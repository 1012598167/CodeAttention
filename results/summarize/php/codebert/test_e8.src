442	public function hasEventHandlers ( $ name ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( ! empty ( $ handlers ) && StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { return true ; } } return ! empty ( $ this -> _events [ $ name ] ) || Event :: hasHandlers ( $ this , $ name ) ; }
9303	public function setSuccessLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`successLogLifetime` expects integer value!' ) ; } $ this -> options [ 'successLogLifetime' ] = ( int ) $ time ; return $ this ; }
9173	public function reverseTransform ( $ jsonMenuNodes ) { if ( $ jsonMenuNodes instanceof Collection && $ jsonMenuNodes -> count ( ) === 0 ) { return new ArrayCollection ( ) ; } $ this -> allNodes = [ ] ; $ firstNode = json_decode ( $ jsonMenuNodes -> first ( ) ) [ 0 ] ; $ menuItemsArray = $ this -> recursiveNodeHandling ( json_decode ( $ jsonMenuNodes -> first ( ) ) ) ; return new ArrayCollection ( $ menuItemsArray ) ; }
62	public function unlink ( $ path ) { $ unlinked = @ $ this -> unlinkImplementation ( $ path ) ; if ( ! $ unlinked ) { if ( Platform :: isWindows ( ) ) { usleep ( 350000 ) ; $ unlinked = @ $ this -> unlinkImplementation ( $ path ) ; } if ( ! $ unlinked ) { $ error = error_get_last ( ) ; $ message = 'Could not delete ' . $ path . ': ' . @ $ error [ 'message' ] ; if ( Platform :: isWindows ( ) ) { $ message .= "\nThis can be due to an antivirus or the Windows Search Indexer locking the file while they are analyzed" ; } throw new \ RuntimeException ( $ message ) ; } } return true ; }
3655	private function getLabelText ( $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc.' . $ type , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc.' . $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc._default_' , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc._default_' ) { return $ type ; } } return $ label ; }
4128	protected function loadMetadata ( $ className ) { if ( class_exists ( $ className ) ) { return parent :: loadMetadata ( $ className ) ; } throw MappingException :: classNotFound ( $ className ) ; }
12207	public function refresh ( ) { if ( null === $ this -> options || null === $ this -> sourceDir ) { return ; } $ this -> render ( $ this -> sourceDir , $ this -> options , $ this -> username ) ; }
2095	protected function createDateRanges ( ) { if ( ! empty ( $ this -> arrRange ) ) { return ; } $ intYear = date ( 'Y' , $ this -> strDate ) ; $ intMonth = date ( 'm' , $ this -> strDate ) ; $ intDay = date ( 'd' , $ this -> strDate ) ; $ this -> arrRange [ 'day' ] [ 'begin' ] = mktime ( 0 , 0 , 0 , $ intMonth , $ intDay , $ intYear ) ; $ this -> arrRange [ 'day' ] [ 'end' ] = mktime ( 23 , 59 , 59 , $ intMonth , $ intDay , $ intYear ) ; $ this -> arrRange [ 'month' ] [ 'begin' ] = mktime ( 0 , 0 , 0 , $ intMonth , 1 , $ intYear ) ; $ this -> arrRange [ 'month' ] [ 'end' ] = mktime ( 23 , 59 , 59 , $ intMonth , date ( 't' , $ this -> strDate ) , $ intYear ) ; $ this -> arrRange [ 'year' ] [ 'begin' ] = mktime ( 0 , 0 , 0 , 1 , 1 , $ intYear ) ; $ this -> arrRange [ 'year' ] [ 'end' ] = mktime ( 23 , 59 , 59 , 12 , 31 , $ intYear ) ; }
12751	public function sendWelcomeMessage ( User $ user , Token $ token = null ) { return $ this -> sendMessage ( $ user -> email , $ this -> welcomeSubject , 'welcome' , [ 'user' => $ user , 'token' => $ token ] ) ; }
12853	public function import ( Package $ package , $ id = null ) { $ id = is_null ( $ id ) ? $ package -> id : $ id ; $ this -> symbols = array_merge ( $ package -> symbols , $ this -> symbols ) ; $ this -> macros = array_merge ( $ package -> macros , $ this -> macros ) ; $ this -> packages [ $ id ] = $ package ; }
8991	public function build ( $ attributes = null ) { if ( $ attributes instanceof \ ElggEntity ) { return $ attributes ; } if ( is_numeric ( $ attributes ) ) { return $ this -> get ( $ attributes ) ; } $ attributes = ( array ) $ attributes ; if ( ! empty ( $ attributes [ 'guid' ] ) ) { return $ this -> get ( $ attributes [ 'guid' ] ) ; } $ type = elgg_extract ( 'type' , $ attributes , 'object' ) ; $ subtype = elgg_extract ( 'subtype' , $ attributes , ELGG_ENTITIES_ANY_VALUE ) ; unset ( $ attributes [ 'type' ] ) ; unset ( $ attributes [ 'subtype' ] ) ; $ class = get_subtype_class ( $ type , $ subtype ) ; if ( class_exists ( $ class ) ) { $ entity = new $ class ( ) ; } else { switch ( $ type ) { case 'object' : $ entity = new \ ElggObject ( ) ; $ entity -> subtype = $ subtype ; break ; case 'user' : $ entity = new \ ElggUser ( ) ; $ entity -> subtype = $ subtype ; break ; case 'group' : $ entity = new \ ElggGroup ( ) ; $ entity -> subtype = $ subtype ; break ; } } foreach ( $ attributes as $ key => $ value ) { if ( in_array ( $ key , $ this -> getAttributeNames ( $ entity ) ) ) { $ entity -> $ key = $ value ; } } return $ entity ; }
10473	public function renewItem ( $ user_id , $ item_id ) { $ request = new RenewRequest ( $ user_id , $ item_id ) ; $ this -> emit ( 'request.renew' , array ( $ user_id , $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new RenewResponse ( $ response ) ; }
1471	public function createResponseFactory ( Api $ api ) { return new Responses ( $ this , $ api , $ this -> container -> make ( Route :: class ) , $ this -> container -> make ( 'json-api.exceptions' ) ) ; }
12930	public function attemptConfirmation ( $ code ) { $ token = $ this -> finder -> findToken ( [ 'user_id' => $ this -> id , 'code' => $ code , 'type' => Token :: TYPE_CONFIRMATION , ] ) -> one ( ) ; if ( $ token === null || $ token -> isExpired ) { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'The confirmation link is invalid or expired. Please try requesting a new one.' ) ) ; } else { $ token -> delete ( ) ; $ this -> confirmed_at = time ( ) ; \ Yii :: $ app -> user -> login ( $ this ) ; \ Yii :: getLogger ( ) -> log ( 'User has been confirmed' , Logger :: LEVEL_INFO ) ; if ( $ this -> save ( false ) ) { \ Yii :: $ app -> session -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Thank you, registration is now complete.' ) ) ; } else { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'Something went wrong and your account has not been confirmed.' ) ) ; } } }
844	public function clearEmptyTokens ( ) { $ limit = $ this -> count ( ) ; $ index = 0 ; for ( ; $ index < $ limit ; ++ $ index ) { if ( $ this -> isEmptyAt ( $ index ) ) { break ; } } if ( $ limit === $ index ) { return ; } for ( $ count = $ index ; $ index < $ limit ; ++ $ index ) { if ( ! $ this -> isEmptyAt ( $ index ) ) { $ this [ $ count ++ ] = $ this [ $ index ] ; } } $ this -> setSize ( $ count ) ; }
9352	public function cofactor ( ) { $ c = new self ( $ this -> size -> rows , $ this -> size -> cols ) ; for ( $ m = 0 ; $ m < $ this -> size -> rows ; $ m ++ ) { $ arr_row = array ( ) ; for ( $ n = 0 ; $ n < $ this -> size -> cols ; $ n ++ ) { if ( $ this -> size -> cols == 2 ) { $ arr_row [ ] = pow ( - 1 , $ m + $ n ) * $ this -> subMatrix ( $ m , $ n ) -> get ( 0 , 0 ) ; } else { $ arr_row [ ] = pow ( - 1 , $ m + $ n ) * $ this -> subMatrix ( $ m , $ n ) -> det ( ) ; } } $ c -> addRow ( $ arr_row ) ; } return $ c ; }
3561	protected function getMutatedType ( $ value , $ dir = 'setter' ) { foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ this -> getValueType ( $ value ) == $ mutated || $ value instanceof $ mutated ) { return $ mutated ; } } }
12404	public function transaction ( ) { $ transaction_id = Parser :: beginTransaction ( $ this -> connection ) ; $ connection = clone $ this -> connection ; $ connection -> transactionId = $ transaction_id ; return new Service ( $ connection ) ; }
5400	protected function truncateHost ( $ host ) { $ tlds = SimpleUrl :: getAllTopLevelDomains ( ) ; if ( preg_match ( '/[a-z\-]+\.(' . $ tlds . ')$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } elseif ( preg_match ( '/[a-z\-]+\.[a-z\-]+\.[a-z\-]+$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } return false ; }
8993	public function expecting ( ) { $ possibilities = count ( $ this -> samples ) ; $ orderedByOccurance = array_count_values ( $ this -> samples ) ; array_multisort ( $ orderedByOccurance , SORT_DESC ) ; $ probabilities = [ ] ; foreach ( $ orderedByOccurance as $ item => $ value ) { $ probabilities [ $ item ] = $ value / $ possibilities ; } return $ probabilities ; }
4571	public function setAnonymousUuid ( ? string $ anonymousUuid ) { $ this -> anonymousUuid = $ anonymousUuid ; $ this -> _anonymousUuid = true ; return $ this ; }
2342	protected function getUserId ( ) { if ( $ this -> intUserId !== null ) { return $ this -> intUserId ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> id ; }
11861	public function getCompanionId ( ) { if ( $ this -> isForeign && isset ( $ this -> foreignPrimaryKey ) ) { return $ this -> foreignPrimaryKey ; } elseif ( ! $ this -> isForeign && isset ( $ this -> localPrimaryKey ) ) { return $ this -> localPrimaryKey ; } if ( isset ( $ this -> companionObject ) ) { return $ this -> companionObject -> primaryKey ; } return ; }
3358	public function resize ( $ width = false , $ height = false ) { if ( ! $ width && ! $ height ) { throw new \ Exception ( 'Please, provide at least $width or $height for resize' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'resize' ] = array ( 'width' => $ width , 'height' => $ height , ) ; return $ result ; }
4970	public function process ( array $ event ) { $ event = parent :: process ( $ event ) ; $ event [ 'uniqueId' ] = substr ( $ event [ 'extra' ] [ 'requestId' ] , 0 , 7 ) ; unset ( $ event [ 'extra' ] [ 'requestId' ] ) ; return $ event ; }
6494	private function rankAcceptMediaTypeHeaders ( array $ mediaTypeHeaders ) : array { usort ( $ mediaTypeHeaders , [ $ this , 'compareAcceptMediaTypeHeaders' ] ) ; $ rankedMediaTypeHeaders = array_filter ( $ mediaTypeHeaders , [ $ this , 'filterZeroScores' ] ) ; return array_values ( $ rankedMediaTypeHeaders ) ; }
12910	public function group ( $ group ) { if ( ! is_array ( $ group ) ) { $ this -> group = array ( $ group ) ; } else { $ this -> group = $ group ; } return $ this ; }
5790	private function setDefaultValue ( $ columnDefault ) { if ( is_null ( $ columnDefault ) ) { $ this -> defaultValue = '' ; } else { switch ( $ this -> type ) { case 'character' : case 'character varying' : case 'text' : case 'USER-DEFINED' : $ parseColumnDefault = explode ( "'" , $ columnDefault ) ; $ this -> defaultValue = $ parseColumnDefault [ 1 ] ; break ; case 'boolean' : if ( $ columnDefault == 'true' ) { $ this -> defaultValue = Postgres :: BOOLEAN_TRUE ; } break ; default : $ this -> defaultValue = $ columnDefault ; } } }
1685	public function checkAdminDisable ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == 1 && $ this -> User -> id == $ dc -> id ) { $ varValue = '' ; } return $ varValue ; }
7031	private function findMatchingShipmentItem ( InvoiceLineInterface $ line , ShipmentInterface $ shipment ) { $ saleItem = $ line -> getSaleItem ( ) ; foreach ( $ shipment -> getItems ( ) as $ shipmentItem ) { if ( $ saleItem === $ shipmentItem -> getSaleItem ( ) ) { return $ shipmentItem ; } } return null ; }
12570	public function previewNews ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_NEWS , $ message , $ to , $ by ) ; }
1508	public static function fromArray ( array $ url ) : self { return new self ( isset ( $ url [ 'host' ] ) ? $ url [ 'host' ] : '' , isset ( $ url [ 'namespace' ] ) ? $ url [ 'namespace' ] : '' , isset ( $ url [ 'name' ] ) ? $ url [ 'name' ] : '' ) ; }
11404	public function changeAction ( ) { $ theme = $ this -> container -> get ( 'request' ) -> request -> get ( 'admin_theme' ) ; $ this -> container -> get ( 'vince_t.admin.theme.handler' ) -> setCurrentTheme ( $ theme ) ; $ headers = $ this -> container -> get ( 'request' ) -> server -> getHeaders ( ) ; $ referer = $ headers [ 'REFERER' ] ; return new RedirectResponse ( $ referer ) ; }
11185	public function addMatch ( string $ method , string $ uri , $ next ) { $ method = strtoupper ( $ method ) ; if ( ! in_array ( $ method , $ this -> supported_methods ) ) { throw new Exception ( "Method " . $ method . " is not supported." ) ; } if ( ! is_string ( $ uri ) ) { throw new Exception ( "Uri " . $ uri . " is not valid." ) ; } if ( is_callable ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => true , $ this -> ARRAY_CALLABLE_KEY => $ next ) ; } elseif ( is_string ( $ next ) ) { if ( file_exists ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ next ) ; } else { $ dir_next = __DIR__ . "/" . $ next ; if ( file_exists ( $ dir_next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ dir_next ) ; } else { throw new Exception ( "File " . $ next . " not found." ) ; } } } else { throw new Exception ( "Invalid third parameter. Expecting callable or file." ) ; } array_push ( $ this -> match_list , $ new_match ) ; }
4326	public static function getInterface ( ) { $ return = 'http' ; $ isCliOrCron = \ count ( \ array_filter ( array ( \ defined ( 'STDIN' ) , isset ( $ _SERVER [ 'argv' ] ) , ! \ array_key_exists ( 'REQUEST_METHOD' , $ _SERVER ) , ) ) ) > 0 ; if ( $ isCliOrCron ) { $ return = isset ( $ _SERVER [ 'TERM' ] ) || \ array_key_exists ( 'PATH' , $ _SERVER ) ? 'cli' : 'cron' ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] ) && $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] == 'XMLHttpRequest' ) { $ return = 'ajax' ; } return $ return ; }
4333	private static function buildAttribBoolVal ( $ key , $ value = true ) { if ( $ key == 'autocomplete' ) { $ value = $ value ? 'on' : 'off' ; } elseif ( $ key == 'spellcheck' ) { $ value = $ value ? 'true' : 'false' ; } elseif ( $ key == 'translate' ) { $ value = $ value ? 'yes' : 'no' ; } elseif ( $ value ) { $ value = $ key ; } else { $ value = null ; } return $ value ; }
10641	public function andWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
9846	public function createSealedRequest ( string $ method , string $ uri , string $ body , SealingPublicKey $ key , array $ headers = [ ] ) : RequestInterface { return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: seal ( $ body , $ key ) ) ) , [ ] ) ; }
11722	public function getPosts ( $ limit = null , $ offset = null ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; if ( is_null ( $ limit ) && is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) ) ; } elseif ( is_null ( $ limit ) && ! is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) , $ limit ) ; } elseif ( ! is_null ( $ limit ) && ! is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) , $ limit , $ offset ) ; } return $ entities ; }
7884	public function getShow ( $ date , $ level = null ) { $ logs = LogViewer :: logs ( ) ; if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ page = Input :: get ( 'page' ) ; if ( empty ( $ page ) ) { $ page = '1' ; } $ data = [ 'logs' => $ logs , 'date' => $ date , 'url' => 'logviewer' , 'data_url' => URL :: route ( 'logviewer.index' ) . '/data/' . $ date . '/' . $ level . '?page=' . $ page , 'levels' => LogViewer :: levels ( ) , 'current' => $ level , ] ; return View :: make ( 'logviewer::show' , $ data ) ; }
9197	public function getTag ( ) { if ( null !== $ this -> tag ) { return $ this -> tag ; } $ categoryId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'categoryid' ) ; if ( is_numeric ( $ categoryId ) ) { return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ categoryId ) ; } $ topicId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'topicid' ) ; if ( is_numeric ( $ topicId ) ) { $ topic = $ this -> getDiscussService ( ) -> getTopicById ( $ topicId ) ; return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ topic -> getforumCategoryId ( ) ) ; } return false ; }
3481	private static function includeConfigurationFile ( ) { static $ included = false ; if ( $ included ) { return ; } $ file = __DIR__ . '/config.php' ; if ( ! file_exists ( $ file ) ) { print sprintf ( 'The configuration file "%s" was not found.%sPlease copy %s/config.php.dist to %s/config.php and modify new file for set own parameters.%s' , $ file , PHP_EOL , __DIR__ , __DIR__ , PHP_EOL ) ; exit ( 1 ) ; } $ included = true ; include_once $ file ; }
11778	public function startAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , ) ; return parent :: start ( $ options ) ; }
7452	protected function renderRTL ( ) : string { $ trail = '' ; if ( $ this -> after ) { $ trail .= '<span class="after">' . $ this -> after . '</span> ' ; } $ trail .= \ join ( ' <span class="sep delimiter">' . $ this -> delimiter . '</span> ' , \ array_reverse ( $ this -> links ) ) ; if ( $ this -> before ) { $ trail .= ' <span class="before">' . $ this -> before . '</span>' ; } return $ trail ; }
5011	public function getLogger ( ) : LoggerInterface { if ( ! $ this -> logger ) { $ logger = new class implements LoggerInterface { public function emerg ( $ message , $ extra = [ ] ) : void { } public function alert ( $ message , $ extra = [ ] ) : void { } public function crit ( $ message , $ extra = [ ] ) : void { } public function err ( $ message , $ extra = [ ] ) : void { } public function warn ( $ message , $ extra = [ ] ) : void { } public function notice ( $ message , $ extra = [ ] ) : void { } public function info ( $ message , $ extra = [ ] ) : void { } public function debug ( $ message , $ extra = [ ] ) : void { } } ; $ this -> setLogger ( $ logger ) ; } return $ this -> logger ; }
262	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } if ( $ model -> delete ( ) === false ) { throw new ServerErrorHttpException ( 'Failed to delete the object for unknown reason.' ) ; } Yii :: $ app -> getResponse ( ) -> setStatusCode ( 204 ) ; }
4807	public function schedule_event ( ) { if ( $ this -> is_scheduled ( $ this -> args [ 'name' ] ) ) { return ; } if ( $ this -> args [ 'run_on_creation' ] ) { call_user_func ( $ this -> args [ 'cb' ] , $ this -> args [ 'args' ] ) ; } if ( $ this -> args [ 'schedule' ] === 'schedule' ) { wp_schedule_event ( $ this -> args [ 'time' ] , $ this -> args [ 'recurrence' ] , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } elseif ( $ this -> args [ 'schedule' ] === 'single' ) { wp_schedule_single_event ( $ this -> args [ 'recurrence' ] , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } if ( is_multisite ( ) && ! wp_is_large_network ( ) ) { $ sites = ( array ) get_site_option ( $ this -> args [ 'name' ] . '_sites' , array ( ) ) ; $ sites [ ] = get_current_blog_id ( ) ; update_site_option ( $ this -> args [ 'name' ] . '_sites' , $ sites ) ; } return true ; }
4510	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getUuid ( ) ) ; $ event -> setData ( $ data ) ; }
1051	public static function getArgumentValues ( $ def , $ node , $ variableValues = null ) { if ( empty ( $ def -> args ) ) { return [ ] ; } $ argumentNodes = $ node -> arguments ; if ( empty ( $ argumentNodes ) ) { return [ ] ; } $ argumentValueMap = [ ] ; foreach ( $ argumentNodes as $ argumentNode ) { $ argumentValueMap [ $ argumentNode -> name -> value ] = $ argumentNode -> value ; } return static :: getArgumentValuesForMap ( $ def , $ argumentValueMap , $ variableValues , $ node ) ; }
4334	public function getCfg ( $ path = null ) { if ( $ path == 'outputAs' ) { $ ret = $ this -> cfg [ 'outputAs' ] ; if ( ! $ ret ) { $ ret = $ this -> getDefaultOutputAs ( ) ; } } elseif ( $ path == 'css' ) { $ ret = $ this -> getCss ( ) ; } else { $ ret = $ this -> debug -> utilities -> arrayPathGet ( $ this -> cfg , $ path ) ; } return $ ret ; }
3008	public function getAttribute ( $ key ) { if ( ! isset ( $ this -> attributes [ $ key ] ) ) { return false ; } return $ this -> attributes [ $ key ] ; }
1829	public function delete ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ intAffected = Database :: getInstance ( ) -> prepare ( "DELETE FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) -> affectedRows ; if ( $ intAffected ) { Registry :: getInstance ( ) -> unregister ( $ this ) ; $ this -> arrData [ static :: $ strPk ] = null ; } return $ intAffected ; }
4093	public function wildcard ( $ val , $ field = false ) { $ this -> wildcard = ( $ field ) ? array ( $ field => $ val ) : $ val ; return $ this ; }
5332	public static function haikunate ( array $ params = [ ] ) { $ defaults = [ "delimiter" => "-" , "tokenLength" => 4 , "tokenHex" => false , "tokenChars" => "0123456789" , ] ; $ params = array_merge ( $ defaults , $ params ) ; if ( $ params [ "tokenHex" ] == true ) { $ params [ "tokenChars" ] = "0123456789abcdef" ; } $ adjective = self :: $ ADJECTIVES [ mt_rand ( 0 , count ( self :: $ ADJECTIVES ) - 1 ) ] ; $ noun = self :: $ NOUNS [ mt_rand ( 0 , count ( self :: $ NOUNS ) - 1 ) ] ; $ token = "" ; for ( $ i = 0 ; $ i < $ params [ "tokenLength" ] ; $ i ++ ) { $ token .= $ params [ "tokenChars" ] [ mt_rand ( 0 , strlen ( $ params [ "tokenChars" ] ) - 1 ) ] ; } $ sections = [ $ adjective , $ noun , $ token ] ; return implode ( $ params [ "delimiter" ] , array_filter ( $ sections ) ) ; }
6089	public function updateMoodboard ( $ id , Moodboard $ moodboard ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'moodboard' => $ moodboard ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards/' . $ id . '' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
11308	public function entityFromBody ( $ body , $ entity ) { $ json = $ this -> decodeJson ( $ body ) ; return $ entity -> populate ( $ json ) ; }
6857	protected static function equinoxSeptember ( $ year , $ vsop = true ) { $ month = 9 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
8508	public function getPrepInstructionsForASIN ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForASINRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForASINRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForASIN' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForASINResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5608	public function after ( $ method ) { $ this -> invoker -> after ( $ method ) ; $ output = ob_get_contents ( ) ; ob_end_clean ( ) ; if ( $ output !== '' ) { $ result = $ this -> listener -> write ( '{status:"info",message:"' . EclipseReporter :: escapeVal ( $ output ) . '"}' ) ; } }
1421	protected function createBelongsToIdentity ( Model $ model , $ relationshipKey ) { $ relation = $ model -> { $ relationshipKey } ( ) ; if ( ! $ relation instanceof BelongsTo ) { throw new RuntimeException ( sprintf ( 'Expecting %s on %s to be a belongs-to relationship.' , $ relationshipKey , get_class ( $ model ) ) ) ; } $ foreignKey = method_exists ( $ relation , 'getForeignKeyName' ) ? $ relation -> getForeignKeyName ( ) : $ relation -> getForeignKey ( ) ; $ id = $ model -> { $ foreignKey } ; if ( is_null ( $ id ) ) { return null ; } $ ownerKey = method_exists ( $ relation , 'getOwnerKeyName' ) ? $ relation -> getOwnerKeyName ( ) : $ relation -> getOwnerKey ( ) ; $ related = $ relation -> getRelated ( ) -> replicate ( ) ; $ related -> { $ ownerKey } = $ id ; return $ related ; }
3320	public function getValidValues ( ) { if ( $ this -> validValues ) { if ( is_callable ( $ this -> validValues ) ) { return call_user_func ( $ this -> validValues ) ; } return $ this -> validValues ; } return ; }
1004	public function parseRequestParams ( $ method , array $ bodyParams , array $ queryParams ) { if ( $ method === 'GET' ) { $ result = OperationParams :: create ( $ queryParams , true ) ; } elseif ( $ method === 'POST' ) { if ( isset ( $ bodyParams [ 0 ] ) ) { $ result = [ ] ; foreach ( $ bodyParams as $ index => $ entry ) { $ op = OperationParams :: create ( $ entry ) ; $ result [ ] = $ op ; } } else { $ result = OperationParams :: create ( $ bodyParams ) ; } } else { throw new RequestError ( 'HTTP Method "' . $ method . '" is not supported' ) ; } return $ result ; }
11854	public function getHeader ( string $ name ) : ? string { $ name = strtolower ( $ name ) ; foreach ( $ this -> getAllHeaders ( ) as $ key => $ value ) { if ( strtolower ( $ key ) === $ name ) { return $ value ; } } return null ; }
434	private function isIncorrectClassNameOrPrefix ( $ className , $ prefix ) { if ( ! preg_match ( '%^[a-z][a-z0-9\\-_]*$%' , $ className ) ) { return true ; } if ( $ prefix !== '' && ! preg_match ( '%^[a-z0-9_/]+$%i' , $ prefix ) ) { return true ; } return false ; }
9430	public function getFontIconTag ( ) { if ( $ this -> owner -> hasFontIcon ( ) ) { return $ this -> backend -> getTag ( $ this -> owner -> FontIconClass , $ this -> owner -> FontIconColor ) ; } }
3483	public function withMutableContent ( bool $ mutableContent ) : Aps { $ cloned = clone $ this ; $ cloned -> mutableContent = $ mutableContent ; return $ cloned ; }
7634	public function putBlockList ( $ containerName = '' , $ blobName = '' , $ blockList = array ( ) , $ metadata = array ( ) , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; Assertion :: notEmpty ( $ blockList , 'Block list does not contain any elements.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ blocks = '' ; foreach ( $ blockList as $ block ) { $ blocks .= ' <Latest>' . base64_encode ( $ block ) . '</Latest>' . "\n" ; } $ fileContents = utf8_encode ( implode ( "\n" , array ( '<?xml version="1.0" encoding="utf-8"?>' , '<BlockList>' , $ blocks , '</BlockList>' ) ) ) ; $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , array ( 'comp' => 'blocklist' ) , 'PUT' , $ headers , false , $ fileContents , self :: RESOURCE_BLOB , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
573	public function compareString ( $ expected , $ actual ) { if ( ! is_string ( $ expected ) ) { throw new InvalidArgumentException ( 'Expected expected value to be a string, ' . gettype ( $ expected ) . ' given.' ) ; } if ( ! is_string ( $ actual ) ) { throw new InvalidArgumentException ( 'Expected actual value to be a string, ' . gettype ( $ actual ) . ' given.' ) ; } if ( function_exists ( 'hash_equals' ) ) { return hash_equals ( $ expected , $ actual ) ; } $ expected .= "\0" ; $ actual .= "\0" ; $ expectedLength = StringHelper :: byteLength ( $ expected ) ; $ actualLength = StringHelper :: byteLength ( $ actual ) ; $ diff = $ expectedLength - $ actualLength ; for ( $ i = 0 ; $ i < $ actualLength ; $ i ++ ) { $ diff |= ( ord ( $ actual [ $ i ] ) ^ ord ( $ expected [ $ i % $ expectedLength ] ) ) ; } return $ diff === 0 ; }
8298	protected function removeBkFile ( ) { if ( ! $ this -> options [ "backup" ] ) { return ; } if ( ! $ this -> writeErrors && $ this -> bkFilePath ) { unlink ( $ this -> bkFilePath ) ; } }
247	public function init ( ) { parent :: init ( ) ; register_shutdown_function ( [ $ this , 'close' ] ) ; if ( $ this -> getIsActive ( ) ) { Yii :: warning ( 'Session is already started' , __METHOD__ ) ; $ this -> updateFlashCounters ( ) ; } }
7093	private function checkHierarchyIntegrity ( InvoiceInterface $ invoice ) { if ( null !== $ shipment = $ invoice -> getShipment ( ) ) { if ( $ invoice -> getSale ( ) !== $ shipment -> getSale ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isCredit ( $ invoice ) && ! $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isInvoice ( $ invoice ) && $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } } }
1796	private function addIndexRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/' , $ defaults ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_index' , $ route ) ; }
3007	public function setLayout ( $ layout ) { if ( $ layout === "" || $ layout === null ) { $ this -> layout = null ; } else { $ layoutPath = $ this -> templatePath . $ layout ; if ( ! is_file ( $ layoutPath ) ) { throw new \ RuntimeException ( "Layout template `$layout` does not exist" ) ; } $ this -> layout = $ layoutPath ; } }
9542	public function runSyncAction ( $ syncActionBaseUrl , $ component , $ action , array $ configData ) { $ uriParts = [ ] ; if ( $ this -> super ) { $ uriParts [ ] = $ this -> super ; } $ uriParts [ ] = $ component ; $ uriParts [ ] = 'action' ; $ uriParts [ ] = $ action ; $ uri = rtrim ( $ syncActionBaseUrl , '/' ) . '/' . implode ( '/' , $ uriParts ) ; $ body = [ 'configData' => $ configData , ] ; try { $ request = new Request ( 'POST' , $ uri , [ ] , json_encode ( $ body ) ) ; $ response = $ this -> guzzle -> send ( $ request ) ; } catch ( RequestException $ e ) { throw new ClientException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return $ this -> decodeResponse ( $ response ) ; }
9209	protected function findKey ( Table $ Table , Entity $ entity ) { if ( ! empty ( $ entity -> { $ Table -> primaryKey ( ) } ) ) { $ key = $ entity -> { $ Table -> primaryKey ( ) } ; } else { $ key = 'unknown' ; } return $ key ; }
10040	public function load ( $ pFilename ) { $ spreadsheet = new Spreadsheet ( ) ; $ spreadsheet -> removeSheetByIndex ( 0 ) ; return $ this -> loadIntoExisting ( $ pFilename , $ spreadsheet ) ; }
11618	private function compressPhase2 ( $ calcIdWriteOff , $ calcIdPhase1 , $ calcIdPhase2 , $ scheme ) { $ pv = $ this -> rouGetPv -> exec ( $ calcIdWriteOff ) ; $ dwnlPlain = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdWriteOff ) ; $ dwnlPhase1 = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdPhase1 ) ; $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_CALC_ID_PHASE2 , $ calcIdPhase2 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_SCHEME , $ scheme ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PLAIN , $ dwnlPlain ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PHASE1 , $ dwnlPhase1 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_MAP_PV , $ pv ) ; $ out = $ this -> procCmprsPhase2 -> exec ( $ ctx ) ; $ dwnlPhase2 = $ out -> get ( PCpmrsPhase2 :: OUT_DWNL_PHASE2 ) ; $ legs = $ out -> get ( PCpmrsPhase2 :: OUT_LEGS ) ; $ result = [ $ dwnlPhase2 , $ legs ] ; return $ result ; }
4707	public function processMultipleUnderScore ( Text $ text ) { $ text -> replace ( '{<pre>.*?</pre>}m' , function ( Text $ w ) { $ md5 = md5 ( $ w ) ; $ this -> hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '/^(?! {4}|\t)(\[?\w+_\w+_\w[\w_]*\]?)/' , function ( Text $ w , Text $ word ) { $ underscores = $ word -> split ( '//' ) -> filter ( function ( Text $ item ) { return $ item == '_' ; } ) ; if ( count ( $ underscores ) >= 2 ) { $ word -> replaceString ( '_' , '\\_' ) ; } return $ word ; } ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) { return "\n\n" . $ this -> hashes [ ( string ) $ md5 ] ; } ) ; }
11476	public function authenticate ( Zend_Auth_Adapter_Interface $ adapter ) { $ result = $ adapter -> authenticate ( ) ; if ( $ this -> hasIdentity ( ) ) { $ this -> clearIdentity ( ) ; } if ( $ result -> isValid ( ) ) { $ this -> getStorage ( ) -> write ( $ adapter -> getResultRowObject ( ) ) ; } return $ result ; }
858	public function setCode ( $ code ) { if ( $ code === $ this -> generateCode ( ) ) { return ; } $ this -> setSize ( 0 ) ; $ tokens = \ defined ( 'TOKEN_PARSE' ) ? token_get_all ( $ code , TOKEN_PARSE ) : token_get_all ( $ code ) ; $ this -> setSize ( \ count ( $ tokens ) ) ; foreach ( $ tokens as $ index => $ token ) { $ this [ $ index ] = new Token ( $ token ) ; } $ transformers = Transformers :: create ( ) ; $ transformers -> transform ( $ this ) ; $ this -> foundTokenKinds = [ ] ; foreach ( $ this as $ token ) { $ this -> registerFoundToken ( $ token ) ; } $ this -> rewind ( ) ; $ this -> changeCodeHash ( self :: calculateCodeHash ( $ code ) ) ; $ this -> changed = true ; }
12243	public function XSLT ( $ filepath , $ use_xslcache = true ) { if ( $ use_xslcache && extension_loaded ( 'xslcache' ) ) { $ xslt = new XSLTCache ; $ xslt -> importStylesheet ( $ filepath ) ; } else { $ xsl = new DOMDocument ; $ xsl -> load ( $ filepath ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; } return $ xslt -> transformToXML ( dom_import_simplexml ( $ this ) ) ; }
2557	protected function loadMopDetails ( MopInfo $ options ) { $ this -> mopDetails = new MopDetails ( ) ; if ( $ this -> checkAnyNotEmpty ( $ options -> fopCode , $ options -> fopStatus ) ) { $ this -> mopDetails -> fopPNRDetails = new FopPNRDetails ( $ options -> fopCode , $ options -> fopStatus ) ; } if ( ! empty ( $ options -> freeFlowText ) ) { $ this -> mopDetails -> oldFopFreeflow = new OldFopFreeflow ( $ options -> freeFlowText , $ options -> freeFlowEncoding ) ; } if ( ! empty ( $ options -> supplementaryData ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_DATA_INFORMATION , $ options -> supplementaryData ) ; } if ( ! empty ( $ options -> supplementarySwitches ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_SWITCH_INFORMATION , $ options -> supplementarySwitches ) ; } }
7234	protected function assertItemClass ( Common \ SaleItemInterface $ child ) { if ( ! $ child instanceof Model \ CartItemInterface ) { throw new InvalidArgumentException ( "Expected instance of " . Model \ CartItemInterface :: class ) ; } }
7085	public function setDbQueryConditionsForDefaultOptionsLoader ( $ conditonsAndOptions ) { if ( ! is_array ( $ conditonsAndOptions ) && ! ( $ conditonsAndOptions instanceof DbExpr ) && ! ( $ conditonsAndOptions instanceof \ Closure ) ) { throw new \ InvalidArgumentException ( '$conditonsAndOptions argument must be a string, DbExpr or a Closure' ) ; } $ this -> dbQueryConditionsForDefaultOptionsLoader = $ conditonsAndOptions ; return $ this ; }
3611	public function getNextScheduledEvent ( $ serial_number = NULL ) { $ schedule = $ this -> getDeviceSchedule ( $ serial_number ) ; $ next_event = FALSE ; $ time = date ( 'H' ) * 60 + date ( 'i' ) ; for ( $ i = 0 , $ day = date ( 'D' ) ; $ i ++ < 7 ; $ day = date ( 'D' , strtotime ( "+ $i days" ) ) ) { if ( isset ( $ schedule [ $ day ] ) ) { foreach ( $ schedule [ $ day ] as $ event ) { if ( $ event -> time > $ time ) { return $ event ; } } } $ time = 0 ; } return $ next_event ; }
12455	public function hasToolbar ( ) { $ fileSkeleton = '/Resources/views/Editor/Toolbar/_toolbar_%s_buttons.html.twig' ; return file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'left' ) ) || file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'right' ) ) ; }
4596	public function getList ( ) : array { $ objects = $ this -> execute ( 'GET' , static :: RESOURCE_LIST ) ; $ list = [ ] ; foreach ( $ objects as $ name => $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
10507	private function registerFilesystem ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ Filesystem :: class , function ( $ app ) { $ files = $ app [ 'files' ] ; $ filesystem = new Utilities \ Filesystem ( $ files , storage_path ( 'logs' ) ) ; $ filesystem -> setPattern ( Utilities \ Filesystem :: PATTERN_PREFIX , Utilities \ Filesystem :: PATTERN_DATE , Utilities \ Filesystem :: PATTERN_EXTENSION ) ; return $ filesystem ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.filesystem' , Contracts \ Utilities \ Filesystem :: class ) ; }
4325	public static function getCallerInfo ( $ offset = 0 ) { $ return = array ( 'file' => null , 'line' => null , 'function' => null , 'class' => null , 'type' => null , ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS | DEBUG_BACKTRACE_PROVIDE_OBJECT , 8 ) ; $ numFrames = \ count ( $ backtrace ) ; $ regexInternal = '/^' . \ preg_quote ( __NAMESPACE__ ) . '\b/' ; if ( isset ( $ backtrace [ 1 ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ 1 ] [ 'class' ] ) ) { for ( $ i = $ numFrames - 1 ; $ i >= 0 ; $ i -- ) { if ( isset ( $ backtrace [ $ i ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ $ i ] [ 'class' ] ) ) { break ; } } } else { $ i = 1 ; } $ i += $ offset ; $ iLine = $ i ; $ iFunc = $ i + 1 ; if ( isset ( $ backtrace [ $ iFunc ] ) && \ in_array ( $ backtrace [ $ iFunc ] [ 'function' ] , array ( 'call_user_func' , 'call_user_func_array' ) ) ) { $ iLine ++ ; $ iFunc ++ ; } elseif ( isset ( $ backtrace [ $ iFunc ] [ 'class' ] ) && $ backtrace [ $ iFunc ] [ 'class' ] == 'ReflectionMethod' && $ backtrace [ $ iFunc ] [ 'function' ] == 'invoke' ) { $ iLine ++ ; $ iFunc -- ; } if ( isset ( $ backtrace [ $ iFunc ] ) ) { $ return = \ array_merge ( $ return , \ array_intersect_key ( $ backtrace [ $ iFunc ] , $ return ) ) ; if ( $ return [ 'type' ] == '->' ) { $ return [ 'class' ] = \ get_class ( $ backtrace [ $ iFunc ] [ 'object' ] ) ; } } if ( isset ( $ backtrace [ $ iLine ] ) ) { $ return [ 'file' ] = $ backtrace [ $ iLine ] [ 'file' ] ; $ return [ 'line' ] = $ backtrace [ $ iLine ] [ 'line' ] ; } else { $ return [ 'file' ] = $ backtrace [ $ numFrames - 1 ] [ 'file' ] ; $ return [ 'line' ] = 0 ; } return $ return ; }
9460	public function deleteTickets ( array $ tickets ) { $ ids = array ( ) ; foreach ( $ tickets as $ ticket ) { $ ids [ ] = $ ticket -> getId ( ) ; } return parent :: deleteByIds ( $ ids , 'tickets/destroy_many.json' ) ; }
9960	public function setAutoFilterByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { return $ this -> setAutoFilter ( Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ) ; }
9843	public function createSignedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SigningSecretKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSignedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
4824	public function removeValue ( $ fieldName , $ value ) { $ result = $ this -> row [ $ fieldName ] ; if ( ! is_array ( $ result ) ) { if ( $ value == $ result ) { unset ( $ this -> row [ $ fieldName ] ) ; $ this -> informChanges ( ) ; } } else { $ qty = count ( $ result ) ; for ( $ i = 0 ; $ i < $ qty ; $ i ++ ) { if ( $ result [ $ i ] == $ value ) { unset ( $ result [ $ i ] ) ; $ this -> informChanges ( ) ; } } $ this -> row [ $ fieldName ] = array_values ( $ result ) ; } }
2567	protected function checkAllNotEmpty ( ) { $ foundEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( empty ( $ arg ) ) { $ foundEmpty = true ; break ; } } return ! $ foundEmpty ; }
5	private function buildDepPackageConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { if ( ! array_key_exists ( 'channel' , $ subDepItem ) ) { $ subDepItem [ 'channel' ] = $ subDepItem [ 'uri' ] ; } $ depChannelName = $ subDepItem [ 'channel' ] ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; if ( isset ( $ subDepItem [ 'conflicts' ] ) ) { $ depType = 'conflicts' ; } $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
3332	public function fromContent ( $ content , $ mime_type ) { $ tmpfile = tempnam ( sys_get_temp_dir ( ) , 'ucr' ) ; $ temp = fopen ( $ tmpfile , 'w' ) ; fwrite ( $ temp , $ content ) ; fclose ( $ temp ) ; return $ this -> fromPath ( $ tmpfile , $ mime_type ) ; }
11438	public function getDefault ( $ name ) { return isset ( $ this -> options [ 'defaults' ] [ $ name ] ) ? $ this -> options [ 'defaults' ] [ $ name ] : null ; }
8132	public function getSourceContext ( ) { return $ this -> filename ? new Twig_Source ( $ this -> sourceCode , $ this -> filename , $ this -> sourcePath ) : null ; }
1448	protected function dataForRelationship ( $ record , string $ field , array $ document ) : array { $ schema = $ this -> container -> getSchema ( $ record ) ; return [ 'type' => $ schema -> getResourceType ( ) , 'id' => $ schema -> getId ( $ record ) , 'relationships' => [ $ field => [ 'data' => $ document [ 'data' ] , ] , ] , ] ; }
8344	public static function run ( ) { if ( self :: $ isInit === true ) { if ( ( self :: $ rawRequest instanceof RawRequest ) === false ) { throw new RuntimeException ( 'Raw request was not specified!' ) ; } self :: $ request = new Request ( self :: $ rawRequest , self :: $ routes ) ; self :: $ controllers = array ( ) ; self :: $ response = new Response ( ) ; try { ob_start ( ) ; $ before = self :: $ request -> getBefore ( ) ; foreach ( $ before as $ b ) { $ controller = Controllers :: get ( $ b [ 'class' ] ) ; $ action = $ b [ 'action' ] ; $ controller -> $ action ( self :: $ request , self :: $ response ) ; if ( self :: $ request -> hasEnded ( ) === true ) { break ; } } if ( self :: $ request -> hasEnded ( ) === false ) { $ controller = Controllers :: get ( self :: $ request -> getClass ( ) ) ; $ action = self :: $ request -> getAction ( ) ; $ controller -> $ action ( self :: $ request , self :: $ response ) ; if ( self :: $ request -> hasEnded ( ) === false ) { $ after = self :: $ request -> getAfter ( ) ; foreach ( $ after as $ a ) { $ controller = Controllers :: get ( $ a [ 'class' ] ) ; $ action = $ a [ 'action' ] ; $ controller -> $ action ( self :: $ request , self :: $ response ) ; } } } $ render = self :: $ response -> getRender ( ) ; if ( ! ( $ render instanceof RenderInterface ) ) { throw new NotARender ( 'response->render is a non RenderInterface implementing object' ) ; } echo $ render -> render ( self :: $ response -> data ) ; ob_end_flush ( ) ; } catch ( \ Exception $ e ) { ob_end_clean ( ) ; throw $ e ; } } }
3160	protected function storeVariable ( QtiRunnerServiceContext $ context , $ itemUri , \ taoResultServer_models_classes_Variable $ metaVariable , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariable ( $ testUri , $ itemUri , $ metaVariable , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariable ( $ testUri , $ metaVariable , $ sessionId ) ; } return true ; }
7545	function getNamespace ( ) { if ( $ this -> tag_ns === null ) { $ a = explode ( ':' , $ this -> tag , 2 ) ; if ( empty ( $ a [ 1 ] ) ) { $ this -> tag_ns = array ( '' , $ a [ 0 ] ) ; } else { $ this -> tag_ns = array ( $ a [ 0 ] , $ a [ 1 ] ) ; } } return $ this -> tag_ns [ 0 ] ; }
7272	public static function deleteWhere ( $ condition = "" , array $ conditionParams = [ ] ) { $ tableName = static :: tableName ( ) ; if ( empty ( $ condition ) ) return Db :: query ( "delete from $tableName" , [ ] , static :: getDbName ( ) , false ) ; else return Db :: query ( " delete from $tableName where $condition " , $ conditionParams , static :: getDbName ( ) , false ) ; }
5368	public function asMime ( ) { $ part = 'Content-Disposition: form-data; ' ; $ part .= 'name="' . $ this -> key . '"; ' ; $ part .= 'filename="' . $ this -> filename . '"' ; $ part .= "\r\nContent-Type: " . $ this -> deduceMimeType ( ) ; $ part .= "\r\n\r\n" . $ this -> content ; return $ part ; }
3726	public static function createFromQueryBuilder ( QueryBuilder $ builder , $ columnName = 'id' ) { return new self ( $ builder -> getSQL ( ) , $ builder -> getParameters ( ) , $ columnName , $ builder -> getConnection ( ) , $ builder -> getParameterTypes ( ) ) ; }
8613	public function setAdjustmentItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdjustmentItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
971	public function getToken ( bool $ strict = false ) { $ tokens = [ self :: GRANT_PERUSER => Session :: get ( self :: TOKEN ) , self :: GRANT_OFFLINE => $ this -> shop -> { self :: TOKEN } , ] ; if ( $ strict ) { return $ tokens [ $ this -> getType ( ) ] ; } return $ tokens [ self :: GRANT_PERUSER ] ?? $ tokens [ self :: GRANT_OFFLINE ] ; }
5602	public function paintFail ( $ message ) { if ( ! $ this -> fail && ! $ this -> error ) { $ this -> fail = true ; $ this -> message = self :: escapeVal ( $ message ) ; $ this -> listener -> write ( '{status:"fail",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
3874	protected function removeEmptyDetailPages ( $ jumpTos ) { foreach ( $ jumpTos as $ jumpTo ) { $ event = new GetPageDetailsEvent ( $ jumpTo [ 'value' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null ) { continue ; } $ baseUrl = $ this -> getBaseUrl ( $ pageDetails ) ; if ( ( $ strKey = array_search ( $ baseUrl -> getUrl ( ) , $ this -> foundPages ) ) !== false ) { unset ( $ this -> foundPages [ $ strKey ] ) ; } $ baseUrl = $ this -> getBaseUrl ( $ pageDetails , null , true ) ; if ( ( $ strKey = array_search ( $ baseUrl -> getUrl ( ) , $ this -> foundPages ) ) !== false ) { unset ( $ this -> foundPages [ $ strKey ] ) ; } } }
11235	protected function checkReferenceLoop ( $ loop , $ name ) { if ( $ loop > 20 ) { throw new RuntimeException ( Message :: get ( Message :: MSG_REF_LOOP , $ name ) , Message :: MSG_REF_LOOP ) ; } }
9057	public function addPrimaryKey ( string $ name ) : Column { $ column = $ this -> addColumn ( $ name ) ; $ this -> setPrimaryKey ( $ name ) ; return $ column ; }
7036	protected function dropMigrationTable ( ) { try { return Db :: query ( "drop table if exists migrations" , [ ] , $ this -> dbName , false ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
12300	public function storeChild ( $ id , $ relation , array $ data ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } $ resource = $ parent -> $ relation ( ) -> create ( $ data ) ; return $ resource ; }
1306	public function destroy ( $ id , Request $ request ) { $ post = Models :: post ( ) -> with ( 'discussion' ) -> findOrFail ( $ id ) ; if ( $ request -> user ( ) -> id !== ( int ) $ post -> user_id ) { return redirect ( '/' . config ( 'chatter.routes.home' ) ) -> with ( [ 'chatter_alert_type' => 'danger' , 'chatter_alert' => trans ( 'chatter::alert.danger.reason.destroy_post' ) , ] ) ; } if ( $ post -> discussion -> posts ( ) -> oldest ( ) -> first ( ) -> id === $ post -> id ) { if ( config ( 'chatter.soft_deletes' ) ) { $ post -> discussion -> posts ( ) -> delete ( ) ; $ post -> discussion ( ) -> delete ( ) ; } else { $ post -> discussion -> posts ( ) -> forceDelete ( ) ; $ post -> discussion ( ) -> forceDelete ( ) ; } return redirect ( '/' . config ( 'chatter.routes.home' ) ) -> with ( [ 'chatter_alert_type' => 'success' , 'chatter_alert' => trans ( 'chatter::alert.success.reason.destroy_post' ) , ] ) ; } $ post -> delete ( ) ; $ url = '/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.discussion' ) . '/' . $ post -> discussion -> category -> slug . '/' . $ post -> discussion -> slug ; return redirect ( $ url ) -> with ( [ 'chatter_alert_type' => 'success' , 'chatter_alert' => trans ( 'chatter::alert.success.reason.destroy_from_discussion' ) , ] ) ; }
7801	protected function splitTransactions ( $ text ) { $ offset = 0 ; $ length = 0 ; $ position = 0 ; $ transactions = array ( ) ; while ( $ line = $ this -> getLine ( '61' , $ text , $ offset , $ offset , $ length ) ) { $ offset += 4 + $ length + 2 ; $ transaction = array ( $ line ) ; $ description = array ( ) ; while ( $ line = $ this -> getLine ( '86' , $ text , $ offset , $ position , $ length ) ) { if ( $ position == $ offset ) { $ offset += 4 + $ length + 2 ; $ description [ ] = $ line ; } else { break ; } } if ( $ description ) { $ transaction [ ] = implode ( "\r\n" , $ description ) ; } $ transactions [ ] = $ transaction ; } return $ transactions ; }
41	public static function checkCertificateHost ( $ certificate , $ hostname , & $ cn = null ) { $ names = self :: getCertificateNames ( $ certificate ) ; if ( empty ( $ names ) ) { return false ; } $ combinedNames = array_merge ( $ names [ 'san' ] , array ( $ names [ 'cn' ] ) ) ; $ hostname = strtolower ( $ hostname ) ; foreach ( $ combinedNames as $ certName ) { $ matcher = self :: certNameMatcher ( $ certName ) ; if ( $ matcher && $ matcher ( $ hostname ) ) { $ cn = $ names [ 'cn' ] ; return true ; } } return false ; }
3686	protected function getAndOrFilter ( IFilter $ filter , $ operation ) { if ( ! $ operation [ 'children' ] ) { return ; } if ( $ operation [ 'operation' ] == 'AND' ) { $ filterRule = new ConditionAnd ( ) ; } else { $ filterRule = new ConditionOr ( ) ; } $ filter -> addFilterRule ( $ filterRule ) ; $ children = $ this -> optimizedFilter ( $ filterRule , $ operation [ 'children' ] , $ operation [ 'operation' ] ) ; foreach ( $ children as $ child ) { $ subFilter = $ this -> getMetaModel ( ) -> getEmptyFilter ( ) ; $ filterRule -> addChild ( $ subFilter ) ; $ this -> calculateSubfilter ( $ child , $ subFilter ) ; } }
11757	public function delete ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_COMMENT , $ params ] ) ; }
287	public function negotiate ( ) { $ request = $ this -> request ? : Yii :: $ app -> getRequest ( ) ; $ response = $ this -> response ? : Yii :: $ app -> getResponse ( ) ; if ( ! empty ( $ this -> formats ) ) { if ( \ count ( $ this -> formats ) > 1 ) { $ response -> getHeaders ( ) -> add ( 'Vary' , 'Accept' ) ; } $ this -> negotiateContentType ( $ request , $ response ) ; } if ( ! empty ( $ this -> languages ) ) { if ( \ count ( $ this -> languages ) > 1 ) { $ response -> getHeaders ( ) -> add ( 'Vary' , 'Accept-Language' ) ; } Yii :: $ app -> language = $ this -> negotiateLanguage ( $ request ) ; } }
2634	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippet = $ this -> getRequest ( ) -> getParam ( 'snippet_id' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ write = $ this -> filesystem -> getDirectoryWrite ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ write -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ snippet ) ; $ snippetName = explode ( '_' , $ snippet ) ; $ snippetName = explode ( '.' , $ snippetName [ 2 ] ) ; $ reqName = Config :: FASTLY_MAGENTO_MODULE . '_' . $ snippetName [ 0 ] ; $ checkIfSnippetExist = $ this -> api -> hasSnippet ( $ activeVersion , $ reqName ) ; if ( $ checkIfSnippetExist ) { $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ this -> api -> removeSnippet ( $ clone -> number , $ reqName ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ comment = [ 'comment' => 'Magento Module deleted the ' . $ reqName . ' custom snippet.' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; } if ( $ write -> isExist ( $ snippetPath ) ) { $ write -> delete ( $ snippetPath ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
8588	public function setASINPrepInstructions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ASINPrepInstructions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9000	private function fixDirectorySeparator ( $ path ) : string { $ path = str_replace ( "\\" , DIRECTORY_SEPARATOR , $ path ) ; $ path = str_replace ( "/" , DIRECTORY_SEPARATOR , $ path ) ; return $ path ; }
10729	public function getDay ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'day' ] ; } }
1556	protected function queryRulesWithoutSearch ( ) { return collect ( $ this -> queryRules ( ) ) -> reject ( function ( $ value , $ key ) { return Str :: startsWith ( $ key , [ 'filter.' , 'sort.' , 'page.' ] ) ; } ) -> all ( ) ; }
1325	public static function fromConsumerAndToken ( Consumer $ consumer , Token $ token = null , $ httpMethod , $ httpUrl , array $ parameters = [ ] , $ json = false ) { $ defaults = [ "oauth_version" => Request :: $ version , "oauth_nonce" => Request :: generateNonce ( ) , "oauth_timestamp" => time ( ) , "oauth_consumer_key" => $ consumer -> key ] ; if ( null !== $ token ) { $ defaults [ 'oauth_token' ] = $ token -> key ; } if ( $ json ) { $ parameters = $ defaults ; } else { $ parameters = array_merge ( $ defaults , $ parameters ) ; } return new Request ( $ httpMethod , $ httpUrl , $ parameters ) ; }
4775	private function loadUserConfig ( ) { if ( ! $ this -> widgetConfig ) { $ this -> widgetConfig = $ this -> entityManager -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> tokenStorage -> getToken ( ) -> getUser ( ) , ] ) ; if ( null !== $ this -> widgetConfig ) { $ this -> widgetConfig = $ this -> widgetConfig -> getConfig ( ) ; } } }
2289	protected function activateRecipient ( ) { $ this -> Template = new FrontendTemplate ( 'mod_newsletter' ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) < 1 || key ( $ arrRelated ) != 'tl_newsletter_recipients' || \ count ( $ arrIds = current ( $ arrRelated ) ) < 1 ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } $ arrRecipients = array ( ) ; foreach ( $ arrIds as $ intId ) { if ( ! $ objRecipient = NewsletterRecipientsModel :: findByPk ( $ intId ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objRecipient -> email ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ arrRecipients [ ] = $ objRecipient ; } $ time = time ( ) ; $ arrAdd = array ( ) ; $ arrCids = array ( ) ; foreach ( $ arrRecipients as $ objRecipient ) { $ arrAdd [ ] = $ objRecipient -> id ; $ arrCids [ ] = $ objRecipient -> pid ; $ objRecipient -> tstamp = $ time ; $ objRecipient -> active = '1' ; $ objRecipient -> save ( ) ; } $ optInToken -> confirm ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ optInToken -> getEmail ( ) , $ arrAdd , $ arrCids ) ; } } $ this -> Template -> mclass = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_activate' ] ; }
6430	public function completeLogin ( $ extrainputs = array ( ) ) { $ facebook = $ this -> getFacebookObject ( ) ; $ old_GET = $ _GET ; $ _GET = $ extrainputs ; $ helper = $ facebook -> getRedirectLoginHelper ( ) ; $ accessToken = $ helper -> getAccessToken ( ) ; $ _GET = $ old_GET ; if ( ! isset ( $ accessToken ) ) { if ( $ helper -> getError ( ) ) { throw new \ Exception ( $ helper -> getError ( ) . ' ' . $ helper -> getErrorCode ( ) . ' ' . $ helper -> getErrorReason ( ) . ' ' . $ helper -> getErrorDescription ( ) ) ; } else { throw new \ Exception ( 'Unknown error from Facebook' ) ; } } $ this -> accesstoken = $ accessToken ; return $ this -> getUserProfile ( ) ; }
6121	public function permissionGetIdByName ( $ name ) { if ( ! array_key_exists ( ( string ) $ name , $ this -> permissionList ( ) ) ) { throw new Ts3Exception ( "invalid permission ID" , 0xA02 ) ; } return $ this -> permissionList [ ( string ) $ name ] [ "permid" ] ; }
7287	public function getInvoicedAt ( $ latest = false ) { if ( 0 == $ this -> invoices -> count ( ) ) { return null ; } $ criteria = Criteria :: create ( ) ; $ criteria -> andWhere ( Criteria :: expr ( ) -> eq ( 'type' , InvoiceTypes :: TYPE_INVOICE ) ) -> orderBy ( [ 'createdAt' => $ latest ? Criteria :: DESC : Criteria :: ASC ] ) ; $ invoices = $ this -> invoices ; $ invoices = $ invoices -> matching ( $ criteria ) ; if ( false !== $ invoice = $ invoices -> first ( ) ) { return $ invoice -> getCreatedAt ( ) ; } return null ; }
8189	final protected function getContext ( $ context , $ item , $ ignoreStrictCheck = false ) { if ( ! array_key_exists ( $ item , $ context ) ) { if ( $ ignoreStrictCheck || ! $ this -> env -> isStrictVariables ( ) ) { return ; } throw new Twig_Error_Runtime ( sprintf ( 'Variable "%s" does not exist.' , $ item ) , - 1 , $ this -> getSourceContext ( ) ) ; } return $ context [ $ item ] ; }
7375	public function clear ( ) { while ( ! $ this -> queue -> isEmpty ( ) ) { $ this -> queue -> pop ( ) ; } $ this -> queue = null ; }
2579	protected function loadCustomerRefs ( $ dkNumber ) { if ( ! is_null ( $ dkNumber ) ) { $ this -> customerRef = new MasterPricer \ CustomerRef ( ) ; $ this -> customerRef -> customerReferences [ ] = new MasterPricer \ CustomerReferences ( $ dkNumber , MasterPricer \ CustomerReferences :: QUAL_AGENCY_GROUPING_ID ) ; } }
8475	public function debug ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'debug' , $ scope , $ message , $ context , $ config ) ; }
1475	public function createRelationshipValidator ( ResourceObject $ resource , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ resource -> all ( ) , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) use ( $ resource ) { return $ this -> invalidResource ( $ resource -> pointerForRelationship ( $ key , '/data' ) , $ detail , $ failed ) ; } ) ; }
1805	public function getActiveGroups ( ) { $ arrGroups = array ( ) ; $ objGroup = Contao \ MemberGroupModel :: findAllActive ( ) ; if ( $ objGroup !== null ) { while ( $ objGroup -> next ( ) ) { $ arrGroups [ $ objGroup -> id ] = $ objGroup -> name ; } } return $ arrGroups ; }
10437	public function inject_template ( midgardmvc_core_request $ request ) { $ route = $ request -> get_route ( ) ; $ route -> template_aliases [ 'content-sidebar' ] = 'cmp-show-sidebar' ; $ route -> template_aliases [ 'main-menu' ] = 'cmp-show-main_menu' ; midgardmvc_core :: get_instance ( ) -> head -> add_link ( array ( 'rel' => 'stylesheet' , 'type' => 'text/css' , 'href' => MIDGARDMVC_STATIC_URL . '/com_meego_planet/planet.css' ) ) ; }
11179	protected function get ( $ key ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; if ( ! is_array ( $ cache ) ) { return false ; } else { if ( isset ( $ cache [ $ key ] ) ) { return $ cache [ $ key ] ; } return false ; } }
12734	public function unregister ( Listener $ register ) { $ id = $ register -> id ; $ success = false ; if ( isset ( $ this -> _byId [ $ id ] ) ) { unset ( $ this -> _byId [ $ id ] ) ; $ success = true ; } foreach ( $ this -> _bySignal as $ signal => $ reg ) { if ( isset ( $ reg [ $ id ] ) ) { unset ( $ this -> _bySignal [ $ signal ] [ $ id ] ) ; } } return $ success ; }
467	public function buildExistsCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
12462	private function createCreateForm ( CustomFieldsGroup $ entity ) { $ form = $ this -> createForm ( 'custom_fields_group' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfieldsgroup_create' ) , 'method' => 'POST' , ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Create' ) ) ; return $ form ; }
11641	public function getColumns ( ) { if ( is_null ( $ this -> _columns ) ) { $ this -> columns = $ this -> dataProvider -> model -> attributeNames ( ) ; } return $ this -> _columns ; }
6322	private function parseConfiguration ( array $ config ) { $ this -> currentEnvironment = 'dev' ; foreach ( $ config as $ environment => $ connection ) { if ( isset ( $ connection [ 'dsn' ] ) ) { $ this -> dsn [ $ environment ] = $ connection [ 'dsn' ] ; } else { $ this -> dsn [ $ environment ] = sprintf ( 'pgsql:host=%s; port=%s; dbname=%s;' , $ connection [ 'host' ] , $ connection [ 'port' ] , $ connection [ 'database' ] ) ; } $ this -> username [ $ environment ] = $ connection [ 'username' ] ; $ this -> password [ $ environment ] = $ connection [ 'password' ] ; } }
5730	public function getButtonHTML ( ) { $ html = '<div class="btn-group" role="group">' ; $ params = array ( 'q' => ( array ) $ this -> gridFieldRequest -> getRequest ( ) -> getVar ( 'q' ) ) ; $ searchVars = ( bool ) $ params ? '?' . http_build_query ( $ params ) : '' ; $ previousRecordID = $ this -> gridFieldRequest -> getPreviousRecordID ( ) ; $ cssClass = $ previousRecordID ? "cms-panel-link" : "disabled" ; $ prevLink = $ previousRecordID ? Controller :: join_links ( $ this -> gridFieldRequest -> gridField -> Link ( ) , "item" , $ previousRecordID . $ searchVars ) : "javascript:void(0);" ; $ linkTitle = $ previousRecordID ? _t ( 'GridFieldBetterButtons.PREVIOUSRECORD' , 'Go to the previous record' ) : "" ; $ linkText = $ previousRecordID ? _t ( 'GridFieldBetterButtons.PREVIOUS' , 'Previous' ) : "" ; $ html .= sprintf ( "<a class='ss-ui-button btn btn-default gridfield-better-buttons-prevnext gridfield-better-buttons-prev %s' href='%s' title='%s'><img src='" . BETTER_BUTTONS_DIR . "/images/prev.png' alt='previous' /> %s</a>" , $ cssClass , $ prevLink , $ linkTitle , $ linkText ) ; $ nextRecordID = $ this -> gridFieldRequest -> getNextRecordID ( ) ; $ cssClass = $ nextRecordID ? "cms-panel-link" : "disabled" ; $ nextLink = $ nextRecordID ? Controller :: join_links ( $ this -> gridFieldRequest -> gridField -> Link ( ) , "item" , $ nextRecordID . $ searchVars ) : "javascript:void(0);" ; $ linkTitle = $ nextRecordID ? _t ( 'GridFieldBetterButtons.NEXTRECORD' , 'Go to the next record' ) : "" ; $ linkText = $ nextRecordID ? _t ( 'GridFieldBetterButtons.NEXT' , 'Next' ) : "" ; $ html .= sprintf ( "<a class='ss-ui-button btn btn-default gridfield-better-buttons-prevnext gridfield-better-buttons-next %s' href='%s' title='%s'>%s <img src='" . BETTER_BUTTONS_DIR . "/images/next.png' alt='next' /></a>" , $ cssClass , $ nextLink , $ linkTitle , $ linkText ) ; $ html .= '</div>' ; return $ html ; }
393	protected static function filterValidColumnNames ( $ db , array $ aliases ) { $ columnNames = [ ] ; $ tableName = static :: tableName ( ) ; $ quotedTableName = $ db -> quoteTableName ( $ tableName ) ; foreach ( static :: getTableSchema ( ) -> getColumnNames ( ) as $ columnName ) { $ columnNames [ ] = $ columnName ; $ columnNames [ ] = $ db -> quoteColumnName ( $ columnName ) ; $ columnNames [ ] = "$tableName.$columnName" ; $ columnNames [ ] = $ db -> quoteSql ( "$quotedTableName.[[$columnName]]" ) ; foreach ( $ aliases as $ tableAlias ) { $ columnNames [ ] = "$tableAlias.$columnName" ; $ quotedTableAlias = $ db -> quoteTableName ( $ tableAlias ) ; $ columnNames [ ] = $ db -> quoteSql ( "$quotedTableAlias.[[$columnName]]" ) ; } } return $ columnNames ; }
1664	protected function getCountries ( ) { if ( sizeof ( $ this -> countries ) == 0 ) { $ this -> countries = json_decode ( file_get_contents ( __DIR__ . '/Models/countries.json' ) , true ) ; } return $ this -> countries ; }
5202	public function open ( ) { try { $ additionalConnectionOptions = array ( ) ; foreach ( array ( 'connection_timeout' , 'read_write_timeout' , 'keepalive' , 'heartbeat' ) as $ option ) { if ( isset ( $ this -> $ option ) ) { $ additionalConnectionOptions [ $ option ] = $ this -> $ option ; } } $ this -> AMQPConnection = new AMQPSSLConnection ( $ this -> host , $ this -> port , $ this -> username , $ this -> password , $ this -> vhost , $ this -> ssl_context_options , $ additionalConnectionOptions ) ; $ this -> channel = $ this -> AMQPConnection -> channel ( ) ; $ this -> channel -> queue_declare ( $ this -> queue_name , false , false , false , false ) ; $ this -> channel -> exchange_declare ( $ this -> exchange , $ this -> exchange_type , false , true , false ) ; $ this -> channel -> queue_bind ( $ this -> queue_name , $ this -> exchange ) ; } catch ( Exception $ e ) { throw new Exception ( $ e ) ; } }
2262	public function query ( $ strQuery ) { $ objStatement = new Statement ( $ this -> resConnection , $ this -> blnDisableAutocommit ) ; return $ objStatement -> query ( $ strQuery ) ; }
3423	protected function groupsMustBeSelected ( ) { return in_array ( 'GROUPS' , $ this -> select ) || in_array ( 'GROUP_ID' , $ this -> select ) || in_array ( 'GROUPS_ID' , $ this -> select ) ; }
3079	public static function getCatInfo ( AssessmentTest $ test , $ namespace = '' ) { if ( $ namespace === '' ) { $ namespace = CatService :: QTI_2X_ADAPTIVE_XML_NAMESPACE ; } $ info = [ ] ; foreach ( $ test -> getComponentsByClassName ( 'assessmentSection' ) as $ assessmentSection ) { if ( ( $ selection = $ assessmentSection -> getSelection ( ) ) !== null && ( ( $ xmlExtension = $ selection -> getXml ( ) ) ) !== null ) { $ xpath = new \ DOMXPath ( $ xmlExtension ) ; $ xpath -> registerNamespace ( 'ais' , $ namespace ) ; $ sectionIdentifier = $ assessmentSection -> getIdentifier ( ) ; $ sectionInfo = [ ] ; foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:adaptiveEngineRef' , $ xmlExtension ) as $ adaptiveEngineRef ) { $ sectionInfo [ 'adaptiveEngineRef' ] = $ adaptiveEngineRef -> getAttribute ( 'href' ) ; } foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:adaptiveSettingsRef' , $ xmlExtension ) as $ adaptiveSettingsRef ) { $ sectionInfo [ 'adaptiveSettingsRef' ] = $ adaptiveSettingsRef -> getAttribute ( 'href' ) ; } foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:qtiUsagedataRef' , $ xmlExtension ) as $ qtiUsagedataRef ) { $ sectionInfo [ 'qtiUsagedataRef' ] = $ qtiUsagedataRef -> getAttribute ( 'href' ) ; } foreach ( $ xpath -> query ( './/ais:adaptiveItemSelection/ais:qtiMetadataRef' , $ xmlExtension ) as $ qtiMetadataRef ) { $ sectionInfo [ 'qtiMetadataRef' ] = $ qtiMetadataRef -> getAttribute ( 'href' ) ; } if ( ! empty ( $ sectionInfo ) ) { $ info [ $ sectionIdentifier ] = $ sectionInfo ; } } } return $ info ; }
3696	protected function extractIdFrom ( EnvironmentInterface $ environment , $ parameterName = 'pid' ) { $ parameter = $ environment -> getInputProvider ( ) -> getParameter ( $ parameterName ) ; return ModelId :: fromSerialized ( $ parameter ) -> getId ( ) ; }
10267	public function setEndColor ( Color $ pValue ) { $ color = $ pValue -> getIsSupervisor ( ) ? $ pValue -> getSharedComponent ( ) : $ pValue ; if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getEndColor ( ) -> getStyleArray ( [ 'argb' => $ color -> getARGB ( ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> endColor = $ color ; } return $ this ; }
5943	public function fetchObject ( AbstractNode $ node , array $ siblings = array ( ) ) { $ this -> currObj = $ node ; $ this -> currSib = $ siblings ; $ args = array ( $ this -> getPrefix ( ) , $ this -> getCorpusIcon ( ) , $ this -> getCorpusName ( ) , ) ; return StringHelper :: factory ( $ this -> pattern ) -> arg ( $ args ) ; }
1574	public function defaultApi ( $ apiName = null ) { if ( is_null ( $ apiName ) ) { return LaravelJsonApi :: $ defaultApi ; } LaravelJsonApi :: defaultApi ( $ apiName ) ; return $ apiName ; }
10124	private function writeGridset ( ) { $ record = 0x0082 ; $ length = 0x0002 ; $ fGridSet = ! $ this -> phpSheet -> getPrintGridlines ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fGridSet ) ; $ this -> append ( $ header . $ data ) ; }
3555	protected function castValue ( ) { $ value = $ this -> attributes [ 'meta_value' ] ; $ validTypes = [ 'boolean' , 'integer' , 'float' , 'double' , 'array' , 'object' , 'null' ] ; if ( in_array ( $ this -> attributes [ 'meta_type' ] , $ validTypes ) ) { settype ( $ value , $ this -> attributes [ 'meta_type' ] ) ; } return $ value ; }
2324	public static function validate ( $ strToken ) { if ( Config :: get ( 'disableRefererCheck' ) || \ defined ( 'BYPASS_TOKEN_CHECK' ) ) { return true ; } if ( Config :: get ( 'requestTokenWhitelist' ) ) { $ strHostname = gethostbyaddr ( $ _SERVER [ 'REMOTE_ADDR' ] ) ; foreach ( Config :: get ( 'requestTokenWhitelist' ) as $ strDomain ) { if ( $ strDomain == $ strHostname || preg_match ( '/\.' . preg_quote ( $ strDomain , '/' ) . '$/' , $ strHostname ) ) { return true ; } } } $ container = System :: getContainer ( ) ; return $ container -> get ( 'contao.csrf.token_manager' ) -> isTokenValid ( new CsrfToken ( $ container -> getParameter ( 'contao.csrf_token_name' ) , $ strToken ) ) ; }
7650	public function unlink ( $ path ) { $ this -> getStorageClient ( $ path ) -> deleteBlob ( $ this -> getContainerName ( $ path ) , $ this -> getFileName ( $ path ) ) ; clearstatcache ( true , $ path ) ; return true ; }
4201	private function addMethodsMin ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( \ method_exists ( $ obj , '__toString' ) ) { $ abs [ 'methods' ] [ '__toString' ] = array ( 'returnValue' => \ call_user_func ( array ( $ obj , '__toString' ) ) , 'visibility' => 'public' , ) ; } if ( \ method_exists ( $ obj , '__get' ) ) { $ abs [ 'methods' ] [ '__get' ] = array ( 'visibility' => 'public' ) ; } if ( \ method_exists ( $ obj , '__set' ) ) { $ abs [ 'methods' ] [ '__set' ] = array ( 'visibility' => 'public' ) ; } return ; }
2517	public function pnrAddMultiElements ( RequestOptions \ PnrAddMultiElementsOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
2285	protected static function server ( ) { $ strServer = ! empty ( $ _SERVER [ 'SERVER_ADDR' ] ) ? $ _SERVER [ 'SERVER_ADDR' ] : $ _SERVER [ 'LOCAL_ADDR' ] ; if ( empty ( $ strServer ) ) { $ strServer = @ gethostbyname ( $ _SERVER [ 'SERVER_NAME' ] ) ; } return $ strServer ; }
1666	protected function enableTwoFactor ( BackendUser $ user , $ return ) { if ( $ user -> useTwoFactor ) { return ; } $ container = System :: getContainer ( ) ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerificationHelp' ] ; $ authenticator = $ container -> get ( 'contao.security.two_factor.authenticator' ) ; if ( Input :: post ( 'FORM_SUBMIT' ) == 'tl_two_factor' ) { if ( $ authenticator -> validateCode ( $ user , Input :: post ( 'verify' ) ) ) { $ user -> useTwoFactor = '1' ; $ user -> save ( ) ; throw new RedirectResponseException ( $ return ) ; } $ this -> Template -> error = true ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidTwoFactor' ] ; } if ( ! $ user -> secret ) { $ user -> secret = random_bytes ( 128 ) ; $ user -> save ( ) ; } $ request = $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; $ this -> Template -> enable = true ; $ this -> Template -> secret = Base32 :: encodeUpperUnpadded ( $ user -> secret ) ; $ this -> Template -> textCode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorTextCode' ] ; $ this -> Template -> qrCode = base64_encode ( $ authenticator -> getQrCode ( $ user , $ request ) ) ; $ this -> Template -> scan = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorScan' ] ; $ this -> Template -> verify = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerification' ] ; $ this -> Template -> verifyHelp = $ verifyHelp ; }
165	public static function serialize ( array $ links ) { foreach ( $ links as $ rel => $ link ) { if ( is_array ( $ link ) ) { foreach ( $ link as $ i => $ l ) { $ link [ $ i ] = $ l instanceof self ? array_filter ( ( array ) $ l ) : [ 'href' => $ l ] ; } $ links [ $ rel ] = $ link ; } elseif ( ! $ link instanceof self ) { $ links [ $ rel ] = [ 'href' => $ link ] ; } } return $ links ; }
12425	public function getAuthorizerToken ( $ appId , $ refreshToken ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ appId , 'authorizer_refresh_token' => $ refreshToken , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_TOKEN , $ params ] ) ; }
4241	public function onError ( Event $ error ) { if ( $ this -> debug -> getCfg ( 'collect' ) ) { $ this -> error = $ error ; $ errInfo = $ error [ 'typeStr' ] . ': ' . $ error [ 'file' ] . ' (line ' . $ error [ 'line' ] . ')' ; $ errMsg = $ error [ 'message' ] ; if ( $ error [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ) { $ this -> debug -> error ( $ errInfo . ': ' , $ errMsg ) ; } else { $ this -> debug -> warn ( $ errInfo . ': ' , $ errMsg ) ; } $ error [ 'continueToNormal' ] = false ; $ error [ 'inConsole' ] = true ; $ error [ 'email' ] = false ; $ this -> error = null ; } elseif ( $ this -> debug -> getCfg ( 'output' ) ) { $ error [ 'email' ] = false ; $ error [ 'inConsole' ] = false ; } else { $ error [ 'inConsole' ] = false ; } }
4016	protected function getWidgetClass ( $ field ) { $ className = $ GLOBALS [ ( TL_MODE == 'BE' ? 'BE_FFL' : 'TL_FFL' ) ] [ $ field [ 'inputType' ] ] ; if ( ( $ className !== '' ) && class_exists ( $ className ) ) { return $ className ; } return null ; }
7172	protected function resolveSaleTargetCountry ( SaleInterface $ sale ) : ? CountryInterface { if ( null !== $ country = $ sale -> getDeliveryCountry ( ) ) { return $ country ; } if ( null !== $ customer = $ sale -> getCustomer ( ) ) { return $ this -> resolveCustomerTargetCountry ( $ customer ) ; } return null ; }
5193	public function dispatch ( ServerRequestInterface $ request ) : ServerRequestInterface { $ dispatcher = simpleDispatcher ( [ $ this , 'addRoutes' ] ) ; $ routeInfo = $ dispatcher -> dispatch ( $ request -> getMethod ( ) , $ request -> getUri ( ) -> getPath ( ) ) ; if ( $ routeInfo [ 0 ] === Dispatcher :: METHOD_NOT_ALLOWED ) { throw new MethodNotAllowedException ( $ request -> getMethod ( ) , $ routeInfo [ 1 ] ) ; } if ( $ routeInfo [ 0 ] === Dispatcher :: NOT_FOUND ) { throw new NotFoundHttpException ( sprintf ( "Route '%s' not found." , $ request -> getUri ( ) -> getPath ( ) ) ) ; } foreach ( $ routeInfo [ 2 ] as $ key => $ value ) { $ request = $ request -> withAttribute ( $ key , $ value ) ; } return $ request -> withAttribute ( 'route' , $ this -> routes [ $ routeInfo [ 1 ] ] ) ; }
1549	protected function authorizeRelationship ( AuthorizerInterface $ authorizer , $ request , $ record , string $ field ) : void { if ( $ this -> isModifyRelationship ( $ request ) ) { $ authorizer -> modifyRelationship ( $ record , $ field , $ request ) ; return ; } $ authorizer -> readRelationship ( $ record , $ field , $ request ) ; }
11412	public function batchTagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_TAG , $ params ] ) ; }
6053	public function retrieveParents ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders/' . $ id . '/parents' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderParent ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
2787	protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( PHP_SAPI !== 'phpdbg' && ! defined ( 'HHVM_VERSION' ) && ! extension_loaded ( 'xdebug' ) ) { $ output -> writeln ( '<error>You need to install and enable xdebug, or use phpdbg, ' . 'in order to allow for code coverage generation.</error>' ) ; return 1 ; } Performance :: upMemProfiler ( ) ; $ this -> validate ( $ input ) ; $ container = $ this -> container = new Container ( $ input -> getOptions ( ) ) ; $ this -> doConfiguration ( $ input ) ; if ( $ this -> isLoggingEnabled ( ) ) { $ this -> removeOldLogFiles ( ) ; } else { $ output -> writeln ( '<error>No log file is specified. Detailed results ' . 'will not be available.</error>' ) ; $ output -> write ( PHP_EOL ) ; } if ( $ input -> getOption ( 'incremental' ) ) { $ output -> writeln ( '<error>Incremental Analysis is an experimental feature and will very likely</error>' ) ; $ output -> writeln ( '<error>yield inaccurate results at this time.</error>' ) ; $ output -> write ( PHP_EOL ) ; } if ( $ this -> textLogFile ) { $ renderer = new Text ( $ output , true ) ; } else { $ renderer = new Text ( $ output ) ; } $ testSuiteRunner = new UnitTestRunner ( $ container -> getAdapter ( ) , $ container -> getAdapter ( ) -> getProcess ( $ container , true ) , $ container -> getTempDirectory ( ) . '/coverage.humbug.txt' ) ; $ testSuiteRunner -> addObserver ( new LoggingObserver ( $ renderer , $ output , new ProgressBarObserver ( $ input , $ output ) ) ) ; $ result = $ testSuiteRunner -> run ( $ container ) ; if ( ! $ result -> isSuccess ( ) ) { return 1 ; } $ output -> write ( PHP_EOL ) ; $ renderer -> renderStaticAnalysisStart ( ) ; $ output -> write ( PHP_EOL ) ; $ incrementalCache = null ; if ( $ input -> getOption ( 'incremental' ) ) { $ incrementalCache = new IncrementalCache ( $ container ) ; } $ mutationTestingRunner = $ this -> builder -> build ( $ container , $ renderer , $ input , $ output ) ; $ mutationTestingRunner -> run ( $ result -> getCoverage ( ) , $ this -> mutableIterator , $ incrementalCache ) ; if ( $ this -> isLoggingEnabled ( ) ) { $ output -> write ( PHP_EOL ) ; } if ( $ input -> getOption ( 'incremental' ) ) { $ incrementalCache -> write ( ) ; } }
1816	public function pagePicker ( Contao \ DataContainer $ dc ) { @ trigger_error ( 'Using tl_content::pagePicker() has been deprecated and will no longer work in Contao 5.0. Set the "dcaPicker" eval attribute instead.' , E_USER_DEPRECATED ) ; return Contao \ Backend :: getDcaPickerWizard ( true , $ dc -> table , $ dc -> field , $ dc -> inputName ) ; }
10885	protected function makeRequest ( $ data ) { $ url = 'https://www.errorstream.com/api/1.0/errors/create?' . http_build_query ( [ 'api_token' => $ this -> api_token , 'project_token' => $ this -> project_token ] ) ; try { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_POST , true ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , json_encode ( $ data ) ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-Type:application/json' ) ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; $ result = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ result ; } catch ( \ Exception $ ex ) { return $ ex -> getMessage ( ) ; } }
11597	public static function setCacheType ( string $ sCacheName ) { if ( $ sCacheName === 'file' ) { self :: $ _sTypeOfCache = 'file' ; } else if ( $ sCacheName === 'memcache' ) { self :: $ _sTypeOfCache = 'memcache' ; } else if ( $ sCacheName === 'apc' ) { self :: $ _sTypeOfCache = 'apc' ; } else if ( $ sCacheName === 'redis' ) { self :: $ _sTypeOfCache = 'redis' ; } else { self :: $ _sTypeOfCache = 'mock' ; } }
2002	public static function getVersion ( string $ packageName ) : string { $ version = Versions :: getVersion ( $ packageName ) ; return static :: parseVersion ( $ version ) ; }
11258	private function invoker ( ContainerInterface $ container ) { $ resolvers = new ResolverChain ( [ new ParameterNameContainerResolver ( $ container ) , new DefaultValueResolver ( ) , ] ) ; $ invoker = new Invoker ( $ resolvers , $ container ) ; return $ invoker ; }
12748	public function setPattern ( $ pattern ) { $ this -> setTag ( 'pattern' , $ pattern ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'pattern' , $ pattern ) ; } }
8151	public function hasExtension ( $ class ) { $ class = ltrim ( $ class , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } return true ; } return isset ( $ this -> extensionsByClass [ $ class ] ) ; }
4047	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'jumpTo' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; if ( $ metaModel -> isTranslated ( ) ) { $ arrLanguages = [ ] ; foreach ( ( array ) $ metaModel -> getAvailableLanguages ( ) as $ strLangCode ) { $ arrLanguages [ $ strLangCode ] = $ this -> translator -> trans ( 'LNG.' . $ strLangCode , [ ] , 'contao_languages' ) ; } asort ( $ arrLanguages ) ; $ extra [ 'minCount' ] = count ( $ arrLanguages ) ; $ extra [ 'maxCount' ] = count ( $ arrLanguages ) ; $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] = $ arrLanguages ; } else { $ extra [ 'minCount' ] = 1 ; $ extra [ 'maxCount' ] = 1 ; $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] = [ 'xx' => $ this -> translator -> trans ( 'tl_metamodel_rendersettings.jumpTo_allLanguages' , [ ] , 'contao_tl_metamodel_rendersettings' ) ] ; } $ extra [ 'columnFields' ] [ 'filter' ] [ 'options' ] = $ this -> getFilterSettings ( $ model ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; }
5303	protected static function hexToUnicode ( $ char ) { if ( ! is_string ( $ char ) || ! preg_match ( '(^[0-9a-f]{2,6}$)i' , $ char ) ) { throw new \ InvalidArgumentException ( '$char must be one single unicode character as hex string' ) ; } return mb_convert_encoding ( '&#x' . strtolower ( $ char ) . ';' , 'UTF-8' , 'HTML-ENTITIES' ) ; }
5962	public function serverGroupPermList ( $ sgid , $ permsid = false ) { return $ this -> execute ( "servergrouppermlist" , array ( "sgid" => $ sgid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
12164	private function createAuthorityTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?authority`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?authority` ( `authority_id` bigint(20) NOT NULL AUTO_INCREMENT, `authority_title` varchar(100) NOT NULL, `authority_parent_id` bigint(20) NOT NULL, `authority_name` varchar(45) NOT NULL COMMENT ' ', `authority_description` varchar(255) DEFAULT NULL, `lft` int(11) NOT NULL, `rgt` int(11) NOT NULL, PRIMARY KEY (`authority_id`), UNIQUE KEY `authority_name_UNIQUE` (`authority_name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=5 ;" ) ; $ this -> database -> query ( "INSERT INTO `?authority` (`authority_id`, `authority_title`, `authority_parent_id`, `authority_name`, `authority_description`, `lft`, `rgt`) VALUES (1, 'PUBLIC', 0, 'PUBLIC', 'All unregistered nodes, users and applications', 1, 8), (2, 'Registered Users', 1, 'REGISTEREDUSERS', 'All registered nodes with a known unique identifier', 2, 7), (3, 'Moderators', 2, 'MODERATORS', 'System moderators, Users allowed to manage user generated import', 3, 6), (4, 'Super Administrators', 3, 'MASTERADMINISTRATORS', 'Special users with awesome powers', 4, 5);" ) ; }
9738	public function setFitToHeight ( $ pValue , $ pUpdate = true ) { $ this -> fitToHeight = $ pValue ; if ( $ pUpdate ) { $ this -> fitToPage = true ; } return $ this ; }
9139	public static function parse ( $ uri , $ serverVars = array ( ) , $ defaultController = 'Index' , $ defaultAction = 'index' ) { $ req = new self ( $ defaultController , $ defaultAction ) ; $ req -> origin = $ uri ; self :: parseRemoteHost ( $ req , $ serverVars ) ; self :: parseGetPostSessionCookie ( $ req ) ; $ savedRequestParams = array ( ) ; if ( strpos ( $ uri , '?' ) ) { parse_str ( substr ( $ uri , strpos ( $ uri , '?' ) + 1 ) , $ savedRequestParams ) ; $ uri = substr ( $ uri , 0 , strpos ( $ uri , '?' ) ) ; } self :: parseContextPrefix ( $ req , $ serverVars ) ; $ parts = self :: parseUri ( $ req , $ uri , $ defaultController , $ defaultAction ) ; $ numParts = count ( $ parts ) ; for ( $ i = 0 ; $ i < $ numParts ; $ i = $ i + 2 ) { $ paramName = trim ( $ parts [ $ i ] ) ; $ paramValue = isset ( $ parts [ $ i + 1 ] ) ? trim ( $ parts [ $ i + 1 ] ) : '' ; if ( $ paramName && $ paramValue ) { $ req -> params [ $ paramName ] = $ paramValue ; } } $ req -> params = array_merge ( $ req -> params , $ savedRequestParams ) ; self :: parseParameters ( $ req , $ serverVars ) ; return $ req ; }
9717	private function writeRecalcId ( ) { $ record = 0x01C1 ; $ length = 8 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'VV' , 0x000001C1 , 0x00001E667 ) ; return $ this -> writeData ( $ header . $ data ) ; }
4106	public function commitBulk ( ) { if ( $ this -> bulk && $ this -> bulk -> count ( ) ) { $ result = $ this -> bulk -> commit ( ) ; $ this -> bulk = null ; return $ result ; } }
12670	public function stream_open ( $ path ) { $ scheme = parse_url ( $ path , PHP_URL_SCHEME ) ; if ( substr ( $ scheme , - 10 ) === '-emulation' ) { $ scheme = substr ( $ scheme , 0 , - 10 ) ; } $ emulator = static :: getEmulatorInstance ( $ scheme , $ path , $ this -> getContext ( ) ) ; if ( ! $ emulator ) { return false ; } $ this -> setEmulator ( $ emulator ) ; $ this -> getEmulator ( ) -> setResponseStream ( $ this -> callEmulation ( $ this -> getEmulator ( ) -> getIncomingStream ( ) ) ) ; $ this -> setResponse ( $ this -> getEmulator ( ) -> getOutgoingStream ( ) ) ; return true ; }
7092	protected function add ( $ url , $ method , Callable $ action ) { $ url = $ this -> base !== "" && $ url === "/" ? $ this -> base : $ this -> base . $ url ; $ route = new Route ( $ url , $ method , $ action ) ; $ this -> routes [ ] = $ route ; return $ route ; }
8884	private function buildPackages ( $ number , $ weight , $ measurement = 'LBS' ) { $ packages = array ( ) ; if ( $ number > 1 ) { $ individual_weight = $ weight / $ number ; for ( $ i = 0 ; $ i < $ number ; $ i ++ ) { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ individual_weight . '</Weight> </PackageWeight> </Package>' ; } } else { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ weight . '</Weight> </PackageWeight> </Package>' ; } return implode ( '' , $ packages ) ; }
10897	public function setScheme ( $ scheme ) { foreach ( $ this -> uris as $ name => $ uri ) { $ this -> add ( $ name , $ uri -> withScheme ( $ scheme ) ) ; } }
6847	public static function adjust ( $ hour , $ ampm ) { $ hour = ( int ) $ hour ; $ ampm = strtolower ( $ ampm ) ; switch ( $ ampm ) { case 'am' : if ( $ hour == 12 ) { $ hour = 0 ; } break ; case 'pm' : if ( $ hour < 12 ) { $ hour += 12 ; } break ; } return sprintf ( '%02d' , $ hour ) ; }
801	private function clearRangeLeaveComments ( Tokens $ tokens , $ indexStart , $ indexEnd ) { for ( $ i = $ indexStart ; $ i <= $ indexEnd ; ++ $ i ) { $ token = $ tokens [ $ i ] ; if ( $ token -> isComment ( ) ) { continue ; } if ( $ token -> isWhitespace ( "\n\r" ) ) { continue ; } $ tokens -> clearAt ( $ i ) ; } }
1228	public function parse ( $ expression ) { $ this -> expression = $ expression ; $ this -> tokens = $ this -> lexer -> tokenize ( $ expression ) ; $ this -> tpos = - 1 ; $ this -> next ( ) ; $ result = $ this -> expr ( ) ; if ( $ this -> token [ 'type' ] === T :: T_EOF ) { return $ result ; } throw $ this -> syntax ( 'Did not reach the end of the token stream' ) ; }
4772	public function configs ( Request $ request , WidgetInterface $ widget , CacheInterface $ cache , string $ widgetId ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; if ( $ request -> get ( 'remove' ) ) { $ widgetConfig -> removeWidgetConfig ( $ widgetId , $ widgets [ $ widgetId ] -> getConfigProcess ( $ request ) ?? [ ] ) ; } else { $ widgetConfig -> addWidgetConfig ( $ widgetId , $ widgets [ $ widgetId ] -> getConfigProcess ( $ request ) ?? [ ] ) ; } $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; $ cache -> delete ( $ widgetId . $ this -> getUser ( ) -> getId ( ) ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
409	public function getHostInfo ( ) { if ( $ this -> _hostInfo === null ) { $ secure = $ this -> getIsSecureConnection ( ) ; $ http = $ secure ? 'https' : 'http' ; if ( $ this -> headers -> has ( 'X-Forwarded-Host' ) ) { $ this -> _hostInfo = $ http . '://' . trim ( explode ( ',' , $ this -> headers -> get ( 'X-Forwarded-Host' ) ) [ 0 ] ) ; } elseif ( $ this -> headers -> has ( 'Host' ) ) { $ this -> _hostInfo = $ http . '://' . $ this -> headers -> get ( 'Host' ) ; } elseif ( isset ( $ _SERVER [ 'SERVER_NAME' ] ) ) { $ this -> _hostInfo = $ http . '://' . $ _SERVER [ 'SERVER_NAME' ] ; $ port = $ secure ? $ this -> getSecurePort ( ) : $ this -> getPort ( ) ; if ( ( $ port !== 80 && ! $ secure ) || ( $ port !== 443 && $ secure ) ) { $ this -> _hostInfo .= ':' . $ port ; } } } return $ this -> _hostInfo ; }
9928	protected function valueIsEmpty ( $ value ) { return ( is_object ( $ value ) && $ value instanceof Parameters && $ value -> isEmpty ( ) ) || ( is_array ( $ value ) && ! count ( $ value ) ) ; }
2294	public static function getTinyMceLanguage ( ) { $ lang = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( $ lang == '' ) { return 'en' ; } $ lang = str_replace ( '-' , '_' , $ lang ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ lang . '.js' ) ) { return $ lang ; } if ( ( $ short = substr ( $ GLOBALS [ 'TL_LANGUAGE' ] , 0 , 2 ) ) != $ lang ) { if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ short . '.js' ) ) { return $ short ; } } elseif ( ( $ long = $ short . '_' . strtoupper ( $ short ) ) != $ lang ) { if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ long . '.js' ) ) { return $ long ; } } return 'en' ; }
2689	private function fastlyResize ( ) { if ( $ this -> getWidth ( ) === null && $ this -> getHeight ( ) === null ) { return $ this ; } $ this -> adjustSize ( ) ; return $ this ; }
7814	private function _processRequest ( ) { $ this -> _isAjaxRequest = $ this -> request -> is ( 'ajax' ) ; if ( isset ( $ this -> request -> query [ 'length' ] ) && ! empty ( $ this -> request -> query [ 'length' ] ) ) { $ this -> config ( 'length' , $ this -> request -> query [ 'length' ] ) ; } if ( isset ( $ this -> request -> query [ 'start' ] ) && ! empty ( $ this -> request -> query [ 'start' ] ) ) { $ this -> config ( 'start' , ( int ) $ this -> request -> query [ 'start' ] ) ; } if ( isset ( $ this -> request -> query [ 'order' ] ) && ! empty ( $ this -> request -> query [ 'order' ] ) ) { $ order = $ this -> config ( 'order' ) ; foreach ( $ this -> request -> query [ 'order' ] as $ item ) { $ order [ $ this -> request -> query [ 'columns' ] [ $ item [ 'column' ] ] [ 'name' ] ] = $ item [ 'dir' ] ; } $ this -> config ( 'order' , $ order ) ; } if ( isset ( $ this -> request -> query [ 'draw' ] ) && ! empty ( $ this -> request -> query [ 'draw' ] ) ) { $ this -> _viewVars [ 'draw' ] = ( int ) $ this -> request -> query [ 'draw' ] ; } if ( ! isset ( $ this -> request -> query [ 'columns' ] ) || empty ( $ this -> request -> query [ 'columns' ] ) ) { return ; } $ globalSearch = ( isset ( $ this -> request -> query [ 'search' ] [ 'value' ] ) ? $ this -> request -> query [ 'search' ] [ 'value' ] : false ) ; foreach ( $ this -> request -> query [ 'columns' ] as $ column ) { if ( $ globalSearch && $ column [ 'searchable' ] == 'true' ) { $ this -> _addCondition ( $ column [ 'name' ] , $ globalSearch , 'or' ) ; } $ localSearch = $ column [ 'search' ] [ 'value' ] ; if ( ! empty ( $ localSearch ) && ( $ localSearch !== $ globalSearch ) ) { $ this -> _addCondition ( $ column [ 'name' ] , $ column [ 'search' ] [ 'value' ] ) ; } } }
11167	protected function generateApi ( ) { $ api = array ( ) ; $ api [ "url" ] = $ this -> getUrl ( ) ; $ api [ "type" ] = "remoting" ; $ actionsArray = array ( ) ; $ actions = $ this -> getActions ( ) ; foreach ( $ actions as $ class ) { $ methodArray = array ( ) ; foreach ( $ class -> getMethods ( ) as $ method ) { $ methodArray [ ] = array ( "name" => $ method -> getAnnotatedName ( ) , "len" => $ method -> getLen ( ) ) ; } $ actionsArray [ $ class -> getAnnotatedName ( ) ] = $ methodArray ; } $ api [ "actions" ] = $ actionsArray ; return $ api ; }
308	protected function createRule ( $ pattern , $ prefix , $ action ) { $ verbs = 'GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS' ; if ( preg_match ( "/^((?:($verbs),)*($verbs))(?:\\s+(.*))?$/" , $ pattern , $ matches ) ) { $ verbs = explode ( ',' , $ matches [ 1 ] ) ; $ pattern = isset ( $ matches [ 4 ] ) ? $ matches [ 4 ] : '' ; } else { $ verbs = [ ] ; } $ config = $ this -> ruleConfig ; $ config [ 'verb' ] = $ verbs ; $ config [ 'pattern' ] = rtrim ( $ prefix . '/' . strtr ( $ pattern , $ this -> tokens ) , '/' ) ; $ config [ 'route' ] = $ action ; if ( ! empty ( $ verbs ) && ! in_array ( 'GET' , $ verbs ) ) { $ config [ 'mode' ] = WebUrlRule :: PARSING_ONLY ; } $ config [ 'suffix' ] = $ this -> suffix ; return Yii :: createObject ( $ config ) ; }
12316	public function editAction ( Request $ request , Category $ category ) { $ deleteForm = $ this -> createDeleteForm ( $ category ) ; $ editForm = $ this -> createForm ( 'BlogBundle\Form\CategoryType' , $ category ) ; $ editForm -> handleRequest ( $ request ) ; if ( $ editForm -> isSubmitted ( ) && $ editForm -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ category ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'category.edited' ) ; return $ this -> redirectToRoute ( 'blog_category_index' ) ; } return array ( 'entity' => $ category , 'edit_form' => $ editForm -> createView ( ) , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
2801	protected static function generateNonLazyBeanCode ( string $ padding , string $ beanId , string $ beanType , Bean $ beanMetadata , string $ methodParams , ForceLazyInitProperty $ forceLazyInitProperty , SessionBeansProperty $ sessionBeansProperty , BeanPostProcessorsProperty $ postProcessorsProperty , WrapBeanAsLazy $ wrapBeanAsLazy ) : string { $ content = $ padding . '$backupForceLazyInit = $this->' . $ forceLazyInitProperty -> getName ( ) . ';' . PHP_EOL ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . 'if($this->' . $ sessionBeansProperty -> getName ( ) . '->has("' . $ beanId . '")) {' . PHP_EOL ; if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . ' $sessionInstance = clone $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } else { $ content .= $ padding . ' $sessionInstance = $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $sessionInstance) : $sessionInstance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . 'static $instance = null;' . PHP_EOL ; $ content .= $ padding . 'if ($instance !== null) {' . PHP_EOL ; $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = true;' . PHP_EOL ; } $ content .= self :: generateBeanCreationCode ( $ padding , $ beanId , $ methodParams , $ postProcessorsProperty ) ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = $backupForceLazyInit;' . PHP_EOL ; $ content .= $ padding . '$this->' . $ sessionBeansProperty -> getName ( ) . '->add("' . $ beanId . '", $instance);' . PHP_EOL ; } $ content .= $ padding . 'return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; return $ content ; }
10882	protected function aggregateTernaryValues ( array $ values ) { if ( in_array ( false , $ values , true ) ) { return false ; } elseif ( in_array ( true , $ values , true ) ) { return true ; } else { return null ; } }
12791	public static function createLayout ( string $ layoutName , View $ view ) : ? Layout { $ layoutsRoot = AppHelper :: getInstance ( ) -> getComponentRoot ( 'layouts' ) ; $ layoutFile = $ layoutsRoot . \ DIRECTORY_SEPARATOR . strtolower ( $ layoutName ) . '.php' ; if ( is_readable ( $ layoutFile ) ) { return new Layout ( $ layoutFile , $ view ) ; } return null ; }
8135	public function displayBlock ( $ name , $ context = array ( ) ) { $ this -> template -> displayBlock ( $ name , $ this -> env -> mergeGlobals ( $ context ) ) ; }
7000	public function url ( $ url = null ) { if ( $ url ) $ this -> url = trim ( $ url ) ; return $ this -> url ; }
7416	public function getMaxFileSize ( ) : int { $ iniMax = strtolower ( ini_get ( 'upload_max_filesize' ) ) ; if ( '' === $ iniMax ) { return PHP_INT_MAX ; } $ max = ltrim ( $ iniMax , '+' ) ; if ( 0 === strpos ( $ max , '0x' ) ) { $ max = intval ( $ max , 16 ) ; } elseif ( 0 === strpos ( $ max , '0' ) ) { $ max = intval ( $ max , 8 ) ; } else { $ max = ( int ) $ max ; } switch ( substr ( $ iniMax , - 1 ) ) { case 't' : $ max *= 1024 ; case 'g' : $ max *= 1024 ; case 'm' : $ max *= 1024 ; case 'k' : $ max *= 1024 ; } return $ max ; }
4874	public function setFormId ( $ formId ) { $ this -> formId = $ formId . '-' ; foreach ( $ this as $ button ) { $ button -> setAttribute ( 'id' , $ this -> formId . $ button -> getAttribute ( 'id' ) ) ; } return $ this ; }
7794	protected function accountNumber ( $ text ) { if ( $ account = $ this -> getLine ( '25' , $ text ) ) { return ltrim ( substr ( $ account , 12 ) , '0' ) ; } return null ; }
5542	protected function clearNestedFramesFocus ( ) { for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ this -> frames [ $ i ] -> clearFrameFocus ( ) ; } }
516	public function actionMark ( $ version ) { $ originalVersion = $ version ; if ( ( $ namespaceVersion = $ this -> extractNamespaceMigrationVersion ( $ version ) ) !== false ) { $ version = $ namespaceVersion ; } elseif ( ( $ migrationName = $ this -> extractMigrationVersion ( $ version ) ) !== false ) { $ version = $ migrationName ; } elseif ( $ version !== static :: BASE_MIGRATION ) { throw new Exception ( "The version argument must be either a timestamp (e.g. 101129_185401)\nor the full name of a migration (e.g. m101129_185401_create_user_table)\nor the full name of a namespaced migration (e.g. app\\migrations\\M101129185401CreateUserTable)." ) ; } $ migrations = $ this -> getNewMigrations ( ) ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ this -> confirm ( "Set migration history at $originalVersion?" ) ) { for ( $ j = 0 ; $ j <= $ i ; ++ $ j ) { $ this -> addMigrationHistory ( $ migrations [ $ j ] ) ; } $ this -> stdout ( "The migration history is set at $originalVersion.\nNo actual migration was performed.\n" , Console :: FG_GREEN ) ; } return ExitCode :: OK ; } } $ migrations = array_keys ( $ this -> getMigrationHistory ( null ) ) ; $ migrations [ ] = static :: BASE_MIGRATION ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ i === 0 ) { $ this -> stdout ( "Already at '$originalVersion'. Nothing needs to be done.\n" , Console :: FG_YELLOW ) ; } else { if ( $ this -> confirm ( "Set migration history at $originalVersion?" ) ) { for ( $ j = 0 ; $ j < $ i ; ++ $ j ) { $ this -> removeMigrationHistory ( $ migrations [ $ j ] ) ; } $ this -> stdout ( "The migration history is set at $originalVersion.\nNo actual migration was performed.\n" , Console :: FG_GREEN ) ; } } return ExitCode :: OK ; } } throw new Exception ( "Unable to find the version '$originalVersion'." ) ; }
9054	public function createRelationTable ( $ tableName ) : self { $ table = $ this -> getTableData ( $ tableName ) ; $ name = $ this -> name . '_x_' . $ table -> name ; return $ this -> relationTables [ ] = $ this -> tableFactory -> create ( $ name , $ this -> prefix ) ; }
12304	public function adminIndex ( ) { $ config = [ 'title' => trans ( 'HCLanguages::languages.page_title' ) , 'listURL' => route ( 'admin.api.languages' ) , 'newFormUrl' => route ( 'admin.api.form-manager' , [ 'languages-new' ] ) , 'editFormUrl' => route ( 'admin.api.form-manager' , [ 'languages-edit' ] ) , 'imagesUrl' => route ( 'resource.get' , [ '/' ] ) , 'headers' => $ this -> getAdminListHeader ( ) , ] ; $ config [ 'actions' ] [ ] = 'search' ; return hcview ( 'HCCoreUI::admin.content.list' , [ 'config' => $ config ] ) ; }
2152	public function synchronize ( $ varValue , $ objUser , $ objModule = null ) { if ( $ objUser === null ) { return $ varValue ; } $ blnIsFrontend = true ; if ( $ objUser instanceof DataContainer ) { $ objUser = $ this -> Database -> prepare ( "SELECT * FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ objUser -> id ) ; if ( $ objUser -> numRows < 1 ) { return $ varValue ; } $ blnIsFrontend = false ; } if ( $ varValue == $ objUser -> newsletter || $ objUser -> email == '' ) { return $ varValue ; } $ time = time ( ) ; $ varValue = StringUtil :: deserialize ( $ varValue , true ) ; if ( $ blnIsFrontend && $ objModule instanceof Module ) { $ arrChannel = StringUtil :: deserialize ( $ objModule -> newsletters , true ) ; } else { $ arrChannel = $ this -> Database -> query ( "SELECT id FROM tl_newsletter_channel" ) -> fetchEach ( 'id' ) ; } $ arrDelete = array_values ( array_diff ( $ arrChannel , $ varValue ) ) ; if ( ! empty ( $ arrDelete ) && \ is_array ( $ arrDelete ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrDelete ) ) . ") AND email=?" ) -> execute ( $ objUser -> email ) ; } foreach ( $ varValue as $ intId ) { $ intId = ( int ) $ intId ; if ( $ intId < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intId , $ objUser -> email ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, active=?, addedOn=?" ) -> execute ( $ intId , $ objUser -> email , ( $ objUser -> disable ? '' : 1 ) , ( $ blnIsFrontend ? $ time : '' ) ) ; } } return serialize ( $ varValue ) ; }
4948	public function findDraftsBy ( array $ criteria , array $ sort = null , $ limit = null , $ skip = null ) { $ criteria [ 'isDraft' ] = true ; return parent :: findBy ( $ criteria , $ sort , $ limit , $ skip ) ; }
12424	public function getAuthorizationInfo ( $ authCode = null ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorization_code' => $ authCode ? : $ this -> request -> get ( 'auth_code' ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTH_INFO , $ params ] ) ; }
3719	protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) ) { return false ; } if ( $ event -> getPropertyName ( ) !== 'type' ) { return false ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ request -> request -> get ( 'act' , null ) === 'select' && ! $ event -> getModel ( ) -> getId ( ) ) { return false ; } return true ; }
8108	public function getReviewFrom ( ) { $ from = $ this -> owner -> getField ( 'ReviewFrom' ) ; if ( $ from ) { return $ from ; } return Config :: inst ( ) -> get ( Email :: class , 'admin_email' ) ; }
1311	public function checkSignature ( Request $ request , Consumer $ consumer , Token $ token , $ signature ) { $ built = $ this -> buildSignature ( $ request , $ consumer , $ token ) ; if ( strlen ( $ built ) == 0 || strlen ( $ signature ) == 0 ) { return false ; } if ( strlen ( $ built ) != strlen ( $ signature ) ) { return false ; } $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ signature ) ; $ i ++ ) { $ result |= ord ( $ built { $ i } ) ^ ord ( $ signature { $ i } ) ; } return $ result == 0 ; }
9092	public function putPagePartial ( $ page , $ partial ) { if ( null === $ partial || is_string ( $ partial ) || is_array ( $ partial ) ) { $ this -> pagePartials [ $ page ] = $ partial ; } return $ this ; }
11129	protected function stringize ( array & $ arguments ) { array_walk ( $ arguments , function ( & $ value ) { if ( is_object ( $ value ) ) { $ value = get_class ( $ value ) ; } elseif ( is_scalar ( $ value ) ) { $ value = ( string ) $ value ; } else { $ value = json_encode ( $ value , 0 ) ; } } ) ; return $ this ; }
1691	protected function compileColor ( $ color , $ blnWriteToFile = false , $ vars = array ( ) ) { if ( ! \ is_array ( $ color ) ) { return '#' . $ this -> shortenHexColor ( $ color ) ; } elseif ( ! isset ( $ color [ 1 ] ) || empty ( $ color [ 1 ] ) ) { return '#' . $ this -> shortenHexColor ( $ color [ 0 ] ) ; } else { return 'rgba(' . implode ( ',' , $ this -> convertHexColor ( $ color [ 0 ] , $ blnWriteToFile , $ vars ) ) . ',' . ( $ color [ 1 ] / 100 ) . ')' ; } }
197	public function setDownloadHeaders ( $ attachmentName , $ mimeType = null , $ inline = false , $ contentLength = null ) { $ headers = $ this -> getHeaders ( ) ; $ disposition = $ inline ? 'inline' : 'attachment' ; $ headers -> setDefault ( 'Pragma' , 'public' ) -> setDefault ( 'Accept-Ranges' , 'bytes' ) -> setDefault ( 'Expires' , '0' ) -> setDefault ( 'Cache-Control' , 'must-revalidate, post-check=0, pre-check=0' ) -> setDefault ( 'Content-Disposition' , $ this -> getDispositionHeaderValue ( $ disposition , $ attachmentName ) ) ; if ( $ mimeType !== null ) { $ headers -> setDefault ( 'Content-Type' , $ mimeType ) ; } if ( $ contentLength !== null ) { $ headers -> setDefault ( 'Content-Length' , $ contentLength ) ; } return $ this ; }
1505	protected function bindPageResolver ( ) : void { AbstractPaginator :: currentPageResolver ( function ( $ pageName ) { $ pagination = app ( EncodingParametersInterface :: class ) -> getPaginationParameters ( ) ? : [ ] ; return $ pagination [ $ pageName ] ?? null ; } ) ; }
12672	public static function emulate ( $ emulation , callable $ assertionCallable = null ) { if ( ( is_string ( $ emulation ) ) && ( class_exists ( $ emulation ) ) ) { $ emulation = new $ emulation ( $ assertionCallable ) ; } static :: $ emulation = $ emulation ; }
12469	protected function replaceNamespace ( $ path ) { $ search = [ 'namespace ' . $ this -> currentRoot . ';' , $ this -> currentRoot . '\\' ] ; $ replace = [ 'namespace ' . $ this -> argument ( 'name' ) . ';' , $ this -> argument ( 'name' ) . '\\' ] ; $ this -> replaceIn ( $ path , $ search , $ replace ) ; }
6203	public static function start ( $ apiKey , $ notifyOnWarning = false , array $ options = array ( ) ) { if ( ! isset ( self :: $ instance ) ) { $ config = new Configuration ( $ apiKey , $ options ) ; $ client = new Client ( $ config ) ; self :: $ instance = new self ( $ client , $ notifyOnWarning ) ; if ( null !== $ config -> get ( 'errorReportingLevel' ) ) { self :: $ instance -> addErrorFilter ( new ErrorReporting ( $ config ) ) ; } self :: $ instance -> addExceptionFilter ( new AirbrakeExceptionFilter ( ) ) ; set_error_handler ( array ( self :: $ instance , 'onError' ) ) ; set_exception_handler ( array ( self :: $ instance , 'onException' ) ) ; register_shutdown_function ( array ( self :: $ instance , 'onShutdown' ) ) ; } return self :: $ instance ; }
3781	private function determineFilterValue ( $ filterValues , $ valueName ) { if ( ! isset ( $ filterValues [ $ valueName ] ) && $ this -> get ( 'defaultid' ) ) { return $ this -> get ( 'defaultid' ) ; } return $ filterValues [ $ valueName ] ; }
11	private function mockLocalRepositories ( RepositoryManager $ rm ) { $ packages = array ( ) ; foreach ( $ rm -> getLocalRepository ( ) -> getPackages ( ) as $ package ) { $ packages [ ( string ) $ package ] = clone $ package ; } foreach ( $ packages as $ key => $ package ) { if ( $ package instanceof AliasPackage ) { $ alias = ( string ) $ package -> getAliasOf ( ) ; $ packages [ $ key ] = new AliasPackage ( $ packages [ $ alias ] , $ package -> getVersion ( ) , $ package -> getPrettyVersion ( ) ) ; } } $ rm -> setLocalRepository ( new InstalledArrayRepository ( $ packages ) ) ; }
9855	protected function storeBof ( $ type ) { $ record = 0x0809 ; $ length = 0x0010 ; $ unknown = pack ( 'VV' , 0x000100D1 , 0x00000406 ) ; $ build = 0x0DBB ; $ year = 0x07CC ; $ version = 0x0600 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ version , $ type , $ build , $ year ) ; $ this -> append ( $ header . $ data . $ unknown ) ; }
9900	private function advance ( ) { $ i = $ this -> currentCharacter ; $ formula_length = strlen ( $ this -> formula ) ; if ( $ i < $ formula_length ) { while ( $ this -> formula [ $ i ] == ' ' ) { ++ $ i ; } if ( $ i < ( $ formula_length - 1 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 1 ] ; } $ token = '' ; } while ( $ i < $ formula_length ) { $ token .= $ this -> formula [ $ i ] ; if ( $ i < ( $ formula_length - 1 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 1 ] ; } else { $ this -> lookAhead = '' ; } if ( $ this -> match ( $ token ) != '' ) { $ this -> currentCharacter = $ i + 1 ; $ this -> currentToken = $ token ; return 1 ; } if ( $ i < ( $ formula_length - 2 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 2 ] ; } else { $ this -> lookAhead = '' ; } ++ $ i ; } }
1410	public function resourceTypeNotRecognised ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'resource_type_not_recognised' , 'code' ) , $ this -> trans ( 'resource_type_not_recognised' , 'title' ) , $ this -> trans ( 'resource_type_not_recognised' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'type' ) ) ; }
699	public function actionApp ( $ app , $ repo = null ) { $ base = \ dirname ( \ dirname ( __DIR__ ) ) ; $ appDir = "$base/apps/$app" ; if ( ! file_exists ( $ appDir ) ) { if ( empty ( $ repo ) ) { if ( isset ( $ this -> apps [ $ app ] ) ) { $ repo = $ this -> apps [ $ app ] ; if ( $ this -> useHttp ) { $ repo = str_replace ( 'git@github.com:' , 'https://github.com/' , $ repo ) ; } } else { $ this -> stderr ( "Repo argument is required for app '$app'.\n" , Console :: FG_RED ) ; return 1 ; } } $ this -> stdout ( "cloning application repo '$app' from '$repo'...\n" , Console :: BOLD ) ; passthru ( 'git clone ' . escapeshellarg ( $ repo ) . ' ' . $ appDir ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } $ this -> stdout ( "cleaning up application '$app' vendor directory...\n" , Console :: BOLD ) ; $ this -> cleanupVendorDir ( $ appDir ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; $ this -> stdout ( "updating composer for app '$app'...\n" , Console :: BOLD ) ; chdir ( $ appDir ) ; $ command = 'composer update --prefer-dist' ; if ( $ this -> composerNoProgress ) { $ command .= ' --no-progress' ; } passthru ( $ command ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; $ this -> stdout ( "linking framework and extensions to '$app' app vendor dir...\n" , Console :: BOLD ) ; $ this -> linkFrameworkAndExtensions ( $ appDir , $ base ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; return 0 ; }
9581	public function getChannel ( $ channel = null ) { $ channel = $ channel ? : $ this -> defaultChannel ; if ( isset ( $ this -> deferredChannels [ $ channel ] ) ) { $ this -> setChannel ( $ channel , $ this -> deferredChannels [ $ channel ] ( ) ) ; unset ( $ this -> deferredChannels [ $ channel ] ) ; } if ( isset ( $ this -> channels [ $ channel ] ) ) { return $ this -> channels [ $ channel ] ; } throw new InvalidArgumentException ( "Undefined channel: $channel" ) ; }
7557	function getChildrenByTag ( $ tag , $ compare = 'total' , $ recursive = true ) { if ( $ this -> childCount ( ) < 1 ) { return array ( ) ; } $ tag = explode ( ' ' , strtolower ( $ tag ) ) ; $ match = ( ( isset ( $ tag [ 1 ] ) && ( $ tag [ 1 ] === 'not' ) ) ? 'false' : 'true' ) ; return $ this -> getChildrenByMatch ( array ( 'tags' => array ( $ tag [ 0 ] => array ( 'match' => $ match , 'compare' => $ compare ) ) ) , $ recursive ) ; }
558	protected function buildBlockCondition ( $ operator , $ condition ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } return [ $ operator , $ this -> buildCondition ( $ condition ) , ] ; }
7144	public static function remove_author_meta_values ( ) { global $ blog_id ; if ( isset ( $ blog_id ) && ! empty ( $ blog_id ) ) { $ blogusers = get_users ( array ( 'blog_id' => $ blog_id ) ) ; foreach ( $ blogusers as $ user_object ) { delete_user_meta ( $ user_object -> ID , 'post_subscription' ) ; delete_user_meta ( $ user_object -> ID , 'comment_subscription' ) ; } } }
7005	private function format_d ( & $ str ) { if ( strstr ( $ str , '%d' ) ) $ str = str_replace ( '%d' , sprintf ( '%02d' , $ this -> day ) , $ str ) ; }
3588	protected function getMetaBetweenConstraint ( $ column , array $ values ) { $ min = $ values [ 0 ] ; $ max = $ values [ 1 ] ; return function ( $ query ) use ( $ column , $ min , $ max ) { $ query -> where ( 'meta_key' , $ column ) -> where ( 'meta_value' , '>=' , $ min ) -> where ( 'meta_value' , '<=' , $ max ) ; } ; }
3663	private function getValueFromServiceContainer ( $ valueName , $ arguments ) { if ( ! empty ( $ arguments [ 'service' ] ) ) { $ serviceName = $ arguments [ 'service' ] ; } else { $ serviceName = $ valueName ; } $ service = $ this -> container -> get ( IMetaModelsServiceContainer :: class ) -> getService ( $ serviceName ) ; if ( is_callable ( $ service ) ) { return call_user_func ( $ service , $ valueName , $ arguments ) ; } return 'NULL' ; }
11394	public static function setKindOfReportLog ( string $ sKindOfReportLog ) { if ( $ sKindOfReportLog === 'screen' || $ sKindOfReportLog === 'all' ) { self :: $ _sKindOfReportLog = $ sKindOfReportLog ; } else { self :: $ _sKindOfReportLog = 'error_log' ; } }
3339	public function getGroupsChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'group_list' , 'GET' , $ options ) ; $ groups_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ groups_raw as $ group_raw ) { $ resultArr [ ] = new Group ( $ group_raw -> id , $ this ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; }
7538	function getRoot ( ) { $ r = $ this -> parent ; $ n = ( $ r === null ) ? null : $ r -> parent ; while ( $ n !== null ) { $ r = $ n ; $ n = $ r -> parent ; } return $ r ; }
7429	public function loginAction ( Request $ request ) { $ session = $ request -> getSession ( ) ; $ form = $ this -> createFormBuilder ( ) -> add ( 'username' , TextType :: class , array ( 'label' => 'Username' ) ) -> add ( 'password' , PasswordType :: class , array ( 'label' => 'Password' ) ) -> add ( 'rememberMe' , CheckboxType :: class , array ( 'label' => 'Remember Me' , 'required' => false ) ) -> getForm ( ) ; $ helper = $ this -> get ( 'security.authentication_utils' ) ; if ( $ lastUsername = $ helper -> getLastUsername ( ) ) { $ form -> setData ( array ( 'username' => $ lastUsername ) ) ; } return array ( 'form' => $ form -> createView ( ) ) ; }
8825	protected function valid_cc ( $ data ) { $ number = preg_replace ( '/\D/' , '' , $ data ) ; if ( function_exists ( 'mb_strlen' ) ) { $ number_length = mb_strlen ( $ number ) ; } else { $ number_length = strlen ( $ number ) ; } $ parity = $ number_length % 2 ; $ total = 0 ; for ( $ i = 0 ; $ i < $ number_length ; $ i ++ ) { $ digit = $ number [ $ i ] ; if ( $ i % 2 == $ parity ) { $ digit *= 2 ; if ( $ digit > 9 ) { $ digit -= 9 ; } } $ total += $ digit ; } return ( $ total % 10 == 0 ) ? true : false ; }
8266	public function lock ( $ lockType ) { if ( ! $ this -> isOpened ( ) ) { return false ; } if ( $ this -> options [ "blocking" ] ) { return flock ( $ this -> handle , $ lockType ) ; } else { $ tries = 0 ; do { if ( flock ( $ this -> handle , $ lockType | LOCK_NB ) ) { return true ; } else { ++ $ tries ; usleep ( self :: LOCK_RETRY_WAIT ) ; } } while ( $ tries < self :: LOCK_MAX_TRIES ) ; return false ; } }
4090	public function delete ( $ id = false , $ index , $ type , array $ options = array ( ) ) { $ params = array ( '_id' => $ id , '_index' => $ index , '_type' => $ type ) ; foreach ( $ options as $ key => $ value ) { $ params [ '_' . $ key ] = $ value ; } $ operation = array ( array ( 'delete' => $ params ) ) ; $ this -> operations [ ] = $ operation ; return $ this ; }
2690	public function getResizedImageInfo ( ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { return parent :: getResizedImageInfo ( ) ; } if ( $ this -> getBaseFile ( ) !== null ) { return [ 0 => $ this -> getWidth ( ) , 1 => $ this -> getHeight ( ) ] ; } $ asset = $ this -> _assetRepo -> createAsset ( "Magento_Catalog::images/product/placeholder/{$this->getDestinationSubdir()}.jpg" ) ; $ img = $ asset -> getSourceFile ( ) ; $ imageInfo = getimagesize ( $ img ) ; $ this -> setWidth ( $ imageInfo [ 0 ] ) ; $ this -> setHeight ( $ imageInfo [ 1 ] ) ; return $ imageInfo ; }
1064	private function collectConflictsWithin ( ValidationContext $ context , array & $ conflicts , array $ fieldMap ) { foreach ( $ fieldMap as $ responseName => $ fields ) { $ fieldsLength = count ( $ fields ) ; if ( $ fieldsLength <= 1 ) { continue ; } for ( $ i = 0 ; $ i < $ fieldsLength ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ fieldsLength ; $ j ++ ) { $ conflict = $ this -> findConflict ( $ context , false , $ responseName , $ fields [ $ i ] , $ fields [ $ j ] ) ; if ( ! $ conflict ) { continue ; } $ conflicts [ ] = $ conflict ; } } } }
3911	protected function fetchAdditionalData ( ) { $ this -> modifiedTime = array ( ) ; $ this -> outputBuffer = array ( ) ; if ( ! $ this -> foundFiles ) { return ; } foreach ( $ this -> foundFiles as $ strFile ) { $ this -> processFile ( $ strFile ) ; } }
11532	public static function cascade ( array $ folders ) { $ result = null ; foreach ( $ folders as $ folder ) { if ( is_dir ( $ folder ) ) { $ result = $ folder ; break ; } } return $ result ; }
6438	public function completeLogin ( $ extrainputs = array ( ) ) { $ request_token = [ ] ; $ request_token [ 'oauth_token' ] = $ this -> request_token [ 'oauth_token' ] ; $ request_token [ 'oauth_token_secret' ] = $ this -> request_token [ 'oauth_token_secret' ] ; $ this -> logQ ( 'session token ' . print_r ( $ request_token , true ) , 'twitter' ) ; $ this -> logQ ( 'extra options ' . print_r ( $ extrainputs , true ) , 'twitter' ) ; if ( isset ( $ extrainputs [ 'oauth_token' ] ) && $ request_token [ 'oauth_token' ] !== $ extrainputs [ 'oauth_token' ] ) { throw new \ Exception ( 'Twitter oauth. Somethign went wrong. No token in the session' ) ; } $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] , $ request_token [ 'oauth_token' ] , $ request_token [ 'oauth_token_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ access_token = $ connection -> oauth ( "oauth/access_token" , array ( "oauth_verifier" => $ extrainputs [ 'oauth_verifier' ] ) ) ; $ this -> access_token = $ access_token ; return $ this -> getUserProfile ( ) ; }
9918	public function getTableName ( Model $ model , ModelConfig $ config = null ) { if ( empty ( $ this -> models ) ) { throw new \ LogicException ( 'AujaConfigurator not configured yet! Call configure first.' ) ; } if ( ! isset ( $ this -> configs [ $ model -> getName ( ) ] ) ) { throw new \ LogicException ( sprintf ( 'AujaConfigurator not configured for model %s' , $ model -> getName ( ) ) ) ; } $ result = null ; if ( $ config != null && $ config -> getTableName ( ) != null ) { $ result = $ config -> getTableName ( ) ; } else { $ modelConfig = $ this -> configs [ $ model -> getName ( ) ] ; $ result = $ modelConfig -> getTableName ( ) ; } return $ result ; }
7916	public function initOptions ( ) { Ui :: addCssClasses ( $ this -> options , [ 'ui' , 'message' ] ) ; if ( ! empty ( $ this -> header ) && isset ( $ this -> header [ 'options' ] ) ) { Ui :: addCssClass ( $ this -> header [ 'options' ] , 'header' ) ; } if ( isset ( $ this -> icon ) ) { Ui :: addCssClass ( $ this -> options , 'icon' ) ; } }
7951	public function orderCacheRule ( $ nbCacheRule , $ duration ) { return json_decode ( self :: getClient ( ) -> orderCacheRule ( $ this -> sn , $ nbCacheRule , $ duration ) ) ; }
5780	private function setNav ( ) { $ this -> nav = [ 'System' => [ 'subSections' => [ 'Administrators' => [ 'route' => ROUTE_ADMINISTRATORS , 'authorization' => ADMINISTRATORS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_INSERT , 'authorization' => ADMINISTRATORS_INSERT_RESOURCE , ] , ] ] , 'Roles' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES , 'authorization' => ROLES_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES_INSERT , 'authorization' => ROLES_INSERT_RESOURCE , ] , ] , ] , 'Permissions' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS , 'authorization' => PERMISSIONS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS_INSERT , 'authorization' => PERMISSIONS_INSERT_RESOURCE , ] , ] ] , 'Events' => [ 'route' => ROUTE_EVENTS , 'authorization' => EVENTS_VIEW_RESOURCE , 'subSections' => [ 'Types' => [ 'route' => ROUTE_DATABASE_TABLES , 'args' => [ ROUTEARG_DATABASE_TABLE_NAME => 'event_types' ] , 'authorization' => EVENTS_VIEW_RESOURCE , ] , ] ] , 'Database' => [ 'authorization' => DATABASE_TABLES_VIEW_RESOURCE , 'subSections' => $ this -> getDatabaseTablesSection ( ) ] , ] ] , 'Logout' => [ 'route' => ROUTE_LOGOUT , ] , ] ; if ( isset ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { if ( ! is_array ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { throw new \ Exception ( "adminNav config must be array" ) ; } $ this -> nav = array_merge ( $ this -> container [ 'settings' ] [ 'adminNav' ] , $ this -> nav ) ; } }
284	private function getFixturesConfig ( $ fixtures ) { $ config = [ ] ; foreach ( $ fixtures as $ fixture ) { $ isNamespaced = ( strpos ( $ fixture , '\\' ) !== false ) ; $ fixture = str_replace ( '/' , '\\' , $ fixture ) ; $ fullClassName = $ isNamespaced ? $ fixture : $ this -> namespace . '\\' . $ fixture ; if ( class_exists ( $ fullClassName ) ) { $ config [ ] = $ fullClassName ; } elseif ( class_exists ( $ fullClassName . 'Fixture' ) ) { $ config [ ] = $ fullClassName . 'Fixture' ; } } return $ config ; }
8948	public function downloadTraceMetadetails ( $ id , $ username , $ password ) { $ base = 'gpx/' . $ id . '/details' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; return $ this -> sendRequest ( $ path , 'GET' , array ( 'Authorization' => 'Basic ' . base64_encode ( $ username . ':' . $ password ) ) ) ; }
1037	private function completeObjectValue ( ObjectType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ isTypeOf = $ returnType -> isTypeOf ( $ result , $ this -> exeContext -> contextValue , $ info ) ; if ( $ isTypeOf !== null ) { $ promise = $ this -> getPromise ( $ isTypeOf ) ; if ( $ promise ) { return $ promise -> then ( function ( $ isTypeOfResult ) use ( $ returnType , $ fieldNodes , $ path , & $ result ) { if ( ! $ isTypeOfResult ) { throw $ this -> invalidReturnTypeError ( $ returnType , $ result , $ fieldNodes ) ; } return $ this -> collectAndExecuteSubfields ( $ returnType , $ fieldNodes , $ path , $ result ) ; } ) ; } if ( ! $ isTypeOf ) { throw $ this -> invalidReturnTypeError ( $ returnType , $ result , $ fieldNodes ) ; } } return $ this -> collectAndExecuteSubfields ( $ returnType , $ fieldNodes , $ path , $ result ) ; }
3013	public function like ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/like' , $ options , false ) ; }
9660	public static function identify ( $ pFilename ) { $ reader = self :: createReaderForFile ( $ pFilename ) ; $ className = get_class ( $ reader ) ; $ classType = explode ( '\\' , $ className ) ; unset ( $ reader ) ; return array_pop ( $ classType ) ; }
5416	protected function dispatchRequest ( $ socket , $ encoding ) { foreach ( $ this -> headers as $ header_line ) { $ socket -> write ( $ header_line . "\r\n" ) ; } if ( count ( $ this -> cookies ) > 0 ) { $ socket -> write ( 'Cookie: ' . implode ( ';' , $ this -> cookies ) . "\r\n" ) ; } $ encoding -> writeHeadersTo ( $ socket ) ; $ socket -> write ( "\r\n" ) ; $ encoding -> writeTo ( $ socket ) ; }
3178	public function getItemClasses ( ) { $ itemClass = $ this -> getClass ( self :: ITEM_ROOT_CLASS_URI ) ; return $ this -> getResourceService ( ) -> getAllClasses ( $ itemClass ) ; }
6040	public function download ( $ sessionId , array $ downloads ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'downloads' => $ downloads ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/download' , $ parameters , true ) ; return $ result ; }
5206	public function areActiveRoutes ( array $ routeNames , $ output = "active" ) { foreach ( $ routeNames as $ routeName ) { if ( $ this -> isActiveRoute ( $ routeName , true ) ) { return $ output ; } } return null ; }
11135	protected function calculateUPDATE ( ) { $ this -> query .= 'UPDATE ' ; $ this -> queryStringFromArray ( 'tables' , '' , ', ' ) ; $ this -> queryStringFromArray ( 'updates' , ' SET ' , ', ' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } }
4752	public function send ( ) { $ optInValue = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'c_oegdproptin' ) ; if ( $ this -> isOptInValidationRequired ( ) && ! $ optInValue ) { \ OxidEsales \ Eshop \ Core \ Registry :: get ( \ OxidEsales \ Eshop \ Core \ UtilsView :: class ) -> addErrorToDisplay ( 'OEGDPROPTIN_CONTACT_FORM_ERROR_MESSAGE' ) ; $ this -> optInError = true ; return false ; } return parent :: send ( ) ; }
5805	public function increment ( ) { $ this -> counter ++ ; if ( 1 === $ this -> counter ) { $ this -> expiresAt = $ this -> now ( ) + $ this -> expiresIn ; } }
7927	public function registerNamespace ( $ ns , $ def ) { list ( $ ns , $ def ) = $ this -> fireEvent ( 'namespace.register' , [ $ ns , $ def ] ) ; $ this -> namespaces [ $ ns ] = $ def ; return $ this ; }
10244	public function getImplementedFunctionNames ( ) { $ returnValue = [ ] ; foreach ( self :: $ phpSpreadsheetFunctions as $ functionName => $ function ) { if ( $ this -> isImplemented ( $ functionName ) ) { $ returnValue [ ] = $ functionName ; } } return $ returnValue ; }
998	public function getTypeMap ( ) { if ( ! $ this -> fullyLoaded ) { $ this -> resolvedTypes = $ this -> collectAllTypes ( ) ; $ this -> fullyLoaded = true ; } return $ this -> resolvedTypes ; }
9962	public function insertNewRowBefore ( $ pBefore , $ pNumRows = 1 ) { if ( $ pBefore >= 1 ) { $ objReferenceHelper = ReferenceHelper :: getInstance ( ) ; $ objReferenceHelper -> insertNewBefore ( 'A' . $ pBefore , 0 , $ pNumRows , $ this ) ; } else { throw new Exception ( 'Rows can only be inserted before at least row 1.' ) ; } return $ this ; }
1718	public function onKernelRequest ( GetResponseEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser || ! $ user -> language ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> setLocale ( $ user -> language ) ; $ this -> translator -> setLocale ( $ user -> language ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = str_replace ( '_' , '-' , $ user -> language ) ; }
988	public function activate ( ) { if ( ! $ this -> chargeId ) { throw new Exception ( 'Can not activate plan without a charge ID.' ) ; } $ this -> response = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}/{$this->chargeId}/activate.json" ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ this -> response ; }
7113	public function urlAllowed ( $ user , $ url ) { if ( empty ( $ url ) ) { return false ; } if ( is_array ( $ url ) ) { $ url = Hash :: merge ( [ 'plugin' => null ] , $ url ) ; $ url = Router :: url ( $ url ) ; $ url = Router :: normalize ( $ url ) ; } $ route = Router :: parse ( $ url ) ; if ( empty ( $ route [ 'controller' ] ) || empty ( $ route [ 'action' ] ) ) { return false ; } return $ this -> isAuthorized ( $ user , $ route [ 'plugin' ] , $ route [ 'controller' ] , $ route [ 'action' ] ) ; }
12658	private function getFileName ( $ language ) { if ( $ language === $ this -> baseLang ) { return $ this -> baseDir . $ this -> pageName . '.js' ; } else { return $ this -> baseDir . $ language . '/' . $ this -> pageName . '.js' ; } }
4124	private function generateProxyClass ( $ class , $ fileName , $ template ) { $ methods = $ this -> generateMethods ( $ class ) ; $ sleepImpl = $ this -> generateSleep ( $ class ) ; $ placeholders = array ( '<namespace>' , '<proxyClassName>' , '<className>' , '<methods>' , '<sleepImpl>' ) ; $ className = ltrim ( $ class -> name , '\\' ) ; $ proxyClassName = ClassUtils :: generateProxyClassName ( $ class -> name , $ this -> proxyNamespace ) ; $ parts = explode ( '\\' , strrev ( $ proxyClassName ) , 2 ) ; $ proxyClassNamespace = strrev ( $ parts [ 1 ] ) ; $ proxyClassName = strrev ( $ parts [ 0 ] ) ; $ replacements = array ( $ proxyClassNamespace , $ proxyClassName , $ className , $ methods , $ sleepImpl ) ; $ template = str_replace ( $ placeholders , $ replacements , $ template ) ; file_put_contents ( $ fileName , $ template , LOCK_EX ) ; }
686	protected function sortModels ( $ models , $ sort ) { $ orders = $ sort -> getOrders ( ) ; if ( ! empty ( $ orders ) ) { ArrayHelper :: multisort ( $ models , array_keys ( $ orders ) , array_values ( $ orders ) ) ; } return $ models ; }
12614	public function have_required_properties ( ) { return ( ! empty ( $ this -> handle ) && ! empty ( $ this -> relative_path ) && ! empty ( $ this -> filename ) ) ; }
2632	public function sendPurgeRequest ( $ pattern = '' ) { if ( empty ( $ pattern ) ) { if ( $ this -> config -> canPreserveStatic ( ) ) { $ result = $ this -> api -> cleanBySurrogateKey ( [ 'text' ] ) ; } else { $ result = $ this -> api -> cleanAll ( ) ; } } elseif ( ! is_array ( $ pattern ) && strpos ( $ pattern , 'http' ) === 0 ) { $ result = $ this -> api -> cleanUrl ( $ pattern ) ; } elseif ( is_array ( $ pattern ) ) { $ result = $ this -> api -> cleanBySurrogateKey ( $ pattern ) ; } else { return false ; } return $ result ; }
3837	private function getBaseDefinition ( ) { $ this -> setLanguageStrings ( ) ; $ tableName = $ this -> getMetaModel ( ) -> getTableName ( ) ; $ definition = array ( ) ; if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] [ 'fields' ] [ $ this -> getColName ( ) ] ) ) { $ definition = $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] [ 'fields' ] [ $ this -> getColName ( ) ] ; } return array_replace_recursive ( array ( 'label' => & $ GLOBALS [ 'TL_LANG' ] [ $ tableName ] [ $ this -> getColName ( ) ] , 'eval' => array ( ) ) , $ definition ) ; }
6693	public static function sort ( $ a , $ b ) { if ( ! isset ( $ a [ 'position' ] ) ) { return 0 ; } if ( ! isset ( $ b [ 'position' ] ) ) { return 0 ; } if ( $ a [ 'position' ] === $ b [ 'position' ] ) { return 0 ; } return ( $ a [ 'position' ] < $ b [ 'position' ] ) ? - 1 : 1 ; }
12182	public function getPrimaryChild ( $ parentObject ) { if ( ! $ this -> handlePrimary ) { return false ; } if ( ! $ this -> child -> getPrimaryAsChild ( $ this -> parent ) ) { return false ; } $ key = json_encode ( [ __FUNCTION__ , $ this -> systemId , $ parentObject -> primaryKey ] ) ; if ( ! isset ( self :: $ _cache [ $ key ] ) ) { self :: $ _cache [ $ key ] = null ; $ relationClass = Yii :: $ app -> classes [ 'Relation' ] ; $ childClass = $ this -> child -> primaryModel ; $ relation = $ relationClass :: find ( ) ; $ alias = $ relationClass :: tableName ( ) ; $ relation -> andWhere ( [ '`' . $ alias . '`.`parent_object_id`' => $ parentObject -> primaryKey , '`' . $ alias . '`.`primary_child`' => 1 ] ) ; $ relation -> andWhere ( [ 'or' , '`' . $ alias . '`.`child_object_id` LIKE :prefix' ] ) ; $ relation -> params [ ':prefix' ] = $ childClass :: modelPrefix ( ) . '-%' ; $ parentObject -> addActiveConditions ( $ relation , $ alias ) ; $ relation = $ relation -> one ( ) ; if ( ! empty ( $ relation ) ) { self :: $ _cache [ $ key ] = $ relation ; } } return self :: $ _cache [ $ key ] ; }
4389	public function repay ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; if ( ( $ cfg = $ this -> getCustomerData ( $ base -> getCustomerId ( ) , 'repay' ) ) === null ) { $ msg = sprintf ( 'No reoccurring payment data available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } if ( ! isset ( $ cfg [ 'token' ] ) ) { $ msg = sprintf ( 'No payment token available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } $ data = array ( 'transactionId' => $ order -> getId ( ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'cardReference' => $ cfg [ 'token' ] , 'paymentPage' => false , ) ; if ( isset ( $ cfg [ 'month' ] ) && isset ( $ cfg [ 'year' ] ) ) { $ data [ 'card' ] = new \ Omnipay \ Common \ CreditCard ( [ 'expiryMonth' => $ cfg [ 'month' ] , 'expiryYear' => $ cfg [ 'year' ] , ] ) ; } $ response = $ this -> getXmlProvider ( ) -> purchase ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ this -> saveTransationRef ( $ base , $ response -> getTransactionReference ( ) ) ; $ order -> setPaymentStatus ( \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ) ; $ this -> saveOrder ( $ order ) ; } else { $ msg = ( method_exists ( $ response , 'getMessage' ) ? $ response -> getMessage ( ) : '' ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( sprintf ( 'Token based payment failed: %1$s' , $ msg ) ) ; } }
5813	public function getCMSFields ( ) { $ fields = parent :: getCMSFields ( ) ; $ types = array ( ) ; foreach ( $ this -> service -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } if ( count ( $ types ) ) { $ fields -> replaceField ( 'TagTypes' , $ list = ListboxField :: create ( 'Types' , 'Tag Types' , $ types ) -> setMultiple ( true ) ) ; $ items = is_string ( $ this -> TagTypes ) ? array_keys ( unserialize ( $ this -> TagTypes ) ) : array ( ) ; $ list -> setValue ( $ items ) ; $ list -> setDisabledItems ( $ items ) ; } else { $ fields -> removeByName ( 'TagTypes' ) ; } $ this -> extend ( 'updateFusionTagCMSFields' , $ fields ) ; return $ fields ; }
3039	public function has ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { return $ this -> getStorage ( ) -> has ( $ userId , $ callId ) ; } return $ this -> exists ( $ key ) ; }
9317	public function perform ( $ src , $ dst ) { $ inClusterHandler = eZClusterFileHandler :: instance ( $ src ) ; $ inClusterHandler -> fetch ( ) ; try { $ this -> converter -> transform ( 'transformation' , $ src , $ dst ) ; } catch ( Exception $ e ) { $ inClusterHandler -> deleteLocal ( ) ; throw $ e ; } $ outClusterHandler = eZClusterFileHandler :: instance ( ) ; $ outClusterHandler -> fileStore ( $ dst , 'image' ) ; eZImageHandler :: changeFilePermissions ( $ dst ) ; }
8655	private function convertGetReportCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
1329	public function set ( $ key , $ value = null ) { $ keys = is_array ( $ key ) ? $ key : [ $ key => $ value ] ; foreach ( $ keys as $ key => $ value ) { self :: updateOrCreate ( [ 'key' => $ key ] , [ 'value' => $ value ] ) ; } }
4868	protected function parseOptionsToDateTime ( $ options ) { $ time = microtime ( true ) ; $ micro = sprintf ( "%06d" , ( $ time - floor ( $ time ) ) * 1000000 ) ; $ this -> now = new \ DateTime ( date ( 'Y-m-d H:i:s.' . $ micro , $ time ) , new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; $ scheduled = isset ( $ options [ 'scheduled' ] ) ? Utils :: createDateTime ( $ options [ 'scheduled' ] ) : clone ( $ this -> now ) ; if ( isset ( $ options [ 'delay' ] ) ) { $ delay = Utils :: createDateInterval ( $ options [ 'delay' ] ) ; $ scheduled -> add ( $ delay ) ; } return $ scheduled ; }
12948	public function removeTagValues ( $ tags ) { $ this -> _tagsList = array_diff ( $ this -> getTagValues ( ) , $ this -> parseTags ( $ tags ) ) ; $ this -> updateOwnerTags ( ) ; }
415	public function getAcceptableContentTypes ( ) { if ( $ this -> _contentTypes === null ) { if ( $ this -> headers -> get ( 'Accept' ) !== null ) { $ this -> _contentTypes = $ this -> parseAcceptHeader ( $ this -> headers -> get ( 'Accept' ) ) ; } else { $ this -> _contentTypes = [ ] ; } } return $ this -> _contentTypes ; }
3698	private function getOrCreateDefinition ( ) { if ( $ this -> container -> hasDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ) { $ view = $ this -> container -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; if ( ! $ view instanceof Contao2BackendViewDefinitionInterface ) { throw new DcGeneralInvalidArgumentException ( 'Configured BackendViewDefinition does not implement Contao2BackendViewDefinitionInterface.' ) ; } return $ view ; } $ this -> container -> setDefinition ( Contao2BackendViewDefinitionInterface :: NAME , $ view = new Contao2BackendViewDefinition ( ) ) ; return $ view ; }
6100	protected function delete ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_DELETE , null , $ fireAndForget ) ; }
1622	private function addColumn ( $ column , & $ columns ) { if ( isset ( $ columns [ $ column ] ) ) { return $ columns [ $ column ] ; } $ name = 'c' . preg_replace ( "/[^a-z]+/i" , "" , $ column ) . count ( $ columns ) ; return $ columns [ $ column ] = $ name ; }
7983	public function addRestoreTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaRestoreTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
7735	private function documentRouteAndOperations ( $ metadata , Reflector $ element ) { if ( ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Id' ) ) ) || ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Route' ) ) ) ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Operations' ) ; if ( null !== $ annotation ) { $ operations = array_unique ( $ annotation -> operations ) ; $ operationsMetadata = array_map ( array ( $ this , 'getRouteMetadata' ) , $ operations ) ; $ metadata -> setOperations ( $ operationsMetadata ) ; } if ( null !== ( $ route = $ metadata -> getRoute ( ) ) ) { $ metadata -> addOperation ( $ this -> getRouteMetadata ( $ route -> getName ( ) ) ) ; } elseif ( null !== $ annotation ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( reset ( $ annotation -> operations ) ) ) ; } if ( ( $ metadata instanceof PropertyDefinition ) && ( count ( $ operations = $ metadata -> getOperations ( ) ) > 0 ) ) { foreach ( $ operations as $ operation ) { if ( ( 'GET' === $ operation -> getMethod ( ) ) && ( null !== $ operation -> getReturns ( ) ) ) { $ metadata -> setType ( $ operation -> getReturns ( ) ) ; return ; } } $ metadata -> setType ( 'ML\HydraBundle\Entity\Resource' ) ; } }
4222	public function get ( $ key = null ) { if ( $ key == 'lastError' ) { return isset ( $ this -> data [ 'lastError' ] ) ? $ this -> data [ 'lastError' ] -> getValues ( ) : null ; } if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } if ( isset ( $ this -> { $ key } ) ) { return $ this -> { $ key } ; } return null ; }
7302	static function getAvailableTransitions ( PaymentInterface $ payment , $ admin = false ) { $ transitions = [ ] ; $ method = $ payment -> getMethod ( ) ; $ state = $ payment -> getState ( ) ; if ( $ admin ) { if ( $ method -> isManual ( ) ) { switch ( $ state ) { case PaymentStates :: STATE_PENDING : $ transitions [ ] = static :: TRANSITION_CANCEL ; $ transitions [ ] = static :: TRANSITION_ACCEPT ; break ; case PaymentStates :: STATE_CAPTURED : $ transitions [ ] = static :: TRANSITION_CANCEL ; $ transitions [ ] = static :: TRANSITION_HANG ; $ transitions [ ] = static :: TRANSITION_REFUND ; break ; case PaymentStates :: STATE_REFUNDED : $ transitions [ ] = static :: TRANSITION_CANCEL ; $ transitions [ ] = static :: TRANSITION_HANG ; $ transitions [ ] = static :: TRANSITION_ACCEPT ; break ; case PaymentStates :: STATE_CANCELED : $ transitions [ ] = static :: TRANSITION_HANG ; $ transitions [ ] = static :: TRANSITION_ACCEPT ; break ; } } elseif ( $ method -> isOutstanding ( ) || $ method -> isManual ( ) ) { if ( $ state === PaymentStates :: STATE_CAPTURED ) { $ transitions [ ] = static :: TRANSITION_CANCEL ; } else { $ transitions [ ] = static :: TRANSITION_ACCEPT ; } } else { if ( $ state === PaymentStates :: STATE_CAPTURED ) { $ transitions [ ] = static :: TRANSITION_REFUND ; } if ( $ state === PaymentStates :: STATE_PENDING ) { $ diff = $ payment -> getUpdatedAt ( ) -> diff ( new \ DateTime ( ) ) ; if ( 0 < $ diff -> days && ! $ diff -> invert ) { $ transitions [ ] = static :: TRANSITION_CANCEL ; } } } } else { if ( $ method -> isManual ( ) && $ state === PaymentStates :: STATE_PENDING ) { $ transitions [ ] = static :: TRANSITION_CANCEL ; } } return $ transitions ; }
8980	private function buildRateFromTableRowData ( array $ row ) { return new Rate ( $ row [ 'source_name' ] , ( float ) $ row [ 'rate_value' ] , $ row [ 'currency_code' ] , $ row [ 'rate_type' ] , \ DateTime :: createFromFormat ( 'Y-m-d' , $ row [ 'rate_date' ] ) , $ row [ 'base_currency_code' ] , \ DateTime :: createFromFormat ( 'Y-m-d H:i:s' , $ row [ 'created_at' ] ) , \ DateTime :: createFromFormat ( 'Y-m-d H:i:s' , $ row [ 'modified_at' ] ) ) ; }
6690	public function canAccess ( $ permissionKeys , $ fullAccessKey , $ errorMsg , $ defaultUrl , $ redirect = false ) { if ( $ this -> getUser ( ) -> isGuest ) { return $ this -> getUser ( ) -> loginRequired ( ) ; } if ( $ this -> getPermissionManager ( ) -> canAccess ( $ fullAccessKey ) ) { return true ; } if ( ! is_array ( $ permissionKeys ) ) { $ permissionKeys = [ $ permissionKeys ] ; } foreach ( $ permissionKeys as $ permissionKey ) { if ( $ this -> getPermissionManager ( ) -> canAccess ( $ permissionKey ) ) { return true ; } } if ( $ redirect ) { $ this -> flashError ( $ errorMsg ) ; $ request = $ this -> getRequest ( ) ; $ referrerUrl = $ request -> referrer ; $ redirectUrl = ( $ referrerUrl == $ request -> url || is_null ( $ referrerUrl ) ) ? $ defaultUrl : $ referrerUrl ; $ this -> redirect ( $ redirectUrl ) -> send ( ) ; Yii :: $ app -> end ( ) ; } return false ; }
1460	protected function orderDesc ( ) { $ this -> query -> orderByDesc ( $ this -> column ) ; if ( $ this -> isNotPagingOnKey ( ) ) { $ this -> query -> orderByDesc ( $ this -> key ) ; } return $ this ; }
1415	public function invalidResource ( string $ path , ? string $ detail = null , array $ failed = [ ] ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_invalid' , 'code' ) , $ this -> trans ( 'resource_invalid' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_invalid' , 'detail' ) , $ this -> pointer ( $ path ) , $ failed ? compact ( 'failed' ) : null ) ; }
9270	public function load ( ContainerBuilder $ container ) { $ loader = $ this -> getContainerLoader ( $ container ) ; $ loader -> load ( $ this -> configFile ) ; }
5285	public function page ( $ page , $ size = 25 ) { $ size = \ absint ( $ size ) ; $ offset = $ size * \ absint ( $ page ) ; $ this -> limit ( $ size , $ offset ) ; return $ this ; }
5163	public function serialize ( EntityContract $ entity , Collection $ select = null ) { $ bag = parent :: serialize ( $ entity , $ select ) ; return $ bag ; }
4626	private function createIndexQueryPath ( Bucket $ bucket ) { $ command = $ this -> command ; if ( $ command -> isMatchQuery ( ) ) { $ path = sprintf ( '/types/%s/buckets/%s/index/%s/%s' , $ bucket -> getType ( ) , $ bucket -> getName ( ) , $ command -> getIndexName ( ) , $ command -> getMatchValue ( ) ) ; } elseif ( $ command -> isRangeQuery ( ) ) { $ path = sprintf ( '/types/%s/buckets/%s/index/%s/%s/%s' , $ bucket -> getType ( ) , $ bucket -> getName ( ) , $ command -> getIndexName ( ) , $ command -> getLowerBound ( ) , $ command -> getUpperBound ( ) ) ; } else { throw new Api \ Exception ( "Invalid Secondary Index Query." ) ; } return $ path ; }
7765	private function documentClassProperties ( \ ML \ HydraBundle \ Mapping \ ClassMetadata $ class ) { $ result = array ( ) ; $ propertyDomain = $ this -> getTypeReferenceIri ( $ class -> getName ( ) ) ; foreach ( $ class -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( '@' , $ property -> getExposeAs ( ) , 1 ) ) { continue ; } $ result [ ] = array ( 'property' => ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : array ( '@id' => 'vocab:' . $ property -> getIri ( ) , '@type' => ( $ property -> getRoute ( ) ) ? 'hydra:Link' : 'rdf:Property' , 'label' => $ property -> getTitle ( ) , 'description' => $ property -> getDescription ( ) , 'domain' => $ propertyDomain , 'range' => $ this -> getTypeReferenceIri ( $ property -> getType ( ) ) , 'supportedOperation' => $ this -> documentOperations ( $ property -> getOperations ( ) ) ) , 'hydra:title' => $ property -> getTitle ( ) , 'hydra:description' => $ property -> getDescription ( ) , 'required' => $ property -> getRequired ( ) , 'readonly' => $ property -> isReadOnly ( ) , 'writeonly' => $ property -> isWriteOnly ( ) ) ; } return $ result ; }
937	public static function getKeywords ( ) { static $ keywords = null ; if ( null === $ keywords ) { $ keywords = self :: getTokenKindsForNames ( [ 'T_ABSTRACT' , 'T_ARRAY' , 'T_AS' , 'T_BREAK' , 'T_CALLABLE' , 'T_CASE' , 'T_CATCH' , 'T_CLASS' , 'T_CLONE' , 'T_CONST' , 'T_CONTINUE' , 'T_DECLARE' , 'T_DEFAULT' , 'T_DO' , 'T_ECHO' , 'T_ELSE' , 'T_ELSEIF' , 'T_EMPTY' , 'T_ENDDECLARE' , 'T_ENDFOR' , 'T_ENDFOREACH' , 'T_ENDIF' , 'T_ENDSWITCH' , 'T_ENDWHILE' , 'T_EVAL' , 'T_EXIT' , 'T_EXTENDS' , 'T_FINAL' , 'T_FINALLY' , 'T_FOR' , 'T_FOREACH' , 'T_FUNCTION' , 'T_GLOBAL' , 'T_GOTO' , 'T_HALT_COMPILER' , 'T_IF' , 'T_IMPLEMENTS' , 'T_INCLUDE' , 'T_INCLUDE_ONCE' , 'T_INSTANCEOF' , 'T_INSTEADOF' , 'T_INTERFACE' , 'T_ISSET' , 'T_LIST' , 'T_LOGICAL_AND' , 'T_LOGICAL_OR' , 'T_LOGICAL_XOR' , 'T_NAMESPACE' , 'T_NEW' , 'T_PRINT' , 'T_PRIVATE' , 'T_PROTECTED' , 'T_PUBLIC' , 'T_REQUIRE' , 'T_REQUIRE_ONCE' , 'T_RETURN' , 'T_STATIC' , 'T_SWITCH' , 'T_THROW' , 'T_TRAIT' , 'T_TRY' , 'T_UNSET' , 'T_USE' , 'T_VAR' , 'T_WHILE' , 'T_YIELD' , 'T_YIELD_FROM' , ] ) + [ CT :: T_ARRAY_TYPEHINT => CT :: T_ARRAY_TYPEHINT , CT :: T_CLASS_CONSTANT => CT :: T_CLASS_CONSTANT , CT :: T_CONST_IMPORT => CT :: T_CONST_IMPORT , CT :: T_FUNCTION_IMPORT => CT :: T_FUNCTION_IMPORT , CT :: T_NAMESPACE_OPERATOR => CT :: T_NAMESPACE_OPERATOR , CT :: T_USE_TRAIT => CT :: T_USE_TRAIT , CT :: T_USE_LAMBDA => CT :: T_USE_LAMBDA , ] ; } return $ keywords ; }
4457	public function detach ( string $ eventName , $ handler ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } if ( isset ( $ this -> events [ $ eventName ] ) == false ) { return ; } $ priorityQueue = $ this -> events [ $ eventName ] ; $ priorityQueue -> setExtractFlags ( SplPriorityQueue :: EXTR_BOTH ) ; $ priorityQueue -> top ( ) ; $ newPriorityQueue = $ this -> createQueue ( ) ; while ( $ priorityQueue -> valid ( ) ) { $ data = $ priorityQueue -> current ( ) ; $ priorityQueue -> next ( ) ; if ( $ data [ 'data' ] !== $ handler ) { $ newPriorityQueue -> insert ( $ data [ 'data' ] , $ data [ 'priority' ] ) ; } } $ this -> events [ $ eventName ] = $ newPriorityQueue ; }
6163	public function getMemUsage ( $ realmem = false ) { if ( $ this -> isRunning ( ) ) { $ this -> stop ( ) ; $ this -> start ( ) ; } return ( $ realmem !== false ) ? $ this -> data [ "realmem" ] : $ this -> data [ "emalloc" ] ; }
8439	protected static function completeFilesCountsAndEditorLinks ( ) { if ( ! static :: $ files ) { $ rawList = get_included_files ( ) ; $ list = [ ] ; $ docRoot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; $ docRootLength = mb_strlen ( $ docRoot ) ; $ tracyFileDetectionSubstr = '/tracy' ; foreach ( $ rawList as & $ file ) { $ file = str_replace ( '\\' , '/' , $ file ) ; $ text = mb_substr ( $ file , $ docRootLength ) ; $ tracyFile = mb_stripos ( $ text , $ tracyFileDetectionSubstr ) !== FALSE ; if ( ! $ tracyFile ) static :: $ appFilesCount += 1 ; static :: $ allFilesCount += 1 ; $ href = \ Tracy \ Helpers :: editorUri ( $ file , 1 ) ; $ list [ ] = '<a ' . ( $ tracyFile ? 'class="tracy" ' : '' ) . 'href="' . $ href . '"><nobr>' . $ text . '</nobr></a><br />' ; } static :: $ files = & $ list ; } }
1560	protected function modelKeyForField ( $ field , $ model ) { if ( isset ( $ this -> attributes [ $ field ] ) ) { return $ this -> attributes [ $ field ] ; } $ key = $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; return $ this -> attributes [ $ field ] = $ key ; }
11839	public static function convert2Jpeg ( $ inputImg , $ savePath = null , $ quality = null , array $ exifData = null ) { $ retval = false ; $ img = self :: imgCreate ( $ inputImg ) ; $ imgSize = self :: size ( $ img ) ; $ jpegImg = imagecreatetruecolor ( $ imgSize [ 0 ] , $ imgSize [ 1 ] ) ; imagecopy ( $ jpegImg , $ img , 0 , 0 , 0 , 0 , $ imgSize [ 0 ] , $ imgSize [ 1 ] ) ; if ( null === $ quality ) $ quality = self :: IMG_QUALITY ; if ( null !== $ exifData && array_key_exists ( 'Orientation' , $ exifData ) ) { $ ort = $ exifData [ 'Orientation' ] ; switch ( $ ort ) { default : case 1 : break ; case 2 : $ jpegImg = self :: flipImage ( $ jpegImg , 1 ) ; break ; case 3 : $ jpegImg = self :: rotateImage ( $ jpegImg , 180 ) ; break ; case 4 : $ jpegImg = self :: flipImage ( $ jpegImg , 2 ) ; break ; case 5 : $ jpegImg = self :: flipImage ( $ jpegImg , 2 ) ; $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 6 : $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 7 : $ jpegImg = self :: flipImage ( $ jpegImg , 1 ) ; $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 8 : $ jpegImg = self :: rotateImage ( $ jpegImg , 270 ) ; break ; } } if ( null === $ savePath ) $ retval = $ jpegImg ; else $ retval = imagejpeg ( $ jpegImg , $ savePath , $ quality ) ; return $ retval ; }
4819	public function getIterator ( IteratorFilter $ itf = null ) { if ( is_null ( $ itf ) ) { return new AnyIterator ( $ this -> collection ) ; } return new AnyIterator ( $ itf -> match ( $ this -> collection ) ) ; }
4030	protected function getLabelPattern ( EnvironmentInterface $ environment , ModelInterface $ model ) { $ translator = $ environment -> getTranslator ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ combined = 'typedesc.' . $ type ; if ( ( $ resultPattern = $ translator -> translate ( $ combined , 'tl_metamodel_filtersetting' ) ) == $ combined ) { $ resultPattern = $ translator -> translate ( 'typedesc._default_' , 'tl_metamodel_filtersetting' ) ; } return $ resultPattern ; }
3175	private function getItemLabel ( RunnerServiceContext $ context , $ itemUri , $ useTitle = false ) { $ label = '' ; if ( $ useTitle ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'title' ) ; } if ( ! $ label ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'label' ) ; } if ( ! $ label ) { $ item = new \ core_kernel_classes_Resource ( $ itemUri ) ; $ label = $ item -> getLabel ( ) ; } return $ label ; }
7030	public function toArray ( ) { return [ 'o_msg' => $ this -> overflowMessage , 'min_qty' => $ this -> minimumQuantity , 'min_msg' => $ this -> minimumMessage , 'max_qty' => INF === $ this -> maximumQuantity ? 'INF' : $ this -> maximumQuantity , 'max_msg' => $ this -> maximumMessage , 'a_qty' => INF === $ this -> availableQuantity ? 'INF' : $ this -> availableQuantity , 'a_msg' => $ this -> availableMessage , 'r_qty' => $ this -> resupplyQuantity , 'r_msg' => $ this -> resupplyMessage , ] ; }
8689	private static function doFlatten ( $ iterable , $ depth , callable $ predicate , array $ result = [ ] ) { foreach ( $ iterable as $ item ) { if ( $ depth >= 1 && $ predicate ( $ item ) ) { $ result = static :: doFlatten ( $ item , $ depth - 1 , $ predicate , $ result ) ; } else { $ result [ ] = $ item ; } } return $ result ; }
3899	public function setDataFor ( $ arrValues ) { $ strTable = $ this -> getMetaModel ( ) -> getTableName ( ) ; $ strColName = $ this -> getColName ( ) ; foreach ( $ arrValues as $ intId => $ varData ) { if ( is_array ( $ varData ) ) { $ varData = serialize ( $ varData ) ; } $ this -> connection -> update ( $ strTable , [ $ strColName => $ varData ] , [ 'id' => $ intId ] ) ; } }
1517	public function readRelationship ( StoreInterface $ store , FetchRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelationship ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> relationship ( $ related ) ; }
3215	function getAccountInfo ( ) { $ response = $ this -> doGet ( $ this -> apiHost , "1/account/info" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
6013	public function listProtocols ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/protocols' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Protocol ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
3502	private function initializeCurlResource ( ) : void { if ( ! $ this -> resource ) { $ this -> resource = curl_init ( ) ; curl_setopt ( $ this -> resource , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_POST , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_HTTP_VERSION , 3 ) ; } }
3850	public function getServiceContainer ( ) { if ( ! $ this -> serviceContainer ) { $ this -> useDefaultServiceContainer ( ) ; } if ( is_callable ( $ this -> serviceContainer ) ) { return $ this -> serviceContainer = $ this -> serviceContainer -> __invoke ( ) ; } return $ this -> serviceContainer ; }
7902	protected function getFullFileName ( Provider $ provider ) { $ folder = $ this -> folder ? rtrim ( $ this -> folder , '/' ) . '/' : '' ; if ( $ this -> filename ) { $ filename = $ this -> filename ; } else { $ filename = md5 ( uniqid ( microtime ( true ) , true ) ) ; } return $ folder . $ filename . '.' . $ provider -> getExtension ( ) ; }
8284	protected function init ( ) { $ this -> loadModules ( ) ; $ this -> session = $ this -> container -> get ( 'session' ) ; $ this -> csrf = new CSRF ( $ this -> session ) ; $ this -> user = $ this -> getUserFromSession ( ) ; $ this -> request = Request :: createFromGlobals ( ) ; $ this -> sessionTimeoutCheck ( "sessionInterval" , "_migT" , false ) ; $ this -> sessionTimeoutCheck ( "sessionTimeout" , "_start" , true ) ; $ this -> sessionTimeoutCheck ( "sessionIdle" , "_idle" , true , true ) ; }
11493	public function removeAll ( ) : array { $ res = [ ] ; foreach ( $ this -> getKeys ( ) as $ key ) { $ res [ $ key ] = $ this -> remove ( $ key ) ; } return $ res ; }
10137	private function writeMsoDrawing ( ) { if ( isset ( $ this -> escher ) ) { $ writer = new Escher ( $ this -> escher ) ; $ data = $ writer -> close ( ) ; $ spOffsets = $ writer -> getSpOffsets ( ) ; $ spTypes = $ writer -> getSpTypes ( ) ; $ spOffsets [ 0 ] = 0 ; $ nm = count ( $ spOffsets ) - 1 ; for ( $ i = 1 ; $ i <= $ nm ; ++ $ i ) { $ record = 0x00EC ; $ dataChunk = substr ( $ data , $ spOffsets [ $ i - 1 ] , $ spOffsets [ $ i ] - $ spOffsets [ $ i - 1 ] ) ; $ length = strlen ( $ dataChunk ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ dataChunk ) ; $ record = 0x005D ; $ objData = '' ; if ( $ spTypes [ $ i ] == 0x00C9 ) { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0014 , $ i , 0x2101 , 0 , 0 , 0 ) ; $ objData .= pack ( 'vv' , 0x00C , 0x0014 ) ; $ objData .= pack ( 'H*' , '0000000000000000640001000A00000010000100' ) ; $ objData .= pack ( 'vv' , 0x0013 , 0x1FEE ) ; $ objData .= pack ( 'H*' , '00000000010001030000020008005700' ) ; } else { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0008 , $ i , 0x6011 , 0 , 0 , 0 ) ; } $ objData .= pack ( 'vv' , 0x0000 , 0x0000 ) ; $ length = strlen ( $ objData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ objData ) ; } } }
10378	protected static function get_routes_to_folder ( $ type ) { $ url = isset ( self :: $ unify [ "{$type}s" ] ) ? self :: $ unify [ "{$type}s" ] : self :: $ unify ; return [ 'url' => $ url , 'path' => self :: get_path_from_url ( $ url ) , ] ; }
8188	public function getBlockNames ( array $ context = null , array $ blocks = array ( ) ) { if ( null === $ context ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is internal and should never be called; calling it directly is deprecated since version 1.28 and won\'t be possible anymore in 2.0.' , E_USER_DEPRECATED ) ; return array_keys ( $ this -> blocks ) ; } $ names = array_merge ( array_keys ( $ blocks ) , array_keys ( $ this -> blocks ) ) ; if ( false !== $ parent = $ this -> getParent ( $ context ) ) { $ names = array_merge ( $ names , $ parent -> getBlockNames ( $ context ) ) ; } return array_unique ( $ names ) ; }
12979	protected function registerBehaviors ( EventManager $ evm , Configuration $ config ) { $ reader = new AnnotationReader ; if ( $ cache = $ config -> getMetadataCacheImpl ( ) ) { $ reader = new CachedReader ( $ reader , $ cache ) ; } foreach ( $ this -> getConfig ( 'behaviors' , array ( ) ) as $ behavior ) { if ( $ class = DiC :: resolve ( 'doctrine.behavior.' . $ behavior ) ) { $ class -> setAnnotationReader ( $ reader ) ; $ this -> configureBehavior ( $ behavior , $ class ) ; $ evm -> addEventSubscriber ( $ class ) ; } } if ( $ mapping = $ config -> getMetadataDriverImpl ( ) ) { $ type = 'registerMappingIntoDriverChainORM' ; if ( $ this -> getConfig ( 'behavior.superclass' , false ) ) { $ type = 'registerAbstractMappingIntoDriverChainORM' ; } DoctrineExtensions :: $ type ( $ mapping , $ reader ) ; } }
1659	public static function create ( $ reply = null ) { $ suggestion = new self ( ) ; if ( $ reply ) { $ suggestion -> reply ( $ reply ) ; } return $ suggestion ; }
12048	public function render ( ElementInterface $ element ) { $ renderer = $ this -> getView ( ) ; if ( $ element instanceof CkEditor ) { $ plugin = $ renderer -> plugin ( 'form_ckeditor' ) ; return $ plugin ( $ element ) ; } return parent :: render ( $ element ) ; }
11570	final public static function load ( & $ object , & $ params ) { $ attachments = static :: getInstance ( ) ; $ attachment = & $ object ; if ( ! is_a ( $ attachment , Entity :: class ) ) { $ attachment = $ attachments -> loadObjectByURI ( $ attachment ) ; } if ( $ attachment -> getObjectType ( ) !== "attachment" ) return false ; $ fileId = $ attachment -> getObjectType ( ) ; $ filePath = FSPATH . DS . $ attachment -> getPropertyValue ( "attachment_src" ) ; $ contentType = $ attachment -> getPropertyValue ( "attachment_type" ) ; static :: place ( $ fileId , $ filePath , $ contentType , $ params ) ; }
3851	public function setLimit ( $ blnUse , $ intOffset , $ intLimit ) { $ this -> paginationLimitCalculator -> setApplyLimitAndOffset ( $ blnUse ) -> setOffset ( $ intOffset ) -> setLimit ( $ intLimit ) ; return $ this ; }
5601	public function paintPass ( $ message ) { if ( ! $ this -> pass ) { $ this -> message = self :: escapeVal ( $ message ) ; } $ this -> pass = true ; }
3319	public function isa ( $ type , $ option = null ) { if ( $ type === 'bool' ) { $ type = 'boolean' ; } $ this -> isa = $ type ; $ this -> isaOption = $ option ; return $ this ; }
286	public function remove ( $ name ) { $ name = strtolower ( $ name ) ; if ( isset ( $ this -> _headers [ $ name ] ) ) { $ value = $ this -> _headers [ $ name ] ; unset ( $ this -> _headers [ $ name ] ) ; return $ value ; } return null ; }
10164	private function readRangeProtection ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ offset = 0 ; if ( ! $ this -> readDataOnly ) { $ offset += 12 ; $ isf = self :: getUInt2d ( $ recordData , 12 ) ; if ( $ isf != 2 ) { return ; } $ offset += 2 ; $ offset += 5 ; $ cref = self :: getUInt2d ( $ recordData , 19 ) ; $ offset += 2 ; $ offset += 6 ; $ cellRanges = [ ] ; for ( $ i = 0 ; $ i < $ cref ; ++ $ i ) { try { $ cellRange = $ this -> readBIFF8CellRangeAddressFixed ( substr ( $ recordData , 27 + 8 * $ i , 8 ) ) ; } catch ( PhpSpreadsheetException $ e ) { return ; } $ cellRanges [ ] = $ cellRange ; $ offset += 8 ; } $ rgbFeat = substr ( $ recordData , $ offset ) ; $ offset += 4 ; $ wPassword = self :: getInt4d ( $ recordData , $ offset ) ; $ offset += 4 ; if ( $ cellRanges ) { $ this -> phpSheet -> protectCells ( implode ( ' ' , $ cellRanges ) , strtoupper ( dechex ( $ wPassword ) ) , true ) ; } } }
11377	public function getAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)(\/(\w+))?$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } $ pageName = $ matches [ 1 ] ; $ language = $ matches [ 2 ] ; $ pageTexts = $ this -> getTextModel ( $ pageName ) ; if ( empty ( $ matches [ 4 ] ) ) { $ result = array_values ( $ pageTexts -> getTextsWithBaseTexts ( $ language ) ) ; } else { $ result = $ pageTexts -> getText ( $ matches [ 4 ] , $ language ) ; } $ this -> environment -> sendJSONResult ( $ result ) ; }
6328	private function getColumnsSql ( ) { $ columnTypeMapper = new ColumnTypeMapper ( ) ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { if ( $ constraint instanceof PrimaryKey ) { $ primaryKey = $ constraint ; } } if ( ! isset ( $ primaryKey ) ) { $ primaryKey = new PrimaryKey ( ) ; $ primaryKey -> setTable ( $ this -> table ) ; $ this -> table -> addConstraint ( $ primaryKey ) ; } $ sql = '' ; if ( ! $ primaryKey -> isMulti ( ) && $ primaryKey -> isAutoCreateColumn ( ) ) { $ sql = sprintf ( '%s %s NOT NULL,' , $ primaryKey -> getColumns ( ) , $ primaryKey -> isAutoIncrement ( ) ? 'serial' : 'integer' ) ; } foreach ( $ this -> table -> getColumns ( ) as $ column ) { if ( $ column instanceof CustomColumn ) { $ columnType = $ column -> getType ( ) ; } else { $ columnType = $ columnTypeMapper -> getNative ( $ column -> getType ( ) ) ; } $ sql .= sprintf ( '%s %s%s %s %s,' , $ column -> getName ( ) , $ columnType , $ this -> getTypeConstraints ( $ column ) , $ column -> isNotNull ( ) ? 'NOT NULL' : '' , null === $ column -> getDefault ( ) ? '' : 'DEFAULT' . ' ' . $ this -> addQuotesIfNeeded ( $ column , $ column -> getDefault ( ) ) ) ; } return rtrim ( $ sql , ',' ) ; }
7442	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } return array ( 'group' => $ group , ) ; }
1523	protected function doSearch ( StoreInterface $ store , FetchResources $ request ) { if ( $ result = $ this -> invoke ( 'searching' , $ request ) ) { return $ result ; } $ found = $ store -> queryRecords ( $ request -> getResourceType ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ found instanceof PageInterface ) ? $ found -> getData ( ) : $ found ; if ( $ result = $ this -> invoke ( 'searched' , $ records , $ request ) ) { return $ result ; } return $ found ; }
6370	public static function forMap ( array $ map ) : callable { return function ( $ index ) use ( $ map ) { Preconditions :: checkArgument ( array_key_exists ( $ index , $ map ) , "The given key '%s' does not exist in the map" , $ index ) ; return $ map [ $ index ] ; } ; }
7411	public function combine ( array $ keys ) : self { if ( count ( $ keys ) !== count ( $ this -> _container ) ) { throw new LengthException ( 'array counts do not match' ) ; } $ this -> _container = array_combine ( $ keys , $ this -> _container ) ; return $ this ; }
4932	public function renderJSON ( MvcEvent $ event ) { if ( ! $ this -> hasRunned ) { $ valueToPlainStati = array ( 1 => 'error' , 2 => 'error' , 3 => 'error' , 4 => 'error' , 5 => 'success' , 6 => 'info' , 7 => 'info' ) ; $ viewModel = $ event -> getViewModel ( ) ; if ( $ viewModel instanceof JsonModel ) { if ( ! empty ( $ this -> notifications ) ) { $ jsonNotifications = $ viewModel -> getVariable ( 'notifications' , array ( ) ) ; foreach ( $ this -> notifications as $ notification ) { $ status = 'info' ; if ( array_key_exists ( $ notification -> getPriority ( ) , $ valueToPlainStati ) ) { $ status = $ valueToPlainStati [ $ notification -> getPriority ( ) ] ; } $ jsonNotifications [ ] = array ( 'text' => $ notification -> getNotification ( ) , 'status' => $ status ) ; } $ viewModel -> setVariable ( 'notifications' , $ jsonNotifications ) ; } $ this -> hasRunned = true ; } } return ; }
12393	public function onSiteSaved ( SiteSavedEvent $ event ) { $ fs = new Filesystem ( ) ; $ fs -> mirror ( $ this -> configurationHandler -> uploadAssetsDir ( ) , $ this -> configurationHandler -> uploadAssetsDirProduction ( ) ) ; }
5209	public function convert ( array $ stmts , ClassMetadata $ metadata , ClassCollector $ classCollector , Logger $ logger ) { $ this -> metadata = $ metadata ; $ this -> classCollector = $ classCollector ; $ this -> logger = $ logger ; return ltrim ( str_replace ( "\n" . self :: noIndentToken , "\n" , $ this -> pStmts ( $ stmts , false ) ) ) ; }
7626	public function containerExists ( $ containerName = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ containers = $ this -> listContainers ( $ containerName , 1 ) ; foreach ( $ containers as $ container ) { if ( $ container -> Name == $ containerName ) { return true ; } } return false ; }
11060	public function value ( $ encoding = null ) { if ( $ this -> value !== null ) { if ( $ encoding === null ) { return mb_convert_encoding ( $ this -> value , $ this -> encoding , 'UTF-8' ) ; } else { $ encoding = $ this -> getRealEncoding ( $ encoding ) ; return mb_convert_encoding ( $ this -> value , $ encoding , 'UTF-8' ) ; } } }
8919	protected function parseAuthority ( $ authority , & $ out ) { if ( ! empty ( $ authority ) ) { $ out [ 'id' ] = $ authority ; if ( preg_match ( '/\((.*?)\)(.*)/' , $ authority , $ matches ) ) { $ out [ 'vocabulary' ] = $ matches [ 1 ] ; $ out [ 'id' ] = $ matches [ 2 ] ; } } }
4494	private function getApnsJsonInner ( ? string $ text ) : array { $ apns = [ 'aps' => [ ] , ] ; if ( null !== $ this -> localizedKey ) { $ apns [ 'aps' ] [ 'alert' ] = [ 'loc-key' => $ this -> localizedKey , ] ; if ( $ this -> localizedArguments ) { $ apns [ 'aps' ] [ 'alert' ] [ 'loc-args' ] = $ this -> localizedArguments ; } } elseif ( null !== $ text ) { $ apns [ 'aps' ] [ 'alert' ] = $ text ; } if ( $ this -> isContentAvailable ( ) ) { $ apns [ 'aps' ] [ 'content-available' ] = 1 ; } if ( null !== $ this -> badge ) { $ apns [ 'aps' ] [ 'badge' ] = $ this -> badge ; } if ( null !== $ this -> sound ) { $ apns [ 'aps' ] [ 'sound' ] = $ this -> sound ; } $ merged = $ this -> arrayMergeDeep ( $ apns , $ this -> custom , $ this -> apnsData ? $ this -> apnsData : [ ] ) ; if ( ! \ count ( $ merged [ 'aps' ] ) ) { $ merged [ 'aps' ] = new \ stdClass ( ) ; } return $ merged ; }
3188	public function getFirstTimestamp ( $ tags ) { $ range = $ this -> getRange ( $ tags ) ; $ last = false ; if ( count ( $ range ) ) { $ last = $ range [ 0 ] -> getTimestamp ( ) ; } return $ last ; }
1754	public static function getLanguages ( $ blnInstalledOnly = false ) { $ return = array ( ) ; $ languages = array ( ) ; $ arrAux = array ( ) ; $ langsNative = array ( ) ; static :: loadLanguageFile ( 'languages' ) ; include __DIR__ . '/../../config/languages.php' ; foreach ( $ languages as $ strKey => $ strName ) { $ arrAux [ $ strKey ] = isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) ? Utf8 :: toAscii ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) : $ strName ; } asort ( $ arrAux ) ; $ arrBackendLanguages = self :: getContainer ( ) -> getParameter ( 'contao.locales' ) ; foreach ( array_keys ( $ arrAux ) as $ strKey ) { if ( $ blnInstalledOnly && ! \ in_array ( $ strKey , $ arrBackendLanguages ) ) { continue ; } $ return [ $ strKey ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ?? $ languages [ $ strKey ] ; if ( isset ( $ langsNative [ $ strKey ] ) && $ langsNative [ $ strKey ] != $ return [ $ strKey ] ) { $ return [ $ strKey ] .= ' - ' . $ langsNative [ $ strKey ] ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ return , $ languages , $ langsNative , $ blnInstalledOnly ) ; } } return $ return ; }
7277	public function time ( $ timestamp = false ) { return $ timestamp ? ( new DateTime ( $ this -> time ) ) -> getTimestamp ( ) : $ this -> time ; }
7377	public function fetchFloat ( string $ key , float $ default = 0.0 , int $ precision = 2 ) : float { return round ( floatval ( $ this -> fetch ( $ key , $ default ) ) , $ precision ) ; }
11211	protected function hasInLookup ( $ key ) { foreach ( $ this -> lookup_pool as $ registry ) { if ( $ this -> hasInRegistry ( $ registry , $ key ) ) { $ this -> cache_key = $ key ; $ this -> cache_reg = $ registry ; return true ; } } return false ; }
12093	public function getDomainUrl ( $ address , $ scheme = false ) { $ this -> urlAddress -> setAddress ( $ address ) ; return $ this -> urlAddress -> getDomain ( $ scheme ) ; }
10416	protected function addStatusField ( Table $ table ) { if ( empty ( $ this -> shops ) ) { $ table -> addColumn ( 'status' , 'boolean' , [ 'default' => 0 ] ) -> setComment ( '0-new,1-done' ) ; $ table -> addIndex ( [ 'status' ] ) ; } else { foreach ( $ this -> shops as $ shop ) { $ fieldName = "status_{$shop}" ; $ table -> addColumn ( $ fieldName , 'boolean' , [ 'default' => 0 ] ) -> setComment ( '0-new,1-done' ) ; $ table -> addIndex ( [ $ fieldName ] ) ; } } }
5420	protected function parseCookie ( $ cookie_line ) { $ parts = explode ( ';' , $ cookie_line ) ; $ cookie = array ( ) ; preg_match ( '/\s*(.*?)\s*=(.*)/' , array_shift ( $ parts ) , $ cookie ) ; foreach ( $ parts as $ part ) { if ( preg_match ( '/\s*(.*?)\s*=(.*)/' , $ part , $ matches ) ) { $ cookie [ $ matches [ 1 ] ] = trim ( $ matches [ 2 ] ) ; } } return new SimpleCookie ( $ cookie [ 1 ] , trim ( $ cookie [ 2 ] ) , isset ( $ cookie [ 'path' ] ) ? $ cookie [ 'path' ] : '' , isset ( $ cookie [ 'expires' ] ) ? $ cookie [ 'expires' ] : false ) ; }
5833	protected function headerToArray ( $ header ) { $ tmp = explode ( "\r\n" , $ header ) ; $ headers = array ( ) ; foreach ( $ tmp as $ singleHeader ) { $ delimiter = strpos ( $ singleHeader , ': ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 2 ) ; $ headers [ $ key ] = $ val ; } else { $ delimiter = strpos ( $ singleHeader , ' ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 1 ) ; $ headers [ $ key ] = $ val ; } } } return $ headers ; }
12155	public function getInitialRole ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = $ roleItem -> level < 400 ; if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
12475	public function getCurrentTheme ( ) { $ theme = $ this -> getDefaultTheme ( ) ; if ( $ this -> container -> get ( 'session' ) -> has ( '_admin_theme' ) ) { $ theme = $ this -> container -> get ( 'session' ) -> get ( '_admin_theme' ) ; } return $ theme ; }
3400	protected function makeRequest ( $ arguments = [ ] ) { $ defaults = $ this -> getDefaultOptions ( ) ; $ arguments = array_merge ( $ defaults , $ arguments ) ; $ client = $ this -> resource -> getGuzzle ( ) ; $ request = $ client -> createRequest ( $ this -> getMethod ( ) , $ this -> url , $ arguments ) ; $ response = $ client -> send ( $ request ) ; $ this -> setResponse ( $ response ) ; $ this -> setContent ( ( string ) $ response -> getBody ( ) ) ; }
1337	protected function getQueryParameters ( EncodingParametersInterface $ parameters ) { return new EncodingParameters ( $ parameters -> getIncludePaths ( ) , $ parameters -> getFieldSets ( ) , $ parameters -> getSortParameters ( ) ? : $ this -> defaultSort ( ) , $ parameters -> getPaginationParameters ( ) ? : $ this -> defaultPagination ( ) , $ parameters -> getFilteringParameters ( ) , $ parameters -> getUnrecognizedParameters ( ) ) ; }
113	private function getInstallPath ( PackageInterface $ package , $ global = false ) { if ( ! $ global ) { return $ this -> composer -> getInstallationManager ( ) -> getInstallPath ( $ package ) ; } return $ this -> globalComposer -> getInstallationManager ( ) -> getInstallPath ( $ package ) ; }
5818	public function updateTagging ( $ fusionID ) { $ configuration = Config :: inst ( ) ; $ classes = ClassInfo :: subclassesFor ( 'DataObject' ) ; unset ( $ classes [ 'DataObject' ] ) ; foreach ( $ classes as $ class ) { $ extensions = $ configuration -> get ( $ class , 'extensions' , Config :: UNINHERITED ) ; if ( is_array ( $ extensions ) && in_array ( 'TaggingExtension' , $ extensions ) ) { $ mode = Versioned :: get_reading_mode ( ) ; Versioned :: reading_stage ( 'Stage' ) ; $ objects = $ class :: get ( ) -> filter ( 'FusionTags.ID' , $ fusionID ) ; if ( $ class :: has_extension ( $ class , 'Versioned' ) ) { foreach ( $ objects as $ object ) { $ object -> writeWithoutVersion ( ) ; } Versioned :: reading_stage ( 'Live' ) ; $ objects = $ class :: get ( ) -> filter ( 'FusionTags.ID' , $ fusionID ) ; foreach ( $ objects as $ object ) { $ object -> writeWithoutVersion ( ) ; } } else { foreach ( $ objects as $ object ) { $ object -> write ( ) ; } } Versioned :: set_reading_mode ( $ mode ) ; } } }
9424	public function write ( $ string ) { if ( ! $ this -> isWritable ( ) ) { $ message = 'Stream is not writable' ; throw new \ RuntimeException ( $ message ) ; } $ this -> size = null ; return fwrite ( $ this -> stream , $ string ) ; }
6480	private function getSetCookieHeaderValue ( Cookie $ cookie ) : string { $ headerValue = "{$cookie->getName()}=" . urlencode ( $ cookie -> getValue ( ) ) ; if ( ( $ expiration = $ cookie -> getExpiration ( ) ) !== null ) { $ headerValue .= '; Expires=' . $ expiration -> format ( self :: EXPIRATION_DATE_FORMAT ) ; } if ( ( $ maxAge = $ cookie -> getMaxAge ( ) ) !== null ) { $ headerValue .= "; Max-Age=$maxAge" ; } if ( ( $ domain = $ cookie -> getDomain ( ) ) !== null ) { $ headerValue .= '; Domain=' . urlencode ( $ domain ) ; } if ( ( $ path = $ cookie -> getPath ( ) ) !== null ) { $ headerValue .= '; Path=' . urlencode ( $ path ) ; } if ( $ cookie -> isSecure ( ) ) { $ headerValue .= '; Secure' ; } if ( $ cookie -> isHttpOnly ( ) ) { $ headerValue .= '; HttpOnly' ; } if ( ( $ sameSite = $ cookie -> getSameSite ( ) ) !== null ) { $ headerValue .= '; SameSite=' . urlencode ( $ sameSite ) ; } return $ headerValue ; }
1202	public function buildItem ( ItemInterface $ item , array $ options ) { $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setCurrent ( $ options [ 'current' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) ; $ this -> buildExtras ( $ item , $ options ) ; }
4411	public function process ( ContainerBuilder $ container ) { if ( ! $ container -> has ( 'netgen_admin_ui.menu_plugin.registry' ) ) { return ; } $ menuPluginRegistry = $ container -> findDefinition ( 'netgen_admin_ui.menu_plugin.registry' ) ; $ menuPlugins = $ container -> findTaggedServiceIds ( 'netgen_admin_ui.menu_plugin' ) ; $ flattenedMenuPlugins = array ( ) ; foreach ( $ menuPlugins as $ identifier => $ menuPlugin ) { $ flattenedMenuPlugins [ $ identifier ] = isset ( $ menuPlugin [ 0 ] [ 'priority' ] ) ? $ menuPlugin [ 0 ] [ 'priority' ] : 0 ; } arsort ( $ flattenedMenuPlugins ) ; foreach ( array_keys ( $ flattenedMenuPlugins ) as $ menuPlugin ) { $ menuPluginRegistry -> addMethodCall ( 'addMenuPlugin' , array ( new Reference ( $ menuPlugin ) ) ) ; } }
341	public static function validate ( $ model , $ attributes = null ) { $ result = [ ] ; if ( $ attributes instanceof Model ) { $ models = func_get_args ( ) ; $ attributes = null ; } else { $ models = [ $ model ] ; } foreach ( $ models as $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , $ attribute ) ] = $ errors ; } } return $ result ; }
11171	public function getFilters ( $ columnDescriptions = [ ] , $ activeFieldName = false ) { $ filters = [ ] ; if ( count ( $ this -> filtersArray ) > 0 ) { foreach ( $ this -> filtersArray as $ key => $ value ) { if ( isset ( $ this -> filters [ $ key ] ) ) { $ activeFieldName = $ activeFieldName ? : $ this -> filtersArray [ 'orderBy' ] ; $ friendlyFieldName = isset ( $ columnDescriptions [ $ activeFieldName ] ) ? $ columnDescriptions [ $ activeFieldName ] : $ activeFieldName ; $ filters [ ] = sprintf ( $ this -> filters [ $ key ] , $ friendlyFieldName , $ value ) ; } } } return $ filters ; }
2802	public static function parseBooleanValue ( $ value ) : bool { if ( \ is_bool ( $ value ) ) { return $ value ; } if ( \ is_string ( $ value ) ) { $ value = \ strtolower ( $ value ) ; return 'true' === $ value ; } if ( \ is_object ( $ value ) || \ is_array ( $ value ) || \ is_callable ( $ value ) ) { return false ; } return ( bool ) $ value ; }
6445	public function getLoginStartUrl ( $ redirecturl ) { $ linkedin = $ this -> getClient ( $ redirecturl ) ; $ url = $ linkedin -> getLoginUrl ( array ( \ LinkedIn \ LinkedIn :: SCOPE_BASIC_PROFILE , \ LinkedIn \ LinkedIn :: SCOPE_EMAIL_ADDRESS ) ) ; return $ url ; }
6086	public function listTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/moodboards/templates' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new MoodboardTemplateResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
3256	public function map ( Router $ router ) { $ router -> group ( [ 'namespace' => 'Amsgames\LaravelShop\Http\Controllers' ] , function ( $ router ) { $ router -> group ( [ 'prefix' => 'shop' ] , function ( $ router ) { $ router -> get ( 'callback/payment/{status}/{id}/{shoptoken}' , [ 'as' => 'shop.callback' , 'uses' => 'Shop\CallbackController@process' ] ) ; $ router -> post ( 'callback/payment/{status}/{id}/{shoptoken}' , [ 'as' => 'shop.callback' , 'uses' => 'Shop\CallbackController@process' ] ) ; } ) ; } ) ; }
1504	protected function bindApi ( string $ namespace , string $ host ) : Api { $ repository = $ this -> container -> make ( Repository :: class ) ; $ api = $ repository -> createApi ( $ namespace , $ host ) ; $ this -> container -> instance ( Api :: class , $ api ) ; $ this -> container -> alias ( Api :: class , 'json-api.inbound' ) ; return $ api ; }
10887	public function getSession ( $ sessionId ) { return tap ( $ this -> manager -> driver ( ) , function ( $ session ) use ( $ sessionId ) { $ session -> setId ( $ sessionId ) ; } ) ; }
9344	public function addCol ( $ arr_col ) { if ( isset ( $ this -> arr [ 0 ] ) && ( count ( $ this -> arr [ 0 ] ) == $ this -> size -> cols ) ) { throw new \ OutOfRangeException ( sprintf ( 'You cannot add another column! Max number of columns is %d' , $ this -> size -> cols ) ) ; } if ( count ( $ arr_col ) != $ this -> size -> rows ) { throw new \ InvalidArgumentException ( 'New column must have same amout of rows than previous columns.' ) ; } $ arr_col = array_values ( $ arr_col ) ; foreach ( $ arr_col as $ k => $ v ) { $ this -> arr [ $ k ] [ ] = $ arr_col [ $ k ] ; } return $ this ; }
11983	public function getConfig ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> settings ) ? $ this -> settings [ $ name ] : $ default ; }
7315	public function setDateTime ( $ year , $ month , $ day , $ hour , $ min , $ sec ) { return $ this -> setDate ( $ year , $ month , $ day ) -> setTime ( $ hour , $ min , $ sec ) ; }
8221	protected function getEntityId ( $ blockType , $ config , $ params = array ( ) ) { $ entityId = null ; if ( $ blockType === "account" && isset ( $ params [ "name" ] ) ) { $ entityId = md5 ( $ params [ "name" ] ) ; } elseif ( $ blockType === "email" && isset ( $ params [ "email" ] ) ) { $ entityId = md5 ( $ params [ "email" ] ) ; } elseif ( $ blockType === "ip" ) { $ entityId = $ this -> getIp ( $ config ) ; } return $ entityId ; }
3380	public function getModel ( $ entity ) { if ( \ Links :: isMain ( $ entity ) ) { $ modelClass = 'Serverfireteam\\Panel\\' . $ entity ; } else { if ( ! empty ( \ Config :: get ( 'panel.modelPath' ) ) ) { $ modelClass = $ this -> getNameSpace ( ) . \ Config :: get ( 'panel.modelPath' ) . '\\' . $ entity ; } else { $ modelClass = $ this -> getNameSpace ( ) . $ entity ; } } return $ modelClass ; }
4625	public function prepare ( Command $ command , Node $ node ) { if ( $ this -> connection ) { $ this -> resetConnection ( ) ; } parent :: prepare ( $ command , $ node ) ; $ this -> buildPath ( ) ; $ this -> prepareConnection ( ) ; $ this -> prepareRequest ( ) ; return $ this ; }
8306	public function assertString ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_string ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be a string." ) ; } return $ this ; }
8912	protected function _fetch_primary_key ( ) { if ( $ this -> is_base_model_instance ( ) ) { return ; } if ( $ this -> primary_key == NULL && $ this -> _database ) { $ this -> primary_key = $ this -> execute_query ( "SHOW KEYS FROM `" . $ this -> _database -> dbprefix ( $ this -> _table ) . "` WHERE Key_name = 'PRIMARY'" ) -> row ( ) -> Column_name ; } }
1565	public function getResource ( ) { if ( ! $ this -> resource_type || ! $ this -> resource_id ) { return null ; } return $ this -> getApi ( ) -> getStore ( ) -> find ( ResourceIdentifier :: create ( $ this -> resource_type , ( string ) $ this -> resource_id ) ) ; }
11145	protected function scanDir ( $ dir ) { $ result = array ( ) ; $ list = $ this -> scanDirExec ( $ dir ) ; foreach ( $ list as $ element ) { $ elementPath = $ dir . DIRECTORY_SEPARATOR . $ element ; if ( is_file ( $ elementPath ) ) { $ fileInfo = pathinfo ( $ element ) ; if ( in_array ( $ fileInfo [ 'extension' ] , $ this -> getAllowedFileExtensions ( ) ) ) { $ result [ ] = $ this -> getNameSpace ( ) . "\\" . $ fileInfo [ 'filename' ] ; } } } return $ result ; }
6168	protected function writeAssertionFailure ( $ assertionFailure ) { $ this -> writeNewLine ( ) ; foreach ( explode ( "\n" , $ assertionFailure ) as $ line ) { $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
9409	protected function transform ( $ middleware , $ wrappable = true ) { if ( is_a ( $ middleware , Application :: MIDDLEWARE ) === false ) { $ approach = ( boolean ) $ this -> approach ( $ middleware ) ; $ response = $ approach === self :: SINGLE_PASS ? $ this -> response : null ; $ wrapper = new CallableMiddlewareWrapper ( $ middleware , $ response ) ; $ middleware = $ wrappable === true ? $ wrapper : $ middleware ; } return $ middleware ; }
10289	protected function executeTasks ( array $ tasks ) { foreach ( $ tasks as $ scheduled => $ taskList ) { foreach ( $ taskList as $ cronjob ) { if ( ( $ task = $ this -> taskFactory -> factory ( $ cronjob -> task , $ scheduled , $ this -> logger ) ) !== false ) { $ this -> logger -> setTask ( $ task -> getId ( ) ) ; $ this -> logger -> log ( 'Start task execution.' ) ; $ status = $ task -> execute ( ) ; switch ( $ status ) { case Executor :: SUCCESS : $ this -> logger -> log ( 'Finished task execution.' ) ; break ; case Executor :: ERROR : $ this -> logger -> log ( 'Error occured during task execution.' , Logger :: WARNING ) ; break ; case Executor :: RESCHEDULE : $ this -> logger -> log ( 'Task will be rescheduled for ' . $ task -> reScheduleTime . ' seconds.' ) ; $ this -> rescheduled [ $ scheduled + $ task -> reScheduleTime ] = $ cronjob ; break ; default : $ this -> logger -> log ( 'Invalid status returned by task.' , Logger :: ERROR ) ; break ; } $ this -> logger -> setTask ( ) ; } } } }
1061	public static function findValuesAddedToEnums ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ valuesAddedToEnums = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof EnumType ) || ! ( $ newType instanceof EnumType ) ) { continue ; } $ valuesInOldEnum = [ ] ; foreach ( $ oldType -> getValues ( ) as $ value ) { $ valuesInOldEnum [ $ value -> name ] = true ; } foreach ( $ newType -> getValues ( ) as $ value ) { if ( isset ( $ valuesInOldEnum [ $ value -> name ] ) ) { continue ; } $ valuesAddedToEnums [ ] = [ 'type' => self :: DANGEROUS_CHANGE_VALUE_ADDED_TO_ENUM , 'description' => sprintf ( '%s was added to enum type %s.' , $ value -> name , $ typeName ) , ] ; } } return $ valuesAddedToEnums ; }
5699	public function findActionByName ( $ action ) { $ actions = $ this -> owner -> getBetterButtonsActions ( ) ; $ formAction = false ; foreach ( $ actions as $ f ) { if ( $ formAction ) { break ; } if ( $ f instanceof CompositeField ) { $ formAction = $ f -> fieldByName ( $ action ) ; } elseif ( $ f -> getName ( ) === $ action ) { $ formAction = $ f ; } } if ( ! $ formAction ) { $ utils = $ this -> owner -> getBetterButtonsUtils ( ) ; $ formAction = $ utils -> fieldByName ( $ action ) ; } return $ formAction ; }
4368	public function & offsetGet ( $ key ) { if ( $ this -> hasValue ( $ key ) ) { return $ this -> values [ $ key ] ; } $ null = null ; return $ null ; }
9876	public function writeWorkbook ( Spreadsheet $ spreadsheet , $ recalcRequired = false ) { if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'workbook' ) ; $ objWriter -> writeAttribute ( 'xml:space' , 'preserve' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ this -> writeFileVersion ( $ objWriter ) ; $ this -> writeWorkbookPr ( $ objWriter ) ; $ this -> writeWorkbookProtection ( $ objWriter , $ spreadsheet ) ; if ( $ this -> getParentWriter ( ) -> getOffice2003Compatibility ( ) === false ) { $ this -> writeBookViews ( $ objWriter , $ spreadsheet ) ; } $ this -> writeSheets ( $ objWriter , $ spreadsheet ) ; $ this -> writeDefinedNames ( $ objWriter , $ spreadsheet ) ; $ this -> writeCalcPr ( $ objWriter , $ recalcRequired ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
4405	public function generate ( InputInterface $ input , OutputInterface $ output ) { $ fileSystem = $ this -> container -> get ( 'filesystem' ) ; $ configResolver = $ this -> container -> get ( 'ezpublish.config.resolver' ) ; $ kernelRootDir = $ this -> container -> getParameter ( 'kernel.root_dir' ) ; $ siteAccessGroup = $ input -> getOption ( 'site-access-group' ) ; $ varDir = $ configResolver -> getParameter ( 'var_dir' , null , $ siteAccessGroup ) ; $ repository = $ configResolver -> getParameter ( 'repository' , null , $ siteAccessGroup ) ; $ configFile = $ kernelRootDir . '/config/ngadminui.yml' ; if ( $ fileSystem -> exists ( $ configFile ) ) { if ( ! $ this -> questionHelper -> ask ( $ input , $ output , new ConfirmationQuestion ( '<info><comment>ngadminui.yml</comment> configuration file already exists. Do you want to overwrite it?</info> [<comment>no</comment>] ' , false ) ) ) { return ; } } $ siteAccessName = $ input -> getOption ( 'site-access-name' ) ; $ languageService = $ this -> container -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; $ languages = $ languageService -> loadLanguages ( ) ; $ settings = array ( 'parameters' => array ( 'netgen_admin_ui.' . $ siteAccessName . '.is_admin_ui_siteaccess' => true , 'eztags.' . $ siteAccessName . '.routing.enable_tag_router' => false , 'ezsettings.' . $ siteAccessName . '.treemenu.http_cache' => false , ) , 'ezpublish' => array ( 'siteaccess' => array ( 'list' => array ( $ siteAccessName , ) , 'groups' => array ( 'ngadminui' => array ( $ siteAccessName , ) , ) , 'match' => array ( 'Map\URI' => array ( $ siteAccessName => $ siteAccessName , ) , ) , ) , 'system' => array ( $ siteAccessName => array ( 'user' => array ( 'layout' => '@NetgenAdminUI/pagelayout_login.html.twig' , 'login_template' => '@NetgenAdminUI/user/login.html.twig' , ) , 'languages' => array_map ( function ( Language $ language ) { return $ language -> languageCode ; } , $ languages ) , 'var_dir' => $ varDir , 'repository' => $ repository , ) , ) , ) , 'ez_publish_legacy' => array ( 'system' => array ( $ siteAccessName => array ( 'templating' => array ( 'view_layout' => '@NetgenAdminUI/pagelayout_legacy.html.twig' , 'module_layout' => '@NetgenAdminUI/pagelayout_module.html.twig' , ) , ) , ) , ) , ) ; file_put_contents ( $ configFile , Yaml :: dump ( $ settings , 7 ) ) ; $ output -> writeln ( array ( '' , 'Generated <comment>ngadminui.yml</comment> configuration file!' , '' , ) ) ; }
9924	public function filter ( Parameters $ params , array $ permitted = array ( ) ) { $ this -> cleanUnwanted ( $ params , $ permitted ) ; $ this -> handleArrays ( $ params , $ permitted ) ; $ this -> handleCollections ( $ params , $ permitted ) ; }
602	public function tokenize ( ) { $ this -> length = mb_strlen ( $ this -> sql , 'UTF-8' ) ; $ this -> offset = 0 ; $ this -> _substrings = [ ] ; $ this -> _buffer = '' ; $ this -> _token = new SqlToken ( [ 'type' => SqlToken :: TYPE_CODE , 'content' => $ this -> sql , ] ) ; $ this -> _tokenStack = new \ SplStack ( ) ; $ this -> _tokenStack -> push ( $ this -> _token ) ; $ this -> _token [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_STATEMENT ] ) ; $ this -> _tokenStack -> push ( $ this -> _token [ 0 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; while ( ! $ this -> isEof ( ) ) { if ( $ this -> isWhitespace ( $ length ) || $ this -> isComment ( $ length ) ) { $ this -> addTokenFromBuffer ( ) ; $ this -> advance ( $ length ) ; continue ; } if ( $ this -> tokenizeOperator ( $ length ) || $ this -> tokenizeDelimitedString ( $ length ) ) { $ this -> advance ( $ length ) ; continue ; } $ this -> _buffer .= $ this -> substring ( 1 ) ; $ this -> advance ( 1 ) ; } $ this -> addTokenFromBuffer ( ) ; if ( $ this -> _token -> getHasChildren ( ) && ! $ this -> _token [ - 1 ] -> getHasChildren ( ) ) { unset ( $ this -> _token [ - 1 ] ) ; } return $ this -> _token ; }
9790	public function getFormattedValue ( ) { return ( string ) NumberFormat :: toFormattedString ( $ this -> getCalculatedValue ( ) , $ this -> getStyle ( ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; }
12860	public function getDispatcher ( ) : Dispatcher { if ( $ this -> forceReload || ! file_exists ( $ this -> cacheFile ) ) { $ dispatchData = $ this -> buildCache ( ) ; } else { $ dispatchData = require $ this -> cacheFile ; } return call_user_func ( $ this -> dispatcherFactory , $ dispatchData ) ; }
4328	public static function parseAttribString ( $ str , $ dataDecode = true ) { $ attribs = array ( ) ; $ regexAttribs = '/\b([\w\-]+)\b(?: \s*=\s*(["\'])(.*?)\\2 | \s*=\s*(\S+) )?/xs' ; \ preg_match_all ( $ regexAttribs , $ str , $ matches ) ; $ keys = \ array_map ( 'strtolower' , $ matches [ 1 ] ) ; $ values = \ array_replace ( $ matches [ 3 ] , \ array_filter ( $ matches [ 4 ] , 'strlen' ) ) ; foreach ( $ keys as $ i => $ k ) { $ attribs [ $ k ] = $ values [ $ i ] ; if ( \ in_array ( $ k , self :: $ htmlBoolAttr ) ) { $ attribs [ $ k ] = true ; } } \ ksort ( $ attribs ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_string ( $ v ) ) { $ attribs [ $ k ] = \ htmlspecialchars_decode ( $ v ) ; } $ isDataAttrib = \ strpos ( $ k , 'data-' ) === 0 ; if ( $ isDataAttrib && $ dataDecode ) { $ val = $ attribs [ $ k ] ; $ attribs [ $ k ] = \ json_decode ( $ attribs [ $ k ] , true ) ; if ( $ attribs [ $ k ] === null && $ val !== 'null' ) { $ attribs [ $ k ] = \ json_decode ( '"' . $ val . '"' , true ) ; } } } return $ attribs ; }
6700	public function setPreRelease ( $ pre ) { $ this -> pre = array_values ( ( array ) $ pre ) ; array_walk ( $ this -> pre , function ( & $ v ) { if ( preg_match ( '/^[0-9]+$/' , $ v ) ) { $ v = ( int ) $ v ; } } ) ; }
9850	public function stringToStream ( string $ input ) : StreamInterface { $ stream = \ fopen ( 'php://temp' , 'w+' ) ; if ( ! \ is_resource ( $ stream ) ) { throw new \ Error ( 'Could not create stream' ) ; } \ fwrite ( $ stream , $ input ) ; \ rewind ( $ stream ) ; return new Stream ( $ stream ) ; }
1733	protected function getBookPages ( $ intParentId , $ groups , $ time ) { $ objPages = PageModel :: findPublishedSubpagesWithoutGuestsByPid ( $ intParentId , $ this -> showHidden ) ; if ( $ objPages === null ) { return ; } foreach ( $ objPages as $ objPage ) { $ _groups = StringUtil :: deserialize ( $ objPage -> groups ) ; if ( ! $ objPage -> protected || $ this -> showProtected || ( \ is_array ( $ groups ) && \ is_array ( $ _groups ) && \ count ( array_intersect ( $ groups , $ _groups ) ) ) ) { $ this -> arrPages [ $ objPage -> id ] = $ objPage ; if ( $ objPage -> subpages > 0 ) { $ this -> getBookPages ( $ objPage -> id , $ groups , $ time ) ; } } } }
1649	public function getLats ( ) : array { $ lats = [ ] ; foreach ( $ this -> points as $ point ) { $ lats [ ] = $ point -> getLat ( ) ; } return $ lats ; }
6314	public function setReferencedColumns ( $ columns ) { if ( ! is_array ( $ columns ) ) { $ columns = array ( $ columns ) ; } $ this -> referencedColumns = $ columns ; return $ this ; }
10113	private function writeSetup ( ) { $ record = 0x00A1 ; $ length = 0x0022 ; $ iPaperSize = $ this -> phpSheet -> getPageSetup ( ) -> getPaperSize ( ) ; $ iScale = $ this -> phpSheet -> getPageSetup ( ) -> getScale ( ) ? $ this -> phpSheet -> getPageSetup ( ) -> getScale ( ) : 100 ; $ iPageStart = 0x01 ; $ iFitWidth = ( int ) $ this -> phpSheet -> getPageSetup ( ) -> getFitToWidth ( ) ; $ iFitHeight = ( int ) $ this -> phpSheet -> getPageSetup ( ) -> getFitToHeight ( ) ; $ grbit = 0x00 ; $ iRes = 0x0258 ; $ iVRes = 0x0258 ; $ numHdr = $ this -> phpSheet -> getPageMargins ( ) -> getHeader ( ) ; $ numFtr = $ this -> phpSheet -> getPageMargins ( ) -> getFooter ( ) ; $ iCopies = 0x01 ; $ fLeftToRight = 0x0 ; $ fLandscape = ( $ this -> phpSheet -> getPageSetup ( ) -> getOrientation ( ) == PageSetup :: ORIENTATION_LANDSCAPE ) ? 0x0 : 0x1 ; $ fNoPls = 0x0 ; $ fNoColor = 0x0 ; $ fDraft = 0x0 ; $ fNotes = 0x0 ; $ fNoOrient = 0x0 ; $ fUsePage = 0x0 ; $ grbit = $ fLeftToRight ; $ grbit |= $ fLandscape << 1 ; $ grbit |= $ fNoPls << 2 ; $ grbit |= $ fNoColor << 3 ; $ grbit |= $ fDraft << 4 ; $ grbit |= $ fNotes << 5 ; $ grbit |= $ fNoOrient << 6 ; $ grbit |= $ fUsePage << 7 ; $ numHdr = pack ( 'd' , $ numHdr ) ; $ numFtr = pack ( 'd' , $ numFtr ) ; if ( self :: getByteOrder ( ) ) { $ numHdr = strrev ( $ numHdr ) ; $ numFtr = strrev ( $ numFtr ) ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data1 = pack ( 'vvvvvvvv' , $ iPaperSize , $ iScale , $ iPageStart , $ iFitWidth , $ iFitHeight , $ grbit , $ iRes , $ iVRes ) ; $ data2 = $ numHdr . $ numFtr ; $ data3 = pack ( 'v' , $ iCopies ) ; $ this -> append ( $ header . $ data1 . $ data2 . $ data3 ) ; }
10710	public function getById ( $ id , $ columns = [ '*' ] ) { try { $ results = $ this -> getQuery ( ) -> findOrFail ( $ id , $ columns ) ; } catch ( ModelNotFoundException $ e ) { throw new NotFoundRepositoryException ( $ e ) ; } return $ this -> returnResults ( $ results ) ; }
6748	public function handle ( ServerRequestInterface $ request ) { list ( $ httpResponse , $ _ ) = $ this -> requestHandler -> handleServerRequest ( $ request ) ; return $ httpResponse ; }
11517	protected function GenerateIOSPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ IOSPinicon ) { $ metadata .= $ this -> owner -> MarkupComment ( 'iOS Pinned Icon' ) ; if ( $ config -> fetchPiniconTitle ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'apple-mobile-web-app-title' , $ config -> fetchPiniconTitle ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 57 , 57 ) -> getAbsoluteURL ( ) , 'image/png' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 60 , 60 ) -> getAbsoluteURL ( ) , 'image/png' , '60x60' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'image/png' , '72x72' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 76 , 76 ) -> getAbsoluteURL ( ) , 'image/png' , '76x76' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 114 , 114 ) -> getAbsoluteURL ( ) , 'image/png' , '114x114' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 120 , 120 ) -> getAbsoluteURL ( ) , 'image/png' , '120x120' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'image/png' , '144x144' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 152 , 152 ) -> getAbsoluteURL ( ) , 'image/png' , '152x152' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 180 , 180 ) -> getAbsoluteURL ( ) , 'image/png' , '180x180' ) ; }
11467	public function init ( array $ viewDirs , array $ params ) { $ this -> viewDirs = $ viewDirs ; $ this -> params = $ params ; $ this -> parts = new ClearViewPartsCollection ( ) ; }
1070	private function collectConflictsBetweenFragments ( ValidationContext $ context , array & $ conflicts , $ areMutuallyExclusive , $ fragmentName1 , $ fragmentName2 ) { if ( $ fragmentName1 === $ fragmentName2 ) { return ; } if ( $ this -> comparedFragmentPairs -> has ( $ fragmentName1 , $ fragmentName2 , $ areMutuallyExclusive ) ) { return ; } $ this -> comparedFragmentPairs -> add ( $ fragmentName1 , $ fragmentName2 , $ areMutuallyExclusive ) ; $ fragment1 = $ context -> getFragment ( $ fragmentName1 ) ; $ fragment2 = $ context -> getFragment ( $ fragmentName2 ) ; if ( ! $ fragment1 || ! $ fragment2 ) { return ; } [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getReferencedFieldsAndFragmentNames ( $ context , $ fragment1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getReferencedFieldsAndFragmentNames ( $ context , $ fragment2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentName1 , $ fragmentNames2 [ $ j ] ) ; } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentName2 ) ; } }
6728	public function set_total_votes ( $ post_id , $ votes ) { $ votes = json_encode ( $ votes , true ) ; if ( ! add_post_meta ( $ post_id , 'imdbTotalVotes' , $ votes , true ) ) { update_post_meta ( $ post_id , 'imdbTotalVotes' , $ votes ) ; } }
10373	public static function unify ( $ id , $ params , $ minify = '' ) { self :: $ id = $ id ; self :: $ unify = $ params ; self :: $ minify = $ minify ; return true ; }
8654	private function convertSubmitFeed ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'SubmitFeed' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMarketplaceIdList ( ) ) { $ marketplaceIdList = $ request -> getMarketplaceIdList ( ) ; foreach ( $ marketplaceIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'MarketplaceIdList.Id.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetFeedType ( ) ) { $ parameters [ 'FeedType' ] = $ request -> getFeedType ( ) ; } if ( $ request -> isSetPurgeAndReplace ( ) ) { $ parameters [ 'PurgeAndReplace' ] = $ request -> getPurgeAndReplace ( ) ? "true" : "false" ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } $ headers = array ( ) ; array_push ( $ headers , "Content-Type: " . $ request -> getContentType ( ) -> toString ( ) ) ; return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ headers ) ; }
8289	protected function authRoutes ( ) { switch ( $ this -> requestUrl ) { case 'login' : if ( $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToPage ( $ this -> config [ "afterLogin" ] ) ; } break ; case 'logout' : if ( ! $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToLogin ( ) ; } $ this -> checkLogoutSubmission ( ) ; break ; } }
7468	protected function colorize ( $ str , $ attrs ) { $ start = $ this -> start ( $ attrs ) ; return $ start . $ str . $ this -> end ( ) ; }
10252	public function getLastName ( $ max = 250 ) { return LastName :: where ( 'rank' , '<=' , $ max ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; }
3993	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: encodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( $ values ) ; }
5735	public function getMatchesForTeam ( int $ teamID , array $ filter = [ 'dateFrom' => '' , 'dateTo' => '' , 'status' => '' , 'venue' => '' ] ) { $ matches = $ this -> run ( "v2/teams/{$teamID}/matches" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ matches -> matches ) ; }
10716	public function deleteMany ( ArrayAccess $ models ) { $ results = [ ] ; foreach ( $ models as $ model ) { $ results [ ] = $ this -> delete ( $ model ) ; } return $ this -> returnResults ( $ results ) ; }
4217	private function clearErrorsHelper ( & $ log , $ clear = true ) { $ errorsNotCleared = array ( ) ; foreach ( $ log as $ k => $ entry ) { if ( ! \ in_array ( $ entry [ 0 ] , array ( 'error' , 'warn' ) ) ) { continue ; } $ clear2 = $ clear ; if ( $ this -> channelName ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; $ clear2 = $ clear && $ channel === $ this -> channelName ; } if ( $ clear2 ) { unset ( $ log [ $ k ] ) ; } elseif ( isset ( $ entry [ 2 ] [ 'errorHash' ] ) ) { $ errorsNotCleared [ ] = $ entry [ 2 ] [ 'errorHash' ] ; } } $ log = \ array_values ( $ log ) ; return $ errorsNotCleared ; }
6919	public function getAdjustments ( $ type = null ) { if ( null !== $ type ) { AdjustmentTypes :: isValidType ( $ type ) ; return $ this -> adjustments -> filter ( function ( AdjustmentInterface $ a ) use ( $ type ) { return $ a -> getType ( ) === $ type ; } ) ; } return $ this -> adjustments ; }
2458	public function undo ( ) { $ objRecords = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; if ( $ objRecords -> numRows < 1 ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ error = false ; $ query = $ objRecords -> query ; $ data = StringUtil :: deserialize ( $ objRecords -> data ) ; if ( ! \ is_array ( $ data ) ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ arrFields = array ( ) ; foreach ( $ data as $ table => $ fields ) { $ this -> loadDataContainer ( $ table ) ; if ( ! isset ( $ arrFields [ $ table ] ) ) { $ arrFields [ $ table ] = array_flip ( $ this -> Database -> getFieldNames ( $ table ) ) ; } foreach ( $ fields as $ row ) { $ row = array_intersect_key ( $ row , $ arrFields [ $ table ] ) ; $ objInsertStmt = $ this -> Database -> prepare ( "INSERT INTO " . $ table . " %s" ) -> set ( $ row ) -> execute ( ) ; if ( $ objInsertStmt -> affectedRows < 1 ) { $ error = true ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'onundo_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'onundo_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ table , $ row , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ table , $ row , $ this ) ; } } } } } if ( ! $ error ) { $ this -> log ( 'Undone ' . $ query , __METHOD__ , TL_GENERAL ) ; $ this -> Database -> prepare ( "DELETE FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
343	protected function renderSortLinks ( ) { $ attributes = empty ( $ this -> attributes ) ? array_keys ( $ this -> sort -> attributes ) : $ this -> attributes ; $ links = [ ] ; foreach ( $ attributes as $ name ) { $ links [ ] = $ this -> sort -> link ( $ name , $ this -> linkOptions ) ; } return Html :: ul ( $ links , array_merge ( $ this -> options , [ 'encode' => false ] ) ) ; }
4042	public function getReadableValue ( RenderReadablePropertyValueEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ result = $ nativeItem -> parseAttribute ( $ event -> getProperty ( ) -> getName ( ) , 'text' , $ renderSetting ) ; if ( ! isset ( $ result [ 'text' ] ) ) { $ event -> setRendered ( sprintf ( 'Unexpected behaviour, attribute %s text representation was not rendered.' , $ event -> getProperty ( ) -> getName ( ) ) ) ; return ; } $ event -> setRendered ( $ result [ 'text' ] ) ; }
1351	protected function allowed ( string $ resourceType , string $ fields ) : bool { return $ this -> notAllowed ( $ resourceType , $ fields ) -> isEmpty ( ) ; }
7206	public function addTaxAdjustment ( Adjustment $ tax ) : void { foreach ( $ this -> taxes as $ t ) { if ( $ t -> isSameAs ( $ tax ) ) { $ t -> addAmount ( $ tax -> getAmount ( ) ) ; return ; } } $ this -> taxes [ ] = clone $ tax ; }
6791	public function create ( $ type , $ source = null ) { $ notify = new Notify ( ) ; $ notify -> setType ( $ type ) -> setSource ( $ source ) ; return $ notify ; }
6332	public function createResponse ( $ status , $ errorCode , $ errorDescription ) { $ document = new \ DOMDocument ( '1.0' , 'utf-8' ) ; $ document -> formatOutput = false ; $ response = $ document -> appendChild ( $ document -> createElement ( 'SVSPurchaseStatusNotificationResponse' ) ) ; $ result = $ response -> appendChild ( $ document -> createElement ( 'TransactionResult' ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Description' , $ errorDescription ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Code' , $ errorCode ) ) ; $ response -> appendChild ( $ document -> createElement ( 'Status' , $ status ) ) ; $ authentication = $ response -> appendChild ( $ document -> createElement ( 'Authentication' ) ) ; $ checksum = $ authentication -> appendChild ( $ document -> createElement ( 'Checksum' , $ this -> getMerchantPassword ( ) ) ) ; $ checksum -> nodeValue = $ this -> calculateXmlChecksum ( $ document -> saveXML ( ) ) ; return $ document -> saveXML ( ) ; }
5621	protected function chompScheme ( & $ url ) { if ( preg_match ( '#^([^/:]*):(//)(.*)#' , $ url , $ matches ) ) { $ url = $ matches [ 2 ] . $ matches [ 3 ] ; return $ matches [ 1 ] ; } return false ; }
4827	public static function find ( $ id ) { $ endpoint = self :: $ endpoint . '/' . $ id ; return new self ( GoCardless :: $ client , GoCardless :: $ client -> request ( 'get' , $ endpoint ) ) ; }
12606	public static function getPath ( string $ file ) { $ parts = explode ( '/' , $ file ) ; array_pop ( $ parts ) ; return implode ( '/' , $ parts ) ; }
2268	public function isUniqueValue ( $ strTable , $ strField , $ varValue , $ intId = null ) { $ strQuery = "SELECT * FROM $strTable WHERE " . static :: quoteIdentifier ( $ strField ) . "=?" ; if ( $ intId !== null ) { $ strQuery .= " AND id!=?" ; } $ objUnique = $ this -> prepare ( $ strQuery ) -> limit ( 1 ) -> execute ( $ varValue , $ intId ) ; return $ objUnique -> numRows ? false : true ; }
5967	public function tempPasswordList ( $ resolve = false ) { $ passwords = $ this -> request ( "servertemppasswordlist" ) -> toAssocArray ( "pw_clear" ) ; if ( $ resolve ) { foreach ( $ passwords as $ password => $ array ) { try { $ channel = $ this -> channelGetById ( $ array [ "tcid" ] ) ; $ passwords [ $ password ] [ "tcname" ] = $ channel -> toString ( ) ; $ passwords [ $ password ] [ "tcpath" ] = $ channel -> getPathway ( ) ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0xA00 ) { throw $ e ; } } } } return $ passwords ; }
8708	public function select ( $ columns = [ '*' ] ) { parent :: select ( $ columns ) ; $ this -> columns = $ this -> qualifyColumns ( $ this -> columns ) ; return $ this ; }
5040	public function setPermissions ( PermissionsInterface $ permissions ) { foreach ( $ this -> getImages ( ) as $ file ) { $ filePermissions = $ file -> getPermissions ( ) ; $ filePermissions -> clear ( ) ; $ filePermissions -> inherit ( $ permissions ) ; } return $ this ; }
7825	protected function getTotalWidth ( ) { $ borders = ( static :: BORDER_WIDTH + static :: MIN_SPACE_FROM_BORDER_X ) * 2 ; if ( empty ( $ this -> pipes ) ) { return $ borders + $ this -> getCoreLength ( ) ; } $ borders *= count ( $ this -> pipes ) ; $ name = ( $ this -> getLongestPipeLength ( ) + static :: SPACE_FROM_ARROW ) * 2 ; return $ borders + $ name + static :: ARROW_WIDTH ; }
3744	protected function getMetaModel ( ) { if ( ! $ this -> metaModel ) { if ( $ this -> metaModel === null ) { throw new \ RuntimeException ( 'No MetaModel instance set for ' . $ this -> strTable ) ; } } return $ this -> metaModel ; }
11065	public function icon ( $ level , $ default = null ) { if ( array_key_exists ( $ level , $ this -> icons ) ) { return $ this -> icons [ $ level ] ; } return $ default ; }
5688	public function getFormByImage ( $ selector ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> hasImage ( $ selector ) ) { return $ this -> forms [ $ i ] ; } } return ; }
3462	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ next ) : ResponseInterface { $ route = $ this -> router -> find ( $ request -> getMethod ( ) , $ request -> getUri ( ) -> getPath ( ) ) ; $ controller = $ route -> getController ( ) ; if ( $ request instanceof ServerRequest ) { $ request = $ request -> withAttributes ( $ route -> getAttributes ( ) ) ; } if ( is_string ( $ controller ) && class_exists ( $ controller ) && is_subclass_of ( $ controller , Controller :: class ) ) { $ instance = $ this -> resolver -> resolve ( $ controller ) ; return $ instance ( $ request ) ; } if ( is_callable ( $ controller ) ) { $ response = $ controller ( $ request ) ; if ( ! $ response instanceof ResponseInterface ) { throw ControllerException :: forInvalidReturnValue ( ) ; } return $ response ; } throw ControllerException :: forMissingController ( $ route -> getPath ( ) ) ; }
2313	public function executeResize ( ) { $ image = $ this -> prepareImage ( ) ; $ resizeConfig = $ this -> prepareResizeConfig ( ) ; if ( ! System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) && $ this -> getTargetPath ( ) && ! $ this -> getForceOverride ( ) && file_exists ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) && $ this -> fileObj -> mtime <= filemtime ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] as $ callback ) { $ return = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ this ) ; if ( \ is_string ( $ return ) ) { $ this -> resizedPath = System :: urlEncode ( $ return ) ; return $ this ; } } } $ this -> resizedPath = System :: urlEncode ( $ this -> getTargetPath ( ) ) ; return $ this ; } $ image = System :: getContainer ( ) -> get ( 'contao.image.resizer' ) -> resize ( $ image , $ resizeConfig , ( new ResizeOptions ( ) ) -> setImagineOptions ( System :: getContainer ( ) -> getParameter ( 'contao.image.imagine_options' ) ) -> setTargetPath ( $ this -> targetPath ? $ this -> strRootDir . '/' . $ this -> targetPath : null ) -> setBypassCache ( System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) ) ) ; $ this -> resizedPath = $ image -> getUrl ( $ this -> strRootDir ) ; return $ this ; }
1456	protected function validateHasMany ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasManyExpected ( $ key ) ) ; return false ; } $ identifiers = $ relationship -> getIdentifiers ( ) ; if ( ! $ this -> validateIdentifiers ( $ identifiers , $ record , $ key , $ resource ) ) { return false ; } return true ; }
10236	private function writeDefaultContentType ( XMLWriter $ objWriter , $ pPartname , $ pContentType ) { if ( $ pPartname != '' && $ pContentType != '' ) { $ objWriter -> startElement ( 'Default' ) ; $ objWriter -> writeAttribute ( 'Extension' , $ pPartname ) ; $ objWriter -> writeAttribute ( 'ContentType' , $ pContentType ) ; $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
11961	public function each ( Closure $ fn ) { foreach ( $ this -> elements as $ key => $ element ) { if ( $ fn ( $ element , $ key ) === false ) { return false ; } } return true ; }
10705	public function getEntityManager ( ) { if ( null === $ this -> em ) { $ mainService = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ this -> em = $ mainService -> getEntityManager ( ) ; } return $ this -> em ; }
7511	protected function parse_linebreak ( ) { if ( $ this -> doc [ $ this -> pos ] === "\r" ) { ++ $ this -> line_pos [ 0 ] ; if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === "\n" ) ) { ++ $ this -> pos ; } $ this -> line_pos [ 1 ] = $ this -> pos ; } elseif ( $ this -> doc [ $ this -> pos ] === "\n" ) { ++ $ this -> line_pos [ 0 ] ; $ this -> line_pos [ 1 ] = $ this -> pos ; } }
356	public function init ( ) { parent :: init ( ) ; if ( $ this -> enableCoreCommands ) { foreach ( $ this -> coreCommands ( ) as $ id => $ command ) { if ( ! isset ( $ this -> controllerMap [ $ id ] ) ) { $ this -> controllerMap [ $ id ] = $ command ; } } } if ( ! isset ( $ this -> controllerMap [ 'help' ] ) ) { $ this -> controllerMap [ 'help' ] = 'yii\console\controllers\HelpController' ; } }
449	public function init ( ) { parent :: init ( ) ; $ this -> cachePath = Yii :: getAlias ( $ this -> cachePath ) ; if ( ! is_dir ( $ this -> cachePath ) ) { FileHelper :: createDirectory ( $ this -> cachePath , $ this -> dirMode , true ) ; } }
9358	public function getModulePath ( $ moduleName ) { if ( array_key_exists ( $ moduleName , $ this -> loadedModules ) ) { $ module = $ this -> loadedModules [ $ moduleName ] ; $ moduleConfig = $ module -> getAutoloaderConfig ( ) ; return $ moduleConfig [ self :: STANDARD_AUTOLOLOADER ] [ self :: NAMESPACE_KEY ] [ $ moduleName ] ; } return null ; }
11579	private function config ( ) { $ handler = new RotatingFileHandler ( $ this -> getFullPath ( ) , 0 , MonoLogger :: INFO ) ; $ handler -> setFormatter ( $ this -> getLineFormater ( ) ) ; $ this -> logger -> pushHandler ( $ handler ) ; $ this -> logger -> pushProcessor ( new WebProcessor ( ) ) ; $ this -> logger -> pushProcessor ( new MemoryUsageProcessor ( ) ) ; }
7353	protected function getProvider ( $ nameOrRelativeOrSubject ) { if ( null === $ provider = $ this -> registry -> getProvider ( $ nameOrRelativeOrSubject ) ) { throw new SubjectException ( 'Failed to get provider.' ) ; } return $ provider ; }
2183	public function create ( ) : ItemInterface { $ tree = $ this -> factory -> createItem ( 'root' ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: BACKEND_MENU_BUILD , new MenuEvent ( $ this -> factory , $ tree ) ) ; return $ tree ; }
1434	public static function decamelize ( $ value ) { if ( isset ( self :: $ decamelized [ $ value ] ) ) { return self :: $ decamelized [ $ value ] ; } return self :: $ decamelized [ $ value ] = strtolower ( preg_replace ( '/(.)(?=[A-Z])/u' , '$1_' , $ value ) ) ; }
3430	protected function rememberInCache ( $ key , $ minutes , Closure $ callback ) { $ minutes = ( double ) $ minutes ; if ( $ minutes <= 0 ) { return $ callback ( ) ; } $ cache = Cache :: createInstance ( ) ; if ( $ cache -> initCache ( $ minutes * 60 , $ key , '/bitrix-models' ) ) { $ vars = $ cache -> getVars ( ) ; return ! empty ( $ vars [ 'isCollection' ] ) ? new Collection ( $ vars [ 'cache' ] ) : $ vars [ 'cache' ] ; } $ cache -> startDataCache ( ) ; $ result = $ callback ( ) ; $ isCollection = $ result instanceof Collection ; if ( $ isCollection ) { $ result = $ result -> all ( ) ; } $ cache -> endDataCache ( [ 'cache' => $ result , 'isCollection' => $ isCollection ] ) ; return $ isCollection ? new Collection ( $ result ) : $ result ; }
9662	private static function getReaderTypeFromExtension ( $ filename ) { $ pathinfo = pathinfo ( $ filename ) ; if ( ! isset ( $ pathinfo [ 'extension' ] ) ) { return null ; } switch ( strtolower ( $ pathinfo [ 'extension' ] ) ) { case 'xlsx' : case 'xlsm' : case 'xltx' : case 'xltm' : return 'Xlsx' ; case 'xls' : case 'xlt' : return 'Xls' ; case 'ods' : case 'ots' : return 'Ods' ; case 'slk' : return 'Slk' ; case 'xml' : return 'Xml' ; case 'gnumeric' : return 'Gnumeric' ; case 'htm' : case 'html' : return 'Html' ; case 'csv' : return null ; default : return null ; } }
2726	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , 'magentomodule_basic_auth' ) ; if ( ! $ dictionary || ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) ) { return $ result -> setData ( [ 'status' => 'none' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ authItems = false ; if ( isset ( $ dictionary -> id ) ) { $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; } if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'There are no dictionary items.' ] ) ; } if ( ! $ authItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch dictionary items.' ] ) ; } foreach ( $ authItems as $ key => $ item ) { $ userData = explode ( ':' , base64_decode ( $ item -> item_key ) ) ; $ username = $ userData [ 0 ] ; $ item -> item_key_id = $ item -> item_key ; $ item -> item_key = $ username ; $ authItems [ $ key ] = $ item ; } return $ result -> setData ( [ 'status' => true , 'auths' => $ authItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11741	private function _getPerson ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ person = $ em -> getRepository ( 'ChillPersonBundle:Person' ) -> find ( $ id ) ; return $ person ; }
4060	public static function compare ( $ expected , $ actual , $ strict = true ) { try { self :: calculateDiff ( $ expected , $ actual , $ strict ) ; } catch ( \ Exception $ exception ) { $ instance = new DifferentValuesException ( $ expected , $ actual , $ strict , 'The values differ.' , 0 , $ exception ) ; throw $ instance ; } }
4470	public function complete ( ? string $ nextq = null , int $ delay = 0 , array $ depends = [ ] ) : string { if ( $ this -> completed || $ this -> failed ) { throw new JobAlreadyFinishedException ( ) ; } $ params = [ $ this -> jid , $ this -> worker , $ this -> queue , json_encode ( $ this -> data , JSON_UNESCAPED_SLASHES ) ? : '{}' ] ; if ( $ nextq ) { $ next = [ 'next' , $ nextq , 'delay' , $ delay , 'depends' , json_encode ( $ depends , JSON_UNESCAPED_SLASHES ) ] ; $ params = array_merge ( $ params , $ next ) ; } $ this -> completed = true ; return call_user_func_array ( [ $ this -> client , 'complete' ] , $ params ) ; }
8972	protected function paginate ( array $ rates , $ criteria ) { if ( ! array_key_exists ( 'offset' , $ criteria ) && ! array_key_exists ( 'limit' , $ criteria ) ) { return $ rates ; } $ range = array ( ) ; $ offset = array_key_exists ( 'offset' , $ criteria ) ? $ criteria [ 'offset' ] : 0 ; $ limit = min ( ( array_key_exists ( 'limit' , $ criteria ) ? $ criteria [ 'limit' ] : count ( $ rates ) ) + $ offset , count ( $ rates ) ) ; for ( $ i = $ offset ; $ i < $ limit ; $ i ++ ) { $ range [ ] = $ rates [ $ i ] ; } return $ range ; }
2607	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ ioOptions = $ this -> api -> getImageOptimizationDefaultConfigOptions ( $ activeVersion ) -> data -> attributes ; if ( ! $ ioOptions ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch image optimization default config options.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'io_options' => $ ioOptions ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
3853	public function overrideOutputFormat ( $ strOutputFormat = null ) { $ strOutputFormat = strval ( $ strOutputFormat ) ; if ( strlen ( $ strOutputFormat ) ) { $ this -> strOutputFormat = $ strOutputFormat ; } else { unset ( $ this -> strOutputFormat ) ; } return $ this ; }
633	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> delete ( $ table , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
8984	public function isEqual ( TableNode $ expected , TableNode $ actual , $ message = NULL ) { $ this -> doAssert ( 'Failed asserting that two tables were equivalent: ' , [ 'ignoreColumnSequence' => TRUE ] , $ expected , $ actual , $ message ) ; }
7617	public function api_request ( $ path , $ options ) { $ data = $ this -> requestHandler -> request ( $ path , $ options ) ; return json_encode ( $ data -> json ) ; }
11677	protected function isFileLoaded ( $ locale , $ file ) { if ( array_key_exists ( $ locale , $ this -> translations ) === false ) { return false ; } if ( array_key_exists ( $ file , $ this -> translations [ $ locale ] ) === false ) { return false ; } return true ; }
6870	protected function buildPaymentList ( PM \ PaymentSubjectInterface $ subject ) { $ payments = array_filter ( $ subject -> getPayments ( ) -> toArray ( ) , function ( PM \ PaymentInterface $ p ) { if ( $ p -> getMethod ( ) -> isOutstanding ( ) ) { return false ; } if ( ! PM \ PaymentStates :: isPaidState ( $ p -> getState ( ) ) ) { return false ; } return true ; } ) ; usort ( $ payments , function ( PM \ PaymentInterface $ a , PM \ PaymentInterface $ b ) { return $ a -> getCompletedAt ( ) -> getTimestamp ( ) - $ b -> getCompletedAt ( ) -> getTimestamp ( ) ; } ) ; return array_map ( function ( PM \ PaymentInterface $ payment ) { return [ 'payment' => $ payment , 'amount' => $ payment -> getAmount ( ) , ] ; } , $ payments ) ; }
5737	public function selectRenderer ( ViewEvent $ e ) { if ( $ this -> renderer -> canRender ( $ e -> getModel ( ) -> getTemplate ( ) ) ) { return $ this -> renderer ; } return false ; }
4815	public function getAsDom ( ) { $ anyDataSet = XmlUtil :: createXmlDocumentFromStr ( "<anydataset></anydataset>" ) ; $ nodeRoot = $ anyDataSet -> getElementsByTagName ( "anydataset" ) -> item ( 0 ) ; foreach ( $ this -> collection as $ sr ) { $ row = $ sr -> getAsDom ( ) ; $ nodeRow = $ row -> getElementsByTagName ( "row" ) -> item ( 0 ) ; $ newRow = XmlUtil :: createChild ( $ nodeRoot , "row" ) ; XmlUtil :: addNodeFromNode ( $ newRow , $ nodeRow ) ; } return $ anyDataSet ; }
11221	private static function routeValidator ( ) { self :: $ uri = Url :: getUriMethods ( ) ; self :: $ uri = Url :: setUrlParams ( self :: $ uri ) ; self :: $ uri = Url :: addBackSlash ( self :: $ uri ) ; self :: cleanResources ( ) ; if ( self :: getMethod ( self :: $ uri ) ) { self :: any ( self :: $ uri , self :: $ routes [ self :: $ uri ] ) ; } }
8168	public function outdent ( $ step = 1 ) { if ( $ this -> indentation < $ step ) { throw new LogicException ( 'Unable to call outdent() as the indentation would become negative.' ) ; } $ this -> indentation -= $ step ; return $ this ; }
10606	public function addHeader ( string $ header , $ value ) : void { if ( is_iterable ( $ value ) || is_array ( $ value ) ) { $ iterable = $ value ; $ value = [ ] ; foreach ( $ iterable as $ key => $ entry ) { $ value [ $ key ] = ( string ) $ entry ; } } else { $ value = ( string ) $ value ; } $ this -> headers [ ] = [ $ header , $ value ] ; }
4239	public function onBootstrap ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ collectWas = $ this -> debug -> setCfg ( 'collect' , true ) ; $ this -> debug -> groupSummary ( ) ; $ this -> debug -> group ( 'environment' , $ this -> debug -> meta ( array ( 'hideIfEmpty' => true , 'level' => 'info' , ) ) ) ; $ this -> logPhpInfo ( ) ; $ this -> logServerVals ( ) ; $ this -> logRequest ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> setCfg ( 'collect' , $ collectWas ) ; }
6941	private function getPurchaseCost ( Model \ SaleItemInterface $ item ) { if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ item ) ) { return null ; } $ currency = $ item -> getSale ( ) -> getCurrency ( ) -> getCode ( ) ; if ( null !== $ cost = $ this -> purchaseCostGuesser -> guess ( $ subject , $ currency ) ) { return $ cost ; } return null ; }
2353	protected function fputs ( $ varData , $ strMode ) { if ( ! \ is_resource ( $ this -> resFile ) ) { $ this -> strTmp = 'system/tmp/' . md5 ( uniqid ( mt_rand ( ) , true ) ) ; if ( strncmp ( $ strMode , 'a' , 1 ) === 0 && file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { $ this -> Files -> copy ( $ this -> strFile , $ this -> strTmp ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strTmp , $ strMode ) ) { return false ; } } fwrite ( $ this -> resFile , $ varData ) ; return true ; }
9549	public function setPdo ( PDO $ pdo ) { $ this -> pdo = $ pdo ; $ this -> pdo -> setAttribute ( PDO :: ATTR_DEFAULT_FETCH_MODE , PDO :: FETCH_ASSOC ) ; return $ this ; }
747	protected function getTypeCategory ( ) { return isset ( $ this -> categoryMap [ $ this -> type ] ) ? $ this -> categoryMap [ $ this -> type ] : null ; }
2589	protected function addReceivedFrom ( $ explicitRf , $ doAutoAdd , $ defaultRf , & $ tattooCounter ) { if ( $ this -> dataElementsMaster === null ) { $ this -> dataElementsMaster = new DataElementsMaster ( ) ; } if ( ! empty ( $ explicitRf ) || ( $ doAutoAdd && ! empty ( $ defaultRf ) ) ) { $ tattooCounter ++ ; $ rfToAdd = ( ! empty ( $ explicitRf ) ) ? $ explicitRf : $ defaultRf ; $ this -> dataElementsMaster -> dataElementsIndiv [ ] = $ this -> createElement ( new ReceivedFrom ( [ 'receivedFrom' => $ rfToAdd ] ) , $ tattooCounter ) ; } }
5213	private function getBinding ( $ type , $ name = null ) { $ binding = $ this -> findBinding ( $ type , $ name ) ; if ( null === $ binding ) { throw new BindingException ( 'No binding for ' . $ type . ' defined' ) ; } return $ binding ; }
5752	public function getObjects ( array $ whereColumnsInfo = null ) : array { $ roles = [ ] ; if ( null !== $ records = $ this -> select ( "*" , $ whereColumnsInfo ) ) { foreach ( $ records as $ record ) { $ roles [ ] = $ this -> buildRole ( ( int ) $ record [ 'id' ] , $ record [ 'role' ] , new \ DateTimeImmutable ( $ record [ 'created' ] ) ) ; } } return $ roles ; }
9217	protected function parsePageLinks ( $ headers = false ) { $ pagination = [ ] ; if ( ! $ headers ) { $ headers = $ this -> api -> lastHeader ( 'link' ) ; } if ( preg_match_all ( '%<([^>]*)>\s*;\s*rel="([^"]+)"%' , $ headers , $ links , PREG_SET_ORDER ) ) { foreach ( $ links as $ link ) { $ pagination [ $ link [ 2 ] ] = new CanvasPageLink ( $ link [ 1 ] , $ link [ 2 ] ) ; } } return $ pagination ; }
7481	public function setContent ( $ content ) { Argument :: i ( ) -> test ( 1 , 'string' ) ; try { $ this -> absolute ( ) ; } catch ( \ Eden \ Path \ Exception $ e ) { $ this -> touch ( ) ; } file_put_contents ( $ this -> data , $ content ) ; return $ this ; }
9862	private function writeSheetFormatPr ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'sheetFormatPr' ) ; if ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , 'true' ) ; $ objWriter -> writeAttribute ( 'defaultRowHeight' , StringHelper :: formatNumber ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) ) ) ; } else { $ objWriter -> writeAttribute ( 'defaultRowHeight' , '14.4' ) ; } if ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) == '1' || strtolower ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) ) == 'true' ) { $ objWriter -> writeAttribute ( 'zeroHeight' , '1' ) ; } if ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'defaultColWidth' , StringHelper :: formatNumber ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) ) ) ; } $ outlineLevelRow = 0 ; foreach ( $ pSheet -> getRowDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelRow ) { $ outlineLevelRow = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelRow' , ( int ) $ outlineLevelRow ) ; $ outlineLevelCol = 0 ; foreach ( $ pSheet -> getColumnDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelCol ) { $ outlineLevelCol = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelCol' , ( int ) $ outlineLevelCol ) ; $ objWriter -> endElement ( ) ; }
12029	function generateParamFilterBlock ( \ ArtaxServiceBuilder \ Parameter $ parameter ) { $ i1 = ' ' ; $ i2 = ' ' ; $ text = '' ; $ text .= sprintf ( $ i1 . "case ('%s'): {" . PHP_EOL , $ parameter -> getName ( ) ) ; foreach ( $ parameter -> getFilters ( ) as $ filter ) { if ( is_array ( $ filter ) ) { $ text .= $ i2 . '$args = [];' . PHP_EOL ; if ( isset ( $ filter [ 'args' ] ) == true ) { if ( is_array ( $ filter [ 'args' ] ) == false ) { throw new \ ArtaxServiceBuilder \ APIBuilderException ( "Filter args should be an array instead received " . var_export ( $ filter [ 'args' ] , true ) ) ; } foreach ( $ filter [ 'args' ] as $ data ) { if ( $ data == '@value' ) { $ text .= $ i2 . '$args[] = $value;' . PHP_EOL ; } elseif ( $ data == '@api' ) { $ text .= $ i2 . "\$args[] = \$this->\$api;" . PHP_EOL ; } else { $ text .= $ i2 . "\$args[] = $data;" . PHP_EOL ; } } } $ text .= sprintf ( $ i2 . '$value = call_user_func_array([$value, \'%s\'], $args);' . PHP_EOL , $ filter [ 'method' ] ) ; } else { $ text .= sprintf ( $ i2 . 'call_user_func(\'%s\', $value);' . PHP_EOL , $ filter ) ; } } $ text .= $ i1 . ' break;' . PHP_EOL ; $ text .= $ i1 . '}' . PHP_EOL ; return $ text ; }
12753	public function sendRecoveryMessage ( User $ user , Token $ token ) { return $ this -> sendMessage ( $ user -> email , $ this -> recoverySubject , 'recovery' , [ 'user' => $ user , 'token' => $ token ] ) ; }
7138	protected function getConstraintsForStep ( $ step ) { $ constraints = [ new Valid ( ) ] ; if ( $ step === static :: SHIPMENT_STEP ) { $ constraints [ ] = new Constraints \ SaleShipmentStep ( ) ; } if ( $ step === static :: PAYMENT_STEP ) { $ constraints [ ] = new Constraints \ SaleShipmentStep ( ) ; $ constraints [ ] = new Constraints \ RelayPoint ( ) ; $ constraints [ ] = new Constraints \ SalePaymentStep ( ) ; } return $ constraints ; }
12228	public function removeSelf ( ) { $ tmp = dom_import_simplexml ( $ this ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { throw new BadMethodCallException ( 'removeSelf() cannot be used to remove the root node' ) ; } $ node = $ tmp -> parentNode -> removeChild ( $ tmp ) ; return simplexml_import_dom ( $ node , get_class ( $ this ) ) ; }
5289	protected static function requestStream ( $ url , $ params ) { $ opts = array ( 'http' => array ( 'method' => 'POST' , 'header' => implode ( "\n" , self :: getHeaders ( ) ) , 'content' => json_encode ( $ params ) , 'timeout' => self :: $ requestTimeout , 'ignore_errors' => true , ) ) ; $ context = stream_context_create ( $ opts ) ; return file_get_contents ( $ url , false , $ context ) ; }
1442	protected function replaceRecord ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'DummyRecord' , Str :: classify ( str_singular ( $ resource ) ) , $ stub ) ; return $ this ; }
1269	public function getSubscription ( $ name = null , $ beginDateTime = null , $ endDateTime = null , $ fileName = null , $ bookmark = null ) { if ( null !== $ beginDateTime ) { $ beginDateTime = $ this -> formatDateTime ( $ beginDateTime ) ; } if ( null !== $ endDateTime ) { $ endDateTime = $ this -> formatDateTime ( $ endDateTime ) ; } if ( null !== $ beginDateTime && null === $ endDateTime ) { $ endDateTime = $ this -> formatDateTime ( time ( ) ) ; } $ this -> name = $ name ; $ this -> beginDateTime = $ beginDateTime ; $ this -> endDateTime = $ endDateTime ; $ this -> fileName = $ fileName ; $ this -> bookmark = $ bookmark ; $ access = $ this -> createAccess ( ) ; $ request = $ this -> createRequest ( ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ access , $ request , $ this -> compileEndpointUrl ( self :: ENDPOINT ) ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { if ( isset ( $ response -> Bookmark ) ) { $ this -> setBookmark ( ( string ) $ response -> Bookmark ) ; } else { $ this -> setBookmark ( null ) ; } return $ this -> formatResponse ( $ response ) ; } }
4888	public function gotoAction ( Request $ r ) { return $ this -> redirect ( $ this -> get ( 'zicht_url.provider' ) -> url ( $ this -> getPageManager ( ) -> findForView ( $ r -> get ( 'id' ) ) ) ) ; }
3590	public function allowsMeta ( $ key ) { $ allowed = $ this -> getAllowedMeta ( ) ; return empty ( $ allowed ) || in_array ( $ key , $ allowed ) ; }
5457	protected function addContentTagToOpenTags ( & $ tag ) { if ( $ tag -> getTagName ( ) != 'option' ) { return ; } foreach ( array_keys ( $ this -> tags ) as $ name ) { for ( $ i = 0 , $ count = count ( $ this -> tags [ $ name ] ) ; $ i < $ count ; $ i ++ ) { $ this -> tags [ $ name ] [ $ i ] -> addTag ( $ tag ) ; } } }
5363	public function generate ( Registry $ registry ) { $ context = $ this -> createContext ( $ registry , 'Client' ) ; $ files = [ ] ; foreach ( $ registry -> getSchemas ( ) as $ schema ) { $ context -> setCurrentSchema ( $ schema ) ; $ files = array_merge ( $ files , $ this -> modelGenerator -> generate ( $ schema , $ schema -> getRootName ( ) , $ context ) ) ; $ files = array_merge ( $ files , $ this -> normalizerGenerator -> generate ( $ schema , $ schema -> getRootName ( ) , $ context ) ) ; $ clients = $ this -> clientGenerator -> generate ( $ schema -> getParsed ( ) , $ schema -> getNamespace ( ) , $ context , $ schema -> getOrigin ( ) . '#' ) ; foreach ( $ clients as $ node ) { $ files [ ] = new File ( $ schema -> getDirectory ( ) . DIRECTORY_SEPARATOR . 'Resource' . DIRECTORY_SEPARATOR . $ node -> stmts [ 2 ] -> name . '.php' , $ node , '' ) ; } } return $ files ; }
7596	protected function renderHelpBlock ( ElementInterface $ oElement ) { if ( $ sHelpBlock = $ oElement -> getOption ( 'help-block' ) ) { if ( $ oTranslator = $ this -> getTranslator ( ) ) { $ sHelpBlock = $ oTranslator -> translate ( $ sHelpBlock , $ this -> getTranslatorTextDomain ( ) ) ; } $ sHelpBlockString = strip_tags ( $ sHelpBlock ) ; if ( $ sHelpBlock === $ sHelpBlockString ) { $ sHelpBlock = $ this -> getEscapeHtmlHelper ( ) -> __invoke ( $ sHelpBlock ) ; } return sprintf ( static :: $ helpBlockFormat , $ sHelpBlock ) ; } else { return '' ; } }
7660	function AddrFormat ( $ addr ) { if ( empty ( $ addr [ 1 ] ) ) $ formatted = $ addr [ 0 ] ; else { $ formatted = $ this -> EncodeHeader ( $ addr [ 1 ] , 'phrase' ) . " <" . $ addr [ 0 ] . ">" ; } return $ formatted ; }
2195	protected function resendActivationMail ( MemberModel $ objMember ) { if ( $ objMember -> disable == '' ) { return ; } $ this -> strTemplate = 'mod_message' ; $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = null ; $ models = OptInModel :: findByRelatedTableAndIds ( 'tl_member' , array ( $ objMember -> id ) ) ; foreach ( $ models as $ model ) { if ( ( $ token = $ optIn -> find ( $ model -> token ) ) && $ token -> isValid ( ) && ! $ token -> isConfirmed ( ) ) { $ optInToken = $ token ; break ; } } if ( $ optInToken === null ) { return ; } $ optInToken -> send ( ) ; $ this -> Template -> type = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resendActivation' ] ; }
6610	public static function getByCreatedDateRange ( $ startDate , $ endDate , $ createdAtColumn = 'created_at' ) { $ model = get_called_class ( ) ; $ model = new $ model ; return self :: find ( ) -> andWhere ( $ model :: tableName ( ) . '.' . $ createdAtColumn . ' BETWEEN :start_date AND :end_date' , [ 'start_date' => $ startDate , 'end_date' => $ endDate ] ) ; }
8440	public function createAction ( string $ production_slug , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_USER' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; $ post = new Post ( ) ; $ post -> setActive ( true ) ; $ post -> setPinned ( false ) ; $ post -> setAuthor ( $ user -> getUsername ( ) ) ; $ post -> addGroup ( $ production ) ; if ( $ request -> query -> has ( 'reply-to' ) ) { $ repo = $ this -> em -> getRepository ( Post :: class ) ; if ( null === $ parent = $ repo -> findOneBy ( [ 'id' => $ request -> query -> get ( 'reply-to' ) ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ parent -> getGroups ( ) -> contains ( $ production ) ) { throw new AccessDeniedException ( ) ; } if ( null !== $ parent -> getParent ( ) ) { throw new AccessDeniedException ( ) ; } $ post -> setParent ( $ parent ) ; $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> persist ( $ post ) ; $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.created' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/create.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
8882	private function isValidGlobalCommand ( string $ command ) : bool { $ valid = false ; if ( strlen ( $ command ) ) { foreach ( $ this -> paths as $ pathDir ) { $ tmpPath = $ pathDir . DIRECTORY_SEPARATOR . $ command ; if ( $ this -> isValidFullPath ( $ tmpPath ) ) { $ valid = true ; break ; } } } return $ valid ; }
7056	protected static function dayOfYear ( $ y , $ m , $ d ) { $ l = ( ( int ) $ y % 4 == 0 && ( int ) $ y % 100 != 0 ) || ( int ) $ y % 400 == 0 ; $ k = $ l ? 1 : 2 ; $ n = intval ( 275 * ( int ) $ m / 9 ) - $ k * intval ( ( ( int ) $ m + 9 ) / 12 ) + ( int ) $ d - 30 ; return ( int ) $ n ; }
11759	public function deleteReply ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_REPLY , $ params ] ) ; }
10008	public function disconnectWorksheets ( ) { $ worksheet = null ; foreach ( $ this -> workSheetCollection as $ k => & $ worksheet ) { $ worksheet -> disconnectCells ( ) ; $ this -> workSheetCollection [ $ k ] = null ; } unset ( $ worksheet ) ; $ this -> workSheetCollection = [ ] ; }
1085	private function parseName ( ) { $ token = $ this -> expect ( Token :: NAME ) ; return new NameNode ( [ 'value' => $ token -> value , 'loc' => $ this -> loc ( $ token ) , ] ) ; }
12142	public static function provider ( ProviderInterface $ provider = null ) { if ( $ provider ) { static :: $ provider = $ provider ; } elseif ( ! static :: $ provider ) { static :: $ provider = new Provider \ Native ( static :: $ root ) ; } return static :: $ provider ; }
12587	public function init ( ) { parent :: init ( ) ; $ db = $ this -> getDbConnection ( ) ; $ db -> setActive ( true ) ; if ( $ this -> autoCreateTokenTable ) { $ sql = "DELETE FROM {$this->tokenTableName} WHERE (expires>0 AND expires<" . time ( ) . ") OR (uses_allowed>0 AND uses_remaining<1)" ; try { $ db -> createCommand ( $ sql ) -> execute ( ) ; } catch ( Exception $ e ) { $ this -> createTokenTable ( $ db , $ this -> tokenTableName ) ; } } }
829	private function isStringPartToken ( Token $ token ) { return $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) || $ token -> isGivenKind ( T_START_HEREDOC ) || '"' === $ token -> getContent ( ) || 'b"' === strtolower ( $ token -> getContent ( ) ) ; }
8024	public function destroy ( ) { if ( ! is_resource ( $ this -> semaphore ) ) { throw new SemaphoreException ( 'Semaphore hasn\'t yet been created.' ) ; } if ( ! sem_remove ( $ this -> semaphore ) ) { throw new SemaphoreException ( 'Cannot remove the semaphore.' ) ; } $ this -> semaphore = NULL ; $ this -> semKey = NULL ; return $ this ; }
10991	public function getName ( bool $ includeExtension = false ) : string { $ filename = basename ( $ this -> path ) ; if ( $ includeExtension ) { return $ filename ; } return $ this -> splitName ( ) [ 0 ] ; }
5251	public function delete ( ) { if ( $ this -> deleting ( ) === false ) { return false ; } $ this -> _dal -> delete ( ) ; $ this -> _exist = false ; $ cache = self :: cache ( ) ; $ cache -> forget ( $ this -> getId ( ) ) ; if ( $ this -> deleted ( ) === false ) { return false ; } return true ; }
9543	public function getMessages ( ) { $ messages = array ( ) ; if ( ! empty ( $ this -> error ) ) { $ messages [ ] = $ this -> error ; } if ( ! empty ( $ this -> warning ) ) { $ messages [ ] = $ this -> warning ; } return $ messages ; }
10184	function createContactFilter ( $ newFilterObject , $ createTargetGroup , $ version = 1.0 ) { if ( $ version == 1.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> put ( "contactfilters/contactfilter" , $ newFilterObject -> toXMLString ( ) , $ queryParameters ) ; } else if ( $ version == 2.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> post ( "contactfilters/v2" , $ newFilterObject , $ queryParameters , "application/json" ) ; } }
4401	protected function translateStatus ( $ status ) { if ( ! interface_exists ( '\Omnipay\Common\Message\NotificationInterface' ) ) { return \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_REFUSED ; } switch ( $ status ) { case \ Omnipay \ Common \ Message \ NotificationInterface :: STATUS_COMPLETED : return \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ; case \ Omnipay \ Common \ Message \ NotificationInterface :: STATUS_PENDING : return \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_PENDING ; case \ Omnipay \ Common \ Message \ NotificationInterface :: STATUS_FAILED : return \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_REFUSED ; } }
8174	protected function checkLoopUsageCondition ( Twig_TokenStream $ stream , Twig_NodeInterface $ node ) { if ( $ node instanceof Twig_Node_Expression_GetAttr && $ node -> getNode ( 'node' ) instanceof Twig_Node_Expression_Name && 'loop' == $ node -> getNode ( 'node' ) -> getAttribute ( 'name' ) ) { throw new Twig_Error_Syntax ( 'The "loop" variable cannot be used in a looping condition.' , $ node -> getTemplateLine ( ) , $ stream -> getSourceContext ( ) ) ; } foreach ( $ node as $ n ) { if ( ! $ n ) { continue ; } $ this -> checkLoopUsageCondition ( $ stream , $ n ) ; } }
4974	private function hydrateTree ( NodeInterface $ object , \ ArrayObject $ currentData = null ) { if ( null === $ currentData ) { $ currentData = $ this -> hydrateData [ '__root__' ] ; } if ( 'set' == $ currentData [ 'do' ] ) { $ object -> setName ( $ currentData [ 'name' ] ) -> setValue ( $ currentData [ 'value' ] ) -> setPriority ( $ currentData [ 'priority' ] ) ; } if ( isset ( $ this -> hydrateData [ $ currentData [ 'current' ] ] ) ) { foreach ( $ this -> hydrateData [ $ currentData [ 'current' ] ] as $ childData ) { $ child = $ this -> findOrCreateChild ( $ object , $ childData [ 'id' ] ) ; if ( 'remove' == $ childData [ 'do' ] ) { $ object -> removeChild ( $ child ) ; } else { $ this -> hydrateTree ( $ child , $ childData ) ; } } } return $ object ; }
3531	public static function sendFortniteGetRequest ( $ endpoint , $ access_token , $ extra_headers = array ( ) ) { $ client = new Client ( ) ; $ headers = [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ; $ headers = array_merge ( $ headers , $ extra_headers ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => $ headers ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
6604	public function makeAccessToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateAccessTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'user_id' ] = $ params [ 'user_id' ] ; $ this -> credentials [ 'screen_name' ] = $ params [ 'screen_name' ] ; return $ this ; }
3840	private function parsePanelRow ( $ fields , PanelRowInterface $ panelRow ) { foreach ( $ fields as $ field ) { switch ( $ field ) { case 'sort' : $ this -> parsePanelSort ( $ panelRow ) ; break ; case 'limit' : $ this -> parsePanelLimit ( $ panelRow ) ; break ; case 'filter' : $ this -> parsePanelFilter ( $ panelRow ) ; break ; case 'search' : $ this -> parsePanelSearch ( $ panelRow ) ; break ; case 'submit' : $ this -> parsePanelSubmit ( $ panelRow ) ; break ; default : break ; } } }
12400	public function first ( ) { $ this -> scope -> limit = 1 ; $ this -> scope -> offset = 0 ; return $ this -> get ( null ) ; }
10078	public static function convertEncoding ( $ value , $ to , $ from ) { if ( self :: getIsIconvEnabled ( ) ) { $ result = iconv ( $ from , $ to . '//IGNORE//TRANSLIT' , $ value ) ; if ( false !== $ result ) { return $ result ; } } return mb_convert_encoding ( $ value , $ to , $ from ) ; }
1751	public static function getReferer ( $ blnEncodeAmpersands = false , $ strTable = null ) { $ objSession = static :: getContainer ( ) -> get ( 'session' ) ; $ ref = Input :: get ( 'ref' ) ; $ key = Input :: get ( 'popup' ) ? 'popupReferer' : 'referer' ; $ session = $ objSession -> get ( $ key ) ; if ( $ ref && isset ( $ session [ $ ref ] ) ) { $ session = $ session [ $ ref ] ; } elseif ( \ defined ( 'TL_MODE' ) && TL_MODE == 'BE' && \ is_array ( $ session ) ) { $ session = end ( $ session ) ; } if ( $ strTable != '' && isset ( $ session [ $ strTable ] ) && Input :: get ( 'act' ) != 'select' ) { $ session [ 'current' ] = $ session [ $ strTable ] ; } $ cleanUrl = function ( $ url , $ params = array ( 'rt' , 'ref' ) ) { if ( $ url == '' || strpos ( $ url , '?' ) === false ) { return $ url ; } list ( $ path , $ query ) = explode ( '?' , $ url , 2 ) ; $ queryObj = new Query ( $ query ) ; $ queryObj = $ queryObj -> withoutPairs ( $ params ) ; return $ path . $ queryObj -> getUriComponent ( ) ; } ; $ strUrl = ( $ cleanUrl ( $ session [ 'current' ] ) != $ cleanUrl ( Environment :: get ( 'request' ) ) ) ? $ session [ 'current' ] : $ session [ 'last' ] ; $ return = $ cleanUrl ( $ strUrl , array ( 'tg' , 'ptg' ) ) ; if ( $ return == '' && \ defined ( 'TL_MODE' ) && TL_MODE == 'FE' ) { $ return = Environment :: get ( 'httpReferer' ) ; } if ( $ return == '' ) { $ return = ( \ defined ( 'TL_MODE' ) && TL_MODE == 'BE' ) ? 'contao/main.php' : Environment :: get ( 'url' ) ; } return preg_replace ( '/&(amp;)?/i' , ( $ blnEncodeAmpersands ? '&amp;' : '&' ) , $ return ) ; }
6236	public static function try ( array $ paths ) : Storage { foreach ( $ paths as $ diskpath ) { if ( is_string ( $ diskpath ) ) { if ( file_exists ( $ diskpath ) ) { return new Storage \ Disk ( $ diskpath ) ; } } elseif ( $ diskpath instanceof Path ) { if ( $ diskpath -> fileInfo ( ) -> isFile ( ) || $ diskpath -> fileInfo ( ) -> isDir ( ) ) { return new Storage \ Disk ( $ diskpath ) ; } } elseif ( $ diskpath instanceof Storage ) { if ( $ diskpath -> isFile ( ) || $ diskpath -> isDir ( ) ) { return $ diskpath ; } } elseif ( $ diskpath instanceof FileSystem ) { if ( $ diskpath -> isFile ( ) || $ diskpath -> isDir ( ) ) { return $ diskpath -> storage ( ) ; } } else { throw new UnexpectedValueException ( sprintf ( 'invalid search-path of type \'%s\'' , is_object ( $ diskpath ) ? get_class ( $ diskpath ) : gettype ( $ diskpath ) ) , 500 ) ; } } throw new FileNotFoundException ( 'file not found' , 404 ) ; }
8236	protected function checkServerConfiguration ( ) { $ pico = $ this -> picoAuth -> getPico ( ) ; $ configDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfigDir ( ) ) ; $ configFile = $ configDir . "/config.yml" ; $ contentDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfig ( 'content_dir' ) ) ; $ indexFile = $ contentDir . "/index" . $ pico -> getConfig ( 'content_ext' ) ; $ urls = array ( 'dir_listing' => $ configDir , 'config_file' => $ configFile , 'content_file' => $ indexFile ) ; $ this -> httpsTest ( ) ; $ this -> webRootDirsTest ( ) ; $ this -> picoAuth -> addOutput ( "installer_urltest" , $ urls ) ; }
4121	public function getProxy ( $ className , $ identifier ) { $ fqn = ClassUtils :: generateProxyClassName ( $ className , $ this -> proxyNamespace ) ; if ( ! class_exists ( $ fqn , false ) ) { $ fileName = $ this -> getProxyFileName ( $ className ) ; if ( $ this -> autoGenerate ) { $ this -> generateProxyClass ( $ this -> dm -> getClassMetadata ( $ className ) , $ fileName , self :: $ proxyClassTemplate ) ; } require $ fileName ; } if ( ! $ this -> dm -> getMetadataFactory ( ) -> hasMetadataFor ( $ fqn ) ) { $ this -> dm -> getMetadataFactory ( ) -> setMetadataFor ( $ fqn , $ this -> dm -> getClassMetadata ( $ className ) ) ; } return new $ fqn ( $ this -> dm , $ identifier ) ; }
3463	public function handle ( ServerRequestInterface $ request ) : ResponseInterface { $ response = $ this -> getMiddlewarePipe ( ) -> handle ( $ request ) ; return $ response ; }
12274	public static function createFromFormat ( $ format , $ time , $ object = null ) { if ( empty ( $ object ) ) { $ object = new DateTimeZone ( 'America/Sao_Paulo' ) ; } return self :: cast ( parent :: createFromFormat ( $ format , $ time , $ object ) ) ; }
8653	private function convertUpdateReportAcknowledgements ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'UpdateReportAcknowledgements' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportIdList ( ) ) { $ reportIdList = $ request -> getReportIdList ( ) ; foreach ( $ reportIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
9341	public function set ( $ key , $ value , $ fromFile = false ) { $ keys = array_filter ( explode ( '.' , $ key ) ) ; $ value = ( $ fromFile ) ? require $ value : $ value ; $ this -> save ( $ keys , $ this -> data , $ value ) ; return $ this ; }
1365	protected function bootMiddleware ( Router $ router ) { $ router -> aliasMiddleware ( 'json-api' , BootJsonApi :: class ) ; $ router -> aliasMiddleware ( 'json-api.content' , NegotiateContent :: class ) ; $ router -> aliasMiddleware ( 'json-api.auth' , Authorize :: class ) ; }
7124	protected function getMessageFromEvent ( ResourceEventInterface $ event ) { $ message = $ event -> getResource ( ) ; if ( ! $ message instanceof TicketMessageInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketMessageInterface :: class ) ; } return $ message ; }
2631	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ read -> getRelativePath ( 'vcl_snippets_custom' ) ; $ customSnippets = $ read -> read ( $ snippetPath ) ; if ( ! $ customSnippets ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'No snippets found.' ] ) ; } $ snippets = [ ] ; foreach ( $ customSnippets as $ snippet ) { $ snippets [ ] = explode ( '/' , $ snippet ) [ 1 ] ; } return $ result -> setData ( [ 'status' => true , 'snippets' => $ snippets ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1801	protected function switchToEdit ( $ id ) { $ arrKeys = array ( ) ; $ arrUnset = array ( 'act' , 'id' , 'table' ) ; foreach ( array_keys ( $ _GET ) as $ strKey ) { if ( ! \ in_array ( $ strKey , $ arrUnset ) ) { $ arrKeys [ $ strKey ] = $ strKey . '=' . Input :: get ( $ strKey ) ; } } $ strUrl = TL_SCRIPT . '?' . implode ( '&' , $ arrKeys ) ; return $ strUrl . ( ! empty ( $ arrKeys ) ? '&' : '' ) . ( Input :: get ( 'table' ) ? 'table=' . Input :: get ( 'table' ) . '&amp;' : '' ) . 'act=edit&amp;id=' . rawurlencode ( $ id ) ; }
7804	protected function balance ( BalanceInterface $ balance , $ text ) { if ( ! preg_match ( '/(C|D)(\d{6})([A-Z]{3})([0-9,]{1,15})/' , $ text , $ match ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot parse balance: "%s"' , $ text ) ) ; } $ amount = ( float ) str_replace ( ',' , '.' , $ match [ 4 ] ) ; if ( $ match [ 1 ] === 'D' ) { $ amount *= - 1 ; } $ date = \ DateTime :: createFromFormat ( 'ymd' , $ match [ 2 ] ) ; $ date -> setTime ( 0 , 0 , 0 ) ; $ balance -> setCurrency ( $ match [ 3 ] ) -> setAmount ( $ amount ) -> setDate ( $ date ) ; return $ balance ; }
2468	public function getOptions ( ) : array { $ options = [ ] ; foreach ( self :: DEFAULT_OPTIONS as $ option => $ label ) { $ options [ $ option ] = $ this -> translator -> trans ( 'MSC.validCharacters.' . $ label , [ ] , 'contao_default' ) ; } $ event = new SlugValidCharactersEvent ( $ options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: SLUG_VALID_CHARACTERS , $ event ) ; return $ event -> getOptions ( ) ; }
6745	private function applyResponseEncoding ( Request $ request , Response $ response ) { $ allowedCompressionAsString = $ request -> headers -> get ( 'Accept-Encoding' ) ; if ( ! $ allowedCompressionAsString ) { return ; } $ allowedCompression = explode ( ',' , $ allowedCompressionAsString ) ; $ allowedCompression = array_map ( 'trim' , $ allowedCompression ) ; if ( in_array ( 'gzip' , $ allowedCompression ) ) { $ response -> setContent ( gzencode ( $ response -> getContent ( ) ) ) ; $ response -> headers -> set ( 'Content-Encoding' , 'gzip' ) ; return ; } if ( in_array ( 'deflate' , $ allowedCompression ) ) { $ response -> setContent ( gzdeflate ( $ response -> getContent ( ) ) ) ; $ response -> headers -> set ( 'Content-Encoding' , 'deflate' ) ; return ; } }
4005	protected function createInstanceViaLegacyFactory ( CreateMetaModelEvent $ event , $ arrData ) { $ name = $ arrData [ 'tableName' ] ; if ( ! isset ( $ GLOBALS [ 'METAMODELS' ] [ 'factories' ] [ $ name ] ) ) { return false ; } @ trigger_error ( 'Creating MetaModel instances via global factories is deprecated.' , E_USER_DEPRECATED ) ; $ factoryClass = $ GLOBALS [ 'METAMODELS' ] [ 'factories' ] [ $ name ] ; $ event -> setMetaModel ( call_user_func_array ( array ( $ factoryClass , 'createInstance' ) , array ( $ arrData ) ) ) ; return $ event -> getMetaModel ( ) !== null ; }
2125	protected function getDebugMarkup ( ) { $ return = $ this -> getFileUrls ( ) ; foreach ( $ return as $ k => $ v ) { $ options = StringUtil :: resolveFlaggedUrl ( $ v ) ; $ return [ $ k ] = $ v ; if ( $ options -> mtime ) { $ return [ $ k ] .= '?v=' . substr ( md5 ( $ options -> mtime ) , 0 , 8 ) ; } if ( $ options -> media ) { $ return [ $ k ] .= '" media="' . $ options -> media ; } } if ( $ this -> strMode == self :: JS ) { return implode ( '"></script><script src="' , $ return ) ; } return implode ( '"><link rel="stylesheet" href="' , $ return ) ; }
561	public static function autoload ( $ className ) { if ( isset ( static :: $ classMap [ $ className ] ) ) { $ classFile = static :: $ classMap [ $ className ] ; if ( $ classFile [ 0 ] === '@' ) { $ classFile = static :: getAlias ( $ classFile ) ; } } elseif ( strpos ( $ className , '\\' ) !== false ) { $ classFile = static :: getAlias ( '@' . str_replace ( '\\' , '/' , $ className ) . '.php' , false ) ; if ( $ classFile === false || ! is_file ( $ classFile ) ) { return ; } } else { return ; } include $ classFile ; if ( YII_DEBUG && ! class_exists ( $ className , false ) && ! interface_exists ( $ className , false ) && ! trait_exists ( $ className , false ) ) { throw new UnknownClassException ( "Unable to find '$className' in file: $classFile. Namespace missing?" ) ; } }
7100	private function equalComparison ( UnitCandidate $ a , UnitCandidate $ b , $ property , $ quantity ) { if ( $ a -> { $ property } == $ quantity && $ b -> { $ property } != $ quantity ) { return - 1 ; } if ( $ a -> { $ property } != $ quantity && $ b -> { $ property } == $ quantity ) { return 1 ; } return false ; }
3562	protected function hasMutator ( $ value , $ dir = 'setter' , $ type = null ) { return ( bool ) $ this -> getMutator ( $ value , $ dir , $ type ) ; }
5884	protected function _normalizeConfig ( $ orders ) { if ( empty ( $ orders ) ) { $ orders = [ [ ] ] ; } elseif ( isset ( $ orders [ 'order' ] ) || isset ( $ orders [ 'callback' ] ) ) { $ orders = [ $ orders ] ; } $ default = [ 'order' => $ this -> _table -> aliasField ( $ this -> _table -> getDisplayField ( ) ) , 'callback' => null , ] ; foreach ( $ orders as $ key => $ value ) { $ orders [ $ key ] = $ orders [ $ key ] + $ default ; } $ this -> _config = [ 'orders' => $ orders , ] ; }
9532	private function preloadAliases ( ) { foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { foreach ( $ this -> parameterCluster -> prefixes [ $ prefix ] as $ parameterClosure ) { foreach ( $ parameterClosure -> aliases as $ prefix => $ alias ) { $ aliasClosure = new ParameterClosure ( $ prefix , $ alias , $ parameterClosure -> parameterClosure ) ; $ aliasClosure -> parent = $ parameterClosure ; $ this -> parameterCluster -> add ( $ aliasClosure ) ; } } } }
5789	protected function setRules ( bool $ skipUniqueForUnchanged = false , array $ record = null ) { $ this -> mapFieldsRules ( $ this -> databaseTableValidation -> getValidationRules ( ) ) ; $ uniqueColumns = $ this -> mapper -> getUniqueColumns ( ) ; if ( count ( $ uniqueColumns ) > 0 ) { $ this -> addUniqueRule ( ) ; foreach ( $ uniqueColumns as $ databaseColumnMapper ) { $ field = $ databaseColumnMapper -> getName ( ) ; if ( ! ( $ skipUniqueForUnchanged && $ this -> inputData [ $ field ] == $ record [ $ field ] ) ) { $ this -> rule ( 'unique' , $ field , $ databaseColumnMapper , $ this ) ; } } } }
5224	protected function getProviderCreator ( $ provider ) { if ( is_string ( $ provider ) ) { return function ( $ injector , $ name , $ key ) use ( $ provider ) { $ providerInstance = $ injector -> getInstance ( $ provider ) ; if ( ! ( $ providerInstance instanceof InjectionProvider ) ) { throw new BindingException ( 'Configured provider class ' . $ provider . ' for ' . $ name . '[' . $ key . '] is not an instance of stubbles\ioc\InjectionProvider.' ) ; } return $ providerInstance -> get ( ) ; } ; } elseif ( $ provider instanceof InjectionProvider ) { return function ( ) use ( $ provider ) { return $ provider -> get ( ) ; } ; } throw new \ InvalidArgumentException ( 'Given provider must either be a instance of' . ' stubbles\ioc\InjectionProvider or a class name representing' . ' such a provider instance.' ) ; }
1033	private function getPromise ( $ value ) { if ( $ value === null || $ value instanceof Promise ) { return $ value ; } if ( $ this -> exeContext -> promises -> isThenable ( $ value ) ) { $ promise = $ this -> exeContext -> promises -> convertThenable ( $ value ) ; if ( ! $ promise instanceof Promise ) { throw new InvariantViolation ( sprintf ( '%s::convertThenable is expected to return instance of GraphQL\Executor\Promise\Promise, got: %s' , get_class ( $ this -> exeContext -> promises ) , Utils :: printSafe ( $ promise ) ) ) ; } return $ promise ; } return null ; }
1820	public function extractVimeoId ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> vimeo != $ varValue ) { $ matches = array ( ) ; if ( preg_match ( '%vimeo\.com/(?:channels/(?:\w+/)?|groups/(?:[^/]+)/videos/|album/(?:\d+)/video/)?(\d+)(?:$|/|\?)%i' , $ varValue , $ matches ) ) { $ varValue = $ matches [ 1 ] ; } } return $ varValue ; }
7729	public function quickReplie ( $ text , $ title , $ postback , $ image = null ) { $ this -> setText ( $ text ) ; $ payload = [ 'title' => $ title , 'payload' => $ postback , ] ; if ( ! empty ( $ image ) ) { $ payload [ 'image' ] = $ image ; } $ this -> setQuickReplies ( $ payload ) ; return $ this ; }
11701	public function get ( $ component ) { $ parts = explode ( '.' , $ component ) ; if ( count ( $ parts ) == 1 ) { return $ this -> getService ( $ parts [ 0 ] ) ; } elseif ( count ( $ parts ) == 2 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) ; } elseif ( count ( $ parts ) == 3 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) -> getAction ( $ parts [ 2 ] ) ; } throw new \ LogicException ( 'Malformed component path. Please use a dot-notated path (e.g. service.group.action)' ) ; }
10564	public function variant ( array $ attrs ) { return new self ( $ this -> id , $ attrs , null , $ this -> info -> all ( ) ) ; }
532	protected function resortChangelog ( $ changelog ) { foreach ( $ changelog as $ i => $ line ) { $ changelog [ $ i ] = rtrim ( $ line ) ; } $ changelog = array_filter ( $ changelog ) ; $ i = 0 ; ArrayHelper :: multisort ( $ changelog , function ( $ line ) use ( & $ i ) { if ( preg_match ( '/^- (Chg|Enh|Bug|New)( #\d+(, #\d+)*)?: .+/' , $ line , $ m ) ) { $ o = [ 'Bug' => 'C' , 'Enh' => 'D' , 'Chg' => 'E' , 'New' => 'F' ] ; return $ o [ $ m [ 1 ] ] . ' ' . ( ! empty ( $ m [ 2 ] ) ? $ m [ 2 ] : 'AAAA' . $ i ++ ) ; } return 'B' . $ i ++ ; } , SORT_ASC , SORT_NATURAL ) ; array_unshift ( $ changelog , '' ) ; $ changelog [ ] = '' ; $ changelog [ ] = '' ; return $ changelog ; }
3217	function chunkedUploadContinue ( $ uploadId , $ byteOffset , $ data ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Checker :: argNat ( "byteOffset" , $ byteOffset ) ; Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( "upload_id" => $ uploadId , "offset" => $ byteOffset ) , $ data ) ; if ( $ response -> statusCode === 404 ) { return false ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) { list ( $ correctedUploadId , $ correctedByteOffset ) = $ correction ; if ( $ correctedUploadId !== $ uploadId ) throw new Exception_BadResponse ( "Corrective 400 upload_id mismatch: us=" . Util :: q ( $ uploadId ) . " server=" . Util :: q ( $ correctedUploadId ) ) ; if ( $ correctedByteOffset === $ byteOffset ) throw new Exception_BadResponse ( "Corrective 400 offset is the same as ours: $byteOffset" ) ; return $ correctedByteOffset ; } if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ retUploadId , $ retByteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ nextByteOffset = $ byteOffset + strlen ( $ data ) ; if ( $ uploadId !== $ retUploadId ) throw new Exception_BadResponse ( "upload_id mismatch: us=" . Util :: q ( $ uploadId ) . ", server=" . Util :: q ( $ uploadId ) ) ; if ( $ nextByteOffset !== $ retByteOffset ) throw new Exception_BadResponse ( "next-offset mismatch: us=$nextByteOffset, server=$retByteOffset" ) ; return true ; }
5164	public function send ( EmailSender $ email , array $ data = [ ] ) { $ result = ( new DataBuilderManager ( ) ) -> validateRaw ( $ email -> data_builder , $ data ) ; dispatch ( new SendEmail ( $ email , $ data , $ this -> getAgent ( ) ) ) ; return $ result ; }
12169	private function createPropertyValuesTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?property_values`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?property_values` ( `value_id` mediumint(11) NOT NULL AUTO_INCREMENT, `value_data` text NOT NULL, `value_updated_on` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `property_id` int(11) NOT NULL, `object_id` int(11) NOT NULL, PRIMARY KEY (`value_id`), UNIQUE KEY `object_property_uid` (`object_id`,`property_id`), KEY `property_id_idxfk` (`property_id`), KEY `object_id_idxfk` (`object_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;" ) ; $ this -> database -> query ( "DROP PROCEDURE IF EXISTS `property_value_validate`;" ) ; $ this -> database -> query ( "CREATE PROCEDURE `?property_value_validate`(IN _property_id INT, IN _value_data LONGTEXT) BEGIN DECLARE _validationFails CONDITION FOR SQLSTATE '99001'; DECLARE _dataTypeRegExp VARCHAR(255); DECLARE _signalText TEXT; SELECT r.datatype_validation FROM `?properties` AS d INNER JOIN `?property_datatypes` AS r WHERE `property_id`= _property_id AND d.property_datatype=r.datatype_name INTO _dataTypeRegExp; IF (_dataTypeRegExp IS NOT NULL) THEN IF (_value_data NOT REGEXP(_dataTypeRegExp)) THEN SET _signalText = CONCAT('The inserted/updated value fails the property data type validation'); SIGNAL _validationFails SET MESSAGE_TEXT=_signalText; END IF; END IF; END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?property_value_validate_insert`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?property_value_validate_insert` BEFORE INSERT ON `?property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?property_value_validate_update`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?property_value_validate_update` BEFORE UPDATE ON `?property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; }
12515	public static function exists ( $ path ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; return $ fs -> exists ( $ path ) ; }
12021	private function generateParameterSetBlock ( $ indent , \ ArtaxServiceBuilder \ Parameter $ operationParameter ) { switch ( $ operationParameter -> getLocation ( ) ) { case 'absoluteURL' : { return $ indent . '$url = $value;' . PHP_EOL ; break ; } case 'postField' : { return sprintf ( $ indent . '$formBody->addField(\'%s\', $value);' . PHP_EOL , $ operationParameter -> getSentAs ( ) ) ; } case 'postFile' : { return sprintf ( $ indent . '$formBody->addFileField(\'%s\', $value);' . PHP_EOL , $ operationParameter -> getSentAs ( ) ) ; break ; } case 'json' : { return sprintf ( $ indent . '$jsonParams[\'%s\'] = $value;' . PHP_EOL , $ operationParameter -> getSentAs ( ) ) ; } case ( 'header' ) : { return sprintf ( $ indent . '$request->setHeader(\'%s\', $value);' . PHP_EOL , $ operationParameter -> getSentAs ( ) , $ operationParameter -> getName ( ) ) ; } default : case 'query' : { return sprintf ( $ indent . '$queryParameters[\'%s\'] = $value;' . PHP_EOL , $ operationParameter -> getSentAs ( ) , $ operationParameter -> getName ( ) ) ; } } }
6755	private static function createCopy ( string $ from , string $ fromFilename , string $ to , string $ toFilename ) { if ( file_exists ( "$to/$toFilename" ) ) { unlink ( "$to/$toFilename" ) ; } copy ( realpath ( $ from ) . "/$fromFilename" , realpath ( $ to ) . "/$toFilename" ) ; echo '> * Copy origin - ' . realpath ( $ from ) . "/$toFilename" . PHP_EOL ; echo '> * Copy destination - ' . realpath ( $ to ) . "/$toFilename" . PHP_EOL ; }
9225	private function preprocessData ( $ data ) { if ( is_array ( $ data ) && ! array_key_exists ( self :: PARAM_PER_PAGE , $ data ) ) { $ data [ self :: PARAM_PER_PAGE ] = CanvasArray :: MAXIMUM_PER_PAGE ; } return $ data ; }
3361	private function exists ( $ offset = null ) { return isset ( $ this -> container [ $ offset !== null ? $ offset : $ this -> position ] ) ; }
12526	static public function cleanup ( $ opts = array ( ) ) { if ( strtoupper ( substr ( PHP_OS , 0 , 3 ) ) == 'WIN' ) { exec ( 'tasklist /FO CSV' , $ runningProcesses , $ return_var ) ; $ runningProcesses = array_map ( function ( $ line ) { $ cols = explode ( ',' , $ line ) ; return trim ( $ cols [ 1 ] , '"' ) ; } , $ runningProcesses ) ; unset ( $ runningProcesses [ 0 ] ) ; sort ( $ runningProcesses ) ; unset ( $ runningProcesses [ 0 ] ) ; } else { exec ( 'ps -e -o pid' , $ runningProcesses , $ return_var ) ; } if ( $ return_var != 0 ) { pake_echo_error ( "Could not get list of processes to remove stale lock files" ) ; return ; } $ lockDir = self :: lockDir ( $ opts ) ; foreach ( glob ( $ lockDir . "/*_W.lock" ) as $ writeLock ) { $ pid = file_get_contents ( $ writeLock ) ; if ( ! in_array ( $ pid , $ runningProcesses ) ) { pake_unlink ( $ writeLock ) ; } } foreach ( glob ( $ lockDir . "/*_R/*.lock" ) as $ readLock ) { $ pid = file_get_contents ( $ readLock ) ; if ( ! in_array ( $ pid , $ runningProcesses ) ) { pake_unlink ( $ readLock ) ; } } }
6060	public function retrieveFileData ( $ id , $ template = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'template' => $ template ] , 'body' => json_encode ( [ ] ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/asset' , $ parameters , $ cachePolicy ) ; return $ result ; }
11615	public function delete ( $ account ) { $ accessTokenField = sprintf ( '%s=%s' , $ this -> accessToken -> getQueryName ( ) , $ this -> accessToken -> getToken ( ) ) ; $ url = sprintf ( self :: API_DELETE . '?%s&kf_account=%s' , $ accessTokenField , $ account ) ; $ contents = $ this -> getHttp ( ) -> parseJSON ( file_get_contents ( $ url ) ) ; $ this -> checkAndThrow ( $ contents ) ; return new Collection ( $ contents ) ; }
7050	protected function buildDiscountsLines ( Document \ DocumentInterface $ document ) { $ sale = $ document -> getSale ( ) ; if ( ! $ sale -> hasAdjustments ( Common \ AdjustmentTypes :: TYPE_DISCOUNT ) ) { return ; } $ adjustments = $ sale -> getAdjustments ( ) ; foreach ( $ adjustments as $ adjustment ) { if ( $ adjustment -> getType ( ) === Common \ AdjustmentTypes :: TYPE_DISCOUNT ) { $ this -> buildDiscountLine ( $ adjustment , $ document ) ; } } }
1968	public static function findByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; if ( Validator :: isStringUuid ( $ intPid ) ) { $ intPid = StringUtil :: uuidToBin ( $ intPid ) ; } return static :: findBy ( array ( "$t.pid=UNHEX(?)" ) , bin2hex ( $ intPid ) , $ arrOptions ) ; }
4524	protected function createZoneFromDefinition ( array $ definition ) { $ zone = new Zone ( ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; $ this -> name = $ definition [ 'name' ] ; if ( isset ( $ definition [ 'scope' ] ) ) { $ this -> scope = $ definition [ 'scope' ] ; } if ( isset ( $ definition [ 'priority' ] ) ) { $ this -> priority = $ definition [ 'priority' ] ; } } , $ zone , '\CommerceGuys\Zone\Model\Zone' ) ; $ setValues ( $ definition ) ; foreach ( $ definition [ 'members' ] as $ memberDefinition ) { if ( $ memberDefinition [ 'type' ] == 'country' ) { $ zoneMember = $ this -> createZoneMemberCountryFromDefinition ( $ memberDefinition ) ; $ zone -> addMember ( $ zoneMember ) ; } elseif ( $ memberDefinition [ 'type' ] == 'zone' ) { $ zoneMember = $ this -> createZoneMemberZoneFromDefinition ( $ memberDefinition ) ; $ zone -> addMember ( $ zoneMember ) ; } } return $ zone ; }
9752	public function set_posts_to_review ( ) { $ total_posts = wp_count_posts ( ) ; $ total_posts = isset ( $ total_posts -> publish ) ? $ total_posts -> publish : 0 ; $ posts = get_posts ( [ 'post_type' => 'post' , 'numberposts' => $ total_posts , 'post_status' => 'publish' , ] ) ; foreach ( $ posts as $ post ) { if ( isset ( $ post -> ID ) ) { add_post_meta ( $ post -> ID , 'custom_images_grifus' , 'false' , true ) ; } } }
10892	public function isPrime ( ) { if ( $ this -> value < 2 ) { return false ; } if ( $ this -> value === 2 ) { return true ; } if ( $ this -> isEven ( ) ) { return false ; } for ( $ i = 3 ; $ i <= ceil ( sqrt ( $ this -> value ) ) ; $ i = $ i + 2 ) { if ( $ this -> value % $ i == 0 ) { return false ; } } return true ; }
3771	public function fixupModules ( DataContainer $ dataContainer ) { if ( ! class_exists ( 'tl_user_group' , false ) ) { throw new \ RuntimeException ( 'data container is not loaded!' ) ; } $ original = new \ tl_user_group ( ) ; $ modules = $ original -> getModules ( ) ; foreach ( array_keys ( $ modules ) as $ group ) { foreach ( $ modules [ $ group ] as $ key => $ module ) { if ( strpos ( $ module , 'metamodel_' ) === 0 ) { unset ( $ modules [ $ group ] [ $ key ] ) ; } } $ modules [ $ group ] = array_values ( $ modules [ $ group ] ) ; } $ modules [ 'metamodels' ] [ ] = 'support_metamodels' ; if ( false !== $ index = array_search ( 'metamodels' , $ modules [ 'metamodels' ] , true ) ) { unset ( $ modules [ 'metamodels' ] [ $ index ] ) ; $ modules [ 'metamodels' ] = array_values ( $ modules [ 'metamodels' ] ) ; } $ combinations = $ this -> combinationBuilder -> getCombinationsForUser ( [ $ dataContainer -> activeRecord -> id ] , 'be' ) ; $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ locale = $ this -> requestStack -> getCurrentRequest ( ) -> getLocale ( ) ; foreach ( $ screens as $ metaModel => $ screen ) { if ( 'standalone' === $ screen [ 'meta' ] [ 'rendertype' ] ) { $ modules [ $ screen [ 'meta' ] [ 'backendsection' ] ] [ ] = 'metamodel_' . $ metaModel ; $ this -> buildLanguageString ( 'metamodel_' . $ metaModel , $ screen , $ locale ) ; } } return $ modules ; }
2489	public function hasMultipleEndpoints ( ) { if ( $ this -> hasMultiple !== null ) { return $ this -> hasMultiple ; } $ endpointSet = array_flip ( $ this -> endpointMap ) ; if ( isset ( $ this -> defaultEndpoint ) ) { $ endpointSet [ $ this -> defaultEndpoint ] = true ; } if ( isset ( $ this -> mainLanguagesEndpoint ) ) { $ endpointSet [ $ this -> mainLanguagesEndpoint ] = true ; } return $ this -> hasMultiple = count ( $ endpointSet ) > 1 ; }
8663	private function convertGetReportRequestList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportRequestList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportRequestIdList ( ) ) { $ reportRequestIdList = $ request -> getReportRequestIdList ( ) ; foreach ( $ reportRequestIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportRequestIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetReportProcessingStatusList ( ) ) { $ reportProcessingStatusList = $ request -> getReportProcessingStatusList ( ) ; foreach ( $ reportProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'ReportProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetRequestedFromDate ( ) ) { $ parameters [ 'RequestedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedFromDate ( ) ) ; } if ( $ request -> isSetRequestedToDate ( ) ) { $ parameters [ 'RequestedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
7529	function dumpLocation ( ) { return ( ( $ this -> parent ) ? ( ( $ p = $ this -> parent -> dumpLocation ( ) ) ? $ p . ' > ' : '' ) . $ this -> tag . '(' . $ this -> typeIndex ( ) . ')' : '' ) ; }
9099	public function serve ( ServiceCallback $ callback ) { $ this -> bind ( ) ; $ this -> listen ( ) ; $ runOn = true ; while ( $ runOn ) { $ clientHandle = @ socket_accept ( $ this -> handle ) ; if ( ! is_resource ( $ clientHandle ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ address = null ; $ port = 0 ; if ( ! @ socket_getpeername ( $ clientHandle , $ address , $ port ) ) { $ code = socket_last_error ( $ clientHandle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ client = new ClientSocket ( new Endpoint ( $ address , $ port ) , $ clientHandle ) ; $ runOn = boolval ( $ callback -> callback ( $ client ) ) ; } }
8116	public function canBeReviewedBy ( Member $ member = null ) { if ( ! $ this -> owner -> obj ( "NextReviewDate" ) -> exists ( ) ) { return false ; } if ( $ this -> owner -> obj ( "NextReviewDate" ) -> InFuture ( ) ) { return false ; } $ options = $ this -> getOptions ( ) ; if ( ! $ options ) { return false ; } if ( ! $ options || ( ! $ options -> hasExtension ( __CLASS__ ) && ! $ options -> hasExtension ( ContentReviewDefaultSettings :: class ) ) ) { return false ; } if ( $ options -> OwnerGroups ( ) -> count ( ) == 0 && $ options -> OwnerUsers ( ) -> count ( ) == 0 ) { return false ; } if ( ! $ member ) { return true ; } if ( $ member -> inGroups ( $ options -> OwnerGroups ( ) ) ) { return true ; } if ( $ options -> OwnerUsers ( ) -> find ( "ID" , $ member -> ID ) ) { return true ; } return false ; }
1310	public static function categoriesMenu ( $ categories ) { $ menu = '<ul class="nav nav-pills nav-stacked">' ; foreach ( $ categories as $ category ) { $ menu .= '<li>' ; $ menu .= '<a href="/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.category' ) . '/' . $ category [ 'slug' ] . '">' ; $ menu .= '<div class="chatter-box" style="background-color:' . $ category [ 'color' ] . '"></div>' ; $ menu .= $ category [ 'name' ] . '</a>' ; if ( count ( $ category [ 'parents' ] ) ) { $ menu .= static :: categoriesMenu ( $ category [ 'parents' ] ) ; } $ menu .= '</li>' ; } $ menu .= '</ul>' ; return $ menu ; }
5883	public function beforeFind ( Event $ event , Query $ query , ArrayObject $ options , $ primary ) { $ orders = $ this -> _config [ 'orders' ] ; $ args = [ $ query , $ options , $ primary ] ; foreach ( $ orders as $ config ) { if ( ( ! empty ( $ config [ 'callback' ] ) && call_user_func_array ( $ config [ 'callback' ] , $ args ) ) || ! $ query -> clause ( 'order' ) ) { $ query -> order ( $ config [ 'order' ] ) ; break ; } } }
5738	public function setDefaultSuffix ( $ defaultSuffix ) { $ this -> defaultSuffix = ( string ) $ defaultSuffix ; $ this -> defaultSuffix = ltrim ( $ this -> defaultSuffix , '.' ) ; return $ this ; }
8176	public function actionRecoverPassword ( ) { $ model = new AccountRecoverPasswordForm ( ) ; if ( $ model -> load ( Yii :: $ app -> request -> post ( ) ) ) { if ( $ model -> validate ( ) ) { $ model -> recoverPassword ( ) ; } } return $ this -> render ( 'recoverPassword' , [ 'model' => $ model ] ) ; }
7584	protected function extractResponse ( $ curlResponse ) { $ this -> headers = substr ( $ curlResponse , 0 , $ this -> info [ 'header_size' ] ) ; $ this -> body = substr ( $ curlResponse , $ this -> info [ 'header_size' ] ) ; }
8847	public function getArchivedBlogPosts ( $ year , $ month = null , $ day = null ) { $ query = $ this -> getBlogPosts ( ) -> dataQuery ( ) ; $ stage = $ query -> getQueryParam ( "Versioned.stage" ) ; if ( $ stage ) $ stage = '_' . Convert :: raw2sql ( $ stage ) ; $ query -> innerJoin ( "BlogPost" , "`SiteTree" . $ stage . "`.`ID` = `BlogPost" . $ stage . "`.`ID`" ) ; $ query -> where ( "YEAR(PublishDate) = '" . Convert :: raw2sql ( $ year ) . "'" ) ; if ( $ month ) { $ query -> where ( "MONTH(PublishDate) = '" . Convert :: raw2sql ( $ month ) . "'" ) ; if ( $ day ) { $ query -> where ( "DAY(PublishDate) = '" . Convert :: raw2sql ( $ day ) . "'" ) ; } } return $ this -> getBlogPosts ( ) -> setDataQuery ( $ query ) ; }
6885	public function lookupPostcodeAddresses ( $ postcode ) { $ path = self :: PATH_LOOKUP_POSTCODE ; $ response = $ this -> httpGet ( $ path , [ 'postcode' => $ postcode ] ) ; return Response \ AddressList :: buildFromResponse ( $ response ) ; }
5125	public function serve ( ) { foreach ( $ this -> dispatchers as $ dispatcher ) { if ( $ dispatcher -> canServe ( ) ) { ContainerScope :: runScope ( $ this -> container , [ $ dispatcher , 'serve' ] ) ; return ; } } throw new BootException ( "Unable to locate active dispatcher." ) ; }
6016	public function createSite ( DeploymentSite $ deploymentSite ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'deploymentSite' => $ deploymentSite ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
758	protected function renderImageByImagick ( $ code ) { $ backColor = $ this -> transparent ? new \ ImagickPixel ( 'transparent' ) : new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> backColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ foreColor = new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> foreColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ image = new \ Imagick ( ) ; $ image -> newImage ( $ this -> width , $ this -> height , $ backColor ) ; $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( 30 ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code ) ; $ length = strlen ( $ code ) ; $ w = ( int ) $ fontMetrics [ 'textWidth' ] - 8 + $ this -> offset * ( $ length - 1 ) ; $ h = ( int ) $ fontMetrics [ 'textHeight' ] - 8 ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ) ; $ draw -> setFillColor ( $ foreColor ) ; $ image -> annotateImage ( $ draw , $ x , $ y , mt_rand ( - 10 , 10 ) , $ code [ $ i ] ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code [ $ i ] ) ; $ x += ( int ) $ fontMetrics [ 'textWidth' ] + $ this -> offset ; } $ image -> setImageFormat ( 'png' ) ; return $ image -> getImageBlob ( ) ; }
3953	public function get ( $ strAttributeName ) { return array_key_exists ( $ strAttributeName , $ this -> arrData ) ? $ this -> arrData [ $ strAttributeName ] : null ; }
10281	public static function absoluteCoordinate ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } list ( $ column , $ row ) = self :: coordinateFromString ( $ pCoordinateString ) ; $ column = ltrim ( $ column , '$' ) ; $ row = ltrim ( $ row , '$' ) ; return $ worksheet . '$' . $ column . '$' . $ row ; }
2841	public function renderArray ( $ data , $ noDataLabel = 'No Data' , $ header = null ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ block -> setTemplate ( 'sheep_debug/view/panel/_array.phtml' ) ; $ block -> setData ( 'array' , $ data ) ; $ block -> setData ( 'no_data_label' , $ noDataLabel ) ; $ block -> setData ( 'header' , $ header ) ; return $ block -> toHtml ( ) ; }
2808	protected function _getFilteredRequests ( ) { $ requests = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> getCollection ( ) ; $ requests -> setCurPage ( 1 ) ; $ requests -> setPageSize ( Mage :: helper ( 'sheep_debug/filter' ) -> getLimitDefaultValue ( ) ) ; if ( $ sessionId = $ this -> getRequest ( ) -> getParam ( 'session_id' ) ) { $ requests -> addSessionIdFilter ( $ sessionId ) ; } if ( $ ip = $ this -> getRequest ( ) -> getParam ( 'ip' ) ) { $ requests -> addIpFilter ( $ ip ) ; } if ( $ method = $ this -> getRequest ( ) -> getParam ( 'method' ) ) { $ requests -> addHttpMethodFilter ( $ method ) ; } if ( $ limit = $ this -> getRequest ( ) -> getParam ( 'limit' ) ) { $ requests -> setPageSize ( $ limit ) ; } if ( $ path = $ this -> getRequest ( ) -> getParam ( 'path' ) ) { $ requests -> addRequestPathFilter ( $ path ) ; } if ( $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ) { $ requests -> addTokenFilter ( $ token ) ; } if ( $ startDate = $ this -> getRequest ( ) -> getParam ( 'start' ) ) { $ requests -> addAfterFilter ( $ startDate ) ; } if ( $ endDate = $ this -> getRequest ( ) -> getParam ( 'end' ) ) { $ requests -> addEarlierFilter ( $ endDate ) ; } if ( $ page = ( int ) $ this -> getRequest ( ) -> getParam ( 'page' ) ) { $ requests -> setCurPage ( $ page ) ; } $ requests -> addOrder ( 'id' , Varien_Data_Collection_Db :: SORT_ORDER_DESC ) ; return $ requests ; }
759	public function setChildren ( $ children ) { $ this -> _children = [ ] ; foreach ( $ children as $ child ) { $ child -> parent = $ this ; $ this -> _children [ ] = $ child ; } $ this -> updateCollectionOffsets ( ) ; }
1345	public function isUpdateResource ( ) : bool { return $ this -> isMethod ( 'patch' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
5009	public function setSubject ( $ subject , $ translate = true ) { if ( false !== $ translate ) { $ translator = $ this -> getTranslator ( ) ; $ domain = $ this -> getTranslatorTextDomain ( ) ; if ( true === $ translate ) { $ subject = $ translator -> translate ( $ subject , $ domain ) ; } else { $ args = func_get_args ( ) ; $ args [ 0 ] = $ translator -> translate ( $ args [ 0 ] , $ domain ) ; $ subject = call_user_func_array ( 'sprintf' , $ args ) ; } } return parent :: setSubject ( $ subject ) ; }
3337	public function getInputTag ( $ name , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<input type="hidden" role="uploadcare-uploader" name="%s" data-upload-url-base="" data-integration="%s" %s />' , $ name , $ this -> getIntegrationData ( ) , join ( ' ' , $ to_compile ) ) ; }
9104	protected function parse_user ( ) { if ( ! empty ( $ this -> args [ 'user' ] ) ) { $ this -> args [ 'user__in' ] = array ( $ this -> args [ 'user' ] ) ; } return $ this -> parse_in_or_not_in_query ( 'user' , $ this -> args [ 'user__in' ] , $ this -> args [ 'user__not_in' ] ) ; }
7520	function parse_cdata ( ) { if ( $ this -> next_pos ( ']]>' , false ) === self :: TOK_UNKNOWN ) { $ this -> status [ 'cdata' ] = $ this -> getTokenString ( 9 , - 1 ) ; $ this -> status [ 'last_pos' ] = $ this -> pos + 2 ; return true ; } else { $ this -> addError ( 'Invalid cdata tag' ) ; return false ; } }
9765	function exist ( ) : self { if ( $ this -> hasFlag ( 'directory' ) ) $ constraint = directoryExists ( ) ; else if ( $ this -> hasFlag ( 'file' ) ) $ constraint = fileExists ( ) ; else throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , $ constraint ) ; }
2036	public function getAbsoluteUrl ( $ strParams = null ) { $ this -> loadDetails ( ) ; $ objUrlGenerator = System :: getContainer ( ) -> get ( 'contao.routing.url_generator' ) ; $ strUrl = $ objUrlGenerator -> generate ( ( $ this -> alias ? : $ this -> id ) . $ strParams , array ( '_locale' => $ this -> rootLanguage , '_domain' => $ this -> domain , '_ssl' => ( bool ) $ this -> rootUseSSL , ) , UrlGeneratorInterface :: ABSOLUTE_URL ) ; $ strUrl = $ this -> applyLegacyLogic ( $ strUrl , $ strParams ) ; return $ strUrl ; }
474	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "update $table" ) ; $ this -> db -> createCommand ( ) -> update ( $ table , $ columns , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
9541	private function decodeResponse ( Response $ response ) { $ data = json_decode ( $ response -> getBody ( ) -> read ( $ response -> getBody ( ) -> getSize ( ) ) , true ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new ClientException ( 'Unable to parse response body into JSON: ' . json_last_error ( ) ) ; } return $ data === null ? array ( ) : $ data ; }
6504	public function serializeParameters ( $ type , array $ parameters ) { $ jobType = $ this -> registry -> get ( $ type ) ; $ indices = $ jobType -> getIndicesOfSerializableParameters ( ) ; if ( count ( $ indices ) < count ( $ parameters ) ) { throw new \ InvalidArgumentException ( sprintf ( 'More parameters provided for serialization than defined for job "%s"' , $ type ) ) ; } $ i = 0 ; $ serializedParameters = array ( ) ; foreach ( $ parameters as $ parameter ) { if ( null == $ parameter ) { $ serializedParameters [ ] = null ; } else { $ serializedParameters [ ] = $ this -> serializer -> serialize ( $ parameter , 'json' , $ this -> getParamSerializationContext ( $ jobType , $ indices [ $ i ] ) ) ; } $ i ++ ; } $ data = json_encode ( $ serializedParameters ) ; if ( false === $ data ) { throw new \ RuntimeException ( sprintf ( 'Serialization failed with error "%s"' , json_last_error_msg ( ) ) ) ; } return $ data ; }
2161	public function run33Update ( ) { $ objLayout = $ this -> Database -> query ( "SELECT id, framework FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ strFramework = '' ; $ tmp = StringUtil :: deserialize ( $ objLayout -> framework ) ; if ( ! empty ( $ tmp ) && \ is_array ( $ tmp ) ) { if ( ( $ key = array_search ( 'layout.css' , $ tmp ) ) !== false ) { array_insert ( $ tmp , $ key + 1 , 'responsive.css' ) ; } $ strFramework = serialize ( array_values ( array_unique ( $ tmp ) ) ) ; } $ this -> Database -> prepare ( "UPDATE tl_layout SET framework=? WHERE id=?" ) -> execute ( $ strFramework , $ objLayout -> id ) ; } $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `viewport` varchar(64) NOT NULL default ''" ) ; }
519	private function findMigrationPath ( $ namespace ) { if ( empty ( $ namespace ) ) { return is_array ( $ this -> migrationPath ) ? reset ( $ this -> migrationPath ) : $ this -> migrationPath ; } if ( ! in_array ( $ namespace , $ this -> migrationNamespaces , true ) ) { throw new Exception ( "Namespace '{$namespace}' not found in `migrationNamespaces`" ) ; } return $ this -> getNamespacePath ( $ namespace ) ; }
7051	private function addViolation ( $ value , Constraint $ constraint ) { if ( $ this -> context instanceof ExecutionContextInterface ) { $ this -> context -> buildViolation ( $ constraint -> getMessage ( ) ) -> setParameter ( '{{ type }}' , $ constraint -> getType ( ) ) -> setParameter ( '{{ value }}' , $ this -> formatValue ( $ value ) ) -> setCode ( PhoneNumber :: INVALID_PHONE_NUMBER_ERROR ) -> addViolation ( ) ; } else { $ this -> context -> addViolation ( $ constraint -> getMessage ( ) , array ( '{{ type }}' => $ constraint -> getType ( ) , '{{ value }}' => $ value ) ) ; } }
2664	public function sendWebHook ( $ message ) { $ url = $ this -> config -> getIncomingWebhookURL ( ) ; $ messagePrefix = $ this -> config -> getWebhookMessagePrefix ( ) ; $ currentUsername = 'System' ; try { if ( $ this -> state -> getAreaCode ( ) == 'adminhtml' ) { $ getUser = $ this -> authSession -> getUser ( ) ; if ( ! empty ( $ getUser ) ) { $ currentUsername = $ getUser -> getUserName ( ) ; } } } catch ( \ Exception $ e ) { $ this -> log -> log ( 100 , 'Failed to retrieve Area Code' ) ; } $ storeName = $ this -> helper -> getStoreName ( ) ; $ storeUrl = $ this -> helper -> getStoreUrl ( ) ; $ text = $ messagePrefix . ' user=' . $ currentUsername . ' ' . $ message . ' on <' . $ storeUrl . '|Store> | ' . $ storeName ; $ headers = [ 'Content-type: application/json' ] ; $ body = json_encode ( [ "text" => $ text , "username" => "fastly-magento-bot" , "icon_emoji" => ":airplane:" ] ) ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> addOption ( CURLOPT_CONNECTTIMEOUT , 2 ) ; $ client -> addOption ( CURLOPT_TIMEOUT , 3 ) ; $ client -> write ( \ Zend_Http_Client :: POST , $ url , '1.1' , $ headers , $ body ) ; $ response = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; if ( $ responseCode != 200 ) { $ this -> log -> log ( 100 , 'Failed to send message to the following Webhook: ' . $ url ) ; } $ client -> close ( ) ; }
10782	public function andHaving ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
7250	protected function validateDeliveryAddress ( SaleInterface $ sale , Constraint $ constraint ) { if ( ! $ sale -> isSameAddress ( ) && null === $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_is_required ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } elseif ( $ sale -> isSameAddress ( ) && null !== $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_should_be_null ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } }
12131	public function handle ( ) { $ view = $ this -> application -> createInstance ( "view" , [ $ this -> application -> response , $ this -> application -> createInstance ( "viewengine" , [ $ this -> application -> response ] ) , $ this -> application ] ) ; $ view -> setData ( "title" , "An Error Occured" ) ; $ this -> application -> response -> send ( $ view -> render ( "errors/error" ) ) ; return Handler :: LAST_HANDLER ; }
9678	public function allNumberFormats ( Spreadsheet $ spreadsheet ) { $ aNumFmts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false && ! isset ( $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] ) ) { $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] = $ style -> getNumberFormat ( ) ; } } return $ aNumFmts ; }
7715	static function FindStartTagByPrefix ( & $ Txt , $ TagPrefix , $ PosBeg , $ Forward = true ) { $ x = '<' . $ TagPrefix ; $ xl = strlen ( $ x ) ; if ( $ Forward ) { $ PosBeg = strpos ( $ Txt , $ x , $ PosBeg ) ; } else { $ PosBeg = strrpos ( substr ( $ Txt , 0 , $ PosBeg + 2 ) , $ x ) ; } if ( $ PosBeg === false ) return false ; $ Tag = $ TagPrefix ; $ p = $ PosBeg + $ xl ; do { $ z = substr ( $ Txt , $ p , 1 ) ; if ( ( $ z !== ' ' ) && ( $ z !== "\r" ) && ( $ z !== "\n" ) && ( $ z !== '>' ) && ( $ z !== '/' ) ) { $ Tag .= $ z ; $ p ++ ; } else { $ p = false ; } } while ( $ p !== false ) ; return new clsTbsXmlLoc ( $ Txt , $ Tag , $ PosBeg ) ; }
12259	public function compile ( callable $ validator = NULL ) { if ( ! ( $ project = $ this -> getProject ( ) ) ) { $ project = CC :: get ( $ this -> getConfiguration ( ) , CC :: COMPILER_PROJECT ) ; if ( ! $ project ) throw new CompilerException ( "Compilation without project settings is not possible" ) ; } $ this -> project = $ project ; try { set_error_handler ( function ( $ code , $ msg , $ file , $ line ) { switch ( AbstractErrorHandlerService :: detectErrorLevel ( $ code ) ) { case AbstractErrorHandlerService :: NOTICE_ERROR_LEVEL : return $ this -> getLogger ( ) -> logNotice ( $ msg , [ $ file , $ line ] ) ; case AbstractErrorHandlerService :: DEPRECATED_ERROR_LEVEL : case AbstractErrorHandlerService :: WARNING_ERROR_LEVEL : return $ this -> getLogger ( ) -> logWarning ( $ msg , [ $ file , $ line ] ) ; default : return $ this -> getLogger ( ) -> logError ( $ msg , [ $ file , $ line ] ) ; } } ) ; foreach ( $ this -> getOrganizedCompilers ( ) as $ compiler ) { if ( ! $ validator || $ validator ( $ compiler ) ) $ compiler -> compile ( $ this ) ; } } catch ( Throwable $ throwable ) { $ this -> getLogger ( ) -> logException ( $ throwable ) ; } finally { restore_error_handler ( ) ; } }
1217	public static function slice ( $ value , $ start = null , $ stop = null , $ step = 1 ) { if ( ! Utils :: isArray ( $ value ) && ! is_string ( $ value ) ) { throw new \ InvalidArgumentException ( 'Expects string or array' ) ; } return self :: sliceIndices ( $ value , $ start , $ stop , $ step ) ; }
5024	private function findLeaf ( NodeInterface $ leaf , $ value ) { $ parts = is_array ( $ value ) ? $ value : explode ( $ this -> shouldUseNames ( ) ? ' | ' : '-' , $ value ) ; $ value = array_shift ( $ parts ) ; foreach ( $ leaf -> getChildren ( ) as $ item ) { $ compare = $ this -> shouldUseNames ( ) ? $ item -> getName ( ) : $ item -> getValue ( ) ; if ( $ compare == $ value ) { if ( count ( $ parts ) ) { return $ this -> findLeaf ( $ item , $ parts ) ; } return $ item ; } } if ( $ value && $ this -> shouldCreateLeafs ( ) ) { $ nodeClass = get_class ( $ leaf ) ; $ node = new $ nodeClass ( $ value ) ; $ leaf -> addChild ( $ node ) ; if ( count ( $ parts ) ) { return $ this -> findLeaf ( $ node , $ parts ) ; } return $ node ; } return null ; }
6556	public function log ( $ msg , $ logLevel = null ) { $ helper = new FormatterHelper ( ) ; $ style = $ this -> mapLogLevelToStyle ( $ logLevel ) ; $ this -> getOutput ( ) -> writeln ( $ logLevel ? $ helper -> formatBlock ( $ msg , $ style ) : $ msg ) ; if ( $ logLevel && $ systemLogger = $ this -> getSystemLogger ( ) ) { $ systemLogger -> log ( $ logLevel , $ msg ) ; } }
8931	private function addRoute ( $ method ) { switch ( $ method ) { case 'index' : $ methodMap = [ 'GET' ] ; $ realRoute = '$route' ; $ controllerCallable = $ this -> controllerLocation . ':indexAction' ; break ; case 'get' : $ methodMap = [ 'GET' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':getAction' ; break ; case 'post' : $ methodMap = [ 'POST' ] ; $ realRoute = '$route' ; $ controllerCallable = $ this -> controllerLocation . ':postAction' ; break ; case 'put' : $ methodMap = [ 'POST' , 'PUT' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':putAction' ; break ; case 'delete' : $ methodMap = [ 'DELETE' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':deleteAction' ; break ; default : throw new \ Exception ( 'Invalid method.' . $ method ) ; break ; } $ methodMap = "['" . implode ( "', '" , $ methodMap ) . "']" ; $ command = strtr ( $ this -> template , [ '$methodMap' => $ methodMap , '$route' => $ realRoute , '$controllerCallable' => $ controllerCallable ] ) ; $ this -> commands [ ] = $ command ; }
8043	public function onProcessCreate ( Semaphore $ semaphore ) { $ this -> semaphore = $ semaphore ; $ this -> create -> __invoke ( $ this -> semaphore , $ this -> storage ) ; }
3402	protected function applyResultCallbackChain ( Crawler $ node , ApistMethod $ method ) { if ( empty ( $ this -> resultMethodChain ) ) { $ this -> addCallback ( 'text' ) ; } $ traceStack = [ ] ; foreach ( $ this -> resultMethodChain as $ resultCallback ) { try { $ traceStack [ ] = $ resultCallback ; $ node = $ resultCallback -> apply ( $ node , $ method ) ; } catch ( InvalidArgumentException $ e ) { if ( $ method -> getResource ( ) -> isSuppressExceptions ( ) ) { return null ; } $ message = $ this -> createExceptionMessage ( $ e , $ traceStack ) ; throw new InvalidArgumentException ( $ message , 0 , $ e ) ; } } return $ node ; }
9703	private function addColor ( $ rgb ) { if ( ! isset ( $ this -> colors [ $ rgb ] ) ) { $ color = [ hexdec ( substr ( $ rgb , 0 , 2 ) ) , hexdec ( substr ( $ rgb , 2 , 2 ) ) , hexdec ( substr ( $ rgb , 4 ) ) , 0 , ] ; $ colorIndex = array_search ( $ color , $ this -> palette ) ; if ( $ colorIndex ) { $ this -> colors [ $ rgb ] = $ colorIndex ; } else { if ( count ( $ this -> colors ) == 0 ) { $ lastColor = 7 ; } else { $ lastColor = end ( $ this -> colors ) ; } if ( $ lastColor < 57 ) { $ colorIndex = $ lastColor + 1 ; $ this -> palette [ $ colorIndex ] = $ color ; $ this -> colors [ $ rgb ] = $ colorIndex ; } else { $ colorIndex = 0 ; } } } else { $ colorIndex = $ this -> colors [ $ rgb ] ; } return $ colorIndex ; }
7380	public function fetchEscape ( string $ key , \ mysqli $ db , string $ default = '' ) : string { return $ db -> real_escape_string ( $ this -> fetch ( $ key , $ default ) ) ; }
2386	public function removeField ( $ name , string $ legend = null ) : self { $ this -> removes [ ] = [ 'fields' => ( array ) $ name , 'parents' => ( array ) $ legend , ] ; return $ this ; }
7326	private function configureTaxableMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Pricing \ Model \ TaxableInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> taxableClassCache ) ) { return ; } if ( ! $ metadata -> hasAssociation ( 'taxGroup' ) ) { $ metadata -> mapManyToOne ( [ 'fieldName' => 'taxGroup' , 'targetEntity' => Pricing \ Entity \ TaxGroup :: class , 'joinColumns' => [ [ 'name' => 'tax_group_id' , 'referencedColumnName' => 'id' , 'onDelete' => 'RESTRICT' , 'nullable' => true , ] , ] , ] ) ; } $ this -> taxableClassCache [ ] = $ class ; }
545	protected function rotateFiles ( ) { $ file = $ this -> logFile ; for ( $ i = $ this -> maxLogFiles ; $ i >= 0 ; -- $ i ) { $ rotateFile = $ file . ( $ i === 0 ? '' : '.' . $ i ) ; if ( is_file ( $ rotateFile ) ) { if ( $ i === $ this -> maxLogFiles ) { @ unlink ( $ rotateFile ) ; continue ; } $ newFile = $ this -> logFile . '.' . ( $ i + 1 ) ; $ this -> rotateByCopy ? $ this -> rotateByCopy ( $ rotateFile , $ newFile ) : $ this -> rotateByRename ( $ rotateFile , $ newFile ) ; if ( $ i === 0 ) { $ this -> clearLogFile ( $ rotateFile ) ; } } } }
11398	public function remove ( $ sourceDir , array $ options , $ username ) { $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ options [ "blockname" ] ; $ blocksDir = $ dir . '/blocks' ; $ filename = sprintf ( '%s/%s.json' , $ blocksDir , $ blockName ) ; $ options [ "block" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVING , new BlockRemovingEvent ( $ this -> serializer , $ filename ) ) ; $ this -> filesystem -> remove ( $ filename ) ; $ this -> removeBlockFromSlotFile ( $ options , $ dir ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVED , new BlockRemovedEvent ( $ this -> serializer , $ filename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been removed from the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
6261	public function getActionMap ( ) { $ actionMap = ( array ) Configure :: read ( 'SimpleRbac.actionMap' ) ; if ( empty ( $ actionMap ) && $ this -> _config [ 'allowEmptyActionMap' ] === false ) { throw new \ RuntimeException ( 'SimpleRbac.actionMap configuration is empty!' ) ; } return $ actionMap ; }
10567	public function newAction ( ) { $ entity = new Media ( ) ; $ form = $ this -> createCreateForm ( $ entity ) ; return $ this -> render ( 'MMMediaBundle:Media:new.html.twig' , array ( 'entity' => $ entity , 'form' => $ form -> createView ( ) , ) ) ; }
7907	protected function getLabel ( $ item ) { $ encodeLabel = isset ( $ item [ 'encode' ] ) ? $ item [ 'encode' ] : $ this -> encodeLabels ; return $ encodeLabel ? Html :: encode ( $ item [ 'label' ] ) : $ item [ 'label' ] ; }
6967	protected function calculateGoodLines ( Model \ DocumentInterface $ document ) : Amount { $ gross = new Amount ( $ document -> getCurrency ( ) ) ; foreach ( $ document -> getLinesByType ( Model \ DocumentLineTypes :: TYPE_GOOD ) as $ line ) { if ( null !== $ result = $ this -> calculateGoodLine ( $ line ) ) { $ gross -> merge ( $ result ) ; } } $ gross -> copyGrossToUnit ( ) ; return $ gross ; }
12511	private function buildGroup ( $ group ) { if ( is_null ( $ group ) ) { $ group = [ 'filter' => [ 'is_to_all' => true , ] , ] ; } elseif ( is_array ( $ group ) ) { $ group = [ 'touser' => $ group , ] ; } else { $ group = [ 'filter' => [ 'is_to_all' => false , 'group_id' => $ group , ] , ] ; } return $ group ; }
10485	protected function getTableMapping ( $ table ) { if ( array_key_exists ( $ table , $ this -> mappings ) ) { return $ this -> mappings [ $ table ] ; } $ mapping = $ this -> retrieveMapping ( $ table ) ; if ( empty ( $ mapping ) ) { throw new \ UnderflowException ( "Table with name {$table} not found." ) ; } $ this -> mappings [ $ table ] = $ mapping ; return $ mapping ; }
902	public function isAnonymousClass ( $ index ) { $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isClassy ( ) ) { throw new \ LogicException ( sprintf ( 'No classy token at given index %d.' , $ index ) ) ; } if ( ! $ token -> isGivenKind ( T_CLASS ) ) { return false ; } return $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_NEW ) ; }
6469	public function parseAcceptHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept' , $ i ) ; $ mediaType = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptMediaTypeHeaderValue ( $ mediaType , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
138	public function update ( RepositoryInterface $ repo , UpdateOperation $ operation ) { $ initial = $ operation -> getInitialPackage ( ) ; $ target = $ operation -> getTargetPackage ( ) ; $ initialType = $ initial -> getType ( ) ; $ targetType = $ target -> getType ( ) ; if ( $ initialType === $ targetType ) { $ installer = $ this -> getInstaller ( $ initialType ) ; $ installer -> update ( $ repo , $ initial , $ target ) ; $ this -> markForNotification ( $ target ) ; } else { $ this -> getInstaller ( $ initialType ) -> uninstall ( $ repo , $ initial ) ; $ this -> getInstaller ( $ targetType ) -> install ( $ repo , $ target ) ; } }
2371	public static function splitCsv ( $ strString , $ strDelimiter = ',' ) { $ arrValues = preg_split ( '/' . $ strDelimiter . '(?=(?:[^"]*"[^"]*")*(?![^"]*"))/' , $ strString ) ; foreach ( $ arrValues as $ k => $ v ) { $ arrValues [ $ k ] = trim ( $ v , ' "' ) ; } return $ arrValues ; }
11080	public static function getDayName ( $ day ) { if ( $ day < self :: DOW_MONDAY || $ day > self :: DOW_SUNDAY ) { return '' ; } $ dayNames = [ self :: DOW_MONDAY => self :: poorManTranslate ( 'fts-shared' , 'Monday' ) , self :: DOW_TUESDAY => self :: poorManTranslate ( 'fts-shared' , 'Tuesday' ) , self :: DOW_WEDNESDAY => self :: poorManTranslate ( 'fts-shared' , 'Wednesday' ) , self :: DOW_THURSDAY => self :: poorManTranslate ( 'fts-shared' , 'Thursday' ) , self :: DOW_FRIDAY => self :: poorManTranslate ( 'fts-shared' , 'Friday' ) , self :: DOW_SATURDAY => self :: poorManTranslate ( 'fts-shared' , 'Saturday' ) , self :: DOW_SUNDAY => self :: poorManTranslate ( 'fts-shared' , 'Sunday' ) , ] ; return $ dayNames [ $ day ] ; }
10462	public function getTableName ( $ shopId = null ) { $ tableName = parent :: getTableName ( ) ; if ( $ shopId === null ) { $ shopId = $ this -> getActiveShopId ( ) ; } if ( ! $ this -> isShopValid ( $ shopId ) ) { throw new InvalidArgumentException ( "Shop id \"{$shopId}\" is invalid." ) ; } $ tableName .= '_' . $ shopId ; try { SqlValidator :: validateTableName ( $ tableName ) ; } catch ( InvalidArgumentException $ e ) { throw new InvalidArgumentException ( "Shop id \"{$shopId}\" is invalid." , 0 , $ e ) ; } return $ tableName ; }
11738	protected function normalize ( $ scheme = true , $ www = true ) { $ address = $ this -> address ; if ( $ scheme && null === $ this -> get ( self :: PARSE_SCHEME ) ) { $ address = sprintf ( 'http://%s' , $ this -> address ) ; } elseif ( ! $ scheme && $ this -> get ( self :: PARSE_SCHEME ) ) { $ address = str_replace ( $ this -> get ( self :: PARSE_SCHEME ) . '://' , '' , $ this -> address ) ; } if ( false === $ www && 0 === strpos ( $ this -> get ( self :: PARSE_HOST ) , 'www.' ) ) { $ address = substr ( $ address , 4 ) ; } return $ address ; }
11125	public function index ( Request $ request ) { $ this -> settingRepository -> pushCriteria ( new RequestCriteria ( $ request ) ) ; $ settings = $ this -> settingRepository -> all ( ) ; $ dateFormats = DateFormatter :: dropdownArray ( ) ; return view ( 'l5starter::admin.settings.index' ) -> with ( [ 'dateFormats' => $ dateFormats , 'settings' => $ settings , ] ) ; }
1759	public static function getSessionHash ( $ strCookie ) { @ trigger_error ( 'Using System::getSessionHash() has been deprecated and will no longer work in Contao 5.0. Use Symfony authentication instead.' , E_USER_DEPRECATED ) ; $ session = static :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { $ session -> start ( ) ; } return sha1 ( $ session -> getId ( ) . $ strCookie ) ; }
3894	private function getFilteredAttributeNames ( $ metaModelId , $ allowedTypes = array ( ) ) { $ attributeNames = array ( ) ; if ( $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ) ) { foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( empty ( $ allowedTypes ) || in_array ( $ attribute -> get ( 'type' ) , $ allowedTypes ) ) { $ attributeNames [ $ attribute -> getColName ( ) ] = sprintf ( '%s [%s]' , $ attribute -> getName ( ) , $ attribute -> getColName ( ) ) ; } } } return $ attributeNames ; }
5749	public static function arrayWalkToStringRecursive ( array $ arr , int $ level = 0 , int $ maxLevel = 1000 , $ newLine = '<br>' ) : string { $ out = "" ; $ tabs = " " ; for ( $ i = 0 ; $ i < $ level ; $ i ++ ) { $ tabs .= " ^" ; } foreach ( $ arr as $ k => $ v ) { $ out .= "$newLine$tabs$k: " ; if ( is_object ( $ v ) ) { $ out .= 'object type: ' . get_class ( $ v ) ; } elseif ( is_array ( $ v ) ) { $ newLevel = $ level + 1 ; if ( $ newLevel > $ maxLevel ) { $ out .= ' array too deep, quitting' ; } else { $ out .= self :: arrayWalkToStringRecursive ( $ v , $ newLevel , $ maxLevel , $ newLine ) ; } } else { $ out .= ( string ) $ v ; } } return $ out ; }
2580	protected function loadWsdl ( $ params ) { if ( isset ( $ params [ 'wsdl' ] ) ) { if ( is_string ( $ params [ 'wsdl' ] ) ) { $ this -> wsdl = [ $ params [ 'wsdl' ] ] ; } elseif ( is_array ( $ params [ 'wsdl' ] ) ) { $ this -> wsdl = $ params [ 'wsdl' ] ; } } }
5155	public function setConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } unset ( $ this -> configuration ) ; $ this -> configuration = $ configuration ; if ( $ configure ) { $ this -> configure ( ) ; } }
4554	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; foreach ( $ this -> removed as $ property ) { if ( array_key_exists ( $ property , $ payload ) ) { $ event -> markAsInvalid ( ) ; break ; } } }
2016	public function generateMarkup ( ) { $ return = ' <div> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple required> </div>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; }
7696	function MsPowerpoint_Clean ( & $ Txt ) { $ this -> MsPowerpoint_CleanRpr ( $ Txt , 'a:rPr' ) ; $ Txt = str_replace ( '<a:rPr/>' , '' , $ Txt ) ; $ this -> MsPowerpoint_CleanRpr ( $ Txt , 'a:endParaRPr' ) ; $ Txt = str_replace ( '<a:endParaRPr/>' , '' , $ Txt ) ; $ Txt = str_replace ( '</a:t><a:t>' , '' , $ Txt ) ; $ Txt = str_replace ( '</a:t></a:r><a:r><a:t>' , '' , $ Txt ) ; $ Txt = str_replace ( '<a:t></a:t>' , '' , $ Txt ) ; $ Txt = str_replace ( '<a:r></a:r>' , '' , $ Txt ) ; }
2630	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ comment = $ this -> getRequest ( ) -> getParam ( 'comment_value' ) ; $ negated = 0 ; if ( $ value [ 0 ] == '!' ) { $ negated = 1 ; $ value = ltrim ( $ value , '!' ) ; } $ ipParts = explode ( '/' , $ value ) ; $ subnet = false ; if ( ! empty ( $ ipParts [ 1 ] ) ) { if ( is_numeric ( $ ipParts [ 1 ] ) && ( int ) $ ipParts [ 1 ] < 129 ) { $ subnet = $ ipParts [ 1 ] ; } else { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP subnet format.' ] ) ; } } if ( ! filter_var ( $ ipParts [ 0 ] , FILTER_VALIDATE_IP ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP address format.' ] ) ; } $ createAclItem = $ this -> api -> upsertAclItem ( $ aclId , $ ipParts [ 0 ] , $ negated , $ comment , $ subnet ) ; if ( ! $ createAclItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Acl entry.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'id' => $ createAclItem -> id , 'comment' => $ createAclItem -> comment , 'created_at' => $ createAclItem -> created_at ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12536	public function authenticate ( ClientInterface $ client ) { $ attributes = $ client -> getUserAttributes ( ) ; $ provider = $ client -> getId ( ) ; $ clientId = $ attributes [ 'id' ] ; $ account = $ this -> finder -> findAccountByProviderAndClientId ( $ provider , $ clientId ) ; if ( $ account === null ) { $ account = \ Yii :: createObject ( [ 'class' => Account :: className ( ) , 'provider' => $ provider , 'client_id' => $ clientId , 'data' => json_encode ( $ attributes ) , ] ) ; $ account -> save ( false ) ; } if ( null === ( $ user = $ account -> user ) ) { $ this -> action -> successUrl = Url :: to ( [ '/user/registration/connect' , 'account_id' => $ account -> id ] ) ; } else { \ Yii :: $ app -> user -> login ( $ user , $ this -> module -> rememberFor ) ; } }
1545	public function decodes ( string ... $ mediaTypes ) : bool { if ( ! $ decoding = $ this -> getDecodingMediaType ( ) ) { return false ; } return collect ( $ mediaTypes ) -> contains ( function ( $ mediaType , $ index ) use ( $ decoding ) { return $ decoding -> equalsTo ( MediaType :: parse ( $ index , $ mediaType ) ) ; } ) ; }
4548	public function getAll ( ) : Data { $ data = new Data ; foreach ( $ this -> statCollection as $ stat ) { $ datum = $ stat -> get ( ) ; $ data -> getCollection ( ) -> add ( $ datum ) ; } return $ data ; }
9947	public function getRowDimension ( $ pRow , $ create = true ) { $ found = null ; if ( ! isset ( $ this -> rowDimensions [ $ pRow ] ) ) { if ( ! $ create ) { return null ; } $ this -> rowDimensions [ $ pRow ] = new RowDimension ( $ pRow ) ; $ this -> cachedHighestRow = max ( $ this -> cachedHighestRow , $ pRow ) ; } return $ this -> rowDimensions [ $ pRow ] ; }
4910	public function renderSummary ( SummaryFormInterface $ form ) { $ form -> prepare ( ) ; $ baseFieldset = $ form -> getBaseFieldset ( ) ; if ( ! isset ( $ baseFieldset ) ) { throw new \ InvalidArgumentException ( 'For the Form ' . get_class ( $ form ) . ' there is no Basefieldset' ) ; } $ dataAttributesMarkup = '' ; foreach ( $ form -> getAttributes ( ) as $ dataKey => $ dataValue ) { if ( preg_match ( '/^data-/' , $ dataKey ) ) { $ dataAttributesMarkup .= sprintf ( ' %s="%s"' , $ dataKey , $ dataValue ) ; } } $ markup = '<div class="panel panel-default" style="min-height: 100px;"' . $ dataAttributesMarkup . '> <div class="panel-body"><div class="sf-controls">%s</div>%s</div></div>' ; $ view = $ this -> getView ( ) ; $ buttonMarkup = false === $ form -> getOption ( 'editable' ) ? '' : '<button type="button" class="btn btn-default btn-xs sf-edit">' . '<span class="yk-icon yk-icon-edit"></span> ' . $ view -> translate ( 'Edit' ) . '</button>' ; if ( ( $ controlButtons = $ form -> getOption ( 'control_buttons' ) ) !== null ) { $ buttonMarkup .= PHP_EOL . implode ( PHP_EOL , array_map ( function ( array $ buttonSpec ) use ( $ view ) { return '<button type="button" class="btn btn-default btn-xs' . ( isset ( $ buttonSpec [ 'class' ] ) ? ' ' . $ buttonSpec [ 'class' ] : '' ) . '">' . ( isset ( $ buttonSpec [ 'icon' ] ) ? '<span class="yk-icon yk-icon-' . $ buttonSpec [ 'icon' ] . '"></span> ' : '' ) . $ view -> translate ( $ buttonSpec [ 'label' ] ) . '</button>' ; } , $ controlButtons ) ) ; } $ elementMarkup = $ this -> renderSummaryElement ( $ baseFieldset ) ; return sprintf ( $ markup , $ buttonMarkup , $ elementMarkup ) ; }
10843	protected function refreshProductVariantSellPrice ( VariantInterface $ variant ) { $ product = $ variant -> getProduct ( ) ; $ sellPrice = $ product -> getSellPrice ( ) ; $ grossAmount = $ this -> calculateAttributePrice ( $ variant , $ sellPrice -> getGrossAmount ( ) ) ; $ discountedGrossAmount = $ this -> calculateAttributePrice ( $ variant , $ sellPrice -> getDiscountedGrossAmount ( ) ) ; $ taxRate = $ product -> getSellPriceTax ( ) -> getValue ( ) ; $ netAmount = TaxHelper :: calculateNetPrice ( $ grossAmount , $ taxRate ) ; $ discountedNetAmount = TaxHelper :: calculateNetPrice ( $ discountedGrossAmount , $ taxRate ) ; $ productAttributeSellPrice = $ variant -> getSellPrice ( ) ; $ productAttributeSellPrice -> setTaxRate ( $ taxRate ) ; $ productAttributeSellPrice -> setTaxAmount ( $ grossAmount - $ netAmount ) ; $ productAttributeSellPrice -> setGrossAmount ( $ grossAmount ) ; $ productAttributeSellPrice -> setNetAmount ( $ netAmount ) ; $ productAttributeSellPrice -> setDiscountedGrossAmount ( $ discountedGrossAmount ) ; $ productAttributeSellPrice -> setDiscountedTaxAmount ( $ discountedGrossAmount - $ discountedNetAmount ) ; $ productAttributeSellPrice -> setDiscountedNetAmount ( $ discountedNetAmount ) ; $ productAttributeSellPrice -> setValidFrom ( $ sellPrice -> getValidFrom ( ) ) ; $ productAttributeSellPrice -> setValidTo ( $ sellPrice -> getValidTo ( ) ) ; $ productAttributeSellPrice -> setCurrency ( $ sellPrice -> getCurrency ( ) ) ; }
12457	protected function onSuccessLoad ( ) { if ( $ this -> Web2All -> DebugLevel > Web2All_Manager_Main :: DEBUGLEVEL_MEDIUM ) { $ this -> Web2All -> debugLog ( 'Web2All_Table_Object::loadFromTable(): loaded: ' . $ this -> asDebugString ( ) ) ; } }
7611	public function actionCreate ( ) { $ model = new User ; if ( $ model -> load ( $ _POST ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; } }
2543	public function analyzeWithErrCodeAndMsgQueryFixedCat ( SendResult $ response , $ qErr , $ qMsg , $ category ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; $ errorMsgNodeList = $ domXpath -> query ( $ qMsg ) ; if ( $ errorCodeNodeList -> length > 0 || $ errorMsgNodeList -> length > 0 ) { $ analyzeResponse -> status = $ category ; $ errorCode = ( $ errorCodeNodeList -> length > 0 ) ? $ errorCodeNodeList -> item ( 0 ) -> nodeValue : null ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorMsgNodeList ) ) ; } return $ analyzeResponse ; }
10474	public function lookupItem ( $ item_id ) { $ request = new ItemRequest ( $ item_id ) ; $ this -> emit ( 'request.item' , array ( $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new ItemResponse ( $ response ) ; }
5408	protected function isMatch ( $ cookie , $ host , $ path , $ name ) { if ( $ cookie -> getName ( ) != $ name ) { return false ; } if ( $ host && $ cookie -> getHost ( ) && ! $ cookie -> isValidHost ( $ host ) ) { return false ; } if ( ! $ cookie -> isValidPath ( $ path ) ) { return false ; } return true ; }
1333	protected function applyFilters ( $ query , Collection $ filters ) { if ( $ this -> isFindMany ( $ filters ) ) { $ this -> filterByIds ( $ query , $ filters ) ; } $ this -> filter ( $ query , $ filters ) ; }
1530	public function resource ( string $ resourceType , array $ options = [ ] ) : ResourceRegistration { return new ResourceRegistration ( $ this -> router , $ resourceType , array_merge ( $ this -> options , $ options ) ) ; }
2644	public function getCustomerInfo ( ) { $ uri = $ this -> config -> getApiEndpoint ( ) . 'current_customer' ; $ result = $ this -> _fetch ( $ uri ) ; return $ result ; }
7398	public function setStatusCode ( int $ statusCode , string $ version = '1.1' , string $ statusText = '' ) : bool { if ( ! headers_sent ( ) ) { $ statusCode = intval ( $ statusCode ) ; if ( '' == $ statusText ) { $ statusTexts = [ 100 => 'Continue' , 101 => 'Switching Protocols' , 102 => 'Processing' , 200 => 'OK' , 201 => 'Created' , 202 => 'Accepted' , 203 => 'Non-Authoritative Information' , 204 => 'No Content' , 205 => 'Reset Content' , 206 => 'Partial Content' , 207 => 'Multi-Status' , 208 => 'Already Reported' , 226 => 'IM Used' , 300 => 'Multiple Choices' , 301 => 'Moved Permanently' , 302 => 'Found' , 303 => 'See Other' , 304 => 'Not Modified' , 305 => 'Use Proxy' , 307 => 'Temporary Redirect' , 308 => 'Permanent Redirect' , 400 => 'Bad Request' , 401 => 'Unauthorized' , 402 => 'Payment Required' , 403 => 'Forbidden' , 404 => 'Not Found' , 405 => 'Method Not Allowed' , 406 => 'Not Acceptable' , 407 => 'Proxy Authentication Required' , 408 => 'Request Timeout' , 409 => 'Conflict' , 410 => 'Gone' , 411 => 'Length Required' , 412 => 'Precondition Failed' , 413 => 'Payload Too Large' , 414 => 'URI Too Long' , 415 => 'Unsupported Media Type' , 416 => 'Range Not Satisfiable' , 417 => 'Expectation Failed' , 418 => 'I\'m a teapot' , 422 => 'Unprocessable Entity' , 423 => 'Locked' , 424 => 'Failed Dependency' , 425 => 'Reserved for WebDAV advanced collections expired proposal' , 426 => 'Upgrade Required' , 428 => 'Precondition Required' , 429 => 'Too Many Requests' , 431 => 'Request Header Fields Too Large' , 500 => 'Internal Server Error' , 501 => 'Not Implemented' , 502 => 'Bad Gateway' , 503 => 'Service Unavailable' , 504 => 'Gateway Timeout' , 505 => 'HTTP Version Not Supported' , 506 => 'Variant Also Negotiates (Experimental)' , 507 => 'Insufficient Storage' , 508 => 'Loop Detected' , 510 => 'Not Extended' , 511 => 'Network Authentication Required' , ] ; $ statusText = $ statusTexts [ $ statusCode ] ; } header ( sprintf ( 'HTTP/%s %s %s' , $ version , $ statusCode , $ statusText ) , true , $ statusCode ) ; return true ; } return false ; }
10450	public function delete ( $ key ) { try { $ this -> get ( $ key ) ; } catch ( KeyNotFoundException $ e ) { return false ; } return $ this -> getClient ( ) -> delete ( $ key ) ; }
1579	public function withType ( string $ type ) : self { if ( empty ( $ type ) ) { throw new \ InvalidArgumentException ( 'Expecting a non-empty string.' ) ; } $ copy = clone $ this ; $ copy -> type = $ type ; $ copy -> normalize ( ) ; return $ copy ; }
4587	public function setStaffUuid ( ? string $ staffUuid ) { $ this -> staffUuid = $ staffUuid ; $ this -> _staffUuid = true ; return $ this ; }
12921	public function getRemaining ( ) { if ( is_null ( $ this -> _countRemaining ) ) { $ this -> _countRemaining = $ this -> total ; } return $ this -> _countRemaining ; }
9425	public function f ( ) { if ( is_null ( $ this -> arr_f ) ) { $ arr = $ this -> frequency ( ) ; array_walk ( $ arr , function ( & $ v , $ k , $ n ) { $ v = $ v / $ n ; } , count ( $ this ) ) ; $ this -> arr_f = $ arr ; } return $ this -> arr_f ; }
7677	function TbsSearchInFiles ( $ files , $ str , $ returnFirstFound = true ) { $ keys_ok = array ( ) ; $ keys_todo = array ( ) ; $ idx_keys = array ( ) ; foreach ( $ files as $ k => $ f ) { $ idx = $ this -> FileGetIdx ( $ f ) ; if ( $ idx !== false ) { $ keys_todo [ $ k ] = $ idx ; $ idx_keys [ $ idx ] = $ k ; } } if ( ( $ this -> TbsCurrIdx !== false ) && isset ( $ idx_keys [ $ this -> TbsCurrIdx ] ) ) { $ key = $ idx_keys [ $ this -> TbsCurrIdx ] ; $ p = strpos ( $ this -> TBS -> Source , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ this -> TbsCurrIdx , 'src' => & $ this -> TBS -> Source , 'pos' => $ p , 'curr' => true ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } foreach ( $ this -> TbsStoreLst as $ idx => $ s ) { if ( ( $ idx !== $ this -> TbsCurrIdx ) && isset ( $ idx_keys [ $ idx ] ) ) { $ key = $ idx_keys [ $ idx ] ; $ p = strpos ( $ s [ 'src' ] , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => & $ s [ 'src' ] , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } } foreach ( $ keys_todo as $ key => $ idx ) { $ txt = $ this -> FileRead ( $ idx ) ; $ p = strpos ( $ txt , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => $ txt , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } } if ( $ returnFirstFound ) { return array ( 'key' => false , 'idx' => false , 'src' => false , 'pos' => false , 'curr' => false ) ; } else { return $ keys_ok ; } }
3604	public function handleJsonRequest ( $ jsonRequest ) { if ( \ is_array ( $ jsonRequest ) ) { $ jsonResponse = [ ] ; foreach ( $ jsonRequest as $ request ) { $ jsonResponse [ ] = $ this -> handleJsonRequest ( $ request ) ; } return $ jsonResponse ; } if ( $ this -> stopwatch ) { $ this -> stopwatch -> start ( 'rpc.execute' ) ; } try { $ this -> dispatch ( Event \ JsonRequestEvent :: EVENT , new Event \ JsonRequestEvent ( $ jsonRequest ) ) ; $ metadata = $ this -> getMethod ( $ jsonRequest ) ; $ isCache = $ this -> isCacheSupport ( $ jsonRequest ) ; $ cacheId = $ jsonRequest -> getHash ( ) ; $ jsonResponse = new JsonResponse ( $ jsonRequest ) ; if ( true === $ isCache && true === $ this -> getCache ( ) -> contains ( $ cacheId ) ) { $ jsonResponse -> setResult ( $ this -> getCache ( ) -> fetch ( $ cacheId ) ) ; $ isCache = false ; } $ result = $ jsonResponse -> getResult ( ) ; if ( null === $ result ) { $ result = $ this -> executeJsonRequest ( $ metadata , $ jsonRequest ) ; } if ( $ result instanceof JsonResponse ) { $ jsonResponse = $ result ; $ jsonResponse -> setRequest ( $ jsonRequest ) ; } else { $ jsonResponse -> setResult ( $ this -> serialize ( $ result ) ) ; } $ isCache && $ this -> cache -> save ( $ cacheId , $ jsonResponse -> getResult ( ) , $ metadata -> getCache ( ) ) ; $ this -> dispatch ( Event \ JsonResponseEvent :: EVENT , new Event \ JsonResponseEvent ( $ jsonResponse ) ) ; } catch ( \ Exception $ exception ) { $ jsonResponse = $ this -> createJsonResponseFromException ( $ exception , $ jsonRequest ) ; } if ( $ this -> stopwatch ) { $ this -> stopwatch -> stop ( 'rpc.execute' ) ; } return $ jsonResponse ; }
5172	public function setEncoder ( callable $ encoder ) : Yaml { if ( ! is_callable ( $ encoder ) ) { throw new \ InvalidArgumentException ( 'The provided encoder must be callable.' ) ; } $ this -> encoder = $ encoder ; return $ this ; }
3506	private function convertAlertToArray ( Alert $ alert ) : array { $ data = [ ] ; if ( $ alert -> getBodyLocalized ( ) -> getKey ( ) ) { $ data [ 'loc-key' ] = $ alert -> getBodyLocalized ( ) -> getKey ( ) ; $ data [ 'loc-args' ] = $ alert -> getBodyLocalized ( ) -> getArgs ( ) ; } else { $ data [ 'body' ] = $ alert -> getBody ( ) ; } if ( $ alert -> getTitleLocalized ( ) -> getKey ( ) ) { $ data [ 'title-loc-key' ] = $ alert -> getTitleLocalized ( ) -> getKey ( ) ; $ data [ 'title-loc-args' ] = $ alert -> getTitleLocalized ( ) -> getArgs ( ) ; } elseif ( $ alert -> getTitle ( ) ) { $ data [ 'title' ] = $ alert -> getTitle ( ) ; } if ( $ alert -> getActionLocalized ( ) -> getKey ( ) ) { $ data [ 'action-loc-key' ] = $ alert -> getActionLocalized ( ) -> getKey ( ) ; } if ( $ alert -> getLaunchImage ( ) ) { $ data [ 'launch-image' ] = $ alert -> getLaunchImage ( ) ; } return $ data ; }
2549	protected function loadClientParams ( Params $ params , $ receivedFromIdentifier , $ version ) { if ( $ params -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> authParams ; if ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams instanceof Params \ SessionHandlerParams ) { $ params -> sessionHandlerParams -> authParams = $ this -> authParams ; } } elseif ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> sessionHandlerParams -> authParams ; } $ this -> sessionHandler = $ this -> loadSessionHandler ( $ params -> sessionHandler , $ params -> sessionHandlerParams ) ; $ this -> requestCreator = $ this -> loadRequestCreator ( $ params -> requestCreator , $ params -> requestCreatorParams , $ receivedFromIdentifier . "-" . $ version , $ this -> sessionHandler -> getOriginatorOffice ( ) , $ this -> sessionHandler -> getMessagesAndVersions ( ) ) ; $ this -> responseHandler = $ this -> loadResponseHandler ( $ params -> responseHandler ) ; $ this -> returnResultXml = $ params -> returnXml ; }
2212	public function fetchField ( $ intOffset = 0 ) { $ arrFields = array_values ( $ this -> resultSet [ $ this -> intIndex ] ) ; return $ arrFields [ $ intOffset ] ; }
2988	public function hasResourceInAnnotation ( $ bundle ) { if ( ! file_exists ( $ this -> file ) ) { return false ; } $ config = Yaml :: parse ( file_get_contents ( $ this -> file ) ) ; $ search = sprintf ( '@%s/Controller/' , $ bundle ) ; foreach ( $ config as $ resource ) { if ( array_key_exists ( 'resource' , $ resource ) ) { return $ resource [ 'resource' ] === $ search ; } } return false ; }
6489	private function addHeaderValue ( HttpHeaders $ headers , string $ name , $ value , bool $ append ) : void { $ decodedValue = trim ( ( string ) ( isset ( self :: $ headersToUrlDecode [ $ name ] ) ? urldecode ( $ value ) : $ value ) ) ; if ( isset ( self :: $ specialCaseHeaders [ $ name ] ) ) { $ headers -> add ( $ name , $ decodedValue , $ append ) ; } elseif ( strpos ( $ name , 'HTTP_' ) === 0 ) { $ normalizedName = substr ( $ name , 5 ) ; $ headers -> add ( $ normalizedName , $ decodedValue , $ append ) ; } }
10934	protected function is_php ( $ version ) { static $ _is_php ; $ version = ( string ) $ version ; if ( ! isset ( $ _is_php [ $ version ] ) ) { $ _is_php [ $ version ] = version_compare ( PHP_VERSION , $ version , '>=' ) ; } return $ _is_php [ $ version ] ; }
864	private function registerFoundToken ( $ token ) { $ tokenKind = $ token instanceof Token ? ( $ token -> isArray ( ) ? $ token -> getId ( ) : $ token -> getContent ( ) ) : ( \ is_array ( $ token ) ? $ token [ 0 ] : $ token ) ; if ( ! isset ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { $ this -> foundTokenKinds [ $ tokenKind ] = 0 ; } ++ $ this -> foundTokenKinds [ $ tokenKind ] ; }
10919	public static function getArray ( $ language ) { $ fileName = __DIR__ . '/stop-words/' . $ language . '.txt' ; if ( file_exists ( $ fileName ) ) { return array_map ( 'trim' , file ( $ fileName ) ) ; } return [ ] ; }
5877	protected static function findExistingFile ( $ fileName ) { $ file = null ; $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( isset ( $ storageConfiguration [ 'basePath' ] ) ) { $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ row = GeneralUtility :: makeInstance ( ConnectionPool :: class ) -> getConnectionForTable ( 'sys_file' ) -> select ( [ 'uid' ] , 'sys_file' , [ 'storage' => $ targetFolder -> getStorage ( ) -> getUid ( ) , 'identifier' => $ identifier , ] ) -> fetch ( ) ; if ( ! empty ( $ row [ 'uid' ] ) ) { $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ file = $ fileRepository -> findByUid ( $ row [ 'uid' ] ) ; } } return $ file ; }
860	public function clearRange ( $ indexStart , $ indexEnd ) { for ( $ i = $ indexStart ; $ i <= $ indexEnd ; ++ $ i ) { $ this -> clearAt ( $ i ) ; } }
2957	public function confCharacterLength ( $ int ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set length of a character : the device " . "is either not set or opened" , E_USER_WARNING ) ; return false ; } $ int = ( int ) $ int ; if ( $ int < 5 ) { $ int = 5 ; } elseif ( $ int > 8 ) { $ int = 8 ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " cs" . $ int , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " cs" . $ int , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " DATA=" . $ int , $ out ) ; } if ( $ ret === 0 ) { return true ; } trigger_error ( "Unable to set character length : " . $ out [ 1 ] , E_USER_WARNING ) ; return false ; }
2603	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ dictionaryName = Config :: CONFIG_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ currActiveVersion , $ dictionaryName ) ; if ( ! $ dictionary ) { return $ result -> setData ( [ 'status' => false ] ) ; } $ dictionaryItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; foreach ( $ dictionaryItems as $ item ) { if ( $ item -> item_key == Config :: CONFIG_DICTIONARY_KEY && $ item -> item_value == 1 ) { return $ result -> setData ( [ 'status' => true ] ) ; } } return $ result -> setData ( [ 'status' => false ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
10340	public static function checkErrorCode ( $ pValue ) { $ pValue = ( string ) $ pValue ; if ( ! isset ( self :: $ errorCodes [ $ pValue ] ) ) { $ pValue = '#NULL!' ; } return $ pValue ; }
5381	public function getValue ( ) { if ( $ this -> choice === false ) { return $ this -> getDefault ( ) ; } return $ this -> options [ $ this -> choice ] -> getValue ( ) ; }
11556	protected function findParameter ( $ namespace , $ name , $ namespaceParameters ) { foreach ( $ namespaceParameters as $ namespaceParameter ) { if ( $ namespaceParameter -> getNamespace ( ) === $ namespace && $ namespaceParameter -> getName ( ) === $ name ) { return $ namespaceParameter ; } } return null ; }
4701	protected function createCiconia ( InputInterface $ input ) { if ( $ input -> getOption ( 'diagnose' ) ) { $ ciconia = new \ Ciconia \ Diagnose \ Ciconia ( ) ; } else { $ ciconia = new Ciconia ( ) ; } if ( $ input -> getOption ( 'format' ) == 'xhtml' ) { $ ciconia -> setRenderer ( new XhtmlRenderer ( ) ) ; } if ( $ input -> getOption ( 'gfm' ) ) { $ ciconia -> addExtensions ( [ new FencedCodeBlockExtension ( ) , new InlineStyleExtension ( ) , new TaskListExtension ( ) , new WhiteSpaceExtension ( ) , new TableExtension ( ) , new UrlAutoLinkExtension ( ) ] ) ; } return $ ciconia ; }
6570	public function getMessage ( ) { return '[' . $ this -> prefix . ( $ this -> context === null ? '' : ( ' - ' . get_class ( $ this -> context ) ) ) . '] ' . $ this -> msg ; }
4189	protected function dumpConstants ( $ constants ) { $ str = '' ; if ( $ constants && $ this -> debug -> output -> getCfg ( 'outputConstants' ) ) { $ str = '<dt class="constants">constants</dt>' . "\n" ; foreach ( $ constants as $ k => $ value ) { $ str .= '<dd class="constant">' . '<span class="constant-name">' . $ k . '</span>' . ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ value ) . '</dd>' . "\n" ; } } return $ str ; }
1123	public function descendantsAndSelf ( ) { return $ this -> newNestedSetQuery ( ) -> where ( $ this -> getLeftColumnName ( ) , '>=' , $ this -> getLeft ( ) ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getRight ( ) ) ; }
8903	public function delete_by_at ( $ condition , $ time ) { $ this -> prevent_if_not_soft_deletable ( ) ; $ this -> _set_where ( $ condition ) ; return $ this -> _delete ( $ condition , $ time ) ; }
4038	public function getMatchingIds ( ) { $ arrIds = array ( ) ; foreach ( $ this -> arrChildFilters as $ objChildFilter ) { $ arrChildMatches = $ objChildFilter -> getMatchingIds ( ) ; if ( $ arrChildMatches === null ) { return null ; } if ( $ arrChildMatches && $ this -> stopAfterMatch ) { return $ arrChildMatches ; } if ( $ arrChildMatches ) { $ arrIds = array_merge ( $ arrIds , $ arrChildMatches ) ; } } return array_unique ( $ arrIds ) ; }
162	public function addParams ( $ params ) { if ( ! empty ( $ params ) ) { if ( empty ( $ this -> params ) ) { $ this -> params = $ params ; } else { foreach ( $ params as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> params [ ] = $ value ; } else { $ this -> params [ $ name ] = $ value ; } } } } return $ this ; }
4396	public function refund ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsRefund ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ type = \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT ; $ service = $ this -> getBasketService ( $ base , $ type , $ this -> getServiceItem ( ) -> getCode ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> refund ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ attr = array ( 'REFUNDID' => $ response -> getTransactionReference ( ) ) ; $ this -> setAttributes ( $ service , $ attr , 'payment/omnipay' ) ; $ this -> saveOrderBase ( $ base ) ; $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_REFUND ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
2021	public static function findPublishedByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
6585	protected function perform ( callable $ callback , ... $ params ) { $ result = $ callback ( $ this -> curl , ... $ params ) ; if ( curl_errno ( $ this -> curl ) !== CURLE_OK ) throw new CurlException ( $ this -> curl ) ; if ( $ result === false ) throw new CurlException ( "Unable to perform $callback - unknown error." ) ; return $ result ; }
11776	public function getHelper ( ) { if ( $ this -> helper === null ) { $ this -> helper = $ this -> command -> getHelper ( 'question' ) ; } return $ this -> helper ; }
8562	public function createShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_CreateShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_CreateShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_CreateShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8488	public static function getLoad ( ) { $ wmi = Windows :: getInstance ( ) ; $ load = [ ] ; foreach ( $ wmi -> ExecQuery ( "SELECT LoadPercentage FROM Win32_Processor" ) as $ cpu ) { $ load [ ] = $ cpu -> LoadPercentage ; } return round ( array_sum ( $ load ) / count ( $ load ) , 2 ) . "%" ; }
412	public function getPort ( ) { if ( $ this -> _port === null ) { $ serverPort = $ this -> getServerPort ( ) ; $ this -> _port = ! $ this -> getIsSecureConnection ( ) && $ serverPort !== null ? $ serverPort : 80 ; } return $ this -> _port ; }
6721	private function handleTokenResponse ( $ response ) { $ params = ( $ response instanceof OAuthToken ) ? $ response -> getParams ( ) : $ response ; $ status = ArrayHelper :: getValue ( $ params , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ token = ArrayHelper :: getValue ( $ params , 'data' ) ; if ( is_null ( $ token ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ token ; } else { $ message = ArrayHelper :: getValue ( $ params , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
4525	protected function createZoneMemberCountryFromDefinition ( array $ definition ) { $ zoneMember = new ZoneMemberCountry ( ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; $ this -> name = $ definition [ 'name' ] ; $ this -> countryCode = $ definition [ 'country_code' ] ; if ( isset ( $ definition [ 'administrative_area' ] ) ) { $ this -> administrativeArea = $ definition [ 'administrative_area' ] ; } if ( isset ( $ definition [ 'locality' ] ) ) { $ this -> locality = $ definition [ 'locality' ] ; } if ( isset ( $ definition [ 'dependent_locality' ] ) ) { $ this -> dependentLocality = $ definition [ 'dependent_locality' ] ; } if ( isset ( $ definition [ 'included_postal_codes' ] ) ) { $ this -> includedPostalCodes = $ definition [ 'included_postal_codes' ] ; } if ( isset ( $ definition [ 'excluded_postal_codes' ] ) ) { $ this -> excludedPostalCodes = $ definition [ 'excluded_postal_codes' ] ; } } , $ zoneMember , '\CommerceGuys\Zone\Model\ZoneMemberCountry' ) ; $ setValues ( $ definition ) ; return $ zoneMember ; }
7369	private function updatePrice ( StockUnitInterface $ stockUnit ) { $ price = null ; if ( null !== $ item = $ stockUnit -> getSupplierOrderItem ( ) ) { if ( null === $ order = $ item -> getOrder ( ) ) { throw new StockLogicException ( "Supplier order item's order must be set at this point." ) ; } $ currency = $ order -> getCurrency ( ) -> getCode ( ) ; $ date = $ order -> getPaymentDate ( ) ; if ( $ date > new \ DateTime ( ) ) { $ date = null ; } $ price = $ this -> currencyConverter -> convert ( $ item -> getNetPrice ( ) , $ currency , null , $ date ) ; } if ( 0 !== Money :: compare ( $ stockUnit -> getNetPrice ( ) , $ price , $ this -> currencyConverter -> getDefaultCurrency ( ) ) ) { $ stockUnit -> setNetPrice ( $ price ) ; return true ; } return false ; }
7426	private function isValid ( $ source = '' ) { if ( empty ( $ source ) ) { return false ; } else { $ extension = substr ( $ source , - 3 ) ; if ( strtolower ( $ extension ) !== 'swf' ) { return false ; } } return true ; }
3820	private function perform ( $ table , Request $ request , $ metaModel , $ parentId ) { $ activate = ( bool ) $ request -> request -> get ( 'activate' ) ; $ query = $ this -> connection -> createQueryBuilder ( ) -> insert ( $ table ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( $ this -> knowsAttribute ( $ attribute ) || ! ( $ this -> accepts ( $ attribute ) && $ this -> isAttributeSubmitted ( $ attribute -> get ( 'id' ) , $ request ) ) ) { continue ; } $ data = [ ] ; foreach ( $ this -> createEmptyDataFor ( $ attribute , $ parentId , $ activate , $ this -> startSort ) as $ key => $ value ) { $ data [ $ key ] = ':' . $ key ; $ query -> setParameter ( $ key , $ value ) ; } $ query -> values ( $ data ) -> execute ( ) ; $ this -> startSort += 128 ; } $ this -> purger -> purge ( ) ; }
2293	public static function getThemes ( ) { $ arrReturn = array ( ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrThemes = scan ( $ rootDir . '/system/themes' ) ; foreach ( $ arrThemes as $ strTheme ) { if ( strncmp ( $ strTheme , '.' , 1 ) === 0 || ! is_dir ( $ rootDir . '/system/themes/' . $ strTheme ) ) { continue ; } $ arrReturn [ $ strTheme ] = $ strTheme ; } return $ arrReturn ; }
2071	private function getDateAndTime ( CalendarEventsModel $ objEvent , PageModel $ objPage , $ intStartTime , $ intEndTime , $ span ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) ; if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> dateFormat , $ intEndTime ) ; } $ strTime = '' ; if ( $ objEvent -> addTime ) { if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> datimFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> datimFormat , $ intEndTime ) ; } elseif ( $ intStartTime == $ intEndTime ) { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) ; } else { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> timeFormat , $ intEndTime ) ; } } return array ( $ strDate , $ strTime ) ; }
5765	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ administrators = $ this -> administratorsEntityMapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) , null , $ this -> authentication , $ this -> authorization ) ; } catch ( QueryFailureException $ e ) { $ administrators = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ administrators ) ; }
1083	private function expect ( $ kind ) { $ token = $ this -> lexer -> token ; if ( $ token -> kind === $ kind ) { $ this -> lexer -> advance ( ) ; return $ token ; } throw new SyntaxError ( $ this -> lexer -> source , $ token -> start , sprintf ( 'Expected %s, found %s' , $ kind , $ token -> getDescription ( ) ) ) ; }
6080	public function updateProperties ( $ id , array $ properties ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'properties' => $ properties ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/media/' . $ id . '/properties' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
2683	public function getWafSettings ( $ id ) { $ url = $ this -> _getWafEndpoint ( ) . $ id ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
11133	protected function calculate ( ) { $ action = false ; $ actions = 0 ; if ( $ this -> delete ) { $ actions += 1 ; $ action = 'DELETE' ; } if ( ! empty ( $ this -> inserts ) ) { $ actions += 1 ; $ action = 'INSERT' ; } if ( ! empty ( $ this -> updates ) ) { $ actions += 1 ; $ action = 'UPDATE' ; } if ( ! empty ( $ this -> selects ) ) { $ actions += 1 ; $ action = 'SELECT' ; } if ( ! empty ( $ this -> create ) ) { $ actions += 1 ; $ action = 'CREATE' ; } if ( $ actions > 1 ) { throw new \ Exception ( "More than one query action specified! When using Cora's query builder class, only one type of query (select, update, delete, insert) can be done at a time." ) ; } else { $ calcMethod = 'calculate' . $ action ; $ this -> $ calcMethod ( ) ; } }
5122	private function setAuthorizationHeader ( string $ accessToken ) : self { $ this -> accessToken = $ accessToken ; $ this -> options -> set ( 'default_headers' , array_merge ( $ this -> options -> get ( 'default_headers' ) , [ 'Authorization' => 'Bearer ' . $ accessToken , ] ) ) ; return $ this ; }
979	protected function response ( Request $ request , Closure $ next ) { $ response = $ next ( $ request ) ; if ( Config :: get ( 'shopify-app.esdk_enabled' ) && ( $ request -> ajax ( ) || $ request -> expectsJson ( ) || $ request -> isJson ( ) ) === false ) { if ( ( $ response instanceof BaseResponse ) === false ) { $ response = new Response ( $ response ) ; } $ response -> headers -> set ( 'P3P' , 'CP="Not used"' ) ; $ response -> headers -> remove ( 'X-Frame-Options' ) ; } return $ response ; }
2058	public function makeRedirectPageMandatory ( Contao \ DataContainer $ dc ) { $ objPage = $ this -> Database -> prepare ( "SELECT * FROM " . $ dc -> table . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objPage -> numRows && $ objPage -> type == 'logout' ) { $ GLOBALS [ 'TL_DCA' ] [ 'tl_page' ] [ 'fields' ] [ 'jumpTo' ] [ 'eval' ] [ 'mandatory' ] = true ; } }
12947	protected function ownerHasTagAttribute ( ) { if ( $ this -> _hasTagAttribute === null ) { $ this -> _hasTagAttribute = $ this -> owner -> hasAttribute ( 'tags' ) ; } return $ this -> _hasTagAttribute ; }
5436	protected function getParameterSignatures ( $ method ) { $ signatures = [ ] ; $ parameters = $ method -> getParameters ( ) ; foreach ( $ parameters as $ parameter ) { $ signature = '' ; $ signature .= $ this -> getParameterTypeHint ( $ parameter ) ; if ( $ parameter -> isPassedByReference ( ) ) { $ signature .= '&' ; } $ isVariadic = ( PHP_VERSION_ID >= 50600 ) && $ parameter -> isVariadic ( ) ; if ( $ isVariadic ) { $ signature .= '...' ; } $ signature .= '$' . $ parameter -> getName ( ) ; if ( ! $ isVariadic ) { if ( $ parameter -> isDefaultValueAvailable ( ) ) { $ signature .= ' = ' . var_export ( $ parameter -> getDefaultValue ( ) , true ) ; } elseif ( $ parameter -> isOptional ( ) ) { $ signature .= ' = null' ; } } $ signatures [ ] = $ signature ; } return implode ( ', ' , $ signatures ) ; }
6325	public function stop ( ) { $ fp = @ fopen ( $ this -> _file , 'w' ) ; fwrite ( $ fp , ob_get_contents ( ) ) ; fclose ( $ fp ) ; ob_end_flush ( ) ; }
5677	protected function stringDiffersAt ( $ first , $ second ) { if ( ! $ first || ! $ second ) { return 0 ; } if ( strlen ( $ first ) < strlen ( $ second ) ) { list ( $ first , $ second ) = array ( $ second , $ first ) ; } $ position = 0 ; $ step = strlen ( $ first ) ; while ( $ step > 1 ) { $ step = ( integer ) ( ( $ step + 1 ) / 2 ) ; if ( strncmp ( $ first , $ second , $ position + $ step ) == 0 ) { $ position += $ step ; } } return $ position ; }
2738	private function setToken ( $ token ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_API_KEY , $ token ) ; $ this -> output -> writeln ( '<info>Token updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
9033	protected function mapField ( $ field ) { if ( ! $ this -> classMetadata -> hasField ( $ field ) ) { $ this -> classMetadata -> mapField ( [ 'fieldName' => $ field , 'type' => 'datetime' , 'nullable' => true , ] ) ; } }
11274	public function install ( ) : Migrate { Whois :: print ( $ this -> getNotify ( ) ) ; $ this -> exists ( ) || $ this -> migrationRepository -> createRepository ( ) ; return $ this ; }
12313	public function toArray ( ) { $ data = [ "uuid" => $ this -> uuid , "code" => $ this -> code , "modules" => $ this -> modules , "vars" => $ this -> vars , ] ; foreach ( [ 'modules' , 'vars' ] as $ key ) { if ( ! array_key_exists ( $ key , $ data ) ) { continue ; } if ( empty ( $ data [ $ key ] ) ) { $ data [ $ key ] = new \ stdClass ( ) ; } } return $ data ; }
347	public static function removeCssClass ( & $ options , $ class ) { if ( isset ( $ options [ 'class' ] ) ) { if ( is_array ( $ options [ 'class' ] ) ) { $ classes = array_diff ( $ options [ 'class' ] , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = $ classes ; } } else { $ classes = preg_split ( '/\s+/' , $ options [ 'class' ] , - 1 , PREG_SPLIT_NO_EMPTY ) ; $ classes = array_diff ( $ classes , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = implode ( ' ' , $ classes ) ; } } } }
3024	public function getBlogPosts ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/posts' ) ; if ( $ options && isset ( $ options [ 'type' ] ) ) { $ path .= '/' . $ options [ 'type' ] ; unset ( $ options [ 'type' ] ) ; } return $ this -> getRequest ( $ path , $ options , true ) ; }
4782	public function removeWidgetConfig ( string $ widgetId , array $ config = [ ] ) { foreach ( $ config as $ id => $ content ) { if ( isset ( $ this -> config [ $ widgetId ] [ $ id ] ) ) { unset ( $ this -> config [ $ widgetId ] [ $ id ] ) ; } } return $ this ; }
10426	private function body ( ResponseInterface $ response ) : ResponseInterface { if ( ! in_array ( $ response -> getStatusCode ( ) , $ this -> responseIsEmpty ) ) { $ stream = $ response -> getBody ( ) ; if ( $ stream -> isSeekable ( ) ) { $ stream -> rewind ( ) ; } $ bufferLenght = ( ! $ response -> getHeaderLine ( 'Content-Length' ) ) ? $ stream -> getSize ( ) : $ response -> getHeaderLine ( 'Content-Length' ) ; if ( isset ( $ bufferLenght ) ) { $ lengthToRead = $ bufferLenght ; while ( $ lengthToRead > 0 && ! $ stream -> eof ( ) ) { $ data = $ stream -> read ( min ( $ this -> sizeLimit , $ lengthToRead ) ) ; echo $ data ; $ lengthToRead -= strlen ( $ data ) ; } } else { while ( ! $ stream -> eof ( ) ) { echo $ stream -> read ( $ this -> size ) ; } } } return $ response ; }
3666	public function convertParameter ( $ arrMatch ) { list ( $ strSource , $ strQuery ) = explode ( '?' , $ arrMatch [ 1 ] , 2 ) ; parse_str ( $ strQuery , $ arrArgs ) ; $ arrName = ( array ) $ arrArgs [ 'name' ] ; $ var = $ this -> getValueFromSource ( $ strSource , array_shift ( $ arrName ) , $ arrArgs ) ; $ index = 0 ; $ count = count ( $ arrName ) ; while ( $ index < $ count && is_array ( $ var ) ) { $ var = $ var [ $ arrName [ $ index ++ ] ] ; } if ( $ index != $ count || $ var === null ) { if ( array_key_exists ( 'default' , $ arrArgs ) && ( null !== $ arrArgs [ 'default' ] ) ) { $ this -> addParameter ( $ arrArgs [ 'default' ] ) ; return '?' ; } else { return 'NULL' ; } } if ( ! isset ( $ arrArgs [ 'aggregate' ] ) ) { $ this -> addParameter ( $ var ) ; return '?' ; } return $ this -> convertParameterAggregate ( $ var , $ arrArgs ) ; }
6286	public static function hash ( $ s ) { $ h = 5381 ; $ len = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ h5 = ( $ h << 5 ) & 0xffffffff ; $ sum = ( $ h & 0x3fffffff ) + ( $ h5 & 0x3fffffff ) ; $ h = ( ( $ sum & 0x40000000 ? 1 : 0 ) + ( $ h & 0x80000000 ? 2 : 0 ) + ( $ h & 0x40000000 ? 1 : 0 ) + ( $ h5 & 0x80000000 ? 2 : 0 ) + ( $ h5 & 0x40000000 ? 1 : 0 ) ) << 30 | ( $ sum & 0x3fffffff ) ; $ h ^= ord ( $ s [ $ i ] ) ; $ h &= 0xffffffff ; } return $ h ; }
10784	public function parse ( UriInterface $ uri ) : ParsedURL { $ matches = [ ] ; if ( preg_match ( $ this -> pattern , $ uri -> getPath ( ) , $ matches ) === 0 ) { throw new InvalidRequestURLException ( "Unable to parse request path: did not match regex" ) ; } if ( ! ( $ endpoint = $ matches [ "endpoint" ] ?? null ) ) { throw new InvalidRequestURLException ( "Unable to match endpoint in url" ) ; } $ element = $ matches [ "element" ] ?? null ; $ version = $ matches [ "version" ] ?? null ; $ apiKey = $ matches [ "apiKey" ] ?? null ; $ acceptableMimeTypes = [ ] ; if ( ( $ acceptableExtension = $ matches [ "acceptableExtension" ] ?? null ) ) { if ( ! $ this -> MIMEProvider ) { throw new UnableToParseURLException ( "Unable to accept acceptable extensions" ) ; } else { try { $ acceptableMimeTypes [ ] = $ this -> MIMEProvider -> provideMIME ( $ acceptableExtension ) ; } catch ( UnableToProvideMIMEException $ exception ) { throw new UnableToParseURLException ( $ exception -> getMessage ( ) ) ; } } } return new ParsedURL ( $ endpoint , $ element , $ version , $ apiKey , $ acceptableMimeTypes , $ uri -> getQuery ( ) ) ; }
2085	public static function addFiles ( $ files ) { foreach ( $ files as $ name => $ file ) { self :: addFile ( $ name , $ file ) ; } }
7862	protected function setPipesOfWorkflow ( $ workflow ) { $ pipes = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ this -> pipes = array_map ( function ( $ pipe ) { $ chunks = explode ( '\\' , $ pipe ) ; return end ( $ chunks ) ; } , $ pipes ) ; $ this -> geometry -> setPipes ( $ this -> pipes ) ; }
12433	private function getMaxPercentForInfinityBonus ( $ cfgParams , $ scheme ) { $ result = 0 ; $ params = $ cfgParams [ $ scheme ] ; foreach ( $ params as $ item ) { $ percent = $ item -> getInfinity ( ) ; if ( $ percent > $ result ) { $ result = $ percent ; } } return $ result ; }
9975	private static function fillBuiltInFormatCodes ( ) { if ( self :: $ builtInFormats === null ) { self :: $ builtInFormats = [ ] ; self :: $ builtInFormats [ 0 ] = self :: FORMAT_GENERAL ; self :: $ builtInFormats [ 1 ] = '0' ; self :: $ builtInFormats [ 2 ] = '0.00' ; self :: $ builtInFormats [ 3 ] = '#,##0' ; self :: $ builtInFormats [ 4 ] = '#,##0.00' ; self :: $ builtInFormats [ 9 ] = '0%' ; self :: $ builtInFormats [ 10 ] = '0.00%' ; self :: $ builtInFormats [ 11 ] = '0.00E+00' ; self :: $ builtInFormats [ 12 ] = '# ?/?' ; self :: $ builtInFormats [ 13 ] = '# ??/??' ; self :: $ builtInFormats [ 14 ] = 'm/d/yyyy' ; self :: $ builtInFormats [ 15 ] = 'd-mmm-yy' ; self :: $ builtInFormats [ 16 ] = 'd-mmm' ; self :: $ builtInFormats [ 17 ] = 'mmm-yy' ; self :: $ builtInFormats [ 18 ] = 'h:mm AM/PM' ; self :: $ builtInFormats [ 19 ] = 'h:mm:ss AM/PM' ; self :: $ builtInFormats [ 20 ] = 'h:mm' ; self :: $ builtInFormats [ 21 ] = 'h:mm:ss' ; self :: $ builtInFormats [ 22 ] = 'm/d/yyyy h:mm' ; self :: $ builtInFormats [ 37 ] = '#,##0_);(#,##0)' ; self :: $ builtInFormats [ 38 ] = '#,##0_);[Red](#,##0)' ; self :: $ builtInFormats [ 39 ] = '#,##0.00_);(#,##0.00)' ; self :: $ builtInFormats [ 40 ] = '#,##0.00_);[Red](#,##0.00)' ; self :: $ builtInFormats [ 44 ] = '_("$"* #,##0.00_);_("$"* \(#,##0.00\);_("$"* "-"??_);_(@_)' ; self :: $ builtInFormats [ 45 ] = 'mm:ss' ; self :: $ builtInFormats [ 46 ] = '[h]:mm:ss' ; self :: $ builtInFormats [ 47 ] = 'mm:ss.0' ; self :: $ builtInFormats [ 48 ] = '##0.0E+0' ; self :: $ builtInFormats [ 49 ] = '@' ; self :: $ builtInFormats [ 27 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 30 ] = 'm/d/yy' ; self :: $ builtInFormats [ 36 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 50 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 57 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 59 ] = 't0' ; self :: $ builtInFormats [ 60 ] = 't0.00' ; self :: $ builtInFormats [ 61 ] = 't#,##0' ; self :: $ builtInFormats [ 62 ] = 't#,##0.00' ; self :: $ builtInFormats [ 67 ] = 't0%' ; self :: $ builtInFormats [ 68 ] = 't0.00%' ; self :: $ builtInFormats [ 69 ] = 't# ?/?' ; self :: $ builtInFormats [ 70 ] = 't# ??/??' ; self :: $ flippedBuiltInFormats = array_flip ( self :: $ builtInFormats ) ; } }
4169	public function tokenizePackageInfo ( ) { $ info = explode ( ':' , $ this -> argument ( 'package' ) ) ; return [ 'name' => $ info [ 0 ] , 'version' => ( count ( $ info ) > 1 ) ? last ( $ info ) : null , ] ; }
5826	public function setJson ( $ toggle ) { $ this -> setEncoding ( $ toggle ? Request :: ENCODING_JSON : Request :: ENCODING_QUERY ) ; return $ this ; }
1728	public function save ( ) { $ arrFields = $ this -> Database -> getFieldNames ( $ this -> strTable ) ; $ arrSet = array_intersect_key ( $ this -> arrData , array_flip ( $ arrFields ) ) ; $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " %s WHERE id=?" ) -> set ( $ arrSet ) -> execute ( $ this -> id ) ; }
9831	public function resource ( $ modelName , $ controller ) { if ( php_sapi_name ( ) == 'cli' ) { return ; } if ( ! class_exists ( $ controller ) ) { throw new ExpectedAujaControllerException ( $ controller . ' does not exist.' ) ; } if ( ! is_subclass_of ( $ controller , 'Label305\AujaLaravel\Controllers\Interfaces\AujaControllerInterface' ) ) { throw new ExpectedAujaControllerException ( $ controller . ' does not implement Label305\AujaLaravel\Controllers\Interfaces\AujaControllerInterface' ) ; } $ this -> registerIndex ( $ modelName , $ controller ) ; $ this -> registerMenu ( $ modelName , $ controller ) ; $ this -> registerShowMenu ( $ modelName , $ controller ) ; $ this -> registerCreate ( $ modelName , $ controller ) ; $ this -> registerStore ( $ modelName , $ controller ) ; $ this -> registerShow ( $ modelName , $ controller ) ; $ this -> registerEdit ( $ modelName , $ controller ) ; $ this -> registerUpdate ( $ modelName , $ controller ) ; $ this -> registerDelete ( $ modelName , $ controller ) ; $ model = $ this -> auja -> getModel ( ucfirst ( str_singular ( camel_case ( $ modelName ) ) ) ) ; $ relations = $ this -> auja -> getRelationsForModel ( $ model ) ; foreach ( $ relations as $ relation ) { $ otherModelName = $ relation -> getRight ( ) -> getName ( ) ; if ( $ relation -> getType ( ) == Relation :: BELONGS_TO ) { $ this -> registerBelongsToAssociationMenu ( $ modelName , $ otherModelName , $ controller ) ; } else { $ this -> registerAssociation ( $ modelName , $ otherModelName , $ controller ) ; $ this -> registerAssociationMenu ( $ modelName , $ otherModelName , $ controller ) ; $ this -> registerCreateAssociation ( $ modelName , $ otherModelName , $ controller ) ; } } }
4712	public function escapeHtml ( $ option = ENT_QUOTES ) { $ this -> text = htmlspecialchars ( $ this -> text , $ option , 'UTF-8' , false ) ; return $ this ; }
3890	protected function buildFilterParamsFor ( \ DC_Table $ dataContainer , $ elementName ) { if ( ! $ this -> requestStack -> getCurrentRequest ( ) -> query -> get ( 'act' ) ) { return ; } $ filterId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'c.metamodel_filtering' ) -> from ( static :: $ tableName , 'c' ) -> join ( 'c' , 'tl_metamodel' , 'mm' , 'mm.id=c.metamodel' ) -> where ( 'c.id=:id' ) -> setParameter ( 'id' , $ dataContainer -> id ) -> andWhere ( 'c.type=:type' ) -> setParameter ( 'type' , $ elementName ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_COLUMN ) ; if ( ! $ filterId ) { unset ( $ GLOBALS [ 'TL_DCA' ] [ static :: $ tableName ] [ 'fields' ] [ 'metamodel_filterparams' ] ) ; return ; } $ collection = $ this -> filterFactory -> createCollection ( $ filterId ) ; $ dca = $ collection -> getParameterDCA ( ) ; foreach ( $ dca as $ fieldName => $ subField ) { $ options = [ ] ; foreach ( $ subField [ 'options' ] as $ key => $ value ) { $ options [ $ this -> loadCallback ( $ key ) ] = $ value ; } $ dca [ $ fieldName ] [ 'options' ] = $ options ; $ dca [ $ fieldName ] [ 'save_callback' ] [ ] = [ static :: class , 'saveCallback' ] ; $ dca [ $ fieldName ] [ 'load_callback' ] [ ] = [ static :: class , 'loadCallback' ] ; } $ GLOBALS [ 'TL_DCA' ] [ static :: $ tableName ] [ 'fields' ] [ 'metamodel_filterparams' ] [ 'eval' ] [ 'subfields' ] = $ dca ; }
4096	public function build ( ) { $ built = array ( ) ; if ( $ this -> fieldname ) { $ built [ $ this -> fieldname ] = array ( ) ; foreach ( array ( "from" , "to" , "includeLower" , "includeUpper" , "boost" ) as $ opt ) { if ( $ this -> $ opt !== null ) $ built [ $ this -> fieldname ] [ $ opt ] = $ this -> $ opt ; } if ( count ( $ built [ $ this -> fieldname ] ) == 0 ) throw new \ ElasticSearch \ Exception ( "Empty RangeQuery cant be created" ) ; } return $ built ; }
9368	protected function globals ( Configuration $ config ) { $ cookies = $ config -> get ( 'app.http.cookies' , array ( ) ) ; $ files = $ config -> get ( 'app.http.files' , array ( ) ) ; $ get = $ config -> get ( 'app.http.get' , array ( ) ) ; $ post = $ config -> get ( 'app.http.post' , array ( ) ) ; $ server = $ config -> get ( 'app.http.server' , $ this -> server ( ) ) ; return array ( $ server , $ cookies , $ get , $ files , $ post ) ; }
8258	protected function finishAuthentication ( Request $ httpRequest ) { $ sessionCode = $ this -> session -> get ( "oauth2state" ) ; $ this -> session -> remove ( "oauth2state" ) ; if ( $ httpRequest -> query -> get ( "state" ) !== $ sessionCode ) { $ this -> onStateMismatch ( ) ; } if ( $ httpRequest -> query -> has ( "error" ) ) { $ this -> onOAuthError ( $ httpRequest -> query -> get ( "error" ) ) ; } if ( ! $ httpRequest -> query -> has ( "code" ) ) { $ this -> onOAuthError ( "no_code" ) ; } try { $ accessToken = $ this -> provider -> getAccessToken ( 'authorization_code' , [ 'code' => $ httpRequest -> query -> get ( "code" ) , ] ) ; $ resourceOwner = $ this -> provider -> getResourceOwner ( $ accessToken ) ; $ this -> saveLoginInfo ( $ resourceOwner ) ; } catch ( IdentityProviderException $ e ) { $ this -> onOauthResourceError ( $ e ) ; } }
5852	protected function processData ( ) { $ close = GeneralUtility :: _GP ( 'closeDoc' ) ; $ save = GeneralUtility :: _GP ( '_savedok' ) ; $ saveAndClose = GeneralUtility :: _GP ( '_saveandclosedok' ) ; if ( $ save || $ saveAndClose ) { $ table = static :: virtualTable ; $ id = static :: virtualRecordId ; $ field = 'rulesets' ; $ inputData_tmp = GeneralUtility :: _GP ( 'data' ) ; $ data = $ inputData_tmp [ $ table ] [ $ id ] ; if ( count ( $ inputData_tmp [ $ table ] ) > 1 ) { foreach ( $ inputData_tmp [ $ table ] as $ key => $ values ) { if ( $ key === $ id ) continue ; ArrayUtility :: mergeRecursiveWithOverrule ( $ data , $ values ) ; } } $ newConfig = $ this -> config ; ArrayUtility :: mergeRecursiveWithOverrule ( $ newConfig , $ data ) ; $ ffValue = & $ data [ $ field ] ; if ( $ ffValue ) { $ actionCMDs = GeneralUtility :: _GP ( '_ACTION_FLEX_FORMdata' ) ; if ( is_array ( $ actionCMDs [ $ table ] [ $ id ] [ $ field ] [ 'data' ] ) ) { $ dataHandler = new CustomDataHandler ( ) ; $ dataHandler -> _ACTION_FLEX_FORMdata ( $ ffValue [ 'data' ] , $ actionCMDs [ $ table ] [ $ id ] [ $ field ] [ 'data' ] ) ; } $ this -> persistFlexForm ( $ ffValue [ 'data' ] ) ; $ newConfig [ $ field ] = $ ffValue ; } $ localconfConfig = $ newConfig ; $ localconfConfig [ 'conversion_mapping' ] = implode ( ',' , GeneralUtility :: trimExplode ( LF , $ localconfConfig [ 'conversion_mapping' ] , true ) ) ; if ( $ this -> persistConfiguration ( $ localconfConfig ) ) { $ this -> config = $ newConfig ; } } if ( $ close || $ saveAndClose ) { $ closeUrl = BackendUtility :: getModuleUrl ( 'tools_ExtensionmanagerExtensionmanager' ) ; \ TYPO3 \ CMS \ Core \ Utility \ HttpUtility :: redirect ( $ closeUrl ) ; } }
7945	public function ipDeleteMonitoringNotification ( $ id , $ ip , $ notificationId ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Missing parameter $ip.' ) ; if ( ! $ notificationId ) throw new BadMethodCallException ( 'Missing parameter $notificationId.' ) ; try { $ r = $ this -> delete ( 'xdsl/' . $ id . '/ips/' . $ ip . '/monitoringNotifications/' . $ notificationId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
4550	public function setAssigneeLike ( ? string $ assigneeLike ) { $ this -> assigneeLike = $ assigneeLike ; $ this -> _assigneeLike = null !== $ assigneeLike ; return $ this ; }
8881	private function isValidRelativePath ( string $ relativePath , string $ cwd ) : bool { $ valid = false ; if ( './' === substr ( $ relativePath , 0 , 2 ) ) { $ tmpPath = $ cwd . DIRECTORY_SEPARATOR . substr ( $ relativePath , 2 , strlen ( $ relativePath ) ) ; $ valid = $ this -> isValidFullPath ( $ tmpPath ) ; } return $ valid ; }
12793	public function create ( $ params = array ( ) ) { $ serverConfig = array_merge ( $ this -> defaults , $ params ) ; try { $ response = $ this -> client -> request -> post ( $ this -> apiEndpoint . "/droplets" , [ 'json' => $ serverConfig ] ) ; if ( 202 != $ this -> client -> getStatus ( $ response ) ) { throw new Exception ( 'Unable to create server.' ) ; } } catch ( Exception $ e ) { echo 'Unable to create server because ' . $ e -> getMessage ( ) ; } return $ this -> client -> getBody ( $ response ) ; }
1826	public function mergeRow ( array $ arrData ) { foreach ( $ arrData as $ k => $ v ) { if ( strpos ( $ k , '__' ) !== false ) { continue ; } if ( ! isset ( $ this -> arrModified [ $ k ] ) ) { $ this -> arrData [ $ k ] = $ v ; } } return $ this ; }
4669	protected function beforeGeneration ( ) { $ this -> config -> getLogger ( ) -> startBreak ( 'XSD Parsing' ) ; $ this -> XSDMap = XSDMapGenerator :: buildXSDMap ( $ this -> config ) ; $ this -> config -> getLogger ( ) -> endBreak ( 'XSD Parsing' ) ; $ this -> config -> getLogger ( ) -> startBreak ( 'Generator Class Initialization' ) ; self :: _initializeClasses ( $ this -> config ) ; $ this -> autoloadMap = new AutoloaderTemplate ( $ this -> config ) ; $ this -> mapTemplate = new ParserMapTemplate ( $ this -> config ) ; $ this -> autoloadMap -> addEntry ( $ this -> mapTemplate -> getClassName ( ) , $ this -> mapTemplate -> getClassPath ( ) ) ; $ helperTemplate = new HelperTemplate ( $ this -> config ) ; $ helperTemplate -> writeToFile ( ) ; $ this -> autoloadMap -> addEntry ( $ helperTemplate -> getClassName ( ) , $ helperTemplate -> getClassPath ( ) ) ; $ this -> config -> getLogger ( ) -> endBreak ( 'Generator Class Initialization' ) ; }
7676	function TbsQuickLoad ( $ NameLst ) { if ( ! is_array ( $ NameLst ) ) $ NameLst = array ( $ NameLst ) ; $ nbr = 0 ; $ TBS = & $ this -> TBS ; foreach ( $ NameLst as $ FileName ) { $ idx = $ this -> FileGetIdx ( $ FileName ) ; if ( ( ! isset ( $ this -> TbsStoreLst [ $ idx ] ) ) && ( ! isset ( $ this -> TbsNoField [ $ idx ] ) ) ) { $ txt = $ this -> FileRead ( $ idx , true ) ; if ( strpos ( $ txt , $ TBS -> _ChrOpen ) !== false ) { $ nbr ++ ; if ( $ nbr == 1 ) { $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ SaveIdx = $ this -> TbsCurrIdx ; $ SaveName = $ TBS -> OtbsCurrFile ; $ this -> TbsSwitchMode ( true ) ; } $ this -> TbsStorePark ( ) ; $ TBS -> Source = $ txt ; unset ( $ txt ) ; $ TBS -> OtbsCurrFile = $ FileName ; $ this -> TbsCurrIdx = $ idx ; if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } else { $ this -> TbsNoField [ $ idx ] = true ; } } } if ( $ nbr > 0 ) { $ this -> TbsSwitchMode ( false ) ; $ this -> TbsStorePark ( ) ; $ this -> TbsStoreLoad ( $ SaveIdx , $ SaveName ) ; } return $ nbr ; }
283	private function findFixtures ( array $ fixtures = [ ] ) { $ fixturesPath = $ this -> getFixturePath ( ) ; $ filesToSearch = [ '*Fixture.php' ] ; $ findAll = ( $ fixtures === [ ] ) ; if ( ! $ findAll ) { $ filesToSearch = [ ] ; foreach ( $ fixtures as $ fileName ) { $ filesToSearch [ ] = $ fileName . 'Fixture.php' ; } } $ files = FileHelper :: findFiles ( $ fixturesPath , [ 'only' => $ filesToSearch ] ) ; $ foundFixtures = [ ] ; foreach ( $ files as $ fixture ) { $ foundFixtures [ ] = $ this -> getFixtureRelativeName ( $ fixture ) ; } return $ foundFixtures ; }
5218	protected static function hostname ( ) { return function ( Binder $ binder ) { if ( DIRECTORY_SEPARATOR === '\\' ) { $ fq = php_uname ( 'n' ) ; if ( isset ( $ _SERVER [ 'USERDNSDOMAIN' ] ) ) { $ fq .= '.' . $ _SERVER [ 'USERDNSDOMAIN' ] ; } } else { $ fq = exec ( 'hostname -f' ) ; } $ binder -> bindConstant ( 'stubbles.hostname.nq' ) -> to ( php_uname ( 'n' ) ) ; $ binder -> bindConstant ( 'stubbles.hostname.fq' ) -> to ( $ fq ) ; } ; }
5108	private function appendDesc ( & $ column ) : void { if ( is_array ( $ column ) ) { foreach ( $ column as & $ col ) { $ col = "$col DESC" ; } } else { $ column = [ "$column DESC" ] ; } }
5816	public function onAfterWrite ( ) { parent :: onAfterWrite ( ) ; $ types = unserialize ( $ this -> TagTypes ) ; $ changed = $ this -> getChangedFields ( ) ; foreach ( $ this -> service -> getFusionTagTypes ( ) as $ type => $ field ) { if ( isset ( $ types [ $ type ] ) ) { $ newTypes = array ( ) ; if ( isset ( $ changed [ 'TagTypes' ] ) ) { $ before = unserialize ( $ changed [ 'TagTypes' ] [ 'before' ] ) ; $ after = unserialize ( $ changed [ 'TagTypes' ] [ 'after' ] ) ; $ newTypes = is_array ( $ before ) ? array_diff ( $ after , $ before ) : $ after ; } if ( ( isset ( $ changed [ 'ID' ] ) || isset ( $ newTypes [ $ type ] ) ) && ! ( $ type :: get ( ) -> filter ( $ field , $ this -> Title ) -> first ( ) ) ) { $ tag = $ type :: create ( ) ; $ tag -> $ field = $ this -> Title ; $ tag -> FusionTagID = $ this -> ID ; $ tag -> write ( ) ; } else if ( ! isset ( $ changed [ 'ID' ] ) && isset ( $ changed [ 'Title' ] ) && ( $ existing = $ type :: get ( ) -> filter ( $ field , $ changed [ 'Title' ] [ 'before' ] ) ) ) { foreach ( $ existing as $ tag ) { $ tag -> $ field = $ changed [ 'Title' ] [ 'after' ] ; $ tag -> write ( ) ; } } } } if ( ! isset ( $ changed [ 'ID' ] ) && isset ( $ changed [ 'Title' ] ) ) { $ this -> service -> updateTagging ( $ this -> ID ) ; } }
4219	private function clearSummary ( $ flags ) { $ return = null ; $ clearErrors = $ flags & Debug :: CLEAR_SUMMARY_ERRORS ; if ( $ flags & Debug :: CLEAR_SUMMARY ) { $ return = 'summary (' . ( $ clearErrors ? 'incl errors' : 'sans errors' ) . ')' ; $ curPriority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; foreach ( \ array_keys ( $ this -> data [ 'logSummary' ] ) as $ priority ) { $ entriesKeep = array ( ) ; if ( $ priority === $ curPriority ) { $ curDepth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] [ $ priority ] as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entriesKeep = $ this -> debug -> internal -> getCurrentGroups ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ curDepth ) ; } else { $ this -> data [ 'groupStacks' ] [ $ priority ] = array ( ) ; } $ this -> clearLogHelper ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ clearErrors , $ entriesKeep ) ; } } elseif ( $ clearErrors ) { $ return = 'summary errors' ; } return $ return ; }
9926	private function handleArrays ( Parameters $ params , array $ permitted = array ( ) ) { foreach ( $ permitted as $ key => $ allowed ) { if ( is_array ( $ allowed ) && $ params -> hasKey ( $ key ) ) { $ value = $ params [ $ key ] ; if ( $ value instanceof Parameters ) { $ this -> filter ( $ value , $ allowed ) ; } else { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } } }
6554	public function removeLineFromFile ( $ line , $ fh ) { $ lines = array ( ) ; $ found = false ; rewind ( $ fh ) ; while ( ( $ buffer = fgets ( $ fh , 4096 ) ) !== false ) { $ buffer = trim ( $ buffer ) ; if ( $ line === $ buffer ) { $ found = true ; continue ; } $ lines [ ] = $ buffer ; } if ( ! $ found ) { throw new LineNotFoundException ( sprintf ( 'Line %s can not be found' , $ line ) ) ; } ftruncate ( $ fh , 0 ) ; rewind ( $ fh ) ; foreach ( $ lines as $ ln ) { if ( fwrite ( $ fh , $ ln . PHP_EOL ) === false ) { throw new \ Exception ( sprintf ( 'Can\'t write %s to file' , $ ln ) ) ; } } }
12835	private function generateFactoryCreatorMethod ( FactoredService $ service ) : string { $ factoryMethod = $ service -> getFactoryMethod ( ) ; $ taggedAs = implode ( ', ' , $ service -> getTags ( ) ) ; $ classNormalized = $ this -> normalizeFqcn ( $ service -> getClass ( ) ) ; $ optional = $ service -> getFactoryMethod ( ) -> isOptional ( ) ? '?' : '' ; if ( $ service -> isSingleton ( ) ) { return <<<PHP /** * Get the factored service "{$service->getId()}" (Singleton) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : {$optional}{$classNormalized} { if (isset(\$this->singletons['{$service->getId()}'])) { return \$this->singletons['{$service->getId()}']; } /** @noinspection OneTimeUseVariablesInspection */ \$service = \$this->singletons['{$service->getId()}'] = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; } return <<<PHP /** * Get a fresh instance of service "{$service->getId()}" (Prototype) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { \$this->prototypes['{$service->getId()}'] = (\$this->prototypes['{$service->getId()}'] ?? 0) + 1; /** @noinspection OneTimeUseVariablesInspection */ \$service = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; }
8798	public function registerDirectives ( BladeCompiler $ blade ) { $ keywords = [ "namespace" , "use" , ] ; foreach ( $ keywords as $ keyword ) { $ blade -> directive ( $ keyword , function ( $ parameter ) use ( $ keyword ) { $ parameter = trim ( $ parameter , "()" ) ; return "<?php {$keyword} {$parameter} ?>" ; } ) ; } $ assetify = function ( $ file , $ type ) { $ file = trim ( $ file , "()" ) ; if ( in_array ( substr ( $ file , 0 , 1 ) , [ "'" , '"' ] , true ) ) { $ file = trim ( $ file , "'\"" ) ; } else { return "{{ {$file} }}" ; } if ( substr ( $ file , 0 , 1 ) !== "/" ) { $ file = "/{$type}/{$file}" ; } if ( substr ( $ file , ( strlen ( $ type ) + 1 ) * - 1 ) !== ".{$type}" ) { $ file .= ".{$type}" ; } return $ file ; } ; $ blade -> directive ( "css" , function ( $ parameter ) use ( $ assetify ) { $ file = $ assetify ( $ parameter , "css" ) ; return '<link rel="stylesheet" type="text/css" href="' . $ file . '"/>' ; } ) ; $ blade -> directive ( "js" , function ( $ parameter ) use ( $ assetify ) { $ file = $ assetify ( $ parameter , "js" ) ; return '<script type="text/javascript" src="' . $ file . '"></script>' ; } ) ; }
4160	public function getLoginUrl ( $ scope = array ( ) , $ state = null ) { $ scope = $ this -> mergeScope ( $ scope ) ; $ state = is_string ( $ state ) ? "&state={$state}" : '' ; return self :: API_OAUTH_URL . '?client_id=' . $ this -> getApiKey ( ) . '&redirect_uri=' . urlencode ( $ this -> getApiCallback ( ) ) . '&scope=' . implode ( '+' , $ scope ) . '&response_type=code' . $ state ; }
10826	public static function table ( array $ rows , array $ headers = [ ] ) { $ table = new Table ( ) ; $ table -> setRows ( $ rows ) ; if ( count ( $ headers ) > 0 ) { $ table -> setHeaders ( $ headers ) ; } $ output = $ table -> render ( ) ; self :: writeln ( $ output ) ; }
6376	public function sorted ( Comparator $ comparator ) : FluentIterable { $ array = $ this -> toArray ( ) ; Arrays :: sort ( $ array , $ comparator ) ; return self :: of ( $ array ) ; }
7749	public function getAllMetadata ( ) { $ metadata = array ( ) ; foreach ( $ this -> driver -> getAllClassNames ( ) as $ className ) { $ metadata [ ] = $ this -> getMetadataFor ( $ className ) ; } $ this -> validate ( $ metadata ) ; return $ metadata ; }
12861	private function buildCache ( ) : array { $ dispatchData = $ this -> routeCollector -> getData ( ) ; file_put_contents ( $ this -> cacheFile , '<?php return ' . var_export ( $ dispatchData , true ) . ';' ) ; return $ dispatchData ; }
6024	public function setMetadata ( array $ metadata ) { $ this -> metadata = [ ] ; foreach ( $ metadata as $ item ) { $ this -> addMetaData ( $ item ) ; } return $ this ; }
6602	public function make ( $ key , $ secret ) { $ this -> credentials [ 'key' ] = $ key ; $ this -> credentials [ 'secret' ] = $ secret ; return $ this ; }
7299	public static function sender_to_message ( $ message , $ options , $ id ) { $ author = NULL ; $ commenter = NULL ; $ parts = array ( ) ; if ( 'iac_post_message' == current_filter ( ) ) { $ post = get_post ( $ id ) ; $ author = get_userdata ( $ post -> post_author ) ; if ( ! is_a ( $ author , 'WP_User' ) ) { return $ message ; } $ parts = array ( '' , implode ( ' ' , array ( $ options [ 'static_options' ] [ 'mail_string_by' ] , $ author -> data -> display_name ) ) , implode ( ': ' , array ( $ options [ 'static_options' ] [ 'mail_string_url' ] , get_permalink ( $ post ) ) ) ) ; } elseif ( 'iac_comment_message' == current_filter ( ) ) { $ comment = get_comment ( $ id ) ; $ post = get_post ( $ comment -> comment_post_ID ) ; $ commenter = array ( 'name' => 'Annonymous' ) ; if ( 0 != $ comment -> user_id ) { $ author = get_userdata ( $ comment -> user_id ) ; $ commenter [ 'name' ] = $ author -> data -> display_name ; } else { if ( ! empty ( $ comment -> comment_author ) ) { $ commenter [ 'name' ] = $ comment -> comment_author ; } } $ parts = array ( '' , implode ( ' ' , array ( $ options [ 'static_options' ] [ 'mail_string_by' ] , $ commenter [ 'name' ] , $ options [ 'static_options' ] [ 'mail_string_to' ] , get_the_title ( $ post -> ID ) , ) ) , implode ( ': ' , array ( $ options [ 'static_options' ] [ 'mail_string_url' ] , get_permalink ( $ post ) ) ) ) ; } if ( ! empty ( $ parts ) ) { $ message .= implode ( PHP_EOL , $ parts ) ; } return $ message ; }
8802	public function get ( $ key = null ) { return ( is_null ( $ key ) ? $ _SESSION : ( $ this -> has ( $ key ) ? $ _SESSION [ $ key ] : null ) ) ; }
3523	public function id ( $ id ) { foreach ( $ this -> items as $ item ) { if ( $ item -> itemId == $ id ) return $ item ; } return null ; }
5486	public function submitButton ( SelectorInterface $ selector , $ additional = false ) { $ additional = $ additional ? $ additional : array ( ) ; foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { $ encoding = $ this -> encode ( ) ; $ button -> write ( $ encoding ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; } } return false ; }
8382	public function fetch ( ) { if ( $ this -> statement == null || $ this -> getErrorState ( ) != '00000' ) { return false ; } return $ this -> statement -> fetch ( \ PDO :: FETCH_ASSOC ) ; }
2629	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ dictionaryId = $ this -> getRequest ( ) -> getParam ( 'dictionary_id' ) ; $ key = $ this -> getRequest ( ) -> getParam ( 'item_key' ) ; if ( $ key == '' ) { return $ result -> setData ( [ 'status' => true ] ) ; } $ deleteItem = $ this -> api -> deleteDictionaryItem ( $ dictionaryId , $ key ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
8200	public function look ( $ number = 1 ) { if ( ! isset ( $ this -> tokens [ $ this -> current + $ number ] ) ) { throw new Twig_Error_Syntax ( 'Unexpected end of template.' , $ this -> tokens [ $ this -> current + $ number - 1 ] -> getLine ( ) , $ this -> source ) ; } return $ this -> tokens [ $ this -> current + $ number ] ; }
2187	public function fetchByAlias ( $ strTable , $ strAlias , $ varValue ) { if ( isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ) { $ strPk = $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ; if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ strPk ] ) ) { return $ this -> arrRegistry [ $ strTable ] [ $ strPk ] ; } } return null ; }
1499	public function when ( bool $ test , $ encodings ) : self { if ( ! $ test || is_null ( $ encodings ) ) { return $ this ; } if ( $ encodings instanceof \ Closure ) { return $ encodings ( $ this ) ; } if ( is_string ( $ encodings ) ) { $ encodings = Encoding :: custom ( $ encodings ) ; } $ encodings = $ encodings instanceof Encoding ? [ $ encodings ] : $ encodings ; return $ this -> push ( ... $ encodings ) ; }
4709	public function initialize ( Text $ text ) { $ text -> replaceString ( "\r\n" , "\n" ) ; $ text -> replaceString ( "\r" , "\n" ) ; $ text -> append ( "\n\n" ) ; $ this -> markdown -> emit ( 'detab' , array ( $ text ) ) ; $ text -> replace ( '/^[ \t]+$/m' , '' ) ; }
10488	public function run ( \ de \ codenamephp \ platform \ cli \ command \ iCommand $ command ) { if ( $ this -> getDirectory ( ) !== '' && is_dir ( $ this -> getDirectory ( ) ) ) { $ currentDir = getcwd ( ) ; chdir ( $ this -> getDirectory ( ) ) ; } $ returnValue = $ this -> getActualPassthru ( ) -> run ( $ command ) ; if ( isset ( $ currentDir ) ) { chdir ( $ currentDir ) ; } return $ returnValue ; }
2606	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItemId = $ this -> getRequest ( ) -> getParam ( 'acl_item_id' ) ; $ deleteItem = $ this -> api -> deleteAclItem ( $ aclId , $ aclItemId ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11919	public function attr ( $ keys = [ ] ) { if ( ! is_array ( $ keys ) ) { $ keys = [ $ keys ] ; } $ out = '' ; foreach ( $ keys as $ key ) { $ value = $ this -> getValue ( $ key ) -> attr ( ) ; if ( ! empty ( $ value ) ) { $ out .= ' ' . $ value ; } } return ltrim ( $ out , ' ' ) ; }
2105	protected function generateFaqLink ( $ objFaq ) { $ objCategory = $ objFaq -> getRelated ( 'pid' ) ; $ jumpTo = ( int ) $ objCategory -> jumpTo ; if ( $ jumpTo < 1 ) { throw new \ Exception ( "FAQ categories without redirect page cannot be used in an FAQ list" ) ; } if ( ! isset ( $ this -> arrTargets [ $ jumpTo ] ) ) { $ this -> arrTargets [ $ jumpTo ] = ampersand ( Environment :: get ( 'request' ) , true ) ; if ( $ jumpTo > 0 && ( $ objTarget = PageModel :: findByPk ( $ jumpTo ) ) !== null ) { $ this -> arrTargets [ $ jumpTo ] = ampersand ( $ objTarget -> getFrontendUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ) ; } } return sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ this -> arrTargets [ $ jumpTo ] ) , ( $ objFaq -> alias ? : $ objFaq -> id ) ) ; }
5889	public function getViewer ( IViewer $ viewer ) { $ html = $ viewer -> fetchObject ( $ this ) ; $ iterator = new \ RecursiveIteratorIterator ( $ this , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ iterator as $ node ) { $ siblings = array ( ) ; for ( $ level = 0 ; $ level < $ iterator -> getDepth ( ) ; $ level ++ ) { $ siblings [ ] = ( $ iterator -> getSubIterator ( $ level ) -> hasNext ( ) ) ? 1 : 0 ; } $ siblings [ ] = ( ! $ iterator -> getSubIterator ( $ level ) -> hasNext ( ) ) ? 1 : 0 ; $ html .= $ viewer -> fetchObject ( $ node , $ siblings ) ; } return $ html ; }
5085	protected function buildUrl ( $ iTotal , $ iPage , $ iPageOffset ) { $ aParams = [ 'page' => $ iPage + $ iPageOffset , ] ; if ( $ aParams [ 'page' ] <= 0 ) { return null ; } elseif ( $ aParams [ 'page' ] === 1 ) { unset ( $ aParams [ 'page' ] ) ; } $ iTotalPages = ceil ( $ iTotal / static :: CONFIG_PER_PAGE ) ; if ( ! empty ( $ aParams [ 'page' ] ) && $ aParams [ 'page' ] > $ iTotalPages ) { return null ; } $ sUrl = site_url ( ) . uri_string ( ) ; if ( ! empty ( $ aParams ) ) { $ sUrl .= '?' . http_build_query ( $ aParams ) ; } return $ sUrl ; }
2368	public static function extractEmail ( $ strString , $ strAllowedTags = '' ) { $ arrEmails = array ( ) ; if ( strpos ( $ strString , '@' ) === false ) { return $ arrEmails ; } preg_match_all ( '/mailto:(?:[^\x00-\x20\x22\x40\x7F]{1,64}+|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , $ strString , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( 'mailto:' , '' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } unset ( $ strEmail ) ; $ strString = preg_replace_callback ( '@</?([^\s<>/]*)@' , function ( $ matches ) use ( $ strAllowedTags ) { if ( $ matches [ 1 ] == '' || stripos ( $ strAllowedTags , '<' . strtolower ( $ matches [ 1 ] ) . '>' ) === false ) { $ matches [ 0 ] = str_replace ( '<' , '&lt;' , $ matches [ 0 ] ) ; } return $ matches [ 0 ] ; } , $ strString ) ; preg_match_all ( '/(?:[^\x00-\x20\x22\x40\x7F]{1,64}|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , strip_tags ( $ strString ) , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( '&lt;' , '<' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } return array_unique ( $ arrEmails ) ; }
10666	public function setReportUri ( string $ reportUri ) : void { if ( ! $ this -> enableProtection ) { throw new MiddlewareException ( $ this , "You can't set the report URI because the XSS protection is disabled" ) ; } if ( $ this -> blockMode ) { throw new MiddlewareException ( $ this , sprintf ( "You can't set the report URI because the block mode is already enabled (see %s)" , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/X-XSS-Protection' ) ) ; } $ this -> reportUri = $ reportUri ; }
2880	public function disableTranslateAction ( ) { try { $ this -> getService ( ) -> setTranslateInline ( 0 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Translate inline cannot be disabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
8576	public function setItemChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4947	protected function checkPermission ( $ permission ) { $ perms = array ( self :: PERMISSION_ALL , self :: PERMISSION_CHANGE , self :: PERMISSION_NONE , self :: PERMISSION_VIEW , ) ; if ( ! in_array ( $ permission , $ perms ) ) { throw new \ InvalidArgumentException ( 'Invalid permission. Must be one of ' . implode ( ', ' , $ perms ) ) ; } }
10135	public function processBitmapGd ( $ image ) { $ width = imagesx ( $ image ) ; $ height = imagesy ( $ image ) ; $ data = pack ( 'Vvvvv' , 0x000c , $ width , $ height , 0x01 , 0x18 ) ; for ( $ j = $ height ; -- $ j ; ) { for ( $ i = 0 ; $ i < $ width ; ++ $ i ) { $ color = imagecolorsforindex ( $ image , imagecolorat ( $ image , $ i , $ j ) ) ; foreach ( [ 'red' , 'green' , 'blue' ] as $ key ) { $ color [ $ key ] = $ color [ $ key ] + round ( ( 255 - $ color [ $ key ] ) * $ color [ 'alpha' ] / 127 ) ; } $ data .= chr ( $ color [ 'blue' ] ) . chr ( $ color [ 'green' ] ) . chr ( $ color [ 'red' ] ) ; } if ( 3 * $ width % 4 ) { $ data .= str_repeat ( "\x00" , 4 - 3 * $ width % 4 ) ; } } return [ $ width , $ height , strlen ( $ data ) , $ data ] ; }
1486	public function push ( Decoding ... $ decodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ decodings ) -> all ( ) ; return $ copy ; }
4774	public function build ( $ widgets , string $ widgetGroup = '' , array $ widgetId = [ ] ) { if ( ! $ widgets ) { return $ widgets ; } $ this -> loadUserConfig ( ) ; $ outputWidget = [ ] ; if ( $ widgetId ) { foreach ( $ widgetId as $ id ) { if ( isset ( $ widgets [ $ id ] ) ) { $ widgets [ $ id ] -> setActive ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'status' ] ?? false ) ; $ widgets [ $ id ] -> setConfig ( $ this -> widgetConfig [ $ widget -> getId ( ) ] ?? [ ] ) ; $ outputWidget [ ] = $ widgets [ $ id ] ; } } return $ outputWidget ; } foreach ( $ widgets as $ widget ) { if ( '' !== $ widgetGroup && $ widget -> getGroup ( ) !== $ widgetGroup ) { continue ; } if ( isset ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'order' ] ) ) { $ widget -> setOrder ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'order' ] ) ; } if ( null !== $ widget -> getOrder ( ) ) { while ( isset ( $ outputWidget [ $ widget -> getOrder ( ) ] ) ) { $ widget -> setOrder ( $ widget -> getOrder ( ) + 1 ) ; } $ outputWidget [ $ widget -> getOrder ( ) ] = $ widget ; } else { $ outputWidget [ ] = $ widget ; } $ widget -> setActive ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'status' ] ?? false ) ; $ widget -> setConfig ( $ this -> widgetConfig [ $ widget -> getId ( ) ] ?? [ ] ) ; } ksort ( $ outputWidget ) ; return $ outputWidget ; }
10022	public function removeCellStyleXfByIndex ( $ pIndex ) { if ( $ pIndex > count ( $ this -> cellStyleXfCollection ) - 1 ) { throw new Exception ( 'CellStyleXf index is out of bounds.' ) ; } array_splice ( $ this -> cellStyleXfCollection , $ pIndex , 1 ) ; }
8120	public function canSubmitReview ( $ record ) { if ( ! $ record -> canEdit ( ) || ! $ record -> hasMethod ( 'canBeReviewedBy' ) || ! $ record -> canBeReviewedBy ( Security :: getCurrentUser ( ) ) ) { return false ; } return true ; }
8219	protected function getIp ( $ config ) { $ remoteAddr = $ _SERVER [ 'REMOTE_ADDR' ] ; if ( filter_var ( $ remoteAddr , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) ) { $ netmask = ( isset ( $ config [ "netmask_IPv4" ] ) ) ? $ config [ "netmask_IPv4" ] : self :: DEFAULT_NETMASK_IPV4 ; } else { $ netmask = ( isset ( $ config [ "netmask_IPv6" ] ) ) ? $ config [ "netmask_IPv6" ] : self :: DEFAULT_NETMASK_IPV6 ; } $ ipSubnet = $ this -> getSubnet ( $ remoteAddr , $ netmask ) ; return $ ipSubnet ; }
3811	protected function transformCondition ( $ condition ) { $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ event = new CreatePropertyConditionEvent ( $ condition , $ this -> getMetaModel ( ) ) ; $ dispatcher -> dispatch ( CreatePropertyConditionEvent :: NAME , $ event ) ; if ( $ event -> getInstance ( ) === null ) { throw new \ RuntimeException ( sprintf ( 'Condition of type %s could not be transformed to an instance.' , $ condition [ 'type' ] ) ) ; } return $ event -> getInstance ( ) ; }
8994	private function update ( ) { if ( null !== $ this -> namespace ) { $ _SESSION [ $ this -> namespace ] = $ this -> sessionData ; } else { $ _SESSION = $ this -> sessionData ; } }
8573	public function listRecommendationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsByNextTokenRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsByNextTokenResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7571	public function get ( $ url = "" ) { try { $ this -> guzzleResponse = $ this -> _client -> request ( 'GET' , $ url ) ; $ this -> _setLinks ( ) ; } catch ( RequestException $ e ) { throw new GreenhouseAPIResponseException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return ( string ) $ this -> guzzleResponse -> getBody ( ) ; }
7251	protected function validateIdentity ( SaleInterface $ sale , Constraint $ constraint ) { if ( null === $ sale -> getCustomer ( ) ) { if ( null === $ sale -> getCustomerGroup ( ) ) { $ this -> context -> buildViolation ( $ constraint -> customer_group_is_required_if_no_customer ) -> atPath ( 'customerGroup' ) -> addViolation ( ) ; } if ( 0 == strlen ( $ sale -> getEmail ( ) ) ) { $ this -> context -> buildViolation ( $ constraint -> email_is_required_if_no_customer ) -> atPath ( 'email' ) -> addViolation ( ) ; } IdentityValidator :: validateIdentity ( $ this -> context , $ sale ) ; } }
9995	private function writeComment ( Worksheet $ pSheet , $ coordinate ) { $ result = '' ; if ( ! $ this -> isPdf && isset ( $ pSheet -> getComments ( ) [ $ coordinate ] ) ) { $ result .= '<a class="comment-indicator"></a>' ; $ result .= '<div class="comment">' . nl2br ( $ pSheet -> getComment ( $ coordinate ) -> getText ( ) -> getPlainText ( ) ) . '</div>' ; $ result .= PHP_EOL ; } return $ result ; }
5849	protected function moduleContent ( array $ row ) { $ this -> formResultCompiler = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormResultCompiler :: class ) ; $ wizard = $ this -> formResultCompiler -> addCssFiles ( ) ; $ wizard .= $ this -> buildForm ( $ row ) ; $ wizard .= $ this -> formResultCompiler -> printNeededJSFunctions ( ) ; $ this -> content .= $ wizard ; }
9641	public function validate ( $ validator ) { $ this -> value = trim ( $ this -> value ) ; $ regex = $ this -> config [ 'validregex' ] ; if ( $ this -> value && $ regex && ! preg_match ( $ regex , $ this -> value ) ) { $ validator -> validationError ( $ this -> name , _t ( 'ExternalURLField.VALIDATION' , "Please enter a valid URL" ) , "validation" ) ; return false ; } return true ; }
10675	private function _sklon ( $ nPad , $ vzndx , $ txt , $ zivotne = false ) { if ( $ vzndx < 0 || $ vzndx >= \ count ( $ this -> vzor ) ) { return '???' ; } $ txt3 = $ this -> _xEdeten ( $ txt ) ; $ kndx = $ this -> _isShoda ( $ this -> vzor [ $ vzndx ] [ 1 ] , $ txt3 ) ; if ( $ kndx < 0 || $ nPad < 1 || $ nPad > 14 ) { return '???' ; } if ( $ this -> vzor [ $ vzndx ] [ $ nPad ] === '?' ) { return '?' ; } if ( ! $ this -> isDbgMode & $ nPad === 1 ) { $ rv = $ this -> _xDetene ( $ txt3 ) ; } else { $ rv = $ this -> _leftStr ( $ kndx , $ txt3 ) . '-' . $ this -> _cmpFrm ( $ this -> vzor [ $ vzndx ] [ $ nPad ] ) ; } if ( $ this -> isDbgMode ) { return $ rv ; } $ length = mb_strlen ( $ rv , 'UTF-8' ) ; for ( $ nnn = 0 ; $ nnn < $ length ; $ nnn ++ ) { if ( mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) === '-' ) { break ; } } $ ndx1 = $ nnn ; for ( $ nnn = 0 ; $ nnn < $ length ; $ nnn ++ ) { if ( mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) === '/' ) { break ; } } $ ndx2 = $ nnn ; if ( $ ndx1 !== $ length && $ ndx2 !== $ length ) { if ( $ zivotne ) { $ rv = $ this -> _leftStr ( $ ndx1 , $ rv ) . $ this -> _rightStr ( $ ndx2 + 1 , $ rv ) ; } else { $ rv = $ this -> _leftStr ( $ ndx2 , $ rv ) ; } $ length = mb_strlen ( $ rv , 'UTF-8' ) ; } $ txt3 = '' ; for ( $ nnn = 0 ; $ nnn < $ length ; $ nnn ++ ) { $ subStr = mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) ; if ( ! ( $ subStr === '-' || $ subStr === '/' ) ) { $ txt3 .= mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) ; } } $ rv = $ this -> _xDetene ( $ txt3 ) ; return $ rv ; }
11453	protected function getPublicIdAttribute ( ) { if ( $ id = Api :: decodeHashId ( $ this -> attributes [ 'id' ] ) ) { return $ id ; } return Api :: encodeHashId ( $ this -> attributes [ 'id' ] ) ; }
1359	public static function jsonApi ( int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { return self :: create ( MediaTypeInterface :: JSON_API_MEDIA_TYPE , $ options , $ urlPrefix , $ depth ) ; }
11123	public function getUp ( $ time = NOW ) { foreach ( $ this -> movements as $ v ) { if ( $ v -> isActive ( $ time ) ) { $ up = $ v -> getCurrentUp ( $ time ) ; if ( isset ( $ up ) ) { return $ v -> getCurrentUp ( $ time ) ; } } } return new Neuron_GameServer_Map_Vector3 ( 0 , 1 , 0 ) ; }
11264	public function repeat ( & $ property , $ repeatTag , $ classes = '' , $ outerTag = false , $ outerClasses = '' ) { if ( isset ( $ property ) ) { $ output = '' ; if ( $ outerTag ) { $ output .= '<' . $ outerTag . ' class="' . $ outerClasses . '">' ; } if ( is_array ( $ property ) ) { foreach ( $ property as $ value ) { $ output .= '<' . $ repeatTag . ' class="' . $ classes . '">' ; $ output .= $ value ; $ output .= '</' . $ repeatTag . '>' ; } } else { $ output .= '<' . $ repeatTag . ' class="' . $ classes . '">' ; $ output .= $ property ; $ output .= '</' . $ repeatTag . '>' ; } if ( $ outerTag ) { $ output .= '</' . $ outerTag . '>' ; } echo $ output ; } else echo '' ; }
2735	public function afterGetOutput ( \ Magento \ Framework \ View \ Layout $ subject , $ result ) { if ( $ this -> config -> getType ( ) == Config :: FASTLY ) { $ this -> response -> setHeader ( "Fastly-Module-Enabled" , "1.2.99" , true ) ; } return $ result ; }
1841	public static function parse ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( 'Invalid file ' . $ file ) ; } $ table = '' ; $ return = array ( ) ; $ data = file ( $ file ) ; foreach ( $ data as $ k => $ v ) { $ key_name = array ( ) ; $ subpatterns = array ( ) ; if ( preg_match ( '/^[#-]+/' , $ v ) || ! \ strlen ( trim ( $ v ) ) ) { unset ( $ data [ $ k ] ) ; continue ; } if ( preg_match ( '/^CREATE TABLE `([^`]+)`/i' , $ v , $ subpatterns ) ) { $ table = $ subpatterns [ 1 ] ; } elseif ( $ table != '' && preg_match ( '/^\)([^;]+);/' , $ v , $ subpatterns ) ) { $ return [ $ table ] [ 'TABLE_OPTIONS' ] = $ subpatterns [ 1 ] ; $ table = '' ; } elseif ( $ table != '' ) { preg_match ( '/^[^`]*`([^`]+)`/' , trim ( $ v ) , $ key_name ) ; $ first = preg_replace ( '/\s[^\n\r]+/' , '' , $ key_name [ 0 ] ) ; $ key = $ key_name [ 1 ] ; if ( \ in_array ( $ first , array ( 'KEY' , 'PRIMARY' , 'PRIMARY KEY' , 'FOREIGN' , 'FOREIGN KEY' , 'INDEX' , 'UNIQUE' , 'FULLTEXT' , 'CHECK' ) ) ) { if ( strncmp ( $ first , 'PRIMARY' , 7 ) === 0 ) { $ key = 'PRIMARY' ; } $ return [ $ table ] [ 'TABLE_CREATE_DEFINITIONS' ] [ $ key ] = preg_replace ( '/,$/' , '' , trim ( $ v ) ) ; } else { $ return [ $ table ] [ 'TABLE_FIELDS' ] [ $ key ] = preg_replace ( '/,$/' , '' , trim ( $ v ) ) ; } } } foreach ( array_keys ( $ return ) as $ table ) { if ( ! isset ( $ return [ $ table ] [ 'TABLE_CREATE_DEFINITIONS' ] [ 'PRIMARY' ] ) ) { unset ( $ return [ $ table ] [ 'TABLE_OPTIONS' ] ) ; } } return $ return ; }
4486	public function broadcast ( Message $ message , ? string $ platform = null ) { if ( null !== $ platform && ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } if ( $ platform ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } else { foreach ( $ this -> arns as $ platform => $ arn ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } } }
7874	private function checkConfig ( ) : void { if ( empty ( $ this -> userkey ) ) { Log :: warning ( 'Config "message.zenziva.userkey" is not defined.' ) ; } if ( empty ( $ this -> passkey ) ) { Log :: warning ( 'Config "message.zenziva.passkey" is not defined.' ) ; } }
4985	public function setParam ( $ key , $ value ) { $ this -> params [ $ key ] = $ value ; foreach ( $ this -> forms as $ form ) { if ( isset ( $ form [ '__instance__' ] ) && is_object ( $ form [ '__instance__' ] ) && method_exists ( $ form [ '__instance__' ] , 'setParam' ) ) { $ form [ '__instance__' ] -> setParam ( $ key , $ value ) ; } } return $ this ; }
8756	public static function build ( array $ subscribers = [ ] , $ totalItems = self :: UNKNOWN ) { $ that = new static ( $ totalItems ) ; foreach ( $ subscribers as $ subscriber ) { $ that -> addSubscriber ( $ subscriber ) ; } return $ that ; }
12278	public function moveUser ( $ openId , $ groupId ) { $ params = [ 'openid' => $ openId , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_UPDATE , $ params ] ) ; }
8692	public static function checkSymlink ( $ symlinkTarget , $ symlinkName , $ forceSymlink = false ) { if ( $ forceSymlink && file_exists ( $ symlinkName ) && ! is_link ( $ symlinkName ) ) { if ( 'link' !== filetype ( $ symlinkName ) ) { throw new \ UnexpectedValueException ( "{$symlinkName} exists and is not a link" ) ; } } elseif ( is_link ( $ symlinkName ) ) { $ linkTarget = readlink ( $ symlinkName ) ; if ( $ linkTarget !== $ symlinkTarget ) { if ( ! $ forceSymlink ) { throw new \ UnexpectedValueException ( "Symlink '{$symlinkName}' points to '{$linkTarget}' instead of '{$symlinkTarget}'" ) ; } unlink ( $ symlinkName ) ; return false ; } return true ; } return false ; }
3177	public static function checkTimedSectionExit ( RunnerServiceContext $ context , $ nextPosition ) { $ timerConfig = $ context -> getTestConfig ( ) -> getConfigValue ( 'timer' ) ; if ( empty ( $ timerConfig [ 'keepUpToTimeout' ] ) ) { $ session = $ context -> getTestSession ( ) ; $ route = $ session -> getRoute ( ) ; $ section = $ session -> getCurrentAssessmentSection ( ) ; $ limits = $ section -> getTimeLimits ( ) ; if ( ! ( $ context instanceof QtiRunnerServiceContext ) || ! $ context -> isAdaptive ( ) ) { $ isJumpOutOfSection = false ; if ( ( $ nextPosition >= 0 ) && ( $ nextPosition < $ route -> count ( ) ) ) { $ nextSection = $ route -> getRouteItemAt ( $ nextPosition ) ; $ isJumpOutOfSection = ( $ section -> getIdentifier ( ) !== $ nextSection -> getAssessmentSection ( ) -> getIdentifier ( ) ) ; } if ( $ isJumpOutOfSection && $ limits != null && $ limits -> hasMaxTime ( ) ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; foreach ( $ assessmentItemRefs as $ assessmentItemRef ) { $ itemSessions = $ session -> getAssessmentItemSessions ( $ assessmentItemRef -> getIdentifier ( ) ) ; if ( $ itemSessions !== false ) { foreach ( $ itemSessions as $ itemSession ) { $ itemSession -> endItemSession ( ) ; } } } } } } }
12227	public function deleteSelf ( ) { $ tmp = dom_import_simplexml ( $ this ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { throw new BadMethodCallException ( 'deleteSelf() cannot be used to delete the root node' ) ; } $ tmp -> parentNode -> removeChild ( $ tmp ) ; }
7783	public function registerTimezoneScript ( $ actionRoute ) { Yii :: $ app -> on ( Controller :: EVENT_BEFORE_ACTION , function ( $ event ) use ( $ actionRoute ) { $ view = $ event -> sender -> view ; $ js = <<<JS var timezone = ''; var timezoneAbbr = ''; try { var timezone = Intl.DateTimeFormat().resolvedOptions().timeZone; var timezoneAbbr = /\((.*)\)/.exec(new Date().toString())[1]; } catch(err) { console.log(err); } $.post("$actionRoute", { timezone: timezone, timezoneAbbr: timezoneAbbr, timezoneOffset: -new Date().getTimezoneOffset() / 60 });JS ; $ view -> registerJs ( $ js ) ; } ) ; }
6971	protected function syncLineWithResult ( Model \ DocumentLineInterface $ line , Amount $ result ) { if ( $ line -> getUnit ( ) !== $ result -> getUnit ( ) ) { $ line -> setUnit ( $ result -> getUnit ( ) ) ; $ this -> changed = true ; } if ( $ line -> getGross ( ) !== $ result -> getGross ( ) ) { $ line -> setGross ( $ result -> getGross ( ) ) ; $ this -> changed = true ; } if ( $ line -> getDiscount ( ) !== $ result -> getDiscount ( ) ) { $ line -> setDiscount ( $ result -> getDiscount ( ) ) ; $ this -> changed = true ; } $ discountRates = [ ] ; if ( ! empty ( $ adjustments = $ result -> getDiscountAdjustments ( ) ) ) { foreach ( $ adjustments as $ adjustment ) { $ discountRates [ ] = $ adjustment -> getRate ( ) ; } } if ( $ discountRates !== $ line -> getDiscountRates ( ) ) { $ line -> setDiscountRates ( $ discountRates ) ; $ this -> changed = true ; } if ( $ line -> getBase ( ) !== $ result -> getBase ( ) ) { $ line -> setBase ( $ result -> getBase ( ) ) ; $ this -> changed = true ; } if ( $ line -> getTax ( ) !== $ result -> getTax ( ) ) { $ line -> setTax ( $ result -> getTax ( ) ) ; $ this -> changed = true ; } $ taxRates = [ ] ; if ( ! empty ( $ adjustments = $ result -> getTaxAdjustments ( ) ) ) { foreach ( $ adjustments as $ adjustment ) { $ taxRates [ ] = $ adjustment -> getRate ( ) ; } } if ( $ taxRates !== $ line -> getTaxRates ( ) ) { $ line -> setTaxRates ( $ taxRates ) ; $ this -> changed = true ; } if ( $ line -> getTotal ( ) !== $ result -> getTotal ( ) ) { $ line -> setTotal ( $ result -> getTotal ( ) ) ; $ this -> changed = true ; } }
5051	public function triggerUntil ( callable $ callback , $ eventName , $ target = null , $ argv = [ ] ) { $ event = $ eventName instanceof EventInterface ? $ eventName : $ this -> getEvent ( $ eventName , $ target , $ argv ) ; return $ this -> triggerListeners ( $ event , $ callback ) ; }
2292	public static function getTheme ( ) { $ theme = Config :: get ( 'backendTheme' ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( $ theme != '' && $ theme != 'flexible' && is_dir ( $ rootDir . '/system/themes/' . $ theme ) ) { return $ theme ; } return 'flexible' ; }
6710	protected function parseHeader ( array $ headers = [ ] ) { $ processedHeaders = array ( ) ; foreach ( $ headers as $ key => $ value ) { if ( substr ( $ key , 0 , 5 ) == 'HTTP_' ) { $ name = str_replace ( ' ' , '-' , ucwords ( strtolower ( str_replace ( '_' , ' ' , substr ( $ key , 5 ) ) ) ) ) ; $ processedHeaders [ $ name ] = $ value ; } elseif ( $ key == 'CONTENT_TYPE' ) { $ processedHeaders [ 'Content-Type' ] = $ value ; } elseif ( $ key == 'CONTENT_LENGTH' ) { $ processedHeaders [ 'Content-Length' ] = $ value ; } } return $ processedHeaders ; }
6467	private function createStreamFromString ( string $ string ) : Stream { $ stream = new Stream ( fopen ( 'php://temp' , 'r+b' ) ) ; $ stream -> write ( $ string ) ; $ stream -> rewind ( ) ; return $ stream ; }
11031	protected function ensureFieldIds ( ) { if ( $ this -> submitModelName ) { $ formName = Inflector :: slug ( $ this -> submitModelName , '_' ) ; } else { $ model = new \ ReflectionClass ( $ this -> model ) ; $ formName = $ model -> getShortName ( ) ; } $ parts = [ ] ; preg_match_all ( '/{([^}]+)}/' , $ this -> template , $ parts ) ; $ keys = array_flip ( $ parts [ 1 ] ) ; $ fieldIds = [ ] ; if ( isset ( $ keys [ 'country' ] ) ) { $ fieldIds [ 'country' ] = $ formName . '_country_id' ; } if ( isset ( $ keys [ 'state' ] ) ) { $ fieldIds [ 'state' ] = $ formName . '_state_id' ; } if ( isset ( $ keys [ 'region' ] ) ) { $ fieldIds [ 'region' ] = $ formName . '_region_id' ; } if ( isset ( $ keys [ 'city' ] ) ) { $ fieldIds [ 'city' ] = $ formName . '_city_id' ; } if ( isset ( $ keys [ 'address' ] ) ) { $ fieldIds [ 'address' ] = $ formName . '_address' ; } if ( isset ( $ keys [ 'postalCode' ] ) ) { $ fieldIds [ 'postal_code' ] = $ formName . '_postal_code' ; } if ( isset ( $ keys [ 'geolocation' ] ) ) { $ fieldIds [ 'latitude' ] = $ formName . '_latitude' ; $ fieldIds [ 'longitude' ] = $ formName . '_longitude' ; } $ this -> fieldIds = $ fieldIds ; }
9749	public function _calcSize ( & $ raList ) { list ( $ iSBDcnt , $ iBBcnt , $ iPPScnt ) = [ 0 , 0 , 0 ] ; $ iSmallLen = 0 ; $ iSBcnt = 0 ; $ iCount = count ( $ raList ) ; for ( $ i = 0 ; $ i < $ iCount ; ++ $ i ) { if ( $ raList [ $ i ] -> Type == OLE :: OLE_PPS_TYPE_FILE ) { $ raList [ $ i ] -> Size = $ raList [ $ i ] -> getDataLen ( ) ; if ( $ raList [ $ i ] -> Size < OLE :: OLE_DATA_SIZE_SMALL ) { $ iSBcnt += floor ( $ raList [ $ i ] -> Size / $ this -> smallBlockSize ) + ( ( $ raList [ $ i ] -> Size % $ this -> smallBlockSize ) ? 1 : 0 ) ; } else { $ iBBcnt += ( floor ( $ raList [ $ i ] -> Size / $ this -> bigBlockSize ) + ( ( $ raList [ $ i ] -> Size % $ this -> bigBlockSize ) ? 1 : 0 ) ) ; } } } $ iSmallLen = $ iSBcnt * $ this -> smallBlockSize ; $ iSlCnt = floor ( $ this -> bigBlockSize / OLE :: OLE_LONG_INT_SIZE ) ; $ iSBDcnt = floor ( $ iSBcnt / $ iSlCnt ) + ( ( $ iSBcnt % $ iSlCnt ) ? 1 : 0 ) ; $ iBBcnt += ( floor ( $ iSmallLen / $ this -> bigBlockSize ) + ( ( $ iSmallLen % $ this -> bigBlockSize ) ? 1 : 0 ) ) ; $ iCnt = count ( $ raList ) ; $ iBdCnt = $ this -> bigBlockSize / OLE :: OLE_PPS_SIZE ; $ iPPScnt = ( floor ( $ iCnt / $ iBdCnt ) + ( ( $ iCnt % $ iBdCnt ) ? 1 : 0 ) ) ; return [ $ iSBDcnt , $ iBBcnt , $ iPPScnt ] ; }
1253	private function newPhpObject ( \ stdClass $ meta ) { $ phpTypes = explode ( '|' , $ meta -> phpType ) ; foreach ( $ phpTypes as $ phpType ) { switch ( $ phpType ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'DateTime' : continue ; default : return $ meta -> phpType !== '' ? new $ phpType ( ) : null ; } } return null ; }
10376	protected static function look_if_process_files ( $ type ) { if ( is_string ( self :: $ unify ) || isset ( self :: $ unify [ "{$type}s" ] ) ) { return self :: unify_files ( self :: prepare_files ( $ type ) ) ; } }
5839	protected function trim ( Builder $ url , $ args ) { $ args = ( is_string ( $ args ) ) ? $ args : null ; $ url -> trim ( $ args ) ; }
3574	protected function update ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { $ value = $ key -> getValue ( ) ; $ group = $ key -> getMetaGroup ( ) ; $ key = $ key -> getMetaKey ( ) ; } $ this -> get ( $ key ) -> setValue ( $ value ) ; $ this -> get ( $ key ) -> setMetaGroup ( $ group ) ; return $ this ; }
10152	private function readHcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isHorizontalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setHorizontalCentered ( $ isHorizontalCentered ) ; } }
8659	private function convertGetFeedSubmissionCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
3684	protected function buildNativeSqlProcedure ( FilterBuilderSql $ procedure , $ children ) { $ skipped = array ( ) ; $ metaModel = $ this -> getMetaModel ( ) ; $ tableName = $ metaModel -> getTableName ( ) ; foreach ( $ children as $ child ) { if ( isset ( $ child [ 'property' ] ) && $ metaModel -> hasAttribute ( $ child [ 'property' ] ) ) { $ skipped [ ] = $ child ; continue ; } if ( ( 'AND' === $ child [ 'operation' ] ) || ( 'OR' === $ child [ 'operation' ] ) ) { if ( null === $ child [ 'children' ] ) { continue ; } $ subProcedure = new FilterBuilderSql ( $ tableName , $ child [ 'operation' ] , $ this -> connection ) ; $ subSkipped = $ this -> buildNativeSqlProcedure ( $ subProcedure , $ child [ 'children' ] ) ; if ( count ( $ subSkipped ) !== count ( $ child [ 'children' ] ) ) { $ procedure -> addSubProcedure ( $ subProcedure ) ; } if ( ! empty ( $ subSkipped ) ) { $ skipped += $ subSkipped ; } continue ; } $ procedure -> addChild ( $ child ) ; } return $ skipped ; }
1028	private function resolveField ( ObjectType $ parentType , $ source , $ fieldNodes , $ path ) { $ exeContext = $ this -> exeContext ; $ fieldNode = $ fieldNodes [ 0 ] ; $ fieldName = $ fieldNode -> name -> value ; $ fieldDef = $ this -> getFieldDef ( $ exeContext -> schema , $ parentType , $ fieldName ) ; if ( ! $ fieldDef ) { return self :: $ UNDEFINED ; } $ returnType = $ fieldDef -> getType ( ) ; $ info = new ResolveInfo ( $ fieldName , $ fieldNodes , $ returnType , $ parentType , $ path , $ exeContext -> schema , $ exeContext -> fragments , $ exeContext -> rootValue , $ exeContext -> operation , $ exeContext -> variableValues ) ; if ( $ fieldDef -> resolveFn !== null ) { $ resolveFn = $ fieldDef -> resolveFn ; } elseif ( $ parentType -> resolveFieldFn !== null ) { $ resolveFn = $ parentType -> resolveFieldFn ; } else { $ resolveFn = $ this -> exeContext -> fieldResolver ; } $ context = $ exeContext -> contextValue ; $ result = $ this -> resolveOrError ( $ fieldDef , $ fieldNode , $ resolveFn , $ source , $ context , $ info ) ; $ result = $ this -> completeValueCatchingError ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; return $ result ; }
282	private function outputList ( $ data ) { foreach ( $ data as $ index => $ item ) { $ this -> stdout ( "\t" . ( $ index + 1 ) . ". {$item}\n" , Console :: FG_GREEN ) ; } }
5544	public function getRaw ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRaw ( ) ; } $ raw = '' ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ raw .= $ this -> frames [ $ i ] -> getRaw ( ) ; } return $ raw ; }
5300	public function getGlyphNames ( ) { $ glyphNames = array ( ) ; foreach ( $ this -> font -> getGlyphs ( ) as $ glyph ) { $ glyphNames [ static :: unicodeToHex ( $ glyph [ 'char' ] ) ] = empty ( $ glyph [ 'name' ] ) ? null : $ glyph [ 'name' ] ; } return $ glyphNames ; }
7447	function decrypt ( $ data , $ password ) { $ data = base64_decode ( $ data ) ; $ salt = substr ( $ data , 0 , 16 ) ; $ ct = substr ( $ data , 16 ) ; $ rounds = 3 ; $ data00 = $ password . $ salt ; $ hash = array ( ) ; $ hash [ 0 ] = hash ( 'sha256' , $ data00 , true ) ; $ result = $ hash [ 0 ] ; for ( $ i = 1 ; $ i < $ rounds ; $ i ++ ) { $ hash [ $ i ] = hash ( 'sha256' , $ hash [ $ i - 1 ] . $ data00 , true ) ; $ result .= $ hash [ $ i ] ; } $ key = substr ( $ result , 0 , 32 ) ; $ iv = substr ( $ result , 32 , 16 ) ; return openssl_decrypt ( $ ct , 'AES-256-CBC' , $ key , true , $ iv ) ; }
2693	private function compileFastlyParameters ( ) { if ( isset ( $ this -> fastlyParameters [ 'width' ] ) == false ) { $ this -> fastlyParameters [ 'height' ] = $ this -> _height ; $ this -> fastlyParameters [ 'width' ] = $ this -> _width ; } $ params = [ ] ; foreach ( $ this -> fastlyParameters as $ key => $ value ) { $ params [ ] = $ key . '=' . $ value ; } return implode ( '&' , $ params ) ; }
7158	public function compile ( Database $ db = NULL ) : string { if ( $ db === null ) { $ db = \ Mii :: $ app -> db ; } $ value = $ this -> value ( ) ; if ( ! empty ( $ this -> _parameters ) ) { $ params = array_map ( [ $ db , 'quote' ] , $ this -> _parameters ) ; $ value = strtr ( $ value , $ params ) ; } return $ value ; }
3788	public static function calculateConditions ( IMetaModelDataDefinition $ container , array $ inputScreen ) { if ( $ container -> hasDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ) { $ definition = $ container -> getDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ; } else { $ definition = new DefaultModelRelationshipDefinition ( ) ; $ container -> setDefinition ( ModelRelationshipDefinitionInterface :: NAME , $ definition ) ; } if ( ! $ definition instanceof ModelRelationshipDefinitionInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } $ instance = new static ( ) ; $ instance -> container = $ container ; $ instance -> inputScreen = $ inputScreen ; $ instance -> definition = $ definition ; $ instance -> calculate ( ) ; }
8144	public function tokenize ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer -> tokenize ( $ source ) ; }
4041	public function render ( ModelToLabelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ viewSection = $ definition -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; $ listing = $ viewSection -> getListingConfig ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ data = array ( $ nativeItem -> parseValue ( 'html5' , $ renderSetting ) ) ; if ( $ listing -> getShowColumns ( ) ) { $ event -> setArgs ( $ data [ 0 ] [ 'html5' ] ) ; return ; } $ template = new Template ( $ renderSetting -> get ( 'template' ) ) ; $ renderSetting = self :: removeInvariantAttributes ( $ nativeItem , $ renderSetting ) ; $ template -> setData ( array ( 'settings' => $ renderSetting , 'items' => new Items ( array ( $ nativeItem ) ) , 'view' => $ renderSetting , 'data' => $ data ) ) ; $ event -> setLabel ( '%s' ) -> setArgs ( array ( $ template -> parse ( 'html5' ) ) ) ; }
2310	public function setZoomLevel ( $ zoomLevel ) { $ zoomLevel = ( int ) $ zoomLevel ; if ( $ zoomLevel < 0 || $ zoomLevel > 100 ) { throw new \ InvalidArgumentException ( 'Zoom level must be between 0 and 100!' ) ; } $ this -> zoomLevel = $ zoomLevel ; return $ this ; }
9110	protected function attainPathName ( ) { $ path = false ; $ config = $ this -> getConfig ( ) ; if ( isset ( $ config [ 'theme_locator' ] [ 'themes_default_path' ] ) ) { $ path = $ config [ 'theme_locator' ] [ 'themes_default_path' ] ; } $ themeName = $ this -> attainThemeName ( ) ; if ( isset ( $ config [ 'themes' ] ) && is_array ( $ config [ 'themes' ] ) && isset ( $ config [ 'themes' ] [ $ themeName ] ) ) { if ( array_key_exists ( 'dir_path' , $ config [ 'themes' ] [ $ themeName ] ) ) { $ path = $ config [ 'themes' ] [ $ themeName ] [ 'dir_path' ] ; } } return $ path ; }
3798	private function checkModelWithVariants ( $ containedModel ) { $ isVarbase = ( bool ) $ containedModel -> getProperty ( 'varbase' ) ; $ vargroup = $ containedModel -> getProperty ( 'vargroup' ) ; $ isCurrentVarbase = ( bool ) $ this -> currentModel -> getProperty ( 'varbase' ) ; $ currentVargroup = $ this -> currentModel -> getProperty ( 'vargroup' ) ; if ( $ isVarbase && ! $ this -> circularReference && $ isCurrentVarbase ) { $ this -> disablePA = false ; } elseif ( ! $ isVarbase && ! $ isCurrentVarbase && $ vargroup == $ currentVargroup ) { $ this -> disablePA = false ; } $ this -> disablePI = ! $ isCurrentVarbase || $ isVarbase ; }
10314	function getClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ linkIdFilter = null , $ linkUrlFilter = null , $ linkTagFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_id" , $ linkIdFilter ) ; if ( isset ( $ linkUrlFilter ) ) $ params [ 'link_url' ] = $ linkUrlFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_tag" , $ linkTagFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/clicks/count' , $ params ) ; }
6077	public function uploadNewVersionChunked ( $ fileData , $ id , $ revisionComment , $ name , $ chunk , $ chunks , $ fileId ) { $ parameters = [ 'query' => [ 'revisionComment' => $ revisionComment , 'name' => $ name , 'chunk' => $ chunk , 'chunks' => $ chunks , 'fileId' => $ fileId , ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => $ name , ] , ] , 'headers' => null , ] ; $ result = $ this -> post ( 'v1/media.json/' . $ id . '/version' , $ parameters ) ; return $ result ; }
4211	public static function getConstants ( $ phpVer = null ) { $ phpVer = $ phpVer ? : PHP_VERSION ; $ phpVer = \ preg_match ( '/^\d+\.\d+$/' , $ phpVer ) ? $ phpVer . '.0' : $ phpVer ; $ constants = array ( 'E_ERROR' => 1 , 'E_WARNING' => 2 , 'E_PARSE' => 4 , 'E_NOTICE' => 8 , 'E_CORE_ERROR' => 16 , 'E_CORE_WARNING' => 32 , 'E_COMPILE_ERROR' => 64 , 'E_COMPILE_WARNING' => 128 , 'E_USER_ERROR' => 256 , 'E_USER_WARNING' => 512 , 'E_USER_NOTICE' => 1024 , 'E_STRICT' => \ version_compare ( $ phpVer , '5.0.0' , '>=' ) ? 2048 : null , 'E_RECOVERABLE_ERROR' => \ version_compare ( $ phpVer , '5.2.0' , '>=' ) ? 4096 : null , 'E_DEPRECATED' => \ version_compare ( $ phpVer , '5.3.0' , '>=' ) ? 8192 : null , 'E_USER_DEPRECATED' => \ version_compare ( $ phpVer , '5.3.0' , '>=' ) ? 16384 : null , 'E_ALL' => null , ) ; $ constants = \ array_filter ( $ constants ) ; $ constants [ 'E_ALL' ] = \ array_sum ( $ constants ) ; if ( isset ( $ constants [ 'E_STRICT' ] ) && \ version_compare ( $ phpVer , '5.4.0' , '<' ) ) { $ constants [ 'E_ALL' ] -= $ constants [ 'E_STRICT' ] ; } return $ constants ; }
11319	function query ( $ sql , $ params = array ( ) ) { $ db = Neuron_DB_Database :: getInstance ( ) ; $ sql = $ this -> printf ( $ sql , $ params ) ; if ( $ this -> debug ) { echo $ sql . "<br><br>" ; } try { $ data = $ db -> query ( $ sql ) ; if ( $ this -> debug ) { echo '<pre>' ; var_dump ( $ data ) ; echo "</pre><br><br>" ; } $ this -> error = false ; return $ data ; } catch ( Exception $ e ) { $ this -> error = true ; echo 'error' ; } }
9560	protected function renderCloseButton ( ) { if ( ( $ closeButton = $ this -> closeButton ) !== false ) { $ tag = ArrayHelper :: remove ( $ closeButton , 'tag' , 'button' ) ; $ label = ArrayHelper :: remove ( $ closeButton , 'label' , 'Close' ) ; if ( $ tag === 'button' && ! isset ( $ closeButton [ 'type' ] ) ) { $ closeButton [ 'type' ] = 'button' ; } return Html :: tag ( $ tag , $ label , $ closeButton ) ; } else { return null ; } }
7203	public function addDiscountAdjustment ( Adjustment $ discount ) : void { foreach ( $ this -> discounts as $ d ) { if ( $ d -> isSameAs ( $ discount ) ) { $ d -> addAmount ( $ discount -> getAmount ( ) ) ; return ; } } $ this -> discounts [ ] = clone $ discount ; }
12782	public function getAll ( ) { if ( is_null ( $ this -> intersections ) ) { $ this -> intersections = [ ] ; if ( $ this -> arraysSize >= 2 ) { $ this -> createIntersections ( ) ; } } return $ this -> intersections ; }
5052	public function getContentType ( ) { if ( ! $ this -> contentType ) { $ this -> setContentType ( $ this -> getParam ( 'contentType' ) ? : static :: TYPE_JSON ) ; } return $ this -> contentType ; }
10133	public function insertBitmap ( $ row , $ col , $ bitmap , $ x = 0 , $ y = 0 , $ scale_x = 1 , $ scale_y = 1 ) { $ bitmap_array = ( is_resource ( $ bitmap ) ? $ this -> processBitmapGd ( $ bitmap ) : $ this -> processBitmap ( $ bitmap ) ) ; list ( $ width , $ height , $ size , $ data ) = $ bitmap_array ; $ width *= $ scale_x ; $ height *= $ scale_y ; $ this -> positionImage ( $ col , $ row , $ x , $ y , $ width , $ height ) ; $ record = 0x007f ; $ length = 8 + $ size ; $ cf = 0x09 ; $ env = 0x01 ; $ lcb = $ size ; $ header = pack ( 'vvvvV' , $ record , $ length , $ cf , $ env , $ lcb ) ; $ this -> append ( $ header . $ data ) ; }
12591	protected function checkParams ( $ params , $ operator ) { if ( ! is_array ( $ params ) ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: first param must be an array' ) ; } if ( $ operator == 'IN' ) { if ( count ( $ params ) < 1 ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: IN operator requires at least one param' ) ; } } elseif ( $ operator == 'BETWEEN' ) { if ( count ( $ params ) != 2 ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: BETWEEN operator requires exactly two params' ) ; } } else { throw new Exception ( 'Web2All_Table_MultiValueOperator: unsupported operator "' . $ operator . '"' ) ; } }
2123	public function addMultiple ( array $ arrFiles , $ strVersion = null , $ strMedia = 'screen' ) { foreach ( $ arrFiles as $ strFile ) { $ this -> add ( $ strFile , $ strVersion , $ strMedia ) ; } }
7568	protected function parse ( ) { $ p = & $ this -> parser ; $ p -> setPos ( 0 ) ; $ this -> result = array ( ) ; if ( ! $ this -> parse_single ( ) ) { return false ; } while ( count ( $ this -> result ) > 0 ) { switch ( $ p -> token ) { case CSSQueryTokenizer :: TOK_CHILD : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( false , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_SIBLING : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( true , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_PLUS : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_adjacent ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_ALL : case CSSQueryTokenizer :: TOK_IDENTIFIER : case CSSQueryTokenizer :: TOK_STRING : case CSSQueryTokenizer :: TOK_BRACE_OPEN : case CSSQueryTokenizer :: TOK_BRACKET_OPEN : case CSSQueryTokenizer :: TOK_ID : case CSSQueryTokenizer :: TOK_CLASS : case CSSQueryTokenizer :: TOK_COLON : if ( ! $ this -> parse_result ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_NULL : break 2 ; default : $ this -> error ( 'Invalid search pattern(3): No result modifier found!' ) ; return false ; } } return true ; }
8292	protected function checkAccess ( $ url ) { foreach ( $ this -> modules as $ module ) { if ( false === $ module -> handleEvent ( 'checkAccess' , [ $ url ] ) ) { return false ; } } return true ; }
12966	public function getObjectTypeDescriptor ( ) { if ( is_null ( $ this -> _objectTypeDescriptor ) && isset ( $ this -> object ) ) { $ this -> _objectTypeDescriptor = $ this -> object -> objectType -> title -> upperSingular ; } return $ this -> _objectTypeDescriptor ; }
984	public function usageCharge ( StoreUsageCharge $ request ) { $ validated = $ request -> validated ( ) ; $ uc = new UsageCharge ( ShopifyApp :: shop ( ) , $ validated ) ; $ uc -> activate ( ) ; $ uc -> save ( ) ; return isset ( $ validated [ 'redirect' ] ) ? Redirect :: to ( $ validated [ 'redirect' ] ) -> with ( 'success' , 'usage_charge' ) : Redirect :: back ( ) -> with ( 'success' , 'usage_charge' ) ; }
4880	public function getResource ( ) { if ( $ this -> file instanceof \ Doctrine \ MongoDB \ GridFSFile ) { return $ this -> file -> getMongoGridFSFile ( ) -> getResource ( ) ; } return null ; }
9321	protected function compileMarkdownEchos ( $ value ) { $ pattern = sprintf ( '/(@)?%s\s*(.+?)\s*%s(\r?\n)?/s' , $ this -> markdownTags [ 0 ] , $ this -> markdownTags [ 1 ] ) ; $ callback = function ( $ matches ) { $ wrapper = sprintf ( $ this -> markdownFormat , $ this -> compileEchoDefaults ( $ matches [ 2 ] ) ) ; return $ matches [ 1 ] ? strlen ( stripcslashes ( $ this -> markdownTags [ 0 ] ) ) > 2 ? $ matches [ 0 ] : substr ( $ matches [ 0 ] , 1 ) : '<?php echo ' . $ wrapper . '; ?>' ; } ; return preg_replace_callback ( $ pattern , $ callback , $ value ) ; }
3958	protected function registerAssets ( $ objSettings ) { if ( ! $ objSettings ) { return ; } $ arrCss = $ objSettings -> get ( 'additionalCss' ) ; foreach ( ( array ) $ arrCss as $ arrFile ) { if ( $ arrFile [ 'published' ] ) { $ GLOBALS [ 'TL_CSS' ] [ md5 ( $ arrFile [ 'file' ] ) ] = $ arrFile [ 'file' ] ; } } $ arrJs = $ objSettings -> get ( 'additionalJs' ) ; foreach ( ( array ) $ arrJs as $ arrFile ) { if ( $ arrFile [ 'published' ] ) { $ GLOBALS [ 'TL_JAVASCRIPT' ] [ md5 ( $ arrFile [ 'file' ] ) ] = $ arrFile [ 'file' ] ; } } }
6724	protected function validateTokenParams ( ) { if ( empty ( $ this -> tokenUrl ) || filter_var ( $ this -> tokenUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_TOKEN_URL , $ this -> tokenUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
11563	public function LineBreaks ( $ text , $ lang = "" ) { $ this -> text = $ text ; $ word = "" ; $ lang = $ lang ? $ lang : $ this -> lang ; list ( $ weekWords , $ units , $ shortcuts ) = $ this -> getWeekWordsUnitsAndShortcuts ( $ lang ) ; $ this -> text = preg_replace ( "#\t+#mu" , " " , $ this -> text ) ; $ this -> text = preg_replace ( "#[ ]{2,}#mu" , " " , $ this -> text ) ; for ( $ i = 0 , $ l = count ( $ weekWords ) ; $ i < $ l ; $ i += 1 ) { $ word = $ weekWords [ $ i ] ; $ this -> processWeakWord ( $ word ) ; $ word = mb_strtoupper ( mb_substr ( $ word , 0 , 1 ) ) . mb_substr ( $ word , 1 ) ; $ this -> processWeakWord ( $ word ) ; } for ( $ i = 0 , $ l = count ( $ units ) ; $ i < $ l ; $ i += 1 ) { $ word = $ units [ $ i ] ; $ regExp = "#([0-9])\\s(" . $ word . ")#mu" ; $ this -> text = preg_replace ( $ regExp , "$1&nbsp;$2" , $ this -> text ) ; } foreach ( $ shortcuts as $ sourceShortcut => $ targetShortcut ) { $ this -> text = str_replace ( $ sourceShortcut , $ targetShortcut , $ this -> text ) ; } $ this -> text = preg_replace ( "#([0-9])\s([0-9])#" , "$1&nbsp;$2" , $ this -> text ) ; return $ this -> text ; }
4180	protected function notifyUser ( ) { $ this -> console -> line ( '' ) ; $ this -> console -> line ( "{$this->isDone($this->getProviders()->isRegistered())} " . "{$this->getProviders()->count()} service provider registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getFacades()->isRegistered())} " . "{$this->getFacades()->count()} facade registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getMigration()->isRegistered())} " . "{$this->getMigration()->count()} migration file ran." ) ; $ this -> console -> line ( "{$this->isDone($this->getResources()->isRegistered())} " . '- ' . $ this -> console -> tokenizePackageInfo ( ) [ 'name' ] . ' file publish.' ) ; return true ; }
1056	public static function findRemovedTypes ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ breakingChanges = [ ] ; foreach ( array_keys ( $ oldTypeMap ) as $ typeName ) { if ( isset ( $ newTypeMap [ $ typeName ] ) ) { continue ; } $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_REMOVED , 'description' => "${typeName} was removed." , ] ; } return $ breakingChanges ; }
4209	private function methodInfo ( $ obj , \ ReflectionMethod $ reflectionMethod ) { $ declaringClassName = $ reflectionMethod -> getDeclaringClass ( ) -> getName ( ) ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; $ vis = 'public' ; if ( $ reflectionMethod -> isPrivate ( ) ) { $ vis = 'private' ; } elseif ( $ reflectionMethod -> isProtected ( ) ) { $ vis = 'protected' ; } $ info = array ( 'implements' => null , 'inheritedFrom' => $ declaringClassName != \ get_class ( $ obj ) ? $ declaringClassName : null , 'isAbstract' => $ reflectionMethod -> isAbstract ( ) , 'isDeprecated' => $ reflectionMethod -> isDeprecated ( ) || isset ( $ phpDoc [ 'deprecated' ] ) , 'isFinal' => $ reflectionMethod -> isFinal ( ) , 'isStatic' => $ reflectionMethod -> isStatic ( ) , 'params' => $ this -> getParams ( $ reflectionMethod , $ phpDoc ) , 'phpDoc' => $ phpDoc , 'visibility' => $ vis , ) ; unset ( $ info [ 'phpDoc' ] [ 'param' ] ) ; return $ info ; }
9990	private function writeImageInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getDrawingCollection ( ) as $ drawing ) { if ( $ drawing instanceof Drawing ) { if ( $ drawing -> getCoordinates ( ) == $ coordinates ) { $ filename = $ drawing -> getPath ( ) ; if ( substr ( $ filename , 0 , 1 ) == '.' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = $ this -> getImagesRoot ( ) . $ filename ; if ( substr ( $ filename , 0 , 1 ) == '.' && substr ( $ filename , 0 , 2 ) != './' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = htmlspecialchars ( $ filename ) ; $ html .= PHP_EOL ; if ( ( ! $ this -> embedImages ) || ( $ this -> isPdf ) ) { $ imageData = $ filename ; } else { $ imageDetails = getimagesize ( $ filename ) ; if ( $ fp = fopen ( $ filename , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ filename ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; } else { $ imageData = $ filename ; } } $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ drawing -> getOffsetX ( ) . 'px; top: ' . $ drawing -> getOffsetY ( ) . 'px; width: ' . $ drawing -> getWidth ( ) . 'px; height: ' . $ drawing -> getHeight ( ) . 'px;" src="' . $ imageData . '" border="0" />' ; $ html .= '</div>' ; } } elseif ( $ drawing instanceof MemoryDrawing ) { if ( $ drawing -> getCoordinates ( ) != $ coordinates ) { continue ; } ob_start ( ) ; imagepng ( $ drawing -> getImageResource ( ) ) ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; $ dataUri = 'data:image/jpeg;base64,' . base64_encode ( $ contents ) ; $ html .= '<img src="' . $ dataUri . '" style="max-width:100%;width:' . $ drawing -> getWidth ( ) . 'px;" />' ; } } return $ html ; }
10520	public function constraint ( $ string ) { if ( ! isset ( $ this -> tbl_constraint [ 'other' ] ) ) { $ this -> tbl_constraint [ 'other' ] = [ ] ; } $ this -> tbl_constraint [ 'other' ] [ ] = $ string ; return $ this ; }
210	protected function getValidXmlElementName ( $ name ) { if ( empty ( $ name ) || is_int ( $ name ) || ! $ this -> isValidXmlName ( $ name ) ) { return $ this -> itemTag ; } return $ name ; }
12020	function addSetAPIMethod ( ) { $ methodGenerator = new MethodGenerator ( 'setAPI' ) ; $ methodGenerator -> setBody ( '$this->api = $api;' ) ; $ parameterGenerator = new ParameterGenerator ( 'api' , $ this -> apiClassname ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
1159	public function getMessage ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> fakeValidationData ( $ attribute , $ rule , $ parameters ) ; $ message = $ this -> validator -> getMessage ( $ attribute , $ rule ) ; $ message = $ this -> validator -> makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) ; $ this -> validator -> setData ( $ data ) ; return $ message ; }
5034	public function hydrate ( $ value ) { if ( ! is_array ( $ value ) ) { return null ; } $ entity = $ this -> getTargetEntity ( ) ; foreach ( $ value as $ key => $ v ) { $ entity -> { "set$key" } ( $ v ) ; } return $ entity ; }
3598	public function parserHttpRequest ( HttpRequest $ httpRequest ) { $ json = \ json_decode ( $ httpRequest -> getContent ( ) , true ) ; if ( JSON_ERROR_NONE !== \ json_last_error ( ) ) { throw new Exceptions \ ParseException ( ) ; } $ createJsonRequest = function ( $ json ) use ( $ httpRequest ) { $ id = null ; $ method = null ; $ params = [ ] ; if ( \ is_array ( $ json ) ) { $ id = \ array_key_exists ( 'id' , $ json ) ? $ json [ 'id' ] : null ; $ method = \ array_key_exists ( 'method' , $ json ) ? $ json [ 'method' ] : null ; $ params = \ array_key_exists ( 'params' , $ json ) ? $ json [ 'params' ] : [ ] ; } $ request = new JsonRequest ( $ method , $ params , $ id ) ; $ request -> headers ( ) -> add ( $ httpRequest -> headers -> all ( ) ) ; return $ request ; } ; if ( \ array_keys ( $ json ) === \ range ( 0 , \ count ( $ json ) - 1 ) ) { $ requests = [ ] ; foreach ( $ json as $ part ) { $ requests [ ] = $ createJsonRequest ( $ part ) ; } } else { $ requests = $ createJsonRequest ( $ json ) ; } return $ requests ; }
7770	public function errors ( ) { $ messages = [ ] ; foreach ( $ this -> errors as $ rule => $ items ) { foreach ( $ items as $ item ) { $ field = $ item [ 'field' ] ; $ message = $ this -> fetchMessage ( $ field , $ rule ) ; if ( isset ( $ this -> fieldAliases [ $ field ] ) ) { $ item [ 'field' ] = $ this -> fieldAliases [ $ field ] ; } $ messages [ $ field ] [ ] = $ this -> replaceMessageFormat ( $ message , $ item ) ; } } return new MessageBag ( $ messages ) ; }
1984	public function getAllOptions ( ) : array { $ this -> loadOptions ( ) ; $ event = new ImageSizesEvent ( $ this -> options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_ALL , $ event ) ; return $ event -> getImageSizes ( ) ; }
9484	public function fromArray ( array $ array ) { foreach ( $ array as $ k => $ v ) { if ( ! is_null ( $ v ) && property_exists ( get_class ( $ this ) , $ k ) ) { $ meta = new \ ReflectionProperty ( get_class ( $ this ) , $ k ) ; $ info = $ this -> parsePropertyDocComment ( $ meta -> getDocComment ( ) ) ; $ type = $ info [ 'type' ] ; if ( strtolower ( $ type ) == "array" && $ elementType = $ info [ 'array_element' ] ) { if ( class_exists ( $ elementType ) ) { $ children = array ( ) ; foreach ( $ v as $ subV ) { $ newElement = new $ elementType ( ) ; $ children [ ] = $ newElement -> fromArray ( $ subV ) ; } $ this -> $ k = $ children ; } else { throw new \ Exception ( '@element Class Not Found:' . $ elementType ) ; } } else if ( class_exists ( $ type ) ) { $ typeObject = new $ type ( ) ; $ this -> $ k = $ typeObject -> fromArray ( $ v ) ; } else { $ this -> $ k = $ v ; } } } return $ this ; }
9182	public function remember ( $ value , $ memoryDuration = null ) { if ( is_null ( $ memoryDuration ) ) { $ memoryDuration = $ this -> memoryDuration ; } $ key = $ this -> getRememberKey ( ) ; if ( Cache :: has ( $ key ) ) { $ value = Cache :: get ( $ key ) ; } else { $ expiresAt = Carbon :: now ( ) -> addMinutes ( $ memoryDuration ) ; if ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } Cache :: put ( $ key , $ value , $ expiresAt ) ; } return $ value ; }
3154	public function getTraceVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_TraceVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setTrace ( $ variableValue ) ; return $ metaVariable ; }
8096	public function destroy ( ) { if ( ! is_null ( $ this -> getValue ( ) ) ) { if ( ! headers_sent ( ) ) { return setcookie ( $ this -> name , '' , time ( ) - 3600 , $ this -> path , $ this -> host ) ; } else { return false ; } } else { return true ; } }
11706	public function storageValidate ( $ validators , $ storage ) { $ errors = [ ] ; foreach ( $ validators as $ kValidate => $ validate ) { if ( ! isset ( $ storage [ $ kValidate ] ) ) { $ errors [ ] = [ 'field' => $ kValidate , 'message' => 'Value ' . $ kValidate . ' not found.' ] ; continue ; } $ error = $ this -> validate ( $ validate , $ storage [ $ kValidate ] ) ; if ( $ error ) $ errors [ ] = [ 'field' => $ kValidate , 'message' => $ error ] ; } return $ errors ; }
11680	public function setPath ( $ path ) { if ( $ path === null ) { throw new PathCanNotBeNull ( ) ; } $ this -> path = rtrim ( $ path , '\\/' ) . '/' ; return $ this ; }
2727	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> determineVersions ( $ service -> versions ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> request -> getParam ( 'acls' ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetName = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; $ snippetId = $ this -> api -> getSnippet ( $ currActiveVersion [ 'active_version' ] , $ snippetName ) -> id ; $ params = [ 'name' => $ snippetId , 'content' => $ value ] ; $ this -> api -> updateSnippet ( $ params ) ; } $ this -> cacheTypeList -> cleanType ( 'config' ) ; $ this -> systemConfig -> clean ( ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
134	public function isPackageInstalled ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( $ package instanceof AliasPackage ) { return $ repo -> hasPackage ( $ package ) && $ this -> isPackageInstalled ( $ repo , $ package -> getAliasOf ( ) ) ; } return $ this -> getInstaller ( $ package -> getType ( ) ) -> isInstalled ( $ repo , $ package ) ; }
10540	protected function typeModification ( $ type , array $ args ) { if ( is_int ( $ args [ 1 ] ) ) { $ type .= '(' . $ args [ 1 ] ; if ( isset ( $ args [ 2 ] ) ) { $ type .= ',' . $ args [ 2 ] ; } $ type .= ')' ; } elseif ( is_array ( $ args [ 1 ] ) ) { if ( isset ( $ args [ 1 ] [ 'size' ] ) ) { $ type .= '(' . $ args [ 1 ] [ 'size' ] . ')' ; } foreach ( $ args [ 1 ] as $ key => $ val ) { if ( 'size' === $ key ) { continue ; } $ type .= ' ' . strtoupper ( $ key ) ; } } else { $ type .= $ args [ 1 ] ; } return $ type ; }
2502	protected function mapData ( array $ data ) { $ values = array ( ) ; reset ( $ data ) ; while ( $ key = current ( $ data ) ) { $ values [ $ key ] = next ( $ data ) ; next ( $ data ) ; } return $ values ; }
12914	protected function getWhereAsArray ( ) { $ filters = [ ] ; if ( ! empty ( $ this -> filters ) ) { $ filters = $ this -> filters ; } if ( ! $ this -> allowDeleted ) { $ filters [ ] = "(`" . $ this -> table . "`.deleted = 0 OR `" . $ this -> table . "`.deleted IS NULL)" ; } if ( ! empty ( $ this -> joins ) ) { foreach ( $ this -> joins as $ join ) { $ manager = $ join [ 'manager' ] ; $ filters = array_merge ( $ filters , $ manager -> getWhereAsArray ( ) ) ; } } return $ filters ; }
8092	static public function decode ( $ number ) { $ k = self :: $ encoder ; preg_match_all ( '/[1][a-zA-Z]|[2-9]|[a-zA-Z]|[0]/' , $ number , $ a ) ; $ n = '' ; $ o = count ( $ k ) ; foreach ( $ a [ 0 ] as $ i ) { $ f = preg_match ( '/1([a-zA-Z])/' , $ i , $ v ) ; if ( $ f == true ) { $ i = $ o + array_search ( $ v [ 1 ] , $ k ) ; } else { $ i = array_search ( $ i , $ k ) ; } $ n .= $ i ; } return $ n ; }
7069	static function isValid ( $ unit , $ throw = false ) { if ( in_array ( $ unit , static :: getUnits ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Invalid unit '$unit'." ) ; } return false ; }
7840	public function addNumber ( int $ id , string $ number ) : ? array { $ response = Request :: put ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
5560	public function recordEntry ( $ url , $ parameters ) { $ this -> dropFuture ( ) ; array_push ( $ this -> sequence , array ( 'url' => $ url , 'parameters' => $ parameters ) ) ; $ this -> position ++ ; }
10831	public static function createFromSplFileInfo ( \ SplFileInfo $ info ) { $ realpath = $ info -> getRealPath ( ) ; if ( $ info -> isFile ( ) ) { return new fs \ entity \ FileEntity ( $ realpath ) ; } return new fs \ entity \ DirEntity ( $ realpath ) ; }
6355	public function setTimestamp ( $ ts = false ) { $ m = [ ] ; $ da = [ ] ; $ strtime = '' ; if ( ! $ ts || $ ts === "\0\0\0\0\0\0\0\0\0\0\0\0\0\0" ) { $ uts = self :: time ( ) ; $ strtime = "@$uts" ; } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4}):(\d\d):(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(-?\d{1,13})$/D' , $ ts , $ m ) ) { $ strtime = "@{$m[1]}" ; } elseif ( preg_match ( '/^(-?\d{1,13})(\.\d+)$/D' , $ ts , $ m ) ) { $ strtime = 'unixmicro' ; } elseif ( preg_match ( '/^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}.\d{6}$/' , $ ts ) ) { $ strtime = preg_replace ( '/(\d\d)\.(\d\d)\.(\d\d)(\.(\d+))?/' , "$1:$2:$3" , str_replace ( '+00:00' , 'UTC' , $ ts ) ) ; } elseif ( preg_match ( '/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d*[\+\- ](\d\d)$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d* GMT$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^[ \t\r\n]*([A-Z][a-z]{2},[ \t\r\n]*)?' . '\d\d?[ \t\r\n]*[A-Z][a-z]{2}[ \t\r\n]*\d{2}(?:\d{2})?' . '[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d/S' , $ ts ) ) { $ strtime = strtok ( $ ts , ';' ) ; } elseif ( preg_match ( '/^[A-Z][a-z]{5,8}, \d\d-[A-Z][a-z]{2}-\d{2} \d\d:\d\d:\d\d/' , $ ts ) ) { $ strtime = $ ts ; } elseif ( preg_match ( '/^[A-Z][a-z]{2} [A-Z][a-z]{2} +\d{1,2} \d\d:\d\d:\d\d \d{4}/' , $ ts ) ) { $ strtime = $ ts ; } else { throw new TimestampException ( __METHOD__ . ": Invalid timestamp - $ts" ) ; } if ( ! $ strtime ) { $ da = array_map ( 'intval' , $ da ) ; $ da [ 0 ] = "%04d-%02d-%02dT%02d:%02d:%02d.00+00:00" ; $ strtime = call_user_func_array ( "sprintf" , $ da ) ; } try { if ( $ strtime === 'unixmicro' ) { $ final = DateTime :: createFromFormat ( 'U.u' , $ ts , new DateTimeZone ( 'GMT' ) ) ; } else { $ final = new DateTime ( $ strtime , new DateTimeZone ( 'GMT' ) ) ; } } catch ( Exception $ e ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' , $ e -> getCode ( ) , $ e ) ; } if ( $ final === false ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' ) ; } $ this -> timestamp = $ final ; }
82	public function extractTo ( $ target , array $ roles = array ( 'php' => '/' , 'script' => '/bin' ) , $ vars = array ( ) ) { $ extractionPath = $ target . '/tarball' ; try { $ archive = new \ PharData ( $ this -> file ) ; $ archive -> extractTo ( $ extractionPath , null , true ) ; if ( ! is_file ( $ this -> combine ( $ extractionPath , '/package.xml' ) ) ) { throw new \ RuntimeException ( 'Invalid PEAR package. It must contain package.xml file.' ) ; } $ fileCopyActions = $ this -> buildCopyActions ( $ extractionPath , $ roles , $ vars ) ; $ this -> copyFiles ( $ fileCopyActions , $ extractionPath , $ target , $ roles , $ vars ) ; $ this -> filesystem -> removeDirectory ( $ extractionPath ) ; } catch ( \ Exception $ exception ) { throw new \ UnexpectedValueException ( sprintf ( 'Failed to extract PEAR package %s to %s. Reason: %s' , $ this -> file , $ target , $ exception -> getMessage ( ) ) , 0 , $ exception ) ; } }
2469	public function mapContentBlock ( Content $ content ) { $ contentInfo = $ content -> versionInfo -> contentInfo ; $ locations = $ this -> locationHandler -> loadLocationsByContent ( $ contentInfo -> id ) ; $ blockFields = $ this -> getBlockFields ( $ content ) ; $ contentFields = $ this -> getContentFields ( $ content ) ; $ documents = [ ] ; $ locationFieldsMap = [ ] ; foreach ( $ locations as $ location ) { $ locationFieldsMap [ $ location -> id ] = $ this -> getLocationFields ( $ location ) ; } foreach ( array_keys ( $ content -> versionInfo -> names ) as $ languageCode ) { $ blockTranslationFields = $ this -> getBlockTranslationFields ( $ content , $ languageCode ) ; $ translationLocationDocuments = array ( ) ; foreach ( $ locations as $ location ) { $ translationLocationDocuments [ ] = new Document ( array ( 'id' => $ this -> generateLocationDocumentId ( $ location -> id , $ languageCode ) , 'fields' => array_merge ( $ blockFields , $ locationFieldsMap [ $ location -> id ] , $ blockTranslationFields ) , ) ) ; } $ isMainTranslation = ( $ contentInfo -> mainLanguageCode === $ languageCode ) ; $ alwaysAvailable = ( $ isMainTranslation && $ contentInfo -> alwaysAvailable ) ; $ contentTranslationFields = $ this -> getContentTranslationFields ( $ content , $ languageCode ) ; $ documents [ ] = new Document ( array ( 'id' => $ this -> generateContentDocumentId ( $ contentInfo -> id , $ languageCode ) , 'languageCode' => $ languageCode , 'alwaysAvailable' => $ alwaysAvailable , 'isMainTranslation' => $ isMainTranslation , 'fields' => array_merge ( $ blockFields , $ contentFields , $ blockTranslationFields , $ contentTranslationFields ) , 'documents' => $ translationLocationDocuments , ) ) ; } return $ documents ; }
1252	private function normalizeElementName ( $ name ) { $ nsElement = explode ( '@' , $ name ) ; if ( count ( $ nsElement ) > 1 ) { array_shift ( $ nsElement ) ; return $ nsElement [ 0 ] ; } else { return $ name ; } }
760	public function getIsCollection ( ) { return in_array ( $ this -> type , [ self :: TYPE_CODE , self :: TYPE_STATEMENT , self :: TYPE_PARENTHESIS , ] , true ) ; }
5700	protected function getDefaultButtonList ( $ config ) { $ new = ( $ this -> owner -> ID == 0 ) ; $ list = $ new ? Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_create" : "create" ) : Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_edit" : "edit" ) ; return $ list ? : array ( ) ; }
4583	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! array_key_exists ( $ this -> attribute , $ payload ) ) { $ event -> markAsInvalid ( ) ; } $ uuid = $ payload [ $ this -> attribute ] ; $ tenant = $ this -> tenantService -> getRepository ( ) -> findBy ( [ 'uuid' => $ uuid ] ) ; if ( ! $ tenant ) { $ event -> markAsInvalid ( ) ; } }
7685	function XML_DeleteColumnElements ( & $ Txt , $ Tag , $ SpanAtt , $ ColLst , $ ColMax ) { $ ColNum = 0 ; $ ColPos = 0 ; $ ColQty = 1 ; $ Continue = true ; $ ModifNbr = 0 ; while ( $ Continue && ( $ Loc = clsTbsXmlLoc :: FindElement ( $ Txt , $ Tag , $ ColPos , true ) ) ) { if ( $ SpanAtt !== false ) { $ ColQty = $ Loc -> GetAttLazy ( $ SpanAtt ) ; $ ColQty = ( $ ColQty === false ) ? 1 : intval ( $ ColQty ) ; } $ KeepQty = 0 ; for ( $ i = 1 ; $ i <= $ ColQty ; $ i ++ ) { if ( array_search ( $ ColNum + $ i , $ ColLst ) === false ) $ KeepQty ++ ; } if ( $ KeepQty == 0 ) { $ Loc -> ReplaceSrc ( '' ) ; $ ModifNbr ++ ; } else { if ( $ KeepQty != $ ColQty ) { $ Loc -> ReplaceAtt ( $ SpanAtt , $ KeepQty ) ; $ ModifNbr ++ ; } $ ColPos = $ Loc -> PosEnd + 1 ; } $ ColNum += $ ColQty ; if ( $ ColNum > $ ColMax ) $ Continue = false ; } return $ ModifNbr ; }
1838	public static function findBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ blnModel = false ; $ arrColumn = ( array ) $ strColumn ; if ( \ count ( $ arrColumn ) == 1 && ( $ arrColumn [ 0 ] === static :: getPk ( ) || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) ) { $ blnModel = true ; } $ arrOptions = array_merge ( array ( 'column' => $ strColumn , 'value' => $ varValue , 'return' => $ blnModel ? 'Model' : 'Collection' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
8716	public static function createInLocale ( $ locale , array $ attributes = [ ] , $ translations = [ ] ) { $ model = ( new static ( $ attributes ) ) -> setLocale ( $ locale ) ; if ( $ model -> save ( ) && is_array ( $ translations ) ) { $ model -> saveTranslations ( $ translations ) ; } return $ model ; }
10915	protected function findController ( $ object ) { $ urlargs = $ this -> arguments ; $ arg = $ urlargs -> shift ( ) ; $ controller = $ arg ; if ( ( $ pos = strpos ( $ controller , '.' ) ) !== false ) $ controller = substr ( $ controller , 0 , $ pos ) ; if ( ! method_exists ( $ object , $ controller ) ) { if ( method_exists ( $ object , "index" ) ) { if ( $ controller !== null ) $ urlargs -> unshift ( $ arg ) ; $ controller = "index" ; } else throw new HTTPError ( 404 , "Unknown controller: " . $ controller ) ; } return $ controller ; }
4602	public function encrypt ( $ data , string $ key = null ) : string { $ key = $ this -> createKey ( $ key ) ; $ data = Crypto :: encrypt ( serialize ( $ data ) , $ key ) ; return $ data ; }
11445	public function getTransporter ( ) { if ( empty ( $ this -> transporter ) ) { $ transport_class = $ this -> getDefault ( 'transporter' ) ; if ( class_exists ( $ transport_class ) ) { $ this -> setTransporter ( new $ transport_class ) ; } else { throw new \ Exception ( sprintf ( 'Default transport class "%s" not found!' , $ transport_class ) ) ; } } return $ this -> transporter ; }
875	private function convertToNowdoc ( Token $ token ) { return new Token ( [ $ token -> getId ( ) , Preg :: replace ( '/^([Bb]?<<<)([ \t]*)"?([^\s"]+)"?/' , '$1$2\'$3\'' , $ token -> getContent ( ) ) , ] ) ; }
11692	private function buildParsedRequests ( ApiParseResult $ parseResult ) : array { $ requests = [ ] ; foreach ( $ parseResult -> getApi ( ) -> getResourceGroups ( ) as $ apiResourceGroup ) { foreach ( $ apiResourceGroup -> getResources ( ) as $ apiResource ) { foreach ( $ apiResource -> getTransitions ( ) as $ apiStateTransition ) { foreach ( $ apiStateTransition -> getHttpTransactions ( ) as $ apiHttpTransaction ) { $ this -> processApiHttpTransactions ( $ apiHttpTransaction , $ apiResourceGroup , $ apiResource , $ apiStateTransition , $ requests ) ; } } } } return $ requests ; }
391	protected static function filterValidAliases ( Query $ query ) { $ tables = $ query -> getTablesUsedInFrom ( ) ; $ aliases = array_diff ( array_keys ( $ tables ) , $ tables ) ; return array_map ( function ( $ alias ) { return preg_replace ( '/{{([\w]+)}}/' , '$1' , $ alias ) ; } , array_values ( $ aliases ) ) ; }
12941	public function storePermissions ( $ params = array ( ) ) { $ authorityAreaTitle = $ this -> input -> getString ( "area-title" ) ; $ authorityAreaURI = $ this -> input -> getString ( "area-uri" ) ; $ authorityAreaAction = $ this -> input -> getString ( "area-action" ) ; $ authorityAreaPermission = $ this -> input -> getString ( "area-permission" ) ; $ authorityId = $ this -> input -> getInt ( "area-authority" ) ; $ table = $ this -> load -> table ( "?authority_permissions" ) ; $ aData = array ( "authority_id" => $ authorityId , "permission_area_uri" => strtolower ( $ authorityAreaURI ) , "permission" => strtolower ( $ authorityAreaPermission ) , "permission_type" => strtolower ( $ authorityAreaAction ) , "permission_title" => $ authorityAreaTitle ) ; foreach ( $ aData as $ k => $ item ) { if ( empty ( $ item ) ) { $ this -> setError ( _t ( "Please complete all permission fields; Provide a title and uri defining the area, a permission type and value" ) ) ; return false ; } } if ( ! $ table -> bindData ( $ aData ) ) { throw new \ Platform \ Exception ( $ table -> getError ( ) ) ; return false ; } if ( $ table -> isNewRow ( ) ) { } if ( ! $ table -> save ( ) ) { return false ; } return true ; }
10449	public function load ( $ config ) { if ( is_string ( $ config ) and file_exists ( $ config ) ) { $ config = include $ config ; } if ( ! is_array ( $ config ) ) { $ msg = 'Failed to load configuration data' ; throw new ConfigurationException ( $ msg ) ; } return new Configuration ( $ config ) ; }
9024	public function hasDenial ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( in_array ( $ word , $ this -> denialWords ) ) { $ result = true ; } } return $ result ; }
5493	public function add ( $ parameters , $ action ) { $ place = count ( $ this -> map ) ; $ this -> map [ $ place ] = array ( ) ; $ this -> map [ $ place ] [ 'params' ] = new ParametersExpectation ( $ parameters ) ; $ this -> map [ $ place ] [ 'content' ] = $ action ; }
51	public function addRepository ( RepositoryInterface $ repository ) { if ( $ repository instanceof self ) { foreach ( $ repository -> getRepositories ( ) as $ repo ) { $ this -> addRepository ( $ repo ) ; } } else { $ this -> repositories [ ] = $ repository ; } }
1658	private function getDateTime ( $ argument ) { $ datetimeValue = $ argument [ 'datetimeValue' ] ; $ year = $ datetimeValue [ 'date' ] [ 'year' ] ; $ month = $ datetimeValue [ 'date' ] [ 'month' ] ; $ day = $ datetimeValue [ 'date' ] [ 'day' ] ; $ hours = $ datetimeValue [ 'time' ] [ 'hours' ] ; $ minutes = isset ( $ datetimeValue [ 'time' ] [ 'minutes' ] ) ? $ datetimeValue [ 'time' ] [ 'minutes' ] : 0 ; return Carbon :: create ( $ year , $ month , $ day , $ hours , $ minutes , 0 ) ; }
8561	public function cancelShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_CancelShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CancelShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_CancelShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CancelShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CancelShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_CancelShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1811	public function addCteType ( $ arrRow ) { $ key = $ arrRow [ 'invisible' ] ? 'unpublished' : 'published' ; $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ arrRow [ 'type' ] ] [ 0 ] ? : '&nbsp;' ; $ class = 'limit_height' ; if ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'start' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'separator' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'stop' ] ) ) { $ class = '' ; if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } elseif ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'single' ] ) ) { if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } if ( $ arrRow [ 'type' ] == 'alias' ) { $ type .= ' ID ' . $ arrRow [ 'cteAlias' ] ; } if ( $ arrRow [ 'protected' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'protected' ] . ')' ; } elseif ( $ arrRow [ 'guests' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'guests' ] . ')' ; } if ( $ arrRow [ 'type' ] == 'headline' ) { if ( \ is_array ( $ headline = Contao \ StringUtil :: deserialize ( $ arrRow [ 'headline' ] ) ) ) { $ type .= ' (' . $ headline [ 'unit' ] . ')' ; } } if ( ! Contao \ Config :: get ( 'doNotCollapse' ) ) { $ class .= ' h40' ; } $ objModel = new Contao \ ContentModel ( ) ; $ objModel -> setRow ( $ arrRow ) ; return '<div class="cte_type ' . $ key . '">' . $ type . '</div><div class="' . trim ( $ class ) . '">' . Contao \ StringUtil :: insertTagToSrc ( $ this -> getContentElement ( $ objModel ) ) . '</div>' . "\n" ; }
3924	public function getValueOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ options = $ this -> getOptionsViaDcGeneral ( $ metaModel , $ event -> getEnvironment ( ) , $ attribute ) ; $ mangled = [ ] ; foreach ( ( array ) $ options as $ key => $ option ) { $ mangled [ 'value_' . $ key ] = $ option ; } $ event -> setOptions ( $ mangled ) ; } }
8971	protected function fromJson ( $ json ) { $ data = json_decode ( $ json , true ) ; return new Rate ( $ data [ 'sourceName' ] , ( float ) $ data [ 'value' ] , $ data [ 'currencyCode' ] , $ data [ 'rateType' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'date' ] ) , $ data [ 'baseCurrencyCode' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'createdAt' ] ) , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'modifiedAt' ] ) ) ; }
2303	public function addCustomLayoutSectionReferences ( ) { $ objLayout = $ this -> Database -> getInstance ( ) -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ v [ 'id' ] ] = $ v [ 'title' ] ; } } } } }
10085	public function setMapping ( $ severity , $ pipe ) { if ( ! isset ( $ this -> mapping [ $ severity ] ) ) { throw new \ RuntimeException ( "Unknown severity: " . $ severity ) ; } if ( ( $ pipe !== self :: SILENCE ) && ( $ pipe !== self :: STDOUT ) && ( $ pipe !== self :: STDERR ) ) { throw new \ RuntimeException ( "Unknown output pipe: " . $ pipe ) ; } $ this -> mapping [ $ severity ] = $ pipe ; }
8107	protected function getTemplateVariables ( $ recipient , $ config , $ pages ) { return [ 'Subject' => $ config -> ReviewSubject , 'PagesCount' => $ pages -> count ( ) , 'FromEmail' => $ config -> ReviewFrom , 'ToFirstName' => $ recipient -> FirstName , 'ToSurname' => $ recipient -> Surname , 'ToEmail' => $ recipient -> Email , ] ; }
10605	public function addHeaders ( array $ headers ) : void { foreach ( $ headers as $ name => $ value ) { $ this -> addHeader ( ( string ) $ name , $ value ) ; } }
12770	public function authorize ( RecordInterface & $ user , $ remember = false ) { if ( parent :: authorize ( $ user , $ remember ) ) { if ( $ remember ) { $ token = $ user [ $ this -> dbHashEmailField ] . ( time ( ) + ( $ this -> cookieTime ) ) . $ user [ $ this -> dbHashPasswordField ] ; $ user [ $ this -> dbAccessToken ] = $ token ; $ user -> save ( ) ; $ expiry = time ( ) + ( $ this -> cookieTime ) ; $ cookieData = array ( "token" => $ token , "expiry" => $ expiry ) ; setcookie ( '_cookie_accessToken' , serialize ( $ cookieData ) , $ expiry ) ; } } }
7863	protected function drawCenteredChar ( $ character ) { $ spaces = str_repeat ( ' ' , $ this -> geometry -> getHalfWidth ( ) ) ; $ this -> drawRow ( $ spaces . $ character ) ; }
3033	public function getSessionDescription ( \ taoQtiTest_helpers_TestSession $ session ) { if ( $ session -> isRunning ( ) ) { $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ progressScope = isset ( $ config [ 'progress-indicator-scope' ] ) ? $ config [ 'progress-indicator-scope' ] : 'test' ; $ progress = $ this -> getSessionProgress ( $ session ) ; $ itemPosition = $ progress [ $ progressScope ] ; $ itemCount = $ progress [ $ progressScope . 'Length' ] ; $ format = $ this -> hasOption ( self :: OPTION_STATE_FORMAT ) ? $ this -> getOption ( self :: OPTION_STATE_FORMAT ) : __ ( '%s - item %p/%c' ) ; $ map = array ( '%s' => $ session -> getCurrentAssessmentSection ( ) -> getTitle ( ) , '%p' => $ itemPosition , '%c' => $ itemCount ) ; return strtr ( $ format , $ map ) ; } else { return __ ( 'finished' ) ; } }
11268	public static function new ( string $ type = 'default' , string $ path = Migrate :: DEFAULT_PATH , $ notify = NotifyInterface :: LOGGER ) : Creator { $ fs = new Filesystem ( new Local ( $ path ) ) ; $ note = NotifyFactory :: create ( $ notify ) ; return new static ( CreatorFactory :: create ( $ type , $ note ) , $ fs , $ note ) ; }
2039	private function createConfig ( $ size ) : array { if ( ! \ is_array ( $ size ) ) { $ size = [ 0 , 0 , $ size ] ; } $ config = new PictureConfiguration ( ) ; $ attributes = [ ] ; if ( ! isset ( $ size [ 2 ] ) || ! is_numeric ( $ size [ 2 ] ) ) { $ resizeConfig = new ResizeConfiguration ( ) ; if ( ! empty ( $ size [ 0 ] ) ) { $ resizeConfig -> setWidth ( ( int ) $ size [ 0 ] ) ; } if ( ! empty ( $ size [ 1 ] ) ) { $ resizeConfig -> setHeight ( ( int ) $ size [ 1 ] ) ; } if ( ! empty ( $ size [ 2 ] ) ) { $ resizeConfig -> setMode ( $ size [ 2 ] ) ; } $ configItem = new PictureConfigurationItem ( ) ; $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( $ this -> defaultDensities ) { $ configItem -> setDensities ( $ this -> defaultDensities ) ; } $ config -> setSize ( $ configItem ) ; return [ $ config , $ attributes ] ; } $ imageSizeModel = $ this -> framework -> getAdapter ( ImageSizeModel :: class ) ; $ imageSizes = $ imageSizeModel -> findByPk ( $ size [ 2 ] ) ; $ config -> setSize ( $ this -> createConfigItem ( $ imageSizes ) ) ; if ( $ imageSizes && $ imageSizes -> cssClass ) { $ attributes [ 'class' ] = $ imageSizes -> cssClass ; } $ imageSizeItemModel = $ this -> framework -> getAdapter ( ImageSizeItemModel :: class ) ; $ imageSizeItems = $ imageSizeItemModel -> findVisibleByPid ( $ size [ 2 ] , [ 'order' => 'sorting ASC' ] ) ; if ( null !== $ imageSizeItems ) { $ configItems = [ ] ; foreach ( $ imageSizeItems as $ imageSizeItem ) { $ configItems [ ] = $ this -> createConfigItem ( $ imageSizeItem ) ; } $ config -> setSizeItems ( $ configItems ) ; } return [ $ config , $ attributes ] ; }
12968	protected function renderPage ( ) { $ page = $ this -> options [ "page" ] ; $ request = $ this -> options [ "request" ] ; $ username = $ this -> options [ "username" ] ; $ pageOptions = array ( 'page' => $ request -> get ( 'page' ) , 'language' => $ request -> get ( '_locale' ) , 'country' => $ request -> get ( 'country' ) , ) ; $ page -> render ( $ this -> configuration -> siteDir ( ) , $ pageOptions , $ username ) ; return $ page ; }
11970	public function extendExpiration ( ) { if ( null === $ this -> ttl ) { throw new DomainException ( 'There is no TTL set for this Lock.' ) ; } if ( ! $ this -> expiresAt ) { $ this -> expiresAt = new \ DateTime ( ) ; $ this -> expiresAt -> setTimestamp ( time ( ) ) ; } $ this -> expiresAt -> add ( $ this -> ttl ) ; }
9914	public function create ( $ modelName , ModelConfig $ config = null ) { $ menu = new Menu ( ) ; $ addMenuItem = new LinkMenuItem ( ) ; $ addMenuItem -> setText ( Lang :: trans ( 'Add' ) ) ; $ addMenuItem -> setIcon ( Icons :: ion_plus ) ; $ addMenuItem -> setTarget ( URL :: route ( $ this -> aujaRouter -> getCreateName ( $ modelName ) ) ) ; $ menu -> addMenuItem ( $ addMenuItem ) ; $ spacerMenuItem = new SpacerMenuItem ( ) ; $ spacerMenuItem -> setText ( Lang :: trans ( $ modelName ) ) ; $ menu -> addMenuItem ( $ spacerMenuItem ) ; $ resourceMenuItem = new ResourceMenuItem ( ) ; $ resourceMenuItem -> setTarget ( URL :: route ( $ this -> aujaRouter -> getIndexName ( $ modelName ) ) ) ; $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; if ( $ this -> aujaConfigurator -> isSearchable ( $ model , $ config ) ) { $ target = urldecode ( URL :: route ( $ this -> aujaRouter -> getIndexName ( $ modelName ) , [ 'q' => '%s' ] ) ) ; $ property = new Searchable ( $ target ) ; $ resourceMenuItem -> addProperty ( $ property ) ; } $ menu -> addMenuItem ( $ resourceMenuItem ) ; return $ menu ; }
4240	public function onConfig ( Event $ event ) { $ cfg = $ event [ 'config' ] ; if ( ! isset ( $ cfg [ 'debug' ] ) ) { return ; } $ cfg = $ cfg [ 'debug' ] ; if ( isset ( $ cfg [ 'file' ] ) ) { $ this -> debug -> addPlugin ( $ this -> debug -> output -> file ) ; } if ( isset ( $ cfg [ 'onBootstrap' ] ) ) { if ( ! $ this -> debug -> parentInstance ) { $ this -> debug -> eventManager -> subscribe ( 'debug.bootstrap' , $ cfg [ 'onBootstrap' ] ) ; } else { \ call_user_func ( $ cfg [ 'onBootstrap' ] , new Event ( $ this -> debug ) ) ; } } if ( isset ( $ cfg [ 'onLog' ] ) ) { if ( isset ( $ this -> cfg [ 'onLog' ] ) ) { $ this -> debug -> eventManager -> unsubscribe ( 'debug.log' , $ this -> cfg [ 'onLog' ] ) ; } $ this -> debug -> eventManager -> subscribe ( 'debug.log' , $ cfg [ 'onLog' ] ) ; } if ( ! static :: $ profilingEnabled ) { $ cfg = $ this -> debug -> getCfg ( 'debug/*' ) ; if ( $ cfg [ 'enableProfiling' ] && $ cfg [ 'collect' ] ) { static :: $ profilingEnabled = true ; $ pathsExclude = array ( __DIR__ , ) ; FileStreamWrapper :: register ( $ pathsExclude ) ; } } }
4017	protected function handleLoadCallback ( $ field , $ value ) { if ( isset ( $ field [ 'load_callback' ] ) && is_array ( $ field [ 'load_callback' ] ) ) { foreach ( $ field [ 'load_callback' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ value = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ value , $ this ) ; } } return $ value ; }
11217	public static function getMethod ( $ route ) { $ route = Url :: addBackSlash ( $ route ) ; return isset ( self :: $ routes [ $ route ] ) ? self :: $ routes [ $ route ] : null ; }
1555	protected function queryValidatorWithoutSearch ( ) { return $ this -> validatorFactory ( ) -> queryParameters ( $ this -> queryRulesWithoutSearch ( ) , $ this -> queryMessages ( ) , $ this -> queryCustomAttributes ( ) , function ( Validator $ validator ) { return $ this -> conditionalQuery ( $ validator ) ; } ) ; }
1962	public static function decodeEmail ( $ strEmail ) { if ( $ strEmail == '' ) { return '' ; } if ( strpos ( $ strEmail , '@' ) === false ) { return $ strEmail ; } $ arrChunks = explode ( '@' , $ strEmail ) ; $ strHost = static :: decode ( array_pop ( $ arrChunks ) ) ; if ( $ strHost == '' ) { return '' ; } return implode ( '@' , $ arrChunks ) . '@' . $ strHost ; }
771	public function actionConfig ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; $ dir = dirname ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } $ array = VarDumper :: export ( $ this -> getOptionValues ( $ this -> action -> id ) ) ; $ content = <<<EOD<?php/** * Configuration file for 'yii {$this->id}/{$this->defaultAction}' command. * * This file is automatically generated by 'yii {$this->id}/{$this->action->id}' command. * It contains parameters for source code messages extraction. * You may modify this file to suit your needs. * * You can use 'yii {$this->id}/{$this->action->id}-template' command to create * template configuration file with detailed description for each parameter. */return $array;EOD ; if ( FileHelper :: createDirectory ( $ dir ) === false || file_put_contents ( $ filePath , $ content , LOCK_EX ) === false ) { $ this -> stdout ( "Configuration file was NOT created: '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file created: '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; }
2785	private function extractFail ( $ output ) { if ( preg_match ( '%##teamcity\[testFailed.*\]%' , $ output , $ matches ) ) { preg_match ( "/##teamcity\\[testFailed.*name='(.*)' message='(.*)' details='\\s*(.*)' flowId=.*/" , $ output , $ matches ) ; $ matches = $ this -> replaceEscapedChars ( $ matches ) ; $ fail = sprintf ( 'Test Name: %s' . PHP_EOL . 'Failure Message: %s' . PHP_EOL . 'Trace:' . PHP_EOL . '%s' , $ matches [ 1 ] , $ matches [ 2 ] , $ matches [ 3 ] ) ; return $ fail ; } return 'No failure output was detected by Humbug, but a failure was reported by PHPUnit.' ; }
384	protected function validateImage ( $ image ) { if ( false === ( $ imageInfo = getimagesize ( $ image -> tempName ) ) ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } list ( $ width , $ height ) = $ imageInfo ; if ( $ width == 0 || $ height == 0 ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } if ( $ this -> minWidth !== null && $ width < $ this -> minWidth ) { return [ $ this -> underWidth , [ 'file' => $ image -> name , 'limit' => $ this -> minWidth ] ] ; } if ( $ this -> minHeight !== null && $ height < $ this -> minHeight ) { return [ $ this -> underHeight , [ 'file' => $ image -> name , 'limit' => $ this -> minHeight ] ] ; } if ( $ this -> maxWidth !== null && $ width > $ this -> maxWidth ) { return [ $ this -> overWidth , [ 'file' => $ image -> name , 'limit' => $ this -> maxWidth ] ] ; } if ( $ this -> maxHeight !== null && $ height > $ this -> maxHeight ) { return [ $ this -> overHeight , [ 'file' => $ image -> name , 'limit' => $ this -> maxHeight ] ] ; } return null ; }
3131	public function persist ( QtiRunnerServiceContext $ context ) { $ testSession = $ context -> getTestSession ( ) ; $ sessionId = $ testSession -> getSessionId ( ) ; \ common_Logger :: d ( "Persisting QTI Assessment Test Session '${sessionId}'..." ) ; $ context -> getStorage ( ) -> persist ( $ testSession ) ; if ( $ this -> isTerminated ( $ context ) ) { $ userId = \ common_session_SessionManager :: getSession ( ) -> getUser ( ) -> getIdentifier ( ) ; $ eventManager = $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) ; $ eventManager -> trigger ( new AfterAssessmentTestSessionClosedEvent ( $ testSession , $ userId ) ) ; } }
9122	private function prepareRequest ( $ requestType ) : MemoryStream { $ ms = new MemoryStream ( ) ; $ ms -> interpolate ( "{rqtype} {path}{query} {proto}\r\n" , array ( 'rqtype' => $ requestType , 'path' => $ this -> path , 'proto' => $ this -> protocol , 'query' => ( strlen ( $ this -> queryString ) ? '?' . $ this -> queryString : '' ) ) ) ; $ ms -> interpolate ( "Host: {host}\r\n" , array ( 'host' => $ this -> getEndpoint ( ) -> getAddress ( ) ) ) ; $ this -> adjustHeaders ( $ requestType ) ; foreach ( $ this -> getHeaders ( ) as $ headerName => $ headerValue ) { if ( isset ( $ headerValue ) && strlen ( $ headerValue ) > 0 ) { $ ms -> interpolate ( "{headerName}: {headerValue}\r\n" , array ( 'headerName' => $ headerName , 'headerValue' => $ headerValue ) ) ; } } $ ms -> write ( "\r\n" ) ; return $ ms ; }
2467	private function setImpersonatedLogout ( ) { $ token = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ impersonatorUser = null ; foreach ( $ token -> getRoles ( ) as $ role ) { if ( $ role instanceof SwitchUserRole ) { $ impersonatorUser = $ role -> getSource ( ) -> getUsername ( ) ; break ; } } if ( ! $ impersonatorUser ) { return ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ firewallMap = System :: getContainer ( ) -> get ( 'security.firewall.map' ) ; if ( ( $ firewallConfig = $ firewallMap -> getFirewallConfig ( $ request ) ) === null || ( $ switchUserConfig = $ firewallConfig -> getSwitchUser ( ) ) === null ) { return ; } $ arrParams = array ( 'do' => 'user' , urlencode ( $ switchUserConfig [ 'parameter' ] ) => SwitchUserListener :: EXIT_VALUE ) ; $ this -> Template -> logout = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'switchBT' ] , $ impersonatorUser ) ; $ this -> Template -> logoutLink = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_backend' , $ arrParams ) ; }
3466	public function put ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: put ( $ route ) ) ; }
7430	public function addRegion ( RegionInterface $ region ) { $ region -> setCountry ( $ this ) ; $ this -> regions -> add ( $ region ) ; }
2081	public function purgeOptInTokens ( ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optIn -> purgeTokens ( ) ; $ this -> log ( 'Purged the expired double opt-in tokens' , __METHOD__ , TL_CRON ) ; }
10330	public function replace_when_add ( ) { $ state = isset ( $ _POST [ 'state' ] ) ? $ _POST [ 'state' ] : null ; $ nonce = isset ( $ _POST [ 'nonce' ] ) ? $ _POST [ 'nonce' ] : '' ; if ( ! wp_verify_nonce ( $ nonce , 'eliasis' ) && ! wp_verify_nonce ( $ nonce , 'customImagesGrifusAdmin' ) ) { die ( 'Busted!' ) ; } App :: setCurrentID ( 'EFG' ) ; $ slug = Module :: CustomImagesGrifus ( ) -> getOption ( 'slug' ) ; $ this -> model -> set_replace_when_add ( $ slug , $ state ) ; $ response = [ 'replace-when-add' => $ state ] ; echo json_encode ( $ response ) ; die ( ) ; }
6707	public function afterFind ( $ event ) { if ( is_array ( $ this -> fields ) ) { foreach ( $ this -> fields as $ field ) { if ( $ event -> sender -> { $ field } ) { $ event -> sender -> { $ field } = explode ( ';' , $ event -> sender -> { $ field } ) ; } } } }
6653	public function removeExtraData ( array $ extraDataKeys = [ ] ) { foreach ( $ extraDataKeys as $ key ) { if ( array_key_exists ( $ key , $ this -> extraData ) ) { unset ( $ this -> extraData [ $ key ] ) ; } } }
8288	protected function loadModules ( ) { foreach ( $ this -> config [ "authModules" ] as $ name ) { try { $ instance = $ this -> container -> get ( $ name ) ; } catch ( \ League \ Container \ Exception \ NotFoundException $ e ) { if ( ! class_exists ( $ name ) ) { throw new \ RuntimeException ( "PicoAuth module not found: " . $ name ) ; } $ instance = new $ name ; } if ( ! is_subclass_of ( $ instance , Module \ AbstractAuthModule :: class , false ) ) { throw new \ RuntimeException ( "PicoAuth module class must inherit from AbstractAuthModule." ) ; } $ name = $ instance -> getName ( ) ; $ this -> modules [ $ name ] = $ instance ; } }
11352	public function getErrors ( ) { $ errors = [ ] ; foreach ( $ this -> fields as $ field ) { if ( ! $ field -> isValid ( ) ) { $ errors [ ] = [ 'field' => $ field -> getLabel ( ) , 'message' => $ field -> getError ( ) ] ; } } return $ errors ; }
5136	public static function handleShutdown ( ) { if ( ! empty ( $ error = error_get_last ( ) ) ) { self :: handleException ( new FatalException ( $ error [ 'message' ] , $ error [ 'type' ] , 0 , $ error [ 'file' ] , $ error [ 'line' ] ) ) ; } }
7583	protected function extractInfo ( ) { $ this -> info = curl_getinfo ( $ this -> CurlRequest ) ; $ this -> status = $ this -> info [ 'http_code' ] ; if ( curl_errno ( $ this -> CurlRequest ) !== CURLE_OK ) { $ this -> error = curl_error ( $ this -> CurlRequest ) ; } else { $ this -> error = false ; } }
4657	public function run ( Job $ job , $ command ) { if ( is_string ( $ command ) ) { $ command = [ '/bin/bash' , '-c' , $ command ] ; } $ image = $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; $ hostConfig = new HostConfig ( ) ; $ config = new ContainerConfig ( ) ; $ config -> setCmd ( $ command ) ; $ config -> setImage ( $ image -> getId ( ) ) ; $ config -> setHostConfig ( $ hostConfig ) ; $ config -> setLabels ( new \ ArrayObject ( [ 'com.jolici.container=true' ] ) ) ; $ config -> setAttachStderr ( true ) ; $ config -> setAttachStdout ( true ) ; $ links = [ ] ; foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { $ serviceContainer = $ this -> docker -> getContainerManager ( ) -> find ( $ service -> getContainer ( ) ) ; $ links [ ] = sprintf ( '%s:%s' , $ serviceContainer -> getName ( ) , $ service -> getName ( ) ) ; } } $ hostConfig -> setLinks ( $ links ) ; $ containerCreateResult = $ this -> docker -> getContainerManager ( ) -> create ( $ config ) ; $ attachStream = $ this -> docker -> getContainerManager ( ) -> attach ( $ containerCreateResult -> getId ( ) , [ 'stream' => true , 'stdout' => true , 'stderr' => true , ] , ContainerManager :: FETCH_STREAM ) ; $ attachStream -> onStdout ( $ this -> logger -> getRunStdoutCallback ( ) ) ; $ attachStream -> onStderr ( $ this -> logger -> getRunStderrCallback ( ) ) ; $ this -> docker -> getContainerManager ( ) -> start ( $ containerCreateResult -> getId ( ) ) ; $ attachStream -> wait ( ) ; $ containerWait = $ this -> docker -> getContainerManager ( ) -> wait ( $ containerCreateResult -> getId ( ) ) ; return $ containerWait -> getStatusCode ( ) ; }
5424	public function expectException ( $ expected = false , $ message = '%s' ) { $ this -> expected = $ this -> forceToExpectation ( $ expected ) ; $ this -> message = $ message ; }
351	public static function getInputName ( $ model , $ attribute ) { $ formName = $ model -> formName ( ) ; if ( ! preg_match ( static :: $ attributeRegex , $ attribute , $ matches ) ) { throw new InvalidArgumentException ( 'Attribute name must contain word characters only.' ) ; } $ prefix = $ matches [ 1 ] ; $ attribute = $ matches [ 2 ] ; $ suffix = $ matches [ 3 ] ; if ( $ formName === '' && $ prefix === '' ) { return $ attribute . $ suffix ; } elseif ( $ formName !== '' ) { return $ formName . $ prefix . "[$attribute]" . $ suffix ; } throw new InvalidArgumentException ( get_class ( $ model ) . '::formName() cannot be empty for tabular inputs.' ) ; }
6973	private function buildFieldValue ( ClassMetadata $ metadata , $ propertyPath , $ value ) { $ type = $ metadata -> getTypeOfField ( $ propertyPath ) ; switch ( $ type ) { case 'smallint' : case 'integer' : case 'bigint' : if ( ! is_int ( $ value ) ) { throw new \ Exception ( 'Expected integer.' ) ; } return intval ( $ value ) ; case 'boolean' : if ( ! is_bool ( $ value ) ) { throw new \ Exception ( 'Expected boolean.' ) ; } return ( bool ) $ value ; case 'float' : case 'double' : case 'decimal' : if ( ! is_numeric ( $ value ) ) { throw new \ Exception ( 'Expected float.' ) ; } return floatval ( $ value ) ; case 'datetime' : return new \ DateTime ( $ value ) ; case 'string' : return ( string ) $ value ; } throw new \ Exception ( "Unsupported field type '$type' for path '$propertyPath'." ) ; }
12940	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a monitor consumer over aggregate connections.' ) ; } if ( $ client -> getCommandFactory ( ) -> supportsCommand ( 'MONITOR' ) === false ) { throw new NotSupportedException ( "'MONITOR' is not supported by the current command factory." ) ; } }
6206	public function onShutdown ( ) { if ( self :: $ instance == null ) { return ; } self :: $ instance = null ; if ( ! $ error = error_get_last ( ) ) { return ; } if ( ! $ this -> shouldNotifyError ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ) { return ; } $ backtrace = array ( array ( 'file' => $ error [ 'file' ] , 'line' => $ error [ 'line' ] , 'function' => '' , 'args' => array ( ) , ) ) ; $ this -> airbrakeClient -> notifyOnError ( '[Improper Shutdown] ' . $ error [ 'message' ] , $ backtrace ) ; }
11401	public function startAt ( $ startAt = 0 ) { if ( ! is_numeric ( $ startAt ) || $ startAt < 0 ) { throw new Exception ( "startAt: bad value" , 10 ) ; } $ this -> startAt = $ startAt ; return $ this ; }
2063	public function purgeSearchIndex ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ objResult = $ this -> Database -> prepare ( "SELECT id FROM tl_search WHERE pid=?" ) -> execute ( $ dc -> id ) ; while ( $ objResult -> next ( ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ this -> Database -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } }
768	protected function regenerateCsrfToken ( ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ request -> enableCsrfCookie || $ this -> enableSession ) { $ request -> getCsrfToken ( true ) ; } }
11441	public function setRegistry ( $ var = null , $ val = null , $ section = false ) { if ( is_null ( $ var ) ) { return ; } if ( $ section ) { if ( ! isset ( $ this -> registry [ $ section ] ) ) { $ this -> registry [ $ section ] = array ( ) ; } $ this -> registry [ $ section ] [ $ var ] = $ val ; } else { $ this -> registry [ $ var ] = $ val ; } return $ this ; }
7727	public function login ( $ text , $ url ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'type' => 'account_link' , 'url' => $ url ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
11733	public function publish ( $ pageName , $ languageName ) { $ this -> contributorDefined ( ) ; $ baseDir = $ this -> pagesDir . '/' . $ pageName ; $ pageCollectionSourceFile = $ baseDir . '/' . $ this -> username . '.json' ; $ pageCollectionTargetFile = $ baseDir . '/page.json' ; $ pageDir = $ baseDir . '/' . $ languageName ; $ pageSourceFile = $ pageDir . '/' . $ this -> username . '.json' ; $ pageTargetFile = $ pageDir . '/seo.json' ; Dispatcher :: dispatch ( PageEvents :: PAGE_PUBLISHING , new PagePublishingEvent ( ) ) ; copy ( $ pageCollectionSourceFile , $ pageCollectionTargetFile ) ; copy ( $ pageSourceFile , $ pageTargetFile ) ; Dispatcher :: dispatch ( PageEvents :: PAGE_PUBLISHED , new PagePublishedEvent ( ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" for language "%s" was published in production' , $ pageName , $ languageName ) ) ; }
8469	public function emergency ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'emergency' , $ scope , $ message , $ context , $ config ) ; }
277	public function notifyNothingToUnload ( $ foundFixtures , $ except ) { $ this -> stdout ( "Fixtures to unload could not be found according to given conditions:\n\n" , Console :: FG_RED ) ; $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n" , Console :: FG_GREEN ) ; if ( count ( $ foundFixtures ) ) { $ this -> stdout ( "\nFixtures found under the namespace:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ foundFixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be unloaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } }
2657	public function createResponse ( $ version , array $ response ) { $ checkIfExists = $ this -> getResponse ( $ version , $ response [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/response_object' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ response [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ response ) ; return $ result ; }
3857	protected function prepareView ( ) { if ( $ this -> renderSettingFactory ) { $ this -> objView = $ this -> renderSettingFactory -> createCollection ( $ this -> objMetaModel , $ this -> intView ) ; } else { $ this -> objView = $ this -> objMetaModel -> getView ( $ this -> intView ) ; } if ( $ this -> objView ) { $ this -> objTemplate = new Template ( $ this -> objView -> get ( 'template' ) ) ; $ this -> objTemplate -> view = $ this -> objView ; } else { $ this -> objTemplate = new Template ( 'metamodel_full' ) ; } }
7421	protected function initializeProductMediaGalleryValueToEntity ( array $ attr ) { $ rowId = $ attr [ MemberNames :: ROW_ID ] ; $ valueId = $ attr [ MemberNames :: VALUE_ID ] ; if ( $ this -> loadProductMediaGalleryValueToEntityByValueIdAndRowId ( $ valueId , $ rowId ) ) { return ; } return $ attr ; }
3495	public function add ( HttpProtocolVisitorInterface $ visitor , int $ priority = 0 ) : void { $ this -> visitors -> insert ( $ visitor , $ priority ) ; }
924	public function getInvalidErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_INVALID === $ error -> getType ( ) ; } ) ; }
8140	public function createTemplate ( $ template ) { $ name = sprintf ( '__string_template__%s' , hash ( 'sha256' , $ template , false ) ) ; $ loader = new Twig_Loader_Chain ( array ( new Twig_Loader_Array ( array ( $ name => $ template ) ) , $ current = $ this -> getLoader ( ) , ) ) ; $ this -> setLoader ( $ loader ) ; try { $ template = $ this -> loadTemplate ( $ name ) ; } catch ( Exception $ e ) { $ this -> setLoader ( $ current ) ; throw $ e ; } catch ( Throwable $ e ) { $ this -> setLoader ( $ current ) ; throw $ e ; } $ this -> setLoader ( $ current ) ; return $ template ; }
132	public function disablePlugins ( ) { foreach ( $ this -> installers as $ i => $ installer ) { if ( ! $ installer instanceof PluginInstaller ) { continue ; } unset ( $ this -> installers [ $ i ] ) ; } }
8704	public function apply ( EloquentBuilder $ builder , Eloquent $ model ) { $ this -> table = $ model -> getTable ( ) ; $ this -> locale = $ model -> getLocale ( ) ; $ this -> i18nTable = $ model -> getI18nTable ( ) ; $ this -> fallback = $ model -> getFallbackLocale ( ) ; if ( ! starts_with ( $ this -> table , 'laravel_reserved_' ) ) { $ this -> createJoin ( $ builder , $ model ) ; $ this -> createWhere ( $ builder , $ model ) ; $ this -> createSelect ( $ builder , $ model ) ; } }
5928	public function createCategory ( Category $ category ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'category' => $ category ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/categories' , $ parameters ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
12345	public function editAction ( Request $ request , Post $ post ) { if ( is_object ( $ post -> getPublished ( ) ) && $ post -> getPublished ( ) -> format ( 'dmY' ) == '3011-0001' ) { $ post -> setPublished ( null ) ; } $ deleteForm = $ this -> createDeleteForm ( $ post ) ; $ editForm = $ this -> createForm ( 'BlogBundle\Form\PostType' , $ post , array ( 'translator' => $ this -> get ( 'translator' ) ) ) ; $ editForm -> handleRequest ( $ request ) ; if ( $ editForm -> isSubmitted ( ) && $ editForm -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ post ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'post.edited' ) ; return $ this -> redirectToRoute ( 'blog_post_index' ) ; } return array ( 'entity' => $ post , 'edit_form' => $ editForm -> createView ( ) , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
8568	public function setCategoryQueryList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'CategoryQueryList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
608	private function addTokenFromBuffer ( ) { if ( $ this -> _buffer === '' ) { return ; } $ isKeyword = $ this -> isKeyword ( $ this -> _buffer , $ content ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => $ isKeyword ? SqlToken :: TYPE_KEYWORD : SqlToken :: TYPE_TOKEN , 'content' => is_string ( $ content ) ? $ content : $ this -> _buffer , 'startOffset' => $ this -> offset - mb_strlen ( $ this -> _buffer , 'UTF-8' ) , 'endOffset' => $ this -> offset , ] ) ; $ this -> _buffer = '' ; }
10852	public function echo ( $ type , $ content ) { if ( $ this -> option ( 'debug' ) == false ) { return ; } if ( trim ( $ content ) ) { $ this -> { $ type } ( $ content ) ; } }
3041	public function persist ( $ userId = null , $ callId = null ) { if ( $ userId && $ callId ) { $ keys = [ $ this -> getCacheKey ( $ userId , $ callId ) ] ; } else { $ keys = array_keys ( $ this -> cache ) ; } $ success = true ; foreach ( $ keys as $ key ) { if ( ! $ this -> persistCacheEntry ( $ key ) ) { $ success = false ; } } return $ success ; }
8403	public static function loadClass ( string $ className ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'bootstrap doesn\'t seem to have been initialized' ) ; } $ fileName = null ; if ( ( $ namespacePos = strripos ( $ className , '\\' ) ) !== false ) { $ namespacePos = ( int ) $ namespacePos ; $ namespace = substr ( $ className , 0 , $ namespacePos ) ; $ subNamespaces = array ( ) ; while ( $ fileName === null && $ namespace != null ) { if ( isset ( self :: $ namespaces [ $ namespace ] ) === false ) { $ subNamespacePos = strripos ( $ namespace , '\\' ) ; $ subNamespacePos = ( int ) $ subNamespacePos ; $ subNamespaces [ ] = substr ( $ namespace , $ subNamespacePos ) ; $ namespace = substr ( $ namespace , 0 , $ subNamespacePos ) ; } else { $ fileName = self :: $ namespaces [ $ namespace ] ; } } if ( $ fileName === null ) { throw new UnknownNamespace ( 'can\'t find namespace "' . substr ( $ className , 0 , $ namespacePos ) . '"' ) ; } $ fileName = self :: $ namespaces [ $ namespace ] . str_replace ( '\\' , DIRECTORY_SEPARATOR , implode ( '' , array_reverse ( $ subNamespaces ) ) ) ; $ className = substr ( $ className , $ namespacePos + 1 ) ; } if ( $ fileName != null ) { $ fileName .= DIRECTORY_SEPARATOR . str_replace ( '_' , DIRECTORY_SEPARATOR , $ className ) . '.php' ; require $ fileName ; } }
7316	public function setTimezone ( $ timezone ) { if ( is_string ( $ timezone ) ) { $ timezone = TimeZone :: parse ( $ timezone ) ; } else { if ( $ timezone instanceof TimeZone == false ) { throw new \ InvalidArgumentException ( ) ; } } $ jd = $ this -> toJD ( ) ; $ tzOffset = $ timezone -> offset ( $ jd ) - $ this -> timezone -> offset ( $ jd ) ; $ this -> add ( Time :: hours ( $ tzOffset ) ) ; $ this -> timezone = $ timezone ; $ this -> timezone0 = $ timezone ; return $ this ; }
10160	private function readMsoDrawing ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingData .= $ recordData ; }
5250	public function save ( $ columns = [ '*' ] ) { $ columns = $ columns ? ( array ) $ columns : [ '*' ] ; if ( $ this -> saving ( ) === false ) { return false ; } $ this -> fillTimestamp ( ) ; $ this -> _dal -> put ( $ columns ) ; $ this -> _exist = true ; if ( $ this -> saved ( ) === false ) { return false ; } return true ; }
2487	protected function search ( array $ parameters ) { $ queryString = $ this -> generateQueryString ( $ parameters ) ; $ response = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getEntryEndpoint ( ) ) , '/select' , new Message ( [ 'Content-Type' => 'application/x-www-form-urlencoded' , ] , $ queryString ) ) ; $ result = json_decode ( $ response -> body ) ; if ( ! isset ( $ result -> response ) ) { throw new RuntimeException ( '->response not set: ' . var_export ( array ( $ result , $ parameters ) , true ) ) ; } return $ result ; }
4858	public function getList ( $ namespace , $ callback ) { $ session = new Container ( $ namespace ) ; $ params = $ session -> params ? : array ( ) ; if ( ! $ session -> list ) { $ session -> list = is_array ( $ callback ) ? call_user_func ( $ callback , $ session -> params ) : $ callback -> getPaginationList ( $ session -> params ) ; } return $ session -> list ; }
5605	public function paintMethodEnd ( $ method ) { if ( $ this -> fail || $ this -> error || ! $ this -> pass ) { } else { $ this -> listener -> write ( '{status:"pass",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
12714	protected function resolveMethodParameters ( $ params = [ ] ) { if ( ! is_array ( $ params ) ) { throw new \ InvalidArgumentException ( sprintf ( "Parameter 1 of %s must be an array." , __METHOD__ ) ) ; } foreach ( $ params as $ key => $ value ) { if ( $ value instanceof \ ReflectionParameter ) { $ class = $ value -> getClass ( ) ; if ( $ class instanceof \ ReflectionClass ) { if ( $ class -> isInterface ( ) ) { $ params [ $ key ] = $ this -> getConcreteFromInterface ( $ class -> getName ( ) ) ; } else { $ params [ $ key ] = $ this -> circularDependencyResolver ( $ class -> getName ( ) ) ; } } else { $ params [ $ key ] = ( $ value -> isDefaultValueAvailable ( ) ? $ value -> getDefaultValue ( ) : null ) ; } } else { if ( is_string ( $ value ) && class_exists ( $ value ) ) { $ params [ $ key ] = $ this -> circularDependencyResolver ( $ value ) ; } elseif ( $ value instanceof \ Closure ) { $ params [ $ key ] = $ value ( $ this ) ; } else { $ params [ $ key ] = $ value ; } } } return $ params ; }
3972	public function decodeAttributeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ attribute = $ metaModel -> getAttributeById ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ) ; } }
12521	public function renderLabel ( $ customFieldOrClass , $ slug = null , array $ params = array ( ) ) { $ resolvedParams = array_merge ( $ this -> defaultParams , $ params ) ; $ customField = ( $ customFieldOrClass instanceof CustomField ) ? $ customFieldOrClass : $ this -> container -> get ( 'chill.custom_field.provider' ) -> getCustomField ( $ customFieldOrClass , $ slug ) ; return $ this -> container -> get ( 'templating' ) -> render ( $ resolvedParams [ 'label_layout' ] , array ( 'customField' => $ customField ) ) ; }
3859	public function addFilterRule ( $ objFilterRule ) { if ( ! $ this -> objFilter ) { $ this -> objFilter = $ this -> objMetaModel -> getEmptyFilter ( ) ; } $ this -> objFilter -> addFilterRule ( $ objFilterRule ) ; return $ this ; }
12009	public function setTitle ( string $ title ) : void { $ this -> title = $ this -> translator !== null ? $ this -> translator -> translate ( $ title ) : $ title ; }
12905	public function index ( FilterRequest $ request ) { $ limit = $ request -> request -> get ( 'limit' , 15 ) ; $ limit = ( $ limit > 49 ) ? 50 : $ limit ; $ filter = $ this -> repository -> filter ( $ request ) ; if ( $ this -> list || $ request -> request -> get ( 'search_type' ) == 'list' ) { $ resources = $ filter -> get ( 1000 ) ; } else { $ resources = $ filter -> paginate ( $ limit ) ; } if ( $ resources -> count ( ) < 1 ) { } return $ this -> success ( $ resources ) ; }
7311	public static function solsticeWinter ( $ year ) { $ jd = static :: solsticeDecember ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
983	public function process ( Plan $ plan ) { $ shop = ShopifyApp :: shop ( ) ; $ bp = new BillingPlan ( $ shop , $ plan ) ; $ bp -> setChargeId ( Request :: query ( 'charge_id' ) ) ; $ bp -> activate ( ) ; $ bp -> save ( ) ; $ shop -> update ( [ 'freemium' => false , 'plan_id' => $ plan -> id , ] ) ; return Redirect :: route ( 'home' ) -> with ( 'success' , 'billing' ) ; }
9234	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; if ( Yii :: $ app -> request -> post ( ) ) { $ post = Yii :: $ app -> request -> post ( ) ; $ category = [ ] ; if ( isset ( $ post [ 'Post' ] [ 'category' ] ) ) { $ category = $ post [ 'Post' ] [ 'category' ] ; } if ( is_array ( $ post [ 'Post' ] [ 'tags' ] ) ) { $ post [ 'Post' ] [ 'tags' ] = implode ( "," , $ post [ 'Post' ] [ 'tags' ] ) ; } $ model -> load ( $ post ) ; $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> save ( ) ) { $ cs = BlogCatPos :: deleteAll ( "post_id = :id" , [ "id" => $ model -> id ] ) ; foreach ( $ category as $ d ) { $ c = new BlogCatPos ( ) ; $ c -> post_id = $ model -> id ; $ c -> category_id = $ d ; $ c -> isdel = 0 ; $ c -> save ( ) ; } $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } } return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; }
1949	public function showRelatedRecords ( $ data , $ row ) { Contao \ System :: loadLanguageFile ( 'tl_opt_in_related' ) ; Contao \ Controller :: loadDataContainer ( 'tl_opt_in_related' ) ; $ objRelated = $ this -> Database -> prepare ( "SELECT * FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ row [ 'id' ] ) ; while ( $ objRelated -> next ( ) ) { $ arrAdd = array ( ) ; $ arrRow = $ objRelated -> row ( ) ; foreach ( $ arrRow as $ k => $ v ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] ; $ arrAdd [ $ label ] = $ v ; } $ data [ 'tl_opt_in_related' ] [ ] = $ arrAdd ; } return $ data ; }
5570	public function retry ( ) { $ frames = $ this -> page -> getFrameFocus ( ) ; if ( count ( $ frames ) > 0 ) { $ this -> loadFrame ( $ frames , $ this -> page -> getUrl ( ) , $ this -> page -> getRequestData ( ) ) ; return $ this -> page -> getRaw ( ) ; } if ( $ url = $ this -> history -> getUrl ( ) ) { $ this -> page = $ this -> fetch ( $ url , $ this -> history -> getParameters ( ) ) ; return $ this -> page -> getRaw ( ) ; } return false ; }
7265	public static function select ( $ queryString = "" , array $ queryParams = [ ] ) { $ tableName = static :: tableName ( ) ; $ rows = Db :: query ( " select $tableName.* from $tableName $queryString " , $ queryParams , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return new Collection ( [ ] ) ; $ collection = [ ] ; foreach ( $ rows as $ row ) { $ model = new static ; foreach ( $ row as $ column => $ val ) $ model -> $ column = $ model -> decodeValue ( $ val , $ column ) ; $ collection [ ] = $ model ; } return new Collection ( $ collection ) ; }
10935	public function checkEmailAction ( ) { $ session = $ this -> get ( 'session' ) ; $ email = $ session -> get ( static :: SESSION_EMAIL ) ; $ session -> remove ( static :: SESSION_EMAIL ) ; if ( empty ( $ email ) ) { return new RedirectResponse ( $ this -> get ( 'router' ) -> generate ( 'miky_app_customer_resetting_request' ) ) ; } return $ this -> render ( 'MikyUserBundle:Frontend/Resetting:checkEmail.html.twig' , array ( 'email' => $ email , ) ) ; }
3205	protected function get_docblock_tags ( $ comment_opener ) { $ tags = array ( ) ; $ opener = $ this -> tokens [ $ comment_opener ] ; if ( ! isset ( $ opener [ 'comment_tags' ] ) ) { return $ tags ; } $ closer = null ; if ( isset ( $ opener [ 'comment_closer' ] ) ) { $ closer = $ opener [ 'comment_closer' ] ; } $ tag_count = count ( $ opener [ 'comment_tags' ] ) ; for ( $ i = 0 ; $ i < $ tag_count ; $ i ++ ) { $ tag_token = $ opener [ 'comment_tags' ] [ $ i ] ; $ tag = trim ( $ this -> tokens [ $ tag_token ] [ 'content' ] , '@' ) ; $ search_end = $ closer ; if ( ( $ i + 1 ) < $ tag_count ) { $ search_end = $ opener [ 'comment_tags' ] [ ( $ i + 1 ) ] ; } $ value_token = $ this -> phpcsFile -> findNext ( T_DOC_COMMENT_STRING , ( $ tag_token + 1 ) , $ search_end ) ; $ tags [ $ tag ] = trim ( $ this -> tokens [ $ value_token ] [ 'content' ] ) ; unset ( $ tag_token , $ tag , $ search_end , $ value ) ; } return $ tags ; }
3049	protected function initCompilationDirectory ( ) { $ fileStorage = \ tao_models_classes_service_FileStorage :: singleton ( ) ; $ directoryIds = explode ( '|' , $ this -> getTestCompilationUri ( ) ) ; $ directories = array ( 'private' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 0 ] ) , 'public' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 1 ] ) ) ; $ this -> compilationDirectory = $ directories ; }
1225	private function buildQueryParameters ( array $ paramValues ) { if ( empty ( $ paramValues ) ) { return '' ; } $ query = [ ] ; foreach ( $ paramValues as $ param => $ value ) { if ( is_array ( $ value ) ) { $ value = join ( ',' , $ value ) ; } elseif ( is_bool ( $ value ) ) { $ value = $ value ? 'true' : 'false' ; } elseif ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } $ query [ ] = $ param . '=' . urlencode ( $ value ) ; } return '?' . join ( '&' , $ query ) ; }
3189	public function getLastTimestamp ( $ tags ) { $ range = $ this -> getRange ( $ tags ) ; $ length = count ( $ range ) ; $ last = false ; if ( $ length ) { $ last = $ range [ $ length - 1 ] -> getTimestamp ( ) ; } return $ last ; }
3768	private function resolvePath ( $ value ) { $ path = Path :: canonicalize ( $ value ) ; if ( '\\' === DIRECTORY_SEPARATOR ) { $ path = str_replace ( '/' , '\\' , $ path ) ; } return $ path ; }
2583	protected function prepareForNextMessage ( $ messageName , $ messageOptions ) { if ( ! $ this -> isAuthenticated && $ messageName !== 'Security_Authenticate' ) { throw new InvalidSessionException ( 'No active session' ) ; } $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( null ) ; if ( $ this -> isAuthenticated === true && is_int ( $ this -> sessionData [ 'sequenceNumber' ] ) ) { $ this -> sessionData [ 'sequenceNumber' ] ++ ; $ session = new Client \ Struct \ HeaderV2 \ Session ( $ this -> sessionData [ 'sessionId' ] , $ this -> sessionData [ 'sequenceNumber' ] , $ this -> sessionData [ 'securityToken' ] ) ; $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( new \ SoapHeader ( self :: CORE_WS_V2_SESSION_NS , self :: NODENAME_SESSION , $ session ) ) ; } }
724	public function getUniqueId ( ) { return $ this -> module instanceof Application ? $ this -> id : $ this -> module -> getUniqueId ( ) . '/' . $ this -> id ; }
7038	public function getShipments ( $ filter = null ) { if ( null === $ filter ) { return $ this -> shipments ; } return $ this -> shipments -> filter ( function ( ShipmentInterface $ shipment ) use ( $ filter ) { return $ filter xor $ shipment -> isReturn ( ) ; } ) ; }
8084	public function clearErrors ( $ channelName = '' ) { $ channel = $ this -> namespaceChannel ( $ channelName ) ; $ this -> console [ 'errors' ] [ $ channel ] = array ( ) ; $ this -> console [ 'form' ] [ $ channel ] = array ( ) ; }
11784	public function update ( $ pageId , $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'page_id' => intval ( $ pageId ) , 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
3475	public function getGateway ( ) { $ gateway = $ this -> gateway ; try { $ response = $ this -> guzzle -> get ( 'https://discordapp.com/api/gateway' , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , ] ) ; $ gateway = Arr :: get ( json_decode ( $ response -> getBody ( ) , true ) , 'url' , $ gateway ) ; } catch ( Exception $ e ) { $ this -> warn ( "Could not get a websocket gateway address, defaulting to '{$gateway}'." ) ; } return $ gateway ; }
6574	private function isSessionValid ( SessionDataHolder $ session , ServerRequestInterface $ request ) : bool { if ( ( $ lastReq = $ session -> getLastRequestTime ( ) ) && ( $ lastReq + $ this -> getExpire ( ) * 60 ) < time ( ) ) { return false ; } if ( $ this -> getValidateClientIp ( ) && ( $ clientIp = $ session -> getClientIp ( ) ) && isset ( $ request -> getServerParams ( ) [ 'REMOTE_ADDR' ] ) && $ clientIp != $ request -> getServerParams ( ) [ 'REMOTE_ADDR' ] ) { return false ; } return true ; }
11323	protected function getAnnotationMethodForMethod ( ClassInterface $ class , $ requestMethod ) { foreach ( $ class -> getMethods ( ) as $ method ) { if ( $ method -> getAnnotatedName ( ) === $ requestMethod ) { return $ method ; } } throw new ExtDirectException ( "extjs method name '{$requestMethod}' does not exist'" ) ; }
4533	public function getList ( $ task , Parameters $ parameters = null ) { $ resource = str_replace ( '{id}' , $ task , static :: VARIABLE_LIST ) ; $ options = [ 'headers' => [ 'Accept' => 'application/json' ] , 'query' => ( array ) $ parameters -> toObject ( true ) ] ; $ objects = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ list = [ ] ; foreach ( $ objects as $ name => $ object ) { $ object -> name = $ name ; $ model = static :: toModel ( $ object ) ; $ list [ $ name ] = $ model ; } return $ list ; }
7156	private function setSubjectData ( StockSubjectInterface $ subject , $ inStock = .0 , $ availableStock = .0 , $ virtualStock = .0 , \ DateTime $ eda = null ) { $ changed = false ; if ( $ inStock != $ subject -> getInStock ( ) ) { $ subject -> setInStock ( $ inStock ) ; $ changed = true ; } if ( $ availableStock != $ subject -> getAvailableStock ( ) ) { $ subject -> setAvailableStock ( $ availableStock ) ; $ changed = true ; } if ( $ virtualStock != $ subject -> getVirtualStock ( ) ) { $ subject -> setVirtualStock ( $ virtualStock ) ; $ changed = true ; } if ( $ eda !== $ subject -> getEstimatedDateOfArrival ( ) ) { $ subject -> setEstimatedDateOfArrival ( $ eda ) ; $ changed = true ; } return $ changed ; }
12599	public function get ( $ key , $ default = null ) { return array_key_exists ( $ key , $ this -> configs ) ? $ this -> configs [ $ key ] : $ default ; }
2700	private function upgrade1010 ( $ newConfigPaths ) { $ oldData = $ this -> scopeConfig -> getValue ( $ newConfigPaths [ 'geoip_country_mapping' ] ) ; try { $ oldData = unserialize ( $ oldData ) ; } catch ( \ Exception $ e ) { $ oldData = [ ] ; } $ oldData = ( is_array ( $ oldData ) ) ? $ oldData : [ ] ; $ newData = json_encode ( $ oldData ) ; if ( false === $ newData ) { throw new \ InvalidArgumentException ( 'Unable to encode data.' ) ; } $ this -> configWriter -> save ( $ newConfigPaths [ 'geoip_country_mapping' ] , $ newData ) ; $ this -> cacheManager -> clean ( [ \ Magento \ Framework \ App \ Cache \ Type \ Config :: TYPE_IDENTIFIER ] ) ; }
1066	private function doTypesConflict ( OutputType $ type1 , OutputType $ type2 ) { if ( $ type1 instanceof ListOfType ) { return $ type2 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof ListOfType ) { return $ type1 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type1 instanceof NonNull ) { return $ type2 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof NonNull ) { return $ type1 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( Type :: isLeafType ( $ type1 ) || Type :: isLeafType ( $ type2 ) ) { return $ type1 !== $ type2 ; } return false ; }
7799	protected function getLine ( $ id , $ text , $ offset = 0 , & $ position = null , & $ length = null ) { $ pcre = '/(?:^|\r?\n)\:(' . $ id . ')\:' . '(.+)' . '(:?$|\r?\n\:[[:alnum:]]{2,3}\:)' . '/Us' ; if ( preg_match ( $ pcre , substr ( $ text , $ offset ) , $ match , PREG_OFFSET_CAPTURE ) ) { $ position = $ offset + $ match [ 1 ] [ 1 ] - 1 ; $ length = strlen ( $ match [ 2 ] [ 0 ] ) ; return rtrim ( $ match [ 2 ] [ 0 ] ) ; } return '' ; }
11610	public function connect ( ClientInterface $ client ) { $ attributes = $ client -> getUserAttributes ( ) ; $ provider = $ client -> getId ( ) ; $ clientId = $ attributes [ 'id' ] ; $ account = $ this -> finder -> findAccountByProviderAndClientId ( $ provider , $ clientId ) ; if ( $ account === null ) { $ account = \ Yii :: createObject ( [ 'class' => Account :: className ( ) , 'provider' => $ provider , 'client_id' => $ clientId , 'data' => json_encode ( $ attributes ) , 'user_id' => \ Yii :: $ app -> user -> id , ] ) ; $ account -> save ( false ) ; \ Yii :: $ app -> session -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Your account has been connected' ) ) ; } else if ( null == $ account -> user ) { $ account -> user_id = \ Yii :: $ app -> user -> id ; $ account -> save ( false ) ; } else { \ Yii :: $ app -> session -> setFlash ( 'error' , \ Yii :: t ( 'user' , 'This account has already been connected to another user' ) ) ; } $ this -> action -> successUrl = Url :: to ( [ '/user/settings/networks' ] ) ; }
8102	public function getStatement ( $ sql , $ args = false ) { $ query = $ this -> buildQuery ( $ sql , $ args ) ; if ( $ connection = $ this -> db -> getConnection ( ) ) { if ( $ stmt = $ connection -> prepare ( $ query ) ) { $ this -> log -> report ( "SQL Statement: {$query}" ) ; $ stmt -> setFetchMode ( \ PDO :: FETCH_INTO , new Collection ( ) ) ; if ( $ args ) { $ this -> log -> report ( "SQL Data Sent: [" . implode ( ', ' , $ args ) . "]" ) ; $ stmt -> execute ( $ args ) ; } if ( $ stmt -> errorCode ( ) > 0 ) { $ error = $ stmt -> errorInfo ( ) ; $ this -> log -> error ( "PDO({$error[0]})[{$error[1]}] {$error[2]}" ) ; return false ; } return $ stmt ; } else { $ this -> log -> error ( 'Failed to create a PDO statement with: ' . $ query ) ; return false ; } } else { return false ; } }
4535	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Tenantable ) { return ; } if ( null !== $ entity -> getTenant ( ) ) { return ; } $ tenant = $ this -> container -> get ( TenantService :: class ) -> getContext ( ) ; $ entity -> setTenant ( $ tenant ) ; }
850	public function getTokenOfKindSibling ( $ index , $ direction , array $ tokens = [ ] , $ caseSensitive = true ) { if ( ! self :: isLegacyMode ( ) ) { $ tokens = array_filter ( $ tokens , function ( $ token ) { return $ this -> isTokenKindFound ( $ this -> extractTokenKind ( $ token ) ) ; } ) ; } if ( ! \ count ( $ tokens ) ) { return null ; } while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( $ token -> equalsAny ( $ tokens , $ caseSensitive ) ) { return $ index ; } } }
3074	public function getRubrics ( RunnerServiceContext $ context , AssessmentItemRef $ itemRef = null ) { $ session = $ context -> getTestSession ( ) ; $ routeItem = null ; if ( ! is_null ( $ itemRef ) ) { try { $ routeItem = $ session -> getRoute ( ) -> getRouteItemsByAssessmentItemRef ( $ itemRef ) ; if ( $ routeItem ) { $ routeItem = $ routeItem [ 0 ] ; } } catch ( OutOfBoundsException $ obe ) { \ common_Logger :: d ( "Could not retrieve the route for item '${itemRef}'." ) ; } } else { $ routeItem = $ session -> getRoute ( ) -> current ( ) ; } return implode ( '' , $ this -> getRubricBlock ( $ routeItem , $ session , $ context -> getCompilationDirectory ( ) ) ) ; }
2623	public function daysFromInstallation ( ) { $ stat = $ this -> statisticRepository -> getStatByAction ( self :: FASTLY_INSTALLED_FLAG ) ; if ( ! $ stat -> getCreatedAt ( ) ) { return null ; } $ installDate = date_create ( $ stat -> getCreatedAt ( ) ) ; $ currentDate = date_create ( $ this -> dateTime -> gmtDate ( ) ) ; $ dateDiff = date_diff ( $ installDate , $ currentDate ) ; return $ dateDiff -> days ; }
2164	public static function convertSingleField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field!=''" ) ; $ objDesc = $ objDatabase -> query ( "DESC $table $field" ) ; if ( $ objDesc -> Type != 'binary(16)' ) { $ objDatabase -> query ( "ALTER TABLE `$table` CHANGE `$field` `$field` binary(16) NULL" ) ; $ objDatabase -> query ( "UPDATE `$table` SET `$field`=NULL WHERE `$field`='' OR `$field`=0" ) ; } while ( $ objRow -> next ( ) ) { $ objHelper = static :: generateHelperObject ( $ objRow -> $ field ) ; if ( $ objHelper -> isUuid ) { continue ; } if ( $ objHelper -> isNumeric ) { $ objFile = FilesModel :: findByPk ( $ objHelper -> value ) ; $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( $ objFile -> uuid , $ objRow -> id ) ; } else { $ objFile = FilesModel :: findByPath ( $ objHelper -> value ) ; $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( $ objFile -> uuid , $ objRow -> id ) ; } } }
3680	private function injectChildTables ( & $ localMenu ) { $ parented = $ this -> viewCombination -> getParented ( ) ; $ lastCount = count ( $ parented ) ; while ( $ parented ) { foreach ( $ parented as $ metaModelName => $ child ) { foreach ( $ localMenu as $ groupName => $ modules ) { foreach ( $ modules as $ moduleName => $ module ) { if ( isset ( $ module [ 'tables' ] ) && in_array ( $ child [ 'meta' ] [ 'ptable' ] , $ module [ 'tables' ] ) ) { $ localMenu [ $ groupName ] [ $ moduleName ] [ 'tables' ] [ ] = $ metaModelName ; unset ( $ parented [ $ metaModelName ] ) ; break ; } } } } if ( count ( $ parented ) == $ lastCount ) { break ; } $ lastCount = count ( $ parented ) ; } }
7580	protected function verifyUrl ( ) { $ UrlArray = explode ( "?" , $ this -> Url ) ; if ( strpos ( $ UrlArray [ 0 ] , "$" ) !== false ) { throw new InvalidURLException ( get_called_class ( ) , "Configured URL is " . $ this -> Url ) ; } return true ; }
1964	public static function decodeUrl ( $ strUrl ) { if ( $ strUrl == '' ) { return '' ; } if ( $ strUrl == '#' || strncmp ( $ strUrl , '{{' , 2 ) === 0 ) { return $ strUrl ; } if ( strncmp ( $ strUrl , 'mailto:' , 7 ) === 0 ) { return static :: decodeEmail ( $ strUrl ) ; } $ arrUrl = parse_url ( $ strUrl ) ; if ( ! isset ( $ arrUrl [ 'scheme' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Expected a FQDN, got "%s"' , $ strUrl ) ) ; } if ( isset ( $ arrUrl [ 'scheme' ] ) ) { $ arrUrl [ 'scheme' ] .= ( ( substr ( $ strUrl , \ strlen ( $ arrUrl [ 'scheme' ] ) , 3 ) == '://' ) ? '://' : ':' ) ; } if ( isset ( $ arrUrl [ 'user' ] ) ) { $ arrUrl [ 'user' ] .= isset ( $ arrUrl [ 'pass' ] ) ? ':' : '@' ; } if ( isset ( $ arrUrl [ 'pass' ] ) ) { $ arrUrl [ 'pass' ] .= '@' ; } if ( isset ( $ arrUrl [ 'host' ] ) ) { $ arrUrl [ 'host' ] = static :: decode ( $ arrUrl [ 'host' ] ) ; } if ( isset ( $ arrUrl [ 'port' ] ) ) { $ arrUrl [ 'port' ] = ':' . $ arrUrl [ 'port' ] ; } if ( isset ( $ arrUrl [ 'query' ] ) ) { $ arrUrl [ 'query' ] = '?' . $ arrUrl [ 'query' ] ; } if ( isset ( $ arrUrl [ 'fragment' ] ) ) { $ arrUrl [ 'fragment' ] = '#' . $ arrUrl [ 'fragment' ] ; } $ strReturn = '' ; foreach ( array ( 'scheme' , 'user' , 'pass' , 'host' , 'port' , 'path' , 'query' , 'fragment' ) as $ key ) { if ( isset ( $ arrUrl [ $ key ] ) ) { $ strReturn .= $ arrUrl [ $ key ] ; } } return $ strReturn ; }
911	public function addBlank ( ) { $ matched = Preg :: match ( '/^([ \t]*\*)[^\r\n]*(\r?\n)$/' , $ this -> content , $ matches ) ; if ( 1 !== $ matched ) { return ; } $ this -> content .= $ matches [ 1 ] . $ matches [ 2 ] ; }
7569	public function getJobApiService ( ) { $ apiService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ JobApiService ( $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: jobBoardBaseUrl ( $ this -> _boardToken ) ) ) ; $ apiService -> setClient ( $ apiClient ) ; return $ apiService ; }
11372	protected function onClassFound ( ScannedPhpClass $ subject ) { $ class = $ subject -> getClass ( ) ; $ main = $ this -> reader -> getClassAnnotation ( $ class , Di \ DiServiceAnnotation :: class ) ; if ( $ main instanceof Di \ DiServiceAnnotation ) { $ definition = $ this -> provideServiceDefinitionFor ( new ServiceDefinitionProvider \ Frame ( $ class , $ main , DiOptionsCollection :: from ( $ this -> reader , $ class ) , null ) ) ; $ this -> addServiceDefinition ( $ definition ) ; } }
4526	protected function createZoneMemberZoneFromDefinition ( array $ definition ) { $ zone = $ this -> get ( $ definition [ 'zone' ] ) ; $ zoneMember = new ZoneMemberZone ( ) ; $ zoneMember -> setZone ( $ zone ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; } , $ zoneMember , '\CommerceGuys\Zone\Model\ZoneMemberZone' ) ; $ setValues ( $ definition ) ; return $ zoneMember ; }
4037	private function getTemplatesForBaseFrom ( $ base , $ folder , $ themeName ) { if ( ! is_dir ( $ folder ) ) { return [ ] ; } $ themeName = trim ( $ themeName ) ; $ foundTemplates = Finder :: create ( ) -> in ( $ folder ) -> name ( $ base . '*' ) ; $ templates = [ ] ; foreach ( $ foundTemplates as $ template ) { $ templates [ $ template -> getBasename ( '.' . $ template -> getExtension ( ) ) ] = [ $ themeName => $ themeName ] ; } return $ templates ; }
12816	private static function getColumns ( string $ table ) : array { if ( self :: $ columnsCache !== null && array_key_exists ( $ table , self :: $ columnsCache ) ) return self :: $ columnsCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT * FROM information_schema.columns WHERE table_name = '$table' " ; self :: $ columnsCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ columnsCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ columnsCache [ $ table ] ; }
8621	public function compile ( ) { $ compiled_blocks = [ ] ; foreach ( $ this -> blocks as $ key => $ block ) $ compiled_blocks [ ] = $ block -> compile ( ) ; return implode ( "\n\n" , $ compiled_blocks ) . "\n" ; }
6099	protected function put ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_PUT , null , $ fireAndForget ) ; }
1879	public function protect ( ) { @ trigger_error ( 'Using DC_Folder::protect() has been deprecated and will no longer work in Contao 5.0. Use Contao\Folder::protect() and Contao\Folder::unprotect() instead.' , E_USER_DEPRECATED ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ this -> intId ) ) { throw new InternalServerErrorException ( 'Resource "' . $ this -> intId . '" is not a directory.' ) ; } if ( file_exists ( $ this -> strRootDir . '/' . $ this -> intId . '/.public' ) ) { $ objFolder = new Folder ( $ this -> intId ) ; $ objFolder -> protect ( ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> generateSymlinks ( ) ; $ this -> log ( 'Folder "' . $ this -> intId . '" has been protected' , __METHOD__ , TL_FILES ) ; } else { $ objFolder = new Folder ( $ this -> intId ) ; $ objFolder -> unprotect ( ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> generateSymlinks ( ) ; $ this -> log ( 'The protection from folder "' . $ this -> intId . '" has been removed' , __METHOD__ , TL_FILES ) ; } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
997	public function offsetUnset ( $ offset ) { if ( $ offset === true ) { $ this -> trueValue = null ; $ this -> trueValueIsSet = false ; } elseif ( $ offset === false ) { $ this -> falseValue = null ; $ this -> falseValueIsSet = false ; } elseif ( is_int ( $ offset ) || is_string ( $ offset ) ) { unset ( $ this -> standardStore [ $ offset ] ) ; } elseif ( is_float ( $ offset ) ) { unset ( $ this -> floatStore [ ( string ) $ offset ] ) ; } elseif ( is_object ( $ offset ) ) { $ this -> objectStore -> offsetUnset ( $ offset ) ; } elseif ( is_array ( $ offset ) ) { $ index = array_search ( $ offset , $ this -> arrayKeys , true ) ; if ( $ index !== false ) { array_splice ( $ this -> arrayKeys , $ index , 1 ) ; array_splice ( $ this -> arrayValues , $ index , 1 ) ; } } elseif ( $ offset === null ) { $ this -> nullValue = null ; $ this -> nullValueIsSet = false ; } }
7875	protected function settleRepositoryIfNotExists ( ) { $ source = $ this -> pipelines -> getSource ( ) ; if ( ! $ this -> files -> exists ( $ source ) ) { $ this -> pipelines -> settle ( ) ; } }
8454	protected function downloadMediaFileFromURL ( $ fileUri , $ tempFileName ) { $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , "$fileUri" ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11" ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_HEADER , false ) ; curl_setopt ( $ curl , CURLOPT_NOBODY , false ) ; curl_setopt ( $ curl , CURLOPT_BUFFERSIZE , 1024 ) ; curl_setopt ( $ curl , CURLOPT_FILE , $ tempFileName ) ; curl_exec ( $ curl ) ; curl_close ( $ curl ) ; }
3052	public function getItemIndexValue ( $ id , $ name ) { return $ this -> itemIndex -> getItemValue ( $ id , \ common_session_SessionManager :: getSession ( ) -> getInterfaceLanguage ( ) , $ name ) ; }
2976	public function serialize ( ) { try { $ this -> data = $ this -> data ? : $ this -> serializer -> getData ( $ this -> closure , true ) ; return serialize ( $ this -> data ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Serialization of closure failed: ' . $ e -> getMessage ( ) , E_USER_NOTICE ) ; return null ; } }
11929	public function setDataInterface ( $ value ) { if ( ( $ interfaceItem = Yii :: $ app -> collectors [ 'dataInterfaces' ] -> getOne ( $ value ) ) && ( $ interface = $ interfaceItem -> object ) ) { $ this -> _interface = $ interfaceItem ; } else { throw new Exception ( "Invalid interface!" ) ; } }
9884	private function writeNamedRanges ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ namedRanges = $ spreadsheet -> getNamedRanges ( ) ; foreach ( $ namedRanges as $ namedRange ) { $ this -> writeDefinedNameForNamedRange ( $ objWriter , $ namedRange ) ; } }
3214	function disableAccessToken ( ) { $ response = $ this -> doPost ( $ this -> apiHost , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; }
11901	private function assembleUrl ( ) { $ address = '' ; if ( ! empty ( $ this -> scheme ) ) { $ address .= $ this -> scheme . '://' ; } if ( ! empty ( $ this -> user ) ) { $ address .= $ this -> user ; } if ( ! empty ( $ this -> pass ) ) { $ address .= ':' . $ this -> pass . '@' ; } if ( ! empty ( $ this -> host ) ) { $ address .= $ this -> host ; } if ( ! empty ( $ this -> port ) ) { $ address .= ':' . $ this -> port ; } if ( ! empty ( $ this -> path ) ) { $ address .= $ this -> path ; } if ( count ( $ this -> query ) > 0 ) { $ this -> query_string = http_build_query ( $ this -> query ) ; $ address .= '?' . $ this -> query_string ; } if ( ! empty ( $ this -> fragment ) ) { $ address .= '#' . $ this -> fragment ; } $ this -> full_address = $ address ; }
9272	protected function dataToMultipart ( array $ data = [ ] ) { $ multipart = [ ] ; foreach ( $ data as $ name => $ contents ) { array_push ( $ multipart , [ 'name' => $ name , 'contents' => $ contents ] ) ; } return $ multipart ; }
9583	public function addCachedRoute ( Route $ route ) { $ this -> routes -> attach ( $ route ) ; if ( $ name = $ route -> getName ( ) ) { $ this -> addNamedRoute ( $ name , $ route ) ; } }
6933	public function transform ( ) { if ( null === $ this -> source || null === $ this -> target ) { throw new LogicException ( "Please call initialize first." ) ; } $ event = new SaleTransformEvent ( $ this -> source , $ this -> target ) ; $ this -> eventDispatcher -> dispatch ( SaleTransformEvents :: PRE_TRANSFORM , $ event ) ; if ( $ event -> hasErrors ( ) || $ event -> isPropagationStopped ( ) ) { return $ event ; } $ targetEvent = $ this -> getOperator ( $ this -> target ) -> persist ( $ this -> target ) ; if ( ! $ targetEvent -> isPropagationStopped ( ) && ! $ targetEvent -> hasErrors ( ) ) { $ this -> uploadableListener -> setEnabled ( false ) ; $ sourceEvent = $ this -> getOperator ( $ this -> source ) -> delete ( $ this -> source , true ) ; if ( ! $ sourceEvent -> isPropagationStopped ( ) && ! $ sourceEvent -> hasErrors ( ) ) { $ targetEvent = null ; } $ this -> uploadableListener -> setEnabled ( true ) ; } $ this -> eventDispatcher -> dispatch ( SaleTransformEvents :: POST_TRANSFORM , $ event ) ; if ( $ event -> hasErrors ( ) || $ event -> isPropagationStopped ( ) ) { return $ event ; } $ this -> source = null ; $ this -> target = null ; return $ targetEvent ; }
2110	public function setRelatedRecords ( array $ arrRelated ) { $ objDatabase = Database :: getInstance ( ) ; $ objCount = $ objDatabase -> prepare ( "SELECT COUNT(*) AS count FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ this -> id ) ; if ( $ objCount -> count > 0 ) { throw new \ LogicException ( sprintf ( 'Token "%s" already contains related records' , $ this -> token ) ) ; } foreach ( $ arrRelated as $ strTable => $ arrIds ) { foreach ( $ arrIds as $ intId ) { $ objDatabase -> prepare ( "INSERT INTO tl_opt_in_related (pid, relTable, relId) VALUES (?, ?, ?)" ) -> execute ( $ this -> id , $ strTable , $ intId ) ; } } }
9536	private function prefixExists ( $ parameter ) { $ prefixExists = false ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { $ prefixExists = true ; break ; } } return $ prefixExists ; }
11876	public static function getDump ( $ var , $ maxSize = null ) { $ trace = debug_backtrace ( ) ; $ dump = '' ; $ dump .= static :: getHeader ( 'Dump de variable' ) ; $ dump .= '<div class="dump_segment">Contexte</div>' ; if ( count ( $ trace ) > 2 ) { $ dump .= static :: getContext ( $ trace [ 1 ] , $ trace [ 2 ] ) ; } else { $ dump .= static :: getContext ( $ trace [ 1 ] ) ; } if ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\common\sgbd\Query' ) { $ dump .= '<div class="dump_segment">Requête SQL</div>'; $ dump .= '<div class="dump_segment_content"><pre>' . $ var -> getSql ( ) . '</pre></div>' ; } $ dump .= '<div class="dump_segment">Exploration de la variable</div>' ; $ dump .= '<div class="dump_segment_content"><pre>' ; if ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\framework\query\Query' ) { $ dump .= static :: getDumpQueryResult ( $ var -> getQueryResults ( ) ) ; } elseif ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\framework\query\QueryResult' ) { $ dump .= static :: getDumpQueryResult ( $ var ) ; } else { $ dump .= static :: getDumpContent ( $ var , $ maxSize ) ; } $ dump .= '</pre></div>' ; $ dump .= static :: getFooter ( ) ; return $ dump ; }
1866	public function addSenderNamePlaceholder ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> pid ) { $ objChannel = $ this -> Database -> prepare ( "SELECT senderName FROM tl_newsletter_channel WHERE id=?" ) -> execute ( $ dc -> activeRecord -> pid ) ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'placeholder' ] = $ objChannel -> senderName ; } return $ varValue ; }
12893	public function create ( $ account , $ openId ) { $ params = [ 'kf_account' => $ account , 'openid' => $ openId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CREATE , $ params ] ) ; }
5406	protected function findFirstMatch ( $ cookie ) { for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { $ is_match = $ this -> isMatch ( $ cookie , $ this -> cookies [ $ i ] -> getHost ( ) , $ this -> cookies [ $ i ] -> getPath ( ) , $ this -> cookies [ $ i ] -> getName ( ) ) ; if ( $ is_match ) { return $ i ; } } return count ( $ this -> cookies ) ; }
267	protected function loadMessagesFromDb ( $ category , $ language ) { $ mainQuery = ( new Query ( ) ) -> select ( [ 'message' => 't1.message' , 'translation' => 't2.translation' ] ) -> from ( [ 't1' => $ this -> sourceMessageTable , 't2' => $ this -> messageTable ] ) -> where ( [ 't1.id' => new Expression ( '[[t2.id]]' ) , 't1.category' => $ category , 't2.language' => $ language , ] ) ; $ fallbackLanguage = substr ( $ language , 0 , 2 ) ; $ fallbackSourceLanguage = substr ( $ this -> sourceLanguage , 0 , 2 ) ; if ( $ fallbackLanguage !== $ language ) { $ mainQuery -> union ( $ this -> createFallbackQuery ( $ category , $ language , $ fallbackLanguage ) , true ) ; } elseif ( $ language === $ fallbackSourceLanguage ) { $ mainQuery -> union ( $ this -> createFallbackQuery ( $ category , $ language , $ fallbackSourceLanguage ) , true ) ; } $ messages = $ mainQuery -> createCommand ( $ this -> db ) -> queryAll ( ) ; return ArrayHelper :: map ( $ messages , 'message' , 'translation' ) ; }
368	public function renderTableBody ( ) { $ models = array_values ( $ this -> dataProvider -> getModels ( ) ) ; $ keys = $ this -> dataProvider -> getKeys ( ) ; $ rows = [ ] ; foreach ( $ models as $ index => $ model ) { $ key = $ keys [ $ index ] ; if ( $ this -> beforeRow !== null ) { $ row = call_user_func ( $ this -> beforeRow , $ model , $ key , $ index , $ this ) ; if ( ! empty ( $ row ) ) { $ rows [ ] = $ row ; } } $ rows [ ] = $ this -> renderTableRow ( $ model , $ key , $ index ) ; if ( $ this -> afterRow !== null ) { $ row = call_user_func ( $ this -> afterRow , $ model , $ key , $ index , $ this ) ; if ( ! empty ( $ row ) ) { $ rows [ ] = $ row ; } } } if ( empty ( $ rows ) && $ this -> emptyText !== false ) { $ colspan = count ( $ this -> columns ) ; return "<tbody>\n<tr><td colspan=\"$colspan\">" . $ this -> renderEmpty ( ) . "</td></tr>\n</tbody>" ; } return "<tbody>\n" . implode ( "\n" , $ rows ) . "\n</tbody>" ; }
4235	private static function trimDesc ( $ desc ) { $ lines = \ explode ( "\n" , $ desc ) ; $ leadingSpaces = array ( ) ; foreach ( $ lines as $ line ) { if ( \ strlen ( $ line ) ) { $ leadingSpaces [ ] = \ strspn ( $ line , ' ' ) ; } } \ array_shift ( $ leadingSpaces ) ; $ trimLen = $ leadingSpaces ? \ min ( $ leadingSpaces ) : 0 ; if ( ! $ trimLen ) { return $ desc ; } foreach ( $ lines as $ i => $ line ) { $ lines [ $ i ] = $ i > 0 && \ strlen ( $ line ) ? \ substr ( $ line , $ trimLen ) : $ line ; } $ desc = \ implode ( "\n" , $ lines ) ; return $ desc ; }
8253	protected function handleAccountPage ( Request $ httpRequest ) { $ user = $ this -> picoAuth -> getUser ( ) ; if ( ! $ user -> getAuthenticated ( ) ) { $ this -> session -> addFlash ( "error" , "Login to access this page." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; return ; } if ( $ user -> getAuthenticator ( ) !== $ this -> getName ( ) ) { $ this -> picoAuth -> redirectToPage ( "index" ) ; return ; } $ editAccount = $ this -> picoAuth -> getContainer ( ) -> get ( 'EditAccount' ) ; $ editAccount -> setConfig ( $ this -> config ) -> handleAccountPage ( $ httpRequest ) ; }
6056	public function updateFolder ( $ id , Folder $ folder ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'folder' => $ folder ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders/' . $ id . '' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
10616	protected function setLifetime ( Response $ response , $ lifetime ) { if ( $ lifetime >= 0 ) { $ date = clone $ response -> getDate ( ) ; $ response -> setMaxAge ( $ lifetime ) -> setExpires ( $ date -> modify ( sprintf ( '+%s seconds' , $ lifetime ) ) ) ; if ( ! $ response -> headers -> hasCacheControlDirective ( 'private' ) ) { $ response -> setPublic ( ) -> setSharedMaxAge ( $ lifetime ) ; } } return $ this ; }
2270	public function getSizeOf ( $ strTable ) { $ statement = $ this -> resConnection -> executeQuery ( 'SHOW TABLE STATUS LIKE ' . $ this -> resConnection -> quote ( $ strTable ) ) ; $ status = $ statement -> fetch ( \ PDO :: FETCH_ASSOC ) ; return $ status [ 'Data_length' ] + $ status [ 'Index_length' ] ; }
7443	public function newAction ( ) { $ group = new Group ( ) ; $ form = $ this -> createForm ( GroupType :: class , $ group ) ; return array ( 'group' => $ group , 'form' => $ form -> createView ( ) ) ; }
12416	static function run_coding_style_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcs = self :: getTool ( 'phpcs' , $ opts , true ) ; $ rulesDir = self :: getVendorDir ( ) . '/squizlabs/php_codesniffer/Codesniffer/Standards/' . $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ; if ( ! is_dir ( $ rulesDir ) ) { if ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] == 'ezcs' ) { $ sourceDir = self :: getVendorDir ( ) . '/ezsystems/ezcs/php/ezcs' ; if ( is_dir ( $ sourceDir ) ) { pake_symlink ( $ sourceDir , $ rulesDir ) ; } } } try { $ out = pake_sh ( "$phpcs --standard=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ) . " " . "--report=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'format' ] ) . " " . "--extensions=php " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcs.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
4708	public function initialize ( Text $ text , array $ options = array ( ) ) { $ text -> replace ( '{ ^[ ]{0,' . $ options [ 'tabWidth' ] . '}\[(.+)\]: # id = $1 [ \t]* \n? # maybe *one* newline [ \t]* <?(\S+?)>? # url = $2 [ \t]* \n? # maybe one newline [ \t]* (?: (?<=\s) # lookbehind for whitespace ["\'(] (.+?) # title = $3 ["\')] [ \t]* )? # title is optional (?:\n+|\Z) }xm' , function ( Text $ whole , Text $ id , Text $ url , Text $ title = null ) { $ id -> lower ( ) ; $ this -> markdown -> emit ( 'escape.special_chars' , [ $ url -> replace ( '/(?<!\\\\)_/' , '\\\\_' ) ] ) ; $ this -> markdown -> getUrlRegistry ( ) -> set ( $ id , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' , false ) ) ; if ( $ title ) { $ this -> markdown -> getTitleRegistry ( ) -> set ( $ id , preg_replace ( '/"/' , '&quot;' , $ title ) ) ; } return '' ; } ) ; }
11850	public static function createFault ( $ code , $ message ) { $ response = new \ SimpleXMLElement ( "<methodResponse></methodResponse>" ) ; $ struct = $ response -> addChild ( "fault" ) -> addChild ( "value" ) -> addChild ( "struct" ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultCode" ) ; $ member -> addChild ( "value" ) -> addChild ( "int" , $ code ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultString" ) ; $ member -> addChild ( "value" , $ message ) ; return $ response -> asXML ( ) ; }
1585	public function withLinks ( $ links ) : self { $ copy = clone $ this ; $ copy -> links = collect ( $ links ) -> all ( ) ; return $ copy ; }
11820	public function cell_default ( $ item , $ column ) { $ ret = $ this -> val ( $ item , $ column ) ; return is_null ( $ ret ) ? '' : $ ret ; }
11134	protected function calculateSELECT ( ) { $ this -> query .= 'SELECT ' ; if ( $ this -> distinct ) { $ this -> query .= ' DISTINCT ' ; } $ this -> queryStringFromArray ( 'selects' , '' , ', ' ) ; $ this -> queryStringFromArray ( 'tables' , ' FROM ' , ', ' ) ; $ this -> joinStringFromArray ( 'joins' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'groupBys' , ' GROUP BY ' , ', ' ) ; $ this -> conditionStringFromArray ( 'havings' , ' HAVING ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } if ( $ this -> offset ) { $ this -> query .= ' OFFSET ' . $ this -> offset ; } }
11793	public function setCc ( $ mail = '' , $ name = null ) { $ this -> cc = Helper :: deduplicate ( array_merge ( $ this -> cc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
1991	protected function getLoginStatus ( $ strCookie ) { @ trigger_error ( 'Using Frontend::getLoginStatus() has been deprecated and will no longer work in Contao 5.0. Use Symfony security instead.' , E_USER_DEPRECATED ) ; $ objTokenChecker = System :: getContainer ( ) -> get ( 'contao.security.token_checker' ) ; if ( $ strCookie == 'BE_USER_AUTH' && $ objTokenChecker -> hasBackendUser ( ) ) { if ( TL_MODE == 'FE' && ! $ objTokenChecker -> isPreviewMode ( ) ) { return false ; } return true ; } if ( $ strCookie == 'FE_USER_AUTH' && $ objTokenChecker -> hasFrontendUser ( ) ) { return true ; } return false ; }
7879	protected function registerLogViewer ( ) { $ this -> app -> singleton ( 'logviewer' , function ( $ app ) { $ factory = $ app [ 'logviewer.factory' ] ; $ filesystem = $ app [ 'logviewer.filesystem' ] ; $ data = $ app [ 'logviewer.data' ] ; return new LogViewer ( $ factory , $ filesystem , $ data ) ; } ) ; $ this -> app -> alias ( 'logviewer' , LogViewer :: class ) ; }
8633	public function setOrderChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9343	public function addRow ( array $ arr_row ) { if ( count ( $ this -> arr ) == $ this -> size -> rows ) { throw new \ OutOfRangeException ( sprintf ( 'You cannot add another row! Max number of rows is %d' , $ this -> size -> rows ) ) ; } if ( count ( $ arr_row ) != $ this -> size -> cols ) { throw new \ InvalidArgumentException ( 'New row must have same amout of columns than defined into the size matrix' ) ; } $ this -> arr [ ] = $ arr_row ; return $ this ; }
3955	public function getVariantBase ( ) { if ( $ this -> getMetaModel ( ) -> hasVariants ( ) && ! $ this -> isVariantBase ( ) ) { return $ this -> getMetaModel ( ) -> findById ( $ this -> get ( 'vargroup' ) ) ; } return $ this ; }
2208	public function __isset ( $ strKey ) { if ( empty ( $ this -> arrCache ) ) { $ this -> next ( ) ; } return isset ( $ this -> arrCache [ $ strKey ] ) ; }
10967	public static function isSsl ( ) { $ isSecure = false ; if ( isset ( $ _SERVER [ 'HTTPS' ] ) && in_array ( $ _SERVER [ 'HTTPS' ] , [ 'on' , '1' ] ) ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] == 'https' ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] == 'on' ) { $ isSecure = true ; } return $ isSecure ; }
10075	public static function controlCharacterOOXML2PHP ( $ value ) { self :: buildCharacterSets ( ) ; return str_replace ( array_keys ( self :: $ controlCharacters ) , array_values ( self :: $ controlCharacters ) , $ value ) ; }
3450	public function getDirectChildren ( array $ filter = [ ] ) { return static :: query ( ) -> filter ( $ filter ) -> filter ( [ 'SECTION_ID' => $ this -> id ] ) -> select ( 'ID' ) -> getList ( ) -> transform ( function ( $ section ) { return ( int ) $ section [ 'ID' ] ; } ) -> all ( ) ; }
8048	public function receive ( ) { $ hdr = '' ; do { $ read = socket_read ( $ this -> socket , 4 - strlen ( $ hdr ) ) ; if ( $ read === FALSE ) { throw new SimpleSocketException ( 'Reception failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } elseif ( $ read === '' || $ read === NULL ) { return NULL ; } $ hdr .= $ read ; } while ( strlen ( $ hdr ) < 4 ) ; list ( $ len ) = array_values ( unpack ( "N" , $ hdr ) ) ; $ buffer = '' ; do { $ read = socket_read ( $ this -> socket , $ len - strlen ( $ buffer ) ) ; if ( $ read === FALSE || $ read == '' ) { throw new SimpleSocketException ( 'Reception failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } elseif ( $ read == '' ) { return NULL ; } $ buffer .= $ read ; } while ( strlen ( $ buffer ) < $ len ) ; $ data = unserialize ( $ buffer ) ; return $ data ; }
11012	protected function importSchemaFile ( string $ schemaFile , string $ controlTableName = null ) : void { if ( $ controlTableName !== null ) { if ( $ this -> db -> getSchemaManager ( ) -> tablesExist ( [ $ controlTableName ] ) ) { $ this -> output -> writeln ( '<comment>Schema already exists in the database, skipping schema import for file <info>' . $ schemaFile . '</info></comment>' ) ; return ; } } $ this -> runQueriesFromFile ( $ schemaFile ) ; }
2600	public function peek ( ) { if ( isset ( $ this -> tokens [ $ this -> position + $ this -> peek ] ) ) { return $ this -> tokens [ $ this -> position + $ this -> peek ++ ] ; } else { return null ; } }
10527	public function getValue ( ) { static $ ip = null ; if ( is_null ( $ ip ) ) { $ ip = $ this -> getIpAddressFromProxy ( ) ; if ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) ) { $ ip = $ _SERVER [ 'REMOTE_ADDR' ] ; } } return $ ip ; }
2537	protected function getSoapClient ( $ msgName ) { $ wsdlId = $ this -> getWsdlIdFor ( $ msgName ) ; if ( ! empty ( $ msgName ) ) { if ( ! isset ( $ this -> soapClients [ $ wsdlId ] ) || ! ( $ this -> soapClients [ $ wsdlId ] instanceof \ SoapClient ) ) { $ this -> soapClients [ $ wsdlId ] = $ this -> initSoapClient ( $ wsdlId ) ; } return $ this -> soapClients [ $ wsdlId ] ; } else { return null ; } }
10681	public function onBeforeWrite ( ) { if ( $ this -> owner -> Title ) { $ this -> owner -> URLSegment = $ this -> generateURLSegment ( $ this -> owner -> Title ) ; } parent :: onBeforeWrite ( ) ; }
3772	private function buildLanguageString ( $ name , $ screen , $ locale ) { if ( isset ( $ screen [ 'label' ] [ $ locale ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ $ locale ] ; return ; } $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ '' ] ; }
1005	public function toPsrResponse ( $ result , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { if ( $ result instanceof Promise ) { return $ result -> then ( function ( $ actualResult ) use ( $ response , $ writableBodyStream ) { return $ this -> doConvertToPsrResponse ( $ actualResult , $ response , $ writableBodyStream ) ; } ) ; } return $ this -> doConvertToPsrResponse ( $ result , $ response , $ writableBodyStream ) ; }
12594	protected function makeDir ( $ dirName , LoggerInterface $ logger ) { $ dn = explode ( getcwd ( ) , $ dirName ) [ 1 ] ?? $ dirName ; if ( @ mkdir ( $ dirName ) ) { $ logger -> logText ( "Created directory <fg=green>%s</>" , LoggerInterface :: VERBOSITY_NORMAL , NULL , $ dn ) ; } else { $ logger -> logWarning ( "Creating directory $dn failed" ) ; } }
9346	public function getCol ( $ int = 0 ) { if ( $ int >= $ this -> size -> cols ) { throw new \ OutOfRangeException ( 'There is not column having this index.' ) ; } $ arr_out = array ( ) ; foreach ( $ this -> arr as $ row ) { $ arr_out [ ] = $ row [ $ int ] ; } return $ arr_out ; }
4501	public function getElementsByClassName ( string $ names ) : HTMLCollection { $ namesArray = explode ( " " , $ names ) ; $ dots = "." . implode ( "." , $ namesArray ) ; return $ this -> css ( $ dots ) ; }
2948	public function release ( $ version ) { $ package = 'upyun/sdk' ; $ name = 'php-sdk' ; $ collection = $ this -> collectionBuilder ( ) ; $ workingPath = __DIR__ . DIRECTORY_SEPARATOR . $ collection -> workDir ( "release" ) ; $ collection -> taskExec ( "composer create-project {$package} {$name} {$version}" ) -> dir ( $ workingPath ) -> arg ( '--prefer-dist' ) -> arg ( '--no-dev' ) -> arg ( '-vvv' ) -> taskExec ( 'composer dump-autoload --optimize' ) -> dir ( $ workingPath . DIRECTORY_SEPARATOR . $ name ) -> arg ( '-vvv' ) ; $ collection -> run ( ) ; $ zipFile = "release/{$name}-{$version}.zip" ; $ this -> _remove ( $ zipFile ) ; $ this -> taskPack ( $ zipFile ) -> addDir ( "php-sdk" , __DIR__ . "/release/php-sdk" ) -> run ( ) ; $ this -> _deleteDir ( "release/$name" ) ; }
2217	public function getChannels ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> newsletters ) ) { return array ( ) ; } $ arrChannels = array ( ) ; $ objChannels = $ this -> Database -> execute ( "SELECT id, title FROM tl_newsletter_channel ORDER BY title" ) ; while ( $ objChannels -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objChannels -> id , 'newsletters' ) ) { $ arrChannels [ $ objChannels -> id ] = $ objChannels -> title ; } } return $ arrChannels ; }
8514	public function listInboundShipmentsByNextToken ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4704	public function get ( $ name ) { if ( ! $ this -> exists ( $ name ) ) { throw new \ OutOfBoundsException ( sprintf ( 'Undefined offset "%s"' , $ name ) ) ; } return $ this -> objects [ ( string ) $ name ] ; }
925	public function getExceptionErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_EXCEPTION === $ error -> getType ( ) ; } ) ; }
515	public function actionTo ( $ version ) { if ( ( $ namespaceVersion = $ this -> extractNamespaceMigrationVersion ( $ version ) ) !== false ) { $ this -> migrateToVersion ( $ namespaceVersion ) ; } elseif ( ( $ migrationName = $ this -> extractMigrationVersion ( $ version ) ) !== false ) { $ this -> migrateToVersion ( $ migrationName ) ; } elseif ( ( string ) ( int ) $ version == $ version ) { $ this -> migrateToTime ( $ version ) ; } elseif ( ( $ time = strtotime ( $ version ) ) !== false ) { $ this -> migrateToTime ( $ time ) ; } else { throw new Exception ( "The version argument must be either a timestamp (e.g. 101129_185401),\n the full name of a migration (e.g. m101129_185401_create_user_table),\n the full namespaced name of a migration (e.g. app\\migrations\\M101129185401CreateUserTable),\n a UNIX timestamp (e.g. 1392853000), or a datetime string parseable\nby the strtotime() function (e.g. 2014-02-15 13:00:50)." ) ; } }
11843	private function getCalcId ( $ dsBegin , $ treeType ) { $ codeRegular = $ codeForecast = '' ; if ( $ treeType == OptionTreeType :: VAL_PLAIN ) { $ codeRegular = Cfg :: CODE_TYPE_CALC_PV_WRITE_OFF ; $ codeForecast = Cfg :: CODE_TYPE_CALC_FORECAST_PLAIN ; } elseif ( $ treeType == OptionTreeType :: VAL_COMPRESS ) { $ codeRegular = Cfg :: CODE_TYPE_CALC_COMPRESS_PHASE1 ; $ codeForecast = Cfg :: CODE_TYPE_CALC_FORECAST_PHASE1 ; } $ query = $ this -> qGetId -> build ( ) ; $ conn = $ query -> getConnection ( ) ; $ bind = [ QGetId :: BND_DS_BEGIN => $ dsBegin , QGetId :: BND_TYPE_CODE_REGULAR => $ codeRegular , QGetId :: BND_TYPE_CODE_FORECAST => $ codeForecast ] ; $ result = $ conn -> fetchOne ( $ query , $ bind ) ; return $ result ; }
3780	protected function getFilteredAttribute ( ) { if ( ! ( $ attributeId = $ this -> get ( 'attr_id' ) ) ) { return null ; } if ( $ attribute = $ this -> getMetaModel ( ) -> getAttributeById ( $ attributeId ) ) { return $ attribute ; } return null ; }
8191	public function actionConfirm ( $ id , $ code ) { $ user = UserIdentity :: findByActivationToken ( $ id , $ code ) ; if ( $ user == NULL ) throw new NotFoundHttpException ; if ( ! empty ( $ user ) ) { $ user -> activation_token = NULL ; $ user -> status = User :: STATUS_ACTIVE ; $ user -> save ( FALSE ) ; Yii :: $ app -> session -> setFlash ( 'success' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' has successfully been activated' ) ) ; } else Yii :: $ app -> session -> setFlash ( 'error' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' could not been activated. Please contact the Administrator' ) ) ; return $ this -> render ( 'confirm' , [ 'user' => $ user ] ) ; }
3379	protected function getDefaultNamespace ( $ rootNamespace ) { $ controllersPath = \ Config :: get ( 'panel.controllers' ) ; if ( isset ( $ controllersPath ) && $ controllersPath != NULL ) { return $ controllersPath ; } else { return $ rootNamespace . '\Http\Controllers' ; } }
6185	public function clear ( $ type = 'all' ) { if ( $ type === 'all' ) { $ this -> driver -> remove ( 'flash_messages' ) ; } else { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; unset ( $ flashMessages [ $ type ] ) ; $ this -> driver -> set ( 'flash_messages' , $ flashMessages ) ; } return true ; }
10036	function getBlockedContacts ( $ standardFields = array ( ) , $ customFields = array ( ) , $ pageIndex = 1 , $ pageSize = 1000 ) { $ queryParameters = array ( 'standard_field' => $ standardFields , 'page_index' => $ pageIndex , 'page_size' => $ pageSize ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ customFields ) ; return $ this -> get ( 'contacts/blocked' , $ queryParameters ) ; }
4257	protected function getErrorsInCategory ( $ category ) { $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ errorsInCat = array ( ) ; foreach ( $ errors as $ err ) { if ( $ err [ 'category' ] == $ category && $ err [ 'inConsole' ] ) { $ errorsInCat [ ] = $ err ; } } return $ errorsInCat ; }
8668	public function setSelf ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Self' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12964	private function getPerMonth ( $ months ) { $ per_month = [ ] ; $ log = $ this -> logger -> perMonth ( $ months ) ; foreach ( $ log as $ date => $ hits ) { array_push ( $ per_month , [ $ date , $ hits ] ) ; } return $ per_month ; }
10082	protected function registerConfigurator ( ) { $ this -> app -> singleton ( 'auja.database' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; switch ( $ config [ 'database' ] ) { case 'mysql' : return new MySQLDatabaseHelper ( ) ; break ; default : throw new NoDatabaseHelperException ( 'No Auja database helper for ' . $ config [ 'database' ] ) ; break ; } } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Database\DatabaseHelper' , 'auja.database' ) ; $ this -> app -> singleton ( 'auja.configurator' , function ( $ app ) { return new AujaConfigurator ( $ app , $ app [ 'auja.database' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Config\AujaConfigurator' , 'auja.configurator' ) ; }
6487	protected function createHeadersFromSuperglobals ( array $ server ) : HttpHeaders { $ headers = new HttpHeaders ( ) ; foreach ( $ server as $ name => $ values ) { $ containsMultipleValues = isset ( self :: $ headersThatPermitMultipleValues [ $ name ] ) && count ( $ explodedValues = preg_split ( '/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/' , $ values ) ) > 1 ; if ( $ containsMultipleValues ) { foreach ( $ explodedValues as $ value ) { $ this -> addHeaderValue ( $ headers , $ name , $ value , true ) ; } } else { $ this -> addHeaderValue ( $ headers , $ name , $ values , false ) ; } } return $ headers ; }
9386	public function retrieve ( $ httpMethod , $ uri ) { $ route = array ( $ httpMethod , $ uri ) ; $ routes = array_map ( function ( $ route ) { return array ( $ route [ 0 ] , $ route [ 1 ] ) ; } , $ this -> routes ) ; $ key = array_search ( $ route , $ routes ) ; return $ key !== false ? $ this -> routes [ $ key ] : null ; }
9902	private static function cellAddressInDeleteRange ( $ cellAddress , $ beforeRow , $ pNumRows , $ beforeColumnIndex , $ pNumCols ) { list ( $ cellColumn , $ cellRow ) = Coordinate :: coordinateFromString ( $ cellAddress ) ; $ cellColumnIndex = Coordinate :: columnIndexFromString ( $ cellColumn ) ; if ( $ pNumRows < 0 && ( $ cellRow >= ( $ beforeRow + $ pNumRows ) ) && ( $ cellRow < $ beforeRow ) ) { return true ; } elseif ( $ pNumCols < 0 && ( $ cellColumnIndex >= ( $ beforeColumnIndex + $ pNumCols ) ) && ( $ cellColumnIndex < $ beforeColumnIndex ) ) { return true ; } return false ; }
6902	public function url ( $ page = 1 ) { $ page = max ( 1 , ( int ) $ page ) ; if ( $ page === 1 AND ! $ this -> first_page_in_url ) { $ page = NULL ; } switch ( $ this -> current_page_source ) { case 'query_string' : case 'mixed' : return URL :: site ( $ this -> request -> uri ( ) . $ this -> query ( [ $ this -> current_page_source_key => $ page ] ) ) ; case 'route' : return URL :: site ( $ this -> route -> url ( array_merge ( $ this -> route_params , array ( $ this -> current_page_source_key => $ page ) ) ) . $ this -> query ( ) ) ; } return '#' ; }
9956	public function protectCells ( $ pRange , $ pPassword , $ pAlreadyHashed = false ) { $ pRange = strtoupper ( $ pRange ) ; if ( ! $ pAlreadyHashed ) { $ pPassword = Shared \ PasswordHasher :: hashPassword ( $ pPassword ) ; } $ this -> protectedCells [ $ pRange ] = $ pPassword ; return $ this ; }
5148	protected function getMostRecentUnreadEmail ( ) { if ( empty ( $ this -> unreadInbox ) ) { $ this -> fail ( 'Unread Inbox is Empty' ) ; } $ email = array_shift ( $ this -> unreadInbox ) ; $ content = $ this -> getFullEmail ( $ email -> id ) ; $ content -> Headers = $ this -> getHeaders ( $ email -> id ) -> headers ; return $ content ; }
5536	public function addFrame ( $ page , $ name = false ) { $ this -> frames [ ] = $ page ; if ( $ name ) { $ this -> names [ $ name ] = count ( $ this -> frames ) - 1 ; } }
9792	public function setDataType ( $ pDataType ) { if ( $ pDataType == DataType :: TYPE_STRING2 ) { $ pDataType = DataType :: TYPE_STRING ; } $ this -> dataType = $ pDataType ; return $ this -> updateInCollection ( ) ; }
938	public function isGivenKind ( $ possibleKind ) { return $ this -> isArray && ( \ is_array ( $ possibleKind ) ? \ in_array ( $ this -> id , $ possibleKind , true ) : $ this -> id === $ possibleKind ) ; }
5061	public function calculateWidth ( $ text , $ size = self :: TEXT_SIZE ) { $ size = $ this -> convertToPt ( $ size ) ; $ box = imagettfbbox ( $ size , 0 , $ this -> fontPath , $ text ) ; return round ( abs ( $ box [ 2 ] - $ box [ 0 ] ) + self :: SHIELD_PADDING_EXTERNAL + self :: SHIELD_PADDING_INTERNAL , 1 ) ; }
5615	public function paintGroupEnd ( $ message ) { $ node = $ this -> _stack -> pop ( ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ current ) { if ( $ node -> isFailed ( ) ) { $ current -> fail ( ) ; } $ current -> putChild ( $ node ) ; } else { $ this -> _graph = $ node ; } parent :: paintGroupEnd ( $ message ) ; }
59	public function addPackage ( $ source , $ target , $ reason ) { $ this -> suggestedPackages [ ] = array ( 'source' => $ source , 'target' => $ target , 'reason' => $ reason , ) ; return $ this ; }
9555	public function getHandler ( ) { if ( $ this -> namer === null ) { $ this -> namer = new GenericNamer ( ) ; } if ( $ this -> filesystem === null ) { throw new \ LogicException ( sprintf ( 'You should set a filesystem for the builder.' ) ) ; } $ handler = new UploadHandler ( $ this -> filesystem , $ this -> namer , $ this -> overwrite ) ; $ validator = $ handler -> getValidator ( ) ; foreach ( $ this -> constraints as $ constraint ) { $ validator -> addConstraint ( $ constraint ) ; } return $ handler ; }
6708	protected function getReaderFactory ( ) { if ( ! $ this -> readerFactory ) { $ this -> readerFactory = new ReaderFactory ( [ new Json ( ) , new Xml ( ) , ] ) ; } return $ this -> readerFactory ; }
8923	public function generate ( $ sourceDocument , $ targetDocument ) { if ( $ sourceDocument === null || $ targetDocument === null ) { return $ targetDocument ; } if ( $ sourceDocument == new \ stdClass ( ) ) { return null ; } if ( is_array ( $ sourceDocument ) ) { if ( $ sourceDocument !== $ targetDocument ) { return $ targetDocument ; } return null ; } $ patchDocument = new \ stdClass ( ) ; $ sourceDocumentVars = get_object_vars ( $ sourceDocument ) ; $ targetDocumentVars = get_object_vars ( $ targetDocument ) ; foreach ( $ targetDocumentVars as $ var => $ value ) { if ( ! in_array ( $ var , array_keys ( $ sourceDocumentVars ) ) || ! in_array ( $ value , array_values ( $ sourceDocumentVars ) ) ) { $ patchDocument -> $ var = $ value ; } } foreach ( $ sourceDocumentVars as $ var => $ value ) { if ( $ targetDocumentVars === [ ] ) { $ patchDocument -> $ var = null ; break ; } if ( is_object ( $ value ) ) { if ( $ sourceDocument -> $ var !== null && is_object ( $ sourceDocument -> $ var ) ) { $ subPatch = $ this -> generate ( $ sourceDocument -> $ var , $ targetDocument -> $ var ) ; if ( $ subPatch !== null ) { $ patchDocument -> $ var = $ subPatch ; } } } elseif ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) || ! in_array ( $ value , array_values ( $ targetDocumentVars ) ) ) { $ sourceDocument -> $ var = null ; if ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) ) { $ patchDocument -> $ var = null ; } } } if ( count ( get_object_vars ( $ patchDocument ) ) > 0 ) { return $ patchDocument ; } return null ; }
10847	protected function runCommand ( $ command , $ basePath , $ asset , $ result ) { $ command = Yii :: getAlias ( $ command ) ; $ command = strtr ( $ command , [ '{from}' => escapeshellarg ( "$basePath/$asset" ) , '{to}' => escapeshellarg ( "$basePath/$result" ) , ] ) ; $ descriptor = [ 1 => [ 'pipe' , 'w' ] , 2 => [ 'pipe' , 'w' ] , ] ; $ pipes = [ ] ; $ proc = proc_open ( $ command , $ descriptor , $ pipes , $ basePath ) ; $ stdout = stream_get_contents ( $ pipes [ 1 ] ) ; $ stderr = stream_get_contents ( $ pipes [ 2 ] ) ; foreach ( $ pipes as $ pipe ) { fclose ( $ pipe ) ; } $ status = proc_close ( $ proc ) ; if ( $ status === 0 ) { Yii :: trace ( "Converted $asset into $result:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" , __METHOD__ ) ; } elseif ( YII_DEBUG ) { throw new Exception ( "AssetConverter command '$command' failed with exit code $status:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" ) ; } else { Yii :: error ( "AssetConverter command '$command' failed with exit code $status:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" , __METHOD__ ) ; } return $ status === 0 ; }
6631	public function authURL ( $ state ) { $ url = $ this -> settings [ 'authentication_url' ] ; $ params = [ 'client_id' => $ this -> settings ( 'api_key' ) , 'redirect_uri' => $ this -> settings ( 'redirect_uri' ) , 'scope' => $ this -> settings ( 'permissions' ) , 'state' => $ state , ] ; return $ url . '?' . http_build_query ( $ params ) ; }
2982	public function addBundle ( $ bundle ) { if ( ! $ this -> getFilename ( ) ) { return false ; } $ src = file ( $ this -> getFilename ( ) ) ; $ method = $ this -> reflected -> getMethod ( 'registerBundles' ) ; $ lines = array_slice ( $ src , $ method -> getStartLine ( ) - 1 , $ method -> getEndLine ( ) - $ method -> getStartLine ( ) + 1 ) ; if ( false !== strpos ( implode ( '' , $ lines ) , $ bundle ) ) { throw new \ RuntimeException ( sprintf ( 'Bundle "%s" is already defined in "AppKernel::registerBundles()".' , $ bundle ) ) ; } $ this -> setCode ( token_get_all ( '<?php ' . implode ( '' , $ lines ) ) , $ method -> getStartLine ( ) ) ; while ( $ token = $ this -> next ( ) ) { if ( T_VARIABLE !== $ token [ 0 ] || '$bundles' !== $ token [ 1 ] ) { continue ; } $ this -> next ( ) ; $ token = $ this -> next ( ) ; if ( T_ARRAY !== $ token [ 0 ] && '[' !== $ this -> value ( $ token ) ) { return false ; } while ( $ token = $ this -> next ( ) ) { if ( ')' !== $ this -> value ( $ token ) && ']' !== $ this -> value ( $ token ) ) { continue ; } if ( ';' !== $ this -> value ( $ this -> peek ( ) ) ) { continue ; } $ this -> next ( ) ; $ leadingContent = implode ( '' , array_slice ( $ src , 0 , $ this -> line ) ) ; $ leadingContent = rtrim ( rtrim ( $ leadingContent ) , ';' ) ; $ closingSymbolRegex = '#(\)|])$#' ; preg_match ( $ closingSymbolRegex , $ leadingContent , $ matches ) ; $ closingSymbol = $ matches [ 0 ] ; $ leadingContent = rtrim ( preg_replace ( $ closingSymbolRegex , '' , rtrim ( $ leadingContent ) ) ) ; if ( '(' !== substr ( $ leadingContent , - 1 ) && '[' !== substr ( $ leadingContent , - 1 ) ) { $ leadingContent = rtrim ( $ leadingContent , ',' ) . ',' ; } $ lines = array_merge ( array ( $ leadingContent , "\n" ) , array ( str_repeat ( ' ' , 12 ) , sprintf ( 'new %s(),' , $ bundle ) , "\n" ) , array ( str_repeat ( ' ' , 8 ) , $ closingSymbol . ';' , "\n" ) , array_slice ( $ src , $ this -> line ) ) ; Generator :: dump ( $ this -> getFilename ( ) , implode ( '' , $ lines ) ) ; return true ; } } }
5954	public function channelCreate ( array $ properties ) { $ cid = $ this -> execute ( "channelcreate" , $ properties ) -> toList ( ) ; $ this -> channelListReset ( ) ; if ( ! isset ( $ properties [ "client_flag_permanent" ] ) && ! isset ( $ properties [ "client_flag_semi_permanent" ] ) ) { $ this -> getParent ( ) -> whoamiSet ( "client_channel_id" , $ cid [ "cid" ] ) ; } return $ cid [ "cid" ] ; }
5318	public function wait ( ) { $ this -> internalWait ( ) ; $ event = $ this -> isSuccessExit ( ) ? 'success' : 'error' ; $ this -> internalEmit ( 'exit' , $ this -> pid ) ; $ this -> internalEmit ( $ event ) ; return $ this ; }
10439	protected function nextBufferLine ( ) { $ query = $ this -> parseQuery ( ) ; if ( ! empty ( $ query ) ) { $ this -> buffer [ $ this -> key ] [ self :: PARAM_QUERY ] = $ query ; } else { $ this -> buffer [ $ this -> key ] = false ; } }
6421	public static function ands ( callable ... $ predicates ) : callable { return function ( $ element ) use ( $ predicates ) { foreach ( $ predicates as $ predicate ) { if ( ! self :: call ( $ predicate , $ element ) ) { return false ; } } return true ; } ; }
3093	public function process ( $ data , $ serviceContext ) { if ( empty ( $ data ) ) { throw new \ common_exception_InconsistentData ( 'No action to check. Processing action requires data.' ) ; } $ actions = [ ] ; $ duration = 0 ; foreach ( $ data as $ entry ) { $ action = $ this -> resolve ( $ entry ) ; $ actions [ ] = $ action ; if ( $ action -> hasRequestParameter ( 'itemDuration' ) ) { $ duration += $ action -> getRequestParameter ( 'itemDuration' ) + self :: TIMEPOINT_INTERVAL ; } } $ now = microtime ( true ) ; $ last = $ serviceContext -> getTestSession ( ) -> getTimer ( ) -> getLastRegisteredTimestamp ( ) ; $ elapsed = $ now - $ last ; if ( $ duration > $ elapsed ) { \ common_Logger :: t ( 'Ignoring the last timestamp to take into account the actual duration to sync. Could introduce TimeLine inconsistency!' ) ; $ last = $ now - $ duration ; } usort ( $ actions , function ( $ a , $ b ) { return $ a -> getTimestamp ( ) - $ b -> getTimestamp ( ) ; } ) ; $ response = [ ] ; foreach ( $ actions as $ action ) { try { $ serviceContext -> setSyncingMode ( $ action -> getRequestParameter ( 'offline' ) ) ; if ( $ action -> hasRequestParameter ( 'itemDuration' ) && $ serviceContext -> isSyncingMode ( ) ) { $ last += $ action -> getRequestParameter ( 'itemDuration' ) + self :: TIMEPOINT_INTERVAL ; $ action -> setTime ( $ last ) ; } else { $ action -> setTime ( $ now ) ; } $ action -> setServiceContext ( $ serviceContext ) ; if ( $ serviceContext instanceof QtiRunnerServiceContext ) { } $ responseAction = $ action -> process ( ) ; } catch ( \ common_Exception $ e ) { $ responseAction = [ 'error' => $ e -> getMessage ( ) ] ; $ responseAction [ 'success' ] = false ; } $ responseAction [ 'name' ] = $ action -> getName ( ) ; $ responseAction [ 'timestamp' ] = $ action -> getTimeStamp ( ) ; $ responseAction [ 'requestParameters' ] = $ action -> getRequestParameters ( ) ; $ response [ ] = $ responseAction ; if ( $ responseAction [ 'success' ] === false ) { break ; } } $ this -> getRunnerService ( ) -> persist ( $ serviceContext ) ; return $ response ; }
2129	protected function initialize ( ) { if ( static :: $ blnHasLcf === null ) { static :: preload ( ) ; } $ strCacheDir = System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ strCacheDir . '/contao/config/config.php' ) ) { include $ strCacheDir . '/contao/config/config.php' ; } else { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/config.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { $ files = array ( ) ; } foreach ( $ files as $ file ) { include $ file ; } } if ( static :: $ blnHasLcf ) { include $ this -> strRootDir . '/system/config/localconfig.php' ; } static :: loadParameters ( ) ; }
11038	function node_path_walk ( $ elements , $ rank , $ ptype , & $ i , & $ line , $ cvalue , $ ncontent , $ content , $ code ) { if ( count ( $ elements ) == 1 ) { $ elt [ $ ptype . ':' . $ i . ':' . $ elements [ 0 ] . ':' . $ cvalue ] = $ this -> parse ( $ code ? _ETS_CODE : $ ptype , $ i , $ line , $ ncontent , $ content ) ; } else { $ element1 = array_shift ( $ elements ) ; $ masktype = ( $ ptype == _ETS_MIS || $ ptype == _ETS_MISVAL ) ? _ETS_MIS_TEMPLATE : _ETS_TEMPLATE ; $ elt [ $ masktype . ':' . $ i . '.' . $ rank . ':' . $ element1 ] = $ this -> node_path_walk ( $ elements , $ rank + 1 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } return $ elt ; }
1533	protected function isFillableRelation ( $ field , $ record ) { return $ this -> isRelation ( $ field ) && $ this -> isFillable ( $ field , $ record ) ; }
11772	public function resolve ( ) : array { try { $ app_required_modules = array_unique ( $ this -> required_modules ) ; $ component_dependency_map = $ this -> getComponentDependencyMap ( $ app_required_modules ) ; $ component_type_list = $ this -> resolveComponentDependencyMap ( $ component_dependency_map ) ; $ component_module_list = [ ] ; foreach ( $ component_type_list as $ component_type ) { $ component_module = $ this -> findComponentModuleByType ( $ app_required_modules , $ component_type ) ; if ( ! $ component_module ) { throw new ModuleDependencyResolverException ( 'Could not find component module: ' . $ component_type ) ; } if ( ! in_array ( $ component_module , $ component_module_list ) ) { $ component_module_list [ ] = $ component_module ; } } $ module_list = array_merge ( $ component_module_list , $ app_required_modules ) ; $ module_dependency_map = self :: getModuleDependencyMap ( $ module_list ) ; $ resolved_list = $ this -> resolveModuleDependencyMap ( $ module_dependency_map ) ; return $ resolved_list ; } catch ( \ Throwable $ e ) { throw new ModuleDependencyResolverException ( __METHOD__ . ' failed: ' . $ e -> getMessage ( ) , $ e ) ; } }
10201	private function writeCellMerge ( XMLWriter $ objWriter , Cell $ cell ) { if ( ! $ cell -> isMergeRangeValueCell ( ) ) { return ; } $ mergeRange = Coordinate :: splitRange ( $ cell -> getMergeRange ( ) ) ; list ( $ startCell , $ endCell ) = $ mergeRange [ 0 ] ; $ start = Coordinate :: coordinateFromString ( $ startCell ) ; $ end = Coordinate :: coordinateFromString ( $ endCell ) ; $ columnSpan = Coordinate :: columnIndexFromString ( $ end [ 0 ] ) - Coordinate :: columnIndexFromString ( $ start [ 0 ] ) + 1 ; $ rowSpan = $ end [ 1 ] - $ start [ 1 ] + 1 ; $ objWriter -> writeAttribute ( 'table:number-columns-spanned' , $ columnSpan ) ; $ objWriter -> writeAttribute ( 'table:number-rows-spanned' , $ rowSpan ) ; }
5779	public function getOne ( ) : ? string { $ result = $ this -> execute ( ) ; if ( pg_num_rows ( $ result ) == 1 ) { if ( pg_num_fields ( $ result ) == 1 ) { return pg_fetch_array ( $ result ) [ 0 ] ; } else { throw new \ Exception ( "Too many result fields" ) ; } } else { if ( pg_num_rows ( $ result ) == 0 ) { return null ; } else { throw new \ Exception ( "Multiple results" ) ; } } }
1698	private function loadFrontendUser ( string $ username , BackendUser $ backendUser ) : ? FrontendUser { try { $ frontendUser = $ this -> userProvider -> loadUserByUsername ( $ username ) ; if ( ! $ frontendUser instanceof FrontendUser ) { throw new UsernameNotFoundException ( 'User is not a front end user' ) ; } } catch ( UsernameNotFoundException $ e ) { if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'Could not find a front end user with the username "%s"' , $ username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , '' ) ] ) ; } return null ; } $ allowedGroups = StringUtil :: deserialize ( $ backendUser -> amg , true ) ; $ frontendGroups = StringUtil :: deserialize ( $ frontendUser -> groups , true ) ; if ( ! $ backendUser -> isAdmin && ! \ count ( array_intersect ( $ frontendGroups , $ allowedGroups ) ) ) { return null ; } return $ frontendUser ; }
539	protected function serializePagination ( $ pagination ) { return [ $ this -> linksEnvelope => Link :: serialize ( $ pagination -> getLinks ( true ) ) , $ this -> metaEnvelope => [ 'totalCount' => $ pagination -> totalCount , 'pageCount' => $ pagination -> getPageCount ( ) , 'currentPage' => $ pagination -> getPage ( ) + 1 , 'perPage' => $ pagination -> getPageSize ( ) , ] , ] ; }
3069	protected function endItemTimer ( $ timestamp = null ) { if ( $ this -> getRequestParameter ( 'itemDuration' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemDuration = $ this -> getRequestParameter ( 'itemDuration' ) ; return $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ timestamp ) ; } return false ; }
1069	private function collectConflictsBetweenFieldsAndFragment ( ValidationContext $ context , array & $ conflicts , array & $ comparedFragments , $ areMutuallyExclusive , array $ fieldMap , $ fragmentName ) { if ( isset ( $ comparedFragments [ $ fragmentName ] ) ) { return ; } $ comparedFragments [ $ fragmentName ] = true ; $ fragment = $ context -> getFragment ( $ fragmentName ) ; if ( ! $ fragment ) { return ; } [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getReferencedFieldsAndFragmentNames ( $ context , $ fragment ) ; if ( $ fieldMap === $ fieldMap2 ) { return ; } $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; for ( $ i = 0 ; $ i < $ fragmentNames2Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap , $ fragmentNames2 [ $ i ] ) ; } }
6993	static protected function getCacheKeyForOptimizedUiTemplatesBasedOnUserRole ( $ group ) : string { if ( static :: getAuthModule ( ) -> getAccessPolicyClassName ( ) === CmfAccessPolicy :: class ) { $ userId = 'any' ; } else { $ userId = 'not_authenticated' ; $ user = static :: getUser ( ) ; if ( $ user && $ user -> existsInDb ( ) ) { if ( $ user :: hasColumn ( 'is_superadmin' ) ) { $ userId = '__superadmin__' ; } else if ( $ user :: hasColumn ( 'role' ) ) { $ userId = $ user -> role ; } else { $ userId = 'user' ; } } } return static :: url_prefix ( ) . '_templates_' . static :: getShortLocale ( ) . '_' . $ group . '_user_' . $ userId ; }
5934	public function setLastLogin ( $ lastLogin ) { if ( $ lastLogin instanceof DateTime ) { $ this -> lastLogin = $ lastLogin ; } else { try { $ this -> lastLogin = new DateTime ( $ lastLogin ) ; } catch ( \ Exception $ e ) { $ this -> lastLogin = null ; } } return $ this ; }
12768	public function get ( string $ key = '' ) { if ( empty ( $ key ) ) { return $ this -> store ; } else { return $ this -> store [ $ key ] ?? null ; } }
4221	public function getAbstraction ( & $ array , $ method = null , & $ hist = array ( ) ) { if ( \ in_array ( $ array , $ hist , true ) ) { return $ this -> abstracter -> RECURSION ; } if ( self :: isCallable ( $ array ) ) { return array ( 'debug' => $ this -> abstracter -> ABSTRACTION , 'type' => 'callable' , 'values' => array ( \ get_class ( $ array [ 0 ] ) , $ array [ 1 ] ) , ) ; } $ return = array ( ) ; $ hist [ ] = $ array ; foreach ( $ array as $ k => $ v ) { if ( $ this -> abstracter -> needsAbstraction ( $ v ) ) { $ v = $ this -> abstracter -> getAbstraction ( $ array [ $ k ] , $ method , $ hist ) ; } $ return [ $ k ] = $ v ; } return $ return ; }
7869	protected function drawCore ( ) { $ this -> drawBorderTop ( true ) ; $ this -> drawBordered ( $ this -> geometry -> getSpacedCore ( ) ) ; $ this -> drawBorderBottom ( true ) ; }
6563	public function carrier_data ( $ carrier = '' , $ field_output = '' ) { $ inputParams = array ( 'carrier' => $ carrier , 'field_output' => $ field_output ) ; $ field_output = strtolower ( $ field_output ) ; $ this -> debug -> info ( __FUNCTION__ , 'Input Params: ' , $ inputParams ) ; try { $ vnCarrierData = DataRepository :: getData ( 'vn_carrier_data' ) ; $ this -> debug -> debug ( __FUNCTION__ , 'VN Carrier All Data: ' , $ vnCarrierData ) ; if ( array_key_exists ( $ carrier , $ vnCarrierData ) ) { $ isCarrier = $ vnCarrierData [ $ carrier ] ; $ this -> debug -> debug ( __FUNCTION__ , 'Is Carrier Data: ' , $ isCarrier ) ; if ( array_key_exists ( $ field_output , $ isCarrier ) ) { $ result = $ isCarrier [ $ field_output ] ; $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ result ) ; return $ result ; } if ( $ field_output = 'full' ) { $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ isCarrier ) ; return $ isCarrier ; } } } catch ( \ Exception $ e ) { $ message = 'Error File: ' . $ e -> getFile ( ) . ' - Line: ' . $ e -> getLine ( ) . ' - Code: ' . $ e -> getCode ( ) . ' - Message: ' . $ e -> getMessage ( ) ; $ this -> debug -> error ( __FUNCTION__ , $ message ) ; return NULL ; } return NULL ; }
8105	public function runQuery ( $ sql , $ arguments = false ) { if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } if ( ! $ arguments ) { $ stmt -> execute ( ) ; } $ rows = $ stmt -> rowCount ( ) ; if ( $ rows > 0 ) { $ this -> log -> report ( "$rows row(s) where Affected" ) ; return true ; } else { $ this -> log -> report ( 'No rows were Affected' ) ; return false ; } }
9712	private function writeSupbookInternal ( ) { $ record = 0x01AE ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> spreadsheet -> getSheetCount ( ) , 0x0401 ) ; return $ this -> writeData ( $ header . $ data ) ; }
7128	public function addRanges ( string $ from , string $ to ) { $ this -> ranges [ ] = [ 'from' => $ from , 'to' => $ to , ] ; return $ this ; }
9477	protected function getTopDownloads ( $ limit = 20 ) { $ arrTopDownloads = array ( ) ; $ objTopDownloads = \ Database :: getInstance ( ) -> prepare ( "SELECT `tstamp`, `filename`, `downloads`, `id` FROM `tl_dlstats` ORDER BY `downloads` DESC" ) -> limit ( $ limit ) -> execute ( ) ; $ intRows = $ objTopDownloads -> numRows ; if ( $ intRows > 0 ) { while ( $ objTopDownloads -> next ( ) ) { $ c4d = $ this -> check4details ( $ objTopDownloads -> id ) ; $ arrTopDownloads [ ] = array ( $ objTopDownloads -> filename , $ this -> getFormattedNumber ( $ objTopDownloads -> downloads , 0 ) , $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'datimFormat' ] , $ objTopDownloads -> tstamp ) , $ objTopDownloads -> id , $ c4d , $ objTopDownloads -> downloads , $ objTopDownloads -> tstamp ) ; } } return $ arrTopDownloads ; }
526	public function init ( ) { if ( $ this -> sourcePath !== null ) { $ this -> sourcePath = rtrim ( Yii :: getAlias ( $ this -> sourcePath ) , '/\\' ) ; } if ( $ this -> basePath !== null ) { $ this -> basePath = rtrim ( Yii :: getAlias ( $ this -> basePath ) , '/\\' ) ; } if ( $ this -> baseUrl !== null ) { $ this -> baseUrl = rtrim ( Yii :: getAlias ( $ this -> baseUrl ) , '/' ) ; } }
6300	public function render ( $ mainName = 'default' , $ barName = false , array $ data = null ) { if ( $ data === null ) { $ data = [ 'title' => 'Navigation' , 'side' => 'dropdown' , 'inverse' => true ] ; } $ main = $ this -> getMain ( $ mainName ) ; if ( is_string ( $ barName ) ) { $ bar = $ this -> getBar ( $ barName ) ; if ( empty ( $ bar ) ) { $ bar = false ; } } else { $ bar = false ; } return $ this -> view -> make ( $ this -> name , array_merge ( $ data , [ 'main' => $ main , 'bar' => $ bar ] ) ) -> render ( ) ; }
6761	public function find ( $ criteria ) { if ( ! $ criteria ) { error_log ( "collection error: no criteria specified" ) ; return null ; } else if ( is_callable ( $ criteria ) ) { foreach ( $ this -> models as $ model ) if ( $ criteria ( $ model ) ) return $ model ; } else if ( is_a ( $ criteria , "SnooPHP\Model\Model" ) ) { foreach ( $ this -> models as $ i => $ model ) if ( $ model == $ criteria ) return $ i ; } return null ; }
8859	private function _hardCopy ( string $ originDir , string $ targetDir ) : string { $ this -> filesystem -> mkdir ( $ targetDir , 0777 ) ; $ this -> filesystem -> mirror ( $ originDir , $ targetDir , Finder :: create ( ) -> ignoreDotFiles ( false ) -> in ( $ originDir ) ) ; return AssetsInstallCommand :: METHOD_COPY ; }
10356	public function lockOut ( ) { $ this -> resetAttempts ( ) ; $ this -> cache -> add ( $ this -> lockOutKey , $ this -> getDelay ( ) + time ( ) , $ this -> getExpiry ( ) ) ; }
12823	protected function createContributorDir ( $ sourceDir , array $ options , $ username ) { if ( null === $ username ) { return ; } $ this -> init ( $ sourceDir , $ options , $ username ) ; if ( is_dir ( $ this -> contributorDir ) ) { return ; } $ this -> filesystem -> copy ( $ this -> productionDir . '/slot.json' , $ this -> contributorDir . '/slot.json' , true ) ; $ this -> filesystem -> mirror ( $ this -> productionDir . '/blocks' , $ this -> contributorDir . '/blocks' ) ; }
8529	public function listFinancialEvents ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7693	function MsExcel_SheetIsIt ( $ FileName ) { $ this -> MsExcel_SheetInit ( ) ; foreach ( $ this -> MsExcel_Sheets as $ o ) { if ( $ FileName == 'xl/' . $ o -> file ) return true ; } return false ; }
5757	private function selectArray ( ? string $ selectColumns = null , array $ whereColumnsInfo = null , string $ orderBy = null ) : array { $ columns = $ selectColumns ?? $ this -> defaultSelectColumnsString ; $ permissionsArray = [ ] ; if ( null !== $ records = $ this -> select ( $ columns , $ whereColumnsInfo , $ orderBy ) ) { $ rolesTableMapper = RolesTableMapper :: getInstance ( ) ; foreach ( $ records as $ record ) { if ( null === $ key = $ this -> getPermissionsArrayKeyForId ( $ permissionsArray , ( int ) $ record [ 'id' ] ) ) { $ permissionsArray [ ] = [ 'id' => ( int ) $ record [ 'id' ] , 'title' => $ record [ 'title' ] , 'description' => $ record [ 'description' ] , 'roles' => [ $ rolesTableMapper -> getObjectById ( ( int ) $ record [ 'role_id' ] ) ] , 'active' => Postgres :: convertPostgresBoolToBool ( $ record [ 'active' ] ) , 'created' => new \ DateTimeImmutable ( $ record [ 'created' ] ) , ] ; } else { array_push ( $ permissionsArray [ $ key ] [ 'roles' ] , $ rolesTableMapper -> getObjectById ( ( int ) $ record [ 'role_id' ] ) ) ; } } } return $ permissionsArray ; }
5595	protected function createRoute ( $ url ) { if ( $ this -> proxy ) { return new SimpleProxyRoute ( $ url , $ this -> proxy , $ this -> proxy_username , $ this -> proxy_password ) ; } return new SimpleRoute ( $ url ) ; }
10147	private function readPalette ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ nm = self :: getUInt2d ( $ recordData , 0 ) ; for ( $ i = 0 ; $ i < $ nm ; ++ $ i ) { $ rgb = substr ( $ recordData , 2 + 4 * $ i , 4 ) ; $ this -> palette [ ] = self :: readRGB ( $ rgb ) ; } } }
3576	public function replicate ( $ except = null ) { $ except = $ except ? array_combine ( $ except , $ except ) : [ ] ; $ attributes = [ ] ; foreach ( array_diff_key ( $ this -> items , $ except ) as $ attribute ) { $ attributes [ ] = $ attribute -> replicate ( ) ; } return new static ( $ attributes ) ; }
1067	private function findConflictsBetweenSubSelectionSets ( ValidationContext $ context , $ areMutuallyExclusive , $ parentType1 , SelectionSetNode $ selectionSet1 , $ parentType2 , SelectionSetNode $ selectionSet2 ) { $ conflicts = [ ] ; [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType1 , $ selectionSet1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType2 , $ selectionSet2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; if ( $ fragmentNames2Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap1 , $ fragmentNames2 [ $ j ] ) ; } } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; if ( $ fragmentNames1Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap2 , $ fragmentNames1 [ $ i ] ) ; } } for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentNames2 [ $ j ] ) ; } } return $ conflicts ; }
10342	protected function isValidDate ( $ year , $ month , $ day ) { if ( $ month <= 0 || $ month > 12 || $ day <= 0 || $ day > 31 ) { return false ; } if ( ( $ month == 4 || $ month == 6 || $ month == 9 || $ month == 11 ) && ( $ day == 31 ) ) { return false ; } if ( $ month == 2 ) { if ( $ day > 29 ) { return false ; } $ leap = date ( 'L' , strtotime ( $ year . '-01-01' ) ) ; if ( $ leap === '0' && $ day > 28 ) { return false ; } } return true ; }
3896	public function getTemplates ( \ DC_Table $ objDC ) { $ type = $ objDC -> activeRecord -> type ; return $ this -> getTemplateList ( 'mod_' . $ type ) ; }
4065	public function getReferencedAttributes ( ) { $ arrAttributes = array ( ) ; foreach ( $ this -> arrChildren as $ objSetting ) { $ arrAttributes = array_merge ( $ arrAttributes , $ objSetting -> getReferencedAttributes ( ) ) ; } return $ arrAttributes ; }
6414	public static function limit ( IteratorAggregate $ iterable , int $ limitSize ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ iterable , $ limitSize ) { return Iterators :: limit ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ limitSize ) ; } ) ; }
255	public function beforeRun ( ) { $ event = new WidgetEvent ( ) ; $ this -> trigger ( self :: EVENT_BEFORE_RUN , $ event ) ; return $ event -> isValid ; }
2751	public function validateCustomSnippet ( $ name , $ type , $ priority ) { $ snippetName = str_replace ( ' ' , '' , $ name ) ; $ types = [ 'init' , 'recv' , 'hit' , 'miss' , 'pass' , 'fetch' , 'error' , 'deliver' , 'log' , 'hash' , 'none' ] ; $ inArray = in_array ( $ type , $ types ) ; $ isNumeric = is_numeric ( $ priority ) ; $ isAlphanumeric = preg_match ( '/^[\w]+$/' , $ snippetName ) ; $ error = null ; if ( ! $ inArray ) { $ error = 'Type value is not recognised.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } if ( ! $ isNumeric ) { $ error = 'Please make sure that the priority value is a number.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } if ( ! $ isAlphanumeric ) { $ error = 'Please make sure that the name value contains only alphanumeric characters.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } return [ 'snippet_name' => $ snippetName , 'error' => $ error ] ; }
828	private function isValidVariable ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_VARIABLE ) ) { return false ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; return $ tokens [ $ nextIndex ] -> equals ( '=' ) ; }
304	private function resetDependentRelations ( $ attribute ) { foreach ( $ this -> _relationsDependencies [ $ attribute ] as $ relation ) { unset ( $ this -> _related [ $ relation ] ) ; } unset ( $ this -> _relationsDependencies [ $ attribute ] ) ; }
10447	public function post ( Payload $ payload , $ endpoint ) { if ( ! Type :: isValidWebhookType ( $ payload -> getAction ( ) ) ) { throw new \ Exception ( sprintf ( 'Webhook "%s" isn\'t valid' , $ payload -> getAction ( ) ) ) ; } $ requestContent = [ 'headers' => [ 'Content-Type' => 'application/json' ] , 'body' => json_encode ( $ payload ) , 'timeout' => self :: DEFAULT_REQUEST_TIMEOUT ] ; return $ this -> guzzleClient -> post ( $ endpoint , $ requestContent ) ; }
783	public function actionReport ( $ sourcePath , $ translationPath , $ title = 'Translation report' ) { $ sourcePath = trim ( $ sourcePath , '/\\' ) ; $ translationPath = trim ( $ translationPath , '/\\' ) ; $ results = [ ] ; $ dir = new DirectoryIterator ( $ sourcePath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ sourceFilePath = $ sourcePath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( $ translatedFilePath ) ; $ diff = empty ( $ errors ) ? $ this -> getDiff ( $ translatedFilePath , $ sourceFilePath ) : '' ; if ( ! empty ( $ diff ) ) { $ errors [ ] = 'Translation outdated.' ; } $ result = [ 'errors' => $ errors , 'diff' => $ diff , ] ; $ results [ $ fileinfo -> getFilename ( ) ] = $ result ; } } $ dir = new DirectoryIterator ( $ translationPath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( null , $ translatedFilePath ) ; if ( ! empty ( $ errors ) ) { $ results [ $ fileinfo -> getFilename ( ) ] [ 'errors' ] = $ errors ; } } } echo $ this -> renderFile ( __DIR__ . '/views/translation/report_html.php' , [ 'results' => $ results , 'sourcePath' => $ sourcePath , 'translationPath' => $ translationPath , 'title' => $ title , ] ) ; }
12174	public function addScalarArgument ( $ name , $ type , $ required = true , $ default = null ) { return $ this -> addArgument ( new ScalarArgument ( $ this -> argumentPosition ++ , $ name , $ type , $ required , $ default ) ) ; }
7366	protected function checkPrivacyIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ parent = $ item -> getParent ( ) ; if ( $ item -> isPrivate ( ) ) { if ( null === $ parent ) { $ this -> context -> buildViolation ( $ constraint -> root_item_cant_be_private ) -> atPath ( 'private' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } elseif ( $ item -> getTaxGroup ( ) !== $ parent -> getTaxGroup ( ) ) { $ this -> context -> buildViolation ( $ constraint -> tax_group_integrity ) -> atPath ( 'taxGroup' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } } elseif ( null !== $ parent && $ parent -> isPrivate ( ) ) { $ this -> context -> buildViolation ( $ constraint -> privacy_integrity ) -> atPath ( 'private' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
9736	public function setWorksheet ( Worksheet $ pValue = null , $ pOverrideOld = false ) { if ( $ this -> worksheet === null ) { $ this -> worksheet = $ pValue ; $ this -> worksheet -> getCell ( $ this -> coordinates ) ; $ this -> worksheet -> getDrawingCollection ( ) -> append ( $ this ) ; } else { if ( $ pOverrideOld ) { $ iterator = $ this -> worksheet -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { if ( $ iterator -> current ( ) -> getHashCode ( ) == $ this -> getHashCode ( ) ) { $ this -> worksheet -> getDrawingCollection ( ) -> offsetUnset ( $ iterator -> key ( ) ) ; $ this -> worksheet = null ; break ; } } $ this -> setWorksheet ( $ pValue ) ; } else { throw new PhpSpreadsheetException ( 'A Worksheet has already been assigned. Drawings can only exist on one \\PhpOffice\\PhpSpreadsheet\\Worksheet.' ) ; } } return $ this ; }
12963	public function checkDbExists ( $ name ) { $ data = $ this -> query ( "SELECT COUNT(*) AS total FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '" . $ this -> escape ( $ name ) . "'" , true ) ; if ( isset ( $ data [ '0' ] [ 'total' ] ) && $ data [ '0' ] [ 'total' ] == '1' ) { return true ; } return false ; }
9710	private function writeWindow1 ( ) { $ record = 0x003D ; $ length = 0x0012 ; $ xWn = 0x0000 ; $ yWn = 0x0000 ; $ dxWn = 0x25BC ; $ dyWn = 0x1572 ; $ grbit = 0x0038 ; $ ctabsel = 1 ; $ wTabRatio = 0x0258 ; $ itabFirst = 0 ; $ itabCur = $ this -> spreadsheet -> getActiveSheetIndex ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvvvvvvv' , $ xWn , $ yWn , $ dxWn , $ dyWn , $ grbit , $ itabCur , $ itabFirst , $ ctabsel , $ wTabRatio ) ; $ this -> append ( $ header . $ data ) ; }
5102	public function asSelect ( ICmdSelect $ select ) { $ this -> setPart ( CmdInsert :: PART_VALUES , false ) ; return $ this -> setPart ( CmdInsert :: PART_AS , $ select -> assemble ( ) , $ select -> bind ( ) ) ; }
10823	public static function ask ( $ question , $ defaultValue = null , $ secret = false ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( $ secret ) { self :: write ( ' > ' ) ; if ( self :: $ testValue === null ) { system ( 'stty -echo' ) ; $ value = trim ( fgets ( STDIN ) ) ; system ( 'stty echo' ) ; } else { $ value = self :: $ testValue ; } } else { if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
12693	public function generate ( ) { $ templates = array_merge ( array_keys ( $ this -> templates [ "base" ] ) , array_keys ( $ this -> templates [ "template" ] ) ) ; foreach ( $ templates as $ template ) { $ templateDir = $ this -> themeDir . '/' . $ template ; if ( ! is_dir ( $ templateDir ) ) { continue ; } $ finder = new Finder ( ) ; $ files = $ finder -> files ( ) -> depth ( 0 ) -> in ( $ templateDir ) ; foreach ( $ files as $ file ) { $ file = ( string ) $ file ; $ slotName = basename ( $ file , '.json' ) ; $ json = FilesystemTools :: readFile ( $ file ) ; $ slot = json_decode ( $ json , true ) ; $ blocks = array ( ) ; if ( array_key_exists ( "blocks" , $ slot ) ) { $ blocks = $ slot [ "blocks" ] ; } $ slotManager = $ this -> slotsManagerFactory -> createSlotManager ( $ slot [ "repeat" ] ) ; $ slotManager -> addSlot ( $ slotName , $ blocks ) ; } } }
3267	protected function openFile ( int $ mode ) : SplFileObject { $ path = $ this -> getPath ( ) ; if ( ! is_file ( $ path ) && ! @ touch ( $ path ) ) { throw new Exception ( 'Could not create file: ' . $ path ) ; } if ( ! is_readable ( $ path ) || ! is_writable ( $ path ) ) { throw new Exception ( 'File does not have permission for read and write: ' . $ path ) ; } if ( $ this -> getConfig ( ) -> useGzip ( ) ) { $ path = 'compress.zlib://' . $ path ; } $ res = $ this -> fileAccessMode [ $ mode ] ; $ file = new SplFileObject ( $ path , $ res [ 'mode' ] ) ; if ( $ mode === self :: FILE_READ ) { $ file -> setFlags ( SplFileObject :: DROP_NEW_LINE | SplFileObject :: SKIP_EMPTY | SplFileObject :: READ_AHEAD ) ; } if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( $ res [ 'operation' ] ) ) { $ file = null ; throw new Exception ( 'Could not lock file: ' . $ path ) ; } return $ file ; }
7258	protected function mergeItemsResults ( Model \ SaleItemInterface $ item , Amount $ result ) : void { foreach ( $ item -> getChildren ( ) as $ child ) { if ( $ child -> isPrivate ( ) ) { continue ; } if ( ! ( $ child -> isCompound ( ) && ! $ child -> hasPrivateChildren ( ) ) ) { $ result -> merge ( $ child -> getResult ( ) ) ; } if ( $ child -> hasChildren ( ) ) { $ this -> mergeItemsResults ( $ child , $ result ) ; } } }
1623	public function buildCondition ( $ condition , & $ columns ) { static $ builders = [ 'not' => 'buildNotCondition' , 'and' => 'buildAndCondition' , 'or' => 'buildAndCondition' , 'between' => 'buildBetweenCondition' , 'not between' => 'buildBetweenCondition' , 'in' => 'buildInCondition' , 'not in' => 'buildInCondition' , 'like' => 'buildLikeCondition' , 'not like' => 'buildLikeCondition' , 'or like' => 'buildLikeCondition' , 'or not like' => 'buildLikeCondition' , '>' => 'buildCompareCondition' , '>=' => 'buildCompareCondition' , '<' => 'buildCompareCondition' , '<=' => 'buildCompareCondition' , ] ; if ( ! is_array ( $ condition ) ) { throw new NotSupportedException ( 'Where condition must be an array in redis ActiveRecord.' ) ; } if ( isset ( $ condition [ 0 ] ) ) { $ operator = strtolower ( $ condition [ 0 ] ) ; if ( isset ( $ builders [ $ operator ] ) ) { $ method = $ builders [ $ operator ] ; array_shift ( $ condition ) ; return $ this -> $ method ( $ operator , $ condition , $ columns ) ; } else { throw new Exception ( 'Found unknown operator in query: ' . $ operator ) ; } } else { return $ this -> buildHashCondition ( $ condition , $ columns ) ; } }
6059	public function retrieveMedia ( $ id , $ includeChildren = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeChildren' => $ includeChildren ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
12551	public function isSerialized ( ) { if ( ! is_string ( $ this -> serialized ) ) { return false ; } $ this -> serialized = trim ( $ this -> serialized ) ; if ( 'N;' == $ this -> serialized ) { return true ; } $ length = strlen ( $ this -> serialized ) ; if ( $ length < 4 ) { return false ; } if ( ':' !== $ this -> serialized [ 1 ] ) { return false ; } $ lastc = $ this -> serialized [ $ length - 1 ] ; if ( ';' !== $ lastc && '}' !== $ lastc ) { return false ; } $ token = $ this -> serialized [ 0 ] ; switch ( $ token ) { case 's' : if ( '"' !== $ this -> serialized [ $ length - 2 ] ) { return false ; } case 'a' : case 'O' : return ( bool ) preg_match ( "/^{$token}:[0-9]+:/s" , $ this -> serialized ) ; case 'b' : case 'i' : case 'd' : return ( bool ) preg_match ( "/^{$token}:[0-9.E-]+;\$/" , $ this -> serialized ) ; } return false ; }
3429	protected function propsMustBeSelected ( ) { return in_array ( 'PROPS' , $ this -> select ) || in_array ( 'PROPERTIES' , $ this -> select ) || in_array ( 'PROPERTY_VALUES' , $ this -> select ) ; }
11178	public function getApi ( ) { $ api = $ this -> get ( Keys :: EXT_API ) ; if ( is_array ( $ api ) ) { return $ api ; } return false ; }
6490	public function getDrupalSelector ( $ name ) { $ selectors = $ this -> getDrupalParameter ( 'selectors' ) ; if ( ! isset ( $ selectors [ $ name ] ) ) { throw new \ Exception ( sprintf ( 'No such selector configured: %s' , $ name ) ) ; } return $ selectors [ $ name ] ; }
2749	public function getVclFile ( $ vclTemplatePath ) { $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) ; $ configFilePath = $ moduleEtcPath . '/' . $ this -> _scopeConfig -> getValue ( self :: FASTLY_CONFIGURATION_PATH ) ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; $ configFilePath = $ directoryRead -> getRelativePath ( $ configFilePath ) ; $ data = $ directoryRead -> readFile ( $ configFilePath ) ; return strtr ( $ data , $ this -> getReplacements ( ) ) ; }
7154	protected function match ( $ role , $ action ) : bool { $ roles = $ actions = [ '*' ] ; $ allow = false ; if ( $ role != '*' ) array_unshift ( $ roles , $ role ) ; if ( $ action != '*' ) array_unshift ( $ actions , $ action ) ; foreach ( $ roles as $ _role ) { foreach ( $ actions as $ _action ) { if ( isset ( $ this -> _rules [ $ _role ] [ $ _action ] ) ) { $ allow = $ this -> _rules [ $ _role ] [ $ _action ] ; break 2 ; } } } return $ allow === true ; }
1353	protected function invalid ( ) : Collection { if ( ! is_array ( $ this -> value ) ) { return collect ( ) ; } return collect ( $ this -> value ) -> map ( function ( $ value , $ key ) { return $ this -> notAllowed ( $ key , $ value ) ; } ) -> flatMap ( function ( Collection $ fields , $ type ) { return $ fields -> map ( function ( $ field ) use ( $ type ) { return "{$type}.{$field}" ; } ) ; } ) ; }
12928	public function update ( $ poiId , array $ data ) { $ data = array_merge ( $ data , [ 'poi_id' => $ poiId ] ) ; $ params = [ 'business' => [ 'base_info' => $ data ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
4278	public function stream_read ( $ count ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ buffer = \ fread ( $ this -> handle , $ count ) ; $ bufferLen = \ strlen ( $ buffer ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS , 2 ) ; $ isRequire = ! \ in_array ( $ backtrace [ 1 ] [ 'function' ] , array ( 'file_get_contents' ) ) ; if ( ! $ this -> declaredTicks && $ isRequire ) { foreach ( self :: $ pathsExclude as $ excludePath ) { if ( \ strpos ( $ this -> filepath , $ excludePath . DIRECTORY_SEPARATOR ) === 0 ) { $ this -> declaredTicks = true ; } } } if ( ! $ this -> declaredTicks && $ isRequire ) { $ buffer = \ preg_replace ( '/^(<\?php\s*)$/m' , '$0 declare(ticks=1);' , $ buffer , 1 ) ; $ this -> declaredTicks = true ; self :: $ filesModified [ ] = $ this -> filepath ; } $ buffer = $ this -> bufferPrepend . $ buffer ; $ bufferLenAfter = \ strlen ( $ buffer ) ; $ diff = $ bufferLenAfter - $ bufferLen ; $ this -> bufferPrepend = '' ; if ( $ diff ) { $ this -> bufferPrepend = \ substr ( $ buffer , $ count ) ; $ buffer = \ substr ( $ buffer , 0 , $ count ) ; } self :: register ( ) ; return $ buffer ; }
315	public function setVendorPath ( $ path ) { $ this -> _vendorPath = Yii :: getAlias ( $ path ) ; Yii :: setAlias ( '@vendor' , $ this -> _vendorPath ) ; Yii :: setAlias ( '@bower' , $ this -> _vendorPath . DIRECTORY_SEPARATOR . 'bower' ) ; Yii :: setAlias ( '@npm' , $ this -> _vendorPath . DIRECTORY_SEPARATOR . 'npm' ) ; }
9898	private function convertFunction ( $ token , $ num_args ) { $ args = $ this -> functions [ $ token ] [ 1 ] ; if ( $ args >= 0 ) { return pack ( 'Cv' , $ this -> ptg [ 'ptgFuncV' ] , $ this -> functions [ $ token ] [ 0 ] ) ; } if ( $ args == - 1 ) { return pack ( 'CCv' , $ this -> ptg [ 'ptgFuncVarV' ] , $ num_args , $ this -> functions [ $ token ] [ 0 ] ) ; } }
615	protected function resolveDependencies ( $ dependencies , $ reflection = null ) { foreach ( $ dependencies as $ index => $ dependency ) { if ( $ dependency instanceof Instance ) { if ( $ dependency -> id !== null ) { $ dependencies [ $ index ] = $ this -> get ( $ dependency -> id ) ; } elseif ( $ reflection !== null ) { $ name = $ reflection -> getConstructor ( ) -> getParameters ( ) [ $ index ] -> getName ( ) ; $ class = $ reflection -> getName ( ) ; throw new InvalidConfigException ( "Missing required parameter \"$name\" when instantiating \"$class\"." ) ; } } } return $ dependencies ; }
7645	protected function getStorageClient ( $ path = '' ) { if ( is_null ( $ this -> storageClient ) ) { $ url = explode ( ':' , $ path ) ; if ( ! $ url ) { throw new BlobException ( 'Could not parse path "' . $ path . '".' ) ; } $ this -> storageClient = BlobClient :: getWrapperClient ( $ url [ 0 ] ) ; if ( ! $ this -> storageClient ) { throw new BlobException ( 'No storage client registered for stream type "' . $ url [ 0 ] . '://".' ) ; } } return $ this -> storageClient ; }
5182	private function fillSource ( $ source , $ photo ) : string { if ( ! empty ( $ source ) ) { return $ this -> filterUriInstance ( $ source ) ; } return ( string ) $ photo ; }
974	public function handle ( Request $ request , Closure $ next ) { $ hmac = $ request -> header ( 'x-shopify-hmac-sha256' ) ? : '' ; $ shop = $ request -> header ( 'x-shopify-shop-domain' ) ; $ data = $ request -> getContent ( ) ; $ hmacLocal = ShopifyApp :: createHmac ( [ 'data' => $ data , 'raw' => true , 'encode' => true ] ) ; if ( ! hash_equals ( $ hmac , $ hmacLocal ) || empty ( $ shop ) ) { return Response :: make ( 'Invalid webhook signature.' , 401 ) ; } return $ next ( $ request ) ; }
10996	public function prepend ( string $ contents , int $ maxMemory = 8096 ) : bool { $ test = \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE | \ sndsgd \ Fs :: WRITABLE ; if ( $ this -> test ( $ test ) === false ) { $ this -> error = "failed to prepend file; {$this->error}" ; return false ; } $ len = strlen ( $ contents ) ; $ size = filesize ( $ this -> path ) ; $ endsize = $ len + $ size ; if ( $ endsize > $ maxMemory ) { return $ this -> prependFileInPlace ( $ contents , $ len , $ endsize ) ; } if ( ( $ tmp = $ this -> readFile ( 0 ) ) === false ) { return false ; } if ( $ this -> writeFile ( $ contents . $ tmp , 0 ) === false ) { return false ; } return true ; }
1551	protected function requiresInverseAdapter ( $ record , EncodingParametersInterface $ parameters ) { return ! empty ( $ parameters -> getFilteringParameters ( ) ) || ! empty ( $ parameters -> getSortParameters ( ) ) || ! empty ( $ parameters -> getPaginationParameters ( ) ) || ! empty ( $ parameters -> getIncludePaths ( ) ) ; }
5418	public function writeCookiesToJar ( $ jar , $ url ) { foreach ( $ this -> cookies as $ cookie ) { $ jar -> setCookie ( $ cookie -> getName ( ) , $ cookie -> getValue ( ) , $ url -> getHost ( ) , $ cookie -> getPath ( ) , $ cookie -> getExpiry ( ) ) ; } }
1711	public function setEmptyEndTime ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue === null ) { $ varValue = $ dc -> activeRecord -> startTime ; } return $ varValue ; }
6079	public function combineSlides ( array $ structure ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'structure' => $ structure ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/slides/combine' , $ parameters ) ; return $ result ; }
8323	public function addPingback ( $ url ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=add_pingback&addr={$url}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
8910	private function getCallableFunction ( $ method ) { if ( is_callable ( $ method ) ) { return $ method ; } if ( is_string ( $ method ) && is_callable ( array ( $ this , $ method ) ) ) { return array ( $ this , $ method ) ; } return FALSE ; }
7486	public function indexOf ( $ string , $ offset = null ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ offset = $ offset !== null ? ( int ) $ offset : null ; if ( $ offset !== null && ( $ offset < 0 || $ offset >= $ this -> length ( ) ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_strpos ( $ this -> string , $ string , $ offset , $ this -> encoding ) ; }
10121	private function writeMarginBottom ( ) { $ record = 0x0029 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getBottom ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
7910	public function init ( ) { parent :: init ( ) ; Html :: addCssClass ( $ this -> options , 'ui' ) ; if ( ! isset ( $ this -> options [ 'id' ] ) ) { $ this -> options [ 'id' ] = $ this -> getId ( ) ; } $ this -> registerTranslations ( ) ; }
5255	public function makePagination ( QueryBuilder $ query = null ) { if ( is_null ( $ this -> _position ) ) { throw new Exception ( 'To use Paginationable trait you must fill _position property in your model' ) ; } $ model = static :: createInstance ( ) ; $ query = $ query ? : new QueryBuilder ( ) ; $ prevDoc = null ; $ nextDoc = null ; $ query -> fields ( ) ; $ prevPos = $ this -> _position - 1 ; if ( $ prevPos >= 0 ) { $ items = $ model -> search ( $ query -> from ( $ prevPos ) -> size ( 3 ) ) ; $ prevDoc = $ items -> first ( ) ; $ items = array_values ( $ items -> toArray ( ) ) ; if ( array_key_exists ( 2 , $ items ) ) { $ nextDoc = $ items [ 2 ] ; } } else { $ items = $ model -> search ( $ query -> from ( $ this -> _position ) -> size ( 2 ) ) ; $ total = $ items -> getTotal ( ) ; $ nextDoc = $ items -> last ( ) ; $ last = $ total - 1 ; $ items = $ model -> search ( $ query -> from ( $ last ) -> size ( 1 ) ) ; $ prevDoc = $ items -> first ( ) ; } if ( ! $ nextDoc ) { $ items = $ model -> search ( $ query -> from ( 0 ) -> size ( 1 ) ) ; $ nextDoc = $ items -> first ( ) ; } $ this -> _previous = $ prevDoc ; $ this -> _next = $ nextDoc ; }
4404	public function getPath ( $ locationId ) { $ pathArray = array ( ) ; $ startingLocation = $ this -> locationService -> loadLocation ( $ locationId ) ; $ path = $ startingLocation -> path ; array_shift ( $ path ) ; $ rootLocationFound = false ; foreach ( $ path as $ index => $ pathItem ) { if ( ( int ) $ pathItem === $ this -> rootLocationId ) { $ rootLocationFound = true ; } if ( ! $ rootLocationFound ) { continue ; } try { $ location = $ this -> locationService -> loadLocation ( $ pathItem ) ; } catch ( UnauthorizedException $ e ) { return array ( ) ; } $ pathArray [ ] = array ( 'text' => $ this -> translationHelper -> getTranslatedContentNameByContentInfo ( $ location -> contentInfo ) , 'url' => $ location -> id !== $ startingLocation -> id ? $ this -> router -> generate ( $ location ) : false , 'locationId' => $ location -> id , 'contentId' => $ location -> contentId , ) ; } return $ pathArray ; }
6354	public static function setFakeTime ( $ fakeTime ) { if ( is_string ( $ fakeTime ) ) { $ fakeTime = ( int ) static :: convert ( TS_UNIX , $ fakeTime ) ; } if ( is_int ( $ fakeTime ) ) { $ fakeTime = function ( ) use ( $ fakeTime ) { return $ fakeTime ; } ; } $ old = static :: $ fakeTimeCallback ; static :: $ fakeTimeCallback = $ fakeTime ? $ fakeTime : null ; return $ old ; }
212	protected function initClientOptions ( ) { $ options = $ this -> clientOptions ; foreach ( $ options as $ key => $ value ) { if ( ! $ value instanceof JsExpression && in_array ( $ key , [ 'oncomplete' , 'onincomplete' , 'oncleared' , 'onKeyUp' , 'onKeyDown' , 'onBeforeMask' , 'onBeforePaste' , 'onUnMask' , 'isComplete' , 'determineActiveMasksetIndex' , ] , true ) ) { $ options [ $ key ] = new JsExpression ( $ value ) ; } } $ this -> clientOptions = $ options ; }
5878	protected static function updateIndex ( \ TYPO3 \ CMS \ Core \ Resource \ File $ file = null , $ width , $ height , array $ metadata = [ ] ) { if ( count ( $ metadata ) > 0 ) { $ metadataRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ Index \ MetaDataRepository :: class ) ; $ currentMetadata = $ metadataRepository -> findByFile ( $ file ) ; $ newMetadata = [ ] ; foreach ( $ currentMetadata as $ key => $ value ) { if ( ! empty ( $ metadata [ $ key ] ) ) { if ( $ key === 'creator_tool' && MathUtility :: canBeInterpretedAsFloat ( $ metadata [ $ key ] ) ) { continue ; } $ newMetadata [ $ key ] = $ metadata [ $ key ] ; } } unset ( $ newMetadata [ 'width' ] ) ; unset ( $ newMetadata [ 'height' ] ) ; $ newMetadata [ 'unit' ] = 'px' ; $ mapping = [ 'color_space' => 'ColorSpace' , 'content_creation_date' => 'DateTimeOriginal' , 'creator' => 'IPTCCreator|Company' , 'creator_tool' => 'Model|Make|Software' , 'description' => 'ImageDescription' , 'keywords' => 'IPTCKeywords' , 'latitude' => 'GPSLatitudeDecimal' , 'longitude' => 'GPSLongitudeDecimal' , 'location_city' => 'IPTCCity' , 'location_country' => 'IPTCCountry' , 'location_region' => 'IPTCRegion' , 'note' => 'IPTCLocation' , 'publisher' => 'IPTCCredit' , 'source' => 'IPTCSource' , 'title' => 'IPTCTitle' , ] ; foreach ( $ mapping as $ falKey => $ metadataKeyMapping ) { if ( ! empty ( $ newMetadata [ $ falKey ] ) ) { continue ; } $ metatadaKeys = explode ( '|' , $ metadataKeyMapping ) ; foreach ( $ metatadaKeys as $ metadataKey ) { $ value = null ; if ( isset ( $ metadata [ $ metadataKey ] ) ) { $ value = trim ( $ metadata [ $ metadataKey ] ) ; if ( ord ( $ value ) === 1 ) $ value = null ; switch ( $ metadataKey ) { case 'ColorSpace' : if ( $ value == 1 ) { $ value = 'RGB' ; } else { $ value = null ; } break ; case 'DateTimeOriginal' : $ value = strtotime ( $ value ) ; break ; } } if ( ! empty ( $ value ) ) { $ newMetadata [ $ falKey ] = $ value ; break ; } } } $ metadataRepository -> update ( $ file -> getUid ( ) , $ newMetadata ) ; } }
5058	public function generate ( $ subject , $ status , $ color , $ format ) { $ badge = new Badge ( $ subject , $ status , $ color , $ format ) ; return $ this -> getRenderFor ( $ badge -> getFormat ( ) ) -> render ( $ badge ) ; }
8081	public function error ( $ message ) { if ( $ message ) { if ( is_int ( $ message ) && isset ( $ this -> errorList [ $ message ] ) ) { $ errorMessage = $ this -> errorList [ $ message ] ; $ this -> report ( "Error[{$message}]: {$errorMessage}" ) ; } else { $ errorMessage = $ message ; $ this -> report ( "Error: {$errorMessage}" ) ; } $ errors = & $ this -> getErrors ( ) ; $ errors [ ] = $ errorMessage ; } return $ this ; }
11974	private function firstParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( is_numeric ( $ params [ 0 ] ) && $ params [ 0 ] > 0 && $ params [ 0 ] <= $ this -> maxDieRolls ) ; }
3633	public function pools ( Request $ request ) : array { if ( $ name = $ request -> query ( 'name' ) ) { if ( ! App :: hasPool ( $ name ) ) { return [ ] ; } $ poolConfig = App :: getPool ( $ name ) -> getPoolConfig ( ) ; return $ poolConfig -> toArray ( ) ; } return PoolCollector :: getCollector ( ) ; }
10853	public function setLimit ( $ num , $ offset = 0 ) { $ this -> limit = ( int ) $ num ; $ this -> offset = ( int ) $ offset ; }
2211	public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ arrReturn = array ( ) ; while ( ( $ arrRow = $ this -> fetchAssoc ( ) ) !== false ) { if ( $ strKey != 'id' && isset ( $ arrRow [ 'id' ] ) ) { $ arrReturn [ $ arrRow [ 'id' ] ] = $ arrRow [ $ strKey ] ; } else { $ arrReturn [ ] = $ arrRow [ $ strKey ] ; } } return $ arrReturn ; }
144	public function insert ( RuleWatchNode $ node ) { if ( $ node -> getRule ( ) -> isAssertion ( ) ) { return ; } foreach ( array ( $ node -> watch1 , $ node -> watch2 ) as $ literal ) { if ( ! isset ( $ this -> watchChains [ $ literal ] ) ) { $ this -> watchChains [ $ literal ] = new RuleWatchChain ; } $ this -> watchChains [ $ literal ] -> unshift ( $ node ) ; } }
8316	public function startPasswordResetSession ( $ user ) { $ this -> session -> migrate ( true ) ; $ this -> session -> set ( "pwreset" , array ( 'user' => $ user , 'validity' => time ( ) + $ this -> config [ "resetTimeout" ] ) ) ; }
10604	public function setQueryParam ( $ name , $ value ) { if ( $ this -> checkQuery ( $ name ) ) { $ this -> editQuery ( $ name , $ value ) ; } else { $ this -> addQuery ( $ name , $ value ) ; } return $ this ; }
5504	public function getCallCount ( $ method ) { $ this -> dieOnNoMethod ( $ method , 'get call count' ) ; $ method = strtolower ( $ method ) ; if ( ! isset ( $ this -> call_counts [ $ method ] ) ) { return 0 ; } return $ this -> call_counts [ $ method ] ; }
7438	public static function handleException ( \ Throwable $ e ) { self :: render ( $ e -> getCode ( ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) , null , $ e -> getTrace ( ) , get_class ( $ e ) ) ; }
8339	public static function get ( string $ fileName ) : array { if ( isset ( self :: $ files [ $ fileName ] ) === false ) { if ( ( $ content = file_get_contents ( $ fileName ) ) === false ) { throw new FileNotReadable ( 'file "' . $ fileName . '" can\'t be read' ) ; } $ content = ( string ) $ content ; try { $ content = Yaml :: parse ( $ content ) ; } catch ( ParseException $ e ) { throw new FileNotParsable ( 'file "' . $ fileName . '" can\'t be parsed' ) ; } self :: $ files [ $ fileName ] = $ content ; } return self :: $ files [ $ fileName ] ; }
6806	public function create ( string $ locale = null , string $ currency = null ) { $ locale = $ locale ?? $ this -> localeProvider -> getCurrentLocale ( ) ; $ currency = $ currency ?? $ this -> currencyProvider -> getCurrentCurrency ( ) ; if ( isset ( $ this -> cache [ $ key = strtolower ( "$locale-$currency" ) ] ) ) { return $ this -> cache [ $ key ] ; } return $ this -> cache [ $ key ] = new Formatter ( $ locale , $ currency ) ; }
4267	public function dir_closedir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; \ closedir ( $ this -> handle ) ; self :: register ( ) ; $ this -> handle = null ; return true ; }
888	private function isStrictOrNullableReturnTypeFunction ( Tokens $ tokens , $ returnIndex ) { $ functionIndex = $ returnIndex ; do { $ functionIndex = $ tokens -> getPrevTokenOfKind ( $ functionIndex , [ [ T_FUNCTION ] ] ) ; if ( null === $ functionIndex ) { return false ; } $ openingCurlyBraceIndex = $ tokens -> getNextTokenOfKind ( $ functionIndex , [ '{' ] ) ; $ closingCurlyBraceIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ openingCurlyBraceIndex ) ; } while ( $ closingCurlyBraceIndex < $ returnIndex ) ; $ possibleVoidIndex = $ tokens -> getPrevMeaningfulToken ( $ openingCurlyBraceIndex ) ; $ isStrictReturnType = $ tokens [ $ possibleVoidIndex ] -> isGivenKind ( T_STRING ) && 'void' !== $ tokens [ $ possibleVoidIndex ] -> getContent ( ) ; $ nullableTypeIndex = $ tokens -> getNextTokenOfKind ( $ functionIndex , [ [ CT :: T_NULLABLE_TYPE ] ] ) ; $ isNullableReturnType = null !== $ nullableTypeIndex && $ nullableTypeIndex < $ openingCurlyBraceIndex ; return $ isStrictReturnType || $ isNullableReturnType ; }
12467	public function renderFormAction ( $ id , Request $ request ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ entity = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ id ) ; if ( ! $ entity ) { throw $ this -> createNotFoundException ( 'Unable to find CustomFieldsGroups entity.' ) ; } $ form = $ this -> createForm ( 'custom_field' , null , array ( 'group' => $ entity ) ) ; $ form -> add ( 'submit_dump' , 'submit' , array ( 'label' => 'POST AND DUMP' ) ) ; $ form -> add ( 'submit_render' , 'submit' , array ( 'label' => 'POST AND RENDER' ) ) ; $ form -> handleRequest ( $ request ) ; $ this -> get ( 'twig.loader' ) -> addPath ( __DIR__ . '/../Tests/Fixtures/App/app/Resources/views/' , $ namespace = 'test' ) ; if ( $ form -> isSubmitted ( ) ) { if ( $ form -> get ( 'submit_render' ) -> isClicked ( ) ) { return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:render_for_test.html.twig' , array ( 'fields' => $ form -> getData ( ) , 'customFieldsGroup' => $ entity ) ) ; } var_dump ( $ form -> getData ( ) ) ; var_dump ( json_enccode ( $ form -> getData ( ) ) ) ; } return $ this -> render ( '@test/CustomField/simple_form_render.html.twig' , array ( 'form' => $ form -> createView ( ) ) ) ; }
7670	function ServerHostname ( ) { if ( $ this -> Hostname != "" ) $ result = $ this -> Hostname ; elseif ( $ this -> ServerVar ( 'SERVER_NAME' ) != "" ) $ result = $ this -> ServerVar ( 'SERVER_NAME' ) ; else $ result = "localhost.localdomain" ; return $ result ; }
9479	public function respondWithMessage ( $ message = null ) { $ res [ 'status' ] = $ this -> getStatusText ( ) ; if ( $ this -> getErrorCode ( ) ) { $ res [ 'error' ] = $ this -> getErrorCode ( ) ; if ( is_null ( $ message ) ) $ res [ 'message' ] = $ this -> getErrorMessage ( ) ; else $ res [ 'message' ] = $ message ; } else { $ res [ 'message' ] = $ message ; } return $ this -> respond ( $ res ) ; }
10741	protected function buildRecord ( ) { $ res = [ ] ; foreach ( $ this -> clause_records as $ tbl ) { $ res [ ] = $ this -> quote ( $ tbl ) . '.*' ; } if ( ! empty ( $ res ) ) { return [ join ( ', ' , $ res ) ] ; } else { return [ ] ; } }
3419	protected static function instantiateServiceContainer ( ) { $ container = Container :: getInstance ( ) ; if ( ! $ container ) { $ container = new Container ( ) ; Container :: setInstance ( $ container ) ; } return $ container ; }
5741	protected static function prefixData ( $ data ) { $ prefixedData = array ( ) ; foreach ( $ data as $ stat => $ value ) { $ prefixedKey = self :: prefix ( $ stat ) ; $ prefixedData [ $ prefixedKey ] = $ value ; } return $ prefixedData ; }
10070	public function make ( $ tag , $ props = null , $ content = null ) { $ tag = parent :: make ( $ tag , $ props , $ content ) ; $ tag = $ this -> decorators -> apply ( $ tag , $ this ) ; return $ tag ; }
3020	public function getBlogInfo ( $ blogName ) { $ path = $ this -> blogPath ( $ blogName , '/info' ) ; return $ this -> getRequest ( $ path , null , true ) ; }
5840	protected function crop ( Builder $ url , $ args ) { $ url -> crop ( $ args [ 'top_left_x' ] , $ args [ 'top_left_y' ] , $ args [ 'bottom_right_x' ] , $ args [ 'bottom_right_y' ] ) ; }
10855	public function getLocationString ( ) { $ normalized = '' ; if ( $ this -> city !== null ) { $ normalized .= $ this -> city -> name ; } if ( $ this -> region !== null ) { $ normalized .= ' ' . $ this -> region -> name ; } if ( $ this -> postal_code !== null ) { $ normalized .= ' ' . $ this -> postal_code ; } return $ normalized ; }
11498	public static function locate ( $ column , $ value ) { $ table = new static ( ) ; $ select = $ table -> select ( ) -> where ( "{$table->getAdapter()->quoteIdentifier($column)} = ?" , $ value ) -> limit ( 1 ) ; return $ table -> fetchRow ( $ select ) ; }
11673	public function offsetExists ( $ offset ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( array_key_exists ( $ offset , $ this -> result ) ) { return true ; } else { return false ; } }
3001	public function setHTML ( $ message ) { $ f3 = \ Base :: instance ( ) ; $ tmpl = new \ Template ( ) ; if ( $ f3 -> exists ( 'mailer.jumplinks' , $ jumplink ) && $ jumplink ) $ tmpl -> extend ( 'a' , function ( $ node ) use ( $ f3 , $ tmpl ) { if ( isset ( $ node [ '@attrib' ] ) ) { $ attr = $ node [ '@attrib' ] ; unset ( $ node [ '@attrib' ] ) ; } else $ attr = array ( ) ; if ( isset ( $ attr [ 'href' ] ) ) { if ( ! $ f3 -> exists ( 'mailer.jump_route' , $ ping_route ) ) $ ping_route = '/mailer-jump' ; $ attr [ 'href' ] = $ f3 -> get ( 'SCHEME' ) . '://' . $ f3 -> get ( 'HOST' ) . $ f3 -> get ( 'BASE' ) . $ ping_route . '?target=' . urlencode ( $ attr [ 'href' ] ) ; } $ params = '' ; foreach ( $ attr as $ key => $ value ) $ params .= ' ' . $ key . '="' . $ value . '"' ; return '<a' . $ params . '>' . $ tmpl -> build ( $ node ) . '</a>' ; } ) ; $ message = $ tmpl -> build ( $ tmpl -> parse ( $ message ) ) ; $ this -> setContent ( $ message , 'text/html' ) ; }
12422	public function getAll ( $ domain ) { $ messages = [ ] ; $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { $ messages = $ messages + ( array ) $ object -> getMessages ( $ domain , $ locale ) ; } return $ messages ; }
6085	public function retrieveMoodboard ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/moodboards/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
4422	protected function interact ( InputInterface $ input , OutputInterface $ output ) { $ this -> input = $ input ; $ this -> output = $ output ; $ this -> questionHelper = $ this -> getHelper ( 'question' ) ; if ( Kernel :: VERSION_ID < 20700 ) { throw new RuntimeException ( 'Installation is not possible. Netgen Admin UI requires Symfony 2.7 or later to work.' ) ; } if ( ! $ this -> getContainer ( ) -> hasParameter ( 'ezpublish_legacy.root_dir' ) ) { throw new RuntimeException ( sprintf ( "%s\n%s" , 'Installation is not possible because eZ Publish Legacy is not present.' , 'Netgen Admin UI requires eZ Publish Community 2014.12 (Netgen Variant), eZ Publish 5.4.x or eZ Platform with Legacy Bridge to work.' ) ) ; } $ this -> writeSection ( 'Welcome to the Netgen Admin UI installation' ) ; while ( ! $ this -> doInteract ( ) ) { } return 0 ; }
8531	public function listFinancialEventsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsByNextTokenRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsByNextTokenResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
9161	private function addParsedHeader ( $ line ) { if ( strpos ( $ line , ':' ) === false ) { $ this -> responseCode = HttpStatus :: parseStatus ( $ line ) -> getCode ( ) ; } else { $ line = trim ( $ line ) ; list ( $ headerName , $ headerValue ) = explode ( ':' , $ line , 2 ) ; $ this -> headers [ $ headerName ] = trim ( $ headerValue ) ; } }
11449	public function fill ( array $ attributes ) { if ( $ this -> getFieldManager ( ) ) { $ attributes = $ this -> getFieldManager ( ) -> transformToResource ( $ attributes ) ; } return parent :: fill ( $ attributes ) ; }
730	public function run ( ) { if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id ) ; } $ model = new $ this -> modelClass ( [ 'scenario' => $ this -> scenario , ] ) ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> setStatusCode ( 201 ) ; $ id = implode ( ',' , array_values ( $ model -> getPrimaryKey ( true ) ) ) ; $ response -> getHeaders ( ) -> set ( 'Location' , Url :: toRoute ( [ $ this -> viewAction , 'id' => $ id ] , true ) ) ; } elseif ( ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to create the object for unknown reason.' ) ; } return $ model ; }
8464	public static function getDomain ( $ url = false ) { if ( $ url ) { preg_match ( '/([\w]+[.]){1,}[a-z]+/' , $ url , $ matches ) ; return isset ( $ matches [ 0 ] ) ? $ matches [ 0 ] : false ; } return $ _SERVER [ 'SERVER_NAME' ] ; }
12470	protected function setAppConfigNamespaces ( ) { $ search = [ $ this -> currentRoot . '\\Providers' , $ this -> currentRoot . '\\Http\\Controllers\\' ] ; $ replace = [ $ this -> argument ( 'name' ) . '\\Providers' , $ this -> argument ( 'name' ) . '\\Http\\Controllers\\' ] ; }
11417	public function addPiwikCode ( ViewEvent $ event ) { $ model = $ event -> getModel ( ) ; if ( ! $ model instanceof \ Zend \ View \ Model \ ViewModel ) { return ; } $ options = $ model -> getOptions ( ) ; if ( array_key_exists ( 'has_parent' , $ options ) && $ options [ 'has_parent' ] ) { return ; } $ renderer = $ event -> getRenderer ( ) ; if ( ! $ renderer instanceof \ Zend \ View \ Renderer \ PhpRenderer ) { return ; } $ config = $ this -> serviceManager -> get ( 'config' ) ; $ piwikConfig = $ config [ 'orgHeiglPiwik' ] ; $ code = str_replace ( array_map ( function ( $ e ) { return '%%' . $ e . '%%' ; } , array_keys ( $ piwikConfig ) ) , array_values ( $ piwikConfig ) , $ this -> template ) ; $ renderer -> headScript ( ) -> appendScript ( '//<![CDATA[' . "\n" . $ code . "\n" . '//]]>' ) ; return $ renderer ; }
8628	public static function fromXML ( $ xml ) { $ dom = new DOMDocument ( ) ; $ dom -> loadXML ( $ xml ) ; $ xpath = new DOMXPath ( $ dom ) ; $ response = $ xpath -> query ( "//*[local-name()='GetCompetitivePricingForSKUResponse']" ) ; if ( $ response -> length == 1 ) { return new MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse ( ( $ response -> item ( 0 ) ) ) ; } else { throw new Exception ( "Unable to construct MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse from provided XML. Make sure that GetCompetitivePricingForSKUResponse is a root element" ) ; } }
6856	protected static function equinoxMarch ( $ year , $ vsop = true ) { $ month = 3 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
1170	protected function createProtectedCaller ( $ instance ) { $ closure = function ( $ method , $ args ) { $ callable = [ $ this , $ method ] ; return call_user_func_array ( $ callable , $ args ) ; } ; return $ closure -> bindTo ( $ instance , $ instance ) ; }
5807	public function onAfterWrite ( ) { parent :: onAfterWrite ( ) ; $ write = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ write = $ field ; } } $ changed = $ this -> owner -> getChangedFields ( ) ; $ existing = FusionTag :: get ( ) -> filter ( 'Title' , $ this -> owner -> $ write ) -> first ( ) ; if ( is_null ( $ this -> owner -> FusionTagID ) && ! $ existing ) { $ fusion = FusionTag :: create ( ) ; $ fusion -> Title = $ this -> owner -> $ write ; $ fusion -> TagTypes = serialize ( array ( $ class => $ class ) ) ; $ fusion -> write ( ) ; $ this -> owner -> FusionTagID = $ fusion -> ID ; $ this -> owner -> write ( ) ; } else if ( is_null ( $ this -> owner -> FusionTagID ) && $ existing ) { $ types = unserialize ( $ existing -> TagTypes ) ; $ types [ $ class ] = $ class ; $ existing -> TagTypes = serialize ( $ types ) ; $ existing -> write ( ) ; $ this -> owner -> FusionTagID = $ existing -> ID ; $ this -> owner -> write ( ) ; } else if ( isset ( $ changed [ $ write ] ) && ! isset ( $ changed [ 'FusionTagID' ] ) && $ existing && ( $ existing -> ID != $ this -> owner -> FusionTagID ) ) { $ fusion = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ; $ types = unserialize ( $ fusion -> TagTypes ) ; unset ( $ types [ $ this -> owner -> ClassName ] ) ; $ fusion -> TagTypes = ! empty ( $ types ) ? serialize ( $ types ) : null ; $ fusion -> write ( ) ; $ types = unserialize ( $ existing -> TagTypes ) ; $ types [ $ class ] = $ class ; $ existing -> TagTypes = serialize ( $ types ) ; $ existing -> write ( ) ; $ this -> owner -> FusionTagID = $ existing -> ID ; $ this -> owner -> write ( ) ; } else if ( isset ( $ changed [ $ write ] ) && ! isset ( $ changed [ 'FusionTagID' ] ) && ( $ existing = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ) ) { $ existing -> Title = $ changed [ $ write ] [ 'after' ] ; $ existing -> write ( ) ; } }
11143	public function run ( ) { $ list = $ this -> getClassList ( ) ; $ directCollection = new DirectCollection ( ) ; foreach ( $ list as $ class ) { $ cl = $ this -> processClass ( $ class ) ; if ( $ cl !== false ) { $ directCollection -> add ( $ cl ) ; } } return $ directCollection ; }
1349	public function any ( string ... $ resourceTypes ) : self { foreach ( $ resourceTypes as $ resourceType ) { $ this -> allow ( $ resourceType , null ) ; } return $ this ; }
7043	public function handleSrcTableNames ( GetPropertyOptionsEvent $ event ) { if ( ( $ event -> getPropertyName ( ) !== 'tag_srctable' ) || ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_attribute' ) ) { return ; } $ sqlTable = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.sql-table' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ translated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.translated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ untranslated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.untranslated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ result = $ this -> getMetaModelTableNames ( $ translated , $ untranslated ) ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableNames ( ) as $ table ) { if ( 0 !== \ strpos ( $ table , 'mm_' ) ) { $ result [ $ sqlTable ] [ $ table ] = $ table ; } } if ( \ is_array ( $ result [ $ translated ] ) ) { \ asort ( $ result [ $ translated ] ) ; } if ( \ is_array ( $ result [ $ untranslated ] ) ) { \ asort ( $ result [ $ untranslated ] ) ; } if ( \ is_array ( $ result [ $ sqlTable ] ) ) { \ asort ( $ result [ $ sqlTable ] ) ; } $ event -> setOptions ( $ result ) ; }
7054	public function message_id_header ( $ headers , $ iac_options , $ item_ID ) { $ type = ( 'iac_comment_headers' == current_filter ( ) ) ? 'comment' : 'post' ; $ item = ( 'post' == $ type ) ? get_post ( $ item_ID ) : get_comment ( $ item_ID ) ; $ headers [ 'Message-ID' ] = '<' . Iac_Mail_ID :: generate_ID ( $ type , $ item ) . '>' ; return $ headers ; }
4322	public static function buildAttribString ( $ attribs ) { if ( \ is_string ( $ attribs ) ) { return \ rtrim ( ' ' . \ trim ( $ attribs ) ) ; } $ attribPairs = array ( ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_int ( $ k ) ) { $ k = $ v ; $ v = true ; } $ k = \ strtolower ( $ k ) ; if ( \ strpos ( $ k , 'data-' ) === 0 ) { $ v = \ json_encode ( $ v ) ; $ v = \ trim ( $ v , '"' ) ; } elseif ( \ is_bool ( $ v ) ) { $ v = self :: buildAttribBoolVal ( $ k , $ v ) ; } elseif ( \ is_array ( $ v ) || $ k === 'class' ) { $ v = self :: buildAttribArrayVal ( $ k , $ v ) ; } if ( \ array_filter ( array ( $ v === null , $ v === '' && \ in_array ( $ k , array ( 'class' , 'style' ) ) ) ) ) { continue ; } $ v = \ trim ( $ v ) ; $ attribPairs [ ] = $ k . '="' . \ htmlspecialchars ( $ v ) . '"' ; } \ sort ( $ attribPairs ) ; return \ rtrim ( ' ' . \ implode ( ' ' , $ attribPairs ) ) ; }
9280	public function deleteByWhere ( $ where = null , array $ options = array ( ) ) { $ delete = $ this -> sql -> delete ( ) ; if ( $ where instanceof Where ) { $ delete -> where ( $ where ) ; } elseif ( is_string ( $ where ) && ! empty ( $ where ) ) { $ delete -> where ( $ where ) ; } $ delete -> where ( $ where ) ; $ limit = array_key_exists ( 'limit' , $ options ) ? ( int ) $ limit : null ; if ( ! is_null ( $ limit ) && ( int ) $ limit > 0 ) { $ delete -> limit ( $ limit ) ; } $ stmt = $ this -> sql -> prepareStatementForSqlObject ( $ delete ) ; return $ stmt -> execute ( ) ; }
4147	protected function getResponse ( ) { $ url = $ this -> getUrl ( ) ; $ params = array ( 'get' => $ this -> getParams , 'post' => $ this -> postParams , 'headers' => $ this -> buildRequestHeader ( ) , ) ; return $ this -> curl -> send ( $ url , $ params ) ; }
7813	public static function toGregorianStr ( $ j_date , $ sep = '/' ) { $ arr = explode ( $ sep , $ j_date ) ; if ( count ( $ arr ) < 3 || intval ( $ arr [ 0 ] ) == 0 ) return "" ; else $ g_date = jDateTime :: toGregorian ( $ arr [ 2 ] , $ arr [ 1 ] , $ arr [ 0 ] ) ; return implode ( $ sep , $ g_date ) ; }
6260	public function getControllerNameAndAction ( Request $ request ) { $ controller = $ this -> _registry -> getController ( ) ; $ name = $ controller -> name ; $ action = $ request -> action ; if ( ! empty ( $ request -> params [ 'plugin' ] ) ) { $ name = Inflector :: camelize ( $ request -> params [ 'plugin' ] ) . '.' . $ name ; } return compact ( 'name' , 'action' ) ; }
5110	private function appendBind ( $ part , $ bind ) { if ( $ bind === false ) return $ this ; if ( ! is_array ( $ bind ) ) $ bind = [ $ bind ] ; if ( ! $ this -> bind [ $ part ] ) { $ this -> bind [ $ part ] = $ bind ; } else { $ this -> bind [ $ part ] = array_merge ( $ this -> bind [ $ part ] , $ bind ) ; } return $ this ; }
4972	private function flattenTree ( $ tree , & $ data , $ curId = '1' ) { $ data [ ] = new \ ArrayObject ( [ 'id' => $ tree -> getId ( ) , 'current' => $ curId , 'name' => $ tree -> getName ( ) , 'value' => $ tree -> getValue ( ) , 'priority' => $ tree -> getPriority ( ) , 'do' => 'nothing' , ] ) ; if ( $ tree -> hasChildren ( ) ) { foreach ( $ tree -> getChildren ( ) as $ i => $ child ) { $ this -> flattenTree ( $ child , $ data , $ curId . '-' . ( $ i + 1 ) ) ; } } }
6226	public function isValid ( ) { if ( $ this -> service_code == 2106 ) { if ( $ this -> getSpecifier ( 'pickup_point_id' ) === null ) return false ; } if ( $ this -> service_code == 3101 ) { $ expected_params = array ( 'amount' , 'account' , 'reference' , 'codbic' ) ; foreach ( $ expected_params as $ param ) { if ( $ this -> getSpecifier ( $ param ) === null ) return false ; } } if ( $ this -> service_code == 3102 ) { if ( $ this -> getSpecifier ( 'count' ) === null ) return false ; if ( ! is_numeric ( $ this -> getSpecifier ( 'count' ) ) ) return false ; } if ( $ this -> service_code == 3111 ) { if ( $ this -> getSpecifier ( 'insurancevalue' ) === null ) return false ; } if ( $ this -> service_code == 3120 ) { if ( $ this -> getSpecifier ( 'deliverytime' ) ) return false ; } if ( $ this -> service_code == 3143 ) { if ( $ this -> getSpecifier ( 'lqweight' ) === null or $ this -> getSpecifier ( 'lqcount' ) === null ) return false ; } if ( ! is_numeric ( $ this -> service_code ) ) { return false ; } return true ; }
12908	public function update ( FilterRequest $ request , $ id ) { $ this -> fieldManager = $ this -> getFieldManager ( ) ; $ this -> validate ( $ request -> request , $ this -> fieldManager -> update ( ) ) ; $ id = $ this -> getRealId ( $ id ) ; $ resource = $ this -> repository -> update ( $ request -> all ( ) , $ id ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
6678	public static function getDateRangeText ( $ startDate , $ endDate , $ toSeparator = 'to' ) { if ( $ startDate == $ endDate ) { return self :: format ( $ startDate , DateFormat :: FORMAT_SHORT ) ; } elseif ( self :: format ( $ startDate , DateFormat :: FORMAT_YEAR ) == self :: format ( $ endDate , DateFormat :: FORMAT_YEAR ) ) { $ start_date = ( self :: format ( $ startDate , DateFormat :: FORMAT_MONTH ) == self :: format ( $ endDate , DateFormat :: FORMAT_MONTH ) ) ? self :: format ( $ startDate , DateFormat :: FORMAT_DAY ) : self :: format ( $ startDate , DateFormat :: FORMAT_SHORT_NO_YEAR ) ; } else { $ start_date = self :: format ( $ startDate , DateFormat :: FORMAT_SHORT ) ; } return $ start_date . ' ' . $ toSeparator . ' ' . self :: format ( $ endDate , DateFormat :: FORMAT_SHORT ) ; }
7714	function switchToRelative ( ) { $ this -> FindEndTag ( ) ; $ this -> rel_Txt = & $ this -> Txt ; $ this -> rel_PosBeg = $ this -> PosBeg ; $ this -> rel_Len = $ this -> GetLen ( ) ; $ src = $ this -> GetSrc ( ) ; $ this -> Txt = & $ src ; $ this -> _ApplyDiffToAll ( - $ this -> PosBeg ) ; }
2142	private function getSessionBag ( Request $ request ) : SessionBagInterface { if ( ! $ request -> hasSession ( ) || null === ( $ session = $ request -> getSession ( ) ) ) { throw new \ RuntimeException ( 'The request did not contain a session.' ) ; } $ name = 'contao_frontend' ; if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ name = 'contao_backend' ; } return $ session -> getBag ( $ name ) ; }
10571	protected function validateCache ( $ lastModified , $ etag ) { if ( isset ( $ _SERVER [ 'HTTP_IF_NONE_MATCH' ] ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getEtags ( ) , true ) ; } elseif ( isset ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) ) { return $ lastModified !== null && @ strtotime ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) >= $ lastModified ; } else { return $ etag === null && $ lastModified === null ; } }
784	protected function validateCache ( $ lastModified , $ etag ) { if ( Yii :: $ app -> request -> headers -> has ( 'If-None-Match' ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getETags ( ) , true ) ; } elseif ( Yii :: $ app -> request -> headers -> has ( 'If-Modified-Since' ) ) { return $ lastModified !== null && @ strtotime ( Yii :: $ app -> request -> headers -> get ( 'If-Modified-Since' ) ) >= $ lastModified ; } return false ; }
11486	protected function resolveNonClassArg ( ReflectionParameter $ param , array $ params , ReflectionFunctionAbstract $ func ) { $ name = '$' . $ param -> getName ( ) ; if ( $ params && array_key_exists ( $ name , $ params ) ) { $ argument = $ params [ $ name ] ; if ( is_array ( $ argument ) && isset ( $ this -> factories [ $ argument [ 0 ] ] ) ) { $ argument = $ this -> callFactory ( $ argument [ 0 ] , $ argument [ 1 ] ) ; } return $ argument ; } if ( $ param -> isDefaultValueAvailable ( ) ) { return $ param -> getDefaultValue ( ) ; } throw Exception \ UnresolvableArgumentException :: fromReflectionParam ( $ param , $ func ) ; }
4599	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ entity = $ request -> attributes -> get ( '_api_resource_class' ) ; if ( null === $ entity ) { return ; } if ( ! in_array ( Translatable :: class , class_implements ( $ entity ) , true ) ) { return ; } $ model = $ request -> attributes -> get ( 'data' ) ; if ( 'post' === $ request -> attributes -> get ( '_api_collection_operation_name' ) ) { $ this -> translationService -> transfer ( $ model ) ; } else if ( 'put' === $ request -> attributes -> get ( '_api_item_operation_name' ) ) { $ this -> translationService -> transfer ( $ model ) ; $ this -> translationService -> translate ( $ model ) ; } }
2451	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoRequest ( $ event -> getRequest ( ) ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( '_locale' , $ this -> getLocale ( $ request ) ) ; }
4717	public function emit ( $ event , $ parameters ) { if ( ! isset ( $ this -> callbacks [ $ event ] ) ) { return ; } if ( ! $ this -> callbacks [ $ event ] [ 0 ] ) { usort ( $ this -> callbacks [ $ event ] [ 1 ] , function ( $ A , $ B ) { if ( $ A [ 0 ] == $ B [ 0 ] ) { return 0 ; } return ( $ A [ 0 ] > $ B [ 0 ] ) ? 1 : - 1 ; } ) ; $ this -> callbacks [ $ event ] [ 0 ] = true ; } foreach ( $ this -> callbacks [ $ event ] [ 1 ] as $ item ) { call_user_func_array ( $ item [ 1 ] , $ this -> buildParameters ( $ parameters ) ) ; } }
3219	function getDelta ( $ cursor = null , $ pathPrefix = null ) { Checker :: argStringNonEmptyOrNull ( "cursor" , $ cursor ) ; Path :: checkArgOrNull ( "pathPrefix" , $ pathPrefix ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/delta" , array ( "cursor" => $ cursor , "path_prefix" => $ pathPrefix ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
7103	public static function query ( array $ params = null , $ use_get = null ) { if ( $ use_get ) { if ( $ params === NULL ) { $ params = $ _GET ; } else { $ params = Arr :: merge ( $ _GET , $ params ) ; } } if ( empty ( $ params ) ) { return '' ; } $ query = http_build_query ( $ params , '' , '&' ) ; return ( $ query === '' ) ? '' : ( '?' . $ query ) ; }
4183	public function fileHas ( $ contains ) { $ this -> files = ( new ClassIterator ( $ this -> finder -> contains ( $ contains ) ) ) -> getClassMap ( ) ; $ this -> count = count ( $ this -> files ) ; return $ this ; }
751	protected function validateSlug ( $ slug ) { $ validator = Yii :: createObject ( array_merge ( [ 'class' => UniqueValidator :: className ( ) , ] , $ this -> uniqueValidator ) ) ; $ model = clone $ this -> owner ; $ model -> clearErrors ( ) ; $ model -> { $ this -> slugAttribute } = $ slug ; $ validator -> validateAttribute ( $ model , $ this -> slugAttribute ) ; return ! $ model -> hasErrors ( ) ; }
7015	private function format_y ( & $ str ) { if ( strstr ( $ str , '%y' ) ) $ str = str_replace ( '%y' , substr ( $ this -> year , strlen ( $ this -> year ) - 2 , 2 ) , $ str ) ; }
11030	public function getSubmitModelName ( $ attribute ) { return empty ( $ this -> submitModelName ) ? Html :: getInputName ( $ this -> model , $ attribute ) : $ this -> submitModelName . "[$attribute]" ; }
9142	public function getParams ( ) { $ params = array ( ) ; if ( $ paramsAvailable = reset ( $ this -> params ) ) { foreach ( array_keys ( $ paramsAvailable ) as $ paramKey ) { $ params [ $ paramKey ] = $ this -> getParam ( $ paramKey ) ; } } return $ params ; }
10712	public function create ( array $ attributes = [ ] ) { $ model = $ this -> newModel ( ) ; $ model -> fill ( $ attributes ) ; $ this -> save ( $ model ) ; return $ model ; }
10468	public static function getConversionFactor ( Uom $ from , Uom $ to ) { if ( $ from -> isSameValueAs ( $ to ) ) { return new Fraction ( 1 ) ; } if ( ! isset ( static :: $ conversions ) ) { static :: $ conversions = json_decode ( utf8_encode ( file_get_contents ( __DIR__ . '/conversions.json' ) ) , true ) ; } if ( isset ( static :: $ conversions [ $ from -> getName ( ) ] [ $ to -> getName ( ) ] ) ) { $ numeratorDenominatorPair = static :: $ conversions [ $ from -> getName ( ) ] [ $ to -> getName ( ) ] ; } elseif ( isset ( static :: $ conversions [ $ to -> getName ( ) ] [ $ from -> getName ( ) ] ) ) { $ numeratorDenominatorPair = array_reverse ( static :: $ conversions [ $ to -> getName ( ) ] [ $ from -> getName ( ) ] ) ; } else { throw new ConversionNotSetException ( $ from -> getName ( ) , $ to -> getName ( ) ) ; } if ( count ( $ numeratorDenominatorPair ) == 2 ) { return new Fraction ( $ numeratorDenominatorPair [ 0 ] , $ numeratorDenominatorPair [ 1 ] ) ; } else { throw new BadConversionException ( ) ; } }
12219	public function errorHandler ( $ errno , $ errstr , $ errfile , $ errline , array $ errcontext = [ ] ) { $ codes = array ( 256 => 'E_USER_ERROR' , 512 => 'E_USER_WARNING' , 1024 => 'E_USER_NOTICE' , 2048 => 'E_STRICT' , 4096 => 'E_RECOVERABLE_ERROR' , 8192 => 'E_DEPRECATED' , 16384 => 'E_USER_DEPRECATED' , 8 => 'E_NOTICE' , 2 => 'E_WARNING' ) ; $ message = 'Error of level ' ; if ( array_key_exists ( $ errno , $ codes ) ) { $ message .= $ codes [ $ errno ] ; } else { $ message .= sprintf ( 'Unknown error level, code of %d passed' , $ errno ) ; } $ message .= sprintf ( '. Error message was "%s" in file %s at line %d.' , $ errstr , $ errfile , $ errline ) ; $ this -> container [ 'log' ] -> error ( $ message , $ errcontext ) ; $ this -> exceptionHandler ( new InternalServerError ( 'An unexpected error occurred.' ) ) ; }
4167	protected function stringify ( $ name ) { $ classes = array_unique ( array_merge ( $ this -> suffixClass ( $ this -> getFromConfig ( $ name ) ) , $ this -> suffixClass ( $ this -> $ name ) ) ) ; $ newLine2Tabs = PHP_EOL . ' ' ; if ( $ name == 'providers' ) { return "'$name' => [$newLine2Tabs" . implode ( ',' . $ newLine2Tabs , $ classes ) . PHP_EOL . ' ],' . PHP_EOL ; } $ template = "'$name' => [$newLine2Tabs" ; foreach ( $ classes as $ fullClassName ) { $ template .= "'{$this->getClassName($fullClassName)}' => $fullClassName,$newLine2Tabs" ; } $ template .= PHP_EOL . ' ],' . PHP_EOL ; return $ template ; }
4343	protected function popStack ( ) { $ stackInfo = \ array_pop ( $ this -> funcStack ) ; $ funcPopped = $ stackInfo [ 'function' ] ; $ timeElapsed = \ microtime ( true ) - $ stackInfo [ 'tsStart' ] ; $ this -> data [ $ funcPopped ] [ 'ownTime' ] += $ timeElapsed - $ stackInfo [ 'subTime' ] ; $ this -> data [ $ funcPopped ] [ 'totalTime' ] += $ timeElapsed ; if ( $ this -> data [ $ funcPopped ] [ 'calls' ] === 0 ) { $ this -> data [ $ funcPopped ] [ 'calls' ] ++ ; } if ( $ this -> funcStack ) { $ this -> funcStack [ \ count ( $ this -> funcStack ) - 1 ] [ 'subTime' ] += $ timeElapsed ; } return $ stackInfo [ 'function' ] ; }
2281	protected static function httpHost ( ) { if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_HOST' ] ; } else { $ host = $ _SERVER [ 'SERVER_NAME' ] ; if ( $ _SERVER [ 'SERVER_PORT' ] != 80 ) { $ host .= ':' . $ _SERVER [ 'SERVER_PORT' ] ; } } return preg_replace ( '/[^A-Za-z0-9[\].:-]/' , '' , $ host ) ; }
12395	abstract public function __construct ( ConnectionInterface $ connection ) ;
8712	public function whereTranslated ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( func_num_args ( ) == 2 ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } elseif ( $ this -> invalidOperatorAndValue ( $ operator , $ value ) ) { throw new InvalidArgumentException ( 'Illegal operator and value combination.' ) ; } if ( ! in_array ( strtolower ( $ operator ) , $ this -> operators , true ) ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } $ fallbackColumn = $ this -> qualifyTranslationColumn ( $ column , true ) ; $ column = $ this -> qualifyTranslationColumn ( $ column ) ; if ( ! $ this -> model -> shouldFallback ( ) || $ column instanceof Closure ) { return $ this -> where ( $ column , $ operator , $ value , $ boolean ) ; } $ condition = $ this -> compileIfNull ( $ column , $ fallbackColumn ) ; return $ this -> whereRaw ( "$condition $operator ?" , [ $ value ] , $ boolean ) ; }
3055	public function getLastCatItemOutput ( ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ itemOutput = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> getCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-item-output' ) ; $ output = [ ] ; if ( ! is_null ( $ itemOutput ) ) { $ rawData = json_decode ( $ itemOutput , true ) ; foreach ( $ rawData as $ result ) { $ itemResult = ItemResult :: restore ( $ result ) ; $ output [ $ itemResult -> getItemRefId ( ) ] = $ itemResult ; } } return $ output ; }
1906	protected function replaceWildcards ( $ arrValues ) { $ arrValues = $ this -> escapeParams ( $ arrValues ) ; $ this -> strQuery = preg_replace ( '/(?<!%)%([^bcdufosxX%])/' , '%%$1' , $ this -> strQuery ) ; if ( ! $ this -> strQuery = @ vsprintf ( $ this -> strQuery , $ arrValues ) ) { throw new \ Exception ( 'Too few arguments to build the query string' ) ; } }
3371	private function visitAssociation ( $ className , $ association = null ) { if ( null === $ association ) { if ( isset ( $ this -> visitedAssociations [ $ className ] ) ) { return false ; } $ this -> visitedAssociations [ $ className ] = [ ] ; return true ; } if ( isset ( $ this -> visitedAssociations [ $ className ] [ $ association ] ) ) { return false ; } if ( ! isset ( $ this -> visitedAssociations [ $ className ] ) ) { $ this -> visitedAssociations [ $ className ] = [ ] ; } $ this -> visitedAssociations [ $ className ] [ $ association ] = true ; return true ; }
11259	public static function pascal2snake ( string $ pascal ) : string { preg_match_all ( '/((?:^|[A-Z])[a-z]+)/' , $ pascal , $ matches ) ; if ( $ matches !== null && count ( $ matches ) > 1 && count ( $ matches [ 1 ] ) > 1 ) { $ nameParts = $ matches [ 1 ] ; $ nameParts = array_map ( "lcfirst" , $ nameParts ) ; return implode ( "_" , $ nameParts ) ; } else { return lcfirst ( $ pascal ) ; } }
7190	private function copyAttachment ( Model \ SaleAttachmentInterface $ source , Model \ SaleAttachmentInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'path' , 'title' , 'type' , 'size' , 'internal' , 'createdAt' , 'updatedAt' , ] ) ; }
4317	private static function getMethodDefaultArgs ( $ methodName ) { $ defaultArgs = array ( ) ; if ( isset ( self :: $ methodDefaultArgs [ $ methodName ] ) ) { $ defaultArgs = self :: $ methodDefaultArgs [ $ methodName ] ; } elseif ( \ method_exists ( self :: $ instance , $ methodName ) ) { $ reflectionMethod = new ReflectionMethod ( self :: $ instance , $ methodName ) ; $ params = $ reflectionMethod -> getParameters ( ) ; foreach ( $ params as $ reflectionParameter ) { $ defaultArgs [ ] = $ reflectionParameter -> isOptional ( ) ? $ reflectionParameter -> getDefaultValue ( ) : null ; } self :: $ methodDefaultArgs [ $ methodName ] = $ defaultArgs ; } return $ defaultArgs ; }
12534	public function pagination ( $ lastSeen , $ count ) { $ params = [ 'type' => 2 , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
4472	public function retry ( $ group , $ message , $ delay = 0 ) { return $ this -> client -> retry ( $ this -> jid , $ this -> queue , $ this -> worker , $ delay , $ group , $ message ) ; }
905	public function isUnaryPredecessorOperator ( $ index ) { static $ potentialSuccessorOperator = [ T_INC , T_DEC ] ; static $ potentialBinaryOperator = [ '+' , '-' , '&' , [ CT :: T_RETURN_REF ] ] ; static $ otherOperators ; if ( null === $ otherOperators ) { $ otherOperators = [ '!' , '~' , '@' , [ T_ELLIPSIS ] ] ; } static $ disallowedPrevTokens ; if ( null === $ disallowedPrevTokens ) { $ disallowedPrevTokens = [ ']' , '}' , ')' , '"' , '`' , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ T_CLASS_C ] , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_DEC ] , [ T_DIR ] , [ T_DNUMBER ] , [ T_FILE ] , [ T_FUNC_C ] , [ T_INC ] , [ T_LINE ] , [ T_LNUMBER ] , [ T_METHOD_C ] , [ T_NS_C ] , [ T_STRING ] , [ T_TRAIT_C ] , [ T_VARIABLE ] , ] ; } $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( $ potentialSuccessorOperator ) ) { return ! $ this -> isUnarySuccessorOperator ( $ index ) ; } if ( $ token -> equalsAny ( $ otherOperators ) ) { return true ; } if ( ! $ token -> equalsAny ( $ potentialBinaryOperator ) ) { return false ; } $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( ! $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return true ; } if ( ! $ token -> equals ( '&' ) || ! $ prevToken -> isGivenKind ( T_STRING ) ) { return false ; } static $ searchTokens = [ ';' , '{' , '}' , [ T_FUNCTION ] , [ T_OPEN_TAG ] , [ T_OPEN_TAG_WITH_ECHO ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevTokenOfKind ( $ index , $ searchTokens ) ] ; return $ prevToken -> isGivenKind ( T_FUNCTION ) ; }
1501	public function matchesTo ( MediaTypeInterface $ mediaType ) : ? Encoding { return collect ( $ this -> stack ) -> first ( function ( Encoding $ encoding ) use ( $ mediaType ) { return $ encoding -> matchesTo ( $ mediaType ) ; } ) ; }
622	public function with ( ) { $ with = func_get_args ( ) ; if ( isset ( $ with [ 0 ] ) && is_array ( $ with [ 0 ] ) ) { $ with = $ with [ 0 ] ; } if ( empty ( $ this -> with ) ) { $ this -> with = $ with ; } elseif ( ! empty ( $ with ) ) { foreach ( $ with as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> with [ ] = $ value ; } else { $ this -> with [ $ name ] = $ value ; } } } return $ this ; }
11040	function leaf_path_walk ( $ elements , $ rank , $ ptype , & $ i , $ cvalue ) { if ( count ( $ elements ) == 1 ) { $ elt [ $ ptype . ':' . $ i . ':' . $ elements [ 0 ] . ':' . $ cvalue ] = '' ; } else { $ element1 = array_shift ( $ elements ) ; $ elt [ _ETS_TEMPLATE . ':' . $ i . '.' . $ rank . ':' . $ element1 ] = $ this -> leaf_path_walk ( $ elements , $ rank + 1 , $ ptype , $ i , $ cvalue ) ; } return $ elt ; }
2470	public function getMaxDepthForContent ( ContentType $ contentType ) : int { if ( isset ( $ this -> contentTypeMap [ $ contentType -> identifier ] ) ) { return $ this -> contentTypeMap [ $ contentType -> identifier ] ; } return $ this -> defaultIndexingDepth ; }
4621	public function buildJsonObject ( $ data ) { $ this -> object = new RObject ( ) ; $ this -> object -> setData ( $ data ) ; $ this -> object -> setContentType ( Http :: CONTENT_TYPE_JSON ) ; return $ this ; }
10722	public function count ( $ col , $ alias , $ distinct = false ) { $ this -> counts [ ] = [ $ col , $ alias , $ distinct ] ; return $ this ; }
6572	protected function registerCommands ( ) { $ this -> app [ 'command.countries.migration' ] = $ this -> app -> share ( function ( $ app ) { return new MigrationCommand ( $ app ) ; } ) ; $ this -> commands ( 'command.countries.migration' ) ; }
8630	public function setGetLowestOfferListingsForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetLowestOfferListingsForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3359	public function preview ( $ width , $ height ) { if ( ! $ width || ! $ height ) { throw new \ Exception ( 'Please, provide both width and height for preview' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'preview' ] = array ( 'width' => $ width , 'height' => $ height , ) ; return $ result ; }
10477	protected function displayExceptions ( Exception $ e ) { $ this -> display [ ] = 'Cerbero\Auth\Exceptions\DisplayException' ; foreach ( $ this -> display as $ exception ) { if ( $ e instanceof $ exception ) { return back ( ) -> withInput ( ) -> withError ( $ e -> getMessage ( ) ) ; } } }
3014	public function unlike ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/unlike' , $ options , false ) ; }
2905	public function addEmailToProfile ( $ email , $ name , $ variables , $ result , Zend_Mail $ mail ) { $ emailCapture = Mage :: getModel ( 'sheep_debug/email' ) ; $ subject = $ this -> decodeSubject ( $ mail -> getSubject ( ) ) ; $ body = $ this -> getContent ( $ mail ) ; $ emailCapture -> setFromName ( $ this -> getSenderName ( ) ) ; $ emailCapture -> setFromEmail ( $ this -> getSenderEmail ( ) ) ; $ emailCapture -> setToEmail ( $ email ) ; $ emailCapture -> setToName ( $ name ) ; $ emailCapture -> setSubject ( $ subject ) ; $ emailCapture -> setIsPlain ( $ this -> isPlain ( ) ) ; $ emailCapture -> setBody ( $ body ) ; $ emailCapture -> setIsAccepted ( $ result ) ; $ emailCapture -> setVariables ( $ variables ) ; $ emailCapture -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) -> addEmail ( $ emailCapture ) ; }
8543	public function setShipmentEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11419	protected function getValues ( $ fields , $ preCalculatedResult = false ) { if ( $ preCalculatedResult ) { return $ preCalculatedResult ; } $ app = App :: getInstance ( ) ; $ sql = $ this -> constructSelectSQL ( $ fields ) ; $ item = $ this -> getCache ( $ fields [ $ this -> pk ] ) ; $ results = $ item -> get ( \ Stash \ Invalidation :: PRECOMPUTE , 300 ) ; if ( $ item -> isMiss ( ) ) { $ results = $ this -> runGetRow ( $ sql ) ; if ( $ app [ 'db' ] -> last_error ) { throw new SQLException ( $ app [ 'db' ] -> last_error , $ app [ 'db' ] -> captured_errors ) ; } if ( is_null ( $ results ) ) { throw new ModelNotFoundException ( 'No model in database' , $ this -> dbtable , $ this -> constructorId ) ; } $ app [ 'cache' ] -> save ( $ item -> set ( $ results ) ) ; } return $ results ; }
3308	protected function signature ( ) { $ signatureKey = $ this -> buildSignatureKey ( ) ; $ sing = hash_hmac ( 'SHA1' , $ signatureKey , $ this -> secretKey , true ) ; return base64_encode ( $ sing . $ signatureKey ) ; }
4146	protected function getUrl ( ) { $ domain = $ this -> urls [ 'domain' ] ; $ apiVersion = $ this -> urls [ 'api' ] ; $ jsonExt = '.json' ; if ( isset ( $ this -> withMedia ) && $ this -> withMedia === true ) { $ domain = $ this -> urls [ 'upload' ] ; } if ( $ this -> call === 'oauth/request_token' || $ this -> call === 'oauth/access_token' ) { $ apiVersion = '' ; $ jsonExt = '' ; } return $ domain . $ apiVersion . $ this -> call . $ jsonExt ; }
10506	private function registerLogMenu ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogMenu :: class , Utilities \ LogMenu :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.menu' , Contracts \ Utilities \ LogMenu :: class ) ; }
12702	public function get ( $ id ) { if ( isset ( $ this -> singletons [ $ id ] ) ) { return $ this -> singletons [ $ id ] ; } $ methodName = 'get' . Util :: mapIdToCamelCase ( $ id ) ; if ( method_exists ( $ this , $ methodName ) ) { return $ this -> $ methodName ( ) ; } throw new \ InvalidArgumentException ( "Unknown service '$id' in container '" . get_called_class ( ) . "'" ) ; }
9823	public function writeWorkbookRelationships ( Spreadsheet $ spreadsheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ this -> writeRelationship ( $ objWriter , 1 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles' , 'styles.xml' ) ; $ this -> writeRelationship ( $ objWriter , 2 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme' , 'theme/theme1.xml' ) ; $ this -> writeRelationship ( $ objWriter , 3 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings' , 'sharedStrings.xml' ) ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ this -> writeRelationship ( $ objWriter , ( $ i + 1 + 3 ) , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet' , 'worksheets/sheet' . ( $ i + 1 ) . '.xml' ) ; } if ( $ spreadsheet -> hasMacros ( ) ) { $ this -> writeRelationShip ( $ objWriter , ( $ i + 1 + 3 ) , 'http://schemas.microsoft.com/office/2006/relationships/vbaProject' , 'vbaProject.bin' ) ; ++ $ i ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
10521	protected function buildTblConst ( ) { $ result = $ this -> buildCol ( ) ; if ( isset ( $ this -> tbl_constraint [ 'primary' ] ) ) { $ p = $ this -> tbl_constraint [ 'primary' ] ; $ result [ ] = 'PRIMARY KEY (' . join ( ', ' , $ this -> quoteIndex ( $ p [ 0 ] ) ) . ')' . ( empty ( $ p [ 1 ] ) ? '' : " $p[1]" ) ; } if ( isset ( $ this -> tbl_constraint [ 'unique' ] ) ) { foreach ( $ this -> tbl_constraint [ 'unique' ] as $ uniq ) { $ result [ ] = 'UNIQUE (' . join ( ', ' , $ this -> quoteIndex ( $ uniq [ 0 ] ) ) . ')' . ( empty ( $ uniq [ 1 ] ) ? '' : " $uniq[1]" ) ; } } if ( isset ( $ this -> tbl_constraint [ 'other' ] ) ) { foreach ( $ this -> tbl_constraint [ 'other' ] as $ const ) { $ result [ ] = $ const ; } } return $ result ; }
9375	public function render ( $ template , array $ data = array ( ) ) { list ( $ file , $ name ) = array ( null , str_replace ( '.' , '/' , $ template ) ) ; foreach ( ( array ) $ this -> paths as $ key => $ path ) { $ files = ( array ) $ this -> files ( $ path ) ; $ item = $ this -> check ( $ files , $ path , $ key , $ name . '.php' ) ; $ item !== null && $ file = $ item ; } if ( is_null ( $ file ) === true ) { $ message = 'Template file "' . $ name . '" not found.' ; throw new \ InvalidArgumentException ( ( string ) $ message ) ; } return $ this -> extract ( $ file , $ data ) ; }
6785	public function buildFormDataString ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ formOptions = [ ] ; foreach ( $ this -> formParameters as $ key => $ isFormParameter ) { if ( $ isFormParameter && isset ( $ options [ $ key ] ) ) { $ formOptions [ $ key ] = $ options [ $ key ] ; } } return http_build_query ( $ formOptions ) ; }
5862	protected function expandValuesInRuleset ( array $ ruleset ) { $ values = [ ] ; foreach ( $ ruleset as $ key => $ value ) { switch ( $ key ) { case 'usergroup' : $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; break ; case 'directories' : $ values [ 'directories_config' ] = '' ; $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; foreach ( $ value as & $ directory ) { $ directory = rtrim ( $ directory , '/' ) . '/' ; if ( ! empty ( $ values [ 'directories_config' ] ) ) { $ values [ 'directories_config' ] .= ',' ; } $ values [ 'directories_config' ] .= $ directory ; $ directory = $ this -> getDirectoryPattern ( $ directory ) ; } if ( count ( $ value ) == 0 ) { $ value = '' ; } break ; case 'file_types' : $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; if ( count ( $ value ) == 0 ) { $ value = '' ; } break ; case 'threshold' : if ( ! is_numeric ( $ value ) ) { $ unit = strtoupper ( substr ( $ value , - 1 ) ) ; $ factor = 1 * ( $ unit === 'K' ? 1024 : ( $ unit === 'M' ? 1024 * 1024 : 0 ) ) ; $ value = intval ( trim ( substr ( $ value , 0 , strlen ( $ value ) - 1 ) ) ) * $ factor ; } case 'max_width' : case 'max_height' : if ( $ value <= 0 ) { $ value = '' ; } break ; case 'max_size' : if ( ! is_numeric ( $ value ) ) { $ unit = strtoupper ( substr ( $ value , - 1 ) ) ; $ factor = 1 * ( $ unit === 'M' ? 1000000 : 1 ) ; $ value = intval ( trim ( substr ( $ value , 0 , strlen ( $ value ) - 1 ) ) ) * $ factor ; } break ; case 'conversion_mapping' : if ( strpos ( $ value , CRLF ) !== false ) { $ mapping = GeneralUtility :: trimExplode ( CRLF , $ value , true ) ; } else { $ mapping = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; } if ( count ( $ mapping ) > 0 ) { $ value = $ this -> expandConversionMapping ( $ mapping ) ; } else { $ value = '' ; } break ; } $ values [ $ key ] = $ value ; } return $ values ; }
7224	public function exec ( $ keepAlive = false ) { $ this -> lastResult = curl_exec ( $ this -> curl ) ; $ this -> info = curl_getinfo ( $ this -> curl ) ; if ( ! $ keepAlive ) curl_close ( $ this -> curl ) ; return $ this -> lastResult !== false ; }
8596	public function listMarketplaceParticipations ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10699	public static function isBirthDate ( $ date ) { if ( $ date === null || $ date === '0000-00-00' ) { return true ; } if ( preg_match ( '/^(\d{4})-((?:0?[1-9])|(?:1[0-2]))-((?:0?[1-9])|(?:[1-2]\d)|(?:3[01]))(\d{2}:\d{2}:\d{2})?$/' , $ date , $ birth_date ) ) { return ! ( ( $ birth_date [ 1 ] > date ( 'Y' ) && $ birth_date [ 2 ] > date ( 'm' ) && $ birth_date [ 3 ] > date ( 'd' ) ) || ( $ birth_date [ 1 ] === date ( 'Y' ) && $ birth_date [ 2 ] === date ( 'm' ) && $ birth_date [ 3 ] > date ( 'd' ) ) || ( $ birth_date [ 1 ] === date ( 'Y' ) && $ birth_date [ 2 ] > date ( 'm' ) ) ) ; } return false ; }
57	public function remove ( PackageInterface $ package , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> remove ( $ package , $ targetDir ) ; } }
4179	public function hasManagerFile ( ) { if ( app ( 'filesystem' ) -> exists ( $ this -> directory . 'manager.yml' ) ) { return true ; } $ this -> console -> warn ( "No manager.yml file found in {$this->name} package." ) ; return false ; }
4243	public function onShutdown ( ) { $ this -> runtimeVals ( ) ; if ( $ this -> testEmailLog ( ) ) { $ this -> emailLog ( ) ; } if ( ! $ this -> debug -> getData ( 'outputSent' ) ) { echo $ this -> debug -> output ( ) ; } return ; }
10187	protected static function buildAuthorizationHeader ( string $ method , string $ token , string $ password = null ) { switch ( $ method ) { case Client :: AUTH_HTTP_PASSWORD : return 'Basic ' . base64_encode ( "$token:$password" ) ; case Client :: AUTH_OAUTH_TOKEN : return "Bearer $token" ; } throw new RuntimeException ( sprintf ( 'Authentication method "%s" not implemented.' , $ method ) ) ; }
5405	public function agePrematurely ( $ interval ) { for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { $ this -> cookies [ $ i ] -> agePrematurely ( $ interval ) ; } }
4694	public function addOrderBy ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> order [ ] = $ expression ; $ this -> pushArgs ( 'order' , $ args ) ; return $ this ; }
1275	private function sendRequest ( $ request , $ endpoint , $ operation , $ wsdl ) { $ endpointurl = $ this -> compileEndpointUrl ( $ endpoint ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ endpointurl , $ operation , $ wsdl ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } return $ this -> formatResponse ( $ response ) ; }
12689	public function get ( $ namespace , $ name , $ default = null , $ require = false ) { $ configuration = $ this -> load ( $ namespace , $ require ) ; return array_key_exists ( $ name , $ configuration ) ? $ configuration [ $ name ] : $ default ; }
8286	protected function loadDefaultConfig ( array $ config ) { $ configurator = new PluginConfigurator ; $ validConfig = $ configurator -> validate ( isset ( $ config [ self :: PLUGIN_NAME ] ) ? $ config [ self :: PLUGIN_NAME ] : null ) ; return $ validConfig ; }
7109	static public function getRoundingIncrement ( $ currency ) { if ( isset ( static :: $ increments [ $ currency ] ) ) { return static :: $ increments [ $ currency ] ; } return static :: $ increments [ $ currency ] = static :: getCurrencyBundle ( ) -> getRoundingIncrement ( $ currency ) ; }
11282	public function _populate ( $ record = null , $ db = false , $ loadMap = false ) { $ this -> model_hydrating = true ; if ( $ db ) { $ this -> model_db = $ db ; } if ( $ record ) { $ this -> _populateAttributes ( $ record ) ; $ this -> _populateNonModelData ( $ record ) ; } if ( $ this -> model_loadMapsEnabled ) { $ this -> _populateLoadMap ( $ record , $ loadMap ) ; } $ this -> onLoad ( ) ; if ( $ loadMap instanceof \ Cora \ Adm \ LoadMap && $ func = $ loadMap -> getOnLoadFunction ( ) ) { $ args = $ loadMap -> getOnLoadArgs ( ) ; array_unshift ( $ args , $ this ) ; call_user_func_array ( $ func , $ args ) ; } $ this -> model_hydrating = false ; return $ this ; }
4997	public function setSearchParams ( $ params ) { if ( $ params instanceof \ Traversable ) { $ params = ArrayUtils :: iteratorToArray ( $ params ) ; } $ params = Json :: encode ( $ params ) ; $ this -> setAttribute ( 'data-search-params' , $ params ) ; return $ this ; }
12833	private function generateConfigCreatorMethod ( ConfigService $ config ) { $ configClass = Util :: normalizeFqcn ( $ config -> getClass ( ) ) ; $ configData = var_export ( $ config -> getData ( ) , true ) ; return <<<PHP public function getAppConfig() : {$configClass} { if (isset(\$this->singletons['{$config->getId()}}'])) { return \$this->singletons['{$config->getId()}']; } \$data = {$configData}; return \$this->singletons['{$config->getId()}'] = new {$configClass}(\$data); }PHP ; }
12038	public function drop ( $ key ) { if ( $ this -> has ( $ key ) ) { unset ( $ _SESSION [ $ this -> root ] [ $ key ] ) ; return true ; } return false ; }
651	public function dropView ( $ viewName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropView ( $ viewName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ viewName ) ; }
11246	public function getMigrations ( int $ steps ) : array { $ sql = "select migration from {$this->table} where batch >= 1 order by batch, migration desc limit ?" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> bindParam ( 1 , $ steps , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
8914	public function decode ( $ value , $ b = 62 ) { $ limit = strlen ( $ value ) ; $ result = strpos ( $ this -> base , $ value [ 0 ] ) ; for ( $ i = 1 ; $ i < $ limit ; $ i ++ ) { $ result = $ b * $ result + strpos ( $ this -> base , $ value [ $ i ] ) ; } return $ result ; }
9821	public function shiftColumn ( $ fromColumn , $ toColumn ) { $ fromColumn = strtoupper ( $ fromColumn ) ; $ toColumn = strtoupper ( $ toColumn ) ; if ( ( $ fromColumn !== null ) && ( isset ( $ this -> columns [ $ fromColumn ] ) ) && ( $ toColumn !== null ) ) { $ this -> columns [ $ fromColumn ] -> setParent ( ) ; $ this -> columns [ $ fromColumn ] -> setColumnIndex ( $ toColumn ) ; $ this -> columns [ $ toColumn ] = $ this -> columns [ $ fromColumn ] ; $ this -> columns [ $ toColumn ] -> setParent ( $ this ) ; unset ( $ this -> columns [ $ fromColumn ] ) ; ksort ( $ this -> columns ) ; } return $ this ; }
3866	private function getOrCreateBasicDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasBasicDefinition ( ) ) { return $ container -> getBasicDefinition ( ) ; } $ config = new DefaultBasicDefinition ( ) ; $ container -> setBasicDefinition ( $ config ) ; return $ config ; }
701	protected function cleanupVendorDir ( $ dir ) { if ( is_link ( $ link = "$dir/vendor/yiisoft/yii2" ) ) { $ this -> stdout ( "Removing symlink $link.\n" ) ; FileHelper :: unlink ( $ link ) ; } $ extensions = $ this -> findDirs ( "$dir/vendor/yiisoft" ) ; foreach ( $ extensions as $ ext ) { if ( is_link ( $ link = "$dir/vendor/yiisoft/yii2-$ext" ) ) { $ this -> stdout ( "Removing symlink $link.\n" ) ; FileHelper :: unlink ( $ link ) ; } } }
11187	public static function get ( array $ arr , $ k , $ default = null ) { if ( isset ( $ arr [ $ k ] ) ) return $ arr [ $ k ] ; $ nested = explode ( '.' , $ k ) ; foreach ( $ nested as $ part ) { if ( isset ( $ arr [ $ part ] ) ) { $ arr = $ arr [ $ part ] ; continue ; } else { $ arr = $ default ; break ; } } return $ arr ; }
1147	protected function isConditionalRule ( $ attribute , $ rule ) { return isset ( $ this -> conditional [ $ attribute ] ) && in_array ( $ rule , $ this -> conditional [ $ attribute ] ) ; }
598	public function joinWith ( $ with , $ eagerLoading = true , $ joinType = 'LEFT JOIN' ) { $ relations = [ ] ; foreach ( ( array ) $ with as $ name => $ callback ) { if ( is_int ( $ name ) ) { $ name = $ callback ; $ callback = null ; } if ( preg_match ( '/^(.*?)(?:\s+AS\s+|\s+)(\w+)$/i' , $ name , $ matches ) ) { list ( , $ relation , $ alias ) = $ matches ; $ name = $ relation ; $ callback = function ( $ query ) use ( $ callback , $ alias ) { $ query -> alias ( $ alias ) ; if ( $ callback !== null ) { call_user_func ( $ callback , $ query ) ; } } ; } if ( $ callback === null ) { $ relations [ ] = $ name ; } else { $ relations [ $ name ] = $ callback ; } } $ this -> joinWith [ ] = [ $ relations , $ eagerLoading , $ joinType ] ; return $ this ; }
9089	public function viewBody ( ) { $ sticky_values = hypePrototyper ( ) -> prototype -> getStickyValues ( $ this -> action ) ; hypePrototyper ( ) -> prototype -> clearStickyValues ( $ this -> action ) ; $ validation_status = hypePrototyper ( ) -> prototype -> getValidationStatus ( $ this -> action ) ; hypePrototyper ( ) -> prototype -> clearValidationStatus ( $ this -> action ) ; $ i = 0 ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getInputView ( ) === false ) { continue ; } $ shortname = $ field -> getShortname ( ) ; if ( isset ( $ sticky_values [ $ shortname ] ) ) { $ field -> setStickyValue ( $ sticky_values [ $ shortname ] ) ; } if ( isset ( $ validation_status [ $ shortname ] ) ) { $ field -> setValidation ( $ validation_status [ $ shortname ] [ 'status' ] , $ validation_status [ $ shortname ] [ 'messages' ] ) ; } $ output .= $ field -> viewInput ( array ( 'index' => $ i , 'entity' => $ this -> entity , ) ) ; $ i ++ ; } $ submit = elgg_view ( 'prototyper/input/submit' , array ( 'entity' => $ this -> entity , 'action' => $ this -> action , ) ) ; $ output .= elgg_format_element ( 'div' , array ( 'class' => 'elgg-foot' , ) , $ submit ) ; return $ output ; }
11086	public static function getOctets ( $ option ) { if ( preg_match ( '/\d+k/i' , $ option ) ) { return 1024 * ( int ) $ option ; } if ( preg_match ( '/\d+m/i' , $ option ) ) { return 1024 * 1024 * ( int ) $ option ; } if ( preg_match ( '/\d+g/i' , $ option ) ) { return 1024 * 1024 * 1024 * ( int ) $ option ; } return $ option ; }
10406	public function remove ( $ key ) { $ pair = $ this -> repository -> find ( $ key ) ; if ( $ pair !== null ) { $ this -> repository -> remove ( $ pair -> getId ( ) ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> refresh ( ) ; } }
11841	private function extractInput ( ) { $ params = $ this -> request -> getParams ( ) ; $ period = $ params [ self :: REQ_PERIOD ] ?? '' ; if ( empty ( $ period ) ) { $ period = $ this -> hlpPeriod -> getPeriodCurrent ( null , 0 , HPeriod :: TYPE_MONTH ) ; } else { $ period = $ this -> hlpPeriod -> normalizePeriod ( $ period , HPeriod :: TYPE_MONTH ) ; } $ dsBegin = $ this -> hlpPeriod -> getPeriodFirstDate ( $ period ) ; $ treeType = $ params [ self :: REQ_TREE_TYPE ] ?? '' ; if ( $ treeType != OptionTreeType :: VAL_PLAIN ) { $ treeType = OptionTreeType :: VAL_COMPRESS ; } return [ $ dsBegin , $ treeType ] ; }
7537	function clear ( ) { foreach ( $ this -> children as $ c ) { $ c -> parent = null ; $ c -> delete ( ) ; } $ this -> children = array ( ) ; }
1285	private function fetchResourcesForGivenIds ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ resources = [ ] ; $ resourcePoolOptions = [ 'locale' => $ locale ] ; foreach ( $ resourceIds as $ index => $ resourceId ) { if ( $ this -> resourcePool -> has ( $ type , $ resourceId , $ resourcePoolOptions ) ) { $ resources [ ] = $ this -> resourcePool -> get ( $ type , $ resourceId , $ resourcePoolOptions ) ; unset ( $ resourceIds [ $ index ] ) ; } } foreach ( $ this -> createIdChunks ( $ resourceIds ) as $ chunk ) { $ resources += $ this -> fetchCollectionFromApi ( $ chunk , $ type , $ locale ) ; } return $ resources ; }
8719	public function fresh ( $ with = [ ] ) { if ( ! $ this -> exists ) { return ; } $ query = static :: newQueryWithoutScopes ( ) -> with ( is_string ( $ with ) ? func_get_args ( ) : $ with ) -> where ( $ this -> getKeyName ( ) , $ this -> getKey ( ) ) ; ( new TranslatableScope ( ) ) -> apply ( $ query , $ this ) ; return $ query -> first ( ) ; }
9754	public static function assertFile ( $ filename ) { if ( ! is_file ( $ filename ) ) { throw new InvalidArgumentException ( 'File "' . $ filename . '" does not exist.' ) ; } if ( ! is_readable ( $ filename ) ) { throw new InvalidArgumentException ( 'Could not open "' . $ filename . '" for reading.' ) ; } }
2153	public function updateAccount ( ) { $ intUser = Input :: get ( 'id' ) ; if ( TL_MODE == 'FE' ) { $ this -> import ( FrontendUser :: class , 'User' ) ; $ intUser = $ this -> User -> id ; } if ( ! $ intUser ) { return ; } if ( TL_MODE == 'FE' || Input :: get ( 'act' ) == 'edit' ) { $ objUser = $ this -> Database -> prepare ( "SELECT email, disable FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intUser ) ; if ( $ objUser -> numRows ) { $ strEmail = Input :: post ( 'email' , true ) ; if ( ! empty ( $ _POST ) && $ strEmail != '' && $ strEmail != $ objUser -> email ) { $ objCount = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ strEmail ) ; if ( $ objCount -> count > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; } else { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET email=? WHERE email=?" ) -> execute ( $ strEmail , $ objUser -> email ) ; } $ objUser -> email = $ strEmail ; } $ objSubscriptions = $ this -> Database -> prepare ( "SELECT pid FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; if ( $ objSubscriptions -> numRows ) { $ strNewsletters = serialize ( $ objSubscriptions -> fetchEach ( 'pid' ) ) ; } else { $ strNewsletters = '' ; } $ this -> Database -> prepare ( "UPDATE tl_member SET newsletter=? WHERE id=?" ) -> execute ( $ strNewsletters , $ intUser ) ; if ( TL_MODE == 'FE' ) { $ this -> User -> newsletter = $ strNewsletters ; } elseif ( ! empty ( $ _POST ) && Input :: post ( 'disable' ) != $ objUser -> disable ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active=? WHERE email=?" ) -> execute ( ( Input :: post ( 'disable' ) ? '' : 1 ) , $ objUser -> email ) ; $ objUser -> disable = Input :: post ( 'disable' ) ; } } } elseif ( Input :: get ( 'act' ) == 'delete' ) { $ objUser = $ this -> Database -> prepare ( "SELECT email FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intUser ) ; if ( $ objUser -> numRows ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; } } }
9636	public function write ( $ path , $ contents , $ blocking = false ) { $ flockFlags = $ blocking ? LOCK_EX : LOCK_EX | LOCK_NB ; $ file = fopen ( $ path , 'c' ) ; if ( ! flock ( $ file , $ flockFlags ) ) { fclose ( $ file ) ; throw new IOException ( "Could not aquire file lock for file: $path" ) ; } ftruncate ( $ file , 0 ) ; fwrite ( $ file , $ contents ) ; fflush ( $ file ) ; flock ( $ file , LOCK_UN | LOCK_NB ) ; fclose ( $ file ) ; }
12150	public function checkReservedCodes ( ) { $ reserved = $ this -> getReservedCodes ( ) ; foreach ( $ reserved as $ factoryClass => $ reservedForFactory ) { foreach ( $ reserved as $ checkInFactory => $ reservedInCheckFactory ) { if ( $ checkInFactory == $ factoryClass ) { continue ; } if ( $ reservedInCheckFactory [ 0 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 0 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } if ( $ reservedInCheckFactory [ 1 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 1 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } } } }
6282	public static function buildHttpClient ( LoopInterface $ loop , $ connector = null ) { if ( class_exists ( HttpClientFactory :: class ) ) { return static :: buildHttpClient04 ( $ loop , $ connector ) ; } else { return static :: buildHttpClient05 ( $ loop , $ connector ) ; } }
12010	public function addLink ( string $ name , string $ link = null , array $ arguments = [ ] ) : Link { $ name = $ this -> translator !== null ? $ this -> translator -> translate ( $ name ) : $ name ; return $ this -> addLinkUntranslated ( $ name , $ link , $ arguments ) ; }
8259	protected function getResourceAttribute ( $ name , $ resourceOwner ) { $ method = "get" . $ name ; if ( is_callable ( array ( $ resourceOwner , $ method ) ) ) { $ res = $ resourceOwner -> $ method ( ) ; return $ res ; } else { $ resourceArray = $ resourceOwner -> toArray ( ) ; $ res = $ this -> getValueByKey ( $ resourceArray , $ name ) ; return $ res ; } }
1686	public function updateCurrentUser ( Contao \ DataContainer $ dc ) { if ( $ this -> User -> id == $ dc -> id ) { $ this -> User -> findBy ( 'id' , $ this -> User -> id ) ; } }
5951	public function addFolderResponse ( $ item ) { if ( ! ( $ item instanceof FolderResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new FolderResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FolderResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } elseif ( ! is_numeric ( $ item ) ) { trigger_error ( 'Array parameter item is not of expected type "FolderResponse"!' , E_USER_WARNING ) ; } } $ this -> results [ ] = $ item ; return $ this ; }
1046	public static function toSafeTrace ( $ error ) { $ trace = $ error -> getTrace ( ) ; if ( isset ( $ trace [ 0 ] [ 'function' ] ) && isset ( $ trace [ 0 ] [ 'class' ] ) && ( $ trace [ 0 ] [ 'class' ] . '::' . $ trace [ 0 ] [ 'function' ] === 'GraphQL\Utils\Utils::invariant' ) ) { array_shift ( $ trace ) ; } elseif ( ! isset ( $ trace [ 0 ] [ 'file' ] ) ) { array_shift ( $ trace ) ; } return array_map ( static function ( $ err ) { $ safeErr = array_intersect_key ( $ err , [ 'file' => true , 'line' => true ] ) ; if ( isset ( $ err [ 'function' ] ) ) { $ func = $ err [ 'function' ] ; $ args = ! empty ( $ err [ 'args' ] ) ? array_map ( [ self :: class , 'printVar' ] , $ err [ 'args' ] ) : [ ] ; $ funcStr = $ func . '(' . implode ( ', ' , $ args ) . ')' ; if ( isset ( $ err [ 'class' ] ) ) { $ safeErr [ 'call' ] = $ err [ 'class' ] . '::' . $ funcStr ; } else { $ safeErr [ 'function' ] = $ funcStr ; } } return $ safeErr ; } , $ trace ) ; }
3715	public function addKnownAttributeType ( $ typeName ) { if ( ! is_array ( $ this -> attributeTypes ) ) { throw new \ LogicException ( 'Filter setting ' . $ this -> typeClass . ' can not handle attributes.' ) ; } $ this -> attributeTypes [ $ typeName ] = $ typeName ; return $ this ; }
6202	public function methodFail ( $ errors = null ) { if ( $ errors === null ) { return $ this -> methodResult ( false ) ; } if ( ! is_array ( $ errors ) ) { $ errors = [ $ errors ] ; } return $ this -> methodResult ( false , [ 'errors' => $ errors ] ) ; }
11288	protected function _getRelation ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = false ; if ( isset ( $ def [ 'models' ] ) ) { $ result = $ this -> _getModels ( $ attributeName , $ def [ 'models' ] , $ query , $ loadMap , $ record ) ; } else if ( isset ( $ def [ 'model' ] ) ) { $ result = $ this -> _getModel ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap , $ record ) ; } return $ result ; }
8334	public function addScope ( $ scope ) { if ( $ this -> isValidScope ( $ scope ) ) { $ this -> scope [ $ scope ] = $ scope ; } return $ this ; }
2757	public function permissions ( ) { $ permissions = [ ] ; foreach ( $ this -> entityTypeManager -> getStorage ( 'taxonomy_vocabulary' ) -> loadMultiple ( ) as $ vocabulary ) { $ permissions += [ 'view published terms in ' . $ vocabulary -> id ( ) => [ 'title' => $ this -> t ( 'View published terms in %vocabulary' , [ '%vocabulary' => $ vocabulary -> label ( ) ] ) , ] , 'view unpublished terms in ' . $ vocabulary -> id ( ) => [ 'title' => $ this -> t ( 'View unpublished terms in %vocabulary' , [ '%vocabulary' => $ vocabulary -> label ( ) ] ) , ] , ] ; } return $ permissions ; }
436	public function afterAction ( $ action , $ result ) { $ event = new ActionEvent ( $ action ) ; $ event -> result = $ result ; $ this -> trigger ( self :: EVENT_AFTER_ACTION , $ event ) ; return $ event -> result ; }
8811	public function header ( $ key , $ value ) { if ( is_array ( $ key ) && ! empty ( $ key ) ) { foreach ( $ key as $ k => $ v ) { $ this -> headers -> set ( $ k , $ v ) ; } } elseif ( is_string ( $ key ) && ! empty ( $ key ) ) { $ this -> headers -> set ( $ key , $ value ) ; } return $ this ; }
12707	public static function parseSignature ( string $ signature ) : array { $ signature = explode ( ' ' , trim ( $ signature ) ) ; $ command = trim ( $ signature [ 0 ] ) ; $ arguments = [ ] ; $ options = [ ] ; foreach ( $ signature as $ word ) { $ type = self :: determineTypeOfWord ( $ word ) ; if ( $ type == self :: OPTION_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ options [ $ key ] = $ defaultValue ; } elseif ( $ type == self :: ARGUMENT_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ arguments [ $ key ] = $ defaultValue ; } } return [ $ command , $ arguments , $ options ] ; }
1804	protected function invalidateCacheTags ( self $ dc ) { if ( ! System :: getContainer ( ) -> has ( 'fos_http_cache.cache_manager' ) ) { return ; } $ ns = 'contao.db.' ; $ tags = array ( $ ns . $ dc -> table , $ ns . $ dc -> table . '.' . $ dc -> id ) ; if ( $ dc -> ptable && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { $ tags [ ] = $ ns . $ dc -> ptable ; $ tags [ ] = $ ns . $ dc -> ptable . '.' . $ dc -> activeRecord -> pid ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'oninvalidate_cache_tags_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'oninvalidate_cache_tags_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ tags = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ dc , $ tags ) ; } elseif ( \ is_callable ( $ callback ) ) { $ tags = $ callback ( $ dc , $ tags ) ; } } } $ tags = array_filter ( array_unique ( $ tags ) ) ; $ cacheManager = System :: getContainer ( ) -> get ( 'fos_http_cache.cache_manager' ) ; $ cacheManager -> invalidateTags ( $ tags ) ; }
993	public static function isValidLiteralValue ( Type $ type , $ valueNode ) { $ emptySchema = new Schema ( [ ] ) ; $ emptyDoc = new DocumentNode ( [ 'definitions' => [ ] ] ) ; $ typeInfo = new TypeInfo ( $ emptySchema , $ type ) ; $ context = new ValidationContext ( $ emptySchema , $ emptyDoc , $ typeInfo ) ; $ validator = new ValuesOfCorrectType ( ) ; $ visitor = $ validator -> getVisitor ( $ context ) ; Visitor :: visit ( $ valueNode , Visitor :: visitWithTypeInfo ( $ typeInfo , $ visitor ) ) ; return $ context -> getErrors ( ) ; }
7483	public function startsWith ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; return $ string === $ this -> substring ( 0 , ( mb_strlen ( $ string , $ this -> encoding ) - 1 ) ) -> __toString ( ) ; }
4200	private function addMethods ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( ! $ abs [ 'collectMethods' ] ) { $ this -> addMethodsMin ( $ abs ) ; return ; } if ( $ this -> abstracter -> getCfg ( 'cacheMethods' ) && isset ( static :: $ methodCache [ $ abs [ 'className' ] ] ) ) { $ abs [ 'methods' ] = static :: $ methodCache [ $ abs [ 'className' ] ] ; } else { $ methodArray = array ( ) ; $ methods = $ abs [ 'reflector' ] -> getMethods ( ) ; $ interfaceMethods = array ( 'ArrayAccess' => array ( 'offsetExists' , 'offsetGet' , 'offsetSet' , 'offsetUnset' ) , 'Countable' => array ( 'count' ) , 'Iterator' => array ( 'current' , 'key' , 'next' , 'rewind' , 'void' ) , 'IteratorAggregate' => array ( 'getIterator' ) , ) ; $ interfacesHide = \ array_intersect ( $ abs [ 'implements' ] , \ array_keys ( $ interfaceMethods ) ) ; foreach ( $ methods as $ reflectionMethod ) { $ info = $ this -> methodInfo ( $ obj , $ reflectionMethod ) ; $ methodName = $ reflectionMethod -> getName ( ) ; if ( $ info [ 'visibility' ] === 'private' && $ info [ 'inheritedFrom' ] ) { continue ; } foreach ( $ interfacesHide as $ interface ) { if ( \ in_array ( $ methodName , $ interfaceMethods [ $ interface ] ) ) { $ info [ 'implements' ] = $ interface ; break ; } } $ methodArray [ $ methodName ] = $ info ; } $ abs [ 'methods' ] = $ methodArray ; $ this -> addMethodsPhpDoc ( $ abs ) ; static :: $ methodCache [ $ abs [ 'className' ] ] = $ abs [ 'methods' ] ; } if ( isset ( $ abs [ 'methods' ] [ '__toString' ] ) ) { $ abs [ 'methods' ] [ '__toString' ] [ 'returnValue' ] = $ obj -> __toString ( ) ; } return ; }
4077	protected function getPaletteCombinationRows ( ) { $ combinations = $ this -> getCombinationsFromDatabase ( ) ; $ success = array ( ) ; if ( ! $ combinations ) { return array_keys ( $ this -> information ) ; } foreach ( $ combinations as $ combination ) { $ modelId = $ combination -> pid ; $ modelName = $ this -> tableNameFromId ( $ modelId ) ; if ( ! empty ( $ this -> information [ $ modelName ] [ self :: COMBINATION ] ) ) { continue ; } $ this -> information [ $ modelName ] [ self :: MODELID ] = $ modelId ; $ this -> information [ $ modelName ] [ self :: COMBINATION ] = array ( 'dca_id' => $ combination -> dca_id , 'view_id' => $ combination -> view_id ) ; $ this -> setTableMapping ( $ modelId , $ modelName ) ; $ success [ ] = $ modelId ; } return $ success ; }
542	protected function serializeModels ( array $ models ) { list ( $ fields , $ expand ) = $ this -> getRequestedFields ( ) ; foreach ( $ models as $ i => $ model ) { if ( $ model instanceof Arrayable ) { $ models [ $ i ] = $ model -> toArray ( $ fields , $ expand ) ; } elseif ( is_array ( $ model ) ) { $ models [ $ i ] = ArrayHelper :: toArray ( $ model ) ; } } return $ models ; }
9728	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> minutes ) ) $ this -> minutes = $ xmlElement -> minutes ; if ( isset ( $ xmlElement -> hours ) ) $ this -> hours = $ xmlElement -> hours ; if ( isset ( $ xmlElement -> state ) ) $ this -> state = $ xmlElement -> state ; if ( isset ( $ xmlElement -> date ) ) $ this -> date = $ xmlElement -> date ; }
2553	public static function loadPricingOptionsFromRequestOptions ( $ options ) { $ priceOptions = [ ] ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makePricingOptionForValidatingCarrier ( $ options -> validatingCarrier ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makePricingOptionForCurrencyOverride ( $ options -> currencyOverride ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makePricingOptionFareBasisOverride ( $ options -> pricingsFareBasis ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makePricingOptionFareFamilyOverride ( $ options -> fareFamily ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadCorpNegoFare ( $ options -> corporateNegoFare ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadCorpUniFares ( $ options -> corporateUniFares , $ options -> awardPricing ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadObFees ( $ options -> obFees , $ options -> obFeeRefs ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadPaxDiscount ( $ options -> paxDiscountCodes , $ options -> paxDiscountCodeRefs ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadPointOverrides ( $ options -> pointOfSaleOverride , $ options -> pointOfTicketingOverride ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadPricingLogic ( $ options -> pricingLogic ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadTicketType ( $ options -> ticketType ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadTaxes ( $ options -> taxes ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadExemptTaxes ( $ options -> exemptTaxes ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadPastDate ( $ options -> pastDatePricing ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadFormOfPayment ( $ options -> formOfPayment ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadReferences ( $ options -> references ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makeOverrideOptions ( $ options -> overrideOptions , $ priceOptions ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makeOverrideOptionsWithCriteria ( $ options -> overrideOptionsWithCriteria , $ priceOptions ) ) ; if ( empty ( $ priceOptions ) ) { $ priceOptions [ ] = new PricingOptionGroup ( PricingOptionKey :: OPTION_NO_OPTION ) ; } return $ priceOptions ; }
1068	private function collectConflictsBetween ( ValidationContext $ context , array & $ conflicts , $ parentFieldsAreMutuallyExclusive , array $ fieldMap1 , array $ fieldMap2 ) { foreach ( $ fieldMap1 as $ responseName => $ fields1 ) { if ( ! isset ( $ fieldMap2 [ $ responseName ] ) ) { continue ; } $ fields2 = $ fieldMap2 [ $ responseName ] ; $ fields1Length = count ( $ fields1 ) ; $ fields2Length = count ( $ fields2 ) ; for ( $ i = 0 ; $ i < $ fields1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fields2Length ; $ j ++ ) { $ conflict = $ this -> findConflict ( $ context , $ parentFieldsAreMutuallyExclusive , $ responseName , $ fields1 [ $ i ] , $ fields2 [ $ j ] ) ; if ( ! $ conflict ) { continue ; } $ conflicts [ ] = $ conflict ; } } } }
12804	private static function buildColumnPropertiesCache ( ) { $ class = self :: getStaticChildClass ( ) ; $ annotations = new AnnotationReader ( $ class ) ; $ properties = $ annotations -> getPropertyAnnotations ( ) ; self :: $ columnPropertiesCache [ $ class ] = [ ] ; foreach ( $ properties as $ property ) { if ( $ property === [ ] ) continue ; if ( array_key_exists ( "ColumnName" , $ property ) ) self :: $ columnPropertiesCache [ $ class ] [ $ property [ "ColumnName" ] ] [ ] = $ property [ "var" ] [ "name" ] ; else self :: $ columnPropertiesCache [ $ class ] [ $ property [ "var" ] [ "name" ] ] [ ] = $ property [ "var" ] [ "name" ] ; } }
9512	private function getLogViewerPermissions ( ) { return [ [ 'name' => 'LogViewer - View dashboard' , 'description' => 'Allow to view the LogViewer dashboard.' , 'slug' => LogViewerPolicy :: PERMISSION_DASHBOARD , ] , [ 'name' => 'LogViewer - List all logs' , 'description' => 'Allow to list all the logs.' , 'slug' => LogViewerPolicy :: PERMISSION_LIST , ] , [ 'name' => 'LogViewer - View a log' , 'description' => 'Allow to display a log.' , 'slug' => LogViewerPolicy :: PERMISSION_SHOW , ] , [ 'name' => 'LogViewer - Download a log' , 'description' => 'Allow to download a log.' , 'slug' => LogViewerPolicy :: PERMISSION_DOWNLOAD , ] , [ 'name' => 'LogViewer - Delete a log' , 'description' => 'Allow to delete a log.' , 'slug' => LogViewerPolicy :: PERMISSION_DELETE , ] , ] ; }
12664	public function requirePackage ( string $ package_class ) : ApplicationInterface { if ( ! in_array ( PackageInterface :: class , class_implements ( $ package_class ) ) ) { throw new PackageRequireException ( 'Specified package does not implements PackageInterface: ' . $ package_class , $ package_class ) ; } $ module_list = call_user_func ( [ $ package_class , 'getModuleList' ] ) ; if ( ! is_array ( $ module_list ) ) { throw new PackageRequireException ( 'Failed to call getModuleList: ' . $ package_class , $ package_class ) ; } $ this -> required_modules = array_merge ( $ this -> required_modules , $ module_list ) ; return $ this ; }
10622	public static function forThe ( MapsObjectsByIdentity $ mapped , string ... $ allowedClasses ) : MapsObjectsByIdentity { foreach ( $ mapped -> objects ( ) as $ object ) { if ( Whitelist :: doesNotHave ( $ object , $ allowedClasses ) ) { $ mapped = $ mapped -> removeThe ( $ object ) ; } } return new Whitelist ( $ allowedClasses , $ mapped ) ; }
10125	private function writeAutoFilterInfo ( ) { $ record = 0x009D ; $ length = 0x0002 ; $ rangeBounds = Coordinate :: rangeBoundaries ( $ this -> phpSheet -> getAutoFilter ( ) -> getRange ( ) ) ; $ iNumFilters = 1 + $ rangeBounds [ 1 ] [ 0 ] - $ rangeBounds [ 0 ] [ 0 ] ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ iNumFilters ) ; $ this -> append ( $ header . $ data ) ; }
2000	private function fetchData ( FileUpload $ uploader , string $ separator , callable $ callback ) : array { $ data = [ ] ; $ files = $ this -> getFiles ( $ uploader ) ; $ delimiter = $ this -> getDelimiter ( $ separator ) ; foreach ( $ files as $ file ) { $ fp = fopen ( $ file , 'r' ) ; while ( false !== ( $ row = fgetcsv ( $ fp , 0 , $ delimiter ) ) ) { $ data = $ callback ( $ data , $ row ) ; } } return $ data ; }
4799	function exec ( $ query ) { $ conn = $ this -> getConn ( ) ; $ sql = $ conn -> quote ( $ query ) ; return $ conn -> exec ( $ sql ) ; }
7255	public function loggedIn ( ) { if ( $ this -> _viewAuth ) { return $ this -> sessionKey && $ this -> request -> session ( ) -> check ( $ this -> sessionKey ) ; } return false ; }
4467	private function reload ( ) : void { $ this -> sha = ( string ) @ sha1_file ( $ this -> corePath ) ; if ( empty ( $ this -> sha ) ) { throw new RuntimeException ( 'Unable to locate qless-core file at path: ' . $ this -> corePath ) ; } $ res = $ this -> redis -> script ( 'exists' , $ this -> sha ) ; if ( $ res [ 0 ] !== 1 ) { $ this -> sha = $ this -> redis -> script ( 'load' , file_get_contents ( $ this -> corePath ) ) ; } }
8246	protected function getPasswordEncoder ( $ userData = null ) { if ( isset ( $ userData [ 'encoder' ] ) && is_string ( $ userData [ 'encoder' ] ) ) { $ name = $ userData [ 'encoder' ] ; } else { $ name = $ this -> config [ "encoder" ] ; } $ container = $ this -> picoAuth -> getContainer ( ) ; if ( ! $ container -> has ( $ name ) ) { throw new \ RuntimeException ( "Specified LocalAuth encoder is not resolvable." ) ; } return $ container -> get ( $ name ) ; }
11914	public function addDynamic ( $ name , $ factory , $ createDefault = 0 , $ forceDefault = false ) { $ control = new RContainer ( $ factory , $ createDefault , $ forceDefault ) ; $ control -> currentGroup = $ this -> currentGroup ; return $ this [ $ name ] = $ control ; }
2361	public static function findAllActive ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; return static :: findBy ( array ( "$t.disable='' AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "')" ) , null , $ arrOptions ) ; }
2896	public function captureEmail ( ) { $ email = Mage :: getModel ( 'sheep_debug/email' ) ; $ email -> setFromEmail ( $ this -> getFromEmail ( ) ) ; $ email -> setFromName ( $ this -> getFromName ( ) ) ; $ email -> setToEmail ( $ this -> getToEmail ( ) ) ; $ email -> setToName ( $ this -> getToName ( ) ) ; $ email -> setSubject ( $ this -> getSubject ( ) ) ; $ email -> setIsPlain ( $ this -> getType ( ) != 'html' ) ; $ email -> setBody ( $ this -> getBody ( ) ) ; $ email -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; $ email -> setIsAccepted ( true ) ; $ requestInfo = Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) ; $ requestInfo -> addEmail ( $ email ) ; }
10800	public function renderPageHistoricTableAction ( ) { $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ melisKey = $ this -> params ( ) -> fromRoute ( 'melisKey' , '' ) ; $ melisTool = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreTool' ) ; $ melisTool -> setMelisToolKey ( self :: PLUGIN_INDEX , self :: TOOL_KEY ) ; $ columns = $ melisTool -> getColumns ( ) ; $ idPage = $ this -> params ( ) -> fromRoute ( 'idPage' , $ this -> params ( ) -> fromQuery ( 'idPage' , '' ) ) ; $ container = new Container ( 'meliscore' ) ; $ locale = $ container [ 'melis-lang-locale' ] ; $ view = new ViewModel ( ) ; $ view -> melisKey = $ melisKey ; $ view -> tableColumns = $ columns ; $ view -> getToolDataTableConfig = $ melisTool -> getDataTableConfiguration ( '#tableHistoricPageId' . $ idPage , true ) ; $ view -> idPage = $ idPage ; $ view -> tableId = 'tableHistoricPageId' . $ idPage ; return $ view ; }
7898	protected function dynamicFrom ( $ from ) { $ provider = Str :: snake ( substr ( $ from , 4 ) ) ; return $ this -> from ( $ provider ) ; }
4473	public function heartbeat ( array $ data = [ ] ) : float { try { $ this -> expires = $ this -> client -> heartbeat ( $ this -> jid , $ this -> worker , json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ) ; } catch ( QlessException $ e ) { throw new LostLockException ( $ e -> getMessage ( ) , 'Heartbeat' , $ this -> jid , $ e -> getCode ( ) , $ e ) ; } return $ this -> expires ; }
12636	protected function getSandboxSignKey ( ) { if ( $ this -> sandboxSignKey ) { return $ this -> sandboxSignKey ; } $ cacheKey = 'sandbox_signkey.' . $ this -> merchant -> merchant_id . $ this -> merchant -> sub_merchant_id ; $ cache = $ this -> getCache ( ) ; $ this -> sandboxSignKey = $ cache -> fetch ( $ cacheKey ) ; if ( ! $ this -> sandboxSignKey ) { $ result = $ this -> request ( self :: API_SANDBOX_SIGN_KEY , [ ] ) ; if ( $ result -> return_code === 'SUCCESS' ) { $ cache -> save ( $ cacheKey , $ result -> sandbox_signkey , 24 * 3600 ) ; return $ this -> sandboxSignKey = $ result -> sandbox_signkey ; } throw new Exception ( $ result -> return_msg ) ; } return $ this -> sandboxSignKey ; }
9507	public function show ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_SHOW ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ log -> entries ( $ level = 'all' ) -> paginate ( $ this -> perPage ) ; $ this -> addBreadcrumbRoute ( trans ( 'foundation::log-viewer.titles.logs-list' ) , 'admin::foundation.system.log-viewer.logs.list' ) ; $ this -> setTitle ( $ title = "Log : {$log->date}" ) ; $ this -> addBreadcrumb ( $ title ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'level' , 'search' , 'entries' ) ) ; }
1821	protected function getQuicknavPages ( $ pid , $ level = 1 , $ host = null ) { global $ objPage ; $ groups = array ( ) ; $ arrPages = array ( ) ; if ( FE_USER_LOGGED_IN ) { $ this -> import ( FrontendUser :: class , 'User' ) ; $ groups = $ this -> User -> groups ; } $ objSubpages = PageModel :: findPublishedRegularWithoutGuestsByPid ( $ pid ) ; if ( $ objSubpages === null ) { return array ( ) ; } ++ $ level ; foreach ( $ objSubpages as $ objSubpage ) { $ _groups = StringUtil :: deserialize ( $ objSubpage -> groups ) ; if ( $ host !== null ) { $ objSubpage -> domain = $ host ; } if ( ! $ objSubpage -> protected || $ this -> showProtected || ( \ is_array ( $ _groups ) && \ is_array ( $ groups ) && array_intersect ( $ _groups , $ groups ) ) ) { if ( ! $ objSubpage -> hide || $ this -> showHidden ) { $ arrPages [ ] = array ( 'level' => ( $ level - 2 ) , 'title' => StringUtil :: specialchars ( StringUtil :: stripInsertTags ( $ objSubpage -> pageTitle ? : $ objSubpage -> title ) ) , 'href' => $ objSubpage -> getFrontendUrl ( ) , 'link' => StringUtil :: stripInsertTags ( $ objSubpage -> title ) , 'active' => ( $ objPage -> id == $ objSubpage -> id || ( $ objSubpage -> type == 'forward' && $ objPage -> id == $ objSubpage -> jumpTo ) ) ) ; if ( ! $ this -> showLevel || $ this -> showLevel >= $ level || ( ! $ this -> hardLimit && ( $ objPage -> id == $ objSubpage -> id || \ in_array ( $ objPage -> id , $ this -> Database -> getChildRecords ( $ objSubpage -> id , 'tl_page' ) ) ) ) ) { $ subpages = $ this -> getQuicknavPages ( $ objSubpage -> id , $ level ) ; if ( \ is_array ( $ subpages ) ) { $ arrPages = array_merge ( $ arrPages , $ subpages ) ; } } } } } return $ arrPages ; }
7289	protected function watch ( OrderInterface $ order ) { if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( $ order -> hasNotifications ( NotificationTypes :: ORDER_ACCEPTED ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ order , OrderStates :: STATE_ACCEPTED ) ) { return ; } $ this -> notify ( NotificationTypes :: ORDER_ACCEPTED , $ order ) ; }
1368	protected function bindService ( ) { $ this -> app -> singleton ( JsonApiService :: class ) ; $ this -> app -> alias ( JsonApiService :: class , 'json-api' ) ; $ this -> app -> alias ( JsonApiService :: class , 'json-api.service' ) ; }
4503	public function replaceWith ( DOMNode $ replacement ) : void { $ this -> parentNode -> insertBefore ( $ replacement , $ this ) ; $ this -> remove ( ) ; }
8355	private function buildModel ( string $ modelName , array $ modelDefinition ) { $ mapping = Mapping :: get ( $ this -> mapping ) ; $ definition = $ this -> getDefinition ( ) ; $ database = GlobalDatabase :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ tableName = null ; if ( isset ( $ modelDefinition [ 'name' ] ) === true ) { $ tableName = $ modelDefinition [ 'name' ] ; } else { $ tableName = Helper :: codifyName ( $ this -> mapping ) . '_' . Helper :: codifyName ( $ modelName ) ; } if ( isset ( $ modelDefinition [ 'fields' ] ) === false ) { throw new InvalidSchemaDefinition ( 'model "' . $ modelName . '" has no field' ) ; } $ statement = Mutation \ AddTable :: statement ( $ database , $ this -> getDefinition ( ) , $ this -> mapping , $ tableName , $ modelName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } if ( isset ( $ modelDefinition [ 'indexes' ] ) === true ) { foreach ( $ modelDefinition [ 'indexes' ] as $ indexName => $ indexDefinition ) { $ statement = Mutation \ AddIndex :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ indexName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } if ( isset ( $ modelDefinition [ 'uniques' ] ) === true ) { foreach ( $ modelDefinition [ 'uniques' ] as $ uniqueName => $ uniqueDefinition ) { $ statement = Mutation \ AddUnique :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ uniqueName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } echo $ modelName . ' - Done' . PHP_EOL ; }
6861	public function doDefaultValueConversionByType ( $ value , $ type , array $ record ) { switch ( $ type ) { case static :: TYPE_DATETIME : return date ( static :: FORMAT_DATETIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_DATE : return date ( static :: FORMAT_DATE , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_TIME : return date ( static :: FORMAT_TIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_MULTILINE : return '<pre class="multiline-text">' . $ value . '</pre>' ; case static :: TYPE_JSON : case static :: TYPE_JSONB : if ( ! is_array ( $ value ) && $ value !== null ) { if ( is_string ( $ value ) || is_numeric ( $ value ) || is_bool ( $ value ) ) { $ value = json_decode ( $ value , true ) ; if ( $ value === null && strtolower ( $ value ) !== 'null' ) { $ value = 'Failed to decode JSON: ' . print_r ( $ value , true ) ; } } else { $ value = 'Invalid value for JSON: ' . print_r ( $ value , true ) ; } } return '<pre class="json-text">' . htmlentities ( stripslashes ( json_encode ( $ value , JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE ) ) ) . '</pre>' ; break ; } return $ value ; }
12541	public static function random ( $ length = 8 , $ allowedChars = 'abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXY346789' ) { $ return = '' ; $ hashLength = strlen ( $ allowedChars ) - 1 ; for ( ; $ length > 0 ; -- $ length ) { $ return .= $ allowedChars { rand ( 0 , $ hashLength ) } ; } return str_shuffle ( $ return ) ; }
11052	public static function sprintt ( $ datatree , $ containers , $ entry = 'main' , $ hsr = _ETS_SOURCE_READ , $ hcr = _ETS_CACHE_READ , $ hcw = _ETS_CACHE_WRITE ) { $ ets = new _ets ( $ containers , $ hsr , $ hcr , $ hcw ) ; return $ ets -> build_all ( $ datatree , $ entry ) ; }
7381	public function route ( bool $ dropIndex = false ) : string { if ( $ dropIndex ) { if ( 'index' == $ this -> route ) { return '' ; } } return $ this -> route ; }
3941	public function maxChildren ( $ conditionType ) { if ( ! isset ( $ GLOBALS [ 'METAMODELS' ] [ 'inputscreen_conditions' ] [ $ conditionType ] [ 'maxChildren' ] ) ) { return null ; } @ trigger_error ( 'Configuring input screen conditions via global array is deprecated. ' . 'Please implement/configure a valid condition factory.' , E_USER_DEPRECATED ) ; return $ GLOBALS [ 'METAMODELS' ] [ 'inputscreen_conditions' ] [ $ conditionType ] [ 'maxChildren' ] ; }
6701	protected function parseString ( $ string ) { $ this -> build = null ; $ this -> major = 0 ; $ this -> minor = 0 ; $ this -> patch = 0 ; $ this -> pre = null ; if ( false === static :: isValid ( $ string ) ) { throw new InvalidArgumentException ( sprintf ( 'The version string "%s" is invalid.' , $ string ) ) ; } if ( false !== strpos ( $ string , '+' ) ) { list ( $ string , $ build ) = explode ( '+' , $ string ) ; $ this -> setBuild ( explode ( '.' , $ build ) ) ; } if ( false !== strpos ( $ string , '-' ) ) { list ( $ string , $ pre ) = explode ( '-' , $ string ) ; $ this -> setPreRelease ( explode ( '.' , $ pre ) ) ; } $ version = explode ( '.' , $ string ) ; $ this -> major = ( int ) $ version [ 0 ] ; if ( isset ( $ version [ 1 ] ) ) { $ this -> minor = ( int ) $ version [ 1 ] ; } if ( isset ( $ version [ 2 ] ) ) { $ this -> patch = ( int ) $ version [ 2 ] ; } }
1709	public function renderContaoBackendTemplate ( array $ blocks = [ ] ) : string { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request || ! $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { return '' ; } $ controller = $ this -> framework -> createInstance ( BackendCustom :: class ) ; $ template = $ controller -> getTemplateObject ( ) ; foreach ( $ blocks as $ key => $ content ) { $ template -> { $ key } = $ content ; } $ response = $ controller -> run ( ) ; return $ response -> getContent ( ) ; }
11176	public static function rand ( $ length = 10 , $ special = false ) { $ characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ; $ special && ( $ characters .= '!@#$%^&*()+=>:;*-~`{}[],' ) ; $ charactersLength = strlen ( $ characters ) ; $ randomString = '' ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ randomString .= $ characters [ rand ( 0 , $ charactersLength - 1 ) ] ; } return $ randomString ; }
9273	public function filter ( $ text ) { $ text = str_replace ( "\r" , '' , $ text ) ; $ text = str_replace ( ' ' , ' &nbsp;' , $ text ) ; $ this -> _parseBbcodeNobbcode ( $ text ) ; $ this -> _parseBbcodeCode ( $ text ) ; $ this -> _parseBbcodeQuote ( $ text ) ; $ this -> _parseBbcodeList ( $ text ) ; $ this -> _parseSimpleBbcode ( 'i' , '<em>$1</em>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'u' , '<u>$1</u>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'b' , '<strong>$1</strong>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'del' , '<del>$1</del>' , $ text ) ; $ this -> _parseSimpleBbcode ( 'strike' , '<del>$1</del>' , $ text ) ; $ this -> _parseParamBbcode ( 'color' , '([a-zA-Z]*|\#?[0-9a-fA-F]{6})' , '<span style="color: $1">$2</span>' , $ text ) ; $ this -> _parseParamBbcode ( 'bgcolor' , '([a-zA-Z]*|\#?[0-9a-fA-F]{6})' , '<span style="background-color: $1">$2</span>' , $ text ) ; $ this -> _parseParamBbcode ( 'align' , '(center|left|right|justify){1}' , '<div style="text-alignement: $1">$2</div>' , $ text ) ; $ this -> _parseParamBbcode ( 'size' , '([0-9].*)' , '<span style="font-size: $1">$2</span>' , $ text ) ; $ this -> _parseBbcodeEmail ( $ text ) ; $ this -> _parseBbcodeUrl ( $ text ) ; $ this -> _parseBbcodeImg ( $ text ) ; $ this -> _parseBbcodeSpoiler ( $ text ) ; $ this -> _parseScriptTags ( $ text ) ; $ this -> _parseSmiley ( $ text ) ; $ this -> _parseBbcodeBr ( $ text ) ; return $ text ; }
5824	public function setMethod ( $ method ) { $ method = strtolower ( $ method ) ; if ( ! array_key_exists ( $ method , $ this -> curl -> getAllowedMethods ( ) ) ) { throw new \ InvalidArgumentException ( "Method [$method] not a valid HTTP method." ) ; } $ this -> method = $ method ; return $ this ; }
1140	protected function computeLevel ( ) { list ( $ node , $ nesting ) = $ this -> determineDepth ( $ this ) ; if ( $ node -> equals ( $ this ) ) return $ this -> ancestors ( ) -> count ( ) ; return $ node -> getLevel ( ) + $ nesting ; }
7309	public static function now ( $ timezone = null ) { $ now = explode ( ' ' , microtime ( ) ) ; $ unix = $ now [ 1 ] ; $ micro = Time :: sec ( $ now [ 0 ] ) ; $ jd = ( $ unix / 86400.0 ) + static :: UJD ; if ( $ timezone == null ) { $ timezone = TimeZone :: UTC ( ) ; } if ( is_string ( $ timezone ) ) { $ timezone = TimeZone :: parse ( $ timezone ) ; } return static :: jd ( $ jd ) -> add ( $ micro ) -> setTimezone ( $ timezone ) ; }
3253	public function clear ( ) { DB :: table ( Config :: get ( 'shop.item_table' ) ) -> where ( 'cart_id' , $ this -> attributes [ 'id' ] ) -> delete ( ) ; $ this -> resetCalculations ( ) ; return $ this ; }
2326	public static function createFromDbResult ( Result $ objResult , $ strTable ) { $ arrModels = array ( ) ; $ strClass = Model :: getClassFromTable ( $ strTable ) ; while ( $ objResult -> next ( ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( $ strTable , $ objResult -> { $ strClass :: getPk ( ) } ) ; if ( $ objModel !== null ) { $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; $ arrModels [ ] = $ objModel ; } else { $ arrModels [ ] = new $ strClass ( $ objResult ) ; } } return new static ( $ arrModels , $ strTable ) ; }
11963	private function setParam ( $ key , $ value , $ allowed_keys ) { if ( in_array ( $ key , $ allowed_keys ) ) { $ this -> { $ key } = $ value ; } }
4511	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } }
6920	static public function validateIdentity ( ExecutionContextInterface $ context , IdentityInterface $ identity , array $ config = [ ] , $ pathPrefix = null ) { $ violationList = $ context -> getValidator ( ) -> validate ( $ identity , [ new Identity ( $ config ) ] ) ; if ( ! empty ( $ pathPrefix ) ) { $ pathPrefix = rtrim ( $ pathPrefix , '.' ) . '.' ; } foreach ( $ violationList as $ violation ) { $ context -> buildViolation ( $ violation -> getMessage ( ) ) -> atPath ( $ pathPrefix . $ violation -> getPropertyPath ( ) ) -> addViolation ( ) ; } }
155	public function scalar ( $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } return $ this -> createCommand ( $ db ) -> queryScalar ( ) ; }
7808	public function setCurlNumRetries ( $ retries ) { if ( ! is_numeric ( $ retries ) || $ retries < 0 ) { throw new \ InvalidArgumentException ( 'Retries value must be numeric and a non-negative number.' ) ; } $ this -> curlNumRetries = $ retries ; return $ this ; }
1300	private function getLocaleForCacheKey ( string $ locale = null ) : string { if ( $ locale ) { return $ locale ; } return $ this -> getEnvironment ( ) -> getDefaultLocale ( ) -> getCode ( ) ; }
6400	public static function init ( ) : void { self :: $ classMap = new CallbackLazyMap ( function ( $ className ) { $ trimmedClassName = trim ( $ className , '\\' ) ; return $ trimmedClassName === $ className ? new ObjectClass ( $ className ) : ObjectClass :: $ classMap -> $ trimmedClassName ; } ) ; }
4808	public function unschedule_specific_event ( $ timestamp = '' ) { if ( empty ( $ timestamp ) ) { $ timestamp = wp_next_scheduled ( $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } wp_unschedule_event ( $ timestamp , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; }
6713	public function getParameter ( $ key , $ default = null ) { if ( array_key_exists ( $ key , $ this -> parameters ) ) { return $ this -> parameters [ $ key ] ; } $ flatKey = $ this -> flatten ( $ key ) ; foreach ( $ this -> parameters as $ index => $ value ) { if ( $ flatKey == $ this -> flatten ( $ index ) ) { return $ value ; } } return $ default ; }
5307	protected function getPathFromPolygon ( SimpleXMLElement $ polygon ) { $ points = $ this -> getValuesFromList ( $ polygon [ 'points' ] ) ; $ path = 'M' . array_shift ( $ points ) . ' ' . array_shift ( $ points ) ; while ( count ( $ points ) ) { $ path .= 'L' . array_shift ( $ points ) . ' ' . array_shift ( $ points ) ; } return $ path . 'Z' ; }
3570	public function __unsetHook ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( $ this -> hasMeta ( $ key ) ) { return $ this -> setMeta ( $ key , null ) ; } return $ next ( $ value , $ args ) ; } ; }
5388	protected function valuesArePossible ( $ values ) { $ matches = array ( ) ; $ widgets = & $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { $ possible = $ widgets [ $ i ] -> getAttribute ( 'value' ) ; if ( in_array ( $ possible , $ values ) ) { $ matches [ ] = $ possible ; } } return ( $ values == $ matches ) ; }
546	protected function getCreateTableSql ( $ table ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> quoteTableName ( $ table -> fullName ) ) -> queryOne ( ) ; if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } return $ sql ; }
3206	private function parse_response_headers ( $ headers ) { $ head = array ( ) ; foreach ( $ headers as $ key => $ value ) { $ tag = explode ( ':' , $ value , 2 ) ; if ( isset ( $ tag [ 1 ] ) ) { $ head [ trim ( $ tag [ 0 ] ) ] = trim ( $ tag [ 1 ] ) ; } else { $ head [ ] = $ value ; if ( preg_match ( '`HTTP/[0-9\.]+\s+([0-9]+)`' , $ value , $ out ) ) { $ head [ 'response_code' ] = intval ( $ out [ 1 ] ) ; } } } return $ head ; }
6234	protected function applyAccessMode ( int $ mode ) : void { if ( $ this -> mode === self :: MODE_CLOSED ) { $ this -> mode = $ mode ; return ; } elseif ( $ mode === $ this -> mode ) { return ; } throw new AccessDeniedException ( 'unable to switch access-mode for existing binary file handle' , 500 ) ; }
10635	public function update ( \ SplSubject $ eventManager ) { $ this -> isUpdate = true ; if ( $ eventManager -> event -> function !== NULL ) { $ this -> { $ eventManager -> event -> function } ( $ eventManager ) ; } }
5937	public function setFunctionalities ( array $ functionalities ) { $ this -> functionalities = [ ] ; foreach ( $ functionalities as $ item ) { $ this -> addFunctionality ( $ item ) ; } return $ this ; }
2903	public function downloadAsText ( Mage_Core_Model_Config_Element $ configNode ) { $ items = array ( ) ; Mage :: helper ( 'sheep_debug' ) -> xml2array ( $ configNode , $ items ) ; $ content = '' ; foreach ( $ items as $ key => $ value ) { $ content .= "$key = $value\n" ; } $ this -> _prepareDownloadResponse ( 'config.txt' , $ content , 'text/plain' ) ; }
11697	public function __ ( $ key , array $ parameters = [ ] , $ locale = null , $ default = null , $ parseBBCode = true ) { return $ this -> translate ( $ key , $ parameters , $ locale , $ default , $ parseBBCode ) ; }
2178	private function addDefaultsToContext ( array $ context ) : array { $ context = array_merge ( $ this -> context , $ context ) ; if ( ! isset ( $ context [ 'request_token' ] ) ) { $ context [ 'request_token' ] = $ this -> getRequestToken ( ) ; } if ( ! isset ( $ context [ 'language' ] ) ) { $ context [ 'language' ] = $ this -> container -> get ( 'translator' ) -> getLocale ( ) ; } if ( ! isset ( $ context [ 'ua' ] ) ) { $ context [ 'ua' ] = $ this -> getUserAgentString ( ) ; } if ( ! isset ( $ context [ 'path' ] ) ) { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ context [ 'host' ] = $ request -> getHost ( ) ; $ context [ 'path' ] = $ request -> getBasePath ( ) ; } return $ context ; }
5177	public function map ( \ Closure $ callback , $ context = [ ] ) : self { $ collection = new static ( ) ; foreach ( $ this -> props as $ key => $ value ) { $ collection -> add ( $ key , $ callback ( $ value , $ key , $ context ) ) ; } return $ collection ; }
3579	protected function metaJoinQuery ( Builder $ query , $ method , ArgumentBag $ args ) { $ alias = $ this -> joinMeta ( $ query , $ args -> get ( 'column' ) ) ; $ method = $ args -> get ( 'function' ) ? : $ method ; return ( in_array ( $ method , [ 'orderBy' , 'lists' , 'pluck' ] ) ) ? $ this -> { "{$method}Meta" } ( $ query , $ args , $ alias ) : $ this -> metaSingleResult ( $ query , $ method , $ alias ) ; }
7565	protected function parse_callback ( $ conditions , $ recursive = true , $ check_root = false ) { return ( $ this -> result = $ this -> root -> getChildrenByMatch ( $ conditions , $ recursive , $ check_root , $ this -> custom_filter_map ) ) ; }
6544	public function currentShardingKey ( ) { return isset ( $ this -> options [ SelectorSourceInterface :: SHARDING_KEY ] ) ? $ this -> options [ SelectorSourceInterface :: SHARDING_KEY ] : null ; }
7892	public function set ( $ property_name , $ value ) { $ this -> validateProperty ( $ property_name , $ value ) ; $ this -> data [ $ property_name ] = $ value ; return $ this ; }
10374	public static function remove ( $ type , $ name ) { if ( isset ( self :: $ data [ $ type ] [ $ name ] ) ) { unset ( self :: $ data [ $ type ] [ $ name ] ) ; } return true ; }
1904	public function execute ( ) { $ arrParams = \ func_get_args ( ) ; if ( ! empty ( $ arrParams ) && \ is_array ( $ arrParams [ 0 ] ) ) { $ arrParams = array_values ( $ arrParams [ 0 ] ) ; } $ this -> replaceWildcards ( $ arrParams ) ; return $ this -> query ( ) ; }
11102	public static function countryCodeThreeToTwo ( $ code ) { if ( ! array_key_exists ( $ code , self :: $ _countryCodes ) ) { return false ; } return self :: $ _countryCodes [ $ code ] ; }
5253	public static function findOrFail ( $ id , array $ columns = [ '*' ] , $ parent = null ) { $ model = static :: find ( $ id , $ columns , [ 'parent' => $ parent ] ) ; if ( is_null ( $ model ) ) { throw new ModelNotFoundException ( get_called_class ( ) , $ id ) ; } return $ model ; }
6915	public function addAttachment ( AttachmentInterface $ attachment ) { if ( ! $ this -> attachments -> contains ( $ attachment ) ) { $ this -> attachments -> add ( $ attachment ) ; } return $ this ; }
9715	private function writeNumberFormat ( $ format , $ ifmt ) { $ record = 0x041E ; $ numberFormatString = StringHelper :: UTF8toBIFF8UnicodeLong ( $ format ) ; $ length = 2 + strlen ( $ numberFormatString ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ ifmt ) . $ numberFormatString ; $ this -> append ( $ header . $ data ) ; }
6267	public static function open ( $ fileName ) { return Reader :: haveExtension ( ) ? new Writer \ DBA ( $ fileName ) : new Writer \ PHP ( $ fileName ) ; }
9996	protected function checkSeparator ( ) { $ line = fgets ( $ this -> fileHandle ) ; if ( $ line === false ) { return ; } if ( ( strlen ( trim ( $ line , "\r\n" ) ) == 5 ) && ( stripos ( $ line , 'sep=' ) === 0 ) ) { $ this -> delimiter = substr ( $ line , 4 , 1 ) ; return ; } return $ this -> skipBOM ( ) ; }
11649	protected function _authenticateCreateSelect ( ) { $ dbSelect = clone $ this -> getDbSelect ( ) ; $ dbSelect -> from ( $ this -> _tableName ) -> where ( "{$this->_identityColumn} = ?" , $ this -> _identity ) -> limit ( 1 ) ; return $ dbSelect ; }
11292	protected function _getAttributeDataWhenUnset ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { if ( $ attributeName != $ this -> getPrimaryKey ( ) ) { if ( $ this -> _isRelation ( $ attributeName ) && ! isset ( $ this -> model_dynamicOff ) ) { $ this -> $ attributeName = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap , $ record ) ; } else { $ this -> $ attributeName = $ this -> _fetchData ( $ attributeName ) ; } } else { $ this -> $ attributeName = null ; } $ this -> beforeGet ( $ attributeName ) ; $ returnValue = $ this -> model_data [ $ attributeName ] ; $ this -> afterGet ( $ attributeName , $ returnValue ) ; return $ returnValue ; }
1729	protected function regenerateSessionId ( ) { @ trigger_error ( 'Using User::regenerateSessionId() has been deprecated and will no longer work in Contao 5.0. Use Symfony authentication instead.' , E_USER_DEPRECATED ) ; $ container = System :: getContainer ( ) ; $ strategy = $ container -> getParameter ( 'security.authentication.session_strategy.strategy' ) ; switch ( $ strategy ) { case SessionAuthenticationStrategy :: NONE : break ; case SessionAuthenticationStrategy :: MIGRATE : $ container -> get ( 'session' ) -> migrate ( ) ; break ; case SessionAuthenticationStrategy :: INVALIDATE : $ container -> get ( 'session' ) -> invalidate ( ) ; break ; default : throw new \ RuntimeException ( sprintf ( 'Invalid session authentication strategy "%s"' , $ strategy ) ) ; } }
7395	protected function _getByName ( $ propName ) { if ( array_key_exists ( $ propName , $ this -> _map ) ) { $ propName = $ this -> _map [ $ propName ] ; } if ( $ this -> { $ propName } instanceof AtomicInterface ) { return $ this -> { $ propName } -> get ( ) ; } $ getter = '_get_' . $ propName ; if ( method_exists ( $ this -> _calledClass , $ getter ) ) { return $ this -> { $ getter } ( ) ; } return $ this -> { $ propName } ; }
4953	public function call ( $ method , $ args = [ ] , $ expect = self :: EXPECT_SELF ) { if ( ! is_array ( $ args ) ) { $ expect = $ args ; $ args = [ ] ; } if ( ! $ this -> helper ) { return $ this -> expected ( $ expect ) ; } return call_user_func_array ( [ $ this -> helper , $ method ] , $ args ) ; }
2052	public static function create ( $ file , $ size = null ) { if ( \ is_string ( $ file ) ) { $ file = new File ( rawurldecode ( $ file ) ) ; } $ imageSize = null ; $ picture = new static ( $ file ) ; if ( \ is_array ( $ size ) && ! empty ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ size = ( int ) $ size [ 2 ] ; } $ imageSize = null ; if ( ! \ is_array ( $ size ) ) { $ imageSize = ImageSizeModel :: findByPk ( $ size ) ; if ( $ imageSize === null ) { $ size = array ( ) ; } } if ( \ is_array ( $ size ) ) { $ size += array ( 0 , 0 , 'crop' ) ; $ imageSize = new \ stdClass ( ) ; $ imageSize -> width = $ size [ 0 ] ; $ imageSize -> height = $ size [ 1 ] ; $ imageSize -> resizeMode = $ size [ 2 ] ; $ imageSize -> zoom = 0 ; } $ picture -> setImageSize ( $ imageSize ) ; if ( $ imageSize !== null && ! empty ( $ imageSize -> id ) ) { $ picture -> setImageSizeItems ( ImageSizeItemModel :: findVisibleByPid ( $ imageSize -> id , array ( 'order' => 'sorting ASC' ) ) ) ; } $ fileRecord = FilesModel :: findByPath ( $ file -> path ) ; if ( $ fileRecord !== null && $ fileRecord -> importantPartWidth && $ fileRecord -> importantPartHeight ) { $ picture -> setImportantPart ( array ( 'x' => ( int ) $ fileRecord -> importantPartX , 'y' => ( int ) $ fileRecord -> importantPartY , 'width' => ( int ) $ fileRecord -> importantPartWidth , 'height' => ( int ) $ fileRecord -> importantPartHeight , ) ) ; } return $ picture ; }
3331	public function fromResource ( $ fp ) { $ tmpfile = tempnam ( sys_get_temp_dir ( ) , 'ucr' ) ; $ temp = fopen ( $ tmpfile , 'w' ) ; while ( ! feof ( $ fp ) ) { fwrite ( $ temp , fread ( $ fp , 8192 ) ) ; } fclose ( $ temp ) ; fclose ( $ fp ) ; return $ this -> fromPath ( $ tmpfile ) ; }
3153	public function storeTraceVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getTraceVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
12874	public function saveAction ( Request $ request , Application $ app ) { $ options = array ( "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "plugin_manager" => $ app [ "red_kite_cms.plugin_manager" ] , "theme_deployer" => $ app [ "red_kite_cms.theme_deployer" ] , "page" => clone ( $ app [ "red_kite_cms.page" ] ) , ) ; return parent :: save ( $ options ) ; }
6890	protected function removeAssignment ( StockAssignmentInterface $ assignment ) { $ this -> unitUpdater -> updateSold ( $ assignment -> getStockUnit ( ) , - $ assignment -> getSoldQuantity ( ) , true ) ; $ assignment -> setSaleItem ( null ) -> setStockUnit ( null ) ; $ this -> persistenceHelper -> remove ( $ assignment ) ; }
922	private function ensureAreTogether ( DocBlock $ doc , Annotation $ first , Annotation $ second ) { $ pos = $ first -> getEnd ( ) ; $ final = $ second -> getStart ( ) ; for ( $ pos = $ pos + 1 ; $ pos < $ final ; ++ $ pos ) { $ doc -> getLine ( $ pos ) -> remove ( ) ; } }
4538	public function setTenantId ( ? string $ tenantId ) { $ this -> tenantId = $ tenantId ; $ this -> _tenantId = null !== $ tenantId ; return $ this ; }
10896	public function setHost ( $ host ) { foreach ( $ this -> uris as $ name => $ uri ) { $ this -> add ( $ name , $ uri -> withHost ( $ host ) ) ; } }
146	protected function moveWatch ( $ fromLiteral , $ toLiteral , $ node ) { if ( ! isset ( $ this -> watchChains [ $ toLiteral ] ) ) { $ this -> watchChains [ $ toLiteral ] = new RuleWatchChain ; } $ node -> moveWatch ( $ fromLiteral , $ toLiteral ) ; $ this -> watchChains [ $ fromLiteral ] -> remove ( ) ; $ this -> watchChains [ $ toLiteral ] -> unshift ( $ node ) ; }
2296	public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ arrUnset [ ] = 'nb' ; return parent :: addToUrl ( $ strRequest . ( ( $ strRequest != '' ) ? '&amp;' : '' ) . 'rt=' . REQUEST_TOKEN , $ blnAddRef , $ arrUnset ) ; }
830	private function processException ( $ name , $ e ) { $ this -> dispatchEvent ( FixerFileProcessedEvent :: NAME , new FixerFileProcessedEvent ( FixerFileProcessedEvent :: STATUS_EXCEPTION ) ) ; $ this -> errorsManager -> report ( new Error ( Error :: TYPE_EXCEPTION , $ name , $ e ) ) ; }
9813	protected function deleteRaw ( string $ path , $ body = null , array $ headers = [ ] ) { $ response = $ this -> client -> delete ( $ path , $ headers , $ body ) ; return ResponseMediator :: getContent ( $ response ) ; }
8987	public static function parseStatus ( $ statusLine ) : HttpStatus { list ( $ proto , $ code ) = sscanf ( $ statusLine , "%s %d %s" ) ; return new HttpStatus ( $ code , $ proto ) ; }
1769	public function __isset ( $ strKey ) { switch ( $ strKey ) { case 'id' : return isset ( $ this -> strId ) ; break ; case 'name' : return isset ( $ this -> strName ) ; break ; case 'label' : return isset ( $ this -> strLabel ) ; break ; case 'value' : return isset ( $ this -> varValue ) ; break ; case 'class' : return isset ( $ this -> strClass ) ; break ; case 'template' : return isset ( $ this -> strTemplate ) ; break ; case 'wizard' : return isset ( $ this -> strWizard ) ; break ; case 'required' : return isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; case 'forAttribute' : return isset ( $ this -> blnForAttribute ) ; break ; case 'dataContainer' : return isset ( $ this -> objDca ) ; break ; case 'activeRecord' : return isset ( $ this -> objDca -> activeRecord ) ; break ; default : return isset ( $ this -> arrAttributes [ $ strKey ] ) || isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; } }
7163	private function buildSaleItemsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasItems ( ) ) { return ; } foreach ( $ sale -> getItems ( ) as $ item ) { $ this -> view -> addItem ( $ this -> buildSaleItemLineView ( $ item ) ) ; } }
445	public function getBehavior ( $ name ) { $ this -> ensureBehaviors ( ) ; return isset ( $ this -> _behaviors [ $ name ] ) ? $ this -> _behaviors [ $ name ] : null ; }
5978	public function objecttypes ( ) { if ( ! $ this -> objecttypes instanceof ObjecttypesController ) { $ this -> objecttypes = new ObjecttypesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> objecttypes -> setLogger ( $ this -> logger ) ; } return $ this -> objecttypes ; }
1357	public function field ( string $ field , string $ inverse = null ) : self { $ this -> defaults = array_merge ( $ this -> defaults , [ ResourceRegistrar :: PARAM_RELATIONSHIP_NAME => $ field , ResourceRegistrar :: PARAM_RELATIONSHIP_INVERSE_TYPE => $ inverse ? : Str :: plural ( $ field ) , ] ) ; return $ this ; }
6925	private function getFindOneByCountryAndMethodAndWeightQuery ( ) { if ( null === $ this -> findOneByCountryAndMethodAndWeightQuery ) { $ qb = $ this -> getCollectionQueryBuilder ( 'o' ) ; $ qb -> join ( 'o.zone' , 'z' ) -> join ( 'o.method' , 'm' ) -> andWhere ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'z.countries' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'o.weight' , ':weight' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.method' , ':method' ) ) -> addOrderBy ( 'o.weight' , 'ASC' ) -> setMaxResults ( 1 ) ; $ this -> findOneByCountryAndMethodAndWeightQuery = $ qb -> getQuery ( ) ; } return $ this -> findOneByCountryAndMethodAndWeightQuery ; }
8721	protected function getTranslatableAttributesFromSchema ( ) { if ( ( ! $ con = $ this -> getConnection ( ) ) || ( ! $ builder = $ con -> getSchemaBuilder ( ) ) ) { return [ ] ; } if ( $ columns = TranslatableConfig :: cacheGet ( $ this -> getI18nTable ( ) ) ) { return $ columns ; } $ columns = $ builder -> getColumnListing ( $ this -> getI18nTable ( ) ) ; unset ( $ columns [ array_search ( $ this -> getForeignKey ( ) , $ columns ) ] ) ; TranslatableConfig :: cacheSet ( $ this -> getI18nTable ( ) , $ columns ) ; return $ columns ; }
9305	public function setEmitEvents ( $ emitEvents ) { if ( ! is_bool ( $ emitEvents ) ) { throw new \ InvalidArgumentException ( '`emitEvents` expects boolean value!' ) ; } $ this -> options [ 'emitEvents' ] = ( bool ) $ emitEvents ; return $ this ; }
7254	static public function isBetterState ( $ stateA , $ stateB ) { if ( $ stateA === static :: STATE_IN_STOCK ) { return $ stateB !== static :: STATE_IN_STOCK ; } elseif ( $ stateA === static :: STATE_PRE_ORDER ) { return $ stateB === static :: STATE_OUT_OF_STOCK ; } return false ; }
1412	public function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_FORBIDDEN , $ this -> trans ( 'resource_client_ids_not_supported' , 'code' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'title' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
12871	public function search ( string $ sFilter , array $ aAttributes ) { return ldap_search ( $ this -> _rConnect , $ this -> _sBase , $ sFilter , $ aAttributes ) ; }
302	public function getAttributeLabel ( $ attribute ) { $ labels = $ this -> attributeLabels ( ) ; if ( isset ( $ labels [ $ attribute ] ) ) { return $ labels [ $ attribute ] ; } elseif ( strpos ( $ attribute , '.' ) ) { $ attributeParts = explode ( '.' , $ attribute ) ; $ neededAttribute = array_pop ( $ attributeParts ) ; $ relatedModel = $ this ; foreach ( $ attributeParts as $ relationName ) { if ( $ relatedModel -> isRelationPopulated ( $ relationName ) && $ relatedModel -> $ relationName instanceof self ) { $ relatedModel = $ relatedModel -> $ relationName ; } else { try { $ relation = $ relatedModel -> getRelation ( $ relationName ) ; } catch ( InvalidParamException $ e ) { return $ this -> generateAttributeLabel ( $ attribute ) ; } $ modelClass = $ relation -> modelClass ; $ relatedModel = $ modelClass :: instance ( ) ; } } $ labels = $ relatedModel -> attributeLabels ( ) ; if ( isset ( $ labels [ $ neededAttribute ] ) ) { return $ labels [ $ neededAttribute ] ; } } return $ this -> generateAttributeLabel ( $ attribute ) ; }
9203	public function get ( $ endpoint , $ params = null ) { $ endpoint = $ this -> prependVersionToEndpoint ( $ endpoint , Config :: get ( 'api_version' ) ) ; $ options = $ this -> constructRequestOptions ( $ params ) ; $ response = $ this -> guzzleClient -> get ( $ endpoint , $ options ) ; return $ response ; }
11239	public function run ( ) { if ( count ( $ this -> errors ) == 0 ) { return true ; } else { $ this -> controller -> setData ( 'errors' , $ this -> errors ) ; return false ; } }
258	public function render ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; return $ this -> renderFile ( $ viewFile , $ params , $ context ) ; }
7717	function FileGetState ( $ NameOrIdx ) { $ idx = $ this -> FileGetIdx ( $ NameOrIdx ) ; if ( $ idx === false ) { $ idx = $ this -> FileGetIdxAdd ( $ NameOrIdx ) ; if ( $ idx === false ) { return false ; } else { return 'a' ; } } elseif ( isset ( $ this -> ReplInfo [ $ idx ] ) ) { if ( $ this -> ReplInfo [ $ idx ] === false ) { return 'd' ; } else { return 'm' ; } } else { return 'u' ; } }
11089	public static function isCzechHoliday ( $ date ) { if ( ! $ date instanceof DateTime ) { if ( \ is_int ( $ date ) ) { $ date = new DateTime ( '@' . $ date ) ; } elseif ( \ is_string ( $ date ) ) { $ date = new DateTime ( $ date ) ; } else { throw new RuntimeException ( self :: poorManTranslate ( 'fts-shared' , 'Invalid date format' ) ) ; } } $ holidays = [ '01-01' , '05-01' , '05-08' , '07-05' , '07-06' , '09-28' , '10-28' , '11-17' , '12-24' , '12-25' , '12-26' ] ; if ( \ in_array ( $ date -> format ( 'm-d' ) , $ holidays , true ) ) { return true ; } $ easterDays = easter_days ( $ date -> format ( 'Y' ) ) ; $ easter = new DateTime ( $ date -> format ( 'Y' ) . '-03-21' ) ; $ easter -> add ( new \ DateInterval ( 'P' . $ easterDays . 'D' ) ) ; $ easter -> sub ( new \ DateInterval ( 'P2D' ) ) ; if ( $ date -> format ( 'Y-m-d' ) === $ easter -> format ( 'Y-m-d' ) ) { return true ; } $ easter -> add ( new \ DateInterval ( 'P3D' ) ) ; return ( $ easter -> format ( 'Y-m-d' ) === $ date -> format ( 'Y-m-d' ) ) ; }
11800	public function substitution ( $ search , $ replace ) { $ this -> body = str_replace ( $ search , $ replace , $ this -> body ) ; return $ this -> body ; }
4438	public function create ( string $ className , string $ performMethod = 'perform' ) { if ( class_exists ( $ className ) == false ) { throw new InvalidArgumentException ( "Could not find job class {$className}." ) ; } if ( method_exists ( $ className , $ performMethod ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Job class "%s" does not contain perform method "%s".' , $ className , $ performMethod ) ) ; } $ instance = new $ className ; if ( $ instance instanceof EventsManagerAwareInterface ) { $ instance -> setEventsManager ( $ this -> getEventsManager ( ) ) ; } return $ instance ; }
4372	public function onOutput ( Event $ event ) { $ this -> data = $ this -> debug -> getData ( ) ; $ this -> channels = array ( ) ; $ str = '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => 'debug' , 'data-channels' => '{{channels}}' , 'data-channel-root' => $ this -> channelNameRoot , ) ) . ">\n" ; if ( $ this -> debug -> getCfg ( 'output.outputCss' ) ) { $ str .= '<style type="text/css">' . "\n" . $ this -> debug -> output -> getCss ( ) . "\n" . '</style>' . "\n" ; } if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<script type="text/javascript">' . \ file_get_contents ( $ this -> debug -> getCfg ( 'filepathScript' ) ) . '</script>' . "\n" ; } $ str .= '<div class="debug-bar"><h3>Debug Log</h3></div>' . "\n" ; $ str .= $ this -> processAlerts ( ) ; if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<div class="loading">Loading <i class="fa fa-spinner fa-pulse fa-2x fa-fw" aria-hidden="true"></i></div>' . "\n" ; } $ str .= '<div class="debug-header m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processSummary ( ) ; $ str .= '</div>' . "\n" ; $ str .= '<div class="debug-content m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processLog ( ) ; $ str .= '</div>' . "\n" ; $ str .= '</div>' . "\n" ; $ str = \ strtr ( $ str , array ( '{{channels}}' => \ htmlspecialchars ( \ json_encode ( $ this -> buildChannelTree ( ) , JSON_FORCE_OBJECT ) ) , ) ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
10178	public function removeRow ( $ row ) { foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ r == $ row ) { $ this -> delete ( $ coord ) ; } } }
5344	public function make ( $ wsdl , array $ classMap = [ ] ) { return new SoapClient ( $ wsdl , [ 'trace' => true , 'exceptions' => true , 'encoding' => 'utf-8' , 'features' => SOAP_SINGLE_ELEMENT_ARRAYS , 'classmap' => $ classMap , 'cache_wsdl' => WSDL_CACHE_MEMORY , ] ) ; }
6854	private function findPaymentTokens ( PaymentInterface $ payment ) { $ identity = $ this -> getPaymentIdentity ( $ payment ) ; $ tokens = $ this -> payum -> getTokenStorage ( ) -> findBy ( [ 'details' => $ identity , ] ) ; return $ tokens ; }
9798	public function setHyperlink ( Hyperlink $ pHyperlink = null ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot set hyperlink for cell that is not bound to a worksheet' ) ; } $ this -> getWorksheet ( ) -> setHyperlink ( $ this -> getCoordinate ( ) , $ pHyperlink ) ; return $ this -> updateInCollection ( ) ; }
11809	protected function fillRelationConfig ( & $ config , $ otherObject ) { if ( isset ( $ config [ 'parent_object_id' ] ) ) { $ config [ 'child_object_id' ] = $ otherObject ; } elseif ( isset ( $ config [ 'child_object_id' ] ) ) { $ config [ 'parent_object_id' ] = $ otherObject ; } }
6187	public function assign ( $ name , $ value ) { if ( ! isset ( $ this -> view ) ) { throw new ViewException ( 'Please Define view engine in app/View.php' , 500 ) ; } return $ this -> view -> assign ( $ name , $ value ) ; }
8438	public function setPostLink ( TimelineLinkEvent $ event ) : void { $ action = $ event -> getAction ( ) ; if ( ! in_array ( $ action -> getVerb ( ) , [ 'post' , 'reply' ] ) ) { return ; } $ production = $ action -> getComponent ( 'indirectComplement' ) -> getData ( ) ; $ post = $ action -> getComponent ( 'directComplement' ) -> getData ( ) ; $ event -> setLink ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) , '_fragment' => 'post-' . $ post -> getId ( ) , ] ) ) ; }
7514	function next_search ( $ characters , $ callback = true ) { $ this -> token_start = $ this -> pos ; if ( ! is_array ( $ characters ) ) { $ characters = array_fill_keys ( str_split ( $ characters ) , true ) ; } while ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ characters [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( $ callback && isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
6698	public function compareTo ( $ version ) { $ major = $ version -> getMajor ( ) ; $ minor = $ version -> getMinor ( ) ; $ patch = $ version -> getPatch ( ) ; $ pre = $ version -> getPreRelease ( ) ; $ build = $ version -> getBuild ( ) ; switch ( true ) { case ( $ this -> major < $ major ) : return 1 ; case ( $ this -> major > $ major ) : return - 1 ; case ( $ this -> minor > $ minor ) : return - 1 ; case ( $ this -> minor < $ minor ) : return 1 ; case ( $ this -> patch > $ patch ) : return - 1 ; case ( $ this -> patch < $ patch ) : return 1 ; } if ( $ pre || $ this -> pre ) { if ( empty ( $ this -> pre ) && $ pre ) { return - 1 ; } if ( $ this -> pre && empty ( $ pre ) ) { return 1 ; } if ( 0 !== ( $ weight = $ this -> precedence ( $ this -> pre , $ pre ) ) ) { return $ weight ; } } if ( $ build || $ this -> build ) { if ( ( null === $ this -> build ) && $ build ) { return 1 ; } if ( $ this -> build && ( null === $ build ) ) { return - 1 ; } return $ this -> precedence ( $ this -> build , $ build ) ; } return 0 ; }
4175	public function getProviders ( ) { return $ this -> providers ? : $ this -> providers = new ServiceProvider ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
3067	public function process ( ) { $ this -> validate ( ) ; $ ref = ( $ this -> getRequestParameter ( 'ref' ) === false ) ? null : $ this -> getRequestParameter ( 'ref' ) ; $ direction = $ this -> getRequestParameter ( 'direction' ) ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = ( $ this -> getRequestParameter ( 'start' ) !== false ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( ! $ this -> getRunnerService ( ) -> isTerminated ( $ serviceContext ) ) { $ this -> endItemTimer ( $ this -> getTime ( ) ) ; $ this -> saveItemState ( ) ; } $ this -> initServiceContext ( ) ; $ this -> saveItemResponses ( false ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ serviceContext -> getTestSession ( ) -> initItemTimer ( $ this -> getTime ( ) ) ; $ result = $ this -> getRunnerService ( ) -> move ( $ serviceContext , $ direction , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } common_Logger :: d ( 'Test session state : ' . $ serviceContext -> getTestSession ( ) -> getState ( ) ) ; if ( $ start === true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { common_Logger :: e ( $ e -> getMessage ( ) ) ; $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
11305	public static function email ( $ email = null , $ errorMsg = null ) { if ( ! $ email ) return null ; $ email = trim ( mb_strtolower ( trim ( $ email ) , "UTF-8" ) ) ; if ( ! filter_var ( $ email , FILTER_VALIDATE_EMAIL ) ) { return null ; } return $ email ; }
7107	static public function round ( $ amount , $ currency ) { $ precision = static :: getPrecision ( $ currency ) ; $ roundingIncrement = static :: getRoundingIncrement ( $ currency ) ; $ amount = round ( $ amount , $ precision , \ PHP_ROUND_HALF_EVEN ) ; if ( 0 < $ roundingIncrement && 0 < $ precision ) { $ roundingFactor = $ roundingIncrement / pow ( 10 , $ precision ) ; $ amount = round ( $ amount / $ roundingFactor ) * $ roundingFactor ; } return $ amount ; }
2625	protected function _toHtml ( ) { if ( $ this -> config -> isGeoIpEnabled ( ) == false || $ this -> config -> isFastlyEnabled ( ) == false ) { return parent :: _toHtml ( ) ; } $ actionUrl = $ this -> getUrl ( 'fastlyCdn/geoip/getaction' ) ; $ header = $ this -> response -> getHeader ( 'x-esi' ) ; if ( empty ( $ header ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } return sprintf ( '<esi:include src=\'%s\' />' , preg_replace ( "/^https/" , "http" , $ actionUrl ) ) ; }
6222	public function getElevation ( $ latitude , $ longitude ) { if ( $ latitude === 0.0 && $ longitude === 0.0 ) { return false ; } if ( ! $ this -> locationIsInBounds ( $ latitude , $ longitude ) ) { throw new InvalidArgumentException ( sprintf ( 'Location (%f, %f) is out of bounds ([-%f, %f], [-%f, %f]).' , $ latitude , $ longitude , static :: MAX_LATITUDE , static :: MAX_LATITUDE , static :: MAX_LONGITUDE , static :: MAX_LONGITUDE ) ) ; } $ filename = $ this -> getFilenameFor ( $ latitude , $ longitude ) ; if ( $ this -> CurrentFilename !== $ filename ) { $ this -> openResource ( $ filename ) ; } return $ this -> getElevationFromResource ( $ latitude , $ longitude ) ; }
4291	private function publishMeta ( ) { $ debugClass = \ get_class ( $ this -> debug ) ; $ metaVals = array ( 'debug_version' => $ debugClass :: VERSION , ) ; $ keys = array ( 'HTTP_HOST' , 'HTTPS' , 'REMOTE_ADDR' , 'REQUEST_METHOD' , 'REQUEST_TIME' , 'REQUEST_URI' , 'SERVER_ADDR' , 'SERVER_NAME' , ) ; foreach ( $ keys as $ k ) { $ metaVals [ $ k ] = isset ( $ _SERVER [ $ k ] ) ? $ _SERVER [ $ k ] : null ; } if ( ! isset ( $ metaVals [ 'REQUEST_URI' ] ) && ! empty ( $ _SERVER [ 'argv' ] ) ) { $ metaVals [ 'REQUEST_URI' ] = '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; } $ this -> processLogEntry ( 'meta' , array ( $ metaVals , ) , array ( 'channel' => $ this -> debug -> getCfg ( 'channel' ) , ) ) ; }
12960	public function query ( $ sql , $ return = false ) { $ query = $ this -> getDb ( ) -> query ( $ sql , true ) ; if ( $ return ) { return $ query ; } }
1637	protected function setupQueue ( QueueManager $ queue ) { $ queue -> looping ( function ( ) { $ this -> app -> bugsnag -> flush ( ) ; $ this -> app -> bugsnag -> clearBreadcrumbs ( ) ; $ this -> app -> make ( Tracker :: class ) -> clear ( ) ; } ) ; if ( ! class_exists ( JobProcessing :: class ) ) { return ; } $ queue -> before ( function ( JobProcessing $ event ) { $ this -> app -> bugsnag -> setFallbackType ( 'Queue' ) ; $ job = [ 'name' => $ event -> job -> getName ( ) , 'queue' => $ event -> job -> getQueue ( ) , 'attempts' => $ event -> job -> attempts ( ) , 'connection' => $ event -> connectionName , ] ; if ( method_exists ( $ event -> job , 'resolveName' ) ) { $ job [ 'resolved' ] = $ event -> job -> resolveName ( ) ; } $ this -> app -> make ( Tracker :: class ) -> set ( $ job ) ; } ) ; }
6452	public function findLabels ( $ text ) { $ xpath = new XPath \ InaccurateText ( '//label[@for]' , $ this -> getWorkingElement ( ) ) ; $ labels = [ ] ; foreach ( $ xpath -> text ( $ text ) -> findAll ( ) as $ label ) { $ labels [ $ label -> getAttribute ( 'for' ) ] = $ label ; } return $ labels ; }
1848	protected function getMetaFields ( $ objArticle ) { $ meta = StringUtil :: deserialize ( $ this -> news_metaFields ) ; if ( ! \ is_array ( $ meta ) ) { return array ( ) ; } global $ objPage ; $ return = array ( ) ; foreach ( $ meta as $ field ) { switch ( $ field ) { case 'date' : $ return [ 'date' ] = Date :: parse ( $ objPage -> datimFormat , $ objArticle -> date ) ; break ; case 'author' : if ( ( $ objAuthor = $ objArticle -> getRelated ( 'author' ) ) instanceof UserModel ) { $ return [ 'author' ] = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'by' ] . ' <span itemprop="author">' . $ objAuthor -> name . '</span>' ; } break ; case 'comments' : if ( $ objArticle -> noComments || $ objArticle -> source != 'default' ) { break ; } $ bundles = System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( ! isset ( $ bundles [ 'ContaoCommentsBundle' ] ) ) { break ; } $ intTotal = CommentsModel :: countPublishedBySourceAndParent ( 'tl_news' , $ objArticle -> id ) ; $ return [ 'ccount' ] = $ intTotal ; $ return [ 'comments' ] = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'commentCount' ] , $ intTotal ) ; break ; } } return $ return ; }
7477	public function downloadAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ file = $ em -> find ( 'Orkestra\Bundle\ApplicationBundle\Entity\File' , $ id ) ; if ( ! $ file ) { throw $ this -> createNotFoundException ( 'Unable to locate File' ) ; } $ securityContext = $ this -> get ( 'security.authorization_checker' ) ; foreach ( $ file -> getGroups ( ) as $ group ) { if ( ! $ securityContext -> isGranted ( $ group -> getRole ( ) ) ) { throw $ this -> createNotFoundException ( 'Unable to locate File' ) ; } } return new Response ( $ file -> getContent ( ) , 200 , array ( 'Content-Type' => $ file -> getMimeType ( ) , 'Content-Disposition' => sprintf ( 'attachment; filename="%s"' , $ file -> getFilename ( ) ) ) ) ; }
8669	protected function computeFileSystemDifferences ( ) { $ entityPathByFilesystems = [ ] ; foreach ( $ this -> resourceManager -> getResourceConfigurations ( ) as $ resourceConfiguration ) { $ className = $ resourceConfiguration -> getEntity ( ) ; $ entityManager = $ this -> doctrine -> getManagerForClass ( $ className ) ; if ( ! $ entityManager instanceof EntityManagerInterface ) { throw new \ UnexpectedValueException ( "No manager found for class {$className}" ) ; } $ repository = $ entityManager -> getRepository ( $ className ) ; if ( ! $ repository instanceof ResourceRepositoryInterface ) { throw new \ UnexpectedValueException ( "Repository for class {$className} must implement ResourceRepositoryInterface" ) ; } $ paths = $ repository -> getPaths ( ) ; $ adapterReference = $ this -> adaptersByResourceType [ $ resourceConfiguration -> getCode ( ) ] ; if ( array_key_exists ( $ adapterReference , $ entityPathByFilesystems ) ) { $ entityPathByFilesystems [ $ adapterReference ] = array_merge ( $ entityPathByFilesystems [ $ adapterReference ] , $ paths ) ; } else { $ entityPathByFilesystems [ $ adapterReference ] = $ paths ; } } foreach ( $ this -> adapters as $ adapterReference => $ adapter ) { $ existingPaths = [ ] ; foreach ( $ adapter -> listContents ( ) as $ metadata ) { $ entityPath = $ metadata [ 'path' ] ; if ( '.gitkeep' === $ entityPath ) { continue ; } $ existingPaths [ $ entityPath ] = $ entityPath ; } $ entityPaths = $ entityPathByFilesystems [ $ adapterReference ] ; $ this -> extraFiles [ $ adapterReference ] = array_diff_key ( $ existingPaths , $ entityPaths ) ; $ this -> missingFiles [ $ adapterReference ] = array_diff_key ( $ entityPaths , $ existingPaths ) ; } }
6606	public function validateAccessTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'access token' ) ; } return true ; }
5707	public function getButtonLink ( ) { $ link = Controller :: join_links ( 'customaction' , $ this -> actionName ) ; return $ this -> gridFieldRequest -> Link ( $ link ) ; }
5491	protected function describeDifference ( $ expected , $ parameters ) { if ( count ( $ expected ) != count ( $ parameters ) ) { return sprintf ( 'Expected %s arguments of [%s], but got %s arguments of [%s]' , count ( $ expected ) , $ this -> renderArguments ( $ expected ) , count ( $ parameters ) , $ this -> renderArguments ( $ parameters ) ) ; } $ messages = array ( ) ; for ( $ i = 0 ; $ i < count ( $ expected ) ; $ i ++ ) { $ comparison = $ this -> forceToExpectation ( $ expected [ $ i ] ) ; if ( ! $ comparison -> test ( $ parameters [ $ i ] ) ) { $ messages [ ] = 'parameter ' . ( $ i + 1 ) . ' with [' . $ comparison -> overlayMessage ( $ parameters [ $ i ] , $ this -> getDumper ( ) ) . ']' ; } } return 'Parameter expectation differs at ' . implode ( ' and ' , $ messages ) ; }
11267	public function view ( $ pathname = '' , $ data = false , $ return = false ) { if ( is_array ( $ data ) || is_object ( $ data ) ) { foreach ( $ data as $ key => $ value ) { $ $ key = $ value ; } } if ( $ pathname == '' ) { $ pathname = $ this -> config [ 'template' ] ; } $ fullPath = $ this -> config [ 'pathToViews' ] . $ this -> getPath ( $ pathname ) ; $ path = $ this -> getPath ( $ pathname ) ; $ this -> debug ( 'Full Path: ' . $ fullPath ) ; $ fileName = $ this -> config [ 'viewsPrefix' ] . $ this -> getName ( $ pathname ) . $ this -> config [ 'viewsPostfix' ] . '.php' ; $ filePath = $ this -> _getFilePath ( $ pathname , $ fileName ) ; $ this -> debug ( '' ) ; $ this -> debug ( 'Searching for View: ' ) ; $ this -> debug ( 'View Name: ' . $ this -> getName ( $ pathname ) ) ; $ this -> debug ( 'View Path: ' . $ this -> getPath ( $ pathname ) ) ; $ this -> debug ( 'File Path: ' . $ filePath ) ; $ this -> debug ( '' ) ; if ( $ return || $ this -> neverOutput ) { ob_start ( ) ; $ inc = include ( $ filePath ) ; if ( $ inc == false && $ this -> config [ 'mode' ] == 'development' ) { throw new \ Exception ( "Can't find file '$fileName' using path '$filePath'" ) ; } return ob_get_clean ( ) ; } else { $ inc = include ( $ filePath ) ; if ( $ inc == false && $ this -> config [ 'mode' ] == 'development' ) { throw new \ Exception ( "Can't find file '$fileName' using path '$filePath'" ) ; } } }
3263	public static function format ( $ value ) { return preg_replace ( [ '/:symbol/' , '/:price/' , '/:currency/' ] , [ Config :: get ( 'shop.currency_symbol' ) , $ value , Config :: get ( 'shop.currency' ) ] , Config :: get ( 'shop.display_price_format' ) ) ; }
3270	public function appendToFile ( string $ line ) { $ file = $ this -> openFile ( static :: FILE_APPEND ) ; $ file -> fwrite ( $ line ) ; $ this -> closeFile ( $ file ) ; }
9833	public function setWorkbookPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> workbookPassword = $ pValue ; return $ this ; }
2087	public static function getDefaultPath ( $ template , $ format ) { $ file = $ template . '.' . $ format ; $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ files [ $ template ] ) ) { return $ rootDir . '/' . self :: $ files [ $ template ] . '/' . $ file ; } $ strPath = null ; try { foreach ( $ container -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> name ( $ file ) as $ file ) { $ strPath = $ file -> getPathname ( ) ; } } catch ( \ InvalidArgumentException $ e ) { } if ( $ strPath !== null ) { return $ strPath ; } throw new \ Exception ( 'Could not find template "' . $ template . '"' ) ; }
11048	function add_system_var ( & $ datatree , $ index , $ last , $ key ) { $ datatree -> _key = $ key ; $ datatree -> _index = $ index ; $ datatree -> _rank = $ index + 1 ; $ datatree -> _odd = $ datatree -> _not_even = ( 1 == $ datatree -> _rank % 2 ) ; $ datatree -> _even = $ datatree -> _not_odd = ( 0 == $ datatree -> _rank % 2 ) ; $ datatree -> _first = ( 0 == $ index ) ; $ datatree -> _middle = ! $ datatree -> _first && ! $ last ; $ datatree -> _last = $ last ; $ datatree -> _not_first = ! $ datatree -> _first ; $ datatree -> _not_last = ! $ last ; $ datatree -> _not_middle = ! $ datatree -> _middle ; }
12293	public function update ( array $ data , $ id ) { $ resource = $ this -> model -> find ( $ id ) ; if ( ! $ resource ) { return '' ; } $ resource -> update ( $ data ) ; return $ resource ; }
11423	public function batchGet ( array $ openIds , $ lang = 'zh_CN' ) { $ params = [ ] ; $ params [ 'user_list' ] = array_map ( function ( $ openId ) use ( $ lang ) { return [ 'openid' => $ openId , 'lang' => $ lang , ] ; } , $ openIds ) ; return $ this -> parseJSON ( 'json' , [ self :: API_BATCH_GET , $ params ] ) ; }
7674	function TbsStoreLoad ( $ idx , $ file = false ) { $ this -> TBS -> Source = $ this -> TbsStoreGet ( $ idx , false ) ; $ this -> TbsCurrIdx = $ idx ; if ( $ file === false ) $ file = $ this -> TbsGetFileName ( $ idx ) ; $ this -> TBS -> OtbsCurrFile = $ file ; }
6402	public static function register ( ) { set_error_handler ( function ( $ code , $ message , $ file , $ line , $ context ) { if ( error_reporting ( ) == 0 ) { return false ; } ErrorType :: forCode ( $ code ) -> throwException ( $ message , $ file , $ line , $ context ) ; } ) ; }
10302	private function writePrintSettings ( $ objWriter ) { $ objWriter -> startElement ( 'c:printSettings' ) ; $ objWriter -> startElement ( 'c:headerFooter' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:pageMargins' ) ; $ objWriter -> writeAttribute ( 'footer' , 0.3 ) ; $ objWriter -> writeAttribute ( 'header' , 0.3 ) ; $ objWriter -> writeAttribute ( 'r' , 0.7 ) ; $ objWriter -> writeAttribute ( 'l' , 0.7 ) ; $ objWriter -> writeAttribute ( 't' , 0.75 ) ; $ objWriter -> writeAttribute ( 'b' , 0.75 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:pageSetup' ) ; $ objWriter -> writeAttribute ( 'orientation' , 'portrait' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
9113	public function setUp ( ) { $ this -> controllers = array ( ) ; $ this -> views = array ( ) ; $ this -> viewControls = array ( ) ; $ this -> setDefaults ( ) ; $ this -> init ( ) ; $ this -> setLogger ( new NullLogger ( ) ) ; return $ this ; }
7313	public function setDate ( $ year , $ month , $ day ) { $ status = IAU :: Cal2jd ( ( int ) $ year , ( int ) $ month , ( int ) $ day , $ djm0 , $ djm ) ; $ this -> checkDate ( $ status ) ; $ this -> jd = $ djm0 + $ djm ; return $ this ; }
10097	private function writeBIFF8CellRangeAddressFixed ( $ range ) { $ explodes = explode ( ':' , $ range ) ; $ firstCell = $ explodes [ 0 ] ; if ( count ( $ explodes ) == 1 ) { $ lastCell = $ firstCell ; } else { $ lastCell = $ explodes [ 1 ] ; } $ firstCellCoordinates = Coordinate :: coordinateFromString ( $ firstCell ) ; $ lastCellCoordinates = Coordinate :: coordinateFromString ( $ lastCell ) ; return pack ( 'vvvv' , $ firstCellCoordinates [ 1 ] - 1 , $ lastCellCoordinates [ 1 ] - 1 , Coordinate :: columnIndexFromString ( $ firstCellCoordinates [ 0 ] ) - 1 , Coordinate :: columnIndexFromString ( $ lastCellCoordinates [ 0 ] ) - 1 ) ; }
4434	public function call ( string $ command , ... $ arguments ) { $ arguments = func_get_args ( ) ; array_shift ( $ arguments ) ; return $ this -> __call ( $ command , $ arguments ) ; }
10415	public function updateTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( ! $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return false ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ oldTable = $ schemaManager -> listTableDetails ( $ this -> tableName ) ; $ comparator = new Comparator ( ) ; $ diff = $ comparator -> diffTable ( $ oldTable , $ table ) ; if ( ! $ diff ) { return null ; } $ schemaManager -> alterTable ( $ diff ) ; return true ; }
5584	public function click ( $ label ) { $ raw = $ this -> clickSubmit ( $ label ) ; if ( ! $ raw ) { $ raw = $ this -> clickLink ( $ label ) ; } if ( ! $ raw ) { $ raw = $ this -> clickImage ( $ label ) ; } return $ raw ; }
9461	public function appendValueFilter ( $ key , $ value ) { if ( ! empty ( $ value ) ) { if ( $ this -> getValues ( $ key ) ) { return $ this -> append ( $ key , $ value ) ; } else { return $ this -> addValuesFilter ( $ key , [ $ value ] ) ; } } else { return $ this ; } }
2768	public function checkoutNewBranch ( string $ branch , array $ options = [ ] ) : string { $ options [ 'b' ] = true ; return $ this -> checkout ( $ branch , $ options ) ; }
8473	public function warning ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'warning' , $ scope , $ message , $ context , $ config ) ; }
1929	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ return = '<pre>' . StringUtil :: specialchars ( $ this -> code ) . '</pre>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
8038	public function find ( $ identifier , array $ fields = [ ] ) { $ results = $ this -> ldap -> search ( $ this -> base_dn , $ this -> search_filter . '=' . $ identifier , ( $ fields ? : $ this -> search_fields ) ) ; if ( count ( $ results ) > 0 ) { $ entry = $ this -> ldap -> entry ( $ results ) ; if ( isset ( $ entry [ 0 ] ) && ! empty ( $ entry [ 0 ] ) ) { return $ entry [ 0 ] ; } } throw new EmptySearchResultException ; }
9026	public function hasEmail ( $ string ) { $ result = false ; $ tokenizer = new General ( ) ; $ words = $ tokenizer -> tokenize ( $ string ) ; foreach ( $ words as $ word ) { if ( filter_var ( $ word , FILTER_VALIDATE_EMAIL ) ) { $ result = true ; } } return $ result ; }
9494	private function formatSize ( $ bytes ) { $ kb = 1024 ; $ mb = $ kb * 1024 ; $ gb = $ mb * 1024 ; $ tb = $ gb * 1024 ; if ( ( $ bytes >= 0 ) && ( $ bytes < $ kb ) ) { return $ bytes . ' B' ; } elseif ( ( $ bytes >= $ kb ) && ( $ bytes < $ mb ) ) { return ceil ( $ bytes / $ kb ) . ' KB' ; } elseif ( ( $ bytes >= $ mb ) && ( $ bytes < $ gb ) ) { return ceil ( $ bytes / $ mb ) . ' MB' ; } elseif ( ( $ bytes >= $ gb ) && ( $ bytes < $ tb ) ) { return ceil ( $ bytes / $ gb ) . ' GB' ; } elseif ( $ bytes >= $ tb ) { return ceil ( $ bytes / $ tb ) . ' TB' ; } return $ bytes . ' B' ; }
10732	public function getSecond ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'second' ] ; } }
8205	protected function getJobStats ( $ job ) { try { return ( array ) $ this -> getPheanstalk ( ) -> statsJob ( $ job ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
9267	public function recipe ( string $ string , string $ method , callable $ callback = null ) : string { return preg_replace_callback ( RegEx :: REGEX_SPACE , [ $ this , $ method ] , $ this -> callback ( $ string , $ callback ) ) ; }
7929	public function setDefaultGroup ( $ defaultGroup ) { list ( $ defaultGroup ) = $ this -> fireEvent ( 'default-group.set' , [ $ defaultGroup ] ) ; $ this -> defaultGroup = $ defaultGroup ; return $ this ; }
4297	public function clear ( $ flags = self :: CLEAR_LOG ) { array ( $ flags ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'flags' => self :: CLEAR_LOG ) , array ( 'flags' => 'bitmask' ) ) ; $ event = $ this -> methodClear -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ) ; $ this -> setLogDest ( 'log' ) ; $ collect = $ this -> cfg [ 'collect' ] ; $ this -> cfg [ 'collect' ] = true ; if ( $ event [ 'log' ] ) { $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; } elseif ( $ event [ 'publish' ] ) { $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ event ) ; } $ this -> cfg [ 'collect' ] = $ collect ; $ this -> setLogDest ( 'auto' ) ; }
4566	public function getForms ( $ id ) { $ forms = [ ] ; $ form = $ this -> getForm ( $ id ) ; $ form -> setMethod ( 'POST' ) -> setPrimary ( true ) ; $ forms [ ] = $ form ; switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ extract = function ( & $ container , $ key , & $ component ) use ( & $ extract , & $ forms , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as $ key => & $ subComponent ) { $ extract ( $ component -> components , $ key , $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as $ key => & $ subComponent ) { $ extract ( $ column -> components , $ key , $ subComponent ) ; } } break ; case property_exists ( $ component , 'properties' ) && is_object ( $ component -> properties ) && property_exists ( $ component -> properties , 'ds_form' ) : $ form = $ this -> getForm ( $ component -> properties -> ds_form ) ; $ data = [ ] ; if ( property_exists ( $ component , 'defaultValue' ) ) { try { $ data = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ data = [ ] ; } catch ( UnmatchedException $ exception ) { } } $ form -> setData ( $ data ) ; $ forms [ ] = $ form ; unset ( $ container [ $ key ] ) ; break ; } } ; foreach ( $ components as $ key => & $ component ) { $ extract ( $ components , $ key , $ component ) ; } $ form -> setSchema ( array_values ( $ components ) ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ forms ; }
7926	public function fireEvent ( $ event , array $ args = [ ] ) { if ( isset ( $ this -> eventListeners [ $ event ] ) === false ) return $ args ; foreach ( $ this -> eventListeners [ $ event ] as $ listener ) call_user_func_array ( $ listener , $ args ) ; return $ args ; }
10347	public function current ( ) { $ minute = current ( $ this -> minutes ) ; $ hour = current ( $ this -> hours ) ; $ monthAndDay = current ( $ this -> monthAndDays ) ; $ currentElement = strtotime ( sprintf ( '%d-%s %02d:%02d:00' , $ this -> year + $ this -> yearOffset , $ monthAndDay , $ hour , $ minute ) ) ; if ( $ currentElement < $ this -> getCurrentTime ( ) ) { $ currentElement = $ this -> getNextFutureTimestamp ( ) ; } return $ currentElement ; }
6020	public function removeMediaFromDeploymentSite ( $ id , $ mediaIds ) { $ parameters = [ 'query' => [ 'mediaIds' => $ mediaIds ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/deployment/' . $ id . '/media' , $ parameters ) ; return $ result ; }
4287	public function getSubscriptions ( ) { if ( ! $ this -> isConnected ( ) ) { $ this -> debug -> alert ( 'WAMP publisher not connected to WAMP router' ) ; return array ( ) ; } $ this -> publishMeta ( ) ; $ this -> processExistingData ( ) ; return array ( 'debug.log' => array ( 'onLog' , PHP_INT_MAX * - 1 ) , 'errorHandler.error' => 'onError' , 'php.shutdown' => array ( 'onShutdown' , PHP_INT_MAX * - 1 ) , ) ; }
11960	public function reduce ( Closure $ fn , $ initial = null ) { return array_reduce ( $ this -> elements , $ fn , $ initial ) ; }
4683	public static function stop ( $ key = 'default' ) : void { if ( isset ( self :: $ timers [ $ key ] ) ) { self :: $ timers [ $ key ] -> stop ( ) ; } else { throw new \ LogicException ( 'Stopping timer when the given key timer was not initialized.' ) ; } }
2784	private function indent ( $ output , $ asArray = false ) { $ lines = explode ( "\n" , $ output ) ; $ out = [ ] ; foreach ( $ lines as $ line ) { $ out [ ] = ' > ' . $ line ; } if ( $ asArray ) { return $ out ; } $ return = implode ( "\n" , $ out ) ; return $ return ; }
12698	static function archiveDir ( $ sourcedir , $ archivefile , $ no_top_dir = false ) { $ archivefile = str_replace ( '\\' , '/' , $ archivefile ) ; $ sourcedir = str_replace ( '\\' , '/' , realpath ( $ sourcedir ) ) ; if ( $ no_top_dir ) { $ srcdir = '.' ; $ workdir = $ sourcedir ; } else { $ srcdir = basename ( $ sourcedir ) ; $ workdir = dirname ( $ sourcedir ) ; } $ archivedir = dirname ( $ archivefile ) ; $ extra = '' ; $ tar = self :: getTool ( 'tar' ) ; if ( substr ( $ archivefile , - 7 ) == '.tar.gz' || substr ( $ archivefile , - 4 ) == '.tgz' ) { $ cmd = "$tar -z -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 8 ) == '.tar.bz2' ) { $ cmd = "$tar -j -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 4 ) == '.tar' ) { $ cmd = "$tar -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 4 ) == '.zip' ) { $ zip = self :: getTool ( 'zip' ) ; $ cmd = "$zip -9 -r" ; } else { throw new pakeException ( "Can not determine archive type from filename: $archivefile" ) ; } pake_sh ( self :: getCdCmd ( $ workdir ) . " && $cmd $archivefile $extra $srcdir" ) ; pake_echo_action ( 'file+' , $ archivefile ) ; }
8051	public function getAllEvents ( ) : array { $ calendarEvents = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: ALL_EVENTS_KEY ) ) { return $ cache :: get ( self :: ALL_EVENTS_KEY ) ; } $ allEvents = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> get ( ) ; $ calendarEvents = $ allEvents -> keyBy ( 'id' ) -> toArray ( ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ calendarEvents , $ this -> cacheTimeToLive ) ; return $ calendarEvents ; }
3111	public function getStorageService ( ) { if ( ! $ this -> storageService ) { $ this -> storageService = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storageService ; }
1344	public function isReadResource ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
7049	protected function buildGoodsLines ( Document \ DocumentInterface $ document ) { foreach ( $ document -> getSale ( ) -> getItems ( ) as $ item ) { $ this -> buildGoodLine ( $ item , $ document ) ; } }
3950	private function buildChildOperationButton ( $ idParameter , $ itemId , $ href , $ label , $ name , $ icon , $ attributes , $ table ) { $ modelId = ModelId :: fromValues ( $ table , $ itemId ) ; $ url = $ href . '&amp;' . $ idParameter . '=' . $ modelId -> getSerialized ( ) ; if ( 'id' !== $ idParameter ) { $ url .= '&amp;id=' ; } $ url = $ this -> controller -> addToUrl ( $ url ) ; if ( 'id' !== $ idParameter ) { $ url = preg_replace ( '#(&amp;)id=(?:&amp;)?#' , '$1' , $ url ) ; } $ title = sprintf ( $ label ? : $ name , $ itemId ) ; return sprintf ( '<a href="%1$s" title="%2$s"%3$s>%4$s</a> ' , $ url , specialchars ( $ title ) , $ attributes , $ this -> iconBuilder -> getBackendIconImageTag ( $ icon , $ label ) ) ; }
159	public function having ( $ condition , $ params = [ ] ) { $ this -> having = $ condition ; $ this -> addParams ( $ params ) ; return $ this ; }
5864	public function getDirectoryPattern ( $ directory ) { $ pattern = '/^' . str_replace ( '/' , '\\/' , $ directory ) . '/' ; $ pattern = str_replace ( '\\/**\\/' , '\\/([^\/]+\\/)*' , $ pattern ) ; $ pattern = str_replace ( '\\/*\\/' , '\\/[^\/]+\\/' , $ pattern ) ; return $ pattern ; }
931	public function clear ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> content = '' ; $ this -> id = null ; $ this -> isArray = false ; }
6242	public function reload ( ) : self { if ( $ this -> loaded === false ) { return $ this ; } clearstatcache ( false , $ this -> raw ) ; $ this -> loaded = false ; return $ this ; }
3945	public function onLoadDataContainer ( $ tableName ) { static $ tableExists ; if ( null === $ tableExists ) { $ tableExists = \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' ] ) ; } if ( false === $ tableExists ) { return ; } $ this -> handleMetaModelTable ( $ tableName ) ; $ this -> handleNonMetaModelTable ( $ tableName ) ; }
2773	public function fetchTags ( ) : array { $ output = $ this -> gitWorkingCopy -> tag ( [ 'l' => true ] ) ; $ tags = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimTags' ] , $ tags ) ; }
8730	public function getCanSelectFolder ( ) { if ( ! $ this -> isActive ( ) ) { return false ; } if ( $ this -> template && in_array ( $ this -> template , self :: config ( ) -> disable_for_templates ) ) { return false ; } $ can = $ this -> canSelectFolder ; return ( is_bool ( $ can ) ) ? $ can : Permission :: check ( $ can ) ; }
1427	protected function modelRelationForField ( $ field ) { return $ this -> camelCaseRelations ? Str :: camelize ( $ field ) : Str :: underscore ( $ field ) ; }
9557	public function addMany ( $ parameters ) { foreach ( $ parameters as $ parameter ) { $ this -> prefixes [ $ parameter -> prefix ] [ $ parameter -> parameterName ] = $ parameter ; } return $ this ; }
11338	public function getPrimaryKeyLocation ( $ table ) { $ count = 0 ; foreach ( $ table -> columns as $ column ) { if ( $ column -> isPrimaryKey ) { $ count ++ ; } if ( $ count > 1 ) { return 'index' ; } } return 'table_build' ; }
10781	public function assetFunction ( $ asset , $ serverPath = false ) { $ request = isset ( $ this -> container [ 'request' ] ) ? $ this -> container [ 'request' ] : null ; $ path = \ ltrim ( $ asset , '/\\' ) ; $ assetPath = Utils :: fixPath ( $ this -> container -> getRootDir ( ) . '/' . $ path ) ; if ( ! $ serverPath ) if ( $ request instanceof Request ) $ assetPath = $ request -> getSchemeAndHttpHost ( ) . '/' . $ path ; else $ assetPath = '/' . $ path ; return $ assetPath ; }
2928	public function getKeys ( $ keys = [ ] ) { $ allKeys = $ this -> reader -> keys ( ) ; return array_filter ( $ allKeys , function ( $ key ) use ( $ keys ) { if ( ! empty ( $ keys ) ) { return in_array ( $ key , $ keys ) ; } return true ; } , ARRAY_FILTER_USE_KEY ) ; }
4268	public function dir_opendir ( $ path , $ options = 0 ) { if ( $ this -> handle ) { return false ; } array ( $ options ) ; self :: restorePrev ( ) ; $ this -> handle = \ opendir ( $ path ) ; self :: register ( ) ; return $ this -> handle !== false ; }
3457	protected function replay ( Iterator $ historyEvents ) : void { foreach ( $ historyEvents as $ pastEvent ) { $ this -> version = $ pastEvent -> version ( ) ; $ this -> apply ( $ pastEvent ) ; } }
4978	public function filter ( $ value ) { return isset ( $ this -> map [ $ value ] ) ? $ this -> map [ $ value ] : $ value ; }
610	public function get ( $ class , $ params = [ ] , $ config = [ ] ) { if ( isset ( $ this -> _singletons [ $ class ] ) ) { return $ this -> _singletons [ $ class ] ; } elseif ( ! isset ( $ this -> _definitions [ $ class ] ) ) { return $ this -> build ( $ class , $ params , $ config ) ; } $ definition = $ this -> _definitions [ $ class ] ; if ( is_callable ( $ definition , true ) ) { $ params = $ this -> resolveDependencies ( $ this -> mergeParams ( $ class , $ params ) ) ; $ object = call_user_func ( $ definition , $ this , $ params , $ config ) ; } elseif ( is_array ( $ definition ) ) { $ concrete = $ definition [ 'class' ] ; unset ( $ definition [ 'class' ] ) ; $ config = array_merge ( $ definition , $ config ) ; $ params = $ this -> mergeParams ( $ class , $ params ) ; if ( $ concrete === $ class ) { $ object = $ this -> build ( $ class , $ params , $ config ) ; } else { $ object = $ this -> get ( $ concrete , $ params , $ config ) ; } } elseif ( is_object ( $ definition ) ) { return $ this -> _singletons [ $ class ] = $ definition ; } else { throw new InvalidConfigException ( 'Unexpected object definition type: ' . gettype ( $ definition ) ) ; } if ( array_key_exists ( $ class , $ this -> _singletons ) ) { $ this -> _singletons [ $ class ] = $ object ; } return $ object ; }
2166	public static function convertOrderField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field LIKE '%,%'" ) ; while ( $ objRow -> next ( ) ) { $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( serialize ( explode ( ',' , $ objRow -> $ field ) ) , $ objRow -> id ) ; } static :: convertMultiField ( $ table , $ field ) ; }
1338	public static function defaultApi ( string $ name ) : self { if ( empty ( $ name ) ) { throw new \ InvalidArgumentException ( 'Default API name must not be empty.' ) ; } self :: $ defaultApi = $ name ; return new self ( ) ; }
7508	function setWhitespace ( $ ws ) { if ( is_array ( $ ws ) ) { $ this -> whitespace = array_fill_keys ( array_values ( $ ws ) , true ) ; $ this -> buildCharMap ( ) ; } else { $ this -> setWhiteSpace ( str_split ( $ ws ) ) ; } }
2618	public function getSiteLocation ( ) { $ countryId = $ this -> scopeConfig -> getValue ( 'general/store_information/country_id' ) ; if ( $ countryId ) { $ country = $ this -> countryFactory -> create ( ) -> loadByCode ( $ countryId ) ; $ countryName = $ country -> getName ( ) ; } else { $ countryName = 'Unknown country' ; } $ regionId = $ this -> scopeConfig -> getValue ( 'general/store_information/region_id' ) ; $ regionName = 'Unknown region' ; if ( $ regionId ) { $ region = $ this -> regionFactory -> create ( ) ; $ region = $ region -> load ( $ regionId ) ; if ( $ region -> getId ( ) ) { $ regionName = $ region -> getName ( ) ; } } $ postCode = $ this -> scopeConfig -> getValue ( 'general/store_information/postcode' ) ; if ( ! $ postCode ) { $ postCode = 'Unknown zip code' ; } return $ countryName . ' | ' . $ regionName . ' | ' . $ postCode ; }
12267	public function renderCmsBlock ( BaseBlock $ block , $ username , array $ options = array ( ) ) { $ blockTemplate = $ this -> fetchTemplateBlock ( $ block ) ; if ( $ blockTemplate == "" ) { return "" ; } $ permalinks = $ this -> pagesParser -> contributor ( $ username ) -> parse ( ) -> permalinksByLanguage ( ) ; $ options = array_merge ( array ( 'block' => $ block , 'permalinks' => $ permalinks , ) , $ options ) ; return $ this -> templating -> render ( $ blockTemplate , $ options ) ; }
4917	public function setParams ( array $ params ) { foreach ( $ params as $ key => $ value ) { $ this -> setParam ( $ key , $ value ) ; } return $ this ; }
9483	public function toArray ( $ changedOnly = false , $ extraData = null ) { $ vars = get_object_vars ( $ this ) ; $ object = array ( ) ; if ( ! is_array ( $ this -> _changes ) ) { $ this -> _changes = array ( ) ; } if ( is_array ( $ extraData ) ) { $ vars = array_merge ( $ vars , $ extraData ) ; } foreach ( $ vars as $ k => $ v ) { if ( strpos ( $ k , '_' ) !== 0 && $ v !== null && ( ! $ changedOnly || array_key_exists ( $ k , $ this -> _changes ) || array_key_exists ( $ k , $ extraData ) ) ) { if ( is_array ( $ v ) ) { $ subV = array ( ) ; foreach ( $ v as $ sub ) { if ( is_a ( $ sub , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ subV [ ] = $ sub -> toArray ( ) ; } else { $ subV [ ] = $ sub ; } } $ object [ $ k ] = $ subV ; } else if ( is_a ( $ v , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ object [ $ k ] = $ v -> toArray ( ) ; } else { $ object [ $ k ] = $ v ; } } } return $ object ; }
2441	public static function urlDecode ( string $ data ) : self { $ decoded = base64_decode ( strtr ( $ data , '-_,' , '+/=' ) , true ) ; if ( \ function_exists ( 'gzdecode' ) && false !== ( $ uncompressed = @ gzdecode ( $ decoded ) ) ) { $ decoded = $ uncompressed ; } $ json = @ json_decode ( $ decoded , true ) ; if ( null === $ json ) { throw new \ InvalidArgumentException ( 'Invalid JSON data' ) ; } return new self ( $ json [ 'context' ] , $ json [ 'extras' ] , $ json [ 'value' ] , $ json [ 'current' ] ) ; }
2338	public function initialize ( ) { if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'enableVersioning' ] ) { return ; } $ objVersion = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_version WHERE fromTable=? AND pid=?" ) -> limit ( 1 ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> count > 0 ) { return ; } $ this -> create ( ) ; }
10425	private function headers ( ResponseInterface $ response ) : void { if ( ! headers_sent ( ) ) { foreach ( $ response -> getHeaders ( ) as $ name => $ values ) { $ cookie = stripos ( $ name , 'Set-Cookie' ) === 0 ? false : true ; foreach ( $ values as $ value ) { header ( sprintf ( '%s: %s' , $ name , $ value ) , $ cookie ) ; $ cookie = false ; } } header ( sprintf ( 'HTTP/%s %s %s' , $ response -> getProtocolVersion ( ) , $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) , true , $ response -> getStatusCode ( ) ) ; } }
4450	public function popByJid ( string $ jid , ? string $ worker = null ) : ? BaseJob { $ workerName = $ worker ? : $ this -> client -> getWorkerName ( ) ; $ data = json_decode ( $ this -> client -> popByJid ( $ this -> name , $ jid , $ workerName ) , true ) ; $ jobData = array_reduce ( $ data , 'array_merge' , [ ] ) ; if ( isset ( $ jobData [ 'jid' ] ) === false ) { return null ; } if ( $ jobData [ 'jid' ] === $ jid ) { $ job = new BaseJob ( $ this -> client , $ jobData ) ; $ job -> setEventsManager ( $ this -> getEventsManager ( ) ) ; } return $ job ?? null ; }
7593	public function openTag ( FormInterface $ form = null ) { $ this -> setFormClass ( $ form , $ this -> formLayout ) ; return parent :: openTag ( $ form ) ; }
10306	public function setLineStyleProperties ( $ line_width = null , $ compound_type = null , $ dash_type = null , $ cap_type = null , $ join_type = null , $ head_arrow_type = null , $ head_arrow_size = null , $ end_arrow_type = null , $ end_arrow_size = null ) { ( $ line_width !== null ) ? $ this -> lineStyleProperties [ 'width' ] = $ this -> getExcelPointsWidth ( ( float ) $ line_width ) : null ; ( $ compound_type !== null ) ? $ this -> lineStyleProperties [ 'compound' ] = ( string ) $ compound_type : null ; ( $ dash_type !== null ) ? $ this -> lineStyleProperties [ 'dash' ] = ( string ) $ dash_type : null ; ( $ cap_type !== null ) ? $ this -> lineStyleProperties [ 'cap' ] = ( string ) $ cap_type : null ; ( $ join_type !== null ) ? $ this -> lineStyleProperties [ 'join' ] = ( string ) $ join_type : null ; ( $ head_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'type' ] = ( string ) $ head_arrow_type : null ; ( $ head_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'size' ] = ( string ) $ head_arrow_size : null ; ( $ end_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'type' ] = ( string ) $ end_arrow_type : null ; ( $ end_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'size' ] = ( string ) $ end_arrow_size : null ; }
10798	public function dateToSqlFormat ( $ dateString ) { $ dateFormatter = new \ IntlDateFormatter ( \ Locale :: getDefault ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , \ date_default_timezone_get ( ) , \ IntlDateFormatter :: GREGORIAN , "dd MMM yyyy" ) ; $ time = $ dateFormatter -> parse ( $ dateString ) ; $ date = new \ DateTime ( ) ; $ date -> setTimestamp ( $ time ) ; return $ date -> format ( 'Y-m-d' ) ; }
8582	public function setAny ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Any' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5023	public function allowSelectMultipleItems ( ) { $ flagOrCallback = $ this -> allowSelectMultipleItems ; return is_callable ( $ flagOrCallback ) ? ( bool ) $ flagOrCallback ( ) : ( bool ) $ flagOrCallback ; }
9951	public function duplicateConditionalStyle ( array $ pCellStyle , $ pRange = '' ) { foreach ( $ pCellStyle as $ cellStyle ) { if ( ! ( $ cellStyle instanceof Conditional ) ) { throw new Exception ( 'Style is not a conditional style' ) ; } } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> setConditionalStyles ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row , $ pCellStyle ) ; } } return $ this ; }
9773	function readable ( ) : self { if ( ! $ this -> hasFlag ( 'directory' ) && ! $ this -> hasFlag ( 'file' ) ) throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , isReadable ( ) ) ; }
704	public function setDefaultRoles ( $ roles ) { if ( is_array ( $ roles ) ) { $ this -> defaultRoles = $ roles ; } elseif ( $ roles instanceof \ Closure ) { $ roles = call_user_func ( $ roles ) ; if ( ! is_array ( $ roles ) ) { throw new InvalidValueException ( 'Default roles closure must return an array' ) ; } $ this -> defaultRoles = $ roles ; } else { throw new InvalidArgumentException ( 'Default roles must be either an array or a callable' ) ; } }
4442	public function completed ( int $ offset = 0 , int $ count = 25 ) { return $ this -> client -> jobs ( 'complete' , null , $ offset , $ count ) ; }
7136	public function merge ( Margin $ margin ) : void { $ this -> purchaseCost += $ margin -> getPurchaseCost ( ) ; $ this -> sellingPrice += $ margin -> getSellingPrice ( ) ; $ this -> average = $ this -> average || $ margin -> isAverage ( ) ; }
4133	public function initializeObject ( $ obj ) { if ( $ obj instanceof PersistentCollection ) { $ obj -> initialize ( ) ; } else if ( $ obj instanceof Proxy \ Proxy ) { $ obj -> __doctrineLoad__ ( ) ; } }
1171	protected function getProtected ( $ instance , $ property ) { $ closure = function ( $ property ) { return $ this -> $ property ; } ; $ callback = $ closure -> bindTo ( $ instance , $ instance ) ; return $ callback ( $ property ) ; }
1148	protected function getAttributeName ( $ attribute ) { $ attributeArray = explode ( '.' , $ attribute ) ; if ( count ( $ attributeArray ) > 1 ) { return $ attributeArray [ 0 ] . '[' . implode ( '][' , array_slice ( $ attributeArray , 1 ) ) . ']' ; } return $ attribute ; }
3522	public static function refresh ( $ refresh_token ) { $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , [ 'grant_type' => 'refresh_token' , 'refresh_token' => $ refresh_token , 'includePerms' => "false" , 'token_type' => 'eg1' , ] , FortniteClient :: FORTNITE_AUTHORIZATION ) ; if ( ! $ data -> access_token ) { throw new \ Exception ( $ data -> errorMessage ) ; } return new self ( $ data -> access_token , $ data -> in_app_id , $ data -> refresh_token , $ data -> account_id , $ data -> expires_in ) ; }
9235	public function actionCreate ( ) { $ model = new Banner ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> position = $ model -> getLast ( ) ; $ model -> isdel = 0 ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'Banner' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'Banner' ] [ 'tags' ] ) ) { $ post [ 'Banner' ] [ 'tags' ] = implode ( "," , $ post [ 'Banner' ] [ 'tags' ] ) ; } } $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { $ model -> updatePosition ( $ model -> position ) ; $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; }
5958	public function clientGetById ( $ clid ) { if ( ! array_key_exists ( ( string ) $ clid , $ this -> clientList ( ) ) ) { throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; } return $ this -> clientList [ intval ( ( string ) $ clid ) ] ; }
4763	public function createUser ( ) { if ( false == $ this -> validateRegistrationOptin ( ) ) { if ( $ this -> getRequestParameter ( 'stoken' ) ) { \ OxidEsales \ Eshop \ Core \ Registry :: get ( \ OxidEsales \ Eshop \ Core \ UtilsView :: class ) -> addErrorToDisplay ( 'OEGDPROPTIN_CONFIRM_USER_REGISTRATION_OPTIN' , false , true ) ; \ OxidEsales \ Eshop \ Core \ Registry :: get ( \ OxidEsales \ Eshop \ Core \ UtilsView :: class ) -> addErrorToDisplay ( 'OEGDPROPTIN_CONFIRM_USER_REGISTRATION_OPTIN' , false , true , 'oegdproptin_userregistration' ) ; } } else { return parent :: createUser ( ) ; } }
8500	protected function setSSLCurlOptions ( $ ch ) { curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , $ this -> _config [ 'SSL_VerifyPeer' ] ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , $ this -> _config [ 'SSL_VerifyHost' ] ) ; }
11142	public function getAttributes ( $ props ) { $ attr = '' ; if ( isset ( $ props [ 'primaryKey' ] ) ) { $ attr .= 'NOT NULL AUTO_INCREMENT ' ; } if ( isset ( $ props [ 'defaultValue' ] ) ) { $ attr .= "DEFAULT '" . $ props [ 'defaultValue' ] . "'" ; } return $ attr ; }
7083	public function method ( $ method = NULL ) { if ( $ method === NULL ) { return $ this -> _method ; } $ this -> _method = strtoupper ( $ method ) ; return $ this ; }
8512	public function listInboundShipmentItemsByNextToken ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentItemsByNextTokenRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentItemsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentItemsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentItemsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10215	protected function scanElementForText ( \ DOMNode $ element ) { $ str = '' ; foreach ( $ element -> childNodes as $ child ) { if ( $ child -> nodeType == XML_TEXT_NODE ) { $ str .= $ child -> nodeValue ; } elseif ( $ child -> nodeType == XML_ELEMENT_NODE && $ child -> nodeName == 'text:s' ) { $ cAttr = $ child -> attributes -> getNamedItem ( 'c' ) ; if ( $ cAttr ) { $ multiplier = ( int ) $ cAttr -> nodeValue ; } else { $ multiplier = 1 ; } $ str .= str_repeat ( ' ' , $ multiplier ) ; } if ( $ child -> hasChildNodes ( ) ) { $ str .= $ this -> scanElementForText ( $ child ) ; } } return $ str ; }
12957	public function authenticate ( ) { $ identity = $ this -> getIdentity ( ) ; $ results = $ this -> model -> findByIdentity ( $ identity ) ; $ identityObject = null ; $ count = 0 ; foreach ( $ results as $ identityObject ) { if ( $ count > 1 ) { return new Result ( Result :: FAILURE_IDENTITY_AMBIGUOUS , $ identity , [ 'More than one record matches the supplied identity.' ] ) ; } $ count ++ ; } if ( $ count == 0 ) { return new Result ( Result :: FAILURE_IDENTITY_NOT_FOUND , $ identity , [ 'A record with the supplied identity could not be found.' ] ) ; } if ( $ identityObject instanceof ObjectInterface ) { if ( $ identityObject -> validateCredential ( $ this -> getCredential ( ) ) ) { return new Result ( Result :: SUCCESS , $ identity ) ; } return new Result ( Result :: FAILURE_CREDENTIAL_INVALID , $ identity , [ 'wrong password' ] ) ; } return new Result ( Result :: FAILURE_UNCATEGORIZED , $ identity , [ 'generic error' ] ) ; }
8958	public function validateResponse ( $ url , $ response ) { if ( $ response -> code != 200 ) { $ error = htmlspecialchars ( $ response -> body ) ; throw new \ DomainException ( $ error , $ response -> code ) ; } }
3994	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'name_langcode' , 'tl_metamodel_dcasetting' ) , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'name_value' , 'tl_metamodel_dcasetting' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( 'legendtitle' ) , true ) ) ; }
10203	public function setVertical ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: VERTICAL_BOTTOM ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'vertical' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> vertical = $ pValue ; } return $ this ; }
5865	protected function reportAdditionalStorageClaimed ( $ bytes ) { $ legacyFileName = PATH_site . 'typo3conf/.tx_imageautoresize' ; $ fileName = PATH_site . 'typo3temp/.tx_imageautoresize' ; if ( file_exists ( $ legacyFileName ) && ! file_exists ( $ fileName ) ) { @ rename ( $ legacyFileName , $ fileName ) ; } $ data = [ ] ; if ( file_exists ( $ fileName ) ) { $ data = json_decode ( file_get_contents ( $ fileName ) , true ) ; if ( ! is_array ( $ data ) ) { $ data = [ ] ; } } $ data [ 'bytes' ] = $ bytes + ( isset ( $ data [ 'bytes' ] ) ? ( int ) $ data [ 'bytes' ] : 0 ) ; $ data [ 'images' ] = 1 + ( isset ( $ data [ 'images' ] ) ? ( int ) $ data [ 'images' ] : 0 ) ; GeneralUtility :: writeFile ( $ fileName , json_encode ( $ data ) ) ; }
8715	public function getAccessToken ( ) : ApiAccessToken { try { $ accessToken = $ this -> tokenStorage -> getAccessToken ( ) ; } catch ( UnableToAcquireAccessToken $ e ) { $ accessToken = null ; } if ( $ accessToken && $ accessToken -> isExpired ( ) ) { $ this -> tokenStorage -> unsetAccessToken ( ) ; $ accessToken = null ; } return $ accessToken ? : $ this -> refreshToken ( ) ; }
3043	protected function unpackTimeLine ( & $ data ) { $ timeLine = new QtiTimeLine ( ) ; if ( isset ( $ data [ self :: STORAGE_KEY_TIMELINE_POINTS ] ) ) { $ epoch = 0 ; if ( isset ( $ data [ self :: STORAGE_KEY_TIMELINE_EPOCH ] ) ) { $ epoch = $ data [ self :: STORAGE_KEY_TIMELINE_EPOCH ] ; } $ tags = $ data [ self :: STORAGE_KEY_TIMELINE_TAGS ] ; foreach ( $ data [ self :: STORAGE_KEY_TIMELINE_POINTS ] as & $ dataPoint ) { $ point = new TimePoint ( $ tags , $ dataPoint [ 2 ] + $ epoch , $ dataPoint [ 1 ] , $ dataPoint [ 0 ] ) ; $ timeLine -> add ( $ point ) ; } $ points = $ timeLine -> getPoints ( ) ; foreach ( $ data [ self :: STORAGE_KEY_TIMELINE_INDEX ] as $ tag => & $ list ) { foreach ( $ list as $ index ) { $ points [ $ index ] -> addTag ( $ tag ) ; } } } else { $ timeLine -> fromArray ( $ data ) ; } return $ timeLine ; }
9733	public function setARGB ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: COLOR_BLACK ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'argb' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> argb = $ pValue ; } return $ this ; }
6863	protected function registerManager ( ) { $ this -> app -> singleton ( 'notifyme' , function ( $ app ) { $ config = $ app [ 'config' ] ; $ factory = $ app [ 'notifyme.factory' ] ; return new NotifyMeManager ( $ config , $ factory ) ; } ) ; $ this -> app -> alias ( 'notifyme' , NotifyMeManager :: class ) ; $ this -> app -> alias ( 'notifyme' , ManagerInterface :: class ) ; }
12749	private function validateSKU ( string $ sku ) { if ( strlen ( $ sku ) == 0 ) { throw new SKUException ( "A SKU cannot be empty" ) ; } $ containsWhitespace = preg_match ( $ this -> whiteSpacePattern , $ sku ) == 1 ; if ( $ containsWhitespace ) { throw new SKUException ( sprintf ( "A SKU cannot contain white space characters: \"%s\"" , $ sku ) ) ; } $ containsUppercaseCharacters = preg_match ( $ this -> uppercaseCharactersPattern , $ sku ) == 1 ; if ( $ containsUppercaseCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot contain uppercase characters: \"%s\"" , $ sku ) ) ; } $ containsInvalidCharacters = preg_match ( $ this -> invalidCharactersPattern , $ sku ) == 1 ; if ( $ containsInvalidCharacters ) { throw new SKUException ( sprintf ( "The SKU \"%s\" contains invalid characters. A SKU can only contain the following characters: a-z, 0-9 and -" , $ sku ) ) ; } $ prefixMatches = [ ] ; $ prefixContainsInvalidCharacters = preg_match ( $ this -> invalidPrefixCharacters , $ sku , $ prefixMatches ) == 1 ; if ( $ prefixContainsInvalidCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot start with the given characters: \"%s\"" , implode ( "" , $ prefixMatches ) ) ) ; } $ suffixMatches = [ ] ; $ suffixContainsInvalidCharacters = preg_match ( $ this -> invalidSuffixCharacters , $ sku , $ suffixMatches ) == 1 ; if ( $ suffixContainsInvalidCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot end with the given characters: \"%s\"" , implode ( "" , $ suffixMatches ) ) ) ; } if ( strlen ( $ sku ) < $ this -> minLength ) { throw new SKUException ( sprintf ( "The given SKU \"%s\" is too short. The minimum length for a SKU is: %s" , $ sku , $ this -> minLength ) ) ; } if ( strlen ( $ sku ) > $ this -> maxLength ) { throw new SKUException ( sprintf ( "The given SKU \"%s\" is too long (%s character). The maximum length for a SKU is: %s" , strlen ( $ sku ) , $ sku , $ this -> maxLength ) ) ; } }
11503	private function createDeleteForm ( Comment $ comment ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_comment_delete' , array ( 'id' => $ comment -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
9647	public function whateverMatches ( string $ param ) : RouteBuilder { if ( array_key_exists ( $ param , $ this -> matchers ) ) { unset ( $ this -> matchers [ $ param ] ) ; } return $ this ; }
4912	public function setVariables ( $ variables , $ overwrite = false ) { if ( ! is_array ( $ variables ) && ! $ variables instanceof \ Traversable ) { throw new \ InvalidArgumentException ( sprintf ( '%s: expects an array, or Traversable argument; received "%s"' , __METHOD__ , ( is_object ( $ variables ) ? get_class ( $ variables ) : gettype ( $ variables ) ) ) ) ; } if ( $ overwrite ) { if ( is_object ( $ variables ) && ! $ variables instanceof \ ArrayAccess ) { $ variables = ArrayUtils :: iteratorToArray ( $ variables ) ; } $ this -> variables = $ variables ; return $ this ; } foreach ( $ variables as $ key => $ value ) { $ this -> setVariable ( $ key , $ value ) ; } return $ this ; }
4413	public function onException ( GetResponseForExceptionEvent $ event ) { if ( ! $ this -> isAdminSiteAccess ) { return ; } $ routeName = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( $ routeName !== FallbackRouter :: ROUTE_NAME ) { return ; } $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof NotFoundHttpException ) { return ; } if ( method_exists ( $ exception , 'getOriginalResponse' ) ) { $ event -> setResponse ( $ exception -> getOriginalResponse ( ) ) ; } }
462	public function buildCondition ( $ condition , & $ params ) { if ( is_array ( $ condition ) ) { if ( empty ( $ condition ) ) { return '' ; } $ condition = $ this -> createConditionFromArray ( $ condition ) ; } if ( $ condition instanceof ExpressionInterface ) { return $ this -> buildExpression ( $ condition , $ params ) ; } return ( string ) $ condition ; }
6493	private function compareAcceptMediaTypeHeaders ( AcceptMediaTypeHeaderValue $ a , AcceptMediaTypeHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aType = $ a -> getType ( ) ; $ bType = $ b -> getType ( ) ; $ aSubType = $ a -> getSubType ( ) ; $ bSubType = $ b -> getSubType ( ) ; if ( $ aType === '*' ) { if ( $ bType === '*' ) { return 0 ; } return 1 ; } if ( $ aSubType === '*' ) { if ( $ bSubType === '*' ) { return 0 ; } return 1 ; } if ( $ bType === '*' || $ bSubType === '*' ) { return - 1 ; } return 0 ; }
9186	protected function mergeParams ( & $ data , $ params ) { foreach ( $ params as $ paramName => $ paramValue ) { if ( is_array ( $ paramValue ) ) { foreach ( $ paramValue as $ key => $ value ) { foreach ( $ value as $ name => $ x ) { $ data [ $ paramName ] [ $ key ] [ $ name ] = $ x ; } } } else { $ data [ $ paramName ] = $ paramValue ; } } }
4300	public function groupEnd ( $ value = \ bdk \ Debug \ Abstracter :: UNDEFINED ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'value' => \ bdk \ Debug \ Abstracter :: UNDEFINED ) ) ; \ extract ( $ args ) ; $ groupStackWas = $ this -> rootInstance -> groupStackRef ; $ appendLog = false ; if ( $ groupStackWas && \ end ( $ groupStackWas ) [ 'collect' ] == $ this -> cfg [ 'collect' ] ) { \ array_pop ( $ this -> rootInstance -> groupStackRef ) ; $ appendLog = $ this -> cfg [ 'collect' ] ; } if ( $ appendLog && $ value !== \ bdk \ Debug \ Abstracter :: UNDEFINED ) { $ this -> appendLog ( 'groupEndValue' , array ( 'return' , $ value ) , $ meta ) ; } if ( $ this -> data [ 'groupPriorityStack' ] && ! $ groupStackWas ) { $ priorityClosing = \ array_pop ( $ this -> data [ 'groupPriorityStack' ] ) ; unset ( $ this -> data [ 'groupStacks' ] [ $ priorityClosing ] ) ; $ this -> setLogDest ( 'auto' ) ; $ meta [ 'closesSummary' ] = true ; $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; } elseif ( $ appendLog ) { $ this -> appendLog ( 'groupEnd' , array ( ) , $ meta ) ; } $ errorCaller = $ this -> errorHandler -> get ( 'errorCaller' ) ; if ( $ errorCaller && isset ( $ errorCaller [ 'groupDepth' ] ) && $ this -> getGroupDepth ( ) < $ errorCaller [ 'groupDepth' ] ) { $ this -> errorHandler -> setErrorCaller ( false ) ; } }
2108	public static function findByRelatedTableAndIds ( $ strTable , array $ arrIds , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE $t.id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")) ORDER BY $t.createdOn DESC" ) -> execute ( $ strTable , $ arrIds ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ arrModels = array ( ) ; $ objRegistry = Registry :: getInstance ( ) ; while ( $ objResult -> next ( ) ) { if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { $ arrModels [ ] = $ objOptIn ; } else { $ arrModels [ ] = new static ( $ objResult -> row ( ) ) ; } } return static :: createCollection ( $ arrModels , $ t ) ; }
1360	public static function custom ( $ mediaType ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , null ) ; }
6864	protected function updateTotals ( InvoiceInterface $ invoice ) { $ changed = $ this -> invoiceCalculator -> calculate ( $ invoice ) ; if ( $ changed ) { foreach ( $ invoice -> getLines ( ) as $ line ) { $ this -> persistenceHelper -> persistAndRecompute ( $ line , false ) ; } } return $ changed ; }
1702	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objArchive = NewsArchiveModel :: findByProtected ( '' ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { if ( ! $ objArchive -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objArchive -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objArchive -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objArchive -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objArchive -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objArchive -> jumpTo ] ; $ objArticle = NewsModel :: findPublishedDefaultByPid ( $ objArchive -> id ) ; if ( $ objArticle !== null ) { while ( $ objArticle -> next ( ) ) { $ arrPages [ ] = $ this -> getLink ( $ objArticle , $ strUrl ) ; } } } } return $ arrPages ; }
3128	protected function getRangeDuration ( $ start , $ end ) { if ( $ start -> getTarget ( ) != $ end -> getTarget ( ) ) { throw new InconsistentRangeException ( 'A time range must be defined by two TimePoint with the same target' ) ; } $ rangeDuration = $ end -> getTimestamp ( ) - $ start -> getTimestamp ( ) ; if ( $ rangeDuration < 0 ) { throw new InconsistentRangeException ( 'A START TimePoint cannot take place after the END!' ) ; } return $ rangeDuration ; }
7498	public function createAndSendMessageFromTemplate ( ) { $ args = func_get_args ( ) ; if ( empty ( $ args [ 0 ] ) ) { throw new \ RuntimeException ( 'First parameter must be a template filename or EmailTemplate entity' ) ; } elseif ( $ args [ 0 ] instanceof EmailTemplate ) { $ method = 'createMessageFromTemplateEntity' ; } else { $ method = 'createMessageFromTemplateFile' ; } $ message = call_user_func_array ( array ( $ this , $ method ) , $ args ) ; $ this -> mailer -> send ( $ message ) ; return true ; }
11686	public function getLocation ( $ location , $ owner = null ) { $ bucket = $ this -> getBucket ( 'locations:' . $ location ) ; if ( is_null ( $ owner ) ) { return $ bucket -> toArray ( ) ; } else { $ result = [ ] ; foreach ( $ bucket as $ key => $ widget ) { if ( $ widget -> owner === $ owner ) { $ result [ $ key ] = $ widget ; } } return $ result ; } }
7939	public function deleteBackupFTPaccessBlock ( $ domain , $ ipBlock ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; try { $ r = $ this -> delete ( 'dedicated/server/' . $ domain . '/features/backupFTP/access/' . urlencode ( $ ipBlock ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
8964	private static function matchesArrayCriteria ( $ key , $ object , array $ criteria ) { $ criteria = self :: extractArrayCriteria ( $ key , $ criteria ) ; if ( count ( $ criteria ) === 0 ) { return true ; } $ getter = sprintf ( 'get%s' , ucfirst ( $ key ) ) ; if ( ! method_exists ( $ object , $ getter ) ) { throw new RuntimeException ( sprintf ( 'Object instance of "%s" does not have required getter "%s" to be used for filtering.' , get_class ( $ object ) , $ getter ) ) ; } return in_array ( $ object -> { $ getter } ( ) , $ criteria , true ) ; }
7455	protected function getTaxonomies ( string $ post_type ) : array { $ return = [ ] ; $ taxes = \ get_object_taxonomies ( $ post_type , 'objects' ) ; foreach ( $ taxes as $ tax_slug => $ tax_object ) { if ( \ is_taxonomy_hierarchical ( $ tax_slug ) ) { $ return [ ] = $ tax_slug ; } } return $ return ; }
4238	public function hasLog ( ) { $ entryCountInitial = $ this -> debug -> getData ( 'entryCountInitial' ) ; $ entryCountCurrent = $ this -> debug -> getData ( 'log/__count__' ) ; $ haveLog = $ entryCountCurrent > $ entryCountInitial ; $ lastEntryMethod = $ this -> debug -> getData ( 'log/__end__/0' ) ; return $ haveLog && $ lastEntryMethod !== 'clear' ; }
9144	public static function generate ( $ length = 8 , $ allowed = RandomString :: ASCII , $ repeatable = true ) : string { $ allowedChars = array ( ) ; $ currentLocale = setlocale ( LC_ALL , "0" ) ; if ( $ allowed == RandomString :: ASCII ) { setlocale ( LC_ALL , "C" ) ; } for ( $ i = 32 ; $ i < 256 ; $ i ++ ) { if ( ( $ allowed == RandomString :: ASCII && ! ctype_alnum ( chr ( $ i ) ) ) || ( ! ctype_print ( chr ( $ i ) ) ) ) { continue ; } $ allowedChars [ ] = $ i ; } self :: resetLocaleTo ( $ currentLocale ) ; $ used = array ( ) ; $ string = "" ; $ i = $ length ; while ( $ i > 0 ) { $ index = mt_rand ( 0 , count ( $ allowedChars ) - 1 ) ; if ( ! $ repeatable && in_array ( $ index , $ used ) ) { continue ; } $ string .= chr ( $ allowedChars [ $ index ] ) ; $ used [ ] = $ i ; $ i -- ; } return $ string ; }
6518	public static function fromDateTime ( \ DateTimeInterface $ date ) { $ str = $ date -> format ( 'U' ) . str_pad ( $ date -> format ( 'u' ) , 6 , '0' ) ; $ m = new self ( ) ; $ m -> int = ( int ) $ str ; $ m -> sec = ( int ) substr ( $ str , 0 , 10 ) ; $ m -> usec = ( int ) substr ( $ str , - 6 ) ; return $ m ; }
2230	protected function getTargetFolders ( $ strFolder , $ intLevel = 1 ) { $ strFolders = '' ; $ strPath = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFolder ; foreach ( scan ( $ strPath ) as $ strFile ) { if ( ! is_dir ( $ strPath . '/' . $ strFile ) || strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } $ strRelPath = $ strFolder . '/' . $ strFile ; $ strFolders .= sprintf ( '<option value="%s"%s>%s%s</option>' , $ strRelPath , ( ( Contao \ Input :: post ( 'target' ) == $ strRelPath ) ? ' selected="selected"' : '' ) , str_repeat ( ' &nbsp; ' , $ intLevel ) , basename ( $ strRelPath ) ) ; $ strFolders .= $ this -> getTargetFolders ( $ strRelPath , ( $ intLevel + 1 ) ) ; } return $ strFolders ; }
2253	protected function getParentEntries ( $ strTable , $ intId ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ) ) { return '' ; } $ arrParent = array ( ) ; do { $ objParent = $ this -> Database -> prepare ( "SELECT pid FROM " . $ strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intId ) ; if ( $ objParent -> numRows < 1 ) { break ; } $ strTable = $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ; $ intId = $ objParent -> pid ; $ arrParent [ ] = $ strTable . '.id=' . $ intId ; $ this -> loadDataContainer ( $ strTable ) ; } while ( $ intId && isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ) ) ; if ( empty ( $ arrParent ) ) { return '' ; } return ' (parent records: ' . implode ( ', ' , $ arrParent ) . ')' ; }
499	protected function writeInteger ( $ fileHandle , $ integer ) { return $ this -> writeBytes ( $ fileHandle , pack ( $ this -> useBigEndian ? 'N' : 'V' , ( int ) $ integer ) ) ; }
373	public function getOptionValues ( $ actionID ) { $ properties = [ ] ; foreach ( $ this -> options ( $ this -> action -> id ) as $ property ) { $ properties [ $ property ] = $ this -> $ property ; } return $ properties ; }
7354	protected function getUrl ( $ name , $ subject , $ path ) { if ( $ subject instanceof SubjectRelativeInterface ) { if ( null === $ subject = $ this -> resolve ( $ subject , false ) ) { return null ; } } if ( ! $ subject instanceof SubjectInterface ) { throw new InvalidArgumentException ( "Expected instance of " . SubjectInterface :: class ) ; } $ event = new SubjectUrlEvent ( $ subject , $ path ) ; $ this -> eventDispatcher -> dispatch ( $ name , $ event ) ; return $ event -> getUrl ( ) ; }
11058	protected function _getDataStore ( ) { return $ this -> dataStore === null ? $ this -> dataStore = $ this -> _createDataStore ( ) : $ this -> dataStore ; }
6427	public function getUserProfile ( ) { $ client = $ this -> getClient ( ) ; $ client -> setAccessToken ( $ this -> access_token ) ; $ plus = new \ Google_Service_Plus ( $ client ) ; $ oauth2 = new \ Google_Service_Oauth2 ( $ client ) ; if ( $ client -> getAccessToken ( ) ) { $ user = $ oauth2 -> userinfo -> get ( ) ; if ( isset ( $ user -> id ) ) { $ name = $ user -> givenName ; if ( ! empty ( $ user -> familyName ) ) { $ name = $ user -> familyName . ' ' . $ user -> givenName ; } $ profile = array ( 'userid' => $ user -> id , 'name' => $ name , 'imageurl' => $ user -> picture , 'email' => $ user -> email ) ; return $ profile ; } } throw new \ Exception ( 'Can not get google profile' ) ; }
826	public function isBeforeStructuralElement ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_COMMENT , T_DOC_COMMENT ] ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ nextIndex = $ index ; do { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ; } while ( null !== $ nextIndex && $ tokens [ $ nextIndex ] -> equals ( '(' ) ) ; if ( null === $ nextIndex || $ tokens [ $ nextIndex ] -> equals ( '}' ) ) { return false ; } $ nextToken = $ tokens [ $ nextIndex ] ; if ( $ this -> isStructuralElement ( $ nextToken ) ) { return true ; } if ( $ this -> isValidControl ( $ tokens , $ token , $ nextIndex ) ) { return true ; } if ( $ this -> isValidVariable ( $ tokens , $ nextIndex ) ) { return true ; } if ( $ this -> isValidLanguageConstruct ( $ tokens , $ token , $ nextIndex ) ) { return true ; } return false ; }
10797	public function getCryptedPassword ( $ password ) { $ bcrypt = new Bcrypt ; $ bcrypt -> setCost ( $ this -> getOptions ( ) -> getPasswordCost ( ) ) ; return $ bcrypt -> create ( $ password ) ; }
3464	public function get ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: get ( $ route ) ) ; }
9511	public function delete ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DELETE ) ; $ date = $ log -> date ; if ( $ this -> logViewer -> delete ( $ date ) ) { $ this -> notifySuccess ( $ message = trans ( 'foundation::log-viewer.messages.deleted.message' , compact ( 'date' ) ) , trans ( 'foundation::log-viewer.messages.deleted.title' ) ) ; return $ this -> jsonResponseSuccess ( compact ( 'message' ) ) ; } return $ this -> jsonResponseError ( [ 'message' => "An error occurred while deleting the log [$date]" ] ) ; }
9449	protected function allowed ( $ method ) { if ( in_array ( $ method , $ this -> allowed ) === false ) { $ message = 'Used method is not allowed' ; throw new \ UnexpectedValueException ( $ message ) ; } return true ; }
881	private function fixTypes ( Annotation $ annotation ) { $ types = $ annotation -> getTypes ( ) ; $ new = $ this -> normalizeTypes ( $ types ) ; if ( $ types !== $ new ) { $ annotation -> setTypes ( $ new ) ; } }
9015	function getRoot ( ) { $ sm = $ this -> sl -> getServiceLocator ( ) ; $ event = $ sm -> get ( 'Application' ) -> getMvcEvent ( ) ; return $ event -> getViewModel ( ) ; }
6877	private function buildRevenueData ( array $ result , $ detailed = false ) { $ data = [ ] ; foreach ( $ result as $ r ) { $ data [ $ r [ 'date' ] ] = $ detailed ? json_decode ( $ r [ 'details' ] , true ) : $ r [ 'revenue' ] ; } return $ data ; }
8312	public function handlePasswordReset ( Request $ httpRequest ) { $ this -> httpRequest = $ httpRequest ; $ this -> checkResetLink ( ) ; $ resetData = $ this -> session -> get ( "pwreset" ) ; if ( $ resetData === null ) { $ this -> beginPasswordReset ( ) ; } else { $ this -> finishPasswordReset ( $ resetData ) ; } }
6562	public static function joinPath ( $ base , $ path ) { if ( substr ( $ path , 0 , 1 ) === '/' ) { return $ path ; } if ( substr ( $ base , 0 , 1 ) !== '/' ) { return false ; } $ pathParts = self :: splitPath ( $ path ) ; $ resultParts = self :: splitPath ( $ base ) ; while ( ( $ part = array_shift ( $ pathParts ) ) !== null ) { switch ( $ part ) { case '.' : break ; case '..' : if ( count ( $ resultParts ) > 1 ) { array_pop ( $ resultParts ) ; } break ; default : $ resultParts [ ] = $ part ; break ; } } return implode ( '/' , $ resultParts ) ; }
5770	public function getLoggedInAdministrator ( ) : Administrator { if ( ! isset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { throw new \ Exception ( "No one is logged in" ) ; } if ( null === $ administrator = ( AdministratorsEntityMapper :: getInstance ( ) ) -> getObjectById ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { unset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ; throw new \ Exception ( "Invalid administrator id " . $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] . " in session" ) ; } return $ administrator ; }
11988	function readLine ( ) { $ i = $ this -> pos ; $ tot_len = strlen ( $ this -> data ) ; while ( $ i < $ tot_len && ! $ this -> isEndOfLine ( $ i ) ) { $ i ++ ; } $ result = substr ( $ this -> data , $ this -> pos , $ i - $ this -> pos ) ; $ i ++ ; if ( $ this -> getLineEndingModeCrlf ( ) ) $ i ++ ; $ this -> pos = $ i ; return $ result ; }
5575	public function clickSubmitByName ( $ name , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectByName ( $ name ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectByName ( $ name ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
2423	public static function updateFolderHashes ( $ varResource ) { $ arrPaths = array ( ) ; if ( ! \ is_array ( $ varResource ) ) { $ varResource = array ( $ varResource ) ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ varResource as $ strResource ) { $ arrChunks = explode ( '/' , $ strResource ) ; $ strPath = array_shift ( $ arrChunks ) ; if ( is_file ( $ rootDir . '/' . $ strResource ) ) { array_pop ( $ arrChunks ) ; } while ( \ count ( $ arrChunks ) ) { $ strPath .= '/' . array_shift ( $ arrChunks ) ; $ arrPaths [ ] = $ strPath ; } unset ( $ arrChunks ) ; } $ arrPaths = array_values ( array_unique ( $ arrPaths ) ) ; foreach ( array_reverse ( $ arrPaths ) as $ strPath ) { $ objModel = FilesModel :: findByPath ( $ strPath ) ; if ( $ objModel === null ) { $ objModel = static :: addResource ( $ strPath , false ) ; } $ objModel -> hash = static :: getFolderHash ( $ strPath ) ; $ objModel -> save ( ) ; } }
10554	public static function handleUnknownHost ( URL $ webroot , URL $ request , array $ sites , Dictionary $ cfg ) { $ on_unknown = strtoupper ( $ cfg -> dget ( 'unknown_host_policy' , "IGNORE" ) ) ; $ best_matching = self :: findBestMatching ( $ webroot , $ sites ) ; if ( $ on_unknown === "ERROR" || ( $ best_matching === null && $ on_unknown === "REDIRECT" ) ) return null ; if ( $ on_unknown === "REDIRECT" ) { $ redir = $ best_matching -> URL ( $ request -> path ) ; return $ redir ; } $ url = new URL ( $ webroot ) ; $ url -> fragment = null ; $ url -> query = null ; $ lang = $ cfg -> dget ( 'default_language' , 'en' ) ; $ vhost = new VirtualHost ( $ url , $ lang ) ; if ( $ best_matching === null ) { $ site = new Site ( ) ; $ site -> addVirtualHost ( $ vhost ) ; } else $ best_matching -> getSite ( ) -> addVirtualHost ( $ vhost ) ; return $ vhost ; }
3487	private static function tryResolveByWebTokenJwtSystem ( ) : ? WebTokenJwtSignatureGenerator { $ requiredClasses = [ WebTokenComponentJws :: class , WebTokenComponentJwk :: class , WebTokenComponentJWKFactory :: class , ] ; foreach ( $ requiredClasses as $ requiredClass ) { if ( ! class_exists ( $ requiredClass ) ) { return null ; } } return new WebTokenJwtSignatureGenerator ( ) ; }
3539	public static function getAdldapProvider ( ) { if ( static :: getExtensionOptions ( 'adldap-providername' ) != '__USE_DEFAULT_PROVIDER__' ) { $ provider = Yii :: $ app -> ad -> getProvider ( static :: getExtensionOptions ( 'adldap-providername' ) ) ; } else { $ provider = Yii :: $ app -> ad -> getDefaultProvider ( ) ; } return $ provider ; }
12046	public function getThumbnails ( $ videoId , $ format = null ) { $ listResponse = $ this -> videos -> listVideos ( 'snippet' , array ( 'id' => $ videoId ) ) ; if ( empty ( $ listResponse ) ) { throw new \ RuntimeException ( sprintf ( 'Could not find video with id %s' , $ videoId ) ) ; } $ video = $ listResponse [ 0 ] ; $ videoSnippet = $ video [ 'snippet' ] ; if ( is_null ( $ format ) ) { return $ videoSnippet [ 'thumbnails' ] [ 'data' ] ; } if ( ! in_array ( $ format , array ( 'default' , 'medium' , 'high' ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid format "%s"' , $ format ) ) ; } return $ videoSnippet [ 'thumbnails' ] [ 'data' ] [ $ format ] ; }
2437	public function setData ( $ arrData ) { if ( ! \ is_array ( $ arrData ) ) { throw new \ Exception ( 'Array required to set session data' ) ; } foreach ( $ this -> mappedKeys as $ strKey ) { if ( isset ( $ arrData [ $ strKey ] ) ) { $ this -> session -> set ( $ strKey , $ arrData [ $ strKey ] ) ; unset ( $ arrData [ $ strKey ] ) ; } } $ this -> sessionBag -> replace ( $ arrData ) ; }
9450	protected function pathExtract ( ) : array { $ regExp = [ ] ; $ path = $ this -> path ; if ( \ is_array ( $ this -> path ) ) { $ regExp = \ array_pop ( $ this -> path ) ; $ path = \ array_pop ( $ this -> path ) ; } return [ $ path , $ regExp ] ; }
10789	protected function setSearchFacets ( SessionInterface $ session , $ facets ) { $ session -> set ( $ this -> getSessionPrefix ( ) . '_facets' , \ json_encode ( $ facets ) ) ; }
6815	protected function buildFile ( array $ orders , string $ name ) { if ( false === $ path = tempnam ( sys_get_temp_dir ( ) , $ name ) ) { throw new RuntimeException ( "Failed to create temporary file." ) ; } if ( false === $ handle = fopen ( $ path , "w" ) ) { throw new RuntimeException ( "Failed to open '$path' for writing." ) ; } if ( ! empty ( $ headers = $ this -> buildHeaders ( ) ) ) { fputcsv ( $ handle , $ headers , ';' , '"' ) ; } $ supplierTotal = 0 ; $ forwarderTotal = 0 ; foreach ( $ orders as $ order ) { if ( ! empty ( $ row = $ this -> buildRow ( $ order ) ) ) { fputcsv ( $ handle , $ row , ';' , '"' ) ; $ supplierTotal += $ row [ 'payment_total' ] ; $ forwarderTotal += $ row [ 'forwarder_total' ] ; } } fputcsv ( $ handle , [ 'id' => '' , 'number' => '' , 'state' => '' , 'ordered_at' => '' , 'completed_at' => '' , 'supplier' => '' , 'payment_total' => $ supplierTotal , 'payment_date' => '' , 'payment_due_date' => '' , 'carrier' => '' , 'forwarder_total' => $ forwarderTotal , 'forwarder_date' => '' , 'forwarder_due_date' => '' , ] , ';' , '"' ) ; fclose ( $ handle ) ; return $ path ; }
9545	public function create ( $ table , array $ fields , $ tokenize = 'porter' ) { $ fields = implode ( ', ' , $ fields ) ; $ query = "CREATE VIRTUAL TABLE {$table} USING fts4({$fields}, tokenize={$tokenize})" ; $ executed = $ this -> db -> info ( 'tables' , $ table ) ; if ( $ query == $ executed ) { return false ; } if ( ! is_null ( $ executed ) ) { $ this -> db -> exec ( 'DROP TABLE ' . $ table ) ; } $ this -> db -> exec ( $ query ) ; $ this -> db -> info ( 'tables' , $ table , $ query ) ; return true ; }
1979	public static function generate ( $ strScope = TL_MODE ) { $ strMessages = static :: generateUnwrapped ( $ strScope ) ; if ( $ strMessages != '' ) { $ strMessages = '<div class="tl_message">' . $ strMessages . '</div>' ; } return $ strMessages ; }
4714	public function replaceString ( $ search , $ replace ) { $ this -> text = str_replace ( $ search , $ replace , $ this -> text ) ; return $ this ; }
1342	public function getParameters ( ) : EncodingParametersInterface { if ( $ this -> parameters ) { return $ this -> parameters ; } return $ this -> parameters = $ this -> container -> make ( EncodingParametersInterface :: class ) ; }
8077	public function delete ( $ endpoint , $ query = [ ] ) { $ endpoint = $ this -> buildUri ( $ endpoint , $ query ) ; $ headers = $ this -> buildHeaders ( ) ; $ this -> response = $ this -> client -> delete ( $ endpoint , $ headers ) ; return $ this -> response ; }
9257	public function get ( $ id , $ invalidBehavior = ContainerInterface :: EXCEPTION_ON_INVALID_REFERENCE ) { if ( ! $ this -> booted ) { $ this -> boot ( ) ; } return $ this -> container -> get ( $ id , $ invalidBehavior ) ; }
10909	public function inject ( string ... $ methods ) : Binding { if ( $ this -> definition -> injects === null ) { $ this -> definition -> injects = \ array_fill_keys ( $ methods , true ) ; } else { foreach ( $ methods as $ f ) { $ this -> definition -> injects [ $ f ] = true ; } } return $ this ; }
10621	public static function percentage ( $ value , $ from ) { $ value = floatval ( $ value ) ; $ from = floatval ( $ from ) ; return floatval ( $ value / $ from * 100 ) ; }
4812	public function add ( $ name , $ value ) { if ( array_key_exists ( $ name , $ this -> storage ) ) { throw new AlreadyDefinedException ( sprintf ( 'Context value with key `%s` already defined' , $ name ) ) ; } $ this -> storage [ $ name ] = $ value ; }
12759	public static function parse ( & $ string ) { $ media = array ( "objects" => array ( ) , "hashes" => array ( ) , "links" => array ( ) , ) ; preg_match_all ( '#@([\\d\\w]+)#' , $ string , $ mentions ) ; preg_match_all ( '/#([\\d\\w]+)/' , $ string , $ hashTags ) ; preg_match_all ( '/((http|https|ftp|ftps)\:\/\/)([a-z0-9+!*(),;?&=\$_.-]+(\:[a-z0-9+!*(),;?&=\$_.-]+)?@)?([a-zA-Z0-9\-\.]+)\.([a-zA-Z]{2,3})(\:[0-9]{2,5})?(\/([a-z0-9+\$_-]\.?)+)*\/?/' , $ data , $ openLinks ) ; return $ media ; }
8324	public function getPingbacks ( ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get_pingback" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( strpos ( $ responseText , 'OK|' ) !== false ) { $ data = explode ( '|' , $ responseText ) ; unset ( $ data [ 0 ] ) ; return empty ( $ data [ 1 ] ) ? [ ] : array_values ( $ data ) ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
7559	function select ( $ query = '*' , $ index = false , $ recursive = true , $ check_self = false ) { $ s = new $ this -> selectClass ( $ this , $ query , $ check_self , $ recursive ) ; $ res = $ s -> result ; unset ( $ s ) ; if ( is_array ( $ res ) && ( $ index === true ) && ( count ( $ res ) === 1 ) ) { return $ res [ 0 ] ; } elseif ( is_int ( $ index ) && is_array ( $ res ) ) { if ( $ index < 0 ) { $ index += count ( $ res ) ; } return ( $ index < count ( $ res ) ) ? $ res [ $ index ] : null ; } else { return $ res ; } }
7948	public function getPppLoginByMail ( $ id ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; try { $ this -> post ( 'xdsl/' . $ id . '/requestPPPLoginMail' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
562	public static function debug ( $ message , $ category = 'application' ) { if ( YII_DEBUG ) { static :: getLogger ( ) -> log ( $ message , Logger :: LEVEL_TRACE , $ category ) ; } }
12548	public function getThemePlugin ( $ name ) { if ( ! array_key_exists ( $ name , $ this -> themes ) ) { return null ; } return $ this -> themes [ $ name ] ; }
1339	public function add ( ResourceIdentifierInterface $ identifier , $ record ) { if ( ! is_object ( $ record ) && ! is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Expecting an object or a boolean to add to the identity map.' ) ; } $ existing = $ this -> lookup ( $ identifier ) ; if ( is_object ( $ existing ) && is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Attempting to push a boolean into the map in place of an object.' ) ; } $ this -> map [ $ identifier -> toString ( ) ] = $ record ; return $ this ; }
8456	public function drush ( $ command , $ assumeYes = true ) { if ( is_array ( $ command ) ) { $ command = implode ( ' ' , array_filter ( $ command ) ) ; } return $ this -> exec ( $ this -> injectArguments ( $ command , $ assumeYes ) ) ; }
9271	protected function setUri ( $ uriToSet ) { $ uri_parts = [ ] ; array_push ( $ uri_parts , 'api' ) ; array_push ( $ uri_parts , config ( 'ckan_api.api_version' ) ) ; array_push ( $ uri_parts , trim ( $ uriToSet , '/' ) ) ; $ uri_parts = array_filter ( $ uri_parts ) ; $ this -> uri = implode ( '/' , $ uri_parts ) ; }
7570	public function getApplicationApiService ( ) { $ applicationService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ ApplicationService ( $ this -> _apiKey , $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: APPLICATION_URL ) ) ; $ applicationService -> setClient ( $ apiClient ) ; return $ applicationService ; }
5458	protected function openTag ( $ tag ) { $ name = $ tag -> getTagName ( ) ; if ( ! in_array ( $ name , array_keys ( $ this -> tags ) ) ) { $ this -> tags [ $ name ] = array ( ) ; } $ this -> tags [ $ name ] [ ] = $ tag ; }
2059	public function generateSitemap ( ) { $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; if ( empty ( $ session ) || ! \ is_array ( $ session ) ) { return ; } $ this -> import ( 'Contao\Automator' , 'Automator' ) ; foreach ( $ session as $ id ) { $ this -> Automator -> generateSitemap ( $ id ) ; } $ objSession -> set ( 'sitemap_updater' , null ) ; }
11047	function get_value ( $ parent , $ varname ) { if ( isset ( $ parent -> $ varname ) ) { return $ parent -> $ varname ; } else { $ elements = explode ( '[' , $ varname ) ; if ( count ( $ elements ) == 1 ) { return NULL ; } else { $ vartest = $ parent ; foreach ( $ elements as $ elementid => $ element ) { if ( $ elementid == 0 ) { $ vartest = $ parent -> $ element ; if ( ! isset ( $ vartest ) ) { return NULL ; } } else { $ index = substr ( $ element , 0 , - 1 ) ; if ( $ index == '_first' ) { $ keys = array_keys ( $ vartest ) ; $ index = $ keys [ 0 ] ; } elseif ( $ index == '_last' ) { $ keys = array_keys ( $ vartest ) ; $ index = $ keys [ count ( $ keys ) - 2 ] ; } if ( ! isset ( $ vartest [ $ index ] ) ) { return NULL ; } else { $ vartest = $ vartest [ $ index ] ; } } } } return $ vartest ; } }
7146	public function save_custom_profile_fields ( $ user_id ) { if ( 'POST' !== $ _SERVER [ 'REQUEST_METHOD' ] || ! isset ( $ _POST [ 'iac_nonce' ] ) ) { return ; } if ( ! wp_verify_nonce ( $ _POST [ 'iac_nonce' ] , 'iac_user_settings' ) ) { return ; } do_action ( 'iac_save_user_settings' , $ user_id , isset ( $ _POST [ 'post_subscription' ] ) ? $ _POST [ 'post_subscription' ] : NULL , isset ( $ _POST [ 'comment_subscription' ] ) ? $ _POST [ 'comment_subscription' ] : NULL ) ; }
6499	public function beforeStep ( Scope \ StepScope $ scope ) { self :: $ pageUrl = $ this -> getCurrentUrl ( ) ; $ _GET [ 'q' ] = ltrim ( parse_url ( static :: $ pageUrl ) [ 'path' ] , '/' ) ; drupal_path_initialize ( ) ; }
1734	public function validateCode ( User $ user , string $ code ) : bool { $ totp = TOTP :: create ( $ this -> getUpperUnpaddedSecretForUser ( $ user ) ) ; return $ totp -> verify ( $ code ) ; }
12398	public function select ( $ select = null ) { $ this -> scope -> select = Parser :: select ( $ select ) ; return $ this ; }
3736	protected function updateVariants ( $ item , $ activeLanguage , $ allIds , $ baseAttributes = false ) { foreach ( $ this -> getAttributes ( ) as $ strAttributeId => $ objAttribute ) { if ( ! $ item -> isAttributeSet ( $ objAttribute -> getColName ( ) ) ) { continue ; } if ( ! $ baseAttributes && $ item -> isVariant ( ) && ! ( $ objAttribute -> get ( 'isvariant' ) ) ) { continue ; } if ( $ item -> isVariantBase ( ) && ! ( $ objAttribute -> get ( 'isvariant' ) ) ) { $ arrIds = $ allIds ; } else { $ arrIds = array ( $ item -> get ( 'id' ) ) ; } $ this -> saveAttribute ( $ objAttribute , $ arrIds , $ item -> get ( $ strAttributeId ) , $ activeLanguage ) ; } }
11210	protected function addRegistry ( $ registry ) { $ this -> removeFromLookup ( $ registry ) ; if ( $ registry instanceof DelegatorAwareInterface ) { $ registry -> setDelegator ( $ this ) ; } $ this -> lookup_pool [ ] = $ registry ; return $ this ; }
6119	public function serverDelete ( $ sid ) { $ this -> serverListReset ( ) ; $ this -> execute ( "serverdelete" , array ( "sid" => $ sid ) ) ; Signal :: getInstance ( ) -> emit ( "notifyServerdeleted" , $ this , $ sid ) ; }
10438	public function offsetSet ( $ attributeName , $ attribute ) { if ( ! is_string ( $ attributeName ) || ! is_string ( $ attribute ) ) { throw new ValueException ( $ attribute , 'string' ) ; } $ this -> attributes [ $ attributeName ] = $ attribute ; }
2554	protected static function makePricingOptionFareFamilyOverride ( $ fareFamily ) { $ opt = [ ] ; if ( $ fareFamily !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_FARE_FAMILY ) ; $ po -> optionDetail = new OptionDetail ( [ [ 'FF' => $ fareFamily ] ] ) ; $ opt [ ] = $ po ; } return $ opt ; }
7713	function FindEndTag ( $ Encaps = false ) { if ( is_null ( $ this -> SelfClosing ) ) { $ pe = $ this -> PosEnd ; $ SelfClosing = ( substr ( $ this -> Txt , $ pe - 1 , 1 ) == '/' ) ; if ( ! $ SelfClosing ) { if ( $ Encaps ) { $ loc = clsTinyButStrong :: f_Xml_FindTag ( $ this -> Txt , $ this -> FindName ( ) , null , $ pe , true , - 1 , false , false ) ; if ( $ loc === false ) return false ; $ this -> pET_PosBeg = $ loc -> PosBeg ; $ this -> PosEnd = $ loc -> PosEnd ; } else { $ pe = clsTinyButStrong :: f_Xml_FindTagStart ( $ this -> Txt , $ this -> FindName ( ) , false , $ pe , true , true ) ; if ( $ pe === false ) return false ; $ this -> pET_PosBeg = $ pe ; $ pe = strpos ( $ this -> Txt , '>' , $ pe ) ; if ( $ pe === false ) return false ; $ this -> PosEnd = $ pe ; } } $ this -> SelfClosing = $ SelfClosing ; } return true ; }
2545	protected function makeDomXpath ( $ response ) { $ domDoc = $ this -> loadDomDocument ( $ response ) ; $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( self :: XMLNS_PREFIX , $ domDoc -> documentElement -> lookupNamespaceUri ( null ) ) ; return $ domXpath ; }
556	public function setComponents ( $ components ) { foreach ( $ components as $ id => $ component ) { $ this -> set ( $ id , $ component ) ; } }
11360	public function setSortBy ( $ sortKeys ) { if ( $ sortKeys == null ) { $ sortKeys = [ ] ; } if ( ! is_array ( $ sortKeys ) ) { $ sortKeys = [ $ sortKeys ] ; } $ this -> sortKeys = $ sortKeys ; }
4337	private function getDefaultOutputAs ( ) { $ ret = 'html' ; $ interface = $ this -> debug -> utilities -> getInterface ( ) ; if ( $ interface == 'ajax' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } elseif ( $ interface == 'http' ) { $ contentType = $ this -> debug -> utilities -> getResponseHeader ( ) ; if ( $ contentType && $ contentType !== 'text/html' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } } else { $ ret = 'text' ; } return $ ret ; }
7386	public static final function moveFile ( $ file ) { try { if ( $ file -> is_temp ) { rename ( $ file -> temp_destination . '/' . $ file -> temp_name , $ file -> original_destination . '/' . $ file -> temp_name ) ; if ( ! file_exists ( $ file -> original_destination . '/' . $ file -> temp_name ) ) { throw new CannotSaveFileInHardDriveException ( ) ; } $ file -> is_temp = false ; $ file -> expire = null ; $ file -> save ( ) ; } } catch ( \ Exception $ exception ) { throw new FileException ( $ exception -> getMessage ( ) ) ; } }
12341	protected function printError ( \ Throwable $ error , bool $ withTime = true , ? string $ fontColor = null , ? string $ bgColor = self :: BG_COLOR_MAP [ 'red' ] ) : void { $ shift = $ withTime ? "\t\t" : '' ; $ this -> print ( $ this -> getColoredMsg ( 'Error: ' . $ error -> getMessage ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'File: ' . $ error -> getFile ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'Line: ' . $ error -> getLine ( ) , $ fontColor , $ bgColor ) , $ withTime ) ; }
4729	public function isSingular ( $ word ) { $ inflection = $ this -> getCachedPlural ( $ word ) ; if ( $ inflection !== false ) { return true ; } $ pluralWord = $ this -> toPlural ( $ word ) ; if ( $ pluralWord === false ) { return false ; } return $ this -> toSingular ( $ pluralWord ) == $ word ; }
5995	public function addFolderResponse ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FolderResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "FolderResponse"!' , E_USER_WARNING ) ; } } $ this -> subFolders [ ] = $ item ; return $ this ; }
7199	protected function assignSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> assignSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> assignSaleItemRecursively ( $ child ) ; } }
663	public function getMaster ( ) { if ( $ this -> _master === false ) { $ this -> _master = $ this -> shuffleMasters ? $ this -> openFromPool ( $ this -> masters , $ this -> masterConfig ) : $ this -> openFromPoolSequentially ( $ this -> masters , $ this -> masterConfig ) ; } return $ this -> _master ; }
3028	public function setConsumer ( $ key , $ secret ) { $ this -> consumer = new \ Eher \ OAuth \ Consumer ( $ key , $ secret ) ; }
2946	public function setRolesById ( $ roles ) { $ roles = is_array ( $ roles ) ? $ roles : [ $ roles ] ; return $ this -> roles ( ) -> sync ( $ roles ) ; }
5872	public static function getTransformation ( $ orientation ) { $ transformation = '' ; if ( ( isset ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'processor' ] ) && $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'processor' ] === 'ImageMagick' ) || ( isset ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'im_version_5' ] ) && $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'im_version_5' ] !== 'gm' ) ) { if ( $ orientation >= 2 && $ orientation <= 8 ) { $ transformation = '-auto-orient' ; } } else { switch ( $ orientation ) { case 2 : $ transformation = '-flip horizontal' ; break ; case 3 : $ transformation = '-rotate 180' ; break ; case 4 : $ transformation = '-flip vertical' ; break ; case 5 : $ transformation = '-transpose' ; break ; case 6 : $ transformation = '-rotate 90' ; break ; case 7 : $ transformation = '-transverse' ; break ; case 8 : $ transformation = '-rotate 270' ; break ; } } return $ transformation ; }
1414	public function resourceCannotBeDeleted ( string $ detail = null ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_cannot_be_deleted' , 'code' ) , $ this -> trans ( 'resource_cannot_be_deleted' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_cannot_be_deleted' , 'detail' ) ) ; }
10186	private static function fromArray ( $ object , $ type = null , $ innerType = null ) { if ( $ type == 'array' ) { foreach ( $ object as $ element ) { $ result [ ] = self :: fromArray ( $ element , $ innerType ) ; } return $ result ; } else if ( class_exists ( $ type ) ) { $ class = new $ type ( ) ; if ( is_subclass_of ( $ class , 'AbstractJSONWrapper' ) ) { $ class -> fromArray ( $ object ) ; return $ class ; } else { trigger_error ( __CLASS__ . ": Trying to deserialize " . get_class ( $ class ) ) ; return $ object ; } } else { return $ object ; } }
9851	public static function hashPassword ( $ pPassword ) { $ password = 0x0000 ; $ charPos = 1 ; $ chars = preg_split ( '//' , $ pPassword , - 1 , PREG_SPLIT_NO_EMPTY ) ; foreach ( $ chars as $ char ) { $ value = ord ( $ char ) << $ charPos ++ ; $ rotated_bits = $ value >> 15 ; $ value &= 0x7fff ; $ password ^= ( $ value | $ rotated_bits ) ; } $ password ^= strlen ( $ pPassword ) ; $ password ^= 0xCE4B ; return strtoupper ( dechex ( $ password ) ) ; }
6788	protected function getCustomerGroupFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerGroupInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerGroupInterface :: class ) ; } return $ resource ; }
11509	protected function parseMessageFromRequest ( $ content ) { $ content = strval ( $ content ) ; $ dataSet = json_decode ( $ content , true ) ; if ( $ dataSet && ( JSON_ERROR_NONE === json_last_error ( ) ) ) { $ content = XML :: build ( $ dataSet ) ; } if ( $ this -> isSafeMode ( ) ) { if ( ! $ this -> encryptor ) { throw new RuntimeException ( 'Safe mode Encryptor is necessary, please use Guard::setEncryptor(Encryptor $encryptor) set the encryptor instance.' ) ; } $ message = $ this -> encryptor -> decryptMsg ( $ this -> request -> get ( 'msg_signature' ) , $ this -> request -> get ( 'nonce' ) , $ this -> request -> get ( 'timestamp' ) , $ content ) ; } else { $ message = XML :: parse ( $ content ) ; } return $ message ; }
5183	public function article ( string $ singleJsonArticle ) : Article { if ( json_decode ( $ singleJsonArticle , true ) ) { $ dataArticle = json_decode ( $ singleJsonArticle , true ) [ 'data' ] ; $ article = new Article ( $ this -> filterString ( $ this -> getValue ( 'title' , $ dataArticle ) ) , $ this -> filterString ( $ this -> getValue ( 'body' , $ dataArticle ) ) , $ this -> filterString ( $ this -> getValue ( 'source' , $ dataArticle ) ) , $ this -> getValue ( 'unique_id' , $ dataArticle ) , $ this -> filterInteger ( $ this -> getValue ( 'type_id' , $ dataArticle [ 'type' ] ) ) , $ this -> filterInteger ( $ this -> getValue ( 'category_id' , $ dataArticle [ 'category' ] ) ) , $ this -> getValue ( 'reporter' , $ dataArticle ) , $ this -> filterString ( $ this -> getValue ( 'lead' , $ dataArticle ) ) , $ this -> getValue ( 'tag_name' , $ dataArticle [ 'tags' ] ) , $ this -> filterString ( $ this -> getValue ( 'published_at' , $ dataArticle ) ) , ( string ) $ this -> filterInteger ( $ this -> getValue ( 'id' , $ dataArticle ) ) ) ; $ attachmentConstants = [ Article :: ATTACHMENT_FIELD_PHOTO , Article :: ATTACHMENT_FIELD_PAGE , Article :: ATTACHMENT_FIELD_GALLERY , Article :: ATTACHMENT_FIELD_VIDEO , ] ; $ attachmentTypes = [ self :: JSON_PHOTO_FIELD , self :: JSON_PAGE_FIELD , self :: JSON_GALLERY_FIELD , self :: JSON_VIDEO_FIELD , ] ; $ attachmentAttributes = $ this -> lookUp ( $ attachmentConstants ) ; return $ this -> generalAttachment ( $ article , $ attachmentConstants , $ attachmentTypes , $ attachmentAttributes , $ dataArticle ) ; } throw new \ Exception ( 'Empty or invalid JSON Response' , 1 ) ; }
8452	protected function checkUrlExistsAndSize ( $ fileUri , array $ mediaFileInfo ) { $ mediaFileInfo [ 'url' ] = $ fileUri ; $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , "$fileUri" ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11" ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_HEADER , false ) ; curl_setopt ( $ curl , CURLOPT_NOBODY , true ) ; if ( curl_exec ( $ curl ) === false ) { return false ; } $ info = curl_getinfo ( $ curl ) ; $ mediaFileInfo [ 'filesize' ] = $ info [ 'download_content_length' ] ; $ mediaFileInfo [ 'filemimetype' ] = $ info [ 'content_type' ] ; $ mediaFileInfo [ 'fileextension' ] = pathinfo ( parse_url ( $ mediaFileInfo [ 'url' ] , PHP_URL_PATH ) , PATHINFO_EXTENSION ) ; curl_close ( $ curl ) ; return $ mediaFileInfo ; }
5887	public function iconGetName ( $ key ) { $ iconid = ( $ this [ $ key ] < 0 ) ? ( pow ( 2 , 32 ) ) - ( $ this [ $ key ] * - 1 ) : $ this [ $ key ] ; return new StringHelper ( "/icon_" . $ iconid ) ; }
10832	public function actionIndex ( ) { $ searchModel = new SearchState ( Yii :: $ app -> request -> get ( ) ) ; $ dataProvider = $ searchModel -> search ( Yii :: $ app -> request -> queryParams ) ; return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider ] ) ; }
8826	protected function migrationToClassName ( $ migrationName ) { $ class = str_replace ( '_' , ' ' , $ migrationName ) ; $ class = ucwords ( $ class ) ; $ class = str_replace ( ' ' , '' , $ class ) ; if ( ! $ this -> isValidClassName ( $ class ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Migration class "%s" is invalid' , $ class ) ) ; } return $ class ; }
7482	public function changeEncoding ( $ encoding ) { $ encoding = ( string ) $ encoding ; $ this -> string = iconv ( $ this -> encoding , $ encoding , $ this -> string ) ; $ this -> encoding = $ encoding ; return $ this ; }
10038	function renameCustomField ( $ oldName , $ newName ) { $ encodedOldName = urlencode ( mb_convert_encoding ( $ oldName , "UTF-8" ) ) ; $ encodedNewName = urlencode ( mb_convert_encoding ( $ newName , "UTF-8" ) ) ; return $ this -> put ( "contacts/fields/custom/${encodedOldName}/${encodedNewName}" ) ; }
8348	public function setValue ( string $ v ) : string { if ( static :: isValid ( $ v ) === false ) { throw new BadUse ( '"' . $ v . '" is not recognized as a possible value' ) ; } $ this -> value = $ v ; }
1604	public function onException ( ExceptionEvent $ event ) { $ exception = $ event -> exception ; $ craft = \ Craft :: $ app ; if ( ! ( $ exception instanceof HttpException ) || $ exception -> statusCode !== 404 ) return ; $ path = $ craft -> request -> getFullPath ( ) ; $ query = $ craft -> request -> getQueryStringWithoutPath ( ) ; if ( $ query ) $ path .= '?' . $ query ; if ( $ redirect = $ this -> findRedirectByPath ( $ path ) ) { $ event -> handled = true ; $ craft -> response -> redirect ( $ redirect [ 'to' ] , $ redirect [ 'type' ] ) -> send ( ) ; $ craft -> end ( ) ; } }
11023	public function run ( string $ task , $ ostr = STDERR ) { $ task = str_replace ( ":" , "\\" , $ task ) ; $ log = Logger :: getLogger ( '' ) ; $ log -> addLogWriter ( new StreamWriter ( STDOUT ) ) ; if ( ! class_exists ( $ task ) ) { fprintf ( $ ostr , "Error: task does not exist: {$task}\n" ) ; return false ; } try { if ( ! is_subclass_of ( $ task , TaskInterface :: class ) ) { fprintf ( $ ostr , "Error: invalid task: {$task}\n" ) ; return false ; } $ taskrunner = new $ task ; $ taskrunner -> execute ( ) ; } catch ( \ Throwable $ e ) { fprintf ( $ ostr , "Error: error while running task: %s\n" , $ task ) ; fprintf ( $ ostr , "Exception: %s\n" , get_class ( $ e ) ) ; fprintf ( $ ostr , "Message: %s\n" , $ e -> getMessage ( ) ) ; if ( method_exists ( $ e , "getLine" ) ) fprintf ( $ ostr , "On: %s (line %d)\n" , $ e -> getFile ( ) , $ e -> getLine ( ) ) ; fprintf ( $ ostr , $ e -> getTraceAsString ( ) . "\n" ) ; return false ; } return true ; }
11480	private function getJsonBody ( RequestInterface $ request , ResponseInterface $ response ) : array { $ data = json_decode ( $ response -> getBody ( ) , true ) ; if ( ! $ data || ! is_array ( $ data ) || ! array_key_exists ( "data" , $ data ) ) { throw new ClientException ( "Response body does not contain a valid JSON object." , $ request , $ response ) ; } if ( ! is_array ( $ data ) || ! is_array ( $ data [ "data" ] ) ) { throw new ClientException ( "Not sure what happened. The list jobs endpoint didn't return a list. :worried:" , $ request , $ response ) ; } return $ data [ "data" ] ; }
12459	public function indexAction ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ cfGroups = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> findAll ( ) ; $ defaultGroups = $ this -> getDefaultGroupsId ( ) ; $ makeDefaultFormViews = array ( ) ; foreach ( $ cfGroups as $ group ) { if ( ! in_array ( $ group -> getId ( ) , $ defaultGroups ) ) { $ makeDefaultFormViews [ $ group -> getId ( ) ] = $ this -> createMakeDefaultForm ( $ group ) -> createView ( ) ; } } return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:index.html.twig' , array ( 'entities' => $ cfGroups , 'default_groups' => $ defaultGroups , 'make_default_forms' => $ makeDefaultFormViews ) ) ; }
6801	public function installTaxes ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_taxes.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Taxes data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } $ country = $ this -> manager -> getRepository ( Country :: class ) -> findOneBy ( [ 'code' => $ code ] ) ; if ( null === $ country ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( null === $ taxRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ tax = new Tax ( ) ; $ tax -> setName ( $ name ) -> setRate ( $ datum [ 'rate' ] ) -> setCountry ( $ country ) ; $ this -> manager -> persist ( $ tax ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
10161	private function readPane ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ px = self :: getUInt2d ( $ recordData , 0 ) ; $ py = self :: getUInt2d ( $ recordData , 2 ) ; $ rwTop = self :: getUInt2d ( $ recordData , 4 ) ; $ colLeft = self :: getUInt2d ( $ recordData , 6 ) ; if ( $ this -> frozen ) { $ cell = Coordinate :: stringFromColumnIndex ( $ px + 1 ) . ( $ py + 1 ) ; $ topLeftCell = Coordinate :: stringFromColumnIndex ( $ colLeft + 1 ) . ( $ rwTop + 1 ) ; $ this -> phpSheet -> freezePane ( $ cell , $ topLeftCell ) ; } } }
4749	public function getAddonsForPlan ( array $ plans , string $ addonType = null ) : array { $ addonApi = new Addon ( $ this -> token , $ this -> organizationId , $ this -> cache , $ this -> ttl ) ; foreach ( $ plans as & $ plan ) { $ addons = [ ] ; foreach ( $ plan [ 'addons' ] as $ planAddon ) { $ addon = $ addonApi -> getAddon ( $ planAddon [ 'addon_code' ] ) ; if ( null !== $ addonType ) { if ( ( $ addon [ 'type' ] == $ addonType ) && ( in_array ( $ addonType , self :: $ addonTypes ) ) ) { $ addons [ ] = $ addon ; } } else { $ addons [ ] = $ addon ; } } $ plan [ 'addons' ] = $ addons ; } return $ plans ; }
1293	private function getTokenFromResponse ( array $ data ) : string { $ url = $ data [ 'nextSyncUrl' ] ?? $ data [ 'nextPageUrl' ] ; $ queryValues = [ ] ; \ parse_str ( \ parse_url ( $ url , \ PHP_URL_QUERY ) , $ queryValues ) ; return $ queryValues [ 'sync_token' ] ; }
3277	public function getKeys ( ) : array { $ keys = [ ] ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { $ keys [ ] = $ line -> getKey ( ) ; } return $ keys ; }
11836	public function addAction ( AbstractAction $ action ) { $ action -> setGroup ( $ this ) ; $ this -> actions [ $ action -> getName ( ) ] = $ action ; return $ this ; }
6613	public function settings ( $ setting = null ) { if ( ! is_null ( $ setting ) ) { return isset ( $ this -> settings [ $ setting ] ) ? $ this -> settings [ $ setting ] : null ; } return $ this -> settings ; }
8489	public static function getCpuArchitecture ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Architecture FROM Win32_Processor" ) as $ cpu ) { switch ( $ cpu -> Architecture ) { case 0 : return "x86" ; case 1 : return "MIPS" ; case 2 : return "Alpha" ; case 3 : return "PowerPC" ; case 6 : return "Itanium-based systems" ; case 9 : return "x64" ; } } return "Unknown" ; }
8432	public function getDsn ( array $ info ) : string { $ dsn = 'pgsql:host=' ; $ dsn .= ( isset ( $ info [ 'host' ] ) === true ? $ info [ 'host' ] : 'localhost' ) . ';' ; if ( isset ( $ info [ 'port' ] ) === true ) { $ dsn .= 'port=' . $ info [ 'port' ] . ';' ; } $ dsn .= 'dbname=' . $ info [ 'name' ] . ';' ; return $ dsn ; }
11084	public static function deleteDirectory ( $ dirName , $ deleteSelf = true ) { $ dirName = rtrim ( $ dirName , '/' ) . '/' ; if ( file_exists ( $ dirName ) && $ files = scandir ( $ dirName , SCANDIR_SORT_NONE ) ) { foreach ( $ files as $ file ) { if ( $ file !== '.' && $ file !== '..' && $ file !== '.svn' ) { if ( is_dir ( $ dirName . $ file ) ) { self :: deleteDirectory ( $ dirName . $ file , true ) ; } elseif ( file_exists ( $ dirName . $ file ) ) { @ chmod ( $ dirName . $ file , 0777 ) ; unlink ( $ dirName . $ file ) ; } } } if ( $ deleteSelf && ! rmdir ( $ dirName ) ) { @ chmod ( $ dirName , 0777 ) ; return false ; } return true ; } return false ; }
11168	public function getApiAsArray ( ) { if ( $ this -> useCache ( ) ) { if ( $ this -> getExtCache ( ) -> isApiCached ( ) ) { return $ this -> getExtCache ( ) -> getApi ( ) ; } } $ api = $ this -> generateApi ( ) ; if ( $ this -> useCache ( ) ) { $ this -> getExtCache ( ) -> cacheApi ( $ api ) ; } return $ api ; }
6510	protected function initHandler ( HandlerInterface $ handler ) { if ( $ this -> formatter != null ) { $ handler -> setFormatter ( $ this -> formatter ) ; } foreach ( $ this -> processors as $ processor ) { $ handler -> pushProcessor ( $ processor ) ; } return $ handler ; }
5351	public function setDatabasePassword ( $ domainName , $ database , $ password ) { return $ this -> call ( self :: SERVICE , 'setDatabasePassword' , [ $ domainName , $ database , $ password ] ) ; }
2636	public function getLastVersion ( ) { try { $ url = self :: CHECK_VERSION_URL ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> write ( \ Zend_Http_Client :: GET , $ url , '1.1' ) ; $ responseBody = $ client -> read ( ) ; $ client -> close ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; if ( $ responseCode !== 200 ) { return false ; } $ body = \ Zend_Http_Response :: extractBody ( $ responseBody ) ; $ json = json_decode ( $ body ) ; $ version = ! empty ( $ json -> version ) ? $ json -> version : false ; return $ version ; } catch ( \ Exception $ e ) { $ this -> _logger -> log ( 100 , $ e -> getMessage ( ) . $ url ) ; return false ; } }
6746	public function getCatalogue ( $ locale = null ) { if ( $ this -> translator instanceof TranslatorBagInterface ) { return $ this -> translator -> getCatalogue ( $ locale ) ; } return null ; }
6827	public static function isValid ( $ action , $ throw = false ) { if ( in_array ( $ action , static :: getActions ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Unknown gateway action '$action'." ) ; } return false ; }
9501	public function watch ( WatcherInterface $ watcher ) { $ events = $ this -> getEvents ( ) ; $ watcher -> watch ( $ this -> getTrackedPaths ( ) , $ events , [ $ this , 'runPeridot' ] ) ; }
10626	public static function docroot ( ) { if ( ! empty ( $ _SERVER [ 'DOCUMENT_ROOT' ] ) ) { $ docroot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; } else { $ docroot = str_replace ( '\\' , '/' , dirname ( __FILE__ ) ) ; } return $ docroot ; }
3482	public function withContentAvailable ( bool $ contentAvailable ) : Aps { $ cloned = clone $ this ; $ cloned -> contentAvailable = $ contentAvailable ; return $ cloned ; }
11279	public static function applyDataToView ( $ view , $ data ) { if ( ! empty ( $ data ) ) { foreach ( $ data as $ name => $ value ) { if ( is_string ( $ value ) ) { $ view = str_replace ( '{' . $ name . '}' , $ value , $ view ) ; } } } return $ view ; }
5220	public function contains ( $ path ) { $ realpath = realpath ( $ path ) ; if ( false === $ realpath ) { return false ; } return substr ( $ realpath , 0 , strlen ( $ this -> rootpath ) ) === $ this -> rootpath ; }
1257	public static function createRuntime ( ) { switch ( $ compileDir = getenv ( self :: COMPILE_DIR ) ) { case false : return new AstRuntime ( ) ; case 'on' : return new CompilerRuntime ( ) ; default : return new CompilerRuntime ( $ compileDir ) ; } }
126	protected function createRemoveRule ( PackageInterface $ package , $ reason , $ job ) { return new GenericRule ( array ( - $ package -> id ) , $ reason , $ job [ 'packageName' ] , $ job ) ; }
11584	public function exec ( $ calcId ) { $ result = [ ] ; $ bonusPercent = Cfg :: TEAM_BONUS_EU_PERCENT ; $ dwnlCompress = $ this -> daoBonDwnl -> getByCalcId ( $ calcId ) ; $ dwnlCurrent = $ this -> daoDwnl -> get ( ) ; $ mapDwnlById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCompress , EBonDwnl :: A_CUST_REF ) ; $ mapCustById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCurrent , ECustomer :: A_CUSTOMER_REF ) ; foreach ( $ mapDwnlById as $ custId => $ custDwnl ) { $ custData = $ mapCustById [ $ custId ] ; $ custMlmId = $ custData -> getMlmId ( ) ; $ pv = $ custDwnl -> getPv ( ) ; $ parentId = $ custDwnl -> getParentRef ( ) ; $ parentDwnl = $ mapDwnlById [ $ parentId ] ; $ parentData = $ mapCustById [ $ parentId ] ; $ parentMlmId = $ parentData -> getMlmId ( ) ; $ scheme = $ this -> hlpScheme -> getSchemeByCustomer ( $ parentData ) ; if ( $ scheme == Cfg :: SCHEMA_EU ) { $ pvParent = $ parentDwnl -> getPv ( ) ; if ( $ pvParent > ( Cfg :: PV_QUALIFICATION_LEVEL_EU - Cfg :: DEF_ZERO ) ) { $ bonus = $ this -> hlpFormat -> roundBonus ( $ pv * $ bonusPercent ) ; if ( $ bonus > Cfg :: DEF_ZERO ) { $ entry = new DBonus ( ) ; $ entry -> setCustomerRef ( $ parentId ) ; $ entry -> setDonatorRef ( $ custId ) ; $ entry -> setValue ( $ bonus ) ; $ result [ ] = $ entry ; } $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) has '$bonus' as EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } else { $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) does not qualified t oget EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } } else { $ this -> logger -> debug ( "Parent #$parentId (ref. #$parentMlmId) has incompatible scheme '$scheme' for EU Team Bonus." ) ; } } unset ( $ mapCustById ) ; unset ( $ mapDwnlById ) ; return $ result ; }
12367	protected function getOption ( $ name ) { if ( ! isset ( $ this -> options [ $ name ] ) ) { throw new ValueNotFoundException ( $ name ) ; } return $ this -> options [ $ name ] ; }
3110	public function removeCatValue ( $ assessmentSectionId , $ key ) { if ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) { unset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ; } return $ this ; }
9510	public function download ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DOWNLOAD ) ; return $ this -> logViewer -> download ( $ log -> date ) ; }
1874	private function addComponents ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; foreach ( Versions :: VERSIONS as $ name => $ version ) { if ( 0 !== strncmp ( 'contao-components/' , $ name , 18 ) ) { continue ; } $ serviceId = 'assets._package_' . $ name ; $ basePath = 'assets/' . substr ( $ name , 18 ) ; $ version = $ this -> createVersionStrategy ( $ container , $ version , $ name ) ; $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ version , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ name , new Reference ( $ serviceId ) ] ) ; } }
5358	protected function createParameters ( Operation $ operation , $ queryParamDocumentation , Context $ context ) { $ documentationParams = [ ] ; $ methodParameters = [ ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof PathParameterSubSchema ) { $ methodParameters [ ] = $ this -> pathParameterGenerator -> generateMethodParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ; $ documentationParams [ ] = sprintf ( ' * @param %s' , $ this -> pathParameterGenerator -> generateDocParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ) ; } } foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof BodyParameter ) { $ methodParameters [ ] = $ this -> bodyParameterGenerator -> generateMethodParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ; $ documentationParams [ ] = sprintf ( ' * @param %s' , $ this -> bodyParameterGenerator -> generateDocParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ) ; } } } if ( ! empty ( $ queryParamDocumentation ) ) { $ documentationParams [ ] = " * @param array \$parameters {" ; $ documentationParams = array_merge ( $ documentationParams , array_map ( function ( $ doc ) { return " * " . $ doc ; } , $ queryParamDocumentation ) ) ; $ documentationParams [ ] = " * }" ; } else { $ documentationParams [ ] = " * @param array \$parameters List of parameters" ; } $ documentationParams [ ] = " * @param string \$fetch Fetch mode (object or response)" ; $ methodParameters [ ] = new Param ( 'parameters' , new Expr \ Array_ ( ) ) ; $ methodParameters [ ] = new Param ( 'fetch' , new Expr \ ConstFetch ( new Name ( 'self::FETCH_OBJECT' ) ) ) ; return [ $ documentationParams , $ methodParameters ] ; }
11299	function getFullClassName ( $ class = false ) { if ( $ class == false ) { $ class = $ this ; } $ className = get_class ( $ class ) ; if ( $ pos = strpos ( $ className , '\\' ) ) return substr ( $ className , $ pos + 1 ) ; return $ className ; }
6664	public function instantiate ( $ profile , $ provider ) { $ this -> provider = $ provider ; switch ( $ provider ) { case 'facebook' : $ this -> info = $ this -> parseFb ( $ profile ) ; break ; case 'twitter' : $ this -> info = $ this -> parseTwt ( $ profile ) ; break ; } return $ this ; }
8460	public function exec ( $ command ) { fwrite ( $ this -> _fp , str_replace ( "\n" , '\n' , $ command ) . PHP_EOL ) ; $ answer = fgets ( $ this -> _fp ) ; if ( is_string ( $ answer ) ) { if ( substr ( $ answer , 0 , 7 ) === 'ANSWER ' ) { $ bytes = ( int ) substr ( $ answer , 7 ) ; if ( $ bytes > 0 ) { $ jsonObj = json_decode ( trim ( fread ( $ this -> _fp , $ bytes + 1 ) ) ) ; if ( is_null ( $ jsonObj ) ) { return 'You must enable the json flag on the telegram daemon to get proper response messages here.' ; } return $ jsonObj ; } } else { return $ answer ; } } return false ; }
3564	public function castToString ( ) { if ( $ this -> attributes [ 'meta_type' ] == 'array' ) { return $ this -> attributes [ 'meta_value' ] ; } $ value = $ this -> getValue ( ) ; if ( $ this -> isStringable ( $ value ) || is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } return '' ; }
11895	public function decrypt ( $ data ) { if ( ! is_string ( $ data ) || ! preg_match ( '/^[0-9A-Fa-f]*$/' , $ data ) ) { throw new \ InvalidArgumentException ( 'blowfishDecryptCBC require hex input' , 1502 ) ; } $ data = pack ( 'H*' , $ data ) ; if ( $ this -> iv === null ) { $ return = mcrypt_decrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode ) ; } else { $ return = mcrypt_decrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode , $ this -> iv ) ; } return rtrim ( $ return , "\0" ) ; }
4553	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; foreach ( $ this -> removed as $ property ) { if ( ! array_key_exists ( $ property , $ data ) ) { throw new OutOfRangeException ( 'Property does not exist.' ) ; } unset ( $ data [ $ property ] ) ; } $ event -> setData ( $ data ) ; }
2286	protected static function agent ( ) { $ ua = static :: get ( 'httpUserAgent' ) ; $ return = new \ stdClass ( ) ; $ return -> string = $ ua ; $ os = 'unknown' ; $ mobile = false ; $ browser = 'other' ; $ shorty = '' ; $ version = '' ; $ engine = '' ; foreach ( Config :: get ( 'os' ) as $ k => $ v ) { if ( stripos ( $ ua , $ k ) !== false ) { $ os = $ v [ 'os' ] ; $ mobile = $ v [ 'mobile' ] ; break ; } } $ return -> os = $ os ; foreach ( Config :: get ( 'browser' ) as $ k => $ v ) { if ( stripos ( $ ua , $ k ) !== false ) { $ browser = $ v [ 'browser' ] ; $ shorty = $ v [ 'shorty' ] ; $ version = preg_replace ( $ v [ 'version' ] , '$1' , $ ua ) ; $ engine = $ v [ 'engine' ] ; break ; } } $ versions = explode ( '.' , $ version ) ; $ version = $ versions [ 0 ] ; $ return -> class = $ os . ' ' . $ browser . ' ' . $ engine ; if ( $ version != '' ) { $ return -> class .= ' ' . $ shorty . $ version ; } if ( $ os == 'android' && $ engine != 'presto' && stripos ( $ ua , 'mobile' ) === false ) { $ mobile = false ; } if ( $ mobile ) { $ return -> class .= ' mobile' ; } $ return -> browser = $ browser ; $ return -> shorty = $ shorty ; $ return -> version = $ version ; $ return -> engine = $ engine ; $ return -> versions = $ versions ; $ return -> mobile = $ mobile ; return $ return ; }
4806	protected function processMemberVar ( File $ phpcsFile , $ stackPtr ) { $ tokens = $ phpcsFile -> getTokens ( ) ; $ commentToken = [ T_COMMENT , T_DOC_COMMENT_CLOSE_TAG , ] ; $ commentEnd = $ phpcsFile -> findPrevious ( $ commentToken , $ stackPtr ) ; $ commentStart = $ tokens [ $ commentEnd ] [ 'comment_opener' ] ; if ( $ tokens [ $ commentEnd ] [ 'line' ] === $ tokens [ $ commentStart ] [ 'line' ] ) { $ phpcsFile -> addError ( 'Member variable comment should not be inline' , $ stackPtr , static :: ERROR_CODE ) ; } }
10880	public function renderPreviousExceptions ( $ exception ) { if ( ( $ previous = $ exception -> getPrevious ( ) ) !== null ) { return $ this -> renderFile ( $ this -> previousExceptionView , [ 'exception' => $ previous ] ) ; } else { return '' ; } }
3842	private function parsePanelSort ( PanelRowInterface $ row ) { if ( ! $ row -> hasElement ( 'sort' ) ) { $ element = new DefaultSortElementInformation ( ) ; $ row -> addElement ( $ element ) ; } }
11418	public static function createInstance ( $ environment , $ options = null ) { if ( ! self :: $ _instance ) { self :: $ _instance = new static ( $ environment , $ options , false ) ; } return self :: $ _instance ; }
10311	function getRecipients ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeDeletedRecipients = false , $ standardFields = null , $ customFields = null , $ embedFieldBackups = false , $ pageIndex = 1 , $ pageSize = 100 ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null , $ embedFieldBackups ) ; $ params = $ this -> appendArrayFields ( $ params , "standard_field" , $ standardFields ) ; $ params = $ this -> appendArrayFields ( $ params , "custom_field" , $ customFields ) ; if ( isset ( $ excludeDeletedRecipients ) ) $ params [ 'exclude_deleted_recipients' ] = ( $ excludeDeletedRecipients == true ) ? "true" : "false" ; return $ this -> get ( 'reports/recipients' , $ params ) ; }
3437	public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ sectionsBackup = isset ( $ this -> fields [ 'IBLOCK_SECTION' ] ) ? $ this -> fields [ 'IBLOCK_SECTION' ] : null ; $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; if ( ! empty ( $ sectionsBackup ) ) { $ this -> fields [ 'IBLOCK_SECTION' ] = $ sectionsBackup ; } $ this -> fieldsAreFetched = true ; $ this -> original = $ this -> fields ; return $ this -> fields ; }
9417	public function fwhm ( ) { $ float_fwhm = 2 * sqrt ( 2 * log ( 2 ) ) * $ this -> float_sigma ; if ( $ this -> int_precision ) { return round ( $ float_fwhm , $ this -> int_precision ) ; } return $ float_fwhm ; }
9631	public function setSetting ( $ key , $ value ) { $ settings = $ this -> getSettings ( ) ; $ settings [ $ key ] = $ value ; $ this -> setSettings ( $ settings ) ; }
9968	public function setHyperlink ( $ pCellCoordinate , Hyperlink $ pHyperlink = null ) { if ( $ pHyperlink === null ) { unset ( $ this -> hyperlinkCollection [ $ pCellCoordinate ] ) ; } else { $ this -> hyperlinkCollection [ $ pCellCoordinate ] = $ pHyperlink ; } return $ this ; }
4725	private function addRule ( $ data , $ ruleType ) { if ( \ is_string ( $ data ) ) { $ data = array ( $ data ) ; } elseif ( ! \ is_array ( $ data ) ) { throw new InvalidArgumentException ( 'Invalid inflector rule data.' ) ; } foreach ( $ data as $ rule ) { array_push ( $ this -> rules [ $ ruleType ] , ( string ) $ rule ) ; } }
4456	protected function fetchQueue ( string $ eventName ) : SplPriorityQueue { if ( isset ( $ this -> events [ $ eventName ] ) == false ) { $ this -> events [ $ eventName ] = $ this -> createQueue ( ) ; } return $ this -> events [ $ eventName ] ; }
1479	public function removeRelationship ( $ resourceType , $ id , $ relationshipKey , array $ queryParams = [ ] ) { $ name = RouteName :: removeRelationship ( $ resourceType , $ relationshipKey ) ; return $ this -> resource ( $ name , $ id , $ queryParams ) ; }
6167	protected function writePerformance ( $ time ) { $ ms = round ( $ time * 1000 ) ; foreach ( self :: $ performanceThresholds as $ colour => $ threshold ) { if ( $ ms > $ threshold ) { break ; } } $ this -> writeWithColor ( $ colour , " ($ms ms)" ) ; }
12814	private static function getNullableNames ( string $ table ) : array { if ( self :: $ nullablesCache === null || ! array_key_exists ( $ table , self :: $ nullablesCache ) ) self :: getNullables ( $ table ) ; return array_keys ( self :: $ nullablesCache [ $ table ] ) ; }
2157	public function generate ( ) { if ( $ this -> youtube == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://youtu.be/' . $ this -> youtube . '" target="_blank" rel="noreferrer noopener">youtu.be/' . $ this -> youtube . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
2356	public function hasBackendUser ( ) : bool { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof BackendUser ; }
4206	private function getPropInfo ( Event $ abs , \ ReflectionProperty $ reflectionProperty ) { $ obj = $ abs -> getSubject ( ) ; $ reflectionProperty -> setAccessible ( true ) ; $ className = \ get_class ( $ obj ) ; $ commentInfo = $ this -> getPropCommentInfo ( $ reflectionProperty ) ; $ declaringClassName = $ reflectionProperty -> getDeclaringClass ( ) -> getName ( ) ; $ propInfo = \ array_merge ( static :: $ basePropInfo , array ( 'desc' => $ commentInfo [ 'desc' ] , 'inheritedFrom' => $ declaringClassName !== $ className ? $ declaringClassName : null , 'isStatic' => $ reflectionProperty -> isStatic ( ) , 'type' => $ commentInfo [ 'type' ] , ) ) ; if ( $ reflectionProperty -> isPrivate ( ) ) { $ propInfo [ 'visibility' ] = 'private' ; } elseif ( $ reflectionProperty -> isProtected ( ) ) { $ propInfo [ 'visibility' ] = 'protected' ; } if ( $ abs [ 'collectPropertyValues' ] ) { $ propName = $ reflectionProperty -> getName ( ) ; if ( \ array_key_exists ( $ propName , $ abs [ 'propertyOverrideValues' ] ) ) { $ propInfo [ 'value' ] = $ abs [ 'propertyOverrideValues' ] [ $ propName ] ; $ propInfo [ 'valueFrom' ] = 'debug' ; } else { $ propInfo [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } return $ propInfo ; }
9619	public function checkAnswer ( $ extraParams = array ( ) ) { $ remoteIp = $ _SERVER [ "REMOTE_ADDR" ] ; $ challenge = $ _POST [ "recaptcha_challenge_field" ] ; $ response = $ _POST [ "recaptcha_response_field" ] ; if ( ! $ this -> getPrivateKey ( ) ) { throw new \ Exception ( "To use reCAPTCHA you must get an API key from <a href='https://www.google.com/recaptcha/admin/create'>https://www.google.com/recaptcha/admin/create</a>" ) ; } if ( ! $ remoteIp ) { throw new \ Exception ( "For security reasons, you must pass the remote ip to reCAPTCHA" ) ; } if ( ! $ challenge ) { $ this -> valid = false ; $ this -> error = 'incorrect-captcha-sol' ; } else { $ response = $ this -> httpPost ( self :: RECAPTCHA_VERIFY_SERVER , '/recaptcha/api/verify' , array ( 'privatekey' => $ this -> getPrivateKey ( ) , 'remoteip' => $ remoteIp , 'challenge' => $ challenge , 'response' => $ response , ) + $ extraParams ) ; $ answers = explode ( "\n" , $ response [ 1 ] ) ; if ( trim ( $ answers [ 0 ] ) == 'true' ) { $ this -> valid = true ; } else { $ this -> valid = false ; $ this -> error = $ answers [ 1 ] ; } } return $ this ; }
7226	public function info ( $ name = null ) { if ( $ name ) { return $ this -> info ? $ this -> info [ $ name ] : curl_getinfo ( $ this -> curl , "CURLINFO" . strtoupper ( $ name ) ) ; } else { return $ this -> info ? : curl_getinfo ( $ this -> curl ) ; } }
8773	public function registerCoreContainerAliases ( ) { Facade :: clearResolvedInstances ( ) ; Facade :: setApplication ( $ this ) ; foreach ( $ this -> registerCoreAliases as $ key => $ alias ) { $ this -> alias ( $ key , $ alias ) ; if ( ! class_exists ( $ key ) ) { class_alias ( $ alias , $ key ) ; } } }
12287	public function insetIf ( bool $ condition , string $ block , array $ vars = null ) : string { return $ condition ? trim ( $ this -> make ( $ block , $ vars ) ) . PHP_EOL : PHP_EOL ; }
4110	protected function arrayToTabList ( array $ array , array $ skipKeys = array ( ) , $ indentationLevel = 1 ) { $ output = '' ; foreach ( $ array as $ key => $ value ) { if ( in_array ( $ key , $ skipKeys , true ) ) { continue ; } $ output .= $ this -> tabsForIndentation ( $ indentationLevel ) ; if ( ! is_array ( $ value ) ) { if ( ! is_int ( $ key ) ) { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> tabsForIndentation ( $ indentationLevel + 1 ) ; } $ output .= $ value . "\n" ; } else { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> arrayToTabList ( $ value , $ skipKeys , $ indentationLevel + 1 ) ; } } return $ output ; }
3682	private function getFilterFactory ( ) : IFilterSettingFactory { if ( null === $ this -> filterFactory ) { return $ this -> filterFactory = System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ; } return $ this -> filterFactory ; }
1688	public function updateStyleSheet ( $ intId ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intId ) ; if ( $ objStyleSheet -> numRows < 1 ) { return ; } if ( Input :: get ( 'act' ) == 'delete' ) { $ this -> import ( Files :: class , 'Files' ) ; $ this -> Files -> delete ( 'assets/css/' . $ objStyleSheet -> name . '.css' ) ; } else { $ this -> writeStyleSheet ( $ objStyleSheet -> row ( ) ) ; $ this -> log ( 'Generated style sheet "' . $ objStyleSheet -> name . '.css"' , __METHOD__ , TL_CRON ) ; } }
1809	public function getContentElementGroup ( $ element ) { foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { if ( $ kk == $ element ) { return $ k ; } } } return null ; }
4383	protected function buildArgString ( $ args ) { $ numArgs = \ count ( $ args ) ; if ( $ numArgs == 1 && \ is_string ( $ args [ 0 ] ) ) { $ args [ 0 ] = \ strip_tags ( $ args [ 0 ] ) ; } foreach ( $ args as $ k => $ v ) { if ( $ k > 0 || ! \ is_string ( $ v ) ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ this -> valDepth = 0 ; } $ glue = ', ' ; $ glueAfterFirst = true ; if ( $ numArgs && \ is_string ( $ args [ 0 ] ) ) { if ( \ preg_match ( '/[=:] ?$/' , $ args [ 0 ] ) ) { $ glueAfterFirst = false ; } elseif ( \ count ( $ args ) == 2 ) { $ glue = ' = ' ; } } if ( ! $ glueAfterFirst ) { return $ args [ 0 ] . \ implode ( $ glue , \ array_slice ( $ args , 1 ) ) ; } else { return \ implode ( $ glue , $ args ) ; } }
12602	public static function delete ( $ path ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
4113	public function getBlockInfo ( Mage_Core_Block_Abstract $ block , $ fullInfo = true ) { $ info = array ( 'name' => $ block -> getNameInLayout ( ) , 'alias' => $ block -> getBlockAlias ( ) , ) ; if ( ! $ fullInfo ) { return $ info ; } $ info [ 'class' ] = get_class ( $ block ) ; if ( $ this -> getRemoteCallEnabled ( ) ) { $ fileAndLine = Mage :: helper ( 'aoe_templatehints/classInfo' ) -> findFileAndLine ( $ info [ 'class' ] ) ; if ( $ fileAndLine ) { $ url = sprintf ( $ this -> getRemoteCallUrlTemplate ( ) , $ fileAndLine [ 'file' ] , $ fileAndLine [ 'line' ] ) ; $ info [ 'class' ] = sprintf ( $ this -> getRemoteCallLinkTemplate ( ) , $ url , $ info [ 'class' ] ) ; } } $ info [ 'module' ] = $ block -> getModuleName ( ) ; if ( $ block instanceof Mage_Cms_Block_Block ) { $ info [ 'cms-blockId' ] = $ block -> getBlockId ( ) ; } if ( $ block instanceof Mage_Cms_Block_Page ) { $ info [ 'cms-pageId' ] = $ block -> getPage ( ) -> getIdentifier ( ) ; } $ templateFile = $ block -> getTemplateFile ( ) ; if ( $ templateFile ) { $ info [ 'template' ] = $ templateFile ; if ( $ this -> getRemoteCallEnabled ( ) ) { $ url = sprintf ( $ this -> getRemoteCallUrlTemplate ( ) , Mage :: getBaseDir ( 'design' ) . DS . $ templateFile , 0 ) ; $ info [ 'template' ] = sprintf ( $ this -> getRemoteCallLinkTemplate ( ) , $ url , $ templateFile ) ; } } $ info [ 'cache-status' ] = self :: TYPE_NOTCACHED ; $ cacheLifeTime = $ block -> getCacheLifetime ( ) ; if ( ! is_null ( $ cacheLifeTime ) ) { $ info [ 'cache-lifetime' ] = ( intval ( $ cacheLifeTime ) == 0 ) ? 'forever' : intval ( $ cacheLifeTime ) . ' sec' ; $ info [ 'cache-key' ] = $ block -> getCacheKey ( ) ; $ info [ 'cache-key-info' ] = is_array ( $ block -> getCacheKeyInfo ( ) ) ? implode ( ', ' , $ block -> getCacheKeyInfo ( ) ) : $ block -> getCacheKeyInfo ( ) ; $ info [ 'tags' ] = implode ( ',' , $ block -> getCacheTags ( ) ) ; $ info [ 'cache-status' ] = self :: TYPE_CACHED ; } elseif ( $ this -> isWithinCachedBlock ( $ block ) ) { $ info [ 'cache-status' ] = self :: TYPE_IMPLICITLYCACHED ; } $ info [ 'methods' ] = $ this -> getClassMethods ( get_class ( $ block ) ) ; return $ info ; }
7042	public function getScaffoldConfig ( string $ resourceName ) : ScaffoldConfigInterface { if ( ! isset ( $ this -> scaffoldConfigs [ $ resourceName ] ) ) { $ className = $ this -> getScaffoldConfigClass ( $ resourceName ) ; $ this -> scaffoldConfigs [ $ resourceName ] = new $ className ( ) ; } return $ this -> scaffoldConfigs [ $ resourceName ] ; }
3338	public static function dateTimeString ( $ datetime ) { if ( $ datetime === null ) { return null ; } if ( is_object ( $ datetime ) && ! ( $ datetime instanceof \ DateTime ) ) { throw new \ Exception ( 'Only \DateTime objects allowed' ) ; } if ( is_string ( $ datetime ) ) { $ datetime = new \ DateTime ( $ datetime ) ; } return $ datetime -> format ( "Y-m-d\TH:i:s.uP" ) ; }
8549	public function setRetrochargeEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RetrochargeEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10494	public function div ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ value == 0 ) { throw new InvalidArgumentException ( 'Division by zero' ) ; } if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value / $ value ) ; }
2370	public static function highlight ( $ strString , $ strPhrase , $ strOpeningTag = '<strong>' , $ strClosingTag = '</strong>' ) { if ( $ strString == '' || $ strPhrase == '' ) { return $ strString ; } return preg_replace ( '/(' . preg_quote ( $ strPhrase , '/' ) . ')/i' , $ strOpeningTag . '\\1' . $ strClosingTag , $ strString ) ; }
6447	public function getUserProfile ( ) { $ linkedin = $ this -> getClient ( ) ; $ response = $ linkedin -> get ( '/people/~:(id,first-name,last-name,picture-url,public-profile-url,email-address)' ) ; if ( isset ( $ response [ 'emailAddress' ] ) ) { return array ( 'userid' => $ response [ 'id' ] , 'name' => $ response [ 'firstName' ] . ' ' . $ response [ 'lastName' ] , 'email' => $ response [ 'emailAddress' ] , 'imageurl' => $ response [ 'pictureUrl' ] ) ; } }
1367	protected function bootBladeDirectives ( ) { $ compiler = $ this -> app -> make ( BladeCompiler :: class ) ; $ compiler -> directive ( 'jsonapi' , Renderer :: class . '::compileWith' ) ; $ compiler -> directive ( 'encode' , Renderer :: class . '::compileEncode' ) ; }
11254	public function drop ( ) : array { $ touched = [ ] ; $ this -> pdo -> beginTransaction ( ) ; foreach ( $ this -> getViews ( ) as $ view ) { $ this -> pdo -> exec ( "drop view if exists {$view} cascade" ) ; $ touched [ ] = [ 'view' , $ view ] ; } foreach ( $ this -> getTables ( ) as $ table ) { $ this -> pdo -> exec ( "drop table if exists {$table} cascade" ) ; $ touched [ ] = [ 'table' , $ table ] ; } $ this -> pdo -> commit ( ) ; return $ touched ; }
5718	public function doPublishAndClose ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return $ this -> publish ( $ data , $ form , $ this -> owner , $ this -> getBackLink ( ) ) ; }
10035	function unsubscribeContactByExternalId ( $ externalId , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } $ encodedExternalId = utf8_encode ( $ externalId ) ; return $ this -> delete ( "contacts/externalid/${encodedExternalId}/unsubscribe" , $ queryParameters ) ; }
4352	public function onConfig ( Event $ event ) { $ file = $ this -> debug -> getCfg ( 'file' ) ; $ this -> setFile ( $ file ) ; }
10584	public static function createDir ( string $ prefix = "tmp" , int $ mode = 0777 , int $ maxAttempts = 10 ) : entity \ DirEntity { $ tmpdir = static :: getDir ( ) ; $ prefix = \ sndsgd \ Fs :: sanitizeName ( $ prefix ) ; $ attempts = 0 ; do { $ attempts ++ ; if ( $ attempts > $ maxAttempts ) { throw new \ RuntimeException ( "failed to create temp directory; " . "reached max number ($maxAttempts) of attempts" ) ; } $ rand = \ sndsgd \ Str :: random ( 10 ) ; $ path = "$tmpdir/$prefix-$rand" ; } while ( @ mkdir ( $ path , $ mode ) === false ) ; $ dir = new entity \ DirEntity ( $ path ) ; static :: registerEntity ( $ dir ) ; return $ dir ; }
2127	protected function fixPaths ( $ content , $ arrFile ) { $ strName = $ arrFile [ 'name' ] ; if ( strpos ( $ strName , $ this -> strWebDir . '/' ) === 0 ) { $ strName = substr ( $ strName , \ strlen ( $ this -> strWebDir ) + 1 ) ; } $ strDirname = \ dirname ( $ strName ) ; $ strGlue = ( $ strDirname != '.' ) ? $ strDirname . '/' : '' ; return preg_replace_callback ( '/url\(("[^"\n]+"|\'[^\'\n]+\'|[^"\'\s()]+)\)/' , function ( $ matches ) use ( $ strDirname , $ strGlue ) { $ strData = $ matches [ 1 ] ; if ( $ strData [ 0 ] == '"' || $ strData [ 0 ] == "'" ) { $ strData = substr ( $ strData , 1 , - 1 ) ; } if ( strncmp ( $ strData , 'data:' , 5 ) === 0 || strncmp ( $ strData , 'http://' , 7 ) === 0 || strncmp ( $ strData , 'https://' , 8 ) === 0 || strncmp ( $ strData , '/' , 1 ) === 0 || strncmp ( $ strData , 'assets/css3pie/' , 15 ) === 0 ) { return $ matches [ 0 ] ; } if ( strncmp ( $ strData , '../' , 3 ) !== 0 ) { $ strData = '../../' . $ strGlue . $ strData ; } else { $ dir = $ strDirname ; while ( strncmp ( $ strData , '../' , 3 ) === 0 ) { $ dir = \ dirname ( $ dir ) ; $ strData = substr ( $ strData , 3 ) ; } $ glue = ( $ dir != '.' ) ? $ dir . '/' : '' ; $ strData = '../../' . $ glue . $ strData ; } $ strQuote = '' ; if ( $ matches [ 1 ] [ 0 ] == "'" || $ matches [ 1 ] [ 0 ] == '"' ) { $ strQuote = $ matches [ 1 ] [ 0 ] ; } if ( preg_match ( '/[(),\s"\']/' , $ strData ) ) { if ( $ matches [ 1 ] [ 0 ] == "'" ) { $ strData = str_replace ( "'" , "\\'" , $ strData ) ; } else { $ strQuote = '"' ; $ strData = str_replace ( '"' , '\"' , $ strData ) ; } } return 'url(' . $ strQuote . $ strData . $ strQuote . ')' ; } , $ content ) ; }
5485	public function hasImage ( SelectorInterface $ selector ) { foreach ( $ this -> images as $ image ) { if ( $ selector -> isMatch ( $ image ) ) { return true ; } } return false ; }
12460	private function getDefaultGroupsId ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ customFieldsGroupIds = $ em -> createQuery ( 'SELECT g.id FROM ' . 'ChillCustomFieldsBundle:CustomFieldsDefaultGroup d ' . 'JOIN d.customFieldsGroup g' ) -> getResult ( Query :: HYDRATE_SCALAR ) ; $ result = array ( ) ; foreach ( $ customFieldsGroupIds as $ row ) { $ result [ ] = $ row [ 'id' ] ; } return $ result ; }
3176	public static function getNavigator ( $ direction , $ scope ) { $ className = __NAMESPACE__ . '\QtiRunnerNavigation' . ucfirst ( $ direction ) . ucfirst ( $ scope ) ; if ( class_exists ( $ className ) ) { $ navigator = new $ className ( ) ; if ( $ navigator instanceof RunnerNavigation ) { return $ navigator ; } else { throw new \ common_exception_InconsistentData ( 'Navigator must be an instance of RunnerNavigation' ) ; } } else { throw new \ common_exception_NotImplemented ( 'The action is invalid!' ) ; } }
10849	protected function fillDocument ( Document $ document , object $ object ) : bool { if ( $ object instanceof SearchableEntity ) { return $ object -> indexEntity ( $ document ) ; } $ mapping = $ this -> getMapping ( \ get_class ( $ object ) ) ; $ accessor = PropertyAccess :: createPropertyAccessor ( ) ; foreach ( $ mapping as $ fieldName => $ propertyPath ) { $ document -> addField ( $ fieldName , $ accessor -> getValue ( $ object , $ propertyPath ) ) ; } return true ; }
200	private function checkTargetRelationExistence ( $ model , $ attribute ) { $ exists = false ; $ relationQuery = $ model -> { 'get' . ucfirst ( $ this -> targetRelation ) } ( ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ relationQuery ) ; } elseif ( $ this -> filter !== null ) { $ relationQuery -> andWhere ( $ this -> filter ) ; } if ( $ this -> forceMasterDb && method_exists ( $ model :: getDb ( ) , 'useMaster' ) ) { $ model :: getDb ( ) -> useMaster ( function ( ) use ( $ relationQuery , & $ exists ) { $ exists = $ relationQuery -> exists ( ) ; } ) ; } else { $ exists = $ relationQuery -> exists ( ) ; } if ( ! $ exists ) { $ this -> addError ( $ model , $ attribute , $ this -> message ) ; } }
453	public function delete ( $ table , $ condition , & $ params ) { $ sql = 'DELETE FROM ' . $ this -> db -> quoteTableName ( $ table ) ; $ where = $ this -> buildWhere ( $ condition , $ params ) ; return $ where === '' ? $ sql : $ sql . ' ' . $ where ; }
294	public function setAttribute ( $ name , $ value ) { if ( $ this -> hasAttribute ( $ name ) ) { if ( ! empty ( $ this -> _relationsDependencies [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _attributes ) || $ this -> _attributes [ $ name ] !== $ value ) ) { $ this -> resetDependentRelations ( $ name ) ; } $ this -> _attributes [ $ name ] = $ value ; } else { throw new InvalidArgumentException ( get_class ( $ this ) . ' has no attribute named "' . $ name . '".' ) ; } }
1318	public function put ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'PUT' , self :: API_HOST , $ path , $ parameters , false ) ; }
12868	public function resetPassword ( Token $ token ) { if ( ! $ this -> validate ( ) || $ token -> user === null ) { return false ; } if ( $ token -> user -> resetPassword ( $ this -> password ) ) { \ Yii :: $ app -> session -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Your password has been changed successfully.' ) ) ; $ token -> delete ( ) ; } else { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'An error occurred and your password has not been changed. Please try again later.' ) ) ; } return true ; }
12323	protected function askQuestions ( InputInterface $ input , OutputInterface $ output ) { foreach ( $ this -> questions as $ question ) { if ( ! $ question -> ask ( $ input , $ output ) ) { return static :: RETURN_ERROR ; } } return static :: RETURN_SUCCESS ; }
5071	protected function traverseHeaderTags ( \ DOMDocument $ domDocument , $ topLevel , $ depth ) { $ xpath = new \ DOMXPath ( $ domDocument ) ; $ xpathQuery = sprintf ( "//*[%s]" , implode ( ' or ' , array_map ( function ( $ v ) { return sprintf ( 'local-name() = "%s"' , $ v ) ; } , $ this -> determineHeaderTags ( $ topLevel , $ depth ) ) ) ) ; $ nodes = [ ] ; foreach ( $ xpath -> query ( $ xpathQuery ) as $ node ) { $ nodes [ ] = $ node ; } return new \ ArrayIterator ( $ nodes ) ; }
3600	public function createHttpResponseFromException ( \ Exception $ exception ) { $ httpResponse = HttpResponse :: create ( ) ; $ json = [ ] ; $ json [ 'jsonrpc' ] = '2.0' ; $ json [ 'error' ] = [ ] ; if ( $ exception instanceof Exceptions \ ErrorException ) { $ json [ 'error' ] [ 'code' ] = $ exception -> getCode ( ) ; $ json [ 'error' ] [ 'message' ] = $ exception -> getMessage ( ) ; if ( $ exception -> getData ( ) ) { $ json [ 'error' ] [ 'data' ] = $ exception -> getData ( ) ; } $ json [ 'id' ] = $ exception -> getId ( ) ; } else { $ json [ 'error' ] [ 'code' ] = - 32603 ; $ json [ 'error' ] [ 'message' ] = 'Internal error' ; $ json [ 'id' ] = null ; } $ httpResponse -> headers -> set ( 'Content-Type' , 'application/json' ) ; $ httpResponse -> setContent ( \ json_encode ( $ json ) ) ; $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; $ this -> dispatch ( Event \ HttpResponseEvent :: EVENT , new Event \ HttpResponseEvent ( $ httpResponse ) ) ; return $ httpResponse ; }
7846	public function cancel ( array $ identifiers = [ ] ) : ? array { $ this -> checkConfig ( ) ; if ( empty ( $ identifiers ) ) { return null ; } $ messages = [ ] ; foreach ( $ identifiers as $ id ) { $ messages [ ] = [ 'id' => ( int ) $ id ] ; } $ body = Body :: json ( $ messages ) ; $ response = Request :: post ( $ this -> baseUrl . 'message/cancel' , [ ] , $ body ) ; if ( $ response -> code == 200 ) { return [ 'code' => $ response -> code , 'message' => 'OK' , 'data' => $ response -> body , ] ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } return [ 'code' => $ response -> code , 'message' => $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } }
2192	public function isRegisteredAlias ( Model $ objModel , $ strAlias , $ varValue ) { $ strTable = $ objModel -> getTable ( ) ; return isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ; }
2033	public static function findWithDetails ( $ intId ) { $ objPage = static :: findByPk ( $ intId ) ; if ( $ objPage === null ) { return null ; } return $ objPage -> loadDetails ( ) ; }
9905	private function updateSingleCellReference ( $ pCellReference = 'A1' , $ pBefore = 'A1' , $ pNumCols = 0 , $ pNumRows = 0 ) { if ( Coordinate :: coordinateIsRange ( $ pCellReference ) ) { throw new Exception ( 'Only single cell references may be passed to this method.' ) ; } list ( $ beforeColumn , $ beforeRow ) = Coordinate :: coordinateFromString ( $ pBefore ) ; list ( $ newColumn , $ newRow ) = Coordinate :: coordinateFromString ( $ pCellReference ) ; $ updateColumn = ( ( $ newColumn [ 0 ] != '$' ) && ( $ beforeColumn [ 0 ] != '$' ) && ( Coordinate :: columnIndexFromString ( $ newColumn ) >= Coordinate :: columnIndexFromString ( $ beforeColumn ) ) ) ; $ updateRow = ( ( $ newRow [ 0 ] != '$' ) && ( $ beforeRow [ 0 ] != '$' ) && $ newRow >= $ beforeRow ) ; if ( $ updateColumn ) { $ newColumn = Coordinate :: stringFromColumnIndex ( Coordinate :: columnIndexFromString ( $ newColumn ) + $ pNumCols ) ; } if ( $ updateRow ) { $ newRow = $ newRow + $ pNumRows ; } return $ newColumn . $ newRow ; }
1149	protected function setDefaults ( $ options ) { $ this -> selector = empty ( $ options [ 'selector' ] ) ? 'form' : $ options [ 'selector' ] ; $ this -> view = empty ( $ options [ 'view' ] ) ? 'jsvalidation::bootstrap' : $ options [ 'view' ] ; $ this -> remote = isset ( $ options [ 'remote' ] ) ? $ options [ 'remote' ] : true ; }
8207	protected function putJob ( $ tube , $ body , $ priority , $ delay , $ ttr ) { $ id = $ this -> getPheanstalk ( ) -> putInTube ( $ tube , $ body , $ priority , $ delay , $ ttr ) ; return $ id ; }
362	protected function getClientOptions ( ) { $ filterUrl = isset ( $ this -> filterUrl ) ? $ this -> filterUrl : Yii :: $ app -> request -> url ; $ id = $ this -> filterRowOptions [ 'id' ] ; $ filterSelector = "#$id input, #$id select" ; if ( isset ( $ this -> filterSelector ) ) { $ filterSelector .= ', ' . $ this -> filterSelector ; } return [ 'filterUrl' => Url :: to ( $ filterUrl ) , 'filterSelector' => $ filterSelector , ] ; }
481	public function addPrimaryKey ( $ name , $ table , $ columns ) { $ time = $ this -> beginCommand ( "add primary key $name on $table (" . ( is_array ( $ columns ) ? implode ( ',' , $ columns ) : $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> addPrimaryKey ( $ name , $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
419	private function validateCsrfTokenInternal ( $ clientSuppliedToken , $ trueToken ) { if ( ! is_string ( $ clientSuppliedToken ) ) { return false ; } $ security = Yii :: $ app -> security ; return $ security -> compareString ( $ security -> unmaskToken ( $ clientSuppliedToken ) , $ security -> unmaskToken ( $ trueToken ) ) ; }
2871	public function getModules ( ) { $ items = array ( ) ; $ items [ ] = array ( 'module' => 'Magento' , 'codePool' => 'core' , 'active' => true , 'version' => $ this -> getMagentoVersion ( ) ) ; $ modulesConfig = Mage :: getConfig ( ) -> getModuleConfig ( ) ; foreach ( $ modulesConfig as $ node ) { foreach ( $ node as $ module => $ data ) { $ items [ ] = array ( 'module' => $ module , 'codePool' => ( string ) $ data -> codePool , 'active' => $ data -> active == 'true' , 'version' => ( string ) $ data -> version ) ; } } return $ items ; }
4789	function update ( array $ data ) { if ( $ this -> notORM -> freeze ) { return false ; } if ( ! $ data ) { return 0 ; } $ values = array ( ) ; $ parameters = array ( ) ; $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ data as $ key => $ val ) { $ values [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; if ( $ val instanceof NotORM_Literal && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } if ( $ this -> parameters ) { $ parameters = array_merge ( $ parameters , $ this -> parameters ) ; } $ return = $ this -> query ( "UPDATE" . $ this -> topString ( $ this -> limit ) . " $this->table SET " . implode ( ", " , $ values ) . $ this -> whereString ( ) , $ parameters ) ; if ( ! $ return ) { return false ; } return $ return -> rowCount ( ) ; }
1839	protected static function find ( array $ arrOptions ) { if ( static :: $ strTable == '' ) { return null ; } if ( $ arrOptions [ 'return' ] == 'Model' ) { $ arrColumn = ( array ) $ arrOptions [ 'column' ] ; if ( \ count ( $ arrColumn ) == 1 ) { $ arrColumn [ 0 ] = preg_replace ( '/^' . preg_quote ( static :: getTable ( ) , '/' ) . '\./' , '' , $ arrColumn [ 0 ] ) ; if ( $ arrColumn [ 0 ] == static :: $ strPk || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) { $ varKey = \ is_array ( $ arrOptions [ 'value' ] ) ? $ arrOptions [ 'value' ] [ 0 ] : $ arrOptions [ 'value' ] ; $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varKey , $ arrColumn [ 0 ] ) ; if ( $ objModel !== null ) { return $ objModel ; } } } } $ arrOptions [ 'table' ] = static :: $ strTable ; $ strQuery = static :: buildFindQuery ( $ arrOptions ) ; $ objStatement = Database :: getInstance ( ) -> prepare ( $ strQuery ) ; if ( ! isset ( $ arrOptions [ 'limit' ] ) ) { $ arrOptions [ 'limit' ] = 0 ; } if ( ! isset ( $ arrOptions [ 'offset' ] ) ) { $ arrOptions [ 'offset' ] = 0 ; } if ( $ arrOptions [ 'limit' ] > 0 || $ arrOptions [ 'offset' ] > 0 ) { $ objStatement -> limit ( $ arrOptions [ 'limit' ] , $ arrOptions [ 'offset' ] ) ; } $ objStatement = static :: preFind ( $ objStatement ) ; $ objResult = $ objStatement -> execute ( $ arrOptions [ 'value' ] ) ; if ( $ objResult -> numRows < 1 ) { return $ arrOptions [ 'return' ] == 'Array' ? array ( ) : null ; } $ objResult = static :: postFind ( $ objResult ) ; if ( $ arrOptions [ 'return' ] == 'Model' ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ objResult -> { static :: $ strPk } ) ; if ( $ objModel !== null ) { return $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; } return static :: createModelFromDbResult ( $ objResult ) ; } elseif ( $ arrOptions [ 'return' ] == 'Array' ) { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) -> getModels ( ) ; } else { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) ; } }
6940	private function pop ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( false !== $ index = $ this -> find ( $ list , $ oid , $ unit ) ) { unset ( $ list [ $ oid ] [ $ index ] ) ; if ( empty ( $ list [ $ oid ] ) ) { unset ( $ list [ $ oid ] ) ; } } }
5379	protected function wrap ( $ text ) { $ text = str_replace ( "\r\r\n" , "\r\n" , str_replace ( "\n" , "\r\n" , $ text ) ) ; $ text = str_replace ( "\r\n\n" , "\r\n" , str_replace ( "\r" , "\r\n" , $ text ) ) ; if ( strncmp ( $ text , "\r\n" , strlen ( "\r\n" ) ) == 0 ) { $ text = substr ( $ text , strlen ( "\r\n" ) ) ; } if ( $ this -> wrapIsEnabled ( ) ) { return wordwrap ( $ text , ( integer ) $ this -> getAttribute ( 'cols' ) , "\r\n" ) ; } return $ text ; }
8942	public function queryChangeset ( $ param ) { $ base = 'changesets/' . $ param ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> osm ; }
10216	public function addFromSource ( array $ pSource = null ) { if ( $ pSource == null ) { return ; } foreach ( $ pSource as $ item ) { $ this -> add ( $ item ) ; } }
8078	protected function buildUri ( $ endpoint , $ options = [ ] ) { if ( $ this -> token !== '' ) { $ options [ 'auth' ] = $ this -> token ; } return $ this -> base . '/' . ltrim ( $ endpoint , '/' ) . '.json?' . http_build_query ( $ options , '' , '&' ) ; }
243	protected function renderAttribute ( $ attribute , $ index ) { if ( is_string ( $ this -> template ) ) { $ captionOptions = Html :: renderTagAttributes ( ArrayHelper :: getValue ( $ attribute , 'captionOptions' , [ ] ) ) ; $ contentOptions = Html :: renderTagAttributes ( ArrayHelper :: getValue ( $ attribute , 'contentOptions' , [ ] ) ) ; return strtr ( $ this -> template , [ '{label}' => $ attribute [ 'label' ] , '{value}' => $ this -> formatter -> format ( $ attribute [ 'value' ] , $ attribute [ 'format' ] ) , '{captionOptions}' => $ captionOptions , '{contentOptions}' => $ contentOptions , ] ) ; } return call_user_func ( $ this -> template , $ attribute , $ index , $ this ) ; }
3753	public function save ( ModelInterface $ objItem , $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } if ( $ objItem instanceof Model ) { $ backupLanguage = $ this -> setLanguage ( $ this -> getCurrentLanguage ( ) ) ; $ objItem -> getItem ( ) -> save ( $ timestamp ) ; $ this -> setLanguage ( $ backupLanguage ) ; return $ objItem ; } throw new \ RuntimeException ( 'ERROR: incompatible object passed to GeneralDataMetaModel::save()' ) ; }
12080	public function updateChild ( $ idParent , FilterRequest $ filters , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> updateChild ( $ idParent , $ relation , $ idChild , $ filters -> all ( ) ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
8474	public function notice ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'notice' , $ scope , $ message , $ context , $ config ) ; }
805	private function hasVoidReturn ( Tokens $ tokens , $ startIndex , $ endIndex ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; for ( $ i = $ startIndex ; $ i < $ endIndex ; ++ $ i ) { if ( ( $ tokens [ $ i ] -> isGivenKind ( T_CLASS ) && $ tokensAnalyzer -> isAnonymousClass ( $ i ) ) || ( $ tokens [ $ i ] -> isGivenKind ( T_FUNCTION ) && $ tokensAnalyzer -> isLambda ( $ i ) ) ) { $ i = $ tokens -> getNextTokenOfKind ( $ i , [ '{' ] ) ; $ i = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ i ) ; continue ; } if ( $ tokens [ $ i ] -> isGivenKind ( [ T_YIELD , T_YIELD_FROM ] ) ) { return false ; } if ( ! $ tokens [ $ i ] -> isGivenKind ( T_RETURN ) ) { continue ; } $ i = $ tokens -> getNextMeaningfulToken ( $ i ) ; if ( ! $ tokens [ $ i ] -> equals ( ';' ) ) { return false ; } } return true ; }
1673	public function isUnprotected ( ) { $ path = $ this -> strFolder ; do { if ( file_exists ( $ this -> strRootDir . '/' . $ path . '/.public' ) ) { return true ; } $ path = \ dirname ( $ path ) ; } while ( $ path != '.' ) ; return false ; }
4828	public function create_bill ( $ attrs ) { if ( ! isset ( $ attrs [ 'amount' ] ) ) { throw new GoCardless_ArgumentsException ( 'Amount required' ) ; } $ params = array ( 'bill' => array ( 'amount' => $ attrs [ 'amount' ] , 'pre_authorization_id' => $ this -> id ) ) ; if ( isset ( $ attrs [ 'name' ] ) ) { $ params [ 'bill' ] [ 'name' ] = $ attrs [ 'name' ] ; } if ( isset ( $ attrs [ 'description' ] ) ) { $ params [ 'bill' ] [ 'description' ] = $ attrs [ 'description' ] ; } if ( isset ( $ attrs [ 'charge_customer_at' ] ) ) { $ params [ 'bill' ] [ 'charge_customer_at' ] = $ attrs [ 'charge_customer_at' ] ; } $ endpoint = GoCardless_Bill :: $ endpoint ; return new GoCardless_Bill ( $ this -> client , $ this -> client -> request ( 'post' , $ endpoint , $ params ) ) ; }
11045	function read_content ( ) { if ( $ this -> external_source_read ) { $ fct = $ this -> source_read_name ; return $ fct ( $ this -> container ) ; } else { $ content = FALSE ; if ( $ handle = @ fopen ( $ this -> container , 'rb' ) ) { $ size = @ filesize ( $ this -> container ) ; $ content = @ fread ( $ handle , $ size ) ; fclose ( $ handle ) ; } return $ content ; } }
5662	private function mergeAttribute ( $ attributes , $ raw ) { $ parts = explode ( '=' , $ raw ) ; list ( $ name , $ value ) = count ( $ parts ) === 1 ? array ( $ parts [ 0 ] , $ parts [ 0 ] ) : $ parts ; $ attributes [ trim ( $ name ) ] = html_entity_decode ( $ this -> dequote ( trim ( $ value ) ) , ENT_QUOTES ) ; return $ attributes ; }
12026	private function generateExecuteDocBlock ( $ methodDescription ) { $ responseClass = $ this -> operationDefinition -> getResponseClass ( ) ; $ docBlock = new DocBlockGenerator ( $ methodDescription , null ) ; if ( $ responseClass ) { $ tags [ ] = new GenericTag ( 'return' , '\\' . $ responseClass ) ; } else { $ tags [ ] = new GenericTag ( 'return' , 'mixed' ) ; } $ docBlock -> setTags ( $ tags ) ; return $ docBlock ; }
9714	private function writeStyle ( ) { $ record = 0x0293 ; $ length = 0x0004 ; $ ixfe = 0x8000 ; $ BuiltIn = 0x00 ; $ iLevel = 0xff ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vCC' , $ ixfe , $ BuiltIn , $ iLevel ) ; $ this -> append ( $ header . $ data ) ; }
10865	protected function setInstProperty ( $ inst , $ propertyName , $ mappingDefinition , $ propertyValue = null ) { if ( $ mappingDefinition === false ) { return false ; } if ( func_num_args ( ) <= 3 ) { $ propertyValue = $ this -> $ propertyName ; } if ( $ mappingDefinition === true || is_string ( $ mappingDefinition ) ) { $ instPropertyName = $ mappingDefinition === true ? $ propertyName : $ mappingDefinition ; $ setInstPropertyMethod = 'setInstProperty' . ucfirst ( $ instPropertyName ) ; if ( method_exists ( $ this , $ setInstPropertyMethod ) ) { $ this -> $ setInstPropertyMethod ( $ propertyValue , $ inst ) ; return ; } else { $ instSetterMethod = 'set' . ucfirst ( $ instPropertyName ) ; if ( method_exists ( $ inst , $ instSetterMethod ) ) { $ inst -> $ instSetterMethod ( $ propertyValue ) ; return ; } else { $ inst -> $ instPropertyName = $ propertyValue ; return ; } } } elseif ( is_array ( $ mappingDefinition ) ) { if ( reset ( $ mappingDefinition ) === null ) { $ mappingDefinition [ 0 ] = $ inst ; call_user_func_array ( $ mappingDefinition , [ $ propertyValue ] ) ; return ; } elseif ( reset ( $ mappingDefinition ) === $ this ) { call_user_func_array ( $ mappingDefinition , [ $ propertyValue , $ inst ] ) ; return ; } } throw new \ yii \ base \ ErrorException ( 'Could not set property ' . $ propertyName . ' in wrapped object' ) ; }
10089	function addAttachmentFromBase64Data ( $ filename , $ mimetype , $ contents ) { $ attachment = new Attachment ( $ filename , $ mimetype , $ contents ) ; $ this -> attachments [ ] = $ attachment ; }
2417	protected function addDataRow ( \ DOMDocument $ xml , \ DOMElement $ table , array $ arrRow , array $ arrOrder = array ( ) ) { $ t = $ table -> getAttribute ( 'name' ) ; $ row = $ xml -> createElement ( 'row' ) ; $ row = $ table -> appendChild ( $ row ) ; foreach ( $ arrRow as $ k => $ v ) { $ field = $ xml -> createElement ( 'field' ) ; $ field -> setAttribute ( 'name' , $ k ) ; $ field = $ row -> appendChild ( $ field ) ; if ( $ v === null ) { $ v = 'NULL' ; } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ t ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'fileTree' && ! $ GLOBALS [ 'TL_DCA' ] [ $ t ] [ 'fields' ] [ $ k ] [ 'eval' ] [ 'multiple' ] ) { $ objFile = FilesModel :: findByUuid ( $ v ) ; if ( $ objFile !== null ) { $ v = $ this -> standardizeUploadPath ( $ objFile -> path ) ; } else { $ v = 'NULL' ; } } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ t ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'fileTree' || \ in_array ( $ k , $ arrOrder ) ) { $ arrFiles = StringUtil :: deserialize ( $ v ) ; if ( ! empty ( $ arrFiles ) && \ is_array ( $ arrFiles ) ) { $ objFiles = FilesModel :: findMultipleByUuids ( $ arrFiles ) ; if ( $ objFiles !== null ) { $ arrTmp = array ( ) ; while ( $ objFiles -> next ( ) ) { $ arrTmp [ ] = $ this -> standardizeUploadPath ( $ objFiles -> path ) ; } $ v = serialize ( $ arrTmp ) ; } else { $ v = 'NULL' ; } } } elseif ( $ t == 'tl_style' && ( $ k == 'bgimage' || $ k == 'liststyleimage' ) ) { $ v = $ this -> standardizeUploadPath ( $ v ) ; } $ value = $ xml -> createTextNode ( $ v ) ; $ field -> appendChild ( $ value ) ; } }
7078	static public function isSaleSupportsDocumentType ( SaleInterface $ sale , $ type ) { if ( ! DocumentTypes :: isValidType ( $ type ) ) { return false ; } if ( empty ( $ classes = DocumentTypes :: getClasses ( $ type ) ) ) { return false ; } foreach ( $ classes as $ class ) { if ( is_subclass_of ( $ sale , $ class ) ) { return true ; } } return false ; }
9008	private function prepareColumn ( Row $ row ) : string { $ nullable = $ row -> Null === 'YES' ; if ( $ row -> Default === null && ! $ nullable ) { $ default = ' NOT null' ; } elseif ( $ row -> Default === null && $ nullable ) { $ default = ' DEFAULT null' ; } else { $ default = ( $ nullable ? '' : ' NOT null' ) . " DEFAULT '{$row->Default}'" ; } if ( ! empty ( $ row -> Collation ) ) { $ collate = ' COLLATE ' . $ row -> Collation ; } else { $ collate = '' ; } if ( $ row -> Extra === 'auto_increment' ) { $ autoIncrement = ' AUTO_INCREMENT' ; } else { $ autoIncrement = '' ; } return "`{$row->Field}` " . $ row -> Type . $ collate . $ default . $ autoIncrement ; }
3690	public function handleCreateVariantAction ( ActionEvent $ event ) { if ( false === $ this -> scopeMatcher -> currentScopeIsBackend ( ) || 'createvariant' !== $ event -> getAction ( ) -> getName ( ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ view = $ environment -> getView ( ) ; $ dataProvider = $ environment -> getDataProvider ( ) ; $ inputProvider = $ environment -> getInputProvider ( ) ; $ modelId = $ inputProvider -> hasParameter ( 'id' ) ? ModelId :: fromSerialized ( $ inputProvider -> getParameter ( 'id' ) ) : null ; $ model = $ dataProvider -> createVariant ( $ dataProvider -> getEmptyConfig ( ) -> setId ( $ modelId -> getId ( ) ) ) ; if ( $ model == null ) { throw new \ RuntimeException ( sprintf ( 'Could not find model with id %s for creating a variant.' , $ modelId ) ) ; } $ metaModel = $ this -> factory -> getMetaModel ( $ model -> getProviderName ( ) ) ; if ( ! $ metaModel || ! $ metaModel -> hasVariants ( ) ) { return ; } $ preFunction = function ( $ environment , $ model ) { $ copyEvent = new PreCreateModelEvent ( $ environment , $ model ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ copyEvent :: NAME , $ copyEvent ) ; } ; $ postFunction = function ( $ environment , $ model ) { $ copyEvent = new PostCreateModelEvent ( $ environment , $ model ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ copyEvent :: NAME , $ copyEvent ) ; } ; if ( ! $ view instanceof BackendViewInterface ) { throw new \ InvalidArgumentException ( 'Invalid view registered in environment.' ) ; } $ editMask = new EditMask ( $ view , $ model , null , $ preFunction , $ postFunction , $ this -> breadcrumb ( $ environment ) ) ; $ event -> setResponse ( $ editMask -> execute ( ) ) ; }
8504	public function confirmTransportRequest ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ConfirmTransportRequest' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ConfirmTransportRequestResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12189	public function getPrimaryRelation ( $ baseObject , $ baseRole , $ relationOptions = [ ] ) { $ companionRole = $ this -> companionRole ( $ baseRole ) ; $ companionType = $ this -> companionRoleType ( $ baseRole ) ; $ companionModel = $ companionType -> primaryModel ; if ( ! isset ( $ relationOptions [ 'order' ] ) ) { $ relationOptions [ 'order' ] = [ ] ; } if ( $ companionRole === 'child' ) { array_unshift ( $ relationOptions [ 'order' ] , [ 'primary_child' , SORT_DESC ] ) ; $ relation = $ baseObject -> queryParentRelations ( $ companionModel , $ relationOptions ) -> one ( ) ; } else { array_unshift ( $ relationOptions [ 'order' ] , [ 'primary_parent' , SORT_DESC ] ) ; $ relation = $ baseObject -> queryParentRelations ( $ companionModel , $ relationOptions ) -> one ( ) ; } if ( empty ( $ relation ) ) { return false ; } else { return $ relation ; } }
8589	public function setReportScheduleList ( $ reportSchedule ) { if ( ! $ this -> _isNumericArray ( $ reportSchedule ) ) { $ reportSchedule = array ( $ reportSchedule ) ; } $ this -> fields [ 'ReportSchedule' ] [ 'FieldValue' ] = $ reportSchedule ; return $ this ; }
186	protected function renderStrike ( $ element ) { return Console :: ansiFormat ( $ this -> parseInline ( $ this -> renderAbsy ( $ element [ 1 ] ) ) , [ Console :: CROSSED_OUT ] ) ; }
6188	public function render ( $ data , $ type = null ) { if ( empty ( $ type ) or $ type === 'html' ) { return Response :: Create ( $ this -> renderInclude ( $ data ) ) ; } elseif ( $ type === 'jsonp' ) { return $ this -> renderJSONP ( $ data ) ; } else { return $ this -> renderJSON ( $ data ) ; } }
8624	public function setShippingServiceList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShippingServiceList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6828	private function getSaleDeliveryAddress ( ShipmentInterface $ shipment ) { if ( null === $ sale = $ shipment -> getSale ( ) ) { throw new LogicException ( "Shipment's sale must be set at this point." ) ; } return $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; }
12730	public function renderStraight ( Zend_Navigation_Container $ container = null ) { if ( $ container === null ) { $ container = $ this -> getContainer ( ) ; } if ( ! $ active = $ this -> findActive ( $ container ) ) { return '' ; } $ active = $ active [ 'page' ] ; if ( $ this -> getLinkLast ( ) ) { $ html = '<li>' . $ this -> htmlify ( $ active ) . '</li>' ; } else { $ html = $ active -> getLabel ( ) ; if ( $ this -> getUseTranslator ( ) && $ t = $ this -> getTranslator ( ) ) { $ html = $ t -> translate ( $ html ) ; } $ html = '<li class="active">' . $ this -> view -> escape ( $ html ) . '</li>' ; } while ( ( $ parent = $ active -> getParent ( ) ) != null ) { if ( $ parent instanceof Zend_Navigation_Page ) { $ html = '<li>' . $ this -> htmlify ( $ parent ) . ' <span class="divider">' . $ this -> getSeparator ( ) . '</span></li>' . PHP_EOL . $ html ; } if ( $ parent === $ container ) { break ; } $ active = $ parent ; } return strlen ( $ html ) ? $ this -> getIndent ( ) . '<ul class="breadcrumb">' . $ html . '</ul>' : '' ; }
9316	public static function filter ( $ region ) { $ r = array ( 'x' => intval ( $ region [ 'x' ] ) , 'y' => intval ( $ region [ 'y' ] ) , 'width' => intval ( $ region [ 'w' ] ) , 'height' => intval ( $ region [ 'h' ] ) ) ; return array ( new ezcImageFilter ( 'crop' , $ r ) ) ; }
12276	private function buildTemplatesMap ( ) { if ( ! empty ( $ this -> templatesMap ) ) { return $ this -> templatesMap ; } $ this -> templatesMap = [ ] ; foreach ( $ this -> templatesPaths as $ templatesPath => $ templatesNamespace ) { if ( ! is_readable ( $ templatesPath ) ) { throw new \ RuntimeException ( "Templates path '$templatesPath' does not exist or is not readable." ) ; } foreach ( glob ( $ templatesPath . '/*.phtml' ) as $ templatePath ) { $ template = pathinfo ( $ templatePath , PATHINFO_FILENAME ) ; if ( $ templatesNamespace !== null ) { $ template .= '@' . $ templatesNamespace ; } if ( array_key_exists ( $ template , $ this -> templatesMap ) ) { throw new \ OverflowException ( "Can't import template '$template' from '$templatePath' as a template with the same name already exists at '{$this->templatesMap[$template]}'. You may want to use namespaces." ) ; } $ this -> templatesMap [ $ template ] = $ templatePath ; } } return $ this -> templatesMap ; }
12453	static function run_generate_sample_package_xml ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { pake_copy ( self :: getResourceDir ( ) . '/package_master.xml' , 'package.xml' ) ; $ tokens = array ( '$summary' => '[Summary]' , '$description' => '[Description]' , '$vendor' => '' , '$maintainers' => '' , '$documents' => '' , '$changelog' => '' , '$simple-files' => '' , '$state' => '[State]' , '$requires' => '' ) ; pake_replace_tokens ( 'package.xml' , '.' , '{' , '}' , $ tokens ) ; pake_echo ( "File package.xml generated. Please replace all tokens in square brackets in it (but do not replace values in curly brackets) then commit it to sources in the top dir of the extension" ) ; }
3085	public function getAssessmentItemRefsByPlaceholder ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , AssessmentItemRef $ placeholder ) { $ urlinfo = parse_url ( $ placeholder -> getHref ( ) ) ; $ adaptiveSectionId = ltrim ( $ urlinfo [ 'path' ] , '/' ) ; $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-section-${adaptiveSectionId}" ; $ component = $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , $ filename ) ; return $ component -> getComponentsByClassName ( 'assessmentItemRef' ) -> getArrayCopy ( ) ; }
11199	public function processDelete ( $ name , $ container = false ) { if ( ! $ container ) { $ container = $ this ; } if ( isset ( $ container -> singleton -> $ name ) ) { unset ( $ container -> singleton -> $ name ) ; return true ; } if ( isset ( $ container -> signature -> $ name ) ) { unset ( $ container -> signature -> $ name ) ; return true ; } elseif ( $ container -> parent ) { return $ container -> processDelete ( $ name , $ container -> parent ) ; } return false ; }
11005	public function setSandbox ( string $ sandbox ) : void { if ( ! in_array ( $ sandbox , self :: SANDBOX_VALUES ) ) { throw new MiddlewareException ( $ this , sprintf ( "%s is not a correct value for the CSP sandbox, correct values are: %s (see %s)" , $ sandbox , implode ( ', ' , self :: SANDBOX_VALUES ) , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/sandbox' ) ) ; } $ this -> tags [ 'sandbox' ] = $ sandbox ; }
11746	public function device ( ) { if ( is_null ( $ this -> device ) ) { $ this -> device = new Device ( $ this -> accessToken ) ; } return $ this -> device ; }
1509	public function getResourceUrl ( string $ type , $ id , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id ] , $ params ) ; }
7385	public function uploadAction ( ) { if ( $ this -> request -> hasFiles ( ) == true ) { $ this -> initializeScaffolding ( ) ; $ form = $ this -> scaffolding -> getForm ( ) ; $ name = key ( $ _FILES ) ; $ uploadElement = $ form -> get ( $ name ) ; $ model = $ uploadElement -> getModel ( ) ; $ path = $ uploadElement -> getPath ( ) ; $ maxFileSize = $ uploadElement -> getMaxFileSize ( ) ; $ minFileSize = $ uploadElement -> getMinFileSize ( ) ; foreach ( $ this -> request -> getUploadedFiles ( ) as $ file ) { $ fileName = $ file -> getName ( ) ; $ fileSize = $ file -> getSize ( ) ; $ fileType = $ file -> getRealType ( ) ; $ fileExtensions = pathinfo ( $ fileName , PATHINFO_EXTENSION ) ; $ allowed = $ uploadElement -> getAllowedExtensions ( ) ; if ( ! empty ( $ allowed ) ) { if ( ! in_array ( $ fileExtensions , $ allowed ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ forbidden = $ uploadElement -> getForbiddenExtensions ( ) ; if ( ! empty ( $ forbidden ) ) { if ( in_array ( $ fileExtensions , $ forbidden ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ allowedMime = $ uploadElement -> getAllowedMimeTypes ( ) ; if ( ! empty ( $ allowedMime ) ) { if ( ! in_array ( $ fileType , $ allowedMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } $ forbiddenMime = $ uploadElement -> getForbiddenMimeTypes ( ) ; if ( ! empty ( $ forbiddenMime ) ) { if ( in_array ( $ fileType , $ forbiddenMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } if ( ! empty ( $ maxFileSize ) ) { if ( $ fileSize > $ this -> convertFileSizeToBytes ( $ maxFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( ! empty ( $ minFileSize ) ) { if ( $ fileSize < $ this -> convertFileSizeToBytes ( $ minFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( empty ( $ path ) ) { $ path = 'files/' ; } $ model -> name = $ fileName ; $ model -> mime_type = $ fileType ; $ model -> path = $ path ; $ model -> save ( ) ; $ file -> moveTo ( $ path . $ model -> _id ) ; return $ this -> response -> setJsonContent ( ( string ) $ model -> _id ) ; } } $ this -> view -> setRenderLevel ( View :: LEVEL_NO_RENDER ) ; }
7795	protected function statementBody ( $ text ) { switch ( substr ( $ this -> getLine ( '20' , $ text ) , 0 , 4 ) ) { case '940A' : $ this -> format = self :: FORMAT_CLASSIC ; break ; case '940S' : $ this -> format = self :: FORMAT_STRUCTURED ; break ; default : throw new \ RuntimeException ( 'Unknown file format' ) ; } return parent :: statementBody ( $ text ) ; }
6536	protected function retrieve ( ) { if ( false === $ this -> retrieved ) { $ this -> updatedDatas = $ this -> getArray ( ) ; $ this -> retrieved = true ; } }
8876	public function send ( ) { if ( ! preg_match ( '/^.+@.+$/' , $ this -> sender ) ) { return false ; } if ( ! preg_match ( '/^.+@.+$/' , $ this -> recipient ) ) { return false ; } if ( ! $ this -> subject || strlen ( $ this -> subject ) > 255 ) { return false ; } $ required_headers = [ ] ; if ( Mail :: $ config [ 'testing_mode' ] ) { if ( empty ( Mail :: $ config [ 'testing_email' ] ) ) { return true ; } $ required_headers [ 'X-Testing-Original-To' ] = $ this -> recipient ; foreach ( $ this -> headers as $ name => $ value ) { switch ( strtolower ( $ name ) ) { case 'cc' : $ this -> headers [ 'X-Testing-Original-Cc' ] = $ value ; $ required_headers [ $ name ] = '' ; break ; case 'bcc' : $ this -> headers [ 'X-Testing-Original-Bcc' ] = $ value ; $ required_headers [ $ name ] = '' ; break ; } } $ to = Mail :: $ config [ 'testing_email' ] ; $ subject = '*Test* ' . $ this -> subject ; } else { $ to = $ this -> recipient ; $ subject = $ this -> subject ; } $ required_headers [ 'From' ] = $ this -> sender ; $ required_headers [ 'Return-Path' ] = $ this -> sender ; $ required_headers [ 'Reply-To' ] = $ this -> sender ; $ required_headers [ 'X-Sender' ] = $ this -> sender ; $ headers = $ this -> buildHeaders ( $ required_headers ) ; $ message = $ this -> buildTextPart ( ) . $ this -> buildAttachmentPart ( ) . "--MIME_BOUNDRY--\n" ; return mail ( $ to , $ subject , $ message , $ headers , Mail :: $ config [ 'additional_parameters' ] ) ; }
4577	public function getXml ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_XML ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_XML_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_XML_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = new Xml ; $ model -> setId ( $ object -> id ) -> setXml ( new SimpleXMLElement ( $ object -> bpmn20Xml ) ) ; return $ model ; }
2731	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ backends = $ this -> api -> getBackends ( $ activeVersion ) ; if ( ! $ backends ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Backend details.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'backends' => $ backends ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2539	protected function executeMethodOnSoapClientForMsg ( $ msgName , $ method ) { $ result = null ; $ soapClient = $ this -> getSoapClient ( $ msgName ) ; if ( $ soapClient instanceof \ SoapClient ) { $ result = $ soapClient -> $ method ( ) ; } return $ result ; }
10734	public function setLower ( $ lower ) : self { if ( ! is_numeric ( $ lower ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, lower, to be a number" ) ; } $ this -> lower = + $ lower ; return $ this ; }
12580	public function previewVideoByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_VIDEO , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
11477	public function boot ( Plugin $ theme ) { $ this -> plugin = $ theme ; parent :: boot ( $ theme ) ; $ this -> initTemplates ( ) ; $ this -> initHomepageTemplate ( ) ; return $ this ; }
528	public function actionInfo ( ) { $ items = [ 'framework' , 'app-basic' , 'app-advanced' , ] ; $ extensionPath = "{$this->basePath}/extensions" ; foreach ( scandir ( $ extensionPath ) as $ extension ) { if ( ctype_alpha ( $ extension ) && is_dir ( $ extensionPath . '/' . $ extension ) ) { $ items [ ] = $ extension ; } } if ( $ this -> update ) { foreach ( $ items as $ item ) { $ this -> stdout ( "fetching tags for $item..." ) ; if ( $ item === 'framework' ) { $ this -> gitFetchTags ( ( string ) $ this -> basePath ) ; } elseif ( strncmp ( 'app-' , $ item , 4 ) === 0 ) { $ this -> gitFetchTags ( "{$this->basePath}/apps/" . substr ( $ item , 4 ) ) ; } else { $ this -> gitFetchTags ( "{$this->basePath}/extensions/$item" ) ; } $ this -> stdout ( "done.\n" , Console :: FG_GREEN , Console :: BOLD ) ; } } else { $ this -> stdout ( "\nInformation may be outdated, re-run with `--update` to fetch latest tags.\n\n" ) ; } $ versions = $ this -> getCurrentVersions ( $ items ) ; $ nextVersions = $ this -> getNextVersions ( $ versions , self :: PATCH ) ; $ w = $ this -> minWidth ( array_keys ( $ versions ) ) ; $ this -> stdout ( str_repeat ( ' ' , $ w + 2 ) . "Current Version Next Version\n" , Console :: BOLD ) ; foreach ( $ versions as $ ext => $ version ) { $ this -> stdout ( $ ext . str_repeat ( ' ' , $ w + 3 - mb_strlen ( $ ext ) ) . $ version . '' ) ; $ this -> stdout ( str_repeat ( ' ' , 17 - mb_strlen ( $ version ) ) . $ nextVersions [ $ ext ] . "\n" ) ; } }
10270	function setReplyToAddress ( $ mailingId , $ auto = true , $ customEmail = null ) { $ queryParameters = array ( 'auto' => ( $ auto == TRUE ) ? "true" : "false" , 'customEmail' => $ customEmail ) ; return $ this -> post ( 'mailings/' . $ mailingId . '/settings/replyto' , null , $ queryParameters ) ; }
5674	protected function isMatchingKeys ( $ first , $ second , $ identical ) { $ first_keys = array_keys ( $ first ) ; $ second_keys = array_keys ( $ second ) ; if ( $ identical ) { return ( $ first_keys === $ second_keys ) ; } sort ( $ first_keys ) ; sort ( $ second_keys ) ; return ( $ first_keys == $ second_keys ) ; }
30	public function appendPackages ( array $ packages , array $ bucket ) { foreach ( $ packages as $ package ) { $ bucket [ $ package -> getName ( ) ] = $ package ; } return $ bucket ; }
6050	public function addPropertyResponse ( $ item ) { if ( ! ( $ item instanceof PropertyResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertyResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertyResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertyResponse"!' , E_USER_WARNING ) ; } } $ this -> properties [ ] = $ item ; return $ this ; }
11173	public static function decrypt ( $ data , $ key , $ cipher = MCRYPT_RIJNDAEL_128 , $ mode = MCRYPT_MODE_CBC ) { $ key = hash ( 'sha256' , $ key , true ) ; @ list ( $ iv , $ encrypted ) = ( array ) unserialize ( base64_decode ( $ data ) ) ; return unserialize ( trim ( mcrypt_decrypt ( $ cipher , $ key , $ encrypted , $ mode , $ iv ) ) ) ; }
2393	public function addFile ( $ strFile , $ strName = null ) { if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFile ) ) { throw new \ Exception ( "File $strFile does not exist" ) ; } if ( strncmp ( $ strName , '/' , 1 ) === 0 ) { $ strName = substr ( $ strName , 1 ) ; } $ this -> addString ( file_get_contents ( $ this -> strRootDir . '/' . $ strFile ) , $ strName ? : $ strFile , filemtime ( $ this -> strRootDir . '/' . $ strFile ) ) ; }
10995	public function write ( string $ contents , int $ opts = 0 ) : bool { if ( $ this -> prepareWrite ( ) !== true ) { $ this -> error = "failed to write '{$this->path}; {$this->error}" ; return false ; } return $ this -> writeFile ( $ contents , $ opts ) ; }
6237	private static function getOptions ( ) { return [ '1/6' => Craft :: t ( 'width-fieldtype' , '1/6' ) , '1/5' => Craft :: t ( 'width-fieldtype' , '1/5' ) , '1/4' => Craft :: t ( 'width-fieldtype' , '1/4' ) , '1/3' => Craft :: t ( 'width-fieldtype' , '1/3' ) , '2/5' => Craft :: t ( 'width-fieldtype' , '2/5' ) , '1/2' => Craft :: t ( 'width-fieldtype' , '1/2' ) , '3/5' => Craft :: t ( 'width-fieldtype' , '3/5' ) , '2/3' => Craft :: t ( 'width-fieldtype' , '2/3' ) , '3/4' => Craft :: t ( 'width-fieldtype' , '3/4' ) , '4/5' => Craft :: t ( 'width-fieldtype' , '4/5' ) , '5/6' => Craft :: t ( 'width-fieldtype' , '5/6' ) , 'full' => Craft :: t ( 'width-fieldtype' , 'Full' ) , ] ; }
5468	public function addHeaders ( $ request , $ url ) { if ( $ url -> getUsername ( ) && $ url -> getPassword ( ) ) { $ username = $ url -> getUsername ( ) ; $ password = $ url -> getPassword ( ) ; } elseif ( $ realm = $ this -> findRealmFromUrl ( $ url ) ) { $ username = $ realm -> getUsername ( ) ; $ password = $ realm -> getPassword ( ) ; } else { return ; } $ this -> addBasicHeaders ( $ request , $ username , $ password ) ; }
3395	protected function attemptLogin ( Request $ request ) { if ( $ this -> guard ( ) -> validate ( $ this -> credentials ( $ request ) ) ) { $ user = $ this -> guard ( ) -> getLastAttempted ( ) ; if ( ! is_null ( $ user -> confirmed_at ) ) { return $ this -> baseAttemptLogin ( $ request ) ; } session ( [ 'confirmation_user_id' => $ user -> getKey ( ) ] ) ; throw ValidationException :: withMessages ( [ 'confirmation' => [ __ ( 'confirmation::confirmation.not_confirmed' , [ 'resend_link' => route ( 'auth.resend_confirmation' ) ] ) ] ] ) ; } return false ; }
12180	public function getTaxonomyPackage ( ) { if ( empty ( $ this -> taxonomy ) ) { return false ; } $ taxonomySettings = $ this -> taxonomy ; if ( ! is_array ( $ taxonomySettings ) ) { $ taxonomySettings = [ 'id' => $ taxonomySettings ] ; } $ taxonomy = Yii :: $ app -> collectors [ 'taxonomies' ] -> getOne ( $ taxonomySettings [ 'id' ] ) ; if ( empty ( $ taxonomy ) || empty ( $ taxonomy -> object ) ) { return false ; } return $ taxonomy -> package ( $ taxonomySettings ) ; }
6836	private function isIdentityValid ( SaleInterface $ cart ) { return 0 < strlen ( $ cart -> getEmail ( ) ) && 0 < strlen ( $ cart -> getGender ( ) ) && 0 < strlen ( $ cart -> getFirstName ( ) ) && 0 < strlen ( $ cart -> getLastName ( ) ) ; }
8661	private function convertGetFeedSubmissionResult ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionResult' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionId ( ) ) { $ parameters [ 'FeedSubmissionId' ] = $ request -> getFeedSubmissionId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
10260	public function getIp ( ) { $ parts = [ ] ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ parts [ ] = $ this -> getInteger ( 0 , 255 ) ; } return join ( '.' , $ parts ) ; }
8313	protected function beginPasswordReset ( ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ this -> picoAuth -> addAllowed ( "password_reset" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/pwbeginreset.md' ) ; if ( count ( $ this -> session -> getFlash ( '_pwresetsent' ) ) ) { $ this -> picoAuth -> addOutput ( "resetSent" , true ) ; return ; } $ post = $ this -> httpRequest -> request ; if ( $ post -> has ( "reset_email" ) ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ email = trim ( $ post -> get ( "reset_email" ) ) ; if ( ! filter_var ( $ email , FILTER_VALIDATE_EMAIL ) ) { $ this -> session -> addFlash ( "error" , "Email address does not have a valid format." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( ! $ this -> limit -> action ( "passwordReset" , true , array ( "email" => $ email ) ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( $ userData = $ this -> storage -> getUserByEmail ( $ email ) ) { $ this -> sendResetMail ( $ userData ) ; } $ this -> session -> addFlash ( "_pwresetsent" , true ) ; $ this -> session -> addFlash ( "success" , "Reset link sent via email." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
4070	public function getStylesheets ( GetOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getPropertyName ( ) !== 'additionalCss' ) || ( $ event -> getSubPropertyName ( ) !== 'file' ) ) { return ; } $ event -> setOptions ( $ this -> scanFiles ( 'css' ) ) ; }
9369	protected function resolve ( ContainerInterface $ container , ServerRequestInterface $ request , ResponseInterface $ response ) { if ( class_exists ( 'Zend\Diactoros\ServerRequestFactory' ) ) { $ response = new ZendResponse ; $ request = ServerRequestFactory :: fromGlobals ( ) ; } $ container -> set ( 'Psr\Http\Message\ServerRequestInterface' , $ request ) ; return $ container -> set ( 'Psr\Http\Message\ResponseInterface' , $ response ) ; }
11945	protected function handleEventMessage ( array $ message ) { Log :: debug ( 'OpenPlatform Event Message detail:' , $ message ) ; $ message = new Collection ( $ message ) ; $ infoType = $ message -> get ( 'InfoType' ) ; if ( $ handler = $ this -> getHandler ( $ infoType ) ) { $ handler -> handle ( $ message ) ; } else { Log :: notice ( "No existing handler for '{$infoType}'." ) ; } if ( $ messageHandler = $ this -> getMessageHandler ( ) ) { call_user_func_array ( $ messageHandler , [ $ message ] ) ; } }
501	protected function getHeaderCheckBoxName ( ) { $ name = $ this -> name ; if ( substr_compare ( $ name , '[]' , - 2 , 2 ) === 0 ) { $ name = substr ( $ name , 0 , - 2 ) ; } if ( substr_compare ( $ name , ']' , - 1 , 1 ) === 0 ) { $ name = substr ( $ name , 0 , - 1 ) . '_all]' ; } else { $ name .= '_all' ; } return $ name ; }
12969	public function transformFromFront ( array $ array ) { $ transformation = $ this -> getTransformation ( ) ; $ fillables = $ this -> getFillable ( ) ; $ transformed = [ ] ; foreach ( $ fillables as $ name ) { if ( ! key_exists ( $ name , $ array ) ) { continue ; } $ transformed [ $ name ] = $ array [ $ name ] ; } foreach ( $ transformation as $ name => $ new_name ) { if ( ! key_exists ( $ new_name , $ array ) ) { continue ; } $ transformed [ $ name ] = $ array [ $ new_name ] ; } return $ transformed ; }
7775	protected function handleError ( $ field , $ value , $ rule , array $ args ) { $ this -> errors [ $ rule ] [ ] = [ 'field' => $ field , 'value' => $ value , 'args' => $ args , ] ; }
11076	public function getHttpClient ( ) { if ( null === $ this -> httpClient ) { $ this -> httpClient = new HttpClient ( ) ; $ this -> httpClient -> setAdapter ( $ this -> getHttpAdapter ( ) ) ; } return $ this -> httpClient ; }
11743	public function remove ( $ pageName ) { if ( $ pageName == $ this -> configurationHandler -> homepage ( ) ) { throw new RuntimeException ( "exception_homepage_cannot_be_removed" ) ; } $ pageDir = $ this -> pagesDir . '/' . $ pageName ; Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_REMOVING , new PageCollectionRemovingEvent ( $ this -> username , $ pageDir ) ) ; $ filesystem = new Filesystem ( ) ; if ( file_exists ( $ pageDir . '/page.json' ) ) { $ filesystem -> mirror ( $ pageDir , $ this -> pagesRemovedDir . '/' . $ pageName . "-" . date ( "Y-m-d-H.i.s" ) ) ; } $ filesystem -> remove ( $ pageDir ) ; Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_REMOVED , new PageCollectionRemovedEvent ( $ this -> username , $ pageDir ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully removed from website' , $ pageName ) ) ; }
3985	private function isActive ( $ route , $ params , Request $ request ) { if ( '/contao' === $ request -> getPathInfo ( ) || ! ( $ request -> attributes -> get ( '_route' ) === $ route ) ) { return false ; } $ attributes = $ request -> attributes -> get ( '_route_params' ) ; $ query = $ request -> query ; foreach ( $ params as $ param => $ value ) { if ( isset ( $ attributes [ $ param ] ) && ( $ value !== $ request -> attributes [ '_route_params' ] [ $ param ] ) ) { return false ; } if ( $ query -> has ( $ param ) && ( $ value !== $ query -> get ( $ param ) ) ) { return false ; } } return true ; }
3572	public function set ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { return $ this -> setInstance ( $ key ) ; } if ( $ this -> has ( $ key ) ) { $ this -> update ( $ key , $ value , $ group ) ; } else { $ this -> items [ $ key ] = $ this -> newAttribute ( $ key , $ value , $ group ) ; } return $ this ; }
6929	private function checkShipmentInvoice ( Invoice \ InvoiceInterface $ invoice ) { if ( null === $ shipment = $ invoice -> getShipment ( ) ) { throw new LogicException ( "Invoice's shipment must be set at this point." ) ; } if ( $ shipment -> getSale ( ) !== $ sale = $ invoice -> getSale ( ) ) { throw new LogicException ( "Shipment/Invoice sale miss match." ) ; } if ( ! $ sale instanceof Invoice \ InvoiceSubjectInterface ) { throw new LogicException ( "Expected instance of " . Invoice \ InvoiceSubjectInterface :: class ) ; } if ( $ shipment -> isReturn ( ) && ! Invoice \ InvoiceTypes :: isCredit ( $ invoice ) ) { throw new LogicException ( "Invoice should not be associated with Return." ) ; } elseif ( ! $ shipment -> isReturn ( ) && ! Invoice \ InvoiceTypes :: isInvoice ( $ invoice ) ) { throw new LogicException ( "Credit should not be associated with Shipment." ) ; } }
12401	public function get ( $ multiple = true ) { $ scope = $ this -> scope ; return Parser :: get ( $ scope , $ this -> connection , $ multiple ) ; }
5856	public function initializeRulesets ( array $ configuration ) { $ general = $ configuration ; $ general [ 'usergroup' ] = '' ; unset ( $ general [ 'rulesets' ] ) ; $ general = $ this -> expandValuesInRuleset ( $ general ) ; if ( $ general [ 'conversion_mapping' ] === '' ) { $ general [ 'conversion_mapping' ] = [ ] ; } if ( isset ( $ configuration [ 'rulesets' ] ) ) { $ rulesets = $ this -> compileRuleSets ( $ configuration [ 'rulesets' ] ) ; } else { $ rulesets = [ ] ; } foreach ( $ rulesets as $ k => & $ ruleset ) { foreach ( $ general as $ key => $ value ) { if ( ! isset ( $ ruleset [ $ key ] ) ) { $ ruleset [ $ key ] = $ value ; } elseif ( $ ruleset [ $ key ] === '' ) { $ ruleset [ $ key ] = $ value ; } } if ( count ( $ ruleset [ 'usergroup' ] ) == 0 ) { $ ruleset [ 'directories' ] = array_diff ( $ ruleset [ 'directories' ] , $ general [ 'directories' ] ) ; if ( count ( $ ruleset [ 'directories' ] ) == 0 ) { unset ( $ rulesets [ $ k ] ) ; } } } $ rulesets [ ] = $ general ; $ this -> rulesets = $ rulesets ; }
10073	public function allDrawings ( Spreadsheet $ spreadsheet ) { $ aDrawings = [ ] ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ iterator = $ spreadsheet -> getSheet ( $ i ) -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { $ aDrawings [ ] = $ iterator -> current ( ) ; $ iterator -> next ( ) ; } } return $ aDrawings ; }
11617	public function records ( $ startTime , $ endTime , $ page = 1 , $ pageSize = 10 ) { $ params = [ 'starttime' => is_numeric ( $ startTime ) ? $ startTime : strtotime ( $ startTime ) , 'endtime' => is_numeric ( $ endTime ) ? $ endTime : strtotime ( $ endTime ) , 'pageindex' => $ page , 'pagesize' => $ pageSize , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RECORDS , $ params ] ) ; }
5403	protected function fixPath ( $ path ) { if ( substr ( $ path , 0 , 1 ) != '/' ) { $ path = '/' . $ path ; } if ( substr ( $ path , - 1 , 1 ) != '/' ) { $ path .= '/' ; } return $ path ; }
4036	private function fetchTemplatesFromResourceDirectories ( $ templateBaseName ) { $ allTemplates = [ ] ; $ themeName = $ this -> getNoThemeMessage ( ) ; foreach ( $ this -> resourceDirs as $ resourceDir ) { $ allTemplates = array_replace_recursive ( $ allTemplates , $ this -> getTemplatesForBaseFrom ( $ templateBaseName , $ resourceDir . '/templates' , $ themeName ) ) ; } return $ allTemplates ; }
3059	public function selectAdaptiveNextItem ( ) { $ lastItemId = $ this -> getCurrentCatItemId ( ) ; $ lastOutput = $ this -> getLastCatItemOutput ( ) ; $ catSession = $ this -> getCatSession ( ) ; $ preSelection = $ catSession -> getTestMap ( ) ; try { if ( ! $ this -> syncingMode ) { $ selection = $ catSession -> getTestMap ( array_values ( $ lastOutput ) ) ; if ( ! $ this -> saveAdaptiveResults ( $ catSession ) ) { \ common_Logger :: w ( 'Unable to save CatService results.' ) ; } $ isShadowItem = false ; } else { $ selection = $ catSession -> getTestMap ( ) ; $ isShadowItem = true ; } } catch ( CatEngineException $ e ) { \ common_Logger :: e ( 'Error during CatEngine processing. ' . $ e -> getMessage ( ) ) ; $ selection = $ catSession -> getTestMap ( ) ; $ isShadowItem = true ; } $ event = new SelectAdaptiveNextItemEvent ( $ this -> getTestSession ( ) , $ lastItemId , $ preSelection , $ selection , $ isShadowItem ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ this -> persistCatSession ( $ catSession ) ; if ( is_array ( $ selection ) && count ( $ selection ) > 0 ) { \ common_Logger :: d ( "New CAT item selection is '" . implode ( ', ' , $ selection ) . "'." ) ; return $ selection [ 0 ] ; } else { \ common_Logger :: d ( 'No new CAT item selection.' ) ; return null ; } }
4392	public function checkConfigBE ( array $ attributes ) { return array_merge ( parent :: checkConfigBE ( $ attributes ) , $ this -> checkConfig ( $ this -> beConfig , $ attributes ) ) ; }
8268	public function open ( ) { if ( $ this -> isOpened ( ) ) { return ; } if ( ! file_exists ( $ this -> filePath ) ) { throw new \ RuntimeException ( $ this -> filePath . " does not exist" ) ; } $ this -> handle = @ fopen ( $ this -> filePath , self :: OPEN_MODE ) ; if ( $ this -> handle === false ) { throw new \ RuntimeException ( "Could not open file for reading: " . $ this -> filePath ) ; } if ( ! $ this -> lock ( LOCK_SH ) ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not aquire a shared lock for " . $ this -> filePath ) ; } }
11942	private function validateArgument ( Request $ request , ConfigContainer $ config , $ position ) { $ value = null ; switch ( $ config -> getValue ( 'storage' ) ) { case 'url' : $ value = $ this -> validateUrl ( $ request , $ config , $ position ) ; break ; case 'post' : $ value = $ this -> validateGetPost ( $ request -> getData ( ) , $ config , $ position ) ; break ; case 'get' : $ value = $ this -> validateGetPost ( $ request -> getQuery ( ) , $ config , $ position ) ; break ; default : throw new InvalidConfigValueException ( 'storage' , $ config -> getValue ( 'storage' ) ) ; } $ validatorName = $ config -> getValue ( 'validator' ) ; if ( $ validatorName !== '' ) { $ validatorObject = new $ validatorName ( ) ; $ error = $ validatorObject -> validate ( $ value ) ; if ( $ error ) { throw new InvalidArgumentException ( $ position , $ config -> getValue ( 'name' ) , $ error ) ; } } $ mapperName = $ config -> getValue ( 'mapper' ) ; if ( $ mapperName !== '' ) { $ mapper = new $ mapperName ( $ this -> container ) ; $ value = $ mapper -> cast ( $ value ) ; } $ request -> setArgument ( $ config -> getValue ( 'name' ) , $ value ) ; }
1400	public function exception ( \ Exception $ ex ) { if ( $ this -> getCodec ( ) -> willNotEncode ( ) ) { $ this -> codec = $ this -> api -> getDefaultCodec ( ) ; } return $ this -> getErrorResponse ( $ this -> exceptions -> parse ( $ ex ) ) ; }
3439	public function section ( $ load = false ) { $ fields = $ this -> getFields ( ) ; $ sectionModel = static :: sectionModel ( ) ; return $ load ? $ sectionModel :: query ( ) -> getById ( $ fields [ 'IBLOCK_SECTION_ID' ] ) : new $ sectionModel ( $ fields [ 'IBLOCK_SECTION_ID' ] ) ; }
4567	public function resolve ( Form $ form ) { switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ resolve = function ( & $ component ) use ( & $ resolve , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as & $ subComponent ) { $ resolve ( $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as & $ subComponent ) { $ resolve ( $ subComponent ) ; } } break ; case property_exists ( $ component , 'defaultValue' ) : if ( null !== $ component -> defaultValue ) { try { $ component -> defaultValue = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ component -> defaultValue = null ; } catch ( UnmatchedException $ exception ) { } } break ; } } ; foreach ( $ components as & $ component ) { $ resolve ( $ component ) ; } $ form -> setSchema ( $ components ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ form ; }
7062	protected function updateCustomerBalance ( PaymentInterface $ payment , $ amount = null ) { if ( null === $ customer = $ payment -> getSale ( ) -> getCustomer ( ) ) { return false ; } $ amount = $ amount ? : $ payment -> getAmount ( ) ; if ( $ this -> isAcceptedPayment ( $ payment ) ) { $ amount = - $ amount ; } if ( $ payment -> getMethod ( ) -> isCredit ( ) ) { return $ this -> updateCreditBalance ( $ customer , $ amount , true ) ; } elseif ( $ payment -> getMethod ( ) -> isOutstanding ( ) ) { return $ this -> updateOutstandingBalance ( $ customer , $ amount , true ) ; } return false ; }
4139	protected function getOauthParameters ( ) { $ time = time ( ) ; return array ( 'oauth_consumer_key' => $ this -> getConsumerKey ( ) , 'oauth_nonce' => trim ( base64_encode ( $ time ) , '=' ) , 'oauth_signature_method' => 'HMAC-SHA1' , 'oauth_timestamp' => $ time , 'oauth_token' => $ this -> getAccessToken ( ) , 'oauth_version' => '1.0' ) ; }
7476	public function getEntitiesByIds ( $ identifier , array $ values ) { $ accessor = PropertyAccess :: createPropertyAccessor ( ) ; return array_filter ( is_array ( $ this -> entities ) ? $ this -> entities : $ this -> entities -> toArray ( ) , function ( $ entity ) use ( $ identifier , $ values , $ accessor ) { return in_array ( $ accessor -> getValue ( $ entity , $ identifier ) , $ values ) ; } ) ; }
11281	public function getFloat ( $ min , $ max ) { if ( $ min > $ max ) { throw new InvalidArgumentException ( 'Min cannot be greater than max' ) ; } $ random01 = \ mt_rand ( ) / \ mt_getrandmax ( ) ; return ( $ max - $ min ) * $ random01 + $ min ; }
3254	private function getItem ( $ sku ) { $ className = Config :: get ( 'shop.item' ) ; $ item = new $ className ( ) ; return $ item -> where ( 'sku' , $ sku ) -> where ( 'cart_id' , $ this -> attributes [ 'id' ] ) -> first ( ) ; }
955	public function retrieve ( ) { $ path = null ; switch ( $ this -> type ) { case self :: CHARGE_CREDIT : $ path = 'application_credits' ; break ; case self :: CHARGE_ONETIME : $ path = 'application_charges' ; break ; default : $ path = 'recurring_application_charges' ; break ; } return $ this -> shop -> api ( ) -> rest ( 'GET' , "/admin/{$path}/{$this->charge_id}.json" ) -> body -> { substr ( $ path , 0 , - 1 ) } ; }
12319	public function redirect ( string $ shortURLKey ) { $ record = HCShortURL :: where ( 'short_url_key' , $ shortURLKey ) -> first ( ) ; if ( ! $ record ) abort ( 404 ) ; $ record -> increment ( 'clicks' ) ; return redirect ( $ record -> url ) ; }
1813	public function setRteSyntax ( $ varValue , Contao \ DataContainer $ dc ) { switch ( $ dc -> activeRecord -> highlight ) { case 'C' : case 'CSharp' : $ syntax = 'c_cpp' ; break ; case 'CSS' : case 'Diff' : case 'Groovy' : case 'HTML' : case 'Java' : case 'JavaScript' : case 'Perl' : case 'PHP' : case 'PowerShell' : case 'Python' : case 'Ruby' : case 'Scala' : case 'SQL' : case 'Text' : case 'YAML' : $ syntax = strtolower ( $ dc -> activeRecord -> highlight ) ; break ; case 'VB' : $ syntax = 'vbscript' ; break ; case 'XML' : case 'XHTML' : $ syntax = 'xml' ; break ; default : $ syntax = 'text' ; break ; } if ( $ dc -> activeRecord -> type == 'markdown' ) { $ syntax = 'markdown' ; } $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'code' ] [ 'eval' ] [ 'rte' ] = 'ace|' . $ syntax ; return $ varValue ; }
6156	public function redirect ( string $ url ) : object { return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
259	protected function findViewFile ( $ view , $ context = null ) { if ( strncmp ( $ view , '@' , 1 ) === 0 ) { $ file = Yii :: getAlias ( $ view ) ; } elseif ( strncmp ( $ view , '//' , 2 ) === 0 ) { $ file = Yii :: $ app -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } elseif ( strncmp ( $ view , '/' , 1 ) === 0 ) { if ( Yii :: $ app -> controller !== null ) { $ file = Yii :: $ app -> controller -> module -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } else { throw new InvalidCallException ( "Unable to locate view file for view '$view': no active controller." ) ; } } elseif ( $ context instanceof ViewContextInterface ) { $ file = $ context -> getViewPath ( ) . DIRECTORY_SEPARATOR . $ view ; } elseif ( ( $ currentViewFile = $ this -> getRequestedViewFile ( ) ) !== false ) { $ file = dirname ( $ currentViewFile ) . DIRECTORY_SEPARATOR . $ view ; } else { throw new InvalidCallException ( "Unable to resolve view file for view '$view': no active view context." ) ; } if ( pathinfo ( $ file , PATHINFO_EXTENSION ) !== '' ) { return $ file ; } $ path = $ file . '.' . $ this -> defaultExtension ; if ( $ this -> defaultExtension !== 'php' && ! is_file ( $ path ) ) { $ path = $ file . '.php' ; } return $ path ; }
104	public function isRateLimited ( array $ headers ) { foreach ( $ headers as $ header ) { if ( preg_match ( '{^X-RateLimit-Remaining: *0$}i' , trim ( $ header ) ) ) { return true ; } } return false ; }
1393	protected function prepareJsonApiException ( JsonApiException $ ex ) { $ error = collect ( $ ex -> getErrors ( ) ) -> map ( function ( ErrorInterface $ err ) { return $ err -> getDetail ( ) ? : $ err -> getTitle ( ) ; } ) -> filter ( ) -> first ( ) ; return new HttpException ( $ ex -> getHttpCode ( ) , $ error , $ ex ) ; }
9419	public function samples ( $ amount ) { if ( ! is_numeric ( $ amount ) || $ amount < 1 ) { throw new \ InvalidArgumentException ( 'Amount of samples must be greater or equal to one' ) ; } $ arr = array ( ) ; for ( $ i = 1 ; $ i <= $ amount ; $ i ++ ) { $ r = new Random ( ) ; $ float_u = $ r -> get ( ) ; $ float_v = $ r -> get ( ) ; $ double_x = $ this -> float_sigma * sqrt ( - 2 * log ( $ float_u ) ) * cos ( 2 * pi ( ) * $ float_v ) + $ this -> float_mu ; if ( $ this -> int_precision ) { $ arr [ ] = round ( $ double_x , $ this -> int_precision ) ; } else { $ arr [ ] = $ double_x ; } } return $ arr ; }
257	public function init ( ) { parent :: init ( ) ; if ( is_array ( $ this -> theme ) ) { if ( ! isset ( $ this -> theme [ 'class' ] ) ) { $ this -> theme [ 'class' ] = 'yii\base\Theme' ; } $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } elseif ( is_string ( $ this -> theme ) ) { $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } }
1881	protected function isValid ( $ strFile ) { $ strFolder = Input :: get ( 'pid' , true ) ; if ( Validator :: isInsecurePath ( $ strFile ) ) { throw new AccessDeniedException ( 'Invalid file name "' . $ strFile . '" (hacking attempt).' ) ; } elseif ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new AccessDeniedException ( 'Invalid folder name "' . $ strFolder . '" (hacking attempt).' ) ; } if ( ! empty ( $ this -> arrValidFileTypes ) && is_file ( $ this -> strRootDir . '/' . $ strFile ) ) { $ fileinfo = preg_replace ( '/.*\.(.*)$/u' , '$1' , $ strFile ) ; if ( ! \ in_array ( strtolower ( $ fileinfo ) , $ this -> arrValidFileTypes ) ) { throw new AccessDeniedException ( 'File "' . $ strFile . '" is not an allowed file type.' ) ; } } if ( ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFile ) ) { throw new AccessDeniedException ( 'File or folder "' . $ strFile . '" is not within the files directory.' ) ; } if ( $ strFolder && ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFolder ) ) { throw new AccessDeniedException ( 'Parent folder "' . $ strFolder . '" is not within the files directory.' ) ; } if ( Input :: get ( 'act' ) == 'edit' || Input :: get ( 'act' ) == 'paste' || Input :: get ( 'act' ) == 'delete' ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> isAdmin && \ in_array ( $ strFile , $ this -> User -> filemounts ) ) { throw new AccessDeniedException ( 'Attempt to edit, copy, move or delete the root folder "' . $ strFile . '".' ) ; } } return true ; }
4264	protected function doPublish ( $ eventName , $ subscribers , Event $ event ) { foreach ( $ subscribers as $ callable ) { if ( $ event -> isPropagationStopped ( ) ) { break ; } \ call_user_func ( $ callable , $ event , $ eventName , $ this ) ; } }
7782	public function init ( ) { $ this -> actionRoute = Url :: toRoute ( $ this -> actionRoute ) ; $ this -> name = Yii :: $ app -> session -> get ( 'timezone' ) ; if ( $ this -> name == null ) { $ this -> registerTimezoneScript ( $ this -> actionRoute ) ; $ this -> name = date_default_timezone_get ( ) ; } Yii :: $ app -> setTimeZone ( $ this -> name ) ; }
6391	public function readScormScoesTrack ( $ userid , $ scormid , $ scoid , $ attempt ) { $ trackingValues = [ ] ; $ scormTracking = $ this -> readStoreRecords ( 'scorm_scoes_track' , [ 'userid' => $ userid , 'scormid' => $ scormid , 'scoid' => $ scoid , 'attempt' => $ attempt ] ) ; foreach ( $ scormTracking as $ st ) { if ( $ st -> element == 'cmi.core.score.min' ) { $ trackingValues [ 'scoremin' ] = $ st -> value ; } else if ( $ st -> element == 'cmi.core.score.max' ) { $ trackingValues [ 'scoremax' ] = $ st -> value ; } else if ( $ st -> element == 'cmi.core.lesson_status' ) { $ trackingValues [ 'status' ] = $ st -> value ; } } return $ trackingValues ; }
10141	private function loadOLE ( $ pFilename ) { $ ole = new OLERead ( ) ; $ ole -> read ( $ pFilename ) ; $ this -> data = $ ole -> getStream ( $ ole -> wrkbook ) ; $ this -> summaryInformation = $ ole -> getStream ( $ ole -> summaryInformation ) ; $ this -> documentSummaryInformation = $ ole -> getStream ( $ ole -> documentSummaryInformation ) ; }
1422	protected function createModelIdentity ( $ modelClass , $ id , $ keyName = null ) { if ( is_null ( $ id ) ) { return null ; } $ model = new $ modelClass ( ) ; if ( ! $ model instanceof Model ) { throw new RuntimeException ( sprintf ( 'Expecting a model class, got %s.' , $ modelClass ) ) ; } $ model -> setAttribute ( $ keyName ? : $ model -> getRouteKeyName ( ) , $ id ) ; return $ model ; }
7148	public function getTotal ( $ discounted = true ) { $ base = $ this -> base ; if ( $ discounted && $ this -> hasDiscounts ( ) ) { foreach ( $ this -> discounts as $ discount ) { $ base -= $ this -> calculateAdjustment ( $ discount , $ base ) ; } } $ total = $ base ; if ( ! empty ( $ this -> taxes ) && $ this -> mode === VatDisplayModes :: MODE_ATI ) { foreach ( $ this -> taxes as $ tax ) { $ total += $ this -> calculateAdjustment ( $ tax , $ base ) ; } } return $ total ; }
6127	public function setExpireDate ( $ expireDate ) { if ( $ expireDate instanceof DateTime ) { $ this -> expireDate = $ expireDate ; } else { try { $ this -> expireDate = new DateTime ( $ expireDate ) ; } catch ( \ Exception $ e ) { $ this -> expireDate = null ; } } return $ this ; }
7222	protected function clearShipment ( Shipment \ ShipmentInterface $ shipment ) { if ( empty ( $ shipment -> getTrackingNumber ( ) ) && ! $ shipment -> hasLabels ( ) ) { return false ; } $ shipment -> setTrackingNumber ( null ) ; foreach ( $ shipment -> getLabels ( ) as $ label ) { $ shipment -> removeLabel ( $ label ) ; } return true ; }
5728	public function Field ( $ properties = array ( ) ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/dropdown_form_action.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/dropdown_form_action.js' ) ; $ this -> setAttribute ( 'data-form-action-dropdown' , '#' . $ this -> DropdownID ( ) ) ; return parent :: Field ( ) ; }
5558	protected function findForm ( $ method , $ attribute ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> findFormInFrame ( $ this -> frames [ $ this -> focus ] , $ this -> focus , $ method , $ attribute ) ; } for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ form = $ this -> findFormInFrame ( $ this -> frames [ $ i ] , $ i , $ method , $ attribute ) ; if ( $ form ) { return $ form ; } } return ; }
5667	public function getType ( $ value ) { if ( ! isset ( $ value ) ) { return 'Null' ; } elseif ( is_bool ( $ value ) ) { return 'Boolean' ; } elseif ( is_string ( $ value ) ) { return 'String' ; } elseif ( is_integer ( $ value ) ) { return 'Integer' ; } elseif ( is_float ( $ value ) ) { return 'Float' ; } elseif ( is_array ( $ value ) ) { return 'Array' ; } elseif ( is_resource ( $ value ) ) { return 'Resource' ; } elseif ( is_object ( $ value ) ) { return 'Object' ; } return 'Unknown' ; }
10523	protected function getDepDropParents ( $ post = 'depdrop_parents' ) { $ parents = Yii :: $ app -> request -> post ( $ post ) ; $ filteredParents = [ ] ; foreach ( $ parents as $ key => $ parent ) { if ( is_numeric ( $ parent ) ) { $ filteredParents [ $ key ] = $ parent ; } else { return [ ] ; } } return $ filteredParents ; }
5396	public function paintSkip ( $ message ) { parent :: paintSkip ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'skip>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "skip>\n" ; }
5619	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ msg = '<span class="fail">Fail</span>: ' ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; $ msg .= implode ( '-&gt;' , $ breadcrumb ) ; $ msg .= '-&gt;' . htmlentities ( $ message ) . '<br />' ; echo "add_fail('$msg');\n" ; }
1789	public function pasteArticle ( Contao \ DataContainer $ dc , $ row , $ table , $ cr , $ arrClipboard = null ) { $ imagePasteAfter = Contao \ Image :: getHtml ( 'pasteafter.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) ; $ imagePasteInto = Contao \ Image :: getHtml ( 'pasteinto.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) ; if ( $ table == $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'ptable' ] ) { return ( $ row [ 'type' ] == 'root' || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ row ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteinto_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=2&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteInto . '</a> ' ; } $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return ( ( $ arrClipboard [ 'mode' ] == 'cut' && $ arrClipboard [ 'id' ] == $ row [ 'id' ] ) || ( $ arrClipboard [ 'mode' ] == 'cutAll' && \ in_array ( $ row [ 'id' ] , $ arrClipboard [ 'id' ] ) ) || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ objPage -> row ( ) ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteafter_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=1&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteAfter . '</a> ' ; }
7505	public function assignNamespace ( string $ namespace , $ prepend = false ) { if ( $ prepend ) { array_unshift ( $ this -> namespaces , $ namespace ) ; return ; } array_push ( $ this -> namespaces , $ namespace ) ; }
8852	public function getCurrentTag ( ) { $ tag = $ this -> request -> param ( "Tag" ) ; if ( $ tag ) { return $ this -> dataRecord -> Tags ( ) -> filter ( "URLSegment" , $ tag ) -> first ( ) ; } return null ; }
12018	protected function setup ( \ AMQPQueue $ queue ) { $ queue -> declareQueue ( ) ; foreach ( $ this -> binds as $ exchange => $ params ) { $ queue -> bind ( $ exchange , $ params [ 'routing_key' ] , $ params [ 'arguments' ] ) ; } }
10390	public static function loadString ( $ xmlString ) { $ xmlFile = tempnam ( self :: getSysTempDir ( ) , 'xml_' ) ; file_put_contents ( $ xmlFile , $ xmlString ) ; $ xml = self :: parseXml ( $ xmlFile ) ; unlink ( $ xmlFile ) ; return $ xml ; }
2494	protected function escapeExpressions ( $ string , $ allowWildcard = false ) { if ( $ allowWildcard ) { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~?:\\ ' ) ; } else { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~*?:\\ ' ) ; } return preg_replace_callback ( '/([' . $ reservedCharacters . '])/' , function ( $ matches ) { return '\\' . $ matches [ 0 ] ; } , $ string ) ; }
1106	protected function writeMigration ( $ name ) { $ output = pathinfo ( $ this -> migrator -> create ( $ name , $ this -> getMigrationsPath ( ) ) , PATHINFO_FILENAME ) ; $ this -> line ( " <fg=green;options=bold>create</fg=green;options=bold> $output" ) ; }
3700	private function handleSorting ( $ information , GroupAndSortingDefinitionInterface $ definition ) { if ( $ information [ 'ismanualsort' ] ) { $ definition -> add ( ) -> setManualSorting ( ) -> setProperty ( 'sorting' ) -> setSortingMode ( GroupAndSortingInformationInterface :: SORT_ASC ) ; return ; } if ( $ information [ 'col_name' ] ) { $ definition -> add ( ) -> setProperty ( $ information [ 'col_name' ] ) -> setSortingMode ( $ information [ 'rendersort' ] ) ; } }
897	private function fixTokensCompare ( Tokens $ tokens , $ startLeft , $ endLeft , $ compareOperatorIndex , $ startRight , $ endRight ) { $ type = $ tokens [ $ compareOperatorIndex ] -> getId ( ) ; $ content = $ tokens [ $ compareOperatorIndex ] -> getContent ( ) ; if ( \ array_key_exists ( $ type , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ type ] ; } elseif ( \ array_key_exists ( $ content , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ content ] ; } $ right = $ this -> fixTokensComparePart ( $ tokens , $ startRight , $ endRight ) ; $ left = $ this -> fixTokensComparePart ( $ tokens , $ startLeft , $ endLeft ) ; for ( $ i = $ startRight ; $ i <= $ endRight ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } for ( $ i = $ startLeft ; $ i <= $ endLeft ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens -> insertAt ( $ startRight , $ left ) ; $ tokens -> insertAt ( $ startLeft , $ right ) ; return $ startLeft ; }
5935	public function setGroups ( array $ groups ) { $ this -> groups = [ ] ; foreach ( $ groups as $ item ) { $ this -> addGroup ( $ item ) ; } return $ this ; }
1738	public function generate ( ) { if ( $ this -> singleSRC == '' ) { return '' ; } $ objFile = FilesModel :: findByUuid ( $ this -> singleSRC ) ; if ( $ objFile === null ) { return '' ; } $ allowedDownload = StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'allowedDownload' ) ) ) ; if ( ! \ in_array ( $ objFile -> extension , $ allowedDownload ) ) { return '' ; } $ file = Input :: get ( 'file' , true ) ; if ( $ file && ( ! isset ( $ _GET [ 'cid' ] ) || Input :: get ( 'cid' ) == $ this -> id ) ) { if ( $ file == $ objFile -> path ) { Controller :: sendFileToBrowser ( $ file , ( bool ) $ this -> inline ) ; } if ( isset ( $ _GET [ 'cid' ] ) ) { throw new PageNotFoundException ( 'Invalid file name' ) ; } } $ this -> objFile = $ objFile ; $ this -> singleSRC = $ objFile -> path ; return parent :: generate ( ) ; }
8711	public function whereOriginal ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { return parent :: where ( $ column , $ operator , $ value , $ boolean ) ; }
9286	public function create ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ CreateTable ( ) ; $ ddl -> setTable ( self :: TABLE_NAME ) -> addColumn ( new Column \ Integer ( 'id' , false , null , array ( 'autoincrement' => true ) ) ) -> addColumn ( new Column \ Varchar ( 'code' , 55 ) ) -> addColumn ( new Column \ Varchar ( 'status' , 55 ) ) -> addColumn ( new Column \ Text ( 'error_msg' ) ) -> addColumn ( new Column \ Text ( 'stack_trace' ) ) -> addColumn ( new Column \ Varchar ( 'created' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'scheduled' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'executed' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'finished' , 255 ) ) -> addConstraint ( new Constraint \ PrimaryKey ( 'id' ) ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
1418	public function failedValidatorException ( ValidatorContract $ validator , \ Closure $ closure = null ) : JsonApiException { return new ValidationException ( $ this -> failedValidator ( $ validator , $ closure ) ) ; }
3312	public function getCacheKey ( ) { if ( is_null ( $ this -> cacheKey ) ) { return $ this -> prefix . $ this -> appKey ; } return $ this -> cacheKey ; }
9849	public function createSignedResponse ( int $ status , string $ body , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { $ signature = \ ParagonIE_Sodium_Compat :: crypto_sign_detached ( $ body , $ key -> getString ( true ) ) ; if ( isset ( $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] ) ) { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] [ ] = Base64UrlSafe :: encode ( $ signature ) ; } else { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] = Base64UrlSafe :: encode ( $ signature ) ; } return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( $ body ) ) ; }
12494	public static function find ( $ id = null , $ connection ) { if ( gettype ( $ id ) != "string" && ! is_numeric ( $ id ) ) { throw new ClusterpointException ( "\"->find()\" function: \"_id\" is not in valid format." , 9002 ) ; } $ connection -> method = 'GET' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; $ connection -> multiple = false ; return self :: sendQuery ( $ connection ) ; }
12067	public function fetchProjects ( ) { $ response = $ this -> getResponse ( 'get' , 'v2/projects' ) ; $ projects = array ( ) ; if ( is_array ( $ response ) ) { foreach ( $ response as $ data ) { $ projects [ ] = $ this -> hydrator -> hydrate ( new Project ( ) , $ data ) ; } } return $ projects ; }
5612	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , true ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ current ) { $ current -> putChild ( $ node ) ; } else { echo 'no current node' ; } }
11222	private static function checkRoutes ( ) { $ method = $ _SERVER [ 'REQUEST_METHOD' ] ; $ route_pos = array_keys ( self :: $ routes , self :: $ uri , true ) ; foreach ( $ route_pos as $ route ) { $ methodRoute = self :: $ methods [ $ route ] ; if ( $ methodRoute == $ method || $ methodRoute == 'ANY' ) { if ( ! is_object ( $ callback = self :: $ callbacks [ $ route ] ) ) { self :: $ response = self :: invokeObject ( $ callback ) ; } else { self :: $ response = call_user_func ( $ callback ) ; } if ( ! self :: $ halts ) { return self :: $ response ; } self :: $ halts -- ; } } return self :: $ response ; }
9253	protected function getContainerInitializer ( ) { $ initializer = new DefaultInitializer ( $ this -> getConfigurationProvider ( ) ) ; if ( $ this -> cache ) { $ initializer = new CachedInitializer ( $ initializer , $ this -> getCacheDir ( ) ) ; } return $ initializer ; }
2912	public function formatNumber ( $ number , $ precision = 2 ) { $ locale = Mage :: app ( ) -> getLocale ( ) -> getLocale ( ) ; return Zend_Locale_Format :: toNumber ( $ number , array ( 'locale' => $ locale , 'precision' => $ precision ) ) ; }
2908	public function decodeSubject ( $ subject ) { if ( $ this -> hasQueue ( ) && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageParameters ( 'subject' ) ; } return base64_decode ( substr ( $ subject , strlen ( '=?utf-8?B?' ) , - 1 * strlen ( '?=' ) ) ) ; }
3037	public function set ( $ userId , $ callId , $ data ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ cache = $ this -> getFromCache ( $ key ) ; if ( is_null ( $ cache ) || $ cache != $ data ) { $ this -> putInCache ( $ key , $ userId , $ callId , $ data , self :: STATE_PENDING_WRITE ) ; } return true ; }
12434	private function shouldInterruptInfinityBonus ( $ percent , $ percentParent ) { $ result = false ; if ( ( $ percentParent > 0 ) && ( $ percentParent <= $ percent ) ) { $ result = true ; } return $ result ; }
5624	public function setCoordinates ( $ x = false , $ y = false ) { if ( ( $ x === false ) || ( $ y === false ) ) { $ this -> x = $ this -> y = false ; return ; } $ this -> x = ( integer ) $ x ; $ this -> y = ( integer ) $ y ; }
387	public function setAttributeOrders ( $ attributeOrders , $ validate = true ) { if ( $ attributeOrders === null || ! $ validate ) { $ this -> _attributeOrders = $ attributeOrders ; } else { $ this -> _attributeOrders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ order ) { if ( isset ( $ this -> attributes [ $ attribute ] ) ) { $ this -> _attributeOrders [ $ attribute ] = $ order ; if ( ! $ this -> enableMultiSort ) { break ; } } } } }
1558	protected function doesRequireOrdering ( $ query ) { if ( ! $ this -> primaryKey ) { return false ; } $ query = ( $ query instanceof Relation ) ? $ query -> getBaseQuery ( ) : $ query -> getQuery ( ) ; return ! collect ( $ query -> orders ? : [ ] ) -> contains ( function ( array $ order ) { $ col = $ order [ 'column' ] ?? '' ; return $ this -> primaryKey === $ col ; } ) ; }
3448	public function getAttribute ( $ key ) { if ( in_array ( $ key , $ this -> multipleHighloadBlockFields ) ) { return unserialize ( $ this -> attributes [ $ key ] ) ; } return parent :: getAttribute ( $ key ) ; }
12626	public function post ( $ url , $ data = array ( ) ) { $ client = $ this -> getClient ( ) ; return $ client -> request ( 'POST' , $ url , array ( 'form_params' => $ data ) ) ; }
3497	public function addDefaultVisitors ( ) : Http20Builder { if ( $ this -> addedDefaultVisitors ) { return $ this ; } $ this -> addedDefaultVisitors = true ; $ this -> addVisitor ( new AddExpirationHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddPriorityHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddApnIdHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddCollapseIdHeaderVisitor ( ) ) ; return $ this ; }
8758	public function tick ( $ status = Tick :: SUCCESS , $ msg = null , array $ extraInfo = [ ] , $ incrementBy = 1 ) { if ( ! $ this -> isRunning ( ) ) { $ this -> start ( ) ; } $ tick = new Tick ( $ this , $ status , $ msg , $ extraInfo , $ incrementBy ) ; if ( array_key_exists ( $ tick -> getStatus ( ) , $ this -> numProcessedItems ) ) { $ this -> numProcessedItems [ $ tick -> getStatus ( ) ] += $ tick -> getIncrementBy ( ) ; } else { $ this -> numProcessedItems [ $ tick -> getStatus ( ) ] = $ tick -> getIncrementBy ( ) ; } $ this -> dispatcher -> dispatch ( Events :: TRACKER_TICK , $ tick ) ; $ this -> lastTick = $ tick ; return $ tick -> getReport ( ) ; }
8228	protected function assertLimits ( ) { if ( $ this -> storage -> getUsersCount ( ) >= $ this -> config [ "maxUsers" ] ) { $ this -> session -> addFlash ( "error" , "New registrations are currently disabled." ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } }
5843	public function validateAdditionalFields ( array & $ submittedData , \ TYPO3 \ CMS \ Scheduler \ Controller \ SchedulerModuleController $ parentObject ) { $ result = true ; $ directories = GeneralUtility :: trimExplode ( LF , $ submittedData [ 'scheduler_batchResize_directories' ] , true ) ; foreach ( $ directories as $ directory ) { $ absoluteDirectory = GeneralUtility :: getFileAbsFileName ( $ directory ) ; if ( ! @ is_dir ( $ absoluteDirectory ) ) { $ result = false ; $ parentObject -> addMessage ( sprintf ( $ GLOBALS [ 'LANG' ] -> sL ( 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:msg.invalidDirectories' ) , $ directory ) , \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR ) ; } } $ directories = GeneralUtility :: trimExplode ( LF , $ submittedData [ 'scheduler_batchResize_excludeDirectories' ] , true ) ; foreach ( $ directories as $ directory ) { $ absoluteDirectory = GeneralUtility :: getFileAbsFileName ( $ directory ) ; if ( ! @ is_dir ( $ absoluteDirectory ) ) { $ result = false ; $ parentObject -> addMessage ( sprintf ( $ GLOBALS [ 'LANG' ] -> sL ( 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:msg.invalidExcludeDirectories' ) , $ directory ) , \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR ) ; } } return $ result ; }
10727	public function getYear ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'year' ] ; } }
9554	public function naming ( $ namer ) { if ( $ namer instanceof \ Closure ) { $ namer = new ClosureNamer ( $ namer ) ; } $ this -> namer = $ namer ; return $ this ; }
5633	public function collect ( & $ test , $ path ) { $ path = $ this -> removeTrailingSlash ( $ path ) ; if ( $ handle = opendir ( $ path ) ) { while ( ( $ entry = readdir ( $ handle ) ) !== false ) { if ( $ this -> isHidden ( $ entry ) ) { continue ; } $ this -> handle ( $ test , $ path . DIRECTORY_SEPARATOR . $ entry ) ; } closedir ( $ handle ) ; } }
1931	public function attachFileFromString ( $ strContent , $ strFilename , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( new \ Swift_Attachment ( $ strContent , $ strFilename , $ strMime ) ) ; }
3702	protected function getLegend ( $ name , $ palette , $ prevLegend = null ) { if ( strpos ( $ name , '+' ) === 0 ) { $ name = substr ( $ name , 1 ) ; } if ( ! $ palette -> hasLegend ( $ name ) ) { $ palette -> addLegend ( new Legend ( $ name ) , $ prevLegend ) ; } return $ palette -> getLegend ( $ name ) ; }
12263	public function renderCustomField ( array $ fields , $ classOrCustomField , $ documentType = 'html' , $ slug = null , $ showIfEmpty = true ) { $ customField = ( $ classOrCustomField instanceof CustomField ) ? $ classOrCustomField : $ this -> getCustomField ( $ classOrCustomField , $ slug ) ; $ slug = $ customField -> getSlug ( ) ; $ rawValue = ( isset ( $ fields [ $ slug ] ) ) ? $ fields [ $ slug ] : null ; $ customFieldType = $ this -> provider -> getCustomFieldByType ( $ customField -> getType ( ) ) ; return $ customFieldType -> render ( $ rawValue , $ customField , $ documentType ) ; }
3654	public function purge ( ) { foreach ( $ GLOBALS [ 'TL_PURGE' ] [ 'folders' ] [ 'metamodels_assets' ] [ 'affected' ] as $ folderName ) { $ folder = new \ Folder ( $ folderName ) ; $ folder -> purge ( ) ; } $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ dispatcher -> dispatch ( ContaoEvents :: SYSTEM_LOG , new LogEvent ( 'Purged the MetaModels assets' , __METHOD__ , TL_CRON ) ) ; }
12843	protected function addOptionShortcut ( $ name , $ description , $ default ) { $ this -> addOption ( $ name , null , InputOption :: VALUE_OPTIONAL , $ description , $ default ) ; return $ this ; }
7389	public function getResponse ( array $ packageList , array $ languageList , array $ customRouteList , string $ url = '' ) : Response { $ request = new Request ( $ languageList , $ packageList , $ url ) ; $ this -> packageRoot .= 'package/' . $ request -> package ( ) . '/' ; try { if ( isset ( $ customRouteList [ $ request -> package ( ) ] ) ) { $ path = $ this -> packageRoot . 'CustomRoute.php' ; if ( file_exists ( $ path ) ) { require $ path ; $ route = $ request -> package ( ) . '\\CustomRoute' ; $ route = new $ route ( ) ; $ this -> response = $ route -> getResponse ( $ this -> packageRoot , $ request ) ; if ( $ this -> response -> is404 ( ) ) { $ this -> set404 ( ) ; } return $ this -> response ; } else { throw new RouteException ( sprintf ( 'The file "%s" does not exist' , $ path ) ) ; } } else { $ this -> response = ( new DefaultRoute ( ) ) -> getResponse ( $ this -> packageRoot , $ request ) ; if ( $ this -> response -> is404 ( ) ) { $ this -> set404 ( ) ; } return $ this -> response ; } } catch ( RouteException $ e ) { if ( Wrap :: isEnabled ( ) ) { throw $ e ; } else { $ this -> response = new Response ( ) ; $ this -> set404 ( ) ; return $ this -> response ; } } }
3299	public function setHeaders ( array $ headers = [ ] ) { $ originHeaders = empty ( $ this -> headers ) ? [ ] : $ this -> headers ; $ this -> headers = array_merge ( $ originHeaders , $ headers ) ; return $ this ; }
7390	private function set404 ( ) { $ this -> response -> setStatusCode ( 404 ) ; $ content = '404 Not Found' ; if ( file_exists ( $ this -> packageRoot . '/view/404.html.php' ) ) { $ content = ( new Native ( $ this -> packageRoot ) ) -> getContent ( '404.html.php' ) ; } $ this -> response -> setContent ( $ content ) ; }
9382	public function getTag ( $ classNames , $ color = null ) { return ArrayData :: create ( [ 'ClassNames' => $ classNames , 'Color' => $ color ] ) -> renderWith ( sprintf ( '%s\Tag' , self :: class ) ) ; }
1034	private function completeListValue ( ListOfType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ itemType = $ returnType -> getWrappedType ( ) ; Utils :: invariant ( is_array ( $ result ) || $ result instanceof Traversable , 'User Error: expected iterable, but did not find one for field ' . $ info -> parentType . '.' . $ info -> fieldName . '.' ) ; $ containsPromise = false ; $ i = 0 ; $ completedItems = [ ] ; foreach ( $ result as $ item ) { $ fieldPath = $ path ; $ fieldPath [ ] = $ i ++ ; $ completedItem = $ this -> completeValueCatchingError ( $ itemType , $ fieldNodes , $ info , $ fieldPath , $ item ) ; if ( ! $ containsPromise && $ this -> getPromise ( $ completedItem ) ) { $ containsPromise = true ; } $ completedItems [ ] = $ completedItem ; } return $ containsPromise ? $ this -> exeContext -> promises -> all ( $ completedItems ) : $ completedItems ; }
2288	public static function findUnactivatedByEmail ( $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE email=? AND disable='1' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn>? AND o.confirmedOn=0)" ) -> limit ( 1 ) -> execute ( $ strEmail , strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objMember = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { return $ objMember ; } return new static ( $ objResult ) ; }
12642	public function set ( $ key , $ value ) { if ( ! is_string ( $ key ) ) throw new InvalidArgumentException ( 'First parameter has to be a string' ) ; if ( ! $ this -> isTypeSupported ( gettype ( $ value ) ) ) throw new UnsupportedException ( 'First parameter has to be an int, a double, a bool or a string' ) ; try { $ this -> getRecursive ( $ key , $ this -> data ) ; $ this -> data = $ this -> setRecursive ( $ key , $ value ) ; } catch ( ElementNotFoundException $ e ) { $ this -> data = array_merge_recursive ( $ this -> data , $ this -> setRecursive ( $ key , $ value ) ) ; } }
10175	public function getHighestColumn ( $ row = null ) { if ( $ row == null ) { $ colRow = $ this -> getHighestRowAndColumn ( ) ; return $ colRow [ 'column' ] ; } $ columnList = [ 1 ] ; foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ r != $ row ) { continue ; } $ columnList [ ] = Coordinate :: columnIndexFromString ( $ c ) ; } return Coordinate :: stringFromColumnIndex ( max ( $ columnList ) + 1 ) ; }
12191	protected function buildMessage ( ) { $ className = $ this -> getClassName ( ) ; $ methodName = $ this -> getMethodName ( ) ; $ functionName = $ this -> getFunctionName ( ) ; if ( $ className !== null && $ methodName !== null ) { $ callable = $ className . '::' . $ methodName ; ; } else { $ callable = $ functionName ; } $ this -> message = s ( 'Container could not resolve argument %s for %s.' , $ this -> getArgumentIndex ( ) , $ callable ) ; }
7510	function addError ( $ error ) { $ this -> errors [ ] = htmlentities ( $ error . ' at ' . ( $ this -> line_pos [ 0 ] + 1 ) . ', ' . ( $ this -> pos - $ this -> line_pos [ 1 ] + 1 ) . '!' ) ; }
2465	public function checkPermission ( ) { $ bundles = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( ! isset ( $ bundles [ 'ContaoCommentsBundle' ] ) ) { $ key = array_search ( 'allowComments' , $ GLOBALS [ 'TL_DCA' ] [ 'tl_faq' ] [ 'list' ] [ 'sorting' ] [ 'headerFields' ] ) ; unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_faq' ] [ 'list' ] [ 'sorting' ] [ 'headerFields' ] [ $ key ] ) ; } }
4327	public static function isList ( $ val ) { if ( ! \ is_array ( $ val ) ) { return false ; } $ keys = \ array_keys ( $ val ) ; foreach ( $ keys as $ i => $ key ) { if ( $ i != $ key ) { return false ; } } return true ; }
642	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
9118	private function getViewBestMatch ( Request $ request , $ applicationName ) { $ best = null ; if ( count ( $ this -> views [ $ applicationName ] ) > 0 ) { foreach ( $ this -> views [ $ applicationName ] as $ orderLevel => $ views ) { foreach ( $ views as $ view ) { assert ( $ view instanceof View ) ; if ( $ view -> matchBoth ( $ request -> getController ( ) , $ request -> getAction ( ) ) ) { $ best [ $ orderLevel ] = $ view ; continue 2 ; } } } } if ( null == $ best ) { throw new ViewException ( "No view found for request" ) ; } if ( count ( $ best ) > 1 ) { krsort ( $ best ) ; } return reset ( $ best ) ; }
11383	protected function build ( $ stage ) { if ( $ stage instanceof MiddlewareInterface ) { return $ stage ; } if ( $ this -> container -> has ( $ stage ) ) { $ stage = $ this -> container -> get ( $ stage ) ; if ( $ stage instanceof RequestHandlerInterface ) { return new RequestHandler ( $ stage ) ; } if ( $ stage instanceof MiddlewareInterface ) { return $ stage ; } throw new \ RuntimeException ( "Stage is not a valid " . MiddlewareInterface :: class ) ; } if ( method_exists ( $ this -> container , 'newInstance' ) ) { return $ this -> container -> newInstance ( $ stage ) ; } throw new \ RuntimeException ( "Unable to resolve $stage" ) ; }
408	public function get ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getQueryParams ( ) ; } return $ this -> getQueryParam ( $ name , $ defaultValue ) ; }
11539	public function add ( $ sourceDir , array $ options , $ username ) { $ this -> resolveAddOptions ( $ options ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ this -> addBlockToSlot ( $ dir , $ options ) ; $ blockContent = $ this -> addBlock ( $ dir , $ options , $ blockName ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been added to the "%s" slot on page "%s" for the "%s_%s" language' , $ blockName , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; return $ blockContent ; }
6097	protected function get ( $ endpoint , array $ parameters = [ ] , CachePolicy $ cachePolicy = null , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_GET , $ cachePolicy , $ fireAndForget ) ; }
4395	public function isImplemented ( $ what ) { $ provider = $ this -> getProvider ( ) ; switch ( $ what ) { case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_CAPTURE : return $ provider -> supportsCapture ( ) ; case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_CANCEL : return $ provider -> supportsVoid ( ) ; case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_REFUND : return $ provider -> supportsRefund ( ) ; case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_REPAY : return method_exists ( $ provider , 'createCard' ) ; } return false ; }
71	protected function filterPackageMap ( array $ packageMap , PackageInterface $ mainPackage ) { $ packages = array ( ) ; $ include = array ( ) ; foreach ( $ packageMap as $ item ) { $ package = $ item [ 0 ] ; $ name = $ package -> getName ( ) ; $ packages [ $ name ] = $ package ; } $ add = function ( PackageInterface $ package ) use ( & $ add , $ packages , & $ include ) { foreach ( $ package -> getRequires ( ) as $ link ) { $ target = $ link -> getTarget ( ) ; if ( ! isset ( $ include [ $ target ] ) ) { $ include [ $ target ] = true ; if ( isset ( $ packages [ $ target ] ) ) { $ add ( $ packages [ $ target ] ) ; } } } } ; $ add ( $ mainPackage ) ; return array_filter ( $ packageMap , function ( $ item ) use ( $ include ) { $ package = $ item [ 0 ] ; foreach ( $ package -> getNames ( ) as $ name ) { if ( isset ( $ include [ $ name ] ) ) { return true ; } } return false ; } ) ; }
12739	public function removeClass ( $ name ) { $ classParts = explode ( ' ' , $ this -> tags [ 'class' ] ) ; $ className = '' ; foreach ( $ classParts as $ part ) { if ( $ name != $ part ) { $ className .= ' ' . $ part ; } } $ this -> tags [ 'class' ] = trim ( $ className ) ; }
3229	public static function q ( $ string ) { $ special_escape_out = self :: SPECIAL_ESCAPE_OUT ; $ r = "\"" ; $ len = \ strlen ( $ string ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ c = $ string [ $ i ] ; $ escape_i = \ strpos ( self :: SPECIAL_ESCAPE_IN , $ c ) ; if ( $ escape_i !== false ) { $ r .= "\\" ; $ r .= $ special_escape_out [ $ escape_i ] ; } else if ( $ c >= "\x20" and $ c <= "\x7e" ) { $ r .= $ c ; } else { $ r .= "\\x" ; $ r .= \ bin2hex ( $ c ) ; } } $ r .= "\"" ; return $ r ; }
1599	protected function authenticate ( ) { if ( empty ( $ this -> guards ) && Auth :: check ( ) ) { return ; } foreach ( $ this -> guards as $ guard ) { if ( Auth :: guard ( $ guard ) -> check ( ) ) { Auth :: shouldUse ( $ guard ) ; return ; } } throw new AuthenticationException ( 'Unauthenticated.' , $ this -> guards ) ; }
4688	public function andWhere ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ this -> where ? '(' . $ this -> where . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'where' , $ args ) ; return $ this ; }
8804	public function getFlash ( $ key = null ) { if ( ! is_null ( $ key ) ) { $ value = null ; if ( $ this -> hasFlash ( $ key ) ) { $ value = $ this -> get ( '_nur_flash' ) [ $ key ] ; unset ( $ _SESSION [ '_nur_flash' ] [ $ key ] ) ; } return $ value ; } return $ key ; }
157	public function where ( $ condition , $ params = [ ] ) { $ this -> where = $ condition ; $ this -> addParams ( $ params ) ; return $ this ; }
9038	protected function execute ( QueryBuilder $ builder ) : ? Result { return $ this -> connection -> queryArgs ( $ builder -> getQuerySql ( ) , $ builder -> getQueryParameters ( ) ) ; }
12906	public function show ( $ id , FilterRequest $ request ) { $ id = $ this -> getRealId ( $ id ) ; $ request -> criteria [ ] = 'id,=,' . $ id ; $ resource = $ this -> repository -> filter ( $ request ) -> first ( ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
9535	private function parseVariadicParameter ( & $ i , & $ results , $ closure , & $ closure_arguments , $ prefix , $ parameter ) { $ i ++ ; while ( isset ( $ this -> argv [ $ i ] ) && ( $ argument = $ this -> argv [ $ i ] ) != null && ! $ this -> prefixExists ( $ argument ) ) { $ closure_arguments [ ] = $ argument ; $ i ++ ; } $ parameterClosure = $ this -> getParameterClosure ( $ parameter ) ; if ( $ parameterClosure -> parent != null ) { if ( count ( $ closure_arguments ) > 0 ) { $ results [ $ parameterClosure -> parent -> parameterName ] = $ closure ( ... $ closure_arguments ) ; } else { $ this -> valid = false ; if ( $ this -> errorHandler != null ) { $ this -> errorHandler -> call ( $ this , $ parameterClosure , 'Missing argument for parameter closure.' ) ; } } } else { if ( count ( $ closure_arguments ) > 0 ) { $ results [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] = $ closure ( ... $ closure_arguments ) ; } else { $ this -> valid = false ; if ( $ this -> errorHandler != null ) { $ this -> errorHandler -> call ( $ this , $ parameterClosure , 'Missing argument for parameter closure.' ) ; } } } }
9982	private function writeVMLComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ pCellReference ) ; $ column = Coordinate :: columnIndexFromString ( $ column ) ; $ id = 1024 + $ column + $ row ; $ id = substr ( $ id , 0 , 4 ) ; $ objWriter -> startElement ( 'v:shape' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_s' . $ id ) ; $ objWriter -> writeAttribute ( 'type' , '#_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'style' , 'position:absolute;margin-left:' . $ pComment -> getMarginLeft ( ) . ';margin-top:' . $ pComment -> getMarginTop ( ) . ';width:' . $ pComment -> getWidth ( ) . ';height:' . $ pComment -> getHeight ( ) . ';z-index:1;visibility:' . ( $ pComment -> getVisible ( ) ? 'visible' : 'hidden' ) ) ; $ objWriter -> writeAttribute ( 'fillcolor' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> writeAttribute ( 'o:insetmode' , 'auto' ) ; $ objWriter -> startElement ( 'v:fill' ) ; $ objWriter -> writeAttribute ( 'color2' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shadow' ) ; $ objWriter -> writeAttribute ( 'on' , 't' ) ; $ objWriter -> writeAttribute ( 'color' , 'black' ) ; $ objWriter -> writeAttribute ( 'obscured' , 't' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'none' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:textbox' ) ; $ objWriter -> writeAttribute ( 'style' , 'mso-direction-alt:auto' ) ; $ objWriter -> startElement ( 'div' ) ; $ objWriter -> writeAttribute ( 'style' , 'text-align:left' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'x:ClientData' ) ; $ objWriter -> writeAttribute ( 'ObjectType' , 'Note' ) ; $ objWriter -> writeElement ( 'x:MoveWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:SizeWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:AutoFill' , 'False' ) ; $ objWriter -> writeElement ( 'x:Row' , ( $ row - 1 ) ) ; $ objWriter -> writeElement ( 'x:Column' , ( $ column - 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
1770	public function getErrorsAsString ( $ strSeparator = null ) { if ( $ strSeparator === null ) { $ strSeparator = '<br' . $ this -> strTagEnding . "\n" ; } return $ this -> hasErrors ( ) ? implode ( $ strSeparator , $ this -> arrErrors ) : '' ; }
248	public function destroy ( ) { if ( $ this -> getIsActive ( ) ) { $ sessionId = session_id ( ) ; $ this -> close ( ) ; $ this -> setId ( $ sessionId ) ; $ this -> open ( ) ; session_unset ( ) ; session_destroy ( ) ; $ this -> setId ( $ sessionId ) ; } }
8425	public function getAllActiveQuery ( Production $ production ) : Query { $ qb = $ this -> createQueryBuilder ( 'p' ) ; return $ qb -> join ( 'p.groups' , 'g' ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'g' , ':group' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.active' , ':active' ) ) -> andWhere ( $ qb -> expr ( ) -> isNull ( 'p.parent' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isNull ( 'p.expiry' ) , $ qb -> expr ( ) -> gt ( 'p.expiry' , ':now' ) ) ) -> setParameter ( 'group' , $ production ) -> setParameter ( 'active' , true ) -> setParameter ( 'now' , new \ DateTime ( ) ) -> orderBy ( 'p.pinned' , 'DESC' ) -> addOrderBy ( 'p.created' , 'DESC' ) -> getQuery ( ) ; }
11347	public function renderField ( $ name ) { $ html = '' ; $ field = $ this -> getField ( $ name ) ; $ html .= $ this -> formatter -> renderField ( $ field ) ; return $ html ; }
10987	public static function D ( $ value , $ options = array ( ) ) { if ( is_numeric ( $ options ) ) { $ options = array ( 'depth' => $ options ) ; } elseif ( empty ( $ options ) ) { $ options = array ( ) ; } $ plop = new Dumpling ( $ options ) ; return $ plop -> dump ( $ value ) ; }
10240	public function calculateCellValue ( Cell $ pCell = null , $ resetLog = true ) { if ( $ pCell === null ) { return null ; } $ returnArrayAsType = self :: $ returnArrayAsType ; if ( $ resetLog ) { $ this -> formulaError = null ; $ this -> debugLog -> clearLog ( ) ; $ this -> cyclicReferenceStack -> clear ( ) ; $ this -> cyclicFormulaCounter = 1 ; self :: $ returnArrayAsType = self :: RETURN_ARRAY_AS_ARRAY ; } $ this -> cellStack [ ] = [ 'sheet' => $ pCell -> getWorksheet ( ) -> getTitle ( ) , 'cell' => $ pCell -> getCoordinate ( ) , ] ; try { $ result = self :: unwrapResult ( $ this -> _calculateFormulaValue ( $ pCell -> getValue ( ) , $ pCell -> getCoordinate ( ) , $ pCell ) ) ; $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; } catch ( \ Exception $ e ) { $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; throw new Exception ( $ e -> getMessage ( ) ) ; } if ( ( is_array ( $ result ) ) && ( self :: $ returnArrayAsType != self :: RETURN_ARRAY_AS_ARRAY ) ) { self :: $ returnArrayAsType = $ returnArrayAsType ; $ testResult = Functions :: flattenArray ( $ result ) ; if ( self :: $ returnArrayAsType == self :: RETURN_ARRAY_AS_ERROR ) { return Functions :: VALUE ( ) ; } if ( count ( $ testResult ) != 1 ) { $ r = array_keys ( $ result ) ; $ r = array_shift ( $ r ) ; if ( ! is_numeric ( $ r ) ) { return Functions :: VALUE ( ) ; } if ( is_array ( $ result [ $ r ] ) ) { $ c = array_keys ( $ result [ $ r ] ) ; $ c = array_shift ( $ c ) ; if ( ! is_numeric ( $ c ) ) { return Functions :: VALUE ( ) ; } } } $ result = array_shift ( $ testResult ) ; } self :: $ returnArrayAsType = $ returnArrayAsType ; if ( $ result === null ) { return 0 ; } elseif ( ( is_float ( $ result ) ) && ( ( is_nan ( $ result ) ) || ( is_infinite ( $ result ) ) ) ) { return Functions :: NAN ( ) ; } return $ result ; }
12382	public static function lastMonth ( ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subMonth ( ) -> firstOfMonth ( ) , Carbon :: now ( ) -> subMonth ( ) -> lastOfMonth ( ) ) ; return $ hits_count ; }
5060	public static function fromURI ( $ URI ) { $ regex = '/^(([^-]|--)+)-(([^-]|--)+)-(([^-]|--)+)\.(svg|png|gif|jpg)$/' ; $ match = array ( ) ; if ( 1 != preg_match ( $ regex , $ URI , $ match ) && ( 7 != count ( $ match ) ) ) { throw new \ InvalidArgumentException ( 'The URI given is not a valid URI' . $ URI ) ; } $ subject = $ match [ 1 ] ; $ status = $ match [ 3 ] ; $ color = $ match [ 5 ] ; $ format = $ match [ 7 ] ; return new self ( $ subject , $ status , $ color , $ format ) ; }
9274	public function getServiceConfig ( ) { return array ( 'factories' => array ( 'CronHelper\Service\CronService' => function ( $ serviceManager ) { $ mainConfig = $ serviceManager -> get ( 'config' ) ; $ serviceConfig = array ( ) ; if ( is_array ( $ mainConfig ) ) { if ( array_key_exists ( 'cron_helper' , $ mainConfig ) ) { $ serviceConfig = $ mainConfig [ 'cron_helper' ] ; } } $ cronService = new CronService ( $ serviceConfig ) ; return $ cronService ; } , ) , ) ; }
11652	protected function _initRestRoute ( ) { $ front = Zend_Controller_Front :: getInstance ( ) ; $ front -> setResponse ( new Benri_Controller_Response_Http ( ) ) ; $ front -> setRequest ( new Benri_Controller_Request_Http ( ) ) ; $ front -> getRouter ( ) -> addRoute ( 'benri-app' , new Zend_Rest_Route ( $ front ) ) ; }
5259	public static function all ( $ query = [ ] ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ collection = collect ( ) ; static :: map ( $ query , function ( ElasticsearchModel $ document ) use ( $ collection ) { $ collection -> put ( $ document -> getId ( ) , $ document ) ; } ) ; return $ collection ; }
5801	protected function getDeleteCell ( bool $ showDeleteLink , ? string $ primaryKeyValue ) : string { if ( $ showDeleteLink && $ this -> deleteRoute == null ) { throw new \ Exception ( "Must have deleteRoute" ) ; } if ( $ showDeleteLink && $ primaryKeyValue === null ) { throw new \ Exception ( "Must have primaryKeyValue to delete" ) ; } $ cellValue = ( $ showDeleteLink ) ? '<a href="' . $ this -> router -> pathFor ( $ this -> deleteRoute , [ "primaryKey" => $ primaryKeyValue ] ) . '" title="delete" onclick="return confirm(\'Are you sure you want to delete ' . $ primaryKeyValue . '?\');">X</a>' : '&nbsp;' ; return '<td>' . $ cellValue . '</td>' ; }
8641	public function setShipmentItemAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentItemAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10596	protected function initViewPanelTableRow ( \ MvcCore \ IRoute & $ route , $ matched ) { $ route -> InitAll ( ) ; $ row = new \ stdClass ; $ row -> matched = $ matched ; $ row -> method = $ route -> GetMethod ( ) ; $ row -> method = $ row -> method === NULL ? '*' : $ row -> method ; $ row -> className = htmlSpecialChars ( '\\' . get_class ( $ route ) , ENT_QUOTES , 'UTF-8' ) ; $ routeMatch = $ this -> getRouteLocalizedRecord ( $ route , 'GetMatch' ) ; $ routeMatch = rtrim ( $ routeMatch , 'imsxeADSUXJu' ) ; $ routeReverse = $ this -> getRouteLocalizedRecord ( $ route , 'GetReverse' ) ; $ routeDefaults = $ this -> getRouteLocalizedRecord ( $ route , 'GetDefaults' ) ; $ row -> match = $ this -> completeFormatedPatternCharGroups ( $ routeMatch , [ '(' , ')' ] ) ; if ( $ routeReverse !== NULL ) { $ row -> reverse = $ this -> completeFormatedPatternCharGroups ( $ routeReverse , [ '<' , '>' ] ) ; } else { $ row -> reverse = NULL ; } $ row -> routeName = $ route -> GetName ( ) ; $ row -> ctrlActionName = $ route -> GetControllerAction ( ) ; if ( $ row -> ctrlActionName !== ':' ) { $ row -> ctrlActionLink = $ this -> completeCtrlActionLink ( $ route -> GetController ( ) , $ route -> GetAction ( ) ) ; } else { $ row -> ctrlActionName = NULL ; $ row -> ctrlActionLink = NULL ; } $ routeReverseParams = $ route -> GetReverseParams ( ) ? : [ ] ; $ paramsKeys = array_unique ( array_merge ( $ routeReverseParams , array_keys ( $ routeDefaults ) ) ) ; $ row -> defaults = $ this -> completeParams ( $ route , $ paramsKeys , TRUE ) ; $ row -> params = [ ] ; if ( $ matched ) { $ paramsAndReqestParams = array_merge ( $ routeDefaults , $ this -> requestParams ) ; $ row -> params = $ this -> completeParams ( $ route , array_keys ( $ paramsAndReqestParams ) , FALSE ) ; } return $ row ; }
4916	public function setValue ( $ value ) { if ( ! $ value ) { if ( ! $ this -> getName ( ) ) { throw new \ InvalidArgumentException ( 'Value must not be empty.' ) ; } $ value = self :: filterValue ( $ this -> getName ( ) ) ; } $ this -> value = ( string ) $ value ; return $ this ; }
8052	public function getAllEventsAsJson ( ) { $ cache = $ this -> cache ; if ( $ cache :: has ( self :: ALL_EVENTS_TO_JSON_KEY ) ) { return $ cache :: get ( self :: ALL_EVENTS_TO_JSON_KEY ) ; } $ allEvents = $ this -> calendarEventsEngine -> formatEventsToJson ( $ this -> getAllEvents ( ) ) ; $ allEventsToJson = json_encode ( $ allEvents ) ; $ cache :: put ( self :: ALL_EVENTS_TO_JSON_KEY , $ allEventsToJson , $ this -> cacheTimeToLive ) ; return $ allEventsToJson ; }
7718	function meth_Conv_Prepare ( & $ Loc , $ StrConv ) { $ x = strtolower ( $ StrConv ) ; $ x = '+' . str_replace ( ' ' , '' , $ x ) . '+' ; if ( strpos ( $ x , '+esc+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvEsc = true ; } if ( strpos ( $ x , '+wsp+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvWS = true ; } if ( strpos ( $ x , '+js+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvJS = true ; } if ( strpos ( $ x , '+url+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUrl = true ; } if ( strpos ( $ x , '+utf8+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUtf8 = true ; } if ( strpos ( $ x , '+no+' ) !== false ) $ Loc -> ConvStr = false ; if ( strpos ( $ x , '+yes+' ) !== false ) $ Loc -> ConvStr = true ; if ( strpos ( $ x , '+nobr+' ) !== false ) { $ Loc -> ConvStr = true ; $ Loc -> ConvBr = false ; } }
2143	public function generate ( $ objRootPage = null ) { global $ objPage ; $ obj403 = $ this -> prepare ( $ objRootPage ) ; $ objPage = $ obj403 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 403 Forbidden' ) ; $ objHandler -> generate ( $ objPage ) ; }
2760	public function fetchBranches ( bool $ onlyRemote = false ) : array { $ options = $ onlyRemote ? [ 'r' => true ] : [ 'a' => true ] ; $ output = $ this -> gitWorkingCopy -> branch ( $ options ) ; $ branches = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimBranch' ] , $ branches ) ; }
9233	public function actionCreate ( ) { $ model = new Post ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> author_id = Yii :: $ app -> user -> id ; $ model -> isdel = 0 ; if ( Yii :: $ app -> request -> post ( ) ) { $ post = Yii :: $ app -> request -> post ( ) ; $ category = [ ] ; if ( isset ( $ post [ 'Post' ] [ 'category' ] ) ) { $ category = $ post [ 'Post' ] [ 'category' ] ; } if ( is_array ( $ post [ 'Post' ] [ 'tags' ] ) ) { $ post [ 'Post' ] [ 'tags' ] = implode ( "," , $ post [ 'Post' ] [ 'tags' ] ) ; } $ model -> load ( $ post ) ; $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> save ( ) ) { $ cs = BlogCatPos :: deleteAll ( "post_id = :id" , [ "id" => $ model -> id ] ) ; foreach ( $ category as $ d ) { $ c = new BlogCatPos ( ) ; $ c -> post_id = $ model -> id ; $ c -> category_id = $ d ; $ c -> isdel = 0 ; $ c -> save ( ) ; } $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ model -> id = array_merge ( $ category , [ ] ) ; $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } } return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; }
2851	public function searchConfig ( $ query ) { $ configArray = array ( ) ; $ configArray = Mage :: helper ( 'sheep_debug' ) -> xml2array ( $ this -> getConfig ( ) -> getNode ( ) , $ configArray ) ; $ results = array ( ) ; $ configKeys = array_keys ( $ configArray ) ; foreach ( $ configKeys as $ configKey ) { if ( strpos ( $ configKey , $ query ) !== FALSE ) { $ results [ $ configKey ] = $ configArray [ $ configKey ] ; } } return $ results ; }
12255	public function removeCompiler ( $ compiler ) { if ( ( $ idx = array_search ( $ compiler , $ this -> compilers ) ) !== false ) { unset ( $ this -> compilers [ $ idx ] ) ; $ this -> orderedCompilers = NULL ; } }
7453	protected function renderLTR ( ) : string { $ trail = '' ; if ( $ this -> before ) { $ trail .= '<span class="before">' . $ this -> before . '</span> ' ; } $ trail .= \ join ( ' <span class="sep delimiter">' . $ this -> delimiter . '</span> ' , $ this -> links ) ; if ( $ this -> after ) { $ trail .= ' <span class="after">' . $ this -> after . '</span>' ; } return $ trail ; }
4572	public function setIdentityUuid ( ? string $ identityUuid ) { if ( null !== $ identityUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ identityUuid ) ) { throw new InvalidArgumentException ( 'Identity uuid is not valid.' ) ; } } $ this -> identityUuid = $ identityUuid ; return $ this ; }
739	protected function saveAssignments ( ) { $ assignmentData = [ ] ; foreach ( $ this -> assignments as $ userId => $ assignments ) { foreach ( $ assignments as $ name => $ assignment ) { $ assignmentData [ $ userId ] [ ] = $ assignment -> roleName ; } } $ this -> saveToFile ( $ assignmentData , $ this -> assignmentFile ) ; }
786	public function scenarios ( ) { $ scenarios = [ self :: SCENARIO_DEFAULT => [ ] ] ; foreach ( $ this -> getValidators ( ) as $ validator ) { foreach ( $ validator -> on as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } foreach ( $ validator -> except as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } } $ names = array_keys ( $ scenarios ) ; foreach ( $ this -> getValidators ( ) as $ validator ) { if ( empty ( $ validator -> on ) && empty ( $ validator -> except ) ) { foreach ( $ names as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } elseif ( empty ( $ validator -> on ) ) { foreach ( $ names as $ name ) { if ( ! in_array ( $ name , $ validator -> except , true ) ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } else { foreach ( $ validator -> on as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } foreach ( $ scenarios as $ scenario => $ attributes ) { if ( ! empty ( $ attributes ) ) { $ scenarios [ $ scenario ] = array_keys ( $ attributes ) ; } } return $ scenarios ; }
8554	public function setLoanServicingEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LoanServicingEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1615	public function readSession ( $ id ) { $ data = $ this -> redis -> executeCommand ( 'GET' , [ $ this -> calculateKey ( $ id ) ] ) ; return $ data === false || $ data === null ? '' : $ data ; }
6235	public function mkdir ( ) : self { if ( ! $ this -> storage -> isDir ( ) ) { if ( ! $ this -> storage -> mkdir ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to create directory at: "%s"' , $ this -> storage -> path ( ) -> raw ) , 500 ) ; } } return $ this ; }
5349	public function installOperatingSystemUnattended ( $ vpsName , $ operatingSystemName , $ base64InstallText ) { return $ this -> call ( self :: SERVICE , 'installOperatingSystemUnattended' , [ $ vpsName , $ operatingSystemName , $ base64InstallText ] ) ; }
7516	protected function expect ( $ token , $ do_next = true , $ try_next = false , $ next_on_match = 1 ) { if ( $ do_next ) { if ( $ do_next === 1 ) { $ this -> next ( ) ; } else { $ this -> next_no_whitespace ( ) ; } } if ( is_int ( $ token ) ) { if ( ( $ this -> token !== $ token ) && ( ( ! $ try_next ) || ( ( ( $ try_next === 1 ) && ( $ this -> next ( ) !== $ token ) ) || ( ( $ try_next === true ) && ( $ this -> next_no_whitespace ( ) !== $ token ) ) ) ) ) { $ this -> addError ( 'Unexpected "' . $ this -> getTokenString ( ) . '"' ) ; return false ; } } else { if ( ( $ this -> doc [ $ this -> pos ] !== $ token ) && ( ( ! $ try_next ) || ( ( ( ( $ try_next === 1 ) && ( $ this -> next ( ) !== self :: TOK_NULL ) ) || ( ( $ try_next === true ) && ( $ this -> next_no_whitespace ( ) !== self :: TOK_NULL ) ) ) && ( $ this -> doc [ $ this -> pos ] !== $ token ) ) ) ) { $ this -> addError ( 'Expected "' . $ token . '", but found "' . $ this -> getTokenString ( ) . '"' ) ; return false ; } } if ( $ next_on_match ) { if ( $ next_on_match === 1 ) { $ this -> next ( ) ; } else { $ this -> next_no_whitespace ( ) ; } } return true ; }
1065	private function findConflict ( ValidationContext $ context , $ parentFieldsAreMutuallyExclusive , $ responseName , array $ field1 , array $ field2 ) { [ $ parentType1 , $ ast1 , $ def1 ] = $ field1 ; [ $ parentType2 , $ ast2 , $ def2 ] = $ field2 ; $ areMutuallyExclusive = $ parentFieldsAreMutuallyExclusive || ( $ parentType1 !== $ parentType2 && $ parentType1 instanceof ObjectType && $ parentType2 instanceof ObjectType ) ; $ type1 = $ def1 === null ? null : $ def1 -> getType ( ) ; $ type2 = $ def2 === null ? null : $ def2 -> getType ( ) ; if ( ! $ areMutuallyExclusive ) { $ name1 = $ ast1 -> name -> value ; $ name2 = $ ast2 -> name -> value ; if ( $ name1 !== $ name2 ) { return [ [ $ responseName , sprintf ( '%s and %s are different fields' , $ name1 , $ name2 ) ] , [ $ ast1 ] , [ $ ast2 ] , ] ; } if ( ! $ this -> sameArguments ( $ ast1 -> arguments ? : [ ] , $ ast2 -> arguments ? : [ ] ) ) { return [ [ $ responseName , 'they have differing arguments' ] , [ $ ast1 ] , [ $ ast2 ] , ] ; } } if ( $ type1 && $ type2 && $ this -> doTypesConflict ( $ type1 , $ type2 ) ) { return [ [ $ responseName , sprintf ( 'they return conflicting types %s and %s' , $ type1 , $ type2 ) ] , [ $ ast1 ] , [ $ ast2 ] , ] ; } $ selectionSet1 = $ ast1 -> selectionSet ; $ selectionSet2 = $ ast2 -> selectionSet ; if ( $ selectionSet1 && $ selectionSet2 ) { $ conflicts = $ this -> findConflictsBetweenSubSelectionSets ( $ context , $ areMutuallyExclusive , Type :: getNamedType ( $ type1 ) , $ selectionSet1 , Type :: getNamedType ( $ type2 ) , $ selectionSet2 ) ; return $ this -> subfieldConflicts ( $ conflicts , $ responseName , $ ast1 , $ ast2 ) ; } return null ; }
8528	public function listFinancialEventGroupsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroupsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12384	public static function perDay ( $ days = 1 , $ date_format = "m-d" ) { $ hits_per_day = [ ] ; for ( $ i = 1 ; $ i <= $ days ; $ i ++ ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subDays ( $ i ) , Carbon :: now ( ) -> subDays ( $ i - 1 ) ) ; $ hits_per_day [ Carbon :: now ( ) -> subDays ( $ i ) -> format ( $ date_format ) ] = $ hits_count ; } return $ hits_per_day ; }
3935	private function setSearchable ( PropertyInterface $ property , $ propInfo ) { if ( ! isset ( $ propInfo [ 'search' ] ) ) { return ; } $ property -> setSearchable ( ( bool ) $ propInfo [ 'search' ] ) ; }
7456	private function ensureDirectoryExists ( $ path ) { if ( ! is_dir ( $ path ) ) { if ( ! mkdir ( $ path , 0777 , true ) ) { throw new \ RuntimeException ( sprintf ( 'Could not create directory "%s"' , $ path ) ) ; } } return $ path ; }
5579	public function clickImageById ( $ id , $ x = 1 , $ y = 1 , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormByImage ( new SelectById ( $ id ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitImage ( new SelectById ( $ id ) , $ x , $ y , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
9607	public function projectOnto ( self $ b ) { $ bUnit = $ b -> normalize ( ) ; return $ bUnit -> multiplyByScalar ( $ this -> dotProduct ( $ bUnit ) ) ; }
1340	public function exists ( ResourceIdentifierInterface $ identifier ) { $ record = $ this -> lookup ( $ identifier ) ; return is_object ( $ record ) ? true : $ record ; }
7116	public function watch ( Repository \ PaymentRepositoryInterface $ paymentRepository ) { if ( null === $ term = $ this -> termRepository -> findLongest ( ) ) { return false ; } $ today = new \ DateTime ( ) ; $ today -> setTime ( 0 , 0 , 0 ) ; $ fromDate = clone $ today ; $ fromDate -> modify ( '-1 year' ) ; $ states = [ Model \ PaymentStates :: STATE_AUTHORIZED , Model \ PaymentStates :: STATE_CAPTURED ] ; $ method = $ this -> methodRepository -> findOneBy ( [ 'factoryName' => Constants :: FACTORY_NAME , ] ) ; if ( ! $ method || ! $ method -> isOutstanding ( ) ) { return false ; } $ result = false ; $ payments = $ paymentRepository -> findByMethodAndStates ( $ method , $ states , $ fromDate ) ; foreach ( $ payments as $ payment ) { $ sale = $ payment -> getSale ( ) ; if ( null === $ date = $ sale -> getOutstandingDate ( ) ) { continue ; } $ diff = $ date -> diff ( $ today ) ; if ( 0 < $ diff -> days && ! $ diff -> invert ) { $ payment -> setState ( Model \ PaymentStates :: STATE_EXPIRED ) ; $ this -> persist ( $ payment ) ; $ result = true ; } } return $ result ; }
2780	public function buildOptions ( ) : array { $ options = [ ] ; foreach ( $ this -> options as $ option => $ values ) { foreach ( ( array ) $ values as $ value ) { $ prefix = strlen ( $ option ) !== 1 ? '--' : '-' ; $ options [ ] = $ prefix . $ option ; if ( $ value !== true ) { $ options [ ] = $ value ; } } } return $ options ; }
669	protected function generateDependencyData ( $ cache ) { $ db = Instance :: ensure ( $ this -> db , Connection :: className ( ) ) ; if ( $ this -> sql === null ) { throw new InvalidConfigException ( 'DbDependency::sql must be set.' ) ; } if ( $ db -> enableQueryCache ) { $ db -> enableQueryCache = false ; $ result = $ db -> createCommand ( $ this -> sql , $ this -> params ) -> queryOne ( ) ; $ db -> enableQueryCache = true ; } else { $ result = $ db -> createCommand ( $ this -> sql , $ this -> params ) -> queryOne ( ) ; } return $ result ; }
1208	public function moveChildToPosition ( ItemInterface $ item , ItemInterface $ child , $ position ) { $ name = $ child -> getName ( ) ; $ order = array_keys ( $ item -> getChildren ( ) ) ; $ oldPosition = array_search ( $ name , $ order ) ; unset ( $ order [ $ oldPosition ] ) ; $ order = array_values ( $ order ) ; array_splice ( $ order , $ position , 0 , $ name ) ; $ item -> reorderChildren ( $ order ) ; }
1940	public function checkUniqueRecipient ( $ varValue , Contao \ DataContainer $ dc ) { $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE email=? AND pid=(SELECT pid FROM tl_newsletter_recipients WHERE id=?) AND id!=?" ) -> execute ( $ varValue , $ dc -> id , $ dc -> id ) ; if ( $ objRecipient -> count > 0 ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unique' ] , $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ $ dc -> field ] [ 0 ] ) ) ; } return $ varValue ; }
9216	public function actionDelete ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> isdel = 1 ; $ model -> save ( ) ; return $ this -> redirect ( [ 'index' ] ) ; }
8860	public function onBeforePublish ( ) { if ( $ this -> dbObject ( 'PublishDate' ) -> InPast ( ) && ! $ this -> isPublished ( ) ) { $ this -> setCastedField ( "PublishDate" , time ( ) ) ; $ this -> write ( ) ; } }
4363	public static function toUtf8 ( $ str ) { if ( \ extension_loaded ( 'mbstring' ) && \ function_exists ( 'iconv' ) ) { $ encoding = \ mb_detect_encoding ( $ str , \ mb_detect_order ( ) , true ) ; if ( ! $ encoding ) { $ str_conv = false ; if ( \ function_exists ( 'iconv' ) ) { $ str_conv = \ iconv ( 'cp1252' , 'UTF-8' , $ str ) ; } if ( $ str_conv === false ) { $ str_conv = \ htmlentities ( $ str , ENT_COMPAT ) ; $ str_conv = \ html_entity_decode ( $ str_conv , ENT_COMPAT , 'UTF-8' ) ; } $ str = $ str_conv ; } elseif ( ! \ in_array ( $ encoding , array ( 'ASCII' , 'UTF-8' ) ) ) { $ str_new = \ iconv ( $ encoding , 'UTF-8' , $ str ) ; if ( $ str_new !== false ) { $ str = $ str_new ; } } } return $ str ; }
428	public function init ( ) { if ( $ this -> controllerNamespace === null ) { $ class = get_class ( $ this ) ; if ( ( $ pos = strrpos ( $ class , '\\' ) ) !== false ) { $ this -> controllerNamespace = substr ( $ class , 0 , $ pos ) . '\\controllers' ; } } }
9339	public function get ( $ key , $ default = null ) { $ keys = array_filter ( explode ( '.' , $ key ) ) ; $ length = count ( $ keys ) ; $ data = $ this -> data ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ index = $ keys [ $ i ] ; $ data = & $ data [ $ index ] ; } return $ data !== null ? $ data : $ default ; }
1490	public function equalsTo ( MediaTypeInterface $ mediaType ) : ? Decoding { return collect ( $ this -> stack ) -> first ( function ( Decoding $ decoding ) use ( $ mediaType ) { return $ decoding -> equalsTo ( $ mediaType ) ; } ) ; }
431	public function getModule ( $ id , $ load = true ) { if ( ( $ pos = strpos ( $ id , '/' ) ) !== false ) { $ module = $ this -> getModule ( substr ( $ id , 0 , $ pos ) ) ; return $ module === null ? null : $ module -> getModule ( substr ( $ id , $ pos + 1 ) , $ load ) ; } if ( isset ( $ this -> _modules [ $ id ] ) ) { if ( $ this -> _modules [ $ id ] instanceof self ) { return $ this -> _modules [ $ id ] ; } elseif ( $ load ) { Yii :: debug ( "Loading module: $id" , __METHOD__ ) ; $ module = Yii :: createObject ( $ this -> _modules [ $ id ] , [ $ id , $ this ] ) ; $ module -> setInstance ( $ module ) ; return $ this -> _modules [ $ id ] = $ module ; } } return null ; }
6248	public function getAll ( ) { $ permissions = $ this -> modules -> getAllPermissions ( ) ; $ permissions = array_merge ( $ permissions , $ this -> getCustom ( ) ) ; return array_unique ( $ permissions ) ; }
3250	public function scopeWhereCurrent ( $ query ) { if ( Auth :: guest ( ) ) return $ query ; return $ query -> whereUser ( Auth :: user ( ) -> shopId ) ; }
4893	protected function array_compare ( $ array1 , $ array2 , $ maxDepth = 2 ) { $ result = array ( ) ; $ arraykeys = array_unique ( array_merge ( array_keys ( $ array1 ) , array_keys ( $ array2 ) ) ) ; foreach ( $ arraykeys as $ key ) { if ( ! empty ( $ key ) && is_string ( $ key ) && $ key [ 0 ] != "\0" && substr ( $ key , 0 , 8 ) != 'Doctrine' ) { if ( array_key_exists ( $ key , $ array1 ) && ! array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , '' ) ; } if ( ! array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( '' , $ array2 [ $ key ] ) ; } if ( array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ subResult = null ; if ( is_array ( $ array1 [ $ key ] ) && is_array ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ subResult = $ this -> array_compare ( $ array1 [ $ key ] , $ array2 [ $ key ] , $ maxDepth - 1 ) ; } } elseif ( is_object ( $ array1 [ $ key ] ) && is_object ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ hydrator = new EntityHydrator ( ) ; $ a1 = $ hydrator -> extract ( $ array1 [ $ key ] ) ; $ a2 = $ hydrator -> extract ( $ array2 [ $ key ] ) ; $ subResult = $ this -> array_compare ( $ a1 , $ a2 , $ maxDepth - 1 ) ; } } else { if ( $ array1 [ $ key ] != $ array2 [ $ key ] ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , $ array2 [ $ key ] ) ; } } if ( ! empty ( $ subResult ) ) { foreach ( $ subResult as $ subKey => $ subValue ) { if ( ! empty ( $ subKey ) && is_string ( $ subKey ) ) { $ result [ $ key . '.' . $ subKey ] = $ subValue ; } } } } } } return $ result ; }
2661	public function deleteRequest ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to delete the REQUEST object.' ) ) ; } }
6155	protected function convertValue ( $ value ) { switch ( $ this -> propertyType -> getDataTypeId ( ) ) { case PropertyType :: DATATYPE_BOOLEAN : return ( bool ) $ value ; break ; case PropertyType :: DATATYPE_DATETIME : if ( $ value instanceof \ DateTime ) { return $ value ; } try { return new \ DateTime ( $ value ) ; } catch ( \ Exception $ e ) { return null ; } break ; case PropertyType :: DATATYPE_FLOAT : return ( float ) $ value ; break ; case PropertyType :: DATATYPE_INTEGER : return ( int ) $ value ; break ; case PropertyType :: DATATYPE_STRING : return ( string ) $ value ; break ; default : return $ value ; break ; } }
10142	private function readDefault ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ this -> pos += 4 + $ length ; }
9611	public function getAssetUrl ( $ path , $ relative = false ) { if ( substr ( $ path , 0 , 1 ) !== '/' ) { $ path = '/' . $ path ; } if ( $ this -> assetRoot !== null ) { $ base = $ this -> assetRoot ; } else if ( $ relative ) { $ base = $ this -> requests -> getCurrentRequest ( ) -> getBaseUrl ( ) ; } else { $ base = $ this -> getRootUrl ( ) ; } return $ base . $ path ; }
6075	public function setStatus ( $ id , $ status ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'status' => $ status ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/status' , $ parameters ) ; return $ result ; }
363	public function renderItems ( ) { $ caption = $ this -> renderCaption ( ) ; $ columnGroup = $ this -> renderColumnGroup ( ) ; $ tableHeader = $ this -> showHeader ? $ this -> renderTableHeader ( ) : false ; $ tableBody = $ this -> renderTableBody ( ) ; $ tableFooter = false ; $ tableFooterAfterBody = false ; if ( $ this -> showFooter ) { if ( $ this -> placeFooterAfterBody ) { $ tableFooterAfterBody = $ this -> renderTableFooter ( ) ; } else { $ tableFooter = $ this -> renderTableFooter ( ) ; } } $ content = array_filter ( [ $ caption , $ columnGroup , $ tableHeader , $ tableFooter , $ tableBody , $ tableFooterAfterBody , ] ) ; return Html :: tag ( 'table' , implode ( "\n" , $ content ) , $ this -> tableOptions ) ; }
1869	private function parseFile ( string $ file ) : array { $ code = '' ; $ namespace = '' ; $ buffer = false ; $ stream = new \ PHP_Token_Stream ( $ file ) ; foreach ( $ stream as $ token ) { switch ( true ) { case $ token instanceof \ PHP_Token_OPEN_TAG : case $ token instanceof \ PHP_Token_CLOSE_TAG : break ; case false !== $ buffer : $ buffer .= $ token ; if ( ';' === ( string ) $ token ) { $ code .= $ this -> handleDeclare ( $ buffer ) ; $ buffer = false ; } break ; case $ token instanceof \ PHP_Token_NAMESPACE : if ( '{' === $ token -> getName ( ) ) { $ namespace = false ; $ code .= $ token ; } else { $ namespace = $ token -> getName ( ) ; $ stream -> seek ( $ token -> getEndTokenId ( ) ) ; } break ; case $ token instanceof \ PHP_Token_DECLARE : $ buffer = ( string ) $ token ; break ; default : $ code .= $ token ; } } return [ $ code , $ namespace ] ; }
9474	public function readOne ( ) { if ( $ this -> pos <= $ this -> max ) { $ value = $ this -> string [ $ this -> pos ] ; $ this -> pos += 1 ; } else { $ value = null ; } return $ value ; }
1777	public static function optionSelected ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' selected' : '' ; }
6341	final public static function init ( ) : void { $ className = static :: class ; self :: $ cache [ $ className ] = [ ] ; $ reflectionClass = self :: objectClass ( ) ; $ constructorParams = static :: constructorArgs ( ) ; $ ordinal = 0 ; foreach ( $ reflectionClass -> getProperties ( ReflectionProperty :: IS_STATIC ) as $ property ) { if ( $ property -> isPublic ( ) ) { $ name = $ property -> getName ( ) ; $ instance = self :: newInstance ( $ name , $ constructorParams ) ; $ property -> setValue ( $ instance ) ; self :: $ cache [ $ className ] [ $ name ] = $ instance ; self :: $ ordinals [ $ className ] [ $ name ] = $ ordinal ++ ; } } }
9537	private function getPrefix ( $ parameter ) { $ prefix = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ _prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ _prefix ) ) == $ _prefix ) { $ prefix = $ _prefix ; } } return $ prefix ; }
1	public function buildDependencyInfo ( $ depArray ) { if ( ! is_array ( $ depArray ) ) { return new DependencyInfo ( array ( ) , array ( ) ) ; } if ( ! $ this -> isHash ( $ depArray ) ) { return new DependencyInfo ( $ this -> buildDependency10Info ( $ depArray ) , array ( ) ) ; } return $ this -> buildDependency20Info ( $ depArray ) ; }
9429	public function getFontIconClassNames ( ) { $ classes = [ ] ; if ( $ this -> owner -> FontIcon ) { if ( $ this -> owner -> FontIconListItem ) { $ classes [ ] = $ this -> backend -> getClassName ( 'list-item' ) ; } if ( $ this -> owner -> FontIconFixedWidth ) { $ classes [ ] = $ this -> backend -> getClassName ( 'fixed-width' ) ; } $ classes [ ] = $ this -> backend -> getClassName ( 'icon' , [ $ this -> owner -> FontIcon ] ) ; } return $ classes ; }
2897	public function replaceProfiler ( ) { $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ currentProfile = $ connection -> getProfiler ( ) ; if ( $ currentProfile ) { $ this -> _queryProfiles = $ currentProfile -> _queryProfiles ; } $ this -> setEnabled ( $ currentProfile -> getEnabled ( ) ) ; $ connection -> setProfiler ( $ this ) ; }
1439	protected function getStub ( ) { if ( $ this -> isIndependent ) { return $ this -> getStubFor ( 'independent' ) ; } if ( $ this -> isEloquent ( ) ) { return $ this -> getStubFor ( 'eloquent' ) ; } return $ this -> getStubFor ( 'abstract' ) ; }
2323	public static function get ( ) { $ container = System :: getContainer ( ) ; return $ container -> get ( 'contao.csrf.token_manager' ) -> getToken ( $ container -> getParameter ( 'contao.csrf_token_name' ) ) -> getValue ( ) ; }
11966	public function renderSlots ( Page $ page , array $ slots , array $ options = array ( ) ) { $ renderedSlots = array ( ) ; $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERING , $ page , $ slots ) ; foreach ( $ slots as $ slotName => $ slot ) { if ( is_string ( $ slot ) ) { $ renderedSlots [ $ slotName ] = $ slot ; continue ; } if ( ! $ slot instanceof Slot ) { continue ; } $ renderedSlots [ $ slotName ] = implode ( "" , $ this -> renderSlot ( $ slot ) ) ; } $ this -> mediaFiles = array_unique ( $ this -> mediaFiles ) ; return $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERED , $ page , $ renderedSlots ) ; }
394	public static function updateAll ( $ attributes , $ condition = '' , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> update ( static :: tableName ( ) , $ attributes , $ condition , $ params ) ; return $ command -> execute ( ) ; }
11446	public function getSpooler ( ) { if ( empty ( $ this -> spooler ) ) { $ spool_class = $ this -> getDefault ( 'spooler' ) ; if ( class_exists ( $ spool_class ) ) { $ this -> setSpooler ( new $ spool_class ) ; } else { throw new \ Exception ( sprintf ( 'Default spool class "%s" not found!' , $ spool_class ) ) ; } } return $ this -> spooler ; }
1381	protected function validateToMany ( array $ value , ? string $ field = null ) : bool { $ path = $ field ? "/data/relationships/{$field}/data" : "/data" ; $ valid = true ; foreach ( $ value as $ index => $ item ) { if ( ! $ this -> validateIdentifier ( $ item , $ path , $ index ) ) { $ valid = false ; continue ; } if ( $ this -> isNotFound ( $ item -> type , $ item -> id ) ) { $ this -> resourceDoesNotExist ( "{$path}/{$index}" ) ; $ valid = false ; } } return $ valid ; }
5419	protected function parseHeaderLine ( $ header_line ) { if ( preg_match ( '/HTTP\/(\d+\.\d+)\s+(\d+)/i' , $ header_line , $ matches ) ) { $ this -> http_version = $ matches [ 1 ] ; $ this -> response_code = $ matches [ 2 ] ; } if ( preg_match ( '/Content-type:\s*(.*)/i' , $ header_line , $ matches ) ) { $ this -> mime_type = trim ( $ matches [ 1 ] ) ; } if ( preg_match ( '/Location:\s*(.*)/i' , $ header_line , $ matches ) ) { $ this -> location = trim ( $ matches [ 1 ] ) ; } if ( preg_match ( '/Set-cookie:(.*)/i' , $ header_line , $ matches ) ) { $ this -> cookies [ ] = $ this -> parseCookie ( $ matches [ 1 ] ) ; } if ( preg_match ( '/WWW-Authenticate:\s+(\S+)\s+realm=\"(.*?)\"/i' , $ header_line , $ matches ) ) { $ this -> authentication = $ matches [ 1 ] ; $ this -> realm = trim ( $ matches [ 2 ] ) ; } }
8090	static public function generate ( $ uid = 0 , $ hash = false ) { if ( $ uid ) { $ e_uid = self :: encode ( $ uid ) ; $ e_uid_length = strlen ( $ e_uid ) ; $ e_uid_length = str_pad ( $ e_uid_length , 2 , 0 , STR_PAD_LEFT ) ; $ e_uid_pos = rand ( 10 , 32 - $ e_uid_length - 1 ) ; if ( ! $ hash ) { $ hash = sha1 ( uniqid ( rand ( ) , true ) ) ; } $ code = $ e_uid_pos . $ e_uid_length ; $ code .= substr ( $ hash , 0 , $ e_uid_pos - strlen ( $ code ) ) ; $ code .= $ e_uid ; $ code .= substr ( $ hash , strlen ( $ code ) ) ; return $ code ; } else { return sha1 ( uniqid ( rand ( ) , true ) ) ; } }
4193	protected function dumpProperties ( $ abs ) { $ label = \ count ( $ abs [ 'properties' ] ) ? 'properties' : 'no properties' ; if ( $ abs [ 'viaDebugInfo' ] ) { $ label .= ' <span class="text-muted">(via __debugInfo)</span>' ; } $ str = '<dt class="properties">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__get' , '__set' ) , \ array_keys ( $ abs [ 'methods' ] ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ abs [ 'properties' ] as $ k => $ info ) { $ vis = ( array ) $ info [ 'visibility' ] ; $ isPrivateAncestor = \ in_array ( 'private' , $ vis ) && $ info [ 'inheritedFrom' ] ; $ classes = \ array_keys ( \ array_filter ( array ( 'debuginfo-value' => $ info [ 'valueFrom' ] == 'debugInfo' , 'excluded' => $ info [ 'isExcluded' ] , 'forceShow' => $ info [ 'forceShow' ] , 'debug-value' => $ info [ 'valueFrom' ] == 'debug' , 'private-ancestor' => $ isPrivateAncestor , 'property' => true , \ implode ( ' ' , $ vis ) => $ info [ 'visibility' ] !== 'debug' , ) ) ) ; $ modifiers = $ vis ; if ( $ info [ 'isStatic' ] ) { $ modifiers [ ] = 'static' ; } $ str .= '<dd class="' . \ implode ( ' ' , $ classes ) . '">' . \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ( $ isPrivateAncestor ? ' (<i>' . $ info [ 'inheritedFrom' ] . '</i>)' : '' ) . ( $ info [ 'type' ] ? ' <span class="t_type">' . $ info [ 'type' ] . '</span>' : '' ) . ' <span class="property-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . $ k . '</span>' . ( $ info [ 'value' ] !== $ this -> debug -> abstracter -> UNDEFINED ? ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ info [ 'value' ] ) : '' ) . '</dd>' . "\n" ; } return $ str ; }
5587	public function getCookies ( ) { $ lstCookies = $ this -> cookie_jar -> getCookies ( ) ; $ aCookies = [ ] ; foreach ( $ lstCookies as $ oCookies ) { $ aCookies [ ] = [ 'name' => $ oCookies -> getName ( ) , 'value' => $ oCookies -> getValue ( ) , 'host' => $ oCookies -> getHost ( ) , 'path' => $ oCookies -> getPath ( ) , 'expiry' => $ oCookies -> getExpiry ( ) , ] ; } return $ aCookies ; }
6566	public function request ( array $ data ) { $ data = array_replace ( $ this -> config , $ data ) ; return $ this -> client -> callRequest ( $ data ) ; }
9080	private static function parseElement ( Request & $ req , $ serverVars , $ elementName , $ paramName ) { if ( isset ( $ serverVars [ $ elementName ] ) ) { $ req -> setParam ( $ paramName , $ serverVars [ $ elementName ] ) ; } }
3406	public function loadCommands ( string $ path , string $ namespace = "" , string $ suffix = "Command" ) : Application { $ commands = [ ] ; $ realpath = ( string ) realpath ( $ path ) ; $ finder = ( new Finder ( ) ) -> files ( ) -> in ( $ path ) -> name ( "/[A-Z].*{$suffix}.php/" ) ; foreach ( $ finder as $ file ) { $ filename = ( string ) $ file -> getRealPath ( ) ; require_once $ filename ; $ class = $ filename ; $ class = str_replace ( $ realpath , "" , $ class ) ; $ class = str_replace ( ".php" , "" , $ class ) ; $ class = str_replace ( "/" , "\\" , $ class ) ; $ command = $ class ; if ( substr ( $ command , 0 , 1 ) == "\\" ) { $ command = substr ( $ command , 1 ) ; } $ command = ( string ) preg_replace_callback ( "/^([A-Z])(.*){$suffix}$/" , function ( $ match ) { return strtolower ( $ match [ 1 ] ) . $ match [ 2 ] ; } , $ command ) ; $ command = preg_replace_callback ( "/(\\\\)?([A-Z])/" , function ( $ match ) { $ result = ( $ match [ 1 ] ) ? ":" : "-" ; $ result .= strtolower ( $ match [ 2 ] ) ; return $ result ; } , $ command ) ; $ class = $ namespace . $ class ; $ reflected = new \ ReflectionClass ( $ class ) ; if ( ! $ reflected -> isInstantiable ( ) ) { continue ; } $ commands [ ] = new $ class ( $ command ) ; } if ( count ( $ commands ) < 1 ) { throw new \ InvalidArgumentException ( "No commands were found in the path (" . $ path . ")" ) ; } $ this -> addCommands ( $ commands ) ; return $ this ; }
11131	public static function getRootBackslash ( $ pathname ) { if ( $ pathname [ 0 ] == '\\' ) { $ pathname = substr ( $ pathname , 1 ) ; } $ arr = explode ( '\\' , $ pathname ) ; if ( count ( $ arr ) > 1 ) { return $ arr [ 0 ] ; } return '' ; }
8433	public function migrate ( Request $ req ) { if ( count ( $ req -> getArgs ( ) ) != 1 ) { echo 'Wrong arguments.' . PHP_EOL . 'Usage : db/migration/migrate mapping_name' . PHP_EOL ; } else { $ mappingName = $ req -> getArgs ( ) [ 0 ] ; $ mapping = Mapping :: get ( $ mappingName ) ; $ cl = '\\' . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Migration::migrate' ; if ( is_callable ( $ cl ) === false ) { throw new RuntimeException ( 'Migration migrate method is not callable on configured provider!' ) ; } call_user_func ( $ cl , $ mapping ) ; echo 'Migrate - Done' . PHP_EOL ; } }
3782	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ image = '<img src="' . $ this -> attributeFactory -> getIconForType ( $ type ) . '" />' ; $ metaModel = $ this -> getMetaModelByModelPid ( $ model ) ; $ attribute = $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ metaModel ) ; if ( ! $ attribute ) { $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> <strong>%s</strong><br /> </div>' ) -> setArgs ( array ( $ translator -> translate ( 'error_unknown_attribute.0' , 'tl_metamodel_attribute' ) , $ type , $ translator -> translate ( 'error_unknown_attribute.1' , 'tl_metamodel_attribute' , array ( $ type ) ) , ) ) ; return ; } $ colName = $ attribute -> getColName ( ) ; $ name = $ attribute -> getName ( ) ; $ arrDescription = StringUtil :: deserialize ( $ attribute -> get ( 'description' ) ) ; if ( is_array ( $ arrDescription ) ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getActiveLanguage ( ) ] ; if ( ! $ description ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; } } else { $ description = $ arrDescription ? : $ attribute -> getName ( ) ; } $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong> - %s </div>' ) -> setArgs ( array ( $ colName , $ type , $ image , $ name , $ description ) ) ; }
60	public function addSuggestionsFromPackage ( PackageInterface $ package ) { $ source = $ package -> getPrettyName ( ) ; foreach ( $ package -> getSuggests ( ) as $ target => $ reason ) { $ this -> addPackage ( $ source , $ target , $ reason ) ; } return $ this ; }
891	public function setTypes ( array $ types ) { $ pattern = '/' . preg_quote ( $ this -> getTypesContent ( ) , '/' ) . '/' ; $ this -> lines [ 0 ] -> setContent ( Preg :: replace ( $ pattern , implode ( '|' , $ types ) , $ this -> lines [ 0 ] -> getContent ( ) , 1 ) ) ; $ this -> clearCache ( ) ; }
12066	public function invokeRpcCall ( $ method , $ arguments = [ ] ) { if ( ! is_null ( $ this -> namespace ) ) { $ method = $ this -> namespace . '.' . $ method ; } $ body = XmlRpcBuilder :: createRequest ( $ method , $ arguments ) ; $ guzzle = new \ GuzzleHttp \ Client ( ) ; $ this -> getLogger ( ) -> info ( "sending request for $method to {$this->url}" ) ; $ this -> getLogger ( ) -> debug ( "sending request for $method to {$this->url}, with parameters: " . print_r ( $ arguments , true ) ) ; $ response = $ guzzle -> post ( $ this -> url , [ 'body' => $ body , 'headers' => [ 'User-Agent' => 'Devedge\XmlRpc\Client/' . self :: $ version , 'Content-Type' => 'text/xml' ] ] ) ; if ( $ response -> xml ( ) -> fault -> count ( ) > 0 ) { $ this -> logger -> warning ( "serverside error occured, details: " . $ response -> getBody ( ) ) ; throw XmlRpcParser :: parseFault ( $ response -> xml ( ) -> fault ) ; } return array_shift ( XmlRpcParser :: parseParams ( $ response -> xml ( ) -> params ) ) ; }
6343	public function equals ( ObjectInterface $ object = null ) : bool { return $ object instanceof static && $ object -> name === $ this -> name ; }
8427	public static function get ( string $ class ) { if ( isset ( self :: $ controllers [ $ class ] ) === false ) { self :: $ controllers [ $ class ] = new $ class ( ) ; } return self :: $ controllers [ $ class ] ; }
5821	protected function writeToContainer ( $ type , $ path , $ payload ) { try { $ this -> container -> { 'uploadFrom' . $ type } ( $ path , $ payload ) ; } catch ( UploadFailedException $ e ) { return false ; } return $ this -> getMetadata ( $ path ) ; }
4491	public function registerDeviceOnTopic ( string $ deviceArn , string $ topicArn ) { $ this -> sns -> subscribe ( [ 'TopicArn' => $ topicArn , 'Protocol' => 'application' , 'Endpoint' => $ deviceArn , ] ) ; }
6358	public function setTimezone ( $ timezone ) { try { $ this -> timestamp -> setTimezone ( new DateTimeZone ( $ timezone ) ) ; } catch ( Exception $ e ) { throw new TimestampException ( __METHOD__ . ': Invalid timezone.' , $ e -> getCode ( ) , $ e ) ; } }
1780	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'calendar' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } $ this -> cal_calendar = $ this -> sortOutProtected ( StringUtil :: deserialize ( $ this -> cal_calendar , true ) ) ; if ( empty ( $ this -> cal_calendar ) || ! \ is_array ( $ this -> cal_calendar ) ) { return '' ; } $ this -> strUrl = preg_replace ( '/\?.*$/' , '' , Environment :: get ( 'request' ) ) ; $ this -> strLink = $ this -> strUrl ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> strLink = $ objTarget -> getFrontendUrl ( ) ; } return parent :: generate ( ) ; }
8097	private function validate ( ) { $ server = new Collection ( $ _SERVER ) ; $ ip = $ server -> HTTP_X_FORWARDED_FOR ; if ( is_null ( $ ip ) && $ server -> REMOTE_ADDR ) { $ ip = $ server -> REMOTE_ADDR ; } if ( ! is_null ( $ this -> _ip ) ) { if ( $ this -> _ip != $ ip ) { $ this -> destroy ( ) ; } } else { $ this -> _ip = $ ip ; } }
6230	public function module ( $ key ) { if ( ! $ this -> core -> modules ( ) -> has ( $ key ) ) { abort ( 404 , 'Module not loaded' ) ; } return $ this -> core -> api ( ) -> response ( $ this -> makeContainer ( $ this -> core -> modules ( ) -> getModulePermissions ( $ key ) ) ) ; }
12650	protected function readFileContents ( $ language ) { $ fileName = $ this -> getFileName ( $ language ) ; $ fs = $ this -> env -> getFileSystem ( ) ; if ( ! $ fs -> fileExists ( $ fileName ) ) { return array ( ) ; } $ content = json_decode ( preg_replace ( '/^.*?define\((.*)\);\s*/s' , '$1' , $ fs -> getFile ( $ fileName ) ) , true ) ; if ( $ language === $ this -> baseLang ) { $ content = $ content [ 'root' ] ; } $ outdateInfo = [ ] ; $ fileName = $ this -> getOutdateInfoFileName ( $ language ) ; if ( $ fs -> fileExists ( $ fileName ) ) { $ outdateInfo = json_decode ( $ fs -> getFile ( $ fileName ) , true ) ; } foreach ( $ content as $ id => $ text ) { $ outdated = isset ( $ outdateInfo [ $ id ] ) ? $ outdateInfo [ $ id ] : true ; $ content [ $ id ] = array ( 'id' => $ id , 'name' => $ id , 'content' => $ text , 'outdated' => $ outdated ) ; } return $ content ; }
1534	protected function methodForRelation ( $ field ) { if ( method_exists ( $ this , $ field ) ) { return $ field ; } $ method = Str :: camelize ( $ field ) ; return method_exists ( $ this , $ method ) ? $ method : null ; }
7681	function TbsPrepareMergeCell ( & $ Txt , & $ Loc ) { if ( $ this -> ExtEquiv == 'docx' ) { $ xml = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'w:tcPr' , $ Loc -> PosBeg , false ) ; if ( $ xml ) { $ Txt = substr_replace ( $ Txt , '' , $ Loc -> PosBeg , $ Loc -> PosEnd - $ Loc -> PosBeg + 1 ) ; $ Loc -> PosBeg = $ xml -> PosEnd + 1 ; $ Loc -> PosEnd = $ xml -> PosEnd ; $ this -> PrevVals [ $ Loc -> FullName ] = '' ; $ Loc -> ConvStr = false ; } } }
10060	public function set ( $ key , $ value ) { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> first ( ) ; if ( $ meta === null ) { $ meta = new $ this -> metaModel ; $ meta -> key = $ key ; } $ meta -> value = $ value ; $ meta -> save ( ) ; }
8856	public function increase ( ) { $ this -> retries ++ ; if ( $ this -> retries > $ this -> maxRetries ) { throw new MaxRetriesExceededException ( sprintf ( 'Max allowed retries exceeded. Allowed: %s. Tried: %s.' , $ this -> maxRetries , $ this -> retries ) ) ; } return $ this ; }
8599	private function _convertCreateSubscription ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateSubscription' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetSubscription ( ) ) { $ SubscriptionCreateSubscriptionInput = $ request -> getSubscription ( ) ; foreach ( $ SubscriptionCreateSubscriptionInput -> getNotificationType ( ) as $ NotificationTypeSubscriptionIndex => $ NotificationTypeSubscription ) { $ parameters [ 'Subscription' . '.' . 'NotificationType' . '.' . ( $ NotificationTypeSubscriptionIndex + 1 ) ] = $ NotificationTypeSubscription ; } } return $ parameters ; }
2017	protected function resizeUploadedImage ( $ strImage ) { if ( Config :: get ( 'imageWidth' ) < 1 && Config :: get ( 'imageHeight' ) < 1 ) { return false ; } $ objFile = new File ( $ strImage ) ; if ( ! $ objFile -> isSvgImage && ! $ objFile -> isGdImage ) { return false ; } $ arrImageSize = $ objFile -> imageSize ; if ( $ objFile -> isGdImage && ( $ arrImageSize [ 0 ] > Config :: get ( 'gdMaxImgWidth' ) || $ arrImageSize [ 1 ] > Config :: get ( 'gdMaxImgHeight' ) ) ) { Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileExceeds' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" is too big to be resized automatically' , __METHOD__ , TL_FILES ) ; return false ; } $ blnResize = false ; if ( $ arrImageSize [ 0 ] > Config :: get ( 'imageWidth' ) ) { $ blnResize = true ; $ intWidth = Config :: get ( 'imageWidth' ) ; $ intHeight = round ( Config :: get ( 'imageWidth' ) * $ arrImageSize [ 1 ] / $ arrImageSize [ 0 ] ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ arrImageSize [ 1 ] > Config :: get ( 'imageHeight' ) ) { $ blnResize = true ; $ intWidth = round ( Config :: get ( 'imageHeight' ) * $ arrImageSize [ 0 ] / $ arrImageSize [ 1 ] ) ; $ intHeight = Config :: get ( 'imageHeight' ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ blnResize ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; $ container -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ strImage , array ( $ arrImageSize [ 0 ] , $ arrImageSize [ 1 ] ) , $ rootDir . '/' . $ strImage ) ; Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileResized' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" was scaled down to the maximum dimensions' , __METHOD__ , TL_FILES ) ; $ this -> blnHasResized = true ; return true ; } return false ; }
1624	protected function releaseLock ( $ name ) { static $ releaseLuaScript = <<<LUAif redis.call("GET",KEYS[1])==ARGV[1] then return redis.call("DEL",KEYS[1])else return 0endLUA ; if ( ! isset ( $ this -> _lockValues [ $ name ] ) || ! $ this -> redis -> executeCommand ( 'EVAL' , [ $ releaseLuaScript , 1 , $ this -> calculateKey ( $ name ) , $ this -> _lockValues [ $ name ] ] ) ) { return false ; } else { unset ( $ this -> _lockValues [ $ name ] ) ; return true ; } }
5778	public function set ( string $ sql , array $ args ) { $ this -> sql = $ sql ; $ this -> args = $ args ; }
11140	protected function joinStringFromArray ( $ dataMember , $ sep = ' AND ' ) { if ( empty ( $ this -> $ dataMember ) ) { return 0 ; } $ count = count ( $ this -> $ dataMember ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ statement = $ this -> { $ dataMember } [ $ i ] ; $ this -> query .= ' ' . $ statement [ 2 ] . ' JOIN ' . $ statement [ 0 ] . ' ON ' ; $ sCount = count ( $ statement [ 1 ] ) ; for ( $ j = 0 ; $ j < $ sCount ; $ j ++ ) { $ this -> query .= $ this -> getArrayJoin ( $ dataMember , $ i , $ j ) ; if ( $ sCount - 1 != $ j ) { $ this -> query .= $ sep ; } } } }
9700	protected function generate ( ) { $ params = array_keys ( $ this -> params ) ; if ( $ this -> paragraphs ) { $ params [ ] = $ this -> paragraphs ; } $ url = self :: API_URL . implode ( '/' , $ params ) ; return $ this -> conn -> request ( $ url ) ; }
11363	public static function mailListTagger ( array $ list ) { $ str = '' ; foreach ( $ list as $ name => $ mail ) { if ( is_string ( $ mail ) ) { $ str .= self :: mailTagger ( $ mail , $ name ) . Mailer :: $ ADDERSSES_SEPARATOR ; } elseif ( is_array ( $ mail ) ) { foreach ( $ mail as $ subname => $ submail ) { $ str .= self :: mailTagger ( $ submail , $ subname ) . Mailer :: $ ADDERSSES_SEPARATOR ; } } } return $ str ; }
4228	protected function buildError ( $ errType , $ errMsg , $ file , $ line , $ vars ) { foreach ( $ this -> errCategories as $ category => $ errTypes ) { if ( \ in_array ( $ errType , $ errTypes ) ) { break ; } } $ errorValues = array ( 'type' => $ errType , 'typeStr' => $ this -> errTypes [ $ errType ] , 'category' => $ category , 'message' => $ errMsg , 'file' => $ file , 'line' => $ line , 'vars' => $ vars , 'backtrace' => array ( ) , 'continueToNormal' => false , 'continueToPrevHandler' => $ this -> cfg [ 'continueToPrevHandler' ] && $ this -> prevErrorHandler , 'exception' => $ this -> uncaughtException , 'hash' => null , 'isFirstOccur' => true , 'isHtml' => \ filter_var ( \ ini_get ( 'html_errors' ) , FILTER_VALIDATE_BOOLEAN ) && ! \ in_array ( $ errType , $ this -> userErrors ) && ! $ this -> uncaughtException , 'isSuppressed' => false , ) ; $ hash = $ this -> errorHash ( $ errorValues ) ; $ isFirstOccur = ! isset ( $ this -> data [ 'errors' ] [ $ hash ] ) ; if ( $ errorValues [ 'isHtml' ] ) { $ errorValues [ 'message' ] = \ str_replace ( '<a ' , '<a target="phpRef" ' , $ errorValues [ 'message' ] ) ; } $ isSuppressed = ! $ isFirstOccur && ! $ this -> data [ 'errors' ] [ $ hash ] [ 'isSuppressed' ] ? false : \ error_reporting ( ) === 0 ; if ( ! empty ( $ this -> data [ 'errorCaller' ] ) ) { $ errorValues [ 'file' ] = $ this -> data [ 'errorCaller' ] [ 'file' ] ; $ errorValues [ 'line' ] = $ this -> data [ 'errorCaller' ] [ 'line' ] ; } if ( \ in_array ( $ errType , array ( E_ERROR , E_USER_ERROR ) ) ) { $ errorValues [ 'backtrace' ] = $ this -> backtrace ( $ errorValues ) ; } $ errorValues = \ array_merge ( $ errorValues , array ( 'continueToNormal' => ! $ isSuppressed && $ isFirstOccur , 'hash' => $ hash , 'isFirstOccur' => $ isFirstOccur , 'isSuppressed' => $ isSuppressed , ) ) ; return new Event ( $ this , $ errorValues ) ; }
7273	public static function tableName ( ) { $ cc = static :: modelName ( ) ; $ cc [ 0 ] = strtolower ( $ cc [ 0 ] ) ; return preg_replace_callback ( "/[A-Z]/" , function ( $ uppercase ) { return "_" . strtolower ( $ uppercase [ 0 ] ) ; } , $ cc ) . "s" ; }
322	public static function pluralize ( $ word ) { if ( isset ( static :: $ specials [ $ word ] ) ) { return static :: $ specials [ $ word ] ; } foreach ( static :: $ plurals as $ rule => $ replacement ) { if ( preg_match ( $ rule , $ word ) ) { return preg_replace ( $ rule , $ replacement , $ word ) ; } } return $ word ; }
84	public static function expandPath ( $ path ) { if ( preg_match ( '#^~[\\/]#' , $ path ) ) { return self :: getUserDirectory ( ) . substr ( $ path , 1 ) ; } return preg_replace_callback ( '#^(\$|(?P<percent>%))(?P<var>\w++)(?(percent)%)(?P<path>.*)#' , function ( $ matches ) { if ( Platform :: isWindows ( ) && $ matches [ 'var' ] == 'HOME' ) { return ( getenv ( 'HOME' ) ? : getenv ( 'USERPROFILE' ) ) . $ matches [ 'path' ] ; } return getenv ( $ matches [ 'var' ] ) . $ matches [ 'path' ] ; } , $ path ) ; }
252	public function removeAllFlashes ( ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; foreach ( array_keys ( $ counters ) as $ key ) { unset ( $ _SESSION [ $ key ] ) ; } unset ( $ _SESSION [ $ this -> flashParam ] ) ; }
11105	public function join ( $ table , $ type = null ) { $ this -> join -> addJoin ( $ table , $ type ) ; return $ this ; }
11471	public function edit ( ResponseRequest $ request , Response $ response ) { return $ this -> response -> title ( trans ( 'app.edit' ) . ' ' . trans ( 'forum::response.name' ) ) -> view ( 'forum::response.edit' , true ) -> data ( compact ( 'response' ) ) -> output ( ) ; }
11158	protected function getVideoId ( $ url ) { $ logger = $ this -> getLogger ( ) ; $ parsed = parse_url ( $ url ) ; $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'parsed' => $ parsed ) ) ; switch ( $ parsed [ 'host' ] ) { case 'youtu.be' : return ltrim ( $ parsed [ 'path' ] , '/' ) ; case 'www.youtube.com' : case 'youtube.com' : if ( ! empty ( $ parsed [ 'query' ] ) ) { parse_str ( $ parsed [ 'query' ] , $ query ) ; $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'query' => $ query ) ) ; if ( ! empty ( $ query [ 'v' ] ) ) { return $ query [ 'v' ] ; } } elseif ( isset ( $ parsed [ 'path' ] ) && substr ( $ parsed [ 'path' ] , 0 , 7 ) == '/embed/' ) { $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'path' => $ parsed [ 'path' ] ) ) ; $ vId = substr ( $ parsed [ 'path' ] , 7 ) ; if ( ! empty ( $ vId ) ) { return $ vId ; } } } return null ; }
5321	public function remove ( ) { if ( is_resource ( $ this -> mutex ) ) { sem_remove ( $ this -> mutex ) ; } if ( file_exists ( $ this -> file ) ) { unlink ( $ this -> file ) ; } }
12904	public function setAccessToken ( $ token , $ expires = 7200 ) { $ this -> cache -> save ( $ this -> getAccessTokenCacheKey ( ) , $ token , $ expires ) ; return $ this ; }
5114	private function conv ( $ str ) { if ( $ this -> supportsExtMbstring ) { return mb_convert_encoding ( $ str , 'UTF-16BE' , 'UTF-8' ) ; } return preg_replace_callback ( '/./su' , function ( $ m ) { if ( ! isset ( $ m [ 0 ] [ 1 ] ) ) { return "\x00" . $ m [ 0 ] ; } if ( isset ( $ m [ 0 ] [ 3 ] ) ) { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x07 ) << 18 ) + ( ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) << 12 ) + ( ( ord ( $ m [ 0 ] [ 2 ] ) & 0x3F ) << 6 ) + ( ord ( $ m [ 0 ] [ 3 ] ) & 0x3F ) ; return pack ( 'nn' , ( $ code - 0x10000 >> 10 ) | 0xD800 , ( $ code & 0x03FF ) | 0xDC00 ) ; } if ( isset ( $ m [ 0 ] [ 2 ] ) ) { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x0F ) << 12 ) + ( ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) << 6 ) + ( ord ( $ m [ 0 ] [ 2 ] ) & 0x3F ) ; } else { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x1F ) << 6 ) + ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) ; } return chr ( $ code >> 8 ) . chr ( $ code & 0xFF ) ; } , $ str ) ; }
3271	public function writeTempToFile ( SplTempFileObject & $ tmpFile ) { $ file = $ this -> openFile ( static :: FILE_WRITE ) ; foreach ( $ tmpFile as $ line ) { $ file -> fwrite ( $ line ) ; } $ this -> closeFile ( $ file ) ; $ tmpFile = null ; }
9037	protected function update ( $ entity , $ where = null , $ tableName = null , HydratorInterface $ hydrator = null ) { if ( ! $ where ) { $ where = 'id = ' . $ entity -> getId ( ) ; } return parent :: update ( $ entity , $ where , $ tableName , $ hydrator ) ; }
9155	private function parseAnnotations ( \ ReflectionMethod $ action ) { if ( $ action -> isConstructor ( ) || $ action -> isDestructor ( ) || $ action -> isStatic ( ) || $ action -> isFinal ( ) ) { return ; } $ rfMethod = new \ ReflectionMethod ( $ this , $ action -> name ) ; $ anno = $ rfMethod -> getDocComment ( ) ; if ( $ anno && preg_match ( '#@webMethod#' , $ anno ) ) { $ this -> actions [ ] = $ action -> name ; return ; } if ( ! $ this -> parseParameters ( $ action ) ) { return ; } $ this -> actions [ ] = $ action -> name ; }
7082	public function uri ( $ uri = NULL ) : string { if ( $ uri === NULL ) { return empty ( $ this -> _uri ) ? '/' : $ this -> _uri ; } return $ this -> _uri = $ uri ; }
11877	public static function getDumpQueryResult ( $ var ) { $ header = true ; $ dump = '<table cellpadding=5 cellspacing=0>' ; $ i = 1 ; foreach ( $ var as $ ligne ) { if ( $ header ) { $ dump .= '<tr>' ; foreach ( $ ligne as $ key => $ value ) { if ( ! is_numeric ( $ key ) ) { $ dump .= '<th>' . $ key . '</th>' ; } } $ dump .= '</tr>' ; $ header = false ; } $ class = '' ; if ( ! ( $ i % 2 ) ) { $ class = 'highlight' ; } $ dump .= '<tr class="' . $ class . '">' ; foreach ( $ ligne as $ key => $ value ) { if ( ! is_numeric ( $ key ) ) { if ( $ value != '' ) { $ dump .= '<td>' . $ value . '</td>' ; } else { $ dump .= '<td>&nbsp;</td>' ; } } } $ dump .= '</tr>' ; $ i ++ ; } $ dump .= '</table>' ; return $ dump ; }
8609	private function _convertRegisterDestination ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'RegisterDestination' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationRegisterDestinationInput = $ request -> getDestination ( ) ; foreach ( $ DestinationRegisterDestinationInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
3208	public static function encode ( $ string ) { if ( strlen ( $ string ) == 0 ) { return '' ; } $ binaryString = '' ; foreach ( str_split ( $ string ) as $ s ) { $ binaryString .= sprintf ( '%08b' , ord ( $ s ) ) ; } $ binaryArray = self :: chunk ( $ binaryString , 5 ) ; while ( count ( $ binaryArray ) % 8 !== 0 ) { $ binaryArray [ ] = null ; } $ base32String = '' ; foreach ( $ binaryArray as $ bin ) { $ char = 32 ; if ( ! is_null ( $ bin ) ) { $ bin = str_pad ( $ bin , 5 , 0 , STR_PAD_RIGHT ) ; $ char = bindec ( $ bin ) ; } $ base32String .= self :: $ alphabet [ $ char ] ; } return $ base32String ; }
1761	protected static function readPhpFileWithoutTags ( $ strName ) { @ trigger_error ( 'Using System::readPhpFileWithoutTags() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\PhpFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new PhpFileLoader ( ) ; return $ loader -> load ( $ strName ) ; }
1371	protected function make ( array $ data ) { $ validator = $ this -> validatorFactory -> make ( $ data , $ this -> getRules ( ) , $ this -> getMessages ( ) , $ this -> getAttributes ( ) ) ; $ this -> configureValidator ( $ validator ) ; return $ validator ; }
4996	public function getColumnMap ( ) { $ map = $ this -> getOption ( 'column_map' ) ; if ( null === $ map ) { $ map = [ ] ; foreach ( $ this as $ element ) { $ col = $ element -> getOption ( 'span' ) ; if ( null !== $ col ) { $ map [ $ element -> getName ( ) ] = $ col ; } } $ this -> setOption ( 'column_map' , $ map ) ; } return $ map ; }
5239	private function paramType ( \ ReflectionMethod $ method , \ ReflectionParameter $ param ) { $ methodAnnotations = annotationsOf ( $ method ) ; $ paramAnnotations = annotationsOf ( $ param ) ; $ paramClass = $ param -> getClass ( ) ; if ( null !== $ paramClass ) { if ( $ methodAnnotations -> contain ( 'Property' ) || $ paramAnnotations -> contain ( 'Property' ) ) { return PropertyBinding :: TYPE ; } return $ paramClass -> getName ( ) ; } if ( $ methodAnnotations -> contain ( 'List' ) || $ paramAnnotations -> contain ( 'List' ) ) { return ListBinding :: TYPE ; } if ( $ methodAnnotations -> contain ( 'Map' ) || $ paramAnnotations -> contain ( 'Map' ) ) { return MapBinding :: TYPE ; } if ( $ methodAnnotations -> contain ( 'Property' ) || $ paramAnnotations -> contain ( 'Property' ) ) { return PropertyBinding :: TYPE ; } return ConstantBinding :: TYPE ; }
2999	public function setErrors ( $ email , $ title = null ) { $ this -> set ( 'Sender' , $ this -> buildMail ( $ email , $ title ) ) ; }
10461	public function initialize ( $ filePath , $ params ) { copy ( __DIR__ . '/../../../recipe/releaz.php' , $ filePath ) ; $ exampleFile = $ this -> getExamplePath ( ) ; $ projectFile = dirname ( $ filePath ) . '/' . $ this -> getExample ( ) ; copy ( $ exampleFile , $ projectFile ) ; $ this -> setParamsInExample ( $ projectFile , $ params ) ; }
5057	private function getClassName ( $ requestedName ) { $ exp = explode ( '/' , $ requestedName ) ; $ className = array_shift ( $ exp ) . '\\Controller\\' . implode ( '\\' , $ exp ) . 'Controller' ; if ( ! class_exists ( $ className ) ) { throw new ServiceNotCreatedException ( sprintf ( 'Can\'t find correct controller class for "%s"' , $ requestedName ) ) ; } return $ className ; }
5204	public function isActiveURL ( $ url , $ output = "active" ) { if ( $ this -> url -> current ( ) == $ this -> url -> to ( $ url ) ) { return $ output ; } return null ; }
5316	public function toCollection ( ) { if ( function_exists ( $ this -> collectionFunction ) ) { return call_user_func ( $ this -> collectionFunction , $ this -> toArray ( ) ) ; } throw new \ Exception ( "Function {$this->collectionFunction}() was not found. " . "You probably need to install a suggested package?" ) ; }
3032	public function getSessionState ( AssessmentTestSession $ session ) { $ deliveryExecution = $ this -> getDeliveryExecution ( $ session ) ; return $ deliveryExecution -> getState ( ) -> getUri ( ) ; }
1461	protected function orderAsc ( ) { $ this -> query -> orderBy ( $ this -> column ) ; if ( $ this -> isNotPagingOnKey ( ) ) { $ this -> query -> orderBy ( $ this -> key ) ; } return $ this ; }
7081	public function onPostCopy ( SaleTransformEvent $ event ) { $ source = $ event -> getSource ( ) ; $ target = $ event -> getTarget ( ) ; $ target -> setOriginNumber ( $ source -> getNumber ( ) ) ; if ( $ source instanceof OrderInterface && $ target instanceof OrderInterface ) { $ target -> setSample ( $ source -> isSample ( ) ) ; } if ( null === $ customer = $ source -> getCustomer ( ) ) { return ; } if ( $ target instanceof OrderInterface && $ customer -> hasParent ( ) ) { $ target -> setCustomer ( $ customer -> getParent ( ) ) ; if ( null === $ target -> getOriginCustomer ( ) ) { $ target -> setOriginCustomer ( $ customer ) ; } } }
2029	public static function findPublishedFallbackByHostname ( $ strHost , array $ arrOptions = array ( ) ) { if ( empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ strHost , 'contao.dns-fallback' ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.dns=? AND $t.fallback='1'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; }
65	public function normalizePath ( $ path ) { $ parts = array ( ) ; $ path = strtr ( $ path , '\\' , '/' ) ; $ prefix = '' ; $ absolute = false ; if ( preg_match ( '{^( [0-9a-z]{2,}+: (?: // (?: [a-z]: )? )? | [a-z]: )}ix' , $ path , $ match ) ) { $ prefix = $ match [ 1 ] ; $ path = substr ( $ path , strlen ( $ prefix ) ) ; } if ( substr ( $ path , 0 , 1 ) === '/' ) { $ absolute = true ; $ path = substr ( $ path , 1 ) ; } $ up = false ; foreach ( explode ( '/' , $ path ) as $ chunk ) { if ( '..' === $ chunk && ( $ absolute || $ up ) ) { array_pop ( $ parts ) ; $ up = ! ( empty ( $ parts ) || '..' === end ( $ parts ) ) ; } elseif ( '.' !== $ chunk && '' !== $ chunk ) { $ parts [ ] = $ chunk ; $ up = '..' !== $ chunk ; } } return $ prefix . ( $ absolute ? '/' : '' ) . implode ( '/' , $ parts ) ; }
5228	public static function createInjector ( callable ... $ applyBindings ) { $ self = new self ( ) ; foreach ( $ applyBindings as $ applyBinding ) { $ applyBinding ( $ self ) ; } return $ self -> getInjector ( ) ; }
10266	public function setRotation ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'rotation' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> rotation = $ pValue ; } return $ this ; }
6961	public static function J ( $ year ) { $ jd = static :: J2000 ( ) -> jd + ( $ year - 2000 ) * static :: DaysJulianYear ; $ epoch = new static ( $ jd ) ; $ epoch -> type = YearType :: Julian ( ) ; return $ epoch ; }
9453	public function getCollection ( $ index , array $ filters = null , array $ queries = null , array $ fieldWeights = null , $ limit = 20 , $ offset = 0 , $ countableAttributes = null ) { $ result = $ this -> query ( $ index , $ filters , $ queries , $ fieldWeights , $ limit , $ offset ) ; if ( is_array ( $ result ) ) { $ i = 0 ; if ( $ countableAttributes ) { foreach ( $ countableAttributes as $ attributeName ) { $ i ++ ; $ result [ 0 ] [ 'attributes' ] [ 'countable' ] [ $ attributeName ] = new CountableCollection ( $ result [ $ i ] , $ attributeName ) ; } } for ( $ l = 1 ; $ l <= $ i ; $ l ++ ) { unset ( $ result [ $ l ] ) ; } $ collection = $ this -> factoryCollection ( $ result ) ; return $ collection ; } }
3618	public function setFanModeOnWithTimer ( $ mode , $ serial_number = NULL ) { $ modes = explode ( ',' , $ mode ) ; $ mode = $ modes [ 0 ] ; $ timer = ( int ) $ modes [ 1 ] ; return $ this -> _setFanMode ( $ mode , NULL , $ timer , $ serial_number ) ; }
5591	public function fetchResponse ( $ url , $ encoding ) { if ( ! in_array ( $ encoding -> getMethod ( ) , array ( 'POST' , 'PUT' ) ) ) { $ url -> addRequestParameters ( $ encoding ) ; $ encoding -> clear ( ) ; } $ response = $ this -> fetchWhileRedirected ( $ url , $ encoding ) ; if ( $ headers = $ response -> getHeaders ( ) ) { if ( $ headers -> isChallenge ( ) ) { $ this -> authenticator -> addRealm ( $ url , $ headers -> getAuthentication ( ) , $ headers -> getRealm ( ) ) ; } } return $ response ; }
10714	public function updateById ( $ id , array $ newAttributes ) { $ model = $ this -> getById ( $ id ) ; $ results = $ model -> update ( $ newAttributes ) ; if ( ! $ results ) { throw new UpdateFailedRepositoryException ( ) ; } return $ model ; }
11196	public function __isset ( $ name ) { $ value = $ this -> find ( $ name ) ; if ( $ value !== null && ! ( $ value instanceof \ Exception ) ) { return true ; } return false ; }
5846	public function syslog ( $ message , $ severity = \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK ) { switch ( $ severity ) { case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: NOTICE : $ severity = GeneralUtility :: SYSLOG_SEVERITY_NOTICE ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: INFO : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: WARNING : $ severity = GeneralUtility :: SYSLOG_SEVERITY_WARNING ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR : $ severity = GeneralUtility :: SYSLOG_SEVERITY_ERROR ; break ; } GeneralUtility :: sysLog ( $ message , 'image_autoresize' , $ severity ) ; }
10585	public static function createFile ( string $ name , int $ maxAttempts = 10 ) : entity \ FileEntity { $ tmpdir = static :: getDir ( ) ; $ name = \ sndsgd \ Fs :: sanitizeName ( $ name ) ; $ pos = strrpos ( $ name , "." ) ; if ( $ pos === false ) { $ extension = "" ; } else { $ extension = substr ( $ name , $ pos ) ; $ name = substr ( $ name , 0 , $ pos ) ; } $ attempts = 1 ; do { if ( $ attempts > $ maxAttempts ) { throw new \ RuntimeException ( "failed to create temp file; " . "reached max number ($maxAttempts) of attempts" ) ; } $ rand = \ sndsgd \ Str :: random ( 10 ) ; $ path = "$tmpdir/$name-$rand$extension" ; $ attempts ++ ; } while ( file_exists ( $ path ) ) ; touch ( $ path ) ; $ file = new entity \ FileEntity ( $ path ) ; static :: registerEntity ( $ file ) ; return $ file ; }
2255	protected function eliminateNestedPages ( $ arrPages , $ strTable = null , $ blnSorting = false ) { if ( empty ( $ arrPages ) || ! \ is_array ( $ arrPages ) ) { return array ( ) ; } if ( ! $ strTable ) { $ strTable = 'tl_page' ; } $ arrPages = array_intersect ( $ arrPages , $ this -> Database -> getChildRecords ( 0 , $ strTable , $ blnSorting ) ) ; $ arrPages = array_values ( array_diff ( $ arrPages , $ this -> Database -> getChildRecords ( $ arrPages , $ strTable , $ blnSorting ) ) ) ; return $ arrPages ; }
10890	public static function input ( $ prompt , $ default = null ) { $ ret = false ; while ( ! $ ret ) { if ( $ prompt ) { echo $ prompt ; if ( $ default ) echo " (" . $ default . ")" ; echo ": " ; } $ ret = trim ( fgets ( STDIN ) ) ; if ( ! $ ret && $ default !== null ) return $ default ; } return trim ( $ ret ) ; }
12695	static function getVendorDir ( $ vendorPrefix = 'vendor' ) { if ( is_dir ( __DIR__ . '/../../../composer' ) && is_file ( __DIR__ . '/../../../autoload.php' ) ) { return realpath ( __DIR__ . '/../../..' ) ; } if ( is_dir ( __DIR__ . "/../$vendorPrefix/composer" ) && is_file ( __DIR__ . "/../$vendorPrefix/autoload.php" ) ) { return realpath ( __DIR__ . "/../$vendorPrefix" ) ; } return false ; }
3193	public function load ( ) { if ( ! $ this -> storage ) { throw new InvalidStorageException ( 'A storage must be defined in order to store the data!' ) ; } $ data = $ this -> storage -> load ( ) ; if ( isset ( $ data ) ) { if ( ! is_array ( $ data ) ) { $ data = [ self :: STORAGE_KEY_TIME_LINE => $ data , ] ; } if ( isset ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ) { $ this -> timeLine = $ this -> unserializeTimeLine ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ; } else { $ this -> timeLine = new QtiTimeLine ( ) ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ) ) { $ this -> extraTime = $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ; } else { $ this -> extraTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ) ) { $ this -> extendedTime = $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ; } else { $ this -> extendedTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ) ) { $ this -> consumedExtraTime = $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ; } else { $ this -> consumedExtraTime = 0 ; } if ( ! $ this -> timeLine instanceof TimeLine ) { throw new InvalidDataException ( 'The storage did not provide acceptable data when loading!' ) ; } } return $ this ; }
11073	public function setString ( string $ key , $ value , string $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( string ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
2986	protected function generateForm ( $ bundle , $ entity , $ metadata , $ forceOverwrite = false ) { $ this -> getFormGenerator ( $ bundle ) -> generate ( $ bundle , $ entity , $ metadata [ 0 ] , $ forceOverwrite ) ; }
1684	public function checkAdminStatus ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == '' && $ this -> User -> id == $ dc -> id ) { $ varValue = 1 ; } return $ varValue ; }
4351	private function setDebugCfg ( $ cfg ) { if ( isset ( $ cfg [ 'key' ] ) ) { $ cfg = \ array_merge ( $ cfg , $ this -> debugKeyValues ( $ cfg [ 'key' ] ) ) ; } if ( isset ( $ cfg [ 'logEnvInfo' ] ) && \ is_bool ( $ cfg [ 'logEnvInfo' ] ) ) { $ keys = \ array_keys ( $ this -> cfg [ 'logEnvInfo' ] ) ; $ cfg [ 'logEnvInfo' ] = \ array_fill_keys ( $ keys , $ cfg [ 'logEnvInfo' ] ) ; } if ( isset ( $ cfg [ 'logServerKeys' ] ) ) { $ this -> cfg [ 'logServerKeys' ] = array ( ) ; } $ this -> cfg = $ this -> debug -> utilities -> arrayMergeDeep ( $ this -> cfg , $ cfg ) ; }
2182	public function listImageSizeItem ( $ row ) { $ html = '<div class="tl_content_left">' ; $ html .= $ row [ 'media' ] ; if ( $ row [ 'width' ] || $ row [ 'height' ] ) { $ html .= ' <span style="padding-left:3px">' . $ row [ 'width' ] . 'x' . $ row [ 'height' ] . '</span>' ; } if ( $ row [ 'zoom' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">(' . $ row [ 'zoom' ] . '%)</span>' ; } $ html .= "</div>\n" ; return $ html ; }
9840	public function createSymmetricEncryptedJsonResponse ( int $ status , array $ arrayToJsonify , SharedEncryptionKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricEncryptedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
246	public function fixPrimaryKey ( $ keys ) { $ keys = ( array ) $ keys ; $ this -> primaryKey = $ keys ; foreach ( $ this -> columns as $ column ) { $ column -> isPrimaryKey = false ; } foreach ( $ keys as $ key ) { if ( isset ( $ this -> columns [ $ key ] ) ) { $ this -> columns [ $ key ] -> isPrimaryKey = true ; } else { throw new InvalidArgumentException ( "Primary key '$key' cannot be found in table '{$this->name}'." ) ; } } }
7887	protected function parse ( ) { $ log = [ ] ; $ pattern = "/\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\].*/" ; preg_match_all ( $ pattern , $ this -> raw , $ headings ) ; $ data = preg_split ( $ pattern , $ this -> raw ) ; if ( $ data [ 0 ] < 1 ) { $ trash = array_shift ( $ data ) ; unset ( $ trash ) ; } foreach ( $ headings as $ heading ) { for ( $ i = 0 , $ j = count ( $ heading ) ; $ i < $ j ; $ i ++ ) { foreach ( $ this -> levels as $ level ) { if ( $ this -> level == $ level || $ this -> level == 'all' ) { if ( strpos ( strtolower ( $ heading [ $ i ] ) , strtolower ( '.' . $ level ) ) ) { $ log [ ] = [ 'level' => $ level , 'header' => $ heading [ $ i ] , 'stack' => $ data [ $ i ] ] ; } } } } } unset ( $ headings ) ; unset ( $ data ) ; return array_reverse ( $ log ) ; }
8170	public function recoverPassword ( ) { $ user = User :: findOne ( [ 'email' => $ this -> email ] ) ; if ( $ user != NULL ) { $ user -> password_reset_token = Yii :: $ app -> getSecurity ( ) -> generateRandomString ( ) . '_' . time ( ) ; $ user -> save ( FALSE ) ; } Mailer :: sendRecoveryMessage ( $ user ) ; Yii :: $ app -> session -> setFlash ( 'info' , 'You will receive an email with instructions on how to reset your password in a few minutes.' ) ; }
9301	public function setScheduleAhead ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`scheduleAhead` expects integer value!' ) ; } $ this -> options [ 'scheduleAhead' ] = ( int ) $ time ; return $ this ; }
7889	public function make ( $ date , $ level = 'all' ) { $ raw = $ this -> filesystem -> read ( $ date ) ; $ levels = $ this -> levels ; return new Log ( $ raw , $ levels , $ level ) ; }
1188	public function validatorClosure ( ) { return function ( $ attribute , $ value , $ parameters , BaseValidator $ validator ) { $ remoteValidator = new Validator ( $ validator ) ; $ remoteValidator -> validate ( $ value , $ parameters ) ; return $ attribute ; } ; }
4629	protected function prepareRequestParameters ( ) { if ( $ this -> command -> hasParameters ( ) ) { $ this -> query = http_build_query ( $ this -> command -> getParameters ( ) , '' , '&' , PHP_QUERY_RFC3986 ) ; } return $ this ; }
5003	protected function getConfig ( $ services , $ name ) { $ defaults = [ 'service' => 'EventManager' , 'configure' => true , 'identifiers' => [ $ name ] , 'event' => '\Zend\EventManager\Event' , 'listeners' => [ ] , ] ; $ config = $ services -> get ( 'Config' ) ; $ config = isset ( $ config [ 'event_manager' ] [ $ name ] ) ? $ config [ 'event_manager' ] [ $ name ] : [ ] ; $ config = array_replace_recursive ( $ defaults , $ config ) ; return $ config ; }
9082	private static function parseRemoteHost ( Request & $ request , $ serverVars = array ( ) ) { if ( isset ( $ serverVars [ 'REMOTE_ADDR' ] ) ) { $ request -> remoteHost = $ serverVars [ 'REMOTE_ADDR' ] ; } if ( isset ( $ serverVars [ 'HTTP_X_FORWARDED_FOR' ] ) ) { $ request -> remoteHost = $ serverVars [ 'HTTP_X_FORWARDED_FOR' ] ; } }
12617	public function removeAttribute ( string $ attributeName ) { if ( isset ( $ this -> attributes [ $ attributeName ] ) ) unset ( $ this -> attributes [ $ attributeName ] ) ; }
7946	public function getLineProperties ( $ id , $ line ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ line ) throw new BadMethodCallException ( 'Missing parameter $line.' ) ; try { $ r = $ this -> get ( 'xdsl/' . $ id . '/lines/' . $ line ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
5334	protected function sign ( $ privateKey , $ parameters ) { if ( preg_match ( '/-----BEGIN (RSA )?PRIVATE KEY-----(.*)-----END (RSA )?PRIVATE KEY-----/si' , $ privateKey , $ matches ) ) { $ key = $ matches [ 2 ] ; $ key = preg_replace ( '/\s*/s' , '' , $ key ) ; $ key = chunk_split ( $ key , 64 , "\n" ) ; $ key = "-----BEGIN PRIVATE KEY-----\n" . $ key . '-----END PRIVATE KEY-----' ; $ digest = $ this -> sha512Asn1 ( $ this -> encodeParameters ( $ parameters ) ) ; if ( @ openssl_private_encrypt ( $ digest , $ signature , $ key ) ) { return base64_encode ( $ signature ) ; } throw new \ InvalidArgumentException ( 'Unable to sign the request, this has to do with the provided (invalid) private key.' ) ; } throw new \ InvalidArgumentException ( 'Invalid private key.' ) ; }
10804	public function getBackOfficeUsersAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ users = $ melisPageHistoricTable -> getUsers ( ) -> toArray ( ) ; return new JsonModel ( array ( 'users' => $ users , ) ) ; }
8858	private function _absoluteSymlinkWithFallback ( string $ originDir , string $ targetDir ) : string { try { $ this -> _symlink ( $ originDir , $ targetDir ) ; $ method = AssetsInstallCommand :: METHOD_ABSOLUTE_SYMLINK ; } catch ( IOException $ e ) { $ method = $ this -> _hardCopy ( $ originDir , $ targetDir ) ; } return $ method ; }
5870	protected static function getBasicMetadata ( $ fileName ) { $ extension = strtolower ( substr ( $ fileName , strrpos ( $ fileName , '.' ) + 1 ) ) ; $ metadata = [ ] ; if ( GeneralUtility :: inList ( 'jpg,jpeg,tif,tiff' , $ extension ) && function_exists ( 'exif_read_data' ) ) { $ exif = @ exif_read_data ( $ fileName ) ; if ( $ exif ) { $ metadata = $ exif ; $ metadata [ 'ImageDescription' ] = static :: safeUtf8Encode ( $ metadata [ 'ImageDescription' ] ) ; if ( isset ( $ metadata [ 'GPSLatitude' ] ) && is_array ( $ metadata [ 'GPSLatitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLatitudeRef' ] ) ? $ metadata [ 'GPSLatitudeRef' ] : 'N' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLatitude' ] ) ; $ decimal *= $ reference === 'N' ? 1 : - 1 ; $ metadata [ 'GPSLatitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSLongitude' ] ) && is_array ( $ metadata [ 'GPSLongitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLongitudeRef' ] ) ? $ metadata [ 'GPSLongitudeRef' ] : 'E' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLongitude' ] ) ; $ decimal *= $ reference === 'E' ? 1 : - 1 ; $ metadata [ 'GPSLongitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSAltitude' ] ) ) { $ rationalParts = explode ( '/' , $ metadata [ 'GPSAltitude' ] ) ; if ( ! empty ( $ rationalParts [ 1 ] ) ) { $ metadata [ 'GPSAltitudeDecimal' ] = $ rationalParts [ 0 ] / $ rationalParts [ 1 ] ; } else { $ metadata [ 'GPSAltitudeDecimal' ] = 0 ; } } } $ imageinfo = [ ] ; if ( function_exists ( 'iptcparse' ) && getimagesize ( $ fileName , $ imageinfo ) ) { if ( isset ( $ imageinfo [ 'APP13' ] ) ) { $ data = iptcparse ( $ imageinfo [ 'APP13' ] ) ; $ mapping = [ '2#005' => 'Title' , '2#025' => 'Keywords' , '2#040' => 'Instructions' , '2#080' => 'Creator' , '2#085' => 'CreatorFunction' , '2#090' => 'City' , '2#092' => 'Location' , '2#095' => 'Region' , '2#100' => 'CountryCode' , '2#101' => 'Country' , '2#103' => 'IdentifierWork' , '2#105' => 'CreatorTitle' , '2#110' => 'Credit' , '2#115' => 'Source' , '2#116' => 'Copyright' , '2#120' => 'Description' , '2#122' => 'DescriptionAuthor' , ] ; foreach ( $ mapping as $ iptcKey => $ metadataKey ) { if ( isset ( $ data [ $ iptcKey ] ) ) { $ metadata [ 'IPTC' . $ metadataKey ] = static :: safeUtf8Encode ( $ data [ $ iptcKey ] [ 0 ] ) ; } } } } } return $ metadata ; }
26	protected function getRemoteContents ( $ originUrl , $ fileUrl , $ context , array & $ responseHeaders = null ) { try { $ e = null ; $ result = file_get_contents ( $ fileUrl , false , $ context ) ; } catch ( \ Throwable $ e ) { } catch ( \ Exception $ e ) { } $ responseHeaders = isset ( $ http_response_header ) ? $ http_response_header : array ( ) ; if ( null !== $ e ) { throw $ e ; } return $ result ; }
7373	public function updatePasswordAction ( Request $ request ) { $ user = $ this -> getUser ( ) ; $ form = $ this -> createForm ( ChangePasswordType :: class ) ; $ form -> bind ( $ request ) ; $ data = $ form -> getData ( ) ; $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ current = $ encoder -> encodePassword ( $ data [ 'current' ] , $ user -> getSalt ( ) ) ; if ( $ current !== $ user -> getPassword ( ) ) { $ form -> get ( 'current' ) -> addError ( new FormError ( 'Current password is not correct' ) ) ; } if ( $ form -> isValid ( ) ) { $ user -> setPassword ( $ encoder -> encodePassword ( $ data [ 'password' ] , $ user -> getSalt ( ) ) ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your password has been changed.' ) ; return new JsonReloadResponse ( ) ; } return new JsonErrorResponse ( $ form ) ; }
4007	public function createMetaModel ( CreateMetaModelEvent $ event ) { if ( $ event -> getMetaModel ( ) !== null ) { return ; } if ( isset ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ) { $ event -> setMetaModel ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ; return ; } $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'tableName=:tableName' ) -> setParameter ( 'tableName' , $ event -> getMetaModelName ( ) ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ table [ 'system_columns' ] = $ this -> systemColumns ; $ this -> createInstance ( $ event , $ table ) ; } }
8741	protected function i18nDeleteQuery ( $ withGlobalScopes = true ) { $ subQuery = $ withGlobalScopes ? $ this -> toBase ( ) : $ this -> getQuery ( ) ; $ subQuery -> select ( $ this -> model -> getQualifiedKeyName ( ) ) ; return $ this -> i18nQuery ( ) -> whereIn ( $ this -> model -> getForeignKey ( ) , $ subQuery -> pluck ( $ this -> model -> getKeyName ( ) ) ) ; }
5916	public function resetPassword ( $ hash , $ password ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'hash' => $ hash , 'password' => $ password ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/resetpassword' , $ parameters ) ; return $ result ; }
4965	public function fromFiles ( $ name = null , $ default = null ) { if ( $ name === null ) { return $ this -> event -> getRequest ( ) -> getFiles ( $ name , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getFiles ( $ name , $ default ) ; }
3179	public function getQtiItems ( \ core_kernel_classes_Class $ itemClass , $ format = 'list' , $ search = '' , $ offset = 0 , $ limit = 30 ) { $ propertyFilters = [ ] ; if ( $ this -> hasOption ( self :: ITEM_MODEL_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_MODEL_URI ] = $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) ; } if ( $ this -> hasOption ( self :: ITEM_CONTENT_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_CONTENT_URI ] = '*' ; } if ( is_string ( $ search ) && strlen ( trim ( $ search ) ) > 0 ) { $ propertyFilters [ self :: LABEL_URI ] = $ search ; } if ( is_array ( $ search ) ) { foreach ( $ search as $ uri => $ value ) { if ( is_string ( $ uri ) && ( is_string ( $ value ) && strlen ( trim ( $ value ) ) > 0 ) || ( is_array ( $ value ) && count ( $ value ) > 0 ) ) { $ propertyFilters [ $ uri ] = $ value ; } } } $ result = [ ] ; if ( in_array ( $ format , self :: $ formats ) ) { $ itemLookup = $ this -> getServiceLocator ( ) -> get ( self :: SERVICE_ID . '/' . $ format ) ; if ( ! is_null ( $ itemLookup ) && $ itemLookup instanceof ItemLookup ) { $ result = $ itemLookup -> getItems ( $ itemClass , $ propertyFilters , $ offset , $ limit ) ; } } return $ result ; }
8143	public function getLexer ( ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 1.25 and will be removed in 2.0.' , __FUNCTION__ ) , E_USER_DEPRECATED ) ; if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer ; }
10905	public function getList ( $ asStrings = false ) { $ list = scandir ( $ this -> path ) ; if ( $ asStrings === true ) { return array_diff ( $ list , [ "." , ".." ] ) ; } $ ret = [ ] ; foreach ( $ list as $ name ) { if ( $ name === "." || $ name === ".." ) { continue ; } $ path = $ this -> path . DIRECTORY_SEPARATOR . $ name ; $ ret [ ] = ( is_dir ( $ path ) ) ? new static ( $ path ) : new FileEntity ( $ path ) ; } return $ ret ; }
2572	protected function loadSessionHandler ( $ params ) { if ( isset ( $ params [ 'sessionHandler' ] ) && $ params [ 'sessionHandler' ] instanceof Session \ Handler \ HandlerInterface ) { $ this -> sessionHandler = $ params [ 'sessionHandler' ] ; } }
10535	protected function _getData ( $ key ) { $ store = $ this -> _getDataStore ( ) ; try { $ result = $ this -> _containerGet ( $ store , $ key ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ key ) ; } return $ result ; }
9780	private function getLength ( $ value ) : int { if ( is_array ( $ value ) || $ value instanceof \ Countable ) return count ( $ value ) ; if ( $ value instanceof \ Traversable ) return iterator_count ( $ value ) ; if ( is_string ( $ value ) ) return mb_strlen ( $ value ) ; throw new \ InvalidArgumentException ( "The specified value is not iterable: $value" ) ; }
7160	public function buildSaleView ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> initialize ( $ sale , $ options ) ; $ this -> amountCalculator -> calculateSale ( $ sale ) ; $ grossResult = $ sale -> getGrossResult ( ) ; $ this -> view -> setGross ( new TotalView ( $ this -> formatter -> currency ( $ grossResult -> getGross ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getDiscount ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getBase ( $ this -> view -> isAti ( ) ) ) ) ) ; $ finalResult = $ sale -> getFinalResult ( ) ; $ this -> view -> setFinal ( new TotalView ( $ this -> formatter -> currency ( $ finalResult -> getBase ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTax ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTotal ( ) ) ) ) ; if ( $ this -> options [ 'private' ] && null !== $ margin = $ this -> marginCalculator -> calculateSale ( $ sale ) ) { $ prefix = $ margin -> isAverage ( ) ? '~' : '' ; $ this -> view -> setMargin ( new MarginView ( $ prefix . $ this -> formatter -> currency ( $ margin -> getAmount ( ) ) , $ prefix . $ this -> formatter -> percent ( $ margin -> getPercent ( ) ) ) ) ; $ this -> view -> vars [ 'show_margin' ] = true ; } $ this -> buildSaleItemsLinesViews ( $ sale ) ; $ this -> buildSaleDiscountsLinesViews ( $ sale ) ; $ this -> buildShipmentLine ( $ sale ) ; $ this -> buildSaleTaxesViews ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> buildSaleView ( $ sale , $ this -> view , $ this -> options ) ; } $ columnsCount = 6 ; if ( $ this -> view -> vars [ 'show_availability' ] ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_discounts' ] = 0 < count ( $ grossResult -> getDiscountAdjustments ( ) ) ) { $ columnsCount += 3 ; } if ( $ this -> view -> vars [ 'show_taxes' ] = 1 < count ( $ finalResult -> getTaxAdjustments ( ) ) ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_margin' ] ) { $ columnsCount ++ ; } if ( $ this -> options [ 'editable' ] ) { $ columnsCount ++ ; } $ this -> view -> vars [ 'columns_count' ] = $ columnsCount ; return $ this -> view ; }
12542	public function get ( ) : \ TheCMSThread \ Core \ Main \ View { if ( $ this -> getLink ( ) == '/' ) { $ this -> details = Model \ Page :: find ( 1 ) ; } else { $ this -> details = Model \ Page :: where ( 'link' , $ this -> getLink ( ) ) ; if ( $ this -> auth -> allow ( [ "min" => 3 , "max" => 1 ] ) === false ) { $ this -> details -> where ( 'status' , true ) ; } $ this -> details = $ this -> details -> first ( ) ; } if ( $ this -> details === null ) { $ this -> details = false ; } return $ this ; }
2614	public function getWebsiteName ( ) { $ websites = $ this -> storeManager -> getWebsites ( ) ; $ websiteName = 'Not set.' ; foreach ( $ websites as $ website ) { if ( $ website -> getIsDefault ( ) ) { $ websiteName = $ website -> getName ( ) ; } } return $ websiteName ; }
204	public static function moveCursorTo ( $ column , $ row = null ) { if ( $ row === null ) { echo "\033[" . ( int ) $ column . 'G' ; } else { echo "\033[" . ( int ) $ row . ';' . ( int ) $ column . 'H' ; } }
10508	private function registerChecker ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogChecker :: class , Utilities \ LogChecker :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.checker' , Contracts \ Utilities \ LogChecker :: class ) ; }
9909	public function setPositionXL ( $ positionXL ) { if ( ! isset ( self :: $ positionXLref [ $ positionXL ] ) ) { return false ; } $ this -> position = self :: $ positionXLref [ $ positionXL ] ; return true ; }
10074	static function init ( ) { if ( self :: $ initialized == false ) { self :: $ UPDATE = new SynchronizationMode ( 1 ) ; self :: $ IGNORE = new SynchronizationMode ( 2 ) ; self :: $ initialized = true ; } }
6109	public function permAssign ( $ permid , $ permvalue ) { return $ this -> getParent ( ) -> channelPermAssign ( $ this -> getId ( ) , $ permid , $ permvalue ) ; }
4338	private function removeHideIfEmptyGroups ( & $ log ) { $ groupStack = array ( ) ; $ groupStackCount = 0 ; $ removed = false ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ entry = $ log [ $ i ] ; $ groupStack [ ] = array ( 'i' => $ i , 'meta' => ! empty ( $ entry [ 2 ] ) ? $ entry [ 2 ] : array ( ) , 'hasEntries' => false , ) ; $ groupStackCount ++ ; } elseif ( $ method == 'groupEnd' ) { $ group = \ end ( $ groupStack ) ; if ( ! $ group [ 'hasEntries' ] && ! empty ( $ group [ 'meta' ] [ 'hideIfEmpty' ] ) ) { unset ( $ log [ $ group [ 'i' ] ] ) ; unset ( $ log [ $ i ] ) ; $ removed = true ; } \ array_pop ( $ groupStack ) ; $ groupStackCount -- ; } elseif ( $ groupStack ) { $ groupStack [ $ groupStackCount - 1 ] [ 'hasEntries' ] = true ; } } if ( $ removed ) { $ log = \ array_values ( $ log ) ; } }
8303	public function assertBool ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_bool ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be a boolean value." ) ; } return $ this ; }
5782	public function routeGetDelete ( Request $ request , Response $ response , $ args ) { if ( ! $ this -> authorization -> isAuthorized ( ROLES_DELETE_RESOURCE ) ) { throw new \ Exception ( 'No permission.' ) ; } $ primaryKey = $ args [ ROUTEARG_PRIMARY_KEY ] ; $ tableName = $ this -> tableMapper -> getFormalTableName ( false ) ; $ primaryKeyColumnName = $ this -> tableMapper -> getPrimaryKeyColumnName ( ) ; try { $ this -> tableMapper -> deleteByPrimaryKey ( $ primaryKey ) ; $ this -> events -> insertInfo ( EVENT_ROLE_DELETE , [ $ primaryKeyColumnName => $ primaryKey ] ) ; SlimPostgres :: setAdminNotice ( "Deleted $tableName $primaryKey" ) ; } catch ( Exceptions \ UnallowedActionException $ e ) { $ this -> events -> insertWarning ( EVENT_UNALLOWED_ACTION , [ 'error' => $ e -> getMessage ( ) ] ) ; SlimPostgres :: setAdminNotice ( $ e -> getMessage ( ) , 'failure' ) ; } catch ( Exceptions \ QueryResultsNotFoundException $ e ) { define ( 'EVENT_QUERY_NO_RESULTS' , 'Query Results Not Found' ) ; $ this -> events -> insertWarning ( EVENT_QUERY_NO_RESULTS , $ e -> getMessage ( ) ) ; SlimPostgres :: setAdminNotice ( $ e -> getMessage ( ) , 'failure' ) ; } catch ( Exceptions \ QueryFailureException $ e ) { $ this -> events -> insertError ( EVENT_QUERY_FAIL , [ 'error' => $ e -> getMessage ( ) ] ) ; SlimPostgres :: setAdminNotice ( 'Delete Failed' , 'failure' ) ; } return $ response -> withRedirect ( $ this -> router -> pathFor ( SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ) ) ; }
9428	public function updateCMSFields ( FieldList $ fields ) { $ fields -> insertAfter ( Tab :: create ( 'Icon' , $ this -> owner -> fieldLabel ( 'Icon' ) ) , 'Main' ) ; $ fields -> addFieldsToTab ( 'Root.Icon' , [ FontIconField :: create ( 'FontIcon' , $ this -> owner -> fieldLabel ( 'FontIcon' ) ) , ColorField :: create ( 'FontIconColor' , $ this -> owner -> fieldLabel ( 'FontIconColor' ) ) ] ) ; }
1130	public function makeFirstChildOf ( $ node ) { if ( $ node -> children ( ) -> count ( ) == 0 ) return $ this -> makeChildOf ( $ node ) ; return $ this -> moveToLeftOf ( $ node -> children ( ) -> first ( ) ) ; }
1612	private function _setCriteriaIdByType ( $ criteria , Element $ type , $ id ) { switch ( $ type :: className ( ) ) { case 'Entry' : $ criteria -> sectionId = $ id ; break ; case 'Category' : $ criteria -> groupId = $ id ; break ; } }
12438	public function get ( $ id ) { if ( isset ( $ this -> children [ $ id ] ) ) { return $ this -> children [ $ id ] ; } throw new FormalException ( "Unknown form field '$id' on form '" . get_called_class ( ) . "'. Available fields are: " . implode ( ', ' , array_keys ( $ this -> children ) ) ) ; }
12085	public function store ( $ objectURI = null ) { $ this -> setPropertyValue ( "media_owner" , $ this -> user -> getPropertyValue ( "user_name_id" ) ) ; if ( ! $ this -> saveObject ( $ objectURI , $ this -> getObjectType ( ) ) ) { return false ; } return true ; }
10978	protected function setVerificationCode ( $ code = null ) { $ this -> { Config :: get ( 'verifier.store_column' ) } = $ code ; if ( $ code ) { $ this -> { Config :: get ( 'verifier.flag_column' ) } = false ; } else { $ this -> { Config :: get ( 'verifier.flag_column' ) } = true ; } $ this -> save ( ) ; }
8019	public function getClient ( ) { if ( $ this -> _client === null ) { $ settings = [ 'key' => $ this -> key , 'secret' => $ this -> secret ] ; if ( $ this -> enableV4 ) $ settings [ 'signature' ] = 'v4' ; $ this -> _client = S3Client :: factory ( $ settings ) ; } return $ this -> _client ; }
3553	protected function set ( $ key , $ value , $ group = 'default' ) { $ this -> setMetaKey ( $ key ) ; $ this -> setValue ( $ value ) ; $ this -> setMetaGroup ( $ group ) ; }
10696	public function toArray ( ) : array { if ( empty ( $ this -> output ) ) { $ problem = [ 'type' => $ this -> type ? ( string ) $ this -> type : 'about:blank' ] ; if ( $ this -> title ) { $ problem [ 'title' ] = $ this -> title ; } if ( $ this -> status ) { $ problem [ 'status' ] = $ this -> status ; } if ( $ this -> detail ) { $ problem [ 'detail' ] = $ this -> detail ; } if ( $ this -> instance ) { $ problem [ 'instance' ] = ( string ) $ this -> instance ; } $ this -> output = array_merge ( $ problem , $ this -> extensions ) ; } return $ this -> output ; }
4995	public function getActiveFormNext ( ) { $ key = null ; $ actualKey = $ this -> getActiveFormActual ( ) ; if ( isset ( $ actualKey ) ) { $ forms = array_keys ( $ this -> forms ) ; $ formsFlip = array_flip ( $ forms ) ; $ index = $ formsFlip [ $ actualKey ] ; if ( $ index < count ( $ forms ) - 1 ) { $ key = $ forms [ $ index + 1 ] ; } } return $ key ; }
6968	protected function calculateGoodLine ( Model \ DocumentLineInterface $ line ) : ? Amount { if ( $ line -> getType ( ) !== Model \ DocumentLineTypes :: TYPE_GOOD ) { throw new LogicException ( sprintf ( "Expected document line with type '%s'." , Model \ DocumentLineTypes :: TYPE_GOOD ) ) ; } if ( null === $ item = $ line -> getSaleItem ( ) ) { throw new LogicException ( "Document can't be recalculated." ) ; } $ result = $ this -> calculator -> calculateSaleItem ( $ item , $ line -> getQuantity ( ) ) ; $ this -> syncLineWithResult ( $ line , $ result ) ; if ( $ item -> isPrivate ( ) ) { return null ; } return $ result ; }
6019	public function removeSite ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/deployment/' . $ id . '' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
11958	public function remove ( $ element ) { if ( ! $ this -> contains ( $ element ) ) { return false ; } $ this -> offsetUnset ( $ this -> indexOf ( $ element ) ) ; return true ; }
10381	protected static function unify_files ( $ params , $ data = '' ) { $ type = $ params [ 'type' ] ; $ routes = $ params [ 'routes' ] ; $ extension = ( 'style' == $ type ) ? '.css' : '.js' ; $ hash = sha1 ( implode ( '' , $ params [ 'files' ] ) ) ; $ min_file = $ routes [ 'path' ] . $ hash . $ extension ; if ( ! is_file ( $ min_file ) || self :: $ changes ) { foreach ( $ params [ 'paths' ] as $ id => $ path ) { if ( isset ( $ params [ 'urls' ] [ $ id ] ) ) { $ url = $ params [ 'urls' ] [ $ id ] ; $ path = $ routes [ 'path' ] . $ params [ 'files' ] [ $ id ] ; $ data .= self :: save_external_file ( $ url , $ path ) ; } $ data .= file_get_contents ( $ path ) ; } $ data = ( self :: $ minify ) ? self :: compress_files ( $ data ) : $ data ; self :: save_file ( $ min_file , $ data ) ; } self :: set_processed_files ( ) ; return self :: set_new_params ( $ type , $ hash , $ routes [ 'url' ] , $ extension ) ; }
11921	public static function arrayRecursiveDiff ( $ aArray1 , $ aArray2 ) { $ aReturn = array ( ) ; foreach ( $ aArray1 as $ mKey => $ mValue ) { if ( array_key_exists ( $ mKey , $ aArray2 ) ) { if ( is_array ( $ mValue ) ) { $ aRecursiveDiff = self :: arrayRecursiveDiff ( $ mValue , $ aArray2 [ $ mKey ] ) ; if ( count ( $ aRecursiveDiff ) ) { $ aReturn [ $ mKey ] = $ aRecursiveDiff ; } } else { if ( $ mValue != $ aArray2 [ $ mKey ] ) { $ aReturn [ $ mKey ] = $ mValue ; } } } else { $ aReturn [ $ mKey ] = $ mValue ; } } return $ aReturn ; }
9447	public function getSymlinks ( Container $ app ) { $ symlinks = [ ] ; if ( $ this -> getPublicPath ( $ app ) ) { $ symlinks [ $ this -> getPublicPath ( $ app ) ] = 'packs/' . $ this -> _ns ( ) ; } return $ symlinks ; }
8001	public function calculateChallengeResponseData ( HashCredentialInterface $ hash_credential , $ data ) { $ padded_hash = str_pad ( $ hash_credential -> getValue ( ) , static :: DESL_FULL_KEY_LENGTH , static :: NULL_PAD_CHARACTER ) ; $ key_blocks = str_split ( $ padded_hash , static :: DESL_KEY_BLOCK_SEGMENT_LENGTH ) ; $ binary_data = array_reduce ( $ key_blocks , function ( $ result , $ key_block ) use ( $ data ) { return $ result . $ this -> des_encrypter -> encrypt ( $ key_block , $ data , CipherMode :: ECB , '' ) ; } , '' ) ; return $ binary_data ; }
12857	function giveBuiltInQueue ( iQueueDriver $ queueDriver ) { if ( $ this -> builtinQueue ) throw new exImmutable ( sprintf ( 'Built-in Queue (%s) is given.' , \ Poirot \ Std \ flatten ( $ this -> builtinQueue ) ) ) ; $ this -> builtinQueue = $ queueDriver ; return $ this ; }
11002	public function setRedirect ( $ hostname ) { if ( ! empty ( $ hostname ) ) { $ this -> redirect = new URL ( $ hostname ) ; $ this -> redirect -> set ( 'path' , rtrim ( $ this -> redirect -> path , '/' ) ) ; } else $ this -> redirect = false ; return $ this ; }
12247	public function getNodeByName ( $ strXpath , $ strName ) { $ varResult = $ this -> xpath ( $ strXpath . "[@name='" . $ strName . "']" ) ; if ( $ varResult !== false ) { return reset ( $ varResult ) ; } else { return false ; } }
8175	protected function optimizePrintNode ( Twig_NodeInterface $ node , Twig_Environment $ env ) { if ( ! $ node instanceof Twig_Node_Print ) { return $ node ; } $ exprNode = $ node -> getNode ( 'expr' ) ; if ( $ exprNode instanceof Twig_Node_Expression_BlockReference || $ exprNode instanceof Twig_Node_Expression_Parent ) { $ exprNode -> setAttribute ( 'output' , true ) ; return $ exprNode ; } return $ node ; }
333	public function add ( $ key , $ value , $ duration = 0 , $ dependency = null ) { if ( $ dependency !== null && $ this -> serializer !== false ) { $ dependency -> evaluateDependency ( $ this ) ; } if ( $ this -> serializer === null ) { $ value = serialize ( [ $ value , $ dependency ] ) ; } elseif ( $ this -> serializer !== false ) { $ value = call_user_func ( $ this -> serializer [ 0 ] , [ $ value , $ dependency ] ) ; } $ key = $ this -> buildKey ( $ key ) ; return $ this -> addValue ( $ key , $ value , $ duration ) ; }
12531	public function getStatus ( $ applyId ) { $ params = [ 'apply_id' => intval ( $ applyId ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_APPLYSTATUS , $ params ] ) ; }
8694	public static function parse ( $ size , $ fallbackUnits = null ) { preg_match ( '/^(\d+)[.,]?(\d*)\s*(\w*)$/' , $ size , $ matches ) ; if ( empty ( $ matches [ 1 ] ) || ( empty ( $ matches [ 3 ] ) && null === $ fallbackUnits ) ) { throw new \ UnexpectedValueException ( "Unable to parse : '{$size}'" ) ; } $ oSize = $ matches [ 1 ] ; if ( ! empty ( $ matches [ 2 ] ) ) { $ oSize .= '.' . $ matches [ 2 ] ; } $ oSize = ( float ) $ oSize ; $ unit = strtolower ( empty ( $ matches [ 3 ] ) ? $ fallbackUnits : $ matches [ 3 ] ) ; $ byteMultiplier = 1 ; if ( 'b' === substr ( $ unit , - 1 ) ) { $ byteMultiplier = 8 ; $ unit = substr ( $ unit , 0 , - 1 ) . 'o' ; } if ( ! array_key_exists ( $ unit , self :: getBinarySizes ( ) ) ) { throw new \ UnexpectedValueException ( "Unexpected unit {$unit}" ) ; } return ( int ) ( $ oSize * self :: getBinarySizes ( ) [ $ unit ] * $ byteMultiplier ) ; }
4890	public function renderPage ( PageInterface $ page , $ vars = array ( ) ) { return $ this -> render ( $ this -> getPageManager ( ) -> getTemplate ( $ page ) , $ vars + array ( 'page' => $ page , 'id' => $ page -> getId ( ) , ) ) ; }
12348	protected function getConnectionInitializer ( OptionsInterface $ options , $ callable ) { if ( ! is_callable ( $ callable ) ) { $ class = get_called_class ( ) ; throw new \ InvalidArgumentException ( "$class expects a valid callable" ) ; } $ option = $ this ; return function ( $ parameters = null ) use ( $ callable , $ options , $ option ) { $ connection = call_user_func ( $ callable , $ options , $ parameters ) ; if ( ! $ connection instanceof AggregateConnectionInterface ) { $ class = get_class ( $ option ) ; throw new \ InvalidArgumentException ( "$class expects a valid connection type returned by callable initializer" ) ; } return $ connection ; } ; }
5663	private function dequote ( $ quoted ) { if ( preg_match ( '/^(\'([^\']*)\'|"([^"]*)")$/' , $ quoted , $ matches ) ) { return isset ( $ matches [ 3 ] ) ? $ matches [ 3 ] : $ matches [ 2 ] ; } return $ quoted ; }
12865	public function clearQuota ( ) { $ appid = $ this -> getAccessToken ( ) -> getAppId ( ) ; return $ this -> parseJSON ( 'json' , [ self :: API_CLEAR_QUOTA , compact ( 'appid' ) ] ) ; }
6333	public function validateChecksum ( $ string ) { $ xml = new \ SimpleXMLElement ( $ string ) ; $ checksum = ( string ) $ xml -> Authentication -> Checksum ; $ original = str_replace ( $ checksum , $ this -> getMerchantPassword ( ) , $ string ) ; return md5 ( $ original ) == $ checksum ; }
7149	private function calculateAdjustment ( AdjustmentDataInterface $ adjustment , $ base ) { if ( $ adjustment -> getMode ( ) === AdjustmentModes :: MODE_PERCENT ) { return Money :: round ( $ base * $ adjustment -> getAmount ( ) / 100 , $ this -> currency ) ; } if ( $ adjustment -> getMode ( ) === AdjustmentModes :: MODE_FLAT ) { return $ adjustment -> getAmount ( ) ; } throw new InvalidArgumentException ( "Unexpected adjustment mode." ) ; }
5326	public function begin ( string $ profile ) { Craft :: beginProfile ( $ profile , Craft :: t ( 'twig-profiler' , self :: CATEGORY_PREFIX ) . TwigProfiler :: $ renderingTemplate ) ; }
4339	private function setOutputAs ( $ outputAs ) { if ( \ is_object ( $ this -> cfg [ 'outputAs' ] ) ) { $ this -> debug -> removePlugin ( $ this -> cfg [ 'outputAs' ] ) ; $ this -> cfg [ 'outputAs' ] = null ; } $ prop = null ; $ obj = null ; if ( \ is_string ( $ outputAs ) ) { $ prop = $ outputAs ; $ classname = __NAMESPACE__ . '\\Output\\' . \ ucfirst ( $ outputAs ) ; if ( \ property_exists ( $ this , $ prop ) ) { $ obj = $ this -> { $ prop } ; } elseif ( \ class_exists ( $ classname ) ) { $ obj = new $ classname ( $ this -> debug ) ; } } elseif ( $ outputAs instanceof OutputInterface ) { $ classname = \ get_class ( $ outputAs ) ; $ prefix = __NAMESPACE__ . '\\Output\\' ; if ( \ strpos ( $ classname , $ prefix ) == 0 ) { $ prop = \ substr ( $ classname , \ strlen ( $ prefix ) ) ; $ prop = \ lcfirst ( $ prop ) ; } $ obj = $ outputAs ; } if ( $ obj ) { $ this -> debug -> addPlugin ( $ obj ) ; $ this -> cfg [ 'outputAs' ] = $ obj ; if ( $ prop ) { $ this -> { $ prop } = $ obj ; } } }
12978	protected function detectMetadataDriver ( $ dir , $ configPath ) { foreach ( ( array ) $ configPath as $ cPath ) { $ path = $ dir . DS . $ cPath . DS ; if ( ( $ files = glob ( $ path . '*.dcm.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ path . '*.orm.xml' ) ) && count ( $ files ) ) { return 'simplified_xml' ; } elseif ( ( $ files = glob ( $ path . '*.dcm.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ path . '*.orm.yml' ) ) && count ( $ files ) ) { return 'simplified_yml' ; } elseif ( ( $ files = glob ( $ path . '*.php' ) ) && count ( $ files ) ) { return 'php' ; } } if ( is_dir ( $ dir . DS . $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ) ) { return 'annotation' ; } return false ; }
9737	public function setWidth ( $ pValue ) { if ( $ this -> resizeProportional && $ pValue != 0 ) { $ ratio = $ this -> height / ( $ this -> width != 0 ? $ this -> width : 1 ) ; $ this -> height = round ( $ ratio * $ pValue ) ; } $ this -> width = $ pValue ; return $ this ; }
6775	protected function updateKey ( SaleInterface $ sale ) { if ( 0 == strlen ( $ sale -> getKey ( ) ) ) { $ this -> keyGenerator -> generate ( $ sale ) ; return true ; } return false ; }
10806	protected function getConfig ( ) { $ config = array_replace ( $ this -> config , $ this -> dialect_config ) ; ksort ( $ config ) ; return $ config ; }
9842	public function createSealedJsonResponse ( int $ status , array $ arrayToJsonify , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSealedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
12818	public function transformCommandToMessage ( $ command ) { if ( ! is_object ( $ command ) ) { throw CommandTransformationException :: expectedObject ( $ command ) ; } if ( ! isset ( $ this -> commands [ get_class ( $ command ) ] ) ) { throw CommandTransformationException :: unknownCommand ( $ command , array_keys ( $ this -> commands ) ) ; } if ( $ this -> serializer instanceof EncoderInterface && ! $ this -> serializer -> supportsEncoding ( $ this -> format ) ) { throw CommandTransformationException :: unsupportedFormat ( $ command , $ this -> format ) ; } $ info = $ this -> commands [ get_class ( $ command ) ] ; return new CommandMessage ( $ info -> getVhost ( ) , $ info -> getExchange ( ) , $ this -> serializer -> serialize ( $ command , $ this -> format ) , $ info -> getRoutingKey ( ) , $ info -> getFlags ( ) , $ this -> resolveMessageAttributes ( $ command , $ info ) ) ; }
9392	protected function skipRowsClause ( ) { $ skipClause = [ ] ; foreach ( $ this -> skipRows as $ cl => $ val ) { $ skipClause [ ] = [ '<>' , $ cl , $ val ] ; } if ( count ( $ skipClause ) > 1 ) array_unshift ( $ skipClause , 'and' ) ; return $ skipClause ; }
8676	public function flip ( ) { if ( ! $ this -> items ) { return $ this -> createFrom ( [ ] ) ; } try { return $ this -> createFrom ( Thrower :: call ( 'array_flip' , $ this -> items ) ) ; } catch ( ErrorException $ e ) { throw new LogicException ( 'Only string and integer values can be flipped' ) ; } }
6917	public function isEmpty ( ) { return empty ( $ this -> subject ) || ( empty ( $ this -> customMessage ) && empty ( $ this -> paymentMessage ) && empty ( $ this -> shipmentMessage ) ) ; }
2846	public function getUrl ( $ path , array $ params = array ( ) ) { $ path = self :: MODULE_ROUTE . $ path ; $ params [ '_store' ] = $ this -> getRouteStoreId ( ) ; $ params [ '_nosid' ] = true ; return $ this -> _getUrl ( $ path , $ params ) ; }
8509	public function getPrepInstructionsForSKU ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForSKU' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForSKUResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
100	public function set ( $ prefix , $ paths ) { if ( ! $ prefix ) { $ this -> fallbackDirsPsr0 = ( array ) $ paths ; } else { $ this -> prefixesPsr0 [ $ prefix [ 0 ] ] [ $ prefix ] = ( array ) $ paths ; } }
11430	private function runRoute ( array $ routeInfo ) : Response { list ( $ _ , $ callback , $ vars ) = $ routeInfo ; $ vars = array_filter ( $ vars , function ( $ var ) { return strpos ( $ var , '_' ) !== 0 ; } , ARRAY_FILTER_USE_KEY ) ; if ( ! class_exists ( $ callback [ 0 ] ) ) { throw new ControllerNotFoundException ( 'Trying to instantiate a non existent controller (`' . $ callback [ 0 ] . '`)' ) ; } $ controller = new $ callback [ 0 ] ( $ this -> response , $ this -> session ) ; if ( ! method_exists ( $ controller , $ callback [ 1 ] ) ) { throw new ActionNotFoundException ( 'Trying to call a non existent action (`' . $ callback [ 0 ] . '::' . $ callback [ 1 ] . '`)' ) ; } return $ this -> injector -> execute ( [ $ controller , $ callback [ 1 ] ] , array_map ( 'urldecode' , $ vars ) ) ; }
9847	public function createSealedResponse ( int $ status , string $ body , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: seal ( $ body , $ key ) ) ) ) ; }
5938	public function addFunctionality ( $ item ) { if ( ! ( $ item instanceof Functionality ) ) { if ( is_array ( $ item ) ) { try { $ item = new Functionality ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Functionality. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Functionality"!' , E_USER_WARNING ) ; } } $ this -> functionalities [ ] = $ item ; return $ this ; }
8387	public function distinct ( $ distinct ) { if ( is_array ( $ distinct ) === true ) { $ this -> distinct = implode ( ', ' , $ distinct ) ; } else { $ this -> distinct = $ distinct ; } return $ this ; }
10392	protected static function parseXml ( $ xmlFile ) { $ reader = new \ XMLReader ( ) ; $ libXmlErrors = libxml_use_internal_errors ( true ) ; $ errors = array ( ) ; if ( ! $ reader -> open ( $ xmlFile ) ) { throw new XmlParserException ( $ xmlFile , array ( ) ) ; } $ current = $ root = new Document ( ) ; $ parents = array ( $ root ) ; while ( @ $ reader -> read ( ) ) { switch ( $ reader -> nodeType ) { case \ XMLReader :: ELEMENT : $ nodeName = $ reader -> name ; array_push ( $ parents , $ current ) ; $ current = $ current -> $ nodeName = new Node ( ) ; $ emptyElement = $ reader -> isEmptyElement ; if ( $ reader -> hasAttributes ) { while ( $ reader -> moveToNextAttribute ( ) ) { $ current [ $ reader -> name ] = $ reader -> value ; } } if ( ! $ emptyElement ) { break ; } case \ XMLReader :: END_ELEMENT : $ current = array_pop ( $ parents ) ; break ; case \ XMLReader :: TEXT : case \ XMLReader :: CDATA : $ current -> setContent ( ( string ) $ current . $ reader -> value ) ; break ; } } if ( count ( $ errors = libxml_get_errors ( ) ) ) { libxml_use_internal_errors ( $ libXmlErrors ) ; libxml_clear_errors ( ) ; throw new XmlParserException ( $ xmlFile , $ errors ) ; } libxml_use_internal_errors ( $ libXmlErrors ) ; return $ root -> skipRoot ( ) ; }
4831	public function retry ( ) { $ endpoint = self :: $ endpoint . '/' . $ this -> id . '/retry' ; return new self ( $ this -> client , $ this -> client -> request ( 'post' , $ endpoint ) ) ; }
10273	function updateCustomProperty ( $ mailingId , $ property ) { $ queryParameters = array ( 'name' => $ property -> key , 'value' => $ property -> value ) ; return $ this -> put ( "mailings/${mailingId}/settings/properties" , "" , $ queryParameters ) ; }
4480	public function setData ( $ data ) : void { if ( is_array ( $ data ) == false && is_string ( $ data ) == false && $ data instanceof JobData == false ) { throw new InvalidArgumentException ( sprintf ( "Job's data must be either an array, or a JobData instance, or a JSON string, %s given." , gettype ( $ data ) ) ) ; } if ( is_array ( $ data ) == true ) { $ data = new JobData ( $ data ) ; } elseif ( is_string ( $ data ) == true ) { $ data = new JobData ( json_decode ( $ data , true ) ) ; } $ this -> data = $ data ; }
6361	public function toDateInterval ( float $ duration ) : DateInterval { Preconditions :: checkState ( $ this -> dateIntervalFormat !== null , '[%s] does not support toDateInterval()' , $ this ) ; return new DateInterval ( sprintf ( $ this -> dateIntervalFormat , $ duration ) ) ; }
742	public function afterRun ( $ event ) { echo $ event -> result ; $ event -> result = null ; $ this -> owner -> view -> endCache ( ) ; }
3637	public function initApp ( ) : void { $ tmpDir = \ Swoft :: getAlias ( '@runtime' ) ; $ names = [ 'logs' , 'uploadfiles' ] ; \ output ( ) -> writeln ( 'Create runtime directories: ' . \ implode ( ',' , $ names ) ) ; foreach ( $ names as $ name ) { DirHelper :: make ( $ tmpDir . '/' . $ name ) ; } \ output ( ) -> writeln ( '<success>OK</success>' ) ; }
506	public function getMessageFormatter ( ) { if ( $ this -> _messageFormatter === null ) { $ this -> _messageFormatter = new MessageFormatter ( ) ; } elseif ( is_array ( $ this -> _messageFormatter ) || is_string ( $ this -> _messageFormatter ) ) { $ this -> _messageFormatter = Yii :: createObject ( $ this -> _messageFormatter ) ; } return $ this -> _messageFormatter ; }
2740	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippet = Config :: BLOCKING_SETTING_NAME ; $ req = $ this -> api -> hasSnippet ( $ activeVersion , $ snippet ) ; if ( $ req == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
810	private function toComparableNames ( array $ types , array $ symbolShortNames ) { $ normalized = array_map ( function ( $ type ) use ( $ symbolShortNames ) { $ type = strtolower ( $ type ) ; if ( isset ( $ symbolShortNames [ $ type ] ) ) { return $ symbolShortNames [ $ type ] ; } return $ type ; } , $ types ) ; sort ( $ normalized ) ; return $ normalized ; }
862	private static function getCache ( $ key ) { if ( ! self :: hasCache ( $ key ) ) { throw new \ OutOfBoundsException ( sprintf ( 'Unknown cache key: "%s".' , $ key ) ) ; } return self :: $ cache [ $ key ] ; }
2241	public static function getArticle ( $ varId , $ blnMultiMode = false , $ blnIsInsertTag = false , $ strColumn = 'main' ) { global $ objPage ; if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( ! $ varId ) { return '' ; } $ objRow = ArticleModel :: findByIdOrAliasAndPid ( $ varId , ( ! $ blnIsInsertTag ? $ objPage -> id : null ) ) ; if ( $ objRow === null ) { return false ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } if ( isset ( $ _GET [ 'pdf' ] ) && Input :: get ( 'pdf' ) == $ objRow -> id ) { if ( $ objRow -> printable == 1 ) { @ trigger_error ( 'Setting tl_article.printable to "1" has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } elseif ( $ objRow -> printable != '' ) { $ options = StringUtil :: deserialize ( $ objRow -> printable ) ; if ( \ is_array ( $ options ) && \ in_array ( 'pdf' , $ options ) ) { $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } } } $ objRow -> headline = $ objRow -> title ; $ objRow -> multiMode = $ blnMultiMode ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow ) ; } } $ objArticle = new ModuleArticle ( $ objRow , $ strColumn ) ; $ strBuffer = $ objArticle -> generate ( $ blnIsInsertTag ) ; if ( $ objArticle -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
11900	public function getIsMostRecent ( ) { return ! empty ( $ this -> dataInterface ) && $ this -> dataInterface -> lastDataInterfaceLog && $ this -> dataInterface -> lastDataInterfaceLog -> primaryKey === $ this -> primaryKey ; }
530	public function actionSortChangelog ( array $ what ) { if ( \ count ( $ what ) > 1 ) { $ this -> stdout ( "Currently only one simultaneous release is supported.\n" ) ; return 1 ; } $ this -> validateWhat ( $ what , [ 'framework' , 'ext' ] , false ) ; $ version = $ this -> version ? : array_values ( $ this -> getNextVersions ( $ this -> getCurrentVersions ( $ what ) , self :: PATCH ) ) [ 0 ] ; $ this -> stdout ( 'sorting CHANGELOG of ' ) ; $ this -> stdout ( reset ( $ what ) , Console :: BOLD ) ; $ this -> stdout ( ' for version ' ) ; $ this -> stdout ( $ version , Console :: BOLD ) ; $ this -> stdout ( '...' ) ; $ this -> resortChangelogs ( $ what , $ version ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; }
12648	public function get ( ) { $ arResult = [ 'status' => $ this -> status ( ) , 'data' => $ this -> data ( ) , 'message' => $ this -> message ( ) , 'code' => $ this -> code ( ) , ] ; return $ arResult ; }
288	protected function negotiateLanguage ( $ request ) { if ( ! empty ( $ this -> languageParam ) && ( $ language = $ request -> get ( $ this -> languageParam ) ) !== null ) { if ( is_array ( $ language ) ) { return reset ( $ this -> languages ) ; } if ( isset ( $ this -> languages [ $ language ] ) ) { return $ this -> languages [ $ language ] ; } foreach ( $ this -> languages as $ key => $ supported ) { if ( is_int ( $ key ) && $ this -> isLanguageSupported ( $ language , $ supported ) ) { return $ supported ; } } return reset ( $ this -> languages ) ; } foreach ( $ request -> getAcceptableLanguages ( ) as $ language ) { if ( isset ( $ this -> languages [ $ language ] ) ) { return $ this -> languages [ $ language ] ; } foreach ( $ this -> languages as $ key => $ supported ) { if ( is_int ( $ key ) && $ this -> isLanguageSupported ( $ language , $ supported ) ) { return $ supported ; } } } return reset ( $ this -> languages ) ; }
5896	public function retrieveImageTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/images/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new ImageTemplate ( $ result ) ; return $ result ; }
3373	public function indexAction ( ) { $ request = $ this -> getRequest ( ) ; $ this -> httpClient -> setMethod ( Request :: METHOD_POST ) ; $ this -> httpClient -> setParameterPost ( [ 'dsl_text' => $ request -> getPost ( 'dsl_text' ) ] ) ; $ response = $ this -> httpClient -> send ( ) ; if ( ! $ response -> isSuccess ( ) ) { throw new \ UnexpectedValueException ( 'HTTP Request failed' ) ; } $ redirect = $ this -> plugin ( 'redirect' ) ; return $ redirect -> toUrl ( 'https://yuml.me/' . $ response -> getBody ( ) ) ; }
3348	private function __preparePagedParams ( $ data , $ reverse , $ resultArr ) { $ nextParamsArr = parse_url ( $ data -> next ) ; $ prevParamsArr = parse_url ( $ data -> previous ) ; $ nextParamsArr = array_replace ( array ( 'query' => null ) , $ nextParamsArr ) ; $ prevParamsArr = array_replace ( array ( 'query' => null ) , $ prevParamsArr ) ; parse_str ( parse_url ( ! $ reverse ? $ data -> next : $ data -> previous , PHP_URL_QUERY ) , $ params ) ; if ( $ reverse ) { $ resultArr = array_reverse ( $ resultArr ) ; } return array ( 'nextParams' => $ reverse ? $ prevParamsArr : $ nextParamsArr , 'prevParams' => ! $ reverse ? $ prevParamsArr : $ nextParamsArr , 'params' => $ params , 'data' => $ resultArr , ) ; }
12208	public function getSingleWidget ( ) { if ( is_null ( $ this -> _singleWidget ) ) { $ this -> _singleWidget = false ; $ widgets = $ this -> collectorItem -> getAll ( ) ; if ( ! empty ( $ widgets ) ) { $ widget = array_shift ( $ widgets ) ; $ this -> _singleWidget = Yii :: $ app -> collectors [ 'widgets' ] -> build ( $ this , $ widget -> object ) ; } } return $ this -> _singleWidget ; }
3443	public function offsetExists ( $ offset ) { return $ this -> getAccessor ( $ offset ) || $ this -> getAccessorForLanguageField ( $ offset ) ? true : isset ( $ this -> fields [ $ offset ] ) ; }
1358	public static function create ( $ mediaType , int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , new EncoderOptions ( $ options , $ urlPrefix , $ depth ) ) ; }
921	private function fixAnnotations ( DocBlock $ doc ) { foreach ( $ doc -> getAnnotations ( ) as $ index => $ annotation ) { $ next = $ doc -> getAnnotation ( $ index + 1 ) ; if ( null === $ next ) { break ; } if ( true === $ next -> getTag ( ) -> valid ( ) ) { if ( TagComparator :: shouldBeTogether ( $ annotation -> getTag ( ) , $ next -> getTag ( ) ) ) { $ this -> ensureAreTogether ( $ doc , $ annotation , $ next ) ; } else { $ this -> ensureAreSeparate ( $ doc , $ annotation , $ next ) ; } } } return $ doc -> getContent ( ) ; }
3672	private function getPageCandidates ( string $ alias ) { $ aliases = [ $ alias ] ; while ( '/' !== $ alias && false !== strpos ( $ alias , '/' ) ) { $ alias = \ dirname ( $ alias ) ; $ aliases [ ] = $ alias ; } $ pages = $ this -> pageModelAdapter -> findByAliases ( $ aliases ) ; if ( null === $ pages ) { return null ; } $ arrPages = [ ] ; while ( $ pages -> next ( ) ) { $ objModel = $ pages -> current ( ) ; $ objPage = $ objModel -> loadDetails ( ) ; $ domain = $ objPage -> domain ? : '*' ; $ arrPages [ $ domain ] [ $ objPage -> rootLanguage ] [ ] = $ objPage ; if ( $ objPage -> rootIsFallback ) { $ arrPages [ $ domain ] [ '*' ] [ ] = $ objPage ; } } return $ arrPages ; }
9897	private function convertString ( $ string ) { $ string = substr ( $ string , 1 , - 1 ) ; if ( strlen ( $ string ) > 255 ) { throw new WriterException ( 'String is too long' ) ; } return pack ( 'C' , $ this -> ptg [ 'ptgStr' ] ) . StringHelper :: UTF8toBIFF8UnicodeShort ( $ string ) ; }
7586	public function setDestinationPath ( $ destination = null ) { if ( empty ( $ destination ) ) { $ destination = sys_get_temp_dir ( ) . '/SugarAPI' ; } $ this -> destinationPath = $ destination ; return $ this ; }
145	public function propagateLiteral ( $ decidedLiteral , $ level , $ decisions ) { $ literal = - $ decidedLiteral ; if ( ! isset ( $ this -> watchChains [ $ literal ] ) ) { return null ; } $ chain = $ this -> watchChains [ $ literal ] ; $ chain -> rewind ( ) ; while ( $ chain -> valid ( ) ) { $ node = $ chain -> current ( ) ; $ otherWatch = $ node -> getOtherWatch ( $ literal ) ; if ( ! $ node -> getRule ( ) -> isDisabled ( ) && ! $ decisions -> satisfy ( $ otherWatch ) ) { $ ruleLiterals = $ node -> getRule ( ) -> getLiterals ( ) ; $ alternativeLiterals = array_filter ( $ ruleLiterals , function ( $ ruleLiteral ) use ( $ literal , $ otherWatch , $ decisions ) { return $ literal !== $ ruleLiteral && $ otherWatch !== $ ruleLiteral && ! $ decisions -> conflict ( $ ruleLiteral ) ; } ) ; if ( $ alternativeLiterals ) { reset ( $ alternativeLiterals ) ; $ this -> moveWatch ( $ literal , current ( $ alternativeLiterals ) , $ node ) ; continue ; } if ( $ decisions -> conflict ( $ otherWatch ) ) { return $ node -> getRule ( ) ; } $ decisions -> decide ( $ otherWatch , $ level , $ node -> getRule ( ) ) ; } $ chain -> next ( ) ; } return null ; }
10983	public static function getDiskUsage ( ) { $ result = [ ] ; $ lines = explode ( "\n" , trim ( shell_exec ( 'df' ) ) ) ; array_shift ( $ lines ) ; foreach ( $ lines as & $ line ) { if ( 0 === strpos ( $ line , '/' ) ) { $ result [ ] = explode ( "\t" , $ line ) ; } } return $ result ; }
8510	public function getTransportContent ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetTransportContentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetTransportContentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetTransportContent' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetTransportContentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12291	public function findPost ( $ search ) { $ qb = $ this -> getQueryBuilder ( ) -> select ( 'p, pTrans' ) -> join ( 'p.translations' , 'pTrans' ) ; if ( ! empty ( $ search ) ) { $ qb -> where ( 'pTrans.title LIKE :search' ) -> orWhere ( 'pTrans.description LIKE :search' ) -> setParameter ( 'search' , '%' . $ search . '%' ) ; } $ qb -> orderBy ( 'p.published' , 'DESC' ) ; return $ qb -> getQuery ( ) -> getResult ( ) ; }
11663	public static function saveToFile ( $ file , $ properties ) { $ prop_string = self :: saveToString ( $ properties ) ; $ real_file = File :: asFile ( $ file ) ; if ( ! $ real_file -> exists ( ) ) { $ real_file -> touch ( ) ; } $ real_file -> setContent ( $ prop_string ) ; }
11481	public function save ( BlockManagerApprover $ approver , array $ options , $ saveCommonSlots = true ) { $ this -> contributorDefined ( ) ; $ filesystem = new Filesystem ( ) ; $ pageDir = $ this -> pagesDir . '/' . $ options [ "page" ] ; $ filesystem -> copy ( $ pageDir . '/' . $ this -> pageFile , $ pageDir . '/page.json' , true ) ; $ pageDir .= '/' . $ options [ "language" ] . '_' . $ options [ "country" ] ; if ( $ this -> seoFile != "seo.json" ) { $ sourceFile = $ pageDir . '/' . $ this -> seoFile ; $ values = json_decode ( file_get_contents ( $ sourceFile ) , true ) ; if ( array_key_exists ( "current_permalink" , $ values ) ) { $ values [ "changed_permalinks" ] [ ] = $ values [ "current_permalink" ] ; unset ( $ values [ "current_permalink" ] ) ; file_put_contents ( $ sourceFile , json_encode ( $ values ) ) ; } $ filesystem -> copy ( $ sourceFile , $ pageDir . '/seo.json' , true ) ; } $ approvedBlocks = $ this -> saveBlocks ( $ approver , $ pageDir , $ options ) ; if ( $ saveCommonSlots ) { $ slotsDir = $ this -> baseDir . '/slots' ; $ approvedCommonBlocks = $ this -> saveBlocks ( $ approver , $ slotsDir , $ options ) ; $ approvedBlocks = array_merge ( $ approvedBlocks , $ approvedCommonBlocks ) ; } Dispatcher :: dispatch ( PageEvents :: PAGE_SAVED , new PageSavedEvent ( $ pageDir , null , $ approvedBlocks ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully saved in production' , $ options [ "page" ] ) ) ; }
10573	protected function registerSessionHandler ( ) { if ( $ this -> handler !== null ) { if ( ! is_object ( $ this -> handler ) ) { $ this -> handler = Yii :: createObject ( $ this -> handler ) ; } if ( ! $ this -> handler instanceof \ SessionHandlerInterface ) { throw new InvalidConfigException ( '"' . get_class ( $ this ) . '::handler" must implement the SessionHandlerInterface.' ) ; } @ session_set_save_handler ( $ this -> handler , false ) ; } elseif ( $ this -> getUseCustomStorage ( ) ) { @ session_set_save_handler ( [ $ this , 'openSession' ] , [ $ this , 'closeSession' ] , [ $ this , 'readSession' ] , [ $ this , 'writeSession' ] , [ $ this , 'destroySession' ] , [ $ this , 'gcSession' ] ) ; } }
3200	protected function binaryPopCount ( $ value ) { $ value -= ( ( $ value >> 1 ) & 0x55555555 ) ; $ value = ( ( ( $ value >> 2 ) & 0x33333333 ) + ( $ value & 0x33333333 ) ) ; $ value = ( ( ( $ value >> 4 ) + $ value ) & 0x0f0f0f0f ) ; $ value += ( $ value >> 8 ) ; $ value += ( $ value >> 16 ) ; return $ value & 0x0000003f ; }
2666	public function dictionaryItemsList ( $ dictionaryId ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/items' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
4552	public function exists ( UserParameters $ parameters = null ) { $ object = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c6f7311000029066df850' ) ; if ( $ object && property_exists ( $ object , '_id' ) && $ object -> _id ) { return true ; } return false ; }
4499	private function arrayMergeDeep ( array $ array1 , array $ array2 ) : array { $ result = [ ] ; foreach ( \ func_get_args ( ) as $ array ) { foreach ( $ array as $ key => $ value ) { if ( \ is_int ( $ key ) ) { $ result [ ] = $ value ; } elseif ( isset ( $ result [ $ key ] ) && \ is_array ( $ result [ $ key ] ) && \ is_array ( $ value ) ) { $ result [ $ key ] = $ this -> arrayMergeDeep ( $ result [ $ key ] , $ value ) ; } else { $ result [ $ key ] = $ value ; } } } return $ result ; }
5315	protected function generateBlocks ( ) { $ blocks = [ ] ; foreach ( range ( 1 , $ this -> getBlocks ( ) ) as $ counter ) { $ blocks [ ] = $ this -> generateChars ( ) ; } return implode ( $ this -> blockSeparator , $ blocks ) ; }
3075	public function process ( ) { $ this -> validate ( ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> pause ( $ serviceContext ) ; $ response = [ 'success' => $ result ] ; } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
1887	protected function linkToPage ( $ intPage ) { if ( $ intPage <= 1 && ! $ this -> blnForceParam ) { return ampersand ( $ this -> strUrl ) ; } else { return ampersand ( $ this -> strUrl ) . $ this -> strVarConnector . $ this -> strParameter . '=' . $ intPage ; } }
8117	public function onBeforeWrite ( ) { $ changedFields = $ this -> owner -> getChangedFields ( true , 2 ) ; if ( $ changedFields ) { $ this -> owner -> LastEditedByName = $ this -> owner -> getEditorName ( ) ; $ this -> owner -> OwnerNames = $ this -> owner -> getOwnerNames ( ) ; } if ( $ this -> owner -> isChanged ( "ContentReviewType" , 2 ) ) { if ( $ this -> owner -> ContentReviewType == "Disabled" ) { $ this -> setDefaultReviewDateForDisabled ( ) ; } elseif ( $ this -> owner -> ContentReviewType == "Custom" ) { $ this -> setDefaultReviewDateForCustom ( ) ; } else { $ this -> setDefaultReviewDateForInherited ( ) ; } } if ( $ this -> owner -> ContentReviewType == "Inherit" && ! $ this -> owner -> NextReviewDate ) { $ this -> setDefaultReviewDateForInherited ( ) ; } if ( ! $ this -> owner -> exists ( ) ) { return ; } if ( $ this -> owner -> isChanged ( 'ReviewPeriodDays' , 2 ) ) { $ nextReviewUnixSec = strtotime ( ' + ' . $ this -> owner -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ this -> owner -> NextReviewDate = DBDate :: create ( ) -> setValue ( $ nextReviewUnixSec ) -> Format ( 'y-MM-dd' ) ; } }
8941	public function expandBBoxChangeset ( $ id , $ nodes ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/expand_bbox' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ nodeList = '' ; if ( ! empty ( $ nodes ) ) { foreach ( $ nodes as $ node ) { $ nodeList .= '<node lat="' . $ node [ 0 ] . '" lon="' . $ node [ 1 ] . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <changeset>' . $ nodeList . '</changeset> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'POST' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> changeset ; }
9068	protected function convert_value_to_string ( $ value ) { if ( $ this -> is_resource ( $ value ) ) { $ type = get_resource_type ( $ value ) ; return "(Resource:$type)" ; } if ( is_object ( $ value ) ) { if ( $ value instanceof \ Exception || $ value instanceof \ Throwable ) { return '(' . get_class ( $ value ) . "#{$value->getCode()}:{$value->getMessage()})" ; } elseif ( $ value instanceof \ DateTime || ( interface_exists ( '\DateTimeInterface' ) && $ value instanceof \ DateTimeInterface ) ) { return $ value -> format ( \ DateTime :: ATOM ) ; } elseif ( method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } else { $ class = get_class ( $ value ) ; return "($class)" ; } } if ( is_array ( $ value ) ) { return '(Array)' ; } if ( is_scalar ( $ value ) ) { return $ value ; } if ( $ value === null ) { return '(Null)' ; } return '(Invalid)' ; }
4073	public function getUser ( ) { static $ authenticated ; if ( ! isset ( $ authenticated ) ) { $ authenticated = true ; $ this -> authenticateUser ( ) ; } return $ this -> user ; }
8885	private function send ( ) { $ ch = curl_init ( $ this -> url ) ; curl_setopt ( $ ch , CURLOPT_HEADER , 1 ) ; curl_setopt ( $ ch , CURLOPT_POST , 1 ) ; curl_setopt ( $ ch , CURLOPT_TIMEOUT , 60 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , 0 ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , 0 ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ this -> xml ) ; $ result = curl_exec ( $ ch ) ; $ this -> xml = strstr ( $ result , '<?' ) ; $ this -> xml_result = new \ SimpleXMLElement ( $ this -> xml ) ; return $ this -> parseResult ( ) ; }
135	public function ensureBinariesPresence ( PackageInterface $ package ) { try { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; } catch ( \ InvalidArgumentException $ e ) { return ; } if ( $ installer instanceof BinaryPresenceInterface ) { $ installer -> ensureBinariesPresence ( $ package ) ; } }
12201	public function mediaAction ( Request $ request , Application $ app ) { $ options = array ( "connector" => $ app [ "red_kite_cms.elfinder_media_connector" ] , ) ; return parent :: show ( $ options ) ; }
6808	public function number ( float $ number ) : string { return $ this -> getNumberFormatter ( ) -> format ( $ number , NumberFormatter :: TYPE_DEFAULT ) ; }
1302	public function getDefaultLocale ( ) : Locale { foreach ( $ this -> locales as $ locale ) { if ( $ locale -> isDefault ( ) ) { return $ locale ; } } throw new \ RuntimeException ( 'No locale marked as default exists in this environment.' ) ; }
11019	private function _getRoute ( ) { $ action = str_replace ( 'Action' , '' , $ this -> action -> getName ( ) ) ; $ action = explode ( '\\' , $ action ) ; $ action = strtolower ( $ action [ 0 ] ) ; $ cls = str_replace ( 'Controller' , '' , get_class ( $ this ) ) ; $ cls = strtolower ( $ cls ) ; $ path = explode ( '\\' , $ cls ) ; $ path = $ path [ count ( $ path ) - 1 ] . '/' . $ action ; if ( $ this -> action -> hasParams ( ) ) { foreach ( $ this -> action -> getParams ( ) as $ param ) { $ path .= '/' . $ param ; } } return $ path ; }
9443	public function setPackOptions ( Container $ app ) { foreach ( $ this -> packOptions as $ key => & $ value ) { $ key = $ this -> _ns ( $ key ) ; if ( isset ( $ app [ $ key ] ) ) { $ value = $ app [ $ key ] ; } } }
1818	public function setSingleSrcFlags ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord ) { switch ( $ dc -> activeRecord -> type ) { case 'text' : case 'hyperlink' : case 'image' : case 'accordionSingle' : $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'extensions' ] = Contao \ Config :: get ( 'validImageTypes' ) ; break ; case 'download' : $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'extensions' ] = Contao \ Config :: get ( 'allowedDownload' ) ; break ; } } return $ varValue ; }
1239	private static function getActualType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } return $ actualType ; }
3551	public function parse ( InlineParserContext $ inlineContext ) { $ cursor = $ inlineContext -> getCursor ( ) ; $ previous = $ cursor -> peek ( - 1 ) ; if ( $ previous !== null && $ previous !== ' ' ) { return false ; } $ saved = $ cursor -> saveState ( ) ; $ cursor -> advance ( ) ; $ handle = $ cursor -> match ( '/^[a-z0-9\+\-_]+:/' ) ; if ( ! $ handle ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ next = $ cursor -> peek ( 0 ) ; if ( $ next !== null && $ next !== ' ' ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ key = substr ( $ handle , 0 , - 1 ) ; if ( $ this -> map === null ) { $ this -> map = $ this -> repo -> get ( ) ; } if ( ! array_key_exists ( $ key , $ this -> map ) ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ inline = new Image ( $ this -> map [ $ key ] , $ key ) ; $ inline -> data [ 'attributes' ] = [ 'class' => 'emoji' , 'data-emoji' => $ key ] ; $ inlineContext -> getContainer ( ) -> appendChild ( $ inline ) ; return true ; }
12809	private static function isPrimaryKey ( string $ table , string $ column ) : bool { return self :: getPrimaryKey ( $ table ) [ "column_name" ] === $ column ; }
3760	private function createConditionsForPalette ( PaletteInterface $ palette , array $ typeLegends ) { $ conditions = [ ] ; foreach ( $ typeLegends as $ value => $ legends ) { $ valueCondition = new FilterSettingTypeSubPaletteCondition ( $ this -> filterFactory , $ value ) ; foreach ( $ legends as $ legendName => $ legendProperties ) { $ legend = $ this -> getLegend ( $ palette , $ legendName ) ; foreach ( $ legendProperties as $ propertyName ) { $ this -> getConditionChain ( $ legend , $ propertyName , $ conditions ) -> addCondition ( $ valueCondition ) ; } } } }
10708	public function getMany ( $ columns = [ '*' ] , $ paginated = false , $ perPage = null ) { $ results = $ paginated ? $ this -> getManyPaginated ( $ perPage , $ columns ) : $ this -> getQuery ( ) -> get ( $ columns ) ; return $ this -> returnResults ( $ results ) ; }
5092	public function assemble ( ) { $ command = 'CREATE ' . $ this -> getPartIfSet ( self :: PART_TEMP ) . 'TABLE ' . $ this -> getPartIfSet ( self :: PART_IF_NOT_EXIST ) . $ this -> parts [ self :: PART_DB ] . $ this -> parts [ self :: PART_NAME ] ; if ( $ this -> parts [ self :: PART_LIKE ] ) { return $ command . ' ' . $ this -> parts [ self :: PART_LIKE ] ; } if ( ! $ this -> columnsList -> isEmpty ( ) ) { $ command .= '(' ; $ columns = $ this -> columnsList -> assemble ( ) ; $ keys = $ this -> indexes -> assemble ( ) ; $ combined = array_merge ( $ columns , $ keys ) ; $ command .= implode ( ',' , $ combined ) ; $ command .= ') ' . $ this -> getPartIfSet ( self :: PART_ENGINE , 'ENGINE=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'CHARSET=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'AUTO_INCREMENT=' ) . $ this -> getPartIfSet ( self :: PART_COMMENT , 'COMMENT=' ) ; } if ( $ this -> parts [ self :: PART_AS ] ) { $ command .= " {$this->getAsExpression()}" ; } return $ command ; }
3507	private function doDiff ( $ from_text , $ to_text ) { $ this -> last_edit = false ; $ this -> stackpointer = 0 ; $ this -> from_text = $ from_text ; $ this -> from_offset = 0 ; if ( empty ( $ this -> granularityStack ) ) { return ; } $ this -> _processGranularity ( $ from_text , $ to_text ) ; }
273	public function asXml ( $ data ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> format = Response :: FORMAT_XML ; $ response -> data = $ data ; return $ response ; }
8913	protected function _set_where ( $ params ) { if ( count ( $ params ) == 1 ) { $ this -> _database -> where ( $ params [ 0 ] ) ; } else if ( count ( $ params ) == 2 ) { $ this -> _database -> where ( $ params [ 0 ] , $ params [ 1 ] ) ; } else if ( count ( $ params ) == 3 ) { $ this -> _database -> where ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] ) ; } else { $ this -> _database -> where ( $ params ) ; } }
12107	public function getPage ( $ name ) { if ( ! isset ( $ this -> pages [ $ name ] ) ) { throw new InvalidParameterException ( "Page not found" ) ; } return $ this -> pages [ $ name ] ; }
8015	protected function execute ( Command $ command ) { $ command -> setJar ( $ this -> getPathToPdfBox ( ) ) ; $ command -> setOptions ( $ this -> _options ) ; exec ( ( string ) $ command . ' 2>&1' , $ stdErr , $ exitCode ) ; if ( $ command -> getPdfFileIsTemp ( ) ) { unlink ( $ command -> getPdfFile ( ) ) ; } if ( $ exitCode > 0 ) { throw new \ RuntimeException ( join ( "\n" , $ stdErr ) , $ exitCode ) ; } $ resultFile = $ command -> getTextFile ( ) ; $ result = file_get_contents ( $ resultFile ) ; if ( $ command -> getTextFileIsTemp ( ) ) { unlink ( $ resultFile ) ; } return $ result ; }
6172	public function setConfig ( $ host , $ name = 'schema' , DriverInterface $ driver = null ) { $ this -> driver = \ is_null ( $ driver ) ? new Driver \ Json ( ) : $ driver ; $ this -> path = $ host ; $ this -> name = $ name ; $ this -> file = $ host . DIRECTORY_SEPARATOR . $ name . '.' . $ this -> driver -> getExtension ( ) ; return $ this ; }
9240	public function renderLanguageSwitcher ( ) { return $ this -> _View -> element ( $ this -> config ( 'element' ) , [ 'availableLanguages' => $ this -> config ( 'availableLanguages' ) , 'displayNames' => $ this -> config ( 'displayNames' ) , 'imageMapping' => $ this -> config ( 'imageMapping' ) , 'renderToggleButtonDisplayName' => $ this -> config ( 'renderToggleButtonDisplayName' ) ] ) ; }
5226	private function isTypeMismatch ( $ type , $ value ) { if ( ! ( $ type instanceof \ ReflectionClass ) ) { return false ; } if ( ! is_object ( $ value ) ) { return true ; } return ! $ type -> isInstance ( $ value ) ; }
10372	public static function add_styles ( ) { self :: look_if_process_files ( 'style' ) ; foreach ( self :: $ data [ 'style' ] as $ data ) { wp_register_style ( $ data [ 'name' ] , $ data [ 'url' ] , $ data [ 'deps' ] , $ data [ 'version' ] , $ data [ 'media' ] ) ; wp_enqueue_style ( $ data [ 'name' ] ) ; } }
1150	public function render ( $ view = null , $ selector = null ) { $ this -> view ( $ view ) ; $ this -> selector ( $ selector ) ; return View :: make ( $ this -> view , [ 'validator' => $ this -> getViewData ( ) ] ) -> render ( ) ; }
68	public function junction ( $ target , $ junction ) { if ( ! Platform :: isWindows ( ) ) { throw new \ LogicException ( sprintf ( 'Function %s is not available on non-Windows platform' , __CLASS__ ) ) ; } if ( ! is_dir ( $ target ) ) { throw new IOException ( sprintf ( 'Cannot junction to "%s" as it is not a directory.' , $ target ) , 0 , null , $ target ) ; } $ cmd = sprintf ( 'mklink /J %s %s' , ProcessExecutor :: escape ( str_replace ( '/' , DIRECTORY_SEPARATOR , $ junction ) ) , ProcessExecutor :: escape ( realpath ( $ target ) ) ) ; if ( $ this -> getProcess ( ) -> execute ( $ cmd , $ output ) !== 0 ) { throw new IOException ( sprintf ( 'Failed to create junction to "%s" at "%s".' , $ target , $ junction ) , 0 , null , $ target ) ; } clearstatcache ( true , $ junction ) ; }
483	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ time = $ this -> beginCommand ( 'create' . ( $ unique ? ' unique' : '' ) . " index $name on $table (" . implode ( ',' , ( array ) $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
5643	public function makeDry ( $ is_dry = true ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> makeDry ( $ is_dry ) ; } }
9637	public function handle ( GetResponseEvent $ event ) { $ apiKey = $ this -> getApiKeyFromQueryOrHeader ( $ event -> getRequest ( ) ) ; if ( false === $ apiKey ) { return ; } try { $ token = $ this -> authenticationManager -> authenticate ( new ApiKeyToken ( $ apiKey ) ) ; $ this -> tokenStorage -> setToken ( $ token ) ; } catch ( AuthenticationException $ failed ) { $ this -> tokenStorage -> setToken ( null ) ; $ this -> doFailureResponse ( $ event ) ; } }
10927	private function updateWidth ( $ columnNumber , $ width ) { if ( $ width > $ this -> getWidth ( $ columnNumber ) ) { $ this -> widths [ $ columnNumber ] = $ width ; } }
127	public function ensureBinariesPresence ( PackageInterface $ package ) { $ this -> binaryInstaller -> installBinaries ( $ package , $ this -> getInstallPath ( $ package ) , false ) ; }
12261	private function _cacheCustomFieldsGroup ( CustomFieldsGroup $ group ) { foreach ( $ group -> getCustomFields ( ) as $ field ) { $ this -> cache [ $ group -> getEntity ( ) ] [ $ field -> getSlug ( ) ] = $ field ; } }
2997	public function setFrom ( $ email , $ title = null ) { $ this -> set ( 'From' , $ this -> buildMail ( $ email , $ title ) ) ; }
4564	public function kernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof NoPermissionsException ) { return ; } $ response = new JsonResponse ( [ ] ) ; $ event -> setResponse ( $ response ) ; }
4373	protected function buildArgString ( $ args , $ sanitize = true ) { $ glue = ', ' ; $ glueAfterFirst = true ; if ( \ is_string ( $ args [ 0 ] ) ) { if ( \ preg_match ( '/[=:] ?$/' , $ args [ 0 ] ) ) { $ glueAfterFirst = false ; } elseif ( \ count ( $ args ) == 2 ) { $ glue = ' = ' ; } } foreach ( $ args as $ i => $ v ) { $ args [ $ i ] = $ i > 0 ? $ this -> dump ( $ v , $ sanitize ) : $ this -> dump ( $ v , false ) ; } if ( ! $ glueAfterFirst ) { return $ args [ 0 ] . \ implode ( $ glue , \ array_slice ( $ args , 1 ) ) ; } else { return \ implode ( $ glue , $ args ) ; } }
5701	protected function createFieldList ( $ buttons ) { $ actions = FieldList :: create ( ) ; foreach ( $ buttons as $ buttonType => $ bool ) { if ( ! $ bool || ! $ buttonType ) { continue ; } if ( substr ( $ buttonType , 0 , 6 ) == "Group_" ) { $ group = $ this -> createButtonGroup ( substr ( $ buttonType , 6 ) ) ; if ( $ group -> children -> exists ( ) ) { $ actions -> push ( $ group ) ; } } elseif ( $ b = $ this -> instantiateButton ( $ buttonType ) ) { $ actions -> push ( $ b ) ; } } return $ actions ; }
3159	public function storeVariables ( QtiRunnerServiceContext $ context , $ itemUri , $ metaVariables , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariables ( $ testUri , $ itemUri , $ metaVariables , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariables ( $ testUri , $ metaVariables , $ sessionId ) ; } return true ; }
4354	protected function setFile ( $ file ) { if ( $ file == $ this -> file ) { return ; } if ( $ this -> fileHandle ) { \ fclose ( $ this -> fileHandle ) ; $ this -> fileHandle = null ; } $ this -> file = $ file ; if ( empty ( $ file ) ) { return ; } $ fileExists = \ file_exists ( $ file ) ; $ this -> fileHandle = \ fopen ( $ file , 'a' ) ; if ( $ this -> fileHandle ) { \ fwrite ( $ this -> fileHandle , '***** ' . \ date ( 'Y-m-d H:i:s' ) . ' *****' . "\n" ) ; if ( ! $ fileExists ) { \ chmod ( $ file , 0660 ) ; } } }
1618	public function scalar ( $ attribute , $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } $ record = $ this -> one ( $ db ) ; if ( $ record !== null ) { return $ record -> hasAttribute ( $ attribute ) ? $ record -> $ attribute : null ; } else { return null ; } }
9814	public function addEntriesToBlacklist ( $ id , $ entries , $ importName = null ) { if ( $ importName == null ) { $ importName = "phpclient_import_" . uniqid ( ) ; } $ action = new AddEntriesAction ( ) ; $ action -> importName = $ importName ; $ action -> entries = $ entries ; return $ this -> post ( "blacklists/" . $ id . "/actions" , $ action -> toXMLString ( ) ) ; }
11802	public static function import ( $ name ) { $ importPath = FOREVERPHP_ROOT . DS . $ name . '.php' ; if ( file_exists ( $ importPath ) ) { include_once $ importPath ; } else { throw new SetupException ( "The object to import ($name) not exists." ) ; } }
12376	public function equals ( ) { foreach ( $ this -> comparisonList as $ valuePair ) { $ a = $ valuePair [ 0 ] ; $ b = $ valuePair [ 1 ] ; $ callback = $ valuePair [ 2 ] ; if ( ! is_null ( $ callback ) ) { if ( ! is_callable ( $ callback ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Provided callback of type %s is not callable!' , is_object ( $ callback ) ? get_class ( $ callback ) : gettype ( $ callback ) ) ) ; } if ( is_array ( $ a ) && is_array ( $ b ) && $ this -> isList ( $ a ) && $ this -> isList ( $ b ) ) { $ result = $ this -> compareListsWithCallback ( $ a , $ b , $ callback ) ; } else { $ result = call_user_func ( $ callback , $ a , $ b ) ; } if ( ! is_bool ( $ result ) ) { throw new \ RuntimeException ( sprintf ( 'Provided callback of type %s does not return a boolean value!' , is_object ( $ callback ) ? get_class ( $ callback ) : gettype ( $ callback ) ) ) ; } return $ result ; } if ( ! ( ( $ this -> strict ) ? $ a === $ b : $ a == $ b ) ) { return false ; } } return true ; }
6181	protected function getSeverity ( $ errorCode ) { if ( isset ( $ this -> severityMapping [ $ errorCode ] ) ) { return $ this -> severityMapping [ $ errorCode ] ; } else { return $ this -> severityMapping [ Logger :: ERROR ] ; } }
10258	public function getCompanyName ( $ base_name = null ) { $ suffixes = [ 'Corporation' , 'Company' , 'Company, Limited' , 'Computer Repair' , 'Incorporated' , 'and Sons' , 'Group' , 'Group, PLC' , 'Furniture' , 'Flowers' , 'Sales' , 'Systems' , 'Tire' , 'Auto' , 'Plumbing' , 'Roofing' , 'Realty' , 'Foods' , 'Books' ] ; if ( empty ( $ base_name ) ) { $ base_name = $ this -> getLastName ( ) ; } return $ base_name . ' ' . $ this -> fromArray ( $ suffixes ) ; }
10226	public function noAssociationsMenuFor ( $ model , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ menuFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\NoAssociationsIndexMenuFactory' ) ; return $ menuFactory -> create ( $ modelName , $ config ) ; }
10221	public static function getConversionGroupUnits ( $ group = null ) { $ conversionGroups = [ ] ; foreach ( self :: $ conversionUnits as $ conversionUnit => $ conversionGroup ) { if ( ( $ group === null ) || ( $ conversionGroup [ 'Group' ] == $ group ) ) { $ conversionGroups [ $ conversionGroup [ 'Group' ] ] [ ] = $ conversionUnit ; } } return $ conversionGroups ; }
6627	public function getData ( $ defaultValue = null ) { return ArrayHelper :: getValue ( $ this -> parsedResponse , self :: RESPONSE_DATA_PARAM , $ defaultValue ) ; }
7554	protected function match_filters ( $ conditions , $ custom_filters = array ( ) ) { foreach ( $ conditions as $ c ) { $ c [ 'filter' ] = strtolower ( $ c [ 'filter' ] ) ; if ( isset ( $ this -> filter_map [ $ c [ 'filter' ] ] ) ) { if ( ! $ this -> { $ this -> filter_map [ $ c [ 'filter' ] ] } ( $ c [ 'params' ] ) ) { return false ; } } elseif ( isset ( $ custom_filters [ $ c [ 'filter' ] ] ) ) { if ( ! call_user_func ( $ custom_filters [ $ c [ 'filter' ] ] , $ this , $ c [ 'params' ] ) ) { return false ; } } else { trigger_error ( 'Unknown filter "' . $ c [ 'filter' ] . '"!' ) ; return false ; } } return true ; }
4012	private function calculatePaginated ( ) { $ this -> calculatedTotal = $ this -> getTotalAmount ( ) ; if ( ( $ this -> calculatedLimit !== null ) && ( $ this -> calculatedTotal > $ this -> calculatedLimit ) ) { $ this -> calculatedTotal -= $ this -> calculatedLimit ; } $ this -> calculatedTotal -= $ this -> calculatedOffset ; $ page = $ this -> getCurrentPage ( ) ; if ( $ page > ( $ this -> calculatedTotal / $ this -> getPerPage ( ) ) ) { $ page = ( int ) ceil ( $ this -> calculatedTotal / $ this -> getPerPage ( ) ) ; } $ pageOffset = ( ( max ( $ page , 1 ) - 1 ) * $ this -> getPerPage ( ) ) ; $ this -> calculatedOffset += $ pageOffset ; if ( $ this -> calculatedLimit === null ) { $ this -> calculatedLimit = $ this -> getPerPage ( ) ; } else { $ this -> calculatedLimit = min ( ( $ this -> calculatedLimit - $ this -> calculatedOffset ) , $ this -> getPerPage ( ) ) ; } }
1482	public function encoder ( $ options = 0 , $ depth = 512 ) { if ( $ options instanceof Encoding ) { $ options = $ options -> getOptions ( ) ; } if ( ! $ options instanceof EncoderOptions ) { $ options = new EncoderOptions ( $ options , $ this -> getUrl ( ) -> toString ( ) , $ depth ) ; } return $ this -> factory -> createEncoder ( $ this -> getContainer ( ) , $ options ) ; }
4665	public function createMessage ( ) { $ eventsManager = $ this -> getEventsManager ( ) ; if ( $ eventsManager ) { $ eventsManager -> fire ( 'mailer:beforeCreateMessage' , $ this ) ; } $ message = $ this -> getDI ( ) -> get ( '\Baka\Mail\Message' , [ $ this ] ) ; if ( ( $ from = $ this -> getConfig ( 'from' ) ) ) { $ message -> from ( $ from [ 'email' ] , isset ( $ from [ 'name' ] ) ? $ from [ 'name' ] : null ) ; } if ( $ eventsManager ) { $ eventsManager -> fire ( 'mailer:afterCreateMessage' , $ this , $ message ) ; } return $ message ; }
1731	public static function triggerImportUserHook ( $ username , $ password , $ strTable ) { $ self = new static ( ) ; if ( empty ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] ) || ! \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] ) ) { return false ; } @ trigger_error ( 'Using the "importUser" hook has been deprecated and will no longer work in Contao 5.0. Use the contao.import_user event instead.' , E_USER_DEPRECATED ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] as $ callback ) { $ self -> import ( $ callback [ 0 ] , 'objImport' , true ) ; $ blnLoaded = $ self -> objImport -> { $ callback [ 1 ] } ( $ username , $ password , $ strTable ) ; if ( $ blnLoaded === true ) { return true ; } } return false ; }
5198	public function save ( ) { try { $ connection = new Connection ( $ this -> buildConnectionOptions ( ) ) ; $ connection -> open ( ) ; $ msg = new AMQPMessage ( $ this -> message , array ( 'content_type' => $ this -> content_type , 'delivery_mode' => 2 ) ) ; $ connection -> channel -> basic_publish ( $ msg , $ this -> exchange , $ this -> queue_name ) ; $ connection -> close ( ) ; } catch ( Exception $ e ) { $ connection -> close ( ) ; throw new Exception ( $ e ) ; } }
3451	protected function recordThat ( AggregateChanged $ event ) : void { $ this -> version += 1 ; $ this -> recordedEvents [ ] = $ event -> withVersion ( $ this -> version ) ; $ this -> apply ( $ event ) ; }
9533	private function preloadParameters ( $ argv ) { array_shift ( $ argv ) ; $ this -> argv = [ ] ; while ( ( $ argument = array_shift ( $ argv ) ) != null ) { switch ( substr ( $ argument , 0 , 1 ) ) { case '\'' : { $ this -> parseQuote ( $ argv , $ argument , '\'' ) ; break ; } case '"' : { $ this -> parseQuote ( $ argv , $ argument , '"' ) ; break ; } default : { $ this -> argv [ ] = $ argument ; } } } }
7968	public function getFaxConsumptions ( $ params = null ) { $ consumptionList = json_decode ( self :: getClient ( ) -> getFaxConsumptions ( $ this -> service , $ this -> billingAccount , $ params ) ) ; $ consumptions = array ( ) ; foreach ( $ consumptionList as $ consumption ) { $ consumptions [ ] = new FaxConsumption ( $ consumption , $ this ) ; } return $ consumptions ; }
6990	static public function transApiDoc ( string $ translationPath , array $ parameters = [ ] , $ locale = null ) { if ( static :: class === self :: class ) { return self :: getPrimary ( ) -> transApiDoc ( $ translationPath , $ parameters , $ locale ) ; } else { $ translationPath = 'api_docs.' . ltrim ( $ translationPath , '.' ) ; return static :: transCustom ( $ translationPath , $ parameters , $ locale ) ; } }
12880	public function register ( ) { if ( ! $ this -> validate ( ) ) { return false ; } $ this -> user -> setAttributes ( [ 'email' => $ this -> email , 'username' => $ this -> username , 'password' => $ this -> password ] ) ; return $ this -> user -> register ( ) ; }
7232	public static function createFromCurrency ( $ currency , $ code = 0 , \ Exception $ prev = null ) { $ message = sprintf ( 'Not found prices by currency "%s".' , $ currency ) ; return new static ( $ message , $ code , $ prev ) ; }
5768	public function addColumn ( string $ name , $ value ) { $ this -> args [ ] = $ value ; if ( count ( $ this -> args ) > 1 ) { $ this -> setColumnsValues .= ", " ; } $ argNum = count ( $ this -> args ) ; $ this -> setColumnsValues .= "$name = \$" . $ argNum ; }
12088	public function view ( UserPolicy $ user , Response $ response ) { if ( $ user -> canDo ( 'forum.response.view' ) && $ user -> isAdmin ( ) ) { return true ; } return $ response -> user_id == user_id ( ) && $ response -> user_type == user_type ( ) ; }
4032	private function preCreateInverseImage ( ModelInterface $ model , string $ image ) : void { if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return ; } if ( $ model -> getProperty ( 'enabled' ) ) { $ this -> iconBuilder -> getBackendIcon ( substr_replace ( $ image , '_1' , $ intPos , 0 ) ) ; return ; } $ this -> iconBuilder -> getBackendIcon ( $ image ) ; }
849	public function getPrevTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , - 1 , $ tokens , $ caseSensitive ) ; }
687	protected function getChildrenRecursive ( $ name , $ childrenList , & $ result ) { if ( isset ( $ childrenList [ $ name ] ) ) { foreach ( $ childrenList [ $ name ] as $ child ) { $ result [ $ child ] = true ; $ this -> getChildrenRecursive ( $ child , $ childrenList , $ result ) ; } } }
1596	protected function validateAttributes ( ) : bool { if ( ! $ this -> dataHas ( 'attributes' ) ) { return true ; } $ attrs = $ this -> dataGet ( 'attributes' ) ; if ( ! is_object ( $ attrs ) ) { $ this -> memberNotObject ( '/data' , 'attributes' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ attrs ) { return property_exists ( $ attrs , $ field ) ; } ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'attributes' , $ disallowed ) ; return $ disallowed -> isEmpty ( ) ; }
10119	private function writeMarginRight ( ) { $ record = 0x0027 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getRight ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
9857	public function isValid ( Cell $ cell ) { if ( ! $ cell -> hasDataValidation ( ) ) { return true ; } $ cellValue = $ cell -> getValue ( ) ; $ dataValidation = $ cell -> getDataValidation ( ) ; if ( ! $ dataValidation -> getAllowBlank ( ) && ( $ cellValue === null || $ cellValue === '' ) ) { return false ; } switch ( $ dataValidation -> getType ( ) ) { case DataValidation :: TYPE_LIST : return $ this -> isValueInList ( $ cell ) ; } return false ; }
6862	protected function registerFactory ( ) { $ this -> app -> singleton ( 'notifyme.factory' , function ( ) { return new NotifyMeFactory ( ) ; } ) ; $ this -> app -> alias ( 'notifyme.factory' , NotifyMeFactory :: class ) ; $ this -> app -> alias ( 'notifyme.factory' , FactoryInterface :: class ) ; }
3956	public function getSiblings ( $ objFilter ) { if ( ! $ this -> getMetaModel ( ) -> hasVariants ( ) ) { return null ; } return $ this -> getMetaModel ( ) -> findVariantsWithBase ( array ( $ this -> get ( 'id' ) ) , $ objFilter ) ; }
12302	public function getChild ( $ id , $ relation , $ idChild , $ filters = null ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } if ( count ( $ filters -> request -> all ( ) ) > 0 ) { $ child = $ parent -> $ relation ( ) -> getRelated ( ) ; $ search = new Search ( $ child , $ filters , $ parent -> $ relation ( ) ) ; $ this -> builder = $ search -> getBuilder ( ) ; $ this -> builder -> select ( "{$child->getTable()}.*" ) ; if ( $ parent -> $ relation ( ) instanceof \ Illuminate \ Database \ Eloquent \ Relations \ BelongsToMany ) { $ this -> builder -> where ( $ parent -> $ relation ( ) -> getOtherKey ( ) , $ idChild ) ; } $ resource = $ this -> builder -> get ( ) ; } else { $ resource = $ parent -> $ relation ( ) -> find ( $ idChild ) ; } return $ resource ; }
9509	public function search ( Log $ log , $ level = 'all' , Request $ request ) { if ( is_null ( $ query = $ request -> get ( 'query' ) ) ) return redirect ( ) -> route ( 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ log -> entries ( $ level ) -> filter ( function ( LogEntry $ value ) use ( $ query ) { return Str :: contains ( $ value -> header , $ query ) ; } ) -> paginate ( $ this -> perPage ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'level' , 'query' , 'entries' ) ) ; }
1715	public function hasAccess ( $ field , $ array ) { if ( $ this -> isAdmin ) { return true ; } if ( ! \ is_array ( $ field ) ) { $ field = array ( $ field ) ; } if ( \ is_array ( $ this -> $ array ) && array_intersect ( $ field , $ this -> $ array ) ) { return true ; } elseif ( $ array == 'filemounts' ) { foreach ( $ this -> filemounts as $ folder ) { if ( preg_match ( '/^' . preg_quote ( $ folder , '/' ) . '(\/|$)/i' , $ field [ 0 ] ) ) { return true ; } } } return false ; }
5010	public function getPermissions ( ) { if ( ! $ this -> permissions ) { $ type = property_exists ( $ this , 'permissionsType' ) ? $ this -> permissionsType : str_replace ( '\\Entity\\' , '/' , static :: class ) ; $ permissions = new Permissions ( $ type ) ; if ( method_exists ( $ this , 'setupPermissions' ) ) { $ this -> setupPermissions ( $ permissions ) ; } $ this -> setPermissions ( $ permissions ) ; } return $ this -> permissions ; }
6804	public function installCustomerGroups ( ) { $ groups = ( array ) $ this -> customerGroupRepository -> findBy ( [ ] , [ ] , 1 ) -> getIterator ( ) ; if ( ! empty ( $ groups ) ) { call_user_func ( $ this -> log , 'All' , 'skipped' ) ; return ; } $ groups = [ 'Particuliers' => [ 'default' => true , 'business' => false , 'registration' => true , ] , 'Entreprise' => [ 'default' => false , 'business' => true , 'registration' => true , ] , ] ; foreach ( $ groups as $ name => $ config ) { $ result = 'already exists' ; if ( null === $ this -> customerGroupRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ customerGroup = $ this -> customerGroupRepository -> createNew ( ) ; $ customerGroup -> setName ( $ name ) -> setDefault ( $ config [ 'default' ] ) -> setBusiness ( $ config [ 'business' ] ) -> setRegistration ( $ config [ 'registration' ] ) -> translate ( ) -> setTitle ( $ name ) ; $ this -> manager -> persist ( $ customerGroup ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } $ this -> manager -> flush ( ) ; }
2753	protected function getRequestForPath ( $ path , array $ exclude ) { if ( ! empty ( $ exclude [ $ path ] ) ) { return NULL ; } $ request = Request :: create ( $ path ) ; $ request -> headers -> set ( 'Accept' , 'text/html' ) ; $ processed = $ this -> pathProcessor -> processInbound ( $ path , $ request ) ; if ( empty ( $ processed ) || ! empty ( $ exclude [ $ processed ] ) ) { return NULL ; } $ this -> currentPath -> setPath ( $ processed , $ request ) ; try { $ request -> attributes -> add ( $ this -> router -> matchRequest ( $ request ) ) ; return $ request ; } catch ( ParamNotConvertedException $ e ) { return NULL ; } catch ( ResourceNotFoundException $ e ) { return NULL ; } catch ( MethodNotAllowedException $ e ) { return NULL ; } catch ( AccessDeniedHttpException $ e ) { return NULL ; } }
3599	public function handleHttpRequest ( HttpRequest $ httpRequest ) { $ event = $ this -> dispatch ( Event \ HttpRequestEvent :: EVENT , new Event \ HttpRequestEvent ( $ httpRequest ) ) ; $ httpRequest = $ event -> getHttpRequest ( ) ; try { $ jsonRequests = $ this -> parserHttpRequest ( $ httpRequest ) ; } catch ( Exceptions \ ParseException $ e ) { return $ this -> createHttpResponseFromException ( $ e ) ; } $ jsonResponses = $ this -> jsonHandler -> handleJsonRequest ( $ jsonRequests ) ; $ httpResponse = HttpResponse :: create ( ) ; if ( $ this -> profiler ) { $ collect = function ( $ jsonResponse ) use ( & $ collect , $ httpRequest , $ httpResponse ) { if ( \ is_array ( $ jsonResponse ) ) { foreach ( $ jsonResponse as $ value ) { $ collect ( $ value ) ; } } else { if ( $ jsonResponse -> isError ( ) ) { $ this -> collectException ( $ httpRequest , $ httpResponse , new Exceptions \ ErrorException ( $ jsonResponse -> getErrorMessage ( ) , $ jsonResponse -> getErrorCode ( ) , $ jsonResponse -> getErrorData ( ) , $ jsonResponse -> getId ( ) ) ) ; } } } ; $ collect ( $ jsonResponses ) ; } if ( \ is_array ( $ jsonResponses ) ) { $ results = [ ] ; foreach ( $ jsonResponses as $ jsonResponse ) { if ( $ jsonResponse -> isError ( ) || $ jsonResponse -> getId ( ) ) { $ results [ ] = $ jsonResponse ; } if ( $ jsonResponse -> isError ( ) ) { $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; } } $ httpResponse -> setContent ( \ json_encode ( $ results ) ) ; } else { if ( $ jsonResponses -> isError ( ) || $ jsonResponses -> getId ( ) ) { $ httpResponse -> setContent ( \ json_encode ( $ jsonResponses ) ) ; } if ( $ jsonResponses -> isError ( ) ) { $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; } } if ( \ is_array ( $ jsonResponses ) ) { foreach ( $ jsonResponses as $ jsonResponse ) { if ( $ jsonResponse -> isError ( ) || $ jsonResponse -> getId ( ) ) { $ httpResponse -> headers -> add ( $ jsonResponse -> headers ( ) -> all ( ) ) ; } } } else { $ httpResponse -> headers -> add ( $ jsonResponses -> headers ( ) -> all ( ) ) ; } $ httpResponse -> headers -> set ( 'Content-Type' , 'application/json' ) ; $ this -> dispatch ( Event \ HttpResponseEvent :: EVENT , new Event \ HttpResponseEvent ( $ httpResponse ) ) ; return $ httpResponse ; }
5635	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print '<span class="fail">Exception</span>: ' ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print implode ( ' -&gt; ' , $ breadcrumb ) ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print ' -&gt; <strong>' . $ this -> htmlEntities ( $ message ) . "</strong><br />\n" ; }
10754	public function getDateBorn ( UserEntity $ user , $ sm ) { $ dateFormatter = new \ IntlDateFormatter ( \ Locale :: getDefault ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , \ date_default_timezone_get ( ) , \ IntlDateFormatter :: GREGORIAN , "dd MMMM YYYY" ) ; $ date = $ user -> getDateBorn ( ) ; return $ dateFormatter -> format ( $ date ) ; }
11075	public function setArray ( string $ key , $ value , callable $ callback = null , array $ ignoredDefaultValue = null ) { if ( $ value instanceof Traversable ) { $ value = iterator_to_array ( $ value ) ; } if ( is_array ( $ value ) ) { if ( is_callable ( $ callback ) ) { $ value = array_map ( $ callback , $ value ) ; } $ this -> set ( $ key , $ value , $ ignoredDefaultValue ) ; } return $ this ; }
5192	public function map ( array $ methods , string $ path , RequestHandlerInterface $ handler ) : Route { return $ this -> routes [ ] = new Route ( $ methods , $ path , $ handler ) ; }
5038	public function get ( $ key , $ fallback = true ) { foreach ( $ this -> getImages ( ) as $ image ) { if ( $ key == $ image -> getKey ( ) ) { return $ image ; } } return ! $ fallback || self :: ORIGINAL == $ key ? null : $ this -> get ( self :: ORIGINAL ) ; }
1864	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( $ request -> isMethod ( 'POST' ) ) { return ; } if ( null === ( $ session = $ request -> getSession ( ) ) || ! $ session -> isStarted ( ) ) { return ; } $ this -> clearLegacyAttributeBags ( 'FE_DATA' ) ; $ this -> clearLegacyAttributeBags ( 'BE_DATA' ) ; $ this -> clearLegacyFormData ( ) ; }
10945	public function onPrerenderPost ( PrerenderEvent $ events ) { $ cache = $ this -> getServiceLocator ( ) -> get ( $ this -> moduleOptions -> getCacheKey ( ) ) ; $ response = $ events -> getResponse ( ) ; $ key = $ this -> getCacheEntryKey ( $ events -> getRequest ( ) ) ; $ cache -> setItem ( $ key , $ events -> getResponse ( ) ) ; return $ this ; }
8329	public function whereExists ( Closure $ callback , $ boolean = 'and' , $ not = false ) { $ type = $ not ? 'NotExists' : 'Exists' ; $ this -> wheres [ ] = compact ( 'type' , 'callback' , 'boolean' ) ; return $ this ; }
2232	protected function getDatalistOptions ( ) { $ strGroups = '' ; if ( ! $ this -> User -> isAdmin ) { if ( empty ( $ this -> User -> amg ) || ! \ is_array ( $ this -> User -> amg ) ) { header ( 'Content-type: application/json' ) ; die ( json_encode ( array ( ) ) ) ; } $ arrGroups = array ( ) ; foreach ( $ this -> User -> amg as $ intGroup ) { $ arrGroups [ ] = '%"' . ( int ) $ intGroup . '"%' ; } $ strGroups = " AND (groups LIKE '" . implode ( "' OR GROUPS LIKE '" , $ arrGroups ) . "')" ; } $ arrUsers = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objUsers = $ this -> Database -> prepare ( "SELECT username FROM tl_member WHERE username LIKE ?$strGroups AND login='1' AND disable!='1' AND (start='' OR start<='$time') AND (stop='' OR stop>'" . ( $ time + 60 ) . "') ORDER BY username" ) -> limit ( 10 ) -> execute ( str_replace ( '%' , '' , Input :: post ( 'value' ) ) . '%' ) ; if ( $ objUsers -> numRows ) { $ arrUsers = $ objUsers -> fetchEach ( 'username' ) ; } header ( 'Content-type: application/json' ) ; die ( json_encode ( $ arrUsers ) ) ; }
12807	public static function where ( string $ column , string $ operator , $ value ) : Collection { $ pdo = Database :: connect ( ) ; $ class = self :: getStaticChildClass ( ) ; $ tableName = self :: getTableName ( ) ; $ column = self :: getColumnName ( $ column ) ; if ( $ column === null ) throw new ModelMissingPropertyException ( "Could not find a property '$column' of class '$class'. " . "Are you missing a '@ColumnNameAnnotation' on a property?" ) ; $ sql = "SELECT * FROM \"$tableName\" WHERE \"$column\" $operator " . ( gettype ( $ value ) === "string" ? "'$value'" : "$value" ) ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; $ collection = new Collection ( $ class , [ ] ) ; foreach ( $ results as $ result ) { $ object = new $ class ( $ result ) ; $ collection -> push ( $ object ) ; } return $ collection ; }
3801	public function getCache ( ) { @ trigger_error ( '"' . __METHOD__ . '" is deprecated as the service container will get removed.' , E_USER_DEPRECATED ) ; if ( \ is_callable ( $ this -> cache ) ) { $ this -> cache = \ call_user_func ( $ this -> cache ) ; } return $ this -> cache ; }
27	public function write ( ) { $ data = array ( ) ; $ dumper = new ArrayDumper ( ) ; foreach ( $ this -> getCanonicalPackages ( ) as $ package ) { $ data [ ] = $ dumper -> dump ( $ package ) ; } usort ( $ data , function ( $ a , $ b ) { return strcmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; $ this -> file -> write ( $ data ) ; }
10524	protected function _unsetData ( $ key ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerUnset ( $ store , $ key ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ key ) ; } }
2866	public function getTotalLineCount ( ) { if ( $ this -> logLineCount === null ) { $ this -> logLineCount = 0 ; foreach ( $ this -> getFiles ( ) as $ log ) { $ this -> logLineCount += $ this -> getLineCount ( $ log ) ; } } return $ this -> logLineCount ; }
6148	public function setBody ( $ body ) { if ( is_string ( $ body ) ) { $ this -> body = $ body ; } elseif ( is_array ( $ body ) ) { $ this -> setJsonBody ( $ body ) ; } elseif ( is_callable ( $ body ) ) { ob_start ( ) ; $ res1 = call_user_func ( $ body ) ; $ res2 = ob_get_contents ( ) ; $ this -> body = $ res2 . $ res1 ; ob_end_clean ( ) ; } return $ this ; }
11999	static protected function phalconQuery ( $ modelName , $ field , $ generate ) { $ return = \ Phalcon \ Mvc \ Model :: query ( ) -> setModelName ( $ modelName ) -> where ( "$field = :value:" ) -> bind ( array ( 'value' => $ generate ) ) -> execute ( ) ; return ( boolean ) $ return -> count ( ) ; }
3279	protected function replace ( string $ key , $ data ) { $ tmpFile = $ this -> getDatabase ( ) -> openTempFile ( ) ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { if ( $ line -> getKey ( ) == $ key ) { if ( $ data !== false ) { $ tmpFile -> fwrite ( $ this -> getLineString ( $ key , $ data ) ) ; } } else { $ tmpFile -> fwrite ( $ line -> getLine ( ) . "\n" ) ; } } $ tmpFile -> rewind ( ) ; $ this -> getDatabase ( ) -> writeTempToFile ( $ tmpFile ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> delete ( $ key ) ; } }
7194	public static function get_thumbnail_file ( $ meta , $ size = 'medium' ) { if ( ! isset ( $ meta [ 'sizes' ] [ $ size ] ) ) { $ file = FALSE ; } else { $ dir = wp_upload_dir ( ) ; $ file_parts = array ( $ dir [ 'basedir' ] , dirname ( $ meta [ 'file' ] ) , $ meta [ 'sizes' ] [ $ size ] [ 'file' ] ) ; $ file = implode ( DIRECTORY_SEPARATOR , $ file_parts ) ; } return apply_filters ( 'iac_attach_media_thumbnail_file' , $ file , $ meta , $ size ) ; }
9307	public function setJsonApiSecurityHash ( $ jsonApiSecurityHash ) { if ( ! is_string ( $ jsonApiSecurityHash ) ) { throw new \ InvalidArgumentException ( '`jsonApiSecurityHash` expects string value!' ) ; } $ this -> options [ 'jsonApiSecurityHash' ] = ( string ) $ jsonApiSecurityHash ; return $ this ; }
6153	public function setPropertyType ( $ propertyType ) { if ( $ propertyType instanceof PropertyType ) { $ this -> propertyType = $ propertyType ; } elseif ( is_array ( $ propertyType ) ) { $ this -> propertyType = new PropertyType ( $ propertyType ) ; } else { $ this -> propertyType = null ; trigger_error ( 'Argument must be an object of class PropertyType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
11344	public function removeField ( $ name ) { for ( $ i = 0 ; $ i < count ( $ this -> fields ) ; $ i ++ ) { if ( $ this -> fields [ $ i ] -> getName ( ) == $ name ) { array_splice ( $ this -> fields , $ i , 1 ) ; break ; } } }
9085	public function getAlias ( string $ abstract ) : string { if ( ! isset ( $ this -> aliases [ $ abstract ] ) ) { return $ abstract ; } if ( $ this -> aliases [ $ abstract ] === $ abstract ) { throw new ContainerException ( "[{$abstract}] is aliased to itself." ) ; } return $ this -> getAlias ( $ this -> aliases [ $ abstract ] ) ; }
3885	private function collectRulesFor ( $ parentSetting , $ filterSettings ) { $ childInformation = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'pid' , $ parentSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ childInformation -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ childSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ childSetting ) { $ parentSetting -> addChild ( $ childSetting ) ; } } }
3268	protected function closeFile ( SplFileObject & $ file ) { if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( LOCK_UN ) ) { $ file = null ; throw new Exception ( 'Could not unlock file' ) ; } $ file = null ; }
6658	public function jsonSerialize ( ) { $ serialized = [ 'message' => $ this -> getPublicMessage ( ) , 'code' => $ this -> getCode ( ) , ] ; if ( $ this -> getPrevious ( ) instanceof $ this ) { $ previous = $ this -> getPrevious ( ) ; $ serialized [ 'previous' ] = $ previous -> jsonSerialize ( ) ; } return $ serialized ; }
6432	public function removeDisplayField ( $ displayField ) { $ key = array_search ( $ displayField , $ this -> displayFields ) ; if ( $ key ) { unset ( $ this -> displayFields [ $ key ] ) ; $ this -> displayFields = array_values ( $ this -> displayFields ) ; } }
11819	public function addAppDependencies ( ) { $ container = $ this -> getContainer ( ) ; $ container [ 'person' ] = $ container -> protect ( function ( $ name ) { return 'Person name: ' . $ name ; } ) ; return $ this ; }
761	public function getSql ( ) { $ code = $ this ; while ( $ code -> parent !== null ) { $ code = $ code -> parent ; } return mb_substr ( $ code -> content , $ this -> startOffset , $ this -> endOffset - $ this -> startOffset , 'UTF-8' ) ; }
5906	public function listSettings ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/settings' , $ parameters , $ cachePolicy ) ; return $ result ; }
12488	public static function write ( $ output ) { if ( self :: $ enabled ) { $ d = new \ DateTime ( ) ; $ f = new File ( self :: $ logFilePath , true ) ; $ f -> write ( $ d -> format ( 'd/m/Y H:i:s' ) . ' - ' . $ output . "\n" , true ) ; } }
5672	protected function describeFloatDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } return sprintf ( 'because [%s] differs from [%s] by %s' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) , abs ( $ first - $ second ) ) ; }
12350	public function validate ( string $ api_session = null ) { $ this -> details = false ; if ( empty ( $ api_session ) === false && is_string ( $ api_session ) === true ) { $ session = Model \ Session :: with ( 'user' ) -> where ( 'code' , $ api_session ) -> first ( ) ; if ( $ session !== null ) { if ( strtotime ( $ session -> updated_at ) < strtotime ( "-1 hour" ) || $ session -> user === null ) { $ this -> invalidate ( $ api_session ) ; } else { $ session -> updated_at = date ( 'Y-m-d H:i:s' ) ; $ session -> save ( ) ; $ this -> details = $ session -> user ; } } else { $ _SESSION [ 'api_session' ] = null ; } } }
5750	public function setRoles ( ) { $ this -> roles = [ ] ; if ( null !== $ records = $ this -> select ( ) ) { foreach ( $ records as $ record ) { $ this -> roles [ ( int ) $ record [ 'id' ] ] = $ record [ 'role' ] ; } } }
3504	private function createByReason ( string $ reason , array $ json ) : SendNotificationException { $ reason = strtolower ( $ reason ) ; switch ( $ reason ) { case 'badcollapseid' : return new BadCollapseIdException ( ) ; case 'baddevicetoken' : return new BadDeviceTokenException ( ) ; case 'badexpirationdate' : return new BadExpirationDateException ( ) ; case 'badmessageid' : return new BadMessageIdException ( ) ; case 'badpriority' : return new BadPriorityException ( ) ; case 'badtopic' : return new BadTopicException ( ) ; case 'devicetokennotfortopic' : return new DeviceTokenNotForTopicException ( ) ; case 'duplicateheaders' : return new DuplicateHeadersException ( ) ; case 'idletimeout' : return new IdleTimeoutException ( ) ; case 'missingdevicetoken' : return new MissingDeviceTokenException ( ) ; case 'missingtopic' : return new MissingTopicException ( ) ; case 'payloadempty' : return new PayloadEmptyException ( ) ; case 'topicdisallowed' : return new TopicDisallowedException ( ) ; case 'badcertificate' : return new BadCertificateException ( ) ; case 'badcertificateenvironment' : return new BadCertificateEnvironmentException ( ) ; case 'expiredprovidertoken' : return new ExpiredProviderTokenException ( ) ; case 'forbidden' : return new ForbiddenException ( ) ; case 'invalidprovidertoken' : return new InvalidProviderTokenException ( ) ; case 'missingprovidertoken' : return new MissingProviderTokenException ( ) ; case 'badpath' : return new BadPathException ( ) ; case 'methodnotallowed' : return new MethodNotAllowedException ( ) ; case 'unregistered' : $ timestamp = array_key_exists ( 'timestamp' , $ json ) ? $ json [ 'timestamp' ] : 0 ; $ lastConfirmed = new \ DateTime ( 'now' , new \ DateTimeZone ( 'UTC' ) ) ; $ lastConfirmed -> setTimestamp ( $ timestamp ) ; return new UnregisteredException ( $ lastConfirmed ) ; case 'payloadtoolarge' : return new PayloadTooLargeException ( ) ; case 'toomanyprovidertokenupdates' : return new TooManyProviderTokenUpdatesException ( ) ; case 'toomanyrequests' : return new TooManyRequestsException ( ) ; case 'internalservererror' : return new InternalServerErrorException ( ) ; case 'serviceunavailable' : return new ServiceUnavailableException ( ) ; case 'shutdown' : return new ShutdownException ( ) ; default : return new UndefinedErrorException ( ) ; } }
5931	public function setDefinition ( $ definition ) { if ( is_array ( $ definition ) ) { $ this -> definition = $ definition ; return $ this ; } $ this -> definition = json_decode ( $ definition , true ) ; if ( null === $ this -> definition ) { $ this -> definition = $ definition ; } return $ this ; }
5867	public static function getOrientation ( $ fileName ) { $ orientation = 1 ; $ metadata = static :: getMetadata ( $ fileName ) ; if ( isset ( $ metadata [ 'Orientation' ] ) ) { $ orientation = $ metadata [ 'Orientation' ] ; } return $ orientation ; }
5777	public function null_eq ( string $ name , $ arg ) { if ( $ arg === null ) { $ this -> sql .= "$name is null" ; } else { $ this -> args [ ] = $ arg ; $ argNum = count ( $ this -> args ) ; $ this -> sql .= "$name = \$$argNum" ; } return $ this ; }
6843	public function call ( Closure $ c , $ params = array ( ) ) { $ ref = new ReflectionFunction ( $ c ) ; $ params_need = $ ref -> getParameters ( ) ; $ args = $ this -> apply ( $ params_need , $ params ) ; return call_user_func_array ( $ c , $ args ) ; }
10277	public static function getDefaultRowHeightByFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { switch ( $ font -> getName ( ) ) { case 'Arial' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; case 'Calibri' : switch ( $ font -> getSize ( ) ) { case 11 : $ rowHeight = 15 ; break ; case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6.00 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } break ; case 'Verdana' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 11.25 ; break ; case 8 : $ rowHeight = 10.50 ; break ; case 7 : $ rowHeight = 9.00 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } return $ rowHeight ; }
10822	public static function block ( $ messages , $ style ) { if ( is_string ( $ messages ) ) { $ messages = [ $ messages ] ; } if ( count ( $ messages ) > 0 ) { self :: writeln ( str_repeat ( ' ' , self :: $ lineLength ) , $ style ) ; foreach ( $ messages as $ message ) { $ message = ' ' . $ message ; while ( strlen ( $ message ) < self :: $ lineLength ) { $ message .= ' ' ; } self :: writeln ( $ message , $ style ) ; } self :: writeln ( str_repeat ( ' ' , self :: $ lineLength ) , $ style ) ; } }
11505	public function getSlots ( $ first , $ last ) { if ( ! static :: isValidRange ( $ first , $ last ) ) { throw new \ OutOfBoundsException ( "Invalid slot range $first-$last" ) ; } return array_intersect_key ( $ this -> slots , array_fill ( $ first , $ last - $ first + 1 , null ) ) ; }
12256	public function getSkylineAppDirectory ( string $ dirName ) { $ name = CC :: get ( [ ] , $ dirName ) ; if ( $ name ) { return $ this -> getSkylineAppDataDirectory ( ) . "/$name" ; } return NULL ; }
4205	private function getParams ( \ ReflectionMethod $ reflectionMethod , $ phpDoc = array ( ) ) { $ paramArray = array ( ) ; $ params = $ reflectionMethod -> getParameters ( ) ; if ( empty ( $ phpDoc ) ) { $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; } foreach ( $ params as $ i => $ reflectionParameter ) { $ nameNoPrefix = $ reflectionParameter -> getName ( ) ; $ name = '$' . $ nameNoPrefix ; if ( \ method_exists ( $ reflectionParameter , 'isVariadic' ) && $ reflectionParameter -> isVariadic ( ) ) { $ name = '...' . $ name ; } if ( $ reflectionParameter -> isPassedByReference ( ) ) { $ name = '&' . $ name ; } $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( $ reflectionParameter -> isDefaultValueAvailable ( ) ) { $ defaultValue = $ reflectionParameter -> getDefaultValue ( ) ; if ( \ version_compare ( PHP_VERSION , '5.4.6' , '>=' ) && $ reflectionParameter -> isDefaultValueConstant ( ) ) { $ constantName = $ reflectionParameter -> getDefaultValueConstantName ( ) ; } } $ paramInfo = array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , 'desc' => null , 'isOptional' => $ reflectionParameter -> isOptional ( ) , 'name' => $ name , 'type' => $ this -> getParamTypeHint ( $ reflectionParameter ) , ) ; if ( isset ( $ phpDoc [ 'param' ] [ $ i ] ) ) { $ paramInfo [ 'desc' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'desc' ] ; if ( ! isset ( $ paramInfo [ 'type' ] ) ) { $ paramInfo [ 'type' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'type' ] ; } } $ paramArray [ $ nameNoPrefix ] = $ paramInfo ; } return $ paramArray ; }
5188	private function createPage ( string $ title , string $ body , string $ source , int $ order , string $ cover , string $ lead ) : \ One \ Model \ Page { return new Page ( $ title , $ body , $ source , $ order , $ cover , $ lead ) ; }
3560	protected function getValueType ( $ value ) { $ type = is_object ( $ value ) ? get_class ( $ value ) : gettype ( $ value ) ; return ( $ type == 'double' ) ? 'float' : $ type ; }
3918	private function checkDownloads ( ) { if ( $ this -> getShowImages ( ) ) { return ; } if ( ( $ file = Input :: get ( 'file' ) ) && ( $ key = Input :: get ( 'fileKey' ) ) ) { if ( ! ( array_key_exists ( $ file , $ _SESSION [ 'metaModels_downloads' ] ) && $ _SESSION [ 'metaModels_downloads' ] [ $ file ] === $ key ) ) { $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_403' ] ( ) ; $ objHandler -> generate ( $ file ) ; } Controller :: sendFileToBrowser ( $ file ) ; } }
12059	public function setTarget ( $ value ) { if ( in_array ( $ value , $ this -> possibleTargets ) ) { $ this -> _target = $ value ; } else { throw new Exception ( 'Unknown deletion target ' . $ value ) ; } }
429	public function getUniqueId ( ) { return $ this -> module ? ltrim ( $ this -> module -> getUniqueId ( ) . '/' . $ this -> id , '/' ) : $ this -> id ; }
9423	public function getSize ( ) { if ( is_null ( $ this -> size ) === true ) { $ stats = fstat ( $ this -> stream ) ; $ this -> size = $ stats [ 'size' ] ; } return $ this -> size ; }
9005	protected function get_levels ( ) { return array ( LogLevel :: EMERGENCY => 'Emergency' , LogLevel :: ALERT => 'Alert' , LogLevel :: CRITICAL => 'Critical' , LogLevel :: ERROR => 'Error' , LogLevel :: WARNING => 'Warning' , LogLevel :: NOTICE => 'Notice' , LogLevel :: INFO => 'Info' , LogLevel :: DEBUG => 'Debug' ) ; }
5510	public function expectAt ( $ timing , $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments at time' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments at time' ) ; $ args = $ this -> replaceWildcards ( $ args ) ; if ( ! isset ( $ this -> expected_args_at [ $ timing ] ) ) { $ this -> expected_args_at [ $ timing ] = array ( ) ; } $ method = strtolower ( $ method ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args_at [ $ timing ] [ $ method ] = new ParametersExpectation ( $ args , $ message ) ; }
4601	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_PUT ) ) { return ; } if ( ! $ request -> attributes -> has ( 'data' ) ) { return ; } $ data = $ request -> attributes -> get ( 'data' ) ; if ( ! $ data instanceof Access ) { return ; } $ access = $ data ; $ manager = $ this -> accessService -> getManager ( ) ; foreach ( $ access -> getPermissions ( ) as $ permission ) { $ manager -> remove ( $ permission ) ; } $ manager -> flush ( ) ; }
11619	public function site ( ) : \ TheCMSThread \ Core \ Main \ Site { static $ site ; if ( $ site === null ) { $ site = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\Site" ) ; } return $ site ; }
5985	public function setTokens ( AccessToken $ accessToken , AccessToken $ refreshToken = null ) { if ( $ accessToken instanceof AccessToken && false === $ accessToken -> isExpired ( ) ) { if ( $ this -> cache instanceof Cache ) { $ this -> cache -> save ( 'oauth2accesstoken' , serialize ( $ accessToken ) , $ accessToken -> getExpires ( ) -> getTimestamp ( ) - ( new \ DateTime ( ) ) -> getTimestamp ( ) ) ; } $ this -> oauth2Middleware -> setAccessToken ( $ accessToken ) ; } if ( $ refreshToken instanceof AccessToken && false === $ accessToken -> isExpired ( ) ) { if ( $ this -> cache instanceof Cache ) { $ this -> cache -> save ( 'oauth2refreshtoken' , serialize ( $ refreshToken ) , $ refreshToken -> getExpires ( ) instanceof \ DateTime ? $ refreshToken -> getExpires ( ) -> getTimestamp ( ) - ( new \ DateTime ( ) ) -> getTimestamp ( ) : 3600 * 24 * 13 ) ; } $ this -> oauth2Middleware -> setRefreshToken ( $ refreshToken ) ; } }
1273	public function isAmbiguous ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> AmbiguousAddressIndicator ) ; }
7016	private function format_g ( & $ str ) { if ( strstr ( $ str , '%g' ) ) { $ h = $ this -> hour > 12 ? $ this -> hour - 12 : $ this -> hour ; $ str = str_replace ( '%g' , sprintf ( '%1d' , $ h ) , $ str ) ; } }
5076	public function getIndex ( $ aData = [ ] , $ iPage = null , $ iPerPage = null ) { $ oInput = Factory :: service ( 'Input' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; if ( is_null ( $ iPage ) ) { $ iPage = ( int ) $ oInput -> get ( 'page' ) ? : 1 ; } if ( is_null ( $ iPerPage ) ) { $ iPerPage = static :: CONFIG_MAX_ITEMS_PER_PAGE ; } $ aResults = $ oItemModel -> getAll ( $ iPage , $ iPerPage , $ aData ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( array_map ( [ $ this , 'formatObject' ] , $ aResults ) ) ; return $ oResponse ; }
7822	protected function refreshPipelines ( ) { $ yaml = $ this -> parser -> dump ( $ this -> pipelines ) ; $ this -> files -> put ( $ this -> getSource ( ) , $ yaml ) ; }
11909	public function getRequiredParams ( ) { $ requiredParams = [ ] ; foreach ( $ this -> parameters as $ parameter ) { if ( $ parameter -> getIsOptional ( ) || $ parameter -> hasDefault ( ) ) { continue ; } $ requiredParams [ ] = $ parameter ; } return $ requiredParams ; }
9137	public function call ( callable $ callable , array $ args = [ ] ) { $ args = $ this -> resolveArguments ( $ args ) ; $ reflection = $ this -> reflectCallable ( $ callable ) ; return call_user_func_array ( $ callable , $ this -> getParameters ( $ reflection , $ args ) ) ; }
4809	public function deactivate ( ) { $ this -> clear_schedule ( ) ; if ( ! is_multisite ( ) || wp_is_large_network ( ) ) { return ; } $ sites = ( array ) get_site_option ( $ this -> args [ 'name' ] . '_sites' , array ( ) ) ; $ sites and $ sites = array_diff ( $ sites , [ get_current_blog_id ( ) ] ) ; foreach ( $ sites as $ site ) { switch_to_blog ( $ site ) ; $ this -> clear_schedule ( ) ; } restore_current_blog ( ) ; delete_site_option ( $ this -> args [ 'name' ] . '_sites' ) ; }
8125	protected function getSchemaRequested ( ) { $ parts = $ this -> owner -> getRequest ( ) -> getHeader ( LeftAndMain :: SCHEMA_HEADER ) ; return ! empty ( $ parts ) ; }
6395	public function init ( ) { parent :: init ( ) ; $ this -> path = Yii :: getAlias ( $ this -> path ) ; FileHelper :: createDirectory ( $ this -> path , $ this -> dirMode , true ) ; }
4199	public function addConstants ( Event $ abs ) { if ( ! $ this -> abstracter -> getCfg ( 'collectConstants' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; $ constants = $ reflector -> getConstants ( ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ constants = \ array_merge ( $ reflector -> getConstants ( ) , $ constants ) ; } if ( $ this -> abstracter -> getCfg ( 'objectSort' ) == 'name' ) { \ ksort ( $ constants ) ; } $ abs [ 'constants' ] = $ constants ; }
4952	protected function checkRatingValue ( $ rating , $ throwException = true ) { if ( ! is_int ( $ rating ) || static :: RATING_EXCELLENT < $ rating || static :: RATING_NONE > $ rating ) { if ( $ throwException ) { throw new \ InvalidArgumentException ( sprintf ( '%s is not a valid rating value.' , $ rating ) ) ; } return false ; } return true ; }
6688	public function isPostCheck ( $ redirectUrl = null ) { if ( $ this -> getRequest ( ) -> isPost ) { return true ; } if ( is_null ( $ redirectUrl ) ) { return false ; } $ this -> sendTerminalResponse ( $ redirectUrl ) ; }
2398	public static function changeSubscriptionStatus ( FrontendTemplate $ objTemplate ) { if ( strncmp ( Input :: get ( 'token' ) , 'com-' , 4 ) === 0 ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) != 1 || key ( $ arrRelated ) != 'tl_comments_notify' || \ count ( $ arrIds = current ( $ arrRelated ) ) != 1 || ( ! $ objNotify = CommentsNotifyModel :: findByPk ( $ arrIds [ 0 ] ) ) ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objNotify -> email ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ objNotify -> active = '1' ; $ objNotify -> save ( ) ; $ optInToken -> confirm ( ) ; $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_optInConfirm' ] ; } elseif ( strncmp ( Input :: get ( 'token' ) , 'cor-' , 4 ) === 0 ) { $ objNotify = CommentsNotifyModel :: findOneByTokenRemove ( Input :: get ( 'token' ) ) ; if ( $ objNotify === null ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } $ objNotify -> delete ( ) ; $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_optInCancel' ] ; } }
5572	public function authenticate ( $ username , $ password ) { if ( ! $ this -> page -> getRealm ( ) ) { return false ; } $ url = $ this -> page -> getUrl ( ) ; if ( ! $ url ) { return false ; } $ this -> user_agent -> setIdentity ( $ url -> getHost ( ) , $ this -> page -> getRealm ( ) , $ username , $ password ) ; return $ this -> retry ( ) ; }
11858	public function getHandler ( ) { if ( $ this -> pairedDataItem ) { if ( ! isset ( $ this -> primaryObject ) ) { return $ this -> pairedDataItem ; } elseif ( isset ( $ this -> companionObject ) ) { return static :: getHandlingObject ( $ this , $ this -> pairedDataItem ) ; } } return $ this ; }
5760	public function getObjects ( array $ whereColumnsInfo = null , string $ orderBy = null ) : array { $ permissions = [ ] ; foreach ( $ this -> selectArray ( null , $ whereColumnsInfo , $ orderBy ) as $ permissionArray ) { $ permissions [ ] = $ this -> buildPermission ( $ permissionArray [ 'id' ] , $ permissionArray [ 'title' ] , $ permissionArray [ 'description' ] , $ permissionArray [ 'active' ] , $ permissionArray [ 'created' ] , $ permissionArray [ 'roles' ] ) ; } return $ permissions ; }
9691	private function compile ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } if ( ! file_exists ( $ this -> views_cache ) && ! mkdir ( $ this -> views_cache ) ) { throw new \ Exception ( "Could no create cache directory." . " Make sure you have write permissions." ) ; } $ hash = md5 ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; $ compiled = null ; if ( $ this -> debug || ( ! file_exists ( $ compiled_file ) || filemtime ( $ compiled_file ) < filemtime ( $ file ) ) ) { $ source = file_get_contents ( $ file ) ; $ compiled = $ this -> compileString ( $ source ) ; $ compiled = "<?php\nfunction katar_" . $ hash . "(\$args) {\nextract(\$args);\n\$output = null;\n" . $ compiled . "\nreturn \$output;\n}\n" ; file_put_contents ( $ compiled_file , $ compiled ) ; } else { $ compiled = file_get_contents ( $ cache_file ) ; } return $ compiled ; }
6216	public static function realmNameToSlug ( string $ name ) : string { $ name = \ mb_strtolower ( $ name , 'UTF-8' ) ; $ slug = \ str_replace ( static :: $ replaceTable [ 0 ] , static :: $ replaceTable [ 1 ] , $ name ) ; $ slug = \ preg_replace ( static :: $ regexTable [ 0 ] , static :: $ regexTable [ 1 ] , $ slug ) ; return \ trim ( ( string ) $ slug , '-' ) ; }
8161	public function block ( ) { $ this -> status = User :: STATUS_BLOCKED ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
256	public function afterRun ( $ result ) { $ event = new WidgetEvent ( ) ; $ event -> result = $ result ; $ this -> trigger ( self :: EVENT_AFTER_RUN , $ event ) ; return $ event -> result ; }
10434	protected function prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) { return array_merge ( $ serviceConfig , $ typeConfig [ 'config' ] , [ 'entity_class' => $ typeConfig [ 'entity_class' ] , 'document_class' => $ typeConfig [ 'document_class' ] , 'document_type' => $ type , ] ) ; }
7131	protected function updateTotals ( SupplierOrderInterface $ order ) { $ changed = false ; $ tax = $ this -> calculator -> calculatePaymentTax ( $ order ) ; if ( $ tax != $ order -> getTaxTotal ( ) ) { $ order -> setTaxTotal ( $ tax ) ; $ changed = true ; } $ payment = $ this -> calculator -> calculatePaymentTotal ( $ order ) ; if ( $ payment != $ order -> getPaymentTotal ( ) ) { $ order -> setPaymentTotal ( $ payment ) ; $ changed = true ; } if ( null !== $ order -> getCarrier ( ) ) { $ forwarder = $ this -> calculator -> calculateForwarderTotal ( $ order ) ; if ( $ forwarder != $ order -> getForwarderTotal ( ) ) { $ order -> setForwarderTotal ( $ forwarder ) ; $ changed = true ; } } else { if ( 0 != $ order -> getForwarderFee ( ) ) { $ order -> setForwarderFee ( 0 ) ; $ changed = true ; } if ( 0 != $ order -> getCustomsTax ( ) ) { $ order -> setCustomsTax ( 0 ) ; $ changed = true ; } if ( 0 != $ order -> getCustomsVat ( ) ) { $ order -> setCustomsVat ( 0 ) ; $ changed = true ; } if ( 0 != $ order -> getForwarderTotal ( ) ) { $ order -> setForwarderTotal ( 0 ) ; $ changed = true ; } if ( null !== $ order -> getForwarderDate ( ) ) { $ order -> setForwarderDate ( null ) ; $ changed = true ; } if ( null !== $ order -> getForwarderDueDate ( ) ) { $ order -> setForwarderDueDate ( null ) ; $ changed = true ; } } return $ changed ; }
8482	public static function getOS ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Caption FROM Win32_OperatingSystem" ) as $ os ) { return $ os -> Caption ; } return "Windows" ; }
11625	public function processContent ( Operation $ operation , $ data ) { if ( is_array ( $ data ) ) { $ status = $ this -> contentService -> getSocialMediaScheduleByOperation ( $ operation ) ; if ( ! $ data [ 'locations' ] instanceof ArrayCollection ) { $ locations = $ this -> em -> getRepository ( 'CampaignChainCoreBundle:Location' ) -> findById ( array_values ( $ data [ 'locations' ] ) ) ; $ locations = new ArrayCollection ( $ locations ) ; } else { $ locations = $ data [ 'locations' ] ; } $ status -> setLocations ( $ locations ) ; $ status -> setMessage ( $ data [ 'message' ] ) ; } else { $ status = $ data ; } return $ status ; }
8827	public function token ( ) { $ token = ! empty ( $ this -> csrfToken ) ? $ this -> csrfToken : csrfToken ( ) ; return $ this -> hidden ( '_token' , $ token ) ; }
11500	protected function _setupDatabaseAdapter ( ) { if ( Zend_Registry :: isRegistered ( 'multidb' ) ) { return $ this -> _setAdapter ( Zend_Registry :: get ( 'multidb' ) -> getDb ( $ this -> _connection ) ) ; } return parent :: _setupDatabaseAdapter ( ) ; }
3048	public function init ( ) { $ sessionStateService = $ this -> getServiceManager ( ) -> get ( SessionStateService :: SERVICE_ID ) ; $ sessionStateService -> resumeSession ( $ this -> getTestSession ( ) ) ; $ this -> retrieveItemIndex ( ) ; }
10402	public function createApplication ( string $ app_type , FileSystemInterface $ filesystem ) : ApplicationInterface { switch ( $ app_type ) { case ApplicationType :: SHELL : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( CalgamoShellRequestModule :: class ) ; case ApplicationType :: CRON : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( CalgamoShellRequestModule :: class ) ; break ; case ApplicationType :: HTTP : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( 'zend.request' ) ; break ; case ApplicationType :: REST : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( ZendRequestModule :: class ) -> requireModule ( CalgamoRestApiModule :: class ) ; break ; } return new NullApplication ( ) ; }
478	public function dropColumn ( $ table , $ column ) { $ time = $ this -> beginCommand ( "drop column $column from table $table" ) ; $ this -> db -> createCommand ( ) -> dropColumn ( $ table , $ column ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
11762	public static function get ( $ property , $ default = NULL ) { $ object = new \ ReflectionClass ( Collection :: class ) ; $ value = $ object -> getStaticPropertyValue ( $ property ) ; return ( empty ( $ value ) ) ? $ default : $ value ; }
8192	public static function guess ( $ name ) { if ( in_array ( substr ( $ name , - 1 ) , array ( '/' , '\\' ) ) ) { return 'html' ; } if ( '.twig' === substr ( $ name , - 5 ) ) { $ name = substr ( $ name , 0 , - 5 ) ; } $ extension = pathinfo ( $ name , PATHINFO_EXTENSION ) ; switch ( $ extension ) { case 'js' : return 'js' ; case 'css' : return 'css' ; case 'txt' : return false ; default : return 'html' ; } }
5144	private static function createPhoto ( string $ url , string $ ratio , string $ description , string $ information ) : \ One \ Model \ Photo { return new Photo ( $ url , $ ratio , $ description , $ information ) ; }
1657	public function get ( $ name ) { foreach ( $ this -> arguments as $ argument ) { if ( $ argument [ 'name' ] == $ name ) { if ( isset ( $ this -> mapArgumentName [ $ name ] ) ) { return $ this -> { $ this -> mapArgumentName [ $ name ] } ( $ argument ) ; } else { return $ argument ; } } } }
822	private function fixSemicolonAfterCurlyBraceClose ( Tokens $ tokens , $ index , $ curlyCloseIndex ) { static $ beforeCurlyOpeningKinds = null ; if ( null === $ beforeCurlyOpeningKinds ) { $ beforeCurlyOpeningKinds = [ T_ELSE , T_FINALLY , T_NAMESPACE , T_OPEN_TAG ] ; } $ curlyOpeningIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ curlyCloseIndex ) ; $ beforeCurlyOpening = $ tokens -> getPrevMeaningfulToken ( $ curlyOpeningIndex ) ; if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( $ beforeCurlyOpeningKinds ) || $ tokens [ $ beforeCurlyOpening ] -> equalsAny ( [ ';' , '{' , '}' ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( T_STRING ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ beforeCurlyOpening ) ; while ( $ tokens [ $ classyTest ] -> equals ( ',' ) || $ tokens [ $ classyTest ] -> isGivenKind ( [ T_STRING , T_NS_SEPARATOR , T_EXTENDS , T_IMPLEMENTS ] ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ classyTest ) ; } $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; if ( $ tokens [ $ classyTest ] -> isGivenKind ( T_NAMESPACE ) || ( $ tokens [ $ classyTest ] -> isClassy ( ) && ! $ tokensAnalyzer -> isAnonymousClass ( $ classyTest ) ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } return ; } if ( ! $ tokens [ $ beforeCurlyOpening ] -> equals ( ')' ) ) { return ; } $ openingBrace = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ beforeCurlyOpening ) ; $ beforeOpeningBrace = $ tokens -> getPrevMeaningfulToken ( $ openingBrace ) ; if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( [ T_IF , T_ELSEIF , T_FOR , T_FOREACH , T_WHILE , T_SWITCH , T_CATCH , T_DECLARE ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( T_STRING ) ) { $ beforeString = $ tokens -> getPrevMeaningfulToken ( $ beforeOpeningBrace ) ; if ( $ tokens [ $ beforeString ] -> isGivenKind ( T_FUNCTION ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } } }
8947	public function uploadTrace ( $ file , $ description , $ tags , $ public , $ visibility , $ username , $ password ) { $ parameters = array ( 'file' => $ file , 'description' => $ description , 'tags' => $ tags , 'public' => $ public , 'visibility' => $ visibility , ) ; $ base = 'gpx/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'Content-Type' ] = 'multipart/form-data' ; $ header = array_merge ( $ header , $ parameters ) ; $ header = array_merge ( $ header , array ( 'Authorization' => 'Basic ' . base64_encode ( $ username . ':' . $ password ) ) ) ; return $ this -> sendRequest ( $ path , 'POST' , $ header , array ( ) ) ; }
6010	public function setDateRange ( $ dateRange ) { if ( $ dateRange instanceof DateTimeRange ) { $ this -> dateRange = $ dateRange ; } elseif ( is_array ( $ dateRange ) ) { $ this -> dateRange = new DateTimeRange ( $ dateRange ) ; } else { $ this -> dateRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
10560	public function init ( array $ config = [ ] ) { foreach ( $ config as $ key => $ value ) { switch ( $ key ) { case 'default_controller' : $ this -> defaultController = $ value ; break ; case 'default_action' : $ this -> defaultAction = $ value ; break ; case 'namespaces' : $ this -> namespaces = $ value ; break ; default : break ; } } }
1543	protected function cursor ( EncodingParametersInterface $ parameters ) { return Cursor :: create ( ( array ) $ parameters -> getPaginationParameters ( ) , $ this -> before , $ this -> after , $ this -> limit ) ; }
7401	private function getErrors ( Form $ form ) { $ errors = array ( ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { return $ errors ; } $ id = $ form -> createView ( ) -> vars [ 'id' ] ; foreach ( $ form -> getErrors ( ) as $ error ) { if ( ! isset ( $ errors [ $ id ] ) ) { $ errors [ $ id ] = array ( ) ; } $ errors [ $ id ] [ ] = $ error -> getMessage ( ) ; } foreach ( $ form -> all ( ) as $ child ) { $ errors = array_merge ( $ this -> getErrors ( $ child ) , $ errors ) ; } return $ errors ; }
4924	public function type ( $ className ) { if ( ! class_exists ( $ className ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Class %s is non-existent or could not be loaded' , $ className ) ) ; } $ this -> matrix [ $ this -> currentRegion ] [ ] = $ className ; return $ this ; }
1154	public function makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'makeReplacements' , [ $ message , $ attribute , $ rule , $ parameters ] ) ; }
2837	public function getInfoAsArray ( ) { return array ( 'design_area' => $ this -> getArea ( ) , 'package_name' => $ this -> getPackageName ( ) , 'layout_theme' => $ this -> getThemeLayout ( ) , 'template_theme' => $ this -> getThemeTemplate ( ) , 'locale' => $ this -> getThemeLocale ( ) , 'skin' => $ this -> getThemeSkin ( ) ) ; }
10844	protected function calculateAttributePrice ( VariantInterface $ variant , $ amount ) { $ modifierType = $ variant -> getModifierType ( ) ; $ modifierValue = $ variant -> getModifierValue ( ) ; switch ( $ modifierType ) { case '+' : $ amount = $ amount + $ modifierValue ; break ; case '-' : $ amount = $ amount - $ modifierValue ; break ; case '%' : $ amount = $ amount * ( $ modifierValue / 100 ) ; break ; } return round ( $ amount , 2 ) ; }
8567	private function _convertGetShipment ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetShipment' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentId ( ) ) { $ parameters [ 'ShipmentId' ] = $ request -> getShipmentId ( ) ; } return $ parameters ; }
2378	public static function specialchars ( $ strString , $ blnStripInsertTags = false , $ blnDoubleEncode = false ) { if ( $ blnStripInsertTags ) { $ strString = static :: stripInsertTags ( $ strString ) ; } return htmlspecialchars ( $ strString , ENT_COMPAT , Config :: get ( 'characterSet' ) , $ blnDoubleEncode ) ; }
11306	public static function getDataFromId ( $ id ) { $ db = Neuron_Core_Database :: __getInstance ( ) ; $ id = intval ( $ id ) ; $ r = $ db -> getDataFromQuery ( $ db -> customQuery ( " SELECT * FROM n_players WHERE n_players.plid = '" . $ id . "' " ) ) ; if ( count ( $ r ) == 1 ) { return $ r [ 0 ] ; } return null ; }
12681	public function send ( ) { if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message to send.' ) ; } $ transformer = new Transformer ( ) ; if ( $ this -> message instanceof RawMessage ) { $ message = $ this -> message -> get ( 'content' ) ; } else { $ content = $ transformer -> transform ( $ this -> message ) ; $ message = [ 'touser' => $ this -> to , ] ; if ( $ this -> account ) { $ message [ 'customservice' ] = [ 'kf_account' => $ this -> account ] ; } $ message = array_merge ( $ message , $ content ) ; } return $ this -> staff -> send ( $ message ) ; }
3492	public function withHeaders ( array $ headers ) : Request { $ cloned = clone $ this ; foreach ( $ headers as $ name => $ value ) { $ cloned = $ cloned -> withHeader ( $ name , $ value ) ; } return $ cloned ; }
776	private function supportsFractionalSeconds ( ) { $ version = $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_SERVER_VERSION ) ; return version_compare ( $ version , '5.6.4' , '>=' ) ; }
9405	public function push ( $ middleware ) { if ( is_array ( $ middleware ) ) { $ this -> stack = array_merge ( $ this -> stack , $ middleware ) ; return $ this ; } $ this -> stack [ ] = $ middleware ; return $ this ; }
9695	private function applyInlineStyle ( & $ sheet , $ row , $ column , $ attributeArray ) { if ( ! isset ( $ attributeArray [ 'style' ] ) ) { return ; } $ supported_styles = [ 'background-color' , 'color' ] ; $ styles = explode ( ';' , $ attributeArray [ 'style' ] ) ; foreach ( $ styles as $ st ) { $ value = explode ( ':' , $ st ) ; if ( empty ( trim ( $ value [ 0 ] ) ) || ! in_array ( trim ( $ value [ 0 ] ) , $ supported_styles ) ) { continue ; } if ( substr ( trim ( $ value [ 1 ] ) , 0 , 1 ) == '#' ) { $ style_color = substr ( trim ( $ value [ 1 ] ) , 1 ) ; } if ( empty ( $ style_color ) ) { continue ; } switch ( trim ( $ value [ 0 ] ) ) { case 'background-color' : $ sheet -> getStyle ( $ column . $ row ) -> applyFromArray ( [ 'fill' => [ 'fillType' => Fill :: FILL_SOLID , 'color' => [ 'rgb' => "{$style_color}" ] ] ] ) ; break ; case 'color' : $ sheet -> getStyle ( $ column . $ row ) -> applyFromArray ( [ 'font' => [ 'color' => [ 'rgb' => "$style_color}" ] ] ] ) ; break ; } } }
1927	public function isSemitransparent ( ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return false ; } $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ alpha = ( imagecolorat ( $ this -> gdResource , $ x , $ y ) >> 24 ) & 0x7F ; if ( $ alpha > 0 && $ alpha < 127 ) { return true ; } } } return false ; }
5393	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'fail>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "fail>\n" ; }
11790	public function clear ( $ name = null ) { if ( ! is_null ( $ name ) ) { $ name = strtolower ( $ name ) ; if ( array_key_exists ( $ name , self :: $ clearings ) ) { $ this -> { $ name } = self :: $ clearings [ $ self :: $ clearings ] ; } } else { foreach ( self :: $ clearings as $ n => $ v ) { $ this -> { $ n } = $ v ; } } return $ this ; }
2401	public function route ( $ strName , $ arrParams = array ( ) ) { $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( $ strName , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; return ampersand ( $ strUrl ) ; }
7266	public static function find ( $ id , $ idColumn = null ) { $ tableName = static :: tableName ( ) ; $ idColumn = $ idColumn ? : static :: $ idColumn ; $ rows = Db :: query ( " select * from $tableName where $idColumn = :id " , [ "id" => $ id ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ model = new static ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ model -> $ col = $ model -> decodeValue ( $ val , $ col ) ; return $ model ; }
12230	public function deleteNodes ( $ xpath ) { if ( ! is_string ( $ xpath ) ) { throw new InvalidArgumentException ( 'Argument 1 passed to deleteNodes() must be a string, ' . gettype ( $ xpath ) . ' given' ) ; } $ nodes = $ this -> _xpath ( $ xpath ) ; if ( isset ( $ nodes [ 0 ] ) ) { $ tmp = dom_import_simplexml ( $ nodes [ 0 ] ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { unset ( $ nodes [ 0 ] ) ; } } foreach ( $ nodes as $ node ) { $ node -> deleteSelf ( ) ; } return count ( $ nodes ) ; }
1790	private function prepareAlias ( string $ alias , array & $ parameters ) : void { if ( 'index' === $ alias ) { return ; } $ hasAutoItem = false ; $ autoItems = $ this -> getAutoItems ( $ parameters ) ; $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ parameters [ 'alias' ] = preg_replace_callback ( '/\{([^\}]+)\}/' , static function ( array $ matches ) use ( $ alias , & $ parameters , $ autoItems , & $ hasAutoItem , $ config ) : string { $ param = $ matches [ 1 ] ; if ( ! isset ( $ parameters [ $ param ] ) ) { throw new MissingMandatoryParametersException ( sprintf ( 'Parameters "%s" is missing to generate a URL for "%s"' , $ param , $ alias ) ) ; } $ value = $ parameters [ $ param ] ; unset ( $ parameters [ $ param ] ) ; if ( $ hasAutoItem || ! $ config -> get ( 'useAutoItem' ) || ! \ in_array ( $ param , $ autoItems , true ) ) { return $ param . '/' . $ value ; } $ hasAutoItem = true ; return $ value ; } , $ alias ) ; }
11577	public function actionConfirm ( $ id , $ code ) { $ user = $ this -> finder -> findUserById ( $ id ) ; if ( $ user === null || $ this -> module -> enableConfirmation == false ) { throw new NotFoundHttpException ; } $ user -> attemptConfirmation ( $ code ) ; return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Account confirmation' ) , 'module' => $ this -> module , ] ) ; }
9684	public function getStorage ( ) { if ( null === $ this -> storage ) { $ this -> setStorage ( new Storage \ File ( array ( 'dir' => DATA_PATH ) ) ) ; } return $ this -> storage ; }
10255	public function getApartment ( ) { $ types = [ 'Apt.' , 'Apartment' , 'Ste.' , 'Suite' , 'Box' ] ; if ( $ this -> getBool ( true , false ) ) { $ extra = $ this -> getLetter ( ) ; } else { $ extra = $ this -> getInteger ( 1 , 9999 ) ; } $ type = $ this -> fromArray ( $ types ) ; return $ type . ' ' . $ extra ; }
10984	public static function getHostId ( ) { if ( self :: isWindows ( ) ) { $ uuid = explode ( "\r\n" , trim ( shell_exec ( 'wmic csproduct get UUID' ) ) ) ; return ( \ count ( $ uuid ) === 2 ? $ uuid [ 1 ] : false ) ; } $ uuid = trim ( shell_exec ( 'hostid' ) ) ; return $ uuid === null ? false : $ uuid ; }
840	public function setSize ( $ size ) { if ( $ this -> getSize ( ) !== $ size ) { $ this -> changed = true ; parent :: setSize ( $ size ) ; } }
6379	protected function readStoreRecords ( $ type , array $ query ) { $ model = $ this -> store -> get_records ( $ type , $ query ) ; return $ model ; }
8673	private function iterateReverseFromIndex ( $ fromIndex ) { Assert :: nullOrInteger ( $ fromIndex ) ; $ index = count ( $ this -> items ) ; if ( $ index === 0 ) { return ; } if ( $ fromIndex !== null ) { $ index = $ fromIndex < 0 ? max ( $ index + $ fromIndex , 1 ) : min ( $ fromIndex + 1 , $ index ) ; } $ keys = array_keys ( $ this -> items ) ; while ( -- $ index >= 0 ) { $ key = $ keys [ $ index ] ; yield $ key => $ this -> items [ $ key ] ; } }
5993	public function addSearchSort ( $ item ) { if ( ! ( $ item instanceof SearchSort ) ) { if ( is_array ( $ item ) ) { try { $ item = new SearchSort ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate SearchSort. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "SearchSort"!' , E_USER_WARNING ) ; } } $ this -> sortFields [ ] = $ item ; return $ this ; }
4379	protected function dumpArray ( $ array ) { if ( empty ( $ array ) ) { $ html = '<span class="t_keyword">array</span>' . '<span class="t_punct">()</span>' ; } else { $ displayKeys = $ this -> debug -> getCfg ( 'output.displayListKeys' ) || ! $ this -> debug -> utilities -> isList ( $ array ) ; $ html = '<span class="t_keyword">array</span>' . '<span class="t_punct">(</span>' . "\n" ; if ( $ displayKeys ) { $ html .= '<span class="array-inner">' . "\n" ; foreach ( $ array as $ key => $ val ) { $ html .= "\t" . '<span class="key-value">' . '<span class="t_key' . ( \ is_int ( $ key ) ? ' t_int' : '' ) . '">' . $ this -> dump ( $ key , true , false ) . '</span> ' . '<span class="t_operator">=&gt;</span> ' . $ this -> dump ( $ val ) . '</span>' . "\n" ; } $ html .= '</span>' ; } else { $ html .= '<ul class="array-inner list-unstyled">' . "\n" ; foreach ( $ array as $ val ) { $ html .= $ this -> dump ( $ val , true , 'li' ) ; } $ html .= '</ul>' ; } $ html .= '<span class="t_punct">)</span>' ; } return $ html ; }
4126	public function getDocumentNamespace ( $ documentNamespaceAlias ) { if ( ! isset ( $ this -> attributes [ 'documentNamespaces' ] [ $ documentNamespaceAlias ] ) ) { throw CouchDBException :: unknownDocumentNamespace ( $ documentNamespaceAlias ) ; } return trim ( $ this -> attributes [ 'documentNamespaces' ] [ $ documentNamespaceAlias ] , '\\' ) ; }
208	public static function select ( $ prompt , $ options = [ ] ) { top : static :: stdout ( "$prompt [" . implode ( ',' , array_keys ( $ options ) ) . ',?]: ' ) ; $ input = static :: stdin ( ) ; if ( $ input === '?' ) { foreach ( $ options as $ key => $ value ) { static :: output ( " $key - $value" ) ; } static :: output ( ' ? - Show help' ) ; goto top ; } elseif ( ! array_key_exists ( $ input , $ options ) ) { goto top ; } return $ input ; }
11151	public function getApi ( ) { if ( $ this -> api === null ) { $ this -> api = new ExtDirectApi ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; } return $ this -> api ; }
6349	public static function limit ( Iterator $ iterator , int $ limitSize ) : Iterator { Preconditions :: checkArgument ( 0 <= $ limitSize ) ; return new NoRewindNecessaryLimitIterator ( $ iterator , $ limitSize ) ; }
8727	public function getDirty ( ) { $ dirty = parent :: getDirty ( ) ; if ( ! $ this -> localeChanged ) { return $ dirty ; } foreach ( $ this -> translatableAttributes ( ) as $ key ) { if ( isset ( $ this -> attributes [ $ key ] ) ) { $ dirty [ $ key ] = $ this -> attributes [ $ key ] ; } } return $ dirty ; }
11450	public function getParentUri ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; if ( ! is_string ( $ func ) ) { return ; } $ relat = $ this -> $ func ( ) ; $ parentResourceName = $ relat -> getRelated ( ) -> getResourceName ( ) ; $ field = $ relat -> getForeignKey ( ) ; if ( ! $ this -> $ field ) { return Api :: url ( ) ; } return Api :: url ( ) . '/' . $ parentResourceName . '/' . Api :: encodeHashId ( $ this -> $ field ) ; } return Api :: url ( ) ; }
9604	public function scalarTripleProduct ( self $ b , self $ c ) { return $ this -> dotProduct ( $ b -> crossProduct ( $ c ) ) ; }
8345	public static function prefix ( string $ namespace , $ subdomain = null , string $ uri = null ) { self :: $ namespace = $ namespace ; self :: $ subdomain = is_array ( $ subdomain ) ? $ subdomain : [ $ subdomain ] ; self :: $ uri = $ uri ; }
9767	function least ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , greaterThanOrEqual ( $ value ) ) ; }
6906	public function addExtraRecipient ( Recipient $ recipient ) { if ( ! $ this -> extraRecipients -> contains ( $ recipient ) ) { $ this -> extraRecipients -> add ( $ recipient ) ; } return $ this ; }
12615	public function addAttribute ( AttributeInterface $ attribute ) { if ( isset ( $ this -> attributes [ $ attribute -> getName ( ) ] ) ) trigger_error ( "Attribute " . $ attribute -> getName ( ) . " already exists" , E_USER_NOTICE ) ; $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; }
11981	public function isAccessible ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ resource -> isLocked ( ) ) { return true ; } $ lock = $ resource -> getLock ( ) ; if ( $ lock instanceof ExpiringLockInterface and $ this -> isLockExpired ( $ lock ) ) { $ this -> release ( $ lock ) ; return true ; } return $ lock -> getAcquirer ( ) -> getIdentifier ( ) === $ acquirer -> getIdentifier ( ) ; }
6778	protected function updateVatDisplayMode ( SaleInterface $ sale ) { if ( $ sale -> hasPayments ( ) ) { return false ; } $ mode = null ; if ( null !== $ group = $ sale -> getCustomerGroup ( ) ) { $ mode = $ group -> getVatDisplayMode ( ) ; } if ( null === $ mode ) { $ mode = $ this -> defaultVatDisplayMode ; } if ( $ mode !== $ sale -> getVatDisplayMode ( ) ) { $ sale -> setVatDisplayMode ( $ mode ) ; return true ; } return false ; }
5644	public function getStatus ( ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { if ( ! $ this -> reporters [ $ i ] -> getStatus ( ) ) { return false ; } } return true ; }
3873	private function getBaseUrl ( $ pageDetails , $ path = null , $ ignoreSSL = false ) { $ url = new UrlBuilder ( ) ; if ( $ pageDetails [ 'domain' ] ) { $ url -> setHost ( $ pageDetails [ 'domain' ] ) ; } else { $ url -> setHost ( \ Environment :: get ( 'host' ) ) ; } if ( $ pageDetails [ 'rootUseSSL' ] && ! $ ignoreSSL ) { $ url -> setScheme ( 'https' ) ; } else { $ url -> setScheme ( 'http' ) ; } $ fullPath = array ( ) ; $ fullPath [ ] = TL_PATH ; if ( $ path === null ) { $ event = new GenerateFrontendUrlEvent ( $ pageDetails , null , $ pageDetails [ 'language' ] , true ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GENERATE_FRONTEND_URL , $ event ) ; $ fullPath [ ] = $ event -> getUrl ( ) ; } else { $ fullPath [ ] = $ path ; } $ url -> setPath ( implode ( '/' , $ fullPath ) ) ; return $ url ; }
2266	public function indexExists ( $ strName , $ strTable , $ blnNoCache = false ) { if ( $ strName == '' || $ strTable == '' ) { return false ; } foreach ( $ this -> listFields ( $ strTable , $ blnNoCache ) as $ arrField ) { if ( $ arrField [ 'name' ] == $ strName && $ arrField [ 'type' ] == 'index' ) { return true ; } } return false ; }
7909	protected function renderSearchInput ( ) { $ lines = [ ] ; $ lines [ ] = Html :: beginTag ( 'div' , [ 'class' => 'ui icon search input' ] ) ; $ lines [ ] = Html :: tag ( 'i' , '' , [ 'class' => 'search icon' ] ) ; $ lines [ ] = Html :: input ( 'text' , $ this -> getId ( ) . '-search' , '' , $ this -> searchInputOptions ) ; $ lines [ ] = Html :: endTag ( 'div' ) ; $ lines [ ] = Html :: tag ( 'div' , '' , [ 'class' => 'divider' ] ) ; return implode ( "\n" , $ lines ) ; }
11941	public function onExecuteAction ( ExecuteActionEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ position = 1 ; foreach ( $ request -> getConfig ( ) -> getArray ( 'argument' ) as $ argument ) { $ this -> validateArgument ( $ request , $ argument , $ position ++ ) ; } }
3544	protected function writeable ( $ file_path ) { if ( $ this -> option ( 'force' ) ) { return true ; } return ( ! file_exists ( $ file_path ) || $ this -> confirmable ( $ file_path ) ) ; }
9269	public function setPhase ( $ value ) { $ value = ( int ) $ value ; if ( $ value ) $ this -> phase = $ value ; else $ this -> phase = null ; return $ this ; }
7986	public function getModels ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/models' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
371	public function isColorEnabled ( $ stream = \ STDOUT ) { return $ this -> color === null ? Console :: streamSupportsAnsiColors ( $ stream ) : $ this -> color ; }
10003	protected function removeRecursive ( $ path , $ pattern , Logger $ logger ) { if ( ! is_file ( $ path ) && ! is_dir ( $ path ) ) { $ logger -> log ( "$path is not a valid source." , Logger :: WARNING ) ; return ; } if ( ! is_readable ( $ path ) ) { $ logger -> log ( "$path is not readable, skipping." , Logger :: WARNING ) ; return ; } if ( ! is_writeable ( $ parent = dirname ( $ path ) ) ) { $ logger -> log ( "$parent is not writable, skipping." , Logger :: WARNING ) ; return ; } $ matchesPattern = ( ( $ pattern === null ) || ( preg_match ( $ pattern , basename ( $ path ) ) ) ) ; if ( is_file ( $ path ) ) { if ( $ matchesPattern ) { unlink ( $ path ) ; } return ; } $ dh = opendir ( $ path ) ; while ( ( $ file = readdir ( $ dh ) ) !== false ) { if ( ( $ file === '.' ) || ( $ file === '..' ) ) { continue ; } $ this -> removeRecursive ( $ path . '/' . $ file , ( $ matchesPattern ? null : $ pattern ) , $ logger ) ; } if ( $ matchesPattern ) { rmdir ( $ path ) ; } }
7692	function MsExcel_ConvertToExplicit_Item ( & $ Txt , $ Tag , $ Att , $ CellRow ) { $ tag_pc = strlen ( $ Tag ) + 1 ; $ rpl = '<' . $ Tag . ' ' . $ Att . '="' ; $ rpl_len = strlen ( $ rpl ) ; $ rpl_nbr = 0 ; $ p = 0 ; $ empty_first_pos = false ; $ empty_nbr = 0 ; $ item_num = 0 ; $ rpl_nbr = 0 ; while ( ( $ p = clsTinyButStrong :: f_Xml_FindTagStart ( $ Txt , $ Tag , true , $ p , true , true ) ) !== false ) { $ item_num ++ ; if ( $ empty_first_pos === false ) $ empty_first_pos = $ p ; $ p = $ p + $ tag_pc ; if ( substr ( $ Txt , $ p , 1 ) == '/' ) { $ empty_nbr ++ ; } else { $ ref = ( $ CellRow === false ) ? $ item_num : $ this -> Misc_CellRef ( $ item_num , $ CellRow ) ; $ x = $ rpl . $ ref . '"' ; $ len = $ p - $ empty_first_pos ; $ Txt = substr_replace ( $ Txt , $ x , $ empty_first_pos , $ len ) ; $ rpl_nbr ++ ; if ( $ CellRow === false ) { $ loc = new clsTbsXmlLoc ( $ Txt , $ Tag , $ p ) ; $ loc -> FindEndTag ( ) ; $ src = $ loc -> GetSrc ( ) ; $ nbr = $ this -> MsExcel_ConvertToExplicit_Item ( $ src , 'c' , 'r' , $ item_num ) ; if ( $ nbr > 0 ) { $ loc -> ReplaceSrc ( $ src ) ; } $ p = $ loc -> PosEnd ; } else { $ p = $ empty_first_pos + $ tag_pc ; } $ empty_nbr = 0 ; $ empty_first_pos = false ; } } return $ rpl_nbr ; }
6719	private function handleAuthorizeResponse ( $ response ) { $ status = ArrayHelper :: getValue ( $ response , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ code = ArrayHelper :: getValue ( $ response , 'data.code' ) ; if ( is_null ( $ code ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ code ; } else { $ message = ArrayHelper :: getValue ( $ response , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
12808	private static function getPrimaryKey ( string $ table ) : array { if ( self :: $ primaryKeyCache !== null && array_key_exists ( $ table , self :: $ primaryKeyCache ) ) return self :: $ primaryKeyCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'PRIMARY KEY' AND tc.table_name = '$table' " ; $ results = $ pdo -> query ( $ query ) ; self :: $ primaryKeyCache [ $ table ] = $ results -> fetch ( ) ; return self :: $ primaryKeyCache [ $ table ] ; }
7088	public function error ( Callable $ action = null ) { if ( $ action ) $ this -> errorAction = $ action ; return $ this -> errorAction ; }
12444	public static function run ( $ source , $ destination , $ width , $ height = "" ) { $ mime = exif_imagetype ( $ source ) ; switch ( $ mime ) { case IMAGETYPE_JPEG : $ source = imagecreatefromjpeg ( $ source ) ; break ; case IMAGETYPE_PNG : $ source = imagecreatefrompng ( $ source ) ; break ; case IMAGETYPE_GIF : $ source = imagecreatefromgif ( $ source ) ; break ; default : return ; } $ width_src = imagesx ( $ source ) ; $ height_src = imagesy ( $ source ) ; $ width_dest = 0 ; $ height_dest = 0 ; if ( ! $ height ) { $ ratio = ( $ width * 100 ) / $ width_src ; if ( $ ratio > 100 ) { imagejpeg ( $ source , $ destination , 70 ) ; imagedestroy ( $ source ) ; return ; } $ width_dest = $ width ; $ height_dest = $ height_src * $ ratio / 100 ; } else { if ( $ height_src >= $ width_src ) { $ height_dest = ( $ height_src * $ width ) / $ width_src ; $ width_dest = $ width ; } elseif ( $ height_src < $ width_src ) { $ width_dest = ( $ width_src * $ height ) / $ height_src ; $ height_dest = $ height ; } } $ emptyPicture = imagecreatetruecolor ( $ width , ( $ height ) ? $ height : $ height_dest ) ; imagecopyresampled ( $ emptyPicture , $ source , 0 , 0 , 0 , 0 , $ width_dest , $ height_dest , $ width_src , $ height_src ) ; imagejpeg ( $ emptyPicture , $ destination , 70 ) ; imagedestroy ( $ source ) ; imagedestroy ( $ emptyPicture ) ; return ; }
1885	public function getItemsAsString ( $ strSeparator = ' ' ) { $ arrLinks = array ( ) ; foreach ( $ this -> getItemsAsArray ( ) as $ arrItem ) { if ( $ arrItem [ 'href' ] === null ) { $ arrLinks [ ] = sprintf ( '<li><strong class="active">%s</strong></li>' , $ arrItem [ 'page' ] ) ; } else { $ arrLinks [ ] = sprintf ( '<li><a href="%s" class="link" title="%s">%s</a></li>' , $ arrItem [ 'href' ] , $ arrItem [ 'title' ] , $ arrItem [ 'page' ] ) ; } } return implode ( $ strSeparator , $ arrLinks ) ; }
941	public function getPath ( ) { if ( null === $ this -> path ) { $ filesystem = new Filesystem ( ) ; $ cwd = $ this -> cwd ; if ( 1 === \ count ( $ this -> options [ 'path' ] ) && '-' === $ this -> options [ 'path' ] [ 0 ] ) { $ this -> path = $ this -> options [ 'path' ] ; } else { $ this -> path = array_map ( static function ( $ path ) use ( $ cwd , $ filesystem ) { $ absolutePath = $ filesystem -> isAbsolutePath ( $ path ) ? $ path : $ cwd . \ DIRECTORY_SEPARATOR . $ path ; if ( ! file_exists ( $ absolutePath ) ) { throw new InvalidConfigurationException ( sprintf ( 'The path "%s" is not readable.' , $ path ) ) ; } return $ absolutePath ; } , $ this -> options [ 'path' ] ) ; } } return $ this -> path ; }
12686	public function inferType ( $ value ) { if ( is_string ( $ value ) ) { return new StringType ( ) ; } elseif ( is_array ( $ value ) ) { return new ArrayType ( ) ; } elseif ( is_object ( $ value ) ) { return $ this -> inferObjectType ( $ value ) ; } elseif ( is_integer ( $ value ) ) { return new IntegerType ( ) ; } elseif ( is_bool ( $ value ) ) { return new BooleanType ( ) ; } elseif ( is_null ( $ value ) ) { return new MixedType ( ) ; } $ e = new InferException ( 'Typ konnte nicht geraten werden: ' . Util :: varInfo ( $ value ) ) ; $ e -> value = $ value ; throw $ e ; }
9347	public function isDiagonal ( ) { $ int_size = min ( ( array ) $ this -> size ) ; if ( $ int_size > 0 ) { for ( $ i = 0 ; $ i < $ int_size ; $ i ++ ) { $ arr_row = $ this -> getRow ( $ i ) ; if ( $ arr_row [ $ i ] != 0 ) { unset ( $ arr_row [ $ i ] ) ; foreach ( $ arr_row as $ v ) { if ( $ v != 0 ) { return false ; } } } else { return false ; } } return true ; } return false ; }
8632	public function setReportRequestInfoList ( $ reportRequestInfo ) { if ( ! $ this -> _isNumericArray ( $ reportRequestInfo ) ) { $ reportRequestInfo = array ( $ reportRequestInfo ) ; } $ this -> fields [ 'ReportRequestInfo' ] [ 'FieldValue' ] = $ reportRequestInfo ; return $ this ; }
4088	protected function transformDSLSortToString ( $ dslSort ) { $ string = "" ; if ( is_array ( $ dslSort ) ) { foreach ( $ dslSort as $ sort ) { if ( is_array ( $ sort ) ) { $ field = key ( $ sort ) ; $ info = current ( $ sort ) ; } else $ field = $ sort ; $ string .= "&sort=" . $ field ; if ( isset ( $ info ) ) { if ( is_string ( $ info ) && $ info == "desc" ) $ string .= ":reverse" ; elseif ( is_array ( $ info ) && array_key_exists ( "reverse" , $ info ) && $ info [ 'reverse' ] ) $ string .= ":reverse" ; } } } return $ string ; }
7499	protected function renderStringTemplate ( $ template , $ parameters = array ( ) ) { $ template = $ this -> environment -> createTemplate ( $ template ) ; return $ template -> render ( $ parameters ) ; }
3068	protected function initServiceContext ( ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> getRunnerService ( ) -> check ( $ serviceContext ) ; return $ serviceContext -> init ( ) ; }
444	public function trigger ( $ name , Event $ event = null ) { $ this -> ensureBehaviors ( ) ; $ eventHandlers = [ ] ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ handlers ) ; } } if ( ! empty ( $ this -> _events [ $ name ] ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ this -> _events [ $ name ] ) ; } if ( ! empty ( $ eventHandlers ) ) { if ( $ event === null ) { $ event = new Event ( ) ; } if ( $ event -> sender === null ) { $ event -> sender = $ this ; } $ event -> handled = false ; $ event -> name = $ name ; foreach ( $ eventHandlers as $ handler ) { $ event -> data = $ handler [ 1 ] ; call_user_func ( $ handler [ 0 ] , $ event ) ; if ( $ event -> handled ) { return ; } } } Event :: trigger ( $ this , $ name , $ event ) ; }
4	private function buildDepExtensionConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { $ depChannelName = 'ext' ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
1287	private function fetchCollectionFromApi ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , $ resourceIds ) ; if ( 'Asset' === $ type || 'Entry' === $ type ) { $ query -> setLocale ( $ locale ) ; } switch ( $ type ) { case 'Asset' : return $ this -> client -> getAssets ( $ query ) -> getItems ( ) ; case 'ContentType' : return $ this -> client -> getContentTypes ( $ query ) -> getItems ( ) ; case 'Entry' : return $ this -> client -> getEntries ( $ query ) -> getItems ( ) ; case 'Environment' : return [ $ this -> client -> getEnvironment ( ) ] ; case 'Space' : return [ $ this -> client -> getSpace ( ) ] ; default : throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to resolve link for unknown type "%s".' , $ type ) ) ; } }
6969	protected function calculateDiscountLine ( Model \ DocumentLineInterface $ line , Amount $ gross , Amount $ final ) { if ( $ line -> getType ( ) !== Model \ DocumentLineTypes :: TYPE_DISCOUNT ) { throw new LogicException ( sprintf ( "Expected document line with type '%s'." , Model \ DocumentLineTypes :: TYPE_DISCOUNT ) ) ; } if ( null === $ adjustment = $ line -> getSaleAdjustment ( ) ) { throw new LogicException ( "Document can't be recalculated." ) ; } $ result = $ this -> calculator -> calculateSaleDiscount ( $ adjustment , $ gross , $ final ) ; $ this -> syncLineWithResult ( $ line , $ result ) ; }
6607	public static function getAll ( $ offset = null , $ limit = null ) { $ query = self :: find ( ) ; self :: addPaginationParameters ( $ query , $ offset , $ limit ) ; return $ query -> all ( ) ; }
8983	public function isSame ( TableNode $ expected , TableNode $ actual , $ message = NULL ) { $ this -> doAssert ( 'Failed asserting that two tables were identical: ' , [ ] , $ expected , $ actual , $ message ) ; }
2931	public function setKeys ( $ data ) { foreach ( $ data as $ setter ) { if ( array_key_exists ( 'key' , $ setter ) ) { $ key = $ this -> formatter -> formatKey ( $ setter [ 'key' ] ) ; $ value = array_key_exists ( 'value' , $ setter ) ? $ setter [ 'value' ] : null ; $ comment = array_key_exists ( 'comment' , $ setter ) ? $ setter [ 'comment' ] : null ; $ export = array_key_exists ( 'export' , $ setter ) ? $ setter [ 'export' ] : false ; if ( ! is_file ( $ this -> filePath ) || ! $ this -> keyExists ( $ key ) ) { $ this -> writer -> appendSetter ( $ key , $ value , $ comment , $ export ) ; } else { $ oldInfo = $ this -> getKeys ( [ $ key ] ) ; $ comment = is_null ( $ comment ) ? $ oldInfo [ $ key ] [ 'comment' ] : $ comment ; $ this -> writer -> updateSetter ( $ key , $ value , $ comment , $ export ) ; } } } return $ this ; }
2146	protected function generateEmailObject ( Result $ objNewsletter , $ arrAttachments ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ objNewsletter -> sender ; $ objEmail -> subject = $ objNewsletter -> subject ; if ( $ objNewsletter -> senderName != '' ) { $ objEmail -> fromName = $ objNewsletter -> senderName ; } $ objEmail -> embedImages = ! $ objNewsletter -> externalImages ; $ objEmail -> logFile = TL_NEWSLETTER . '_' . $ objNewsletter -> id ; if ( ! empty ( $ arrAttachments ) && \ is_array ( $ arrAttachments ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ arrAttachments as $ strAttachment ) { $ objEmail -> attachFile ( $ rootDir . '/' . $ strAttachment ) ; } } return $ objEmail ; }
2504	protected static function getMessagesAndVersionsFromImportedWsdl ( $ import , $ wsdlPath , $ wsdlIdentifier ) { $ msgAndVer = [ ] ; $ domXpath = null ; $ importPath = realpath ( dirname ( $ wsdlPath ) ) . DIRECTORY_SEPARATOR . $ import ; $ wsdlContent = file_get_contents ( $ importPath ) ; if ( $ wsdlContent !== false ) { $ domDoc = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ ok = $ domDoc -> loadXML ( $ wsdlContent ) ; if ( $ ok === true ) { $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; $ domXpath -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ importPath . ' import could not be loaded' ) ; } if ( $ domXpath instanceof \ DOMXPath ) { $ nodeList = $ domXpath -> query ( self :: XPATH_ALL_OPERATIONS ) ; $ msgAndVer = array_merge ( $ msgAndVer , self :: loopOperationsWithQuery ( $ nodeList , self :: XPATH_ALT_VERSION_FOR_OPERATION , $ wsdlIdentifier , $ domXpath ) ) ; } return $ msgAndVer ; }
11996	static public function doctrine ( $ tableName , $ field , $ length = 16 ) { do { $ generate = self :: generate ( $ length ) ; } while ( self :: doctrineQuery ( $ tableName , $ field , $ generate ) ) ; return $ generate ; }
1572	public function getProcess ( ) : ? AsynchronousProcess { $ process = $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; return ( $ process instanceof AsynchronousProcess ) ? $ process : null ; }
10888	public function addOption ( $ short , $ long , $ arg , $ description ) { $ this -> parameters [ ] = array ( $ short , $ long , $ arg , $ description ) ; return $ this ; }
3141	public function move ( RunnerServiceContext $ context , $ direction , $ scope , $ ref ) { $ result = true ; if ( $ context instanceof QtiRunnerServiceContext ) { try { $ result = QtiRunnerNavigation :: move ( $ direction , $ scope , $ context , $ ref ) ; if ( $ result ) { $ this -> continueInteraction ( $ context ) ; } } catch ( AssessmentTestSessionException $ e ) { switch ( $ e -> getCode ( ) ) { case AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW : case AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW : case AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW : case AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW : $ this -> onTimeout ( $ context , $ e ) ; break ; } } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'move' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; }
6672	public function restart_all_ratings ( ) { $ nonce = isset ( $ _POST [ 'nonce' ] ) ? $ _POST [ 'nonce' ] : '' ; if ( ! wp_verify_nonce ( $ nonce , 'eliasis' ) && ! wp_verify_nonce ( $ nonce , 'customRatingGrifusAdmin' ) ) { die ( 'Busted!' ) ; } $ response [ 'ratings_restarted' ] = 0 ; $ posts = $ this -> model -> get_posts ( ) ; foreach ( $ posts as $ post ) { if ( isset ( $ post -> ID ) && ! $ this -> model -> get_movie_votes ( $ post -> ID ) ) { $ this -> set_rating_and_votes ( $ post -> ID , $ this -> get_default_votes ( $ post -> ID ) ) ; $ response [ 'ratings_restarted' ] ++ ; } } echo json_encode ( $ response ) ; die ( ) ; }
10566	protected function formatJsonp ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/javascript; charset=UTF-8' ) ; if ( is_array ( $ response -> data ) && isset ( $ response -> data [ 'data' ] , $ response -> data [ 'callback' ] ) ) { $ response -> content = sprintf ( '%s(%s);' , $ response -> data [ 'callback' ] , Json :: htmlEncode ( $ response -> data [ 'data' ] ) ) ; } elseif ( $ response -> data !== null ) { $ response -> content = '' ; Yii :: warning ( "The 'jsonp' response requires that the data be an array consisting of both 'data' and 'callback' elements." , __METHOD__ ) ; } }
211	protected function hashPluginOptions ( $ view ) { $ encOptions = empty ( $ this -> clientOptions ) ? '{}' : Json :: htmlEncode ( $ this -> clientOptions ) ; $ this -> _hashVar = self :: PLUGIN_NAME . '_' . hash ( 'crc32' , $ encOptions ) ; $ this -> options [ 'data-plugin-' . self :: PLUGIN_NAME ] = $ this -> _hashVar ; $ view -> registerJs ( "var {$this->_hashVar} = {$encOptions};" , View :: POS_HEAD ) ; }
5669	public function clipString ( $ string , $ size , $ position = 0 ) { $ utf8 = false ; if ( function_exists ( 'mb_detect_encoding' ) && mb_detect_encoding ( $ string ) == 'UTF-8' ) { $ utf8 = true ; } $ length = ( $ utf8 == true ) ? mb_strlen ( $ string , "UTF-8" ) : strlen ( $ string ) ; if ( $ length <= $ size ) { return $ string ; } $ position = min ( $ position , $ length ) ; $ start = ( $ size / 2 > $ position ? 0 : $ position - $ size / 2 ) ; if ( $ start + $ size > $ length ) { $ start = $ length - $ size ; } $ string = ( $ utf8 == true ) ? mb_substr ( $ string , $ start , $ size ) : substr ( $ string , $ start , $ size ) ; return ( $ start > 0 ? '...' : '' ) . $ string . ( $ start + $ size < $ length ? '...' : '' ) ; }
3452	public function getAggregateRoot ( string $ aggregateId ) { if ( ! $ this -> disableIdentityMap && isset ( $ this -> identityMap [ $ aggregateId ] ) ) { return $ this -> identityMap [ $ aggregateId ] ; } if ( $ this -> snapshotStore ) { $ eventSourcedAggregateRoot = $ this -> loadFromSnapshotStore ( $ aggregateId ) ; if ( $ eventSourcedAggregateRoot && ! $ this -> disableIdentityMap ) { $ this -> identityMap [ $ aggregateId ] = $ eventSourcedAggregateRoot ; } return $ eventSourcedAggregateRoot ; } $ streamName = $ this -> determineStreamName ( $ aggregateId ) ; if ( $ this -> oneStreamPerAggregate ) { try { $ streamEvents = $ this -> eventStore -> load ( $ streamName , 1 ) ; } catch ( StreamNotFound $ e ) { return null ; } } else { $ metadataMatcher = new MetadataMatcher ( ) ; $ metadataMatcher = $ metadataMatcher -> withMetadataMatch ( '_aggregate_type' , Operator :: EQUALS ( ) , $ this -> aggregateType -> toString ( ) ) ; $ metadataMatcher = $ metadataMatcher -> withMetadataMatch ( '_aggregate_id' , Operator :: EQUALS ( ) , $ aggregateId ) ; try { $ streamEvents = $ this -> eventStore -> load ( $ streamName , 1 , null , $ metadataMatcher ) ; } catch ( StreamNotFound $ e ) { return null ; } } if ( ! $ streamEvents -> valid ( ) ) { return null ; } $ eventSourcedAggregateRoot = $ this -> aggregateTranslator -> reconstituteAggregateFromHistory ( $ this -> aggregateType , $ streamEvents ) ; if ( ! $ this -> disableIdentityMap ) { $ this -> identityMap [ $ aggregateId ] = $ eventSourcedAggregateRoot ; } return $ eventSourcedAggregateRoot ; }
746	protected function buildDefaultString ( ) { if ( $ this -> default === null ) { return $ this -> isNotNull === false ? ' DEFAULT NULL' : '' ; } $ string = ' DEFAULT ' ; switch ( gettype ( $ this -> default ) ) { case 'integer' : $ string .= ( string ) $ this -> default ; break ; case 'double' : $ string .= StringHelper :: floatToString ( $ this -> default ) ; break ; case 'boolean' : $ string .= $ this -> default ? 'TRUE' : 'FALSE' ; break ; case 'object' : $ string .= ( string ) $ this -> default ; break ; default : $ string .= "'{$this->default}'" ; } return $ string ; }
2667	public function getSingleDictionary ( $ version , $ dictionaryName ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/dictionary/' . $ dictionaryName ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
8618	public function removeBlock ( $ spec ) { if ( $ spec instanceof Block ) $ spec = $ spec -> getKey ( ) ; if ( is_string ( $ spec ) ) { if ( $ this -> blocks [ $ spec ] ) { unset ( $ this -> blocks [ $ spec ] ) ; } } }
6255	public function searchPickupPoints ( $ postcode = null , $ street_address = null , $ country = null , $ service_provider = null , $ limit = 5 ) { if ( ( $ postcode == null && $ street_address == null ) || ( trim ( $ postcode ) == '' && trim ( $ street_address ) == '' ) ) { return '[]' ; } $ post_params = array ( 'postcode' => ( string ) $ postcode , 'address' => ( string ) $ street_address , 'country' => ( string ) $ country , 'service_provider' => ( string ) $ service_provider , 'limit' => ( int ) $ limit ) ; return $ this -> doPost ( '/pickup-points/search' , $ post_params ) ; }
10	private function getCurrentPackages ( $ installedRepo ) { if ( $ this -> locker -> isLocked ( ) ) { try { return $ this -> locker -> getLockedRepository ( true ) -> getPackages ( ) ; } catch ( \ RuntimeException $ e ) { return $ this -> locker -> getLockedRepository ( ) -> getPackages ( ) ; } } return $ installedRepo -> getPackages ( ) ; }
2823	public function deleteExpiredRequests ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( ! $ helper -> isEnabled ( ) ) { return 'skipped: module is disabled.' ; } if ( $ helper -> getPersistLifetime ( ) == 0 ) { return 'skipped: lifetime is set to 0' ; } $ expirationDate = $ this -> getExpirationDate ( date ( self :: DATE_FORMAT ) ) ; $ table = $ this -> getRequestsTable ( ) ; $ deleteSql = "DELETE FROM {$table} WHERE date <= '{$expirationDate}'" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return "{$result->rowCount()} requests deleted" ; }
7757	public function processData ( $ data = array ( ) ) { if ( is_array ( $ data ) && 0 === count ( $ data ) ) { $ data = new \ stdClass ( ) ; } if ( ! is_string ( $ data ) ) { $ options = 0 ; if ( PHP_VERSION_ID >= 50400 ) { $ options |= JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ; if ( self :: $ pretty ) { $ options |= JSON_PRETTY_PRINT ; } $ data = json_encode ( $ data , $ options ) ; } else { $ data = json_encode ( $ data ) ; $ data = str_replace ( '\\/' , '/' , $ data ) ; $ data = preg_replace_callback ( '/\\\\u([a-f0-9]{4})/' , function ( $ match ) { return iconv ( 'UCS-4LE' , 'UTF-8' , pack ( 'V' , hexdec ( $ match [ 1 ] ) ) ) ; } , $ data ) ; } } return $ this -> setContent ( $ data ) ; }
10988	public function getConfigTreeBuilder ( ) { $ tree_builder = new TreeBuilder ( ) ; $ tree_builder -> root ( 'anime_db_cache_time_keeper' ) -> children ( ) -> booleanNode ( 'enable' ) -> defaultTrue ( ) -> end ( ) -> scalarNode ( 'use_driver' ) -> cannotBeEmpty ( ) -> defaultValue ( 'file' ) -> end ( ) -> arrayNode ( 'private_headers' ) -> treatNullLike ( [ ] ) -> prototype ( 'scalar' ) -> end ( ) -> defaultValue ( [ 'Authorization' , 'Cookie' ] ) -> end ( ) -> append ( $ this -> getEtagHasher ( ) ) -> append ( $ this -> getTrack ( ) ) -> arrayNode ( 'drivers' ) -> append ( $ this -> getDriverFile ( ) ) -> append ( $ this -> getDriverMemcache ( ) ) -> append ( $ this -> getDriverMulti ( ) ) -> append ( $ this -> getDriverShmop ( ) ) -> end ( ) -> end ( ) ; return $ tree_builder ; }
1725	private static function canGenerateSecret ( array $ config ) : bool { if ( isset ( $ config [ 'file' ] ) ) { return ! is_file ( $ config [ 'file' ] ) ; } foreach ( $ config as $ v ) { if ( \ is_array ( $ v ) && isset ( $ v [ 'file' ] ) && is_file ( $ v [ 'file' ] ) ) { return false ; } } return ! empty ( $ config ) ; }
3697	public function checkPurge ( AbstractModelAwareEvent $ event ) { $ table = $ event -> getModel ( ) -> getProviderName ( ) ; if ( ( $ table == 'tl_metamodel' ) || ( $ table == 'tl_metamodel_dca' ) || ( $ table == 'tl_metamodel_dca_sortgroup' ) || ( $ table == 'tl_metamodel_dcasetting' ) || ( $ table == 'tl_metamodel_dcasetting_condition' ) || ( $ table == 'tl_metamodel_attribute' ) || ( $ table == 'tl_metamodel_filter' ) || ( $ table == 'tl_metamodel_filtersetting' ) || ( $ table == 'tl_metamodel_rendersettings' ) || ( $ table == 'tl_metamodel_rendersetting' ) || ( $ table == 'tl_metamodel_dca_combine' ) ) { $ this -> purger -> purge ( ) ; } }
11512	public function actionRequest ( ) { if ( ! $ this -> module -> enablePasswordRecovery ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( [ 'class' => RecoveryForm :: className ( ) , 'scenario' => 'request' , ] ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> sendRecoveryMessage ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Recovery message sent' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'request' , [ 'model' => $ model , ] ) ; }
4859	public function getNeighbours ( $ namespace , $ callback , $ id ) { $ list = $ this -> getList ( $ namespace , $ callback ) ; $ list -> setCurrent ( $ id ) ; return [ $ list -> getPrevious ( ) , $ list -> getNext ( ) ] ; }
8577	public function setItemFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7165	private function buildDiscountLine ( Model \ SaleAdjustmentInterface $ adjustment , $ level = 0 ) { if ( Model \ AdjustmentTypes :: TYPE_DISCOUNT !== $ adjustment -> getType ( ) ) { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ lineNumber = $ this -> lineNumber ++ ; $ view = new LineView ( 'adjustment_' . ( $ lineNumber - 1 ) , 'adjustment_' . $ adjustment -> getId ( ) , $ lineNumber , $ level ) ; if ( empty ( $ designation = $ adjustment -> getDesignation ( ) ) ) { $ designation = 'Discount ' ; if ( $ adjustment -> getMode ( ) === Model \ AdjustmentModes :: MODE_PERCENT ) { $ designation .= $ this -> formatter -> percent ( $ adjustment -> getAmount ( ) ) ; } } $ result = $ adjustment -> getResult ( ) ; $ view -> setDesignation ( $ designation ) -> setBase ( $ this -> formatter -> currency ( $ result -> getBase ( ) ) ) -> setTaxAmount ( $ this -> formatter -> currency ( $ result -> getTax ( ) ) ) -> setTotal ( $ this -> formatter -> currency ( $ result -> getTotal ( ) ) ) ; foreach ( $ this -> types as $ type ) { $ type -> buildAdjustmentView ( $ adjustment , $ view , $ this -> options ) ; } return $ view ; }
5301	public function getCss ( ) { $ css = '' ; foreach ( $ this -> getGlyphNames ( ) as $ unicode => $ name ) { $ css .= ".icon-" . $ name . ":before {" . "\n" ; $ css .= "\tcontent: \"\\" . $ unicode . "\";\n" ; $ css .= "}\n" ; } return $ css ; }
10654	public function __isset ( $ propertyName ) { $ methodName = 'get' . $ propertyName ; if ( method_exists ( $ this , $ methodName ) ) { return ( $ this -> $ methodName ( ) !== null ) ; } else { return false ; } }
11424	public function lists ( $ nextOpenId = null ) { $ params = [ 'next_openid' => $ nextOpenId ] ; return $ this -> parseJSON ( 'get' , [ self :: API_LIST , $ params ] ) ; }
12389	protected function updateCredentialHash ( PasswordableInterface $ identityObject , $ password ) { $ cryptoService = $ this -> getMapper ( ) -> getPasswordService ( ) ; if ( ! $ cryptoService instanceof Bcrypt ) { return $ this ; } $ hash = explode ( '$' , $ identityObject -> getPassword ( ) ) ; if ( $ hash [ 2 ] === $ cryptoService -> getCost ( ) ) { return $ this ; } $ identityObject -> setPassword ( $ cryptoService -> create ( $ password ) ) ; return $ this ; }
11095	public static function generatePin ( $ salt , $ length = 6 , $ useMinutes = false ) { $ seed = sha1 ( $ salt . ( new \ DateTime ( 'now' , new \ DateTimeZone ( 'Europe/Prague' ) ) ) -> format ( 'Ymd' . ( $ useMinutes ? 'i' : '' ) ) , true ) ; for ( $ i = 0 ; $ i <= ( new \ DateTime ( 'now' , new \ DateTimeZone ( 'Europe/Prague' ) ) ) -> format ( 'G' ) ; $ i ++ ) { $ seed = sha1 ( $ seed . $ i ) ; } $ data = unpack ( 'V1/V2' , $ seed ) ; $ data [ 1 ] = $ data [ 1 ] < 0 ? $ data [ 1 ] * - 1 : $ data [ 1 ] ; $ data [ 2 ] = $ data [ 2 ] < 0 ? $ data [ 2 ] * - 1 : $ data [ 2 ] ; $ mask = $ data [ 1 ] ^ $ data [ 2 ] ; if ( $ mask % 1000000 === 0 || $ mask % 1000000 === 999999 ) { return self :: generatePin ( $ salt . $ seed , $ length , $ useMinutes ) ; } return round ( ( ( ( float ) ( $ mask % 1000000 ) - 0.5 + ( ( float ) ( $ mask % 200 ) / 199 ) ) / 999999 ) * ( ( ( 10 ** $ length ) - 1 ) - ( 10 ** ( $ length - 1 ) ) ) + ( 10 ** ( $ length - 1 ) ) ) ; }
5103	public static function appendSet ( $ values , $ forceExist = false ) { if ( $ forceExist && ! $ values ) throw new SquidException ( 'SET clause must be present for this type of command!' ) ; return Assembly :: append ( 'SET' , $ values , ', ' ) ; }
9290	public function applySerializeMetadataToArray ( array $ array , $ className ) { $ classMetadata = $ this -> documentManager -> getClassMetadata ( $ className ) ; $ fieldList = $ this -> fieldListForSerialize ( $ classMetadata ) ; $ return = array_merge ( $ array , $ this -> serializeClassNameAndDiscriminator ( $ classMetadata ) ) ; foreach ( $ classMetadata -> fieldMappings as $ field => $ mapping ) { if ( ! in_array ( $ field , $ fieldList ) ) { if ( isset ( $ return [ $ field ] ) ) { unset ( $ return [ $ field ] ) ; } continue ; } if ( isset ( $ mapping [ 'id' ] ) && $ mapping [ 'id' ] && isset ( $ array [ '_id' ] ) ) { $ return [ $ field ] = $ array [ '_id' ] ; unset ( $ return [ '_id' ] ) ; } if ( ! isset ( $ return [ $ field ] ) ) { continue ; } $ return [ $ field ] = $ this -> applySerializeMetadataToField ( $ return [ $ field ] , $ field , $ className ) ; } return $ return ; }
7471	public function createAction ( Request $ request ) { $ user = new User ( ) ; $ form = $ this -> createForm ( UserType :: class , $ user ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ user -> setPassword ( $ encoder -> encodePassword ( $ user -> getPassword ( ) , $ user -> getSalt ( ) ) ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The user has been created.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ user -> getId ( ) ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) ) ; }
270	public function getEnabled ( ) { if ( is_callable ( $ this -> _enabled ) ) { return call_user_func ( $ this -> _enabled , $ this ) ; } return $ this -> _enabled ; }
5715	public function doSaveAndAdd ( $ data , $ form ) { return $ this -> saveAndRedirect ( $ data , $ form , $ this -> owner -> Link ( "addnew" ) ) ; }
795	public function load ( $ data , $ formName = null ) { $ scope = $ formName === null ? $ this -> formName ( ) : $ formName ; if ( $ scope === '' && ! empty ( $ data ) ) { $ this -> setAttributes ( $ data ) ; return true ; } elseif ( isset ( $ data [ $ scope ] ) ) { $ this -> setAttributes ( $ data [ $ scope ] ) ; return true ; } return false ; }
9892	protected function createError ( ) { $ error = $ this -> getForm ( ) -> getValidator ( ) -> getMessages ( $ this -> getElement ( ) -> getName ( ) ) ; if ( $ error ) { $ this -> error = $ this -> builder -> make ( 'error' , [ ] , $ error ) ; } }
6382	public function readQuestions ( $ quizId ) { $ quizSlots = $ this -> readStoreRecords ( 'quiz_slots' , [ 'quizid' => $ quizId ] ) ; $ questions = [ ] ; foreach ( $ quizSlots as $ index => $ quizSlot ) { try { $ question = $ this -> readStoreRecord ( 'question' , [ 'id' => $ quizSlot -> questionid ] ) ; $ question -> answers = $ this -> readStoreRecords ( 'question_answers' , [ 'question' => $ question -> id ] ) ; $ question -> url = $ this -> cfg -> wwwroot . '/mod/question/question.php?id=' . $ question -> id ; if ( $ question -> qtype == 'numerical' ) { $ question -> numerical = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_numerical' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_numerical_options' , [ 'question' => $ question -> id ] ) , 'units' => $ this -> readStoreRecords ( 'question_numerical_units' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'match' ) { $ question -> match = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_match_options' , [ 'questionid' => $ question -> id ] ) , 'subquestions' => $ this -> readStoreRecords ( 'qtype_match_subquestions' , [ 'questionid' => $ question -> id ] ) ] ; } else if ( strpos ( $ question -> qtype , 'calculated' ) === 0 ) { $ question -> calculated = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_calculated' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_calculated_options' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'shortanswer' ) { $ question -> shortanswer = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_shortanswer_options' , [ 'questionid' => $ question -> id ] ) ] ; } $ questions [ $ question -> id ] = $ question ; } catch ( \ Exception $ e ) { } } return $ questions ; }
6210	public function notifyOnException ( Exception $ e , $ extraParams = null ) { $ notice = new Notice ; $ notice -> load ( array ( 'errorClass' => get_class ( $ e ) , 'backtrace' => $ this -> cleanBacktrace ( $ e -> getTrace ( ) ? : debug_backtrace ( ) ) , 'errorMessage' => $ e -> getMessage ( ) . ' in ' . $ this -> cleanFilePath ( $ e -> getFile ( ) ) . ' on line ' . $ e -> getLine ( ) , 'extraParameters' => $ extraParams , ) ) ; return $ this -> notify ( $ notice ) ; }
10233	public function edit ( $ id ) { $ user = User :: findOrFail ( $ id ) ; $ roles = Role :: lists ( 'name' , 'id' ) ; return view ( 'intothesource.usersmanager.users.edit' , compact ( 'user' , 'roles' ) ) ; }
3077	public function processOutput ( QtiRunnerServiceContext $ context ) { $ messages = [ ] ; $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; if ( is_array ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] ) ) { foreach ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] as $ outputChannelName => $ outputChannelClass ) { $ channel = $ this -> getChannel ( $ outputChannelName , self :: CHANNEL_TYPE_OUTPUT ) ; $ message = $ this -> processChannel ( $ channel , $ context ) ; if ( $ message !== null ) { $ messages [ ] = [ 'channel' => $ channel -> getName ( ) , 'message' => $ message , ] ; } } } return $ messages ; }
9984	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> name ) ) $ this -> name = $ xmlElement -> name ; if ( isset ( $ xmlElement -> entries ) ) { $ this -> entries = array ( ) ; foreach ( $ xmlElement -> entries -> children ( ) as $ entry ) { $ this -> entries [ ] = $ entry ; } } }
12	public function setOptimizeAutoloader ( $ optimizeAutoloader = false ) { $ this -> optimizeAutoloader = ( bool ) $ optimizeAutoloader ; if ( ! $ this -> optimizeAutoloader ) { $ this -> setClassMapAuthoritative ( false ) ; } return $ this ; }
5525	protected function createCodeForClass ( $ methods ) { $ implements = '' ; $ interfaces = $ this -> reflection -> getInterfaces ( ) ; $ interfaces = array_diff ( $ interfaces , [ 'Traversable' , 'Throwable' ] ) ; if ( count ( $ interfaces ) > 0 ) { $ implements = 'implements ' . implode ( ', ' , $ interfaces ) ; } $ code = 'class ' . $ this -> mock_class . ' extends ' . $ this -> mock_base . ' ' . $ implements . " {\n" ; $ code .= " function __construct() {\n" ; $ code .= " parent::__construct();\n" ; $ code .= " }\n" ; $ code .= $ this -> createCodeForConstructor ( ) ; $ code .= $ this -> createCodeForMethods ( $ methods ) ; $ code .= "}\n" ; return $ code ; }
3311	protected function getTokenFormApi ( ) { $ http = $ this -> getHttp ( ) ; $ token = $ http -> parseJson ( $ http -> post ( self :: API_TOKEN_URI , [ 'grant_type' => 'client_credentials' , 'client_id' => $ this -> getAppKey ( ) , 'client_secret' => $ this -> getSecretKey ( ) ] ) ) ; if ( empty ( $ token [ $ this -> tokenSucessKey ] ) ) { throw new RuntimeException ( 'Request AccessToken fail. response: ' . json_encode ( $ token , JSON_UNESCAPED_UNICODE ) ) ; } return $ token ; }
4654	protected function getJobs ( $ projectPath ) { $ jobs = array ( ) ; $ project = $ this -> naming -> getProjectName ( $ projectPath ) ; $ repositoryRegex = sprintf ( '#^%s_([a-z]+?)/%s:\d+-\d+$#' , Job :: BASE_NAME , $ project ) ; foreach ( $ this -> docker -> getImageManager ( ) -> findAll ( ) as $ image ) { foreach ( $ image -> getRepoTags ( ) as $ name ) { if ( preg_match ( $ repositoryRegex , $ name , $ matches ) ) { $ jobs [ ] = $ this -> getJobFromImage ( $ image , $ name , $ matches [ 1 ] , $ project ) ; } } } return $ jobs ; }
9433	protected static function checkOrder ( $ float_min , $ float_max ) { if ( ! is_numeric ( $ float_min ) && ! is_numeric ( $ float_max ) ) { throw new \ InvalidArgumentException ( 'Min and max values must be valid numbers.' ) ; } if ( $ float_min >= $ float_max ) { throw new \ InvalidArgumentException ( 'Max value must be greater than min value!' ) ; } }
4315	protected function getGroupDepth ( ) { $ depth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] as $ stack ) { $ depth += \ count ( $ stack ) ; } $ depth += \ count ( $ this -> data [ 'groupPriorityStack' ] ) ; return $ depth ; }
957	public function remainingTrialDays ( ) { if ( ! $ this -> isTrial ( ) ) { return ; } return $ this -> isActiveTrial ( ) ? Carbon :: today ( ) -> diffInDays ( $ this -> trial_ends_on ) : 0 ; }
11956	function addQueue ( $ channel , $ queue , $ weight = 1 ) { $ orig = $ channel ; $ channel = $ this -> _normalizeQueueName ( $ channel ) ; if ( ! $ queue instanceof iQueueDriver ) throw new \ Exception ( sprintf ( 'Queue must be instance of iQueueDriver; given: (%s).' , \ Poirot \ Std \ flatten ( $ queue ) ) ) ; if ( isset ( $ this -> channels_queue [ $ channel ] ) ) throw new \ RuntimeException ( sprintf ( 'Channel (%s) is currently filled with (%s) and is not empty.' , $ orig , get_class ( $ this -> channels_queue [ $ channel ] ) ) ) ; $ this -> channels_queue [ $ channel ] = $ queue ; $ this -> channels_weight [ $ channel ] = $ weight ; return $ this ; }
5562	protected function parse ( $ response , $ depth = 0 ) { $ page = $ this -> buildPage ( $ response ) ; if ( $ this -> ignore_frames || ! $ page -> hasFrames ( ) || ( $ depth > $ this -> maximum_nested_frames ) ) { return $ page ; } $ frameset = new SimpleFrameset ( $ page ) ; foreach ( $ page -> getFrameset ( ) as $ key => $ url ) { $ frame = $ this -> fetch ( $ url , new SimpleGetEncoding ( ) , $ depth + 1 ) ; $ frameset -> addFrame ( $ frame , $ key ) ; } return $ frameset ; }
6899	public function regenerate ( $ delete_old = false ) { if ( $ this -> is_active ( ) ) { @ session_regenerate_id ( $ delete_old ) ; } else { $ this -> open ( ) ; } return session_id ( ) ; }
9844	public function createSignedJsonResponse ( int $ status , array $ arrayToJsonify , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSignedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
3938	private function setExplanation ( PropertyInterface $ property , $ propInfo ) { if ( $ property -> getExplanation ( ) || ! isset ( $ propInfo [ 'explanation' ] ) ) { return ; } $ property -> setExplanation ( $ propInfo [ 'explanation' ] ) ; }
5269	private function translateSelect ( ) { $ build = array ( 'select' ) ; if ( $ this -> found_rows ) { $ build [ ] = 'SQL_CALC_FOUND_ROWS' ; } if ( $ this -> distinct ) { $ build [ ] = 'distinct' ; } $ build [ ] = ! empty ( $ this -> statements [ 'select' ] ) && is_array ( $ this -> statements [ 'select' ] ) ? join ( ', ' , $ this -> statements [ 'select' ] ) : '*' ; $ build [ ] = 'from ' . $ this -> table ; if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> statements [ 'groups' ] ) ) { $ build [ ] = 'group by ' . join ( ', ' , $ this -> statements [ 'groups' ] ) ; if ( ! empty ( $ this -> statements [ 'having' ] ) ) { $ build [ ] = $ this -> statements [ 'having' ] ; } } if ( ! empty ( $ this -> statements [ 'orders' ] ) ) { $ build [ ] = $ this -> translateOrderBy ( ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
2162	public function run35Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_member` CHANGE `username` `username` varchar(64) COLLATE utf8_bin NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_member` SET username=NULL WHERE username=''" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_member` DROP INDEX `username`, ADD UNIQUE KEY `username` (`username`)" ) ; }
2317	public function computeResize ( ) { $ resizeCoordinates = System :: getContainer ( ) -> get ( 'contao.image.resize_calculator' ) -> calculate ( $ this -> prepareResizeConfig ( ) , new ImageDimensions ( new Box ( $ this -> fileObj -> viewWidth , $ this -> fileObj -> viewHeight ) , $ this -> fileObj -> viewWidth !== $ this -> fileObj -> width ) , $ this -> prepareImportantPart ( ) ) ; return array ( 'width' => $ resizeCoordinates -> getCropSize ( ) -> getWidth ( ) , 'height' => $ resizeCoordinates -> getCropSize ( ) -> getHeight ( ) , 'target_x' => - $ resizeCoordinates -> getCropStart ( ) -> getX ( ) , 'target_y' => - $ resizeCoordinates -> getCropStart ( ) -> getY ( ) , 'target_width' => $ resizeCoordinates -> getSize ( ) -> getWidth ( ) , 'target_height' => $ resizeCoordinates -> getSize ( ) -> getHeight ( ) , ) ; }
8231	public static function getItemByUrl ( $ items , $ url ) { if ( ! isset ( $ items ) ) { return null ; } if ( array_key_exists ( "/" . $ url , $ items ) ) { return $ items [ "/" . $ url ] ; } $ urlParts = explode ( "/" , trim ( $ url , "/" ) ) ; $ urlPartsLen = count ( $ urlParts ) ; while ( $ urlPartsLen > 0 ) { unset ( $ urlParts [ -- $ urlPartsLen ] ) ; $ subUrl = "/" . join ( "/" , $ urlParts ) ; if ( array_key_exists ( $ subUrl , $ items ) && ( ! isset ( $ items [ $ subUrl ] [ "recursive" ] ) || $ items [ $ subUrl ] [ "recursive" ] === true ) ) { return $ items [ $ subUrl ] ; } } return null ; }
2060	public function scheduleUpdate ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord || ! $ dc -> activeRecord -> id || Contao \ Input :: get ( 'act' ) == 'copy' ) { return ; } $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; $ session [ ] = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> id ) -> rootId ; $ objSession -> set ( 'sitemap_updater' , array_unique ( $ session ) ) ; }
1930	public function attachFile ( $ strFile , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( \ Swift_Attachment :: fromPath ( $ strFile , $ strMime ) -> setFilename ( basename ( $ strFile ) ) ) ; }
3583	protected function joinMeta ( Builder $ query , $ column ) { $ query -> prefixColumnsForJoin ( ) ; $ alias = $ this -> generateMetaAlias ( ) ; $ table = ( new Attribute ) -> getTable ( ) ; $ query -> leftJoin ( "{$table} as {$alias}" , function ( $ join ) use ( $ alias , $ column ) { $ join -> on ( "{$alias}.metable_id" , '=' , $ this -> getQualifiedKeyName ( ) ) -> where ( "{$alias}.metable_type" , '=' , $ this -> getMorphClass ( ) ) -> where ( "{$alias}.meta_key" , '=' , $ column ) ; } ) ; return $ alias ; }
10627	public static function cpuCoreInfo ( ) { $ cores = array ( ) ; if ( false !== ( $ data = @ file ( '/proc/stat' ) ) ) { foreach ( $ data as $ line ) { if ( preg_match ( '/^cpu[0-9]/' , $ line ) ) { $ info = explode ( ' ' , $ line ) ; $ cores [ ] = array ( 'user' => $ info [ 1 ] , 'nice' => $ info [ 2 ] , 'sys' => $ info [ 3 ] , 'idle' => $ info [ 4 ] , 'iowait' => $ info [ 5 ] , 'irq' => $ info [ 6 ] , 'softirq' => $ info [ 7 ] ) ; } } } return $ cores ; }
193	public function clear ( ) { $ this -> _headers = null ; $ this -> _cookies = null ; $ this -> _statusCode = 200 ; $ this -> statusText = 'OK' ; $ this -> data = null ; $ this -> stream = null ; $ this -> content = null ; $ this -> isSent = false ; }
863	private function changeCodeHash ( $ codeHash ) { if ( null !== $ this -> codeHash ) { self :: clearCache ( $ this -> codeHash ) ; } $ this -> codeHash = $ codeHash ; self :: setCache ( $ this -> codeHash , $ this ) ; }
1279	private function extractSpaceId ( array $ data ) : string { if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Space' === $ data [ 'sys' ] [ 'type' ] ) { return $ data [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Environment' === $ data [ 'sys' ] [ 'type' ] ) { return $ this -> spaceId ; } if ( isset ( $ data [ 'sys' ] [ 'space' ] ) ) { return $ data [ 'sys' ] [ 'space' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'space' ] ) ) { return $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'space' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] ) && ! $ data [ 'items' ] ) { return $ this -> spaceId ; } return '[blank]' ; }
4393	public function cancel ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsVoid ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> void ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_CANCELED ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
3445	private function getAccessor ( $ field ) { $ method = 'get' . camel_case ( $ field ) . 'Attribute' ; return method_exists ( $ this , $ method ) ? $ method : false ; }
6841	public function getCache ( $ key ) { return isset ( $ this -> caches [ $ key ] ) ? $ this -> caches [ $ key ] : null ; }
9278	public function fetchByWhere ( $ where = null , array $ options = array ( ) ) { $ select = $ this -> sql -> select ( ) ; if ( $ where instanceof Where ) { $ select -> where ( $ where ) ; } elseif ( is_string ( $ where ) && ! empty ( $ where ) ) { $ select -> where ( $ where ) ; } $ limit = array_key_exists ( 'limit' , $ options ) ? ( int ) $ limit : null ; if ( ! is_null ( $ limit ) && ( int ) $ limit > 0 ) { $ select -> limit ( $ limit ) ; } $ stmt = $ this -> sql -> prepareStatementForSqlObject ( $ select ) ; $ result = $ stmt -> execute ( ) ; $ hydrate = array_key_exists ( 'hydrate' , $ options ) ? ( bool ) $ options [ 'hydrate' ] : true ; if ( $ hydrate !== true ) { return $ result ; } return $ this -> hydrateResult ( $ result ) ; }
8751	private function addCurrentMessage ( ) { if ( $ this -> currentMessage -> hasTranslation ( ) ) { $ this -> messages [ ] = $ this -> currentMessage ; $ this -> currentMessage = new Message ( ) ; } }
5483	public function attachLabelBySelector ( SelectorInterface $ selector , $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { if ( method_exists ( $ this -> widgets [ $ i ] , 'setLabel' ) ) { $ this -> widgets [ $ i ] -> setLabel ( $ label ) ; return ; } } } }
8336	public function setValueMutator ( callable $ callback ) : self { $ this -> valueMutator = $ callback ; $ this -> value = ( $ this -> valueMutator ) ( $ this -> value ) ; return $ this ; }
12866	public function init_locales ( ) { if ( ! empty ( $ this -> textdomain ) && $ this -> locales_initialized !== true ) { load_plugin_textdomain ( $ this -> textdomain , true , $ this -> get_id ( ) ) ; $ this -> locales_initialized = true ; } }
626	public function cache ( $ duration = null , $ dependency = null ) { $ this -> queryCacheDuration = $ duration === null ? $ this -> db -> queryCacheDuration : $ duration ; $ this -> queryCacheDependency = $ dependency ; return $ this ; }
5134	private static function createUri ( string $ scheme , string $ host , ? int $ port , string $ user , string $ password , string $ path , string $ query , string $ fragment ) : \ One \ Uri { return new Uri ( $ scheme , $ host , $ port , $ path , $ query , $ fragment , $ user , $ password ) ; }
3718	protected function getMetaModelFromModel ( ModelInterface $ model ) { if ( ! ( ( $ model -> getProviderName ( ) == 'tl_metamodel_dca_sortgroup' ) && $ model -> getProperty ( 'pid' ) ) ) { throw new DcGeneralInvalidArgumentException ( sprintf ( 'Model must originate from tl_metamodel_dca_sortgroup and be saved, this one originates from %s ' . 'and has pid %s' , $ model -> getProviderName ( ) , $ model -> getProperty ( 'pid' ) ) ) ; } $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'pid' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchColumn ( ) ; $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; return $ this -> factory -> getMetaModel ( $ tableName ) ; }
3294	protected function buildLink ( $ provider , $ url ) { $ fontAwesomeVersion = config ( 'laravel-share.fontAwesomeVersion' , 4 ) ; $ this -> html .= trans ( "laravel-share::laravel-share-fa$fontAwesomeVersion.$provider" , [ 'url' => $ url , 'class' => key_exists ( 'class' , $ this -> options ) ? $ this -> options [ 'class' ] : '' , 'id' => key_exists ( 'id' , $ this -> options ) ? $ this -> options [ 'id' ] : '' , ] ) ; }
2456	public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( \ is_array ( $ ids ) && \ strlen ( $ ids [ 0 ] ) ) { foreach ( $ ids as $ id ) { $ this -> intId = $ id ; $ this -> delete ( true ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
6133	protected function getImage ( $ name , $ text = "" , $ class = null , $ iconpath = true , $ flagpath = false ) { $ src = "" ; if ( $ iconpath ) { $ src = $ this -> iconpath ; } if ( $ flagpath ) { $ src = $ this -> flagpath ; } return "<img src='" . $ src . $ name . "' title='" . $ text . "' alt='' align='top' />" ; }
8969	protected function initialize ( ) { if ( ! file_exists ( dirname ( $ this -> pathToFile ) ) && ! mkdir ( dirname ( $ this -> pathToFile ) , 0777 , true ) ) { throw new RuntimeException ( sprintf ( 'Could not create storage file on path "%s".' , $ this -> pathToFile ) ) ; } if ( ! file_exists ( $ this -> pathToFile ) && ! ( touch ( $ this -> pathToFile ) && chmod ( $ this -> pathToFile , 0777 ) ) ) { throw new RuntimeException ( sprintf ( 'Could not create storage file on path "%s".' , $ this -> pathToFile ) ) ; } if ( ! is_readable ( $ this -> pathToFile ) ) { throw new RuntimeException ( sprintf ( 'File on path "%s" for storing rates must be readable.' , $ this -> pathToFile ) ) ; } if ( ! is_writable ( $ this -> pathToFile ) ) { throw new RuntimeException ( sprintf ( 'File on path "%s" for storing rates must be writeable.' , $ this -> pathToFile ) ) ; } }
6224	public function removeDir ( ) : bool { if ( ! $ this -> isDir ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to remove directory for path: "%s"' , $ this -> path -> raw ) , 500 ) ; } try { $ iterator = $ this -> getIterator ( true , \ RecursiveIteratorIterator :: CHILD_FIRST ) ; foreach ( $ iterator as $ splFile ) { if ( ! $ splFile -> isReadable ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to access file for path: "%s"' , $ splFile -> getPathname ( ) ) , 500 ) ; } switch ( $ splFile -> getType ( ) ) { case 'dir' : rmdir ( $ splFile -> getRealPath ( ) ) ; break ; case 'link' : unlink ( $ splFile -> getPathname ( ) ) ; break ; default : unlink ( $ splFile -> getRealPath ( ) ) ; } } return rmdir ( $ this -> path -> raw ) ; } finally { $ this -> selfdestruct = false ; $ this -> path -> reload ( ) ; } }
2012	public static function addNamespace ( $ name ) { @ trigger_error ( 'Using ClassLoader::addNamespace() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ in_array ( $ name , self :: $ namespaces ) ) { return ; } array_unshift ( self :: $ namespaces , $ name ) ; }
5095	protected function getDefaultParts ( ) { if ( ! isset ( CmdUpsert :: $ DEFAULT ) ) { CmdUpsert :: $ DEFAULT = parent :: getDefaultParts ( ) ; CmdUpsert :: $ PART_SET = count ( CmdUpsert :: $ DEFAULT ) ; CmdUpsert :: $ DEFAULT [ CmdUpsert :: $ PART_SET ] = false ; } return CmdUpsert :: $ DEFAULT ; }
201	private function valueExists ( $ targetClass , $ query , $ value ) { $ db = $ targetClass :: getDb ( ) ; $ exists = false ; if ( $ this -> forceMasterDb && method_exists ( $ db , 'useMaster' ) ) { $ db -> useMaster ( function ( $ db ) use ( $ query , $ value , & $ exists ) { $ exists = $ this -> queryValueExists ( $ query , $ value ) ; } ) ; } else { $ exists = $ this -> queryValueExists ( $ query , $ value ) ; } return $ exists ; }
10443	protected function handleStart ( $ line ) { if ( preg_match ( '/^(INSERT INTO|UPDATE|DELETE FROM)\s+`?(.*?)`?\.`?(.*?)`?$/' , $ line , $ part ) ) { return [ 'type' => $ this -> detectQueryType ( $ part [ 1 ] ) , 'table' => $ part [ 3 ] , ] ; } throw new \ UnexpectedValueException ( "Expected a statement, got {$line}" ) ; }
7625	public function blobExists ( $ containerName = '' , $ blobName = '' , $ snapshotId = null ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; try { $ this -> getBlobInstance ( $ containerName , $ blobName , $ snapshotId ) ; } catch ( BlobException $ e ) { return false ; } return true ; }
4430	protected function writeInstallerSummary ( $ errors ) { if ( ! $ errors ) { $ this -> writeSection ( 'You can now continue installation as per instructions in the README.md file!' ) ; return ; } $ this -> writeSection ( array ( 'The command was not able to install everything automatically.' , 'You must do the following changes manually.' , ) , 'error' ) ; $ this -> output -> writeln ( $ errors ) ; }
11127	protected function renderView ( $ view , $ data ) { try { return parent :: renderView ( $ view , $ data ) ; } catch ( \ InvalidArgumentException $ e ) { return static :: applyDataToView ( $ view , $ data ) ; } }
7982	public function addDeleteTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaDeleteTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
8287	protected function createContainer ( ) { $ configDir = $ this -> pico -> getConfigDir ( ) ; $ userContainer = $ configDir . "PicoAuth/container.php" ; if ( is_file ( $ userContainer ) && is_readable ( $ userContainer ) ) { $ this -> container = include $ userContainer ; if ( $ this -> container === false || ! ( $ this -> container instanceof \ League \ Container \ Container ) ) { throw new \ RuntimeException ( "The container.php does not return container instance." ) ; } } else { $ this -> container = include $ this -> pluginDir . '/src/container.php' ; } $ this -> container -> share ( 'configDir' , new \ League \ Container \ Argument \ RawArgument ( $ configDir ) ) ; $ this -> container -> share ( 'PicoAuth' , $ this ) ; if ( ! $ this -> config [ "rateLimit" ] ) { $ this -> container -> share ( 'RateLimit' , \ PicoAuth \ Security \ RateLimiting \ NullRateLimit :: class ) ; } }
3931	private function getOrCreateProperty ( PropertiesDefinitionInterface $ definition , $ propName ) { if ( $ definition -> hasProperty ( $ propName ) ) { return $ definition -> getProperty ( $ propName ) ; } $ property = new DefaultProperty ( $ propName ) ; $ definition -> addProperty ( $ property ) ; return $ property ; }
4696	public static function getToken ( $ token_name = self :: TOKEN_NAME ) { if ( empty ( $ _SESSION [ $ token_name ] ) ) { static :: generateToken ( $ token_name ) ; } return $ _SESSION [ $ token_name ] ; }
3607	protected function getTableNames ( ) { $ schemas = DB :: getConfig ( 'used_schemas' ) ? : [ DB :: getConfig ( 'schema' ) ] ; $ schemaCount = count ( $ schemas ) ; $ binds = implode ( ',' , array_fill ( 0 , $ schemaCount , '?' ) ) ; return collect ( DB :: select ( "SELECT schemaname || '.' || tablename AS table FROM pg_catalog.pg_tables WHERE schemaname IN (" . $ binds . ')' , $ schemas ) ) -> pluck ( 'table' ) -> reject ( function ( $ value , $ key ) { $ tableName = explode ( '.' , $ value ) [ 1 ] ; return $ tableName === 'spatial_ref_sys' ; } ) ; }
4908	public function render ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ renderer -> headscript ( ) -> appendFile ( $ renderer -> basepath ( 'modules/Core/js/jquery.summary-form.js' ) ) ; $ label = $ form -> getLabel ( ) ; $ labelContent = $ label ? '<div class="sf-headline"><h3>' . $ this -> getView ( ) -> translate ( $ label ) . '</h3></div>' : '' ; $ formContent = $ this -> renderForm ( $ form , $ layout , $ parameter ) ; $ summaryContent = $ this -> renderSummary ( $ form ) ; $ formContent = sprintf ( '<div class="sf-form"><div class="panel panel-info"><div class="panel-body">%s</div></div></div> <div class="sf-summary">%s</div> ' , $ formContent , $ summaryContent ) ; if ( $ form instanceof DescriptionAwareFormInterface && $ form -> isDescriptionsEnabled ( ) ) { $ this -> getView ( ) -> headscript ( ) -> appendFile ( $ this -> getView ( ) -> basepath ( 'modules/Core/js/forms.descriptions.js' ) ) ; if ( $ desc = $ form -> getOption ( 'description' , '' ) ) { $ translator = $ this -> getTranslator ( ) ; $ textDomain = $ this -> getTranslatorTextDomain ( ) ; $ desc = $ translator -> translate ( $ desc , $ textDomain ) ; } $ formContent = sprintf ( '<div class="daf-form-container row"> <div class="daf-form col-md-8">%s</div> <div class="daf-desc col-md-4"> <div class="daf-desc-content alert alert-info">%s</div> </div> </div>' , $ formContent , $ desc ) ; } $ markup = '<div id="sf-%s" class="sf-container" data-display-mode="%s">' . '%s' . '%s' . '</div>' ; $ id = str_replace ( '.' , '-' , $ form -> getAttribute ( 'name' ) ) ; $ content = sprintf ( $ markup , $ id , $ form -> getDisplayMode ( ) , $ labelContent , $ formContent ) ; return $ content ; }
12086	public function save ( ) { $ this -> checkPermission ( "special" , "/admin" ) ; $ referer = $ this -> application -> input -> getReferer ( ) ; if ( ! $ this -> application -> input -> methodIs ( "post" ) ) { $ this -> response -> addAlert ( "No configuration data recieved" , 'error' ) ; } else { if ( ( $ data = $ this -> application -> input -> getArray ( "options" , array ( ) , "post" ) ) == FALSE ) { $ this -> response -> addAlert ( "No input data recieved, Something went wrong" , 'error' ) ; } else { $ namespace = $ this -> application -> input -> getString ( "options_namespace" , "" , "post" ) ; $ this -> application -> config -> mergeParams ( $ namespace , $ data ) ; if ( ! $ this -> application -> config -> saveParams ( ) ) { $ this -> response -> addAlert ( 'Something went wrong, Did not save the parameters' , 'error' ) ; } else { $ this -> response -> addAlert ( "Your configuration settings have now been saved" , "success" ) ; } } } $ this -> application -> dispatcher -> redirect ( $ referer , HTTP_FOUND , null , $ this -> response -> getAlerts ( ) ) ; return true ; }
40	protected function fetchRootIdentifier ( ) { if ( $ this -> repoData ) { return ; } $ repoDataUrl = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository ; $ this -> repoData = JsonFile :: parseJson ( $ this -> getContents ( $ repoDataUrl , true ) , $ repoDataUrl ) ; if ( null === $ this -> repoData && null !== $ this -> gitDriver ) { return ; } $ this -> owner = $ this -> repoData [ 'owner' ] [ 'login' ] ; $ this -> repository = $ this -> repoData [ 'name' ] ; $ this -> isPrivate = ! empty ( $ this -> repoData [ 'private' ] ) ; if ( isset ( $ this -> repoData [ 'default_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'default_branch' ] ; } elseif ( isset ( $ this -> repoData [ 'master_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'master_branch' ] ; } else { $ this -> rootIdentifier = 'master' ; } $ this -> hasIssues = ! empty ( $ this -> repoData [ 'has_issues' ] ) ; }
9743	public function setCountry ( $ country ) { if ( ! ( $ country instanceof Country ) ) { $ country = new Country ( $ country ) ; } if ( $ country -> isEmpty ( ) ) { $ this -> invalidArguments ( '10001' ) ; } return $ this -> setParameter ( 'country' , $ country ) ; }
942	public function isDryRun ( ) { if ( null === $ this -> isDryRun ) { if ( $ this -> isStdIn ( ) ) { $ this -> isDryRun = true ; } else { $ this -> isDryRun = $ this -> options [ 'dry-run' ] ; } } return $ this -> isDryRun ; }
10557	public function dispatchNextJobInChain ( ) { if ( ! empty ( $ this -> chained ) ) { new PendingDispatch ( tap ( unserialize ( array_shift ( $ this -> chained ) ) , function ( $ next ) { $ next -> chained = $ this -> chained ; } ) ) ; } }
5921	public function getProperty ( $ systemName ) { foreach ( $ this -> propertySets as $ propertySet ) { foreach ( $ propertySet -> getProperties ( ) as $ property ) { if ( $ property -> getPropertyType ( ) -> getSystemName ( ) == $ systemName ) { return $ property ; } } } throw new PropertyNotFoundException ( 'No Property with the system name "' . $ systemName . '" exists.' ) ; }
1366	protected function bootResponseMacro ( ) { Response :: macro ( 'jsonApi' , function ( $ api = null ) { return json_api ( $ api ) -> getResponses ( ) -> withEncodingParameters ( app ( EncodingParametersInterface :: class ) ) ; } ) ; }
12273	public static function cast ( $ date ) { return $ date instanceof self ? $ date : new self ( $ date -> format ( self :: ISO8601 ) , $ date -> getTimezone ( ) ) ; }
3347	public function __preparedRequest ( $ type , $ request_type = 'GET' , $ params = array ( ) , $ data = array ( ) , $ retry_throttled = null ) { $ retry_throttled = $ retry_throttled ? : $ this -> retry_throttled ; $ path = $ this -> __getPath ( $ type , $ params ) ; while ( true ) { try { return $ this -> request ( $ request_type , $ path , $ data ) ; } catch ( ThrottledRequestException $ exception ) { if ( $ retry_throttled > 0 ) { sleep ( $ exception -> getTimeout ( ) ) ; $ retry_throttled -- ; continue ; } else { throw $ exception ; } } } return null ; }
9740	public function getPrintArea ( $ index = 0 ) { if ( $ index == 0 ) { return $ this -> printArea ; } $ printAreas = explode ( ',' , $ this -> printArea ) ; if ( isset ( $ printAreas [ $ index - 1 ] ) ) { return $ printAreas [ $ index - 1 ] ; } throw new PhpSpreadsheetException ( 'Requested Print Area does not exist' ) ; }
12783	protected function createIntersections ( ) { $ totalNumberOfCombinations = min ( pow ( 2 , $ this -> arraysSize ) , $ this -> maxNumberOfCombinations ) ; $ maskGenerator = new BitMaskGenerator ( $ this -> arraysSize , 2 ) ; $ i = 0 ; $ noresult = 0 ; while ( $ i < $ totalNumberOfCombinations && $ noresult < $ totalNumberOfCombinations && $ mask = $ maskGenerator -> getNextMask ( ) ) { if ( ! $ this -> isNoResultMask ( $ mask ) ) { $ i ++ ; $ this -> generateIntersection ( $ mask ) ; continue ; } $ noresult ++ ; } if ( ! is_null ( $ this -> intersections ) ) { uasort ( $ this -> intersections , function ( $ a , $ b ) { return count ( $ b ) - count ( $ a ) ; } ) ; } }
5417	protected function createResponse ( $ socket ) { $ response = new SimpleHttpResponse ( $ socket , $ this -> route -> getUrl ( ) , $ this -> encoding ) ; $ socket -> close ( ) ; return $ response ; }
8534	public function setChargeInstrumentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ChargeInstrumentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7162	private function buildSaleTaxesViews ( Model \ SaleInterface $ sale ) { if ( ! $ this -> options [ 'taxes_view' ] ) { return ; } $ amounts = $ this -> amountCalculator -> calculateSale ( $ sale ) ; foreach ( $ amounts -> getTaxAdjustments ( ) as $ tax ) { $ this -> view -> addTax ( new TaxView ( $ tax -> getName ( ) , $ this -> formatter -> currency ( $ tax -> getAmount ( ) ) ) ) ; } }
4909	public function renderForm ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ formHelper = $ renderer -> plugin ( 'form' ) ; $ fieldset = $ form -> getBaseFieldset ( ) ; $ resetPartial = false ; if ( $ fieldset instanceof ViewPartialProviderInterface ) { $ origPartial = $ fieldset -> getViewPartial ( ) ; $ partial = "$origPartial.form" ; if ( $ renderer -> resolver ( $ partial ) ) { $ fieldset -> setViewPartial ( $ partial ) ; $ resetPartial = true ; } } $ markup = $ formHelper -> renderBare ( $ form , $ layout , $ parameter ) ; if ( $ resetPartial ) { $ fieldset -> setViewPartial ( $ origPartial ) ; } return $ markup ; }
3060	public function getCurrentAssessmentItemRef ( ) { if ( $ this -> isAdaptive ( ) ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAssessmentItemRefByIdentifier ( $ this -> getCompilationDirectory ( ) [ 'private' ] , $ this -> getCurrentCatItemId ( ) ) ; } else { return $ this -> getTestSession ( ) -> getCurrentAssessmentItemRef ( ) ; } }
6035	public function setCommands ( array $ commands ) { $ this -> commands = [ ] ; foreach ( $ commands as $ item ) { $ this -> addCommand ( $ item ) ; } return $ this ; }
2159	public function run210Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_style` ADD `positioning` char(1) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_style` SET `positioning`=`size`" ) ; $ this -> Database -> query ( "UPDATE `tl_module` SET `guests`=1 WHERE `type`='lostPassword' OR `type`='registration'" ) ; $ this -> Database -> query ( "UPDATE `tl_news` SET `teaser`=CONCAT('<p>', teaser, '</p>') WHERE `teaser`!='' AND `teaser` NOT LIKE '<p>%'" ) ; }
9153	public function getUrlString ( ) : string { $ query = "" ; if ( strlen ( $ this -> queryString ) > 0 ) { $ query = sprintf ( "?%s" , $ this -> queryString ) ; } if ( ( $ this -> scheme == 'http' && $ this -> getPort ( ) == 80 ) || ( $ this -> scheme == 'ftp' && $ this -> getPort ( ) == 21 ) || ( $ this -> scheme == 'https' && $ this -> getPort ( ) == 443 ) ) { return sprintf ( "%s://%s%s%s" , $ this -> scheme , $ this -> getAddress ( ) , $ this -> path , $ query ) ; } return sprintf ( "%s://%s:%d%s%s" , $ this -> scheme , $ this -> getAddress ( ) , $ this -> getPort ( ) , $ this -> path , $ query ) ; }
3053	public function getCatEngine ( RouteItem $ routeItem = null ) { $ compiledDirectory = $ this -> getCompilationDirectory ( ) [ 'private' ] ; $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ compiledDirectory ) ; $ routeItem = $ routeItem ? $ routeItem : $ this -> getTestSession ( ) -> getRoute ( ) -> current ( ) ; $ sectionId = $ routeItem -> getAssessmentSection ( ) -> getIdentifier ( ) ; $ catEngine = false ; if ( isset ( $ adaptiveSectionMap [ $ sectionId ] ) ) { $ catEngine = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getEngine ( $ adaptiveSectionMap [ $ sectionId ] [ 'endpoint' ] ) ; } return $ catEngine ; }
5456	protected function addContentToAllOpenTags ( $ text ) { foreach ( array_keys ( $ this -> tags ) as $ name ) { for ( $ i = 0 , $ count = count ( $ this -> tags [ $ name ] ) ; $ i < $ count ; $ i ++ ) { $ this -> tags [ $ name ] [ $ i ] -> addContent ( $ text ) ; } } }
8690	protected function validateElementValues ( ) { foreach ( self :: $ mandatoryFields as $ field ) { if ( array_key_exists ( $ field , $ this -> attributes ) ) { $ value = ( int ) $ this -> attributes [ $ field ] ; if ( $ value < 0 ) { throw new \ SVGCreator \ SVGException ( "The " . $ field . " value is lesser than 0, in element " . self :: TYPE , 1 ) ; } } } }
7647	public function stream_open ( $ path , $ mode , $ options , & $ opened_path ) { $ this -> fileName = $ path ; $ this -> temporaryFileName = tempnam ( sys_get_temp_dir ( ) , 'azure' ) ; $ fh = @ fopen ( $ this -> temporaryFileName , $ mode ) ; if ( $ fh === false ) { return false ; } fclose ( $ fh ) ; if ( strpbrk ( $ mode , 'wax+' ) ) { $ this -> writeMode = true ; } else { $ this -> writeMode = false ; } if ( ! $ this -> writeMode || strpbrk ( $ mode , 'ra+' ) ) { $ this -> getStorageClient ( $ this -> fileName ) -> getBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } $ this -> temporaryFileHandle = fopen ( $ this -> temporaryFileName , $ mode ) ; return true ; }
10633	protected function getVars ( $ content , $ details = [ ] ) { $ defaults = [ 'title' => Translate :: t ( 'file.title' , [ ] , 'filefield' ) , 'file' => false , ] ; $ vars = array_merge ( $ defaults , $ content ) ; $ this -> getModel ( ) -> setVars ( $ vars ) ; }
9875	private function writeLegacyDrawingHF ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getHeaderFooter ( ) -> getImages ( ) ) > 0 ) { $ objWriter -> startElement ( 'legacyDrawingHF' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId_headerfooter_vml1' ) ; $ objWriter -> endElement ( ) ; } }
7657	function Send ( ) { $ header = "" ; $ body = "" ; $ result = true ; if ( ( count ( $ this -> to ) + count ( $ this -> cc ) + count ( $ this -> bcc ) ) < 1 ) { $ this -> SetError ( $ this -> Lang ( "provide_address" ) ) ; return false ; } if ( ! empty ( $ this -> AltBody ) ) $ this -> ContentType = "multipart/alternative" ; $ this -> error_count = 0 ; $ this -> SetMessageType ( ) ; $ header .= $ this -> CreateHeader ( ) ; $ body = $ this -> CreateBody ( ) ; if ( $ body == "" ) { return false ; } switch ( $ this -> Mailer ) { case "sendmail" : $ result = $ this -> SendmailSend ( $ header , $ body ) ; break ; case "mail" : $ result = $ this -> MailSend ( $ header , $ body ) ; break ; case "smtp" : $ result = $ this -> SmtpSend ( $ header , $ body ) ; break ; default : $ this -> SetError ( $ this -> Mailer . $ this -> Lang ( "mailer_not_supported" ) ) ; $ result = false ; break ; } return $ result ; }
2616	private function prepareCustomVariables ( ) { if ( $ this -> validationServiceId != null ) { $ serviceId = $ this -> validationServiceId ; } else { $ serviceId = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_SERVICE_ID ) ; } $ customVars = [ 'cd1' => $ serviceId , 'cd2' => ( $ this -> isApiKeyValid ( ) ) ? 'yes' : 'no' , 'cd3' => $ this -> getWebsiteName ( ) , 'cd4' => $ this -> request -> getServer ( 'HTTP_HOST' ) , 'cd5' => $ this -> getSiteLocation ( ) , 'cd6' => $ this -> helper -> getModuleVersion ( ) , 'cd7' => $ this -> config -> getCID ( ) , 'cd8' => 'fastlyext' ] ; return $ customVars ; }
4166	public function run ( $ command ) { $ process = new Process ( $ command , null , null , null , ini_get ( 'max_execution_time' ) ) ; $ process -> run ( function ( $ type , $ buffer ) { if ( Process :: ERR === $ type ) { $ this -> console -> warn ( trim ( $ buffer ) ) ; } else { $ this -> console -> info ( trim ( $ buffer ) ) ; } } ) ; if ( ! $ process -> isSuccessful ( ) ) { throw new ProcessFailedException ( $ process ) ; } return true ; }
11265	public function model ( $ pathname ) { $ fullPath = $ this -> config [ 'pathToModels' ] . $ this -> getPath ( $ pathname ) . $ this -> config [ 'modelsPrefix' ] . $ this -> getName ( $ pathname ) . $ this -> config [ 'modelsPostfix' ] . '.php' ; include_once ( $ fullPath ) ; }
7839	public function info ( int $ id ) : ? array { $ response = Request :: get ( $ this -> baseUrl . 'contact/' . $ id ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
2940	public static function addUnit ( UnitOfMeasureInterface $ unit ) { if ( static :: unitNameOrAliasesAlreadyRegistered ( $ unit ) ) { throw new Exception \ DuplicateUnitNameOrAlias ( [ ':labels' => implode ( ', ' , array_merge ( [ $ unit -> getName ( ) ] , $ unit -> getAliases ( ) ) ) ] ) ; } static :: $ unitDefinitions [ ] = $ unit ; }
11562	protected function getWeekWordsUnitsAndShortcuts ( $ lang ) { if ( ! isset ( $ this -> weekWords [ $ lang ] ) ) { if ( isset ( static :: $ WeekWordsDefault [ $ lang ] ) ) { $ this -> weekWords [ $ lang ] = explode ( ',' , static :: $ WeekWordsDefault [ $ lang ] ) ; } else { $ this -> weekWords [ $ lang ] = [ ] ; } } if ( ! $ this -> units ) $ this -> units = explode ( ',' , static :: $ UnitsDefault ) ; if ( ! isset ( $ this -> shortcuts [ $ lang ] ) ) { if ( isset ( static :: $ ShortcutsDefault [ $ lang ] ) ) { $ shortcuts = [ ] ; foreach ( static :: $ ShortcutsDefault [ $ lang ] as $ shortcutsLocalized ) foreach ( $ shortcutsLocalized as $ shortcut ) $ shortcuts [ $ shortcut ] = str_replace ( ' ' , '&nbsp;' , $ shortcut ) ; $ this -> shortcuts [ $ lang ] = & $ shortcuts ; } else { $ this -> shortcuts [ $ lang ] = [ ] ; } } return [ $ this -> weekWords [ $ lang ] , $ this -> units , $ this -> shortcuts [ $ lang ] ] ; }
7589	protected function configureType ( ) { switch ( $ this -> type ) { case 'POST' : $ this -> setOption ( CURLOPT_POST , true ) ; break ; case 'DELETE' : case 'PUT' : $ this -> setOption ( CURLOPT_CUSTOMREQUEST , $ this -> type ) ; break ; } }
8352	public function handle ( int $ signal ) { if ( isset ( $ this -> handlers [ $ signal ] ) && $ this -> handlers [ $ signal ] === true ) { return new Failure ( new Exception ( 'Signal is already being processed.' ) ) ; } $ this -> handlers [ $ signal ] = true ; $ this -> dispatcher -> setIsRunning ( false ) ; $ fn = $ this -> signals [ $ signal ] ; $ result = $ this -> $ fn ( ) ; if ( $ result === true ) { unset ( $ this -> handlers [ $ signal ] ) ; return new Success ( $ result ) ; } $ deferred = new Deferred ; Loop :: repeat ( 1000 , function ( $ watcherId , $ callback ) use ( $ deferred , $ signal , $ result ) { if ( count ( $ this -> dispatcher -> getProcesses ( ) ) === 0 ) { Loop :: cancel ( $ watcherId ) ; unset ( $ this -> handlers [ $ signal ] ) ; return $ deferred -> resolve ( $ result ) ; } } ) ; return $ deferred -> promise ( ) ; }
10683	public function preferred ( array $ types ) : ? string { if ( empty ( $ types ) ) { return null ; } foreach ( $ this -> types as $ type ) { if ( in_array ( $ type , $ types , true ) ) { return $ type ; } elseif ( '*/*' == $ type ) { return current ( $ types ) ; } elseif ( strlen ( $ type ) > 2 && substr ( $ type , - 2 , 2 ) == '/*' ) { $ prefix = substr ( $ type , 0 , strpos ( $ type , '/' ) + 1 ) ; $ plen = strlen ( $ prefix ) ; foreach ( $ types as $ t ) { if ( strncmp ( $ prefix , $ t , $ plen ) === 0 ) { return $ t ; } } } } return null ; }
4498	private function getTrimmedJson ( callable $ inner , int $ limit , string $ error ) : array { $ gcmInner = $ inner ( $ this -> text ) ; $ gcmInnerJson = json_encode ( $ gcmInner , JSON_UNESCAPED_UNICODE ) ; if ( ( $ gcmInnerJsonLength = \ strlen ( $ gcmInnerJson ) ) > $ limit ) { $ cut = $ gcmInnerJsonLength - $ limit ; if ( $ this -> text && ( $ textLength = \ strlen ( $ this -> text ) ) > $ cut && $ this -> allowTrimming ) { $ gcmInner = $ inner ( mb_strcut ( $ this -> text , 0 , $ textLength - $ cut - 3 , 'utf8' ) . '...' ) ; } else { throw new MessageTooLongException ( "$error $gcmInnerJson" ) ; } } return $ gcmInner ; }
12555	public function showAction ( Tag $ tag ) { $ deleteForm = $ this -> createDeleteForm ( $ tag ) ; return array ( 'entity' => $ tag , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
5347	public function revertSnapshotToOtherVps ( $ sourceVpsName , $ snapshotName , $ destinationVpsName ) { return $ this -> call ( self :: SERVICE , 'revertSnapshotToOtherVps' , [ $ sourceVpsName , $ snapshotName , $ destinationVpsName ] ) ; }
2167	protected static function generateHelperObject ( $ value ) { $ return = new \ stdClass ( ) ; if ( ! \ is_array ( $ value ) ) { $ return -> value = rtrim ( $ value , "\x00" ) ; $ return -> isUuid = ( \ strlen ( $ value ) == 16 && ! is_numeric ( $ return -> value ) && strncmp ( $ return -> value , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value ) && $ return -> value > 0 ) ; } else { $ return -> value = array_map ( function ( $ var ) { return rtrim ( $ var , "\x00" ) ; } , $ value ) ; $ return -> isUuid = ( \ strlen ( $ value [ 0 ] ) == 16 && ! is_numeric ( $ return -> value [ 0 ] ) && strncmp ( $ return -> value [ 0 ] , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value [ 0 ] ) && $ return -> value [ 0 ] > 0 ) ; } return $ return ; }
2570	protected static function loadNonceBase ( $ handlerParams ) { if ( empty ( $ handlerParams -> authParams -> nonceBase ) ) { $ handlerParams -> authParams -> nonceBase = SomewhatRandomGenerator :: generateSomewhatRandomString ( ) ; } return $ handlerParams ; }
8450	public function contactRename ( $ contact , $ firstName , $ lastName ) { $ contact = $ this -> escapePeer ( $ contact ) ; $ firstName = $ this -> escapeStringArgument ( $ firstName ) ; $ lastName = $ this -> escapeStringArgument ( $ lastName ) ; return $ this -> exec ( 'rename_contact ' . $ contact . ' ' . $ firstName . ' ' . $ lastName ) ; }
12156	public function getOwner ( ) { if ( ! $ this -> isOwnable ) { return ; } $ ownerObject = $ this -> getOwnerObject ( ) ; if ( is_object ( $ ownerObject ) ) { return $ ownerObject -> primaryKey ; } return $ ownerObject ; }
1787	public function getActiveLayoutSections ( Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> pid ) { $ arrSections = array ( ) ; $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> pid ) ; if ( $ objPage -> layout ) { $ objLayout = Contao \ LayoutModel :: findByPk ( $ objPage -> layout ) ; if ( $ objLayout === null ) { return array ( ) ; } $ arrModules = Contao \ StringUtil :: deserialize ( $ objLayout -> modules ) ; if ( empty ( $ arrModules ) || ! \ is_array ( $ arrModules ) ) { return array ( ) ; } foreach ( $ arrModules as $ arrModule ) { if ( $ arrModule [ 'mod' ] == 0 && $ arrModule [ 'enable' ] ) { $ arrSections [ ] = $ arrModule [ 'col' ] ; } } } } else { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; $ objLayout = $ this -> Database -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = Contao \ StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ arrSections [ ] = $ v [ 'id' ] ; } } } } } return Contao \ Backend :: convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) ; }
5345	public function requestAccess ( $ when , $ duration , array $ visitors , $ phoneNumber ) { return $ this -> call ( self :: SERVICE , 'requestAccess' , [ $ when , $ duration , $ visitors , $ phoneNumber ] ) ; }
12854	public function process ( Pipeline \ Pipeline $ pipeline , $ payload ) { $ runner = clone ( $ this ) ; $ runner -> stages = $ pipeline -> getIterator ( ) ; return $ runner -> handle ( $ payload ) ; }
11967	public function getPidByProgramName ( $ name ) { $ process = new Process ( sprintf ( 'supervisorctl pid %s' , $ name ) ) ; $ process -> run ( ) ; return $ process -> getOutput ( ) ; }
10286	public static function stringFromColumnIndex ( $ columnIndex ) { static $ indexCache = [ ] ; if ( ! isset ( $ indexCache [ $ columnIndex ] ) ) { $ indexValue = $ columnIndex ; $ base26 = null ; do { $ characterValue = ( $ indexValue % 26 ) ? : 26 ; $ indexValue = ( $ indexValue - $ characterValue ) / 26 ; $ base26 = chr ( $ characterValue + 64 ) . ( $ base26 ? : '' ) ; } while ( $ indexValue > 0 ) ; $ indexCache [ $ columnIndex ] = $ base26 ; } return $ indexCache [ $ columnIndex ] ; }
5473	public function isMatch ( $ widget ) { if ( method_exists ( $ widget , 'isLabel' ) ) { if ( $ widget -> isLabel ( $ this -> label ) ) { return true ; } } return ( $ widget -> getName ( ) == $ this -> label ) ; }
12845	protected function processTextType ( $ value , \ Symfony \ Component \ Form \ FormInterface $ form , \ Chill \ CustomFieldsBundle \ Entity \ CustomField $ cf ) { $ form -> submit ( array ( $ cf -> getSlug ( ) => $ value ) ) ; $ value = $ form -> getData ( ) [ $ cf -> getSlug ( ) ] ; $ this -> logger -> debug ( sprintf ( "Found value : %s for custom field with question " . "'%s'" , $ value , $ this -> helper -> localize ( $ cf -> getName ( ) ) ) ) ; return $ value ; }
5755	public function select ( ? string $ columns = "*" , ? array $ whereColumnsInfo = null , ? string $ orderBy = null ) : ? array { if ( $ whereColumnsInfo != null ) { $ this -> validateWhere ( $ whereColumnsInfo ) ; } if ( is_array ( $ whereColumnsInfo ) && array_key_exists ( 'roles.role' , $ whereColumnsInfo ) ) { return $ this -> selectWithRoleSubquery ( $ columns , $ whereColumnsInfo , $ orderBy ) ; } $ columns = $ columns ?? $ this -> defaultSelectColumnsString ; $ orderBy = $ orderBy ?? $ this -> getOrderBy ( ) ; $ q = new SelectBuilder ( "SELECT $columns" , $ this -> getFromClause ( ) , $ whereColumnsInfo , $ orderBy ) ; $ pgResult = $ q -> execute ( ) ; if ( ! $ results = pg_fetch_all ( $ pgResult ) ) { $ results = null ; } pg_free_result ( $ pgResult ) ; return $ results ; }
4667	public function setRenderView ( $ viewPath , $ params ) { $ this -> setViewEngines ( [ '.volt' => function ( $ view = null ) { $ volt = new Volt ( $ view ) ; $ volt -> setOptions ( [ 'compiledPath' => APP_PATH . '/cache/volt/' , 'compiledSeparator' => '_' , 'compileAlways' => ! $ this -> getDI ( ) -> get ( 'config' ) -> application -> production , ] ) ; return $ volt ; } ] ) ; $ view = $ this -> getView ( ) ; $ content = $ view -> render ( $ viewPath , $ params ) ; return $ content ; }
10368	public function recover ( RecoverRequest $ request ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'recover' ) ) -> dispatchFrom ( RecoverJob :: class , $ request ) ; return back ( ) -> withSuccess ( trans ( 'auth::recover.success' ) ) ; }
2922	protected function ensureFileIsReadable ( ) { if ( ! is_readable ( $ this -> filePath ) || ! is_file ( $ this -> filePath ) ) { throw new UnableReadFileException ( sprintf ( 'Unable to read the file at %s.' , $ this -> filePath ) ) ; } }
3390	public function redirectAfterResendConfirmationPath ( ) { if ( method_exists ( $ this , 'redirectAfterResendConfirmationTo' ) ) { return $ this -> redirectAfterResendConfirmationTo ( ) ; } return property_exists ( $ this , 'redirectAfterResendConfirmationTo' ) ? $ this -> redirectAfterResendConfirmationTo : route ( 'login' ) ; }
11952	protected function substituteSQLOperationPlaceholders ( $ sqloperation ) { $ sql_value = $ sqloperation -> toSQLString ( ) ; if ( count ( $ sqloperation -> getPlaceholderValues ( ) ) > 0 ) { $ startpos = 0 ; $ sql_value_replaced = '' ; foreach ( $ sqloperation -> getPlaceholderValues ( ) as $ avalue ) { $ qpos = strpos ( $ sql_value , '?' , $ startpos ) ; $ sql_value_replaced .= substr ( $ sql_value , $ startpos , $ qpos ) ; $ sql_value_replaced .= $ this -> db -> Quote ( $ avalue ) ; $ startpos = $ qpos + 1 ; } $ sql_value_replaced .= substr ( $ sql_value , $ startpos ) ; $ sql_value = $ sql_value_replaced ; } return $ sql_value ; }
9446	public function getConfigsPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ subpath = $ this -> packOptions [ 'configs_subpath' ] ; $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) . '/' . $ subpath ; } return $ paths [ $ me ] ; }
8889	public function set ( $ key , $ value ) { if ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value , false ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } }
8952	public function retrieveMapData ( $ left , $ bottom , $ right , $ top ) { $ base = 'map?bbox=' . $ left . ',' . $ bottom . ',' . $ right . ',' . $ top ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'GET' , array ( ) ) ; return simplexml_load_string ( $ response -> body ) ; }
8366	public static function registerMapping ( array $ config ) { self :: validateConfig ( $ config ) ; if ( isset ( self :: $ mappings [ $ config [ 'name' ] ] ) === false ) { self :: $ mappings [ $ config [ 'name' ] ] = array ( 'config' => $ config ) ; Database :: registerDatabase ( $ config [ 'database' ] ) ; } else { Logger :: get ( ) -> warning ( 'mapping with name "' . $ config [ 'name' ] . '" was already set' ) ; } }
7769	public function passes ( ) { foreach ( $ this -> after as $ after ) { call_user_func_array ( $ after , [ $ this ] ) ; } return empty ( $ this -> errors ) ; }
10332	public function setSize ( $ width , $ height ) { if ( ! is_string ( $ width ) && ! is_int ( $ width ) ) { throw new \ InvalidArgumentException ( 'The width argument must be of type string or integer' ) ; } if ( ! is_string ( $ height ) && ! is_int ( $ height ) ) { throw new \ InvalidArgumentException ( 'The height argument must be of type string or integer' ) ; } $ this -> html = preg_replace ( "/ width([ ]?)=([ ]?)[\"\']([0-9\.]+)[\"\']/" , " width=\"" . $ width . "\"" , $ this -> html ) ; $ this -> html = preg_replace ( "/ height([ ]?)=([ ]?)[\"\']([0-9\.]+)[\"\']/" , " height=\"" . $ height . "\"" , $ this -> html ) ; $ this -> html = preg_replace ( "/width:([0-9\.]+)px/" , "width:" . ( is_numeric ( $ width ) ? $ width . 'px' : $ width ) . "" , $ this -> html ) ; $ this -> html = preg_replace ( "/height:([0-9\.]+)px/" , "height:" . ( is_numeric ( $ height ) ? $ height . 'px' : $ height ) . "" , $ this -> html ) ; $ this -> html = preg_replace ( "/ width([ ]?)=([ ]?)([0-9\.]+)/" , " width=" . $ width , $ this -> html ) ; $ this -> html = preg_replace ( "/ height([ ]?)=([ ]?)([0-9\.]+)/" , " height=" . $ height , $ this -> html ) ; $ this -> width = $ width ; $ this -> height = $ height ; }
6223	public function getMenuPresence ( ) { return [ 'id' => 'simple-acl' , 'type' => MenuPresenceType :: GROUP , 'label' => 'Access Control' , 'children' => [ [ 'id' => 'simple-acl-users' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Users' , 'permissions' => 'acl.users.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.index' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-create-user' , 'type' => MenuPresenceType :: ACTION , 'label' => 'New User' , 'permissions' => 'acl.users.create' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.create' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-roles' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Roles' , 'permissions' => 'acl.roles.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.roles.index' ) , 'parameters' => [ ] , ] , ] ] ; }
12917	public function sumValor ( ) { $ tableGateway = new TableGateway ( $ this -> tableName , $ this -> dbAdapter ) ; $ sql = $ tableGateway -> getSql ( ) ; $ select = $ sql -> select ( ) -> columns ( array ( 'sum' => new Expression ( 'SUM(valor)' ) ) ) ; return $ tableGateway -> selectWith ( $ select ) -> current ( ) ; }
12946	protected function parseTags ( $ tags ) { return array_unique ( is_array ( $ tags ) ? array_filter ( $ tags ) : preg_split ( '/\s*,\s*/' , $ tags , - 1 , PREG_SPLIT_NO_EMPTY ) ) ; }
8249	protected function needsPasswordRehash ( array $ userData ) { if ( $ this -> config [ "login" ] [ "passwordRehash" ] !== true ) { return false ; } if ( isset ( $ userData [ 'encoder' ] ) && $ userData [ 'encoder' ] !== $ this -> config [ "encoder" ] ) { return true ; } $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; return $ encoder -> needsRehash ( $ userData [ 'pwhash' ] ) ; }
11083	public static function passwdGen ( $ length = 8 , $ flag = 'ALPHANUMERIC' ) { switch ( $ flag ) { case 'NUMERIC' : $ str = '0123456789' ; break ; case 'ALPHA' : $ str = 'abcdefghijkmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; case 'ALPHA_LOWER' : $ str = 'abcdefghijkmnopqrstuvwxyz' ; break ; default : $ str = 'abcdefghijkmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; } for ( $ i = 0 , $ passwd = '' ; $ i < $ length ; $ i ++ ) { $ passwd .= substr ( $ str , mt_rand ( 0 , \ strlen ( $ str ) - 1 ) , 1 ) ; } return $ passwd ; }
9327	protected function registerMarkdownEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md' , 'markdown' ) ; }
8671	public static function combine ( $ keys , $ values ) { $ keys = Arr :: from ( $ keys ) ; $ values = Arr :: from ( $ values ) ; if ( count ( $ keys ) !== count ( $ values ) ) { throw new InvalidArgumentException ( 'The size of keys and values needs to be the same.' ) ; } if ( count ( $ keys ) === 0 ) { return new static ( ) ; } return new static ( array_combine ( $ keys , $ values ) ) ; }
7999	public function identifyTargetName ( $ username , $ nt_domain , ServerChallenge $ server_challenge ) { $ target_name = $ nt_domain ? : $ server_challenge -> getTargetName ( ) ; if ( false !== strpos ( $ username , static :: USER_PRINCIPAL_NAME_SEPARATOR ) ) { $ target_name = '' ; } return $ target_name ; }
9401	public function setHttp ( ServerRequestInterface $ request , ResponseInterface $ response ) { $ this -> set ( 'Psr\Http\Message\ServerRequestInterface' , $ request ) ; return $ this -> set ( 'Psr\Http\Message\ResponseInterface' , $ response ) ; }
5690	public static function normalise ( $ html ) { $ rules = array ( '#<!--.*? , '#<(script|option|textarea)[^>]*>.*?</\1>#si' , '#<img[^>]*alt\s*=\s*("([^"]*)"|\'([^\']*)\'|([a-zA-Z_]+))[^>]*>#' , '#<[^>]*>#' , ) ; $ replace = array ( '' , '' , ' \2\3\4 ' , '' , ) ; $ text = preg_replace ( $ rules , $ replace , $ html ) ; $ text = html_entity_decode ( $ text , ENT_QUOTES ) ; $ text = preg_replace ( '#\s+#' , ' ' , $ text ) ; return trim ( trim ( $ text ) , "\xA0" ) ; }
10774	protected function loginByCookie ( ) { $ value = Yii :: $ app -> getRequest ( ) -> getCookies ( ) -> getValue ( $ this -> identityCookie [ 'name' ] ) ; if ( $ value === null ) { return ; } $ data = json_decode ( $ value , true ) ; if ( count ( $ data ) !== 3 || ! isset ( $ data [ 0 ] , $ data [ 1 ] , $ data [ 2 ] ) ) { return ; } list ( $ id , $ authKey , $ duration ) = $ data ; $ class = $ this -> identityClass ; $ identity = $ class :: findIdentity ( $ id ) ; if ( $ identity === null ) { return ; } elseif ( ! $ identity instanceof IdentityInterface ) { throw new InvalidValueException ( "$class::findIdentity() must return an object implementing IdentityInterface." ) ; } if ( $ identity -> validateAuthKey ( $ authKey ) ) { if ( $ this -> beforeLogin ( $ identity , true , $ duration ) ) { $ this -> switchIdentity ( $ identity , $ this -> autoRenewCookie ? $ duration : 0 ) ; $ ip = Yii :: $ app -> getRequest ( ) -> getUserIP ( ) ; Yii :: info ( "User '$id' logged in from $ip via cookie." , __METHOD__ ) ; $ this -> afterLogin ( $ identity , true , $ duration ) ; } } else { Yii :: warning ( "Invalid auth key attempted for user '$id': $authKey" , __METHOD__ ) ; } }
2009	public function onInitializeSystem ( ) : void { foreach ( $ this -> globals as $ key => $ value ) { if ( \ is_array ( $ value ) && isset ( $ GLOBALS [ $ key ] ) && \ is_array ( $ GLOBALS [ $ key ] ) ) { $ GLOBALS [ $ key ] = array_replace_recursive ( $ GLOBALS [ $ key ] , $ value ) ; } else { $ GLOBALS [ $ key ] = $ value ; } } }
8361	public static function init ( RawRequest $ request = null ) { if ( self :: $ isInit === false ) { self :: $ translations = array ( ) ; $ settings = Config :: getSettings ( ) ; if ( isset ( $ settings [ 'locale' ] ) === false || isset ( $ settings [ 'locale' ] [ 'default' ] ) === false ) { throw new BadUse ( 'locale.default isn\'t defined in settings' ) ; } self :: $ currentLanguage = $ settings [ 'locale' ] [ 'default' ] ; if ( $ request != null ) { if ( Session :: has ( '_stray_language' ) === true ) { self :: $ currentLanguage = Session :: get ( '_stray_language' ) ; } else { $ domain = HttpHelper :: extractDomain ( $ request ) ; if ( isset ( $ settings [ 'locale' ] [ 'hosts' ] ) === true && isset ( $ settings [ 'locale' ] [ 'hosts' ] [ $ domain ] ) === true ) { self :: $ currentLanguage = $ settings [ 'locale' ] [ 'hosts' ] [ $ domain ] ; } Session :: set ( '_stray_language' , self :: $ currentLanguage ) ; } } self :: $ isInit = true ; } }
3413	public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; $ this -> original = $ this -> fields ; $ this -> fieldsAreFetched = true ; return $ this -> fields ; }
6742	public function apply ( Request $ request , ParamConverter $ configuration ) { $ param = $ this -> getRequestAttributeName ( $ request , $ configuration ) ; if ( ! $ request -> attributes -> has ( $ param ) ) { return false ; } $ value = $ request -> attributes -> get ( $ param ) ; if ( ! $ value && $ configuration -> isOptional ( ) ) { return false ; } $ convertedValue = $ this -> convertValue ( $ value , $ configuration ) ; if ( null === $ convertedValue && false === $ configuration -> isOptional ( ) ) { throw new NotFoundHttpException ( "Unable to find '{$configuration->getClass()}' with identifier '{$value}' not found" ) ; } $ request -> attributes -> set ( $ configuration -> getName ( ) , $ convertedValue ) ; return true ; }
12715	protected function circularDependencyResolver ( $ class ) { if ( ! is_string ( $ class ) && ! class_exists ( $ class ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be a string of valid class name." , __METHOD__ ) ) ; } $ reflector = Internal \ ReflectionClassFactory :: create ( $ class ) ; if ( ! $ this -> hasConstructor ( $ reflector ) ) { return $ this -> resolveInstanceWithoutConstructor ( $ reflector ) ; } else { $ param = $ this -> getMethodParameters ( $ reflector , '__construct' ) ; if ( empty ( $ param ) ) { return $ reflector -> newInstance ( ) ; } else { foreach ( $ param as $ key => $ value ) { $ class = $ value -> getClass ( ) ; if ( $ class instanceof \ ReflectionClass ) { if ( $ class -> isInterface ( ) ) { $ param [ $ key ] = $ this -> getConcreteFromInterface ( $ class -> getName ( ) ) ; } else { $ param [ $ key ] = $ this -> circularDependencyResolver ( $ class -> getName ( ) ) ; } } } return $ reflector -> newInstanceArgs ( $ param ) ; } } }
3901	public function createColumn ( ) { if ( $ this -> getColName ( ) ) { $ this -> tableManipulator -> createColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) , $ this -> getSQLDataType ( ) ) ; } }
8299	public function addRule ( $ url , $ rule ) { if ( ! is_string ( $ url ) || ! is_array ( $ rule ) ) { throw new \ InvalidArgumentException ( "addRule() expects a string and an array." ) ; } $ this -> runtimeRules [ $ url ] = $ rule ; }
9284	private function checkImports ( $ lessPath , $ cssPath , $ callback ) { static $ needsRecompile = false ; if ( $ needsRecompile ) return $ needsRecompile ; $ lessContent = file_get_contents ( $ lessPath ) ; preg_match_all ( '/(?<=@import)\s+"([^"]+)/im' , $ lessContent , $ imports ) ; foreach ( $ imports [ 1 ] as $ import ) { $ importPath = realpath ( dirname ( $ lessPath ) . DIRECTORY_SEPARATOR . $ import ) ; if ( file_exists ( $ importPath ) ) { if ( $ callback ( $ importPath , $ cssPath ) ) { $ needsRecompile = true ; break ; } else $ needsRecompile = $ this -> checkImports ( $ importPath , $ cssPath , $ callback ) ; } } return $ needsRecompile ; }
2915	public function getLayoutUpdatesFiles ( $ storeId , $ designArea ) { $ updatesRoot = $ this -> getConfig ( ) -> getNode ( $ designArea . '/layout/updates' ) ; $ updateFiles = array ( ) ; foreach ( $ updatesRoot -> children ( ) as $ updateNode ) { if ( $ updateNode -> file ) { $ module = $ updateNode -> getAttribute ( 'module' ) ; if ( $ module && Mage :: getStoreConfigFlag ( 'advanced/modules_disable_output/' . $ module , $ storeId ) ) { continue ; } $ updateFiles [ ] = ( string ) $ updateNode -> file ; } } $ updateFiles [ ] = 'local.xml' ; return $ updateFiles ; }
7592	protected function setFormClass ( FormInterface $ oForm , $ sFormLayout = self :: LAYOUT_HORIZONTAL ) { if ( is_string ( $ sFormLayout ) ) { $ sLayoutClass = 'form-' . $ sFormLayout ; if ( $ sFormClass = $ oForm -> getAttribute ( 'class' ) ) { if ( ! preg_match ( '/(\s|^)' . preg_quote ( $ sLayoutClass , '/' ) . '(\s|$)/' , $ sFormClass ) ) { $ oForm -> setAttribute ( 'class' , trim ( $ sFormClass . ' ' . $ sLayoutClass ) ) ; } } else { $ oForm -> setAttribute ( 'class' , $ sLayoutClass ) ; } } return $ this ; }
176	public static function removeValue ( & $ array , $ value ) { $ result = [ ] ; if ( is_array ( $ array ) ) { foreach ( $ array as $ key => $ val ) { if ( $ val === $ value ) { $ result [ $ key ] = $ val ; unset ( $ array [ $ key ] ) ; } } } return $ result ; }
3787	protected function getMetaModelById ( $ modelId ) { $ services = $ this -> getServiceContainer ( ) ; $ modelFactory = $ services -> getFactory ( ) ; $ name = $ modelFactory -> translateIdToMetaModelName ( $ modelId ) ; return $ modelFactory -> getMetaModel ( $ name ) ; }
2856	public function init ( Varien_Data_Collection_Db $ collection ) { $ this -> class = get_class ( $ collection ) ; $ this -> type = $ collection instanceof Mage_Eav_Model_Entity_Collection_Abstract ? self :: TYPE_EAV : self :: TYPE_FLAT ; $ this -> query = $ collection -> getSelectSql ( true ) ; $ this -> count = 0 ; }
7809	public static function toDebugReport ( ) { $ report = 'PHP SDK (zipMoney) Debug Report:' . PHP_EOL ; $ report .= ' OS: ' . php_uname ( ) . PHP_EOL ; $ report .= ' PHP Version: ' . phpversion ( ) . PHP_EOL ; $ report .= ' OpenAPI Spec Version: 2017-03-01' . PHP_EOL ; $ report .= ' Temp Folder Path: ' . self :: getDefaultConfiguration ( ) -> getTempFolderPath ( ) . PHP_EOL ; return $ report ; }
6873	protected function buildItem ( SaleItemInterface $ saleItem , ShipmentInterface $ shipment ) { if ( $ saleItem -> isCompound ( ) ) { $ available = $ expected = null ; foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { if ( null !== $ child = $ this -> buildItem ( $ childSaleItem , $ shipment ) ) { $ saleItemQty = $ childSaleItem -> getQuantity ( ) ; $ e = $ child -> getExpected ( ) / $ saleItemQty ; if ( null === $ expected || $ expected > $ e ) { $ expected = $ e ; } $ a = $ child -> getAvailable ( ) / $ saleItemQty ; if ( null === $ available || $ available > $ a ) { $ available = $ a ; } } } if ( 0 < $ expected ) { return $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected , $ available ) ; } return null ; } $ item = null ; if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ expected = $ shipment -> isReturn ( ) ? $ this -> calculator -> calculateReturnableQuantity ( $ saleItem , $ shipment ) : $ this -> calculator -> calculateShippableQuantity ( $ saleItem , $ shipment ) ; if ( 0 < $ expected ) { $ item = $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected ) ; } } if ( $ saleItem -> hasChildren ( ) ) { foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { $ this -> buildItem ( $ childSaleItem , $ shipment ) ; } } return $ item ; }
5926	public function listCategories ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/categories' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new CategoryResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
2226	private function renderErrorScreenByException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; $ statusCode = $ this -> getStatusCodeForException ( $ exception ) ; $ template = null ; $ this -> logException ( $ exception ) ; do { if ( $ exception instanceof \ Exception ) { $ template = $ this -> getTemplateForException ( $ exception ) ; } } while ( null === $ template && null !== ( $ exception = $ exception -> getPrevious ( ) ) ) ; $ this -> renderTemplate ( $ template ? : 'error' , $ statusCode , $ event ) ; }
12499	public static function insertMany ( $ document , $ connection ) { if ( gettype ( $ document ) != "array" && gettype ( $ document ) != "object" ) { throw new ClusterpointException ( "\"->insert()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid document format." , 9002 ) ; } if ( gettype ( $ document ) == "object" ) { $ document_array = array ( ) ; foreach ( $ document as $ value ) { $ document_array [ ] = $ value ; } $ document = $ document_array ; } $ connection -> query = json_encode ( array_values ( $ document ) ) ; $ connection -> multiple = true ; return self :: insert ( $ connection ) ; }
7394	public function replace ( $ in ) : void { $ this -> _massageBlockInput ( $ in ) ; if ( empty ( $ in ) ) { return ; } foreach ( $ in as $ k => $ v ) { if ( $ this -> _keyExists ( $ k ) ) { if ( $ this -> { $ k } instanceof TypedAbstract ) { $ this -> { $ k } -> replace ( $ v ) ; } else { $ this -> _setByName ( $ k , $ v ) ; } } } $ this -> _checkRelatedProperties ( ) ; }
12040	public function getCurrentUser ( ) { $ this -> authenticated = false ; $ authenticate = $ this -> session -> get ( "handler" , "auth" ) ; if ( is_a ( $ authenticate , Authenticate :: class ) ) { if ( $ authenticate -> authenticated ) { $ this -> authenticated = true ; $ this -> authority = $ this -> session -> getAuthority ( ) ; return $ this -> loadObjectByURI ( $ authenticate -> get ( "user_name_id" ) , [ ] , true ) ; } } return $ this ; }
7618	public function get ( $ name ) { if ( ! isset ( $ this -> accounts [ $ name ] ) ) { throw new \ RuntimeException ( "No account found with " . $ name ) ; } return $ this -> accounts [ $ name ] ; }
7992	public function setPassword ( $ pp , $ pca , $ passwd ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ passwd ) throw new BadMethodCallException ( 'Missing parameter $passwd (Password for this pca).' ) ; $ payload = array ( 'password' => $ passwd ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
3946	private function handleMetaModelTable ( $ tableName ) { static $ tableNames ; if ( ! $ tableNames ) { $ tableNames = $ this -> factory -> collectNames ( ) ; } if ( ! in_array ( $ tableName , $ tableNames ) ) { return ; } $ this -> controller -> loadLanguageFile ( 'tl_metamodel_item' ) ; $ this -> controller -> loadDataContainer ( 'tl_metamodel_item' ) ; if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] ) ) { $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] = [ ] ; } $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] = array_replace_recursive ( ( array ) $ GLOBALS [ 'TL_DCA' ] [ 'tl_metamodel_item' ] , ( array ) $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] ) ; }
7695	function MsPowerpoint_InitSlideLst ( $ Master = false ) { if ( $ Master ) { $ RefLst = & $ this -> OpenXmlSlideMasterLst ; } else { $ RefLst = & $ this -> OpenXmlSlideLst ; } if ( $ RefLst !== false ) return $ RefLst ; $ PresFile = 'ppt/presentation.xml' ; $ prefix = ( $ Master ) ? 'slideMasters/' : 'slides/' ; $ o = $ this -> OpenXML_Rels_GetObj ( 'ppt/presentation.xml' , $ prefix ) ; $ Txt = $ this -> FileRead ( $ PresFile ) ; if ( $ Txt === false ) return false ; $ p = 0 ; $ i = 0 ; $ lst = array ( ) ; $ tag = ( $ Master ) ? 'p:sldMasterId' : 'p:sldId' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ tag , $ p ) ) { $ i ++ ; $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( $ rid === false ) { $ this -> RaiseError ( "(Init Slide List) attribute 'r:id' is missing for slide #$i in '$PresFile'." ) ; } elseif ( isset ( $ o -> TargetLst [ $ rid ] ) ) { $ f = 'ppt/' . $ o -> TargetLst [ $ rid ] ; $ lst [ ] = array ( 'file' => $ f , 'idx' => $ this -> FileGetIdx ( $ f ) , 'rid' => $ rid ) ; } else { $ this -> RaiseError ( "(Init Slide List) Slide corresponding to rid=$rid is not found in the Rels file of '$PresFile'." ) ; } $ p = $ loc -> PosEnd ; } $ RefLst = $ lst ; return $ RefLst ; }
2973	public static function wrapClosures ( & $ data , SerializerInterface $ serializer ) { if ( $ data instanceof \ Closure ) { $ reflection = new \ ReflectionFunction ( $ data ) ; if ( $ binding = $ reflection -> getClosureThis ( ) ) { self :: wrapClosures ( $ binding , $ serializer ) ; $ scope = $ reflection -> getClosureScopeClass ( ) ; $ scope = $ scope ? $ scope -> getName ( ) : 'static' ; $ data = $ data -> bindTo ( $ binding , $ scope ) ; } $ data = new SerializableClosure ( $ data , $ serializer ) ; } elseif ( is_array ( $ data ) || $ data instanceof \ stdClass || $ data instanceof \ Traversable ) { foreach ( $ data as & $ value ) { self :: wrapClosures ( $ value , $ serializer ) ; } } elseif ( is_object ( $ data ) && ! $ data instanceof \ Serializable ) { $ reflection = new \ ReflectionObject ( $ data ) ; if ( ! $ reflection -> hasMethod ( '__sleep' ) ) { foreach ( $ reflection -> getProperties ( ) as $ property ) { if ( $ property -> isPrivate ( ) || $ property -> isProtected ( ) ) { $ property -> setAccessible ( true ) ; } $ value = $ property -> getValue ( $ data ) ; self :: wrapClosures ( $ value , $ serializer ) ; $ property -> setValue ( $ data , $ value ) ; } } } }
953	public function authenticate ( AuthShop $ request ) { $ validated = $ request -> validated ( ) ; $ shopDomain = ShopifyApp :: sanitizeShopDomain ( $ validated [ 'shop' ] ) ; $ shop = ShopifyApp :: shop ( $ shopDomain ) ; $ auth = new AuthShopHandler ( $ shop ) ; $ session = new ShopSession ( $ shop ) ; if ( ! $ request -> has ( 'code' ) ) { $ authUrl = $ auth -> buildAuthUrl ( $ shop -> hasOfflineAccess ( ) ? Config :: get ( 'shopify-app.api_grant_mode' ) : ShopSession :: GRANT_OFFLINE ) ; return View :: make ( 'shopify-app::auth.fullpage_redirect' , compact ( 'authUrl' , 'shopDomain' ) ) ; } $ access = $ auth -> getAccess ( $ validated [ 'code' ] ) ; $ session -> setDomain ( $ shopDomain ) ; $ session -> setAccess ( $ access ) ; $ auth -> postProcess ( ) ; $ auth -> dispatchJobs ( $ session ) ; return $ this -> returnTo ( ) ; }
11440	public function getInfos ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> infos ) ; } else { return $ this -> infos ; } }
6522	public function isCompatibleForMerge ( Field $ other ) { if ( $ this -> name !== $ other -> name ) { return false ; } if ( $ this -> type !== $ other -> type ) { return false ; } if ( $ this -> rule !== $ other -> rule ) { return false ; } if ( $ this -> className !== $ other -> className ) { return false ; } if ( ! array_intersect ( $ this -> anyOfClassNames , $ other -> anyOfClassNames ) ) { return false ; } return true ; }
4174	public function build ( ) { $ providers = $ this -> getProviders ( ) -> search ( ) ; $ facades = $ this -> getFacades ( ) -> search ( ) ; if ( ! ConfigFile :: instance ( $ providers , $ facades ) -> make ( ) ) { throw new ErrorException ( 'Unable to register providers and facades. Please report this incident at Qafeen/Manager' ) ; } $ this -> getResources ( ) -> publish ( $ providers [ 0 ] ) ; return $ this ; }
3018	public function createPost ( $ blogName , $ data ) { $ path = $ this -> blogPath ( $ blogName , '/post' ) ; return $ this -> postRequest ( $ path , $ data , false ) ; }
3668	public function generate ( FilterUrl $ filterUrl ) { $ jumpTo = $ filterUrl -> getPage ( ) ; if ( empty ( $ jumpTo [ 'alias' ] ) ) { $ this -> addFromCurrentRequest ( $ filterUrl = $ filterUrl -> clone ( ) , [ ] ) ; $ jumpTo = $ filterUrl -> getPage ( ) ; } $ alias = $ jumpTo [ 'alias' ] ; $ parameters = $ filterUrl -> getGetParameters ( ) ; $ url = $ alias ; if ( $ filterUrl -> hasSlug ( 'auto_item' ) ) { $ url .= '/' . $ this -> encodeForAllowEncodedSlashes ( $ filterUrl -> getSlug ( 'auto_item' ) ) ; } if ( ! empty ( $ jumpTo [ 'domain' ] ) ) { $ parameters [ '_domain' ] = $ jumpTo [ 'domain' ] ; } if ( ! empty ( $ jumpTo [ 'rootUseSSL' ] ) ) { $ parameters [ '_ssl' ] = ( bool ) $ jumpTo [ 'rootUseSSL' ] ; } if ( $ filterUrl -> hasSlug ( 'language' ) ) { $ parameters [ '_locale' ] = $ filterUrl -> getSlug ( 'language' ) ; } foreach ( $ filterUrl -> getSlugParameters ( ) as $ name => $ value ) { if ( in_array ( $ name , [ 'language' , 'auto_item' ] ) ) { continue ; } $ url .= '/' . $ this -> encodeForAllowEncodedSlashes ( $ name ) . '/' . $ this -> encodeForAllowEncodedSlashes ( $ value ) ; } return $ this -> urlGenerator -> generate ( $ url , $ parameters ) ; }
949	public function sanitizeShopDomain ( $ domain ) { if ( empty ( $ domain ) ) { return ; } $ configEndDomain = Config :: get ( 'shopify-app.myshopify_domain' ) ; $ domain = strtolower ( preg_replace ( '/https?:\/\//i' , '' , trim ( $ domain ) ) ) ; if ( strpos ( $ domain , $ configEndDomain ) === false && strpos ( $ domain , '.' ) === false ) { $ domain .= ".{$configEndDomain}" ; } return parse_url ( "http://{$domain}" , PHP_URL_HOST ) ; }
11685	public function getCachePath ( ) { if ( empty ( $ this -> basePath ) ) { return false ; } $ cachePath = $ this -> basePath . DIRECTORY_SEPARATOR . 'cache' ; if ( ! is_dir ( $ cachePath ) ) { @ mkdir ( $ cachePath , 0777 , true ) ; } if ( ! is_dir ( $ cachePath ) ) { return false ; } return $ cachePath ; }
10615	public function configure ( Response $ response , \ DateTime $ last_modified , $ lifetime ) { $ request = $ this -> request_stack -> getMasterRequest ( ) ; if ( ! ( $ request instanceof Request ) ) { return $ response ; } $ this -> setPrivateCache ( $ response , $ request ) -> setLastModified ( $ response , $ last_modified ) -> setLifetime ( $ response , $ lifetime ) -> setEtag ( $ response ) ; return $ response ; }
2452	private function getLocale ( Request $ request ) : string { if ( null !== $ request -> attributes -> get ( '_locale' ) ) { return $ this -> formatLocaleId ( $ request -> attributes -> get ( '_locale' ) ) ; } return $ request -> getPreferredLanguage ( $ this -> availableLocales ) ; }
6831	protected function synchronizeWithProduct ( SupplierOrderItemInterface $ item ) { $ changed = false ; if ( null !== $ product = $ item -> getProduct ( ) ) { $ productSID = $ product -> getSubjectIdentity ( ) ; if ( $ productSID -> hasIdentity ( ) ) { $ itemSID = $ item -> getSubjectIdentity ( ) ; if ( $ itemSID -> hasIdentity ( ) ) { if ( ! $ itemSID -> equals ( $ productSID ) ) { throw new LogicException ( 'Breaking synchronization between supplier order item and supplier product is not supported.' ) ; } $ changed = false ; } else { $ itemSID -> copy ( $ productSID ) ; $ changed = true ; } } else { throw new InvalidArgumentException ( 'Supplier product subject identity is not set.' ) ; } if ( 0 == strlen ( $ item -> getDesignation ( ) ) ) { $ item -> setDesignation ( $ product -> getDesignation ( ) ) ; } if ( 0 == strlen ( $ item -> getReference ( ) ) ) { $ item -> setReference ( $ product -> getReference ( ) ) ; } if ( 0 == $ item -> getNetPrice ( ) ) { $ item -> setNetPrice ( $ product -> getNetPrice ( ) ) ; } } elseif ( $ item -> hasSubjectIdentity ( ) ) { throw new LogicException ( 'Breaking synchronization between supplier order item and supplier product is not supported.' ) ; } return $ changed ; }
9134	public function setLastPost ( $ lastPost ) { if ( $ lastPost == 0 ) { $ this -> _lastPost = "" ; } elseif ( $ lastPost !== "" and $ lastPost !== "NULL" and $ lastPost !== null ) { if ( $ lastPost instanceof DateTime ) { $ this -> _lastPost = $ lastPost ; } else { $ this -> _lastPost = new DateTime ( $ lastPost ) ; } } return $ this ; }
4861	public function pushLazy ( $ service , $ payload = null , array $ options = [ ] ) { $ manager = $ this -> getJobPluginManager ( ) ; $ serviceOptions = [ ] ; if ( is_array ( $ service ) ) { $ serviceOptions = $ service [ 'options' ] ?? $ service [ 1 ] ?? [ ] ; $ service = $ service [ 'name' ] ?? $ service [ 0 ] ?? null ; } if ( ! $ manager -> has ( $ service ) && ! class_exists ( $ service ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Service name "%s" is not a known job service or existent class' , $ service ) ) ; } $ lazyOptions = [ 'name' => $ service , 'options' => $ serviceOptions , 'content' => $ payload , ] ; $ job = $ this -> getJobPluginManager ( ) -> build ( 'lazy' , $ lazyOptions ) ; $ this -> push ( $ job , $ options ) ; }
8496	public function getFulfillmentPreview ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetFulfillmentPreviewRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetFulfillmentPreviewRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetFulfillmentPreview' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetFulfillmentPreviewResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12431	protected function generateContentTypeFilter ( $ contentType ) { $ filter = null ; if ( ! is_null ( $ contentType ) && '' != $ contentType ) { $ filter = array ( 'contentType' => $ contentType ) ; } return $ filter ; }
3073	public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = ( $ this -> getRequestParameter ( 'start' ) !== false ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( ! $ this -> getRunnerService ( ) -> isTerminated ( $ serviceContext ) ) { $ this -> endItemTimer ( $ this -> getTime ( ) ) ; $ this -> saveItemState ( ) ; } $ this -> initServiceContext ( ) ; $ this -> saveItemResponses ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> timeout ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } if ( $ start == true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
10762	public function setAlternativeAccount ( $ iban1 , $ swift1 = null , $ iban2 = null , $ swift2 = null ) { if ( $ swift1 !== null ) { $ iban1 .= '+' . $ swift1 ; } if ( $ iban2 !== null ) { if ( $ swift2 !== null ) { $ iban2 .= '+' . $ swift2 ; } $ iban1 .= ',' . $ iban2 ; } return $ this -> add ( 'ALT-ACC' , $ iban1 ) ; }
4398	protected function getTransactionReference ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ base ) { $ code = $ this -> getServiceItem ( ) -> getCode ( ) ; $ service = $ base -> getService ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT , $ code ) ; return $ service -> getAttribute ( 'TRANSACTIONID' , 'payment/omnipay' ) ; }
11801	public function hookTemplateRender ( $ templates , $ data , $ rendered , $ controller ) { $ template = reset ( $ templates ) ; if ( strpos ( $ template , '/modules/ga_report/templates/panels/' ) !== false && isset ( $ data [ 'content' ] [ 'data' ] [ 'report' ] [ 'data' ] ) && isset ( $ data [ 'content' ] [ 'data' ] [ 'handler' ] [ 'id' ] ) ) { $ handler_id = $ data [ 'content' ] [ 'data' ] [ 'handler' ] [ 'id' ] ; $ controller -> setJsSettings ( "ga_chart_$handler_id" , $ data [ 'content' ] [ 'data' ] [ 'report' ] [ 'data' ] ) ; $ controller -> setJs ( __DIR__ . "/js/handlers/$handler_id.js" ) ; $ controller -> setJs ( __DIR__ . "/js/common.js" ) ; } }
9744	public function setState ( $ state ) { if ( ! $ state ) { return $ this ; } if ( ! ( $ state instanceof State ) ) { $ state = new State ( $ state ) ; } if ( $ state -> isEmpty ( ) ) { $ this -> invalidArguments ( '10002' ) ; } return $ this -> setParameter ( 'state' , $ state ) ; }
4289	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ meta = \ array_merge ( array ( 'format' => 'raw' , 'requestId' => $ this -> requestId , ) , $ meta ) ; if ( $ meta [ 'channel' ] == $ this -> debug -> getCfg ( 'channel' ) ) { unset ( $ meta [ 'channel' ] ) ; } if ( $ meta [ 'format' ] == 'raw' ) { $ args = $ this -> crateValues ( $ args ) ; } if ( ! empty ( $ meta [ 'backtrace' ] ) ) { $ meta [ 'backtrace' ] = $ this -> crateValues ( $ meta [ 'backtrace' ] ) ; } $ this -> wamp -> publish ( $ this -> topic , array ( $ method , $ args , $ meta ) ) ; }
7642	public function getBaseUrl ( ) { if ( $ this -> credentials -> usePathStyleUri ( ) ) { return $ this -> host . '/' . $ this -> accountName ; } return $ this -> host ; }
10989	protected function _setData ( $ key , $ value ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerSet ( $ store , $ key , $ value ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ store ) ; } }
2803	public function setProxyTargetDir ( string $ proxyTargetDir ) : void { if ( ! is_dir ( $ proxyTargetDir ) ) { throw new InvalidArgumentException ( sprintf ( 'Proxy target directory "%s" does not exist!' , $ proxyTargetDir ) , 10 ) ; } if ( ! is_writable ( $ proxyTargetDir ) ) { throw new InvalidArgumentException ( sprintf ( 'Proxy target directory "%s" is not writable!' , $ proxyTargetDir ) , 20 ) ; } $ this -> proxyTargetDir = $ proxyTargetDir ; }
8662	private function convertGetFeedSubmissionList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionIdList ( ) ) { $ feedSubmissionIdList = $ request -> getFeedSubmissionIdList ( ) ; foreach ( $ feedSubmissionIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'FeedSubmissionIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
3968	protected function createAttributeInstance ( ModelInterface $ model = null ) { if ( null === $ model ) { return null ; } return $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ this -> getMetaModelByModelPid ( $ model ) ) ; }
3258	public function scopeFindByUser ( $ query , $ userId , $ statusCode = null ) { if ( ! empty ( $ status ) ) { $ query = $ query -> whereStatus ( $ status ) ; } return $ query -> whereUser ( $ userId ) -> get ( ) ; }
8651	private function convertGetReport ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReport' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportId ( ) ) { $ parameters [ 'ReportId' ] = $ request -> getReportId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
6977	protected function createAndRegisterGateway ( $ platformName , $ name , array $ config ) { $ platform = $ this -> registry -> getPlatform ( $ platformName ) ; $ gateway = $ platform -> createGateway ( $ name , $ config ) ; if ( $ gateway instanceof Shipment \ AddressResolverAwareInterface ) { $ gateway -> setAddressResolver ( $ this -> registry -> getAddressResolver ( ) ) ; } if ( $ gateway instanceof Shipment \ WeightCalculatorAwareInterface ) { $ gateway -> setWeightCalculator ( $ this -> registry -> getWeightCalculator ( ) ) ; } if ( $ gateway instanceof PersisterAwareInterface ) { $ gateway -> setPersister ( $ this -> registry -> getPersister ( ) ) ; } $ this -> gateways [ $ name ] = $ gateway ; }
5727	public function recordIsDeletedFromStage ( ) { if ( $ this -> owner -> hasMethod ( 'getIsDeletedFromStage' ) ) { return $ this -> owner -> IsDeletedFromStage ; } if ( ! $ this -> owner -> record -> checkVersioned ( ) ) { return false ; } if ( ! $ this -> owner -> record -> isInDB ( ) ) { return true ; } $ class = $ this -> owner -> record -> class ; $ stageVersion = Versioned :: get_versionnumber_by_stage ( $ class , 'Stage' , $ this -> owner -> record -> ID ) ; return ! ( $ stageVersion ) ; }
11972	protected function validateParams ( Event $ event ) { return ( $ this -> genericParamValidation ( $ event ) && $ this -> firstParamValidation ( $ event ) && $ this -> secondParamValidation ( $ event ) ) ; }
5513	public function expectMinimumCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set minimum call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_counts [ strtolower ( $ method ) ] = new MinimumCallCountExpectation ( $ method , $ count , $ message ) ; }
11514	public function getNamedParams ( string $ category = null ) : array { switch ( $ category ) { case 'attribute' : return $ this -> request -> getAttributes ( ) ; case 'query' : return $ this -> request -> getQueryParams ( ) ; case 'uploaded_files' : return $ this -> request -> getUploadedFiles ( ) ; case 'parsed_body' : { $ body = $ this -> request -> getParsedBody ( ) ; if ( ! $ body ) { return [ ] ; } if ( is_array ( $ body ) ) { return $ body ; } if ( is_object ( $ body ) ) { return get_object_vars ( $ body ) ; } } return [ ] ; case 'server' : return $ this -> request -> getServerParams ( ) ; case 'cookie' : return $ this -> request -> getCookieParams ( ) ; } return [ ] ; }
4540	public function get ( string $ key ) { $ config = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ config ) { throw new OutOfRangeException ( 'Config "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ config ) ; return $ config -> getValue ( ) ; }
12743	public function buildSlotMap ( ) { $ this -> slotmap -> reset ( ) ; foreach ( $ this -> pool as $ connectionID => $ connection ) { $ parameters = $ connection -> getParameters ( ) ; if ( ! isset ( $ parameters -> slots ) ) { continue ; } foreach ( explode ( ',' , $ parameters -> slots ) as $ slotRange ) { $ slots = explode ( '-' , $ slotRange , 2 ) ; if ( ! isset ( $ slots [ 1 ] ) ) { $ slots [ 1 ] = $ slots [ 0 ] ; } $ this -> slotmap -> setSlots ( $ slots [ 0 ] , $ slots [ 1 ] , $ connectionID ) ; } } }
8448	public function broadcastMsg ( array $ peers , $ msg ) { $ peerList = $ this -> formatPeers ( $ peers ) ; return $ this -> exec ( 'broadcast ' . $ peerList . ' ' . $ msg ) ; }
9132	protected function validate ( $ config , $ name , $ path ) { if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The definition of "%s" in "%s" must be a YAML array.' , $ name , $ path ) ) ; } if ( $ extraKeys = array_diff ( array_keys ( $ config ) , self :: $ availableKeys ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The routing file "%s" contains unsupported keys for "%s": "%s". Expected one of: "%s".' , $ path , $ name , implode ( '", "' , $ extraKeys ) , implode ( '", "' , self :: $ availableKeys ) ) ) ; } if ( isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The business rule file "%s" must not specify both the "resource" key and the "expression" key for "%s". Choose between an import and a rule definition.' , $ path , $ name ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'type' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "type" key for the rule definition "%s" in "%s" is unsupported. It is only available for imports in combination with the "resource" key.' , $ name , $ path ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && ! isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'You must define an "expression" for the rule "%s" in file "%s".' , $ name , $ path ) ) ; } if ( isset ( $ config [ 'tags' ] ) && ! is_array ( $ config [ 'tags' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } elseif ( isset ( $ config [ 'tags' ] ) ) { foreach ( $ config [ 'tags' ] as $ tag ) { if ( ! isset ( $ tag [ 'name' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } } } }
4117	public function isWithinCachedBlock ( Mage_Core_Block_Abstract $ block ) { $ step = $ block ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { if ( ! is_null ( $ step -> getCacheLifetime ( ) ) ) { return true ; } $ step = $ step -> getParentBlock ( ) ; } return false ; }
10039	public function trySimpleXMLLoadString ( $ pFilename ) { try { $ xml = simplexml_load_string ( $ this -> securityScan ( file_get_contents ( $ pFilename ) ) , 'SimpleXMLElement' , Settings :: getLibXmlLoaderOptions ( ) ) ; } catch ( \ Exception $ e ) { throw new Exception ( 'Cannot load invalid XML file: ' . $ pFilename , 0 , $ e ) ; } return $ xml ; }
623	protected function createModels ( $ rows ) { if ( $ this -> asArray ) { return $ rows ; } else { $ models = [ ] ; $ class = $ this -> modelClass ; foreach ( $ rows as $ row ) { $ model = $ class :: instantiate ( $ row ) ; $ modelClass = get_class ( $ model ) ; $ modelClass :: populateRecord ( $ model , $ row ) ; $ models [ ] = $ model ; } return $ models ; } }
6174	protected function delete ( $ path , $ file ) { return $ this -> driver -> delete ( $ this -> root . $ path , $ file ) ; }
8644	public function getReportRequestCount ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestCountRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestCountRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestCount ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestCountResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11468	public function index ( ResponseRequest $ request ) { $ view = $ this -> response -> theme -> listView ( ) ; if ( $ this -> response -> typeIs ( 'json' ) ) { $ function = camel_case ( 'get-' . $ view ) ; return $ this -> repository -> setPresenter ( \ Litecms \ Forum \ Repositories \ Presenter \ ResponsePresenter :: class ) -> $ function ( ) ; } $ responses = $ this -> repository -> paginate ( ) ; return $ this -> response -> title ( trans ( 'forum::response.names' ) ) -> view ( 'forum::response.index' , true ) -> data ( compact ( 'responses' ) ) -> output ( ) ; }
2654	public function hasSnippet ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/snippet/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET , '' , false , null , false ) ; if ( $ result == false ) { return false ; } return true ; }
3000	public function reset ( $ key = null ) { if ( $ key ) { $ key = ucfirst ( $ key ) ; $ this -> smtp -> clear ( $ key ) ; if ( isset ( $ this -> recipients [ $ key ] ) ) unset ( $ this -> recipients [ $ key ] ) ; } else { $ this -> recipients = array ( ) ; $ this -> initSMTP ( ) ; } }
207	public static function confirm ( $ message , $ default = false ) { while ( true ) { static :: stdout ( $ message . ' (yes|no) [' . ( $ default ? 'yes' : 'no' ) . ']:' ) ; $ input = trim ( static :: stdin ( ) ) ; if ( empty ( $ input ) ) { return $ default ; } if ( ! strcasecmp ( $ input , 'y' ) || ! strcasecmp ( $ input , 'yes' ) ) { return true ; } if ( ! strcasecmp ( $ input , 'n' ) || ! strcasecmp ( $ input , 'no' ) ) { return false ; } } }
1641	protected function setupSessionTracking ( Client $ client , $ endpoint , $ events ) { $ client -> setAutoCaptureSessions ( true ) ; if ( ! is_null ( $ endpoint ) ) { $ client -> setSessionEndpoint ( $ endpoint ) ; } $ sessionTracker = $ client -> getSessionTracker ( ) ; $ sessionStorage = function ( $ session = null ) { if ( is_null ( $ session ) ) { return session ( 'bugsnag-session' , [ ] ) ; } else { session ( [ 'bugsnag-session' => $ session ] ) ; } } ; $ sessionTracker -> setSessionFunction ( $ sessionStorage ) ; $ cache = $ this -> app -> cache ; $ genericStorage = function ( $ key , $ value = null ) use ( $ cache ) { if ( is_null ( $ value ) ) { return $ cache -> get ( $ key , null ) ; } else { $ cache -> put ( $ key , $ value , 60 ) ; } } ; $ sessionTracker -> setStorageFunction ( $ genericStorage ) ; }
1778	public static function optionChecked ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' checked' : '' ; }
2587	protected function loadCreatePnr ( PnrCreatePnrOptions $ params ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; $ tattooCounter = 0 ; if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; }
869	private function createProcessForSource ( $ source ) { if ( null === $ this -> temporaryFile ) { $ this -> temporaryFile = tempnam ( '.' , 'cs_fixer_tmp_' ) ; $ this -> fileRemoval -> observe ( $ this -> temporaryFile ) ; } if ( false === @ file_put_contents ( $ this -> temporaryFile , $ source ) ) { throw new IOException ( sprintf ( 'Failed to write file "%s".' , $ this -> temporaryFile ) , 0 , null , $ this -> temporaryFile ) ; } return $ this -> createProcessForFile ( $ this -> temporaryFile ) ; }
9245	private function parseDynamicGroup ( $ group ) { $ regex = $ group [ 'regex' ] ; $ parts = explode ( '|' , $ regex ) ; $ data = array ( ) ; foreach ( $ group [ 'routeMap' ] as $ matchIndex => $ routeData ) { if ( ! is_array ( $ routeData [ 0 ] ) || ! isset ( $ routeData [ 0 ] [ 'name' ] ) || ! isset ( $ parts [ $ matchIndex - 1 ] ) ) { continue ; } $ parameters = $ routeData [ 1 ] ; $ path = $ parts [ $ matchIndex - 1 ] ; foreach ( $ parameters as $ parameter ) { $ path = $ this -> replaceOnce ( '([^/]+)' , '{' . $ parameter . '}' , $ path ) ; } $ path = rtrim ( $ path , '()$~' ) ; $ data [ $ routeData [ 0 ] [ 'name' ] ] = array ( 'path' => $ path , 'params' => $ parameters , ) ; } return $ data ; }
12158	public function getObjectLevel ( ) { if ( $ this -> isPrimaryType ) { return 1 ; } $ parents = $ this -> collectorItem -> parents ; if ( ! empty ( $ parents ) ) { $ maxLevel = 1 ; foreach ( $ parents as $ rel ) { if ( get_class ( $ rel -> parent ) === get_class ( $ this ) ) { continue ; } $ newLevel = $ rel -> parent -> objectLevel + 1 ; if ( $ newLevel > $ maxLevel ) { $ maxLevel = $ newLevel ; } } return $ maxLevel ; } return 1 ; }
2551	protected function loadRequestCreator ( $ requestCreator , $ params , $ libIdentifier , $ originatorOffice , $ mesVer ) { if ( $ requestCreator instanceof RequestCreatorInterface ) { $ newRequestCreator = $ requestCreator ; } else { $ params -> originatorOfficeId = $ originatorOffice ; $ params -> messagesAndVersions = $ mesVer ; $ newRequestCreator = RequestCreatorFactory :: createRequestCreator ( $ params , $ libIdentifier ) ; } return $ newRequestCreator ; }
11995	public function getCatalog ( array $ catalogData ) { $ skuIndex = [ ] ; $ slugIndex = [ ] ; $ index = 1 ; $ products = [ ] ; foreach ( $ catalogData as $ catalogItem ) { try { $ product = $ this -> productMapper -> getProduct ( $ catalogItem ) ; $ sku = strtolower ( $ product -> getSku ( ) -> __toString ( ) ) ; if ( array_key_exists ( $ sku , $ skuIndex ) ) { throw new CatalogException ( sprintf ( "Cannot add a second product with the SKU '%s' to the catalog" , $ sku ) ) ; } $ skuIndex [ $ sku ] = 1 ; $ slug = strtolower ( $ product -> getSlug ( ) -> __toString ( ) ) ; if ( array_key_exists ( $ slug , $ slugIndex ) ) { throw new CatalogException ( sprintf ( "Cannot add a second product with the Slug '%s' to the catalog" , $ slug ) ) ; } $ slugIndex [ $ slug ] = 1 ; $ products [ ] = $ product ; } catch ( \ Exception $ productException ) { throw new CatalogException ( sprintf ( "Cannot convert catalog item %s into a product: %s" , $ index , $ productException -> getMessage ( ) ) , $ productException ) ; } $ index ++ ; } return new Catalog ( $ products ) ; }
7448	function encrypt ( $ data , $ password ) { $ salt = openssl_random_pseudo_bytes ( 16 ) ; $ salted = '' ; $ dx = '' ; while ( strlen ( $ salted ) < 48 ) { $ dx = hash ( 'sha256' , $ dx . $ password . $ salt , true ) ; $ salted .= $ dx ; } $ key = substr ( $ salted , 0 , 32 ) ; $ iv = substr ( $ salted , 32 , 16 ) ; $ encrypted_data = openssl_encrypt ( $ data , 'AES-256-CBC' , $ key , true , $ iv ) ; return base64_encode ( $ salt . $ encrypted_data ) ; }
4850	public function prepare ( $ value ) { $ importer = $ this -> getVariably ( ) -> get ( 'importer' ) ; $ table = $ importer -> getCurrentTable ( ) ; if ( ! isset ( $ this -> counter [ $ table ] ) ) { $ db = $ importer -> getDb ( ) ; $ counter = $ db -> fetchOne ( 'SELECT MAX(DISTINCT counter) AS counter FROM ' . $ table ) ; $ this -> counter [ $ table ] = $ counter [ 'counter' ] + 1 ; } return $ this -> counter [ $ table ] ; }
3031	public function resumeSession ( AssessmentTestSession $ session ) { $ deliveryExecutionState = $ this -> getSessionState ( $ session ) ; if ( $ deliveryExecutionState === DeliveryExecution :: STATE_PAUSED ) { $ this -> updateTimeReference ( $ session ) ; $ this -> getDeliveryExecution ( $ session ) -> setState ( DeliveryExecution :: STATE_ACTIVE ) ; } }
6766	public function onAddressChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } if ( $ this -> handleAddressChange ( $ sale ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ sale , false ) ; $ this -> scheduleContentChangeEvent ( $ sale ) ; } }
332	public function madd ( $ items , $ duration = 0 , $ dependency = null ) { return $ this -> multiAdd ( $ items , $ duration , $ dependency ) ; }
4822	public function set ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> addField ( $ name , $ value ) ; } else { $ this -> row [ $ name ] = $ value ; } $ this -> informChanges ( ) ; }
5886	public function resolve ( $ tsdns ) { $ this -> getTransport ( ) -> sendLine ( $ tsdns ) ; $ repl = $ this -> getTransport ( ) -> readLine ( ) ; $ this -> getTransport ( ) -> disconnect ( ) ; if ( $ repl -> section ( ":" , 0 ) -> toInt ( ) == 404 ) { throw new Ts3Exception ( "unable to resolve TSDNS hostname (" . $ tsdns . ")" ) ; } Signal :: getInstance ( ) -> emit ( "tsdnsResolved" , $ tsdns , $ repl ) ; return $ repl ; }
10624	private static function checkAndMoveFile ( $ sourceMigrationFile , $ appMigrationDir , IOInterface $ io ) { $ explodedPath = explode ( '/' , $ sourceMigrationFile ) ; $ filename = array_pop ( $ explodedPath ) ; if ( file_exists ( $ appMigrationDir . '/' . $ filename ) ) { if ( md5_file ( $ appMigrationDir . '/' . $ filename ) === md5_file ( $ sourceMigrationFile ) ) { if ( $ io -> isVeryVerbose ( ) ) { $ io -> write ( "<info>found that $sourceMigrationFile is equal" . " to $appMigrationDir/$filename</info>" ) ; } $ doTheMove = false ; } else { $ doTheMove = $ io -> askConfirmation ( "<question>The file \n" . " \t$sourceMigrationFile\n has the same name than the previous " . "migrated file located at \n\t$appMigrationDir/$filename\n " . "but the content is not equal.\n Overwrite the file ?[y,N]" , false ) ; } } else { $ doTheMove = true ; } if ( $ doTheMove ) { $ fs = new Filesystem ( ) ; $ fs -> copy ( $ sourceMigrationFile , $ appMigrationDir . '/' . $ filename ) ; $ io -> write ( "<info>Importing '$filename' migration file</info>" ) ; return true ; } return false ; }
169	public static function unlink ( $ path ) { $ isWindows = DIRECTORY_SEPARATOR === '\\' ; if ( ! $ isWindows ) { return unlink ( $ path ) ; } if ( is_link ( $ path ) && is_dir ( $ path ) ) { return rmdir ( $ path ) ; } try { return unlink ( $ path ) ; } catch ( ErrorException $ e ) { if ( function_exists ( 'exec' ) && file_exists ( $ path ) ) { exec ( 'DEL /F/Q ' . escapeshellarg ( $ path ) ) ; return ! file_exists ( $ path ) ; } return false ; } }
9263	private function addNamedRoute ( $ name , $ httpMethod , $ route , $ handler ) { if ( ! ( $ this -> dataGenerator instanceof NamedDataGeneratorInterface ) ) { throw new \ RuntimeException ( 'The injected generator does not support named routes' ) ; } $ routeData = $ this -> routeParser -> parse ( $ route ) ; foreach ( $ routeData as $ routeDatum ) { $ this -> dataGenerator -> addNamedRoute ( $ name , $ httpMethod , $ routeDatum , $ handler ) ; } }
7334	private function getSubjectIdentityMapper ( EntityManagerInterface $ em ) { if ( null === $ this -> subjectIdentityMapper ) { $ this -> subjectIdentityMapper = new EmbeddableMapper ( $ em , SubjectIdentity :: class ) ; } return $ this -> subjectIdentityMapper ; }
6431	public function getUserProfile ( ) { $ facebook = $ this -> getFacebookObject ( ) ; $ response = $ facebook -> get ( '/me' , $ this -> accesstoken ) ; $ me = $ response -> getGraphUser ( ) ; return array ( 'userid' => $ me -> getId ( ) , 'name' => $ me -> getName ( ) , 'email' => $ me -> getField ( 'email' ) , 'imageurl' => 'https://graph.facebook.com/' . $ me -> getId ( ) . '/picture?type=large' ) ; }
7372	public function updateAction ( Request $ request ) { $ user = $ this -> getUser ( ) ; $ form = $ this -> createForm ( ProfileType :: class , $ user ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; try { $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return new JsonReloadResponse ( ) ; } catch ( \ Exception $ e ) { $ form -> addError ( new FormError ( 'Could not save changes. If the problem persists, please contact support.' ) ) ; } } return new JsonErrorResponse ( $ form ) ; }
10889	public function parse ( ) { list ( $ opt_str , $ long_opts , $ mapping ) = $ this -> getOptString ( ) ; $ opts = \ getopt ( $ opt_str , $ long_opts ) ; $ options = $ this -> mapOptions ( $ opts , $ mapping ) ; return new Dictionary ( $ options ) ; }
509	public function actionIndex ( $ command = null ) { if ( $ command !== null ) { $ result = Yii :: $ app -> createController ( $ command ) ; if ( $ result === false ) { $ name = $ this -> ansiFormat ( $ command , Console :: FG_YELLOW ) ; throw new Exception ( "No help for unknown command \"$name\"." ) ; } list ( $ controller , $ actionID ) = $ result ; $ actions = $ this -> getActions ( $ controller ) ; if ( $ actionID !== '' || count ( $ actions ) === 1 && $ actions [ 0 ] === $ controller -> defaultAction ) { $ this -> getSubCommandHelp ( $ controller , $ actionID ) ; } else { $ this -> getCommandHelp ( $ controller ) ; } } else { $ this -> getDefaultHelp ( ) ; } }
7858	private function registerPipelineRepository ( ) { $ abstract = 'Cerbero\Workflow\Repositories\PipelineRepositoryInterface' ; $ this -> app -> bind ( $ abstract , function ( $ app ) { return new YamlPipelineRepository ( new SymfonyYamlParser , new \ Illuminate \ Filesystem \ Filesystem , config ( 'workflow.path' ) ) ; } ) ; }
12163	public function getFormSegment ( $ primaryModel = null , $ settings = [ ] ) { if ( empty ( $ primaryModel ) ) { return false ; } return $ primaryModel -> form ( $ settings ) ; }
4506	public function create ( OrganizationPersona $ persona , Parameters $ parameters = null ) : OrganizationPersona { $ options = [ ] ; $ options [ 'json' ] = ( array ) static :: toObject ( $ persona ) ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; } $ object = $ this -> execute ( 'POST' , static :: RESOURCE_LIST , $ options ) ; $ persona = static :: toModel ( $ object ) ; return $ persona ; }
7562	protected function parse_pipe ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_PREFIX ) ; } else { return ( $ this -> token = self :: TOK_PIPE ) ; } }
5066	public function init ( string $ url = null ) : void { $ this -> ch = curl_init ( $ url ) ; CurlObjectLookup :: add ( $ this ) ; }
4489	public function registerDevice ( string $ deviceId , string $ platform , ? string $ userData = null ) : string { if ( ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } try { $ args = [ 'PlatformApplicationArn' => $ this -> arns [ $ platform ] , 'Token' => $ deviceId , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ; if ( $ userData ) { $ args [ 'CustomUserData' ] = $ userData ; } $ res = $ this -> sns -> createPlatformEndpoint ( $ args ) ; } catch ( SnsException $ e ) { preg_match ( '/Endpoint (.+?) already/' , $ e -> getMessage ( ) , $ matches ) ; if ( isset ( $ matches [ 1 ] ) ) { $ this -> sns -> setEndpointAttributes ( [ 'EndpointArn' => $ matches [ 1 ] , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ) ; return $ matches [ 1 ] ; } else { throw $ e ; } } return $ res [ 'EndpointArn' ] ; }
359	function checkUploadMaxFileSize ( $ min = null , $ max = null ) { $ postMaxSize = ini_get ( 'post_max_size' ) ; $ uploadMaxFileSize = ini_get ( 'upload_max_filesize' ) ; if ( $ min !== null ) { $ minCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ min , '>=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ min , '>=' ) ; } else { $ minCheckResult = true ; } if ( $ max !== null ) { $ maxCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ max , '<=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ max , '<=' ) ; } else { $ maxCheckResult = true ; } return ( $ minCheckResult && $ maxCheckResult ) ; }
5792	private function setConstraints ( ) { $ q = new QueryBuilder ( "SELECT ccu.column_name, tc.constraint_type FROM INFORMATION_SCHEMA.constraint_column_usage ccu JOIN information_schema.table_constraints tc ON ccu.constraint_name = tc.constraint_name WHERE tc.table_name = ccu.table_name AND ccu.table_name = $1" , $ this -> tableName ) ; $ qResult = $ q -> execute ( ) ; while ( $ qRow = pg_fetch_assoc ( $ qResult ) ) { switch ( $ qRow [ 'constraint_type' ] ) { case 'PRIMARY KEY' : $ this -> primaryKeyColumnName = $ qRow [ 'column_name' ] ; break ; case 'UNIQUE' : $ this -> uniqueColumnNames [ ] = $ qRow [ 'column_name' ] ; } } }
10640	protected function createUniquePath ( UploadedFile $ file ) { $ dir = 'mmmb/' . mb_substr ( mb_strtolower ( ( string ) $ file -> getClientOriginalName ( ) ) , 0 , 2 ) ; $ filename = str_replace ( array ( ' ' , $ file -> getClientOriginalExtension ( ) ) , '-' , $ file -> getClientOriginalName ( ) ) ; $ name = mb_strtolower ( $ filename . uniqid ( ) . '.' . $ file -> getClientOriginalExtension ( ) ) ; return array ( 'dir' => $ dir , 'filename' => $ name , 'path' => $ dir . '/' . $ name , ) ; }
847	public function getNextTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , 1 , $ tokens , $ caseSensitive ) ; }
11894	public function encrypt ( $ data ) { if ( $ this -> iv === null ) { $ dataEncrypted = mcrypt_encrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode ) ; } else { $ dataEncrypted = mcrypt_encrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode , $ this -> iv ) ; } return bin2hex ( $ dataEncrypted ) ; }
10166	private function readBIFF8CellAddressB ( $ cellAddressStructure , $ baseCell = 'A1' ) { list ( $ baseCol , $ baseRow ) = Coordinate :: coordinateFromString ( $ baseCell ) ; $ baseCol = Coordinate :: columnIndexFromString ( $ baseCol ) - 1 ; $ rowIndex = self :: getUInt2d ( $ cellAddressStructure , 0 ) ; $ row = self :: getUInt2d ( $ cellAddressStructure , 0 ) + 1 ; if ( ! ( 0x4000 & self :: getUInt2d ( $ cellAddressStructure , 2 ) ) ) { $ colIndex = 0x00FF & self :: getUInt2d ( $ cellAddressStructure , 2 ) ; $ column = Coordinate :: stringFromColumnIndex ( $ colIndex + 1 ) ; $ column = '$' . $ column ; } else { $ relativeColIndex = 0x00FF & self :: getInt2d ( $ cellAddressStructure , 2 ) ; $ colIndex = $ baseCol + $ relativeColIndex ; $ colIndex = ( $ colIndex < 256 ) ? $ colIndex : $ colIndex - 256 ; $ colIndex = ( $ colIndex >= 0 ) ? $ colIndex : $ colIndex + 256 ; $ column = Coordinate :: stringFromColumnIndex ( $ colIndex + 1 ) ; } if ( ! ( 0x8000 & self :: getUInt2d ( $ cellAddressStructure , 2 ) ) ) { $ row = '$' . $ row ; } else { $ rowIndex = ( $ rowIndex <= 32767 ) ? $ rowIndex : $ rowIndex - 65536 ; $ row = $ baseRow + $ rowIndex ; } return $ column . $ row ; }
3135	public function getItemState ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; $ state = is_null ( $ userUri ) ? null : $ serviceService -> get ( $ userUri , $ stateId ) ; if ( $ state ) { $ state = json_decode ( $ state , true ) ; if ( is_null ( $ state ) ) { throw new \ common_exception_InconsistentData ( 'Unable to decode the state for the item ' . $ itemRef ) ; } } return $ state ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
6455	public function textual ( ) { $ this -> restrictElements ( [ 'textarea' => [ ] , 'input' => [ ] , ] ) ; self :: debug ( [ 'Expected: %s' , 'Value: %s' , 'Tag: %s' , ] , [ $ this -> expected , $ this -> value , $ this -> tag , ] ) ; $ this -> assert ( trim ( $ this -> expected ) === $ this -> value ) ; }
6599	protected function getReturnType ( array $ lines ) { foreach ( $ lines as $ line ) { if ( strpos ( $ line , '@return' ) === 0 ) { $ type = trim ( str_replace ( '@return' , '' , $ line ) ) ; $ type = str_replace ( '$this' , 'self' , $ type ) ; $ type = explode ( '|' , $ type ) ; return $ type ; } } return [ ] ; }
447	private function attachBehaviorInternal ( $ name , $ behavior ) { if ( ! ( $ behavior instanceof Behavior ) ) { $ behavior = Yii :: createObject ( $ behavior ) ; } if ( is_int ( $ name ) ) { $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ ] = $ behavior ; } else { if ( isset ( $ this -> _behaviors [ $ name ] ) ) { $ this -> _behaviors [ $ name ] -> detach ( ) ; } $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ $ name ] = $ behavior ; } return $ behavior ; }
677	public function getLinks ( $ absolute = false ) { $ currentPage = $ this -> getPage ( ) ; $ pageCount = $ this -> getPageCount ( ) ; $ links = [ Link :: REL_SELF => $ this -> createUrl ( $ currentPage , null , $ absolute ) , ] ; if ( $ currentPage > 0 ) { $ links [ self :: LINK_FIRST ] = $ this -> createUrl ( 0 , null , $ absolute ) ; $ links [ self :: LINK_PREV ] = $ this -> createUrl ( $ currentPage - 1 , null , $ absolute ) ; } if ( $ currentPage < $ pageCount - 1 ) { $ links [ self :: LINK_NEXT ] = $ this -> createUrl ( $ currentPage + 1 , null , $ absolute ) ; $ links [ self :: LINK_LAST ] = $ this -> createUrl ( $ pageCount - 1 , null , $ absolute ) ; } return $ links ; }
10559	private function setupTranslateLog ( ) { $ logger = Logger :: getLogger ( 'Wedeto.I18n.Translator.Translator' ) ; $ writer = new TranslationLogger ( $ this -> app -> pathConfig -> log . '/translate-%s-%s.pot' ) ; $ logger -> addLogWriter ( $ writer ) ; }
7661	function SetWordWrap ( ) { if ( $ this -> WordWrap < 1 ) return ; switch ( $ this -> message_type ) { case "alt" : case "alt_attachments" : $ this -> AltBody = $ this -> WrapText ( $ this -> AltBody , $ this -> WordWrap ) ; break ; default : $ this -> Body = $ this -> WrapText ( $ this -> Body , $ this -> WordWrap ) ; break ; } }
12214	public function run ( $ route ) { if ( ! is_array ( $ route ) ) { $ this -> makeResponse ( $ route ) ; } $ viewSegments = explode ( '.' , $ route [ 'view' ] ) ; $ method = $ route [ 'method' ] ; Setup :: toDefine ( 'TEMPLATES_PATH' , APPS_ROOT . DS . $ this -> appName . DS . 'Templates' . DS ) ; Setup :: toDefine ( 'STATIC_PATH' , APPS_ROOT . DS . 'static' . DS ) ; $ viewPath = '' ; $ view = $ viewSegments [ 0 ] ; if ( count ( $ viewSegments ) > 1 ) { $ view = $ viewSegments [ count ( $ viewSegments ) - 1 ] ; array_pop ( $ viewSegments ) ; $ viewPath = implode ( '\\' , $ viewSegments ) ; $ viewPath .= '\\' ; } if ( $ view instanceof \ ForeverPHP \ View \ View ) { throw new ViewException ( "La vista ($view) no hereda de View." ) ; } if ( Settings :: getInstance ( ) -> get ( 'usingNamespaces' ) ) { $ view = '\\Apps\\' . $ this -> appName . '\\Views\\' . $ viewPath . $ view ; } $ v = new $ view ( ) ; $ returnValue = $ v -> $ method ( ) ; $ this -> makeResponse ( $ returnValue ) ; }
11926	public function setAutoloadDir ( $ dir ) { if ( ! is_string ( $ dir ) || empty ( $ dir ) ) { throw new InvalidArgumentException ( sprintf ( 'Invalid directory for autoload of configuration provided; ' . 'must be a non-empty string, "%s" received.' , is_object ( $ dir ) ? get_class ( $ dir ) : gettype ( $ dir ) ) ) ; } $ dir = Normalizer :: path ( $ dir ) ; if ( ! file_exists ( $ dir ) || ! is_dir ( $ dir ) ) { throw new InvalidArgumentException ( sprintf ( 'The directory "%s", specified for autoload of configurations, ' . 'does not exists.' , $ dir ) ) ; } $ this -> autoloadDir = $ dir ; }
11408	public function onBootstrap ( MvcEvent $ e ) { if ( ! $ e -> getRequest ( ) instanceof HttpRequest ) { return ; } $ app = $ e -> getApplication ( ) ; $ services = $ app -> getServiceManager ( ) ; $ eventManager = $ app -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; $ sharedEventManager -> attach ( UserService :: class , 'register' , function ( $ e ) use ( $ services ) { $ user = $ e -> getParam ( 'user' ) ; if ( $ user instanceof RoleableInterface && $ services -> has ( AuthorizationModuleOptions :: class ) ) { $ config = $ services -> get ( PermissionsModuleOptions :: class ) ; $ roleClass = $ config -> getRoleEntityClass ( ) ; $ mapper = $ services -> get ( 'MapperManager' ) -> get ( $ roleClass ) ; if ( $ defaultRole = $ mapper -> find ( $ config -> getAuthenticatedRole ( ) ) ) { $ user -> addRole ( $ defaultRole ) ; } } } , 100 ) ; }
10664	public function withRequest ( RequestInterface $ request ) { $ object = clone $ this ; $ object -> request = $ request ; $ object -> method = $ request -> getMethod ( ) ; return $ object ; }
12758	public static function getNew ( ) { $ class = new MediaLink ; $ medialink = get_class_vars ( get_class ( $ class ) ) ; foreach ( $ medialink as $ name => $ default ) : $ class :: set ( $ name , null ) ; $ class :: set ( "objectType" , "medialink" ) ; endforeach ; return $ class ; }
10275	public static function getTextWidthPixelsExact ( $ text , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font , $ rotation = 0 ) { if ( ! function_exists ( 'imagettfbbox' ) ) { throw new PhpSpreadsheetException ( 'GD library needs to be enabled' ) ; } $ fontFile = self :: getTrueTypeFontFileFromFont ( $ font ) ; $ textBox = imagettfbbox ( $ font -> getSize ( ) , $ rotation , $ fontFile , $ text ) ; $ lowerLeftCornerX = $ textBox [ 0 ] ; $ lowerRightCornerX = $ textBox [ 2 ] ; $ upperRightCornerX = $ textBox [ 4 ] ; $ upperLeftCornerX = $ textBox [ 6 ] ; $ textWidth = max ( $ lowerRightCornerX - $ upperLeftCornerX , $ upperRightCornerX - $ lowerLeftCornerX ) ; return $ textWidth ; }
10864	protected function generateHashes ( ) : array { $ dirLength = strlen ( $ this -> dir ) ; foreach ( $ this -> createIterator ( ) as $ file ) { if ( ! $ file -> isFile ( ) ) { continue ; } $ realpath = $ file -> getRealPath ( ) ; $ path = $ file -> getPath ( ) . DIRECTORY_SEPARATOR . $ file -> getFilename ( ) ; if ( $ realpath !== $ path ) { continue ; } $ path = substr ( $ realpath , $ dirLength ) ; $ lowerPath = strtolower ( $ path ) ; if ( isset ( $ this -> hashes [ $ lowerPath ] ) ) { $ message = "duplicate file encountered: $path ($lowerPath)" ; throw new \ RuntimeException ( $ message ) ; } $ this -> hashes [ $ lowerPath ] = sha1_file ( $ realpath ) ; } ksort ( $ this -> hashes ) ; return $ this -> hashes ; }
5314	protected function generate ( ) { $ this -> reset ( ) ; foreach ( range ( 1 , $ this -> getCount ( ) ) as $ counter ) { $ this -> codes [ ] = $ this -> generateBlocks ( ) ; } return $ this -> codes ; }
3622	public function enableHumidifier ( $ enabled , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'target_humidity_enabled' => ( ( boolean ) $ enabled ) ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
5731	public function getLeagues ( array $ filter = [ 'areas' => '' ] ) { $ leagues = $ this -> run ( "v2/competitions" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagues -> competitions ) ; }
3034	public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ data = $ this -> getTreeResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; return $ this -> formatTreeData ( $ data ) ; }
3352	public function getUserAgentHeader ( ) { $ userAgentName = $ this -> getUserAgentName ( ) ; if ( $ userAgentName ) { return $ userAgentName ; } $ userAgent = sprintf ( '%s/%s/%s (PHP/%s.%s.%s' , $ this -> getLibraryName ( ) , $ this -> getVersion ( ) , $ this -> getPublicKey ( ) , PHP_MAJOR_VERSION , PHP_MINOR_VERSION , PHP_RELEASE_VERSION ) ; $ framework = $ this -> getFramework ( ) ; if ( $ framework ) { $ userAgent .= '; ' . $ framework ; } $ extension = $ this -> getExtension ( ) ; if ( $ extension ) { $ userAgent .= '; ' . $ extension ; } $ userAgent .= ')' ; return $ userAgent ; }
10395	protected function getShopIds ( ) { $ shopIds = [ ] ; try { $ shops = $ this -> container -> getParameter ( 'ongr_connections.shops' ) ; } catch ( InvalidArgumentException $ e ) { $ shops = [ ] ; } foreach ( $ shops as $ shop ) { $ shopIds [ ] = $ shop [ 'shop_id' ] ; } return $ shopIds ; }
551	public function actionFlush ( ) { $ cachesInput = func_get_args ( ) ; if ( empty ( $ cachesInput ) ) { throw new Exception ( 'You should specify cache components names' ) ; } $ caches = $ this -> findCaches ( $ cachesInput ) ; $ cachesInfo = [ ] ; $ foundCaches = array_keys ( $ caches ) ; $ notFoundCaches = array_diff ( $ cachesInput , array_keys ( $ caches ) ) ; if ( $ notFoundCaches ) { $ this -> notifyNotFoundCaches ( $ notFoundCaches ) ; } if ( ! $ foundCaches ) { $ this -> notifyNoCachesFound ( ) ; return ExitCode :: OK ; } if ( ! $ this -> confirmFlush ( $ foundCaches ) ) { return ExitCode :: OK ; } foreach ( $ caches as $ name => $ class ) { $ cachesInfo [ ] = [ 'name' => $ name , 'class' => $ class , 'is_flushed' => $ this -> canBeFlushed ( $ class ) ? Yii :: $ app -> get ( $ name ) -> flush ( ) : false , ] ; } $ this -> notifyFlushed ( $ cachesInfo ) ; }
7267	public function has ( $ forClass , $ forColumn = null ) { $ refTable = static :: tableName ( ) ; $ forTable = $ forClass :: tableName ( ) ; $ refColumn = static :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( static :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select F.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and R.$refColumn = :id " , [ "id" => $ this -> $ refColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ forModel = new $ forClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ forModel -> $ col = $ forModel -> decodeValue ( $ val , $ col ) ; return $ forModel ; }
8539	public function setGetMyPriceForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMyPriceForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6393	public static function run ( callable $ tryBlock , array $ exceptions = [ ] , callable $ finallyBlock = null ) : TryTo { try { return Success :: of ( Functions :: call ( $ tryBlock ) ) ; } catch ( Exception $ e ) { if ( count ( $ exceptions ) === 0 ) { return Failure :: of ( $ e ) ; } $ error = FluentIterable :: of ( $ exceptions ) -> filter ( Predicates :: assignableFrom ( get_class ( $ e ) ) ) -> first ( ) ; if ( $ error -> isPresent ( ) ) { return Failure :: of ( $ e ) ; } throw $ e ; } finally { if ( $ finallyBlock !== null ) { Functions :: call ( $ finallyBlock ) ; } } }
3664	private function getValueFromSource ( $ source , $ valueName , $ arguments ) { switch ( strtolower ( $ source ) ) { case 'get' : return $ this -> container -> get ( Input :: class ) -> get ( $ valueName ) ; case 'post' : return $ this -> container -> get ( Input :: class ) -> post ( $ valueName ) ; case 'cookie' : return $ this -> container -> get ( Input :: class ) -> cookie ( $ valueName ) ; case 'session' : return $ this -> container -> get ( Session :: class ) -> get ( $ valueName ) ; case 'filter' : if ( is_array ( $ this -> filterParameters ) ) { if ( array_key_exists ( $ valueName , $ this -> filterParameters ) ) { return $ this -> filterParameters [ $ valueName ] ; } return null ; } break ; case 'container' : @ trigger_error ( 'Getting filter values from the service container is deprecated, the container will get removed.' , E_USER_DEPRECATED ) ; return $ this -> getValueFromServiceContainer ( $ valueName , $ arguments ) ; default : } return null ; }
6860	private static function horner ( $ x , $ c ) { if ( count ( $ c ) == 0 ) throw new InvalidArgumentException ( 'No coefficients were provided' ) ; $ i = count ( $ c ) - 1 ; $ y = $ c [ $ i ] ; while ( $ i > 0 ) { $ i -- ; $ y = $ y * $ x + $ c [ $ i ] ; } return $ y ; }
1793	private function getHostAndPort ( string $ domain ) : array { if ( false !== strpos ( $ domain , ':' ) ) { return explode ( ':' , $ domain , 2 ) ; } return [ $ domain , null ] ; }
10679	private function _sklStd ( $ slovo , $ ii , $ zivotne ) { if ( $ ii < 0 || $ ii > \ count ( $ this -> vzor ) ) { $ this -> astrTvar [ 0 ] = '!!!???' ; } $ count = \ count ( $ this -> v0 ) ; for ( $ jj = 0 ; $ jj < $ count ; $ jj ++ ) { if ( $ this -> _isShoda ( $ this -> v0 [ $ jj ] , $ slovo ) >= 0 ) { return null ; } } $ this -> astrTvar [ 0 ] = $ this -> vzor [ $ ii ] [ 0 ] ; for ( $ jj = 1 ; $ jj < 15 ; $ jj ++ ) { $ this -> astrTvar [ $ jj ] = $ this -> _sklon ( $ jj , $ ii , $ slovo , $ zivotne ) ; } $ count = \ count ( $ this -> v3 ) ; for ( $ jj = 0 ; $ jj < $ count ; $ jj ++ ) { if ( $ this -> _isShoda ( $ this -> v3 [ $ jj ] , $ slovo ) >= 0 ) { return ; } } }
1956	public function styleSheetLink ( Contao \ DataContainer $ dc ) { return ' <a href="contao/main.php?do=themes&amp;table=tl_style_sheet&amp;id=' . $ dc -> activeRecord -> pid . '&amp;popup=1&amp;nb=1&amp;rt=' . REQUEST_TOKEN . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_styles' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . Contao \ StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_styles' ] ) ) . '\',\'url\':this.href});return false">' . Contao \ Image :: getHtml ( 'edit.svg' ) . '</a>' ; }
8035	public function isMemberOf ( $ group ) { foreach ( $ this -> attributes [ 'member_of' ] as $ groups ) { if ( preg_match ( '/^CN=' . $ group . '/' , $ groups ) ) { return true ; } } return false ; }
5025	protected function renderMarkup ( FileUpload $ element ) { $ markup = '<div class="%s" id="%s-dropzone"> %s __input__</div>' ; return sprintf ( $ markup , $ this -> getDropZoneClass ( $ element ) , $ element -> getAttribute ( 'id' ) , $ this -> renderFileList ( $ element ) ) ; }
4103	public function search ( $ query , array $ options = array ( ) ) { $ start = microtime ( true ) ; $ result = $ this -> transport -> search ( $ query , $ options ) ; $ result [ 'time' ] = microtime ( true ) - $ start ; return $ result ; }
5474	protected function createAction ( $ action , $ page ) { if ( ( $ action === '' ) || ( $ action === false ) ) { return $ page -> expandUrl ( $ page -> getUrl ( ) ) ; } return $ page -> expandUrl ( new SimpleUrl ( $ action ) ) ; }
12514	public static function create ( $ path = '' , $ mode = 0777 ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mkdir ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_CREATING' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
3255	public function scopeWhereUser ( $ query , $ userId ) { return $ query -> join ( Config :: get ( 'shop.order_table' ) , Config :: get ( 'shop.order_table' ) . '.id' , '=' , Config :: get ( 'shop.transaction_table' ) . '.order_id' ) -> where ( Config :: get ( 'shop.order_table' ) . '.user_id' , $ userId ) ; }
11096	public static function sendHipChatMessage ( $ room , $ token , $ text , $ notify = true , $ format = 'text' ) { $ session = curl_init ( ) ; curl_setopt ( $ session , CURLOPT_URL , 'https://api.hipchat.com/v2/room/' . $ room . '/notification?auth_token=' . $ token ) ; curl_setopt ( $ session , CURLOPT_POST , 1 ) ; curl_setopt ( $ session , CURLOPT_POSTFIELDS , http_build_query ( [ 'message' => $ text , 'message_format' => $ format , 'notify' => $ notify , ] ) ) ; curl_setopt ( $ session , CURLOPT_RETURNTRANSFER , true ) ; curl_exec ( $ session ) ; curl_close ( $ session ) ; }
1178	protected function getValidatorInstance ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ factory = $ this -> app -> make ( ValidationFactory :: class ) ; $ data = $ this -> getValidationData ( $ rules , $ customAttributes ) ; $ validator = $ factory -> make ( $ data , $ rules , $ messages , $ customAttributes ) ; $ validator -> addCustomAttributes ( $ customAttributes ) ; return $ validator ; }
6018	public function addMediaToDeploymentSite ( $ id , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment/' . $ id . '/media' , $ parameters ) ; return $ result ; }
5891	public static function permissionType ( $ type ) { if ( $ type == TeamSpeak3 :: PERM_TYPE_SERVERGROUP ) { return "Server Group" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CLIENT ) { return "Client" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CHANNEL ) { return "Channel" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CHANNELGROUP ) { return "Channel Group" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CHANNELCLIENT ) { return "Channel Client" ; } return "Unknown" ; }
7900	public function upload ( $ file , Closure $ callback = null ) { $ uploadedFile = $ this -> runUpload ( $ file ) ; if ( ! $ uploadedFile ) { return false ; } if ( $ callback ) { $ callback ( $ uploadedFile ) ; } return true ; }
8217	public static function getRefererQueryParam ( $ url , $ key ) { if ( ! $ url ) { return null ; } $ query = [ ] ; parse_str ( parse_url ( $ url , PHP_URL_QUERY ) , $ query ) ; if ( isset ( $ query [ $ key ] ) ) { return $ query [ $ key ] ; } return null ; }
10533	public function last ( ) { if ( is_array ( $ this -> items ) && count ( $ this -> items ) > 0 ) { return end ( $ this -> items ) ; } return null ; }
11386	public function exec ( $ calcId = null ) { if ( is_null ( $ calcId ) ) { $ calcId = $ this -> queryGetCalcId -> exec ( ) ; } if ( ! isset ( $ this -> cachedIds [ $ calcId ] ) ) { $ ids = [ ] ; $ where = \ Praxigento \ BonusHybrid \ Repo \ Data \ Registry \ SignUpDebit :: A_CALC_REF . '=' . ( int ) $ calcId ; $ rs = $ this -> daoRegistry -> get ( $ where ) ; foreach ( $ rs as $ one ) { $ ids [ ] = $ one -> getCustomerRef ( ) ; } $ this -> cachedIds [ $ calcId ] = $ ids ; } return $ this -> cachedIds [ $ calcId ] ; }
6129	protected function getCorpusTitle ( ) { if ( $ this -> currObj instanceof Server ) { return "ID: " . $ this -> currObj -> getId ( ) . " | Clients: " . $ this -> currObj -> clientCount ( ) . "/" . $ this -> currObj [ "virtualserver_maxclients" ] . " | Uptime: " . Convert :: seconds ( $ this -> currObj [ "virtualserver_uptime" ] ) ; } elseif ( $ this -> currObj instanceof Channel && ! $ this -> currObj -> isSpacer ( ) ) { return "ID: " . $ this -> currObj -> getId ( ) . " | Codec: " . Convert :: codec ( $ this -> currObj [ "channel_codec" ] ) . " | Quality: " . $ this -> currObj [ "channel_codec_quality" ] ; } elseif ( $ this -> currObj instanceof Client ) { return "ID: " . $ this -> currObj -> getId ( ) . " | Version: " . Convert :: versionShort ( $ this -> currObj [ "client_version" ] ) . " | Platform: " . $ this -> currObj [ "client_platform" ] ; } elseif ( $ this -> currObj instanceof Servergroup || $ this -> currObj instanceof Channelgroup ) { return "ID: " . $ this -> currObj -> getId ( ) . " | Type: " . Convert :: groupType ( $ this -> currObj [ "type" ] ) . " (" . ( $ this -> currObj [ "savedb" ] ? "Permanent" : "Temporary" ) . ")" ; } return "" ; }
9709	private function writeCodepage ( ) { $ record = 0x0042 ; $ length = 0x0002 ; $ cv = $ this -> codepage ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cv ) ; $ this -> append ( $ header . $ data ) ; }
4591	public function setOwnerUuid ( ? string $ ownerUuid ) { if ( null !== $ ownerUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ ownerUuid ) ) { throw new InvalidArgumentException ( 'Owner uuid is not valid.' ) ; } } $ this -> ownerUuid = $ ownerUuid ; return $ this ; }
2205	public static function findPost ( $ strKey ) { if ( isset ( $ _POST [ $ strKey ] ) ) { return $ _POST [ $ strKey ] ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getMasterRequest ( ) ; if ( $ request === null || ! $ request -> hasPreviousSession ( ) ) { return null ; } if ( isset ( $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ) ) { return ( $ strKey == 'FORM_SUBMIT' ) ? preg_replace ( '/^auto_/i' , '' , $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ) : $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ; } return null ; }
10926	private function renderCell ( $ columnNumber , $ value , $ filler , $ style = '' ) { $ output = [ ] ; $ width = $ this -> getWidth ( $ columnNumber ) ; $ output [ ] = $ filler ; while ( $ this -> length ( $ value ) < $ width ) { $ value .= $ filler ; } $ output [ ] = Style :: applyStyle ( $ value , $ style ) ; $ output [ ] = $ filler ; return implode ( '' , $ output ) ; }
8264	protected function onOAuthError ( $ errorCode ) { $ errorCode = strlen ( $ errorCode > 100 ) ? substr ( $ errorCode , 0 , 100 ) : $ errorCode ; $ this -> logger -> notice ( "OAuth2 error response: code {code}, provider {provider}" , array ( "code" => $ errorCode , "provider" => get_class ( $ this -> provider ) , ) ) ; $ this -> session -> addFlash ( "error" , "The provider returned an error ($errorCode)" ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
2250	protected static function replaceOldBePaths ( $ strContext ) { $ router = System :: getContainer ( ) -> get ( 'router' ) ; $ generate = function ( $ route ) use ( $ router ) { return substr ( $ router -> generate ( $ route ) , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; } ; $ arrMapper = array ( 'contao/confirm.php' => $ generate ( 'contao_backend_confirm' ) , 'contao/file.php' => $ generate ( 'contao_backend_file' ) , 'contao/help.php' => $ generate ( 'contao_backend_help' ) , 'contao/index.php' => $ generate ( 'contao_backend_login' ) , 'contao/main.php' => $ generate ( 'contao_backend' ) , 'contao/page.php' => $ generate ( 'contao_backend_page' ) , 'contao/password.php' => $ generate ( 'contao_backend_password' ) , 'contao/popup.php' => $ generate ( 'contao_backend_popup' ) , 'contao/preview.php' => $ generate ( 'contao_backend_preview' ) , 'contao/switch.php' => $ generate ( 'contao_backend_switch' ) ) ; return str_replace ( array_keys ( $ arrMapper ) , $ arrMapper , $ strContext ) ; }
6715	protected function getFormatFromUri ( $ requestedUri ) { $ uriParts = explode ( '?' , $ requestedUri , 2 ) ; $ uriWithoutGet = reset ( $ uriParts ) ; $ uriAndFormat = explode ( '.' , $ uriWithoutGet ) ; if ( count ( $ uriAndFormat ) >= 2 ) { return end ( $ uriAndFormat ) ; } return null ; }
7807	protected function closingBalance ( $ text ) { if ( $ line = $ this -> getLine ( '62M' , $ text ) ) { return $ this -> balance ( $ this -> reader -> createClosingBalance ( ) , $ line ) ; } }
4145	protected function validateCredentials ( $ credentials ) { $ credentials = array_filter ( $ credentials ) ; $ keys = array_keys ( $ credentials ) ; $ diff = array_diff ( $ this -> requiredCredentials , $ keys ) ; if ( ! empty ( $ diff ) ) { throw new MissingCredentialsException ( 'Missing Credentials: ' . implode ( $ diff , ', ' ) ) ; } unset ( $ credentials , $ keys , $ diff ) ; }
11997	static public function generateDoctrine2 ( \ Doctrine \ ORM \ EntityManager $ entityManager , $ entityName , $ field , $ length = 16 ) { do { $ generate = self :: generate ( $ length ) ; } while ( self :: doctrine2Query ( $ entityManager , $ entityName , $ field , $ generate ) ) ; return $ generate ; }
1465	public static function decode ( $ content , $ assoc = false , $ depth = 512 , $ options = 0 ) { $ decoded = \ json_decode ( $ content , $ assoc , $ depth , $ options ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw InvalidJsonException :: create ( ) ; } if ( ! $ assoc && ! is_object ( $ decoded ) ) { throw new DocumentRequiredException ( ) ; } if ( $ assoc && ! is_array ( $ decoded ) ) { throw new InvalidJsonException ( null , 'JSON is not an array.' ) ; } return $ decoded ; }
10877	public function isValidForgotten ( string $ hash ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { return $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ; } return false ; }
11798	public function setHtml ( $ html = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } $ this -> html .= Helper :: formatText ( $ html , 'ascii' ) ; return $ this ; }
9309	public function show ( $ id , $ params = [ ] ) { $ data = [ 'id' => $ id ] + $ params ; return $ this -> query ( __FUNCTION__ , $ data ) ; }
9778	function writable ( ) : self { if ( ! $ this -> hasFlag ( 'directory' ) && ! $ this -> hasFlag ( 'file' ) ) throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , isWritable ( ) ) ; }
2523	protected function makeMessageOptions ( array $ incoming , $ endSession = false ) { $ options = [ 'endSession' => $ endSession , 'returnXml' => $ this -> returnResultXml ] ; if ( array_key_exists ( 'endSession' , $ incoming ) ) { $ options [ 'endSession' ] = $ incoming [ 'endSession' ] ; } if ( array_key_exists ( 'returnXml' , $ incoming ) ) { $ options [ 'returnXml' ] = $ incoming [ 'returnXml' ] ; } return $ options ; }
5895	public function listImageTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/images' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new ImageTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12468	public function getStream ( $ mediaId ) { $ response = $ this -> getHttp ( ) -> get ( self :: API_GET , [ 'media_id' => $ mediaId ] ) ; $ response -> getBody ( ) -> rewind ( ) ; $ body = $ response -> getBody ( ) -> getContents ( ) ; $ json = json_decode ( $ body , true ) ; if ( JSON_ERROR_NONE === json_last_error ( ) ) { $ this -> checkAndThrow ( $ json ) ; } return $ body ; }
9279	public function save ( JobEntity $ job ) { $ query = null ; if ( ( int ) $ job -> getId ( ) == 0 ) { $ query = $ this -> sql -> insert ( ) ; $ query -> values ( $ job -> getArrayCopy ( ) ) ; } else { $ query = $ this -> sql -> update ( ) ; $ query -> set ( $ job -> getArrayCopy ( ) ) ; $ query -> where ( array ( 'id' => $ job -> getId ( ) ) ) ; } $ stmt = $ this -> sql -> prepareStatementForSqlObject ( $ query ) ; $ res = $ stmt -> execute ( ) ; if ( ( int ) $ job -> getId ( ) == 0 ) { $ job -> setId ( ( int ) $ res -> getGeneratedValue ( ) ) ; } return $ job ; }
3627	protected function getDeviceNetworkInfo ( $ serial_number = NULL ) { $ this -> prepareForGet ( ) ; $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ connection_info = $ this -> last_status -> track -> { $ serial_number } ; return ( object ) array ( 'online' => $ connection_info -> online , 'last_connection' => date ( DATETIME_FORMAT , $ connection_info -> last_connection / 1000 ) , 'last_connection_UTC' => gmdate ( DATETIME_FORMAT , $ connection_info -> last_connection / 1000 ) , 'wan_ip' => @ $ connection_info -> last_ip , 'local_ip' => $ this -> last_status -> device -> { $ serial_number } -> local_ip , 'mac_address' => $ this -> last_status -> device -> { $ serial_number } -> mac_address ) ; }
4275	public function stream_lock ( $ operation ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ flock ( $ this -> handle , $ operation ) ; self :: register ( ) ; return $ success ; }
8196	public function collectDir ( $ dir , $ ext = '.twig' ) { $ iterator = new RegexIterator ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ dir ) , RecursiveIteratorIterator :: LEAVES_ONLY ) , '{' . preg_quote ( $ ext ) . '$}' ) ; return $ this -> collect ( new Twig_Util_TemplateDirIterator ( $ iterator ) ) ; }
11448	public function actionOne ( $ option = null ) { $ fixtures = Yii :: createObject ( Fixtures :: className ( ) ) ; $ option = Question :: displayWithQuit ( 'Select operation' , [ 'Export' , 'Import' ] , $ option ) ; if ( $ option == 'e' ) { $ table = Enter :: display ( 'Enter table name for export' ) ; $ tables = $ fixtures -> export ( [ $ table ] ) ; Output :: items ( $ tables , 'Exported tables' ) ; } elseif ( $ option == 'i' ) { $ table = Enter :: display ( 'Enter table name for import' ) ; $ tables = $ fixtures -> import ( [ $ table ] ) ; Output :: items ( $ tables , 'Imported tables' ) ; } }
5171	private function getAvailableRatios ( ) : array { return [ self :: RATIO_SQUARE , self :: RATIO_RECTANGLE , self :: RATIO_HEADLINE , self :: RATIO_VERTICAL , self :: RATIO_COVER , ] ; }
8187	public function hasBlock ( $ name , array $ context = null , array $ blocks = array ( ) ) { if ( null === $ context ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is internal and should never be called; calling it directly is deprecated since version 1.28 and won\'t be possible anymore in 2.0.' , E_USER_DEPRECATED ) ; return isset ( $ this -> blocks [ ( string ) $ name ] ) ; } if ( isset ( $ blocks [ $ name ] ) ) { return $ blocks [ $ name ] [ 0 ] instanceof self ; } if ( isset ( $ this -> blocks [ $ name ] ) ) { return true ; } if ( false !== $ parent = $ this -> getParent ( $ context ) ) { return $ parent -> hasBlock ( $ name , $ context ) ; } return false ; }
2218	public function getFields ( ) { $ arrFields = $ GLOBALS [ 'TL_FFL' ] ; foreach ( array_keys ( $ arrFields ) as $ key ) { $ arrFields [ $ key ] = $ GLOBALS [ 'TL_LANG' ] [ 'FFL' ] [ $ key ] [ 0 ] ; } return $ arrFields ; }
10430	protected function createPipelines ( ContainerBuilder $ container , array $ config ) { foreach ( $ config [ 'pipelines' ] as $ pipelineName => $ pipelineConfig ) { if ( ! isset ( $ pipelineConfig [ 'shop' ] ) ) { $ pipelineConfig [ 'shop' ] = $ container -> getParameter ( 'ongr_connections.active_shop' ) ; } $ serviceConfig = $ this -> prepareServiceConfigs ( $ container , $ pipelineConfig , $ pipelineName ) ; $ this -> createServices ( $ container , $ pipelineConfig [ 'provide_sources' ] , $ serviceConfig , "data_sync.{$pipelineName}.source" , 'onSource' ) ; $ this -> createServices ( $ container , $ pipelineConfig [ 'provide_consumers' ] , $ serviceConfig , "data_sync.{$pipelineName}.consume" , 'onConsume' ) ; foreach ( $ pipelineConfig [ 'types' ] as $ type => $ typeConfig ) { $ typeServiceConfig = $ this -> prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) ; $ serviceList = $ this -> getServiceList ( $ pipelineName , $ type ) ; foreach ( $ serviceList as $ name => $ service ) { $ this -> createServices ( $ container , array_merge ( $ pipelineConfig [ $ name ] , $ typeConfig [ $ name ] ) , $ typeServiceConfig , $ service [ 'tag' ] , $ service [ 'method' ] ) ; } } } }
10265	public function getPerson ( $ state_code = null ) { $ state_code = ! empty ( $ state_code ) ? $ state_code : $ this -> getState ( ) -> code ; $ person = new Entities \ Person ; $ person -> guid = $ this -> getGuid ( ) ; $ person -> unique_hash = $ this -> getUniqueHash ( ) ; $ person -> name = $ this -> getFullName ( ) ; if ( rand ( 1 , 100 ) % 5 == 0 ) { $ person -> company = $ this -> getCompanyName ( $ person -> name -> last ) ; } else { $ person -> company = $ this -> getCompanyName ( ) ; } $ person -> address = $ this -> getAddress ( $ state_code ) ; $ person -> address2 = $ this -> getAddress ( $ state_code , $ person -> address -> zip ) ; $ person -> internet = $ this -> getInternet ( $ person -> name , $ person -> company ) ; $ person -> phone = new stdclass ( ) ; $ person -> phone -> home = $ this -> getPhone ( $ state_code , $ person -> address -> zip ) ; $ person -> phone -> mobile = $ this -> getPhone ( $ state_code , $ person -> address -> zip ) ; $ person -> phone -> work = $ this -> getPhone ( $ state_code , $ person -> address -> zip ) ; $ person -> ssn = $ this -> getSsn ( $ state_code ) ; $ person -> dln = $ this -> getDln ( $ state_code ) ; $ person -> dob = $ this -> getBirthDate ( ) ; $ person -> credit_card = $ this -> getCreditCard ( ) ; $ person -> bank_account = $ this -> getBank ( ) ; return $ person ; }
6321	public function addConstraint ( ConstraintInterface $ constraint ) { $ constraint -> setTable ( $ this ) ; $ this -> constraints [ ] = $ constraint ; return $ this ; }
529	public function actionPackage ( array $ what ) { $ this -> validateWhat ( $ what , [ 'app' ] ) ; $ versions = $ this -> getCurrentVersions ( $ what ) ; $ this -> stdout ( "You are about to generate packages for the following things:\n\n" ) ; foreach ( $ what as $ ext ) { if ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( substr ( $ ext , 4 ) , Console :: FG_RED ) ; $ this -> stdout ( ' application version ' ) ; } elseif ( $ ext === 'framework' ) { $ this -> stdout ( ' - Yii Framework version ' ) ; } else { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( $ ext , Console :: FG_RED ) ; $ this -> stdout ( ' extension version ' ) ; } $ this -> stdout ( $ versions [ $ ext ] , Console :: BOLD ) ; $ this -> stdout ( "\n" ) ; } $ this -> stdout ( "\n" ) ; $ packagePath = "{$this->basePath}/packages" ; $ this -> stdout ( "Packages will be stored in $packagePath\n\n" ) ; if ( ! $ this -> confirm ( 'Continue?' , false ) ) { $ this -> stdout ( "Canceled.\n" ) ; return 1 ; } foreach ( $ what as $ ext ) { if ( $ ext === 'framework' ) { throw new Exception ( 'Can not package framework.' ) ; } elseif ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> packageApplication ( substr ( $ ext , 4 ) , $ versions [ $ ext ] , $ packagePath ) ; } else { throw new Exception ( 'Can not package extension.' ) ; } } $ this -> stdout ( "\ndone. verify the versions composer installed above and push it to github!\n\n" ) ; return 0 ; }
1928	protected function validator ( $ varInput ) { foreach ( $ varInput as $ k => $ v ) { if ( $ k != 'unit' ) { $ varInput [ $ k ] = parent :: validator ( $ v ) ; } } return $ varInput ; }
3812	protected function transformConditions ( $ conditions ) { $ sorted = array ( ) ; $ byPid = array ( ) ; foreach ( $ conditions as $ i => $ condition ) { $ sorted [ $ condition [ 'id' ] ] = $ conditions [ $ i ] ; $ byPid [ $ condition [ 'pid' ] ] [ ] = $ condition [ 'id' ] ; } $ instances = array ( ) ; foreach ( $ sorted as $ id => $ condition ) { $ instances [ $ id ] = $ this -> transformCondition ( $ condition ) ; } foreach ( $ byPid as $ pid => $ ids ) { foreach ( $ ids as $ id ) { $ settingId = $ sorted [ $ id ] [ 'settingId' ] ; if ( ! isset ( $ this -> conditions [ $ settingId ] ) ) { $ this -> conditions [ $ settingId ] = new PropertyConditionChain ( ) ; } $ result = $ this -> conditions [ $ settingId ] ; $ condition = $ instances [ $ id ] ; $ parent = ( $ pid == 0 ) ? $ result : $ instances [ $ pid ] ; if ( $ parent instanceof ConditionChainInterface ) { $ parent -> addCondition ( $ condition ) ; } elseif ( $ parent instanceof NotCondition ) { $ parent -> setCondition ( $ condition ) ; } } } }
12236	public function insertPI ( $ target , $ data = null , $ mode = 'before' ) { $ tmp = dom_import_simplexml ( $ this ) ; $ doc = $ tmp -> ownerDocument ; if ( isset ( $ data ) ) { if ( is_array ( $ data ) ) { $ str = '' ; foreach ( $ data as $ k => $ v ) { $ str .= $ k . '="' . htmlspecialchars ( $ v ) . '" ' ; } $ data = substr ( $ str , 0 , - 1 ) ; } else { $ data = ( string ) $ data ; } $ pi = $ doc -> createProcessingInstruction ( $ target , $ data ) ; } else { $ pi = $ doc -> createProcessingInstruction ( $ target ) ; } if ( $ pi !== false ) { $ this -> insertNode ( $ tmp , $ pi , $ mode ) ; } return $ this ; }
8261	protected function saveAfterLogin ( Request $ httpRequest ) { $ referer = $ httpRequest -> headers -> get ( "referer" , null , true ) ; $ afterLogin = Utils :: getRefererQueryParam ( $ referer , "afterLogin" ) ; if ( $ afterLogin && Utils :: isValidPageId ( $ afterLogin ) ) { $ this -> session -> set ( "afterLogin" , $ afterLogin ) ; } }
4448	public function put ( string $ className , array $ data , ? string $ jid = null , ? int $ delay = null , ? int $ retries = null , ? int $ priority = null , ? array $ tags = null , ? array $ depends = null ) { try { $ jid = $ jid ? : str_replace ( '-' , '' , Uuid :: uuid4 ( ) -> toString ( ) ) ; } catch ( \ Exception $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } $ data = new JobData ( $ data ) ; $ this -> getEventsManager ( ) -> fire ( new QueueEvent \ BeforeEnqueue ( $ this , $ jid , $ data , $ className ) ) ; if ( ! $ putData = json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ) { throw new RuntimeException ( sprintf ( 'Unable to encode payload to put the described job "%s" to the "%s" queue.' , $ jid , $ this -> name ) ) ; } $ jid = $ this -> client -> put ( '' , $ this -> name , $ jid , $ className , $ putData , is_null ( $ delay ) ? 0 : $ delay , 'priority' , is_null ( $ priority ) ? 0 : $ priority , 'tags' , json_encode ( $ tags ? : [ ] , JSON_UNESCAPED_SLASHES ) , 'retries' , is_null ( $ retries ) ? 5 : $ retries , 'depends' , json_encode ( $ depends ? : [ ] , JSON_UNESCAPED_SLASHES ) ) ; $ this -> getEventsManager ( ) -> fire ( new QueueEvent \ AfterEnqueue ( $ this , $ jid , $ data -> toArray ( ) , $ className ) ) ; return $ jid ; }
2032	public static function findFirstActiveByMemberGroups ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objPage = $ objRegistry -> fetch ( 'tl_page' , $ objResult -> id ) ) { return $ objPage ; } return new static ( $ objResult ) ; }
6258	public function authorizeByControllerAndAction ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; extract ( $ this -> getControllerNameAndAction ( $ request ) ) ; $ actionMap = $ this -> getActionMap ( ) ; if ( isset ( $ actionMap [ $ name ] [ '*' ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ '*' ] ) ) { return true ; } } if ( isset ( $ actionMap [ $ name ] [ $ action ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ $ action ] ) ) { return true ; } } if ( $ this -> config ( 'undefinedActionsAreAllowed' ) === true ) { return true ; } return false ; }
1168	protected function setRemoteValidation ( $ attribute , $ validateAll = false ) { $ validator = $ this -> validator ; $ rules = $ validator -> getRules ( ) ; $ rules = isset ( $ rules [ $ attribute ] ) ? $ rules [ $ attribute ] : [ ] ; if ( in_array ( 'no_js_validation' , $ rules ) ) { $ validator -> setRules ( [ $ attribute => [ ] ] ) ; return ; } if ( ! $ validateAll ) { $ rules = $ this -> purgeNonRemoteRules ( $ rules , $ validator ) ; } $ validator -> setRules ( [ $ attribute => $ rules ] ) ; }
2238	private function handlePrependLocale ( array $ extensionConfigs , ContainerBuilder $ container ) : array { if ( ! $ container -> hasParameter ( 'prepend_locale' ) ) { return $ extensionConfigs ; } foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'prepend_locale' ] ) ) { return $ extensionConfigs ; } } @ trigger_error ( 'Defining the "prepend_locale" parameter in the parameters.yml file has been deprecated and will no longer work in Contao 5.0. Define the "contao.prepend_locale" parameter in the config.yml file instead.' , E_USER_DEPRECATED ) ; $ extensionConfigs [ ] = [ 'prepend_locale' => '%prepend_locale%' , ] ; return $ extensionConfigs ; }
8424	public function generate ( Request $ request ) { if ( count ( $ request -> getArgs ( ) ) != 1 ) { echo 'Wrong arguments.' . PHP_EOL . 'Usage : db/generate mapping_name' . PHP_EOL ; } else { $ mapping = $ request -> getArgs ( ) [ 0 ] ; $ schema = Schema :: getSchema ( $ mapping ) ; $ schema -> generateModels ( ) ; } }
4137	protected function processHeaders ( $ headers ) { $ out = array ( ) ; $ headers = explode ( "\r\n" , trim ( $ headers ) ) ; foreach ( $ headers as $ header ) { if ( strpos ( $ header , ':' ) !== false ) { $ tmp = explode ( ':' , $ header ) ; $ out [ reset ( $ tmp ) ] = end ( $ tmp ) ; } else { if ( ! isset ( $ out [ 'http-code' ] ) ) { $ out [ 'http-code' ] = $ header ; } } } unset ( $ headers , $ header , $ tmp ) ; return $ out ; }
7295	public function send_mail ( $ to , $ subject = '' , $ message = '' , $ headers = array ( ) , $ attachments = array ( ) ) { if ( $ this -> options [ 'static_options' ] [ 'mail_to_chunking' ] [ 'chunking' ] === TRUE ) { $ send_next_group = array ( ) ; if ( array_key_exists ( 'send_next_group' , $ this -> options [ 'static_options' ] ) ) { $ object_id = $ this -> options [ 'static_options' ] [ 'object' ] [ 'id' ] ; $ send_next_group = $ this -> options [ 'static_options' ] [ 'send_next_group' ] [ $ object_id ] ; } if ( $ this -> options [ 'send_by_bcc' ] ) { $ headers [ 'Bcc' ] = $ this -> get_mail_to_chunk ( $ headers [ 'Bcc' ] , $ send_next_group ) ; } else { $ to = $ this -> get_mail_to_chunk ( $ to , $ send_next_group ) ; } } foreach ( $ headers as $ k => $ v ) { $ headers [ ] = $ k . ': ' . $ v ; unset ( $ headers [ $ k ] ) ; } return wp_mail ( $ to , $ subject , $ message , $ headers , $ attachments ) ; }
4272	public function stream_close ( ) { if ( ! $ this -> handle ) { return ; } self :: restorePrev ( ) ; \ fclose ( $ this -> handle ) ; $ this -> handle = null ; self :: register ( ) ; }
3286	public function onBootstrap ( EventInterface $ e ) { $ app = $ e -> getApplication ( ) ; $ container = $ app -> getServiceManager ( ) ; $ config = $ container -> get ( 'Configuration' ) ; $ env = $ container -> get ( Environment :: class ) ; $ name = static :: MODULE_NAME ; $ options = $ envOptions = empty ( $ config [ $ name ] ) ? [ ] : $ config [ $ name ] ; $ extensions = empty ( $ options [ 'extensions' ] ) ? [ ] : $ options [ 'extensions' ] ; $ renderer = $ container -> get ( TwigRenderer :: class ) ; foreach ( $ extensions as $ extension ) { if ( empty ( $ extension ) ) { continue ; } elseif ( is_string ( $ extension ) ) { if ( $ container -> has ( $ extension ) ) { $ extension = $ container -> get ( $ extension ) ; } else { $ extension = new $ extension ( $ container , $ renderer ) ; } } elseif ( ! is_object ( $ extension ) ) { throw new InvalidArgumentException ( 'Extensions should be a string or object.' ) ; } if ( ! $ env -> hasExtension ( get_class ( $ extension ) ) ) { $ env -> addExtension ( $ extension ) ; } } return ; }
7786	public function createStatement ( AccountInterface $ account , $ number ) { return $ this -> createObject ( $ this -> statementClass , 'Jejik\MT940\StatementInterface' , array ( $ account , $ number ) ) ; }
9487	private function installModules ( ) { $ this -> frame ( 'Installing the modules' ) ; $ this -> line ( '' ) ; foreach ( $ this -> config ( ) -> get ( 'arcanesoft.foundation.modules.commands.install' , [ ] ) as $ command ) { $ this -> call ( $ command ) ; } $ this -> call ( 'db:seed' , [ '--class' => DatabaseSeeder :: class ] ) ; $ this -> line ( '' ) ; $ this -> comment ( 'Modules installed !' ) ; $ this -> line ( '' ) ; }
4490	public function createTopic ( string $ name ) : string { $ res = $ this -> sns -> createTopic ( [ 'Name' => $ name , ] ) ; return $ res [ 'TopicArn' ] ; }
6117	public function serverGetByUid ( $ uid ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_unique_identifier" ] == $ uid ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
5295	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputDirectory = realpath ( $ input -> getArgument ( 'output-directory' ) ) ; if ( $ outputDirectory === false || ! file_exists ( $ outputDirectory ) || ! is_dir ( $ outputDirectory ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'output-directory' ) . '" is no directory' ) ; } $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing SVG files to "' . $ outputDirectory . '" ...' ) ; $ generator -> saveGlyphsToDir ( $ outputDirectory ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created SVG files successfully</success>' ) ; }
604	protected function substring ( $ length , $ caseSensitive = true , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + $ length > $ this -> length ) { return '' ; } $ cacheKey = $ offset . ',' . $ length ; if ( ! isset ( $ this -> _substrings [ $ cacheKey . ',1' ] ) ) { $ this -> _substrings [ $ cacheKey . ',1' ] = mb_substr ( $ this -> sql , $ offset , $ length , 'UTF-8' ) ; } if ( ! $ caseSensitive && ! isset ( $ this -> _substrings [ $ cacheKey . ',0' ] ) ) { $ this -> _substrings [ $ cacheKey . ',0' ] = mb_strtoupper ( $ this -> _substrings [ $ cacheKey . ',1' ] , 'UTF-8' ) ; } return $ this -> _substrings [ $ cacheKey . ',' . ( int ) $ caseSensitive ] ; }
4642	public function getProjectName ( $ projectPath ) { $ project = basename ( realpath ( $ projectPath ) ) ; $ project = Transliterator :: transliterate ( $ project , '-' ) ; return $ project ; }
9244	private function __loadConfigFiles ( ) { $ additionalConfigs = $ this -> config ( 'additionalConfigFiles' ) ; foreach ( $ additionalConfigs as $ additionalConfig ) { Configure :: load ( $ additionalConfig ) ; } }
10096	protected function processSize ( $ size ) { if ( $ size === null ) { return $ size ; } $ size = ( int ) $ size ; if ( $ size <= 0 ) { throw new InvalidArgumentException ( 'Size has to be larger than 0' ) ; } return ( int ) $ size ; }
6179	private function loadAllColumnsSchema ( ) { $ schema = $ this -> tableSchema [ 'fields' ] ; foreach ( $ this -> request [ 'leftJoin' ] as $ value ) { $ schemaTable = $ this -> schema -> getSchemaTable ( $ value [ 'table' ] ) ; $ schema = array_merge ( $ schema , $ schemaTable [ 'fields' ] ) ; } foreach ( $ this -> request [ 'rightJoin' ] as $ value ) { $ schemaTable = $ this -> schema -> getSchemaTable ( $ value [ 'table' ] ) ; $ schema = array_merge ( $ schema , $ schemaTable [ 'fields' ] ) ; } $ this -> request [ 'allColumnsSchema' ] = $ schema ; }
1192	private function addCustomAttributes ( array $ attributes , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ attributes as $ attribute ) { $ required = ! empty ( $ attribute [ 3 ] ) ? true : false ; $ onElement = $ attribute [ 0 ] ; $ attrName = $ required ? $ attribute [ 1 ] . '*' : $ attribute [ 1 ] ; $ validValues = $ attribute [ 2 ] ; $ definition -> addAttribute ( $ onElement , $ attrName , $ validValues ) ; } return $ definition ; }
8709	protected function qualifyColumns ( $ columns ) { foreach ( $ columns as & $ column ) { if ( ! in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { continue ; } $ primary = $ this -> qualifyTranslationColumn ( $ column ) ; $ fallback = $ this -> qualifyTranslationColumn ( $ column , true ) ; if ( $ this -> model -> shouldFallback ( ) ) { $ column = new Expression ( $ this -> compileIfNull ( $ primary , $ fallback , $ column ) ) ; } else { $ column = $ primary ; } } return $ columns ; }
10354	protected function getEventName ( ) { $ chunks = explode ( '\\' , get_class ( $ this ) ) ; $ name = $ chunks [ count ( $ chunks ) - 2 ] ; return strtolower ( $ name ) ; }
1177	public function make ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , $ selector = null ) { $ validator = $ this -> getValidatorInstance ( $ rules , $ messages , $ customAttributes ) ; return $ this -> validator ( $ validator , $ selector ) ; }
2906	public function getContent ( Zend_Mail $ mail ) { $ hasQueue = $ this -> hasQueue ( ) ; if ( $ hasQueue && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageBody ( ) ; } $ mimePart = $ this -> isPlain ( ) ? $ mail -> getBodyText ( ) : $ mail -> getBodyHtml ( ) ; return $ mimePart ? $ this -> getPartDecodedContent ( $ mimePart ) : '' ; }
1137	public function setDepthWithSubtree ( ) { $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ self -> descendantsAndSelf ( ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ oldDepth = ! is_null ( $ self -> getDepth ( ) ) ? $ self -> getDepth ( ) : 0 ; $ newDepth = $ self -> getLevel ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ self -> getKeyName ( ) , '=' , $ self -> getKey ( ) ) -> update ( array ( $ self -> getDepthColumnName ( ) => $ newDepth ) ) ; $ self -> setAttribute ( $ self -> getDepthColumnName ( ) , $ newDepth ) ; $ diff = $ newDepth - $ oldDepth ; if ( ! $ self -> isLeaf ( ) && $ diff != 0 ) $ self -> descendants ( ) -> increment ( $ self -> getDepthColumnName ( ) , $ diff ) ; } ) ; return $ this ; }
7029	public function getMessagesForQuantity ( float $ quantity ) { $ messages = [ ] ; if ( $ quantity < $ this -> minimumQuantity ) { $ messages [ ] = $ this -> minimumMessage ; } elseif ( 0 < $ this -> maximumQuantity && $ quantity > $ this -> maximumQuantity ) { $ messages [ ] = $ this -> maximumMessage ; } else { if ( null !== $ this -> availableMessage ) { $ messages [ ] = $ this -> availableMessage ; } if ( $ quantity > $ this -> availableQuantity ) { if ( null !== $ this -> resupplyMessage ) { $ messages [ ] = $ this -> resupplyMessage ; if ( $ quantity > $ this -> availableQuantity + $ this -> resupplyQuantity ) { $ messages [ ] = $ this -> overflowMessage ; } } else { $ messages [ ] = $ this -> overflowMessage ; } } } if ( empty ( $ messages ) ) { $ messages [ ] = $ this -> overflowMessage ; } return $ messages ; }
8208	public function getPheanstalk ( ) { if ( ! $ this -> pheanstalk ) { $ this -> pheanstalk = new Pheanstalk ( $ this -> host , $ this -> port ) ; } return $ this -> pheanstalk ; }
2091	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ 'form' ] [ 0 ] ) . ' ###' ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> title ; $ objTemplate -> href = 'contao/main.php?do=form&amp;table=tl_form_field&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> customTpl != '' && TL_MODE == 'FE' ) { $ this -> strTemplate = $ this -> customTpl ; } return parent :: generate ( ) ; }
79	public function createRepository ( $ type , $ config , $ name = null ) { if ( ! isset ( $ this -> repositoryClasses [ $ type ] ) ) { throw new \ InvalidArgumentException ( 'Repository type is not registered: ' . $ type ) ; } if ( isset ( $ config [ 'packagist' ] ) && false === $ config [ 'packagist' ] ) { $ this -> io -> writeError ( '<warning>Repository "' . $ name . '" (' . json_encode ( $ config ) . ') has a packagist key which should be in its own repository definition</warning>' ) ; } $ class = $ this -> repositoryClasses [ $ type ] ; $ reflMethod = new \ ReflectionMethod ( $ class , '__construct' ) ; $ params = $ reflMethod -> getParameters ( ) ; if ( isset ( $ params [ 4 ] ) && $ params [ 4 ] -> getClass ( ) && $ params [ 4 ] -> getClass ( ) -> getName ( ) === 'Composer\Util\RemoteFilesystem' ) { return new $ class ( $ config , $ this -> io , $ this -> config , $ this -> eventDispatcher , $ this -> rfs ) ; } return new $ class ( $ config , $ this -> io , $ this -> config , $ this -> eventDispatcher ) ; }
5296	public function setOptions ( $ options = array ( ) ) { $ this -> options = array_merge ( $ this -> options , $ options ) ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ 'id' ] = $ this -> options [ 'id' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ 'horiz-adv-x' ] = $ this -> options [ 'horiz-adv-x' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'units-per-em' ] = $ this -> options [ 'units-per-em' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'ascent' ] = $ this -> options [ 'ascent' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'descent' ] = $ this -> options [ 'descent' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'x-height' ] = $ this -> options [ 'x-height' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'cap-height' ] = $ this -> options [ 'cap-height' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'missing-glyph' } [ 0 ] [ 'horiz-adv-x' ] = $ this -> options [ 'horiz-adv-x' ] ; }
1810	public function adjustDcaByType ( $ dc ) { $ objCte = Contao \ ContentModel :: findByPk ( $ dc -> id ) ; if ( $ objCte === null ) { return ; } switch ( $ objCte -> type ) { case 'hyperlink' : unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imageUrl' ] ) ; break ; case 'image' : $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imagemargin' ] [ 'eval' ] [ 'tl_class' ] .= ' clr' ; break ; } }
2868	public function preDispatch ( ) { parent :: preDispatch ( ) ; if ( ! Mage :: helper ( 'sheep_debug' ) -> isAllowed ( ) ) { $ this -> setFlag ( '' , 'no-dispatch' , true ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; } }
4981	public function convertToPhpValue ( $ value ) { if ( ! is_array ( $ value ) || ! isset ( $ value [ 'date' ] ) || ! $ value [ 'date' ] instanceof \ MongoDate || ! isset ( $ value [ 'tz' ] ) ) { return null ; } $ timestamp = $ value [ 'date' ] -> sec ; $ date = new \ DateTime ( '@' . $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ value [ 'tz' ] ) ) ; return $ date ; }
7176	public static function extract ( $ array , array $ paths , $ default = null ) { $ found = array ( ) ; foreach ( $ paths as $ path ) { static :: set_path ( $ found , $ path , static :: path ( $ array , $ path , $ default ) ) ; } return $ found ; }
12275	private function getTemplatePath ( $ template ) { if ( strpos ( $ template , '@' ) === false && ! empty ( $ this -> defaultNamespace ) ) { $ template .= '@' . $ this -> defaultNamespace ; } $ map = $ this -> buildTemplatesMap ( ) ; if ( ! array_key_exists ( $ template , $ map ) ) { throw new \ RuntimeException ( "A template by the name '$template' does not exist. The following templates are available: " . join ( ', ' , array_keys ( $ map ) ) ) ; } return $ map [ $ template ] ; }
5333	public function setSignature ( $ parameters , $ privateKey , $ service , $ endpoint , $ timestamp , $ nonce ) { $ this -> __setCookie ( 'signature' , rawurlencode ( $ this -> sign ( $ privateKey , array_merge ( $ parameters , [ '__service' => $ service , '__hostname' => $ endpoint , '__timestamp' => $ timestamp , '__nonce' => $ nonce , ] ) ) ) ) ; }
883	private function isUseForLambda ( Tokens $ tokens , $ index ) { $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; return $ nextToken -> equals ( '(' ) ; }
6580	public static function fromPolar ( $ length , $ ap , $ av ) { return new static ( $ length * cos ( $ ap ) * cos ( $ av ) , $ length * sin ( $ ap ) * cos ( $ av ) , $ length * sin ( $ av ) ) ; }
12652	public function getPageTexts ( $ language ) { if ( ! isset ( $ this -> contents [ $ language ] ) ) { $ this -> contents [ $ language ] = $ this -> readFileContents ( $ language ) ; } return $ this -> contents [ $ language ] ; }
1538	public function willSeeOne ( $ request ) : bool { if ( $ this -> route -> isRelationship ( ) ) { return false ; } if ( $ this -> route -> isResource ( ) ) { return true ; } return $ request -> isMethod ( 'POST' ) ; }
1846	public static function unixToJd ( $ tstamp ) { list ( $ year , $ month , $ day ) = explode ( ',' , date ( 'Y,m,d' , $ tstamp ) ) ; $ year += ( $ year < 0 ? 4801 : 4800 ) ; if ( $ month > 2 ) { $ month -= 3 ; } else { $ month += 9 ; -- $ year ; } $ sdn = floor ( ( floor ( $ year / 100 ) * 146097 ) / 4 ) ; $ sdn += floor ( ( ( $ year % 100 ) * 1461 ) / 4 ) ; $ sdn += floor ( ( $ month * 153 + 2 ) / 5 ) ; $ sdn += $ day - 32045 ; return $ sdn ; }
5336	protected function encodeParameters ( $ parameters , $ keyPrefix = null ) { if ( ! is_array ( $ parameters ) && ! is_object ( $ parameters ) ) { return rawurlencode ( $ parameters ) ; } $ encodedData = [ ] ; foreach ( $ parameters as $ key => $ value ) { $ encodedKey = is_null ( $ keyPrefix ) ? rawurlencode ( $ key ) : $ keyPrefix . '[' . rawurlencode ( $ key ) . ']' ; if ( is_array ( $ value ) || is_object ( $ value ) ) { $ encodedData [ ] = $ this -> encodeParameters ( $ value , $ encodedKey ) ; } else { $ encodedData [ ] = $ encodedKey . '=' . rawurlencode ( $ value ) ; } } return implode ( '&' , $ encodedData ) ; }
8180	public function setDefaultStrategy ( $ defaultStrategy ) { if ( true === $ defaultStrategy ) { @ trigger_error ( 'Using "true" as the default strategy is deprecated since version 1.21. Use "html" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'html' ; } if ( 'filename' === $ defaultStrategy ) { @ trigger_error ( 'Using "filename" as the default strategy is deprecated since version 1.27. Use "name" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'name' ; } if ( 'name' === $ defaultStrategy ) { $ defaultStrategy = array ( 'Twig_FileExtensionEscapingStrategy' , 'guess' ) ; } $ this -> defaultStrategy = $ defaultStrategy ; }
8703	protected function registerViewComposers ( ) { $ core = $ this -> getCore ( ) ; view ( ) -> composer ( $ core -> config ( 'views.menu' ) , MenuComposer :: class ) ; view ( ) -> composer ( $ core -> config ( 'views.top' ) , TopComposer :: class ) ; return $ this ; }
11884	public function getModuleHandler ( ) { if ( is_null ( $ this -> _moduleHandler ) ) { $ stem = $ this -> field ; if ( ! isset ( self :: $ _moduleHandlers [ $ stem ] ) ) { self :: $ _moduleHandlers [ $ stem ] = [ ] ; } $ n = count ( self :: $ _moduleHandlers [ $ stem ] ) ; $ this -> _moduleHandler = $ this -> field . ':_' . $ n ; self :: $ _moduleHandlers [ $ stem ] [ ] = $ this -> _moduleHandler ; } return $ this -> _moduleHandler ; }
6335	public function create ( $ title , $ message , $ level = 'info' , $ key = 'flash_message' ) { $ this -> session -> flash ( $ key , [ 'title' => $ title , 'message' => $ message , 'level' => $ level , ] ) ; return $ this ; }
11326	public static function removeSuffix ( $ string , $ suffix ) { if ( static :: hasSuffix ( $ string , $ suffix ) ) { return substr ( $ string , 0 , - strlen ( $ suffix ) ) ; } return $ string ; }
10399	protected function start ( InputInterface $ input , OutputInterface $ output , $ serviceClass , $ prefix ) { $ benchmark = new CommandBenchmark ( $ output ) ; $ benchmark -> start ( ) ; $ service = $ this -> getContainer ( ) -> get ( $ serviceClass ) ; $ factory = $ service -> getPipelineFactory ( ) ; $ factory -> setProgressBar ( new ProgressBar ( $ output ) ) ; $ service -> startPipeline ( $ prefix , $ input -> getArgument ( 'target' ) ) ; $ benchmark -> finish ( ) ; }
12024	private function addConstructorMethod ( ) { $ requiredParameters = $ this -> operationDefinition -> getRequiredParams ( ) ; $ methodGenerator = new MethodGenerator ( '__construct' ) ; $ defaultParams = $ this -> operationDefinition -> getDefaultParams ( ) ; $ body = '' ; if ( count ( $ defaultParams ) ) { $ body = '$defaultParams = [' . PHP_EOL ; foreach ( $ defaultParams as $ param ) { $ body .= sprintf ( " '%s' => '%s'," , $ param -> getName ( ) , $ param -> getDefault ( ) ) ; $ body .= PHP_EOL ; } $ body .= '];' . PHP_EOL ; $ body .= '$this->setParams($defaultParams);' . PHP_EOL ; } $ constructorParams = [ ] ; $ constructorParams [ ] = new ParameterGenerator ( 'api' , $ this -> apiGenerator -> getFQCN ( ) ) ; $ body .= '$this->api = $api;' . PHP_EOL ; foreach ( $ requiredParameters as $ param ) { $ normalizedParamName = normalizeParamName ( $ param -> getName ( ) ) ; $ constructorParams [ ] = new ParameterGenerator ( $ normalizedParamName , $ param -> getType ( ) ) ; $ body .= sprintf ( "\$this->parameters['%s'] = $%s;" . PHP_EOL , $ param -> getName ( ) , $ normalizedParamName ) ; } $ methodGenerator -> setParameters ( $ constructorParams ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
1651	public function containsGeometry ( GeometryInterface $ geometry ) : bool { $ geometryInPolygon = true ; foreach ( $ geometry -> getPoints ( ) as $ point ) { $ geometryInPolygon = $ geometryInPolygon && $ this -> contains ( $ point ) ; } return $ geometryInPolygon ; }
10777	private function total_size ( ) { $ arr = array ( "width" => 0 , "height" => 0 ) ; foreach ( $ this -> images as $ image ) { if ( $ arr [ "width" ] < $ image [ "width" ] ) { $ arr [ "width" ] = $ image [ "width" ] ; } $ arr [ "height" ] += $ image [ "height" ] ; } return $ arr ; }
2899	public function getQueryModels ( ) { $ queries = array ( ) ; foreach ( $ this -> _queryProfiles as $ queryId => $ queryProfile ) { $ queryModel = Mage :: getModel ( 'sheep_debug/query' ) ; $ stacktrace = array_key_exists ( $ queryId , $ this -> stackTraces ) ? $ this -> stackTraces [ $ queryId ] : '' ; $ queryModel -> init ( $ queryProfile , $ stacktrace ) ; $ queries [ ] = $ queryModel ; } return $ queries ; }
8449	public function contactAdd ( $ phoneNumber , $ firstName , $ lastName ) { $ phoneNumber = $ this -> formatPhoneNumber ( $ phoneNumber ) ; return $ this -> exec ( 'add_contact ' . $ phoneNumber . ' ' . $ this -> escapeStringArgument ( $ firstName ) . ' ' . $ this -> escapeStringArgument ( $ lastName ) ) ; }
6046	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; AdminUiAsset :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } if ( ! empty ( $ this -> clientEvents ) ) { $ js = [ ] ; foreach ( $ this -> clientEvents as $ event => $ handler ) { $ js [ ] = "jQuery('#$id').on('$event', $handler);" ; } $ view -> registerJs ( implode ( "\n" , $ js ) ) ; } }
640	public function dropPrimaryKey ( $ name , $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropPrimaryKey ( $ name , $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
11098	public static function secondsBetweenWorkingDays ( $ dateFrom , $ dateTo , $ workDayFrom , $ workDayTo , $ weekends = false , $ holidays = false , $ timeZone = 'Europe/Prague' ) { $ timeZoneObj = new \ DateTimeZone ( $ timeZone ) ; $ dateFromObj = new DateTime ( $ dateFrom , $ timeZoneObj ) ; $ dateToObj = new DateTime ( $ dateTo , $ timeZoneObj ) ; $ workDayFromObj = new DateTime ( $ workDayFrom , $ timeZoneObj ) ; $ workDayToObj = new DateTime ( $ workDayTo , $ timeZoneObj ) ; $ workDayLength = self :: secondsBetweenDates ( $ workDayFrom , $ workDayTo , true , $ timeZone ) ; $ period = new \ DatePeriod ( new DateTime ( $ dateFromObj -> format ( 'Y-m-d 00:00:00' ) , $ timeZoneObj ) , new \ DateInterval ( 'P1D' ) , new DateTime ( $ dateToObj -> format ( 'Y-m-d 23:59:59' ) , $ timeZoneObj ) ) ; $ workedTime = 0 ; foreach ( $ period as $ date ) { if ( ( ! $ weekends && ( int ) $ date -> format ( 'N' ) > 5 ) || ( ! $ holidays && self :: isCzechHoliday ( $ date ) ) ) { continue ; } if ( $ date -> format ( 'Y-m-d' ) === $ dateFromObj -> format ( 'Y-m-d' ) ) { $ endOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayToObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateFromObj < $ endOfDay && $ dateFromObj -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ diff = $ dateToObj -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } else { $ diff = $ endOfDay -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } elseif ( $ date -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ startOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayFromObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateToObj > $ startOfDay ) { $ diff = $ startOfDay -> diff ( $ dateToObj ) -> format ( '%H:%I:%S' ) ; $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } } else { $ workedTime += $ workDayLength ; } } return $ workedTime ; }
7256	public function user ( $ key = null ) { if ( $ this -> sessionKey && $ this -> request -> session ( ) -> check ( $ this -> sessionKey ) ) { $ user = $ this -> request -> session ( ) -> read ( $ this -> sessionKey ) ; } else { return null ; } if ( $ key === null ) { return $ user ; } return Hash :: get ( $ user , $ key ) ; }
10921	public function setHeaders ( array $ headers ) { $ columnNumber = 0 ; foreach ( $ headers as $ header ) { $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ header ) ) ; if ( ! in_array ( $ header , $ this -> headers ) ) { $ this -> headers [ ] = $ header ; } $ columnNumber ++ ; } }
9838	public function createSymmetricAuthenticatedJsonResponse ( int $ status , array $ arrayToJsonify , SharedAuthenticationKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricAuthenticatedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
7890	protected function getDefaultProjectHook ( ) { $ default = $ this -> config -> get ( self :: CONFIG_DEFAULT ) ; return $ this -> config -> get ( sprintf ( self :: CONFIG_PROJECT , $ default ) ) ; }
11638	public function getAuthorities ( ) { $ authorities = [ ] ; foreach ( $ this -> getAll ( ) as $ typeItem ) { if ( isset ( $ typeItem -> object ) && $ typeItem -> object -> getBehavior ( 'Authority' ) !== null ) { $ authorities [ $ typeItem -> object -> systemId ] = $ typeItem -> object ; } } return $ authorities ; }
4075	protected function setTableMapping ( $ modelId , $ tableName ) { $ this -> information [ $ tableName ] [ self :: MODELID ] = $ modelId ; $ this -> tableMap [ $ modelId ] = $ tableName ; }
6215	public function getParameters ( ) { $ parameters = $ this -> getUnfilteredParameters ( ) ; foreach ( $ this -> parameterFilters as $ filter ) { $ filter -> filter ( $ parameters ) ; } return $ parameters ; }
12829	public function setConfig ( $ name , $ value ) { if ( is_null ( $ name ) ) { $ this -> _config = new ArrayStorage ( $ value ) ; } else { $ this -> _config -> setDeepValue ( $ name , $ value ) ; } return $ this ; }
10631	public static function avgload ( ) { $ avgload = new \ StdClass ( ) ; if ( false !== ( $ data = @ file ( '/proc/loadavg' ) ) ) { $ data = explode ( " " , implode ( "" , $ data ) ) ; $ data = array_chunk ( $ data , 4 ) ; $ avgload -> min1 = $ data [ 0 ] [ 0 ] ; $ avgload -> min5 = $ data [ 0 ] [ 1 ] ; $ avgload -> min15 = $ data [ 0 ] [ 2 ] ; $ fourth = explode ( '/' , $ data [ 0 ] [ 3 ] ) ; $ avgload -> running = $ fourth [ 0 ] ; $ avgload -> exists = $ fourth [ 1 ] ; $ avgload -> recentPID = $ data [ 1 ] [ 0 ] ; } return $ avgload ; }
10669	public static function fromArray ( $ input , array $ options = [ ] ) { if ( ! \ is_array ( $ input ) || \ count ( $ input ) !== 1 ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid input.' ) ) ; } $ key = key ( $ input ) ; if ( \ is_int ( $ key ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'The key of input must be alphanumeric.' ) ) ; } if ( ! \ is_array ( $ options ) ) { $ options = [ 'format' => ( string ) $ options ] ; } $ defaults = [ 'format' => 'tags' , 'version' => '1.0' , 'encoding' => 'utf-8' , 'return' => 'simplexml' , ] ; $ options = array_merge ( $ defaults , $ options ) ; $ dom = new \ DOMDocument ( $ options [ 'version' ] , $ options [ 'encoding' ] ) ; self :: _fromArray ( $ dom , $ dom , $ input , $ options [ 'format' ] ) ; $ options [ 'return' ] = strtolower ( $ options [ 'return' ] ) ; if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ dom -> saveXML ( ) ) ; } return $ dom ; }
8924	public function merge ( $ patchDocument1 , $ patchDocument2 ) { if ( $ patchDocument1 === null || $ patchDocument2 === null || ! is_object ( $ patchDocument1 ) || ! is_object ( $ patchDocument2 ) ) { return $ patchDocument2 ; } $ patchDocument = $ patchDocument1 ; $ patchDocument1Vars = get_object_vars ( $ patchDocument1 ) ; $ patchDocument2Vars = get_object_vars ( $ patchDocument2 ) ; foreach ( $ patchDocument2Vars as $ var => $ value ) { if ( isset ( $ patchDocument1Vars [ $ var ] ) ) { $ patchDocument -> $ var = $ this -> merge ( $ patchDocument1 -> $ var , $ patchDocument2 -> $ var ) ; } else { $ patchDocument -> $ var = $ patchDocument2 -> $ var ; } } return $ patchDocument ; }
7427	public function renderEmbed ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> embedDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
11896	protected function generateIV ( ) { $ sizeIV = $ this -> getSizeIV ( ) ; if ( $ sizeIV === 0 ) { return $ this ; } $ this -> setIV ( mcrypt_create_iv ( $ sizeIV , MCRYPT_RAND ) ) ; return $ this ; }
7196	public function handleReleasedChange ( OrderInterface $ order ) { if ( $ this -> persistenceHelper -> isChanged ( $ order , 'sample' ) ) { if ( $ order -> isReleased ( ) && ! $ order -> isSample ( ) ) { throw new IllegalOperationException ( "Can't turn 'sample' into false if order is released." ) ; } } if ( ! $ this -> persistenceHelper -> isChanged ( $ order , 'released' ) ) { return false ; } if ( ! $ order -> isSample ( ) && $ order -> isReleased ( ) ) { $ order -> setReleased ( false ) ; return true ; } if ( ! OrderStates :: isStockableState ( $ order -> getState ( ) ) ) { return false ; } foreach ( $ order -> getItems ( ) as $ item ) { $ this -> applySaleItemRecursively ( $ item ) ; } return false ; }
9322	protected function registerMarkdownEnvironment ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.environment' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'markdown' ] ; $ environment = Environment :: createCommonMarkEnvironment ( ) ; if ( $ config [ 'configurations' ] ) { $ environment -> mergeConfig ( $ config [ 'configurations' ] ) ; } foreach ( $ config [ 'extensions' ] as $ extension ) { if ( class_exists ( $ extension ) ) { $ environment -> addExtension ( new $ extension ( ) ) ; } } return $ environment ; } ) ; $ app -> alias ( 'commonmark.environment' , Environment :: class ) ; }
1098	public function updateStructure ( ) { list ( $ a , $ b , $ c , $ d ) = $ this -> boundaries ( ) ; $ this -> applyLockBetween ( $ a , $ d ) ; $ connection = $ this -> node -> getConnection ( ) ; $ grammar = $ connection -> getQueryGrammar ( ) ; $ currentId = $ this -> quoteIdentifier ( $ this -> node -> getKey ( ) ) ; $ parentId = $ this -> quoteIdentifier ( $ this -> parentId ( ) ) ; $ leftColumn = $ this -> node -> getLeftColumnName ( ) ; $ rightColumn = $ this -> node -> getRightColumnName ( ) ; $ parentColumn = $ this -> node -> getParentColumnName ( ) ; $ wrappedLeft = $ grammar -> wrap ( $ leftColumn ) ; $ wrappedRight = $ grammar -> wrap ( $ rightColumn ) ; $ wrappedParent = $ grammar -> wrap ( $ parentColumn ) ; $ wrappedId = $ grammar -> wrap ( $ this -> node -> getKeyName ( ) ) ; $ lftSql = "CASE WHEN $wrappedLeft BETWEEN $a AND $b THEN $wrappedLeft + $d - $b WHEN $wrappedLeft BETWEEN $c AND $d THEN $wrappedLeft + $a - $c ELSE $wrappedLeft END" ; $ rgtSql = "CASE WHEN $wrappedRight BETWEEN $a AND $b THEN $wrappedRight + $d - $b WHEN $wrappedRight BETWEEN $c AND $d THEN $wrappedRight + $a - $c ELSE $wrappedRight END" ; $ parentSql = "CASE WHEN $wrappedId = $currentId THEN $parentId ELSE $wrappedParent END" ; $ updateConditions = array ( $ leftColumn => $ connection -> raw ( $ lftSql ) , $ rightColumn => $ connection -> raw ( $ rgtSql ) , $ parentColumn => $ connection -> raw ( $ parentSql ) ) ; if ( $ this -> node -> timestamps ) $ updateConditions [ $ this -> node -> getUpdatedAtColumn ( ) ] = $ this -> node -> freshTimestamp ( ) ; return $ this -> node -> newNestedSetQuery ( ) -> where ( function ( $ query ) use ( $ leftColumn , $ rightColumn , $ a , $ d ) { $ query -> whereBetween ( $ leftColumn , array ( $ a , $ d ) ) -> orWhereBetween ( $ rightColumn , array ( $ a , $ d ) ) ; } ) -> update ( $ updateConditions ) ; }
6934	protected function getOperator ( SaleInterface $ sale ) { if ( $ sale instanceof CartInterface ) { return $ this -> cartOperator ; } elseif ( $ sale instanceof QuoteInterface ) { return $ this -> quoteOperator ; } elseif ( $ sale instanceof OrderInterface ) { return $ this -> orderOperator ; } throw new InvalidArgumentException ( "Unexpected sale type." ) ; }
2933	public function deleteKeys ( $ keys = [ ] ) { foreach ( $ keys as $ key ) { $ this -> writer -> deleteSetter ( $ key ) ; } return $ this ; }
1050	public static function getDirectiveValues ( Directive $ directiveDef , $ node , $ variableValues = null ) { if ( isset ( $ node -> directives ) && $ node -> directives instanceof NodeList ) { $ directiveNode = Utils :: find ( $ node -> directives , static function ( DirectiveNode $ directive ) use ( $ directiveDef ) { return $ directive -> name -> value === $ directiveDef -> name ; } ) ; if ( $ directiveNode !== null ) { return self :: getArgumentValues ( $ directiveDef , $ directiveNode , $ variableValues ) ; } } return null ; }
5150	protected function getEmailRecipients ( $ email ) { $ recipients = $ email -> Headers -> to . ' ' . $ email -> Headers -> cc ; if ( $ email -> Headers -> bcc != NULL ) { $ recipients .= ' ' . $ email -> Headers -> bcc ; } return $ recipients ; }
8530	private function _convertListFinancialEvents ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMaxResultsPerPage ( ) ) { $ parameters [ 'MaxResultsPerPage' ] = $ request -> getMaxResultsPerPage ( ) ; } if ( $ request -> isSetAmazonOrderId ( ) ) { $ parameters [ 'AmazonOrderId' ] = $ request -> getAmazonOrderId ( ) ; } if ( $ request -> isSetFinancialEventGroupId ( ) ) { $ parameters [ 'FinancialEventGroupId' ] = $ request -> getFinancialEventGroupId ( ) ; } if ( $ request -> isSetPostedAfter ( ) ) { $ parameters [ 'PostedAfter' ] = $ request -> getPostedAfter ( ) ; } if ( $ request -> isSetPostedBefore ( ) ) { $ parameters [ 'PostedBefore' ] = $ request -> getPostedBefore ( ) ; } return $ parameters ; }
12923	public function getLocalDataItems ( ) { if ( ! isset ( $ this -> _localDataItems ) ) { $ this -> trigger ( self :: EVENT_LOAD_LOCAL_DATA_ITEMS ) ; } return $ this -> _localDataItems ; }
7174	public static function path ( $ array , $ path , $ default = null , $ delimiter = null ) { if ( ! static :: is_array ( $ array ) ) { return $ default ; } if ( is_array ( $ path ) ) { $ keys = $ path ; } else { if ( array_key_exists ( $ path , $ array ) ) { return $ array [ $ path ] ; } if ( ! $ delimiter ) { $ delimiter = static :: $ delimiter ; } $ path = trim ( $ path , "{$delimiter} " ) ; $ keys = explode ( $ delimiter , $ path ) ; } do { $ key = array_shift ( $ keys ) ; if ( ctype_digit ( $ key ) ) { $ key = ( int ) $ key ; } if ( isset ( $ array [ $ key ] ) ) { if ( ! $ keys ) { return $ array [ $ key ] ; } if ( ! static :: is_array ( $ array [ $ key ] ) ) { break ; } $ array = $ array [ $ key ] ; } else { break ; } } while ( $ keys ) ; return $ default ; }
7101	static public function getClasses ( $ type ) { switch ( $ type ) { case static :: TYPE_FORM : return [ CartInterface :: class ] ; case static :: TYPE_QUOTE : return [ QuoteInterface :: class ] ; case static :: TYPE_PROFORMA : return [ QuoteInterface :: class , OrderInterface :: class ] ; case static :: TYPE_CONFIRMATION : return [ OrderInterface :: class ] ; case static :: TYPE_VOUCHER : return [ ] ; default : throw new InvalidArgumentException ( "Unexpected type '$type'." ) ; } }
11548	public function getGroup ( $ name ) { if ( array_key_exists ( $ name , $ this -> groups ) ) { return $ this -> groups [ $ name ] ; } throw new KeyNotFoundInSetException ( $ name , array_keys ( $ this -> groups ) , 'groups' ) ; }
8100	protected function validate ( $ name , $ limit , $ regEx = false ) { $ Name = ucfirst ( $ name ) ; $ value = $ this -> _updates -> $ name ; $ length = explode ( '-' , $ limit ) ; $ min = intval ( $ length [ 0 ] ) ; $ max = intval ( $ length [ 1 ] ) ; if ( ! $ max and ! $ min ) { $ this -> log -> error ( "Invalid second parameter for the $name validation" ) ; return false ; } if ( ! $ value ) { if ( is_null ( $ value ) ) { $ this -> log -> report ( "Missing index $name from the input" ) ; } if ( strlen ( $ value ) == $ min ) { $ this -> log -> report ( "$Name is blank and optional - skipped" ) ; return true ; } $ this -> log -> formError ( $ name , "$Name is required." ) ; return false ; } if ( strlen ( $ value ) > $ max ) { $ this -> log -> formError ( $ name , "The $Name is larger than $max characters." ) ; return false ; } if ( strlen ( $ value ) < $ min ) { $ this -> log -> formError ( $ name , "The $Name is too short. It should at least be $min characters long" ) ; return false ; } if ( $ regEx ) { preg_match ( $ regEx , $ value , $ match ) ; if ( preg_match ( $ regEx , $ value , $ match ) === 0 ) { $ this -> log -> formError ( $ name , "The $Name \"{$value}\" is not valid" ) ; return false ; } } $ this -> log -> report ( "The $name is Valid" ) ; return true ; }
12607	public static function makeSafe ( $ file ) { $ regex = [ '#(\.){2,}#' , '#[^A-Za-z0-9\.\_\- ]#' , '#^\.#' , ] ; $ file = rtrim ( $ file , '.' ) ; $ clean = preg_replace ( $ regex , ' ' , $ file ) ; $ clean = preg_replace ( "/[ \_]/" , '-' , $ clean ) ; $ clean = preg_replace ( "/[\-]+/" , '-' , $ clean ) ; return $ clean ; }
8245	protected function abortIfExpired ( $ id , $ userData ) { if ( isset ( $ userData [ 'pwreset' ] ) && $ userData [ 'pwreset' ] ) { $ this -> session -> addFlash ( "error" , "Please set a new password." ) ; $ this -> picoAuth -> getContainer ( ) -> get ( 'PasswordReset' ) -> startPasswordResetSession ( $ id ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
2480	protected function mapSearchFieldValue ( $ value , FieldType $ searchFieldType = null ) { if ( null === $ searchFieldType ) { return $ value ; } $ searchField = new SearchField ( 'field' , $ value , $ searchFieldType ) ; $ value = ( array ) $ this -> fieldValueMapper -> map ( $ searchField ) ; return current ( $ value ) ; }
11558	public function save ( ) { $ this -> modifiedTime = new \ DateTime ( 'now' ) ; self :: set ( $ this -> namespace , base64_encode ( serialize ( $ this -> instance ) ) , $ this -> modifiedTime -> getTimestamp ( ) + $ this -> lifetime , $ this -> path , $ this -> domain , $ this -> secure ) ; return $ this ; }
9299	public function postAction ( Request $ request ) { try { $ data = $ this -> get ( 'ongr_api.batch_request_handler' ) -> handleRequest ( $ request , $ repository = $ this -> getRequestRepository ( $ request ) , 'create' ) ; return $ this -> renderRest ( $ request , $ data , Response :: HTTP_OK ) ; } catch ( \ Exception $ e ) { return $ this -> renderError ( $ request , $ e -> getMessage ( ) , Response :: HTTP_BAD_REQUEST ) ; } }
3292	public function twitter ( ) { if ( is_null ( $ this -> title ) ) { $ this -> title = config ( 'laravel-share.services.twitter.text' ) ; } $ base = config ( 'laravel-share.services.twitter.uri' ) ; $ url = $ base . '?text=' . urlencode ( $ this -> title ) . '&url=' . $ this -> url ; $ this -> buildLink ( 'twitter' , $ url ) ; return $ this ; }
6272	public static function open ( $ fileName ) { return self :: haveExtension ( ) ? new Reader \ DBA ( $ fileName ) : new Reader \ PHP ( $ fileName ) ; }
9475	public function stripQuotes ( $ string ) { if ( strlen ( $ string ) < 2 || substr ( $ string , 0 , 1 ) !== '"' || substr ( $ string , - 1 , 1 ) !== '"' ) { return $ string ; } return substr ( $ string , 1 , - 1 ) ; }
796	public function getAnnotationEnd ( $ index ) { $ currentIndex = null ; if ( isset ( $ this [ $ index + 2 ] ) ) { if ( $ this [ $ index + 2 ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { $ currentIndex = $ index + 2 ; } elseif ( isset ( $ this [ $ index + 3 ] ) && $ this [ $ index + 2 ] -> isType ( DocLexer :: T_NONE ) && $ this [ $ index + 3 ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) && Preg :: match ( '/^(\R\s*\*\s*)*\s*$/' , $ this [ $ index + 2 ] -> getContent ( ) ) ) { $ currentIndex = $ index + 3 ; } } if ( null !== $ currentIndex ) { $ level = 0 ; for ( $ max = \ count ( $ this ) ; $ currentIndex < $ max ; ++ $ currentIndex ) { if ( $ this [ $ currentIndex ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { ++ $ level ; } elseif ( $ this [ $ currentIndex ] -> isType ( DocLexer :: T_CLOSE_PARENTHESIS ) ) { -- $ level ; } if ( 0 === $ level ) { return $ currentIndex ; } } return null ; } return $ index + 1 ; }
6712	protected function stringToArray ( $ string ) { if ( ! $ string || ! is_string ( $ string ) ) { return [ ] ; } $ result = $ this -> getReaderFactory ( ) -> read ( $ string ) ; if ( $ result ) { return $ result ; } $ array = [ ] ; $ array [ 'text' ] = $ string ; return $ array ; }
5210	public static function getInstance ( OutputInterface $ output ) { $ questionHelper = new QuestionHelper ( ) ; $ application = new Application ( 'PHP to Zephir Command Line Interface' , 'Beta 0.2.1' ) ; $ application -> getHelperSet ( ) -> set ( new FormatterHelper ( ) , 'formatter' ) ; $ application -> getHelperSet ( ) -> set ( $ questionHelper , 'question' ) ; $ application -> add ( ConvertFactory :: getInstance ( $ output ) ) ; return $ application ; }
4330	public static function serializeLog ( $ data ) { $ str = \ serialize ( $ data ) ; if ( \ function_exists ( 'gzdeflate' ) ) { $ str = \ gzdeflate ( $ str ) ; } $ str = \ chunk_split ( \ base64_encode ( $ str ) , 124 ) ; return "START DEBUG\n" . $ str . 'END DEBUG' ; }
10846	protected function restoreWordCase ( $ token ) { if ( $ token === strtoupper ( $ token ) ) { return function ( $ word ) { return strtoupper ( $ word ) ; } ; } if ( $ token === ucfirst ( $ token ) ) { return function ( $ word ) { return ucfirst ( $ word ) ; } ; } return function ( $ word ) { return $ word ; } ; }
4895	public function render ( $ type = null , $ content = true , array $ options = array ( ) ) { if ( is_array ( $ type ) ) { $ options = $ type ; $ type = self :: TYPE_INFO ; $ content = true ; } elseif ( is_array ( $ content ) ) { $ options = $ content ; $ content = true ; } if ( true === $ content ) { return $ this -> start ( $ type , $ options ) ; } $ id = isset ( $ options [ 'id' ] ) ? ' id="' . $ options [ 'id' ] . '"' : '' ; $ class = isset ( $ options [ 'class' ] ) ? ' ' . $ options [ 'class' ] : '' ; if ( ( isset ( $ options [ 'dismissable' ] ) && $ options [ 'dismissable' ] ) || ! isset ( $ options [ 'dismissable' ] ) ) { $ class .= ' alert-dismissable' ; $ content = '<button type="button" class="close" data-dismiss="alert">&times;</button>' . '<span class="notification-content">' . $ content . '</span>' ; } $ target = array_key_exists ( 'target' , $ options ) ? ' target="' . $ options [ 'target' ] . '"' : '' ; $ markup = '<div ' . $ id . ' class="alert alert-' . $ type . $ class . '" ' . $ target . '>' . $ content . '</div>' . PHP_EOL ; return $ markup ; }
1878	public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( ! empty ( $ ids ) && \ is_array ( $ ids ) ) { $ ids = $ this -> eliminateNestedPaths ( $ ids ) ; foreach ( $ ids as $ id ) { $ this -> delete ( $ id ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
1158	protected function ruleAfter ( $ attribute , array $ parameters ) { if ( ! ( $ date = strtotime ( $ parameters [ 0 ] ) ) ) { $ date = $ this -> getAttributeName ( $ parameters [ 0 ] ) ; } return [ $ attribute , [ $ date ] ] ; }
10065	public function setPieces ( $ pieces ) { if ( $ pieces && ! $ pieces instanceof PieceBag ) { $ pieces = new PieceBag ( is_array ( $ pieces ) ? $ pieces : [ ] ) ; } return $ this -> setParameter ( 'pieces' , $ pieces ) ; }
11426	public function blacklist ( $ beginOpenid = null ) { $ params = [ 'begin_openid' => $ beginOpenid ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_BLACK_LIST , $ params ] ) ; }
11892	public function newAction ( Request $ request ) { $ entity = new CustomField ( ) ; $ cfGroupId = $ request -> query -> get ( 'customFieldsGroup' , null ) ; if ( $ cfGroupId !== null ) { $ cfGroup = $ this -> getDoctrine ( ) -> getManager ( ) -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ cfGroupId ) ; if ( ! $ cfGroup ) { throw $ this -> createNotFoundException ( 'CustomFieldsGroup with id ' . $ cfGroupId . ' is not found !' ) ; } $ entity -> setCustomFieldsGroup ( $ cfGroup ) ; } $ form = $ this -> createCreateForm ( $ entity , $ request -> query -> get ( 'type' ) ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomField:new.html.twig' , array ( 'entity' => $ entity , 'form' => $ form -> createView ( ) , ) ) ; }
5745	private function getDebugBacktraceString ( ) : string { $ out = "" ; $ dbt = debug_backtrace ( ~ DEBUG_BACKTRACE_PROVIDE_OBJECT & ~ DEBUG_BACKTRACE_IGNORE_ARGS ) ; array_shift ( $ dbt ) ; array_shift ( $ dbt ) ; $ showVendorCalls = true ; $ showFullFilePath = true ; $ startFilePath = '/Src' ; $ showClassNamespace = false ; foreach ( $ dbt as $ index => $ call ) { $ outLine = "#$index:" ; if ( isset ( $ call [ 'file' ] ) ) { if ( ! $ showVendorCalls && strstr ( $ call [ 'file' ] , '/vendor/' ) ) { break ; } $ outLine .= " " ; if ( $ showFullFilePath ) { $ outLine .= $ call [ 'file' ] ; } else { $ fileParts = explode ( $ startFilePath , $ call [ 'file' ] ) ; $ outLine .= ( isset ( $ fileParts [ 1 ] ) ) ? $ fileParts [ 1 ] : $ call [ 'file' ] ; } } if ( isset ( $ call [ 'line' ] ) ) { $ outLine .= " [" . $ call [ 'line' ] . "] " ; } if ( isset ( $ call [ 'class' ] ) ) { $ classParts = explode ( "\\" , $ call [ 'class' ] ) ; $ outLine .= " " ; $ outLine .= ( $ showClassNamespace ) ? $ call [ 'class' ] : $ classParts [ count ( $ classParts ) - 1 ] ; } if ( isset ( $ call [ 'type' ] ) ) { $ outLine .= $ call [ 'type' ] ; } if ( isset ( $ call [ 'function' ] ) ) { $ outLine .= $ call [ 'function' ] . "()" ; } if ( isset ( $ call [ 'args' ] ) ) { $ outLine .= " {" . Functions :: arrayWalkToStringRecursive ( $ call [ 'args' ] , 0 , 1000 , PHP_EOL ) . "}" ; } $ out .= "$outLine" . PHP_EOL ; } return $ out ; }
6642	public static function encodeId ( $ id , $ salt , $ hashLength = self :: MIN_HASH_LENGTH ) { $ hashIds = new Hashids ( $ salt , $ hashLength ) ; return $ hashIds -> encode ( $ id ) ; }
8505	public function createInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_CreateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_CreateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_CreateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12726	public function getContent ( array $ contentData ) { foreach ( $ this -> mandatoryFields as $ mandatoryField ) { if ( ! array_key_exists ( $ mandatoryField , $ contentData ) ) { throw new ContentException ( "The field '$mandatoryField' is missing in the given content data" ) ; } } try { $ title = "" ; if ( isset ( $ contentData [ self :: FIELD_TITLE ] ) ) { $ title = $ contentData [ self :: FIELD_TITLE ] ; } $ summary = "" ; if ( isset ( $ contentData [ self :: FIELD_SUMMARY ] ) ) { $ summary = $ contentData [ self :: FIELD_SUMMARY ] ; } $ description = "" ; if ( isset ( $ contentData [ self :: FIELD_DESCRIPTION ] ) ) { $ description = $ contentData [ self :: FIELD_DESCRIPTION ] ; } $ content = new Content ( $ title , $ summary , $ description ) ; return $ content ; } catch ( \ Exception $ contentException ) { throw new ContentException ( sprintf ( "Failed to create a content model from the given data: %s" , $ contentException -> getMessage ( ) ) , $ contentException ) ; } }
4462	private function readErrorFromSocket ( $ socket ) : ? string { $ error = '' ; while ( ! empty ( $ res = socket_read ( $ socket , 8192 ) ) ) { $ error .= $ res ; } $ error = unserialize ( $ error ) ; if ( is_array ( $ error ) ) { $ handler = new ErrorFormatter ( ) ; return sprintf ( '%s: %s in %s on line %d' , $ handler -> constant ( $ error [ 'type' ] ) ? : 'Unknown' , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } return null ; }
3704	public function handle ( PreDuplicateModelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ model -> getProviderName ( ) ) ; if ( ! $ metaModel || ! $ metaModel -> hasVariants ( ) ) { return ; } if ( $ model -> getProperty ( 'varbase' ) == 1 ) { $ model -> setProperty ( 'vargroup' , null ) ; } }
2352	public function sendToBrowser ( $ filename = '' , $ inline = false ) { $ response = new BinaryFileResponse ( $ this -> strRootDir . '/' . $ this -> strFile ) ; $ response -> setContentDisposition ( $ inline ? ResponseHeaderBag :: DISPOSITION_INLINE : ResponseHeaderBag :: DISPOSITION_ATTACHMENT , $ filename , Utf8 :: toAscii ( $ this -> basename ) ) ; $ response -> headers -> addCacheControlDirective ( 'must-revalidate' ) ; $ response -> headers -> addCacheControlDirective ( 'post-check' , 0 ) ; $ response -> headers -> addCacheControlDirective ( 'pre-check' , 0 ) ; $ response -> headers -> set ( 'Connection' , 'close' ) ; throw new ResponseException ( $ response ) ; }
5256	public function setParent ( ElasticsearchModel $ parent ) { $ this -> _parent = $ parent ; $ this -> setParentId ( $ parent -> getId ( ) ) ; }
6384	public function readFeedbackQuestions ( $ id ) { $ questions = $ this -> readStoreRecords ( 'feedback_item' , [ 'feedback' => $ id ] ) ; $ expandedQuestions = [ ] ; foreach ( $ questions as $ index => $ question ) { $ expandedQuestion = $ question ; $ expandedQuestion -> template = $ this -> readStoreRecord ( 'feedback_template' , [ 'id' => $ question -> template ] ) ; $ expandedQuestion -> url = $ this -> cfg -> wwwroot . '/mod/feedback/edit_item.php?id=' . $ question -> id ; $ expandedQuestions [ $ index ] = $ expandedQuestion ; } return $ expandedQuestions ; }
9839	public function createSymmetricEncryptedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SharedEncryptionKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricEncryptedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
11149	protected function process ( array $ requestParams ) { $ request = new ExtDirectRequest ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; $ response = new ExtDirectResponse ( ) ; $ requestParameters = new Parameters ( ) ; try { $ request -> setApplicationPath ( $ this -> getApplicationPath ( ) ) ; $ requestParameters -> setParameters ( $ requestParams ) ; $ request -> injectParameters ( $ requestParameters ) ; $ response -> injectParameters ( $ requestParameters ) ; $ request -> injectResponse ( $ response ) ; $ request -> setParamMethod ( $ this -> getParamMethod ( ) ) ; $ request -> setMethodCalls ( $ this -> getMethodsToCall ( ) ) ; $ request -> run ( ) ; } catch ( ExtDirectApplicationException $ e ) { $ result = $ e -> getResponse ( ) ; if ( ! empty ( $ result ) ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) , "actions" => $ result ) ) ; } else { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } } catch ( \ Exception $ e ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } return $ response ; }
2615	public function isApiKeyValid ( ) { try { $ apiKey = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_API_KEY ) ; $ serviceId = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_SERVICE_ID ) ; $ isApiKeyValid = $ this -> api -> checkServiceDetails ( true , $ serviceId , $ apiKey ) ; } catch ( \ Exception $ e ) { return false ; } return ( bool ) $ isApiKeyValid ; }
11174	public static function hash ( $ string , $ algorithm = 'blowfish' ) { switch ( strtolower ( $ algorithm ) ) : case ( 'md5' ) : $ salt = '$1$' . ( static :: rand ( 12 ) ) . '$' ; break ; case ( 'sha256' ) : $ salt = '$5$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'sha512' ) : $ salt = '$6$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'blowfish' ) : default : $ salt = '$2a$09$' . ( static :: rand ( 22 ) ) . '$' ; break ; endswitch ; return base64_encode ( crypt ( $ string , $ salt ) ) ; }
1032	private function completeValue ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ promise = $ this -> getPromise ( $ result ) ; if ( $ promise ) { return $ promise -> then ( function ( & $ resolved ) use ( $ returnType , $ fieldNodes , $ info , $ path ) { return $ this -> completeValue ( $ returnType , $ fieldNodes , $ info , $ path , $ resolved ) ; } ) ; } if ( $ result instanceof Exception || $ result instanceof Throwable ) { throw $ result ; } if ( $ returnType instanceof NonNull ) { $ completed = $ this -> completeValue ( $ returnType -> getWrappedType ( ) , $ fieldNodes , $ info , $ path , $ result ) ; if ( $ completed === null ) { throw new InvariantViolation ( 'Cannot return null for non-nullable field ' . $ info -> parentType . '.' . $ info -> fieldName . '.' ) ; } return $ completed ; } if ( $ result === null ) { return null ; } if ( $ returnType instanceof ListOfType ) { return $ this -> completeListValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } if ( $ returnType !== $ this -> exeContext -> schema -> getType ( $ returnType -> name ) ) { $ hint = '' ; if ( $ this -> exeContext -> schema -> getConfig ( ) -> typeLoader ) { $ hint = sprintf ( 'Make sure that type loader returns the same instance as defined in %s.%s' , $ info -> parentType , $ info -> fieldName ) ; } throw new InvariantViolation ( sprintf ( 'Schema must contain unique named types but contains multiple types named "%s". %s ' . '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).' , $ returnType , $ hint ) ) ; } if ( $ returnType instanceof LeafType ) { return $ this -> completeLeafValue ( $ returnType , $ result ) ; } if ( $ returnType instanceof AbstractType ) { return $ this -> completeAbstractValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } if ( $ returnType instanceof ObjectType ) { return $ this -> completeObjectValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } throw new RuntimeException ( sprintf ( 'Cannot complete value of unexpected type "%s".' , $ returnType ) ) ; }
11893	private function createEditForm ( CustomField $ entity , $ type ) { $ form = $ this -> createForm ( 'custom_field_choice' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfield_update' , array ( 'id' => $ entity -> getId ( ) ) ) , 'method' => 'PUT' , 'type' => $ type , 'group_widget' => 'hidden' ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Update' ) ) ; return $ form ; }
4477	public function untrack ( ) : void { if ( $ this -> client -> call ( 'track' , 'untrack' , $ this -> jid ) ) { $ this -> tracked = false ; } }
10659	protected function normalizeHeaderName ( $ keyName ) { if ( ! is_string ( $ keyName ) ) { return null ; } return ucwords ( trim ( strtolower ( $ keyName ) ) , '-' ) ? : null ; }
11459	public function attachFile ( string $ sFileName , string $ sContent , string $ sType ) : bool { $ this -> _aAttachments [ ] = array ( "name" => $ sFileName , "content" => $ sContent , "type" => $ sType ) ; return true ; }
7648	public function stream_close ( ) { @ fclose ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; }
12911	public function getCountSQL ( ) { $ statement = [ ] ; if ( $ this -> distinct ) { $ distinct = 'DISTINCT ' ; } else { $ distinct = '' ; } $ statement [ ] = "(SELECT $distinct`" . $ this -> table . "`.*" ; $ statement [ ] = $ this -> getFrom ( ) ; $ statement [ ] = $ this -> getJoin ( ) ; $ statement [ ] = $ this -> getWhere ( ) ; $ statement [ ] = $ this -> getOrder ( ) ; $ statement [ ] = ")" ; foreach ( $ this -> unions as $ union ) { $ statement [ ] = "UNION " . $ distinct ; $ statement [ ] = $ union -> getCountSQL ( ) ; } $ statement = array_filter ( $ statement ) ; $ sql = implode ( "\n" , $ statement ) ; return $ sql ; }
7673	function TbsStorePark ( ) { if ( $ this -> TbsCurrIdx !== false ) { $ this -> TbsStoreLst [ $ this -> TbsCurrIdx ] = array ( 'src' => $ this -> TBS -> Source , 'onshow' => true ) ; $ this -> TBS -> Source = '' ; $ this -> TbsCurrIdx = false ; } }
8845	public function build ( ContainerBuilder $ container ) { $ container -> addCompilerPass ( new ThemeCompilerPass ( ) , PassConfig :: TYPE_BEFORE_OPTIMIZATION , - 10 ) ; $ container -> addCompilerPass ( new ThemeProviderPass ( ) ) ; }
9513	public function setMatchModeByModeName ( $ modeName ) { $ modes = [ 'all' => 0 , 'any' => 1 , 'phrase' => 2 , 'boolean' => 3 , 'extended' => 4 , 'fullscan' => 5 , ] ; if ( array_key_exists ( $ modeName , $ modes ) ) { $ mode = $ modes [ $ modeName ] ; $ this -> SetMatchMode ( $ mode ) ; } else { throw new \ LogicException ( 'Wrong Mode' ) ; } }
12592	public function toSQLString ( ) { if ( $ this -> operator == 'IN' ) { $ sql = '(' ; $ komma = '' ; for ( $ i = 0 ; $ i < count ( $ this -> operation ) ; $ i ++ ) { $ sql .= $ komma . '?' ; $ komma = ',' ; } $ sql .= ')' ; return $ sql ; } elseif ( $ this -> operator == 'BETWEEN' ) { return '? AND ?' ; } }
7459	private function color ( string $ color ) : Font { $ this -> color = $ color ; if ( $ this -> background ) { $ this -> turnToBackground ( ) ; } return $ this ; }
7159	protected function compileKeyboard ( Keyboard $ keyboard ) { $ firstButton = collect ( $ keyboard -> getButtons ( ) ) -> first ( ) ; if ( $ firstButton instanceof PayloadButton || $ firstButton instanceof UrlButton ) { return $ this -> compileInlineKeyboard ( $ keyboard ) ; } return $ this -> compileReplyKeyboard ( $ keyboard ) ; }
8423	public function mappings ( Request $ request ) { $ table = new \ cli \ Table ( ) ; $ table -> setHeaders ( [ 'Mapping' , 'Database' , 'Models path' ] ) ; $ rows = [ ] ; $ mappings = Mapping :: getMappings ( ) ; usort ( $ mappings , function ( array $ a , array $ b ) { return strcmp ( $ a [ 'config' ] [ 'name' ] , $ b [ 'config' ] [ 'name' ] ) ; } ) ; foreach ( $ mappings as $ mapping ) { $ rows [ ] = [ $ mapping [ 'config' ] [ 'name' ] , $ mapping [ 'config' ] [ 'database' ] , $ mapping [ 'config' ] [ 'models' ] [ 'path' ] , ] ; } $ table -> setRows ( $ rows ) ; $ table -> display ( ) ; }
5660	private function collectSelectOptions ( $ node ) { $ options = array ( ) ; if ( $ node -> name === 'option' ) { $ options [ ] = $ this -> tags ( ) -> createTag ( $ node -> name , $ this -> attributes ( $ node ) ) -> addContent ( $ this -> innerHtml ( $ node ) ) ; } if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ options = array_merge ( $ options , $ this -> collectSelectOptions ( $ child ) ) ; } } return $ options ; }
12357	public function updateEntryName ( ContentfulEntry $ entry ) { $ displayField = $ this -> getDisplayField ( ) ; $ values = array_values ( ( array ) $ entry -> { $ displayField } ) ; $ entry -> setName ( isset ( $ values [ 0 ] ) ? $ values [ 0 ] : 'Untitled' ) ; }
4610	public function geo ( $ sLat , $ sLon , $ iHeight ) { $ this -> sData .= 'GEO:' . $ sLat . ',' . $ sLon . ',' . $ iHeight . "\n" ; return $ this ; }
7705	function _GetAttValPos ( $ Att ) { if ( $ this -> pST_Src === false ) $ this -> pST_Src = substr ( $ this -> Txt , $ this -> PosBeg , $ this -> pST_PosEnd - $ this -> PosBeg + 1 ) ; $ a = ' ' . $ Att . '="' ; $ p0 = strpos ( $ this -> pST_Src , $ a ) ; if ( $ p0 !== false ) { $ p1 = $ p0 + strlen ( $ a ) ; $ p2 = strpos ( $ this -> pST_Src , '"' , $ p1 ) ; if ( $ p2 !== false ) return array ( $ p1 , $ p2 - $ p1 , $ p0 , $ p2 - $ p0 + 1 ) ; } return false ; }
9950	public function duplicateStyle ( Style $ pCellStyle , $ pRange ) { $ workbook = $ this -> parent ; if ( $ existingStyle = $ this -> parent -> getCellXfByHashCode ( $ pCellStyle -> getHashCode ( ) ) ) { $ xfIndex = $ existingStyle -> getIndex ( ) ; } else { $ workbook -> addCellXf ( $ pCellStyle ) ; $ xfIndex = $ pCellStyle -> getIndex ( ) ; } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> getCell ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row ) -> setXfIndex ( $ xfIndex ) ; } } return $ this ; }
1266	private function createRecoverLabelRequest ( $ trackingData , $ labelSpecificationOpts = null , $ labelDeliveryOpts = null , $ translateOpts = null ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'LabelRecoveryRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LabelRecovery' ) ) ; if ( is_string ( $ trackingData ) ) { $ container -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ trackingData ) ) ; } elseif ( is_array ( $ trackingData ) ) { $ referenceNumber = $ container -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) ; $ referenceNumber -> appendChild ( $ xml -> createElement ( 'Value' , $ trackingData [ 'value' ] ) ) ; $ container -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ trackingData [ 'shipperNumber' ] ) ) ; } if ( ! empty ( $ labelSpecificationOpts ) ) { $ labelSpec = $ request -> appendChild ( $ xml -> createElement ( 'LabelSpecification' ) ) ; if ( isset ( $ labelSpecificationOpts [ 'userAgent' ] ) ) { $ labelSpec -> appendChild ( $ xml -> createElement ( 'HTTPUserAgent' , $ labelSpecificationOpts [ 'userAgent' ] ) ) ; } if ( isset ( $ labelSpecificationOpts [ 'imageFormat' ] ) ) { $ format = $ labelSpec -> appendChild ( $ xml -> createElement ( 'LabelImageFormat' ) ) ; $ format -> appendChild ( $ xml -> createElement ( 'Code' , $ labelSpecificationOpts [ 'imageFormat' ] ) ) ; } } if ( ! empty ( $ labelDeliveryOpts ) ) { $ labelDelivery = $ request -> appendChild ( $ xml -> createElement ( 'LabelDelivery' ) ) ; $ labelDelivery -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' , $ labelDeliveryOpts [ 'link' ] ) ) ; } if ( ! empty ( $ translateOpts ) ) { $ translate = $ request -> appendChild ( $ xml -> createElement ( 'Translate' ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'LanguageCode' , $ translateOpts [ 'language' ] ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'DialectCode' , $ translateOpts [ 'dialect' ] ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'Code' , '01' ) ) ; } return $ xml -> saveXML ( ) ; }
38	protected function initStyles ( OutputInterface $ output ) { $ this -> colors = array ( 'green' , 'yellow' , 'cyan' , 'magenta' , 'blue' , ) ; foreach ( $ this -> colors as $ color ) { $ style = new OutputFormatterStyle ( $ color ) ; $ output -> getFormatter ( ) -> setStyle ( $ color , $ style ) ; } }
3759	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) -> getName ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_langcode' , [ ] , 'contao_tl_metamodel_attribute' ) , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_value' , [ ] , 'contao_tl_metamodel_attribute' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) -> getName ( ) ) , true ) ) ; }
3921	private function processFile ( $ fileName ) { $ file = new File ( $ fileName ) ; $ meta = $ this -> metaInformation [ dirname ( $ fileName ) ] [ $ file -> basename ] ; $ title = strlen ( $ meta [ 'title' ] ) ? $ meta [ 'title' ] : StringUtil :: specialchars ( $ file -> basename ) ; if ( strlen ( $ meta [ 'caption' ] ) ) { $ altText = $ meta [ 'caption' ] ; } else { $ altText = ucfirst ( str_replace ( '_' , ' ' , preg_replace ( '/^[0-9]+_/' , '' , $ file -> filename ) ) ) ; } $ information = [ 'file' => $ fileName , 'mtime' => $ file -> mtime , 'alt' => $ altText , 'caption' => ( ! empty ( $ meta [ 'caption' ] ) ? $ meta [ 'caption' ] : '' ) , 'title' => $ title , 'metafile' => $ meta , 'icon' => 'assets/contao/images/' . $ file -> icon , 'extension' => $ file -> extension , 'size' => $ file -> filesize , 'sizetext' => sprintf ( '(%s)' , Controller :: getReadableSize ( $ file -> filesize , 2 ) ) , 'url' => StringUtil :: specialchars ( $ this -> getDownloadLink ( $ fileName ) ) ] ; if ( $ information [ 'isGdImage' ] = $ file -> isGdImage ) { $ information [ 'src' ] = urldecode ( $ this -> resizeImage ( $ fileName ) ) ; if ( file_exists ( TL_ROOT . '/' . $ information [ 'src' ] ) ) { $ size = getimagesize ( TL_ROOT . '/' . $ information [ 'src' ] ) ; $ information [ 'lb' ] = 'lb' . $ this -> getLightboxId ( ) ; $ information [ 'w' ] = $ size [ 0 ] ; $ information [ 'h' ] = $ size [ 1 ] ; $ information [ 'wh' ] = $ size [ 3 ] ; } } if ( $ information [ 'isSvgImage' ] = $ file -> isSvgImage ) { $ information [ 'src' ] = $ fileName ; } if ( $ information [ 'isPicture' ] = ( int ) $ this -> resizeImages [ 2 ] ) { $ picture = Picture :: create ( $ file , $ this -> getResizeImages ( ) ) -> getTemplateData ( ) ; $ picture [ 'alt' ] = $ altText ; $ picture [ 'title' ] = $ title ; $ information [ 'picture' ] = $ picture ; } $ this -> modifiedTime [ ] = $ file -> mtime ; $ this -> outputBuffer [ ] = $ information ; }
12283	public function render ( array $ data = null ) : string { $ this -> init ( $ data ?? [ ] ) ; return trim ( $ this -> make ( static :: LAYOUT_NAME ) ) . PHP_EOL ; }
3485	public static function resolve ( ) : SignatureGeneratorInterface { self :: addDefaultResolvers ( ) ; foreach ( self :: $ resolvers as $ resolver ) { if ( $ generator = $ resolver ( ) ) { return $ generator ; } } throw new \ LogicException ( 'Cannot resolve available JWT Signature Generator.' ) ; }
8776	public function route ( $ name , array $ params = null , $ secure = false ) { $ routes = file_exists ( cache_path ( 'routes.php' ) ) ? require cache_path ( 'routes.php' ) : app ( 'route' ) -> getRoutes ( ) ; $ found = false ; foreach ( $ routes as $ key => $ value ) { if ( $ value [ 'alias' ] == $ name ) { $ found = true ; break ; } } if ( $ found ) { if ( strstr ( $ routes [ $ key ] [ 'route' ] , '{' ) ) { $ segment = explode ( '/' , $ routes [ $ key ] [ 'route' ] ) ; $ i = 0 ; foreach ( $ segment as $ key => $ value ) { if ( strstr ( $ value , '{' ) ) { $ segment [ $ key ] = $ params [ $ i ] ; $ i ++ ; } } $ newUrl = implode ( '/' , $ segment ) ; } else { $ newUrl = $ routes [ $ key ] [ 'route' ] ; } $ data = str_replace ( $ this -> base , '' , $ this -> url ) . '/' . $ newUrl ; return $ this -> getUrl ( $ data , $ secure ) ; } return $ this -> getUrl ( $ this -> url , $ secure ) ; }
12522	public function renderWidget ( array $ fields , $ customFieldOrClass , $ documentType = 'html' , $ slug = null ) { return $ this -> container -> get ( 'chill.custom_field.helper' ) -> renderCustomField ( $ fields , $ customFieldOrClass , $ documentType , $ slug ) ; }
1519	public function addToRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doAddToRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
2199	public static function findPublishedByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
9145	private static function resetLocaleTo ( $ localeSaved ) { $ localeData = explode ( ';' , $ localeSaved ) ; foreach ( $ localeData as $ identifier ) { if ( ! strchr ( $ identifier , '=' ) ) { continue ; } $ type = $ value = null ; sscanf ( $ identifier , "%s=%s" , $ type , $ value ) ; switch ( $ type ) { case 'LC_ALL' : setlocale ( LC_ALL , $ value ) ; break ; case 'LC_COLLATE' : setlocale ( LC_COLLATE , $ value ) ; break ; case 'LC_CTYPE' : setlocale ( LC_CTYPE , $ value ) ; break ; case 'LC_MONETARY' : setlocale ( LC_MONETARY , $ value ) ; break ; case 'LC_NUMERIC' : setlocale ( LC_NUMERIC , $ value ) ; break ; case 'LC_TIME' : setlocale ( LC_TIME , $ value ) ; break ; case 'LC_MESSAGES' : setlocale ( LC_MESSAGES , $ value ) ; break ; default : ; break ; } } }
2148	public function removeSubscriptions ( $ intUser , $ strMode ) { if ( ! $ intUser ) { return ; } if ( $ strMode == 'close_delete' ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } else { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active='' WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } }
7575	public function getCustomFields ( $ parameters = array ( ) ) { $ this -> _harvest = $ this -> _harvestHelper -> parse ( 'getCustomFields' , $ parameters ) ; if ( ! array_key_exists ( 'id' , $ parameters ) ) $ this -> _harvest [ 'url' ] = $ this -> _harvest [ 'url' ] . '/' ; $ this -> sendRequest ( ) ; }
6680	public static function getDateTime ( $ format , $ timestamp = 'now' ) { $ date = strtotime ( $ timestamp ) ; if ( ! $ date ) { return $ timestamp ; } return date ( $ format , $ date ) ; }
4140	protected function getRequestString ( ) { $ params = array_merge ( $ this -> getParams , $ this -> postParams , $ this -> getOauthParameters ( ) ) ; $ params = $ this -> curl -> getParams ( $ params ) ; return rawurlencode ( $ params ) ; }
4177	public function getMigration ( ) { return $ this -> migration ? : $ this -> migration = new Migration ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
12106	public function error ( $ level , $ message , $ file , $ line ) { throw new SyntaxException ( $ message , $ file , $ line , $ level ) ; }
10191	public function validate ( ) { foreach ( func_get_args ( ) as $ key ) { $ value = $ this -> parameters -> get ( $ key ) ; if ( ! isset ( $ value ) ) { throw new InvalidRequestException ( "The $key parameter is required" ) ; } } }
8557	public function setType ( $ type ) { if ( ! $ this -> isNumericArray ( $ type ) ) { $ type = array ( $ type ) ; } $ this -> fields [ 'Type' ] [ 'FieldValue' ] = $ type ; return $ this ; }
12482	private function mapByGeneration ( $ mapByDepthDesc , $ mapById ) { $ result = [ ] ; foreach ( $ mapByDepthDesc as $ depth => $ ids ) { foreach ( $ ids as $ custId ) { $ entry = $ mapById [ $ custId ] ; $ path = $ entry -> getPath ( ) ; $ parents = $ this -> hlpTree -> getParentsFromPathReversed ( $ path ) ; $ level = 0 ; foreach ( $ parents as $ parentId ) { $ level += 1 ; if ( ! isset ( $ result [ $ parentId ] ) ) { $ result [ $ parentId ] = [ ] ; } if ( ! isset ( $ result [ $ parentId ] [ $ level ] ) ) { $ result [ $ parentId ] [ $ level ] = [ ] ; } $ result [ $ parentId ] [ $ level ] [ ] = $ custId ; } } } return $ result ; }
3648	protected function registerBinput ( ) { $ this -> app -> singleton ( 'binput' , function ( Container $ app ) { $ request = $ app [ 'request' ] ; $ security = $ app [ 'security' ] ; $ binput = new Binput ( $ request , $ security ) ; $ app -> refresh ( 'request' , $ binput , 'setRequest' ) ; return $ binput ; } ) ; $ this -> app -> alias ( 'binput' , Binput :: class ) ; }
1262	protected function compileEndpointUrl ( $ segment ) { $ base = ( $ this -> useIntegration ? $ this -> integrationBaseUrl : $ this -> productionBaseUrl ) ; return $ base . $ segment ; }
7402	public function Get ( $ name = null , $ value = null , ... $ param ) { if ( ! isset ( $ name ) ) return self :: $ config ; return isset ( $ value ) ? self :: $ config [ $ name ] [ $ value ] : ( isset ( self :: $ config [ $ name ] ) ? self :: $ config [ $ name ] : null ) ; }
11886	public function addChild ( $ structureName , $ prefix = '' , $ suffix = '' ) { if ( isset ( $ this -> children [ $ structureName ] ) ) { throw new DefinitionDuplicateException ( sprintf ( 'Child structure with same name "%s" already exists' , $ structureName ) ) ; } $ this -> children [ $ structureName ] = array ( 'name' => $ structureName , 'prefix' => ( string ) $ prefix , 'suffix' => ( string ) $ suffix ) ; }
10753	protected function getMobile ( UserEntity $ user ) { $ metadata = $ user -> getMetadata ( ) ; foreach ( $ metadata as $ meta ) { if ( 'cellulare' == $ meta -> getKey ( ) ) { return $ meta -> getValue ( ) ; } } return null ; }
4302	public function groupUncollapse ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ curDepth = 0 ; foreach ( $ this -> rootInstance -> groupStackRef as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entryKeys = \ array_keys ( $ this -> internal -> getCurrentGroups ( $ this -> rootInstance -> logRef , $ curDepth ) ) ; foreach ( $ entryKeys as $ key ) { $ this -> rootInstance -> logRef [ $ key ] [ 0 ] = 'group' ; } $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; }
10817	public static function info ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'info' , $ length , $ separator ) ; }
11437	protected function init ( array $ options = null ) { $ this -> boot ( ) ; if ( ! is_null ( $ options ) ) { $ this -> setOptions ( array_merge ( $ this -> getOptions ( ) , $ options ) ) ; } }
2113	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'articlenav' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } global $ objPage ; $ this -> objArticles = ArticleModel :: findPublishedWithTeaserByPidAndColumn ( $ objPage -> id , $ this -> strColumn ) ; if ( $ this -> objArticles === null ) { return '' ; } if ( ! Input :: get ( 'articles' ) ) { if ( ! $ this -> loadFirst ) { return '' ; } $ objArticle = $ this -> objArticles -> current ( ) ; $ strAlias = $ objArticle -> alias ? : $ objArticle -> id ; $ this -> redirect ( $ objPage -> getFrontendUrl ( '/articles/' . $ strAlias ) ) ; } return parent :: generate ( ) ; }
10589	public function buildPayoutFromId ( $ sPayoutId ) { $ oPayout = new Freeagent \ DataWrapper \ PayoutVO ( ) ; $ oPayout -> setId ( $ sPayoutId ) ; try { $ oDets = $ this -> getTxnChargeDetails ( $ sPayoutId ) ; $ oPayout -> setDateArrival ( strtotime ( $ oDets -> PaymentDate ) ) -> setCurrency ( $ oDets -> GrossAmount -> currencyID ) ; $ oPayout -> addCharge ( $ this -> buildChargeFromTransaction ( $ sPayoutId ) ) ; } catch ( \ Exception $ oE ) { } return $ oPayout ; }
4518	public function preFlush ( PreFlushEventArgs $ args ) { $ entities = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getScheduledEntityInsertions ( ) ; foreach ( $ entities as $ entity ) { if ( ! $ entity instanceof Parameter ) { continue ; } $ entity -> setValue ( serialize ( $ entity -> getValue ( ) ) ) ; } }
12820	public function execute ( callable $ callback , array $ vars ) : Response { $ arguments = $ this -> resolveDependencies ( $ callback , $ vars ) ; return call_user_func_array ( $ callback , $ arguments ) ; }
1320	private function curlOptions ( ) { $ options = [ CURLOPT_CONNECTTIMEOUT => $ this -> connectionTimeout , CURLOPT_HEADER => true , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYHOST => 2 , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_TIMEOUT => $ this -> timeout , CURLOPT_USERAGENT => $ this -> userAgent , ] ; if ( $ this -> useCAFile ( ) ) { $ options [ CURLOPT_CAINFO ] = __DIR__ . DIRECTORY_SEPARATOR . 'cacert.pem' ; } if ( $ this -> gzipEncoding ) { $ options [ CURLOPT_ENCODING ] = 'gzip' ; } if ( ! empty ( $ this -> proxy ) ) { $ options [ CURLOPT_PROXY ] = $ this -> proxy [ 'CURLOPT_PROXY' ] ; $ options [ CURLOPT_PROXYUSERPWD ] = $ this -> proxy [ 'CURLOPT_PROXYUSERPWD' ] ; $ options [ CURLOPT_PROXYPORT ] = $ this -> proxy [ 'CURLOPT_PROXYPORT' ] ; $ options [ CURLOPT_PROXYAUTH ] = CURLAUTH_BASIC ; $ options [ CURLOPT_PROXYTYPE ] = CURLPROXY_HTTP ; } return $ options ; }
7854	protected function deleteIfForced ( array $ files ) { if ( ! $ this -> option ( 'force' ) ) return ; foreach ( $ files as $ file ) { if ( $ this -> files -> exists ( $ path = $ this -> getPath ( $ file ) ) ) { $ this -> files -> delete ( $ path ) ; } } }
10099	private function writeString ( $ row , $ col , $ str , $ xfIndex ) { $ this -> writeLabelSst ( $ row , $ col , $ str , $ xfIndex ) ; }
3251	public function scopeFindByUser ( $ query , $ userId ) { if ( empty ( $ userId ) ) return ; $ cart = $ query -> whereUser ( $ userId ) -> first ( ) ; if ( empty ( $ cart ) ) { $ cart = call_user_func ( Config :: get ( 'shop.cart' ) . '::create' , [ 'user_id' => $ userId ] ) ; } return $ cart ; }
11939	public function findOne ( $ params = [ ] ) { return $ this -> populateRecord ( $ this -> find ( $ params ) -> one ( $ this -> interface -> db ) ) ; }
9171	public function getControllerPluginConfig ( ) { return [ 'aliases' => [ 'email' => Controller \ Plugin \ Email :: class , 'mutex' => Controller \ Plugin \ Mutex :: class , 'referer' => Controller \ Plugin \ Referer :: class , 'settings' => Controller \ Plugin \ Settings :: class , 'thumbnail' => Controller \ Plugin \ Thumbnail :: class , 'zettaUrl' => Controller \ Plugin \ Url :: class , ] , 'factories' => [ Controller \ Plugin \ Email :: class => Controller \ Plugin \ Factory \ EmailFactory :: class , Controller \ Plugin \ Mutex :: class => Controller \ Plugin \ Factory \ MutexFactory :: class , Controller \ Plugin \ Referer :: class => InvokableFactory :: class , Controller \ Plugin \ Settings :: class => Factory \ WithSettingsFactory :: class , Controller \ Plugin \ Thumbnail :: class => Factory \ WithThumbnailFactory :: class , Controller \ Plugin \ Url :: class => Factory \ WithUrlConfigFactory :: class , ] , ] ; }
420	public function run ( ) { $ block = ob_get_clean ( ) ; if ( $ this -> renderInPlace ) { echo $ block ; } $ this -> view -> blocks [ $ this -> getId ( ) ] = $ block ; }
11650	protected function _authenticateValidateResult ( $ resultIdentity ) { $ code = Zend_Auth_Result :: FAILURE_CREDENTIAL_INVALID ; $ message = 'Supplied credential is invalid.' ; if ( Benri_Util_String :: verifyPassword ( $ this -> _credential , $ resultIdentity [ $ this -> _credentialColumn ] ) ) { $ code = Zend_Auth_Result :: SUCCESS ; $ message = 'Authentication successful.' ; $ this -> _resultRow = $ resultIdentity ; } $ this -> _authenticateResultInfo [ 'code' ] = $ code ; $ this -> _authenticateResultInfo [ 'messages' ] [ ] = $ message ; return $ this -> _authenticateCreateAuthResult ( ) ; }
5438	public function match ( $ subject , & $ match ) { if ( count ( $ this -> patterns ) === 0 ) { return false ; } if ( ! preg_match ( $ this -> getCompoundedRegex ( ) , $ subject , $ matches ) ) { $ match = '' ; return false ; } $ match = $ matches [ 0 ] ; for ( $ i = 1 ; $ i < count ( $ matches ) ; $ i ++ ) { if ( $ matches [ $ i ] ) { return $ this -> labels [ $ i - 1 ] ; } } return true ; }
2269	public function lockTables ( $ arrTables ) { $ arrLocks = array ( ) ; foreach ( $ arrTables as $ table => $ mode ) { $ arrLocks [ ] = $ this -> resConnection -> quoteIdentifier ( $ table ) . ' ' . $ mode ; } $ this -> resConnection -> exec ( 'LOCK TABLES ' . implode ( ', ' , $ arrLocks ) . ';' ) ; }
9633	public function onBeforeWrite ( ) { $ return = parent :: onBeforeWrite ( ) ; $ exists = self :: get ( ) -> filter ( 'Name' , $ this -> Name ) -> exclude ( 'ID' , $ this -> ID ) ; if ( $ exists -> count ( ) ) { throw new ValidationException ( _t ( 'Moo_EditableField.UNIQUENAME' , 'Field name "{name}" must be unique' , '' , [ 'name' => $ this -> Name ] ) ) ; } $ this -> Name = preg_replace ( '/[^a-zA-Z0-9_]+/' , '' , $ this -> Name ) ; $ customSettings = $ this -> getSettings ( ) ; if ( empty ( $ customSettings ) ) { $ customSettings = ( array ) Controller :: curr ( ) -> getRequest ( ) -> postVar ( 'CustomSettings' ) ; } if ( ! empty ( $ this -> customSettingsFields ) ) { $ customSettings = array_intersect_key ( $ customSettings , array_flip ( ( array ) $ this -> customSettingsFields ) ) ; } $ this -> setSettings ( $ customSettings ) ; return $ return ; }
7866	protected function drawBorderTop ( $ isCore = false ) { $ crossroads = $ isCore ? static :: CROSSROADS_UP : static :: CROSSROADS ; $ this -> drawBorder ( static :: BORDER_NW , $ crossroads , static :: BORDER_NE ) ; $ this -> geometry -> increaseNesting ( ) ; }
6839	public function get ( $ key ) { if ( isset ( $ this -> objects [ $ key ] ) ) { return $ this -> objects [ $ key ] ; } throw new InjectorException ( "obj $key not found" ) ; }
4764	protected function validateDeliveryAddressOptIn ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_deliveryaddress' ) ; $ changeExistigAddress = ( int ) $ this -> getRequestParameter ( 'oegdproptin_changeDelAddress' ) ; $ addressId = $ this -> getRequestParameter ( 'oxaddressid' ) ; $ deliveryAddressData = $ this -> _getDelAddressData ( ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinDeliveryAddress' ) && ( ( null == $ addressId ) || ( '-1' == $ addressId ) || ( 1 == $ changeExistigAddress ) ) && ! empty ( $ deliveryAddressData ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
6141	public function checkPass ( $ password = null ) { if ( $ password === null ) { $ password = $ this -> pass ; } if ( strlen ( $ password ) == 0 ) { return true ; } $ pattern = "/^(" . $ this -> regex [ "alphanum" ] . "|" . $ this -> regex [ "mark" ] . "|" . $ this -> regex [ "escaped" ] . "|[;:&=+$,])+$/" ; $ status = @ preg_match ( $ pattern , $ password ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI password validation failed" ) ; } return ( $ status == 1 ) ; }
1608	public function bulk ( $ redirects , $ separator , $ type , $ siteId ) { $ rawRedirects = array_map ( function ( $ line ) use ( $ separator ) { return str_getcsv ( $ line , $ separator ) ; } , explode ( PHP_EOL , $ redirects ) ) ; $ newFormatted = [ ] ; foreach ( $ rawRedirects as $ redirect ) { $ record = new RedirectRecord ( ) ; $ record -> uri = $ redirect [ 0 ] ; $ record -> to = $ redirect [ 1 ] ; $ record -> type = array_key_exists ( 2 , $ redirect ) ? $ redirect [ 2 ] : $ type ; $ record -> siteId = $ siteId ; $ record -> save ( ) ; $ newFormatted [ ] = [ 'id' => $ record -> id , 'uri' => $ record -> uri , 'to' => $ record -> to , 'type' => $ record -> type , 'siteId' => $ record -> siteId , ] ; } return [ $ newFormatted , false ] ; }
7651	public function rename ( $ path_from , $ path_to ) { if ( $ this -> getContainerName ( $ path_from ) != $ this -> getContainerName ( $ path_to ) ) { throw new BlobException ( 'Container name can not be changed.' ) ; } if ( $ this -> getFileName ( $ path_from ) == $ this -> getContainerName ( $ path_to ) ) { return true ; } $ this -> getStorageClient ( $ path_from ) -> copyBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) , $ this -> getContainerName ( $ path_to ) , $ this -> getFileName ( $ path_to ) ) ; $ this -> getStorageClient ( $ path_from ) -> deleteBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) ) ; clearstatcache ( true , $ path_from ) ; clearstatcache ( true , $ path_to ) ; return true ; }
10064	public function all ( ) { $ meta = $ this -> metaModel :: get ( [ 'key' , 'value' , 'type' ] ) ; $ data = [ ] ; foreach ( $ meta as $ m ) { $ data [ $ m -> key ] = $ m -> value ; } return $ data ; }
9003	protected function extra_tablenav ( $ which ) { if ( $ which !== 'top' ) { return ; } $ this -> months_dropdown ( '' ) ; $ selected = isset ( $ _GET [ 'level' ] ) ? $ _GET [ 'level' ] : '' ; ?> <label for="filter-by-level" class="screen-reader-text"> <?php echo $ this -> translations [ 'levelFilterLabel' ] ; ?> </label> <select name="level" id="filter-by-level"> <option value=""> <?php echo $ this -> translations [ 'allLevels' ] ; ?> </option> <?php foreach ( $ this -> get_levels ( ) as $ level => $ label ) : ?> <option value=" <?php echo esc_attr ( $ level ) ; ?> " <?php selected ( $ selected , $ level ) ; ?> > <?php echo $ label ; ?> </option> <?php endforeach ; ?> </select> <?php submit_button ( $ this -> translations [ 'filter' ] , 'button' , 'filter_action' , false ) ; }
5639	public function paintGroupStart ( $ test_name , $ size ) { if ( ! isset ( $ this -> size ) ) { $ this -> size = $ size ; } if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintHeader ( $ test_name ) ; } $ this -> test_stack [ ] = $ test_name ; }
7247	protected function purge ( ShipmentInterface $ shipment ) { foreach ( $ shipment -> getItems ( ) as $ item ) { if ( 0 == $ item -> getAvailable ( ) ) { $ shipment -> removeItem ( $ item ) ; } } }
10871	public function existLogin ( string $ login ) : int { return ( int ) $ this -> connection -> select ( self :: COLUMN_ID ) -> from ( $ this -> tableIdentity ) -> where ( [ 'login' => $ login ] ) -> fetchSingle ( ) ; }
8725	public function translationModel ( ) { $ translation = new TranslationModel ( ) ; $ translation -> setConnection ( $ this -> getI18nConnection ( ) ) ; $ translation -> setTable ( $ this -> getI18nTable ( ) ) ; $ translation -> setKeyName ( $ this -> getForeignKey ( ) ) ; $ translation -> setLocaleKey ( $ this -> getLocaleKey ( ) ) ; if ( $ attributes = $ this -> translatableAttributes ( ) ) { $ translation -> fillable ( array_intersect ( $ attributes , $ this -> getFillable ( ) ) ) ; } return $ translation ; }
4963	public function addViewTemplate ( $ name , $ template , $ vars = [ ] , $ priority = 0 ) { if ( is_int ( $ vars ) ) { $ priority = $ vars ; $ vars = [ ] ; } $ model = new ViewModel ( $ vars ) ; $ model -> setTemplate ( $ template ) ; return $ this -> addViewModel ( $ name , $ model , $ priority ) ; }
8061	protected function runWorkerProcess ( WorkerInterface $ worker , SimpleSocket $ simpleSocket , $ i ) { $ replacements = array ( 'basename' => basename ( $ _SERVER [ 'PHP_SELF' ] ) , 'fullname' => $ _SERVER [ 'PHP_SELF' ] , 'class' => get_class ( $ worker ) , 'i' => $ i , 'state' => 'free' ) ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; $ this -> worker -> onProcessCreate ( $ this -> semaphore ) ; while ( TRUE ) { $ output = array ( 'pid' => getmypid ( ) ) ; try { $ replacements [ 'state' ] = 'free' ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; $ cmd = $ simpleSocket -> receive ( ) ; if ( ! isset ( $ cmd [ 'cmd' ] ) ) { break ; } $ replacements [ 'state' ] = 'busy' ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; if ( $ cmd [ 'cmd' ] == 'run' ) { try { $ output [ 'data' ] = $ this -> worker -> run ( $ cmd [ 'data' ] ) ; } catch ( \ Exception $ e ) { $ output [ 'workerException' ] = array ( 'class' => get_class ( $ e ) , 'message' => $ e -> getMessage ( ) , 'trace' => $ e -> getTraceAsString ( ) ) ; } $ simpleSocket -> send ( $ output ) ; } elseif ( $ cmd [ 'cmd' ] == 'exit' ) { break ; } } catch ( SimpleSocketException $ e ) { break ; } catch ( \ Exception $ e ) { $ output [ 'poolException' ] = array ( 'class' => get_class ( $ e ) , 'message' => $ e -> getMessage ( ) , 'trace' => $ e -> getTraceAsString ( ) ) ; $ simpleSocket -> send ( $ output ) ; } } $ this -> worker -> onProcessDestroy ( ) ; $ this -> exitPhp ( 0 ) ; }
5941	public function connect ( ) { if ( $ this -> stream !== null ) { return ; } $ host = strval ( $ this -> config [ "host" ] ) ; $ port = strval ( $ this -> config [ "port" ] ) ; $ address = "tcp://" . $ host . ":" . $ port ; $ timeout = intval ( $ this -> config [ "timeout" ] ) ; $ this -> stream = @ stream_socket_client ( $ address , $ errno , $ errstr , $ timeout ) ; if ( $ this -> stream === false ) { throw new Ts3Exception ( StringHelper :: factory ( $ errstr ) -> toUtf8 ( ) -> toString ( ) , $ errno ) ; } @ stream_set_timeout ( $ this -> stream , $ timeout ) ; @ stream_set_blocking ( $ this -> stream , $ this -> config [ "blocking" ] ? 1 : 0 ) ; }
11413	public function batchUntagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_UNTAG , $ params ] ) ; }
3984	private function addMenu ( & $ modules , $ section , $ name , $ module , Request $ request ) { if ( ! isset ( $ modules [ $ section ] ) ) { $ modules [ $ section ] = $ this -> buildBackendMenuSection ( $ section , $ request ) ; } $ active = $ this -> isActive ( $ module [ 'route' ] , $ module [ 'param' ] , $ request ) ; $ class = 'navigation ' . $ name ; if ( isset ( $ module [ 'class' ] ) ) { $ class .= ' ' . $ module [ 'class' ] ; } if ( $ active ) { $ class .= ' active' ; } if ( $ request -> query -> has ( 'ref' ) ) { $ module [ 'param' ] [ 'ref' ] = $ request -> query -> get ( 'ref' ) ; } $ modules [ $ section ] [ 'modules' ] [ $ name ] = [ 'label' => $ module [ 'label' ] , 'title' => $ module [ 'title' ] , 'class' => $ class , 'isActive' => $ active , 'href' => $ this -> urlGenerator -> generate ( $ module [ 'route' ] , $ module [ 'param' ] ) , ] ; }
8976	public static function typeOf ( $ arg ) { if ( null === $ arg ) { return 'NULL' ; } if ( is_object ( $ arg ) ) { return get_class ( $ arg ) ; } return gettype ( $ arg ) ; }
10382	protected static function save_external_file ( $ url , $ path ) { $ data = file_get_contents ( $ url ) ; return ( $ data && self :: save_file ( $ path , $ data ) ) ? $ data : '' ; }
5960	public function clientGetByDbid ( $ dbid ) { foreach ( $ this -> clientList ( ) as $ client ) { if ( $ client [ "client_database_id" ] == $ dbid ) { return $ client ; } } throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; }
4663	public function smtp ( array $ params ) { if ( ! array_key_exists ( 'username' , $ params ) ) { throw new Exception ( 'We need a username' ) ; } if ( ! array_key_exists ( 'password' , $ params ) ) { throw new Exception ( 'We need a password' ) ; } $ this -> smtp = $ params ; $ this -> auth = true ; return $ this ; }
9702	public function addFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { $ fontHashCode = $ font -> getHashCode ( ) ; if ( isset ( $ this -> addedFonts [ $ fontHashCode ] ) ) { $ fontIndex = $ this -> addedFonts [ $ fontHashCode ] ; } else { $ countFonts = count ( $ this -> fontWriters ) ; $ fontIndex = ( $ countFonts < 4 ) ? $ countFonts : $ countFonts + 1 ; $ fontWriter = new Font ( $ font ) ; $ fontWriter -> setColorIndex ( $ this -> addColor ( $ font -> getColor ( ) -> getRGB ( ) ) ) ; $ this -> fontWriters [ ] = $ fontWriter ; $ this -> addedFonts [ $ fontHashCode ] = $ fontIndex ; } return $ fontIndex ; }
11986	function read ( $ length ) { $ l = $ this -> pos + $ length < strlen ( $ this -> data ) ? $ length : strlen ( $ this -> data ) - $ this -> pos ; $ result = substr ( $ this -> data , $ this -> pos , $ l ) ; $ this -> pos += $ l ; return $ result ; }
8962	private static function extractArrayCriteria ( $ key , array $ criteria ) { if ( ! empty ( $ criteria [ $ key ] ) ) { return array ( $ criteria [ $ key ] ) ; } if ( ! empty ( $ criteria [ $ key . 's' ] ) ) { return $ criteria [ $ key . 's' ] ; } return array ( ) ; }
2380	public static function trimsplit ( $ strPattern , $ strString ) { if ( \ strlen ( $ strPattern ) == 1 ) { $ arrFragments = array_map ( 'trim' , explode ( $ strPattern , $ strString ) ) ; } else { $ arrFragments = array_map ( 'trim' , preg_split ( '/' . $ strPattern . '/ui' , $ strString ) ) ; } if ( \ count ( $ arrFragments ) < 2 && ! \ strlen ( $ arrFragments [ 0 ] ) ) { $ arrFragments = array ( ) ; } return $ arrFragments ; }
2397	public function parseBbCode ( $ strComment ) { $ arrSearch = array ( '@\[b\](.*)\[/b\]@Uis' , '@\[i\](.*)\[/i\]@Uis' , '@\[u\](.*)\[/u\]@Uis' , '@\s*\[code\](.*)\[/code\]\s*@Uis' , '@\[color=([^\]" ]+)\](.*)\[/color\]@Uis' , '@\s*\[quote\](.*)\[/quote\]\s*@Uis' , '@\s*\[quote=([^\]]+)\](.*)\[/quote\]\s*@Uis' , '@\[img\]\s*([^\[" ]+\.(jpe?g|png|gif|bmp|tiff?|ico))\s*\[/img\]@i' , '@\[url\]\s*([^\[" ]+)\s*\[/url\]@i' , '@\[url=([^\]" ]+)\](.*)\[/url\]@Uis' , '@\[email\]\s*([^\[" ]+)\s*\[/email\]@i' , '@\[email=([^\]" ]+)\](.*)\[/email\]@Uis' , '@href="(([a-z0-9]+\.)*[a-z0-9]+\.([a-z]{2}|asia|biz|com|info|name|net|org|tel)(/|"))@i' ) ; $ arrReplace = array ( '<strong>$1</strong>' , '<em>$1</em>' , '<span style="text-decoration:underline">$1</span>' , "\n\n" . '<div class="code"><p>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_code' ] . '</p><pre>$1</pre></div>' . "\n\n" , '<span style="color:$1">$2</span>' , "\n\n" . '<blockquote>$1</blockquote>' . "\n\n" , "\n\n" . '<blockquote><p>' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_quote' ] , '$1' ) . '</p>$2</blockquote>' . "\n\n" , '<img src="$1" alt="" />' , '<a href="$1">$1</a>' , '<a href="$1">$2</a>' , '<a href="mailto:$1">$1</a>' , '<a href="mailto:$1">$2</a>' , 'href="http://$1' ) ; $ strComment = preg_replace ( $ arrSearch , $ arrReplace , $ strComment ) ; if ( strpos ( $ strComment , 'mailto:' ) !== false ) { $ strComment = StringUtil :: encodeEmail ( $ strComment ) ; } return $ strComment ; }
11679	protected function log ( $ message , $ priority = Logger :: DEBUG , array $ extra = [ ] ) { if ( $ this -> getLogger ( ) === null ) { return $ this ; } $ this -> getLogger ( ) -> log ( $ priority , $ message , $ extra ) ; return $ this ; }
3100	private function getItemData ( RunnerServiceContext $ context , $ itemRef ) { $ this -> getRunnerService ( ) -> assertQtiRunnerServiceContext ( $ context ) ; $ itemData = $ this -> getRunnerService ( ) -> getItemData ( $ context , $ itemRef ) ; $ itemDataVariable = $ this -> getRunnerService ( ) -> getItemVariableElementsData ( $ context , $ itemRef ) ; $ responses = $ itemData [ 'data' ] [ 'responses' ] ; foreach ( array_keys ( $ responses ) as $ responseId ) { if ( array_key_exists ( $ responseId , $ itemDataVariable ) ) { $ itemData [ 'data' ] [ 'responses' ] [ $ responseId ] = array_merge ( ... [ $ responses [ $ responseId ] , $ itemDataVariable [ $ responseId ] , ] ) ; } } return $ itemData ; }
9462	private function getEventMap ( ) { return [ WatcherInterface :: CREATE_EVENT => FilesystemEvent :: CREATE , WatcherInterface :: MODIFY_EVENT => FilesystemEvent :: MODIFY , WatcherInterface :: DELETE_EVENT => FilesystemEvent :: DELETE , WatcherInterface :: ALL_EVENT => FilesystemEvent :: ALL ] ; }
4390	protected function getXmlProvider ( ) { $ provider = OPay :: create ( 'Datatrans\Xml' ) ; $ provider -> initialize ( $ this -> getServiceItem ( ) -> getConfig ( ) ) ; return $ provider ; }
3170	protected function hasItemHrefIndexFile ( QtiRunnerServiceContext $ context , $ itemIdentifier ) { if ( $ context -> isAdaptive ( ) ) { return true ; } else { $ indexFile = $ this -> getItemHrefIndexFile ( $ context , $ itemIdentifier ) ; return $ indexFile -> exists ( ) ; } }
9613	public function register ( Container $ app ) { $ app [ 'guzzle.handler_stack' ] = function ( ) { $ stack = HandlerStack :: create ( ) ; return $ stack ; } ; $ app [ 'guzzle' ] = function ( ) use ( $ app ) { $ client = new HttpClient ( [ 'handler' => $ app [ 'guzzle.handler_stack' ] ] ) ; return $ client ; } ; }
10980	public function preRemove ( LifecycleEventArgs $ args ) : void { if ( ! $ this -> enableIndexing ) { return ; } $ this -> removeEntity ( $ args -> getObject ( ) , $ args -> getObjectManager ( ) ) ; }
9858	private function isValueInList ( Cell $ cell ) { $ cellValue = $ cell -> getValue ( ) ; $ dataValidation = $ cell -> getDataValidation ( ) ; $ formula1 = $ dataValidation -> getFormula1 ( ) ; if ( ! empty ( $ formula1 ) ) { if ( $ formula1 [ 0 ] === '"' ) { return in_array ( strtolower ( $ cellValue ) , explode ( ',' , strtolower ( trim ( $ formula1 , '"' ) ) ) , true ) ; } elseif ( strpos ( $ formula1 , ':' ) > 0 ) { $ matchFormula = '=MATCH(' . $ cell -> getCoordinate ( ) . ', ' . $ formula1 . ', 0)' ; $ calculation = Calculation :: getInstance ( $ cell -> getWorksheet ( ) -> getParent ( ) ) ; try { $ result = $ calculation -> calculateFormula ( $ matchFormula , $ cell -> getCoordinate ( ) , $ cell ) ; return $ result !== Functions :: NA ( ) ; } catch ( Exception $ ex ) { return false ; } } } return true ; }
2101	public static function getNumericDatimFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> datimFormat != '' && static :: isNumericFormat ( $ objPage -> datimFormat ) ) { return $ objPage -> datimFormat ; } } return Config :: get ( 'datimFormat' ) ; }
6989	private function addRate ( $ pair , $ rate ) { if ( ! preg_match ( '~^[A-Z]{3}/[A-Z]{3}$~' , $ pair ) ) { throw new InvalidArgumentException ( "Unexpected currency pair '$pair'." ) ; } if ( ! ( is_float ( $ rate ) && 0 < $ rate ) ) { throw new InvalidArgumentException ( "Unexpected rate '$rate'." ) ; } $ this -> rates [ $ pair ] = $ rate ; return $ this ; }
4986	public function executeAction ( $ name , array $ data = [ ] ) { if ( false !== strpos ( $ name , '.' ) ) { list ( $ name , $ childKey ) = explode ( '.' , $ name , 2 ) ; $ container = $ this -> getForm ( $ name ) ; return $ container -> executeAction ( $ childKey , $ data ) ; } return [ ] ; }
4891	protected function getTarget ( $ generateInstance = true ) { $ serviceLocator = $ this -> getServicelocator ( ) ; $ this -> getGenerator ( ) ; $ target = null ; if ( array_key_exists ( 'target' , $ this -> options ) ) { $ target = $ this -> options [ 'target' ] ; if ( is_string ( $ target ) ) { if ( $ serviceLocator -> has ( $ target ) ) { $ target = $ serviceLocator -> get ( $ target ) ; if ( $ generateInstance ) { $ target = get_class ( $ target ) ; } } else { if ( $ generateInstance ) { $ target = new $ target ; } } } } return $ target ; }
5020	public function getFieldFlags ( $ field ) { if ( ! $ this -> hasField ( $ field ) ) { return [ ] ; } if ( ! isset ( $ this -> fields [ $ field ] [ '__flags__' ] ) ) { $ this -> fields [ $ field ] [ '__flags__' ] = $ this -> copyArrayValues ( $ this -> fields [ $ field ] , [ 'flags' => [ ] , 'order' => [ 'priority' ] , 'priority' ] ) ; } return $ this -> fields [ $ field ] [ '__flags__' ] ; }
6609	public static function getIdByField ( $ field , $ value ) { $ result = self :: find ( ) -> where ( [ $ field => $ value ] ) -> limit ( 1 ) -> one ( ) ; return ( $ result ) ? $ result -> id : null ; }
9901	public function parse ( $ formula ) { $ this -> currentCharacter = 0 ; $ this -> formula = $ formula ; $ this -> lookAhead = isset ( $ formula [ 1 ] ) ? $ formula [ 1 ] : '' ; $ this -> advance ( ) ; $ this -> parseTree = $ this -> condition ( ) ; return true ; }
12703	public function publishAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "page_manager" => $ app [ "red_kite_cms.page_manager" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: publish ( $ options ) ; }
4741	private function createProfilerProbes ( $ name , ContainerBuilder $ container ) { $ key = sprintf ( "socloz_monitoring.profiler.probe.definition.%s" , $ name ) ; if ( $ container -> hasParameter ( $ key ) ) { $ definition = $ container -> getParameter ( $ key ) ; return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS | Probe :: TRACKER_TIMING , $ definition , $ container ) ) ; } else { return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS , $ container -> getParameter ( $ key . '.calls' ) , $ container ) , $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_TIMING , $ container -> getParameter ( $ key . '.timing' ) , $ container ) , ) ; } }
5837	public function transform ( $ orig , $ transformation = null , $ overrides = array ( ) ) { return $ this -> transformer -> transform ( $ orig , $ transformation , $ overrides ) ; }
12716	protected function getConcreteFromInterface ( $ interface ) { if ( ! $ this -> isAbstractExists ( $ interface ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: runtime ( sprintf ( "%s has no concrete implementation in the class binding stack." , $ interface ) ) ; } try { return $ this -> getResolvedSingleton ( $ interface ) ; } catch ( \ Exception $ e ) { } $ concrete = $ this -> bindings [ $ interface ] [ 'concrete' ] ; $ object = $ concrete instanceof \ Closure ? $ concrete ( $ this ) : $ this -> build ( $ concrete ) ; if ( $ this -> isShared ( $ interface ) ) { $ this -> markAsResolved ( $ interface , $ object , 'singleton' ) ; } else { $ this -> markAsResolved ( $ interface , $ object ) ; } return $ object ; }
3659	public static function getSubscribedServices ( ) { return [ Connection :: class => Connection :: class , Input :: class => Input :: class , InsertTags :: class => InsertTags :: class , Session :: class => Session :: class , IMetaModelsServiceContainer :: class => IMetaModelsServiceContainer :: class ] ; }
2960	public function sendMessage ( $ str , $ waitForReply = 0.1 ) { $ this -> _buffer .= $ str ; if ( $ this -> autoFlush === true ) { $ this -> serialflush ( ) ; } usleep ( ( int ) ( $ waitForReply * 1000000 ) ) ; }
11343	public function addField ( FormField $ field ) { $ this -> fields [ ] = $ field ; if ( $ field -> getName ( ) == null ) { $ field -> setName ( 'name_' . count ( $ this -> fields ) ) ; } if ( $ field -> getId ( ) == null ) { $ field -> setId ( 'id_' . count ( $ this -> fields ) ) ; } if ( $ field instanceof FileField ) { $ this -> formTags [ 'enctype' ] = 'multipart/form-data' ; } }
7417	protected function setView ( string $ name = '' , array $ data = [ ] ) { if ( ! empty ( $ data ) ) { $ this -> data = array_replace ( $ this -> data , $ data ) ; } $ content = ( new Native ( $ this -> packageRoot , $ this -> request -> language ( ) , ! Wrap :: isEnabled ( ) ) ) -> getContent ( $ name , $ this -> data ) ; $ this -> response -> setContent ( $ content ) ; }
7112	public function isAuthorized ( $ user , $ plugin , $ controller , $ action ) { $ isAuthorized = false ; if ( $ plugin ) { $ plugin = Inflector :: camelize ( $ plugin ) ; } if ( $ this -> isPublicAction ( $ plugin , $ controller , $ action ) ) { $ isAuthorized = true ; } elseif ( isset ( $ user [ 'role' ] ) && ! empty ( $ controller ) && ! empty ( $ action ) ) { if ( $ this -> _options [ 'camelizedControllerNames' ] ) { $ controller = Inflector :: camelize ( $ controller ) ; } else { $ controller = Inflector :: underscore ( $ controller ) ; } $ key = $ controller ; if ( ! empty ( $ plugin ) ) { $ key = $ plugin . '.' . $ key ; } if ( isset ( $ this -> _rightsConfig [ $ key ] [ '*' ] ) && $ this -> _rightsConfig [ $ key ] [ '*' ] == '*' ) { $ isAuthorized = true ; } elseif ( isset ( $ this -> _rightsConfig [ $ key ] [ '*' ] ) && in_array ( $ user [ 'role' ] , $ this -> _rightsConfig [ $ key ] [ '*' ] ) ) { $ isAuthorized = true ; } elseif ( isset ( $ this -> _rightsConfig [ $ key ] [ $ action ] ) && in_array ( $ user [ 'role' ] , $ this -> _rightsConfig [ $ key ] [ $ action ] ) ) { $ isAuthorized = true ; } } return $ isAuthorized ; }
8652	private function convertGetReportScheduleCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportScheduleCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
1045	public static function createFromException ( $ e , $ debug = false , $ internalErrorMessage = null ) { Utils :: invariant ( $ e instanceof Exception || $ e instanceof Throwable , 'Expected exception, got %s' , Utils :: getVariableType ( $ e ) ) ; $ internalErrorMessage = $ internalErrorMessage ? : self :: $ internalErrorMessage ; if ( $ e instanceof ClientAware ) { $ formattedError = [ 'message' => $ e -> isClientSafe ( ) ? $ e -> getMessage ( ) : $ internalErrorMessage , 'extensions' => [ 'category' => $ e -> getCategory ( ) , ] , ] ; } else { $ formattedError = [ 'message' => $ internalErrorMessage , 'extensions' => [ 'category' => Error :: CATEGORY_INTERNAL , ] , ] ; } if ( $ e instanceof Error ) { $ locations = Utils :: map ( $ e -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ formattedError [ 'locations' ] = $ locations ; } if ( ! empty ( $ e -> path ) ) { $ formattedError [ 'path' ] = $ e -> path ; } if ( ! empty ( $ e -> getExtensions ( ) ) ) { $ formattedError [ 'extensions' ] = $ e -> getExtensions ( ) + $ formattedError [ 'extensions' ] ; } } if ( $ debug ) { $ formattedError = self :: addDebugEntries ( $ formattedError , $ e , $ debug ) ; } return $ formattedError ; }
6443	public function httpRequest ( $ url ) { if ( DEBUG ) echo "HTTP request: $url\n" ; $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , $ url ) ; curl_setopt ( $ curl , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_TIMEOUT , CURL_TIMEOUT ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , SPIDER_NAME ) ; curl_setopt ( $ curl , CURLOPT_VERBOSE , false ) ; curl_setopt ( $ curl , CURLOPT_MAXREDIRS , 4 ) ; curl_setopt ( $ curl , CURLOPT_FOLLOWLOCATION , true ) ; $ response [ 'file' ] = curl_exec ( $ curl ) ; $ response [ 'status' ] = curl_getinfo ( $ curl ) ; $ response [ 'error' ] = curl_error ( $ curl ) ; curl_exec ( $ curl ) ; curl_close ( $ curl ) ; if ( DEBUG === 'verbose' ) { echo "Retrieved HTTP:\n" ; var_dump ( $ response [ 'status' ] ) ; var_dump ( $ response [ 'error' ] ) ; } if ( $ response [ 'file' ] == '' ) die ( "Error while making the HTTP request: no HTML retrieved." ) ; return $ response ; }
10636	protected function resolvePaths ( array $ fixPaths ) { $ this -> rootDir = \ realpath ( isset ( $ fixPaths [ 'rootDir' ] ) ? $ fixPaths [ 'rootDir' ] : __DIR__ . '/../../../../' ) ; $ this -> packageDir = \ realpath ( isset ( $ fixPaths [ 'packageDir' ] ) ? $ fixPaths [ 'packageDir' ] : __DIR__ . '/../' ) ; $ this -> configPath = Utils :: fixPath ( isset ( $ fixPaths [ 'configPath' ] ) ? $ fixPaths [ 'configPath' ] : '/app/' ) ; if ( $ this -> rootDir === false || $ this -> packageDir === false ) throw new \ InvalidArgumentException ( 'Bootstrap directories do not exists or are not accessible' ) ; if ( $ this [ 'minion.usePropel' ] ) { $ this -> propelConfigPath = \ realpath ( isset ( $ fixPaths [ 'propelConfigPath' ] ) ? $ fixPaths [ 'propelConfigPath' ] : Utils :: fixPath ( $ this -> packageDir . '/propel.php' ) ) ; if ( $ this -> propelConfigPath === false ) throw new \ InvalidArgumentException ( 'Propel configuration file in vendor Minion not found' ) ; } }
7359	public static function getDefaultPriceMapLoader ( ) { if ( null === self :: $ defaultPriceMapLoader ) { $ currencyDir = realpath ( __DIR__ . '/../../../data/prices' ) ; self :: $ defaultPriceMapLoader = new PhpFileLoader ( array ( $ currencyDir ) ) ; } return self :: $ defaultPriceMapLoader ; }
1451	protected function validatorForDelete ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> createValidator ( $ data , $ rules , $ messages , $ customAttributes ) ; }
6657	protected function createFailSafeResponse ( ) { $ status = new Status ( 500 ) ; $ response = new Response ( ) ; $ response -> setRequest ( new Request ( ) ) ; $ response -> setWriter ( new Json ( ) ) ; $ response -> setStatus ( $ status ) ; $ response -> setBodyData ( $ status -> getMessage ( ) ) ; return $ response ; }
2336	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ response = $ event -> getResponse ( ) ; $ isSecure = $ request -> isSecure ( ) ; $ basePath = $ request -> getBasePath ( ) ? : '/' ; foreach ( $ this -> tokenStorage -> getUsedTokens ( ) as $ key => $ value ) { $ cookieKey = $ this -> cookiePrefix . $ key ; if ( $ request -> cookies -> has ( $ cookieKey ) && $ value === $ request -> cookies -> get ( $ cookieKey ) ) { continue ; } $ expires = null === $ value ? 1 : 0 ; $ response -> headers -> setCookie ( new Cookie ( $ cookieKey , $ value , $ expires , $ basePath , null , $ isSecure , true , false , Cookie :: SAMESITE_LAX ) ) ; } }
11067	protected function compileMixins ( ) { $ sql = array ( ) ; foreach ( $ this -> mixins as $ mixin ) { $ compiled = $ this -> { $ mixin } -> compile ( ) ; if ( $ compiled !== "" ) { $ sql [ ] = $ compiled ; } } return $ sql ; }
6622	public function add_styles ( ) { $ css = App :: EFG ( ) -> getOption ( 'assets' , 'css' ) ; WP_Register :: add ( 'style' , $ css [ 'extensionsForGrifusAdmin' ] ) ; WP_Register :: add ( 'style' , Module :: CustomRatingGrifus ( ) -> getOption ( 'assets' , 'css' , 'customRatingGrifusAdmin' ) ) ; }
6538	public function init ( ) { Html :: addCssClass ( $ this -> options , [ 'panel' , 'sx-panel' , $ this -> color ] ) ; $ options = ArrayHelper :: merge ( $ this -> options , [ 'id' => $ this -> id , ] ) ; echo Html :: beginTag ( 'div' , $ options ) ; echo Html :: beginTag ( 'div' , $ this -> headingOptions ) ; echo <<<HTML <div class="pull-left"> <h2> {$this->name} </h2> </div> <div class="panel-actions panel-hidden-actions"> {$this->actions} </div>HTML ; echo Html :: endTag ( 'div' ) ; echo Html :: beginTag ( 'div' , $ this -> bodyOptions ) ; echo $ this -> content ; }
11672	protected function onErrorResponse ( CommandInterface $ command , ErrorResponseInterface $ response ) { if ( $ command instanceof ScriptCommand && $ response -> getErrorType ( ) === 'NOSCRIPT' ) { $ response = $ this -> executeCommand ( $ command -> getEvalCommand ( ) ) ; if ( ! $ response instanceof ResponseInterface ) { $ response = $ command -> parseResponse ( $ response ) ; } return $ response ; } if ( $ this -> options -> exceptions ) { throw new ServerException ( $ response -> getMessage ( ) ) ; } return $ response ; }
10746	protected function sendJson ( Response $ response , $ payload ) : Response { $ response -> getBody ( ) -> write ( json_encode ( $ payload ) ) ; return $ response -> withHeader ( 'Content-Type' , 'application/json' ) ; }
2765	public function isUpToDate ( ) : bool { if ( ! $ this -> isTracking ( ) ) { throw new GitException ( 'Error: HEAD does not have a remote tracking branch. Cannot check if it is up-to-date.' ) ; } $ mergeBase = $ this -> run ( 'merge-base' , [ '@' , '@{u}' ] ) ; $ remoteSha = $ this -> run ( 'rev-parse' , [ '@{u}' ] ) ; return $ mergeBase === $ remoteSha ; }
10879	protected function convertExceptionToArray ( $ exception ) { if ( ! YII_DEBUG && ! $ exception instanceof UserException && ! $ exception instanceof HttpException ) { $ exception = new HttpException ( 500 , 'There was an error at the server.' ) ; } $ array = [ 'name' => ( $ exception instanceof Exception || $ exception instanceof ErrorException ) ? $ exception -> getName ( ) : 'Exception' , 'message' => $ exception -> getMessage ( ) , 'code' => $ exception -> getCode ( ) , ] ; if ( $ exception instanceof HttpException ) { $ array [ 'status' ] = $ exception -> statusCode ; } if ( YII_DEBUG ) { $ array [ 'type' ] = get_class ( $ exception ) ; if ( ! $ exception instanceof UserException ) { $ array [ 'file' ] = $ exception -> getFile ( ) ; $ array [ 'line' ] = $ exception -> getLine ( ) ; $ array [ 'stack-trace' ] = explode ( "\n" , $ exception -> getTraceAsString ( ) ) ; if ( $ exception instanceof \ yii \ db \ Exception ) { $ array [ 'error-info' ] = $ exception -> errorInfo ; } } } if ( ( $ prev = $ exception -> getPrevious ( ) ) !== null ) { $ array [ 'previous' ] = $ this -> convertExceptionToArray ( $ prev ) ; } return $ array ; }
10291	protected function aquireLock ( ) { $ lockfile = $ this -> lockDir . '/lock' ; $ fp = @ fopen ( $ lockfile , 'x' ) ; if ( $ fp === false ) { $ this -> logger -> log ( sprintf ( 'The lockfile %s does already exist.' , $ lockfile ) , Logger :: WARNING ) ; return false ; } fwrite ( $ fp , time ( ) ) ; fclose ( $ fp ) ; $ this -> logger -> log ( 'Aquired lock.' , Logger :: INFO ) ; return true ; }
7777	protected function extractFieldAliases ( array $ data ) { foreach ( $ data as $ field => $ fieldRules ) { $ extraction = explode ( '|' , $ field ) ; if ( isset ( $ extraction [ 1 ] ) ) { $ updatedField = $ extraction [ 0 ] ; $ alias = $ extraction [ 1 ] ; $ this -> fieldAliases [ $ updatedField ] = $ alias ; $ data [ $ updatedField ] = $ data [ $ field ] ; unset ( $ data [ $ field ] ) ; } } return $ data ; }
5871	protected static function rationalToDecimal ( array $ components ) { foreach ( $ components as $ key => $ value ) { $ rationalParts = explode ( '/' , $ value ) ; if ( ! empty ( $ rationalParts [ 1 ] ) ) { $ components [ $ key ] = $ rationalParts [ 0 ] / $ rationalParts [ 1 ] ; } else { $ components [ $ key ] = 0 ; } } list ( $ hours , $ minutes , $ seconds ) = $ components ; return $ hours + ( $ minutes / 60 ) + ( $ seconds / 3600 ) ; }
2132	public function add ( $ strKey , $ varValue ) { $ this -> markModified ( ) ; $ this -> arrData [ $ strKey ] = $ this -> escape ( $ varValue ) . ';' ; }
738	protected function saveItems ( ) { $ items = [ ] ; foreach ( $ this -> items as $ name => $ item ) { $ items [ $ name ] = array_filter ( [ 'type' => $ item -> type , 'description' => $ item -> description , 'ruleName' => $ item -> ruleName , 'data' => $ item -> data , ] ) ; if ( isset ( $ this -> children [ $ name ] ) ) { foreach ( $ this -> children [ $ name ] as $ child ) { $ items [ $ name ] [ 'children' ] [ ] = $ child -> name ; } } } $ this -> saveToFile ( $ items , $ this -> itemFile ) ; }
9936	public function setGrouping ( $ pGrouping ) { if ( ( $ pGrouping !== null ) && ( ! in_array ( $ pGrouping , self :: $ dateTimeGroups ) ) && ( ! in_array ( $ pGrouping , self :: $ dynamicTypes ) ) && ( ! in_array ( $ pGrouping , self :: $ topTenType ) ) ) { throw new PhpSpreadsheetException ( 'Invalid rule type for column AutoFilter Rule.' ) ; } $ this -> grouping = $ pGrouping ; return $ this ; }
4224	public function handleException ( $ exception ) { $ this -> uncaughtException = $ exception ; \ http_response_code ( 500 ) ; $ this -> handleError ( E_ERROR , 'Uncaught exception \'' . \ get_class ( $ exception ) . '\' with message ' . $ exception -> getMessage ( ) , $ exception -> getFile ( ) , $ exception -> getLine ( ) ) ; $ this -> uncaughtException = null ; if ( $ this -> cfg [ 'continueToPrevHandler' ] && $ this -> prevExceptionHandler ) { \ call_user_func ( $ this -> prevErrorHandler , $ exception ) ; } }
11887	public function getUser ( $ owner = true ) { if ( $ owner && $ this -> owner -> getBehavior ( 'Ownable' ) !== null && isset ( $ this -> owner -> objectOwner ) ) { return $ this -> owner -> objectOwner ; } elseif ( isset ( Yii :: $ app -> user ) && isset ( Yii :: $ app -> user -> identity -> primaryKey ) ) { return Yii :: $ app -> user -> identity ; } return false ; }
5689	public function getFormById ( $ id ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> getId ( ) == $ id ) { return $ this -> forms [ $ i ] ; } } return ; }
7152	public function copy ( SubjectIdentity $ identity ) { $ this -> provider = $ identity -> getProvider ( ) ; $ this -> identifier = $ identity -> getIdentifier ( ) ; }
4753	private function getContactFormMethod ( ) { $ method = self :: CONTACT_FORM_METHOD_DEFAULT ; if ( $ configMethod = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'OeGdprOptinContactFormMethod' ) ) { $ method = $ configMethod ; } return $ method ; }
8728	public function changeFolder ( HTTPRequest $ request ) { $ token = $ this -> getForm ( ) -> getSecurityToken ( ) ; if ( ! $ token -> checkRequest ( $ request ) ) { return $ this -> httpError ( 400 ) ; } $ folderID = $ request -> postVar ( 'FolderID' ) ; if ( $ folderID ) { $ this -> FolderSelector ( ) -> setLastFolderID ( $ folderID ) ; } }
2309	public function getImportantPart ( ) { if ( $ this -> importantPart ) { return $ this -> importantPart ; } return array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight ) ; }
2921	public function save ( $ filePath ) { $ this -> ensureFileIsWritable ( $ filePath ) ; file_put_contents ( $ filePath , $ this -> buffer ) ; return $ this ; }
10709	public function getManyPaginated ( $ perPage = null , $ columns = [ '*' ] ) { $ query = $ this -> getQuery ( ) ; $ results = $ query -> paginate ( $ perPage , $ columns ) ; return $ this -> returnResults ( $ results ) ; }
10348	public function rewind ( ) { if ( $ this -> yearOffset !== 0 ) { $ this -> generateTimetable ( 0 ) ; } else { reset ( $ this -> minutes ) ; reset ( $ this -> hours ) ; reset ( $ this -> monthAndDays ) ; } }
2359	public function isPreviewMode ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return $ token instanceof FrontendPreviewToken && $ token -> showUnpublished ( ) ; }
12414	public function removeDevice ( $ groupId , array $ deviceIdentifiers ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'device_identifiers' => $ deviceIdentifiers , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_DEVICE , $ params ] ) ; }
72	public function authorizeOAuth ( $ originUrl ) { if ( $ originUrl !== 'bitbucket.org' ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config bitbucket.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , 'x-token-auth' , trim ( $ output ) ) ; return true ; } return false ; }
820	private function fixBackticks ( Tokens $ tokens , array $ backtickTokens ) { ksort ( $ backtickTokens ) ; $ openingBacktickIndex = key ( $ backtickTokens ) ; end ( $ backtickTokens ) ; $ closingBacktickIndex = key ( $ backtickTokens ) ; array_shift ( $ backtickTokens ) ; array_pop ( $ backtickTokens ) ; $ count = \ count ( $ backtickTokens ) ; $ newTokens = [ new Token ( [ T_STRING , 'shell_exec' ] ) , new Token ( '(' ) , ] ; if ( 1 !== $ count ) { $ newTokens [ ] = new Token ( '"' ) ; } foreach ( $ backtickTokens as $ token ) { if ( ! $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) ) { $ newTokens [ ] = $ token ; continue ; } $ content = $ token -> getContent ( ) ; if ( Preg :: match ( '/[`"\']/u' , $ content ) ) { return ; } $ kind = T_ENCAPSED_AND_WHITESPACE ; if ( 1 === $ count ) { $ content = '"' . $ content . '"' ; $ kind = T_CONSTANT_ENCAPSED_STRING ; } $ newTokens [ ] = new Token ( [ $ kind , $ content ] ) ; } if ( 1 !== $ count ) { $ newTokens [ ] = new Token ( '"' ) ; } $ newTokens [ ] = new Token ( ')' ) ; $ tokens -> overrideRange ( $ openingBacktickIndex , $ closingBacktickIndex , $ newTokens ) ; }
1270	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ quantumViewRequest = $ xml -> appendChild ( $ xml -> createElement ( 'QuantumViewRequest' ) ) ; $ quantumViewRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; if ( null !== $ this -> name || null !== $ this -> beginDateTime || null !== $ this -> fileName ) { $ subscriptionRequest = $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'SubscriptionRequest' ) ) ; if ( null !== $ this -> name ) { $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'Name' , $ this -> name ) ) ; } if ( null !== $ this -> beginDateTime ) { $ dateTimeRange = $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'DateTimeRange' ) ) ; $ dateTimeRange -> appendChild ( $ xml -> createElement ( 'BeginDateTime' , $ this -> beginDateTime ) ) ; $ dateTimeRange -> appendChild ( $ xml -> createElement ( 'EndDateTime' , $ this -> endDateTime ) ) ; } elseif ( null !== $ this -> fileName ) { $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'FileName' , $ this -> fileName ) ) ; } } if ( null !== $ this -> bookmark ) { $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'Bookmark' , $ this -> bookmark ) ) ; } $ request = $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'QVEvents' ) ) ; return $ xml -> saveXML ( ) ; }
9212	protected function existsOrCreate ( $ file ) { if ( ! file_exists ( $ file ) ) { $ this -> out ( '<info>Creating empty seed file: ' . $ this -> shortPath ( $ file ) . '</info>' ) ; file_put_contents ( $ file , <<<'EOD'<?php/** * BasicSeed plugin data seed file. */namespace App\Config\BasicSeed;use Cake\ORM\TableRegistry;// Write your data import statements here.$data = [ 'TableName' => [ //'_truncate' => true, //'_entityOptions' => [ // 'validate' => false, //], //'_saveOptions' => [ // 'checkRules' => false, //], '_defaults' => [], [ 'id' => 1, 'name' => 'record 1', ], ],];$this->importTables($data);EOD ) ; } }
12776	protected function write ( $ namespace , array $ data ) { $ file = $ this -> adapter -> getFileName ( $ namespace ) ; $ contents = $ this -> adapter -> prepareForWriting ( $ data ) ; if ( ! $ this -> fileSystem -> has ( $ file ) ) { $ this -> fileSystem -> write ( $ file , $ contents ) ; } $ this -> fileSystem -> update ( $ file , $ contents ) ; }
5145	public function _after ( \ Codeception \ TestCase $ test ) { if ( isset ( $ this -> config [ 'deleteEmailsAfterScenario' ] ) && $ this -> config [ 'deleteEmailsAfterScenario' ] ) { $ this -> deleteAllEmails ( ) ; } }
9692	private function compileString ( $ str ) { $ result = null ; try { $ result = $ this -> parser -> compile ( $ str ) ; } catch ( \ Exception $ e ) { throw new SyntaxErrorException ( "Syntax error in $this->currFile: " . $ e -> getMessage ( ) ) ; } return $ result ; }
12812	private static function isForeignKey ( string $ table , string $ column ) : bool { return array_key_exists ( $ column , self :: getForeignKeys ( $ table ) ) ; }
3368	public function generateFromMetadata ( array $ metadata ) { $ this -> metadata = $ metadata ; $ this -> visitedAssociations = [ ] ; $ str = [ ] ; foreach ( $ metadata as $ class ) { $ parent = $ this -> getParent ( $ class ) ; if ( $ parent ) { $ str [ ] = $ this -> getClassString ( $ parent ) . '^' . $ this -> getClassString ( $ class ) ; } $ associations = $ class -> getAssociationNames ( ) ; if ( empty ( $ associations ) && ! isset ( $ this -> visitedAssociations [ $ class -> getName ( ) ] ) ) { $ str [ ] = $ this -> getClassString ( $ class ) ; continue ; } foreach ( $ associations as $ associationName ) { if ( $ parent && in_array ( $ associationName , $ parent -> getAssociationNames ( ) ) ) { continue ; } if ( $ this -> visitAssociation ( $ class -> getName ( ) , $ associationName ) ) { $ str [ ] = $ this -> getAssociationString ( $ class , $ associationName ) ; } } } return implode ( ',' , $ str ) ; }
4702	protected function runHelp ( InputInterface $ input , OutputInterface $ output ) { $ help = $ this -> getApplication ( ) -> find ( 'help' ) ; $ help -> setCommand ( $ this ) ; $ help -> run ( $ input , $ output ) ; }
2977	public function unserialize ( $ serialized ) { $ this -> data = unserialize ( $ serialized ) ; $ this -> closure = __reconstruct_closure ( $ this -> data ) ; if ( ! $ this -> closure instanceof Closure ) { throw new ClosureUnserializationException ( 'The closure is corrupted and cannot be unserialized.' ) ; } if ( $ this -> data [ 'binding' ] || $ this -> data [ 'isStatic' ] ) { $ this -> closure = $ this -> closure -> bindTo ( $ this -> data [ 'binding' ] , $ this -> data [ 'scope' ] ) ; } }
821	private function splitUpDocBlock ( $ lines , Tokens $ tokens , $ docBlockIndex ) { $ lineContent = $ this -> getSingleLineDocBlockEntry ( $ lines ) ; $ lineEnd = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ originalIndent = $ this -> detectIndent ( $ tokens , $ tokens -> getNextNonWhitespace ( $ docBlockIndex ) ) ; return [ new Line ( '/**' . $ lineEnd ) , new Line ( $ originalIndent . ' * ' . $ lineContent . $ lineEnd ) , new Line ( $ originalIndent . ' */' ) , ] ; }
10834	public function using ( $ column ) { if ( $ this -> active_join === null ) { throw new \ Peyote \ Exception ( "You need to start a join before calling \Peyote\Join::using()" ) ; } list ( $ table , $ type ) = $ this -> active_join ; $ this -> active_join = null ; $ this -> joins [ ] = array ( "USING" , $ table , $ type , $ column ) ; return $ this ; }
1446	protected function dataForUpdate ( $ record , array $ document ) : array { $ resource = $ document [ 'data' ] ?? [ ] ; if ( $ this -> mustValidateExisting ( $ record , $ document ) ) { $ resource [ 'attributes' ] = $ this -> extractAttributes ( $ record , $ resource [ 'attributes' ] ?? [ ] ) ; $ resource [ 'relationships' ] = $ this -> extractRelationships ( $ record , $ resource [ 'relationships' ] ?? [ ] ) ; } return $ resource ; }
1911	protected function getType ( ) : string { if ( isset ( $ this -> options [ 'type' ] ) ) { return $ this -> options [ 'type' ] ; } $ className = ltrim ( strrchr ( static :: class , '\\' ) , '\\' ) ; if ( 'Controller' === substr ( $ className , - 10 ) ) { $ className = substr ( $ className , 0 , - 10 ) ; } return Container :: underscore ( $ className ) ; }
10629	public static function hdd ( ) { $ hdd = new \ StdClass ( ) ; $ hdd -> total = @ disk_total_space ( "." ) ; $ hdd -> free = @ disk_free_space ( "." ) ; return $ hdd ; }
2775	public function streamOutput ( bool $ streamOutput = true ) : void { if ( $ streamOutput && ! isset ( $ this -> gitOutputListener ) ) { $ this -> gitOutputListener = new GitOutputStreamListener ( ) ; $ this -> addOutputListener ( $ this -> gitOutputListener ) ; } if ( ! $ streamOutput && isset ( $ this -> gitOutputListener ) ) { $ this -> removeOutputListener ( $ this -> gitOutputListener ) ; unset ( $ this -> gitOutputListener ) ; } }
1561	protected function deserializeAttributes ( $ attributes , $ record ) { return collect ( $ attributes ) -> reject ( function ( $ v , $ field ) use ( $ record ) { return $ this -> isNotFillable ( $ field , $ record ) ; } ) -> mapWithKeys ( function ( $ value , $ field ) use ( $ record ) { $ key = $ this -> modelKeyForField ( $ field , $ record ) ; return [ $ key => $ this -> deserializeAttribute ( $ value , $ field , $ record ) ] ; } ) -> all ( ) ; }
923	private function ensureAreSeparate ( DocBlock $ doc , Annotation $ first , Annotation $ second ) { $ pos = $ first -> getEnd ( ) ; $ final = $ second -> getStart ( ) - 1 ; if ( $ pos === $ final ) { $ doc -> getLine ( $ pos ) -> addBlank ( ) ; return ; } for ( $ pos = $ pos + 1 ; $ pos < $ final ; ++ $ pos ) { $ doc -> getLine ( $ pos ) -> remove ( ) ; } }
11399	public function getCustomFieldByType ( $ type ) { if ( isset ( $ this -> servicesByType [ $ type ] ) ) { return $ this -> servicesByType [ $ type ] ; } else { throw new \ LogicException ( 'the custom field with type ' . $ type . ' ' . 'is not found' ) ; } }
5646	public function createInvoker ( $ invoker ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ invoker = $ this -> reporters [ $ i ] -> createInvoker ( $ invoker ) ; } return $ invoker ; }
443	public function off ( $ name , $ handler = null ) { $ this -> ensureBehaviors ( ) ; if ( empty ( $ this -> _events [ $ name ] ) && empty ( $ this -> _eventWildcards [ $ name ] ) ) { return false ; } if ( $ handler === null ) { unset ( $ this -> _events [ $ name ] , $ this -> _eventWildcards [ $ name ] ) ; return true ; } $ removed = false ; if ( isset ( $ this -> _events [ $ name ] ) ) { foreach ( $ this -> _events [ $ name ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( $ this -> _events [ $ name ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { $ this -> _events [ $ name ] = array_values ( $ this -> _events [ $ name ] ) ; return $ removed ; } } if ( isset ( $ this -> _eventWildcards [ $ name ] ) ) { foreach ( $ this -> _eventWildcards [ $ name ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( $ this -> _eventWildcards [ $ name ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { $ this -> _eventWildcards [ $ name ] = array_values ( $ this -> _eventWildcards [ $ name ] ) ; if ( empty ( $ this -> _eventWildcards [ $ name ] ) ) { unset ( $ this -> _eventWildcards [ $ name ] ) ; } } } return $ removed ; }
3061	public function getCurrentPosition ( ) { $ route = $ this -> getTestSession ( ) -> getRoute ( ) ; $ routeCount = $ route -> count ( ) ; $ routeItemPosition = $ route -> getPosition ( ) ; $ currentRouteItem = $ route -> getRouteItemAt ( $ routeItemPosition ) ; $ finalPosition = 0 ; for ( $ i = 0 ; $ i < $ routeCount ; $ i ++ ) { $ routeItem = $ route -> getRouteItemAt ( $ i ) ; if ( $ routeItem !== $ currentRouteItem ) { if ( ! $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition ++ ; } else { $ finalPosition += count ( $ this -> getShadowTest ( $ routeItem ) ) ; } } else { if ( $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition += array_search ( $ this -> getCurrentCatItemId ( $ routeItem ) , $ this -> getShadowTest ( $ routeItem ) ) ; } break ; } } return $ finalPosition ; }
8025	public function addFree ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; $ this -> processDetails [ $ pid ] = $ processDetails ; $ this -> sockets [ $ pid ] = $ processDetails -> getSocket ( ) ; $ this -> registerFreeProcess ( $ processDetails ) ; return $ this ; }
8218	protected function isAllowed ( $ limit , $ config ) { if ( $ limit [ "cnt" ] >= $ config [ "count" ] ) { if ( time ( ) > $ limit [ "ts" ] + $ config [ "blockDuration" ] ) { return true ; } else { return false ; } } else { return true ; } }
238	protected function normalizePdoRowKeyCase ( array $ row , $ multiple ) { if ( $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_CASE ) !== \ PDO :: CASE_UPPER ) { return $ row ; } if ( $ multiple ) { return array_map ( function ( array $ row ) { return array_change_key_case ( $ row , CASE_LOWER ) ; } , $ row ) ; } return array_change_key_case ( $ row , CASE_LOWER ) ; }
7922	private function isValidPath ( $ path ) { $ pathParts = explode ( '/' , $ path ) ; if ( ! strncmp ( $ path , '/' , 1 ) || array_search ( '..' , $ pathParts ) !== false || strpos ( $ path , ':' ) !== false ) { return false ; } return true ; }
1390	protected function resourceDoesNotExist ( string $ path ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotExist ( $ path ) ) ; }
7861	public function draw ( $ workflow ) { $ this -> geometry -> setCore ( $ workflow ) ; $ this -> setPipesOfWorkflow ( $ workflow ) ; $ this -> drawCenteredChar ( static :: NOCK ) ; $ this -> drawPipesBeginning ( ) ; $ this -> drawCore ( ) ; $ this -> drawPipesEnd ( ) ; $ this -> drawCenteredChar ( static :: PILE ) ; return $ this -> drawing ; }
7187	public function getAssignmentById ( $ id ) { foreach ( $ this -> unit -> getStockAssignments ( ) as & $ assignment ) { if ( $ assignment -> getId ( ) === $ id ) { return $ assignment ; } } return null ; }
878	public function useRuleSet ( RuleSetInterface $ ruleSet ) { $ fixers = [ ] ; $ fixersByName = [ ] ; $ fixerConflicts = [ ] ; $ fixerNames = array_keys ( $ ruleSet -> getRules ( ) ) ; foreach ( $ fixerNames as $ name ) { if ( ! \ array_key_exists ( $ name , $ this -> fixersByName ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Rule "%s" does not exist.' , $ name ) ) ; } $ fixer = $ this -> fixersByName [ $ name ] ; $ config = $ ruleSet -> getRuleConfiguration ( $ name ) ; if ( null !== $ config ) { if ( $ fixer instanceof ConfigurableFixerInterface ) { if ( ! \ is_array ( $ config ) || ! \ count ( $ config ) ) { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Configuration must be an array and may not be empty.' ) ; } $ fixer -> configure ( $ config ) ; } else { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Is not configurable.' ) ; } } $ fixers [ ] = $ fixer ; $ fixersByName [ $ name ] = $ fixer ; $ conflicts = array_intersect ( $ this -> getFixersConflicts ( $ fixer ) , $ fixerNames ) ; if ( \ count ( $ conflicts ) > 0 ) { $ fixerConflicts [ $ name ] = $ conflicts ; } } if ( \ count ( $ fixerConflicts ) > 0 ) { throw new \ UnexpectedValueException ( $ this -> generateConflictMessage ( $ fixerConflicts ) ) ; } $ this -> fixers = $ fixers ; $ this -> fixersByName = $ fixersByName ; return $ this ; }
4020	protected function validateWidget ( & $ arrField , $ strRow , $ strKey , & $ varInput ) { $ varValue = $ varInput [ $ strRow ] [ $ strKey ] ; $ objWidget = $ this -> initializeWidget ( $ arrField , $ strRow , $ strKey , $ varValue ) ; if ( ! is_object ( $ objWidget ) ) { return false ; } if ( ( $ arrField [ 'inputType' ] == 'checkbox' ) && isset ( $ varInput [ $ strRow ] [ $ strKey ] ) ) { $ _POST [ $ objWidget -> name ] = $ varValue ; } $ objWidget -> validate ( ) ; $ varValue = $ objWidget -> value ; $ rgxp = $ arrField [ 'eval' ] [ 'rgxp' ] ; if ( ( $ rgxp == 'date' || $ rgxp == 'time' || $ rgxp == 'datim' ) && $ varValue != '' ) { $ objDate = new Date ( $ varValue , $ GLOBALS [ 'TL_CONFIG' ] [ $ rgxp . 'Format' ] ) ; $ varValue = $ objDate -> tstamp ; } $ varValue = $ this -> handleSaveCallback ( $ arrField , $ objWidget , $ varValue ) ; $ varInput [ $ strRow ] [ $ strKey ] = $ varValue ; if ( $ objWidget -> hasErrors ( ) ) { return false ; } return true ; }
11796	public function setSubject ( $ subject = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'subject' ) ; } $ this -> subject = $ subject ; return $ this ; }
5047	public function getResult ( $ paginatorAlias = null , $ formAlias = null ) { if ( null === $ paginatorAlias ) { $ paginatorAlias = isset ( $ this -> stack [ 'paginator' ] [ 'as' ] ) ? $ this -> stack [ 'paginator' ] [ 'as' ] : 'paginator' ; } if ( null === $ formAlias ) { $ formAlias = isset ( $ this -> stack [ 'form' ] [ 'as' ] ) ? $ this -> stack [ 'form' ] [ 'as' ] : 'searchform' ; } $ result = [ ] ; $ controller = $ this -> getController ( ) ; $ request = $ controller -> getRequest ( ) ; $ this -> setParameters ( $ request -> getQuery ( ) ) ; if ( isset ( $ this -> stack [ 'params' ] ) ) { $ this -> callPlugin ( 'paginationParams' , $ this -> stack [ 'params' ] ) ; } if ( isset ( $ this -> stack [ 'form' ] ) ) { $ form = $ this -> callPlugin ( 'searchform' , $ this -> stack [ 'form' ] ) ; if ( ! $ request -> isXmlHttpRequest ( ) ) { $ result [ $ formAlias ] = $ form ; } } if ( isset ( $ this -> stack [ 'paginator' ] ) ) { $ result [ $ paginatorAlias ] = $ this -> callPlugin ( 'paginator' , $ this -> stack [ 'paginator' ] ) ; } return $ result ; }
606	private function tokenizeDelimitedString ( & $ length ) { $ isIdentifier = $ this -> isIdentifier ( $ length , $ content ) ; $ isStringLiteral = ! $ isIdentifier && $ this -> isStringLiteral ( $ length , $ content ) ; if ( ! $ isIdentifier && ! $ isStringLiteral ) { return false ; } $ this -> addTokenFromBuffer ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => $ isIdentifier ? SqlToken :: TYPE_IDENTIFIER : SqlToken :: TYPE_STRING_LITERAL , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; return true ; }
1726	protected function checkAccountStatus ( ) { @ trigger_error ( 'Using User::checkAccountStatus() has been deprecated and will no longer work in Contao 5.0. Use Symfony security instead.' , E_USER_DEPRECATED ) ; try { $ userChecker = System :: getContainer ( ) -> get ( 'contao.security.user_checker' ) ; $ userChecker -> checkPreAuth ( $ this ) ; $ userChecker -> checkPostAuth ( $ this ) ; } catch ( AuthenticationException $ exception ) { return false ; } return true ; }
11669	protected function createAggregateConnection ( $ parameters , $ option ) { $ options = $ this -> getOptions ( ) ; $ initializer = $ options -> $ option ; $ connection = $ initializer ( $ parameters ) ; if ( $ option !== 'aggregate' && ! $ connection instanceof SentinelReplication ) { $ options -> connections -> aggregate ( $ connection , $ parameters ) ; } return $ connection ; }
8998	public function exists ( ) : bool { if ( ! file_exists ( $ this -> path ) ) { return false ; } if ( ! is_dir ( $ this -> path ) ) { throw new DirectoryException ( "Entry {path} exists, but it is not a directory!" , array ( 'path' => $ this -> path ) ) ; } return true ; }
3996	protected function jumpTo ( $ mixMetaModel , $ mixDataId , $ intIdRenderSetting , $ strParam = 'url' ) { if ( empty ( $ strParam ) ) { $ strParam = 'url' ; } $ objMetaModel = $ this -> loadMetaModel ( $ mixMetaModel ) ; if ( $ objMetaModel == null ) { return false ; } $ objRenderSettings = $ this -> getServiceContainer ( ) -> getRenderSettingFactory ( ) -> createCollection ( $ objMetaModel , $ intIdRenderSetting ) ; if ( $ objRenderSettings == null ) { return false ; } $ objItem = $ objMetaModel -> findById ( $ mixDataId ) ; if ( $ objItem == null ) { return false ; } $ arrRenderedItem = $ objItem -> parseValue ( 'text' , $ objRenderSettings ) ; if ( ! isset ( $ arrRenderedItem [ 'jumpTo' ] ) ) { return false ; } if ( stripos ( $ strParam , 'params.' ) !== false ) { $ mixAttName = StringUtil :: trimsplit ( '.' , $ strParam ) ; $ mixAttName = array_pop ( $ mixAttName ) ; if ( isset ( $ arrRenderedItem [ 'jumpTo' ] [ 'params' ] [ $ mixAttName ] ) ) { return $ arrRenderedItem [ 'jumpTo' ] [ 'params' ] [ $ mixAttName ] ; } } elseif ( isset ( $ arrRenderedItem [ 'jumpTo' ] [ $ strParam ] ) ) { return $ arrRenderedItem [ 'jumpTo' ] [ $ strParam ] ; } return false ; }
5462	public function stretch ( $ url ) { $ this -> root = $ this -> getCommonPath ( $ this -> root , $ url -> getPath ( ) ) ; }
8713	public function orWhereTranslated ( $ column , $ operator = null , $ value = null ) { return $ this -> whereTranslated ( $ column , $ operator , $ value , 'or' ) ; }
4269	public function dir_readdir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ readdir ( $ this -> handle ) ; self :: register ( ) ; return $ success ; }
11193	protected function setPath ( $ url ) { $ cleanURI = str_replace ( '?' . $ _SERVER [ 'QUERY_STRING' ] , '' , $ url ) ; $ this -> pathString = explode ( $ this -> config [ 'site_url' ] , $ cleanURI , 2 ) [ 1 ] ; if ( $ this -> config [ 'lowercase_url' ] ) { $ this -> pathString = strtolower ( $ this -> pathString ) ; } $ this -> path = explode ( '/' , $ this -> pathString ) ; }
522	protected function createMigration ( $ class ) { $ this -> includeMigrationFile ( $ class ) ; $ migration = Yii :: createObject ( $ class ) ; if ( $ migration instanceof BaseObject && $ migration -> canSetProperty ( 'compact' ) ) { $ migration -> compact = $ this -> compact ; } return $ migration ; }
6422	public function getMenu ( $ level = 1 ) { if ( class_exists ( ContentController :: class ) ) { $ controller = ContentController :: singleton ( ) ; return $ controller -> getMenu ( $ level ) ; } }
1496	public function prepend ( Encoding ... $ encodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ encodings ) ; return $ copy ; }
8184	public function getPeakMemoryUsage ( ) { return isset ( $ this -> ends [ 'pmu' ] ) && isset ( $ this -> starts [ 'pmu' ] ) ? $ this -> ends [ 'pmu' ] - $ this -> starts [ 'pmu' ] : 0 ; }
6474	private function rankAcceptCharsetHeaders ( array $ charsetHeaders ) : array { usort ( $ charsetHeaders , [ $ this , 'compareAcceptCharsetHeaders' ] ) ; $ rankedCharsetHeaders = array_filter ( $ charsetHeaders , [ $ this , 'filterZeroScores' ] ) ; return array_values ( $ rankedCharsetHeaders ) ; }
3029	public function setToken ( $ token , $ secret ) { $ this -> token = new \ Eher \ OAuth \ Token ( $ token , $ secret ) ; }
6640	private function getContainerRoute ( array $ routes , $ name ) { foreach ( $ routes as $ route => $ names ) { if ( in_array ( $ name , $ names , false ) ) { return $ route ; } } throw new Exception ( "Unknown configuration class name '{$name}'" ) ; }
2008	private function loadLanguageFile ( string $ name ) : void { $ system = $ this -> framework -> getAdapter ( System :: class ) ; $ system -> loadLanguageFile ( $ name ) ; }
7567	protected function parse_adjacent ( ) { $ tmp = $ this -> result ; $ this -> result = array ( ) ; if ( ( $ c = $ this -> parse_conditions ( ) ) === false ) { return false ; } foreach ( $ tmp as $ t ) { if ( ( $ sibling = $ t -> getNextSibling ( ) ) !== false ) { if ( $ sibling -> match ( $ c , true , $ this -> custom_filter_map ) ) { $ this -> result [ ] = $ sibling ; } } } return true ; }
11846	final public function reset ( $ column ) { if ( $ this -> isDirty ( $ column ) ) { $ this -> _data [ $ column ] = $ this -> _cleanData [ $ column ] ; unset ( $ this -> _modifiedFields [ $ column ] ) ; } }
91	public static function parseJson ( $ json , $ file = null ) { if ( null === $ json ) { return ; } $ data = json_decode ( $ json , true ) ; if ( null === $ data && JSON_ERROR_NONE !== json_last_error ( ) ) { self :: validateSyntax ( $ json , $ file ) ; } return $ data ; }
3981	private function getChildModelCaption ( $ metaModel , $ screen ) { $ caption = [ '' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) ] ; foreach ( $ screen [ 'label' ] as $ langCode => $ label ) { if ( ! empty ( $ label ) && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ screen [ 'description' ] [ $ langCode ] , $ label ] ; } } return $ caption ; }
9043	protected function logImpl ( $ level , $ message , array $ context = array ( ) ) { if ( ! $ this -> levelHasReached ( $ level ) ) { return ; } if ( $ this -> isRotationNeeded ( ) ) { unlink ( $ this -> file ) ; } $ ms = $ this -> getMessage ( $ level , $ message , $ context ) ; $ fos = new FileOutputStream ( $ this -> file , true ) ; $ fos -> write ( $ ms ) ; $ fos -> flush ( ) ; $ fos -> close ( ) ; }
9123	private function retrieveAndParseResponse ( $ requestType ) { $ this -> payload = new MemoryStream ( ) ; $ this -> headers = array ( ) ; $ delimiterFound = false ; $ tmp = "" ; $ numBytes = 1 ; $ start = time ( ) ; while ( true ) { if ( ! $ this -> checkConnection ( $ start ) ) { continue ; } $ c = $ this -> read ( $ numBytes ) ; if ( $ c == null ) { break ; } $ start = time ( ) ; $ tmp .= $ c ; if ( ! $ delimiterFound ) { $ this -> handleHeader ( $ delimiterFound , $ numBytes , $ tmp ) ; } if ( $ delimiterFound ) { if ( $ requestType == 'HEAD' ) { break ; } $ this -> payload -> write ( $ tmp ) ; $ tmp = "" ; if ( $ this -> checkContentLengthExceeded ( ) ) { break ; } } } $ size = $ this -> payload -> count ( ) ; if ( $ size == 0 ) { return ; } $ this -> payload -> reset ( ) ; $ mayCompressed = $ this -> payload -> read ( $ size ) ; switch ( $ this -> getContentEncoding ( ) ) { case 'gzip' : $ uncompressed = gzdecode ( strstr ( $ mayCompressed , "\x1f\x8b" ) ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; case 'deflate' : $ uncompressed = gzuncompress ( $ mayCompressed ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; default : break ; } $ this -> payload -> reset ( ) ; }
11224	private static function getRegexRoutes ( ) { foreach ( self :: $ routes as $ key => $ value ) { unset ( self :: $ routes [ $ key ] ) ; if ( strpos ( $ key , ':' ) !== false ) { self :: any ( $ key , $ value ) ; } } }
10414	public function createTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return null ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ schemaManager -> createTable ( $ table ) ; return true ; }
6454	private function createNotAcceptableException ( string $ type ) : HttpException { $ headers = new HttpHeaders ( ) ; $ headers -> add ( 'Content-Type' , 'application/json' ) ; $ body = new StringBody ( json_encode ( $ this -> contentNegotiator -> getAcceptableResponseMediaTypes ( $ type ) ) ) ; $ response = new Response ( HttpStatusCodes :: HTTP_NOT_ACCEPTABLE , $ headers , $ body ) ; return new HttpException ( $ response ) ; }
66	public function isSymlinkedDirectory ( $ directory ) { if ( ! is_dir ( $ directory ) ) { return false ; } $ resolved = $ this -> resolveSymlinkedDirectorySymlink ( $ directory ) ; return is_link ( $ resolved ) ; }
12559	public function fixFile ( $ file ) { $ contents = preg_split ( "/\\r\\n|\\r|\\n/" , file_get_contents ( $ file ) ) ; $ changed = false ; if ( $ this -> fixFileSlashes ( $ file , $ contents ) ) { $ changed = true ; } if ( $ changed ) { file_put_contents ( $ file , implode ( "\n" , $ contents ) ) ; } return $ changed ; }
3580	protected function orderByMeta ( Builder $ query , $ args , $ alias ) { $ query -> with ( 'metaAttributes' ) -> getQuery ( ) -> orderBy ( "{$alias}.meta_value" , $ args -> get ( 'direction' ) ) ; return $ query ; }
2531	private function getStatefulStatusCode ( $ messageName , array $ messageOptions ) { if ( 'Security_Authenticate' === $ messageName ) { return self :: TRANSACTION_STATUS_CODE_START ; } if ( isset ( $ messageOptions [ 'endSession' ] ) && $ messageOptions [ 'endSession' ] === true ) { return self :: TRANSACTION_STATUS_CODE_END ; } return self :: TRANSACTION_STATUS_CODE_INSERIES ; }
10163	private function readSheetLayout ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ offset = 0 ; if ( ! $ this -> readDataOnly ) { $ sz = self :: getInt4d ( $ recordData , 12 ) ; switch ( $ sz ) { case 0x14 : $ colorIndex = self :: getUInt2d ( $ recordData , 16 ) ; $ color = Xls \ Color :: map ( $ colorIndex , $ this -> palette , $ this -> version ) ; $ this -> phpSheet -> getTabColor ( ) -> setRGB ( $ color [ 'rgb' ] ) ; break ; case 0x28 : return ; break ; } } }
12095	public function shortText ( $ text , $ length ) { $ text = trim ( $ text ) ; $ charset = mb_detect_encoding ( $ text ) ; if ( mb_strlen ( $ text , $ charset ) > $ length ) { $ text = mb_substr ( $ text , 0 , $ length , $ charset ) . '...' ; } else { $ text = $ text ; } return $ text ; }
7612	public function getIsSuperAdmin ( ) { if ( $ this -> _isSuperAdmin !== null ) { return $ this -> _isSuperAdmin ; } $ this -> _isSuperAdmin = in_array ( $ this -> username , Yii :: $ app -> getModule ( 'auth' ) -> superAdmins ) ; return $ this -> _isSuperAdmin ; }
8754	public function start ( $ block = true , $ interval = 100 ) { $ loop = $ this -> loop ; $ this -> pool = new ParallelPool ( function ( ) use ( $ loop ) { $ loop -> run ( ) ; } , $ this -> count ) ; $ this -> pool -> start ( ) ; $ this -> pool -> keep ( $ block , $ interval ) ; }
6069	public function listComments ( $ mediaId , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ mediaId . '/comments' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new CommentResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
1897	private function isExistingOptionalFile ( SplFileInfo $ file , string $ webDir ) : bool { $ path = $ file -> getRelativePathname ( ) ; return 'robots.txt' === $ path && $ this -> fs -> exists ( $ webDir . '/' . $ path ) ; }
2971	public static function processAttachments ( array $ attachments ) { $ processed = [ ] ; foreach ( $ attachments as $ attachment ) { if ( ! ( $ attachment instanceof Attachment ) ) { throw new \ InvalidArgumentException ( 'Attachments must implement Stampie\\Attachment' ) ; } $ name = $ attachment -> getName ( ) ; if ( isset ( $ processed [ $ name ] ) ) { $ name = static :: findUniqueName ( $ name , array_keys ( $ processed ) ) ; } $ processed [ $ name ] = $ attachment ; } return $ processed ; }
7147	public function get_user_settings ( $ default = array ( ) , $ user_id = NULL ) { if ( ! $ user_id ) return $ default ; $ default_opt_in = apply_filters ( 'iac_default_opt_in' , FALSE ) ; $ default = $ default_opt_in ? '1' : '0' ; $ settings = array ( 'inform_about_posts' => get_user_meta ( $ user_id , 'post_subscription' , TRUE ) , 'inform_about_comments' => get_user_meta ( $ user_id , 'comment_subscription' , TRUE ) ) ; foreach ( $ settings as $ k => $ v ) { if ( '' === $ v ) $ settings [ $ k ] = $ default ; } return $ settings ; }
4385	protected function dumpObject ( $ abs ) { $ isNested = $ this -> valueDepth > 0 ; $ this -> valueDepth ++ ; if ( $ abs [ 'isRecursion' ] ) { $ str = '(object) ' . $ abs [ 'className' ] . ' *RECURSION*' ; } elseif ( $ abs [ 'isExcluded' ] ) { $ str = '(object) ' . $ abs [ 'className' ] . ' (not inspected)' ; } else { $ str = '(object) ' . $ abs [ 'className' ] . "\n" ; $ str .= $ this -> dumpProperties ( $ abs ) ; if ( $ abs [ 'collectMethods' ] && $ this -> debug -> output -> getCfg ( 'outputMethods' ) ) { $ str .= $ this -> dumpMethods ( $ abs [ 'methods' ] ) ; } } $ str = \ trim ( $ str ) ; if ( $ isNested ) { $ str = \ str_replace ( "\n" , "\n " , $ str ) ; } return $ str ; }
970	public function setDomain ( string $ shopDomain ) { $ this -> fixLifetime ( ) ; Session :: put ( self :: DOMAIN , $ shopDomain ) ; }
2430	public function listStyleSheet ( $ row ) { $ cc = '' ; $ media = Contao \ StringUtil :: deserialize ( $ row [ 'media' ] ) ; if ( $ row [ 'cc' ] != '' ) { $ cc = ' &lt;!--[' . $ row [ 'cc' ] . ']&gt;' ; } if ( $ row [ 'mediaQuery' ] != '' ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . $ row [ 'mediaQuery' ] . $ cc . '</span>' . "</div>\n" ; } elseif ( ! empty ( $ media ) && \ is_array ( $ media ) ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . implode ( ', ' , $ media ) . $ cc . '</span>' . "</div>\n" ; } else { return '<div class="tl_content_left">' . $ row [ 'name' ] . $ cc . "</div>\n" ; } }
74	public function requestToken ( $ originUrl , $ consumerKey , $ consumerSecret ) { if ( ! empty ( $ this -> token ) || $ this -> getTokenFromConfig ( $ originUrl ) ) { return $ this -> token [ 'access_token' ] ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return '' ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; return $ this -> token [ 'access_token' ] ; }
1757	public static function getReadableSize ( $ intSize , $ intDecimals = 1 ) { for ( $ i = 0 ; $ intSize >= 1024 ; $ i ++ ) { $ intSize /= 1024 ; } return static :: getFormattedNumber ( $ intSize , $ intDecimals ) . ' ' . $ GLOBALS [ 'TL_LANG' ] [ 'UNITS' ] [ $ i ] ; }
2519	public function queueList ( RequestOptions \ QueueListOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Queue_List' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
12288	public function loop ( array $ collection , string $ block , string $ emptyBlock = null ) : string { if ( empty ( $ collection ) ) { return isset ( $ emptyBlock ) ? trim ( $ this -> make ( $ emptyBlock ) ) . PHP_EOL : PHP_EOL ; } else { $ items = '' ; foreach ( $ collection as $ key => $ item ) { $ items .= rtrim ( $ this -> make ( $ block , [ 'key' => $ key , 'item' => $ item ] ) ) ; } return ltrim ( $ items ) . PHP_EOL ; } }
8229	public static function readFile ( $ fileName , $ options = [ ] ) { $ reader = new File \ FileReader ( $ fileName , $ options ) ; $ success = true ; $ contents = null ; try { $ reader -> open ( ) ; $ contents = $ reader -> read ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ success = false ; } try { $ reader -> close ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ success = false ; } return ( $ success ) ? $ contents : false ; }
4417	public function showLocationLayouts ( $ locationId ) { $ repository = $ this -> getRepository ( ) ; $ location = $ repository -> getLocationService ( ) -> loadLocation ( $ locationId ) ; $ content = $ repository -> getContentService ( ) -> loadContent ( $ location -> contentInfo -> id ) ; $ request = $ this -> createRequest ( $ content , $ location ) ; return $ this -> render ( '@NetgenAdminUI/layouts/location_layouts.html.twig' , array ( 'rules' => $ this -> layoutResolver -> resolveRules ( $ request , array ( 'ez_content_type' ) ) , 'related_layouts' => $ this -> relatedLayoutsLoader -> loadRelatedLayouts ( $ location ) , 'location' => $ location , ) ) ; }
10761	public function encodeString ( $ string ) { $ string = strtolower ( $ string ) ; $ src = "abcdefghijklmnopqrstuvwxyz0123456789 " ; $ dst = "jklmnopqrstuvwxyz0123456789abcdefghi " ; for ( $ i = 0 ; $ i < strlen ( $ string ) ; $ i ++ ) { $ pos = strpos ( $ src , $ string [ $ i ] ) ; if ( $ pos === false ) { throw new \ Exception ( "Please provide only numbers and alphanumerical characters" ) ; } $ string [ $ i ] = $ dst [ $ pos ] ; } return $ string ; }
10755	protected function buildTblOpt ( ) { $ result = [ ] ; foreach ( $ this -> tbl_option as $ opt ) { $ result [ ] = $ opt ; } if ( empty ( $ result ) ) { $ result [ ] = '' ; } return $ result ; }
2681	public function configureImageOptimizationDefaultConfigOptions ( $ params , $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/io_settings' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , $ params ) ; return $ result ; }
11214	public function count ( $ coraDbQuery = false ) { if ( ! $ coraDbQuery ) { $ coraDbQuery = $ this -> gateway -> getDb ( ) ; } $ coraDbQuery = $ this -> model :: model_constraints ( $ coraDbQuery ) ; return $ this -> gateway -> count ( $ coraDbQuery ) ; }
8930	protected function getStackIconElement ( $ key , $ value , $ index ) { $ element = $ value ; if ( is_string ( $ key ) ) { $ element = $ this -> icon ( $ key ) -> addClass ( $ value ) ; } else if ( is_string ( $ value ) ) { $ element = $ this -> icon ( $ value ) ; } if ( ! is_a ( $ element , FontAwesomeIcon :: class ) ) { throw new \ InvalidArgumentException ( 'Invalid icon passed to stack' ) ; } return $ element -> addClass ( "fa-stack-{$index}x" ) ; }
6897	public function bind ( $ key , & $ value ) { $ this -> open ( ) ; $ this -> _data [ $ key ] = & $ value ; return $ this ; }
6500	public function afterStep ( Scope \ StepScope $ scope ) { if ( ! empty ( $ this -> mainWindow ) && count ( $ this -> getWindowNames ( ) ) == 1 ) { $ this -> iSwitchToWindow ( ) ; } if ( self :: hasTag ( 'javascript' ) && self :: isStepImpliesJsEvent ( $ scope ) ) { $ this -> waitAjaxAndAnimations ( ) ; } }
12146	public function get ( $ name ) { if ( $ this -> exists ( $ name ) ) { $ value = $ this -> settings [ $ name ] ; return $ value ; } return false ; }
10230	public function getContext ( ) { $ s = '' ; foreach ( [ 'a' , 'b' , 'c' , 'd' ] as $ i ) { $ v = $ this -> { $ i } ; $ s .= chr ( $ v & 0xff ) ; $ s .= chr ( ( $ v >> 8 ) & 0xff ) ; $ s .= chr ( ( $ v >> 16 ) & 0xff ) ; $ s .= chr ( ( $ v >> 24 ) & 0xff ) ; } return $ s ; }
92	protected static function validateSyntax ( $ json , $ file = null ) { $ parser = new JsonParser ( ) ; $ result = $ parser -> lint ( $ json ) ; if ( null === $ result ) { if ( defined ( 'JSON_ERROR_UTF8' ) && JSON_ERROR_UTF8 === json_last_error ( ) ) { throw new \ UnexpectedValueException ( '"' . $ file . '" is not UTF-8, could not parse as JSON' ) ; } return true ; } throw new ParsingException ( '"' . $ file . '" does not contain valid JSON' . "\n" . $ result -> getMessage ( ) , $ result -> getDetails ( ) ) ; }
4084	public function getParentOf ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> childMap [ $ metaModelName ] ) ? $ this -> childMap [ $ metaModelName ] : null ; }
7286	public function getInvoices ( $ filter = null ) { if ( null === $ filter ) { return $ this -> invoices ; } return $ this -> invoices -> filter ( function ( InvoiceInterface $ invoice ) use ( $ filter ) { return $ filter xor InvoiceTypes :: isCredit ( $ invoice ) ; } ) ; }
11155	public function getValueByPowers ( array $ values , array $ powers ) { if ( empty ( $ values ) || empty ( $ powers ) || \ count ( $ values ) !== \ count ( $ powers ) ) { throw new InvalidArgumentException ( 'Empty parameter or count not equal' ) ; } $ values = \ array_values ( $ values ) ; $ powers = \ array_values ( $ powers ) ; $ rolledIndex = $ this -> getArrayKeyByPowers ( $ powers ) ; return $ values [ $ rolledIndex ] ; }
5618	public function paintHeader ( $ test_name ) { $ this -> sendNoCacheHeaders ( ) ; echo sprintf ( SIMPLETEST_WEBUNIT_HEAD , $ test_name , $ this -> path . 'js/' , $ this -> path . 'js/' , $ this -> path . 'css/' , $ this -> _getCss ( ) , $ test_name , $ this -> path . 'img/' ) ; flush ( ) ; }
6104	public function wait ( ) { if ( $ this -> getTransport ( ) -> getConfig ( "blocking" ) ) { throw new Ts3Exception ( "only available in non-blocking mode" ) ; } do { $ evt = $ this -> getTransport ( ) -> readLine ( ) ; var_dump ( $ evt ) ; } while ( $ evt instanceof StringHelper && ! $ evt -> section ( TeamSpeak3 :: SEPARATOR_CELL ) -> startsWith ( TeamSpeak3 :: EVENT ) ) ; return new Event ( $ evt , $ this -> getHost ( ) ) ; }
12899	public function getResponse ( ) { if ( $ this -> response ) { return $ this -> response ; } return $ this -> response = \ GuzzleHttp \ Psr7 \ parse_response ( $ this -> getResponseStream ( ) ) ; }
6347	public static function all ( Iterator $ iterator , callable $ predicate ) : bool { while ( $ iterator -> valid ( ) ) { if ( ! Predicates :: call ( $ predicate , $ iterator -> current ( ) ) ) { return false ; } $ iterator -> next ( ) ; } return true ; }
10562	private function _buildControllerName ( $ name ) { $ name = strtoupper ( $ name [ 0 ] ) . substr ( $ name , 1 ) ; $ controller = $ name ; $ namespace = NULL ; foreach ( $ this -> namespaces as $ ns ) { if ( class_exists ( $ ns . $ controller ) ) { $ namespace = $ ns ; $ controller = $ ns . $ controller ; break ; } } if ( NULL === $ namespace ) { return strtoupper ( $ this -> defaultController [ 0 ] ) . substr ( $ this -> defaultController , 1 ) . 'Controller' ; } else { return $ controller ; } }
10825	public static function choice ( $ question , array $ choices , $ defaultValue = null ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( ( string ) $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( count ( $ choices ) > 0 ) { foreach ( $ choices as $ index => $ choice ) { self :: write ( ' [' ) ; self :: write ( ( string ) ( $ index + 1 ) , 'comment' ) ; self :: writeln ( '] ' . $ choice ) ; } } if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( ! isset ( $ choices [ intval ( $ value ) - 1 ] ) ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] Value "' . $ value . '" is invalid' , 'error' ) ; $ value = '' ; } elseif ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
12200	public function getData ( $ object ) { if ( ! $ this -> validateObject ( $ object ) ) { throw new InvalidArgumentException ( "Given object isn't instance of {$this->localName}" ) ; } $ reflection = new ReflectionObject ( $ object ) ; $ data = [ ] ; foreach ( array_keys ( $ this -> properties ) as $ localProperty ) { $ property = $ reflection -> getProperty ( $ localProperty ) ; $ property -> setAccessible ( true ) ; $ data [ $ localProperty ] = $ property -> getValue ( $ object ) ; } return $ data ; }
3162	public function assertQtiRunnerServiceContext ( RunnerServiceContext $ context ) { if ( ! $ context instanceof QtiRunnerServiceContext ) { throw new \ common_exception_InvalidArgumentType ( __CLASS__ , __FUNCTION__ , 0 , QtiRunnerServiceContext :: class , $ context ) ; } }
6106	private function getGridClass ( ) { $ class = [ ] ; foreach ( $ this -> grid as $ grid ) { if ( ! isset ( $ grid [ 'type' ] ) || ! isset ( $ grid [ 'size' ] ) ) { throw new InvalidConfigException ( get_called_class ( ) . ' must have type and size.' ) ; } if ( ! isset ( $ grid [ 'positiontype' ] ) ) $ class [ ] = $ grid [ 'type' ] . $ grid [ 'size' ] ; else $ class [ ] = $ grid [ 'type' ] . $ grid [ 'positiontype' ] . '-' . $ grid [ 'size' ] ; } return implode ( ' ' , $ class ) ; }
1308	private static function urlParameter ( $ url ) { $ start = strpos ( $ url , '{' ) + 1 ; $ length = strpos ( $ url , '}' ) - $ start ; return substr ( $ url , $ start , $ length ) ; }
4321	public static function arrayPathGet ( $ array , $ path ) { if ( ! \ is_array ( $ path ) ) { $ path = \ array_filter ( \ preg_split ( '#[\./]#' , $ path ) , 'strlen' ) ; } $ path = \ array_reverse ( $ path ) ; while ( $ path ) { $ key = \ array_pop ( $ path ) ; $ arrayAccess = \ is_array ( $ array ) || $ array instanceof \ ArrayAccess ; if ( ! $ arrayAccess ) { return null ; } elseif ( isset ( $ array [ $ key ] ) ) { $ array = $ array [ $ key ] ; } elseif ( $ key == '__count__' ) { return \ count ( $ array ) ; } elseif ( $ key == '__end__' ) { \ end ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } elseif ( $ key == '__reset__' ) { \ reset ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } else { return null ; } } return $ array ; }
3470	public function head ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: head ( $ route ) ) ; }
4114	public function getRemoteCallEnabled ( ) { if ( is_null ( $ this -> remoteCallEnabled ) ) { $ this -> remoteCallEnabled = Mage :: getStoreConfigFlag ( 'dev/aoe_templatehints/enablePhpstormRemoteCall' ) ; } return $ this -> remoteCallEnabled ; }
12634	public function reverse ( $ orderNo , $ type = self :: OUT_TRADE_NO ) { $ params = [ $ type => $ orderNo , ] ; return $ this -> safeRequest ( $ this -> wrapApi ( self :: API_REVERSE ) , $ params ) ; }
10410	public function createUrlsTempFile ( ) { $ hash = md5 ( microtime ( true ) ) ; $ links = array_merge ( $ this -> getUrls ( ) , $ this -> getUrlsByDocumentParameter ( ) ) ; $ urlsFile = "/tmp/urls_{$hash}.txt" ; $ urls = [ ] ; foreach ( $ links as $ url ) { $ separator = ( $ url [ 0 ] !== '/' ) ? '/' : '' ; $ urls [ ] = $ this -> baseUrl . $ separator . $ url ; } file_put_contents ( $ urlsFile , implode ( PHP_EOL , $ urls ) ) ; return $ urlsFile ; }
7790	public function setOpeningBalanceClass ( $ openingBalanceClass ) { if ( ! is_callable ( $ openingBalanceClass ) && ! class_exists ( $ openingBalanceClass ) ) { throw new \ InvalidArgumentException ( '$openingBalanceClass must be a valid classname or a PHP callable' ) ; } $ this -> openingBalanceClass = $ openingBalanceClass ; return $ this ; }
4904	protected function createValueOptions ( NodeInterface $ node , $ allowSelectNodes = false , $ isRoot = true ) { $ key = $ isRoot ? $ node -> getValue ( ) : $ node -> getValueWithParents ( ) ; $ name = $ node -> getName ( ) ; if ( $ node -> hasChildren ( ) ) { $ leafOptions = [ ] ; if ( $ allowSelectNodes && ! $ isRoot ) { $ leafOptions [ $ key ] = $ name ; $ key = "$key-group" ; } foreach ( $ node -> getChildren ( ) as $ child ) { $ leafOptions += $ this -> createValueOptions ( $ child , $ allowSelectNodes , false ) ; } $ value = [ 'label' => $ name , 'options' => $ leafOptions ] ; } else { $ value = $ name ; } return [ $ key => $ value ] ; }
9725	public function getTemporaryFilename ( $ extension = 'xlsx' ) { $ temporaryFilename = tempnam ( $ this -> getTemporaryFolder ( ) , 'phpspreadsheet-' ) ; unlink ( $ temporaryFilename ) ; return $ temporaryFilename . '.' . $ extension ; }
3640	public function all ( bool $ trim = true , bool $ clean = true ) { $ values = $ this -> request -> all ( ) ; return $ this -> clean ( $ values , $ trim , $ clean ) ; }
12006	final public function getAuthorityTree ( ) { $ database = $ this -> database ; $ statement = $ database -> select ( ) -> from ( '?authority' ) -> between ( "lft" , '1' , '6' ) -> prepare ( ) ; $ results = $ statement -> execute ( ) ; $ right = array ( ) ; }
5201	public function buildConnectionOptions ( ) { $ connection_name = $ this -> config -> get ( "tail-settings.default" ) ; if ( $ this -> connection_name ) $ connection_name = $ this -> connection_name ; $ connectionOptions = $ this -> config -> get ( "tail-settings.connections.$connection_name" ) ; if ( ! isset ( $ connectionOptions [ 'exchange_type' ] ) ) $ connectionOptions [ 'exchange_type' ] = 'direct' ; if ( ! isset ( $ connectionOptions [ 'content_type' ] ) ) $ connectionOptions [ 'content_type' ] = 'text/plain' ; if ( $ this -> vhost ) $ connectionOptions [ 'vhost' ] = $ this -> vhost ; if ( $ this -> exchange ) $ connectionOptions [ 'exchange' ] = $ this -> exchange ; if ( $ this -> exchange_type ) $ connectionOptions [ 'exchange_type' ] = $ this -> exchange_type ; if ( $ this -> content_type ) $ connectionOptions [ 'content_type' ] = $ this -> content_type ; $ connectionOptions [ 'queue_name' ] = $ this -> queue_name ; return $ connectionOptions ; }
10613	protected function authenticateUser ( UserInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> container -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
3852	public function setSorting ( $ strSortBy , $ strDirection = 'ASC' ) { $ this -> strSortBy = $ strSortBy ; $ this -> strSortDirection = ( $ strDirection == 'DESC' ) ? 'DESC' : 'ASC' ; return $ this ; }
2648	public function uploadVcl ( $ version , $ vcl ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/vcl' ; $ result = $ this -> _fetch ( $ url , 'POST' , $ vcl ) ; return $ result ; }
11353	private function compress ( $ dwnlSnap , $ pv , $ calcId ) { $ in = new \ Praxigento \ Core \ Data ( ) ; $ in -> set ( PPhase1 :: IN_DWNL_PLAIN , $ dwnlSnap ) ; $ in -> set ( PPhase1 :: IN_PV , $ pv ) ; $ in -> set ( PPhase1 :: IN_CALC_ID , $ calcId ) ; $ in -> set ( PPhase1 :: IN_KEY_CALC_ID , EBonDwnl :: A_CALC_REF ) ; $ in -> set ( PPhase1 :: IN_KEY_CUST_ID , QBSnap :: A_CUST_ID ) ; $ in -> set ( PPhase1 :: IN_KEY_PARENT_ID , QBSnap :: A_PARENT_ID ) ; $ in -> set ( PPhase1 :: IN_KEY_DEPTH , QBSnap :: A_DEPTH ) ; $ in -> set ( PPhase1 :: IN_KEY_PATH , QBSnap :: A_PATH ) ; $ in -> set ( PPhase1 :: IN_KEY_PV , EBonDwnl :: A_PV ) ; $ out = $ this -> procPhase1 -> exec ( $ in ) ; $ updates = $ out -> get ( PPhase1 :: OUT_COMPRESSED ) ; $ pvTransfers = $ out -> get ( PPhase1 :: OUT_PV_TRANSFERS ) ; $ result = [ $ updates , $ pvTransfers ] ; return $ result ; }
10522	protected function quoteIndex ( array $ cols ) { $ q = [ ] ; foreach ( $ cols as $ col ) { $ q [ ] = $ this -> quoteLeading ( $ col ) ; } return $ q ; }
643	public function addUnique ( $ name , $ table , $ columns ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addUnique ( $ name , $ table , $ columns ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
12760	public static function dispatch ( $ eventName , Event $ event ) { if ( null === self :: $ dispatcher ) { return $ event ; } self :: $ dispatcher -> dispatch ( $ eventName , $ event ) ; DataLogger :: log ( sprintf ( 'The "%s" event was dispatched' , $ eventName ) ) ; if ( $ event -> getAbort ( ) ) { DataLogger :: log ( sprintf ( 'The "%s" event was aborted' , $ eventName ) , DataLogger :: ERROR ) ; throw new EventAbortedException ( $ event -> getAbortMessage ( ) ) ; } return $ event ; }
224	protected function asIntegerStringFallback ( $ value ) { if ( empty ( $ value ) ) { $ value = 0 ; } $ value = $ this -> normalizeNumericStringValue ( ( string ) $ value ) ; $ separatorPosition = strrpos ( $ value , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ value , 0 , $ separatorPosition ) ; } else { $ integerPart = $ value ; } return $ this -> asDecimalStringFallback ( $ integerPart , 0 ) ; }
694	public function sendMultiple ( array $ messages ) { $ successCount = 0 ; foreach ( $ messages as $ message ) { if ( $ this -> send ( $ message ) ) { $ successCount ++ ; } } return $ successCount ; }
358	function compareByteSize ( $ a , $ b , $ compare = '>=' ) { $ compareExpression = '(' . $ this -> getByteSize ( $ a ) . $ compare . $ this -> getByteSize ( $ b ) . ')' ; return $ this -> evaluateExpression ( $ compareExpression ) ; }
5340	public function setBalancingMode ( $ haipName , $ balancingMode , $ cookieName = '' ) { return $ this -> call ( self :: SERVICE , 'setBalancingMode' , [ $ haipName , $ balancingMode , $ cookieName ] ) ; }
87	private function getDefaultNormalizer ( ) { $ default = $ this -> getDefault ( ) ; $ trueRegex = $ this -> trueAnswerRegex ; $ falseRegex = $ this -> falseAnswerRegex ; return function ( $ answer ) use ( $ default , $ trueRegex , $ falseRegex ) { if ( is_bool ( $ answer ) ) { return $ answer ; } if ( empty ( $ answer ) && ! empty ( $ default ) ) { return $ default ; } if ( preg_match ( $ trueRegex , $ answer ) ) { return true ; } if ( preg_match ( $ falseRegex , $ answer ) ) { return false ; } return null ; } ; }
311	private function applyTableAlias ( $ query , $ conditions , $ alias = null ) { if ( $ alias === null ) { $ alias = array_keys ( $ query -> getTablesUsedInFrom ( ) ) [ 0 ] ; } $ prefixedConditions = [ ] ; foreach ( $ conditions as $ columnName => $ columnValue ) { if ( strpos ( $ columnName , '(' ) === false ) { $ columnName = preg_replace ( '/^' . preg_quote ( $ alias ) . '\.(.*)$/' , '$1' , $ columnName ) ; if ( strpos ( $ columnName , '[[' ) === 0 ) { $ prefixedColumn = "{$alias}.{$columnName}" ; } else { $ prefixedColumn = "{$alias}.[[{$columnName}]]" ; } } else { $ prefixedColumn = $ columnName ; } $ prefixedConditions [ $ prefixedColumn ] = $ columnValue ; } return $ prefixedConditions ; }
9859	public function getStream ( $ stream ) { if ( $ stream === null ) { return null ; } $ streamData = '' ; if ( $ this -> props [ $ stream ] [ 'size' ] < self :: SMALL_BLOCK_THRESHOLD ) { $ rootdata = $ this -> _readData ( $ this -> props [ $ this -> rootentry ] [ 'startBlock' ] ) ; $ block = $ this -> props [ $ stream ] [ 'startBlock' ] ; while ( $ block != - 2 ) { $ pos = $ block * self :: SMALL_BLOCK_SIZE ; $ streamData .= substr ( $ rootdata , $ pos , self :: SMALL_BLOCK_SIZE ) ; $ block = self :: getInt4d ( $ this -> smallBlockChain , $ block * 4 ) ; } return $ streamData ; } $ numBlocks = $ this -> props [ $ stream ] [ 'size' ] / self :: BIG_BLOCK_SIZE ; if ( $ this -> props [ $ stream ] [ 'size' ] % self :: BIG_BLOCK_SIZE != 0 ) { ++ $ numBlocks ; } if ( $ numBlocks == 0 ) { return '' ; } $ block = $ this -> props [ $ stream ] [ 'startBlock' ] ; while ( $ block != - 2 ) { $ pos = ( $ block + 1 ) * self :: BIG_BLOCK_SIZE ; $ streamData .= substr ( $ this -> data , $ pos , self :: BIG_BLOCK_SIZE ) ; $ block = self :: getInt4d ( $ this -> bigBlockChain , $ block * 4 ) ; } return $ streamData ; }
493	private function indexBuckets ( $ buckets , $ indexBy ) { $ result = [ ] ; foreach ( $ buckets as $ key => $ models ) { $ result [ $ key ] = [ ] ; foreach ( $ models as $ model ) { $ index = is_string ( $ indexBy ) ? $ model [ $ indexBy ] : call_user_func ( $ indexBy , $ model ) ; $ result [ $ key ] [ $ index ] = $ model ; } } return $ result ; }
12171	public static function getDefaultForClass ( $ class , array $ params = array ( ) ) { $ reflectionClass = new ReflectionClass ( $ class ) ; if ( ! $ reflectionClass -> isInstantiable ( ) ) { throw new NotInstantiableException ( "Class $class is not instantiable" ) ; } $ factory = new static ( [ $ reflectionClass , 'newInstance' ] , "$class::__construct" ) ; if ( $ reflectionClass -> hasMethod ( '__construct' ) ) { static :: addReflectionArguments ( $ factory , $ reflectionClass -> getMethod ( '__construct' ) ) ; } return $ factory -> getFactory ( $ params ) ; }
12126	public function validate ( string $ sValue = null ) : bool { if ( $ this -> _sType == 'DateTime' ) { if ( preg_match ( '#^[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}#' , $ sValue ) ) { return true ; } } return false ; }
2739	private function uploadVcl ( $ activate ) { try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'priority' => 50 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_pass' , 'statement' => 'req.http.x-pass' , 'type' => 'REQUEST' , 'priority' => 90 ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ request = [ 'action' => 'pass' , 'max_stale_age' => 3600 , 'name' => Config :: FASTLY_MAGENTO_MODULE . '_request' , 'request_condition' => $ createCondition -> name , 'service_id' => $ service -> id , 'version' => $ currActiveVersion ] ; $ this -> api -> createRequest ( $ clone -> number , $ request ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; $ msg = 'Successfully uploaded VCL. ' ; if ( $ activate ) { $ this -> api -> activateVersion ( $ clone -> number ) ; $ msg .= 'Activated Version ' . $ clone -> number ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Upload VCL has been initiated and activated in version ' . $ clone -> number . '*' ) ; } $ this -> output -> writeln ( '<info>' . $ msg . '</info>' , OutputInterface :: OUTPUT_NORMAL ) ; } catch ( \ Exception $ e ) { $ msg = $ e -> getMessage ( ) ; $ this -> output -> writeln ( "<error>$msg</error>" , OutputInterface :: OUTPUT_NORMAL ) ; return ; } }
6207	public function set ( $ key , $ value ) { if ( $ this -> exists ( $ key ) ) { $ this -> dataStore [ $ key ] = $ value ; } }
1053	public static function buildAST ( DocumentNode $ ast , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ builder = new self ( $ ast , $ typeConfigDecorator , $ options ) ; return $ builder -> buildSchema ( ) ; }
11295	public function getAttributeValue ( $ name , $ convertDates = true ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { $ result = $ this -> model_data [ $ name ] ; if ( $ result instanceof \ DateTime && $ convertDates == true ) { $ result = $ result -> format ( 'Y-m-d H:i:s' ) ; } return $ result ; } if ( isset ( $ this -> data -> { $ name } ) ) { return $ this -> data -> { $ name } ; } return null ; }
6292	private function findThemeByDirectory ( $ directory ) { if ( isset ( $ this -> themes [ $ directory ] ) ) { return $ this -> themes [ $ directory ] ; } return null ; }
3823	public function setPageValue ( string $ name , $ value ) : self { if ( empty ( $ value ) ) { unset ( $ this -> page [ $ name ] ) ; return $ this ; } $ this -> page [ $ name ] = $ value ; return $ this ; }
12708	public static function runCommand ( string $ command , array $ arguments = null , array $ options = null ) : void { $ commandObject = new $ command ( $ arguments , $ options ) ; $ commandObject -> update ( $ arguments , $ options ) ; $ commandObject -> handle ( ) ; }
1468	public static function wantsJsonApi ( $ request ) { $ acceptable = $ request -> getAcceptableContentTypes ( ) ; return isset ( $ acceptable [ 0 ] ) && IlluminateStr :: contains ( $ acceptable [ 0 ] , MediaType :: JSON_API_SUB_TYPE ) ; }
11959	public function splice ( $ offset = 0 , $ length = 0 , $ replacement = [ ] ) { return new static ( array_splice ( $ this -> elements , $ offset , $ length , $ replacement ) ) ; }
11122	public function getEndLocation ( ) { $ lastLocation = $ this -> getLocation ( ) ; $ lastDate = NOW ; foreach ( $ this -> movements as $ v ) { if ( $ v -> getEndTime ( ) > $ lastDate ) { $ lastDate = $ v -> getEndTime ( ) ; $ lastLocation = $ v -> getEndLocation ( ) ; } } return $ lastLocation ; }
6491	protected function getInstance ( $ selector = '' ) { if ( empty ( $ this -> object ) ) { throw new \ RuntimeException ( 'Editor instance was not set.' ) ; } if ( empty ( $ this -> selector ) && empty ( $ selector ) ) { throw new \ RuntimeException ( 'No such editor was not selected.' ) ; } $ this -> setSelector ( $ selector ) ; if ( empty ( $ this -> instances [ $ this -> selector ] ) ) { $ instanceId = $ this -> context -> element ( 'field' , $ this -> selector ) -> getAttribute ( 'id' ) ; $ instance = sprintf ( $ this -> object , $ instanceId ) ; if ( ! $ this -> context -> executeJs ( "return !!$instance" ) ) { throw new \ Exception ( sprintf ( 'Editor "%s" was not found.' , $ instanceId ) ) ; } $ this -> instances [ $ this -> selector ] = $ instance ; } return $ this -> instances [ $ this -> selector ] ; }
1057	public static function findTypesThatChangedKind ( Schema $ schemaA , Schema $ schemaB ) : iterable { $ schemaATypeMap = $ schemaA -> getTypeMap ( ) ; $ schemaBTypeMap = $ schemaB -> getTypeMap ( ) ; $ breakingChanges = [ ] ; foreach ( $ schemaATypeMap as $ typeName => $ schemaAType ) { if ( ! isset ( $ schemaBTypeMap [ $ typeName ] ) ) { continue ; } $ schemaBType = $ schemaBTypeMap [ $ typeName ] ; if ( $ schemaAType instanceof $ schemaBType ) { continue ; } if ( $ schemaBType instanceof $ schemaAType ) { continue ; } $ schemaATypeKindName = self :: typeKindName ( $ schemaAType ) ; $ schemaBTypeKindName = self :: typeKindName ( $ schemaBType ) ; $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_CHANGED_KIND , 'description' => "${typeName} changed from ${schemaATypeKindName} to ${schemaBTypeKindName}." , ] ; } return $ breakingChanges ; }
9986	private function mapHAlign ( $ hAlign ) { switch ( $ hAlign ) { case Alignment :: HORIZONTAL_GENERAL : return false ; case Alignment :: HORIZONTAL_LEFT : return 'left' ; case Alignment :: HORIZONTAL_RIGHT : return 'right' ; case Alignment :: HORIZONTAL_CENTER : case Alignment :: HORIZONTAL_CENTER_CONTINUOUS : return 'center' ; case Alignment :: HORIZONTAL_JUSTIFY : return 'justify' ; default : return false ; } }
2639	public function aroundGetElementByPathParts ( \ Closure $ proceed , array $ pathParts ) { $ result = $ proceed ( $ pathParts ) ; if ( $ this -> isLoaded == true || false ) { return $ result ; } if ( ( $ result instanceof Section ) == false ) { return $ result ; } if ( isset ( $ pathParts [ 0 ] ) == false || $ pathParts [ 0 ] != 'system' ) { return $ result ; } $ this -> isLoaded = true ; $ data = $ result -> getData ( ) ; if ( isset ( $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ) == false ) { return $ result ; } $ original = $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ; $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] = array_merge ( $ original , $ this -> loadModlyData ( ) ) ; $ result -> setData ( $ data , $ this -> scopeDefiner -> getScope ( ) ) ; return $ result ; }
7525	function select ( $ query = '*' , $ index = false , $ recursive = true , $ check_self = false ) { return $ this -> root -> select ( $ query , $ index , $ recursive , $ check_self ) ; }
7294	public function inform_about_posts ( $ post_id = FALSE ) { if ( ! $ post_id ) { return $ post_id ; } if ( ! isset ( $ this -> transit_posts [ $ post_id ] ) ) { return $ post_id ; } $ transit = $ this -> transit_posts [ $ post_id ] ; if ( 'publish' != $ transit [ 'new_status' ] || 'publish' == $ transit [ 'old_status' ] ) { return $ post_id ; } $ post_data = get_post ( $ post_id ) ; $ user = get_userdata ( $ post_data -> post_author ) ; $ to = $ this -> get_members ( $ user -> data -> user_email , 'post' ) ; if ( empty ( $ to ) ) { return $ post_id ; } $ subject = get_option ( 'blogname' ) . ': ' . get_the_title ( $ post_data -> ID ) ; $ message = $ post_data -> post_content ; $ headers = array ( ) ; $ headers [ 'From' ] = get_the_author_meta ( 'display_name' , $ user -> ID ) . ' (' . get_bloginfo ( 'name' ) . ')' . ' <' . $ user -> data -> user_email . '>' ; if ( $ this -> options [ 'send_by_bcc' ] ) { $ bcc = $ to ; $ to = empty ( $ this -> options [ 'bcc_to_recipient' ] ) ? get_bloginfo ( 'admin_email' ) : $ this -> options [ 'bcc_to_recipient' ] ; $ headers [ 'Bcc' ] = $ bcc ; } $ to = apply_filters ( 'iac_post_to' , $ to , $ this -> options , $ post_id ) ; $ subject = apply_filters ( 'iac_post_subject' , $ subject , $ this -> options , $ post_id ) ; $ message = apply_filters ( 'iac_post_message' , $ message , $ this -> options , $ post_id ) ; $ headers = apply_filters ( 'iac_post_headers' , $ headers , $ this -> options , $ post_id ) ; $ attachments = apply_filters ( 'iac_post_attachments' , array ( ) , $ this -> options , $ post_id ) ; $ signature = apply_filters ( 'iac_post_signature' , '' , $ this -> options , $ post_id ) ; $ this -> options [ 'static_options' ] [ 'object' ] = array ( 'id' => $ post_id , 'type' => 'post' ) ; $ this -> send_mail ( $ to , $ subject , $ this -> append_signature ( $ message , $ signature ) , $ headers , $ attachments ) ; return $ post_id ; }
15	public function replaceVersion ( $ version , $ prettyVersion ) { $ this -> version = $ version ; $ this -> prettyVersion = $ prettyVersion ; $ this -> stability = VersionParser :: parseStability ( $ version ) ; $ this -> dev = $ this -> stability === 'dev' ; }
9357	public function withoutHeader ( $ name ) { $ instance = clone $ this ; if ( $ this -> hasHeader ( $ name ) ) { $ static = clone $ this ; unset ( $ static -> headers [ $ name ] ) ; $ instance = $ static ; } return $ instance ; }
185	protected function renderInputHtml ( $ type ) { if ( $ this -> hasModel ( ) ) { return Html :: activeInput ( $ type , $ this -> model , $ this -> attribute , $ this -> options ) ; } return Html :: input ( $ type , $ this -> name , $ this -> value , $ this -> options ) ; }
7441	protected function hasAccessToAction ( $ packageKey , $ subpackageKey , $ controllerName , $ actionName ) { $ actionControllerName = $ this -> router -> getControllerObjectName ( $ packageKey , $ subpackageKey , $ controllerName ) ; try { return $ this -> privilegeManager -> isGranted ( 'Neos\Flow\Security\Authorization\Privilege\Method\MethodPrivilege' , new MethodPrivilegeSubject ( new JoinPoint ( NULL , $ actionControllerName , $ actionName . 'Action' , array ( ) ) ) ) ; } catch ( AccessDeniedException $ e ) { return FALSE ; } }
1198	protected function escape ( $ value ) { return $ this -> fixDoubleEscape ( htmlspecialchars ( ( string ) $ value , ENT_QUOTES | ENT_SUBSTITUTE , $ this -> charset ) ) ; }
543	public function init ( ) { parent :: init ( ) ; if ( $ this -> logFile === null ) { $ this -> logFile = Yii :: $ app -> getRuntimePath ( ) . '/logs/app.log' ; } else { $ this -> logFile = Yii :: getAlias ( $ this -> logFile ) ; } if ( $ this -> maxLogFiles < 1 ) { $ this -> maxLogFiles = 1 ; } if ( $ this -> maxFileSize < 1 ) { $ this -> maxFileSize = 1 ; } }
8484	public static function getHostname ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Name FROM Win32_ComputerSystem" ) as $ cs ) { return $ cs -> Name ; } return "Unknown" ; }
337	protected function extractColumnType ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> dbType = $ dbType ; if ( strpos ( $ dbType , 'FLOAT' ) !== false || strpos ( $ dbType , 'DOUBLE' ) !== false ) { $ column -> type = 'double' ; } elseif ( strpos ( $ dbType , 'NUMBER' ) !== false ) { if ( $ scale === null || $ scale > 0 ) { $ column -> type = 'decimal' ; } else { $ column -> type = 'integer' ; } } elseif ( strpos ( $ dbType , 'INTEGER' ) !== false ) { $ column -> type = 'integer' ; } elseif ( strpos ( $ dbType , 'BLOB' ) !== false ) { $ column -> type = 'binary' ; } elseif ( strpos ( $ dbType , 'CLOB' ) !== false ) { $ column -> type = 'text' ; } elseif ( strpos ( $ dbType , 'TIMESTAMP' ) !== false ) { $ column -> type = 'timestamp' ; } else { $ column -> type = 'string' ; } }
1893	public function onAuthenticationFailure ( Request $ request , AuthenticationException $ exception ) : Response { if ( null === $ this -> logger ) { return parent :: onAuthenticationFailure ( $ request , $ exception ) ; } if ( $ exception instanceof AccountStatusException && ( $ user = $ exception -> getUser ( ) ) instanceof UserInterface ) { $ username = $ user -> getUsername ( ) ; } else { $ username = $ request -> request -> get ( 'username' ) ; } $ this -> logger -> info ( $ exception -> getMessage ( ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ username ) ] ) ; return parent :: onAuthenticationFailure ( $ request , $ exception ) ; }
8516	public function updateInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_UpdateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10848	protected function getTableName ( $ returnAlias = false ) { $ result = '' ; foreach ( $ this -> clause_table as $ k => $ v ) { if ( ! is_int ( $ k ) && $ returnAlias ) { return $ k ; } else { return $ v ; } } return $ result ; }
4818	public function addField ( $ name , $ value ) { if ( $ this -> currentRow < 0 ) { $ this -> appendRow ( ) ; } $ this -> collection [ $ this -> currentRow ] -> addField ( $ name , $ value ) ; }
3524	private function fetch ( $ account_id ) { if ( ! $ account_id ) return null ; $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_API . 'stats/accountId/' . $ account_id . '/bulk/window/alltime' , $ this -> access_token ) ; $ this -> display_name = Account :: getDisplayNameFromID ( str_replace ( "-" , "" , $ this -> account_id ) , $ this -> access_token ) ; $ compiledStats = [ ] ; foreach ( $ data as $ stat ) { $ parsed = $ this -> parseStatItem ( $ stat ) ; $ compiledStats = array_merge_recursive ( $ compiledStats , $ parsed ) ; } $ platforms = [ ] ; foreach ( $ compiledStats as $ key => $ platform ) { $ platforms [ $ key ] = new Platform ( $ platform ) ; } return $ platforms ; }
5829	public function newRawRequest ( $ method , $ url , $ data = '' ) { return $ this -> newRequest ( $ method , $ url , $ data , Request :: ENCODING_RAW ) ; }
10081	protected function registerManager ( ) { $ this -> app -> singleton ( 'auja' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new Auja ( $ app , $ app [ 'auja.configurator' ] , $ config [ 'models' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Auja' , 'auja' ) ; }
7485	public function charAt ( $ index ) { $ index = ( int ) $ index ; if ( $ index < 0 || $ index >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_substr ( $ this -> string , $ index , 1 , $ this -> encoding ) ; }
3796	private function checkForRoot ( $ containedModel , $ action ) { if ( $ this -> hasVariants ( ) && $ action == 'cut' && $ containedModel -> getProperty ( 'varbase' ) == 0 ) { $ this -> disablePI = true ; } }
8810	public function destroy ( ) { foreach ( $ _COOKIE as $ key => $ value ) { setcookie ( $ key , null , - 1 , '/' ) ; unset ( $ _COOKIE [ $ key ] ) ; } return ; }
2234	public function showDeletedRecords ( $ data , $ row ) { $ arrData = Contao \ StringUtil :: deserialize ( $ row [ 'data' ] ) ; foreach ( $ arrData as $ strTable => $ arrTableData ) { Contao \ System :: loadLanguageFile ( $ strTable ) ; Contao \ Controller :: loadDataContainer ( $ strTable ) ; foreach ( $ arrTableData as $ arrRow ) { $ arrBuffer = array ( ) ; foreach ( $ arrRow as $ i => $ v ) { if ( \ is_array ( Contao \ StringUtil :: deserialize ( $ v ) ) ) { continue ; } if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ; } else { $ label = \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] [ 0 ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ; } if ( ! $ label ) { $ label = $ i ; } $ arrBuffer [ $ label ] = $ v ; } $ data [ $ strTable ] [ ] = $ arrBuffer ; } } return $ data ; }
6927	protected function notify ( $ type , $ resource ) { $ notify = $ this -> builder -> create ( $ type , $ resource ) ; if ( ! $ this -> builder -> build ( $ notify ) ) { return ; } $ this -> queue -> add ( $ notify ) ; }
10146	private function readStyle ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ ixfe = self :: getUInt2d ( $ recordData , 0 ) ; $ xfIndex = ( 0x0FFF & $ ixfe ) >> 0 ; $ isBuiltIn = ( bool ) ( ( 0x8000 & $ ixfe ) >> 15 ) ; if ( $ isBuiltIn ) { $ builtInId = ord ( $ recordData [ 2 ] ) ; switch ( $ builtInId ) { case 0x00 : break ; default : break ; } } } }
12392	public function getPages ( $ startPage , $ endPage , $ urlStub ) { $ pages = [ ] ; for ( $ x = $ startPage ; $ x <= $ endPage ; $ x ++ ) { $ pages [ ] = $ urlStub . $ x ; } return $ pages ; }
2258	protected function prepareForWidget ( $ arrData , $ strName , $ varValue = null , $ strField = '' , $ strTable = '' ) { @ trigger_error ( 'Using Controller::prepareForWidget() has been deprecated and will no longer work in Contao 5.0. Use Widget::getAttributesFromDca() instead.' , E_USER_DEPRECATED ) ; return Widget :: getAttributesFromDca ( $ arrData , $ strName , $ varValue , $ strField , $ strTable ) ; }
8523	public function setAdvertisingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdvertisingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10726	public function getUsers ( ) { $ select = $ this -> tableGateway -> getSql ( ) -> select ( ) ; $ select -> columns ( [ "fullname" => new Expression ( "DISTINCT(CONCAT(usr_firstname, ' ', usr_lastname))" ) ] ) ; $ select -> join ( 'melis_core_user' , 'melis_core_user.usr_id = melis_hist_page_historic.hist_user_id' , [ ] , $ select :: JOIN_INNER ) ; $ resultSet = $ this -> tableGateway -> selectWith ( $ select ) ; return $ resultSet ; }
4187	public function publish ( $ provider ) { $ class = last ( explode ( '\\' , $ provider ) ) ; $ this -> console -> info ( "Searching {$provider} to publish vendor file." ) ; if ( ! $ this -> finder -> contains ( $ class ) -> contains ( '/\$this->publishes/i' ) -> count ( ) ) { $ this -> console -> warn ( 'Nothing to publish.' ) ; return true ; } $ tag = $ this -> console -> ask ( "If the \"{$this->console->tokenizePackageInfo()['name']}\" has specify vendor publish tag in installation guide then please add it here or press enter to skip adding tag." , false ) ; $ this -> console -> call ( 'vendor:publish' , [ '--provider' => $ provider , '--tag' => $ tag , ] ) ; return $ this -> registered = true ; }
8949	function constructUrl ( Request $ appRequest , Nette \ Http \ Url $ refUrl ) { return $ this -> getRouter ( ) -> constructUrl ( $ appRequest , $ refUrl ) ; }
8044	public static function setProcessTitle ( $ title , array $ replacements = array ( ) ) { if ( trim ( $ title ) == '' || PHP_OS == 'Darwin' ) { return ; } $ title = preg_replace_callback ( '/\%([a-z0-9]+)\%/i' , function ( $ match ) use ( $ replacements ) { if ( isset ( $ replacements [ $ match [ 1 ] ] ) ) { return $ replacements [ $ match [ 1 ] ] ; } return $ match [ 0 ] ; } , $ title ) ; $ title = preg_replace ( '/[^a-z0-9-_.: \\\\\\]\\[]/i' , '' , $ title ) ; if ( function_exists ( 'cli_set_process_title' ) ) { cli_set_process_title ( $ title ) ; } elseif ( function_exists ( 'setproctitle' ) ) { setproctitle ( $ title ) ; } }
10453	public function assignResetToken ( $ token , $ email ) { $ user = $ this -> user -> whereEmail ( $ email ) -> first ( ) ; $ user -> reset_token = $ token ; $ user -> save ( ) ; }
4208	private function isObjExcluded ( $ obj ) { if ( \ in_array ( \ get_class ( $ obj ) , $ this -> abstracter -> getCfg ( 'objectsExclude' ) ) ) { return true ; } foreach ( $ this -> abstracter -> getCfg ( 'objectsExclude' ) as $ exclude ) { if ( \ is_subclass_of ( $ obj , $ exclude ) ) { return true ; } } return false ; }
1161	private function fakeRequiredIfData ( $ data , $ rule , $ parameters ) { if ( $ rule !== 'RequiredIf' ) { return ; } $ newData = $ data ; $ newData [ $ parameters [ 0 ] ] = $ parameters [ 1 ] ; $ this -> validator -> setData ( $ newData ) ; }
2624	private function sendReqToGA ( $ body = '' , $ method = \ Zend_Http_Client :: POST , $ uri = self :: GA_API_ENDPOINT ) { $ reqGAData = ( array ) $ this -> getGAReqData ( ) ; if ( $ body != '' && is_array ( $ body ) && ! empty ( $ body ) ) { $ body = array_merge ( $ reqGAData , $ body ) ; } try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> addOption ( CURLOPT_TIMEOUT , 10 ) ; $ client -> write ( $ method , $ uri , '1.1' , null , http_build_query ( $ body ) ) ; $ response = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; $ client -> close ( ) ; if ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( 'Return status ' . $ responseCode ) ) ; } return true ; } catch ( \ Exception $ e ) { return false ; } }
6263	public function nextkey ( ) { if ( $ this -> keys === null ) { return $ this -> firstkey ( ) ; } return empty ( $ this -> keys ) ? false : array_shift ( $ this -> keys ) ; }
1852	protected function getNextPage ( $ rootPageId ) { $ objNextPage = PageModel :: findFirstPublishedByPid ( $ rootPageId ) ; if ( null === $ objNextPage ) { $ this -> log ( 'No active page found under root page "' . $ rootPageId . '")' , __METHOD__ , TL_ERROR ) ; throw new NoActivePageFoundException ( 'No active page found under root page.' ) ; } return $ objNextPage ; }
10370	public static function add ( $ type , $ data = [ ] ) { $ is_admin = is_admin ( ) ; if ( self :: validate ( $ type , $ data , $ is_admin ) ) { $ hook = $ is_admin ? 'admin_enqueue_scripts' : 'wp_enqueue_scripts' ; $ method = __CLASS__ . "::add_{$type}s" ; if ( has_action ( $ hook , $ method ) === false ) { add_action ( $ hook , $ method ) ; } return true ; } return false ; }
9181	public function forget ( $ args = [ ] ) { if ( ! empty ( $ args ) ) { if ( is_array ( $ args ) ) { $ args = implode ( '_' , $ args ) ; } if ( empty ( $ this -> forgetful ) ) { $ this -> forgetful = get_class_methods ( $ this ) ; } foreach ( $ this -> forgetful as $ method ) { $ cacheKey = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ method . '_' ) ; $ this -> forgetByKey ( $ cacheKey ) ; $ cacheKey = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ method . '_' . $ args ) ; $ this -> forgetByKey ( $ cacheKey ) ; } } else { $ key = $ this -> getRememberKey ( ) ; $ this -> forgetByKey ( $ key ) ; } return $ this ; }
7074	private function addSaleDetails ( array & $ details , Model \ SaleInterface $ sale ) { if ( $ sale -> getCurrency ( ) -> getCode ( ) !== $ this -> currency ) { return ; } if ( 0 !== Money :: compare ( $ sale -> getGrandTotal ( ) , $ details [ 'PAYMENTREQUEST_0_AMT' ] , $ this -> currency ) ) { return ; } $ this -> calculator -> calculateSale ( $ sale ) ; $ this -> line = 0 ; $ lineTotals = 0 ; foreach ( $ sale -> getItems ( ) as $ item ) { $ lineTotals += $ this -> addItemDetails ( $ details , $ item ) ; } foreach ( $ sale -> getAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ discount ) { $ lineTotals += $ this -> addDiscountDetails ( $ details , $ discount ) ; } $ details [ 'PAYMENTREQUEST_0_ITEMAMT' ] = $ this -> format ( $ lineTotals ) ; $ details [ 'PAYMENTREQUEST_0_SHIPPINGAMT' ] = $ this -> format ( $ sale -> getShipmentResult ( ) -> getTotal ( ) ) ; }
7653	public function dir_opendir ( $ path , $ options ) { $ this -> blobs = $ this -> getStorageClient ( $ path ) -> listBlobs ( $ this -> getContainerName ( $ path ) ) ; return is_array ( $ this -> blobs ) ; }
3752	public function resetFallback ( $ strField ) { @ trigger_error ( __CLASS__ . '::' . __METHOD__ . ' is deprecated - handle resetting manually' , E_USER_DEPRECATED ) ; $ metaModel = $ this -> getMetaModel ( ) ; $ attribute = $ metaModel -> getAttribute ( $ strField ) ; $ ids = $ metaModel -> getIdsFromFilter ( null ) ; if ( $ attribute instanceof IComplex ) { $ attribute -> unsetDataFor ( $ ids ) ; } if ( $ attribute instanceof ITranslated ) { $ attribute -> unsetValueFor ( $ ids , $ this -> getCurrentLanguage ( ) ) ; } if ( $ attribute instanceof IAttribute ) { $ data = array ( ) ; foreach ( $ ids as $ id ) { $ data [ $ id ] = null ; } $ attribute -> setDataFor ( $ data ) ; } throw new \ RuntimeException ( 'Unknown attribute or type ' . $ strField ) ; }
8916	public function parseSubjectAddedEntry ( QuiteSimpleXmlElement & $ node ) { $ out = array ( 'term' => '' , 'vocabulary' => null ) ; $ vocabularies = array ( '0' => 'lcsh' , '1' => 'lccsh' , '2' => 'mesh' , '3' => 'atg' , '5' => 'cash' , '6' => 'rvm' , ) ; $ ind2 = $ node -> attr ( 'ind2' ) ; $ id = $ node -> text ( 'marc:subfield[@code="0"]' ) ; $ out [ 'id' ] = empty ( $ id ) ? null : $ id ; if ( isset ( $ vocabularies [ $ ind2 ] ) ) { $ out [ 'vocabulary' ] = $ vocabularies [ $ ind2 ] ; } elseif ( $ ind2 == '7' ) { $ vocab = $ node -> text ( 'marc:subfield[@code="2"]' ) ; if ( ! empty ( $ vocab ) ) { $ out [ 'vocabulary' ] = $ vocab ; } } elseif ( $ ind2 == '4' ) { $ this -> parseAuthority ( $ node -> text ( 'marc:subfield[@code="0"]' ) , $ out ) ; } $ out [ 'parts' ] = array ( ) ; $ subdivtypes = array ( 'v' => 'form' , 'x' => 'general' , 'y' => 'chronologic' , 'z' => 'geographic' , ) ; foreach ( $ node -> all ( 'marc:subfield' ) as $ subdiv ) { $ code = $ subdiv -> attr ( 'code' ) ; if ( in_array ( $ code , array_keys ( $ subdivtypes ) ) ) { $ subdiv = trim ( $ subdiv , '.' ) ; $ out [ 'parts' ] [ ] = array ( 'value' => $ subdiv , 'type' => $ subdivtypes [ $ code ] ) ; $ out [ 'term' ] .= self :: $ subfieldSeparator . $ subdiv ; } } return $ out ; }
5004	protected function createEventManager ( $ services , $ config ) { if ( $ services -> has ( $ config [ 'service' ] ) ) { $ events = $ services -> get ( $ config [ 'service' ] ) ; } else { if ( ! class_exists ( $ config [ 'service' ] , true ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Class or service %s does not exists. Cannot create event manager instance.' , $ config [ 'service' ] ) ) ; } $ events = new $ config [ 'service' ] ( ) ; } if ( false === $ config [ 'configure' ] ) { return $ events ; } $ events -> setIdentifiers ( $ config [ 'identifiers' ] ) ; $ event = $ services -> has ( $ config [ 'event' ] ) ? $ services -> get ( $ config [ 'event' ] ) : new $ config [ 'event' ] ( ) ; $ events -> setEventPrototype ( $ event ) ; if ( 'EventManager' != $ config [ 'service' ] && method_exists ( $ events , 'setSharedManager' ) && $ services -> has ( 'SharedEventManager' ) ) { $ sharedEvents = $ services -> get ( 'SharedEventManager' ) ; $ events -> setSharedManager ( $ sharedEvents ) ; } return $ events ; }
9293	protected function getAssetsUrl ( ) { if ( ! isset ( $ this -> _assetsUrl ) ) { $ path = dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'assets' ; $ this -> _assetsUrl = Yii :: app ( ) -> assetManager -> publish ( $ path , false , - 1 , $ this -> forceCopyAssets ) ; } return $ this -> _assetsUrl ; }
6496	public function getCurrentId ( ) { $ args = arg ( ) ; return count ( $ args ) > 1 && $ this -> entityType ( ) === $ args [ 0 ] && $ args [ 1 ] > 0 ? ( int ) $ args [ 1 ] : 0 ; }
8079	public function & getErrors ( $ channel = null ) { $ channel = $ this -> namespaceChannel ( $ channel ) ; if ( ! isset ( $ this -> console [ 'errors' ] [ $ channel ] ) ) { $ this -> console [ 'errors' ] [ $ channel ] = array ( ) ; } return $ this -> console [ 'errors' ] [ $ channel ] ; }
12355	public function setVariables ( array $ data ) : void { foreach ( $ data as $ key => $ value ) { $ this -> $ key = $ value ; } }
8840	public function setExitCode ( $ exitCode ) { \ Assert \ that ( $ exitCode ) -> integer ( ) -> min ( 0 ) ; $ this -> exitCode = $ exitCode ; return $ this ; }
7204	public function getDiscount ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> discount ) : $ this -> discount ; }
10541	public function getFiltroConfiguration ( $ filtroName ) { if ( ! isset ( $ this -> config [ 'filtros' ] [ $ filtroName ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Filtro "%s" is not managed.' , $ filtroName ) ) ; } return $ this -> config [ 'filtros' ] [ $ filtroName ] ; }
11534	public static function writeFile ( $ file , $ content ) { $ handle = fopen ( $ file , 'w' ) ; if ( ! self :: lockFile ( $ handle , LOCK_EX | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_writing' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } if ( fwrite ( $ handle , $ content ) === false ) { $ exception = array ( "message" => 'exception_file_cannot_be_written' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } self :: unlockFile ( $ handle ) ; }
3449	public function setAttribute ( $ key , $ value ) { if ( in_array ( $ key , $ this -> multipleHighloadBlockFields ) ) { $ this -> attributes [ $ key ] = serialize ( $ value ) ; return $ this ; } parent :: setAttribute ( $ key , $ value ) ; return $ this ; }
10997	public function read ( int $ offset = 0 ) { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE ) === false ) { $ this -> error = "failed to read file; {$this->error}" ; return false ; } return $ this -> readFile ( $ offset ) ; }
11660	public static function readFromString ( $ string ) { $ xml = new \ DOMDocument ( ) ; $ xml -> loadXML ( $ string ) ; $ result = [ ] ; $ props = $ xml -> childNodes -> item ( $ xml -> childNodes -> length - 1 ) -> childNodes ; for ( $ i = 0 ; $ i < $ props -> length ; $ i ++ ) { $ entry = $ props -> item ( $ i ) ; if ( $ entry -> nodeName == "entry" ) $ result [ $ entry -> attributes -> getNamedItem ( "key" ) -> nodeValue ] = $ entry -> textContent ; } return $ result ; }
3864	private function setTitleAndDescription ( ) { $ page = $ this -> getPage ( ) ; if ( $ page && $ this -> objItems -> getCount ( ) ) { if ( ! empty ( $ this -> strTitleAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrTitle = $ objCurrentItem -> parseAttribute ( $ this -> strTitleAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrTitle [ 'text' ] ) ) { $ page -> pageTitle = strip_tags ( $ arrTitle [ 'text' ] ) ; break ; } } $ this -> objItems -> reset ( ) ; } if ( ! empty ( $ this -> strDescriptionAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrDescription = $ objCurrentItem -> parseAttribute ( $ this -> strDescriptionAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrDescription [ 'text' ] ) ) { $ page -> description = StringUtil :: substr ( $ arrDescription [ 'text' ] , 160 ) ; break ; } } $ this -> objItems -> reset ( ) ; } } }
10108	private function writeSelection ( ) { $ selectedCells = Coordinate :: splitRange ( $ this -> phpSheet -> getSelectedCells ( ) ) ; $ selectedCells = $ selectedCells [ 0 ] ; if ( count ( $ selectedCells ) == 2 ) { list ( $ first , $ last ) = $ selectedCells ; } else { $ first = $ selectedCells [ 0 ] ; $ last = $ selectedCells [ 0 ] ; } list ( $ colFirst , $ rwFirst ) = Coordinate :: coordinateFromString ( $ first ) ; $ colFirst = Coordinate :: columnIndexFromString ( $ colFirst ) - 1 ; -- $ rwFirst ; list ( $ colLast , $ rwLast ) = Coordinate :: coordinateFromString ( $ last ) ; $ colLast = Coordinate :: columnIndexFromString ( $ colLast ) - 1 ; -- $ rwLast ; $ colFirst = min ( $ colFirst , 255 ) ; $ colLast = min ( $ colLast , 255 ) ; $ rwFirst = min ( $ rwFirst , 65535 ) ; $ rwLast = min ( $ rwLast , 65535 ) ; $ record = 0x001D ; $ length = 0x000F ; $ pnn = $ this -> activePane ; $ rwAct = $ rwFirst ; $ colAct = $ colFirst ; $ irefAct = 0 ; $ cref = 1 ; if ( ! isset ( $ rwLast ) ) { $ rwLast = $ rwFirst ; } if ( ! isset ( $ colLast ) ) { $ colLast = $ colFirst ; } if ( $ rwFirst > $ rwLast ) { list ( $ rwFirst , $ rwLast ) = [ $ rwLast , $ rwFirst ] ; } if ( $ colFirst > $ colLast ) { list ( $ colFirst , $ colLast ) = [ $ colLast , $ colFirst ] ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'CvvvvvvCC' , $ pnn , $ rwAct , $ colAct , $ irefAct , $ cref , $ rwFirst , $ rwLast , $ colFirst , $ colLast ) ; $ this -> append ( $ header . $ data ) ; }
9079	private static function parseUri ( Request & $ request , $ uri , $ defaultController , $ defaultAction ) { $ contextUri = $ uri ; if ( null != $ request -> getContextPrefix ( ) && '/' != $ request -> getContextPrefix ( ) ) { $ contextUri = str_replace ( $ request -> getContextPrefix ( ) , '' , $ uri ) ; } $ parts = array ( ) ; if ( $ contextUri != '' ) { while ( isset ( $ contextUri [ 0 ] ) && $ contextUri [ 0 ] == '/' ) { $ contextUri = substr ( $ contextUri , 1 ) ; } $ parts = explode ( '/' , $ contextUri ) ; } if ( count ( $ parts ) > 0 ) { $ request -> setController ( ucfirst ( trim ( $ parts [ 0 ] ) ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getController ( ) ) { $ request -> setController ( $ defaultController ) ; } } if ( count ( $ parts ) > 0 ) { $ request -> setAction ( trim ( $ parts [ 0 ] ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getAction ( ) ) { $ request -> setAction ( $ defaultAction ) ; } } return $ parts ; }
2120	public function getFromFile ( ) { $ return = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'config' ) -> depth ( 0 ) -> files ( ) -> name ( 'database.sql' ) ; foreach ( $ files as $ file ) { $ return = array_replace_recursive ( $ return , SqlFileParser :: parse ( $ file ) ) ; } ksort ( $ return ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ return = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ return ) ; } } return $ return ; }
1945	public function sections ( $ key = null , $ template = null ) { if ( ! array_filter ( $ this -> sections ) ) { return ; } if ( $ key && ! isset ( $ this -> positions [ $ key ] ) ) { return ; } $ matches = array ( ) ; foreach ( $ this -> positions [ $ key ] as $ id => $ section ) { if ( ! empty ( $ this -> sections [ $ id ] ) ) { $ section [ 'content' ] = $ this -> sections [ $ id ] ; $ matches [ $ id ] = $ section ; } } if ( empty ( $ matches ) ) { return ; } $ this -> matches = $ matches ; if ( $ template === null ) { $ template = 'block_sections' ; } include $ this -> getTemplate ( $ template ) ; }
8178	protected function sendMail ( $ to , $ subject , $ view , $ params = [ ] ) { $ mailer = Yii :: $ app -> mailer ; $ mailer -> viewPath = '@abhimanyu/user/views/mail' ; return $ mailer -> compose ( [ 'html' => $ view , 'text' => 'text/' . $ view ] , $ params ) -> setTo ( $ to ) -> setFrom ( Yii :: $ app -> config -> get ( 'mail.username' ) , 'no@reply.com' ) -> setSubject ( $ subject ) -> send ( ) ; }
2879	public function enableTemplateHintsAction ( ) { try { $ this -> getService ( ) -> setTemplateHints ( 1 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Template hints cannot be enabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
6558	public function slug ( Entity $ entity ) { $ config = $ this -> config ( ) ; $ value = $ entity -> get ( $ config [ 'field' ] ) ; $ entity -> set ( $ config [ 'slug' ] , strtolower ( Inflector :: slug ( $ value , $ config [ 'replacement' ] ) ) ) ; }
5165	public function render ( DataBuilder $ data_builder , $ parameters , array $ data = [ ] ) { $ parameters = $ this -> castParameters ( $ parameters ) ; $ tm = new TemplateManager ( ) ; $ result = new Result ( ) ; try { $ bag = new Bag ( $ parameters ) ; $ bag -> set ( 'body' , $ tm -> renderRaw ( 'text/html' , strval ( $ bag -> get ( 'body' ) ) , $ data ) ) ; $ attachments = [ ] ; foreach ( ( array ) Yaml :: parse ( strval ( $ bag -> get ( 'attachments' ) ) ) as $ key => $ attachment ) { $ attachment = ( object ) $ attachment ; $ attachments [ $ key ] [ 'as' ] = strval ( $ tm -> renderRaw ( 'text/plain' , $ attachment -> as , $ data ) ) ; $ attachments [ $ key ] [ 'source' ] = strval ( $ tm -> renderRaw ( 'text/plain' , $ attachment -> source , $ data ) ) ; } $ bag -> set ( 'attachments' , $ attachments ) ; $ bag -> set ( 'recipients' , explode ( ',' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'recipients' ) ) , $ data ) ) ) ; $ bag -> set ( 'subject' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'subject' ) ) , $ data ) ) ; $ bag -> set ( 'sender' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'sender' ) ) , $ data ) ) ; $ result -> setResources ( new Collection ( [ $ bag -> toArray ( ) ] ) ) ; } catch ( \ Twig_Error $ e ) { $ e = new Exceptions \ EmailSenderRenderException ( $ e -> getRawMessage ( ) . ' on line ' . $ e -> getTemplateLine ( ) ) ; $ result -> addErrors ( new Collection ( [ $ e ] ) ) ; } return $ result ; }
9006	public function build ( $ options = array ( ) ) { if ( is_string ( $ options ) ) { $ options = array ( 'type' => $ options , ) ; } else if ( ! is_array ( $ options ) ) { $ options = array ( 'type' => 'text' , ) ; } if ( empty ( $ options [ 'type' ] ) ) { $ options [ 'type' ] = 'text' ; } if ( empty ( $ options [ 'data_type' ] ) ) { $ options [ 'data_type' ] = 'metadata' ; } $ defaults = ( array ) $ this -> config -> getType ( $ options [ 'data_type' ] , $ options [ 'type' ] ) ; $ options = array_merge ( $ defaults , $ options ) ; $ classname = elgg_extract ( 'class_name' , $ options ) ; if ( class_exists ( $ classname ) ) { return new $ classname ( $ options ) ; } return false ; }
945	private function setOption ( $ name , $ value ) { if ( ! \ array_key_exists ( $ name , $ this -> options ) ) { throw new InvalidConfigurationException ( sprintf ( 'Unknown option name: "%s".' , $ name ) ) ; } $ this -> options [ $ name ] = $ value ; }
2459	public function move ( ) { if ( $ this -> intId && Input :: get ( 'sid' ) && ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'root' ] || ! \ in_array ( $ this -> intId , $ this -> root ) ) ) { $ objRow = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=? OR id=?" ) -> limit ( 2 ) -> execute ( $ this -> intId , Input :: get ( 'sid' ) ) ; $ row = $ objRow -> fetchAllAssoc ( ) ; if ( $ row [ 0 ] [ 'pid' ] == $ row [ 1 ] [ 'pid' ] ) { $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET sorting=? WHERE id=?" ) -> execute ( $ row [ 0 ] [ 'sorting' ] , $ row [ 1 ] [ 'id' ] ) ; $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET sorting=? WHERE id=?" ) -> execute ( $ row [ 1 ] [ 'sorting' ] , $ row [ 0 ] [ 'id' ] ) ; $ this -> invalidateCacheTags ( $ this ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
6478	protected function encodingIsSupported ( string $ encoding ) : bool { $ lowercaseSupportedEncodings = array_map ( 'strtolower' , $ this -> getSupportedEncodings ( ) ) ; $ lowercaseEncoding = strtolower ( $ encoding ) ; return in_array ( $ lowercaseEncoding , $ lowercaseSupportedEncodings , true ) ; }
9779	private function expect ( $ target , Constraint $ constraint ) : self { assertThat ( $ target , $ this -> hasFlag ( 'negate' ) ? logicalNot ( $ constraint ) : $ constraint , $ this -> message ) ; return $ this ; }
4409	protected function render ( $ template , $ parameters ) { $ twig = new Twig_Environment ( new Twig_Loader_Filesystem ( $ this -> skeletonDirs ) , array ( 'debug' => true , 'cache' => false , 'strict_variables' => true , 'autoescape' => false , ) ) ; return $ twig -> render ( $ template , $ parameters ) ; }
11568	public function count ( ) { if ( is_null ( $ this -> recordSet ) ) { $ this -> fetchData ( ) ; } if ( is_null ( $ this -> recordcount ) ) { $ this -> recordcount = $ this -> recordSet -> RecordCount ( ) ; } return $ this -> recordcount ; }
1905	public function query ( $ strQuery = '' ) { if ( ! empty ( $ strQuery ) ) { $ this -> strQuery = trim ( $ strQuery ) ; } if ( $ this -> strQuery == '' ) { throw new \ Exception ( 'Empty query string' ) ; } $ this -> statement = $ this -> resConnection -> executeQuery ( $ this -> strQuery ) ; if ( $ this -> statement -> columnCount ( ) < 1 ) { return $ this ; } return new Result ( $ this -> statement , $ this -> strQuery ) ; }
6579	public function setParts ( array $ parts ) { $ parts = array_intersect_key ( $ parts , $ this -> params ) ; if ( isset ( $ parts [ 'port' ] ) ) $ parts [ 'port' ] = ( int ) $ parts [ 'port' ] ; if ( isset ( $ parts [ 'query' ] ) ) { $ query = $ this -> _parse_str ( $ parts [ 'query' ] ) ; $ this -> _rksort ( $ query ) ; $ parts [ 'query' ] = $ query ; } array_walk ( $ parts , function ( & $ part , $ key ) { if ( is_string ( $ part ) ) { $ part = strlen ( $ part ) ? $ part : null ; } else { $ part = $ part ? : null ; } } ) ; $ self = clone $ this ; $ self -> params = array_replace ( $ this -> params , $ parts ) ; return $ self ; }
2932	public function setKey ( $ key , $ value = null , $ comment = null , $ export = false ) { $ data = [ compact ( 'key' , 'value' , 'comment' , 'export' ) ] ; return $ this -> setKeys ( $ data ) ; }
12087	public static function create ( $ validator , $ command ) { static $ cache = [ ] ; $ cacheKey = $ validator ; if ( isset ( $ cache [ $ cacheKey ] ) ) { $ class = $ cache [ $ cacheKey ] [ 'class' ] ; $ validator = $ cache [ $ cacheKey ] [ 'validator' ] ; } else { if ( false === strpos ( $ validator , '.' ) ) { $ class = __NAMESPACE__ . '\\' . String :: convertToCamelCase ( $ validator ) ; } else { $ class = explode ( '.' , $ validator ) ; $ class = array_map ( array ( 'In2pire\\Component\\Utility\\Text' , 'convertToCamelCase' ) , $ class ) ; $ class = implode ( '\\' , $ class ) ; $ validator = substr ( $ validator , strrpos ( $ validator , '.' ) + 1 ) ; } $ cache [ $ cacheKey ] = [ 'class' => $ class , 'validator' => $ validator ] ; } if ( ! class_exists ( $ class ) ) { throw new \ RuntimeException ( 'Unknow validator ' . $ cacheKey ) ; } return new $ class ( $ command ) ; }
7166	private function buildShipmentLine ( Model \ SaleInterface $ sale ) { if ( null === $ sale -> getShipmentMethod ( ) && ! $ this -> options [ 'private' ] ) { return ; } $ lineNumber = $ this -> lineNumber ++ ; $ view = new LineView ( 'shipment' , 'shipment' , $ lineNumber , 0 ) ; $ designation = 'Shipping cost' ; if ( null !== $ method = $ sale -> getShipmentMethod ( ) ) { $ designation = $ method -> getTitle ( ) ; } $ designation .= ' (' . $ this -> formatter -> number ( $ sale -> getWeightTotal ( ) ) . ' kg)' ; $ result = $ sale -> getShipmentResult ( ) ; $ view -> setDesignation ( $ designation ) -> setBase ( $ this -> formatter -> currency ( $ result -> getBase ( ) ) ) -> setTaxRates ( $ this -> formatter -> rates ( ... $ result -> getTaxAdjustments ( ) ) ) -> setTaxAmount ( $ this -> formatter -> currency ( $ result -> getTax ( ) ) ) -> setTotal ( $ this -> formatter -> currency ( $ result -> getTotal ( ) ) ) ; foreach ( $ this -> types as $ type ) { $ type -> buildShipmentView ( $ sale , $ view , $ this -> options ) ; } $ this -> view -> setShipment ( $ view ) ; }
6419	public function start ( ) : Stopwatch { Preconditions :: checkState ( ! $ this -> isRunning , 'This stopwatch is already running.' ) ; $ this -> isRunning = true ; $ this -> startTick = $ this -> ticker -> read ( ) ; return $ this ; }
6383	public function readFeedbackAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'feedback_completed' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/feedback/complete.php?id=' . $ id ; $ model -> name = 'Attempt ' . $ id ; $ model -> responses = $ this -> readStoreRecords ( 'feedback_value' , [ 'completed' => $ id ] ) ; return $ model ; }
7784	public function addParser ( $ name , $ class , $ before = null ) { if ( $ before === null ) { $ this -> parsers [ $ name ] = $ class ; return $ this ; } if ( ( $ offset = array_search ( $ before , array_keys ( $ this -> parsers ) ) ) !== false ) { $ this -> parsers = array_slice ( $ this -> parsers , 0 , $ offset , true ) + array ( $ name => $ class ) + array_slice ( $ this -> parsers , $ offset , null , true ) ; return $ this ; } throw new \ RuntimeException ( sprintf ( 'Parser "%s" does not exist.' , $ before ) ) ; }
6444	protected function getClient ( $ redirecturl = '' ) { if ( is_object ( $ this -> linkedin ) ) { return $ this -> linkedin ; } if ( $ redirecturl == '' ) { $ redirecturl = $ this -> redirecturl ; } else { $ this -> redirecturl = $ redirecturl ; } $ this -> logQ ( 'redirect ' . $ redirecturl , 'linkedin' ) ; $ API_CONFIG = array ( 'api_key' => $ this -> options [ 'api_key' ] , 'api_secret' => $ this -> options [ 'api_secret' ] , 'callback_url' => $ redirecturl ) ; $ this -> linkedin = $ linkedin = new \ LinkedIn \ LinkedIn ( $ API_CONFIG ) ; return $ this -> linkedin ; }
1201	public function isCurrent ( ItemInterface $ item ) { if ( null === $ this -> matcher ) { throw new \ BadMethodCallException ( 'The matcher must be set to get the breadcrumbs array' ) ; } return $ this -> matcher -> isCurrent ( $ item ) ; }
7739	public function deserialize ( $ data , $ entity ) { if ( ! $ this -> container -> has ( 'hydra.serializer' ) ) { throw new \ LogicException ( 'The HydraBundle is not registered in your application.' ) ; } $ serializer = $ this -> container -> get ( 'hydra.serializer' ) ; if ( is_object ( $ entity ) ) { return $ serializer -> deserializeIntoEntity ( $ data , $ entity ) ; } return $ serializer -> deserialize ( $ data , $ entity , self :: FORMAT ) ; }
1455	protected function validateHasOne ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasOne ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasOneExpected ( $ key ) ) ; return false ; } $ identifier = $ relationship -> getData ( ) ; if ( ! $ identifier ) { return true ; } if ( ! $ this -> validateIdentifier ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateExists ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateAcceptable ( $ identifier , $ record , $ key , $ resource ) ) { return false ; } return true ; }
9314	public function storageClearAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ dbAdapter = $ this -> getDbAdapter ( ) ; $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; try { $ table = new JobTable ( $ dbAdapter ) ; $ table -> truncate ( ) ; } catch ( \ Exception $ exception ) { $ console -> writeLine ( 'Truncating database table failed!' , ConsoleColor :: LIGHT_RED ) ; return ; } $ console -> writeLine ( 'Storage was successfully cleared!' , ConsoleColor :: LIGHT_GREEN ) ; }
10225	public function itemsFor ( $ model , $ items = null , $ targetUrl = null , $ nextPageUrl = null , $ offset = - 1 , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ items == null ) { $ items = call_user_func ( array ( $ modelName , 'simplePaginate' ) , 10 ) ; } $ factory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\ResourceItemsFactory' ) ; return $ factory -> create ( $ modelName , $ items , $ targetUrl , $ nextPageUrl , $ offset , $ config ) ; }
2962	public function serialflush ( ) { if ( ! $ this -> _ckOpened ( ) ) { return false ; } if ( fwrite ( $ this -> _dHandle , $ this -> _buffer ) !== false ) { $ this -> _buffer = "" ; return true ; } else { $ this -> _buffer = "" ; trigger_error ( "Error while sending message" , E_USER_WARNING ) ; return false ; } }
4761	public function flush ( ) { if ( $ this -> doNotTrack ) { return ; } if ( empty ( $ this -> queue ) ) { return ; } if ( $ this -> mergePackets ) { $ this -> send ( implode ( "\n" , $ this -> queue ) ) ; } else { foreach ( $ this -> queue as $ data ) { $ this -> send ( $ data ) ; } } $ this -> queue = array ( ) ; $ this -> queueSize = 0 ; }
1719	public function getNewsArchives ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> news ) ) { return array ( ) ; } $ arrArchives = array ( ) ; $ objArchives = $ this -> Database -> execute ( "SELECT id, title FROM tl_news_archive ORDER BY title" ) ; while ( $ objArchives -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objArchives -> id , 'news' ) ) { $ arrArchives [ $ objArchives -> id ] = $ objArchives -> title ; } } return $ arrArchives ; }
10872	public function existEmail ( string $ email ) : int { return ( int ) $ this -> connection -> select ( self :: COLUMN_ID ) -> from ( $ this -> tableIdentity ) -> where ( [ 'email' => $ email ] ) -> fetchSingle ( ) ; }
1323	private function encodeAppAuthorization ( Consumer $ consumer ) { $ key = rawurlencode ( $ consumer -> key ) ; $ secret = rawurlencode ( $ consumer -> secret ) ; return base64_encode ( $ key . ':' . $ secret ) ; }
239	private function loadTableMetadataFromCache ( $ cache , $ name ) { if ( $ cache === null ) { $ this -> _tableMetadata [ $ name ] = [ ] ; return ; } $ metadata = $ cache -> get ( $ this -> getCacheKey ( $ name ) ) ; if ( ! is_array ( $ metadata ) || ! isset ( $ metadata [ 'cacheVersion' ] ) || $ metadata [ 'cacheVersion' ] !== static :: SCHEMA_CACHE_VERSION ) { $ this -> _tableMetadata [ $ name ] = [ ] ; return ; } unset ( $ metadata [ 'cacheVersion' ] ) ; $ this -> _tableMetadata [ $ name ] = $ metadata ; }
1528	protected function transaction ( Closure $ closure ) { if ( ! $ this -> useTransactions ) { return $ closure ( ) ; } return app ( 'db' ) -> connection ( $ this -> connection ) -> transaction ( $ closure ) ; }
8622	public function setGetLowestOfferListingsForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetLowestOfferListingsForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6139	public static function check ( $ uri ) { try { $ uri = new self ( strval ( $ uri ) ) ; } catch ( Ts3Exception $ e ) { return false ; } return $ uri -> valid ( ) ; }
2516	public function pnrCreatePnr ( RequestOptions \ PnrCreatePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
4718	public function processStandardUrl ( Text $ text ) { $ hashes = array ( ) ; $ text -> replace ( '{<code>.*?</code>}m' , function ( Text $ w ) use ( & $ hashes ) { $ md5 = md5 ( $ w ) ; $ hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '{(?<!]\(|"|<|\[)((?:https?|ftp)://[^\'">\s]+)(?!>|\"|\])}' , '<\1>' ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) use ( & $ hashes ) { return $ hashes [ ( string ) $ md5 ] ; } ) ; }
9496	public function getCollection ( $ end_point , $ collectionName , $ page = 1 , $ per_page = 100 , $ sort_by = null , $ sort_order = 'asc' ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ query = $ request -> getQuery ( ) -> set ( 'page' , $ page ) -> set ( 'per_page' , $ per_page ) ; if ( $ sort_by ) { $ query -> set ( 'sort_by' , $ sort_by ) -> set ( 'sort_order' , $ sort_order == 'asc' ? 'asc' : 'desc' ) ; } $ response = $ this -> processRequest ( $ request ) ; $ values = $ response -> json ( ) ; $ result = new PaginatedResult ( ) ; $ result -> setClient ( $ this ) ; if ( array_key_exists ( 'count' , $ values ) ) { $ result -> setCount ( $ values [ 'count' ] ) ; } $ result -> setCurrentPage ( $ page ) ; $ result -> setPerPage ( $ per_page ) ; $ result -> setEndPoint ( $ end_point ) ; $ type = $ this -> getType ( ) ; if ( array_key_exists ( $ collectionName , $ values ) && is_array ( $ values [ $ collectionName ] ) ) { foreach ( $ values [ $ collectionName ] as $ value ) { $ entity = new $ type ( ) ; $ this -> manage ( $ entity ) ; $ result [ ] = $ entity -> fromArray ( $ value ) ; } } return $ result ; }
7574	public function hasRequiredValue ( $ postVars , $ keys ) { foreach ( $ keys as $ key ) { $ requiredKey = $ this -> findKey ( $ key , $ postVars ) ; if ( array_key_exists ( $ requiredKey , $ postVars ) && $ postVars [ $ requiredKey ] !== '' ) return true ; } return false ; }
8032	public function validateDatesArray ( $ attribute , $ value , array $ parameters , Validator $ validator ) { foreach ( $ value as $ date ) { if ( false === strtotime ( $ date ) || empty ( $ date ) ) { return false ; } } return true ; }
5361	protected function createHeaderStatements ( Operation $ operation , $ queryParamVariable ) { $ headerVariable = new Expr \ Variable ( 'headers' ) ; $ headers = [ new Expr \ ArrayItem ( new Scalar \ String_ ( $ operation -> getHost ( ) ) , new Scalar \ String_ ( 'Host' ) ) , ] ; $ produces = $ operation -> getOperation ( ) -> getProduces ( ) ; if ( $ produces && in_array ( "application/json" , $ produces ) ) { $ headers [ ] = new Expr \ ArrayItem ( new Expr \ Array_ ( [ new Expr \ ArrayItem ( new Scalar \ String_ ( "application/json" ) ) , ] ) , new Scalar \ String_ ( 'Accept' ) ) ; } $ consumes = $ operation -> getOperation ( ) -> getProduces ( ) ; if ( $ operation -> getOperation ( ) -> getParameters ( ) && $ consumes ) { $ bodyParameters = array_filter ( $ operation -> getOperation ( ) -> getParameters ( ) , function ( $ parameter ) { return $ parameter instanceof BodyParameter ; } ) ; if ( count ( $ bodyParameters ) > 0 && in_array ( "application/json" , $ consumes ) ) { $ headers [ ] = new Expr \ ArrayItem ( new Scalar \ String_ ( "application/json" ) , new Scalar \ String_ ( 'Content-Type' ) ) ; } } return [ [ new Expr \ Assign ( $ headerVariable , new Expr \ FuncCall ( new Name ( 'array_merge' ) , [ new Arg ( new Expr \ Array_ ( $ headers ) ) , new Arg ( new Expr \ MethodCall ( $ queryParamVariable , 'buildHeaders' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] ) ) ] , $ headerVariable ] ; }
9318	public function rotate ( $ angle , $ background = 'FFFFFF' ) { $ angle = intval ( $ angle ) ; if ( ! is_int ( $ angle ) || ( $ angle < 0 ) || ( $ angle > 360 ) ) { throw new ezcBaseValueException ( 'height' , $ height , 'angle < 0 or angle > 360' ) ; } $ angle = 360 - $ angle ; $ background = "#{$background}" ; $ this -> addFilterOption ( $ this -> getActiveReference ( ) , '-background' , $ background ) ; $ this -> addFilterOption ( $ this -> getActiveReference ( ) , '-rotate' , $ angle ) ; }
10525	public function setFieldValue ( $ field , $ value ) { $ type = $ this -> getFieldFormType ( $ field ) ; switch ( $ type ) { case 'select' : return $ this -> selectOptionForm ( $ field , $ value ) ; case 'checkbox' : case 'checkboxGroup' : return $ this -> checkOptionForm ( $ field ) ; default : return $ this -> fillFieldForm ( $ field , $ value ) ; } }
4173	public function hasMigrationFile ( ) { $ this -> count = $ this -> fileHas ( '/class [A-Z]\w+ extends Migration/i' ) -> getClasses ( ) -> count ( ) ; return $ this -> hasMigrationFile = $ this -> count > 0 ; }
313	public function setRuntimePath ( $ path ) { $ this -> _runtimePath = Yii :: getAlias ( $ path ) ; Yii :: setAlias ( '@runtime' , $ this -> _runtimePath ) ; }
11628	protected function getLockFile ( ) { $ request = $ this -> getRequest ( ) ; $ params = $ request -> getParams ( ) ; $ controller = $ params -> controller ; $ action = $ params -> action ; $ normalizedController = strtolower ( stripslashes ( str_replace ( __NAMESPACE__ , '' , $ controller ) ) ) ; $ fileBaseName = implode ( '_' , array ( basename ( $ request -> getScriptName ( ) ) , $ normalizedController , $ action ) ) ; return $ this -> lockdir . DIRECTORY_SEPARATOR . $ fileBaseName . self :: FILE_SUFFIX ; }
11804	public function isRelation ( $ key ) { if ( ! method_exists ( $ this -> model , $ key ) ) { return false ; } $ relation = $ this -> model -> { $ key } ( ) ; return ( $ relation instanceof Relation ) ; }
8185	public function getParent ( array $ context ) { if ( null !== $ this -> parent ) { return $ this -> parent ; } try { $ parent = $ this -> doGetParent ( $ context ) ; if ( false === $ parent ) { return false ; } if ( $ parent instanceof self ) { return $ this -> parents [ $ parent -> getTemplateName ( ) ] = $ parent ; } if ( ! isset ( $ this -> parents [ $ parent ] ) ) { $ this -> parents [ $ parent ] = $ this -> loadTemplate ( $ parent ) ; } } catch ( Twig_Error_Loader $ e ) { $ e -> setSourceContext ( null ) ; $ e -> guess ( ) ; throw $ e ; } return $ this -> parents [ $ parent ] ; }
4612	public function prepare ( Command $ command , Node $ node ) { $ this -> setCommand ( $ command ) ; $ this -> setNode ( $ node ) ; return $ this ; }
5586	public function restart ( $ date = false ) { $ this -> cookie_jar -> restartSession ( $ date ) ; $ this -> authenticator -> restartSession ( ) ; $ this -> http_referer = null ; }
6112	public function dirCreate ( $ cpw = "" , $ dirname = "/" ) { return $ this -> getParent ( ) -> channelDirCreate ( $ this -> getId ( ) , $ cpw , $ dirname ) ; }
9791	public function getCalculatedValue ( $ resetLog = true ) { if ( $ this -> dataType == DataType :: TYPE_FORMULA ) { try { $ result = Calculation :: getInstance ( $ this -> getWorksheet ( ) -> getParent ( ) ) -> calculateCellValue ( $ this , $ resetLog ) ; if ( is_array ( $ result ) ) { while ( is_array ( $ result ) ) { $ result = array_pop ( $ result ) ; } } } catch ( Exception $ ex ) { if ( ( $ ex -> getMessage ( ) === 'Unable to access External Workbook' ) && ( $ this -> calculatedValue !== null ) ) { return $ this -> calculatedValue ; } throw new \ PhpOffice \ PhpSpreadsheet \ Calculation \ Exception ( $ this -> getWorksheet ( ) -> getTitle ( ) . '!' . $ this -> getCoordinate ( ) . ' -> ' . $ ex -> getMessage ( ) ) ; } if ( $ result === '#Not Yet Implemented' ) { return $ this -> calculatedValue ; } return $ result ; } elseif ( $ this -> value instanceof RichText ) { return $ this -> value -> getPlainText ( ) ; } return $ this -> value ; }
5876	public function getImageFileExtensions ( array $ settings ) { $ languageService = $ this -> getLanguageService ( ) ; $ extensions = GeneralUtility :: trimExplode ( ',' , strtolower ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'imagefile_ext' ] ) , true ) ; if ( $ key = array_search ( 'pdf' , $ extensions ) ) { unset ( $ extensions [ $ key ] ) ; } if ( $ key = array_search ( 'svg' , $ extensions ) ) { unset ( $ extensions [ $ key ] ) ; } asort ( $ extensions ) ; $ elements = [ ] ; foreach ( $ extensions as $ extension ) { $ label = $ languageService -> sL ( 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang.xlf:extension.' . $ extension ) ; $ label = $ label ? $ label : '.' . $ extension ; $ elements [ ] = [ $ label , $ extension ] ; } $ settings [ 'items' ] = array_merge ( $ settings [ 'items' ] , $ elements ) ; }
1268	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ avRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AddressValidationRequest' ) ) ; $ avRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ avRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'AV' ) ) ; if ( null !== $ this -> address ) { $ addressNode = $ avRequest -> appendChild ( $ xml -> createElement ( 'Address' ) ) ; if ( $ this -> address -> getStateProvinceCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'StateProvinceCode' , $ this -> address -> getStateProvinceCode ( ) ) ) ; } if ( $ this -> address -> getCity ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'City' , $ this -> address -> getCity ( ) ) ) ; } if ( $ this -> address -> getCountryCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'CountryCode' , $ this -> address -> getCountryCode ( ) ) ) ; } if ( $ this -> address -> getPostalCode ( ) ) { $ addressNode -> appendChild ( $ xml -> createElement ( 'PostalCode' , $ this -> address -> getPostalCode ( ) ) ) ; } } return $ xml -> saveXML ( ) ; }
1430	protected function deserializeSoftDelete ( $ value , $ field , $ record ) { if ( collect ( [ true , false , 1 , 0 , '1' , '0' ] ) -> containsStrict ( $ value ) ) { return $ value ? Carbon :: now ( ) : null ; } return $ this -> deserializeAttribute ( $ value , $ field , $ record ) ; }
843	public function clearChanged ( ) { $ this -> changed = false ; if ( self :: isLegacyMode ( ) ) { foreach ( $ this as $ token ) { $ token -> clearChanged ( ) ; } } }
9377	protected function extract ( $ filepath , array $ data ) { extract ( $ data ) ; ob_start ( ) ; include $ filepath ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; return $ contents ; }
9088	public function slurp ( ) : string { $ str = "" ; while ( $ this -> ready ( ) ) { $ str .= $ this -> read ( $ this -> count ( ) ) ; } return $ str ; }
8240	protected function saveResetTokens ( $ tokens , FileWriter $ writer = null ) { $ time = time ( ) ; foreach ( $ tokens as $ id => $ token ) { if ( $ time > $ token [ 'valid' ] ) { unset ( $ tokens [ $ id ] ) ; } } $ fileName = $ this -> dir . self :: RESET_TOKENS ; $ yaml = \ Symfony \ Component \ Yaml \ Yaml :: dump ( $ tokens , 1 , 2 ) ; if ( $ writer && $ writer -> isOpened ( ) ) { $ writer -> write ( $ yaml ) ; } else { self :: preparePath ( $ this -> dir , dirname ( self :: RESET_TOKENS ) ) ; if ( ( self :: writeFile ( $ fileName , $ yaml ) === false ) ) { throw new \ RuntimeException ( "Unable to save token file (" . self :: RESET_TOKENS . ")." ) ; } } }
10792	public function get ( $ idOrUser ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; if ( 'current' == $ idOrUser ) { return $ userRepository -> get ( $ idOrUser , $ this -> getServiceLocator ( ) ) ; } $ user = $ this -> getEntity ( $ idOrUser ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } return $ userRepository -> get ( $ user , $ this -> getServiceLocator ( ) ) ; }
8142	public function clearCacheFiles ( ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( is_string ( $ this -> originalCache ) ) { foreach ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ this -> originalCache ) , RecursiveIteratorIterator :: LEAVES_ONLY ) as $ file ) { if ( $ file -> isFile ( ) ) { @ unlink ( $ file -> getPathname ( ) ) ; } } } }
11041	function store_leaf ( & $ elts , $ ptype , & $ i , $ cname , $ cvalue = NULL ) { $ isabsolute = FALSE ; if ( $ cname { 0 } == '/' && $ cname { 1 } == '/' ) { $ isabsolute = TRUE ; $ cname = substr ( $ cname , 2 ) ; } $ elements = explode ( '/' , $ cname ) ; if ( count ( $ elements ) == 1 && ! $ isabsolute ) { $ elts [ $ ptype . ':' . $ i . ':' . $ cname . ':' . $ cvalue ] = '' ; } else { if ( $ isabsolute ) { $ elts [ _ETS_TEMPLATE . ':' . $ i . '.1://' ] = $ this -> leaf_path_walk ( $ elements , 2 , $ ptype , $ i , $ cvalue ) ; } else { $ element1 = array_shift ( $ elements ) ; $ elts [ _ETS_TEMPLATE . ':' . $ i . '.1:' . $ element1 ] = $ this -> leaf_path_walk ( $ elements , 2 , $ ptype , $ i , $ cvalue ) ; } } }
3051	protected function retrieveItemIndex ( ) { $ this -> itemIndex = new QtiTestCompilerIndex ( ) ; try { $ directories = $ this -> getCompilationDirectory ( ) ; $ data = $ directories [ 'private' ] -> read ( taoQtiTest_models_classes_QtiTestService :: TEST_COMPILED_INDEX ) ; if ( $ data ) { $ this -> itemIndex -> unserialize ( $ data ) ; } } catch ( \ Exception $ e ) { \ common_Logger :: d ( 'Ignoring file not found exception for Items Index' ) ; } }
6584	public function sum ( $ n , $ m = 0 ) { if ( $ m > 0 ) return $ this -> sum ( $ n + $ m ) - $ this -> sum ( $ m ) ; static :: ensureValid ( $ n ) ; return $ this -> b * ( 1 - pow ( $ this -> q , $ n ) ) / ( 1 - $ this -> q ) ; }
3822	public function purge ( ) { $ fileSystem = new Filesystem ( ) ; $ fileSystem -> remove ( $ this -> cacheDir ) ; $ this -> logger -> log ( LogLevel :: INFO , 'Purged the MetaModels cache' , [ 'contao' => new ContaoContext ( __METHOD__ , TL_CRON ) ] ) ; }
2777	public function init ( string $ directory , array $ options = [ ] ) : GitWorkingCopy { $ git = $ this -> workingCopy ( $ directory ) ; $ git -> init ( $ options ) ; $ git -> setCloned ( true ) ; return $ git ; }
2075	public function purgeVersionTable ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_version" ) ; $ this -> log ( 'Purged the version table' , __METHOD__ , TL_CRON ) ; }
5653	private function longestFlag ( $ flag_sets ) { $ longest = 0 ; foreach ( $ flag_sets as $ flags ) { foreach ( $ flags as $ flag ) { $ longest = max ( $ longest , strlen ( $ this -> renderFlag ( $ flag ) ) ) ; } } return $ longest ; }
9551	public function setOrderBy ( $ order_by , $ order = null ) { $ this -> order_by = $ order_by ; $ this -> order = $ order ; return $ this ; }
8394	public static function before ( string $ path , string $ usage , string $ help , string $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'before' , 'path' => $ path , 'usage' => $ usage , 'help' => $ help , 'action' => $ action , 'namespace' => self :: $ namespace ) ; } }
6760	static public function buildCacheKey ( $ columns = '*' , array $ conditionsAndOptions = [ ] ) { foreach ( $ conditionsAndOptions as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$conditionsAndOptions argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; if ( is_array ( $ columns ) ) { foreach ( $ columns as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$columns argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; } else if ( $ columns instanceof DbExpr ) { $ columns = $ columns -> get ( ) ; } return hash ( 'sha256' , json_encode ( array ( $ columns , $ conditionsAndOptions ) ) ) ; }
12277	public function update ( $ groupId , $ name ) { $ params = [ 'group' => [ 'id' => $ groupId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
8251	protected function isValidUsername ( $ name ) { if ( ! is_string ( $ name ) || ! $ this -> storage -> checkValidName ( $ name ) || strlen ( $ name ) < $ this -> config [ "registration" ] [ "nameLenMin" ] || strlen ( $ name ) > $ this -> config [ "registration" ] [ "nameLenMax" ] ) { return false ; } return true ; }
9107	public function getMvcLayout ( MvcEvent $ e ) { try { $ resolver = $ this -> getResolverObject ( 'mvclayout_resolver_adapter' , array ( 'event_mvc' => $ e ) ) ; } catch ( \ Exception $ e ) { throw $ e ; } $ layout = $ resolver -> getName ( ) ; if ( empty ( $ layout ) && ! ( $ layout === '0' ) ) { return false ; } return $ layout ; }
6947	private function getOutstandingExpiredDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; $ qb -> join ( 'o.paymentTerm' , 't' ) -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ qb -> expr ( ) -> lte ( 'o.outstandingDate' , ':today' ) , $ this -> getDueClauses ( ) ) ) -> addOrderBy ( 'o.outstandingDate' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'today' , ( new \ DateTime ( ) ) -> setTime ( 23 , 59 , 59 ) , Type :: DATETIME ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; $ this -> setDueParameters ( $ qb ) ; return $ qb ; }
1182	protected function jsValidator ( Validator $ validator , $ selector = null ) { $ remote = ! $ this -> options [ 'disable_remote_validation' ] ; $ view = $ this -> options [ 'view' ] ; $ selector = is_null ( $ selector ) ? $ this -> options [ 'form_selector' ] : $ selector ; $ delegated = new DelegatedValidator ( $ validator , new ValidationRuleParserProxy ( ) ) ; $ rules = new RuleParser ( $ delegated , $ this -> getSessionToken ( ) ) ; $ messages = new MessageParser ( $ delegated ) ; $ jsValidator = new ValidatorHandler ( $ rules , $ messages ) ; $ manager = new JavascriptValidator ( $ jsValidator , compact ( 'view' , 'selector' , 'remote' ) ) ; return $ manager ; }
6639	protected function initNavigation ( ) { Yii :: $ app -> params [ 'nav' ] [ 'wavecms_dashboard' ] = [ 'label' => FontAwesome :: icon ( 'home' ) . Yii :: t ( 'wavecms/main' , 'Dashboard' ) , 'url' => [ '/' ] , 'position' => 500 ] ; Yii :: $ app -> params [ 'nav' ] [ 'wavecms_user' ] = [ 'label' => FontAwesome :: icon ( 'users' ) . Yii :: t ( 'wavecms/user' , 'Users' ) , 'url' => 'javascript: ;' , 'options' => [ 'class' => 'drop-down' ] , 'permission' => 'wavecms-user' , 'position' => 9000 , 'items' => [ [ 'label' => FontAwesome :: icon ( 'user' ) . Yii :: t ( 'wavecms/user' , 'List of users' ) , 'url' => [ '/wavecms/user/index' ] ] , [ 'label' => FontAwesome :: icon ( 'key' ) . Yii :: t ( 'wavecms/user' , 'Roles' ) , 'url' => [ '/wavecms/role/index' ] ] , ] ] ; Yii :: $ app -> params [ 'nav' ] [ 'wavecms_settings' ] = [ 'label' => FontAwesome :: icon ( 'cog' ) . Yii :: t ( 'wavecms/main' , 'Settings' ) , 'url' => 'javascript: ;' , 'options' => [ 'class' => 'drop-down' ] , 'permission' => 'wavecms-settings' , 'position' => 10000 , 'items' => [ [ 'label' => FontAwesome :: icon ( 'flag' ) . Yii :: t ( 'wavecms/main' , 'Translations' ) , 'url' => [ '/wavecms/translation/index' ] ] , [ 'label' => FontAwesome :: icon ( 'database' ) . Yii :: t ( 'wavecms/main' , 'Cache' ) , 'url' => [ '/wavecms/settings/cache' ] ] ] ] ; }
10436	public function channel ( string $ channel_id ) : LoggerChannelInterface { $ logger = $ this -> log_manager -> get ( $ channel_id ) ; if ( ! $ logger ) { return new NullLoggerChannel ( ) ; } return new CalgamoLoggerChannelAdapter ( $ logger ) ; }
3827	protected function getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ) { return '' ; } return $ strKeyOption ; }
9289	public function getDuration ( ) { $ executed = $ this -> getExecuted ( ) ; $ finished = $ this -> getFinished ( ) ; if ( is_null ( $ executed ) || is_null ( $ finished ) ) { return 0 ; } return strtotime ( $ finished ) - strtotime ( $ executed ) ; }
11840	public static function size ( $ inputImg ) { if ( is_string ( $ inputImg ) ) $ img = self :: imgCreate ( $ inputImg ) ; else $ img = $ inputImg ; $ imgW = imagesx ( $ img ) ; $ imgH = imagesy ( $ img ) ; if ( is_string ( $ inputImg ) ) imagedestroy ( $ img ) ; return array ( $ imgW , $ imgH ) ; }
662	public function transaction ( callable $ callback , $ isolationLevel = null ) { $ transaction = $ this -> beginTransaction ( $ isolationLevel ) ; $ level = $ transaction -> level ; try { $ result = call_user_func ( $ callback , $ this ) ; if ( $ transaction -> isActive && $ transaction -> level === $ level ) { $ transaction -> commit ( ) ; } } catch ( \ Exception $ e ) { $ this -> rollbackTransactionOnLevel ( $ transaction , $ level ) ; throw $ e ; } catch ( \ Throwable $ e ) { $ this -> rollbackTransactionOnLevel ( $ transaction , $ level ) ; throw $ e ; } return $ result ; }
3786	public function addListener ( $ eventName , $ listener , $ priority = 200 ) { $ dispatcher = $ this -> getServiceContainer ( ) -> getEventDispatcher ( ) ; $ dispatcher -> addListener ( $ eventName , $ listener , $ priority ) ; return $ this ; }
8566	public function getShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_GetShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_GetShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_GetShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1413	public function resourceDoesNotExist ( string $ path ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_NOT_FOUND , $ this -> trans ( 'resource_not_found' , 'code' ) , $ this -> trans ( 'resource_not_found' , 'title' ) , $ this -> trans ( 'resource_not_found' , 'detail' ) , $ this -> pointer ( $ path ) ) ; }
3695	protected function getBreadcrumbElements ( EnvironmentInterface $ environment , BreadcrumbStore $ elements ) { if ( $ this -> parent ) { $ this -> parent -> getBreadcrumbElements ( $ environment , $ elements ) ; } }
7339	public function sendMessage ( Chat $ chat , User $ recipient , string $ text , Template $ template = null ) : void { $ sendMessage = new SendMessage ( ) ; if ( $ template !== null ) { $ sendMessage -> reply_markup = $ this -> templateCompiler -> compile ( $ template ) ; } $ sendMessage -> chat_id = $ chat -> getId ( ) ; $ sendMessage -> text = $ text ; $ this -> client -> performApiRequest ( $ sendMessage ) ; $ this -> loop -> run ( ) ; }
4414	public function onKernelRequest ( GetResponseEvent $ event ) { if ( ! $ event -> isMasterRequest ( ) ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( mb_stripos ( $ currentRoute , 'netgen_information_collection' ) !== 0 ) { return ; } $ this -> globalVariable -> setPageLayoutTemplate ( $ this -> pageLayoutTemplate ) ; }
2124	public function getFileUrls ( ) { $ return = array ( ) ; $ strTarget = substr ( $ this -> strMode , 1 ) ; foreach ( $ this -> arrFiles as $ arrFile ) { if ( $ arrFile [ 'extension' ] == self :: SCSS || $ arrFile [ 'extension' ] == self :: LESS ) { $ strPath = 'assets/' . $ strTarget . '/' . str_replace ( '/' , '_' , $ arrFile [ 'name' ] ) . $ this -> strMode ; if ( Config :: get ( 'debugMode' ) || ! file_exists ( $ this -> strRootDir . '/' . $ strPath ) ) { $ objFile = new File ( $ strPath ) ; $ objFile -> write ( $ this -> handleScssLess ( file_get_contents ( $ this -> strRootDir . '/' . $ arrFile [ 'name' ] ) , $ arrFile ) ) ; $ objFile -> close ( ) ; } $ return [ ] = $ strPath . '|' . $ arrFile [ 'version' ] ; } else { $ name = $ arrFile [ 'name' ] ; if ( strncmp ( $ name , $ this -> strWebDir . '/' , \ strlen ( $ this -> strWebDir ) + 1 ) === 0 ) { $ name = substr ( $ name , \ strlen ( $ this -> strWebDir ) + 1 ) ; } if ( $ this -> strMode == self :: CSS && $ arrFile [ 'media' ] != '' && $ arrFile [ 'media' ] != 'all' && ! $ this -> hasMediaTag ( $ arrFile [ 'name' ] ) ) { $ name .= '|' . $ arrFile [ 'media' ] ; } $ return [ ] = $ name . '|' . $ arrFile [ 'version' ] ; } } return $ return ; }
11933	public function render ( $ view , array $ parameters = array ( ) , Response $ response = null ) { $ parameters [ 'base_template' ] = isset ( $ parameters [ 'base_template' ] ) ? $ parameters [ 'base_template' ] : $ this -> getBaseTemplate ( ) ; $ parameters [ 'admin_pool' ] = $ this -> get ( 'sonata.admin.pool' ) ; return parent :: render ( $ view , $ parameters ) ; }
2668	public function getAuthDictionary ( $ version ) { $ name = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> getSingleDictionary ( $ version , $ name ) ; return $ dictionary ; }
7308	public static function jd ( $ jd , TimeScale $ timescale = null ) { $ t = [ ] ; IAU :: D2dtf ( $ timescale , 14 , $ jd , 0 , $ y , $ m , $ d , $ t ) ; return new static ( $ y , $ m , $ d , $ t [ 0 ] , $ t [ 1 ] , $ t [ 2 ] , null , $ timescale ) ; }
8954	public function createWay ( $ changeset , $ tags , $ nds ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'way/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ ndList = '' ; if ( ! empty ( $ nds ) ) { foreach ( $ nds as $ value ) { $ ndList .= '<nd ref="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <way changeset="' . $ changeset . '">' . $ tagList . $ ndList . '</way> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
1044	private static function highlightSourceAtLocation ( Source $ source , SourceLocation $ location ) { $ line = $ location -> line ; $ lineOffset = $ source -> locationOffset -> line - 1 ; $ columnOffset = self :: getColumnOffset ( $ source , $ location ) ; $ contextLine = $ line + $ lineOffset ; $ contextColumn = $ location -> column + $ columnOffset ; $ prevLineNum = ( string ) ( $ contextLine - 1 ) ; $ lineNum = ( string ) $ contextLine ; $ nextLineNum = ( string ) ( $ contextLine + 1 ) ; $ padLen = strlen ( $ nextLineNum ) ; $ lines = preg_split ( '/\r\n|[\n\r]/' , $ source -> body ) ; $ lines [ 0 ] = self :: whitespace ( $ source -> locationOffset -> column - 1 ) . $ lines [ 0 ] ; $ outputLines = [ sprintf ( '%s (%s:%s)' , $ source -> name , $ contextLine , $ contextColumn ) , $ line >= 2 ? ( self :: lpad ( $ padLen , $ prevLineNum ) . ': ' . $ lines [ $ line - 2 ] ) : null , self :: lpad ( $ padLen , $ lineNum ) . ': ' . $ lines [ $ line - 1 ] , self :: whitespace ( 2 + $ padLen + $ contextColumn - 1 ) . '^' , $ line < count ( $ lines ) ? self :: lpad ( $ padLen , $ nextLineNum ) . ': ' . $ lines [ $ line ] : null , ] ; return implode ( "\n" , array_filter ( $ outputLines ) ) ; }
163	public function cache ( $ duration = true , $ dependency = null ) { $ this -> queryCacheDuration = $ duration ; $ this -> queryCacheDependency = $ dependency ; return $ this ; }
6725	public static function getAccessToken ( ) { $ oauthClientParams = ArrayHelper :: getValue ( \ Yii :: $ app -> params , 'oauth' ) ; $ oauthClient = new Oauth2Client ( $ oauthClientParams ) ; $ code = $ oauthClient -> authorize ( ) ; $ token = $ oauthClient -> fetchAccessToken ( $ code ) ; $ accessToken = ArrayHelper :: getValue ( $ token , 'access_token' ) ; return $ accessToken ; }
6246	public function files ( ? int $ constraints = null ) : \ Generator { foreach ( $ this -> all ( $ constraints ) as $ file ) { if ( ! $ file -> isDir ( ) ) { yield $ file ; } } }
438	public function __isset ( $ name ) { $ getter = 'get' . $ name ; if ( method_exists ( $ this , $ getter ) ) { return $ this -> $ getter ( ) !== null ; } $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name ) ) { return $ behavior -> $ name !== null ; } } return false ; }
7223	protected function clearParcel ( Shipment \ ShipmentParcelInterface $ parcel ) { if ( empty ( $ parcel -> getTrackingNumber ( ) ) && ! $ parcel -> hasLabels ( ) ) { return false ; } $ parcel -> setTrackingNumber ( null ) ; foreach ( $ parcel -> getLabels ( ) as $ label ) { $ parcel -> removeLabel ( $ label ) ; } return true ; }
7032	public function run ( $ prog = "migrate" ) { switch ( trim ( $ prog ) ) { case "migrate" : return $ this -> migrate ( ) ; case "drop" : return $ this -> drop ( ) ; case "reset" : return $ this -> drop ( ) & $ this -> migrate ( ) ; default : error_log ( "\n\e[1;31m!\e[0m program $prog not applicable\n" ) ; return false ; } }
11984	public function boot ( ) { if ( $ this -> booted ) { return $ this ; } if ( extension_loaded ( 'pinba' ) ) { ini_set ( 'pinba.enabled' , false ) ; } if ( extension_loaded ( 'newrelic' ) ) { ini_set ( 'newrelic.enabled' , false ) ; } if ( ! empty ( $ this -> settings [ 'timezone' ] ) ) { date_default_timezone_set ( $ this -> settings [ 'timezone' ] ) ; } $ this -> booted = true ; return $ this ; }
10875	public function getDecodeHash ( string $ hash ) : array { $ decode = base64_decode ( $ hash ) ; list ( $ part1 , $ part2 ) = explode ( self :: PART_SEPARATOR , $ decode ) ; $ p1 = explode ( self :: TIME_SEPARATOR , $ part1 ) ; list ( $ linkValidate , ) = $ p1 ; $ id = null ; $ verifyHash = null ; $ dateNow = new DateTime ( ) ; $ dateValidate = $ dateNow ; if ( $ linkValidate == self :: NO_TIME ) { $ linkValidate = $ dateNow -> getTimestamp ( ) ; } $ dateValidate -> setTimestamp ( ( int ) $ linkValidate ) ; if ( $ dateValidate >= $ dateNow ) { $ p2 = explode ( self :: ID_SEPARATOR , $ part2 ) ; $ verifyHash = implode ( '.' , array_slice ( $ p2 , 0 , - 1 ) ) ; $ id = $ p2 [ count ( $ p2 ) - 1 ] ; } else { throw new IdentityException ( 'Activate link is expired!' ) ; } return [ 'id' => $ id , 'verifyHash' => $ verifyHash , 'expired' => ( int ) $ linkValidate ] ; }
956	public function isActiveTrial ( ) { return $ this -> isTrial ( ) && Carbon :: today ( ) -> lte ( Carbon :: parse ( $ this -> trial_ends_on ) ) ; }
8602	public function deregisterDestination ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_DeregisterDestinationInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationInput.php' ) ; $ request = new MWSSubscriptionsService_Model_DeregisterDestinationInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationResponse.php' ) ; $ response = MWSSubscriptionsService_Model_DeregisterDestinationResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8535	public function setId ( $ id ) { if ( ! $ this -> isNumericArray ( $ id ) ) { $ id = array ( $ id ) ; } $ this -> fields [ 'Id' ] [ 'FieldValue' ] = $ id ; return $ this ; }
8625	public function setTemporarilyUnavailableCarrierList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'TemporarilyUnavailableCarrierList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4541	public function set ( string $ key , $ value ) { $ config = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ config ) { throw new OutOfRangeException ( 'Config "' . $ key . '" does not exist.' ) ; } $ config -> setKey ( $ key ) -> setValue ( $ value ) ; $ this -> manager -> persist ( $ config ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> detach ( $ config ) ; }
12402	public function update ( $ id , $ document = null ) { return Parser :: update ( $ id , $ document , $ this -> connection ) ; }
8580	public function setPromotionAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PromotionAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
446	public function detachBehaviors ( ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ name => $ behavior ) { $ this -> detachBehavior ( $ name ) ; } }
732	public function evaluateAttributes ( $ event ) { if ( $ this -> skipUpdateOnClean && $ event -> name === ActiveRecord :: EVENT_BEFORE_UPDATE && empty ( $ this -> owner -> dirtyAttributes ) ) { return ; } $ attributes = array_keys ( array_filter ( $ this -> attributes , function ( $ carry ) use ( $ event ) { return array_key_exists ( $ event -> name , $ carry ) ; } ) ) ; if ( ! empty ( $ this -> order [ $ event -> name ] ) ) { $ attributes = array_merge ( array_intersect ( ( array ) $ this -> order [ $ event -> name ] , $ attributes ) , array_diff ( $ attributes , ( array ) $ this -> order [ $ event -> name ] ) ) ; } foreach ( $ attributes as $ attribute ) { if ( $ this -> preserveNonEmptyValues && ! empty ( $ this -> owner -> $ attribute ) ) { continue ; } $ this -> owner -> $ attribute = $ this -> getValue ( $ attribute , $ event ) ; } }
2206	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'logout' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> redirectBack ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ this -> getReferer ( ) ; } $ strLogoutUrl = System :: getContainer ( ) -> get ( 'security.logout_url_generator' ) -> getLogoutUrl ( ) ; $ strRedirect = Environment :: get ( 'base' ) ; if ( $ this -> redirectBack && ! empty ( $ _SESSION [ 'LAST_PAGE_VISITED' ] ) ) { $ strRedirect = $ _SESSION [ 'LAST_PAGE_VISITED' ] ; } elseif ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ strRedirect = $ objTarget -> getAbsoluteUrl ( ) ; } $ uri = Http :: createFromString ( $ strLogoutUrl ) ; $ query = new Query ( $ uri -> getQuery ( ) ) ; $ query = $ query -> merge ( 'redirect=' . $ strRedirect ) ; $ this -> redirect ( ( string ) $ uri -> withQuery ( ( string ) $ query ) ) ; return '' ; }
7192	private function copyItem ( Model \ SaleItemInterface $ source , Model \ SaleItemInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'designation' , 'description' , 'reference' , 'taxGroup' , 'netPrice' , 'weight' , 'quantity' , 'position' , 'compound' , 'immutable' , 'configurable' , 'private' , 'data' , ] ) ; $ this -> copy ( $ source -> getSubjectIdentity ( ) , $ target -> getSubjectIdentity ( ) , [ 'provider' , 'identifier' , ] ) ; foreach ( $ source -> getAdjustments ( ) as $ sourceAdjustment ) { $ targetAdjustment = $ this -> saleFactory -> createAdjustmentForItem ( $ target ) ; $ target -> addAdjustment ( $ targetAdjustment ) ; $ this -> copyAdjustment ( $ sourceAdjustment , $ targetAdjustment ) ; } foreach ( $ source -> getChildren ( ) as $ sourceChild ) { $ targetChild = $ this -> saleFactory -> createItemForSale ( $ target -> getSale ( ) ) ; $ target -> addChild ( $ targetChild ) ; $ this -> copyItem ( $ sourceChild , $ targetChild ) ; } }
8585	public function setProductGroupList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ProductGroupList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11442	public function getRegistry ( $ var = null , $ section = false , $ default = false ) { if ( is_null ( $ var ) ) { return ; } if ( $ section && isset ( $ this -> registry [ $ section ] ) ) { if ( isset ( $ this -> registry [ $ section ] [ $ var ] ) ) { return $ this -> registry [ $ section ] [ $ var ] ; } else { return $ default ; } } if ( isset ( $ this -> registry [ $ var ] ) ) { return $ this -> registry [ $ var ] ; } return $ default ; }
9732	public function writeFont ( ) { $ font_outline = 0 ; $ font_shadow = 0 ; $ icv = $ this -> colorIndex ; if ( $ this -> font -> getSuperscript ( ) ) { $ sss = 1 ; } elseif ( $ this -> font -> getSubscript ( ) ) { $ sss = 2 ; } else { $ sss = 0 ; } $ bFamily = 0 ; $ bCharSet = \ PhpOffice \ PhpSpreadsheet \ Shared \ Font :: getCharsetFromFontName ( $ this -> font -> getName ( ) ) ; $ record = 0x31 ; $ reserved = 0x00 ; $ grbit = 0x00 ; if ( $ this -> font -> getItalic ( ) ) { $ grbit |= 0x02 ; } if ( $ this -> font -> getStrikethrough ( ) ) { $ grbit |= 0x08 ; } if ( $ font_outline ) { $ grbit |= 0x10 ; } if ( $ font_shadow ) { $ grbit |= 0x20 ; } $ data = pack ( 'vvvvvCCCC' , $ this -> font -> getSize ( ) * 20 , $ grbit , $ icv , self :: mapBold ( $ this -> font -> getBold ( ) ) , $ sss , self :: mapUnderline ( $ this -> font -> getUnderline ( ) ) , $ bFamily , $ bCharSet , $ reserved ) ; $ data .= StringHelper :: UTF8toBIFF8UnicodeShort ( $ this -> font -> getName ( ) ) ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
6407	public static function filter ( IteratorAggregate $ unfiltered , callable $ predicate ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ unfiltered , $ predicate ) { return Iterators :: filter ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ predicate ) ; } ) ; }
12104	public function handleRequest ( ) : void { global $ argv ; if ( ! is_array ( $ argv ) || empty ( $ argv ) ) { throw new Exception ( 'Invalid value of the cli args array was given.' ) ; } ( new CliCtrlResolver ( $ argv ) ) -> run ( ) ; }
4359	public static function addSpecial ( $ special ) { $ special = ( array ) $ special ; foreach ( $ special as $ char ) { self :: $ special [ ] = $ char ; } }
3596	protected function createTables ( ) { $ tablesCreated = false ; $ tableSchema = Craft :: $ app -> db -> schema -> getTableSchema ( '{{%dolphiq_sitemap_entries}}' ) ; if ( $ tableSchema === null ) { $ tablesCreated = true ; $ this -> createTable ( '{{%dolphiq_sitemap_entries}}' , [ 'id' => $ this -> primaryKey ( ) , 'dateCreated' => $ this -> dateTime ( ) -> notNull ( ) , 'dateUpdated' => $ this -> dateTime ( ) -> notNull ( ) , 'uid' => $ this -> uid ( ) , 'linkId' => $ this -> integer ( ) -> notNull ( ) , 'type' => $ this -> string ( 30 ) -> notNull ( ) -> defaultValue ( '' ) , 'priority' => $ this -> double ( 2 ) -> notNull ( ) -> defaultValue ( 0.5 ) , 'changefreq' => $ this -> string ( 30 ) -> notNull ( ) -> defaultValue ( '' ) , ] ) ; } return $ tablesCreated ; }
328	public static function instance ( $ refresh = false ) { $ className = get_called_class ( ) ; if ( $ refresh || ! isset ( self :: $ _instances [ $ className ] ) ) { self :: $ _instances [ $ className ] = Yii :: createObject ( $ className ) ; } return self :: $ _instances [ $ className ] ; }
6039	public function custom ( $ sessionId , $ mediaId , $ event ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaId' => $ mediaId , 'event' => $ event ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/custom' , $ parameters , true ) ; return $ result ; }
9354	public function subMatrix ( $ int_m , $ int_n ) { $ sm = new self ( $ this -> size -> rows - 1 , $ this -> size -> cols - 1 ) ; foreach ( $ this -> arr as $ m => $ row ) { if ( $ m != $ int_m ) { $ arr_row = array ( ) ; foreach ( $ row as $ n => $ v ) { if ( $ n != $ int_n ) { $ arr_row [ ] = $ v ; } } $ sm -> addRow ( $ arr_row ) ; } } return $ sm ; }
5378	public function wrapIsEnabled ( ) { if ( $ this -> getAttribute ( 'cols' ) ) { $ wrap = $ this -> getAttribute ( 'wrap' ) ; if ( ( $ wrap === 'physical' ) || ( $ wrap === 'hard' ) ) { return true ; } } return false ; }
7818	public function create ( ) : ? array { $ body = Body :: json ( [ 'name' => $ this -> name , 'event' => $ this -> event , 'device_id' => $ this -> device , 'filter_type' => '' , 'filter' => '' , 'method' => 'http' , 'action' => $ this -> url , 'secret' => $ this -> secret , ] ) ; $ response = Request :: post ( $ this -> baseUrl . 'callback' , [ ] , $ body ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
11754	public function lists ( $ msgId , $ index , $ begin , $ count , $ type = 0 ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'begin' => $ begin , 'count' => $ count , 'type' => $ type , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_LIST_COMMENT , $ params ] ) ; }
1767	private function getRelativeRequestUri ( Request $ request ) : string { return ( string ) substr ( $ request -> getRequestUri ( ) , \ strlen ( $ request -> getBasePath ( ) ) + 1 ) ; }
7011	private function formatS ( & $ str ) { if ( strstr ( $ str , '%S' ) ) $ str = str_replace ( '%S' , static :: ordinal ( $ this -> day ) , $ str ) ; }
12495	public static function get ( Scope $ scope , $ connection , $ multiple , $ return = false ) { $ from = $ connection -> db ; if ( strpos ( $ from , '.' ) !== false ) { $ tmp = explode ( '.' , $ connection -> db ) ; $ from = end ( $ tmp ) ; } if ( ! is_null ( $ scope -> listWordsField ) ) { if ( $ scope -> listWordsField === '' ) { $ from = 'LIST_WORDS(' . $ from . ')' ; } else { $ from = 'LIST_WORDS(' . $ from . '.' . $ scope -> listWordsField . ')' ; } } if ( ! is_null ( $ scope -> alternativesField ) ) { if ( $ scope -> alternativesField === '' ) { $ from = 'ALTERNATIVES(' . $ from . ')' ; } else { $ from = 'ALTERNATIVES(' . $ from . '.' . $ scope -> alternativesField . ')' ; } } $ connection -> query = $ scope -> prepend . 'SELECT ' . $ scope -> select . ' FROM ' . $ from . ' ' ; if ( ! is_null ( $ scope -> join ) ) { $ connection -> query .= $ scope -> join . ' ' ; } if ( $ scope -> where != '' ) { $ connection -> query .= 'WHERE' . $ scope -> where ; } if ( count ( $ scope -> groupBy ) ) { $ connection -> query .= 'GROUP BY ' . implode ( ", " , $ scope -> groupBy ) . ' ' ; } if ( count ( $ scope -> orderBy ) ) { $ connection -> query .= 'ORDER BY ' . implode ( ", " , $ scope -> orderBy ) . ' ' ; } $ connection -> query .= 'LIMIT ' . $ scope -> offset . ', ' . $ scope -> limit ; if ( $ return ) { return $ connection -> query ; } $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; $ connection -> multiple = $ multiple ; $ scope -> resetSelf ( ) ; return self :: sendQuery ( $ connection ) ; }
11382	public function pipe ( $ stage ) { $ pipeline = new self ( $ this -> container , $ this -> stages ) ; $ this -> handleStage ( $ pipeline -> stages , $ stage ) ; return $ pipeline ; }
7741	public function addOperation ( OperationDefinition $ operation ) { if ( false === $ this -> supportsOperation ( $ operation -> getName ( ) ) ) { $ this -> operations [ ] = $ operation ; } return $ this ; }
2481	protected function internalFind ( array $ parameters , array $ languageSettings = array ( ) ) { $ searchTargets = $ this -> getSearchTargets ( $ languageSettings ) ; if ( ! empty ( $ searchTargets ) ) { $ parameters [ 'shards' ] = $ searchTargets ; } return $ this -> search ( $ parameters ) ; }
3855	public function setMetaTags ( $ strTitleAttribute , $ strDescriptionAttribute ) { $ this -> strDescriptionAttribute = $ strDescriptionAttribute ; $ this -> strTitleAttribute = $ strTitleAttribute ; return $ this ; }
5529	protected function chainMockReturns ( ) { $ code = " function returns(\$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returns(\$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsAt(\$timing, \$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsAt(\$timing, \$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByValue(\$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returns(\$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByValueAt(\$timing, \$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByValueAt(\$timing, \$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByReference(\$method, &\$ref, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByReference(\$method, \$ref, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByReferenceAt(\$timing, \$method, &\$ref, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByReferenceAt(\$timing, \$method, \$ref, \$args);\n" ; $ code .= " }\n" ; return $ code ; }
5386	public function isLabel ( $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> widgets [ $ i ] -> isLabel ( $ label ) ) { return true ; } } return false ; }
4955	public function listenToRenderer ( ) { if ( $ this -> ListenersUnaware ) { $ this -> ListenersUnaware = false ; $ view = $ this -> serviceManager -> get ( 'View' ) ; $ viewEvents = $ view -> getEventManager ( ) ; $ viewEvents -> attach ( ViewEvent :: EVENT_RESPONSE , array ( $ this , 'anounceAttachedFiles' ) , 1000 ) ; } }
7418	protected function setJSONContent ( array $ content ) { if ( $ this -> deleteJsonKeys ) { $ content = $ this -> deleteArrayKeys ( $ content ) ; } $ content = json_encode ( $ content , JSON_UNESCAPED_UNICODE ) ; $ this -> response -> setContentTypeJson ( ) ; $ this -> response -> setContent ( $ content ) ; }
9459	public function getByIds ( array $ ids , $ page = 1 , $ per_page = 100 ) { return $ this -> getCollection ( 'tickets/show_many.json?ids=' . implode ( ',' , $ ids ) , 'tickets' , $ page , $ per_page ) ; }
4424	protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( ! $ input -> isInteractive ( ) ) { $ output -> writeln ( '<error>This command only supports interactive execution</error>' ) ; return 1 ; } $ this -> writeSection ( 'Installation' ) ; $ legacySiteAccessGenerator = new LegacySiteAccessGenerator ( $ this -> getContainer ( ) , $ this -> questionHelper ) ; $ legacySiteAccessGenerator -> generate ( $ this -> input , $ this -> output ) ; $ configurationGenerator = new ConfigurationGenerator ( $ this -> getContainer ( ) , $ this -> questionHelper ) ; $ configurationGenerator -> generate ( $ this -> input , $ this -> output ) ; $ errors = array ( ) ; $ runner = $ this -> getRunner ( $ errors ) ; $ runner ( $ this -> generateLegacyAutoloads ( ) ) ; $ this -> writeInstallerSummary ( $ errors ) ; return 0 ; }
12631	public function prepare ( Order $ order ) { $ order -> notify_url = $ order -> get ( 'notify_url' , $ this -> merchant -> notify_url ) ; if ( is_null ( $ order -> spbill_create_ip ) ) { $ order -> spbill_create_ip = ( $ order -> trade_type === Order :: NATIVE ) ? get_server_ip ( ) : get_client_ip ( ) ; } return $ this -> request ( $ this -> wrapApi ( self :: API_PREPARE_ORDER ) , $ order -> all ( ) ) ; }
5091	private function asScalarSubQuery ( $ callback , $ default = false ) { $ sql = $ this -> sql ; $ this -> sql = $ callback ( $ sql ) ; $ result = $ this -> queryScalar ( null ) ; $ this -> sql = $ sql ; return ( is_null ( $ result ) ? $ default : $ result ) ; }
2556	protected static function loadObFees ( $ obFees , $ obFeeRefs ) { $ opt = [ ] ; if ( ! empty ( $ obFees ) ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_OB_FEES ) ; $ po -> penDisInformation = new PenDisInformation ( PenDisInformation :: QUAL_OB_FEES , $ obFees ) ; if ( ! empty ( $ obFeeRefs ) ) { $ po -> paxSegTstReference = new PaxSegTstReference ( $ obFeeRefs ) ; } $ opt [ ] = $ po ; } return $ opt ; }
10452	public function format ( string $ question , string $ default = null ) : string { if ( $ default != '' ) { $ default = sprintf ( '[%s]' , $ default ) ; } return trim ( $ question . $ default ) . sprintf ( '%s ' , $ this -> getDelimiter ( ) ) ; }
7305	protected function scheduleParentChangeEvents ( CustomerInterface $ customer ) { if ( ! $ customer -> hasChildren ( ) ) { return ; } foreach ( $ customer -> getChildren ( ) as $ child ) { $ this -> persistenceHelper -> scheduleEvent ( CustomerEvents :: PARENT_CHANGE , $ child ) ; } }
3477	public function withLocalizedTitle ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> title = '' ; $ cloned -> titleLocalized = $ localized ; return $ cloned ; }
10672	private static function addSegmentsToPath ( $ path , $ segments ) { $ segments = Arr :: toArray ( $ segments ) ; if ( count ( $ segments ) > 0 ) { $ path .= '/' . implode ( '/' , $ segments ) ; } return $ path ; }
656	public function init ( ) { if ( $ this -> autoRelease ) { $ locks = & $ this -> _locks ; register_shutdown_function ( function ( ) use ( & $ locks ) { foreach ( $ locks as $ lock ) { $ this -> release ( $ lock ) ; } } ) ; } }
50	protected function pushEvent ( Event $ event ) { $ eventName = $ event -> getName ( ) ; if ( in_array ( $ eventName , $ this -> eventStack ) ) { throw new \ RuntimeException ( sprintf ( "Circular call to script handler '%s' detected" , $ eventName ) ) ; } return array_push ( $ this -> eventStack , $ eventName ) ; }
8896	public function get_many_by ( ) { $ where = func_get_args ( ) ; $ this -> apply_soft_delete_filter ( ) ; $ this -> _set_where ( $ where ) ; return $ this -> get_all ( ) ; }
5225	private function resolve ( Injector $ injector , $ type ) { $ resolved = [ ] ; foreach ( $ this -> getBindings ( ) as $ key => $ bindingValue ) { $ value = $ bindingValue ( $ injector , $ this -> name , $ key ) ; if ( $ this -> isTypeMismatch ( $ type , $ value ) ) { $ valueType = ( ( is_object ( $ value ) ) ? ( get_class ( $ value ) ) : ( gettype ( $ value ) ) ) ; throw new BindingException ( 'Value of type ' . $ valueType . ' for ' . ( ( is_int ( $ key ) ) ? ( 'list' ) : ( 'map' ) ) . ' named ' . $ this -> name . ' at position ' . $ key . ' is not of type ' . $ type -> getName ( ) ) ; } $ resolved [ $ key ] = $ value ; } return $ resolved ; }
12206	public function createPagination ( $ currentPage , $ total , $ perPage = null , $ baseUrl = null , $ neighbours = null ) { if ( isset ( $ this -> container ) && $ this -> container instanceof \ League \ Container \ ContainerInterface ) { return $ this -> getContainer ( ) -> get ( 'Laasti\Pagination\Pagination' , [ $ currentPage , $ total , $ perPage , $ baseUrl , $ neighbours ] ) ; } $ perPage = $ perPage ? : 10 ; $ baseUrl = $ baseUrl ? : '' ; $ neighbours = $ neighbours ? : 3 ; return new Pagination ( $ currentPage , $ total , $ perPage , $ baseUrl , $ neighbours ) ; }
4345	public function getCfgLazy ( $ name ) { if ( ! isset ( $ this -> cfgLazy [ $ name ] ) ) { return array ( ) ; } $ return = $ this -> cfgLazy [ $ name ] ; unset ( $ this -> cfgLazy [ $ name ] ) ; return $ return ; }
4387	public function getConfigFE ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ basket ) { $ list = [ ] ; $ feconfig = $ this -> feConfig ; try { $ code = $ this -> getServiceItem ( ) -> getCode ( ) ; $ service = $ basket -> getService ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT , $ code ) ; foreach ( $ service -> getAttributeItems ( ) as $ item ) { if ( isset ( $ feconfig [ $ item -> getCode ( ) ] ) ) { $ feconfig [ $ item -> getCode ( ) ] [ 'default' ] = $ item -> getValue ( ) ; } } } catch ( \ Aimeos \ MShop \ Order \ Exception $ e ) { ; } $ addresses = $ basket -> getAddress ( \ Aimeos \ MShop \ Order \ Item \ Base \ Address \ Base :: TYPE_PAYMENT ) ; if ( ( $ address = current ( $ addresses ) ) !== false ) { if ( $ feconfig [ 'novalnetsepa.holder' ] [ 'default' ] == '' && ( $ fn = $ address -> getFirstname ( ) ) !== '' && ( $ ln = $ address -> getLastname ( ) ) !== '' ) { $ feconfig [ 'novalnetsepa.holder' ] [ 'default' ] = $ fn . ' ' . $ ln ; } } foreach ( $ feconfig as $ key => $ config ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( $ config ) ; } return $ list ; }
9040	public function getMax ( string $ column ) : int { return $ this -> connection -> query ( 'SELECT IFNULL(MAX(%column), 0) position FROM %table' , $ column , $ this -> getTableName ( ) ) -> fetch ( ) -> position ; }
6730	public function set_user_vote ( $ post_id , $ votes , $ vote , $ ip ) { global $ wpdb ; $ table_name = $ wpdb -> prefix . 'efg_custom_rating' ; $ result = $ wpdb -> get_row ( " SELECT id, vote FROM $table_name WHERE ip = '$ip' AND post_id = $post_id " ) ; if ( ! isset ( $ result -> id ) && ! isset ( $ result -> vote ) ) { $ wpdb -> insert ( $ table_name , [ 'post_id' => $ post_id , 'ip' => $ ip , 'vote' => $ vote , ] , [ '%d' , '%s' , '%d' ] ) ; $ votes [ $ vote ] ++ ; } else { if ( $ result -> vote != $ vote ) { $ wpdb -> update ( $ table_name , [ 'post_id' => $ post_id , 'ip' => $ ip , 'vote' => $ vote , ] , [ 'id' => $ result -> id ] , [ '%d' , '%s' , '%d' ] , [ '%d' ] ) ; $ votes [ $ result -> vote ] -- ; $ votes [ $ vote ] ++ ; } } return $ votes ; }
6462	public function add ( $ name , $ values , bool $ append = false ) : void { $ normalizedName = self :: normalizeHeaderName ( $ name ) ; if ( ! $ append || ! $ this -> containsKey ( $ normalizedName ) ) { parent :: add ( $ normalizedName , ( array ) $ values ) ; } else { $ currentValues = [ ] ; $ this -> tryGet ( $ normalizedName , $ currentValues ) ; parent :: add ( $ normalizedName , array_merge ( $ currentValues , ( array ) $ values ) ) ; } }
6472	public function getBestEncodingMatch ( IMediaTypeFormatter $ formatter , array $ acceptCharsetHeaders , ? MediaTypeHeaderValue $ mediaTypeHeader ) : ? string { $ rankedAcceptCharsetHeaders = $ this -> rankAcceptCharsetHeaders ( $ acceptCharsetHeaders ) ; foreach ( $ rankedAcceptCharsetHeaders as $ acceptCharsetHeader ) { foreach ( $ formatter -> getSupportedEncodings ( ) as $ supportedEncoding ) { $ charset = $ acceptCharsetHeader -> getCharset ( ) ; if ( $ charset === '*' || strcasecmp ( $ charset , $ supportedEncoding ) === 0 ) { return $ supportedEncoding ; } } } if ( $ mediaTypeHeader === null || $ mediaTypeHeader -> getCharset ( ) === null ) { return null ; } foreach ( $ formatter -> getSupportedEncodings ( ) as $ supportedEncoding ) { $ charset = $ mediaTypeHeader -> getCharset ( ) ; if ( $ charset === '*' || strcasecmp ( $ charset , $ supportedEncoding ) === 0 ) { return $ supportedEncoding ; } } return null ; }
3416	protected function normalizeFieldsForSave ( $ selectedFields ) { $ fields = [ ] ; if ( $ this -> fields === null ) { return [ ] ; } foreach ( $ this -> fields as $ field => $ value ) { if ( ! $ this -> fieldShouldNotBeSaved ( $ field , $ value , $ selectedFields ) ) { $ fields [ $ field ] = $ value ; } } return $ fields ? : null ; }
6995	public static function parseApplePriceMatrix ( $ dom , $ currency , $ directory = null ) { if ( is_string ( $ dom ) ) { if ( file_exists ( $ dom ) && is_file ( $ dom ) ) { $ file = $ dom ; $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTMLFile ( $ file ) ; unset ( $ file ) ; } else { $ content = $ dom ; $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTML ( $ content ) ; unset ( $ content ) ; } } if ( ! $ dom instanceof \ DOMDocument ) { throw new \ InvalidArgumentException ( sprintf ( 'The first argument must be a DOMDocument instance or path to ApplePriceMatrix file, "%s" given.' , is_object ( $ dom ) ? get_class ( $ dom ) : gettype ( $ dom ) ) ) ; } $ currency = strtoupper ( $ currency ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ tierPrimary = static :: parseApplePriceMatrixTier ( $ xpath , 1 , $ currency ) ; $ tierAlternative = static :: parseApplePriceMatrixTier ( $ xpath , 2 , $ currency ) ; $ prices = $ tierPrimary + $ tierAlternative ; ksort ( $ prices ) ; if ( $ directory ) { if ( ! is_writable ( $ directory ) ) { throw new \ RuntimeException ( sprintf ( 'Could not write prices map to directory "%s". Directory is not writable.' , $ directory ) ) ; } $ file = $ directory . '/' . $ currency . '.php' ; file_put_contents ( $ file , '<?php return ' . var_export ( $ prices , 1 ) . ';' ) ; } return $ prices ; }
3965	protected function authenticateUser ( ) { if ( \ System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) -> currentScopeIsUnknown ( ) ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'contao/login' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'request' ) , 'install' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'system/bin' ) !== false ) { return false ; } $ authResult = $ this -> getUser ( ) -> authenticate ( ) ; return ( $ authResult === true || $ authResult === null ) ? true : false ; }
6070	public function downloadArchive ( array $ ids , $ template = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'ids' => $ ids , 'template' => $ template ] , 'body' => json_encode ( [ ] ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/download' , $ parameters , $ cachePolicy ) ; return $ result ; }
3500	public function withApnId ( ApnId $ apnId = null ) : Notification { $ cloned = clone $ this ; $ cloned -> apnId = $ apnId ; return $ cloned ; }
3763	private function getLegendProperty ( LegendInterface $ legend , $ propertyName ) { if ( $ legend -> hasProperty ( $ propertyName ) ) { $ property = $ legend -> getProperty ( $ propertyName ) ; } else { $ property = new Property ( $ propertyName ) ; $ legend -> addProperty ( $ property ) ; } return $ property ; }
9175	public function fromRoute ( $ route = null , $ params = [ ] , $ options = [ ] , $ reuseMatchedParams = false ) { $ controller = $ this -> getController ( ) ; if ( ! $ controller || ! method_exists ( $ controller , 'plugin' ) ) { throw new Exception \ DomainException ( 'Redirect plugin requires a controller that defines the plugin() method' ) ; } $ referer = $ controller -> getRequest ( ) -> getHeader ( 'Referer' ) ; if ( $ referer ) { $ refererUrl = $ referer -> uri ( ) -> getPath ( ) ; $ refererHost = $ referer -> uri ( ) -> getHost ( ) ; $ host = $ controller -> getRequest ( ) -> getUri ( ) -> getHost ( ) ; if ( $ refererUrl && ( $ refererHost == $ host ) ) { return $ refererUrl ; } } $ urlPlugin = $ controller -> plugin ( 'url' ) ; return $ urlPlugin -> fromRoute ( $ route , $ params , $ options , $ reuseMatchedParams ) ; }
4185	public function search ( ) { $ this -> console -> info ( 'Searching directory for service providers.' ) ; $ sps = $ this -> getProviders ( ) ; if ( ! $ sps -> count ( ) ) { $ this -> console -> warn ( 'No service provider file found. Nothing to install.' ) ; return [ ] ; } $ this -> console -> line ( " Found {$sps->count()} Service provider" . ( $ sps -> count ( ) > 1 ? 's' : '' ) . '.' ) ; $ sps -> each ( function ( $ sp , $ index ) { $ currentCount = $ index + 1 ; $ this -> console -> line ( " $currentCount. $sp" ) ; } ) ; if ( ! $ this -> console -> confirm ( 'Register service providers?' , true ) ) { return [ ] ; } $ this -> registered = true ; return $ this -> getProviders ( ) -> toArray ( ) ; }
9204	public static function get ( $ item ) { $ item = strtoupper ( $ item ) ; $ config = json_decode ( file_get_contents ( dirname ( __FILE__ ) . "/Config.json" ) , true ) ; if ( ! isset ( $ config [ $ item ] ) ) { throw new InvalidConfigItemException ( "Invalid Endpoint Requested!" ) ; } return $ config [ $ item ] ; }
4419	protected function checkPermissions ( ) { if ( $ this -> isGranted ( 'ROLE_NGBM_EDITOR' ) ) { return ; } if ( $ this -> isGranted ( 'nglayouts:ui:access' ) ) { return ; } $ exception = $ this -> createAccessDeniedException ( ) ; $ exception -> setAttributes ( 'nglayouts:ui:access' ) ; throw $ exception ; }
11598	private static function _getCacheObject ( ) { if ( self :: $ _sTypeOfCache === 'file' ) { if ( ! isset ( self :: $ _aCache [ 'file' ] ) ) { self :: $ _aCache [ 'file' ] = new CacheFile ; } return self :: $ _aCache [ 'file' ] ; } else if ( self :: $ _sTypeOfCache === 'memcache' ) { if ( ! isset ( self :: $ _aCache [ 'memcache' ] ) ) { $ oDbConf = Config :: get ( 'Memcache' ) -> configuration ; if ( isset ( $ oDbConf -> port ) ) { $ sPort = $ oDbConf -> port ; } else { $ sPort = null ; } if ( isset ( $ oDbConf -> timeout ) ) { $ iTimeout = $ oDbConf -> timeout ; } else { $ iTimeout = null ; } self :: $ _aCache [ 'memcache' ] = new CacheMemcache ( $ oDbConf -> host , $ sPort , $ iTimeout ) ; } return self :: $ _aCache [ 'memcache' ] ; } else if ( self :: $ _sTypeOfCache === 'apc' ) { if ( ! isset ( self :: $ _aCache [ 'apc' ] ) ) { self :: $ _aCache [ 'apc' ] = new Apc ; } return self :: $ _aCache [ 'apc' ] ; } else if ( self :: $ _sTypeOfCache === 'redis' ) { if ( ! isset ( self :: $ _aCache [ 'redis' ] ) ) { $ oDbConf = Config :: get ( 'Redis' ) -> configuration ; self :: $ _aCache [ 'memcache' ] = new Redis ( $ oDbConf ) ; } return self :: $ _aCache [ 'redis' ] ; } else if ( self :: $ _sTypeOfCache === 'mock' ) { if ( ! isset ( self :: $ _aCache [ 'mock' ] ) ) { self :: $ _aCache [ 'mock' ] = new Mock ; } return self :: $ _aCache [ 'mock' ] ; } }
11099	public static function maxCount ( ) { $ array = \ func_get_args ( ) ; if ( ! \ is_array ( $ array ) ) { return 0 ; } $ maxCnt = 0 ; foreach ( $ array as $ item ) { if ( ! \ is_array ( $ item ) ) { continue ; } $ cnt = \ count ( $ item ) ; $ maxCnt = $ cnt > $ maxCnt ? $ cnt : $ maxCnt ; } return $ maxCnt ; }
5923	public function addPropertySet ( $ item ) { if ( ! ( $ item instanceof PropertySet ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertySet ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertySet. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertySet"!' , E_USER_WARNING ) ; } } $ this -> propertySets [ ] = $ item ; return $ this ; }
7035	protected function createMigrationTable ( ) { $ migrations = new Table ( "migrations" , true ) ; $ migrations -> string ( "host" ) -> notNullable ( ) -> primaryComposite ( ) ; $ migrations -> timestamp ( "created_at" ) -> notNullable ( ) -> primaryComposite ( true ) ; $ migrations -> blob ( "tables" ) ; try { return $ migrations -> create ( $ this -> dbName ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
10403	public function onConsume ( ItemPipelineEvent $ event ) { if ( $ event -> getItemSkip ( ) ) { $ this -> skip ( $ event ) ; } else { $ this -> consume ( $ event ) ; } }
10110	private function writeSheetLayout ( ) { if ( ! $ this -> phpSheet -> isTabColorSet ( ) ) { return ; } $ recordData = pack ( 'vvVVVvv' , 0x0862 , 0x0000 , 0x00000000 , 0x00000000 , 0x00000014 , $ this -> colors [ $ this -> phpSheet -> getTabColor ( ) -> getRGB ( ) ] , 0x0000 ) ; $ length = strlen ( $ recordData ) ; $ record = 0x0862 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
4218	private function clearLog ( $ flags ) { $ return = null ; $ clearErrors = $ flags & Debug :: CLEAR_LOG_ERRORS ; if ( $ flags & Debug :: CLEAR_LOG ) { $ return = 'log (' . ( $ clearErrors ? 'incl errors' : 'sans errors' ) . ')' ; $ curDepth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] [ 'main' ] as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entriesKeep = $ this -> debug -> internal -> getCurrentGroups ( $ this -> data [ 'log' ] , $ curDepth ) ; $ this -> clearLogHelper ( $ this -> data [ 'log' ] , $ clearErrors , $ entriesKeep ) ; } elseif ( $ clearErrors ) { $ return = 'errors' ; } return $ return ; }
4245	private function logPhpInfo ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.phpInfo' ) ) { return ; } $ this -> debug -> log ( 'PHP Version' , PHP_VERSION ) ; $ this -> debug -> log ( 'ini location' , \ php_ini_loaded_file ( ) ) ; $ this -> debug -> log ( 'memory_limit' , $ this -> debug -> utilities -> getBytes ( $ this -> debug -> utilities -> memoryLimit ( ) ) ) ; $ this -> debug -> log ( 'session.cache_limiter' , \ ini_get ( 'session.cache_limiter' ) ) ; if ( \ session_module_name ( ) === 'files' ) { $ this -> debug -> log ( 'session_save_path' , \ session_save_path ( ) ? : \ sys_get_temp_dir ( ) ) ; } $ extensionsCheck = array ( 'curl' , 'mbstring' ) ; $ extensionsCheck = \ array_filter ( $ extensionsCheck , function ( $ extension ) { return ! \ extension_loaded ( $ extension ) ; } ) ; if ( $ extensionsCheck ) { $ this -> debug -> warn ( 'These common extensions are not loaded:' , $ extensionsCheck ) ; } $ this -> logPhpInfoEr ( ) ; }
3625	public function getDevices ( $ type = DEVICE_TYPE_THERMOSTAT ) { $ this -> prepareForGet ( ) ; if ( $ type == DEVICE_TYPE_PROTECT ) { $ protects = array ( ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ topaz as $ protect ) { $ protects [ ] = $ protect -> serial_number ; } return $ protects ; } $ devices_serials = array ( ) ; foreach ( $ this -> last_status -> user -> { $ this -> userid } -> structures as $ structure ) { list ( , $ structure_id ) = explode ( '.' , $ structure ) ; foreach ( $ this -> last_status -> structure -> { $ structure_id } -> devices as $ device ) { list ( , $ device_serial ) = explode ( '.' , $ device ) ; $ devices_serials [ ] = $ device_serial ; } } return $ devices_serials ; }
4836	public function create_bill ( $ params ) { if ( ! isset ( $ params [ 'pre_authorization_id' ] ) ) { throw new GoCardless_ArgumentsException ( 'pre_authorization_id missing' ) ; } $ pre_auth = new GoCardless_PreAuthorization ( $ this , array ( 'id' => $ params [ 'pre_authorization_id' ] ) ) ; return $ pre_auth -> create_bill ( array ( 'amount' => $ params [ 'amount' ] ) ) ; }
6381	public function readQuestionAttempts ( $ id ) { $ questionAttempts = $ this -> readStoreRecords ( 'question_attempts' , [ 'questionusageid' => $ id ] ) ; foreach ( $ questionAttempts as $ questionIndex => $ questionAttempt ) { $ questionAttemptSteps = $ this -> readStoreRecords ( 'question_attempt_steps' , [ 'questionattemptid' => $ questionAttempt -> id ] ) ; foreach ( $ questionAttemptSteps as $ stepIndex => $ questionAttemptStep ) { $ questionAttemptStep -> data = $ this -> readStoreRecords ( 'question_attempt_step_data' , [ 'attemptstepid' => $ questionAttemptStep -> id ] ) ; } $ questionAttempt -> steps = $ questionAttemptSteps ; } return $ questionAttempts ; }
12628	public function register ( Application $ app ) { if ( is_null ( $ this -> filename ) ) { throw new \ RuntimeException ( 'You must provide a valid config filename' ) ; } if ( ! file_exists ( $ this -> filename ) ) { throw new \ RuntimeException ( sprintf ( 'Config path \'%s\' is not valid' , $ this -> filename ) ) ; } if ( ! is_readable ( $ this -> filename ) ) { throw new \ RuntimeException ( sprintf ( 'Config path \'%s\' is not readable' , $ this -> filename ) ) ; } $ parser = new YamlParser ( ) ; $ config = $ parser -> parse ( file_get_contents ( $ this -> filename ) ) ; if ( is_array ( $ config ) && ! empty ( $ config ) ) { if ( isset ( $ app [ 'config' ] ) && is_array ( $ app [ 'config' ] ) ) { $ config = array_replace_recursive ( $ app [ 'config' ] , $ config ) ; } $ app [ 'config' ] = $ config ; } }
890	public function getTypes ( ) { if ( null === $ this -> types ) { $ this -> types = [ ] ; $ content = $ this -> getTypesContent ( ) ; while ( '' !== $ content && false !== $ content ) { Preg :: match ( '{^' . self :: REGEX_TYPES . '$}x' , $ content , $ matches ) ; $ this -> types [ ] = $ matches [ 'type' ] ; $ content = substr ( $ content , \ strlen ( $ matches [ 'type' ] ) + 1 ) ; } } return $ this -> types ; }
9165	public function fields ( $ entity = array ( ) , $ action = 'all' , array $ params = array ( ) ) { $ fieldCollection = array ( ) ; $ entity = $ this -> entityFactory -> build ( $ entity ) ; if ( $ entity instanceof \ ElggEntity ) { $ params [ 'entity' ] = $ entity ; $ fields = ( array ) elgg_trigger_plugin_hook ( 'prototype' , $ action , $ params , array ( ) ) ; $ attribute_names = $ this -> entityFactory -> getAttributeNames ( $ entity ) ; if ( ! $ entity -> guid ) { $ fields [ 'type' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'subtype' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'owner_guid' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'container_guid' ] = array ( 'type' => 'hidden' ) ; } else { $ fields [ 'guid' ] = array ( 'type' => 'hidden' ) ; } foreach ( $ fields as $ shortname => $ field ) { $ field [ 'entity_type' ] = $ entity -> getType ( ) ; $ field [ 'entity_subtype' ] = $ entity -> getSubtype ( ) ; if ( empty ( $ field [ 'shortname' ] ) ) { $ field [ 'shortname' ] = $ shortname ; } if ( in_array ( $ shortname , $ attribute_names ) ) { $ field [ 'data_type' ] = 'attribute' ; $ field [ 'class_name' ] = Elements \ AttributeField :: CLASSNAME ; } $ fieldObj = $ this -> fieldFactory -> build ( $ field ) ; if ( $ fieldObj instanceof Elements \ Field ) { $ fieldCollection [ ] = $ fieldObj ; } } } return new Elements \ FieldCollection ( $ fieldCollection ) ; }
12847	private function _loadController ( $ oControllerName , string $ sActionName , array $ aParams = array ( ) ) { $ aPhpDoc = PhpDoc :: getPhpDocOfMethod ( $ oControllerName , $ sActionName ) ; if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { if ( ! isset ( $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ) { $ aPhpDoc [ 'Cache' ] [ 'maxage' ] = 0 ; } $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } $ mCacheReturn = Cache :: get ( $ sActionName . $ sCacheExt , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; if ( $ mCacheReturn !== false ) { return $ mCacheReturn ; } } if ( isset ( $ aPhpDoc [ 'Secure' ] ) ) { if ( isset ( $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) && $ this -> _oSecurity -> getUserRole ( ) != $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) { $ this -> _getPage403 ( ) ; } } $ oController = new $ oControllerName ; ob_start ( ) ; if ( ! defined ( 'PORTAL' ) ) { define ( 'PORTAL' , 'Batch' ) ; } if ( method_exists ( $ oController , 'beforeExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'beforeExecuteRoute' ) , array ( ) ) ; } $ mReturnController = call_user_func_array ( array ( $ oController , $ sActionName ) , $ aParams ) ; if ( method_exists ( $ oController , 'afterExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'afterExecuteRoute' ) , array ( ) ) ; } $ mReturn = ob_get_clean ( ) ; if ( $ mReturn == '' ) { $ mReturn = $ mReturnController ; } if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } if ( defined ( 'COMPRESS_HTML' ) && COMPRESS_HTML ) { $ mReturn = str_replace ( array ( "\t" , "\r" , " " ) , array ( "" , "" , "" , " " ) , $ mReturn ) ; } Cache :: set ( $ sActionName . $ sCacheExt , $ mReturn , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; } return $ mReturn ; }
8486	public static function getCpuVendor ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT Manufacturer FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> Manufacturer ; } return 'Unknown' ; }
1633	protected function fireLogEvent ( $ level , $ message , array $ context = [ ] ) { if ( ! isset ( $ this -> dispatcher ) ) { return ; } if ( class_exists ( MessageLogged :: class ) ) { $ this -> dispatcher -> dispatch ( new MessageLogged ( $ level , $ message , $ context ) ) ; } else { $ this -> dispatcher -> fire ( 'illuminate.log' , compact ( 'level' , 'message' , 'context' ) ) ; } }
7969	public function getVoiceConsumptions ( $ params = null ) { $ consumptionList = json_decode ( self :: getClient ( ) -> getVoiceConsumptions ( $ this -> service , $ this -> billingAccount , $ params ) ) ; $ consumptions = array ( ) ; foreach ( $ consumptionList as $ consumption ) { $ consumptions [ ] = new VoiceConsumption ( $ consumption , $ this ) ; } return $ consumptions ; }
6636	protected function initLanguages ( ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } if ( ! isset ( Yii :: $ app -> wavecms ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Component "wavecms" not defined in config.php' ) ) ; if ( ! count ( Yii :: $ app -> wavecms -> languages ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Property "languages" is not defined in config file for component "wavecms"' ) ) ; if ( ! Yii :: $ app -> session -> get ( 'editedLanguage' ) ) { Yii :: $ app -> session -> set ( 'editedLanguage' , Yii :: $ app -> wavecms -> languages [ 0 ] ) ; } Yii :: $ app -> wavecms -> editedLanguage = Yii :: $ app -> session -> get ( 'editedLanguage' ) ; }
8421	private function getTexture ( ) { if ( isset ( $ this -> model ) ) { $ texture = $ this -> attribute ; if ( isset ( $ this -> model -> $ texture ) ) { return $ this -> model -> $ texture ; } } if ( isset ( $ this -> texture ) ) { return $ this -> texture ; } return $ this -> default ; }
4323	public static function buildTag ( $ tagName , $ attribs = array ( ) , $ innerhtml = '' ) { $ tagName = \ strtolower ( $ tagName ) ; $ attribStr = self :: buildAttribString ( $ attribs ) ; return \ in_array ( $ tagName , self :: $ htmlEmptyTags ) ? '<' . $ tagName . $ attribStr . ' />' : '<' . $ tagName . $ attribStr . '>' . $ innerhtml . '</' . $ tagName . '>' ; }
8338	public function returning ( $ returning ) { if ( is_array ( $ returning ) === true ) { $ this -> returning = implode ( ', ' , $ returning ) ; } else { $ this -> returning = $ returning ; } return $ this ; }
11384	protected function resolve ( ) { if ( $ this -> resolved ) { return ; } $ this -> resolved = [ ] ; foreach ( $ this -> stages as $ stage ) { $ this -> resolved [ ] = $ this -> build ( $ stage ) ; } }
5655	public function parse ( $ response ) { $ this -> page = new SimplePage ( $ response ) ; $ tidied = tidy_parse_string ( $ input = $ this -> insertGuards ( $ response -> getContent ( ) ) , array ( 'output-xml' => false , 'wrap' => '0' , 'indent' => 'no' ) , 'latin1' ) ; $ this -> walkTree ( $ tidied -> html ( ) ) ; $ this -> attachLabels ( $ this -> widgets_by_id , $ this -> labels ) ; $ this -> page -> setForms ( $ this -> forms ) ; $ page = $ this -> page ; $ this -> free ( ) ; return $ page ; }
11233	public function run ( $ argument , Message $ message , ApiClient $ apiClient ) { $ this -> setApiClient ( $ apiClient ) ; $ this -> execute ( $ argument , $ message ) ; }
12894	public function close ( $ account , $ openId ) { $ params = [ 'kf_account' => $ account , 'openid' => $ openId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CLOSE , $ params ] ) ; }
10025	function getContact ( $ contactId , $ checksum , $ standard_fields = array ( ) , $ custom_fields = array ( ) , $ ignoreChecksum = false ) { $ queryParameters = array ( 'id' => $ contactId , 'checksum' => $ checksum , 'standard_field' => $ standard_fields , 'ignore_checksum' => $ ignoreChecksum ? "true" : "false" ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/contact' , $ queryParameters ) ; }
9563	protected function callHandler ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return $ handler -> handle ( $ exception ) ; } return call_user_func ( $ handler , $ exception ) ; }
12427	public function getAuthorizerOption ( $ authorizerAppId , $ optionName ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ authorizerAppId , 'option_name' => $ optionName , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_OPTION , $ params ] ) ; }
3207	private static function chunk ( $ binaryString , $ bits ) { $ binaryString = chunk_split ( $ binaryString , $ bits , ' ' ) ; if ( substr ( $ binaryString , ( strlen ( $ binaryString ) ) - 1 ) == ' ' ) { $ binaryString = substr ( $ binaryString , 0 , strlen ( $ binaryString ) - 1 ) ; } return explode ( ' ' , $ binaryString ) ; }
2882	protected function _initEmail ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ index = $ this -> getRequest ( ) -> getParam ( 'index' ) ; if ( $ token === null || $ index === null ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return null ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return null ; } $ emails = $ requestProfile -> getEmails ( ) ; if ( ! $ emails || ! ( $ index < count ( $ emails ) ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'E-mail not found' ) ; return null ; } return $ emails [ ( int ) $ index ] ; }
5739	public function render ( MvcEvent $ e ) { $ result = $ e -> getResult ( ) ; if ( $ result instanceof Response ) { return $ result ; } $ response = $ e -> getResponse ( ) ; $ viewModel = $ e -> getViewModel ( ) ; if ( ! $ viewModel instanceof ViewModel ) { return null ; } try { $ result = $ this -> getEnvironment ( ) -> render ( $ viewModel -> getTemplate ( ) . $ this -> getSuffix ( ) , ( array ) $ viewModel -> getVariables ( ) ) ; } catch ( Twig_Error_Loader $ e ) { return null ; } $ response -> setContent ( $ result ) ; $ e -> setResult ( $ response ) ; return $ response ; }
9745	public function setCity ( $ city ) { if ( ! ( $ city instanceof City ) ) { $ city = new City ( $ city ) ; } if ( $ city -> isEmpty ( ) ) { $ this -> invalidArguments ( '10003' ) ; } return $ this -> setParameter ( 'city' , $ city ) ; }
5109	public function orderBy ( $ column , $ type = OrderBy :: ASC ) : IWithLimit { if ( $ type == OrderBy :: DESC ) { $ this -> appendDesc ( $ column ) ; } else if ( ! is_array ( $ column ) ) { $ column = [ $ column ] ; } return $ this -> _orderBy ( $ column ) ; }
10873	public function cleanUser ( string $ validate = null ) : int { $ result = 0 ; if ( $ validate ) { $ validateTo = new DateTime ; $ validateTo -> modify ( $ validate ) ; $ list = $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.active' => false , $ this -> tableName [ 0 ] . '.added IS NOT NULL' , [ $ this -> tableName [ 0 ] . '.added<=%dt' , $ validateTo ] , ] ) ; foreach ( $ list as $ item ) { if ( $ this -> delete ( $ item [ self :: COLUMN_ID ] ) ) { $ result ++ ; } } } return $ result ; }
12519	public function getByCalcId ( $ calcId ) { $ where = Entity :: A_CALC_REF . '=' . ( int ) $ calcId ; $ result = $ this -> get ( $ where ) ; return $ result ; }
9911	function fromArray ( $ object_vars ) { foreach ( $ object_vars as $ key => $ value ) { if ( class_exists ( 'AbstractJSONWrapper' ) && is_subclass_of ( $ this -> { $ key } , 'AbstractJSONWrapper' ) ) { $ this -> { $ key } -> fromArray ( $ value ) ; } else { $ this -> { $ key } = $ value ; } } }
7108	static public function getPrecision ( $ currency ) { if ( isset ( static :: $ precisions [ $ currency ] ) ) { return static :: $ precisions [ $ currency ] ; } return static :: $ precisions [ $ currency ] = static :: getCurrencyBundle ( ) -> getFractionDigits ( $ currency ) ; }
1260	protected function createAccess ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ accessRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AccessRequest' ) ) ; $ accessRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'AccessLicenseNumber' , $ this -> accessKey ) ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'UserId' , $ this -> userId ) ) ; $ p = $ accessRequest -> appendChild ( $ xml -> createElement ( 'Password' ) ) ; $ p -> appendChild ( $ xml -> createTextNode ( $ this -> password ) ) ; return $ xml -> saveXML ( ) ; }
2168	protected function createContentElement ( Result $ objElement , $ strPtable , $ strField ) { $ set = array ( 'pid' => $ objElement -> id , 'ptable' => $ strPtable , 'sorting' => 128 , 'tstamp' => $ objElement -> tstamp , 'type' => 'text' , 'text' => $ objElement -> $ strField , 'addImage' => $ objElement -> addImage , 'singleSRC' => $ objElement -> singleSRC , 'alt' => $ objElement -> alt , 'size' => $ objElement -> size , 'imagemargin' => $ objElement -> imagemargin , 'imageUrl' => $ objElement -> imageUrl , 'fullsize' => $ objElement -> fullsize , 'caption' => $ objElement -> caption , 'floating' => $ objElement -> floating ) ; $ this -> Database -> prepare ( "INSERT INTO tl_content %s" ) -> set ( $ set ) -> execute ( ) ; }
4382	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ str = '' ; $ str .= $ this -> processAlerts ( ) ; $ str .= $ this -> processSummary ( ) ; $ str .= $ this -> processLog ( ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
8063	protected function reaper ( $ pid = - 1 ) { if ( ! is_int ( $ pid ) ) { $ pid = - 1 ; } $ childpid = pcntl_waitpid ( $ pid , $ status , WNOHANG ) ; while ( $ childpid > 0 ) { $ stopSignal = pcntl_wstopsig ( $ status ) ; if ( pcntl_wifexited ( $ stopSignal ) === FALSE ) { array_push ( $ this -> results , array ( 'pid' => $ childpid , 'abnormalChildReturnCode' => $ stopSignal ) ) ; } $ processDetails = $ this -> workerProcesses -> getProcessDetails ( $ childpid ) ; if ( $ processDetails !== NULL ) { $ this -> workerPoolSize -- ; $ this -> workerProcesses -> remove ( $ processDetails ) ; unset ( $ processDetails ) ; } $ childpid = pcntl_waitpid ( $ pid , $ status , WNOHANG ) ; } }
10028	function getContactsByExternalId ( $ externalId , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/externalid/' . utf8_encode ( $ externalId ) , $ queryParameters ) ; }
3192	public function save ( ) { if ( ! $ this -> storage ) { throw new InvalidStorageException ( 'A storage must be defined in order to store the data!' ) ; } $ this -> storage -> store ( $ this -> toArray ( ) ) ; return $ this ; }
115	public function execute ( $ command , $ url , $ cwd = null , $ path = null , $ verbose = false ) { $ this -> config -> prohibitUrlByConfig ( $ url , $ this -> io ) ; return $ this -> executeWithAuthRetry ( $ command , $ cwd , $ url , $ path , $ verbose ) ; }
4350	private function setCopyValues ( $ values ) { if ( isset ( $ values [ 'debug' ] [ 'emailLog' ] ) && $ values [ 'debug' ] [ 'emailLog' ] === true ) { $ values [ 'debug' ] [ 'emailLog' ] = 'onError' ; } foreach ( array ( 'emailFrom' , 'emailFunc' , 'emailTo' ) as $ key ) { if ( isset ( $ values [ 'debug' ] [ $ key ] ) && ! isset ( $ values [ 'errorEmailer' ] [ $ key ] ) ) { $ values [ 'errorEmailer' ] [ $ key ] = $ values [ 'debug' ] [ $ key ] ; } } return $ values ; }
9600	public function length ( ) { $ sumOfSquares = 0 ; foreach ( $ this -> components ( ) as $ component ) { $ sumOfSquares += pow ( $ component , 2 ) ; } return sqrt ( $ sumOfSquares ) ; }
6702	protected function precedence ( $ a , $ b ) { if ( count ( $ a ) > count ( $ b ) ) { $ l = - 1 ; $ r = 1 ; $ x = $ a ; $ y = $ b ; } else { $ l = 1 ; $ r = - 1 ; $ x = $ b ; $ y = $ a ; } foreach ( array_keys ( $ x ) as $ i ) { if ( false === isset ( $ y [ $ i ] ) ) { return $ l ; } if ( $ x [ $ i ] === $ y [ $ i ] ) { continue ; } $ xi = is_integer ( $ x [ $ i ] ) ; $ yi = is_integer ( $ y [ $ i ] ) ; if ( $ xi && $ yi ) { return ( $ x [ $ i ] > $ y [ $ i ] ) ? $ l : $ r ; } elseif ( ( false === $ xi ) && ( false === $ yi ) ) { return ( max ( $ x [ $ i ] , $ y [ $ i ] ) == $ x [ $ i ] ) ? $ l : $ r ; } else { return $ xi ? $ r : $ l ; } } return 0 ; }
423	public function hiddenInput ( $ options = [ ] ) { $ options = array_merge ( $ this -> inputOptions , $ options ) ; $ this -> adjustLabelFor ( $ options ) ; $ this -> parts [ '{input}' ] = Html :: activeHiddenInput ( $ this -> model , $ this -> attribute , $ options ) ; return $ this ; }
12694	public function addOption ( $ name , $ shortcut = null , $ mode = null , $ description = '' , $ default = null ) : self { $ this -> cmd -> addOption ( $ name , $ shortcut , $ mode , $ description , $ default ) ; return $ this ; }
12671	public static function getEmulatorInstance ( $ scheme , $ path , $ context ) { if ( ! isset ( static :: $ emulators [ $ scheme ] ) ) { throw new \ InvalidArgumentException ( 'No emulator found for scheme \'' . $ scheme . '\'' ) ; } $ emulator = static :: $ emulators [ $ scheme ] ; return new $ emulator ( $ path , $ context ) ; }
8087	public function getConnection ( ) { if ( ! ( $ this -> log instanceof Log ) ) { $ this -> log = new Log ( 'DB' ) ; } if ( $ this -> connection instanceof \ PDO ) { return $ this -> connection ; } $ this -> log -> report ( 'Connecting to database...' ) ; try { $ this -> connection = new \ PDO ( $ this -> generateDSN ( ) , $ this -> user , $ this -> password ) ; $ this -> log -> report ( 'Connected to database.' ) ; } catch ( \ PDOException $ e ) { $ this -> log -> error ( 'Failed to connect to database, [SQLSTATE] ' . $ e -> getCode ( ) ) ; } if ( $ this -> connection instanceof \ PDO ) { return $ this -> connection ; } else { return false ; } }
8435	public function delete ( ) : bool { $ status = false ; if ( $ this -> new === false ) { $ deleteQuery = new Delete ( $ this -> getDatabaseName ( ) ) ; $ deleteQuery -> from ( $ this -> getTableName ( ) ) ; $ where = array ( ) ; foreach ( $ this -> getPrimary ( ) as $ primary ) { $ field = $ this -> { 'field' . ucfirst ( $ primary ) } ; $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ primary ) ) ) ; $ where [ $ realName ] = ':primary' . ucfirst ( $ primary ) ; $ deleteQuery -> bind ( 'primary' . ucfirst ( $ primary ) , $ field [ 'value' ] ) ; } $ deleteQuery -> where ( $ where ) ; $ status = $ deleteQuery -> execute ( ) ; } return $ status ; }
11162	protected function getKey ( array $ config ) { if ( ! isset ( $ config [ 'key' ] ) || ! is_string ( $ config [ 'key' ] ) ) { throw new \ DomainException ( 'key must reference a string' , self :: ERR_INVALID_KEY ) ; } return $ config [ 'key' ] ; }
12604	public static function upload ( $ src , $ dest ) { $ dest = Path :: clean ( $ dest ) ; $ baseDir = dirname ( $ dest ) ; try { if ( ! Folder :: exists ( $ baseDir ) ) { Folder :: create ( $ baseDir ) ; } } catch ( Exception $ e ) { throw $ e ; } if ( is_writeable ( $ baseDir ) && move_uploaded_file ( $ src , $ dest ) ) { if ( Path :: setPermissions ( $ dest ) ) { return true ; } throw new Exception ( Helper :: getTranslation ( 'FAILED_CHMOD' ) ) ; } throw new Exception ( Helper :: getTranslation ( 'FAILED_MOVE_UPLOAD' ) ) ; }
9528	private function parseSingle ( & $ i , $ parameter , & $ results ) { if ( $ this -> prefixExists ( $ parameter ) ) { $ closure = $ this -> getClosure ( $ parameter ) ; if ( $ closure != null ) { $ prefix = $ this -> getPrefix ( $ parameter ) ; $ closure_arguments = [ ] ; $ rFunction = new ReflectionFunction ( $ closure ) ; if ( $ rFunction -> isVariadic ( ) ) { $ this -> parseVariadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter ) ; } else { $ this -> parseUniadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter , $ rFunction ) ; } $ result_key = $ this -> getRealName ( $ parameter ) ; $ result = $ results [ $ result_key ] ; if ( ! $ result instanceof ParameterResult ) { if ( $ result == self :: HALT_PARSE ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; unset ( $ results [ $ result_key ] ) ; return false ; } } else { if ( $ result -> shouldHalt ( ) ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; if ( $ result -> isHaltOnly ( ) ) { unset ( $ results [ $ result_key ] ) ; } else { $ results [ $ result_key ] = $ result -> getValue ( ) ; } return false ; } } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } return true ; }
4700	protected function handleInput ( InputInterface $ input ) { if ( $ file = $ input -> getArgument ( 'file' ) ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The input file "%s" not found' , $ file ) ) ; } return file_get_contents ( $ file ) ; } else { $ contents = '' ; if ( $ stdin = fopen ( 'php://stdin' , 'r' ) ) { if ( stream_set_blocking ( $ stdin , false ) ) { $ contents = stream_get_contents ( $ stdin ) ; } fclose ( $ stdin ) ; } if ( $ contents ) { return $ contents ; } } throw new \ InvalidArgumentException ( 'No input file' ) ; }
12368	public function set ( string $ name , string $ value = null ) : Headers { if ( $ value !== null ) { header ( $ name . ': ' . $ value ) ; } else { header ( $ name ) ; } return $ this ; }
2520	public function queuePlacePnr ( RequestOptions \ QueuePlacePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Queue_PlacePNR' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
2900	public function initFromAction ( $ action ) { if ( ! $ action ) { return ; } $ request = $ action -> getRequest ( ) ; $ this -> httpMethod = $ request -> getMethod ( ) ; $ this -> requestOriginalPath = $ request -> getOriginalPathInfo ( ) ; $ this -> requestPath = $ request -> getPathInfo ( ) ; $ this -> remoteIp = Mage :: helper ( 'core/http' ) -> getRemoteAddr ( ) ; $ this -> routeName = $ request -> getRouteName ( ) ; $ this -> module = $ request -> getControllerModule ( ) ; $ this -> class = get_class ( $ action ) ; $ this -> action = $ action -> getActionMethodName ( $ request -> getActionName ( ) ) ; }
5900	public function retrieveFunctionality ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/functionalities/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Functionality ( $ result ) ; return $ result ; }
1613	public function close ( ) { if ( $ this -> _socket !== false ) { $ connection = ( $ this -> unixSocket ? : $ this -> hostname . ':' . $ this -> port ) . ', database=' . $ this -> database ; \ Yii :: trace ( 'Closing DB connection: ' . $ connection , __METHOD__ ) ; try { $ this -> executeCommand ( 'QUIT' ) ; } catch ( SocketException $ e ) { } fclose ( $ this -> _socket ) ; $ this -> _socket = false ; } }
7760	protected function detectMetadataDriver ( $ dir , ContainerBuilder $ container ) { $ configPath = $ this -> getMappingResourceConfigDirectory ( ) ; $ resource = $ dir . '/' . $ configPath ; while ( ! is_dir ( $ resource ) ) { $ resource = dirname ( $ resource ) ; } $ container -> addResource ( new FileResource ( $ resource ) ) ; $ extension = $ this -> getMappingResourceExtension ( ) ; if ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.php' ) ) && count ( $ files ) ) { return 'php' ; } $ container -> addResource ( new FileResource ( $ dir ) ) ; if ( is_dir ( $ dir . '/' . $ this -> getMappingObjectDefaultName ( ) ) ) { return 'annotation' ; } return null ; }
9618	public function registerStackMiddleware ( $ class ) { if ( func_num_args ( ) === 0 ) { throw new \ InvalidArgumentException ( "Missing argument(s) when calling registerStackMiddlerware" ) ; } if ( ! class_exists ( $ class ) && ! is_callable ( $ class ) ) { throw new \ InvalidArgumentException ( "{$class} not found or not callable" ) ; } call_user_func_array ( [ $ this -> builder , "push" ] , func_get_args ( ) ) ; }
5771	public function hasOneRole ( array $ roleIds ) : bool { foreach ( $ roleIds as $ roleId ) { if ( $ this -> hasRole ( ( int ) $ roleId ) ) { return true ; } } return false ; }
4310	public function getChannels ( $ allDescendants = false ) { if ( $ allDescendants ) { $ channels = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ channels = \ array_merge ( $ channels , array ( $ channel -> getCfg ( 'channel' ) => $ channel ) , $ channel -> getChannels ( true ) ) ; } return $ channels ; } return $ this -> channels ; }
912	private function moveParamAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ params = $ doc -> getAnnotationsOfType ( 'param' ) ; if ( empty ( $ params ) ) { return $ content ; } $ others = $ doc -> getAnnotationsOfType ( [ 'throws' , 'return' ] ) ; if ( empty ( $ others ) ) { return $ content ; } $ end = end ( $ params ) -> getEnd ( ) ; $ line = $ doc -> getLine ( $ end ) ; foreach ( $ others as $ other ) { if ( $ other -> getStart ( ) < $ end ) { $ line -> setContent ( $ line -> getContent ( ) . $ other -> getContent ( ) ) ; $ other -> remove ( ) ; } } return $ doc -> getContent ( ) ; }
2	private function buildDependency10Info ( $ depArray ) { static $ dep10toOperatorMap = array ( 'has' => '==' , 'eq' => '==' , 'ge' => '>=' , 'gt' => '>' , 'le' => '<=' , 'lt' => '<' , 'not' => '!=' ) ; $ result = array ( ) ; foreach ( $ depArray as $ depItem ) { if ( empty ( $ depItem [ 'rel' ] ) || ! array_key_exists ( $ depItem [ 'rel' ] , $ dep10toOperatorMap ) ) { continue ; } $ depType = ! empty ( $ depItem [ 'optional' ] ) && 'yes' == $ depItem [ 'optional' ] ? 'optional' : 'required' ; $ depType = 'not' == $ depItem [ 'rel' ] ? 'conflicts' : $ depType ; $ depVersion = ! empty ( $ depItem [ 'version' ] ) ? $ this -> parseVersion ( $ depItem [ 'version' ] ) : '*' ; $ depVersionConstraint = ( 'has' == $ depItem [ 'rel' ] || 'not' == $ depItem [ 'rel' ] ) && '*' == $ depVersion ? '*' : $ dep10toOperatorMap [ $ depItem [ 'rel' ] ] . $ depVersion ; switch ( $ depItem [ 'type' ] ) { case 'php' : $ depChannelName = 'php' ; $ depPackageName = '' ; break ; case 'pkg' : $ depChannelName = ! empty ( $ depItem [ 'channel' ] ) ? $ depItem [ 'channel' ] : 'pear.php.net' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'ext' : $ depChannelName = 'ext' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'os' : case 'sapi' : $ depChannelName = '' ; $ depPackageName = '' ; break ; default : $ depChannelName = '' ; $ depPackageName = '' ; break ; } if ( '' != $ depChannelName ) { $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } } return $ result ; }
10900	public function validate ( string $ method = 'save' ) : array { $ errors = [ ] ; foreach ( $ this -> getValidators ( ) [ $ method ] ?? [ ] as $ field => $ validator ) { try { $ validator -> setName ( $ field ) -> assert ( $ this -> get ( $ field ) ) ; } catch ( NestedValidationException $ e ) { $ errors [ $ field ] = $ e -> getMessages ( ) ; } } return $ errors ; }
2175	private function adjustDatabaseTables ( ) : ? RedirectResponse { $ this -> container -> get ( 'contao.install_tool' ) -> handleRunOnce ( ) ; $ installer = $ this -> container -> get ( 'contao.installer' ) ; $ this -> context [ 'sql_form' ] = $ installer -> getCommands ( ) ; $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_database_update' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return null ; } $ sql = $ request -> request -> get ( 'sql' ) ; if ( ! empty ( $ sql ) && \ is_array ( $ sql ) ) { foreach ( $ sql as $ hash ) { $ installer -> execCommand ( $ hash ) ; } } return $ this -> getRedirectResponse ( ) ; }
6741	public function to ( $ target ) { if ( is_null ( $ this -> request ) ) { throw new \ LogicException ( 'Missing request instance.' ) ; } $ target = new Uri ( $ target ) ; $ uri = $ this -> request -> getUri ( ) -> withScheme ( $ target -> getScheme ( ) ) -> withHost ( $ target -> getHost ( ) ) ; if ( $ port = $ target -> getPort ( ) ) { $ uri = $ uri -> withPort ( $ port ) ; } if ( $ path = $ target -> getPath ( ) ) { $ uri = $ uri -> withPath ( rtrim ( $ path , '/' ) . '/' . ltrim ( $ uri -> getPath ( ) , '/' ) ) ; } if ( ! empty ( $ this -> request -> getQueryParams ( ) ) ) { $ queryParams = $ this -> request -> getQueryParams ( ) ; if ( count ( $ queryParams ) == 1 && empty ( array_shift ( $ queryParams ) ) ) { $ queryKeys = array_keys ( $ this -> request -> getQueryParams ( ) ) ; $ uri = $ uri -> withQuery ( $ queryKeys [ 0 ] ) ; } else { $ uri = $ uri -> withQuery ( http_build_query ( $ this -> request -> getQueryParams ( ) ) ) ; } } $ request = $ this -> request -> withUri ( $ uri ) ; foreach ( $ request -> getHeaders ( ) as $ headerName => $ headerValue ) { if ( empty ( $ headerValue [ 0 ] ) ) { $ request = $ request -> withoutHeader ( $ headerName ) ; } } return $ this -> client -> send ( $ request ) ; }
8395	public static function get ( ) : Logger { if ( self :: $ log == null ) { self :: $ log = new Logger ( ) ; } return self :: $ log ; }
10719	public function addThumbnail ( \ TYPO3 \ CMS \ Extbase \ Domain \ Model \ FileReference $ thumbnail ) { $ this -> thumbnails -> attach ( $ thumbnail ) ; }
10407	private function save ( Pair $ pair ) { $ this -> manager -> persist ( $ pair ) ; $ this -> manager -> commit ( ) ; $ this -> manager -> refresh ( ) ; }
4263	public function unsubscribe ( $ eventName , $ callable ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return ; } if ( $ this -> isClosureFactory ( $ callable ) ) { $ callable [ 0 ] = $ callable [ 0 ] ( ) ; } foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ v ) { if ( $ v !== $ callable && $ this -> isClosureFactory ( $ v ) ) { $ v [ 0 ] = $ v [ 0 ] ( ) ; } if ( $ v === $ callable ) { unset ( $ subscribers [ $ k ] , $ this -> sorted [ $ eventName ] ) ; } else { $ subscribers [ $ k ] = $ v ; } } if ( $ subscribers ) { $ this -> subscribers [ $ eventName ] [ $ priority ] = $ subscribers ; } else { unset ( $ this -> subscribers [ $ eventName ] [ $ priority ] ) ; } } }
11872	protected function _setDataKey ( $ key ) { if ( ! is_null ( $ key ) && ! is_string ( $ key ) && ! ( $ key instanceof Stringable ) ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Data key must be a string or stringable' ) , 0 , null , $ key ) ; } $ this -> dataKey = $ key ; return $ this ; }
6320	public function getColumn ( $ name ) { foreach ( $ this -> columns as $ column ) { if ( $ column -> getName ( ) == $ name ) { return $ column ; } } return null ; }
2892	public function onWebsiteRestriction ( Varien_Event_Observer $ observer ) { $ controller = $ observer -> getController ( ) ; $ result = $ observer -> getResult ( ) ; $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( $ helper -> canShowToolbar ( ) && $ controller instanceof Sheep_Debug_Controller_Front_Action ) { $ result -> setShouldProceed ( false ) ; } }
1197	private function htmlAttributesCallback ( $ name , $ value ) { if ( false === $ value || null === $ value ) { return '' ; } return ' ' . $ this -> renderHtmlAttribute ( $ name , $ value ) ; }
4536	public function setTenantIdIn ( array $ tenantIdIn ) { $ this -> tenantIdIn = $ tenantIdIn ; $ this -> _tenantIdIn = null !== $ tenantIdIn ; return $ this ; }
1638	protected function getGuzzle ( array $ config ) { $ options = [ ] ; if ( isset ( $ config [ 'proxy' ] ) && $ config [ 'proxy' ] ) { if ( isset ( $ config [ 'proxy' ] [ 'http' ] ) && php_sapi_name ( ) != 'cli' ) { unset ( $ config [ 'proxy' ] [ 'http' ] ) ; } $ options [ 'proxy' ] = $ config [ 'proxy' ] ; } return Client :: makeGuzzle ( isset ( $ config [ 'endpoint' ] ) ? $ config [ 'endpoint' ] : null , $ options ) ; }
2204	public static function encodeSpecialChars ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: encodeSpecialChars ( $ v ) ; } return $ varValue ; } $ arrSearch = array ( '#' , '<' , '>' , '(' , ')' , '\\' , '=' ) ; $ arrReplace = array ( '&#35;' , '&#60;' , '&#62;' , '&#40;' , '&#41;' , '&#92;' , '&#61;' ) ; return str_replace ( $ arrSearch , $ arrReplace , $ varValue ) ; }
8094	public function set ( $ keyPath , $ value ) { $ stops = explode ( '.' , $ keyPath ) ; $ currentLocation = $ previousLocation = $ this ; foreach ( $ stops as $ key ) { if ( $ currentLocation instanceof Collection ) { if ( ! ( $ currentLocation -> $ key instanceof Collection ) ) { $ currentLocation -> $ key = array ( ) ; } } else { $ currentLocation = array ( ) ; $ currentLocation -> $ key = array ( ) ; } $ previousLocation = $ currentLocation ; $ currentLocation = $ currentLocation -> $ key ; } $ previousLocation -> $ key = $ value ; }
6732	protected function processMessage ( & $ message ) { if ( ! $ message instanceof \ Closure ) { return ; } $ callback = $ message ; $ message = $ callback ( $ this -> model ) ; }
10939	public function get ( $ key ) { if ( ! ( $ time = $ this -> driver -> get ( $ key ) ) ) { if ( $ key == self :: LAST_UPDATE_KEY ) { $ time = $ this -> reset ( ) ; } else { $ time = $ this -> get ( self :: LAST_UPDATE_KEY ) ; } } return $ time ; }
12411	public function lists ( $ begin , $ count ) { $ params = [ 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_LIST , $ params ] ) ; }
12605	public static function getName ( $ file ) { $ file = str_replace ( '\\' , '/' , $ file ) ; $ slash = strrpos ( $ file , '/' ) ; if ( $ slash !== false ) { return substr ( $ file , $ slash + 1 ) ; } return $ file ; }
8442	public function render ( array $ args , bool $ prettyPrint = null ) { header ( 'Content-type: application/json' ) ; if ( ( constant ( 'STRAY_ENV' ) === 'development' && $ prettyPrint !== false ) || $ prettyPrint === true ) { return ( string ) json_encode ( $ args , JSON_PRETTY_PRINT ) ; } return ( string ) json_encode ( $ args ) ; }
4488	private function broadcastToPlatform ( $ message , string $ platform ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $platform" , [ 'Message' => $ message , ] ) ; return ; } foreach ( $ this -> sns -> getPaginator ( 'ListEndpointsByPlatformApplication' , [ 'PlatformApplicationArn' => $ this -> arns [ $ platform ] , ] ) as $ endpointsResult ) { foreach ( $ endpointsResult [ 'Endpoints' ] as $ endpoint ) { if ( $ endpoint [ 'Attributes' ] [ 'Enabled' ] == 'true' ) { try { $ this -> send ( $ message , $ endpoint [ 'EndpointArn' ] ) ; } catch ( \ Exception $ e ) { $ this -> logger && $ this -> logger -> error ( "Failed to push to {$endpoint['EndpointArn']}" , [ 'Message' => $ message , 'Exception' => $ e , 'Endpoint' => $ endpoint , ] ) ; } } else { $ this -> logger && $ this -> logger -> info ( "Disabled endpoint {$endpoint['EndpointArn']}" , [ 'Message' => $ message , 'Endpoint' => $ endpoint , ] ) ; } } } }
10384	protected static function set_new_params ( $ type , $ hash , $ url , $ extension ) { $ data = [ 'name' => self :: $ id , 'url' => $ url . $ hash . $ extension , 'deps' => self :: unify_params ( $ type , 'deps' ) , 'version' => self :: unify_params ( $ type , 'version' , '1.0.0' ) , ] ; switch ( $ type ) { case 'style' : $ data [ 'media' ] = self :: unify_params ( $ type , 'media' , 'all' ) ; break ; case 'script' : $ data [ 'params' ] = self :: unify_params ( $ type , 'params' ) ; $ data [ 'footer' ] = self :: unify_params ( $ type , 'footer' , false ) ; $ data [ 'params' ] [ 'nonce' ] = wp_create_nonce ( self :: $ id ) ; break ; default : } self :: $ data [ $ type ] = [ $ data [ 'name' ] => $ data ] ; return true ; }
6437	public function getLoginStartUrl ( $ redirecturl ) { $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ request_token = $ connection -> oauth ( 'oauth/request_token' , array ( 'oauth_callback' => $ redirecturl ) ) ; $ this -> request_token = array ( ) ; $ this -> request_token [ 'oauth_token' ] = $ request_token [ 'oauth_token' ] ; $ this -> request_token [ 'oauth_token_secret' ] = $ request_token [ 'oauth_token_secret' ] ; return $ connection -> url ( 'oauth/authorize' , array ( 'oauth_token' => $ request_token [ 'oauth_token' ] ) ) ; }
1216	public static function stableSort ( array $ data , callable $ sortFn ) { array_walk ( $ data , function ( & $ v , $ k ) { $ v = [ $ v , $ k ] ; } ) ; uasort ( $ data , function ( $ a , $ b ) use ( $ sortFn ) { return $ sortFn ( $ a [ 0 ] , $ b [ 0 ] ) ? : ( $ a [ 1 ] < $ b [ 1 ] ? - 1 : 1 ) ; } ) ; return array_map ( function ( $ v ) { return $ v [ 0 ] ; } , array_values ( $ data ) ) ; }
10614	public function createMigrateRepository ( array $ args ) { $ db = $ this -> app -> db ; $ repo = new Repository ( $ db ) ; $ resolver = $ this -> app -> resolver -> getResolver ( "migrations" ) ; $ mods = [ ] ; foreach ( $ resolver -> getSearchPath ( ) as $ name => $ path ) { $ module = new Module ( $ name , $ path , $ db ) ; if ( $ name === "wedeto.db" ) array_unshift ( $ mods , $ module ) ; else array_push ( $ mods , $ module ) ; } foreach ( $ mods as $ module ) $ repo -> addModule ( $ module ) ; return $ repo ; }
4182	public static function instance ( ) { switch ( func_num_args ( ) ) { case func_num_args ( ) == 0 : return new static ( ) ; case func_num_args ( ) == 1 : return new static ( func_get_arg ( 0 ) ) ; case func_num_args ( ) == 2 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) ) ; case func_num_args ( ) == 3 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) ) ; case func_num_args ( ) == 4 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) ) ; case func_num_args ( ) == 5 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) , func_get_arg ( 4 ) ) ; default : throw new Exception ( 'Unable to instantiate class with given arguments' ) ; } }
2923	public function lines ( ) { $ content = [ ] ; $ lines = $ this -> readLinesFromFile ( ) ; foreach ( $ lines as $ row => $ line ) { $ data = [ 'line' => $ row + 1 , 'raw_data' => $ line , 'parsed_data' => $ this -> formatter -> parseLine ( $ line ) ] ; $ content [ ] = $ data ; } return $ content ; }
9050	private static function checkLevel ( $ level ) { if ( $ level != LogLevel :: ALERT && $ level != LogLevel :: CRITICAL && $ level != LogLevel :: DEBUG && $ level != LogLevel :: EMERGENCY && $ level != LogLevel :: ERROR && $ level != LogLevel :: INFO && $ level != LogLevel :: NOTICE && $ level != LogLevel :: WARNING ) { throw new \ Psr \ Log \ InvalidArgumentException ( "Invalid log level provided!" ) ; } }
8927	public function fetch ( $ name ) { $ generator = false ; if ( array_key_exists ( $ name , $ this -> generators ) ) { $ generator = $ this -> generators [ $ name ] ; } return $ generator ; }
4838	public function new_limit_url ( $ type , $ params ) { $ request = array ( ) ; $ params [ 'merchant_id' ] = $ this -> account_details [ 'merchant_id' ] ; $ opt_params = array ( 'redirect_uri' , 'cancel_uri' , 'state' ) ; foreach ( $ opt_params as $ opt_param ) { if ( isset ( $ params [ $ opt_param ] ) ) { $ request [ $ opt_param ] = $ params [ $ opt_param ] ; unset ( $ params [ $ opt_param ] ) ; } } if ( ! isset ( $ request [ 'redirect_uri' ] ) && isset ( $ this -> redirect_uri ) ) { $ request [ 'redirect_uri' ] = $ this -> redirect_uri ; } $ payment_params = array ( $ type => $ params ) ; $ request = array_merge ( $ request , $ payment_params , $ this -> generate_mandatory_params ( ) ) ; $ request [ 'signature' ] = GoCardless_Utils :: generate_signature ( $ request , $ this -> account_details [ 'app_secret' ] ) ; $ query_string = GoCardless_Utils :: generate_query_string ( $ request ) ; return $ this -> base_url . '/connect/' . $ type . 's/new?' . $ query_string ; }
8788	public function style ( $ url , $ attributes = [ ] , $ secure = null ) { $ defaults = [ 'media' => 'all' , 'type' => 'text/css' , 'rel' => 'stylesheet' ] ; $ attributes = array_merge ( $ attributes , $ defaults ) ; $ attributes [ 'href' ] = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> toHtmlString ( '<link' . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL ) ; }
10148	private function readMsoDrawingGroup ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingGroupData .= $ recordData ; }
6771	protected function isDiscountUpdateNeeded ( SaleInterface $ sale ) { if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'autoDiscount' ] ) ) { return true ; } if ( ( 0 == $ sale -> getPaidTotal ( ) ) && $ this -> persistenceHelper -> isChanged ( $ sale , [ 'customerGroup' , 'customer' ] ) ) { return true ; } return $ this -> didInvoiceCountryChanged ( $ sale ) ; }
5328	public function getCpuinfoByLsCpu ( ) { if ( ! $ this -> cpuInfoByLsCpu ) { $ lscpu = shell_exec ( 'lscpu' ) ; $ lscpu = explode ( "\n" , $ lscpu ) ; $ values = [ ] ; foreach ( $ lscpu as $ v ) { $ v = array_map ( 'trim' , explode ( ':' , $ v ) ) ; if ( isset ( $ v [ 0 ] , $ v [ 1 ] ) ) { $ values [ $ v [ 0 ] ] = $ v [ 1 ] ; } } $ this -> cpuInfoByLsCpu = $ values ; } return $ this -> cpuInfoByLsCpu ; }
11655	private function _parseDsn ( $ dsn ) { $ dsn = parse_url ( $ dsn ) ; $ cfg = [ ] ; if ( isset ( $ dsn [ 'port' ] ) ) { $ cfg [ 'port' ] = $ dsn [ 'port' ] ; } return $ cfg + [ 'dbname' => isset ( $ dsn [ 'path' ] ) ? trim ( $ dsn [ 'path' ] , '/' ) : null , 'host' => isset ( $ dsn [ 'host' ] ) ? $ dsn [ 'host' ] : null , 'password' => isset ( $ dsn [ 'pass' ] ) ? $ dsn [ 'pass' ] : null , 'username' => isset ( $ dsn [ 'user' ] ) ? $ dsn [ 'user' ] : null , ] ; }
2196	protected function sendAdminNotification ( $ intId , $ arrData ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'adminSubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ strData = "\n\n" ; foreach ( $ arrData as $ k => $ v ) { if ( $ k == 'password' || $ k == 'tstamp' || $ k == 'dateAdded' ) { continue ; } $ v = StringUtil :: deserialize ( $ v ) ; if ( $ k == 'dateOfBirth' && \ strlen ( $ v ) ) { $ v = Date :: parse ( Config :: get ( 'dateFormat' ) , $ v ) ; } $ strData .= $ GLOBALS [ 'TL_LANG' ] [ 'tl_member' ] [ $ k ] [ 0 ] . ': ' . ( \ is_array ( $ v ) ? implode ( ', ' , $ v ) : $ v ) . "\n" ; } $ objEmail -> text = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'adminText' ] , $ intId , $ strData . "\n" ) . "\n" ; $ objEmail -> sendTo ( $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ) ; $ this -> log ( 'A new user (ID ' . $ intId . ') has registered on the website' , __METHOD__ , TL_ACCESS ) ; }
4863	public function retry ( JobInterface $ job , array $ options = [ ] ) { $ tried = $ job -> getMetadata ( 'mongoqueue.tries' , 0 ) + 1 ; $ job -> setMetaData ( 'mongoqueue.tries' , $ tried ) ; $ options [ 'tried' ] = $ tried ; $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectID ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
2505	public static function loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) { if ( ! isset ( self :: $ wsdlDomXpath [ $ wsdlId ] ) || is_null ( self :: $ wsdlDomXpath [ $ wsdlId ] ) ) { $ wsdlContent = file_get_contents ( $ wsdlFilePath ) ; if ( $ wsdlContent !== false ) { self :: $ wsdlDomDoc [ $ wsdlId ] = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; self :: $ wsdlDomDoc [ $ wsdlId ] -> loadXML ( $ wsdlContent ) ; self :: $ wsdlDomXpath [ $ wsdlId ] = new \ DOMXPath ( self :: $ wsdlDomDoc [ $ wsdlId ] ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ wsdlFilePath . ' could not be loaded' ) ; } } }
7368	protected function checkShipmentIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ sale = $ item -> getSale ( ) ; if ( ! $ sale instanceof Shipment \ ShipmentSubjectInterface ) { return ; } if ( empty ( $ sale -> getShipments ( ) -> toArray ( ) ) ) { return ; } $ min = $ this -> shipmentCalculator -> calculateShippedQuantity ( $ item ) ; if ( 1 === bccomp ( $ min , 0 , 3 ) && 1 === bccomp ( $ min , $ item -> getTotalQuantity ( ) , 3 ) ) { $ this -> context -> buildViolation ( $ constraint -> quantity_is_lower_than_shipped , [ '%min%' => $ min , ] ) -> setInvalidValue ( $ item -> getQuantity ( ) ) -> atPath ( 'quantity' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
10026	function getContacts ( $ page_index = 1 , $ page_size = 100 , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'page_index' => $ page_index , 'page_size' => $ page_size , 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts' , $ queryParameters ) ; }
4050	private function prepareInputScreen ( $ modelName , $ screen ) : array { if ( null === $ metaModel = $ this -> factory -> getMetaModel ( $ modelName ) ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ modelName ) ; } $ caption = [ '' => $ metaModel -> getName ( ) ] ; $ description = [ '' => $ metaModel -> getName ( ) ] ; foreach ( StringUtil :: deserialize ( $ screen [ 'backendcaption' ] , true ) as $ languageEntry ) { $ langCode = $ languageEntry [ 'langcode' ] ; $ caption [ $ langCode ] = ! empty ( $ label = $ languageEntry [ 'label' ] ) ? $ label : $ caption [ '' ] ; $ description [ $ langCode ] = ! empty ( $ title = $ languageEntry [ 'description' ] ) ? $ title : $ description [ '' ] ; if ( $ metaModel -> getFallbackLanguage ( ) === $ langCode ) { $ caption [ '' ] = $ label ; $ description [ '' ] = $ title ; } } $ result = [ 'meta' => $ screen , 'properties' => $ this -> fetchPropertiesFor ( $ screen [ 'id' ] , $ metaModel ) , 'conditions' => $ this -> fetchConditions ( $ screen [ 'id' ] ) , 'groupSort' => $ this -> fetchGroupSort ( $ screen [ 'id' ] , $ metaModel ) , 'label' => $ caption , 'description' => $ description ] ; $ bySetting = $ this -> buildConditionTree ( $ result [ 'conditions' ] ) ; $ result [ 'legends' ] = $ this -> convertLegends ( $ result [ 'properties' ] , $ metaModel , $ bySetting ) ; return $ result ; }
3491	public function withHeader ( string $ name , string $ value ) : Request { $ cloned = clone $ this ; $ cloned -> headers [ $ name ] = $ value ; return $ cloned ; }
4375	protected function buildGroupMethod ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ str = '' ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ label = \ array_shift ( $ args ) ; $ levelClass = isset ( $ meta [ 'level' ] ) ? 'level-' . $ meta [ 'level' ] : null ; if ( ! empty ( $ meta [ 'isMethodName' ] ) ) { $ label = $ this -> markupClassname ( $ label ) ; } foreach ( $ args as $ k => $ v ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ argStr = \ implode ( ', ' , $ args ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'div' , array ( 'class' => array ( 'group-header' , $ method == 'groupCollapsed' ? 'collapsed' : 'expanded' , $ levelClass , ) , 'data-channel' => $ meta [ 'channel' ] , ) , '<span class="group-label">' . $ label . ( ! empty ( $ argStr ) ? '(</span>' . $ argStr . '<span class="group-label">)' : '' ) . '</span>' ) . "\n" ; $ str .= '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => array ( 'm_group' , $ levelClass , ) , ) ) . '>' ; } elseif ( $ method == 'groupEnd' ) { $ str = '</div>' ; } return $ str ; }
4820	public function addField ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> row [ $ name ] = $ value ; } elseif ( is_array ( $ this -> row [ $ name ] ) ) { $ this -> row [ $ name ] [ ] = $ value ; } else { $ this -> row [ $ name ] = array ( $ this -> row [ $ name ] , $ value ) ; } $ this -> informChanges ( ) ; }
209	protected function formatScalarValue ( $ value ) { if ( $ value === true ) { return 'true' ; } if ( $ value === false ) { return 'false' ; } if ( is_float ( $ value ) ) { return StringHelper :: floatToString ( $ value ) ; } return ( string ) $ value ; }
2225	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( 'html' !== $ request -> getRequestFormat ( ) ) { return ; } if ( ! AcceptHeader :: fromString ( $ request -> headers -> get ( 'Accept' ) ) -> has ( 'text/html' ) ) { return ; } $ this -> handleException ( $ event ) ; }
6	private function parse20VersionConstraint ( array $ data ) { static $ dep20toOperatorMap = array ( 'has' => '==' , 'min' => '>=' , 'max' => '<=' , 'exclude' => '!=' ) ; $ versions = array ( ) ; $ values = array_intersect_key ( $ data , $ dep20toOperatorMap ) ; if ( 0 == count ( $ values ) ) { return '*' ; } if ( isset ( $ values [ 'min' ] ) && isset ( $ values [ 'exclude' ] ) && $ data [ 'min' ] == $ data [ 'exclude' ] ) { $ versions [ ] = '>' . $ this -> parseVersion ( $ values [ 'min' ] ) ; } elseif ( isset ( $ values [ 'max' ] ) && isset ( $ values [ 'exclude' ] ) && $ data [ 'max' ] == $ data [ 'exclude' ] ) { $ versions [ ] = '<' . $ this -> parseVersion ( $ values [ 'max' ] ) ; } else { foreach ( $ values as $ op => $ version ) { if ( 'exclude' == $ op && is_array ( $ version ) ) { foreach ( $ version as $ versionPart ) { $ versions [ ] = $ dep20toOperatorMap [ $ op ] . $ this -> parseVersion ( $ versionPart ) ; } } else { $ versions [ ] = $ dep20toOperatorMap [ $ op ] . $ this -> parseVersion ( $ version ) ; } } } return implode ( ',' , $ versions ) ; }
939	public function isWhitespace ( $ whitespaces = " \t\n\r\0\x0B" ) { if ( null === $ whitespaces ) { $ whitespaces = " \t\n\r\0\x0B" ; } if ( $ this -> isArray && ! $ this -> isGivenKind ( T_WHITESPACE ) ) { return false ; } return '' === trim ( $ this -> content , $ whitespaces ) ; }
3322	public function anyOfOptions ( OptionCollection $ options ) { $ name = $ this -> getOptionName ( ) ; $ keys = $ options -> keys ( ) ; return in_array ( $ name , $ keys ) ; }
5764	public function routeIndexResetFilter ( Request $ request , Response $ response , $ args ) { return $ this -> indexViewObjects ( $ response , true ) ; }
3756	public function createVariant ( ConfigInterface $ objConfig ) { $ objItem = $ this -> getMetaModel ( ) -> findById ( $ objConfig -> getId ( ) ) -> varCopy ( ) ; if ( ! $ objItem ) { return null ; } $ model = new Model ( $ objItem ) ; $ model -> setMeta ( $ model :: IS_CHANGED , true ) ; return $ model ; }
4441	public function fromSubscriptions ( string $ topic ) : array { $ response = [ ] ; if ( empty ( $ topic ) ) { return $ response ; } $ subscriptions = $ this -> client -> call ( 'subscription' , 'default' , 'all' , $ topic ) ; $ subscriptions = json_decode ( $ subscriptions , true ) ? : [ ] ; foreach ( $ subscriptions as $ subscription => $ queues ) { $ topicPattern = str_replace ( [ '.' , '*' , '#' ] , [ '\.' , '[a-zA-z0-9^.]{1,}' , '.*' ] , $ subscription ) ; if ( preg_match ( "/^$topicPattern$/" , $ topic ) ) { $ response = array_merge ( $ response , $ queues ) ; } } return array_unique ( $ response ) ; }
1423	protected function with ( $ query , EncodingParametersInterface $ parameters ) { $ query -> with ( $ this -> getRelationshipPaths ( ( array ) $ parameters -> getIncludePaths ( ) ) ) ; }
11821	function prepare_items ( ) { $ this -> columns = array ( $ this -> get_columns ( ) , $ this -> get_hidden_columns ( ) , $ this -> get_sortable_columns ( ) ) ; $ this -> items = $ this -> get_items ( ) ; usort ( $ this -> example_data , array ( $ this , 'usort_reorder' ) ) ; }
9348	public function sameSize ( $ matrix ) { return ( $ this -> size -> cols == $ matrix -> cols && $ this -> size -> rows == $ matrix -> rows ) ; }
7077	static public function getSaleEditableDocumentTypes ( SaleInterface $ sale ) { $ types = [ ] ; foreach ( DocumentTypes :: getTypes ( ) as $ type ) { if ( ! static :: isSaleSupportsDocumentType ( $ sale , $ type ) ) { continue ; } foreach ( $ sale -> getAttachments ( ) as $ attachment ) { if ( $ attachment -> getType ( ) === $ type ) { continue 2 ; } } $ types [ ] = $ type ; } return $ types ; }
2331	public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ return = array ( ) ; while ( $ this -> next ( ) ) { $ strPk = $ this -> current ( ) -> getPk ( ) ; if ( $ strKey != 'id' && isset ( $ this -> $ strPk ) ) { $ return [ $ this -> $ strPk ] = $ this -> $ strKey ; } else { $ return [ ] = $ this -> $ strKey ; } } return $ return ; }
12100	public function priceBrutto ( $ netto , $ tax ) { $ tax = round ( ( double ) $ tax / 100.0 , 2 ) ; if ( $ tax < 0.00 ) { throw new Exception ( sprintf ( 'Tax must be greater than or equal to 0, given %s.' , $ tax ) ) ; } if ( $ tax === 0.00 ) { return $ netto ; } $ result = $ netto * ( $ tax + 1 ) ; return round ( $ result , 2 , PHP_ROUND_HALF_UP ) ; }
9815	public function setWorksheet ( Worksheet $ value = null ) { if ( $ value !== null ) { $ this -> worksheet = $ value ; } return $ this ; }
2895	public function send ( ) { try { $ this -> captureEmail ( ) ; } catch ( Exception $ e ) { Mage :: logException ( $ e ) ; } return $ this -> parentSend ( ) ; }
8734	public function increment ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> increment ( $ column , $ amount , $ extra ) ; }
4265	private function sortSubscribers ( $ eventName ) { \ krsort ( $ this -> subscribers [ $ eventName ] ) ; $ this -> sorted [ $ eventName ] = array ( ) ; foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ subscriber ) { if ( $ this -> isClosureFactory ( $ subscriber ) ) { $ subscriber [ 0 ] = $ subscriber [ 0 ] ( ) ; $ this -> subscribers [ $ eventName ] [ $ priority ] [ $ k ] = $ subscriber ; } $ this -> sorted [ $ eventName ] [ ] = $ subscriber ; } } }
8824	protected function errorMessage ( $ filter , $ field , $ params = null ) { $ text = ( isset ( $ this -> texts [ $ field ] [ $ filter ] ) && ! is_null ( $ this -> texts [ $ field ] [ $ filter ] ) ? $ this -> texts [ $ field ] [ $ filter ] : $ this -> msg ) ; $ text = str_replace ( [ ':label:' , ':value:' ] , '%s' , $ text ) ; if ( ! isset ( $ this -> data [ $ field ] ) ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } elseif ( ! is_null ( $ params ) ) { if ( $ filter == 'matches' ) { if ( $ this -> matches ( $ this -> data [ $ field ] , $ this -> data [ $ params ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] , $ params ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } }
10297	private function writeTitle ( XMLWriter $ objWriter , Title $ title = null ) { if ( $ title === null ) { return ; } $ objWriter -> startElement ( 'c:title' ) ; $ objWriter -> startElement ( 'c:tx' ) ; $ objWriter -> startElement ( 'c:rich' ) ; $ objWriter -> startElement ( 'a:bodyPr' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:lstStyle' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:p' ) ; $ caption = $ title -> getCaption ( ) ; if ( ( is_array ( $ caption ) ) && ( count ( $ caption ) > 0 ) ) { $ caption = $ caption [ 0 ] ; } $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichTextForCharts ( $ objWriter , $ caption , 'a' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writeLayout ( $ objWriter , $ title -> getLayout ( ) ) ; $ objWriter -> startElement ( 'c:overlay' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
6143	public function checkQuery ( $ query = null ) { if ( $ query === null ) { $ query = $ this -> query ; } if ( strlen ( $ query ) == 0 ) { return true ; } $ pattern = "/^" . $ this -> regex [ "uric" ] . "*$/" ; $ status = @ preg_match ( $ pattern , $ query ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI query string validation failed" ) ; } return ( $ status == 1 ) ; }
3012	public function unfollow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/unfollow' , $ options , false ) ; }
1610	private function _isRedirectRegex ( $ uri ) { if ( preg_match ( '/\/(.*)\/([g|m|i|x|X|s|u|U|A|J|D]+)/m' , $ uri ) === 0 ) { $ i = preg_match_all ( '/(?<!\\\\)\?(?![^(]*\))/' , $ uri , $ matches , PREG_OFFSET_CAPTURE ) ; while ( $ i -- ) { $ x = $ matches [ 0 ] [ $ i ] [ 1 ] ; $ uri = substr_replace ( $ uri , '\?' , $ x , 1 ) ; } $ i = preg_match_all ( '/(?<!\\\\)\/(?![^(]*\))/' , $ uri , $ matches , PREG_OFFSET_CAPTURE ) ; while ( $ i -- ) { $ x = $ matches [ 0 ] [ $ i ] [ 1 ] ; $ uri = substr_replace ( $ uri , '\/' , $ x , 1 ) ; } } if ( @ preg_match ( $ uri , null ) === false ) $ uri = '/^' . $ uri . '$/i' ; if ( @ preg_match ( $ uri , null ) !== false ) return $ uri ; return false ; }
11883	public function getTicketCacheKey ( ) { if ( is_null ( $ this -> ticketCacheKey ) ) { return $ this -> ticketCachePrefix . $ this -> getAccessToken ( ) -> getAppId ( ) ; } return $ this -> ticketCacheKey ; }
8418	public static function registerDatabase ( string $ alias ) { if ( isset ( self :: $ databases [ $ alias ] ) === false ) { self :: $ databases [ $ alias ] = new static ( $ alias ) ; } }
5942	public function readLine ( $ token = "\n" ) { $ this -> connect ( ) ; $ line = StringHelper :: factory ( "" ) ; while ( ! $ line -> endsWith ( $ token ) ) { $ this -> waitForReadyRead ( ) ; $ data = @ fgets ( $ this -> stream , 4096 ) ; Signal :: getInstance ( ) -> emit ( strtolower ( $ this -> getAdapterType ( ) ) . "DataRead" , $ data ) ; if ( $ data === false ) { if ( $ line -> count ( ) ) { $ line -> append ( $ token ) ; } else { throw new Ts3Exception ( "connection to server '" . $ this -> config [ "host" ] . ":" . $ this -> config [ "port" ] . "' lost" ) ; } } else { $ line -> append ( $ data ) ; } } return $ line -> trim ( ) ; }
12035	private function createMethodGenerator ( $ methodName , $ body , DocBlockGenerator $ docBlock , $ parameterInfoArray , $ returnType = null ) { $ parameters = [ ] ; foreach ( $ parameterInfoArray as $ parameterInfo ) { $ parameters [ ] = new ParameterGenerator ( $ parameterInfo [ 0 ] , $ parameterInfo [ 1 ] ) ; } $ methodGenerator = new MethodGenerator ( $ methodName ) ; $ methodGenerator -> setParameters ( $ parameters ) ; if ( $ returnType != null ) { if ( is_array ( $ returnType ) ) { $ returnType = implode ( '|' , $ returnType ) ; } $ tags [ ] = new GenericTag ( 'return' , $ returnType ) ; $ docBlock -> setTags ( $ tags ) ; } $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; return $ methodGenerator ; }
8328	public function getCaptchaResult ( $ captchaId ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get&id={$captchaId}&json=1" ) ; $ responseData = json_decode ( $ response -> getBody ( ) -> __toString ( ) , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new InvalidArgumentException ( 'json_decode error: ' . json_last_error_msg ( ) ) ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_CAPCHA_NOT_READY ) { return false ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_OK ) { $ this -> getLogger ( ) -> info ( "Got OK response: `{$responseData['request']}`." ) ; return $ responseData [ 'request' ] ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseData [ 'request' ] ) ? : $ responseData [ 'request' ] , $ responseData [ 'status' ] ) ; }
4855	public function log ( $ level , $ message , array $ context = [ ] ) { static $ counter = [ ] ; ! $ this -> logger || $ this -> logger -> log ( $ level , $ message , $ context ) ; $ message = is_object ( $ message ) ? $ message -> __toString ( ) : $ message ; if ( isset ( $ this -> messages [ $ level ] [ $ hash = md5 ( $ message ) ] ) ) { $ this -> messages [ $ level ] [ $ hash ] = '(' . ++ $ counter [ $ hash ] . ') ' . $ message ; } else { $ counter [ $ hash ] = 1 ; $ this -> messages [ $ level ] [ $ hash ] = $ message ; } }
5969	protected static function sortFileList ( array $ a , array $ b ) { if ( ! array_key_exists ( "src" , $ a ) || ! array_key_exists ( "src" , $ b ) || ! array_key_exists ( "type" , $ a ) || ! array_key_exists ( "type" , $ b ) ) { return 0 ; throw new Ts3Exception ( "invalid parameter" , 0x602 ) ; } if ( $ a [ "type" ] != $ b [ "type" ] ) { return ( $ a [ "type" ] < $ b [ "type" ] ) ? - 1 : 1 ; } return strcmp ( strtolower ( $ a [ "src" ] ) , strtolower ( $ b [ "src" ] ) ) ; }
1176	public function sometimes ( $ attribute , $ rules = [ ] ) { $ callback = function ( ) { return true ; } ; $ this -> validator -> sometimes ( $ attribute , $ rules , $ callback ) ; $ this -> rules -> addConditionalRules ( $ attribute , ( array ) $ rules ) ; }
3126	protected function isStartPoint ( TimePoint $ point ) { return $ point -> match ( null , TimePoint :: TARGET_ALL , TimePoint :: TYPE_START ) ; }
8898	public function update ( $ primary_value , $ data ) { $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ result = $ this -> _database -> where ( $ this -> primary_key , $ primary_value ) -> set ( $ data ) -> update ( $ this -> _table ) ; $ this -> trigger ( 'after_update' , array ( $ data , $ result ) ) ; return $ result ; } else { return FALSE ; } }
2391	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> calendarfeeds ) || ! \ is_array ( $ this -> User -> calendarfeeds ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> calendarfeeds ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_calendar_feed' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_calendar_feed' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, calendarfeeds, calendarfeedp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT calendarfeeds, calendarfeedp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> calendarfeeds = $ root ; } }
8794	protected function writeNewEnvironmentFileWith ( $ key ) { file_put_contents ( base_path ( '.env' ) , preg_replace ( $ this -> keyReplacementPattern ( ) , 'APP_KEY=' . $ key , file_get_contents ( base_path ( '.env' ) ) ) ) ; }
5262	protected function mergeBoolQuery ( array $ query1 , array $ query2 , $ type ) { if ( empty ( $ query2 [ 'bool' ] [ $ type ] ) ) { return $ query1 ; } else { if ( empty ( $ query1 [ 'bool' ] [ $ type ] ) ) { $ query1 [ 'bool' ] [ $ type ] = [ ] ; } } $ query1 [ 'bool' ] [ $ type ] = array_merge ( $ query1 [ 'bool' ] [ $ type ] , $ query2 [ 'bool' ] [ $ type ] ) ; return $ query1 ; }
8414	public function getMasterLink ( ) { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return $ this -> servers [ 'all' ] [ 'link' ] ; } return $ this -> servers [ 'write' ] [ 'link' ] ; }
10863	protected function createIterator ( ) { $ options = \ RecursiveDirectoryIterator :: SKIP_DOTS ; $ iterator = new \ RecursiveDirectoryIterator ( $ this -> dir , $ options ) ; $ options = \ RecursiveIteratorIterator :: SELF_FIRST ; return new \ RecursiveIteratorIterator ( $ iterator , $ options ) ; }
12240	public function getElementsByClassName ( $ class ) { if ( strpos ( $ class , '"' ) !== false || strpos ( $ class , "'" ) !== false ) { return array ( ) ; } $ xpath = './/*[contains(concat(" ", @class, " "), " ' . htmlspecialchars ( $ class ) . ' ")]' ; return $ this -> xpath ( $ xpath ) ; }
4306	public function time ( $ label = null ) { $ args = \ func_get_args ( ) ; $ this -> internal -> getMetaVals ( $ args , array ( ) , array ( 'label' => null ) ) ; \ extract ( $ args ) ; if ( isset ( $ label ) ) { $ timers = & $ this -> data [ 'timers' ] [ 'labels' ] ; if ( ! isset ( $ timers [ $ label ] ) ) { $ timers [ $ label ] = array ( 0 , \ microtime ( true ) ) ; } elseif ( ! isset ( $ timers [ $ label ] [ 1 ] ) ) { $ timers [ $ label ] [ 1 ] = \ microtime ( true ) ; } } else { $ this -> data [ 'timers' ] [ 'stack' ] [ ] = \ microtime ( true ) ; } }
1535	protected function fill ( $ record , ResourceObject $ resource , EncodingParametersInterface $ parameters ) { $ this -> fillAttributes ( $ record , $ resource -> getAttributes ( ) ) ; $ this -> fillRelationships ( $ record , $ resource -> getRelationships ( ) , $ parameters ) ; }
10202	public function setHorizontal ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: HORIZONTAL_GENERAL ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'horizontal' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> horizontal = $ pValue ; } return $ this ; }
12445	private function getPlainCalcId ( $ period ) { if ( $ period ) { $ dsMax = $ this -> hlpPeriod -> getPeriodLastDate ( $ period ) ; } else { $ dsMax = Cfg :: DEF_MAX_DATESTAMP ; } $ query = $ this -> qbCalcGetLast -> build ( ) ; $ bind = [ QBCalcGetLast :: BND_CODE => Cfg :: CODE_TYPE_CALC_FORECAST_PLAIN , QBCalcGetLast :: BND_DATE => $ dsMax , QBCalcGetLast :: BND_STATE => Cfg :: CALC_STATE_COMPLETE ] ; $ conn = $ query -> getConnection ( ) ; $ rs = $ conn -> fetchRow ( $ query , $ bind ) ; $ result = $ rs [ QBCalcGetLast :: A_CALC_ID ] ; return $ result ; }
5475	public function getAction ( ) { $ url = $ this -> action ; if ( $ this -> default_target && ! $ url -> getTarget ( ) ) { $ url -> setTarget ( $ this -> default_target ) ; } if ( $ this -> getMethod ( ) === 'get' ) { $ url -> clearRequest ( ) ; } return $ url ; }
11777	public function appendChoice ( FormEvent $ event ) { $ rootForm = $ this -> getRootForm ( $ event -> getForm ( ) ) ; $ group = $ rootForm -> getData ( ) ; if ( $ group === NULL ) { return ; } $ choices = array ( ) ; foreach ( $ group -> getCustomFields ( ) as $ customFields ) { $ choices [ $ customFields -> getSlug ( ) ] = $ this -> translatableStringHelper -> localize ( $ customFields -> getName ( ) ) ; } $ options = array_merge ( $ this -> options , array ( 'choice_list' => new SimpleChoiceList ( $ choices ) , ) ) ; $ event -> getForm ( ) -> getParent ( ) -> add ( $ this -> choiceName , 'choice' , $ options ) ; }
4637	private function createMailEvent ( Email $ email , string $ name , ResultInterface $ result = null ) : MailEvent { $ event = new MailEvent ( $ email , $ name ) ; if ( $ result !== null ) { $ event -> setResult ( $ result ) ; } return $ event ; }
11720	public function countPost ( $ actor ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( 'actor' => $ actor ) ) ; return count ( $ entities ) ; }
4231	public static function findInheritedDoc ( \ Reflector $ reflector ) { $ name = $ reflector -> getName ( ) ; $ reflectionClass = $ reflector -> getDeclaringClass ( ) ; $ interfaces = $ reflectionClass -> getInterfaceNames ( ) ; foreach ( $ interfaces as $ className ) { $ reflectionClass2 = new \ ReflectionClass ( $ className ) ; if ( $ reflectionClass2 -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass2 -> getMethod ( $ name ) ) ; } } $ reflectionClass = $ reflectionClass -> getParentClass ( ) ; if ( $ reflectionClass && $ reflectionClass -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass -> getMethod ( $ name ) ) ; } }
12510	public function buildPreview ( $ by ) { if ( ! in_array ( $ by , $ this -> previewBys , true ) ) { throw new InvalidArgumentException ( 'This preview by not exist.' ) ; } if ( empty ( $ this -> msgType ) ) { throw new RuntimeException ( 'Message type not exist.' ) ; } elseif ( $ this -> msgType === Broadcast :: MSG_TYPE_VIDEO ) { if ( is_array ( $ this -> message ) ) { $ this -> message = array_shift ( $ this -> message ) ; } $ this -> msgType = 'mpvideo' ; } if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message content to send.' ) ; } if ( empty ( $ this -> to ) ) { throw new RuntimeException ( 'No to.' ) ; } $ content = ( new Transformer ( $ this -> msgType , $ this -> message ) ) -> transform ( ) ; $ message = array_merge ( $ this -> buildTo ( $ this -> to , $ by ) , $ content ) ; return $ message ; }
369	public function getViewNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _viewNames [ $ schema ] ) || $ refresh ) { $ this -> _viewNames [ $ schema ] = $ this -> findViewNames ( $ schema ) ; } return $ this -> _viewNames [ $ schema ] ; }
6021	public function setApiKey ( $ apiKey ) { $ this -> apiKey = $ apiKey ; list ( , $ datacentre ) = explode ( '-' , $ this -> apiKey ) ; $ this -> apiUrl = str_replace ( '<dc>' , $ datacentre , $ this -> apiUrl ) ; }
8412	public function isConnected ( ) : bool { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return isset ( $ this -> servers [ 'all' ] [ 'link' ] ) ; } return isset ( $ this -> servers [ 'read' ] [ 'link' ] ) && isset ( $ this -> servers [ 'write' ] [ 'link' ] ) ; }
4364	private static function setStr ( $ str ) { self :: $ str = $ str ; self :: $ curI = 0 ; self :: $ stats = array ( 'bytesOther' => 0 , 'bytesSpecial' => 0 , 'bytesUtf8' => 0 , 'strLen' => \ strlen ( $ str ) , ) ; }
179	protected function loadBundle ( $ name , $ config = [ ] , $ publish = true ) { if ( ! isset ( $ config [ 'class' ] ) ) { $ config [ 'class' ] = $ name ; } $ bundle = Yii :: createObject ( $ config ) ; if ( $ publish ) { $ bundle -> publish ( $ this ) ; } return $ bundle ; }
6008	protected function init ( $ ftkey ) { if ( strlen ( $ ftkey ) != 32 ) { throw new Ts3Exception ( "invalid file transfer key format" ) ; } $ this -> getProfiler ( ) -> start ( ) ; $ this -> getTransport ( ) -> send ( $ ftkey ) ; Signal :: getInstance ( ) -> emit ( "filetransferHandshake" , $ this ) ; }
11456	public function batchDeviceSummary ( $ timestamp , $ pageIndex ) { $ params = [ 'date' => $ timestamp , 'page_index' => $ pageIndex , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_LIST , $ params ] ) ; }
4950	public function createDraft ( array $ data = null , $ persist = false ) { $ data [ 'isDraft' ] = true ; return $ this -> create ( $ data , $ persist ) ; }
223	protected function normalizeNumericStringValue ( $ value ) { $ powerPosition = strrpos ( $ value , 'E' ) ; if ( $ powerPosition !== false ) { $ valuePart = substr ( $ value , 0 , $ powerPosition ) ; $ powerPart = substr ( $ value , $ powerPosition + 1 ) ; } else { $ powerPart = null ; $ valuePart = $ value ; } $ separatorPosition = strrpos ( $ valuePart , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ valuePart , 0 , $ separatorPosition ) ; $ fractionalPart = substr ( $ valuePart , $ separatorPosition + 1 ) ; } else { $ integerPart = $ valuePart ; $ fractionalPart = null ; } $ integerPart = preg_replace ( '/^\+?(-?)0*(\d+)$/' , '$1$2' , $ integerPart ) ; $ integerPart = preg_replace ( '/^\+?(-?)0*$/' , '${1}0' , $ integerPart ) ; if ( $ fractionalPart !== null ) { $ fractionalPart = rtrim ( $ fractionalPart , '0' ) ; if ( empty ( $ fractionalPart ) ) { $ fractionalPart = $ powerPart !== null ? '0' : null ; } } $ normalizedValue = $ integerPart ; if ( $ fractionalPart !== null ) { $ normalizedValue .= '.' . $ fractionalPart ; } elseif ( $ normalizedValue === '-0' ) { $ normalizedValue = '0' ; } if ( $ powerPart !== null ) { $ normalizedValue .= 'E' . $ powerPart ; } return $ normalizedValue ; }
9969	public function getDataValidation ( $ pCellCoordinate ) { if ( isset ( $ this -> dataValidationCollection [ $ pCellCoordinate ] ) ) { return $ this -> dataValidationCollection [ $ pCellCoordinate ] ; } $ this -> dataValidationCollection [ $ pCellCoordinate ] = new DataValidation ( ) ; return $ this -> dataValidationCollection [ $ pCellCoordinate ] ; }
5830	public function prepareRequest ( Request $ request ) { $ this -> ch = curl_init ( ) ; curl_setopt ( $ this -> ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ this -> ch , CURLOPT_HEADER , true ) ; curl_setopt ( $ this -> ch , CURLOPT_URL , $ request -> getUrl ( ) ) ; $ options = $ request -> getOptions ( ) ; if ( ! empty ( $ options ) ) { curl_setopt_array ( $ this -> ch , $ options ) ; } $ method = $ request -> getMethod ( ) ; if ( $ method === 'post' ) { curl_setopt ( $ this -> ch , CURLOPT_POST , 1 ) ; } elseif ( $ method !== 'get' ) { curl_setopt ( $ this -> ch , CURLOPT_CUSTOMREQUEST , strtoupper ( $ method ) ) ; } curl_setopt ( $ this -> ch , CURLOPT_HTTPHEADER , $ request -> formatHeaders ( ) ) ; if ( $ this -> methods [ $ method ] === true ) { curl_setopt ( $ this -> ch , CURLOPT_POSTFIELDS , $ request -> encodeData ( ) ) ; } }
6595	protected function getMethodComment ( \ ReflectionMethod $ method ) { $ lines = preg_split ( "/((\r?\n)|(\r\n?))/" , $ method -> getDocComment ( ) ) ; $ count = count ( $ lines ) ; foreach ( $ lines as $ i => $ line ) { $ line = preg_replace ( '/^\s*(\/\*\*|\*\/?)\s*/' , '' , $ line ) ; $ line = trim ( $ line ) ; $ lines [ $ i ] = $ line ; if ( ! $ line && ( $ i == 0 || $ i == $ count - 1 ) ) { unset ( $ lines [ $ i ] ) ; } } return array_values ( $ lines ) ; }
5908	public function listUsers ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/users' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new User ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5233	public function handleException ( \ Exception $ exception ) { if ( $ this -> loggingEnabled ) { $ this -> exceptionLogger -> log ( $ exception ) ; } if ( 'cgi' === $ this -> sapi ) { $ this -> header ( 'Status: 500 Internal Server Error' ) ; } else { $ this -> header ( 'HTTP/1.1 500 Internal Server Error' ) ; } $ this -> writeBody ( $ this -> createResponseBody ( $ exception ) ) ; }
10940	public function getResponse ( $ params = [ ] , $ lifetime = - 1 , Response $ response = null ) { if ( ! $ response ) { $ response = new Response ( ) ; } if ( ! $ this -> enable ) { return $ response ; } return $ this -> configurator -> configure ( $ response , $ this -> getMax ( $ params ) , $ lifetime ) ; }
11990	public function toggleFiltrable ( $ entityName , $ id ) { $ entity = $ this -> entityManager -> getRepository ( $ entityName ) -> find ( $ id ) ; if ( ! $ entity ) { throw new NotFoundHttpException ( ) ; } $ entity -> toggleFiltrable ( ) ; $ this -> entityManager -> persist ( $ entity ) ; $ this -> entityManager -> flush ( ) ; return $ entity -> isFiltrable ( ) ; }
6199	protected function transformParam ( $ param , $ k ) { if ( isset ( $ this -> routeMapParse [ $ k ] [ $ param ] ) and ! is_array ( $ this -> routeMapParse [ $ k ] [ $ param ] ) ) { return $ this -> routeMapParse [ $ k ] [ $ param ] ; } else { return '(.+?)' ; } }
4156	function every ( $ interval , Job $ job ) { $ expression = new SimpleExpression ( $ interval ) ; $ this -> add ( $ expression , $ job ) ; return $ this ; }
12204	public function makeEmojiAccessible ( $ text ) { return preg_replace_callback ( $ this -> search , function ( $ matches ) { $ desc = $ this -> emoji [ $ this -> utf8ToUnicode ( $ matches [ 0 ] ) ] ; return sprintf ( $ this -> output , $ desc , $ matches [ 0 ] ) ; } , $ text ) ; }
5236	public function get ( $ name = null ) { $ constructor = $ this -> class -> getConstructor ( ) ; if ( null === $ constructor || $ this -> class -> isInternal ( ) ) { return $ this -> class -> newInstance ( ) ; } $ params = $ this -> injectionValuesForMethod ( $ constructor ) ; if ( count ( $ params ) === 0 ) { return $ this -> class -> newInstance ( ) ; } return $ this -> class -> newInstanceArgs ( $ params ) ; }
9688	public function det ( ) { if ( $ this -> m == $ this -> n ) { $ d = $ this -> pivsign ; for ( $ j = 0 ; $ j < $ this -> n ; ++ $ j ) { $ d *= $ this -> LU [ $ j ] [ $ j ] ; } return $ d ; } throw new CalculationException ( Matrix :: MATRIX_DIMENSION_EXCEPTION ) ; }
8103	private function buildQuery ( $ sql , $ arguments = null ) { if ( is_array ( $ arguments ) ) { $ finalArgs = array ( ) ; foreach ( $ arguments as $ field => $ val ) { $ finalArgs [ ] = " {$field}=:{$field}" ; } $ finalArgs = implode ( ' AND' , $ finalArgs ) ; if ( strpos ( $ sql , ' _arguments_' ) ) { $ sql = str_replace ( ' _arguments_' , $ finalArgs , $ sql ) ; } else { } } $ sql = str_replace ( ' _table_' , " {$this->tableName} " , $ sql ) ; return $ sql ; }
9931	public function getRule ( $ pIndex ) { if ( ! isset ( $ this -> ruleset [ $ pIndex ] ) ) { $ this -> ruleset [ $ pIndex ] = new Column \ Rule ( $ this ) ; } return $ this -> ruleset [ $ pIndex ] ; }
794	public function activeAttributes ( ) { $ scenario = $ this -> getScenario ( ) ; $ scenarios = $ this -> scenarios ( ) ; if ( ! isset ( $ scenarios [ $ scenario ] ) ) { return [ ] ; } $ attributes = array_keys ( array_flip ( $ scenarios [ $ scenario ] ) ) ; foreach ( $ attributes as $ i => $ attribute ) { if ( $ attribute [ 0 ] === '!' ) { $ attributes [ $ i ] = substr ( $ attribute , 1 ) ; } } return $ attributes ; }
11336	public function getBaseNamespace ( ) { if ( ! empty ( $ this -> moduleSet ) && isset ( Yii :: $ app -> extensions [ $ this -> moduleSet ] ) ) { $ bsClass = Yii :: $ app -> extensions [ $ this -> moduleSet ] [ 'bootstrap' ] ; $ bsReflector = new \ ReflectionClass ( new $ bsClass ( ) ) ; return $ bsReflector -> getNamespaceName ( ) ; } return 'cascade\modules' ; }
5469	public function overlayMessage ( $ compare , $ dumper ) { $ this -> dumper = $ dumper ; return sprintf ( $ this -> message , $ this -> testMessage ( $ compare ) ) ; }
2490	protected function processConnectionConfiguration ( ContainerBuilder $ container , array $ config ) { $ alias = $ this -> getAlias ( ) ; if ( isset ( $ config [ 'default_connection' ] ) ) { $ container -> setParameter ( "{$alias}.default_connection" , $ config [ 'default_connection' ] ) ; } elseif ( ! empty ( $ config [ 'connections' ] ) ) { reset ( $ config [ 'connections' ] ) ; $ container -> setParameter ( "{$alias}.default_connection" , key ( $ config [ 'connections' ] ) ) ; } foreach ( $ config [ 'connections' ] as $ name => $ params ) { $ this -> configureSearchServices ( $ container , $ name , $ params ) ; $ this -> configureBoostMap ( $ container , $ name , $ params ) ; $ this -> configureIndexingDepth ( $ container , $ name , $ params ) ; $ container -> setParameter ( "$alias.connection.$name" , $ params ) ; } foreach ( $ config [ 'endpoints' ] as $ name => $ params ) { $ this -> defineEndpoint ( $ container , $ name , $ params ) ; } $ searchEngineDef = $ container -> findDefinition ( self :: ENGINE_ID ) ; $ searchEngineDef -> setFactory ( [ new Reference ( 'ezpublish.solr.engine_factory' ) , 'buildEngine' ] ) ; $ boostFactorProviderDef = $ container -> findDefinition ( self :: BOOST_FACTOR_PROVIDER_ID ) ; $ boostFactorProviderDef -> setFactory ( [ new Reference ( 'ezpublish.solr.boost_factor_provider_factory' ) , 'buildService' ] ) ; }
11484	protected function getFunctionArguments ( ReflectionFunctionAbstract $ func , array $ params = array ( ) ) { $ args = [ ] ; foreach ( $ func -> getParameters ( ) as $ param ) { $ class = $ param -> getClass ( ) ; if ( $ class ) { $ args [ ] = $ this -> resolveClassArg ( $ class , $ param , $ params ) ; } else { $ args [ ] = $ this -> resolveNonClassArg ( $ param , $ params , $ func ) ; } } return $ args ; }
6353	public static function tryFind ( Iterator $ iterator , callable $ predicate ) : Optional { return Optional :: ofNullable ( self :: find ( $ iterator , $ predicate ) ) ; }
4982	public function setOptions ( $ options ) { foreach ( $ options as $ key => $ val ) { $ this -> setOption ( $ key , $ val ) ; } }
8848	public function tag ( ) { $ tag = $ this -> getCurrentTag ( ) ; if ( $ tag ) { $ this -> blogPosts = $ tag -> BlogPosts ( ) ; return $ this -> render ( ) ; } return $ this -> httpError ( 404 , "Not Found" ) ; }
9063	private function getKeys ( ) : array { $ result = [ ] ; $ rows = $ this -> connection -> query ( " SELECT [INDEX_NAME], [COLUMN_NAME], [INDEX_TYPE], [NON_UNIQUE], [SEQ_IN_INDEX] FROM [information_schema.STATISTICS] WHERE [TABLE_SCHEMA] = %s AND [TABLE_NAME] = %s AND [INDEX_NAME] != %s" , $ this -> database , $ this -> name , 'PRIMARY' ) ; foreach ( $ rows as $ row ) { $ name = $ row -> INDEX_NAME ; if ( isset ( $ result [ $ name ] ) ) { $ obj = $ result [ $ name ] ; } else { $ obj = new Key ; } $ obj -> name = $ name ; $ obj -> addColumn ( $ row -> SEQ_IN_INDEX , $ row -> COLUMN_NAME ) ; $ obj -> type = $ row -> INDEX_TYPE ; $ obj -> unique = ! $ row -> NON_UNIQUE ; $ result [ $ name ] = $ obj ; } return $ result ; }
7811	private static function filterArray ( $ needle , $ heystack , $ always = array ( ) ) { foreach ( $ heystack as $ k => $ v ) { if ( ! in_array ( $ v , $ needle ) && ! in_array ( $ v , $ always ) ) unset ( $ heystack [ $ k ] ) ; } return $ heystack ; }
1540	public function withQualifiedColumn ( $ column ) { $ parts = explode ( '.' , $ column ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withColumn ( $ parts [ 1 ] ) ; return $ this ; }
8552	public function setServiceFeeEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ServiceFeeEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12623	public function fire ( $ eventName , $ infoClass = null ) { if ( isset ( $ this -> events [ $ eventName ] ) ) { foreach ( $ this -> events [ $ eventName ] as $ bind => $ data ) { call_user_func_array ( [ $ data [ 'object' ] , $ data [ 'methodName' ] ] , [ $ infoClass ] ) ; } } }
12731	protected function getTasks ( ) { $ tasks = [ ] ; $ tasks [ 'flush-file-cache' ] = [ ] ; $ tasks [ 'flush-file-cache' ] [ 'title' ] = 'Flush File Cache' ; $ tasks [ 'flush-file-cache' ] [ 'description' ] = 'Clear the file cache in Cascade' ; $ tasks [ 'flush-file-cache' ] [ 'run' ] = function ( ) { Yii :: $ app -> fileCache -> flush ( ) ; Yii :: $ app -> response -> content = 'File cache was flushed!' ; Yii :: $ app -> response -> taskOptions = [ 'state' => 'success' , 'title' => 'Success' ] ; } ; $ tasks [ 'flush-cache' ] = [ ] ; $ tasks [ 'flush-cache' ] [ 'title' ] = 'Flush Memory Cache' ; $ tasks [ 'flush-cache' ] [ 'description' ] = 'Clear the memory cache in Cascade' ; $ tasks [ 'flush-cache' ] [ 'run' ] = function ( ) { Yii :: $ app -> cache -> flush ( ) ; Yii :: $ app -> response -> content = 'Memory cache was flushed!' ; Yii :: $ app -> response -> taskOptions = [ 'state' => 'success' , 'title' => 'Success' ] ; } ; return $ tasks ; }
12162	public function getForm ( $ primaryModel = false , $ settings = [ ] ) { if ( ! $ primaryModel ) { return false ; } $ formSegments = [ $ this -> getFormSegment ( $ primaryModel , $ settings ) ] ; $ config = [ 'class' => $ this -> formGeneratorClass , 'models' => $ primaryModel -> collectModels ( ) , 'items' => $ formSegments ] ; return Yii :: createObject ( $ config ) ; }
10986	public static function getMaxUploadSize ( $ max_size = 0 ) { $ post_max_size = Tools :: unformatBytes ( ini_get ( 'post_max_size' ) ) ; $ upload_max_filesize = Tools :: unformatBytes ( ini_get ( 'upload_max_filesize' ) ) ; if ( $ max_size > 0 ) { $ result = min ( $ post_max_size , $ upload_max_filesize , $ max_size ) ; } else { $ result = min ( $ post_max_size , $ upload_max_filesize ) ; } return $ result ; }
2797	public function getAdapter ( ) { if ( is_null ( $ this -> adapter ) ) { $ name = ucfirst ( strtolower ( $ this -> get ( 'adapter' ) ) ) ; $ class = '\\Humbug\\Adapter\\' . $ name ; $ this -> adapter = new $ class ; } return $ this -> adapter ; }
754	public function run ( ) { if ( Yii :: $ app -> request -> getQueryParam ( self :: REFRESH_GET_VAR ) !== null ) { $ code = $ this -> getVerifyCode ( true ) ; Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; return [ 'hash1' => $ this -> generateValidationHash ( $ code ) , 'hash2' => $ this -> generateValidationHash ( strtolower ( $ code ) ) , 'url' => Url :: to ( [ $ this -> id , 'v' => uniqid ( '' , true ) ] ) , ] ; } $ this -> setHttpHeaders ( ) ; Yii :: $ app -> response -> format = Response :: FORMAT_RAW ; return $ this -> renderImage ( $ this -> getVerifyCode ( ) ) ; }
8401	public function render ( RenderInterface $ render , $ status = 200 ) { $ this -> renderInst = $ render ; $ this -> status = $ status ; }
9198	public function getRedirectUrlForAuth ( ) { $ oauth = new Oauth1 ( array ( 'consumer_key' => $ this -> credentials -> getConsumerKey ( ) , 'consumer_secret' => $ this -> credentials -> getConsumerSecret ( ) , 'callback' => $ this -> credentials -> getCallbackUrl ( ) ) ) ; $ this -> guzzleClient -> getEmitter ( ) -> attach ( $ oauth ) ; $ requestTokenResponse = $ this -> guzzleClient -> post ( Config :: get ( 'oauth_request_token' ) , array ( 'auth' => 'oauth' ) ) ; $ oauthToken = array ( ) ; parse_str ( $ requestTokenResponse -> getBody ( ) , $ oauthToken ) ; $ params = http_build_query ( array ( 'oauth_token' => $ oauthToken [ 'oauth_token' ] ) ) ; return ( Config :: get ( 'base_url' ) . Config :: get ( 'oauth_authenticate' ) . '?' . $ params ) ; }
3458	public function extend ( $ module ) : void { if ( is_object ( $ module ) || class_exists ( $ module ) ) { $ this -> modules [ ] = $ module ; } else { throw ApplicationException :: forInvalidModule ( $ module ) ; } }
4223	public function getCfg ( $ key = null ) { if ( ! \ strlen ( $ key ) ) { return $ this -> cfg ; } if ( isset ( $ this -> cfg [ $ key ] ) ) { return $ this -> cfg [ $ key ] ; } return null ; }
8834	private function getObserver ( ) : ProcessObserverInterface { if ( 1 === count ( $ this -> observerList ) ) { $ observer = $ this -> observerList [ 0 ] ; } elseif ( count ( $ this -> observerList ) ) { $ observer = new AggregateLogger ( $ this -> observerList ) ; } else { $ observer = new NullProcessObserver ( ) ; } return $ observer ; }
8541	public function compile ( ) { if ( ! count ( $ this -> msgid ) ) return "" ; $ str = "" ; if ( $ this -> comments ) $ str .= implode ( self :: NEWLINE , $ this -> comments ) . self :: NEWLINE ; if ( $ this -> msgctxt ) $ str .= 'msgctxt "' . $ this -> msgctxt . '"' . self :: NEWLINE ; $ included_blocks = [ 'msgid' ] ; if ( $ this -> msgstr_plural ) $ included_blocks [ ] = 'msgid_plural' ; else $ included_blocks [ ] = 'msgstr' ; foreach ( $ included_blocks as $ key ) { if ( is_array ( $ this -> $ key ) ) { $ str .= "$key " ; $ str .= implode ( self :: NEWLINE , array_map ( [ $ this , 'quoteWrap' ] , $ this -> $ key ) ) . self :: NEWLINE ; } } if ( $ this -> msgid_plural && $ this -> msgstr_plural ) { foreach ( $ this -> msgstr_plural as $ plural_key => $ plural_message ) { $ str .= 'msgstr[' . $ plural_key . '] ' ; $ str .= implode ( self :: NEWLINE , array_map ( [ $ this , 'quoteWrap' ] , $ plural_message ) ) . self :: NEWLINE ; } } return trim ( $ str ) ; }
9868	private function writePrintOptions ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'printOptions' ) ; $ objWriter -> writeAttribute ( 'gridLines' , ( $ pSheet -> getPrintGridlines ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'gridLinesSet' , 'true' ) ; if ( $ pSheet -> getPageSetup ( ) -> getHorizontalCentered ( ) ) { $ objWriter -> writeAttribute ( 'horizontalCentered' , 'true' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getVerticalCentered ( ) ) { $ objWriter -> writeAttribute ( 'verticalCentered' , 'true' ) ; } $ objWriter -> endElement ( ) ; }
3246	public function onCallbackFail ( $ order , $ data = null ) { $ this -> statusCode = 'failed' ; $ this -> detail = 'failed callback' ; $ this -> didCallback = true ; }
12360	public static function encodeHashId ( $ id ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ id ; } $ hashids = App :: make ( 'Hashids' ) ; return $ hashids -> encode ( $ id , date ( 'd' ) ) ; }
1277	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'TrackRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'Track' ) ) ; if ( null !== $ this -> requestOption ) { $ request -> appendChild ( $ xml -> createElement ( 'RequestOption' , $ this -> requestOption ) ) ; } if ( null !== $ this -> trackingNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ this -> trackingNumber ) ) ; } if ( $ this -> isMailInnovations ( ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'IncludeMailInnovationIndicator' ) ) ; } if ( null !== $ this -> referenceNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) -> appendChild ( $ xml -> createElement ( 'Value' , $ this -> referenceNumber ) ) ; } if ( null !== $ this -> shipperNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ this -> shipperNumber ) ) ; } if ( null !== $ this -> beginDate || null !== $ this -> endDate ) { $ DateRange = $ xml -> createElement ( 'PickupDateRange' ) ; if ( null !== $ this -> beginDate ) { $ beginDate = $ this -> beginDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'BeginDate' , $ beginDate ) ) ; } if ( null !== $ this -> endDate ) { $ endDate = $ this -> endDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'EndDate' , $ endDate ) ) ; } $ trackRequest -> appendChild ( $ DateRange ) ; } return $ xml -> saveXML ( ) ; }
331	public function mset ( $ items , $ duration = 0 , $ dependency = null ) { return $ this -> multiSet ( $ items , $ duration , $ dependency ) ; }
10586	protected static function registerEntity ( entity \ EntityInterface $ entity ) { if ( count ( self :: $ entities ) === 0 ) { register_shutdown_function ( "sndsgd\\fs\\Temp::cleanup" ) ; } self :: $ entities [ $ entity -> getPath ( ) ] = $ entity ; }
2094	private function isScope ( string $ scope ) : bool { if ( null === $ this -> container || null === ( $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ) ) { return false ; } $ matcher = $ this -> container -> get ( 'contao.routing.scope_matcher' ) ; if ( ContaoCoreBundle :: SCOPE_BACKEND === $ scope ) { return $ matcher -> isBackendRequest ( $ request ) ; } if ( ContaoCoreBundle :: SCOPE_FRONTEND === $ scope ) { return $ matcher -> isFrontendRequest ( $ request ) ; } return false ; }
8172	private function getSourceExcerpt ( $ source = '' , $ line = 1 , $ plus = 1 , $ format = false ) { $ excerpt = [ ] ; $ twig = Escape :: html ( $ source ) ; $ lines = preg_split ( "/(\r\n|\n|\r)/" , $ twig ) ; $ start = max ( 1 , $ line - $ plus ) ; $ limit = min ( count ( $ lines ) , $ line + $ plus ) ; for ( $ i = $ start - 1 ; $ i < $ limit ; $ i ++ ) { if ( $ format ) { $ attr = 'data-line="' . ( $ i + 1 ) . '"' ; if ( $ i === $ line - 1 ) $ excerpt [ ] = "<mark $attr>$lines[$i]</mark>" ; else $ excerpt [ ] = "<span $attr>$lines[$i]</span>" ; } else { $ excerpt [ ] = $ lines [ $ i ] ; } } return implode ( "\n" , $ excerpt ) ; }
5002	public function removeEmptyGroups ( ) { $ tabs = $ this -> getFormTabs ( ) ; if ( ! is_array ( $ tabs ) ) { return ; } $ groups = $ this -> getFormGroups ( ) ; foreach ( $ tabs as $ tabKey => $ tab ) { foreach ( $ tab [ 'groups' ] as $ tabGroup ) { if ( ! array_key_exists ( $ tabGroup , $ groups ) ) { unset ( $ tabs [ $ tabKey ] ) ; } } } $ this -> setFormTabs ( $ tabs ) ; }
10405	public function set ( $ key , $ value ) { $ pair = $ this -> repository -> find ( $ key ) ; if ( $ pair === null ) { $ pair = new Pair ( ) ; $ pair -> setId ( $ key ) ; } $ pair -> setValue ( $ value ) ; $ this -> save ( $ pair ) ; return $ pair ; }
5073	private function createController ( ) : void { $ aFields = $ this -> getArguments ( ) ; $ aCreated = [ ] ; try { $ aModels = array_filter ( explode ( ',' , $ aFields [ 'MODEL_NAME' ] ) ) ; foreach ( $ aModels as $ sModel ) { $ aFields [ 'MODEL_NAME' ] = $ sModel ; $ this -> oOutput -> write ( 'Creating controller <comment>' . $ sModel . '</comment>... ' ) ; Factory :: model ( $ sModel , $ aFields [ 'MODEL_PROVIDER' ] ) ; $ sPath = static :: CONTROLLER_PATH . $ sModel . '.php' ; if ( file_exists ( $ sPath ) ) { throw new ControllerExistsException ( 'Controller "' . $ sModel . '" exists already at path "' . $ sPath . '"' ) ; } $ this -> createFile ( $ sPath , $ this -> getResource ( 'template/controller.php' , $ aFields ) ) ; $ aCreated [ ] = $ sPath ; $ this -> oOutput -> writeln ( '<info>done!</info>' ) ; } } catch ( \ Exception $ e ) { $ this -> oOutput -> writeln ( '<error>failed!</error>' ) ; if ( ! empty ( $ aCreated ) ) { $ this -> oOutput -> writeln ( '<error>Cleaning up - removing newly created controllers</error>' ) ; foreach ( $ aCreated as $ sPath ) { @ unlink ( $ sPath ) ; } } throw $ e ; } }
9205	public function init ( ) { $ path = $ this -> absolutePath ( $ this -> getFile ( ) ) ; $ this -> quiet ( 'Initializing seed file: ' . $ this -> shortPath ( $ path ) ) ; $ this -> existsOrCreate ( $ path ) ; }
2330	public function next ( ) { if ( ! isset ( $ this -> arrModels [ $ this -> intIndex + 1 ] ) ) { return false ; } ++ $ this -> intIndex ; return $ this ; }
4854	protected function profiling ( $ signal = true ) { static $ timeStart ; if ( $ signal ) { $ timeStart = microtime ( true ) ; } if ( ! $ signal ) { $ this -> timeExecution = ( microtime ( true ) - $ timeStart ) / 60 ; return $ this -> timeExecution ; } }
7597	public function render ( $ sFontAwesome , array $ aFontAwesomeAttributes = null ) { if ( ! is_scalar ( $ sFontAwesome ) ) { throw new \ InvalidArgumentException ( sprintf ( 'FontAwesome expects a scalar value, "%s" given' , gettype ( $ sFontAwesome ) ) ) ; } if ( empty ( $ aFontAwesomeAttributes ) ) { $ aFontAwesomeAttributes = array ( 'class' => 'fa' ) ; } else { if ( empty ( $ aFontAwesomeAttributes [ 'class' ] ) ) { $ aFontAwesomeAttributes [ 'class' ] = 'fa' ; } elseif ( ! preg_match ( '/(\s|^)fa(\s|$)/' , $ aFontAwesomeAttributes [ 'class' ] ) ) { $ aFontAwesomeAttributes [ 'class' ] .= ' fa' ; } } if ( strpos ( 'fa-' , $ sFontAwesome ) !== 0 ) { $ sFontAwesome = 'fa-' . $ sFontAwesome ; } if ( ! preg_match ( '/(\s|^)' . preg_quote ( $ sFontAwesome , '/' ) . '(\s|$)/' , $ aFontAwesomeAttributes [ 'class' ] ) ) { $ aFontAwesomeAttributes [ 'class' ] .= ' ' . $ sFontAwesome ; } return sprintf ( static :: $ faFormat , $ this -> createAttributesString ( $ aFontAwesomeAttributes ) ) ; }
4386	protected function dumpMethods ( $ methods ) { $ str = '' ; if ( ! empty ( $ methods ) ) { $ counts = array ( 'public' => 0 , 'protected' => 0 , 'private' => 0 , 'magic' => 0 , ) ; foreach ( $ methods as $ info ) { $ counts [ $ info [ 'visibility' ] ] ++ ; } $ str .= ' Methods:' . "\n" ; foreach ( $ counts as $ vis => $ count ) { if ( $ count ) { $ str .= ' ' . $ vis . ': ' . $ count . "\n" ; } } } else { $ str .= ' Methods: none!' . "\n" ; } return $ str ; }
2420	public static function moveResource ( $ strSource , $ strDestination ) { $ objFile = FilesModel :: findByPath ( $ strSource ) ; if ( $ objFile === null ) { $ objFile = static :: addResource ( $ strDestination ) ; } $ strFolder = \ dirname ( $ strDestination ) ; if ( $ strFolder == Config :: get ( 'uploadPath' ) ) { $ objFile -> pid = null ; } else { $ objFolder = FilesModel :: findByPath ( $ strFolder ) ; if ( $ objFolder === null ) { $ objFolder = static :: addResource ( $ strFolder ) ; } $ objFile -> pid = $ objFolder -> uuid ; } $ objFile -> path = $ strDestination ; $ objFile -> name = basename ( $ strDestination ) ; $ objFile -> save ( ) ; if ( $ objFile -> type == 'folder' ) { $ objFiles = FilesModel :: findMultipleByBasepath ( $ strSource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objFiles -> path = preg_replace ( '@^' . preg_quote ( $ strSource , '@' ) . '/@' , $ strDestination . '/' , $ objFiles -> path ) ; $ objFiles -> save ( ) ; } } } if ( ( $ strPath = \ dirname ( $ strSource ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } if ( ( $ strPath = \ dirname ( $ strDestination ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } return $ objFile ; }
2076	public function purgeImageCache ( ) { $ container = System :: getContainer ( ) ; $ strTargetPath = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.image.target_dir' ) ) ; $ strRootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; foreach ( scan ( $ strRootDir . '/' . $ strTargetPath ) as $ dir ) { if ( strncmp ( $ dir , '.' , 1 ) !== 0 ) { $ objFolder = new Folder ( $ strTargetPath . '/' . $ dir ) ; $ objFolder -> purge ( ) ; } } $ this -> purgePageCache ( ) ; $ this -> log ( 'Purged the image cache' , __METHOD__ , TL_CRON ) ; }
5945	public function freetext ( $ freetext , $ deploymentSiteIds = null , $ mode = self :: FREETEXT_OR , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'mode' => $ mode , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/freetext/' . $ freetext . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11200	public function checkIfSingleton ( $ name , $ item ) { if ( isset ( $ this -> signaturesToSingletons -> $ name ) and $ this -> signaturesToSingletons -> $ name ) { $ this -> $ name = $ item ; $ this -> signaturesToSingletons = false ; } }
2541	protected function analyzeWithErrCodeCategoryMsgQuery ( SendResult $ response , $ qErr , $ qCat , $ qMsg , $ errLevel = null ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ errorCatNode = $ domXpath -> query ( $ qCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ errLevel ) ; } return $ analyzeResponse ; }
12900	public function offsetGet ( $ offset ) { if ( $ offset === 'headers' ) { $ headers = [ 'HTTP/' . $ this -> getResponse ( ) -> getProtocolVersion ( ) . ' ' . $ this -> getResponse ( ) -> getStatusCode ( ) . ' ' . $ this -> getResponse ( ) -> getReasonPhrase ( ) ] ; foreach ( $ this -> getResponse ( ) -> getHeaders ( ) as $ header => $ values ) { foreach ( $ values as $ value ) { $ headers [ ] = $ header . ': ' . $ value ; } } return $ headers ; } }
10309	function getOpensCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ excludeAnonymousOpens = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousOpens ) ) $ params [ 'exclude_anonymous_opens' ] = ( $ excludeAnonymousOpens == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/opens/count' , $ params ) ; }
7588	public function setFileName ( $ fileName ) { $ fileName = preg_replace ( "([^\w\s\d\-_~,;\[\]\(\).])" , '' , $ fileName ) ; $ fileName = preg_replace ( "([\.]{2,})" , '' , $ fileName ) ; $ this -> fileName = $ fileName ; return $ this ; }
5936	public function addGroup ( $ item ) { if ( ! ( $ item instanceof Group ) ) { if ( is_array ( $ item ) ) { try { $ item = new Group ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Group. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Group"!' , E_USER_WARNING ) ; } } $ this -> groups [ ] = $ item ; return $ this ; }
6396	public function run ( ) : void { $ thrownException = null ; try { $ this -> lock -> lock ( ) ; try { $ this -> runnable -> run ( ) ; } catch ( Exception $ e ) { self :: getLogger ( ) -> error ( $ e ) ; $ thrownException = $ e ; } $ this -> lock -> unLock ( ) ; } catch ( LockException $ e ) { throw new RunException ( 'Lock error during running.' , 0 , $ e ) ; } if ( $ thrownException !== null ) { throw new RunException ( 'Error during execution wrapped Runnable object.' , 0 , $ thrownException ) ; } }
11062	public static function isEncodingSupported ( $ encoding ) { $ encoding = strtolower ( $ encoding ) ; if ( isset ( static :: supportedEncodings ( ) [ $ encoding ] ) ) { return true ; } return false ; }
5398	public function paintSignal ( $ type , $ payload ) { parent :: paintSignal ( $ type , $ payload ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . "signal type=\"$type\">" ; print '<![CDATA[' . serialize ( $ payload ) . ']]>' ; print '</' . $ this -> namespace . "signal>\n" ; }
767	public function login ( IdentityInterface $ identity , $ duration = 0 ) { if ( $ this -> beforeLogin ( $ identity , false , $ duration ) ) { $ this -> switchIdentity ( $ identity , $ duration ) ; $ id = $ identity -> getId ( ) ; $ ip = Yii :: $ app -> getRequest ( ) -> getUserIP ( ) ; if ( $ this -> enableSession ) { $ log = "User '$id' logged in from $ip with duration $duration." ; } else { $ log = "User '$id' logged in from $ip. Session not enabled." ; } $ this -> regenerateCsrfToken ( ) ; Yii :: info ( $ log , __METHOD__ ) ; $ this -> afterLogin ( $ identity , false , $ duration ) ; } return ! $ this -> getIsGuest ( ) ; }
9019	public function getKeywords ( $ string , $ amount = 10 ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ keywords = $ analysis -> getKeyValuesByFrequency ( ) ; return array_slice ( $ keywords , 0 , $ amount ) ; }
9572	public function boot ( ) { if ( $ this -> booted ) return ; $ this -> booting = true ; $ this -> registerProviders ( ) ; foreach ( $ this -> configurators as $ configurator ) { $ this -> invokeConfigurator ( $ configurator ) ; } $ this -> resolveStack ( ) ; $ this -> booted = true ; }
8977	public function setParameter ( $ name , $ value ) { if ( ! isset ( $ ref ) ) { $ ref = new \ ReflectionClass ( $ this -> config ) ; } $ function = sprintf ( 'set%s' , ucfirst ( $ name ) ) ; if ( ! $ ref -> hasMethod ( $ function ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The function "%s" does not exists on configuration' , $ name ) ) ; } $ this -> config -> $ function ( $ value ) ; return $ this ; }
2550	protected function loadSessionHandler ( $ sessionHandler , $ params ) { if ( $ sessionHandler instanceof HandlerInterface ) { $ newSessionHandler = $ sessionHandler ; } else { $ newSessionHandler = HandlerFactory :: createHandler ( $ params ) ; } return $ newSessionHandler ; }
9027	public function isQuestion ( $ string ) { $ probability = 0 ; if ( strpos ( $ string , '?' ) ) { $ probability += 1 ; } $ words = $ this -> getWords ( $ string ) ; foreach ( $ this -> inquiryWords as $ queryWord ) { if ( ! strncmp ( strtolower ( $ string ) , $ queryWord , strlen ( $ queryWord ) ) ) { $ probability += 1 ; } elseif ( stristr ( strtolower ( $ string ) , $ queryWord ) ) { $ probability += 0.5 ; } } if ( $ probability >= 2 ) { return true ; } return false ; }
12612	public function getIP ( ) { $ ip = "UNKNOWN" ; if ( getenv ( "HTTP_CLIENT_IP" ) ) { $ ip = getenv ( "HTTP_CLIENT_IP" ) ; } else if ( getenv ( "HTTP_X_FORWARDED_FOR" ) ) { $ ip = getenv ( "HTTP_X_FORWARDED_FOR" ) ; } else if ( getenv ( "REMOTE_ADDR" ) ) { $ ip = getenv ( "REMOTE_ADDR" ) ; } return $ ip ; }
9018	public function getActionWords ( $ string , $ language = 'english' ) { $ words = $ this -> getWords ( $ string ) ; $ filter = new ActionWordsFilter ( $ language ) ; $ actionWords = [ ] ; foreach ( $ words as $ word ) { $ word = $ this -> removePunctuation ( $ word ) ; if ( ! is_null ( $ filter -> filter ( $ word ) ) ) { $ actionWords [ ] = $ word ; } } return $ actionWords ; }
9231	public function actionIndex ( $ format = false , $ arraymap = false , $ term = false , $ category = false , $ time = false ) { $ searchModel = new PostSearch ( ) ; $ req = Yii :: $ app -> request -> queryParams ; if ( $ term ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "term" ] = $ term ; } if ( $ category ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "category" ] = $ category ; } if ( $ time ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "time" ] = $ time ; } $ dataProvider = $ searchModel -> search ( $ req ) ; $ query = $ dataProvider -> query ; $ query -> andWhere ( [ 'status' => [ 1 ] ] ) ; if ( $ format == 'json' ) { $ model = [ ] ; foreach ( $ dataProvider -> getModels ( ) as $ d ) { $ obj = $ d -> attributes ; if ( $ arraymap ) { $ map = explode ( "," , $ arraymap ) ; if ( count ( $ map ) == 1 ) { $ obj = ( isset ( $ d [ $ arraymap ] ) ? $ d [ $ arraymap ] : null ) ; } else { $ obj = [ ] ; foreach ( $ map as $ a ) { $ k = explode ( ":" , $ a ) ; $ v = ( count ( $ k ) > 1 ? $ k [ 1 ] : $ k [ 0 ] ) ; $ obj [ $ k [ 0 ] ] = ( $ v == "Obj" ? json_encode ( $ d -> attributes ) : ( isset ( $ d -> $ v ) ? $ d -> $ v : null ) ) ; } } } if ( $ term ) { if ( ! in_array ( $ obj , $ model ) ) { array_push ( $ model , $ obj ) ; } } else { array_push ( $ model , $ obj ) ; } } header ( "Access-Control-Allow-Origin: *" ) ; header ( "Access-Control-Expose-Headers: X-Pagination-Per-Page,X-Pagination-Current-Page,X-Pagination-Page-Count,X-Pagination-Total-Count,Content-Type,Location" ) ; return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , ] ) ; } }
3124	protected function fixRange ( $ range , $ lastTimestamp = null ) { $ fixedRange = [ ] ; $ last = null ; $ open = false ; foreach ( $ range as $ point ) { if ( $ this -> isStartPoint ( $ point ) ) { if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ point , TimePoint :: TYPE_END ) ; } $ open = true ; } else if ( $ this -> isEndPoint ( $ point ) ) { if ( ! $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last ? $ last : $ point , TimePoint :: TYPE_START ) ; } $ open = false ; } $ fixedRange [ ] = $ point ; $ last = $ point ; } if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last , TimePoint :: TYPE_END , $ lastTimestamp ) ; } return $ fixedRange ; }
7778	protected function extractInput ( array $ data ) { $ input = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ input [ $ field ] = $ fieldData [ 0 ] ; } return $ input ; }
11957	public function add ( $ renderer , $ name = null ) { if ( is_null ( $ name ) ) { $ name = $ renderer ; } $ this -> renderers [ $ name ] = $ renderer ; }
5785	public function addColumn ( string $ name , $ value ) { $ this -> args [ ] = $ value ; if ( mb_strlen ( $ this -> columns ) > 0 ) { $ this -> columns .= ", " ; } $ this -> columns .= $ name ; if ( mb_strlen ( $ this -> values ) > 0 ) { $ this -> values .= ", " ; } $ argNum = count ( $ this -> args ) ; $ this -> values .= "$" . $ argNum ; }
4786	function offsetGet ( $ key ) { $ this -> access ( $ key ) ; if ( ! array_key_exists ( $ key , $ this -> row ) ) { $ this -> access ( $ key , true ) ; } return $ this -> row [ $ key ] ; }
9578	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; if ( $ this -> materializeAsset ) { MaterializeAsset :: register ( $ view ) ; } if ( $ this -> customAsset ) { MaterializeCustomAsset :: register ( $ view ) ; } $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } $ this -> registerClientEvents ( ) ; }
2529	protected function generateGuid ( ) { mt_srand ( ( double ) microtime ( ) * 10000 ) ; $ charId = strtoupper ( md5 ( uniqid ( rand ( ) , true ) ) ) ; $ hyphen = chr ( 45 ) ; $ uuid = substr ( $ charId , 0 , 8 ) . $ hyphen . substr ( $ charId , 8 , 4 ) . $ hyphen . substr ( $ charId , 12 , 4 ) . $ hyphen . substr ( $ charId , 16 , 4 ) . $ hyphen . substr ( $ charId , 20 , 12 ) ; return $ uuid ; }
6880	public function transform ( $ data ) { $ address = new ShipmentAddress ( ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { return $ address ; } foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field ] ) ) { $ value = $ data [ $ field ] ; if ( $ field === 'country' ) { if ( 0 >= $ value ) { throw new InvalidArgumentException ( "Invalid country id." ) ; } $ value = $ this -> countryRepository -> find ( $ value ) ; if ( null === $ value ) { throw new InvalidArgumentException ( "Country not found." ) ; } } elseif ( $ field === 'phone' || $ field === 'mobile' ) { $ value = unserialize ( $ value ) ; if ( ! $ value instanceof PhoneNumber ) { throw new InvalidArgumentException ( "Invalid phone number." ) ; } } $ this -> accessor -> setValue ( $ address , $ field , $ value ) ; } } return $ address ; }
748	protected function buildCompleteString ( $ format ) { $ placeholderValues = [ '{type}' => $ this -> type , '{length}' => $ this -> buildLengthString ( ) , '{unsigned}' => $ this -> buildUnsignedString ( ) , '{notnull}' => $ this -> buildNotNullString ( ) , '{unique}' => $ this -> buildUniqueString ( ) , '{default}' => $ this -> buildDefaultString ( ) , '{check}' => $ this -> buildCheckString ( ) , '{comment}' => $ this -> buildCommentString ( ) , '{pos}' => $ this -> isFirst ? $ this -> buildFirstString ( ) : $ this -> buildAfterString ( ) , '{append}' => $ this -> buildAppendString ( ) , ] ; return strtr ( $ format , $ placeholderValues ) ; }
10056	public function getItem ( $ key ) { if ( $ this -> hasItem ( $ key ) !== true ) { $ this -> data [ $ key ] = new CacheItem ( $ key , null , false ) ; } return $ this -> data [ $ key ] ; }
12017	public function calculateRequestFilename ( Request $ request ) { $ string = $ request -> getUri ( ) ; $ filename = parse_url ( $ string , PHP_URL_HOST ) ; $ filename .= '_' . parse_url ( $ string , PHP_URL_PATH ) ; $ headers = $ request -> getAllHeaders ( ) ; ksort ( $ headers ) ; foreach ( $ headers as $ header => $ values ) { $ string .= $ header ; foreach ( $ values as $ value ) { $ string .= $ value ; } } $ filename .= '_' . sha1 ( $ string ) ; if ( strpos ( $ filename , '_' ) === 0 ) { $ filename = substr ( $ filename , 1 ) ; } return $ this -> cacheDirectory . '/' . $ filename . '.cache' ; }
3003	public function attachFile ( $ path , $ alias = null , $ cid = null ) { $ this -> smtp -> attach ( $ path , $ alias , $ cid ) ; }
9943	public function setCellValueExplicit ( $ pCoordinate , $ pValue , $ pDataType ) { $ this -> getCell ( $ pCoordinate ) -> setValueExplicit ( $ pValue , $ pDataType ) ; return $ this ; }
5955	public function channelPermList ( $ cid , $ permsid = false ) { return $ this -> execute ( "channelpermlist" , array ( "cid" => $ cid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
7805	protected function openingBalance ( $ text ) { if ( $ line = $ this -> getLine ( '60F|60M' , $ text ) ) { return $ this -> balance ( $ this -> reader -> createOpeningBalance ( ) , $ line ) ; } }
9277	public function renderRest ( $ request , $ data , $ statusCode = Response :: HTTP_OK , $ headers = [ ] ) { $ requestSerializer = $ this -> get ( 'ongr_api.request_serializer' ) ; return new Response ( $ requestSerializer -> serializeRequest ( $ request , $ data ) , $ statusCode , array_merge ( [ 'Content-Type' => 'application/' . $ requestSerializer -> checkAcceptHeader ( $ request ) ] , $ headers ) ) ; }
12366	public function getNextVideoToConvert ( ) { $ query = $ this -> createQueryBuilder ( 'v' ) ; $ this -> onlyUploaded ( $ query ) ; return $ query -> getQuery ( ) -> getOneOrNullResult ( ) ; }
12545	public function listen ( $ event , callable $ callback , $ priority = 100 ) { $ this -> event -> on ( $ event , $ callback , $ priority ) ; }
12619	protected function loadForeignDataItems ( ) { if ( ! $ this -> fileSource ) { \ d ( "boom" ) ; return false ; } $ foreignModelClass = $ this -> foreignModelClass ; $ lines = $ this -> fileSource -> getLines ( $ this -> lazyForeign ) ; $ lineCount = 0 ; foreach ( $ lines as $ id => $ line ) { if ( $ this -> lazyForeign ) { $ this -> createForeignDataItem ( null , [ 'deferredModel' => $ line ] ) ; } else { $ model = $ this -> createModel ( $ line -> id , $ line -> attributes ) ; $ this -> createForeignDataItem ( $ model , [ 'deferredModel' => $ line ] ) ; } $ lineCount ++ ; } $ this -> task -> addInfo ( "Processed {$lineCount} lines from {$this->fileSource->id}" ) ; }
1849	protected function generateLink ( $ strLink , $ objArticle , $ blnAddArchive = false , $ blnIsReadMore = false ) { if ( $ objArticle -> source != 'external' ) { return sprintf ( '<a href="%s" title="%s" itemprop="url"><span itemprop="headline">%s</span>%s</a>' , News :: generateNewsUrl ( $ objArticle , $ blnAddArchive ) , StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'readMore' ] , $ objArticle -> headline ) , true ) , $ strLink , ( $ blnIsReadMore ? '<span class="invisible"> ' . $ objArticle -> headline . '</span>' : '' ) ) ; } if ( substr ( $ objArticle -> url , 0 , 7 ) == 'mailto:' ) { $ strArticleUrl = StringUtil :: encodeEmail ( $ objArticle -> url ) ; } else { $ strArticleUrl = ampersand ( $ objArticle -> url ) ; } return sprintf ( '<a href="%s" title="%s"%s itemprop="url"><span itemprop="headline">%s</span></a>' , $ strArticleUrl , StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'open' ] , $ strArticleUrl ) ) , ( $ objArticle -> target ? ' target="_blank"' : '' ) , $ strLink ) ; }
709	public function string ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_STRING , $ length ) ; }
10757	public function totals ( $ locale = null ) { $ this -> setLocale ( $ locale ) ; $ totals = Collection :: make ( ) ; foreach ( Arr :: except ( $ this -> footer ( ) , 'all' ) as $ level => $ count ) { $ totals -> put ( $ level , [ 'label' => trans ( 'dashboard::logs.' . $ level ) , 'value' => $ count , 'color' => $ this -> color ( $ level ) , 'highlight' => $ this -> color ( $ level ) , ] ) ; } return $ totals ; }
3967	protected function getMetaModelByModelPid ( ModelInterface $ model ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; if ( $ metaModel === null ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ model -> getProperty ( 'pid' ) ) ; } return $ metaModel ; }
1133	public function setDefaultLeftAndRight ( ) { $ withHighestRight = $ this -> newNestedSetQuery ( ) -> reOrderBy ( $ this -> getRightColumnName ( ) , 'desc' ) -> take ( 1 ) -> sharedLock ( ) -> first ( ) ; $ maxRgt = 0 ; if ( ! is_null ( $ withHighestRight ) ) $ maxRgt = $ withHighestRight -> getRight ( ) ; $ this -> setAttribute ( $ this -> getLeftColumnName ( ) , $ maxRgt + 1 ) ; $ this -> setAttribute ( $ this -> getRightColumnName ( ) , $ maxRgt + 2 ) ; }
1895	private function addHtaccess ( string $ webDir ) : void { $ htaccess = __DIR__ . '/../Resources/skeleton/web/.htaccess' ; if ( ! file_exists ( $ webDir . '/.htaccess' ) ) { $ this -> fs -> copy ( $ htaccess , $ webDir . '/.htaccess' , true ) ; $ this -> io -> writeln ( 'Added the <comment>web/.htaccess</comment> file.' ) ; return ; } $ existingContent = file_get_contents ( $ webDir . '/.htaccess' ) ; if ( preg_match ( '/^\s*RewriteRule\s/im' , $ existingContent ) ) { return ; } $ this -> fs -> dumpFile ( $ webDir . '/.htaccess' , $ existingContent . "\n\n" . file_get_contents ( $ htaccess ) ) ; $ this -> io -> writeln ( 'Updated the <comment>web/.htaccess</comment> file.' ) ; }
981	public function planCharge ( ) { return $ this -> charges ( ) -> whereIn ( 'type' , [ Charge :: CHARGE_RECURRING , Charge :: CHARGE_ONETIME ] ) -> where ( 'plan_id' , $ this -> plan_id ) -> orderBy ( 'created_at' , 'desc' ) -> first ( ) ; }
7941	public function setBootDevice ( $ domain , $ currentState , $ bootDevice ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ domain = ( string ) $ domain ; if ( ! $ bootDevice ) throw new BadMethodCallException ( 'Parameter $bootDevice is missing.' ) ; $ bootDevice = ( string ) $ bootDevice ; $ payload = array ( 'bootId' => $ bootDevice , 'monitoring' => $ currentState -> monitoring , 'rootDevice' => $ currentState -> rootDevice ) ; try { $ r = $ this -> put ( 'dedicated/server/' . $ domain , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
3388	public function redirectAfterConfirmationPath ( ) { if ( method_exists ( $ this , 'redirectConfirmationTo' ) ) { return $ this -> redirectConfirmationTo ( ) ; } return property_exists ( $ this , 'redirectConfirmationTo' ) ? $ this -> redirectConfirmationTo : route ( 'login' ) ; }
7845	public function send ( array $ destinations , string $ text ) : ? array { $ this -> checkConfig ( ) ; $ messages = [ ] ; foreach ( $ destinations as $ destination ) { $ messages [ ] = [ 'phone_number' => $ destination , 'message' => $ text , 'device_id' => $ this -> device , ] ; } $ body = Body :: json ( $ messages ) ; $ response = Request :: post ( $ this -> baseUrl . 'message/send' , [ ] , $ body ) ; if ( $ response -> code == 200 ) { return [ 'code' => $ response -> code , 'message' => 'OK' , 'data' => $ response -> body , ] ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } return [ 'code' => $ response -> code , 'message' => $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } }
1636	protected function formatQuery ( $ sql , array $ bindings , $ time , $ connection ) { $ data = [ 'sql' => $ sql ] ; foreach ( $ bindings as $ index => $ binding ) { $ data [ "binding {$index}" ] = $ binding ; } $ data [ 'time' ] = "{$time}ms" ; $ data [ 'connection' ] = $ connection ; return $ data ; }
781	public function has ( $ name ) { return isset ( $ this -> _cookies [ $ name ] ) && $ this -> _cookies [ $ name ] -> value !== '' && ( $ this -> _cookies [ $ name ] -> expire === null || $ this -> _cookies [ $ name ] -> expire === 0 || $ this -> _cookies [ $ name ] -> expire >= time ( ) ) ; }
4482	public function setBacklog ( int $ backlog ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'backlog' , $ backlog ) ) { $ this -> backlog = $ backlog ; } }
12637	public static function connect ( string $ host = "" , int $ port = 0 , string $ dbname = "" , string $ user = "" , string $ pass = "" , bool $ reconnect = false ) : ? \ PDO { if ( self :: $ pdo !== null && ! $ reconnect ) return self :: $ pdo ; if ( $ host === "" && ( self :: $ databaseHost === null || self :: $ databaseHost === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid host name was not provided!" ) ; $ host = $ host ? : self :: $ databaseHost ; if ( $ port === 0 && ( self :: $ databasePort === null || self :: $ databasePort === 0 ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid port number was not provided!" ) ; $ port = $ port ? : self :: $ databasePort ; if ( $ dbname === "" && ( self :: $ databaseName === null || self :: $ databaseName === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid database name was not provided!" ) ; $ dbname = $ dbname ? : self :: $ databaseName ; if ( $ user === "" && ( self :: $ databaseUser === null || self :: $ databaseUser === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid username was not provided!" ) ; $ user = $ user ? : self :: $ databaseUser ; if ( $ pass === "" && ( self :: $ databasePass === null || self :: $ databasePass === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid password was not provided!" ) ; $ pass = $ pass ? : self :: $ databasePass ; try { self :: $ pdo = new \ PDO ( "pgsql:host=$host;port=$port;dbname=$dbname" , $ user , $ pass , [ \ PDO :: ATTR_DEFAULT_FETCH_MODE => \ PDO :: FETCH_ASSOC , ] ) ; if ( self :: $ pdo ) return self :: $ pdo ; } catch ( \ PDOException $ e ) { throw new Exceptions \ DatabaseConnectionException ( $ e -> getMessage ( ) ) ; } return null ; }
6753	public static function installWebServer ( ) { $ appPath = __DIR__ . '/../../../..' ; self :: createFolderIfNotExists ( "$appPath/web" ) ; self :: createCopy ( __DIR__ , 'app.php' , "$appPath/web" , 'app.php' ) ; self :: createCopy ( __DIR__ , 'app_dev.php' , "$appPath/web" , 'app_dev.php' ) ; }
1863	protected function validate ( ) { foreach ( \ func_get_args ( ) as $ strPath ) { if ( $ strPath == '' ) { throw new \ RuntimeException ( 'No file or folder name given' ) ; } elseif ( Validator :: isInsecurePath ( $ strPath ) ) { throw new \ RuntimeException ( 'Invalid file or folder name ' . $ strPath ) ; } } }
8003	public static function forCurrentSystem ( $ code = self :: CODE_FOR_SYSTEM , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . self :: MESSAGE_EXTENSION_FOR_SYSTEM ; return new static ( $ message , $ code , $ previous ) ; }
8133	public function setSourceContext ( Twig_Source $ source = null ) { if ( null === $ source ) { $ this -> sourceCode = $ this -> filename = $ this -> sourcePath = null ; } else { $ this -> sourceCode = $ source -> getCode ( ) ; $ this -> filename = $ source -> getName ( ) ; $ this -> sourcePath = $ source -> getPath ( ) ; } $ this -> updateRepr ( ) ; }
6654	public function getRequestToken ( $ settings , OAuthConsumerInterface $ consumer , OAuthTokenInterface $ token ) { $ url = $ settings [ 'auth_api_url' ] . $ settings [ 'request_token_uri' ] ; $ options = [ 'oauth_callback' => $ settings [ 'callback_url' ] ] ; $ headers = $ this -> headers ( $ settings , 'POST' , $ url , $ consumer , $ token , $ options ) ; $ request = [ 'url' => $ url , 'headers' => $ headers ] ; return $ this -> token -> makeRequestToken ( $ this -> http -> post ( $ request ) ) ; }
3378	private function showLink ( $ link ) { if ( ! $ link [ 'show_menu' ] ) return false ; $ user = \ Auth :: guard ( 'panel' ) -> user ( ) ; return $ user -> hasRole ( 'super' ) || $ user -> hasPermission ( '/' . $ link [ 'url' ] . '/all' ) ; }
5372	public function merge ( $ query ) { if ( is_object ( $ query ) ) { $ this -> request = array_merge ( $ this -> request , $ query -> getAll ( ) ) ; } elseif ( is_array ( $ query ) ) { foreach ( $ query as $ key => $ value ) { $ this -> add ( $ key , $ value ) ; } } }
5067	public function setOpt ( int $ option , $ value ) : bool { return curl_setopt ( $ this -> ch , $ option , $ value ) ; }
3097	protected function getItemData ( $ itemIdentifier ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemRef = $ this -> getRunnerService ( ) -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; $ itemData = $ this -> getRunnerService ( ) -> getItemData ( $ serviceContext , $ itemRef ) ; $ baseUrl = $ this -> getRunnerService ( ) -> getItemPublicUrl ( $ serviceContext , $ itemRef ) ; $ itemState = $ this -> getRunnerService ( ) -> getItemState ( $ serviceContext , $ itemIdentifier ) ; if ( $ itemState === null || ! count ( $ itemState ) ) { $ itemState = new stdClass ( ) ; } return [ 'baseUrl' => $ baseUrl , 'itemData' => $ itemData , 'itemState' => $ itemState , 'itemIdentifier' => $ itemIdentifier , ] ; }
2555	protected static function loadCorpNegoFare ( $ corporateNegoFare ) { $ opt = [ ] ; if ( $ corporateNegoFare !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_CORPORATE_NEGOTIATED_FARES ) ; $ po -> optionDetail = new OptionDetail ( $ corporateNegoFare ) ; $ opt [ ] = $ po ; } return $ opt ; }
5223	protected function getValueCreator ( $ value ) { if ( is_string ( $ value ) && class_exists ( $ value ) ) { return function ( $ injector ) use ( $ value ) { return $ injector -> getInstance ( $ value ) ; } ; } return function ( ) use ( $ value ) { return $ value ; } ; }
7521	function parse_asp ( ) { $ start = $ this -> pos ; if ( $ this -> next_pos ( '%>' , false ) !== self :: TOK_UNKNOWN ) { $ this -> pos -= 2 ; } $ len = $ this -> pos - 1 - $ start ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ start + 1 , $ len ) : '' ) ; $ this -> status [ 'last_pos' ] = ++ $ this -> pos ; return true ; }
4341	public function end ( ) { \ unregister_tick_function ( array ( $ this , 'tickFunction' ) ) ; while ( $ this -> funcStack ) { $ this -> popStack ( ) ; } \ uasort ( $ this -> data , function ( $ valA , $ valB ) { return ( $ valA [ 'totalTime' ] < $ valB [ 'totalTime' ] ) ? 1 : - 1 ; } ) ; $ data = \ array_map ( function ( $ row ) { $ row [ 'totalTime' ] = \ round ( $ row [ 'totalTime' ] , 6 ) ; $ row [ 'ownTime' ] = \ round ( $ row [ 'ownTime' ] , 6 ) ; return $ row ; } , $ this -> data ) ; $ this -> data = array ( ) ; $ this -> funcStack = array ( ) ; $ this -> isProfiling = false ; $ this -> rootStack = array ( ) ; return $ data ; }
11927	public function actionRunOne ( ) { $ this -> out ( "Run Interface " . $ this -> dataInterface -> object -> name , Console :: UNDERLINE , Console :: FG_GREEN ) ; $ this -> hr ( ) ; $ this -> dataInterface -> run ( null , new ConsoleAction ( ) ) ; }
4938	protected function getOptionsConfig ( $ fullName ) { if ( array_key_exists ( $ fullName , $ this -> optionsConfig ) ) { return $ this -> optionsConfig [ $ fullName ] ; } return false ; }
12241	public function addClass ( $ class ) { if ( ! $ this -> hasClass ( $ class ) ) { $ current = ( string ) $ this [ 'class' ] ; if ( $ current !== '' && substr ( $ current , - 1 ) !== ' ' ) { $ this [ 'class' ] .= ' ' ; } $ this [ 'class' ] .= $ class ; } return $ this ; }
3418	public static function registerEloquent ( ) { $ capsule = self :: bootstrapIlluminateDatabase ( ) ; class_alias ( Capsule :: class , 'DB' ) ; if ( $ _COOKIE [ "show_sql_stat" ] == "Y" ) { Capsule :: enableQueryLog ( ) ; $ em = \ Bitrix \ Main \ EventManager :: getInstance ( ) ; $ em -> addEventHandler ( 'main' , 'OnAfterEpilog' , [ IlluminateQueryDebugger :: class , 'onAfterEpilogHandler' ] ) ; } static :: addEventListenersForHelpersHighloadblockTables ( $ capsule ) ; }
10788	protected function getSearchFacets ( SessionInterface $ session ) { $ facets = $ session -> get ( $ this -> getSessionPrefix ( ) . '_facets' , false ) ; return $ facets ? \ json_decode ( $ facets , true ) : $ this -> getDefaultFacets ( ) ; }
10835	private function compileOn ( array $ join ) { $ sql = array ( ) ; list ( $ on , $ table , $ type , $ c1 , $ op , $ c2 ) = $ join ; if ( $ type !== null ) { $ sql [ ] = $ type ; } array_push ( $ sql , "JOIN" , $ table , "ON" , $ c1 , $ op , $ c2 ) ; return join ( ' ' , $ sql ) ; }
3180	public function useClientContainer ( ) { if ( $ this -> hasOption ( self :: OPTION_CLIENT_TESTRUNNER ) ) { return $ this -> getOption ( self :: OPTION_CLIENT_TESTRUNNER ) ; } else { $ itemModel = $ this -> getServiceLocator ( ) -> get ( ItemModel :: SERVICE_ID ) ; return $ itemModel -> getCompilerClass ( ) == QtiJsonItemCompiler :: class ; } }
8836	public function setMaxRetries ( $ retries ) { switch ( gettype ( $ retries ) ) { case 'integer' : $ this -> maxRetries = new Retries ( $ retries ) ; break ; case 'object' : $ this -> maxRetries = $ retries ; break ; default : throw new InvalidArgumentException ( 'Invalid type for max retries given.' ) ; break ; } }
10464	private function deductionForDeletion ( $ connection , $ tableName , $ documentType , $ documentId , $ shopId ) { $ sql = sprintf ( "SELECT `id` FROM {$tableName} WHERE `type` != 'D' AND `document_type` = :documentType AND `document_id` = :documentId AND `status` = :status AND `id` < :id" ) ; $ statement = $ connection -> prepare ( $ sql ) ; $ statement -> execute ( [ 'documentType' => $ documentType , 'documentId' => $ documentId , 'status' => self :: STATUS_NEW , 'id' => $ connection -> lastInsertId ( ) , ] ) ; $ entries = $ statement -> fetchAll ( ) ; foreach ( $ entries as $ entry ) { $ this -> removeRecord ( $ entry [ 'id' ] , [ $ shopId ] ) ; } }
3088	public function isAssessmentSectionAdaptive ( AssessmentSection $ section ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; return count ( $ assessmentItemRefs ) === 1 && $ this -> isAdaptivePlaceholder ( $ assessmentItemRefs [ 0 ] ) ; }
2863	public function getLogging ( ) { $ logging = array ( ) ; foreach ( $ this -> files as $ logFile ) { $ logging [ $ logFile ] = $ this -> getLoggedContent ( $ logFile ) ; } return $ logging ; }
4679	public function set ( $ template , $ data = [ ] , $ sort = 0 , $ type = "file" ) { if ( empty ( $ template ) ) { $ type = "empty" ; } elseif ( is_array ( $ template ) ) { if ( isset ( $ template [ "callback" ] ) ) { $ type = "callback" ; $ this -> template = $ template [ "callback" ] ; } else { $ this -> template = $ template [ "template" ] ; } $ this -> sortOrder = $ template [ "sort" ] ?? $ sort ; $ this -> type = $ template [ "type" ] ?? $ type ; $ data1 = $ template [ "data" ] ?? [ ] ; if ( empty ( $ data ) ) { $ this -> templateData = $ data1 ; } else if ( empty ( $ data1 ) ) { $ this -> templateData = $ data ; } else { foreach ( $ data as $ key => $ val ) { if ( is_array ( $ val ) ) { if ( ! array_key_exists ( $ key , $ data1 ) ) { $ data1 [ $ key ] = [ ] ; } $ data1 [ $ key ] = array_merge ( $ data1 [ $ key ] , $ val ) ; } else { $ data1 [ $ key ] = $ val ; } $ this -> templateData = $ data1 ; } } return ; } $ this -> template = $ template ; $ this -> templateData = $ data ; $ this -> sortOrder = $ sort ; $ this -> type = $ type ; return $ this ; }
8749	public function loadFromRegistry ( Registry $ registry ) { foreach ( $ registry as $ key => $ serviceProvider ) { $ this -> loadServiceProviderFactories ( $ serviceProvider , $ key ) ; } foreach ( $ registry as $ key => $ serviceProvider ) { $ this -> loadServiceProviderExtensions ( $ serviceProvider , $ key ) ; } }
5714	protected function filterFieldList ( Form $ form , FieldList $ actions ) { $ list = FieldList :: create ( ) ; foreach ( $ actions as $ a ) { if ( ! $ a instanceof BetterButtonInterface ) { throw new Exception ( "{$buttonObj->class} must implement BetterButtonInterface" ) ; } $ a -> bindGridField ( $ form , $ this -> owner ) ; if ( ! $ a -> shouldDisplay ( ) ) { continue ; } if ( ( $ a instanceof BetterButton_Versioned ) && ! $ this -> owner -> record -> checkVersioned ( ) ) { continue ; } $ list -> push ( $ a ) ; } return $ list ; }
1437	public static function classify ( $ value ) { if ( isset ( self :: $ classified [ $ value ] ) ) { return self :: $ classified [ $ value ] ; } $ converted = ucwords ( str_replace ( [ '-' , '_' ] , ' ' , $ value ) ) ; return self :: $ classified [ $ value ] = str_replace ( ' ' , '' , $ converted ) ; }
6283	protected static function buildHttpClient04 ( LoopInterface $ loop , $ dns = null ) { if ( null === $ dns ) { $ dns = static :: buildDnsResolver ( $ loop ) ; } if ( ! $ dns instanceof DnsResolver ) { throw new \ InvalidArgumentException ( 'For react http client v0.4, $dns must be an instance of DnsResolver' ) ; } $ factory = new HttpClientFactory ( ) ; return $ factory -> create ( $ loop , $ dns ) ; }
5944	public function categories ( $ categoryIds , $ deploymentSiteIds = null , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/categories/' . $ categoryIds . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5035	public function setFrom ( $ email , $ name = null ) { if ( is_array ( $ email ) ) { $ this -> from = [ $ email [ 'email' ] => $ email [ 'name' ] ] ; } else { $ this -> from = is_object ( $ email ) || null === $ name ? $ email : array ( $ email => $ name ) ; } return $ this ; }
12653	public function getTextsWithBaseTexts ( $ language ) { $ texts = $ this -> getPageTexts ( $ language ) ; if ( $ language !== $ this -> baseLang ) { $ baseTexts = $ this -> getPageTexts ( $ this -> baseLang ) ; $ texts = array_map ( function ( $ text , $ baseText ) { return $ text + array ( "basecontent" => $ baseText [ 'content' ] ) ; } , $ texts , $ baseTexts ) ; } return $ texts ; }
2779	public function git ( string $ commandLine , ? string $ cwd = null ) : string { $ command = new GitCommand ( $ commandLine ) ; $ command -> executeRaw ( is_string ( $ commandLine ) ) ; $ command -> setDirectory ( $ cwd ) ; return $ this -> run ( $ command ) ; }
7262	protected function assertAdjustmentMode ( Model \ AdjustmentInterface $ adjustment , string $ expected ) : void { if ( $ expected !== $ mode = $ adjustment -> getMode ( ) ) { throw new Exception \ InvalidArgumentException ( "Unexpected adjustment mode '$mode'." ) ; } }
9646	public function build ( ) : Route { return new $ this -> routeClass ( $ this -> methods , $ this -> path , $ this -> target , $ this -> matchers , $ this -> name ) ; }
8239	public function setAuthenticated ( $ v ) { if ( ! $ v ) { $ this -> authenticator = null ; } $ this -> authenticated = $ v ; return $ this ; }
6526	public static function resolveId ( SchemaId $ id ) : string { $ curieMajor = $ id -> getCurieMajor ( ) ; if ( isset ( self :: $ curies [ $ curieMajor ] ) ) { return self :: $ classes [ self :: $ curies [ $ curieMajor ] ] ; } $ curie = $ id -> getCurie ( ) -> toString ( ) ; if ( isset ( self :: $ curies [ $ curie ] ) ) { return self :: $ classes [ self :: $ curies [ $ curie ] ] ; } throw new NoMessageForSchemaId ( $ id ) ; }
11154	public function getArrayKeyByPowers ( array $ powers ) { if ( empty ( $ powers ) ) { throw new InvalidArgumentException ( 'Empty powers set' ) ; } $ powersSum = 0 ; foreach ( $ powers as $ power ) { if ( $ power < 0 ) { throw new InvalidArgumentException ( 'Negative power found' ) ; } $ powersSum += $ power ; } if ( $ powersSum <= 0 ) { throw new InvalidArgumentException ( 'The sum of powers must be positive' ) ; } $ randomValue = $ this -> generator -> getFloat ( 0 , $ powersSum ) ; $ currentSum = 0 ; $ result = null ; foreach ( $ powers as $ key => $ power ) { $ currentSum += $ power ; if ( $ currentSum >= $ randomValue ) { $ result = $ key ; break ; } } return $ key ; }
7752	protected function completeMetadata ( ClassMetadata $ class ) { $ className = $ class -> getName ( ) ; if ( null === $ class -> getIri ( ) ) { $ class -> setIri ( $ this -> namingStrategy -> classIriFragment ( $ className ) ) ; } if ( null === $ class -> getExposeAs ( ) ) { $ class -> setExposeAs ( $ this -> namingStrategy -> classShortName ( $ className ) ) ; } if ( null === $ class -> getTitle ( ) ) { $ class -> setTitle ( $ this -> namingStrategy -> classShortName ( $ className ) ) ; } foreach ( $ class -> getProperties ( ) as $ property ) { $ propertyName = $ property -> getName ( ) ; if ( null === $ property -> getIri ( ) ) { $ property -> setIri ( $ this -> namingStrategy -> propertyIriFragment ( $ className , $ propertyName ) ) ; } if ( null === $ property -> getExposeAs ( ) ) { $ property -> setExposeAs ( $ this -> namingStrategy -> propertyShortName ( $ className , $ propertyName ) ) ; } if ( null === $ property -> getTitle ( ) ) { $ property -> setTitle ( $ this -> namingStrategy -> propertyShortName ( $ className , $ propertyName ) ) ; } } }
12379	public function handle ( ) : void { $ help = " -----------------------------------------------------------------\n" ; $ help .= " | Command Line Interface\n" ; $ help .= " | See more in https://github.com/senhungwong/command-line-interface\n" ; $ help .= " -------------------------------------------------------------------\n" ; $ commands = CommandEntry :: getCommands ( ) ; if ( $ command = $ this -> getArgument ( 'function-name' ) ) { $ command = new $ commands [ $ command ] ; $ help .= " - " . $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } else { foreach ( $ commands as $ command ) { $ command = new $ command ; $ help .= " - " ; $ help .= $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } } echo $ help ; }
6488	protected function getClientIPAddress ( array $ server ) : ? string { $ serverRemoteAddress = $ server [ 'REMOTE_ADDR' ] ?? null ; if ( $ this -> isUsingTrustedProxy ( $ server ) ) { return $ serverRemoteAddress ?? null ; } $ ipAddresses = [ ] ; if ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ) ) { $ header = $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ; preg_match_all ( "/for=(?:\"?\[?)([a-z0-9:\.\-\/_]*)/" , $ header , $ matches ) ; $ ipAddresses = $ matches [ 1 ] ; } elseif ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ) { $ ipAddresses = explode ( ',' , $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ; $ ipAddresses = array_map ( 'trim' , $ ipAddresses ) ; } if ( $ serverRemoteAddress !== null ) { $ ipAddresses [ ] = $ serverRemoteAddress ; } $ fallbackIPAddresses = count ( $ ipAddresses ) === 0 ? [ ] : [ $ ipAddresses [ 0 ] ] ; foreach ( $ ipAddresses as $ index => $ ipAddress ) { if ( filter_var ( $ ipAddress , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) === false ) { unset ( $ ipAddresses [ $ index ] ) ; } if ( in_array ( $ ipAddress , $ this -> trustedProxyIPAddresses , true ) ) { unset ( $ ipAddresses [ $ index ] ) ; } } $ clientIPAddresses = count ( $ ipAddresses ) === 0 ? $ fallbackIPAddresses : array_reverse ( $ ipAddresses ) ; return $ clientIPAddresses [ 0 ] ?? null ; }
10162	private function readSelection ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ paneId = ord ( $ recordData [ 0 ] ) ; $ r = self :: getUInt2d ( $ recordData , 1 ) ; $ c = self :: getUInt2d ( $ recordData , 3 ) ; $ index = self :: getUInt2d ( $ recordData , 5 ) ; $ data = substr ( $ recordData , 7 ) ; $ cellRangeAddressList = $ this -> readBIFF5CellRangeAddressList ( $ data ) ; $ selectedCells = $ cellRangeAddressList [ 'cellRangeAddresses' ] [ 0 ] ; if ( preg_match ( '/^([A-Z]+1\:[A-Z]+)16384$/' , $ selectedCells ) ) { $ selectedCells = preg_replace ( '/^([A-Z]+1\:[A-Z]+)16384$/' , '${1}1048576' , $ selectedCells ) ; } if ( preg_match ( '/^([A-Z]+1\:[A-Z]+)65536$/' , $ selectedCells ) ) { $ selectedCells = preg_replace ( '/^([A-Z]+1\:[A-Z]+)65536$/' , '${1}1048576' , $ selectedCells ) ; } if ( preg_match ( '/^(A\d+\:)IV(\d+)$/' , $ selectedCells ) ) { $ selectedCells = preg_replace ( '/^(A\d+\:)IV(\d+)$/' , '${1}XFD${2}' , $ selectedCells ) ; } $ this -> phpSheet -> setSelectedCells ( $ selectedCells ) ; } }
4505	public function getList ( Parameters $ parameters = null ) : array { $ options = [ ] ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; if ( array_key_exists ( 'organizationUuid' , $ options [ 'query' ] ) ) { $ options [ 'query' ] [ 'organization.uuid' ] = $ options [ 'query' ] [ 'organizationUuid' ] ; unset ( $ options [ 'query' ] [ 'organizationUuid' ] ) ; } } $ objects = $ this -> execute ( 'GET' , static :: RESOURCE_LIST , $ options ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
8608	public function registerDestination ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_RegisterDestinationInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/RegisterDestinationInput.php' ) ; $ request = new MWSSubscriptionsService_Model_RegisterDestinationInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'RegisterDestination' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/RegisterDestinationResponse.php' ) ; $ response = MWSSubscriptionsService_Model_RegisterDestinationResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12242	public function asPrettyXML ( $ filepath = null ) { $ xml = dom_import_simplexml ( new SimpleXMLElement ( $ this -> asXML ( ) ) ) ; $ xsl = new DOMDocument ; $ xsl -> loadXML ( '<?xml version="1.0" encoding="utf-8"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="xml" indent="yes" /> <xsl:template match="text()"> <!-- remove everything that contains only whitespace, with at least one LF ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; $ result = trim ( $ xslt -> transformToXML ( $ xml ) ) ; if ( isset ( $ filepath ) ) { return ( bool ) file_put_contents ( $ filepath , $ result ) ; } return $ result ; }
7345	public function modifySubmitedValueBeforeValidation ( $ value , array $ data ) { if ( $ this -> hasSubmittedValueModifier ( ) ) { return call_user_func ( $ this -> getSubmittedValueModifier ( ) , $ value , $ data ) ; } else { return $ value ; } }
12282	private function stopCustomProcess ( ) : void { if ( $ this -> isCustomProcessSet ( ) ) { $ this -> getCustomProcess ( ) -> stop ( ) ; } elseif ( class_exists ( '\extensions\core\Process' ) ) { \ extensions \ core \ Process :: getInstance ( ) -> stop ( ) ; } }
12480	protected function findSlotsInTemplates ( ) { $ templates = $ this -> findTemplates ( ) ; $ slots = array ( ) ; foreach ( $ templates [ "base" ] as $ templateName => $ templateFile ) { $ templateContents = FilesystemTools :: readFile ( $ templateFile ) ; $ slots = array_merge_recursive ( $ slots , $ this -> findSlots ( $ templateName , $ templateContents ) ) ; } $ baseSlots [ "base" ] = $ slots ; $ slots = array ( ) ; foreach ( $ templates [ "template" ] as $ templateName => $ templateFile ) { $ templateContents = FilesystemTools :: readFile ( $ templateFile ) ; $ slots [ $ templateName ] = $ this -> findSlots ( $ templateName , $ templateContents ) ; } return array ( 'base' => $ baseSlots , 'templates' => $ slots , ) ; }
3109	public function getCatValue ( $ assessmentSectionId , $ key ) { return ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) ? $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] : null ; }
6302	protected function getBar ( $ name = 'default' ) { $ this -> events -> fire ( 'navigation.bar' , [ [ 'name' => $ name ] ] ) ; if ( $ name !== 'default' && ! array_key_exists ( $ name , $ this -> bar ) ) { $ name = 'default' ; } if ( ! array_key_exists ( $ name , $ this -> bar ) ) { $ this -> bar [ $ name ] = [ ] ; } $ nav = $ this -> bar [ $ name ] ; return $ this -> process ( $ nav ) ; }
2449	public function editComment ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> isAllowedToEditComment ( $ row [ 'parent' ] , $ row [ 'source' ] ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg/i' , '_.svg' , $ icon ) ) . ' ' ; }
7104	public static function title ( $ title , $ separator = '-' , $ ascii_only = FALSE ) { if ( $ ascii_only === TRUE ) { $ title = UTF8 :: transliterate_to_ascii ( $ title ) ; $ title = preg_replace ( '![^' . preg_quote ( $ separator ) . 'a-z0-9\s]+!' , '' , strtolower ( $ title ) ) ; } else { $ title = preg_replace ( '![^' . preg_quote ( $ separator ) . '\pL\pN\s]+!u' , '' , UTF8 :: strtolower ( $ title ) ) ; } $ title = preg_replace ( '![' . preg_quote ( $ separator ) . '\s]+!u' , $ separator , $ title ) ; return trim ( $ title , $ separator ) ; }
10321	function getUnsubscribersCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ source = null ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source ) ; return $ this -> get ( 'reports/unsubscriptions/count' , $ params ) ; }
8089	static protected function encode ( $ number ) { $ k = self :: $ encoder ; preg_match_all ( "/[1-9][0-9]|[0-9]/" , $ number , $ a ) ; $ n = '' ; $ o = count ( $ k ) ; foreach ( $ a [ 0 ] as $ i ) { if ( $ i < $ o ) { $ n .= $ k [ $ i ] ; } else { $ n .= '1' . $ k [ $ i - $ o ] ; } } return $ n ; }
10228	private function resolveModelName ( $ model ) { if ( $ model instanceof Controller ) { $ exploded = explode ( '\\' , get_class ( $ model ) ) ; $ controllerName = array_pop ( $ exploded ) ; return str_singular ( str_replace ( 'Controller' , '' , $ controllerName ) ) ; } else if ( $ model instanceof Eloquent ) { return get_class ( $ model ) ; } else { return $ model ; } }
8841	public function generateURLSegment ( $ increment = null ) { $ filter = new URLSegmentFilter ( ) ; $ this -> owner -> URLSegment = $ filter -> filter ( $ this -> owner -> Title ) ; if ( is_int ( $ increment ) ) $ this -> owner -> URLSegment .= '-' . $ increment ; $ duplicate = DataList :: create ( $ this -> owner -> ClassName ) -> filter ( array ( "URLSegment" => $ this -> owner -> URLSegment , "BlogID" => $ this -> owner -> BlogID ) ) ; if ( $ this -> owner -> ID ) $ duplicate = $ duplicate -> exclude ( "ID" , $ this -> owner -> ID ) ; if ( $ duplicate -> count ( ) > 0 ) { $ increment = is_int ( $ increment ) ? $ increment + 1 : 0 ; $ this -> owner -> generateURLSegment ( ( int ) $ increment ) ; } return $ this -> owner -> URLSegment ; }
6439	public function getUserProfile ( ) { $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] , $ this -> access_token [ 'oauth_token' ] , $ this -> access_token [ 'oauth_token_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ user = $ connection -> get ( "account/verify_credentials" ) ; return array ( 'userid' => $ user -> id , 'name' => $ user -> screen_name , 'imageurl' => $ user -> profile_image_url ) ; }
361	public function renderErrors ( ) { if ( $ this -> filterModel instanceof Model && $ this -> filterModel -> hasErrors ( ) ) { return Html :: errorSummary ( $ this -> filterModel , $ this -> filterErrorSummaryOptions ) ; } return '' ; }
11333	public function setFormat ( $ value ) { if ( is_array ( $ value ) ) { if ( ! isset ( $ value [ 'class' ] ) ) { $ value [ 'class' ] = $ this -> determineFormatClass ( ) ; } $ value [ 'field' ] = $ this ; $ value = Yii :: createObject ( $ value ) ; } $ this -> _format = $ value ; }
5279	protected function generateWhere ( $ column , $ param1 = null , $ param2 = null , $ type = 'and' ) { if ( is_null ( $ param2 ) ) { $ param2 = $ param1 ; $ param1 = '=' ; } if ( is_array ( $ param2 ) ) { $ param2 = $ this -> esc_array ( array_unique ( $ param2 ) ) ; if ( in_array ( $ param1 , array ( 'between' , 'not between' ) ) ) { $ param2 = join ( ' and ' , $ param2 ) ; } else { $ param2 = '(' . join ( ', ' , $ param2 ) . ')' ; } } elseif ( is_scalar ( $ param2 ) ) { $ param2 = $ this -> esc_value ( $ param2 ) ; } return join ( ' ' , array ( $ type , $ column , $ param1 , $ param2 ) ) ; }
4186	public function search ( ) { $ url = self :: PACKAGIST_URL . 'search.json?q=' . $ this -> getPackageName ( ) ; $ response = $ this -> client -> get ( $ url ) -> getBody ( ) -> getContents ( ) ; $ this -> rawPackages = collect ( json_decode ( $ response , true ) ) ; return collect ( $ this -> rawPackages -> get ( 'results' ) ) ; }
3593	public static function setFakeMacAddress ( $ interface , $ mac = null ) { if ( ! self :: validateMacAddress ( $ mac ) ) { $ mac = self :: generateMacAddress ( ) ; } self :: runCommand ( "ifconfig {$interface} down" ) ; self :: runCommand ( "ifconfig {$interface} hw ether {$mac}" ) ; self :: runCommand ( "ifconfig {$interface} up" ) ; self :: runCommand ( "dhclient {$interface}" ) ; if ( self :: getCurrentMacAddress ( $ interface ) == $ mac ) { return true ; } return false ; }
1305	public function index ( ) { $ discussions = Discussion :: limit ( 20 ) -> orderBy ( 'created_at' , 'DESC' ) -> get ( ) ; $ discussions -> load ( [ 'user' , 'posts' ] ) ; $ xml = new SimpleXMLElement ( '<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" xml:lang="en-US"/>' ) ; $ xml -> addChild ( 'id' , route ( 'chatter.home' ) ) ; $ link = $ xml -> addChild ( 'link' ) ; $ link -> addAttribute ( 'type' , 'text/html' ) ; $ link -> addAttribute ( 'href' , route ( 'chatter.home' ) ) ; $ link = $ xml -> addChild ( 'link' ) ; $ link -> addAttribute ( 'type' , 'application/atom+xml' ) ; $ link -> addAttribute ( 'rel' , 'self' ) ; $ link -> addAttribute ( 'href' , route ( 'chatter.atom' ) ) ; $ xml -> addChild ( 'title' , config ( 'app.name' ) . ' Discussions' ) ; $ updated = count ( $ discussions ) ? Carbon :: parse ( $ discussions [ 0 ] -> created_at ) : Carbon :: now ( ) ; $ xml -> addChild ( 'updated' , $ updated -> toAtomString ( ) ) ; foreach ( $ discussions as $ discussion ) { $ child = $ xml -> addChild ( 'entry' ) ; $ child -> addChild ( 'id' , route ( 'chatter.discussion.show' , [ 'discussion' => $ discussion -> slug ] ) ) ; $ child -> addChild ( 'title' , $ discussion -> title ) ; $ link = $ child -> addChild ( 'link' ) ; $ link -> addAttribute ( 'type' , 'text/html' ) ; $ link -> addAttribute ( 'rel' , 'alternate' ) ; $ link -> addAttribute ( 'href' , route ( 'chatter.discussion.show' , [ 'discussion' => $ discussion -> slug ] ) ) ; $ child -> addChild ( 'updated' , Carbon :: parse ( $ discussion -> created_at ) -> toAtomString ( ) ) ; $ author = $ child -> addChild ( 'author' ) ; $ author -> addChild ( 'name' , $ discussion -> user -> name ) ; $ content = $ child -> addChild ( 'content' , htmlentities ( count ( $ discussion -> posts ) ? $ discussion -> posts [ 0 ] -> body : '' ) ) ; $ content -> addAttribute ( 'type' , 'html' ) ; } return response ( $ xml -> asXML ( ) , 200 , [ 'Content-Type' => 'application/atom+xml' , ] ) ; }
2044	public static function create ( array $ parameters ) : ? Connection { $ params = [ 'driver' => 'pdo_mysql' , 'host' => $ parameters [ 'parameters' ] [ 'database_host' ] , 'port' => $ parameters [ 'parameters' ] [ 'database_port' ] , 'user' => $ parameters [ 'parameters' ] [ 'database_user' ] , 'password' => $ parameters [ 'parameters' ] [ 'database_password' ] , 'dbname' => $ parameters [ 'parameters' ] [ 'database_name' ] , ] ; try { return DriverManager :: getConnection ( $ params ) ; } catch ( DBALException $ e ) { } return null ; }
10829	public static function dir ( string $ path ) : fs \ entity \ DirEntity { return ( new fs \ entity \ DirEntity ( $ path ) ) -> normalize ( ) ; }
3710	protected function getFilters ( ) { $ filterOptions = $ this -> getFrontendFilterOptions ( ) ; $ jumpToInformation = $ this -> objFilterConfig -> getJumpTo ( ) ; $ filterSetting = $ this -> objFilterConfig -> getFilterCollection ( ) ; $ wantedNames = $ this -> getWantedNames ( ) ; $ this -> buildParameters ( $ other = new FilterUrl ( $ jumpToInformation ) , $ all = new FilterUrl ( $ jumpToInformation ) , $ wantedNames ) ; foreach ( $ wantedNames as $ name ) { if ( $ all -> hasSlug ( $ name ) ) { Input :: get ( $ name ) ; } } $ arrWidgets = $ filterSetting -> getParameterFilterWidgets ( $ all -> getSlugParameters ( ) , $ jumpToInformation , $ filterOptions ) ; if ( Input :: post ( 'FORM_SUBMIT' ) === $ this -> formId ) { foreach ( $ wantedNames as $ widgetName ) { $ filter = $ arrWidgets [ $ widgetName ] ; if ( null !== $ filter [ 'urlvalue' ] ) { $ other -> setSlug ( $ widgetName , $ filter [ 'urlvalue' ] ) ; } } throw new RedirectResponseException ( $ this -> filterUrlBuilder -> generate ( $ other ) ) ; } $ renderedWidgets = [ ] ; foreach ( $ wantedNames as $ strWidget ) { $ renderedWidgets [ $ strWidget ] = $ this -> renderWidget ( $ arrWidgets [ $ strWidget ] , $ filterOptions ) ; } return [ 'action' => $ this -> filterUrlBuilder -> generate ( $ other ) , 'formid' => $ this -> formId , 'filters' => $ renderedWidgets , 'submit' => ( $ filterOptions -> isAutoSubmit ( ) ? '' : $ GLOBALS [ 'TL_LANG' ] [ 'metamodels_frontendfilter' ] [ 'submit' ] ) ] ; }
4886	public function plugin ( $ plugin , $ options = null ) { $ renderer = $ this -> getView ( ) ; if ( ! method_exists ( $ renderer , 'getHelperPluginManager' ) ) { return true === $ options ? false : new HelperProxy ( false ) ; } $ manager = $ renderer -> getHelperPluginManager ( ) ; $ hasPlugin = $ manager -> has ( $ plugin ) ; if ( true === $ options ) { return $ hasPlugin ; } if ( $ hasPlugin ) { $ pluginInstance = $ manager -> get ( $ plugin , $ options ) ; } else { $ pluginInstance = false ; } return new HelperProxy ( $ pluginInstance ) ; }
4190	protected function dumpMethods ( $ methods ) { $ label = \ count ( $ methods ) ? 'methods' : 'no methods' ; $ str = '<dt class="methods">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__call' , '__callStatic' ) , \ array_keys ( $ methods ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ methods as $ methodName => $ info ) { if ( ! isset ( $ info [ 'phpDoc' ] [ 'return' ] ) ) { $ info [ 'phpDoc' ] [ 'return' ] = array ( 'desc' => null , 'type' => null , ) ; } $ classes = \ array_keys ( \ array_filter ( array ( 'method' => true , 'deprecated' => $ info [ 'isDeprecated' ] , ) ) ) ; $ modifiers = \ array_keys ( \ array_filter ( array ( 'final' => $ info [ 'isFinal' ] , $ info [ 'visibility' ] => true , 'static' => $ info [ 'isStatic' ] , ) ) ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'dd' , array ( 'class' => \ array_merge ( $ classes , $ modifiers ) , 'data-implements' => $ info [ 'implements' ] , ) , \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ' ' . $ this -> debug -> utilities -> buildTag ( 'span' , array ( 'class' => 't_type' , 'title' => $ info [ 'phpDoc' ] [ 'return' ] [ 'desc' ] , ) , $ info [ 'phpDoc' ] [ 'return' ] [ 'type' ] ) . ' ' . $ this -> debug -> utilities -> buildTag ( 'span' , array ( 'class' => 'method-name' , 'title' => \ trim ( $ info [ 'phpDoc' ] [ 'summary' ] . ( $ this -> debug -> output -> getCfg ( 'outputMethodDescription' ) ? "\n\n" . $ info [ 'phpDoc' ] [ 'description' ] : '' ) ) , ) , $ methodName ) . '<span class="t_punct">(</span>' . $ this -> dumpMethodParams ( $ info [ 'params' ] ) . '<span class="t_punct">)</span>' . ( $ methodName == '__toString' ? '<br />' . $ this -> debug -> output -> html -> dump ( $ info [ 'returnValue' ] ) : '' ) ) . "\n" ; } $ str = \ str_replace ( ' data-implements="null"' , '' , $ str ) ; $ str = \ str_replace ( ' <span class="t_type"></span>' , '' , $ str ) ; return $ str ; }
1817	public function deleteElement ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objElement = $ this -> Database -> prepare ( "SELECT id FROM tl_content WHERE cteAlias=? AND type='alias'" ) -> limit ( 1 ) -> execute ( $ row [ 'id' ] ) ; return $ objElement -> numRows ? Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' : '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; }
8855	public function getArchiveDate ( ) { $ year = $ this -> getArchiveYear ( ) ; $ month = $ this -> getArchiveMonth ( ) ; $ day = $ this -> getArchiveDay ( ) ; if ( $ year ) { if ( $ month ) { $ date = $ year . '-' . $ month . '-01' ; if ( $ day ) { $ date = $ year . '-' . $ month . '-' . $ day ; } } else { $ date = $ year . '-01-01' ; } return DBField :: create_field ( "Date" , $ date ) ; } }
8809	public function delete ( $ key ) { if ( $ this -> has ( $ key ) ) { setcookie ( $ key , null , - 1 , '/' ) ; unset ( $ _COOKIE [ $ key ] ) ; } return ; }
7984	public function getCurrentMonitoring ( $ domain , $ type ) { $ type = strtolower ( $ type ) ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! in_array ( $ type , array ( 'cpu:max' , 'cpu:used' , 'mem:max' , 'mem:used' , 'net:rx' , 'net:tx' ) ) ) throw new BadMethodCallException ( 'Parameter $type must be "cpu:max" or "cpu:used" or "mem:max" or "mem:used" or "net:rx" or "net:tx". "' . $ type . '" given.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/use?type=' . $ type ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
6597	protected function getDescription ( array $ lines ) { $ description = '' ; $ summaryFound = false ; $ summaryPassed = false ; foreach ( $ lines as $ line ) { if ( $ line && ! $ summaryPassed ) { $ summaryFound = true ; if ( substr ( trim ( $ line ) , - 1 ) == '.' ) { $ summaryPassed = true ; } continue ; } if ( ! $ line && $ summaryFound && ! $ summaryPassed ) { $ summaryPassed = true ; continue ; } if ( $ line && $ line [ 0 ] == '@' ) { break ; } if ( $ line && $ summaryPassed ) { $ description .= $ line . "\n" ; } } return trim ( $ description ) ; }
9827	public function setPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> password = $ pValue ; return $ this ; }
2461	private function canonicalize ( string $ value ) : string { $ resolved = [ ] ; $ chunks = preg_split ( '#([\\\\/]+)#' , $ value , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; for ( $ i = 0 , $ c = \ count ( $ chunks ) ; $ i < $ c ; ++ $ i ) { if ( '.' === $ chunks [ $ i ] ) { ++ $ i ; continue ; } if ( '/' === $ chunks [ $ i ] [ 0 ] ) { $ resolved [ ] = '/' ; continue ; } if ( '\\' === $ chunks [ $ i ] [ 0 ] ) { $ resolved [ ] = '\\' ; continue ; } if ( '..' === $ chunks [ $ i ] ) { ++ $ i ; array_pop ( $ resolved ) ; array_pop ( $ resolved ) ; continue ; } $ resolved [ ] = $ chunks [ $ i ] ; } return rtrim ( implode ( '' , $ resolved ) , '\/' ) ; }
11474	public function setObject ( $ object ) { if ( is_null ( $ this -> _objectType ) ) { $ this -> objectType = $ object -> objectType ; } $ this -> _object = $ object ; }
12901	private function addSource ( array $ arguments = array ( ) ) { $ this -> builder -> addSource ( array_key_exists ( 'cache' , $ this -> source ) ? $ this -> createCacheAdapter ( ) : new HttpApiAdapter ( ) , new Request ( array ( 'source' => $ this -> source , 'arguments' => $ arguments , 'service' => $ this -> getGroup ( ) -> getService ( ) -> getName ( ) , 'group' => $ this -> getGroup ( ) -> getName ( ) , 'action' => $ this -> getName ( ) , ) ) ) ; }
4773	public function order ( Request $ request , WidgetInterface $ widget , string $ widgetId , int $ order ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'order' => $ order ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> json ( [ 'result' => 'success' , ] ) ; }
10687	private function setCreatePermissions ( ) { if ( $ this -> config -> has ( 'io' , 'group' ) ) Path :: setDefaultFileGroup ( $ this -> config -> get ( 'io' , 'group' ) ) ; $ file_mode = ( int ) $ this -> config -> get ( 'io' , 'file_mode' ) ; if ( $ file_mode ) { $ of = $ file_mode ; $ file_mode = octdec ( sprintf ( "%04d" , $ file_mode ) ) ; Path :: setDefaultFileMode ( $ file_mode ) ; } $ dir_mode = ( int ) $ this -> config -> get ( 'io' , 'dir_mode' ) ; if ( $ dir_mode ) { $ of = $ dir_mode ; $ dir_mode = octdec ( sprintf ( "%04d" , $ dir_mode ) ) ; Path :: setDefaultDirMode ( $ dir_mode ) ; } }
7872	public function send ( array $ destinations , string $ message ) : ? array { $ this -> checkConfig ( ) ; if ( ! empty ( $ destinations ) ) { $ destination = $ destinations [ 0 ] ; } $ query = http_build_query ( [ 'userkey' => $ this -> userkey , 'passkey' => $ this -> passkey , 'nohp' => $ destination , 'pesan' => $ message , ] ) ; $ response = Request :: get ( $ this -> baseUrl . '/smsapi.php?' . $ query ) ; $ xml = simplexml_load_string ( $ response -> body ) ; $ body = json_decode ( json_encode ( $ xml ) , true ) ; if ( ! empty ( $ body [ 'message' ] ) and $ body [ 'message' ] [ 'status' ] != 0 ) { Log :: error ( sprintf ( 'Zenziva: %s.' , $ body [ 'message' ] [ 'text' ] ) ) ; } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ body [ 'message' ] [ 'text' ] ?? '' , 'data' => $ body , ] ; }
6618	protected function parseEndpointName ( $ method , $ endpoint ) { $ endpoint = str_replace ( ' ' , '' , ucwords ( str_replace ( [ '-' , '+' , '%20' ] , ' ' , $ endpoint ) ) ) ; $ method = strtolower ( $ method ) ; return $ method . $ endpoint . 'Endpoint' ; }
12472	public static function isEnabled ( ) { $ class = self :: className ( ) ; foreach ( \ Yii :: $ app -> modules as $ module => $ params ) { switch ( gettype ( $ params ) ) { case 'array' : if ( $ class == @ $ params [ 'class' ] ) return true ; break ; case 'object' : if ( $ class == get_class ( $ params ) ) return true ; break ; default : if ( $ class == $ params ) return true ; } if ( $ module == $ class || ( isset ( $ module [ 'class' ] ) && $ module [ 'class' ] == $ class ) ) { return true ; } } return false ; }
9250	public function boot ( ) { if ( $ this -> booted ) { return ; } $ this -> container = $ this -> initializeContainer ( ) ; $ this -> kernel = $ this -> container -> get ( 'http_kernel' ) ; $ this -> booted = true ; }
7012	private function formatF ( & $ str ) { if ( strstr ( $ str , '%F' ) ) $ str = str_replace ( '%F' , $ this -> monthName ( true ) , $ str ) ; }
636	public function dropTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropTable ( $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
8281	public function onTwigRegistered ( & $ twig ) { $ twig -> getLoader ( ) -> addPath ( $ this -> pluginDir . '/theme' ) ; $ this_instance = $ this ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_token' , function ( $ action = null ) use ( & $ this_instance ) { return $ this_instance -> csrf -> getToken ( $ action ) ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_field' , function ( $ action = null ) use ( & $ this_instance ) { return '<input type="hidden" name="csrf_token" value="' . $ this_instance -> csrf -> getToken ( $ action ) . '">' ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; }
7848	private function checkConfig ( ) : void { if ( empty ( $ this -> device ) ) { Log :: warning ( 'Config "message.smsgatewayme.device" is not defined.' ) ; } if ( empty ( $ this -> token ) ) { Log :: warning ( 'Config "message.smsgatewayme.token" is not defined.' ) ; } }
870	public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> candidateTokenKind = 'long' === $ this -> configuration [ 'syntax' ] ? CT :: T_DESTRUCTURING_SQUARE_BRACE_OPEN : T_LIST ; }
3657	private function tryDispatch ( $ eventName , MetaModelsBootEvent $ event ) { $ dispatcher = System :: getContainer ( ) -> get ( 'event_dispatcher' ) ; if ( $ dispatcher -> hasListeners ( $ eventName ) ) { @ trigger_error ( 'Event "' . $ eventName . '" has been deprecated - Use registered services.' , E_USER_DEPRECATED ) ; $ dispatcher -> dispatch ( $ eventName , $ event ) ; } }
3096	public function process ( ) { $ this -> validate ( ) ; $ itemIdentifier = $ this -> hasRequestParameter ( 'itemDefinition' ) ? $ this -> getRequestParameter ( 'itemDefinition' ) : null ; if ( ! is_array ( $ itemIdentifier ) ) { $ itemIdentifier = [ $ itemIdentifier ] ; } try { if ( ! $ this -> getRunnerService ( ) -> getTestConfig ( ) -> getConfigValue ( 'itemCaching.enabled' ) ) { common_Logger :: w ( 'Attempt to disclose the next items without the configuration' ) ; throw new common_exception_Unauthorized ( ) ; } $ response = [ ] ; foreach ( $ itemIdentifier as $ itemId ) { $ response [ 'items' ] [ ] = $ this -> getItemData ( $ itemId ) ; } if ( isset ( $ response [ 'items' ] ) ) { $ response [ 'success' ] = true ; } } catch ( \ Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
2277	public function getPasswordDefault ( $ varValue ) { if ( ! trim ( $ varValue ) ) { $ varValue = ( \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] [ 1 ] : $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] ) ; } return $ varValue ; }
11046	function parse_containers ( $ containers ) { if ( ! is_array ( $ containers ) ) { $ containers = explode ( ',' , $ containers ) ; } foreach ( $ containers as $ container ) { $ masktree = $ this -> read_container ( $ container , _ETS_ROOT ) ; if ( $ masktree === FALSE ) { $ this -> error ( 11 , 52 , $ this -> container ) ; } else { $ this -> masktree = $ this -> masktree_merge ( $ this -> masktree , $ masktree , $ container ) ; } } }
12153	public function getPossibleRoles ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = true ; switch ( $ roleItem -> systemId ) { case 'owner' : $ test = $ this -> isOwnable ; break ; } if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
12692	public function synchronize ( Page $ page , array $ pages ) { if ( ! $ this -> configurationHandler -> isTheme ( ) ) { return ; } foreach ( $ pages as $ pageValues ) { $ tokens = explode ( "_" , $ pageValues [ "seo" ] [ 0 ] [ "language" ] ) ; $ pageOptions = array ( 'page' => $ pageValues [ "name" ] , 'language' => $ tokens [ 0 ] , 'country' => $ tokens [ 1 ] , ) ; $ page -> render ( $ this -> configurationHandler -> siteDir ( ) , $ pageOptions ) ; $ this -> saveTemplateSlots ( $ page -> getPageSlots ( ) , $ pageValues [ "template" ] ) ; } $ this -> saveTemplateSlots ( $ page -> getCommonSlots ( ) , 'base' ) ; }
2061	public function generateAlias ( $ varValue , Contao \ DataContainer $ dc ) { $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> id ) ; $ aliasExists = function ( string $ alias ) use ( $ dc , $ objPage ) : bool { $ objAliasIds = $ this -> Database -> prepare ( "SELECT id FROM tl_page WHERE alias=? AND id!=?" ) -> execute ( $ alias , $ dc -> id ) ; if ( ! $ objAliasIds -> numRows ) { return false ; } $ strCurrentDomain = $ objPage -> domain ; $ strCurrentLanguage = $ objPage -> rootLanguage ; if ( $ objPage -> type == 'root' ) { $ strCurrentDomain = Contao \ Input :: post ( 'dns' ) ; $ strCurrentLanguage = Contao \ Input :: post ( 'language' ) ; } while ( $ objAliasIds -> next ( ) ) { $ objAliasPage = Contao \ PageModel :: findWithDetails ( $ objAliasIds -> id ) ; if ( $ objAliasPage -> domain != $ strCurrentDomain ) { continue ; } if ( Contao \ Config :: get ( 'addLanguageToUrl' ) && $ objAliasPage -> rootLanguage != $ strCurrentLanguage ) { continue ; } return true ; } return false ; } ; if ( $ varValue == '' ) { $ varValue = Contao \ System :: getContainer ( ) -> get ( 'contao.slug' ) -> generate ( $ dc -> activeRecord -> title , $ dc -> activeRecord -> id , function ( $ alias ) use ( $ objPage , $ aliasExists ) { return $ aliasExists ( ( Contao \ Config :: get ( 'folderUrl' ) ? $ objPage -> folderUrl : '' ) . $ alias ) ; } ) ; if ( Contao \ Config :: get ( 'folderUrl' ) && $ objPage -> folderUrl != '' ) { $ varValue = $ objPage -> folderUrl . $ varValue ; } } elseif ( $ aliasExists ( $ varValue ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
6904	public function runWild ( ) { foreach ( $ this -> handlers as $ handler ) { $ rtn = $ handler instanceof Closure ? $ this -> context -> call ( $ handler , $ this -> req ) : $ this -> context -> callInClass ( $ handler , $ this -> action , $ this -> req ) ; if ( ! is_null ( $ rtn ) ) return $ rtn ; } return null ; }
8526	public function listFinancialEventGroups ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroups' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1582	public function withRelationships ( $ relationships ) : self { $ copy = clone $ this ; $ copy -> relationships = collect ( $ relationships ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; }
3898	public function handleMetaChange ( $ strMetaName , $ varNewValue ) { if ( $ strMetaName == 'colname' ) { if ( $ this -> get ( $ strMetaName ) != $ varNewValue ) { $ this -> renameColumn ( $ varNewValue ) ; } return $ this ; } return parent :: handleMetaChange ( $ strMetaName , $ varNewValue ) ; }
293	public function getAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) ? $ this -> _attributes [ $ name ] : null ; }
3010	public function setConsumer ( $ consumerKey , $ consumerSecret ) { $ this -> apiKey = $ consumerKey ; $ this -> requestHandler -> setConsumer ( $ consumerKey , $ consumerSecret ) ; }
227	public function getSchemaNames ( $ refresh = false ) { if ( $ this -> _schemaNames === null || $ refresh ) { $ this -> _schemaNames = $ this -> findSchemaNames ( ) ; } return $ this -> _schemaNames ; }
11396	private static function _setFileNameInErrorFile ( ) { if ( defined ( 'BASH_CALLED' ) ) { error_log ( Bash :: setColor ( '############### ' . BASH_CALLED . ' ###############' , 'cyan' ) ) ; } else { if ( isset ( $ _SERVER [ 'HTTP_HOST' ] ) && isset ( $ _SERVER [ 'REQUEST_URI' ] ) ) { error_log ( Bash :: setColor ( '############### ' . $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] . ' ###############' , 'cyan' ) ) ; } } }
11053	public static function sprintts ( $ datatree , $ containers , $ entry = 'main' ) { return $ this -> sprintt ( $ datatree , $ containers , $ entry , _ETS_STRING_READ , '' , '' ) ; }
1058	public static function findTypesRemovedFromUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesRemovedFromUnion = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInNewUnion = [ ] ; foreach ( $ newType -> getTypes ( ) as $ type ) { $ typeNamesInNewUnion [ $ type -> name ] = true ; } foreach ( $ oldType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInNewUnion [ $ type -> name ] ) ) { continue ; } $ typesRemovedFromUnion [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_REMOVED_FROM_UNION , 'description' => sprintf ( '%s was removed from union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesRemovedFromUnion ; }
6853	public function onStatus ( PaymentEvent $ event ) { $ payment = $ event -> getPayment ( ) ; $ sale = $ payment -> getSale ( ) ; if ( $ sale instanceof OrderInterface ) { return ; } if ( $ sale instanceof CartInterface && $ sale -> getState ( ) !== CartStates :: STATE_ACCEPTED ) { return ; } if ( $ sale instanceof QuoteInterface && $ sale -> getState ( ) !== QuoteStates :: STATE_ACCEPTED ) { return ; } $ tokens = $ this -> findPaymentTokens ( $ payment ) ; if ( null === $ order = $ this -> transform ( $ sale ) ) { return ; } $ newPayment = null ; foreach ( $ order -> getPayments ( ) as $ p ) { if ( $ p -> getNumber ( ) === $ payment -> getNumber ( ) ) { $ newPayment = $ p ; break ; } } if ( null === $ newPayment ) { throw new RuntimeException ( "Failed to find the transformed payment." ) ; } $ this -> convertTokens ( $ this -> getPaymentIdentity ( $ newPayment ) , $ tokens ) ; $ event -> setPayment ( $ newPayment ) ; }
12324	protected function doExecute ( InputInterface $ input , OutputInterface $ output ) { if ( $ this -> askQuestions ( $ input , $ output ) == static :: RETURN_ERROR ) { return static :: RETURN_ERROR ; } $ data = $ this -> prepareData ( $ input ) ; $ this -> doPreExecuteTasks ( $ input , $ output , $ data ) ; $ return = $ this -> executeTasks ( $ input , $ output , $ data ) ; $ this -> doPostExecuteTasks ( $ input , $ output , $ data , $ return ) ; return $ return ; }
6846	public static function hours ( $ step = 1 , $ long = false , $ start = null ) { if ( ! $ start ) { $ start = $ long ? 0 : 1 ; } $ size = $ long ? 23 : 12 ; $ step = ( int ) $ step ; $ hours = array ( ) ; for ( $ i = $ start ; $ i <= $ size ; $ i += $ step ) { $ hours [ $ i ] = ( string ) $ i ; } return $ hours ; }
811	private function fixSpaceBelowClassElement ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { for ( $ nextNotWhite = $ elementEndIndex + 1 ; ; ++ $ nextNotWhite ) { if ( ( $ tokens [ $ nextNotWhite ] -> isComment ( ) || $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) && false === strpos ( $ tokens [ $ nextNotWhite ] -> getContent ( ) , "\n" ) ) { continue ; } break ; } if ( $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ nextNotWhite ) ; } $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; }
9980	private function writeComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment , array $ pAuthors ) { $ objWriter -> startElement ( 'comment' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pCellReference ) ; $ objWriter -> writeAttribute ( 'authorId' , $ pAuthors [ $ pComment -> getAuthor ( ) ] ) ; $ objWriter -> startElement ( 'text' ) ; $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichText ( $ objWriter , $ pComment -> getText ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
3223	function createTemporaryDirectLink ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/media" , $ path ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ j = RequestUtil :: parseResponseJson ( $ response -> body ) ; $ url = self :: getField ( $ j , "url" ) ; $ expires = self :: parseDateTime ( self :: getField ( $ j , "expires" ) ) ; return array ( $ url , $ expires ) ; }
5901	public function listGroups ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/groups' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Group ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12101	public function setAccept ( $ accept ) { $ this -> setTag ( 'accept' , $ accept ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'accept' , $ accept ) ; } }
6183	public function add ( $ type , $ message , $ redirect = null ) { if ( ! isset ( $ type ) or ! isset ( $ message [ 0 ] ) ) { return false ; } if ( strlen ( trim ( $ type ) ) === 1 ) { $ type = str_replace ( [ 'h' , 'i' , 'w' , 'e' , 's' ] , [ 'help' , 'info' , 'warning' , 'error' , 'success' ] , $ type ) ; } $ router = new Router ( ) ; try { if ( ! in_array ( $ type , $ this -> msgTypes ) ) { throw new BaseException ( '"' . strip_tags ( $ type ) . '" is not a valid message type!' , 501 ) ; } } catch ( BaseException $ e ) { $ msg = null ; if ( ini_get ( 'display_errors' ) === "on" ) { $ msg .= '<pre>' ; $ msg .= 'Message: <b>' . $ e -> getMessage ( ) . '</b><br><br>' ; $ msg .= 'Accept: ' . $ _SERVER [ 'HTTP_ACCEPT' ] . '<br>' ; if ( isset ( $ _SERVER [ 'HTTP_REFERER' ] ) ) { $ msg .= 'Referer: ' . $ _SERVER [ 'HTTP_REFERER' ] . '<br><br>' ; } $ msg .= 'Request Method: ' . $ _SERVER [ 'REQUEST_METHOD' ] . '<br><br>' ; $ msg .= 'Current file Path: <b>' . $ this -> router -> currentPath ( ) . '</b><br>' ; $ msg .= 'File Exception: ' . $ e -> getFile ( ) . ':' . $ e -> getLine ( ) . '<br><br>' ; $ msg .= 'Trace: <br>' . $ e -> getTraceAsString ( ) . '<br>' ; $ msg .= '</pre>' ; return Response :: create ( $ msg ) -> display ( ) ; } return Response :: create ( $ e -> getMessage ( ) ) -> status ( 501 ) -> display ( ) ; } $ get = $ this -> driver -> get ( 'flash_messages' ) ; $ get [ $ type ] [ ] = $ message ; $ this -> driver -> set ( 'flash_messages' , $ get ) ; if ( ! is_null ( $ redirect ) ) { return $ router -> redirect ( $ redirect , 301 ) ; } return true ; }
10795	public function contact ( array $ data , $ destination = null ) { $ authService = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'zfcUserAuthentication' ) ; if ( null === $ destination && ! $ authService -> hasIdentity ( ) ) { throw new \ Exception ( "Errore si sistema." ) ; } $ identity = $ authService -> getIdentity ( ) ; $ data [ 'email' ] = null !== $ destination ? $ destination : $ identity -> getEmail ( ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.contact' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ data = array_merge ( $ form -> getData ( ) , array ( 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) ) ) ; $ event = new UserContactEvent ( __FUNCTION__ , null , $ data ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; }
2919	public function updateSetter ( $ key , $ value = null , $ comment = null , $ export = false ) { $ pattern = "/^(export\h)?\h*{$key}=.*/m" ; $ line = $ this -> formatter -> formatSetterLine ( $ key , $ value , $ comment , $ export ) ; $ this -> buffer = preg_replace ( $ pattern , $ line , $ this -> buffer ) ; return $ this ; }
12117	public static function displayConsoleException ( \ Throwable $ Throwable ) { ob_start ( ) ; echo PHP_EOL . ' ' ; echo ( ( $ Throwable instanceof PHPAssertionFailed ) ? 'Assertion Failed' : 'Uncaught ' . self :: getShortName ( get_class ( $ Throwable ) ) ) ; echo ' <' . basename ( $ Throwable -> getFile ( ) ) . ':' . $ Throwable -> getLine ( ) . '>' ; echo PHP_EOL . PHP_EOL . ' ' ; if ( $ Throwable instanceof PHPAssertionFailed ) { $ message = $ Throwable -> getExpression ( ) ; if ( $ message == '' ) { $ message = 'false' ; } } else { $ message = $ Throwable -> getMessage ( ) ; } echo wordwrap ( $ message , self :: CONSOLE_WIDTH - 2 , PHP_EOL . ' ' ) ; echo PHP_EOL . PHP_EOL . ' Stack Trace:' . PHP_EOL . PHP_EOL ; if ( $ Throwable instanceof BaseException || $ Throwable instanceof PHPErrorException ) { $ trace = $ Throwable -> getStackTrace ( ) ; } else { $ trace = array_reverse ( $ Throwable -> getTrace ( ) ) ; } $ trace_empty = [ 'class' => '' , 'type' => '' , 'function' => '' , 'file' => '{unknown}' , 'line' => 0 ] ; foreach ( $ trace as $ key => $ trace_item ) { $ trace_item = array_merge ( $ trace_empty , $ trace_item ) ; $ trace_item [ 'file' ] = basename ( $ trace_item [ 'file' ] ) ; if ( $ trace_item [ 'function' ] != '{closure}' ) { $ trace_item [ 'function' ] .= '()' ; } $ key ++ ; echo str_pad ( " $key. " , 6 , ' ' ) ; echo self :: getShortName ( $ trace_item [ 'class' ] ) . $ trace_item [ 'type' ] . $ trace_item [ 'function' ] ; echo " <{$trace_item['file']}:{$trace_item['line']}>" . PHP_EOL ; } return ob_get_clean ( ) ; }
1060	public static function findDangerousChanges ( Schema $ oldSchema , Schema $ newSchema ) { return array_merge ( self :: findArgChanges ( $ oldSchema , $ newSchema ) [ 'dangerousChanges' ] , self :: findValuesAddedToEnums ( $ oldSchema , $ newSchema ) , self :: findInterfacesAddedToObjectTypes ( $ oldSchema , $ newSchema ) , self :: findTypesAddedToUnions ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnInputObjectTypes ( $ oldSchema , $ newSchema ) [ 'dangerousChanges' ] ) ; }
9415	public function precision ( $ n ) { if ( ! is_numeric ( $ n ) || $ n < 0 ) { throw new \ InvalidArgumentException ( 'Precision must be positive number' ) ; } $ this -> int_precision = ( integer ) $ n ; }
10793	public function delete ( $ idOrUser , $ forceLogout = true ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ em = $ main -> getEntityManager ( ) ; $ user = $ this -> getEntity ( $ idOrUser ) ; $ classifiedService = $ this -> getServiceLocator ( ) -> get ( 'document.service.classified' ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ , $ this , array ( 'user' => $ user ) ) ; $ user -> setState ( UserEntity :: USER_STATE_DELETED ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ documents = $ user -> getDocument ( ) ; foreach ( $ documents as $ document ) { try { $ classifiedService -> delete ( $ document ) ; } catch ( \ Exception $ e ) { } } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , array ( 'user' => $ user ) ) ; if ( $ forceLogout ) { $ this -> logout ( ) ; } return $ user ; }
12112	public function getForeignDataModel ( $ key ) { $ config = $ this -> settings [ 'foreignPullParams' ] ; if ( ! isset ( $ config [ 'where' ] ) ) { $ config [ 'where' ] = [ ] ; } if ( ! empty ( $ config [ 'where' ] ) ) { $ config [ 'where' ] = [ 'and' , $ config [ 'where' ] , [ $ this -> foreignModel -> primaryKey ( ) => $ key ] ] ; } else { $ config [ 'where' ] [ $ this -> foreignModel -> primaryKey ( ) ] = $ key ; } return $ this -> foreignModel -> findOne ( $ config ) ; }
7325	protected function cachingIsPossible ( ) { if ( static :: $ _cachingIsPossible === null ) { $ storeClass = '\AlternativeLaravelCache\Core\AlternativeCacheStore' ; $ poolInterface = '\Cache\Taggable\TaggablePoolInterface' ; $ cache = app ( 'cache.store' ) -> getStore ( ) ; static :: $ _cachingIsPossible = ( $ cache instanceof $ storeClass && $ cache -> getWrappedConnection ( ) instanceof $ poolInterface ) ; } return static :: $ _cachingIsPossible ; }
9180	final public function getViewSettings ( ) { $ rf = new \ ReflectionClass ( $ this ) ; $ this -> viewName = str_replace ( 'View' , '' , $ rf -> getShortName ( ) ) ; $ matches = array ( ) ; if ( preg_match ( "#@applyTo\((.*)\)#" , $ rf -> getDocComment ( ) , $ matches ) ) { $ params = array ( ) ; parse_str ( str_replace ( ',' , '&' , $ matches [ 1 ] ) , $ params ) ; if ( is_array ( $ params ) ) { foreach ( $ params as $ param => $ value ) { if ( $ param == 'controller' ) { $ this -> controllers = explode ( '|' , $ value ) ; } if ( $ param == 'action' ) { $ this -> actions = explode ( '|' , $ value ) ; } } } } return $ this ; }
7439	protected function initializeProductMediaGalleryValue ( array $ attr ) { $ rowId = $ attr [ MemberNames :: ROW_ID ] ; $ valueId = $ attr [ MemberNames :: VALUE_ID ] ; $ storeId = $ attr [ MemberNames :: STORE_ID ] ; if ( $ entity = $ this -> loadProductMediaGalleryValueByValueIdAndStoreIdAndRowId ( $ valueId , $ storeId , $ rowId ) ) { return $ this -> mergeEntity ( $ entity , $ attr ) ; } return $ attr ; }
7806	protected function getNearestDateTimeFromDayAndMonth ( \ DateTime $ target , $ day , $ month ) { $ initialGuess = new \ DateTime ( ) ; $ initialGuess -> setDate ( $ target -> format ( 'Y' ) , $ month , $ day ) ; $ initialGuess -> setTime ( 0 , 0 , 0 ) ; $ initialGuessDiff = $ target -> diff ( $ initialGuess ) ; $ yearEarlier = clone $ initialGuess ; $ yearEarlier -> modify ( '-1 year' ) ; $ yearEarlierDiff = $ target -> diff ( $ yearEarlier ) ; if ( $ yearEarlierDiff -> days < $ initialGuessDiff -> days ) { return $ yearEarlier ; } $ yearLater = clone $ initialGuess ; $ yearLater -> modify ( '+1 year' ) ; $ yearLaterDiff = $ target -> diff ( $ yearLater ) ; if ( $ yearLaterDiff -> days < $ initialGuessDiff -> days ) { return $ yearLater ; } return $ initialGuess ; }
11935	public function primaryKey ( ) { $ pk = $ this -> meta -> schema -> primaryKey ; if ( is_array ( $ pk ) ) { $ ppk = [ ] ; foreach ( $ pk as $ key ) { $ ppk [ ] = $ key ; } return implode ( '.' , $ ppk ) ; } return $ pk ; }
6628	public function get ( $ key , $ default = null ) { return ArrayHelper :: getValue ( $ this -> parsedResponse , sprintf ( '%s.%s' , self :: RESPONSE_DATA_PARAM , $ key ) , $ default ) ; }
5094	public function executeIterator ( ) { $ result = $ this -> execute ( ) ; if ( ! $ result ) throw new MySqlException ( 'Could not execute multiset query!' ) ; while ( true ) { yield new StatementResult ( $ result ) ; if ( ! $ result -> nextRowset ( ) ) { $ this -> checkForError ( $ result ) ; break ; } } }
3595	public function registerCpUrlRules ( RegisterUrlRulesEvent $ event ) { if ( ! \ Craft :: $ app -> user -> identity ) return ; $ rules = [ 'settings/sitemap' => [ 'route' => 'sitemap/settings' , 'params' => [ 'source' => 'CpSettings' ] ] , 'settings/sitemap/save-sitemap' => [ 'route' => 'sitemap/settings/save-sitemap' , 'params' => [ 'source' => 'CpSettings' ] ] , ] ; $ event -> rules = array_merge ( $ event -> rules , $ rules ) ; }
9940	public function calculateColumnWidths ( ) { $ autoSizes = [ ] ; foreach ( $ this -> getColumnDimensions ( ) as $ colDimension ) { if ( $ colDimension -> getAutoSize ( ) ) { $ autoSizes [ $ colDimension -> getColumnIndex ( ) ] = - 1 ; } } if ( ! empty ( $ autoSizes ) ) { $ isMergeCell = [ ] ; foreach ( $ this -> getMergeCells ( ) as $ cells ) { foreach ( Coordinate :: extractAllCellReferencesInRange ( $ cells ) as $ cellReference ) { $ isMergeCell [ $ cellReference ] = true ; } } foreach ( $ this -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ this -> getCell ( $ coordinate , false ) ; if ( $ cell !== null && isset ( $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] ) ) { $ isMerged = isset ( $ isMergeCell [ $ this -> cellCollection -> getCurrentCoordinate ( ) ] ) ; $ isMergedButProceed = false ; if ( $ isMerged && $ cell -> isMergeRangeValueCell ( ) ) { $ range = $ cell -> getMergeRange ( ) ; $ rangeBoundaries = Coordinate :: rangeDimension ( $ range ) ; if ( $ rangeBoundaries [ 0 ] == 1 ) { $ isMergedButProceed = true ; } } if ( ! $ isMerged || $ isMergedButProceed ) { $ cellValue = NumberFormat :: toFormattedString ( $ cell -> getCalculatedValue ( ) , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] = max ( ( float ) $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] , ( float ) Shared \ Font :: calculateColumnWidth ( $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getFont ( ) , $ cellValue , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getAlignment ( ) -> getTextRotation ( ) , $ this -> getParent ( ) -> getDefaultStyle ( ) -> getFont ( ) ) ) ; } } } foreach ( $ autoSizes as $ columnIndex => $ width ) { if ( $ width == - 1 ) { $ width = $ this -> getDefaultColumnDimension ( ) -> getWidth ( ) ; } $ this -> getColumnDimension ( $ columnIndex ) -> setWidth ( $ width ) ; } } return $ this ; }
10480	private function isTrackedFieldModified ( AbstractDiffItem $ item , ExtractionDescriptorInterface $ relation ) { if ( ! $ item instanceof UpdateDiffItem ) { throw new \ InvalidArgumentException ( 'Wrong diff item type. Got: ' . get_class ( $ item ) ) ; } $ trackedFields = $ relation -> getUpdateFields ( ) ; if ( empty ( $ trackedFields ) ) { return true ; } $ itemRow = $ item -> getItem ( ) ; $ oldItemRow = $ item -> getOldItem ( ) ; foreach ( array_keys ( $ trackedFields ) as $ key ) { if ( array_key_exists ( $ key , $ itemRow ) && $ itemRow [ $ key ] !== $ oldItemRow [ $ key ] ) { return true ; } } return false ; }
4977	public function send ( \ Zend \ Mail \ Message $ message ) { $ options = $ this -> options ; $ filename = call_user_func ( $ options -> getCallback ( ) , $ this ) ; $ file = $ options -> getPath ( ) . DIRECTORY_SEPARATOR . $ filename ; $ contents = $ message -> toString ( ) ; $ umask = umask ( ) ; umask ( 022 ) ; if ( false === file_put_contents ( $ file , $ contents , LOCK_EX ) ) { throw new RuntimeException ( sprintf ( 'Unable to write mail to file (directory "%s")' , $ options -> getPath ( ) ) ) ; } umask ( $ umask ) ; $ this -> lastFile = $ file ; }
4336	private function closeOpenGroups ( ) { $ this -> data [ 'groupPriorityStack' ] [ ] = 'main' ; while ( $ this -> data [ 'groupPriorityStack' ] ) { $ priority = \ array_pop ( $ this -> data [ 'groupPriorityStack' ] ) ; foreach ( $ this -> data [ 'groupStacks' ] [ $ priority ] as $ i => $ info ) { if ( $ info [ 'collect' ] ) { unset ( $ this -> data [ 'groupStacks' ] [ $ priority ] [ $ i ] ) ; $ meta = array ( 'channel' => $ info [ 'channel' ] , ) ; if ( $ priority === 'main' ) { $ this -> data [ 'log' ] [ ] = array ( 'groupEnd' , array ( ) , $ meta ) ; } else { $ this -> data [ 'logSummary' ] [ $ priority ] [ ] = array ( 'groupEnd' , array ( ) , $ meta ) ; } } } } }
5179	private function addNew ( string $ key , $ value ) : self { $ this -> props [ $ key ] = $ value ; return $ this ; }
8285	protected function sessionTimeoutCheck ( $ configKey , $ sessKey , $ clear , $ alwaysUpdate = false ) { if ( $ this -> config [ $ configKey ] !== false ) { $ t = time ( ) ; if ( $ this -> session -> has ( $ sessKey ) ) { if ( $ this -> session -> get ( $ sessKey ) < $ t - $ this -> config [ $ configKey ] ) { if ( $ clear ) { $ this -> session -> invalidate ( ) ; } else { $ this -> session -> migrate ( true ) ; } $ this -> session -> set ( $ sessKey , $ t ) ; } elseif ( $ alwaysUpdate ) { $ this -> session -> set ( $ sessKey , $ t ) ; } } else { $ this -> session -> set ( $ sessKey , $ t ) ; } } }
5360	protected function createBodyStatements ( Operation $ operation , $ queryParamVariable , Context $ context ) { $ bodyParameter = null ; $ bodyVariable = new Expr \ Variable ( 'body' ) ; $ parameterKey = 0 ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ bodyParameter = $ parameter ; $ parameterKey = $ key ; } } } if ( null === $ bodyParameter ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( $ queryParamVariable , 'buildFormDataString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] , $ bodyVariable ] ; } if ( $ bodyParameter -> getSchema ( ) instanceof Reference || $ context -> getRegistry ( ) -> hasClass ( $ operation -> getReference ( ) . '/parameters/' . $ parameterKey ) ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( new Expr \ PropertyFetch ( new Expr \ Variable ( 'this' ) , 'serializer' ) , 'serialize' , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) , new Arg ( new Scalar \ String_ ( 'json' ) ) ] ) ) ] , $ bodyVariable ] ; } return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) ] , $ bodyVariable ] ; }
3112	public function persist ( $ testSessionId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> save ( ) ; $ this -> getStorageService ( ) -> persist ( $ extendedState -> getUserId ( ) , $ extendedState -> getStorageKey ( ) ) ; }
11209	public function login ( $ subject ) { $ caller = $ this -> identifier -> identify ( $ subject ) ; if ( $ this -> authenticator -> authenticate ( $ subject , $ caller ) ) { $ this -> driver -> setLoginToken ( $ caller -> getLoginToken ( ) ) ; $ this -> currentCaller = $ caller ; return true ; } return false ; }
12415	public static function init ( $ options = array ( ) ) { Flight :: map ( "render" , function ( $ template , $ data , $ toVar = false ) { Flight :: view ( ) -> render ( $ template , $ data , $ toVar ) ; } ) ; Flight :: register ( 'view' , get_called_class ( ) , $ options ) ; }
6998	protected function prepareRelatedRecord ( $ relationName , array $ relationRecordData , $ index = null ) { $ recordWithBackup = $ relationRecordData ; $ valueViewers = $ this -> getViewersForRelations ( ) ; foreach ( $ relationRecordData as $ columnName => $ value ) { $ viewerName = $ relationName . '.' . ( $ index === null ? '' : $ index . '.' ) . $ columnName ; if ( array_key_exists ( $ viewerName , $ valueViewers ) && $ valueViewers [ $ viewerName ] -> getRelation ( ) -> getName ( ) === $ relationName ) { $ recordWithBackup [ $ columnName ] = $ recordWithBackup [ '__' . $ columnName ] = $ value ; $ valueViewer = $ valueViewers [ $ viewerName ] ; if ( is_object ( $ valueViewer ) && method_exists ( $ valueViewer , 'convertValue' ) && ( ! method_exists ( $ valueViewer , 'isVisible' ) || $ valueViewer -> isVisible ( ) ) ) { $ recordWithBackup [ $ columnName ] = $ valueViewer -> convertValue ( $ recordWithBackup [ $ columnName ] , $ relationRecordData ) ; } } } return $ recordWithBackup ; }
5538	public function getFrameFocus ( ) { if ( $ this -> focus === false ) { return array ( ) ; } return array_merge ( array ( $ this -> getPublicNameFromIndex ( $ this -> focus ) ) , $ this -> frames [ $ this -> focus ] -> getFrameFocus ( ) ) ; }
3806	private function isAttributeNameOrTypeChanged ( ModelInterface $ new , ModelInterface $ old ) { return ( $ old -> getProperty ( 'type' ) !== $ new -> getProperty ( 'type' ) ) || ( $ old -> getProperty ( 'colname' ) !== $ new -> getProperty ( 'colname' ) ) ; }
1425	protected function getRelationshipPaths ( $ includePaths ) { return $ this -> convertIncludePaths ( $ includePaths ) -> merge ( $ this -> defaultWith ) -> unique ( ) -> all ( ) ; }
11487	protected function callResolvingCallbacks ( $ key , $ object ) { foreach ( $ this -> resolvingAnyCallbacks as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } if ( isset ( $ this -> resolvingCallbacks [ $ key ] ) ) { foreach ( $ this -> resolvingCallbacks [ $ key ] as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } } }
2007	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; if ( $ exception -> getPrevious ( ) instanceof ResourceNotFoundException && ! $ this -> hasRootPages ( ) ) { $ exception = new NoRootPageFoundException ( 'No root page found' , 0 , $ exception ) ; } $ class = $ this -> getTargetClass ( $ exception ) ; if ( null === $ class ) { return ; } if ( null !== ( $ httpException = $ this -> convertToHttpException ( $ exception , $ class ) ) ) { $ event -> setException ( $ httpException ) ; } }
11327	public function getLocations ( ) { if ( is_null ( $ this -> _locations ) ) { $ this -> _locations = $ this -> determineLocations ( ) ; } return $ this -> _locations ; }
11764	protected function handleStage ( & $ stages , $ stage ) { if ( $ stage instanceof Pipeline ) { $ stages = array_merge ( $ stages , $ stage -> stages ( ) ) ; } elseif ( $ stage instanceof MiddlewareInterface ) { $ stages [ ] = $ stage ; } elseif ( $ stage instanceof RequestHandlerInterface ) { $ stages [ ] = new RequestHandler ( $ stage ) ; } elseif ( is_callable ( $ stage ) ) { $ stages [ ] = new Lambda ( $ stage ) ; } else { throw new InvalidMiddlewareArgument ( is_string ( $ stage ) ? $ stage : get_class ( $ stage ) ) ; } }
1141	public function setValue ( $ value ) { if ( \ is_bool ( $ value ) ) { if ( 'checkbox' !== $ this -> type ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Invalid argument of type "%s"' , \ gettype ( $ value ) ) ) ; } if ( $ value ) { if ( ! $ this -> element -> isSelected ( ) ) { $ this -> element -> click ( ) ; } } elseif ( $ this -> element -> isSelected ( ) ) { $ this -> element -> click ( ) ; } return ; } foreach ( ( array ) $ value as $ v ) { $ this -> selector -> selectByValue ( $ v ) ; } }
11373	public function createPublicMethodInjection ( \ ReflectionMethod $ method ) : MethodInjection { $ injections = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { $ injections [ ] = new ParameterInjection ( $ parameter -> getName ( ) , ( string ) $ parameter -> getType ( ) , $ parameter -> isArray ( ) , $ this -> getInjectHint ( $ method , $ parameter ) ) ; } return new MethodInjection ( $ injections , $ method -> getName ( ) ) ; }
10931	function countRowsWith ( string $ tablename , string $ colName , $ colValue ) : int { $ strSQL = "SELECT COUNT($colName) as count FROM $tablename WHERE $colName=:$colName;" ; return $ this -> getCountOf ( $ strSQL , [ "$colName" => $ colValue ] ) ; }
4919	public function attachInputFilterDefaults ( InputFilterInterface $ inputFilter , FieldsetInterface $ fieldset ) { parent :: attachInputFilterDefaults ( $ inputFilter , $ fieldset ) ; foreach ( $ inputFilter -> getInputs ( ) as $ name => $ input ) { if ( ! $ input instanceof InputFilterInterface ) { $ required = $ input -> isRequired ( ) ; $ inputExists = $ fieldset -> has ( $ name ) ; if ( ! $ inputExists && $ required ) { $ fieldsetName = '' ; if ( $ fieldset -> hasAttribute ( 'name' ) ) { $ fieldsetName = 'in Fieldset "' . $ fieldset -> getAttribute ( 'name' ) . '" ' ; } throw new \ RuntimeException ( 'input for "' . $ name . '" ' . $ fieldsetName . 'is required but a input-field with this name is not defined' ) ; } } } }
12479	private function generateOptions ( $ folder , $ rootAlias ) { $ assetsPath = $ this -> configurationHandler -> uploadAssetsDir ( ) . '/' . $ folder ; if ( ! is_dir ( $ assetsPath ) ) { @ mkdir ( $ assetsPath ) ; } $ options = array ( 'locale' => '' , 'roots' => array ( array ( 'driver' => 'LocalFileSystem' , 'path' => $ assetsPath , 'URL' => $ this -> configurationHandler -> absoluteUploadAssetsDir ( ) . '/' . $ folder , 'accessControl' => 'access' , 'rootAlias' => $ rootAlias ) ) ) ; return $ options ; }
5828	public function newRequest ( $ method , $ url , $ data = array ( ) , $ encoding = Request :: ENCODING_QUERY ) { $ class = $ this -> requestClass ; $ request = new $ class ( $ this ) ; $ request -> setMethod ( $ method ) ; $ request -> setUrl ( $ url ) ; $ request -> setData ( $ data ) ; $ request -> setEncoding ( $ encoding ) ; return $ request ; }
12011	private function addBlockSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> fixXmlConfig ( 'block_theme' ) -> children ( ) -> arrayNode ( 'block_themes' ) -> prototype ( 'scalar' ) -> end ( ) -> example ( [ '@App/block.html.twig' ] ) -> end ( ) -> end ( ) ; }
2534	public function setSessionData ( array $ sessionData ) { if ( isset ( $ sessionData [ 'sessionId' ] , $ sessionData [ 'sequenceNumber' ] , $ sessionData [ 'securityToken' ] ) ) { $ this -> sessionData [ 'sessionId' ] = $ sessionData [ 'sessionId' ] ; $ this -> sessionData [ 'sequenceNumber' ] = $ sessionData [ 'sequenceNumber' ] ; $ this -> sessionData [ 'securityToken' ] = $ sessionData [ 'securityToken' ] ; $ this -> isAuthenticated = true ; } else { $ this -> isAuthenticated = false ; } return $ this -> isAuthenticated ; }
4024	public function handle ( BuildDataDefinitionEvent $ event ) { if ( 'tl_metamodel_dca_sortgroup' !== $ event -> getContainer ( ) -> getName ( ) ) { return ; } foreach ( $ event -> getContainer ( ) -> getPalettesDefinition ( ) -> getPalettes ( ) as $ palette ) { foreach ( $ palette -> getProperties ( ) as $ property ) { if ( $ property -> getName ( ) != 'rendergrouptype' ) { continue ; } $ this -> addCondition ( $ property , new PropertyConditionChain ( array ( new InputScreenRenderModeIs ( 'flat' , $ this -> connection ) , new InputScreenRenderModeIs ( 'parented' , $ this -> connection ) , ) , PropertyConditionChain :: OR_CONJUNCTION ) ) ; } } }
2874	public function enableAction ( ) { $ moduleName = ( string ) $ this -> getRequest ( ) -> getParam ( 'module' ) ; try { $ this -> getService ( ) -> setModuleStatus ( $ moduleName , true ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'Module was enabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to enable module: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
8687	public static function replaceRecursive ( $ iterable1 , $ iterable2 ) { Assert :: allIsIterable ( [ $ iterable1 , $ iterable2 ] ) ; if ( $ iterable1 instanceof Traversable ) { $ iterable1 = iterator_to_array ( $ iterable1 ) ; } if ( $ iterable2 instanceof Traversable ) { $ iterable2 = iterator_to_array ( $ iterable2 ) ; } $ merged = $ iterable1 ; foreach ( $ iterable2 as $ key => $ value ) { if ( $ value instanceof Traversable ) { $ value = iterator_to_array ( $ value ) ; } if ( is_array ( $ value ) && static :: isAssociative ( $ value ) && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { $ merged [ $ key ] = static :: replaceRecursive ( $ merged [ $ key ] , $ value ) ; } elseif ( $ value === null && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { if ( $ merged [ $ key ] instanceof Traversable ) { $ merged [ $ key ] = iterator_to_array ( $ merged [ $ key ] ) ; } continue ; } else { $ merged [ $ key ] = $ value ; } } return $ merged ; }
5875	public function containerAdd ( ServerRequestInterface $ request , ResponseInterface $ response ) : ResponseInterface { $ GLOBALS [ 'TCA' ] [ 'tx_imageautoresize' ] = include ( ExtensionManagementUtility :: extPath ( 'image_autoresize' ) . 'Configuration/TCA/Module/Options.php' ) ; $ GLOBALS [ 'TCA' ] [ 'tx_imageautoresize' ] [ 'ajax' ] = true ; $ dataProviders = & $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'formEngine' ] [ 'formDataGroup' ] [ 'tcaDatabaseRecord' ] ; $ dataProviders [ \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: class ] = [ 'before' => [ \ TYPO3 \ CMS \ Backend \ Form \ FormDataProvider \ DatabaseEditRow :: class , ] ] ; $ record = [ 'uid' => \ Causal \ ImageAutoresize \ Controller \ ConfigurationController :: virtualRecordId , 'pid' => 0 , ] ; \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: initialize ( $ record ) ; $ response = parent :: containerAdd ( $ request , $ response ) ; return $ response -> withHeader ( 'Content-Type' , 'application/json; charset=utf-8' ) ; }
7998	private function getOpenSslEncryptionOptions ( ) { $ options = self :: DEFAULT_OPENSSL_OPTIONS ; if ( $ this -> zero_pad ) { $ options = $ options | OPENSSL_ZERO_PADDING ; } return $ options ; }
11303	protected static function checkPath ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new NotFoundException ( Message :: get ( Message :: MSG_PATH_NOTFOUND , $ path ) , Message :: MSG_PATH_NOTFOUND ) ; } if ( ! is_readable ( $ path ) ) { throw new RuntimeException ( Message :: get ( Message :: MSG_PATH_NONREADABLE , $ path ) , Message :: MSG_PATH_NONREADABLE ) ; } }
1248	private static function getHomeDir ( ) { if ( $ homeDir = getenv ( 'HOME' ) ) { return $ homeDir ; } $ homeDrive = getenv ( 'HOMEDRIVE' ) ; $ homePath = getenv ( 'HOMEPATH' ) ; return ( $ homeDrive && $ homePath ) ? $ homeDrive . $ homePath : null ; }
2721	private function getMessageInStoreLocale ( StoreInterface $ emulatedStore ) { $ currentStore = $ this -> storeManager -> getStore ( ) ; $ this -> localeResolver -> emulate ( $ emulatedStore -> getId ( ) ) ; $ this -> storeManager -> setCurrentStore ( $ emulatedStore -> getId ( ) ) ; $ message = __ ( 'You are in the wrong store. Click OK to visit the %1 store.' , [ $ emulatedStore -> getName ( ) ] ) -> __toString ( ) ; $ this -> localeResolver -> revert ( ) ; $ this -> storeManager -> setCurrentStore ( $ currentStore -> getId ( ) ) ; return $ message ; }
8672	private function iterateFromIndex ( $ fromIndex ) { Assert :: integer ( $ fromIndex ) ; $ count = count ( $ this -> items ) ; if ( $ count === 0 ) { return ; } $ last = $ count - 2 ; $ index = $ fromIndex < 0 ? max ( $ last + $ fromIndex , - 1 ) : min ( $ fromIndex - 1 , $ last ) ; $ keys = array_keys ( $ this -> items ) ; while ( ++ $ index < $ count ) { $ key = $ keys [ $ index ] ; yield $ key => $ this -> items [ $ key ] ; } }
6239	public static function getExtensionFor ( string $ mimetype ) : ? string { $ extensions = static :: getExtensions ( ) ; if ( false !== $ match = array_search ( $ mimetype , $ extensions , true ) ) { return $ match ; } return null ; }
4644	public function stop ( Job $ job , $ timeout = 10 ) { foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { try { $ this -> docker -> getContainerManager ( ) -> stop ( $ service -> getContainer ( ) , [ 't' => $ timeout ] ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) != 304 ) { throw $ e ; } } $ this -> docker -> getContainerManager ( ) -> remove ( $ service -> getContainer ( ) , [ 'v' => true , 'force' => true ] ) ; $ service -> setContainer ( null ) ; } } }
1200	public function get ( $ menu , array $ path = array ( ) , array $ options = array ( ) ) { if ( ! $ menu instanceof ItemInterface ) { if ( null === $ this -> menuProvider ) { throw new \ BadMethodCallException ( 'A menu provider must be set to retrieve a menu' ) ; } $ menuName = $ menu ; $ menu = $ this -> menuProvider -> get ( $ menuName , $ options ) ; if ( ! $ menu instanceof ItemInterface ) { throw new \ LogicException ( sprintf ( 'The menu "%s" exists, but is not a valid menu item object. Check where you created the menu to be sure it returns an ItemInterface object.' , $ menuName ) ) ; } } foreach ( $ path as $ child ) { $ menu = $ menu -> getChild ( $ child ) ; if ( null === $ menu ) { throw new \ InvalidArgumentException ( sprintf ( 'The menu has no child named "%s"' , $ child ) ) ; } } return $ menu ; }
11432	protected function head ( $ path , array $ parameters = array ( ) , $ requestHeaders = array ( ) ) { if ( array_key_exists ( 'ref' , $ parameters ) && is_null ( $ parameters [ 'ref' ] ) ) { unset ( $ parameters [ 'ref' ] ) ; } $ response = $ this -> client -> getHttpClient ( ) -> request ( $ path , null , 'HEAD' , $ requestHeaders , array ( 'query' => $ parameters ) ) ; return $ response ; }
4391	public function getConfigBE ( ) { $ list = [ ] ; foreach ( $ this -> beConfig as $ key => $ config ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( $ config ) ; } return $ list ; }
1091	public function aggregate ( $ function , $ columns = array ( '*' ) ) { if ( ! isset ( $ this -> groups ) ) $ this -> reOrderBy ( null ) ; return parent :: aggregate ( $ function , $ columns ) ; }
11320	function getOne ( $ sql , $ params = array ( ) ) { $ data = $ this -> query ( $ sql , $ params ) ; if ( count ( $ data ) > 0 ) { $ data = array_values ( $ data [ 0 ] ) ; return $ data [ 0 ] ; } return false ; }
3288	private function readDataFromPendingClient ( $ socket , int $ length , PendingSocketClient $ state ) { $ data = \ fread ( $ socket , $ length ) ; if ( $ data === false || $ data === '' ) { return null ; } $ data = $ state -> receivedDataBuffer . $ data ; if ( \ strlen ( $ data ) < $ length ) { $ state -> receivedDataBuffer = $ data ; return null ; } $ state -> receivedDataBuffer = '' ; Loop :: cancel ( $ state -> readWatcher ) ; return $ data ; }
11242	protected function _call ( $ fieldData , $ controller , $ method , $ passing , $ arguments ) { $ fieldData = array ( $ fieldData , $ arguments ) ; $ result = call_user_func_array ( array ( $ controller , $ method ) , $ fieldData ) ; return $ result == $ passing ? true : false ; }
1452	protected function createValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> factory -> createDeleteValidator ( $ data , $ rules , $ messages , $ customAttributes ) ; }
4747	public function listPlans ( array $ filters = [ ] , bool $ withAddons = true , string $ addonType = null ) : array { $ cacheKey = 'plans' ; $ hit = $ this -> getFromCache ( $ cacheKey ) ; if ( false === $ hit ) { $ response = $ this -> sendRequest ( 'GET' , 'plans' ) ; $ plans = $ this -> processResponse ( $ response ) ; $ hit = $ plans [ 'plans' ] ; $ this -> saveToCache ( $ cacheKey , $ hit ) ; } $ hit = $ this -> filterPlans ( $ hit , $ filters ) ; if ( $ withAddons ) { $ hit = $ this -> getAddonsForPlan ( $ hit , $ addonType ) ; } return $ hit ; }
11293	protected function _getAttributeData ( $ name , $ query = false , $ loadMap = false , $ record = false ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { return $ this -> _getAttributeDataWhenSet ( $ name , $ query , $ loadMap , $ record ) ; } if ( isset ( $ this -> model_attributes [ $ name ] ) && ! isset ( $ this -> model_dynamicOff ) ) { return $ this -> _getAttributeDataWhenUnset ( $ name , $ query , $ loadMap , $ record ) ; } if ( isset ( $ this -> data -> { $ name } ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> data -> { $ name } ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } $ class = get_class ( $ this ) ; if ( property_exists ( $ class , $ name ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> { $ name } ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } if ( $ name == 'id' && property_exists ( $ class , 'id_name' ) ) { $ this -> beforeGet ( $ this -> id_name ) ; if ( isset ( $ this -> model_data [ $ this -> id_name ] ) ) { $ returnValue = $ this -> model_data [ $ this -> id_name ] ; } else { $ returnValue = $ this -> { $ this -> id_name } ; } $ this -> afterGet ( $ this -> id_name , $ returnValue ) ; return $ returnValue ; } if ( substr ( $ name , 0 , 6 ) != "model_" && $ this -> issetExtended ( $ name ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> getExtendedAttribute ( $ name ) ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } $ this -> beforeGet ( $ name ) ; if ( isset ( $ this -> { $ name } ) ) { $ returnValue = $ this -> { $ name } ; } else { $ returnValue = null ; } $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; }
1862	public function move_uploaded_file ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; return move_uploaded_file ( $ strSource , $ this -> strRootDir . '/' . $ strDestination ) ; }
9039	public function getByHash ( $ columns , string $ hash ) : ? IEntity { if ( $ this -> manager -> hasher === null ) { throw new MissingServiceException ( 'Hasher is missing' ) ; } return $ this -> toEntity ( $ this -> manager -> hasher -> hashSQL ( $ this -> builder ( ) , $ columns , $ hash ) ) ; }
4918	public function setParam ( $ key , $ value ) { if ( $ this -> has ( $ key ) ) { $ this -> get ( $ key ) -> setValue ( $ value ) ; } else { $ this -> add ( [ 'type' => 'hidden' , 'name' => $ key , 'attributes' => [ 'value' => $ value ] ] ) ; } return $ this ; }
5927	public function retrieveCategory ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/categories/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
1169	protected function purgeNonRemoteRules ( $ rules , $ validator ) { $ protectedValidator = $ this -> createProtectedCaller ( $ validator ) ; foreach ( $ rules as $ i => $ rule ) { $ parsedRule = ValidationRuleParser :: parse ( [ $ rule ] ) ; if ( ! $ this -> isRemoteRule ( $ parsedRule [ 0 ] ) ) { unset ( $ rules [ $ i ] ) ; } } return $ rules ; }
8453	protected function determineFilename ( $ originalFilename , array $ mediaFileInfo ) { if ( is_null ( $ originalFilename ) || ! isset ( $ originalFilename ) || is_file ( sys_get_temp_dir ( ) . '/' . $ originalFilename ) ) { $ uniqueFilename = tempnam ( sys_get_temp_dir ( ) , 'tg' ) ; rename ( $ uniqueFilename , $ uniqueFilename . '.' . $ mediaFileInfo [ 'fileextension' ] ) ; $ mediaFileInfo [ 'filepath' ] = $ uniqueFilename . '.' . $ mediaFileInfo [ 'fileextension' ] ; } else { $ mediaFileInfo [ 'filepath' ] = sys_get_temp_dir ( ) . '/' . $ originalFilename ; } return $ mediaFileInfo ; }
3694	public function getBreadcrumb ( GetBreadcrumbEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ elements = $ this -> storeFactory -> createStore ( ) ; $ this -> getBreadcrumbElements ( $ environment , $ elements ) ; $ event -> setElements ( $ elements -> getElements ( ) ) ; $ event -> stopPropagation ( ) ; }
7954	public function getSpamStats ( $ ipblock , $ spamstate , $ fromdate , $ todate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ipv4 ) throw new BadMethodCallException ( 'Parameter $ipv4 is missing.' ) ; if ( ! $ fromdate ) throw new BadMethodCallException ( 'Parameter $fromdate is missing.' ) ; if ( ! $ todate ) throw new BadMethodCallException ( 'Parameter $todate is missing.' ) ; try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/' . $ ipv4 . '/stats?from=' . urlencode ( $ fromdate ) . '&to=' . urlencode ( $ todate ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
2945	public function removeRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> detach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> detach ( $ role ) ; }
12867	public function init_options ( ) { if ( ! is_array ( $ this -> options ) ) { $ this -> options = array ( ) ; } $ options_id = $ this -> get_id ( '-options' ) ; $ options = get_option ( $ options_id ) ; $ need_update = false ; if ( $ options === false ) { $ need_update = true ; $ options = array ( ) ; } foreach ( $ this -> options as $ key => $ value ) { if ( ! array_key_exists ( $ key , $ options ) ) { $ options [ $ key ] = $ value ; } } if ( ! array_key_exists ( 'latest_used_version' , $ options ) ) { $ options [ 'latest_used_version' ] = $ this -> version ; $ need_update = true ; } if ( $ need_update === true ) { update_option ( $ options_id , $ options ) ; } return $ options ; }
1990	protected function jumpToOrReload ( $ intId , $ strParams = null , $ strForceLang = null ) { if ( $ strForceLang !== null ) { @ trigger_error ( 'Using Frontend::jumpToOrReload() with $strForceLang has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; } global $ objPage ; $ blnForceRedirect = ( $ strParams !== null || $ strForceLang !== null ) ; if ( \ is_array ( $ intId ) ) { $ intId = $ intId [ 'id' ] ?? 0 ; } if ( $ intId > 0 && ( $ intId != $ objPage -> id || $ blnForceRedirect ) && ( $ objNextPage = PageModel :: findPublishedById ( $ intId ) ) !== null ) { $ this -> redirect ( $ objNextPage -> getFrontendUrl ( $ strParams , $ strForceLang ) ) ; } $ this -> reload ( ) ; }
5304	public function getPath ( $ scale = 1 , $ roundPrecision = null , $ flip = 'none' , $ onlyFilled = true , $ xOffset = 0 , $ yOffset = 0 ) { $ path = $ this -> getPathPart ( $ this -> xmlDocument , $ onlyFilled ) ; if ( $ scale !== 1 || $ roundPrecision !== null || $ flip !== 'none' || $ xOffset !== 0 || $ yOffset !== 0 ) { $ path = $ this -> transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset / $ scale , $ yOffset / $ scale ) ; } return trim ( $ path ) ; }
1119	public function scopeLimitDepth ( $ query , $ limit ) { $ depth = $ this -> exists ? $ this -> getDepth ( ) : $ this -> getLevel ( ) ; $ max = $ depth + $ limit ; $ scopes = array ( $ depth , $ max ) ; return $ query -> whereBetween ( $ this -> getDepthColumnName ( ) , array ( min ( $ scopes ) , max ( $ scopes ) ) ) ; }
9249	public function generate ( $ name , array $ parameters = array ( ) , $ absolute = false ) { if ( ! $ this -> initialized ) { $ this -> initialize ( ) ; } $ path = $ this -> routes [ $ name ] ; if ( is_array ( $ path ) ) { $ params = $ path [ 'params' ] ; $ path = $ path [ 'path' ] ; foreach ( $ params as $ param ) { if ( ! isset ( $ parameters [ $ param ] ) ) { throw new \ RuntimeException ( 'Missing required parameter "' . $ param . '". Optional parameters not currently supported' ) ; } $ path = str_replace ( '{' . $ param . '}' , $ parameters [ $ param ] , $ path ) ; } } if ( $ this -> request ) { $ path = $ this -> request -> getBaseUrl ( ) . $ path ; if ( $ absolute ) { $ path = $ this -> request -> getSchemeAndHttpHost ( ) . $ path ; } } return $ path ; }
4600	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Translatable ) { return ; } $ this -> translationService -> translate ( $ entity ) ; }
2590	public function setArrivalDate ( \ DateTime $ arrivalDate ) { $ this -> arrivalDate = ( $ arrivalDate -> format ( 'dmy' ) !== '000000' ) ? $ arrivalDate -> format ( 'dmy' ) : null ; $ time = $ arrivalDate -> format ( 'Hi' ) ; if ( $ time !== '0000' ) { $ this -> arrivalTime = $ time ; } }
8226	protected function validateRegistration ( array $ reg ) { $ isValid = true ; try { $ this -> storage -> checkValidName ( $ reg [ "username" ] ) ; } catch ( \ RuntimeException $ e ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , $ e -> getMessage ( ) ) ; } $ min = $ this -> config [ "nameLenMin" ] ; $ max = $ this -> config [ "nameLenMax" ] ; if ( strlen ( $ reg [ "username" ] ) < $ min || strlen ( $ reg [ "username" ] ) > $ max ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , sprintf ( "Length of a username must be between %d-%d characters." , $ min , $ max ) ) ; } if ( ! filter_var ( $ reg [ "email" ] , FILTER_VALIDATE_EMAIL ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "Email address does not have a valid format." ) ; } if ( null !== $ this -> storage -> getUserByEmail ( $ reg [ "email" ] ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "This email is already in use." ) ; } if ( $ reg [ "password" ] -> get ( ) !== $ reg [ "passwordRepeat" ] -> get ( ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ reg [ "password" ] ) ) { $ isValid = false ; } if ( $ this -> storage -> getUserByName ( $ reg [ "username" ] ) !== null ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The username is already taken." ) ; } return $ isValid ; }
2341	protected function getUsername ( ) { if ( $ this -> strUsername !== null ) { return $ this -> strUsername ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> username ; }
2097	public static function getRegexp ( $ strFormat = null ) { if ( $ strFormat === null ) { $ strFormat = static :: getNumericDateFormat ( ) ; } if ( ! static :: isNumericFormat ( $ strFormat ) ) { throw new \ Exception ( sprintf ( 'Invalid date format "%s"' , $ strFormat ) ) ; } return preg_replace_callback ( '/[a-zA-Z]/' , function ( $ matches ) { $ arrRegexp = array ( 'a' => '(?P<a>am|pm)' , 'A' => '(?P<A>AM|PM)' , 'd' => '(?P<d>0[1-9]|[12][0-9]|3[01])' , 'g' => '(?P<g>[1-9]|1[0-2])' , 'G' => '(?P<G>[0-9]|1[0-9]|2[0-3])' , 'h' => '(?P<h>0[1-9]|1[0-2])' , 'H' => '(?P<H>[01][0-9]|2[0-3])' , 'i' => '(?P<i>[0-5][0-9])' , 'j' => '(?P<j>[1-9]|[12][0-9]|3[01])' , 'm' => '(?P<m>0[1-9]|1[0-2])' , 'n' => '(?P<n>[1-9]|1[0-2])' , 's' => '(?P<s>[0-5][0-9])' , 'Y' => '(?P<Y>[0-9]{4})' , 'y' => '(?P<y>[0-9]{2})' , ) ; return $ arrRegexp [ $ matches [ 0 ] ] ?? $ matches [ 0 ] ; } , preg_quote ( $ strFormat ) ) ; }
9828	public function getCreateAssociationName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s.create' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
3333	public function createGroup ( $ files ) { $ data = array ( 'pub_key' => $ this -> api -> getPublicKey ( ) , ) ; foreach ( $ files as $ i => $ file ) { $ data [ "files[$i]" ] = $ file -> getUrl ( ) ; } $ ch = $ this -> __initRequest ( 'group' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ resp = $ this -> __runRequest ( $ ch ) ; $ group = $ this -> api -> getGroup ( $ resp -> id ) ; return $ group ; }
11658	public static function addEntriesToFile ( $ file , $ entries ) { $ properties = self :: readFromFile ( $ file ) ; foreach ( $ entries as $ key => $ value ) { $ properties [ $ key ] = $ value ; } self :: saveToFile ( $ file , $ properties ) ; }
11767	protected function wipeServerList ( ) { $ this -> reset ( ) ; $ this -> master = null ; $ this -> slaves = array ( ) ; $ this -> pool = array ( ) ; }
7827	public function getSpacedPipe ( $ pipe , $ arrow , $ method ) { $ left = $ this -> getSpacesByWord ( $ pipe ) ; $ arrow = $ this -> addSpacesToArrow ( $ arrow ) ; $ right = $ this -> getSpacesByWord ( $ method ) ; return $ left . $ pipe . $ arrow . $ method . $ right ; }
5105	public function limit ( $ from , $ count ) : IWithLimit { return $ this -> setPart ( CmdUpdate :: PART_LIMIT , true , ( $ from ? array ( $ from , $ count ) : $ count ) ) ; }
3838	protected function build ( IMetaModelDataDefinition $ container ) { $ this -> inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( $ container -> hasDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ) { $ view = $ container -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; } else { return ; } $ panelLayout = $ this -> inputScreen [ 'meta' ] [ 'panelLayout' ] ; if ( empty ( $ panelLayout ) ) { return ; } $ arrRows = StringUtil :: trimsplit ( ';' , $ panelLayout ) ; $ panel = $ view -> getPanelLayout ( ) ; $ panelRows = $ panel -> getRows ( ) ; foreach ( $ arrRows as $ rowNo => $ rowElements ) { if ( $ panelRows -> getRowCount ( ) < ( $ rowNo + 1 ) ) { $ panelRow = $ panelRows -> addRow ( ) ; } else { $ panelRow = $ panelRows -> getRow ( $ rowNo ) ; } $ fields = StringUtil :: trimsplit ( ',' , $ rowElements ) ; $ fields = array_reverse ( $ fields ) ; $ this -> parsePanelRow ( $ fields , $ panelRow ) ; if ( $ panelRow -> getCount ( ) == 0 ) { $ panelRows -> deleteRow ( $ rowNo ) ; } } $ this -> ensureSubmitElement ( $ panelRows ) ; $ this -> inputScreen = null ; }
774	protected function extractMessages ( $ fileName , $ translator , $ ignoreCategories = [ ] ) { $ this -> stdout ( 'Extracting messages from ' ) ; $ this -> stdout ( $ fileName , Console :: FG_CYAN ) ; $ this -> stdout ( "...\n" ) ; $ subject = file_get_contents ( $ fileName ) ; $ messages = [ ] ; $ tokens = token_get_all ( $ subject ) ; foreach ( ( array ) $ translator as $ currentTranslator ) { $ translatorTokens = token_get_all ( '<?php ' . $ currentTranslator ) ; array_shift ( $ translatorTokens ) ; $ messages = array_merge_recursive ( $ messages , $ this -> extractMessagesFromTokens ( $ tokens , $ translatorTokens , $ ignoreCategories ) ) ; } $ this -> stdout ( "\n" ) ; return $ messages ; }
5680	public function getText ( ) { if ( ! $ this -> text ) { $ this -> text = self :: normalise ( $ this -> raw ) ; } return $ this -> text ; }
2907	public function getPartDecodedContent ( Zend_Mime_Part $ mimePart ) { if ( method_exists ( $ mimePart , 'getRawContent' ) ) { return $ mimePart -> getRawContent ( ) ; } $ content = '' ; if ( method_exists ( $ mimePart , 'getContent' ) ) { $ encoding = $ mimePart -> encoding ; $ mimePart -> encoding = 'none' ; $ content = $ mimePart -> getContent ( ) ; $ mimePart -> encoding = $ encoding ; } return $ content ; }
8503	public function setGetCompetitivePricingForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetCompetitivePricingForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6665	public function parseFb ( $ raw_profile ) { $ profile = $ raw_profile ; $ profile -> avatar = sprintf ( 'http://graph.facebook.com/%s/picture' , $ profile -> id ) ; return ( array ) $ profile ; }
2098	public static function formatToJs ( $ strFormat ) { $ chunks = str_split ( $ strFormat ) ; foreach ( $ chunks as $ k => $ v ) { switch ( $ v ) { case 'D' : $ chunks [ $ k ] = 'a' ; break ; case 'j' : $ chunks [ $ k ] = 'e' ; break ; case 'l' : $ chunks [ $ k ] = 'A' ; break ; case 'S' : $ chunks [ $ k ] = 'o' ; break ; case 'F' : $ chunks [ $ k ] = 'B' ; break ; case 'M' : $ chunks [ $ k ] = 'b' ; break ; case 'a' : $ chunks [ $ k ] = 'p' ; break ; case 'A' : $ chunks [ $ k ] = 'p' ; break ; case 'g' : $ chunks [ $ k ] = 'l' ; break ; case 'G' : $ chunks [ $ k ] = 'k' ; break ; case 'h' : $ chunks [ $ k ] = 'I' ; break ; case 'i' : $ chunks [ $ k ] = 'M' ; break ; case 's' : $ chunks [ $ k ] = 'S' ; break ; case 'U' : $ chunks [ $ k ] = 's' ; break ; } } return preg_replace ( '/([a-zA-Z])/' , '%$1' , implode ( '' , $ chunks ) ) ; }
9067	public static function bootUuidForKey ( ) { static :: creating ( function ( $ model ) { $ model -> incrementing = false ; $ model -> attributes [ $ model -> getKeyName ( ) ] = ( string ) Str :: orderedUuid ( ) ; } ) ; }
3641	public function get ( string $ key , $ default = null , bool $ trim = true , bool $ clean = true ) { $ value = $ this -> request -> input ( $ key , $ default ) ; return $ this -> clean ( $ value , $ trim , $ clean ) ; }
9759	function contain ( $ value = null ) : self { if ( $ this -> hasFlag ( 'file' ) ) return $ this -> expect ( @ file_get_contents ( $ this -> target ) , stringContains ( $ value ) ) ; return $ this -> expect ( $ this -> target , is_string ( $ this -> target ) ? stringContains ( $ value ) : contains ( $ value ) ) ; }
10049	private static function toArray ( $ object ) { $ type = gettype ( $ object ) ; if ( $ type == 'array' ) { foreach ( $ object as $ element ) { $ result [ ] = self :: toArray ( $ element ) ; } return $ result ; } else if ( $ type == 'object' ) { if ( is_subclass_of ( $ object , 'AbstractJSONWrapper' ) ) { return $ object -> toArray ( ) ; } else { trigger_error ( "JSONSerializer: Trying to serialize " . get_class ( $ object ) ) ; return $ object ; } } else { return $ object ; } }
11948	public function getSignature ( $ baseString , array $ params ) { unset ( $ params [ 'oauth_signature' ] ) ; if ( $ this -> signature_method === 'HMAC-SHA1' ) { $ result = $ this -> sign_HMAC_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'RSA-SHA1' ) { $ result = $ this -> sign_RSA_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'PLAINTEXT' ) { $ result = $ this -> sign_PLAINTEXT ( $ baseString ) ; } else { throw new ArtaxServiceException ( 'Unknown signature method: ' . $ this -> signature_method ) ; } return base64_encode ( $ result ) ; }
11775	protected function getIsEnabled ( ) : \ Illuminate \ Database \ Eloquent \ Model { $ result = Model \ Setting :: find ( 1 ) ; $ result -> value = ( bool ) $ result -> value ; return $ result ; }
3904	public function handle ( GetOptionsEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getPropertyName ( ) ) || ( 'dca_id' !== $ event -> getSubPropertyName ( ) ) ) { return ; } $ screens = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' ) -> addSelect ( 'name' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ event -> getModel ( ) -> getProperty ( 'id' ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; foreach ( $ screens as $ screen ) { $ result [ $ screen [ 'id' ] ] = $ screen [ 'name' ] ; } $ event -> setOptions ( $ result ) ; }
1084	private function expectKeyword ( $ value ) { $ token = $ this -> lexer -> token ; if ( $ token -> kind === Token :: NAME && $ token -> value === $ value ) { $ this -> lexer -> advance ( ) ; return $ token ; } throw new SyntaxError ( $ this -> lexer -> source , $ token -> start , 'Expected "' . $ value . '", found ' . $ token -> getDescription ( ) ) ; }
954	protected function returnTo ( ) { $ return_to = Session :: get ( 'return_to' ) ; if ( $ return_to ) { Session :: forget ( 'return_to' ) ; return Redirect :: to ( $ return_to ) ; } return Redirect :: route ( 'home' ) ; }
4153	public function invalidateBearerToken ( ) { $ url = $ this -> getInvalidateBearerTokenUrl ( ) ; $ bearerToken = $ this -> bearerToken ; if ( $ bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } $ params = array ( 'post' => array ( 'access_token' => $ bearerToken ) , 'headers' => $ this -> buildBearerTokenHeader ( ) , ) ; $ response = $ this -> curl -> send ( $ url , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> access_token ) || $ obj -> access_token != $ bearerToken ) { $ this -> findExceptions ( $ response ) ; } unset ( $ url , $ bearerToken , $ params , $ response , $ obj ) ; return true ; }
595	private function deletePublishedAssets ( $ bundles ) { $ this -> stdout ( "Deleting source files...\n" ) ; if ( $ this -> getAssetManager ( ) -> linkAssets ) { $ this -> stdout ( "`AssetManager::linkAssets` option is enabled. Deleting of source files canceled.\n" , Console :: FG_YELLOW ) ; return ; } foreach ( $ bundles as $ bundle ) { if ( $ bundle -> sourcePath !== null ) { foreach ( $ bundle -> js as $ jsFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ jsFile ) ; } foreach ( $ bundle -> css as $ cssFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ cssFile ) ; } } } $ this -> stdout ( "Source files deleted.\n" , Console :: FG_GREEN ) ; }
2174	private function setUpDatabaseConnection ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( false !== getenv ( 'DATABASE_URL' ) ) { return $ this -> render ( 'misconfigured_database_url.html.twig' ) ; } $ parameters = [ 'parameters' => [ 'database_host' => $ this -> getContainerParameter ( 'database_host' ) , 'database_port' => $ this -> getContainerParameter ( 'database_port' ) , 'database_user' => $ this -> getContainerParameter ( 'database_user' ) , 'database_password' => $ this -> getContainerParameter ( 'database_password' ) , 'database_name' => $ this -> getContainerParameter ( 'database_name' ) , ] , ] ; if ( 'tl_database_login' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'database.html.twig' , $ parameters ) ; } $ parameters = [ 'parameters' => [ 'database_host' => $ request -> request -> get ( 'dbHost' ) , 'database_port' => $ request -> request -> get ( 'dbPort' ) , 'database_user' => $ request -> request -> get ( 'dbUser' ) , 'database_password' => $ this -> getContainerParameter ( 'database_password' ) , 'database_name' => $ request -> request -> get ( 'dbName' ) , ] , ] ; if ( '*****' !== $ request -> request -> get ( 'dbPassword' ) ) { $ parameters [ 'parameters' ] [ 'database_password' ] = $ request -> request -> get ( 'dbPassword' ) ; } if ( false !== strpos ( $ parameters [ 'parameters' ] [ 'database_name' ] , '.' ) ) { return $ this -> render ( 'database.html.twig' , array_merge ( $ parameters , [ 'database_error' => $ this -> trans ( 'database_dot_in_dbname' ) ] ) ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ installTool -> setConnection ( ConnectionFactory :: create ( $ parameters ) ) ; if ( ! $ installTool -> canConnectToDatabase ( $ parameters [ 'parameters' ] [ 'database_name' ] ) ) { return $ this -> render ( 'database.html.twig' , array_merge ( $ parameters , [ 'database_error' => $ this -> trans ( 'database_could_not_connect' ) ] ) ) ; } $ dumper = new ParameterDumper ( $ this -> getContainerParameter ( 'kernel.project_dir' ) ) ; $ dumper -> setParameters ( $ parameters ) ; $ dumper -> dump ( ) ; $ this -> purgeSymfonyCache ( ) ; return $ this -> getRedirectResponse ( ) ; }
2782	public function renderShadowMark ( $ count , $ current , $ eolInterval = 60 ) { $ this -> progressCount ++ ; $ this -> write ( '<fg=blue;options=bold>S</fg=blue;options=bold>' , false ) ; if ( ( $ this -> progressCount % $ eolInterval ) == 0 ) { $ counter = str_pad ( $ this -> progressCount , 5 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( ' |' . $ counter . ' (' . str_pad ( $ current , strlen ( $ count ) , ' ' , STR_PAD_LEFT ) . '/' . $ count . ')' . PHP_EOL , false ) ; } }
7543	function getSibling ( $ offset = 1 ) { $ index = $ this -> index ( ) + $ offset ; if ( ( $ index >= 0 ) && ( $ index < $ this -> parent -> childCount ( ) ) ) { return $ this -> parent -> getChild ( $ index ) ; } else { return null ; } }
8410	public function connect ( ) { if ( $ this -> isConnected ( ) === false ) { try { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'all' ] ) ; $ this -> servers [ 'all' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'all' ] [ 'user' ] , $ this -> servers [ 'all' ] [ 'pass' ] ) ; } else { $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'read' ] ) ; $ this -> servers [ 'read' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'read' ] [ 'user' ] , $ this -> servers [ 'read' ] [ 'pass' ] ) ; $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'write' ] ) ; $ this -> servers [ 'write' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'write' ] [ 'user' ] , $ this -> servers [ 'write' ] [ 'pass' ] ) ; } } catch ( \ PDOException $ e ) { throw new ExternalLink ( 'can\'t connect to database (' . $ e -> getMessage ( ) . ')' ) ; } } }
12037	function generate ( ) { if ( $ this -> namespace ) { $ fqcn = $ this -> namespace . '\\' . $ this -> className ; } else { $ fqcn = $ this -> className ; } $ this -> addProperties ( ) ; $ this -> addConstructorMethod ( ) ; $ this -> addSetAPIMethod ( ) ; $ this -> addSetParameterMethod ( ) ; $ this -> addCheckScopeMethod ( ) ; $ this -> addAccessorMethods ( ) ; $ this -> addFilteredParameterMethod ( ) ; $ this -> addCreateRequestMethod ( ) ; $ this -> addCreateAndExecuteMethod ( ) ; $ this -> addCallMethod ( ) ; $ this -> addExecuteMethod ( ) ; $ this -> addExecuteAsyncMethod ( ) ; $ this -> addDispatchMethod ( ) ; $ this -> addDispatchAsyncMethod ( ) ; $ this -> addProcessResponseMethod ( ) ; $ this -> addShouldResponseBeProcessedMethod ( ) ; $ this -> addTranslateResponseToExceptionMethod ( ) ; $ this -> addShouldUseCachedResponseMethod ( ) ; $ this -> addShouldResponseBeCachedMethod ( ) ; $ this -> addSetOriginalResponseMethod ( ) ; $ this -> addGetOriginalResponseMethod ( ) ; $ this -> addGetResultInstantiationInfoMethod ( ) ; $ this -> classGenerator -> setImplementedInterfaces ( [ 'ArtaxServiceBuilder\Operation' ] ) ; $ this -> classGenerator -> setFQCN ( $ fqcn ) ; $ text = $ this -> classGenerator -> generate ( ) ; saveFile ( $ this -> outputPath , $ fqcn , $ text ) ; }
2885	public function saveProfiling ( ) { if ( ! $ this -> canCollect ( ) || ! Mage :: helper ( 'sheep_debug' ) -> canPersist ( ) ) { return ; } if ( Mage :: helper ( 'sheep_debug' ) -> hasDisablePersistenceCookie ( ) ) { return ; } if ( ! $ this -> getRequestInfo ( ) -> getIsStarted ( ) ) { return ; } $ this -> getRequestInfo ( ) -> save ( ) ; }
10245	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; if ( isset ( $ xmlElement -> last_type ) ) $ this -> lastType = $ xmlElement -> last_type ; if ( isset ( $ xmlElement -> count ) ) $ this -> count = $ xmlElement -> count ; if ( isset ( $ xmlElement -> count_hard ) ) $ this -> countHard = $ xmlElement -> count_hard ; if ( isset ( $ xmlElement -> count_soft ) ) $ this -> countSoft = $ xmlElement -> count_soft ; }
6054	public function createFolder ( Folder $ folder , $ parentId = 0 , $ inheritAccess = null ) { $ parameters = [ 'query' => [ 'parentId' => $ parentId ] , 'body' => json_encode ( [ 'folder' => $ folder , 'inheritAccess' => $ inheritAccess ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
5063	public function outputJson ( int $ depth = 512 , int $ options = 0 ) { $ json = json_decode ( $ this -> output ( ) , false , $ depth , $ options ) ; if ( is_null ( $ json ) ) { $ errorMessage = json_last_error_msg ( ) ; throw new JsonDecodeException ( $ errorMessage ) ; } return $ json ; }
401	public static function processParagraph ( $ markdown , $ flavor = null ) { $ parser = static :: getParser ( $ flavor ) ; return $ parser -> parseParagraph ( $ markdown ) ; }
5115	public function submitArticle ( Article $ article ) : \ One \ Model \ Article { $ responseArticle = $ this -> post ( self :: ARTICLE_ENDPOINT , $ this -> normalizePayload ( $ article -> getCollection ( ) ) ) ; $ responseArticle = json_decode ( $ responseArticle , true ) ; $ article -> setId ( ( string ) $ responseArticle [ 'data' ] [ 'id' ] ) ; foreach ( $ article -> getPossibleAttachment ( ) as $ field ) { if ( $ article -> hasAttachment ( $ field ) ) { foreach ( $ article -> getAttachmentByField ( $ field ) as $ attachment ) { $ this -> submitAttachment ( $ article -> getId ( ) , $ attachment , $ field ) ; } } } return $ article ; }
7997	public static function getSpecificationString ( $ reversed = false ) { $ reflection = new ReflectionClass ( get_class ( ) ) ; $ constants = $ reflection -> getConstants ( ) ; if ( $ reversed ) { $ constants = array_reverse ( $ constants ) ; } $ string = '' ; foreach ( $ constants as $ name => $ int_val ) { $ binary_val_string = base_convert ( ( string ) $ int_val , '10' , '2' ) ; $ string .= sprintf ( '0b%s : %s' , str_pad ( $ binary_val_string , 32 , '0' , STR_PAD_LEFT ) , $ name ) ; $ string .= PHP_EOL ; } return $ string ; }
9800	public static function setChartRenderer ( $ rendererClass ) { if ( ! is_a ( $ rendererClass , IRenderer :: class , true ) ) { throw new Exception ( 'Chart renderer must implement ' . IRenderer :: class ) ; } self :: $ chartRenderer = $ rendererClass ; }
9590	public function radioWithGap ( $ options = [ ] , $ enclosedByLabel = true ) { Html :: addCssClass ( $ options , $ this -> radioGapCssClass ) ; return self :: radio ( $ options , $ enclosedByLabel ) ; }
86	public function archive ( PackageInterface $ package , $ format , $ targetDir , $ fileName = null , $ ignoreFilters = false ) { if ( empty ( $ format ) ) { throw new \ InvalidArgumentException ( 'Format must be specified' ) ; } $ usableArchiver = null ; foreach ( $ this -> archivers as $ archiver ) { if ( $ archiver -> supports ( $ format , $ package -> getSourceType ( ) ) ) { $ usableArchiver = $ archiver ; break ; } } if ( null === $ usableArchiver ) { throw new \ RuntimeException ( sprintf ( 'No archiver found to support %s format' , $ format ) ) ; } $ filesystem = new Filesystem ( ) ; if ( null === $ fileName ) { $ packageName = $ this -> getPackageFilename ( $ package ) ; } else { $ packageName = $ fileName ; } $ filesystem -> ensureDirectoryExists ( $ targetDir ) ; $ target = realpath ( $ targetDir ) . '/' . $ packageName . '.' . $ format ; $ filesystem -> ensureDirectoryExists ( dirname ( $ target ) ) ; if ( ! $ this -> overwriteFiles && file_exists ( $ target ) ) { return $ target ; } if ( $ package instanceof RootPackageInterface ) { $ sourcePath = realpath ( '.' ) ; } else { $ sourcePath = sys_get_temp_dir ( ) . '/composer_archive' . uniqid ( ) ; $ filesystem -> ensureDirectoryExists ( $ sourcePath ) ; try { $ this -> downloadManager -> download ( $ package , $ sourcePath ) ; } catch ( \ Exception $ e ) { $ filesystem -> removeDirectory ( $ sourcePath ) ; throw $ e ; } if ( file_exists ( $ composerJsonPath = $ sourcePath . '/composer.json' ) ) { $ jsonFile = new JsonFile ( $ composerJsonPath ) ; $ jsonData = $ jsonFile -> read ( ) ; if ( ! empty ( $ jsonData [ 'archive' ] [ 'exclude' ] ) ) { $ package -> setArchiveExcludes ( $ jsonData [ 'archive' ] [ 'exclude' ] ) ; } } } $ tempTarget = sys_get_temp_dir ( ) . '/composer_archive' . uniqid ( ) . '.' . $ format ; $ filesystem -> ensureDirectoryExists ( dirname ( $ tempTarget ) ) ; $ archivePath = $ usableArchiver -> archive ( $ sourcePath , $ tempTarget , $ format , $ package -> getArchiveExcludes ( ) , $ ignoreFilters ) ; $ filesystem -> rename ( $ archivePath , $ target ) ; if ( ! $ package instanceof RootPackageInterface ) { $ filesystem -> removeDirectory ( $ sourcePath ) ; } $ filesystem -> remove ( $ tempTarget ) ; return $ target ; }
9315	public function checkAcceptHeader ( Request $ request ) { $ headers = $ request -> getAcceptableContentTypes ( ) ; if ( array_intersect ( $ headers , [ 'application/json' , 'text/json' ] ) ) { return 'json' ; } elseif ( array_intersect ( $ headers , [ 'application/xml' , 'text/xml' ] ) ) { return 'xml' ; } return $ this -> defaultAcceptType ; }
450	public static function encode ( $ value , $ options = 320 ) { $ expressions = [ ] ; $ value = static :: processData ( $ value , $ expressions , uniqid ( '' , true ) ) ; set_error_handler ( function ( ) { static :: handleJsonError ( JSON_ERROR_SYNTAX ) ; } , E_WARNING ) ; $ json = json_encode ( $ value , $ options ) ; restore_error_handler ( ) ; static :: handleJsonError ( json_last_error ( ) ) ; return $ expressions === [ ] ? $ json : strtr ( $ json , $ expressions ) ; }
3530	public static function sendUnrealClientPostRequest ( $ endpoint , $ params = null , $ authorization = self :: EPIC_LAUNCHER_AUTHORIZATION , $ oauth = false ) { $ client = new Client ( [ 'http_errors' => false ] ) ; try { $ response = $ client -> post ( $ endpoint , [ 'form_params' => $ params , 'headers' => [ 'User-Agent' => self :: UNREAL_CLIENT_USER_AGENT , 'Authorization' => ( ! $ oauth ) ? 'basic ' . $ authorization : 'bearer ' . $ authorization , 'X-Epic-Device-ID' => self :: generateDeviceId ( ) ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
10391	protected static function getSysTempDir ( ) { if ( function_exists ( 'sys_get_temp_dir' ) ) { return sys_get_temp_dir ( ) ; } else if ( $ tmp = getenv ( 'TMP' ) ) { return $ tmp ; } else if ( $ tmp = getenv ( 'TEMP' ) ) { return $ tmp ; } else if ( $ tmp = getenv ( 'TMPDIR' ) ) { return $ tmp ; } return '/tmp' ; }
5415	public function fetch ( $ timeout ) { $ socket = $ this -> route -> createConnection ( $ this -> encoding -> getMethod ( ) , $ timeout ) ; if ( ! $ socket -> isError ( ) ) { $ this -> dispatchRequest ( $ socket , $ this -> encoding ) ; } return $ this -> createResponse ( $ socket ) ; }
10942	private function reset ( ) { $ time = new \ DateTime ( ) ; $ this -> driver -> set ( self :: LAST_UPDATE_KEY , $ time ) ; return $ time ; }
1417	public function failedValidator ( ValidatorContract $ validator , \ Closure $ closure = null ) : ErrorCollection { $ failed = $ this -> doesIncludeFailed ( ) ? $ validator -> failed ( ) : [ ] ; $ errors = new ErrorCollection ( ) ; foreach ( $ validator -> errors ( ) -> messages ( ) as $ key => $ messages ) { $ failures = $ this -> createValidationFailures ( $ failed [ $ key ] ?? [ ] ) ; foreach ( $ messages as $ detail ) { $ failed = $ failures -> shift ( ) ? : [ ] ; if ( $ closure ) { $ errors -> add ( $ this -> call ( $ closure , $ key , $ detail , $ failed ) ) ; continue ; } $ errors -> add ( new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'failed_validator' , 'code' ) , $ this -> trans ( 'failed_validator' , 'title' ) , $ detail ? : $ this -> trans ( 'failed_validator' , 'detail' ) ) ) ; } } return $ errors ; }
3626	protected function getDefaultSerial ( $ serial_number ) { if ( empty ( $ serial_number ) ) { $ devices_serials = $ this -> getDevices ( ) ; if ( count ( $ devices_serials ) == 0 ) { $ devices_serials = $ this -> getDevices ( DEVICE_TYPE_PROTECT ) ; } $ serial_number = $ devices_serials [ 0 ] ; } return $ serial_number ; }
6375	public function first ( ) : Optional { try { return Optional :: ofNullable ( $ this -> get ( 0 ) ) ; } catch ( OutOfBoundsException $ e ) { return Optional :: absent ( ) ; } }
1953	public static function findActiveBySourceAndParent ( $ strSource , $ intParent , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.source=? AND $t.parent=? AND $t.active='1'" ) , array ( $ strSource , $ intParent ) , $ arrOptions ) ; }
8478	public function log ( $ level , $ message , array $ context = [ ] ) { if ( $ this -> config ( 'requiredScope' ) && ( empty ( $ context [ 'scope' ] ) ) ) return false ; $ scopes = ( empty ( $ context [ 'scope' ] ) ) ? [ null ] : $ context [ 'scope' ] ; unset ( $ context [ 'scope' ] ) ; $ this -> _context = $ context ; $ Table = TableRegistry :: get ( $ this -> config ( 'model' ) , [ 'table' => $ this -> config ( 'table' ) ] ) ; foreach ( $ scopes as $ scope ) { $ entity = $ Table -> newEntity ( ) ; $ data = [ 'level' => $ level , 'user_id' => $ this -> _userId ( ) , 'scope' => $ scope , 'message' => $ message , 'context' => $ this -> _context , ] ; $ entity = $ Table -> patchEntity ( $ entity , $ data ) ; $ Table -> save ( $ entity ) ; } return true ; }
4537	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Uuidentifiable ) { return ; } $ this -> idService -> generateUuid ( $ entity ) ; }
1606	public function findRedirectByPath ( $ path ) { $ redirects = $ this -> findAllRedirects ( true ) ; foreach ( $ redirects as $ redirect ) { $ to = false ; if ( trim ( $ redirect [ 'uri' ] , '/' ) == $ path ) $ to = $ redirect [ 'to' ] ; elseif ( $ uri = $ this -> _isRedirectRegex ( $ redirect [ 'uri' ] ) ) if ( preg_match ( $ uri , $ path ) ) $ to = preg_replace ( $ uri , $ redirect [ 'to' ] , $ path ) ; if ( $ to ) { return [ 'to' => strpos ( $ to , '://' ) !== false ? $ to : UrlHelper :: siteUrl ( $ to ) , 'type' => $ redirect [ 'type' ] , ] ; } } return false ; }
11920	public function onPageRemoved ( PageCollectionRemovedEvent $ event ) { $ pageName = basename ( $ event -> getFilePath ( ) ) ; $ page = $ this -> pagesParser -> contributor ( $ event -> getUsername ( ) ) -> parse ( ) -> page ( $ pageName ) ; if ( null === $ page ) { return ; } foreach ( $ page [ "seo" ] as $ seo ) { $ permalink = $ seo [ "permalink" ] ; $ this -> permalinkManager -> remove ( $ permalink ) ; } $ this -> permalinkManager -> save ( ) ; }
787	public function formName ( ) { $ reflector = new ReflectionClass ( $ this ) ; if ( PHP_VERSION_ID >= 70000 && $ reflector -> isAnonymous ( ) ) { throw new InvalidConfigException ( 'The "formName()" method should be explicitly defined for anonymous models' ) ; } return $ reflector -> getShortName ( ) ; }
11317	public function note ( string $ message ) : void { $ this -> logger -> log ( $ this -> level , strip_tags ( $ message ) ) ; }
8332	public function listSequences ( $ database = null ) { $ query = "SELECT name FROM sysobjects WHERE xtype = 'U'" ; $ tableNames = $ this -> _conn -> fetchAll ( $ query ) ; return array_map ( [ $ this -> _conn -> formatter , 'fixSequenceName' ] , $ tableNames ) ; }
7102	public static function site ( string $ uri = '' , $ protocol = null ) : string { $ path = preg_replace ( '~^[-a-z0-9+.]++://[^/]++/?~' , '' , trim ( $ uri , '/' ) ) ; if ( preg_match ( '/[^\x00-\x7F]/S' , $ path ) ) { $ path = preg_replace_callback ( '~([^/]+)~' , '\mii\util\URL::_rawurlencode_callback' , $ path ) ; } return URL :: base ( $ protocol ) . $ path ; }
3547	public function boot ( ) { $ this -> loadViewsFrom ( realpath ( __DIR__ . '/../views' ) , 'entrust-gui' ) ; $ this -> setupRoutes ( $ this -> app -> router ) ; $ this -> loadTranslationsFrom ( realpath ( __DIR__ . '/../translations' ) , 'entrust-gui' ) ; $ this -> publishes ( [ __DIR__ . '/../config/entrust-gui.php' => config_path ( 'entrust-gui.php' ) ] , 'config' ) ; $ this -> publishes ( [ __DIR__ . '/../views' => base_path ( 'resources/views/vendor/entrust-gui' ) ] , 'views' ) ; $ this -> publishes ( [ __DIR__ . '/../translations' => base_path ( 'resources/lang/vendor/entrust-gui' ) ] , 'translations' ) ; $ this -> commands ( 'command.entrust-gui.models' ) ; }
11571	public function onBlockEditing ( BlockEditingEvent $ event ) { $ encodedBlock = $ event -> getFileContent ( ) ; $ htmlBlock = $ this -> pageProductionRenderer -> renderBlock ( $ encodedBlock ) ; $ this -> permalinkManager -> add ( $ event -> getFilePath ( ) , $ htmlBlock ) -> save ( ) ; }
3995	public function replaceTags ( $ strTag ) { $ arrElements = explode ( '::' , $ strTag ) ; if ( $ arrElements [ 0 ] != 'mm' ) { return false ; } try { switch ( $ arrElements [ 1 ] ) { case 'total' : return $ this -> getCount ( $ arrElements [ 2 ] , $ arrElements [ 3 ] ) ; case 'attribute' : return $ this -> getAttribute ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; case 'item' : return $ this -> getItem ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; case 'jumpTo' : return $ this -> jumpTo ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; default : } } catch ( \ Exception $ exc ) { System :: log ( 'Error by replace tags: ' . $ exc -> getMessage ( ) , __CLASS__ . ' | ' . __FUNCTION__ , TL_ERROR ) ; } return false ; }
4150	protected function getBinaryFile ( $ filename ) { if ( ! file_exists ( $ filename ) ) { throw new FileNotFoundException ; } if ( ! is_readable ( $ filename ) ) { throw new FileNotReadableException ; } ob_start ( ) ; readfile ( $ filename ) ; $ binary = ob_get_contents ( ) ; ob_end_clean ( ) ; unset ( $ filename ) ; return $ binary ; }
1035	private function completeLeafValue ( LeafType $ returnType , & $ result ) { try { return $ returnType -> serialize ( $ result ) ; } catch ( Exception $ error ) { throw new InvariantViolation ( 'Expected a value of type "' . Utils :: printSafe ( $ returnType ) . '" but received: ' . Utils :: printSafe ( $ result ) , 0 , $ error ) ; } catch ( Throwable $ error ) { throw new InvariantViolation ( 'Expected a value of type "' . Utils :: printSafe ( $ returnType ) . '" but received: ' . Utils :: printSafe ( $ result ) , 0 , $ error ) ; } }
3669	public function getCurrentFilterUrl ( $ options = null ) : FilterUrl { $ this -> addFromCurrentRequest ( $ filterUrl = new FilterUrl ( ) , $ options ) ; return $ filterUrl ; }
12303	protected function generateSiteMap ( ) { $ urls = array ( ) ; $ siteName = $ this -> configurationHandler -> siteName ( ) ; foreach ( $ this -> pagesCollectionParser -> pages ( ) as $ page ) { foreach ( $ page [ "seo" ] as $ seo ) { $ urls [ ] = array ( 'href' => $ siteName . '/' . $ seo [ "permalink" ] , 'frequency' => $ seo [ "sitemap_frequency" ] , 'priority' => $ seo [ "sitemap_priority" ] , ) ; } } return $ this -> twig -> render ( 'RedKiteCms/Resources/views/Sitemap/sitemap.html.twig' , array ( 'urls' => $ urls ) ) ; }
7271	public function delete ( ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; if ( isset ( $ this -> $ idColumn ) ) { $ status = Db :: query ( " delete from $tableName where $idColumn = :id " , [ "id" => $ this -> $ idColumn ] , static :: getDbName ( ) , false ) ; } else { $ condition = "" ; $ params = [ ] ; foreach ( $ columns as $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( isset ( $ this -> $ name ) ) { $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } } $ condition = substr ( $ condition , 0 , - 5 ) ; var_dump ( " delete from $tableName where $condition " ) ; var_dump ( $ params ) ; $ status = Db :: query ( " delete from $tableName where $condition " , $ params , static :: getDbName ( ) , false ) ; } return $ status !== false && $ status > 0 ; }
7328	private function configureVatNumberSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Pricing \ Model \ VatNumberSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> vatNumberSubjectClassCache ) ) { return ; } $ this -> addMappings ( $ metadata , $ this -> getVatNumberSubjectMappings ( ) ) ; $ this -> vatNumberSubjectClassCache [ ] = $ class ; }
1593	protected function validateTypeAndId ( ) : bool { if ( ! ( $ this -> validateType ( ) && $ this -> validateId ( ) ) ) { return false ; } $ type = $ this -> dataGet ( 'type' ) ; $ id = $ this -> dataGet ( 'id' ) ; if ( $ id && ! $ this -> isNotFound ( $ type , $ id ) ) { $ this -> resourceExists ( $ type , $ id ) ; return false ; } return true ; }
10422	public function addToInsertList ( $ key , $ value , $ isString = true ) { $ this -> sqlInsertList [ $ key ] = [ 'value' => $ value , 'string' => $ isString , ] ; }
7065	public function getAuthActions ( ) { if ( ! $ this -> _AuthActions ) { if ( Configure :: load ( 'auth_actions' ) === false ) { trigger_error ( 'AuthActions: Could not load config/auth_actions.php' , E_USER_WARNING ) ; } $ actionConfig = Configure :: read ( 'auth_actions' ) ; $ publicActionsConfig = Configure :: read ( 'public_actions' ) ; $ options = Configure :: read ( 'auth_settings' ) ; if ( ! is_array ( $ options ) ) { $ options = [ ] ; } if ( ! is_array ( $ publicActionsConfig ) ) { $ publicActionsConfig = [ ] ; } $ this -> _AuthActions = new AuthActions ( $ actionConfig , $ publicActionsConfig , $ options ) ; } return $ this -> _AuthActions ; }
9147	private function open ( ) { $ this -> handle = @ socket_create ( AF_INET , SOCK_STREAM , SOL_TCP ) ; if ( ! is_resource ( $ this -> handle ) ) { $ code = socket_last_error ( ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
424	protected function adjustLabelFor ( $ options ) { if ( ! isset ( $ options [ 'id' ] ) ) { return ; } $ this -> _inputId = $ options [ 'id' ] ; if ( ! isset ( $ this -> labelOptions [ 'for' ] ) ) { $ this -> labelOptions [ 'for' ] = $ options [ 'id' ] ; } }
896	private function findComparisonStart ( Tokens $ tokens , $ index ) { -- $ index ; $ nonBlockFound = false ; while ( 0 <= $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { -- $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { -- $ index ; $ nonBlockFound = true ; continue ; } if ( $ block [ 'isStart' ] || ( $ nonBlockFound && Tokens :: BLOCK_TYPE_CURLY_BRACE === $ block [ 'type' ] ) ) { break ; } $ index = $ tokens -> findBlockStart ( $ block [ 'type' ] , $ index ) - 1 ; } return $ tokens -> getNextMeaningfulToken ( $ index ) ; }
8670	public static function fromRecursive ( $ collection ) { $ arr = Arr :: from ( $ collection ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return new static ( $ arr ) ; }
4751	public function getPriceByPlanCode ( string $ planCode ) : float { $ plan = $ this -> getPlan ( $ planCode ) ; return ( array_key_exists ( 'recurring_price' , $ plan ) ) ? $ plan [ 'recurring_price' ] : 0 ; }
253	protected function freeze ( ) { if ( $ this -> getIsActive ( ) ) { if ( isset ( $ _SESSION ) ) { $ this -> frozenSessionData = $ _SESSION ; } $ this -> close ( ) ; Yii :: info ( 'Session frozen' , __METHOD__ ) ; } }
4483	public function requeue ( string $ queue ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'queue' , $ queue ) ) { $ this -> setQueue ( $ queue ) ; } }
11864	public function save ( string $ sessionIdentifier , string $ sessionData ) : void { self :: $ files [ $ sessionIdentifier ] = [ 'data' => $ sessionData , 'time' => microtime ( true ) ] ; }
7213	public function configure ( $ subject ) { if ( $ subject instanceof InvoiceInterface ) { $ this -> date = $ subject -> getCreatedAt ( ) -> format ( 'Y-m-d' ) ; } elseif ( $ subject instanceof PaymentInterface ) { $ this -> date = $ subject -> getCompletedAt ( ) -> format ( 'Y-m-d' ) ; } else { throw new InvalidArgumentException ( "Expected instance of " . InvoiceInterface :: class . " or " . PaymentInterface :: class ) ; } $ this -> number = $ subject -> getNumber ( ) ; $ sale = $ subject -> getSale ( ) ; if ( $ customer = $ sale -> getCustomer ( ) ) { $ this -> identity = $ customer -> getFirstName ( ) . ' ' . $ customer -> getLastName ( ) ; } else { $ this -> identity = $ sale -> getFirstName ( ) . ' ' . $ sale -> getLastName ( ) ; } }
8784	protected function log ( $ level , $ message ) { if ( is_array ( $ message ) || is_object ( $ message ) ) { $ message = print_r ( $ message , true ) ; } $ text = '[' . date ( $ this -> timeFormat , time ( ) ) . '] - [' . strtoupper ( $ level ) . '] - [' . http ( ) -> getClientIP ( ) . '] . $ message ; $ this -> save ( $ text ) ; }
2203	public static function decodeEntities ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: decodeEntities ( $ v ) ; } return $ varValue ; } $ varValue = static :: preserveBasicEntities ( $ varValue ) ; $ varValue = html_entity_decode ( $ varValue , ENT_QUOTES , Config :: get ( 'characterSet' ) ) ; return $ varValue ; }
240	private function saveTableMetadataToCache ( $ cache , $ name ) { if ( $ cache === null ) { return ; } $ metadata = $ this -> _tableMetadata [ $ name ] ; $ metadata [ 'cacheVersion' ] = static :: SCHEMA_CACHE_VERSION ; $ cache -> set ( $ this -> getCacheKey ( $ name ) , $ metadata , $ this -> db -> schemaCacheDuration , new TagDependency ( [ 'tags' => $ this -> getCacheTag ( ) ] ) ) ; }
3808	protected function translateProperty ( $ property , $ metaModel , $ legend ) { $ attribute = $ metaModel -> getAttributeById ( $ property [ 'attr_id' ] ) ; if ( ! $ attribute ) { return false ; } $ propName = $ attribute -> getColName ( ) ; $ this -> legends [ $ legend ] [ 'properties' ] [ ] = $ propName ; $ this -> properties [ $ propName ] = array ( 'info' => $ attribute -> getFieldDefinition ( $ property ) , ) ; return true ; }
2038	private function applyLegacyLogic ( $ strUrl , $ strParams ) { if ( strpos ( $ strParams , '%' ) !== false ) { @ trigger_error ( 'Using sprintf placeholders in URLs has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ arrMatches = array ( ) ; preg_match_all ( '/%([sducoxXbgGeEfF])/' , $ strParams , $ arrMatches ) ; foreach ( array_unique ( $ arrMatches [ 1 ] ) as $ v ) { $ strUrl = str_replace ( '%25' . $ v , '%' . $ v , $ strUrl ) ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateFrontendUrl' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateFrontendUrl' ] ) ) { @ trigger_error ( 'Using the "generateFrontendUrl" hook has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateFrontendUrl' ] as $ callback ) { $ strUrl = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ this -> row ( ) , $ strParams , $ strUrl ) ; } return $ strUrl ; } return $ strUrl ; }
7399	public function redirect ( string $ url = '' , int $ statusCode = 302 ) { $ this -> is404 = false ; $ server = filter_input_array ( INPUT_SERVER ) ; if ( '' == $ url && isset ( $ server [ 'REQUEST_URI' ] ) ) { $ url = '/' . trim ( $ server [ 'REQUEST_URI' ] , '/' ) ; preg_match ( '/^[\\a-zA-Z0-9-\._~:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=%]*$/iD' , $ url , $ match ) ; $ url = $ match [ 1 ] ?? '' ; } if ( ! headers_sent ( ) ) { header ( 'Location: ' . $ url , true , $ statusCode ) ; } echo sprintf ( '<!DOCTYPE html><html> <head> <meta charset="UTF-8" /> <meta http-equiv="refresh" content="0;url=%1$s" /> <title>Redirecting to %1$s</title> </head> <body> <script type="text/javascript"> window.location.href = "%1$s"; </script> Redirecting to <a href="%1$s">%1$s</a>. </body></html>' , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' ) ) ; }
11243	public function setDirection ( Neuron_GameServer_Map_Vector3 $ start , Neuron_GameServer_Map_Vector3 $ end ) { $ this -> startRotation = $ start ; $ this -> endRotation = $ end ; }
8262	protected function isValidCallback ( Request $ httpRequest ) { return $ this -> session -> has ( "provider" ) && $ httpRequest -> query -> has ( "state" ) && $ this -> session -> has ( "oauth2state" ) && is_string ( $ this -> session -> get ( "oauth2state" ) ) && ( strlen ( $ this -> session -> get ( "oauth2state" ) ) > 0 ) ; }
4867	public function fail ( JobInterface $ job , array $ options = [ ] ) { $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; unset ( $ envelope [ 'scheduled' ] ) ; $ envelope [ 'status' ] = self :: STATUS_FAILED ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectId ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
6514	public function invoke ( JobInterface $ job , ContextInterface $ context ) { $ jobType = $ this -> registry -> get ( $ job -> getType ( ) ) ; $ callableArray = $ jobType -> getCallable ( ) ; $ parameters = static :: resolveParameters ( $ jobType , $ context , $ job -> getParameters ( ) ) ; if ( is_array ( $ callableArray ) && $ callable = $ callableArray [ 0 ] ) { if ( $ callable instanceof JobAwareInterface ) { $ callable -> setJob ( $ job ) ; } if ( $ callable instanceof ManagerAwareInterface ) { $ callable -> setManager ( $ this -> manager ) ; } if ( $ callable instanceof ControllerAwareInterface ) { $ callable -> setController ( $ this -> controllerFactory -> create ( $ job ) ) ; } if ( $ callable instanceof LoggerAwareInterface && $ context -> has ( 'abc.logger' ) ) { $ callable -> setLogger ( $ context -> get ( 'abc.logger' ) ) ; } } return call_user_func_array ( $ callableArray , $ parameters ) ; }
812	private function fixSpaceBelowClassMethod ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ elementEndIndex ) ; $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; }
6945	protected function watch ( OrderPaymentInterface $ payment ) { $ order = $ payment -> getOrder ( ) ; if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( ! $ payment -> getMethod ( ) -> isManual ( ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ payment , PaymentStates :: STATE_CAPTURED ) ) { return ; } foreach ( $ order -> getNotifications ( ) as $ n ) { if ( $ n -> getType ( ) !== NotificationTypes :: PAYMENT_CAPTURED ) { continue ; } if ( $ n -> hasData ( 'payment' ) && $ n -> getData ( 'payment' ) === $ payment -> getNumber ( ) ) { return ; } } $ this -> notify ( NotificationTypes :: PAYMENT_CAPTURED , $ payment ) ; }
4573	public function getProperties ( Auditable $ entity ) { $ reflection = new ReflectionObject ( $ entity ) ; $ properties = [ ] ; foreach ( $ reflection -> getProperties ( ) as $ key => $ property ) { if ( ! $ this -> annotationReader -> getPropertyAnnotation ( $ property , AuditAnnotation :: class ) ) { continue ; } $ properties [ ] = $ property -> name ; } return $ properties ; }
7885	public function getData ( $ date , $ level = null ) { if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ data = LogViewer :: data ( $ date , $ level ) ; $ paginator = new Paginator ( $ data , $ this -> perPage ) ; $ path = ( new \ ReflectionClass ( $ paginator ) ) -> getProperty ( 'path' ) ; $ path -> setAccessible ( true ) ; $ path -> setValue ( $ paginator , URL :: route ( 'logviewer.index' ) . '/' . $ date . '/' . $ level ) ; if ( count ( $ data ) > $ paginator -> perPage ( ) ) { $ log = array_slice ( $ data , $ paginator -> firstItem ( ) - 1 , $ paginator -> perPage ( ) ) ; } else { $ log = $ data ; } return View :: make ( 'logviewer::data' , compact ( 'paginator' , 'log' ) ) ; }
5410	public function close ( ) { if ( ! $ this -> is_open ) { return false ; } $ this -> is_open = false ; return fclose ( $ this -> handle ) ; }
11365	public static function listAddresses ( $ list = array ( ) , $ type = 'to' ) { if ( empty ( $ list ) ) { return ; } $ str = ucfirst ( strtolower ( $ type ) ) . ': ' . self :: mailListTagger ( $ list ) ; return ( trim ( $ str , Mailer :: $ ADDERSSES_SEPARATOR ) . Mailer :: $ LINE_ENDING ) ; }
9526	private function checkValidityAndContinueParse ( ) { $ valid = $ this -> validateRequiredParameters ( ) ; if ( $ valid !== true ) { $ this -> errorHandler -> call ( $ this , $ valid , 'Missing required argument: ' . $ valid -> parameterName ) ; $ this -> valid = false ; return [ ] ; } return $ this -> parseEvery ( ) ; }
3699	private function parseListing ( ) { $ listing = $ this -> definition -> getListingConfig ( ) ; if ( null === $ listing -> getRootLabel ( ) ) { $ listing -> setRootLabel ( $ this -> metaModel -> get ( 'name' ) ) ; } if ( null === $ listing -> getRootIcon ( ) ) { $ listing -> setRootIcon ( $ this -> iconBuilder -> getBackendIcon ( $ this -> inputScreen [ 'meta' ] [ 'backendicon' ] ) ) ; } $ this -> parseListSorting ( $ listing ) ; $ this -> parseListLabel ( $ listing ) ; $ listing -> setShowColumns ( ( bool ) $ this -> inputScreen [ 'meta' ] [ 'showColumns' ] ) ; }
7291	private function getByMethodAndStatesFromDateQuery ( ) { if ( null !== $ this -> byMethodAndStatesFromDateQuery ) { return $ this -> byMethodAndStatesFromDateQuery ; } $ qb = $ this -> createQueryBuilder ( 'p' ) ; $ query = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.method' , ':method' ) ) -> andWhere ( $ qb -> expr ( ) -> in ( 'p.state' , ':states' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'p.createdAt' , ':date' ) ) -> addOrderBy ( 'p.createdAt' , 'ASC' ) -> getQuery ( ) -> useQueryCache ( true ) ; return $ this -> byMethodAndStatesFromDateQuery = $ query ; }
12185	public function getNiceId ( $ queryRole ) { $ roleType = $ this -> roleType ( $ queryRole ) ; if ( empty ( $ roleType ) ) { return false ; } return implode ( ':' , [ $ this -> role ( $ queryRole ) , $ roleType -> systemId ] ) ; }
10543	public function setConfig ( Dictionary $ config ) { $ this -> config = $ config ; $ this -> configureSites ( ) ; $ this -> setVariable ( 'config' , $ config ) ; return $ this ; }
3805	public function generate ( ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/metamodelscore/css/style.css' ; $ arrModule = $ GLOBALS [ 'BE_MOD' ] [ 'metamodels' ] [ 'metamodels' ] ; if ( \ Input :: get ( 'key' ) && isset ( $ arrModule [ \ Input :: get ( 'key' ) ] ) ) { Callbacks :: call ( $ arrModule [ \ Input :: get ( 'key' ) ] , $ this , $ arrModule ) ; } $ act = \ Input :: get ( 'act' ) ; if ( ! strlen ( $ act ) ) { $ act = 'showAll' ; } return $ this -> dataContainer -> getEnvironment ( ) -> getController ( ) -> handle ( new Action ( $ act ) ) ; }
8517	public function setInventoryRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InventoryRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9077	public function addCollection ( RuleCollection $ collection ) { foreach ( $ collection -> all ( ) as $ name => $ rule ) { unset ( $ this -> rules [ $ name ] ) ; $ this -> rules [ $ name ] = $ rule ; } $ this -> resources = array_merge ( $ this -> resources , $ collection -> getResources ( ) ) ; }
733	public function toArray ( array $ fields = [ ] , array $ expand = [ ] , $ recursive = true ) { $ data = [ ] ; foreach ( $ this -> resolveFields ( $ fields , $ expand ) as $ field => $ definition ) { $ attribute = is_string ( $ definition ) ? $ this -> $ definition : $ definition ( $ this , $ field ) ; if ( $ recursive ) { $ nestedFields = $ this -> extractFieldsFor ( $ fields , $ field ) ; $ nestedExpand = $ this -> extractFieldsFor ( $ expand , $ field ) ; if ( $ attribute instanceof Arrayable ) { $ attribute = $ attribute -> toArray ( $ nestedFields , $ nestedExpand ) ; } elseif ( is_array ( $ attribute ) ) { $ attribute = array_map ( function ( $ item ) use ( $ nestedFields , $ nestedExpand ) { if ( $ item instanceof Arrayable ) { return $ item -> toArray ( $ nestedFields , $ nestedExpand ) ; } return $ item ; } , $ attribute ) ; } } $ data [ $ field ] = $ attribute ; } if ( $ this instanceof Linkable ) { $ data [ '_links' ] = Link :: serialize ( $ this -> getLinks ( ) ) ; } return $ recursive ? ArrayHelper :: toArray ( $ data ) : $ data ; }
12222	private function prepareErrorBody ( Exception $ exception ) { $ body = [ 'errors' => [ ] ] ; if ( ! empty ( $ statusCode = $ exception -> getStatusCode ( ) ) ) { $ body [ 'errors' ] [ 'statusCode' ] = $ statusCode ; } if ( ! empty ( $ description = $ exception -> getDescription ( ) ) ) { $ body [ 'errors' ] [ 'description' ] = $ description ; } if ( ! empty ( $ message = $ exception -> getMessage ( ) ) ) { $ body [ 'errors' ] [ 'message' ] = $ message ; } if ( ! empty ( $ code = $ exception -> getCode ( ) ) ) { $ body [ 'errors' ] [ 'code' ] = $ code ; } if ( ! empty ( $ link = $ exception -> getLink ( ) ) ) { $ body [ 'errors' ] [ 'link' ] = $ link ; } return $ body ; }
8894	protected function _initialize_schema ( ) { $ this -> set_database ( $ this -> _database_group ) ; $ this -> _fetch_table ( ) ; $ this -> _fetch_primary_key ( ) ; if ( $ this -> primary_key == null && $ this -> is_base_model_instance ( ) ) { return ; } $ this -> _fields = $ this -> get_fields ( ) ; $ this -> _guess_is_soft_deletable ( ) ; $ this -> _guess_is_blamable ( ) ; $ this -> _guess_is_timestampable ( ) ; }
2776	public static function parseRepositoryName ( string $ repositoryUrl ) : string { $ scheme = parse_url ( $ repositoryUrl , PHP_URL_SCHEME ) ; if ( $ scheme === null ) { $ parts = explode ( '/' , $ repositoryUrl ) ; $ path = end ( $ parts ) ; } else { $ strpos = strpos ( $ repositoryUrl , ':' ) ; $ path = substr ( $ repositoryUrl , $ strpos + 1 ) ; } return basename ( $ path , '.git' ) ; }
399	protected function deleteInternal ( ) { if ( ! $ this -> beforeDelete ( ) ) { return false ; } $ condition = $ this -> getOldPrimaryKey ( true ) ; $ lock = $ this -> optimisticLock ( ) ; if ( $ lock !== null ) { $ condition [ $ lock ] = $ this -> $ lock ; } $ result = static :: deleteAll ( $ condition ) ; if ( $ lock !== null && ! $ result ) { throw new StaleObjectException ( 'The object being deleted is outdated.' ) ; } $ this -> setOldAttributes ( null ) ; $ this -> afterDelete ( ) ; return $ result ; }
249	public function regenerateID ( $ deleteOldSession = false ) { if ( $ this -> getIsActive ( ) ) { if ( YII_DEBUG && ! headers_sent ( ) ) { session_regenerate_id ( $ deleteOldSession ) ; } else { @ session_regenerate_id ( $ deleteOldSession ) ; } } }
5796	private function setSlimMiddleware ( \ Slim \ App $ slim , $ slimContainer ) { $ slim -> add ( new CsrfMiddleware ( $ slimContainer ) ) ; if ( isset ( $ this -> config [ 'trackAll' ] ) && $ this -> config [ 'trackAll' ] ) { $ slim -> add ( new TrackerMiddleware ( $ slimContainer ) ) ; } $ slim -> add ( $ slimContainer -> csrf ) ; }
3272	public function setConfig ( Config $ config ) { $ this -> config = $ config ; $ this -> getDatabase ( ) -> setConfig ( $ config ) ; }
12413	public function addDevice ( $ groupId , array $ deviceIdentifiers ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'device_identifiers' => $ deviceIdentifiers , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_ADD_DEVICE , $ params ] ) ; }
36	protected function printLinks ( CompletePackageInterface $ package , $ linkType , $ title = null ) { $ title = $ title ? : $ linkType ; $ io = $ this -> getIO ( ) ; if ( $ links = $ package -> { 'get' . ucfirst ( $ linkType ) } ( ) ) { $ io -> write ( "\n<info>" . $ title . "</info>" ) ; foreach ( $ links as $ link ) { $ io -> write ( $ link -> getTarget ( ) . ' <comment>' . $ link -> getPrettyConstraint ( ) . '</comment>' ) ; } } }
4671	public function addBlockToBody ( $ block ) { $ this -> body = array_merge ( $ this -> body , explode ( PHP_EOL , $ block ) ) ; }
994	private function getDescription ( $ node ) { if ( $ node -> description ) { return $ node -> description -> value ; } if ( isset ( $ this -> options [ 'commentDescriptions' ] ) ) { $ rawValue = $ this -> getLeadingCommentBlock ( $ node ) ; if ( $ rawValue !== null ) { return BlockString :: value ( "\n" . $ rawValue ) ; } } return null ; }
12297	public function getRules ( array $ fields = [ ] ) { $ default_rules = $ this -> model -> getRules ( ) ; if ( count ( $ fields ) < 1 ) { return $ default_rules ; } foreach ( $ fields as $ field => $ rule ) { if ( is_int ( $ field ) ) { $ rules [ $ rule ] = $ default_rules [ $ rule ] ; continue ; } if ( ! key_exists ( $ field , $ default_rules ) ) { continue ; } $ default_rules [ $ field ] .= '|' . $ rule ; } $ rules = [ ] ; $ transformation = $ this -> model -> getTransformation ( ) ; foreach ( $ transformation as $ original => $ transformed ) { $ rules [ $ transformed ] = $ default_rules [ $ original ] ; } foreach ( $ fields as $ field => $ rule ) { if ( ! key_exists ( $ field , $ rules ) ) { continue ; } $ rules [ $ field ] .= '|' . $ rule ; } return $ rules ; }
5463	protected function getCommonPath ( $ first , $ second ) { $ first = explode ( '/' , $ first ) ; $ second = explode ( '/' , $ second ) ; for ( $ i = 0 ; $ i < min ( count ( $ first ) , count ( $ second ) ) ; $ i ++ ) { if ( $ first [ $ i ] != $ second [ $ i ] ) { return implode ( '/' , array_slice ( $ first , 0 , $ i ) ) . '/' ; } } return implode ( '/' , $ first ) . '/' ; }
475	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "delete from $table" ) ; $ this -> db -> createCommand ( ) -> delete ( $ table , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
6797	private function convertRows ( Statement $ dbResult , $ idColumn , $ valueColumn ) { $ result = [ ] ; while ( $ row = $ dbResult -> fetch ( \ PDO :: FETCH_ASSOC ) ) { if ( ! isset ( $ result [ $ row [ $ idColumn ] ] ) ) { $ result [ $ row [ $ idColumn ] ] = [ ] ; } $ data = $ row ; unset ( $ data [ $ idColumn ] ) ; $ result [ $ row [ $ idColumn ] ] [ $ row [ $ valueColumn ] ] = $ data ; } return $ result ; }
2585	protected function loadReferences ( $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> passengers , $ params -> segments ) ) { $ this -> psaInformation = new PsaInformation ( ) ; foreach ( $ params -> passengers as $ passenger ) { $ this -> psaInformation -> refDetails [ ] = new RefDetails ( $ passenger , RefDetails :: QUAL_PASSENGER ) ; } foreach ( $ params -> segments as $ segment ) { $ this -> psaInformation -> refDetails [ ] = new RefDetails ( $ segment , RefDetails :: QUAL_SEGMENT_REFERENCE ) ; } } }
4098	public function config ( $ key , $ value = null ) { if ( is_array ( $ key ) ) $ this -> config = $ key + $ this -> config ; else { if ( $ value !== null ) $ this -> config [ $ key ] = $ value ; if ( ! isset ( $ this -> config [ $ key ] ) ) throw new \ Exception ( "Configuration key `type` is not set" ) ; return $ this -> config [ $ key ] ; } }
5866	protected function getIndexer ( \ TYPO3 \ CMS \ Core \ Resource \ ResourceStorage $ storage ) { return GeneralUtility :: makeInstance ( Indexer :: class , $ storage ) ; }
2114	public function onBuild ( MenuEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser ) { return ; } $ factory = $ event -> getFactory ( ) ; $ tree = $ event -> getTree ( ) ; $ modules = $ user -> navigation ( ) ; foreach ( $ modules as $ categoryName => $ categoryData ) { $ categoryNode = $ tree -> getChild ( $ categoryName ) ; if ( ! $ categoryNode ) { $ categoryNode = $ this -> createNode ( $ factory , $ categoryName , $ categoryData ) ; if ( isset ( $ categoryData [ 'class' ] ) && preg_match ( '/\bnode-collapsed\b/' , $ categoryData [ 'class' ] ) ) { $ categoryNode -> setDisplayChildren ( false ) ; } $ tree -> addChild ( $ categoryNode ) ; } foreach ( $ categoryData [ 'modules' ] as $ moduleName => $ moduleData ) { $ moduleNode = $ this -> createNode ( $ factory , $ moduleName , $ moduleData ) ; $ moduleNode -> setCurrent ( ( bool ) $ moduleData [ 'isActive' ] ) ; $ categoryNode -> addChild ( $ moduleNode ) ; } } }
12550	public function installAssets ( ) { $ this -> doInstallAssets ( $ this -> core ) ; $ this -> doInstallAssets ( $ this -> blocks ) ; $ this -> doInstallAssets ( $ this -> themes ) ; }
9224	public function setupToken ( $ token ) { if ( ! empty ( $ token ) ) { $ this -> headers [ 'Authorization' ] = "Bearer $token" ; return true ; } else { if ( $ this -> throw_exceptions ) { throw new CanvasPest_Exception ( 'API authorization token must be a non-zero-length string' , CanvasPest_Exception :: INVALID_TOKEN ) ; } return false ; } }
12779	public function getState ( $ key , $ default = null ) { return Yii :: $ app -> webState -> get ( $ this -> stateKeyName ( $ key ) , $ default ) ; }
1291	public function continueSync ( $ token ) : Result { if ( $ token instanceof Result ) { if ( ! $ this -> isDeliveryApi && $ token -> isDone ( ) ) { throw new \ RuntimeException ( 'Can not continue syncing when using the Content Preview API.' ) ; } $ token = $ token -> getToken ( ) ; } $ response = $ this -> client -> syncRequest ( [ 'sync_token' => $ token ] ) ; return $ this -> buildResult ( $ response ) ; }
6768	protected function handleContentChange ( SaleInterface $ sale ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; if ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed = $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } $ changed |= $ this -> saleUpdater -> updateTotals ( $ sale ) ; $ changed |= $ this -> updateState ( $ sale ) ; $ changed |= $ this -> saleUpdater -> updateOutstandingDate ( $ sale ) ; return $ changed ; }
9676	public function allFonts ( Spreadsheet $ spreadsheet ) { $ aFonts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] ) ) { $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] = $ style -> getFont ( ) ; } } return $ aFonts ; }
4579	public function getStartForm ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_START_FORM ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_START_FORM_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_START_FORM_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ result = $ this -> execute ( 'GET' , $ resource , $ options ) ; return $ result -> key ; }
6598	protected function getParameters ( array $ lines ) { $ comment = implode ( "\n" , $ lines ) ; preg_match_all ( '/@param\s([\s\S]+?(?=@))/' , $ comment , $ paramsDoc ) ; $ params = [ ] ; if ( isset ( $ paramsDoc [ 1 ] ) ) { foreach ( $ paramsDoc [ 1 ] as $ paramDoc ) { $ documentation = [ ] ; preg_match ( '/([^$]+)?\$(\w+)(.+)?/s' , $ paramDoc , $ documentation ) ; list ( , $ type , $ name , $ description ) = $ documentation ; $ lines = preg_split ( "/((\r?\n)|(\r\n?))/" , $ description ) ; foreach ( $ lines as $ key => $ value ) { $ value = preg_replace ( '/\r/' , '' , $ value ) ; $ value = preg_replace ( '/^\s+\*/' , '' , $ value ) ; $ value = trim ( $ value ) ; $ lines [ $ key ] = $ value ; } $ description = implode ( "\n" , $ lines ) ; $ params [ $ name ] = [ 'type' => trim ( $ type ) , 'description' => trim ( $ description ) , ] ; } } return $ params ; }
1272	public function isValid ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { return $ this -> response -> AddressClassification -> Code > 0 ; } return isset ( $ this -> response -> ValidAddressIndicator ) ; }
10906	public function remove ( ) : bool { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE | \ sndsgd \ Fs :: WRITABLE ) === false ) { $ this -> error = "failed to remove directory; {$this->error}" ; return false ; } foreach ( $ this -> getList ( ) as $ entity ) { if ( $ entity -> remove ( ) === false ) { $ this -> error = $ entity -> getError ( ) ; return false ; } } if ( @ rmdir ( $ this -> path ) === false ) { $ this -> setError ( "failed to remove directory '{$this->path}'" ) ; return false ; } return true ; }
2070	public function deletePage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ root = func_get_arg ( 7 ) ; return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_DELETE_PAGE , $ row ) && ( $ this -> User -> isAdmin || ! \ in_array ( $ row [ 'id' ] , $ root ) ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
11346	public function renderFields ( ) { $ html = '' ; foreach ( $ this -> fields as $ field ) { $ html .= $ this -> formatter -> renderField ( $ field ) ; } return $ html ; }
789	public function getFirstError ( $ attribute ) { return isset ( $ this -> _errors [ $ attribute ] ) ? reset ( $ this -> _errors [ $ attribute ] ) : null ; }
775	public function resetSequence ( $ tableName , $ value = null ) { $ table = $ this -> db -> getTableSchema ( $ tableName ) ; if ( $ table !== null && $ table -> sequenceName !== null ) { $ tableName = $ this -> db -> quoteTableName ( $ tableName ) ; if ( $ value === null ) { $ key = reset ( $ table -> primaryKey ) ; $ value = $ this -> db -> createCommand ( "SELECT MAX(`$key`) FROM $tableName" ) -> queryScalar ( ) + 1 ; } else { $ value = ( int ) $ value ; } return "ALTER TABLE $tableName AUTO_INCREMENT=$value" ; } elseif ( $ table === null ) { throw new InvalidArgumentException ( "Table not found: $tableName" ) ; } throw new InvalidArgumentException ( "There is no sequence associated with table '$tableName'." ) ; }
10196	public function createStringTable ( Worksheet $ pSheet , $ pExistingTable = null ) { $ aStringTable = [ ] ; $ cellCollection = null ; $ aFlippedStringTable = null ; if ( ( $ pExistingTable !== null ) && is_array ( $ pExistingTable ) ) { $ aStringTable = $ pExistingTable ; } $ aFlippedStringTable = $ this -> flipStringTable ( $ aStringTable ) ; foreach ( $ pSheet -> getCoordinates ( ) as $ coordinate ) { $ cell = $ pSheet -> getCell ( $ coordinate ) ; $ cellValue = $ cell -> getValue ( ) ; if ( ! is_object ( $ cellValue ) && ( $ cellValue !== null ) && $ cellValue !== '' && ! isset ( $ aFlippedStringTable [ $ cellValue ] ) && ( $ cell -> getDataType ( ) == DataType :: TYPE_STRING || $ cell -> getDataType ( ) == DataType :: TYPE_STRING2 || $ cell -> getDataType ( ) == DataType :: TYPE_NULL ) ) { $ aStringTable [ ] = $ cellValue ; $ aFlippedStringTable [ $ cellValue ] = true ; } elseif ( $ cellValue instanceof RichText && ( $ cellValue !== null ) && ! isset ( $ aFlippedStringTable [ $ cellValue -> getHashCode ( ) ] ) ) { $ aStringTable [ ] = $ cellValue ; $ aFlippedStringTable [ $ cellValue -> getHashCode ( ) ] = true ; } } return $ aStringTable ; }
9877	private function writeFileVersion ( XMLWriter $ objWriter ) { $ objWriter -> startElement ( 'fileVersion' ) ; $ objWriter -> writeAttribute ( 'appName' , 'xl' ) ; $ objWriter -> writeAttribute ( 'lastEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'lowestEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'rupBuild' , '4505' ) ; $ objWriter -> endElement ( ) ; }
1336	protected function queryAllOrOne ( $ query , EncodingParametersInterface $ parameters ) { $ filters = collect ( $ parameters -> getFilteringParameters ( ) ) ; if ( $ this -> isSearchOne ( $ filters ) ) { return $ this -> queryOne ( $ query , $ parameters ) ; } return $ this -> queryAll ( $ query , $ parameters ) ; }
4397	protected function getRedirectForm ( \ Omnipay \ Common \ Message \ RedirectResponseInterface $ response ) { $ list = [ ] ; foreach ( ( array ) $ response -> getRedirectData ( ) as $ key => $ value ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( array ( 'label' => $ key , 'code' => $ key , 'type' => 'string' , 'internalcode' => $ key , 'internaltype' => 'string' , 'default' => $ value , 'public' => false , ) ) ; } $ url = $ response -> getRedirectUrl ( ) ; $ method = $ response -> getRedirectMethod ( ) ; return new \ Aimeos \ MShop \ Common \ Helper \ Form \ Standard ( $ url , $ method , $ list ) ; }
816	private function getMeaningfulSequence ( Tokens $ tokens , $ start , $ end ) { $ sequence = [ ] ; $ index = $ start ; while ( $ index < $ end ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ index >= $ end || null === $ index ) { break ; } $ sequence [ ] = $ tokens [ $ index ] ; } return Tokens :: fromArray ( $ sequence ) ; }
4063	private static function calculateArrayDiff ( $ expected , $ actual , $ strict ) { if ( count ( $ expected ) !== count ( $ actual ) ) { throw new \ LogicException ( sprintf ( 'Array element count mismatch. Found %s, expected %s.' , count ( $ actual ) , count ( $ expected ) ) , self :: ARRAY_COUNT_MISMATCH ) ; } reset ( $ actual ) ; foreach ( $ expected as $ key => $ value ) { if ( $ key !== key ( $ actual ) ) { throw new \ LogicException ( sprintf ( 'Array key mismatch. Found %s, expected %s.' , key ( $ actual ) , $ key ) , self :: ARRAY_KEY_MISMATCH ) ; } try { self :: calculateDiff ( $ value , current ( $ actual ) , $ strict ) ; } catch ( \ Exception $ exception ) { throw new \ LogicException ( sprintf ( 'Array value mismatch for key %s.' , key ( $ actual ) ) , self :: ARRAY_VALUE_MISMATCH , $ exception ) ; } next ( $ actual ) ; } }
4778	public function addWidget ( ItemInterface $ item ) { if ( $ this -> checkRole ) { if ( $ item -> getRole ( ) && ! $ this -> security -> isGranted ( $ item -> getRole ( ) ) ) { return $ this ; } } $ this -> widgets [ $ item -> getId ( ) ] = $ item ; return $ this ; }
5834	protected function setCode ( $ code ) { $ this -> code = $ code ; $ this -> statusText = $ code ; list ( $ this -> statusCode , ) = explode ( ' ' , $ code ) ; }
11916	public function response ( array $ data , $ http_code ) { if ( config ( 'odin.queryRequest' ) ) { $ data [ 'queries' ] = $ this -> getQueries ( ) ; } return response ( ) -> json ( $ data , $ http_code ) ; }
6297	protected function registerNavigation ( ) { $ this -> app -> singleton ( 'navigation' , function ( $ app ) { $ request = $ app [ 'request' ] ; $ events = $ app [ 'events' ] ; $ url = $ app [ 'url' ] ; $ view = $ app [ 'view' ] ; $ name = 'navigation::bootstrap' ; $ navigation = new Navigation ( $ request , $ events , $ url , $ view , $ name ) ; $ app -> refresh ( 'request' , $ navigation , 'setRequest' ) ; return $ navigation ; } ) ; $ this -> app -> alias ( 'navigation' , Navigation :: class ) ; }
2789	public static function reconstructFromTokens ( array & $ tokens ) { $ str = '' ; foreach ( $ tokens as $ token ) { if ( is_string ( $ token ) ) { $ str .= $ token ; } else { $ str .= $ token [ 1 ] ; } } return $ str ; }
5327	public function end ( string $ profile ) { Craft :: endProfile ( $ profile , Craft :: t ( 'twig-profiler' , self :: CATEGORY_PREFIX ) . TwigProfiler :: $ renderingTemplate ) ; }
2621	public function sendValidationRequest ( $ validatedFlag , $ serviceId = null ) { if ( $ serviceId != null ) { $ this -> validationServiceId = $ serviceId ; } if ( $ validatedFlag ) { $ validationState = self :: FASTLY_VALIDATED_FLAG ; } else { $ validationState = self :: FASTLY_NON_VALIDATED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ validationState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ validationState , 'dt' => ucfirst ( $ validationState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ validationState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
637	public function truncateTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> truncateTable ( $ table ) ; return $ this -> setSql ( $ sql ) ; }
3540	public static function getSyncOptions ( $ optionName , $ individualSyncOptions = null ) { if ( $ individualSyncOptions != null && is_array ( $ individualSyncOptions ) && array_key_exists ( $ optionName , $ individualSyncOptions ) ) { return $ individualSyncOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK ) ) { return static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Sync-option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
1155	public function getMessage ( $ attribute , $ rule ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'getMessage' , [ $ attribute , $ rule ] ) ; }
9677	public function allBorders ( Spreadsheet $ spreadsheet ) { $ aBorders = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aBorders [ $ style -> getBorders ( ) -> getHashCode ( ) ] ) ) { $ aBorders [ $ style -> getBorders ( ) -> getHashCode ( ) ] = $ style -> getBorders ( ) ; } } return $ aBorders ; }
9801	public static function setLibXmlLoaderOptions ( $ options ) { if ( $ options === null && defined ( 'LIBXML_DTDLOAD' ) ) { $ options = LIBXML_DTDLOAD | LIBXML_DTDATTR ; } self :: $ libXmlLoaderOptions = $ options ; }
9302	public function setScheduleLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`scheduleLifetime` expects integer value!' ) ; } $ this -> options [ 'scheduleLifetime' ] = ( int ) $ time ; return $ this ; }
6528	public static function registerMap ( array $ map ) { @ trigger_error ( sprintf ( '"%s" is deprecated. Use "registerManifest" instead.' , __CLASS__ ) , E_USER_DEPRECATED ) ; $ nextId = count ( self :: $ curies ) + 30000 ; foreach ( $ map as $ curie => $ class ) { ++ $ nextId ; self :: $ curies [ $ curie ] = $ nextId ; self :: $ classes [ $ nextId ] = $ class ; } }
2604	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ checkIfSettingExists = $ this -> api -> hasSnippet ( $ activeVersion , Config :: WAF_SETTING_NAME ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> config -> getWafAllowByAcl ( ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; if ( ! $ checkIfSettingExists ) { foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key , 'type' => $ key , 'dynamic' => 1 , 'priority' => 10 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } } else { foreach ( $ snippet as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; if ( $ this -> api -> hasSnippet ( $ clone -> number , $ name ) == true ) { $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ checkIfSettingExists , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON WAF ACL Bypass' ] ; if ( $ checkIfSettingExists ) { $ comment = [ 'comment' => 'Magento Module turned OFF WAF ACL Bypass' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
8149	public function compileSource ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } try { return $ this -> compile ( $ this -> parse ( $ this -> tokenize ( $ source ) ) ) ; } catch ( Twig_Error $ e ) { $ e -> setSourceContext ( $ source ) ; throw $ e ; } catch ( Exception $ e ) { throw new Twig_Error_Syntax ( sprintf ( 'An exception has been thrown during the compilation of a template ("%s").' , $ e -> getMessage ( ) ) , - 1 , $ source , $ e ) ; } }
2298	public static function findSearchablePages ( $ pid = 0 , $ domain = '' , $ blnIsSitemap = false ) { $ objPages = PageModel :: findPublishedByPid ( $ pid , array ( 'ignoreFePreview' => true ) ) ; if ( $ objPages === null ) { return array ( ) ; } $ arrPages = array ( ) ; foreach ( $ objPages as $ objPage ) { if ( $ objPage -> type == 'regular' ) { if ( ( ! $ objPage -> noSearch || $ blnIsSitemap ) && ( ! $ objPage -> protected || ( Config :: get ( 'indexProtected' ) && ( ! $ blnIsSitemap || $ objPage -> sitemap == 'map_always' ) ) ) && ( ! $ blnIsSitemap || $ objPage -> sitemap != 'map_never' ) && ! $ objPage -> requireItem ) { $ arrPages [ ] = $ objPage -> getAbsoluteUrl ( ) ; if ( ( $ objArticles = ArticleModel :: findPublishedWithTeaserByPid ( $ objPage -> id , array ( 'ignoreFePreview' => true ) ) ) !== null ) { foreach ( $ objArticles as $ objArticle ) { $ arrPages [ ] = $ objPage -> getAbsoluteUrl ( '/articles/' . ( $ objArticle -> alias ? : $ objArticle -> id ) ) ; } } } } if ( ( ! $ objPage -> protected || Config :: get ( 'indexProtected' ) ) && ( $ arrSubpages = static :: findSearchablePages ( $ objPage -> id , $ domain , $ blnIsSitemap ) ) ) { $ arrPages = array_merge ( $ arrPages , $ arrSubpages ) ; } } return $ arrPages ; }
11859	public static function getHandlingObject ( $ a , $ b ) { $ handlingA = $ a -> handlingComparison ; $ handlingB = $ b -> handlingComparison ; if ( ! $ handlingB ) { return $ a ; } if ( $ handlingA !== false && $ handlingB !== false ) { if ( $ handlingA > $ handlingB ) { return $ a ; } else { return $ b ; } } return $ a ; }
2321	public static function get ( $ image , $ width , $ height , $ mode = '' , $ target = null , $ force = false ) { @ trigger_error ( 'Using Image::get() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; if ( $ image == '' ) { return null ; } try { $ imageObj = static :: create ( $ image , array ( $ width , $ height , $ mode ) ) ; $ imageObj -> setTargetPath ( $ target ) ; $ imageObj -> setForceOverride ( $ force ) ; if ( $ path = $ imageObj -> executeResize ( ) -> getResizedPath ( ) ) { return $ path ; } } catch ( \ Exception $ e ) { System :: log ( 'Image "' . $ image . '" could not be processed: ' . $ e -> getMessage ( ) , __METHOD__ , 'ERROR' ) ; } return null ; }
951	public function activate ( ) { $ currentCharge = $ this -> shop -> planCharge ( ) ; if ( ! $ currentCharge -> isType ( Charge :: CHARGE_RECURRING ) ) { throw new Exception ( 'Can only create usage charges for recurring charge.' ) ; } $ this -> response = $ this -> api -> rest ( 'POST' , "/admin/recurring_application_charges/{$currentCharge->charge_id}/usage_charges.json" , [ 'usage_charge' => [ 'price' => $ this -> data [ 'price' ] , 'description' => $ this -> data [ 'description' ] , ] , ] ) -> body -> usage_charge ; return $ this -> response ; }
5367	public function paintException ( $ message ) { parent :: paintException ( $ message ) ; $ this -> results [ ] = new SimpleResultOfException ( parent :: getTestList ( ) , $ message ) ; }
7303	public function onParentChange ( ResourceEventInterface $ event ) { $ customer = $ this -> getCustomerFromEvent ( $ event ) ; if ( $ this -> updateFromParent ( $ customer ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ customer , true ) ; } }
647	public function addCommentOnColumn ( $ table , $ column , $ comment ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addCommentOnColumn ( $ table , $ column , $ comment ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
7906	protected function renderMenu ( $ items , $ parentItem ) { $ options = ArrayHelper :: getValue ( $ parentItem , 'options' ) ; $ label = $ this -> getLabel ( $ parentItem ) ; $ items = Html :: tag ( 'div' , $ this -> renderItems ( $ items ) , [ 'class' => 'menu' ] ) ; Html :: addCssClass ( $ options , 'ui' ) ; Html :: addCssClass ( $ options , 'header' ) ; return Html :: tag ( 'div' , Html :: tag ( 'div' , $ label , $ options ) . $ items , [ 'class' => 'item' ] ) ; }
7816	public function event ( string $ event ) : self { $ events = [ 'MESSAGE_RECEIVED' , 'MESSAGE_SENT' , 'MESSAGE_FAILED' , ] ; if ( ! in_array ( $ event , $ events ) ) { abort ( 500 , sprintf ( 'Event %s not available.' , $ event ) ) ; } $ this -> event = $ event ; return $ this ; }
3054	public function persistSeenCatItemIds ( $ seenCatItemId ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ items = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> getCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-seen-item-ids' ) ; if ( ! $ items ) { $ items = [ ] ; } else { $ items = json_decode ( $ items ) ; } if ( ! in_array ( $ seenCatItemId , $ items ) ) { $ items [ ] = $ seenCatItemId ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> setCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-seen-item-ids' , json_encode ( $ items ) ) ; }
2130	protected function markModified ( ) { if ( $ this -> blnIsModified === true ) { return ; } $ this -> blnIsModified = true ; $ this -> strTop = '' ; $ this -> strBottom = '' ; $ this -> Files = Files :: getInstance ( ) ; if ( static :: $ blnHasLcf ) { $ strMode = 'top' ; $ resFile = fopen ( $ this -> strRootDir . '/system/config/localconfig.php' , 'rb' ) ; while ( ! feof ( $ resFile ) ) { $ strLine = fgets ( $ resFile ) ; $ strTrim = trim ( $ strLine ) ; if ( $ strTrim == '?>' ) { continue ; } if ( $ strTrim == '### INSTALL SCRIPT START ###' ) { $ strMode = 'data' ; continue ; } if ( $ strTrim == '### INSTALL SCRIPT STOP ###' ) { $ strMode = 'bottom' ; continue ; } if ( $ strMode == 'top' ) { $ this -> strTop .= $ strLine ; } elseif ( $ strMode == 'bottom' ) { $ this -> strBottom .= $ strLine ; } elseif ( $ strTrim != '' ) { $ arrChunks = array_map ( 'trim' , explode ( '=' , $ strLine , 2 ) ) ; $ this -> arrData [ $ arrChunks [ 0 ] ] = $ arrChunks [ 1 ] ; } } fclose ( $ resFile ) ; } }
54	public function getDownloader ( $ type ) { $ type = strtolower ( $ type ) ; if ( ! isset ( $ this -> downloaders [ $ type ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Unknown downloader type: %s. Available types: %s.' , $ type , implode ( ', ' , array_keys ( $ this -> downloaders ) ) ) ) ; } return $ this -> downloaders [ $ type ] ; }
2952	protected function prepareTemplate ( $ templateTxt ) { $ patterns = [ '/\\\{%(.*)%\\\}/U' , '/\s+/' , ] ; $ replacements = [ '(?<$1>.*)' , ' ' , ] ; $ templateTxt = preg_replace ( $ patterns , $ replacements , preg_quote ( $ templateTxt , '/' ) ) ; return trim ( $ templateTxt ) ; }
10418	public static function extract ( $ yamlArray , $ key , $ needed = false ) { if ( ! empty ( $ yamlArray ) && array_key_exists ( $ key , $ yamlArray ) ) return $ yamlArray [ $ key ] ; if ( $ needed ) { throw new \ Deployer \ Exception \ Exception ( 'Cannot find the setting: ' . $ key . '. This key needs to be given!' ) ; } return null ; }
8678	public function chunk ( $ size , $ preserveKeys = false ) { $ create = function ( $ items ) { return $ this -> createFrom ( $ items ) ; } ; return $ this -> createFrom ( array_map ( $ create , array_chunk ( $ this -> items , $ size , $ preserveKeys ) ) ) ; }
12190	public function getActive ( ) { return ( isset ( $ this -> _child ) and $ this -> _child -> active ) and ( isset ( $ this -> _parent ) and $ this -> _parent -> active ) ; }
2140	private function fetchHttpHeaders ( ) : void { $ this -> headers = array_merge ( $ this -> headers , $ this -> headerStorage -> all ( ) ) ; $ this -> headerStorage -> clear ( ) ; }
2320	public static function create ( $ image , $ size = null ) { @ trigger_error ( 'Using Image::create() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; if ( \ is_string ( $ image ) ) { $ image = new File ( rawurldecode ( $ image ) ) ; } $ imageObj = new static ( $ image ) ; if ( \ is_array ( $ size ) && ! empty ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ size = ( int ) $ size [ 2 ] ; } if ( \ is_array ( $ size ) ) { $ size += array ( 0 , 0 , 'crop' ) ; $ imageObj -> setTargetWidth ( $ size [ 0 ] ) -> setTargetHeight ( $ size [ 1 ] ) -> setResizeMode ( $ size [ 2 ] ) ; } elseif ( ( $ imageSize = ImageSizeModel :: findByPk ( $ size ) ) !== null ) { $ imageObj -> setTargetWidth ( $ imageSize -> width ) -> setTargetHeight ( $ imageSize -> height ) -> setResizeMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; } $ fileRecord = FilesModel :: findByPath ( $ image -> path ) ; if ( $ fileRecord !== null && $ fileRecord -> importantPartWidth && $ fileRecord -> importantPartHeight ) { $ imageObj -> setImportantPart ( array ( 'x' => ( int ) $ fileRecord -> importantPartX , 'y' => ( int ) $ fileRecord -> importantPartY , 'width' => ( int ) $ fileRecord -> importantPartWidth , 'height' => ( int ) $ fileRecord -> importantPartHeight , ) ) ; } return $ imageObj ; }
11104	protected function registerClientScript ( ) { $ view = $ this -> getView ( ) ; DateTimePickerAssets :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; $ options = Json :: encode ( $ this -> clientOptions ) ; $ view -> registerJs ( "jQuery('#$id').datetimepicker($options);" ) ; }
2072	public function getAllowedArchives ( ) { if ( $ this -> User -> isAdmin ) { $ objArchive = Contao \ NewsArchiveModel :: findAll ( ) ; } else { $ objArchive = Contao \ NewsArchiveModel :: findMultipleByIds ( $ this -> User -> news ) ; } $ return = array ( ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { $ return [ $ objArchive -> id ] = $ objArchive -> title ; } } return $ return ; }
2562	protected function loadGeoCode ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAllNotEmpty ( $ params -> latitude , $ params -> longitude ) ) { $ this -> porFndQryParams -> geoCode = new GeoCode ( $ params -> longitude , $ params -> latitude ) ; } }
11256	private function resolve ( string $ class ) : AbstractSeed { $ instance = $ this -> autowire ( $ class ) ; $ instance -> setDatabase ( $ this -> database ) ; $ instance -> setSeeder ( $ this ) ; if ( ! is_null ( $ this -> container ) ) { $ instance -> setContainer ( $ this -> container ) ; } return $ instance ; }
12919	public function setFilters ( ) { $ this -> activeQueryLog ( ) -> setFields ( ) -> setCriteriaByQueryString ( ) -> setCriteria ( ) -> setIncludes ( ) -> setLimit ( ) -> setOrder ( ) -> setGroup ( ) ; }
7393	public function unserialize ( $ serialized ) : void { $ this -> _initMetaData ( ) ; $ data = unserialize ( $ serialized ) ; foreach ( $ data as $ k => $ v ) { $ this -> { $ k } = $ v ; } }
3728	protected function tryUnserialize ( $ value ) { if ( ! is_array ( $ value ) && 0 === strpos ( $ value , 'a:' ) && is_array ( $ unSerialized = unserialize ( $ value , [ 'allowed_classes' => false ] ) ) ) { return $ unSerialized ; } return $ value ; }
4125	private function generateMethods ( ClassMetadata $ class ) { $ methods = '' ; foreach ( $ class -> reflClass -> getMethods ( ) as $ method ) { if ( $ method -> isConstructor ( ) || strtolower ( $ method -> getName ( ) ) == "__sleep" ) { continue ; } if ( $ method -> isPublic ( ) && ! $ method -> isFinal ( ) && ! $ method -> isStatic ( ) ) { $ methods .= PHP_EOL . ' public function ' ; if ( $ method -> returnsReference ( ) ) { $ methods .= '&' ; } $ methods .= $ method -> getName ( ) . '(' ; $ firstParam = true ; $ parameterString = $ argumentString = '' ; foreach ( $ method -> getParameters ( ) as $ param ) { if ( $ firstParam ) { $ firstParam = false ; } else { $ parameterString .= ', ' ; $ argumentString .= ', ' ; } if ( ( $ paramClass = $ param -> getClass ( ) ) !== null ) { $ parameterString .= '\\' . $ paramClass -> getName ( ) . ' ' ; } else if ( $ param -> isArray ( ) ) { $ parameterString .= 'array ' ; } if ( $ param -> isPassedByReference ( ) ) { $ parameterString .= '&' ; } $ parameterString .= '$' . $ param -> getName ( ) ; $ argumentString .= '$' . $ param -> getName ( ) ; if ( $ param -> isDefaultValueAvailable ( ) ) { $ parameterString .= ' = ' . var_export ( $ param -> getDefaultValue ( ) , true ) ; } } $ methods .= $ parameterString . ')' ; $ methods .= PHP_EOL . ' {' . PHP_EOL ; $ methods .= ' $this->__load();' . PHP_EOL ; $ methods .= ' return parent::' . $ method -> getName ( ) . '(' . $ argumentString . ');' ; $ methods .= PHP_EOL . ' }' . PHP_EOL ; } } return $ methods ; }
8699	private function factoryElement ( $ type ) { switch ( $ type ) { case \ SVGCreator \ Element :: CIRCLE : return new \ SVGCreator \ Elements \ Circle ( ) ; break ; case \ SVGCreator \ Element :: DEFS : return new \ SVGCreator \ Elements \ Defs ( ) ; break ; case \ SVGCreator \ Element :: GROUP : return new \ SVGCreator \ Elements \ Group ( ) ; break ; case \ SVGCreator \ Element :: LINE : return new \ SVGCreator \ Elements \ Line ( ) ; break ; case \ SVGCreator \ Element :: MARKER : return new \ SVGCreator \ Elements \ Marker ( ) ; break ; case \ SVGCreator \ Element :: PATH : return new \ SVGCreator \ Elements \ Path ( ) ; break ; case \ SVGCreator \ Element :: RECT : return new \ SVGCreator \ Elements \ Rect ( ) ; break ; case \ SVGCreator \ Element :: SVG : return new \ SVGCreator \ Elements \ Svg ( ) ; break ; case \ SVGCreator \ Element :: TEXT : return new \ SVGCreator \ Elements \ Text ( ) ; break ; case \ SVGCreator \ Element :: POLYGON : return new \ SVGCreator \ Elements \ Polygon ( ) ; break ; default : throw new \ SVGCreator \ SVGException ( "The tag " . $ type . " is not implemented yet" , 1 ) ; break ; } }
2322	public static function getPixelValue ( $ size ) { @ trigger_error ( 'Using Image::getPixelValue() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ value = preg_replace ( '/[^0-9.-]+/' , '' , $ size ) ; $ unit = preg_replace ( '/[^acehimnprtvwx%]/' , '' , $ size ) ; switch ( $ unit ) { case '' : case 'px' : return ( int ) round ( $ value ) ; break ; case 'em' : return ( int ) round ( $ value * 16 ) ; break ; case 'ex' : return ( int ) round ( $ value * 16 / 2 ) ; break ; case 'pt' : return ( int ) round ( $ value * 16 / 12 ) ; break ; case 'pc' : return ( int ) round ( $ value * 16 ) ; break ; case 'in' : return ( int ) round ( $ value * 16 * 6 ) ; break ; case 'cm' : return ( int ) round ( $ value * 16 / ( 2.54 / 6 ) ) ; break ; case 'mm' : return ( int ) round ( $ value * 16 / ( 25.4 / 6 ) ) ; break ; case '%' : return ( int ) round ( $ value * 16 / 100 ) ; break ; } return 0 ; }
1221	private function reduce ( $ from , array $ values , array $ types , callable $ reduce ) { $ i = - 1 ; return array_reduce ( $ values , function ( $ carry , $ item ) use ( $ from , $ types , $ reduce , & $ i ) { if ( ++ $ i > 0 ) { $ this -> validateSeq ( $ from , $ types , $ carry , $ item ) ; } return $ reduce ( $ carry , $ item , $ i ) ; } ) ; }
10924	private function renderLine ( ) { $ output = [ ] ; $ output [ ] = $ this -> charCross ; if ( count ( $ this -> columns ) > 0 ) { for ( $ columnNumber = 0 ; $ columnNumber < count ( $ this -> columns ) ; $ columnNumber ++ ) { $ output [ ] = $ this -> renderCell ( $ columnNumber , $ this -> charHorizontal , $ this -> charHorizontal ) ; $ output [ ] = $ this -> charCross ; } } return implode ( '' , $ output ) ; }
12487	public static function enableLogging ( $ writePath ) { if ( is_file ( $ writePath ) ) { self :: $ enabled = true ; self :: $ logFilePath = $ writePath ; return true ; } throw new \ Exception ( 'Impossible d\'activer les logs dans le fichier ' . $ writePath . ' : celui ci n\'existe pas.' ) ; return false ; }
4530	public function setUserUuid ( ? string $ userUuid ) { if ( null !== $ userUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ userUuid ) ) { throw new InvalidArgumentException ( 'Uuid is not valid.' ) ; } } $ this -> userUuid = $ userUuid ; return $ this ; }
8346	public static function route ( $ method , $ path , $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'route' , 'method' => $ method , 'path' => $ path , 'action' => $ action , 'namespace' => self :: $ namespace , 'subdomain' => self :: $ subdomain , 'uri' => self :: $ uri ) ; } }
5350	public function setMailBoxPassword ( $ domainName , $ mailBox , $ password ) { return $ this -> call ( self :: SERVICE , 'setMailBoxPassword' , [ $ domainName , $ mailBox , $ password ] ) ; }
3284	public function setFormatter ( $ formatter ) { if ( $ formatter === null ) { $ formatter = new SerializeFormatter ( ) ; } if ( ! $ formatter instanceof FormatterInterface ) { throw new Exception ( 'Formatter must be an instance of Flintstone\Formatter\FormatterInterface' ) ; } $ this -> config [ 'formatter' ] = $ formatter ; }
5019	public function getFieldOptions ( $ field ) { if ( ! $ this -> hasField ( $ field ) ) { return [ ] ; } if ( ! isset ( $ this -> fields [ $ field ] [ '__options__' ] ) ) { $ this -> fields [ $ field ] [ '__options__' ] = $ this -> copyArrayValues ( $ this -> fields [ $ field ] , [ 'attributes' , 'options' , 'label' => 'options' , 'required' => [ 'key' => [ 'attributes' , '*' ] , 'value' => 'required' , 'if' => true ] , 'type' , ] ) ; } return $ this -> fields [ $ field ] [ '__options__' ] ; }
5337	public function api ( $ name ) { switch ( $ name ) { case 'domain' : case 'domain_service' : case 'domainService' : return new Api \ Domain ( $ this ) ; case 'colocation' : case 'colocation_service' : case 'colocationService' : return new Api \ Colocation ( $ this ) ; case 'forward' : case 'forward_service' : case 'forwardService' : return new Api \ Forward ( $ this ) ; case 'vps' : case 'vps_service' : case 'vpsService' : return new Api \ Vps ( $ this ) ; case 'hosting' : case 'web_hosting' : case 'webHosting' : case 'web_hosting_service' : case 'webHostingService' : return new Api \ WebHosting ( $ this ) ; case 'haip' : case 'ha_ip' : case 'ha_ip_service' : case 'haip_service' : case 'haipService' : return new Api \ Haip ( $ this ) ; default : throw new \ InvalidArgumentException ( sprintf ( 'Undefined api instance called: [%s]' , $ name ) ) ; } }
10632	private function getFiles ( $ pattern ) { $ files = $ this -> filesystem -> glob ( $ this -> storagePath . DIRECTORY_SEPARATOR . $ pattern , GLOB_BRACE ) ; return array_filter ( array_map ( 'realpath' , $ files ) ) ; }
5800	public function delete ( int $ id , AuthenticationService $ authentication , AuthorizationService $ authorization ) : string { if ( null === $ administrator = $ this -> getObjectById ( $ id ) ) { throw new Exceptions \ QueryResultsNotFoundException ( ) ; } $ administrator -> setAuth ( $ authentication , $ authorization ) ; if ( ! $ administrator -> isDeletable ( ) ) { throw new Exceptions \ UnallowedActionException ( $ administrator -> getNotDeletableReason ( ) ) ; } $ this -> doDeleteTransaction ( $ id ) ; $ username = $ administrator -> getUsername ( ) ; unset ( $ administrator ) ; return $ username ; }
12143	public static function user ( ) { if ( ! static :: $ user and static :: $ factory ) { $ id = static :: provider ( ) -> get ( 'id' ) ; static :: $ user = call_user_func ( static :: $ factory , $ id ) ; } return static :: $ user ; }
4365	public function onErrorHighPri ( Event $ error ) { $ this -> throttleDataRead ( ) ; $ hash = $ error [ 'hash' ] ; $ error [ 'email' ] = ( $ error [ 'type' ] & $ this -> cfg [ 'emailMask' ] ) && $ error [ 'isFirstOccur' ] && $ this -> cfg [ 'emailTo' ] ; $ error [ 'stats' ] = array ( 'tsEmailed' => 0 , 'countSince' => 0 , 'emailedTo' => '' , ) ; if ( isset ( $ this -> throttleData [ 'errors' ] [ $ hash ] ) ) { $ stats = \ array_intersect_key ( $ this -> throttleData [ 'errors' ] [ $ hash ] , $ error [ 'stats' ] ) ; $ error [ 'stats' ] = \ array_merge ( $ error [ 'stats' ] , $ stats ) ; } return ; }
11321	function getRow ( $ sql , $ params = array ( ) ) { $ data = $ this -> query ( $ sql , $ params ) ; $ row = false ; if ( count ( $ data ) > 0 ) { $ row = $ data [ 0 ] ; } return $ row ; }
5390	protected function valueIsPossible ( $ value ) { $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ widgets [ $ i ] -> getAttribute ( 'value' ) == $ value ) { return true ; } } return false ; }
7301	static public function getTargetsForSale ( SaleInterface $ sale ) { if ( $ sale instanceof CartInterface ) { return [ static :: TARGET_ORDER , static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof OrderInterface ) { if ( $ sale -> getState ( ) !== OrderStates :: STATE_NEW ) { return [ ] ; } return [ static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof QuoteInterface ) { return [ static :: TARGET_ORDER ] ; } throw new InvalidArgumentException ( "Unexpected sale type." ) ; }
5470	protected function describePatternMatch ( $ pattern , $ subject ) { preg_match ( $ pattern , $ subject , $ matches ) ; $ position = strpos ( $ subject , $ matches [ 0 ] ) ; $ dumper = $ this -> getDumper ( ) ; return "Pattern [$pattern] detected at character [$position] in [" . $ dumper -> describeValue ( $ subject ) . '] as [' . $ matches [ 0 ] . '] in region [' . $ dumper -> clipString ( $ subject , 100 , $ position ) . ']' ; }
6442	public function getAllResources ( $ name , $ full = false , array $ filters = [ ] , array $ fields = [ ] ) { $ this -> lastRequest = new Request ; $ this -> lastRequest -> setMode ( Request :: MODE_READ ) ; $ this -> lastRequest -> setResourceName ( $ name ) ; if ( $ full ) { $ this -> lastRequest -> enableFullResults ( ) ; } $ this -> lastRequest -> setFilters ( $ filters ) ; $ this -> lastRequest -> setFields ( $ fields ) ; $ data = [ ] ; $ page = 1 ; do { $ this -> lastRequest -> setCurrentPage ( $ page ) ; $ response = $ this -> proceed ( ) ; $ data = ArrayUtils :: merge ( $ data , $ response -> getData ( ) -> getData ( ) ) ; $ page ++ ; } while ( $ response -> getPagination ( ) -> getPage ( ) != $ response -> getPagination ( ) -> getPages ( ) ) ; return $ data ; }
2316	protected function prepareResizeConfig ( ) { $ resizeConfig = new ResizeConfiguration ( ) ; $ resizeConfig -> setWidth ( $ this -> targetWidth ) ; $ resizeConfig -> setHeight ( $ this -> targetHeight ) ; $ resizeConfig -> setZoomLevel ( $ this -> zoomLevel ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; $ resizeConfig -> setZoomLevel ( 0 ) ; } else { try { $ resizeConfig -> setMode ( $ this -> resizeMode ) ; } catch ( \ InvalidArgumentException $ exception ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; } } return $ resizeConfig ; }
7115	protected function getOneQueryBuilder ( $ alias = null , $ indexBy = null ) { return $ this -> createQueryBuilder ( $ alias , $ indexBy ) -> select ( $ alias , 'customer' , 'customer_group' , 'invoice_address' , 'delivery_address' , 'shipment_method' , 'currency' ) -> leftJoin ( $ alias . '.customer' , 'customer' ) -> leftJoin ( $ alias . '.customerGroup' , 'customer_group' ) -> leftJoin ( $ alias . '.invoiceAddress' , 'invoice_address' ) -> leftJoin ( $ alias . '.deliveryAddress' , 'delivery_address' ) -> leftJoin ( $ alias . '.shipmentMethod' , 'shipment_method' ) -> leftJoin ( $ alias . '.currency' , 'currency' ) -> setMaxResults ( 1 ) ; }
8029	public function registerFreeProcessId ( $ pid ) { $ processDetails = $ this -> getProcessDetails ( $ pid ) ; if ( $ processDetails !== NULL ) { $ this -> registerFreeProcess ( $ processDetails ) ; } return $ this ; }
1142	public function availableOptionValues ( ) { $ options = [ ] ; foreach ( $ this -> selector -> getOptions ( ) as $ option ) { $ options [ ] = $ option -> getAttribute ( 'value' ) ; } return $ options ; }
2093	protected function validator ( $ varInput ) { $ this -> blnSubmitInput = false ; if ( ! \ strlen ( $ varInput ) && ( \ strlen ( $ this -> varValue ) || ! $ this -> mandatory ) ) { return '' ; } $ intLength = $ this -> minlength ? : Config :: get ( 'minPasswordLength' ) ; if ( Utf8 :: strlen ( $ varInput ) < $ intLength ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'passwordLength' ] , $ intLength ) ) ; } if ( $ varInput != $ this -> getPost ( $ this -> strName . '_confirm' ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'passwordMatch' ] ) ; } $ varInput = parent :: validator ( $ varInput ) ; if ( ! $ this -> hasErrors ( ) ) { $ this -> blnSubmitInput = true ; return password_hash ( $ varInput , PASSWORD_DEFAULT ) ; } return '' ; }
1748	protected function listSingleRecord ( $ id ) { if ( ! \ strlen ( $ this -> list_info_layout ) ) { $ this -> list_info_layout = 'info_default' ; } $ this -> Template = new FrontendTemplate ( $ this -> list_info_layout ) ; $ this -> Template -> record = array ( ) ; $ this -> Template -> referer = 'javascript:history.go(-1)' ; $ this -> Template -> back = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goBack' ] ; $ this -> list_info = StringUtil :: deserialize ( $ this -> list_info ) ; $ this -> list_info_where = $ this -> replaceInsertTags ( $ this -> list_info_where , false ) ; $ objRecord = $ this -> Database -> prepare ( "SELECT " . implode ( ', ' , array_map ( 'Database::quoteIdentifier' , trimsplit ( ',' , $ this -> list_info ) ) ) . " FROM " . $ this -> list_table . " WHERE " . ( ( $ this -> list_info_where != '' ) ? "(" . $ this -> list_info_where . ") AND " : "" ) . Database :: quoteIdentifier ( $ this -> strPk ) . "=?" ) -> limit ( 1 ) -> execute ( $ id ) ; if ( $ objRecord -> numRows < 1 ) { return ; } $ arrFields = array ( ) ; $ arrRow = $ objRecord -> row ( ) ; $ limit = \ count ( $ arrRow ) ; $ count = - 1 ; foreach ( $ arrRow as $ k => $ v ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'password' ) { -- $ limit ; continue ; } $ class = 'row_' . ++ $ count . ( ( $ count == 0 ) ? ' row_first' : '' ) . ( ( $ count >= ( $ limit - 1 ) ) ? ' row_last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' even' : ' odd' ) ; $ arrFields [ $ k ] = array ( 'raw' => $ v , 'label' => ( \ strlen ( $ label = $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ) ? $ label : $ k ) , 'content' => $ this -> formatValue ( $ k , $ v , true ) , 'class' => $ class ) ; } $ this -> Template -> record = $ arrFields ; }
2817	public function addModel ( Mage_Core_Model_Abstract $ model ) { $ modelInfo = Mage :: getModel ( 'sheep_debug/model' ) ; $ modelInfo -> init ( $ model ) ; $ key = $ modelInfo -> getClass ( ) ; if ( ! array_key_exists ( $ key , $ this -> models ) ) { $ this -> models [ $ key ] = $ modelInfo ; } $ this -> models [ $ key ] -> incrementCount ( ) ; }
517	public function actionFresh ( ) { if ( YII_ENV_PROD ) { $ this -> stdout ( "YII_ENV is set to 'prod'.\nRefreshing migrations is not possible on production systems.\n" ) ; return ExitCode :: OK ; } if ( $ this -> confirm ( "Are you sure you want to reset the database and start the migration from the beginning?\nAll data will be lost irreversibly!" ) ) { $ this -> truncateDatabase ( ) ; $ this -> actionUp ( ) ; } else { $ this -> stdout ( 'Action was cancelled by user. Nothing has been performed.' ) ; } }
7738	public function serialize ( $ entity ) { if ( ! $ this -> container -> has ( 'hydra.serializer' ) ) { throw new \ LogicException ( 'The HydraBundle is not registered in your application.' ) ; } return $ this -> container -> get ( 'hydra.serializer' ) -> serialize ( $ entity , self :: FORMAT ) ; }
8718	public static function forceCreateInLocale ( $ locale , array $ attributes , $ translations = [ ] ) { $ model = new static ; return static :: unguarded ( function ( ) use ( $ locale , $ model , $ attributes , $ translations ) { return $ model -> createInLocale ( $ locale , $ attributes , $ translations ) ; } ) ; }
10745	public function getObjectArray ( $ keys ) : array { return array_map ( function ( $ value ) { return $ this -> createObject ( $ value ) ; } , $ this -> getArray ( $ keys ) ) ; }
8276	public function triggerEvent ( $ eventName , array $ params = array ( ) ) { foreach ( $ this -> modules as $ module ) { $ module -> handleEvent ( $ eventName , $ params ) ; } }
10285	public static function columnIndexFromString ( $ pString ) { static $ indexCache = [ ] ; if ( isset ( $ indexCache [ $ pString ] ) ) { return $ indexCache [ $ pString ] ; } static $ columnLookup = [ 'A' => 1 , 'B' => 2 , 'C' => 3 , 'D' => 4 , 'E' => 5 , 'F' => 6 , 'G' => 7 , 'H' => 8 , 'I' => 9 , 'J' => 10 , 'K' => 11 , 'L' => 12 , 'M' => 13 , 'N' => 14 , 'O' => 15 , 'P' => 16 , 'Q' => 17 , 'R' => 18 , 'S' => 19 , 'T' => 20 , 'U' => 21 , 'V' => 22 , 'W' => 23 , 'X' => 24 , 'Y' => 25 , 'Z' => 26 , 'a' => 1 , 'b' => 2 , 'c' => 3 , 'd' => 4 , 'e' => 5 , 'f' => 6 , 'g' => 7 , 'h' => 8 , 'i' => 9 , 'j' => 10 , 'k' => 11 , 'l' => 12 , 'm' => 13 , 'n' => 14 , 'o' => 15 , 'p' => 16 , 'q' => 17 , 'r' => 18 , 's' => 19 , 't' => 20 , 'u' => 21 , 'v' => 22 , 'w' => 23 , 'x' => 24 , 'y' => 25 , 'z' => 26 , ] ; if ( isset ( $ pString [ 0 ] ) ) { if ( ! isset ( $ pString [ 1 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString ] ; return $ indexCache [ $ pString ] ; } elseif ( ! isset ( $ pString [ 2 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString [ 0 ] ] * 26 + $ columnLookup [ $ pString [ 1 ] ] ; return $ indexCache [ $ pString ] ; } elseif ( ! isset ( $ pString [ 3 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString [ 0 ] ] * 676 + $ columnLookup [ $ pString [ 1 ] ] * 26 + $ columnLookup [ $ pString [ 2 ] ] ; return $ indexCache [ $ pString ] ; } } throw new Exception ( 'Column string index can not be ' . ( ( isset ( $ pString [ 0 ] ) ) ? 'longer than 3 characters' : 'empty' ) ) ; }
987	public function chargeParams ( ) { $ chargeDetails = [ 'name' => $ this -> plan -> name , 'price' => $ this -> plan -> price , 'test' => $ this -> plan -> isTest ( ) , 'trial_days' => $ this -> plan -> hasTrial ( ) ? $ this -> plan -> trial_days : 0 , 'return_url' => URL :: secure ( Config :: get ( 'shopify-app.billing_redirect' ) , [ 'plan_id' => $ this -> plan -> id ] ) , ] ; if ( isset ( $ this -> plan -> capped_amount ) && $ this -> plan -> capped_amount > 0 ) { $ chargeDetails [ 'capped_amount' ] = $ this -> plan -> capped_amount ; $ chargeDetails [ 'terms' ] = $ this -> plan -> terms ; } return $ chargeDetails ; }
8104	public function query ( $ sql , $ arguments = false ) { if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } else { return $ stmt ; } }
8199	public function expect ( $ type , $ value = null , $ message = null ) { $ token = $ this -> tokens [ $ this -> current ] ; if ( ! $ token -> test ( $ type , $ value ) ) { $ line = $ token -> getLine ( ) ; throw new Twig_Error_Syntax ( sprintf ( '%sUnexpected token "%s" of value "%s" ("%s" expected%s).' , $ message ? $ message . '. ' : '' , Twig_Token :: typeToEnglish ( $ token -> getType ( ) ) , $ token -> getValue ( ) , Twig_Token :: typeToEnglish ( $ type ) , $ value ? sprintf ( ' with value "%s"' , $ value ) : '' ) , $ line , $ this -> source ) ; } $ this -> next ( ) ; return $ token ; }
406	public function getIsFlash ( ) { $ userAgent = $ this -> headers -> get ( 'User-Agent' , '' ) ; return stripos ( $ userAgent , 'Shockwave' ) !== false || stripos ( $ userAgent , 'Flash' ) !== false ; }
6154	public function setValue ( $ value ) { $ definition = $ this -> propertyType -> getDefinition ( ) ; if ( isset ( $ definition [ 'hierarchical' ] ) && $ definition [ 'hierarchical' ] ) { $ this -> value = [ ] ; foreach ( $ value as $ v ) { foreach ( $ v [ 'value' ] as $ itemValue ) { $ this -> value [ ] = $ this -> convertValue ( $ itemValue [ 'value' ] ) ; } } } elseif ( ! empty ( $ definition [ 'array' ] ) ) { if ( empty ( $ definition [ 'multiplechoice' ] ) && isset ( $ definition [ 'options' ] ) && is_array ( $ definition [ 'options' ] ) ) { $ this -> value = $ this -> convertValue ( current ( $ value ) [ 'value' ] ) ; } else { $ this -> value = [ ] ; foreach ( $ value as $ v ) { $ this -> value [ ] = $ this -> convertValue ( $ v [ 'value' ] ) ; } } } else { $ this -> value = $ this -> convertValue ( $ value ) ; } return $ this ; }
7901	protected function runUpload ( $ file ) { $ this -> provider -> setFile ( $ file ) ; if ( ! $ this -> provider -> isValid ( ) ) { throw new InvalidFileException ( "Given file [{$file}] is invalid." ) ; } $ filename = $ this -> getFullFileName ( $ this -> provider ) ; if ( $ this -> filesystem -> disk ( $ this -> disk ) -> put ( $ filename , $ this -> provider -> getContents ( ) , $ this -> getVisibility ( ) ) ) { return $ filename ; } return false ; }
5893	public function listAudioTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/audio' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new AudioTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
1766	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } $ response = $ event -> getResponse ( ) ; if ( 200 !== $ response -> getStatusCode ( ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ this -> storeBackendReferer ( $ request ) ; } else { $ this -> storeFrontendReferer ( $ request ) ; } }
6889	protected function getAssignments ( $ item ) { if ( $ item instanceof ShipmentItemInterface ) { $ item = $ item -> getSaleItem ( ) ; } elseif ( $ item instanceof InvoiceLineInterface ) { if ( ! $ item = $ item -> getSaleItem ( ) ) { return null ; } } if ( ! $ this -> supportsAssignment ( $ item ) ) { return null ; } return $ item -> getStockAssignments ( ) -> toArray ( ) ; }
3257	public function scopeWhereSKU ( $ query , $ sku ) { return $ query -> join ( config ( 'shop.item_table' ) , config ( 'shop.item_table' ) . '.order_id' , '=' , $ this -> table . '.id' ) -> where ( config ( 'shop.item_table' ) . '.sku' , $ sku ) ; }
580	public static function current ( array $ params = [ ] , $ scheme = false ) { $ currentParams = Yii :: $ app -> getRequest ( ) -> getQueryParams ( ) ; $ currentParams [ 0 ] = '/' . Yii :: $ app -> controller -> getRoute ( ) ; $ route = array_replace_recursive ( $ currentParams , $ params ) ; return static :: toRoute ( $ route , $ scheme ) ; }
6781	protected function updateLocale ( SaleInterface $ sale ) { if ( null !== $ sale -> getLocale ( ) ) { return false ; } $ sale -> setLocale ( $ this -> localeProvider -> getCurrentLocale ( ) ) ; return true ; }
2436	public function getData ( ) { $ data = $ this -> sessionBag -> all ( ) ; foreach ( $ this -> mappedKeys as $ strKey ) { unset ( $ data [ $ strKey ] ) ; if ( $ this -> session -> has ( $ strKey ) ) { $ data [ $ strKey ] = $ this -> session -> get ( $ strKey ) ; } } return $ data ; }
9313	public function infoAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; $ mapper = $ this -> getJobMapper ( ) ; try { $ pendingJobs = $ mapper -> getPending ( ) -> count ( ) ; $ runningJobs = $ mapper -> getRunning ( ) -> count ( ) ; $ finishedJobs = $ mapper -> getHistory ( ) -> count ( ) ; $ console -> writeLine ( sprintf ( 'Pending jobs: %s' , $ pendingJobs ) ) ; $ console -> writeLine ( sprintf ( 'Running jobs: %s' , $ runningJobs ) ) ; $ console -> writeLine ( sprintf ( 'Finished jobs: %s' , $ finishedJobs ) ) ; } catch ( \ PDOException $ exception ) { $ console -> writeLine ( 'Something is bad with your database - either database ' . 'adapter is not properly configured or database table is ' . 'not created.' , ConsoleColor :: LIGHT_RED ) ; } }
11525	private function getDom ( $ url ) { $ ch = curl_init ( ) ; $ timeout = 5 ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , $ timeout ) ; $ dom = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ dom ; }
2213	public function first ( ) { $ this -> intIndex = 0 ; $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ $ this -> intIndex ] ; return $ this ; }
2558	protected function loadPaymentModule ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> fopType , $ options -> payMerchant , $ options -> payments , $ options -> installmentsInfo , $ options -> mopPaymentType , $ options -> creditCardInfo , $ options -> fraudScreening , $ options -> payIds , $ options -> paySupData ) ) { if ( $ this instanceof MopDescription14 ) { $ this -> paymentModule = new PaymentModule14 ( $ options -> fopType ) ; } else { $ this -> paymentModule = new PaymentModule ( $ options -> fopType ) ; } $ this -> paymentModule -> loadPaymentData ( $ options ) ; $ this -> loadMopInformation ( $ options ) ; $ this -> loadPaymentSupplementaryData ( $ options ) ; } }
4293	public function getAbstraction ( & $ mixed , $ method = null , $ hist = array ( ) ) { if ( \ is_array ( $ mixed ) ) { return $ this -> abstractArray -> getAbstraction ( $ mixed , $ method , $ hist ) ; } elseif ( \ is_object ( $ mixed ) ) { return $ this -> abstractObject -> getAbstraction ( $ mixed , $ method , $ hist ) ; } elseif ( \ is_resource ( $ mixed ) || \ strpos ( \ print_r ( $ mixed , true ) , 'Resource' ) === 0 ) { return array ( 'debug' => self :: ABSTRACTION , 'type' => 'resource' , 'value' => \ print_r ( $ mixed , true ) . ': ' . \ get_resource_type ( $ mixed ) , ) ; } }
11523	public function parseBotNames ( ) { $ dom = $ this -> getDom ( 'https://udger.com/resources/ua-list/crawlers' ) ; if ( false === $ dom ) { throw new Exception ( "Fail to load bot list DOM." , E_WARNING ) ; } $ crawler = new Crawler ( ) ; $ crawler -> addContent ( $ dom ) ; $ crawler -> filter ( 'body #container table tr td > a' ) -> each ( function ( $ node , $ i ) { $ botName = $ node -> text ( ) ; $ this -> addBotName ( $ botName ) ; } ) ; }
4777	public function getOutput ( ItemInterface $ item , $ userId ) { if ( $ item -> getCacheTime ( ) ) { $ cache = $ this -> cache -> getItem ( $ item -> getId ( ) . $ userId ) ; $ cache -> expiresAfter ( $ item -> getCacheTime ( ) ) ; if ( false === $ cache -> isHit ( ) ) { $ cache -> set ( $ item -> getTemplate ( ) ? $ this -> engine -> render ( $ item -> getTemplate ( ) , [ 'widget' => $ item ] ) : $ item -> getContent ( ) ) ; $ this -> cache -> save ( $ cache ) ; } return $ cache -> get ( ) ; } return $ item -> getTemplate ( ) ? $ this -> engine -> render ( $ item -> getTemplate ( ) , [ 'widget' => $ item ] ) : $ item -> getContent ( ) ; }
9075	public function add ( $ name , Rule $ rule ) { unset ( $ this -> rules [ $ name ] ) ; $ this -> rules [ $ name ] = $ rule ; }
1627	public function useFiles ( $ path , $ level = 'debug' ) { foreach ( $ this -> loggers as $ logger ) { if ( $ logger instanceof Log ) { $ logger -> useFiles ( $ path , $ level ) ; } } }
11316	public function handleUseRequest ( $ data , $ transactionId , $ transactionKey ) { if ( ! $ this -> objCredits ) { return null ; } if ( isset ( $ _POST [ 'transaction_id' ] ) && isset ( $ _POST [ 'transaction_secret' ] ) ) { $ valid = $ this -> objCredits -> isRequestValid ( $ _POST [ 'transaction_id' ] , $ _POST [ 'transaction_secret' ] ) ; if ( $ valid ) { $ amount = $ _POST [ 'transaction_amount' ] ; $ this -> objUser -> useCredit ( $ amount , $ data ) ; return true ; } else { $ this -> error = 'This request was not valid or already executed. Ignore.' ; } } else { $ this -> error = 'No post data received.' ; } return false ; }
11751	public function stats ( ) { if ( is_null ( $ this -> stats ) ) { $ this -> stats = new Stats ( $ this -> accessToken ) ; } return $ this -> stats ; }
7631	public function setContainerMetadata ( $ containerName = '' , $ metadata = array ( ) , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: isArray ( $ metadata , 'Meta data should be an array of key and value pairs.' ) ; if ( count ( $ metadata ) == 0 ) { return ; } $ headers = array ( ) ; $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'metadata' ) , 'PUT' , $ headers , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
10894	public function get ( $ name ) { return isset ( $ this -> uris [ $ name ] ) ? $ this -> uris [ $ name ] : null ; }
4429	protected function getChoiceQuestion ( $ questionName , $ defaultValue = null , array $ choices = array ( ) ) { $ questionName = $ defaultValue ? '<info>' . $ questionName . '</info> [<comment>' . $ defaultValue . '</comment>]: ' : '<info>' . $ questionName . '</info>: ' ; return new ChoiceQuestion ( $ questionName , $ choices , $ defaultValue ) ; }
5373	public function getValue ( $ key ) { $ values = array ( ) ; foreach ( $ this -> request as $ pair ) { if ( $ pair -> isKey ( $ key ) ) { $ values [ ] = $ pair -> getValue ( ) ; } } if ( count ( $ values ) == 0 ) { return false ; } elseif ( count ( $ values ) == 1 ) { return $ values [ 0 ] ; } else { return $ values ; } }
11037	function store_reduce ( & $ elts , $ value ) { switch ( strtoupper ( $ value ) ) { case 'OFF' : case 'NOTHING' : $ elts [ '0reduce' ] = _ETS_REDUCE_OFF ; return TRUE ; case 'SPACE' : case 'SPACES' : $ elts [ '0reduce' ] = _ETS_REDUCE_SPACES ; return TRUE ; case 'CRLF' : case 'ON' : case 'ALL' : $ elts [ '0reduce' ] = _ETS_REDUCE_ALL ; return TRUE ; default : return FALSE ; } }
2929	public function keyExists ( $ key ) { $ allKeys = $ this -> getKeys ( ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return true ; } return false ; }
10268	function createMailing ( $ name , $ subject , $ deprecatedParameter = false , $ type = "regular" ) { $ queryParameters = array ( 'name' => urlencode ( $ name ) , 'subject' => urlencode ( $ subject ) , 'type' => urlencode ( $ type ) , ) ; return $ this -> post ( 'mailings' , "" , $ queryParameters ) ; }
11934	public function walk ( Callable $ callback ) { $ arrayCopy = $ this -> getArrayCopy ( ) ; $ result = array_walk ( $ arrayCopy , $ callback ) ; $ this -> exchangeArray ( $ arrayCopy ) ; return $ result ; }
2427	public function onBuild ( MenuEvent $ event ) : void { if ( null === $ this -> managerPath || ! $ this -> isAdminUser ( ) ) { return ; } $ categoryNode = $ event -> getTree ( ) -> getChild ( 'system' ) ; if ( null === $ categoryNode ) { return ; } $ item = $ event -> getFactory ( ) -> createItem ( 'contao_manager' , [ 'label' => 'Contao Manager' , 'attributes' => [ 'title' => 'Contao Manager' , 'href' => '/' . $ this -> managerPath , 'class' => 'navigation contao_manager' , ] , ] ) ; $ categoryNode -> addChild ( $ item ) ; }
4053	private function fetchConditions ( $ inputScreenId ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return $ builder -> select ( 'cond.*' , 'setting.attr_id AS setting_attr_id' ) -> from ( 'tl_metamodel_dcasetting_condition' , 'cond' ) -> leftJoin ( 'cond' , 'tl_metamodel_dcasetting' , 'setting' , 'cond.settingId=setting.id' ) -> leftJoin ( 'setting' , 'tl_metamodel_dca' , 'dca' , 'setting.pid=dca.id' ) -> where ( 'cond.enabled=1' ) -> andWhere ( 'setting.published=1' ) -> andWhere ( 'dca.id=:screenId' ) -> setParameter ( 'screenId' , $ inputScreenId ) -> orderBy ( 'pid' ) -> addOrderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
10653	protected function __propertyTraitHasProperty ( $ propertyName ) { if ( method_exists ( $ this , 'get' . $ propertyName ) || method_exists ( $ this , 'set' . $ propertyName ) ) { return true ; } try { $ classReflection = new \ ReflectionProperty ( get_class ( $ this ) , $ propertyName ) ; return $ classReflection -> isPublic ( ) ; } catch ( \ ReflectionException $ ex ) { return false ; } }
2708	public function afterSave ( \ Magento \ Config \ Model \ Config $ subject ) { if ( $ this -> purge ) { $ this -> api -> cleanBySurrogateKey ( [ 'text' ] ) ; } }
10954	protected function ifNoneMatch ( Request $ request , Response $ response , string $ etag ) : Response { $ ifNoneMatch = $ request -> getHeaderLine ( 'If-None-Match' ) ; if ( $ ifNoneMatch && $ etag === $ ifNoneMatch ) { return $ response -> withStatus ( 304 , "Not Modified" ) ; } return $ response ; }
7810	public function getPackageVersion ( ) { $ package_config = file_get_contents ( dirname ( __FILE__ ) . "./../composer.json" ) ; if ( $ package_config ) { $ package_config_object = json_decode ( $ package_config ) ; if ( is_object ( $ package_config_object ) && isset ( $ package_config_object -> version ) ) { return $ package_config_object -> version ; } } return null ; }
53	public function setDownloader ( $ type , DownloaderInterface $ downloader ) { $ type = strtolower ( $ type ) ; $ this -> downloaders [ $ type ] = $ downloader ; return $ this ; }
5247	public function get ( ) { $ child = $ this -> childClassName ; $ query = new QueryBuilder ( ) ; $ query -> filter ( new ParentFilter ( $ this -> parent -> getId ( ) ) ) ; $ collection = $ child :: search ( $ query ) ; $ collection -> each ( function ( ElasticsearchModel $ model ) { $ model -> setParent ( $ this -> parent ) ; } ) ; return $ collection ; }
468	public function buildSimpleCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
5219	public static function castFrom ( $ predicate ) { if ( $ predicate instanceof self ) { return $ predicate ; } elseif ( is_callable ( $ predicate ) ) { return new CallablePredicate ( $ predicate ) ; } throw new \ InvalidArgumentException ( 'Given predicate is neither a callable nor an instance of ' . __CLASS__ ) ; }
9468	public function map ( ) { $ this -> namespace ( 'System' ) -> prefix ( 'system' ) -> name ( 'system.' ) -> group ( function ( ) { $ this -> registerSystemInformationRoutes ( ) ; $ this -> registerLogViewerRoutes ( ) ; $ this -> registerRouteViewerRoutes ( ) ; } ) ; }
10235	private function getImageMimeType ( $ pFile ) { if ( File :: fileExists ( $ pFile ) ) { $ image = getimagesize ( $ pFile ) ; return image_type_to_mime_type ( $ image [ 2 ] ) ; } throw new WriterException ( "File $pFile does not exist" ) ; }
1798	public static function findClass ( $ strName ) { foreach ( $ GLOBALS [ 'TL_CTE' ] as $ v ) { foreach ( $ v as $ kk => $ vv ) { if ( $ kk == $ strName ) { return $ vv ; } } } return '' ; }
7931	public function appendToCollection ( array $ data ) { list ( $ data ) = $ this -> fireEvent ( 'append-to-collection' , [ $ data ] ) ; $ files = [ ] ; if ( isset ( $ data [ 'files' ] [ 'js' ] ) && is_array ( $ data [ 'files' ] [ 'js' ] ) ) $ files [ 'js' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'js' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; if ( isset ( $ data [ 'files' ] [ 'css' ] ) && is_array ( $ data [ 'files' ] [ 'css' ] ) ) $ files [ 'css' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'css' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; $ this -> collection [ ] = [ 'order' => isset ( $ data [ 'order' ] ) ? $ data [ 'order' ] : 0 , 'name' => isset ( $ data [ 'name' ] ) ? $ data [ 'name' ] : uniqid ( ) , 'files' => $ files , 'group' => isset ( $ data [ 'group' ] ) ? $ data [ 'group' ] : $ this -> defaultGroup , 'require' => isset ( $ data [ 'require' ] ) ? $ data [ 'require' ] : [ ] ] ; return $ this ; }
321	public function normalizePathInfo ( $ pathInfo , $ suffix , & $ normalized = false ) { if ( empty ( $ pathInfo ) ) { return $ pathInfo ; } $ sourcePathInfo = $ pathInfo ; if ( $ this -> collapseSlashes ) { $ pathInfo = $ this -> collapseSlashes ( $ pathInfo ) ; } if ( $ this -> normalizeTrailingSlash === true ) { $ pathInfo = $ this -> normalizeTrailingSlash ( $ pathInfo , $ suffix ) ; } $ normalized = $ sourcePathInfo !== $ pathInfo ; return $ pathInfo ; }
4794	function group ( $ columns , $ having = "" ) { $ this -> __destruct ( ) ; $ this -> group = $ columns ; $ this -> having = $ having ; return $ this ; }
9705	private function calcSheetOffsets ( ) { $ boundsheet_length = 10 ; $ offset = $ this -> _datasize ; $ total_worksheets = count ( $ this -> spreadsheet -> getAllSheets ( ) ) ; foreach ( $ this -> spreadsheet -> getWorksheetIterator ( ) as $ sheet ) { $ offset += $ boundsheet_length + strlen ( StringHelper :: UTF8toBIFF8UnicodeShort ( $ sheet -> getTitle ( ) ) ) ; } for ( $ i = 0 ; $ i < $ total_worksheets ; ++ $ i ) { $ this -> worksheetOffsets [ $ i ] = $ offset ; $ offset += $ this -> worksheetSizes [ $ i ] ; } $ this -> biffSize = $ offset ; }
8294	private function openTransactionFile ( $ id ) { if ( ! isset ( $ this -> tFiles [ $ id ] ) ) { self :: preparePath ( $ this -> dir , self :: DATA_DIR ) ; $ fileName = $ this -> dir . static :: DATA_DIR . $ id ; $ handle = @ fopen ( $ fileName , 'c+' ) ; if ( $ handle === false ) { throw new \ RuntimeException ( "Could not open file: " . $ fileName ) ; } $ this -> tFiles [ $ id ] = new \ PicoAuth \ Storage \ File \ FileReader ( $ fileName , [ "handle" => $ handle ] ) ; } }
1194	public function setRequest ( Request $ request ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 2.3 and will be removed in 3.0. Pass a RequestStack in the constructor instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ this -> request = $ request ; }
12343	public function newAction ( Request $ request ) { $ post = new Post ( ) ; $ form = $ this -> createForm ( 'BlogBundle\Form\PostType' , $ post , array ( 'translator' => $ this -> get ( 'translator' ) ) ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ user = $ this -> container -> get ( 'security.token_storage' ) -> getToken ( ) -> getUser ( ) ; $ post -> setActor ( $ user ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ post ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'post.created' ) ; return $ this -> redirectToRoute ( 'blog_post_index' ) ; } return array ( 'category' => $ post , 'form' => $ form -> createView ( ) , ) ; }
11950	private function buildAuthorizationHeader ( array $ params ) { foreach ( $ params as $ key => $ value ) { $ params [ $ key ] = $ key . '="' . rawurlencode ( $ value ) . '"' ; } if ( $ this -> realm ) { array_unshift ( $ params , 'realm="' . rawurlencode ( $ this -> realm ) . '"' ) ; } return [ 'Authorization' , 'OAuth ' . implode ( ', ' , $ params ) ] ; }
7189	private function copyAdjustment ( Model \ AdjustmentInterface $ source , Model \ AdjustmentInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'designation' , 'type' , 'mode' , 'amount' , 'immutable' , ] ) ; }
10371	public static function add_scripts ( ) { self :: look_if_process_files ( 'script' ) ; foreach ( self :: $ data [ 'script' ] as $ data ) { $ params = [ 'plugin_url' => defined ( 'WP_PLUGIN_URL' ) ? WP_PLUGIN_URL . '/' : '' , 'nonce' => wp_create_nonce ( $ data [ 'name' ] ) , ] ; $ data [ 'params' ] = array_merge ( $ data [ 'params' ] , $ params ) ; wp_register_script ( $ data [ 'name' ] , $ data [ 'url' ] , $ data [ 'deps' ] , $ data [ 'version' ] , $ data [ 'footer' ] ) ; wp_enqueue_script ( $ data [ 'name' ] ) ; wp_localize_script ( $ data [ 'name' ] , $ data [ 'name' ] , $ data [ 'params' ] ) ; } }
377	private function getByteSize ( $ verboseSize ) { if ( empty ( $ verboseSize ) ) { return 0 ; } if ( is_numeric ( $ verboseSize ) ) { return ( int ) $ verboseSize ; } $ sizeUnit = trim ( $ verboseSize , '0123456789' ) ; $ size = trim ( str_replace ( $ sizeUnit , '' , $ verboseSize ) ) ; if ( ! is_numeric ( $ size ) ) { return 0 ; } switch ( strtolower ( $ sizeUnit ) ) { case 'kb' : case 'k' : return $ size * 1024 ; case 'mb' : case 'm' : return $ size * 1024 * 1024 ; case 'gb' : case 'g' : return $ size * 1024 * 1024 * 1024 ; default : return 0 ; } }
7173	protected function resolveCustomerTargetCountry ( CustomerInterface $ customer ) : ? CountryInterface { if ( null !== $ address = $ customer -> getDefaultDeliveryAddress ( ) ) { return $ address -> getCountry ( ) ; } return null ; }
4800	function via ( $ column ) { $ this -> column = $ column ; $ this -> conditions [ 0 ] = "$this->table.$column AND" ; $ this -> where [ 0 ] = "(" . $ this -> whereIn ( "$this->table.$column" , array_keys ( ( array ) $ this -> result -> rows ) ) . ")" ; return $ this ; }
1720	private function getChunksFromUnit ( \ DOMElement $ unit ) : array { $ chunks = explode ( '.' , $ unit -> getAttribute ( 'id' ) ) ; if ( preg_match ( '/tl_layout\.[a-z]+\.css\./' , $ unit -> getAttribute ( 'id' ) ) ) { $ chunks = [ $ chunks [ 0 ] , $ chunks [ 1 ] . '.' . $ chunks [ 2 ] , $ chunks [ 3 ] ] ; } return $ chunks ; }
12385	public function permalinksByLanguage ( $ language = null ) { $ result = array ( ) ; if ( null === $ language ) { $ language = $ this -> currentLanguage ; } foreach ( $ this -> pages as $ page ) { foreach ( $ page [ "seo" ] as $ pageAttribute ) { if ( $ pageAttribute [ "language" ] != $ language ) { continue ; } $ result [ ] = $ pageAttribute [ "permalink" ] ; } } return $ result ; }
125	public function whatProvides ( $ name , ConstraintInterface $ constraint = null , $ mustMatchName = false , $ bypassFilters = false ) { if ( $ bypassFilters ) { return $ this -> computeWhatProvides ( $ name , $ constraint , $ mustMatchName , true ) ; } $ key = ( ( int ) $ mustMatchName ) . $ constraint ; if ( isset ( $ this -> providerCache [ $ name ] [ $ key ] ) ) { return $ this -> providerCache [ $ name ] [ $ key ] ; } return $ this -> providerCache [ $ name ] [ $ key ] = $ this -> computeWhatProvides ( $ name , $ constraint , $ mustMatchName , $ bypassFilters ) ; }
12003	public function getSessionKey ( $ jsCode ) { $ params = [ 'appid' => $ this -> config [ 'app_id' ] , 'secret' => $ this -> config [ 'secret' ] , 'js_code' => $ jsCode , 'grant_type' => 'authorization_code' , ] ; return $ this -> parseJSON ( 'GET' , [ self :: JSCODE_TO_SESSION , $ params ] ) ; }
8553	public function setDebtRecoveryEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DebtRecoveryEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7958	public function isIpv6Enabled ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> ipv6Enabled ; }
11032	protected function supports ( $ attribute , $ subject ) { if ( ! in_array ( $ attribute , array ( self :: MENU , self :: PERMISO ) ) ) { return false ; } if ( $ attribute == self :: MENU && ! is_null ( $ subject ) && ! $ subject instanceof Menu ) { return false ; } return true ; }
11213	protected function removeFromLookup ( $ registry ) { foreach ( $ this -> lookup_pool as $ idx => $ reg ) { if ( $ registry === $ reg ) { if ( $ reg instanceof DelegatorAwareInterface ) { $ reg -> setDelegator ( ) ; } unset ( $ this -> lookup_pool [ $ idx ] ) ; } } return $ this ; }
9632	public function getSetting ( $ setting ) { $ settings = $ this -> getSettings ( ) ; if ( isset ( $ settings ) && count ( $ settings ) > 0 ) { if ( isset ( $ settings [ $ setting ] ) ) { return $ settings [ $ setting ] ; } } return '' ; }
11463	public static function exception ( $ Throwable ) { while ( @ ob_end_clean ( ) ) ; try { if ( PHP_SAPI == 'cli' ) { $ message = BaseException :: displayConsoleException ( $ Throwable ) ; if ( @ fwrite ( STDERR , $ message ) === false ) echo $ message ; } else { @ header ( "HTTP/1.1 500 Internal Server Error" ) ; @ header ( 'Content-Type: text/html' ) ; echo BaseException :: displayException ( $ Throwable ) ; } } catch ( \ Throwable $ e ) { $ class = get_class ( $ e ) ; $ message = $ e -> getMessage ( ) ; echo "Uncaught $class inside exception-handler: \"$message\"" ; } exit ( 1 ) ; }
4739	public static function clearTmp ( $ clearFolderPath = '' ) { $ folderPath = self :: _getFolderToClear ( $ clearFolderPath ) ; $ directoryHandler = opendir ( $ folderPath ) ; if ( ! empty ( $ directoryHandler ) ) { while ( false !== ( $ fileName = readdir ( $ directoryHandler ) ) ) { $ filePath = $ folderPath . DIRECTORY_SEPARATOR . $ fileName ; self :: _clear ( $ fileName , $ filePath ) ; } closedir ( $ directoryHandler ) ; } return true ; }
5657	private function createEmptyForm ( $ node ) { return new SimpleForm ( $ this -> tags ( ) -> createTag ( $ node -> name , ( array ) $ node -> attribute ) , $ this -> page ) ; }
10048	public function getColourByIndex ( $ index ) { if ( isset ( $ this -> colourMap [ $ index ] ) ) { return $ this -> colourMap [ $ index ] ; } return null ; }
8936	public function createChangeset ( $ changesets = array ( ) ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , 'oauth_token_secret' => $ token [ 'secret' ] , ) ; $ base = 'changeset/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap">' ; if ( ! empty ( $ changesets ) ) { foreach ( $ changesets as $ tags ) { $ xml .= '<changeset>' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ xml .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml .= '</changeset>' ; } } $ xml .= '</osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
7110	protected function getTicketFromEvent ( ResourceEventInterface $ event ) { $ ticket = $ event -> getResource ( ) ; if ( ! $ ticket instanceof TicketInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketInterface :: class ) ; } return $ ticket ; }
617	private function parseArray ( $ value , & $ i = 0 ) { $ result = [ ] ; $ len = strlen ( $ value ) ; for ( ++ $ i ; $ i < $ len ; ++ $ i ) { switch ( $ value [ $ i ] ) { case '{' : $ result [ ] = $ this -> parseArray ( $ value , $ i ) ; break ; case '}' : break 2 ; case $ this -> delimiter : if ( empty ( $ result ) ) { $ result [ ] = null ; } if ( in_array ( $ value [ $ i + 1 ] , [ $ this -> delimiter , '}' ] , true ) ) { $ result [ ] = null ; } break ; default : $ result [ ] = $ this -> parseString ( $ value , $ i ) ; } } return $ result ; }
4004	public function getMetaModelNameFromId ( GetMetaModelNameFromIdEvent $ event ) { $ metaModelId = $ event -> getMetaModelId ( ) ; if ( array_key_exists ( $ metaModelId , $ this -> instancesById ) ) { $ event -> setMetaModelName ( $ this -> instancesById [ $ metaModelId ] -> getTableName ( ) ) ; return ; } if ( isset ( $ this -> tableNames [ $ metaModelId ] ) ) { $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; return ; } if ( ! $ this -> tableNamesCollected ) { $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ metaModelId ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ this -> tableNames [ $ metaModelId ] = $ table [ 'tableName' ] ; $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; } } }
2194	protected function activateAcount ( ) { $ this -> strTemplate = 'mod_message' ; $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) != 1 || key ( $ arrRelated ) != 'tl_member' || \ count ( $ arrIds = current ( $ arrRelated ) ) != 1 || ( ! $ objMember = MemberModel :: findByPk ( $ arrIds [ 0 ] ) ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objMember -> email ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ objMember -> disable = '' ; $ objMember -> save ( ) ; $ optInToken -> confirm ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateAccount' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateAccount' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateAccount' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objMember , $ this ) ; } } $ this -> log ( 'User account ID ' . $ objMember -> id . ' (' . Idna :: decodeEmail ( $ objMember -> email ) . ') has been activated' , __METHOD__ , TL_ACCESS ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'reg_jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } $ this -> Template -> type = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'accountActivated' ] ; }
11608	public function actionConfirm ( $ id , $ code ) { $ user = $ this -> finder -> findUserById ( $ id ) ; if ( $ user === null || $ this -> module -> emailChangeStrategy == Module :: STRATEGY_INSECURE ) { throw new NotFoundHttpException ; } $ user -> attemptEmailChange ( $ code ) ; return $ this -> redirect ( [ 'account' ] ) ; }
12720	public function callInstance ( $ instance , $ args = [ ] ) { $ args = ( is_array ( $ args ) ? $ args : array_slice ( func_get_args ( ) , 1 ) ) ; $ current = $ this -> make ( $ instance ) ; return call_user_func_array ( $ current , $ args ) ; }
2134	public static function remove ( $ strKey ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> delete ( $ strKey ) ; }
7665	function EncodeFile ( $ path , $ encoding = "base64" ) { if ( ! @ $ fd = fopen ( $ path , "rb" ) ) { $ this -> SetError ( $ this -> Lang ( "file_open" ) . $ path ) ; return "" ; } $ magic_quotes = get_magic_quotes_runtime ( ) ; set_magic_quotes_runtime ( 0 ) ; $ file_buffer = fread ( $ fd , filesize ( $ path ) ) ; $ file_buffer = $ this -> EncodeString ( $ file_buffer , $ encoding ) ; fclose ( $ fd ) ; set_magic_quotes_runtime ( $ magic_quotes ) ; return $ file_buffer ; }
4999	protected function fixOneToMany ( PageInterface $ object ) { $ items = $ object -> getContentItems ( ) ; if ( $ items ) { foreach ( $ object -> getContentItems ( ) as $ item ) { $ item -> setPage ( $ object ) ; } } if ( $ this -> menuManager ) { $ this -> menuManager -> flush ( ) ; } }
5694	public function index ( HTTPRequest $ r ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/betterbuttons_nested_form.css' ) ; return $ this -> customise ( array ( 'Form' => $ this -> Form ( ) ) ) -> renderWith ( BetterButtonNestedForm :: class ) ; }
6720	public function authorize ( ) { $ this -> validateAuthParams ( ) ; try { $ response = $ this -> curl -> setOption ( CURLOPT_POSTFIELDS , http_build_query ( array ( 'grant_type' => self :: GRANT_TYPE_AUTHORIZATION_CODE , 'client_id' => $ this -> clientId , 'client_secret' => $ this -> clientSecret , 'response_type' => self :: RESPONSE_TYPE_CODE , 'state' => self :: STATE_ALIVE ) ) ) -> post ( $ this -> authUrl , false ) ; } catch ( InvalidParamException $ invalidParamException ) { throw new Oauth2ClientException ( $ invalidParamException -> getMessage ( ) ) ; } return $ this -> handleAuthorizeResponse ( $ response ) ; }
7622	public function signRequestUrl ( $ requestUrl = '' , $ resourceType = Storage :: RESOURCE_UNKNOWN , $ requiredPermission = CredentialsAbstract :: PERMISSION_READ ) { foreach ( $ this -> getPermissionSet ( ) as $ permittedUrl ) { if ( $ this -> permissionMatchesRequest ( $ permittedUrl , $ requestUrl , $ resourceType , $ requiredPermission ) ) { $ parsedPermittedUrl = parse_url ( $ permittedUrl ) ; if ( strpos ( $ requestUrl , '?' ) === false ) { $ requestUrl .= '?' ; } else { $ requestUrl .= '&' ; } $ requestUrl .= $ parsedPermittedUrl [ 'query' ] ; return $ requestUrl ; } } return $ requestUrl ; }
865	private function skipNonArrayElements ( $ index , Tokens $ tokens ) { if ( $ tokens [ $ index ] -> equals ( '}' ) ) { return $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ; } if ( $ tokens [ $ index ] -> equals ( ')' ) ) { $ startIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ startIndex = $ tokens -> getPrevMeaningfulToken ( $ startIndex ) ; if ( ! $ tokens [ $ startIndex ] -> isGivenKind ( [ T_ARRAY , CT :: T_ARRAY_SQUARE_BRACE_OPEN ] ) ) { return $ startIndex ; } } return $ index ; }
7497	public function createMessageFromTemplateFile ( $ template , $ params , $ subject , $ recipient , $ sender = null ) { $ body = $ this -> templating -> render ( $ template , $ params ) ; if ( ! $ sender ) { $ sender = $ this -> defaultSender ; } $ message = new \ Swift_Message ( ) ; $ message -> setFrom ( $ sender ) -> setReplyTo ( $ sender ) -> setTo ( $ recipient ) -> setSubject ( $ subject ) -> setBody ( $ body , 'text/html' ) ; return $ message ; }
12223	public function get ( $ keys = [ ] ) { $ this -> buildIfNotBuilded ( ) ; $ keys = $ keys == [ ] ? $ this -> keys ( ) : $ keys ; if ( ! $ keys ) { return $ this -> builder -> get ( ) ; } return $ this -> builder -> withColumns ( $ keys ) -> get ( $ keys ) ; }
7621	public function permissionMatchesRequest ( $ permissionUrl = '' , $ requestUrl = '' , $ resourceType = Storage :: RESOURCE_UNKNOWN , $ requiredPermission = CredentialsAbstract :: PERMISSION_READ ) { $ requiredResourceType = $ resourceType ; if ( $ requiredResourceType == Storage :: RESOURCE_BLOB ) { $ requiredResourceType .= Storage :: RESOURCE_CONTAINER ; } $ parsedPermissionUrl = parse_url ( $ permissionUrl ) ; $ permissionParts = explode ( '&' , $ parsedPermissionUrl [ 'query' ] ) ; $ parsedRequestUrl = parse_url ( $ requestUrl ) ; $ matches = true ; foreach ( $ permissionParts as $ part ) { list ( $ property , $ value ) = explode ( '=' , $ part , 2 ) ; if ( $ property == 'sr' ) { $ matches = $ matches && ( strpbrk ( $ value , $ requiredResourceType ) !== false ) ; } if ( $ property == 'sp' ) { $ matches = $ matches && ( strpbrk ( $ value , $ requiredPermission ) !== false ) ; } } $ matches = $ matches && ( strpos ( $ parsedRequestUrl [ 'path' ] , $ parsedPermissionUrl [ 'path' ] ) !== false ) ; return $ matches ; }
7530	protected function toString_attributes ( ) { $ s = '' ; foreach ( $ this -> attributes as $ a => $ v ) { $ s .= ' ' . $ a ; if ( ( ! $ this -> attribute_shorttag ) || ( $ v !== $ a ) ) { $ quote = ( strpos ( $ v , '"' ) === false ) ? '"' : "'" ; $ s .= '=' . $ quote . $ v . $ quote ; } } return $ s ; }
2291	public function onKernelTerminate ( PostResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } if ( preg_match ( '~(?:^|/)' . preg_quote ( $ this -> fragmentPath , '~' ) . '/~' , $ request -> getPathInfo ( ) ) ) { return ; } $ frontend = $ this -> framework -> getAdapter ( Frontend :: class ) ; $ frontend -> indexPageIfApplicable ( $ event -> getResponse ( ) ) ; }
6750	public function getTransformer ( ) { if ( ! property_exists ( $ this , 'transformer' ) || ! $ this -> transformer ) { if ( ! $ this -> _defaultTransformer ) { $ this -> createQualifiedTransformerClass ( ) ; } return $ this -> _defaultTransformer ; } return $ this -> transformer ; }
5008	public function trigger ( $ event , $ target = null ) { if ( empty ( $ this -> _template ) || ! is_string ( $ this -> _template ) ) { throw new \ InvalidArgumentException ( 'ContentCollector must have a template-name' ) ; } $ responseCollection = $ this -> getController ( ) -> getEventManager ( ) -> trigger ( $ event , $ target ) ; $ viewModel = new ViewModel ( ) ; $ viewModel -> setTemplate ( $ this -> _template ) ; foreach ( $ responseCollection as $ i => $ response ) { if ( is_string ( $ response ) ) { $ template = $ response ; $ response = new ViewModel ( array ( 'target' => $ target ) ) ; $ response -> setTemplate ( $ template ) ; } $ viewModel -> addChild ( $ response , $ this -> _captureTo . $ i ) ; } return $ viewModel ; }
8371	protected function shutdown ( ) { $ this -> shutdown = true ; $ this -> args [ 'messages' ] = array_filter ( $ this -> messages , function ( $ message ) { if ( ! isset ( $ message [ 'sent' ] ) || $ message [ 'sent' ] === false ) { return $ message ; } } ) ; $ redis = new Redis ; $ client = new Client ( $ redis ) ; $ client -> push ( static :: class , $ this -> args , 1 , 100 ) ; return true ; }
11157	public function handleUrl ( $ url , Event $ event , Queue $ queue ) { $ logger = $ this -> getLogger ( ) ; $ logger -> info ( 'handleUrl' , array ( 'url' => $ url ) ) ; $ v = $ this -> getVideoId ( $ url ) ; $ logger -> info ( 'getVideoId' , array ( 'url' => $ url , 'v' => $ v ) ) ; if ( ! $ v ) { return ; } $ apiUrl = $ this -> getApiUrl ( $ v ) ; $ request = $ this -> getApiRequest ( $ apiUrl , $ event , $ queue ) ; $ this -> getEventEmitter ( ) -> emit ( 'http.request' , array ( $ request ) ) ; }
8764	private function createUniqueFilename ( $ filename ) { $ full_size_dir = config ( 'dropzoner.upload-path' ) ; $ full_image_path = $ full_size_dir . $ filename . '.jpg' ; if ( \ File :: exists ( $ full_image_path ) ) { $ image_token = substr ( sha1 ( mt_rand ( ) ) , 0 , 5 ) ; return $ filename . '-' . $ image_token ; } return $ filename ; }
10570	protected function parseSort ( string $ sort , array & $ sorts ) { if ( strlen ( trim ( $ sort ) ) === 0 ) { return ; } if ( substr ( $ sort , 0 , 1 ) == "[" ) { $ json = json_decode ( $ sort ) ; if ( is_array ( $ json ) ) { foreach ( $ json as $ s ) { if ( is_object ( $ s ) ) { $ sorts [ $ s -> property ] = strcasecmp ( self :: DESC , $ s -> direction ) !== 0 ; } } return ; } } if ( substr ( $ sort , - 4 ) == ",asc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 4 ) ] = true ; } elseif ( substr ( $ sort , - 5 ) == ",desc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 5 ) ] = false ; } elseif ( substr ( $ sort , - 10 ) == ":ascending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 10 ) ] = true ; } elseif ( substr ( $ sort , - 11 ) == ":descending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 11 ) ] = false ; } else { foreach ( explode ( ',' , $ sort ) as $ s ) { if ( substr ( $ s , 0 , 1 ) === '-' ) { $ sorts [ substr ( $ s , 1 ) ] = false ; } elseif ( substr ( $ s , 0 , 1 ) === '+' ) { $ sorts [ substr ( $ s , 1 ) ] = true ; } else { $ sorts [ $ s ] = true ; } } } }
1294	public static function create ( JsonDecoderClientInterface $ client , ClientOptions $ options ) : ResourcePoolInterface { if ( $ options -> usesLowMemoryResourcePool ( ) ) { return new Standard ( $ client -> getApi ( ) , $ client -> getSpaceId ( ) , $ client -> getEnvironmentId ( ) ) ; } return new Extended ( $ client , $ options -> getCacheItemPool ( ) , $ options -> hasCacheAutoWarmup ( ) , $ options -> hasCacheContent ( ) ) ; }
7878	protected function registerLogFilesystem ( ) { $ this -> app -> singleton ( 'logviewer.filesystem' , function ( $ app ) { $ files = $ app [ 'files' ] ; $ path = $ app [ 'path.storage' ] . '/logs' ; return new Filesystem ( $ files , $ path ) ; } ) ; $ this -> app -> alias ( 'logviewer.filesystem' , Filesystem :: class ) ; }
5278	public function orWhere ( $ column , $ param1 = null , $ param2 = null ) { return $ this -> where ( $ column , $ param1 , $ param2 , 'or' ) ; }
10118	private function writeMarginLeft ( ) { $ record = 0x0026 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getLeft ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
8957	public function redaction ( $ element , $ id , $ version , $ redactionId ) { if ( $ element != 'node' && $ element != 'way' && $ element != 'relation' ) { throw new \ DomainException ( 'Element should be a node, a way or a relation' ) ; } $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = $ element . '/' . $ id . '/' . $ version . '/redact?redaction=' . $ redactionId ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters ) ; return simplexml_load_string ( $ response -> body ) ; }
3510	public static function dbValue ( $ value , $ nullValue = 'NULL' ) { if ( $ value === null ) { return $ nullValue ; } if ( is_string ( $ value ) ) { return '\'' . str_replace ( '\'' , '\'\'' , $ value ) . '\'' ; } if ( is_bool ( $ value ) ) { return $ value ? '1' : '0' ; } return $ value ; }
12974	protected function autoLoadMappingInfo ( ) { $ mappings = array ( ) ; foreach ( \ Package :: loaded ( ) as $ package => $ path ) { $ mappings [ ] = $ package . '::package' ; } foreach ( \ Module :: loaded ( ) as $ module => $ path ) { $ mappings [ ] = $ module . '::module' ; } $ mappings [ ] = 'app' ; $ mappings = array_fill_keys ( $ mappings , array ( 'is_component' => true ) ) ; $ this -> setMappings ( $ mappings ) ; }
4298	public function count ( $ label = null , $ flags = 0 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; if ( \ count ( $ args ) == 1 && \ is_int ( $ args [ 0 ] ) ) { $ label = null ; $ flags = $ args [ 0 ] ; } else { $ args = \ array_combine ( array ( 'label' , 'flags' ) , \ array_replace ( array ( null , 0 ) , $ args ) ) ; \ extract ( $ args ) ; } if ( isset ( $ label ) ) { $ dataLabel = ( string ) $ label ; } else { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ meta = \ array_merge ( array ( 'file' => $ callerInfo [ 'file' ] , 'line' => $ callerInfo [ 'line' ] , ) , $ meta ) ; $ label = 'count' ; $ dataLabel = $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] ; } if ( ! isset ( $ this -> data [ 'counts' ] [ $ dataLabel ] ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] = 0 ; } if ( ! ( $ flags & self :: COUNT_NO_INC ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] ++ ; } $ count = $ this -> data [ 'counts' ] [ $ dataLabel ] ; if ( ! ( $ flags & self :: COUNT_NO_OUT ) ) { $ this -> appendLog ( 'count' , array ( ( string ) $ label , $ count , ) , $ meta ) ; } return $ count ; }
4307	public function timeEnd ( $ label = null , $ returnOrTemplate = false , $ precision = 4 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'label' => null , 'returnOrTemplate' => false , 'precision' => 4 , ) ) ; \ extract ( $ args ) ; if ( \ is_bool ( $ label ) || \ strpos ( $ label , '%time' ) !== false ) { if ( \ is_numeric ( $ returnOrTemplate ) ) { $ precision = $ returnOrTemplate ; } $ returnOrTemplate = $ label ; $ label = null ; } $ ret = $ this -> timeGet ( $ label , true , null ) ; if ( isset ( $ label ) ) { if ( isset ( $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] ) ) { $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] = array ( $ ret , null , ) ; } } else { $ label = 'time' ; \ array_pop ( $ this -> data [ 'timers' ] [ 'stack' ] ) ; } if ( \ is_int ( $ precision ) ) { $ ret = \ number_format ( $ ret , $ precision , '.' , '' ) ; } $ this -> doTime ( $ ret , $ returnOrTemplate , $ label , $ meta ) ; return $ ret ; }
10948	public function getCsrfToken ( $ regenerate = false ) { if ( $ this -> _csrfToken === null || $ regenerate ) { if ( $ regenerate || ( $ token = $ this -> loadCsrfToken ( ) ) === null ) { $ token = $ this -> generateCsrfToken ( ) ; } $ chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-.' ; $ mask = substr ( str_shuffle ( str_repeat ( $ chars , 5 ) ) , 0 , static :: CSRF_MASK_LENGTH ) ; $ this -> _csrfToken = str_replace ( '+' , '.' , base64_encode ( $ mask . $ this -> xorTokens ( $ token , $ mask ) ) ) ; } return $ this -> _csrfToken ; }
3454	public static function fromAggregateRoot ( $ eventSourcedAggregateRoot ) : AggregateType { if ( ! \ is_object ( $ eventSourcedAggregateRoot ) ) { throw new Exception \ AggregateTypeException ( \ sprintf ( 'Aggregate root must be an object but type of %s given' , \ gettype ( $ eventSourcedAggregateRoot ) ) ) ; } if ( $ eventSourcedAggregateRoot instanceof AggregateTypeProvider ) { return $ eventSourcedAggregateRoot -> aggregateType ( ) ; } $ self = new static ( ) ; $ self -> aggregateType = \ get_class ( $ eventSourcedAggregateRoot ) ; return $ self ; }
2082	public function generateXmlFiles ( ) { $ this -> generateSitemap ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( ) ; } } $ this -> purgePageCache ( ) ; $ this -> log ( 'Regenerated the XML files' , __METHOD__ , TL_CRON ) ; }
2843	public function getBlockTreeHtml ( ) { $ content = '' ; $ rootNodes = $ this -> getBlocksAsTree ( ) ; foreach ( $ rootNodes as $ rootNode ) { $ content .= $ this -> renderTreeNode ( $ rootNode ) ; } return $ content ; }
9185	protected function toArray ( $ data , $ type , $ format ) { $ serializer = SerializerBuilder :: create ( ) -> build ( ) ; return $ serializer -> toArray ( $ serializer -> deserialize ( $ data , $ type , $ format ) ) ; }
6281	public static function buildDnsResolver ( LoopInterface $ loop , $ dns = '8.8.8.8' ) { $ factory = new DnsResolverFactory ( ) ; return $ factory -> createCached ( $ dns , $ loop ) ; }
8755	public function buildTracker ( $ numItems = Tracker :: UNKNOWN , array $ extraSubscribers = [ ] ) { $ tracker = new Tracker ( $ numItems ) ; foreach ( array_merge ( $ this -> defaultSubscribers , $ extraSubscribers ) as $ listener ) { $ tracker -> getDispatcher ( ) -> addSubscriber ( $ listener ) ; } return $ tracker ; }
505	public function init ( ) { parent :: init ( ) ; if ( ! isset ( $ this -> translations [ 'yii' ] ) && ! isset ( $ this -> translations [ 'yii*' ] ) ) { $ this -> translations [ 'yii' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => 'en-US' , 'basePath' => '@yii/messages' , ] ; } if ( ! isset ( $ this -> translations [ 'app' ] ) && ! isset ( $ this -> translations [ 'app*' ] ) ) { $ this -> translations [ 'app' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => Yii :: $ app -> sourceLanguage , 'basePath' => '@app/messages' , ] ; } }
8067	public function run ( $ input ) { while ( $ this -> workerPoolSize > 0 ) { try { $ processDetailsOfFreeWorker = $ this -> getNextFreeWorker ( ) ; $ processDetailsOfFreeWorker -> getSocket ( ) -> send ( array ( 'cmd' => 'run' , 'data' => $ input ) ) ; return $ processDetailsOfFreeWorker -> getPid ( ) ; } catch ( \ Exception $ e ) { pcntl_signal_dispatch ( ) ; } } throw new WorkerPoolException ( 'Unable to run the task.' ) ; }
11491	public function getAll ( ) : array { $ res = [ ] ; foreach ( $ this -> getKeys ( ) as $ key ) { $ res [ $ key ] = $ this -> get ( $ key ) ; } return $ res ; }
5274	public function groupBy ( $ columns ) { if ( is_string ( $ columns ) ) { $ columns = $ this -> argument_to_array ( $ columns ) ; } $ this -> statements [ 'groups' ] = $ this -> statements [ 'groups' ] + $ columns ; return $ this ; }
2596	public static function decodeProcessingLevel ( $ level ) { $ decoded = null ; $ map = [ 0 => 'system' , 1 => 'application' ] ; if ( array_key_exists ( $ level , $ map ) ) { $ decoded = $ map [ $ level ] ; } return $ decoded ; }
6591	protected function asset ( $ type ) { $ busters = $ this -> checkAndGetBusters ( ) ; $ bustersOfThisType = array ( ) ; foreach ( $ busters as $ key => $ value ) { if ( strpos ( $ key , $ type ) !== false ) { $ bustersOfThisType [ $ key ] = $ value ; } } $ busterStrings = $ this -> parseTags ( $ bustersOfThisType , $ type ) ; return implode ( "\n" , $ busterStrings ) ; }
8667	public function setMessage ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Message' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6001	public function addImageTemplate ( $ item ) { if ( ! ( $ item instanceof ImageTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new ImageTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate ImageTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "ImageTemplate"!' , E_USER_WARNING ) ; } } $ this -> imagetemplates [ ] = $ item ; return $ this ; }
5126	public static function init ( array $ directories , EnvironmentInterface $ environment = null , bool $ handleErrors = true ) : ? self { if ( $ handleErrors ) { ExceptionHandler :: register ( ) ; } $ core = new static ( new Container ( ) , $ directories ) ; $ core -> container -> bindSingleton ( EnvironmentInterface :: class , $ environment ?? new Environment ( ) ) ; try { ContainerScope :: runScope ( $ core -> container , function ( ) use ( $ core ) { $ core -> bootload ( ) ; $ core -> bootstrap ( ) ; } ) ; } catch ( \ Throwable $ e ) { ExceptionHandler :: handleException ( $ e ) ; return null ; } return $ core ; }
8736	public function insert ( array $ values ) { list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; if ( $ this -> query -> insert ( $ values ) ) { return $ this -> insertI18n ( $ i18nValues , $ values [ $ this -> model -> getKeyName ( ) ] ) ; } }
10377	protected static function prepare_files ( $ type ) { $ params [ 'type' ] = $ type ; $ params [ 'routes' ] = self :: get_routes_to_folder ( $ type ) ; self :: get_processed_files ( ) ; foreach ( self :: $ data [ $ type ] as $ id => $ file ) { $ path = self :: get_path_from_url ( $ file [ 'url' ] ) ; $ params [ 'files' ] [ $ id ] = basename ( $ file [ 'url' ] ) ; $ params [ 'urls' ] [ $ id ] = $ file [ 'url' ] ; $ params [ 'paths' ] [ $ id ] = $ path ; if ( is_file ( $ path ) && self :: is_modified_file ( $ path ) ) { unset ( $ params [ 'urls' ] [ $ id ] ) ; continue ; } $ path = $ params [ 'routes' ] [ 'path' ] . $ params [ 'files' ] [ $ id ] ; if ( is_file ( $ path ) ) { if ( self :: is_modified_hash ( $ file [ 'url' ] , $ path ) ) { continue ; } $ params [ 'paths' ] [ $ id ] = $ path ; } elseif ( self :: is_external_url ( $ file [ 'url' ] ) ) { continue ; } unset ( $ params [ 'urls' ] [ $ id ] ) ; } return $ params ; }
5641	public function paintCaseStart ( $ test_name ) { if ( ! isset ( $ this -> size ) ) { $ this -> size = 1 ; } if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintHeader ( $ test_name ) ; } $ this -> test_stack [ ] = $ test_name ; }
12806	public static function select ( ) : Collection { $ pdo = Database :: connect ( ) ; $ class = self :: getStaticChildClass ( ) ; $ tableName = self :: getTableName ( ) ; $ sql = "SELECT * FROM \"$tableName\"" ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; $ collection = new Collection ( $ class , [ ] ) ; foreach ( $ results as $ result ) { $ object = new $ class ( $ result ) ; $ collection -> push ( $ object ) ; } return $ collection ; }
9391	public function getSortValAfterAll ( $ groupingId = null ) { if ( ! $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( $ this -> srtColumn ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( $ this -> srtColumn . ' DESC' ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result ) { $ result = array_values ( $ result ) ; $ sortVal = $ result [ 0 ] + $ this -> sortGap ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
4237	public static function getMetaVals ( & $ args , $ defaultMeta = array ( ) , $ defaultArgs = array ( ) , $ argsToMeta = array ( ) ) { $ meta = array ( ) ; foreach ( $ args as $ i => $ v ) { if ( \ is_array ( $ v ) && isset ( $ v [ 'debug' ] ) && $ v [ 'debug' ] === Debug :: META ) { unset ( $ v [ 'debug' ] ) ; $ meta = \ array_merge ( $ meta , $ v ) ; unset ( $ args [ $ i ] ) ; } } $ args = \ array_values ( $ args ) ; if ( $ defaultArgs ) { $ args = \ array_slice ( $ args , 0 , \ count ( $ defaultArgs ) ) ; $ args = \ array_combine ( \ array_keys ( $ defaultArgs ) , \ array_replace ( \ array_values ( $ defaultArgs ) , $ args ) ) ; } foreach ( $ argsToMeta as $ argk => $ metak ) { if ( \ is_int ( $ argk ) ) { $ argk = $ metak ; } $ defaultMeta [ $ metak ] = $ args [ $ argk ] ; unset ( $ args [ $ argk ] ) ; } $ meta = \ array_merge ( $ defaultMeta , $ meta ) ; return $ meta ; }
11367	public static function getMimeType ( $ filename = '' ) { $ ext = strtolower ( substr ( $ filename , strrpos ( $ filename , '.' ) ) ) ; switch ( $ ext ) { case '.jpeg' : case '.jpg' : $ mimetype = 'image/jpeg' ; break ; case '.gif' : $ mimetype = 'image/gif' ; break ; case '.png' : $ mimetype = 'image/png' ; break ; case '.txt' : $ mimetype = 'text/plain' ; break ; case '.html' : case '.htm' : $ mimetype = 'text/html' ; break ; case '.zip' : $ mimetype = 'application/x-zip-compressed' ; break ; default : $ mimetype = 'application/octet-stream' ; } return $ mimetype ; }
12669	public function addNamespace ( $ namespaceOptions , $ namespace = null ) { if ( ! $ namespaceOptions instanceof NamespaceOptionsInterface ) { if ( is_array ( $ namespaceOptions ) ) { $ namespaceOptions = new NamespaceOptions ( $ namespaceOptions ) ; if ( $ namespace !== null ) { $ namespaceOptions -> setName ( $ namespace ) ; } } else { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be array or an instance of HtSettingsModule\Options\NamespaceOptionsInterface, %s provided instead' , __METHOD__ , is_object ( $ namespaceOptions ) ? get_class ( $ namespaceOptions ) : gettype ( $ namespaceOptions ) ) ) ; } } else { if ( ! $ namespaceOptions -> getName ( ) && $ namespace ) { $ namespaceOptions -> setName ( $ namespace ) ; } } if ( $ namespace === null ) { $ namespace = $ namespaceOptions -> getName ( ) ; } $ this -> namespaces [ $ namespace ] = $ namespaceOptions ; }
9652	protected function initFormField ( ) { $ options = $ this -> Options ( ) -> map ( 'EscapedTitle' , 'Title' ) ; return new OptionsetField ( $ this -> Name , $ this -> Title , $ options ) ; }
3147	public function check ( RunnerServiceContext $ context ) { $ state = $ context -> getTestSession ( ) -> getState ( ) ; if ( $ state == AssessmentTestSessionState :: CLOSED ) { throw new QtiRunnerClosedException ( ) ; } return true ; }
12537	public function setRelatedObjects ( $ relatedObjects ) { foreach ( $ relatedObjects as $ modelName => $ objects ) { if ( ! isset ( $ this -> _relatedObjects [ $ modelName ] ) ) { $ this -> _relatedObjects [ $ modelName ] = [ ] ; } foreach ( $ objects as $ tabId => $ objectAttributes ) { if ( ! isset ( $ objectAttributes [ '_moduleHandler' ] ) ) { continue ; } list ( $ relationship , $ role ) = $ this -> owner -> objectType -> getRelationship ( $ objectAttributes [ '_moduleHandler' ] ) ; $ relatedHandler = $ this -> owner -> objectType -> getRelatedType ( $ objectAttributes [ '_moduleHandler' ] ) ; if ( ! $ relatedHandler ) { continue ; } $ objectAttributes = array_merge ( [ 'companionObject' => $ this -> owner , 'companionRelationship' => $ relationship , 'companionRole' => $ role , ] , $ objectAttributes ) ; $ object = $ relatedHandler -> getModel ( null , $ objectAttributes ) ; $ object -> tabularId = $ objectAttributes [ '_moduleHandler' ] ; if ( ( ! $ object || $ object -> isEmptyObject ( ) ) && ! ( $ relationship -> required ) ) { continue ; } $ object -> companionObject = $ object -> indirectObject = $ this -> owner ; $ object -> companionRelationship = $ relationship ; $ object -> companionRole = $ role ; $ this -> _relatedObjects [ $ modelName ] [ $ tabId ] = $ object ; $ this -> _relatedObjectsFlat [ ] = $ object ; } } }
698	public function actionRun ( $ command ) { $ command = implode ( ' ' , \ func_get_args ( ) ) ; $ base = \ dirname ( \ dirname ( __DIR__ ) ) ; $ dirs = $ this -> listSubDirs ( "$base/extensions" ) ; $ dirs = array_merge ( $ dirs , $ this -> listSubDirs ( "$base/apps" ) ) ; asort ( $ dirs ) ; $ oldcwd = getcwd ( ) ; foreach ( $ dirs as $ dir ) { $ displayDir = substr ( $ dir , \ strlen ( $ base ) ) ; $ this -> stdout ( "Running '$command' in $displayDir...\n" , Console :: BOLD ) ; chdir ( $ dir ) ; passthru ( $ command ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } chdir ( $ oldcwd ) ; }
2834	public function startRendering ( Mage_Core_Block_Abstract $ block ) { if ( $ this -> isRendering ) { $ this -> renderedCount ++ ; Mage :: log ( "Recursive block rendering {$this->getName()}" , Zend_Log :: DEBUG ) ; return ; } $ this -> init ( $ block ) ; $ this -> isRendering = true ; $ this -> renderedCount ++ ; $ this -> renderedAt = microtime ( true ) ; if ( self :: $ startRenderingTime === null ) { self :: $ startRenderingTime = $ this -> renderedAt ; } }
1049	public static function getVariableValues ( Schema $ schema , $ varDefNodes , array $ inputs ) { $ errors = [ ] ; $ coercedValues = [ ] ; foreach ( $ varDefNodes as $ varDefNode ) { $ varName = $ varDefNode -> variable -> name -> value ; $ varType = TypeInfo :: typeFromAST ( $ schema , $ varDefNode -> type ) ; if ( Type :: isInputType ( $ varType ) ) { if ( array_key_exists ( $ varName , $ inputs ) ) { $ value = $ inputs [ $ varName ] ; $ coerced = Value :: coerceValue ( $ value , $ varType , $ varDefNode ) ; $ coercionErrors = $ coerced [ 'errors' ] ; if ( empty ( $ coercionErrors ) ) { $ coercedValues [ $ varName ] = $ coerced [ 'value' ] ; } else { $ messagePrelude = sprintf ( 'Variable "$%s" got invalid value %s; ' , $ varName , Utils :: printSafeJson ( $ value ) ) ; foreach ( $ coercionErrors as $ error ) { $ errors [ ] = new Error ( $ messagePrelude . $ error -> getMessage ( ) , $ error -> getNodes ( ) , $ error -> getSource ( ) , $ error -> getPositions ( ) , $ error -> getPath ( ) , $ error , $ error -> getExtensions ( ) ) ; } } } else { if ( $ varType instanceof NonNull ) { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" of required type "%s" was not provided.' , $ varName , $ varType ) , [ $ varDefNode ] ) ; } elseif ( $ varDefNode -> defaultValue ) { $ coercedValues [ $ varName ] = AST :: valueFromAST ( $ varDefNode -> defaultValue , $ varType ) ; } } } else { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" expected value of type "%s" which cannot be used as an input type.' , $ varName , Printer :: doPrint ( $ varDefNode -> type ) ) , [ $ varDefNode -> type ] ) ; } } if ( ! empty ( $ errors ) ) { return [ $ errors , null ] ; } return [ null , $ coercedValues ] ; }
6826	protected function getUnpaidAccountNumber ( CustomerGroupInterface $ group , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_UNPAID ) { continue ; } foreach ( $ account -> getCustomerGroups ( ) as $ g ) { if ( $ g -> getId ( ) === $ group -> getId ( ) ) { return $ account -> getNumber ( ) ; } } } foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_UNPAID ) { continue ; } if ( 0 < $ account -> getCustomerGroups ( ) -> count ( ) ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No unpaid account number configured for customer group '%s' (%s)" , $ group -> getName ( ) , $ origin ) ) ; }
3187	public function end ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'end() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; } else { \ common_Logger :: t ( 'Range already closed, or missing START TimePoint in QtiTimer, continue anyway' ) ; } return $ this ; }
965	public function dispatchScripttags ( ) { $ scripttags = Config :: get ( 'shopify-app.scripttags' ) ; if ( count ( $ scripttags ) > 0 ) { ScripttagInstaller :: dispatch ( $ this -> shop , $ scripttags ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.scripttags' ) ) ; } }
3743	protected function setLanguage ( $ language = '' ) { $ previousLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( ! empty ( $ language ) && ( $ GLOBALS [ 'TL_LANGUAGE' ] !== $ language ) ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ language ; } return $ previousLanguage ; }
11656	public function getShortName ( ) { preg_match ( '/Widget([A-Za-z]+)\\\Module/' , get_class ( $ this ) , $ matches ) ; if ( ! isset ( $ matches [ 1 ] ) ) { throw new Exception ( get_class ( $ this ) . " is not set up correctly!" ) ; } return $ matches [ 1 ] ; }
4719	public function processBlockTags ( Tag $ tag ) { if ( $ tag -> isInline ( ) ) { return ; } $ text = null ; $ tag -> getText ( ) -> replace ( '/(^{([^:\(\)]+)}[ \t]*\n?|(?:[ \t]*|\n?){([^:\(\)]+)}\n*$)/' , function ( Text $ w ) use ( & $ text ) { $ text = $ w -> trim ( ) -> trim ( '{}' ) ; return '' ; } ) ; if ( $ text ) { $ tag -> setAttributes ( $ this -> parseAttributes ( $ text ) ) ; } }
5781	private function getSectionForAdministrator ( array $ section , string $ sectionName ) : array { if ( isset ( $ section [ 'authorization' ] ) && ! $ this -> container -> authorization -> isAuthorized ( $ section [ 'authorization' ] ) ) { return [ ] ; } $ updatedSection = [ ] ; foreach ( $ section as $ key => $ value ) { if ( $ key != 'subSections' ) { $ updatedSection [ $ key ] = $ value ; } } $ updatedSubSections = [ ] ; if ( isset ( $ section [ 'subSections' ] ) ) { foreach ( $ section [ 'subSections' ] as $ subSectionName => $ subSection ) { $ updatedSubSection = $ this -> getSectionForAdministrator ( $ subSection , $ subSectionName ) ; if ( count ( $ updatedSubSection ) > 0 ) { $ updatedSubSections [ $ subSectionName ] = $ updatedSubSection ; } } } if ( count ( $ updatedSubSections ) > 0 ) { $ updatedSection [ 'subSections' ] = $ updatedSubSections ; } return $ updatedSection ; }
8833	public function generateFromPattern ( $ pattern , $ amount = 1 , $ safeguard = 100 ) { $ lexer = new \ Gajus \ Paggern \ Lexer ( ) ; $ tokens = $ lexer -> tokenise ( $ pattern , true ) ; $ codes = array_fill ( 0 , $ amount + $ safeguard , '' ) ; foreach ( $ tokens as & $ token ) { if ( $ token [ 'type' ] !== 'literal' ) { $ token [ 'pool' ] = $ this -> generator -> generateString ( $ token [ 'repetition' ] * ( $ amount + $ safeguard ) , $ token [ 'haystack' ] ) ; } unset ( $ token ) ; } foreach ( $ codes as $ i => & $ code ) { foreach ( $ tokens as $ token ) { if ( $ token [ 'type' ] === 'literal' ) { $ code .= $ token [ 'string' ] ; } else { $ code .= mb_substr ( $ token [ 'pool' ] , $ token [ 'repetition' ] * $ i , $ token [ 'repetition' ] ) ; } } unset ( $ code ) ; } $ codes = array_slice ( array_unique ( $ codes ) , 0 , $ amount ) ; if ( count ( $ codes ) < $ amount ) { throw new Exception \ RuntimeException ( 'Unique combination pool exhausted.' ) ; } return $ codes ; }
4285	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; if ( $ this -> json [ 'rows' ] ) { \ array_unshift ( $ this -> json [ 'rows' ] , array ( array ( 'PHP' , isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ) , null , 'groupCollapsed' , ) ) ; \ array_push ( $ this -> json [ 'rows' ] , array ( array ( ) , null , 'groupEnd' , ) ) ; $ encoded = $ this -> encode ( $ this -> json ) ; if ( \ strlen ( $ encoded ) > 250000 ) { $ this -> debug -> warn ( 'chromeLogger: output limit exceeded' ) ; } else { $ event [ 'headers' ] [ ] = array ( self :: HEADER_NAME , $ encoded ) ; } } $ this -> data = array ( ) ; $ this -> json [ 'rows' ] = array ( ) ; }
1238	private static function ensurePropertyType ( $ class , $ name , $ value ) { $ isValid = false ; $ info = self :: propertyInfo ( $ class , $ name ) ; $ actualType = self :: getActualType ( $ value ) ; $ valid = explode ( '|' , $ info [ 'type' ] ) ; foreach ( $ valid as $ check ) { if ( $ check !== 'any' && \ DTS \ eBaySDK \ checkPropertyType ( $ check ) ) { if ( $ check === $ actualType || 'array' === $ actualType ) { return ; } $ isValid = false ; } else { $ isValid = true ; } } if ( ! $ isValid ) { $ expectedType = $ info [ 'type' ] ; throw new Exceptions \ InvalidPropertyTypeException ( $ name , $ expectedType , $ actualType ) ; } }
1857	public function fopen ( $ strFile , $ strMode ) { $ this -> validate ( $ strFile ) ; return fopen ( $ this -> strRootDir . '/' . $ strFile , $ strMode ) ; }
504	protected function renderHtmlResponse ( ) { return $ this -> controller -> render ( $ this -> view ? : $ this -> id , $ this -> getViewRenderParams ( ) ) ; }
8040	public function buildEventDates ( array $ data ) { $ dates = [ ] ; $ eventLength = $ this -> calculateEventLength ( $ data ) ; $ allDay = array_key_exists ( 'all_day' , $ data ) ; foreach ( $ data [ 'repeat_dates' ] as $ date ) { if ( strlen ( $ date ) > 0 ) { $ date = strtotime ( $ date . ' ' . $ data [ 'start' ] [ 'time' ] ) ; if ( false === $ date ) { throw new InvalidDateStringException ( 'Invalid date string!' ) ; } $ eventStart = $ this -> carbon -> copy ( ) -> setTimestamp ( $ date ) ; $ eventEnds = $ allDay ? null : $ eventStart -> copy ( ) -> addSeconds ( $ eventLength ) ; $ dates [ ] = [ 'start' => $ eventStart -> toDateTimeString ( ) , 'end' => ( null !== $ eventEnds ) ? $ eventEnds -> toDateTimeString ( ) : null , ] ; } } return $ dates ; }
8657	private function convertCancelFeedSubmissions ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CancelFeedSubmissions' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionIdList ( ) ) { $ feedSubmissionIdList = $ request -> getFeedSubmissionIdList ( ) ; foreach ( $ feedSubmissionIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'FeedSubmissionIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
3793	private function hasVariants ( ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> providerName ) ; if ( $ metaModel === null ) { throw new \ RuntimeException ( sprintf ( 'Could not find a MetaModels with the name %s' , $ this -> providerName ) ) ; } return $ metaModel -> hasVariants ( ) ; }
2568	protected function checkAllIntegers ( ) { $ foundNonInt = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! is_int ( $ arg ) ) { $ foundNonInt = true ; break ; } } return ! $ foundNonInt ; }
7268	public function hasMany ( $ forClass , $ forColumn = null , $ condition = "" , array $ conditionParams = [ ] ) { $ refTable = static :: tableName ( ) ; $ forTable = $ forClass :: tableName ( ) ; $ refColumn = static :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( static :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select F.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and R.$refColumn = :id $condition " , array_merge ( [ "id" => $ this -> $ refColumn ] , $ conditionParams ) , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return new Collection ( [ ] ) ; $ collection = [ ] ; foreach ( $ rows as $ row ) { $ forModel = new $ forClass ; foreach ( $ row as $ column => $ val ) $ forModel -> $ column = $ forModel -> decodeValue ( $ val , $ column ) ; $ collection [ ] = $ forModel ; } return new Collection ( $ collection ) ; }
5185	private function generalAttachment ( Article $ article , array $ attachmentConst , array $ attachmentype , array $ attributes , array $ dataArticle ) : Article { $ numOfAttachments = count ( $ attachmentConst ) ; for ( $ i = 0 ; $ i < $ numOfAttachments ; $ i ++ ) { $ attachments = $ this -> attachment ( $ attachmentype [ $ i ] , $ attributes [ $ i ] , $ dataArticle ) ; for ( $ j = 0 ; $ j < $ attachments [ 'numberOfItems' ] ; $ j ++ ) { $ attachment = $ attachments [ 'attachments' ] [ $ j ] ; $ article -> attach ( $ attachmentConst [ $ i ] , $ attachment ) ; } } return $ article ; }
5853	protected function loadVirtualTca ( ) { $ GLOBALS [ 'TCA' ] [ static :: virtualTable ] = include ( ExtensionManagementUtility :: extPath ( $ this -> extKey ) . 'Configuration/TCA/Module/Options.php' ) ; ExtensionManagementUtility :: addLLrefForTCAdescr ( static :: virtualTable , 'EXT:' . $ this -> extKey . '/Resource/Private/Language/locallang_csh_' . static :: virtualTable . '.xlf' ) ; }
4801	public function injectSpecialBindings ( string $ sql , array $ bindings ) : string { foreach ( self :: SPECIAL_BINDINGS as $ special ) { $ specialPlaceholder = ":" . $ special ; if ( ! array_key_exists ( $ special , $ bindings ) ) { continue ; } $ replacement = $ this -> escapeSpecialBinding ( $ bindings [ $ special ] , $ special ) ; $ sql = str_replace ( $ specialPlaceholder , $ replacement , $ sql ) ; unset ( $ bindings [ $ special ] ) ; } foreach ( $ bindings as $ key => $ value ) { if ( is_array ( $ value ) ) { $ inString = "" ; foreach ( $ value as $ i => $ innerValue ) { $ newKey = $ key . "__" . $ i ; $ keyParamString = ":$newKey" ; $ inString .= "$keyParamString, " ; } $ inString = rtrim ( $ inString , " ," ) ; $ sql = str_replace ( ":$key" , $ inString , $ sql ) ; } } return $ sql ; }
8322	public function getLoad ( $ paramsList = [ 'waiting' , 'load' , 'minbid' , 'averageRecognitionTime' ] ) { $ parser = $ this -> getLoadXml ( ) ; if ( is_string ( $ paramsList ) ) { return $ parser -> $ paramsList -> __toString ( ) ; } $ statusData = [ ] ; foreach ( $ paramsList as $ item ) { $ statusData [ $ item ] = $ parser -> $ item -> __toString ( ) ; } return $ statusData ; }
5964	public function channelGroupGetById ( $ cgid ) { if ( ! array_key_exists ( ( string ) $ cgid , $ this -> channelGroupList ( ) ) ) { throw new Ts3Exception ( "invalid groupID" , 0xA00 ) ; } return $ this -> cgroupList [ intval ( ( string ) $ cgid ) ] ; }
4575	public function getCount ( Parameters $ parameters = null ) { $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ result = $ this -> execute ( 'GET' , static :: RESOURCE_COUNT , $ options ) ; return $ result -> count ; }
6988	protected function finalize ( ContextInterface $ context ) : ContextInterface { if ( null === $ context -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ this -> customerGroupRepository -> findDefault ( ) ) ; } if ( null === $ context -> getInvoiceCountry ( ) ) { $ context -> setInvoiceCountry ( $ this -> countryProvider -> getCountry ( ) ) ; } if ( null === $ context -> getDeliveryCountry ( ) ) { $ context -> setDeliveryCountry ( $ this -> countryProvider -> getCountry ( ) ) ; } if ( null === $ context -> getCurrency ( ) ) { $ context -> setCurrency ( $ this -> currencyProvider -> getCurrency ( ) ) ; } if ( null === $ context -> getLocale ( ) ) { $ context -> setLocale ( $ this -> localProvider -> getCurrentLocale ( ) ) ; } if ( null === $ context -> getVatDisplayMode ( ) ) { if ( null !== $ mode = $ context -> getCustomerGroup ( ) -> getVatDisplayMode ( ) ) { $ context -> setVatDisplayMode ( $ mode ) ; } else { $ context -> setVatDisplayMode ( $ this -> defaultVatDisplayMode ) ; } } $ this -> eventDispatcher -> dispatch ( ContextEvents :: BUILD , new ContextEvent ( $ context ) ) ; return $ context ; }
7620	public function createSignedQueryString ( $ path = '/' , $ queryString = '' , $ resource = 'b' , $ permissions = 'r' , $ start = '' , $ expiry = '' , $ identifier = '' ) { $ parts = array ( ) ; if ( $ start !== '' ) { $ parts [ ] = 'st=' . urlencode ( $ start ) ; } $ parts [ ] = 'se=' . urlencode ( $ expiry ) ; $ parts [ ] = 'sr=' . $ resource ; $ parts [ ] = 'sp=' . $ permissions ; if ( $ identifier !== '' ) { $ parts [ ] = 'si=' . urlencode ( $ identifier ) ; } $ parts [ ] = 'sig=' . urlencode ( $ this -> createSignature ( $ path , $ resource , $ permissions , $ start , $ expiry , $ identifier ) ) ; if ( $ queryString != '' ) { $ queryString .= '&' ; } $ queryString .= implode ( '&' , $ parts ) ; return $ queryString ; }
8375	public function where ( $ where ) { $ this -> where = ( $ where instanceof Condition ? $ where : new Condition ( $ where ) ) ; return $ this ; }
7671	function TbsInitArchive ( ) { $ TBS = & $ this -> TBS ; $ TBS -> OtbsCurrFile = false ; $ this -> TbsStoreLst = array ( ) ; $ this -> TbsCurrIdx = false ; $ this -> TbsNoField = array ( ) ; $ this -> IdxToCheck = array ( ) ; $ this -> PrevVals = array ( ) ; $ this -> ExtEquiv = false ; $ this -> ExtType = false ; $ this -> OtbsSheetSlidesDelete = array ( ) ; $ this -> OtbsSheetSlidesVisible = array ( ) ; $ this -> OpenDocCharts = false ; $ this -> OpenDocManif = false ; $ this -> OpenDoc_SheetSlides = false ; $ this -> OpenDoc_Styles = false ; $ this -> OpenXmlRid = false ; $ this -> OpenXmlCTypes = false ; $ this -> OpenXmlCharts = false ; $ this -> OpenXmlSharedStr = false ; $ this -> OpenXmlSlideLst = false ; $ this -> OpenXmlSlideMasterLst = false ; $ this -> MsExcel_Sheets = false ; $ this -> MsWord_HeaderFooter = false ; $ this -> Ext_PrepareInfo ( ) ; }
769	public static function isFatalError ( $ error ) { return isset ( $ error [ 'type' ] ) && in_array ( $ error [ 'type' ] , [ E_ERROR , E_PARSE , E_CORE_ERROR , E_CORE_WARNING , E_COMPILE_ERROR , E_COMPILE_WARNING , self :: E_HHVM_FATAL_ERROR ] ) ; }
0	public static function supports ( IOInterface $ io , Config $ config , $ url , $ deep = false ) { if ( ! preg_match ( self :: URL_REGEX , $ url , $ match ) ) { return false ; } $ scheme = ! empty ( $ match [ 'scheme' ] ) ? $ match [ 'scheme' ] : null ; $ guessedDomain = ! empty ( $ match [ 'domain' ] ) ? $ match [ 'domain' ] : $ match [ 'domain2' ] ; $ urlParts = explode ( '/' , $ match [ 'parts' ] ) ; if ( false === self :: determineOrigin ( ( array ) $ config -> get ( 'gitlab-domains' ) , $ guessedDomain , $ urlParts ) ) { return false ; } if ( 'https' === $ scheme && ! extension_loaded ( 'openssl' ) ) { $ io -> writeError ( 'Skipping GitLab driver for ' . $ url . ' because the OpenSSL PHP extension is missing.' , true , IOInterface :: VERBOSE ) ; return false ; } return true ; }
6397	private function addEvolution ( $ decoded_taf , $ evolution , $ result , $ entity_name ) { $ new_evolution = clone ( $ evolution ) ; $ new_evolution -> setEntity ( $ result [ $ entity_name ] ) ; if ( $ entity_name == 'visibility' && $ this -> with_cavok == true ) { $ new_evolution -> setCavok ( true ) ; } $ getter_name = 'get' . ucfirst ( $ entity_name ) ; $ setter_name = 'set' . ucfirst ( $ entity_name ) ; $ decoded_entity = $ decoded_taf -> $ getter_name ( ) ; if ( $ decoded_entity == null || $ entity_name == 'clouds' || $ entity_name == 'weatherPhenomenons' ) { $ decoded_entity = $ this -> instantiateEntity ( $ entity_name ) ; } $ decoded_entity -> addEvolution ( $ new_evolution ) ; if ( $ entity_name == 'clouds' ) { $ decoded_taf -> addCloud ( $ decoded_entity ) ; } elseif ( $ entity_name == 'weatherPhenomenons' ) { $ decoded_taf -> addWeatherPhenomenon ( $ decoded_entity ) ; } else { $ decoded_taf -> $ setter_name ( $ decoded_entity ) ; } }
5380	public function setValue ( $ value ) { for ( $ i = 0 , $ count = count ( $ this -> options ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> options [ $ i ] -> isValue ( $ value ) ) { $ this -> choice = $ i ; return true ; } } return false ; }
12125	public function getAliasIdForLanguage ( $ language ) { foreach ( $ this -> aliases as $ key => $ alias ) { if ( $ alias -> getLanguage ( ) == $ language ) { return $ key ; } } return null ; }
7184	private function getFindAvailableByCountryAndWeightQuery ( ) { if ( null === $ this -> findAvailableByCountryAndWeightQuery ) { $ qb = $ this -> getCollectionQueryBuilder ( ) ; $ this -> findAvailableByCountryAndWeightQuery = $ qb -> join ( 'o.prices' , 'p' ) -> join ( 'p.zone' , 'z' ) -> andWhere ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'z.countries' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'p.weight' , ':weight' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.enabled' , ':enabled' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.available' , ':available' ) ) -> addOrderBy ( 'o.position' , 'ASC' ) -> getQuery ( ) ; } return $ this -> findAvailableByCountryAndWeightQuery ; }
5953	public function channelList ( array $ filter = array ( ) ) { if ( $ this -> channelList === null ) { $ channels = $ this -> request ( "channellist -topic -flags -voice -limits -icon" ) -> toAssocArray ( "cid" ) ; $ this -> channelList = array ( ) ; foreach ( $ channels as $ cid => $ channel ) { $ this -> channelList [ $ cid ] = new Channel ( $ this , $ channel ) ; } $ this -> resetNodeList ( ) ; } return $ this -> filterList ( $ this -> channelList , $ filter ) ; }
1488	public function when ( bool $ test , $ decodings ) : self { if ( ! $ test ) { return $ this ; } if ( $ decodings instanceof \ Closure ) { return $ decodings ( $ this ) ; } $ decodings = $ decodings instanceof Decoding ? [ $ decodings ] : $ decodings ; return $ this -> push ( ... $ decodings ) ; }
2947	public function grant ( $ permission ) { if ( $ this -> hasPermission ( $ permission ) ) { return true ; } if ( ! array_key_exists ( $ permission , Gate :: abilities ( ) ) ) { abort ( 403 , 'Unknown permission' ) ; } return Permission :: create ( [ 'role_id' => $ this -> id , 'permission_slug' => $ permission , ] ) ; return false ; }
6694	public static function applyActive ( & $ Nav ) { if ( $ Nav ) { foreach ( $ Nav as & $ one ) { if ( isset ( $ one [ 'items' ] ) ) { self :: applyActive ( $ one [ 'items' ] ) ; } if ( ! isset ( $ one [ 'active' ] ) ) { if ( is_array ( $ one [ 'url' ] ) ) { $ url = $ one [ 'url' ] [ 0 ] ; $ route = Yii :: $ app -> requestedRoute ; $ params = Yii :: $ app -> request -> getQueryParams ( ) ; if ( $ url === '/' && $ route === Yii :: $ app -> controller -> module -> id . '/dashboard/index' ) { $ one [ 'active' ] = true ; } else { $ url = $ one [ 'url' ] ; $ urlExploded = explode ( '/' , $ url [ 0 ] ) ; $ one [ 'submenuTemplate' ] = '' ; foreach ( self :: $ active as $ activeAction ) { $ urlExploded [ count ( $ urlExploded ) - 1 ] = $ activeAction ; $ url [ 0 ] = implode ( '/' , $ urlExploded ) ; $ one [ 'items' ] [ ] = [ 'label' => $ one [ 'label' ] . ' - ' . $ activeAction , 'url' => $ url , 'options' => [ 'class' => 'hidden' ] ] ; if ( '/' . Yii :: $ app -> request -> getQueryParam ( 'parentRoute' ) === trim ( $ url [ 0 ] ) ) { $ one [ 'items' ] [ ] = [ 'label' => $ one [ 'label' ] . ' - Sub List' , 'url' => array_merge ( [ '/' . $ route ] , $ params ) , 'options' => [ 'class' => 'hidden' ] ] ; } } } } } } } }
1160	protected function fakeValidationData ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> validator -> getData ( ) ; $ this -> fakeFileData ( $ data , $ attribute ) ; $ this -> fakeRequiredIfData ( $ data , $ rule , $ parameters ) ; return $ data ; }
2485	public function bulkIndexDocuments ( array $ documents ) { $ documentMap = array ( ) ; $ mainTranslationsEndpoint = $ this -> endpointResolver -> getMainLanguagesEndpoint ( ) ; $ mainTranslationsDocuments = array ( ) ; foreach ( $ documents as $ translationDocuments ) { foreach ( $ translationDocuments as $ document ) { $ documentMap [ $ document -> languageCode ] [ ] = $ document ; if ( $ mainTranslationsEndpoint !== null && $ document -> isMainTranslation ) { $ mainTranslationsDocuments [ ] = $ this -> getMainTranslationDocument ( $ document ) ; } } } foreach ( $ documentMap as $ languageCode => $ translationDocuments ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getIndexingTarget ( $ languageCode ) ) , $ translationDocuments ) ; } if ( ! empty ( $ mainTranslationsDocuments ) ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ mainTranslationsEndpoint ) , $ mainTranslationsDocuments ) ; } }
10747	protected function sendItems ( Response $ response , iterable $ items , ? Pagination $ pagination = null , ? int $ total = null ) : Response { $ items = is_array ( $ items ) ? $ items : ( $ items instanceof \ Traversable ? iterator_to_array ( $ items , false ) : [ ] ) ; $ total = $ total ?? count ( $ items ) ; $ start = $ pagination === null ? 0 : $ pagination -> getOffset ( ) ; $ max = $ pagination === null ? 0 : $ pagination -> getMax ( ) ; $ end = max ( min ( ( PHP_INT_MAX - $ max < $ start ? PHP_INT_MAX : $ start + $ max ) , $ total ) - 1 , 0 ) ; return $ this -> sendJson ( $ response -> withHeader ( 'Content-Range' , "items $start-$end/$total" ) , $ items ) ; }
6774	protected function didDeliveryCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldSameAddress = isset ( $ saleCs [ 'sameAddress' ] ) ? $ saleCs [ 'sameAddress' ] [ 0 ] : $ sale -> isSameAddress ( ) ; if ( $ oldSameAddress ) { $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; } else { $ oldAddress = isset ( $ saleCs [ 'deliveryAddress' ] ) ? $ saleCs [ 'deliveryAddress' ] [ 0 ] : $ sale -> getDeliveryAddress ( ) ; } if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } $ newAddress = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ newAddress ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
9140	public static function parseFromServerRequest ( $ serverVars , $ defaultController = 'Index' , $ defaultAction = 'index' ) { if ( ! isset ( $ serverVars [ 'REQUEST_URI' ] ) ) { throw new InvalidUrlException ( "No such uri provided" ) ; } return self :: parse ( $ serverVars [ 'REQUEST_URI' ] , $ serverVars , $ defaultController , $ defaultAction ) ; }
6837	public function map ( $ key , $ obj = null , $ need_cache = false ) { $ this -> clearCache ( $ key ) ; if ( is_null ( $ obj ) ) { $ obj = $ key ; } $ this -> objects [ $ key ] = [ $ obj , $ need_cache ] ; return $ this ; }
410	public function setHostInfo ( $ value ) { $ this -> _hostName = null ; $ this -> _hostInfo = $ value === null ? null : rtrim ( $ value , '/' ) ; }
5195	protected function getMethodResult ( $ method , array $ arguments ) { if ( ! is_callable ( [ 'Elasticsearch\Client' , $ method ] ) ) { trigger_error ( sprintf ( 'Call to undefined or protected/private method %s::%s()' , get_called_class ( ) , $ method ) , E_USER_ERROR ) ; } if ( empty ( $ this -> results [ $ method ] ) ) { throw new \ Exception ( sprintf ( "ElasticsearchMock results is empty for %s" , $ method ) ) ; } $ this -> calls [ $ method ] [ ] = $ arguments ; return array_shift ( $ this -> results [ $ method ] ) ; }
11212	protected function getFromLookup ( $ key ) { if ( $ key === $ this -> cache_key || $ this -> hasInLookup ( $ key ) ) { return $ this -> getFromRegistry ( $ this -> cache_reg , $ key ) ; } return null ; }
2200	public static function findPublishedByPidAndColumn ( $ intPid , $ strColumn , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.inColumn=?" ) ; $ arrValues = array ( $ intPid , $ strColumn ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
8750	public static function dumpValue ( $ value , $ containerVariable , array $ usedVariables ) : InlineEntryInterface { if ( is_array ( $ value ) ) { return self :: dumpArray ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( $ value instanceof ReferenceInterface ) { return self :: dumpReference ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( $ value instanceof DumpableInterface ) { return self :: dumpDefinition ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( is_object ( $ value ) || is_resource ( $ value ) ) { throw new \ RuntimeException ( 'Unable to dump a container if a parameter is an object or a resource.' ) ; } else { return new InlineEntry ( var_export ( $ value , true ) , null , $ usedVariables , false ) ; } }
7253	private function getShipmentMethodFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof ShipmentMethodInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . ShipmentMethodInterface :: class ) ; } return $ resource ; }
12078	public function childAssociate ( $ request , $ idParent , $ idChild , $ relation ) { $ request -> request -> merge ( [ 'url' => $ request -> request -> path ( ) ] ) ; $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resourceChild = $ this -> repository -> attach ( $ idParent , $ idChild , $ relation , $ request -> all ( ) ) ; if ( ! $ resourceChild ) { } return $ this -> success ( [ $ resourceChild ] ) ; }
11576	public function actionConnect ( $ account_id ) { $ account = $ this -> finder -> findAccountById ( $ account_id ) ; if ( $ account === null || $ account -> getIsConnected ( ) ) { throw new NotFoundHttpException ; } $ user = \ Yii :: createObject ( [ 'class' => User :: className ( ) , 'scenario' => 'connect' ] ) ; if ( $ user -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ user -> create ( ) ) { $ account -> user_id = $ user -> id ; $ account -> save ( false ) ; \ Yii :: $ app -> user -> login ( $ user , $ this -> module -> rememberFor ) ; return $ this -> goBack ( ) ; } return $ this -> render ( 'connect' , [ 'model' => $ user , 'account' => $ account ] ) ; }
11405	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ cacheManager = new CacheManager ( $ serviceLocator -> get ( 'HtSettingsModule\Options\ModuleOptions' ) -> getCacheOptions ( ) ) ; $ cacheManager -> setServiceLocator ( $ serviceLocator ) ; return $ cacheManager ; }
10224	private function buildComplexIndexMenu ( $ modelName , $ modelId , ModelConfig $ config = null ) { $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; $ relations = $ this -> aujaConfigurator -> getRelationsForModel ( $ model ) ; $ associationRelations = array ( ) ; foreach ( $ relations as $ relation ) { if ( $ relation -> getType ( ) == Relation :: HAS_MANY || $ relation -> getType ( ) == Relation :: HAS_AND_BELONGS_TO ) { $ associationRelations [ ] = $ relation ; } } switch ( count ( $ associationRelations ) ) { case 0 : $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; break ; case 1 : $ menu = $ this -> singleAssociationMenuFor ( $ modelName , $ modelId , $ associationRelations [ 0 ] , $ config ) ; break ; default : $ menu = $ this -> multipleAssociationsMenuFor ( $ modelName , $ modelId , $ associationRelations , $ config ) ; break ; } return $ menu ; }
7490	public function reverse ( ) { $ length = $ this -> length ( ) ; $ reversed = '' ; while ( $ length -- > 0 ) { $ reversed .= mb_substr ( $ this -> string , $ length , 1 , $ this -> encoding ) ; } $ this -> string = $ reversed ; return $ this ; }
6189	public function renderJSONP ( $ data ) { $ callback = null ; if ( isset ( $ _GET [ 'callback' ] ) ) { $ callback = $ _GET [ 'callback' ] ; } exit ( Response :: Create ( $ callback . '(' . json_encode ( $ data ) . ')' ) -> headers ( [ 'Content-Type' => 'application/jsonp' ] ) -> display ( ) ) ; }
2713	public function getValues ( ) { $ values = [ ] ; $ ratios = $ this -> pixelRatios -> toOptionArray ( ) ; foreach ( $ ratios as $ value ) { $ values [ $ value [ 'value' ] ] = $ value [ 'label' ] ; } return $ values ; }
10790	protected function quote ( $ str ) { return $ this -> getDialect ( ) -> quote ( $ str , $ this -> getSettings ( ) [ 'autoQuote' ] ? DialectInterface :: QUOTE_YES : DialectInterface :: QUOTE_NO ) ; }
692	protected function createView ( array $ config ) { if ( ! array_key_exists ( 'class' , $ config ) ) { $ config [ 'class' ] = View :: className ( ) ; } return Yii :: createObject ( $ config ) ; }
11436	private function _removeDirectory ( $ sName ) { if ( $ rDirectory = opendir ( $ sName ) ) { while ( ( $ sFile = readdir ( $ rDirectory ) ) !== false ) { if ( $ sFile > '0' && filetype ( $ sName . $ sFile ) == "file" ) { unlink ( $ sName . $ sFile ) ; } elseif ( $ sFile > '0' && filetype ( $ sName . $ sFile ) == "dir" ) { remove_dir ( $ sName . $ sFile . "\\" ) ; } } closedir ( $ rDirectory ) ; rmdir ( $ sName ) ; } }
8349	public static function toArray ( ) : array { if ( static :: $ array == null ) { $ ref = new \ ReflectionClass ( static :: class ) ; $ consts = $ ref -> getConstants ( ) ; static :: $ array = array ( ) ; foreach ( $ consts as $ key => $ value ) { if ( stripos ( $ key , 'VALUE_' ) === 0 ) { static :: $ array [ $ key ] = $ value ; } } } return static :: $ array ; }
10180	private function storeCurrentCell ( ) { if ( $ this -> currentCellIsDirty && ! empty ( $ this -> currentCoordinate ) ) { $ this -> currentCell -> detach ( ) ; $ stored = $ this -> cache -> set ( $ this -> cachePrefix . $ this -> currentCoordinate , $ this -> currentCell ) ; if ( ! $ stored ) { $ this -> __destruct ( ) ; throw new PhpSpreadsheetException ( "Failed to store cell {$this->currentCoordinate} in cache" ) ; } $ this -> currentCellIsDirty = false ; } $ this -> currentCoordinate = null ; $ this -> currentCell = null ; }
6833	public function userHasRight ( array $ user , $ right ) { $ hasRight = false ; if ( isset ( $ user [ 'role' ] ) && ! empty ( $ right ) && isset ( $ this -> _rightsConfig [ $ right ] ) ) { if ( in_array ( $ user [ 'role' ] , $ this -> _rightsConfig [ $ right ] ) ) { $ hasRight = true ; } } return $ hasRight ; }
9550	public function getPdo ( ) { if ( empty ( $ this -> pdo ) ) { $ this -> pdo = new PDO ( sprintf ( "mysql:host=%s;port=%d" , $ this -> host , $ this -> port ) ) ; $ this -> pdo -> setAttribute ( PDO :: ATTR_DEFAULT_FETCH_MODE , PDO :: FETCH_ASSOC ) ; } return $ this -> pdo ; }
4100	public function setType ( $ type ) { if ( is_array ( $ type ) ) $ type = implode ( "," , array_filter ( $ type ) ) ; $ this -> type = $ type ; $ this -> transport -> setType ( $ type ) ; return $ this ; }
12083	public function getAllMedia ( $ objectType = 'media' , $ objectURI = NULL , $ objectId = NULL ) { $ objects = $ this -> getMediaObjectsList ( $ objectType , $ objectURI , $ objectId ) -> fetchAll ( ) ; $ items = array ( ) ; foreach ( $ objects as $ i => $ object ) { $ object = $ this -> getOwner ( $ object , $ object [ 'media_owner' ] ) ; if ( $ object [ 'object_type' ] === "attachment" ) : $ object [ 'media_object' ] = $ object [ 'object_uri' ] ; if ( empty ( $ object [ 'media_title' ] ) ) : $ object [ 'media_title' ] = $ object [ 'attachment_name' ] ; endif ; endif ; $ object [ 'media_comment_target' ] = $ object [ 'object_uri' ] ; $ object [ 'media_published' ] = $ object [ 'object_created_on' ] ; $ items [ ] = $ object ; } $ mediacollections = new Collection ( ) ; $ mediacollections :: set ( "items" , $ items ) ; $ mediacollections :: set ( "totalItems" , count ( $ items ) ) ; $ collection = $ mediacollections :: getArray ( ) ; return $ collection ; }
289	protected function isLanguageSupported ( $ requested , $ supported ) { $ supported = str_replace ( '_' , '-' , strtolower ( $ supported ) ) ; $ requested = str_replace ( '_' , '-' , strtolower ( $ requested ) ) ; return strpos ( $ requested . '-' , $ supported . '-' ) === 0 ; }
221	protected function normalizeNumericValue ( $ value ) { if ( empty ( $ value ) ) { return 0 ; } if ( is_string ( $ value ) && is_numeric ( $ value ) ) { $ value = ( float ) $ value ; } if ( ! is_numeric ( $ value ) ) { throw new InvalidArgumentException ( "'$value' is not a numeric value." ) ; } return $ value ; }
7947	public function lineResetDslamPort ( $ id , $ line ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ line ) throw new BadMethodCallException ( 'Missing parameter $line.' ) ; try { $ r = $ this -> post ( 'xdsl/' . $ id . '/lines/' . $ line . '/resetDslamPort' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
10977	public static function verify ( $ code ) { if ( ! $ code ) { return null ; } if ( $ user = self :: lookupVerificationCode ( $ code ) ) { $ user -> setVerificationCode ( ) ; } return $ user ; }
2894	public function init ( Zend_Db_Profiler_Query $ profilerQuery , $ stacktrace = '' ) { $ this -> queryType = $ profilerQuery -> getQueryType ( ) ; $ this -> query = $ profilerQuery -> getQuery ( ) ; $ this -> queryParams = $ profilerQuery -> getQueryParams ( ) ; $ this -> elapsedSecs = $ profilerQuery -> getElapsedSecs ( ) ; $ this -> stacktrace = $ stacktrace ; }
6958	public function setForcedRedirect ( $ url ) { $ data = $ this -> getData ( true ) ; $ data [ static :: $ forcedRedirectKey ] = $ url ; return $ this -> setData ( $ data ) ; }
10908	public function instance ( object $ object ) : Binding { if ( ! $ object instanceof $ this -> definition -> typeName ) { throw new \ InvalidArgumentException ( \ sprintf ( '%s is not an instance of %s' , \ get_class ( $ object ) , $ this -> definition -> typeName ) ) ; } $ this -> definition -> instantiator = new Instance ( $ object ) ; return $ this ; }
872	private static function wordwrap ( $ string , $ width ) { $ result = [ ] ; $ currentLine = 0 ; $ lineLength = 0 ; foreach ( explode ( ' ' , $ string ) as $ word ) { $ wordLength = \ strlen ( Preg :: replace ( '~</?(\w+)>~' , '' , $ word ) ) ; if ( 0 !== $ lineLength ) { ++ $ wordLength ; } if ( $ lineLength + $ wordLength > $ width ) { ++ $ currentLine ; $ lineLength = 0 ; } $ result [ $ currentLine ] [ ] = $ word ; $ lineLength += $ wordLength ; } return array_map ( static function ( $ line ) { return implode ( ' ' , $ line ) ; } , $ result ) ; }
4415	public static function modify ( $ tpl , $ operatorName , $ operatorParameters , $ rootNamespace , $ currentNamespace , & $ operatorValue , $ namedParameters , $ placement ) { if ( $ operatorName === 'has_tags_bundle' ) { $ operatorValue = class_exists ( 'Netgen\TagsBundle\Version' ) && TagsBundleVersion :: VERSION_ID >= 30000 ; } }
10706	public function getUserAddForm ( ) { if ( null === $ this -> userAddForm ) { $ this -> userAddForm = $ this -> getServiceLocator ( ) -> get ( 'user.form.useradd' ) ; } return $ this -> userAddForm ; }
4435	public static function fromErrorMessage ( string $ error ) : QlessException { $ area = null ; $ message = $ error ; if ( preg_match ( self :: ERROR_MESSAGE_RE , $ error , $ matches ) > 0 ) { $ area = $ matches [ 'area' ] ; $ message = $ matches [ 'message' ] ; } switch ( true ) { case ( $ area === 'Requeue' && stripos ( $ message , 'does not exist' ) !== false ) : case ( stripos ( $ message , 'Job does not exist' ) !== false ) : return new InvalidJobException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job given out to another worker' ) !== false ) : return new JobLostException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job not currently running' ) !== false ) : default : return new QlessException ( $ message , $ area ) ; } }
2066	public function getPageTypes ( Contao \ DataContainer $ dc ) { $ arrOptions = array ( ) ; foreach ( array_keys ( $ GLOBALS [ 'TL_PTY' ] ) as $ pty ) { if ( $ pty == 'root' && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { continue ; } if ( $ pty == $ dc -> value || $ this -> User -> hasAccess ( $ pty , 'alpty' ) ) { $ arrOptions [ ] = $ pty ; } } return $ arrOptions ; }
7781	public function get ( $ key ) { if ( array_key_exists ( $ key , $ this -> messages ) ) { return ! empty ( $ this -> messages [ $ key ] ) ? $ this -> messages [ $ key ] : null ; } return null ; }
5186	private function makeAttachmentObject ( string $ attachmentType , array $ attrReferences , array $ item ) { $ attrValues = [ ] ; foreach ( $ attrReferences as $ attrReference ) { $ attrValues [ $ attrReference ] = $ this -> getValue ( $ attrReference , $ item ) ; } switch ( $ attachmentType ) { case self :: JSON_PHOTO_FIELD : return $ this -> createPhoto ( $ attrValues [ 'photo_url' ] , $ attrValues [ 'photo_ratio' ] , '' , '' ) ; case self :: JSON_PAGE_FIELD : return $ this -> createPage ( $ attrValues [ 'page_title' ] , $ attrValues [ 'page_body' ] , $ attrValues [ 'page_source' ] , $ attrValues [ 'page_order' ] , $ attrValues [ 'page_cover' ] , $ attrValues [ 'page_lead' ] ) ; case self :: JSON_GALLERY_FIELD : return $ this -> createGallery ( $ attrValues [ 'gallery_body' ] , $ attrValues [ 'gallery_order' ] , $ attrValues [ 'gallery_photo' ] , $ attrValues [ 'gallery_source' ] , $ attrValues [ 'gallery_lead' ] ) ; case self :: JSON_VIDEO_FIELD : return $ this -> createVideo ( $ attrValues [ 'video_body' ] , $ attrValues [ 'video_source' ] , $ attrValues [ 'video_order' ] , $ attrValues [ 'video_cover' ] , $ attrValues [ 'video_lead' ] ) ; default : return null ; } }
1303	public function get ( string $ path , array $ headers = [ ] , $ cache = true ) : Response { if ( null === $ this -> endpoint ) { return new Response ( [ ] ) ; } $ headers [ ] = 'Package-Session: ' . $ this -> sess ; $ url = $ this -> endpoint . '/' . ltrim ( $ path , '/' ) ; $ cacheKey = $ cache ? ltrim ( $ path , '/' ) : '' ; if ( $ cacheKey && $ contents = $ this -> cache -> read ( $ cacheKey ) ) { $ cachedResponse = Response :: fromJson ( json_decode ( $ contents , true ) ) ; if ( $ lastModified = $ cachedResponse -> getHeader ( 'last-modified' ) ) { $ response = $ this -> fetchFileIfLastModified ( $ url , $ cacheKey , $ lastModified , $ headers ) ; if ( 304 === $ response -> getStatusCode ( ) ) { $ response = new Response ( $ cachedResponse -> getBody ( ) , $ response -> getOrigHeaders ( ) , 304 ) ; } return $ response ; } } return $ this -> fetchFile ( $ url , $ cacheKey , $ headers ) ; }
11724	protected function prepare ( $ path , Zend_Http_Client $ client ) { $ client -> setUri ( $ this -> uri . '/' . $ path ) ; $ client -> resetParameters ( ) ; }
7744	public function getValue ( $ entity ) { if ( null === $ this -> getter ) { throw new \ Exception ( "Can't get the entity's {$this->name} property as no getter has been found." ) ; } elseif ( false === ( $ entity instanceof $ this -> class ) ) { throw new \ Exception ( "Can't get the entity's {$this->name} property as the entity is not an instance of {$this->class}." ) ; } if ( self :: GETTER_SETTER_METHOD === $ this -> getterType ) { return $ entity -> { $ this -> getter } ( ) ; } else { return $ entity -> { $ this -> getter } ; } }
9772	function property ( string $ name , $ value = null ) : self { $ isArray = is_array ( $ this -> target ) || $ this -> target instanceof \ ArrayAccess ; if ( ! $ isArray && ! is_object ( $ this -> target ) ) throw new \ BadMethodCallException ( 'The target is not an array nor an object.' ) ; $ hasProperty = $ isArray ? array_key_exists ( $ name , $ this -> target ) : property_exists ( $ this -> target , $ name ) ; $ hasPropertyConstraint = $ isArray ? arrayHasKey ( $ name ) : objectHasAttribute ( $ name ) ; $ property = $ isArray ? ( $ this -> target [ $ name ] ?? null ) : ( $ this -> target -> $ name ?? null ) ; if ( ! $ hasProperty || $ value === null ) $ this -> expect ( $ this -> target , $ hasPropertyConstraint ) ; else { assertThat ( $ this -> target , $ hasPropertyConstraint ) ; $ this -> expect ( $ property , equalTo ( $ value ) ) ; } $ this -> target = $ property ; return $ this ; }
5101	public function valuesExp ( $ expression , $ bind = false ) { return $ this -> appendPart ( CmdInsert :: PART_VALUES , $ expression , $ bind ) ; }
9385	public function getGroupedIcons ( ) { if ( $ icons = self :: cache ( ) -> get ( $ this -> getCacheKey ( ) ) ) { return $ icons ; } $ icons = [ ] ; $ data = Yaml :: parse ( $ this -> getSourceData ( ) ) ; if ( isset ( $ data [ 'icons' ] ) ) { foreach ( $ data [ 'icons' ] as $ icon ) { foreach ( $ icon [ 'categories' ] as $ category ) { if ( ! isset ( $ icons [ $ category ] ) ) { $ icons [ $ category ] = [ ] ; } $ icons [ $ category ] [ $ icon [ 'id' ] ] = [ 'name' => $ icon [ 'name' ] , 'unicode' => $ icon [ 'unicode' ] ] ; } } } ksort ( $ icons ) ; foreach ( $ icons as & $ group ) { uasort ( $ group , function ( $ a , $ b ) { return strcasecmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; } self :: cache ( ) -> set ( $ this -> getCacheKey ( ) , $ icons ) ; return $ icons ; }
6273	public static function haveExtension ( ) { if ( ! function_exists ( 'dba_handlers' ) ) { return false ; } $ handlers = dba_handlers ( ) ; if ( ! in_array ( 'cdb' , $ handlers ) || ! in_array ( 'cdb_make' , $ handlers ) ) { return false ; } return true ; }
12477	private function getTransformation ( ) { $ transforms = [ ] ; foreach ( $ this -> fields as $ field => $ extra ) { if ( is_int ( $ field ) ) { $ transforms [ $ extra ] = $ extra ; continue ; } $ transform = ( key_exists ( 'transform' , $ extra ) ) ? $ extra [ 'transform' ] : $ field ; if ( $ transform === false ) { continue ; } $ transforms [ $ field ] = $ transform ; } return $ transforms ; }
6093	public function section ( $ separator , $ first = 0 , $ last = 0 ) { $ sections = explode ( $ separator , $ this -> string ) ; $ total = count ( $ sections ) ; $ first = intval ( $ first ) ; $ last = intval ( $ last ) ; if ( $ first > $ total ) { return null ; } if ( $ first > $ last ) { $ last = $ first ; } for ( $ i = 0 ; $ i < $ total ; $ i ++ ) { if ( $ i < $ first || $ i > $ last ) { unset ( $ sections [ $ i ] ) ; } } $ string = implode ( $ separator , $ sections ) ; return new self ( $ string ) ; }
2622	public function sendConfigurationRequest ( $ configuredFlag ) { if ( $ configuredFlag ) { $ configuredState = self :: FASTLY_CONFIGURED_FLAG ; } else { $ configuredState = self :: FASTLY_NOT_CONFIGURED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ configuredState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ configuredState , 'dt' => ucfirst ( $ configuredState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ configuredState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
10206	public function setReadOrder ( $ pValue ) { if ( $ pValue < 0 || $ pValue > 2 ) { $ pValue = 0 ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'readOrder' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> readOrder = $ pValue ; } return $ this ; }
4957	public function onFlush ( OnFlushEventArgs $ args ) { $ dm = $ args -> getDocumentManager ( ) ; $ uow = $ dm -> getUnitOfWork ( ) ; $ filter = function ( $ element ) { return $ element instanceof $ this -> targetDocument && $ element instanceof PermissionsAwareInterface && $ element -> getPermissions ( ) -> hasChanged ( ) ; } ; $ inserts = array_filter ( $ uow -> getScheduledDocumentInsertions ( ) , $ filter ) ; $ updates = array_filter ( $ uow -> getScheduledDocumentUpdates ( ) , $ filter ) ; $ this -> process ( $ inserts , $ dm , $ uow , true ) ; $ this -> process ( $ updates , $ dm , $ uow ) ; }
12856	function performPayload ( iPayloadQueued $ processPayload ) { $ triesCount = 0 ; if ( $ processPayload instanceof FailedPayload ) { if ( $ processPayload -> getCountRetries ( ) > $ this -> getMaxTries ( ) ) throw new exPayloadMaxTriesExceed ( $ processPayload , sprintf ( 'Max Tries Exceeds After %s Tries.' , $ processPayload -> getCountRetries ( ) ) , null ) ; } $ payLoadData = $ processPayload -> getData ( ) ; try { if ( ob_get_level ( ) ) ob_end_clean ( ) ; ob_start ( ) ; $ this -> event ( ) -> trigger ( EventHeapOfWorker :: EVENT_PAYLOAD_RECEIVED , [ 'payload' => $ processPayload , 'data' => $ payLoadData , 'worker' => $ this ] ) ; ob_end_flush ( ) ; flush ( ) ; } catch ( \ LogicException $ e ) { throw $ e ; } catch ( \ Exception $ e ) { if ( ! $ processPayload instanceof FailedPayload ) $ failedPayload = new FailedPayload ( $ processPayload , $ triesCount ) ; else $ failedPayload = $ processPayload ; throw new exPayloadPerformFailed ( $ failedPayload , $ e ) ; } }
1737	public function loadFromPlugins ( ) : RouteCollection { $ collection = array_reduce ( $ this -> pluginLoader -> getInstancesOf ( PluginLoader :: ROUTING_PLUGINS , true ) , function ( RouteCollection $ collection , RoutingPluginInterface $ plugin ) : RouteCollection { $ routes = $ plugin -> getRouteCollection ( $ this -> loader -> getResolver ( ) , $ this -> kernel ) ; if ( $ routes instanceof RouteCollection ) { $ collection -> addCollection ( $ routes ) ; } return $ collection ; } , new RouteCollection ( ) ) ; if ( file_exists ( $ configFile = $ this -> rootDir . '/app/config/routing.yml' ) ) { $ routes = $ this -> loader -> getResolver ( ) -> resolve ( $ configFile ) -> load ( $ configFile ) ; if ( $ routes instanceof RouteCollection ) { $ collection -> addCollection ( $ routes ) ; } } foreach ( [ 'contao_frontend' , 'contao_index' , 'contao_root' , 'contao_catch_all' ] as $ name ) { if ( $ route = $ collection -> get ( $ name ) ) { $ collection -> add ( $ name , $ route ) ; } } return $ collection ; }
7823	protected function updateWorkflow ( $ workflow ) { $ attachments = $ this -> getNamespacedPipesByOption ( 'attach' ) ; $ detachments = $ this -> getNamespacedPipesByOption ( 'detach' ) ; $ this -> pipelines -> update ( $ workflow , $ attachments , $ detachments ) ; }
1955	public function getStyleSheets ( Contao \ DataContainer $ dc ) { $ intPid = $ dc -> activeRecord -> pid ; if ( Contao \ Input :: get ( 'act' ) == 'overrideAll' ) { $ intPid = Contao \ Input :: get ( 'id' ) ; } $ objStyleSheet = $ this -> Database -> prepare ( "SELECT id, name FROM tl_style_sheet WHERE pid=?" ) -> execute ( $ intPid ) ; if ( $ objStyleSheet -> numRows < 1 ) { return array ( ) ; } $ return = array ( ) ; while ( $ objStyleSheet -> next ( ) ) { $ return [ $ objStyleSheet -> id ] = $ objStyleSheet -> name ; } return $ return ; }
199	public function redirect ( $ url , $ statusCode = 302 , $ checkAjax = true ) { if ( is_array ( $ url ) && isset ( $ url [ 0 ] ) ) { $ url [ 0 ] = '/' . ltrim ( $ url [ 0 ] , '/' ) ; } $ url = Url :: to ( $ url ) ; if ( strncmp ( $ url , '/' , 1 ) === 0 && strncmp ( $ url , '//' , 2 ) !== 0 ) { $ url = Yii :: $ app -> getRequest ( ) -> getHostInfo ( ) . $ url ; } if ( $ checkAjax ) { if ( Yii :: $ app -> getRequest ( ) -> getIsAjax ( ) ) { if ( Yii :: $ app -> getRequest ( ) -> getHeaders ( ) -> get ( 'X-Ie-Redirect-Compatibility' ) !== null && $ statusCode === 302 ) { $ statusCode = 200 ; } if ( Yii :: $ app -> getRequest ( ) -> getIsPjax ( ) ) { $ this -> getHeaders ( ) -> set ( 'X-Pjax-Url' , $ url ) ; } else { $ this -> getHeaders ( ) -> set ( 'X-Redirect' , $ url ) ; } } else { $ this -> getHeaders ( ) -> set ( 'Location' , $ url ) ; } } else { $ this -> getHeaders ( ) -> set ( 'Location' , $ url ) ; } $ this -> setStatusCode ( $ statusCode ) ; return $ this ; }
1002	public static function visitWithTypeInfo ( TypeInfo $ typeInfo , $ visitor ) { return [ 'enter' => static function ( Node $ node ) use ( $ typeInfo , $ visitor ) { $ typeInfo -> enter ( $ node ) ; $ fn = self :: getVisitFn ( $ visitor , $ node -> kind , false ) ; if ( $ fn ) { $ result = call_user_func_array ( $ fn , func_get_args ( ) ) ; if ( $ result !== null ) { $ typeInfo -> leave ( $ node ) ; if ( $ result instanceof Node ) { $ typeInfo -> enter ( $ result ) ; } } return $ result ; } return null ; } , 'leave' => static function ( Node $ node ) use ( $ typeInfo , $ visitor ) { $ fn = self :: getVisitFn ( $ visitor , $ node -> kind , true ) ; $ result = $ fn ? call_user_func_array ( $ fn , func_get_args ( ) ) : null ; $ typeInfo -> leave ( $ node ) ; return $ result ; } , ] ; }
11400	public function fromData ( $ data ) { $ this -> fromdata = $ data ; $ resource = fopen ( 'php://memory' , 'r+' ) ; fwrite ( $ resource , $ data ) ; rewind ( $ resource ) ; $ this -> setResource ( $ resource ) ; return $ this ; }
8310	public function standardizeUrlFormat ( & $ rules , $ pageUrl ) { if ( ! is_string ( $ pageUrl ) || $ pageUrl === "" || ! is_array ( $ rules ) || ! array_key_exists ( $ pageUrl , $ rules ) ) { return ; } $ oldIndex = $ pageUrl ; if ( $ pageUrl [ 0 ] !== '/' ) { $ pageUrl = '/' . $ pageUrl ; } $ len = strlen ( $ pageUrl ) ; if ( $ len > 1 && $ pageUrl [ $ len - 1 ] === '/' ) { $ pageUrl = rtrim ( $ pageUrl , '/' ) ; } if ( $ oldIndex !== $ pageUrl ) { $ rules [ $ pageUrl ] = $ rules [ $ oldIndex ] ; unset ( $ rules [ $ oldIndex ] ) ; } }
4078	protected function fetchInputScreenDetails ( ) { $ inputScreenIds = array ( ) ; foreach ( $ this -> information as $ info ) { $ inputScreenIds [ ] = $ info [ self :: COMBINATION ] [ 'dca_id' ] ; } if ( ! $ inputScreenIds ) { return ; } $ statement = $ this -> connection -> query ( sprintf ( 'SELECT * FROM tl_metamodel_dca WHERE id IN (%s)' , implode ( ',' , $ inputScreenIds ) ) ) ; while ( $ inputScreens = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ screenId = $ inputScreens -> id ; $ metaModelId = $ inputScreens -> pid ; $ metaModelName = $ this -> tableNameFromId ( $ metaModelId ) ; $ propertyRows = $ this -> connection -> prepare ( 'SELECT * FROM tl_metamodel_dcasetting WHERE pid=? AND published=1 ORDER BY sorting ASC' ) ; $ propertyRows -> bindValue ( 1 , $ screenId ) ; $ propertyRows -> execute ( ) ; $ conditions = $ this -> connection -> prepare ( ' SELECT cond.*, setting.attr_id AS setting_attr_id FROM tl_metamodel_dcasetting_condition AS cond LEFT JOIN tl_metamodel_dcasetting AS setting ON (cond.settingId=setting.id) LEFT JOIN tl_metamodel_dca AS dca ON (setting.pid=dca.id) WHERE dca.id=? AND setting.published=1 AND cond.enabled=1 ORDER BY sorting ASC ' ) ; $ conditions -> bindValue ( 1 , $ screenId ) ; $ conditions -> execute ( ) ; $ groupSort = $ this -> connection -> prepare ( ' SELECT * FROM tl_metamodel_dca_sortgroup WHERE pid=? ORDER BY sorting ASC ' ) ; $ groupSort -> bindValue ( 1 , $ screenId ) ; $ groupSort -> execute ( ) ; $ inputScreen = array ( 'row' => $ inputScreens -> row ( ) , 'properties' => $ propertyRows -> fetchAll ( \ PDO :: FETCH_ASSOC ) , 'conditions' => $ conditions -> fetchAll ( \ PDO :: FETCH_ASSOC ) , 'groupSort' => $ groupSort -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] = $ inputScreen ; $ this -> information [ $ metaModelName ] [ self :: MODELID ] = $ metaModelId ; $ parentTable = $ inputScreen [ 'row' ] [ 'ptable' ] ; if ( $ parentTable && ! $ this -> isInputScreenStandalone ( $ metaModelName ) ) { $ this -> parentMap [ $ parentTable ] [ ] = $ this -> information [ $ metaModelName ] [ self :: MODELID ] ; $ this -> childMap [ $ metaModelName ] = $ parentTable ; } } }
889	private function shouldClearToken ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; return ! $ token -> isComment ( ) && ! ( $ token -> isWhitespace ( ) && $ tokens [ $ index + 1 ] -> isComment ( ) ) ; }
5111	protected function appendPart ( $ part , $ sql , $ bind = false ) { if ( ! is_array ( $ sql ) ) $ sql = [ $ sql ] ; if ( ! $ this -> parts [ $ part ] ) { $ this -> parts [ $ part ] = $ sql ; } else { $ this -> parts [ $ part ] = array_merge ( $ this -> parts [ $ part ] , $ sql ) ; } return $ this -> appendBind ( $ part , $ bind ) ; }
6984	protected function extractInputFromRules ( $ data , array $ rules ) { $ keys = collect ( $ rules ) -> keys ( ) -> map ( function ( $ rule ) { return explode ( '.' , $ rule ) [ 0 ] ; } ) -> unique ( ) -> toArray ( ) ; if ( ! ( $ data instanceof Request ) ) { $ data = collect ( $ data ) ; } return $ data -> only ( $ keys ) ; }
2185	public function onInitialize ( InitializeApplicationEvent $ event ) : void { $ this -> installAssets ( $ event ) ; $ this -> installContao ( $ event ) ; $ this -> createSymlinks ( $ event ) ; }
2348	public static function putContent ( $ strFile , $ strContent ) { $ objFile = new static ( $ strFile ) ; $ objFile -> write ( $ strContent ) ; $ objFile -> close ( ) ; }
9331	private function region ( $ filter , $ resource , $ region , $ colorspace = null , $ value = null ) { $ dest = imagecreatetruecolor ( $ region [ "w" ] , $ region [ "h" ] ) ; if ( ! imagecopy ( $ dest , $ resource , 0 , 0 , $ region [ "x" ] , $ region [ "y" ] , $ region [ "w" ] , $ region [ "h" ] ) ) { throw new ezcImageFilterFailedException ( "1/ {$function} applied on region {$region['x']}x{$region['y']}" ) ; } if ( ! $ colorspace ) { if ( $ filter == "pixelateImg" ) { $ result = $ this -> $ filter ( $ dest , imagesx ( $ resource ) , imagesy ( $ resource ) ) ; } else $ result = $ this -> $ filter ( $ dest , $ value ) ; } else { $ this -> setActiveResource ( $ dest ) ; parent :: colorspace ( $ colorspace ) ; $ result = $ dest ; } if ( ! imagecopy ( $ resource , $ result , $ region [ "x" ] , $ region [ "y" ] , 0 , 0 , $ region [ "w" ] , $ region [ "h" ] ) ) { throw new ezcImageFilterFailedException ( "2/ {$function} applied on region {$region['x']}x{$region['y']}" ) ; } return $ resource ; }
469	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } return $ model ; }
11070	public function setBoolean ( string $ key , $ value , bool $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( bool ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
9480	public function setErrorCode ( $ errorCode ) { $ this -> error = $ this -> config [ $ errorCode ] ; $ this -> errorCode = $ errorCode ; return $ this ; }
4722	public function setText ( $ text ) { $ this -> text = $ text ; if ( ! $ this -> text instanceof Text ) { $ this -> text = new Text ( $ this -> text ) ; } return $ this ; }
12890	public function createView ( ) : \ stdClass { $ oView = new \ stdClass ; $ oView -> form = $ this -> _sView ; $ oView -> form_start = $ this -> _oForm -> getFormInObject ( ) -> start ; $ oView -> form_end = $ this -> _oForm -> getFormInObject ( ) -> end ; $ oView -> form_row = array ( ) ; foreach ( $ this -> _oForm -> getFormInObject ( ) -> form as $ sKey => $ mValue ) { if ( $ mValue instanceof Container ) { $ oNewForm = $ mValue -> createView ( ) ; $ oView -> form_row [ $ sKey ] = $ oNewForm -> form_row ; } else { $ oView -> form_row [ $ sKey ] = $ mValue ; } } return $ oView ; }
12270	protected function dispatchSlotsEvent ( $ baseEventName , Page $ page , array $ slots ) { $ eventNames = $ this -> generateEventNames ( $ baseEventName , $ page ) ; $ event = new SlotsRenderingEvent ( $ slots ) ; foreach ( $ eventNames as $ eventName ) { $ event = Dispatcher :: dispatch ( $ eventName , $ event ) ; } return $ event -> getSlots ( ) ; }
2333	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> tokenChecker -> hasBackendUser ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( $ this -> requestAttribute , true ) ; }
7758	protected function loadMappingInformation ( array $ config , ContainerBuilder $ container ) { $ this -> drivers = array ( ) ; if ( $ config [ 'auto_mapping' ] ) { foreach ( array_keys ( $ container -> getParameter ( 'kernel.bundles' ) ) as $ bundle ) { if ( ! isset ( $ config [ 'mappings' ] [ $ bundle ] ) ) { $ config [ 'mappings' ] [ $ bundle ] = array ( 'mapping' => true , 'is_bundle' => true , ) ; } } } $ container -> setAlias ( 'hydra.naming_strategy' , new Alias ( $ config [ 'naming_strategy' ] , false ) ) ; foreach ( $ config [ 'mappings' ] as $ mappingName => $ mappingConfig ) { if ( null !== $ mappingConfig && false === $ mappingConfig [ 'mapping' ] ) { continue ; } $ mappingConfig = array_replace ( array ( 'dir' => false , 'type' => false , 'prefix' => false , ) , ( array ) $ mappingConfig ) ; $ mappingConfig [ 'dir' ] = $ container -> getParameterBag ( ) -> resolveValue ( $ mappingConfig [ 'dir' ] ) ; if ( ! isset ( $ mappingConfig [ 'is_bundle' ] ) ) { $ mappingConfig [ 'is_bundle' ] = ! is_dir ( $ mappingConfig [ 'dir' ] ) ; } if ( $ mappingConfig [ 'is_bundle' ] ) { $ bundle = null ; foreach ( $ container -> getParameter ( 'kernel.bundles' ) as $ name => $ class ) { if ( $ mappingName === $ name ) { $ bundle = new \ ReflectionClass ( $ class ) ; break ; } } if ( null === $ bundle ) { throw new \ InvalidArgumentException ( sprintf ( 'Bundle "%s" does not exist or it is not enabled.' , $ mappingName ) ) ; } $ mappingConfig = $ this -> getMappingDriverBundleConfigDefaults ( $ mappingConfig , $ bundle , $ container ) ; if ( ! $ mappingConfig ) { continue ; } } $ this -> validateMappingConfiguration ( $ mappingConfig , $ mappingName ) ; $ this -> setMappingDriverConfig ( $ mappingConfig , $ mappingName ) ; } $ this -> registerMappingDrivers ( $ config , $ container ) ; }
12922	public function getForeignDataItems ( ) { if ( ! isset ( $ this -> _foreignDataItems ) ) { $ this -> _foreignDataItems = [ ] ; $ this -> trigger ( self :: EVENT_LOAD_FOREIGN_DATA_ITEMS ) ; } return $ this -> _foreignDataItems ; }
5500	protected function replaceWildcards ( $ args ) { if ( $ args === false ) { return false ; } for ( $ i = 0 ; $ i < count ( $ args ) ; $ i ++ ) { if ( $ args [ $ i ] === $ this -> wildcard ) { $ args [ $ i ] = new AnythingExpectation ( ) ; } } return $ args ; }
3384	private function findUser ( ) { $ sql = sprintf ( 'SELECT * FROM %s WHERE %s = :identity' , $ this -> getTableName ( ) , $ this -> getIdentityColumn ( ) ) ; $ stmt = $ this -> db -> prepare ( $ sql ) ; $ stmt -> execute ( array ( 'identity' => $ this -> getIdentity ( ) ) ) ; return $ stmt -> fetch ( PDO :: FETCH_ASSOC ) ; }
12932	protected function generateContentAttribute ( $ name , $ value , $ type = 'text' ) { $ attribute = new ContentAttribute ( ) ; $ attribute -> setName ( $ name ) ; $ attribute -> setValue ( $ value ) ; if ( is_array ( $ value ) ) { $ value = '' ; } $ attribute -> setStringValue ( $ value ) ; $ attribute -> setType ( $ type ) ; return $ attribute ; }
7691	function OpenMXL_GarbageCollector ( ) { if ( ( count ( $ this -> IdxToCheck ) == 0 ) && ( count ( $ this -> OtbsSheetSlidesDelete ) == 0 ) ) return ; $ pic_path = $ this -> ExtInfo [ 'pic_path' ] ; $ pic_path_len = strlen ( $ pic_path ) ; $ rels_ext = '.rels' ; $ rels_ext_len = strlen ( $ rels_ext ) ; $ pictures = array ( ) ; $ rels = array ( ) ; foreach ( $ this -> CdFileLst as $ idx => $ f ) { $ n = $ f [ 'v_name' ] ; if ( substr ( $ n , 0 , $ pic_path_len ) == $ pic_path ) { $ short = basename ( $ pic_path ) . '/' . basename ( $ n ) ; $ pictures [ ] = array ( 'name' => $ n , 'idx' => $ idx , 'nbr' => 0 , 'short' => $ short ) ; } elseif ( substr ( $ n , - $ rels_ext_len ) == $ rels_ext ) { if ( $ this -> FileGetState ( $ idx ) != 'd' ) $ rels [ $ n ] = $ idx ; } } foreach ( $ rels as $ n => $ idx ) { $ txt = $ this -> TbsStoreGet ( $ idx , 'GarbageCollector' ) ; foreach ( $ pictures as $ i => $ info ) { if ( strpos ( $ txt , $ info [ 'short' ] . '"' ) !== false ) $ pictures [ $ i ] [ 'nbr' ] ++ ; } } foreach ( $ pictures as $ info ) { if ( $ info [ 'nbr' ] == 0 ) $ this -> FileReplace ( $ info [ 'idx' ] , false ) ; } }
9776	function throw ( string $ className = '' ) : self { if ( ! is_callable ( $ this -> target ) ) throw new \ BadMethodCallException ( 'The function target is not callable.' ) ; $ exception = null ; try { call_user_func ( $ this -> target ) ; } catch ( \ Throwable $ e ) { $ exception = $ e ; } $ constraint = logicalNot ( isNull ( ) ) ; return $ this -> expect ( $ exception , mb_strlen ( $ className ) ? logicalAnd ( $ constraint , isInstanceOf ( $ className ) ) : $ constraint ) ; }
411	private function utf8Encode ( $ s ) { $ s .= $ s ; $ len = \ strlen ( $ s ) ; for ( $ i = $ len >> 1 , $ j = 0 ; $ i < $ len ; ++ $ i , ++ $ j ) { switch ( true ) { case $ s [ $ i ] < "\x80" : $ s [ $ j ] = $ s [ $ i ] ; break ; case $ s [ $ i ] < "\xC0" : $ s [ $ j ] = "\xC2" ; $ s [ ++ $ j ] = $ s [ $ i ] ; break ; default : $ s [ $ j ] = "\xC3" ; $ s [ ++ $ j ] = \ chr ( \ ord ( $ s [ $ i ] ) - 64 ) ; break ; } } return substr ( $ s , 0 , $ j ) ; }
936	public static function getNameForId ( $ id ) { if ( CT :: has ( $ id ) ) { return CT :: getName ( $ id ) ; } $ name = token_name ( $ id ) ; return 'UNKNOWN' === $ name ? null : $ name ; }
3552	protected static function boot ( ) { parent :: boot ( ) ; if ( ! isset ( static :: $ attributeMutator ) ) { if ( function_exists ( 'app' ) && app ( ) -> bound ( 'eloquence.mutator' ) ) { static :: $ attributeMutator = app ( 'eloquence.mutator' ) ; } else { static :: $ attributeMutator = new Mutator ; } } }
2041	public static function symlink ( string $ target , string $ link , string $ rootDir ) : void { static :: validateSymlink ( $ target , $ link , $ rootDir ) ; $ fs = new Filesystem ( ) ; if ( ! $ fs -> isAbsolutePath ( $ target ) ) { $ target = $ rootDir . '/' . $ target ; } if ( ! $ fs -> isAbsolutePath ( $ link ) ) { $ link = $ rootDir . '/' . $ link ; } if ( '\\' === \ DIRECTORY_SEPARATOR ) { $ fs -> symlink ( $ target , $ link ) ; } else { $ fs -> symlink ( rtrim ( $ fs -> makePathRelative ( $ target , \ dirname ( $ link ) ) , '/' ) , $ link ) ; } }
11639	public function getColumnSettings ( ) { if ( is_null ( $ this -> _columnSettings ) ) { $ this -> _columnSettings = [ ] ; foreach ( $ this -> columns as $ key => $ c ) { if ( ! $ c -> visible ) { continue ; } $ this -> _columnSettings [ $ key ] = [ 'label' => $ c -> getDataLabel ( ) ] ; if ( ! isset ( $ c -> htmlOptions ) ) { $ c -> htmlOptions = [ ] ; } $ this -> _columnSettings [ $ key ] [ 'htmlOptions' ] = $ c -> htmlOptions ; $ sortableResolve = $ this -> dataProvider -> sort -> resolveAttribute ( $ c -> name ) ; $ this -> _columnSettings [ $ key ] [ 'sortable' ] = ! empty ( $ sortableResolve ) ; } } return $ this -> _columnSettings ; }
5465	public function addRealm ( $ url , $ type , $ realm ) { $ this -> realms [ $ url -> getHost ( ) ] [ $ realm ] = new SimpleRealm ( $ type , $ url ) ; }
4071	public function getJavascripts ( GetOptionsEvent $ event ) { if ( ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_rendersettings' ) || ( $ event -> getPropertyName ( ) !== 'additionalJs' ) || ( $ event -> getSubPropertyName ( ) !== 'file' ) ) { return ; } $ event -> setOptions ( $ this -> scanFiles ( 'js' ) ) ; }
11696	protected function normaliseSrcInput ( $ input ) : array { $ output = [ ] ; if ( $ input instanceof Finder ) { foreach ( $ input as $ fileInfo ) { $ output [ ] = $ fileInfo -> getRealpath ( ) ; } } else { if ( ! is_array ( $ input ) ) $ input = [ $ input ] ; if ( count ( $ input ) === 0 ) throw new \ UnexpectedValueException ; if ( ! is_string ( $ input [ 0 ] ) ) throw new \ UnexpectedValueException ; $ output = $ input ; } return $ output ; }
3900	public function searchFor ( $ strPattern ) { $ strPattern = str_replace ( array ( '*' , '?' ) , array ( '%' , '_' ) , $ strPattern ) ; $ arrIds = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' ) -> from ( $ this -> getMetaModel ( ) -> getTableName ( ) ) -> where ( $ this -> getColName ( ) . ' LIKE :pattern' ) -> setParameter ( 'pattern' , $ strPattern ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_COLUMN , 'id' ) ; return $ arrIds ; }
1745	public function showFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { if ( Contao \ Input :: get ( 'popup' ) ) { return '' ; } else { return '<a href="contao/popup.php?src=' . base64_encode ( $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . ' onclick="Backend.openModalIframe({\'title\':\'' . str_replace ( "'" , "\\'" , Contao \ StringUtil :: specialchars ( $ row [ 'fileNameEncoded' ] ) ) . '\',\'url\':this.href});return false">' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } }
7462	public function getContent ( string $ name , array $ data = [ ] ) : string { $ cacheName = $ name ; if ( '' == $ name ) { $ this -> isRouteView = true ; $ stack = debug_backtrace ( ) ; foreach ( $ stack as $ item ) { if ( false !== stripos ( $ item [ 'file' ] , DIRECTORY_SEPARATOR . 'Route' . DIRECTORY_SEPARATOR ) ) { $ cacheName = pathinfo ( $ item [ 'file' ] , PATHINFO_DIRNAME ) . '/' . $ name ; $ cacheName = explode ( 'Route' . DIRECTORY_SEPARATOR , $ cacheName ) [ 1 ] ; $ cacheName = 'route_' . str_replace ( [ '/' , '\\' ] , '_' , $ cacheName ) ; break ; } } } $ cacheName .= '_' . $ this -> language . '.html.php' ; $ path = $ this -> packageRoot . '/view/_cache/' . str_replace ( '/' , '_' , $ cacheName ) ; $ exist = file_exists ( $ path ) ; if ( ! $ this -> cache || ! $ exist ) { $ code = $ this -> compile ( $ name . '/view.html.php' , true , true , true ) ; $ code = preg_replace ( [ '/\>[^\S ]+/s' , '/[^\S ]+\</s' , '/(\s)+/s' ] , [ '>' , '<' , '\\1' ] , $ code ) ; if ( $ exist ) { $ fh = fopen ( $ path , 'r+b' ) ; } else { $ fh = fopen ( $ path , 'wb' ) ; } if ( flock ( $ fh , LOCK_EX ) ) { ftruncate ( $ fh , 0 ) ; fwrite ( $ fh , $ code ) ; flock ( $ fh , LOCK_UN ) ; } fclose ( $ fh ) ; } $ fh = fopen ( $ path , 'rb' ) ; if ( flock ( $ fh , LOCK_SH ) ) { $ html = self :: renderTemplate ( $ path , $ data ) ; flock ( $ fh , LOCK_UN ) ; fclose ( $ fh ) ; return $ html ; } throw new \ RuntimeException ( 'Can\'t render template' ) ; }
3973	public function encodeAttributeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ value = substr ( $ value , \ strlen ( $ metaModel -> getTableName ( ) . '_' ) ) ; $ attribute = $ metaModel -> getAttribute ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ attribute -> get ( 'id' ) ) ; } }
5811	public function updateCMSFields ( FieldList $ fields ) { $ fields -> removeByName ( 'FusionTags' ) ; $ types = array ( ) ; foreach ( singleton ( 'FusionService' ) -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } $ types = array_intersect ( $ this -> owner -> many_many ( ) , $ types ) ; if ( empty ( $ types ) ) { $ fields -> addFieldToTab ( 'Root.Tagging' , ListboxField :: create ( 'FusionTags' , 'Tags' , FusionTag :: get ( ) -> map ( ) -> toArray ( ) ) -> setMultiple ( true ) ) ; } $ this -> owner -> extend ( 'updateTaggingExtensionCMSFields' , $ fields ) ; }
8892	public function consumeSlimContainer ( Set $ container ) { foreach ( $ container as $ key => $ value ) { if ( $ value instanceof \ Closure ) { $ refFunc = new \ ReflectionFunction ( $ value ) ; $ shared = in_array ( 'object' , $ refFunc -> getStaticVariables ( ) ) ; $ this -> registerFactory ( $ key , $ value , $ shared ) ; } elseif ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value , false ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } } }
1942	public function listRecipient ( $ row ) { $ label = Contao \ Idna :: decodeEmail ( $ row [ 'email' ] ) ; if ( $ row [ 'addedOn' ] ) { $ label .= ' <span style="color:#999;padding-left:3px">(' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'subscribed' ] , Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ row [ 'addedOn' ] ) ) . ')</span>' ; } else { $ label .= ' <span style="color:#999;padding-left:3px">(' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'manually' ] . ')</span>' ; } return sprintf ( '<div class="tl_content_left"><div class="list_icon" style="background-image:url(\'%ssystem/themes/%s/icons/%s.svg\')" data-icon="member.svg" data-icon-disabled="member_.svg">%s</div></div>' , Contao \ System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) , Contao \ Backend :: getTheme ( ) , ( $ row [ 'active' ] ? 'member' : 'member_' ) , $ label ) . "\n" ; }
6805	private function generate ( $ class , array $ names , $ defaultCode ) { $ repository = $ this -> manager -> getRepository ( $ class ) ; foreach ( $ names as $ code => $ name ) { $ result = 'already exists' ; if ( null === $ repository -> findOneBy ( [ 'code' => $ code ] ) ) { $ entity = $ repository -> createNew ( ) ; $ entity -> setName ( $ name ) -> setCode ( $ code ) -> setEnabled ( $ defaultCode === $ code ) ; $ this -> manager -> persist ( $ entity ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } $ this -> manager -> flush ( ) ; }
11369	public static function checkPeopleArgs ( ) { $ args = func_get_args ( ) ; if ( empty ( $ args ) ) { return array ( ) ; } if ( count ( $ args ) == 1 && is_string ( $ args [ 0 ] ) && self :: isEmail ( $ args [ 0 ] ) ) { return array ( array ( $ args [ 0 ] ) ) ; } if ( count ( $ args ) == 2 && ( isset ( $ args [ 0 ] ) && true === self :: isEmail ( $ args [ 0 ] ) ) && ( isset ( $ args [ 1 ] ) && false === self :: isEmail ( $ args [ 1 ] ) ) ) { return array ( array ( $ args [ 1 ] => $ args [ 0 ] ) ) ; } if ( count ( $ args ) == 1 ) { $ args = $ args [ 0 ] ; } $ result = array ( ) ; foreach ( $ args as $ name => $ email ) { if ( is_string ( $ name ) && true === self :: isEmail ( $ email ) ) { $ result [ ] = array ( $ name => $ email ) ; } elseif ( is_numeric ( $ name ) && true === self :: isEmail ( $ email ) ) { $ result [ ] = array ( $ email ) ; } } return $ result ; }
11643	public function getFormatter ( ) { if ( $ this -> _formatter === null ) { $ this -> _formatter = Yii :: $ app -> format ; } return $ this -> _formatter ; }
4659	public function getChainStrategy ( ) { $ strategy = new ChainBuildStrategy ( ) ; $ strategy -> pushStrategy ( $ this -> getTravisCiStrategy ( ) ) ; $ strategy -> pushStrategy ( $ this -> getJoliCiStrategy ( ) ) ; return $ strategy ; }
6647	public function callback ( $ input ) { if ( isset ( $ input [ 'denied' ] ) ) { throw new AuthenticationCanceledException ( ) ; } if ( ! isset ( $ input [ 'oauth_token' ] ) || ! isset ( $ input [ 'oauth_verifier' ] ) ) { throw new InvalidOAuthTokenException ( 'missing oauth_token or oauth_verifier' ) ; } $ verifier_token = $ this -> token -> verifier ( $ input [ 'oauth_token' ] , $ input [ 'oauth_verifier' ] ) ; $ access_token = $ this -> oauth -> getAccessToken ( $ this -> settings , $ this -> consumer , $ verifier_token ) ; return $ this -> getProfile ( $ access_token ) ; }
3114	public function clearEvents ( $ testSessionId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> clearEvents ( ) ; $ extendedState -> save ( ) ; }
3040	public function del ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ this -> putInCache ( $ key , $ userId , $ callId , null , self :: STATE_PENDING_DELETE ) ; return true ; }
6999	public function getCssClassesForContainer ( ) { $ colsXl = $ this -> getWidth ( ) >= 100 ? 12 : ceil ( 12 * ( $ this -> getWidth ( ) / 100 ) ) ; $ colsXlLeft = floor ( ( 12 - $ colsXl ) / 2 ) ; $ colsLg = $ colsXl >= 10 ? 12 : $ colsXl + 2 ; $ colsLgLeft = floor ( ( 12 - $ colsLg ) / 2 ) ; return "col-xs-12 col-xl-{$colsXl} col-lg-{$colsLg} col-xl-offset-{$colsXlLeft} col-lg-offset-{$colsLgLeft}" ; }
11770	public function switchTo ( NodeConnectionInterface $ connection ) { if ( $ connection && $ connection === $ this -> current ) { return ; } if ( $ connection !== $ this -> master && ! in_array ( $ connection , $ this -> slaves , true ) ) { throw new \ InvalidArgumentException ( 'Invalid connection or connection not found.' ) ; } $ connection -> connect ( ) ; if ( $ this -> current ) { $ this -> current -> disconnect ( ) ; } $ this -> current = $ connection ; }
2538	protected function initSoapClient ( $ wsdlId ) { $ wsdlPath = WsdlAnalyser :: $ wsdlIds [ $ wsdlId ] ; $ client = new Client \ SoapClient ( $ wsdlPath , $ this -> makeSoapClientOptions ( ) , $ this -> params -> logger ) ; return $ client ; }
4754	public function startProfiling ( ) { if ( PHP_SAPI == 'cli' ) { $ _SERVER [ 'REMOTE_ADDR' ] = null ; $ _SERVER [ 'REQUEST_URI' ] = $ _SERVER [ 'SCRIPT_NAME' ] ; } if ( function_exists ( 'xhprof_enable' ) && count ( $ this -> probes ) > 0 ) { $ this -> profiling = true ; xhprof_enable ( $ this -> memory ? XHPROF_FLAGS_MEMORY : null ) ; } }
12639	protected function rethrowExceptions ( callable $ callable ) { try { return $ callable ( ) ; } catch ( ImplementationNotFoundException $ ex ) { throw new ImplementationNotFoundException ( $ ex -> getMessage ( ) ) ; } catch ( TypeMismatchException $ ex ) { throw new TypeMismatchException ( $ ex -> getMessage ( ) ) ; } catch ( UnresolveableArgumentException $ ex ) { throw new UnresolveableArgumentException ( $ ex -> getMessage ( ) ) ; } catch ( ValueNotFoundException $ ex ) { throw new ValueNotFoundException ( $ ex -> getMessage ( ) ) ; } catch ( InvalidCallableFormatException $ ex ) { throw new InvalidCallableFormatException ( $ ex -> getMessage ( ) ) ; } catch ( MissingDefinitionIdentifierException $ ex ) { throw new MissingDefinitionIdentifierException ( $ ex -> getMessage ( ) ) ; } catch ( MissingDefinitionValueException $ ex ) { throw new MissingDefinitionValueException ( $ ex -> getMessage ( ) ) ; } catch ( ClassNotFoundException $ ex ) { throw new ClassNotFoundException ( $ ex -> getMessage ( ) ) ; } }
8970	protected function toJson ( RateInterface $ rate ) { return json_encode ( array ( 'sourceName' => $ rate -> getSourceName ( ) , 'value' => $ rate -> getValue ( ) , 'currencyCode' => $ rate -> getCurrencyCode ( ) , 'rateType' => $ rate -> getRateType ( ) , 'date' => $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) , 'baseCurrencyCode' => $ rate -> getBaseCurrencyCode ( ) , 'createdAt' => $ rate -> getCreatedAt ( ) -> format ( \ DateTime :: ATOM ) , 'modifiedAt' => $ rate -> getModifiedAt ( ) -> format ( \ DateTime :: ATOM ) , ) ) ; }
11153	public function getBoolean ( $ probability = 0.5 ) { if ( ( \ is_int ( $ probability ) || \ is_float ( $ probability ) ) === false || $ probability < 0 || $ probability > 1 ) { throw new InvalidArgumentException ( 'Invalid probability' ) ; } if ( $ probability == 0 ) { $ result = false ; } else { $ random = $ this -> generator -> getFloat ( 0 , 1 ) ; $ result = ( $ probability >= $ random ) ; } return $ result ; }
10004	static function getStringFromHTTPStatusCode ( $ httpStatusCode ) { if ( array_key_exists ( $ httpStatusCode , HTTPResponseCodes :: $ codes ) === true ) { return HTTPResponseCodes :: $ codes [ $ httpStatusCode ] ; } else { return "unknown error code: " . $ httpStatusCode ; } }
4366	protected function backtraceStr ( Event $ error ) { $ backtrace = $ error [ 'backtrace' ] ? $ error [ 'backtrace' ] : $ error -> getSubject ( ) -> backtrace ( ) ; if ( \ count ( $ backtrace ) < 2 ) { return '' ; } if ( $ backtrace && $ error [ 'vars' ] ) { $ backtrace [ 0 ] [ 'vars' ] = $ error [ 'vars' ] ; } if ( $ this -> cfg [ 'emailBacktraceDumper' ] ) { $ str = \ call_user_func ( $ this -> cfg [ 'emailBacktraceDumper' ] , $ backtrace ) ; } else { $ search = array ( ")\n\n" , ) ; $ replace = array ( ")\n" , ) ; $ str = \ print_r ( $ backtrace , true ) ; $ str = \ preg_replace ( '#\bArray\n\(#' , 'array(' , $ str ) ; $ str = \ preg_replace ( '/\barray\s+\(\s+\)/s' , 'array()' , $ str ) ; $ str = \ str_replace ( $ search , $ replace , $ str ) ; $ str = \ substr ( $ str , 0 , - 1 ) ; } return $ str ; }
9016	public function markAllNotificationsAsRead ( ) { $ object = Auth :: user ( ) ; $ object -> unreadNotifications -> markAsRead ( ) ; \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
5687	public function getFormBySubmit ( $ selector ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> hasSubmit ( $ selector ) ) { return $ this -> forms [ $ i ] ; } } return ; }
1784	protected function fetchItems ( $ newsArchives , $ blnFeatured , $ limit , $ offset ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListFetchItems' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListFetchItems' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListFetchItems' ] as $ callback ) { if ( ( $ objCollection = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ newsArchives , $ blnFeatured , $ limit , $ offset , $ this ) ) === false ) { continue ; } if ( $ objCollection === null || $ objCollection instanceof Collection ) { return $ objCollection ; } } } $ t = NewsModel :: getTable ( ) ; $ arrOptions = array ( ) ; switch ( $ this -> news_order ) { case 'order_headline_asc' : $ arrOptions [ 'order' ] = "$t.headline" ; break ; case 'order_headline_desc' : $ arrOptions [ 'order' ] = "$t.headline DESC" ; break ; case 'order_random' : $ arrOptions [ 'order' ] = "RAND()" ; break ; case 'order_date_asc' : $ arrOptions [ 'order' ] = "$t.date" ; break ; default : $ arrOptions [ 'order' ] = "$t.date DESC" ; } return NewsModel :: findPublishedByPids ( $ newsArchives , $ blnFeatured , $ limit , $ offset , $ arrOptions ) ; }
3247	public function add ( $ item , $ quantity = 1 , $ quantityReset = false ) { if ( ! is_array ( $ item ) && ! $ item -> isShoppable ) return ; $ cartItem = $ this -> getItem ( is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku ) ; if ( empty ( $ cartItem ) ) { $ reflection = null ; if ( is_object ( $ item ) ) { $ reflection = new \ ReflectionClass ( $ item ) ; } $ cartItem = call_user_func ( Config :: get ( 'shop.item' ) . '::create' , [ 'user_id' => $ this -> user -> shopId , 'cart_id' => $ this -> attributes [ 'id' ] , 'sku' => is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku , 'price' => is_array ( $ item ) ? $ item [ 'price' ] : $ item -> price , 'tax' => is_array ( $ item ) ? ( array_key_exists ( 'tax' , $ item ) ? $ item [ 'tax' ] : 0 ) : ( isset ( $ item -> tax ) && ! empty ( $ item -> tax ) ? $ item -> tax : 0 ) , 'shipping' => is_array ( $ item ) ? ( array_key_exists ( 'shipping' , $ item ) ? $ item [ 'shipping' ] : 0 ) : ( isset ( $ item -> shipping ) && ! empty ( $ item -> shipping ) ? $ item -> shipping : 0 ) , 'currency' => Config :: get ( 'shop.currency' ) , 'quantity' => $ quantity , 'class' => is_array ( $ item ) ? null : $ reflection -> getName ( ) , 'reference_id' => is_array ( $ item ) ? null : $ item -> shopId , ] ) ; } else { $ cartItem -> quantity = $ quantityReset ? $ quantity : $ cartItem -> quantity + $ quantity ; $ cartItem -> save ( ) ; } $ this -> resetCalculations ( ) ; return $ this ; }
4925	public function getTypes ( $ region = null ) { if ( null === $ region ) { $ ret = [ ] ; foreach ( $ this -> matrix as $ types ) { $ ret = array_merge ( $ ret , $ types ) ; } return array_values ( array_unique ( $ ret ) ) ; } return $ this -> matrix [ $ region ] ; }
5776	public function add ( string $ sql ) { $ args = func_get_args ( ) ; array_shift ( $ args ) ; $ this -> sql .= $ sql ; $ this -> args = array_merge ( $ this -> args , $ args ) ; return $ this ; }
10435	public function post ( $ request ) { if ( $ request instanceof Request ) { $ request = $ request -> xml ( ) ; } $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> url ) ; if ( $ this -> user_agent != null ) { curl_setopt ( $ ch , CURLOPT_USERAGENT , $ this -> user_agent ) ; } curl_setopt ( $ ch , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_POST , 1 ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ request ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-type: application/xml; charset=utf-8' , ) ) ; $ response = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; if ( empty ( $ response ) ) { return null ; } return $ response ; }
12063	public function can_save_post_meta ( $ post_id , $ action , $ nonce ) { $ is_autosave = wp_is_post_autosave ( $ post_id ) ; $ is_revision = wp_is_post_revision ( $ post_id ) ; $ is_valid_nonce = ( isset ( $ _POST [ $ nonce ] ) && wp_verify_nonce ( $ _POST [ $ nonce ] , $ action ) ) ; return ! ( $ is_autosave || $ is_revision ) && $ is_valid_nonce ; }
1144	protected function bootstrapConfigs ( ) { $ configFile = realpath ( __DIR__ . '/../config/jsvalidation.php' ) ; $ this -> mergeConfigFrom ( $ configFile , 'jsvalidation' ) ; $ this -> publishes ( [ $ configFile => $ this -> app [ 'path.config' ] . '/jsvalidation.php' ] , 'config' ) ; }
189	public function setTransactionIsolationLevel ( $ level ) { switch ( $ level ) { case Transaction :: SERIALIZABLE : $ this -> db -> createCommand ( 'PRAGMA read_uncommitted = False;' ) -> execute ( ) ; break ; case Transaction :: READ_UNCOMMITTED : $ this -> db -> createCommand ( 'PRAGMA read_uncommitted = True;' ) -> execute ( ) ; break ; default : throw new NotSupportedException ( get_class ( $ this ) . ' only supports transaction isolation levels READ UNCOMMITTED and SERIALIZABLE.' ) ; } }
590	protected function compressJsFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing JavaScript files...\n" ) ; if ( is_string ( $ this -> jsCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineJsFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> jsCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> jsCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress JavaScript files into '{$outputFile}'." ) ; } $ this -> stdout ( " JavaScript files compressed into '{$outputFile}'.\n" ) ; }
657	public function release ( $ name ) { if ( $ this -> releaseLock ( $ name ) ) { $ index = array_search ( $ name , $ this -> _locks ) ; if ( $ index !== false ) { unset ( $ this -> _locks [ $ index ] ) ; } return true ; } return false ; }
813	private function fixSpaceAboveClassElement ( Tokens $ tokens , $ classStartIndex , $ elementIndex ) { static $ methodAttr = [ T_PRIVATE , T_PROTECTED , T_PUBLIC , T_ABSTRACT , T_FINAL , T_STATIC ] ; $ firstElementAttributeIndex = $ elementIndex ; for ( $ i = $ elementIndex ; $ i > $ classStartIndex ; -- $ i ) { $ nonWhiteAbove = $ tokens -> getNonWhitespaceSibling ( $ i , - 1 ) ; if ( null !== $ nonWhiteAbove && $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( $ methodAttr ) ) { $ firstElementAttributeIndex = $ nonWhiteAbove ; } else { break ; } } if ( $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_COMMENT ) ) { if ( 1 === $ firstElementAttributeIndex - $ nonWhiteAbove ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; return ; } if ( substr_count ( $ tokens [ $ nonWhiteAbove + 1 ] -> getContent ( ) , "\n" ) > 1 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; return ; } if ( $ tokens [ $ nonWhiteAbove - 1 ] -> isWhitespace ( ) && substr_count ( $ tokens [ $ nonWhiteAbove - 1 ] -> getContent ( ) , "\n" ) > 0 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbove = $ this -> findCommentBlockStart ( $ tokens , $ nonWhiteAbove ) ; $ nonWhiteAboveComment = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAboveComment , $ nonWhiteAbove , $ nonWhiteAboveComment === $ classStartIndex ? 1 : 2 ) ; } else { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; } return ; } if ( false === $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_DOC_COMMENT ) ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , $ nonWhiteAbove === $ classStartIndex ? 1 : 2 ) ; return ; } $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbovePHPDoc = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbovePHPDoc , $ nonWhiteAbove , $ nonWhiteAbovePHPDoc === $ classStartIndex ? 1 : 2 ) ; }
4588	public function setMaxResults ( ? int $ maxResults ) { $ this -> maxResults = $ maxResults ; $ this -> _maxResults = null !== $ maxResults ; return $ this ; }
2852	public function deleteTemplateHintsDbConfigs ( ) { $ configTable = Mage :: getResourceModel ( 'core/config' ) -> getMainTable ( ) ; $ db = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ db -> delete ( $ configTable , "path like 'dev/debug/template_hints%'" ) ; }
10971	public static function getHeader ( $ header , $ defaultValue = '' ) { $ header = strtolower ( str_replace ( [ '_' , ' ' ] , '-' , $ header ) ) ; $ headers = self :: getHeaders ( ) ; if ( is_array ( $ headers ) ) { foreach ( $ headers as $ name => $ value ) { if ( strtolower ( $ name ) == $ header ) { return $ value ; } } } return $ defaultValue ; }
1683	public function getModules ( ) { $ arrModules = array ( ) ; foreach ( $ GLOBALS [ 'BE_MOD' ] as $ k => $ v ) { if ( ! empty ( $ v ) ) { if ( $ k == 'accounts' ) { unset ( $ v [ 'login' ] ) ; } if ( $ k == 'system' ) { unset ( $ v [ 'undo' ] ) ; } $ arrModules [ $ k ] = array_keys ( $ v ) ; } } return $ arrModules ; }
2798	public function toArray ( ) { return [ 'file' => $ this -> getMutationFileRelativePath ( ) , 'mutator' => $ this -> mutation -> getMutator ( ) , 'class' => $ this -> mutation -> getClass ( ) , 'method' => $ this -> mutation -> getMethod ( ) , 'line' => $ this -> mutation -> getLine ( ) , 'diff' => $ this -> getDiff ( ) , 'tests' => $ this -> testMethods ] ; }
8979	protected function initialize ( ) { if ( $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ this -> tableName ] ) ) { return ; } $ schema = new Schema ( ) ; $ table = $ schema -> createTable ( $ this -> tableName ) ; $ table -> addColumn ( 'source_name' , 'string' , [ 'length' => 255 ] ) ; $ table -> addColumn ( 'rate_value' , 'float' , [ 'precision' => 10 , 'scale' => 4 ] ) ; $ table -> addColumn ( 'currency_code' , 'string' , [ 'length' => 3 ] ) ; $ table -> addColumn ( 'rate_type' , 'string' , [ 'length' => 255 ] ) ; $ table -> addColumn ( 'rate_date' , 'date' , [ ] ) ; $ table -> addColumn ( 'base_currency_code' , 'string' , [ 'length' => 3 ] ) ; $ table -> addColumn ( 'created_at' , 'datetime' , [ ] ) ; $ table -> addColumn ( 'modified_at' , 'datetime' , [ ] ) ; $ table -> setPrimaryKey ( [ 'currency_code' , 'rate_date' , 'rate_type' , 'source_name' ] ) ; $ this -> connection -> exec ( $ schema -> toSql ( $ this -> connection -> getDatabasePlatform ( ) ) [ 0 ] ) ; }
3172	protected function updateStats ( & $ target , $ itemInfos ) { if ( ! isset ( $ target [ 'stats' ] ) ) { $ target [ 'stats' ] = [ 'questions' => 0 , 'answered' => 0 , 'flagged' => 0 , 'viewed' => 0 , 'total' => 0 , 'questionsViewed' => 0 , ] ; } if ( empty ( $ itemInfos [ 'informational' ] ) ) { $ target [ 'stats' ] [ 'questions' ] ++ ; if ( ! empty ( $ itemInfos [ 'answered' ] ) ) { $ target [ 'stats' ] [ 'answered' ] ++ ; } if ( ! empty ( $ itemInfos [ 'viewed' ] ) ) { $ target [ 'stats' ] [ 'questionsViewed' ] ++ ; } } if ( ! empty ( $ itemInfos [ 'flagged' ] ) ) { $ target [ 'stats' ] [ 'flagged' ] ++ ; } if ( ! empty ( $ itemInfos [ 'viewed' ] ) ) { $ target [ 'stats' ] [ 'viewed' ] ++ ; } $ target [ 'stats' ] [ 'total' ] ++ ; }
465	public function buildBetweenCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
5232	public function equals ( $ compare ) { if ( $ compare instanceof self ) { return ( get_class ( $ compare ) === get_class ( $ this ) && $ compare -> name ( ) === $ this -> name ) ; } return false ; }
5594	protected function createRequest ( $ url , $ encoding ) { $ request = $ this -> createHttpRequest ( $ url , $ encoding ) ; $ this -> addAdditionalHeaders ( $ request ) ; if ( $ this -> cookies_enabled ) { $ request -> readCookiesFromJar ( $ this -> cookie_jar , $ url ) ; } $ this -> authenticator -> addHeaders ( $ request , $ url ) ; if ( $ this -> http_referer ) { $ headers = $ request -> getHeaders ( ) ; if ( is_array ( $ headers ) ) { $ custom_referer = false ; foreach ( $ headers as $ header ) { if ( preg_match ( '~^referer:~i' , $ header ) ) { $ custom_referer = true ; break ; } } if ( ! $ custom_referer ) { $ request -> addHeaderLine ( 'Referer: ' . $ this -> http_referer ) ; } } } return $ request ; }
8874	public function addAttachment ( $ attachment ) { if ( ! file_exists ( $ attachment ) ) { pines_error ( 'Invalid attachment.' ) ; return false ; } $ this -> attachments [ ] = $ attachment ; return true ; }
9069	public function purge ( $ days_older_than = 60 , \ wpdb $ wpdb ) { $ days_older_than = absint ( $ days_older_than ) ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ sql = "DELETE FROM {$tn} WHERE time < DATE_SUB(NOW(), INTERVAL $days_older_than DAY)" ; $ wpdb -> query ( $ sql ) ; }
2500	private function getIndexFieldType ( ContentType $ contentType , FieldDefinition $ fieldDefinition , FieldType $ fieldType ) { if ( ! $ fieldType instanceof FieldType \ TextField ) { return $ fieldType ; } $ fieldType = clone $ fieldType ; $ fieldType -> boost = $ this -> boostFactorProvider -> getContentFieldBoostFactor ( $ contentType , $ fieldDefinition ) ; return $ fieldType ; }
944	private function parseRules ( ) { if ( null === $ this -> options [ 'rules' ] ) { return $ this -> getConfig ( ) -> getRules ( ) ; } $ rules = trim ( $ this -> options [ 'rules' ] ) ; if ( '' === $ rules ) { throw new InvalidConfigurationException ( 'Empty rules value is not allowed.' ) ; } if ( '{' === $ rules [ 0 ] ) { $ rules = json_decode ( $ rules , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new InvalidConfigurationException ( sprintf ( 'Invalid JSON rules input: %s.' , json_last_error_msg ( ) ) ) ; } return $ rules ; } $ rules = [ ] ; foreach ( explode ( ',' , $ this -> options [ 'rules' ] ) as $ rule ) { $ rule = trim ( $ rule ) ; if ( '' === $ rule ) { throw new InvalidConfigurationException ( 'Empty rule name is not allowed.' ) ; } if ( '-' === $ rule [ 0 ] ) { $ rules [ substr ( $ rule , 1 ) ] = false ; } else { $ rules [ $ rule ] = true ; } } return $ rules ; }
4247	private function logRequestHeaders ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.headers' ) ) { return ; } if ( ! empty ( $ _SERVER [ 'argv' ] ) ) { return ; } $ headers = $ this -> debug -> utilities -> getAllHeaders ( ) ; \ ksort ( $ headers , SORT_NATURAL ) ; $ this -> debug -> log ( 'request headers' , $ headers ) ; }
7663	function AddAttachment ( $ path , $ name = "" , $ encoding = "base64" , $ type = "application/octet-stream" ) { if ( ! @ is_file ( $ path ) ) { $ this -> SetError ( $ this -> Lang ( "file_access" ) . $ path ) ; return false ; } $ filename = basename ( $ path ) ; if ( $ name == "" ) $ name = $ filename ; $ cur = count ( $ this -> attachment ) ; $ this -> attachment [ $ cur ] [ 0 ] = $ path ; $ this -> attachment [ $ cur ] [ 1 ] = $ filename ; $ this -> attachment [ $ cur ] [ 2 ] = $ name ; $ this -> attachment [ $ cur ] [ 3 ] = $ encoding ; $ this -> attachment [ $ cur ] [ 4 ] = $ type ; $ this -> attachment [ $ cur ] [ 5 ] = false ; $ this -> attachment [ $ cur ] [ 6 ] = "attachment" ; $ this -> attachment [ $ cur ] [ 7 ] = 0 ; return true ; }
3747	protected function extractSorting ( $ config ) { $ sorting = $ config -> getSorting ( ) ; $ sortBy = key ( $ sorting ) ; $ sortDir = current ( $ sorting ) ? : DCGE :: MODEL_SORTING_ASC ; return array ( $ sortBy , $ sortDir ) ; }
762	private function tokensMatch ( SqlToken $ patternToken , SqlToken $ token , $ offset = 0 , & $ firstMatchIndex = null , & $ lastMatchIndex = null ) { if ( $ patternToken -> getIsCollection ( ) !== $ token -> getIsCollection ( ) || ( ! $ patternToken -> getIsCollection ( ) && $ patternToken -> content !== $ token -> content ) ) { return false ; } if ( $ patternToken -> children === $ token -> children ) { $ firstMatchIndex = $ lastMatchIndex = $ offset ; return true ; } $ firstMatchIndex = $ lastMatchIndex = null ; $ wildcard = false ; for ( $ index = 0 , $ count = count ( $ patternToken -> children ) ; $ index < $ count ; $ index ++ ) { if ( $ patternToken [ $ index ] -> content === 'any' ) { $ wildcard = true ; continue ; } for ( $ limit = $ wildcard ? count ( $ token -> children ) : $ offset + 1 ; $ offset < $ limit ; $ offset ++ ) { if ( ! $ wildcard && ! isset ( $ token [ $ offset ] ) ) { break ; } if ( ! $ this -> tokensMatch ( $ patternToken [ $ index ] , $ token [ $ offset ] ) ) { continue ; } if ( $ firstMatchIndex === null ) { $ firstMatchIndex = $ offset ; $ lastMatchIndex = $ offset ; } else { $ lastMatchIndex = $ offset ; } $ wildcard = false ; $ offset ++ ; continue 2 ; } return false ; } return true ; }
3221	function searchFileNames ( $ basePath , $ query , $ limit = null , $ includeDeleted = false ) { Path :: checkArg ( "basePath" , $ basePath ) ; Checker :: argStringNonEmpty ( "query" , $ query ) ; Checker :: argNatOrNull ( "limit" , $ limit ) ; Checker :: argBool ( "includeDeleted" , $ includeDeleted ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/search" , $ basePath ) , array ( "query" => $ query , "file_limit" => $ limit , "include_deleted" => $ includeDeleted , ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
466	public function buildInCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
8617	public function setInvalidSKU ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InvalidSKU' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12135	public function show ( QuestionRequest $ request , Question $ question ) { if ( $ question -> exists ) { $ view = 'forum::question.show' ; } else { $ view = 'forum::question.new' ; } return $ this -> response -> title ( trans ( 'app.view' ) . ' ' . trans ( 'forum::question.name' ) ) -> data ( compact ( 'question' ) ) -> view ( $ view , true ) -> output ( ) ; }
9808	private function readOPT ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ this -> readOfficeArtRGFOPTE ( $ recordData , $ recInstance ) ; }
12561	public function send ( $ msgType , $ message , $ to = null ) { $ message = ( new MessageBuilder ( ) ) -> msgType ( $ msgType ) -> message ( $ message ) -> to ( $ to ) -> build ( ) ; $ api = is_array ( $ to ) ? self :: API_SEND_BY_OPENID : self :: API_SEND_BY_GROUP ; return $ this -> post ( $ api , $ message ) ; }
4650	private function parseEnvironmentLine ( $ environmentLine ) { $ variables = array ( ) ; @ $ variableLines = explode ( ' ' , $ environmentLine ? : '' ) ; foreach ( $ variableLines as $ variableLine ) { if ( ! empty ( $ variableLine ) ) { list ( $ key , $ value ) = $ this -> parseEnvironementVariable ( $ variableLine ) ; $ variables [ $ key ] = $ value ; } } return $ variables ; }
7590	public function renderTemplate ( CollectionElement $ collection ) { if ( false != ( $ sElementLayout = $ collection -> getOption ( 'twb-layout' ) ) ) { $ elementOrFieldset = $ collection -> getTemplateElement ( ) ; $ elementOrFieldset -> setOption ( 'twb-layout' , $ sElementLayout ) ; } return parent :: renderTemplate ( $ collection ) ; }
10601	public function editQuery ( $ name , $ value ) { $ parts = explode ( '&' , $ this -> _urlParts [ 'query' ] ) ; $ return = [ ] ; foreach ( $ parts as $ p ) { $ paramData = explode ( '=' , $ p ) ; if ( $ paramData [ 0 ] === $ name ) { $ paramData [ 1 ] = $ value ; } $ return [ ] = implode ( '=' , $ paramData ) ; } $ this -> _urlParts [ 'query' ] = implode ( '&' , $ return ) ; return $ this ; }
1907	protected function escapeParams ( $ arrValues ) { foreach ( $ arrValues as $ k => $ v ) { switch ( \ gettype ( $ v ) ) { case 'string' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( $ v ) ; break ; case 'boolean' : $ arrValues [ $ k ] = ( $ v === true ) ? 1 : 0 ; break ; case 'object' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( serialize ( $ v ) ) ; break ; case 'array' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( serialize ( $ v ) ) ; break ; default : $ arrValues [ $ k ] = $ v ?? 'NULL' ; break ; } } return $ arrValues ; }
9402	public function build ( $ options ) { $ command = $ this -> path ; if ( isset ( $ options [ 'title' ] ) ) { $ command .= " -t {$options['title']}" ; } if ( isset ( $ options [ 'message' ] ) ) { $ command .= " -m {$options['message']}" ; } if ( isset ( $ options [ 'image' ] ) ) { $ pathInfo = pathinfo ( $ options [ 'image' ] ) ; if ( isset ( $ pathInfo [ 'extension' ] ) ) { $ command .= " --image {$options['image']}" ; } else { $ command .= " -a {$options['image']}" ; } } if ( isset ( $ options [ 'url' ] ) ) { $ command .= " --url {$options['url']}" ; } if ( isset ( $ options [ 'sticky' ] ) && $ options [ 'sticky' ] === true ) { $ command .= ' -s' ; } return $ command ; }
8572	private function _convertListRecommendations ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetRecommendationCategory ( ) ) { $ parameters [ 'RecommendationCategory' ] = $ request -> getRecommendationCategory ( ) ; } if ( $ request -> isSetCategoryQueryList ( ) ) { $ parameters [ 'CategoryQueryList' ] = $ request -> getCategoryQueryList ( ) ; } return $ parameters ; }
10100	private function writeRichTextString ( $ row , $ col , $ str , $ xfIndex , $ arrcRun ) { $ record = 0x00FD ; $ length = 0x000A ; $ str = StringHelper :: UTF8toBIFF8UnicodeShort ( $ str , $ arrcRun ) ; if ( ! isset ( $ this -> stringTable [ $ str ] ) ) { $ this -> stringTable [ $ str ] = $ this -> stringUnique ++ ; } ++ $ this -> stringTotal ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvV' , $ row , $ col , $ xfIndex , $ this -> stringTable [ $ str ] ) ; $ this -> append ( $ header . $ data ) ; }
10192	public static function parseDsn ( $ string = null ) { $ opts = null ; if ( ! empty ( $ string ) ) { $ dsn = ( object ) DsnParser :: parseUrl ( $ string ) -> toArray ( ) ; $ opts = [ 'driver' => $ dsn -> driver , 'host' => $ dsn -> host , 'database' => $ dsn -> dbname , 'username' => $ dsn -> user , 'password' => isset ( $ dsn -> pass ) ? $ dsn -> pass : null ] ; } return $ opts ; }
10837	protected function buildOrderBy ( ) { $ result = [ ] ; foreach ( $ this -> clause_orderby as $ ord ) { $ result [ ] = $ ord [ 0 ] ? $ ord [ 1 ] : ( $ this -> quote ( $ ord [ 1 ] ) . ' ' . $ ord [ 2 ] ) ; } return $ result ; }
9861	private function writeDimension ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'dimension' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pSheet -> calculateWorksheetDimension ( ) ) ; $ objWriter -> endElement ( ) ; }
10763	public function setPaymentType ( $ paymentType ) { if ( self :: PAYMENT_PEER_TO_PEER !== $ paymentType ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid payment type.' ) ) ; } return $ this -> add ( 'PT' , $ paymentType ) ; }
6559	public function get_number_type ( $ phone_number = '' , $ region = NULL ) { $ inputParams = array ( 'phone_number' => $ phone_number , 'region' => $ region ) ; $ this -> debug -> info ( __FUNCTION__ , 'Input Params: ' , $ inputParams ) ; if ( empty ( $ phone_number ) ) { $ this -> debug -> warning ( __FUNCTION__ , 'Phone Number input is Empty!' ) ; return NULL ; } $ phone_number = trim ( $ phone_number ) ; try { $ phoneNumberUtil = PhoneNumberUtil :: getInstance ( ) ; $ use_region = NULL !== $ region ? strtoupper ( $ region ) : self :: DEFAULT_REGION ; $ phoneNumberObject = $ phoneNumberUtil -> parse ( trim ( $ phone_number ) , $ use_region ) ; $ result = $ phoneNumberUtil -> getNumberType ( $ phoneNumberObject ) ; $ this -> debug -> debug ( __FUNCTION__ , 'Use REGION: ' . $ use_region ) ; $ this -> debug -> info ( __FUNCTION__ , 'Final Result: ' . $ result ) ; return $ result ; } catch ( \ Exception $ e ) { $ message = 'Error File: ' . $ e -> getFile ( ) . ' - Line: ' . $ e -> getLine ( ) . ' - Code: ' . $ e -> getCode ( ) . ' - Message: ' . $ e -> getMessage ( ) ; $ this -> debug -> error ( __FUNCTION__ , $ message ) ; return NULL ; } }
1179	protected function getValidationData ( array $ rules , array $ customAttributes = [ ] ) { $ attributes = array_filter ( array_keys ( $ rules ) , function ( $ attribute ) { return $ attribute !== '' && mb_strpos ( $ attribute , '*' ) !== false ; } ) ; $ attributes = array_merge ( array_keys ( $ customAttributes ) , $ attributes ) ; $ data = array_reduce ( $ attributes , function ( $ data , $ attribute ) { Arr :: set ( $ data , $ attribute , true ) ; return $ data ; } , [ ] ) ; return $ data ; }
9750	public function _savePps ( & $ raList ) { $ iC = count ( $ raList ) ; for ( $ i = 0 ; $ i < $ iC ; ++ $ i ) { fwrite ( $ this -> fileHandle , $ raList [ $ i ] -> _getPpsWk ( ) ) ; } $ iCnt = count ( $ raList ) ; $ iBCnt = $ this -> bigBlockSize / OLE :: OLE_PPS_SIZE ; if ( $ iCnt % $ iBCnt ) { fwrite ( $ this -> fileHandle , str_repeat ( "\x00" , ( $ iBCnt - ( $ iCnt % $ iBCnt ) ) * OLE :: OLE_PPS_SIZE ) ) ; } }
7706	function _ApplyDiffFromStart ( $ Diff ) { $ this -> pST_PosEnd += $ Diff ; $ this -> pST_Src = false ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; }
1375	private function runCommandsWithParameters ( Collection $ commands , array $ parameters ) { foreach ( $ commands -> keys ( ) as $ command ) { if ( 0 !== $ this -> call ( $ command , $ parameters ) ) { return false ; } } return true ; }
1389	protected function resourceExists ( string $ type , string $ id , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceExists ( $ type , $ id , $ path ) ) ; }
2956	public function deviceClose ( ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { return true ; } if ( fclose ( $ this -> _dHandle ) ) { $ this -> _dHandle = null ; $ this -> _dState = SERIAL_DEVICE_SET ; return true ; } trigger_error ( "Unable to close the device" , E_USER_ERROR ) ; return false ; }
12312	private function writeToWebDir ( $ file , $ contents ) { if ( ! $ this -> webDir ) { return ; } if ( ! is_writable ( $ this -> webDir ) ) { trigger_error ( sprintf ( 'Directory %s is not writeable' , $ this -> webDir ) ) ; return ; } $ destFile = $ this -> webDir . $ file ; $ destDir = dirname ( $ destFile ) ; if ( ! is_dir ( $ destDir ) ) { mkdir ( $ destDir , 0777 , true ) ; } file_put_contents ( $ destFile , $ contents ) ; }
8780	protected function scheme ( ) { if ( $ this -> cachedHttps === true ) { $ this -> https = true ; } return "http" . ( $ this -> https === true ? 's' : '' ) . "://" ; }
6027	public function setUploaded ( $ uploaded ) { if ( $ uploaded instanceof DateTime ) { $ this -> uploaded = $ uploaded ; } else { try { $ this -> uploaded = new DateTime ( $ uploaded ) ; } catch ( \ Exception $ e ) { $ this -> uploaded = null ; } } return $ this ; }
4711	public function wrap ( $ start , $ end ) { $ this -> text = $ start . $ this -> text . $ end ; return $ this ; }
8626	public function setTermsAndConditionsNotAcceptedCarrierList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'TermsAndConditionsNotAcceptedCarrierList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11937	protected function find ( $ params ) { $ debug = false ; $ q = new Query ( ) ; $ q -> select ( '*' ) ; $ q -> from ( $ this -> _tableName ) ; foreach ( $ params as $ k => $ v ) { if ( $ k === 'join' ) { foreach ( $ v as $ join ) { if ( ! isset ( $ join [ 'type' ] ) ) { $ join [ 'type' ] = 'INNER JOIN' ; } if ( ! isset ( $ join [ 'params' ] ) ) { $ join [ 'params' ] = [ ] ; } $ q -> join ( $ join [ 'type' ] , $ join [ 'table' ] , $ join [ 'on' ] , $ join [ 'params' ] ) ; } $ debug = true ; } elseif ( in_array ( $ k , [ 'where' ] ) ) { $ q -> { $ k } ( $ v ) ; } else { $ q -> { $ k } = $ v ; } } if ( $ debug ) { } return $ q ; }
7837	public function register ( ) { $ className = studly_case ( strtolower ( config ( 'message.vendor' , 'smsgatewayme' ) ) ) ; $ classPath = '\Yugo\SMSGateway\Vendors\\' . $ className ; if ( ! class_exists ( $ classPath ) ) { abort ( 500 , sprintf ( 'SMS vendor %s is not available.' , $ className ) ) ; } app ( ) -> bind ( SMS :: class , $ classPath ) ; }
757	protected function renderImageByGD ( $ code ) { $ image = imagecreatetruecolor ( $ this -> width , $ this -> height ) ; $ backColor = imagecolorallocate ( $ image , ( int ) ( $ this -> backColor % 0x1000000 / 0x10000 ) , ( int ) ( $ this -> backColor % 0x10000 / 0x100 ) , $ this -> backColor % 0x100 ) ; imagefilledrectangle ( $ image , 0 , 0 , $ this -> width - 1 , $ this -> height - 1 , $ backColor ) ; imagecolordeallocate ( $ image , $ backColor ) ; if ( $ this -> transparent ) { imagecolortransparent ( $ image , $ backColor ) ; } $ foreColor = imagecolorallocate ( $ image , ( int ) ( $ this -> foreColor % 0x1000000 / 0x10000 ) , ( int ) ( $ this -> foreColor % 0x10000 / 0x100 ) , $ this -> foreColor % 0x100 ) ; $ length = strlen ( $ code ) ; $ box = imagettfbbox ( 30 , 0 , $ this -> fontFile , $ code ) ; $ w = $ box [ 4 ] - $ box [ 0 ] + $ this -> offset * ( $ length - 1 ) ; $ h = $ box [ 1 ] - $ box [ 5 ] ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ fontSize = ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ; $ angle = mt_rand ( - 10 , 10 ) ; $ letter = $ code [ $ i ] ; $ box = imagettftext ( $ image , $ fontSize , $ angle , $ x , $ y , $ foreColor , $ this -> fontFile , $ letter ) ; $ x = $ box [ 2 ] + $ this -> offset ; } imagecolordeallocate ( $ image , $ foreColor ) ; ob_start ( ) ; imagepng ( $ image ) ; imagedestroy ( $ image ) ; return ob_get_clean ( ) ; }
12647	public function setFalse ( $ obData = null ) { $ this -> bStatus = false ; $ this -> obData = $ obData ; return $ this ; }
9972	public function setCodeName ( $ pValue , $ validate = true ) { if ( $ this -> getCodeName ( ) == $ pValue ) { return $ this ; } if ( $ validate ) { $ pValue = str_replace ( ' ' , '_' , $ pValue ) ; self :: checkSheetCodeName ( $ pValue ) ; if ( $ this -> getParent ( ) ) { if ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue ) ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 29 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 29 ) ; } $ i = 1 ; while ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue . '_' . $ i ) ) { ++ $ i ; if ( $ i == 10 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 28 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 28 ) ; } } elseif ( $ i == 100 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 27 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 27 ) ; } } } $ pValue = $ pValue . '_' . $ i ; } } } $ this -> codeName = $ pValue ; return $ this ; }
2254	protected function eliminateNestedPaths ( $ arrPaths ) { $ arrPaths = array_filter ( $ arrPaths ) ; if ( empty ( $ arrPaths ) || ! \ is_array ( $ arrPaths ) ) { return array ( ) ; } $ nested = array ( ) ; foreach ( $ arrPaths as $ path ) { $ nested [ ] = preg_grep ( '/^' . preg_quote ( $ path , '/' ) . '\/.+/' , $ arrPaths ) ; } if ( ! empty ( $ nested ) ) { $ nested = array_merge ( ... $ nested ) ; } return array_values ( array_diff ( $ arrPaths , $ nested ) ) ; }
3456	public static function fromString ( string $ aggregateTypeString ) : AggregateType { if ( empty ( $ aggregateTypeString ) ) { throw new Exception \ InvalidArgumentException ( 'AggregateType must be a non empty string' ) ; } $ self = new static ( ) ; $ self -> aggregateType = $ aggregateTypeString ; return $ self ; }
2295	public static function getTinyTemplates ( ) { $ strDir = Config :: get ( 'uploadPath' ) . '/tiny_templates' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strDir ) ) { return '' ; } $ arrFiles = array ( ) ; $ arrTemplates = scan ( $ rootDir . '/' . $ strDir ) ; foreach ( $ arrTemplates as $ strFile ) { if ( strncmp ( '.' , $ strFile , 1 ) !== 0 && is_file ( $ rootDir . '/' . $ strDir . '/' . $ strFile ) ) { $ arrFiles [ ] = '{ title: "' . $ strFile . '", url: "' . $ strDir . '/' . $ strFile . '" }' ; } } return implode ( ",\n" , $ arrFiles ) . "\n" ; }
2936	public function getBackups ( ) { $ backups = array_diff ( scandir ( $ this -> backupPath ) , array ( '..' , '.' ) ) ; $ output = [ ] ; foreach ( $ backups as $ backup ) { $ filenamePrefix = preg_quote ( self :: BACKUP_FILENAME_PREFIX , '/' ) ; $ filenameSuffix = preg_quote ( self :: BACKUP_FILENAME_SUFFIX , '/' ) ; $ filenameRegex = '/^' . $ filenamePrefix . '(\d{4})_(\d{2})_(\d{2})_(\d{2})(\d{2})(\d{2})' . $ filenameSuffix . '$/' ; $ datetime = preg_replace ( $ filenameRegex , '$1-$2-$3 $4:$5:$6' , $ backup ) ; $ data = [ 'filename' => $ backup , 'filepath' => $ this -> backupPath . $ backup , 'created_at' => $ datetime , ] ; $ output [ ] = $ data ; } return $ output ; }
5199	public function validateOptions ( array $ options ) { foreach ( $ options as $ option => $ value ) { if ( ! in_array ( $ option , $ this -> allowedOptions ) ) throw new InvalidOptionException ( "Option [$option] is not valid" ) ; } return $ this ; }
9807	private function readBlipJPEG ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ pos = 0 ; $ rgbUid1 = substr ( $ recordData , 0 , 16 ) ; $ pos += 16 ; if ( in_array ( $ recInstance , [ 0x046B , 0x06E3 ] ) ) { $ rgbUid2 = substr ( $ recordData , 16 , 16 ) ; $ pos += 16 ; } $ tag = ord ( $ recordData [ $ pos ] ) ; $ pos += 1 ; $ data = substr ( $ recordData , $ pos ) ; $ blip = new Blip ( ) ; $ blip -> setData ( $ data ) ; $ this -> object -> setBlip ( $ blip ) ; }
9146	public function get ( $ key ) { if ( ! isset ( $ this -> sessionContainer [ $ key ] ) ) { return null ; } return $ this -> sessionContainer [ $ key ] ; }
12710	public function make ( $ instance , $ parameters = [ ] ) { return $ this -> resolve ( $ instance , is_array ( $ parameters ) ? $ parameters : array_slice ( func_get_args ( ) , 1 ) ) ; }
3566	public function setAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ this -> hasColumn ( $ key ) && $ this -> allowsMeta ( $ key ) && ! $ this -> hasSetMutator ( $ key ) ) { return $ this -> setMeta ( $ key , $ value ) ; } return $ next ( $ value , $ args ) ; } ; }
2413	protected function addTableTlStyleSheet ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_style_sheet' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_style_sheet' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_style_sheet' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE pid=? ORDER BY name" ) -> execute ( $ objTheme -> id ) ; while ( $ objStyleSheet -> next ( ) ) { $ this -> addDataRow ( $ xml , $ table , $ objStyleSheet -> row ( ) , $ arrOrder ) ; } $ objStyleSheet -> reset ( ) ; $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_style' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_style' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_style' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; while ( $ objStyleSheet -> next ( ) ) { $ objStyle = $ this -> Database -> prepare ( "SELECT * FROM tl_style WHERE pid=? ORDER BY sorting" ) -> execute ( $ objStyleSheet -> id ) ; while ( $ objStyle -> next ( ) ) { $ this -> addDataRow ( $ xml , $ table , $ objStyle -> row ( ) , $ arrOrder ) ; } } }
2362	public static function findFirstActiveWithJumpToByIds ( $ arrIds ) { @ trigger_error ( 'Using MemberGroupModel::findFirstActiveWithJumpToByIds() has been deprecated and will no longer work in Contao 5.0. Use PageModel::findFirstActiveByMemberGroups() instead.' , E_USER_DEPRECATED ) ; if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } return new static ( $ objResult ) ; }
6550	public function current ( ) { if ( $ this -> iterator -> valid ( ) === false ) { return null ; } $ iterator = $ this -> iterator -> current ( ) -> getCellIterator ( ) ; $ iterator -> setIterateOnlyExistingCells ( false ) ; $ result = [ ] ; foreach ( $ iterator as $ cell ) { $ result [ ] = $ cell -> getValue ( ) ; } return $ result ; }
1081	private function loc ( Token $ startToken ) { if ( empty ( $ this -> lexer -> options [ 'noLocation' ] ) ) { return new Location ( $ startToken , $ this -> lexer -> lastToken , $ this -> lexer -> source ) ; } return null ; }
4512	public function kernelView ( GetResponseForControllerResultEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( ! $ request -> query -> has ( 'locale' ) ) { return ; } $ controllerResult = $ event -> getControllerResult ( ) ; $ locale = $ request -> query -> get ( 'locale' ) ; if ( $ controllerResult instanceof Paginator || is_array ( $ controllerResult ) ) { foreach ( $ controllerResult as $ model ) { if ( $ model instanceof Localizable ) { $ this -> localeService -> localize ( $ model , $ locale ) ; } } } elseif ( $ controllerResult instanceof Localizable ) { $ this -> localeService -> localize ( $ controllerResult , $ locale ) ; } $ event -> setControllerResult ( $ controllerResult ) ; }
7719	function meth_Conv_Str ( & $ Txt , $ ConvBr = true ) { if ( $ this -> Charset === '' ) { $ Txt = htmlspecialchars ( $ Txt ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } elseif ( $ this -> _CharsetFct ) { $ Txt = call_user_func ( $ this -> Charset , $ Txt , $ ConvBr ) ; } else { $ Txt = htmlspecialchars ( $ Txt , ENT_COMPAT , $ this -> Charset ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } }
1105	protected function applyLockBetween ( $ lft , $ rgt ) { $ this -> node -> newQuery ( ) -> where ( $ this -> node -> getLeftColumnName ( ) , '>=' , $ lft ) -> where ( $ this -> node -> getRightColumnName ( ) , '<=' , $ rgt ) -> select ( $ this -> node -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; }
12956	public function remove ( $ id ) { if ( ! $ this -> has ( $ id ) ) { throw new NotFoundException ( sprintf ( '%s not found in %s' , $ id , __CLASS__ ) ) ; } unset ( $ this -> objects [ $ id ] ) ; }
3807	protected function translateLegend ( $ legend , $ metaModel ) { $ arrLegend = StringUtil :: deserialize ( $ legend [ 'legendtitle' ] ) ; if ( is_array ( $ arrLegend ) ) { $ strLegend = $ arrLegend [ $ GLOBALS [ 'TL_LANGUAGE' ] ] ; if ( ! $ strLegend ) { $ strLegend = $ arrLegend [ $ metaModel -> getFallbackLanguage ( ) ] ; if ( ! $ strLegend ) { $ strLegend = 'legend' . ( count ( $ this -> legends ) + 1 ) ; } } } else { $ strLegend = $ legend [ 'legendtitle' ] ? $ legend [ 'legendtitle' ] : 'legend' ; } $ legendName = StringUtil :: standardize ( $ strLegend ) ; $ this -> legends [ $ legendName ] = array ( 'name' => $ strLegend , 'visible' => ! ( isset ( $ legend [ 'legendhide' ] ) && ( bool ) $ legend [ 'legendhide' ] ) , 'properties' => array ( ) ) ; return $ legendName ; }
9825	public function writeDrawingRelationships ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet , & $ chartRef , $ includeCharts = false ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ i = 1 ; $ iterator = $ pWorksheet -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { if ( $ iterator -> current ( ) instanceof \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Drawing || $ iterator -> current ( ) instanceof MemoryDrawing ) { $ this -> writeRelationship ( $ objWriter , $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image' , '../media/' . str_replace ( ' ' , '' , $ iterator -> current ( ) -> getIndexedFilename ( ) ) ) ; } $ iterator -> next ( ) ; ++ $ i ; } if ( $ includeCharts ) { $ chartCount = $ pWorksheet -> getChartCount ( ) ; if ( $ chartCount > 0 ) { for ( $ c = 0 ; $ c < $ chartCount ; ++ $ c ) { $ this -> writeRelationship ( $ objWriter , $ i ++ , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart' , '../charts/chart' . ++ $ chartRef . '.xml' ) ; } } } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
6313	private function loadConstraints ( Table $ table ) { foreach ( $ this -> getConstraints ( ) as $ constraint ) { switch ( $ constraint [ 'constraint_type' ] ) { case 'FOREIGN KEY' : $ foreignKey = new ForeignKey ( new Table ( $ constraint [ 'table_name' ] ) , new Table ( $ constraint [ 'column_name' ] ) ) ; $ foreignKey -> setColumns ( $ constraint [ 'references_table' ] ) ; $ foreignKey -> setReferencedColumns ( $ constraint [ 'references_field' ] ) ; $ table -> addConstraint ( $ foreignKey ) ; break ; case 'PRIMARY KEY' : $ table -> addConstraint ( new PrimaryKey ( $ constraint [ 'column_name' ] , $ table ) ) ; break ; case 'UNIQUE' : $ table -> addConstraint ( new Unique ( $ constraint [ 'column_name' ] , new Table ( $ constraint [ 'table_name' ] ) ) ) ; break ; } } }
6557	protected function mapLogLevelToStyle ( $ logLevel ) { if ( isset ( $ this -> logLevelStyleMapping [ $ logLevel ] ) ) { return $ this -> logLevelStyleMapping [ $ logLevel ] ; } return Simple :: DEFAULT_STYLE ; }
364	public function renderCaption ( ) { if ( ! empty ( $ this -> caption ) ) { return Html :: tag ( 'caption' , $ this -> caption , $ this -> captionOptions ) ; } return false ; }
2650	public function validateServiceVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/validate' ; $ result = $ this -> _fetch ( $ url , 'GET' ) ; if ( $ result -> status == 'error' ) { throw new LocalizedException ( __ ( 'Failed to validate service version: ' . $ result -> msg ) ) ; } }
8722	public function translate ( $ locale ) { $ found = $ this -> translations -> where ( $ this -> getLocaleKey ( ) , $ locale ) -> first ( ) ; if ( ! $ found && $ this -> shouldFallback ( $ locale ) ) { return $ this -> translate ( $ this -> getFallbackLocale ( ) ) ; } return $ found ; }
10630	public static function memory ( ) { $ memory = new \ StdClass ( ) ; $ memory -> real = new \ StdClass ( ) ; $ memory -> swap = new \ StdClass ( ) ; if ( false !== ( $ data = @ file ( '/proc/meminfo' ) ) ) { $ data = implode ( "" , $ data ) ; preg_match_all ( "/MemTotal\s{0,}\:+\s{0,}([\d\.]+).+?MemFree\s{0,}\:+\s{0,}([\d\.]+).+?Cached\s{0,}\:+\s{0,}([\d\.]+).+?SwapTotal\s{0,}\:+\s{0,}([\d\.]+).+?SwapFree\s{0,}\:+\s{0,}([\d\.]+)/s" , $ data , $ meminfo ) ; preg_match_all ( "/Buffers\s{0,}\:+\s{0,}([\d\.]+)/s" , $ data , $ buffers ) ; $ memory -> total = $ meminfo [ 1 ] [ 0 ] * 1024 ; $ memory -> free = $ meminfo [ 2 ] [ 0 ] * 1024 ; $ memory -> used = $ memory -> total - $ memory -> free ; $ memory -> cached = $ meminfo [ 3 ] [ 0 ] * 1024 ; $ memory -> buffers = $ buffers [ 1 ] [ 0 ] * 1024 ; $ memory -> real -> used = $ memory -> total - $ memory -> free - $ memory -> cached - $ memory -> buffers ; $ memory -> real -> free = $ memory -> total - $ memory -> real -> used ; $ memory -> swap -> free = $ meminfo [ 5 ] [ 0 ] * 1024 ; $ memory -> swap -> used = $ meminfo [ 4 ] [ 0 ] * 1024 - $ memory -> swap -> free ; } return $ memory ; }
7730	public function api ( $ url , $ body = null , $ type = self :: TYPE_POST ) { $ body [ 'access_token' ] = $ this -> accessToken ; $ this -> setBody ( $ body ) ; $ headers = [ 'Content-Type: application/json' , ] ; if ( $ type == self :: TYPE_GET ) { $ url .= '?' . http_build_query ( $ body ) ; } $ curl = curl_init ( $ this -> url . $ url ) ; if ( $ type == self :: TYPE_POST ) { curl_setopt ( $ curl , CURLOPT_POST , 1 ) ; curl_setopt ( $ curl , CURLOPT_POSTFIELDS , http_build_query ( $ body ) ) ; } curl_setopt ( $ curl , CURLOPT_HTTPHEADER , $ headers ) ; curl_setopt ( $ curl , CURLOPT_SSL_VERIFYPEER , false ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; $ response = curl_exec ( $ curl ) ; curl_close ( $ curl ) ; return json_decode ( $ response , true ) ; }
1880	protected function isMounted ( $ strFolder ) { if ( $ strFolder == '' ) { return false ; } if ( empty ( $ this -> arrFilemounts ) ) { return true ; } $ path = $ strFolder ; while ( \ is_array ( $ this -> arrFilemounts ) && substr_count ( $ path , '/' ) > 0 ) { if ( \ in_array ( $ path , $ this -> arrFilemounts ) ) { return true ; } $ path = \ dirname ( $ path ) ; } return false ; }
1643	public function getCenter ( ) : Coordinate { $ centerLat = ( $ this -> getNorth ( ) + $ this -> getSouth ( ) ) / 2 ; return new Coordinate ( $ centerLat , $ this -> getCenterLng ( ) ) ; }
11009	public function addPluginType ( string $ mediaType ) : bool { if ( ! preg_match ( '#^[-\w]+/[-\w]+$#ui' , $ mediaType ) ) { throw new MiddlewareException ( $ this , sprintf ( "'%s' is not a valid media type and can not be used as a CSP plugin type" , $ mediaType ) ) ; } if ( ! in_array ( $ mediaType , $ this -> tags [ 'plugin-types' ] ) ) { $ this -> tags [ 'plugin-types' ] [ ] = $ mediaType ; return true ; } return false ; }
3447	public function toArray ( ) { $ array = $ this -> fields ; foreach ( $ this -> appends as $ accessor ) { if ( isset ( $ this [ $ accessor ] ) ) { $ array [ $ accessor ] = $ this [ $ accessor ] ; } } foreach ( $ this -> related as $ key => $ value ) { if ( is_object ( $ value ) && method_exists ( $ value , 'toArray' ) ) { $ array [ $ key ] = $ value -> toArray ( ) ; } elseif ( is_null ( $ value ) || $ value === false ) { $ array [ $ key ] = $ value ; } } if ( count ( $ this -> getVisible ( ) ) > 0 ) { $ array = array_intersect_key ( $ array , array_flip ( $ this -> getVisible ( ) ) ) ; } if ( count ( $ this -> getHidden ( ) ) > 0 ) { $ array = array_diff_key ( $ array , array_flip ( $ this -> getHidden ( ) ) ) ; } return $ array ; }
9029	public function error ( Request $ request ) { $ this -> response -> setCode ( 404 ) ; printf ( "<h2>%s</h2>" , HttpStatus :: getStatus ( 404 ) ) ; printf ( "Requested document %s on %s could not be found!" , $ request -> getAction ( ) , $ request -> getController ( ) ) ; }
12517	public static function move ( $ src , $ dest , $ overwrite = false ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; if ( ! Folder :: exists ( $ src ) ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' : ' . $ src ) ; } if ( Folder :: exists ( $ dest ) ) { throw new Exception ( Helper :: getTranslation ( 'ALREADY_EXISTS' ) . ' : ' . $ dest ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> rename ( $ src , $ dest , $ overwrite ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_RENAMING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
8353	private function shutdown ( $ signal = 9 ) { foreach ( $ this -> dispatcher -> getProcesses ( ) as $ pid => $ process ) { $ this -> logger -> debug ( 'Sending signal to process' , [ 'signal' => $ signal , 'pid' => $ pid , 'jobId' => $ process [ 'id' ] , 'queue' => $ this -> queue -> getName ( ) ] ) ; \ posix_kill ( $ pid , $ signal ) ; if ( $ signal !== 9 ) { if ( $ this -> config [ 'deadline_timeout' ] !== null ) { Loop :: delay ( ( ( int ) $ this -> config [ 'deadline_timeout' ] * 1000 ) , function ( $ watcherId , $ callback ) use ( $ process , $ pid ) { if ( $ process [ 'process' ] -> isRunning ( ) ) { $ this -> logger -> info ( 'Process has exceeded deadline timeout. Killing' , [ 'pid' => $ pid , 'jobId' => $ process [ 'id' ] , 'queue' => $ this -> queue -> getName ( ) ] ) ; \ posix_kill ( $ pid , SIGKILL ) ; } } ) ; } } } }
1312	public function setTimeouts ( $ connectionTimeout , $ timeout ) { $ this -> connectionTimeout = ( int ) $ connectionTimeout ; $ this -> timeout = ( int ) $ timeout ; }
8684	public static function fromRecursive ( $ iterable ) { $ arr = static :: from ( $ iterable ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof \ stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return $ arr ; }
3496	private function doSend ( Receiver $ receiver , Notification $ notification , bool $ sandbox ) : void { $ payloadEncoded = $ this -> payloadEncoder -> encode ( $ notification -> getPayload ( ) ) ; $ uri = $ this -> uriFactory -> create ( $ receiver -> getToken ( ) , $ sandbox ) ; $ request = new Request ( $ uri , $ payloadEncoded ) ; $ headers = [ 'content-type' => 'application/json' , 'accept' => 'application/json' , 'apns-topic' => $ receiver -> getTopic ( ) , ] ; $ request = $ request -> withHeaders ( $ headers ) ; $ request = $ this -> authenticator -> authenticate ( $ request ) ; $ request = $ this -> visitor -> visit ( $ notification , $ request ) ; $ response = $ this -> httpSender -> send ( $ request ) ; if ( $ response -> getStatusCode ( ) !== 200 ) { throw $ this -> exceptionFactory -> create ( $ response ) ; } }
1244	public static function memoize ( callable $ provider ) { return function ( ) use ( $ provider ) { static $ result ; static $ isConstant ; if ( $ isConstant ) { return $ result ; } $ isConstant = true ; return $ result = $ provider ( ) ; } ; }
12864	public function postDispatch ( Zend_Controller_Request_Abstract $ request ) { $ methods = implode ( ', ' , array_unique ( $ this -> _methods ) ) ; $ headers = implode ( ', ' , array_unique ( $ this -> _headers ) ) ; if ( $ this -> _credentials ) { header ( 'Access-Control-Allow-Credentials: true' , true ) ; } header ( "Access-Control-Allow-Origin: {$this->_origin}" , true ) ; header ( "Access-Control-Allow-Methods: {$methods}" , true ) ; header ( "Access-Control-Allow-Headers: {$headers}" , true ) ; header ( "Access-Control-Max-Age: {$this->_maxAge}" , true ) ; header ( 'X-XSS-Protection: 1; mode=block' , true ) ; header ( 'X-Frame-Options: SAMEORIGIN' , true ) ; }
11782	protected function generateSourceFromChildren ( ) { $ i = 1 ; $ children = array ( ) ; foreach ( $ this -> children as $ child ) { $ childValue = Yaml :: parse ( $ child -> getSource ( ) ) ; if ( is_array ( $ childValue ) && array_key_exists ( "type" , $ childValue ) ) { $ childValue [ "type" ] = $ child -> getType ( ) ; } $ children [ 'item' . $ i ] = $ childValue ; $ i ++ ; } $ source = array ( "children" => $ children , ) ; if ( ! empty ( $ this -> tags ) ) { $ source [ "tags" ] = $ this -> tags ; } $ source [ "type" ] = $ this -> type ; return $ source ; }
7683	function Ext_GetMainIdx ( ) { if ( ( $ this -> ExtInfo !== false ) && isset ( $ this -> ExtInfo [ 'main' ] ) ) { return $ this -> FileGetIdx ( $ this -> ExtInfo [ 'main' ] ) ; } else { return false ; } }
5427	public function getInterfaces ( ) { $ reflection = new ReflectionClass ( $ this -> interface ) ; if ( $ reflection -> isInterface ( ) ) { return array ( $ this -> interface ) ; } return $ this -> onlyParents ( $ reflection -> getInterfaces ( ) ) ; }
2476	private function logWarning ( OutputInterface $ output , ProgressBar $ progress , $ message ) { $ progress -> clear ( ) ; $ this -> logger -> warning ( $ message ) ; $ progress -> display ( ) ; }
9111	protected function getConfig ( ) { $ config = $ this -> getServiceLocator ( ) -> get ( 'config' ) ; if ( isset ( $ config [ 'yima-theme' ] ) && is_array ( $ config [ 'yima-theme' ] ) ) { $ config = $ config [ 'yima-theme' ] ; } else { $ config = array ( ) ; } return $ config ; }
9090	function isMultipart ( ) { foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getType ( ) == 'file' || $ field -> getValueType ( ) == 'file' || $ field -> getDataType ( ) ) { return true ; } } return false ; }
9046	public function registerType ( $ type , $ classname , $ options = array ( ) ) { if ( ! class_exists ( $ classname ) || ! is_callable ( array ( $ classname , 'getDataType' ) ) ) { return ; } $ data_type = call_user_func ( array ( $ classname , 'getDataType' ) ) ; $ options = ( array ) $ options ; $ options [ 'type' ] = $ type ; $ options [ 'class_name' ] = $ classname ; $ options [ 'data_type' ] = $ data_type ; $ this -> types [ $ data_type ] [ $ type ] = $ options ; }
10925	private function renderRow ( array $ row ) { $ output = [ ] ; $ output [ ] = $ this -> charVertical ; $ columnNumber = 0 ; foreach ( $ row as $ column => $ value ) { $ output [ ] = $ this -> renderCell ( $ columnNumber , $ value , ' ' ) ; $ output [ ] = $ this -> charVertical ; $ columnNumber ++ ; } return implode ( '' , $ output ) ; }
5671	protected function describeStringDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } $ position = $ this -> stringDiffersAt ( $ first , $ second ) ; return sprintf ( 'at character %s with [%s] and [%s]' , $ position , $ this -> clipString ( $ first , 200 , $ position ) , $ this -> clipString ( $ second , 200 , $ position ) ) ; }
12371	public function addItem ( array $ item ) : self { if ( count ( $ item ) < 2 ) { throw new Exception ( 'Invalid count of item elements.' ) ; } $ this -> items [ ] = $ item ; return $ this ; }
11521	public function off ( $ eventType , $ listener = null ) { foreach ( $ this -> _eventListeners as $ i => $ l ) { if ( $ l -> getType ( ) == $ eventType ) { if ( $ listener === null || $ l -> getListener ( ) === $ listener ) { unset ( $ this -> _eventListeners [ $ i ] ) ; } } } }
3713	public function isNestedType ( ) { if ( ! isset ( $ this -> isNestedType ) ) { $ this -> isNestedType = in_array ( 'MetaModels\Filter\Setting\IWithChildren' , class_implements ( $ this -> typeClass , true ) ) ; } return $ this -> isNestedType ; }
7755	private function doDeserialize ( $ data , $ entity ) { $ metadata = $ this -> hydraApi -> getMetadataFor ( get_class ( $ entity ) ) ; if ( null === $ metadata ) { throw new \ Exception ( sprintf ( '"%s" cannot be serialized as it is not documented.' , get_class ( $ data ) ) ) ; } $ vocabPrefix = $ this -> router -> generate ( 'hydra_vocab' , array ( ) , true ) . '#' ; $ typeIri = ( $ metadata -> isExternalReference ( ) ) ? $ metadata -> getIri ( ) : $ vocabPrefix . $ metadata -> getIri ( ) ; $ graph = JsonLD :: getDocument ( $ data ) -> getGraph ( ) ; $ node = $ graph -> getNodesByType ( $ typeIri ) ; if ( 1 !== count ( $ node ) ) { throw new RuntimeException ( 'The passed data contains ' . count ( $ node ) . ' nodes of the type ' . $ typeIri . '; expected 1.' ) ; } $ node = reset ( $ node ) ; foreach ( $ metadata -> getProperties ( ) as $ property ) { if ( $ property -> isReadOnly ( ) ) { continue ; } if ( null !== ( $ route = $ property -> getRoute ( ) ) ) { continue ; } $ propertyIri = ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : $ vocabPrefix . $ property -> getIri ( ) ; $ value = $ node -> getProperty ( $ propertyIri ) ; if ( $ value instanceof \ ML \ JsonLD \ Value ) { $ value = $ value -> getValue ( ) ; } if ( ! is_null ( $ value ) && $ this -> hydraApi -> hasNormalizer ( $ property -> getType ( ) ) ) { $ normalizer = $ this -> hydraApi -> getNormalizer ( $ property -> getType ( ) ) ; $ value = $ normalizer -> denormalize ( $ value , $ property -> getType ( ) ) ; } $ property -> setValue ( $ entity , $ value ) ; } return $ entity ; }
1943	public function onReplaceInsertTags ( string $ tag ) { $ chunks = explode ( '::' , $ tag ) ; if ( 'asset' !== $ chunks [ 0 ] ) { return false ; } $ url = $ this -> packages -> getUrl ( $ chunks [ 1 ] , $ chunks [ 2 ] ?? null ) ; return ltrim ( $ url , '/' ) ; }
3727	private function sanitizeConnection ( $ connection ) { if ( $ connection instanceof Connection ) { return $ connection ; } if ( $ connection instanceof Database ) { @ trigger_error ( '"' . __METHOD__ . '" now accepts doctrine instances - ' . 'passing Contao database instances is deprecated.' , E_USER_DEPRECATED ) ; $ reflection = new \ ReflectionProperty ( Database :: class , 'resConnection' ) ; $ reflection -> setAccessible ( true ) ; return $ reflection -> getValue ( $ connection ) ; } if ( null === $ connection ) { @ trigger_error ( 'You should pass a doctrine database connection to "' . __METHOD__ . '".' , E_USER_DEPRECATED ) ; $ connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; } if ( ! ( $ connection instanceof Connection ) ) { throw new \ RuntimeException ( 'Could not obtain doctrine connection.' ) ; } return $ connection ; }
4894	public function end ( ) { if ( ! $ this -> captureLock ) { throw new \ RuntimeException ( 'Cannot end capture, there is no capture running.' ) ; } $ type = $ this -> captureType ; $ content = ob_get_clean ( ) ; $ options = $ this -> captureOptions ; $ this -> captureLock = false ; $ this -> captureType = null ; $ this -> captureOptions = null ; return $ this -> render ( $ type , $ content , $ options ) ; }
1009	public static function defaultFieldResolver ( $ source , $ args , $ context , ResolveInfo $ info ) { $ fieldName = $ info -> fieldName ; $ property = null ; if ( is_array ( $ source ) || $ source instanceof ArrayAccess ) { if ( isset ( $ source [ $ fieldName ] ) ) { $ property = $ source [ $ fieldName ] ; } } elseif ( is_object ( $ source ) ) { if ( isset ( $ source -> { $ fieldName } ) ) { $ property = $ source -> { $ fieldName } ; } } return $ property instanceof Closure ? $ property ( $ source , $ args , $ context , $ info ) : $ property ; }
7960	public function canChangeDslamProfile ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canChangeDslamProfile ; }
11736	public function setAddress ( $ address ) { $ address = trim ( $ address , self :: SEPARATOR ) ; if ( ! filter_var ( $ address , FILTER_VALIDATE_URL ) ) { throw new \ InvalidArgumentException ( "$address is not valid format of url address." ) ; } $ this -> address = $ address ; $ this -> parse = parse_url ( $ address ) ; return $ this ; }
2163	public function run40Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `scripts` text NULL" ) ; $ objLayout = $ this -> Database -> query ( "SELECT id, addJQuery, jquery, addMooTools, mootools FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrScripts = array ( ) ; if ( $ objLayout -> addJQuery ) { $ jquery = StringUtil :: deserialize ( $ objLayout -> jquery ) ; if ( ! empty ( $ jquery ) && \ is_array ( $ jquery ) ) { if ( ( $ key = array_search ( 'j_slider' , $ jquery ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ jquery [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET jquery=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ jquery ) ) , $ objLayout -> id ) ; } } } if ( $ objLayout -> addMooTools ) { $ mootools = StringUtil :: deserialize ( $ objLayout -> mootools ) ; if ( ! empty ( $ mootools ) && \ is_array ( $ mootools ) ) { if ( ( $ key = array_search ( 'moo_slider' , $ mootools ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ mootools [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET mootools=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ mootools ) ) , $ objLayout -> id ) ; } } } if ( ! empty ( $ arrScripts ) ) { $ this -> Database -> prepare ( "UPDATE tl_layout SET scripts=? WHERE id=?" ) -> execute ( serialize ( array_values ( array_unique ( $ arrScripts ) ) ) , $ objLayout -> id ) ; } } }
10625	protected function beforeBuild ( ) { $ this -> type = 'CREATE' ; if ( $ this -> temporary ) { $ this -> type .= ' TEMPORARY' ; } $ this -> type .= ' TABLE' ; if ( $ this -> if_not_exists ) { $ this -> type .= ' IF NOT EXISTS' ; } $ this -> type .= ' ' . $ this -> quote ( $ this -> tbl_name ) ; return ; }
4979	public function get ( $ form , $ options = null , $ params = null ) { if ( ! is_object ( $ form ) ) { $ form = $ this -> formElementManager -> get ( $ form , $ options ) ; } $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; $ hydrator = $ form -> getHydrator ( ) ; $ data = $ hydrator -> extract ( $ params ) ; $ form -> setData ( $ data ) ; $ hydrator -> hydrate ( $ data , $ params ) ; return $ form ; }
4026	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> scopeMatcher -> currentScopeIsBackend ( ) ) { return ; } $ model = $ event -> getModel ( ) ; if ( ( $ model -> getProviderName ( ) !== 'tl_metamodel_filtersetting' ) || ! in_array ( $ event -> getModel ( ) -> getProperty ( 'type' ) , $ this -> getTypes ( ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ event -> setLabel ( $ this -> getLabelPattern ( $ environment , $ model ) ) -> setArgs ( $ this -> getLabelParameters ( $ environment , $ model ) ) ; }
4690	public function addGroupBy ( $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group [ ] = $ expression ; $ this -> pushArgs ( 'group' , $ args ) ; return $ this ; }
375	public function getActionArgsHelp ( $ action ) { $ method = $ this -> getActionMethodReflection ( $ action ) ; $ tags = $ this -> parseDocCommentTags ( $ method ) ; $ params = isset ( $ tags [ 'param' ] ) ? ( array ) $ tags [ 'param' ] : [ ] ; $ args = [ ] ; foreach ( $ method -> getParameters ( ) as $ i => $ reflection ) { if ( $ reflection -> getClass ( ) !== null ) { continue ; } $ name = $ reflection -> getName ( ) ; $ tag = isset ( $ params [ $ i ] ) ? $ params [ $ i ] : '' ; if ( preg_match ( '/^(\S+)\s+(\$\w+\s+)?(.*)/s' , $ tag , $ matches ) ) { $ type = $ matches [ 1 ] ; $ comment = $ matches [ 3 ] ; } else { $ type = null ; $ comment = $ tag ; } if ( $ reflection -> isDefaultValueAvailable ( ) ) { $ args [ $ name ] = [ 'required' => false , 'type' => $ type , 'default' => $ reflection -> getDefaultValue ( ) , 'comment' => $ comment , ] ; } else { $ args [ $ name ] = [ 'required' => true , 'type' => $ type , 'default' => null , 'comment' => $ comment , ] ; } } return $ args ; }
385	public function getOrders ( $ recalculate = false ) { $ attributeOrders = $ this -> getAttributeOrders ( $ recalculate ) ; $ orders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ direction ) { $ definition = $ this -> attributes [ $ attribute ] ; $ columns = $ definition [ $ direction === SORT_ASC ? 'asc' : 'desc' ] ; if ( is_array ( $ columns ) || $ columns instanceof \ Traversable ) { foreach ( $ columns as $ name => $ dir ) { $ orders [ $ name ] = $ dir ; } } else { $ orders [ ] = $ columns ; } } return $ orders ; }
3581	protected function pluckMeta ( Builder $ query , ArgumentBag $ args , $ alias ) { list ( $ column , $ key ) = [ $ args -> get ( 'column' ) , $ args -> get ( 'key' ) ] ; $ query -> select ( "{$alias}.meta_value as {$column}" ) ; if ( ! is_null ( $ key ) ) { $ this -> metaSelectListsKey ( $ query , $ key ) ; } return $ query -> callParent ( 'pluck' , $ args -> all ( ) ) ; }
3265	protected function preserveLines ( $ data , bool $ reverse ) { $ search = [ "\n" , "\r" ] ; $ replace = [ '\\n' , '\\r' ] ; if ( $ reverse ) { $ search = [ '\\n' , '\\r' ] ; $ replace = [ "\n" , "\r" ] ; } if ( is_string ( $ data ) ) { $ data = str_replace ( $ search , $ replace , $ data ) ; } elseif ( is_array ( $ data ) ) { foreach ( $ data as & $ value ) { $ value = $ this -> preserveLines ( $ value , $ reverse ) ; } unset ( $ value ) ; } return $ data ; }
5899	public function listFunctionalities ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/functionalities' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Functionality ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5580	public function submitFormById ( $ id , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormById ( $ id ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submit ( $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
6900	public function close ( ) : void { if ( $ this -> is_active ( ) ) { $ this -> _data [ 'last_active' ] = time ( ) ; config ( 'debug' ) ? session_write_close ( ) : @ session_write_close ( ) ; } }
8886	private function parseResult ( ) { if ( $ this -> xml_result -> Response -> ResponseStatusCode != '1' ) { return array ( 'Error' => array ( 'ErrorSeverity' => "{$this->xml_result->Response->Error->ErrorSeverity}" , 'ErrorCode' => "{$this->xml_result->Response->Error->ErrorCode}" , 'ErrorDescription' => "{$this->xml_result->Response->Error->ErrorDescription}" ) ) ; return $ this -> xml_result ; } $ simplified = array ( ) ; $ shipping_choices = array ( ) ; foreach ( $ this -> xml_result -> RatedShipment as $ service ) { $ simplified [ ] = '{' . $ service -> TotalCharges -> MonetaryValue . '}' ; } foreach ( $ simplified as $ key => $ value ) { $ service = $ this -> xml_result -> RatedShipment [ $ key ] -> children ( ) ; if ( $ this -> negotiated_rates && $ service -> NegotiatedRates -> NetSummaryCharges -> GrandTotal -> MonetaryValue ) { $ rate = number_format ( ( double ) ( $ service -> NegotiatedRates -> NetSummaryCharges -> GrandTotal -> MonetaryValue ) , 2 ) ; } else { $ rate = number_format ( ( double ) ( $ service -> TransportationCharges -> MonetaryValue ) , 2 ) ; } $ shipping_choices [ "{$service->Service->Code}" ] = array ( 'service' => $ this -> shipperCodes ( "{$service->Service->Code}" ) , 'rate' => "{$rate}" ) ; } return $ shipping_choices ; }
7896	public function from ( $ provider = null ) { $ provider = $ provider ? : $ this -> getDefaultProvider ( ) ; return new Uploader ( $ this -> app -> make ( 'config' ) , $ this -> app -> make ( 'filesystem' ) , $ this -> createProviderInstance ( $ provider ) ) ; }
597	public function one ( $ db = null ) { $ row = parent :: one ( $ db ) ; if ( $ row !== false ) { $ models = $ this -> populate ( [ $ row ] ) ; return reset ( $ models ) ? : null ; } return null ; }
6994	public function prePersist ( UploadableInterface $ uploadable ) { if ( ! $ this -> enabled ) { return ; } $ uploadable -> setCreatedAt ( new \ DateTime ( ) ) -> setUpdatedAt ( new \ DateTime ( ) ) ; $ this -> uploader -> prepare ( $ uploadable ) ; }
11314	public static function getNormalizedUrl ( Url $ url ) { $ scheme = $ url -> getScheme ( ) ; $ host = $ url -> getHost ( ) ; $ port = $ url -> getPort ( ) ; $ path = $ url -> getPath ( ) ; if ( ( ( $ port == 80 || empty ( $ port ) ) && strcasecmp ( $ scheme , 'http' ) == 0 ) || ( ( $ port == 443 || empty ( $ port ) ) && strcasecmp ( $ scheme , 'https' ) == 0 ) ) { $ normalizedUrl = $ scheme . '://' . $ host . $ path ; } else { if ( ! empty ( $ port ) ) { $ normalizedUrl = $ scheme . '://' . $ host . ':' . $ port . $ path ; } else { throw new RuntimeException ( 'No port specified' ) ; } } return strtolower ( $ normalizedUrl ) ; }
5507	public function returnsByValue ( $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return value' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleByValue ( $ value ) ) ; }
4464	public function childPerform ( BaseJob $ job ) : void { $ loggerContext = [ 'job' => $ job -> jid , 'type' => $ this -> who ] ; try { if ( $ this -> jobPerformHandler ) { if ( $ this -> jobPerformHandler instanceof EventsManagerAwareInterface ) { $ this -> jobPerformHandler -> setEventsManager ( $ this -> client -> getEventsManager ( ) ) ; } if ( method_exists ( $ this -> jobPerformHandler , 'setUp' ) ) { $ this -> jobPerformHandler -> setUp ( ) ; } $ this -> getEventsManager ( ) -> fire ( new JobEvent \ BeforePerform ( $ this -> jobPerformHandler , $ job ) ) ; $ this -> jobPerformHandler -> perform ( $ job ) ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ AfterPerform ( $ this -> jobPerformHandler , $ job ) ) ; if ( method_exists ( $ this -> jobPerformHandler , 'tearDown' ) ) { $ this -> jobPerformHandler -> tearDown ( ) ; } } else { $ job -> perform ( ) ; } $ this -> logger -> notice ( '{type}: job {job} has finished' , $ loggerContext ) ; } catch ( \ Throwable $ e ) { $ loggerContext [ 'stack' ] = $ e -> getMessage ( ) ; $ this -> logger -> critical ( '{type}: job {job} has failed {stack}' , $ loggerContext ) ; $ job -> fail ( 'system:fatal' , sprintf ( '%s: %s in %s on line %d' , get_class ( $ e ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) ) ) ; } }
11524	public function parseBotUA ( $ botName ) { $ dom = $ this -> getDom ( 'https://udger.com/resources/ua-list/bot-detail?bot=' . $ botName ) ; if ( false === $ dom ) { echo "Can not parse DOM" . PHP_EOL ; return false ; } $ this -> currentBotName = $ botName ; $ crawlerBot = new Crawler ( ) ; $ crawlerBot -> addContent ( $ dom ) ; $ crawlerBot -> filter ( 'body #container table tr td > a' ) -> each ( function ( $ el , $ i ) { if ( strpos ( $ el -> attr ( 'href' ) , '/resources/online-parser' ) !== false ) { $ botUA = $ el -> text ( ) ; $ this -> addBotUA ( $ botUA ) ; } } ) ; return true ; }
11632	private function groupPvTrans ( $ transData ) { $ result = [ ] ; foreach ( $ transData as $ one ) { $ debitAccId = $ one -> get ( DTrans :: A_ACC_ID_DEBIT ) ; $ creditAccId = $ one -> get ( DTrans :: A_ACC_ID_CREDIT ) ; $ value = $ one -> get ( DTrans :: A_AMOUNT ) ; if ( isset ( $ result [ $ debitAccId ] ) ) { $ result [ $ debitAccId ] -= $ value ; } else { $ result [ $ debitAccId ] = - $ value ; } if ( isset ( $ result [ $ creditAccId ] ) ) { $ result [ $ creditAccId ] += $ value ; } else { $ result [ $ creditAccId ] = $ value ; } } return $ result ; }
9407	protected function callback ( $ middleware , ResponseInterface $ response ) { $ middleware = is_string ( $ middleware ) ? new $ middleware : $ middleware ; $ callback = function ( $ request , $ next = null ) use ( $ middleware ) { return $ middleware ( $ request , $ next ) ; } ; if ( $ this -> approach ( $ middleware ) == self :: SINGLE_PASS ) { $ callback = function ( $ request , $ next = null ) use ( $ middleware , $ response ) { return $ middleware ( $ request , $ response , $ next ) ; } ; } return $ callback ; }
3113	public function setStoreId ( $ testSessionId , $ storeId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setStoreId ( $ storeId ) ; $ extendedState -> save ( ) ; }
1694	public function exportStyleSheet ( DataContainer $ dc ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objStyleSheet -> numRows < 1 ) { throw new \ Exception ( "Invalid style sheet ID {$dc->id}" ) ; } $ vars = array ( ) ; $ objTheme = $ this -> Database -> prepare ( "SELECT vars FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ objStyleSheet -> pid ) ; if ( $ objTheme -> vars != '' ) { if ( \ is_array ( ( $ tmp = StringUtil :: deserialize ( $ objTheme -> vars ) ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } if ( $ objStyleSheet -> vars != '' ) { if ( \ is_array ( ( $ tmp = StringUtil :: deserialize ( $ objStyleSheet -> vars ) ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } uksort ( $ vars , 'length_sort_desc' ) ; $ objFile = new File ( 'system/tmp/' . md5 ( uniqid ( mt_rand ( ) , true ) ) ) ; $ objFile -> write ( '' ) ; if ( $ objStyleSheet -> mediaQuery != '' ) { $ objFile -> append ( '@media ' . $ objStyleSheet -> mediaQuery . ' {' ) ; } $ objDefinitions = $ this -> Database -> prepare ( "SELECT * FROM tl_style WHERE pid=? AND invisible!='1' ORDER BY sorting" ) -> execute ( $ objStyleSheet -> id ) ; while ( $ objDefinitions -> next ( ) ) { $ objFile -> append ( $ this -> compileDefinition ( $ objDefinitions -> row ( ) , false , $ vars , $ objStyleSheet -> row ( ) , true ) , '' ) ; } if ( $ objStyleSheet -> mediaQuery != '' ) { $ objFile -> append ( '}' ) ; } $ objFile -> close ( ) ; $ objFile -> sendToBrowser ( $ objStyleSheet -> name . '.css' ) ; $ objFile -> delete ( ) ; }
312	public function run ( ) { try { $ this -> state = self :: STATE_BEFORE_REQUEST ; $ this -> trigger ( self :: EVENT_BEFORE_REQUEST ) ; $ this -> state = self :: STATE_HANDLING_REQUEST ; $ response = $ this -> handleRequest ( $ this -> getRequest ( ) ) ; $ this -> state = self :: STATE_AFTER_REQUEST ; $ this -> trigger ( self :: EVENT_AFTER_REQUEST ) ; $ this -> state = self :: STATE_SENDING_RESPONSE ; $ response -> send ( ) ; $ this -> state = self :: STATE_END ; return $ response -> exitStatus ; } catch ( ExitException $ e ) { $ this -> end ( $ e -> statusCode , isset ( $ response ) ? $ response : null ) ; return $ e -> statusCode ; } }
12738	public function addClass ( $ name ) { $ classParts = explode ( ' ' , $ this -> tags [ 'class' ] ) ; foreach ( $ classParts as $ part ) { if ( $ name == $ part ) return ; } $ this -> tags [ 'class' ] .= ' ' . $ name ; $ this -> tags [ 'class' ] = trim ( $ this -> tags [ 'class' ] ) ; }
6765	protected function handleUpdate ( SaleInterface $ sale ) { $ changed = false ; $ changed |= $ this -> updateNumber ( $ sale ) ; $ changed |= $ this -> updateKey ( $ sale ) ; $ changed |= $ this -> updateInformation ( $ sale , true ) ; if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'vatNumber' ) ) { $ changed |= $ this -> pricingUpdater -> updateVatNumberSubject ( $ sale ) ; } if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'customer' ) ) { $ changed |= $ this -> saleUpdater -> updatePaymentTerm ( $ sale ) ; } if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'shipmentMethod' , 'customerGroup' ] ) ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; } if ( $ this -> isDiscountUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateDiscounts ( $ sale , true ) ; } if ( $ this -> isTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateTaxation ( $ sale , true ) ; } elseif ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } return $ changed ; }
11681	public function read ( $ id ) { $ path = $ this -> getPath ( $ id ) ; if ( ! file_exists ( $ path ) ) { return '' ; } if ( filemtime ( $ path ) < time ( ) - $ this -> lifeTime ) { return '' ; } return file_get_contents ( $ path ) ; }
1103	protected function fireMoveEvent ( $ event , $ halt = true ) { if ( ! isset ( static :: $ dispatcher ) ) return true ; $ event = "eloquent.{$event}: " . get_class ( $ this -> node ) ; $ method = $ halt ? 'until' : 'fire' ; return static :: $ dispatcher -> $ method ( $ event , $ this -> node ) ; }
3287	public function plugin ( $ name , array $ options = null ) { $ helper = $ this -> getTwigHelpers ( ) -> setRenderer ( $ this ) ; if ( $ helper -> has ( $ name ) ) { return $ helper -> get ( $ name , $ options ) ; } return $ this -> getHelperPluginManager ( ) -> get ( $ name , $ options ) ; }
4215	private static function keys ( $ val ) { if ( Abstracter :: isAbstraction ( $ val ) ) { if ( $ val [ 'type' ] == 'object' ) { if ( $ val [ 'traverseValues' ] ) { $ val = $ val [ 'traverseValues' ] ; } elseif ( $ val [ 'stringified' ] ) { $ val = null ; } elseif ( isset ( $ val [ 'methods' ] [ '__toString' ] [ 'returnValue' ] ) ) { $ val = null ; } else { $ val = \ array_filter ( $ val [ 'properties' ] , function ( $ prop ) { return $ prop [ 'visibility' ] === 'public' ; } ) ; \ ksort ( $ val , SORT_NATURAL | SORT_FLAG_CASE ) ; } } else { $ val = null ; } } return \ is_array ( $ val ) ? \ array_keys ( $ val ) : array ( self :: SCALAR ) ; }
1394	public function withMediaType ( string $ mediaType ) : self { if ( ! $ encoding = $ this -> api -> getEncodings ( ) -> find ( $ mediaType ) ) { throw new \ InvalidArgumentException ( "Media type {$mediaType} is not valid for API {$this->api->getName()}." ) ; } $ codec = $ this -> factory -> createCodec ( $ this -> api -> getContainer ( ) , $ encoding , null ) ; return $ this -> withCodec ( $ codec ) ; }
5898	public function retrieveVideoTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/videos/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new VideoTemplate ( $ result ) ; return $ result ; }
1341	public function find ( ResourceIdentifierInterface $ identifier ) { $ record = $ this -> lookup ( $ identifier ) ; if ( false === $ record ) { return false ; } return is_object ( $ record ) ? $ record : null ; }
1758	public static function getFormattedNumber ( $ varNumber , $ intDecimals = 2 ) { return number_format ( round ( $ varNumber , $ intDecimals ) , $ intDecimals , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'decimalSeparator' ] , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'thousandsSeparator' ] ) ; }
1614	private function sendCommandInternal ( $ command , $ params ) { $ written = @ fwrite ( $ this -> _socket , $ command ) ; if ( $ written === false ) { throw new SocketException ( "Failed to write to socket.\nRedis command was: " . $ command ) ; } if ( $ written !== ( $ len = mb_strlen ( $ command , '8bit' ) ) ) { throw new SocketException ( "Failed to write to socket. $written of $len bytes written.\nRedis command was: " . $ command ) ; } return $ this -> parseResponse ( implode ( ' ' , $ params ) ) ; }
7412	protected function customChmod ( string $ target , $ mode = 0666 ) { if ( false === @ chmod ( $ target , $ mode & ~ umask ( ) ) ) { throw new FileException ( sprintf ( 'Unable to change mode of the "%s"' , $ target ) ) ; } }
11071	public function setInteger ( string $ key , $ value , int $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( int ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
3584	protected function metaHasQuery ( Builder $ query , $ method , ArgumentBag $ args ) { $ boolean = $ this -> getMetaBoolean ( $ args ) ; $ operator = $ this -> getMetaOperator ( $ method , $ args ) ; if ( in_array ( $ method , [ 'whereBetween' , 'where' ] ) ) { $ this -> unbindNumerics ( $ args ) ; } return $ query -> has ( 'metaAttributes' , $ operator , 1 , $ boolean , $ this -> getMetaWhereConstraint ( $ method , $ args ) ) -> with ( 'metaAttributes' ) ; }
12000	static protected function doctrineQuery ( $ tableName , $ field , $ generate ) { return \ Doctrine_Query :: create ( ) -> select ( $ field ) -> from ( $ tableName ) -> where ( "$field = ?" , $ generate ) -> execute ( array ( ) , \ Doctrine_Core :: HYDRATE_SINGLE_SCALAR ) ; }
948	public function api ( ) { $ apiClass = Config :: get ( 'shopify-app.api_class' ) ; $ api = new $ apiClass ( ) ; $ api -> setApiKey ( Config :: get ( 'shopify-app.api_key' ) ) ; $ api -> setApiSecret ( Config :: get ( 'shopify-app.api_secret' ) ) ; $ version = Config :: get ( 'shopify-app.api_version' ) ; if ( $ version !== null ) { $ api -> setVersion ( $ version ) ; } if ( Config :: get ( 'shopify-app.api_rate_limiting_enabled' ) === true ) { $ api -> enableRateLimiting ( Config :: get ( 'shopify-app.api_rate_limit_cycle' ) , Config :: get ( 'shopify-app.api_rate_limit_cycle_buffer' ) ) ; } return $ api ; }
5518	public function invoke ( $ method , $ args ) { $ method = strtolower ( $ method ) ; $ step = $ this -> getCallCount ( $ method ) ; $ this -> addCall ( $ method , $ args ) ; $ this -> checkExpectations ( $ method , $ args , $ step ) ; $ was = $ this -> disableEStrict ( ) ; try { $ result = $ this -> emulateCall ( $ method , $ args , $ step ) ; } catch ( Exception $ e ) { $ this -> restoreEStrict ( $ was ) ; throw $ e ; } $ this -> restoreEStrict ( $ was ) ; return $ result ; }
8887	private function checkDefaults ( $ options ) { if ( ! isset ( $ options [ 'request_option' ] ) ) { $ options [ 'request_option' ] = 'Shop' ; } if ( ! isset ( $ options [ 'from_country' ] ) ) { $ options [ 'from_country' ] = 'US' ; } if ( ! isset ( $ options [ 'to_country' ] ) ) { $ options [ 'to_country' ] = 'US' ; } if ( ! isset ( $ options [ 'service_type' ] ) ) { $ options [ 'service_type' ] = '03' ; } if ( ! isset ( $ options [ 'from_state' ] ) ) { $ options [ 'from_state' ] = '' ; } if ( ! isset ( $ options [ 'to_state' ] ) ) { $ options [ 'to_state' ] = '' ; } $ this -> commercial_rates = ( isset ( $ options [ 'commercial' ] ) && $ options [ 'commercial' ] ) ? true : false ; $ this -> negotiated_rates = ( isset ( $ options [ 'negotiated_rates' ] ) && $ options [ 'negotiated_rates' ] ) ? true : false ; return $ options ; }
2147	protected function sendNewsletter ( Email $ objEmail , Result $ objNewsletter , $ arrRecipient , $ text , $ html , $ css = null ) { $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ text , $ arrRecipient ) ; if ( ! $ objNewsletter -> sendText ) { if ( $ objNewsletter -> template == '' ) { $ objNewsletter -> template = 'mail_default' ; } $ objTemplate = new BackendTemplate ( $ objNewsletter -> template ) ; $ objTemplate -> setData ( $ objNewsletter -> row ( ) ) ; $ objTemplate -> title = $ objNewsletter -> subject ; $ objTemplate -> body = StringUtil :: parseSimpleTokens ( $ html , $ arrRecipient ) ; $ objTemplate -> charset = Config :: get ( 'characterSet' ) ; $ objTemplate -> recipient = $ arrRecipient [ 'email' ] ; $ objTemplate -> css = $ css ; $ objEmail -> html = $ objTemplate -> parse ( ) ; $ objEmail -> imageDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' ; } try { $ objEmail -> sendTo ( $ arrRecipient [ 'email' ] ) ; } catch ( \ Swift_RfcComplianceException $ e ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( $ objEmail -> hasFailures ( ) ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objEmail , $ objNewsletter , $ arrRecipient , $ text , $ html ) ; } } }
12008	public function getMessages ( $ domain = 'default' , $ locale = null ) { if ( $ locale === null ) { $ locale = $ this -> getLocale ( ) ; } if ( ! isset ( $ this -> messages [ $ domain ] [ $ locale ] ) ) { $ this -> loadMessages ( $ domain , $ locale ) ; } return $ this -> messages [ $ domain ] [ $ locale ] ; }
7540	function index ( $ count_all = true ) { if ( ! $ this -> parent ) { return - 1 ; } elseif ( $ count_all ) { return $ this -> parent -> findChild ( $ this ) ; } else { $ index = - 1 ; foreach ( array_keys ( $ this -> parent -> children ) as $ k ) { if ( ! $ this -> parent -> children [ $ k ] -> isTextOrComment ( ) ) { ++ $ index ; } if ( $ this -> parent -> children [ $ k ] === $ this ) { return $ index ; } } return - 1 ; } }
11049	function parse_info ( $ info ) { $ elements = explode ( ':' , $ info ) ; $ count = count ( $ elements ) ; if ( $ count > 4 ) { for ( $ i = 4 ; $ i < $ count ; ++ $ i ) { $ elements [ 3 ] .= ':' . $ elements [ $ i ] ; } } else { $ elements = array_pad ( $ elements , 4 , '' ) ; } return array ( $ elements [ 0 ] , $ elements [ 2 ] , $ elements [ 3 ] ) ; }
814	private function getNewLineIndex ( $ index , Tokens $ tokens ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; for ( $ index , $ count = \ count ( $ tokens ) ; $ index < $ count ; ++ $ index ) { if ( false !== strstr ( $ tokens [ $ index ] -> getContent ( ) , $ lineEnding ) ) { return $ index ; } } return $ index ; }
2983	protected function makePathRelative ( $ absolutePath ) { $ projectRootDir = dirname ( $ this -> getContainer ( ) -> getParameter ( 'kernel.root_dir' ) ) ; return str_replace ( $ projectRootDir . '/' , '' , realpath ( $ absolutePath ) ? : $ absolutePath ) ; }
314	public function getVendorPath ( ) { if ( $ this -> _vendorPath === null ) { $ this -> setVendorPath ( $ this -> getBasePath ( ) . DIRECTORY_SEPARATOR . 'vendor' ) ; } return $ this -> _vendorPath ; }
339	public function registerClientScript ( ) { $ id = $ this -> options [ 'id' ] ; $ options = Json :: htmlEncode ( $ this -> getClientOptions ( ) ) ; $ attributes = Json :: htmlEncode ( $ this -> attributes ) ; $ view = $ this -> getView ( ) ; ActiveFormAsset :: register ( $ view ) ; $ view -> registerJs ( "jQuery('#$id').yiiActiveForm($attributes, $options);" ) ; }
9921	private function findManyToManyRelations ( array $ models ) { for ( $ i = 0 ; $ i < sizeof ( $ models ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < sizeof ( $ models ) ; $ j ++ ) { $ model1 = $ models [ $ i ] ; $ model2 = $ models [ $ j ] ; if ( strcasecmp ( $ model1 -> getName ( ) , $ model2 -> getName ( ) ) < 0 ) { $ tableName = strtolower ( $ model1 -> getName ( ) ) . '_' . strtolower ( $ model2 -> getName ( ) ) ; } else { $ tableName = strtolower ( $ model2 -> getName ( ) ) . '_' . strtolower ( $ model1 -> getName ( ) ) ; } if ( $ this -> databaseRepository -> hasTable ( $ tableName ) ) { $ this -> defineManyToManyRelation ( $ model1 , $ model2 ) ; } } } }
11077	public function getHttpAdapter ( ) { if ( null === $ this -> httpAdapter ) { $ this -> httpAdapter = new Curl ( ) ; $ this -> httpAdapter -> setOptions ( array ( 'sslverifypeer' => false , ) ) ; } return $ this -> httpAdapter ; }
5014	public function logBootstrap ( BootstrapEvent $ event ) : void { $ this -> getLogger ( ) -> info ( sprintf ( $ this -> tmpl [ 'queue' ] , 'Start' , $ event -> getQueue ( ) -> getName ( ) ) ) ; $ this -> injectLoggerInObject ( $ event -> getWorker ( ) ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
8491	public static function getCpuCores ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT NumberOfLogicalProcessors FROM Win32_Processor" ) ; $ cores = 0 ; foreach ( $ object as $ obj ) { $ cores = $ obj -> NumberOfLogicalProcessors ; } return $ cores ; }
5788	public function runExecute ( bool $ alterBooleanArgs = false ) { if ( ! isset ( $ this -> sql ) ) { $ this -> setSql ( ) ; } if ( isset ( $ this -> primaryKeyName ) ) { return parent :: executeWithReturnField ( $ this -> primaryKeyName , $ alterBooleanArgs ) ; } else { return parent :: execute ( $ alterBooleanArgs ) ; } }
7168	public function updateTab ( $ tabLabel , array $ formInputs ) { $ tabExists = false ; foreach ( $ this -> getTabs ( ) as $ tabIndex => $ tabInfo ) { if ( array_get ( $ tabInfo , 'label' ) === $ tabLabel ) { $ this -> currentTab = $ tabIndex ; $ this -> currentInputsGroup = null ; if ( count ( ( array ) array_get ( $ tabInfo , 'groups' , [ ] ) ) === 1 && is_int ( array_keys ( $ tabInfo [ 'groups' ] ) [ 0 ] ) ) { $ this -> currentInputsGroup = array_keys ( $ tabInfo [ 'groups' ] ) [ 0 ] ; } $ tabExists = true ; break ; } } if ( ! $ tabExists ) { $ this -> newTab ( $ tabLabel ) ; } $ this -> setFormInputs ( $ formInputs ) ; $ this -> currentTab = null ; $ this -> currentInputsGroup = null ; return $ this ; }
904	public function isUnarySuccessorOperator ( $ index ) { static $ allowedPrevToken = [ ']' , [ T_STRING ] , [ T_VARIABLE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , ] ; $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_INC , T_DEC ] ) ) { return false ; } $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; return $ prevToken -> equalsAny ( $ allowedPrevToken ) ; }
12775	protected function read ( $ namespace ) { $ file = $ this -> adapter -> getFileName ( $ namespace ) ; if ( ! $ this -> fileSystem -> has ( $ file ) ) { return [ ] ; } return $ this -> adapter -> onRead ( $ this -> fileSystem -> read ( $ file ) ) ; }
3557	protected function setType ( $ value ) { $ this -> attributes [ 'meta_type' ] = $ this -> hasMutator ( $ value , 'setter' ) ? $ this -> getMutatedType ( $ value , 'setter' ) : $ this -> getValueType ( $ value ) ; }
4428	protected function getQuestion ( $ questionName , $ defaultValue = null , $ validator = null ) { $ questionName = $ defaultValue ? '<info>' . $ questionName . '</info> [<comment>' . $ defaultValue . '</comment>]: ' : '<info>' . $ questionName . '</info>: ' ; $ question = new Question ( $ questionName , $ defaultValue ) ; if ( $ validator !== null ) { $ question -> setValidator ( $ validator ) ; } return $ question ; }
7010	private function formatN ( & $ str ) { if ( strstr ( $ str , '%N' ) ) { $ wdn = $ this -> weekDayNum ( ) ; $ str = str_replace ( '%N' , $ wdn == 0 ? 7 : $ wdn , $ str ) ; } }
11868	public function destroy ( string $ sessionIdentifier ) : void { if ( ! isset ( self :: $ files [ $ sessionIdentifier ] ) ) { throw new SessionNotFoundException ( ) ; } unset ( self :: $ files [ $ sessionIdentifier ] ) ; }
6004	public function setCategories ( array $ categories ) { $ this -> categories = [ ] ; foreach ( $ categories as $ item ) { $ this -> addCategoryResponse ( $ item ) ; } return $ this ; }
5016	public function logJobStart ( ProcessJobEvent $ event ) : void { $ queue = $ event -> getQueue ( ) ; $ job = $ event -> getJob ( ) ; $ logger = $ this -> getLogger ( ) ; $ logger -> info ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue -> getName ( ) , 'START' , $ this -> formatJob ( $ job ) , '' ) ) ; $ this -> injectLoggerInObject ( $ job ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
430	public function getBasePath ( ) { if ( $ this -> _basePath === null ) { $ class = new \ ReflectionClass ( $ this ) ; $ this -> _basePath = dirname ( $ class -> getFileName ( ) ) ; } return $ this -> _basePath ; }
11732	protected function generateBlocks ( array $ blocks , $ blocksDir , $ targetDir ) { $ c = 1 ; $ generatedBlocks = array ( ) ; foreach ( $ blocks as $ block ) { $ blockName = 'block' . $ c ; $ fileName = sprintf ( '%s/%s.json' , $ blocksDir , $ blockName ) ; $ generatedBlocks [ ] = $ blockName ; $ value = $ block ; if ( is_array ( $ value ) ) { $ value = json_encode ( $ block ) ; } FilesystemTools :: writeFile ( $ fileName , $ value ) ; $ c ++ ; } $ slotDefinition = array ( 'next' => $ c , 'blocks' => $ generatedBlocks , 'revision' => 1 , ) ; FilesystemTools :: writeFile ( $ targetDir . '/slot.json' , json_encode ( $ slotDefinition ) ) ; }
5705	public function shouldDisplay ( ) { if ( $ this -> gridFieldRequest -> getRequest ( ) -> param ( 'ID' ) == 'new' ) { return false ; } return $ this -> gridFieldRequest -> record -> canCreate ( ) ; }
9001	public function column_user ( AbstractLog $ item ) { $ user = $ item -> get_user ( ) ; if ( empty ( $ user ) ) { echo '-' ; } else { echo $ user -> display_name ; } }
5050	public function trigger ( $ eventName , $ target = null , $ argv = [ ] ) { $ event = $ eventName instanceof EventInterface ? $ eventName : $ this -> getEvent ( $ eventName , $ target , $ argv ) ; return $ this -> triggerListeners ( $ event ) ; }
5880	protected static function accessProtectedProperty ( $ object , $ propertyName ) { $ className = get_class ( $ object ) ; if ( ! isset ( static :: $ reflectedClasses [ $ className ] ) ) { static :: $ reflectedClasses [ $ className ] = new \ ReflectionClass ( $ className ) ; } $ class = static :: $ reflectedClasses [ $ className ] ; $ property = $ class -> getProperty ( $ propertyName ) ; $ property -> setAccessible ( true ) ; return $ property -> getValue ( $ object ) ; }
12137	public function update ( QuestionRequest $ request , Question $ question ) { try { $ request = $ request -> all ( ) ; $ attributes [ 'title' ] = $ request [ 'title' ] ; $ attributes [ 'question' ] = $ request [ 'question' ] ; $ attributes [ 'category_id' ] = $ request [ 'category_id' ] ; $ question -> update ( $ attributes ) ; return redirect ( '/discussion/' . $ request [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/question/' . $ question -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
3401	public function getValue ( ApistMethod $ method , Crawler $ rootNode = null ) { if ( is_null ( $ rootNode ) ) { $ rootNode = $ method -> getCrawler ( ) ; } $ result = $ rootNode -> filter ( $ this -> selector ) ; return $ this -> applyResultCallbackChain ( $ result , $ method ) ; }
4119	public static function addType ( $ name , $ className ) { if ( isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeExists ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
6908	public function addCopy ( Recipient $ copy ) { if ( ! $ this -> copies -> contains ( $ copy ) ) { $ this -> copies -> add ( $ copy ) ; } return $ this ; }
10918	public function getUserEntity ( $ identity , $ credential ) { $ credential = $ this -> preProcessCredential ( $ credential ) ; $ userObject = NULL ; $ fields = $ this -> getOptions ( ) -> getAuthIdentityFields ( ) ; while ( ! is_object ( $ userObject ) && count ( $ fields ) > 0 ) { $ mode = array_shift ( $ fields ) ; switch ( $ mode ) { case 'username' : $ userObject = $ this -> getMapper ( ) -> findByUsername ( $ identity ) ; break ; case 'email' : $ userObject = $ this -> getMapper ( ) -> findByEmail ( $ identity ) ; break ; } } if ( ! $ userObject ) { return null ; } $ bcrypt = new Bcrypt ( ) ; $ bcrypt -> setCost ( $ this -> getOptions ( ) -> getPasswordCost ( ) ) ; if ( ! $ bcrypt -> verify ( $ credential , $ userObject -> getPassword ( ) ) ) { return null ; } return $ userObject ; }
11723	public function collectActivity ( PostActionEvent $ event ) { $ this -> activity [ ] = array ( 'action_name' => $ event -> getAction ( ) -> getName ( ) , 'group_name' => $ event -> getAction ( ) -> getGroup ( ) -> getName ( ) , 'service_name' => $ event -> getAction ( ) -> getGroup ( ) -> getService ( ) -> getName ( ) , 'execution_time' => round ( $ event -> getExecutionTime ( ) * 1000 , 2 ) , 'arguments' => $ event -> getArguments ( ) , 'extra_data' => $ event -> getExtraData ( ) , ) ; $ this -> totalExecutionTime += $ event -> getExecutionTime ( ) ; $ this -> totalCallCount += 1 ; }
630	public function insert ( $ table , $ columns ) { $ params = [ ] ; $ sql = $ this -> db -> getQueryBuilder ( ) -> insert ( $ table , $ columns , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
4699	public function errorInfo ( ) { static $ statusStrings = array ( \ ZipArchive :: ER_OK => 'No error' , \ ZipArchive :: ER_MULTIDISK => 'Multi-disk zip archives not supported' , \ ZipArchive :: ER_RENAME => 'Renaming temporary file failed' , \ ZipArchive :: ER_CLOSE => 'Closing zip archive failed' , \ ZipArchive :: ER_SEEK => 'Seek error' , \ ZipArchive :: ER_READ => 'Read error' , \ ZipArchive :: ER_WRITE => 'Write error' , \ ZipArchive :: ER_CRC => 'CRC error' , \ ZipArchive :: ER_ZIPCLOSED => 'Containing zip archive was closed' , \ ZipArchive :: ER_NOENT => 'No such file' , \ ZipArchive :: ER_EXISTS => 'File already exists' , \ ZipArchive :: ER_OPEN => 'Can\'t open file' , \ ZipArchive :: ER_TMPOPEN => 'Failure to create temporary file' , \ ZipArchive :: ER_ZLIB => 'Zlib error' , \ ZipArchive :: ER_MEMORY => 'Malloc failure' , \ ZipArchive :: ER_CHANGED => 'Entry has been changed' , \ ZipArchive :: ER_COMPNOTSUPP => 'Compression method not supported' , \ ZipArchive :: ER_EOF => 'Premature EOF' , \ ZipArchive :: ER_INVAL => 'Invalid argument' , \ ZipArchive :: ER_NOZIP => 'Not a zip archive' , \ ZipArchive :: ER_INTERNAL => 'Internal error' , \ ZipArchive :: ER_INCONS => 'Zip archive inconsistent' , \ ZipArchive :: ER_REMOVE => 'Can\'t remove file' , \ ZipArchive :: ER_DELETED => 'Entry has been deleted' , ) ; if ( isset ( $ statusStrings [ $ this -> ziparchive -> status ] ) ) { $ statusString = $ statusStrings [ $ this -> ziparchive -> status ] ; } else { $ statusString = 'Unknown status' ; } return $ statusString . '(' . $ this -> ziparchive -> status . ')' ; }
621	protected function splitCondition ( InCondition $ condition , & $ params ) { $ operator = $ condition -> getOperator ( ) ; $ values = $ condition -> getValues ( ) ; $ column = $ condition -> getColumn ( ) ; if ( $ values instanceof \ Traversable ) { $ values = iterator_to_array ( $ values ) ; } if ( ! is_array ( $ values ) ) { return null ; } $ maxParameters = 1000 ; $ count = count ( $ values ) ; if ( $ count <= $ maxParameters ) { return null ; } $ slices = [ ] ; for ( $ i = 0 ; $ i < $ count ; $ i += $ maxParameters ) { $ slices [ ] = $ this -> queryBuilder -> createConditionFromArray ( [ $ operator , $ column , array_slice ( $ values , $ i , $ maxParameters ) ] ) ; } array_unshift ( $ slices , ( $ operator === 'IN' ) ? 'OR' : 'AND' ) ; return $ this -> queryBuilder -> buildCondition ( $ slices , $ params ) ; }
2796	public function setAdapterOptionsFromString ( $ optionString ) { $ this -> adapterOptions = array_merge ( $ this -> adapterOptions , explode ( ' ' , $ optionString ) ) ; return $ this ; }
8405	public static function run ( ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'bootstrap doesn\'t seem to have been initialized' ) ; } foreach ( self :: $ namespaces as $ name => $ path ) { if ( is_readable ( $ path . DIRECTORY_SEPARATOR . 'init.php' ) === true ) { require $ path . DIRECTORY_SEPARATOR . 'init.php' ; } elseif ( stripos ( $ path , 'vendor' ) === false || stripos ( $ path , 'vendor' ) == strlen ( $ path ) - strlen ( 'vendor' ) ) { Logger :: get ( ) -> error ( 'namespace "' . $ name . '" doesn\'t have an init.php' ) ; } } if ( defined ( 'STRAY_IS_CLI' ) === true && constant ( 'STRAY_IS_CLI' ) === true ) { Console :: run ( ) ; } elseif ( defined ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_IS_HTTP' ) === true ) { if ( count ( self :: $ applications ) == 0 ) { throw new BadUse ( 'no application has been registered' ) ; } Http :: run ( ) ; } else { throw new BadUse ( 'unknown mode, not CLI_IS_CLI nor STRAY_IS_HTTP' ) ; } }
6204	public function onError ( $ type , $ message , $ file = null , $ line = null , $ context = null ) { if ( ini_get ( 'error_reporting' ) == 0 ) { return true ; } if ( isset ( $ this -> fatalErrors [ $ type ] ) ) { throw new Exception ( $ message ) ; } if ( $ this -> shouldNotifyError ( $ type , $ message , $ file , $ line , $ context ) ) { $ backtrace = debug_backtrace ( ) ; array_shift ( $ backtrace ) ; $ this -> airbrakeClient -> notifyOnError ( $ message , $ backtrace ) ; return true ; } return true ; }
7098	private function findStockUnits ( StockSubjectInterface $ subject ) { $ repository = $ this -> entityManager -> getRepository ( $ subject :: getStockUnitClass ( ) ) ; $ stockUnits = array_merge ( $ repository -> findNotClosedBySubject ( $ subject ) , $ repository -> findLatestClosedBySubject ( $ subject ) ) ; usort ( $ stockUnits , function ( StockUnitInterface $ a , StockUnitInterface $ b ) { if ( $ a -> getState ( ) === StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) !== StockUnitStates :: STATE_CLOSED ) { return 1 ; } if ( $ a -> getState ( ) !== StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) === StockUnitStates :: STATE_CLOSED ) { return - 1 ; } if ( $ a -> getState ( ) === StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) === StockUnitStates :: STATE_CLOSED ) { $ aDate = $ a -> getClosedAt ( ) -> getTimestamp ( ) ; $ bDate = $ b -> getClosedAt ( ) -> getTimestamp ( ) ; if ( $ aDate > $ bDate ) { return - 1 ; } if ( $ aDate < $ bDate ) { return 1 ; } } $ aDate = $ a -> getCreatedAt ( ) -> getTimestamp ( ) ; $ bDate = $ b -> getCreatedAt ( ) -> getTimestamp ( ) ; if ( $ aDate > $ bDate ) { return - 1 ; } if ( $ aDate < $ bDate ) { return 1 ; } return 0 ; } ) ; return $ stockUnits ; }
9414	public function variance ( ) { $ float_variance = pow ( $ this -> float_sigma , 2 ) ; if ( $ this -> int_precision ) { return round ( $ float_variance , $ this -> int_precision ) ; } return $ float_variance ; }
12373	private function applyRuleToField ( string $ fieldName , string $ ruleName , array $ options = [ ] ) : void { if ( ! isset ( $ this -> rules [ $ ruleName ] ) ) { throw new Exception ( 'Undefined rule name.' ) ; } $ func = $ this -> rules [ $ ruleName ] [ 0 ] ; if ( ! $ func ( $ fieldName , $ options ) ) { if ( isset ( $ this -> rules [ $ ruleName ] [ 1 ] ) ) { if ( is_callable ( $ this -> rules [ $ ruleName ] [ 1 ] ) ) { $ funcMsg = $ this -> rules [ $ ruleName ] [ 1 ] ; $ this -> addError ( $ funcMsg ( $ fieldName , $ options ) ) ; } else { $ this -> addError ( ( string ) $ this -> rules [ $ ruleName ] [ 1 ] ) ; } } else { $ this -> addDefaultError ( $ fieldName ) ; } } }
7061	private function setClasses ( array $ classes ) { if ( ! empty ( $ classes ) ) { $ this -> vars [ 'attr' ] [ 'class' ] = ' ' . trim ( implode ( ' ' , $ classes ) ) ; } else { unset ( $ this -> vars [ 'attr' ] [ 'class' ] ) ; } }
856	public function overrideAt ( $ index , $ token ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0, use offsetSet instead.' , E_USER_DEPRECATED ) ; self :: $ isLegacyMode = true ; $ this [ $ index ] -> override ( $ token ) ; $ this -> registerFoundToken ( $ token ) ; }
885	public static function getName ( $ value ) { if ( ! self :: has ( $ value ) ) { throw new \ InvalidArgumentException ( sprintf ( 'No custom token was found for "%s".' , $ value ) ) ; } $ tokens = self :: getMapById ( ) ; return 'CT::' . $ tokens [ $ value ] ; }
7260	protected function createPercentAdjustment ( Model \ AdjustmentInterface $ data , float $ base , string $ currency ) : Adjustment { $ this -> assertAdjustmentMode ( $ data , Model \ AdjustmentModes :: MODE_PERCENT ) ; $ rate = ( float ) $ data -> getAmount ( ) ; if ( $ data -> getType ( ) === Model \ AdjustmentTypes :: TYPE_TAXATION ) { $ amount = Money :: round ( $ base * ( 1 + $ rate / 100 ) , $ currency ) - Money :: round ( $ base , $ currency ) ; } else { $ amount = Money :: round ( $ base * $ rate / 100 , $ currency ) ; } return new Adjustment ( ( string ) $ data -> getDesignation ( ) , $ amount , $ rate ) ; }
3387	public function sendResetLinkEmail ( Request $ request ) { $ this -> validateEmail ( $ request ) ; $ user = $ this -> broker ( ) -> getUser ( $ request -> only ( 'email' ) ) ; if ( $ user && is_null ( $ user -> confirmed_at ) ) { session ( [ 'confirmation_user_id' => $ user -> getKey ( ) ] ) ; throw ValidationException :: withMessages ( [ 'confirmation' => [ __ ( 'confirmation::confirmation.not_confirmed_reset_password' , [ 'resend_link' => route ( 'auth.resend_confirmation' ) ] ) ] ] ) ; } $ response = $ this -> broker ( ) -> sendResetLink ( $ request -> only ( 'email' ) ) ; return $ response == Password :: RESET_LINK_SENT ? $ this -> sendResetLinkResponse ( $ response ) : $ this -> sendResetLinkFailedResponse ( $ request , $ response ) ; }
9035	public function persist ( TopicInterface $ thread ) { if ( $ thread -> getId ( ) > 0 ) { $ this -> update ( $ thread , null , null , new TopicHydrator ( ) ) ; } else { $ this -> insert ( $ thread , null , new TopicHydrator ( ) ) ; } return $ thread ; }
7928	public function unregisterNamespace ( $ ns ) { list ( $ ns ) = $ this -> fireEvent ( 'namespace.unregister' , [ $ ns ] ) ; unset ( $ this -> namespaces [ $ ns ] ) ; return $ this ; }
3225	function createFolder ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/create_folder" , array ( "root" => "auto" , "path" => $ path , ) ) ; if ( $ response -> statusCode === 403 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
12724	public function resetSelf ( ) { $ this -> where = '' ; $ this -> select = '*' ; $ this -> limit = 20 ; $ this -> offset = 0 ; $ this -> orderBy = array ( ) ; $ this -> groupBy = array ( ) ; $ this -> prepend = '' ; $ this -> listWordsField = null ; $ this -> alternativesField = null ; $ this -> join = null ; }
9664	public static function registerReader ( $ readerType , $ readerClass ) { if ( ! is_a ( $ readerClass , Reader \ IReader :: class , true ) ) { throw new Reader \ Exception ( 'Registered readers must implement ' . Reader \ IReader :: class ) ; } self :: $ readers [ $ readerType ] = $ readerClass ; }
6007	public static function fromHex ( $ hex ) { if ( strlen ( $ hex ) != 2 ) { throw new Ts3Exception ( "given parameter '" . $ hex . "' is not a valid hexadecimal number" ) ; } return new self ( chr ( hexdec ( $ hex ) ) ) ; }
10204	public function setShrinkToFit ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = false ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'shrinkToFit' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> shrinkToFit = $ pValue ; } return $ this ; }
11515	public function getNamedParam ( string $ category , string $ key ) { $ params = $ this -> getNamedParams ( $ category ) ; return $ params [ $ key ] ?? '' ; }
4407	public function getCurrentMenuPlugin ( ) { $ currentRequest = $ this -> requestStack -> getCurrentRequest ( ) ; if ( ! $ currentRequest instanceof Request ) { return false ; } foreach ( $ this -> menuPluginRegistry -> getMenuPlugins ( ) as $ identifier => $ menuPlugin ) { if ( $ menuPlugin -> matches ( $ currentRequest ) ) { return $ identifier ; } } return false ; }
7748	private function isAccessible ( \ ReflectionClass $ class , $ methodName , $ parameters ) { if ( $ class -> hasMethod ( $ methodName ) ) { $ method = $ class -> getMethod ( $ methodName ) ; if ( $ method -> isPublic ( ) && $ method -> getNumberOfRequiredParameters ( ) === $ parameters ) { return true ; } } return false ; }
2524	protected function loadFromAuthParams ( AuthParams $ authParams ) { $ this -> officeId = $ authParams -> officeId ; $ this -> dutyCode = $ authParams -> dutyCode ; $ this -> organizationId = $ authParams -> organizationId ; $ this -> originatorTypeCode = $ authParams -> originatorTypeCode ; $ this -> userId = $ authParams -> userId ; $ this -> passwordLength = $ authParams -> passwordLength ; $ this -> passwordData = $ authParams -> passwordData ; }
9467	protected function initializer ( string $ key , array $ storage ) : void { $ this -> _name = $ key ; $ this -> attached ( $ storage ) ; }
12850	private function _checkCache ( \ stdClass $ oCache ) { $ sHearderValidity = false ; $ sHeader = "Cache-Control:" ; if ( isset ( $ oCache -> visibility ) && ( $ oCache -> visibility = 'public' || $ oCache -> visibility = 'private' ) ) { $ sHearderValidity = true ; $ sHeader .= " " . $ oCache -> visibility . "," ; } if ( isset ( $ oCache -> max_age ) ) { $ sHearderValidity = true ; $ sHeader .= " maxage=" . $ oCache -> max_age . "," ; } if ( isset ( $ oCache -> must_revalidate ) && $ oCache -> must_revalidate === true ) { $ sHearderValidity = true ; $ sHeader .= " must-revalidate," ; } if ( $ sHearderValidity === true ) { $ sHeader = substr ( $ sHeader , 0 , - 1 ) ; if ( ! headers_sent ( ) ) { header ( $ sHeader ) ; } } if ( isset ( $ oCache -> ETag ) ) { header ( "ETag: \"" . $ oCache -> ETag . "\"" ) ; } if ( isset ( $ oCache -> max_age ) ) { if ( ! headers_sent ( ) ) { header ( 'Expires: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> max_age ) . ' GMT' ) ; } } if ( isset ( $ oCache -> last_modified ) ) { if ( ! headers_sent ( ) ) { header ( 'Last-Modified: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> last_modified ) . ' GMT' ) ; } } if ( isset ( $ oCache -> vary ) ) { header ( 'Vary: ' . $ oCache -> vary ) ; } }
6030	public function setChildMedias ( array $ childMedias ) { $ this -> childMedias = [ ] ; foreach ( $ childMedias as $ item ) { $ this -> addself ( $ item ) ; } return $ this ; }
10043	public function offsetSet ( $ key , $ value ) { if ( ! ( $ value instanceof PieceInterface ) ) { $ value = new Piece ( $ value ) ; } parent :: offsetSet ( $ key , $ value ) ; }
1330	public function queryToMany ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryAllOrOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; }
8404	public static function registerApp ( string $ namespace , string $ path = null ) { $ namespace = rtrim ( $ namespace , '\\' ) ; if ( $ path == null ) { $ path = constant ( 'STRAY_PATH_APPS' ) . str_replace ( '_' , DIRECTORY_SEPARATOR , str_replace ( '\\' , DIRECTORY_SEPARATOR , $ namespace ) ) ; } self :: $ namespaces [ $ namespace ] = $ path ; self :: $ applications [ ] = $ namespace ; }
10053	public function setDataType ( $ dataType ) { if ( ! in_array ( $ dataType , self :: $ dataTypeValues ) ) { throw new Exception ( 'Invalid datatype for chart data series values' ) ; } $ this -> dataType = $ dataType ; return $ this ; }
10151	private function readFooter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { if ( $ recordData ) { if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( $ recordData ) ; } else { $ string = $ this -> readByteStringShort ( $ recordData ) ; } $ this -> phpSheet -> getHeaderFooter ( ) -> setOddFooter ( $ string [ 'value' ] ) ; $ this -> phpSheet -> getHeaderFooter ( ) -> setEvenFooter ( $ string [ 'value' ] ) ; } } }
1256	public static function search ( $ expression , $ data ) { static $ runtime ; if ( ! $ runtime ) { $ runtime = Env :: createRuntime ( ) ; } return $ runtime ( $ expression , $ data ) ; }
9602	public function dotProduct ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; $ bComponents = $ b -> components ( ) ; $ product = 0 ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ product += $ component * $ bComponents [ $ i ] ; } return $ product ; }
6317	public function execute ( $ sql ) { $ this -> dispatcher -> dispatch ( 'rentgen.sql_executed' , new SqlEvent ( $ sql ) ) ; return $ this -> getConnection ( ) -> exec ( $ sql ) ; }
4862	private function createEnvelope ( JobInterface $ job , array $ options = [ ] ) { $ scheduled = $ this -> parseOptionsToDateTime ( $ options ) ; $ tried = isset ( $ options [ 'tried' ] ) ? ( int ) $ options [ 'tried' ] : null ; $ message = isset ( $ options [ 'message' ] ) ? $ options [ 'message' ] : null ; $ trace = isset ( $ options [ 'trace' ] ) ? $ options [ 'trace' ] : null ; $ envelope = [ 'queue' => $ this -> getName ( ) , 'status' => self :: STATUS_PENDING , 'tried' => $ tried , 'message' => $ message , 'trace' => $ trace , 'created' => $ this -> dateTimeToUTCDateTime ( $ this -> now ) , 'data' => $ this -> serializeJob ( $ job ) , 'scheduled' => $ this -> dateTimeToUTCDateTime ( $ scheduled ) , 'priority' => isset ( $ options [ 'priority' ] ) ? $ options [ 'priority' ] : self :: DEFAULT_PRIORITY , ] ; return $ envelope ; }
1672	public function protect ( ) { if ( ! $ this -> isUnprotected ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.public' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot protect folder "%s" because one of its parent folders is public' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.public' ) ) -> delete ( ) ; }
7591	public function render ( $ sBadgeMessage , array $ aBadgeAttributes = null ) { if ( ! is_scalar ( $ sBadgeMessage ) ) { throw new InvalidArgumentException ( sprintf ( 'Badge message expects a scalar value, "%s" given' , is_object ( $ sBadgeMessage ) ? get_class ( $ sBadgeMessage ) : gettype ( $ sBadgeMessage ) ) ) ; } if ( empty ( $ aBadgeAttributes ) ) { $ aBadgeAttributes = array ( 'class' => 'badge' ) ; } else { if ( empty ( $ aBadgeAttributes [ 'class' ] ) ) { $ aBadgeAttributes [ 'class' ] = 'badge' ; } elseif ( ! preg_match ( '/(\s|^)badge(\s|$)/' , $ aBadgeAttributes [ 'class' ] ) ) { $ aBadgeAttributes [ 'class' ] .= ' badge' ; } } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sBadgeMessage = $ oTranslator -> translate ( $ sBadgeMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ badgeFormat , $ this -> createAttributesString ( $ aBadgeAttributes ) , $ sBadgeMessage ) ; }
3932	private function setLabel ( PropertyInterface $ property , $ propInfo , IAttribute $ attribute ) { if ( $ property -> getLabel ( ) ) { return ; } if ( ! isset ( $ propInfo [ 'label' ] ) ) { $ property -> setLabel ( $ attribute -> getName ( ) ) ; return ; } $ lang = $ propInfo [ 'label' ] ; if ( is_array ( $ lang ) ) { $ property -> setLabel ( reset ( $ lang ) ) ; $ property -> setDescription ( next ( $ lang ) ) ; return ; } $ property -> setLabel ( $ lang ) ; }
5077	public function getId ( $ aData = [ ] ) { $ sIds = '' ; $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; if ( ! empty ( $ oInput -> get ( 'id' ) ) ) { $ sIds = $ oInput -> get ( 'id' ) ; } if ( ! empty ( $ oInput -> get ( 'ids' ) ) ) { $ sIds = $ oInput -> get ( 'ids' ) ; } $ aIds = explode ( ',' , $ sIds ) ; $ aIds = array_filter ( $ aIds ) ; $ aIds = array_unique ( $ aIds ) ; if ( count ( $ aIds ) > self :: CONFIG_MAX_ITEMS_PER_REQUEST ) { throw new ApiException ( 'You can request a maximum of ' . self :: CONFIG_MAX_ITEMS_PER_REQUEST . ' items per request' , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ aResults = $ oItemModel -> getByIds ( $ aIds , $ aData ) ; if ( $ oInput -> get ( 'id' ) ) { $ oItem = reset ( $ aResults ) ; $ mData = $ oItem ? $ this -> formatObject ( $ oItem ) : null ; } else { $ mData = array_map ( [ $ this , 'formatObject' ] , $ aResults ) ; } $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ mData ) ; return $ oResponse ; }
8260	protected function saveLoginInfo ( $ resourceOwner ) { $ u = new User ( ) ; $ u -> setAuthenticated ( true ) ; $ u -> setAuthenticator ( $ this -> getName ( ) ) ; $ attrMap = $ this -> providerConfig [ 'attributeMap' ] ; $ userIdAttr = $ attrMap [ 'userId' ] ; $ userId = $ this -> getResourceAttribute ( $ userIdAttr , $ resourceOwner ) ; $ u -> setId ( $ userId ) ; unset ( $ attrMap [ 'userId' ] ) ; if ( isset ( $ attrMap [ 'displayName' ] ) ) { $ name = $ this -> getResourceAttribute ( $ attrMap [ 'displayName' ] , $ resourceOwner ) ; $ u -> setDisplayName ( $ name ) ; unset ( $ attrMap [ 'displayName' ] ) ; } foreach ( $ attrMap as $ mapKey => $ mapValue ) { $ value = $ this -> getResourceAttribute ( $ mapValue , $ resourceOwner ) ; $ u -> setAttribute ( $ mapKey , $ value ) ; } $ u -> setGroups ( $ this -> providerConfig [ 'default' ] [ 'groups' ] ) ; foreach ( $ this -> providerConfig [ 'default' ] [ 'attributes' ] as $ key => $ value ) { if ( null === $ u -> getAttribute ( $ key ) ) { $ u -> setAttribute ( $ key , $ value ) ; } } $ this -> picoAuth -> setUser ( $ u ) ; $ this -> picoAuth -> afterLogin ( ) ; }
9746	public function setQuarter ( $ quarter ) { if ( ! $ quarter ) { return $ this ; } if ( ! ( $ quarter instanceof Quarter ) ) { $ quarter = new Quarter ( $ quarter ) ; } if ( $ quarter -> isEmpty ( ) ) { $ this -> invalidArguments ( '10005' ) ; } return $ this -> setParameter ( 'quarter' , $ quarter ) ; }
12800	public function getHeaders ( ) { if ( ! isset ( $ this -> _headers ) ) { $ this -> _headers = $ this -> readLine ( 1 ) ; if ( ! $ this -> _headers ) { $ this -> _headers = [ ] ; } } return $ this -> _headers ; }
6424	protected function getClient ( $ redirecturl = '' ) { if ( is_object ( $ this -> google ) ) { return $ this -> google ; } if ( $ redirecturl == '' ) { $ redirecturl = $ this -> redirecturl ; } else { $ this -> redirecturl = $ redirecturl ; } $ client = new \ Google_Client ( ) ; $ client -> setApplicationName ( $ this -> options [ 'application_name' ] ) ; $ client -> setClientId ( $ this -> options [ 'client_id' ] ) ; $ client -> setClientSecret ( $ this -> options [ 'client_secret' ] ) ; $ client -> setRedirectUri ( $ redirecturl ) ; $ client -> setDeveloperKey ( $ this -> options [ 'api_key' ] ) ; $ client -> setScopes ( array ( 'https://www.googleapis.com/auth/userinfo.profile' , 'https://www.googleapis.com/auth/userinfo.email' ) ) ; $ this -> google = $ client ; return $ client ; }
4987	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( $ spec instanceof FormParentInterface ) { $ spec -> setParent ( $ this ) ; } $ spec = [ '__instance__' => $ spec , 'name' => $ key , 'entity' => '*' ] ; } if ( ! is_array ( $ spec ) ) { $ spec = array ( 'type' => $ spec , 'name' => $ key ) ; } if ( ! isset ( $ spec [ 'name' ] ) ) { $ spec [ 'name' ] = $ key ; } if ( ! isset ( $ spec [ 'entity' ] ) ) { $ spec [ 'entity' ] = '*' ; } $ this -> forms [ $ key ] = $ spec ; if ( $ enabled ) { $ this -> enableForm ( $ key ) ; } elseif ( true === $ this -> activeForms ) { $ this -> activeForms = false ; } return $ this ; }
2484	protected function getAllSearchTargets ( ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = [ ] ; $ searchTargets = $ this -> endpointResolver -> getEndpoints ( ) ; if ( ! empty ( $ searchTargets ) ) { foreach ( $ searchTargets as $ endpointName ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
11551	public function saveConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_SAVE , $ event ) ; if ( ! $ consignment -> getStatus ( ) ) { $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_NEW ) ; } try { $ adapter -> saveConsignment ( $ consignment ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment saving.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_SAVE , $ event ) ; }
2770	public function getRemoteUrl ( string $ remote , string $ operation = 'fetch' ) : string { $ argsAndOptions = [ 'get-url' , $ remote ] ; if ( $ operation === 'push' ) { $ argsAndOptions [ ] = '--push' ; } return rtrim ( $ this -> remote ( ... $ argsAndOptions ) ) ; }
7121	private function createFindBySubjectQueryBuilder ( ) { $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createQueryBuilder ( ) ; return $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.subjectIdentity.provider' , ':provider' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.subjectIdentity.identifier' , ':identifier' ) ) ; }
5330	public function getEmojiPattern ( ) { if ( null === self :: $ emojiPattern ) { $ codeString = '' ; foreach ( $ this -> getEmojiCodeList ( ) as $ code ) { if ( is_array ( $ code ) ) { $ first = dechex ( array_shift ( $ code ) ) ; $ last = dechex ( array_pop ( $ code ) ) ; $ codeString .= '\x{' . $ first . '}-\x{' . $ last . '}' ; } else { $ codeString .= '\x{' . dechex ( $ code ) . '}' ; } } self :: $ emojiPattern = "/[$codeString]/u" ; } return self :: $ emojiPattern ; }
6501	private function getRequestTarget ( ) : string { switch ( $ this -> requestTargetType ) { case RequestTargetTypes :: ORIGIN_FORM : $ requestTarget = $ this -> uri -> getPath ( ) ; if ( $ requestTarget === null || $ requestTarget === '' ) { $ requestTarget = '/' ; } if ( ( $ queryString = $ this -> uri -> getQueryString ( ) ) !== null && $ queryString !== '' ) { $ requestTarget .= "?$queryString" ; } return $ requestTarget ; case RequestTargetTypes :: ABSOLUTE_FORM : return ( string ) $ this -> uri ; case RequestTargetTypes :: AUTHORITY_FORM : return $ this -> uri -> getAuthority ( false ) ?? '' ; case RequestTargetTypes :: ASTERISK_FORM : return '*' ; default : return '' ; } }
7457	public function persist ( ObjectManager $ manager ) { foreach ( $ this -> entities as $ entity ) { $ manager -> persist ( $ entity ) ; } if ( $ this -> root ) { $ manager -> persist ( $ this -> root ) ; } }
3971	public function getAttributeOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ result = [ ] ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ conditionType = $ event -> getModel ( ) -> getProperty ( 'type' ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( ! $ this -> conditionFactory -> supportsAttribute ( $ conditionType , $ attribute -> get ( 'type' ) ) ) { continue ; } $ typeName = $ attribute -> get ( 'type' ) ; $ strSelectVal = $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ; $ result [ $ strSelectVal ] = $ attribute -> getName ( ) . ' [' . $ typeName . ']' ; } $ event -> setOptions ( $ result ) ; }
8364	public static function setCurrentLanguage ( $ language ) { self :: $ currentLanguage = $ language ; Session :: set ( '_stray_language' , self :: $ currentLanguage ) ; setlocale ( LC_ALL , $ language ) ; }
11201	public function fetchOffset ( $ num ) { if ( $ this -> contentModified ) { $ this -> generateContent ( ) ; } $ key = $ this -> fetchOffsetKey ( $ num ) ; if ( $ key != null ) { return $ this -> content [ $ key ] ; } return null ; }
6893	protected function sortAssignments ( array $ assignments ) { usort ( $ assignments , function ( StockAssignmentInterface $ a1 , StockAssignmentInterface $ a2 ) { $ u1 = $ a1 -> getStockUnit ( ) ; $ u2 = $ a2 -> getStockUnit ( ) ; return $ this -> compareStockUnit ( $ u1 , $ u2 ) ; } ) ; return $ assignments ; }
7707	function _ApplyDiffToAll ( $ Diff ) { $ this -> PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; $ this -> pST_PosEnd += $ Diff ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; }
8216	private function getNextJob ( $ tube , $ state ) { if ( 'ready' == $ this -> state ) { return $ this -> reserveJob ( $ tube ) ; } return $ this -> peekJob ( $ tube , $ state ) ; }
10575	public static function apply ( $ text , $ foreground = '' , $ background = '' ) { try { $ style = new OutputFormatterStyle ( ) ; if ( $ foreground != '' ) { $ style -> setForeground ( $ foreground ) ; } if ( $ background != '' ) { $ style -> setBackground ( $ background ) ; } return $ style -> apply ( $ text ) ; } catch ( \ Exception $ e ) { return $ text ; } }
2704	public function getContentTypeOptions ( ) { $ contentTypes = [ self :: CONTENT_TYPE_HTML => __ ( 'HTML' ) , self :: CONTENT_TYPE_CSS => __ ( 'CSS' ) , self :: CONTENT_TYPE_JS => __ ( 'JavaScript' ) , self :: CONTENT_TYPE_IMAGE => __ ( 'Images' ) ] ; return $ contentTypes ; }
12886	public function setRawPhoto ( $ photo ) { if ( empty ( $ photo ) ) { return true ; } if ( ! ( $ photo instanceof FileInterface ) ) { $ photo = RawFile :: createRawInstance ( $ photo ) ; } return $ this -> setStorage ( $ photo ) ; }
7058	protected function getStockAdjustmentFromEvent ( ResourceEventInterface $ event ) { $ stockAdjustment = $ event -> getResource ( ) ; if ( ! $ stockAdjustment instanceof StockAdjustmentInterface ) { throw new InvalidArgumentException ( "Expected instance of " . StockAdjustmentInterface :: class ) ; } return $ stockAdjustment ; }
8150	public function initRuntime ( ) { $ this -> runtimeInitialized = true ; foreach ( $ this -> getExtensions ( ) as $ name => $ extension ) { if ( ! $ extension instanceof Twig_Extension_InitRuntimeInterface ) { $ m = new ReflectionMethod ( $ extension , 'initRuntime' ) ; if ( 'Twig_Extension' !== $ m -> getDeclaringClass ( ) -> getName ( ) ) { @ trigger_error ( sprintf ( 'Defining the initRuntime() method in the "%s" extension is deprecated since version 1.23. Use the `needs_environment` option to get the Twig_Environment instance in filters, functions, or tests; or explicitly implement Twig_Extension_InitRuntimeInterface if needed (not recommended).' , $ name ) , E_USER_DEPRECATED ) ; } } $ extension -> initRuntime ( $ this ) ; } }
8550	public function setRentalTransactionEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalTransactionEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10869	public function getByEmail ( string $ email ) { return $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.email' => $ email , $ this -> tableName [ 0 ] . '.active' => true ] ) -> fetch ( ) ; }
4062	private static function isEmptyArrayEquivalent ( $ expected , $ actual ) { return ( gettype ( $ expected ) == 'string' ) && ( ( gettype ( $ actual ) == 'array' ) || ( gettype ( $ actual ) == 'NULL' ) ) && empty ( $ actual ) && empty ( $ expected ) ; }
9854	protected function append ( $ data ) { if ( strlen ( $ data ) - 4 > $ this -> limit ) { $ data = $ this -> addContinue ( $ data ) ; } $ this -> _data .= $ data ; $ this -> _datasize += strlen ( $ data ) ; }
8938	public function updateChangeset ( $ id , $ tags = array ( ) ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <changeset>' . $ tagList . '</changeset> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> changeset ; }
683	private function normalizeComplexFilter ( array $ filter ) { $ result = [ ] ; foreach ( $ filter as $ key => $ value ) { if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ key = $ this -> filterControls [ $ key ] ; } elseif ( isset ( $ this -> attributeMap [ $ key ] ) ) { $ key = $ this -> attributeMap [ $ key ] ; } if ( is_array ( $ value ) ) { $ result [ $ key ] = $ this -> normalizeComplexFilter ( $ value ) ; } else { $ result [ $ key ] = $ value ; } } return $ result ; }
12711	public function register ( $ alias , $ abstract ) { if ( ! is_string ( $ alias ) || ! is_string ( $ abstract ) ) { throw new \ InvalidArgumentException ( sprintf ( "Parameter 1 and 2 of %s must be a string." , __METHOD__ ) ) ; } if ( ! isset ( $ this -> aliases [ $ alias ] ) ) { $ this -> aliases [ $ alias ] = $ this -> make ( $ abstract ) ; } return $ this ; }
8012	public static function forChallengeMessage ( $ challenge_message , $ code = 0 , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE ; $ reason_messages = [ ] ; if ( ( self :: CODE_FOR_INVALID_SIGNATURE & $ code ) === self :: CODE_FOR_INVALID_SIGNATURE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_SIGNATURE ; } if ( ( self :: CODE_FOR_INVALID_MESSAGE_TYPE & $ code ) === self :: CODE_FOR_INVALID_MESSAGE_TYPE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_MESSAGE_TYPE ; } $ message .= sprintf ( self :: MESSAGE_EXTENSION_FOR_REASONS_FORMAT , implode ( self :: MESSAGE_REASON_GLUE , $ reason_messages ) ) ; $ instance = new static ( $ message , $ code , $ previous ) ; $ instance -> challenge_message = $ challenge_message ; return $ instance ; }
2652	public function uploadSnippet ( $ version , array $ snippet ) { if ( isset ( $ snippet [ 'content' ] ) ) { $ adminUrl = $ this -> vcl -> getAdminFrontName ( ) ; $ adminPathTimeout = $ this -> config -> getAdminPathTimeout ( ) ; $ ignoredUrlParameters = $ this -> config -> getIgnoredUrlParameters ( ) ; $ ignoredUrlParameterPieces = explode ( "," , $ ignoredUrlParameters ) ; $ filterIgnoredUrlParameterPieces = array_filter ( array_map ( 'trim' , $ ignoredUrlParameterPieces ) ) ; $ queryParameters = implode ( '|' , $ filterIgnoredUrlParameterPieces ) ; $ snippet [ 'content' ] = str_replace ( '####ADMIN_PATH####' , $ adminUrl , $ snippet [ 'content' ] ) ; $ snippet [ 'content' ] = str_replace ( '####ADMIN_PATH_TIMEOUT####' , $ adminPathTimeout , $ snippet [ 'content' ] ) ; $ snippet [ 'content' ] = str_replace ( '####QUERY_PARAMETERS####' , $ queryParameters , $ snippet [ 'content' ] ) ; } $ checkIfExists = $ this -> hasSnippet ( $ version , $ snippet [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/snippet' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ snippet [ 'name' ] ; unset ( $ snippet [ 'name' ] , $ snippet [ 'type' ] , $ snippet [ 'dynamic' ] , $ snippet [ 'priority' ] ) ; } $ result = $ this -> _fetch ( $ url , $ verb , $ snippet ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to upload the Snippet file.' ) ) ; } }
1986	private function loadOptions ( ) : void { if ( null !== $ this -> options ) { return ; } $ this -> framework -> initialize ( ) ; $ this -> options = $ GLOBALS [ 'TL_CROP' ] ; $ rows = $ this -> connection -> fetchAll ( 'SELECT id, name, width, height FROM tl_image_size ORDER BY pid, name' ) ; foreach ( $ rows as $ imageSize ) { $ this -> options [ 'image_sizes' ] [ $ imageSize [ 'id' ] ] = sprintf ( '%s (%sx%s)' , $ imageSize [ 'name' ] , $ imageSize [ 'width' ] , $ imageSize [ 'height' ] ) ; } }
6553	public function unlock ( ) { try { if ( $ this -> pid === $ this -> getSerial ( ) && is_resource ( $ this -> fh ) ) { $ this -> removeLineFromFile ( $ this -> pid , $ this -> fh ) ; flock ( $ this -> fh , LOCK_UN ) ; fclose ( $ this -> fh ) ; if ( filesize ( $ filename = $ this -> getPidFilename ( ) ) === 0 ) { unlink ( $ filename ) ; } } } catch ( FileNotFoundException $ fnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID file %s doesn\'t exist' , $ this -> getPidFilename ( ) ) ) ; } catch ( LineNotFoundException $ lnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID %s is can not be found in PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( sprintf ( 'Can\'t remove PID %s from PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) , null , $ e ) ; } }
5081	public function putRemap ( $ sMethod ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'put' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oItem = $ this -> lookUpResource ( ) ; if ( ! $ oItem ) { throw new ApiException ( 'Resource not found' , 404 ) ; } $ this -> userCan ( static :: ACTION_UPDATE , $ oItem ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ sData = stream_get_contents ( fopen ( 'php://input' , 'r' ) ) ; $ aData = json_decode ( $ sData , JSON_OBJECT_AS_ARRAY ) ? : [ ] ; $ aData = $ this -> validateUserInput ( $ aData , $ oItem ) ; if ( ! $ this -> oModel -> update ( $ oItem -> id , $ aData ) ) { throw new ApiException ( 'Failed to update resource. ' . $ this -> oModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } return Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; }
3960	public function parseAttribute ( $ strAttributeName , $ strOutputFormat = 'text' , $ objSettings = null ) { return $ this -> internalParseAttribute ( $ this -> getAttribute ( $ strAttributeName ) , $ strOutputFormat , $ objSettings ) ; }
12420	public function dt ( $ domain , $ singular ) { $ singular = ( string ) $ singular ; try { $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { if ( ( $ string = $ object -> translate ( $ singular , $ domain , $ locale ) ) != $ singular ) { return $ string ; } } } catch ( \ Exception $ e ) { ; } return ( string ) $ singular ; }
3638	public function env ( Output $ output ) : void { $ info = [ 'OS' => \ PHP_OS , 'Php version' => \ PHP_VERSION , 'Swoole version' => \ SWOOLE_VERSION , 'Swoft version' => \ Swoft :: VERSION , 'App Name' => \ config ( 'name' , 'unknown' ) , 'Base Path' => \ BASE_PATH , ] ; Show :: aList ( $ info , 'System Environment Info' ) ; }
2463	public static function findSentByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.sent=1" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
7269	public function belongsTo ( $ refClass , $ forColumn = null ) { $ refTable = $ refClass :: tableName ( ) ; $ forTable = static :: tableName ( ) ; $ refColumn = $ refClass :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( $ refClass :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select R.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and F.$forColumn = :id " , [ "id" => $ this -> $ forColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ refModel = new $ refClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ refModel -> $ col = $ refModel -> decodeValue ( $ val , $ col ) ; return $ refModel ; }
12832	private function _processModifiers ( $ expression ) { $ mStart = '' ; $ mEnd = '' ; $ rawEcho = false ; if ( strpos ( $ expression , '|' ) !== false && strpos ( $ expression , '||' ) === false ) { $ modifiers = explode ( '|' , $ expression ) ; $ expression = array_shift ( $ modifiers ) ; foreach ( $ modifiers as $ modifier ) { $ params = array ( ) ; if ( strpos ( $ modifier , ':' ) !== false ) { $ params = explode ( ':' , $ modifier ) ; $ modifier = array_shift ( $ params ) ; } if ( $ modifier == 'raw' ) { $ rawEcho = true ; continue ; } if ( $ this -> isCallable ( $ modifier ) ) { $ mStart = $ modifier . '(' . $ mStart ; if ( $ modifier !== 'raw' ) { foreach ( $ params as $ param ) { $ mEnd .= ', ' . $ this -> compileExpression ( $ param ) ; } } $ mEnd .= ')' ; } else { throw new \ Exception ( 'SLOT compiler error: undefined modifier ' . $ modifier ) ; } } } return array ( $ expression , $ mStart , $ mEnd , $ rawEcho ) ; }
3420	public function delete ( ) { if ( $ this -> onBeforeDelete ( ) === false ) { return false ; } $ result = static :: $ bxObject -> delete ( $ this -> id ) ; $ this -> setEventErrorsOnFail ( $ result , static :: $ bxObject ) ; $ this -> onAfterDelete ( $ result ) ; $ this -> resetEventErrors ( ) ; $ this -> throwExceptionOnFail ( $ result , static :: $ bxObject ) ; return $ result ; }
991	public static function allRules ( ) { if ( ! self :: $ initRules ) { static :: $ rules = array_merge ( static :: defaultRules ( ) , self :: securityRules ( ) , self :: $ rules ) ; static :: $ initRules = true ; } return self :: $ rules ; }
4803	public function renderRichText ( $ richText ) { if ( strlen ( $ richText ) < 1 ) { return '' ; } $ templatePath = $ this -> getTemplatePathAndFilename ( 'RichText' ) ; $ view = $ this -> createView ( $ templatePath ) ; $ view -> assign ( 'richText' , $ richText ) ; return $ view -> render ( $ templatePath ) ; }
8000	public function calculateNtResponse ( HashCredentialInterface $ hash_credential , $ client_challenge = null , $ server_challenge_nonce = null ) { $ encryption_data = $ server_challenge_nonce ; if ( null !== $ client_challenge ) { $ extended_security_hasher = $ this -> crypt_hasher_factory -> build ( static :: EXTENDED_SESSION_SECURITY_HASHER_ALGORITHM ) ; $ nt_extended_security_challenge_source = $ server_challenge_nonce . $ client_challenge ; $ nt_extended_security_hash = $ extended_security_hasher -> update ( $ nt_extended_security_challenge_source ) -> digest ( ) ; $ nt_extended_security_challenge = substr ( $ nt_extended_security_hash , 0 , static :: EXTENDED_SESSION_SECURITY_CHALLENGE_LENGTH ) ; $ encryption_data = $ nt_extended_security_challenge ; } return $ this -> calculateChallengeResponseData ( $ hash_credential , $ encryption_data ) ; }
6006	public function toUnicode ( ) { $ h = ord ( $ this -> char { 0 } ) ; if ( $ h <= 0x7F ) { return $ h ; } else { if ( $ h < 0xC2 ) { return false ; } else { if ( $ h <= 0xDF ) { return ( $ h & 0x1F ) << 6 | ( ord ( $ this -> char { 1 } ) & 0x3F ) ; } else { if ( $ h <= 0xEF ) { return ( $ h & 0x0F ) << 12 | ( ord ( $ this -> char { 1 } ) & 0x3F ) << 6 | ( ord ( $ this -> char { 2 } ) & 0x3F ) ; } else { if ( $ h <= 0xF4 ) { return ( $ h & 0x0F ) << 18 | ( ord ( $ this -> char { 1 } ) & 0x3F ) << 12 | ( ord ( $ this -> char { 2 } ) & 0x3F ) << 6 | ( ord ( $ this -> char { 3 } ) & 0x3F ) ; } else { return false ; } } } } } }
11785	public function pagination ( $ begin , $ count ) { $ params = [ 'type' => 2 , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , $ params ] ) ; }
1322	private function parseHeaders ( $ header ) { $ headers = [ ] ; foreach ( explode ( "\r\n" , $ header ) as $ line ) { if ( strpos ( $ line , ':' ) !== false ) { list ( $ key , $ value ) = explode ( ': ' , $ line ) ; $ key = str_replace ( '-' , '_' , strtolower ( $ key ) ) ; $ headers [ $ key ] = trim ( $ value ) ; } } return $ headers ; }
9701	public function addXfWriter ( Style $ style , $ isStyleXf = false ) { $ xfWriter = new Xf ( $ style ) ; $ xfWriter -> setIsStyleXf ( $ isStyleXf ) ; $ fontIndex = $ this -> addFont ( $ style -> getFont ( ) ) ; $ xfWriter -> setFontIndex ( $ fontIndex ) ; $ xfWriter -> setFgColor ( $ this -> addColor ( $ style -> getFill ( ) -> getStartColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setBgColor ( $ this -> addColor ( $ style -> getFill ( ) -> getEndColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setBottomColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getBottom ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setTopColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getTop ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setRightColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getRight ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setLeftColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getLeft ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setDiagColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getDiagonal ( ) -> getColor ( ) -> getRGB ( ) ) ) ; if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false ) { $ numberFormatHashCode = $ style -> getNumberFormat ( ) -> getHashCode ( ) ; if ( isset ( $ this -> addedNumberFormats [ $ numberFormatHashCode ] ) ) { $ numberFormatIndex = $ this -> addedNumberFormats [ $ numberFormatHashCode ] ; } else { $ numberFormatIndex = 164 + count ( $ this -> numberFormats ) ; $ this -> numberFormats [ $ numberFormatIndex ] = $ style -> getNumberFormat ( ) ; $ this -> addedNumberFormats [ $ numberFormatHashCode ] = $ numberFormatIndex ; } } else { $ numberFormatIndex = ( int ) $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) ; } $ xfWriter -> setNumberFormatIndex ( $ numberFormatIndex ) ; $ this -> xfWriters [ ] = $ xfWriter ; $ xfIndex = count ( $ this -> xfWriters ) - 1 ; return $ xfIndex ; }
2222	public static function countPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
9784	public function parseHTML ( ) { $ token = $ this -> pop ( 'HTML' ) ; $ value = $ this -> stripQuotes ( $ token [ 1 ] ) ; $ this -> currLine += substr_count ( $ value , "\n" ) ; return '$output .= \'' . $ value . "';\n" ; }
6363	public function start ( $ name ) : Profiler { if ( ! $ this -> globalStopwatch -> isRunning ( ) ) { $ this -> globalStopwatch -> start ( ) ; } if ( $ this -> entryStopwatch -> isRunning ( ) ) { $ this -> recordEntry ( ) ; } $ this -> currentName = $ name ; $ this -> entryStopwatch -> start ( ) ; return $ this ; }
9719	private function writeMsoDrawingGroup ( ) { if ( isset ( $ this -> escher ) ) { $ writer = new Escher ( $ this -> escher ) ; $ data = $ writer -> close ( ) ; $ record = 0x00EB ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ this -> writeData ( $ header . $ data ) ; } return '' ; }
9751	public function set_images ( $ post_id ) { if ( ! $ post_id || is_null ( $ post_id ) ) { return 0 ; } update_post_meta ( $ post_id , 'custom_images_grifus' , 'true' ) ; $ count = 0 ; $ tmdb = 'image.tmdb.org' ; $ poster = get_post_meta ( $ post_id , 'poster_url' , true ) ; if ( filter_var ( $ poster , FILTER_VALIDATE_URL ) && strpos ( $ poster , $ tmdb ) ) { $ count ++ ; $ poster = WP_Image :: save ( $ poster , $ post_id , true ) ; update_post_meta ( $ post_id , 'poster_url' , $ poster ) ; } $ main = get_post_meta ( $ post_id , 'fondo_player' , true ) ; if ( filter_var ( $ main , FILTER_VALIDATE_URL ) && strpos ( $ main , $ tmdb ) ) { $ count ++ ; $ main = WP_Image :: save ( $ main , $ post_id ) ; update_post_meta ( $ post_id , 'fondo_player' , $ main ) ; } $ images = get_post_meta ( $ post_id , 'imagenes' , true ) ; $ images_array = explode ( "\n" , $ images ) ; $ new_images = '' ; foreach ( $ images_array as $ image ) { $ image = trim ( $ image ) ; if ( filter_var ( $ image , FILTER_VALIDATE_URL ) && strpos ( $ image , $ tmdb ) ) { $ count ++ ; $ url = WP_Image :: save ( $ image , $ post_id ) ; $ new_images .= $ url . "\n" ; } } if ( ! empty ( $ new_images ) ) { update_post_meta ( $ post_id , 'imagenes' , $ new_images ) ; } return $ count ; }
11644	protected function getConnection ( ) { $ connection = $ this -> getClient ( ) -> getConnection ( ) ; if ( $ connection instanceof ReplicationInterface ) { $ connection -> switchToMaster ( ) ; } return $ connection ; }
4590	public function exists ( $ form , Parameters $ parameters = null ) : bool { $ object = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c6f7311000029066df850' ) ; if ( $ object && property_exists ( $ object , '_id' ) && $ object -> _id ) { return true ; } return false ; }
7460	public function lookup ( $ hash , $ className = 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) { try { return $ this -> hashedEntityHelper -> lookup ( $ hash , $ className ) ; } catch ( \ RuntimeException $ e ) { return null ; } }
5160	public function getAttachmentByField ( string $ field ) : array { if ( isset ( $ this -> attachment [ $ field ] ) ) { return $ this -> attachment [ $ field ] ; } return [ ] ; }
3236	public function getTotalPriceAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> totalPrice , 2 ) ; }
3372	private function getFormFactory ( ContainerInterface $ services ) { $ elements = null ; if ( $ services -> has ( 'FormElementManager' ) ) { $ elements = $ services -> get ( 'FormElementManager' ) ; } return new Factory ( $ elements ) ; }
910	private function findHeaderCommentInsertionIndex ( Tokens $ tokens ) { if ( 'after_open' === $ this -> configuration [ 'location' ] ) { return 1 ; } $ index = $ tokens -> getNextMeaningfulToken ( 0 ) ; if ( null === $ index ) { return 1 ; } if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DECLARE ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( '(' ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( [ T_STRING , 'strict_types' ] , false ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( '=' ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> isGivenKind ( T_LNUMBER ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( ')' ) ) { return 1 ; } $ next = $ tokens -> getNextMeaningfulToken ( $ next ) ; if ( null === $ next || ! $ tokens [ $ next ] -> equals ( ';' ) ) { return 1 ; } return $ next + 1 ; }
10112	private function writeRangeProtection ( ) { foreach ( $ this -> phpSheet -> getProtectedCells ( ) as $ range => $ password ) { $ cellRanges = explode ( ' ' , $ range ) ; $ cref = count ( $ cellRanges ) ; $ recordData = pack ( 'vvVVvCVvVv' , 0x0868 , 0x00 , 0x0000 , 0x0000 , 0x02 , 0x0 , 0x0000 , $ cref , 0x0000 , 0x00 ) ; foreach ( $ cellRanges as $ cellRange ) { $ recordData .= $ this -> writeBIFF8CellRangeAddressFixed ( $ cellRange ) ; } $ recordData .= pack ( 'VV' , 0x0000 , hexdec ( $ password ) ) ; $ recordData .= StringHelper :: UTF8toBIFF8UnicodeLong ( 'p' . md5 ( $ recordData ) ) ; $ length = strlen ( $ recordData ) ; $ record = 0x0868 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; } }
11266	public function library ( $ pathname , & $ caller = false , $ exposeToView = false ) { $ name = $ this -> getName ( $ pathname ) ; $ path = $ this -> getPath ( $ pathname ) ; if ( $ caller ) { if ( $ this -> getPathBackslash ( $ pathname ) == '' ) { $ lib = '\\Cora\\' . $ name ; } else { $ lib = $ pathname ; } $ libObj = new $ lib ( $ caller ) ; $ caller -> $ name = $ libObj ; if ( $ exposeToView ) $ caller -> setData ( $ name , $ libObj ) ; } }
1073	private function getSuggestedFieldNames ( Schema $ schema , $ type , $ fieldName ) { if ( $ type instanceof ObjectType || $ type instanceof InterfaceType ) { $ possibleFieldNames = array_keys ( $ type -> getFields ( ) ) ; return Utils :: suggestionList ( $ fieldName , $ possibleFieldNames ) ; } return [ ] ; }
3444	public function offsetGet ( $ offset ) { $ fieldValue = isset ( $ this -> fields [ $ offset ] ) ? $ this -> fields [ $ offset ] : null ; $ accessor = $ this -> getAccessor ( $ offset ) ; if ( $ accessor ) { return $ this -> $ accessor ( $ fieldValue ) ; } $ accessorForLanguageField = $ this -> getAccessorForLanguageField ( $ offset ) ; if ( $ accessorForLanguageField ) { return $ this -> $ accessorForLanguageField ( $ offset ) ; } return $ fieldValue ; }
9426	public function build ( $ options ) { $ command = $ this -> path ; if ( isset ( $ options [ 'title' ] ) ) { $ command .= " -title {$options['title']}" ; } if ( isset ( $ options [ 'subtitle' ] ) ) { $ command .= " -subtitle {$options['subtitle']}" ; } if ( isset ( $ options [ 'message' ] ) ) { $ command .= " -message {$options['message']}" ; } if ( isset ( $ options [ 'image' ] ) ) { $ command .= " -appIcon {$options['image']}" ; } if ( isset ( $ options [ 'contentImage' ] ) ) { $ command .= " -contentImage {$options['contentImage']}" ; } if ( isset ( $ options [ 'url' ] ) ) { $ command .= " -open {$options['url']}" ; } return $ command ; }
5706	public function shouldDisplay ( ) { return $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsPublished ( ) && $ this -> gridFieldRequest -> record -> canEdit ( ) ; }
4668	public function generate ( ) { $ this -> beforeGeneration ( ) ; $ this -> config -> getLogger ( ) -> startBreak ( 'Class Generation' ) ; foreach ( $ this -> XSDMap as $ fhirElementName => $ mapEntry ) { $ this -> config -> getLogger ( ) -> debug ( "Generating class for element {$fhirElementName}..." ) ; $ classTemplate = ClassGenerator :: buildFHIRElementClassTemplate ( $ this -> config , $ this -> XSDMap , $ mapEntry ) ; FileUtils :: createDirsFromNS ( $ classTemplate -> getNamespace ( ) , $ this -> config ) ; MethodGenerator :: implementConstructor ( $ this -> config , $ classTemplate ) ; $ classTemplate -> writeToFile ( $ this -> config -> getOutputPath ( ) ) ; $ this -> mapTemplate -> addEntry ( $ classTemplate ) ; $ this -> autoloadMap -> addPHPFHIRClassEntry ( $ classTemplate ) ; $ this -> config -> getLogger ( ) -> debug ( "{$fhirElementName} completed." ) ; } $ this -> config -> getLogger ( ) -> endBreak ( 'Class Generation' ) ; $ this -> afterGeneration ( ) ; }
6911	public function removeExtraCopy ( Recipient $ copy ) { if ( $ this -> extraCopies -> contains ( $ copy ) ) { $ this -> extraCopies -> removeElement ( $ copy ) ; } return $ this ; }
7003	public function match ( $ test ) { $ isArray = [ ] ; $ pattern = preg_replace_callback ( "~/\{(?<arg>\w+)(?<arr>\[\])?\}(?<num>\?|\+|\*|\{[0-9,]+\})?~" , function ( $ matches ) use ( & $ isArray ) { $ name = $ matches [ "arg" ] ; $ num = $ matches [ "num" ] ?? "" ; $ isArray [ $ name ] = ! empty ( $ matches [ 2 ] ) ; return "(?<$name>(?:/[^\\s/?]+)$num)" ; } , $ this -> url ) ; if ( ! $ pattern || empty ( $ pattern ) ) { error_log ( "pattern error: found in route with pattern: {$this->url}" ) ; return false ; } $ pattern = "^$pattern/?(?:\?.*)?$" ; if ( preg_match ( "~$pattern~" , $ test , $ matches ) ) { foreach ( $ matches as $ name => $ val ) { $ val = urldecode ( $ val ) ; if ( is_int ( $ name ) ) { if ( $ name === 0 ) $ this -> args [ $ name ] = $ val ; } else { $ val = ltrim ( $ val , "/" ) ; $ this -> args [ $ name ] = $ isArray [ $ name ] ? explode ( "/" , $ val ) : $ val ; } } return true ; } return false ; }
9614	public function authenticate ( TokenInterface $ token ) { $ user = $ this -> userProvider -> loadUserByApiKey ( $ this -> encoder -> encodePassword ( $ token -> getCredentials ( ) ) ) ; if ( ! $ user || ! ( $ user instanceof UserInterface ) ) { throw new AuthenticationException ( 'Bad credentials' ) ; } $ token = new ApiKeyToken ( $ token -> getCredentials ( ) , $ user -> getRoles ( ) ) ; $ token -> setUser ( $ user ) ; return $ token ; }
9621	protected function qsencode ( array $ data = array ( ) ) { $ req = '' ; if ( $ data ) { foreach ( $ data as $ key => $ value ) { $ req .= $ key . '=' . urlencode ( stripslashes ( $ value ) ) . '&' ; } $ req = substr ( $ req , 0 , strlen ( $ req ) - 1 ) ; } return $ req ; }
4649	protected function getServices ( $ config ) { $ services = array ( ) ; $ travisServices = isset ( $ config [ 'services' ] ) && is_array ( $ config [ 'services' ] ) ? $ config [ 'services' ] : array ( ) ; foreach ( $ travisServices as $ service ) { if ( isset ( $ this -> servicesMapping [ $ service ] ) ) { $ services [ ] = new Service ( $ service , $ this -> servicesMapping [ $ service ] [ 'repository' ] , $ this -> servicesMapping [ $ service ] [ 'tag' ] , $ this -> servicesMapping [ $ service ] [ 'config' ] ) ; } } return $ services ; }
3969	protected function deleteConditionSettings ( PreDeleteModelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ model = $ event -> getModel ( ) ; $ dataProvider = $ environment -> getDataProvider ( 'tl_metamodel_dcasetting_condition' ) ; $ conditions = $ dataProvider -> fetchAll ( $ dataProvider -> getEmptyConfig ( ) -> setFilter ( [ [ 'operation' => '=' , 'property' => 'attr_id' , 'value' => $ model -> getId ( ) ] ] ) ) ; if ( $ conditions -> count ( ) < 1 ) { return ; } $ conditionsGeneral = new \ DC_General ( $ dataProvider -> getEmptyModel ( ) -> getProviderName ( ) ) ; $ conditionsEnvironment = $ conditionsGeneral -> getEnvironment ( ) ; $ conditionsDataDefinition = $ conditionsEnvironment -> getDataDefinition ( ) ; $ conditionsPalettesDefinition = $ conditionsDataDefinition -> getPalettesDefinition ( ) ; $ conditionsIterator = $ conditions -> getIterator ( ) ; while ( $ currentCondition = $ conditionsIterator -> current ( ) ) { $ conditionPalette = $ conditionsPalettesDefinition -> getPaletteByName ( $ currentCondition -> getProperty ( 'type' ) ) ; $ conditionProperties = $ conditionPalette -> getVisibleProperties ( $ currentCondition ) ; foreach ( $ conditionProperties as $ conditionProperty ) { if ( $ conditionProperty -> getName ( ) !== 'attr_id' ) { continue ; } $ dataProvider -> delete ( $ currentCondition ) ; } $ conditionsIterator -> next ( ) ; } }
6457	public function redirectToUri ( IHttpResponseMessage $ response , $ uri , int $ statusCode = 302 ) : void { if ( is_string ( $ uri ) ) { $ uriString = $ uri ; } elseif ( $ uri instanceof Uri ) { $ uriString = ( string ) $ uri ; } else { throw new InvalidArgumentException ( 'Uri must be instance of ' . Uri :: class . ' or string' ) ; } $ response -> setStatusCode ( $ statusCode ) ; $ response -> getHeaders ( ) -> add ( 'Location' , $ uriString ) ; }
2672	public function upsertDictionaryItem ( $ dictionaryId , $ itemKey , $ itemValue ) { $ body = [ 'item_value' => $ itemValue ] ; $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/item/' . urlencode ( $ itemKey ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ body ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create Dictionary item.' ) ) ; } }
8073	public function post ( $ endpoint , $ data , $ headers = [ ] ) { $ request = new Request ( 'POST' , $ endpoint , $ headers , $ data ) ; $ response = $ this -> guzzle -> send ( $ request ) ; return $ this -> handle ( $ response ) ; }
11220	private static function cleanResources ( ) { self :: $ callbacks = [ ] ; self :: $ methods = [ ] ; self :: $ halts = false ; self :: $ response = false ; }
7555	function match ( $ conditions , $ match = true , $ custom_filters = array ( ) ) { $ t = isset ( $ conditions [ 'tags' ] ) ; $ a = isset ( $ conditions [ 'attributes' ] ) ; $ f = isset ( $ conditions [ 'filters' ] ) ; if ( ! ( $ t || $ a || $ f ) ) { if ( is_array ( $ conditions ) && $ conditions ) { foreach ( $ conditions as $ c ) { if ( $ this -> match ( $ c , $ match ) ) { return true ; } } } return false ; } else { if ( ( $ t && ( ! $ this -> match_tags ( $ conditions [ 'tags' ] ) ) ) === $ match ) { return false ; } if ( ( $ a && ( ! $ this -> match_attributes ( $ conditions [ 'attributes' ] ) ) ) === $ match ) { return false ; } if ( ( $ f && ( ! $ this -> match_filters ( $ conditions [ 'filters' ] , $ custom_filters ) ) ) === $ match ) { return false ; } return true ; } }
11313	public static function buildBasestring ( $ method , Url $ url , array $ data ) { $ base = array ( ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedMethod ( $ method ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedUrl ( $ url ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedParameters ( $ data ) ) ; return implode ( '&' , $ base ) ; }
8368	private static function validateConfig ( array $ config ) { if ( isset ( $ config [ 'name' ] ) === false ) { throw new BadUse ( 'there\'s no name in mapping configuration' ) ; } if ( isset ( $ config [ 'schema' ] ) === false ) { throw new BadUse ( 'there\'s no schema in mapping configuration' ) ; } if ( isset ( $ config [ 'provider' ] ) === false ) { throw new BadUse ( 'there\'s no provider in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] ) === false ) { throw new BadUse ( 'there\'s no models in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] [ 'path' ] ) === false ) { throw new BadUse ( 'there\'s no models.path in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] [ 'namespace' ] ) === false ) { throw new BadUse ( 'there\'s no models.namespace in mapping configuration' ) ; } }
12610	public function getParents ( ) { $ parents = [ ] ; foreach ( $ this -> _parents as $ key => $ parent ) { if ( ! $ parent -> active ) { continue ; } $ parents [ $ key ] = $ parent ; } return $ parents ; }
1960	public static function decode ( $ strDomain ) { if ( $ strDomain == '' ) { return '' ; } $ objPunycode = new Punycode ( ) ; try { return $ objPunycode -> decode ( $ strDomain ) ; } catch ( LabelOutOfBoundsException $ e ) { return '' ; } }
547	protected function addServers ( $ cache , $ servers ) { if ( empty ( $ servers ) ) { $ servers = [ new MemCacheServer ( [ 'host' => '127.0.0.1' , 'port' => 11211 , ] ) ] ; } else { foreach ( $ servers as $ server ) { if ( $ server -> host === null ) { throw new InvalidConfigException ( "The 'host' property must be specified for every memcache server." ) ; } } } if ( $ this -> useMemcached ) { $ this -> addMemcachedServers ( $ cache , $ servers ) ; } else { $ this -> addMemcacheServers ( $ cache , $ servers ) ; } }
8042	protected function calculateEventLength ( array $ data ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ data [ 'start' ] [ 'date' ] . ' ' . $ data [ 'start' ] [ 'time' ] ) ) ; if ( array_key_exists ( 'all_day' , $ data ) ) { $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ data [ 'start' ] [ 'date' ] . ' 23:59:59' ) ) ; } else { $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ data [ 'start' ] [ 'date' ] . ' ' . $ data [ 'end' ] [ 'time' ] ) ) ; } return $ start -> diffInSeconds ( $ end ) ; }
4433	public function createSubscriber ( array $ channels ) : WatchdogSubscriber { $ redis = clone $ this -> redis ; $ redis -> disconnect ( ) ; $ redis -> connect ( ) ; return new WatchdogSubscriber ( $ redis , $ channels ) ; }
5200	public function setOptions ( array $ options ) { $ this -> validateOptions ( $ options ) ; foreach ( $ options as $ option => $ value ) $ this -> $ option = $ value ; return $ this ; }
10301	private function writeLayout ( XMLWriter $ objWriter , Layout $ layout = null ) { $ objWriter -> startElement ( 'c:layout' ) ; if ( $ layout !== null ) { $ objWriter -> startElement ( 'c:manualLayout' ) ; $ layoutTarget = $ layout -> getLayoutTarget ( ) ; if ( $ layoutTarget !== null ) { $ objWriter -> startElement ( 'c:layoutTarget' ) ; $ objWriter -> writeAttribute ( 'val' , $ layoutTarget ) ; $ objWriter -> endElement ( ) ; } $ xMode = $ layout -> getXMode ( ) ; if ( $ xMode !== null ) { $ objWriter -> startElement ( 'c:xMode' ) ; $ objWriter -> writeAttribute ( 'val' , $ xMode ) ; $ objWriter -> endElement ( ) ; } $ yMode = $ layout -> getYMode ( ) ; if ( $ yMode !== null ) { $ objWriter -> startElement ( 'c:yMode' ) ; $ objWriter -> writeAttribute ( 'val' , $ yMode ) ; $ objWriter -> endElement ( ) ; } $ x = $ layout -> getXPosition ( ) ; if ( $ x !== null ) { $ objWriter -> startElement ( 'c:x' ) ; $ objWriter -> writeAttribute ( 'val' , $ x ) ; $ objWriter -> endElement ( ) ; } $ y = $ layout -> getYPosition ( ) ; if ( $ y !== null ) { $ objWriter -> startElement ( 'c:y' ) ; $ objWriter -> writeAttribute ( 'val' , $ y ) ; $ objWriter -> endElement ( ) ; } $ w = $ layout -> getWidth ( ) ; if ( $ w !== null ) { $ objWriter -> startElement ( 'c:w' ) ; $ objWriter -> writeAttribute ( 'val' , $ w ) ; $ objWriter -> endElement ( ) ; } $ h = $ layout -> getHeight ( ) ; if ( $ h !== null ) { $ objWriter -> startElement ( 'c:h' ) ; $ objWriter -> writeAttribute ( 'val' , $ h ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; }
5032	public function getLoadedPage ( $ default = null ) { if ( ! $ this -> loadedPage ) { if ( is_callable ( $ default ) ) { $ page = call_user_func ( $ default , $ this ) ; if ( $ page !== null ) { $ this -> setLoadedPage ( $ page ) ; } } if ( ! $ this -> loadedPage ) { throw new NotFoundHttpException ( "There is no page currently loaded, but it was expected" ) ; } } return $ this -> loadedPage ; }
9871	private function writeBreaks ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ aRowBreaks = [ ] ; $ aColumnBreaks = [ ] ; foreach ( $ pSheet -> getBreaks ( ) as $ cell => $ breakType ) { if ( $ breakType == PhpspreadsheetWorksheet :: BREAK_ROW ) { $ aRowBreaks [ ] = $ cell ; } elseif ( $ breakType == PhpspreadsheetWorksheet :: BREAK_COLUMN ) { $ aColumnBreaks [ ] = $ cell ; } } if ( ! empty ( $ aRowBreaks ) ) { $ objWriter -> startElement ( 'rowBreaks' ) ; $ objWriter -> writeAttribute ( 'count' , count ( $ aRowBreaks ) ) ; $ objWriter -> writeAttribute ( 'manualBreakCount' , count ( $ aRowBreaks ) ) ; foreach ( $ aRowBreaks as $ cell ) { $ coords = Coordinate :: coordinateFromString ( $ cell ) ; $ objWriter -> startElement ( 'brk' ) ; $ objWriter -> writeAttribute ( 'id' , $ coords [ 1 ] ) ; $ objWriter -> writeAttribute ( 'man' , '1' ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } if ( ! empty ( $ aColumnBreaks ) ) { $ objWriter -> startElement ( 'colBreaks' ) ; $ objWriter -> writeAttribute ( 'count' , count ( $ aColumnBreaks ) ) ; $ objWriter -> writeAttribute ( 'manualBreakCount' , count ( $ aColumnBreaks ) ) ; foreach ( $ aColumnBreaks as $ cell ) { $ coords = Coordinate :: coordinateFromString ( $ cell ) ; $ objWriter -> startElement ( 'brk' ) ; $ objWriter -> writeAttribute ( 'id' , Coordinate :: columnIndexFromString ( $ coords [ 0 ] ) - 1 ) ; $ objWriter -> writeAttribute ( 'man' , '1' ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
9845	public function createSymmetricEncryptedRequest ( string $ method , string $ uri , string $ body , SharedEncryptionKey $ key , array $ headers = [ ] ) : RequestInterface { return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: encrypt ( $ body , $ key ) ) ) , [ ] ) ; }
5617	public function getTotalSize ( ) { if ( ! isset ( $ this -> _size ) ) { $ size = $ this -> getSize ( ) ; if ( ! $ this -> isLeaf ( ) ) { foreach ( $ this -> getChildren ( ) as $ child ) { $ size += $ child -> getTotalSize ( ) ; } } $ this -> _size = $ size ; } return $ this -> _size ; }
7180	public function getTypes ( ) { if ( is_string ( $ this -> type ) ) { $ types = array ( $ this -> type ) ; } elseif ( is_array ( $ this -> type ) ) { $ types = $ this -> type ; } else { $ types = array ( ) ; } $ types = array_filter ( $ types , array ( $ this , 'isValidType' ) ) ; return empty ( $ types ) ? array ( self :: ANY ) : $ types ; }
9668	private function writePatternFill ( XMLWriter $ objWriter , Fill $ pFill ) { $ objWriter -> startElement ( 'fill' ) ; $ objWriter -> startElement ( 'patternFill' ) ; $ objWriter -> writeAttribute ( 'patternType' , $ pFill -> getFillType ( ) ) ; if ( $ pFill -> getFillType ( ) !== Fill :: FILL_NONE ) { if ( $ pFill -> getStartColor ( ) -> getARGB ( ) ) { $ objWriter -> startElement ( 'fgColor' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getStartColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } } if ( $ pFill -> getFillType ( ) !== Fill :: FILL_NONE ) { if ( $ pFill -> getEndColor ( ) -> getARGB ( ) ) { $ objWriter -> startElement ( 'bgColor' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getEndColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
10724	public function getNumRows ( ) { $ builtSql = SqlBuilder :: buildRowCountSql ( $ this ) ; if ( is_array ( $ builtSql ) ) { $ preparedSth = $ this -> connect ( ) -> prepare ( $ builtSql [ 0 ] ) ; $ boundSth = StatementBuilder :: bindValues ( $ preparedSth , $ builtSql [ 1 ] ) ; $ boundSth -> execute ( ) ; } else { $ boundSth = $ this -> connect ( ) -> query ( $ builtSql ) ; } $ result = $ boundSth -> fetch ( PDO :: FETCH_ASSOC ) ; return ( int ) $ result [ 'total_count' ] ; }
6311	public function getTable ( Table $ table ) { return $ this -> container -> get ( 'rentgen.get_table' ) -> setTableName ( $ table -> getName ( ) ) -> execute ( ) ; }
7646	protected function getFileName ( $ path ) { $ url = parse_url ( $ path ) ; if ( $ url [ 'host' ] ) { $ fileName = isset ( $ url [ 'path' ] ) ? $ url [ 'path' ] : $ url [ 'host' ] ; if ( strpos ( $ fileName , '/' ) === 0 ) { $ fileName = substr ( $ fileName , 1 ) ; } return $ fileName ; } return '' ; }
4295	public function alert ( $ message , $ class = 'danger' , $ dismissible = false ) { array ( $ class , $ dismissible ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'message' => null , 'class' => 'danger' , 'dismissible' => false , ) , array ( 'class' , 'dismissible' ) ) ; \ extract ( $ args ) ; $ this -> setLogDest ( 'alerts' ) ; $ this -> appendLog ( 'alert' , array ( $ message ) , $ meta ) ; $ this -> setLogDest ( 'auto' ) ; }
6568	protected function createMigration ( ) { $ app = app ( ) ; $ migrationFiles = array ( $ this -> laravel -> path . "/database/migrations/*_create_countries_table.php" => 'countries::generators.migration' , ) ; $ seconds = 0 ; foreach ( $ migrationFiles as $ migrationFile => $ outputFile ) { if ( sizeof ( glob ( $ migrationFile ) ) == 0 ) { $ migrationFile = str_replace ( '*' , date ( 'Y_m_d_His' , strtotime ( '+' . $ seconds . ' seconds' ) ) , $ migrationFile ) ; $ fs = fopen ( $ migrationFile , 'x' ) ; if ( $ fs ) { $ output = "<?php\n\n" . $ app [ 'view' ] -> make ( $ outputFile ) -> with ( 'table' , 'countries' ) -> render ( ) ; fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; } else { return false ; } $ seconds ++ ; } } $ seeder_file = $ this -> laravel -> path . "/database/seeds/CountriesSeeder.php" ; $ output = "<?php\n\n" . $ app [ 'view' ] -> make ( 'countries::generators.seeder' ) -> render ( ) ; if ( ! file_exists ( $ seeder_file ) ) { $ fs = fopen ( $ seeder_file , 'x' ) ; if ( $ fs ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; } else { return false ; } } return true ; }
12407	public function set ( $ key , $ value ) { try { $ filenameCache = $ this -> location . DS . $ key ; file_put_contents ( $ filenameCache , $ value ) ; } catch ( \ Exception $ e ) { return false ; } return true ; }
12897	public function to ( string $ path , int $ status = 301 , array $ headers = array ( ) ) { return $ this -> makeRedirect ( $ path , $ status , $ headers ) ; }
568	private function formatTimestamp ( $ timestamp , $ format ) { if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } $ date = new DateTime ( ) ; $ date -> setTimestamp ( $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ this -> timestampAttributeTimeZone ) ) ; return $ date -> format ( $ format ) ; }
1815	public function tableImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=table' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a> ' . Contao \ Image :: getHtml ( 'demagnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_shrink' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(0.9)"' ) . Contao \ Image :: getHtml ( 'magnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_expand' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(1.1)"' ) ; }
3427	public function addFilter ( $ filters ) { foreach ( $ filters as $ field => $ value ) { $ this -> filter [ $ field ] = $ value ; } return $ this ; }
11980	protected function query ( $ api , $ from , $ to ) { $ params = [ 'begin_date' => $ from , 'end_date' => $ to , ] ; return $ this -> parseJSON ( 'json' , [ $ api , $ params ] ) ; }
3446	private function getAccessorForLanguageField ( $ field ) { $ method = 'getValueFromLanguageField' ; return in_array ( $ field , $ this -> languageAccessors ) && method_exists ( $ this , $ method ) ? $ method : false ; }
3546	public function create ( $ request ) { $ data = $ request -> all ( ) ; $ user = $ this -> repository -> create ( $ data ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ user ) ) ; return $ user ; }
4937	protected function createNestedOptions ( $ className , $ options ) { $ class = new $ className ( ) ; foreach ( $ options as $ key => $ spec ) { if ( is_array ( $ spec ) && array_key_exists ( '__class__' , $ spec ) ) { $ nestedClassName = $ spec [ '__class__' ] ; unset ( $ spec [ '__class__' ] ) ; $ spec = $ this -> createNestedOptions ( $ nestedClassName , $ spec ) ; } $ class -> { $ key } = $ spec ; } return $ class ; }
9207	public function importTable ( Table $ Table , $ records , array $ options = [ ] ) { $ defaultOptions = [ 'checkRules' => true , 'checkExisting' => true , ] ; $ options = $ options + $ defaultOptions ; foreach ( $ records as $ record ) { $ action = ( $ record -> isNew ( ) ? 'Create' : 'Update' ) ; $ result = $ Table -> save ( $ record , $ options ) ; $ key = $ this -> findKey ( $ Table , $ record ) ; if ( $ result ) { $ this -> verbose ( "<success>{$Table->alias()} ({$key}): {$action} successful.</success>" ) ; } else { $ this -> quiet ( "<warning>{$Table->alias()} ({$key}): {$action} failed.</warning>" ) ; $ this -> printValidationErrors ( $ Table -> alias ( ) , $ this -> findKey ( $ Table , $ record ) , $ record -> errors ( ) ) ; } } }
9131	public function load ( $ file , $ type = null ) { $ path = $ this -> locator -> locate ( $ file ) ; if ( ! stream_is_local ( $ path ) ) { throw new \ InvalidArgumentException ( sprintf ( 'This is not a local file "%s".' , $ path ) ) ; } if ( ! file_exists ( $ path ) ) { throw new \ InvalidArgumentException ( sprintf ( 'File "%s" not found.' , $ path ) ) ; } if ( null === $ this -> yamlParser ) { $ this -> yamlParser = new YamlParser ( ) ; } $ config = $ this -> yamlParser -> parse ( file_get_contents ( $ path ) ) ; $ collection = new RuleCollection ( ) ; $ collection -> addResource ( new FileResource ( $ path ) ) ; if ( null === $ config ) { return $ collection ; } if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The file "%s" must contain a YAML array.' , $ path ) ) ; } foreach ( $ config as $ name => $ subConfig ) { $ this -> validate ( $ subConfig , $ name , $ path ) ; if ( isset ( $ subConfig [ 'resource' ] ) ) { $ this -> parseImport ( $ collection , $ subConfig , $ path , $ file ) ; } else { $ this -> parseRule ( $ collection , $ name , $ subConfig , $ path ) ; } } return $ collection ; }
8799	public function make ( $ value , array $ options = [ ] ) { $ hash = password_hash ( $ value , PASSWORD_ARGON2I , [ 'memory_cost' => $ this -> memory ( $ options ) , 'time_cost' => $ this -> time ( $ options ) , 'threads' => $ this -> threads ( $ options ) , ] ) ; if ( $ hash === false ) { throw new RuntimeException ( 'Argon2 hashing not supported.' ) ; } return $ hash ; }
874	public function getAnnotationsOfType ( $ types ) { $ annotations = [ ] ; $ types = ( array ) $ types ; foreach ( $ this -> getAnnotations ( ) as $ annotation ) { $ tag = $ annotation -> getTag ( ) -> getName ( ) ; foreach ( $ types as $ type ) { if ( $ type === $ tag ) { $ annotations [ ] = $ annotation ; } } } return $ annotations ; }
1594	protected function validateType ( ) : bool { if ( ! $ this -> dataHas ( 'type' ) ) { $ this -> memberRequired ( '/data' , 'type' ) ; return false ; } $ value = $ this -> dataGet ( 'type' ) ; if ( ! $ this -> validateTypeMember ( $ value , '/data' ) ) { return false ; } if ( $ this -> expectedType !== $ value ) { $ this -> resourceTypeNotSupported ( $ value ) ; return false ; } return true ; }
11531	public static function slotDir ( $ sourceDir , array $ options ) { $ paths = array ( sprintf ( '%s/pages/pages/%s/%s_%s/%s' , $ sourceDir , $ options [ 'page' ] , $ options [ 'language' ] , $ options [ 'country' ] , $ options [ 'slot' ] ) , sprintf ( '%s/slots/%s/%s_%s' , $ sourceDir , $ options [ 'slot' ] , $ options [ 'language' ] , $ options [ 'country' ] ) , sprintf ( '%s/slots/%s' , $ sourceDir , $ options [ 'slot' ] ) , ) ; return self :: cascade ( $ paths ) ; }
7458	public function background ( ) : Font { if ( $ this -> color !== null ) { $ this -> turnToBackground ( ) ; } $ this -> background = true ; return $ this ; }
4715	public function split ( $ pattern , $ flags = PREG_SPLIT_DELIM_CAPTURE ) { return new Collection ( array_map ( function ( $ item ) { return new static ( $ item ) ; } , preg_split ( $ pattern , $ this -> text , - 1 , $ flags ) ) ) ; }
6012	public function addCommentResponse ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate CommentResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "CommentResponse"!' , E_USER_WARNING ) ; } } $ this -> replies [ ] = $ item ; return $ this ; }
8545	public function setGuaranteeClaimEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GuaranteeClaimEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1361	public function is ( string ... $ mediaTypes ) : bool { $ mediaTypes = collect ( $ mediaTypes ) -> map ( function ( $ mediaType , $ index ) { return MediaType :: parse ( $ index , $ mediaType ) ; } ) ; return $ this -> any ( ... $ mediaTypes ) ; }
5626	public function addRequestParameter ( $ key , $ value ) { $ this -> raw = false ; $ this -> request -> add ( $ key , $ value ) ; }
5555	public function getUrls ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getUrls ( ) ; } $ urls = array ( ) ; foreach ( $ this -> frames as $ frame ) { $ urls = array_merge ( $ urls , $ frame -> getUrls ( ) ) ; } return array_values ( array_unique ( $ urls ) ) ; }
1625	public static function updateAllCounters ( $ counters , $ condition = null ) { if ( empty ( $ counters ) ) { return 0 ; } $ db = static :: getDb ( ) ; $ n = 0 ; foreach ( self :: fetchPks ( $ condition ) as $ pk ) { $ key = static :: keyPrefix ( ) . ':a:' . static :: buildKey ( $ pk ) ; foreach ( $ counters as $ attribute => $ value ) { $ db -> executeCommand ( 'HINCRBY' , [ $ key , $ attribute , $ value ] ) ; } $ n ++ ; } return $ n ; }
3304	public function appendSignature ( array $ params = [ ] , $ timestamp = '' , $ noncestr = '' ) { $ params += [ 'app_id' => $ this -> appId , 'time_stamp' => $ timestamp ? : time ( ) , 'nonce_str' => $ noncestr ? : md5 ( uniqid ( ) ) ] ; if ( isset ( $ params [ 'app_key' ] ) ) { unset ( $ params [ 'app_key' ] ) ; } ksort ( $ params ) ; $ params [ 'sign' ] = strtoupper ( md5 ( http_build_query ( $ params + [ 'app_key' => $ this -> appKey ] ) ) ) ; return $ params ; }
10308	private function setGlowSize ( $ size ) { if ( $ size !== null ) { $ this -> glowProperties [ 'size' ] = $ this -> getExcelPointsWidth ( $ size ) ; } return $ this ; }
5079	public function postRemap ( ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'post' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ aFields = $ oItemModel -> describeFields ( ) ; $ aValid = [ ] ; $ aInvalid = [ ] ; foreach ( $ aFields as $ oField ) { if ( in_array ( $ oField -> key , static :: CONFIG_POST_IGNORE_FIELDS ) ) { continue ; } $ aValid [ ] = $ oField -> key ; } $ aPost = $ oInput -> post ( ) ; foreach ( $ aPost as $ sKey => $ sValue ) { if ( ! in_array ( $ sKey , $ aValid ) ) { $ aInvalid [ ] = $ sKey ; } } if ( ! empty ( $ aInvalid ) ) { throw new ApiException ( 'The following arguments are invalid: ' . implode ( ', ' , $ aInvalid ) , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ iItemId = ( int ) $ oUri -> segment ( 4 ) ; if ( $ iItemId ) { $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( empty ( $ oItem ) ) { throw new ApiException ( 'Item does not exist' , $ oHttpCodes :: STATUS_NOT_FOUND ) ; } elseif ( ! $ oItemModel -> update ( $ iItemId , $ aPost ) ) { throw new ApiException ( 'Failed to update item. ' . $ oItemModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } elseif ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> disableCache ( ) ; } $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> enableCache ( ) ; } } else { $ oItem = $ oItemModel -> create ( $ aPost , true ) ; } $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
11865	public function get ( string $ sessionIdentifier ) : string { if ( ! $ this -> sessionExists ( $ sessionIdentifier ) ) { throw new SessionNotFoundException ( ) ; } return self :: $ files [ $ sessionIdentifier ] [ 'data' ] ; }
8556	private function fromDOMElement ( DOMElement $ dom ) { $ xpath = new DOMXPath ( $ dom -> ownerDocument ) ; $ xpath -> registerNamespace ( 'a' , 'http://mws.amazonaws.com/doc/2009-01-01/' ) ; foreach ( $ this -> fields as $ fieldName => $ field ) { $ fieldType = $ field [ 'FieldType' ] ; if ( is_array ( $ fieldType ) ) { if ( $ this -> isComplexType ( $ fieldType [ 0 ] ) ) { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length >= 1 ) { foreach ( $ elements as $ element ) { $ this -> fields [ $ fieldName ] [ 'FieldValue' ] [ ] = new $ fieldType [ 0 ] ( $ element ) ; } } } else { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length >= 1 ) { foreach ( $ elements as $ element ) { $ text = $ xpath -> query ( './text()' , $ element ) ; $ this -> fields [ $ fieldName ] [ 'FieldValue' ] [ ] = $ text -> item ( 0 ) -> data ; } } } } else { if ( $ this -> isComplexType ( $ fieldType ) ) { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length == 1 ) { $ this -> fields [ $ fieldName ] [ 'FieldValue' ] = new $ fieldType ( $ elements -> item ( 0 ) ) ; } } else { $ element = $ xpath -> query ( "./a:$fieldName/text()" , $ dom ) ; $ data = null ; if ( $ element -> length == 1 ) { switch ( $ this -> fields [ $ fieldName ] [ 'FieldType' ] ) { case 'DateTime' : $ data = new DateTime ( $ element -> item ( 0 ) -> data , new DateTimeZone ( 'UTC' ) ) ; break ; case 'bool' : $ value = $ element -> item ( 0 ) -> data ; $ data = $ value === 'true' ? true : false ; break ; default : $ data = $ element -> item ( 0 ) -> data ; break ; } $ this -> fields [ $ fieldName ] [ 'FieldValue' ] = $ data ; } } } } }
4560	public function translate ( Translatable $ model ) { $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ get = 'get' . $ property -> getName ( ) ; $ set = 'set' . $ property -> getName ( ) ; $ values = [ ] ; foreach ( $ model -> getTranslations ( ) as $ translation ) { $ values [ $ translation -> getLocale ( ) ] = $ translation -> $ get ( ) ; } $ model -> $ set ( $ values ) ; } }
10910	public function decorate ( callable $ decorator ) : Binding { if ( empty ( $ this -> definition -> decorators ) ) { $ this -> definition -> decorators = [ ] ; } $ this -> definition -> decorators [ ] = new Decorator ( $ decorator ) ; return $ this ; }
11061	public static function supportedEncodings ( ) { if ( static :: $ supported_encodings === null ) { $ supported = mb_list_encodings ( ) ; foreach ( $ supported as $ key => $ value ) { static :: $ supported_encodings [ strtolower ( $ value ) ] = $ value ; foreach ( mb_encoding_aliases ( $ value ) as $ k => $ v ) { static :: $ supported_encodings [ strtolower ( $ v ) ] = $ value ; } } } return static :: $ supported_encodings ; }
2358	public function getBackendUsername ( ) : ? string { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof BackendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; }
1296	private function getUnresolvedField ( Field $ field , string $ locale = null ) { if ( ! isset ( $ this -> fields [ $ field -> getId ( ) ] ) ) { return 'Array' === $ field -> getType ( ) ? [ ] : null ; } $ value = $ this -> fields [ $ field -> getId ( ) ] ; $ locale = $ this -> getLocaleFromInput ( $ locale ) ; if ( \ array_key_exists ( $ locale , $ value ) ) { return $ value [ $ locale ] ; } if ( ! $ field -> isLocalized ( ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to access the non-localized field "%s" on content type "%s" using the non-default locale "%s".' , $ field -> getName ( ) , $ this -> sys -> getContentType ( ) -> getName ( ) , $ locale ) ) ; } $ locale = $ this -> walkFallbackChain ( $ value , $ locale , $ this -> sys -> getEnvironment ( ) ) ; if ( $ locale ) { return $ value [ $ locale ] ; } return 'Array' === $ field -> getType ( ) ? [ ] : null ; }
10542	public static function createFromApplication ( Application $ app ) { $ dispatch = new static ( $ app -> request , $ app -> resolver , $ app -> config ) ; $ dispatch -> setApplication ( $ app ) ; return $ dispatch ; }
3888	public function getAttributeNames ( \ DC_Table $ objDc ) { $ attributeNames = [ 'sorting' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodels_sorting' ] , 'random' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'random' ] , 'id' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'id' ] [ 0 ] ] ; $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ objDc -> activeRecord -> metamodel ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( $ metaModel ) { foreach ( $ metaModel -> getAttributes ( ) as $ objAttribute ) { $ attributeNames [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; } } return $ attributeNames ; }
7942	public function addSecondaryDnsDomains ( $ domain , $ domain2add , $ ip ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ domain2add = ( string ) $ domain2add ; if ( ! $ domain2add ) throw new BadMethodCallException ( 'Parameter $domain2add is missing.' ) ; $ ip = ( string ) $ ip ; if ( ! $ ip ) throw new BadMethodCallException ( 'Parameter $ip is missing.' ) ; $ payload = array ( "domain" => $ domain2add , "ip" => $ ip ) ; try { $ r = $ this -> post ( 'dedicated/server/' . $ domain . '/secondaryDnsDomains' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
1440	protected function getResourceName ( ) { $ name = ucwords ( $ this -> getResourceInput ( ) ) ; if ( $ this -> isByResource ( ) ) { return str_plural ( $ name ) ; } return $ name ; }
3414	public function fill ( $ fields ) { if ( ! is_array ( $ fields ) ) { return ; } if ( isset ( $ fields [ 'ID' ] ) ) { $ this -> id = $ fields [ 'ID' ] ; } $ this -> fields = $ fields ; $ this -> fieldsAreFetched = true ; if ( method_exists ( $ this , 'afterFill' ) ) { $ this -> afterFill ( ) ; } $ this -> original = $ this -> fields ; }
5440	public function addEntryPattern ( $ pattern , $ mode , $ new_mode ) { if ( ! isset ( $ this -> regexes [ $ mode ] ) ) { $ this -> regexes [ $ mode ] = new ParallelRegex ( $ this -> case ) ; } $ this -> regexes [ $ mode ] -> addPattern ( $ pattern , $ new_mode ) ; if ( ! isset ( $ this -> mode_handlers [ $ new_mode ] ) ) { $ this -> mode_handlers [ $ new_mode ] = $ new_mode ; } }
383	public function getExceptionName ( $ exception ) { if ( $ exception instanceof \ yii \ base \ Exception || $ exception instanceof \ yii \ base \ InvalidCallException || $ exception instanceof \ yii \ base \ InvalidParamException || $ exception instanceof \ yii \ base \ UnknownMethodException ) { return $ exception -> getName ( ) ; } return null ; }
3186	public function start ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'start() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { \ common_Logger :: t ( 'Missing END TimePoint in QtiTimer, auto add an arbitrary value' ) ; $ point = new TimePoint ( $ tags , $ timestamp - ( 1 / TimePoint :: PRECISION ) , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; $ range [ ] = $ point ; } $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_START , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; return $ this ; }
3571	public function queryHook ( ) { return function ( $ next , $ query , $ bag ) { $ method = $ bag -> get ( 'method' ) ; $ args = $ bag -> get ( 'args' ) ; $ column = $ args -> get ( 'column' ) ; if ( ! $ this -> hasColumn ( $ column ) && $ this -> allowsMeta ( $ column ) && $ this -> isMetaQueryable ( $ method ) ) { return call_user_func_array ( [ $ this , 'metaQuery' ] , [ $ query , $ method , $ args ] ) ; } if ( in_array ( $ method , [ 'select' , 'addSelect' ] ) ) { call_user_func_array ( [ $ this , 'metaSelect' ] , [ $ query , $ args ] ) ; } return $ next ( $ query , $ bag ) ; } ; }
12704	public function getTitleAttribute ( $ value ) { if ( $ value === null ) { $ value = '' ; } if ( getenv ( "BYPASS_HOOKS" ) != true ) { global $ hooks , $ codes ; return $ hooks -> apply_filters ( "TCT-Core-Main-Model-Page-Title" , $ codes -> do_shortcode ( $ value ) ) ; } else { return $ value ; } }
1435	public static function underscore ( $ value ) { if ( isset ( self :: $ underscored [ $ value ] ) ) { return self :: $ underscored [ $ value ] ; } return self :: $ underscored [ $ value ] = str_replace ( '-' , '_' , self :: decamelize ( $ value ) ) ; }
7937	public function createBackupFTPAccess ( $ domain , $ ipBlock ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; $ payload = array ( 'ftp' => ( 1 == 1 ) , 'ipBlock' => $ ipBlock , 'nfs' => ( 1 == 0 ) , 'cifs' => ( 1 == 0 ) ) ; try { $ r = $ this -> post ( 'dedicated/server/' . $ domain . '/features/backupFTP/access' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
2954	protected function findTemplate ( $ text ) { $ matchedTemplate = [ ] ; $ maxMatch = - 1 ; foreach ( $ this -> directoryIterator as $ fileInfo ) { $ templateContent = file_get_contents ( $ fileInfo -> getPathname ( ) ) ; similar_text ( $ text , $ templateContent , $ matchPercentage ) ; if ( $ matchPercentage > $ maxMatch ) { $ this -> logger -> debug ( sprintf ( 'Template "%s" is a best match for now' , $ fileInfo -> getPathname ( ) ) ) ; $ maxMatch = $ matchPercentage ; $ matchedTemplate = [ $ fileInfo -> getPathname ( ) => $ templateContent ] ; } } return $ matchedTemplate ; }
7656	function AddReplyTo ( $ address , $ name = "" ) { $ cur = count ( $ this -> ReplyTo ) ; $ this -> ReplyTo [ $ cur ] [ 0 ] = trim ( $ address ) ; $ this -> ReplyTo [ $ cur ] [ 1 ] = $ name ; }
6782	public function setFormParameters ( $ optionNames ) { foreach ( ( array ) $ optionNames as $ option ) { $ this -> formParameters [ $ option ] = true ; } return $ this ; }
7789	public function setTransactionClass ( $ transactionClass ) { if ( ! is_callable ( $ transactionClass ) && ! class_exists ( $ transactionClass ) ) { throw new \ InvalidArgumentException ( '$transactionClass must be a valid classname or a PHP callable' ) ; } $ this -> transactionClass = $ transactionClass ; return $ this ; }
5850	protected function buildForm ( array $ row ) { $ record = [ 'uid' => static :: virtualRecordId , 'pid' => 0 , ] ; $ record = array_merge ( $ record , $ row ) ; $ dataProviders = & $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'formEngine' ] [ 'formDataGroup' ] [ 'tcaDatabaseRecord' ] ; $ dataProviders [ \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: class ] = [ 'before' => [ \ TYPO3 \ CMS \ Backend \ Form \ FormDataProvider \ DatabaseEditRow :: class , ] ] ; \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: initialize ( $ record ) ; $ formDataGroup = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormDataGroup \ TcaDatabaseRecord :: class ) ; $ formDataCompiler = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormDataCompiler :: class , $ formDataGroup ) ; $ nodeFactory = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ NodeFactory :: class ) ; $ formDataCompilerInput = [ 'tableName' => static :: virtualTable , 'vanillaUid' => $ record [ 'uid' ] , 'command' => 'edit' , 'returnUrl' => '' , ] ; $ this -> loadVirtualTca ( ) ; $ formData = $ formDataCompiler -> compile ( $ formDataCompilerInput ) ; $ formData [ 'renderType' ] = 'outerWrapContainer' ; $ formResult = $ nodeFactory -> create ( $ formData ) -> render ( ) ; $ html = preg_replace ( '/<h1>.*<\/h1>/' , '' , $ formResult [ 'html' ] ) ; $ startFooter = strrpos ( $ html , '<div class="help-block text-right">' ) ; $ endTag = '</div>' ; if ( $ startFooter !== false ) { $ endFooter = strpos ( $ html , $ endTag , $ startFooter ) ; $ html = substr ( $ html , 0 , $ startFooter ) . substr ( $ html , $ endFooter + strlen ( $ endTag ) ) ; } $ formResult [ 'html' ] = '' ; $ formResult [ 'doSaveFieldName' ] = 'doSave' ; $ this -> formResultCompiler -> mergeResult ( $ formResult ) ; $ formContent = ' <!-- EDITING FORM . $ html . ' <input type="hidden" name="returnUrl" value="' . htmlspecialchars ( $ this -> retUrl ) . '" /> <input type="hidden" name="closeDoc" value="0" /> <input type="hidden" name="doSave" value="0" /> <input type="hidden" name="_serialNumber" value="' . md5 ( microtime ( ) ) . '" /> <input type="hidden" name="_scrollPosition" value="" />' ; $ overriddenAjaxUrl = GeneralUtility :: quoteJSvalue ( BackendUtility :: getModuleUrl ( 'TxImageAutoresize::record_flex_container_add' ) ) ; $ formContent .= <<<HTML<script type="text/javascript"> TYPO3.settings.ajaxUrls['record_flex_container_add'] = $overriddenAjaxUrl;</script>HTML ; return $ formContent ; }
5167	protected function filterDateInstance ( $ date ) : string { if ( empty ( $ date ) ) { $ date = new \ DateTime ( 'now' , new \ DateTimeZone ( 'Asia/Jakarta' ) ) ; } if ( is_string ( $ date ) || is_int ( $ date ) ) { $ date = new \ DateTime ( $ date , new \ DateTimeZone ( 'Asia/Jakarta' ) ) ; } return $ this -> formatDate ( $ date ) ; }
6524	public function getHandlerMethodName ( $ withMajor = true ) { if ( true === $ withMajor ) { return lcfirst ( $ this -> classShortName ) ; } return lcfirst ( str_replace ( 'V' . $ this -> id -> getVersion ( ) -> getMajor ( ) , '' , $ this -> classShortName ) ) ; }
12616	public function setAttributes ( array $ attributes ) { foreach ( $ attributes as $ key => $ attribute ) { if ( ! ( $ attribute instanceof AttributeInterface ) ) { if ( is_array ( $ attribute ) ) { $ attr = new AttributeCollection ( $ key ) ; $ attr -> setAttributes ( $ attribute ) ; $ attribute = $ attr ; } else { $ attribute = new Attribute ( $ key , $ attribute ) ; } } $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; } }
3056	public function persistLastCatItemOutput ( array $ lastCatItemOutput ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> setCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-item-output' , json_encode ( $ lastCatItemOutput ) ) ; }
10341	protected function validateColumns ( $ columns ) { $ patterns = array ( '((?P<minute>(?:\*|(?:(?:[0-9]|[1-5][0-9])(?:-(?:[0-9]|[1-5][0-9]))?)(?:,(?:[0-9]|[1-5][0-9])(?:-(?:[0-9]|[1-5][0-9]))?)*)(?:/(?:[1-9]|[1-5][0-9]))?)$)AD' , '((?P<hour>(?:\*|(?:(?:[0-9]|1[0-9]|2[0-3])(?:-(?:[0-9]|1[0-9]|2[0-3]))?)(?:,(?:[0-9]|1[0-9]|2[0-3])(?:-(?:[0-9]|1[0-9]|2[0-3]))?)*)(?:/(?:[1-9]|1[0-9]|2[0-3]))?)$)AD' , '((?P<dayOfMonth>(?:\*|(?:(?:[1-9]|[1-2][0-9]|3[0-1])(?:-(?:[1-9]|[1-2][0-9]|3[0-1]))?)(?:,(?:[1-9]|[1-2][0-9]|3[0-1])(?:-(?:[1-9]|[1-2][0-9]|3[0-1]))?)*)(?:/(?:[1-9]|[1-2][0-9]|3[0-1]))?)$)AD' , '((?P<month>(?:\*|(?:(?:[1-9]|1[0-2])(?:-(?:[1-9]|1[1-2]))?)(?:,(?:[1-9]|1[1-2])(?:-(?:[1-9]|1[1-2]))?)*)(?:/(?:[1-9]|1[1-2]))?)$)AD' , '((?P<dayOfWeek>(?:\*|(?:(?:[0-7])(?:-(?:[0-7]))?)(?:,(?:[0-7])(?:-(?:[0-7]))?)*)(?:/(?:[1-7]))?)$)AD' , ) ; if ( count ( $ columns ) !== 5 ) { return false ; } foreach ( $ columns as $ key => $ column ) { if ( preg_match ( $ patterns [ $ key ] , $ column ) !== 1 ) { return ( int ) $ key ; } } return true ; }
5096	public function queryExists ( ) { foreach ( $ this -> selects as $ select ) { $ result = $ select -> queryExists ( ) ; if ( is_null ( $ result ) || $ result ) { return $ result ; } } return false ; }
12666	public function edit ( $ sourceDir , array $ options , $ username , $ values ) { $ this -> resolveOptions ( $ options ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ filename = sprintf ( '%s/blocks/%s.json' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ currentBlock = $ options [ "baseBlock" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; $ values = $ this -> parseChildren ( $ values ) ; $ block = JsonTools :: join ( $ currentBlock , $ values ) ; $ encodedBlock = json_encode ( $ block ) ; $ blockClass = BlockFactory :: getBlockClass ( $ block [ "type" ] ) ; $ event = Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITING , new BlockEditingEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; $ blockContent = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ filename , $ blockContent ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITED , new BlockEditedEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been edited on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
689	public function addRules ( $ rules , $ append = true ) { if ( ! $ this -> enablePrettyUrl ) { return ; } $ rules = $ this -> buildRules ( $ rules ) ; if ( $ append ) { $ this -> rules = array_merge ( $ this -> rules , $ rules ) ; } else { $ this -> rules = array_merge ( $ rules , $ this -> rules ) ; } }
5772	public function getRolesString ( ) : string { $ rolesString = "" ; foreach ( $ this -> roleNames as $ role ) { $ rolesString .= "$role, " ; } return Functions :: removeLastCharsFromString ( $ rolesString , 2 ) ; }
8210	protected function parseConnection ( $ connectionName ) { $ connection = null ; if ( $ connectionName ) { if ( ! $ connection = config ( "queue.connections.$connectionName" ) ) { throw new \ InvalidArgumentException ( "Connection '$connectionName' doesn't exist." ) ; } } if ( ! $ connection ) { $ defaultConnection = config ( 'queue.default' ) ; if ( 'beanstalkd' == config ( "queue.connections.$defaultConnection.driver" ) ) { $ connection = config ( "queue.connections.$defaultConnection" ) ; } } if ( ! $ connection ) { foreach ( config ( 'queue.connections' ) as $ connection ) { if ( 'beanstalkd' == $ connection [ 'driver' ] ) { break ; } } } if ( ! empty ( $ connection [ 'host' ] ) ) { $ parsedConfigHost = explode ( ':' , $ connection [ 'host' ] ) ; $ this -> host = $ parsedConfigHost [ 0 ] ; if ( isset ( $ parsedConfigHost [ 1 ] ) ) { $ this -> port = $ parsedConfigHost [ 1 ] ; } } if ( ! empty ( $ connection [ 'queue' ] ) ) { $ this -> defaultTube = $ connection [ 'queue' ] ; } }
7072	protected function getAttachmentFromEvent ( ResourceEventInterface $ event ) { $ attachment = $ event -> getResource ( ) ; if ( ! $ attachment instanceof TicketAttachmentInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketAttachmentInterface :: class ) ; } return $ attachment ; }
6486	public function createRequestFromSuperglobals ( array $ server ) : IHttpRequestMessage { $ method = $ server [ 'REQUEST_METHOD' ] ?? 'GET' ; if ( $ method === 'POST' && isset ( $ server [ 'X-HTTP-METHOD-OVERRIDE' ] ) ) { $ method = $ server [ 'X-HTTP-METHOD-OVERRIDE' ] ; } $ uri = $ this -> createUriFromSuperglobals ( $ server ) ; $ headers = $ this -> createHeadersFromSuperglobals ( $ server ) ; $ body = new StreamBody ( new Stream ( fopen ( 'php://input' , 'rb' ) ) ) ; $ properties = $ this -> createProperties ( $ server ) ; return new Request ( $ method , $ uri , $ headers , $ body , $ properties ) ; }
180	protected function loadDummyBundle ( $ name ) { if ( ! isset ( $ this -> _dummyBundles [ $ name ] ) ) { $ this -> _dummyBundles [ $ name ] = $ this -> loadBundle ( $ name , [ 'sourcePath' => null , 'js' => [ ] , 'css' => [ ] , 'depends' => [ ] , ] ) ; } return $ this -> _dummyBundles [ $ name ] ; }
5736	private function getShowParameters ( Request $ request ) { $ showingAll = FALSE ; $ start = - 100 ; $ count = - 1 ; if ( $ request -> query -> has ( 'all' ) ) { $ start = 0 ; $ count = - 1 ; $ showingAll = TRUE ; } return [ $ start , $ count , $ showingAll ] ; }
9378	protected function files ( $ path ) { $ directory = new \ RecursiveDirectoryIterator ( $ path ) ; $ iterator = new \ RecursiveIteratorIterator ( $ directory ) ; $ regex = new \ RegexIterator ( $ iterator , '/^.+\.php$/i' , 1 ) ; return ( array ) array_keys ( iterator_to_array ( $ regex ) ) ; }
3774	public function getTypeNames ( ) { $ names = $ this -> factories -> ids ( ) ; if ( [ ] !== $ fallback = $ this -> fallbackFactory -> getIds ( ) ) { $ names = array_unique ( array_merge ( $ fallback , $ names ) ) ; } return $ names ; }
9421	public function getContents ( ) { if ( is_null ( $ this -> stream ) || ! $ this -> isReadable ( ) ) { $ message = 'Could not get contents of stream' ; throw new \ RuntimeException ( $ message ) ; } return stream_get_contents ( $ this -> stream ) ; }
8932	public function loadDependencies ( ) { $ config = ConfigService :: fetch ( dirname ( __DIR__ ) ) ; $ config = array_merge ( $ config , ConfigService :: fetch ( ) ) ; $ moduleService = new ModuleService ; if ( ! array_key_exists ( 'slim-api' , $ config ) ) { $ config [ 'slim-api' ] = [ 'modules' => [ 'SlimApi\Phinx' , 'SlimApi\Mvc' ] ] ; } else { require 'vendor/autoload.php' ; } foreach ( $ config [ 'slim-api' ] [ 'modules' ] as $ moduleNamespace ) { $ config = array_merge ( $ config , $ moduleService -> load ( $ moduleNamespace ) ) ; } return $ config ; }
5044	public function onRoute ( MvcEvent $ e ) { $ routeMatch = $ e -> getRouteMatch ( ) ; if ( 0 !== strpos ( $ routeMatch -> getMatchedRouteName ( ) , 'lang' ) ) { $ lang = $ this -> detectLanguage ( $ e ) ; $ this -> setLocale ( $ e , $ lang ) ; return ; } $ language = $ routeMatch -> getParam ( 'lang' , '__NOT_SET__' ) ; if ( $ this -> localeService -> isLanguageSupported ( $ language ) ) { $ this -> setLocale ( $ e , $ language ) ; } else { $ e -> setError ( Application :: ERROR_ROUTER_NO_MATCH ) ; $ e -> setTarget ( $ this ) ; $ eventManager = $ e -> getApplication ( ) -> getEventManager ( ) ; $ eventManager -> setEventPrototype ( $ e ) ; $ result = $ eventManager -> trigger ( MvcEvent :: EVENT_DISPATCH_ERROR , $ e ) ; return $ result -> last ( ) ; } }
6543	public function current ( ) { $ this -> prepareQuery ( ) ; if ( false !== current ( $ this -> idsArray ) ) { return current ( $ this -> idsArray ) ; } else { throw new PointerException ( 'Can\'t retrieve the current element' ) ; } }
11913	public function current ( ) { $ current = current ( $ this -> storage ) ; if ( $ this -> useMapEntries ) { return new MapEntry ( $ current [ 0 ] , $ current [ 1 ] ) ; } return $ current [ 1 ] ; }
566	public function setScriptFile ( $ value ) { $ scriptFile = realpath ( Yii :: getAlias ( $ value ) ) ; if ( $ scriptFile !== false && is_file ( $ scriptFile ) ) { $ this -> _scriptFile = $ scriptFile ; } else { throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } }
1966	public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { if ( static :: $ strPk == 'id' ) { return static :: findById ( $ varValue , $ arrOptions ) ; } return parent :: findByPk ( $ varValue , $ arrOptions ) ; }
161	public function orHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'or' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
11780	public function fromDbToEntity ( array $ data ) { $ hydratorFactory = $ this -> documentManager -> getHydratorFactory ( ) ; $ documentClass = $ this -> documentClass ; $ document = new $ documentClass ( ) ; $ hydratorFactory -> hydrate ( $ document , $ data ) ; return $ document ; }
3766	private function addInputScreenTranslations ( StaticTranslator $ translator , $ inputScreen , $ containerName ) { $ currentLocale = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ inputScreen [ 'legends' ] as $ legendName => $ legendInfo ) { foreach ( $ legendInfo [ 'label' ] as $ langCode => $ label ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName , $ langCode ) ; if ( $ currentLocale === $ langCode ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName ) ; } } } }
5640	public function paintGroupEnd ( $ test_name ) { array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
6560	public static function splitPath ( $ path ) { $ fragments = [ ] ; while ( true ) { $ cur = dirname ( $ path ) ; if ( $ cur [ 0 ] === DIRECTORY_SEPARATOR ) { $ cur [ 0 ] = '/' ; } if ( $ cur === $ path || ( $ cur === '.' && basename ( $ path ) === $ path ) ) { break ; } $ fragment = trim ( substr ( $ path , strlen ( $ cur ) ) , '/' ) ; if ( ! $ fragments ) { $ fragments [ ] = $ fragment ; } elseif ( $ fragment === '..' && basename ( $ cur ) !== '..' ) { $ cur = dirname ( $ cur ) ; } elseif ( $ fragment !== '.' ) { $ fragments [ ] = $ fragment ; } $ path = $ cur ; } if ( $ path !== '' ) { $ fragments [ ] = trim ( $ path , '/' ) ; } return array_reverse ( $ fragments ) ; }
4670	protected function afterGeneration ( ) { $ this -> mapTemplate -> writeToFile ( ) ; $ this -> autoloadMap -> writeToFile ( ) ; $ responseParserTemplate = new ResponseParserTemplate ( $ this -> config ) ; $ this -> autoloadMap -> addEntry ( $ responseParserTemplate -> getClassName ( ) , $ responseParserTemplate -> getClassPath ( ) ) ; $ responseParserTemplate -> writeToFile ( ) ; }
4058	private function drawAttribute ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ type = $ attribute -> get ( 'type' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> attributeFactory -> getIconForType ( $ type ) , $ type , '' , 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = $ attribute -> getName ( ) ; $ colName = $ attribute -> getColName ( ) ; $ isUnique = $ attribute -> get ( 'isunique' ) ; } else { $ type = 'unknown ID: ' . $ model -> getProperty ( 'attr_id' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = 'unknown attribute' ; $ colName = 'unknown column' ; $ isUnique = false ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong><span class="mandatory">%s</span> <span class="tl_class">%s</span> </div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ colName , $ type , $ image , $ name , $ model -> getProperty ( 'mandatory' ) || $ isUnique ? ' [' . $ this -> trans ( 'mandatory.0' ) . ']' : '' , $ model -> getProperty ( 'tl_class' ) ? sprintf ( '[%s]' , $ model -> getProperty ( 'tl_class' ) ) : '' ] ) ; }
5742	public function getParserForContentType ( $ contentType ) { if ( 0 !== stripos ( $ contentType , 'multipart/' ) ) { return null ; } list ( $ mime , $ boundary ) = $ this -> parseContentType ( $ contentType ) ; $ parser = new MultipartParser ( ) ; $ parser -> setBoundary ( $ boundary ) ; return $ parser ; }
7687	function Misc_CellRef ( $ Col , $ Row ) { $ r = '' ; $ x = $ Col ; do { $ x = $ x - 1 ; $ c = ( $ x % 26 ) ; $ x = ( $ x - $ c ) / 26 ; $ r = chr ( 65 + $ c ) . $ r ; } while ( $ x > 0 ) ; return $ r . $ Row ; }
1407	protected function getModelAttributes ( Model $ model ) { $ attributes = [ ] ; foreach ( $ this -> attributeKeys ( $ model ) as $ modelKey => $ field ) { if ( is_numeric ( $ modelKey ) ) { $ modelKey = $ field ; $ field = $ this -> fieldForAttribute ( $ field ) ; } $ attributes [ $ field ] = $ this -> extractAttribute ( $ model , $ modelKey , $ field ) ; } return $ attributes ; }
39	protected function generatePackageTree ( PackageInterface $ package , RepositoryInterface $ installedRepo , RepositoryInterface $ distantRepos ) { $ requires = $ package -> getRequires ( ) ; ksort ( $ requires ) ; $ children = array ( ) ; foreach ( $ requires as $ requireName => $ require ) { $ packagesInTree = array ( $ package -> getName ( ) , $ requireName ) ; $ treeChildDesc = array ( 'name' => $ requireName , 'version' => $ require -> getPrettyConstraint ( ) , ) ; $ deepChildren = $ this -> addTree ( $ requireName , $ require , $ installedRepo , $ distantRepos , $ packagesInTree ) ; if ( $ deepChildren ) { $ treeChildDesc [ 'requires' ] = $ deepChildren ; } $ children [ ] = $ treeChildDesc ; } $ tree = array ( 'name' => $ package -> getPrettyName ( ) , 'version' => $ package -> getPrettyVersion ( ) , 'description' => $ package -> getDescription ( ) , ) ; if ( $ children ) { $ tree [ 'requires' ] = $ children ; } return $ tree ; }
1680	public function handleUserProfile ( Contao \ DataContainer $ dc ) { if ( Contao \ Input :: get ( 'do' ) != 'login' ) { return ; } if ( Contao \ BackendUser :: getInstance ( ) -> id != Contao \ Input :: get ( 'id' ) || Contao \ Input :: get ( 'act' ) != 'edit' ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not allowed to edit this page.' ) ; } $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'closed' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'hideVersionMenu' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] = array ( '__selector__' => $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ '__selector__' ] , 'default' => $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ 'login' ] ) ; $ arrFields = Contao \ StringUtil :: trimsplit ( '[,;]' , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ 'default' ] ) ; foreach ( $ arrFields as $ strField ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ strField ] [ 'exclude' ] = false ; } }
8937	public function readChangeset ( $ id ) { $ base = 'changeset/' . $ id ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> changeset ; }
9880	private function writeWorkbookProtection ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { if ( $ spreadsheet -> getSecurity ( ) -> isSecurityEnabled ( ) ) { $ objWriter -> startElement ( 'workbookProtection' ) ; $ objWriter -> writeAttribute ( 'lockRevision' , ( $ spreadsheet -> getSecurity ( ) -> getLockRevision ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'lockStructure' , ( $ spreadsheet -> getSecurity ( ) -> getLockStructure ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'lockWindows' , ( $ spreadsheet -> getSecurity ( ) -> getLockWindows ( ) ? 'true' : 'false' ) ) ; if ( $ spreadsheet -> getSecurity ( ) -> getRevisionsPassword ( ) != '' ) { $ objWriter -> writeAttribute ( 'revisionsPassword' , $ spreadsheet -> getSecurity ( ) -> getRevisionsPassword ( ) ) ; } if ( $ spreadsheet -> getSecurity ( ) -> getWorkbookPassword ( ) != '' ) { $ objWriter -> writeAttribute ( 'workbookPassword' , $ spreadsheet -> getSecurity ( ) -> getWorkbookPassword ( ) ) ; } $ objWriter -> endElement ( ) ; } }
2564	public static function generateSomewhatRandomString ( $ length = 22 ) { $ chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz" ; srand ( ( double ) microtime ( ) * 1000000 ) ; $ i = 0 ; $ somewhatRandom = '' ; while ( $ i < $ length ) { $ num = rand ( ) % 60 ; $ tmp = substr ( $ chars , $ num , 1 ) ; $ somewhatRandom = $ somewhatRandom . $ tmp ; $ i ++ ; } return $ somewhatRandom ; }
3613	public function setTargetTemperature ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
5835	private function clearExpiredCacheEntries ( int $ now ) { $ this -> now = $ now ; foreach ( $ this -> cacheTimeouts as $ path => $ timeout ) { if ( $ now <= $ timeout ) { break ; } $ fileInfo = $ this -> cache [ $ path ] ; unset ( $ this -> cache [ $ path ] , $ this -> cacheTimeouts [ $ path ] ) ; $ this -> bufferedFileCount -= isset ( $ fileInfo -> buffer ) ; $ this -> cacheEntryCount -- ; } }
7722	function meth_Misc_Alert ( $ Src , $ Msg , $ NoErrMsg = false , $ SrcType = false ) { $ this -> ErrCount ++ ; if ( $ this -> NoErr || ( php_sapi_name === 'cli' ) ) { $ t = array ( '' , '' , '' , '' , '' ) ; } else { $ t = array ( '<br /><b>' , '</b>' , '<em>' , '</em>' , '<br />' ) ; $ Msg = htmlentities ( $ Msg ) ; } if ( ! is_string ( $ Src ) ) { if ( $ SrcType === false ) $ SrcType = 'in field' ; if ( isset ( $ Src -> PrmLst [ 'tbstype' ] ) ) { $ Msg = 'Column \'' . $ Src -> SubName . '\' is expected but missing in the current record.' ; $ Src = 'Parameter \'' . $ Src -> PrmLst [ 'tbstype' ] . '=' . $ Src -> SubName . '\'' ; $ NoErrMsg = false ; } else { $ Src = $ SrcType . ' ' . $ this -> _ChrOpen . $ Src -> FullName . '...' . $ this -> _ChrClose ; } } $ x = $ t [ 0 ] . 'TinyButStrong Error' . $ t [ 1 ] . ' ' . $ Src . ': ' . $ Msg ; if ( $ NoErrMsg ) $ x = $ x . ' ' . $ t [ 2 ] . 'This message can be cancelled using parameter \'noerr\'.' . $ t [ 3 ] ; $ x = $ x . $ t [ 4 ] . "\n" ; if ( $ this -> NoErr ) { $ this -> ErrMsg .= $ x ; } else { if ( php_sapi_name !== 'cli' ) { $ x = str_replace ( $ this -> _ChrOpen , $ this -> _ChrProtect , $ x ) ; } echo $ x ; } return false ; }
11609	public function actionDisconnect ( $ id ) { $ account = $ this -> finder -> findAccountById ( $ id ) ; if ( $ account === null ) { throw new NotFoundHttpException ; } if ( $ account -> user_id != \ Yii :: $ app -> user -> id ) { throw new ForbiddenHttpException ; } $ account -> delete ( ) ; return $ this -> redirect ( [ 'networks' ] ) ; }
4673	public function getTemplateFile ( $ template ) { $ file = $ template . $ this -> suffix ; if ( is_file ( $ file ) ) { return $ file ; } foreach ( $ this -> paths as $ path ) { $ file = $ path . "/" . $ template . $ this -> suffix ; if ( is_file ( $ file ) ) { return $ file ; } } throw new Exception ( "Could not find template file '$template'." ) ; }
6495	public function visitPage ( $ path , $ code = 200 ) { if ( ! $ this -> assertStatusCode ( $ path , $ code ) ) { throw new \ Exception ( sprintf ( 'The page "%s" is not accessible!' , $ path ) ) ; } self :: debug ( [ 'Visited page: %s' ] , [ $ path ] ) ; $ this -> visitPath ( $ path ) ; }
8026	public function remove ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; if ( $ this -> hasProcess ( $ pid ) === FALSE ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not remove process. Process (%d) not in list.' , $ processDetails -> getPid ( ) ) , 1400761297 ) ; } if ( isset ( $ this -> freeProcessIds [ $ pid ] ) ) { unset ( $ this -> freeProcessIds [ $ pid ] ) ; } if ( isset ( $ this -> sockets [ $ pid ] ) ) { unset ( $ this -> sockets [ $ pid ] ) ; } unset ( $ this -> processDetails [ $ pid ] ) ; return $ this ; }
9781	private function setFlag ( string $ name , bool $ value = true ) : self { $ this -> flags [ $ name ] = $ value ; return $ this ; }
11675	public function homepageTemplate ( ) { if ( null === $ this -> homepageTemplate ) { $ homepageFile = $ this -> pagesDir . "/" . $ this -> homepage ( ) . '/page.json' ; $ page = json_decode ( FilesystemTools :: readFile ( $ homepageFile ) , true ) ; $ this -> homepageTemplate = $ page [ "template" ] ; } return $ this -> homepageTemplate ; }
3830	protected function prepareFrontendFilterOptions ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , $ blnAutoSubmit ) { $ arrOptions = array ( ) ; if ( ! isset ( $ arrWidget [ 'options' ] ) ) { return $ arrOptions ; } $ filterUrl = new FilterUrl ( $ arrJumpTo ) ; foreach ( $ arrFilterUrl as $ name => $ value ) { if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ filterUrl -> setSlug ( $ name , ( string ) $ value ) ; } $ parameterName = $ arrWidget [ 'eval' ] [ 'urlparam' ] ; if ( $ arrWidget [ 'eval' ] [ 'includeBlankOption' ] ) { $ blnActive = $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , '' ) ; $ arrOptions [ ] = array ( 'key' => '' , 'value' => ( $ arrWidget [ 'eval' ] [ 'blankOptionLabel' ] ? $ arrWidget [ 'eval' ] [ 'blankOptionLabel' ] : $ GLOBALS [ 'TL_LANG' ] [ 'metamodels_frontendfilter' ] [ 'do_not_filter' ] ) , 'href' => $ this -> filterUrlBuilder -> generate ( $ filterUrl -> clone ( ) -> setSlug ( $ parameterName , '' ) ) , 'active' => $ blnActive , 'class' => 'doNotFilter' . ( $ blnActive ? ' active' : '' ) , ) ; } foreach ( $ arrWidget [ 'options' ] as $ strKeyOption => $ strOption ) { $ strValue = $ this -> getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ; $ blnActive = $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ; $ arrOptions [ ] = array ( 'key' => $ strKeyOption , 'value' => $ strOption , 'href' => $ this -> filterUrlBuilder -> generate ( $ filterUrl -> clone ( ) -> setSlug ( $ parameterName , $ strValue ) ) , 'active' => $ blnActive , 'class' => StringUtil :: standardize ( $ strKeyOption ) . ( $ blnActive ? ' active' : '' ) ) ; } return $ arrOptions ; }
3814	private function injectServiceContainerIntoDataDrivers ( $ providerDefinitions , $ environment ) { foreach ( $ providerDefinitions as $ provider ) { $ providerInstance = $ environment -> getDataProvider ( $ provider -> getName ( ) ) ; if ( $ providerInstance instanceof Driver ) { $ initialization = $ provider -> getInitializationData ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ initialization [ 'source' ] ) ; $ providerInstance -> setBaseConfig ( array_merge ( $ initialization , [ 'metaModel' => $ metaModel ] ) ) ; $ providerInstance -> setDispatcher ( $ this -> dispatcher ) ; $ providerInstance -> setConnection ( $ this -> connection ) ; } } }
2633	public function execute ( ) { $ output = $ this -> layoutFactory -> create ( ) -> createBlock ( 'Fastly\Cdn\Block\Dashboard\Tab\Stats\Historic' ) -> toHtml ( ) ; $ resultRaw = $ this -> resultRawFactory -> create ( ) ; return $ resultRaw -> setContents ( $ output ) ; }
6679	public static function convertDate ( $ dateString , $ fromFormat , $ toFormat ) { $ date = DateTime :: createFromFormat ( $ fromFormat , $ dateString ) ; if ( ! $ date && $ fromFormat == DateFormat :: FORMAT_ORACLE_WITH_MICROSECONDS ) { $ date = DateTime :: createFromFormat ( DateFormat :: FORMAT_ORACLE_DATE_ONLY , $ dateString ) ; } if ( $ date ) { return $ date -> format ( $ toFormat ) ; } return $ dateString ; }
2697	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ enabled = false ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ! $ status ) { $ this -> api -> checkAuthDictionaryPopulation ( $ activeVersion ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'content' => $ value , 'priority' => 10 ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ enabled = true ; } else { $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ enabled , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON Basic Authentication' ] ; if ( ! $ enabled ) { $ comment = [ 'comment' => 'Magento Module turned OFF Basic Authentication' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12149	public function getReservedCodes ( ) { $ reserved = [ ] ; foreach ( $ this -> factories as $ factoryClass => $ factory ) { $ reserved [ $ factoryClass ] = $ factory -> getReservedDiapason ( ) ; } return $ reserved ; }
8296	public function write ( $ data ) { if ( ! is_string ( $ data ) ) { throw new \ InvalidArgumentException ( "The data is not a string." ) ; } $ this -> open ( ) ; if ( ! ftruncate ( $ this -> handle , 0 ) ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not truncate file " . $ this -> filePath ) ; } fseek ( $ this -> handle , 0 ) ; $ res = fwrite ( $ this -> handle , $ data ) ; if ( strlen ( $ data ) !== $ res ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not write to file " . $ this -> filePath ) ; } }
4184	public function getFile ( $ class ) { if ( is_null ( $ this -> count ) ) { return $ this -> fileHas ( $ class ) -> getFile ( $ class ) ; } if ( isset ( $ this -> files [ $ class ] ) ) { return $ this -> files [ $ class ] ; } throw new FileException ( "File does not exists with given `{$class}` class." ) ; }
2046	private function getTempDir ( ) : string { $ container = $ this -> getContainer ( ) ; $ tmpDir = sys_get_temp_dir ( ) . '/' . md5 ( $ container -> getParameter ( 'kernel.project_dir' ) ) ; if ( ! is_dir ( $ tmpDir ) ) { $ container -> get ( 'filesystem' ) -> mkdir ( $ tmpDir ) ; } return $ tmpDir ; }
5362	public function createContext ( Registry $ registry , $ name ) { $ schemas = array_values ( $ registry -> getSchemas ( ) ) ; foreach ( $ schemas as $ schema ) { $ openApiSpec = $ this -> schemaParser -> parseSchema ( $ schema -> getOrigin ( ) ) ; $ this -> chainGuesser -> guessClass ( $ openApiSpec , $ schema -> getRootName ( ) , $ schema -> getOrigin ( ) . '#' , $ registry ) ; $ schema -> setParsed ( $ openApiSpec ) ; } foreach ( $ registry -> getSchemas ( ) as $ schema ) { foreach ( $ schema -> getClasses ( ) as $ class ) { $ properties = $ this -> chainGuesser -> guessProperties ( $ class -> getObject ( ) , $ schema -> getRootName ( ) , $ class -> getReference ( ) , $ registry ) ; foreach ( $ properties as $ property ) { $ property -> setType ( $ this -> chainGuesser -> guessType ( $ property -> getObject ( ) , $ property -> getName ( ) , $ property -> getReference ( ) , $ registry ) ) ; } $ class -> setProperties ( $ properties ) ; } } return new Context ( $ registry ) ; }
1603	private function _getVariables ( ) { $ variables = $ this -> _overrideObject ; if ( $ this -> _element !== null ) { foreach ( $ this -> _element -> attributes ( ) as $ name ) if ( $ name !== $ this -> _handle ) $ variables [ $ name ] = $ this -> _element -> $ name ; $ variables = array_merge ( $ variables , $ this -> _element -> toArray ( $ this -> _element -> extraFields ( ) ) ) ; } return $ variables ; }
6266	public function reject ( Exception $ exception ) { if ( HttpPromise :: PENDING !== $ this -> state ) { throw new \ RuntimeException ( 'Promise is already resolved' ) ; } $ this -> state = HttpPromise :: REJECTED ; $ this -> exception = $ exception ; $ this -> doReject ( $ exception ) ; }
9007	public function sort ( ) { $ this -> uasort ( function ( $ a , $ b ) { $ priority_a = ( int ) $ a -> get ( 'priority' ) ? : 500 ; $ priority_b = ( int ) $ b -> get ( 'priority' ) ? : 500 ; if ( $ priority_a == $ priority_b ) { return 0 ; } return ( $ priority_a < $ priority_b ) ? - 1 : 1 ; } ) ; return $ this ; }
10385	protected static function unify_params ( $ type , $ field , $ default = '' ) { $ data = array_column ( self :: $ data [ $ type ] , $ field ) ; switch ( $ field ) { case 'media' : case 'footer' : case 'version' : foreach ( $ data as $ key => $ value ) { if ( $ data [ 0 ] !== $ value ) { return $ default ; } } return ( isset ( $ data [ 0 ] ) && $ data [ 0 ] ) ? $ data [ 0 ] : $ default ; default : $ params = [ ] ; foreach ( $ data as $ key => $ value ) { $ params = array_merge ( $ params , $ value ) ; } return array_unique ( $ params ) ; } }
160	public function andHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'and' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
7338	public function createEvent ( Request $ request ) : Event { if ( empty ( $ request -> input ( ) ) ) { return new Unknown ( ) ; } $ update = new Update ( $ request -> input ( ) ) ; $ this -> update = $ update ; if ( $ message = $ update -> message ) { $ chat = new Chat ( ( string ) $ message -> chat -> id , $ message -> chat -> title , $ message -> chat -> type ) ; $ from = new User ( ( string ) $ message -> from -> id , $ message -> from -> first_name , $ message -> from -> username ) ; return new MessageReceived ( $ chat , $ from , $ message -> text , $ message -> location , null , optional ( $ update -> callback_query ) -> data , $ update ) ; } if ( $ callbackQuery = $ update -> callback_query ) { $ message = $ callbackQuery -> message ; $ chat = new Chat ( ( string ) $ message -> chat -> id , $ message -> chat -> title , $ message -> chat -> type ) ; $ from = new User ( ( string ) $ message -> chat -> id , $ message -> from -> first_name , $ message -> from -> username ) ; return new MessageReceived ( $ chat , $ from , $ message -> text , $ message -> location , null , $ callbackQuery -> data , $ update ) ; } return new Unknown ( ) ; }
8017	public function fileExists ( $ name ) { $ http = new \ Guzzle \ Http \ Client ( ) ; try { $ response = $ http -> get ( $ this -> getUrl ( $ name ) ) -> send ( ) ; } catch ( ClientErrorResponseException $ e ) { return false ; } return $ response -> isSuccessful ( ) ; }
2512	public function setStatus ( $ newStatus ) { if ( $ this -> isWorseStatus ( $ newStatus , $ this -> status ) ) { $ this -> status = $ newStatus ; } }
6936	private function findBySubjectAndStates ( StockSubjectInterface $ subject , array $ states = [ ] ) { $ units = [ ] ; $ oid = spl_object_hash ( $ subject ) ; if ( isset ( $ this -> addedUnits [ $ oid ] ) ) { $ units = $ this -> addedUnits [ $ oid ] ; } if ( ! empty ( $ units ) && ! empty ( $ states ) ) { $ units = array_filter ( $ units , function ( StockUnitInterface $ unit ) use ( $ states ) { return in_array ( $ unit -> getState ( ) , $ states ) ; } ) ; } return $ units ; }
1071	private function subfieldConflicts ( array $ conflicts , $ responseName , FieldNode $ ast1 , FieldNode $ ast2 ) { if ( count ( $ conflicts ) === 0 ) { return null ; } return [ [ $ responseName , array_map ( static function ( $ conflict ) { return $ conflict [ 0 ] ; } , $ conflicts ) , ] , array_reduce ( $ conflicts , static function ( $ allFields , $ conflict ) { return array_merge ( $ allFields , $ conflict [ 1 ] ) ; } , [ $ ast1 ] ) , array_reduce ( $ conflicts , static function ( $ allFields , $ conflict ) { return array_merge ( $ allFields , $ conflict [ 2 ] ) ; } , [ $ ast2 ] ) , ] ; }
7873	public function credit ( ) : ? array { $ this -> checkConfig ( ) ; $ query = http_build_query ( [ 'userkey' => $ this -> userkey , 'passkey' => $ this -> passkey , ] ) ; $ response = Request :: get ( $ this -> baseUrl . '/smsapibalance.php?' . $ query ) ; $ xml = simplexml_load_string ( $ response -> body ) ; $ body = json_decode ( json_encode ( $ xml ) , true ) ; return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ body [ 'message' ] [ 'text' ] ?? '' , 'data' => $ body , ] ; }
5691	public function getButtonHTML ( ) { $ link = $ this -> getButtonLink ( ) ; $ stageLink = Controller :: join_links ( $ link , '?stage=Stage' ) ; $ liveLink = Controller :: join_links ( $ link , '?stage=Live' ) ; return '<span class="better-buttons-frontend-links"> <a class="better-buttons-frontend-link" target="_blank" href="' . $ stageLink . '">' . _t ( 'GridFieldBetterButtons.VIEWONDRAFTSITE' , 'Draft site' ) . '</a> | <a class="better-buttons-frontend-link" target="_blank" href="' . $ liveLink . '">' . _t ( 'GridFieldBetterButtons.VIEWONLIVESITE' , 'Live site' ) . '</a></span>' ; }
6135	public function search ( Search $ search , $ returnType = self :: RETURN_OBJECTS , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'returnType' => $ returnType ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> call ( 'v1/search' , $ parameters , self :: METHOD_POST , $ cachePolicy ) ; $ result = new SearchResult ( $ result ) ; return $ result ; }
10062	public function update ( $ key , $ value ) { try { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> firstOrFail ( ) ; } catch ( \ Exception $ e ) { $ message = "Can't update meta (key: $key). " ; $ message .= "Meta doesn't exist" ; throw new \ Exception ( $ message ) ; } $ meta -> value = $ value ; $ meta -> save ( ) ; }
4192	protected function dumpPhpDoc ( $ phpDoc ) { $ str = '' ; foreach ( $ phpDoc as $ k => $ values ) { if ( ! \ is_array ( $ values ) ) { continue ; } foreach ( $ values as $ value ) { if ( $ k == 'link' ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } elseif ( $ k == 'see' && $ value [ 'uri' ] ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } else { $ value = \ htmlspecialchars ( \ implode ( ' ' , $ value ) ) ; } $ str .= '<dd class="phpdoc phpdoc-' . $ k . '">' . '<span class="phpdoc-tag">' . $ k . '</span>' . '<span class="t_operator">:</span> ' . $ value . '</dd>' . "\n" ; } } if ( $ str ) { $ str = '<dt class="phpDoc">phpDoc</dt>' . "\n" . $ str ; } return $ str ; }
11147	public function getFromLocation ( Neuron_GameServer_Map_Location $ location ) { $ area = new Neuron_GameServer_Map_Area ( $ location , 1 ) ; $ objects = $ this -> getDisplayObjects ( $ area ) ; $ out = array ( ) ; foreach ( $ objects as $ v ) { if ( $ v -> getLocation ( ) -> equals ( $ location ) ) { $ out [ ] = $ v ; } } return $ out ; }
5174	public function get ( string $ key ) { return isset ( $ this -> props [ $ key ] ) ? $ this -> props [ $ key ] : null ; }
11427	public function toObject ( ) { $ groups = $ this -> groups ; foreach ( $ groups as & $ group ) { $ group = $ group -> toObject ( ) ; } $ items = $ this -> items ; foreach ( $ items as & $ item ) { $ item = $ item -> toObject ( ) ; } return ( object ) [ 'type' => $ this -> type , 'value' => $ this -> value , 'text' => $ this -> text , 'groups' => $ groups , 'items' => $ items , ] ; }
3397	public function urlDecodeUnreservedChars ( $ string ) { $ string = rawurldecode ( $ string ) ; $ string = rawurlencode ( $ string ) ; $ string = str_replace ( array ( '%2F' , '%3A' , '%40' ) , array ( '/' , ':' , '@' ) , $ string ) ; return $ string ; }
10778	private function create_image ( ) { $ total = $ this -> total_size ( ) ; $ sprite = imagecreatetruecolor ( $ total [ "width" ] , $ total [ "height" ] ) ; imagesavealpha ( $ sprite , true ) ; $ transparent = imagecolorallocatealpha ( $ sprite , 0 , 0 , 0 , 127 ) ; imagefill ( $ sprite , 0 , 0 , $ transparent ) ; $ top = 0 ; foreach ( $ this -> images as $ image ) { $ func = "imagecreatefrom" . $ image [ 'type' ] ; $ img = $ func ( $ image [ "path" ] ) ; imagecopy ( $ sprite , $ img , ( $ total [ "width" ] - $ image [ "width" ] ) , $ top , 0 , 0 , $ image [ "width" ] , $ image [ "height" ] ) ; $ top += $ image [ "height" ] ; } return $ sprite ; }
6799	public function installCountries ( $ code = 'US' ) { $ countryNames = Intl :: getRegionBundle ( ) -> getCountryNames ( ) ; if ( ! isset ( $ countryNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default country code '$code'." ) ; } asort ( $ countryNames ) ; $ this -> generate ( Country :: class , $ countryNames , $ code ) ; }
6509	public function createHandlers ( JobInterface $ job , $ level , $ bubble ) { $ handlers = [ ] ; foreach ( $ this -> factories as $ factory ) { $ handlers [ ] = $ factory -> createHandler ( $ job , $ level , $ bubble ) ; } return $ handlers ; }
968	protected function cancelCharge ( ) { $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } }
9151	public function getSelectOptions ( ) { $ filter = new UnderscoreToCamelCase ( ) ; $ funcName = "get" . ucfirst ( $ filter -> filter ( $ this -> getUserColumn ( ) ) ) ; $ resultSet = $ this -> fetchAll ( array ( 'user_id' , $ this -> getUserColumn ( ) ) , function ( Select $ select ) { $ select -> where -> notEqualTo ( 'user_id' , $ this -> getCurrentUser ( ) -> getId ( ) ) ; } ) ; $ options = array ( ) ; foreach ( $ resultSet as $ user ) { $ options [ $ user -> getId ( ) ] = $ user -> $ funcName ( ) ; } return $ options ; }
11490	public function destroyWithCookie ( ) : ? bool { if ( $ this -> isStarted ( ) ) { $ this -> destroy ( ) ; return setcookie ( $ this -> getName ( ) , '' , time ( ) - 1 , '/' ) ; } return null ; }
7075	private function addItemDetails ( array & $ details , Model \ SaleItemInterface $ item ) { $ total = 0 ; if ( ! ( $ item -> isCompound ( ) && ! $ item -> hasPrivateChildren ( ) ) ) { $ itemResult = $ item -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ item -> getTotalQuantity ( ) . 'x ' . $ item -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NUMBER' . $ this -> line ] = $ item -> getReference ( ) ; if ( ! empty ( $ description = $ item -> getDescription ( ) ) ) { $ details [ 'L_PAYMENTREQUEST_0_DESC' . $ this -> line ] = $ description ; } $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = $ this -> format ( $ itemResult -> getTotal ( ) ) ; $ total = $ itemResult -> getTotal ( ) ; $ this -> line ++ ; } foreach ( $ item -> getChildren ( ) as $ child ) { $ total += $ this -> addItemDetails ( $ details , $ child ) ; } return $ total ; }
5157	public function executeFor ( Route $ route ) : bool { if ( null === $ this -> pathConstraint ) { return true ; } return strpos ( $ route -> getPath ( ) , $ this -> pathConstraint ) === 0 ; }
9666	private function writeFill ( XMLWriter $ objWriter , Fill $ pFill ) { if ( $ pFill -> getFillType ( ) === Fill :: FILL_GRADIENT_LINEAR || $ pFill -> getFillType ( ) === Fill :: FILL_GRADIENT_PATH ) { $ this -> writeGradientFill ( $ objWriter , $ pFill ) ; } elseif ( $ pFill -> getFillType ( ) !== null ) { $ this -> writePatternFill ( $ objWriter , $ pFill ) ; } }
603	protected function startsWithAnyLongest ( array & $ with , $ caseSensitive , & $ length = null , & $ content = null ) { if ( empty ( $ with ) ) { return false ; } if ( ! is_array ( reset ( $ with ) ) ) { usort ( $ with , function ( $ string1 , $ string2 ) { return mb_strlen ( $ string2 , 'UTF-8' ) - mb_strlen ( $ string1 , 'UTF-8' ) ; } ) ; $ map = [ ] ; foreach ( $ with as $ string ) { $ map [ mb_strlen ( $ string , 'UTF-8' ) ] [ $ caseSensitive ? $ string : mb_strtoupper ( $ string , 'UTF-8' ) ] = true ; } $ with = $ map ; } foreach ( $ with as $ testLength => $ testValues ) { $ content = $ this -> substring ( $ testLength , $ caseSensitive ) ; if ( isset ( $ testValues [ $ content ] ) ) { $ length = $ testLength ; return true ; } } return false ; }
12423	protected function getTranslations ( $ domain ) { if ( ! isset ( $ this -> translations [ $ domain ] ) ) { if ( ! isset ( $ this -> translationSources [ $ domain ] ) ) { $ msg = sprintf ( 'No translation directory for domain "%1$s" available' , $ domain ) ; throw new \ Aimeos \ MW \ Translation \ Exception ( $ msg ) ; } $ locale = $ this -> getLocale ( ) ; $ locations = array_reverse ( $ this -> getTranslationFileLocations ( $ this -> translationSources [ $ domain ] , $ locale ) ) ; foreach ( $ locations as $ location ) { $ translator = \ Zend \ I18n \ Translator \ MwTranslator :: factory ( $ this -> options ) ; $ translator -> addTranslationFile ( $ this -> adapter , $ location , $ domain , $ locale ) ; $ this -> translations [ $ domain ] [ $ location ] = $ translator ; } } return ( isset ( $ this -> translations [ $ domain ] ) ? $ this -> translations [ $ domain ] : [ ] ) ; }
5310	protected function getPathFromEllipse ( SimpleXMLElement $ ellipse ) { $ mult = 0.55228475 ; return 'M' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'C' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . ' ' . $ ellipse [ 'cx' ] . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . 'C' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'C' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . ' ' . $ ellipse [ 'cx' ] . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . 'C' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'Z' ; }
9164	protected function parseNode ( RuleCollection $ collection , \ DOMElement $ node , $ path , $ file ) { if ( self :: NAMESPACE_URI !== $ node -> namespaceURI ) { return ; } switch ( $ node -> localName ) { case 'rule' : $ this -> parseRule ( $ collection , $ node , $ path ) ; break ; case 'import' : $ this -> parseImport ( $ collection , $ node , $ path , $ file ) ; break ; default : throw new \ InvalidArgumentException ( sprintf ( 'Unknown tag "%s" used in file "%s". Expected "rule" or "import".' , $ node -> localName , $ path ) ) ; } }
1822	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> imageSizes ) || ! \ is_array ( $ this -> User -> imageSizes ) ) { $ imageSizes = array ( ) ; } else { $ imageSizes = $ this -> User -> imageSizes ; } if ( \ in_array ( $ insertId , $ imageSizes ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_image_size' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_image_size' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, themes, imageSizes FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrThemes = Contao \ StringUtil :: deserialize ( $ objGroup -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objGroup -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT themes, imageSizes FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrThemes = Contao \ StringUtil :: deserialize ( $ objUser -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objUser -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ this -> User -> id ) ; } } $ imageSizes [ ] = $ insertId ; $ this -> User -> imageSizes = $ imageSizes ; } }
2733	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ html = $ this -> getRequest ( ) -> getParam ( 'html' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_ERROR_SNIPPET_PATH , Config :: VCL_ERROR_SNIPPET ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_' . $ key , 'type' => $ key , 'dynamic' => '0' , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_condition' , 'statement' => 'req.http.ResponseObject == "970"' , 'type' => 'REQUEST' , 'priority' => '9' ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ response = [ 'name' => Config :: ERROR_PAGE_RESPONSE_OBJECT , 'request_condition' => $ createCondition -> name , 'content' => $ html , 'status' => "503" , 'content_type' => "text/html; charset=utf-8" , 'response' => "Service Temporarily Unavailable" ] ; $ createResponse = $ this -> api -> createResponse ( $ clone -> number , $ response ) ; if ( ! $ createResponse ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create a RESPONSE object.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*New Error/Maintenance page has updated and activated under config version ' . $ clone -> number . '*' ) ; } $ comment = [ 'comment' => 'Magento Module updated Error Page html' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
220	private function formatNumber ( $ value , $ decimals , $ maxPosition , $ formatBase , $ options , $ textOptions ) { $ value = $ this -> normalizeNumericValue ( $ value ) ; $ position = 0 ; if ( is_array ( $ formatBase ) ) { $ maxPosition = count ( $ formatBase ) - 1 ; } do { if ( is_array ( $ formatBase ) ) { if ( ! isset ( $ formatBase [ $ position + 1 ] ) ) { break ; } if ( abs ( $ value ) < $ formatBase [ $ position + 1 ] ) { break ; } } else { if ( abs ( $ value ) < $ formatBase ) { break ; } $ value /= $ formatBase ; } $ position ++ ; } while ( $ position < $ maxPosition + 1 ) ; if ( is_array ( $ formatBase ) && $ position !== 0 ) { $ value /= $ formatBase [ $ position ] ; } if ( $ position === 0 ) { $ decimals = 0 ; } elseif ( $ decimals !== null ) { $ value = round ( $ value , $ decimals ) ; } $ oldThousandSeparator = $ this -> thousandSeparator ; $ this -> thousandSeparator = '' ; if ( $ this -> _intlLoaded && ! isset ( $ options [ NumberFormatter :: GROUPING_USED ] ) ) { $ options [ NumberFormatter :: GROUPING_USED ] = false ; } $ params = [ 'n' => abs ( $ value ) , 'nFormatted' => $ this -> asDecimal ( $ value , $ decimals , $ options , $ textOptions ) , ] ; $ this -> thousandSeparator = $ oldThousandSeparator ; return [ $ params , $ position ] ; }
4426	protected function askForData ( $ optionIdentifier , $ optionName , $ defaultValue , $ validator = null ) { $ optionValue = $ this -> input -> getOption ( $ optionIdentifier ) ; $ optionValue = ! empty ( $ optionValue ) ? $ optionValue : $ defaultValue ; $ question = $ this -> getQuestion ( $ optionName , $ optionValue , $ validator ) ; $ optionValue = $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ question ) ; $ this -> input -> setOption ( $ optionIdentifier , $ optionValue ) ; return $ optionValue ; }
11269	public function getPath ( Neuron_GameServer_Map_Location $ start , Neuron_GameServer_Map_Location $ end ) { $ x1 = $ start [ 0 ] ; $ y1 = $ start [ 1 ] ; $ x2 = $ end [ 0 ] ; $ y2 = $ end [ 1 ] ; if ( ! $ this -> isPassable ( $ x2 , $ y2 ) ) { return false ; } $ astar = $ this -> astar ( $ start , $ end ) ; return $ astar ; }
6726	public function get_movie_votes ( $ post_id ) { $ votes = get_post_meta ( $ post_id , 'imdbTotalVotes' , true ) ; if ( ! empty ( $ votes ) ) { return json_decode ( $ votes , true ) ; } return false ; }
4015	protected function makeMandatory ( $ field , $ row , $ key ) { $ field [ 'eval' ] [ 'required' ] = false ; if ( empty ( $ field [ 'eval' ] [ 'mandatory' ] ) ) { return $ field ; } if ( is_array ( $ this -> varValue [ $ row ] [ $ key ] ) ) { if ( empty ( $ this -> varValue [ $ row ] [ $ key ] ) ) { $ field [ 'eval' ] [ 'required' ] = true ; } } else { if ( ! strlen ( $ this -> varValue [ $ row ] [ $ key ] ) ) { $ field [ 'eval' ] [ 'required' ] = true ; } } return $ field ; }
8786	public function generate ( ) { foreach ( $ this -> commandList as $ key => $ value ) { $ this -> app -> add ( new $ value ) ; } foreach ( $ this -> migrationCommands as $ command ) { $ newCommand = new $ command ; $ newCommand -> setName ( "migration:" . $ newCommand -> getName ( ) ) ; $ this -> app -> add ( $ newCommand ) ; } }
2878	public function enableFPCDebugAction ( ) { try { $ this -> getService ( ) -> setFPCDebug ( 1 ) ; $ this -> getService ( ) -> flushCache ( ) ; $ message = $ this -> __ ( 'FPC debug was enabled' ) ; $ this -> getSession ( ) -> addSuccess ( $ message ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'FPC debug cannot be enabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
1674	public function synchronize ( ) { if ( ! $ this -> isUnsynchronized ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot synchronize the folder "%s" because one of its parent folders is unsynchronized' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.nosync' ) ) -> delete ( ) ; }
7899	protected function isProviderAliasExists ( $ provider ) { return array_key_exists ( $ provider , $ this -> providers ) || array_key_exists ( $ provider , $ this -> customProviders ) ; }
11429	public function run ( Request $ request ) { $ dispatcher = $ this -> router -> getDispatcher ( ) ; $ routeInfo = $ dispatcher -> dispatch ( $ request -> server ( 'REQUEST_METHOD' ) , $ request -> server ( 'REQUEST_URI_PATH' ) ) ; switch ( $ routeInfo [ 0 ] ) { case Dispatcher :: NOT_FOUND : $ routeInfo = $ this -> getNotFoundRoute ( $ dispatcher ) ; break ; case Dispatcher :: METHOD_NOT_ALLOWED : $ routeInfo = $ this -> runMethodNotAllowed ( $ dispatcher ) ; break ; case Dispatcher :: FOUND : break ; } $ response = $ this -> runRoute ( $ routeInfo ) ; $ response -> send ( ) ; }
5913	public function addUserToGroup ( $ id , array $ groupIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'groupIds' => $ groupIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/groups' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
5117	public function deleteArticle ( string $ idArticle ) : ? string { $ articleOnRest = $ this -> getArticle ( $ idArticle ) ; if ( ! empty ( $ articleOnRest ) ) { $ articleOnRest = json_decode ( $ articleOnRest , true ) ; if ( isset ( $ articleOnRest [ 'data' ] ) ) { foreach ( Article :: getDeleteableAttachment ( ) as $ field ) { if ( isset ( $ articleOnRest [ 'data' ] [ $ field ] ) ) { foreach ( $ articleOnRest [ 'data' ] [ $ field ] as $ attachment ) { if ( isset ( $ attachment [ $ field . '_order' ] ) ) { $ this -> deleteAttachment ( $ idArticle , $ field , $ attachment [ $ field . '_order' ] ) ; } } } } } return $ this -> delete ( $ this -> getArticleWithIdEndPoint ( $ idArticle ) ) ; } }
