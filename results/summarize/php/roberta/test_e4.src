9389	protected function parse ( $ route ) { $ route [ 0 ] = strtoupper ( $ route [ 0 ] ) ; $ route [ 1 ] = str_replace ( '//' , '/' , $ this -> prefix . $ route [ 1 ] ) ; is_string ( $ route [ 2 ] ) && $ route [ 2 ] = explode ( '@' , $ route [ 2 ] ) ; is_array ( $ route [ 2 ] ) && $ route [ 2 ] [ 0 ] = $ this -> namespace . $ route [ 2 ] [ 0 ] ; is_array ( $ route [ 3 ] ) || $ route [ 3 ] = array ( $ route [ 3 ] ) ; return $ route ; }
12684	public function offsetSet ( $ offset , $ value ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( ! $ this -> isFetched ( ) ) { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: cannot set value on unitialized list' , E_USER_NOTICE ) ; return false ; } if ( ! $ this -> is_assoc && ! is_numeric ( $ value ) ) { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: can only set numeric keys non assoc lists' , E_USER_NOTICE ) ; return false ; } if ( $ value instanceof $ this -> classname ) { $ this -> result [ $ offset ] = $ value ; } else { trigger_error ( 'Web2All_Table_ObjectList::offsetSet: can only add objects of type ' . $ this -> classname . ' to the list' , E_USER_NOTICE ) ; return false ; } }
4679	public function set ( $ template , $ data = [ ] , $ sort = 0 , $ type = "file" ) { if ( empty ( $ template ) ) { $ type = "empty" ; } elseif ( is_array ( $ template ) ) { if ( isset ( $ template [ "callback" ] ) ) { $ type = "callback" ; $ this -> template = $ template [ "callback" ] ; } else { $ this -> template = $ template [ "template" ] ; } $ this -> sortOrder = $ template [ "sort" ] ?? $ sort ; $ this -> type = $ template [ "type" ] ?? $ type ; $ data1 = $ template [ "data" ] ?? [ ] ; if ( empty ( $ data ) ) { $ this -> templateData = $ data1 ; } else if ( empty ( $ data1 ) ) { $ this -> templateData = $ data ; } else { foreach ( $ data as $ key => $ val ) { if ( is_array ( $ val ) ) { if ( ! array_key_exists ( $ key , $ data1 ) ) { $ data1 [ $ key ] = [ ] ; } $ data1 [ $ key ] = array_merge ( $ data1 [ $ key ] , $ val ) ; } else { $ data1 [ $ key ] = $ val ; } $ this -> templateData = $ data1 ; } } return ; } $ this -> template = $ template ; $ this -> templateData = $ data ; $ this -> sortOrder = $ sort ; $ this -> type = $ type ; return $ this ; }
6033	public function getMetadata ( $ section = null , $ key = null ) { if ( null === $ section ) { return $ this -> metadata ; } foreach ( $ this -> metadata as $ md ) { if ( $ section != $ md -> getSection ( ) ) { continue ; } if ( null === $ key ) { return $ md ; } foreach ( $ md -> getData ( ) as $ k => $ data ) { if ( $ key == $ k ) { return $ data ; } } throw new NotFoundException ( 'No metadata with section "' . $ section . '" and key "' . $ key . '" exists.' ) ; } throw new NotFoundException ( 'No metadata with section "' . $ section . '" exists.' ) ; }
4683	public static function stop ( $ key = 'default' ) : void { if ( isset ( self :: $ timers [ $ key ] ) ) { self :: $ timers [ $ key ] -> stop ( ) ; } else { throw new \ LogicException ( 'Stopping timer when the given key timer was not initialized.' ) ; } }
10539	protected function _setMany ( $ data ) { $ data = $ this -> _normalizeIterable ( $ data ) ; $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerSetMany ( $ store , $ data ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } }
9752	public function set_posts_to_review ( ) { $ total_posts = wp_count_posts ( ) ; $ total_posts = isset ( $ total_posts -> publish ) ? $ total_posts -> publish : 0 ; $ posts = get_posts ( [ 'post_type' => 'post' , 'numberposts' => $ total_posts , 'post_status' => 'publish' , ] ) ; foreach ( $ posts as $ post ) { if ( isset ( $ post -> ID ) ) { add_post_meta ( $ post -> ID , 'custom_images_grifus' , 'false' , true ) ; } } }
12566	public function sendVideo ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VIDEO , $ message , $ to ) ; }
4206	private function getPropInfo ( Event $ abs , \ ReflectionProperty $ reflectionProperty ) { $ obj = $ abs -> getSubject ( ) ; $ reflectionProperty -> setAccessible ( true ) ; $ className = \ get_class ( $ obj ) ; $ commentInfo = $ this -> getPropCommentInfo ( $ reflectionProperty ) ; $ declaringClassName = $ reflectionProperty -> getDeclaringClass ( ) -> getName ( ) ; $ propInfo = \ array_merge ( static :: $ basePropInfo , array ( 'desc' => $ commentInfo [ 'desc' ] , 'inheritedFrom' => $ declaringClassName !== $ className ? $ declaringClassName : null , 'isStatic' => $ reflectionProperty -> isStatic ( ) , 'type' => $ commentInfo [ 'type' ] , ) ) ; if ( $ reflectionProperty -> isPrivate ( ) ) { $ propInfo [ 'visibility' ] = 'private' ; } elseif ( $ reflectionProperty -> isProtected ( ) ) { $ propInfo [ 'visibility' ] = 'protected' ; } if ( $ abs [ 'collectPropertyValues' ] ) { $ propName = $ reflectionProperty -> getName ( ) ; if ( \ array_key_exists ( $ propName , $ abs [ 'propertyOverrideValues' ] ) ) { $ propInfo [ 'value' ] = $ abs [ 'propertyOverrideValues' ] [ $ propName ] ; $ propInfo [ 'valueFrom' ] = 'debug' ; } else { $ propInfo [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } return $ propInfo ; }
11491	public function getAll ( ) : array { $ res = [ ] ; foreach ( $ this -> getKeys ( ) as $ key ) { $ res [ $ key ] = $ this -> get ( $ key ) ; } return $ res ; }
125	public function whatProvides ( $ name , ConstraintInterface $ constraint = null , $ mustMatchName = false , $ bypassFilters = false ) { if ( $ bypassFilters ) { return $ this -> computeWhatProvides ( $ name , $ constraint , $ mustMatchName , true ) ; } $ key = ( ( int ) $ mustMatchName ) . $ constraint ; if ( isset ( $ this -> providerCache [ $ name ] [ $ key ] ) ) { return $ this -> providerCache [ $ name ] [ $ key ] ; } return $ this -> providerCache [ $ name ] [ $ key ] = $ this -> computeWhatProvides ( $ name , $ constraint , $ mustMatchName , $ bypassFilters ) ; }
10604	public function setQueryParam ( $ name , $ value ) { if ( $ this -> checkQuery ( $ name ) ) { $ this -> editQuery ( $ name , $ value ) ; } else { $ this -> addQuery ( $ name , $ value ) ; } return $ this ; }
3615	public function setEcoTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = array ( ) ; if ( $ temp_low === FALSE ) { $ data [ 'away_temperature_low_enabled' ] = FALSE ; } elseif ( $ temp_low != NULL ) { $ data [ 'away_temperature_low_enabled' ] = TRUE ; $ data [ 'away_temperature_low' ] = $ temp_low ; } if ( $ temp_high === FALSE ) { $ data [ 'away_temperature_high_enabled' ] = FALSE ; } elseif ( $ temp_high != NULL ) { $ data [ 'away_temperature_high_enabled' ] = TRUE ; $ data [ 'away_temperature_high' ] = $ temp_high ; } $ data = json_encode ( $ data ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
10711	public function getManyByIds ( array $ ids , $ columns = [ '*' ] ) { $ results = $ this -> getQuery ( ) -> findMany ( $ ids , $ columns ) ; return $ this -> returnResults ( $ results ) ; }
10449	public function load ( $ config ) { if ( is_string ( $ config ) and file_exists ( $ config ) ) { $ config = include $ config ; } if ( ! is_array ( $ config ) ) { $ msg = 'Failed to load configuration data' ; throw new ConfigurationException ( $ msg ) ; } return new Configuration ( $ config ) ; }
925	public function getExceptionErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_EXCEPTION === $ error -> getType ( ) ; } ) ; }
10889	public function parse ( ) { list ( $ opt_str , $ long_opts , $ mapping ) = $ this -> getOptString ( ) ; $ opts = \ getopt ( $ opt_str , $ long_opts ) ; $ options = $ this -> mapOptions ( $ opts , $ mapping ) ; return new Dictionary ( $ options ) ; }
10326	function addRule ( $ rule ) { if ( ! $ this -> rules ) $ this -> rules = array ( ) ; array_push ( $ this -> rules , $ rule ) ; }
3836	private function setLanguageStrings ( ) { if ( empty ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] = array ( $ this -> getLangValue ( $ this -> get ( 'name' ) ) , $ this -> getLangValue ( $ this -> get ( 'description' ) ) , ) ; } }
8722	public function translate ( $ locale ) { $ found = $ this -> translations -> where ( $ this -> getLocaleKey ( ) , $ locale ) -> first ( ) ; if ( ! $ found && $ this -> shouldFallback ( $ locale ) ) { return $ this -> translate ( $ this -> getFallbackLocale ( ) ) ; } return $ found ; }
10598	protected function initViewPanelRequestedUrlData ( ) { $ req = & $ this -> request ; $ this -> view -> requestedUrl = ( object ) [ 'method' => htmlSpecialChars ( $ req -> GetMethod ( ) , ENT_IGNORE , 'UTF-8' ) , 'baseUrl' => htmlSpecialChars ( $ req -> GetBaseUrl ( ) , ENT_IGNORE , 'UTF-8' ) , 'path' => htmlSpecialChars ( $ req -> GetRequestPath ( ) , ENT_IGNORE , 'UTF-8' ) , ] ; }
1092	public function reload ( ) { if ( $ this -> exists || ( $ this -> areSoftDeletesEnabled ( ) && $ this -> trashed ( ) ) ) { $ fresh = $ this -> getFreshInstance ( ) ; if ( is_null ( $ fresh ) ) throw with ( new ModelNotFoundException ) -> setModel ( get_called_class ( ) ) ; $ this -> setRawAttributes ( $ fresh -> getAttributes ( ) , true ) ; $ this -> setRelations ( $ fresh -> getRelations ( ) ) ; $ this -> exists = $ fresh -> exists ; } else { $ this -> attributes = $ this -> original ; } return $ this ; }
5607	public function paintGroupEnd ( $ group ) { $ this -> group = '' ; $ cc = '' ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { $ arrfiles = xdebug_get_code_coverage ( ) ; xdebug_stop_code_coverage ( ) ; $ thisdir = dirname ( __FILE__ ) ; $ thisdirlen = strlen ( $ thisdir ) ; foreach ( $ arrfiles as $ index => $ file ) { if ( substr ( $ index , 0 , $ thisdirlen ) === $ thisdir ) { continue ; } $ lcnt = 0 ; $ ccnt = 0 ; foreach ( $ file as $ line ) { if ( $ line == - 2 ) { continue ; } $ lcnt ++ ; if ( $ line == 1 ) { $ ccnt ++ ; } } if ( $ lcnt > 0 ) { $ cc .= round ( ( $ ccnt / $ lcnt ) * 100 , 2 ) . '%' ; } else { $ cc .= '0.00%' ; } $ cc .= "\t" . $ index . "\n" ; } } } $ this -> listener -> write ( '{status:"coverage",message:"' . self :: escapeVal ( $ cc ) . '"}' ) ; }
12393	public function onSiteSaved ( SiteSavedEvent $ event ) { $ fs = new Filesystem ( ) ; $ fs -> mirror ( $ this -> configurationHandler -> uploadAssetsDir ( ) , $ this -> configurationHandler -> uploadAssetsDirProduction ( ) ) ; }
3172	protected function updateStats ( & $ target , $ itemInfos ) { if ( ! isset ( $ target [ 'stats' ] ) ) { $ target [ 'stats' ] = [ 'questions' => 0 , 'answered' => 0 , 'flagged' => 0 , 'viewed' => 0 , 'total' => 0 , 'questionsViewed' => 0 , ] ; } if ( empty ( $ itemInfos [ 'informational' ] ) ) { $ target [ 'stats' ] [ 'questions' ] ++ ; if ( ! empty ( $ itemInfos [ 'answered' ] ) ) { $ target [ 'stats' ] [ 'answered' ] ++ ; } if ( ! empty ( $ itemInfos [ 'viewed' ] ) ) { $ target [ 'stats' ] [ 'questionsViewed' ] ++ ; } } if ( ! empty ( $ itemInfos [ 'flagged' ] ) ) { $ target [ 'stats' ] [ 'flagged' ] ++ ; } if ( ! empty ( $ itemInfos [ 'viewed' ] ) ) { $ target [ 'stats' ] [ 'viewed' ] ++ ; } $ target [ 'stats' ] [ 'total' ] ++ ; }
160	public function andHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'and' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
547	protected function addServers ( $ cache , $ servers ) { if ( empty ( $ servers ) ) { $ servers = [ new MemCacheServer ( [ 'host' => '127.0.0.1' , 'port' => 11211 , ] ) ] ; } else { foreach ( $ servers as $ server ) { if ( $ server -> host === null ) { throw new InvalidConfigException ( "The 'host' property must be specified for every memcache server." ) ; } } } if ( $ this -> useMemcached ) { $ this -> addMemcachedServers ( $ cache , $ servers ) ; } else { $ this -> addMemcacheServers ( $ cache , $ servers ) ; } }
10514	private function updateObserverState ( \ StdClass $ observer ) { $ this -> event -> function = $ observer -> function ; $ observerObject = $ observer -> observer ; $ observerObject -> update ( $ this ) ; }
9742	public function addPrintAreaByColumnAndRow ( $ column1 , $ row1 , $ column2 , $ row2 , $ index = - 1 ) { return $ this -> setPrintArea ( Coordinate :: stringFromColumnIndex ( $ column1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ column2 ) . $ row2 , $ index , self :: SETPRINTRANGE_INSERT ) ; }
8011	private static function setParityBit ( $ byte ) { $ parity = 1 ; for ( $ i = 1 ; $ i < 8 ; $ i ++ ) { $ parity = ( $ parity + ( ( $ byte >> $ i ) & 1 ) ) % 2 ; } $ byte = $ byte | ( $ parity & 1 ) ; return $ byte ; }
12592	public function toSQLString ( ) { if ( $ this -> operator == 'IN' ) { $ sql = '(' ; $ komma = '' ; for ( $ i = 0 ; $ i < count ( $ this -> operation ) ; $ i ++ ) { $ sql .= $ komma . '?' ; $ komma = ',' ; } $ sql .= ')' ; return $ sql ; } elseif ( $ this -> operator == 'BETWEEN' ) { return '? AND ?' ; } }
15	public function replaceVersion ( $ version , $ prettyVersion ) { $ this -> version = $ version ; $ this -> prettyVersion = $ prettyVersion ; $ this -> stability = VersionParser :: parseStability ( $ version ) ; $ this -> dev = $ this -> stability === 'dev' ; }
442	public function hasEventHandlers ( $ name ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( ! empty ( $ handlers ) && StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { return true ; } } return ! empty ( $ this -> _events [ $ name ] ) || Event :: hasHandlers ( $ this , $ name ) ; }
6485	private function isUsingStandardPort ( ) : bool { return $ this -> port === null || ( ( $ this -> scheme === 'http' && $ this -> port === 80 ) || ( $ this -> scheme === 'https' && $ this -> port === 443 ) ) ; }
8856	public function increase ( ) { $ this -> retries ++ ; if ( $ this -> retries > $ this -> maxRetries ) { throw new MaxRetriesExceededException ( sprintf ( 'Max allowed retries exceeded. Allowed: %s. Tried: %s.' , $ this -> maxRetries , $ this -> retries ) ) ; } return $ this ; }
12436	public function addExtra ( $ id , IFormField $ formField ) { $ formField -> setId ( $ id ) ; return $ this -> addFormField ( $ formField , true ) ; }
8440	public function createAction ( string $ production_slug , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_USER' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; $ post = new Post ( ) ; $ post -> setActive ( true ) ; $ post -> setPinned ( false ) ; $ post -> setAuthor ( $ user -> getUsername ( ) ) ; $ post -> addGroup ( $ production ) ; if ( $ request -> query -> has ( 'reply-to' ) ) { $ repo = $ this -> em -> getRepository ( Post :: class ) ; if ( null === $ parent = $ repo -> findOneBy ( [ 'id' => $ request -> query -> get ( 'reply-to' ) ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ parent -> getGroups ( ) -> contains ( $ production ) ) { throw new AccessDeniedException ( ) ; } if ( null !== $ parent -> getParent ( ) ) { throw new AccessDeniedException ( ) ; } $ post -> setParent ( $ parent ) ; $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> persist ( $ post ) ; $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.created' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/create.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
10809	protected function __templates ( $ customTemplate = null , $ customTemplateSuffix = null ) { $ templates = SSViewer :: get_templates_by_class ( $ this -> class , $ customTemplateSuffix , \ FormField :: class ) ; if ( ! $ templates ) { throw new \ Exception ( "No template found for {$this->class}" ) ; } if ( $ customTemplate ) { array_unshift ( $ templates , $ customTemplate ) ; } return $ templates ; }
10846	protected function restoreWordCase ( $ token ) { if ( $ token === strtoupper ( $ token ) ) { return function ( $ word ) { return strtoupper ( $ word ) ; } ; } if ( $ token === ucfirst ( $ token ) ) { return function ( $ word ) { return ucfirst ( $ word ) ; } ; } return function ( $ word ) { return $ word ; } ; }
8099	protected function validateAll ( $ includeAllRules = false ) { if ( $ includeAllRules ) { $ fieldData = new Collection ( array_fill_keys ( array_keys ( $ this -> _validations -> toArray ( ) ) , null ) ) ; $ fieldData -> update ( $ this -> _updates -> toArray ( ) ) ; } else { $ fieldData = clone $ this -> _updates ; } foreach ( $ fieldData -> toArray ( ) as $ field => $ val ) { $ field2 = $ field . '2' ; if ( ! is_null ( $ fieldData -> $ field2 ) ) { if ( $ val != $ fieldData -> $ field2 ) { $ this -> log -> formError ( $ field , ucfirst ( $ field ) . 's did not match' ) ; } else { $ this -> log -> report ( ucfirst ( $ field ) . 's matched' ) ; } } if ( $ this -> _updates -> $ field ) { $ this -> _updates -> $ field = trim ( $ val ) ; } if ( $ validation = $ this -> _validations -> $ field ) { $ this -> validate ( $ field , $ validation -> limit , $ validation -> regEx ) ; } } return ! $ this -> log -> hasError ( ) ; }
11859	public static function getHandlingObject ( $ a , $ b ) { $ handlingA = $ a -> handlingComparison ; $ handlingB = $ b -> handlingComparison ; if ( ! $ handlingB ) { return $ a ; } if ( $ handlingA !== false && $ handlingB !== false ) { if ( $ handlingA > $ handlingB ) { return $ a ; } else { return $ b ; } } return $ a ; }
8115	public function advanceReviewDate ( ) { $ nextDateTimestamp = false ; $ options = $ this -> getOptions ( ) ; if ( $ options && $ options -> ReviewPeriodDays ) { $ nextDateTimestamp = strtotime ( ' + ' . $ options -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ this -> owner -> NextReviewDate = DBDate :: create ( ) -> setValue ( $ nextDateTimestamp ) -> Format ( DBDate :: ISO_DATE ) ; $ this -> owner -> write ( ) ; } return ( bool ) $ nextDateTimestamp ; }
5902	public function retrieveGroup ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/groups/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Group ( $ result ) ; return $ result ; }
3024	public function getBlogPosts ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/posts' ) ; if ( $ options && isset ( $ options [ 'type' ] ) ) { $ path .= '/' . $ options [ 'type' ] ; unset ( $ options [ 'type' ] ) ; } return $ this -> getRequest ( $ path , $ options , true ) ; }
11880	protected function getRunner ( ) { if ( null === $ this -> runner ) { $ this -> runner = new ConsoleApplication ( $ this -> name , $ this -> version , $ this -> description , $ this -> alias ) ; } return $ this -> runner ; }
1809	public function getContentElementGroup ( $ element ) { foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { if ( $ kk == $ element ) { return $ k ; } } } return null ; }
8644	public function getReportRequestCount ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestCountRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestCountRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestCount ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestCountResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10808	public static function isRender ( $ request ) { return true ; $ accept = $ request -> header ( 'accept' ) ?? '' ; if ( static :: isHas ( $ accept , 'json' ) || static :: isHas ( $ accept , 'api' ) ) { return true ; } else if ( static :: isHas ( $ accept , 'html' ) || static :: isHas ( $ accept , 'xml' ) || static :: isHas ( $ accept , 'text' ) ) { return false ; } else if ( $ request -> header ( 'x-ddv-restful-api' ) ) { return true ; } else if ( $ request -> header ( 'authorization' ) ) { foreach ( $ request -> headers -> keys ( ) as $ value ) { if ( static :: isHas ( $ accept , 'x-ddv-' ) ) { return true ; } } } return false ; }
6102	public function listPropertyTypes ( $ systemName = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/propertysets/propertytypes' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new PropertyType ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; if ( null !== $ systemName ) { foreach ( $ result as $ entry ) { if ( $ entry -> getSystemName ( ) === $ systemName ) { return $ entry ; } } return null ; } return $ result ; }
8665	private function convertGetReportRequestCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportRequestCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetReportProcessingStatusList ( ) ) { $ reportProcessingStatusList = $ request -> getReportProcessingStatusList ( ) ; foreach ( $ reportProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'ReportProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetRequestedFromDate ( ) ) { $ parameters [ 'RequestedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedFromDate ( ) ) ; } if ( $ request -> isSetRequestedToDate ( ) ) { $ parameters [ 'RequestedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
6827	public static function isValid ( $ action , $ throw = false ) { if ( in_array ( $ action , static :: getActions ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Unknown gateway action '$action'." ) ; } return false ; }
1751	public static function getReferer ( $ blnEncodeAmpersands = false , $ strTable = null ) { $ objSession = static :: getContainer ( ) -> get ( 'session' ) ; $ ref = Input :: get ( 'ref' ) ; $ key = Input :: get ( 'popup' ) ? 'popupReferer' : 'referer' ; $ session = $ objSession -> get ( $ key ) ; if ( $ ref && isset ( $ session [ $ ref ] ) ) { $ session = $ session [ $ ref ] ; } elseif ( \ defined ( 'TL_MODE' ) && TL_MODE == 'BE' && \ is_array ( $ session ) ) { $ session = end ( $ session ) ; } if ( $ strTable != '' && isset ( $ session [ $ strTable ] ) && Input :: get ( 'act' ) != 'select' ) { $ session [ 'current' ] = $ session [ $ strTable ] ; } $ cleanUrl = function ( $ url , $ params = array ( 'rt' , 'ref' ) ) { if ( $ url == '' || strpos ( $ url , '?' ) === false ) { return $ url ; } list ( $ path , $ query ) = explode ( '?' , $ url , 2 ) ; $ queryObj = new Query ( $ query ) ; $ queryObj = $ queryObj -> withoutPairs ( $ params ) ; return $ path . $ queryObj -> getUriComponent ( ) ; } ; $ strUrl = ( $ cleanUrl ( $ session [ 'current' ] ) != $ cleanUrl ( Environment :: get ( 'request' ) ) ) ? $ session [ 'current' ] : $ session [ 'last' ] ; $ return = $ cleanUrl ( $ strUrl , array ( 'tg' , 'ptg' ) ) ; if ( $ return == '' && \ defined ( 'TL_MODE' ) && TL_MODE == 'FE' ) { $ return = Environment :: get ( 'httpReferer' ) ; } if ( $ return == '' ) { $ return = ( \ defined ( 'TL_MODE' ) && TL_MODE == 'BE' ) ? 'contao/main.php' : Environment :: get ( 'url' ) ; } return preg_replace ( '/&(amp;)?/i' , ( $ blnEncodeAmpersands ? '&amp;' : '&' ) , $ return ) ; }
12811	private static function getForeignKeysNames ( string $ table ) : array { if ( self :: $ foreignKeysCache === null || ! array_key_exists ( $ table , self :: $ foreignKeysCache ) ) self :: getForeignKeys ( $ table ) ; return array_keys ( self :: $ foreignKeysCache [ $ table ] ) ; }
3466	public function put ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: put ( $ route ) ) ; }
1363	public static function create ( array $ parameters , $ beforeKey = 'before' , $ afterKey = 'after' , $ limitKey = 'limit' ) { return new self ( array_get ( $ parameters , $ beforeKey ) , array_get ( $ parameters , $ afterKey ) , array_get ( $ parameters , $ limitKey , 15 ) ) ; }
3213	static function checkArgOrNull ( $ argName , $ argValue ) { if ( $ argValue === null ) return ; if ( ! ( $ argValue instanceof self ) ) Checker :: throwError ( $ argName , $ argValue , __CLASS__ ) ; }
8594	public function listOrdersByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListOrdersByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10162	private function readSelection ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ paneId = ord ( $ recordData [ 0 ] ) ; $ r = self :: getUInt2d ( $ recordData , 1 ) ; $ c = self :: getUInt2d ( $ recordData , 3 ) ; $ index = self :: getUInt2d ( $ recordData , 5 ) ; $ data = substr ( $ recordData , 7 ) ; $ cellRangeAddressList = $ this -> readBIFF5CellRangeAddressList ( $ data ) ; $ selectedCells = $ cellRangeAddressList [ 'cellRangeAddresses' ] [ 0 ] ; if ( preg_match ( '/^([A-Z]+1\:[A-Z]+)16384$/' , $ selectedCells ) ) { $ selectedCells = preg_replace ( '/^([A-Z]+1\:[A-Z]+)16384$/' , '${1}1048576' , $ selectedCells ) ; } if ( preg_match ( '/^([A-Z]+1\:[A-Z]+)65536$/' , $ selectedCells ) ) { $ selectedCells = preg_replace ( '/^([A-Z]+1\:[A-Z]+)65536$/' , '${1}1048576' , $ selectedCells ) ; } if ( preg_match ( '/^(A\d+\:)IV(\d+)$/' , $ selectedCells ) ) { $ selectedCells = preg_replace ( '/^(A\d+\:)IV(\d+)$/' , '${1}XFD${2}' , $ selectedCells ) ; } $ this -> phpSheet -> setSelectedCells ( $ selectedCells ) ; } }
3008	public function getAttribute ( $ key ) { if ( ! isset ( $ this -> attributes [ $ key ] ) ) { return false ; } return $ this -> attributes [ $ key ] ; }
5371	public function attach ( $ key , $ content , $ filename ) { $ this -> request [ ] = new SimpleAttachment ( $ key , $ content , $ filename ) ; }
9108	protected function attainThemeName ( ) { $ themeName = $ this -> getResolverObject ( 'resolver_adapter_service' ) -> getName ( ) ; return ( empty ( $ themeName ) && ! ( $ themeName === '0' ) ) ? false : $ themeName ; }
5242	public function getAutoloads ( ) : array { if ( empty ( $ this -> autoloads ) ) { $ this -> autoloads = $ this -> configCollection -> getAutoloads ( ) ; } return $ this -> autoloads ; }
6168	protected function writeAssertionFailure ( $ assertionFailure ) { $ this -> writeNewLine ( ) ; foreach ( explode ( "\n" , $ assertionFailure ) as $ line ) { $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
10108	private function writeSelection ( ) { $ selectedCells = Coordinate :: splitRange ( $ this -> phpSheet -> getSelectedCells ( ) ) ; $ selectedCells = $ selectedCells [ 0 ] ; if ( count ( $ selectedCells ) == 2 ) { list ( $ first , $ last ) = $ selectedCells ; } else { $ first = $ selectedCells [ 0 ] ; $ last = $ selectedCells [ 0 ] ; } list ( $ colFirst , $ rwFirst ) = Coordinate :: coordinateFromString ( $ first ) ; $ colFirst = Coordinate :: columnIndexFromString ( $ colFirst ) - 1 ; -- $ rwFirst ; list ( $ colLast , $ rwLast ) = Coordinate :: coordinateFromString ( $ last ) ; $ colLast = Coordinate :: columnIndexFromString ( $ colLast ) - 1 ; -- $ rwLast ; $ colFirst = min ( $ colFirst , 255 ) ; $ colLast = min ( $ colLast , 255 ) ; $ rwFirst = min ( $ rwFirst , 65535 ) ; $ rwLast = min ( $ rwLast , 65535 ) ; $ record = 0x001D ; $ length = 0x000F ; $ pnn = $ this -> activePane ; $ rwAct = $ rwFirst ; $ colAct = $ colFirst ; $ irefAct = 0 ; $ cref = 1 ; if ( ! isset ( $ rwLast ) ) { $ rwLast = $ rwFirst ; } if ( ! isset ( $ colLast ) ) { $ colLast = $ colFirst ; } if ( $ rwFirst > $ rwLast ) { list ( $ rwFirst , $ rwLast ) = [ $ rwLast , $ rwFirst ] ; } if ( $ colFirst > $ colLast ) { list ( $ colFirst , $ colLast ) = [ $ colLast , $ colFirst ] ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'CvvvvvvCC' , $ pnn , $ rwAct , $ colAct , $ irefAct , $ cref , $ rwFirst , $ rwLast , $ colFirst , $ colLast ) ; $ this -> append ( $ header . $ data ) ; }
3454	public static function fromAggregateRoot ( $ eventSourcedAggregateRoot ) : AggregateType { if ( ! \ is_object ( $ eventSourcedAggregateRoot ) ) { throw new Exception \ AggregateTypeException ( \ sprintf ( 'Aggregate root must be an object but type of %s given' , \ gettype ( $ eventSourcedAggregateRoot ) ) ) ; } if ( $ eventSourcedAggregateRoot instanceof AggregateTypeProvider ) { return $ eventSourcedAggregateRoot -> aggregateType ( ) ; } $ self = new static ( ) ; $ self -> aggregateType = \ get_class ( $ eventSourcedAggregateRoot ) ; return $ self ; }
9148	public function markAsRead ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; $ object -> markAsRead ( ) ; \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
2339	public function renderDropdown ( ) { $ objVersion = $ this -> Database -> prepare ( "SELECT tstamp, version, username, active FROM tl_version WHERE fromTable=? AND pid=? ORDER BY version DESC" ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> numRows < 2 ) { return '' ; } $ versions = '' ; while ( $ objVersion -> next ( ) ) { $ versions .= ' <option value="' . $ objVersion -> version . '"' . ( $ objVersion -> active ? ' selected="selected"' : '' ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'version' ] . ' ' . $ objVersion -> version . ' (' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ objVersion -> tstamp ) . ') ' . $ objVersion -> username . '</option>' ; } return '<div class="tl_version_panel"><form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_version" class="tl_form" method="post" aria-label="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versioning' ] ) . '"><div class="tl_formbody"><input type="hidden" name="FORM_SUBMIT" value="tl_version"><input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"><select name="version" class="tl_select">' . $ versions . '</select><button type="submit" name="showVersion" id="showVersion" class="tl_submit">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'restore' ] . '</button><a href="' . Backend :: addToUrl ( 'versions=1&amp;popup=1' ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . StringUtil :: specialchars ( str_replace ( "'" , "\\'" , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] , $ this -> intPid , $ this -> strTable ) ) ) . '\',\'url\':this.href});return false">' . Image :: getHtml ( 'diff.svg' ) . '</a></div></form></div>' ; }
7160	public function buildSaleView ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> initialize ( $ sale , $ options ) ; $ this -> amountCalculator -> calculateSale ( $ sale ) ; $ grossResult = $ sale -> getGrossResult ( ) ; $ this -> view -> setGross ( new TotalView ( $ this -> formatter -> currency ( $ grossResult -> getGross ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getDiscount ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getBase ( $ this -> view -> isAti ( ) ) ) ) ) ; $ finalResult = $ sale -> getFinalResult ( ) ; $ this -> view -> setFinal ( new TotalView ( $ this -> formatter -> currency ( $ finalResult -> getBase ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTax ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTotal ( ) ) ) ) ; if ( $ this -> options [ 'private' ] && null !== $ margin = $ this -> marginCalculator -> calculateSale ( $ sale ) ) { $ prefix = $ margin -> isAverage ( ) ? '~' : '' ; $ this -> view -> setMargin ( new MarginView ( $ prefix . $ this -> formatter -> currency ( $ margin -> getAmount ( ) ) , $ prefix . $ this -> formatter -> percent ( $ margin -> getPercent ( ) ) ) ) ; $ this -> view -> vars [ 'show_margin' ] = true ; } $ this -> buildSaleItemsLinesViews ( $ sale ) ; $ this -> buildSaleDiscountsLinesViews ( $ sale ) ; $ this -> buildShipmentLine ( $ sale ) ; $ this -> buildSaleTaxesViews ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> buildSaleView ( $ sale , $ this -> view , $ this -> options ) ; } $ columnsCount = 6 ; if ( $ this -> view -> vars [ 'show_availability' ] ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_discounts' ] = 0 < count ( $ grossResult -> getDiscountAdjustments ( ) ) ) { $ columnsCount += 3 ; } if ( $ this -> view -> vars [ 'show_taxes' ] = 1 < count ( $ finalResult -> getTaxAdjustments ( ) ) ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_margin' ] ) { $ columnsCount ++ ; } if ( $ this -> options [ 'editable' ] ) { $ columnsCount ++ ; } $ this -> view -> vars [ 'columns_count' ] = $ columnsCount ; return $ this -> view ; }
8314	protected function finishPasswordReset ( array $ resetData ) { if ( time ( ) > $ resetData [ 'validity' ] ) { $ this -> session -> remove ( "pwreset" ) ; $ this -> session -> addFlash ( "error" , "Page validity expired, please try again." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; } $ this -> picoAuth -> addOutput ( "isReset" , true ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/pwreset.md' ) ; $ post = $ this -> httpRequest -> request ; if ( $ post -> has ( "new_password" ) && $ post -> has ( "new_password_repeat" ) ) { $ newPassword = new Password ( $ post -> get ( "new_password" ) ) ; $ newPasswordRepeat = new Password ( $ post -> get ( "new_password_repeat" ) ) ; $ username = $ resetData [ 'user' ] ; if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( $ newPassword -> get ( ) !== $ newPasswordRepeat -> get ( ) ) { $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ newPassword ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ this -> session -> remove ( "pwreset" ) ; $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ newPassword ) ; $ this -> storage -> saveUser ( $ username , $ userData ) ; $ this -> logPasswordReset ( $ username ) ; $ localAuth -> login ( $ username , $ userData ) ; $ this -> picoAuth -> afterLogin ( ) ; } }
12780	public function setState ( $ key , $ value ) { return Yii :: $ app -> webState -> set ( $ this -> stateKeyName ( $ key ) , $ value ) ; }
4617	public function buildLocalhost ( array $ ports = [ 8087 ] ) { $ nodes = [ ] ; $ this -> atHost ( 'localhost' ) ; foreach ( $ ports as $ port ) { $ nodes [ ] = $ this -> onPort ( $ port ) -> build ( ) ; } return $ nodes ; }
10127	private function writeWsbool ( ) { $ record = 0x0081 ; $ length = 0x0002 ; $ grbit = 0x0000 ; $ grbit |= 0x0001 ; if ( $ this -> outlineStyle ) { $ grbit |= 0x0020 ; } if ( $ this -> phpSheet -> getShowSummaryBelow ( ) ) { $ grbit |= 0x0040 ; } if ( $ this -> phpSheet -> getShowSummaryRight ( ) ) { $ grbit |= 0x0080 ; } if ( $ this -> phpSheet -> getPageSetup ( ) -> getFitToPage ( ) ) { $ grbit |= 0x0100 ; } if ( $ this -> outlineOn ) { $ grbit |= 0x0400 ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ grbit ) ; $ this -> append ( $ header . $ data ) ; }
8702	public function saveElementAsFile ( $ fileName ) { $ this -> getString ( ) ; if ( false === file_put_contents ( $ fileName , $ this -> elementString ) ) { return false ; } else { return $ fileName ; } }
1907	protected function escapeParams ( $ arrValues ) { foreach ( $ arrValues as $ k => $ v ) { switch ( \ gettype ( $ v ) ) { case 'string' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( $ v ) ; break ; case 'boolean' : $ arrValues [ $ k ] = ( $ v === true ) ? 1 : 0 ; break ; case 'object' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( serialize ( $ v ) ) ; break ; case 'array' : $ arrValues [ $ k ] = $ this -> resConnection -> quote ( serialize ( $ v ) ) ; break ; default : $ arrValues [ $ k ] = $ v ?? 'NULL' ; break ; } } return $ arrValues ; }
7871	protected function drawPipesEnd ( ) { $ pipes = array_reverse ( $ this -> pipes ) ; foreach ( $ pipes as $ pipe ) { $ this -> drawBordered ( $ this -> geometry -> getSpacedPipe ( $ pipe , static :: NOCK , 'after()' ) ) ; $ this -> drawBorderBottom ( ) ; } }
10988	public function getConfigTreeBuilder ( ) { $ tree_builder = new TreeBuilder ( ) ; $ tree_builder -> root ( 'anime_db_cache_time_keeper' ) -> children ( ) -> booleanNode ( 'enable' ) -> defaultTrue ( ) -> end ( ) -> scalarNode ( 'use_driver' ) -> cannotBeEmpty ( ) -> defaultValue ( 'file' ) -> end ( ) -> arrayNode ( 'private_headers' ) -> treatNullLike ( [ ] ) -> prototype ( 'scalar' ) -> end ( ) -> defaultValue ( [ 'Authorization' , 'Cookie' ] ) -> end ( ) -> append ( $ this -> getEtagHasher ( ) ) -> append ( $ this -> getTrack ( ) ) -> arrayNode ( 'drivers' ) -> append ( $ this -> getDriverFile ( ) ) -> append ( $ this -> getDriverMemcache ( ) ) -> append ( $ this -> getDriverMulti ( ) ) -> append ( $ this -> getDriverShmop ( ) ) -> end ( ) -> end ( ) ; return $ tree_builder ; }
4999	protected function fixOneToMany ( PageInterface $ object ) { $ items = $ object -> getContentItems ( ) ; if ( $ items ) { foreach ( $ object -> getContentItems ( ) as $ item ) { $ item -> setPage ( $ object ) ; } } if ( $ this -> menuManager ) { $ this -> menuManager -> flush ( ) ; } }
869	private function createProcessForSource ( $ source ) { if ( null === $ this -> temporaryFile ) { $ this -> temporaryFile = tempnam ( '.' , 'cs_fixer_tmp_' ) ; $ this -> fileRemoval -> observe ( $ this -> temporaryFile ) ; } if ( false === @ file_put_contents ( $ this -> temporaryFile , $ source ) ) { throw new IOException ( sprintf ( 'Failed to write file "%s".' , $ this -> temporaryFile ) , 0 , null , $ this -> temporaryFile ) ; } return $ this -> createProcessForFile ( $ this -> temporaryFile ) ; }
1652	public function getPerimeter ( DistanceInterface $ calculator ) : float { $ perimeter = 0.0 ; if ( count ( $ this -> points ) < 2 ) { return $ perimeter ; } foreach ( $ this -> getSegments ( ) as $ segment ) { $ perimeter += $ segment -> getLength ( $ calculator ) ; } return $ perimeter ; }
4833	public function authorize_url ( $ options = null ) { if ( ! isset ( $ options [ 'redirect_uri' ] ) ) { throw new GoCardless_ArgumentsException ( 'redirect_uri required' ) ; } $ required_options = array ( "client_id" => $ this -> account_details [ 'app_id' ] , "scope" => "manage_merchant" , "response_type" => "code" ) ; $ params = array_merge ( $ required_options , $ options ) ; $ request = GoCardless_Utils :: generate_query_string ( $ params ) ; return $ this -> base_url . "/oauth/authorize/?" . $ request ; }
9442	public function getManyWithoutReplacement ( $ n ) { if ( ! is_integer ( $ n ) || $ n < 2 ) { throw new \ InvalidArgumentException ( 'You must take 2 or more items in this case.' ) ; } if ( $ this -> range -> as_integer ) { $ arr_range = range ( $ this -> range -> min , $ this -> range -> max ) ; $ max_takable = count ( $ arr_range ) ; shuffle ( $ arr_range ) ; if ( $ n > $ max_takable ) { throw new \ OutOfRangeException ( sprintf ( 'Cannot take without replacement more than available items into range [%d;%d]' , $ this -> range -> min , $ this -> range -> max ) ) ; } elseif ( $ n == $ max_takable ) { return array_values ( $ arr_range ) ; } else { return array_slice ( $ arr_range , 0 , $ n ) ; } } else { $ arr_out = array ( ) ; while ( count ( $ arr_out ) < $ n ) { $ r = $ this -> get ( ) ; if ( ! in_array ( $ r , $ arr_out ) ) { $ arr_out [ ] = $ r ; } } return $ arr_out ; } }
12268	protected function renderSlots ( Page $ page , array $ slots , array $ options = array ( ) ) { $ renderedSlots = array ( ) ; $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERING , $ page , $ slots ) ; foreach ( $ slots as $ slotName => $ slot ) { if ( is_string ( $ slot ) ) { $ renderedSlots [ $ slotName ] = $ slot ; continue ; } if ( ! $ slot instanceof Slot ) { continue ; } $ blocks = $ slot -> getEntitiesInUse ( ) ; $ renderedSlots [ $ slotName ] = $ this -> templating -> render ( 'RedKiteCms/Resources/views/Slot/slot.html.twig' , array ( 'options' => $ options , 'slotname' => $ slotName , 'data' => rawurlencode ( "[" . implode ( "," , $ blocks ) ) . "]" , 'next' => $ slot -> getNext ( ) , ) ) ; } return $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERED , $ page , $ renderedSlots ) ; }
3326	public function render ( OptionCollection $ options ) { $ lines = array ( ) ; foreach ( $ options as $ option ) { $ c1 = $ this -> renderOption ( $ option ) ; $ lines [ ] = "\t" . $ c1 ; $ lines [ ] = wordwrap ( "\t\t" . $ option -> desc , $ this -> screenWidth , "\n\t\t" ) ; $ lines [ ] = '' ; } return implode ( "\n" , $ lines ) ; }
6512	public function updateJob ( EntityJobInterface $ job , Status $ status , $ processingTime = 0 , $ response = null ) { $ job -> setStatus ( $ status ) ; $ job -> setProcessingTime ( $ job -> getProcessingTime ( ) + ( $ processingTime === null ? 0 : $ processingTime ) ) ; $ job -> setResponse ( $ response ) ; if ( Status :: isTerminated ( $ status ) ) { $ job -> setTerminatedAt ( new \ DateTime ( ) ) ; } if ( $ job -> hasSchedules ( ) && Status :: isTerminated ( $ status ) ) { foreach ( $ job -> getSchedules ( ) as $ schedule ) { if ( method_exists ( $ schedule , 'setIsActive' ) ) { $ schedule -> setIsActive ( false ) ; } } } }
875	private function convertToNowdoc ( Token $ token ) { return new Token ( [ $ token -> getId ( ) , Preg :: replace ( '/^([Bb]?<<<)([ \t]*)"?([^\s"]+)"?/' , '$1$2\'$3\'' , $ token -> getContent ( ) ) , ] ) ; }
5654	private function renderFlagSet ( $ flags , $ explanation , $ tab_stop ) { $ flag = array_shift ( $ flags ) ; $ text = str_pad ( $ this -> renderFlag ( $ flag ) , $ tab_stop , ' ' ) . $ explanation . "\n" ; foreach ( $ flags as $ flag ) { $ text .= ' ' . $ this -> renderFlag ( $ flag ) . "\n" ; } return $ text ; }
10605	public function addHeaders ( array $ headers ) : void { foreach ( $ headers as $ name => $ value ) { $ this -> addHeader ( ( string ) $ name , $ value ) ; } }
2723	public function execute ( Observer $ observer ) { if ( $ this -> fastlyConfig -> isFastlyEnabled ( ) != true ) { return ; } $ event = $ observer -> getEvent ( ) ; $ name = $ event -> getElementName ( ) ; $ layout = $ event -> getLayout ( ) ; $ block = $ layout -> getBlock ( $ name ) ; if ( $ block instanceof AbstractBlock ) { $ blockTtl = $ block -> getTtl ( ) ; if ( isset ( $ blockTtl ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } } }
8590	public function setGetMatchingProductResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMatchingProductResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7748	private function isAccessible ( \ ReflectionClass $ class , $ methodName , $ parameters ) { if ( $ class -> hasMethod ( $ methodName ) ) { $ method = $ class -> getMethod ( $ methodName ) ; if ( $ method -> isPublic ( ) && $ method -> getNumberOfRequiredParameters ( ) === $ parameters ) { return true ; } } return false ; }
6083	public function uploadFile ( $ pathname , $ name , $ categoryId , $ progress = null , $ chunkSize = 10485760 ) { $ chunk = 0 ; $ chunksTotal = ceil ( filesize ( $ pathname ) / $ chunkSize ) ; $ fileId = sha1 ( uniqid ( 'upload' , true ) ) ; $ fp = fopen ( $ pathname , 'rb' ) ; if ( false === $ fp ) { throw new UploadException ( 'Could not open file "' . $ pathname . '" for reading.' ) ; } if ( $ chunkSize > 10485760 ) { $ this -> logger -> warning ( 'Using a chunk size larger then 10MB is not recommended. Uploading is not guaranteed to work properly.' ) ; } while ( $ chunkData = fread ( $ fp , $ chunkSize ) ) { $ result = $ this -> uploadFileChunked ( $ chunkData , $ name , $ chunk , $ chunksTotal , $ fileId , $ categoryId ) ; if ( is_callable ( $ progress ) ) { try { call_user_func ( $ progress , $ chunk + 1 , $ chunksTotal ) ; } catch ( \ Exception $ e ) { $ this -> logger -> warning ( 'Could not report progress due to callback error.' , [ 'message' => $ e -> getMessage ( ) ] ) ; } } $ this -> logger -> info ( 'Upload progress!' , [ 'part' => $ chunk + 1 , 'total' => $ chunksTotal ] ) ; if ( isset ( $ result [ 'mediaId' ] ) ) { return new MediaResponse ( $ result ) ; } if ( isset ( $ result [ 'success' ] ) && false == $ result [ 'success' ] ) { throw new UploadException ( $ result [ 'error' ] [ 'message' ] , $ result [ 'error' ] [ 'code' ] ) ; } if ( isset ( $ result [ 'fileId' ] ) ) { $ fileId = $ result [ 'fileId' ] ; } ++ $ chunk ; } if ( $ chunk == $ chunksTotal - 1 ) { throw new UploadException ( 'Uploaded all chunks, but something went wrong.' ) ; } if ( false === $ chunkData ) { throw new UploadException ( 'Could not read chunk ' . $ chunk . ' from file "' . $ pathname . '".' ) ; } throw new UploadException ( 'Unknown upload error!' ) ; }
9858	private function isValueInList ( Cell $ cell ) { $ cellValue = $ cell -> getValue ( ) ; $ dataValidation = $ cell -> getDataValidation ( ) ; $ formula1 = $ dataValidation -> getFormula1 ( ) ; if ( ! empty ( $ formula1 ) ) { if ( $ formula1 [ 0 ] === '"' ) { return in_array ( strtolower ( $ cellValue ) , explode ( ',' , strtolower ( trim ( $ formula1 , '"' ) ) ) , true ) ; } elseif ( strpos ( $ formula1 , ':' ) > 0 ) { $ matchFormula = '=MATCH(' . $ cell -> getCoordinate ( ) . ', ' . $ formula1 . ', 0)' ; $ calculation = Calculation :: getInstance ( $ cell -> getWorksheet ( ) -> getParent ( ) ) ; try { $ result = $ calculation -> calculateFormula ( $ matchFormula , $ cell -> getCoordinate ( ) , $ cell ) ; return $ result !== Functions :: NA ( ) ; } catch ( Exception $ ex ) { return false ; } } } return true ; }
10934	protected function is_php ( $ version ) { static $ _is_php ; $ version = ( string ) $ version ; if ( ! isset ( $ _is_php [ $ version ] ) ) { $ _is_php [ $ version ] = version_compare ( PHP_VERSION , $ version , '>=' ) ; } return $ _is_php [ $ version ] ; }
7864	protected function drawPipesBeginning ( ) { foreach ( $ this -> pipes as $ pipe ) { $ this -> drawBorderTop ( ) ; $ this -> drawBordered ( $ this -> geometry -> getSpacedPipe ( $ pipe , static :: NOCK , 'before()' ) ) ; } }
10491	public function add ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value + $ value ) ; }
12229	public function replaceSelf ( SimpleXMLElement $ new ) { $ old = dom_import_simplexml ( $ this ) ; $ new = $ old -> ownerDocument -> importNode ( dom_import_simplexml ( $ new ) , true ) ; $ node = $ old -> parentNode -> replaceChild ( $ new , $ old ) ; return simplexml_import_dom ( $ node , get_class ( $ this ) ) ; }
11803	public static function importFromApp ( $ path ) { $ importPath = APPS_ROOT . DS . $ path . '.php' ; if ( file_exists ( $ importPath ) ) { include_once $ importPath ; } else { throw new SetupException ( "The object to import ($path) not exists." ) ; } }
8148	public function compile ( Twig_NodeInterface $ node ) { if ( null === $ this -> compiler ) { $ this -> compiler = new Twig_Compiler ( $ this ) ; } return $ this -> compiler -> compile ( $ node ) -> getSource ( ) ; }
1969	public static function findMultipleByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } if ( Validator :: isUuid ( current ( $ arrIds ) ) ) { return static :: findMultipleByUuids ( $ arrIds , $ arrOptions ) ; } return parent :: findMultipleByIds ( $ arrIds , $ arrOptions ) ; }
11046	function parse_containers ( $ containers ) { if ( ! is_array ( $ containers ) ) { $ containers = explode ( ',' , $ containers ) ; } foreach ( $ containers as $ container ) { $ masktree = $ this -> read_container ( $ container , _ETS_ROOT ) ; if ( $ masktree === FALSE ) { $ this -> error ( 11 , 52 , $ this -> container ) ; } else { $ this -> masktree = $ this -> masktree_merge ( $ this -> masktree , $ masktree , $ container ) ; } } }
4113	public function getBlockInfo ( Mage_Core_Block_Abstract $ block , $ fullInfo = true ) { $ info = array ( 'name' => $ block -> getNameInLayout ( ) , 'alias' => $ block -> getBlockAlias ( ) , ) ; if ( ! $ fullInfo ) { return $ info ; } $ info [ 'class' ] = get_class ( $ block ) ; if ( $ this -> getRemoteCallEnabled ( ) ) { $ fileAndLine = Mage :: helper ( 'aoe_templatehints/classInfo' ) -> findFileAndLine ( $ info [ 'class' ] ) ; if ( $ fileAndLine ) { $ url = sprintf ( $ this -> getRemoteCallUrlTemplate ( ) , $ fileAndLine [ 'file' ] , $ fileAndLine [ 'line' ] ) ; $ info [ 'class' ] = sprintf ( $ this -> getRemoteCallLinkTemplate ( ) , $ url , $ info [ 'class' ] ) ; } } $ info [ 'module' ] = $ block -> getModuleName ( ) ; if ( $ block instanceof Mage_Cms_Block_Block ) { $ info [ 'cms-blockId' ] = $ block -> getBlockId ( ) ; } if ( $ block instanceof Mage_Cms_Block_Page ) { $ info [ 'cms-pageId' ] = $ block -> getPage ( ) -> getIdentifier ( ) ; } $ templateFile = $ block -> getTemplateFile ( ) ; if ( $ templateFile ) { $ info [ 'template' ] = $ templateFile ; if ( $ this -> getRemoteCallEnabled ( ) ) { $ url = sprintf ( $ this -> getRemoteCallUrlTemplate ( ) , Mage :: getBaseDir ( 'design' ) . DS . $ templateFile , 0 ) ; $ info [ 'template' ] = sprintf ( $ this -> getRemoteCallLinkTemplate ( ) , $ url , $ templateFile ) ; } } $ info [ 'cache-status' ] = self :: TYPE_NOTCACHED ; $ cacheLifeTime = $ block -> getCacheLifetime ( ) ; if ( ! is_null ( $ cacheLifeTime ) ) { $ info [ 'cache-lifetime' ] = ( intval ( $ cacheLifeTime ) == 0 ) ? 'forever' : intval ( $ cacheLifeTime ) . ' sec' ; $ info [ 'cache-key' ] = $ block -> getCacheKey ( ) ; $ info [ 'cache-key-info' ] = is_array ( $ block -> getCacheKeyInfo ( ) ) ? implode ( ', ' , $ block -> getCacheKeyInfo ( ) ) : $ block -> getCacheKeyInfo ( ) ; $ info [ 'tags' ] = implode ( ',' , $ block -> getCacheTags ( ) ) ; $ info [ 'cache-status' ] = self :: TYPE_CACHED ; } elseif ( $ this -> isWithinCachedBlock ( $ block ) ) { $ info [ 'cache-status' ] = self :: TYPE_IMPLICITLYCACHED ; } $ info [ 'methods' ] = $ this -> getClassMethods ( get_class ( $ block ) ) ; return $ info ; }
10357	protected static function highlightCode ( string $ file , int $ line , int $ padding = 6 ) : array { if ( ! is_readable ( $ file ) ) { return false ; } $ handle = fopen ( $ file , 'r' ) ; $ lines = array ( ) ; $ currentLine = 0 ; while ( ! feof ( $ handle ) ) { $ currentLine ++ ; $ temp = fgets ( $ handle ) ; if ( $ currentLine > $ line + $ padding ) { break ; } if ( $ currentLine >= ( $ line - $ padding ) && $ currentLine <= ( $ line + $ padding ) ) { $ lines [ ] = array ( 'number' => str_pad ( $ currentLine , 4 , ' ' , STR_PAD_LEFT ) , 'highlighted' => ( $ currentLine === $ line ) , 'code' => ErrorHandler :: highlightString ( $ temp ) , ) ; } } fclose ( $ handle ) ; return $ lines ; }
4375	protected function buildGroupMethod ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ str = '' ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ label = \ array_shift ( $ args ) ; $ levelClass = isset ( $ meta [ 'level' ] ) ? 'level-' . $ meta [ 'level' ] : null ; if ( ! empty ( $ meta [ 'isMethodName' ] ) ) { $ label = $ this -> markupClassname ( $ label ) ; } foreach ( $ args as $ k => $ v ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ argStr = \ implode ( ', ' , $ args ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'div' , array ( 'class' => array ( 'group-header' , $ method == 'groupCollapsed' ? 'collapsed' : 'expanded' , $ levelClass , ) , 'data-channel' => $ meta [ 'channel' ] , ) , '<span class="group-label">' . $ label . ( ! empty ( $ argStr ) ? '(</span>' . $ argStr . '<span class="group-label">)' : '' ) . '</span>' ) . "\n" ; $ str .= '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => array ( 'm_group' , $ levelClass , ) , ) ) . '>' ; } elseif ( $ method == 'groupEnd' ) { $ str = '</div>' ; } return $ str ; }
822	private function fixSemicolonAfterCurlyBraceClose ( Tokens $ tokens , $ index , $ curlyCloseIndex ) { static $ beforeCurlyOpeningKinds = null ; if ( null === $ beforeCurlyOpeningKinds ) { $ beforeCurlyOpeningKinds = [ T_ELSE , T_FINALLY , T_NAMESPACE , T_OPEN_TAG ] ; } $ curlyOpeningIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ curlyCloseIndex ) ; $ beforeCurlyOpening = $ tokens -> getPrevMeaningfulToken ( $ curlyOpeningIndex ) ; if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( $ beforeCurlyOpeningKinds ) || $ tokens [ $ beforeCurlyOpening ] -> equalsAny ( [ ';' , '{' , '}' ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( T_STRING ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ beforeCurlyOpening ) ; while ( $ tokens [ $ classyTest ] -> equals ( ',' ) || $ tokens [ $ classyTest ] -> isGivenKind ( [ T_STRING , T_NS_SEPARATOR , T_EXTENDS , T_IMPLEMENTS ] ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ classyTest ) ; } $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; if ( $ tokens [ $ classyTest ] -> isGivenKind ( T_NAMESPACE ) || ( $ tokens [ $ classyTest ] -> isClassy ( ) && ! $ tokensAnalyzer -> isAnonymousClass ( $ classyTest ) ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } return ; } if ( ! $ tokens [ $ beforeCurlyOpening ] -> equals ( ')' ) ) { return ; } $ openingBrace = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ beforeCurlyOpening ) ; $ beforeOpeningBrace = $ tokens -> getPrevMeaningfulToken ( $ openingBrace ) ; if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( [ T_IF , T_ELSEIF , T_FOR , T_FOREACH , T_WHILE , T_SWITCH , T_CATCH , T_DECLARE ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( T_STRING ) ) { $ beforeString = $ tokens -> getPrevMeaningfulToken ( $ beforeOpeningBrace ) ; if ( $ tokens [ $ beforeString ] -> isGivenKind ( T_FUNCTION ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } } }
8384	public function select ( $ select ) { if ( is_array ( $ select ) === true ) { $ this -> select = '' ; foreach ( $ select as $ key => $ elem ) { $ this -> select .= $ elem ; if ( is_numeric ( $ key ) === false ) { $ this -> select .= ' AS ' . $ key ; } $ this -> select .= ', ' ; } $ this -> select = substr ( $ this -> select , 0 , - 2 ) ; } elseif ( ! is_string ( $ select ) ) { throw new InvalidArgumentException ( sprintf ( 'Argument 1 passed to %s must be an array or string!' , __METHOD__ ) ) ; } else { $ this -> select = $ select ; } return $ this ; }
10517	private function getMediaIdentifiers ( $ values ) { $ identifiers = [ ] ; foreach ( $ values as $ key => $ id ) { if ( is_int ( $ key ) ) { $ identifiers [ ] = $ id ; } } return $ identifiers ; }
2009	public function onInitializeSystem ( ) : void { foreach ( $ this -> globals as $ key => $ value ) { if ( \ is_array ( $ value ) && isset ( $ GLOBALS [ $ key ] ) && \ is_array ( $ GLOBALS [ $ key ] ) ) { $ GLOBALS [ $ key ] = array_replace_recursive ( $ GLOBALS [ $ key ] , $ value ) ; } else { $ GLOBALS [ $ key ] = $ value ; } } }
1479	public function removeRelationship ( $ resourceType , $ id , $ relationshipKey , array $ queryParams = [ ] ) { $ name = RouteName :: removeRelationship ( $ resourceType , $ relationshipKey ) ; return $ this -> resource ( $ name , $ id , $ queryParams ) ; }
8692	public static function checkSymlink ( $ symlinkTarget , $ symlinkName , $ forceSymlink = false ) { if ( $ forceSymlink && file_exists ( $ symlinkName ) && ! is_link ( $ symlinkName ) ) { if ( 'link' !== filetype ( $ symlinkName ) ) { throw new \ UnexpectedValueException ( "{$symlinkName} exists and is not a link" ) ; } } elseif ( is_link ( $ symlinkName ) ) { $ linkTarget = readlink ( $ symlinkName ) ; if ( $ linkTarget !== $ symlinkTarget ) { if ( ! $ forceSymlink ) { throw new \ UnexpectedValueException ( "Symlink '{$symlinkName}' points to '{$linkTarget}' instead of '{$symlinkTarget}'" ) ; } unlink ( $ symlinkName ) ; return false ; } return true ; } return false ; }
5446	protected function addInTagTokens ( ) { $ this -> mapHandler ( 'tag' , 'acceptStartToken' ) ; $ this -> addSpecialPattern ( '\s+' , 'tag' , 'ignore' ) ; $ this -> addAttributeTokens ( ) ; $ this -> addExitPattern ( '/>' , 'tag' ) ; $ this -> addExitPattern ( '>' , 'tag' ) ; }
11640	public function getData ( ) { if ( is_null ( $ this -> _currentData ) ) { $ this -> _currentDataRaw = $ this -> dataProvider -> getData ( ) ; $ this -> _currentData = [ ] ; $ itemNumber = $ this -> dataProvider -> pagination -> offset ; $ row = 0 ; foreach ( $ this -> _currentDataRaw as $ r ) { $ p = [ 'itemNumber' => $ itemNumber , 'id' => $ r -> primaryKey , 'values' => [ ] ] ; foreach ( $ this -> columns as $ key => $ c ) { $ p [ 'values' ] [ $ key ] = $ c -> getDataValue ( $ row , $ r , false ) ; } $ p [ 'acl' ] = [ ] ; if ( $ this -> owner -> instanceSettings [ 'whoAmI' ] === 'parent' and isset ( $ r -> childObject ) and $ r -> childObject -> hasBehavior ( 'Access' ) ) { $ p [ 'acl' ] = $ r -> childObject -> aclSummary ( ) ; } elseif ( $ this -> owner -> instanceSettings [ 'whoAmI' ] === 'child' and isset ( $ r -> parentObject ) and $ r -> parentObject -> hasBehavior ( 'Access' ) ) { $ p [ 'acl' ] = $ r -> parentObject -> aclSummary ( ) ; } elseif ( $ r -> hasBehavior ( 'Access' ) ) { $ p [ 'acl' ] = $ r -> aclSummary ( ) ; } $ this -> _currentData [ 'item-' . $ itemNumber ] = $ p ; $ row ++ ; $ itemNumber ++ ; } } return $ this -> _currentData ; }
3392	public function resendConfirmation ( Request $ request ) { $ model = $ this -> guard ( ) -> getProvider ( ) -> createModel ( ) ; $ user = $ model -> findOrFail ( $ request -> session ( ) -> pull ( 'confirmation_user_id' ) ) ; $ this -> sendConfirmationToUser ( $ user ) ; return redirect ( $ this -> redirectAfterResendConfirmationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_resent' ) ) ; }
3168	private function getCurrentThemeId ( ) { $ themeService = $ this -> getServiceLocator ( ) -> get ( ThemeService :: SERVICE_ID ) ; return $ themeService -> getTheme ( ) -> getId ( ) ; }
3285	public function getSourceContext ( $ name ) : Source { if ( ! $ this -> exists ( $ name ) ) { throw new LoaderError ( sprintf ( 'Unable to find template "%s" from template map' , $ name ) ) ; } if ( ! file_exists ( $ this -> map [ $ name ] ) ) { throw new LoaderError ( sprintf ( 'Unable to open file "%s" from template map' , $ this -> map [ $ name ] ) ) ; } $ content = file_get_contents ( $ this -> map [ $ name ] ) ; $ source = new Source ( $ content , $ name , $ this -> map [ $ name ] ) ; return $ source ; }
5200	public function setOptions ( array $ options ) { $ this -> validateOptions ( $ options ) ; foreach ( $ options as $ option => $ value ) $ this -> $ option = $ value ; return $ this ; }
2193	protected function sendActivationMail ( $ arrData ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = $ optIn -> create ( 'reg' , $ arrData [ 'email' ] , array ( 'tl_member' => array ( $ arrData [ 'id' ] ) ) ) ; $ arrTokenData = $ arrData ; $ arrTokenData [ 'activation' ] = $ optInToken -> getIdentifier ( ) ; $ arrTokenData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrTokenData [ 'link' ] = Idna :: decode ( Environment :: get ( 'base' ) ) . Environment :: get ( 'request' ) . ( ( strpos ( Environment :: get ( 'request' ) , '?' ) !== false ) ? '&' : '?' ) . 'token=' . $ optInToken -> getIdentifier ( ) ; $ arrTokenData [ 'channels' ] = '' ; $ bundles = System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( isset ( $ bundles [ 'ContaoNewsletterBundle' ] ) ) { if ( ! \ is_array ( $ arrData [ 'newsletter' ] ) ) { if ( $ arrData [ 'newsletter' ] != '' ) { $ arrData [ 'newsletter' ] = array ( $ arrData [ 'newsletter' ] ) ; } else { $ arrData [ 'newsletter' ] = array ( ) ; } } if ( ! empty ( $ arrData [ 'newsletter' ] ) ) { $ objChannels = NewsletterChannelModel :: findByIds ( $ arrData [ 'newsletter' ] ) ; if ( $ objChannels !== null ) { $ arrTokenData [ 'channels' ] = implode ( "\n" , $ objChannels -> fetchEach ( 'title' ) ) ; } } } $ arrTokenData [ 'channel' ] = $ arrTokenData [ 'channels' ] ; $ optInToken -> send ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'emailSubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) , StringUtil :: parseSimpleTokens ( $ this -> reg_text , $ arrTokenData ) ) ; }
1890	public function grantsAccess ( ) : bool { $ content = array_filter ( file ( ( string ) $ this -> file ) ) ; foreach ( $ content as $ line ) { if ( $ this -> hasRequireGranted ( $ line ) ) { return true ; } } return false ; }
12556	private function createDeleteForm ( Tag $ tag ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_tag_delete' , array ( 'id' => $ tag -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
8154	public function addFunction ( $ name , $ function = null ) { if ( ! $ name instanceof Twig_SimpleFunction && ! ( $ function instanceof Twig_SimpleFunction || $ function instanceof Twig_FunctionInterface ) ) { throw new LogicException ( 'A function must be an instance of Twig_FunctionInterface or Twig_SimpleFunction.' ) ; } if ( $ name instanceof Twig_SimpleFunction ) { $ function = $ name ; $ name = $ function -> getName ( ) ; } else { @ trigger_error ( sprintf ( 'Passing a name as a first argument to the %s method is deprecated since version 1.21. Pass an instance of "Twig_SimpleFunction" instead when defining function "%s".' , __METHOD__ , $ name ) , E_USER_DEPRECATED ) ; } if ( $ this -> extensionInitialized ) { throw new LogicException ( sprintf ( 'Unable to add function "%s" as extensions have already been initialized.' , $ name ) ) ; } $ this -> staging -> addFunction ( $ name , $ function ) ; }
11498	public static function locate ( $ column , $ value ) { $ table = new static ( ) ; $ select = $ table -> select ( ) -> where ( "{$table->getAdapter()->quoteIdentifier($column)} = ?" , $ value ) -> limit ( 1 ) ; return $ table -> fetchRow ( $ select ) ; }
9254	public function handle ( Request $ request , $ type = self :: MASTER_REQUEST , $ catch = true ) { if ( ! $ this -> booted ) { $ this -> boot ( ) ; } $ request -> attributes -> set ( 'app' , $ this ) ; return $ this -> kernel -> handle ( $ request , $ type , $ catch ) ; }
7516	protected function expect ( $ token , $ do_next = true , $ try_next = false , $ next_on_match = 1 ) { if ( $ do_next ) { if ( $ do_next === 1 ) { $ this -> next ( ) ; } else { $ this -> next_no_whitespace ( ) ; } } if ( is_int ( $ token ) ) { if ( ( $ this -> token !== $ token ) && ( ( ! $ try_next ) || ( ( ( $ try_next === 1 ) && ( $ this -> next ( ) !== $ token ) ) || ( ( $ try_next === true ) && ( $ this -> next_no_whitespace ( ) !== $ token ) ) ) ) ) { $ this -> addError ( 'Unexpected "' . $ this -> getTokenString ( ) . '"' ) ; return false ; } } else { if ( ( $ this -> doc [ $ this -> pos ] !== $ token ) && ( ( ! $ try_next ) || ( ( ( ( $ try_next === 1 ) && ( $ this -> next ( ) !== self :: TOK_NULL ) ) || ( ( $ try_next === true ) && ( $ this -> next_no_whitespace ( ) !== self :: TOK_NULL ) ) ) && ( $ this -> doc [ $ this -> pos ] !== $ token ) ) ) ) { $ this -> addError ( 'Expected "' . $ token . '", but found "' . $ this -> getTokenString ( ) . '"' ) ; return false ; } } if ( $ next_on_match ) { if ( $ next_on_match === 1 ) { $ this -> next ( ) ; } else { $ this -> next_no_whitespace ( ) ; } } return true ; }
2372	public static function toXhtml ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*)>/i' => '<$1$2 />' , '/ border="[^"]*"/' => '' ) ; $ arrStrReplace = array ( '/ />' => ' />' , '<b>' => '<strong>' , '</b>' => '</strong>' , '<i>' => '<em>' , '</i>' => '</em>' , '<u>' => '<span style="text-decoration:underline">' , '</u>' => '</span>' , ' target="_self"' => '' , ' target="_blank"' => ' onclick="return !window.open(this.href)"' ) ; $ strString = preg_replace ( array_keys ( $ arrPregReplace ) , $ arrPregReplace , $ strString ) ; $ strString = str_ireplace ( array_keys ( $ arrStrReplace ) , $ arrStrReplace , $ strString ) ; return $ strString ; }
8502	public function setMarketplaceIdList ( $ value ) { $ marketplaceIdList = new MarketplaceWebService_Model_IdList ( ) ; $ marketplaceIdList -> setId ( $ value [ 'Id' ] ) ; $ this -> fields [ 'MarketplaceIdList' ] [ 'FieldValue' ] = $ marketplaceIdList ; return ; }
9037	protected function update ( $ entity , $ where = null , $ tableName = null , HydratorInterface $ hydrator = null ) { if ( ! $ where ) { $ where = 'id = ' . $ entity -> getId ( ) ; } return parent :: update ( $ entity , $ where , $ tableName , $ hydrator ) ; }
578	public static function to ( $ url = '' , $ scheme = false ) { if ( is_array ( $ url ) ) { return static :: toRoute ( $ url , $ scheme ) ; } $ url = Yii :: getAlias ( $ url ) ; if ( $ url === '' ) { $ url = Yii :: $ app -> getRequest ( ) -> getUrl ( ) ; } if ( $ scheme === false ) { return $ url ; } if ( static :: isRelative ( $ url ) ) { $ url = static :: getUrlManager ( ) -> getHostInfo ( ) . '/' . ltrim ( $ url , '/' ) ; } return static :: ensureScheme ( $ url , $ scheme ) ; }
7158	public function compile ( Database $ db = NULL ) : string { if ( $ db === null ) { $ db = \ Mii :: $ app -> db ; } $ value = $ this -> value ( ) ; if ( ! empty ( $ this -> _parameters ) ) { $ params = array_map ( [ $ db , 'quote' ] , $ this -> _parameters ) ; $ value = strtr ( $ value , $ params ) ; } return $ value ; }
7715	static function FindStartTagByPrefix ( & $ Txt , $ TagPrefix , $ PosBeg , $ Forward = true ) { $ x = '<' . $ TagPrefix ; $ xl = strlen ( $ x ) ; if ( $ Forward ) { $ PosBeg = strpos ( $ Txt , $ x , $ PosBeg ) ; } else { $ PosBeg = strrpos ( substr ( $ Txt , 0 , $ PosBeg + 2 ) , $ x ) ; } if ( $ PosBeg === false ) return false ; $ Tag = $ TagPrefix ; $ p = $ PosBeg + $ xl ; do { $ z = substr ( $ Txt , $ p , 1 ) ; if ( ( $ z !== ' ' ) && ( $ z !== "\r" ) && ( $ z !== "\n" ) && ( $ z !== '>' ) && ( $ z !== '/' ) ) { $ Tag .= $ z ; $ p ++ ; } else { $ p = false ; } } while ( $ p !== false ) ; return new clsTbsXmlLoc ( $ Txt , $ Tag , $ PosBeg ) ; }
4271	public function rename ( $ pathFrom , $ pathTo ) { self :: restorePrev ( ) ; $ success = \ rename ( $ pathFrom , $ pathTo ) ; self :: register ( ) ; return $ success ; }
9022	public function getStopWords ( $ string , $ language = 'english' ) { $ words = $ this -> getWords ( $ string ) ; $ filter = new StopWordsFilter ( $ language ) ; $ stopWords = [ ] ; foreach ( $ words as $ word ) { if ( ! is_null ( $ filter -> filter ( $ word ) ) ) { $ stopWords [ ] = $ word ; } } return $ stopWords ; }
8867	protected function logTask ( TaskInterface $ task , $ level , $ message , array $ context = array ( ) ) { $ class = get_class ( $ task ) ; $ message = sprintf ( 'Task: %s. ' , $ class ) . $ message ; $ this -> log ( $ level , $ message , $ context ) ; }
8462	public static function getBaseUrl ( ) { $ uri = self :: addBackSlash ( self :: getUriMethods ( ) , 'both' ) ; $ url = self :: addBackSlash ( self :: getCurrentPage ( ) ) ; if ( $ uri !== '/' ) { $ url = trim ( str_replace ( $ uri , '' , $ url ) , '/' ) ; } return self :: addBackSlash ( $ url ) ; }
1011	private function readNumber ( $ line , $ col , Token $ prev ) { $ value = '' ; $ start = $ this -> position ; [ $ char , $ code ] = $ this -> readChar ( ) ; $ isFloat = false ; if ( $ code === 45 ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } if ( $ code === 48 ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; if ( $ code >= 48 && $ code <= 57 ) { throw new SyntaxError ( $ this -> source , $ this -> position , 'Invalid number, unexpected digit after 0: ' . Utils :: printCharCode ( $ code ) ) ; } } else { $ value .= $ this -> readDigits ( ) ; [ $ char , $ code ] = $ this -> readChar ( ) ; } if ( $ code === 46 ) { $ isFloat = true ; $ this -> moveStringCursor ( 1 , 1 ) ; $ value .= $ char ; $ value .= $ this -> readDigits ( ) ; [ $ char , $ code ] = $ this -> readChar ( ) ; } if ( $ code === 69 || $ code === 101 ) { $ isFloat = true ; $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; if ( $ code === 43 || $ code === 45 ) { $ value .= $ char ; $ this -> moveStringCursor ( 1 , 1 ) ; } $ value .= $ this -> readDigits ( ) ; } return new Token ( $ isFloat ? Token :: FLOAT : Token :: INT , $ start , $ this -> position , $ line , $ col , $ prev , $ value ) ; }
2653	public function updateSnippet ( array $ snippet ) { $ url = $ this -> _getApiServiceUri ( ) . 'snippet' . '/' . $ snippet [ 'name' ] ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ snippet ) ; return $ result ; }
9133	public function route ( string $ name , Request $ request ) { $ parts = \ explode ( '/' , $ request -> getOrigin ( ) ) ; $ found = false ; for ( $ i = 0 ; $ i < count ( $ parts ) ; $ i ++ ) { if ( $ parts [ $ i ] === $ name && isset ( $ parts [ $ i + 1 ] ) ) { $ action = $ parts [ $ i + 1 ] ; if ( strpos ( $ action , "?" ) ) { $ action = strstr ( $ action , "?" , true ) ; } $ request -> setAction ( $ action ) ; $ found = true ; } } if ( ! $ found ) { $ request -> setAction ( "index" ) ; } $ controller = $ this -> getRoute ( $ name ) ; $ request -> setController ( $ controller -> getControllerSimpleName ( ) ) ; return $ controller ; }
4711	public function wrap ( $ start , $ end ) { $ this -> text = $ start . $ this -> text . $ end ; return $ this ; }
588	protected function adjustDependency ( $ targets , $ bundles ) { $ this -> stdout ( "Creating new bundle configuration...\n" ) ; $ map = [ ] ; foreach ( $ targets as $ name => $ target ) { foreach ( $ target -> depends as $ bundle ) { $ map [ $ bundle ] = $ name ; } } foreach ( $ targets as $ name => $ target ) { $ depends = [ ] ; foreach ( $ target -> depends as $ bn ) { foreach ( $ bundles [ $ bn ] -> depends as $ bundle ) { $ depends [ $ map [ $ bundle ] ] = true ; } } unset ( $ depends [ $ name ] ) ; $ target -> depends = array_keys ( $ depends ) ; } foreach ( $ targets as $ name => $ target ) { $ registered = [ ] ; $ this -> registerBundle ( $ targets , $ name , $ registered ) ; } foreach ( $ map as $ bundle => $ target ) { $ sourceBundle = $ bundles [ $ bundle ] ; $ depends = $ sourceBundle -> depends ; if ( ! $ this -> isBundleExternal ( $ sourceBundle ) ) { $ depends [ ] = $ target ; } $ targetBundle = clone $ sourceBundle ; $ targetBundle -> depends = $ depends ; $ targets [ $ bundle ] = $ targetBundle ; } return $ targets ; }
581	public function getAssetManager ( ) { if ( ! is_object ( $ this -> _assetManager ) ) { $ options = $ this -> _assetManager ; if ( ! isset ( $ options [ 'class' ] ) ) { $ options [ 'class' ] = 'yii\\web\\AssetManager' ; } if ( ! isset ( $ options [ 'basePath' ] ) ) { throw new Exception ( "Please specify 'basePath' for the 'assetManager' option." ) ; } if ( ! isset ( $ options [ 'baseUrl' ] ) ) { throw new Exception ( "Please specify 'baseUrl' for the 'assetManager' option." ) ; } if ( ! isset ( $ options [ 'forceCopy' ] ) ) { $ options [ 'forceCopy' ] = true ; } $ this -> _assetManager = Yii :: createObject ( $ options ) ; } return $ this -> _assetManager ; }
8782	protected function finish ( $ output = null ) { if ( ! is_null ( $ output ) ) { $ file = fopen ( $ this -> file , 'w+' ) ; fwrite ( $ file , $ output ) ; fclose ( $ file ) ; return $ output ; } return false ; }
7652	public function url_stat ( $ path , $ flags ) { $ stat = array ( ) ; $ stat [ 'dev' ] = 0 ; $ stat [ 'ino' ] = 0 ; $ stat [ 'mode' ] = 0 ; $ stat [ 'nlink' ] = 0 ; $ stat [ 'uid' ] = 0 ; $ stat [ 'gid' ] = 0 ; $ stat [ 'rdev' ] = 0 ; $ stat [ 'size' ] = 0 ; $ stat [ 'atime' ] = 0 ; $ stat [ 'mtime' ] = 0 ; $ stat [ 'ctime' ] = 0 ; $ stat [ 'blksize' ] = 0 ; $ stat [ 'blocks' ] = 0 ; $ info = null ; try { $ info = $ this -> getStorageClient ( $ path ) -> getBlobInstance ( $ this -> getContainerName ( $ path ) , $ this -> getFileName ( $ path ) ) ; $ stat [ 'size' ] = $ info -> Size ; $ lastmodified = strtotime ( $ info -> LastModified ) ; $ stat [ 'mtime' ] = $ lastmodified ; $ stat [ 'ctime' ] = $ lastmodified ; $ stat [ 'mode' ] = 0100000 ; return array_values ( $ stat ) + $ stat ; } catch ( BlobException $ ex ) { return false ; } }
8190	public function actionRegister ( ) { $ model = new User ( ) ; $ model -> scenario = 'register' ; if ( $ model -> load ( Yii :: $ app -> request -> post ( ) ) && $ model -> register ( FALSE , User :: STATUS_PENDING ) ) { Mailer :: sendWelcomeMessage ( $ model ) ; Yii :: $ app -> session -> setFlash ( 'success' , Yii :: t ( 'user' , 'You\'ve successfully been registered. Check your mail to activate your account' ) ) ; return $ this -> redirect ( Yii :: $ app -> urlManager -> createUrl ( '//user/auth/login' ) ) ; } return $ this -> render ( 'register' , [ 'model' => $ model ] ) ; }
11521	public function off ( $ eventType , $ listener = null ) { foreach ( $ this -> _eventListeners as $ i => $ l ) { if ( $ l -> getType ( ) == $ eventType ) { if ( $ listener === null || $ l -> getListener ( ) === $ listener ) { unset ( $ this -> _eventListeners [ $ i ] ) ; } } } }
2567	protected function checkAllNotEmpty ( ) { $ foundEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( empty ( $ arg ) ) { $ foundEmpty = true ; break ; } } return ! $ foundEmpty ; }
6271	protected function throwException ( $ msg ) { if ( $ this -> handle ) { fclose ( $ this -> handle ) ; unlink ( $ this -> tmpFileName ) ; } throw new Exception ( $ msg ) ; }
4451	public function recur ( string $ className , array $ data , ? int $ interval = null , ? int $ offset = null , ? string $ jid = null , ? int $ retries = null , ? int $ priority = null , ? int $ backlog = null , ? array $ tags = null ) { try { $ jid = $ jid ? : Uuid :: uuid4 ( ) -> toString ( ) ; } catch ( \ Exception $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } $ data = json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ; if ( empty ( $ data ) ) { throw new RuntimeException ( sprintf ( 'Unable to encode payload to make a recurring job "%s" for the "%s" queue.' , $ jid , $ this -> name ) ) ; } return $ this -> client -> recur ( $ this -> name , $ jid , $ className , $ data , 'interval' , is_null ( $ interval ) ? 60 : $ interval , is_null ( $ offset ) ? 0 : $ offset , 'priority' , is_null ( $ priority ) ? 0 : $ priority , 'tags' , json_encode ( $ tags ? : [ ] , JSON_UNESCAPED_SLASHES ) , 'retries' , is_null ( $ retries ) ? 5 : $ retries , 'backlog' , is_null ( $ backlog ) ? 0 : $ backlog ) ; }
6636	protected function initLanguages ( ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } if ( ! isset ( Yii :: $ app -> wavecms ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Component "wavecms" not defined in config.php' ) ) ; if ( ! count ( Yii :: $ app -> wavecms -> languages ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Property "languages" is not defined in config file for component "wavecms"' ) ) ; if ( ! Yii :: $ app -> session -> get ( 'editedLanguage' ) ) { Yii :: $ app -> session -> set ( 'editedLanguage' , Yii :: $ app -> wavecms -> languages [ 0 ] ) ; } Yii :: $ app -> wavecms -> editedLanguage = Yii :: $ app -> session -> get ( 'editedLanguage' ) ; }
12877	public function generateAndroidManifest ( ) { $ pinicon = $ this -> owner -> AndroidPinicon ( ) ; if ( $ pinicon -> exists ( ) ) { $ manifest = new stdClass ( ) ; $ manifest -> name = $ this -> owner -> PiniconTitle ; $ manifest -> icons = array ( ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 36 , 36 ) -> getAbsoluteURL ( ) , 'sizes' => '36x36' , 'type' => 'image/png' , 'density' => 0.75 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 48 , 48 ) -> getAbsoluteURL ( ) , 'sizes' => '48x48' , 'type' => 'image/png' , 'density' => 1 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'sizes' => '72x72' , 'type' => 'image/png' , 'density' => 1.5 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 96 , 96 ) -> getAbsoluteURL ( ) , 'sizes' => '96x96' , 'type' => 'image/png' , 'density' => 2 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'sizes' => '144x144' , 'type' => 'image/png' , 'density' => 3 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 192 , 192 ) -> getAbsoluteURL ( ) , 'sizes' => '192x192' , 'type' => 'image/png' , 'density' => 4 ) ) ; $ bytes = file_put_contents ( Director :: baseFolder ( ) . '/manifest.json' , json_encode ( $ manifest ) ) ; if ( $ bytes !== false ) { return true ; } } return false ; }
3869	protected function getMetaModel ( $ identifier , $ ignoreError ) { $ factory = $ this -> getMetaModelsFactory ( ) ; if ( is_numeric ( $ identifier ) ) { $ identifier = $ factory -> translateIdToMetaModelName ( $ identifier ) ; } $ metaModels = $ factory -> getMetaModel ( $ identifier ) ; if ( ! $ ignoreError && $ metaModels == null ) { throw new \ RuntimeException ( 'Could not find the MetaModels with the name ' . $ identifier ) ; } return $ metaModels ; }
11844	private function addAPerson ( array $ person , ObjectManager $ manager ) { $ p = new Person ( ) ; foreach ( $ person as $ key => $ value ) { switch ( $ key ) { case 'CountryOfBirth' : case 'Nationality' : $ value = $ this -> getCountry ( $ value ) ; break ; case 'Birthdate' : $ value = new \ DateTime ( $ value ) ; break ; case 'center' : case 'maritalStatus' : $ value = $ this -> getReference ( $ value ) ; break ; } if ( method_exists ( $ p , 'set' . $ key ) ) { call_user_func ( array ( $ p , 'set' . $ key ) , $ value ) ; } elseif ( method_exists ( $ p , 'add' . $ key ) ) { if ( ! is_array ( $ value ) ) { $ value = array ( $ value ) ; } foreach ( $ value as $ v ) { if ( $ v !== NULL ) { call_user_func ( array ( $ p , 'add' . $ key ) , $ v ) ; } } } } $ manager -> persist ( $ p ) ; echo "add person'" . $ p -> __toString ( ) . "'\n" ; }
2743	public function execute ( Observer $ observer ) { if ( $ this -> backendAuthSession -> isLoggedIn ( ) == false ) { return ; } if ( $ this -> getFrequency ( ) + $ this -> getLastUpdate ( ) > time ( ) ) { return ; } $ modulePath = $ this -> moduleRegistry -> getPath ( ComponentRegistrar :: MODULE , 'Fastly_Cdn' ) ; $ filePath = str_replace ( [ '\\' , '/' ] , DIRECTORY_SEPARATOR , "$modulePath/composer.json" ) ; $ composerData = json_decode ( file_get_contents ( $ filePath ) ) ; $ currentVersion = ! empty ( $ composerData -> version ) ? $ composerData -> version : false ; if ( $ currentVersion ) { $ this -> feedFactory -> checkUpdate ( $ currentVersion ) ; } $ this -> setLastUpdate ( ) ; }
9057	public function addPrimaryKey ( string $ name ) : Column { $ column = $ this -> addColumn ( $ name ) ; $ this -> setPrimaryKey ( $ name ) ; return $ column ; }
1387	protected function resourceTypeNotSupported ( string $ actual , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceTypeNotSupported ( $ actual , $ path ) ) ; }
7400	private function getFormErrorData ( Form $ form ) { if ( $ form -> isValid ( ) ) { return $ this -> getResponseData ( 'An error occurred while processing the submitted information' ) ; } $ errors = $ this -> getErrors ( $ form ) ; $ message = $ this -> getMainErrorMessage ( $ form ) ; return $ this -> getResponseData ( $ message , $ errors ) ; }
9109	public function getResolverObject ( $ state = null , array $ options = array ( ) ) { if ( $ state == null && isset ( $ this -> resolverObject [ 'last_resolver' ] ) ) { return $ this -> resolverObject [ 'last_resolver' ] ; } if ( $ state != 'resolver_adapter_service' && $ state != 'mvclayout_resolver_adapter' ) throw new \ Exception ( 'Invalid state name provided.' ) ; $ config = $ this -> getConfig ( ) ; if ( isset ( $ config [ 'theme_locator' ] ) ) $ config = $ config [ 'theme_locator' ] ; else $ config = array ( ) ; if ( ! isset ( $ config [ $ state ] ) ) throw new \ Exception ( "Theme Resolver Service not present in config[$state]." ) ; $ config = $ config [ $ state ] ; if ( is_string ( $ config ) ) { $ config = array ( "{$config}" => 1 ) ; } if ( isset ( $ this -> resolverObject [ $ state ] ) ) { $ resolver = $ this -> resolverObject [ $ state ] ; $ this -> resolverObject [ 'last_resolver' ] = $ resolver ; return $ resolver ; } else $ resolver = new Resolvers \ Aggregate ( ) ; foreach ( $ config as $ service => $ priority ) { if ( $ this -> getServiceLocator ( ) -> has ( $ service ) ) { $ service = $ this -> getServiceLocator ( ) -> get ( $ service ) ; } else { if ( ! class_exists ( $ service ) ) throw new \ Exception ( "Resolver '$service' not found for yimaTheme as Service either Class." ) ; $ service = new $ service ( ) ; } if ( $ service instanceof Resolvers \ LocatorResolverAwareInterface ) { $ service -> setThemeLocator ( $ this ) ; } if ( $ service instanceof Resolvers \ ConfigResolverAwareInterface ) { $ service -> setConfig ( $ this -> getConfig ( ) ) ; } if ( isset ( $ options [ 'event_mvc' ] ) ) if ( $ service instanceof Resolvers \ MvcResolverAwareInterface ) $ service -> setMvcEvent ( $ options [ 'event_mvc' ] ) ; $ resolver -> attach ( $ service , $ priority ) ; } $ this -> resolverObject [ $ state ] = $ resolver ; $ this -> resolverObject [ 'last_resolver' ] = $ resolver ; return $ resolver ; }
6113	public function sendPluginCmd ( $ plugin , $ data , $ cpw = null , $ subscribed = false ) { if ( $ this -> getId ( ) != $ this -> getParent ( ) -> whoamiGet ( "client_channel_id" ) ) { $ this -> getParent ( ) -> clientMove ( $ this -> getParent ( ) -> whoamiGet ( "client_id" ) , $ this -> getId ( ) , $ cpw ) ; } $ this -> execute ( "plugincmd" , array ( "name" => $ plugin , "data" => $ data , "targetmode" => $ subscribed ? TeamSpeak3 :: PLUGINCMD_CHANNEL_SUBSCRIBED : TeamSpeak3 :: PLUGINCMD_CHANNEL ) ) ; }
4505	public function getList ( Parameters $ parameters = null ) : array { $ options = [ ] ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; if ( array_key_exists ( 'organizationUuid' , $ options [ 'query' ] ) ) { $ options [ 'query' ] [ 'organization.uuid' ] = $ options [ 'query' ] [ 'organizationUuid' ] ; unset ( $ options [ 'query' ] [ 'organizationUuid' ] ) ; } } $ objects = $ this -> execute ( 'GET' , static :: RESOURCE_LIST , $ options ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
12481	public function registerServices ( ServicesFactory $ servicesFactory , array $ entityManagers ) { foreach ( $ entityManagers as $ name => $ entityManager ) { $ emConfig = Setup :: createAnnotationMetadataConfiguration ( ( array ) $ entityManager -> getEntities ( ) , true , null , null , true ) ; $ emConfig -> setNamingStrategy ( new UnderscoreNamingStrategy ( ) ) ; $ em = $ this -> createEntityManager ( $ entityManager -> toArray ( ) , $ emConfig ) ; $ emServiceId = 'doctrine.em.' . Str :: cast ( $ name ) -> lower ( ) ; $ servicesFactory -> registerService ( [ 'id' => $ emServiceId , 'instance' => $ em ] ) ; $ servicesFactory -> registerService ( [ 'id' => 'db.connection.' . $ name , 'instance' => $ em -> getConnection ( ) -> getWrappedConnection ( ) ] ) ; } }
6232	public function setPickupPoint ( $ pickup_point_id ) { $ service = new AdditionalService ( ) ; $ service -> setServiceCode ( 2106 ) ; $ service -> addSpecifier ( 'pickup_point_id' , $ pickup_point_id ) ; $ this -> addAdditionalService ( $ service ) ; }
4147	protected function getResponse ( ) { $ url = $ this -> getUrl ( ) ; $ params = array ( 'get' => $ this -> getParams , 'post' => $ this -> postParams , 'headers' => $ this -> buildRequestHeader ( ) , ) ; return $ this -> curl -> send ( $ url , $ params ) ; }
8862	public function getYearlyArchiveLink ( ) { $ date = $ this -> dbObject ( "PublishDate" ) ; return Controller :: join_links ( $ this -> Parent ( ) -> Link ( "archive" ) , $ date -> format ( "Y" ) ) ; }
10736	public function compare ( $ x ) : int { if ( ! is_numeric ( $ x ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, x, to be a number" ) ; } if ( $ x < $ this -> lower || ( ! $ this -> isLowerInclusive && $ x == $ this -> lower ) ) { return - 1 ; } elseif ( $ x > $ this -> upper || ( ! $ this -> isUpperInclusive && $ x == $ this -> upper ) ) { return 1 ; } else { return 0 ; } }
7520	function parse_cdata ( ) { if ( $ this -> next_pos ( ']]>' , false ) === self :: TOK_UNKNOWN ) { $ this -> status [ 'cdata' ] = $ this -> getTokenString ( 9 , - 1 ) ; $ this -> status [ 'last_pos' ] = $ this -> pos + 2 ; return true ; } else { $ this -> addError ( 'Invalid cdata tag' ) ; return false ; } }
7606	public function render ( array $ aDropdownOptions ) { if ( empty ( $ aDropdownOptions [ 'attributes' ] ) ) { $ aDropdownOptions [ 'attributes' ] = array ( 'class' => 'dropdown' ) ; } else { if ( ! is_array ( $ aDropdownOptions [ 'attributes' ] ) ) { throw new LogicException ( '"attributes" option expects an array, "' . gettype ( $ aDropdownOptions [ 'attributes' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'attributes' ] [ 'class' ] = 'dropdown' ; } elseif ( ! preg_match ( '/(\s|^)dropdown(\s|$)/' , $ aDropdownOptions [ 'attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'attributes' ] [ 'class' ] .= ' dropdown' ; } } return sprintf ( static :: $ dropdownContainerFormat , $ this -> createAttributesString ( $ aDropdownOptions [ 'attributes' ] ) , $ this -> renderToggle ( $ aDropdownOptions ) . $ this -> renderListItems ( $ aDropdownOptions ) ) ; }
8967	public static function clean ( $ currencyCode ) { $ clean = trim ( strtoupper ( $ currencyCode ) ) ; if ( ! self :: exists ( $ clean ) ) { throw new UnknownCurrencyCodeException ( sprintf ( 'Unknown currency code "%s".' , $ currencyCode ) ) ; } return $ clean ; }
11197	public function add ( $ item , $ key = false , $ dataKey = false ) { $ keyPrefix = '' ; if ( is_array ( $ dataKey ) ) { $ keyPrefix = $ dataKey [ 1 ] ; $ dataKey = $ dataKey [ 0 ] ; } if ( is_object ( $ item ) ) { if ( $ key ) { if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else if ( $ dataKey && isset ( $ item -> $ dataKey ) ) { $ key = $ item -> $ dataKey ; if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> { $ keyPrefix . $ key } = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } else if ( is_array ( $ item ) ) { if ( $ key ) { if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else if ( $ dataKey && isset ( $ item [ $ dataKey ] ) ) { $ key = $ item [ $ dataKey ] ; if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> { $ keyPrefix . $ key } = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } else { if ( $ key ) { if ( ! $ this -> __isset ( $ key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } $ this -> contentModified = true ; return $ this ; }
498	public function applyTo ( $ path ) { $ pathMap = $ this -> pathMap ; if ( empty ( $ pathMap ) ) { if ( ( $ basePath = $ this -> getBasePath ( ) ) === null ) { throw new InvalidConfigException ( 'The "basePath" property must be set.' ) ; } $ pathMap = [ Yii :: $ app -> getBasePath ( ) => [ $ basePath ] ] ; } $ path = FileHelper :: normalizePath ( $ path ) ; foreach ( $ pathMap as $ from => $ tos ) { $ from = FileHelper :: normalizePath ( Yii :: getAlias ( $ from ) ) . DIRECTORY_SEPARATOR ; if ( strpos ( $ path , $ from ) === 0 ) { $ n = strlen ( $ from ) ; foreach ( ( array ) $ tos as $ to ) { $ to = FileHelper :: normalizePath ( Yii :: getAlias ( $ to ) ) . DIRECTORY_SEPARATOR ; $ file = $ to . substr ( $ path , $ n ) ; if ( is_file ( $ file ) ) { return $ file ; } } } } return $ path ; }
10920	public static function getString ( $ language , $ separator = ',' ) { $ fileName = __DIR__ . '/stop-words/' . $ language . '.txt' ; if ( file_exists ( $ fileName ) ) { return implode ( $ separator , array_map ( 'trim' , file ( $ fileName ) ) ) ; } return '' ; }
12712	public function getResolvedConcreteFlag ( $ abstract ) { if ( ! $ this -> hasResolvedConcrete ( $ abstract ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be an abstract class name which exists in resolved concrete stack." , __METHOD__ ) ) ; } return explode ( '|' , $ this -> resolved [ $ abstract ] [ 'flag' ] ) ; }
11126	public function update ( Request $ request ) { foreach ( $ request -> all ( ) as $ key => $ value ) { if ( substr ( $ key , 0 , 8 ) == 'setting_' ) { $ skipSave = false ; $ key = substr ( $ key , 8 ) ; if ( ! $ skipSave ) { $ this -> settingRepository -> save ( $ key , $ value ) ; } } } Flash :: success ( trans ( 'l5starter::messages.update.success' ) ) ; return redirect ( route ( 'admin.settings.index' ) ) ; }
4943	protected function addBaseFieldset ( ) { if ( null === $ this -> baseFieldset ) { return ; } $ fs = $ this -> baseFieldset ; if ( ! is_array ( $ fs ) ) { $ fs = array ( 'type' => $ fs , ) ; } if ( ! isset ( $ fs [ 'options' ] [ 'use_as_base_fieldset' ] ) ) { $ fs [ 'options' ] [ 'use_as_base_fieldset' ] = true ; } $ this -> add ( $ fs ) ; }
12894	public function close ( $ account , $ openId ) { $ params = [ 'kf_account' => $ account , 'openid' => $ openId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CLOSE , $ params ] ) ; }
12976	public function parseMappingInfo ( ) { $ mappings = array ( ) ; foreach ( $ this -> getMappings ( ) as $ mappingName => $ mappingConfig ) { if ( is_array ( $ mappingConfig ) === false or \ Arr :: get ( $ mappingConfig , 'mapping' , true ) === false ) { continue ; } $ mappingConfig = array_replace ( array ( 'dir' => false , 'type' => false , 'prefix' => false , ) , $ mappingConfig ) ; if ( isset ( $ mappingConfig [ 'is_component' ] ) === false ) { $ mappingConfig [ 'is_component' ] = false ; if ( is_dir ( $ mappingConfig [ 'dir' ] ) === false ) { $ mappingConfig [ 'is_component' ] = ( \ Package :: loaded ( $ mappingName ) or \ Module :: loaded ( $ mappingName ) ) ; } } if ( $ mappingConfig [ 'is_component' ] ) { $ mappingConfig = $ this -> getComponentDefaults ( $ mappingName , $ mappingConfig ) ; } if ( empty ( $ mappingConfig ) ) { continue ; } $ mappings [ $ mappingName ] = $ mappingConfig ; } $ this -> config [ 'mappings' ] = $ mappings ; }
475	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "delete from $table" ) ; $ this -> db -> createCommand ( ) -> delete ( $ table , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
813	private function fixSpaceAboveClassElement ( Tokens $ tokens , $ classStartIndex , $ elementIndex ) { static $ methodAttr = [ T_PRIVATE , T_PROTECTED , T_PUBLIC , T_ABSTRACT , T_FINAL , T_STATIC ] ; $ firstElementAttributeIndex = $ elementIndex ; for ( $ i = $ elementIndex ; $ i > $ classStartIndex ; -- $ i ) { $ nonWhiteAbove = $ tokens -> getNonWhitespaceSibling ( $ i , - 1 ) ; if ( null !== $ nonWhiteAbove && $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( $ methodAttr ) ) { $ firstElementAttributeIndex = $ nonWhiteAbove ; } else { break ; } } if ( $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_COMMENT ) ) { if ( 1 === $ firstElementAttributeIndex - $ nonWhiteAbove ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; return ; } if ( substr_count ( $ tokens [ $ nonWhiteAbove + 1 ] -> getContent ( ) , "\n" ) > 1 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; return ; } if ( $ tokens [ $ nonWhiteAbove - 1 ] -> isWhitespace ( ) && substr_count ( $ tokens [ $ nonWhiteAbove - 1 ] -> getContent ( ) , "\n" ) > 0 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbove = $ this -> findCommentBlockStart ( $ tokens , $ nonWhiteAbove ) ; $ nonWhiteAboveComment = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAboveComment , $ nonWhiteAbove , $ nonWhiteAboveComment === $ classStartIndex ? 1 : 2 ) ; } else { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; } return ; } if ( false === $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_DOC_COMMENT ) ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , $ nonWhiteAbove === $ classStartIndex ? 1 : 2 ) ; return ; } $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbovePHPDoc = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbovePHPDoc , $ nonWhiteAbove , $ nonWhiteAbovePHPDoc === $ classStartIndex ? 1 : 2 ) ; }
6893	protected function sortAssignments ( array $ assignments ) { usort ( $ assignments , function ( StockAssignmentInterface $ a1 , StockAssignmentInterface $ a2 ) { $ u1 = $ a1 -> getStockUnit ( ) ; $ u2 = $ a2 -> getStockUnit ( ) ; return $ this -> compareStockUnit ( $ u1 , $ u2 ) ; } ) ; return $ assignments ; }
6295	private function parseThemeInfo ( array $ info ) { $ themeInfo = new ThemeInfo ( ) ; $ required = [ 'name' , 'author' , 'directory' ] ; foreach ( $ required as $ key ) { if ( ! array_key_exists ( $ key , $ info ) ) { throw new ThemeInfoAttributeException ( $ key ) ; } } $ themeInfo -> setName ( $ info [ 'name' ] ) ; $ themeInfo -> setAuthor ( $ info [ 'author' ] ) ; $ themeInfo -> setDirectory ( strtolower ( $ info [ 'directory' ] ) ) ; if ( isset ( $ info [ 'description' ] ) ) { $ themeInfo -> setDescription ( $ info [ 'description' ] ) ; } if ( isset ( $ info [ 'version' ] ) ) { $ themeInfo -> setVersion ( $ info [ 'version' ] ) ; } if ( isset ( $ info [ 'parent' ] ) ) { $ themeInfo -> setParent ( $ info [ 'parent' ] ) ; } $ themeInfo -> setPath ( $ this -> findPath ( $ info [ 'directory' ] ) ) ; return $ themeInfo ; }
7392	public function serialize ( ) : string { $ toSerialize = [ '_arrayOptions' => $ this -> _arrayOptions , '_jsonOptions' => $ this -> _jsonOptions , ] ; foreach ( $ this -> _publicNames as $ k ) { $ toSerialize [ $ k ] = $ this -> { $ k } ; } return serialize ( $ toSerialize ) ; }
6793	protected function getTagSortSourceColumn ( $ prefix = null ) { $ column = $ this -> get ( 'tag_srcsorting' ) ; if ( ! $ column ) { return null ; } if ( null !== $ prefix ) { return $ prefix . '.' . $ column ; } return $ column ; }
85	public function getPackageFilename ( PackageInterface $ package ) { $ nameParts = array ( preg_replace ( '#[^a-z0-9-_]#i' , '-' , $ package -> getName ( ) ) ) ; if ( preg_match ( '{^[a-f0-9]{40}$}' , $ package -> getDistReference ( ) ) ) { array_push ( $ nameParts , $ package -> getDistReference ( ) , $ package -> getDistType ( ) ) ; } else { array_push ( $ nameParts , $ package -> getPrettyVersion ( ) , $ package -> getDistReference ( ) ) ; } if ( $ package -> getSourceReference ( ) ) { $ nameParts [ ] = substr ( sha1 ( $ package -> getSourceReference ( ) ) , 0 , 6 ) ; } $ name = implode ( '-' , array_filter ( $ nameParts , function ( $ p ) { return ! empty ( $ p ) ; } ) ) ; return str_replace ( '/' , '-' , $ name ) ; }
3151	protected function continueInteraction ( RunnerServiceContext $ context ) { $ continue = false ; $ session = $ context -> getTestSession ( ) ; if ( $ session -> isRunning ( ) === true && $ session -> isTimeout ( ) === false ) { $ event = new QtiContinueInteractionEvent ( $ context , $ this ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; $ continue = true ; } else { $ this -> finish ( $ context ) ; } return $ continue ; }
4835	public function merchant ( $ id = null ) { if ( $ id == null ) { $ id = $ this -> account_details [ 'merchant_id' ] ; } return GoCardless_Merchant :: find_with_client ( $ this , $ id ) ; }
10052	private function resolvePath ( $ path_alias , $ file_name ) { $ path = \ Yii :: getAlias ( $ path_alias , false ) ; $ path = $ path ? realpath ( $ path ) : $ path ; $ file_name = ! preg_match ( '/\.php$/i' , $ file_name ) ? $ file_name . '.php' : $ file_name ; if ( ! $ path || ! is_dir ( $ path ) || ! file_exists ( $ path . '/' . $ file_name ) ) { throw new Exception ( "Faker template \"{$path}/{$file_name}\" not found" ) ; } return $ path . '/' . $ file_name ; }
9465	public function getSummary ( ) { $ string = "---\n" ; foreach ( $ this -> getWords ( ) as $ k => $ v ) { $ string .= '[' . $ k . ']: Docs:' . $ v [ 'docs' ] . ' | Hits:' . $ v [ 'hits' ] . "\n" ; } return $ string ; }
4808	public function unschedule_specific_event ( $ timestamp = '' ) { if ( empty ( $ timestamp ) ) { $ timestamp = wp_next_scheduled ( $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } wp_unschedule_event ( $ timestamp , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; }
4881	public function getContent ( ) { if ( $ this -> file instanceof \ Doctrine \ MongoDB \ GridFSFile ) { return $ this -> file -> getMongoGridFSFile ( ) -> getBytes ( ) ; } return null ; }
6000	public function setImagetemplates ( array $ imagetemplates ) { $ this -> imagetemplates = [ ] ; foreach ( $ imagetemplates as $ item ) { $ this -> addImageTemplate ( $ item ) ; } return $ this ; }
2738	private function setToken ( $ token ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_API_KEY , $ token ) ; $ this -> output -> writeln ( '<info>Token updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
842	public function offsetSet ( $ index , $ newval ) { $ this -> blockEndCache = [ ] ; if ( ! $ this [ $ index ] || ! $ this [ $ index ] -> equals ( $ newval ) ) { $ this -> changed = true ; if ( isset ( $ this [ $ index ] ) ) { $ this -> unregisterFoundToken ( $ this [ $ index ] ) ; } $ this -> registerFoundToken ( $ newval ) ; } parent :: offsetSet ( $ index , $ newval ) ; }
1598	protected function validateAllFields ( ) : bool { $ duplicates = collect ( ( array ) $ this -> dataGet ( 'attributes' , [ ] ) ) -> intersectByKeys ( ( array ) $ this -> dataGet ( 'relationships' , [ ] ) ) -> keys ( ) ; $ this -> resourceFieldsExistInAttributesAndRelationships ( $ duplicates ) ; return $ duplicates -> isEmpty ( ) ; }
6518	public static function fromDateTime ( \ DateTimeInterface $ date ) { $ str = $ date -> format ( 'U' ) . str_pad ( $ date -> format ( 'u' ) , 6 , '0' ) ; $ m = new self ( ) ; $ m -> int = ( int ) $ str ; $ m -> sec = ( int ) substr ( $ str , 0 , 10 ) ; $ m -> usec = ( int ) substr ( $ str , - 6 ) ; return $ m ; }
9886	private function writeDefinedNameForAutofilter ( XMLWriter $ objWriter , Worksheet $ pSheet , $ pSheetId = 0 ) { $ autoFilterRange = $ pSheet -> getAutoFilter ( ) -> getRange ( ) ; if ( ! empty ( $ autoFilterRange ) ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , '_xlnm._FilterDatabase' ) ; $ objWriter -> writeAttribute ( 'localSheetId' , $ pSheetId ) ; $ objWriter -> writeAttribute ( 'hidden' , '1' ) ; $ range = Coordinate :: splitRange ( $ autoFilterRange ) ; $ range = $ range [ 0 ] ; if ( strpos ( $ range [ 0 ] , '!' ) !== false ) { list ( $ ws , $ range [ 0 ] ) = explode ( '!' , $ range [ 0 ] ) ; } $ range [ 0 ] = Coordinate :: absoluteCoordinate ( $ range [ 0 ] ) ; $ range [ 1 ] = Coordinate :: absoluteCoordinate ( $ range [ 1 ] ) ; $ range = implode ( ':' , $ range ) ; $ objWriter -> writeRawData ( '\'' . str_replace ( "'" , "''" , $ pSheet -> getTitle ( ) ) . '\'!' . $ range ) ; $ objWriter -> endElement ( ) ; } }
10671	public static function toArray ( $ obj ) { if ( $ obj instanceof \ DOMNode ) { $ obj = simplexml_import_dom ( $ obj ) ; } if ( ! ( $ obj instanceof \ SimpleXMLElement ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'The input is not instance of SimpleXMLElement, DOMDocument or DOMNode.' ) ) ; } $ result = [ ] ; $ namespaces = array_merge ( [ '' => '' ] , $ obj -> getNamespaces ( true ) ) ; self :: _toArray ( $ obj , $ result , '' , array_keys ( $ namespaces ) ) ; return $ result ; }
7131	protected function updateTotals ( SupplierOrderInterface $ order ) { $ changed = false ; $ tax = $ this -> calculator -> calculatePaymentTax ( $ order ) ; if ( $ tax != $ order -> getTaxTotal ( ) ) { $ order -> setTaxTotal ( $ tax ) ; $ changed = true ; } $ payment = $ this -> calculator -> calculatePaymentTotal ( $ order ) ; if ( $ payment != $ order -> getPaymentTotal ( ) ) { $ order -> setPaymentTotal ( $ payment ) ; $ changed = true ; } if ( null !== $ order -> getCarrier ( ) ) { $ forwarder = $ this -> calculator -> calculateForwarderTotal ( $ order ) ; if ( $ forwarder != $ order -> getForwarderTotal ( ) ) { $ order -> setForwarderTotal ( $ forwarder ) ; $ changed = true ; } } else { if ( 0 != $ order -> getForwarderFee ( ) ) { $ order -> setForwarderFee ( 0 ) ; $ changed = true ; } if ( 0 != $ order -> getCustomsTax ( ) ) { $ order -> setCustomsTax ( 0 ) ; $ changed = true ; } if ( 0 != $ order -> getCustomsVat ( ) ) { $ order -> setCustomsVat ( 0 ) ; $ changed = true ; } if ( 0 != $ order -> getForwarderTotal ( ) ) { $ order -> setForwarderTotal ( 0 ) ; $ changed = true ; } if ( null !== $ order -> getForwarderDate ( ) ) { $ order -> setForwarderDate ( null ) ; $ changed = true ; } if ( null !== $ order -> getForwarderDueDate ( ) ) { $ order -> setForwarderDueDate ( null ) ; $ changed = true ; } } return $ changed ; }
678	protected function detectSearchAttributeType ( Validator $ validator ) { if ( $ validator instanceof BooleanValidator ) { return self :: TYPE_BOOLEAN ; } if ( $ validator instanceof NumberValidator ) { return $ validator -> integerOnly ? self :: TYPE_INTEGER : self :: TYPE_FLOAT ; } if ( $ validator instanceof StringValidator ) { return self :: TYPE_STRING ; } if ( $ validator instanceof EachValidator ) { return self :: TYPE_ARRAY ; } if ( $ validator instanceof DateValidator ) { if ( $ validator -> type == DateValidator :: TYPE_DATETIME ) { return self :: TYPE_DATETIME ; } if ( $ validator -> type == DateValidator :: TYPE_TIME ) { return self :: TYPE_TIME ; } return self :: TYPE_DATE ; } }
10233	public function edit ( $ id ) { $ user = User :: findOrFail ( $ id ) ; $ roles = Role :: lists ( 'name' , 'id' ) ; return view ( 'intothesource.usersmanager.users.edit' , compact ( 'user' , 'roles' ) ) ; }
9657	public function mount ( $ prefix = null ) { if ( $ prefix ) { $ this -> router -> group ( [ 'prefix' => $ prefix ] , function ( ) { $ this -> registerRoutes ( ) ; } ) ; } else { $ this -> registerRoutes ( ) ; } }
12977	protected function getComponentDefaults ( $ mappingName , array $ mappingConfig ) { if ( strpos ( $ mappingName , '::' ) ) { list ( $ componentName , $ componentType ) = explode ( '::' , $ mappingName ) ; } else { $ componentName = $ mappingName ; $ componentType = $ this -> detectComponentType ( $ componentName ) ; if ( $ componentType === false and $ componentName === 'app' ) { $ componentType = 'app' ; } } if ( ( $ componentPath = $ this -> getComponentPath ( $ componentName , $ componentType ) ) === false ) { return false ; } $ configPath = $ mappingConfig [ 'dir' ] ; if ( $ configPath === false ) { $ configPath = $ this -> getConfigPath ( ) ; } if ( $ mappingConfig [ 'type' ] === false ) { $ mappingConfig [ 'type' ] = $ this -> detectMetadataDriver ( $ componentPath , $ configPath ) ; } if ( $ mappingConfig [ 'type' ] === false ) { return false ; } if ( $ mappingConfig [ 'dir' ] === false ) { if ( in_array ( $ mappingConfig [ 'type' ] , array ( 'annotation' , 'staticphp' ) ) ) { $ mappingConfig [ 'dir' ] = $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ; } else { $ mappingConfig [ 'dir' ] = $ configPath ; } } if ( is_array ( $ mappingConfig [ 'dir' ] ) ) { foreach ( $ mappingConfig [ 'dir' ] as & $ path ) { $ path = $ componentPath . $ path ; } } else { $ mappingConfig [ 'dir' ] = $ componentPath . $ mappingConfig [ 'dir' ] ; } if ( $ mappingConfig [ 'prefix' ] === false ) { $ mappingConfig [ 'prefix' ] = $ this -> detectComponentNamespace ( $ componentName , $ componentType ) ; } $ mappingConfig [ 'is_component' ] = false ; return $ mappingConfig ; }
12487	public static function enableLogging ( $ writePath ) { if ( is_file ( $ writePath ) ) { self :: $ enabled = true ; self :: $ logFilePath = $ writePath ; return true ; } throw new \ Exception ( 'Impossible d\'activer les logs dans le fichier ' . $ writePath . ' : celui ci n\'existe pas.' ) ; return false ; }
3044	public function encode ( $ data ) { if ( is_array ( $ data ) ) { $ encodedData = [ self :: STORAGE_KEY_FORMAT => $ this -> getFormat ( ) , self :: STORAGE_KEY_VERSION => $ this -> getVersion ( ) , ] ; foreach ( $ data as $ key => & $ value ) { if ( $ value instanceof TimeLine ) { $ encodedData [ $ key ] = $ this -> packTimeLine ( $ value ) ; } else { $ encodedData [ $ key ] = & $ value ; } } return json_encode ( $ encodedData ) ; } return json_encode ( $ data ) ; }
6269	private function nameFromAcademicDomain ( $ domain ) { $ path = $ this -> getPath ( $ domain ) ; if ( ! file_exists ( $ path ) ) { return null ; } return trim ( file_get_contents ( $ path ) ) ; }
6145	public function checkFragment ( $ fragment = null ) { if ( $ fragment === null ) { $ fragment = $ this -> fragment ; } if ( strlen ( $ fragment ) == 0 ) { return true ; } $ pattern = "/^" . $ this -> regex [ "uric" ] . "*$/" ; $ status = @ preg_match ( $ pattern , $ fragment ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI fragment validation failed" ) ; } return ( $ status == 1 ) ; }
8193	public function file ( $ name ) { $ usephp = c :: get ( 'twig.usephp' , true ) ; $ base = str_replace ( '\\' , '/' , $ this -> kirby -> roots ( ) -> templates ( ) . '/' . $ name ) ; $ twig = $ base . '.twig' ; $ php = $ base . '.php' ; if ( $ usephp and ! is_file ( $ twig ) and is_file ( $ php ) ) { return $ php ; } else { return $ twig ; } }
7732	public function denormalize ( $ data , $ class , $ format = null , array $ context = array ( ) ) { $ value = $ data ; if ( is_array ( $ data ) ) { if ( ! isset ( $ data [ '@value' ] ) || ! isset ( $ data [ '@type' ] ) ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a valid JSON-LD typed value: " . var_export ( $ data , true ) ) ; } if ( self :: XSD_DATETIME_IRI !== $ data [ '@type' ] ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a XSD dateTime value: " . var_export ( $ data , true ) ) ; } $ value = $ data [ '@value' ] ; } elseif ( ! is_string ( $ data ) ) { throw new RuntimeException ( "Cannot denormalize the data into a DateTime object: " . var_export ( $ data , true ) ) ; } try { $ date = new \ DateTime ( $ value ) ; return $ date ; } catch ( Exception $ e ) { throw new RuntimeException ( "Cannot denormalize the data as the value is invalid: " . var_export ( $ data , true ) , 0 , $ e ) ; } }
536	protected function cleanDocComment ( $ doc ) { $ lines = explode ( "\n" , $ doc ) ; $ n = \ count ( $ lines ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ lines [ $ i ] = rtrim ( $ lines [ $ i ] ) ; if ( trim ( $ lines [ $ i ] ) == '*' && trim ( $ lines [ $ i + 1 ] ) == '*' ) { unset ( $ lines [ $ i ] ) ; } } return implode ( "\n" , $ lines ) ; }
1455	protected function validateHasOne ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasOne ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasOneExpected ( $ key ) ) ; return false ; } $ identifier = $ relationship -> getData ( ) ; if ( ! $ identifier ) { return true ; } if ( ! $ this -> validateIdentifier ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateExists ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateAcceptable ( $ identifier , $ record , $ key , $ resource ) ) { return false ; } return true ; }
4162	public function searchMedia ( $ lat , $ lng , $ distance = 1000 , $ minTimestamp = NULL , $ maxTimestamp = NULL ) { return $ this -> _makeCall ( 'media/search' , array ( 'lat' => $ lat , 'lng' => $ lng , 'distance' => $ distance , 'min_timestamp' => $ minTimestamp , 'max_timestamp' => $ maxTimestamp ) ) ; }
7411	public function combine ( array $ keys ) : self { if ( count ( $ keys ) !== count ( $ this -> _container ) ) { throw new LengthException ( 'array counts do not match' ) ; } $ this -> _container = array_combine ( $ keys , $ this -> _container ) ; return $ this ; }
10410	public function createUrlsTempFile ( ) { $ hash = md5 ( microtime ( true ) ) ; $ links = array_merge ( $ this -> getUrls ( ) , $ this -> getUrlsByDocumentParameter ( ) ) ; $ urlsFile = "/tmp/urls_{$hash}.txt" ; $ urls = [ ] ; foreach ( $ links as $ url ) { $ separator = ( $ url [ 0 ] !== '/' ) ? '/' : '' ; $ urls [ ] = $ this -> baseUrl . $ separator . $ url ; } file_put_contents ( $ urlsFile , implode ( PHP_EOL , $ urls ) ) ; return $ urlsFile ; }
4622	protected function pickNode ( ) { $ nodes = $ this -> getNodes ( ) ; $ index = mt_rand ( 0 , count ( $ nodes ) - 1 ) ; return array_keys ( $ nodes ) [ $ index ] ; }
6413	public static function transform ( IteratorAggregate $ fromIterable , callable $ transformer ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ fromIterable , $ transformer ) { return Iterators :: transform ( Iterators :: from ( $ fromIterable -> getIterator ( ) ) , $ transformer ) ; } ) ; }
10798	public function dateToSqlFormat ( $ dateString ) { $ dateFormatter = new \ IntlDateFormatter ( \ Locale :: getDefault ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , \ date_default_timezone_get ( ) , \ IntlDateFormatter :: GREGORIAN , "dd MMM yyyy" ) ; $ time = $ dateFormatter -> parse ( $ dateString ) ; $ date = new \ DateTime ( ) ; $ date -> setTimestamp ( $ time ) ; return $ date -> format ( 'Y-m-d' ) ; }
736	protected function getInheritedPermissionsByUser ( $ userId ) { $ assignments = $ this -> getAssignments ( $ userId ) ; $ result = [ ] ; foreach ( array_keys ( $ assignments ) as $ roleName ) { $ this -> getChildrenRecursive ( $ roleName , $ result ) ; } if ( empty ( $ result ) ) { return [ ] ; } $ permissions = [ ] ; foreach ( array_keys ( $ result ) as $ itemName ) { if ( isset ( $ this -> items [ $ itemName ] ) && $ this -> items [ $ itemName ] instanceof Permission ) { $ permissions [ $ itemName ] = $ this -> items [ $ itemName ] ; } } return $ permissions ; }
7688	function OpenXML_Rels_ReplaceTarget ( $ RelsPath , $ OldTarget , $ NewTarget ) { $ idx = $ this -> FileGetIdx ( $ RelsPath ) ; if ( $ idx === false ) $ this -> RaiseError ( "Cannot edit target in '$RelsPath' because the file is not found." ) ; $ txt = $ this -> TbsStoreGet ( $ idx , 'Replace target in rels file' ) ; $ att = 'Target="' . $ OldTarget . '"' ; $ loc = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ txt , $ att , 0 ) ; if ( $ loc ) { if ( $ NewTarget === false ) { $ loc -> Delete ( ) ; } else { $ loc -> ReplaceAtt ( 'Target' , $ NewTarget ) ; } $ this -> TbsStorePut ( $ idx , $ txt ) ; return true ; } else { return false ; } }
12805	private static function getColumnName ( string $ name ) : ? string { $ class = self :: getStaticChildClass ( ) ; if ( self :: $ columnPropertiesCache === null || ! array_key_exists ( $ class , self :: $ columnPropertiesCache ) || self :: $ columnPropertiesCache [ $ class ] === null ) self :: buildColumnPropertiesCache ( ) ; if ( array_key_exists ( $ name , self :: $ columnPropertiesCache [ $ class ] ) ) return $ name ; foreach ( self :: $ columnPropertiesCache [ $ class ] as $ column => $ properties ) { if ( in_array ( $ name , $ properties ) ) return $ column ; } return null ; }
686	protected function sortModels ( $ models , $ sort ) { $ orders = $ sort -> getOrders ( ) ; if ( ! empty ( $ orders ) ) { ArrayHelper :: multisort ( $ models , array_keys ( $ orders ) , array_values ( $ orders ) ) ; } return $ models ; }
12800	public function getHeaders ( ) { if ( ! isset ( $ this -> _headers ) ) { $ this -> _headers = $ this -> readLine ( 1 ) ; if ( ! $ this -> _headers ) { $ this -> _headers = [ ] ; } } return $ this -> _headers ; }
890	public function getTypes ( ) { if ( null === $ this -> types ) { $ this -> types = [ ] ; $ content = $ this -> getTypesContent ( ) ; while ( '' !== $ content && false !== $ content ) { Preg :: match ( '{^' . self :: REGEX_TYPES . '$}x' , $ content , $ matches ) ; $ this -> types [ ] = $ matches [ 'type' ] ; $ content = substr ( $ content , \ strlen ( $ matches [ 'type' ] ) + 1 ) ; } } return $ this -> types ; }
8825	protected function valid_cc ( $ data ) { $ number = preg_replace ( '/\D/' , '' , $ data ) ; if ( function_exists ( 'mb_strlen' ) ) { $ number_length = mb_strlen ( $ number ) ; } else { $ number_length = strlen ( $ number ) ; } $ parity = $ number_length % 2 ; $ total = 0 ; for ( $ i = 0 ; $ i < $ number_length ; $ i ++ ) { $ digit = $ number [ $ i ] ; if ( $ i % 2 == $ parity ) { $ digit *= 2 ; if ( $ digit > 9 ) { $ digit -= 9 ; } } $ total += $ digit ; } return ( $ total % 10 == 0 ) ? true : false ; }
9828	public function getCreateAssociationName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s.create' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
1134	public function storeNewParent ( ) { if ( $ this -> isDirty ( $ this -> getParentColumnName ( ) ) && ( $ this -> exists || ! $ this -> isRoot ( ) ) ) static :: $ moveToNewParentId = $ this -> getParentId ( ) ; else static :: $ moveToNewParentId = FALSE ; }
5532	protected function createCodeForOverridenMethods ( $ methods ) { $ code = '' ; foreach ( $ methods as $ method ) { if ( $ this -> isConstructorOrDeconstructor ( $ method ) ) { continue ; } $ code .= ' ' . $ this -> reflection -> getSignature ( $ method ) . " {\n" ; $ code .= " return \$this->mock->invoke(\"$method\", func_get_args());\n" ; $ code .= " }\n" ; } return $ code ; }
4218	private function clearLog ( $ flags ) { $ return = null ; $ clearErrors = $ flags & Debug :: CLEAR_LOG_ERRORS ; if ( $ flags & Debug :: CLEAR_LOG ) { $ return = 'log (' . ( $ clearErrors ? 'incl errors' : 'sans errors' ) . ')' ; $ curDepth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] [ 'main' ] as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entriesKeep = $ this -> debug -> internal -> getCurrentGroups ( $ this -> data [ 'log' ] , $ curDepth ) ; $ this -> clearLogHelper ( $ this -> data [ 'log' ] , $ clearErrors , $ entriesKeep ) ; } elseif ( $ clearErrors ) { $ return = 'errors' ; } return $ return ; }
7742	public function supportsOperation ( $ operationName ) { foreach ( $ this -> operations as $ operation ) { if ( $ operation -> getName ( ) === $ operationName ) { return true ; } } return false ; }
2476	private function logWarning ( OutputInterface $ output , ProgressBar $ progress , $ message ) { $ progress -> clear ( ) ; $ this -> logger -> warning ( $ message ) ; $ progress -> display ( ) ; }
5427	public function getInterfaces ( ) { $ reflection = new ReflectionClass ( $ this -> interface ) ; if ( $ reflection -> isInterface ( ) ) { return array ( $ this -> interface ) ; } return $ this -> onlyParents ( $ reflection -> getInterfaces ( ) ) ; }
1254	private function isSimplePhpType ( \ stdClass $ meta ) { $ phpTypes = explode ( '|' , $ meta -> phpType ) ; foreach ( $ phpTypes as $ phpType ) { switch ( $ phpType ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'DateTime' : continue ; default : return false ; } } return true ; }
8740	public function i18nQuery ( ) { $ query = $ this -> getModel ( ) -> newQueryWithoutScopes ( ) -> getQuery ( ) ; $ query -> from ( $ this -> model -> getI18nTable ( ) ) ; return $ query ; }
2560	private function checkAndCreateMopDetailedData ( $ fopType ) { if ( is_null ( $ this -> paymentModule -> mopDetailedData ) ) { $ this -> paymentModule -> mopDetailedData = new MopDetailedData ( $ fopType ) ; } }
7550	function wrapInner ( $ node , $ start = 0 , $ end = - 1 , $ wrap_index = - 1 , $ node_index = null ) { if ( $ end < 0 ) { $ end += count ( $ this -> children ) ; } if ( $ node_index === null ) { $ node_index = $ end + 1 ; } if ( ! is_object ( $ node ) ) { $ node = $ this -> addChild ( $ node , $ node_index ) ; } elseif ( $ node -> parent !== $ this ) { $ node -> changeParent ( $ this -> parent , $ node_index ) ; } $ this -> moveChildren ( $ node , $ wrap_index , $ start , $ end ) ; return $ node ; }
10638	protected function processUploadedFiles ( FileBag $ filebag ) { $ adapter = new LocalAdapter ( $ this -> get ( 'kernel' ) -> getRootDir ( ) . '/../web/media' ) ; $ filesystem = new Filesystem ( $ adapter ) ; $ processed = array ( ) ; if ( $ filebag -> get ( 'files' ) ) { foreach ( $ filebag -> get ( 'files' ) as $ file ) { $ dest = $ this -> createUniquePath ( $ file ) ; if ( $ filesystem -> write ( $ dest [ 'path' ] , file_get_contents ( $ file -> getPathname ( ) ) ) ) { $ processed [ ] = $ dest [ 'path' ] ; } ; } } return $ processed ; }
12137	public function update ( QuestionRequest $ request , Question $ question ) { try { $ request = $ request -> all ( ) ; $ attributes [ 'title' ] = $ request [ 'title' ] ; $ attributes [ 'question' ] = $ request [ 'question' ] ; $ attributes [ 'category_id' ] = $ request [ 'category_id' ] ; $ question -> update ( $ attributes ) ; return redirect ( '/discussion/' . $ request [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/question/' . $ question -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
11767	protected function wipeServerList ( ) { $ this -> reset ( ) ; $ this -> master = null ; $ this -> slaves = array ( ) ; $ this -> pool = array ( ) ; }
9134	public function setLastPost ( $ lastPost ) { if ( $ lastPost == 0 ) { $ this -> _lastPost = "" ; } elseif ( $ lastPost !== "" and $ lastPost !== "NULL" and $ lastPost !== null ) { if ( $ lastPost instanceof DateTime ) { $ this -> _lastPost = $ lastPost ; } else { $ this -> _lastPost = new DateTime ( $ lastPost ) ; } } return $ this ; }
6778	protected function updateVatDisplayMode ( SaleInterface $ sale ) { if ( $ sale -> hasPayments ( ) ) { return false ; } $ mode = null ; if ( null !== $ group = $ sale -> getCustomerGroup ( ) ) { $ mode = $ group -> getVatDisplayMode ( ) ; } if ( null === $ mode ) { $ mode = $ this -> defaultVatDisplayMode ; } if ( $ mode !== $ sale -> getVatDisplayMode ( ) ) { $ sale -> setVatDisplayMode ( $ mode ) ; return true ; } return false ; }
8189	final protected function getContext ( $ context , $ item , $ ignoreStrictCheck = false ) { if ( ! array_key_exists ( $ item , $ context ) ) { if ( $ ignoreStrictCheck || ! $ this -> env -> isStrictVariables ( ) ) { return ; } throw new Twig_Error_Runtime ( sprintf ( 'Variable "%s" does not exist.' , $ item ) , - 1 , $ this -> getSourceContext ( ) ) ; } return $ context [ $ item ] ; }
6960	public static function dt ( AstroDate $ dt ) { $ epoch = new static ( $ dt -> toTT ( ) -> toJD ( ) ) ; $ epoch -> dt = $ dt -> copy ( ) ; return $ epoch ; }
4227	public function unregister ( ) { if ( ! $ this -> registered ) { return ; } $ errHandlerCur = \ set_error_handler ( array ( $ this , 'handleError' ) ) ; \ restore_error_handler ( ) ; if ( $ errHandlerCur == array ( $ this , 'handleError' ) ) { \ restore_error_handler ( ) ; } $ exHandlerCur = \ set_exception_handler ( array ( $ this , 'handleException' ) ) ; \ restore_exception_handler ( ) ; if ( $ exHandlerCur == array ( $ this , 'handleException' ) ) { \ restore_exception_handler ( ) ; } \ ini_set ( 'display_errors' , $ this -> prevDisplayErrors ) ; $ this -> prevErrorHandler = null ; $ this -> prevExceptionHandler = null ; $ this -> registered = false ; return ; }
7684	function XML_DeleteElements ( & $ Txt , $ TagLst , $ OnlyInner = false ) { $ nbr_del = 0 ; foreach ( $ TagLst as $ tag ) { $ t_open = '<' . $ tag ; $ t_close = '</' . $ tag ; $ p1 = 0 ; while ( ( $ p1 = $ this -> XML_FoundTagStart ( $ Txt , $ t_open , $ p1 ) ) !== false ) { $ pe1 = strpos ( $ Txt , '>' , $ p1 ) ; if ( $ pe1 === false ) return false ; $ p2 = false ; if ( substr ( $ Txt , $ pe1 - 1 , 1 ) == '/' ) { $ pe2 = $ pe1 ; } else { $ p2 = $ this -> XML_FoundTagStart ( $ Txt , $ t_close , $ pe1 ) ; if ( $ p2 === false ) return false ; $ pe2 = strpos ( $ Txt , '>' , $ p2 ) ; } if ( $ pe2 === false ) return false ; if ( $ OnlyInner ) { if ( $ p2 !== false ) $ Txt = substr_replace ( $ Txt , '' , $ pe1 + 1 , $ p2 - $ pe1 - 1 ) ; $ p1 = $ pe1 ; } else { $ Txt = substr_replace ( $ Txt , '' , $ p1 , $ pe2 - $ p1 + 1 ) ; } } } return $ nbr_del ; }
6664	public function instantiate ( $ profile , $ provider ) { $ this -> provider = $ provider ; switch ( $ provider ) { case 'facebook' : $ this -> info = $ this -> parseFb ( $ profile ) ; break ; case 'twitter' : $ this -> info = $ this -> parseTwt ( $ profile ) ; break ; } return $ this ; }
10813	public function callMethodInWrappedInst ( $ method , $ args ) { $ i = $ this -> getWrappedInst ( ) ; if ( method_exists ( $ i , $ method ) ) { return call_user_method_array ( $ method , $ i , $ args ) ; } throw new UnknownMethodException ( 'Calling unknown method: ' . get_class ( $ i ) . "::$method()" ) ; }
5702	public function isCustomActionAllowed ( $ action ) { $ actions = $ this -> owner -> config ( ) -> better_buttons_actions ; if ( $ actions ) { return in_array ( $ action , $ actions ) ; } return false ; }
5742	public function getParserForContentType ( $ contentType ) { if ( 0 !== stripos ( $ contentType , 'multipart/' ) ) { return null ; } list ( $ mime , $ boundary ) = $ this -> parseContentType ( $ contentType ) ; $ parser = new MultipartParser ( ) ; $ parser -> setBoundary ( $ boundary ) ; return $ parser ; }
12204	public function makeEmojiAccessible ( $ text ) { return preg_replace_callback ( $ this -> search , function ( $ matches ) { $ desc = $ this -> emoji [ $ this -> utf8ToUnicode ( $ matches [ 0 ] ) ] ; return sprintf ( $ this -> output , $ desc , $ matches [ 0 ] ) ; } , $ text ) ; }
9865	private function writeHyperlinks ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ hyperlinkCollection = $ pSheet -> getHyperlinkCollection ( ) ; $ relationId = 1 ; if ( ! empty ( $ hyperlinkCollection ) ) { $ objWriter -> startElement ( 'hyperlinks' ) ; foreach ( $ hyperlinkCollection as $ coordinate => $ hyperlink ) { $ objWriter -> startElement ( 'hyperlink' ) ; $ objWriter -> writeAttribute ( 'ref' , $ coordinate ) ; if ( ! $ hyperlink -> isInternal ( ) ) { $ objWriter -> writeAttribute ( 'r:id' , 'rId_hyperlink_' . $ relationId ) ; ++ $ relationId ; } else { $ objWriter -> writeAttribute ( 'location' , str_replace ( 'sheet://' , '' , $ hyperlink -> getUrl ( ) ) ) ; } if ( $ hyperlink -> getTooltip ( ) != '' ) { $ objWriter -> writeAttribute ( 'tooltip' , $ hyperlink -> getTooltip ( ) ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
6127	public function setExpireDate ( $ expireDate ) { if ( $ expireDate instanceof DateTime ) { $ this -> expireDate = $ expireDate ; } else { try { $ this -> expireDate = new DateTime ( $ expireDate ) ; } catch ( \ Exception $ e ) { $ this -> expireDate = null ; } } return $ this ; }
3934	private function setExcluded ( PropertyInterface $ property , $ propInfo ) { if ( ! isset ( $ propInfo [ 'exclude' ] ) ) { return ; } $ property -> setExcluded ( ( bool ) $ propInfo [ 'exclude' ] ) ; }
2633	public function execute ( ) { $ output = $ this -> layoutFactory -> create ( ) -> createBlock ( 'Fastly\Cdn\Block\Dashboard\Tab\Stats\Historic' ) -> toHtml ( ) ; $ resultRaw = $ this -> resultRawFactory -> create ( ) ; return $ resultRaw -> setContents ( $ output ) ; }
4796	protected function execute ( ) { if ( ! isset ( $ this -> rows ) ) { $ result = false ; $ exception = null ; $ parameters = array ( ) ; foreach ( array_merge ( $ this -> select , array ( $ this , $ this -> group , $ this -> having ) , $ this -> order , $ this -> unionOrder ) as $ val ) { if ( ( $ val instanceof NotORM_Literal || $ val instanceof self ) && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } try { $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } catch ( PDOException $ exception ) { } if ( ! $ result ) { if ( ! $ this -> select && $ this -> accessed ) { $ this -> accessed = '' ; $ this -> access = array ( ) ; $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } elseif ( $ exception ) { throw $ exception ; } } $ this -> rows = array ( ) ; if ( $ result ) { $ result -> setFetchMode ( PDO :: FETCH_ASSOC ) ; foreach ( $ result as $ key => $ row ) { if ( isset ( $ row [ $ this -> primary ] ) ) { $ key = $ row [ $ this -> primary ] ; if ( ! is_string ( $ this -> access ) ) { $ this -> access [ $ this -> primary ] = true ; } } if ( $ this -> notORM -> isKeepPrimaryKeyIndex ) { $ this -> rows [ $ key ] = $ row ; } else { $ this -> rows [ ] = $ row ; } } } $ this -> data = $ this -> rows ; } }
5565	public function head ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } $ response = $ this -> user_agent -> fetchResponse ( $ url , new SimpleHeadEncoding ( $ parameters ) ) ; $ this -> page = new SimplePage ( $ response ) ; return ! $ response -> isError ( ) ; }
9604	public function scalarTripleProduct ( self $ b , self $ c ) { return $ this -> dotProduct ( $ b -> crossProduct ( $ c ) ) ; }
8718	public static function forceCreateInLocale ( $ locale , array $ attributes , $ translations = [ ] ) { $ model = new static ; return static :: unguarded ( function ( ) use ( $ locale , $ model , $ attributes , $ translations ) { return $ model -> createInLocale ( $ locale , $ attributes , $ translations ) ; } ) ; }
5134	private static function createUri ( string $ scheme , string $ host , ? int $ port , string $ user , string $ password , string $ path , string $ query , string $ fragment ) : \ One \ Uri { return new Uri ( $ scheme , $ host , $ port , $ path , $ query , $ fragment , $ user , $ password ) ; }
1600	public function serialize ( $ record , $ meta = null , array $ links = [ ] ) { $ serializer = clone $ this -> serializer ; $ serializer -> withMeta ( $ meta ) -> withLinks ( $ links ) ; $ serialized = $ serializer -> serializeData ( $ record , $ this -> createEncodingParameters ( ) ) ; $ resourceLinks = null ; if ( empty ( $ serialized [ 'data' ] [ 'id' ] ) ) { unset ( $ serialized [ 'data' ] [ 'id' ] ) ; $ resourceLinks = false ; } $ resource = $ this -> parsePrimaryResource ( $ serialized [ 'data' ] , $ resourceLinks ) ; $ document = [ 'data' => $ resource ] ; if ( isset ( $ serialized [ 'included' ] ) && $ this -> doesSerializeCompoundDocuments ( ) ) { $ document [ 'included' ] = $ this -> parseIncludedResources ( $ serialized [ 'included' ] ) ; } return $ document ; }
5766	private function clear ( ) { if ( ! isset ( $ this -> phpMailer ) ) { return ; } $ this -> phpMailer -> clearAddresses ( ) ; $ this -> phpMailer -> clearCCs ( ) ; $ this -> phpMailer -> clearBCCs ( ) ; $ this -> phpMailer -> clearReplyTos ( ) ; $ this -> phpMailer -> clearAllRecipients ( ) ; $ this -> phpMailer -> clearAttachments ( ) ; $ this -> phpMailer -> clearCustomHeaders ( ) ; }
1725	private static function canGenerateSecret ( array $ config ) : bool { if ( isset ( $ config [ 'file' ] ) ) { return ! is_file ( $ config [ 'file' ] ) ; } foreach ( $ config as $ v ) { if ( \ is_array ( $ v ) && isset ( $ v [ 'file' ] ) && is_file ( $ v [ 'file' ] ) ) { return false ; } } return ! empty ( $ config ) ; }
9386	public function retrieve ( $ httpMethod , $ uri ) { $ route = array ( $ httpMethod , $ uri ) ; $ routes = array_map ( function ( $ route ) { return array ( $ route [ 0 ] , $ route [ 1 ] ) ; } , $ this -> routes ) ; $ key = array_search ( $ route , $ routes ) ; return $ key !== false ? $ this -> routes [ $ key ] : null ; }
12576	public function previewTextByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_TEXT , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
9467	protected function initializer ( string $ key , array $ storage ) : void { $ this -> _name = $ key ; $ this -> attached ( $ storage ) ; }
12358	private function registerCalc ( $ period ) { $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCalcReg :: IN_CALC_TYPE_CODE , Cfg :: CODE_TYPE_CALC_FORECAST_PHASE1 ) ; $ ctx -> set ( PCalcReg :: IN_PERIOD , $ period ) ; $ res = $ this -> zCalcReg -> exec ( $ ctx ) ; $ result = $ res -> get ( PCalcReg :: OUT_CALC_ID ) ; return $ result ; }
9743	public function setCountry ( $ country ) { if ( ! ( $ country instanceof Country ) ) { $ country = new Country ( $ country ) ; } if ( $ country -> isEmpty ( ) ) { $ this -> invalidArguments ( '10001' ) ; } return $ this -> setParameter ( 'country' , $ country ) ; }
4165	private function mergeScope ( array $ scope ) { if ( empty ( $ scope ) ) return $ this -> _scope ; $ scope = array_merge ( $ scope , $ this -> _defaulScope ) ; $ scope = array_unique ( $ scope ) ; $ intersectingScope = array_intersect ( $ scope , $ this -> _availableScope ) ; if ( count ( $ intersectingScope ) !== count ( $ scope ) ) { throw new InvalidParameterException ( 'Error: mergeScope() - Invalid permission scope parameter used.' ) ; } return $ intersectingScope ; }
2056	public function setRootType ( Contao \ DataContainer $ dc ) { if ( Contao \ Input :: get ( 'act' ) != 'create' ) { return ; } if ( Contao \ Input :: get ( 'pid' ) == 0 ) { $ GLOBALS [ 'TL_DCA' ] [ 'tl_page' ] [ 'fields' ] [ 'type' ] [ 'default' ] = 'root' ; } elseif ( Contao \ Input :: get ( 'mode' ) == 1 ) { $ objPage = $ this -> Database -> prepare ( "SELECT * FROM " . $ dc -> table . " WHERE id=?" ) -> limit ( 1 ) -> execute ( Contao \ Input :: get ( 'pid' ) ) ; if ( $ objPage -> pid == 0 ) { $ GLOBALS [ 'TL_DCA' ] [ 'tl_page' ] [ 'fields' ] [ 'type' ] [ 'default' ] = 'root' ; } } }
8543	public function setShipmentEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3	private function buildDependency20Info ( $ depArray ) { $ result = array ( ) ; $ optionals = array ( ) ; $ defaultOptionals = array ( ) ; foreach ( $ depArray as $ depType => $ depTypeGroup ) { if ( ! is_array ( $ depTypeGroup ) ) { continue ; } if ( 'required' == $ depType || 'optional' == $ depType ) { foreach ( $ depTypeGroup as $ depItemType => $ depItem ) { switch ( $ depItemType ) { case 'php' : $ result [ ] = new DependencyConstraint ( $ depType , $ this -> parse20VersionConstraint ( $ depItem ) , 'php' , '' ) ; break ; case 'package' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'extension' : $ deps = $ this -> buildDepExtensionConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'subpackage' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , 'replaces' ) ; $ defaultOptionals += $ deps ; break ; case 'os' : case 'pearinstaller' : break ; default : break ; } } } elseif ( 'group' == $ depType ) { if ( $ this -> isHash ( $ depTypeGroup ) ) { $ depTypeGroup = array ( $ depTypeGroup ) ; } foreach ( $ depTypeGroup as $ depItem ) { $ groupName = $ depItem [ 'attribs' ] [ 'name' ] ; if ( ! isset ( $ optionals [ $ groupName ] ) ) { $ optionals [ $ groupName ] = array ( ) ; } if ( isset ( $ depItem [ 'subpackage' ] ) ) { $ optionals [ $ groupName ] += $ this -> buildDepPackageConstraints ( $ depItem [ 'subpackage' ] , 'replaces' ) ; } else { $ result += $ this -> buildDepPackageConstraints ( $ depItem [ 'package' ] , 'optional' ) ; } } } } if ( count ( $ defaultOptionals ) > 0 ) { $ optionals [ '*' ] = $ defaultOptionals ; } return new DependencyInfo ( $ result , $ optionals ) ; }
1442	protected function replaceRecord ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'DummyRecord' , Str :: classify ( str_singular ( $ resource ) ) , $ stub ) ; return $ this ; }
11237	public function saveUrl ( $ url = false , $ append = '' ) { if ( $ url == false ) { $ url = '//' . $ this -> config [ 'base_url' ] . $ _SERVER [ 'REQUEST_URI' ] ; } $ this -> saved = $ this -> getRedirect ( $ url ) . $ append ; $ this -> session -> savedUrl = $ this -> saved ; }
9735	public static function indexedColor ( $ pIndex , $ background = false ) { $ pIndex = ( int ) $ pIndex ; if ( self :: $ indexedColors === null ) { self :: $ indexedColors = [ 1 => 'FF000000' , 2 => 'FFFFFFFF' , 3 => 'FFFF0000' , 4 => 'FF00FF00' , 5 => 'FF0000FF' , 6 => 'FFFFFF00' , 7 => 'FFFF00FF' , 8 => 'FF00FFFF' , 9 => 'FF800000' , 10 => 'FF008000' , 11 => 'FF000080' , 12 => 'FF808000' , 13 => 'FF800080' , 14 => 'FF008080' , 15 => 'FFC0C0C0' , 16 => 'FF808080' , 17 => 'FF9999FF' , 18 => 'FF993366' , 19 => 'FFFFFFCC' , 20 => 'FFCCFFFF' , 21 => 'FF660066' , 22 => 'FFFF8080' , 23 => 'FF0066CC' , 24 => 'FFCCCCFF' , 25 => 'FF000080' , 26 => 'FFFF00FF' , 27 => 'FFFFFF00' , 28 => 'FF00FFFF' , 29 => 'FF800080' , 30 => 'FF800000' , 31 => 'FF008080' , 32 => 'FF0000FF' , 33 => 'FF00CCFF' , 34 => 'FFCCFFFF' , 35 => 'FFCCFFCC' , 36 => 'FFFFFF99' , 37 => 'FF99CCFF' , 38 => 'FFFF99CC' , 39 => 'FFCC99FF' , 40 => 'FFFFCC99' , 41 => 'FF3366FF' , 42 => 'FF33CCCC' , 43 => 'FF99CC00' , 44 => 'FFFFCC00' , 45 => 'FFFF9900' , 46 => 'FFFF6600' , 47 => 'FF666699' , 48 => 'FF969696' , 49 => 'FF003366' , 50 => 'FF339966' , 51 => 'FF003300' , 52 => 'FF333300' , 53 => 'FF993300' , 54 => 'FF993366' , 55 => 'FF333399' , 56 => 'FF333333' , ] ; } if ( isset ( self :: $ indexedColors [ $ pIndex ] ) ) { return new self ( self :: $ indexedColors [ $ pIndex ] ) ; } if ( $ background ) { return new self ( self :: COLOR_WHITE ) ; } return new self ( self :: COLOR_BLACK ) ; }
1788	public function editArticle ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLES , $ objPage -> row ( ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
7607	public function renderToggle ( array $ aDropdownOptions ) { if ( empty ( $ aDropdownOptions [ 'label' ] ) ) { $ aDropdownOptions [ 'label' ] = '' ; } elseif ( ! is_scalar ( $ aDropdownOptions [ 'label' ] ) ) { throw new InvalidArgumentException ( '"label" option expects a scalar value, "' . gettype ( $ aDropdownOptions [ 'label' ] ) . '" given' ) ; } elseif ( ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ aDropdownOptions [ 'label' ] = $ oTranslator -> translate ( $ aDropdownOptions [ 'label' ] , $ this -> getTranslatorTextDomain ( ) ) ; } if ( empty ( $ aDropdownOptions [ 'toggle_attributes' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] = array ( 'class' => 'sr-only dropdown-toggle' ) ; } else { if ( ! is_array ( $ aDropdownOptions [ 'toggle_attributes' ] ) ) { throw new InvalidArgumentException ( '"toggle_attributes" option expects an array, "' . gettype ( $ aDropdownOptions [ 'toggle_attributes' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'toggle_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'class' ] = 'sr-only dropdown-toggle' ; } else { if ( ! preg_match ( '/(\s|^)sr-only(\s|$)/' , $ aDropdownOptions [ 'toggle_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'class' ] .= ' sr-only' ; } if ( ! preg_match ( '/(\s|^)dropdown-toggle(\s|$)/' , $ aDropdownOptions [ 'toggle_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'class' ] .= ' dropdown-toggle' ; } } } if ( empty ( $ aDropdownOptions [ 'toggle_attributes' ] [ 'data-toggle' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'data-toggle' ] = 'dropdown' ; } if ( empty ( $ aDropdownOptions [ 'toggle_attributes' ] [ 'role' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'role' ] = 'button' ; } if ( empty ( $ aDropdownOptions [ 'toggle_attributes' ] [ 'href' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'href' ] = '#' ; } if ( ! empty ( $ aDropdownOptions [ 'name' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'id' ] = $ aDropdownOptions [ 'name' ] ; } $ aValidTagAttributes = $ this -> validTagAttributes ; $ this -> validTagAttributes = array ( 'href' => true ) ; $ sAttributeString = $ this -> createAttributesString ( $ aDropdownOptions [ 'toggle_attributes' ] ) ; $ this -> validTagAttributes = $ aValidTagAttributes ; return sprintf ( static :: $ dropdownToggleFormat , $ sAttributeString , $ this -> getEscapeHtmlHelper ( ) -> __invoke ( $ aDropdownOptions [ 'label' ] ) ) ; }
10868	public function getById ( int $ id ) { return $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.' . self :: COLUMN_ID => $ id ] ) -> fetch ( ) ; }
3211	static function checkArg ( $ argName , $ argValue ) { if ( ! ( $ argValue instanceof self ) ) Checker :: throwError ( $ argName , $ argValue , __CLASS__ ) ; }
8671	public static function combine ( $ keys , $ values ) { $ keys = Arr :: from ( $ keys ) ; $ values = Arr :: from ( $ values ) ; if ( count ( $ keys ) !== count ( $ values ) ) { throw new InvalidArgumentException ( 'The size of keys and values needs to be the same.' ) ; } if ( count ( $ keys ) === 0 ) { return new static ( ) ; } return new static ( array_combine ( $ keys , $ values ) ) ; }
6310	private function getCommand ( DatabaseObjectInterface $ databaseObject , $ isCreate = true ) { if ( $ databaseObject instanceof Column ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.add_column' : 'rentgen.drop_column' ) -> setColumn ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof ConstraintInterface ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.add_constraint' : 'rentgen.drop_constraint' ) -> setConstraint ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Index ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_index' : 'rentgen.drop_index' ) -> setIndex ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Schema ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_schema' : 'rentgen.drop_schema' ) -> setSchema ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Table ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_table' : 'rentgen.drop_table' ) -> setTable ( $ databaseObject ) ; } else { throw new \ Exception ( sprintf ( "Class %s is not supported" , get_class ( $ databaseObject ) ) ) ; } return $ command ; }
10484	public static function createSpamComplaint ( $ recipientEmailAddress , $ listExternalId , $ recipientExternalId = null , $ ipAddress = '127.0.0.1' ) { if ( $ recipientExternalId == null ) { $ recipientExternalId = rand ( 1 , 99999 ) ; } return ( new Payload ( ) ) -> setIpAddress ( $ ipAddress ) -> setAction ( Type :: SPAM_COMPLAINT ) -> setCampaignId ( rand ( 1 , 99999 ) ) -> setListExternalId ( $ listExternalId ) -> setReason ( Type :: REASON_USER_REQUEST ) -> setRecipientEmailAddress ( $ recipientEmailAddress ) -> setHash ( md5 ( $ recipientEmailAddress ) ) -> setRecipientExternalId ( $ recipientExternalId ) -> setTriggerDate ( new \ DateTime ( ) ) -> setType ( Type :: SPAM_COMPLAINT ) ; }
8359	public function dashboards ( Environment $ environment , $ size ) { $ dashboards = null ; if ( $ this -> tokenStorage -> getToken ( ) -> getUser ( ) !== null ) { $ dashboardsAvailable = array ( 'ContactForm' , 'Email' , 'Events' , 'ExceptionChecker' , 'GiftVoucher' , 'PageEdit' , 'Payment' , 'PurchaseCredits' , 'Site' , 'User' ) ; foreach ( $ dashboardsAvailable as $ dashboardAvailable ) { if ( is_dir ( $ this -> container -> getParameter ( 'kernel.root_dir' ) . '/../vendor/c975l/' . strtolower ( $ dashboardAvailable ) . '-bundle' ) && $ this -> configService -> hasParameter ( 'c975L' . $ dashboardAvailable . '.roleNeeded' ) && $ this -> container -> get ( 'security.authorization_checker' ) -> isGranted ( $ this -> configService -> getParameter ( 'c975L' . $ dashboardAvailable . '.roleNeeded' ) ) ) { $ dashboards [ ] = strtolower ( $ dashboardAvailable ) ; } } } return $ environment -> render ( '@c975LToolbar/dashboards.html.twig' , array ( 'dashboards' => $ dashboards , 'size' => $ size , ) ) ; }
92	protected static function validateSyntax ( $ json , $ file = null ) { $ parser = new JsonParser ( ) ; $ result = $ parser -> lint ( $ json ) ; if ( null === $ result ) { if ( defined ( 'JSON_ERROR_UTF8' ) && JSON_ERROR_UTF8 === json_last_error ( ) ) { throw new \ UnexpectedValueException ( '"' . $ file . '" is not UTF-8, could not parse as JSON' ) ; } return true ; } throw new ParsingException ( '"' . $ file . '" does not contain valid JSON' . "\n" . $ result -> getMessage ( ) , $ result -> getDetails ( ) ) ; }
5593	protected function fetch ( $ url , $ encoding ) { $ request = $ this -> createRequest ( $ url , $ encoding ) ; return $ request -> fetch ( $ this -> connection_timeout ) ; }
12302	public function getChild ( $ id , $ relation , $ idChild , $ filters = null ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } if ( count ( $ filters -> request -> all ( ) ) > 0 ) { $ child = $ parent -> $ relation ( ) -> getRelated ( ) ; $ search = new Search ( $ child , $ filters , $ parent -> $ relation ( ) ) ; $ this -> builder = $ search -> getBuilder ( ) ; $ this -> builder -> select ( "{$child->getTable()}.*" ) ; if ( $ parent -> $ relation ( ) instanceof \ Illuminate \ Database \ Eloquent \ Relations \ BelongsToMany ) { $ this -> builder -> where ( $ parent -> $ relation ( ) -> getOtherKey ( ) , $ idChild ) ; } $ resource = $ this -> builder -> get ( ) ; } else { $ resource = $ parent -> $ relation ( ) -> find ( $ idChild ) ; } return $ resource ; }
434	private function isIncorrectClassNameOrPrefix ( $ className , $ prefix ) { if ( ! preg_match ( '%^[a-z][a-z0-9\\-_]*$%' , $ className ) ) { return true ; } if ( $ prefix !== '' && ! preg_match ( '%^[a-z0-9_/]+$%i' , $ prefix ) ) { return true ; } return false ; }
7894	private function parseData ( $ data ) { foreach ( $ data as $ property_name => $ property ) { $ types_to_try = [ ] ; if ( isset ( static :: $ properties [ $ property_name ] ) ) { $ types_to_try = array_merge ( $ types_to_try , static :: $ properties [ $ property_name ] ) ; } foreach ( static :: $ pattern_properties as $ pattern_property ) { $ types_to_try = array_merge ( $ types_to_try , $ pattern_property ) ; } if ( is_array ( static :: $ additional_properties ) ) { $ types_to_try = array_merge ( $ types_to_try , static :: $ additional_properties ) ; } if ( is_array ( $ property ) ) { foreach ( $ property as $ property_element ) { $ this -> add ( $ property_name , self :: tryToCast ( $ types_to_try , $ property_element ) ) ; } } else { $ this -> set ( $ property_name , self :: tryToCast ( $ types_to_try , $ property ) ) ; } } }
6994	public function prePersist ( UploadableInterface $ uploadable ) { if ( ! $ this -> enabled ) { return ; } $ uploadable -> setCreatedAt ( new \ DateTime ( ) ) -> setUpdatedAt ( new \ DateTime ( ) ) ; $ this -> uploader -> prepare ( $ uploadable ) ; }
5739	public function render ( MvcEvent $ e ) { $ result = $ e -> getResult ( ) ; if ( $ result instanceof Response ) { return $ result ; } $ response = $ e -> getResponse ( ) ; $ viewModel = $ e -> getViewModel ( ) ; if ( ! $ viewModel instanceof ViewModel ) { return null ; } try { $ result = $ this -> getEnvironment ( ) -> render ( $ viewModel -> getTemplate ( ) . $ this -> getSuffix ( ) , ( array ) $ viewModel -> getVariables ( ) ) ; } catch ( Twig_Error_Loader $ e ) { return null ; } $ response -> setContent ( $ result ) ; $ e -> setResult ( $ response ) ; return $ response ; }
9326	protected function registerEngines ( ) { $ app = $ this -> app ; $ config = $ app [ 'config' ] ; $ resolver = $ app [ 'view.engine.resolver' ] ; if ( $ config [ 'markdown.tags' ] ) { $ this -> registerBladeEngine ( $ resolver ) ; } if ( $ config [ 'markdown.views' ] ) { $ this -> registerMarkdownEngine ( $ resolver ) ; $ this -> registerMarkdownPhpEngine ( $ resolver ) ; $ this -> registerMarkdownBladeEngine ( $ resolver ) ; } }
3322	public function anyOfOptions ( OptionCollection $ options ) { $ name = $ this -> getOptionName ( ) ; $ keys = $ options -> keys ( ) ; return in_array ( $ name , $ keys ) ; }
3459	public function add ( Route $ route ) : void { if ( $ route instanceof Route ) { $ name = $ route -> getName ( ) ; } else { $ name = Route :: generateNameFromPath ( $ route -> getPath ( ) ) ; } $ baseRoute = new SymfonyRoute ( $ route -> getPath ( ) ) ; $ baseRoute -> setMethods ( $ route -> getMethods ( ) ) ; $ this -> routeCollection -> add ( $ name , $ baseRoute ) ; $ this -> routes [ $ name ] = $ route ; }
2370	public static function highlight ( $ strString , $ strPhrase , $ strOpeningTag = '<strong>' , $ strClosingTag = '</strong>' ) { if ( $ strString == '' || $ strPhrase == '' ) { return $ strString ; } return preg_replace ( '/(' . preg_quote ( $ strPhrase , '/' ) . ')/i' , $ strOpeningTag . '\\1' . $ strClosingTag , $ strString ) ; }
5185	private function generalAttachment ( Article $ article , array $ attachmentConst , array $ attachmentype , array $ attributes , array $ dataArticle ) : Article { $ numOfAttachments = count ( $ attachmentConst ) ; for ( $ i = 0 ; $ i < $ numOfAttachments ; $ i ++ ) { $ attachments = $ this -> attachment ( $ attachmentype [ $ i ] , $ attributes [ $ i ] , $ dataArticle ) ; for ( $ j = 0 ; $ j < $ attachments [ 'numberOfItems' ] ; $ j ++ ) { $ attachment = $ attachments [ 'attachments' ] [ $ j ] ; $ article -> attach ( $ attachmentConst [ $ i ] , $ attachment ) ; } } return $ article ; }
503	public function batchInsert ( $ table , $ columns , $ rows , & $ params = [ ] ) { if ( empty ( $ rows ) ) { return '' ; } $ this -> db -> open ( ) ; if ( version_compare ( $ this -> db -> getServerVersion ( ) , '3.7.11' , '>=' ) ) { return parent :: batchInsert ( $ table , $ columns , $ rows , $ params ) ; } $ schema = $ this -> db -> getSchema ( ) ; if ( ( $ tableSchema = $ schema -> getTableSchema ( $ table ) ) !== null ) { $ columnSchemas = $ tableSchema -> columns ; } else { $ columnSchemas = [ ] ; } $ values = [ ] ; foreach ( $ rows as $ row ) { $ vs = [ ] ; foreach ( $ row as $ i => $ value ) { if ( isset ( $ columnSchemas [ $ columns [ $ i ] ] ) ) { $ value = $ columnSchemas [ $ columns [ $ i ] ] -> dbTypecast ( $ value ) ; } if ( is_string ( $ value ) ) { $ value = $ schema -> quoteValue ( $ value ) ; } elseif ( is_float ( $ value ) ) { $ value = StringHelper :: floatToString ( $ value ) ; } elseif ( $ value === false ) { $ value = 0 ; } elseif ( $ value === null ) { $ value = 'NULL' ; } elseif ( $ value instanceof ExpressionInterface ) { $ value = $ this -> buildExpression ( $ value , $ params ) ; } $ vs [ ] = $ value ; } $ values [ ] = implode ( ', ' , $ vs ) ; } if ( empty ( $ values ) ) { return '' ; } foreach ( $ columns as $ i => $ name ) { $ columns [ $ i ] = $ schema -> quoteColumnName ( $ name ) ; } return 'INSERT INTO ' . $ schema -> quoteTableName ( $ table ) . ' (' . implode ( ', ' , $ columns ) . ') SELECT ' . implode ( ' UNION SELECT ' , $ values ) ; }
8217	public static function getRefererQueryParam ( $ url , $ key ) { if ( ! $ url ) { return null ; } $ query = [ ] ; parse_str ( parse_url ( $ url , PHP_URL_QUERY ) , $ query ) ; if ( isset ( $ query [ $ key ] ) ) { return $ query [ $ key ] ; } return null ; }
5014	public function logBootstrap ( BootstrapEvent $ event ) : void { $ this -> getLogger ( ) -> info ( sprintf ( $ this -> tmpl [ 'queue' ] , 'Start' , $ event -> getQueue ( ) -> getName ( ) ) ) ; $ this -> injectLoggerInObject ( $ event -> getWorker ( ) ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
7820	public function store ( $ pipeline , array $ pipes ) { $ workflow = [ $ pipeline => $ pipes ] ; $ yaml = $ this -> parser -> dump ( $ workflow ) ; $ this -> files -> append ( $ this -> getSource ( ) , $ yaml ) ; }
2250	protected static function replaceOldBePaths ( $ strContext ) { $ router = System :: getContainer ( ) -> get ( 'router' ) ; $ generate = function ( $ route ) use ( $ router ) { return substr ( $ router -> generate ( $ route ) , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; } ; $ arrMapper = array ( 'contao/confirm.php' => $ generate ( 'contao_backend_confirm' ) , 'contao/file.php' => $ generate ( 'contao_backend_file' ) , 'contao/help.php' => $ generate ( 'contao_backend_help' ) , 'contao/index.php' => $ generate ( 'contao_backend_login' ) , 'contao/main.php' => $ generate ( 'contao_backend' ) , 'contao/page.php' => $ generate ( 'contao_backend_page' ) , 'contao/password.php' => $ generate ( 'contao_backend_password' ) , 'contao/popup.php' => $ generate ( 'contao_backend_popup' ) , 'contao/preview.php' => $ generate ( 'contao_backend_preview' ) , 'contao/switch.php' => $ generate ( 'contao_backend_switch' ) ) ; return str_replace ( array_keys ( $ arrMapper ) , $ arrMapper , $ strContext ) ; }
6904	public function runWild ( ) { foreach ( $ this -> handlers as $ handler ) { $ rtn = $ handler instanceof Closure ? $ this -> context -> call ( $ handler , $ this -> req ) : $ this -> context -> callInClass ( $ handler , $ this -> action , $ this -> req ) ; if ( ! is_null ( $ rtn ) ) return $ rtn ; } return null ; }
5476	protected function encode ( ) { $ class = $ this -> encoding ; $ encoding = new $ class ( ) ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { $ this -> widgets [ $ i ] -> write ( $ encoding ) ; } return $ encoding ; }
2331	public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ return = array ( ) ; while ( $ this -> next ( ) ) { $ strPk = $ this -> current ( ) -> getPk ( ) ; if ( $ strKey != 'id' && isset ( $ this -> $ strPk ) ) { $ return [ $ this -> $ strPk ] = $ this -> $ strKey ; } else { $ return [ ] = $ this -> $ strKey ; } } return $ return ; }
1355	protected function defaultSort ( ) { return collect ( $ this -> defaultSort ) -> map ( function ( $ param ) { $ desc = ( $ param [ 0 ] === '-' ) ; $ field = ltrim ( $ param , '-' ) ; return new SortParameter ( $ field , ! $ desc ) ; } ) -> all ( ) ; }
3670	private function determineFragments ( Request $ request ) : ? array { if ( null === $ requestUri = $ this -> strippedUri ( $ request ) ) { return null ; } $ fragments = null ; if ( Config :: get ( 'folderUrl' ) && false !== strpos ( $ requestUri , '/' ) ) { $ fragments = $ this -> getFolderUrlFragments ( $ requestUri , $ request -> getHost ( ) , $ request -> attributes -> get ( '_locale' ) ) ; } if ( null === $ fragments ) { if ( '/' === $ requestUri ) { return null ; } $ fragments = explode ( '/' , $ requestUri ) ; } if ( Config :: get ( 'useAutoItem' ) && 0 === ( \ count ( $ fragments ) % 2 ) ) { array_insert ( $ fragments , 1 , [ 'auto_item' ] ) ; } $ fragments = $ this -> getPageIdFromUrlHook ( $ fragments ) ; if ( null === $ fragments || ( '' === $ fragments [ 0 ] && \ count ( $ fragments ) > 1 ) ) { return null ; } return $ fragments ; }
8643	public function cancelReportRequests ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_CancelReportRequestsRequest ) { $ request = new MarketplaceWebService_Model_CancelReportRequestsRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertCancelReportRequests ( $ request ) ) ; $ response = MarketplaceWebService_Model_CancelReportRequestsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5462	public function stretch ( $ url ) { $ this -> root = $ this -> getCommonPath ( $ this -> root , $ url -> getPath ( ) ) ; }
7163	private function buildSaleItemsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasItems ( ) ) { return ; } foreach ( $ sale -> getItems ( ) as $ item ) { $ this -> view -> addItem ( $ this -> buildSaleItemLineView ( $ item ) ) ; } }
9766	function instanceOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , isInstanceOf ( $ className ) ) ; }
10375	protected static function validate ( $ type , $ data , $ admin ) { $ place = ( isset ( $ data [ 'place' ] ) ) ? $ data [ 'place' ] : 'front' ; $ place = $ admin && 'admin' == $ place || ! $ admin && 'front' == $ place ; if ( ! $ place || self :: set_params ( $ type , $ data ) === false ) { return false ; } return true ; }
8780	protected function scheme ( ) { if ( $ this -> cachedHttps === true ) { $ this -> https = true ; } return "http" . ( $ this -> https === true ? 's' : '' ) . "://" ; }
10115	private function writeFooter ( ) { $ record = 0x0015 ; $ recordData = StringHelper :: UTF8toBIFF8UnicodeLong ( $ this -> phpSheet -> getHeaderFooter ( ) -> getOddFooter ( ) ) ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
11413	public function batchUntagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_UNTAG , $ params ] ) ; }
1200	public function get ( $ menu , array $ path = array ( ) , array $ options = array ( ) ) { if ( ! $ menu instanceof ItemInterface ) { if ( null === $ this -> menuProvider ) { throw new \ BadMethodCallException ( 'A menu provider must be set to retrieve a menu' ) ; } $ menuName = $ menu ; $ menu = $ this -> menuProvider -> get ( $ menuName , $ options ) ; if ( ! $ menu instanceof ItemInterface ) { throw new \ LogicException ( sprintf ( 'The menu "%s" exists, but is not a valid menu item object. Check where you created the menu to be sure it returns an ItemInterface object.' , $ menuName ) ) ; } } foreach ( $ path as $ child ) { $ menu = $ menu -> getChild ( $ child ) ; if ( null === $ menu ) { throw new \ InvalidArgumentException ( sprintf ( 'The menu has no child named "%s"' , $ child ) ) ; } } return $ menu ; }
4691	public function having ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> having = $ expression ; $ this -> args [ 'having' ] = $ args ; return $ this ; }
12368	public function set ( string $ name , string $ value = null ) : Headers { if ( $ value !== null ) { header ( $ name . ': ' . $ value ) ; } else { header ( $ name ) ; } return $ this ; }
2669	public function checkAuthDictionaryPopulation ( $ version ) { $ dictionary = $ this -> getAuthDictionary ( $ version ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { throw new LocalizedException ( __ ( 'You must add users in order to enable Basic Authentication.' ) ) ; } $ authItems = $ this -> dictionaryItemsList ( $ dictionary -> id ) ; if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { throw new LocalizedException ( __ ( 'You must add users in order to enable Basic Authentication.' ) ) ; } }
8934	public function fetch ( $ name ) { $ template = false ; if ( array_key_exists ( $ name , $ this -> templates ) ) { $ template = $ this -> templates [ $ name ] ; } return $ template ; }
11206	public function map ( $ callback , $ data = false ) { $ collection = $ this -> getIterator ( ) ; $ mutatedCollection = new Collection ( ) ; foreach ( $ collection as $ prop => $ result ) { $ funcArgs = is_array ( $ data ) ? $ data : [ $ data ] ; array_unshift ( $ funcArgs , $ prop ) ; array_unshift ( $ funcArgs , $ result ) ; $ aValue = call_user_func_array ( $ callback , $ funcArgs ) ; $ mutatedCollection -> add ( $ aValue ) ; } return $ mutatedCollection ; }
9620	protected function httpPost ( $ host , $ path , array $ data , $ port = 80 ) { $ req = $ this -> qsencode ( $ data ) ; $ http_request = "POST {$path} HTTP/1.0\r\n" ; $ http_request .= "Host: {$host}\r\n" ; $ http_request .= "Content-Type: application/x-www-form-urlencoded;\r\n" ; $ http_request .= "Content-Length: " . strlen ( $ req ) . "\r\n" ; $ http_request .= "User-Agent: reCAPTCHA/PHP\r\n" ; $ http_request .= "\r\n" ; $ http_request .= $ req ; $ response = '' ; if ( false == ( $ fs = @ fsockopen ( $ host , ( int ) $ port , $ errno , $ errstr , 10 ) ) ) { throw new \ Exception ( 'Could not open socket' ) ; } fwrite ( $ fs , $ http_request ) ; while ( ! feof ( $ fs ) ) { $ response .= fgets ( $ fs , 1160 ) ; } fclose ( $ fs ) ; $ response = explode ( "\r\n\r\n" , $ response , 2 ) ; return $ response ; }
2727	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> determineVersions ( $ service -> versions ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> request -> getParam ( 'acls' ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetName = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; $ snippetId = $ this -> api -> getSnippet ( $ currActiveVersion [ 'active_version' ] , $ snippetName ) -> id ; $ params = [ 'name' => $ snippetId , 'content' => $ value ] ; $ this -> api -> updateSnippet ( $ params ) ; } $ this -> cacheTypeList -> cleanType ( 'config' ) ; $ this -> systemConfig -> clean ( ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2364	public static function generateAlias ( $ strString ) { $ strString = static :: decodeEntities ( $ strString ) ; $ strString = static :: restoreBasicEntities ( $ strString ) ; $ strString = static :: standardize ( strip_tags ( $ strString ) ) ; if ( strncmp ( $ strString , 'id-' , 3 ) === 0 && ! is_numeric ( $ strSubstr = substr ( $ strString , 3 ) ) ) { $ strString = $ strSubstr ; } return $ strString ; }
3899	public function setDataFor ( $ arrValues ) { $ strTable = $ this -> getMetaModel ( ) -> getTableName ( ) ; $ strColName = $ this -> getColName ( ) ; foreach ( $ arrValues as $ intId => $ varData ) { if ( is_array ( $ varData ) ) { $ varData = serialize ( $ varData ) ; } $ this -> connection -> update ( $ strTable , [ $ strColName => $ varData ] , [ 'id' => $ intId ] ) ; } }
8925	public function mapJson ( $ json , $ targetClass ) { if ( ! is_array ( $ data = json_decode ( $ json , true ) ) ) { throw new InvalidJsonException ( ) ; } $ result = null ; if ( substr ( $ targetClass , - 2 ) == '[]' ) { $ result = [ ] ; foreach ( $ data as $ key => $ entryData ) { $ result [ ] = $ this -> mapDataToObject ( $ entryData , substr ( $ targetClass , 0 , - 2 ) ) ; } } else { $ result = $ this -> mapDataToObject ( $ data , $ targetClass ) ; } return $ result ; }
6404	public static function propagateIfInstanceOf ( Exception $ exception , string $ exceptionClass ) : void { if ( is_a ( $ exception , $ exceptionClass ) ) { throw $ exception ; } }
4028	protected function getLabelImage ( ModelInterface $ model ) { $ typeFactory = $ this -> factory -> getTypeFactory ( $ model -> getProperty ( 'type' ) ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> updateImageWithDisabled ( $ model , $ typeFactory -> getTypeIcon ( ) ) , '' , '' , $ this -> updateImageWithDisabled ( $ model , 'bundles/metamodelscore/images/icons/filter_default.png' ) ) ; $ urlEvent = $ this -> dispatcher -> dispatch ( ContaoEvents :: BACKEND_ADD_TO_URL , new AddToUrlEvent ( 'act=edit&amp;id=' . $ model -> getId ( ) ) ) ; return sprintf ( '<a href="%s">%s</a>' , $ urlEvent -> getUrl ( ) , $ image ) ; }
4960	public function render ( FormInterface $ form , $ layout = self :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ formContent = $ this -> renderBare ( $ form , $ layout , $ parameter ) ; $ renderer = $ this -> getView ( ) ; if ( $ form instanceof DescriptionAwareFormInterface && $ form -> isDescriptionsEnabled ( ) ) { $ renderer -> headscript ( ) -> appendFile ( $ renderer -> basepath ( 'modules/Core/js/forms.descriptions.js' ) ) ; if ( $ desc = $ form -> getOption ( 'description' , '' ) ) { $ descriptionParams = $ form -> getOption ( 'description_params' ) ; $ translator = $ this -> getTranslator ( ) ; $ textDomain = $ this -> getTranslatorTextDomain ( ) ; $ desc = $ translator -> translate ( $ desc , $ textDomain ) ; if ( $ descriptionParams ) { array_unshift ( $ descriptionParams , $ desc ) ; $ desc = call_user_func_array ( 'sprintf' , $ descriptionParams ) ; } } $ formContent = sprintf ( '<div class="daf-form-container row"> <div class="daf-form col-md-8"><div class="panel panel-default"><div class="panel-body">%s</div></div></div> <div class="daf-desc col-md-4"> <div class="daf-desc-content alert alert-info">%s</div> </div> </div>' , $ formContent , $ desc ) ; } else { $ formContent = '<div class="form-content">' . $ formContent . '</div>' ; } $ markup = '<div id="form-%s" class="form-container">' . '%s' . '%s' . '</div>' ; if ( $ label = $ form -> getLabel ( ) ) { $ label = '<div class="form-headline"><h3>' . $ renderer -> translate ( $ label ) . '</h3></div>' ; } return sprintf ( $ markup , $ form -> getAttribute ( 'id' ) ? : $ form -> getName ( ) , $ label , $ formContent ) ; }
9872	private function writeSheetData ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet , array $ pStringTable ) { $ aFlippedStringTable = $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> flipStringTable ( $ pStringTable ) ; $ objWriter -> startElement ( 'sheetData' ) ; $ colCount = Coordinate :: columnIndexFromString ( $ pSheet -> getHighestColumn ( ) ) ; $ highestRow = $ pSheet -> getHighestRow ( ) ; $ cellsByRow = [ ] ; foreach ( $ pSheet -> getCoordinates ( ) as $ coordinate ) { $ cellAddress = Coordinate :: coordinateFromString ( $ coordinate ) ; $ cellsByRow [ $ cellAddress [ 1 ] ] [ ] = $ coordinate ; } $ currentRow = 0 ; while ( $ currentRow ++ < $ highestRow ) { $ rowDimension = $ pSheet -> getRowDimension ( $ currentRow ) ; $ writeCurrentRow = isset ( $ cellsByRow [ $ currentRow ] ) || $ rowDimension -> getRowHeight ( ) >= 0 || $ rowDimension -> getVisible ( ) == false || $ rowDimension -> getCollapsed ( ) == true || $ rowDimension -> getOutlineLevel ( ) > 0 || $ rowDimension -> getXfIndex ( ) !== null ; if ( $ writeCurrentRow ) { $ objWriter -> startElement ( 'row' ) ; $ objWriter -> writeAttribute ( 'r' , $ currentRow ) ; $ objWriter -> writeAttribute ( 'spans' , '1:' . $ colCount ) ; if ( $ rowDimension -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , '1' ) ; $ objWriter -> writeAttribute ( 'ht' , StringHelper :: formatNumber ( $ rowDimension -> getRowHeight ( ) ) ) ; } if ( $ rowDimension -> getVisible ( ) == false ) { $ objWriter -> writeAttribute ( 'hidden' , 'true' ) ; } if ( $ rowDimension -> getCollapsed ( ) == true ) { $ objWriter -> writeAttribute ( 'collapsed' , 'true' ) ; } if ( $ rowDimension -> getOutlineLevel ( ) > 0 ) { $ objWriter -> writeAttribute ( 'outlineLevel' , $ rowDimension -> getOutlineLevel ( ) ) ; } if ( $ rowDimension -> getXfIndex ( ) !== null ) { $ objWriter -> writeAttribute ( 's' , $ rowDimension -> getXfIndex ( ) ) ; $ objWriter -> writeAttribute ( 'customFormat' , '1' ) ; } if ( isset ( $ cellsByRow [ $ currentRow ] ) ) { foreach ( $ cellsByRow [ $ currentRow ] as $ cellAddress ) { $ this -> writeCell ( $ objWriter , $ pSheet , $ cellAddress , $ aFlippedStringTable ) ; } } $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; }
3225	function createFolder ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/create_folder" , array ( "root" => "auto" , "path" => $ path , ) ) ; if ( $ response -> statusCode === 403 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
1932	public function parse ( ) { $ strBuffer = parent :: parse ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'parseBackendTemplate' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'parseBackendTemplate' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'parseBackendTemplate' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ strBuffer = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strBuffer , $ this -> strTemplate ) ; } } return $ strBuffer ; }
5775	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ roles = $ this -> mapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) ) ; } catch ( QueryFailureException $ e ) { $ roles = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ roles ) ; }
2563	protected function loadBusinessId ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> businessCategory , $ params -> businessForeignKey ) ) { $ this -> porFndQryParams -> businessId = new BusinessId ( $ params -> businessCategory , $ params -> businessForeignKey ) ; } }
2272	public static function quoteIdentifier ( $ strName ) { static $ strQuoteCharacter = null ; if ( $ strQuoteCharacter === null ) { $ strQuoteCharacter = System :: getContainer ( ) -> get ( 'database_connection' ) -> getDatabasePlatform ( ) -> getIdentifierQuoteCharacter ( ) ; } if ( strncmp ( $ strName , $ strQuoteCharacter , 1 ) === 0 ) { return $ strName ; } if ( ! preg_match ( '/^[A-Za-z0-9_$.]+$/' , $ strName ) ) { return $ strName ; } return System :: getContainer ( ) -> get ( 'database_connection' ) -> quoteIdentifier ( $ strName ) ; }
6555	public function stop ( $ reason ) { $ this -> log ( $ reason , LogLevel :: INFO ) ; $ this -> stopped = true ; }
2746	public function isImageOptimizationPixelRatioEnabled ( ) { if ( $ this -> isImageOptimizationEnabled ( ) !== true ) { return false ; } return $ this -> _scopeConfig -> isSetFlag ( self :: XML_FASTLY_IMAGE_OPTIMIZATIONS_PIXEL_RATIO ) ; }
9914	public function create ( $ modelName , ModelConfig $ config = null ) { $ menu = new Menu ( ) ; $ addMenuItem = new LinkMenuItem ( ) ; $ addMenuItem -> setText ( Lang :: trans ( 'Add' ) ) ; $ addMenuItem -> setIcon ( Icons :: ion_plus ) ; $ addMenuItem -> setTarget ( URL :: route ( $ this -> aujaRouter -> getCreateName ( $ modelName ) ) ) ; $ menu -> addMenuItem ( $ addMenuItem ) ; $ spacerMenuItem = new SpacerMenuItem ( ) ; $ spacerMenuItem -> setText ( Lang :: trans ( $ modelName ) ) ; $ menu -> addMenuItem ( $ spacerMenuItem ) ; $ resourceMenuItem = new ResourceMenuItem ( ) ; $ resourceMenuItem -> setTarget ( URL :: route ( $ this -> aujaRouter -> getIndexName ( $ modelName ) ) ) ; $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; if ( $ this -> aujaConfigurator -> isSearchable ( $ model , $ config ) ) { $ target = urldecode ( URL :: route ( $ this -> aujaRouter -> getIndexName ( $ modelName ) , [ 'q' => '%s' ] ) ) ; $ property = new Searchable ( $ target ) ; $ resourceMenuItem -> addProperty ( $ property ) ; } $ menu -> addMenuItem ( $ resourceMenuItem ) ; return $ menu ; }
7580	protected function verifyUrl ( ) { $ UrlArray = explode ( "?" , $ this -> Url ) ; if ( strpos ( $ UrlArray [ 0 ] , "$" ) !== false ) { throw new InvalidURLException ( get_called_class ( ) , "Configured URL is " . $ this -> Url ) ; } return true ; }
2015	public static function load ( $ class ) { if ( class_exists ( $ class , false ) || interface_exists ( $ class , false ) || trait_exists ( $ class , false ) ) { return ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ classes [ $ class ] ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_set' ] [ $ class ] = $ class ; } include $ rootDir . '/' . self :: $ classes [ $ class ] ; } elseif ( ( $ namespaced = self :: findClass ( $ class ) ) !== null ) { if ( ! class_exists ( $ namespaced , false ) && ! interface_exists ( $ namespaced , false ) && ! trait_exists ( $ namespaced , false ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_aliased' ] [ $ class ] = $ namespaced ; } include $ rootDir . '/' . self :: $ classes [ $ namespaced ] ; } class_alias ( $ namespaced , $ class ) ; } elseif ( strncmp ( $ class , 'Contao\\' , 7 ) !== 0 ) { $ namespaced = 'Contao\\' . $ class ; if ( class_exists ( $ namespaced ) || interface_exists ( $ namespaced ) || trait_exists ( $ namespaced ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_composerized' ] [ $ class ] = $ namespaced ; } if ( ! class_exists ( $ class , false ) && ! interface_exists ( $ class , false ) && ! trait_exists ( $ class , false ) ) { class_alias ( $ namespaced , $ class ) ; } } } }
1129	public function getLeftSibling ( ) { return $ this -> siblings ( ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getLeft ( ) ) -> orderBy ( $ this -> getOrderColumnName ( ) , 'desc' ) -> get ( ) -> last ( ) ; }
4258	public function addSubscriberInterface ( SubscriberInterface $ interface ) { $ subscribers = $ this -> getInterfaceSubscribers ( $ interface ) ; foreach ( $ subscribers as $ row ) { $ this -> subscribe ( $ row [ 0 ] , $ row [ 1 ] , $ row [ 2 ] ) ; } return $ subscribers ; }
6483	private static function filterPath ( ? string $ path ) : ? string { if ( $ path === null ) { return null ; } return preg_replace_callback ( '/(?:[^a-zA-Z0-9_\-\.~:@&=\+\$,\/;%]+|%(?![A-Fa-f0-9]{2}))/' , function ( $ match ) { return rawurlencode ( $ match [ 0 ] ) ; } , $ path ) ; }
10177	public function cloneCellCollection ( Worksheet $ parent ) { $ this -> storeCurrentCell ( ) ; $ newCollection = clone $ this ; $ newCollection -> parent = $ parent ; if ( ( $ newCollection -> currentCell !== null ) && ( is_object ( $ newCollection -> currentCell ) ) ) { $ newCollection -> currentCell -> attach ( $ this ) ; } $ oldKeys = $ newCollection -> getAllCacheKeys ( ) ; $ oldValues = $ newCollection -> cache -> getMultiple ( $ oldKeys ) ; $ newValues = [ ] ; $ oldCachePrefix = $ newCollection -> cachePrefix ; $ newCollection -> cachePrefix = $ newCollection -> getUniqueID ( ) ; foreach ( $ oldValues as $ oldKey => $ value ) { $ newValues [ str_replace ( $ oldCachePrefix , $ newCollection -> cachePrefix , $ oldKey ) ] = clone $ value ; } $ stored = $ newCollection -> cache -> setMultiple ( $ newValues ) ; if ( ! $ stored ) { $ newCollection -> __destruct ( ) ; throw new PhpSpreadsheetException ( 'Failed to copy cells in cache' ) ; } return $ newCollection ; }
11379	public function putAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)\/(\w+)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ language , $ oldName ) = $ matches ; $ request = $ this -> environment -> getRequestHelper ( ) ; $ newName = $ request -> getIdentifierParam ( 'name' ) ; $ content = $ request -> getParam ( 'content' , '' ) ; try { $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ text = $ pageTexts -> modifyTextContainer ( $ oldName , $ newName , $ this -> filter ( $ content ) , $ language ) ; $ this -> environment -> sendJSONResult ( $ text ) ; } catch ( \ Exception $ e ) { throw new InvalidParameterException ( $ e -> getMessage ( ) ) ; } }
9494	private function formatSize ( $ bytes ) { $ kb = 1024 ; $ mb = $ kb * 1024 ; $ gb = $ mb * 1024 ; $ tb = $ gb * 1024 ; if ( ( $ bytes >= 0 ) && ( $ bytes < $ kb ) ) { return $ bytes . ' B' ; } elseif ( ( $ bytes >= $ kb ) && ( $ bytes < $ mb ) ) { return ceil ( $ bytes / $ kb ) . ' KB' ; } elseif ( ( $ bytes >= $ mb ) && ( $ bytes < $ gb ) ) { return ceil ( $ bytes / $ mb ) . ' MB' ; } elseif ( ( $ bytes >= $ gb ) && ( $ bytes < $ tb ) ) { return ceil ( $ bytes / $ gb ) . ' GB' ; } elseif ( $ bytes >= $ tb ) { return ceil ( $ bytes / $ tb ) . ' TB' ; } return $ bytes . ' B' ; }
4598	public function generateIdentity ( Identitiable $ model , bool $ overwrite = false ) { if ( null === $ model -> getIdentity ( ) || $ overwrite ) { $ user = $ this -> tokenStorage -> getToken ( ) -> getUser ( ) ; $ model -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) ; } return $ this ; }
3870	protected function getView ( $ identifier , $ view ) { $ metaModels = $ this -> getMetaModel ( $ identifier , false ) ; return $ metaModels -> getView ( $ view ) ; }
5923	public function addPropertySet ( $ item ) { if ( ! ( $ item instanceof PropertySet ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertySet ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertySet. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertySet"!' , E_USER_WARNING ) ; } } $ this -> propertySets [ ] = $ item ; return $ this ; }
5487	public function submitImage ( SelectorInterface $ selector , $ x , $ y , $ additional = false ) { $ additional = $ additional ? $ additional : array ( ) ; foreach ( $ this -> images as $ image ) { if ( $ selector -> isMatch ( $ image ) ) { $ encoding = $ this -> encode ( ) ; $ image -> write ( $ encoding , $ x , $ y ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; } } return false ; }
1470	public function createResolver ( $ apiName , array $ config ) { $ factoryName = isset ( $ config [ 'resolver' ] ) ? $ config [ 'resolver' ] : ResolverFactory :: class ; $ factory = $ this -> container -> make ( $ factoryName ) ; if ( $ factory instanceof ResolverInterface ) { return $ factory ; } if ( ! is_callable ( $ factory ) ) { throw new RuntimeException ( "Factory {$factoryName} cannot be invoked." ) ; } $ resolver = $ factory ( $ apiName , $ config ) ; if ( ! $ resolver instanceof ResolverInterface ) { throw new RuntimeException ( "Factory {$factoryName} did not create a resolver instance." ) ; } return $ resolver ; }
4080	protected function isInputScreenStandalone ( $ metaModel ) { $ information = $ this -> information [ $ metaModel ] ; $ inputScreen = isset ( $ information [ self :: INPUTSCREEN ] ) ? $ information [ self :: INPUTSCREEN ] : null ; if ( ! is_object ( $ inputScreen ) ) { return ( $ inputScreen [ 'row' ] [ 'rendertype' ] == 'standalone' ) ; } return $ inputScreen -> isStandalone ( ) ; }
2493	protected function getRange ( $ operator , $ start , $ end ) { $ startBrace = '[' ; $ startValue = '*' ; $ endValue = '*' ; $ endBrace = ']' ; $ start = '"' . $ this -> escapeQuote ( $ this -> toString ( $ start ) , true ) . '"' ; $ end = '"' . $ this -> escapeQuote ( $ this -> toString ( $ end ) , true ) . '"' ; switch ( $ operator ) { case Operator :: GT : $ startBrace = '{' ; $ endBrace = '}' ; case Operator :: GTE : $ startValue = $ start ; break ; case Operator :: LT : $ startBrace = '{' ; $ endBrace = '}' ; case Operator :: LTE : $ endValue = $ end ; break ; case Operator :: BETWEEN : $ startValue = $ start ; $ endValue = $ end ; break ; default : throw new \ RuntimeException ( "Unknown operator: $operator" ) ; } return "$startBrace$startValue TO $endValue$endBrace" ; }
8968	protected function load ( ) { $ this -> rates = array ( ) ; $ this -> latest = array ( ) ; $ handle = fopen ( $ this -> pathToFile , 'rb' ) ; if ( ! $ handle ) { throw new RuntimeException ( sprintf ( 'Error opening file on path "%s".' , $ this -> pathToFile ) ) ; } while ( ( $ line = fgets ( $ handle ) ) !== false ) { $ rate = $ this -> fromJson ( $ line ) ; $ this -> rates [ $ this -> getRateKey ( $ rate -> getCurrencyCode ( ) , $ rate -> getDate ( ) , $ rate -> getRateType ( ) , $ rate -> getSourceName ( ) ) ] = $ rate ; $ latestKey = sprintf ( '%s_%s_%s' , $ rate -> getCurrencyCode ( ) , $ rate -> getRateType ( ) , $ rate -> getSourceName ( ) ) ; if ( ! isset ( $ this -> latest [ $ latestKey ] ) || ( $ this -> latest [ $ latestKey ] -> getDate ( ) < $ rate -> getDate ( ) ) ) { $ this -> latest [ $ latestKey ] = $ rate ; } } fclose ( $ handle ) ; return $ this -> rates ; }
2244	protected function getSpellcheckerString ( ) { System :: loadLanguageFile ( 'languages' ) ; $ return = array ( ) ; $ langs = scan ( __DIR__ . '/../../languages' ) ; array_unshift ( $ langs , $ GLOBALS [ 'TL_LANGUAGE' ] ) ; foreach ( $ langs as $ lang ) { $ lang = substr ( $ lang , 0 , 2 ) ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ lang ] ) ) { $ return [ $ lang ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ lang ] . '=' . $ lang ; } } return '+' . implode ( ',' , array_unique ( $ return ) ) ; }
8251	protected function isValidUsername ( $ name ) { if ( ! is_string ( $ name ) || ! $ this -> storage -> checkValidName ( $ name ) || strlen ( $ name ) < $ this -> config [ "registration" ] [ "nameLenMin" ] || strlen ( $ name ) > $ this -> config [ "registration" ] [ "nameLenMax" ] ) { return false ; } return true ; }
9013	public function mediumtext ( string $ charset = null ) : self { $ this -> type = 'mediumtext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
9232	public function actionView ( $ id , $ format = false ) { $ model = $ this -> findModel ( $ id ) ; if ( $ format == 'json' ) { return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'view' , [ 'model' => $ model , ] ) ; } }
11734	public function hide ( $ pageName , $ languageName ) { $ this -> contributorDefined ( ) ; $ baseDir = $ this -> pagesDir . '/' . $ pageName . '/' . $ languageName ; $ sourceFile = $ baseDir . '/seo.json' ; Dispatcher :: dispatch ( PageEvents :: PAGE_HIDING , new PageHidingEvent ( ) ) ; unlink ( $ sourceFile ) ; Dispatcher :: dispatch ( PageEvents :: PAGE_HID , new PageHidEvent ( ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" for language "%s" was hidden from production' , $ pageName , $ languageName ) ) ; }
2152	public function synchronize ( $ varValue , $ objUser , $ objModule = null ) { if ( $ objUser === null ) { return $ varValue ; } $ blnIsFrontend = true ; if ( $ objUser instanceof DataContainer ) { $ objUser = $ this -> Database -> prepare ( "SELECT * FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ objUser -> id ) ; if ( $ objUser -> numRows < 1 ) { return $ varValue ; } $ blnIsFrontend = false ; } if ( $ varValue == $ objUser -> newsletter || $ objUser -> email == '' ) { return $ varValue ; } $ time = time ( ) ; $ varValue = StringUtil :: deserialize ( $ varValue , true ) ; if ( $ blnIsFrontend && $ objModule instanceof Module ) { $ arrChannel = StringUtil :: deserialize ( $ objModule -> newsletters , true ) ; } else { $ arrChannel = $ this -> Database -> query ( "SELECT id FROM tl_newsletter_channel" ) -> fetchEach ( 'id' ) ; } $ arrDelete = array_values ( array_diff ( $ arrChannel , $ varValue ) ) ; if ( ! empty ( $ arrDelete ) && \ is_array ( $ arrDelete ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrDelete ) ) . ") AND email=?" ) -> execute ( $ objUser -> email ) ; } foreach ( $ varValue as $ intId ) { $ intId = ( int ) $ intId ; if ( $ intId < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intId , $ objUser -> email ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, active=?, addedOn=?" ) -> execute ( $ intId , $ objUser -> email , ( $ objUser -> disable ? '' : 1 ) , ( $ blnIsFrontend ? $ time : '' ) ) ; } } return serialize ( $ varValue ) ; }
8917	public function message ( $ messageId ) { $ params = [ 'query' => [ 'apikey' => $ this -> apikey , ] ] ; $ response = $ this -> client -> get ( 'messages/' . $ messageId , $ params ) ; return $ response -> getBody ( ) ; }
6024	public function setMetadata ( array $ metadata ) { $ this -> metadata = [ ] ; foreach ( $ metadata as $ item ) { $ this -> addMetaData ( $ item ) ; } return $ this ; }
11194	protected function fixTree ( array $ data ) { $ result = [ ] ; foreach ( $ data as $ k => $ v ) { $ res = & $ this -> searchNode ( $ k , $ result ) ; if ( is_array ( $ v ) && is_array ( $ res ) ) { $ res = array_replace_recursive ( $ res , $ this -> fixTree ( $ v ) ) ; } else { $ res = $ v ; } } return $ result ; }
7248	protected function dispatchPrepareEvent ( SaleInterface $ sale ) { if ( ! $ sale instanceof OrderInterface ) { throw new InvalidArgumentException ( "Expected instance of " . OrderInterface :: class ) ; } $ event = $ this -> eventDispatcher -> createResourceEvent ( $ sale ) ; try { $ this -> eventDispatcher -> dispatch ( OrderEvents :: PREPARE , $ event ) ; } catch ( IllegalOperationException $ e ) { return false ; } return true ; }
12933	protected function generateContent ( $ type , $ id , $ name , $ language ) { $ content = new Content ( ) ; $ content -> setContentId ( $ id ) ; $ content -> setContentType ( $ type ) ; $ content -> setDeleted ( false ) ; $ content -> setName ( $ name ) ; $ content -> setLanguage ( $ language ) ; $ content -> setStatus ( $ this -> getReference ( 'status-published' ) ) ; $ content -> setVersion ( '1' ) ; $ content -> setSiteId ( '2' ) ; $ date = new \ DateTime ( "now" ) ; $ content -> setVersionName ( $ content -> getName ( ) . '_' . $ date -> format ( "Y-m-d_H:i:s" ) ) ; return $ content ; }
3242	public function getDisplayNameAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> displayName ; return isset ( $ this -> itemName ) ? $ this -> attributes [ $ this -> itemName ] : ( array_key_exists ( 'name' , $ this -> attributes ) ? $ this -> attributes [ 'name' ] : '' ) ; }
4444	public function failedForGroup ( $ group , int $ start = 0 , int $ limit = 25 ) : array { $ results = json_decode ( $ this -> client -> failed ( $ group , $ start , $ limit ) , true ) ; if ( isset ( $ results [ 'jobs' ] ) && ! empty ( $ results [ 'jobs' ] ) ) { $ results [ 'jobs' ] = $ this -> multiget ( $ results [ 'jobs' ] ) ; } return is_array ( $ results ) ? $ results : [ ] ; }
1815	public function tableImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=table' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a> ' . Contao \ Image :: getHtml ( 'demagnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_shrink' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(0.9)"' ) . Contao \ Image :: getHtml ( 'magnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_expand' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(1.1)"' ) ; }
11713	private function getCalcData ( ) { $ req = new AGetPeriodRequest ( ) ; $ req -> setBaseCalcTypeCode ( Cfg :: CODE_TYPE_CALC_PV_WRITE_OFF ) ; $ req -> setDepCalcTypeCode ( Cfg :: CODE_TYPE_CALC_UNQUALIFIED_PROCESS ) ; $ resp = $ this -> servPeriodGet -> exec ( $ req ) ; $ writeOffCalc = $ resp -> getBaseCalcData ( ) ; $ processCalc = $ resp -> getDepCalcData ( ) ; $ result = [ $ writeOffCalc , $ processCalc ] ; return $ result ; }
3154	public function getTraceVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_TraceVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setTrace ( $ variableValue ) ; return $ metaVariable ; }
485	public function addCommentOnColumn ( $ table , $ column , $ comment ) { $ time = $ this -> beginCommand ( "add comment on column $column" ) ; $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ comment ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
668	public static function normalizeNumber ( $ value ) { $ value = ( string ) $ value ; $ localeInfo = localeconv ( ) ; $ decimalSeparator = isset ( $ localeInfo [ 'decimal_point' ] ) ? $ localeInfo [ 'decimal_point' ] : null ; if ( $ decimalSeparator !== null && $ decimalSeparator !== '.' ) { $ value = str_replace ( $ decimalSeparator , '.' , $ value ) ; } return $ value ; }
2684	private function _fetch ( $ uri , $ method = \ Zend_Http_Client :: GET , $ body = '' , $ test = false , $ testApiKey = null , $ logError = true ) { $ apiKey = ( $ test == true ) ? $ testApiKey : $ this -> config -> getApiKey ( ) ; if ( is_array ( $ body ) == true ) { $ body = http_build_query ( $ body ) ; } $ headers = [ self :: FASTLY_HEADER_AUTH . ': ' . $ apiKey , 'Accept: application/json' ] ; $ options = [ ] ; switch ( $ method ) { case \ Zend_Http_Client :: DELETE : $ options [ CURLOPT_CUSTOMREQUEST ] = \ Zend_Http_Client :: DELETE ; break ; case \ Zend_Http_Client :: PUT : $ headers [ ] = 'Content-Type: application/x-www-form-urlencoded' ; $ options [ CURLOPT_CUSTOMREQUEST ] = \ Zend_Http_Client :: PUT ; if ( $ body != '' ) { $ options [ CURLOPT_POSTFIELDS ] = $ body ; } break ; case \ Zend_Http_Client :: PATCH : $ options [ CURLOPT_CUSTOMREQUEST ] = \ Zend_Http_Client :: PATCH ; $ headers [ ] = 'Content-Type: text/json' ; if ( $ body != '' ) { $ options [ CURLOPT_POSTFIELDS ] = $ body ; } break ; } $ client = $ this -> curlFactory -> create ( ) ; $ client -> setOptions ( $ options ) ; $ client -> write ( $ method , $ uri , '1.1' , $ headers , $ body ) ; $ response = $ client -> read ( ) ; $ client -> close ( ) ; $ responseBody = \ Zend_Http_Response :: extractBody ( $ response ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; $ responseMessage = \ Zend_Http_Response :: extractMessage ( $ response ) ; if ( $ responseCode == '429' ) { throw new LocalizedException ( __ ( $ responseMessage ) ) ; } elseif ( $ responseCode != '200' ) { if ( $ logError == true ) { $ this -> logger -> critical ( 'Return status ' . $ responseCode , $ uri ) ; } return false ; } return json_decode ( $ responseBody ) ; }
11869	public function clearOld ( int $ maxLife ) : void { $ limit = microtime ( true ) - $ maxLife / 1000000 ; foreach ( self :: $ files as & $ file ) { if ( $ file [ 'time' ] <= $ limit ) { $ file = null ; } } self :: $ files = array_filter ( self :: $ files ) ; }
10062	public function update ( $ key , $ value ) { try { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> firstOrFail ( ) ; } catch ( \ Exception $ e ) { $ message = "Can't update meta (key: $key). " ; $ message .= "Meta doesn't exist" ; throw new \ Exception ( $ message ) ; } $ meta -> value = $ value ; $ meta -> save ( ) ; }
828	private function isValidVariable ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_VARIABLE ) ) { return false ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; return $ tokens [ $ nextIndex ] -> equals ( '=' ) ; }
5075	public function writeLog ( $ sLine ) { if ( ! is_string ( $ sLine ) ) { $ sLine = print_r ( $ sLine , true ) ; } $ sLine = ' [' . $ this -> sModuleName . '->' . $ this -> sMethod . '] ' . $ sLine ; $ this -> oLogger -> line ( $ sLine ) ; }
3731	protected function fetchRows ( $ arrIds , $ arrAttrOnly = array ( ) ) { $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ query = $ builder -> select ( '*' ) -> from ( $ this -> getTableName ( ) ) -> where ( $ builder -> expr ( ) -> in ( 'id' , ':values' ) ) -> setParameter ( 'values' , $ arrIds , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'FIELD(id, :values)' ) -> execute ( ) ; if ( $ arrAttrOnly ) { $ arrAttrOnly = array_merge ( $ this -> systemColumns , $ arrAttrOnly ) ; } $ result = [ ] ; while ( $ row = $ query -> fetch ( \ PDO :: FETCH_ASSOC ) ) { $ data = [ ] ; foreach ( $ row as $ attribute => $ value ) { if ( ( ! $ arrAttrOnly ) || ( in_array ( $ attribute , $ arrAttrOnly , true ) ) ) { $ data [ $ attribute ] = $ value ; } } $ result [ $ row [ 'id' ] ] = $ data ; } return $ result ; }
3815	protected function process ( $ table , $ metaModelName , $ parentId , Request $ request ) { $ this -> knownAttributes = $ this -> fetchExisting ( $ table , $ parentId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( ! $ metaModel ) { throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelName ) ; } if ( $ request -> request -> has ( 'add' ) || $ request -> request -> has ( 'saveNclose' ) ) { $ this -> perform ( $ table , $ request , $ metaModel , $ parentId ) ; if ( $ request -> request -> has ( 'saveNclose' ) ) { return new RedirectResponse ( $ this -> getReferer ( $ request , $ table , false ) ) ; } } return new Response ( $ this -> templating -> render ( 'MetaModelsCoreBundle::Backend/add-all.html.twig' , $ this -> render ( $ table , $ metaModel , $ request ) ) ) ; }
7384	private function generateString ( ) { $ this -> generateNumbers ( ) ; $ this -> adjective = $ this -> adjectives [ $ this -> first ] ; $ this -> animal = $ this -> animals [ $ this -> second ] ; switch ( $ this -> case ) { case 'ucfirst' : $ this -> string = ucfirst ( $ this -> adjective . $ this -> animal . $ this -> number ) ; break ; case 'ucwords' : case 'sentence' : $ this -> string = ucfirst ( $ this -> adjective ) . ucfirst ( $ this -> animal ) . ucfirst ( $ this -> number ) ; break ; case 'camel' : $ this -> string = $ this -> adjective . ucfirst ( $ this -> animal ) . $ this -> number ; break ; default : $ this -> string = $ this -> adjective . $ this -> animal . $ this -> number ; break ; } }
2180	private function findIn ( string $ path ) : Finder { return Finder :: create ( ) -> ignoreDotFiles ( false ) -> sort ( static function ( SplFileInfo $ a , SplFileInfo $ b ) : int { $ countA = substr_count ( strtr ( $ a -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; $ countB = substr_count ( strtr ( $ b -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; return $ countA <=> $ countB ; } ) -> followLinks ( ) -> in ( $ path ) ; }
2264	public function tableExists ( $ strTable , $ strDatabase = null , $ blnNoCache = false ) { if ( $ strTable == '' ) { return false ; } return \ in_array ( $ strTable , $ this -> listTables ( $ strDatabase , $ blnNoCache ) ) ; }
1521	public function processes ( StoreInterface $ store , FetchProcesses $ request ) { $ result = $ store -> queryRecords ( $ request -> getProcessType ( ) , $ request -> getEncodingParameters ( ) ) ; return $ this -> reply ( ) -> content ( $ result ) ; }
4655	protected function getJobFromImage ( ImageItem $ image , $ imageName , $ strategy , $ project ) { $ tag = explode ( ':' , $ imageName ) [ 1 ] ; list ( $ uniq , $ timestamp ) = explode ( '-' , $ tag ) ; return new Job ( $ project , $ strategy , $ uniq , array ( 'image' => $ image ) , "" , \ DateTime :: createFromFormat ( 'U' , $ timestamp ) ) ; }
7766	public function getContextAction ( $ type ) { $ context = $ this -> get ( 'hydra.api' ) -> getContext ( $ type ) ; if ( null === $ context ) { $ this -> createNotFoundException ( ) ; } return new JsonLdResponse ( $ context ) ; }
6666	public function setBodyData ( $ data ) { if ( ! $ data instanceof \ Generator ) { $ this -> body [ static :: DEFAULT_DATA_NAME ] = $ data ; return $ this ; } foreach ( $ data as $ key => $ value ) { $ actualKey = $ key ? : static :: DEFAULT_DATA_NAME ; $ this -> body [ $ actualKey ] = $ value ; } return $ this ; }
12972	protected function createEntityManager ( ) { if ( $ cache = $ this -> getConfig ( 'cache_driver' , 'array' ) ) { $ cache = 'doctrine.cache.' . $ cache ; $ cache = DiC :: resolve ( $ cache ) ; } if ( $ this -> getConfig ( 'auto_config' , false ) ) { $ dev = $ this -> getConfig ( 'dev_mode' , \ Fuel :: $ env === \ Fuel :: DEVELOPMENT ) ; $ proxy_dir = $ this -> getConfig ( 'proxy_dir' ) ; $ config = Setup :: createConfiguration ( $ dev , $ proxy_dir , $ cache ) ; } else { $ config = new Configuration ; $ config -> setProxyDir ( $ this -> getConfig ( 'proxy_dir' ) ) ; $ config -> setProxyNamespace ( $ this -> getConfig ( 'proxy_namespace' ) ) ; $ config -> setAutoGenerateProxyClasses ( $ this -> getConfig ( 'auto_generate_proxy_classes' , false ) ) ; if ( $ cache ) { $ config -> setMetadataCacheImpl ( $ cache ) ; $ config -> setQueryCacheImpl ( $ cache ) ; $ config -> setResultCacheImpl ( $ cache ) ; } } $ config -> newDefaultAnnotationDriver ( array ( ) ) ; $ this -> registerMapping ( $ config ) ; $ conn = DiC :: multiton ( 'dbal' , $ this -> getConfig ( 'dbal' ) , [ $ this -> getConfig ( 'dbal' ) ] ) ; $ evm = $ conn -> getEventManager ( ) ; $ this -> registerBehaviors ( $ evm , $ config ) ; return $ this -> entityManager = EntityManager :: create ( $ conn , $ config , $ evm ) ; }
809	private function sortByLength ( array $ first , array $ second ) { $ firstNamespace = ( self :: IMPORT_TYPE_CLASS === $ first [ 'importType' ] ? '' : $ first [ 'importType' ] . ' ' ) . $ this -> prepareNamespace ( $ first [ 'namespace' ] ) ; $ secondNamespace = ( self :: IMPORT_TYPE_CLASS === $ second [ 'importType' ] ? '' : $ second [ 'importType' ] . ' ' ) . $ this -> prepareNamespace ( $ second [ 'namespace' ] ) ; $ firstNamespaceLength = \ strlen ( $ firstNamespace ) ; $ secondNamespaceLength = \ strlen ( $ secondNamespace ) ; if ( $ firstNamespaceLength === $ secondNamespaceLength ) { $ sortResult = strcasecmp ( $ firstNamespace , $ secondNamespace ) ; } else { $ sortResult = $ firstNamespaceLength > $ secondNamespaceLength ? 1 : - 1 ; } return $ sortResult ; }
1039	private static function printPath ( ? array $ path = null ) { $ pathStr = '' ; $ currentPath = $ path ; while ( $ currentPath ) { $ pathStr = ( is_string ( $ currentPath [ 'key' ] ) ? '.' . $ currentPath [ 'key' ] : '[' . $ currentPath [ 'key' ] . ']' ) . $ pathStr ; $ currentPath = $ currentPath [ 'prev' ] ; } return $ pathStr ? 'value' . $ pathStr : '' ; }
11763	public function replace ( $ needle , $ replacement ) : Pipeline { $ stages = [ ] ; $ found = false ; foreach ( $ this -> stages as $ stage ) { if ( $ this -> matches ( $ stage , $ needle ) ) { $ stages [ ] = $ replacement ; $ found = true ; continue ; } $ stages [ ] = $ stage ; } if ( $ found ) { $ pipeline = clone $ this ; $ pipeline -> stages = $ stages ; return $ pipeline ; } unset ( $ stages ) ; return $ this ; }
10091	protected function checkOptionsArray ( $ options ) { if ( isset ( $ options [ 's' ] ) ) { $ options [ 'size' ] = $ options [ 's' ] ; unset ( $ options [ 's' ] ) ; } if ( isset ( $ options [ 'd' ] ) ) { $ options [ 'default' ] = $ options [ 'd' ] ; unset ( $ options [ 'd' ] ) ; } $ allowedOptions = array ( 'algorithm' => true , 'default' => true , 'https' => true , 'size' => true , ) ; foreach ( $ options as $ key => $ value ) { if ( ! isset ( $ allowedOptions [ $ key ] ) ) { throw new InvalidArgumentException ( 'Invalid option in array: ' . $ key ) ; } } return $ options ; }
10389	public static function loadFile ( $ xmlFile ) { if ( ! is_file ( $ xmlFile ) || ! is_readable ( $ xmlFile ) ) { throw new NoSuchFileException ( $ xmlFile ) ; } return self :: parseXml ( $ xmlFile ) ; }
10260	public function getIp ( ) { $ parts = [ ] ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ parts [ ] = $ this -> getInteger ( 0 , 255 ) ; } return join ( '.' , $ parts ) ; }
10954	protected function ifNoneMatch ( Request $ request , Response $ response , string $ etag ) : Response { $ ifNoneMatch = $ request -> getHeaderLine ( 'If-None-Match' ) ; if ( $ ifNoneMatch && $ etag === $ ifNoneMatch ) { return $ response -> withStatus ( 304 , "Not Modified" ) ; } return $ response ; }
156	public function addSelect ( $ columns ) { if ( $ columns instanceof ExpressionInterface ) { $ columns = [ $ columns ] ; } elseif ( ! is_array ( $ columns ) ) { $ columns = preg_split ( '/\s*,\s*/' , trim ( $ columns ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } $ columns = $ this -> getUniqueColumns ( $ columns ) ; if ( $ this -> select === null ) { $ this -> select = $ columns ; } else { $ this -> select = array_merge ( $ this -> select , $ columns ) ; } return $ this ; }
7900	public function upload ( $ file , Closure $ callback = null ) { $ uploadedFile = $ this -> runUpload ( $ file ) ; if ( ! $ uploadedFile ) { return false ; } if ( $ callback ) { $ callback ( $ uploadedFile ) ; } return true ; }
9366	public function divide ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } if ( $ z -> is_zero ) { throw new \ InvalidArgumentException ( 'Cannot divide by zero!' ) ; } $ divisor = pow ( $ z -> re , 2 ) + pow ( $ z -> im , 2 ) ; $ r = ( $ this -> float_r * $ z -> re ) + ( $ this -> float_i * $ z -> im ) ; $ i = ( $ this -> float_i * $ z -> re ) - ( $ this -> float_r * $ z -> im ) ; $ r = $ r / $ divisor ; $ i = $ i / $ divisor ; return new self ( $ r , $ i ) ; }
1777	public static function optionSelected ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' selected' : '' ; }
7656	function AddReplyTo ( $ address , $ name = "" ) { $ cur = count ( $ this -> ReplyTo ) ; $ this -> ReplyTo [ $ cur ] [ 0 ] = trim ( $ address ) ; $ this -> ReplyTo [ $ cur ] [ 1 ] = $ name ; }
10964	public static function getHost ( ) { $ host = null ; if ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_X_FORWARDED_HOST' ] ; } elseif ( isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_HOST' ] ; } elseif ( isset ( $ _SERVER [ 'SERVER_NAME' ] ) ) { $ host = $ _SERVER [ 'SERVER_NAME' ] ; } else { $ host = gethostname ( ) ; } return $ host ; }
4982	public function setOptions ( $ options ) { foreach ( $ options as $ key => $ val ) { $ this -> setOption ( $ key , $ val ) ; } }
12628	public function register ( Application $ app ) { if ( is_null ( $ this -> filename ) ) { throw new \ RuntimeException ( 'You must provide a valid config filename' ) ; } if ( ! file_exists ( $ this -> filename ) ) { throw new \ RuntimeException ( sprintf ( 'Config path \'%s\' is not valid' , $ this -> filename ) ) ; } if ( ! is_readable ( $ this -> filename ) ) { throw new \ RuntimeException ( sprintf ( 'Config path \'%s\' is not readable' , $ this -> filename ) ) ; } $ parser = new YamlParser ( ) ; $ config = $ parser -> parse ( file_get_contents ( $ this -> filename ) ) ; if ( is_array ( $ config ) && ! empty ( $ config ) ) { if ( isset ( $ app [ 'config' ] ) && is_array ( $ app [ 'config' ] ) ) { $ config = array_replace_recursive ( $ app [ 'config' ] , $ config ) ; } $ app [ 'config' ] = $ config ; } }
6058	public function removeFolder ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/folders/' . $ id . '' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
7627	public function createContainerIfNotExists ( $ containerName = '' , $ metadata = array ( ) ) { if ( ! $ this -> containerExists ( $ containerName ) ) { $ this -> createContainer ( $ containerName , $ metadata ) ; } }
1662	public function reply ( $ message ) { if ( is_string ( $ message ) ) { $ this -> messages [ ] = Text :: create ( ) -> text ( $ message ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message ; } } elseif ( $ message instanceof RichMessage ) { if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message -> getFallbackText ( ) ; } $ message -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; $ this -> messages [ ] = $ message ; } elseif ( $ message instanceof Conversation ) { $ this -> messages [ ] = Payload :: create ( $ message -> render ( ) ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; } return $ this ; }
2381	public static function stripRootDir ( $ path ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ length = \ strlen ( $ rootDir ) ; if ( strncmp ( $ path , $ rootDir , $ length ) !== 0 || \ strlen ( $ path ) <= $ length || ( $ path [ $ length ] !== '/' && $ path [ $ length ] !== '\\' ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Path "%s" is not inside the Contao root dir "%s"' , $ path , $ rootDir ) ) ; } return ( string ) substr ( $ path , $ length + 1 ) ; }
1566	public function substituteBindings ( StoreInterface $ store ) : void { $ this -> resourceId = $ this -> getResourceId ( ) ? : false ; $ this -> processId = $ this -> getProcessId ( ) ? : false ; if ( $ this -> resourceId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_RESOURCE_ID , $ store -> findOrFail ( $ this -> getResourceType ( ) , $ this -> resourceId ) ) ; } if ( $ this -> processId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_PROCESS_ID , $ store -> findOrFail ( $ this -> getProcessType ( ) , $ this -> processId ) ) ; } }
4904	protected function createValueOptions ( NodeInterface $ node , $ allowSelectNodes = false , $ isRoot = true ) { $ key = $ isRoot ? $ node -> getValue ( ) : $ node -> getValueWithParents ( ) ; $ name = $ node -> getName ( ) ; if ( $ node -> hasChildren ( ) ) { $ leafOptions = [ ] ; if ( $ allowSelectNodes && ! $ isRoot ) { $ leafOptions [ $ key ] = $ name ; $ key = "$key-group" ; } foreach ( $ node -> getChildren ( ) as $ child ) { $ leafOptions += $ this -> createValueOptions ( $ child , $ allowSelectNodes , false ) ; } $ value = [ 'label' => $ name , 'options' => $ leafOptions ] ; } else { $ value = $ name ; } return [ $ key => $ value ] ; }
4435	public static function fromErrorMessage ( string $ error ) : QlessException { $ area = null ; $ message = $ error ; if ( preg_match ( self :: ERROR_MESSAGE_RE , $ error , $ matches ) > 0 ) { $ area = $ matches [ 'area' ] ; $ message = $ matches [ 'message' ] ; } switch ( true ) { case ( $ area === 'Requeue' && stripos ( $ message , 'does not exist' ) !== false ) : case ( stripos ( $ message , 'Job does not exist' ) !== false ) : return new InvalidJobException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job given out to another worker' ) !== false ) : return new JobLostException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job not currently running' ) !== false ) : default : return new QlessException ( $ message , $ area ) ; } }
12769	public function getDb ( ) { if ( is_null ( $ this -> _db ) ) { if ( ! isset ( $ this -> dbConfig [ 'class' ] ) ) { $ this -> dbConfig [ 'class' ] = 'cascade\components\dataInterface\connectors\db\Connection' ; } $ this -> _db = Yii :: createObject ( $ this -> dbConfig ) ; $ this -> _db -> open ( ) ; } if ( empty ( $ this -> _db ) || ! $ this -> _db -> isActive ) { throw new Exception ( "Unable to connect to foreign database." ) ; } return $ this -> _db ; }
4295	public function alert ( $ message , $ class = 'danger' , $ dismissible = false ) { array ( $ class , $ dismissible ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'message' => null , 'class' => 'danger' , 'dismissible' => false , ) , array ( 'class' , 'dismissible' ) ) ; \ extract ( $ args ) ; $ this -> setLogDest ( 'alerts' ) ; $ this -> appendLog ( 'alert' , array ( $ message ) , $ meta ) ; $ this -> setLogDest ( 'auto' ) ; }
6327	private function getConstraintsSql ( ) { $ sql = '' ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { $ sql .= ',' ; if ( $ constraint instanceof PrimaryKey ) { $ sql .= ( string ) $ constraint ; } elseif ( $ constraint instanceof ForeignKey ) { $ sql .= sprintf ( 'CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s (%s) MATCH SIMPLE ON UPDATE %s ON DELETE %s' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) , $ constraint -> getReferencedTable ( ) -> getQualifiedName ( ) , implode ( ',' , $ constraint -> getReferencedColumns ( ) ) , $ constraint -> getUpdateAction ( ) , $ constraint -> getDeleteAction ( ) ) ; } elseif ( $ constraint instanceof Unique ) { $ sql .= sprintf ( 'CONSTRAINT %s UNIQUE (%s)' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) ) ; } } return rtrim ( $ sql , ',' ) ; }
4076	protected function getMetaModelName ( $ nameOrId ) { return isset ( $ this -> tableMap [ $ nameOrId ] ) ? $ this -> tableMap [ $ nameOrId ] : $ nameOrId ; }
7859	private function registerWorkflowRunnersHook ( ) { $ this -> app -> afterResolving ( function ( WorkflowRunner $ runner , $ app ) { $ runner -> setWorkflow ( $ app [ 'cerbero.workflow' ] ) ; } ) ; }
2863	public function getLogging ( ) { $ logging = array ( ) ; foreach ( $ this -> files as $ logFile ) { $ logging [ $ logFile ] = $ this -> getLoggedContent ( $ logFile ) ; } return $ logging ; }
5853	protected function loadVirtualTca ( ) { $ GLOBALS [ 'TCA' ] [ static :: virtualTable ] = include ( ExtensionManagementUtility :: extPath ( $ this -> extKey ) . 'Configuration/TCA/Module/Options.php' ) ; ExtensionManagementUtility :: addLLrefForTCAdescr ( static :: virtualTable , 'EXT:' . $ this -> extKey . '/Resource/Private/Language/locallang_csh_' . static :: virtualTable . '.xlf' ) ; }
5166	protected function filterUriInstance ( $ uri ) : string { if ( $ uri instanceof UriInterface ) { return ( string ) $ uri ; } if ( is_string ( $ uri ) ) { return ( string ) \ One \ createUriFromString ( $ uri ) ; } return '' ; }
1466	public static function doesRequestHaveBody ( $ request ) { if ( self :: hasHeader ( $ request , 'Transfer-Encoding' ) ) { return true ; } ; if ( 1 > self :: getHeader ( $ request , 'Content-Length' ) ) { return false ; } return true ; }
11920	public function onPageRemoved ( PageCollectionRemovedEvent $ event ) { $ pageName = basename ( $ event -> getFilePath ( ) ) ; $ page = $ this -> pagesParser -> contributor ( $ event -> getUsername ( ) ) -> parse ( ) -> page ( $ pageName ) ; if ( null === $ page ) { return ; } foreach ( $ page [ "seo" ] as $ seo ) { $ permalink = $ seo [ "permalink" ] ; $ this -> permalinkManager -> remove ( $ permalink ) ; } $ this -> permalinkManager -> save ( ) ; }
12351	public function invalidate ( string $ api_session = null ) { if ( empty ( $ api_session ) === false && is_string ( $ api_session ) === true ) { $ session = Model \ Session :: where ( 'code' , $ api_session ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } elseif ( empty ( $ _SESSION [ 'api_session' ] ) === false && is_string ( $ _SESSION [ 'api_session' ] ) === true ) { $ session = Model \ Session :: where ( 'code' , $ _SESSION [ 'api_session' ] ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } elseif ( empty ( $ _GET [ 'api_session' ] ) === false && is_string ( $ _GET [ 'api_session' ] ) === true ) { $ session = Model \ Session :: where ( 'code' , $ _GET [ 'api_session' ] ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } $ this -> details = false ; $ _SESSION [ 'api_session' ] = null ; $ _GET [ 'api_session' ] = null ; }
823	private function getPreviousUnsetCall ( Tokens $ tokens , $ index ) { $ previousUnsetSemicolon = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( null === $ previousUnsetSemicolon ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetSemicolon ] -> equals ( ';' ) ) { return $ previousUnsetSemicolon ; } $ previousUnsetBraceEnd = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetSemicolon ) ; if ( null === $ previousUnsetBraceEnd ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetBraceEnd ] -> equals ( ')' ) ) { return $ previousUnsetBraceEnd ; } $ previousUnsetBraceStart = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ previousUnsetBraceEnd ) ; $ previousUnset = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetBraceStart ) ; if ( null === $ previousUnset ) { return $ index ; } if ( ! $ tokens [ $ previousUnset ] -> isGivenKind ( T_UNSET ) ) { return $ previousUnset ; } return [ $ previousUnset , $ previousUnsetBraceStart , $ previousUnsetBraceEnd , $ previousUnsetSemicolon , ] ; }
2793	public function getCacheDirectory ( ) { if ( ! is_null ( $ this -> cacheDirectory ) ) { return $ this -> cacheDirectory ; } if ( defined ( 'PHP_WINDOWS_VERSION_MAJOR' ) ) { if ( ! getenv ( 'APPDATA' ) ) { throw new RuntimeException ( 'The APPDATA environment variable must be set for humbug.' ) ; } $ home = strtr ( getenv ( 'APPDATA' ) , '\\' , '/' ) . '/Humbug' ; } else { if ( ! getenv ( 'HOME' ) ) { throw new RuntimeException ( 'The HOME environment variable must be set for humbug.' ) ; } $ home = rtrim ( getenv ( 'HOME' ) , '/' ) . '/.humbug' ; } $ cache = $ home . '/cache' ; foreach ( [ $ home , $ cache ] as $ dir ) { if ( ! is_dir ( $ dir ) ) { mkdir ( $ dir , 0777 ) ; } } file_put_contents ( $ home . '/.htaccess' , 'Deny from all' ) ; $ this -> cacheDirectory = $ cache ; return $ cache ; }
3960	public function parseAttribute ( $ strAttributeName , $ strOutputFormat = 'text' , $ objSettings = null ) { return $ this -> internalParseAttribute ( $ this -> getAttribute ( $ strAttributeName ) , $ strOutputFormat , $ objSettings ) ; }
8272	public function validateUsersSection ( & $ config ) { if ( ! isset ( $ config [ "users" ] ) ) { return ; } $ this -> assertArray ( $ config , "users" ) ; foreach ( $ config [ "users" ] as $ username => $ userData ) { $ this -> assertUsername ( $ username , $ config ) ; try { $ this -> validateUserData ( $ userData ) ; } catch ( ConfigurationException $ e ) { $ e -> addBeforeMessage ( "Invalid userdata for $username:" ) ; throw $ e ; } $ lowercaseName = strtolower ( $ username ) ; if ( $ username !== $ lowercaseName ) { if ( ! isset ( $ config [ "users" ] [ $ lowercaseName ] ) ) { $ config [ "users" ] [ $ lowercaseName ] = $ userData ; unset ( $ config [ "users" ] [ $ username ] ) ; } else { throw new ConfigurationException ( "User $username is defined multiple times." ) ; } } } }
3252	public function placeOrder ( $ statusCode = null ) { if ( empty ( $ statusCode ) ) $ statusCode = Config :: get ( 'shop.order_status_placement' ) ; $ order = call_user_func ( Config :: get ( 'shop.order' ) . '::create' , [ 'user_id' => $ this -> user_id , 'statusCode' => $ statusCode ] ) ; for ( $ i = count ( $ this -> items ) - 1 ; $ i >= 0 ; -- $ i ) { $ this -> items [ $ i ] -> order_id = $ order -> id ; $ this -> items [ $ i ] -> cart_id = null ; $ this -> items [ $ i ] -> save ( ) ; } $ this -> resetCalculations ( ) ; return $ order ; }
10308	private function setGlowSize ( $ size ) { if ( $ size !== null ) { $ this -> glowProperties [ 'size' ] = $ this -> getExcelPointsWidth ( $ size ) ; } return $ this ; }
8263	protected function onStateMismatch ( ) { $ this -> logger -> warning ( "OAuth2 response state mismatch: provider: {provider} from {addr}" , array ( "provider" => get_class ( $ this -> provider ) , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] ) ) ; $ this -> session -> remove ( "oauth2state" ) ; $ this -> session -> addFlash ( "error" , "Invalid OAuth response." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
203	protected function createQuery ( $ targetClass , $ condition ) { $ query = $ targetClass :: find ( ) -> andWhere ( $ condition ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ query ) ; } elseif ( $ this -> filter !== null ) { $ query -> andWhere ( $ this -> filter ) ; } return $ query ; }
11312	public static function buildAuthString ( array $ data ) { $ str = array ( ) ; foreach ( $ data as $ k => $ v ) { $ str [ ] = self :: urlEncode ( $ k ) . '="' . self :: urlEncode ( $ v ) . '"' ; } return implode ( ', ' , $ str ) ; }
10764	public function generateText ( ) { $ result = 'SPD' . self :: DELIMITER . $ this -> version . self :: DELIMITER . $ this -> implodeContent ( ) ; if ( $ this -> appendCRC32 ) { $ result .= self :: DELIMITER . 'CRC32:' . sprintf ( '%x' , crc32 ( $ result ) ) ; } return $ result ; }
11591	private function upload ( $ path , $ payload ) { return Storage :: disk ( 's3' ) -> put ( $ path , $ payload , $ this -> visibility ) ; }
6159	public function createUrl ( $ action , $ model , $ key , $ index ) { if ( $ this -> urlCreator instanceof Closure ) { return call_user_func ( $ this -> urlCreator , $ action , $ model , $ key , $ index ) ; } else { $ params [ 0 ] = $ this -> controller ? $ this -> controller . '/' . $ action : $ action ; return Url :: toRoute ( $ params ) ; } }
9070	protected static function parseEachPart ( array $ parts , $ format ) { $ lastPartKey = count ( $ parts ) - 1 ; for ( $ p = 0 ; $ p <= $ lastPartKey ; $ p ++ ) { $ parsedPart = static :: parse ( $ parts [ $ p ] , $ format ) ; $ numNewParts = count ( $ parsedPart ) ; if ( $ numNewParts > 1 ) { array_splice ( $ parts , $ p , 1 , $ parsedPart ) ; $ p += $ numNewParts ; $ lastPartKey += $ numNewParts - 1 ; } } return $ parts ; }
1568	public function getResourceId ( ) : ? string { if ( is_null ( $ this -> resourceId ) ) { return $ this -> parameter ( ResourceRegistrar :: PARAM_RESOURCE_ID ) ; } return $ this -> resourceId ? : null ; }
12149	public function getReservedCodes ( ) { $ reserved = [ ] ; foreach ( $ this -> factories as $ factoryClass => $ factory ) { $ reserved [ $ factoryClass ] = $ factory -> getReservedDiapason ( ) ; } return $ reserved ; }
9189	public function present ( ) { $ presenterClass = $ this -> getPresenterClass ( ) ; if ( ! class_exists ( $ presenterClass ) ) { throw new Exceptions \ PresenterException ( 'The specified presenter does not exist.' ) ; } if ( ! $ this -> presenterInstance ) { $ this -> presenterInstance = new $ presenterClass ( $ this ) ; } return $ this -> presenterInstance ; }
5735	public function getMatchesForTeam ( int $ teamID , array $ filter = [ 'dateFrom' => '' , 'dateTo' => '' , 'status' => '' , 'venue' => '' ] ) { $ matches = $ this -> run ( "v2/teams/{$teamID}/matches" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ matches -> matches ) ; }
4291	private function publishMeta ( ) { $ debugClass = \ get_class ( $ this -> debug ) ; $ metaVals = array ( 'debug_version' => $ debugClass :: VERSION , ) ; $ keys = array ( 'HTTP_HOST' , 'HTTPS' , 'REMOTE_ADDR' , 'REQUEST_METHOD' , 'REQUEST_TIME' , 'REQUEST_URI' , 'SERVER_ADDR' , 'SERVER_NAME' , ) ; foreach ( $ keys as $ k ) { $ metaVals [ $ k ] = isset ( $ _SERVER [ $ k ] ) ? $ _SERVER [ $ k ] : null ; } if ( ! isset ( $ metaVals [ 'REQUEST_URI' ] ) && ! empty ( $ _SERVER [ 'argv' ] ) ) { $ metaVals [ 'REQUEST_URI' ] = '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; } $ this -> processLogEntry ( 'meta' , array ( $ metaVals , ) , array ( 'channel' => $ this -> debug -> getCfg ( 'channel' ) , ) ) ; }
12349	public function getTaxonomy ( $ system_id ) { foreach ( $ this -> getTaxonomies ( ) as $ taxonomy ) { if ( $ taxonomy -> system_id === $ system_id ) { return $ taxonomy ; } } return false ; }
12125	public function getAliasIdForLanguage ( $ language ) { foreach ( $ this -> aliases as $ key => $ alias ) { if ( $ alias -> getLanguage ( ) == $ language ) { return $ key ; } } return null ; }
6939	private function push ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( ! $ this -> has ( $ list , $ oid , $ unit ) ) { $ list [ $ oid ] [ ] = $ unit ; } }
10981	public function tree ( $ trans = false ) { $ tree = [ ] ; foreach ( $ this -> items as $ date => $ log ) { $ tree [ $ date ] = $ log -> tree ( $ trans ) ; } return $ tree ; }
5362	public function createContext ( Registry $ registry , $ name ) { $ schemas = array_values ( $ registry -> getSchemas ( ) ) ; foreach ( $ schemas as $ schema ) { $ openApiSpec = $ this -> schemaParser -> parseSchema ( $ schema -> getOrigin ( ) ) ; $ this -> chainGuesser -> guessClass ( $ openApiSpec , $ schema -> getRootName ( ) , $ schema -> getOrigin ( ) . '#' , $ registry ) ; $ schema -> setParsed ( $ openApiSpec ) ; } foreach ( $ registry -> getSchemas ( ) as $ schema ) { foreach ( $ schema -> getClasses ( ) as $ class ) { $ properties = $ this -> chainGuesser -> guessProperties ( $ class -> getObject ( ) , $ schema -> getRootName ( ) , $ class -> getReference ( ) , $ registry ) ; foreach ( $ properties as $ property ) { $ property -> setType ( $ this -> chainGuesser -> guessType ( $ property -> getObject ( ) , $ property -> getName ( ) , $ property -> getReference ( ) , $ registry ) ) ; } $ class -> setProperties ( $ properties ) ; } } return new Context ( $ registry ) ; }
6945	protected function watch ( OrderPaymentInterface $ payment ) { $ order = $ payment -> getOrder ( ) ; if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( ! $ payment -> getMethod ( ) -> isManual ( ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ payment , PaymentStates :: STATE_CAPTURED ) ) { return ; } foreach ( $ order -> getNotifications ( ) as $ n ) { if ( $ n -> getType ( ) !== NotificationTypes :: PAYMENT_CAPTURED ) { continue ; } if ( $ n -> hasData ( 'payment' ) && $ n -> getData ( 'payment' ) === $ payment -> getNumber ( ) ) { return ; } } $ this -> notify ( NotificationTypes :: PAYMENT_CAPTURED , $ payment ) ; }
2191	public function registerAlias ( Model $ objModel , $ strAlias , $ varValue ) { $ strTable = $ objModel -> getTable ( ) ; $ strPk = $ objModel -> getPk ( ) ; $ varPk = $ objModel -> $ strPk ; if ( isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ) { throw new \ RuntimeException ( "The registry already contains an alias for $strTable::$strPk($varPk) ($strAlias/$varValue)" ) ; } $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] = $ varPk ; }
129	protected function requestContent ( $ origin , $ path ) { $ url = rtrim ( $ origin , '/' ) . '/' . ltrim ( $ path , '/' ) ; $ content = $ this -> rfs -> getContents ( $ origin , $ url , false ) ; if ( ! $ content ) { throw new \ UnexpectedValueException ( 'The PEAR channel at ' . $ url . ' did not respond.' ) ; } return str_replace ( 'http://pear.php.net/rest/' , 'https://pear.php.net/rest/' , $ content ) ; }
12359	public static function decodeHashId ( $ idHashed ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ idHashed ; } $ hashids = App :: make ( 'Hashids' ) ; $ hashId = $ hashids -> decode ( $ idHashed ) ; return ( count ( $ hashId ) > 0 ) ? $ hashId [ 0 ] : '' ; }
506	public function getMessageFormatter ( ) { if ( $ this -> _messageFormatter === null ) { $ this -> _messageFormatter = new MessageFormatter ( ) ; } elseif ( is_array ( $ this -> _messageFormatter ) || is_string ( $ this -> _messageFormatter ) ) { $ this -> _messageFormatter = Yii :: createObject ( $ this -> _messageFormatter ) ; } return $ this -> _messageFormatter ; }
2575	protected function loadRequestCreatorParams ( $ params ) { if ( isset ( $ params [ 'requestCreatorParams' ] ) ) { if ( $ params [ 'requestCreatorParams' ] instanceof RequestCreatorParams ) { $ this -> requestCreatorParams = $ params [ 'requestCreatorParams' ] ; } elseif ( is_array ( $ params [ 'requestCreatorParams' ] ) ) { $ this -> requestCreatorParams = new RequestCreatorParams ( $ params [ 'requestCreatorParams' ] ) ; } } }
6238	public function write ( string $ content , bool $ append = false , int $ mode = LOCK_EX ) : self { $ this -> checkFileWritePermissions ( ) ; if ( ! $ this -> storage -> writeFile ( $ content , $ append , $ mode ) ) { throw new AccessDeniedException ( 'unable to write file-content' , 403 ) ; } return $ this ; }
8285	protected function sessionTimeoutCheck ( $ configKey , $ sessKey , $ clear , $ alwaysUpdate = false ) { if ( $ this -> config [ $ configKey ] !== false ) { $ t = time ( ) ; if ( $ this -> session -> has ( $ sessKey ) ) { if ( $ this -> session -> get ( $ sessKey ) < $ t - $ this -> config [ $ configKey ] ) { if ( $ clear ) { $ this -> session -> invalidate ( ) ; } else { $ this -> session -> migrate ( true ) ; } $ this -> session -> set ( $ sessKey , $ t ) ; } elseif ( $ alwaysUpdate ) { $ this -> session -> set ( $ sessKey , $ t ) ; } } else { $ this -> session -> set ( $ sessKey , $ t ) ; } } }
8639	public function setDirectPaymentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DirectPaymentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1139	public function shiftSiblingsForRestore ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> increment ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>=' , $ lft ) -> increment ( $ rgtCol , $ diff ) ; } ) ; }
12415	public static function init ( $ options = array ( ) ) { Flight :: map ( "render" , function ( $ template , $ data , $ toVar = false ) { Flight :: view ( ) -> render ( $ template , $ data , $ toVar ) ; } ) ; Flight :: register ( 'view' , get_called_class ( ) , $ options ) ; }
5976	public function media ( ) { if ( ! $ this -> media instanceof MediaController ) { $ this -> media = new MediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> media -> setLogger ( $ this -> logger ) ; } return $ this -> media ; }
1204	protected function renderChildren ( ItemInterface $ item , array $ options ) { if ( null !== $ options [ 'depth' ] ) { $ options [ 'depth' ] = $ options [ 'depth' ] - 1 ; } if ( null !== $ options [ 'matchingDepth' ] && $ options [ 'matchingDepth' ] > 0 ) { $ options [ 'matchingDepth' ] = $ options [ 'matchingDepth' ] - 1 ; } $ html = '' ; foreach ( $ item -> getChildren ( ) as $ child ) { $ html .= $ this -> renderItem ( $ child , $ options ) ; } return $ html ; }
2809	public function getVisiblePanels ( ) { if ( $ this -> visiblePanels === null ) { $ this -> visiblePanels = array ( ) ; $ panels = $ this -> getSortedChildBlocks ( ) ; foreach ( $ panels as $ panel ) { if ( ! $ panel instanceof Sheep_Debug_Block_Panel ) { continue ; } $ this -> visiblePanels [ ] = $ panel ; } } return $ this -> visiblePanels ; }
12542	public function get ( ) : \ TheCMSThread \ Core \ Main \ View { if ( $ this -> getLink ( ) == '/' ) { $ this -> details = Model \ Page :: find ( 1 ) ; } else { $ this -> details = Model \ Page :: where ( 'link' , $ this -> getLink ( ) ) ; if ( $ this -> auth -> allow ( [ "min" => 3 , "max" => 1 ] ) === false ) { $ this -> details -> where ( 'status' , true ) ; } $ this -> details = $ this -> details -> first ( ) ; } if ( $ this -> details === null ) { $ this -> details = false ; } return $ this ; }
11004	public function getPath ( $ url ) { $ url = new URL ( $ url ) ; $ to_replace = $ this -> url -> path ; $ path = $ url -> path ; if ( strpos ( $ path , $ to_replace ) === 0 ) $ path = substr ( $ path , strlen ( $ to_replace ) ) ; $ path = '/' . urldecode ( $ path ) ; return $ path ; }
2571	public static function isValidFopType ( $ fopType ) { return ( $ fopType == self :: IDENT_CASH || $ fopType == self :: IDENT_CHECK || $ fopType == self :: IDENT_CREDITCARD || $ fopType == self :: IDENT_MISC ) ; }
6741	public function to ( $ target ) { if ( is_null ( $ this -> request ) ) { throw new \ LogicException ( 'Missing request instance.' ) ; } $ target = new Uri ( $ target ) ; $ uri = $ this -> request -> getUri ( ) -> withScheme ( $ target -> getScheme ( ) ) -> withHost ( $ target -> getHost ( ) ) ; if ( $ port = $ target -> getPort ( ) ) { $ uri = $ uri -> withPort ( $ port ) ; } if ( $ path = $ target -> getPath ( ) ) { $ uri = $ uri -> withPath ( rtrim ( $ path , '/' ) . '/' . ltrim ( $ uri -> getPath ( ) , '/' ) ) ; } if ( ! empty ( $ this -> request -> getQueryParams ( ) ) ) { $ queryParams = $ this -> request -> getQueryParams ( ) ; if ( count ( $ queryParams ) == 1 && empty ( array_shift ( $ queryParams ) ) ) { $ queryKeys = array_keys ( $ this -> request -> getQueryParams ( ) ) ; $ uri = $ uri -> withQuery ( $ queryKeys [ 0 ] ) ; } else { $ uri = $ uri -> withQuery ( http_build_query ( $ this -> request -> getQueryParams ( ) ) ) ; } } $ request = $ this -> request -> withUri ( $ uri ) ; foreach ( $ request -> getHeaders ( ) as $ headerName => $ headerValue ) { if ( empty ( $ headerValue [ 0 ] ) ) { $ request = $ request -> withoutHeader ( $ headerName ) ; } } return $ this -> client -> send ( $ request ) ; }
7581	protected function verifyData ( ) { if ( isset ( $ this -> _DATA_TYPE ) || ! empty ( $ this -> _DATA_TYPE ) ) { $ this -> verifyDataType ( ) ; } if ( ! empty ( $ this -> _REQUIRED_DATA ) ) { $ this -> verifyRequiredData ( ) ; } return true ; }
5205	public function isActiveMatch ( $ string , $ output = "active" ) { if ( strpos ( $ this -> url -> current ( ) , $ string ) !== false ) { return $ output ; } return null ; }
7005	private function format_d ( & $ str ) { if ( strstr ( $ str , '%d' ) ) $ str = str_replace ( '%d' , sprintf ( '%02d' , $ this -> day ) , $ str ) ; }
12207	public function refresh ( ) { if ( null === $ this -> options || null === $ this -> sourceDir ) { return ; } $ this -> render ( $ this -> sourceDir , $ this -> options , $ this -> username ) ; }
8250	protected function passwordRehash ( $ username , Password $ password ) { $ userData = $ this -> storage -> getUserByName ( $ username ) ; try { $ this -> userDataEncodePassword ( $ userData , $ password ) ; } catch ( \ PicoAuth \ Security \ Password \ Encoder \ EncoderException $ e ) { $ this -> session -> addFlash ( "error" , "Please set a new password." ) ; $ this -> picoAuth -> getContainer ( ) -> get ( 'PasswordReset' ) -> startPasswordResetSession ( $ username ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ this -> storage -> saveUser ( $ username , $ userData ) ; }
8038	public function find ( $ identifier , array $ fields = [ ] ) { $ results = $ this -> ldap -> search ( $ this -> base_dn , $ this -> search_filter . '=' . $ identifier , ( $ fields ? : $ this -> search_fields ) ) ; if ( count ( $ results ) > 0 ) { $ entry = $ this -> ldap -> entry ( $ results ) ; if ( isset ( $ entry [ 0 ] ) && ! empty ( $ entry [ 0 ] ) ) { return $ entry [ 0 ] ; } } throw new EmptySearchResultException ; }
9186	protected function mergeParams ( & $ data , $ params ) { foreach ( $ params as $ paramName => $ paramValue ) { if ( is_array ( $ paramValue ) ) { foreach ( $ paramValue as $ key => $ value ) { foreach ( $ value as $ name => $ x ) { $ data [ $ paramName ] [ $ key ] [ $ name ] = $ x ; } } } else { $ data [ $ paramName ] = $ paramValue ; } } }
9564	protected function makeFatalErrorException ( ) { $ error = error_get_last ( ) ; if ( $ error !== null ) { return new FatalErrorException ( $ error [ 'message' ] , $ error [ 'type' ] , 0 , $ error [ 'file' ] , $ error [ 'line' ] ) ; } return null ; }
7570	public function getApplicationApiService ( ) { $ applicationService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ ApplicationService ( $ this -> _apiKey , $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: APPLICATION_URL ) ) ; $ applicationService -> setClient ( $ apiClient ) ; return $ applicationService ; }
3774	public function getTypeNames ( ) { $ names = $ this -> factories -> ids ( ) ; if ( [ ] !== $ fallback = $ this -> fallbackFactory -> getIds ( ) ) { $ names = array_unique ( array_merge ( $ fallback , $ names ) ) ; } return $ names ; }
9815	public function setWorksheet ( Worksheet $ value = null ) { if ( $ value !== null ) { $ this -> worksheet = $ value ; } return $ this ; }
5159	private static function createGallery ( String $ body , int $ order , String $ photo , String $ source , string $ lead ) : \ One \ Model \ Gallery { return new Gallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
12610	public function getParents ( ) { $ parents = [ ] ; foreach ( $ this -> _parents as $ key => $ parent ) { if ( ! $ parent -> active ) { continue ; } $ parents [ $ key ] = $ parent ; } return $ parents ; }
9605	public function vectorTripleProduct ( self $ b , self $ c ) { return $ this -> crossProduct ( $ b -> crossProduct ( $ c ) ) ; }
242	public function run ( ) { $ rows = [ ] ; $ i = 0 ; foreach ( $ this -> attributes as $ attribute ) { $ rows [ ] = $ this -> renderAttribute ( $ attribute , $ i ++ ) ; } $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'table' ) ; echo Html :: tag ( $ tag , implode ( "\n" , $ rows ) , $ options ) ; }
7175	public static function set_path ( & $ array , $ path , $ value , $ delimiter = null ) : void { if ( ! $ delimiter ) { $ delimiter = static :: $ delimiter ; } $ keys = $ path ; if ( ! is_array ( $ path ) ) { $ keys = explode ( $ delimiter , $ path ) ; } while ( count ( $ keys ) > 1 ) { $ key = array_shift ( $ keys ) ; if ( is_string ( $ key ) && ctype_digit ( $ key ) ) { $ key = ( int ) $ key ; } if ( ! isset ( $ array [ $ key ] ) ) { $ array [ $ key ] = array ( ) ; } $ array = & $ array [ $ key ] ; } $ array [ array_shift ( $ keys ) ] = $ value ; }
1298	public function getReferences ( Query $ query = null ) : ResourceArray { $ query = $ query ? : new Query ( ) ; $ query -> linksToEntry ( $ this -> getId ( ) ) ; return $ this -> client -> getEntries ( $ query ) ; }
12183	public static function getOne ( Item $ parent , Item $ child , $ options = [ ] ) { $ key = md5 ( $ parent -> systemId . "." . $ child -> systemId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { self :: $ _relationships [ $ key ] -> mergeOptions ( $ options ) ; } else { self :: $ _relationships [ $ key ] = new Relationship ( $ parent , $ child , $ options ) ; } return self :: $ _relationships [ $ key ] ; }
1556	protected function queryRulesWithoutSearch ( ) { return collect ( $ this -> queryRules ( ) ) -> reject ( function ( $ value , $ key ) { return Str :: startsWith ( $ key , [ 'filter.' , 'sort.' , 'page.' ] ) ; } ) -> all ( ) ; }
3828	protected function addUrlParameter ( $ url , $ name , $ value ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ value = str_replace ( '%' , '%%' , urlencode ( $ value ) ) ; if ( empty ( $ value ) ) { return $ url ; } if ( $ name !== 'auto_item' ) { $ url .= '/' . $ name . '/' . $ value ; } else { $ url = '/' . $ value . $ url ; } return $ url ; }
12335	public function editProfileAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'edit-profile' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getEditProfileForm ( ) ; $ identity = $ this -> cmsAuthentication ( ) -> getIdentity ( ) ; $ form -> bind ( $ identity ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ result = $ this -> getUserService ( ) -> editProfile ( $ identity ) ; if ( $ result instanceof ResponseInterface ) { return $ result ; } elseif ( $ result ) { $ fm = $ this -> flashMessenger ( ) ; $ fm -> setNamespace ( $ form -> getName ( ) . '-' . $ fm :: NAMESPACE_SUCCESS ) -> addMessage ( $ this -> translate ( 'Data has been successfully saved' ) ) ; } } return new ViewModel ( compact ( 'form' ) ) ; }
4572	public function setIdentityUuid ( ? string $ identityUuid ) { if ( null !== $ identityUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ identityUuid ) ) { throw new InvalidArgumentException ( 'Identity uuid is not valid.' ) ; } } $ this -> identityUuid = $ identityUuid ; return $ this ; }
11015	public static function sec2time ( $ seconds ) { $ sec = intval ( $ seconds ) ; $ dtF = new \ DateTime ( "@0" ) ; $ dtT = new \ DateTime ( "@$sec" ) ; return $ dtF -> diff ( $ dtT ) -> format ( '%a days, %h hours, %i minutes and %s seconds' ) ; }
907	private function findClassyElements ( $ index ) { $ elements = [ ] ; $ curlyBracesLevel = 0 ; $ bracesLevel = 0 ; $ classIndex = $ index ; ++ $ index ; for ( $ count = \ count ( $ this -> tokens ) ; $ index < $ count ; ++ $ index ) { $ token = $ this -> tokens [ $ index ] ; if ( $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) ) { continue ; } if ( $ token -> isClassy ( ) ) { list ( $ index , $ newElements ) = $ this -> findClassyElements ( $ index ) ; $ elements += $ newElements ; continue ; } if ( $ token -> equals ( '(' ) ) { ++ $ bracesLevel ; continue ; } if ( $ token -> equals ( ')' ) ) { -- $ bracesLevel ; continue ; } if ( $ token -> equals ( '{' ) ) { ++ $ curlyBracesLevel ; continue ; } if ( $ token -> equals ( '}' ) ) { -- $ curlyBracesLevel ; if ( 0 === $ curlyBracesLevel ) { break ; } continue ; } if ( 1 !== $ curlyBracesLevel || ! $ token -> isArray ( ) ) { continue ; } if ( 0 === $ bracesLevel && $ token -> isGivenKind ( T_VARIABLE ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'property' , 'classIndex' => $ classIndex , ] ; continue ; } if ( $ token -> isGivenKind ( T_FUNCTION ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'method' , 'classIndex' => $ classIndex , ] ; } elseif ( $ token -> isGivenKind ( T_CONST ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'const' , 'classIndex' => $ classIndex , ] ; } } return [ $ index , $ elements ] ; }
5545	public function getText ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getText ( ) ; } $ raw = '' ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ raw .= ' ' . $ this -> frames [ $ i ] -> getText ( ) ; } return trim ( $ raw ) ; }
11586	public function start ( $ taskName , $ repeat = null ) { $ task = new Task ( ) ; $ task -> name ( $ taskName ) ; if ( $ repeat ) { $ task -> repeat ( $ repeat ) ; } if ( isset ( $ this -> _tasks [ $ taskName ] ) ) { throw new Exception ( "Task {$taskName} is already defined." ) ; } $ this -> _tasks [ $ taskName ] = $ task ; $ task -> start ( ) ; return $ task ; }
9996	protected function checkSeparator ( ) { $ line = fgets ( $ this -> fileHandle ) ; if ( $ line === false ) { return ; } if ( ( strlen ( trim ( $ line , "\r\n" ) ) == 5 ) && ( stripos ( $ line , 'sep=' ) === 0 ) ) { $ this -> delimiter = substr ( $ line , 4 , 1 ) ; return ; } return $ this -> skipBOM ( ) ; }
2333	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> tokenChecker -> hasBackendUser ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( $ this -> requestAttribute , true ) ; }
693	public function compose ( $ view = null , array $ params = [ ] ) { $ message = $ this -> createMessage ( ) ; if ( $ view === null ) { return $ message ; } if ( ! array_key_exists ( 'message' , $ params ) ) { $ params [ 'message' ] = $ message ; } $ this -> _message = $ message ; if ( is_array ( $ view ) ) { if ( isset ( $ view [ 'html' ] ) ) { $ html = $ this -> render ( $ view [ 'html' ] , $ params , $ this -> htmlLayout ) ; } if ( isset ( $ view [ 'text' ] ) ) { $ text = $ this -> render ( $ view [ 'text' ] , $ params , $ this -> textLayout ) ; } } else { $ html = $ this -> render ( $ view , $ params , $ this -> htmlLayout ) ; } $ this -> _message = null ; if ( isset ( $ html ) ) { $ message -> setHtmlBody ( $ html ) ; } if ( isset ( $ text ) ) { $ message -> setTextBody ( $ text ) ; } elseif ( isset ( $ html ) ) { if ( preg_match ( '~<body[^>]*>(.*?)</body>~is' , $ html , $ match ) ) { $ html = $ match [ 1 ] ; } $ html = preg_replace ( '~<((style|script))[^>]*>(.*?)</\1>~is' , '' , $ html ) ; $ text = html_entity_decode ( strip_tags ( $ html ) , ENT_QUOTES | ENT_HTML5 , Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ) ; $ text = preg_replace ( "~^[ \t]+~m" , '' , trim ( $ text ) ) ; $ text = preg_replace ( '~\R\R+~mu' , "\n\n" , $ text ) ; $ message -> setTextBody ( $ text ) ; } return $ message ; }
530	public function actionSortChangelog ( array $ what ) { if ( \ count ( $ what ) > 1 ) { $ this -> stdout ( "Currently only one simultaneous release is supported.\n" ) ; return 1 ; } $ this -> validateWhat ( $ what , [ 'framework' , 'ext' ] , false ) ; $ version = $ this -> version ? : array_values ( $ this -> getNextVersions ( $ this -> getCurrentVersions ( $ what ) , self :: PATCH ) ) [ 0 ] ; $ this -> stdout ( 'sorting CHANGELOG of ' ) ; $ this -> stdout ( reset ( $ what ) , Console :: BOLD ) ; $ this -> stdout ( ' for version ' ) ; $ this -> stdout ( $ version , Console :: BOLD ) ; $ this -> stdout ( '...' ) ; $ this -> resortChangelogs ( $ what , $ version ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; }
11139	protected function getSetItem ( $ dataMember , $ offset , $ quote = true ) { $ item = $ this -> { $ dataMember } [ $ offset ] ; switch ( $ item [ 1 ] ) { case 'varchar' : $ type = 'varchar(255)' ; break ; default : $ type = $ item [ 1 ] ; } $ this -> { $ dataMember } [ $ offset ] [ 1 ] = $ type ; return $ this -> getArrayItem ( $ dataMember , $ offset , $ quote ) ; }
5461	protected function acceptPageEnd ( ) { while ( count ( $ this -> open_forms ) ) { $ this -> complete_forms [ ] = array_pop ( $ this -> open_forms ) ; } foreach ( $ this -> left_over_labels as $ label ) { for ( $ i = 0 , $ count = count ( $ this -> complete_forms ) ; $ i < $ count ; $ i ++ ) { $ this -> complete_forms [ $ i ] -> attachLabelBySelector ( new SelectById ( $ label -> getFor ( ) ) , $ label -> getText ( ) ) ; } } $ this -> page -> setForms ( $ this -> complete_forms ) ; $ this -> page -> setFrames ( $ this -> loading_frames ) ; }
2788	public static function getMutation ( array & $ tokens , $ index ) { $ num = ( integer ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1 ; } elseif ( $ num == 1 ) { $ replace = 0 ; } else { $ replace = $ num + 1 ; } $ tokens [ $ index ] = [ T_LNUMBER , ( string ) $ replace ] ; }
10149	private function readPrintGridlines ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( $ this -> version == self :: XLS_BIFF8 && ! $ this -> readDataOnly ) { $ printGridlines = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> setPrintGridlines ( $ printGridlines ) ; } }
6097	protected function get ( $ endpoint , array $ parameters = [ ] , CachePolicy $ cachePolicy = null , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_GET , $ cachePolicy , $ fireAndForget ) ; }
3689	public function createButton ( GetOperationButtonEvent $ event ) { if ( 'createvariant' !== $ event -> getCommand ( ) -> getName ( ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metamodel = $ model -> getItem ( ) -> getMetaModel ( ) ; if ( ! $ metamodel -> hasVariants ( ) || $ model -> getProperty ( 'varbase' ) === '0' ) { $ event -> setHtml ( '' ) ; } }
12354	public function setFilePath ( string $ viewFilePath ) : void { if ( ! is_readable ( $ viewFilePath ) ) { throw new Exception ( "The View file {$viewFilePath} isn't readable." ) ; } $ this -> filePath = $ viewFilePath ; }
6136	public function folderSearch ( FolderSearch $ search ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/search/folder' , $ parameters ) ; $ result = new SearchResult ( $ result ) ; return $ result ; }
771	public function actionConfig ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; $ dir = dirname ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } $ array = VarDumper :: export ( $ this -> getOptionValues ( $ this -> action -> id ) ) ; $ content = <<<EOD<?php/** * Configuration file for 'yii {$this->id}/{$this->defaultAction}' command. * * This file is automatically generated by 'yii {$this->id}/{$this->action->id}' command. * It contains parameters for source code messages extraction. * You may modify this file to suit your needs. * * You can use 'yii {$this->id}/{$this->action->id}-template' command to create * template configuration file with detailed description for each parameter. */return $array;EOD ; if ( FileHelper :: createDirectory ( $ dir ) === false || file_put_contents ( $ filePath , $ content , LOCK_EX ) === false ) { $ this -> stdout ( "Configuration file was NOT created: '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file created: '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; }
9018	public function getActionWords ( $ string , $ language = 'english' ) { $ words = $ this -> getWords ( $ string ) ; $ filter = new ActionWordsFilter ( $ language ) ; $ actionWords = [ ] ; foreach ( $ words as $ word ) { $ word = $ this -> removePunctuation ( $ word ) ; if ( ! is_null ( $ filter -> filter ( $ word ) ) ) { $ actionWords [ ] = $ word ; } } return $ actionWords ; }
7646	protected function getFileName ( $ path ) { $ url = parse_url ( $ path ) ; if ( $ url [ 'host' ] ) { $ fileName = isset ( $ url [ 'path' ] ) ? $ url [ 'path' ] : $ url [ 'host' ] ; if ( strpos ( $ fileName , '/' ) === 0 ) { $ fileName = substr ( $ fileName , 1 ) ; } return $ fileName ; } return '' ; }
1392	public function isJsonApi ( $ request , Exception $ e ) { if ( Helpers :: wantsJsonApi ( $ request ) ) { return true ; } $ route = app ( JsonApiService :: class ) -> currentRoute ( ) ; return $ route -> hasCodec ( ) && $ route -> getCodec ( ) -> willEncode ( ) ; }
706	public function primaryKey ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_PK , $ length ) ; }
7348	protected function watch ( OrderShipmentInterface $ shipment ) { $ order = $ shipment -> getOrder ( ) ; if ( ! $ order -> isAutoNotify ( ) ) { return ; } if ( $ shipment -> isReturn ( ) ) { if ( $ shipment -> getState ( ) === ShipmentStates :: STATE_PENDING ) { if ( ! $ this -> didStateChangeTo ( $ shipment , ShipmentStates :: STATE_PENDING ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: RETURN_PENDING , $ shipment -> getNumber ( ) ) ) { return ; } $ this -> notify ( NotificationTypes :: RETURN_PENDING , $ shipment ) ; return ; } if ( $ shipment -> getState ( ) === ShipmentStates :: STATE_RETURNED ) { if ( ! $ this -> didStateChangeTo ( $ shipment , ShipmentStates :: STATE_RETURNED ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: RETURN_RECEIVED , $ shipment -> getNumber ( ) ) ) { return ; } $ this -> notify ( NotificationTypes :: RETURN_RECEIVED , $ shipment ) ; } return ; } if ( ! $ this -> didStateChangeTo ( $ shipment , ShipmentStates :: STATE_SHIPPED ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: SHIPMENT_SHIPPED , $ shipment -> getNumber ( ) ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: SHIPMENT_SHIPPED , $ shipment -> getNumber ( ) ) ) { return ; } $ type = NotificationTypes :: SHIPMENT_SHIPPED ; if ( $ order -> getShipmentState ( ) !== ShipmentStates :: STATE_COMPLETED ) { $ type = NotificationTypes :: SHIPMENT_PARTIAL ; } $ this -> notify ( $ type , $ shipment ) ; }
9528	private function parseSingle ( & $ i , $ parameter , & $ results ) { if ( $ this -> prefixExists ( $ parameter ) ) { $ closure = $ this -> getClosure ( $ parameter ) ; if ( $ closure != null ) { $ prefix = $ this -> getPrefix ( $ parameter ) ; $ closure_arguments = [ ] ; $ rFunction = new ReflectionFunction ( $ closure ) ; if ( $ rFunction -> isVariadic ( ) ) { $ this -> parseVariadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter ) ; } else { $ this -> parseUniadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter , $ rFunction ) ; } $ result_key = $ this -> getRealName ( $ parameter ) ; $ result = $ results [ $ result_key ] ; if ( ! $ result instanceof ParameterResult ) { if ( $ result == self :: HALT_PARSE ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; unset ( $ results [ $ result_key ] ) ; return false ; } } else { if ( $ result -> shouldHalt ( ) ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; if ( $ result -> isHaltOnly ( ) ) { unset ( $ results [ $ result_key ] ) ; } else { $ results [ $ result_key ] = $ result -> getValue ( ) ; } return false ; } } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } return true ; }
2461	private function canonicalize ( string $ value ) : string { $ resolved = [ ] ; $ chunks = preg_split ( '#([\\\\/]+)#' , $ value , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; for ( $ i = 0 , $ c = \ count ( $ chunks ) ; $ i < $ c ; ++ $ i ) { if ( '.' === $ chunks [ $ i ] ) { ++ $ i ; continue ; } if ( '/' === $ chunks [ $ i ] [ 0 ] ) { $ resolved [ ] = '/' ; continue ; } if ( '\\' === $ chunks [ $ i ] [ 0 ] ) { $ resolved [ ] = '\\' ; continue ; } if ( '..' === $ chunks [ $ i ] ) { ++ $ i ; array_pop ( $ resolved ) ; array_pop ( $ resolved ) ; continue ; } $ resolved [ ] = $ chunks [ $ i ] ; } return rtrim ( implode ( '' , $ resolved ) , '\/' ) ; }
3891	public function loadCallback ( string $ value = null ) { return null === $ value ? null : trim ( \ base64_encode ( $ value ) , '=' ) ; }
6919	public function getAdjustments ( $ type = null ) { if ( null !== $ type ) { AdjustmentTypes :: isValidType ( $ type ) ; return $ this -> adjustments -> filter ( function ( AdjustmentInterface $ a ) use ( $ type ) { return $ a -> getType ( ) === $ type ; } ) ; } return $ this -> adjustments ; }
6943	protected function localizedDayOfWeek ( $ dayOfWeek ) { if ( class_exists ( '\IntlDateFormatter' ) ) { $ date = new \ DateTime ( '2017-01-01' ) ; $ date -> modify ( '+' . $ dayOfWeek . ' days' ) ; $ formatter = \ IntlDateFormatter :: create ( $ this -> localeProvider -> getCurrentLocale ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , $ date -> getTimezone ( ) , null , 'eeee' ) ; return $ formatter -> format ( $ date -> getTimestamp ( ) ) ; } return [ 1 => 'Monday' , 2 => 'Tuesday' , 3 => 'Wednesday' , 4 => 'Thursday' , 5 => 'Friday' , 6 => 'Saturday' , 7 => 'Sunday' , ] [ $ dayOfWeek ] ; }
5101	public function valuesExp ( $ expression , $ bind = false ) { return $ this -> appendPart ( CmdInsert :: PART_VALUES , $ expression , $ bind ) ; }
6947	private function getOutstandingExpiredDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; $ qb -> join ( 'o.paymentTerm' , 't' ) -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ qb -> expr ( ) -> lte ( 'o.outstandingDate' , ':today' ) , $ this -> getDueClauses ( ) ) ) -> addOrderBy ( 'o.outstandingDate' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'today' , ( new \ DateTime ( ) ) -> setTime ( 23 , 59 , 59 ) , Type :: DATETIME ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; $ this -> setDueParameters ( $ qb ) ; return $ qb ; }
3612	public function setTargetTemperatureMode ( $ mode , $ temperature = NULL , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; if ( $ temperature !== NULL ) { if ( $ mode == TARGET_TEMP_MODE_RANGE ) { if ( ! is_array ( $ temperature ) || count ( $ temperature ) != 2 || ! is_numeric ( $ temperature [ 0 ] ) || ! is_numeric ( $ temperature [ 1 ] ) ) { echo "Error: when using TARGET_TEMP_MODE_RANGE, you need to set the target temperatures (second argument of setTargetTemperatureMode) using an array of two numeric values.\n" ; return FALSE ; } $ temp_low = $ this -> temperatureInCelsius ( $ temperature [ 0 ] , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temperature [ 1 ] , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } elseif ( $ mode != TARGET_TEMP_MODE_OFF ) { if ( ! is_numeric ( $ temperature ) ) { echo "Error: when using TARGET_TEMP_MODE_HEAT or TARGET_TEMP_MODE_COLD, you need to set the target temperature (second argument of setTargetTemperatureMode) using an numeric value.\n" ; return FALSE ; } $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } } $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_type' => $ mode ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
108	private function addExtension ( $ name , $ prettyVersion ) { $ extraDescription = null ; try { $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } catch ( \ UnexpectedValueException $ e ) { $ extraDescription = ' (actual version: ' . $ prettyVersion . ')' ; if ( preg_match ( '{^(\d+\.\d+\.\d+(?:\.\d+)?)}' , $ prettyVersion , $ match ) ) { $ prettyVersion = $ match [ 1 ] ; } else { $ prettyVersion = '0' ; } $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } $ packageName = $ this -> buildPackageName ( $ name ) ; $ ext = new CompletePackage ( $ packageName , $ version , $ prettyVersion ) ; $ ext -> setDescription ( 'The ' . $ name . ' PHP extension' . $ extraDescription ) ; $ this -> addPackage ( $ ext ) ; }
5511	public function expectCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_counts [ strtolower ( $ method ) ] = new CallCountExpectation ( $ method , $ count , $ message ) ; }
6458	public function writeJson ( IHttpResponseMessage $ response , array $ content ) : void { $ json = json_encode ( $ content ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new InvalidArgumentException ( 'Failed to JSON encode content: ' . json_last_error_msg ( ) ) ; } $ response -> getHeaders ( ) -> add ( 'Content-Type' , 'application/json' ) ; $ response -> setBody ( new StringBody ( $ json ) ) ; }
10737	public function parse ( string $ string ) : self { $ pattern = '/^[\[\(]-?(\d*[\.]?\d+|INF), -?(\d*[\.]?\d+|INF)[\]\)]$/' ; if ( ! preg_match ( $ pattern , $ string ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, string, to be a valid " . "interval; see the README for details" ) ; } $ this -> isLowerInclusive = substr ( $ string , 0 , 1 ) === '[' ; $ this -> isUpperInclusive = substr ( $ string , - 1 , 1 ) === ']' ; $ endpoints = explode ( $ this -> separator , substr ( $ string , 1 , - 1 ) ) ; foreach ( $ endpoints as & $ endpoint ) { if ( $ endpoint === self :: INFINITY_NEGATIVE ) { $ endpoint = - INF ; } elseif ( $ endpoint === self :: INFINITY_POSITIVE ) { $ endpoint = INF ; } else { $ endpoint = + $ endpoint ; } } if ( $ endpoints [ 1 ] < $ endpoints [ 0 ] ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, string, to be a valid " . "interval, however, the upper bound appears to be greater " . "than the lower bound" ) ; } if ( $ endpoints [ 0 ] == $ endpoints [ 1 ] && $ this -> isLowerInclusive !== $ this -> isUpperInclusive ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, string, to be a valid " . "interval, however, the endpoints are the same but the " . "boundaries are different" ) ; } $ this -> lower = $ endpoints [ 0 ] ; $ this -> upper = $ endpoints [ 1 ] ; return $ this ; }
10329	public function set_images ( $ post_id , $ post , $ update ) { App :: setCurrentID ( 'EFG' ) ; if ( Module :: CustomImagesGrifus ( ) -> getOption ( 'replace-when-add' ) ) { $ is_insert_post = App :: main ( ) -> is_after_insert_post ( $ post , $ update ) ; $ is_update_post = App :: main ( ) -> is_after_update_post ( $ post , $ update ) ; if ( $ is_insert_post || $ is_update_post ) { $ this -> model -> set_images ( $ post_id ) ; } } }
3244	public function getWasPurchasedAttribute ( ) { if ( Auth :: guest ( ) ) return false ; return Auth :: user ( ) -> orders ( ) -> whereSKU ( $ this -> attributes [ 'sku' ] ) -> whereStatusIn ( config ( 'shop.order_status_purchase' ) ) -> count ( ) > 0 ; }
6756	public static function createApp ( string $ appPath , string $ environment , bool $ debug ) : BaseKernel { $ envPath = $ appPath . '/.env' ; if ( file_exists ( $ envPath ) ) { $ dotenv = new Dotenv ( ) ; $ dotenv -> load ( $ envPath ) ; } $ oneBundleAppConfig = new \ OneBundleApp \ App \ OneBundleAppConfig ( $ appPath , $ environment ) ; \ Symfony \ Component \ Debug \ ErrorHandler :: register ( ) ; \ Symfony \ Component \ Debug \ ExceptionHandler :: register ( ) ; return new \ Mmoreram \ BaseBundle \ Kernel \ BaseKernel ( $ oneBundleAppConfig -> getBundles ( ) , $ oneBundleAppConfig -> getConfig ( ) , $ oneBundleAppConfig -> getRoutes ( ) , $ environment , $ debug , $ appPath . '/var' ) ; }
3190	public function getLastRegisteredTimestamp ( ) { $ points = $ this -> timeLine -> getPoints ( ) ; $ length = count ( $ points ) ; $ last = false ; if ( $ length ) { $ last = end ( $ points ) -> getTimestamp ( ) ; } return $ last ; }
12161	public function getIsChildless ( ) { if ( empty ( $ this -> collectorItem ) || empty ( $ this -> collectorItem -> children ) ) { return true ; } return false ; }
3046	protected function saveToolStates ( ) { $ toolStateParameter = 'toolStates' ; if ( $ this -> hasRequestParameter ( $ toolStateParameter ) ) { $ param = $ this -> getRawRequestParameter ( $ toolStateParameter ) ; if ( $ param ) { $ toolStates = json_decode ( $ param , true ) ; if ( count ( $ toolStates ) > 0 ) { array_walk ( $ toolStates , function ( & $ toolState ) { $ toolState = json_encode ( $ toolState ) ; } ) ; $ this -> getRunnerService ( ) -> setToolsStates ( $ this -> getServiceContext ( ) , $ toolStates ) ; return true ; } } } return false ; }
6949	private function getByCountryAndCustomerQuery ( ) { if ( null === $ this -> byCountryAndCustomerQuery ) { $ qb = $ this -> getBaseQueryBuilder ( ) ; $ this -> byCountryAndCustomerQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'r.customer' , ':customer' ) ) -> getQuery ( ) -> setParameter ( 'customer' , true ) -> setMaxResults ( 1 ) ; } return $ this -> byCountryAndCustomerQuery ; }
4756	public function transform ( $ value ) { if ( $ value instanceof \ Traversable || is_array ( $ value ) ) { return $ this -> transformIterable ( $ value ) ; } if ( is_bool ( $ value ) ) { return $ this -> transformBoolean ( $ value ) ; } if ( is_scalar ( $ value ) || ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) ) { return $ value ; } if ( $ value instanceof Cache ) { return $ this -> transformCacheAnnotation ( $ value ) ; } if ( $ value instanceof Method ) { return $ this -> transformMethodAnnotation ( $ value ) ; } if ( $ value instanceof ParamConverter ) { return $ this -> transformParamConverter ( $ value ) ; } if ( $ value instanceof Security ) { return $ this -> transformSecurity ( $ value ) ; } if ( $ value instanceof Template ) { return $ this -> transformTemplate ( $ value ) ; } return get_class ( $ value ) ; }
636	public function dropTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropTable ( $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
5701	protected function createFieldList ( $ buttons ) { $ actions = FieldList :: create ( ) ; foreach ( $ buttons as $ buttonType => $ bool ) { if ( ! $ bool || ! $ buttonType ) { continue ; } if ( substr ( $ buttonType , 0 , 6 ) == "Group_" ) { $ group = $ this -> createButtonGroup ( substr ( $ buttonType , 6 ) ) ; if ( $ group -> children -> exists ( ) ) { $ actions -> push ( $ group ) ; } } elseif ( $ b = $ this -> instantiateButton ( $ buttonType ) ) { $ actions -> push ( $ b ) ; } } return $ actions ; }
3216	function chunkedUploadStart ( $ data ) { Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( ) , $ data ) ; if ( $ response -> statusCode === 404 ) { throw new Exception_BadResponse ( "Got a 404, but we didn't send up an 'upload_id'" ) ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) throw new Exception_BadResponse ( "Got an offset-correcting 400 response, but we didn't send an offset" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ uploadId , $ byteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ len = strlen ( $ data ) ; if ( $ byteOffset !== $ len ) throw new Exception_BadResponse ( "We sent $len bytes, but server returned an offset of $byteOffset" ) ; return $ uploadId ; }
12261	private function _cacheCustomFieldsGroup ( CustomFieldsGroup $ group ) { foreach ( $ group -> getCustomFields ( ) as $ field ) { $ this -> cache [ $ group -> getEntity ( ) ] [ $ field -> getSlug ( ) ] = $ field ; } }
11575	public function actionRegister ( ) { if ( ! $ this -> module -> enableRegistration ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( RegistrationForm :: className ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> register ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Your account has been created' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'register' , [ 'model' => $ model , 'module' => $ this -> module , ] ) ; }
6845	public static function seconds ( $ step = 1 , $ start = 0 , $ end = 60 ) { $ step = ( int ) $ step ; $ seconds = array ( ) ; for ( $ i = $ start ; $ i < $ end ; $ i += $ step ) { $ seconds [ $ i ] = sprintf ( '%02d' , $ i ) ; } return $ seconds ; }
3386	public function authenticate ( $ identity , $ credential ) { $ adapter = $ this -> auth -> getAdapter ( ) ; $ adapter -> setIdentity ( $ identity ) ; $ adapter -> setCredential ( $ credential ) ; return $ this -> auth -> authenticate ( ) ; }
7793	public function getStatements ( $ text ) { if ( ! $ this -> parsers ) { $ this -> addParsers ( $ this -> getDefaultParsers ( ) ) ; } foreach ( $ this -> parsers as $ class ) { $ parser = new $ class ( $ this ) ; if ( $ parser -> accept ( $ text ) ) { return $ parser -> parse ( $ text ) ; } } throw new \ RuntimeException ( 'No suitable parser found.' ) ; }
2917	protected function ensureFileIsWritable ( $ filePath ) { if ( ( is_file ( $ filePath ) && ! is_writable ( $ filePath ) ) || ( ! is_file ( $ filePath ) && ! is_writable ( dirname ( $ filePath ) ) ) ) { throw new UnableWriteToFileException ( sprintf ( 'Unable to write to the file at %s.' , $ filePath ) ) ; } }
2482	protected function generateQueryString ( array $ parameters ) { $ removedArrayCharacters = preg_replace ( '/%5B[0-9]+%5D=/' , '=' , http_build_query ( $ parameters ) ) ; $ removedDuplicatedEscapingForUrlPath = str_replace ( '%5C%5C%2F' , '%5C%2F' , $ removedArrayCharacters ) ; return $ removedDuplicatedEscapingForUrlPath ; }
7308	public static function jd ( $ jd , TimeScale $ timescale = null ) { $ t = [ ] ; IAU :: D2dtf ( $ timescale , 14 , $ jd , 0 , $ y , $ m , $ d , $ t ) ; return new static ( $ y , $ m , $ d , $ t [ 0 ] , $ t [ 1 ] , $ t [ 2 ] , null , $ timescale ) ; }
5865	protected function reportAdditionalStorageClaimed ( $ bytes ) { $ legacyFileName = PATH_site . 'typo3conf/.tx_imageautoresize' ; $ fileName = PATH_site . 'typo3temp/.tx_imageautoresize' ; if ( file_exists ( $ legacyFileName ) && ! file_exists ( $ fileName ) ) { @ rename ( $ legacyFileName , $ fileName ) ; } $ data = [ ] ; if ( file_exists ( $ fileName ) ) { $ data = json_decode ( file_get_contents ( $ fileName ) , true ) ; if ( ! is_array ( $ data ) ) { $ data = [ ] ; } } $ data [ 'bytes' ] = $ bytes + ( isset ( $ data [ 'bytes' ] ) ? ( int ) $ data [ 'bytes' ] : 0 ) ; $ data [ 'images' ] = 1 + ( isset ( $ data [ 'images' ] ) ? ( int ) $ data [ 'images' ] : 0 ) ; GeneralUtility :: writeFile ( $ fileName , json_encode ( $ data ) ) ; }
6575	public function getSessionCookie ( ) : ? SetCookie { try { if ( $ this -> isStarted ( ) ) { return new SetCookie ( $ this -> getName ( ) , $ this -> getDataHolder ( ) -> getId ( ) , ( time ( ) + $ this -> getExpire ( ) * 60 ) , $ this -> getCookiePath ( ) ?? '/' , $ this -> getCookieHost ( ) ?? '' , $ this -> getCookieSecure ( ) , $ this -> isCookieHttpOnly ( ) ) ; } else { return SetCookie :: thatDeletesCookie ( $ this -> getName ( ) ) ; } } catch ( \ Throwable $ exception ) { throw new SessionManagerException ( "Error while preparing the session cookie" , $ this , null , $ exception ) ; } }
8723	public function translateOrNew ( $ locale ) { if ( is_null ( $ instance = $ this -> translate ( $ locale ) ) ) { return $ this -> newModelInstance ( ) ; } return $ instance ; }
3200	protected function binaryPopCount ( $ value ) { $ value -= ( ( $ value >> 1 ) & 0x55555555 ) ; $ value = ( ( ( $ value >> 2 ) & 0x33333333 ) + ( $ value & 0x33333333 ) ) ; $ value = ( ( ( $ value >> 4 ) + $ value ) & 0x0f0f0f0f ) ; $ value += ( $ value >> 8 ) ; $ value += ( $ value >> 16 ) ; return $ value & 0x0000003f ; }
11558	public function save ( ) { $ this -> modifiedTime = new \ DateTime ( 'now' ) ; self :: set ( $ this -> namespace , base64_encode ( serialize ( $ this -> instance ) ) , $ this -> modifiedTime -> getTimestamp ( ) + $ this -> lifetime , $ this -> path , $ this -> domain , $ this -> secure ) ; return $ this ; }
5176	public function add ( string $ key , $ value ) : self { if ( ! array_key_exists ( $ key , $ this -> props ) ) { return $ this -> addNew ( $ key , $ value ) ; } if ( is_array ( $ this -> props [ $ key ] ) ) { return $ this -> addArray ( $ key , $ value ) ; } return $ this -> appendToArray ( $ key , $ value ) ; }
12105	public function exception ( Exception $ exception ) { if ( $ this -> stopPropagation ) { return false ; } $ this -> fireHandlers ( $ exception ) ; $ this -> stopPropagation = true ; return false ; }
7622	public function signRequestUrl ( $ requestUrl = '' , $ resourceType = Storage :: RESOURCE_UNKNOWN , $ requiredPermission = CredentialsAbstract :: PERMISSION_READ ) { foreach ( $ this -> getPermissionSet ( ) as $ permittedUrl ) { if ( $ this -> permissionMatchesRequest ( $ permittedUrl , $ requestUrl , $ resourceType , $ requiredPermission ) ) { $ parsedPermittedUrl = parse_url ( $ permittedUrl ) ; if ( strpos ( $ requestUrl , '?' ) === false ) { $ requestUrl .= '?' ; } else { $ requestUrl .= '&' ; } $ requestUrl .= $ parsedPermittedUrl [ 'query' ] ; return $ requestUrl ; } } return $ requestUrl ; }
6153	public function setPropertyType ( $ propertyType ) { if ( $ propertyType instanceof PropertyType ) { $ this -> propertyType = $ propertyType ; } elseif ( is_array ( $ propertyType ) ) { $ this -> propertyType = new PropertyType ( $ propertyType ) ; } else { $ this -> propertyType = null ; trigger_error ( 'Argument must be an object of class PropertyType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
3374	protected function getFilename ( $ filename ) { $ callback = $ this -> fileCallback ; if ( null === $ callback || substr ( $ filename , 0 , 1 ) == '/' ) { return $ filename ; } return $ callback ( $ filename ) ; }
10042	public function validatePlugin ( $ plugin ) { if ( $ plugin instanceof Storage \ StorageInterface ) { return ; } throw new Storage \ Exception \ RuntimeException ( sprintf ( 'Plugin of type %s is invalid; must implement %s\Storage\StorageInterfaceInterface' , ( is_object ( $ plugin ) ? get_class ( $ plugin ) : gettype ( $ plugin ) ) , __NAMESPACE__ ) ) ; }
10029	function getContactsByFilterId ( $ filterId , $ page_index = 1 , $ page_size = 100 , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'page_index' => $ page_index , 'page_size' => $ page_size , 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/filter/' . utf8_encode ( $ filterId ) , $ queryParameters ) ; }
10257	public function getAddress ( $ state_code = null , $ zip = null ) { $ address = new Entities \ Address ; if ( ! empty ( $ zip ) && ! empty ( $ state_code ) ) { $ result = Zipcode :: where ( 'zip' , $ zip ) -> where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } elseif ( ! empty ( $ zip ) ) { $ result = Zipcode :: where ( 'zip' , $ zip ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } elseif ( ! empty ( $ state_code ) ) { $ result = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } else { $ result = Zipcode :: orderByRaw ( Database :: random ( ) ) -> first ( ) ; } $ address -> line_1 = $ this -> getStreet ( ) ; if ( $ this -> getBool ( true , false ) ) { $ address -> line_2 = $ this -> getApartment ( ) ; } else { $ address -> line_2 = null ; } $ address -> city = $ result -> city ; $ address -> zip = $ result -> zip ; $ address -> county = $ result -> county ; $ address -> state = new Entities \ State ; $ address -> state -> code = $ result -> state_code ; $ address -> state -> name = $ result -> state ; return $ address ; }
8883	public function getQuote ( $ credentials , $ options ) { $ this -> loadCredentials ( $ credentials ) ; $ options = $ this -> checkDefaults ( $ options ) ; $ residential_flag = ( $ this -> commercial_rates ) ? '' : '<ResidentialAddressIndicator/>' ; $ negotiated_flag = ( $ this -> negotiated_rates ) ? '<RateInformation><NegotiatedRatesIndicator/></RateInformation>' : '' ; $ this -> xml = '<?xml version="1.0"?> <AccessRequest xml:lang="en-US"> <AccessLicenseNumber>' . $ this -> access_key . '</AccessLicenseNumber> <UserId>' . $ this -> username . '</UserId> <Password>' . $ this -> password . '</Password> </AccessRequest> <?xml version="1.0"?> <RatingServiceSelectionRequest xml:lang="en-US"> <Request> <TransactionReference> <CustomerContext>Rate Request</CustomerContext> <XpciVersion>1.0001</XpciVersion> </TransactionReference> <RequestAction>Rate</RequestAction> <RequestOption>' . $ options [ 'request_option' ] . '</RequestOption> </Request> <PickupType> <Code>01</Code> </PickupType> <Shipment> <Shipper> <ShipperNumber>' . $ this -> account_number . '</ShipperNumber> <Address> <PostalCode>' . $ options [ 'from_zip' ] . '</PostalCode> <StateProvinceCode>' . $ options [ 'from_state' ] . '</StateProvinceCode> <CountryCode>' . $ options [ 'from_country' ] . '</CountryCode> </Address> </Shipper> <ShipTo> <Address> <PostalCode>' . $ options [ 'to_zip' ] . '</PostalCode> <StateProvinceCode>' . $ options [ 'to_state' ] . '</StateProvinceCode> <CountryCode>' . $ options [ 'to_country' ] . '</CountryCode> ' . $ residential_flag . ' </Address> </ShipTo> <Service> <Code>' . $ options [ 'service_type' ] . '</Code> <Description>Package</Description> </Service> <ShipmentServiceOptions/> ' . $ this -> buildPackages ( $ options [ 'packages' ] , $ options [ 'weight' ] , $ options [ 'measurement' ] ) . $ negotiated_flag . ' </Shipment> </RatingServiceSelectionRequest>' ; return $ this -> send ( ) ; }
7194	public static function get_thumbnail_file ( $ meta , $ size = 'medium' ) { if ( ! isset ( $ meta [ 'sizes' ] [ $ size ] ) ) { $ file = FALSE ; } else { $ dir = wp_upload_dir ( ) ; $ file_parts = array ( $ dir [ 'basedir' ] , dirname ( $ meta [ 'file' ] ) , $ meta [ 'sizes' ] [ $ size ] [ 'file' ] ) ; $ file = implode ( DIRECTORY_SEPARATOR , $ file_parts ) ; } return apply_filters ( 'iac_attach_media_thumbnail_file' , $ file , $ meta , $ size ) ; }
9304	public function setFailureLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`failureLogLifetime` expects integer value!' ) ; } $ this -> options [ 'failureLogLifetime' ] = ( int ) $ time ; return $ this ; }
11478	public function addTemplateSlots ( $ templateName , $ username ) { if ( ! array_key_exists ( $ templateName , $ this -> templateBlocks ) ) { return null ; } $ blocks = $ this -> templateBlocks [ $ templateName ] ; $ this -> addSlots ( $ blocks , $ username ) ; }
11974	private function firstParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( is_numeric ( $ params [ 0 ] ) && $ params [ 0 ] > 0 && $ params [ 0 ] <= $ this -> maxDieRolls ) ; }
102	public function findFile ( $ class ) { if ( isset ( $ this -> classMap [ $ class ] ) ) { return $ this -> classMap [ $ class ] ; } if ( $ this -> classMapAuthoritative || isset ( $ this -> missingClasses [ $ class ] ) ) { return false ; } if ( null !== $ this -> apcuPrefix ) { $ file = apcu_fetch ( $ this -> apcuPrefix . $ class , $ hit ) ; if ( $ hit ) { return $ file ; } } $ file = $ this -> findFileWithExtension ( $ class , '.php' ) ; if ( false === $ file && defined ( 'HHVM_VERSION' ) ) { $ file = $ this -> findFileWithExtension ( $ class , '.hh' ) ; } if ( null !== $ this -> apcuPrefix ) { apcu_add ( $ this -> apcuPrefix . $ class , $ file ) ; } if ( false === $ file ) { $ this -> missingClasses [ $ class ] = true ; } return $ file ; }
9616	public function registerCommands ( array $ commands , callable $ handler ) { foreach ( $ commands as $ command ) { $ handler_id = "app.handler." . join ( '' , array_slice ( explode ( "\\" , $ command ) , - 1 ) ) ; $ this [ $ handler_id ] = $ handler ; } }
4946	public function build ( ) { $ view = $ change = array ( ) ; foreach ( $ this -> assigned as $ resourceId => $ spec ) { if ( isset ( $ spec [ 'permission' ] ) ) { $ spec = array ( $ spec [ 'permission' ] => $ spec [ 'users' ] ) ; $ this -> assigned [ $ resourceId ] = $ spec ; } foreach ( $ spec as $ perm => $ userIds ) { if ( self :: PERMISSION_ALL == $ perm || self :: PERMISSION_CHANGE == $ perm ) { $ change = array_merge ( $ change , $ userIds ) ; } $ view = array_merge ( $ view , $ userIds ) ; } } $ this -> change = array_unique ( $ change ) ; $ this -> view = array_unique ( $ view ) ; return $ this ; }
1338	public static function defaultApi ( string $ name ) : self { if ( empty ( $ name ) ) { throw new \ InvalidArgumentException ( 'Default API name must not be empty.' ) ; } self :: $ defaultApi = $ name ; return new self ( ) ; }
110	public function loadInstalledPlugins ( ) { if ( $ this -> disablePlugins ) { return ; } $ repo = $ this -> composer -> getRepositoryManager ( ) -> getLocalRepository ( ) ; $ globalRepo = $ this -> globalComposer ? $ this -> globalComposer -> getRepositoryManager ( ) -> getLocalRepository ( ) : null ; if ( $ repo ) { $ this -> loadRepository ( $ repo ) ; } if ( $ globalRepo ) { $ this -> loadRepository ( $ globalRepo ) ; } }
5240	public function log ( \ Exception $ exception ) { $ logData = date ( 'Y-m-d H:i:s' ) ; $ logData .= $ this -> exceptionFields ( $ exception ) ; $ logData .= $ this -> fieldsForPrevious ( $ exception -> getPrevious ( ) ) ; error_log ( $ logData . "\n" , 3 , $ this -> getLogDir ( ) . DIRECTORY_SEPARATOR . 'exceptions-' . date ( 'Y-m-d' ) . '.log' ) ; }
3569	public function __issetHook ( ) { return function ( $ next , $ isset , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ isset ) { $ isset = ( bool ) $ this -> hasMeta ( $ key ) ; } return $ next ( $ isset , $ args ) ; } ; }
9034	protected function init ( $ key ) { if ( ! isset ( $ this -> files [ $ key ] ) ) { $ this -> files [ $ key ] = fopen ( $ this -> dir . $ key . '.lockfile' , 'w+' ) ; $ this -> owns [ $ key ] = false ; } }
8173	private function addCallable ( $ type = 'function' , $ name , $ func ) { if ( ! is_string ( $ name ) || ! is_callable ( $ func ) ) { return ; } $ twname = trim ( $ name , '*' ) ; $ params = [ ] ; if ( strpos ( $ name , '*' ) === 0 ) { $ params [ 'is_safe' ] = [ 'html' ] ; } if ( $ type === 'function' ) { $ this -> twig -> addFunction ( new Twig_SimpleFunction ( $ twname , $ func , $ params ) ) ; } if ( $ type === 'filter' ) { $ this -> twig -> addFilter ( new Twig_SimpleFilter ( $ twname , $ func , $ params ) ) ; } }
12157	public function getObjectTypeModel ( ) { if ( ! isset ( $ this -> _objectTypeModel ) && isset ( Yii :: $ app -> collectors [ 'types' ] -> tableRegistry [ $ this -> systemId ] ) ) { $ this -> _objectTypeModel = Yii :: $ app -> collectors [ 'types' ] -> tableRegistry [ $ this -> systemId ] ; } return $ this -> _objectTypeModel ; }
10795	public function contact ( array $ data , $ destination = null ) { $ authService = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'zfcUserAuthentication' ) ; if ( null === $ destination && ! $ authService -> hasIdentity ( ) ) { throw new \ Exception ( "Errore si sistema." ) ; } $ identity = $ authService -> getIdentity ( ) ; $ data [ 'email' ] = null !== $ destination ? $ destination : $ identity -> getEmail ( ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.contact' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ data = array_merge ( $ form -> getData ( ) , array ( 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) ) ) ; $ event = new UserContactEvent ( __FUNCTION__ , null , $ data ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; }
11391	public function createMainMenu ( Request $ request ) { $ menu = $ this -> factory -> createItem ( 'root' ) ; $ menu -> setCurrentUri ( $ request -> getBaseUrl ( ) . $ request -> getPathInfo ( ) ) ; $ admin_pool = $ this -> container -> get ( 'sonata.admin.pool' ) ; foreach ( $ admin_pool -> getDashboardGroups ( ) as $ group ) { $ menu -> addChild ( $ group [ 'label' ] , array ( 'translationDomain' => $ group [ 'label_catalogue' ] ) ) ; foreach ( $ group [ 'items' ] as $ admin ) { if ( $ admin -> hasRoute ( 'list' ) && $ admin -> isGranted ( 'LIST' ) ) { $ menu [ $ group [ 'label' ] ] -> addChild ( $ admin -> getLabel ( ) , array ( 'admin' => $ admin ) ) ; } } } $ dispatcher = $ this -> container -> get ( 'event_dispatcher' ) ; $ event = new MenuCreateEvent ( $ menu ) ; $ dispatcher -> dispatch ( MenuEvents :: ADMIN_MENU_CREATE , $ event ) ; return $ menu ; }
5515	public function expectAtLeastOnce ( $ method , $ args = false , $ message = '%s' ) { $ this -> expectMinimumCallCount ( $ method , 1 , $ message ) ; if ( $ args !== false ) { $ this -> expect ( $ method , $ args , $ message ) ; } }
2666	public function dictionaryItemsList ( $ dictionaryId ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/items' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
6471	public function parseContentTypeHeader ( HttpHeaders $ headers ) : ? ContentTypeHeaderValue { if ( ! $ headers -> containsKey ( 'Content-Type' ) ) { return null ; } $ contentTypeHeaderParameters = $ this -> parseParameters ( $ headers , 'Content-Type' ) ; $ contentType = $ contentTypeHeaderParameters -> getKeys ( ) [ 0 ] ; return new ContentTypeHeaderValue ( $ contentType , $ contentTypeHeaderParameters ) ; }
1717	public function canEditFieldsOf ( $ table ) { if ( $ this -> isAdmin ) { return true ; } return \ count ( preg_grep ( '/^' . preg_quote ( $ table , '/' ) . '::/' , $ this -> alexf ) ) > 0 ; }
2465	public function checkPermission ( ) { $ bundles = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( ! isset ( $ bundles [ 'ContaoCommentsBundle' ] ) ) { $ key = array_search ( 'allowComments' , $ GLOBALS [ 'TL_DCA' ] [ 'tl_faq' ] [ 'list' ] [ 'sorting' ] [ 'headerFields' ] ) ; unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_faq' ] [ 'list' ] [ 'sorting' ] [ 'headerFields' ] [ $ key ] ) ; } }
7881	public function read ( $ date ) { try { return $ this -> files -> get ( $ this -> path ( $ date ) ) ; } catch ( FileNotFoundException $ e ) { throw new FilesystemException ( 'There was an reading the log.' ) ; } }
5301	public function getCss ( ) { $ css = '' ; foreach ( $ this -> getGlyphNames ( ) as $ unicode => $ name ) { $ css .= ".icon-" . $ name . ":before {" . "\n" ; $ css .= "\tcontent: \"\\" . $ unicode . "\";\n" ; $ css .= "}\n" ; } return $ css ; }
10267	public function setEndColor ( Color $ pValue ) { $ color = $ pValue -> getIsSupervisor ( ) ? $ pValue -> getSharedComponent ( ) : $ pValue ; if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getEndColor ( ) -> getStyleArray ( [ 'argb' => $ color -> getARGB ( ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> endColor = $ color ; } return $ this ; }
6235	public function mkdir ( ) : self { if ( ! $ this -> storage -> isDir ( ) ) { if ( ! $ this -> storage -> mkdir ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to create directory at: "%s"' , $ this -> storage -> path ( ) -> raw ) , 500 ) ; } } return $ this ; }
2190	public function isRegistered ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; return isset ( $ this -> arrIdentities [ $ intObjectId ] ) ; }
1111	public function map ( $ nodeList ) { $ self = $ this ; return $ this -> wrapInTransaction ( function ( ) use ( $ self , $ nodeList ) { forward_static_call ( array ( get_class ( $ self -> node ) , 'unguard' ) ) ; $ result = $ self -> mapTree ( $ nodeList ) ; forward_static_call ( array ( get_class ( $ self -> node ) , 'reguard' ) ) ; return $ result ; } ) ; }
11779	protected function buildClass ( $ name ) { $ stub = $ this -> files -> get ( $ this -> getStub ( ) ) ; return str_replace ( 'DummyHelper' , $ this -> getNameInput ( ) , $ stub ) ; }
1957	public function generate ( ) { if ( $ this -> vimeo == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://vimeo.com/' . $ this -> vimeo . '" target="_blank" rel="noreferrer noopener">vimeo.com/' . $ this -> vimeo . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
8101	public function getRow ( $ arguments ) { $ sql = 'SELECT * FROM _table_ WHERE _arguments_ LIMIT 1' ; if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } else { return $ stmt -> fetch ( ) ; } }
1223	public function resolve ( $ uri , $ version , $ resource , array $ paramDefs , array $ paramValues ) { foreach ( $ paramValues as $ param => $ value ) { if ( ! array_key_exists ( $ param , $ paramDefs ) ) { throw new \ InvalidArgumentException ( "Unknown uri parameter \"$param\" provided" ) ; } } foreach ( $ paramDefs as $ key => $ def ) { if ( ! isset ( $ paramValues [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ paramValues [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ paramValues ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ paramDefs , $ paramValues ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ paramValues [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ paramValues [ $ key ] , $ paramValues ) ; } } return ( "$uri/" . "$version/" . $ this -> fillPathParams ( $ resource , $ paramValues ) . $ this -> buildQueryParameters ( $ paramValues ) ) ; }
6185	public function clear ( $ type = 'all' ) { if ( $ type === 'all' ) { $ this -> driver -> remove ( 'flash_messages' ) ; } else { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; unset ( $ flashMessages [ $ type ] ) ; $ this -> driver -> set ( 'flash_messages' , $ flashMessages ) ; } return true ; }
6111	public function fileDelete ( $ cpw = "" , $ name = "/" ) { return $ this -> getParent ( ) -> channelFileDelete ( $ this -> getId ( ) , $ cpw , $ name ) ; }
3409	public function setLockPath ( string $ path ) : Application { if ( ! is_dir ( $ path ) ) { ( new Filesystem ( ) ) -> mkdir ( $ path ) ; } if ( ! $ realpath = realpath ( $ path ) ) { throw new \ InvalidArgumentException ( "The directory (" . $ path . ") is unavailable" ) ; } $ this -> lockPath = $ realpath ; return $ this ; }
3009	public function fetch ( $ template , array $ data = [ ] ) { if ( isset ( $ data [ 'template' ] ) ) { throw new \ InvalidArgumentException ( "Duplicate template key found" ) ; } if ( ! is_file ( $ this -> templatePath . $ template ) ) { throw new \ RuntimeException ( "View cannot render `$template` because the template does not exist" ) ; } $ data = array_merge ( $ this -> attributes , $ data ) ; try { ob_start ( ) ; $ this -> protectedIncludeScope ( $ this -> templatePath . $ template , $ data ) ; $ output = ob_get_clean ( ) ; if ( $ this -> layout !== null ) { ob_start ( ) ; $ data [ 'content' ] = $ output ; $ this -> protectedIncludeScope ( $ this -> layout , $ data ) ; $ output = ob_get_clean ( ) ; } } catch ( \ Throwable $ e ) { ob_end_clean ( ) ; throw $ e ; } catch ( \ Exception $ e ) { ob_end_clean ( ) ; throw $ e ; } return $ output ; }
9993	private function createCSSStyle ( Style $ pStyle ) { $ css = array_merge ( $ this -> createCSSStyleAlignment ( $ pStyle -> getAlignment ( ) ) , $ this -> createCSSStyleBorders ( $ pStyle -> getBorders ( ) ) , $ this -> createCSSStyleFont ( $ pStyle -> getFont ( ) ) , $ this -> createCSSStyleFill ( $ pStyle -> getFill ( ) ) ) ; return $ css ; }
10390	public static function loadString ( $ xmlString ) { $ xmlFile = tempnam ( self :: getSysTempDir ( ) , 'xml_' ) ; file_put_contents ( $ xmlFile , $ xmlString ) ; $ xml = self :: parseXml ( $ xmlFile ) ; unlink ( $ xmlFile ) ; return $ xml ; }
10558	public function createI18n ( array $ args ) { $ i18n = new I18n ; I18nShortcut :: setInstance ( $ i18n ) ; $ modules = $ this -> app -> resolver -> getResolver ( "language" ) ; $ log = \ Wedeto \ Log \ Logger :: getLogger ( I18nPlugin :: class ) ; $ search_path = $ modules -> getSearchPath ( ) ; foreach ( $ search_path as $ name => $ path ) { $ i18n -> registerTextDomain ( $ name , $ path ) ; } $ site_language = $ this -> app -> config -> dget ( 'site' , 'default_language' , 'en' ) ; $ locale = $ args [ 'locale' ] ?? $ site_language ; $ i18n -> setLocale ( $ locale ) ; $ this -> setupTranslateLog ( ) ; return $ i18n ; }
6707	public function afterFind ( $ event ) { if ( is_array ( $ this -> fields ) ) { foreach ( $ this -> fields as $ field ) { if ( $ event -> sender -> { $ field } ) { $ event -> sender -> { $ field } = explode ( ';' , $ event -> sender -> { $ field } ) ; } } } }
12828	protected function registerCustomFunctions ( ) { $ functionList = $ this -> functionGenerator -> getFunctionList ( ) ; foreach ( $ functionList as $ function ) { if ( isset ( $ function [ 'name' ] ) && isset ( $ function [ 'callable' ] ) ) { $ twigFunction = new Twig_SimpleFunction ( $ function [ 'name' ] , $ function [ 'callable' ] ) ; $ this -> engine -> addFunction ( $ twigFunction ) ; } } }
6854	private function findPaymentTokens ( PaymentInterface $ payment ) { $ identity = $ this -> getPaymentIdentity ( $ payment ) ; $ tokens = $ this -> payum -> getTokenStorage ( ) -> findBy ( [ 'details' => $ identity , ] ) ; return $ tokens ; }
1663	public function image ( $ imageUrl , $ accessibilityText = null ) { $ this -> imageUrl = $ imageUrl ; $ this -> accessibilityText = $ accessibilityText ; return $ this ; }
7804	protected function balance ( BalanceInterface $ balance , $ text ) { if ( ! preg_match ( '/(C|D)(\d{6})([A-Z]{3})([0-9,]{1,15})/' , $ text , $ match ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot parse balance: "%s"' , $ text ) ) ; } $ amount = ( float ) str_replace ( ',' , '.' , $ match [ 4 ] ) ; if ( $ match [ 1 ] === 'D' ) { $ amount *= - 1 ; } $ date = \ DateTime :: createFromFormat ( 'ymd' , $ match [ 2 ] ) ; $ date -> setTime ( 0 , 0 , 0 ) ; $ balance -> setCurrency ( $ match [ 3 ] ) -> setAmount ( $ amount ) -> setDate ( $ date ) ; return $ balance ; }
10948	public function getCsrfToken ( $ regenerate = false ) { if ( $ this -> _csrfToken === null || $ regenerate ) { if ( $ regenerate || ( $ token = $ this -> loadCsrfToken ( ) ) === null ) { $ token = $ this -> generateCsrfToken ( ) ; } $ chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-.' ; $ mask = substr ( str_shuffle ( str_repeat ( $ chars , 5 ) ) , 0 , static :: CSRF_MASK_LENGTH ) ; $ this -> _csrfToken = str_replace ( '+' , '.' , base64_encode ( $ mask . $ this -> xorTokens ( $ token , $ mask ) ) ) ; } return $ this -> _csrfToken ; }
522	protected function createMigration ( $ class ) { $ this -> includeMigrationFile ( $ class ) ; $ migration = Yii :: createObject ( $ class ) ; if ( $ migration instanceof BaseObject && $ migration -> canSetProperty ( 'compact' ) ) { $ migration -> compact = $ this -> compact ; } return $ migration ; }
3106	public function getEvents ( ) { if ( isset ( $ this -> state [ self :: VAR_EVENTS_QUEUE ] ) ) { $ events = $ this -> state [ self :: VAR_EVENTS_QUEUE ] ; } else { $ events = [ ] ; } return $ events ; }
2527	protected function getEndpointFromWsdl ( $ wsdlFilePath , $ messageName ) { $ wsdlId = $ this -> getWsdlIdFor ( $ messageName ) ; return WsdlAnalyser :: exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , self :: XPATH_ENDPOINT ) ; }
6369	public static function compose ( callable $ g , callable $ f ) : callable { return function ( $ input ) use ( $ g , $ f ) { return Functions :: call ( $ g , Functions :: call ( $ f , $ input ) ) ; } ; }
2660	public function getRequest ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET , '' , false , null , false ) ; return $ result ; }
9705	private function calcSheetOffsets ( ) { $ boundsheet_length = 10 ; $ offset = $ this -> _datasize ; $ total_worksheets = count ( $ this -> spreadsheet -> getAllSheets ( ) ) ; foreach ( $ this -> spreadsheet -> getWorksheetIterator ( ) as $ sheet ) { $ offset += $ boundsheet_length + strlen ( StringHelper :: UTF8toBIFF8UnicodeShort ( $ sheet -> getTitle ( ) ) ) ; } for ( $ i = 0 ; $ i < $ total_worksheets ; ++ $ i ) { $ this -> worksheetOffsets [ $ i ] = $ offset ; $ offset += $ this -> worksheetSizes [ $ i ] ; } $ this -> biffSize = $ offset ; }
9200	public function uploadMedia ( $ filepaths , $ client = null ) { $ maxMediaIds = Config :: get ( 'max_media_ids' ) ; if ( count ( $ filepaths ) > $ maxMediaIds ) { throw new MediaUploadLimitException ( "You cannot upload more than ${maxMediaIds} media files in a tweet!" ) ; } $ mediaIds = array ( ) ; if ( is_null ( $ client ) ) { $ client = $ this -> createGuzzleClient ( Config :: get ( 'base_upload_url' ) ) ; } $ endpoint = $ this -> prependVersionToEndpoint ( "media/upload.json" , Config :: get ( 'api_version' ) ) ; foreach ( $ filepaths as $ filepath ) { $ options = $ this -> constructRequestOptions ( array ( ) , $ client ) ; $ options [ 'body' ] = array ( 'media' => new PostFile ( 'media' , fopen ( $ filepath , 'r' ) ) ) ; $ response = $ client -> post ( $ endpoint , $ options ) ; array_push ( $ mediaIds , $ response -> json ( ) [ 'media_id_string' ] ) ; } return ( implode ( "," , $ mediaIds ) ) ; }
4374	protected function buildChannelTree ( ) { if ( $ this -> channels == array ( $ this -> channelNameRoot ) ) { return array ( ) ; } \ sort ( $ this -> channels ) ; $ rootKey = \ array_search ( $ this -> channelNameRoot , $ this -> channels ) ; if ( $ rootKey !== false ) { unset ( $ this -> channels [ $ rootKey ] ) ; \ array_unshift ( $ this -> channels , $ this -> channelName ) ; } $ tree = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ ref = & $ tree ; $ path = \ explode ( '.' , $ channel ) ; foreach ( $ path as $ k ) { if ( ! isset ( $ ref [ $ k ] ) ) { $ ref [ $ k ] = array ( ) ; } $ ref = & $ ref [ $ k ] ; } } return $ tree ; }
9510	public function download ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DOWNLOAD ) ; return $ this -> logViewer -> download ( $ log -> date ) ; }
627	public function bindParam ( $ name , & $ value , $ dataType = null , $ length = null , $ driverOptions = null ) { $ this -> prepare ( ) ; if ( $ dataType === null ) { $ dataType = $ this -> db -> getSchema ( ) -> getPdoType ( $ value ) ; } if ( $ length === null ) { $ this -> pdoStatement -> bindParam ( $ name , $ value , $ dataType ) ; } elseif ( $ driverOptions === null ) { $ this -> pdoStatement -> bindParam ( $ name , $ value , $ dataType , $ length ) ; } else { $ this -> pdoStatement -> bindParam ( $ name , $ value , $ dataType , $ length , $ driverOptions ) ; } $ this -> params [ $ name ] = & $ value ; return $ this ; }
11268	public static function new ( string $ type = 'default' , string $ path = Migrate :: DEFAULT_PATH , $ notify = NotifyInterface :: LOGGER ) : Creator { $ fs = new Filesystem ( new Local ( $ path ) ) ; $ note = NotifyFactory :: create ( $ notify ) ; return new static ( CreatorFactory :: create ( $ type , $ note ) , $ fs , $ note ) ; }
8399	public function display ( Environment $ environment , $ template , $ type = null , $ size = 'md' , $ object = null ) { $ tools = $ environment -> render ( $ template , array ( 'type' => $ type , 'object' => $ object , ) ) ; return $ environment -> render ( '@c975LToolbar/toolbar.html.twig' , array ( 'tools' => $ tools , 'size' => $ size , ) ) ; }
4802	protected function locateDirectory ( string $ name ) : ? string { $ parts = [ $ name ] ; foreach ( Database :: COLLECTION_SEPARATOR_CHARACTERS as $ char ) { if ( ! strstr ( $ name , $ char ) ) { continue ; } $ parts = explode ( $ char , $ name ) ; break ; } return $ this -> recurseLocateDirectory ( $ parts ) ; }
756	protected function renderImage ( $ code ) { if ( isset ( $ this -> imageLibrary ) ) { $ imageLibrary = $ this -> imageLibrary ; } else { $ imageLibrary = Captcha :: checkRequirements ( ) ; } if ( $ imageLibrary === 'gd' ) { return $ this -> renderImageByGD ( $ code ) ; } elseif ( $ imageLibrary === 'imagick' ) { return $ this -> renderImageByImagick ( $ code ) ; } throw new InvalidConfigException ( "Defined library '{$imageLibrary}' is not supported" ) ; }
2078	public function purgePageCache ( ) { $ strCacheDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCacheDir . '/http_cache' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the page cache' , __METHOD__ , TL_CRON ) ; }
6498	public function useScreenResolution ( $ width_height ) { list ( $ width , $ height ) = explode ( 'x' , $ width_height ) ; $ this -> getSessionDriver ( ) -> resizeWindow ( ( int ) $ width , ( int ) $ height ) ; }
469	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } return $ model ; }
515	public function actionTo ( $ version ) { if ( ( $ namespaceVersion = $ this -> extractNamespaceMigrationVersion ( $ version ) ) !== false ) { $ this -> migrateToVersion ( $ namespaceVersion ) ; } elseif ( ( $ migrationName = $ this -> extractMigrationVersion ( $ version ) ) !== false ) { $ this -> migrateToVersion ( $ migrationName ) ; } elseif ( ( string ) ( int ) $ version == $ version ) { $ this -> migrateToTime ( $ version ) ; } elseif ( ( $ time = strtotime ( $ version ) ) !== false ) { $ this -> migrateToTime ( $ time ) ; } else { throw new Exception ( "The version argument must be either a timestamp (e.g. 101129_185401),\n the full name of a migration (e.g. m101129_185401_create_user_table),\n the full namespaced name of a migration (e.g. app\\migrations\\M101129185401CreateUserTable),\n a UNIX timestamp (e.g. 1392853000), or a datetime string parseable\nby the strtotime() function (e.g. 2014-02-15 13:00:50)." ) ; } }
12927	public function lists ( $ offset = 0 , $ limit = 10 ) { $ params = [ 'begin' => $ offset , 'limit' => $ limit , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_LIST , $ params ] ) ; }
3249	public function hasItem ( $ sku , $ requireAll = false ) { if ( is_array ( $ sku ) ) { foreach ( $ sku as $ skuSingle ) { $ hasItem = $ this -> hasItem ( $ skuSingle ) ; if ( $ hasItem && ! $ requireAll ) { return true ; } elseif ( ! $ hasItem && $ requireAll ) { return false ; } } return $ requireAll ; } else { foreach ( $ this -> items as $ item ) { if ( $ item -> sku == $ sku ) { return true ; } } } return false ; }
3690	public function handleCreateVariantAction ( ActionEvent $ event ) { if ( false === $ this -> scopeMatcher -> currentScopeIsBackend ( ) || 'createvariant' !== $ event -> getAction ( ) -> getName ( ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ view = $ environment -> getView ( ) ; $ dataProvider = $ environment -> getDataProvider ( ) ; $ inputProvider = $ environment -> getInputProvider ( ) ; $ modelId = $ inputProvider -> hasParameter ( 'id' ) ? ModelId :: fromSerialized ( $ inputProvider -> getParameter ( 'id' ) ) : null ; $ model = $ dataProvider -> createVariant ( $ dataProvider -> getEmptyConfig ( ) -> setId ( $ modelId -> getId ( ) ) ) ; if ( $ model == null ) { throw new \ RuntimeException ( sprintf ( 'Could not find model with id %s for creating a variant.' , $ modelId ) ) ; } $ metaModel = $ this -> factory -> getMetaModel ( $ model -> getProviderName ( ) ) ; if ( ! $ metaModel || ! $ metaModel -> hasVariants ( ) ) { return ; } $ preFunction = function ( $ environment , $ model ) { $ copyEvent = new PreCreateModelEvent ( $ environment , $ model ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ copyEvent :: NAME , $ copyEvent ) ; } ; $ postFunction = function ( $ environment , $ model ) { $ copyEvent = new PostCreateModelEvent ( $ environment , $ model ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ copyEvent :: NAME , $ copyEvent ) ; } ; if ( ! $ view instanceof BackendViewInterface ) { throw new \ InvalidArgumentException ( 'Invalid view registered in environment.' ) ; } $ editMask = new EditMask ( $ view , $ model , null , $ preFunction , $ postFunction , $ this -> breadcrumb ( $ environment ) ) ; $ event -> setResponse ( $ editMask -> execute ( ) ) ; }
10701	public static function isBirthNumber ( $ no ) { if ( ! preg_match ( '#^\s*(\d\d)(\d\d)(\d\d)[ /]*(\d\d\d)(\d?)\s*$#' , $ no , $ matches ) ) { return false ; } list ( , $ year , $ month , $ day , $ ext , $ c ) = $ matches ; if ( $ c === '' ) { $ year += $ year < 54 ? 1900 : 1800 ; } else { $ mod = ( $ year . $ month . $ day . $ ext ) % 11 ; if ( $ mod === 10 ) { $ mod = 0 ; } if ( $ mod !== ( int ) $ c ) { return false ; } $ year += $ year < 54 ? 2000 : 1900 ; } if ( $ year > 2003 ) { if ( $ month > 70 ) { $ month -= 70 ; } if ( $ month > 20 && $ month < 50 ) { $ month -= 20 ; } } if ( $ month > 50 ) { $ month -= 50 ; } return checkdate ( $ month , $ day , $ year ) ; }
8962	private static function extractArrayCriteria ( $ key , array $ criteria ) { if ( ! empty ( $ criteria [ $ key ] ) ) { return array ( $ criteria [ $ key ] ) ; } if ( ! empty ( $ criteria [ $ key . 's' ] ) ) { return $ criteria [ $ key . 's' ] ; } return array ( ) ; }
9068	protected function convert_value_to_string ( $ value ) { if ( $ this -> is_resource ( $ value ) ) { $ type = get_resource_type ( $ value ) ; return "(Resource:$type)" ; } if ( is_object ( $ value ) ) { if ( $ value instanceof \ Exception || $ value instanceof \ Throwable ) { return '(' . get_class ( $ value ) . "#{$value->getCode()}:{$value->getMessage()})" ; } elseif ( $ value instanceof \ DateTime || ( interface_exists ( '\DateTimeInterface' ) && $ value instanceof \ DateTimeInterface ) ) { return $ value -> format ( \ DateTime :: ATOM ) ; } elseif ( method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } else { $ class = get_class ( $ value ) ; return "($class)" ; } } if ( is_array ( $ value ) ) { return '(Array)' ; } if ( is_scalar ( $ value ) ) { return $ value ; } if ( $ value === null ) { return '(Null)' ; } return '(Invalid)' ; }
11968	public static function GetAuthClass ( ) { if ( self :: $ authClass === NULL ) { if ( class_exists ( self :: AUTH_CLASS_FULL ) ) { self :: $ authClass = self :: AUTH_CLASS_FULL ; } else { self :: $ authClass = self :: AUTH_CLASS_BASIC ; } } return self :: $ authClass ; }
10441	protected function getLineType ( $ line ) { if ( preg_match ( '/^###\s+@[0-9]+=.*$/' , $ line ) ) { return self :: LINE_TYPE_PARAM ; } elseif ( preg_match ( '/^###/' , $ line ) ) { return self :: LINE_TYPE_QUERY ; } elseif ( preg_match ( '/^#[0-9]/' , $ line ) ) { return self :: LINE_TYPE_META ; } elseif ( preg_match ( '/Errcode|ERROR/' , $ line ) ) { return self :: LINE_TYPE_ERROR ; } return self :: LINE_TYPE_UNKNOWN ; }
10419	public static function parse ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new Exception ( 'The give file ' . $ path . ' doesn\'t exist.' ) ; } return Yaml :: parse ( file_get_contents ( $ path ) ) ; }
12574	public function previewCard ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_CARD , $ message , $ to , $ by ) ; }
7319	public function add ( Time $ t ) { $ td = $ t -> days ; $ jda = intval ( $ td ) ; $ dfa = $ this -> dayFrac + $ td - $ jda ; if ( $ dfa < 0 ) { $ dfa += 1 ; $ jda -= 1 ; } $ jda1 = intval ( $ dfa ) ; $ dfa = fmod ( $ dfa , 1 ) ; $ this -> jd = $ this -> jd + $ jda + $ jda1 ; $ this -> dayFrac = $ dfa ; return $ this ; }
12131	public function handle ( ) { $ view = $ this -> application -> createInstance ( "view" , [ $ this -> application -> response , $ this -> application -> createInstance ( "viewengine" , [ $ this -> application -> response ] ) , $ this -> application ] ) ; $ view -> setData ( "title" , "An Error Occured" ) ; $ this -> application -> response -> send ( $ view -> render ( "errors/error" ) ) ; return Handler :: LAST_HANDLER ; }
3338	public static function dateTimeString ( $ datetime ) { if ( $ datetime === null ) { return null ; } if ( is_object ( $ datetime ) && ! ( $ datetime instanceof \ DateTime ) ) { throw new \ Exception ( 'Only \DateTime objects allowed' ) ; } if ( is_string ( $ datetime ) ) { $ datetime = new \ DateTime ( $ datetime ) ; } return $ datetime -> format ( "Y-m-d\TH:i:s.uP" ) ; }
457	public function dropUnique ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
4814	private function createFrom ( $ filepath ) { if ( file_exists ( $ filepath ) ) { $ anyDataSet = XmlUtil :: createXmlDocumentFromFile ( $ filepath ) ; $ this -> collection = array ( ) ; $ rows = $ anyDataSet -> getElementsByTagName ( "row" ) ; foreach ( $ rows as $ row ) { $ sr = new Row ( ) ; $ fields = $ row -> getElementsByTagName ( "field" ) ; foreach ( $ fields as $ field ) { $ attr = $ field -> attributes -> getNamedItem ( "name" ) ; if ( is_null ( $ attr ) ) { throw new \ InvalidArgumentException ( 'Malformed anydataset file ' . basename ( $ filepath ) ) ; } $ sr -> addField ( $ attr -> nodeValue , $ field -> nodeValue ) ; } $ sr -> acceptChanges ( ) ; $ this -> collection [ ] = $ sr ; } $ this -> currentRow = count ( $ this -> collection ) - 1 ; } }
7811	private static function filterArray ( $ needle , $ heystack , $ always = array ( ) ) { foreach ( $ heystack as $ k => $ v ) { if ( ! in_array ( $ v , $ needle ) && ! in_array ( $ v , $ always ) ) unset ( $ heystack [ $ k ] ) ; } return $ heystack ; }
6783	public function setHeaderParameters ( $ optionNames ) { foreach ( ( array ) $ optionNames as $ option ) { $ this -> headerParameters [ $ option ] = true ; } return $ this ; }
3857	protected function prepareView ( ) { if ( $ this -> renderSettingFactory ) { $ this -> objView = $ this -> renderSettingFactory -> createCollection ( $ this -> objMetaModel , $ this -> intView ) ; } else { $ this -> objView = $ this -> objMetaModel -> getView ( $ this -> intView ) ; } if ( $ this -> objView ) { $ this -> objTemplate = new Template ( $ this -> objView -> get ( 'template' ) ) ; $ this -> objTemplate -> view = $ this -> objView ; } else { $ this -> objTemplate = new Template ( 'metamodel_full' ) ; } }
5280	public function select ( $ fields = '' ) { if ( empty ( $ fields ) ) { return $ this ; } if ( is_string ( $ fields ) ) { $ this -> statements [ 'select' ] [ ] = $ fields ; return $ this ; } foreach ( $ fields as $ key => $ field ) { if ( is_string ( $ key ) ) { $ this -> statements [ 'select' ] [ ] = "$key as $field" ; } else { $ this -> statements [ 'select' ] [ ] = $ field ; } } return $ this ; }
1289	public function setType ( string $ type = null ) { $ validTypes = [ 'all' , 'Asset' , 'Entry' , 'Deletion' , 'DeletedAsset' , 'DeletedEntry' ] ; if ( ! \ in_array ( $ type , $ validTypes , true ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Unexpected type "%s".' , $ type ) ) ; } $ this -> type = $ type ; return $ this ; }
10827	public static function words ( array $ words , $ style = '' , $ separator = ', ' ) { self :: write ( implode ( $ separator , $ words ) , $ style ) ; }
8778	public function redirect ( $ data = null , int $ statusCode = 301 , $ secure = false ) { if ( substr ( $ data , 0 , 4 ) === 'http' || substr ( $ data , 0 , 5 ) === 'https' ) { header ( 'Location: ' . $ data , true , $ statusCode ) ; } else { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . $ data : $ this -> url ; header ( 'Location: ' . $ this -> getUrl ( $ data , $ secure ) , true , $ statusCode ) ; } die ( ) ; }
11527	public function registerPackageHelpers ( ) { foreach ( $ this -> packageHelpers as $ helper ) { $ dashName = last ( explode ( '/' , $ helper ) ) ; $ underscoreName = str_replace ( '-' , '_' , $ dashName ) ; if ( in_array ( '*' , $ this -> packageInclude ) || in_array ( $ dashName , $ this -> packageInclude ) || in_array ( $ underscoreName , $ this -> packageInclude ) ) { require_once $ this -> replaceVariables ( $ this -> packageHelperPattern , compact ( 'dashName' , 'underscoreName' ) ) ; } } }
7339	public function sendMessage ( Chat $ chat , User $ recipient , string $ text , Template $ template = null ) : void { $ sendMessage = new SendMessage ( ) ; if ( $ template !== null ) { $ sendMessage -> reply_markup = $ this -> templateCompiler -> compile ( $ template ) ; } $ sendMessage -> chat_id = $ chat -> getId ( ) ; $ sendMessage -> text = $ text ; $ this -> client -> performApiRequest ( $ sendMessage ) ; $ this -> loop -> run ( ) ; }
10480	private function isTrackedFieldModified ( AbstractDiffItem $ item , ExtractionDescriptorInterface $ relation ) { if ( ! $ item instanceof UpdateDiffItem ) { throw new \ InvalidArgumentException ( 'Wrong diff item type. Got: ' . get_class ( $ item ) ) ; } $ trackedFields = $ relation -> getUpdateFields ( ) ; if ( empty ( $ trackedFields ) ) { return true ; } $ itemRow = $ item -> getItem ( ) ; $ oldItemRow = $ item -> getOldItem ( ) ; foreach ( array_keys ( $ trackedFields ) as $ key ) { if ( array_key_exists ( $ key , $ itemRow ) && $ itemRow [ $ key ] !== $ oldItemRow [ $ key ] ) { return true ; } } return false ; }
12539	public static function dasherize ( $ str , $ replacement = '_' ) { return preg_replace_callback ( '/([A-Z0-9-\s]+)/' , function ( $ match ) use ( $ replacement ) { return $ replacement . strtolower ( $ match [ 1 ] ) ; } , lcfirst ( $ str ) ) ; }
4410	public function onBuildView ( CollectViewParametersEvent $ event ) { $ view = $ event -> getView ( ) ; if ( ! $ view instanceof LayoutViewInterface && ! $ view instanceof RuleViewInterface ) { return ; } if ( $ view -> getContext ( ) !== 'ngadminui' ) { return ; } $ event -> addParameter ( 'is_enterprise' , $ this -> isEnterpriseVersion ) ; }
633	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> delete ( $ table , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
9117	public function unregisterView ( $ view , $ order , $ applicationName = 'default' ) { if ( isset ( $ this -> views [ $ applicationName ] [ $ order ] [ $ view ] ) ) { unset ( $ this -> views [ $ applicationName ] [ $ order ] [ $ view ] ) ; } return $ this ; }
8960	public function sendRequest ( $ path , $ method = 'GET' , $ headers = array ( ) , $ data = '' ) { switch ( $ method ) { case 'GET' : $ response = $ this -> client -> get ( $ path , $ headers ) ; break ; case 'POST' : $ response = $ this -> client -> post ( $ path , $ data , $ headers ) ; break ; } if ( $ response -> code != 200 ) { $ error = htmlspecialchars ( $ response -> body ) ; throw new \ DomainException ( $ error , $ response -> code ) ; } return simplexml_load_string ( $ response -> body ) ; }
12116	public static function getShortName ( $ fqn ) { $ fqn_parts = explode ( '\\' , $ fqn ) ; $ final = array_pop ( $ fqn_parts ) ; if ( empty ( $ fqn_parts ) ) { return $ final ; } $ fqn_caps = preg_replace ( '/[a-z]+/' , '' , $ fqn_parts ) ; return implode ( '\\' , $ fqn_caps ) . '\\' . $ final ; }
1782	public static function isValidFileName ( $ strName ) { if ( $ strName == '' ) { return false ; } if ( preg_match ( '@[\\\\/:*?"<>|]@' , $ strName ) ) { return false ; } if ( preg_match ( '/[\pC]/u' , $ strName ) !== 0 ) { return false ; } if ( Utf8 :: strlen ( $ strName ) > 255 ) { return false ; } return true ; }
3538	public function queryLdapUserObject ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'queryLdapUserObject' , static :: YII2_PROFILE_NAME . 'queryLdapUserObject' ) ; } if ( $ this -> ldapUserObject == null ) { if ( $ this -> username == null ) { throw new \ yii \ base \ Exception ( 'Please set username attribute before calling queryLdapUserObject() function.' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> where ( 'sAMAccountname' , '=' , $ this -> username ) -> get ( ) ; if ( count ( $ userObjectsFound ) != 1 ) { $ this -> ldapUserObject = null ; } else { $ this -> ldapUserObject = $ userObjectsFound [ 0 ] ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'queryLdapUserObject' , static :: YII2_PROFILE_NAME . 'queryLdapUserObject' ) ; } return $ this -> ldapUserObject ; }
5649	public function assign ( $ key , $ value ) { if ( $ this -> $ key === false ) { $ this -> all [ $ key ] = $ value ; } elseif ( ! is_array ( $ this -> $ key ) ) { $ this -> all [ $ key ] = array ( $ this -> $ key , $ value ) ; } else { $ this -> all [ $ key ] [ ] = $ value ; } }
2147	protected function sendNewsletter ( Email $ objEmail , Result $ objNewsletter , $ arrRecipient , $ text , $ html , $ css = null ) { $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ text , $ arrRecipient ) ; if ( ! $ objNewsletter -> sendText ) { if ( $ objNewsletter -> template == '' ) { $ objNewsletter -> template = 'mail_default' ; } $ objTemplate = new BackendTemplate ( $ objNewsletter -> template ) ; $ objTemplate -> setData ( $ objNewsletter -> row ( ) ) ; $ objTemplate -> title = $ objNewsletter -> subject ; $ objTemplate -> body = StringUtil :: parseSimpleTokens ( $ html , $ arrRecipient ) ; $ objTemplate -> charset = Config :: get ( 'characterSet' ) ; $ objTemplate -> recipient = $ arrRecipient [ 'email' ] ; $ objTemplate -> css = $ css ; $ objEmail -> html = $ objTemplate -> parse ( ) ; $ objEmail -> imageDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' ; } try { $ objEmail -> sendTo ( $ arrRecipient [ 'email' ] ) ; } catch ( \ Swift_RfcComplianceException $ e ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( $ objEmail -> hasFailures ( ) ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objEmail , $ objNewsletter , $ arrRecipient , $ text , $ html ) ; } } }
2172	private function purgeSymfonyCache ( ) : void { $ filesystem = new Filesystem ( ) ; $ cacheDir = $ this -> getContainerParameter ( 'kernel.cache_dir' ) ; $ ref = new \ ReflectionObject ( $ this -> container ) ; $ containerDir = basename ( \ dirname ( $ ref -> getFileName ( ) ) ) ; $ finder = Finder :: create ( ) -> depth ( 0 ) -> exclude ( $ containerDir ) -> in ( $ cacheDir ) ; foreach ( $ finder as $ file ) { $ filesystem -> remove ( $ file -> getPathname ( ) ) ; } if ( \ function_exists ( 'opcache_reset' ) ) { opcache_reset ( ) ; } if ( \ function_exists ( 'apc_clear_cache' ) && ! ini_get ( 'apc.stat' ) ) { apc_clear_cache ( ) ; } }
7628	public function getContainerAcl ( $ containerName = '' , $ signedIdentifiers = false ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'GET' , array ( ) , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } if ( $ signedIdentifiers == false ) { $ accessType = $ response -> getHeader ( Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ) ; if ( strtolower ( $ accessType ) == 'true' ) { $ accessType = self :: ACL_PUBLIC_CONTAINER ; } return $ accessType ; } $ result = $ this -> parseResponse ( $ response ) ; if ( ! $ result ) { return array ( ) ; } $ entries = null ; if ( $ result -> SignedIdentifier ) { if ( count ( $ result -> SignedIdentifier ) > 1 ) { $ entries = $ result -> SignedIdentifier ; } else { $ entries = array ( $ result -> SignedIdentifier ) ; } } $ returnValue = array ( ) ; foreach ( $ entries as $ entry ) { $ returnValue [ ] = new SignedIdentifier ( $ entry -> Id , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Start ? $ entry -> AccessPolicy -> Start : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Expiry ? $ entry -> AccessPolicy -> Expiry : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Permission ? $ entry -> AccessPolicy -> Permission : '' : '' ) ; } return $ returnValue ; }
8467	public static function addBackSlash ( $ uri , $ position = 'end' ) { switch ( $ position ) { case 'top' : $ uri = '/' . ltrim ( $ uri , '/' ) ; break ; case 'end' : $ uri = rtrim ( $ uri , '/' ) . '/' ; break ; case 'both' : $ uri = ! empty ( $ uri ) ? '/' . trim ( $ uri , '/' ) . '/' : '' ; break ; default : $ uri = false ; } return $ uri ; }
6412	public static function all ( IteratorAggregate $ iterable , callable $ predicate ) : bool { return Iterators :: all ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ predicate ) ; }
1585	public function withLinks ( $ links ) : self { $ copy = clone $ this ; $ copy -> links = collect ( $ links ) -> all ( ) ; return $ copy ; }
3561	protected function getMutatedType ( $ value , $ dir = 'setter' ) { foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ this -> getValueType ( $ value ) == $ mutated || $ value instanceof $ mutated ) { return $ mutated ; } } }
3520	public function choice ( $ key , $ number , array $ replace = array ( ) , $ locale = null , $ useDB = null ) { $ inplaceEditMode = $ this -> manager -> config ( 'inplace_edit_mode' ) ; if ( $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 2 ) { if ( ! in_array ( $ key , $ this -> usedKeys ) ) { $ this -> usedKeys [ ] = $ key ; } } if ( ! $ this -> suspendInPlaceEdit && $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 1 ) { return $ this -> get ( $ key , $ replace , $ locale , true , $ useDB ) ; } else { if ( $ useDB !== null ) { $ oldUseDB = $ this -> useDB ; $ this -> useDB = $ useDB ; $ retVal = parent :: choice ( $ key , $ number , $ replace , $ locale ) ; $ this -> useDB = $ oldUseDB ; return $ retVal ; } else { return parent :: choice ( $ key , $ number , $ replace , $ locale ) ; } } }
8205	protected function getJobStats ( $ job ) { try { return ( array ) $ this -> getPheanstalk ( ) -> statsJob ( $ job ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
8963	private static function extractDateCriteria ( $ key , array $ criteria ) { $ date = ( ! empty ( $ criteria [ $ key ] ) ) ? $ criteria [ $ key ] : null ; if ( is_string ( $ date ) ) { $ date = \ DateTime :: createFromFormat ( 'Y-m-d' , $ date ) ; } if ( false === $ date ) { throw new InvalidArgumentException ( sprintf ( 'Invalid date/time format provided "%s", expected "%s", or instance of \DateTime class.' , $ criteria [ $ key ] , 'Y-m-d' ) ) ; } return $ date ; }
10606	public function addHeader ( string $ header , $ value ) : void { if ( is_iterable ( $ value ) || is_array ( $ value ) ) { $ iterable = $ value ; $ value = [ ] ; foreach ( $ iterable as $ key => $ entry ) { $ value [ $ key ] = ( string ) $ entry ; } } else { $ value = ( string ) $ value ; } $ this -> headers [ ] = [ $ header , $ value ] ; }
1610	private function _isRedirectRegex ( $ uri ) { if ( preg_match ( '/\/(.*)\/([g|m|i|x|X|s|u|U|A|J|D]+)/m' , $ uri ) === 0 ) { $ i = preg_match_all ( '/(?<!\\\\)\?(?![^(]*\))/' , $ uri , $ matches , PREG_OFFSET_CAPTURE ) ; while ( $ i -- ) { $ x = $ matches [ 0 ] [ $ i ] [ 1 ] ; $ uri = substr_replace ( $ uri , '\?' , $ x , 1 ) ; } $ i = preg_match_all ( '/(?<!\\\\)\/(?![^(]*\))/' , $ uri , $ matches , PREG_OFFSET_CAPTURE ) ; while ( $ i -- ) { $ x = $ matches [ 0 ] [ $ i ] [ 1 ] ; $ uri = substr_replace ( $ uri , '\/' , $ x , 1 ) ; } } if ( @ preg_match ( $ uri , null ) === false ) $ uri = '/^' . $ uri . '$/i' ; if ( @ preg_match ( $ uri , null ) !== false ) return $ uri ; return false ; }
2287	public static function findActiveByEmailAndUsername ( $ strEmail , $ strUsername = null , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "$t.email=? AND $t.login='1' AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ) ; if ( $ strUsername !== null ) { $ arrColumns [ ] = "$t.username=?" ; } return static :: findOneBy ( $ arrColumns , array ( $ strEmail , $ strUsername ) , $ arrOptions ) ; }
2165	public static function convertMultiField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field!=''" ) ; $ objDesc = $ objDatabase -> query ( "DESC $table $field" ) ; if ( $ objDesc -> Type != 'blob' ) { $ objDatabase -> query ( "ALTER TABLE `$table` CHANGE `$field` `$field` blob NULL" ) ; $ objDatabase -> query ( "UPDATE `$table` SET `$field`=NULL WHERE `$field`=''" ) ; } while ( $ objRow -> next ( ) ) { $ arrValues = StringUtil :: deserialize ( $ objRow -> $ field , true ) ; if ( empty ( $ arrValues ) ) { continue ; } $ objHelper = static :: generateHelperObject ( $ arrValues ) ; if ( $ objHelper -> isUuid ) { continue ; } foreach ( $ arrValues as $ k => $ v ) { if ( $ objHelper -> isNumeric ) { $ objFile = FilesModel :: findByPk ( $ objHelper -> value [ $ k ] ) ; $ arrValues [ $ k ] = $ objFile -> uuid ; } else { $ objFile = FilesModel :: findByPath ( $ objHelper -> value [ $ k ] ) ; $ arrValues [ $ k ] = $ objFile -> uuid ; } } $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( serialize ( $ arrValues ) , $ objRow -> id ) ; } }
87	private function getDefaultNormalizer ( ) { $ default = $ this -> getDefault ( ) ; $ trueRegex = $ this -> trueAnswerRegex ; $ falseRegex = $ this -> falseAnswerRegex ; return function ( $ answer ) use ( $ default , $ trueRegex , $ falseRegex ) { if ( is_bool ( $ answer ) ) { return $ answer ; } if ( empty ( $ answer ) && ! empty ( $ default ) ) { return $ default ; } if ( preg_match ( $ trueRegex , $ answer ) ) { return true ; } if ( preg_match ( $ falseRegex , $ answer ) ) { return false ; } return null ; } ; }
637	public function truncateTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> truncateTable ( $ table ) ; return $ this -> setSql ( $ sql ) ; }
9814	public function addEntriesToBlacklist ( $ id , $ entries , $ importName = null ) { if ( $ importName == null ) { $ importName = "phpclient_import_" . uniqid ( ) ; } $ action = new AddEntriesAction ( ) ; $ action -> importName = $ importName ; $ action -> entries = $ entries ; return $ this -> post ( "blacklists/" . $ id . "/actions" , $ action -> toXMLString ( ) ) ; }
7905	public function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , Html :: tag ( 'i' , '' , [ 'class' => 'content icon' ] ) ) ; Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'launch-sidebar icon' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; Html :: addCssClass ( $ this -> toggleButton , 'fixed' ) ; Html :: addCssClass ( $ this -> toggleButton , 'attached' ) ; if ( $ this -> position === static :: POS_LEFT ) { $ position = static :: POS_RIGHT ; } else { $ position = static :: POS_LEFT ; } Html :: addCssClass ( $ this -> toggleButton , $ position ) ; $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
11622	public function api ( string $ link = null , string $ method = null ) : \ TheCMSThread \ Classes \ API { static $ api ; if ( $ api === null ) { $ api = $ this -> container -> get ( "TheCMSThread\\Core\\API" ) ; } return $ api -> set ( $ link , $ method ) ; }
12516	public static function delete ( $ path ) { if ( ! Folder :: exists ( $ path ) ) { return true ; } $ path = Path :: clean ( $ path ) ; if ( trim ( $ path ) === '' ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' : Cannot delete root path' ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
6549	public function add ( $ data ) { $ columnNum = 0 ; $ rowNum = $ this -> iterator -> current ( ) -> getRowIndex ( ) ; foreach ( ( array ) $ data as $ value ) { $ this -> sheet -> setCellValueByColumnAndRow ( $ columnNum ++ , $ rowNum , $ value ) ; } $ this -> iterator -> next ( ) ; }
4551	public function getList ( $ form ) : array { $ objects = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c3c86110000f8016df7de' ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
12656	public function modifyTextContainer ( $ oldName , $ newName , $ content , $ language ) { foreach ( $ this -> languages as $ lang ) { $ modified = false ; $ allTexts = $ this -> getPageTexts ( $ lang ) ; if ( ! isset ( $ allTexts [ $ oldName ] ) ) { throw new \ Exception ( "Text container unknown." ) ; } if ( $ oldName !== $ newName ) { if ( isset ( $ allTexts [ $ newName ] ) ) { throw new \ Exception ( "Text container already exists" ) ; } $ this -> contents [ $ lang ] [ $ newName ] = $ this -> contents [ $ lang ] [ $ oldName ] ; $ this -> contents [ $ lang ] [ $ newName ] [ 'id' ] = $ newName ; $ this -> contents [ $ lang ] [ $ newName ] [ 'name' ] = $ newName ; unset ( $ this -> contents [ $ lang ] [ $ oldName ] ) ; $ modified = true ; } if ( $ language === $ lang ) { $ this -> contents [ $ lang ] [ $ newName ] [ 'content' ] = $ content ; $ this -> contents [ $ lang ] [ $ newName ] [ 'outdated' ] = false ; $ modified = true ; } elseif ( $ language === $ this -> baseLang ) { $ this -> contents [ $ lang ] [ $ newName ] [ 'outdated' ] = true ; $ modified = true ; } if ( $ modified ) { $ this -> writeTextsToFile ( $ lang ) ; } } return $ this -> contents [ $ language ] [ $ newName ] ; }
7058	protected function getStockAdjustmentFromEvent ( ResourceEventInterface $ event ) { $ stockAdjustment = $ event -> getResource ( ) ; if ( ! $ stockAdjustment instanceof StockAdjustmentInterface ) { throw new InvalidArgumentException ( "Expected instance of " . StockAdjustmentInterface :: class ) ; } return $ stockAdjustment ; }
3533	public static function findByAttribute ( $ attribute , $ searchValue ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> select ( 'samaccountname' ) -> where ( $ attribute , '=' , $ searchValue ) -> get ( ) ; $ userObjectReturn = null ; if ( count ( $ userObjectsFound ) == 1 ) { $ userObjectReturn = static :: findByUsername ( $ userObjectsFound [ 0 ] [ 'samaccountname' ] [ 0 ] ) ; } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } return $ userObjectReturn ; }
2494	protected function escapeExpressions ( $ string , $ allowWildcard = false ) { if ( $ allowWildcard ) { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~?:\\ ' ) ; } else { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~*?:\\ ' ) ; } return preg_replace_callback ( '/([' . $ reservedCharacters . '])/' , function ( $ matches ) { return '\\' . $ matches [ 0 ] ; } , $ string ) ; }
2538	protected function initSoapClient ( $ wsdlId ) { $ wsdlPath = WsdlAnalyser :: $ wsdlIds [ $ wsdlId ] ; $ client = new Client \ SoapClient ( $ wsdlPath , $ this -> makeSoapClientOptions ( ) , $ this -> params -> logger ) ; return $ client ; }
5600	public static function getSeverityAsString ( $ severity ) { static $ map = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_WARNING => 'E_USER_WARNING' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , E_DEPRECATED => 'E_DEPRECATED' , E_USER_DEPRECATED => 'E_USER_DEPRECATED' , E_ALL => 'E_ALL' ) ; return $ map [ $ severity ] ; }
9446	public function getConfigsPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ subpath = $ this -> packOptions [ 'configs_subpath' ] ; $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) . '/' . $ subpath ; } return $ paths [ $ me ] ; }
12766	public function run ( ) : void { $ this -> isRan = true ; foreach ( $ this -> getAll ( ) as $ header ) { header ( $ header ) ; } }
3743	protected function setLanguage ( $ language = '' ) { $ previousLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( ! empty ( $ language ) && ( $ GLOBALS [ 'TL_LANGUAGE' ] !== $ language ) ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ language ; } return $ previousLanguage ; }
2297	public static function handleRunOnce ( ) { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/runonce.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { return ; } foreach ( $ files as $ file ) { try { include $ file ; } catch ( \ Exception $ e ) { } $ strRelpath = StringUtil :: stripRootDir ( $ file ) ; if ( ! unlink ( $ file ) ) { throw new \ Exception ( "The file $strRelpath cannot be deleted. Please remove the file manually and correct the file permission settings on your server." ) ; } System :: log ( "File $strRelpath ran once and has then been removed successfully" , __METHOD__ , TL_GENERAL ) ; } }
2012	public static function addNamespace ( $ name ) { @ trigger_error ( 'Using ClassLoader::addNamespace() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ in_array ( $ name , self :: $ namespaces ) ) { return ; } array_unshift ( self :: $ namespaces , $ name ) ; }
6109	public function permAssign ( $ permid , $ permvalue ) { return $ this -> getParent ( ) -> channelPermAssign ( $ this -> getId ( ) , $ permid , $ permvalue ) ; }
2996	public function set ( $ key , $ val ) { $ this -> smtp -> set ( $ key , $ this -> encode ( $ val ) ) ; }
5952	public function setTransition ( $ transition ) { if ( $ transition instanceof SlideTransition ) { $ this -> transition = $ transition ; } elseif ( is_array ( $ transition ) ) { $ this -> transition = new SlideTransition ( $ transition ) ; } else { $ this -> transition = null ; trigger_error ( 'Argument must be an object of class SlideTransition. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
958	public function remainingTrialDaysFromCancel ( ) { if ( ! $ this -> isTrial ( ) ) { return ; } $ cancelledDate = Carbon :: parse ( $ this -> cancelled_on ) ; $ trialEndsDate = Carbon :: parse ( $ this -> trial_ends_on ) ; if ( $ this -> isCancelled ( ) && $ cancelledDate -> lte ( $ trialEndsDate ) ) { return $ this -> trial_days - ( $ this -> trial_days - $ cancelledDate -> diffInDays ( $ trialEndsDate ) ) ; } return 0 ; }
12776	protected function write ( $ namespace , array $ data ) { $ file = $ this -> adapter -> getFileName ( $ namespace ) ; $ contents = $ this -> adapter -> prepareForWriting ( $ data ) ; if ( ! $ this -> fileSystem -> has ( $ file ) ) { $ this -> fileSystem -> write ( $ file , $ contents ) ; } $ this -> fileSystem -> update ( $ file , $ contents ) ; }
12270	protected function dispatchSlotsEvent ( $ baseEventName , Page $ page , array $ slots ) { $ eventNames = $ this -> generateEventNames ( $ baseEventName , $ page ) ; $ event = new SlotsRenderingEvent ( $ slots ) ; foreach ( $ eventNames as $ eventName ) { $ event = Dispatcher :: dispatch ( $ eventName , $ event ) ; } return $ event -> getSlots ( ) ; }
7440	protected function reloadModule ( Wrapper $ wrapper , $ module ) { $ moduleStatus = $ wrapper -> ModuleManager -> reload ( $ module ) ; $ module = Inflector :: camelize ( $ module ) ; switch ( $ moduleStatus ) { case 'AU' : $ wrapper -> Channel -> sendMessage ( 'The Module `' . $ module . '` doesn\'t exist and cannot be reloaded.' ) ; break ; case 'AL' : $ wrapper -> Channel -> sendMessage ( 'The Module `' . $ module . '` is already loaded.' ) ; break ; case 'L' : $ wrapper -> Channel -> sendMessage ( 'Module `' . $ module . '` reloaded successfully.' ) ; break ; case 'NF' : $ wrapper -> Channel -> sendMessage ( 'Failed to reload the Module `' . $ module . '`.' ) ; break ; } }
11016	public function addDefaultListeners ( ) { $ this -> dispatcher -> addListener ( Events :: EVENT_BEFORE_CONTROLLER_RUN , $ this ) ; $ this -> dispatcher -> addListener ( Events :: EVENT_AFTER_CONTROLLER_RUN , $ this ) ; }
12002	static public function generate ( $ length = 16 , $ algorithm = 'sha256' ) { if ( ! in_array ( $ algorithm , self :: $ allowedAlgorithm ) ) { throw new Exception ( "Hash algorithm $algorithm doesn't exists!" ) ; } $ salt = hash ( $ algorithm , time ( ) ) ; return substr ( hash ( $ algorithm , ( mt_rand ( self :: RAND_MIN , self :: RAND_MAX ) % $ length ) . $ salt . mt_rand ( self :: RAND_MIN , self :: RAND_MAX ) ) , self :: CUT_LEN , $ length ) ; }
5120	private function requestGate ( string $ method , string $ path , array $ header = [ ] , array $ body = [ ] , array $ options = [ ] ) : string { if ( empty ( $ this -> accessToken ) ) { $ this -> renewAuthToken ( ) ; } $ request = new \ GuzzleHttp \ Psr7 \ Request ( $ method , $ path , array_merge ( $ this -> options -> get ( 'default_headers' ) , $ header ) , $ this -> createBodyForRequest ( $ this -> prepareMultipartData ( $ body ) ) ) ; return ( string ) $ this -> sendRequest ( $ request ) ; }
428	public function init ( ) { if ( $ this -> controllerNamespace === null ) { $ class = get_class ( $ this ) ; if ( ( $ pos = strrpos ( $ class , '\\' ) ) !== false ) { $ this -> controllerNamespace = substr ( $ class , 0 , $ pos ) . '\\controllers' ; } } }
11043	function is_space ( $ char ) { $ asc = ord ( $ char ) ; if ( $ asc == 32 ) { return TRUE ; } elseif ( $ asc > 8 && $ asc < 14 ) { return TRUE ; } return FALSE ; }
9533	private function preloadParameters ( $ argv ) { array_shift ( $ argv ) ; $ this -> argv = [ ] ; while ( ( $ argument = array_shift ( $ argv ) ) != null ) { switch ( substr ( $ argument , 0 , 1 ) ) { case '\'' : { $ this -> parseQuote ( $ argv , $ argument , '\'' ) ; break ; } case '"' : { $ this -> parseQuote ( $ argv , $ argument , '"' ) ; break ; } default : { $ this -> argv [ ] = $ argument ; } } } }
8881	private function isValidRelativePath ( string $ relativePath , string $ cwd ) : bool { $ valid = false ; if ( './' === substr ( $ relativePath , 0 , 2 ) ) { $ tmpPath = $ cwd . DIRECTORY_SEPARATOR . substr ( $ relativePath , 2 , strlen ( $ relativePath ) ) ; $ valid = $ this -> isValidFullPath ( $ tmpPath ) ; } return $ valid ; }
3705	public function handle ( CreateMetaModelEvent $ event ) { if ( null === $ metaModel = $ event -> getMetaModel ( ) ) { return ; } foreach ( $ this -> attributeFactory -> createAttributesForMetaModel ( $ metaModel ) as $ attribute ) { $ metaModel -> addAttribute ( $ attribute ) ; } }
6349	public static function limit ( Iterator $ iterator , int $ limitSize ) : Iterator { Preconditions :: checkArgument ( 0 <= $ limitSize ) ; return new NoRewindNecessaryLimitIterator ( $ iterator , $ limitSize ) ; }
9701	public function addXfWriter ( Style $ style , $ isStyleXf = false ) { $ xfWriter = new Xf ( $ style ) ; $ xfWriter -> setIsStyleXf ( $ isStyleXf ) ; $ fontIndex = $ this -> addFont ( $ style -> getFont ( ) ) ; $ xfWriter -> setFontIndex ( $ fontIndex ) ; $ xfWriter -> setFgColor ( $ this -> addColor ( $ style -> getFill ( ) -> getStartColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setBgColor ( $ this -> addColor ( $ style -> getFill ( ) -> getEndColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setBottomColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getBottom ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setTopColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getTop ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setRightColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getRight ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setLeftColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getLeft ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setDiagColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getDiagonal ( ) -> getColor ( ) -> getRGB ( ) ) ) ; if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false ) { $ numberFormatHashCode = $ style -> getNumberFormat ( ) -> getHashCode ( ) ; if ( isset ( $ this -> addedNumberFormats [ $ numberFormatHashCode ] ) ) { $ numberFormatIndex = $ this -> addedNumberFormats [ $ numberFormatHashCode ] ; } else { $ numberFormatIndex = 164 + count ( $ this -> numberFormats ) ; $ this -> numberFormats [ $ numberFormatIndex ] = $ style -> getNumberFormat ( ) ; $ this -> addedNumberFormats [ $ numberFormatHashCode ] = $ numberFormatIndex ; } } else { $ numberFormatIndex = ( int ) $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) ; } $ xfWriter -> setNumberFormatIndex ( $ numberFormatIndex ) ; $ this -> xfWriters [ ] = $ xfWriter ; $ xfIndex = count ( $ this -> xfWriters ) - 1 ; return $ xfIndex ; }
7893	public function add ( $ property_name , $ value ) { $ this -> validateProperty ( $ property_name , $ value ) ; $ this -> data [ $ property_name ] [ ] = & $ value ; return $ this ; }
10895	public function addCollection ( UriCollection $ collection ) { foreach ( $ collection -> all ( ) as $ name => $ uri ) { unset ( $ this -> uris [ $ name ] ) ; $ this -> uris [ $ name ] = $ uri ; } $ this -> resources = array_merge ( $ this -> resources , $ collection -> getResources ( ) ) ; }
8737	public function insertGetId ( array $ values , $ sequence = null ) { list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; if ( $ id = $ this -> query -> insertGetId ( $ values , $ sequence ) ) { if ( $ this -> insertI18n ( $ i18nValues , $ id ) ) { return $ id ; } } return false ; }
4210	private function phpDocParam ( $ param , $ className ) { $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( \ array_key_exists ( 'defaultValue' , $ param ) ) { $ defaultValue = $ param [ 'defaultValue' ] ; if ( \ in_array ( $ defaultValue , array ( 'true' , 'false' , 'null' ) ) ) { $ defaultValue = \ json_decode ( $ defaultValue ) ; } elseif ( \ is_numeric ( $ defaultValue ) ) { $ defaultValue = $ defaultValue * 1 ; } elseif ( \ preg_match ( '/^array\(\s*\)|\[\s*\]$/i' , $ defaultValue ) ) { $ defaultValue = array ( ) ; } elseif ( \ preg_match ( '/^(self::)?([^\(\)\[\]]+)$/i' , $ defaultValue , $ matches ) ) { if ( $ matches [ 1 ] ) { if ( \ defined ( $ className . '::' . $ matches [ 2 ] ) ) { $ constantName = $ matches [ 0 ] ; $ defaultValue = \ constant ( $ className . '::' . $ matches [ 2 ] ) ; } } elseif ( \ defined ( $ defaultValue ) ) { $ constantName = $ defaultValue ; $ defaultValue = \ constant ( $ defaultValue ) ; } } else { $ defaultValue = \ trim ( $ defaultValue , '\'"' ) ; } } return array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , ) ; }
511	protected function formatOptionHelp ( $ name , $ required , $ type , $ defaultValue , $ comment ) { $ comment = trim ( $ comment ) ; $ type = trim ( $ type ) ; if ( strncmp ( $ type , 'bool' , 4 ) === 0 ) { $ type = 'boolean, 0 or 1' ; } if ( $ defaultValue !== null && ! is_array ( $ defaultValue ) ) { if ( $ type === null ) { $ type = gettype ( $ defaultValue ) ; } if ( is_bool ( $ defaultValue ) ) { $ defaultValue = ( int ) $ defaultValue ; } if ( is_string ( $ defaultValue ) ) { $ defaultValue = "'" . $ defaultValue . "'" ; } else { $ defaultValue = var_export ( $ defaultValue , true ) ; } $ doc = "$type (defaults to $defaultValue)" ; } else { $ doc = $ type ; } if ( $ doc === '' ) { $ doc = $ comment ; } elseif ( $ comment !== '' ) { $ doc .= "\n" . preg_replace ( '/^/m' , ' ' , $ comment ) ; } $ name = $ required ? "$name (required)" : $ name ; return $ doc === '' ? $ name : "$name: $doc" ; }
476	public function createTable ( $ table , $ columns , $ options = null ) { $ time = $ this -> beginCommand ( "create table $table" ) ; $ this -> db -> createCommand ( ) -> createTable ( $ table , $ columns , $ options ) -> execute ( ) ; foreach ( $ columns as $ column => $ type ) { if ( $ type instanceof ColumnSchemaBuilder && $ type -> comment !== null ) { $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ type -> comment ) -> execute ( ) ; } } $ this -> endCommand ( $ time ) ; }
11784	public function update ( $ pageId , $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'page_id' => intval ( $ pageId ) , 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
7773	protected function validateAgainstRule ( $ field , $ value , $ rule , array $ args ) { $ ruleToCall = $ this -> getRuleToCall ( $ rule ) ; $ passed = call_user_func_array ( $ ruleToCall , [ $ value , $ this -> input , $ args ] ) ; if ( ! $ passed ) { $ this -> handleError ( $ field , $ value , $ rule , $ args ) ; return $ this -> canSkipRule ( $ ruleToCall , $ value ) ; } return true ; }
7056	protected static function dayOfYear ( $ y , $ m , $ d ) { $ l = ( ( int ) $ y % 4 == 0 && ( int ) $ y % 100 != 0 ) || ( int ) $ y % 400 == 0 ; $ k = $ l ? 1 : 2 ; $ n = intval ( 275 * ( int ) $ m / 9 ) - $ k * intval ( ( ( int ) $ m + 9 ) / 12 ) + ( int ) $ d - 30 ; return ( int ) $ n ; }
3832	protected function validateWidget ( $ widget , $ value ) { if ( null === $ value ) { return ; } $ widget -> setInputCallback ( function ( ) use ( $ value ) { return $ value ; } ) ; $ widget -> validate ( ) ; }
8807	public function set ( $ key , $ value , $ time = 0 ) { if ( is_array ( $ key ) ) { foreach ( $ key as $ k => $ v ) { setcookie ( $ k , $ v , ( $ time == 0 ? 0 : time ( ) + $ time ) , '/' ) ; $ _COOKIE [ $ k ] = $ v ; } } else { setcookie ( $ key , $ value , ( $ time == 0 ? 0 : time ( ) + $ time ) , '/' ) ; $ _COOKIE [ $ key ] = $ value ; } return ; }
11715	protected function getCachedToken ( array $ options ) { $ authOptions = array_intersect_key ( $ options , $ this -> api -> postTokens ( ) [ 'params' ] ) ; $ optionsToHash = array_merge ( $ authOptions , array_intersect_key ( $ options , [ 'authUrl' => true , ] ) ) ; if ( isset ( $ optionsToHash [ 'user' ] ) ) { unset ( $ optionsToHash [ 'user' ] [ 'password' ] ) ; } $ key = 'openstack-token-' . md5 ( json_encode ( $ optionsToHash ) ) ; if ( $ this -> cache -> has ( $ key ) ) { return $ this -> cache -> get ( $ key ) ; } $ token = $ this -> generateToken ( $ authOptions ) ; $ cachedToken = $ token -> export ( ) ; $ expiresAt = new DateTime ( $ cachedToken [ 'expires_at' ] ) ; $ this -> cache -> put ( $ key , $ cachedToken , $ expiresAt -> sub ( new DateInterval ( 'PT1M' ) ) ) ; return $ cachedToken ; }
12832	private function _processModifiers ( $ expression ) { $ mStart = '' ; $ mEnd = '' ; $ rawEcho = false ; if ( strpos ( $ expression , '|' ) !== false && strpos ( $ expression , '||' ) === false ) { $ modifiers = explode ( '|' , $ expression ) ; $ expression = array_shift ( $ modifiers ) ; foreach ( $ modifiers as $ modifier ) { $ params = array ( ) ; if ( strpos ( $ modifier , ':' ) !== false ) { $ params = explode ( ':' , $ modifier ) ; $ modifier = array_shift ( $ params ) ; } if ( $ modifier == 'raw' ) { $ rawEcho = true ; continue ; } if ( $ this -> isCallable ( $ modifier ) ) { $ mStart = $ modifier . '(' . $ mStart ; if ( $ modifier !== 'raw' ) { foreach ( $ params as $ param ) { $ mEnd .= ', ' . $ this -> compileExpression ( $ param ) ; } } $ mEnd .= ')' ; } else { throw new \ Exception ( 'SLOT compiler error: undefined modifier ' . $ modifier ) ; } } } return array ( $ expression , $ mStart , $ mEnd , $ rawEcho ) ; }
1185	public function resolver ( $ field ) { return function ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) use ( $ field ) { return $ this -> resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) ; } ; }
7039	public function getShippedAt ( $ latest = false ) { if ( 0 == $ this -> shipments -> count ( ) ) { return null ; } $ criteria = Criteria :: create ( ) ; $ criteria -> andWhere ( Criteria :: expr ( ) -> eq ( 'return' , false ) ) -> andWhere ( Criteria :: expr ( ) -> in ( 'state' , [ ShipmentStates :: STATE_READY , ShipmentStates :: STATE_SHIPPED ] ) ) -> orderBy ( [ 'createdAt' => $ latest ? Criteria :: DESC : Criteria :: ASC ] ) ; $ shipments = $ this -> shipments ; $ shipments = $ shipments -> matching ( $ criteria ) ; if ( false !== $ shipment = $ shipments -> first ( ) ) { return $ shipment -> getCreatedAt ( ) ; } return null ; }
4057	private function convertAttribute ( array $ property , $ condition , array & $ legend ) { if ( ! isset ( $ property [ 'col_name' ] ) ) { return ; } $ legend [ 'properties' ] [ ] = [ 'name' => $ property [ 'col_name' ] , 'condition' => $ condition ( $ property ) ] ; }
9123	private function retrieveAndParseResponse ( $ requestType ) { $ this -> payload = new MemoryStream ( ) ; $ this -> headers = array ( ) ; $ delimiterFound = false ; $ tmp = "" ; $ numBytes = 1 ; $ start = time ( ) ; while ( true ) { if ( ! $ this -> checkConnection ( $ start ) ) { continue ; } $ c = $ this -> read ( $ numBytes ) ; if ( $ c == null ) { break ; } $ start = time ( ) ; $ tmp .= $ c ; if ( ! $ delimiterFound ) { $ this -> handleHeader ( $ delimiterFound , $ numBytes , $ tmp ) ; } if ( $ delimiterFound ) { if ( $ requestType == 'HEAD' ) { break ; } $ this -> payload -> write ( $ tmp ) ; $ tmp = "" ; if ( $ this -> checkContentLengthExceeded ( ) ) { break ; } } } $ size = $ this -> payload -> count ( ) ; if ( $ size == 0 ) { return ; } $ this -> payload -> reset ( ) ; $ mayCompressed = $ this -> payload -> read ( $ size ) ; switch ( $ this -> getContentEncoding ( ) ) { case 'gzip' : $ uncompressed = gzdecode ( strstr ( $ mayCompressed , "\x1f\x8b" ) ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; case 'deflate' : $ uncompressed = gzuncompress ( $ mayCompressed ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; default : break ; } $ this -> payload -> reset ( ) ; }
7437	public static function handleFatal ( ) { $ error = error_get_last ( ) ; if ( null !== $ error ) { self :: render ( $ error [ "type" ] , $ error [ "message" ] , $ error [ "file" ] , $ error [ "line" ] ) ; } }
2497	private function getCoreCriterion ( array $ languageCodes , $ useAlwaysAvailable ) { if ( ! empty ( $ languageCodes ) ) { $ filter = $ this -> getLanguageFilter ( $ languageCodes ) ; if ( $ useAlwaysAvailable ) { $ filter = new LogicalOr ( array ( $ filter , $ this -> getAlwaysAvailableFilter ( $ languageCodes ) , ) ) ; } return $ filter ; } return new CustomField ( self :: FIELD_IS_MAIN_LANGUAGE , Operator :: EQ , true ) ; }
4434	public function call ( string $ command , ... $ arguments ) { $ arguments = func_get_args ( ) ; array_shift ( $ arguments ) ; return $ this -> __call ( $ command , $ arguments ) ; }
1947	private function setCacheHeaders ( Response $ response ) { global $ objPage ; if ( ( $ objPage -> cache === false || $ objPage -> cache < 1 ) && ( $ objPage -> clientCache === false || $ objPage -> clientCache < 1 ) ) { $ response -> headers -> addCacheControlDirective ( 'no-cache' ) ; $ response -> headers -> addCacheControlDirective ( 'no-store' ) ; return $ response -> setPrivate ( ) ; } if ( FE_USER_LOGGED_IN === true || BE_USER_LOGGED_IN === true || $ objPage -> protected || $ this -> hasAuthenticatedBackendUser ( ) ) { $ response -> headers -> addCacheControlDirective ( 'no-cache' ) ; $ response -> headers -> addCacheControlDirective ( 'no-store' ) ; return $ response -> setPrivate ( ) ; } if ( $ objPage -> clientCache > 0 ) { $ response -> setMaxAge ( $ objPage -> clientCache ) ; } if ( $ objPage -> cache > 0 ) { $ response -> setSharedMaxAge ( $ objPage -> cache ) ; } if ( System :: getContainer ( ) -> has ( 'fos_http_cache.http.symfony_response_tagger' ) ) { $ responseTagger = System :: getContainer ( ) -> get ( 'fos_http_cache.http.symfony_response_tagger' ) ; $ responseTagger -> addTags ( array ( 'contao.db.tl_page.' . $ objPage -> id ) ) ; } return $ response ; }
10861	protected function createObjectUsingFactory ( string $ typeName , Factory $ factory , ? bool $ nullable = false ) : ? object { $ this -> underConstruction [ $ typeName ] = true ; try { $ object = ( $ factory -> callback ) ( ... $ this -> populateArguments ( $ factory -> getReflection ( ) , null , $ typeName ) ) ; if ( ! $ object instanceof $ typeName ) { if ( $ object === null && $ nullable ) { return null ; } $ type = \ is_object ( $ object ) ? \ get_class ( $ object ) : \ gettype ( $ object ) ; throw new ContainerException ( \ sprintf ( 'Factory must return an instance of %s, returned value is %s' , $ typeName , $ type ) ) ; } } finally { unset ( $ this -> underConstruction [ $ typeName ] ) ; } return $ object ; }
6569	public function unsetData ( ) : void { foreach ( array_keys ( $ this -> data ) as $ var ) { if ( ! in_array ( $ var , self :: ALL_HEADERS ) ) { unset ( $ this -> data [ $ var ] ) ; } } }
2189	public function unregister ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; if ( ! isset ( $ this -> arrIdentities [ $ intObjectId ] ) ) { return ; } $ strTable = $ objModel -> getTable ( ) ; $ strPk = $ objModel -> getPk ( ) ; $ intPk = $ objModel -> $ strPk ; unset ( $ this -> arrIdentities [ $ intObjectId ] ) ; unset ( $ this -> arrRegistry [ $ strTable ] [ $ intPk ] ) ; $ objModel -> onUnregister ( $ this ) ; }
4878	public function setUser ( UserInterface $ user ) { if ( $ this -> user ) { $ this -> getPermissions ( ) -> revoke ( $ this -> user , Permissions :: PERMISSION_ALL , false ) ; } $ this -> user = $ user ; $ this -> getPermissions ( ) -> grant ( $ user , Permissions :: PERMISSION_ALL ) ; return $ this ; }
6041	public function search ( $ sessionId , Search $ search , $ hits ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'search' => $ search , 'hits' => $ hits ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/search' , $ parameters , true ) ; return $ result ; }
11896	protected function generateIV ( ) { $ sizeIV = $ this -> getSizeIV ( ) ; if ( $ sizeIV === 0 ) { return $ this ; } $ this -> setIV ( mcrypt_create_iv ( $ sizeIV , MCRYPT_RAND ) ) ; return $ this ; }
12797	public function mb_str_pad ( $ input , $ length , $ string = ' ' , $ type = STR_PAD_LEFT ) { return str_pad ( $ input , $ length + strlen ( $ input ) - mb_strlen ( $ input ) , $ string , $ type ) ; }
9338	public function isSupplementary ( Angle $ angle ) { $ out = new self ( $ this -> float_rad + $ angle -> rad ) ; return $ out -> isStraight ( ) ; }
245	public function getColumn ( $ name ) { return isset ( $ this -> columns [ $ name ] ) ? $ this -> columns [ $ name ] : null ; }
10527	public function getValue ( ) { static $ ip = null ; if ( is_null ( $ ip ) ) { $ ip = $ this -> getIpAddressFromProxy ( ) ; if ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) ) { $ ip = $ _SERVER [ 'REMOTE_ADDR' ] ; } } return $ ip ; }
2995	protected function encodeHeader ( $ str ) { if ( extension_loaded ( 'iconv' ) ) { $ out = iconv_mime_encode ( 'Subject' , $ str , [ 'input-charset' => 'UTF-8' , 'output-charset' => $ this -> charset ] ) ; $ out = substr ( $ out , strlen ( 'Subject: ' ) ) ; } elseif ( extension_loaded ( 'mbstring' ) ) { mb_internal_encoding ( 'UTF-8' ) ; $ out = mb_encode_mimeheader ( $ str , $ this -> charset , 'B' , static :: $ EOL , strlen ( 'Subject: ' ) ) ; } else $ out = wordwrap ( $ str , 65 , static :: $ EOL ) ; return $ out ; }
1512	public function read ( StoreInterface $ store , FetchResource $ request ) { $ result = $ this -> doRead ( $ store , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ result ) ; }
1636	protected function formatQuery ( $ sql , array $ bindings , $ time , $ connection ) { $ data = [ 'sql' => $ sql ] ; foreach ( $ bindings as $ index => $ binding ) { $ data [ "binding {$index}" ] = $ binding ; } $ data [ 'time' ] = "{$time}ms" ; $ data [ 'connection' ] = $ connection ; return $ data ; }
12383	public static function perMonth ( $ months = 1 , $ date_format = "Y-m" ) { $ hits_per_month = [ ] ; for ( $ i = 1 ; $ i <= $ months ; $ i ++ ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subMonths ( $ i ) -> firstOfMonth ( ) , Carbon :: now ( ) -> subMonths ( $ i ) -> lastOfMonth ( ) ) ; $ hits_per_month [ Carbon :: now ( ) -> subMonths ( $ i ) -> format ( $ date_format ) ] = $ hits_count ; } return $ hits_per_month ; }
9845	public function createSymmetricEncryptedRequest ( string $ method , string $ uri , string $ body , SharedEncryptionKey $ key , array $ headers = [ ] ) : RequestInterface { return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: encrypt ( $ body , $ key ) ) ) , [ ] ) ; }
635	public function renameTable ( $ table , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameTable ( $ table , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
7015	private function format_y ( & $ str ) { if ( strstr ( $ str , '%y' ) ) $ str = str_replace ( '%y' , substr ( $ this -> year , strlen ( $ this -> year ) - 2 , 2 ) , $ str ) ; }
288	protected function negotiateLanguage ( $ request ) { if ( ! empty ( $ this -> languageParam ) && ( $ language = $ request -> get ( $ this -> languageParam ) ) !== null ) { if ( is_array ( $ language ) ) { return reset ( $ this -> languages ) ; } if ( isset ( $ this -> languages [ $ language ] ) ) { return $ this -> languages [ $ language ] ; } foreach ( $ this -> languages as $ key => $ supported ) { if ( is_int ( $ key ) && $ this -> isLanguageSupported ( $ language , $ supported ) ) { return $ supported ; } } return reset ( $ this -> languages ) ; } foreach ( $ request -> getAcceptableLanguages ( ) as $ language ) { if ( isset ( $ this -> languages [ $ language ] ) ) { return $ this -> languages [ $ language ] ; } foreach ( $ this -> languages as $ key => $ supported ) { if ( is_int ( $ key ) && $ this -> isLanguageSupported ( $ language , $ supported ) ) { return $ supported ; } } } return reset ( $ this -> languages ) ; }
12746	protected function onMovedResponse ( CommandInterface $ command , $ details ) { list ( $ slot , $ connectionID ) = explode ( ' ' , $ details , 2 ) ; if ( ! $ connection = $ this -> getConnectionById ( $ connectionID ) ) { $ connection = $ this -> createConnection ( $ connectionID ) ; } if ( $ this -> useClusterSlots ) { $ this -> askSlotMap ( $ connection ) ; } $ this -> move ( $ connection , $ slot ) ; $ response = $ this -> executeCommand ( $ command ) ; return $ response ; }
3263	public static function format ( $ value ) { return preg_replace ( [ '/:symbol/' , '/:price/' , '/:currency/' ] , [ Config :: get ( 'shop.currency_symbol' ) , $ value , Config :: get ( 'shop.currency' ) ] , Config :: get ( 'shop.display_price_format' ) ) ; }
5214	private function findBinding ( $ type , $ name ) { $ bindingName = $ this -> bindingName ( $ name ) ; if ( null !== $ bindingName && isset ( $ this -> index [ $ type . '#' . $ bindingName ] ) ) { return $ this -> index [ $ type . '#' . $ bindingName ] ; } if ( isset ( $ this -> index [ $ type ] ) ) { return $ this -> index [ $ type ] ; } if ( ! in_array ( $ type , [ PropertyBinding :: TYPE , ConstantBinding :: TYPE , ListBinding :: TYPE , MapBinding :: TYPE ] ) ) { $ this -> index [ $ type ] = $ this -> getAnnotatedBinding ( new \ ReflectionClass ( $ type ) ) ; return $ this -> index [ $ type ] ; } return null ; }
5666	private function attachLabels ( $ widgets_by_id , $ labels ) { foreach ( $ labels as $ label ) { $ for = $ label -> getFor ( ) ; if ( $ for and isset ( $ widgets_by_id [ $ for ] ) ) { $ text = $ label -> getText ( ) ; foreach ( $ widgets_by_id [ $ for ] as $ widget ) { $ widget -> setLabel ( $ text ) ; } } } }
5663	private function dequote ( $ quoted ) { if ( preg_match ( '/^(\'([^\']*)\'|"([^"]*)")$/' , $ quoted , $ matches ) ) { return isset ( $ matches [ 3 ] ) ? $ matches [ 3 ] : $ matches [ 2 ] ; } return $ quoted ; }
412	public function getPort ( ) { if ( $ this -> _port === null ) { $ serverPort = $ this -> getServerPort ( ) ; $ this -> _port = ! $ this -> getIsSecureConnection ( ) && $ serverPort !== null ? $ serverPort : 80 ; } return $ this -> _port ; }
11442	public function getRegistry ( $ var = null , $ section = false , $ default = false ) { if ( is_null ( $ var ) ) { return ; } if ( $ section && isset ( $ this -> registry [ $ section ] ) ) { if ( isset ( $ this -> registry [ $ section ] [ $ var ] ) ) { return $ this -> registry [ $ section ] [ $ var ] ; } else { return $ default ; } } if ( isset ( $ this -> registry [ $ var ] ) ) { return $ this -> registry [ $ var ] ; } return $ default ; }
8236	protected function checkServerConfiguration ( ) { $ pico = $ this -> picoAuth -> getPico ( ) ; $ configDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfigDir ( ) ) ; $ configFile = $ configDir . "/config.yml" ; $ contentDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfig ( 'content_dir' ) ) ; $ indexFile = $ contentDir . "/index" . $ pico -> getConfig ( 'content_ext' ) ; $ urls = array ( 'dir_listing' => $ configDir , 'config_file' => $ configFile , 'content_file' => $ indexFile ) ; $ this -> httpsTest ( ) ; $ this -> webRootDirsTest ( ) ; $ this -> picoAuth -> addOutput ( "installer_urltest" , $ urls ) ; }
11978	public function transform ( $ message ) { if ( is_array ( $ message ) ) { $ class = News :: class ; } else { if ( is_string ( $ message ) ) { $ message = new Text ( [ 'content' => $ message ] ) ; } $ class = get_class ( $ message ) ; } $ handle = 'transform' . substr ( $ class , strlen ( 'EasyWeChat\Message\\' ) ) ; return method_exists ( $ this , $ handle ) ? $ this -> $ handle ( $ message ) : [ ] ; }
9580	public function setDeferredChannel ( $ channel , callable $ callback ) { if ( isset ( $ this -> channels [ $ channel ] ) ) { throw new InvalidArgumentException ( "Channel $channel is already defined" ) ; } $ this -> deferredChannels [ $ channel ] = $ callback ; }
2612	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getAuthDictionary ( $ activeVersion ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ user = $ this -> getRequest ( ) -> getParam ( 'auth_user' ) ; $ pass = $ this -> getRequest ( ) -> getParam ( 'auth_pass' ) ; $ key = base64_encode ( $ user . ':' . $ pass ) ; $ this -> api -> upsertDictionaryItem ( $ dictionary -> id , $ key , true ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12742	public function removeById ( $ connectionID ) { if ( isset ( $ this -> pool [ $ connectionID ] ) ) { $ this -> slotmap -> reset ( ) ; $ this -> slots = array_diff ( $ this -> slots , array ( $ connectionID ) ) ; unset ( $ this -> pool [ $ connectionID ] ) ; return true ; } return false ; }
9611	public function getAssetUrl ( $ path , $ relative = false ) { if ( substr ( $ path , 0 , 1 ) !== '/' ) { $ path = '/' . $ path ; } if ( $ this -> assetRoot !== null ) { $ base = $ this -> assetRoot ; } else if ( $ relative ) { $ base = $ this -> requests -> getCurrentRequest ( ) -> getBaseUrl ( ) ; } else { $ base = $ this -> getRootUrl ( ) ; } return $ base . $ path ; }
4529	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ content = $ request -> getContent ( ) ; if ( '' === $ content ) { return ; } try { $ filters = json_decode ( $ content , true ) ; } catch ( Exception $ exception ) { throw new BadRequestHttpException ( 'Request body should be an object.' , $ exception ) ; } if ( ! is_array ( $ filters ) ) { throw new BadRequestHttpException ( 'Request body should be an object.' ) ; } $ current = $ request -> attributes -> get ( '_api_filters' , [ ] ) ; $ query = $ request -> query -> all ( ) ; $ filters = array_merge ( $ current , $ query , $ filters ) ; $ request -> attributes -> set ( '_api_filters' , $ filters ) ; }
11722	public function getPosts ( $ limit = null , $ offset = null ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; if ( is_null ( $ limit ) && is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) ) ; } elseif ( is_null ( $ limit ) && ! is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) , $ limit ) ; } elseif ( ! is_null ( $ limit ) && ! is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) , $ limit , $ offset ) ; } return $ entities ; }
12631	public function prepare ( Order $ order ) { $ order -> notify_url = $ order -> get ( 'notify_url' , $ this -> merchant -> notify_url ) ; if ( is_null ( $ order -> spbill_create_ip ) ) { $ order -> spbill_create_ip = ( $ order -> trade_type === Order :: NATIVE ) ? get_server_ip ( ) : get_client_ip ( ) ; } return $ this -> request ( $ this -> wrapApi ( self :: API_PREPARE_ORDER ) , $ order -> all ( ) ) ; }
9811	protected function pureGet ( string $ path , array $ params = [ ] , array $ headers = [ ] ) { if ( $ params ) { $ path .= '?' . http_build_query ( $ params ) ; } return $ this -> client -> get ( $ path , $ headers ) ; }
11624	public function getContent ( Location $ location = null , Operation $ operation ) { if ( $ operation ) { $ status = $ this -> contentService -> getSocialMediaScheduleByOperation ( $ operation ) ; return $ status ; } return null ; }
6750	public function getTransformer ( ) { if ( ! property_exists ( $ this , 'transformer' ) || ! $ this -> transformer ) { if ( ! $ this -> _defaultTransformer ) { $ this -> createQualifiedTransformerClass ( ) ; } return $ this -> _defaultTransformer ; } return $ this -> transformer ; }
2198	public static function findByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
549	public static function dumpAsString ( $ var , $ depth = 10 , $ highlight = false ) { self :: $ _output = '' ; self :: $ _objects = [ ] ; self :: $ _depth = $ depth ; self :: dumpInternal ( $ var , 0 ) ; if ( $ highlight ) { $ result = highlight_string ( "<?php\n" . self :: $ _output , true ) ; self :: $ _output = preg_replace ( '/&lt;\\?php<br \\/>/' , '' , $ result , 1 ) ; } return self :: $ _output ; }
5013	public function attach ( EventManagerInterface $ events , $ priority = 1 ) : void { $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_BOOTSTRAP , [ $ this , 'logBootstrap' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_FINISH , [ $ this , 'logFinish' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_JOB , [ $ this , 'logJobStart' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_JOB , [ $ this , 'logJobEnd' ] , - 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_IDLE , [ $ this , 'injectLoggerInEvent' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_STATE , [ $ this , 'injectLoggerInEvent' ] , 1000 ) ; }
10412	public function loadUrlsFromDocument ( $ type , SeoAwareInterface $ document ) { if ( $ this -> invalidateSeoUrls ) { $ urls = $ document -> getUrls ( ) ; if ( is_array ( $ urls ) || $ urls instanceof \ Traversable ) { foreach ( $ urls as $ url ) { $ this -> addUrl ( $ url -> getUrl ( ) ) ; } } } foreach ( $ this -> urlCollectors as $ collector ) { $ this -> addUrls ( $ collector -> getDocumentUrls ( $ type , $ document , $ this -> router ) ) ; $ this -> addMultipleDocumentParameters ( $ collector -> getDocumentParameters ( $ type , $ document ) ) ; } }
5576	public function clickSubmitById ( $ id , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectById ( $ id ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectById ( $ id ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
6763	public function append ( Collection $ collection ) { if ( ! $ collection ) return $ this ; $ this -> models = array_merge ( $ this -> array ( ) , $ collection -> array ( ) ) ; return $ this ; }
4689	public function groupBy ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'group' ] = $ args ; return $ this ; }
638	public function addColumn ( $ table , $ column , $ type ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addColumn ( $ table , $ column , $ type ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
4864	public function pop ( array $ options = [ ] ) { $ time = microtime ( true ) ; $ micro = sprintf ( "%06d" , ( $ time - floor ( $ time ) ) * 1000000 ) ; $ this -> now = new \ DateTime ( date ( 'Y-m-d H:i:s.' . $ micro , $ time ) , new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; $ now = $ this -> dateTimeToUTCDateTime ( $ this -> now ) ; $ envelope = $ this -> mongoCollection -> findOneAndUpdate ( [ 'queue' => $ this -> getName ( ) , 'status' => self :: STATUS_PENDING , 'scheduled' => [ '$lte' => $ now ] , ] , [ '$set' => [ 'status' => self :: STATUS_RUNNING , 'executed' => $ now , ] , ] , [ 'sort' => [ 'priority' => 1 , 'scheduled' => 1 ] , 'returnDocument' => \ MongoDB \ Operation \ FindOneAndUpdate :: RETURN_DOCUMENT_AFTER ] ) ; if ( ! $ envelope ) { return null ; } return $ this -> unserializeJob ( $ envelope [ 'data' ] , [ '__id__' => $ envelope [ '_id' ] ] ) ; }
7412	protected function customChmod ( string $ target , $ mode = 0666 ) { if ( false === @ chmod ( $ target , $ mode & ~ umask ( ) ) ) { throw new FileException ( sprintf ( 'Unable to change mode of the "%s"' , $ target ) ) ; } }
8905	function dropdown ( ) { $ args = func_get_args ( ) ; if ( count ( $ args ) == 2 ) { list ( $ key , $ value ) = $ args ; } else { $ key = $ this -> primary_key ; $ value = $ args [ 0 ] ; } $ this -> trigger ( 'before_dropdown' , array ( $ key , $ value ) ) ; $ this -> apply_soft_delete_filter ( ) ; $ result = $ this -> _database -> select ( array ( $ key , $ value ) ) -> get ( $ this -> _table ) -> result ( ) ; $ options = array ( ) ; foreach ( $ result as $ row ) { $ options [ $ row -> { $ key } ] = $ row -> { $ value } ; } $ options = $ this -> trigger ( 'after_dropdown' , $ options ) ; return $ options ; }
4925	public function getTypes ( $ region = null ) { if ( null === $ region ) { $ ret = [ ] ; foreach ( $ this -> matrix as $ types ) { $ ret = array_merge ( $ ret , $ types ) ; } return array_values ( array_unique ( $ ret ) ) ; } return $ this -> matrix [ $ region ] ; }
10018	public function removeNamedRange ( $ namedRange , Worksheet $ pSheet = null ) { if ( $ pSheet === null ) { if ( isset ( $ this -> namedRanges [ $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ namedRange ] ) ; } } else { if ( isset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ; } } return $ this ; }
8720	protected function initTranslatableAttributes ( ) { if ( property_exists ( $ this , 'translatable' ) ) { $ attributes = $ this -> translatable ; } else { $ attributes = $ this -> getTranslatableAttributesFromSchema ( ) ; } static :: $ i18nAttributes [ $ this -> getTable ( ) ] = $ attributes ; }
1541	public function withQualifiedKeyName ( $ keyName ) { $ parts = explode ( '.' , $ keyName ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withIdentifierColumn ( $ parts [ 1 ] ) ; return $ this ; }
7184	private function getFindAvailableByCountryAndWeightQuery ( ) { if ( null === $ this -> findAvailableByCountryAndWeightQuery ) { $ qb = $ this -> getCollectionQueryBuilder ( ) ; $ this -> findAvailableByCountryAndWeightQuery = $ qb -> join ( 'o.prices' , 'p' ) -> join ( 'p.zone' , 'z' ) -> andWhere ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'z.countries' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'p.weight' , ':weight' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.enabled' , ':enabled' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.available' , ':available' ) ) -> addOrderBy ( 'o.position' , 'ASC' ) -> getQuery ( ) ; } return $ this -> findAvailableByCountryAndWeightQuery ; }
5329	final public function push ( string $ data ) { if ( $ this -> generator === null ) { throw new \ Error ( "The parser is no longer writable" ) ; } $ this -> buffer .= $ data ; $ end = false ; try { while ( $ this -> buffer !== "" ) { if ( \ is_int ( $ this -> delimiter ) ) { if ( \ strlen ( $ this -> buffer ) < $ this -> delimiter ) { break ; } $ send = \ substr ( $ this -> buffer , 0 , $ this -> delimiter ) ; $ this -> buffer = \ substr ( $ this -> buffer , $ this -> delimiter ) ; } elseif ( \ is_string ( $ this -> delimiter ) ) { if ( ( $ position = \ strpos ( $ this -> buffer , $ this -> delimiter ) ) === false ) { break ; } $ send = \ substr ( $ this -> buffer , 0 , $ position ) ; $ this -> buffer = \ substr ( $ this -> buffer , $ position + \ strlen ( $ this -> delimiter ) ) ; } else { $ send = $ this -> buffer ; $ this -> buffer = "" ; } $ this -> delimiter = $ this -> generator -> send ( $ send ) ; if ( ! $ this -> generator -> valid ( ) ) { $ end = true ; break ; } if ( $ this -> delimiter !== null && ( ! \ is_int ( $ this -> delimiter ) || $ this -> delimiter <= 0 ) && ( ! \ is_string ( $ this -> delimiter ) || ! \ strlen ( $ this -> delimiter ) ) ) { throw new InvalidDelimiterError ( $ this -> generator , \ sprintf ( "Invalid value yielded: Expected NULL, an int greater than 0, or a non-empty string; %s given" , \ is_object ( $ this -> delimiter ) ? \ sprintf ( "instance of %s" , \ get_class ( $ this -> delimiter ) ) : \ gettype ( $ this -> delimiter ) ) ) ; } } } catch ( \ Throwable $ exception ) { $ end = true ; throw $ exception ; } finally { if ( $ end ) { $ this -> generator = null ; } } }
7436	protected function prepareProductMediaGalleryValueToEntityAttributes ( ) { return $ this -> initializeEntity ( array ( MemberNames :: VALUE_ID => $ this -> valueId , MemberNames :: ROW_ID => $ this -> parentId ) ) ; }
9410	protected function collect ( ) { $ collector = new RouteCollector ; foreach ( $ this -> router -> routes ( ) as $ route ) { $ collector -> addRoute ( $ route [ 0 ] , $ route [ 1 ] , $ route [ 2 ] ) ; } return $ collector -> getData ( ) ; }
8828	public function image ( $ name , $ file , $ attributes = [ ] , $ secure = null ) { $ attributes [ 'src' ] = $ this -> uri -> assets ( $ file , $ secure ) ; return $ this -> input ( 'image' , $ name , null , $ attributes ) ; }
3882	private function determineJumpToInformation ( ) { $ translated = $ this -> metaModel -> isTranslated ( ) ; $ desiredLanguage = $ this -> metaModel -> getActiveLanguage ( ) ; $ fallbackLanguage = $ this -> metaModel -> getFallbackLanguage ( ) ; $ jumpToPageId = '' ; $ filterSettingId = '' ; if ( ! isset ( $ this -> jumpToCache [ $ desiredLanguage . '.' . $ fallbackLanguage ] ) ) { foreach ( ( array ) $ this -> get ( 'jumpTo' ) as $ jumpTo ) { $ langCode = $ jumpTo [ 'langcode' ] ; if ( ! $ translated || ( $ langCode == $ desiredLanguage ) || ( $ langCode == $ fallbackLanguage ) ) { $ jumpToPageId = $ jumpTo [ 'value' ] ; $ filterSettingId = $ jumpTo [ 'filter' ] ; if ( $ desiredLanguage == $ jumpTo [ 'langcode' ] ) { break ; } } } $ pageDetails = $ this -> getPageDetails ( $ jumpToPageId ) ; $ filterSetting = $ filterSettingId ? $ this -> getFilterFactory ( ) -> createCollection ( $ filterSettingId ) : null ; $ this -> jumpToCache [ $ desiredLanguage . '.' . $ fallbackLanguage ] = array ( 'page' => $ jumpToPageId , 'pageDetails' => $ pageDetails , 'filter' => $ filterSettingId , 'filterSetting' => $ filterSetting , 'language' => $ pageDetails [ 'language' ] , 'label' => $ this -> getJumpToLabel ( ) ) ; } return $ this -> jumpToCache [ $ desiredLanguage . '.' . $ fallbackLanguage ] ; }
2182	public function listImageSizeItem ( $ row ) { $ html = '<div class="tl_content_left">' ; $ html .= $ row [ 'media' ] ; if ( $ row [ 'width' ] || $ row [ 'height' ] ) { $ html .= ' <span style="padding-left:3px">' . $ row [ 'width' ] . 'x' . $ row [ 'height' ] . '</span>' ; } if ( $ row [ 'zoom' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">(' . $ row [ 'zoom' ] . '%)</span>' ; } $ html .= "</div>\n" ; return $ html ; }
9726	public function logWrite ( IWriter $ writer , $ path , $ callStartTime ) { $ callEndTime = microtime ( true ) ; $ callTime = $ callEndTime - $ callStartTime ; $ reflection = new ReflectionClass ( $ writer ) ; $ format = $ reflection -> getShortName ( ) ; $ message = "Write {$format} format to <code>{$path}</code> in " . sprintf ( '%.4f' , $ callTime ) . ' seconds' ; $ this -> log ( $ message ) ; }
6252	protected function createUngroupedGroupPresence ( $ id = null ) { $ id = $ id ? : 'automatic-ungrouped-permissions' ; return new AclPresence ( [ 'type' => AclPresenceType :: GROUP , 'id' => $ id , 'label' => 'acl.ungrouped-permissions' , 'translated' => true , ] ) ; }
3515	public function getLocale ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'lang_locale' ; $ queuedCookieLocale = \ Cookie :: queued ( $ key , null ) ; $ locale = getSupportedLocale ( $ queuedCookieLocale != null ? $ queuedCookieLocale -> getValue ( ) : \ Cookie :: get ( $ key , '' ) ) ; parent :: setLocale ( $ locale ) ; $ this -> getShowUnpublished ( ) ; $ this -> cookiesLoaded = true ; } return parent :: getLocale ( ) ; }
1986	private function loadOptions ( ) : void { if ( null !== $ this -> options ) { return ; } $ this -> framework -> initialize ( ) ; $ this -> options = $ GLOBALS [ 'TL_CROP' ] ; $ rows = $ this -> connection -> fetchAll ( 'SELECT id, name, width, height FROM tl_image_size ORDER BY pid, name' ) ; foreach ( $ rows as $ imageSize ) { $ this -> options [ 'image_sizes' ] [ $ imageSize [ 'id' ] ] = sprintf ( '%s (%sx%s)' , $ imageSize [ 'name' ] , $ imageSize [ 'width' ] , $ imageSize [ 'height' ] ) ; } }
10099	private function writeString ( $ row , $ col , $ str , $ xfIndex ) { $ this -> writeLabelSst ( $ row , $ col , $ str , $ xfIndex ) ; }
10587	public static function cleanup ( ) : bool { $ ret = true ; foreach ( self :: $ entities as $ path => $ entity ) { if ( ! $ entity -> remove ( ) ) { $ ret = false ; } } self :: $ entities = [ ] ; return $ ret ; }
10396	public function loadClassMetadata ( LoadClassMetadataEventArgs $ eventArgs ) { if ( empty ( $ this -> replacements ) ) { return ; } $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ tableName = $ metadata -> getTableName ( ) ; if ( $ tableName ) { $ metadata -> setPrimaryTable ( [ 'name' => $ this -> doReplacement ( $ tableName ) , ] ) ; } foreach ( $ metadata -> getFieldNames ( ) as $ fieldName ) { $ mapping = $ metadata -> getFieldMapping ( $ fieldName ) ; foreach ( $ mapping as $ key => $ value ) { if ( is_string ( $ value ) ) { $ mapping [ $ key ] = $ this -> doReplacement ( $ value ) ; } } $ metadata -> setAttributeOverride ( $ fieldName , $ mapping ) ; } $ associationMappings = $ metadata -> getAssociationMappings ( ) ; foreach ( $ metadata -> getAssociationNames ( ) as $ fieldName ) { if ( isset ( $ associationMappings [ $ fieldName ] ) ) { $ associationMapping = $ associationMappings [ $ fieldName ] ; if ( isset ( $ associationMapping [ 'joinColumns' ] ) ) { foreach ( $ associationMapping [ 'joinColumns' ] as $ key => $ joinColumn ) { $ associationMapping [ 'joinColumns' ] [ $ key ] [ 'name' ] = $ this -> doReplacement ( $ joinColumn [ 'name' ] ) ; $ associationMapping [ 'joinColumns' ] [ $ key ] [ 'referencedColumnName' ] = $ this -> doReplacement ( $ joinColumn [ 'referencedColumnName' ] ) ; } $ metadata -> setAssociationOverride ( $ fieldName , $ associationMapping ) ; } } } if ( count ( $ metadata -> discriminatorMap ) ) { $ this -> processDiscriminatorMap ( $ metadata ) ; } }
7230	public function getMarginPercent ( ) { if ( 0 < $ this -> margin && 0 < $ this -> revenue ) { return round ( $ this -> margin * 100 / $ this -> revenue , 1 ) ; } return 0 ; }
1948	public function generate ( $ objPage ) { $ this -> redirect ( $ this -> replaceInsertTags ( $ objPage -> url , false ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; }
10458	public function validate ( string $ answer ) : string { if ( trim ( ( string ) $ answer ) === '' ) { throw new \ RuntimeException ( sprintf ( '%s Given value: "%s"' , $ this -> getErrorMessage ( ) , $ answer ) ) ; } return $ answer ; }
12502	public static function replace ( $ id , $ document , $ connection ) { $ connection -> query = self :: singleDocument ( $ document ) ; $ connection -> method = 'PUT' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; return self :: sendQuery ( $ connection ) ; }
3470	public function head ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: head ( $ route ) ) ; }
8884	private function buildPackages ( $ number , $ weight , $ measurement = 'LBS' ) { $ packages = array ( ) ; if ( $ number > 1 ) { $ individual_weight = $ weight / $ number ; for ( $ i = 0 ; $ i < $ number ; $ i ++ ) { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ individual_weight . '</Weight> </PackageWeight> </Package>' ; } } else { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ weight . '</Weight> </PackageWeight> </Package>' ; } return implode ( '' , $ packages ) ; }
7073	static public function isBetterAvailability ( $ stateA , $ stateB ) { if ( $ stateA === $ stateB ) { return false ; } switch ( $ stateA ) { case static :: STATE_PENDING : return in_array ( $ stateB , [ static :: STATE_NEW , static :: STATE_CLOSED ] , true ) ; case static :: STATE_READY : return in_array ( $ stateB , [ static :: STATE_NEW , static :: STATE_PENDING , static :: STATE_CLOSED ] , true ) ; } return false ; }
5831	public function sendRequest ( Request $ request ) { $ this -> prepareRequest ( $ request ) ; $ result = curl_exec ( $ this -> ch ) ; if ( $ result === false ) { throw new \ RuntimeException ( "cURL request failed with error: " . curl_error ( $ this -> ch ) ) ; } $ response = $ this -> createResponseObject ( $ result ) ; curl_close ( $ this -> ch ) ; return $ response ; }
10107	private function writeColinfo ( $ col_array ) { if ( isset ( $ col_array [ 0 ] ) ) { $ colFirst = $ col_array [ 0 ] ; } if ( isset ( $ col_array [ 1 ] ) ) { $ colLast = $ col_array [ 1 ] ; } if ( isset ( $ col_array [ 2 ] ) ) { $ coldx = $ col_array [ 2 ] ; } else { $ coldx = 8.43 ; } if ( isset ( $ col_array [ 3 ] ) ) { $ xfIndex = $ col_array [ 3 ] ; } else { $ xfIndex = 15 ; } if ( isset ( $ col_array [ 4 ] ) ) { $ grbit = $ col_array [ 4 ] ; } else { $ grbit = 0 ; } if ( isset ( $ col_array [ 5 ] ) ) { $ level = $ col_array [ 5 ] ; } else { $ level = 0 ; } $ record = 0x007D ; $ length = 0x000C ; $ coldx *= 256 ; $ ixfe = $ xfIndex ; $ reserved = 0x0000 ; $ level = max ( 0 , min ( $ level , 7 ) ) ; $ grbit |= $ level << 8 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvvvv' , $ colFirst , $ colLast , $ coldx , $ ixfe , $ grbit , $ reserved ) ; $ this -> append ( $ header . $ data ) ; }
5337	public function api ( $ name ) { switch ( $ name ) { case 'domain' : case 'domain_service' : case 'domainService' : return new Api \ Domain ( $ this ) ; case 'colocation' : case 'colocation_service' : case 'colocationService' : return new Api \ Colocation ( $ this ) ; case 'forward' : case 'forward_service' : case 'forwardService' : return new Api \ Forward ( $ this ) ; case 'vps' : case 'vps_service' : case 'vpsService' : return new Api \ Vps ( $ this ) ; case 'hosting' : case 'web_hosting' : case 'webHosting' : case 'web_hosting_service' : case 'webHostingService' : return new Api \ WebHosting ( $ this ) ; case 'haip' : case 'ha_ip' : case 'ha_ip_service' : case 'haip_service' : case 'haipService' : return new Api \ Haip ( $ this ) ; default : throw new \ InvalidArgumentException ( sprintf ( 'Undefined api instance called: [%s]' , $ name ) ) ; } }
9840	public function createSymmetricEncryptedJsonResponse ( int $ status , array $ arrayToJsonify , SharedEncryptionKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricEncryptedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
7425	public function setSource ( $ source = '' ) { if ( ! $ this -> isValid ( $ source ) ) { throw new InvalidSourceExtensionException ( ) ; } $ this -> source = $ source ; return $ this ; }
2688	private function fastlyRotate ( $ angle ) { $ angle = ( int ) $ angle ; $ orient = null ; if ( $ angle == 90 ) { $ orient = 'r' ; } if ( $ angle == - 90 || $ angle == 270 ) { $ orient = 'l' ; } if ( $ angle == 180 ) { $ orient = 3 ; } if ( $ orient !== null ) { $ this -> fastlyParameters [ 'orient' ] = $ orient ; } return $ this ; }
4811	public function create ( ) { $ language = new ExpressionLanguage ( ) ; foreach ( $ this -> providers as $ provider ) { $ language -> registerProvider ( $ provider ) ; } return $ language ; }
5374	public function createTag ( $ name , $ attributes ) { static $ map = array ( 'a' => 'SimpleAnchorTag' , 'title' => 'SimpleTitleTag' , 'base' => 'SimpleBaseTag' , 'button' => 'SimpleButtonTag' , 'textarea' => 'SimpleTextAreaTag' , 'option' => 'SimpleOptionTag' , 'label' => 'SimpleLabelTag' , 'form' => 'SimpleFormTag' , 'frame' => 'SimpleFrameTag' ) ; $ attributes = $ this -> keysToLowerCase ( $ attributes ) ; if ( array_key_exists ( $ name , $ map ) ) { $ tag_class = $ map [ $ name ] ; return new $ tag_class ( $ attributes ) ; } elseif ( $ name === 'select' ) { return $ this -> createSelectionTag ( $ attributes ) ; } elseif ( $ name === 'input' ) { return $ this -> createInputTag ( $ attributes ) ; } return new SimpleTag ( $ name , $ attributes ) ; }
10366	public function logout ( ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'logout' ) ) -> dispatchNow ( new LogoutJob ) ; return redirect ( ) -> route ( config ( '_auth.logout.redirect' ) ) ; }
1579	public function withType ( string $ type ) : self { if ( empty ( $ type ) ) { throw new \ InvalidArgumentException ( 'Expecting a non-empty string.' ) ; } $ copy = clone $ this ; $ copy -> type = $ type ; $ copy -> normalize ( ) ; return $ copy ; }
12816	private static function getColumns ( string $ table ) : array { if ( self :: $ columnsCache !== null && array_key_exists ( $ table , self :: $ columnsCache ) ) return self :: $ columnsCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT * FROM information_schema.columns WHERE table_name = '$table' " ; self :: $ columnsCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ columnsCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ columnsCache [ $ table ] ; }
1043	public static function printError ( Error $ error ) { $ printedLocations = [ ] ; if ( $ error -> nodes ) { foreach ( $ error -> nodes as $ node ) { if ( ! $ node -> loc ) { continue ; } if ( $ node -> loc -> source === null ) { continue ; } $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ node -> loc -> source , $ node -> loc -> source -> getLocation ( $ node -> loc -> start ) ) ; } } elseif ( $ error -> getSource ( ) && $ error -> getLocations ( ) ) { $ source = $ error -> getSource ( ) ; foreach ( $ error -> getLocations ( ) as $ location ) { $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ source , $ location ) ; } } return ! $ printedLocations ? $ error -> getMessage ( ) : implode ( "\n\n" , array_merge ( [ $ error -> getMessage ( ) ] , $ printedLocations ) ) . "\n" ; }
2617	public function getCountry ( ) { $ countryCode = $ this -> scopeConfig -> getValue ( 'general/country/default' ) ; if ( ! $ countryCode ) { return null ; } $ country = $ this -> countryFactory -> create ( ) -> loadByCode ( $ countryCode ) ; return $ country -> getName ( ) ; }
12718	protected function markAsResolved ( $ abstract , $ resolvedInstance , $ flag = [ ] ) { if ( ! is_array ( $ flag ) ) { $ flag = array_slice ( func_get_args ( ) , 2 ) ; } if ( $ this -> isAbstractExists ( $ abstract ) ) { $ this -> resolved [ $ abstract ] = [ 'concrete' => $ resolvedInstance , 'resolved' => true , 'flag' => join ( '|' , $ flag ) ] ; } }
7105	public function onParse ( $ finalText ) { $ func = $ this -> getParam ( 'postParseFunction' ) ; if ( isset ( $ func ) ) $ finalText = $ func ( $ finalText ) ; if ( $ this -> getParam ( 'addFootnotes' ) ) { $ footnotes = $ this -> getFootnotes ( ) ; if ( ! empty ( $ footnotes ) ) $ finalText .= "\n" . $ footnotes ; } $ finalText .= str_repeat ( '</section>' , count ( $ this -> _sectionLevel ) ) ; return ( $ finalText ) ; }
441	public function hasMethod ( $ name , $ checkBehaviors = true ) { if ( method_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> hasMethod ( $ name ) ) { return true ; } } } return false ; }
7866	protected function drawBorderTop ( $ isCore = false ) { $ crossroads = $ isCore ? static :: CROSSROADS_UP : static :: CROSSROADS ; $ this -> drawBorder ( static :: BORDER_NW , $ crossroads , static :: BORDER_NE ) ; $ this -> geometry -> increaseNesting ( ) ; }
5550	public function getRequestData ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRequestData ( ) ; } return $ this -> frameset -> getRequestData ( ) ; }
5618	public function paintHeader ( $ test_name ) { $ this -> sendNoCacheHeaders ( ) ; echo sprintf ( SIMPLETEST_WEBUNIT_HEAD , $ test_name , $ this -> path . 'js/' , $ this -> path . 'js/' , $ this -> path . 'css/' , $ this -> _getCss ( ) , $ test_name , $ this -> path . 'img/' ) ; flush ( ) ; }
3329	public function status ( $ token ) { $ data = array ( 'token' => $ token , ) ; $ ch = $ this -> __initRequest ( 'from_url/status' , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ data = $ this -> __runRequest ( $ ch ) ; return $ data ; }
363	public function renderItems ( ) { $ caption = $ this -> renderCaption ( ) ; $ columnGroup = $ this -> renderColumnGroup ( ) ; $ tableHeader = $ this -> showHeader ? $ this -> renderTableHeader ( ) : false ; $ tableBody = $ this -> renderTableBody ( ) ; $ tableFooter = false ; $ tableFooterAfterBody = false ; if ( $ this -> showFooter ) { if ( $ this -> placeFooterAfterBody ) { $ tableFooterAfterBody = $ this -> renderTableFooter ( ) ; } else { $ tableFooter = $ this -> renderTableFooter ( ) ; } } $ content = array_filter ( [ $ caption , $ columnGroup , $ tableHeader , $ tableFooter , $ tableBody , $ tableFooterAfterBody , ] ) ; return Html :: tag ( 'table' , implode ( "\n" , $ content ) , $ this -> tableOptions ) ; }
7744	public function getValue ( $ entity ) { if ( null === $ this -> getter ) { throw new \ Exception ( "Can't get the entity's {$this->name} property as no getter has been found." ) ; } elseif ( false === ( $ entity instanceof $ this -> class ) ) { throw new \ Exception ( "Can't get the entity's {$this->name} property as the entity is not an instance of {$this->class}." ) ; } if ( self :: GETTER_SETTER_METHOD === $ this -> getterType ) { return $ entity -> { $ this -> getter } ( ) ; } else { return $ entity -> { $ this -> getter } ; } }
11839	public static function convert2Jpeg ( $ inputImg , $ savePath = null , $ quality = null , array $ exifData = null ) { $ retval = false ; $ img = self :: imgCreate ( $ inputImg ) ; $ imgSize = self :: size ( $ img ) ; $ jpegImg = imagecreatetruecolor ( $ imgSize [ 0 ] , $ imgSize [ 1 ] ) ; imagecopy ( $ jpegImg , $ img , 0 , 0 , 0 , 0 , $ imgSize [ 0 ] , $ imgSize [ 1 ] ) ; if ( null === $ quality ) $ quality = self :: IMG_QUALITY ; if ( null !== $ exifData && array_key_exists ( 'Orientation' , $ exifData ) ) { $ ort = $ exifData [ 'Orientation' ] ; switch ( $ ort ) { default : case 1 : break ; case 2 : $ jpegImg = self :: flipImage ( $ jpegImg , 1 ) ; break ; case 3 : $ jpegImg = self :: rotateImage ( $ jpegImg , 180 ) ; break ; case 4 : $ jpegImg = self :: flipImage ( $ jpegImg , 2 ) ; break ; case 5 : $ jpegImg = self :: flipImage ( $ jpegImg , 2 ) ; $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 6 : $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 7 : $ jpegImg = self :: flipImage ( $ jpegImg , 1 ) ; $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 8 : $ jpegImg = self :: rotateImage ( $ jpegImg , 270 ) ; break ; } } if ( null === $ savePath ) $ retval = $ jpegImg ; else $ retval = imagejpeg ( $ jpegImg , $ savePath , $ quality ) ; return $ retval ; }
12907	public function store ( FilterRequest $ request ) { $ this -> fieldManager = $ this -> getFieldManager ( ) ; $ this -> validate ( $ request -> request , $ this -> fieldManager -> store ( ) ) ; $ input = $ request -> all ( ) ; $ resource = $ this -> repository -> create ( $ input ) ; if ( ! $ resource ) { } return $ this -> created ( $ resource ) ; }
450	public static function encode ( $ value , $ options = 320 ) { $ expressions = [ ] ; $ value = static :: processData ( $ value , $ expressions , uniqid ( '' , true ) ) ; set_error_handler ( function ( ) { static :: handleJsonError ( JSON_ERROR_SYNTAX ) ; } , E_WARNING ) ; $ json = json_encode ( $ value , $ options ) ; restore_error_handler ( ) ; static :: handleJsonError ( json_last_error ( ) ) ; return $ expressions === [ ] ? $ json : strtr ( $ json , $ expressions ) ; }
3805	public function generate ( ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/metamodelscore/css/style.css' ; $ arrModule = $ GLOBALS [ 'BE_MOD' ] [ 'metamodels' ] [ 'metamodels' ] ; if ( \ Input :: get ( 'key' ) && isset ( $ arrModule [ \ Input :: get ( 'key' ) ] ) ) { Callbacks :: call ( $ arrModule [ \ Input :: get ( 'key' ) ] , $ this , $ arrModule ) ; } $ act = \ Input :: get ( 'act' ) ; if ( ! strlen ( $ act ) ) { $ act = 'showAll' ; } return $ this -> dataContainer -> getEnvironment ( ) -> getController ( ) -> handle ( new Action ( $ act ) ) ; }
1546	public function document ( $ request ) : ? \ stdClass { if ( $ this -> cannotDecodeJsonApi ( ) ) { return null ; } return $ this -> decoding -> getJsonApiDecoder ( ) -> document ( $ request ) ; }
2197	public function onAuthenticationSuccess ( Request $ request , TokenInterface $ token ) : RedirectResponse { $ this -> user = $ token -> getUser ( ) ; if ( ! $ this -> user instanceof User ) { return $ this -> getRedirectResponse ( $ request ) ; } $ this -> user -> lastLogin = $ this -> user -> currentLogin ; $ this -> user -> currentLogin = time ( ) ; $ this -> user -> save ( ) ; if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has logged in' , $ this -> user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ this -> user -> username ) ] ) ; } $ this -> triggerPostLoginHook ( ) ; return $ this -> getRedirectResponse ( $ request ) ; }
1492	public function current ( $ meta = null , array $ queryParams = [ ] ) { $ url = $ this -> generator -> current ( ) ; if ( $ queryParams ) { $ url .= '?' . http_build_query ( $ queryParams ) ; } return $ this -> factory -> createLink ( $ url , $ meta , true ) ; }
3885	private function collectRulesFor ( $ parentSetting , $ filterSettings ) { $ childInformation = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'pid' , $ parentSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ childInformation -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ childSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ childSetting ) { $ parentSetting -> addChild ( $ childSetting ) ; } } }
3770	protected function internalCreateRenderSetting ( IMetaModel $ metaModel , $ settingId ) { $ row = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_rendersettings' ) -> where ( 'pid=:pid' ) -> andWhere ( 'id=:id' ) -> setParameter ( 'pid' , $ metaModel -> get ( 'id' ) ) -> setParameter ( 'id' , $ settingId ? : 0 ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( ! $ row ) { $ row = [ ] ; } $ renderSetting = new Collection ( $ metaModel , $ row , $ this -> eventDispatcher , $ this -> filterFactory , $ this -> filterUrlBuilder ) ; if ( $ renderSetting -> get ( 'id' ) ) { $ this -> collectAttributeSettings ( $ metaModel , $ renderSetting ) ; } return $ renderSetting ; }
6030	public function setChildMedias ( array $ childMedias ) { $ this -> childMedias = [ ] ; foreach ( $ childMedias as $ item ) { $ this -> addself ( $ item ) ; } return $ this ; }
12850	private function _checkCache ( \ stdClass $ oCache ) { $ sHearderValidity = false ; $ sHeader = "Cache-Control:" ; if ( isset ( $ oCache -> visibility ) && ( $ oCache -> visibility = 'public' || $ oCache -> visibility = 'private' ) ) { $ sHearderValidity = true ; $ sHeader .= " " . $ oCache -> visibility . "," ; } if ( isset ( $ oCache -> max_age ) ) { $ sHearderValidity = true ; $ sHeader .= " maxage=" . $ oCache -> max_age . "," ; } if ( isset ( $ oCache -> must_revalidate ) && $ oCache -> must_revalidate === true ) { $ sHearderValidity = true ; $ sHeader .= " must-revalidate," ; } if ( $ sHearderValidity === true ) { $ sHeader = substr ( $ sHeader , 0 , - 1 ) ; if ( ! headers_sent ( ) ) { header ( $ sHeader ) ; } } if ( isset ( $ oCache -> ETag ) ) { header ( "ETag: \"" . $ oCache -> ETag . "\"" ) ; } if ( isset ( $ oCache -> max_age ) ) { if ( ! headers_sent ( ) ) { header ( 'Expires: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> max_age ) . ' GMT' ) ; } } if ( isset ( $ oCache -> last_modified ) ) { if ( ! headers_sent ( ) ) { header ( 'Last-Modified: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> last_modified ) . ' GMT' ) ; } } if ( isset ( $ oCache -> vary ) ) { header ( 'Vary: ' . $ oCache -> vary ) ; } }
2916	protected function stringToType ( $ string ) { if ( is_string ( $ string ) ) { switch ( true ) { case ( $ string == 'null' || $ string == 'NULL' ) : $ string = null ; break ; case ( $ string == 'true' || $ string == 'TRUE' ) : $ string = true ; break ; case ( $ string == 'false' || $ string == 'FALSE' ) : $ string = false ; break ; default : break ; } } return $ string ; }
3345	public function __batchProcessFilesChunk ( $ filesUuidArr , $ request_type ) { if ( count ( $ filesUuidArr ) > $ this -> batchFilesChunkSize ) { throw new \ Exception ( 'Files number should not exceed ' . $ this -> batchFilesChunkSize . ' items per request.' ) ; } $ data = $ this -> __preparedRequest ( 'files_storage' , $ request_type , array ( ) , $ filesUuidArr ) ; $ files_raw = ( array ) $ data -> result ; $ result = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ result [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return array ( 'status' => ( string ) $ data -> status , 'files' => $ result , 'problems' => $ data -> problems , ) ; }
4905	public function getByKey ( $ key = null ) { if ( ! array_key_exists ( $ key , $ this -> applicationMap ) ) { $ this -> applicationMap [ $ key ] = array ( ) ; $ config = $ this -> serviceManager -> get ( 'Config' ) ; $ appConfig = $ this -> serviceManager -> get ( 'ApplicationConfig' ) ; foreach ( $ appConfig [ 'modules' ] as $ module ) { if ( array_key_exists ( $ module , $ config ) ) { if ( array_key_exists ( $ key , $ config [ $ module ] ) ) { $ this -> applicationMap [ $ key ] [ strtolower ( $ module ) ] = $ config [ $ module ] [ $ key ] ; } } } } return $ this -> applicationMap [ $ key ] ; }
9058	public function addForeignKey ( string $ name , $ mapperClass , $ onDelete = true , $ onUpdate = false ) : Column { $ table = $ this -> getTableData ( $ mapperClass ) ; $ constrait = new Constrait ( $ name , $ this , $ table , $ onDelete , $ onUpdate ) ; $ this -> constraints [ $ constrait -> name ] = $ constrait ; return $ constrait -> column ; }
10734	public function setLower ( $ lower ) : self { if ( ! is_numeric ( $ lower ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, lower, to be a number" ) ; } $ this -> lower = + $ lower ; return $ this ; }
4672	public function setPaths ( array $ paths ) : object { foreach ( $ paths as $ path ) { if ( ! ( is_dir ( $ path ) && is_readable ( $ path ) ) ) { throw new Exception ( "Directory '$path' is not readable." ) ; } } $ this -> paths = $ paths ; return $ this ; }
11936	public function getPrimaryKey ( ) { $ pk = $ this -> meta -> schema -> primaryKey ; if ( is_array ( $ pk ) ) { $ ppk = [ ] ; foreach ( $ pk as $ key ) { if ( ! isset ( $ this -> attributes [ $ key ] ) ) { $ ppk [ ] = null ; } else { $ ppk [ ] = $ this -> attributes [ $ key ] ; } } return implode ( '.' , $ ppk ) ; } if ( ! isset ( $ this -> attributes [ $ pk ] ) ) { return ; } return $ this -> attributes [ $ pk ] ; }
251	public function removeFlash ( $ key ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; $ value = isset ( $ _SESSION [ $ key ] , $ counters [ $ key ] ) ? $ _SESSION [ $ key ] : null ; unset ( $ counters [ $ key ] , $ _SESSION [ $ key ] ) ; $ _SESSION [ $ this -> flashParam ] = $ counters ; return $ value ; }
5116	public function submitAttachment ( string $ idArticle , Model $ attachment , string $ field ) : array { return json_decode ( $ this -> post ( $ this -> getAttachmentEndPoint ( $ idArticle , $ field ) , $ this -> normalizePayload ( $ attachment -> getCollection ( ) ) ) , true ) ; }
8506	public function getBillOfLading ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetBillOfLadingRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetBillOfLadingRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetBillOfLading' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetBillOfLadingResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3122	public function find ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ points = [ ] ; foreach ( $ this -> points as $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ points [ ] = $ point ; } } return $ points ; }
9794	public function getDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot get data validation for cell that is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> getDataValidation ( $ this -> getCoordinate ( ) ) ; }
4879	public function getPrettySize ( ) { $ size = $ this -> getLength ( ) ; if ( $ size >= 1073741824 ) { return round ( $ size / 1073741824 , 2 ) . ' GB' ; } if ( $ size >= 1048576 ) { return round ( $ size / 1048576 , 2 ) . ' MB' ; } if ( $ size >= 1024 ) { return round ( $ size / 1024 , 2 ) . ' kB' ; } return ( string ) $ size ; }
10631	public static function avgload ( ) { $ avgload = new \ StdClass ( ) ; if ( false !== ( $ data = @ file ( '/proc/loadavg' ) ) ) { $ data = explode ( " " , implode ( "" , $ data ) ) ; $ data = array_chunk ( $ data , 4 ) ; $ avgload -> min1 = $ data [ 0 ] [ 0 ] ; $ avgload -> min5 = $ data [ 0 ] [ 1 ] ; $ avgload -> min15 = $ data [ 0 ] [ 2 ] ; $ fourth = explode ( '/' , $ data [ 0 ] [ 3 ] ) ; $ avgload -> running = $ fourth [ 0 ] ; $ avgload -> exists = $ fourth [ 1 ] ; $ avgload -> recentPID = $ data [ 1 ] [ 0 ] ; } return $ avgload ; }
11707	public function actionIndex ( ) { $ searchModel = \ Yii :: createObject ( UserSearch :: className ( ) ) ; $ dataProvider = $ searchModel -> search ( $ _GET ) ; return $ this -> render ( 'index' , [ 'dataProvider' => $ dataProvider , 'searchModel' => $ searchModel , ] ) ; }
11669	protected function createAggregateConnection ( $ parameters , $ option ) { $ options = $ this -> getOptions ( ) ; $ initializer = $ options -> $ option ; $ connection = $ initializer ( $ parameters ) ; if ( $ option !== 'aggregate' && ! $ connection instanceof SentinelReplication ) { $ options -> connections -> aggregate ( $ connection , $ parameters ) ; } return $ connection ; }
6191	public function run ( $ controller = null , $ action = null , $ args = [ ] ) { $ this -> router = $ this -> router -> boot ( $ this ) ; if ( is_null ( $ controller ?? null ) and is_null ( $ action ?? null ) ) { $ this -> router -> parseGets ( ) ; $ controller = $ this -> router -> controller ; $ action = $ this -> router -> action ; $ namespace = $ this -> router -> namespace ; } $ loader = new Loader ( $ this -> baseClass ) ; $ Controller = $ loader -> loadController ( $ controller , $ namespace ?? '\\' ) ; $ response = [ ] ; if ( method_exists ( $ Controller , 'start' ) ) { $ response [ ] = [ 'start' , [ ] ] ; } if ( method_exists ( $ Controller , 'init' ) ) { $ response [ ] = [ 'init' , [ ] ] ; } if ( method_exists ( $ Controller , $ action ) or is_callable ( [ $ Controller , $ action ] ) ) { $ response [ ] = [ $ action , $ args ] ; } if ( method_exists ( $ Controller , 'end' ) ) { $ response [ ] = [ 'end' , [ ] ] ; } foreach ( $ response as $ key => $ data ) { $ run = call_user_func_array ( [ $ Controller , $ data [ 0 ] ] , $ data [ 1 ] ) ; if ( $ run instanceof Response ) { if ( isset ( $ this -> debug ) ) { $ this -> debug -> addHeader ( [ 'X-DF-Debug-Controller' => $ controller ] ) ; $ this -> debug -> addHeader ( [ 'X-DF-Debug-Method' => $ action ] ) ; $ run -> headers ( $ this -> debug -> getHeader ( ) ) ; } return $ run -> display ( ) ; } } return true ; }
12863	protected function getCachedIdentityService ( Cache $ cache , array $ options ) : CachedIdentityService { if ( ! isset ( $ options [ 'authUrl' ] ) ) { throw new \ InvalidArgumentException ( "'authUrl' is a required option" ) ; } $ stack = HandlerStack :: create ( ) ; if ( ! empty ( $ options [ 'debugLog' ] ) && ! empty ( $ options [ 'logger' ] ) && ! empty ( $ options [ 'messageFormatter' ] ) ) { $ stack -> push ( GuzzleMiddleware :: log ( $ options [ 'logger' ] , $ options [ 'messageFormatter' ] ) ) ; } $ clientOptions = [ 'base_uri' => Utils :: normalizeUrl ( $ options [ 'authUrl' ] ) , 'handler' => $ stack , ] ; if ( isset ( $ options [ 'requestOptions' ] ) ) { $ clientOptions = array_merge ( $ options [ 'requestOptions' ] , $ clientOptions ) ; } $ service = CachedIdentityService :: factory ( new Client ( $ clientOptions ) ) ; $ service -> setCache ( $ cache ) ; return $ service ; }
480	public function alterColumn ( $ table , $ column , $ type ) { $ time = $ this -> beginCommand ( "alter column $column in table $table to $type" ) ; $ this -> db -> createCommand ( ) -> alterColumn ( $ table , $ column , $ type ) -> execute ( ) ; if ( $ type instanceof ColumnSchemaBuilder && $ type -> comment !== null ) { $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ type -> comment ) -> execute ( ) ; } $ this -> endCommand ( $ time ) ; }
328	public static function instance ( $ refresh = false ) { $ className = get_called_class ( ) ; if ( $ refresh || ! isset ( self :: $ _instances [ $ className ] ) ) { self :: $ _instances [ $ className ] = Yii :: createObject ( $ className ) ; } return self :: $ _instances [ $ className ] ; }
5310	protected function getPathFromEllipse ( SimpleXMLElement $ ellipse ) { $ mult = 0.55228475 ; return 'M' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'C' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . ' ' . $ ellipse [ 'cx' ] . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . 'C' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'C' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . ' ' . $ ellipse [ 'cx' ] . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . 'C' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'Z' ; }
10850	protected function getMapping ( string $ clazz ) : array { if ( isset ( $ this -> cachedMapping [ $ clazz ] ) ) { return $ this -> cachedMapping [ $ clazz ] ; } $ ref = new \ ReflectionClass ( $ clazz ) ; $ mapping = array ( ) ; foreach ( $ this -> mapping as $ className => $ config ) { if ( $ clazz === $ className || $ ref -> isSubclassOf ( $ className ) ) { $ mapping = \ array_merge ( $ mapping , $ config ) ; } } $ this -> cachedMapping [ $ clazz ] = $ mapping ; return $ mapping ; }
9501	public function watch ( WatcherInterface $ watcher ) { $ events = $ this -> getEvents ( ) ; $ watcher -> watch ( $ this -> getTrackedPaths ( ) , $ events , [ $ this , 'runPeridot' ] ) ; }
5874	public static function isAnimatedGif ( $ fileName ) { if ( ( $ fh = fopen ( $ fileName , 'rb' ) ) === false ) { throw new \ RuntimeException ( 'Can\'t open ' . $ fileName , 1454678600 ) ; } $ count = 0 ; while ( ! feof ( $ fh ) && $ count < 2 ) { $ chunk = fread ( $ fh , 1024 * 100 ) ; $ count += preg_match_all ( '#\x00\x21\xF9\x04.{4}\x00[\x2C\x21]#s' , $ chunk , $ matches ) ; } fclose ( $ fh ) ; return $ count > 1 ; }
11205	public function merge ( $ data , $ key = false , $ dataKey = false ) { if ( $ data != false && ( is_array ( $ data ) || is_object ( $ data ) ) ) { foreach ( $ data as $ item ) { $ this -> add ( $ item , $ key , $ dataKey , true ) ; } } else { $ this -> add ( $ data , $ key , $ dataKey ) ; } return $ this ; }
341	public static function validate ( $ model , $ attributes = null ) { $ result = [ ] ; if ( $ attributes instanceof Model ) { $ models = func_get_args ( ) ; $ attributes = null ; } else { $ models = [ $ model ] ; } foreach ( $ models as $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , $ attribute ) ] = $ errors ; } } return $ result ; }
4390	protected function getXmlProvider ( ) { $ provider = OPay :: create ( 'Datatrans\Xml' ) ; $ provider -> initialize ( $ this -> getServiceItem ( ) -> getConfig ( ) ) ; return $ provider ; }
656	public function init ( ) { if ( $ this -> autoRelease ) { $ locks = & $ this -> _locks ; register_shutdown_function ( function ( ) use ( & $ locks ) { foreach ( $ locks as $ lock ) { $ this -> release ( $ lock ) ; } } ) ; } }
6839	public function get ( $ key ) { if ( isset ( $ this -> objects [ $ key ] ) ) { return $ this -> objects [ $ key ] ; } throw new InjectorException ( "obj $key not found" ) ; }
10590	public static function isTypeOf ( FormInterface $ form , $ typeName ) { $ typeNames = ( array ) $ typeName ; $ type = $ form -> getConfig ( ) -> getType ( ) ; while ( $ type ) { $ actualTypeName = $ type -> getName ( ) ; if ( in_array ( $ actualTypeName , $ typeNames , true ) ) { return true ; } $ type = $ type -> getParent ( ) ; } return false ; }
1431	protected function getSoftDeleteField ( Model $ record ) { if ( $ field = $ this -> softDeleteField ( ) ) { return $ field ; } $ key = $ this -> getSoftDeleteKey ( $ record ) ; return Str :: dasherize ( $ key ) ; }
1494	public static function fromArray ( iterable $ config , string $ urlPrefix = null ) : self { return new self ( ... collect ( $ config ) -> map ( function ( $ value , $ key ) use ( $ urlPrefix ) { return Encoding :: fromArray ( $ key , $ value , $ urlPrefix ) ; } ) -> values ( ) ) ; }
7337	public function createClient ( ) : TgLog { $ this -> loop = Factory :: create ( ) ; $ handler = new HttpClientRequestHandler ( $ this -> loop ) ; return new TgLog ( $ this -> token , $ handler ) ; }
7997	public static function getSpecificationString ( $ reversed = false ) { $ reflection = new ReflectionClass ( get_class ( ) ) ; $ constants = $ reflection -> getConstants ( ) ; if ( $ reversed ) { $ constants = array_reverse ( $ constants ) ; } $ string = '' ; foreach ( $ constants as $ name => $ int_val ) { $ binary_val_string = base_convert ( ( string ) $ int_val , '10' , '2' ) ; $ string .= sprintf ( '0b%s : %s' , str_pad ( $ binary_val_string , 32 , '0' , STR_PAD_LEFT ) , $ name ) ; $ string .= PHP_EOL ; } return $ string ; }
1673	public function isUnprotected ( ) { $ path = $ this -> strFolder ; do { if ( file_exists ( $ this -> strRootDir . '/' . $ path . '/.public' ) ) { return true ; } $ path = \ dirname ( $ path ) ; } while ( $ path != '.' ) ; return false ; }
2108	public static function findByRelatedTableAndIds ( $ strTable , array $ arrIds , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE $t.id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")) ORDER BY $t.createdOn DESC" ) -> execute ( $ strTable , $ arrIds ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ arrModels = array ( ) ; $ objRegistry = Registry :: getInstance ( ) ; while ( $ objResult -> next ( ) ) { if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { $ arrModels [ ] = $ objOptIn ; } else { $ arrModels [ ] = new static ( $ objResult -> row ( ) ) ; } } return static :: createCollection ( $ arrModels , $ t ) ; }
4464	public function childPerform ( BaseJob $ job ) : void { $ loggerContext = [ 'job' => $ job -> jid , 'type' => $ this -> who ] ; try { if ( $ this -> jobPerformHandler ) { if ( $ this -> jobPerformHandler instanceof EventsManagerAwareInterface ) { $ this -> jobPerformHandler -> setEventsManager ( $ this -> client -> getEventsManager ( ) ) ; } if ( method_exists ( $ this -> jobPerformHandler , 'setUp' ) ) { $ this -> jobPerformHandler -> setUp ( ) ; } $ this -> getEventsManager ( ) -> fire ( new JobEvent \ BeforePerform ( $ this -> jobPerformHandler , $ job ) ) ; $ this -> jobPerformHandler -> perform ( $ job ) ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ AfterPerform ( $ this -> jobPerformHandler , $ job ) ) ; if ( method_exists ( $ this -> jobPerformHandler , 'tearDown' ) ) { $ this -> jobPerformHandler -> tearDown ( ) ; } } else { $ job -> perform ( ) ; } $ this -> logger -> notice ( '{type}: job {job} has finished' , $ loggerContext ) ; } catch ( \ Throwable $ e ) { $ loggerContext [ 'stack' ] = $ e -> getMessage ( ) ; $ this -> logger -> critical ( '{type}: job {job} has failed {stack}' , $ loggerContext ) ; $ job -> fail ( 'system:fatal' , sprintf ( '%s: %s in %s on line %d' , get_class ( $ e ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) ) ) ; } }
4264	protected function doPublish ( $ eventName , $ subscribers , Event $ event ) { foreach ( $ subscribers as $ callable ) { if ( $ event -> isPropagationStopped ( ) ) { break ; } \ call_user_func ( $ callable , $ event , $ eventName , $ this ) ; } }
9251	public function addCompilerPass ( CompilerPassInterface $ pass , $ type = PassConfig :: TYPE_BEFORE_OPTIMIZATION ) { $ this -> compilerPasses [ ] = array ( $ pass , $ type ) ; }
3203	protected function validate_css_property_value ( $ value , $ compare_type , $ compare_value ) { switch ( $ compare_type ) { case '!=' : return $ value !== $ compare_value ; case '>' : return $ value > $ compare_value ; default : return false ; } }
5609	public function paintGroupStart ( $ message , $ size ) { parent :: paintGroupStart ( $ message , $ size ) ; $ node = new TreemapNode ( 'Group' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
10682	public static function quoteWith ( $ o , $ quote = '\'' ) { if ( strlen ( $ quote ) !== 1 ) { throw new InvalidArgumentException ( '2nd parameter must be single character, two or more characters are given' ) ; } if ( is_array ( $ o ) ) { $ len = count ( $ o ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ tmp [ $ i ] = $ quote . $ o [ $ i ] . $ quote ; } return $ tmp ; } return $ quote . $ o . $ quote ; }
8746	public function getListenerInstance ( EventDispatcher $ eventDispatcher = null , StreamableInterface $ stream = null ) { $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Matcher' ) ; $ matcher = $ reflection -> newInstance ( ) ; $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Listener' ) ; if ( null === $ eventDispatcher ) { $ eventDispatcher = new EventDispatcher ( ) ; } if ( null === $ stream ) { $ stream = new Stream ( ) ; } $ listener = $ reflection -> newInstance ( $ matcher , $ eventDispatcher , $ stream ) ; return $ listener ; }
8865	public function run ( PayloadInterface $ payload ) { $ tasks = $ this -> getTaskCollection ( ) -> getTasks ( ) ; $ tasksCount = $ tasks -> count ( ) ; if ( 0 === $ tasksCount ) { throw new LogicException ( 'Can\'t invoke task run. Empty task collection set.' ) ; } $ this -> log ( LogLevel :: INFO , sprintf ( 'Starting runner with %s tasks ready for execution.' , $ tasksCount ) ) ; $ this -> dispatch ( 'runner.start' , null , $ payload ) ; foreach ( $ tasks as $ task ) { try { $ task -> setPayload ( $ payload ) ; $ this -> runTask ( $ task , $ payload ) ; } catch ( \ Exception $ e ) { $ this -> logTask ( $ task , LogLevel :: ERROR , sprintf ( 'An exception was thrown. Message: %s' , $ e -> getMessage ( ) ) ) ; $ this -> dispatch ( 'runner.failure' , null , null , null , $ e ) ; throw new RunFailedException ( 'Complete run failed: ' . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } } $ this -> log ( LogLevel :: INFO , 'All tasks were processed.' ) ; $ this -> log ( LogLevel :: INFO , 'Calling attached runners.' ) ; $ this -> notify ( $ payload ) ; $ this -> log ( LogLevel :: INFO , 'Execution successful.' ) ; $ this -> dispatch ( 'runner.success' , null , $ payload ) ; return $ payload ; }
4671	public function addBlockToBody ( $ block ) { $ this -> body = array_merge ( $ this -> body , explode ( PHP_EOL , $ block ) ) ; }
8678	public function chunk ( $ size , $ preserveKeys = false ) { $ create = function ( $ items ) { return $ this -> createFrom ( $ items ) ; } ; return $ this -> createFrom ( array_map ( $ create , array_chunk ( $ this -> items , $ size , $ preserveKeys ) ) ) ; }
2117	public function getExcludedFields ( ) { $ processed = array ( ) ; $ files = Contao \ System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; Contao \ System :: loadLanguageFile ( $ strTable ) ; $ this -> loadDataContainer ( $ strTable ) ; } $ arrReturn = array ( ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] as $ k => $ v ) { if ( \ is_array ( $ v [ 'fields' ] ) ) { foreach ( $ v [ 'fields' ] as $ kk => $ vv ) { if ( $ k == 'tl_user' && $ kk == 'admin' && ! $ this -> User -> isAdmin ) { continue ; } if ( $ vv [ 'exclude' ] || $ vv [ 'orig_exclude' ] ) { $ arrReturn [ $ k ] [ Contao \ StringUtil :: specialchars ( $ k . '::' . $ kk ) ] = isset ( $ vv [ 'label' ] [ 0 ] ) ? $ vv [ 'label' ] [ 0 ] . ' <span style="color:#999;padding-left:3px">[' . $ kk . ']</span>' : $ kk ; } } } } ksort ( $ arrReturn ) ; return $ arrReturn ; }
9591	public function radioListWithGap ( $ items , $ options = [ ] ) { $ this -> addListInputCssClass ( $ options , $ this -> radioGapCssClass ) ; return self :: radioList ( $ items , $ options ) ; }
280	private function confirmLoad ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be loaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be loaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } $ this -> stdout ( "\nBe aware that:\n" , Console :: BOLD ) ; $ this -> stdout ( "Applying leads to purging of certain data in the database!\n" , Console :: FG_RED ) ; return $ this -> confirm ( "\nLoad above fixtures?" ) ; }
7387	public static final function generateThumbnailsFrom ( $ files , array $ size ) { foreach ( $ files as $ file ) { self :: generateThumbnail ( $ file -> getRecord ( ) , $ size ) ; } }
2880	public function disableTranslateAction ( ) { try { $ this -> getService ( ) -> setTranslateInline ( 0 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Translate inline cannot be disabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
178	public static function filter ( $ array , $ filters ) { $ result = [ ] ; $ forbiddenVars = [ ] ; foreach ( $ filters as $ var ) { $ keys = explode ( '.' , $ var ) ; $ globalKey = $ keys [ 0 ] ; $ localKey = isset ( $ keys [ 1 ] ) ? $ keys [ 1 ] : null ; if ( $ globalKey [ 0 ] === '!' ) { $ forbiddenVars [ ] = [ substr ( $ globalKey , 1 ) , $ localKey , ] ; continue ; } if ( ! array_key_exists ( $ globalKey , $ array ) ) { continue ; } if ( $ localKey === null ) { $ result [ $ globalKey ] = $ array [ $ globalKey ] ; continue ; } if ( ! isset ( $ array [ $ globalKey ] [ $ localKey ] ) ) { continue ; } if ( ! array_key_exists ( $ globalKey , $ result ) ) { $ result [ $ globalKey ] = [ ] ; } $ result [ $ globalKey ] [ $ localKey ] = $ array [ $ globalKey ] [ $ localKey ] ; } foreach ( $ forbiddenVars as $ var ) { list ( $ globalKey , $ localKey ) = $ var ; if ( array_key_exists ( $ globalKey , $ result ) ) { unset ( $ result [ $ globalKey ] [ $ localKey ] ) ; } } return $ result ; }
11637	public function getTableRegistry ( ) { if ( is_null ( $ this -> _tableRegistry ) ) { $ objectTypeClass = Yii :: $ app -> classes [ 'ObjectTypeRegistry' ] ; $ this -> _tableRegistry = [ ] ; if ( $ objectTypeClass :: tableExists ( ) ) { $ om = $ objectTypeClass :: find ( ) -> all ( ) ; $ this -> _tableRegistry = ArrayHelper :: index ( $ om , 'name' ) ; } } return $ this -> _tableRegistry ; }
3498	private function createChainVisitor ( ) : HttpProtocolChainVisitor { $ chainVisitors = new HttpProtocolChainVisitor ( ) ; $ visitors = clone $ this -> visitors ; $ priority = 0 ; foreach ( $ visitors as $ visitor ) { $ chainVisitors -> add ( $ visitor , ++ $ priority ) ; } return $ chainVisitors ; }
3032	public function getSessionState ( AssessmentTestSession $ session ) { $ deliveryExecution = $ this -> getDeliveryExecution ( $ session ) ; return $ deliveryExecution -> getState ( ) -> getUri ( ) ; }
5894	public function retrieveAudioTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/audiotemplate' , $ parameters , $ cachePolicy ) ; $ result = new AudioTemplate ( $ result ) ; return $ result ; }
5324	public function dispatch ( ) { pcntl_signal_dispatch ( ) ; foreach ( $ this -> signalQueue as $ signal ) { foreach ( $ this -> handlers [ $ signal ] as & $ callable ) { call_user_func ( $ callable , $ signal ) ; } } return $ this ; }
3115	public function storeItemHrefIndex ( $ testSessionId , $ table ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setItemHrefIndex ( $ table ) ; $ extendedState -> save ( ) ; }
3328	private function getPriceConfigurations ( ) { static $ priceConfigurations ; if ( null === $ priceConfigurations ) { $ priceConfigurations = $ this -> itemsSalesPricesApi -> findAll ( ) ; $ shopIdentities = $ this -> identityService -> findBy ( [ 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Shop :: TYPE , ] ) ; $ shopIdentities = array_filter ( $ shopIdentities , function ( Identity $ identity ) { $ isMappedIdentity = $ this -> identityService -> isMappedIdentity ( $ identity -> getObjectIdentifier ( ) , $ identity -> getObjectType ( ) , $ identity -> getAdapterName ( ) ) ; if ( ! $ isMappedIdentity ) { return false ; } return true ; } ) ; if ( empty ( $ shopIdentities ) ) { $ priceConfigurations = [ ] ; return $ priceConfigurations ; } $ priceConfigurations = array_filter ( $ priceConfigurations , function ( $ priceConfiguration ) use ( $ shopIdentities ) { foreach ( $ shopIdentities as $ identity ) { foreach ( ( array ) $ priceConfiguration [ 'clients' ] as $ client ) { if ( $ client [ 'plentyId' ] === - 1 || $ identity -> getAdapterIdentifier ( ) === ( string ) $ client [ 'plentyId' ] ) { return true ; } } } return false ; } ) ; if ( empty ( $ priceConfigurations ) ) { $ this -> logger -> notice ( 'no valid price configuration found' ) ; } } return $ priceConfigurations ; }
12906	public function show ( $ id , FilterRequest $ request ) { $ id = $ this -> getRealId ( $ id ) ; $ request -> criteria [ ] = 'id,=,' . $ id ; $ resource = $ this -> repository -> filter ( $ request ) -> first ( ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
7498	public function createAndSendMessageFromTemplate ( ) { $ args = func_get_args ( ) ; if ( empty ( $ args [ 0 ] ) ) { throw new \ RuntimeException ( 'First parameter must be a template filename or EmailTemplate entity' ) ; } elseif ( $ args [ 0 ] instanceof EmailTemplate ) { $ method = 'createMessageFromTemplateEntity' ; } else { $ method = 'createMessageFromTemplateFile' ; } $ message = call_user_func_array ( array ( $ this , $ method ) , $ args ) ; $ this -> mailer -> send ( $ message ) ; return true ; }
1226	private function inside ( array & $ chars , $ delim , $ type ) { $ position = key ( $ chars ) ; $ current = next ( $ chars ) ; $ buffer = '' ; while ( $ current !== $ delim ) { if ( $ current === '\\' ) { $ buffer .= '\\' ; $ current = next ( $ chars ) ; } if ( $ current === false ) { return [ 'type' => self :: T_UNKNOWN , 'value' => $ buffer , 'pos' => $ position ] ; } $ buffer .= $ current ; $ current = next ( $ chars ) ; } next ( $ chars ) ; return [ 'type' => $ type , 'value' => $ buffer , 'pos' => $ position ] ; }
6049	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyResponse ( $ item ) ; } return $ this ; }
6913	public function addShipment ( ShipmentInterface $ shipment ) { if ( ! $ this -> shipments -> contains ( $ shipment ) ) { $ this -> shipments -> add ( $ shipment ) ; } return $ this ; }
9505	public function index ( ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DASHBOARD ) ; $ stats = $ this -> logViewer -> statsTable ( ) ; $ percents = $ this -> calcPercentages ( $ stats -> footer ( ) , $ stats -> header ( ) ) ; $ this -> setTitle ( 'LogViewer Dashboard' ) ; $ this -> addBreadcrumb ( 'Dashboard' ) ; return $ this -> view ( 'admin.system.log-viewer.dashboard' , compact ( 'percents' ) ) ; }
1276	private function isMailInnovations ( ) { $ patterns = [ '/^MI\d{6}\d{1,22}$/' , '/^94071\d{17}$/' , '/^7\d{19}$/' , '/^93033\d{17}$/' , '/^M\d{9}$/' , '/^82\d{10}$/' , '/^EC\d{9}US$/' , '/^927\d{23}$/' , '/^927\d{19}$/' , '/^EA\d{9}US$/' , '/^CP\d{9}US$/' , '/^92055\d{17}$/' , '/^14\d{18}$/' , '/^92088\d{17}$/' , '/^RA\d{9}US$/' , '/^9202\d{16}US$/' , '/^23\d{16}US$/' , '/^94\d{20}$/' , '/^03\d{18}$/' ] ; foreach ( $ patterns as $ pattern ) { if ( preg_match ( $ pattern , $ this -> trackingNumber ) ) { return true ; } } return false ; }
9449	protected function allowed ( $ method ) { if ( in_array ( $ method , $ this -> allowed ) === false ) { $ message = 'Used method is not allowed' ; throw new \ UnexpectedValueException ( $ message ) ; } return true ; }
9642	public function resolve ( $ path ) { $ paths = [ ] ; foreach ( $ this -> paths as $ configuredPath ) { $ paths [ ] = $ configuredPath . '/' . $ path ; } $ parts = explode ( '/' , $ path ) ; if ( count ( $ parts ) == 1 ) { return $ paths ; } $ current = '' ; $ mountPaths = [ ] ; foreach ( $ parts as $ part ) { if ( $ current ) { $ current .= '/' . $ part ; } else { $ current = $ part ; } if ( isset ( $ this -> mounts [ $ current ] ) ) { foreach ( $ this -> mounts [ $ current ] as $ mount ) { $ relativePath = str_replace ( $ current , '' , $ path ) ; $ mountPaths [ ] = $ mount . $ relativePath ; } } } return array_merge ( $ mountPaths , $ paths ) ; }
2803	public function setProxyTargetDir ( string $ proxyTargetDir ) : void { if ( ! is_dir ( $ proxyTargetDir ) ) { throw new InvalidArgumentException ( sprintf ( 'Proxy target directory "%s" does not exist!' , $ proxyTargetDir ) , 10 ) ; } if ( ! is_writable ( $ proxyTargetDir ) ) { throw new InvalidArgumentException ( sprintf ( 'Proxy target directory "%s" is not writable!' , $ proxyTargetDir ) , 20 ) ; } $ this -> proxyTargetDir = $ proxyTargetDir ; }
6150	public function setJsonBody ( $ data ) { $ this -> addHeader ( "Content-Type: application/json; charset=utf8" ) ; $ this -> setBody ( json_encode ( $ data , JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES ) ) ; return $ this ; }
1686	public function updateCurrentUser ( Contao \ DataContainer $ dc ) { if ( $ this -> User -> id == $ dc -> id ) { $ this -> User -> findBy ( 'id' , $ this -> User -> id ) ; } }
3503	private function prepareCurlResourceByRequest ( Request $ request ) : void { curl_setopt ( $ this -> resource , CURLOPT_URL , $ request -> getUrl ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_POSTFIELDS , $ request -> getContent ( ) ) ; if ( $ request -> getCertificate ( ) ) { curl_setopt ( $ this -> resource , CURLOPT_SSLCERT , $ request -> getCertificate ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_SSLCERTPASSWD , $ request -> getCertificatePassPhrase ( ) ) ; } $ inlineHeaders = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ inlineHeaders [ ] = sprintf ( '%s: %s' , $ name , $ value ) ; } curl_setopt ( $ this -> resource , CURLOPT_HTTPHEADER , $ inlineHeaders ) ; }
2478	protected function getRequestHeaders ( Message $ message , Endpoint $ endpoint ) { $ headers = $ message -> headers ; if ( $ endpoint -> user !== null ) { $ headers [ 'Authorization' ] = 'Basic ' . base64_encode ( "{$endpoint->user}:{$endpoint->pass}" ) ; } $ requestHeaders = '' ; foreach ( $ headers as $ name => $ value ) { if ( is_numeric ( $ name ) ) { throw new \ RuntimeException ( "Invalid HTTP header name $name" ) ; } $ requestHeaders .= "$name: $value\r\n" ; } return $ requestHeaders ; }
5083	protected function lookUpResource ( $ aData = [ ] , $ iSegment = 4 ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sIdentifier = $ oUri -> segment ( $ iSegment ) ; $ oInput = Factory :: service ( 'Input' ) ; $ aData = array_merge ( static :: CONFIG_LOOKUP_DATA , $ aData ) ; $ aExpansions = array_filter ( ( array ) $ oInput -> get ( 'expand' ) ) ; if ( $ aExpansions ) { if ( ! array_key_exists ( 'expand' , $ aData ) ) { $ aData [ 'expand' ] = [ ] ; } $ aData [ 'expand' ] = array_merge ( $ aData [ 'expand' ] , $ aExpansions ) ; } switch ( static :: CONFIG_LOOKUP_METHOD ) { case 'ID' : return $ this -> oModel -> getById ( $ sIdentifier , $ aData ) ; break ; case 'SLUG' : return $ this -> oModel -> getBySlug ( $ sIdentifier , $ aData ) ; break ; case 'TOKEN' : return $ this -> oModel -> getByToken ( $ sIdentifier , $ aData ) ; break ; } }
4176	public function getFacades ( ) { return $ this -> facades ? : $ this -> facades = new Facade ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
5824	public function setMethod ( $ method ) { $ method = strtolower ( $ method ) ; if ( ! array_key_exists ( $ method , $ this -> curl -> getAllowedMethods ( ) ) ) { throw new \ InvalidArgumentException ( "Method [$method] not a valid HTTP method." ) ; } $ this -> method = $ method ; return $ this ; }
10955	protected function redirect ( Response $ response , int $ code , string $ url ) : Response { return $ response -> withStatus ( $ code ) -> withHeader ( 'Location' , $ url ) ; }
7673	function TbsStorePark ( ) { if ( $ this -> TbsCurrIdx !== false ) { $ this -> TbsStoreLst [ $ this -> TbsCurrIdx ] = array ( 'src' => $ this -> TBS -> Source , 'onshow' => true ) ; $ this -> TBS -> Source = '' ; $ this -> TbsCurrIdx = false ; } }
11420	protected function getCache ( $ pk ) { $ app = App :: getInstance ( ) ; return $ app [ 'cache' ] -> getItem ( $ this -> dbtable . '/' . $ pk -> getValue ( ) ) ; }
6978	protected function normalizeAttachment ( AttachmentInterface $ attachment ) { $ formatter = $ this -> getFormatter ( ) ; return [ 'id' => $ attachment -> getId ( ) , 'title' => $ attachment -> getTitle ( ) , 'type' => $ attachment -> getType ( ) , 'size' => $ attachment -> getSize ( ) , 'internal' => $ attachment -> isInternal ( ) , 'file' => pathinfo ( $ attachment -> getPath ( ) , PATHINFO_BASENAME ) , 'created_at' => ( $ date = $ attachment -> getCreatedAt ( ) ) ? $ date -> format ( 'Y-m-d H:i:s' ) : null , 'f_created_at' => ( $ date = $ attachment -> getCreatedAt ( ) ) ? $ formatter -> dateTime ( $ date ) : null , 'updated_at' => ( $ date = $ attachment -> getUpdatedAt ( ) ) ? $ date -> format ( 'Y-m-d H:i:s' ) : null , 'f_updated_at' => ( $ date = $ attachment -> getUpdatedAt ( ) ) ? $ formatter -> dateTime ( $ date ) : null , ] ; }
12318	protected function searchQuery ( Builder $ query , string $ phrase ) { return $ query -> where ( function ( Builder $ query ) use ( $ phrase ) { $ query -> where ( 'url' , 'LIKE' , '%' . $ phrase . '%' ) -> orWhere ( 'short_url_key' , 'LIKE' , '%' . $ phrase . '%' ) -> orWhere ( 'clicks' , 'LIKE' , '%' . $ phrase . '%' ) -> orWhere ( 'url' , 'LIKE' , '%' . $ phrase . '%' ) ; } ) ; }
3923	protected function getConnection ( ) { if ( null === $ this -> connection ) { @ trigger_error ( 'Connection is missing in class ' . static :: class . '. The automatic fallback will be dropped in MetaModels 3.0. Please use dependency injection' , E_USER_DEPRECATED ) ; return $ this -> connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; } return $ this -> connection ; }
6281	public static function buildDnsResolver ( LoopInterface $ loop , $ dns = '8.8.8.8' ) { $ factory = new DnsResolverFactory ( ) ; return $ factory -> createCached ( $ dns , $ loop ) ; }
1510	public function getRelatedUrl ( string $ type , $ id , string $ field , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id , $ field ] , $ params ) ; }
2499	private function getAlwaysAvailableFilter ( array $ languageCodes ) { $ conditions = array ( new CustomField ( self :: FIELD_IS_ALWAYS_AVAILABLE , Operator :: EQ , true ) , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ languageCodes ) ) , ) ; if ( $ this -> hasMainLanguagesEndpoint ) { $ conditions [ ] = new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ; } return new LogicalAnd ( $ conditions ) ; }
8717	public static function forceCreate ( array $ attributes , $ translations = [ ] ) { $ model = new static ; return static :: unguarded ( function ( ) use ( $ model , $ attributes , $ translations ) { return $ model -> create ( $ attributes , $ translations ) ; } ) ; }
4481	public function setInterval ( int $ interval ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'interval' , $ interval ) ) { $ this -> interval = $ interval ; } }
12356	public function generate ( ) { if ( ! $ this -> configurationHandler -> isTheme ( ) || $ this -> theme -> getName ( ) != $ this -> configurationHandler -> handledTheme ( ) ) { return ; } $ templates = array_keys ( $ this -> templates [ "template" ] ) ; $ homepage = json_decode ( file_get_contents ( $ this -> configurationHandler -> pagesDir ( ) . '/' . $ this -> configurationHandler -> homepage ( ) . '/page.json' ) , true ) ; $ homepageTemplate = $ homepage [ "template" ] ; if ( ! in_array ( $ homepageTemplate , $ templates ) ) { $ homepageTemplate = $ templates [ 0 ] ; } $ themeDefinition = array ( "home_template" => $ homepageTemplate , "templates" => $ templates , ) ; $ this -> synchronizeThemeSlots ( ) ; FilesystemTools :: writeFile ( $ this -> themeDir . '/theme.json' , json_encode ( $ themeDefinition ) ) ; }
2325	public function __isset ( $ strKey ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } return isset ( $ this -> arrModels [ $ this -> intIndex ] -> $ strKey ) ; }
6180	protected function write ( array $ record ) { $ severity = $ this -> getSeverity ( $ record [ 'level' ] ) ; if ( isset ( $ record [ 'context' ] [ 'exception' ] ) ) { $ this -> client -> notifyException ( $ record [ 'context' ] [ 'exception' ] , function ( \ Bugsnag \ Report $ report ) use ( $ record , $ severity ) { $ report -> setSeverity ( $ severity ) ; if ( isset ( $ record [ 'extra' ] ) ) { $ report -> setMetaData ( $ record [ 'extra' ] ) ; } } ) ; } else { $ this -> client -> notifyError ( ( string ) $ record [ 'message' ] , ( string ) $ record [ 'formatted' ] , function ( \ Bugsnag \ Report $ report ) use ( $ record , $ severity ) { $ report -> setSeverity ( $ severity ) ; if ( isset ( $ record [ 'extra' ] ) ) { $ report -> setMetaData ( $ record [ 'extra' ] ) ; } } ) ; } }
11310	public static function setMappings ( array $ messages , $ manual = true ) { $ class = get_called_class ( ) ; if ( $ manual ) { static :: $ messages = $ messages ; self :: setStatus ( ) ; } else { self :: $ mappings [ $ class ] = array_replace ( $ class :: getMappings ( ) , $ messages ) ; } }
3500	public function withApnId ( ApnId $ apnId = null ) : Notification { $ cloned = clone $ this ; $ cloned -> apnId = $ apnId ; return $ cloned ; }
7552	function getChildrenByCallback ( $ callback , $ recursive = true , $ check_self = false ) { $ count = $ this -> childCount ( ) ; if ( $ check_self && $ callback ( $ this ) ) { $ res = array ( $ this ) ; } else { $ res = array ( ) ; } if ( $ count > 0 ) { if ( is_int ( $ recursive ) ) { $ recursive = ( ( $ recursive > 1 ) ? $ recursive - 1 : false ) ; } for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { if ( $ callback ( $ this -> children [ $ i ] ) ) { $ res [ ] = $ this -> children [ $ i ] ; } if ( $ recursive ) { $ res = array_merge ( $ res , $ this -> children [ $ i ] -> getChildrenByCallback ( $ callback , $ recursive ) ) ; } } } return $ res ; }
10679	private function _sklStd ( $ slovo , $ ii , $ zivotne ) { if ( $ ii < 0 || $ ii > \ count ( $ this -> vzor ) ) { $ this -> astrTvar [ 0 ] = '!!!???' ; } $ count = \ count ( $ this -> v0 ) ; for ( $ jj = 0 ; $ jj < $ count ; $ jj ++ ) { if ( $ this -> _isShoda ( $ this -> v0 [ $ jj ] , $ slovo ) >= 0 ) { return null ; } } $ this -> astrTvar [ 0 ] = $ this -> vzor [ $ ii ] [ 0 ] ; for ( $ jj = 1 ; $ jj < 15 ; $ jj ++ ) { $ this -> astrTvar [ $ jj ] = $ this -> _sklon ( $ jj , $ ii , $ slovo , $ zivotne ) ; } $ count = \ count ( $ this -> v3 ) ; for ( $ jj = 0 ; $ jj < $ count ; $ jj ++ ) { if ( $ this -> _isShoda ( $ this -> v3 [ $ jj ] , $ slovo ) >= 0 ) { return ; } } }
3178	public function getItemClasses ( ) { $ itemClass = $ this -> getClass ( self :: ITEM_ROOT_CLASS_URI ) ; return $ this -> getResourceService ( ) -> getAllClasses ( $ itemClass ) ; }
10228	private function resolveModelName ( $ model ) { if ( $ model instanceof Controller ) { $ exploded = explode ( '\\' , get_class ( $ model ) ) ; $ controllerName = array_pop ( $ exploded ) ; return str_singular ( str_replace ( 'Controller' , '' , $ controllerName ) ) ; } else if ( $ model instanceof Eloquent ) { return get_class ( $ model ) ; } else { return $ model ; } }
6045	protected function renderItems ( $ items ) { $ lines = [ ] ; foreach ( $ items as $ i => $ item ) { if ( isset ( $ item [ 'visible' ] ) && ! $ item [ 'visible' ] ) { unset ( $ items [ $ i ] ) ; continue ; } if ( is_string ( $ item ) ) { $ lines [ ] = $ item ; continue ; } $ options = ArrayHelper :: getValue ( $ item , 'options' , [ ] ) ; if ( isset ( $ item [ 'divider' ] ) ) { Html :: addCssClass ( $ options , 'divider' ) ; $ lines [ ] = Html :: tag ( 'li' , '' , $ options ) ; continue ; } if ( ! isset ( $ item [ 'label' ] ) ) { throw new InvalidConfigException ( "The 'label' option is required." ) ; } $ label = $ this -> encodeLabels ? Html :: encode ( $ item [ 'label' ] ) : $ item [ 'label' ] ; $ linkOptions = ArrayHelper :: getValue ( $ item , 'linkOptions' , [ ] ) ; $ linkOptions [ 'tabindex' ] = '-1' ; $ badgeOptions = ArrayHelper :: getValue ( $ item , 'badgeOptions' , [ ] ) ; $ label = Html :: tag ( 'i' , '' , $ linkOptions ) . Html :: tag ( 'span' , $ label ) ; $ label .= $ this -> renderBadge ( $ badgeOptions ) ; $ content = Html :: a ( $ label , ArrayHelper :: getValue ( $ item , 'url' , '#' ) ) ; if ( ! empty ( $ item [ 'items' ] ) ) { $ content .= $ this -> renderItems ( $ item [ 'items' ] ) ; Html :: addCssClass ( $ options , 'dropdown-submenu' ) ; } $ lines [ ] = Html :: tag ( 'li' , $ content , $ options ) ; } return Html :: tag ( 'ul' , implode ( "\n" , $ lines ) , $ this -> options ) ; }
9062	private function getTableSchema ( ) : ? Row { return $ this -> connection -> query ( " SELECT [tab.ENGINE], [col.COLLATION_NAME], [col.CHARACTER_SET_NAME] FROM [information_schema.TABLES] tab JOIN [information_schema.COLLATION_CHARACTER_SET_APPLICABILITY] col ON [tab.TABLE_COLLATION] = [col.COLLATION_NAME] WHERE [tab.TABLE_SCHEMA] = %s AND [tab.TABLE_NAME] = %s" , $ this -> database , $ this -> name ) -> fetch ( ) ; }
9432	protected static function random ( $ float_min , $ float_max ) { if ( $ float_max >= 0 ) { $ r = new Random ( ) ; while ( true ) { $ float_prov = $ float_max * $ r -> get ( ) ; if ( $ float_prov >= $ float_min ) { return $ float_prov ; } } } else { $ r = new Random ( ) ; while ( true ) { $ float_prov = $ float_min * $ r -> get ( ) ; if ( $ float_prov <= $ float_max ) { return $ float_prov ; } } } }
5079	public function postRemap ( ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'post' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ aFields = $ oItemModel -> describeFields ( ) ; $ aValid = [ ] ; $ aInvalid = [ ] ; foreach ( $ aFields as $ oField ) { if ( in_array ( $ oField -> key , static :: CONFIG_POST_IGNORE_FIELDS ) ) { continue ; } $ aValid [ ] = $ oField -> key ; } $ aPost = $ oInput -> post ( ) ; foreach ( $ aPost as $ sKey => $ sValue ) { if ( ! in_array ( $ sKey , $ aValid ) ) { $ aInvalid [ ] = $ sKey ; } } if ( ! empty ( $ aInvalid ) ) { throw new ApiException ( 'The following arguments are invalid: ' . implode ( ', ' , $ aInvalid ) , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ iItemId = ( int ) $ oUri -> segment ( 4 ) ; if ( $ iItemId ) { $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( empty ( $ oItem ) ) { throw new ApiException ( 'Item does not exist' , $ oHttpCodes :: STATUS_NOT_FOUND ) ; } elseif ( ! $ oItemModel -> update ( $ iItemId , $ aPost ) ) { throw new ApiException ( 'Failed to update item. ' . $ oItemModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } elseif ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> disableCache ( ) ; } $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> enableCache ( ) ; } } else { $ oItem = $ oItemModel -> create ( $ aPost , true ) ; } $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
2542	protected function analyzeWithErrorCodeMsgQueryLevel ( SendResult $ response , $ qErr , $ qMsg , $ qLvl , $ lvlToText ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ lvlNodeList = $ domXpath -> query ( $ qLvl ) ; $ level = null ; if ( $ lvlNodeList -> length > 0 ) { if ( array_key_exists ( $ lvlNodeList -> item ( 0 ) -> nodeValue , $ lvlToText ) ) { $ level = $ lvlToText [ $ lvlNodeList -> item ( 0 ) -> nodeValue ] ; } } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ level ) ; } return $ analyzeResponse ; }
5927	public function retrieveCategory ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/categories/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
8709	protected function qualifyColumns ( $ columns ) { foreach ( $ columns as & $ column ) { if ( ! in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { continue ; } $ primary = $ this -> qualifyTranslationColumn ( $ column ) ; $ fallback = $ this -> qualifyTranslationColumn ( $ column , true ) ; if ( $ this -> model -> shouldFallback ( ) ) { $ column = new Expression ( $ this -> compileIfNull ( $ primary , $ fallback , $ column ) ) ; } else { $ column = $ primary ; } } return $ columns ; }
4634	public function getComputedAttachments ( ) : array { if ( ! $ this -> hasAttachments ( ) ) { return [ ] ; } $ attachments = $ this -> getAttachments ( ) ; $ dir = $ this -> getAttachmentsDir ( ) ; $ path = $ dir [ 'path' ] ?? null ; $ recursive = $ dir [ 'recursive' ] ?? false ; if ( is_string ( $ path ) && is_dir ( $ path ) ) { $ files = $ recursive ? new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ path , RecursiveDirectoryIterator :: SKIP_DOTS ) , RecursiveIteratorIterator :: CHILD_FIRST ) : new DirectoryIterator ( $ path ) ; foreach ( $ files as $ fileInfo ) { if ( $ fileInfo -> isDir ( ) ) { continue ; } $ attachments [ ] = $ fileInfo -> getPathname ( ) ; } } return $ attachments ; }
3012	public function unfollow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/unfollow' , $ options , false ) ; }
10806	protected function getConfig ( ) { $ config = array_replace ( $ this -> config , $ this -> dialect_config ) ; ksort ( $ config ) ; return $ config ; }
8335	public function removeScope ( $ scope ) { if ( $ this -> isValidScope ( $ scope ) && $ this -> hasScope ( $ scope ) ) { unset ( $ this -> scope [ $ scope ] ) ; } return $ this ; }
5991	public function setDeploymentDateRange ( $ deploymentDateRange ) { if ( $ deploymentDateRange instanceof DateTimeRange ) { $ this -> deploymentDateRange = $ deploymentDateRange ; } elseif ( is_array ( $ deploymentDateRange ) ) { $ this -> deploymentDateRange = new DateTimeRange ( $ deploymentDateRange ) ; } else { $ this -> deploymentDateRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
1945	public function sections ( $ key = null , $ template = null ) { if ( ! array_filter ( $ this -> sections ) ) { return ; } if ( $ key && ! isset ( $ this -> positions [ $ key ] ) ) { return ; } $ matches = array ( ) ; foreach ( $ this -> positions [ $ key ] as $ id => $ section ) { if ( ! empty ( $ this -> sections [ $ id ] ) ) { $ section [ 'content' ] = $ this -> sections [ $ id ] ; $ matches [ $ id ] = $ section ; } } if ( empty ( $ matches ) ) { return ; } $ this -> matches = $ matches ; if ( $ template === null ) { $ template = 'block_sections' ; } include $ this -> getTemplate ( $ template ) ; }
10500	public function lte ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value !== null && $ this -> value <= $ value ) { return true ; } return false ; }
8330	public function connect ( array $ params , $ username = null , $ password = null , array $ driverOptions = [ ] ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> connectWindows ( $ params , $ username , $ password , $ driverOptions ) ; } return $ this -> connectUnix ( $ params , $ username , $ password , $ driverOptions ) ; }
6227	public function removeOnFree ( bool $ activate = true ) : self { $ this -> storage -> removeOnFree ( $ activate ) ; return $ this ; }
966	public function dispatchAfterAuthenticate ( ) { $ jobsConfig = Config :: get ( 'shopify-app.after_authenticate_job' ) ; $ fireJob = function ( $ config ) { $ job = $ config [ 'job' ] ; if ( isset ( $ config [ 'inline' ] ) && $ config [ 'inline' ] === true ) { $ job :: dispatchNow ( $ this -> shop ) ; } else { $ job :: dispatch ( $ this -> shop ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.after_authenticate' ) ) ; } return true ; } ; if ( isset ( $ jobsConfig [ 0 ] ) ) { foreach ( $ jobsConfig as $ jobConfig ) { $ fireJob ( $ jobConfig ) ; } return true ; } if ( isset ( $ jobsConfig [ 'job' ] ) ) { return $ fireJob ( $ jobsConfig ) ; } return false ; }
1037	private function completeObjectValue ( ObjectType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ isTypeOf = $ returnType -> isTypeOf ( $ result , $ this -> exeContext -> contextValue , $ info ) ; if ( $ isTypeOf !== null ) { $ promise = $ this -> getPromise ( $ isTypeOf ) ; if ( $ promise ) { return $ promise -> then ( function ( $ isTypeOfResult ) use ( $ returnType , $ fieldNodes , $ path , & $ result ) { if ( ! $ isTypeOfResult ) { throw $ this -> invalidReturnTypeError ( $ returnType , $ result , $ fieldNodes ) ; } return $ this -> collectAndExecuteSubfields ( $ returnType , $ fieldNodes , $ path , $ result ) ; } ) ; } if ( ! $ isTypeOf ) { throw $ this -> invalidReturnTypeError ( $ returnType , $ result , $ fieldNodes ) ; } } return $ this -> collectAndExecuteSubfields ( $ returnType , $ fieldNodes , $ path , $ result ) ; }
255	public function beforeRun ( ) { $ event = new WidgetEvent ( ) ; $ this -> trigger ( self :: EVENT_BEFORE_RUN , $ event ) ; return $ event -> isValid ; }
9289	public function getDuration ( ) { $ executed = $ this -> getExecuted ( ) ; $ finished = $ this -> getFinished ( ) ; if ( is_null ( $ executed ) || is_null ( $ finished ) ) { return 0 ; } return strtotime ( $ finished ) - strtotime ( $ executed ) ; }
1271	public function noCandidates ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> NoCandidatesIndicator ) ; }
3510	public static function dbValue ( $ value , $ nullValue = 'NULL' ) { if ( $ value === null ) { return $ nullValue ; } if ( is_string ( $ value ) ) { return '\'' . str_replace ( '\'' , '\'\'' , $ value ) . '\'' ; } if ( is_bool ( $ value ) ) { return $ value ? '1' : '0' ; } return $ value ; }
4844	public static function singularize ( $ string ) { if ( substr ( $ string , - 1 ) == 's' ) { return substr ( $ string , 0 , - 1 ) ; } elseif ( substr ( $ string , - 1 ) == 'i' ) { return substr ( $ string , 0 , - 1 ) . 'us' ; } else { return $ string ; } }
720	public function binary ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BINARY , $ length ) ; }
11992	public function toArray ( ) { $ urls = [ ] ; $ actions = [ ] ; if ( count ( $ this -> items ) < 1 ) { return parent :: toArray ( ) ; } $ entity = $ this -> items [ 0 ] ; if ( is_array ( $ entity -> load ) ) { foreach ( $ entity -> load as $ k => $ load ) { $ this -> load ( $ load ) ; } } $ data = parent :: toArray ( ) ; $ actions = $ entity -> getActions ( ) ; if ( count ( $ actions ) > 0 ) { foreach ( $ data as $ k => $ resource ) { if ( count ( $ resource ) < 2 ) { continue ; } $ data [ $ k ] += [ 'actions' => $ actions ] ; } } $ data = $ this -> normalizeArray ( $ data ) ; return $ data ; }
5738	public function setDefaultSuffix ( $ defaultSuffix ) { $ this -> defaultSuffix = ( string ) $ defaultSuffix ; $ this -> defaultSuffix = ltrim ( $ this -> defaultSuffix , '.' ) ; return $ this ; }
1212	public static function isTruthy ( $ value ) { if ( ! $ value ) { return $ value === 0 || $ value === '0' ; } elseif ( $ value instanceof \ stdClass ) { return ( bool ) get_object_vars ( $ value ) ; } elseif ( $ value instanceof JmesPathableArrayInterface ) { return Utils :: isTruthy ( iterator_to_array ( $ value ) ) ; } elseif ( $ value instanceof JmesPathableObjectInterface ) { return ( bool ) $ value -> toArray ( ) ; } else { return true ; } }
2816	public function getCollectionsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getCollections ( ) as $ collection ) { $ data [ ] = array ( 'type' => $ collection -> getType ( ) , 'class' => $ collection -> getClass ( ) , 'sql' => $ collection -> getQuery ( ) , 'count' => $ collection -> getCount ( ) ) ; } return $ data ; }
2085	public static function addFiles ( $ files ) { foreach ( $ files as $ name => $ file ) { self :: addFile ( $ name , $ file ) ; } }
411	private function utf8Encode ( $ s ) { $ s .= $ s ; $ len = \ strlen ( $ s ) ; for ( $ i = $ len >> 1 , $ j = 0 ; $ i < $ len ; ++ $ i , ++ $ j ) { switch ( true ) { case $ s [ $ i ] < "\x80" : $ s [ $ j ] = $ s [ $ i ] ; break ; case $ s [ $ i ] < "\xC0" : $ s [ $ j ] = "\xC2" ; $ s [ ++ $ j ] = $ s [ $ i ] ; break ; default : $ s [ $ j ] = "\xC3" ; $ s [ ++ $ j ] = \ chr ( \ ord ( $ s [ $ i ] ) - 64 ) ; break ; } } return substr ( $ s , 0 , $ j ) ; }
677	public function getLinks ( $ absolute = false ) { $ currentPage = $ this -> getPage ( ) ; $ pageCount = $ this -> getPageCount ( ) ; $ links = [ Link :: REL_SELF => $ this -> createUrl ( $ currentPage , null , $ absolute ) , ] ; if ( $ currentPage > 0 ) { $ links [ self :: LINK_FIRST ] = $ this -> createUrl ( 0 , null , $ absolute ) ; $ links [ self :: LINK_PREV ] = $ this -> createUrl ( $ currentPage - 1 , null , $ absolute ) ; } if ( $ currentPage < $ pageCount - 1 ) { $ links [ self :: LINK_NEXT ] = $ this -> createUrl ( $ currentPage + 1 , null , $ absolute ) ; $ links [ self :: LINK_LAST ] = $ this -> createUrl ( $ pageCount - 1 , null , $ absolute ) ; } return $ links ; }
12840	static public function getMimeType ( $ filePath , $ default = 'application/octet-stream' ) { $ mimeType = finfo_file ( finfo_open ( FILEINFO_MIME_TYPE ) , $ filePath ) ; if ( $ mimeType === false ) { $ mimeType = $ default ; } return $ mimeType ; }
10651	public function validateCreate ( ) { $ validator = $ this -> getValidator ( 'create' ) ; if ( $ validator -> fails ( ) ) { $ this -> errors = $ validator -> messages ( ) ; return false ; } return true ; }
4332	private static function buildAttribArrayVal ( $ key , $ value = array ( ) ) { if ( $ key == 'class' ) { if ( ! \ is_array ( $ value ) ) { $ value = \ explode ( ' ' , $ value ) ; } $ value = \ array_filter ( \ array_unique ( $ value ) ) ; \ sort ( $ value ) ; $ value = \ implode ( ' ' , $ value ) ; } elseif ( $ key == 'style' ) { $ keyValues = array ( ) ; foreach ( $ value as $ k => $ v ) { $ keyValues [ ] = $ k . ':' . $ v . ';' ; } \ sort ( $ keyValues ) ; $ value = \ implode ( '' , $ keyValues ) ; } else { $ value = null ; } return $ value ; }
4931	public function updateValues ( ) { $ values = [ ] ; foreach ( $ this -> getItems ( ) as $ item ) { if ( ! is_null ( $ item ) ) { $ values [ ] = $ item -> getValueWithParents ( ) ; } } $ this -> values = $ values ; }
3056	public function persistLastCatItemOutput ( array $ lastCatItemOutput ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> setCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-item-output' , json_encode ( $ lastCatItemOutput ) ) ; }
5442	protected function dispatchTokens ( $ unmatched , $ matched , $ mode = false ) { if ( ! $ this -> invokeParser ( $ unmatched , LEXER_UNMATCHED ) ) { return false ; } if ( is_bool ( $ mode ) ) { return $ this -> invokeParser ( $ matched , LEXER_MATCHED ) ; } if ( $ this -> isModeEnd ( $ mode ) ) { if ( ! $ this -> invokeParser ( $ matched , LEXER_EXIT ) ) { return false ; } return $ this -> mode -> leave ( ) ; } if ( $ this -> isSpecialMode ( $ mode ) ) { $ this -> mode -> enter ( $ this -> decodeSpecial ( $ mode ) ) ; if ( ! $ this -> invokeParser ( $ matched , LEXER_SPECIAL ) ) { return false ; } return $ this -> mode -> leave ( ) ; } $ this -> mode -> enter ( $ mode ) ; return $ this -> invokeParser ( $ matched , LEXER_ENTER ) ; }
9041	public function getEnvValue ( array $ expectedEnv , array $ actualEnv ) { $ actualValue = '' ; $ isStarted = false ; foreach ( $ expectedEnv as $ key => $ defaultValue ) { if ( array_key_exists ( $ key , $ actualEnv ) ) { if ( $ this -> option ( 'force' ) ) { $ defaultValue = $ actualEnv [ $ key ] ; } else { $ actualValue .= sprintf ( "%s=%s\n" , $ key , $ actualEnv [ $ key ] ) ; continue ; } } if ( ! $ isStarted ) { $ isStarted = true ; if ( $ this -> option ( 'force' ) ) { $ this -> comment ( 'Update all parameters. Please provide them.' ) ; } else { $ this -> comment ( 'Some parameters are missing. Please provide them.' ) ; } } $ value = $ this -> ask ( $ key , $ defaultValue ) ; $ actualValue .= sprintf ( "%s=%s\n" , $ key , $ value ) ; } return $ actualValue ; }
8012	public static function forChallengeMessage ( $ challenge_message , $ code = 0 , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE ; $ reason_messages = [ ] ; if ( ( self :: CODE_FOR_INVALID_SIGNATURE & $ code ) === self :: CODE_FOR_INVALID_SIGNATURE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_SIGNATURE ; } if ( ( self :: CODE_FOR_INVALID_MESSAGE_TYPE & $ code ) === self :: CODE_FOR_INVALID_MESSAGE_TYPE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_MESSAGE_TYPE ; } $ message .= sprintf ( self :: MESSAGE_EXTENSION_FOR_REASONS_FORMAT , implode ( self :: MESSAGE_REASON_GLUE , $ reason_messages ) ) ; $ instance = new static ( $ message , $ code , $ previous ) ; $ instance -> challenge_message = $ challenge_message ; return $ instance ; }
11919	public function attr ( $ keys = [ ] ) { if ( ! is_array ( $ keys ) ) { $ keys = [ $ keys ] ; } $ out = '' ; foreach ( $ keys as $ key ) { $ value = $ this -> getValue ( $ key ) -> attr ( ) ; if ( ! empty ( $ value ) ) { $ out .= ' ' . $ value ; } } return ltrim ( $ out , ' ' ) ; }
5031	public function setLoadedPage ( $ loadedPage ) { $ this -> dispatch ( Event \ PageEvents :: PAGE_VIEW , new Event \ PageViewEvent ( $ loadedPage ) ) ; $ this -> loadedPage = $ loadedPage ; }
2953	protected function extractData ( $ text , $ template ) { preg_match ( '/' . $ template . '/s' , $ text , $ matches ) ; $ keys = array_filter ( array_keys ( $ matches ) , 'is_string' ) ; $ matches = array_intersect_key ( $ matches , array_flip ( $ keys ) ) ; if ( ! empty ( $ matches ) ) { return $ this -> cleanExtractedData ( $ matches ) ; } return false ; }
127	public function ensureBinariesPresence ( PackageInterface $ package ) { $ this -> binaryInstaller -> installBinaries ( $ package , $ this -> getInstallPath ( $ package ) , false ) ; }
5276	public function orderBy ( $ columns , $ direction = 'asc' ) { if ( is_string ( $ columns ) ) { $ columns = $ this -> argument_to_array ( $ columns ) ; } foreach ( $ columns as $ key => $ column ) { if ( is_numeric ( $ key ) ) { $ this -> statements [ 'orders' ] [ $ column ] = $ direction ; } else { $ this -> statements [ 'orders' ] [ $ key ] = $ column ; } } return $ this ; }
1547	public function registerCustom ( ) : void { if ( ! $ fn = $ this -> group ) { return ; } $ this -> router -> group ( [ ] , function ( ) use ( $ fn ) { $ fn ( new RouteRegistrar ( $ this -> router , [ 'controller' => $ this -> controller ( ) ] , [ self :: PARAM_RESOURCE_TYPE => $ this -> resourceType ] ) ) ; } ) ; }
3908	public function setAcceptedExtensions ( $ acceptedExtensions ) { $ allowedDownload = StringUtil :: trimsplit ( ',' , $ GLOBALS [ 'TL_CONFIG' ] [ 'allowedDownload' ] ) ; if ( ! is_array ( $ acceptedExtensions ) ) { $ acceptedExtensions = StringUtil :: trimsplit ( ',' , $ acceptedExtensions ) ; } $ this -> acceptedExtensions = array_map ( 'strtolower' , array_intersect ( $ allowedDownload , $ acceptedExtensions ) ) ; }
2359	public function isPreviewMode ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return $ token instanceof FrontendPreviewToken && $ token -> showUnpublished ( ) ; }
5366	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ this -> results [ ] = new SimpleResultOfFail ( parent :: getTestList ( ) , $ message ) ; }
7523	function parse_tag_default ( ) { if ( $ this -> status [ 'closing_tag' ] ) { $ this -> status [ 'attributes' ] = array ( ) ; $ this -> next_no_whitespace ( ) ; } else { if ( ! $ this -> parse_attributes ( ) ) { return false ; } } if ( $ this -> token !== self :: TOK_TAG_CLOSE ) { if ( $ this -> token === self :: TOK_SLASH_FORWARD ) { $ this -> status [ 'self_close' ] = true ; $ this -> next ( ) ; } elseif ( ( ( $ this -> status [ 'tag_name' ] [ 0 ] === '?' ) && ( $ this -> doc [ $ this -> pos ] === '?' ) ) || ( ( $ this -> status [ 'tag_name' ] [ 0 ] === '%' ) && ( $ this -> doc [ $ this -> pos ] === '%' ) ) ) { $ this -> status [ 'self_close' ] = true ; $ this -> pos ++ ; if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) && ( ! is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) ) { $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ; } else { $ this -> token = self :: TOK_UNKNOWN ; } } } if ( $ this -> token !== self :: TOK_TAG_CLOSE ) { $ this -> addError ( 'Expected ">", but found "' . $ this -> getTokenString ( ) . '"' ) ; if ( $ this -> next_pos ( '>' , false ) !== self :: TOK_UNKNOWN ) { $ this -> addError ( 'No ">" tag found for "' . $ this -> status [ 'tag_name' ] . '" tag' ) ; return false ; } } return true ; }
10718	public function paginate ( $ page = 1 , $ perPage = null , $ columns = [ '*' ] ) { $ perPage = $ perPage ? : $ this -> defaultPageSize ; $ query = $ this -> getQuery ( ) ; $ total = $ query -> getQuery ( ) -> getCountForPagination ( $ columns ) ; $ query -> getQuery ( ) -> forPage ( $ page , $ perPage ) ; $ results = $ query -> get ( $ columns ) ; $ results = new LengthAwarePaginator ( $ results , $ total , $ perPage , $ page ) ; return $ this -> returnResults ( $ results ) ; }
11481	public function save ( BlockManagerApprover $ approver , array $ options , $ saveCommonSlots = true ) { $ this -> contributorDefined ( ) ; $ filesystem = new Filesystem ( ) ; $ pageDir = $ this -> pagesDir . '/' . $ options [ "page" ] ; $ filesystem -> copy ( $ pageDir . '/' . $ this -> pageFile , $ pageDir . '/page.json' , true ) ; $ pageDir .= '/' . $ options [ "language" ] . '_' . $ options [ "country" ] ; if ( $ this -> seoFile != "seo.json" ) { $ sourceFile = $ pageDir . '/' . $ this -> seoFile ; $ values = json_decode ( file_get_contents ( $ sourceFile ) , true ) ; if ( array_key_exists ( "current_permalink" , $ values ) ) { $ values [ "changed_permalinks" ] [ ] = $ values [ "current_permalink" ] ; unset ( $ values [ "current_permalink" ] ) ; file_put_contents ( $ sourceFile , json_encode ( $ values ) ) ; } $ filesystem -> copy ( $ sourceFile , $ pageDir . '/seo.json' , true ) ; } $ approvedBlocks = $ this -> saveBlocks ( $ approver , $ pageDir , $ options ) ; if ( $ saveCommonSlots ) { $ slotsDir = $ this -> baseDir . '/slots' ; $ approvedCommonBlocks = $ this -> saveBlocks ( $ approver , $ slotsDir , $ options ) ; $ approvedBlocks = array_merge ( $ approvedBlocks , $ approvedCommonBlocks ) ; } Dispatcher :: dispatch ( PageEvents :: PAGE_SAVED , new PageSavedEvent ( $ pageDir , null , $ approvedBlocks ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully saved in production' , $ options [ "page" ] ) ) ; }
5227	public function bindList ( $ name ) { if ( ! isset ( $ this -> listBindings [ $ name ] ) ) { $ this -> listBindings [ $ name ] = $ this -> addBinding ( new ListBinding ( $ name ) ) ; } return $ this -> listBindings [ $ name ] ; }
3656	public function boot ( ) { $ environment = System :: getContainer ( ) -> get ( 'contao.framework' ) -> getAdapter ( Environment :: class ) ; $ script = explode ( '?' , $ environment -> get ( 'relativeRequest' ) , 2 ) [ 0 ] ; if ( ( 'contao/login' === $ script ) || ( 'contao/install' === $ script ) ) { return ; } $ connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; if ( ! $ connection -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' , 'tl_metamodel_dca' , 'tl_metamodel_dca_sortgroup' , 'tl_metamodel_dcasetting' , 'tl_metamodel_dcasetting_condition' , 'tl_metamodel_attribute' , 'tl_metamodel_filter' , 'tl_metamodel_filtersetting' , 'tl_metamodel_rendersettings' , 'tl_metamodel_rendersetting' , 'tl_metamodel_dca_combine' , ] ) ) { System :: getContainer ( ) -> get ( 'logger' ) -> error ( 'MetaModels startup interrupted. Not all MetaModels tables have been created.' ) ; return ; } $ event = new MetaModelsBootEvent ( ) ; $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT , $ event ) ; $ determinator = System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) ; switch ( true ) { case $ determinator -> currentScopeIsFrontend ( ) : $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT_FRONTEND , $ event ) ; break ; case $ determinator -> currentScopeIsBackend ( ) : $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT_BACKEND , $ event ) ; break ; default : } }
3723	public function addMetaModelNames ( $ metaModelNames ) { $ this -> metaModelNames = array_unique ( array_merge ( $ this -> metaModelNames , $ metaModelNames ) ) ; return $ this ; }
7785	public function setStatementClass ( $ statementClass ) { if ( ! is_callable ( $ statementClass ) && ! class_exists ( $ statementClass ) ) { throw new \ InvalidArgumentException ( '$statementClass must be a valid classname or a PHP callable' ) ; } $ this -> statementClass = $ statementClass ; return $ this ; }
4871	public function setEventPrototype ( EventInterface $ prototype ) { if ( ! $ prototype instanceof DependencyResultEvent ) { throw new \ InvalidArgumentException ( 'This event manager only accepts events of the type ' . DependencyResultEvent :: class ) ; } parent :: setEventPrototype ( $ prototype ) ; }
1415	public function invalidResource ( string $ path , ? string $ detail = null , array $ failed = [ ] ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_invalid' , 'code' ) , $ this -> trans ( 'resource_invalid' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_invalid' , 'detail' ) , $ this -> pointer ( $ path ) , $ failed ? compact ( 'failed' ) : null ) ; }
7461	public function sendPasswordResetEmail ( UserInterface $ user , $ subject = 'Password reset request' ) { $ hashedEntity = $ this -> createHash ( $ user ) ; $ this -> emailHelper -> createAndSendMessageFromTemplate ( 'OrkestraApplicationBundle:Email:setPassword.html.twig' , array ( 'user' => $ user , 'hash' => $ hashedEntity -> getHash ( ) ) , $ subject , $ user -> getEmail ( ) ) ; return $ hashedEntity ; }
9630	public function verifyAndMoveUploadedFile ( $ originSize , $ tmpDestination , $ publicDestination ) { $ remoteTempSize = $ this -> getSize ( $ tmpDestination ) ; $ this -> logger -> debug ( 'Temp size: ' . $ remoteTempSize ) ; $ this -> logger -> debug ( 'Origin size: ' . $ originSize ) ; if ( $ remoteTempSize <= 0 ) { throw new VerifySizeException ( 'Uploaded file has size ' . $ remoteTempSize ) ; } if ( $ remoteTempSize !== $ originSize ) { throw new VerifySizeException ( sprintf ( 'Uploaded file has wrong size. Expected %s, got %s.' , $ originSize , $ remoteTempSize ) ) ; } $ this -> logger -> info ( 'OK: Uploaded temp file has right size.' ) ; if ( ! $ this -> move ( $ tmpDestination , $ publicDestination ) ) { throw new FtpException ( 'Error renaming uploaded file from temp to public.' ) ; } $ remotePublicSize = $ this -> getSize ( $ publicDestination ) ; $ this -> logger -> debug ( 'Renamed size: ' . $ remotePublicSize ) ; if ( $ remotePublicSize <= 0 ) { throw new VerifySizeException ( 'Renamed file has size ' . $ remotePublicSize ) ; } if ( $ remotePublicSize !== $ originSize ) { throw new VerifySizeException ( sprintf ( 'Renamed file has wrong size. Expected %s, got %s.' , $ originSize , $ remotePublicSize ) ) ; } $ this -> logger -> info ( 'OK: Renamed file has right size.' ) ; return true ; }
6104	public function wait ( ) { if ( $ this -> getTransport ( ) -> getConfig ( "blocking" ) ) { throw new Ts3Exception ( "only available in non-blocking mode" ) ; } do { $ evt = $ this -> getTransport ( ) -> readLine ( ) ; var_dump ( $ evt ) ; } while ( $ evt instanceof StringHelper && ! $ evt -> section ( TeamSpeak3 :: SEPARATOR_CELL ) -> startsWith ( TeamSpeak3 :: EVENT ) ) ; return new Event ( $ evt , $ this -> getHost ( ) ) ; }
2599	public function skipUntil ( $ type ) { while ( $ this -> lookahead !== null && $ this -> lookahead [ 'type' ] !== $ type ) { $ this -> moveNext ( ) ; } }
264	protected function escapeColumnName ( $ columnName , & $ params = [ ] ) { if ( $ columnName instanceof Query ) { list ( $ sql , $ params ) = $ this -> queryBuilder -> build ( $ columnName , $ params ) ; return "($sql)" ; } elseif ( $ columnName instanceof ExpressionInterface ) { return $ this -> queryBuilder -> buildExpression ( $ columnName , $ params ) ; } elseif ( strpos ( $ columnName , '(' ) === false ) { return $ this -> queryBuilder -> db -> quoteColumnName ( $ columnName ) ; } return $ columnName ; }
2023	public static function findFirstPublishedByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.type!='root' AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findOneBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
204	public static function moveCursorTo ( $ column , $ row = null ) { if ( $ row === null ) { echo "\033[" . ( int ) $ column . 'G' ; } else { echo "\033[" . ( int ) $ row . ';' . ( int ) $ column . 'H' ; } }
10486	protected function retrieveMapping ( $ table ) { $ result = $ this -> connection -> fetchAll ( 'SELECT COLUMN_NAME, ORDINAL_POSITION FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ?' , [ $ table ] ) ; if ( empty ( $ result ) ) { return false ; } $ columns = [ ] ; foreach ( $ result as $ column ) { $ columns [ $ column [ 'ORDINAL_POSITION' ] ] = $ column [ 'COLUMN_NAME' ] ; } return $ columns ; }
3053	public function getCatEngine ( RouteItem $ routeItem = null ) { $ compiledDirectory = $ this -> getCompilationDirectory ( ) [ 'private' ] ; $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ compiledDirectory ) ; $ routeItem = $ routeItem ? $ routeItem : $ this -> getTestSession ( ) -> getRoute ( ) -> current ( ) ; $ sectionId = $ routeItem -> getAssessmentSection ( ) -> getIdentifier ( ) ; $ catEngine = false ; if ( isset ( $ adaptiveSectionMap [ $ sectionId ] ) ) { $ catEngine = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getEngine ( $ adaptiveSectionMap [ $ sectionId ] [ 'endpoint' ] ) ; } return $ catEngine ; }
7228	protected function parseHeader ( $ curl , $ header ) { if ( preg_match ( "/^([^:\s]+)\:\s+(.*)$/" , $ header , $ matches ) ) { $ matches [ 2 ] = trim ( $ matches [ 2 ] ) ; $ this -> lastHeader [ $ matches [ 1 ] ] = $ matches [ 2 ] ; $ this -> lastResultType = $ matches [ 1 ] === "Content-Type" ? $ matches [ 2 ] : $ this -> lastResultType ; } return strlen ( $ header ) ; }
12195	protected function extractArguments ( array $ arguments , array $ data ) { $ instanceArgs = [ ] ; foreach ( $ arguments as $ arg ) { if ( array_key_exists ( $ arg -> getName ( ) , $ data ) ) { $ instanceArgs [ ] = $ data [ $ arg -> getName ( ) ] ; } else { $ instanceArgs [ ] = null ; } } return $ instanceArgs ; }
1197	private function htmlAttributesCallback ( $ name , $ value ) { if ( false === $ value || null === $ value ) { return '' ; } return ' ' . $ this -> renderHtmlAttribute ( $ name , $ value ) ; }
4736	public function process ( ContainerBuilder $ container ) { $ serviceId = 'simple_bus.asynchronous.publishes_predefined_messages_middleware' ; if ( ! $ container -> hasDefinition ( $ serviceId ) ) { return ; } $ names = array ( ) ; $ this -> collectServiceIds ( $ container , 'asynchronous_event_subscriber' , 'subscribes_to' , function ( $ key ) use ( & $ names ) { $ names [ ] = $ key ; } ) ; $ container -> getDefinition ( $ serviceId ) -> replaceArgument ( 2 , array_unique ( $ names ) ) ; }
3340	public function getFilesChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'file_list' , 'GET' , $ options ) ; $ files_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ resultArr [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; }
5823	private function resolveOptions ( array $ options = array ( ) ) { $ this -> options [ 'alertPublisher' ] = $ this -> alertPublisher ; return array_merge ( $ this -> options , $ options ) ; }
666	public function renderItems ( ) { $ models = $ this -> dataProvider -> getModels ( ) ; $ keys = $ this -> dataProvider -> getKeys ( ) ; $ rows = [ ] ; foreach ( array_values ( $ models ) as $ index => $ model ) { $ key = $ keys [ $ index ] ; if ( ( $ before = $ this -> renderBeforeItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ before ; } $ rows [ ] = $ this -> renderItem ( $ model , $ key , $ index ) ; if ( ( $ after = $ this -> renderAfterItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ after ; } } return implode ( $ this -> separator , $ rows ) ; }
8613	public function setAdjustmentItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdjustmentItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8964	private static function matchesArrayCriteria ( $ key , $ object , array $ criteria ) { $ criteria = self :: extractArrayCriteria ( $ key , $ criteria ) ; if ( count ( $ criteria ) === 0 ) { return true ; } $ getter = sprintf ( 'get%s' , ucfirst ( $ key ) ) ; if ( ! method_exists ( $ object , $ getter ) ) { throw new RuntimeException ( sprintf ( 'Object instance of "%s" does not have required getter "%s" to be used for filtering.' , get_class ( $ object ) , $ getter ) ) ; } return in_array ( $ object -> { $ getter } ( ) , $ criteria , true ) ; }
5632	protected function removeTrailingSlash ( $ path ) { if ( substr ( $ path , - 1 ) == DIRECTORY_SEPARATOR ) { return substr ( $ path , 0 , - 1 ) ; } elseif ( substr ( $ path , - 1 ) == '/' ) { return substr ( $ path , 0 , - 1 ) ; } else { return $ path ; } }
9547	public function rank ( $ info , $ weights ) { if ( ! empty ( $ weights ) ) { $ weights = explode ( ',' , $ weights ) ; } $ score = ( float ) 0.0 ; $ isize = 4 ; $ phrases = ( int ) ord ( substr ( $ info , 0 , $ isize ) ) ; $ columns = ( int ) ord ( substr ( $ info , $ isize , $ isize ) ) ; $ string = $ phrases . ' ' . $ columns . ' ' ; for ( $ p = 0 ; $ p < $ phrases ; ++ $ p ) { $ term = substr ( $ info , ( 2 + $ p * $ columns * 3 ) * $ isize ) ; for ( $ c = 0 ; $ c < $ columns ; ++ $ c ) { $ here = ( float ) ord ( substr ( $ term , ( 3 * $ c * $ isize ) , 1 ) ) ; $ total = ( float ) ord ( substr ( $ term , ( 3 * $ c + 1 ) * $ isize , 1 ) ) ; $ rows = ( float ) ord ( substr ( $ term , ( 3 * $ c + 2 ) * $ isize , 1 ) ) ; $ relevance = ( ! empty ( $ total ) ) ? ( $ rows / $ total ) * $ here : 0 ; $ weight = ( isset ( $ weights [ $ c ] ) ) ? ( float ) $ weights [ $ c ] : 1 ; $ score += $ relevance * $ weight ; $ string .= $ here . $ total . $ rows . ' (' . round ( $ relevance , 2 ) . '*' . $ weight . ') ' ; } } return $ score ; }
2035	public function onUnregister ( Registry $ registry ) { parent :: onUnregister ( $ registry ) ; if ( $ this -> fallback && $ this -> type == 'root' && $ registry -> isRegisteredAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ) { $ registry -> unregisterAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ; } }
11212	protected function getFromLookup ( $ key ) { if ( $ key === $ this -> cache_key || $ this -> hasInLookup ( $ key ) ) { return $ this -> getFromRegistry ( $ this -> cache_reg , $ key ) ; } return null ; }
12757	public function routeStartup ( Zend_Controller_Request_Abstract $ request ) { if ( ! $ request -> getHeader ( 'User-Agent' ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 403 ) -> setHeader ( 'Content-Type' , 'text/plain; charset=utf-8' ) -> setBody ( implode ( "\n" , self :: $ _errMessage ) ) -> sendResponse ( ) ; exit ( 403 ) ; } }
10986	public static function getMaxUploadSize ( $ max_size = 0 ) { $ post_max_size = Tools :: unformatBytes ( ini_get ( 'post_max_size' ) ) ; $ upload_max_filesize = Tools :: unformatBytes ( ini_get ( 'upload_max_filesize' ) ) ; if ( $ max_size > 0 ) { $ result = min ( $ post_max_size , $ upload_max_filesize , $ max_size ) ; } else { $ result = min ( $ post_max_size , $ upload_max_filesize ) ; } return $ result ; }
11761	public static function set ( $ property , $ value = NULL ) { $ object = new \ ReflectionClass ( Collection :: class ) ; $ object -> setStaticPropertyValue ( $ property , $ value ) ; return true ; }
1841	public static function parse ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( 'Invalid file ' . $ file ) ; } $ table = '' ; $ return = array ( ) ; $ data = file ( $ file ) ; foreach ( $ data as $ k => $ v ) { $ key_name = array ( ) ; $ subpatterns = array ( ) ; if ( preg_match ( '/^[#-]+/' , $ v ) || ! \ strlen ( trim ( $ v ) ) ) { unset ( $ data [ $ k ] ) ; continue ; } if ( preg_match ( '/^CREATE TABLE `([^`]+)`/i' , $ v , $ subpatterns ) ) { $ table = $ subpatterns [ 1 ] ; } elseif ( $ table != '' && preg_match ( '/^\)([^;]+);/' , $ v , $ subpatterns ) ) { $ return [ $ table ] [ 'TABLE_OPTIONS' ] = $ subpatterns [ 1 ] ; $ table = '' ; } elseif ( $ table != '' ) { preg_match ( '/^[^`]*`([^`]+)`/' , trim ( $ v ) , $ key_name ) ; $ first = preg_replace ( '/\s[^\n\r]+/' , '' , $ key_name [ 0 ] ) ; $ key = $ key_name [ 1 ] ; if ( \ in_array ( $ first , array ( 'KEY' , 'PRIMARY' , 'PRIMARY KEY' , 'FOREIGN' , 'FOREIGN KEY' , 'INDEX' , 'UNIQUE' , 'FULLTEXT' , 'CHECK' ) ) ) { if ( strncmp ( $ first , 'PRIMARY' , 7 ) === 0 ) { $ key = 'PRIMARY' ; } $ return [ $ table ] [ 'TABLE_CREATE_DEFINITIONS' ] [ $ key ] = preg_replace ( '/,$/' , '' , trim ( $ v ) ) ; } else { $ return [ $ table ] [ 'TABLE_FIELDS' ] [ $ key ] = preg_replace ( '/,$/' , '' , trim ( $ v ) ) ; } } } foreach ( array_keys ( $ return ) as $ table ) { if ( ! isset ( $ return [ $ table ] [ 'TABLE_CREATE_DEFINITIONS' ] [ 'PRIMARY' ] ) ) { unset ( $ return [ $ table ] [ 'TABLE_OPTIONS' ] ) ; } } return $ return ; }
1724	public static function generateRandomSecret ( Event $ event ) : void { $ extra = $ event -> getComposer ( ) -> getPackage ( ) -> getExtra ( ) ; if ( ! isset ( $ extra [ 'incenteev-parameters' ] ) || ! self :: canGenerateSecret ( $ extra [ 'incenteev-parameters' ] ) ) { return ; } if ( ! \ function_exists ( 'random_bytes' ) ) { self :: loadRandomCompat ( $ event ) ; } putenv ( static :: RANDOM_SECRET_NAME . '=' . bin2hex ( random_bytes ( 32 ) ) ) ; }
1391	protected function resourceFieldsExistInAttributesAndRelationships ( iterable $ fields ) : void { foreach ( $ fields as $ field ) { $ this -> errors -> add ( $ this -> translator -> resourceFieldExistsInAttributesAndRelationships ( $ field ) ) ; } }
406	public function getIsFlash ( ) { $ userAgent = $ this -> headers -> get ( 'User-Agent' , '' ) ; return stripos ( $ userAgent , 'Shockwave' ) !== false || stripos ( $ userAgent , 'Flash' ) !== false ; }
8480	public function run ( $ eventGroupId = null ) { $ eventGroups = EventGroup :: find ( ) -> asArray ( true ) -> all ( ) ; if ( count ( $ eventGroups ) === 0 ) { throw new Exception ( 'Event groups not found' ) ; } if ( $ eventGroupId === null ) { $ first = reset ( $ eventGroups ) ; $ eventGroupId = $ first [ 'id' ] ; } $ tabs = [ ] ; foreach ( $ eventGroups as $ eventGroup ) { $ tabs [ ] = [ 'label' => $ eventGroup [ 'name' ] , 'url' => [ 'index' , 'eventGroupId' => $ eventGroup [ 'id' ] ] , 'active' => $ eventGroupId == $ eventGroup [ 'id' ] , ] ; } $ model = new EventEventHandler ( [ 'scenario' => 'search' ] ) ; $ eventsList = Event :: find ( ) -> select ( [ 'name' , 'id' ] ) -> where ( [ 'event_group_id' => $ eventGroupId ] ) -> indexBy ( 'id' ) -> column ( ) ; return $ this -> controller -> render ( 'index' , [ 'dataProvider' => $ model -> search ( \ Yii :: $ app -> request -> get ( ) , array_keys ( $ eventsList ) ) , 'eventGroupId' => $ eventGroupId , 'eventsList' => $ eventsList , 'model' => $ model , 'tabs' => $ tabs , ] ) ; }
10283	public static function buildRange ( array $ pRange ) { if ( empty ( $ pRange ) || ! is_array ( $ pRange [ 0 ] ) ) { throw new Exception ( 'Range does not contain any information' ) ; } $ imploded = [ ] ; $ counter = count ( $ pRange ) ; for ( $ i = 0 ; $ i < $ counter ; ++ $ i ) { $ pRange [ $ i ] = implode ( ':' , $ pRange [ $ i ] ) ; } $ imploded = implode ( ',' , $ pRange ) ; return $ imploded ; }
5613	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , false ) ; $ current = $ this -> _stack -> peek ( ) ; $ current -> putChild ( $ node ) ; $ current -> fail ( ) ; }
4608	public function createStatus ( string $ status , array $ options = null ) : array { $ url = '/statuses' ; if ( empty ( $ options ) ) { $ options = [ ] ; } $ params = array_merge ( [ 'status' => $ status , ] , $ options ) ; return $ this -> post ( $ url , $ params ) ; }
6095	public function permAssign ( $ permid , $ permvalue , $ permskip = false ) { return $ this -> getParent ( ) -> clientPermAssign ( $ this [ "client_database_id" ] , $ permid , $ permvalue , $ permskip ) ; }
4804	private function getTemplatePath ( ) { $ tsfe = $ GLOBALS [ 'TSFE' ] ; if ( isset ( $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ) ) { $ templateFile = GeneralUtility :: getFileAbsFileName ( $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ) ; if ( is_file ( $ templateFile ) ) { return $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ; } } return $ this -> getTemplatePathAndFilename ( $ this -> defaultTemplate ) ; }
4455	public function attach ( string $ eventName , $ handler , int $ priority = 100 ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } $ priorityQueue = $ this -> fetchQueue ( $ eventName ) ; $ priorityQueue -> insert ( $ handler , $ priority ) ; }
2529	protected function generateGuid ( ) { mt_srand ( ( double ) microtime ( ) * 10000 ) ; $ charId = strtoupper ( md5 ( uniqid ( rand ( ) , true ) ) ) ; $ hyphen = chr ( 45 ) ; $ uuid = substr ( $ charId , 0 , 8 ) . $ hyphen . substr ( $ charId , 8 , 4 ) . $ hyphen . substr ( $ charId , 12 , 4 ) . $ hyphen . substr ( $ charId , 16 , 4 ) . $ hyphen . substr ( $ charId , 20 , 12 ) ; return $ uuid ; }
6345	public static function filterBy ( Iterator $ unfiltered , string $ className ) : Iterator { return self :: filter ( $ unfiltered , Predicates :: instance ( $ className ) ) ; }
2649	public function setVclAsMain ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/vcl/' . $ name . '/main' ; $ result = $ this -> _fetch ( $ url , 'PUT' ) ; return $ result ; }
6702	protected function precedence ( $ a , $ b ) { if ( count ( $ a ) > count ( $ b ) ) { $ l = - 1 ; $ r = 1 ; $ x = $ a ; $ y = $ b ; } else { $ l = 1 ; $ r = - 1 ; $ x = $ b ; $ y = $ a ; } foreach ( array_keys ( $ x ) as $ i ) { if ( false === isset ( $ y [ $ i ] ) ) { return $ l ; } if ( $ x [ $ i ] === $ y [ $ i ] ) { continue ; } $ xi = is_integer ( $ x [ $ i ] ) ; $ yi = is_integer ( $ y [ $ i ] ) ; if ( $ xi && $ yi ) { return ( $ x [ $ i ] > $ y [ $ i ] ) ? $ l : $ r ; } elseif ( ( false === $ xi ) && ( false === $ yi ) ) { return ( max ( $ x [ $ i ] , $ y [ $ i ] ) == $ x [ $ i ] ) ? $ l : $ r ; } else { return $ xi ? $ r : $ l ; } } return 0 ; }
478	public function dropColumn ( $ table , $ column ) { $ time = $ this -> beginCommand ( "drop column $column from table $table" ) ; $ this -> db -> createCommand ( ) -> dropColumn ( $ table , $ column ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
7474	public function updateAction ( Request $ request , $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ id ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
1430	protected function deserializeSoftDelete ( $ value , $ field , $ record ) { if ( collect ( [ true , false , 1 , 0 , '1' , '0' ] ) -> containsStrict ( $ value ) ) { return $ value ? Carbon :: now ( ) : null ; } return $ this -> deserializeAttribute ( $ value , $ field , $ record ) ; }
6628	public function get ( $ key , $ default = null ) { return ArrayHelper :: getValue ( $ this -> parsedResponse , sprintf ( '%s.%s' , self :: RESPONSE_DATA_PARAM , $ key ) , $ default ) ; }
5373	public function getValue ( $ key ) { $ values = array ( ) ; foreach ( $ this -> request as $ pair ) { if ( $ pair -> isKey ( $ key ) ) { $ values [ ] = $ pair -> getValue ( ) ; } } if ( count ( $ values ) == 0 ) { return false ; } elseif ( count ( $ values ) == 1 ) { return $ values [ 0 ] ; } else { return $ values ; } }
9223	public function unserialize ( $ data ) { $ _data = unserialize ( $ data ) ; $ this -> page = $ _data [ 'page' ] ; $ this -> key = $ _data [ 'key' ] ; $ this -> data = $ _data [ 'data' ] ; $ this -> api = null ; $ this -> endpoint = null ; $ this -> pagination = array ( ) ; }
5284	public function limit ( $ limit , $ offset = 0 ) { global $ wpdb ; $ limit = \ absint ( $ limit ) ; $ offset = \ absint ( $ offset ) ; $ this -> limit = $ wpdb -> prepare ( 'limit %d, %d' , $ offset , $ limit ) ; return $ this ; }
11022	public function listTasks ( $ ostr = STDOUT ) { $ this -> findTasks ( ) ; if ( count ( $ this -> task_list ) === 0 ) { fprintf ( $ ostr , "No tasks available\n" ) ; } else { fprintf ( $ ostr , "Listing available tasks: \n" ) ; foreach ( $ this -> task_list as $ task => $ desc ) { $ task = str_replace ( '\\' , ':' , $ task ) ; fprintf ( $ ostr , "- %-30s" , $ task ) ; CLI :: formatText ( 32 , CLI :: MAX_LINE_LENGTH , ' ' . $ desc , $ ostr ) ; } printf ( "\n" ) ; } }
334	protected function getTableSequenceName ( $ tableName ) { $ sequenceNameSql = <<<'SQL'SELECT UD.REFERENCED_NAME AS SEQUENCE_NAMEFROM USER_DEPENDENCIES UD JOIN USER_TRIGGERS UT ON (UT.TRIGGER_NAME = UD.NAME)WHERE UT.TABLE_NAME = :tableName AND UD.TYPE = 'TRIGGER' AND UD.REFERENCED_TYPE = 'SEQUENCE'SQL ; $ sequenceName = $ this -> db -> createCommand ( $ sequenceNameSql , [ ':tableName' => $ tableName ] ) -> queryScalar ( ) ; return $ sequenceName === false ? null : $ sequenceName ; }
3947	private function handleNonMetaModelTable ( $ tableName ) { if ( substr ( $ tableName , 0 , 3 ) === 'mm_' ) { return ; } static $ map ; if ( ! isset ( $ map ) ) { $ map = $ this -> buildMap ( ) ; } if ( ! isset ( $ map [ $ tableName ] ) ) { return ; } $ parentDCA = & $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] ; $ this -> controller -> loadLanguageFile ( 'default' ) ; foreach ( $ map [ $ tableName ] as $ metaModelTable => $ inputScreen ) { $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelTable ) ; $ caption = $ this -> buildCaption ( $ metaModel , $ inputScreen ) ; $ operationName = 'edit_' . $ metaModel -> getTableName ( ) ; $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] = array ( 'label' => & $ caption , 'href' => 'table=' . $ metaModelTable , 'icon' => $ this -> iconBuilder -> getBackendIcon ( $ inputScreen [ 'meta' ] [ 'backendicon' ] ) , 'attributes' => 'onclick="Backend.getScrollOffset()"' , ) ; if ( $ metaModel -> hasVariants ( ) ) { $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'idparam' ] = 'id_' . $ tableName ; } else { $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'idparam' ] = 'pid' ; } if ( $ parentDCA [ 'config' ] [ 'dataContainer' ] !== 'General' ) { $ idParameter = $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'idparam' ] ; $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'button_callback' ] = function ( $ row , $ href , $ label , $ name , $ icon , $ attributes , $ table ) use ( $ idParameter ) { return $ this -> buildChildOperationButton ( $ idParameter , $ row [ 'id' ] , $ href , $ label , $ name , $ icon , $ attributes , $ table ) ; } ; } } }
9100	private function bind ( ) { if ( ! @ socket_bind ( $ this -> handle , $ this -> endpoint -> getAddress ( ) , $ this -> endpoint -> getPort ( ) ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
9155	private function parseAnnotations ( \ ReflectionMethod $ action ) { if ( $ action -> isConstructor ( ) || $ action -> isDestructor ( ) || $ action -> isStatic ( ) || $ action -> isFinal ( ) ) { return ; } $ rfMethod = new \ ReflectionMethod ( $ this , $ action -> name ) ; $ anno = $ rfMethod -> getDocComment ( ) ; if ( $ anno && preg_match ( '#@webMethod#' , $ anno ) ) { $ this -> actions [ ] = $ action -> name ; return ; } if ( ! $ this -> parseParameters ( $ action ) ) { return ; } $ this -> actions [ ] = $ action -> name ; }
3346	public function request ( $ method , $ path , $ data = array ( ) , $ headers = array ( ) ) { $ ch = curl_init ( sprintf ( 'https://%s%s' , $ this -> api_host , $ path ) ) ; $ this -> __setRequestType ( $ ch , $ method ) ; $ this -> __setHeaders ( $ ch , $ headers , $ data ) ; $ response = curl_exec ( $ ch ) ; if ( $ response === false ) { throw new \ Exception ( curl_error ( $ ch ) ) ; } $ ch_info = curl_getinfo ( $ ch ) ; $ header_size = curl_getinfo ( $ ch , CURLINFO_HEADER_SIZE ) ; $ header = substr ( $ response , 0 , $ header_size ) ; $ body = substr ( $ response , $ header_size ) ; $ error = false ; if ( $ method == 'DELETE' ) { if ( $ ch_info [ 'http_code' ] != 302 && $ ch_info [ 'http_code' ] != 200 ) { $ error = true ; } } else { if ( ! ( ( $ ch_info [ 'http_code' ] >= 200 ) && ( $ ch_info [ 'http_code' ] < 300 ) ) ) { $ error = true ; } } if ( $ ch_info [ 'http_code' ] == 429 ) { $ exception = new ThrottledRequestException ( ) ; $ response_headers = Helper :: parseHttpHeaders ( $ header ) ; $ exception -> setResponseHeaders ( $ response_headers ) ; throw $ exception ; } if ( $ error ) { $ errorInfo = array_filter ( array ( curl_error ( $ ch ) , $ body ) ) ; throw new \ Exception ( 'Request returned unexpected http code ' . $ ch_info [ 'http_code' ] . '. ' . join ( ', ' , $ errorInfo ) ) ; } curl_close ( $ ch ) ; if ( ! defined ( 'PHPUNIT_UPLOADCARE_TESTSUITE' ) && ( $ this -> public_key == 'demopublic_key' || $ this -> secret_key == 'demoprivatekey' ) ) { trigger_error ( 'You are using the demo account. Please get an Uploadcare account at https://uploadcare.com/accounts/create/' , E_USER_WARNING ) ; } return json_decode ( $ body ) ; }
6639	protected function initNavigation ( ) { Yii :: $ app -> params [ 'nav' ] [ 'wavecms_dashboard' ] = [ 'label' => FontAwesome :: icon ( 'home' ) . Yii :: t ( 'wavecms/main' , 'Dashboard' ) , 'url' => [ '/' ] , 'position' => 500 ] ; Yii :: $ app -> params [ 'nav' ] [ 'wavecms_user' ] = [ 'label' => FontAwesome :: icon ( 'users' ) . Yii :: t ( 'wavecms/user' , 'Users' ) , 'url' => 'javascript: ;' , 'options' => [ 'class' => 'drop-down' ] , 'permission' => 'wavecms-user' , 'position' => 9000 , 'items' => [ [ 'label' => FontAwesome :: icon ( 'user' ) . Yii :: t ( 'wavecms/user' , 'List of users' ) , 'url' => [ '/wavecms/user/index' ] ] , [ 'label' => FontAwesome :: icon ( 'key' ) . Yii :: t ( 'wavecms/user' , 'Roles' ) , 'url' => [ '/wavecms/role/index' ] ] , ] ] ; Yii :: $ app -> params [ 'nav' ] [ 'wavecms_settings' ] = [ 'label' => FontAwesome :: icon ( 'cog' ) . Yii :: t ( 'wavecms/main' , 'Settings' ) , 'url' => 'javascript: ;' , 'options' => [ 'class' => 'drop-down' ] , 'permission' => 'wavecms-settings' , 'position' => 10000 , 'items' => [ [ 'label' => FontAwesome :: icon ( 'flag' ) . Yii :: t ( 'wavecms/main' , 'Translations' ) , 'url' => [ '/wavecms/translation/index' ] ] , [ 'label' => FontAwesome :: icon ( 'database' ) . Yii :: t ( 'wavecms/main' , 'Cache' ) , 'url' => [ '/wavecms/settings/cache' ] ] ] ] ; }
2830	public function disableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( false ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was disabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to disable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
5342	private function getSoapClient ( $ service , $ method , array $ parameters ) { $ timestamp = time ( ) ; $ nonce = uniqid ( null , true ) ; $ soapClient = $ this -> client -> buildSoapClient ( $ service ) ; $ soapClient -> setTimestamp ( $ timestamp ) ; $ soapClient -> setNonce ( $ nonce ) ; $ soapClient -> setSignature ( array_merge ( $ parameters , [ '__method' => $ method ] ) , $ this -> client -> getPrivateKey ( ) , $ service , $ this -> client -> getEndpoint ( ) , $ timestamp , $ nonce ) ; return $ soapClient ; }
4320	public static function arrayMergeDeep ( $ arrayDef , $ array2 ) { if ( ! \ is_array ( $ arrayDef ) || self :: isCallable ( $ arrayDef ) ) { return $ array2 ; } if ( ! \ is_array ( $ array2 ) || self :: isCallable ( $ array2 ) ) { return $ array2 ; } foreach ( $ array2 as $ k2 => $ v2 ) { if ( \ is_int ( $ k2 ) ) { if ( ! \ in_array ( $ v2 , $ arrayDef ) ) { $ arrayDef [ ] = $ v2 ; } } elseif ( ! isset ( $ arrayDef [ $ k2 ] ) ) { $ arrayDef [ $ k2 ] = $ v2 ; } else { $ arrayDef [ $ k2 ] = self :: arrayMergeDeep ( $ arrayDef [ $ k2 ] , $ v2 ) ; } } return $ arrayDef ; }
5397	public function paintMessage ( $ message ) { parent :: paintMessage ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'message>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "message>\n" ; }
2134	public static function remove ( $ strKey ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> delete ( $ strKey ) ; }
9064	public function attachShared ( SharedEventManagerInterface $ events ) { $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_BOOTSTRAP , array ( $ this , 'onMvcBootstrapLast' ) , - 100000 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderAddPathStacks' ) , - 900 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderSpecLayout' ) , - 1000 ) ; }
749	public function load ( $ filePath , $ context ) { $ pattern = '/(msgctxt\s+"(.*?(?<!\\\\))")?\s+' . 'msgid\s+((?:".*(?<!\\\\)"\s*)+)\s+' . 'msgstr\s+((?:".*(?<!\\\\)"\s*)+)/' ; $ content = file_get_contents ( $ filePath ) ; $ matches = [ ] ; $ matchCount = preg_match_all ( $ pattern , $ content , $ matches ) ; $ messages = [ ] ; for ( $ i = 0 ; $ i < $ matchCount ; ++ $ i ) { if ( $ matches [ 2 ] [ $ i ] === $ context ) { $ id = $ this -> decode ( $ matches [ 3 ] [ $ i ] ) ; $ message = $ this -> decode ( $ matches [ 4 ] [ $ i ] ) ; $ messages [ $ id ] = $ message ; } } return $ messages ; }
396	public static function deleteAll ( $ condition = null , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> delete ( static :: tableName ( ) , $ condition , $ params ) ; return $ command -> execute ( ) ; }
5251	public function delete ( ) { if ( $ this -> deleting ( ) === false ) { return false ; } $ this -> _dal -> delete ( ) ; $ this -> _exist = false ; $ cache = self :: cache ( ) ; $ cache -> forget ( $ this -> getId ( ) ) ; if ( $ this -> deleted ( ) === false ) { return false ; } return true ; }
6725	public static function getAccessToken ( ) { $ oauthClientParams = ArrayHelper :: getValue ( \ Yii :: $ app -> params , 'oauth' ) ; $ oauthClient = new Oauth2Client ( $ oauthClientParams ) ; $ code = $ oauthClient -> authorize ( ) ; $ token = $ oauthClient -> fetchAccessToken ( $ code ) ; $ accessToken = ArrayHelper :: getValue ( $ token , 'access_token' ) ; return $ accessToken ; }
12369	public function authenticate ( $ accountKey , $ uniqueUserId , $ authMethod = null ) { if ( null === $ authMethod ) { $ authMethod = self :: AUTH_HTTP_TOKEN ; } $ this -> getHttpClient ( ) -> authenticate ( $ accountKey , $ uniqueUserId , $ authMethod ) ; }
19	protected function getRepoData ( ) { $ resource = sprintf ( 'https://api.bitbucket.org/2.0/repositories/%s/%s?%s' , $ this -> owner , $ this -> repository , http_build_query ( array ( 'fields' => '-project,-owner' ) , null , '&' ) ) ; $ repoData = JsonFile :: parseJson ( $ this -> getContentsWithOAuthCredentials ( $ resource , true ) , $ resource ) ; if ( $ this -> fallbackDriver ) { return false ; } $ this -> parseCloneUrls ( $ repoData [ 'links' ] [ 'clone' ] ) ; $ this -> hasIssues = ! empty ( $ repoData [ 'has_issues' ] ) ; $ this -> branchesUrl = $ repoData [ 'links' ] [ 'branches' ] [ 'href' ] ; $ this -> tagsUrl = $ repoData [ 'links' ] [ 'tags' ] [ 'href' ] ; $ this -> homeUrl = $ repoData [ 'links' ] [ 'html' ] [ 'href' ] ; $ this -> website = $ repoData [ 'website' ] ; $ this -> vcsType = $ repoData [ 'scm' ] ; return true ; }
11094	public static function getDateFromBirthNumber ( $ no ) { if ( ! preg_match ( '#^\s*(\d\d)(\d\d)(\d\d)[ /]*(\d\d\d)(\d?)\s*$#' , $ no , $ matches ) ) { return null ; } list ( , $ year , $ month , $ day , $ ext , $ c ) = $ matches ; if ( $ c === '' ) { $ year += $ year < 54 ? 1900 : 1800 ; } else { $ mod = ( $ year . $ month . $ day . $ ext ) % 11 ; if ( $ mod === 10 ) { $ mod = 0 ; } if ( $ mod !== ( int ) $ c ) { return null ; } $ year += $ year < 54 ? 2000 : 1900 ; } if ( $ year > 2003 ) { if ( $ month > 70 ) { $ month -= 70 ; } if ( $ month > 20 && $ month < 50 ) { $ month -= 20 ; } } if ( $ month > 50 ) { $ month -= 50 ; } return new DateTime ( sprintf ( '%04d-%02d-%02d' , $ year , $ month , $ day ) ) ; }
5094	public function executeIterator ( ) { $ result = $ this -> execute ( ) ; if ( ! $ result ) throw new MySqlException ( 'Could not execute multiset query!' ) ; while ( true ) { yield new StatementResult ( $ result ) ; if ( ! $ result -> nextRowset ( ) ) { $ this -> checkForError ( $ result ) ; break ; } } }
12032	function addDispatchMethod ( ) { $ methodGenerator = new MethodGenerator ( 'dispatch' ) ; $ body = '' ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= $ this -> generateResponseFragment ( ) ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response. Allows you to modify the request before it is sent.' ) ; $ parameter = new ParameterGenerator ( 'request' , 'Amp\Artax\Request' ) ; $ methodGenerator -> setParameter ( $ parameter ) ; $ tag = createParamTag ( $ parameter , 'The request to be processed' ) ; $ docBlock -> setTag ( $ tag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
5080	public function postIndex ( ) { $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ this -> userCan ( static :: ACTION_CREATE ) ; $ aData = $ oInput -> post ( ) ; if ( empty ( $ aData ) ) { $ sData = stream_get_contents ( fopen ( 'php://input' , 'r' ) ) ; $ aData = json_decode ( $ sData , JSON_OBJECT_AS_ARRAY ) ? : [ ] ; } $ aData = $ this -> validateUserInput ( $ aData ) ; $ iItemId = $ this -> oModel -> create ( $ aData ) ; if ( empty ( $ iItemId ) ) { throw new ApiException ( 'Failed to create resource. ' . $ this -> oModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } $ oItem = $ this -> oModel -> getById ( $ iItemId , static :: CONFIG_LOOKUP_DATA ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
453	public function delete ( $ table , $ condition , & $ params ) { $ sql = 'DELETE FROM ' . $ this -> db -> quoteTableName ( $ table ) ; $ where = $ this -> buildWhere ( $ condition , $ params ) ; return $ where === '' ? $ sql : $ sql . ' ' . $ where ; }
1917	public static function findByArchive ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.archives LIKE '%\"" . ( int ) $ intId . "\"%'" ) , null , $ arrOptions ) ; }
9882	private function writeSheet ( XMLWriter $ objWriter , $ pSheetname , $ pSheetId = 1 , $ pRelId = 1 , $ sheetState = 'visible' ) { if ( $ pSheetname != '' ) { $ objWriter -> startElement ( 'sheet' ) ; $ objWriter -> writeAttribute ( 'name' , $ pSheetname ) ; $ objWriter -> writeAttribute ( 'sheetId' , $ pSheetId ) ; if ( $ sheetState != 'visible' && $ sheetState != '' ) { $ objWriter -> writeAttribute ( 'state' , $ sheetState ) ; } $ objWriter -> writeAttribute ( 'r:id' , 'rId' . $ pRelId ) ; $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
10952	protected function write ( Response $ response , $ body ) : Response { $ response -> getBody ( ) -> write ( ( string ) $ body ) ; return $ response ; }
4133	public function initializeObject ( $ obj ) { if ( $ obj instanceof PersistentCollection ) { $ obj -> initialize ( ) ; } else if ( $ obj instanceof Proxy \ Proxy ) { $ obj -> __doctrineLoad__ ( ) ; } }
5711	public function FieldHolder ( $ attributes = array ( ) ) { if ( $ this -> shouldDisplay ( ) ) { $ this -> setContent ( $ this -> getButtonHTML ( ) ) ; return parent :: FieldHolder ( $ attributes ) ; } }
863	private function changeCodeHash ( $ codeHash ) { if ( null !== $ this -> codeHash ) { self :: clearCache ( $ this -> codeHash ) ; } $ this -> codeHash = $ codeHash ; self :: setCache ( $ this -> codeHash , $ this ) ; }
8184	public function getPeakMemoryUsage ( ) { return isset ( $ this -> ends [ 'pmu' ] ) && isset ( $ this -> starts [ 'pmu' ] ) ? $ this -> ends [ 'pmu' ] - $ this -> starts [ 'pmu' ] : 0 ; }
795	public function load ( $ data , $ formName = null ) { $ scope = $ formName === null ? $ this -> formName ( ) : $ formName ; if ( $ scope === '' && ! empty ( $ data ) ) { $ this -> setAttributes ( $ data ) ; return true ; } elseif ( isset ( $ data [ $ scope ] ) ) { $ this -> setAttributes ( $ data [ $ scope ] ) ; return true ; } return false ; }
5470	protected function describePatternMatch ( $ pattern , $ subject ) { preg_match ( $ pattern , $ subject , $ matches ) ; $ position = strpos ( $ subject , $ matches [ 0 ] ) ; $ dumper = $ this -> getDumper ( ) ; return "Pattern [$pattern] detected at character [$position] in [" . $ dumper -> describeValue ( $ subject ) . '] as [' . $ matches [ 0 ] . '] in region [' . $ dumper -> clipString ( $ subject , 100 , $ position ) . ']' ; }
2621	public function sendValidationRequest ( $ validatedFlag , $ serviceId = null ) { if ( $ serviceId != null ) { $ this -> validationServiceId = $ serviceId ; } if ( $ validatedFlag ) { $ validationState = self :: FASTLY_VALIDATED_FLAG ; } else { $ validationState = self :: FASTLY_NON_VALIDATED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ validationState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ validationState , 'dt' => ucfirst ( $ validationState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ validationState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
7365	protected function resolveOutstandingDate ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return null ; } if ( ! $ sale instanceof ShipmentSubjectInterface ) { return null ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { return null ; } if ( ! $ this -> saleHasOutstandingPayments ( $ sale ) ) { return null ; } $ from = null ; switch ( $ term -> getTrigger ( ) ) { case PaymentTermTriggers :: TRIGGER_SHIPPED : $ from = $ sale -> getShippedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_SHIPPED : if ( $ sale -> getShipmentState ( ) === ShipmentStates :: STATE_COMPLETED ) { $ from = $ sale -> getShippedAt ( true ) ; } break ; case PaymentTermTriggers :: TRIGGER_INVOICED : $ from = $ sale -> getInvoicedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_INVOICED : if ( $ sale -> getInvoiceState ( ) === InvoiceStates :: STATE_COMPLETED ) { $ from = $ sale -> getInvoicedAt ( true ) ; } break ; } if ( null === $ from ) { return null ; } $ date = clone $ from ; $ date -> setTime ( 23 , 59 , 59 ) ; $ date -> modify ( sprintf ( '+%s days' , $ term -> getDays ( ) ) ) ; if ( $ term -> getEndOfMonth ( ) ) { $ date -> modify ( 'last day of this month' ) ; } return $ date ; }
8851	public function PaginatedList ( ) { $ posts = new PaginatedList ( $ this -> blogPosts ) ; if ( $ this -> PostsPerPage > 0 ) $ posts -> setPageLength ( $ this -> PostsPerPage ) ; else $ posts -> setPageLength ( $ this -> getBlogPosts ( ) -> count ( ) ) ; $ start = $ this -> request -> getVar ( $ posts -> getPaginationGetVar ( ) ) ; $ posts -> setPageStart ( $ start ) ; return $ posts ; }
4102	public function request ( $ path , $ method = 'GET' , $ payload = false , $ verbose = false ) { $ response = $ this -> transport -> request ( $ this -> expandPath ( $ path ) , $ method , $ payload ) ; return ( $ verbose || ! isset ( $ response [ '_source' ] ) ) ? $ response : $ response [ '_source' ] ; }
3700	private function handleSorting ( $ information , GroupAndSortingDefinitionInterface $ definition ) { if ( $ information [ 'ismanualsort' ] ) { $ definition -> add ( ) -> setManualSorting ( ) -> setProperty ( 'sorting' ) -> setSortingMode ( GroupAndSortingInformationInterface :: SORT_ASC ) ; return ; } if ( $ information [ 'col_name' ] ) { $ definition -> add ( ) -> setProperty ( $ information [ 'col_name' ] ) -> setSortingMode ( $ information [ 'rendersort' ] ) ; } }
12254	public function addCompiler ( $ compiler ) { if ( $ compiler instanceof CompilerFactoryInterface || $ compiler instanceof CompilerInterface ) { $ this -> compilers [ ] = $ compiler ; $ this -> orderedCompilers = NULL ; } else throw new CompilerException ( "Can only add objects that implement CompilerInterface or CompilerFactoryInterface to context" ) ; }
5922	public function setPropertySets ( array $ propertySets ) { $ this -> propertySets = [ ] ; foreach ( $ propertySets as $ item ) { $ this -> addPropertySet ( $ item ) ; } return $ this ; }
11850	public static function createFault ( $ code , $ message ) { $ response = new \ SimpleXMLElement ( "<methodResponse></methodResponse>" ) ; $ struct = $ response -> addChild ( "fault" ) -> addChild ( "value" ) -> addChild ( "struct" ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultCode" ) ; $ member -> addChild ( "value" ) -> addChild ( "int" , $ code ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultString" ) ; $ member -> addChild ( "value" , $ message ) ; return $ response -> asXML ( ) ; }
10103	private function writeDimensions ( ) { $ record = 0x0200 ; $ length = 0x000E ; $ data = pack ( 'VVvvv' , $ this -> firstRowIndex , $ this -> lastRowIndex + 1 , $ this -> firstColumnIndex , $ this -> lastColumnIndex + 1 , 0x0000 ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ data ) ; }
3633	public function pools ( Request $ request ) : array { if ( $ name = $ request -> query ( 'name' ) ) { if ( ! App :: hasPool ( $ name ) ) { return [ ] ; } $ poolConfig = App :: getPool ( $ name ) -> getPoolConfig ( ) ; return $ poolConfig -> toArray ( ) ; } return PoolCollector :: getCollector ( ) ; }
10232	private function writeLine ( $ pFileHandle , array $ pValues ) { $ writeDelimiter = false ; $ line = '' ; foreach ( $ pValues as $ element ) { $ element = str_replace ( $ this -> enclosure , $ this -> enclosure . $ this -> enclosure , $ element ) ; if ( $ writeDelimiter ) { $ line .= $ this -> delimiter ; } else { $ writeDelimiter = true ; } $ line .= $ this -> enclosure . $ element . $ this -> enclosure ; } $ line .= $ this -> lineEnding ; fwrite ( $ pFileHandle , $ line ) ; }
4727	private function getCachedSingular ( $ plural ) { $ plural = StringHelper :: strtolower ( $ plural ) ; return array_search ( $ plural , $ this -> cache ) ; }
1869	private function parseFile ( string $ file ) : array { $ code = '' ; $ namespace = '' ; $ buffer = false ; $ stream = new \ PHP_Token_Stream ( $ file ) ; foreach ( $ stream as $ token ) { switch ( true ) { case $ token instanceof \ PHP_Token_OPEN_TAG : case $ token instanceof \ PHP_Token_CLOSE_TAG : break ; case false !== $ buffer : $ buffer .= $ token ; if ( ';' === ( string ) $ token ) { $ code .= $ this -> handleDeclare ( $ buffer ) ; $ buffer = false ; } break ; case $ token instanceof \ PHP_Token_NAMESPACE : if ( '{' === $ token -> getName ( ) ) { $ namespace = false ; $ code .= $ token ; } else { $ namespace = $ token -> getName ( ) ; $ stream -> seek ( $ token -> getEndTokenId ( ) ) ; } break ; case $ token instanceof \ PHP_Token_DECLARE : $ buffer = ( string ) $ token ; break ; default : $ code .= $ token ; } } return [ $ code , $ namespace ] ; }
12530	public function apply ( $ quantity , $ reason , $ comment = '' , $ poiId = null ) { $ params = [ 'quantity' => intval ( $ quantity ) , 'apply_reason' => $ reason , ] ; if ( ! empty ( $ comment ) ) { $ params [ 'comment' ] = $ comment ; } if ( ! is_null ( $ poiId ) ) { $ params [ 'poi_id' ] = intval ( $ poiId ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_APPLYID , $ params ] ) ; }
970	public function setDomain ( string $ shopDomain ) { $ this -> fixLifetime ( ) ; Session :: put ( self :: DOMAIN , $ shopDomain ) ; }
3462	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ next ) : ResponseInterface { $ route = $ this -> router -> find ( $ request -> getMethod ( ) , $ request -> getUri ( ) -> getPath ( ) ) ; $ controller = $ route -> getController ( ) ; if ( $ request instanceof ServerRequest ) { $ request = $ request -> withAttributes ( $ route -> getAttributes ( ) ) ; } if ( is_string ( $ controller ) && class_exists ( $ controller ) && is_subclass_of ( $ controller , Controller :: class ) ) { $ instance = $ this -> resolver -> resolve ( $ controller ) ; return $ instance ( $ request ) ; } if ( is_callable ( $ controller ) ) { $ response = $ controller ( $ request ) ; if ( ! $ response instanceof ResponseInterface ) { throw ControllerException :: forInvalidReturnValue ( ) ; } return $ response ; } throw ControllerException :: forMissingController ( $ route -> getPath ( ) ) ; }
11434	public function registerResources ( Translator $ translator , array $ dirs ) { $ finder = new Finder ( ) ; $ files = $ finder -> files ( ) -> depth ( 0 ) -> ignoreUnreadableDirs ( ) -> in ( $ dirs ) ; foreach ( $ files as $ file ) { $ file = ( string ) $ file ; preg_match_all ( '/[^.]+/' , basename ( $ file ) , $ match ) ; $ translator -> addResource ( 'xliff' , $ file , $ match [ 0 ] [ 1 ] , "RedKiteCms" ) ; } }
4309	public function getChannel ( $ channelName , $ config = array ( ) ) { if ( \ strpos ( $ channelName , '.' ) !== false ) { $ this -> error ( 'getChannel(): channelName should not contain period (.)' ) ; return $ this ; } if ( ! isset ( $ this -> channels [ $ channelName ] ) ) { $ cfg = $ this -> getCfg ( ) ; $ cfg = \ array_diff_key ( $ cfg , \ array_flip ( array ( 'errorEmailer' , 'errorHandler' , 'output' , ) ) ) ; unset ( $ cfg [ 'debug' ] [ 'onBootstrap' ] ) ; $ cfg [ 'debug' ] [ 'channel' ] = $ this -> parentInstance ? $ this -> cfg [ 'channel' ] . '.' . $ channelName : $ channelName ; $ cfg [ 'debug' ] [ 'parent' ] = $ this ; $ this -> channels [ $ channelName ] = new static ( $ cfg ) ; if ( $ config ) { $ this -> channels [ $ channelName ] -> setCfg ( $ config ) ; } } return $ this -> channels [ $ channelName ] ; }
2541	protected function analyzeWithErrCodeCategoryMsgQuery ( SendResult $ response , $ qErr , $ qCat , $ qMsg , $ errLevel = null ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ errorCatNode = $ domXpath -> query ( $ qCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ errLevel ) ; } return $ analyzeResponse ; }
9341	public function set ( $ key , $ value , $ fromFile = false ) { $ keys = array_filter ( explode ( '.' , $ key ) ) ; $ value = ( $ fromFile ) ? require $ value : $ value ; $ this -> save ( $ keys , $ this -> data , $ value ) ; return $ this ; }
4520	public function set ( string $ key , $ value ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ parameter -> setKey ( $ key ) -> setValue ( $ value ) ; $ this -> manager -> persist ( $ parameter ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> detach ( $ parameter ) ; }
352	public static function getInputId ( $ model , $ attribute ) { $ charset = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; $ name = mb_strtolower ( static :: getInputName ( $ model , $ attribute ) , $ charset ) ; return str_replace ( [ '[]' , '][' , '[' , ']' , ' ' , '.' ] , [ '' , '-' , '-' , '' , '-' , '-' ] , $ name ) ; }
7719	function meth_Conv_Str ( & $ Txt , $ ConvBr = true ) { if ( $ this -> Charset === '' ) { $ Txt = htmlspecialchars ( $ Txt ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } elseif ( $ this -> _CharsetFct ) { $ Txt = call_user_func ( $ this -> Charset , $ Txt , $ ConvBr ) ; } else { $ Txt = htmlspecialchars ( $ Txt , ENT_COMPAT , $ this -> Charset ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } }
7142	private function registerActions ( ContainerBuilder $ container ) { if ( class_exists ( 'Ekyna\Component\Payum\Payzen\PayzenGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.convert_payment' , $ definition ) ; $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\FraudLevelAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.fraud_level' , $ definition ) ; } if ( class_exists ( 'Ekyna\Component\Payum\Sips\SipsGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Sips\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'atos_sips' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.sips.convert_payment' , $ definition ) ; } if ( class_exists ( 'Payum\Paypal\ExpressCheckout\Nvp\PaypalExpressCheckoutGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Paypal\Action\EcNvpConvertAction' ) ; $ definition -> setArgument ( 0 , new Reference ( 'ekyna_commerce.common.amount_calculator' ) ) ; if ( $ container -> has ( 'ekyna_setting.manager' ) && class_exists ( 'Ekyna\Bundle\AdminBundle\Settings\GeneralSettingsSchema' ) ) { $ definition -> setArgument ( 1 , new Expression ( "service('ekyna_setting.manager').getParameter('general.site_name')" ) ) ; } $ definition -> addTag ( 'payum.action' , [ 'factory' => 'paypal_express_checkout' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.paypal_ec_nvp.convert_payment' , $ definition ) ; } $ actions = [ 'capture_payment' => Action \ CaptureAction :: class , 'notify_payment' => Action \ NotifyAction :: class , 'status_payment' => Action \ StatusAction :: class , ] ; foreach ( $ actions as $ name => $ class ) { $ definition = new Definition ( $ class ) ; $ definition -> addTag ( 'payum.action' , [ 'all' => true , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.' . $ name , $ definition ) ; } }
4521	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; if ( $ user instanceof User ) { $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getIdentity ( ) -> getType ( ) ) ; } else { $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getIdentity ( ) ) ; } $ event -> setData ( $ data ) ; }
10960	private function prepareFilePathTo ( \ SplFileInfo $ file ) { if ( $ this -> currentCommand -> isUsePathReplace ( ) ) { $ fileWhereToMovePath = $ file -> getPath ( ) . DIRECTORY_SEPARATOR ; if ( $ this -> direction === self :: DIRECTION_FORWARD ) { $ filePathTo = $ this -> currentCommand -> replacePath ( $ fileWhereToMovePath ) ; } elseif ( $ this -> direction === self :: DIRECTION_BACK ) { $ filePathTo = $ this -> currentCommand -> replacePathBack ( $ fileWhereToMovePath ) ; } else { throw new \ Exception ( __METHOD__ . " wrong direction" ) ; } $ this -> currentCommand -> setToDirectory ( $ filePathTo ) ; } else { $ filePathTo = $ this -> currentCommand -> getToDirectory ( ) ; } if ( ! file_exists ( $ filePathTo ) && ! is_dir ( $ filePathTo ) ) { mkdir ( $ filePathTo , $ this -> defaultDirMod , TRUE ) ; } else { chmod ( $ filePathTo , $ this -> defaultDirMod ) ; } if ( $ this -> currentCommand -> getDestinationFileName ( ) ) { $ fileName = $ this -> currentCommand -> getDestinationFileName ( ) ; } else { $ fileName = $ file -> getFilename ( ) ; } $ filePathTo .= $ fileName ; return $ filePathTo ; }
5023	public function allowSelectMultipleItems ( ) { $ flagOrCallback = $ this -> allowSelectMultipleItems ; return is_callable ( $ flagOrCallback ) ? ( bool ) $ flagOrCallback ( ) : ( bool ) $ flagOrCallback ; }
5495	public function findFirstSlot ( $ parameters ) { $ count = count ( $ this -> map ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { if ( $ this -> map [ $ i ] [ 'params' ] -> test ( $ parameters ) ) { return $ this -> map [ $ i ] ; } } return ; }
11969	public static function SetAuthClass ( $ authClass ) { $ toolClass = \ MvcCore \ Application :: GetInstance ( ) -> GetToolClass ( ) ; if ( $ toolClass :: CheckClassInterface ( $ authClass , 'MvcCore\Ext\Auths\Basics\IAuth' , TRUE , TRUE ) ) self :: $ authClass = $ authClass ; }
1421	protected function createBelongsToIdentity ( Model $ model , $ relationshipKey ) { $ relation = $ model -> { $ relationshipKey } ( ) ; if ( ! $ relation instanceof BelongsTo ) { throw new RuntimeException ( sprintf ( 'Expecting %s on %s to be a belongs-to relationship.' , $ relationshipKey , get_class ( $ model ) ) ) ; } $ foreignKey = method_exists ( $ relation , 'getForeignKeyName' ) ? $ relation -> getForeignKeyName ( ) : $ relation -> getForeignKey ( ) ; $ id = $ model -> { $ foreignKey } ; if ( is_null ( $ id ) ) { return null ; } $ ownerKey = method_exists ( $ relation , 'getOwnerKeyName' ) ? $ relation -> getOwnerKeyName ( ) : $ relation -> getOwnerKey ( ) ; $ related = $ relation -> getRelated ( ) -> replicate ( ) ; $ related -> { $ ownerKey } = $ id ; return $ related ; }
12626	public function post ( $ url , $ data = array ( ) ) { $ client = $ this -> getClient ( ) ; return $ client -> request ( 'POST' , $ url , array ( 'form_params' => $ data ) ) ; }
11979	public function transformCard ( AbstractMessage $ message ) { $ type = $ message -> getType ( ) ; return [ 'msgtype' => $ type , $ type => [ 'card_id' => $ message -> get ( 'card_id' ) , ] , ] ; }
6789	protected function assertShipmentPlatform ( ShipmentInterface $ shipment ) { if ( $ shipment -> getPlatformName ( ) !== $ this -> getName ( ) ) { throw new InvalidArgumentException ( sprintf ( "Platform %s does not support shipment %s." , $ this -> getName ( ) , $ shipment -> getNumber ( ) ) ) ; } }
7658	function SmtpClose ( ) { if ( $ this -> smtp != NULL ) { if ( $ this -> smtp -> Connected ( ) ) { $ this -> smtp -> Quit ( ) ; $ this -> smtp -> Close ( ) ; } } }
6087	public function retrieveTemplate ( $ templateId , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/moodboards/templates/' . $ templateId . '' , $ parameters , $ cachePolicy ) ; $ result = new MoodboardTemplateResponse ( $ result ) ; return $ result ; }
4122	private function getProxyFileName ( $ className , $ baseDir = null ) { $ proxyDir = $ baseDir ? : $ this -> proxyDir ; return $ proxyDir . DIRECTORY_SEPARATOR . '__CG__' . str_replace ( '\\' , '' , $ className ) . '.php' ; }
8503	public function setGetCompetitivePricingForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetCompetitivePricingForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1774	public function addAttributes ( $ arrAttributes ) { if ( ! \ is_array ( $ arrAttributes ) ) { return ; } foreach ( $ arrAttributes as $ k => $ v ) { $ this -> $ k = $ v ; } }
4378	protected function buildTableRow ( $ row , $ keys , $ rowKey ) { $ str = '' ; $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; $ parsed = $ this -> debug -> utilities -> parseTag ( $ this -> dump ( $ rowKey ) ) ; $ str .= '<tr>' ; $ str .= $ this -> debug -> utilities -> buildTag ( 'th' , array ( 'class' => 't_key text-right ' . $ parsed [ 'attribs' ] [ 'class' ] , 'scope' => 'row' , ) , $ parsed [ 'innerhtml' ] ) ; if ( $ objInfo [ 'row' ] ) { $ str .= $ this -> markupClassname ( $ objInfo [ 'row' ] [ 'className' ] , 'td' , array ( 'title' => $ objInfo [ 'row' ] [ 'phpDoc' ] [ 'summary' ] ? : null , ) ) ; $ this -> tableInfo [ 'haveObjRow' ] = true ; } else { $ str .= '<td class="t_classname"></td>' ; } foreach ( $ values as $ v ) { $ str .= $ this -> dump ( $ v , true , 'td' ) ; } $ str .= '</tr>' . "\n" ; $ str = \ str_replace ( ' title=""' , '' , $ str ) ; foreach ( \ array_keys ( $ this -> tableInfo [ 'totals' ] ) as $ k ) { $ this -> tableInfo [ 'totals' ] [ $ k ] += $ values [ $ k ] ; } foreach ( $ objInfo [ 'cols' ] as $ k2 => $ classname ) { if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] === false ) { continue ; } if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] === null ) { $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] = $ classname ; } if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] !== $ classname ) { $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] = false ; } } return $ str ; }
5008	public function trigger ( $ event , $ target = null ) { if ( empty ( $ this -> _template ) || ! is_string ( $ this -> _template ) ) { throw new \ InvalidArgumentException ( 'ContentCollector must have a template-name' ) ; } $ responseCollection = $ this -> getController ( ) -> getEventManager ( ) -> trigger ( $ event , $ target ) ; $ viewModel = new ViewModel ( ) ; $ viewModel -> setTemplate ( $ this -> _template ) ; foreach ( $ responseCollection as $ i => $ response ) { if ( is_string ( $ response ) ) { $ template = $ response ; $ response = new ViewModel ( array ( 'target' => $ target ) ) ; $ response -> setTemplate ( $ template ) ; } $ viewModel -> addChild ( $ response , $ this -> _captureTo . $ i ) ; } return $ viewModel ; }
2206	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'logout' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> redirectBack ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ this -> getReferer ( ) ; } $ strLogoutUrl = System :: getContainer ( ) -> get ( 'security.logout_url_generator' ) -> getLogoutUrl ( ) ; $ strRedirect = Environment :: get ( 'base' ) ; if ( $ this -> redirectBack && ! empty ( $ _SESSION [ 'LAST_PAGE_VISITED' ] ) ) { $ strRedirect = $ _SESSION [ 'LAST_PAGE_VISITED' ] ; } elseif ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ strRedirect = $ objTarget -> getAbsoluteUrl ( ) ; } $ uri = Http :: createFromString ( $ strLogoutUrl ) ; $ query = new Query ( $ uri -> getQuery ( ) ) ; $ query = $ query -> merge ( 'redirect=' . $ strRedirect ) ; $ this -> redirect ( ( string ) $ uri -> withQuery ( ( string ) $ query ) ) ; return '' ; }
537	protected function updateDocComment ( $ doc , $ properties ) { $ lines = explode ( "\n" , $ doc ) ; $ propertyPart = false ; $ propertyPosition = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( strncmp ( $ line , '* @property ' , 12 ) === 0 ) { $ propertyPart = true ; } elseif ( $ propertyPart && $ line == '*' ) { $ propertyPosition = $ i ; $ propertyPart = false ; } if ( strncmp ( $ line , '* @author ' , 10 ) === 0 && $ propertyPosition === false ) { $ propertyPosition = $ i - 1 ; $ propertyPart = false ; } if ( $ propertyPart ) { unset ( $ lines [ $ i ] ) ; } } if ( $ propertyPosition === false ) { $ propertyPosition = \ count ( $ lines ) - 2 ; } $ finalDoc = '' ; foreach ( $ lines as $ i => $ line ) { $ finalDoc .= $ line . "\n" ; if ( $ i == $ propertyPosition ) { $ finalDoc .= $ properties ; } } return $ finalDoc ; }
1443	protected function replaceApplicationNamespace ( & $ stub ) { $ namespace = rtrim ( $ this -> laravel -> getNamespace ( ) , '\\' ) ; $ stub = str_replace ( 'DummyApplicationNamespace' , $ namespace , $ stub ) ; return $ this ; }
868	private function isInConditionWithoutBraces ( Tokens $ tokens , $ index , $ lowerLimitIndex ) { do { if ( $ tokens [ $ index ] -> isComment ( ) || $ tokens [ $ index ] -> isWhitespace ( ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_IF , T_ELSEIF , T_ELSE ] ) ) { return true ; } if ( $ token -> equals ( ';' , '}' ) ) { return false ; } if ( $ token -> equals ( '{' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( T_DO ) ) { -- $ index ; continue ; } if ( ! $ tokens [ $ index ] -> equals ( ')' ) ) { return false ; } $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( [ T_IF , T_ELSEIF ] ) ) { return false ; } } elseif ( $ token -> equals ( ')' ) ) { $ type = Tokens :: detectBlockType ( $ token ) ; $ index = $ tokens -> findBlockStart ( $ type [ 'type' ] , $ index ) ; $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } else { -- $ index ; } } while ( $ index > $ lowerLimitIndex ) ; return false ; }
1666	protected function enableTwoFactor ( BackendUser $ user , $ return ) { if ( $ user -> useTwoFactor ) { return ; } $ container = System :: getContainer ( ) ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerificationHelp' ] ; $ authenticator = $ container -> get ( 'contao.security.two_factor.authenticator' ) ; if ( Input :: post ( 'FORM_SUBMIT' ) == 'tl_two_factor' ) { if ( $ authenticator -> validateCode ( $ user , Input :: post ( 'verify' ) ) ) { $ user -> useTwoFactor = '1' ; $ user -> save ( ) ; throw new RedirectResponseException ( $ return ) ; } $ this -> Template -> error = true ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidTwoFactor' ] ; } if ( ! $ user -> secret ) { $ user -> secret = random_bytes ( 128 ) ; $ user -> save ( ) ; } $ request = $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; $ this -> Template -> enable = true ; $ this -> Template -> secret = Base32 :: encodeUpperUnpadded ( $ user -> secret ) ; $ this -> Template -> textCode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorTextCode' ] ; $ this -> Template -> qrCode = base64_encode ( $ authenticator -> getQrCode ( $ user , $ request ) ) ; $ this -> Template -> scan = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorScan' ] ; $ this -> Template -> verify = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerification' ] ; $ this -> Template -> verifyHelp = $ verifyHelp ; }
7877	protected function setupPackage ( ) { $ source = realpath ( __DIR__ . '/../config/logviewer.php' ) ; $ this -> publishes ( [ $ source => config_path ( 'logviewer.php' ) ] , 'config' ) ; $ this -> publishes ( [ realpath ( __DIR__ . '/../assets/css' ) => public_path ( 'assets/styles' ) , realpath ( __DIR__ . '/../assets/js' ) => public_path ( 'assets/scripts' ) , ] , 'public' ) ; $ this -> mergeConfigFrom ( $ source , 'logviewer' ) ; $ this -> loadViewsFrom ( realpath ( __DIR__ . '/../views' ) , 'logviewer' ) ; }
6096	public function memberOf ( ) { $ groups = array ( $ this -> getParent ( ) -> channelGroupGetById ( $ this [ "client_channel_group_id" ] ) ) ; foreach ( explode ( "," , $ this [ "client_servergroups" ] ) as $ sgid ) { $ groups [ ] = $ this -> getParent ( ) -> serverGroupGetById ( $ sgid ) ; } return $ groups ; }
3102	public function getStorage ( ) { if ( ! $ this -> storage ) { $ this -> storage = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storage ; }
5220	public function contains ( $ path ) { $ realpath = realpath ( $ path ) ; if ( false === $ realpath ) { return false ; } return substr ( $ realpath , 0 , strlen ( $ this -> rootpath ) ) === $ this -> rootpath ; }
12846	public function runHttpErrorPage ( int $ iError ) { if ( isset ( $ _SERVER ) && isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { foreach ( Config :: get ( 'route' ) as $ sHost => $ oHost ) { if ( ( ! strstr ( $ sHost , '/' ) && $ sHost == $ _SERVER [ 'HTTP_HOST' ] ) || ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) ) { $ this -> _oRoutes = $ oHost -> routes ; if ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) { $ this -> _sBaseUri = preg_replace ( '#^[^/]+#' , '' , $ sHost ) ; } $ sHttpErrorPageName = '_getPage' . iError ; $ this -> $ sHttpErrorPageName ( ) ; } } } }
3872	protected function getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage = null ) { $ entries = array ( ) ; $ items = $ metaModels -> findByFilter ( $ filter ) ; foreach ( $ items as $ item ) { $ jumpTo = $ item -> buildJumpToLink ( $ view ) ; $ event = new GetPageDetailsEvent ( $ jumpTo [ 'page' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null || ( $ rootPage !== null && $ pageDetails [ 'rootId' ] != $ rootPage ) ) { continue ; } $ url = $ this -> getBaseUrl ( $ pageDetails , $ jumpTo [ 'url' ] ) ; $ entries [ ] = $ url -> getUrl ( ) ; } return $ entries ; }
4487	public function send ( $ message , string $ endpointArn ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $endpointArn" , [ 'Message' => $ message , ] ) ; return ; } if ( ! ( $ message instanceof Message ) ) { $ message = new Message ( $ message ) ; } $ this -> sns -> publish ( [ 'TargetArn' => $ endpointArn , 'Message' => $ this -> encodeMessage ( $ message ) , 'MessageStructure' => 'json' , ] ) ; }
401	public static function processParagraph ( $ markdown , $ flavor = null ) { $ parser = static :: getParser ( $ flavor ) ; return $ parser -> parseParagraph ( $ markdown ) ; }
1367	protected function bootBladeDirectives ( ) { $ compiler = $ this -> app -> make ( BladeCompiler :: class ) ; $ compiler -> directive ( 'jsonapi' , Renderer :: class . '::compileWith' ) ; $ compiler -> directive ( 'encode' , Renderer :: class . '::compileEncode' ) ; }
9414	public function variance ( ) { $ float_variance = pow ( $ this -> float_sigma , 2 ) ; if ( $ this -> int_precision ) { return round ( $ float_variance , $ this -> int_precision ) ; } return $ float_variance ; }
1940	public function checkUniqueRecipient ( $ varValue , Contao \ DataContainer $ dc ) { $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE email=? AND pid=(SELECT pid FROM tl_newsletter_recipients WHERE id=?) AND id!=?" ) -> execute ( $ varValue , $ dc -> id , $ dc -> id ) ; if ( $ objRecipient -> count > 0 ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unique' ] , $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ $ dc -> field ] [ 0 ] ) ) ; } return $ varValue ; }
5132	protected function hasStandardPort ( ) : bool { return ( $ this -> scheme === 'http' && $ this -> port === 80 ) || ( $ this -> scheme === 'https' && $ this -> port === 443 ) ; }
2074	public function purgeSearchTables ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search" ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search_index" ) ; $ strCachePath = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCachePath . '/contao/search' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the search tables' , __METHOD__ , TL_CRON ) ; }
7738	public function serialize ( $ entity ) { if ( ! $ this -> container -> has ( 'hydra.serializer' ) ) { throw new \ LogicException ( 'The HydraBundle is not registered in your application.' ) ; } return $ this -> container -> get ( 'hydra.serializer' ) -> serialize ( $ entity , self :: FORMAT ) ; }
5494	public function findFirstAction ( $ parameters ) { $ slot = $ this -> findFirstSlot ( $ parameters ) ; if ( isset ( $ slot ) && isset ( $ slot [ 'content' ] ) ) { return $ slot [ 'content' ] ; } return ; }
4101	public function map ( $ mapping , array $ config = array ( ) ) { if ( is_array ( $ mapping ) ) $ mapping = new Mapping ( $ mapping ) ; $ mapping -> config ( $ config ) ; try { $ type = $ mapping -> config ( 'type' ) ; } catch ( \ Exception $ e ) { } if ( isset ( $ type ) && ! $ this -> passesTypeConstraint ( $ type ) ) { throw new Exception ( "Cant create mapping due to type constraint mismatch" ) ; } return $ this -> request ( '_mapping' , 'PUT' , $ mapping -> export ( ) , true ) ; }
4602	public function encrypt ( $ data , string $ key = null ) : string { $ key = $ this -> createKey ( $ key ) ; $ data = Crypto :: encrypt ( serialize ( $ data ) , $ key ) ; return $ data ; }
10507	private function registerFilesystem ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ Filesystem :: class , function ( $ app ) { $ files = $ app [ 'files' ] ; $ filesystem = new Utilities \ Filesystem ( $ files , storage_path ( 'logs' ) ) ; $ filesystem -> setPattern ( Utilities \ Filesystem :: PATTERN_PREFIX , Utilities \ Filesystem :: PATTERN_DATE , Utilities \ Filesystem :: PATTERN_EXTENSION ) ; return $ filesystem ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.filesystem' , Contracts \ Utilities \ Filesystem :: class ) ; }
4789	function update ( array $ data ) { if ( $ this -> notORM -> freeze ) { return false ; } if ( ! $ data ) { return 0 ; } $ values = array ( ) ; $ parameters = array ( ) ; $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ data as $ key => $ val ) { $ values [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; if ( $ val instanceof NotORM_Literal && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } if ( $ this -> parameters ) { $ parameters = array_merge ( $ parameters , $ this -> parameters ) ; } $ return = $ this -> query ( "UPDATE" . $ this -> topString ( $ this -> limit ) . " $this->table SET " . implode ( ", " , $ values ) . $ this -> whereString ( ) , $ parameters ) ; if ( ! $ return ) { return false ; } return $ return -> rowCount ( ) ; }
768	protected function regenerateCsrfToken ( ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ request -> enableCsrfCookie || $ this -> enableSession ) { $ request -> getCsrfToken ( true ) ; } }
8087	public function getConnection ( ) { if ( ! ( $ this -> log instanceof Log ) ) { $ this -> log = new Log ( 'DB' ) ; } if ( $ this -> connection instanceof \ PDO ) { return $ this -> connection ; } $ this -> log -> report ( 'Connecting to database...' ) ; try { $ this -> connection = new \ PDO ( $ this -> generateDSN ( ) , $ this -> user , $ this -> password ) ; $ this -> log -> report ( 'Connected to database.' ) ; } catch ( \ PDOException $ e ) { $ this -> log -> error ( 'Failed to connect to database, [SQLSTATE] ' . $ e -> getCode ( ) ) ; } if ( $ this -> connection instanceof \ PDO ) { return $ this -> connection ; } else { return false ; } }
8454	protected function downloadMediaFileFromURL ( $ fileUri , $ tempFileName ) { $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , "$fileUri" ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11" ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_HEADER , false ) ; curl_setopt ( $ curl , CURLOPT_NOBODY , false ) ; curl_setopt ( $ curl , CURLOPT_BUFFERSIZE , 1024 ) ; curl_setopt ( $ curl , CURLOPT_FILE , $ tempFileName ) ; curl_exec ( $ curl ) ; curl_close ( $ curl ) ; }
7750	public function getMetadataFor ( $ className ) { if ( isset ( $ this -> loadedMetadata [ $ className ] ) ) { return $ this -> loadedMetadata [ $ className ] ; } $ realClassName = ClassUtils :: getRealClass ( $ className ) ; if ( isset ( $ this -> loadedMetadata [ $ realClassName ] ) ) { $ this -> loadedMetadata [ $ className ] = $ this -> loadedMetadata [ $ realClassName ] ; return $ this -> loadedMetadata [ $ realClassName ] ; } if ( $ this -> cacheDriver ) { if ( ( $ cached = $ this -> cacheDriver -> fetch ( $ realClassName . $ this -> cacheSalt ) ) !== false ) { $ this -> loadedMetadata [ $ realClassName ] = $ cached ; } else { $ this -> cacheDriver -> save ( $ realClassName . $ this -> cacheSalt , $ this -> loadMetadata ( $ realClassName ) , null ) ; } } else { $ this -> loadMetadata ( $ realClassName ) ; } if ( $ className != $ realClassName ) { $ this -> loadedMetadata [ $ className ] = $ this -> loadedMetadata [ $ realClassName ] ; } return $ this -> loadedMetadata [ $ className ] ; }
3777	protected function getParamName ( ) { if ( $ this -> get ( 'urlparam' ) ) { return $ this -> get ( 'urlparam' ) ; } $ objAttribute = $ this -> getFilteredAttribute ( ) ; if ( $ objAttribute ) { return $ objAttribute -> getColName ( ) ; } return null ; }
2219	public static function countPublishedByPids ( $ arrPids , $ blnFeatured = null , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return 0 ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( $ blnFeatured === true ) { $ arrColumns [ ] = "$t.featured='1'" ; } elseif ( $ blnFeatured === false ) { $ arrColumns [ ] = "$t.featured=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , null , $ arrOptions ) ; }
3448	public function getAttribute ( $ key ) { if ( in_array ( $ key , $ this -> multipleHighloadBlockFields ) ) { return unserialize ( $ this -> attributes [ $ key ] ) ; } return parent :: getAttribute ( $ key ) ; }
573	public function compareString ( $ expected , $ actual ) { if ( ! is_string ( $ expected ) ) { throw new InvalidArgumentException ( 'Expected expected value to be a string, ' . gettype ( $ expected ) . ' given.' ) ; } if ( ! is_string ( $ actual ) ) { throw new InvalidArgumentException ( 'Expected actual value to be a string, ' . gettype ( $ actual ) . ' given.' ) ; } if ( function_exists ( 'hash_equals' ) ) { return hash_equals ( $ expected , $ actual ) ; } $ expected .= "\0" ; $ actual .= "\0" ; $ expectedLength = StringHelper :: byteLength ( $ expected ) ; $ actualLength = StringHelper :: byteLength ( $ actual ) ; $ diff = $ expectedLength - $ actualLength ; for ( $ i = 0 ; $ i < $ actualLength ; $ i ++ ) { $ diff |= ( ord ( $ actual [ $ i ] ) ^ ord ( $ expected [ $ i % $ expectedLength ] ) ) ; } return $ diff === 0 ; }
11329	public function getHuman ( ) { if ( is_null ( $ this -> _human ) ) { $ this -> _human = HumanFieldDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _human ; }
10005	public function setRibbonXMLData ( $ target , $ xmlData ) { if ( $ target !== null && $ xmlData !== null ) { $ this -> ribbonXMLData = [ 'target' => $ target , 'data' => $ xmlData ] ; } else { $ this -> ribbonXMLData = null ; } }
4353	public function onLog ( Event $ event ) { if ( ! $ this -> fileHandle ) { return ; } $ method = $ event [ 'method' ] ; if ( $ method == 'groupUncollapse' ) { return ; } $ args = $ event [ 'args' ] ; $ meta = $ event [ 'meta' ] ; $ isSummaryBookend = $ method == 'groupSummary' || ! empty ( $ meta [ 'closesSummary' ] ) ; if ( $ isSummaryBookend ) { \ fwrite ( $ this -> fileHandle , "=========\n" ) ; return ; } if ( $ args ) { $ str = $ this -> processLogEntryWEvent ( $ method , $ args , $ meta ) ; \ fwrite ( $ this -> fileHandle , $ str ) ; } elseif ( $ method == 'groupEnd' && $ this -> depth > 0 ) { $ this -> depth -- ; } }
546	protected function getCreateTableSql ( $ table ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> quoteTableName ( $ table -> fullName ) ) -> queryOne ( ) ; if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } return $ sql ; }
1984	public function getAllOptions ( ) : array { $ this -> loadOptions ( ) ; $ event = new ImageSizesEvent ( $ this -> options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_ALL , $ event ) ; return $ event -> getImageSizes ( ) ; }
1333	protected function applyFilters ( $ query , Collection $ filters ) { if ( $ this -> isFindMany ( $ filters ) ) { $ this -> filterByIds ( $ query , $ filters ) ; } $ this -> filter ( $ query , $ filters ) ; }
5995	public function addFolderResponse ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FolderResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "FolderResponse"!' , E_USER_WARNING ) ; } } $ this -> subFolders [ ] = $ item ; return $ this ; }
133	public function getInstaller ( $ type ) { $ type = strtolower ( $ type ) ; if ( isset ( $ this -> cache [ $ type ] ) ) { return $ this -> cache [ $ type ] ; } foreach ( $ this -> installers as $ installer ) { if ( $ installer -> supports ( $ type ) ) { return $ this -> cache [ $ type ] = $ installer ; } } throw new \ InvalidArgumentException ( 'Unknown installer type: ' . $ type ) ; }
3868	protected function getConfigs ( ) { if ( ! count ( $ this -> configs ) ) { $ statement = $ this -> connection -> query ( 'SELECT * FROM tl_metamodel_searchable_pages' ) ; $ this -> configs = $ statement -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; } return $ this -> configs ; }
7923	private function extractFilename ( \ ZipArchive $ zipArchive , $ fileIndex ) { $ entry = $ zipArchive -> statIndex ( $ fileIndex ) ; $ filename = str_replace ( '\\' , '/' , $ entry [ 'name' ] ) ; if ( $ this -> isValidPath ( $ filename ) ) { return $ filename ; } throw new \ Exception ( 'Invalid filename path in zip archive' ) ; }
2813	public function initController ( $ controllerAction = null ) { $ controller = Mage :: getModel ( 'sheep_debug/controller' ) ; $ controller -> init ( $ controllerAction ) ; $ this -> action = $ controller ; }
11791	public function setFrom ( $ mail = '' , $ name = null , $ reply = true ) { $ mail = trim ( $ mail ) ; if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { $ this -> from = ! empty ( $ name ) ? array ( $ name => $ mail ) : array ( $ mail ) ; $ this -> getMailer ( ) -> setRegistry ( 'Return-Path' , '<' . $ mail . '>' , 'headers' ) ; $ this -> getMailer ( ) -> setRegistry ( 'X-Sender' , $ mail , 'headers' ) ; if ( $ reply ) { $ this -> setReplyTo ( $ mail , $ name ) ; } } return $ this ; }
4204	private function addPropertiesPhpDoc ( Event $ abs ) { $ tags = array ( 'property' => 'magic' , 'property-read' => 'magic-read' , 'property-write' => 'magic-write' , ) ; $ inheritedFrom = null ; if ( ! \ array_intersect_key ( $ abs [ 'phpDoc' ] , $ tags ) ) { $ found = false ; $ obj = $ abs -> getSubject ( ) ; if ( ! \ method_exists ( $ obj , '__get' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ parsed = $ this -> phpDoc -> getParsed ( $ reflector ) ; $ tagIntersect = \ array_intersect_key ( $ parsed , $ tags ) ; if ( ! $ tagIntersect ) { continue ; } $ found = true ; $ inheritedFrom = $ reflector -> getName ( ) ; $ abs [ 'phpDoc' ] = \ array_merge ( $ abs [ 'phpDoc' ] , $ tagIntersect ) ; break ; } if ( ! $ found ) { return ; } } $ properties = $ abs [ 'properties' ] ; foreach ( $ tags as $ tag => $ vis ) { if ( ! isset ( $ abs [ 'phpDoc' ] [ $ tag ] ) ) { continue ; } foreach ( $ abs [ 'phpDoc' ] [ $ tag ] as $ phpDocProp ) { $ exists = isset ( $ properties [ $ phpDocProp [ 'name' ] ] ) ; $ properties [ $ phpDocProp [ 'name' ] ] = \ array_merge ( $ exists ? $ properties [ $ phpDocProp [ 'name' ] ] : self :: $ basePropInfo , array ( 'desc' => $ phpDocProp [ 'desc' ] , 'type' => $ phpDocProp [ 'type' ] , 'inheritedFrom' => $ inheritedFrom , 'visibility' => $ exists ? array ( $ properties [ $ phpDocProp [ 'name' ] ] [ 'visibility' ] , $ vis ) : $ vis , ) ) ; if ( ! $ exists ) { $ properties [ $ phpDocProp [ 'name' ] ] [ 'value' ] = $ this -> abstracter -> UNDEFINED ; } } unset ( $ abs [ 'phpDoc' ] [ $ tag ] ) ; } $ abs [ 'properties' ] = $ properties ; return ; }
5408	protected function isMatch ( $ cookie , $ host , $ path , $ name ) { if ( $ cookie -> getName ( ) != $ name ) { return false ; } if ( $ host && $ cookie -> getHost ( ) && ! $ cookie -> isValidHost ( $ host ) ) { return false ; } if ( ! $ cookie -> isValidPath ( $ path ) ) { return false ; } return true ; }
9059	public function addUnique ( string ... $ name ) : self { $ key = new Index ( ... $ name ) ; $ key -> setUnique ( ) ; $ this -> keys [ $ key -> name ] = $ key ; return $ this ; }
10710	public function getById ( $ id , $ columns = [ '*' ] ) { try { $ results = $ this -> getQuery ( ) -> findOrFail ( $ id , $ columns ) ; } catch ( ModelNotFoundException $ e ) { throw new NotFoundRepositoryException ( $ e ) ; } return $ this -> returnResults ( $ results ) ; }
63	public function rmdir ( $ path ) { $ deleted = @ rmdir ( $ path ) ; if ( ! $ deleted ) { if ( Platform :: isWindows ( ) ) { usleep ( 350000 ) ; $ deleted = @ rmdir ( $ path ) ; } if ( ! $ deleted ) { $ error = error_get_last ( ) ; $ message = 'Could not delete ' . $ path . ': ' . @ $ error [ 'message' ] ; if ( Platform :: isWindows ( ) ) { $ message .= "\nThis can be due to an antivirus or the Windows Search Indexer locking the file while they are analyzed" ; } throw new \ RuntimeException ( $ message ) ; } } return true ; }
3368	public function generateFromMetadata ( array $ metadata ) { $ this -> metadata = $ metadata ; $ this -> visitedAssociations = [ ] ; $ str = [ ] ; foreach ( $ metadata as $ class ) { $ parent = $ this -> getParent ( $ class ) ; if ( $ parent ) { $ str [ ] = $ this -> getClassString ( $ parent ) . '^' . $ this -> getClassString ( $ class ) ; } $ associations = $ class -> getAssociationNames ( ) ; if ( empty ( $ associations ) && ! isset ( $ this -> visitedAssociations [ $ class -> getName ( ) ] ) ) { $ str [ ] = $ this -> getClassString ( $ class ) ; continue ; } foreach ( $ associations as $ associationName ) { if ( $ parent && in_array ( $ associationName , $ parent -> getAssociationNames ( ) ) ) { continue ; } if ( $ this -> visitAssociation ( $ class -> getName ( ) , $ associationName ) ) { $ str [ ] = $ this -> getAssociationString ( $ class , $ associationName ) ; } } } return implode ( ',' , $ str ) ; }
4431	protected function writeSection ( $ text , $ style = 'bg=blue;fg=white' ) { $ this -> output -> writeln ( array ( '' , $ this -> getHelper ( 'formatter' ) -> formatBlock ( $ text , $ style , true ) , '' , ) ) ; }
11289	protected function _getModel ( $ attributeName , $ relatedObjName = false , $ query = false , $ loadMap = false , $ record = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = null ; if ( $ relatedObjName ) { if ( $ loadMap instanceof \ Cora \ Adm \ LoadMap && ! $ loadMap -> fetchData ( ) && $ record !== false ) { $ relatedObj = $ this -> fetchRelatedObj ( $ def [ 'model' ] ) ; $ result = $ relatedObj -> _populate ( $ record , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'via' ] ) ) { $ result = $ this -> _getModelFromTableColumn ( $ attributeName , $ def [ 'model' ] , $ def [ 'via' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'using' ] ) ) { $ result = $ this -> getModelFromCustomRelationship ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'usesRefTable' ] ) ) { $ result = $ this -> _getModelFromRelationTable ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap ) ; } else { $ relatedObj = $ this -> fetchRelatedObj ( $ def [ 'model' ] ) ; if ( $ query && $ query -> isCustom ( ) ) { $ data = $ query -> fetch ( ) ; $ result = $ relatedObj -> _populate ( $ data ) ; } else { if ( ! isset ( $ this -> model_data [ $ attributeName ] ) ) { $ this -> model_data [ $ attributeName ] = $ this -> _fetchData ( $ attributeName ) ; } if ( ! is_object ( $ this -> model_data [ $ attributeName ] ) ) { $ relObjRepo = $ relatedObj -> getRepository ( true ) ; $ result = $ relObjRepo -> find ( $ this -> model_data [ $ attributeName ] ) ; } else { $ result = $ this -> model_data [ $ attributeName ] ; } if ( $ result ) { $ result -> _populate ( [ ] , false , $ loadMap ) ; } } } } return $ result ; }
11921	public static function arrayRecursiveDiff ( $ aArray1 , $ aArray2 ) { $ aReturn = array ( ) ; foreach ( $ aArray1 as $ mKey => $ mValue ) { if ( array_key_exists ( $ mKey , $ aArray2 ) ) { if ( is_array ( $ mValue ) ) { $ aRecursiveDiff = self :: arrayRecursiveDiff ( $ mValue , $ aArray2 [ $ mKey ] ) ; if ( count ( $ aRecursiveDiff ) ) { $ aReturn [ $ mKey ] = $ aRecursiveDiff ; } } else { if ( $ mValue != $ aArray2 [ $ mKey ] ) { $ aReturn [ $ mKey ] = $ mValue ; } } } else { $ aReturn [ $ mKey ] = $ mValue ; } } return $ aReturn ; }
7619	public function setPermissionSet ( $ value = array ( ) ) { foreach ( $ value as $ url ) { if ( strpos ( $ url , $ this -> accountName ) === false ) { throw new Exception ( 'The permission set can only contain URLs for the account name specified in the Credentials_SharedAccessSignature instance.' ) ; } } $ this -> permissionSet = $ value ; }
10880	public function renderPreviousExceptions ( $ exception ) { if ( ( $ previous = $ exception -> getPrevious ( ) ) !== null ) { return $ this -> renderFile ( $ this -> previousExceptionView , [ 'exception' => $ previous ] ) ; } else { return '' ; } }
7537	function clear ( ) { foreach ( $ this -> children as $ c ) { $ c -> parent = null ; $ c -> delete ( ) ; } $ this -> children = array ( ) ; }
2935	public function backup ( ) { if ( ! is_file ( $ this -> filePath ) ) { throw new FileNotFoundException ( "File does not exist at path {$this->filePath}" ) ; return false ; } copy ( $ this -> filePath , $ this -> backupPath . self :: BACKUP_FILENAME_PREFIX . date ( 'Y_m_d_His' ) . self :: BACKUP_FILENAME_SUFFIX ) ; return $ this ; }
3749	protected function getItemsFromFilter ( $ filter , $ config ) { $ sorting = $ this -> extractSorting ( $ config ) ; return $ this -> getMetaModel ( ) -> findByFilter ( $ filter , $ sorting [ 0 ] , $ config -> getStart ( ) , $ config -> getAmount ( ) , strtoupper ( $ sorting [ 1 ] ) , $ config -> getFields ( ) ? : array ( ) ) ; }
11324	public static function convertCase ( $ string , $ toCase ) { $ str = strtolower ( ltrim ( preg_replace ( [ '/[A-Z]/' , '/[_]/' ] , [ ' $0' , ' ' ] , $ string ) ) ) ; switch ( strtoupper ( $ toCase ) ) { case 'PASCAL' : return str_replace ( ' ' , '' , ucwords ( $ str ) ) ; case 'CAMEL' : return lcfirst ( str_replace ( ' ' , '' , ucwords ( $ str ) ) ) ; default : return str_replace ( ' ' , '_' , $ str ) ; } }
502	public function registerClientScript ( ) { $ id = $ this -> grid -> options [ 'id' ] ; $ options = Json :: encode ( [ 'name' => $ this -> name , 'class' => $ this -> cssClass , 'multiple' => $ this -> multiple , 'checkAll' => $ this -> grid -> showHeader ? $ this -> getHeaderCheckBoxName ( ) : null , ] ) ; $ this -> grid -> getView ( ) -> registerJs ( "jQuery('#$id').yiiGridView('setSelectionColumn', $options);" ) ; }
5110	private function appendBind ( $ part , $ bind ) { if ( $ bind === false ) return $ this ; if ( ! is_array ( $ bind ) ) $ bind = [ $ bind ] ; if ( ! $ this -> bind [ $ part ] ) { $ this -> bind [ $ part ] = $ bind ; } else { $ this -> bind [ $ part ] = array_merge ( $ this -> bind [ $ part ] , $ bind ) ; } return $ this ; }
9517	public function recreate ( $ file ) { if ( is_file ( $ file ) ) { return ; } $ virtual = $ tables = $ indexes = array ( ) ; if ( $ result = $ this -> query ( 'SELECT type, name, sql FROM sqlite_master' ) ) { while ( list ( $ type , $ name , $ sql ) = $ this -> fetch ( $ result ) ) { if ( ! empty ( $ sql ) ) { switch ( $ type ) { case 'table' : $ tables [ $ name ] = $ sql ; break ; case 'index' : $ indexes [ ] = $ sql ; break ; } } } $ this -> close ( $ result ) ; } foreach ( $ tables as $ name => $ sql ) { if ( strpos ( $ sql , 'VIRTUAL TABLE' ) ) { $ virtual [ ] = $ name ; } } foreach ( $ virtual as $ table ) { foreach ( $ tables as $ name => $ sql ) { if ( strpos ( $ name , "{$table}_" ) === 0 ) { unset ( $ tables [ $ name ] ) ; } } } $ db = new self ( $ file ) ; $ this -> exec ( 'ATTACH DATABASE ' . $ this -> dbEscape ( $ file ) . ' AS recreate' ) ; foreach ( $ tables as $ table => $ sql ) { $ db -> connection ( ) -> exec ( $ sql ) ; if ( $ fields = $ this -> row ( 'SELECT * FROM ' . $ table . ' LIMIT 1' , '' , 'assoc' ) ) { $ fields = implode ( ', ' , array_keys ( $ fields ) ) ; $ this -> exec ( "INSERT INTO recreate.{$table} ({$fields}) SELECT * FROM {$table}" ) ; } } foreach ( $ indexes as $ sql ) { $ db -> connection ( ) -> exec ( $ sql ) ; } $ db -> connection ( ) -> close ( ) ; }
11174	public static function hash ( $ string , $ algorithm = 'blowfish' ) { switch ( strtolower ( $ algorithm ) ) : case ( 'md5' ) : $ salt = '$1$' . ( static :: rand ( 12 ) ) . '$' ; break ; case ( 'sha256' ) : $ salt = '$5$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'sha512' ) : $ salt = '$6$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'blowfish' ) : default : $ salt = '$2a$09$' . ( static :: rand ( 22 ) ) . '$' ; break ; endswitch ; return base64_encode ( crypt ( $ string , $ salt ) ) ; }
8487	public static function getCpuFreq ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT CurrentClockSpeed FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> CurrentClockSpeed ; } return 'Unknown' ; }
394	public static function updateAll ( $ attributes , $ condition = '' , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> update ( static :: tableName ( ) , $ attributes , $ condition , $ params ) ; return $ command -> execute ( ) ; }
11050	function protect_spaces ( $ data ) { $ data = str_replace ( "\n" , "\1n\1" , $ data ) ; $ data = str_replace ( "\r" , "\1r\1" , $ data ) ; $ data = str_replace ( "\t" , "\1t\1" , $ data ) ; return str_replace ( " " , "\1s\1" , $ data ) ; }
3074	public function getRubrics ( RunnerServiceContext $ context , AssessmentItemRef $ itemRef = null ) { $ session = $ context -> getTestSession ( ) ; $ routeItem = null ; if ( ! is_null ( $ itemRef ) ) { try { $ routeItem = $ session -> getRoute ( ) -> getRouteItemsByAssessmentItemRef ( $ itemRef ) ; if ( $ routeItem ) { $ routeItem = $ routeItem [ 0 ] ; } } catch ( OutOfBoundsException $ obe ) { \ common_Logger :: d ( "Could not retrieve the route for item '${itemRef}'." ) ; } } else { $ routeItem = $ session -> getRoute ( ) -> current ( ) ; } return implode ( '' , $ this -> getRubricBlock ( $ routeItem , $ session , $ context -> getCompilationDirectory ( ) ) ) ; }
2448	public function sendNotifications ( $ varValue ) { if ( $ varValue ) { Contao \ Comments :: notifyCommentsSubscribers ( Contao \ CommentsModel :: findByPk ( Contao \ Input :: get ( 'id' ) ) ) ; } return $ varValue ; }
5316	public function toCollection ( ) { if ( function_exists ( $ this -> collectionFunction ) ) { return call_user_func ( $ this -> collectionFunction , $ this -> toArray ( ) ) ; } throw new \ Exception ( "Function {$this->collectionFunction}() was not found. " . "You probably need to install a suggested package?" ) ; }
8138	public function getTemplateClass ( $ name , $ index = null ) { $ key = $ this -> getLoader ( ) -> getCacheKey ( $ name ) . $ this -> optionsHash ; return $ this -> templateClassPrefix . hash ( 'sha256' , $ key ) . ( null === $ index ? '' : '_' . $ index ) ; }
10810	public function actionIndex ( $ option = null ) { $ allNames = [ 'web/assets' , 'runtime' , 'runtime/cache' , 'tests/_output' , ] ; $ answer = Select :: display ( 'Select objects' , $ allNames , 1 ) ; $ result = ClearHelper :: run ( $ answer ) ; if ( $ result ) { Output :: items ( $ result , "Clear completed: " . count ( $ result ) . " objects" ) ; } else { Output :: block ( "Not fount object for clear!" ) ; } }
4930	public function detach ( EventManagerInterface $ events ) { foreach ( $ this -> listeners as $ i => $ listener ) { if ( $ events -> detach ( $ listener ) ) { unset ( $ this -> listeners [ $ i ] ) ; } } return empty ( $ this -> listeners ) ; }
11966	public function renderSlots ( Page $ page , array $ slots , array $ options = array ( ) ) { $ renderedSlots = array ( ) ; $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERING , $ page , $ slots ) ; foreach ( $ slots as $ slotName => $ slot ) { if ( is_string ( $ slot ) ) { $ renderedSlots [ $ slotName ] = $ slot ; continue ; } if ( ! $ slot instanceof Slot ) { continue ; } $ renderedSlots [ $ slotName ] = implode ( "" , $ this -> renderSlot ( $ slot ) ) ; } $ this -> mediaFiles = array_unique ( $ this -> mediaFiles ) ; return $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERED , $ page , $ renderedSlots ) ; }
5611	public function paintMethodStart ( $ message ) { parent :: paintMethodStart ( $ message ) ; $ node = new TreemapNode ( 'Method' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
11330	public function getMultiline ( ) { if ( is_null ( $ this -> _multiline ) ) { $ this -> _multiline = MultilineDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _multiline ; }
10025	function getContact ( $ contactId , $ checksum , $ standard_fields = array ( ) , $ custom_fields = array ( ) , $ ignoreChecksum = false ) { $ queryParameters = array ( 'id' => $ contactId , 'checksum' => $ checksum , 'standard_field' => $ standard_fields , 'ignore_checksum' => $ ignoreChecksum ? "true" : "false" ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/contact' , $ queryParameters ) ; }
8806	protected function ensureFacadeExists ( $ alias ) { if ( file_exists ( $ path = storage_path ( 'cache/facade-' . sha1 ( $ alias ) . '.php' ) ) ) { return $ path ; } file_put_contents ( $ path , $ this -> formatFacadeStub ( $ alias , file_get_contents ( __DIR__ . '/stubs/facade.stub' ) ) ) ; return $ path ; }
4207	private function getPropCommentInfo ( \ ReflectionProperty $ reflectionProperty ) { $ name = $ reflectionProperty -> name ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionProperty ) ; $ info = array ( 'type' => null , 'desc' => $ phpDoc [ 'summary' ] ? $ phpDoc [ 'summary' ] : null , ) ; if ( isset ( $ phpDoc [ 'var' ] ) ) { if ( \ count ( $ phpDoc [ 'var' ] ) == 1 ) { $ var = $ phpDoc [ 'var' ] [ 0 ] ; } else { foreach ( $ phpDoc [ 'var' ] as $ var ) { if ( $ var [ 'name' ] == $ name ) { break ; } } } $ info [ 'type' ] = $ var [ 'type' ] ; if ( ! $ info [ 'desc' ] ) { $ info [ 'desc' ] = $ var [ 'desc' ] ; } elseif ( $ var [ 'desc' ] ) { $ info [ 'desc' ] = $ info [ 'desc' ] . ': ' . $ var [ 'desc' ] ; } } return $ info ; }
4412	public function getLegacyPreference ( $ name ) { $ legacyKernel = $ this -> legacyKernel ; return $ legacyKernel ( ) -> runCallback ( function ( ) use ( $ name ) { return eZPreferences :: value ( $ name ) ; } ) ; }
9607	public function projectOnto ( self $ b ) { $ bUnit = $ b -> normalize ( ) ; return $ bUnit -> multiplyByScalar ( $ this -> dotProduct ( $ bUnit ) ) ; }
7227	public function url ( $ url = null ) { if ( $ url ) { $ this -> url = $ url ; $ this -> option ( [ CURLOPT_URL => $ url ] ) ; } return $ this -> url ; }
10160	private function readMsoDrawing ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingData .= $ recordData ; }
8144	public function tokenize ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer -> tokenize ( $ source ) ; }
9276	public function validateFields ( Request $ request , Repository $ repository , $ data ) { $ config = [ ] ; $ validation = [ ] ; foreach ( $ this -> versions as $ version ) { foreach ( $ version [ 'endpoints' ] as $ endpoint ) { if ( $ endpoint [ 'repository' ] == $ request -> attributes -> get ( 'repository' ) ) { $ config = $ endpoint ; break ; } } if ( $ config != [ ] ) { break ; } } if ( ! $ config [ 'allow_extra_fields' ] || $ config [ 'allow_fields' ] ) { $ mapping = $ this -> manager -> getMetadataCollector ( ) -> getMapping ( $ repository -> getClassName ( ) ) ; $ forbiddenFields = $ mapping [ 'properties' ] ; if ( $ config [ 'allow_fields' ] ) { foreach ( $ config [ 'allow_fields' ] as $ field ) { unset ( $ forbiddenFields [ $ field ] ) ; } } foreach ( $ data as $ parameter => $ value ) { if ( ! array_key_exists ( $ parameter , $ mapping [ 'properties' ] ) && $ parameter != '_id' ) { $ validation [ 'message' ] = sprintf ( 'Property `%s` does not exist in the mapping of `%s`.' , $ parameter , $ repository -> getType ( ) ) ; return $ validation ; } if ( $ config [ 'allow_fields' ] && array_key_exists ( $ parameter , $ forbiddenFields ) ) { $ validation [ 'message' ] = sprintf ( 'You are not allowed to insert or modify the field `%s` in `%s`' , $ parameter , $ repository -> getType ( ) ) ; return $ validation ; } } } return $ validation ; }
11539	public function add ( $ sourceDir , array $ options , $ username ) { $ this -> resolveAddOptions ( $ options ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ this -> addBlockToSlot ( $ dir , $ options ) ; $ blockContent = $ this -> addBlock ( $ dir , $ options , $ blockName ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been added to the "%s" slot on page "%s" for the "%s_%s" language' , $ blockName , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; return $ blockContent ; }
10292	public static function setDefaultTimezone ( $ timeZone ) { if ( $ timeZone = self :: validateTimeZone ( $ timeZone ) ) { self :: $ defaultTimeZone = $ timeZone ; return true ; } return false ; }
11627	public function lock ( ) { $ lock_file = $ this -> getLockFile ( ) ; if ( file_exists ( $ lock_file ) ) { $ this -> pid = file_get_contents ( $ lock_file ) ; if ( $ this -> isrunning ( ) ) { error_log ( "==" . $ this -> pid . "== Already in progress..." ) ; return false ; } else error_log ( "==" . $ this -> pid . "== Previous job died abruptly..." ) ; } $ this -> pid = getmypid ( ) ; $ s = file_put_contents ( $ lock_file , $ this -> pid ) ; error_log ( "==" . $ this -> pid . "== Lock acquired, processing the job..." ) ; return $ this -> pid ; }
11515	public function getNamedParam ( string $ category , string $ key ) { $ params = $ this -> getNamedParams ( $ category ) ; return $ params [ $ key ] ?? '' ; }
10278	public function write ( Spreadsheet $ spreadsheet = null ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-styles' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:style' , 'urn:oasis:names:tc:opendocument:xmlns:style:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:text' , 'urn:oasis:names:tc:opendocument:xmlns:text:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:table' , 'urn:oasis:names:tc:opendocument:xmlns:table:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:draw' , 'urn:oasis:names:tc:opendocument:xmlns:drawing:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:fo' , 'urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:dc' , 'http://purl.org/dc/elements/1.1/' ) ; $ objWriter -> writeAttribute ( 'xmlns:meta' , 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:number' , 'urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:presentation' , 'urn:oasis:names:tc:opendocument:xmlns:presentation:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:svg' , 'urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:chart' , 'urn:oasis:names:tc:opendocument:xmlns:chart:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:dr3d' , 'urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:math' , 'http://www.w3.org/1998/Math/MathML' ) ; $ objWriter -> writeAttribute ( 'xmlns:form' , 'urn:oasis:names:tc:opendocument:xmlns:form:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:script' , 'urn:oasis:names:tc:opendocument:xmlns:script:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooow' , 'http://openoffice.org/2004/writer' ) ; $ objWriter -> writeAttribute ( 'xmlns:oooc' , 'http://openoffice.org/2004/calc' ) ; $ objWriter -> writeAttribute ( 'xmlns:dom' , 'http://www.w3.org/2001/xml-events' ) ; $ objWriter -> writeAttribute ( 'xmlns:rpt' , 'http://openoffice.org/2005/report' ) ; $ objWriter -> writeAttribute ( 'xmlns:of' , 'urn:oasis:names:tc:opendocument:xmlns:of:1.2' ) ; $ objWriter -> writeAttribute ( 'xmlns:xhtml' , 'http://www.w3.org/1999/xhtml' ) ; $ objWriter -> writeAttribute ( 'xmlns:grddl' , 'http://www.w3.org/2003/g/data-view#' ) ; $ objWriter -> writeAttribute ( 'xmlns:tableooo' , 'http://openoffice.org/2009/table' ) ; $ objWriter -> writeAttribute ( 'xmlns:css3t' , 'http://www.w3.org/TR/css3-text/' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> writeElement ( 'office:font-face-decls' ) ; $ objWriter -> writeElement ( 'office:styles' ) ; $ objWriter -> writeElement ( 'office:automatic-styles' ) ; $ objWriter -> writeElement ( 'office:master-styles' ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
6808	public function number ( float $ number ) : string { return $ this -> getNumberFormatter ( ) -> format ( $ number , NumberFormatter :: TYPE_DEFAULT ) ; }
9897	private function convertString ( $ string ) { $ string = substr ( $ string , 1 , - 1 ) ; if ( strlen ( $ string ) > 255 ) { throw new WriterException ( 'String is too long' ) ; } return pack ( 'C' , $ this -> ptg [ 'ptgStr' ] ) . StringHelper :: UTF8toBIFF8UnicodeShort ( $ string ) ; }
2131	public function save ( ) { if ( $ this -> strTop == '' ) { $ this -> strTop = '<?php' ; } $ strFile = trim ( $ this -> strTop ) . "\n\n" ; $ strFile .= "### INSTALL SCRIPT START ###\n" ; foreach ( $ this -> arrData as $ k => $ v ) { $ strFile .= "$k = $v\n" ; } $ strFile .= "### INSTALL SCRIPT STOP ###\n" ; $ this -> strBottom = trim ( $ this -> strBottom ) ; if ( $ this -> strBottom != '' ) { $ strFile .= "\n" . $ this -> strBottom . "\n" ; } $ strTemp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objFile = fopen ( $ this -> strRootDir . '/system/tmp/' . $ strTemp , 'wb' ) ; fwrite ( $ objFile , $ strFile ) ; fclose ( $ objFile ) ; if ( ! filesize ( $ this -> strRootDir . '/system/tmp/' . $ strTemp ) ) { System :: log ( 'The local configuration file could not be written. Have your reached your quota limit?' , __METHOD__ , TL_ERROR ) ; return ; } $ this -> Files -> chmod ( 'system/tmp/' . $ strTemp , 0666 & ~ umask ( ) ) ; $ this -> Files -> rename ( 'system/tmp/' . $ strTemp , 'system/config/localconfig.php' ) ; if ( \ function_exists ( 'opcache_invalidate' ) ) { opcache_invalidate ( $ this -> strRootDir . '/system/config/localconfig.php' , true ) ; } if ( \ function_exists ( 'apc_compile_file' ) && ! ini_get ( 'apc.stat' ) ) { apc_compile_file ( $ this -> strRootDir . '/system/config/localconfig.php' ) ; } $ this -> blnIsModified = false ; }
7846	public function cancel ( array $ identifiers = [ ] ) : ? array { $ this -> checkConfig ( ) ; if ( empty ( $ identifiers ) ) { return null ; } $ messages = [ ] ; foreach ( $ identifiers as $ id ) { $ messages [ ] = [ 'id' => ( int ) $ id ] ; } $ body = Body :: json ( $ messages ) ; $ response = Request :: post ( $ this -> baseUrl . 'message/cancel' , [ ] , $ body ) ; if ( $ response -> code == 200 ) { return [ 'code' => $ response -> code , 'message' => 'OK' , 'data' => $ response -> body , ] ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } return [ 'code' => $ response -> code , 'message' => $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } }
10239	public static function unwrapResult ( $ value ) { if ( is_string ( $ value ) ) { if ( ( isset ( $ value [ 0 ] ) ) && ( $ value [ 0 ] == '"' ) && ( substr ( $ value , - 1 ) == '"' ) ) { return substr ( $ value , 1 , - 1 ) ; } } elseif ( ( is_float ( $ value ) ) && ( ( is_nan ( $ value ) ) || ( is_infinite ( $ value ) ) ) ) { return Functions :: NAN ( ) ; } return $ value ; }
7229	public static function create ( $ method , $ url , $ data = "" , array $ headers = [ ] , array $ options = [ ] , $ initOnly = false ) { $ curl = null ; if ( ! strcasecmp ( $ method , "GET" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "GET" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "POST" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "POST" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "PUT" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "PUT" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "DELETE" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "DELETE" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; return $ curl ; }
9220	protected function requestAllPages ( $ forceRefresh = false ) { $ _page = $ this -> page ; $ _key = $ this -> key ; $ nextPageNumber = false ; if ( isset ( $ this -> pagination [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> pagination [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } while ( $ nextPageNumber !== false ) { $ this -> requestPageNumber ( $ nextPageNumber , $ forceRefresh ) ; if ( isset ( $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } else { $ nextPageNumber = false ; } } $ this -> page = $ _page ; $ this -> key = $ _key ; }
5153	public function addConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } $ config = $ this -> getConfiguration ( ) ; if ( $ config instanceof ConfigurationInterface ) { $ config -> merge ( $ configuration ) ; } if ( $ config === null ) { $ config = $ configuration ; } $ this -> setConfiguration ( $ config , $ configure ) ; }
5868	public static function getMetadata ( $ fileName , $ fullExtract = false ) { $ metadata = static :: getBasicMetadata ( $ fileName ) ; if ( $ fullExtract && ! empty ( $ metadata ) ) { $ virtualFileObject = static :: getVirtualFileObject ( $ fileName , $ metadata ) ; $ extractorRegistry = \ TYPO3 \ CMS \ Core \ Resource \ Index \ ExtractorRegistry :: getInstance ( ) ; $ extractionServices = $ extractorRegistry -> getExtractorsWithDriverSupport ( 'Local' ) ; $ newMetadata = [ 0 => $ metadata , ] ; foreach ( $ extractionServices as $ service ) { if ( $ service -> canProcess ( $ virtualFileObject ) ) { $ newMetadata [ $ service -> getPriority ( ) ] = $ service -> extractMetaData ( $ virtualFileObject , $ newMetadata ) ; } } ksort ( $ newMetadata ) ; foreach ( $ newMetadata as $ data ) { $ metadata = array_merge ( $ metadata , $ data ) ; } } return $ metadata ; }
9632	public function getSetting ( $ setting ) { $ settings = $ this -> getSettings ( ) ; if ( isset ( $ settings ) && count ( $ settings ) > 0 ) { if ( isset ( $ settings [ $ setting ] ) ) { return $ settings [ $ setting ] ; } } return '' ; }
1962	public static function decodeEmail ( $ strEmail ) { if ( $ strEmail == '' ) { return '' ; } if ( strpos ( $ strEmail , '@' ) === false ) { return $ strEmail ; } $ arrChunks = explode ( '@' , $ strEmail ) ; $ strHost = static :: decode ( array_pop ( $ arrChunks ) ) ; if ( $ strHost == '' ) { return '' ; } return implode ( '@' , $ arrChunks ) . '@' . $ strHost ; }
2555	protected static function loadCorpNegoFare ( $ corporateNegoFare ) { $ opt = [ ] ; if ( $ corporateNegoFare !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_CORPORATE_NEGOTIATED_FARES ) ; $ po -> optionDetail = new OptionDetail ( $ corporateNegoFare ) ; $ opt [ ] = $ po ; } return $ opt ; }
7541	function setIndex ( $ index ) { if ( $ this -> parent ) { if ( $ index > $ this -> index ( ) ) { -- $ index ; } $ this -> delete ( ) ; $ this -> parent -> addChild ( $ this , $ index ) ; } }
210	protected function getValidXmlElementName ( $ name ) { if ( empty ( $ name ) || is_int ( $ name ) || ! $ this -> isValidXmlName ( $ name ) ) { return $ this -> itemTag ; } return $ name ; }
497	public function calculateTimings ( $ messages ) { $ timings = [ ] ; $ stack = [ ] ; foreach ( $ messages as $ i => $ log ) { list ( $ token , $ level , $ category , $ timestamp , $ traces ) = $ log ; $ memory = isset ( $ log [ 5 ] ) ? $ log [ 5 ] : 0 ; $ log [ 6 ] = $ i ; $ hash = md5 ( json_encode ( $ token ) ) ; if ( $ level == self :: LEVEL_PROFILE_BEGIN ) { $ stack [ $ hash ] = $ log ; } elseif ( $ level == self :: LEVEL_PROFILE_END ) { if ( isset ( $ stack [ $ hash ] ) ) { $ timings [ $ stack [ $ hash ] [ 6 ] ] = [ 'info' => $ stack [ $ hash ] [ 0 ] , 'category' => $ stack [ $ hash ] [ 2 ] , 'timestamp' => $ stack [ $ hash ] [ 3 ] , 'trace' => $ stack [ $ hash ] [ 4 ] , 'level' => count ( $ stack ) - 1 , 'duration' => $ timestamp - $ stack [ $ hash ] [ 3 ] , 'memory' => $ memory , 'memoryDiff' => $ memory - ( isset ( $ stack [ $ hash ] [ 5 ] ) ? $ stack [ $ hash ] [ 5 ] : 0 ) , ] ; unset ( $ stack [ $ hash ] ) ; } } } ksort ( $ timings ) ; return array_values ( $ timings ) ; }
11501	protected function loadContainer ( array $ config = [ ] , $ environment = null ) { $ containerConfigs = $ this -> provideContainerConfigs ( $ config , $ environment ) ; array_unshift ( $ containerConfigs , new WeaveConfig ( function ( $ pipelineName ) { return $ this -> provideMiddlewarePipeline ( $ pipelineName ) ; } , function ( $ router ) { return $ this -> provideRouteConfiguration ( $ router ) ; } ) ) ; $ this -> container = ( new ContainerBuilder ) -> newConfiguredInstance ( $ containerConfigs , ContainerBuilder :: AUTO_RESOLVE ) ; return $ this -> container -> get ( 'instantiator' ) ; }
3687	protected function getAttributeFromFilterOperation ( $ operation ) { $ attribute = null ; if ( ! empty ( $ operation [ 'property' ] ) ) { $ attribute = $ this -> getMetaModel ( ) -> getAttribute ( $ operation [ 'property' ] ) ; } if ( $ attribute === null ) { throw new \ InvalidArgumentException ( 'Attribute ' . $ operation [ 'property' ] . ' not found.' ) ; } return $ attribute ; }
10214	public function setColor ( Color $ pValue ) { $ color = $ pValue -> getIsSupervisor ( ) ? $ pValue -> getSharedComponent ( ) : $ pValue ; if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getColor ( ) -> getStyleArray ( [ 'argb' => $ color -> getARGB ( ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> color = $ color ; } return $ this ; }
1166	protected function parseParameters ( $ parameters ) { $ newParams = [ 'validate_all' => false ] ; if ( isset ( $ parameters [ 0 ] ) ) { $ newParams [ 'validate_all' ] = ( $ parameters [ 0 ] === 'true' ) ? true : false ; } return $ newParams ; }
2614	public function getWebsiteName ( ) { $ websites = $ this -> storeManager -> getWebsites ( ) ; $ websiteName = 'Not set.' ; foreach ( $ websites as $ website ) { if ( $ website -> getIsDefault ( ) ) { $ websiteName = $ website -> getName ( ) ; } } return $ websiteName ; }
8948	public function downloadTraceMetadetails ( $ id , $ username , $ password ) { $ base = 'gpx/' . $ id . '/details' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; return $ this -> sendRequest ( $ path , 'GET' , array ( 'Authorization' => 'Basic ' . base64_encode ( $ username . ':' . $ password ) ) ) ; }
6110	public function fileList ( $ cpw = "" , $ path = "/" , $ recursive = false ) { return $ this -> getParent ( ) -> channelFileList ( $ this -> getId ( ) , $ cpw , $ path , $ recursive ) ; }
3673	private function getPageIdFromUrlHook ( ? array $ fragments ) : ? array { if ( ! ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] ) ) ) { return $ fragments ; } foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] as $ callback ) { $ fragments = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ fragments ) ; } return $ fragments ; }
3048	public function init ( ) { $ sessionStateService = $ this -> getServiceManager ( ) -> get ( SessionStateService :: SERVICE_ID ) ; $ sessionStateService -> resumeSession ( $ this -> getTestSession ( ) ) ; $ this -> retrieveItemIndex ( ) ; }
2290	protected function addRecipient ( $ strEmail , $ arrNew ) { if ( ( $ objOld = NewsletterRecipientsModel :: findOldSubscriptionsByEmailAndPids ( $ strEmail , $ arrNew ) ) !== null ) { while ( $ objOld -> next ( ) ) { $ objOld -> delete ( ) ; } } $ time = time ( ) ; $ arrRelated = array ( ) ; foreach ( $ arrNew as $ id ) { $ objRecipient = new NewsletterRecipientsModel ( ) ; $ objRecipient -> pid = $ id ; $ objRecipient -> tstamp = $ time ; $ objRecipient -> email = $ strEmail ; $ objRecipient -> active = '' ; $ objRecipient -> addedOn = $ time ; $ objRecipient -> save ( ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( md5 ( $ strEmail ) , $ id ) ) !== null ) { $ objBlacklist -> delete ( ) ; } $ arrRelated [ 'tl_newsletter_recipients' ] [ ] = $ objRecipient -> id ; } $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = $ optIn -> create ( 'nl' , $ strEmail , $ arrRelated ) ; $ objChannel = NewsletterChannelModel :: findByIds ( $ arrNew ) ; $ arrData = array ( ) ; $ arrData [ 'token' ] = $ optInToken -> getIdentifier ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'link' ] = Idna :: decode ( Environment :: get ( 'base' ) ) . Environment :: get ( 'request' ) . ( ( strpos ( Environment :: get ( 'request' ) , '?' ) !== false ) ? '&' : '?' ) . 'token=' . $ optInToken -> getIdentifier ( ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ objChannel -> fetchEach ( 'title' ) ) ; $ optInToken -> send ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) , StringUtil :: parseSimpleTokens ( $ this -> nl_subscribe , $ arrData ) ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_confirm' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_confirm' ] ) ; $ this -> reload ( ) ; }
6007	public static function fromHex ( $ hex ) { if ( strlen ( $ hex ) != 2 ) { throw new Ts3Exception ( "given parameter '" . $ hex . "' is not a valid hexadecimal number" ) ; } return new self ( chr ( hexdec ( $ hex ) ) ) ; }
2155	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objNewsletter = NewsletterChannelModel :: findAll ( ) ; if ( $ objNewsletter !== null ) { while ( $ objNewsletter -> next ( ) ) { if ( ! $ objNewsletter -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objNewsletter -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objNewsletter -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objNewsletter -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objNewsletter -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objNewsletter -> jumpTo ] ; $ objItem = NewsletterModel :: findSentByPid ( $ objNewsletter -> id ) ; if ( $ objItem !== null ) { while ( $ objItem -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItem -> alias ? : $ objItem -> id ) ) ; } } } } return $ arrPages ; }
6433	protected function getSerializeVars ( $ skip = array ( ) ) { $ vars = get_object_vars ( $ this ) ; $ servars = array ( ) ; foreach ( $ vars as $ k => $ v ) { if ( in_array ( $ k , $ skip ) ) { continue ; } if ( $ k == 'options' || $ k == 'logger' ) { continue ; } $ servars [ ] = $ k ; } return $ servars ; }
2934	public function save ( ) { if ( is_file ( $ this -> filePath ) && $ this -> autoBackup ) { $ this -> backup ( ) ; } $ this -> writer -> save ( $ this -> filePath ) ; return $ this ; }
1125	public function isDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) > $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; }
5959	public function clientGetByUid ( $ uid ) { foreach ( $ this -> clientList ( ) as $ client ) { if ( $ client [ "client_unique_identifier" ] == $ uid ) { return $ client ; } } throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; }
5294	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing CSS file to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getCss ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created CSS file successfully</success>' ) ; }
951	public function activate ( ) { $ currentCharge = $ this -> shop -> planCharge ( ) ; if ( ! $ currentCharge -> isType ( Charge :: CHARGE_RECURRING ) ) { throw new Exception ( 'Can only create usage charges for recurring charge.' ) ; } $ this -> response = $ this -> api -> rest ( 'POST' , "/admin/recurring_application_charges/{$currentCharge->charge_id}/usage_charges.json" , [ 'usage_charge' => [ 'price' => $ this -> data [ 'price' ] , 'description' => $ this -> data [ 'description' ] , ] , ] ) -> body -> usage_charge ; return $ this -> response ; }
3195	public function setConsumedExtraTime ( $ time ) { $ this -> consumedExtraTime = max ( $ this -> consumedExtraTime , floatval ( $ time ) ) ; return $ this ; }
4847	public static function unregister ( ) { if ( isset ( self :: $ autoloadFn ) ) { spl_autoload_unregister ( self :: $ autoloadFn ) ; self :: $ autoloadFn = null ; } self :: $ aliases = [ ] ; }
2034	public function onRegister ( Registry $ registry ) { parent :: onRegister ( $ registry ) ; if ( $ this -> fallback && $ this -> type == 'root' && ! $ registry -> isRegisteredAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ) { $ registry -> registerAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ; } }
11673	public function offsetExists ( $ offset ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( array_key_exists ( $ offset , $ this -> result ) ) { return true ; } else { return false ; } }
3739	private function saveBaseColumns ( IItem $ item , $ timestamp ) { $ isNew = false ; $ item -> set ( 'tstamp' , $ timestamp ) ; if ( ! $ item -> get ( 'id' ) ) { $ isNew = true ; $ this -> createNewItem ( $ item ) ; } if ( null !== $ item -> get ( 'pid' ) ) { $ this -> saveSimpleColumn ( 'pid' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'pid' ) ) ; } if ( null !== $ item -> get ( 'sorting' ) ) { $ this -> saveSimpleColumn ( 'sorting' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'sorting' ) ) ; } $ this -> saveSimpleColumn ( 'tstamp' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'tstamp' ) ) ; return $ isNew ; }
5111	protected function appendPart ( $ part , $ sql , $ bind = false ) { if ( ! is_array ( $ sql ) ) $ sql = [ $ sql ] ; if ( ! $ this -> parts [ $ part ] ) { $ this -> parts [ $ part ] = $ sql ; } else { $ this -> parts [ $ part ] = array_merge ( $ this -> parts [ $ part ] , $ sql ) ; } return $ this -> appendBind ( $ part , $ bind ) ; }
9248	public function from ( Contract $ contract , string $ string , callable $ callback = null ) : string { return $ this -> callback ( $ contract -> recipe ( $ string , 'upperCaseFirst' , function ( $ string ) use ( $ contract ) { if ( $ contract instanceof ClassName ) { return lcfirst ( $ string ) ; } return strtolower ( $ string ) ; } ) , $ callback ) ; }
1561	protected function deserializeAttributes ( $ attributes , $ record ) { return collect ( $ attributes ) -> reject ( function ( $ v , $ field ) use ( $ record ) { return $ this -> isNotFillable ( $ field , $ record ) ; } ) -> mapWithKeys ( function ( $ value , $ field ) use ( $ record ) { $ key = $ this -> modelKeyForField ( $ field , $ record ) ; return [ $ key => $ this -> deserializeAttribute ( $ value , $ field , $ record ) ] ; } ) -> all ( ) ; }
12083	public function getAllMedia ( $ objectType = 'media' , $ objectURI = NULL , $ objectId = NULL ) { $ objects = $ this -> getMediaObjectsList ( $ objectType , $ objectURI , $ objectId ) -> fetchAll ( ) ; $ items = array ( ) ; foreach ( $ objects as $ i => $ object ) { $ object = $ this -> getOwner ( $ object , $ object [ 'media_owner' ] ) ; if ( $ object [ 'object_type' ] === "attachment" ) : $ object [ 'media_object' ] = $ object [ 'object_uri' ] ; if ( empty ( $ object [ 'media_title' ] ) ) : $ object [ 'media_title' ] = $ object [ 'attachment_name' ] ; endif ; endif ; $ object [ 'media_comment_target' ] = $ object [ 'object_uri' ] ; $ object [ 'media_published' ] = $ object [ 'object_created_on' ] ; $ items [ ] = $ object ; } $ mediacollections = new Collection ( ) ; $ mediacollections :: set ( "items" , $ items ) ; $ mediacollections :: set ( "totalItems" , count ( $ items ) ) ; $ collection = $ mediacollections :: getArray ( ) ; return $ collection ; }
4561	public function transfer ( Translatable $ model ) { $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ get = 'get' . $ property -> getName ( ) ; $ set = 'set' . $ property -> getName ( ) ; $ values = $ model -> $ get ( ) ; if ( null !== $ values ) { foreach ( $ values as $ locale => $ value ) { $ model -> translate ( $ locale , false ) -> $ set ( $ value ) ; } } } $ model -> mergeNewTranslations ( ) ; }
4121	public function getProxy ( $ className , $ identifier ) { $ fqn = ClassUtils :: generateProxyClassName ( $ className , $ this -> proxyNamespace ) ; if ( ! class_exists ( $ fqn , false ) ) { $ fileName = $ this -> getProxyFileName ( $ className ) ; if ( $ this -> autoGenerate ) { $ this -> generateProxyClass ( $ this -> dm -> getClassMetadata ( $ className ) , $ fileName , self :: $ proxyClassTemplate ) ; } require $ fileName ; } if ( ! $ this -> dm -> getMetadataFactory ( ) -> hasMetadataFor ( $ fqn ) ) { $ this -> dm -> getMetadataFactory ( ) -> setMetadataFor ( $ fqn , $ this -> dm -> getClassMetadata ( $ className ) ) ; } return new $ fqn ( $ this -> dm , $ identifier ) ; }
10921	public function setHeaders ( array $ headers ) { $ columnNumber = 0 ; foreach ( $ headers as $ header ) { $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ header ) ) ; if ( ! in_array ( $ header , $ this -> headers ) ) { $ this -> headers [ ] = $ header ; } $ columnNumber ++ ; } }
12419	static function run_php_pdepend_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ pdepend = self :: getTool ( 'pdepend' , $ opts , true ) ; pake_mkdirs ( $ destdir ) ; $ out = pake_sh ( $ pdepend . " --jdepend-chart=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/jdependchart.svg' ) . " --overview-pyramid=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/overview-pyramid.svg' ) . " --summary-xml=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/summary.xml' ) . " " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
4134	public static function encryptAndAppendTag ( $ K , $ IV , $ P = null , $ A = null , $ tag_length = 128 ) { return implode ( self :: encrypt ( $ K , $ IV , $ P , $ A , $ tag_length ) ) ; }
2886	public function onActionPreDispatch ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ action = $ observer -> getData ( 'controller_action' ) ; $ this -> getRequestInfo ( ) -> initController ( $ action ) ; }
4146	protected function getUrl ( ) { $ domain = $ this -> urls [ 'domain' ] ; $ apiVersion = $ this -> urls [ 'api' ] ; $ jsonExt = '.json' ; if ( isset ( $ this -> withMedia ) && $ this -> withMedia === true ) { $ domain = $ this -> urls [ 'upload' ] ; } if ( $ this -> call === 'oauth/request_token' || $ this -> call === 'oauth/access_token' ) { $ apiVersion = '' ; $ jsonExt = '' ; } return $ domain . $ apiVersion . $ this -> call . $ jsonExt ; }
6066	public function listSocialMedia ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/socialmedia/sites' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new SocialMedia ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
2231	protected function hasUser ( ) : bool { $ user = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ user ) { return false ; } return ! ( $ user instanceof AnonymousToken ) ; }
11185	public function addMatch ( string $ method , string $ uri , $ next ) { $ method = strtoupper ( $ method ) ; if ( ! in_array ( $ method , $ this -> supported_methods ) ) { throw new Exception ( "Method " . $ method . " is not supported." ) ; } if ( ! is_string ( $ uri ) ) { throw new Exception ( "Uri " . $ uri . " is not valid." ) ; } if ( is_callable ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => true , $ this -> ARRAY_CALLABLE_KEY => $ next ) ; } elseif ( is_string ( $ next ) ) { if ( file_exists ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ next ) ; } else { $ dir_next = __DIR__ . "/" . $ next ; if ( file_exists ( $ dir_next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ dir_next ) ; } else { throw new Exception ( "File " . $ next . " not found." ) ; } } } else { throw new Exception ( "Invalid third parameter. Expecting callable or file." ) ; } array_push ( $ this -> match_list , $ new_match ) ; }
6163	public function getMemUsage ( $ realmem = false ) { if ( $ this -> isRunning ( ) ) { $ this -> stop ( ) ; $ this -> start ( ) ; } return ( $ realmem !== false ) ? $ this -> data [ "realmem" ] : $ this -> data [ "emalloc" ] ; }
7778	protected function extractInput ( array $ data ) { $ input = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ input [ $ field ] = $ fieldData [ 0 ] ; } return $ input ; }
5636	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; print $ this -> getFailCount ( ) . ") $message\n" ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print "\tin " . implode ( "\n\tin " , array_reverse ( $ breadcrumb ) ) ; print "\n" ; }
11824	public function detect ( ) { $ str = file_get_contents ( $ this -> uri ) ; foreach ( $ this -> getBom ( 'all' ) as $ encoding => $ bom ) { if ( 0 === strncmp ( $ str , $ bom , strlen ( $ bom ) ) ) { return $ encoding ; } } }
618	private function parseString ( $ value , & $ i ) { $ isQuoted = $ value [ $ i ] === '"' ; $ stringEndChars = $ isQuoted ? [ '"' ] : [ $ this -> delimiter , '}' ] ; $ result = '' ; $ len = strlen ( $ value ) ; for ( $ i += $ isQuoted ? 1 : 0 ; $ i < $ len ; ++ $ i ) { if ( in_array ( $ value [ $ i ] , [ '\\' , '"' ] , true ) && in_array ( $ value [ $ i + 1 ] , [ $ value [ $ i ] , '"' ] , true ) ) { ++ $ i ; } elseif ( in_array ( $ value [ $ i ] , $ stringEndChars , true ) ) { break ; } $ result .= $ value [ $ i ] ; } $ i -= $ isQuoted ? 0 : 1 ; if ( ! $ isQuoted && $ result === 'NULL' ) { $ result = null ; } return $ result ; }
12459	public function indexAction ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ cfGroups = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> findAll ( ) ; $ defaultGroups = $ this -> getDefaultGroupsId ( ) ; $ makeDefaultFormViews = array ( ) ; foreach ( $ cfGroups as $ group ) { if ( ! in_array ( $ group -> getId ( ) , $ defaultGroups ) ) { $ makeDefaultFormViews [ $ group -> getId ( ) ] = $ this -> createMakeDefaultForm ( $ group ) -> createView ( ) ; } } return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:index.html.twig' , array ( 'entities' => $ cfGroups , 'default_groups' => $ defaultGroups , 'make_default_forms' => $ makeDefaultFormViews ) ) ; }
4620	public function buildObject ( $ data = NULL , $ headers = NULL ) { $ this -> object = new RObject ( $ data , $ headers ) ; return $ this ; }
11140	protected function joinStringFromArray ( $ dataMember , $ sep = ' AND ' ) { if ( empty ( $ this -> $ dataMember ) ) { return 0 ; } $ count = count ( $ this -> $ dataMember ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ statement = $ this -> { $ dataMember } [ $ i ] ; $ this -> query .= ' ' . $ statement [ 2 ] . ' JOIN ' . $ statement [ 0 ] . ' ON ' ; $ sCount = count ( $ statement [ 1 ] ) ; for ( $ j = 0 ; $ j < $ sCount ; $ j ++ ) { $ this -> query .= $ this -> getArrayJoin ( $ dataMember , $ i , $ j ) ; if ( $ sCount - 1 != $ j ) { $ this -> query .= $ sep ; } } } }
9771	function most ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , lessThanOrEqual ( $ value ) ) ; }
2441	public static function urlDecode ( string $ data ) : self { $ decoded = base64_decode ( strtr ( $ data , '-_,' , '+/=' ) , true ) ; if ( \ function_exists ( 'gzdecode' ) && false !== ( $ uncompressed = @ gzdecode ( $ decoded ) ) ) { $ decoded = $ uncompressed ; } $ json = @ json_decode ( $ decoded , true ) ; if ( null === $ json ) { throw new \ InvalidArgumentException ( 'Invalid JSON data' ) ; } return new self ( $ json [ 'context' ] , $ json [ 'extras' ] , $ json [ 'value' ] , $ json [ 'current' ] ) ; }
8811	public function header ( $ key , $ value ) { if ( is_array ( $ key ) && ! empty ( $ key ) ) { foreach ( $ key as $ k => $ v ) { $ this -> headers -> set ( $ k , $ v ) ; } } elseif ( is_string ( $ key ) && ! empty ( $ key ) ) { $ this -> headers -> set ( $ key , $ value ) ; } return $ this ; }
10874	public function getEncodeHash ( int $ id , string $ slug , string $ linkValidate = null ) : string { return base64_encode ( uniqid ( ( $ linkValidate ? strtotime ( $ linkValidate ) : self :: NO_TIME ) . self :: TIME_SEPARATOR , true ) . self :: PART_SEPARATOR . $ this -> getHash ( $ id . $ slug ) . self :: ID_SEPARATOR . $ id ) ; }
3366	private static function apache_modules ( ) { $ mods = WP_CLI :: get_config ( 'apache_modules' ) ; if ( ! empty ( $ mods ) && ! function_exists ( 'apache_get_modules' ) ) { global $ is_apache ; $ is_apache = true ; $ _SERVER [ 'SCRIPT_FILENAME' ] = ABSPATH ; function apache_get_modules ( ) { return WP_CLI :: get_config ( 'apache_modules' ) ; } } }
9804	public function setModified ( $ time ) { if ( $ time === null ) { $ time = time ( ) ; } elseif ( is_string ( $ time ) ) { if ( is_numeric ( $ time ) ) { $ time = ( int ) $ time ; } else { $ time = strtotime ( $ time ) ; } } $ this -> modified = $ time ; return $ this ; }
8131	protected function removeNodeFilter ( Twig_Node $ node ) { if ( $ node instanceof Twig_Node_Expression_Filter ) { return $ this -> removeNodeFilter ( $ node -> getNode ( 'node' ) ) ; } return $ node ; }
3302	public function json ( $ url , $ options = [ ] , $ encodeOption = JSON_UNESCAPED_UNICODE , $ queries = [ ] ) { is_array ( $ options ) && $ options = json_encode ( $ options , $ encodeOption ) ; return $ this -> setHeaders ( [ 'content-type' => 'application/json' ] ) -> request ( 'POST' , $ url , [ 'query' => $ queries , 'body' => $ options ] ) ; }
28	public static function register ( IOInterface $ io = null ) { set_error_handler ( array ( __CLASS__ , 'handle' ) ) ; error_reporting ( E_ALL | E_STRICT ) ; self :: $ io = $ io ; }
4560	public function translate ( Translatable $ model ) { $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ get = 'get' . $ property -> getName ( ) ; $ set = 'set' . $ property -> getName ( ) ; $ values = [ ] ; foreach ( $ model -> getTranslations ( ) as $ translation ) { $ values [ $ translation -> getLocale ( ) ] = $ translation -> $ get ( ) ; } $ model -> $ set ( $ values ) ; } }
5569	public function delete ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } return $ this -> load ( $ url , new SimpleDeleteEncoding ( $ parameters ) ) ; }
4891	protected function getTarget ( $ generateInstance = true ) { $ serviceLocator = $ this -> getServicelocator ( ) ; $ this -> getGenerator ( ) ; $ target = null ; if ( array_key_exists ( 'target' , $ this -> options ) ) { $ target = $ this -> options [ 'target' ] ; if ( is_string ( $ target ) ) { if ( $ serviceLocator -> has ( $ target ) ) { $ target = $ serviceLocator -> get ( $ target ) ; if ( $ generateInstance ) { $ target = get_class ( $ target ) ; } } else { if ( $ generateInstance ) { $ target = new $ target ; } } } } return $ target ; }
10493	public function mul ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value * $ value ) ; }
1805	public function getActiveGroups ( ) { $ arrGroups = array ( ) ; $ objGroup = Contao \ MemberGroupModel :: findAllActive ( ) ; if ( $ objGroup !== null ) { while ( $ objGroup -> next ( ) ) { $ arrGroups [ $ objGroup -> id ] = $ objGroup -> name ; } } return $ arrGroups ; }
2516	public function pnrCreatePnr ( RequestOptions \ PnrCreatePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
11272	protected function handleResponseContent ( ResponseInterface $ response , $ contentType = null ) { $ contents = $ response -> getBody ( ) -> getContents ( ) ; if ( ! $ contentType ) { $ contentTypeHeaderLine = $ response -> getHeaderLine ( 'Content-Type' ) ; if ( stripos ( $ contentTypeHeaderLine , 'application/json' ) !== false ) { $ contentType = 'json' ; } elseif ( stripos ( $ contentTypeHeaderLine , 'application/xml' ) !== false ) { $ contentType = 'xml' ; } } if ( $ contentType ) { return Parser :: data ( $ contents ) -> from ( $ contentType ) -> toArray ( ) ; } return $ contents ; }
3675	private function collectAttributeFactories ( $ container ) { $ attributeFactory = $ container -> getDefinition ( 'metamodels.attribute_factory' ) ; foreach ( array_keys ( $ container -> findTaggedServiceIds ( self :: TAG_ATTRIBUTE_FACTORY ) ) as $ factory ) { $ attributeFactory -> addMethodCall ( 'addTypeFactory' , [ new Reference ( $ factory ) ] ) ; } }
2386	public function removeField ( $ name , string $ legend = null ) : self { $ this -> removes [ ] = [ 'fields' => ( array ) $ name , 'parents' => ( array ) $ legend , ] ; return $ this ; }
2209	public function fetchRow ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = array_values ( $ this -> resultSet [ ++ $ this -> intIndex ] ) ; return $ this -> arrCache ; }
12649	public function build ( ) { $ assetManager = new AssetManager ( ) ; $ filterManager = new FilterManager ( ) ; foreach ( $ this -> filters as $ filterName => $ filter ) { $ filterManager -> set ( $ filterName , $ filter ) ; } $ assetsFactory = new AssetFactory ( $ this -> configurationHandler -> webDir ( ) ) ; $ assetsFactory -> setAssetManager ( $ assetManager ) ; $ assetsFactory -> setFilterManager ( $ filterManager ) ; return $ assetsFactory ; }
8537	public function setRentalFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7506	function setDoc ( $ doc , $ pos = 0 ) { $ this -> doc = $ doc ; $ this -> size = strlen ( $ doc ) ; $ this -> setPos ( $ pos ) ; }
12527	public function getDataSources ( ) { if ( is_null ( $ this -> _dataSources ) ) { $ this -> _dataSources = [ ] ; foreach ( $ this -> dataSources ( ) as $ foreignModel => $ dataSource ) { if ( is_numeric ( $ foreignModel ) || isset ( $ dataSources [ 'foreignModel' ] ) ) { if ( ! isset ( $ dataSources [ 'foreignModel' ] ) ) { continue ; } $ foreignModel = $ dataSources [ 'foreignModel' ] ; unset ( $ dataSources [ 'foreignModel' ] ) ; } if ( ! isset ( $ dataSource [ 'class' ] ) ) { $ dataSource [ 'class' ] = $ this -> dataSourceClass ; } $ dataSource [ 'name' ] = $ foreignModel ; $ dataSource [ 'foreignModel' ] = $ this -> getForeignModel ( $ foreignModel ) ; if ( empty ( $ dataSource [ 'foreignModel' ] ) ) { continue ; } $ this -> _dataSources [ $ foreignModel ] = Yii :: createObject ( array_merge ( [ 'module' => $ this ] , $ dataSource ) ) ; } } return $ this -> _dataSources ; }
7843	private function callIfExists ( $ method , array $ parameters = [ ] ) { if ( method_exists ( $ this , $ method ) ) { $ this -> container -> call ( [ $ this , $ method ] , $ parameters ) ; } }
2523	protected function makeMessageOptions ( array $ incoming , $ endSession = false ) { $ options = [ 'endSession' => $ endSession , 'returnXml' => $ this -> returnResultXml ] ; if ( array_key_exists ( 'endSession' , $ incoming ) ) { $ options [ 'endSession' ] = $ incoming [ 'endSession' ] ; } if ( array_key_exists ( 'returnXml' , $ incoming ) ) { $ options [ 'returnXml' ] = $ incoming [ 'returnXml' ] ; } return $ options ; }
558	protected function buildBlockCondition ( $ operator , $ condition ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } return [ $ operator , $ this -> buildCondition ( $ condition ) , ] ; }
12240	public function getElementsByClassName ( $ class ) { if ( strpos ( $ class , '"' ) !== false || strpos ( $ class , "'" ) !== false ) { return array ( ) ; } $ xpath = './/*[contains(concat(" ", @class, " "), " ' . htmlspecialchars ( $ class ) . ' ")]' ; return $ this -> xpath ( $ xpath ) ; }
4929	public function attach ( EventManagerInterface $ events , $ priority = 1 ) { foreach ( $ this -> listenerSpecs as $ name => $ spec ) { $ this -> listeners [ ] = $ events -> attach ( $ spec [ 'event' ] , array ( $ this , "do$name" ) , $ spec [ 'priority' ] ) ; } }
12506	public static function sendQuery ( ConnectionInterface $ connection ) { $ response = DataLayer :: execute ( $ connection ) ; $ connection -> resetSelf ( ) ; return $ response ; }
9283	private function needsCompilation ( $ lessPath , $ cssPath ) { $ isNewer = function ( $ subject , $ reference ) { return filemtime ( $ subject ) > filemtime ( $ reference ) ; } ; if ( $ this -> forceCompile || ! file_exists ( $ lessPath ) || ! file_exists ( $ cssPath ) || $ isNewer ( $ lessPath , $ cssPath ) ) { return true ; } return $ this -> checkImports ( $ lessPath , $ cssPath , $ isNewer ) ; }
11058	protected function _getDataStore ( ) { return $ this -> dataStore === null ? $ this -> dataStore = $ this -> _createDataStore ( ) : $ this -> dataStore ; }
11632	private function groupPvTrans ( $ transData ) { $ result = [ ] ; foreach ( $ transData as $ one ) { $ debitAccId = $ one -> get ( DTrans :: A_ACC_ID_DEBIT ) ; $ creditAccId = $ one -> get ( DTrans :: A_ACC_ID_CREDIT ) ; $ value = $ one -> get ( DTrans :: A_AMOUNT ) ; if ( isset ( $ result [ $ debitAccId ] ) ) { $ result [ $ debitAccId ] -= $ value ; } else { $ result [ $ debitAccId ] = - $ value ; } if ( isset ( $ result [ $ creditAccId ] ) ) { $ result [ $ creditAccId ] += $ value ; } else { $ result [ $ creditAccId ] = $ value ; } } return $ result ; }
11973	private function genericParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( count ( $ params ) >= 1 && count ( $ params ) <= 2 ) ; }
9690	public function render ( $ file , $ env = array ( ) ) { $ file = $ this -> views_path . '/' . $ file ; if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } $ cacheHash = md5 ( $ file . serialize ( $ env ) ) ; $ cache_file = $ this -> views_cache . "/$cacheHash.cache" ; if ( ! $ this -> debug && ( file_exists ( $ cache_file ) && filemtime ( $ cache_file ) > filemtime ( $ file ) ) ) { return file_get_contents ( $ cache_file ) ; } $ this -> currFile = $ file ; $ hash = md5 ( $ file ) ; $ this -> compile ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; set_error_handler ( array ( $ this , 'onTemplateError' ) ) ; require_once ( $ compiled_file ) ; $ output = call_user_func ( 'katar_' . $ hash , $ env ) ; restore_error_handler ( ) ; file_put_contents ( $ cache_file , $ output ) ; return $ output ; }
6421	public static function ands ( callable ... $ predicates ) : callable { return function ( $ element ) use ( $ predicates ) { foreach ( $ predicates as $ predicate ) { if ( ! self :: call ( $ predicate , $ element ) ) { return false ; } } return true ; } ; }
6452	public function findLabels ( $ text ) { $ xpath = new XPath \ InaccurateText ( '//label[@for]' , $ this -> getWorkingElement ( ) ) ; $ labels = [ ] ; foreach ( $ xpath -> text ( $ text ) -> findAll ( ) as $ label ) { $ labels [ $ label -> getAttribute ( 'for' ) ] = $ label ; } return $ labels ; }
10621	public static function percentage ( $ value , $ from ) { $ value = floatval ( $ value ) ; $ from = floatval ( $ from ) ; return floatval ( $ value / $ from * 100 ) ; }
7361	protected function updateWeightTotal ( SaleInterface $ sale ) { $ weightTotal = $ this -> weightCalculator -> calculateSale ( $ sale ) ; if ( $ sale -> getWeightTotal ( ) != $ weightTotal ) { $ sale -> setWeightTotal ( $ weightTotal ) ; return true ; } return false ; }
8646	private function getDefaultCurlOptions ( ) { return array ( CURLOPT_POST => true , CURLOPT_USERAGENT => $ this -> config [ 'UserAgent' ] , CURLOPT_VERBOSE => false , CURLOPT_HEADERFUNCTION => array ( $ this , 'headerCallback' ) , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_SSL_VERIFYHOST => 2 ) ; }
7756	public function setPropertyValue ( $ entity , $ property , $ value ) { $ this -> reflFields [ $ property ] -> setValue ( $ entity , $ value ) ; }
11381	public function render ( FormInterface $ form ) { if ( method_exists ( $ form , 'prepare' ) ) { $ form -> prepare ( ) ; } if ( ! $ form -> getAttribute ( 'role' ) ) { $ form -> setAttribute ( 'role' , 'form' ) ; } $ formContent = '' ; foreach ( $ form as $ element ) { if ( $ element instanceof FieldsetInterface ) { $ formContent .= $ this -> getView ( ) -> formCollection ( $ element ) ; } else { $ element -> setOption ( '_form' , $ form ) ; $ formContent .= $ this -> getView ( ) -> formRow ( $ element ) ; } } return $ this -> openTag ( $ form ) . $ formContent . $ this -> closeTag ( ) ; }
8266	public function lock ( $ lockType ) { if ( ! $ this -> isOpened ( ) ) { return false ; } if ( $ this -> options [ "blocking" ] ) { return flock ( $ this -> handle , $ lockType ) ; } else { $ tries = 0 ; do { if ( flock ( $ this -> handle , $ lockType | LOCK_NB ) ) { return true ; } else { ++ $ tries ; usleep ( self :: LOCK_RETRY_WAIT ) ; } } while ( $ tries < self :: LOCK_MAX_TRIES ) ; return false ; } }
12738	public function addClass ( $ name ) { $ classParts = explode ( ' ' , $ this -> tags [ 'class' ] ) ; foreach ( $ classParts as $ part ) { if ( $ name == $ part ) return ; } $ this -> tags [ 'class' ] .= ' ' . $ name ; $ this -> tags [ 'class' ] = trim ( $ this -> tags [ 'class' ] ) ; }
5184	private function lookUp ( array $ articleConstant ) : array { $ copyListAttributes = $ this -> listAttributes ; return array_map ( function ( $ singleConst ) use ( $ copyListAttributes ) { $ res = $ copyListAttributes [ $ singleConst ] ; return array_map ( function ( $ str ) use ( $ singleConst ) { return $ singleConst . $ str ; } , $ res ) ; } , $ articleConstant ) ; }
6753	public static function installWebServer ( ) { $ appPath = __DIR__ . '/../../../..' ; self :: createFolderIfNotExists ( "$appPath/web" ) ; self :: createCopy ( __DIR__ , 'app.php' , "$appPath/web" , 'app.php' ) ; self :: createCopy ( __DIR__ , 'app_dev.php' , "$appPath/web" , 'app_dev.php' ) ; }
3985	private function isActive ( $ route , $ params , Request $ request ) { if ( '/contao' === $ request -> getPathInfo ( ) || ! ( $ request -> attributes -> get ( '_route' ) === $ route ) ) { return false ; } $ attributes = $ request -> attributes -> get ( '_route_params' ) ; $ query = $ request -> query ; foreach ( $ params as $ param => $ value ) { if ( isset ( $ attributes [ $ param ] ) && ( $ value !== $ request -> attributes [ '_route_params' ] [ $ param ] ) ) { return false ; } if ( $ query -> has ( $ param ) && ( $ value !== $ query -> get ( $ param ) ) ) { return false ; } } return true ; }
6961	public static function J ( $ year ) { $ jd = static :: J2000 ( ) -> jd + ( $ year - 2000 ) * static :: DaysJulianYear ; $ epoch = new static ( $ jd ) ; $ epoch -> type = YearType :: Julian ( ) ; return $ epoch ; }
12427	public function getAuthorizerOption ( $ authorizerAppId , $ optionName ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ authorizerAppId , 'option_name' => $ optionName , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_OPTION , $ params ] ) ; }
7902	protected function getFullFileName ( Provider $ provider ) { $ folder = $ this -> folder ? rtrim ( $ this -> folder , '/' ) . '/' : '' ; if ( $ this -> filename ) { $ filename = $ this -> filename ; } else { $ filename = md5 ( uniqid ( microtime ( true ) , true ) ) ; } return $ folder . $ filename . '.' . $ provider -> getExtension ( ) ; }
1309	public static function demoteHtmlHeaderTags ( $ html ) { $ originalHeaderTags = [ ] ; $ demotedHeaderTags = [ ] ; foreach ( range ( 100 , 1 ) as $ index ) { $ originalHeaderTags [ ] = '<h' . $ index . '>' ; $ originalHeaderTags [ ] = '</h' . $ index . '>' ; $ demotedHeaderTags [ ] = '<h' . ( $ index + 1 ) . '>' ; $ demotedHeaderTags [ ] = '</h' . ( $ index + 1 ) . '>' ; } return str_ireplace ( $ originalHeaderTags , $ demotedHeaderTags , $ html ) ; }
2629	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ dictionaryId = $ this -> getRequest ( ) -> getParam ( 'dictionary_id' ) ; $ key = $ this -> getRequest ( ) -> getParam ( 'item_key' ) ; if ( $ key == '' ) { return $ result -> setData ( [ 'status' => true ] ) ; } $ deleteItem = $ this -> api -> deleteDictionaryItem ( $ dictionaryId , $ key ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
918	public static function sortFixers ( array $ fixers ) { return self :: stableSort ( $ fixers , static function ( FixerInterface $ fixer ) { return $ fixer -> getPriority ( ) ; } , static function ( $ a , $ b ) { return self :: cmpInt ( $ b , $ a ) ; } ) ; }
895	private function findComparisonEnd ( Tokens $ tokens , $ index ) { ++ $ index ; $ count = \ count ( $ tokens ) ; while ( $ index < $ count ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { ++ $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { ++ $ index ; continue ; } if ( ! $ block [ 'isStart' ] ) { break ; } $ index = $ tokens -> findBlockEnd ( $ block [ 'type' ] , $ index ) + 1 ; } $ prev = $ tokens -> getPrevMeaningfulToken ( $ index ) ; return $ tokens [ $ prev ] -> isGivenKind ( T_CLOSE_TAG ) ? $ tokens -> getPrevMeaningfulToken ( $ prev ) : $ prev ; }
5777	public function null_eq ( string $ name , $ arg ) { if ( $ arg === null ) { $ this -> sql .= "$name is null" ; } else { $ this -> args [ ] = $ arg ; $ argNum = count ( $ this -> args ) ; $ this -> sql .= "$name = \$$argNum" ; } return $ this ; }
717	public function dateTime ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DATETIME , $ precision ) ; }
5389	public function setValue ( $ value ) { if ( ! $ this -> valueIsPossible ( $ value ) ) { return false ; } $ index = false ; $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( ! $ widgets [ $ i ] -> setValue ( $ value ) ) { $ widgets [ $ i ] -> setValue ( false ) ; } } return true ; }
715	public function double ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DOUBLE , $ precision ) ; }
10436	public function channel ( string $ channel_id ) : LoggerChannelInterface { $ logger = $ this -> log_manager -> get ( $ channel_id ) ; if ( ! $ logger ) { return new NullLoggerChannel ( ) ; } return new CalgamoLoggerChannelAdapter ( $ logger ) ; }
9488	public function getPages ( ) { if ( $ this -> getPageRange ( ) > $ this -> getPagesCount ( ) ) { $ this -> setPageRange ( $ this -> getPagesCount ( ) ) ; } $ delta = ceil ( $ this -> getPageRange ( ) / 2 ) ; if ( $ this -> getCurrentPageNumber ( ) - $ delta > $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) ) { $ pages = range ( $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) + 1 , $ this -> getPagesCount ( ) ) ; } else { if ( $ this -> getCurrentPageNumber ( ) - $ delta < 0 ) { $ delta = $ this -> getCurrentPageNumber ( ) ; } $ offset = $ this -> getCurrentPageNumber ( ) - $ delta ; $ pages = range ( $ offset + 1 , $ offset + $ this -> getPageRange ( ) ) ; } return $ pages ; }
7232	public static function createFromCurrency ( $ currency , $ code = 0 , \ Exception $ prev = null ) { $ message = sprintf ( 'Not found prices by currency "%s".' , $ currency ) ; return new static ( $ message , $ code , $ prev ) ; }
5326	public function begin ( string $ profile ) { Craft :: beginProfile ( $ profile , Craft :: t ( 'twig-profiler' , self :: CATEGORY_PREFIX ) . TwigProfiler :: $ renderingTemplate ) ; }
6417	public static function size ( IteratorAggregate $ iterable ) : int { if ( $ iterable instanceof Countable ) { return $ iterable -> count ( ) ; } return Iterators :: size ( Iterators :: from ( $ iterable -> getIterator ( ) ) ) ; }
12771	public function authorizeWithEmail ( $ hashedEmail , $ hashedPassword , $ remember = null , & $ user = null ) { $ result = new EmailStatus ( 0 ) ; if ( dbQuery ( $ this -> dbTable ) -> where ( $ this -> dbHashEmailField , $ hashedEmail ) -> first ( $ user ) ) { $ dbTable = $ this -> dbTable ; $ hashPasswordField = $ dbTable :: $ _attributes [ $ this -> dbHashPasswordField ] ; if ( $ user [ $ hashPasswordField ] === $ hashedPassword ) { $ result = new EmailStatus ( EmailStatus :: SUCCESS_EMAIL_AUTHORIZE ) ; $ this -> authorize ( $ user , $ remember ) ; } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_WRONGPWD ) ; } } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_NOTFOUND ) ; } if ( is_callable ( $ this -> authorizeHandler ) ) { if ( ! call_user_func_array ( $ this -> authorizeHandler , array ( & $ user , & $ result ) ) ) { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_HANDLER ) ; } } return $ result ; }
6057	public function removeMediaFromFolder ( $ folderId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/folders/' . $ folderId . '/media/' . $ mediaId . '' , $ parameters ) ; return $ result ; }
5948	protected function waitForReadyRead ( $ time = 0 ) { if ( ! $ this -> isConnected ( ) || $ this -> config [ "blocking" ] ) { return ; } do { $ read = array ( $ this -> stream ) ; $ null = null ; if ( $ time ) { Signal :: getInstance ( ) -> emit ( strtolower ( $ this -> getAdapterType ( ) ) . "WaitTimeout" , $ time , $ this -> getAdapter ( ) ) ; } $ time = $ time + $ this -> config [ "timeout" ] ; } while ( @ stream_select ( $ read , $ null , $ null , $ this -> config [ "timeout" ] ) == 0 ) ; }
11064	public function upperFirst ( ) { $ this -> value = mb_strtoupper ( mb_substr ( $ this -> value , 0 , 1 , 'UTF-8' ) , 'UTF-8' ) . mb_substr ( $ this -> value , 1 , null , 'UTF-8' ) ; return $ this ; }
2602	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionaryName = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , $ dictionaryName ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || $ dictionary == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } else { return $ result -> setData ( [ 'status' => true ] ) ; } } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11370	public static function charAscii ( $ char ) { if ( self :: isAscii ( $ char ) ) { return $ char ; } $ char = htmlentities ( $ char ) ; return $ char ; }
2457	public function deleteChilds ( $ table , $ id , & $ delete ) { $ cctable = array ( ) ; $ ctable = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'ctable' ] ; if ( ! \ is_array ( $ ctable ) ) { return ; } foreach ( $ ctable as $ v ) { $ this -> loadDataContainer ( $ v ) ; $ cctable [ $ v ] = $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'ctable' ] ; if ( $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'dynamicPtable' ] ) { $ ptable = $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'ptable' ] ; $ cond = ( $ ptable == 'tl_article' ) ? "(ptable=? OR ptable='')" : "ptable=?" ; $ objDelete = $ this -> Database -> prepare ( "SELECT id FROM $v WHERE pid=? AND $cond" ) -> execute ( $ id , $ ptable ) ; } else { $ objDelete = $ this -> Database -> prepare ( "SELECT id FROM $v WHERE pid=?" ) -> execute ( $ id ) ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'doNotDeleteRecords' ] && \ strlen ( $ v ) && $ objDelete -> numRows ) { foreach ( $ objDelete -> fetchAllAssoc ( ) as $ row ) { $ delete [ $ v ] [ ] = $ row [ 'id' ] ; if ( ! empty ( $ cctable [ $ v ] ) ) { $ this -> deleteChilds ( $ v , $ row [ 'id' ] , $ delete ) ; } } } } }
8418	public static function registerDatabase ( string $ alias ) { if ( isset ( self :: $ databases [ $ alias ] ) === false ) { self :: $ databases [ $ alias ] = new static ( $ alias ) ; } }
10323	private function createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source , $ embedFieldBackups ) { $ queryParameters = array ( 'page_index' => $ pageIndex , 'page_size' => $ pageSize ) ; if ( isset ( $ fromDate ) ) $ queryParameters [ 'from_date' ] = $ fromDate ; if ( isset ( $ toDate ) ) $ queryParameters [ 'to_date' ] = $ toDate ; if ( isset ( $ source ) ) $ queryParameters [ 'source' ] = $ source ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "ids" , $ contactIds ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "emails" , $ contactEmails ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "eids" , $ contactExternalIds ) ; if ( isset ( $ embedFieldBackups ) ) $ queryParameters [ 'embed_field_backups' ] = ( $ embedFieldBackups == true ) ? "true" : "false" ; if ( isset ( $ mailingIds ) ) { $ queryParameters [ 'mailing_id' ] = array ( ) ; foreach ( $ mailingIds as $ mailingId ) { $ queryParameters [ 'mailing_id' ] [ ] = $ mailingId ; } } return $ queryParameters ; }
9602	public function dotProduct ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; $ bComponents = $ b -> components ( ) ; $ product = 0 ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ product += $ component * $ bComponents [ $ i ] ; } return $ product ; }
3485	public static function resolve ( ) : SignatureGeneratorInterface { self :: addDefaultResolvers ( ) ; foreach ( self :: $ resolvers as $ resolver ) { if ( $ generator = $ resolver ( ) ) { return $ generator ; } } throw new \ LogicException ( 'Cannot resolve available JWT Signature Generator.' ) ; }
5375	protected function createInputTag ( $ attributes ) { if ( ! isset ( $ attributes [ 'type' ] ) ) { return new SimpleTextTag ( $ attributes ) ; } $ type = strtolower ( trim ( $ attributes [ 'type' ] ) ) ; $ map = array ( 'submit' => 'SimpleSubmitTag' , 'image' => 'SimpleImageSubmitTag' , 'checkbox' => 'SimpleCheckboxTag' , 'radio' => 'SimpleRadioButtonTag' , 'text' => 'SimpleTextTag' , 'hidden' => 'SimpleTextTag' , 'password' => 'SimpleTextTag' , 'file' => 'SimpleUploadTag' ) ; if ( array_key_exists ( $ type , $ map ) ) { $ tag_class = $ map [ $ type ] ; return new $ tag_class ( $ attributes ) ; } return false ; }
12284	public function head ( ) : string { $ property = static :: HEAD_ASSETS_NAME . static :: BLOCK_PROPERTY_SUFFIX ; return isset ( $ this -> $ property ) ? trim ( $ this -> make ( static :: HEAD_ASSETS_NAME ) ) . PHP_EOL : PHP_EOL ; }
8786	public function generate ( ) { foreach ( $ this -> commandList as $ key => $ value ) { $ this -> app -> add ( new $ value ) ; } foreach ( $ this -> migrationCommands as $ command ) { $ newCommand = new $ command ; $ newCommand -> setName ( "migration:" . $ newCommand -> getName ( ) ) ; $ this -> app -> add ( $ newCommand ) ; } }
9838	public function createSymmetricAuthenticatedJsonResponse ( int $ status , array $ arrayToJsonify , SharedAuthenticationKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricAuthenticatedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
7527	private function nest ( $ x , $ node , $ end = false ) { array_push ( $ x -> stmtStack , $ node ) ; $ n = $ this -> statement ( $ x ) ; array_pop ( $ x -> stmtStack ) ; if ( $ end ) $ this -> t -> mustMatch ( $ end ) ; return $ n ; }
9760	function containOnly ( string $ type ) : self { return $ this -> expect ( $ this -> target , containsOnly ( $ type ) ) ; }
8022	public function addField ( $ title , $ value , $ short = false ) { $ this -> fields [ ] = [ 'title' => $ title , 'value' => $ value , 'short' => $ short ] ; }
6247	public function dirs ( ? int $ constraints = null ) : \ Generator { foreach ( $ this -> all ( $ constraints ) as $ directory ) { if ( $ directory -> isDir ( ) ) { yield $ directory ; } } }
3559	protected function mutateValue ( $ value , $ dir = 'setter' ) { $ mutator = $ this -> getMutator ( $ value , $ dir , $ this -> attributes [ 'meta_type' ] ) ; if ( method_exists ( $ this , $ mutator ) ) { return $ this -> { $ mutator } ( $ value ) ; } return static :: $ attributeMutator -> mutate ( $ value , $ mutator ) ; }
4357	protected function processLog ( ) { $ str = '' ; foreach ( $ this -> data [ 'log' ] as $ entry ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; if ( $ this -> channelTest ( $ channel ) ) { $ str .= $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } } return $ str ; }
570	public function validateData ( $ data , $ key , $ rawHash = false ) { $ test = @ hash_hmac ( $ this -> macHash , '' , '' , $ rawHash ) ; if ( ! $ test ) { throw new InvalidConfigException ( 'Failed to generate HMAC with hash algorithm: ' . $ this -> macHash ) ; } $ hashLength = StringHelper :: byteLength ( $ test ) ; if ( StringHelper :: byteLength ( $ data ) >= $ hashLength ) { $ hash = StringHelper :: byteSubstr ( $ data , 0 , $ hashLength ) ; $ pureData = StringHelper :: byteSubstr ( $ data , $ hashLength , null ) ; $ calculatedHash = hash_hmac ( $ this -> macHash , $ pureData , $ key , $ rawHash ) ; if ( $ this -> compareString ( $ hash , $ calculatedHash ) ) { return $ pureData ; } } return false ; }
9285	protected function compileFile ( $ lessPath , $ cssPath ) { $ options = array ( ) ; if ( $ this -> strictImports === true ) $ options [ ] = '--strict-imports' ; if ( $ this -> compression === self :: COMPRESSION_WHITESPACE ) $ options [ ] = '--compress' ; else if ( $ this -> compression === self :: COMPRESSION_YUI ) $ options [ ] = '--yui-compress' ; if ( $ this -> optimizationLevel !== false ) $ options [ ] = '-O' . $ this -> optimizationLevel ; if ( isset ( $ this -> rootPath ) ) $ options [ ] = '--rootpath ' . $ this -> rootPath ; if ( $ this -> relativeUrls === true ) $ options [ ] = '--relative-urls' ; $ nodePath = $ this -> nodePath ? '"' . $ this -> nodePath . '" ' : '' ; $ command = $ nodePath . '"' . $ this -> compilerPath . '" ' . implode ( ' ' , $ options ) . ' "' . $ lessPath . '" "' . $ cssPath . '" 2>&1' ; $ return = 0 ; $ output = array ( ) ; @ exec ( $ command , $ output , $ return ) ; switch ( $ return ) { case 2 : case 1 : $ output = preg_replace ( '/\[[0-9]+m/i' , '' , implode ( "\n" , $ output ) ) ; throw new CException ( 'Failed to compile file "' . $ lessPath . '" using command: ' . $ command . '. The error was: ' . $ output ) ; } }
9222	public function serialize ( ) { $ this -> requestAllPages ( ) ; return serialize ( array ( 'page' => $ this -> page , 'key' => $ this -> key , 'data' => $ this -> data ) ) ; }
7086	public function setOptionLabelColumnForDefaultOptionsLoader ( $ columnNameOrClosure ) { if ( ! is_string ( $ columnNameOrClosure ) && ! ( $ columnNameOrClosure instanceof DbExpr ) && ! ( $ columnNameOrClosure instanceof \ Closure ) ) { throw new \ InvalidArgumentException ( '$columnNameOrClosure argument must be a string, DbExpr or a Closure' ) ; } $ this -> optionLabelColumnForDefaultOptionsLoader = $ columnNameOrClosure ; return $ this ; }
9124	private function appendPayloadToRequest ( MemoryStream $ ms ) : MemoryStream { $ this -> payload -> reset ( ) ; while ( $ this -> payload -> ready ( ) ) { $ ms -> write ( $ this -> payload -> read ( 1024 ) ) ; } $ ms -> reset ( ) ; return $ ms ; }
7659	function AddrAppend ( $ type , $ addr ) { $ addr_str = $ type . ": " ; $ addr_str .= $ this -> AddrFormat ( $ addr [ 0 ] ) ; if ( count ( $ addr ) > 1 ) { for ( $ i = 1 ; $ i < count ( $ addr ) ; $ i ++ ) $ addr_str .= ", " . $ this -> AddrFormat ( $ addr [ $ i ] ) ; } $ addr_str .= $ this -> LE ; return $ addr_str ; }
7705	function _GetAttValPos ( $ Att ) { if ( $ this -> pST_Src === false ) $ this -> pST_Src = substr ( $ this -> Txt , $ this -> PosBeg , $ this -> pST_PosEnd - $ this -> PosBeg + 1 ) ; $ a = ' ' . $ Att . '="' ; $ p0 = strpos ( $ this -> pST_Src , $ a ) ; if ( $ p0 !== false ) { $ p1 = $ p0 + strlen ( $ a ) ; $ p2 = strpos ( $ this -> pST_Src , '"' , $ p1 ) ; if ( $ p2 !== false ) return array ( $ p1 , $ p2 - $ p1 , $ p0 , $ p2 - $ p0 + 1 ) ; } return false ; }
585	protected function loadBundles ( $ bundles ) { $ this -> stdout ( "Collecting source bundles information...\n" ) ; $ am = $ this -> getAssetManager ( ) ; $ result = [ ] ; foreach ( $ bundles as $ name ) { $ result [ $ name ] = $ am -> getBundle ( $ name ) ; } foreach ( $ result as $ bundle ) { $ this -> loadDependency ( $ bundle , $ result ) ; } return $ result ; }
8385	public function groupBy ( $ groupBy ) { if ( is_array ( $ groupBy ) === true ) { $ this -> groupBy = implode ( ', ' , $ groupBy ) ; } else { $ this -> groupBy = $ groupBy ; } return $ this ; }
7837	public function register ( ) { $ className = studly_case ( strtolower ( config ( 'message.vendor' , 'smsgatewayme' ) ) ) ; $ classPath = '\Yugo\SMSGateway\Vendors\\' . $ className ; if ( ! class_exists ( $ classPath ) ) { abort ( 500 , sprintf ( 'SMS vendor %s is not available.' , $ className ) ) ; } app ( ) -> bind ( SMS :: class , $ classPath ) ; }
2631	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ read -> getRelativePath ( 'vcl_snippets_custom' ) ; $ customSnippets = $ read -> read ( $ snippetPath ) ; if ( ! $ customSnippets ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'No snippets found.' ] ) ; } $ snippets = [ ] ; foreach ( $ customSnippets as $ snippet ) { $ snippets [ ] = explode ( '/' , $ snippet ) [ 1 ] ; } return $ result -> setData ( [ 'status' => true , 'snippets' => $ snippets ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4623	public function execute ( Command $ command ) { $ response = $ this -> getActiveNode ( ) -> execute ( $ command , $ this -> api ) ; if ( empty ( $ response ) && count ( $ this -> nodes ) > 1 && $ this -> attempts < $ this -> getConfigValue ( 'max_connect_attempts' ) ) { $ response = $ this -> pickNewNode ( ) -> execute ( $ command ) ; } elseif ( empty ( $ response ) && $ this -> attempts >= $ this -> getConfigValue ( 'max_connect_attempts' ) ) { throw new Exception ( 'Nodes unreachable. Error Msg: ' . $ this -> api -> getError ( ) ) ; } elseif ( $ response == false ) { throw new Exception ( 'Command failed to execute against Riak. Error Msg: ' . $ this -> api -> getError ( ) ) ; } return $ response ; }
1685	public function checkAdminDisable ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == 1 && $ this -> User -> id == $ dc -> id ) { $ varValue = '' ; } return $ varValue ; }
4092	public function term ( $ term , $ field = false ) { $ this -> term = ( $ field ) ? array ( $ field => $ term ) : $ term ; return $ this ; }
11617	public function records ( $ startTime , $ endTime , $ page = 1 , $ pageSize = 10 ) { $ params = [ 'starttime' => is_numeric ( $ startTime ) ? $ startTime : strtotime ( $ startTime ) , 'endtime' => is_numeric ( $ endTime ) ? $ endTime : strtotime ( $ endTime ) , 'pageindex' => $ page , 'pagesize' => $ pageSize , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RECORDS , $ params ] ) ; }
2517	public function pnrAddMultiElements ( RequestOptions \ PnrAddMultiElementsOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
7403	public static function reload ( $ file , $ rangePath = null ) { if ( ! empty ( $ rangePath ) ) { self :: $ rangePath = $ rangePath ; } if ( PHP_SAPI === 'cli' ) { $ cilpath = realpath ( dirname ( dirname ( dirname ( dirname ( __FILE__ ) ) ) ) ) . '/config/' ; $ file = $ cilpath . $ file . '.' . self :: $ format ; } else { $ file = self :: $ rangePath . $ file . '.' . self :: $ format ; } $ name = strtolower ( $ file ) ; $ type = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( self :: $ format == $ type ) return self :: set ( include $ file ) ; }
292	public function hasAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) || in_array ( $ name , $ this -> attributes ( ) , true ) ; }
7733	public function onKernelView ( GetResponseForControllerResultEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ result = $ event -> getControllerResult ( ) ; if ( ! $ request -> attributes -> get ( '__hydra_serialize' ) ) { return ; } if ( is_array ( $ result ) || ( $ result instanceof \ ArrayAccess ) || ( $ result instanceof \ Traversable ) ) { $ result = new Collection ( $ request -> getUri ( ) , $ result ) ; } elseif ( null === $ result ) { $ event -> setResponse ( new JsonLdResponse ( '' , 200 ) ) ; return ; } elseif ( ! is_object ( $ result ) ) { throw new \ Exception ( "A Hydra controller must return either an array or an object, got a(n) " . gettype ( $ result ) ) ; } $ serialized = $ this -> serializer -> serialize ( $ result , 'jsonld' ) ; $ event -> setResponse ( new JsonLdResponse ( $ serialized ) ) ; }
5382	public function setValue ( $ desired ) { $ achieved = array ( ) ; foreach ( $ desired as $ value ) { $ success = false ; for ( $ i = 0 , $ count = count ( $ this -> options ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> options [ $ i ] -> isValue ( $ value ) ) { $ achieved [ ] = $ this -> options [ $ i ] -> getValue ( ) ; $ success = true ; break ; } } if ( ! $ success ) { return false ; } } $ this -> values = $ achieved ; return true ; }
4428	protected function getQuestion ( $ questionName , $ defaultValue = null , $ validator = null ) { $ questionName = $ defaultValue ? '<info>' . $ questionName . '</info> [<comment>' . $ defaultValue . '</comment>]: ' : '<info>' . $ questionName . '</info>: ' ; $ question = new Question ( $ questionName , $ defaultValue ) ; if ( $ validator !== null ) { $ question -> setValidator ( $ validator ) ; } return $ question ; }
5239	private function paramType ( \ ReflectionMethod $ method , \ ReflectionParameter $ param ) { $ methodAnnotations = annotationsOf ( $ method ) ; $ paramAnnotations = annotationsOf ( $ param ) ; $ paramClass = $ param -> getClass ( ) ; if ( null !== $ paramClass ) { if ( $ methodAnnotations -> contain ( 'Property' ) || $ paramAnnotations -> contain ( 'Property' ) ) { return PropertyBinding :: TYPE ; } return $ paramClass -> getName ( ) ; } if ( $ methodAnnotations -> contain ( 'List' ) || $ paramAnnotations -> contain ( 'List' ) ) { return ListBinding :: TYPE ; } if ( $ methodAnnotations -> contain ( 'Map' ) || $ paramAnnotations -> contain ( 'Map' ) ) { return MapBinding :: TYPE ; } if ( $ methodAnnotations -> contain ( 'Property' ) || $ paramAnnotations -> contain ( 'Property' ) ) { return PropertyBinding :: TYPE ; } return ConstantBinding :: TYPE ; }
12416	static function run_coding_style_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcs = self :: getTool ( 'phpcs' , $ opts , true ) ; $ rulesDir = self :: getVendorDir ( ) . '/squizlabs/php_codesniffer/Codesniffer/Standards/' . $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ; if ( ! is_dir ( $ rulesDir ) ) { if ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] == 'ezcs' ) { $ sourceDir = self :: getVendorDir ( ) . '/ezsystems/ezcs/php/ezcs' ; if ( is_dir ( $ sourceDir ) ) { pake_symlink ( $ sourceDir , $ rulesDir ) ; } } } try { $ out = pake_sh ( "$phpcs --standard=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ) . " " . "--report=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'format' ] ) . " " . "--extensions=php " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcs.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
1285	private function fetchResourcesForGivenIds ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ resources = [ ] ; $ resourcePoolOptions = [ 'locale' => $ locale ] ; foreach ( $ resourceIds as $ index => $ resourceId ) { if ( $ this -> resourcePool -> has ( $ type , $ resourceId , $ resourcePoolOptions ) ) { $ resources [ ] = $ this -> resourcePool -> get ( $ type , $ resourceId , $ resourcePoolOptions ) ; unset ( $ resourceIds [ $ index ] ) ; } } foreach ( $ this -> createIdChunks ( $ resourceIds ) as $ chunk ) { $ resources += $ this -> fetchCollectionFromApi ( $ chunk , $ type , $ locale ) ; } return $ resources ; }
3362	private function isFullyLoaded ( ) { return $ this -> fullyLoaded || ( $ this -> limit && count ( $ this -> container ) >= $ this -> limit ) ; }
1038	private function executeFields ( ObjectType $ parentType , $ source , $ path , $ fields ) { $ containsPromise = false ; $ finalResults = [ ] ; foreach ( $ fields as $ responseName => $ fieldNodes ) { $ fieldPath = $ path ; $ fieldPath [ ] = $ responseName ; $ result = $ this -> resolveField ( $ parentType , $ source , $ fieldNodes , $ fieldPath ) ; if ( $ result === self :: $ UNDEFINED ) { continue ; } if ( ! $ containsPromise && $ this -> getPromise ( $ result ) ) { $ containsPromise = true ; } $ finalResults [ $ responseName ] = $ result ; } if ( ! $ containsPromise ) { return self :: fixResultsIfEmptyArray ( $ finalResults ) ; } return $ this -> promiseForAssocArray ( $ finalResults ) ; }
2549	protected function loadClientParams ( Params $ params , $ receivedFromIdentifier , $ version ) { if ( $ params -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> authParams ; if ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams instanceof Params \ SessionHandlerParams ) { $ params -> sessionHandlerParams -> authParams = $ this -> authParams ; } } elseif ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> sessionHandlerParams -> authParams ; } $ this -> sessionHandler = $ this -> loadSessionHandler ( $ params -> sessionHandler , $ params -> sessionHandlerParams ) ; $ this -> requestCreator = $ this -> loadRequestCreator ( $ params -> requestCreator , $ params -> requestCreatorParams , $ receivedFromIdentifier . "-" . $ version , $ this -> sessionHandler -> getOriginatorOffice ( ) , $ this -> sessionHandler -> getMessagesAndVersions ( ) ) ; $ this -> responseHandler = $ this -> loadResponseHandler ( $ params -> responseHandler ) ; $ this -> returnResultXml = $ params -> returnXml ; }
9651	public function duplicate ( $ doWrite = true ) { $ clonedNode = parent :: duplicate ( $ doWrite ) ; if ( $ this -> Options ( ) ) { foreach ( $ this -> Options ( ) as $ field ) { $ newField = $ field -> duplicate ( ) ; $ newField -> ParentID = $ clonedNode -> ID ; $ newField -> write ( ) ; } } return $ clonedNode ; }
3107	public function getItemHrefIndex ( ) { if ( isset ( $ this -> state [ self :: VAR_HREF_INDEX ] ) ) { $ table = $ this -> state [ self :: VAR_HREF_INDEX ] ; } else { $ table = [ ] ; } return $ table ; }
10110	private function writeSheetLayout ( ) { if ( ! $ this -> phpSheet -> isTabColorSet ( ) ) { return ; } $ recordData = pack ( 'vvVVVvv' , 0x0862 , 0x0000 , 0x00000000 , 0x00000000 , 0x00000014 , $ this -> colors [ $ this -> phpSheet -> getTabColor ( ) -> getRGB ( ) ] , 0x0000 ) ; $ length = strlen ( $ recordData ) ; $ record = 0x0862 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
3652	public function parse ( $ strOutputFormat , $ blnFailIfNotFound = false ) { if ( $ this -> strTemplate == '' ) { return '' ; } $ this -> strFormat = $ strOutputFormat ; $ this -> callParseTemplateHook ( ) ; $ strBuffer = '' ; $ this -> strParent = $ this -> strTemplate ; while ( $ this -> strParent !== null ) { $ strCurrent = $ this -> strParent ; $ strParent = $ this -> strDefault ? : $ this -> getTemplate ( $ this -> strParent , $ this -> strFormat , $ blnFailIfNotFound ) ; if ( empty ( $ strParent ) ) { return sprintf ( 'Template %s not found (it is maybe within a unreachable theme folder?).' , $ this -> strParent ) ; } $ this -> strParent = null ; $ this -> strDefault = null ; ob_start ( ) ; include ( $ strParent ) ; if ( $ this -> strParent === null ) { $ strBuffer = ob_get_contents ( ) ; } elseif ( $ this -> strParent == $ strCurrent ) { $ this -> strDefault = $ this -> getTemplate ( $ this -> strParent , $ this -> strFormat , $ blnFailIfNotFound ) ; } ob_end_clean ( ) ; } $ this -> arrBlocks = array ( ) ; if ( \ Config :: get ( 'debugMode' ) && in_array ( $ this -> strFormat , [ 'html5' , 'xhtml' ] ) ) { $ strRelPath = str_replace ( TL_ROOT . '/' , '' , $ this -> getTemplate ( $ this -> strTemplate , $ this -> strFormat ) ) ; $ strBuffer = <<<EOF<!-- TEMPLATE START: $strRelPath ; } return $ strBuffer ; }
8571	public function listRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5071	protected function traverseHeaderTags ( \ DOMDocument $ domDocument , $ topLevel , $ depth ) { $ xpath = new \ DOMXPath ( $ domDocument ) ; $ xpathQuery = sprintf ( "//*[%s]" , implode ( ' or ' , array_map ( function ( $ v ) { return sprintf ( 'local-name() = "%s"' , $ v ) ; } , $ this -> determineHeaderTags ( $ topLevel , $ depth ) ) ) ) ; $ nodes = [ ] ; foreach ( $ xpath -> query ( $ xpathQuery ) as $ node ) { $ nodes [ ] = $ node ; } return new \ ArrayIterator ( $ nodes ) ; }
4562	public function getProperties ( Translatable $ model ) : array { $ class = get_class ( $ model ) ; if ( substr ( $ class , 0 , 15 ) === 'Proxies\\__CG__\\' ) { $ class = substr ( $ class , 15 ) ; } $ properties = [ ] ; $ reflection = new ReflectionClass ( $ class ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Translate :: class ) ; if ( ! $ annotation ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
3407	public function setLockStore ( StoreInterface $ store ) : Factory { $ this -> lockFactory = new Factory ( $ store ) ; return $ this -> lockFactory ; }
11482	public function saveAllPages ( BlockManagerApprover $ approver , array $ languages , $ saveCommonSlots = true ) { $ this -> contributorDefined ( ) ; $ finder = new Finder ( ) ; $ pages = $ finder -> directories ( ) -> depth ( 0 ) -> in ( $ this -> pagesDir ) ; foreach ( $ pages as $ page ) { $ page = ( string ) $ page ; $ pageName = basename ( $ page ) ; foreach ( $ languages as $ language ) { $ tokens = explode ( "_" , $ language ) ; $ options = array ( 'page' => $ pageName , 'language' => $ tokens [ 0 ] , 'country' => $ tokens [ 1 ] , ) ; $ this -> save ( $ approver , $ options , $ saveCommonSlots ) ; } $ saveCommonSlots = false ; } Dispatcher :: dispatch ( PageCollectionEvents :: SITE_SAVED , new SiteSavedEvent ( ) ) ; DataLogger :: log ( 'The whole website\'s pages were successfully saved in production' ) ; }
10476	public function push ( string $ event , $ event_args = null ) : EventChannelInterface { try { $ this -> channel -> push ( $ event , $ event_args ) ; } catch ( EventSourceIsNotPushableException $ e ) { throw new EventStreamException ( 'Event is not pushable.' ) ; } return $ this ; }
6308	public function setA ( StringType $ name , Attribute $ attribute ) { if ( $ this -> hasA ( $ name ) ) { $ this -> attributes = $ this -> attributes -> kDiff ( new AttributeMap ( [ $ name ( ) => $ attribute ] ) ) ; } $ this -> attributes = $ this -> attributes -> append ( [ $ name ( ) => $ attribute ] ) ; return $ this ; }
40	protected function fetchRootIdentifier ( ) { if ( $ this -> repoData ) { return ; } $ repoDataUrl = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository ; $ this -> repoData = JsonFile :: parseJson ( $ this -> getContents ( $ repoDataUrl , true ) , $ repoDataUrl ) ; if ( null === $ this -> repoData && null !== $ this -> gitDriver ) { return ; } $ this -> owner = $ this -> repoData [ 'owner' ] [ 'login' ] ; $ this -> repository = $ this -> repoData [ 'name' ] ; $ this -> isPrivate = ! empty ( $ this -> repoData [ 'private' ] ) ; if ( isset ( $ this -> repoData [ 'default_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'default_branch' ] ; } elseif ( isset ( $ this -> repoData [ 'master_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'master_branch' ] ; } else { $ this -> rootIdentifier = 'master' ; } $ this -> hasIssues = ! empty ( $ this -> repoData [ 'has_issues' ] ) ; }
496	public function getDbProfiling ( ) { $ timings = $ this -> getProfiling ( [ 'yii\db\Command::query' , 'yii\db\Command::execute' ] ) ; $ count = count ( $ timings ) ; $ time = 0 ; foreach ( $ timings as $ timing ) { $ time += $ timing [ 'duration' ] ; } return [ $ count , $ time ] ; }
8823	public function rule ( $ field , $ label , $ rules , array $ text = [ ] ) { $ this -> labels [ $ field ] = $ label ; $ this -> rules [ $ field ] = $ rules ; $ this -> texts [ $ field ] = ( ! empty ( $ text ) ? $ text : null ) ; }
12239	public function innerXML ( ) { $ xml = $ this -> outerXML ( ) ; $ pos = 1 + strpos ( $ xml , '>' ) ; $ len = strrpos ( $ xml , '<' ) - $ pos ; return substr ( $ xml , $ pos , $ len ) ; }
2576	protected function mergeOptions ( $ existingOptions , $ newOptions ) { if ( ! empty ( $ newOptions ) ) { $ existingOptions = array_merge ( $ existingOptions , $ newOptions ) ; } return $ existingOptions ; }
9216	public function actionDelete ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> isdel = 1 ; $ model -> save ( ) ; return $ this -> redirect ( [ 'index' ] ) ; }
513	public function actionUp ( $ limit = 0 ) { $ migrations = $ this -> getNewMigrations ( ) ; if ( empty ( $ migrations ) ) { $ this -> stdout ( "No new migrations found. Your system is up-to-date.\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; } $ total = count ( $ migrations ) ; $ limit = ( int ) $ limit ; if ( $ limit > 0 ) { $ migrations = array_slice ( $ migrations , 0 , $ limit ) ; } $ n = count ( $ migrations ) ; if ( $ n === $ total ) { $ this -> stdout ( "Total $n new " . ( $ n === 1 ? 'migration' : 'migrations' ) . " to be applied:\n" , Console :: FG_YELLOW ) ; } else { $ this -> stdout ( "Total $n out of $total new " . ( $ total === 1 ? 'migration' : 'migrations' ) . " to be applied:\n" , Console :: FG_YELLOW ) ; } foreach ( $ migrations as $ migration ) { $ nameLimit = $ this -> getMigrationNameLimit ( ) ; if ( $ nameLimit !== null && strlen ( $ migration ) > $ nameLimit ) { $ this -> stdout ( "\nThe migration name '$migration' is too long. Its not possible to apply this migration.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "\t$migration\n" ) ; } $ this -> stdout ( "\n" ) ; $ applied = 0 ; if ( $ this -> confirm ( 'Apply the above ' . ( $ n === 1 ? 'migration' : 'migrations' ) . '?' ) ) { foreach ( $ migrations as $ migration ) { if ( ! $ this -> migrateUp ( $ migration ) ) { $ this -> stdout ( "\n$applied from $n " . ( $ applied === 1 ? 'migration was' : 'migrations were' ) . " applied.\n" , Console :: FG_RED ) ; $ this -> stdout ( "\nMigration failed. The rest of the migrations are canceled.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ applied ++ ; } $ this -> stdout ( "\n$n " . ( $ n === 1 ? 'migration was' : 'migrations were' ) . " applied.\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "\nMigrated up successfully.\n" , Console :: FG_GREEN ) ; } }
8033	public function loadView ( $ viewName , $ data = array ( ) , $ mergeData = array ( ) ) { $ this -> htmlContent = View :: make ( $ viewName , $ data , $ mergeData ) ; return $ this ; }
8137	public function getCacheFilename ( $ name ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ key = $ this -> cache -> generateKey ( $ name , $ this -> getTemplateClass ( $ name ) ) ; return ! $ key ? false : $ key ; }
10866	protected function createNewInst ( ) { $ classReflection = new \ ReflectionClass ( $ this -> instClass ) ; if ( $ this -> constructorArgs === null ) { return $ classReflection -> newInstance ( ) ; } else { return $ classReflection -> newInstanceArgs ( $ this -> concstructorArgs ) ; } }
3541	public static function getGroupAssigmentOptions ( $ optionName , $ individualGroupAssignmentOptions = null ) { if ( $ individualGroupAssignmentOptions != null && is_array ( $ individualGroupAssignmentOptions ) && array_key_exists ( $ optionName , $ individualGroupAssignmentOptions ) ) { return $ individualGroupAssignmentOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX ) ) { return static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Group-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
5708	public function transformToButton ( ) { parent :: transformToButton ( ) ; if ( $ this -> gridFieldRequest -> recordIsPublished ( ) ) { $ this -> setTitle ( _t ( 'SiteTree.BUTTONPUBLISHED' , 'Published' ) ) ; } if ( $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsDeletedFromStage ( ) ) { $ this -> addExtraClass ( 'ss-ui-alternate' ) ; } return $ this ; }
6507	public function deserializeReturnValue ( $ type , $ data ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> deserialize ( $ data , $ jobType -> getReturnType ( ) , 'json' , $ this -> getResponseDeserializationContext ( $ jobType ) ) ; }
4415	public static function modify ( $ tpl , $ operatorName , $ operatorParameters , $ rootNamespace , $ currentNamespace , & $ operatorValue , $ namedParameters , $ placement ) { if ( $ operatorName === 'has_tags_bundle' ) { $ operatorValue = class_exists ( 'Netgen\TagsBundle\Version' ) && TagsBundleVersion :: VERSION_ID >= 30000 ; } }
6167	protected function writePerformance ( $ time ) { $ ms = round ( $ time * 1000 ) ; foreach ( self :: $ performanceThresholds as $ colour => $ threshold ) { if ( $ ms > $ threshold ) { break ; } } $ this -> writeWithColor ( $ colour , " ($ms ms)" ) ; }
12190	public function getActive ( ) { return ( isset ( $ this -> _child ) and $ this -> _child -> active ) and ( isset ( $ this -> _parent ) and $ this -> _parent -> active ) ; }
2119	public function getFromDca ( ) { $ return = array ( ) ; $ processed = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; $ objExtract = DcaExtractor :: getInstance ( $ strTable ) ; if ( $ objExtract -> isDbTable ( ) ) { $ return [ $ strTable ] = $ objExtract -> getDbInstallerArray ( ) ; } } ksort ( $ return ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromDca' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromDca' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromDca' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ return = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ return ) ; } } return $ return ; }
5346	public function requestRemoteHands ( $ colocationName , $ contactName , $ phoneNumber , $ expectedDuration , $ instructions ) { return $ this -> call ( self :: SERVICE , 'requestRemoteHands' , [ $ colocationName , $ contactName , $ phoneNumber , $ expectedDuration , $ instructions ] ) ; }
11208	protected function getValue ( $ data , $ key = false ) { $ returnValue = $ data ; if ( $ key && is_object ( $ data ) ) { $ returnValue = $ data -> $ key ; } else if ( $ key && is_array ( $ data ) ) { $ returnValue = $ data [ $ key ] ; } return $ returnValue ; }
7215	protected function fixDefault ( TaxGroupInterface $ taxGroup ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ taxGroup , [ 'default' ] ) ) { return ; } if ( $ taxGroup -> isDefault ( ) ) { try { $ previousTaxGroup = $ this -> taxGroupRepository -> findDefault ( ) ; } catch ( RuntimeException $ e ) { return ; } if ( null === $ previousTaxGroup || $ previousTaxGroup === $ taxGroup ) { return ; } $ previousTaxGroup -> setDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ previousTaxGroup , false ) ; } }
11641	public function getColumns ( ) { if ( is_null ( $ this -> _columns ) ) { $ this -> columns = $ this -> dataProvider -> model -> attributeNames ( ) ; } return $ this -> _columns ; }
2253	protected function getParentEntries ( $ strTable , $ intId ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ) ) { return '' ; } $ arrParent = array ( ) ; do { $ objParent = $ this -> Database -> prepare ( "SELECT pid FROM " . $ strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intId ) ; if ( $ objParent -> numRows < 1 ) { break ; } $ strTable = $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ; $ intId = $ objParent -> pid ; $ arrParent [ ] = $ strTable . '.id=' . $ intId ; $ this -> loadDataContainer ( $ strTable ) ; } while ( $ intId && isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ) ) ; if ( empty ( $ arrParent ) ) { return '' ; } return ' (parent records: ' . implode ( ', ' , $ arrParent ) . ')' ; }
1469	public static function httpErrorStatus ( $ errors , int $ default = SymfonyResponse :: HTTP_BAD_REQUEST ) : int { if ( $ errors instanceof ErrorInterface ) { $ errors = [ $ errors ] ; } $ statuses = collect ( $ errors ) -> reject ( function ( ErrorInterface $ error ) { return is_null ( $ error -> getStatus ( ) ) ; } ) -> map ( function ( ErrorInterface $ error ) { return ( int ) $ error -> getStatus ( ) ; } ) -> unique ( ) ; if ( 2 > count ( $ statuses ) ) { return $ statuses -> first ( ) ? : $ default ; } $ only4xx = $ statuses -> every ( function ( int $ status ) { return 400 <= $ status && 499 >= $ status ; } ) ; return $ only4xx ? SymfonyResponse :: HTTP_BAD_REQUEST : SymfonyResponse :: HTTP_INTERNAL_SERVER_ERROR ; }
3514	public function postMissingKeys ( ) { $ missingKeys = Request :: json ( 'missingKeys' ) ; $ this -> manager -> setConnectionName ( '' ) ; $ translator = App :: make ( 'translator' ) ; $ affectedGroups = [ ] ; foreach ( $ missingKeys as $ key ) { $ key = decodeKey ( $ key ) ; list ( $ namespace , $ group , $ item ) = $ translator -> parseKey ( $ key ) ; if ( $ item && $ group ) { if ( ! in_array ( $ group , $ this -> manager -> config ( Manager :: EXCLUDE_GROUPS_KEY ) ) ) { $ t = $ this -> manager -> missingKey ( $ namespace , $ group , $ item , null , false , true ) ; if ( ! $ t -> exists ) { $ affectedGroups [ ] = $ t -> group ; $ t -> save ( ) ; } } } else { } } $ data = [ 'connectionName' => '' , 'affectedGroups' => $ affectedGroups , 'missingKeys' => [ ] , ] ; $ pretty = Request :: has ( 'pretty-json' ) ? JSON_PRETTY_PRINT : 0 ; return Response :: json ( $ data , 200 , [ ] , JSON_UNESCAPED_SLASHES | $ pretty ) ; }
8394	public static function before ( string $ path , string $ usage , string $ help , string $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'before' , 'path' => $ path , 'usage' => $ usage , 'help' => $ help , 'action' => $ action , 'namespace' => self :: $ namespace ) ; } }
12262	public function getCustomField ( $ class , $ slug = null ) { if ( ! $ slug ) { throw CustomFieldsHelperException :: slugIsMissing ( ) ; } $ resolveClass = ( is_string ( $ class ) ) ? $ class : get_class ( $ class ) ; if ( ! $ this -> cache [ $ resolveClass ] [ $ slug ] ) { $ this -> _cacheCustomFields ( $ resolveClass ) ; } return $ this -> cache [ $ resolveClass ] [ $ slug ] ; }
2949	private function dispatchQueue ( ) { $ queue = $ this -> queue ; $ this -> queue = [ ] ; $ queueLength = count ( $ queue ) ; $ maxBatchSize = $ this -> options -> getMaxBatchSize ( ) ; if ( $ maxBatchSize && $ maxBatchSize > 0 && $ maxBatchSize < $ queueLength ) { for ( $ i = 0 ; $ i < $ queueLength / $ maxBatchSize ; $ i ++ ) { $ offset = $ i * $ maxBatchSize ; $ length = ( $ i + 1 ) * $ maxBatchSize - $ offset ; $ this -> dispatchQueueBatch ( array_slice ( $ queue , $ offset , $ length ) ) ; } } else { $ this -> dispatchQueueBatch ( $ queue ) ; } }
52	public function setOutputProgress ( $ outputProgress ) { foreach ( $ this -> downloaders as $ downloader ) { $ downloader -> setOutputProgress ( $ outputProgress ) ; } return $ this ; }
9546	public function count ( $ table , $ search , $ where = '' ) { if ( empty ( $ where ) ) { $ where = 'WHERE' ; } else { $ where = ( stripos ( $ where , 'WHERE' ) === false ) ? "WHERE {$where} AND" : "{$where} AND" ; } return $ this -> db -> value ( "SELECT COUNT(*) FROM {$table} AS s {$where} s.{$table} MATCH ?" , $ search ) ; }
4949	public function createQueryBuilder ( $ findDrafts = false ) { $ qb = parent :: createQueryBuilder ( ) ; if ( null !== $ findDrafts ) { $ qb -> field ( 'isDraft' ) -> equals ( $ findDrafts ) ; } return $ qb ; }
12206	public function createPagination ( $ currentPage , $ total , $ perPage = null , $ baseUrl = null , $ neighbours = null ) { if ( isset ( $ this -> container ) && $ this -> container instanceof \ League \ Container \ ContainerInterface ) { return $ this -> getContainer ( ) -> get ( 'Laasti\Pagination\Pagination' , [ $ currentPage , $ total , $ perPage , $ baseUrl , $ neighbours ] ) ; } $ perPage = $ perPage ? : 10 ; $ baseUrl = $ baseUrl ? : '' ; $ neighbours = $ neighbours ? : 3 ; return new Pagination ( $ currentPage , $ total , $ perPage , $ baseUrl , $ neighbours ) ; }
4632	public function responseHeaderCallback ( $ ch , $ header ) { if ( strpos ( $ header , ':' ) ) { list ( $ key , $ value ) = explode ( ':' , $ header , 2 ) ; $ value = trim ( $ value ) ; if ( ! empty ( $ value ) ) { if ( ! isset ( $ this -> responseHeaders [ $ key ] ) ) { $ this -> responseHeaders [ $ key ] = $ value ; } elseif ( is_array ( $ this -> responseHeaders [ $ key ] ) ) { $ this -> responseHeaders [ $ key ] = array_merge ( $ this -> responseHeaders [ $ key ] , [ $ value ] ) ; } else { $ this -> responseHeaders [ $ key ] = array_merge ( [ $ this -> responseHeaders [ $ key ] ] , [ $ value ] ) ; } } } return strlen ( $ header ) ; }
7604	protected function renderAddOn ( $ aAddOnOptions ) { if ( empty ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( 'Addon options are empty' ) ; } if ( $ aAddOnOptions instanceof ElementInterface ) { $ aAddOnOptions = array ( 'element' => $ aAddOnOptions ) ; } elseif ( is_scalar ( $ aAddOnOptions ) ) { $ aAddOnOptions = array ( 'text' => $ aAddOnOptions ) ; } elseif ( ! is_array ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( sprintf ( 'Addon options expects an array or a scalar value, "%s" given' , is_object ( $ aAddOnOptions ) ? get_class ( $ aAddOnOptions ) : gettype ( $ aAddOnOptions ) ) ) ; } $ sMarkup = '' ; $ sAddonTagName = 'span' ; $ sAddonClass = '' ; if ( ! empty ( $ aAddOnOptions [ 'text' ] ) ) { if ( ! is_scalar ( $ aAddOnOptions [ 'text' ] ) ) { throw new InvalidArgumentException ( sprintf ( '"text" option expects a scalar value, "%s" given' , is_object ( $ aAddOnOptions [ 'text' ] ) ? get_class ( $ aAddOnOptions [ 'text' ] ) : gettype ( $ aAddOnOptions [ 'text' ] ) ) ) ; } elseif ( ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sMarkup .= $ oTranslator -> translate ( $ aAddOnOptions [ 'text' ] , $ this -> getTranslatorTextDomain ( ) ) ; } else { $ sMarkup .= $ aAddOnOptions [ 'text' ] ; } $ sAddonClass .= ' input-group-addon' ; } elseif ( ! empty ( $ aAddOnOptions [ 'element' ] ) ) { if ( is_array ( $ aAddOnOptions [ 'element' ] ) || ( $ aAddOnOptions [ 'element' ] instanceof Traversable && ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ aAddOnOptions [ 'element' ] = $ oFactory -> create ( $ aAddOnOptions [ 'element' ] ) ; } elseif ( ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( '"element" option expects an instanceof Zend\Form\ElementInterface, "%s" given' , is_object ( $ aAddOnOptions [ 'element' ] ) ? get_class ( $ aAddOnOptions [ 'element' ] ) : gettype ( $ aAddOnOptions [ 'element' ] ) ) ) ; } $ aAddOnOptions [ 'element' ] -> setOptions ( array_merge ( $ aAddOnOptions [ 'element' ] -> getOptions ( ) , array ( 'disable-twb' => true ) ) ) ; $ sMarkup .= $ this -> render ( $ aAddOnOptions [ 'element' ] ) ; if ( $ aAddOnOptions [ 'element' ] instanceof Button ) { $ sAddonClass .= ' input-group-btn' ; $ sAddonTagName = 'div' ; } else { $ sAddonClass .= ' input-group-addon' ; } } return sprintf ( static :: $ addonFormat , $ sAddonTagName , trim ( $ sAddonClass ) , $ sMarkup , $ sAddonTagName ) ; }
5719	public function cancel ( ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return Controller :: curr ( ) -> redirect ( $ this -> getBackLink ( ) ) ; }
1893	public function onAuthenticationFailure ( Request $ request , AuthenticationException $ exception ) : Response { if ( null === $ this -> logger ) { return parent :: onAuthenticationFailure ( $ request , $ exception ) ; } if ( $ exception instanceof AccountStatusException && ( $ user = $ exception -> getUser ( ) ) instanceof UserInterface ) { $ username = $ user -> getUsername ( ) ; } else { $ username = $ request -> request -> get ( 'username' ) ; } $ this -> logger -> info ( $ exception -> getMessage ( ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ username ) ] ) ; return parent :: onAuthenticationFailure ( $ request , $ exception ) ; }
7815	public static function uploadImgFile ( $ path ) { try { if ( Request :: hasFile ( 'image' ) ) { $ pic = Request :: file ( 'image' ) ; if ( $ pic -> isValid ( ) ) { $ newName = md5 ( rand ( 1 , 1000 ) . $ pic -> getClientOriginalName ( ) ) . "." . $ pic -> getClientOriginalExtension ( ) ; $ pic -> move ( $ path , $ newName ) ; $ url = asset ( $ path . '/' . $ newName ) ; } else { self :: addError ( 'The file is invalid' ) ; } } else { self :: addError ( 'Not File' ) ; } } catch ( \ Exception $ e ) { self :: addError ( $ e -> getMessage ( ) ) ; } $ data = array ( 'status' => empty ( $ message ) ? 0 : 1 , 'message' => self :: getLastError ( ) , 'url' => ! empty ( $ url ) ? $ url : '' ) ; return $ data ; }
8990	public function getTemplates ( ) { $ templates = array ( ) ; $ types = $ this -> config -> getTypes ( ) ; foreach ( $ types as $ type => $ type_options ) { foreach ( $ type_options as $ subtype => $ subtype_options ) { $ templates [ $ type ] [ $ subtype ] = ( array ) $ subtype_options ; } } return $ templates ; }
12928	public function update ( $ poiId , array $ data ) { $ data = array_merge ( $ data , [ 'poi_id' => $ poiId ] ) ; $ params = [ 'business' => [ 'base_info' => $ data ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
6171	protected function onAddFailure ( $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'F' ) ; $ this -> failure = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
4903	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ select = $ this ( $ serviceLocator , self :: class , $ this -> options ) ; $ this -> options = [ ] ; return $ select ; }
8599	private function _convertCreateSubscription ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateSubscription' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetSubscription ( ) ) { $ SubscriptionCreateSubscriptionInput = $ request -> getSubscription ( ) ; foreach ( $ SubscriptionCreateSubscriptionInput -> getNotificationType ( ) as $ NotificationTypeSubscriptionIndex => $ NotificationTypeSubscription ) { $ parameters [ 'Subscription' . '.' . 'NotificationType' . '.' . ( $ NotificationTypeSubscriptionIndex + 1 ) ] = $ NotificationTypeSubscription ; } } return $ parameters ; }
2202	public static function stripTags ( $ varValue , $ strAllowedTags = '' ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: stripTags ( $ v , $ strAllowedTags ) ; } return $ varValue ; } $ varValue = preg_replace_callback ( '@</?([^\s<>/]*)@' , function ( $ matches ) use ( $ strAllowedTags ) { if ( $ matches [ 1 ] == '' || stripos ( $ strAllowedTags , '<' . strtolower ( $ matches [ 1 ] ) . '>' ) === false ) { $ matches [ 0 ] = str_replace ( '<' , '&lt;' , $ matches [ 0 ] ) ; } return $ matches [ 0 ] ; } , $ varValue ) ; $ varValue = strip_tags ( $ varValue , $ strAllowedTags ) ; $ varValue = str_replace ( array ( '&lt;!--' , '&lt;![' ) , array ( '<!--' , '<![' ) , $ varValue ) ; while ( strpos ( $ varValue , '\\0' ) !== false ) { $ varValue = str_replace ( '\\0' , '' , $ varValue ) ; } return $ varValue ; }
8323	public function addPingback ( $ url ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=add_pingback&addr={$url}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
4110	protected function arrayToTabList ( array $ array , array $ skipKeys = array ( ) , $ indentationLevel = 1 ) { $ output = '' ; foreach ( $ array as $ key => $ value ) { if ( in_array ( $ key , $ skipKeys , true ) ) { continue ; } $ output .= $ this -> tabsForIndentation ( $ indentationLevel ) ; if ( ! is_array ( $ value ) ) { if ( ! is_int ( $ key ) ) { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> tabsForIndentation ( $ indentationLevel + 1 ) ; } $ output .= $ value . "\n" ; } else { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> arrayToTabList ( $ value , $ skipKeys , $ indentationLevel + 1 ) ; } } return $ output ; }
6733	public function run ( Request $ request ) { $ this -> stopwatch = microtime ( true ) ; $ starttime = $ request -> server -> get ( 'REQUEST_TIME_FLOAT' ) ; $ this -> log ( "Router: ->run() called. Starting clock at REQUEST_TIME+%.2fms" , microtime ( true ) - $ starttime ) ; try { $ response = $ this -> process ( $ request ) ; } catch ( \ Throwable $ e ) { $ this -> log ( "Router: Exception" ) ; $ response = $ this -> handleException ( $ e , $ request ) ; } $ this -> log ( "Router: Preparing to send response" ) ; $ response -> prepare ( $ request ) ; $ response -> send ( ) ; $ this -> log ( "Router: Response sent" ) ; }
6233	public function addChild ( $ key , $ value = null , $ namespace = null ) { if ( $ value != null ) { $ value = htmlspecialchars ( $ value , ENT_XML1 ) ; } return parent :: addChild ( $ key , $ value , $ namespace ) ; }
8317	protected function sendResetMail ( $ userData ) { if ( ! $ this -> mailer ) { $ this -> getLogger ( ) -> critical ( "Sending mail but no mailer is set!" ) ; return ; } $ url = $ this -> createResetToken ( $ userData [ 'name' ] ) ; $ message = $ this -> picoAuth -> getPico ( ) -> substituteFileContent ( $ this -> config [ "emailMessage" ] ) ; $ subject = $ this -> picoAuth -> getPico ( ) -> substituteFileContent ( $ this -> config [ "emailSubject" ] ) ; $ message = str_replace ( "%url%" , $ url , $ message ) ; $ message = str_replace ( "%username%" , $ userData [ 'name' ] , $ message ) ; $ this -> mailer -> setup ( ) ; $ this -> mailer -> setTo ( $ userData [ 'email' ] ) ; $ this -> mailer -> setSubject ( $ subject ) ; $ this -> mailer -> setBody ( $ message ) ; if ( ! $ this -> mailer -> send ( ) ) { $ this -> getLogger ( ) -> critical ( "Mailer error: {e}" , [ "e" => $ this -> mailer -> getError ( ) ] ) ; } else { $ this -> getLogger ( ) -> info ( "PwReset email sent to {email}" , [ "email" => $ userData [ 'email' ] ] ) ; } }
8425	public function getAllActiveQuery ( Production $ production ) : Query { $ qb = $ this -> createQueryBuilder ( 'p' ) ; return $ qb -> join ( 'p.groups' , 'g' ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'g' , ':group' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.active' , ':active' ) ) -> andWhere ( $ qb -> expr ( ) -> isNull ( 'p.parent' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isNull ( 'p.expiry' ) , $ qb -> expr ( ) -> gt ( 'p.expiry' , ':now' ) ) ) -> setParameter ( 'group' , $ production ) -> setParameter ( 'active' , true ) -> setParameter ( 'now' , new \ DateTime ( ) ) -> orderBy ( 'p.pinned' , 'DESC' ) -> addOrderBy ( 'p.created' , 'DESC' ) -> getQuery ( ) ; }
4910	public function renderSummary ( SummaryFormInterface $ form ) { $ form -> prepare ( ) ; $ baseFieldset = $ form -> getBaseFieldset ( ) ; if ( ! isset ( $ baseFieldset ) ) { throw new \ InvalidArgumentException ( 'For the Form ' . get_class ( $ form ) . ' there is no Basefieldset' ) ; } $ dataAttributesMarkup = '' ; foreach ( $ form -> getAttributes ( ) as $ dataKey => $ dataValue ) { if ( preg_match ( '/^data-/' , $ dataKey ) ) { $ dataAttributesMarkup .= sprintf ( ' %s="%s"' , $ dataKey , $ dataValue ) ; } } $ markup = '<div class="panel panel-default" style="min-height: 100px;"' . $ dataAttributesMarkup . '> <div class="panel-body"><div class="sf-controls">%s</div>%s</div></div>' ; $ view = $ this -> getView ( ) ; $ buttonMarkup = false === $ form -> getOption ( 'editable' ) ? '' : '<button type="button" class="btn btn-default btn-xs sf-edit">' . '<span class="yk-icon yk-icon-edit"></span> ' . $ view -> translate ( 'Edit' ) . '</button>' ; if ( ( $ controlButtons = $ form -> getOption ( 'control_buttons' ) ) !== null ) { $ buttonMarkup .= PHP_EOL . implode ( PHP_EOL , array_map ( function ( array $ buttonSpec ) use ( $ view ) { return '<button type="button" class="btn btn-default btn-xs' . ( isset ( $ buttonSpec [ 'class' ] ) ? ' ' . $ buttonSpec [ 'class' ] : '' ) . '">' . ( isset ( $ buttonSpec [ 'icon' ] ) ? '<span class="yk-icon yk-icon-' . $ buttonSpec [ 'icon' ] . '"></span> ' : '' ) . $ view -> translate ( $ buttonSpec [ 'label' ] ) . '</button>' ; } , $ controlButtons ) ) ; } $ elementMarkup = $ this -> renderSummaryElement ( $ baseFieldset ) ; return sprintf ( $ markup , $ buttonMarkup , $ elementMarkup ) ; }
2214	public function prev ( ) { if ( $ this -> intIndex < 1 ) { return false ; } $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ -- $ this -> intIndex ] ; return $ this ; }
27	public function write ( ) { $ data = array ( ) ; $ dumper = new ArrayDumper ( ) ; foreach ( $ this -> getCanonicalPackages ( ) as $ package ) { $ data [ ] = $ dumper -> dump ( $ package ) ; } usort ( $ data , function ( $ a , $ b ) { return strcmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; $ this -> file -> write ( $ data ) ; }
3952	protected function isArrayEmpty ( $ arrArray ) { if ( empty ( $ arrArray ) ) { return true ; } if ( is_array ( $ arrArray ) && array_key_exists ( 'value' , $ arrArray ) ) { return $ this -> isArrayEmpty ( $ arrArray [ 'value' ] ) ; } if ( is_array ( $ arrArray ) ) { foreach ( $ arrArray as $ value ) { if ( is_array ( $ value ) ) { return $ this -> isArrayEmpty ( $ value ) ; } elseif ( ! empty ( $ value ) ) { return false ; } } } return false ; }
6814	private function getCurrencyFormatter ( ) { if ( $ this -> currencyFormatter ) { return $ this -> currencyFormatter ; } return $ this -> currencyFormatter = NumberFormatter :: create ( $ this -> locale , NumberFormatter :: CURRENCY ) ; }
366	public function renderTableFooter ( ) { $ cells = [ ] ; foreach ( $ this -> columns as $ column ) { $ cells [ ] = $ column -> renderFooterCell ( ) ; } $ content = Html :: tag ( 'tr' , implode ( '' , $ cells ) , $ this -> footerRowOptions ) ; if ( $ this -> filterPosition === self :: FILTER_POS_FOOTER ) { $ content .= $ this -> renderFilters ( ) ; } return "<tfoot>\n" . $ content . "\n</tfoot>" ; }
3931	private function getOrCreateProperty ( PropertiesDefinitionInterface $ definition , $ propName ) { if ( $ definition -> hasProperty ( $ propName ) ) { return $ definition -> getProperty ( $ propName ) ; } $ property = new DefaultProperty ( $ propName ) ; $ definition -> addProperty ( $ property ) ; return $ property ; }
12282	private function stopCustomProcess ( ) : void { if ( $ this -> isCustomProcessSet ( ) ) { $ this -> getCustomProcess ( ) -> stop ( ) ; } elseif ( class_exists ( '\extensions\core\Process' ) ) { \ extensions \ core \ Process :: getInstance ( ) -> stop ( ) ; } }
10553	public static function findVirtualHost ( URL $ url , array $ sites ) { foreach ( $ sites as $ site ) { $ vhost = $ site -> match ( $ url ) ; if ( $ vhost !== null ) return $ vhost ; } return null ; }
9144	public static function generate ( $ length = 8 , $ allowed = RandomString :: ASCII , $ repeatable = true ) : string { $ allowedChars = array ( ) ; $ currentLocale = setlocale ( LC_ALL , "0" ) ; if ( $ allowed == RandomString :: ASCII ) { setlocale ( LC_ALL , "C" ) ; } for ( $ i = 32 ; $ i < 256 ; $ i ++ ) { if ( ( $ allowed == RandomString :: ASCII && ! ctype_alnum ( chr ( $ i ) ) ) || ( ! ctype_print ( chr ( $ i ) ) ) ) { continue ; } $ allowedChars [ ] = $ i ; } self :: resetLocaleTo ( $ currentLocale ) ; $ used = array ( ) ; $ string = "" ; $ i = $ length ; while ( $ i > 0 ) { $ index = mt_rand ( 0 , count ( $ allowedChars ) - 1 ) ; if ( ! $ repeatable && in_array ( $ index , $ used ) ) { continue ; } $ string .= chr ( $ allowedChars [ $ index ] ) ; $ used [ ] = $ i ; $ i -- ; } return $ string ; }
12603	public static function read ( $ path ) { $ path = Path :: clean ( $ path ) ; if ( ! File :: exists ( $ path ) ) { return '' ; } return file_get_contents ( $ path ) ; }
9853	public function expiresAt ( $ expires ) { if ( $ expires instanceof DateTimeInterface ) { $ this -> expires = $ expires ; } else { $ this -> expires = null ; } return $ this ; }
9668	private function writePatternFill ( XMLWriter $ objWriter , Fill $ pFill ) { $ objWriter -> startElement ( 'fill' ) ; $ objWriter -> startElement ( 'patternFill' ) ; $ objWriter -> writeAttribute ( 'patternType' , $ pFill -> getFillType ( ) ) ; if ( $ pFill -> getFillType ( ) !== Fill :: FILL_NONE ) { if ( $ pFill -> getStartColor ( ) -> getARGB ( ) ) { $ objWriter -> startElement ( 'fgColor' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getStartColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } } if ( $ pFill -> getFillType ( ) !== Fill :: FILL_NONE ) { if ( $ pFill -> getEndColor ( ) -> getARGB ( ) ) { $ objWriter -> startElement ( 'bgColor' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getEndColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
3000	public function reset ( $ key = null ) { if ( $ key ) { $ key = ucfirst ( $ key ) ; $ this -> smtp -> clear ( $ key ) ; if ( isset ( $ this -> recipients [ $ key ] ) ) unset ( $ this -> recipients [ $ key ] ) ; } else { $ this -> recipients = array ( ) ; $ this -> initSMTP ( ) ; } }
9680	public function getColumnDisplayName ( $ columnName ) { return isset ( $ this -> columnDisplayNames [ $ columnName ] ) ? $ this -> columnDisplayNames [ $ columnName ] : $ columnName ; }
7000	public function url ( $ url = null ) { if ( $ url ) $ this -> url = trim ( $ url ) ; return $ this -> url ; }
1634	public function boot ( ) { $ this -> app [ 'auth' ] -> viaRequest ( 'api' , function ( $ request ) { if ( $ request -> input ( 'api_token' ) ) { return User :: where ( 'api_token' , $ request -> input ( 'api_token' ) ) -> first ( ) ; } } ) ; }
8078	protected function buildUri ( $ endpoint , $ options = [ ] ) { if ( $ this -> token !== '' ) { $ options [ 'auth' ] = $ this -> token ; } return $ this -> base . '/' . ltrim ( $ endpoint , '/' ) . '.json?' . http_build_query ( $ options , '' , '&' ) ; }
3312	public function getCacheKey ( ) { if ( is_null ( $ this -> cacheKey ) ) { return $ this -> prefix . $ this -> appKey ; } return $ this -> cacheKey ; }
8513	public function listInboundShipments ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipments' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
330	public function get ( $ key ) { $ key = $ this -> buildKey ( $ key ) ; $ value = $ this -> getValue ( $ key ) ; if ( $ value === false || $ this -> serializer === false ) { return $ value ; } elseif ( $ this -> serializer === null ) { $ value = unserialize ( $ value ) ; } else { $ value = call_user_func ( $ this -> serializer [ 1 ] , $ value ) ; } if ( is_array ( $ value ) && ! ( $ value [ 1 ] instanceof Dependency && $ value [ 1 ] -> isChanged ( $ this ) ) ) { return $ value [ 0 ] ; } return false ; }
7862	protected function setPipesOfWorkflow ( $ workflow ) { $ pipes = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ this -> pipes = array_map ( function ( $ pipe ) { $ chunks = explode ( '\\' , $ pipe ) ; return end ( $ chunks ) ; } , $ pipes ) ; $ this -> geometry -> setPipes ( $ this -> pipes ) ; }
6477	public function readAsMultipart ( ? IHttpBody $ body , string $ boundary ) : ? MultipartBody { if ( $ body === null ) { return null ; } $ rawBodyParts = explode ( "--$boundary" , $ body -> readAsString ( ) ) ; array_shift ( $ rawBodyParts ) ; array_pop ( $ rawBodyParts ) ; $ parsedBodyParts = [ ] ; foreach ( $ rawBodyParts as $ rawBodyPart ) { $ headerStartIndex = strlen ( "\r\n" ) ; $ headerEndIndex = strpos ( $ rawBodyPart , "\r\n\r\n" ) ; $ bodyStartIndex = $ headerEndIndex + strlen ( "\r\n\r\n" ) ; $ bodyEndIndex = strlen ( $ rawBodyPart ) - strlen ( "\r\n" ) ; $ rawHeaders = explode ( "\r\n" , substr ( $ rawBodyPart , $ headerStartIndex , $ headerEndIndex - $ headerStartIndex ) ) ; $ parsedHeaders = new HttpHeaders ( ) ; foreach ( $ rawHeaders as $ headerLine ) { [ $ headerName , $ headerValue ] = explode ( ':' , $ headerLine , 2 ) ; $ parsedHeaders -> add ( trim ( $ headerName ) , trim ( $ headerValue ) ) ; } $ body = new StringBody ( substr ( $ rawBodyPart , $ bodyStartIndex , $ bodyEndIndex - $ bodyStartIndex ) ) ; $ parsedBodyParts [ ] = new MultipartBodyPart ( $ parsedHeaders , $ body ) ; } return new MultipartBody ( $ parsedBodyParts , $ boundary ) ; }
6187	public function assign ( $ name , $ value ) { if ( ! isset ( $ this -> view ) ) { throw new ViewException ( 'Please Define view engine in app/View.php' , 500 ) ; } return $ this -> view -> assign ( $ name , $ value ) ; }
6563	public function carrier_data ( $ carrier = '' , $ field_output = '' ) { $ inputParams = array ( 'carrier' => $ carrier , 'field_output' => $ field_output ) ; $ field_output = strtolower ( $ field_output ) ; $ this -> debug -> info ( __FUNCTION__ , 'Input Params: ' , $ inputParams ) ; try { $ vnCarrierData = DataRepository :: getData ( 'vn_carrier_data' ) ; $ this -> debug -> debug ( __FUNCTION__ , 'VN Carrier All Data: ' , $ vnCarrierData ) ; if ( array_key_exists ( $ carrier , $ vnCarrierData ) ) { $ isCarrier = $ vnCarrierData [ $ carrier ] ; $ this -> debug -> debug ( __FUNCTION__ , 'Is Carrier Data: ' , $ isCarrier ) ; if ( array_key_exists ( $ field_output , $ isCarrier ) ) { $ result = $ isCarrier [ $ field_output ] ; $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ result ) ; return $ result ; } if ( $ field_output = 'full' ) { $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ isCarrier ) ; return $ isCarrier ; } } } catch ( \ Exception $ e ) { $ message = 'Error File: ' . $ e -> getFile ( ) . ' - Line: ' . $ e -> getLine ( ) . ' - Code: ' . $ e -> getCode ( ) . ' - Message: ' . $ e -> getMessage ( ) ; $ this -> debug -> error ( __FUNCTION__ , $ message ) ; return NULL ; } return NULL ; }
3108	public function setCatValue ( $ assessmentSectionId , $ key , $ value ) { $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] = $ value ; return $ this ; }
2295	public static function getTinyTemplates ( ) { $ strDir = Config :: get ( 'uploadPath' ) . '/tiny_templates' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strDir ) ) { return '' ; } $ arrFiles = array ( ) ; $ arrTemplates = scan ( $ rootDir . '/' . $ strDir ) ; foreach ( $ arrTemplates as $ strFile ) { if ( strncmp ( '.' , $ strFile , 1 ) !== 0 && is_file ( $ rootDir . '/' . $ strDir . '/' . $ strFile ) ) { $ arrFiles [ ] = '{ title: "' . $ strFile . '", url: "' . $ strDir . '/' . $ strFile . '" }' ; } } return implode ( ",\n" , $ arrFiles ) . "\n" ; }
7749	public function getAllMetadata ( ) { $ metadata = array ( ) ; foreach ( $ this -> driver -> getAllClassNames ( ) as $ className ) { $ metadata [ ] = $ this -> getMetadataFor ( $ className ) ; } $ this -> validate ( $ metadata ) ; return $ metadata ; }
2127	protected function fixPaths ( $ content , $ arrFile ) { $ strName = $ arrFile [ 'name' ] ; if ( strpos ( $ strName , $ this -> strWebDir . '/' ) === 0 ) { $ strName = substr ( $ strName , \ strlen ( $ this -> strWebDir ) + 1 ) ; } $ strDirname = \ dirname ( $ strName ) ; $ strGlue = ( $ strDirname != '.' ) ? $ strDirname . '/' : '' ; return preg_replace_callback ( '/url\(("[^"\n]+"|\'[^\'\n]+\'|[^"\'\s()]+)\)/' , function ( $ matches ) use ( $ strDirname , $ strGlue ) { $ strData = $ matches [ 1 ] ; if ( $ strData [ 0 ] == '"' || $ strData [ 0 ] == "'" ) { $ strData = substr ( $ strData , 1 , - 1 ) ; } if ( strncmp ( $ strData , 'data:' , 5 ) === 0 || strncmp ( $ strData , 'http://' , 7 ) === 0 || strncmp ( $ strData , 'https://' , 8 ) === 0 || strncmp ( $ strData , '/' , 1 ) === 0 || strncmp ( $ strData , 'assets/css3pie/' , 15 ) === 0 ) { return $ matches [ 0 ] ; } if ( strncmp ( $ strData , '../' , 3 ) !== 0 ) { $ strData = '../../' . $ strGlue . $ strData ; } else { $ dir = $ strDirname ; while ( strncmp ( $ strData , '../' , 3 ) === 0 ) { $ dir = \ dirname ( $ dir ) ; $ strData = substr ( $ strData , 3 ) ; } $ glue = ( $ dir != '.' ) ? $ dir . '/' : '' ; $ strData = '../../' . $ glue . $ strData ; } $ strQuote = '' ; if ( $ matches [ 1 ] [ 0 ] == "'" || $ matches [ 1 ] [ 0 ] == '"' ) { $ strQuote = $ matches [ 1 ] [ 0 ] ; } if ( preg_match ( '/[(),\s"\']/' , $ strData ) ) { if ( $ matches [ 1 ] [ 0 ] == "'" ) { $ strData = str_replace ( "'" , "\\'" , $ strData ) ; } else { $ strQuote = '"' ; $ strData = str_replace ( '"' , '\"' , $ strData ) ; } } return 'url(' . $ strQuote . $ strData . $ strQuote . ')' ; } , $ content ) ; }
6627	public function getData ( $ defaultValue = null ) { return ArrayHelper :: getValue ( $ this -> parsedResponse , self :: RESPONSE_DATA_PARAM , $ defaultValue ) ; }
5755	public function select ( ? string $ columns = "*" , ? array $ whereColumnsInfo = null , ? string $ orderBy = null ) : ? array { if ( $ whereColumnsInfo != null ) { $ this -> validateWhere ( $ whereColumnsInfo ) ; } if ( is_array ( $ whereColumnsInfo ) && array_key_exists ( 'roles.role' , $ whereColumnsInfo ) ) { return $ this -> selectWithRoleSubquery ( $ columns , $ whereColumnsInfo , $ orderBy ) ; } $ columns = $ columns ?? $ this -> defaultSelectColumnsString ; $ orderBy = $ orderBy ?? $ this -> getOrderBy ( ) ; $ q = new SelectBuilder ( "SELECT $columns" , $ this -> getFromClause ( ) , $ whereColumnsInfo , $ orderBy ) ; $ pgResult = $ q -> execute ( ) ; if ( ! $ results = pg_fetch_all ( $ pgResult ) ) { $ results = null ; } pg_free_result ( $ pgResult ) ; return $ results ; }
997	public function offsetUnset ( $ offset ) { if ( $ offset === true ) { $ this -> trueValue = null ; $ this -> trueValueIsSet = false ; } elseif ( $ offset === false ) { $ this -> falseValue = null ; $ this -> falseValueIsSet = false ; } elseif ( is_int ( $ offset ) || is_string ( $ offset ) ) { unset ( $ this -> standardStore [ $ offset ] ) ; } elseif ( is_float ( $ offset ) ) { unset ( $ this -> floatStore [ ( string ) $ offset ] ) ; } elseif ( is_object ( $ offset ) ) { $ this -> objectStore -> offsetUnset ( $ offset ) ; } elseif ( is_array ( $ offset ) ) { $ index = array_search ( $ offset , $ this -> arrayKeys , true ) ; if ( $ index !== false ) { array_splice ( $ this -> arrayKeys , $ index , 1 ) ; array_splice ( $ this -> arrayValues , $ index , 1 ) ; } } elseif ( $ offset === null ) { $ this -> nullValue = null ; $ this -> nullValueIsSet = false ; } }
9231	public function actionIndex ( $ format = false , $ arraymap = false , $ term = false , $ category = false , $ time = false ) { $ searchModel = new PostSearch ( ) ; $ req = Yii :: $ app -> request -> queryParams ; if ( $ term ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "term" ] = $ term ; } if ( $ category ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "category" ] = $ category ; } if ( $ time ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "time" ] = $ time ; } $ dataProvider = $ searchModel -> search ( $ req ) ; $ query = $ dataProvider -> query ; $ query -> andWhere ( [ 'status' => [ 1 ] ] ) ; if ( $ format == 'json' ) { $ model = [ ] ; foreach ( $ dataProvider -> getModels ( ) as $ d ) { $ obj = $ d -> attributes ; if ( $ arraymap ) { $ map = explode ( "," , $ arraymap ) ; if ( count ( $ map ) == 1 ) { $ obj = ( isset ( $ d [ $ arraymap ] ) ? $ d [ $ arraymap ] : null ) ; } else { $ obj = [ ] ; foreach ( $ map as $ a ) { $ k = explode ( ":" , $ a ) ; $ v = ( count ( $ k ) > 1 ? $ k [ 1 ] : $ k [ 0 ] ) ; $ obj [ $ k [ 0 ] ] = ( $ v == "Obj" ? json_encode ( $ d -> attributes ) : ( isset ( $ d -> $ v ) ? $ d -> $ v : null ) ) ; } } } if ( $ term ) { if ( ! in_array ( $ obj , $ model ) ) { array_push ( $ model , $ obj ) ; } } else { array_push ( $ model , $ obj ) ; } } header ( "Access-Control-Allow-Origin: *" ) ; header ( "Access-Control-Expose-Headers: X-Pagination-Per-Page,X-Pagination-Current-Page,X-Pagination-Page-Count,X-Pagination-Total-Count,Content-Type,Location" ) ; return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , ] ) ; } }
1790	private function prepareAlias ( string $ alias , array & $ parameters ) : void { if ( 'index' === $ alias ) { return ; } $ hasAutoItem = false ; $ autoItems = $ this -> getAutoItems ( $ parameters ) ; $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ parameters [ 'alias' ] = preg_replace_callback ( '/\{([^\}]+)\}/' , static function ( array $ matches ) use ( $ alias , & $ parameters , $ autoItems , & $ hasAutoItem , $ config ) : string { $ param = $ matches [ 1 ] ; if ( ! isset ( $ parameters [ $ param ] ) ) { throw new MissingMandatoryParametersException ( sprintf ( 'Parameters "%s" is missing to generate a URL for "%s"' , $ param , $ alias ) ) ; } $ value = $ parameters [ $ param ] ; unset ( $ parameters [ $ param ] ) ; if ( $ hasAutoItem || ! $ config -> get ( 'useAutoItem' ) || ! \ in_array ( $ param , $ autoItems , true ) ) { return $ param . '/' . $ value ; } $ hasAutoItem = true ; return $ value ; } , $ alias ) ; }
1889	protected function getPathNodes ( ) { if ( ! $ this -> varValue ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } foreach ( $ this -> varValue as $ id ) { $ arrPids = $ this -> Database -> getParentRecords ( $ id , 'tl_page' ) ; array_shift ( $ arrPids ) ; $ this -> arrNodes = array_merge ( $ this -> arrNodes , $ arrPids ) ; } }
4841	public function fetch_sub_resource ( $ type , $ params = array ( ) ) { $ endpoint = preg_replace ( '/api\/v[0-9]+\//' , '' , parse_url ( $ this -> sub_resource_uris [ $ type ] , PHP_URL_PATH ) ) ; $ sub_resource_params = array ( ) ; if ( $ param_string = parse_url ( $ this -> sub_resource_uris [ $ type ] , PHP_URL_QUERY ) ) { $ split_params = explode ( '&' , $ param_string ) ; foreach ( $ split_params as $ split_param ) { $ parts = explode ( '=' , $ split_param ) ; $ sub_resource_params [ $ parts [ 0 ] ] = $ parts [ 1 ] ; } } $ params = array_merge ( $ params , $ sub_resource_params ) ; $ class = 'GoCardless_' . GoCardless_Utils :: camelize ( GoCardless_Utils :: singularize ( $ type ) ) ; $ objects = array ( ) ; foreach ( $ this -> client -> request ( 'get' , $ endpoint , $ params ) as $ value ) { $ objects [ ] = new $ class ( $ this -> client , $ value ) ; } return $ objects ; }
4373	protected function buildArgString ( $ args , $ sanitize = true ) { $ glue = ', ' ; $ glueAfterFirst = true ; if ( \ is_string ( $ args [ 0 ] ) ) { if ( \ preg_match ( '/[=:] ?$/' , $ args [ 0 ] ) ) { $ glueAfterFirst = false ; } elseif ( \ count ( $ args ) == 2 ) { $ glue = ' = ' ; } } foreach ( $ args as $ i => $ v ) { $ args [ $ i ] = $ i > 0 ? $ this -> dump ( $ v , $ sanitize ) : $ this -> dump ( $ v , false ) ; } if ( ! $ glueAfterFirst ) { return $ args [ 0 ] . \ implode ( $ glue , \ array_slice ( $ args , 1 ) ) ; } else { return \ implode ( $ glue , $ args ) ; } }
7380	public function fetchEscape ( string $ key , \ mysqli $ db , string $ default = '' ) : string { return $ db -> real_escape_string ( $ this -> fetch ( $ key , $ default ) ) ; }
10281	public static function absoluteCoordinate ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } list ( $ column , $ row ) = self :: coordinateFromString ( $ pCoordinateString ) ; $ column = ltrim ( $ column , '$' ) ; $ row = ltrim ( $ row , '$' ) ; return $ worksheet . '$' . $ column . '$' . $ row ; }
2183	public function create ( ) : ItemInterface { $ tree = $ this -> factory -> createItem ( 'root' ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: BACKEND_MENU_BUILD , new MenuEvent ( $ this -> factory , $ tree ) ) ; return $ tree ; }
10771	public function registerMediaType ( $ mediaType ) { if ( $ this -> check ( $ mediaType ) ) { $ this -> mediaTypes [ ( new \ ReflectionClass ( $ mediaType ) ) -> getConstant ( 'NAME' ) ] = $ mediaType ; return $ this ; } else { throw new \ Exception ( 'registered MediaType must implement \MandarinMedien\MMMediaBundle\Model\MediaTypeInterface' ) ; } }
4812	public function add ( $ name , $ value ) { if ( array_key_exists ( $ name , $ this -> storage ) ) { throw new AlreadyDefinedException ( sprintf ( 'Context value with key `%s` already defined' , $ name ) ) ; } $ this -> storage [ $ name ] = $ value ; }
6386	public function readUser ( $ id ) { $ model = $ this -> readObject ( $ id , 'user' ) ; $ model -> url = $ this -> cfg -> wwwroot ; $ model -> fullname = $ this -> fullname ( $ model ) ; if ( isset ( $ model -> password ) ) { unset ( $ model -> password ) ; } if ( isset ( $ model -> secret ) ) { unset ( $ model -> secret ) ; } if ( isset ( $ model -> lastip ) ) { unset ( $ model -> lastip ) ; } return $ model ; }
6442	public function getAllResources ( $ name , $ full = false , array $ filters = [ ] , array $ fields = [ ] ) { $ this -> lastRequest = new Request ; $ this -> lastRequest -> setMode ( Request :: MODE_READ ) ; $ this -> lastRequest -> setResourceName ( $ name ) ; if ( $ full ) { $ this -> lastRequest -> enableFullResults ( ) ; } $ this -> lastRequest -> setFilters ( $ filters ) ; $ this -> lastRequest -> setFields ( $ fields ) ; $ data = [ ] ; $ page = 1 ; do { $ this -> lastRequest -> setCurrentPage ( $ page ) ; $ response = $ this -> proceed ( ) ; $ data = ArrayUtils :: merge ( $ data , $ response -> getData ( ) -> getData ( ) ) ; $ page ++ ; } while ( $ response -> getPagination ( ) -> getPage ( ) != $ response -> getPagination ( ) -> getPages ( ) ) ; return $ data ; }
2844	public function renderTreeNode ( Varien_Data_Tree_Node $ node , $ indentLevel = 0 ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ block -> setRequestInfo ( $ this -> getRequestInfo ( ) ) ; $ block -> setTemplate ( 'sheep_debug/view/panel/_block_node.phtml' ) ; $ block -> setNode ( $ node ) ; $ block -> setIndent ( $ indentLevel ) ; return $ block -> toHtml ( ) ; }
11862	public function setPairedDataItem ( DataItem $ value ) { $ this -> _pairedDataItem = $ value ; if ( ! isset ( $ this -> _localObject ) && isset ( $ value -> localObject ) ) { $ this -> localObject = $ value -> localObject ; } if ( ! isset ( $ this -> _foreignObject ) && isset ( $ value -> foreignObject ) ) { $ this -> foreignObject = $ value -> foreignObject ; } if ( $ value -> handledDataItem ) { $ this -> handledDataItem = $ value -> handledDataItem ; } }
7767	public function loadMetadataForClass ( $ className ) { foreach ( $ this -> drivers as $ namespace => $ driver ) { if ( strpos ( $ className , $ namespace ) === 0 ) { return $ driver -> loadMetadataForClass ( $ className ) ; } } return null ; }
7199	protected function assignSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> assignSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> assignSaleItemRecursively ( $ child ) ; } }
2405	public function minifyHtml ( $ strHtml ) { if ( Config :: get ( 'debugMode' ) ) { return $ strHtml ; } $ arrChunks = preg_split ( '@(</?pre[^>]*>)|(</?script[^>]*>)|(</?style[^>]*>)|( ?</?textarea[^>]*>)@i' , $ strHtml , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; $ strHtml = '' ; $ blnPreserveNext = false ; $ blnOptimizeNext = false ; $ strType = null ; $ isJavaScript = function ( $ strChunk ) { $ typeMatch = array ( ) ; if ( preg_match ( '/\stype\s*=\s*(?:(?J)(["\'])\s*(?<type>.*?)\s*\1|(?<type>[^\s>]+))/i' , $ strChunk , $ typeMatch ) && ! \ in_array ( strtolower ( $ typeMatch [ 'type' ] ) , static :: $ validJavaScriptTypes ) ) { return false ; } if ( preg_match ( '/\slanguage\s*=\s*(?:(?J)(["\'])\s*(?<type>.*?)\s*\1|(?<type>[^\s>]+))/i' , $ strChunk , $ typeMatch ) && ! \ in_array ( 'text/' . strtolower ( $ typeMatch [ 'type' ] ) , static :: $ validJavaScriptTypes ) ) { return false ; } return true ; } ; foreach ( $ arrChunks as $ strChunk ) { if ( strncasecmp ( $ strChunk , '<pre' , 4 ) === 0 || strncasecmp ( ltrim ( $ strChunk ) , '<textarea' , 9 ) === 0 ) { $ blnPreserveNext = true ; } elseif ( strncasecmp ( $ strChunk , '<script' , 7 ) === 0 ) { if ( $ isJavaScript ( $ strChunk ) ) { $ blnOptimizeNext = true ; $ strType = 'js' ; } else { $ blnPreserveNext = true ; } } elseif ( strncasecmp ( $ strChunk , '<style' , 6 ) === 0 ) { $ blnOptimizeNext = true ; $ strType = 'css' ; } elseif ( $ blnPreserveNext ) { $ blnPreserveNext = false ; } elseif ( $ blnOptimizeNext ) { $ blnOptimizeNext = false ; if ( $ strType == 'js' ) { $ objMinify = new Minify \ JS ( ) ; $ objMinify -> add ( $ strChunk ) ; $ strChunk = $ objMinify -> minify ( ) ; } elseif ( $ strType == 'css' ) { $ objMinify = new Minify \ CSS ( ) ; $ objMinify -> add ( $ strChunk ) ; $ strChunk = $ objMinify -> minify ( ) ; } } else { $ strChunk = str_replace ( "\r" , '' , $ strChunk ) ; $ strChunk = preg_replace ( array ( '/^[\t ]+/m' , '/[\t ]+$/m' , '/\n\n+/' ) , array ( '' , '' , "\n" ) , $ strChunk ) ; } $ strHtml .= $ strChunk ; } return trim ( $ strHtml ) ; }
2603	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ dictionaryName = Config :: CONFIG_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ currActiveVersion , $ dictionaryName ) ; if ( ! $ dictionary ) { return $ result -> setData ( [ 'status' => false ] ) ; } $ dictionaryItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; foreach ( $ dictionaryItems as $ item ) { if ( $ item -> item_key == Config :: CONFIG_DICTIONARY_KEY && $ item -> item_value == 1 ) { return $ result -> setData ( [ 'status' => true ] ) ; } } return $ result -> setData ( [ 'status' => false ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2314	protected function prepareImage ( ) { if ( $ this -> fileObj -> isSvgImage ) { $ imagine = System :: getContainer ( ) -> get ( 'contao.image.imagine_svg' ) ; } else { $ imagine = System :: getContainer ( ) -> get ( 'contao.image.imagine' ) ; } $ image = new NewImage ( $ this -> strRootDir . '/' . $ this -> fileObj -> path , $ imagine , System :: getContainer ( ) -> get ( 'filesystem' ) ) ; $ image -> setImportantPart ( $ this -> prepareImportantPart ( ) ) ; return $ image ; }
5844	public function saveAdditionalFields ( array $ submittedData , \ TYPO3 \ CMS \ Scheduler \ Task \ AbstractTask $ task ) { $ task -> directories = trim ( $ submittedData [ 'scheduler_batchResize_directories' ] ) ; $ task -> excludeDirectories = trim ( $ submittedData [ 'scheduler_batchResize_excludeDirectories' ] ) ; }
7340	public function sendAttachment ( Chat $ chat , User $ recipient , Attachment $ attachment ) : void { $ type = $ attachment -> getType ( ) ; $ request = null ; switch ( $ type ) { case Attachment :: TYPE_FILE : $ request = new SendDocument ( ) ; $ request -> document = new InputFile ( $ attachment -> getPath ( ) ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; break ; case Attachment :: TYPE_IMAGE : $ request = new SendPhoto ( ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; break ; case Attachment :: TYPE_AUDIO : $ request = new SendAudio ( ) ; $ request -> chat_id = $ chat -> getId ( ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; $ request -> duration = $ attachment -> getParameters ( ) -> get ( 'duration' ) ; $ request -> performer = $ attachment -> getParameters ( ) -> get ( 'performer' ) ; $ request -> title = $ attachment -> getParameters ( ) -> get ( 'title' ) ; break ; case Attachment :: TYPE_VIDEO : $ request = new SendVideo ( ) ; $ request -> duration = $ attachment -> getParameters ( ) -> get ( 'duration' ) ; $ request -> width = $ attachment -> getParameters ( ) -> get ( 'width' ) ; $ request -> height = $ attachment -> getParameters ( ) -> get ( 'height' ) ; $ request -> caption = $ attachment -> getParameters ( ) -> get ( 'caption' ) ; break ; } if ( $ request ) { $ request -> chat_id = $ chat -> getId ( ) ; $ request -> disable_notification = $ attachment -> getParameters ( ) -> get ( 'disable_notification' ) ; $ request -> reply_to_message_id = $ attachment -> getParameters ( ) -> get ( 'reply_to_message_id' ) ; $ request -> reply_markup = $ attachment -> getParameters ( ) -> get ( 'reply_markup' ) ; $ this -> client -> performApiRequest ( $ request ) ; $ this -> loop -> run ( ) ; } }
12420	public function dt ( $ domain , $ singular ) { $ singular = ( string ) $ singular ; try { $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { if ( ( $ string = $ object -> translate ( $ singular , $ domain , $ locale ) ) != $ singular ) { return $ string ; } } } catch ( \ Exception $ e ) { ; } return ( string ) $ singular ; }
10665	public function enableBlockMode ( ) : void { if ( ! $ this -> enableProtection ) { throw new MiddlewareException ( $ this , "You can't enable the block mode because the XSS protection is disabled" ) ; } if ( $ this -> reportUri ) { throw new MiddlewareException ( $ this , sprintf ( "You can't enable the block mode because the report mode is already enabled (see %s)" , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/X-XSS-Protection' ) ) ; } $ this -> blockMode = true ; }
7845	public function send ( array $ destinations , string $ text ) : ? array { $ this -> checkConfig ( ) ; $ messages = [ ] ; foreach ( $ destinations as $ destination ) { $ messages [ ] = [ 'phone_number' => $ destination , 'message' => $ text , 'device_id' => $ this -> device , ] ; } $ body = Body :: json ( $ messages ) ; $ response = Request :: post ( $ this -> baseUrl . 'message/send' , [ ] , $ body ) ; if ( $ response -> code == 200 ) { return [ 'code' => $ response -> code , 'message' => 'OK' , 'data' => $ response -> body , ] ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } return [ 'code' => $ response -> code , 'message' => $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } }
2797	public function getAdapter ( ) { if ( is_null ( $ this -> adapter ) ) { $ name = ucfirst ( strtolower ( $ this -> get ( 'adapter' ) ) ) ; $ class = '\\Humbug\\Adapter\\' . $ name ; $ this -> adapter = new $ class ; } return $ this -> adapter ; }
12730	public function renderStraight ( Zend_Navigation_Container $ container = null ) { if ( $ container === null ) { $ container = $ this -> getContainer ( ) ; } if ( ! $ active = $ this -> findActive ( $ container ) ) { return '' ; } $ active = $ active [ 'page' ] ; if ( $ this -> getLinkLast ( ) ) { $ html = '<li>' . $ this -> htmlify ( $ active ) . '</li>' ; } else { $ html = $ active -> getLabel ( ) ; if ( $ this -> getUseTranslator ( ) && $ t = $ this -> getTranslator ( ) ) { $ html = $ t -> translate ( $ html ) ; } $ html = '<li class="active">' . $ this -> view -> escape ( $ html ) . '</li>' ; } while ( ( $ parent = $ active -> getParent ( ) ) != null ) { if ( $ parent instanceof Zend_Navigation_Page ) { $ html = '<li>' . $ this -> htmlify ( $ parent ) . ' <span class="divider">' . $ this -> getSeparator ( ) . '</span></li>' . PHP_EOL . $ html ; } if ( $ parent === $ container ) { break ; } $ active = $ parent ; } return strlen ( $ html ) ? $ this -> getIndent ( ) . '<ul class="breadcrumb">' . $ html . '</ul>' : '' ; }
1966	public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { if ( static :: $ strPk == 'id' ) { return static :: findById ( $ varValue , $ arrOptions ) ; } return parent :: findByPk ( $ varValue , $ arrOptions ) ; }
9369	protected function resolve ( ContainerInterface $ container , ServerRequestInterface $ request , ResponseInterface $ response ) { if ( class_exists ( 'Zend\Diactoros\ServerRequestFactory' ) ) { $ response = new ZendResponse ; $ request = ServerRequestFactory :: fromGlobals ( ) ; } $ container -> set ( 'Psr\Http\Message\ServerRequestInterface' , $ request ) ; return $ container -> set ( 'Psr\Http\Message\ResponseInterface' , $ response ) ; }
7091	protected function match ( Request $ request ) { foreach ( $ this -> routes as $ route ) { if ( $ route -> method ( ) === $ request -> method ( ) && $ route -> match ( $ request -> url ( ) ) ) { if ( $ action = $ route -> action ( ) ) { try { $ response = $ action ( $ request , $ route -> args ( ) ) ; if ( $ response !== false ) return $ response ; } catch ( AbortRouteException $ abort ) { return $ abort -> response ( ) ; } } else return null ; } } return false ; }
4260	public function hasSubscribers ( $ eventName = null ) { if ( $ eventName !== null ) { return ! empty ( $ this -> subscribers [ $ eventName ] ) ; } foreach ( $ this -> subscribers as $ subscribers ) { if ( $ subscribers ) { return true ; } } return false ; }
2643	private function _purge ( $ uri , $ type , $ method = \ Zend_Http_Client :: POST , $ payload = null ) { if ( $ method == 'PURGE' ) { $ expiration = time ( ) + self :: PURGE_TOKEN_LIFETIME ; $ zendUri = \ Zend_Uri :: factory ( $ uri ) ; $ path = $ zendUri -> getPath ( ) ; $ stringToSign = $ path . $ expiration ; $ signature = hash_hmac ( 'sha1' , $ stringToSign , $ this -> config -> getServiceId ( ) ) ; $ token = $ expiration . '_' . urlencode ( $ signature ) ; $ headers = [ self :: FASTLY_HEADER_TOKEN . ': ' . $ token ] ; } else { $ headers = [ self :: FASTLY_HEADER_AUTH . ': ' . $ this -> config -> getApiKey ( ) ] ; } if ( $ this -> config -> canUseSoftPurge ( ) ) { array_push ( $ headers , self :: FASTLY_HEADER_SOFT_PURGE . ': 1' ) ; } $ result [ 'status' ] = true ; try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> setConfig ( [ 'timeout' => self :: PURGE_TIMEOUT ] ) ; if ( $ method == 'PURGE' ) { $ client -> addOption ( CURLOPT_CUSTOMREQUEST , 'PURGE' ) ; } $ client -> write ( $ method , $ uri , '1.1' , $ headers , $ payload ) ; $ responseBody = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; $ responseMessage = \ Zend_Http_Response :: extractMessage ( $ responseBody ) ; $ client -> close ( ) ; if ( $ responseCode == '429' ) { throw new LocalizedException ( __ ( $ responseMessage ) ) ; } elseif ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( $ responseCode . ': ' . $ responseMessage ) ) ; } } catch ( \ Exception $ e ) { $ this -> logger -> critical ( $ e -> getMessage ( ) , $ uri ) ; $ result [ 'status' ] = false ; $ result [ 'msg' ] = $ e -> getMessage ( ) ; } if ( empty ( $ type ) ) { return $ result ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishPurgeChanges ( ) ) { $ this -> sendWebHook ( '*initiated ' . $ type . '*' ) ; if ( $ this -> config -> canPublishPurgeDebugBacktrace ( ) == false ) { return $ result ; } $ this -> stackTrace ( $ type ) ; } return $ result ; }
9020	public function getUniqueWords ( $ string ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ words = $ analysis -> getKeyValuesByFrequency ( ) ; return array_unique ( array_keys ( $ words ) ) ; }
1144	protected function bootstrapConfigs ( ) { $ configFile = realpath ( __DIR__ . '/../config/jsvalidation.php' ) ; $ this -> mergeConfigFrom ( $ configFile , 'jsvalidation' ) ; $ this -> publishes ( [ $ configFile => $ this -> app [ 'path.config' ] . '/jsvalidation.php' ] , 'config' ) ; }
6941	private function getPurchaseCost ( Model \ SaleItemInterface $ item ) { if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ item ) ) { return null ; } $ currency = $ item -> getSale ( ) -> getCurrency ( ) -> getCode ( ) ; if ( null !== $ cost = $ this -> purchaseCostGuesser -> guess ( $ subject , $ currency ) ) { return $ cost ; } return null ; }
10774	protected function loginByCookie ( ) { $ value = Yii :: $ app -> getRequest ( ) -> getCookies ( ) -> getValue ( $ this -> identityCookie [ 'name' ] ) ; if ( $ value === null ) { return ; } $ data = json_decode ( $ value , true ) ; if ( count ( $ data ) !== 3 || ! isset ( $ data [ 0 ] , $ data [ 1 ] , $ data [ 2 ] ) ) { return ; } list ( $ id , $ authKey , $ duration ) = $ data ; $ class = $ this -> identityClass ; $ identity = $ class :: findIdentity ( $ id ) ; if ( $ identity === null ) { return ; } elseif ( ! $ identity instanceof IdentityInterface ) { throw new InvalidValueException ( "$class::findIdentity() must return an object implementing IdentityInterface." ) ; } if ( $ identity -> validateAuthKey ( $ authKey ) ) { if ( $ this -> beforeLogin ( $ identity , true , $ duration ) ) { $ this -> switchIdentity ( $ identity , $ this -> autoRenewCookie ? $ duration : 0 ) ; $ ip = Yii :: $ app -> getRequest ( ) -> getUserIP ( ) ; Yii :: info ( "User '$id' logged in from $ip via cookie." , __METHOD__ ) ; $ this -> afterLogin ( $ identity , true , $ duration ) ; } } else { Yii :: warning ( "Invalid auth key attempted for user '$id': $authKey" , __METHOD__ ) ; } }
12932	protected function generateContentAttribute ( $ name , $ value , $ type = 'text' ) { $ attribute = new ContentAttribute ( ) ; $ attribute -> setName ( $ name ) ; $ attribute -> setValue ( $ value ) ; if ( is_array ( $ value ) ) { $ value = '' ; } $ attribute -> setStringValue ( $ value ) ; $ attribute -> setType ( $ type ) ; return $ attribute ; }
1491	public static function camelize ( $ data ) { return collect ( $ data ) -> mapWithKeys ( function ( $ value , $ key ) { $ key = Str :: camelize ( $ key ) ; if ( is_array ( $ value ) ) { return [ $ key => static :: camelize ( $ value ) ] ; } return [ $ key => $ value ] ; } ) -> all ( ) ; }
9613	public function register ( Container $ app ) { $ app [ 'guzzle.handler_stack' ] = function ( ) { $ stack = HandlerStack :: create ( ) ; return $ stack ; } ; $ app [ 'guzzle' ] = function ( ) use ( $ app ) { $ client = new HttpClient ( [ 'handler' => $ app [ 'guzzle.handler_stack' ] ] ) ; return $ client ; } ; }
11614	public function update ( $ account , $ nickname ) { $ params = [ 'kf_account' => $ account , 'nickname' => $ nickname , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
8734	public function increment ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> increment ( $ column , $ amount , $ extra ) ; }
2167	protected static function generateHelperObject ( $ value ) { $ return = new \ stdClass ( ) ; if ( ! \ is_array ( $ value ) ) { $ return -> value = rtrim ( $ value , "\x00" ) ; $ return -> isUuid = ( \ strlen ( $ value ) == 16 && ! is_numeric ( $ return -> value ) && strncmp ( $ return -> value , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value ) && $ return -> value > 0 ) ; } else { $ return -> value = array_map ( function ( $ var ) { return rtrim ( $ var , "\x00" ) ; } , $ value ) ; $ return -> isUuid = ( \ strlen ( $ value [ 0 ] ) == 16 && ! is_numeric ( $ return -> value [ 0 ] ) && strncmp ( $ return -> value [ 0 ] , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value [ 0 ] ) && $ return -> value [ 0 ] > 0 ) ; } return $ return ; }
2324	public static function validate ( $ strToken ) { if ( Config :: get ( 'disableRefererCheck' ) || \ defined ( 'BYPASS_TOKEN_CHECK' ) ) { return true ; } if ( Config :: get ( 'requestTokenWhitelist' ) ) { $ strHostname = gethostbyaddr ( $ _SERVER [ 'REMOTE_ADDR' ] ) ; foreach ( Config :: get ( 'requestTokenWhitelist' ) as $ strDomain ) { if ( $ strDomain == $ strHostname || preg_match ( '/\.' . preg_quote ( $ strDomain , '/' ) . '$/' , $ strHostname ) ) { return true ; } } } $ container = System :: getContainer ( ) ; return $ container -> get ( 'contao.csrf.token_manager' ) -> isTokenValid ( new CsrfToken ( $ container -> getParameter ( 'contao.csrf_token_name' ) , $ strToken ) ) ; }
3619	public function cancelFanModeOnWithTimer ( $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'fan_timer_timeout' => 0 ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
12074	public function childIndex ( FilterRequest $ filters , $ id , $ relation ) { $ id = $ this -> getRealId ( $ id ) ; $ resource = $ this -> repository -> getChilds ( $ id , $ relation , $ filters ) ; if ( ! $ resource || count ( $ resource ) < 1 ) { } return $ this -> success ( $ resource ) ; }
10849	protected function fillDocument ( Document $ document , object $ object ) : bool { if ( $ object instanceof SearchableEntity ) { return $ object -> indexEntity ( $ document ) ; } $ mapping = $ this -> getMapping ( \ get_class ( $ object ) ) ; $ accessor = PropertyAccess :: createPropertyAccessor ( ) ; foreach ( $ mapping as $ fieldName => $ propertyPath ) { $ document -> addField ( $ fieldName , $ accessor -> getValue ( $ object , $ propertyPath ) ) ; } return true ; }
10847	protected function runCommand ( $ command , $ basePath , $ asset , $ result ) { $ command = Yii :: getAlias ( $ command ) ; $ command = strtr ( $ command , [ '{from}' => escapeshellarg ( "$basePath/$asset" ) , '{to}' => escapeshellarg ( "$basePath/$result" ) , ] ) ; $ descriptor = [ 1 => [ 'pipe' , 'w' ] , 2 => [ 'pipe' , 'w' ] , ] ; $ pipes = [ ] ; $ proc = proc_open ( $ command , $ descriptor , $ pipes , $ basePath ) ; $ stdout = stream_get_contents ( $ pipes [ 1 ] ) ; $ stderr = stream_get_contents ( $ pipes [ 2 ] ) ; foreach ( $ pipes as $ pipe ) { fclose ( $ pipe ) ; } $ status = proc_close ( $ proc ) ; if ( $ status === 0 ) { Yii :: trace ( "Converted $asset into $result:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" , __METHOD__ ) ; } elseif ( YII_DEBUG ) { throw new Exception ( "AssetConverter command '$command' failed with exit code $status:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" ) ; } else { Yii :: error ( "AssetConverter command '$command' failed with exit code $status:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" , __METHOD__ ) ; } return $ status === 0 ; }
2932	public function setKey ( $ key , $ value = null , $ comment = null , $ export = false ) { $ data = [ compact ( 'key' , 'value' , 'comment' , 'export' ) ] ; return $ this -> setKeys ( $ data ) ; }
11001	public function setLocale ( $ locale ) { $ locale = WF :: cast_array ( $ locale ) ; foreach ( $ locale as $ l ) $ this -> locales [ ] = new Locale ( $ l ) ; $ this -> locales = array_unique ( $ this -> locales ) ; return $ this ; }
9293	protected function getAssetsUrl ( ) { if ( ! isset ( $ this -> _assetsUrl ) ) { $ path = dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'assets' ; $ this -> _assetsUrl = Yii :: app ( ) -> assetManager -> publish ( $ path , false , - 1 , $ this -> forceCopyAssets ) ; } return $ this -> _assetsUrl ; }
2937	public function restore ( $ filePath = null ) { if ( is_null ( $ filePath ) ) { $ latestBackup = $ this -> getLatestBackup ( ) ; if ( is_null ( $ latestBackup ) ) { throw new NoBackupAvailableException ( "There are no available backups!" ) ; } $ filePath = $ latestBackup [ 'filepath' ] ; } if ( ! is_file ( $ filePath ) ) { throw new FileNotFoundException ( "File does not exist at path {$filePath}" ) ; } copy ( $ filePath , $ this -> filePath ) ; $ this -> writer -> setBuffer ( $ this -> getContent ( ) ) ; return $ this ; }
10556	public function make ( Log $ log , $ trans = true ) { $ items = [ ] ; $ route = 'dashboard.systems.logs.show' ; foreach ( $ log -> tree ( $ trans ) as $ level => $ item ) { $ items [ $ level ] = array_merge ( $ item , [ 'url' => route ( $ route , [ $ log -> date , $ level ] ) , 'icon' => $ this -> styler -> icon ( $ level ) ? : '' , ] ) ; } return $ items ; }
2330	public function next ( ) { if ( ! isset ( $ this -> arrModels [ $ this -> intIndex + 1 ] ) ) { return false ; } ++ $ this -> intIndex ; return $ this ; }
5086	public function startTransaction ( ) : bool { if ( $ this -> isInTransaction ) throw new AlreadyInTransactionException ( ) ; $ this -> isInTransaction = $ this -> executeDirect ( 'START TRANSACTION' ) ; return $ this -> isInTransaction ; }
8110	public static function start ( ) { $ compatibility = [ self :: SUBSITES => null , ] ; if ( ClassInfo :: exists ( Subsite :: class ) ) { $ compatibility [ self :: SUBSITES ] = Subsite :: $ disable_subsite_filter ; Subsite :: disable_subsite_filter ( true ) ; } return $ compatibility ; }
11772	public function resolve ( ) : array { try { $ app_required_modules = array_unique ( $ this -> required_modules ) ; $ component_dependency_map = $ this -> getComponentDependencyMap ( $ app_required_modules ) ; $ component_type_list = $ this -> resolveComponentDependencyMap ( $ component_dependency_map ) ; $ component_module_list = [ ] ; foreach ( $ component_type_list as $ component_type ) { $ component_module = $ this -> findComponentModuleByType ( $ app_required_modules , $ component_type ) ; if ( ! $ component_module ) { throw new ModuleDependencyResolverException ( 'Could not find component module: ' . $ component_type ) ; } if ( ! in_array ( $ component_module , $ component_module_list ) ) { $ component_module_list [ ] = $ component_module ; } } $ module_list = array_merge ( $ component_module_list , $ app_required_modules ) ; $ module_dependency_map = self :: getModuleDependencyMap ( $ module_list ) ; $ resolved_list = $ this -> resolveModuleDependencyMap ( $ module_dependency_map ) ; return $ resolved_list ; } catch ( \ Throwable $ e ) { throw new ModuleDependencyResolverException ( __METHOD__ . ' failed: ' . $ e -> getMessage ( ) , $ e ) ; } }
5840	protected function crop ( Builder $ url , $ args ) { $ url -> crop ( $ args [ 'top_left_x' ] , $ args [ 'top_left_y' ] , $ args [ 'bottom_right_x' ] , $ args [ 'bottom_right_y' ] ) ; }
11479	protected function send ( RequestInterface $ request ) : ResponseInterface { $ request = $ request -> withHeader ( "Authorization" , sprintf ( "Bearer %s" , $ this -> apiToken ) ) ; $ request = $ request -> withHeader ( "Content-Type" , "application/json" ) ; $ request = $ request -> withHeader ( "Accept" , "application/json" ) ; try { $ response = $ this -> client -> send ( $ request ) ; } catch ( GuzzleException $ e ) { if ( $ e -> getCode ( ) === 401 ) { throw new ClientException ( "Authorization failed. Did you specify the right api token?" , $ request , null , $ e ) ; } throw new ClientException ( sprintf ( "Failed to execute request (code %d): %s" , $ e -> getCode ( ) , $ e -> getMessage ( ) ) , $ request , null , $ e ) ; } return $ response ; }
4680	public function render ( ContainerInterface $ di = null ) { switch ( $ this -> type ) { case "file" : if ( $ di -> has ( "viewRenderFile" ) ) { $ viewRender = $ di -> get ( "viewRenderFile" ) ; } else { $ viewRender = new ViewRenderFile ( $ di ) ; $ viewRender -> setDI ( $ di ) ; } $ viewRender -> render ( $ this -> template , $ this -> templateData ) ; break ; case "callback" : if ( ! is_callable ( $ this -> template ) ) { throw new Exception ( "View is expecting a valid callback, provided callback seems to not be a callable." ) ; } echo call_user_func ( $ this -> template , $ this -> templateData ) ; break ; case "string" : echo $ this -> template ; break ; case "empty" : break ; default : throw new Exception ( "Not a valid template type: '{$this->type}'." ) ; } }
2778	public function cloneRepository ( string $ repository , ? string $ directory = null , array $ options = [ ] ) : GitWorkingCopy { if ( $ directory === null ) { $ directory = self :: parseRepositoryName ( $ repository ) ; } $ git = $ this -> workingCopy ( $ directory ) ; $ git -> cloneRepository ( $ repository , $ options ) ; $ git -> setCloned ( true ) ; return $ git ; }
11145	protected function scanDir ( $ dir ) { $ result = array ( ) ; $ list = $ this -> scanDirExec ( $ dir ) ; foreach ( $ list as $ element ) { $ elementPath = $ dir . DIRECTORY_SEPARATOR . $ element ; if ( is_file ( $ elementPath ) ) { $ fileInfo = pathinfo ( $ element ) ; if ( in_array ( $ fileInfo [ 'extension' ] , $ this -> getAllowedFileExtensions ( ) ) ) { $ result [ ] = $ this -> getNameSpace ( ) . "\\" . $ fileInfo [ 'filename' ] ; } } } return $ result ; }
6080	public function updateProperties ( $ id , array $ properties ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'properties' => $ properties ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/media/' . $ id . '/properties' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
1697	public function removeFrontendAuthentication ( ) : bool { if ( ! $ this -> session -> isStarted ( ) || ! $ this -> session -> has ( FrontendUser :: SECURITY_SESSION_KEY ) ) { return false ; } $ this -> session -> remove ( FrontendUser :: SECURITY_SESSION_KEY ) ; return true ; }
3804	private function buildCondition ( $ condition , $ metaModel ) { if ( null === $ condition ) { return null ; } return $ this -> conditionFactory -> createCondition ( $ condition , $ metaModel ) ; }
6732	protected function processMessage ( & $ message ) { if ( ! $ message instanceof \ Closure ) { return ; } $ callback = $ message ; $ message = $ callback ( $ this -> model ) ; }
5656	private function walkChildren ( $ node ) { if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ this -> walkTree ( $ child ) ; } } }
12473	private function lookForPreMinifiedAsset ( ) { $ min_path = ( string ) Str :: s ( $ this -> file -> getRealPath ( ) ) -> replace ( '.' . $ this -> file -> getExtension ( ) , '.min.' . $ this -> file -> getExtension ( ) ) ; if ( ! file_exists ( $ min_path ) ) return false ; return file_get_contents ( $ min_path ) ; }
11276	public function getMessage ( ) { $ response = [ ] ; if ( $ messages = $ this -> data -> query ( '/Message/Body/Errors' ) -> array ( ) ) { foreach ( $ messages as $ message ) { $ response [ ] = $ message -> textContent ; } } return count ( $ response ) ? implode ( ', ' , $ response ) : null ; }
10610	public function checkEmailAction ( ) { $ email = $ this -> get ( 'session' ) -> get ( 'fos_user_send_confirmation_email/email' ) ; $ this -> get ( 'session' ) -> remove ( 'fos_user_send_confirmation_email/email' ) ; $ user = $ this -> get ( 'fos_user.user_manager' ) -> findUserByEmail ( $ email ) ; if ( null === $ user ) { throw new NotFoundHttpException ( sprintf ( 'The user with email "%s" does not exist' , $ email ) ) ; } return $ this -> render ( '@MikyUser/Frontend/Registration/checkEmail.html.twig' , array ( 'user' => $ user , ) ) ; }
11825	public function add ( $ encoding = 'UTF-8' ) { $ str = file_get_contents ( $ this -> uri ) ; return file_put_contents ( $ this -> uri , $ this -> getBom ( $ encoding ) . $ str ) ; }
4369	public function buildTable ( $ rows , $ options = array ( ) ) { $ options = \ array_merge ( array ( 'attribs' => array ( ) , 'caption' => null , 'columns' => array ( ) , 'totalCols' => array ( ) , ) , $ options ) ; if ( \ is_string ( $ options [ 'attribs' ] ) ) { $ options [ 'attribs' ] = array ( 'class' => $ options [ 'attribs' ] , ) ; } if ( $ this -> debug -> abstracter -> isAbstraction ( $ rows ) && $ rows [ 'traverseValues' ] ) { $ options [ 'caption' ] .= ' (' . $ this -> markupClassname ( $ rows [ 'className' ] , 'span' , array ( 'title' => $ rows [ 'phpDoc' ] [ 'summary' ] ? : null , ) ) . ')' ; $ options [ 'caption' ] = \ trim ( $ options [ 'caption' ] ) ; $ rows = $ rows [ 'traverseValues' ] ; } $ keys = $ options [ 'columns' ] ? : $ this -> debug -> methodTable -> colKeys ( $ rows ) ; $ this -> tableInfo = array ( 'colClasses' => \ array_fill_keys ( $ keys , null ) , 'haveObjRow' => false , 'totals' => \ array_fill_keys ( $ options [ 'totalCols' ] , null ) , ) ; $ tBody = '' ; foreach ( $ rows as $ k => $ row ) { $ tBody .= $ this -> buildTableRow ( $ row , $ keys , $ k ) ; } if ( ! $ this -> tableInfo [ 'haveObjRow' ] ) { $ tBody = \ str_replace ( '<td class="t_classname"></td>' , '' , $ tBody ) ; } return $ this -> debug -> utilities -> buildTag ( 'table' , $ options [ 'attribs' ] , "\n" . ( $ options [ 'caption' ] ? '<caption>' . $ options [ 'caption' ] . '</caption>' . "\n" : '' ) . $ this -> buildTableHeader ( $ keys ) . '<tbody>' . "\n" . $ tBody . '</tbody>' . "\n" . $ this -> buildTableFooter ( $ keys ) ) ; }
4991	public function getEntity ( $ key = '*' ) { return isset ( $ this -> entities [ $ key ] ) ? $ this -> entities [ $ key ] : null ; }
2352	public function sendToBrowser ( $ filename = '' , $ inline = false ) { $ response = new BinaryFileResponse ( $ this -> strRootDir . '/' . $ this -> strFile ) ; $ response -> setContentDisposition ( $ inline ? ResponseHeaderBag :: DISPOSITION_INLINE : ResponseHeaderBag :: DISPOSITION_ATTACHMENT , $ filename , Utf8 :: toAscii ( $ this -> basename ) ) ; $ response -> headers -> addCacheControlDirective ( 'must-revalidate' ) ; $ response -> headers -> addCacheControlDirective ( 'post-check' , 0 ) ; $ response -> headers -> addCacheControlDirective ( 'pre-check' , 0 ) ; $ response -> headers -> set ( 'Connection' , 'close' ) ; throw new ResponseException ( $ response ) ; }
5769	public function setSql ( ) { $ this -> args [ ] = $ this -> updateOnColumnValue ; $ lastArgNum = count ( $ this -> args ) ; $ this -> sql = "UPDATE $this->dbTable SET $this->setColumnsValues WHERE $this->updateOnColumnName = $" . $ lastArgNum ; }
9708	private function writeShortNameBiff8 ( $ name , $ sheetIndex , $ rangeBounds , $ isHidden = false ) { $ record = 0x0018 ; $ options = ( $ isHidden ? 0x21 : 0x00 ) ; $ extra = pack ( 'Cvvvvv' , 0x3B , $ sheetIndex - 1 , $ rangeBounds [ 0 ] [ 1 ] - 1 , $ rangeBounds [ 1 ] [ 1 ] - 1 , $ rangeBounds [ 0 ] [ 0 ] - 1 , $ rangeBounds [ 1 ] [ 0 ] - 1 ) ; $ sz = strlen ( $ extra ) ; $ data = pack ( 'vCCvvvCCCCC' , $ options , 0 , 1 , $ sz , 0 , $ sheetIndex , 0 , 0 , 0 , 0 , 0 ) . $ name . $ extra ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
4773	public function order ( Request $ request , WidgetInterface $ widget , string $ widgetId , int $ order ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'order' => $ order ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> json ( [ 'result' => 'success' , ] ) ; }
21	private function revert ( $ level ) { while ( ! $ this -> decisions -> isEmpty ( ) ) { $ literal = $ this -> decisions -> lastLiteral ( ) ; if ( $ this -> decisions -> undecided ( $ literal ) ) { break ; } $ decisionLevel = $ this -> decisions -> decisionLevel ( $ literal ) ; if ( $ decisionLevel <= $ level ) { break ; } $ this -> decisions -> revertLast ( ) ; $ this -> propagateIndex = count ( $ this -> decisions ) ; } while ( ! empty ( $ this -> branches ) && $ this -> branches [ count ( $ this -> branches ) - 1 ] [ self :: BRANCH_LEVEL ] >= $ level ) { array_pop ( $ this -> branches ) ; } }
840	public function setSize ( $ size ) { if ( $ this -> getSize ( ) !== $ size ) { $ this -> changed = true ; parent :: setSize ( $ size ) ; } }
7929	public function setDefaultGroup ( $ defaultGroup ) { list ( $ defaultGroup ) = $ this -> fireEvent ( 'default-group.set' , [ $ defaultGroup ] ) ; $ this -> defaultGroup = $ defaultGroup ; return $ this ; }
6602	public function make ( $ key , $ secret ) { $ this -> credentials [ 'key' ] = $ key ; $ this -> credentials [ 'secret' ] = $ secret ; return $ this ; }
7511	protected function parse_linebreak ( ) { if ( $ this -> doc [ $ this -> pos ] === "\r" ) { ++ $ this -> line_pos [ 0 ] ; if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === "\n" ) ) { ++ $ this -> pos ; } $ this -> line_pos [ 1 ] = $ this -> pos ; } elseif ( $ this -> doc [ $ this -> pos ] === "\n" ) { ++ $ this -> line_pos [ 0 ] ; $ this -> line_pos [ 1 ] = $ this -> pos ; } }
3069	protected function endItemTimer ( $ timestamp = null ) { if ( $ this -> getRequestParameter ( 'itemDuration' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemDuration = $ this -> getRequestParameter ( 'itemDuration' ) ; return $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ timestamp ) ; } return false ; }
2964	public function performRequest ( $ method , $ path , array $ params = [ ] ) { $ request = $ this -> buildRequest ( $ method , $ path , $ params ) ; try { $ response = $ this -> httpClient -> send ( $ request ) ; $ content = json_decode ( $ response -> getBody ( ) -> getContents ( ) , true ) ; } catch ( ClientException $ ex ) { if ( $ ex -> getResponse ( ) -> getStatusCode ( ) == 401 ) { if ( $ this -> isPsr7Version ( ) ) { $ uri = $ request -> getUri ( ) ; } else { $ uri = $ request -> getUrl ( ) ; } $ message = sprintf ( 'Unauthorized %s Request to %s' , $ request -> getMethod ( ) , $ uri ) ; throw new UnauthorizedRequestException ( $ message ) ; } throw $ ex ; } return $ this -> createResponseFromData ( $ content ) ; }
1811	public function addCteType ( $ arrRow ) { $ key = $ arrRow [ 'invisible' ] ? 'unpublished' : 'published' ; $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ arrRow [ 'type' ] ] [ 0 ] ? : '&nbsp;' ; $ class = 'limit_height' ; if ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'start' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'separator' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'stop' ] ) ) { $ class = '' ; if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } elseif ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'single' ] ) ) { if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } if ( $ arrRow [ 'type' ] == 'alias' ) { $ type .= ' ID ' . $ arrRow [ 'cteAlias' ] ; } if ( $ arrRow [ 'protected' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'protected' ] . ')' ; } elseif ( $ arrRow [ 'guests' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'guests' ] . ')' ; } if ( $ arrRow [ 'type' ] == 'headline' ) { if ( \ is_array ( $ headline = Contao \ StringUtil :: deserialize ( $ arrRow [ 'headline' ] ) ) ) { $ type .= ' (' . $ headline [ 'unit' ] . ')' ; } } if ( ! Contao \ Config :: get ( 'doNotCollapse' ) ) { $ class .= ' h40' ; } $ objModel = new Contao \ ContentModel ( ) ; $ objModel -> setRow ( $ arrRow ) ; return '<div class="cte_type ' . $ key . '">' . $ type . '</div><div class="' . trim ( $ class ) . '">' . Contao \ StringUtil :: insertTagToSrc ( $ this -> getContentElement ( $ objModel ) ) . '</div>' . "\n" ; }
3073	public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = ( $ this -> getRequestParameter ( 'start' ) !== false ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( ! $ this -> getRunnerService ( ) -> isTerminated ( $ serviceContext ) ) { $ this -> endItemTimer ( $ this -> getTime ( ) ) ; $ this -> saveItemState ( ) ; } $ this -> initServiceContext ( ) ; $ this -> saveItemResponses ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> timeout ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } if ( $ start == true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
3446	private function getAccessorForLanguageField ( $ field ) { $ method = 'getValueFromLanguageField' ; return in_array ( $ field , $ this -> languageAccessors ) && method_exists ( $ this , $ method ) ? $ method : false ; }
9944	public function getCellByColumnAndRow ( $ columnIndex , $ row , $ createIfNotExists = true ) { $ columnLetter = Coordinate :: stringFromColumnIndex ( $ columnIndex ) ; $ coordinate = $ columnLetter . $ row ; if ( $ this -> cellCollection -> has ( $ coordinate ) ) { return $ this -> cellCollection -> get ( $ coordinate ) ; } return $ createIfNotExists ? $ this -> createNewCell ( $ coordinate ) : null ; }
10401	private function countSourceItems ( $ sources ) { $ count = 0 ; foreach ( $ sources as $ source ) { $ count += count ( $ source ) ; } return $ count ; }
11912	public function setIndustry ( $ industryOne , $ industryTwo ) { $ params = [ 'industry_id1' => $ industryOne , 'industry_id2' => $ industryTwo , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SET_INDUSTRY , $ params ] ) ; }
7190	private function copyAttachment ( Model \ SaleAttachmentInterface $ source , Model \ SaleAttachmentInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'path' , 'title' , 'type' , 'size' , 'internal' , 'createdAt' , 'updatedAt' , ] ) ; }
5423	public function invoke ( $ method ) { $ trap = SimpleTest :: getContext ( ) -> get ( 'SimpleExceptionTrap' ) ; $ trap -> clear ( ) ; try { $ has_thrown = false ; parent :: invoke ( $ method ) ; } catch ( Exception $ exception ) { $ has_thrown = true ; if ( ! $ trap -> isExpected ( $ this -> getTestCase ( ) , $ exception ) ) { $ this -> getTestCase ( ) -> exception ( $ exception ) ; } $ trap -> clear ( ) ; } if ( $ message = $ trap -> getOutstanding ( ) ) { $ this -> getTestCase ( ) -> fail ( $ message ) ; } if ( $ has_thrown ) { try { parent :: getTestCase ( ) -> tearDown ( ) ; } catch ( Exception $ e ) { } } }
12829	public function setConfig ( $ name , $ value ) { if ( is_null ( $ name ) ) { $ this -> _config = new ArrayStorage ( $ value ) ; } else { $ this -> _config -> setDeepValue ( $ name , $ value ) ; } return $ this ; }
1066	private function doTypesConflict ( OutputType $ type1 , OutputType $ type2 ) { if ( $ type1 instanceof ListOfType ) { return $ type2 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof ListOfType ) { return $ type1 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type1 instanceof NonNull ) { return $ type2 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof NonNull ) { return $ type1 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( Type :: isLeafType ( $ type1 ) || Type :: isLeafType ( $ type2 ) ) { return $ type1 !== $ type2 ; } return false ; }
947	protected function scripttagExists ( array $ shopScripttags , array $ scripttag ) { foreach ( $ shopScripttags as $ shopScripttag ) { if ( $ shopScripttag -> src === $ scripttag [ 'src' ] ) { return true ; } } return false ; }
2890	public function onModelLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ model = $ observer -> getData ( 'object' ) ; $ this -> getRequestInfo ( ) -> addModel ( $ model ) ; }
6821	protected function compare ( float $ a , float $ b ) { return Money :: compare ( $ a , $ b , $ this -> currency ) ; }
8520	public function setFulfillmentRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FulfillmentRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12639	protected function rethrowExceptions ( callable $ callable ) { try { return $ callable ( ) ; } catch ( ImplementationNotFoundException $ ex ) { throw new ImplementationNotFoundException ( $ ex -> getMessage ( ) ) ; } catch ( TypeMismatchException $ ex ) { throw new TypeMismatchException ( $ ex -> getMessage ( ) ) ; } catch ( UnresolveableArgumentException $ ex ) { throw new UnresolveableArgumentException ( $ ex -> getMessage ( ) ) ; } catch ( ValueNotFoundException $ ex ) { throw new ValueNotFoundException ( $ ex -> getMessage ( ) ) ; } catch ( InvalidCallableFormatException $ ex ) { throw new InvalidCallableFormatException ( $ ex -> getMessage ( ) ) ; } catch ( MissingDefinitionIdentifierException $ ex ) { throw new MissingDefinitionIdentifierException ( $ ex -> getMessage ( ) ) ; } catch ( MissingDefinitionValueException $ ex ) { throw new MissingDefinitionValueException ( $ ex -> getMessage ( ) ) ; } catch ( ClassNotFoundException $ ex ) { throw new ClassNotFoundException ( $ ex -> getMessage ( ) ) ; } }
7740	public function validate ( $ entity ) { if ( ! $ this -> container -> has ( 'validator' ) ) { throw new \ LogicException ( 'The validator service is not available.' ) ; } $ errors = $ this -> container -> get ( 'validator' ) -> validate ( $ entity ) ; if ( count ( $ errors ) === 0 ) { return false ; } return new JsonLdResponse ( '{ "error": "Validation error" }' , 400 ) ; }
5921	public function getProperty ( $ systemName ) { foreach ( $ this -> propertySets as $ propertySet ) { foreach ( $ propertySet -> getProperties ( ) as $ property ) { if ( $ property -> getPropertyType ( ) -> getSystemName ( ) == $ systemName ) { return $ property ; } } } throw new PropertyNotFoundException ( 'No Property with the system name "' . $ systemName . '" exists.' ) ; }
10950	private function xorTokens ( $ token1 , $ token2 ) { $ n1 = StringHelper :: byteLength ( $ token1 ) ; $ n2 = StringHelper :: byteLength ( $ token2 ) ; if ( $ n1 > $ n2 ) { $ token2 = str_pad ( $ token2 , $ n1 , $ token2 ) ; } elseif ( $ n1 < $ n2 ) { $ token1 = str_pad ( $ token1 , $ n2 , $ n1 === 0 ? ' ' : $ token1 ) ; } return $ token1 ^ $ token2 ; }
4996	public function getColumnMap ( ) { $ map = $ this -> getOption ( 'column_map' ) ; if ( null === $ map ) { $ map = [ ] ; foreach ( $ this as $ element ) { $ col = $ element -> getOption ( 'span' ) ; if ( null !== $ col ) { $ map [ $ element -> getName ( ) ] = $ col ; } } $ this -> setOption ( 'column_map' , $ map ) ; } return $ map ; }
2630	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ comment = $ this -> getRequest ( ) -> getParam ( 'comment_value' ) ; $ negated = 0 ; if ( $ value [ 0 ] == '!' ) { $ negated = 1 ; $ value = ltrim ( $ value , '!' ) ; } $ ipParts = explode ( '/' , $ value ) ; $ subnet = false ; if ( ! empty ( $ ipParts [ 1 ] ) ) { if ( is_numeric ( $ ipParts [ 1 ] ) && ( int ) $ ipParts [ 1 ] < 129 ) { $ subnet = $ ipParts [ 1 ] ; } else { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP subnet format.' ] ) ; } } if ( ! filter_var ( $ ipParts [ 0 ] , FILTER_VALIDATE_IP ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP address format.' ] ) ; } $ createAclItem = $ this -> api -> upsertAclItem ( $ aclId , $ ipParts [ 0 ] , $ negated , $ comment , $ subnet ) ; if ( ! $ createAclItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Acl entry.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'id' => $ createAclItem -> id , 'comment' => $ createAclItem -> comment , 'created_at' => $ createAclItem -> created_at ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
5229	public static function forName ( $ name ) { $ enum = new \ ReflectionClass ( get_called_class ( ) ) ; try { return $ enum -> getStaticPropertyValue ( $ name ) ; } catch ( \ ReflectionException $ re ) { throw new \ InvalidArgumentException ( $ re -> getMessage ( ) ) ; } }
1101	protected function parentId ( ) { switch ( $ this -> position ) { case 'root' : return NULL ; case 'child' : return $ this -> target -> getKey ( ) ; default : return $ this -> target -> getParentId ( ) ; } }
2898	public function queryEnd ( $ queryId ) { $ result = $ this -> parentQueryEnd ( $ queryId ) ; if ( $ this -> captureStacktraces ) { $ this -> stackTraces [ $ queryId ] = $ this -> getStackTrace ( ) ; } return $ result ; }
3861	public function prepare ( ) { if ( $ this -> objItems ) { return $ this ; } if ( ! $ this -> objFilter ) { $ this -> objFilter = $ this -> objMetaModel -> getEmptyFilter ( ) ; } if ( $ this -> objFilterSettings ) { $ this -> objFilterSettings -> addRules ( $ this -> objFilter , $ this -> arrParam ) ; } $ this -> modifyFilter ( ) ; $ intTotal = $ this -> objMetaModel -> getCount ( $ this -> objFilter ) ; $ calculator = $ this -> paginationLimitCalculator ; $ calculator -> setTotalAmount ( $ intTotal ) ; $ curPage = ( int ) \ Input :: get ( 'page' ) ; if ( $ curPage > 1 ) { $ calculator -> setCurrentPage ( $ curPage ) ; } $ this -> objTemplate -> total = $ intTotal ; $ this -> objItems = $ this -> objMetaModel -> findByFilter ( $ this -> objFilter , $ this -> strSortBy , $ calculator -> getCalculatedOffset ( ) , $ calculator -> getCalculatedLimit ( ) , $ this -> strSortDirection , $ this -> getAttributeNames ( ) ) ; return $ this ; }
7949	public function updateDomainProperties ( $ domain , $ properties ) { self :: getClient ( ) -> updateDomainProperties ( $ this -> sn , $ domain , $ properties ) ; }
4555	protected function addJoinTranslation ( QueryBuilder $ queryBuilder , string $ resourceClass ) { $ rootAlias = $ queryBuilder -> getRootAliases ( ) [ 0 ] ; $ translationAlias = $ rootAlias . '_t' ; $ translationClass = call_user_func ( $ resourceClass . '::getTranslationEntityClass' ) ; $ parts = $ queryBuilder -> getDQLParts ( ) [ 'join' ] ; foreach ( $ parts as $ joins ) { foreach ( $ joins as $ join ) { if ( $ translationAlias === $ join -> getAlias ( ) ) { return $ translationAlias ; } } } $ queryBuilder -> leftJoin ( $ translationClass , $ translationAlias , Join :: WITH , $ rootAlias . '.id = ' . $ translationAlias . '.translatable' ) ; return $ translationAlias ; }
10438	public function offsetSet ( $ attributeName , $ attribute ) { if ( ! is_string ( $ attributeName ) || ! is_string ( $ attribute ) ) { throw new ValueException ( $ attribute , 'string' ) ; } $ this -> attributes [ $ attributeName ] = $ attribute ; }
7434	private function getDirContents ( $ dir , & $ results = [ ] ) { $ files = scandir ( $ dir ) ; foreach ( $ files as $ value ) { $ path = realpath ( $ dir . DIRECTORY_SEPARATOR . $ value ) ; if ( ! is_dir ( $ path ) ) { $ results [ ] = $ path ; continue ; } if ( $ value != '.' && $ value != '..' ) { $ this -> getDirContents ( $ path , $ results ) ; $ results [ ] = $ path ; } } return $ results ; }
9594	public function makeSessionHandler ( ) { $ handler = $ this -> dic -> resolve ( 'Autarky\Http\SessionHandlerFactory' ) -> makeHandler ( $ this -> config -> get ( 'session.handler' ) ) ; if ( $ this -> config -> get ( 'session.write_check' ) === true ) { $ handler = new WriteCheckSessionHandler ( $ handler ) ; } return $ handler ; }
7133	protected function getSupplierOrderFromEvent ( ResourceEventInterface $ event ) { $ order = $ event -> getResource ( ) ; if ( ! $ order instanceof SupplierOrderInterface ) { throw new InvalidArgumentException ( "Expected instance of SupplierOrderInterface." ) ; } return $ order ; }
10	private function getCurrentPackages ( $ installedRepo ) { if ( $ this -> locker -> isLocked ( ) ) { try { return $ this -> locker -> getLockedRepository ( true ) -> getPackages ( ) ; } catch ( \ RuntimeException $ e ) { return $ this -> locker -> getLockedRepository ( ) -> getPackages ( ) ; } } return $ installedRepo -> getPackages ( ) ; }
4842	public static function generate_query_string ( $ params , & $ pairs = array ( ) , $ namespace = null ) { if ( is_array ( $ params ) ) { foreach ( $ params as $ k => $ v ) { if ( is_int ( $ k ) ) { GoCardless_Utils :: generate_query_string ( $ v , $ pairs , $ namespace . '[]' ) ; } else { GoCardless_Utils :: generate_query_string ( $ v , $ pairs , $ namespace !== null ? $ namespace . "[$k]" : $ k ) ; } } if ( $ namespace !== null ) { return $ pairs ; } if ( empty ( $ pairs ) ) { return '' ; } usort ( $ pairs , array ( __CLASS__ , 'sortPairs' ) ) ; $ strs = array ( ) ; foreach ( $ pairs as $ pair ) { $ strs [ ] = $ pair [ 0 ] . '=' . $ pair [ 1 ] ; } return implode ( '&' , $ strs ) ; } else { $ pairs [ ] = array ( rawurlencode ( $ namespace ) , rawurlencode ( $ params ) ) ; } }
1656	public function add ( $ message ) { if ( is_string ( $ message ) ) { $ this -> messages [ ] = new SimpleResponse ( $ message ) ; } elseif ( $ message instanceof ResponseInterface ) { $ this -> messages [ ] = $ message ; } elseif ( $ message instanceof QuestionInterface ) { $ this -> messages [ ] = $ message ; } return $ this ; }
7385	public function uploadAction ( ) { if ( $ this -> request -> hasFiles ( ) == true ) { $ this -> initializeScaffolding ( ) ; $ form = $ this -> scaffolding -> getForm ( ) ; $ name = key ( $ _FILES ) ; $ uploadElement = $ form -> get ( $ name ) ; $ model = $ uploadElement -> getModel ( ) ; $ path = $ uploadElement -> getPath ( ) ; $ maxFileSize = $ uploadElement -> getMaxFileSize ( ) ; $ minFileSize = $ uploadElement -> getMinFileSize ( ) ; foreach ( $ this -> request -> getUploadedFiles ( ) as $ file ) { $ fileName = $ file -> getName ( ) ; $ fileSize = $ file -> getSize ( ) ; $ fileType = $ file -> getRealType ( ) ; $ fileExtensions = pathinfo ( $ fileName , PATHINFO_EXTENSION ) ; $ allowed = $ uploadElement -> getAllowedExtensions ( ) ; if ( ! empty ( $ allowed ) ) { if ( ! in_array ( $ fileExtensions , $ allowed ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ forbidden = $ uploadElement -> getForbiddenExtensions ( ) ; if ( ! empty ( $ forbidden ) ) { if ( in_array ( $ fileExtensions , $ forbidden ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ allowedMime = $ uploadElement -> getAllowedMimeTypes ( ) ; if ( ! empty ( $ allowedMime ) ) { if ( ! in_array ( $ fileType , $ allowedMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } $ forbiddenMime = $ uploadElement -> getForbiddenMimeTypes ( ) ; if ( ! empty ( $ forbiddenMime ) ) { if ( in_array ( $ fileType , $ forbiddenMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } if ( ! empty ( $ maxFileSize ) ) { if ( $ fileSize > $ this -> convertFileSizeToBytes ( $ maxFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( ! empty ( $ minFileSize ) ) { if ( $ fileSize < $ this -> convertFileSizeToBytes ( $ minFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( empty ( $ path ) ) { $ path = 'files/' ; } $ model -> name = $ fileName ; $ model -> mime_type = $ fileType ; $ model -> path = $ path ; $ model -> save ( ) ; $ file -> moveTo ( $ path . $ model -> _id ) ; return $ this -> response -> setJsonContent ( ( string ) $ model -> _id ) ; } } $ this -> view -> setRenderLevel ( View :: LEVEL_NO_RENDER ) ; }
838	public static function fromArray ( $ array , $ saveIndexes = null ) { $ tokens = new self ( \ count ( $ array ) ) ; if ( null === $ saveIndexes || $ saveIndexes ) { foreach ( $ array as $ key => $ val ) { $ tokens [ $ key ] = $ val ; } } else { $ index = 0 ; foreach ( $ array as $ val ) { $ tokens [ $ index ++ ] = $ val ; } } $ tokens -> generateCode ( ) ; return $ tokens ; }
4668	public function generate ( ) { $ this -> beforeGeneration ( ) ; $ this -> config -> getLogger ( ) -> startBreak ( 'Class Generation' ) ; foreach ( $ this -> XSDMap as $ fhirElementName => $ mapEntry ) { $ this -> config -> getLogger ( ) -> debug ( "Generating class for element {$fhirElementName}..." ) ; $ classTemplate = ClassGenerator :: buildFHIRElementClassTemplate ( $ this -> config , $ this -> XSDMap , $ mapEntry ) ; FileUtils :: createDirsFromNS ( $ classTemplate -> getNamespace ( ) , $ this -> config ) ; MethodGenerator :: implementConstructor ( $ this -> config , $ classTemplate ) ; $ classTemplate -> writeToFile ( $ this -> config -> getOutputPath ( ) ) ; $ this -> mapTemplate -> addEntry ( $ classTemplate ) ; $ this -> autoloadMap -> addPHPFHIRClassEntry ( $ classTemplate ) ; $ this -> config -> getLogger ( ) -> debug ( "{$fhirElementName} completed." ) ; } $ this -> config -> getLogger ( ) -> endBreak ( 'Class Generation' ) ; $ this -> afterGeneration ( ) ; }
877	private function skipClass ( Tokens $ tokens , $ classIndex , $ classOpenIndex , $ classCloseIndex ) { $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ classIndex ) ] ; if ( ! $ prevToken -> isGivenKind ( T_FINAL ) ) { return true ; } for ( $ index = $ classIndex ; $ index < $ classOpenIndex ; ++ $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_EXTENDS ) ) { return true ; } } $ useIndex = $ tokens -> getNextTokenOfKind ( $ classIndex , [ [ CT :: T_USE_TRAIT ] ] ) ; return $ useIndex && $ useIndex < $ classCloseIndex ; }
5255	public function makePagination ( QueryBuilder $ query = null ) { if ( is_null ( $ this -> _position ) ) { throw new Exception ( 'To use Paginationable trait you must fill _position property in your model' ) ; } $ model = static :: createInstance ( ) ; $ query = $ query ? : new QueryBuilder ( ) ; $ prevDoc = null ; $ nextDoc = null ; $ query -> fields ( ) ; $ prevPos = $ this -> _position - 1 ; if ( $ prevPos >= 0 ) { $ items = $ model -> search ( $ query -> from ( $ prevPos ) -> size ( 3 ) ) ; $ prevDoc = $ items -> first ( ) ; $ items = array_values ( $ items -> toArray ( ) ) ; if ( array_key_exists ( 2 , $ items ) ) { $ nextDoc = $ items [ 2 ] ; } } else { $ items = $ model -> search ( $ query -> from ( $ this -> _position ) -> size ( 2 ) ) ; $ total = $ items -> getTotal ( ) ; $ nextDoc = $ items -> last ( ) ; $ last = $ total - 1 ; $ items = $ model -> search ( $ query -> from ( $ last ) -> size ( 1 ) ) ; $ prevDoc = $ items -> first ( ) ; } if ( ! $ nextDoc ) { $ items = $ model -> search ( $ query -> from ( 0 ) -> size ( 1 ) ) ; $ nextDoc = $ items -> first ( ) ; } $ this -> _previous = $ prevDoc ; $ this -> _next = $ nextDoc ; }
11525	private function getDom ( $ url ) { $ ch = curl_init ( ) ; $ timeout = 5 ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , $ timeout ) ; $ dom = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ dom ; }
2957	public function confCharacterLength ( $ int ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set length of a character : the device " . "is either not set or opened" , E_USER_WARNING ) ; return false ; } $ int = ( int ) $ int ; if ( $ int < 5 ) { $ int = 5 ; } elseif ( $ int > 8 ) { $ int = 8 ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " cs" . $ int , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " cs" . $ int , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " DATA=" . $ int , $ out ) ; } if ( $ ret === 0 ) { return true ; } trigger_error ( "Unable to set character length : " . $ out [ 1 ] , E_USER_WARNING ) ; return false ; }
12184	public static function getById ( $ relationshipId ) { $ key = md5 ( $ relationshipId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { return self :: $ _relationships [ $ key ] ; } return false ; }
11902	public function cache ( ContentfulAsset $ asset ) { if ( ! isset ( $ asset -> file ) ) { $ this -> log ( 'Asset %s has no file.' , $ asset ) ; return ; } foreach ( $ asset -> file as $ locale => $ file ) { if ( ! $ file ) { $ this -> log ( 'Asset %s contains unpublished file for %s.' , $ asset , $ locale ) ; continue ; } $ localFile = $ this -> getLocalFile ( $ asset , $ locale ) ; if ( $ localFile -> isFile ( ) ) { continue ; } $ this -> log ( 'Caching "%s" file for asset "%s" as "%s" ...' , $ locale , $ asset -> getId ( ) , $ localFile -> getPathname ( ) ) ; $ dir = new \ SplFileInfo ( $ localFile -> getPath ( ) ) ; if ( ! $ dir -> isWritable ( ) ) { throw new RuntimeException ( sprintf ( 'Target directory "%s" is not writeable!' , $ localFile -> getPath ( ) ) ) ; } copy ( str_replace ( '//' , 'https://' , $ file [ 'url' ] ) , $ localFile -> getPathname ( ) ) ; $ size = filesize ( $ localFile -> getPathname ( ) ) ; $ this -> log ( '%d bytes saved.' , $ size ) ; } }
9450	protected function pathExtract ( ) : array { $ regExp = [ ] ; $ path = $ this -> path ; if ( \ is_array ( $ this -> path ) ) { $ regExp = \ array_pop ( $ this -> path ) ; $ path = \ array_pop ( $ this -> path ) ; } return [ $ path , $ regExp ] ; }
449	public function init ( ) { parent :: init ( ) ; $ this -> cachePath = Yii :: getAlias ( $ this -> cachePath ) ; if ( ! is_dir ( $ this -> cachePath ) ) { FileHelper :: createDirectory ( $ this -> cachePath , $ this -> dirMode , true ) ; } }
4912	public function setVariables ( $ variables , $ overwrite = false ) { if ( ! is_array ( $ variables ) && ! $ variables instanceof \ Traversable ) { throw new \ InvalidArgumentException ( sprintf ( '%s: expects an array, or Traversable argument; received "%s"' , __METHOD__ , ( is_object ( $ variables ) ? get_class ( $ variables ) : gettype ( $ variables ) ) ) ) ; } if ( $ overwrite ) { if ( is_object ( $ variables ) && ! $ variables instanceof \ ArrayAccess ) { $ variables = ArrayUtils :: iteratorToArray ( $ variables ) ; } $ this -> variables = $ variables ; return $ this ; } foreach ( $ variables as $ key => $ value ) { $ this -> setVariable ( $ key , $ value ) ; } return $ this ; }
10573	protected function registerSessionHandler ( ) { if ( $ this -> handler !== null ) { if ( ! is_object ( $ this -> handler ) ) { $ this -> handler = Yii :: createObject ( $ this -> handler ) ; } if ( ! $ this -> handler instanceof \ SessionHandlerInterface ) { throw new InvalidConfigException ( '"' . get_class ( $ this ) . '::handler" must implement the SessionHandlerInterface.' ) ; } @ session_set_save_handler ( $ this -> handler , false ) ; } elseif ( $ this -> getUseCustomStorage ( ) ) { @ session_set_save_handler ( [ $ this , 'openSession' ] , [ $ this , 'closeSession' ] , [ $ this , 'readSession' ] , [ $ this , 'writeSession' ] , [ $ this , 'destroySession' ] , [ $ this , 'gcSession' ] ) ; } }
10174	public function delete ( $ pCoord ) { if ( $ pCoord === $ this -> currentCoordinate && $ this -> currentCell !== null ) { $ this -> currentCell -> detach ( ) ; $ this -> currentCoordinate = null ; $ this -> currentCell = null ; $ this -> currentCellIsDirty = false ; } unset ( $ this -> index [ $ pCoord ] ) ; $ this -> cache -> delete ( $ this -> cachePrefix . $ pCoord ) ; }
184	public function init ( ) { parent :: init ( ) ; $ this -> cache = $ this -> enabled ? Instance :: ensure ( $ this -> cache , 'yii\caching\CacheInterface' ) : null ; if ( $ this -> cache instanceof CacheInterface && $ this -> getCachedContent ( ) === false ) { $ this -> getView ( ) -> pushDynamicContent ( $ this ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; } }
1471	public function createResponseFactory ( Api $ api ) { return new Responses ( $ this , $ api , $ this -> container -> make ( Route :: class ) , $ this -> container -> make ( 'json-api.exceptions' ) ) ; }
9002	public function column_time ( AbstractLog $ item ) { $ time = $ item -> get_time ( ) ; if ( empty ( $ time ) ) { echo '-' ; } else { echo $ time -> format ( get_option ( 'date_format' ) . ' ' . get_option ( 'time_format' ) ) ; } }
4701	protected function createCiconia ( InputInterface $ input ) { if ( $ input -> getOption ( 'diagnose' ) ) { $ ciconia = new \ Ciconia \ Diagnose \ Ciconia ( ) ; } else { $ ciconia = new Ciconia ( ) ; } if ( $ input -> getOption ( 'format' ) == 'xhtml' ) { $ ciconia -> setRenderer ( new XhtmlRenderer ( ) ) ; } if ( $ input -> getOption ( 'gfm' ) ) { $ ciconia -> addExtensions ( [ new FencedCodeBlockExtension ( ) , new InlineStyleExtension ( ) , new TaskListExtension ( ) , new WhiteSpaceExtension ( ) , new TableExtension ( ) , new UrlAutoLinkExtension ( ) ] ) ; } return $ ciconia ; }
7515	function next_pos ( $ needle , $ callback = true ) { $ this -> token_start = $ this -> pos ; if ( ( $ this -> pos < $ this -> size ) && ( ( $ p = stripos ( $ this -> doc , $ needle , $ this -> pos + 1 ) ) !== false ) ) { $ len = $ p - $ this -> pos - 1 ; if ( $ len > 0 ) { $ str = substr ( $ this -> doc , $ this -> pos + 1 , $ len ) ; if ( ( $ l = strrpos ( $ str , "\n" ) ) !== false ) { ++ $ this -> line_pos [ 0 ] ; $ this -> line_pos [ 1 ] = $ l + $ this -> pos + 1 ; $ len -= $ l ; if ( $ len > 0 ) { $ str = substr ( $ str , 0 , - $ len ) ; $ this -> line_pos [ 0 ] += substr_count ( $ str , "\n" ) ; } } } $ this -> pos = $ p ; if ( $ callback && isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> pos = $ this -> size ; return ( $ this -> token = self :: TOK_NULL ) ; } }
8016	public function close ( ) { $ uri = $ this -> current ( ) -> getNextUri ( ) ; if ( ! is_null ( $ uri ) ) { $ this -> client -> deleteAsync ( $ uri ) -> wait ( ) ; } $ this -> closed = true ; }
4468	public function setPriority ( int $ priority ) : void { if ( $ this -> client -> call ( 'priority' , $ this -> jid , $ priority ) ) { parent :: setPriority ( $ priority ) ; } }
9065	protected function checkMVC ( ) { $ viewResolver = $ this -> sm -> get ( 'ViewResolver' ) ; $ return = true ; if ( $ viewResolver instanceof ViewResolver \ AggregateResolver ) { if ( $ viewResolver -> count ( ) == 2 ) { $ defResolvers = array ( 'Zend\View\Resolver\TemplateMapResolver' , 'Zend\View\Resolver\TemplatePathStack' ) ; foreach ( $ viewResolver -> getIterator ( ) -> toArray ( ) as $ i => $ ro ) { if ( $ defResolvers [ $ i ] != get_class ( $ ro ) ) { $ return = false ; break ; } } } else { $ return = false ; } } else { $ return = false ; } $ viewTemplatePathStack = $ this -> sm -> get ( 'ViewTemplatePathStack' ) ; if ( ! $ viewTemplatePathStack instanceof ViewResolver \ TemplatePathStack ) { throw new \ Exception ( 'yimaTheme work with PathStack' ) ; } return $ return ; }
9398	protected function selectBuilder ( ) { if ( PHP_OS === 'Darwin' ) { if ( exec ( 'which growlnotify' ) ) { return new GrowlNotifyBuilder ; } if ( exec ( 'which terminal-notifier' ) ) { return new TerminalNotifierBuilder ; } } if ( PHP_OS === 'Linux' ) { if ( exec ( 'which notify-send' ) ) { return new NotifySendBuilder ; } } if ( PHP_OS === 'WINNT' ) { if ( exec ( 'where growlnotify' ) ) { return new GrowlNotifyWindowsBuilder ; } } }
6583	public static function create ( $ b , $ q , $ n = 1 ) { if ( $ n == 1 ) return new static ( $ b , $ q ) ; static :: ensureValid ( $ n , "Amount of elements must be an integer number bigger than zero." ) ; return new static ( $ b * ( 1 - $ q ) / ( 1 - pow ( $ q , $ n ) ) , $ q ) ; }
8007	protected function validateSupportedAlgorithm ( $ algorithm ) { if ( ! in_array ( $ algorithm , $ this -> supported_algorithms , true ) ) { throw new InvalidArgumentException ( sprintf ( 'Algorithm "%s" not supported' , $ algorithm ) ) ; } return $ algorithm ; }
3816	protected function render ( $ table , $ metaModel , Request $ request ) { $ fields = $ this -> generateForm ( $ table , $ metaModel , $ request ) ; return [ 'action' => '' , 'requestToken' => REQUEST_TOKEN , 'href' => $ this -> getReferer ( $ request , $ table , true ) , 'backBt' => $ this -> translator -> trans ( 'MSC.backBT' , [ ] , 'contao_default' ) , 'add' => $ this -> translator -> trans ( 'MSC.continue' , [ ] , 'contao_default' ) , 'saveNclose' => $ this -> translator -> trans ( 'MSC.saveNclose' , [ ] , 'contao_default' ) , 'activate' => $ this -> translator -> trans ( $ table . '.addAll_activate' , [ ] , 'contao_' . $ table ) , 'headline' => $ this -> translator -> trans ( $ table . '.addall.1' , [ ] , 'contao_' . $ table ) , 'selectAll' => $ this -> translator -> trans ( 'MSC.selectAll' , [ ] , 'contao_default' ) , 'cacheMessage' => '' , 'updateMessage' => '' , 'hasCheckbox' => count ( $ fields ) > 0 , 'fields' => $ fields , ] ; }
8972	protected function paginate ( array $ rates , $ criteria ) { if ( ! array_key_exists ( 'offset' , $ criteria ) && ! array_key_exists ( 'limit' , $ criteria ) ) { return $ rates ; } $ range = array ( ) ; $ offset = array_key_exists ( 'offset' , $ criteria ) ? $ criteria [ 'offset' ] : 0 ; $ limit = min ( ( array_key_exists ( 'limit' , $ criteria ) ? $ criteria [ 'limit' ] : count ( $ rates ) ) + $ offset , count ( $ rates ) ) ; for ( $ i = $ offset ; $ i < $ limit ; $ i ++ ) { $ range [ ] = $ rates [ $ i ] ; } return $ range ; }
9606	public function multiplyByScalar ( $ scalar ) { $ result = [ ] ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ result [ $ i ] = $ component * $ scalar ; } return new static ( $ result ) ; }
1278	public static function addLocationInformation ( stdClass $ location , DOMNode $ locationNode ) { self :: appendChild ( $ location , 'CompanyName' , $ locationNode ) ; self :: appendChild ( $ location , 'AttentionName' , $ locationNode ) ; if ( isset ( $ location -> Address ) ) { self :: addAddressNode ( $ location -> Address , $ locationNode ) ; } }
4417	public function showLocationLayouts ( $ locationId ) { $ repository = $ this -> getRepository ( ) ; $ location = $ repository -> getLocationService ( ) -> loadLocation ( $ locationId ) ; $ content = $ repository -> getContentService ( ) -> loadContent ( $ location -> contentInfo -> id ) ; $ request = $ this -> createRequest ( $ content , $ location ) ; return $ this -> render ( '@NetgenAdminUI/layouts/location_layouts.html.twig' , array ( 'rules' => $ this -> layoutResolver -> resolveRules ( $ request , array ( 'ez_content_type' ) ) , 'related_layouts' => $ this -> relatedLayoutsLoader -> loadRelatedLayouts ( $ location ) , 'location' => $ location , ) ) ; }
1613	public function close ( ) { if ( $ this -> _socket !== false ) { $ connection = ( $ this -> unixSocket ? : $ this -> hostname . ':' . $ this -> port ) . ', database=' . $ this -> database ; \ Yii :: trace ( 'Closing DB connection: ' . $ connection , __METHOD__ ) ; try { $ this -> executeCommand ( 'QUIT' ) ; } catch ( SocketException $ e ) { } fclose ( $ this -> _socket ) ; $ this -> _socket = false ; } }
3455	public static function fromAggregateRootClass ( string $ aggregateRootClass ) : AggregateType { if ( ! \ class_exists ( $ aggregateRootClass ) ) { throw new Exception \ InvalidArgumentException ( \ sprintf ( 'Aggregate root class %s can not be found' , $ aggregateRootClass ) ) ; } $ self = new static ( ) ; $ self -> aggregateType = $ aggregateRootClass ; return $ self ; }
7345	public function modifySubmitedValueBeforeValidation ( $ value , array $ data ) { if ( $ this -> hasSubmittedValueModifier ( ) ) { return call_user_func ( $ this -> getSubmittedValueModifier ( ) , $ value , $ data ) ; } else { return $ value ; } }
6162	public function start ( ) { if ( $ this -> isRunning ( ) ) { return ; } $ this -> data [ "realmem_start" ] = memory_get_usage ( true ) ; $ this -> data [ "emalloc_start" ] = memory_get_usage ( ) ; $ this -> started = microtime ( true ) ; $ this -> running = true ; }
6440	public function transform ( $ target = null , $ controller = null , $ action = null , array $ params = [ ] , array $ trailing = [ ] , array $ config = [ ] ) { if ( ! empty ( $ trailing ) ) { $ params [ 'trailing' ] = join ( '_' , $ trailing ) ; } $ params = $ this -> sanitize ( $ params ) ; $ refType = \ Symfony \ Component \ Routing \ Generator \ UrlGeneratorInterface :: ABSOLUTE_PATH ; if ( isset ( $ config [ 'absoluteUri' ] ) ) { $ refType = \ Symfony \ Component \ Routing \ Generator \ UrlGeneratorInterface :: ABSOLUTE_URL ; } return $ this -> router -> generate ( $ target , $ params + $ this -> fixed , $ refType ) ; }
7087	static public function loadFromPasswordRecoveryAccessKey ( string $ accessKey ) { try { $ data = \ Crypt :: decrypt ( $ accessKey ) ; } catch ( DecryptException $ exc ) { return false ; } if ( empty ( $ data ) ) { return false ; } $ data = json_decode ( $ data , true ) ; $ now = new \ DateTime ( 'now' , new \ DateTimeZone ( 'UTC' ) ) ; if ( empty ( $ data ) || ! is_array ( $ data ) || ! isset ( $ data [ 'added_keys' ] ) || ! is_array ( $ data [ 'added_keys' ] ) || empty ( $ data [ 'account_id' ] ) || empty ( $ data [ 'expires_at' ] ) || $ data [ 'expires_at' ] < $ now -> getTimestamp ( ) ) { return false ; } $ user = static :: newEmptyRecord ( ) ; $ conditions = [ $ user :: getPrimaryKeyColumnName ( ) => $ data [ 'account_id' ] , ] ; $ additionalColumns = $ data [ 'added_keys' ] ; foreach ( $ additionalColumns as $ columnName ) { if ( ! array_key_exists ( $ columnName , $ data ) ) { return false ; } $ fieldType = $ user :: getColumn ( $ columnName ) -> getType ( ) ; switch ( $ fieldType ) { case Column :: TYPE_DATE : $ conditions [ $ columnName . '::date' ] = DbExpr :: create ( "``$data[$columnName]``::date" ) ; break ; case Column :: TYPE_TIME : $ conditions [ $ columnName . '::time' ] = DbExpr :: create ( "``$data[$columnName]``::time" ) ; break ; case Column :: TYPE_TIMESTAMP : $ conditions [ ] = DbExpr :: create ( "`{$columnName}`::timestamp(0) = ``{$data[$columnName]}``::timestamp(0)" ) ; break ; default : $ conditions [ $ columnName ] = $ data [ $ columnName ] ; } } if ( ! $ user -> fromDb ( $ conditions ) -> existsInDb ( ) ) { return false ; } return $ user ; }
5112	protected function setPart ( $ part , $ sql , $ bind = false ) { $ this -> parts [ $ part ] = $ sql ; if ( is_array ( $ bind ) ) $ this -> bind [ $ part ] = $ bind ; else if ( $ bind === false ) $ this -> bind [ $ part ] = false ; else $ this -> bind [ $ part ] = [ $ bind ] ; return $ this ; }
1730	public function isMemberOf ( $ id ) { if ( ! is_numeric ( $ id ) ) { return false ; } $ groups = StringUtil :: deserialize ( $ this -> groups ) ; if ( empty ( $ groups ) || ! \ is_array ( $ groups ) ) { return false ; } if ( \ in_array ( $ id , $ groups ) ) { return true ; } return false ; }
7264	private function validateItem ( SaleItemInterface $ item ) { foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> validateItem ( $ child ) ; } if ( $ item -> isCompound ( ) ) { return ; } if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ item , false ) ) { return ; } if ( ! $ subject instanceof StockSubjectInterface ) { return ; } $ quantity = $ item -> getTotalQuantity ( ) ; $ availability = $ this -> availabilityHelper -> getAvailability ( $ subject , is_null ( $ item -> getParent ( ) ) ) ; if ( $ quantity < $ availability -> getMinimumQuantity ( ) ) { $ message = $ availability -> getMinimumMessage ( ) ; } elseif ( $ quantity > $ availability -> getMaximumQuantity ( ) ) { $ message = $ availability -> getMaximumMessage ( ) ; } else { return ; } if ( null !== $ item -> getParent ( ) ) { $ message = $ item -> getDesignation ( ) . ' : ' . $ message ; } throw new ValidationFailedException ( $ message ) ; }
11301	public function getFieldName ( $ attributeName ) { if ( isset ( $ this -> model_attributes [ $ attributeName ] [ 'field' ] ) ) { return $ this -> model_attributes [ $ attributeName ] [ 'field' ] ; } return $ attributeName ; }
735	protected function getDirectPermissionsByUser ( $ userId ) { $ permissions = [ ] ; foreach ( $ this -> getAssignments ( $ userId ) as $ name => $ assignment ) { $ permission = $ this -> items [ $ assignment -> roleName ] ; if ( $ permission -> type === Item :: TYPE_PERMISSION ) { $ permissions [ $ name ] = $ permission ; } } return $ permissions ; }
6010	public function setDateRange ( $ dateRange ) { if ( $ dateRange instanceof DateTimeRange ) { $ this -> dateRange = $ dateRange ; } elseif ( is_array ( $ dateRange ) ) { $ this -> dateRange = new DateTimeRange ( $ dateRange ) ; } else { $ this -> dateRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
10210	public function createAction ( ) { $ request = $ this -> getRequest ( ) ; $ prg = $ this -> prg ( $ request -> getRequestUri ( ) , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } elseif ( $ prg === false ) { return $ this -> viewModel ; } if ( $ this -> contactForm -> setData ( $ prg ) -> isValid ( ) ) { $ contact = $ this -> contactForm -> getData ( ) ; $ this -> commandService -> persist ( $ contact ) ; $ this -> viewModel -> setVariable ( 'contact' , $ contact ) ; } return $ this -> viewModel ; }
12586	protected function createCtrl ( ) : AbstractCtrl { $ view = ViewFactory :: createView ( str_replace ( 'action' , '' , $ this -> actionName ) , $ this -> ctrlName ) ; $ componentsRootMap = AppHelper :: getInstance ( ) -> getConfig ( 'componentsRootMap' ) ; if ( ! isset ( $ componentsRootMap [ 'controllers' ] ) ) { throw new Exception ( "The field 'componentsRootMap.controllers' must be " . 'presented in the main configuration file.' ) ; } $ ctrlNamespace = str_replace ( \ DIRECTORY_SEPARATOR , '\\' , $ componentsRootMap [ 'controllers' ] ) ; $ ctrlFullName = $ ctrlNamespace . '\\' . $ this -> ctrlName ; if ( ! is_null ( $ view ) ) { $ layoutName = AppHelper :: getInstance ( ) -> getConfig ( 'defaultLayout' ) ; if ( ! is_null ( $ layoutName ) ) { $ layout = ViewFactory :: createLayout ( $ layoutName , $ view ) ; $ ctrl = new $ ctrlFullName ( $ this -> request , $ layout ) ; } else { $ ctrl = new $ ctrlFullName ( $ this -> request , $ view ) ; } } else { $ ctrl = new $ ctrlFullName ( $ this -> request ) ; } return $ ctrl ; }
1536	protected function fillRelationships ( $ record , Collection $ relationships , EncodingParametersInterface $ parameters ) { $ relationships -> filter ( function ( $ value , $ field ) use ( $ record ) { return $ this -> isFillableRelation ( $ field , $ record ) ; } ) -> each ( function ( $ value , $ field ) use ( $ record , $ parameters ) { $ this -> fillRelationship ( $ record , $ field , $ value , $ parameters ) ; } ) ; }
2889	public function onCollectionLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ collection = $ observer -> getData ( 'collection' ) ; $ this -> getRequestInfo ( ) -> addCollection ( $ collection ) ; }
86	public function archive ( PackageInterface $ package , $ format , $ targetDir , $ fileName = null , $ ignoreFilters = false ) { if ( empty ( $ format ) ) { throw new \ InvalidArgumentException ( 'Format must be specified' ) ; } $ usableArchiver = null ; foreach ( $ this -> archivers as $ archiver ) { if ( $ archiver -> supports ( $ format , $ package -> getSourceType ( ) ) ) { $ usableArchiver = $ archiver ; break ; } } if ( null === $ usableArchiver ) { throw new \ RuntimeException ( sprintf ( 'No archiver found to support %s format' , $ format ) ) ; } $ filesystem = new Filesystem ( ) ; if ( null === $ fileName ) { $ packageName = $ this -> getPackageFilename ( $ package ) ; } else { $ packageName = $ fileName ; } $ filesystem -> ensureDirectoryExists ( $ targetDir ) ; $ target = realpath ( $ targetDir ) . '/' . $ packageName . '.' . $ format ; $ filesystem -> ensureDirectoryExists ( dirname ( $ target ) ) ; if ( ! $ this -> overwriteFiles && file_exists ( $ target ) ) { return $ target ; } if ( $ package instanceof RootPackageInterface ) { $ sourcePath = realpath ( '.' ) ; } else { $ sourcePath = sys_get_temp_dir ( ) . '/composer_archive' . uniqid ( ) ; $ filesystem -> ensureDirectoryExists ( $ sourcePath ) ; try { $ this -> downloadManager -> download ( $ package , $ sourcePath ) ; } catch ( \ Exception $ e ) { $ filesystem -> removeDirectory ( $ sourcePath ) ; throw $ e ; } if ( file_exists ( $ composerJsonPath = $ sourcePath . '/composer.json' ) ) { $ jsonFile = new JsonFile ( $ composerJsonPath ) ; $ jsonData = $ jsonFile -> read ( ) ; if ( ! empty ( $ jsonData [ 'archive' ] [ 'exclude' ] ) ) { $ package -> setArchiveExcludes ( $ jsonData [ 'archive' ] [ 'exclude' ] ) ; } } } $ tempTarget = sys_get_temp_dir ( ) . '/composer_archive' . uniqid ( ) . '.' . $ format ; $ filesystem -> ensureDirectoryExists ( dirname ( $ tempTarget ) ) ; $ archivePath = $ usableArchiver -> archive ( $ sourcePath , $ tempTarget , $ format , $ package -> getArchiveExcludes ( ) , $ ignoreFilters ) ; $ filesystem -> rename ( $ archivePath , $ target ) ; if ( ! $ package instanceof RootPackageInterface ) { $ filesystem -> removeDirectory ( $ sourcePath ) ; } $ filesystem -> remove ( $ tempTarget ) ; return $ target ; }
1425	protected function getRelationshipPaths ( $ includePaths ) { return $ this -> convertIncludePaths ( $ includePaths ) -> merge ( $ this -> defaultWith ) -> unique ( ) -> all ( ) ; }
420	public function run ( ) { $ block = ob_get_clean ( ) ; if ( $ this -> renderInPlace ) { echo $ block ; } $ this -> view -> blocks [ $ this -> getId ( ) ] = $ block ; }
550	public function actionIndex ( ) { $ caches = $ this -> findCaches ( ) ; if ( ! empty ( $ caches ) ) { $ this -> notifyCachesCanBeFlushed ( $ caches ) ; } else { $ this -> notifyNoCachesFound ( ) ; } }
7690	function OpenXML_ChartGetInfoFromFile ( $ idx , $ Txt = false ) { if ( $ idx === false ) return false ; $ file = $ this -> CdFileLst [ $ idx ] [ 'v_name' ] ; $ relative = ( substr_count ( $ file , '/' ) == 1 ) ? '' : '../' ; $ o = $ this -> OpenXML_Rels_GetObj ( $ file , $ relative . 'charts/' ) ; if ( $ o -> ChartLst === false ) { if ( $ Txt === false ) $ Txt = $ this -> TbsStoreGet ( $ idx , 'OpenXML_ChartGetInfoFromFile' ) ; $ o -> ChartLst = array ( ) ; $ p = 0 ; while ( $ t = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'c:chart' , $ p ) ) { $ rid = $ t -> GetAttLazy ( 'r:id' ) ; $ name = false ; $ title = false ; $ descr = false ; $ parent = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'wp:inline' , $ t -> PosBeg , false ) ; if ( $ parent === false ) $ parent = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'p:nvGraphicFramePr' , $ t -> PosBeg , false ) ; if ( $ parent !== false ) { $ parent -> FindEndTag ( ) ; $ src = $ parent -> GetInnerSrc ( ) ; $ el = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ src , 'title' , 0 ) ; if ( $ el !== false ) $ title = $ el -> GetAttLazy ( 'title' ) ; $ el = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ src , 'descr' , 0 ) ; if ( $ el !== false ) $ descr = $ el -> GetAttLazy ( 'descr' ) ; } if ( isset ( $ o -> TargetLst [ $ rid ] ) ) { $ name = basename ( $ o -> TargetLst [ $ rid ] ) ; if ( substr ( $ name , - 4 ) === '.xml' ) $ name = substr ( $ name , 0 , strlen ( $ name ) - 4 ) ; } $ o -> ChartLst [ ] = array ( 'rid' => $ rid , 'title' => $ title , 'descr' => $ descr , 'name' => $ name ) ; $ p = $ t -> PosEnd ; } } return $ o -> ChartLst ; }
3824	protected function getFilterParameters ( $ objItemRenderer ) { $ filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; $ filterUrl = $ filterUrlBuilder -> getCurrentFilterUrl ( ) ; $ result = [ ] ; foreach ( $ objItemRenderer -> getFilterSettings ( ) -> getParameters ( ) as $ name ) { if ( $ filterUrl -> hasSlug ( $ name ) ) { $ result [ $ name ] = $ filterUrl -> getSlug ( $ name ) ; } Input :: get ( $ name ) ; } return $ filterUrl -> getSlugParameters ( ) ; }
7313	public function setDate ( $ year , $ month , $ day ) { $ status = IAU :: Cal2jd ( ( int ) $ year , ( int ) $ month , ( int ) $ day , $ djm0 , $ djm ) ; $ this -> checkDate ( $ status ) ; $ this -> jd = $ djm0 + $ djm ; return $ this ; }
9562	protected function matchesTypehint ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return true ; } if ( is_array ( $ handler ) ) { $ reflection = ( new ReflectionMethod ( $ handler [ 0 ] , $ handler [ 1 ] ) ) ; } else { $ reflection = ( new ReflectionFunction ( $ handler ) ) ; } $ params = $ reflection -> getParameters ( ) ; if ( empty ( $ params ) ) { return true ; } $ handlerHint = $ params [ 0 ] -> getClass ( ) ; if ( ! $ handlerHint ) { return true ; } return $ handlerHint -> isInstance ( $ exception ) ; }
8368	private static function validateConfig ( array $ config ) { if ( isset ( $ config [ 'name' ] ) === false ) { throw new BadUse ( 'there\'s no name in mapping configuration' ) ; } if ( isset ( $ config [ 'schema' ] ) === false ) { throw new BadUse ( 'there\'s no schema in mapping configuration' ) ; } if ( isset ( $ config [ 'provider' ] ) === false ) { throw new BadUse ( 'there\'s no provider in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] ) === false ) { throw new BadUse ( 'there\'s no models in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] [ 'path' ] ) === false ) { throw new BadUse ( 'there\'s no models.path in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] [ 'namespace' ] ) === false ) { throw new BadUse ( 'there\'s no models.namespace in mapping configuration' ) ; } }
6031	public function addself ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate self. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "self"!' , E_USER_WARNING ) ; } } $ this -> childMedias [ ] = $ item ; return $ this ; }
2805	public function viewAction ( ) { $ token = ( string ) $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) ; return $ this -> _getRefererUrl ( ) ; } $ requestInfo = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestInfo -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; return $ this -> _getRefererUrl ( ) ; } $ section = $ this -> getRequest ( ) -> getParam ( 'panel' , 'request' ) ; if ( ! in_array ( $ section , array ( 'request' , 'performance' , 'events' , 'db' , 'logging' , 'email' , 'layout' , 'config' ) ) ) { $ section = 'request' ; } Mage :: register ( 'sheep_debug_request_info' , $ requestInfo ) ; $ blockName = 'sheep_debug_' . $ section ; $ blockTemplate = "sheep_debug/view/panel/{$section}.phtml" ; $ this -> loadLayout ( ) ; $ layout = $ this -> getLayout ( ) ; $ sectionBlock = $ layout -> createBlock ( 'sheep_debug/view' , $ blockName , array ( 'template' => $ blockTemplate ) ) ; $ layout -> getBlock ( 'sheep_debug_content' ) -> insert ( $ sectionBlock ) ; $ layout -> getBlock ( 'root' ) -> setHeaderTitle ( $ this -> __ ( 'Profile for request %s (%s)' , $ requestInfo -> getRequestPath ( ) , $ requestInfo -> getToken ( ) ) ) ; $ this -> renderLayout ( ) ; }
9937	private static function checkSheetCodeName ( $ pValue ) { $ CharCount = Shared \ StringHelper :: countCharacters ( $ pValue ) ; if ( $ CharCount == 0 ) { throw new Exception ( 'Sheet code name cannot be empty.' ) ; } if ( ( str_replace ( self :: $ invalidCharacters , '' , $ pValue ) !== $ pValue ) || ( Shared \ StringHelper :: substring ( $ pValue , - 1 , 1 ) == '\'' ) || ( Shared \ StringHelper :: substring ( $ pValue , 0 , 1 ) == '\'' ) ) { throw new Exception ( 'Invalid character found in sheet code name' ) ; } if ( $ CharCount > 31 ) { throw new Exception ( 'Maximum 31 characters allowed in sheet code name.' ) ; } return $ pValue ; }
11099	public static function maxCount ( ) { $ array = \ func_get_args ( ) ; if ( ! \ is_array ( $ array ) ) { return 0 ; } $ maxCnt = 0 ; foreach ( $ array as $ item ) { if ( ! \ is_array ( $ item ) ) { continue ; } $ cnt = \ count ( $ item ) ; $ maxCnt = $ cnt > $ maxCnt ? $ cnt : $ maxCnt ; } return $ maxCnt ; }
1571	public function getProcessId ( ) : ? string { if ( is_null ( $ this -> processId ) ) { return $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; } return $ this -> processId ? : null ; }
4246	private function logRequest ( ) { $ this -> logRequestHeaders ( ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.cookies' ) ) { $ cookieVals = $ _COOKIE ; \ ksort ( $ cookieVals , SORT_NATURAL ) ; $ this -> debug -> log ( '$_COOKIE' , $ cookieVals ) ; } $ noBody = ! isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) || \ in_array ( $ _SERVER [ 'REQUEST_METHOD' ] , array ( 'CONNECT' , 'GET' , 'HEAD' , 'OPTIONS' , 'TRACE' ) ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.post' ) && ! $ noBody ) { if ( $ _POST ) { $ this -> debug -> log ( '$_POST' , $ _POST ) ; } else { $ input = \ file_get_contents ( 'php://input' ) ; if ( $ input ) { $ this -> debug -> log ( 'php://input' , $ input ) ; } elseif ( isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) && empty ( $ _FILES ) ) { $ this -> debug -> warn ( $ _SERVER [ 'REQUEST_METHOD' ] . ' request with no body' ) ; } } if ( ! empty ( $ _FILES ) ) { $ this -> debug -> log ( '$_FILES' , $ _FILES ) ; } } }
266	protected function loadMessages ( $ category , $ language ) { if ( $ this -> enableCaching ) { $ key = [ __CLASS__ , $ category , $ language , ] ; $ messages = $ this -> cache -> get ( $ key ) ; if ( $ messages === false ) { $ messages = $ this -> loadMessagesFromDb ( $ category , $ language ) ; $ this -> cache -> set ( $ key , $ messages , $ this -> cachingDuration ) ; } return $ messages ; } return $ this -> loadMessagesFromDb ( $ category , $ language ) ; }
2083	public function generateInternalCache ( ) { $ container = System :: getContainer ( ) ; $ warmer = $ container -> get ( 'contao.cache.warm_internal' ) ; $ warmer -> warmUp ( $ container -> getParameter ( 'kernel.cache_dir' ) ) ; $ this -> log ( 'Generated the internal cache' , __METHOD__ , TL_CRON ) ; }
5602	public function paintFail ( $ message ) { if ( ! $ this -> fail && ! $ this -> error ) { $ this -> fail = true ; $ this -> message = self :: escapeVal ( $ message ) ; $ this -> listener -> write ( '{status:"fail",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
9132	protected function validate ( $ config , $ name , $ path ) { if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The definition of "%s" in "%s" must be a YAML array.' , $ name , $ path ) ) ; } if ( $ extraKeys = array_diff ( array_keys ( $ config ) , self :: $ availableKeys ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The routing file "%s" contains unsupported keys for "%s": "%s". Expected one of: "%s".' , $ path , $ name , implode ( '", "' , $ extraKeys ) , implode ( '", "' , self :: $ availableKeys ) ) ) ; } if ( isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The business rule file "%s" must not specify both the "resource" key and the "expression" key for "%s". Choose between an import and a rule definition.' , $ path , $ name ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'type' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "type" key for the rule definition "%s" in "%s" is unsupported. It is only available for imports in combination with the "resource" key.' , $ name , $ path ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && ! isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'You must define an "expression" for the rule "%s" in file "%s".' , $ name , $ path ) ) ; } if ( isset ( $ config [ 'tags' ] ) && ! is_array ( $ config [ 'tags' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } elseif ( isset ( $ config [ 'tags' ] ) ) { foreach ( $ config [ 'tags' ] as $ tag ) { if ( ! isset ( $ tag [ 'name' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } } } }
9864	private function writeDataValidations ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ dataValidationCollection = $ pSheet -> getDataValidationCollection ( ) ; if ( ! empty ( $ dataValidationCollection ) ) { $ dataValidationCollection = Coordinate :: mergeRangesInCollection ( $ dataValidationCollection ) ; $ objWriter -> startElement ( 'dataValidations' ) ; $ objWriter -> writeAttribute ( 'count' , count ( $ dataValidationCollection ) ) ; foreach ( $ dataValidationCollection as $ coordinate => $ dv ) { $ objWriter -> startElement ( 'dataValidation' ) ; if ( $ dv -> getType ( ) != '' ) { $ objWriter -> writeAttribute ( 'type' , $ dv -> getType ( ) ) ; } if ( $ dv -> getErrorStyle ( ) != '' ) { $ objWriter -> writeAttribute ( 'errorStyle' , $ dv -> getErrorStyle ( ) ) ; } if ( $ dv -> getOperator ( ) != '' ) { $ objWriter -> writeAttribute ( 'operator' , $ dv -> getOperator ( ) ) ; } $ objWriter -> writeAttribute ( 'allowBlank' , ( $ dv -> getAllowBlank ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showDropDown' , ( ! $ dv -> getShowDropDown ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showInputMessage' , ( $ dv -> getShowInputMessage ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showErrorMessage' , ( $ dv -> getShowErrorMessage ( ) ? '1' : '0' ) ) ; if ( $ dv -> getErrorTitle ( ) !== '' ) { $ objWriter -> writeAttribute ( 'errorTitle' , $ dv -> getErrorTitle ( ) ) ; } if ( $ dv -> getError ( ) !== '' ) { $ objWriter -> writeAttribute ( 'error' , $ dv -> getError ( ) ) ; } if ( $ dv -> getPromptTitle ( ) !== '' ) { $ objWriter -> writeAttribute ( 'promptTitle' , $ dv -> getPromptTitle ( ) ) ; } if ( $ dv -> getPrompt ( ) !== '' ) { $ objWriter -> writeAttribute ( 'prompt' , $ dv -> getPrompt ( ) ) ; } $ objWriter -> writeAttribute ( 'sqref' , $ coordinate ) ; if ( $ dv -> getFormula1 ( ) !== '' ) { $ objWriter -> writeElement ( 'formula1' , $ dv -> getFormula1 ( ) ) ; } if ( $ dv -> getFormula2 ( ) !== '' ) { $ objWriter -> writeElement ( 'formula2' , $ dv -> getFormula2 ( ) ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
2434	public function set ( $ strKey , $ varValue ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { $ this -> session -> set ( $ strKey , $ varValue ) ; } else { $ this -> sessionBag -> set ( $ strKey , $ varValue ) ; } }
12093	public function getDomainUrl ( $ address , $ scheme = false ) { $ this -> urlAddress -> setAddress ( $ address ) ; return $ this -> urlAddress -> getDomain ( $ scheme ) ; }
11441	public function setRegistry ( $ var = null , $ val = null , $ section = false ) { if ( is_null ( $ var ) ) { return ; } if ( $ section ) { if ( ! isset ( $ this -> registry [ $ section ] ) ) { $ this -> registry [ $ section ] = array ( ) ; } $ this -> registry [ $ section ] [ $ var ] = $ val ; } else { $ this -> registry [ $ var ] = $ val ; } return $ this ; }
3976	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'colname' ) ) { return ; } $ oldColumnName = $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) ) ; $ columnName = $ event -> getValue ( ) ; $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; if ( ( ! $ columnName ) || $ oldColumnName !== $ columnName ) { $ this -> tableManipulator -> checkColumnDoesNotExist ( $ metaModel -> getTableName ( ) , $ columnName ) ; $ colNames = array_keys ( $ metaModel -> getAttributes ( ) ) ; if ( in_array ( $ columnName , $ colNames ) ) { throw new \ RuntimeException ( sprintf ( $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'columnExists' , 'ERR' ) , $ columnName , $ metaModel -> getTableName ( ) ) ) ; } } }
8576	public function setItemChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7706	function _ApplyDiffFromStart ( $ Diff ) { $ this -> pST_PosEnd += $ Diff ; $ this -> pST_Src = false ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; }
4364	private static function setStr ( $ str ) { self :: $ str = $ str ; self :: $ curI = 0 ; self :: $ stats = array ( 'bytesOther' => 0 , 'bytesSpecial' => 0 , 'bytesUtf8' => 0 , 'strLen' => \ strlen ( $ str ) , ) ; }
2622	public function sendConfigurationRequest ( $ configuredFlag ) { if ( $ configuredFlag ) { $ configuredState = self :: FASTLY_CONFIGURED_FLAG ; } else { $ configuredState = self :: FASTLY_NOT_CONFIGURED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ configuredState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ configuredState , 'dt' => ucfirst ( $ configuredState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ configuredState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
11178	public function getApi ( ) { $ api = $ this -> get ( Keys :: EXT_API ) ; if ( is_array ( $ api ) ) { return $ api ; } return false ; }
1979	public static function generate ( $ strScope = TL_MODE ) { $ strMessages = static :: generateUnwrapped ( $ strScope ) ; if ( $ strMessages != '' ) { $ strMessages = '<div class="tl_message">' . $ strMessages . '</div>' ; } return $ strMessages ; }
11662	public static function saveToString ( $ properties ) { $ xn = new \ SimpleXMLElement ( self :: XML_ROOT_OPEN . self :: XML_ROOT_CLOSE , LIBXML_NOXMLDECL ) ; foreach ( $ properties as $ key => $ value ) { $ xn -> addChild ( "entry" , htmlspecialchars ( $ value , ENT_XML1 ) ) -> addAttribute ( "key" , htmlspecialchars ( $ key , ENT_XML1 ) ) ; } return preg_replace ( '/\<\?.*\?\>/' , self :: XML_PRELUDE , $ xn -> asXML ( ) ) ; }
7543	function getSibling ( $ offset = 1 ) { $ index = $ this -> index ( ) + $ offset ; if ( ( $ index >= 0 ) && ( $ index < $ this -> parent -> childCount ( ) ) ) { return $ this -> parent -> getChild ( $ index ) ; } else { return null ; } }
2201	public static function initialize ( ) { $ _GET = static :: cleanKey ( $ _GET ) ; $ _POST = static :: cleanKey ( $ _POST ) ; $ _COOKIE = static :: cleanKey ( $ _COOKIE ) ; }
4821	public function getAsArray ( $ fieldName ) { if ( ! array_key_exists ( $ fieldName , $ this -> row ) ) { return [ ] ; } $ result = $ this -> row [ $ fieldName ] ; if ( empty ( $ result ) ) { return [ ] ; } return ( array ) $ result ; }
6260	public function getControllerNameAndAction ( Request $ request ) { $ controller = $ this -> _registry -> getController ( ) ; $ name = $ controller -> name ; $ action = $ request -> action ; if ( ! empty ( $ request -> params [ 'plugin' ] ) ) { $ name = Inflector :: camelize ( $ request -> params [ 'plugin' ] ) . '.' . $ name ; } return compact ( 'name' , 'action' ) ; }
12544	public function setLink ( string $ link = null ) : \ TheCMSThread \ Core \ Main \ View { $ this -> link = $ link ; return $ this ; }
10540	protected function typeModification ( $ type , array $ args ) { if ( is_int ( $ args [ 1 ] ) ) { $ type .= '(' . $ args [ 1 ] ; if ( isset ( $ args [ 2 ] ) ) { $ type .= ',' . $ args [ 2 ] ; } $ type .= ')' ; } elseif ( is_array ( $ args [ 1 ] ) ) { if ( isset ( $ args [ 1 ] [ 'size' ] ) ) { $ type .= '(' . $ args [ 1 ] [ 'size' ] . ')' ; } foreach ( $ args [ 1 ] as $ key => $ val ) { if ( 'size' === $ key ) { continue ; } $ type .= ' ' . strtoupper ( $ key ) ; } } else { $ type .= $ args [ 1 ] ; } return $ type ; }
8006	public static function forReasonCode ( $ code = 0 , Exception $ previous = null ) { switch ( $ code ) { case self :: CODE_FOR_ENCRYPTION_FAILURE : $ message = self :: MESSAGE_FOR_ENCRYPTION_FAILURE ; break ; case self :: CODE_FOR_RANDOM_DATA_GENERATION_FAILURE : $ message = self :: MESSAGE_FOR_RANDOM_DATA_GENERATION_FAILURE ; break ; default : $ message = self :: DEFAULT_MESSAGE ; } return new static ( $ message , $ code , $ previous ) ; }
1183	protected function getSessionToken ( ) { $ token = null ; if ( $ session = $ this -> app -> __get ( 'session' ) ) { $ token = $ session -> token ( ) ; } if ( $ encrypter = $ this -> app -> __get ( 'encrypter' ) ) { $ token = $ encrypter -> encrypt ( $ token ) ; } return $ token ; }
862	private static function getCache ( $ key ) { if ( ! self :: hasCache ( $ key ) ) { throw new \ OutOfBoundsException ( sprintf ( 'Unknown cache key: "%s".' , $ key ) ) ; } return self :: $ cache [ $ key ] ; }
4243	public function onShutdown ( ) { $ this -> runtimeVals ( ) ; if ( $ this -> testEmailLog ( ) ) { $ this -> emailLog ( ) ; } if ( ! $ this -> debug -> getData ( 'outputSent' ) ) { echo $ this -> debug -> output ( ) ; } return ; }
7819	public function settle ( ) { $ this -> files -> makeDirectory ( $ this -> path , 0755 , true , true ) ; $ this -> files -> put ( $ this -> getSource ( ) , '' ) ; }
2581	protected function loadOverrideSoapClient ( $ params ) { if ( isset ( $ params [ 'overrideSoapClient' ] ) && $ params [ 'overrideSoapClient' ] instanceof \ SoapClient ) { $ this -> overrideSoapClient = $ params [ 'overrideSoapClient' ] ; } if ( isset ( $ params [ 'overrideSoapClientWsdlName' ] ) ) { $ this -> overrideSoapClientWsdlName = $ params [ 'overrideSoapClientWsdlName' ] ; } }
824	public function getName ( ) { if ( null === $ this -> name ) { Preg :: matchAll ( '/@[a-zA-Z0-9_-]+(?=\s|$)/' , $ this -> line -> getContent ( ) , $ matches ) ; if ( isset ( $ matches [ 0 ] [ 0 ] ) ) { $ this -> name = ltrim ( $ matches [ 0 ] [ 0 ] , '@' ) ; } else { $ this -> name = 'other' ; } } return $ this -> name ; }
5872	public static function getTransformation ( $ orientation ) { $ transformation = '' ; if ( ( isset ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'processor' ] ) && $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'processor' ] === 'ImageMagick' ) || ( isset ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'im_version_5' ] ) && $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'im_version_5' ] !== 'gm' ) ) { if ( $ orientation >= 2 && $ orientation <= 8 ) { $ transformation = '-auto-orient' ; } } else { switch ( $ orientation ) { case 2 : $ transformation = '-flip horizontal' ; break ; case 3 : $ transformation = '-rotate 180' ; break ; case 4 : $ transformation = '-flip vertical' ; break ; case 5 : $ transformation = '-transpose' ; break ; case 6 : $ transformation = '-rotate 90' ; break ; case 7 : $ transformation = '-transverse' ; break ; case 8 : $ transformation = '-rotate 270' ; break ; } } return $ transformation ; }
5864	public function getDirectoryPattern ( $ directory ) { $ pattern = '/^' . str_replace ( '/' , '\\/' , $ directory ) . '/' ; $ pattern = str_replace ( '\\/**\\/' , '\\/([^\/]+\\/)*' , $ pattern ) ; $ pattern = str_replace ( '\\/*\\/' , '\\/[^\/]+\\/' , $ pattern ) ; return $ pattern ; }
12080	public function updateChild ( $ idParent , FilterRequest $ filters , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> updateChild ( $ idParent , $ relation , $ idChild , $ filters -> all ( ) ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
8091	static public function examine ( $ hash ) { if ( strlen ( $ hash ) == 40 && preg_match ( "/^[0-9]{4}/" , $ hash ) ) { $ e_uid_pos = substr ( $ hash , 0 , 2 ) ; $ e_uid_length = substr ( $ hash , 2 , 2 ) ; $ e_uid = substr ( $ hash , $ e_uid_pos , $ e_uid_length ) ; $ uid = self :: decode ( $ e_uid ) ; preg_match ( '/^([0-9]{4})(.{2,' . ( $ e_uid_pos - 4 ) . '})(' . $ e_uid . ')/' , $ hash , $ excerpt ) ; $ partial = $ excerpt [ 2 ] ; return array ( $ uid , $ partial ) ; } else { return array ( false , false ) ; } }
4649	protected function getServices ( $ config ) { $ services = array ( ) ; $ travisServices = isset ( $ config [ 'services' ] ) && is_array ( $ config [ 'services' ] ) ? $ config [ 'services' ] : array ( ) ; foreach ( $ travisServices as $ service ) { if ( isset ( $ this -> servicesMapping [ $ service ] ) ) { $ services [ ] = new Service ( $ service , $ this -> servicesMapping [ $ service ] [ 'repository' ] , $ this -> servicesMapping [ $ service ] [ 'tag' ] , $ this -> servicesMapping [ $ service ] [ 'config' ] ) ; } } return $ services ; }
9475	public function stripQuotes ( $ string ) { if ( strlen ( $ string ) < 2 || substr ( $ string , 0 , 1 ) !== '"' || substr ( $ string , - 1 , 1 ) !== '"' ) { return $ string ; } return substr ( $ string , 1 , - 1 ) ; }
2839	public function getFilteredRequestListUrl ( $ filters = array ( ) ) { $ currentFilters = Mage :: helper ( 'sheep_debug/filter' ) -> getRequestFilters ( $ this -> getRequest ( ) ) ; $ filters = array_merge ( $ currentFilters , $ filters ) ; return $ this -> getRequestListUrl ( $ filters ) ; }
6303	protected function active ( array $ nav ) { foreach ( $ nav as $ key => $ value ) { if ( isset ( $ value [ 'slug' ] ) ) { if ( $ this -> request -> is ( $ value [ 'slug' ] ) || $ this -> request -> is ( $ value [ 'slug' ] . '/*' ) ) { $ nav [ $ key ] [ 'active' ] = true ; } else { $ nav [ $ key ] [ 'active' ] = false ; } } else { $ nav [ $ key ] [ 'active' ] = false ; } } return $ nav ; }
7113	public function urlAllowed ( $ user , $ url ) { if ( empty ( $ url ) ) { return false ; } if ( is_array ( $ url ) ) { $ url = Hash :: merge ( [ 'plugin' => null ] , $ url ) ; $ url = Router :: url ( $ url ) ; $ url = Router :: normalize ( $ url ) ; } $ route = Router :: parse ( $ url ) ; if ( empty ( $ route [ 'controller' ] ) || empty ( $ route [ 'action' ] ) ) { return false ; } return $ this -> isAuthorized ( $ user , $ route [ 'plugin' ] , $ route [ 'controller' ] , $ route [ 'action' ] ) ; }
8628	public static function fromXML ( $ xml ) { $ dom = new DOMDocument ( ) ; $ dom -> loadXML ( $ xml ) ; $ xpath = new DOMXPath ( $ dom ) ; $ response = $ xpath -> query ( "//*[local-name()='GetCompetitivePricingForSKUResponse']" ) ; if ( $ response -> length == 1 ) { return new MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse ( ( $ response -> item ( 0 ) ) ) ; } else { throw new Exception ( "Unable to construct MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse from provided XML. Make sure that GetCompetitivePricingForSKUResponse is a root element" ) ; } }
9321	protected function compileMarkdownEchos ( $ value ) { $ pattern = sprintf ( '/(@)?%s\s*(.+?)\s*%s(\r?\n)?/s' , $ this -> markdownTags [ 0 ] , $ this -> markdownTags [ 1 ] ) ; $ callback = function ( $ matches ) { $ wrapper = sprintf ( $ this -> markdownFormat , $ this -> compileEchoDefaults ( $ matches [ 2 ] ) ) ; return $ matches [ 1 ] ? strlen ( stripcslashes ( $ this -> markdownTags [ 0 ] ) ) > 2 ? $ matches [ 0 ] : substr ( $ matches [ 0 ] , 1 ) : '<?php echo ' . $ wrapper . '; ?>' ; } ; return preg_replace_callback ( $ pattern , $ callback , $ value ) ; }
2584	public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ qPassErrors = "//m:passengerErrorInEnhancedData//m:errorDetails/m:errorCode" ; $ qPassErrorCat = "//m:passengerErrorInEnhancedData//m:errorDetails/m:errorCategory" ; $ qPassErrorMsg = "//m:passengerErrorInEnhancedData//m:freeText" ; $ errorCodeNodeList = $ domXpath -> query ( $ qPassErrors ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ errorCatNode = $ domXpath -> query ( $ qPassErrorCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( $ qPassErrorMsg ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'passenger' ) ; } if ( empty ( $ analyzeResponse -> messages ) && $ analyzeResponse -> status === Result :: STATUS_OK ) { $ analyzeResponse = $ this -> analyzeSimpleResponseErrorCodeAndMessage ( $ response ) ; } return $ analyzeResponse ; }
8420	public function renderWidget ( $ config = [ ] ) { $ widgetHtml = $ this -> render ( $ this -> template , [ 'name' => $ this -> getModelName ( ) , 'attribute' => $ this -> attribute , 'label' => $ this -> label , 'texture' => $ this -> getTexture ( ) , 'disabled' => $ this -> disabled ] ) ; if ( $ this -> wrap ) { return Html :: tag ( $ this -> wrapper , $ widgetHtml , $ this -> options ) ; } return $ widgetHtml ; }
12208	public function getSingleWidget ( ) { if ( is_null ( $ this -> _singleWidget ) ) { $ this -> _singleWidget = false ; $ widgets = $ this -> collectorItem -> getAll ( ) ; if ( ! empty ( $ widgets ) ) { $ widget = array_shift ( $ widgets ) ; $ this -> _singleWidget = Yii :: $ app -> collectors [ 'widgets' ] -> build ( $ this , $ widget -> object ) ; } } return $ this -> _singleWidget ; }
10932	public function hasRowsWith ( string $ tablename , string $ colName , $ colValue ) : bool { return ( $ this -> countRowsWith ( $ tablename , $ colName , $ colValue ) > 0 ) ; }
12319	public function redirect ( string $ shortURLKey ) { $ record = HCShortURL :: where ( 'short_url_key' , $ shortURLKey ) -> first ( ) ; if ( ! $ record ) abort ( 404 ) ; $ record -> increment ( 'clicks' ) ; return redirect ( $ record -> url ) ; }
6502	public function parseQueryString ( Uri $ uri ) : IImmutableDictionary { if ( ( $ queryString = $ uri -> getQueryString ( ) ) === null ) { return new ImmutableHashTable ( [ ] ) ; } if ( ! isset ( $ this -> parsedQueryStringCache [ $ queryString ] ) ) { $ parsedQueryString = [ ] ; parse_str ( $ queryString , $ parsedQueryString ) ; $ kvps = [ ] ; foreach ( $ parsedQueryString as $ key => $ value ) { $ kvps [ ] = new KeyValuePair ( $ key , $ value ) ; } $ this -> parsedQueryStringCache [ $ queryString ] = new ImmutableHashTable ( $ kvps ) ; } return $ this -> parsedQueryStringCache [ $ queryString ] ; }
9457	public function addCountableAttribute ( $ attribute ) { if ( empty ( $ attribute ) ) { return false ; } if ( in_array ( $ attribute , $ this -> getCountableAttributes ( ) , true ) ) { return false ; } $ this -> addToArrayValue ( 'countableAttributes' , $ attribute ) ; return $ this ; }
6979	private function getClient ( ) { if ( null !== $ this -> client ) { return $ this -> client ; } try { return $ this -> client = new \ SoapClient ( static :: ENDPOINT ) ; } catch ( \ SoapFault $ oExcept ) { if ( $ this -> debug ) { @ trigger_error ( 'Failed to connect to the europa web service: ' . $ oExcept -> getMessage ( ) ) ; } } return $ this -> client = null ; }
9522	public function upsertDoc ( string $ collectionName , string $ docId , array $ docOrSubset ) : void { $ doc = $ this -> getDoc ( $ collectionName , $ docId ) ; if ( $ doc ) { $ this -> updateDoc ( $ collectionName , $ docId , $ docOrSubset ) ; } else { $ this -> addDoc ( $ collectionName , $ docId , $ docOrSubset ) ; } }
5780	private function setNav ( ) { $ this -> nav = [ 'System' => [ 'subSections' => [ 'Administrators' => [ 'route' => ROUTE_ADMINISTRATORS , 'authorization' => ADMINISTRATORS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_INSERT , 'authorization' => ADMINISTRATORS_INSERT_RESOURCE , ] , ] ] , 'Roles' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES , 'authorization' => ROLES_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES_INSERT , 'authorization' => ROLES_INSERT_RESOURCE , ] , ] , ] , 'Permissions' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS , 'authorization' => PERMISSIONS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS_INSERT , 'authorization' => PERMISSIONS_INSERT_RESOURCE , ] , ] ] , 'Events' => [ 'route' => ROUTE_EVENTS , 'authorization' => EVENTS_VIEW_RESOURCE , 'subSections' => [ 'Types' => [ 'route' => ROUTE_DATABASE_TABLES , 'args' => [ ROUTEARG_DATABASE_TABLE_NAME => 'event_types' ] , 'authorization' => EVENTS_VIEW_RESOURCE , ] , ] ] , 'Database' => [ 'authorization' => DATABASE_TABLES_VIEW_RESOURCE , 'subSections' => $ this -> getDatabaseTablesSection ( ) ] , ] ] , 'Logout' => [ 'route' => ROUTE_LOGOUT , ] , ] ; if ( isset ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { if ( ! is_array ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { throw new \ Exception ( "adminNav config must be array" ) ; } $ this -> nav = array_merge ( $ this -> container [ 'settings' ] [ 'adminNav' ] , $ this -> nav ) ; } }
11939	public function findOne ( $ params = [ ] ) { return $ this -> populateRecord ( $ this -> find ( $ params ) -> one ( $ this -> interface -> db ) ) ; }
12168	public function createPropertyValuesProxyTable ( $ group , $ dropExisting = true ) { $ group = strtolower ( $ group ) ; if ( ! empty ( $ group ) ) : $ this -> database -> query ( "DROP TABLE IF EXISTS `?{$group}_property_values`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?{$group}_property_values` ( `value_id` mediumint(11) NOT NULL AUTO_INCREMENT, `value_data` text NOT NULL, `value_updated_on` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `property_id` int(11) NOT NULL, `object_id` int(11) NOT NULL, PRIMARY KEY (`value_id`), UNIQUE KEY `object_property_uid` (`object_id`,`property_id`), KEY `property_id_idxfk` (`property_id`), KEY `object_id_idxfk` (`object_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?{$group}_property_value_validate_insert`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?{$group}_property_value_validate_insert` BEFORE INSERT ON `?{$group}_property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?{$group}_property_value_validate_update`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?{$group}_property_value_validate_update` BEFORE UPDATE ON `?{$group}_property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "ALTER TABLE `?{$group}_property_values` ADD CONSTRAINT `{$group}_property_values_ibfk_1` FOREIGN KEY (`object_id`) REFERENCES `?objects` (`object_id`), ADD CONSTRAINT `{$group}_property_values_ibfk_2` FOREIGN KEY (`property_id`) REFERENCES `?properties` (`property_id`) ON DELETE CASCADE;" ) ; endif ; }
4208	private function isObjExcluded ( $ obj ) { if ( \ in_array ( \ get_class ( $ obj ) , $ this -> abstracter -> getCfg ( 'objectsExclude' ) ) ) { return true ; } foreach ( $ this -> abstracter -> getCfg ( 'objectsExclude' ) as $ exclude ) { if ( \ is_subclass_of ( $ obj , $ exclude ) ) { return true ; } } return false ; }
3136	public function setItemState ( RunnerServiceContext $ context , $ itemRef , $ state ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; if ( ! isset ( $ state ) ) { $ state = '' ; } return is_null ( $ userUri ) ? false : $ serviceService -> set ( $ userUri , $ stateId , json_encode ( $ state ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'setItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
1370	protected function bindExceptionParser ( ) { $ this -> app -> singleton ( ExceptionParserInterface :: class , ExceptionParser :: class ) ; $ this -> app -> alias ( ExceptionParserInterface :: class , 'json-api.exceptions' ) ; }
8275	public function handleEvent ( $ eventName , array $ params ) { if ( method_exists ( $ this , $ eventName ) ) { call_user_func_array ( array ( $ this , $ eventName ) , $ params ) ; } }
1839	protected static function find ( array $ arrOptions ) { if ( static :: $ strTable == '' ) { return null ; } if ( $ arrOptions [ 'return' ] == 'Model' ) { $ arrColumn = ( array ) $ arrOptions [ 'column' ] ; if ( \ count ( $ arrColumn ) == 1 ) { $ arrColumn [ 0 ] = preg_replace ( '/^' . preg_quote ( static :: getTable ( ) , '/' ) . '\./' , '' , $ arrColumn [ 0 ] ) ; if ( $ arrColumn [ 0 ] == static :: $ strPk || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) { $ varKey = \ is_array ( $ arrOptions [ 'value' ] ) ? $ arrOptions [ 'value' ] [ 0 ] : $ arrOptions [ 'value' ] ; $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varKey , $ arrColumn [ 0 ] ) ; if ( $ objModel !== null ) { return $ objModel ; } } } } $ arrOptions [ 'table' ] = static :: $ strTable ; $ strQuery = static :: buildFindQuery ( $ arrOptions ) ; $ objStatement = Database :: getInstance ( ) -> prepare ( $ strQuery ) ; if ( ! isset ( $ arrOptions [ 'limit' ] ) ) { $ arrOptions [ 'limit' ] = 0 ; } if ( ! isset ( $ arrOptions [ 'offset' ] ) ) { $ arrOptions [ 'offset' ] = 0 ; } if ( $ arrOptions [ 'limit' ] > 0 || $ arrOptions [ 'offset' ] > 0 ) { $ objStatement -> limit ( $ arrOptions [ 'limit' ] , $ arrOptions [ 'offset' ] ) ; } $ objStatement = static :: preFind ( $ objStatement ) ; $ objResult = $ objStatement -> execute ( $ arrOptions [ 'value' ] ) ; if ( $ objResult -> numRows < 1 ) { return $ arrOptions [ 'return' ] == 'Array' ? array ( ) : null ; } $ objResult = static :: postFind ( $ objResult ) ; if ( $ arrOptions [ 'return' ] == 'Model' ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ objResult -> { static :: $ strPk } ) ; if ( $ objModel !== null ) { return $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; } return static :: createModelFromDbResult ( $ objResult ) ; } elseif ( $ arrOptions [ 'return' ] == 'Array' ) { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) -> getModels ( ) ; } else { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) ; } }
12753	public function sendRecoveryMessage ( User $ user , Token $ token ) { return $ this -> sendMessage ( $ user -> email , $ this -> recoverySubject , 'recovery' , [ 'user' => $ user , 'token' => $ token ] ) ; }
5481	public function getValue ( SelectorInterface $ selector ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { return $ this -> widgets [ $ i ] -> getValue ( ) ; } } foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { return $ button -> getValue ( ) ; } } return ; }
2715	public function render ( ) { return [ 'id' => $ this -> getId ( ) , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => 1 , 'label' => $ this -> label , 'comment' => $ this -> comment , '_elementType' => 'group' , 'path' => self :: BASE_CONFIG_PATH , 'children' => $ this -> children ] ; }
7901	protected function runUpload ( $ file ) { $ this -> provider -> setFile ( $ file ) ; if ( ! $ this -> provider -> isValid ( ) ) { throw new InvalidFileException ( "Given file [{$file}] is invalid." ) ; } $ filename = $ this -> getFullFileName ( $ this -> provider ) ; if ( $ this -> filesystem -> disk ( $ this -> disk ) -> put ( $ filename , $ this -> provider -> getContents ( ) , $ this -> getVisibility ( ) ) ) { return $ filename ; } return false ; }
2430	public function listStyleSheet ( $ row ) { $ cc = '' ; $ media = Contao \ StringUtil :: deserialize ( $ row [ 'media' ] ) ; if ( $ row [ 'cc' ] != '' ) { $ cc = ' &lt;!--[' . $ row [ 'cc' ] . ']&gt;' ; } if ( $ row [ 'mediaQuery' ] != '' ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . $ row [ 'mediaQuery' ] . $ cc . '</span>' . "</div>\n" ; } elseif ( ! empty ( $ media ) && \ is_array ( $ media ) ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . implode ( ', ' , $ media ) . $ cc . '</span>' . "</div>\n" ; } else { return '<div class="tl_content_left">' . $ row [ 'name' ] . $ cc . "</div>\n" ; } }
4907	public function onRoute ( MvcEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ ajax = $ request -> getQuery ( ) -> get ( 'ajax' ) ; if ( ! $ request -> isXmlHttpRequest ( ) || ! $ ajax ) { return ; } $ response = $ event -> getResponse ( ) ; $ ajaxEvent = $ this -> ajaxEventManager -> getEvent ( $ ajax , $ this ) ; $ ajaxEvent -> setRequest ( $ request ) ; $ ajaxEvent -> setResponse ( $ response ) ; $ results = $ this -> ajaxEventManager -> triggerEventUntil ( function ( $ r ) { return null !== $ r ; } , $ ajaxEvent ) ; $ result = $ results -> last ( ) ? : $ ajaxEvent -> getResult ( ) ; if ( ! $ result ) { throw new \ UnexpectedValueException ( 'No listener returned anything. Do not know what to do...' ) ; } if ( is_array ( $ result ) || $ result instanceof \ Traversable ) { $ result = Json :: encode ( $ result , true , [ 'enableJsonExprFinder' => true ] ) ; } $ contentType = $ ajaxEvent -> getContentType ( ) ; $ response -> getHeaders ( ) -> addHeaderLine ( 'Content-Type' , $ contentType ) ; $ response -> setContent ( $ result ) ; return $ response ; }
3522	public static function refresh ( $ refresh_token ) { $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , [ 'grant_type' => 'refresh_token' , 'refresh_token' => $ refresh_token , 'includePerms' => "false" , 'token_type' => 'eg1' , ] , FortniteClient :: FORTNITE_AUTHORIZATION ) ; if ( ! $ data -> access_token ) { throw new \ Exception ( $ data -> errorMessage ) ; } return new self ( $ data -> access_token , $ data -> in_app_id , $ data -> refresh_token , $ data -> account_id , $ data -> expires_in ) ; }
3393	public function register ( Request $ request ) { $ this -> validator ( $ request -> all ( ) ) -> validate ( ) ; event ( new Registered ( $ user = $ this -> create ( $ request -> all ( ) ) ) ) ; $ this -> sendConfirmationToUser ( $ user ) ; return $ this -> registered ( $ request , $ user ) ? : redirect ( $ this -> redirectAfterRegistrationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_info' ) ) ; }
6711	protected function urlToParameters ( $ url ) { $ urlParameters = [ ] ; $ url = parse_url ( $ url , PHP_URL_PATH ) ; $ urlParts = explode ( '/' , $ url ) ; reset ( $ urlParts ) ; $ key = next ( $ urlParts ) ; while ( ( $ value = next ( $ urlParts ) ) !== false ) { $ urlParameters [ $ key ] = $ value ; $ key = $ value ; } return $ urlParameters ; }
11705	public function synchronizeEntity ( $ sSynchronizeEntity , $ iId = null ) { if ( $ iId !== null ) { $ this -> _iIdEntity = $ iId ; } $ this -> _sSynchronizeEntity = $ sSynchronizeEntity ; return $ this ; }
4405	public function generate ( InputInterface $ input , OutputInterface $ output ) { $ fileSystem = $ this -> container -> get ( 'filesystem' ) ; $ configResolver = $ this -> container -> get ( 'ezpublish.config.resolver' ) ; $ kernelRootDir = $ this -> container -> getParameter ( 'kernel.root_dir' ) ; $ siteAccessGroup = $ input -> getOption ( 'site-access-group' ) ; $ varDir = $ configResolver -> getParameter ( 'var_dir' , null , $ siteAccessGroup ) ; $ repository = $ configResolver -> getParameter ( 'repository' , null , $ siteAccessGroup ) ; $ configFile = $ kernelRootDir . '/config/ngadminui.yml' ; if ( $ fileSystem -> exists ( $ configFile ) ) { if ( ! $ this -> questionHelper -> ask ( $ input , $ output , new ConfirmationQuestion ( '<info><comment>ngadminui.yml</comment> configuration file already exists. Do you want to overwrite it?</info> [<comment>no</comment>] ' , false ) ) ) { return ; } } $ siteAccessName = $ input -> getOption ( 'site-access-name' ) ; $ languageService = $ this -> container -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; $ languages = $ languageService -> loadLanguages ( ) ; $ settings = array ( 'parameters' => array ( 'netgen_admin_ui.' . $ siteAccessName . '.is_admin_ui_siteaccess' => true , 'eztags.' . $ siteAccessName . '.routing.enable_tag_router' => false , 'ezsettings.' . $ siteAccessName . '.treemenu.http_cache' => false , ) , 'ezpublish' => array ( 'siteaccess' => array ( 'list' => array ( $ siteAccessName , ) , 'groups' => array ( 'ngadminui' => array ( $ siteAccessName , ) , ) , 'match' => array ( 'Map\URI' => array ( $ siteAccessName => $ siteAccessName , ) , ) , ) , 'system' => array ( $ siteAccessName => array ( 'user' => array ( 'layout' => '@NetgenAdminUI/pagelayout_login.html.twig' , 'login_template' => '@NetgenAdminUI/user/login.html.twig' , ) , 'languages' => array_map ( function ( Language $ language ) { return $ language -> languageCode ; } , $ languages ) , 'var_dir' => $ varDir , 'repository' => $ repository , ) , ) , ) , 'ez_publish_legacy' => array ( 'system' => array ( $ siteAccessName => array ( 'templating' => array ( 'view_layout' => '@NetgenAdminUI/pagelayout_legacy.html.twig' , 'module_layout' => '@NetgenAdminUI/pagelayout_module.html.twig' , ) , ) , ) , ) , ) ; file_put_contents ( $ configFile , Yaml :: dump ( $ settings , 7 ) ) ; $ output -> writeln ( array ( '' , 'Generated <comment>ngadminui.yml</comment> configuration file!' , '' , ) ) ; }
8843	public function save ( ) { if ( ! isset ( $ this -> name ) ) { return false ; } if ( class_exists ( '\Tilmeld\Tilmeld' ) && ! \ Tilmeld \ Tilmeld :: gatekeeper ( 'umailphp/admin' ) ) { return false ; } return parent :: save ( ) ; }
9119	public function registerController ( $ controller , $ applicationName = 'default' ) { if ( ! $ controller instanceof \ Nkey \ Caribu \ Mvc \ Controller \ AbstractController ) { if ( ! class_exists ( $ controller ) ) { throw new ControllerException ( "No such controller class {controller} found" , array ( 'controller' => $ controller ) ) ; } $ c = new $ controller ( ) ; if ( ! ( $ c instanceof AbstractController ) ) { throw new ControllerException ( "Controller {controller} is not in application scope" , array ( 'controller' => $ controller ) ) ; } } else { $ c = $ controller ; } $ settings = $ c -> getControllerSettings ( ) ; $ this -> controllers [ $ applicationName ] [ $ settings -> getControllerSimpleName ( ) ] = $ settings ; return $ this ; }
1507	public function didCreate ( $ resource ) : void { if ( $ this -> wasClientDispatched ( ) ) { $ this -> clientJob -> setResource ( $ resource ) -> save ( ) ; } }
8281	public function onTwigRegistered ( & $ twig ) { $ twig -> getLoader ( ) -> addPath ( $ this -> pluginDir . '/theme' ) ; $ this_instance = $ this ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_token' , function ( $ action = null ) use ( & $ this_instance ) { return $ this_instance -> csrf -> getToken ( $ action ) ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_field' , function ( $ action = null ) use ( & $ this_instance ) { return '<input type="hidden" name="csrf_token" value="' . $ this_instance -> csrf -> getToken ( $ action ) . '">' ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; }
3233	static function useExternalPaths ( ) { if ( ! self :: $ useExternalFile and self :: $ paths !== null ) { throw new \ Exception ( "You called \"useExternalFile\" too late. The SDK already used the root " . "certificate file (probably to make an API call)." ) ; } self :: $ useExternalFile = true ; }
8703	protected function registerViewComposers ( ) { $ core = $ this -> getCore ( ) ; view ( ) -> composer ( $ core -> config ( 'views.menu' ) , MenuComposer :: class ) ; view ( ) -> composer ( $ core -> config ( 'views.top' ) , TopComposer :: class ) ; return $ this ; }
10864	protected function generateHashes ( ) : array { $ dirLength = strlen ( $ this -> dir ) ; foreach ( $ this -> createIterator ( ) as $ file ) { if ( ! $ file -> isFile ( ) ) { continue ; } $ realpath = $ file -> getRealPath ( ) ; $ path = $ file -> getPath ( ) . DIRECTORY_SEPARATOR . $ file -> getFilename ( ) ; if ( $ realpath !== $ path ) { continue ; } $ path = substr ( $ realpath , $ dirLength ) ; $ lowerPath = strtolower ( $ path ) ; if ( isset ( $ this -> hashes [ $ lowerPath ] ) ) { $ message = "duplicate file encountered: $path ($lowerPath)" ; throw new \ RuntimeException ( $ message ) ; } $ this -> hashes [ $ lowerPath ] = sha1_file ( $ realpath ) ; } ksort ( $ this -> hashes ) ; return $ this -> hashes ; }
9678	public function allNumberFormats ( Spreadsheet $ spreadsheet ) { $ aNumFmts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false && ! isset ( $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] ) ) { $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] = $ style -> getNumberFormat ( ) ; } } return $ aNumFmts ; }
6844	public function callInClass ( $ class_name , $ action , $ params = array ( ) ) { $ ref = new ReflectionMethod ( $ class_name , $ action ) ; if ( ! $ ref -> isPublic ( ) && ! $ ref -> isStatic ( ) ) throw new InjectorException ( "$class_name->$action is not public or static" ) ; $ params_need = $ ref -> getParameters ( ) ; $ args = $ this -> apply ( $ params_need , $ params ) ; $ obj = $ this -> produce ( $ class_name , $ params ) ; return call_user_func_array ( [ $ obj , $ action ] , $ args ) ; }
1067	private function findConflictsBetweenSubSelectionSets ( ValidationContext $ context , $ areMutuallyExclusive , $ parentType1 , SelectionSetNode $ selectionSet1 , $ parentType2 , SelectionSetNode $ selectionSet2 ) { $ conflicts = [ ] ; [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType1 , $ selectionSet1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType2 , $ selectionSet2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; if ( $ fragmentNames2Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap1 , $ fragmentNames2 [ $ j ] ) ; } } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; if ( $ fragmentNames1Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap2 , $ fragmentNames1 [ $ i ] ) ; } } for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentNames2 [ $ j ] ) ; } } return $ conflicts ; }
8638	public function setOrderFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
701	protected function cleanupVendorDir ( $ dir ) { if ( is_link ( $ link = "$dir/vendor/yiisoft/yii2" ) ) { $ this -> stdout ( "Removing symlink $link.\n" ) ; FileHelper :: unlink ( $ link ) ; } $ extensions = $ this -> findDirs ( "$dir/vendor/yiisoft" ) ; foreach ( $ extensions as $ ext ) { if ( is_link ( $ link = "$dir/vendor/yiisoft/yii2-$ext" ) ) { $ this -> stdout ( "Removing symlink $link.\n" ) ; FileHelper :: unlink ( $ link ) ; } } }
10873	public function cleanUser ( string $ validate = null ) : int { $ result = 0 ; if ( $ validate ) { $ validateTo = new DateTime ; $ validateTo -> modify ( $ validate ) ; $ list = $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.active' => false , $ this -> tableName [ 0 ] . '.added IS NOT NULL' , [ $ this -> tableName [ 0 ] . '.added<=%dt' , $ validateTo ] , ] ) ; foreach ( $ list as $ item ) { if ( $ this -> delete ( $ item [ self :: COLUMN_ID ] ) ) { $ result ++ ; } } } return $ result ; }
1201	public function isCurrent ( ItemInterface $ item ) { if ( null === $ this -> matcher ) { throw new \ BadMethodCallException ( 'The matcher must be set to get the breadcrumbs array' ) ; } return $ this -> matcher -> isCurrent ( $ item ) ; }
7186	public function getCombination ( $ quantity , $ reset = false ) { if ( null !== $ this -> combination && ! $ reset ) { return $ this -> combination ; } $ this -> combination = null ; if ( ! empty ( $ combinations = $ this -> buildCombinations ( $ quantity ) ) ) { usort ( $ combinations , function ( AssignmentCombination $ a , AssignmentCombination $ b ) use ( $ quantity ) { if ( $ a -> diff == $ b -> diff ) { if ( $ a -> size == $ b -> size ) { return 0 ; } return $ a -> size < $ b -> size ? - 1 : 1 ; } if ( 0 <= $ a -> diff ) { return intval ( 0 > $ b -> diff ? - 1 : $ a -> diff - $ b -> diff ) ; } return intval ( 0 < $ b -> diff ? 1 : $ b -> diff - $ a -> diff ) ; } ) ; $ this -> combination = reset ( $ combinations ) ; } return $ this -> combination ; }
4068	public function configure ( MetaModelsServiceContainer $ serviceContainer ) { $ serviceContainer -> setEventDispatcher ( function ( ) { return $ this -> container -> get ( 'event_dispatcher' ) ; } ) -> setDatabase ( function ( ) { return $ this -> container -> get ( 'cca.legacy_dic.contao_database_connection' ) ; } ) -> setAttributeFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.attribute_factory' ) ; } ) -> setFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.factory' ) ; } ) -> setFilterFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.filter_setting_factory' ) ; } ) -> setRenderSettingFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.render_setting_factory' ) ; } ) -> setCache ( function ( ) { return $ this -> container -> get ( 'metamodels.cache' ) ; } ) ; return $ serviceContainer ; }
7129	public function hasNotifications ( $ type = null ) { if ( null !== $ type ) { NotificationTypes :: isValidType ( $ type ) ; return $ this -> getNotifications ( $ type ) -> count ( ) ; } return 0 < $ this -> notifications -> count ( ) ; }
1320	private function curlOptions ( ) { $ options = [ CURLOPT_CONNECTTIMEOUT => $ this -> connectionTimeout , CURLOPT_HEADER => true , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYHOST => 2 , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_TIMEOUT => $ this -> timeout , CURLOPT_USERAGENT => $ this -> userAgent , ] ; if ( $ this -> useCAFile ( ) ) { $ options [ CURLOPT_CAINFO ] = __DIR__ . DIRECTORY_SEPARATOR . 'cacert.pem' ; } if ( $ this -> gzipEncoding ) { $ options [ CURLOPT_ENCODING ] = 'gzip' ; } if ( ! empty ( $ this -> proxy ) ) { $ options [ CURLOPT_PROXY ] = $ this -> proxy [ 'CURLOPT_PROXY' ] ; $ options [ CURLOPT_PROXYUSERPWD ] = $ this -> proxy [ 'CURLOPT_PROXYUSERPWD' ] ; $ options [ CURLOPT_PROXYPORT ] = $ this -> proxy [ 'CURLOPT_PROXYPORT' ] ; $ options [ CURLOPT_PROXYAUTH ] = CURLAUTH_BASIC ; $ options [ CURLOPT_PROXYTYPE ] = CURLPROXY_HTTP ; } return $ options ; }
2052	public static function create ( $ file , $ size = null ) { if ( \ is_string ( $ file ) ) { $ file = new File ( rawurldecode ( $ file ) ) ; } $ imageSize = null ; $ picture = new static ( $ file ) ; if ( \ is_array ( $ size ) && ! empty ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ size = ( int ) $ size [ 2 ] ; } $ imageSize = null ; if ( ! \ is_array ( $ size ) ) { $ imageSize = ImageSizeModel :: findByPk ( $ size ) ; if ( $ imageSize === null ) { $ size = array ( ) ; } } if ( \ is_array ( $ size ) ) { $ size += array ( 0 , 0 , 'crop' ) ; $ imageSize = new \ stdClass ( ) ; $ imageSize -> width = $ size [ 0 ] ; $ imageSize -> height = $ size [ 1 ] ; $ imageSize -> resizeMode = $ size [ 2 ] ; $ imageSize -> zoom = 0 ; } $ picture -> setImageSize ( $ imageSize ) ; if ( $ imageSize !== null && ! empty ( $ imageSize -> id ) ) { $ picture -> setImageSizeItems ( ImageSizeItemModel :: findVisibleByPid ( $ imageSize -> id , array ( 'order' => 'sorting ASC' ) ) ) ; } $ fileRecord = FilesModel :: findByPath ( $ file -> path ) ; if ( $ fileRecord !== null && $ fileRecord -> importantPartWidth && $ fileRecord -> importantPartHeight ) { $ picture -> setImportantPart ( array ( 'x' => ( int ) $ fileRecord -> importantPartX , 'y' => ( int ) $ fileRecord -> importantPartY , 'width' => ( int ) $ fileRecord -> importantPartWidth , 'height' => ( int ) $ fileRecord -> importantPartHeight , ) ) ; } return $ picture ; }
8141	public function isTemplateFresh ( $ name , $ time ) { if ( 0 === $ this -> lastModifiedExtension ) { foreach ( $ this -> extensions as $ extension ) { $ r = new ReflectionObject ( $ extension ) ; if ( file_exists ( $ r -> getFileName ( ) ) && ( $ extensionTime = filemtime ( $ r -> getFileName ( ) ) ) > $ this -> lastModifiedExtension ) { $ this -> lastModifiedExtension = $ extensionTime ; } } } return $ this -> lastModifiedExtension <= $ time && $ this -> getLoader ( ) -> isFresh ( $ name , $ time ) ; }
2587	protected function loadCreatePnr ( PnrCreatePnrOptions $ params ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; $ tattooCounter = 0 ; if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; }
5907	public function retrieveSetting ( $ key , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/settings/' . $ key . '' , $ parameters , $ cachePolicy ) ; return $ result ; }
3271	public function writeTempToFile ( SplTempFileObject & $ tmpFile ) { $ file = $ this -> openFile ( static :: FILE_WRITE ) ; foreach ( $ tmpFile as $ line ) { $ file -> fwrite ( $ line ) ; } $ this -> closeFile ( $ file ) ; $ tmpFile = null ; }
4406	public function matches ( Request $ request ) { return in_array ( $ request -> attributes -> get ( '_route' ) , array ( FallbackRouter :: ROUTE_NAME , UrlAliasRouter :: URL_ALIAS_ROUTE_NAME ) , true ) ; }
8688	private static function canReturnArraysByReference ( ArrayAccess $ obj , $ key , & $ value , & $ ex ) { static $ supportedClasses = [ Bag :: class => true , MutableBag :: class => true , \ ArrayObject :: class => true , \ ArrayIterator :: class => true , \ RecursiveArrayIterator :: class => true , ] ; static $ noErrors = [ ] ; $ class = get_class ( $ obj ) ; if ( ! isset ( $ supportedClasses [ $ class ] ) ) { $ supportedClasses [ $ class ] = ( new \ ReflectionMethod ( $ obj , 'offsetGet' ) ) -> returnsReference ( ) ? null : false ; } if ( $ supportedClasses [ $ class ] !== null ) { return $ supportedClasses [ $ class ] ; } if ( isset ( $ noErrors [ $ class ] ) ) { $ value1 = & $ obj [ $ key ] ; } else { Thrower :: set ( ) ; try { $ value1 = & $ obj [ $ key ] ; } catch ( \ ErrorException $ e ) { $ msg = $ e -> getMessage ( ) ; if ( $ msg === 'Only variable references should be returned by reference' || strpos ( $ msg , 'Indirect modification of overloaded element' ) === 0 ) { $ ex = $ e ; return $ supportedClasses [ $ class ] = false ; } throw $ e ; } finally { restore_error_handler ( ) ; } $ noErrors [ $ class ] = true ; } if ( ! is_array ( $ value1 ) ) { $ value = $ value1 ; return true ; } $ value2 = & $ obj [ $ key ] ; $ testKey = uniqid ( '__reference_test_' ) ; $ value1 [ $ testKey ] = 'test' ; $ supportedClasses [ $ class ] = isset ( $ value2 [ $ testKey ] ) ; unset ( $ value1 [ $ testKey ] ) ; return $ supportedClasses [ $ class ] ; }
9125	private function handleHeader ( & $ delimiterFound , & $ numBytes , & $ tmp ) { if ( $ tmp == "\r\n" ) { $ numBytes = $ this -> adjustNumbytes ( $ numBytes ) ; $ delimiterFound = true ; $ tmp = "" ; return ; } if ( substr ( $ tmp , - 2 , 2 ) == "\r\n" ) { $ this -> addParsedHeader ( $ tmp ) ; $ tmp = "" ; } }
4857	public function getParams ( $ namespace , $ defaults , $ params = null ) { $ session = new Container ( $ namespace ) ; $ sessionParams = $ session -> params ? : array ( ) ; $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; if ( $ params -> get ( 'clear' ) ) { $ sessionParams = array ( ) ; unset ( $ params [ 'clear' ] ) ; } $ changed = false ; foreach ( $ defaults as $ key => $ default ) { if ( is_numeric ( $ key ) ) { $ key = $ default ; $ default = null ; } $ value = $ params -> get ( $ key ) ; if ( null === $ value ) { if ( isset ( $ sessionParams [ $ key ] ) ) { $ params -> set ( $ key , $ sessionParams [ $ key ] ) ; } elseif ( null !== $ default ) { $ params -> set ( $ key , $ default ) ; $ sessionParams [ $ key ] = $ default ; $ changed = true ; } } else { if ( ! isset ( $ sessionParams [ $ key ] ) || $ sessionParams [ $ key ] != $ value ) { $ changed = true ; $ sessionParams [ $ key ] = $ value ; } } } if ( $ changed ) { unset ( $ session -> list ) ; $ session -> params = $ sessionParams ; } return $ params ; }
5745	private function getDebugBacktraceString ( ) : string { $ out = "" ; $ dbt = debug_backtrace ( ~ DEBUG_BACKTRACE_PROVIDE_OBJECT & ~ DEBUG_BACKTRACE_IGNORE_ARGS ) ; array_shift ( $ dbt ) ; array_shift ( $ dbt ) ; $ showVendorCalls = true ; $ showFullFilePath = true ; $ startFilePath = '/Src' ; $ showClassNamespace = false ; foreach ( $ dbt as $ index => $ call ) { $ outLine = "#$index:" ; if ( isset ( $ call [ 'file' ] ) ) { if ( ! $ showVendorCalls && strstr ( $ call [ 'file' ] , '/vendor/' ) ) { break ; } $ outLine .= " " ; if ( $ showFullFilePath ) { $ outLine .= $ call [ 'file' ] ; } else { $ fileParts = explode ( $ startFilePath , $ call [ 'file' ] ) ; $ outLine .= ( isset ( $ fileParts [ 1 ] ) ) ? $ fileParts [ 1 ] : $ call [ 'file' ] ; } } if ( isset ( $ call [ 'line' ] ) ) { $ outLine .= " [" . $ call [ 'line' ] . "] " ; } if ( isset ( $ call [ 'class' ] ) ) { $ classParts = explode ( "\\" , $ call [ 'class' ] ) ; $ outLine .= " " ; $ outLine .= ( $ showClassNamespace ) ? $ call [ 'class' ] : $ classParts [ count ( $ classParts ) - 1 ] ; } if ( isset ( $ call [ 'type' ] ) ) { $ outLine .= $ call [ 'type' ] ; } if ( isset ( $ call [ 'function' ] ) ) { $ outLine .= $ call [ 'function' ] . "()" ; } if ( isset ( $ call [ 'args' ] ) ) { $ outLine .= " {" . Functions :: arrayWalkToStringRecursive ( $ call [ 'args' ] , 0 , 1000 , PHP_EOL ) . "}" ; } $ out .= "$outLine" . PHP_EOL ; } return $ out ; }
6132	protected function getSuffixFlag ( ) { if ( ! $ this -> currObj instanceof Client ) { return "" ; } if ( $ this -> flagpath && $ this -> currObj [ "client_country" ] ) { return $ this -> getImage ( $ this -> currObj [ "client_country" ] -> toLower ( ) . ".png" , $ this -> currObj [ "client_country" ] , null , false , true ) ; } return "" ; }
878	public function useRuleSet ( RuleSetInterface $ ruleSet ) { $ fixers = [ ] ; $ fixersByName = [ ] ; $ fixerConflicts = [ ] ; $ fixerNames = array_keys ( $ ruleSet -> getRules ( ) ) ; foreach ( $ fixerNames as $ name ) { if ( ! \ array_key_exists ( $ name , $ this -> fixersByName ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Rule "%s" does not exist.' , $ name ) ) ; } $ fixer = $ this -> fixersByName [ $ name ] ; $ config = $ ruleSet -> getRuleConfiguration ( $ name ) ; if ( null !== $ config ) { if ( $ fixer instanceof ConfigurableFixerInterface ) { if ( ! \ is_array ( $ config ) || ! \ count ( $ config ) ) { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Configuration must be an array and may not be empty.' ) ; } $ fixer -> configure ( $ config ) ; } else { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Is not configurable.' ) ; } } $ fixers [ ] = $ fixer ; $ fixersByName [ $ name ] = $ fixer ; $ conflicts = array_intersect ( $ this -> getFixersConflicts ( $ fixer ) , $ fixerNames ) ; if ( \ count ( $ conflicts ) > 0 ) { $ fixerConflicts [ $ name ] = $ conflicts ; } } if ( \ count ( $ fixerConflicts ) > 0 ) { throw new \ UnexpectedValueException ( $ this -> generateConflictMessage ( $ fixerConflicts ) ) ; } $ this -> fixers = $ fixers ; $ this -> fixersByName = $ fixersByName ; return $ this ; }
2855	public function getDatabaseUpdatesWithHandle ( $ handle , $ storeId , $ area ) { $ databaseHandles = array ( ) ; $ designPackage = Mage :: getModel ( 'core/design_package' ) ; $ designPackage -> setStore ( $ storeId ) ; $ designPackage -> setArea ( $ area ) ; $ layoutResourceModel = Mage :: getResourceModel ( 'core/layout' ) ; $ bind = array ( 'store_id' => $ storeId , 'area' => $ area , 'package' => $ designPackage -> getPackageName ( ) , 'theme' => $ designPackage -> getTheme ( 'layout' ) , 'layout_update_handle' => $ handle ) ; $ readAdapter = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_read' ) ; $ select = $ readAdapter -> select ( ) -> from ( array ( 'layout_update' => $ layoutResourceModel -> getMainTable ( ) ) , array ( 'layout_update_id' , 'xml' ) ) -> join ( array ( 'link' => $ layoutResourceModel -> getTable ( 'core/layout_link' ) ) , 'link.layout_update_id=layout_update.layout_update_id' , '' ) -> where ( 'link.store_id IN (0, :store_id)' ) -> where ( 'link.area = :area' ) -> where ( 'link.package = :package' ) -> where ( 'link.theme = :theme' ) -> where ( 'layout_update.handle = :layout_update_handle' ) -> order ( 'layout_update.sort_order ' . Varien_Db_Select :: SQL_ASC ) ; $ result = $ readAdapter -> fetchAssoc ( $ select , $ bind ) ; if ( count ( $ result ) ) { foreach ( $ result as $ dbLayoutUpdate ) { $ databaseHandles [ $ dbLayoutUpdate [ 'layout_update_id' ] ] = $ dbLayoutUpdate [ 'xml' ] ; } } return $ databaseHandles ; }
6375	public function first ( ) : Optional { try { return Optional :: ofNullable ( $ this -> get ( 0 ) ) ; } catch ( OutOfBoundsException $ e ) { return Optional :: absent ( ) ; } }
5093	public function rotate ( $ tableA , $ tableB ) { $ tableT = $ tableA . '_' . time ( ) . '_' . rand ( 0 , 1000000 ) ; return $ this -> rename ( [ $ tableB => $ tableT , $ tableA => $ tableB , $ tableT => $ tableA ] ) ; }
6752	public static function getCallable ( Logger $ logger , $ type , $ maxMessageLength ) { return function ( MessageInterface $ message ) use ( $ logger , $ type , $ maxMessageLength ) { $ startMessage = null ; if ( $ message instanceof RequestInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getMethod ( ) , $ message -> getRequestTarget ( ) ) ; } elseif ( $ message instanceof ResponseInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getStatusCode ( ) , $ message -> getReasonPhrase ( ) ) ; } if ( ! is_null ( $ startMessage ) ) { $ logger -> log ( Logger :: INFO , $ startMessage ) ; } foreach ( $ message -> getHeaders ( ) as $ name => $ value ) { $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s header: %s => %s" , $ type , $ name , implode ( ', ' , $ value ) ) ) ; } $ body = $ message -> getBody ( ) ; if ( strlen ( $ body ) > $ maxMessageLength ) { $ body = substr ( $ body , 0 , $ maxMessageLength ) . '[TRUNCATED]' ; } $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s body: %s" , $ type , $ body ) ) ; if ( ! is_null ( $ message ) && $ message -> getBody ( ) -> isSeekable ( ) ) { $ message -> getBody ( ) -> rewind ( ) ; } return $ message ; } ; }
10216	public function addFromSource ( array $ pSource = null ) { if ( $ pSource == null ) { return ; } foreach ( $ pSource as $ item ) { $ this -> add ( $ item ) ; } }
9324	protected function registerMarkdownHtmlRenderer ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.htmlrenderer' , function ( $ app ) { $ environment = $ app [ 'commonmark.environment' ] ; return new HtmlRenderer ( $ environment ) ; } ) ; $ app -> alias ( 'commonmark.htmlrenderer' , HtmlRenderer :: class ) ; }
7084	public function delete_cookie ( $ name ) { unset ( $ _COOKIE [ $ name ] ) ; return setcookie ( $ name , null , - 86400 , $ this -> cookie_path , $ this -> cookie_domain , $ this -> cookie_secure , $ this -> cookie_httponly ) ; }
12364	public function updateSource ( ) { $ source = array ( "value" => $ this -> value , "tags" => $ this -> tags , "type" => $ this -> type , ) ; $ this -> source = Yaml :: dump ( $ source , 100 , 2 ) ; }
6693	public static function sort ( $ a , $ b ) { if ( ! isset ( $ a [ 'position' ] ) ) { return 0 ; } if ( ! isset ( $ b [ 'position' ] ) ) { return 0 ; } if ( $ a [ 'position' ] === $ b [ 'position' ] ) { return 0 ; } return ( $ a [ 'position' ] < $ b [ 'position' ] ) ? - 1 : 1 ; }
3948	private function buildMap ( ) { $ map = [ ] ; foreach ( $ this -> combination -> getParented ( ) as $ childName => $ child ) { $ map [ $ child [ 'meta' ] [ 'ptable' ] ] [ $ childName ] = $ child ; } return $ map ; }
11346	public function renderFields ( ) { $ html = '' ; foreach ( $ this -> fields as $ field ) { $ html .= $ this -> formatter -> renderField ( $ field ) ; } return $ html ; }
3639	public function check ( Output $ output ) : void { [ $ code , $ return , ] = Sys :: run ( 'php --ri swoole' ) ; $ asyncRdsEnabled = $ code === 0 ? \ strpos ( $ return , 'redis client => enabled' ) : false ; $ list = [ "<bold>Runtime environment check</bold>\n" , 'PHP version is greater than 7.1?' => self :: wrap ( \ PHP_VERSION_ID > 70100 , 'current is ' . \ PHP_VERSION ) , 'Swoole extension is installed?' => self :: wrap ( \ extension_loaded ( 'swoole' ) ) , 'Swoole version is greater than 4.3?' => self :: wrap ( \ version_compare ( \ SWOOLE_VERSION , '4.3.0' , '>=' ) , 'current is ' . \ SWOOLE_VERSION ) , 'Swoole async redis is enabled?' => self :: wrap ( $ asyncRdsEnabled ) , 'Swoole coroutine is enabled?' => self :: wrap ( \ class_exists ( 'Swoole\Coroutine' , false ) ) , "\n<bold>Extensions that conflict with 'swoole'</bold>\n" , ' - zend' => self :: wrap ( ! \ extension_loaded ( 'zend' ) , 'Please disabled it, otherwise swoole will be affected!' , true ) , ' - xdebug' => self :: wrap ( ! \ extension_loaded ( 'xdebug' ) , 'Please disabled it, otherwise swoole will be affected!' , true ) , ' - xhprof' => self :: wrap ( ! \ extension_loaded ( 'xhprof' ) , 'Please disabled it, otherwise swoole will be affected!' , true ) , ' - blackfire' => self :: wrap ( ! \ extension_loaded ( 'blackfire' ) , 'Please disabled it, otherwise swoole will be affected!' , true ) , ] ; $ buffer = [ ] ; $ pass = $ total = 0 ; foreach ( $ list as $ question => $ value ) { if ( \ is_int ( $ question ) ) { $ buffer [ ] = $ value ; continue ; } $ total ++ ; if ( $ value [ 0 ] ) { $ pass ++ ; } $ question = \ str_pad ( $ question , 45 ) ; $ buffer [ ] = \ sprintf ( ' <comment>%s</comment> %s' , $ question , $ value [ 1 ] ) ; } $ buffer [ ] = "\nCheck total: <bold>$total</bold>, Pass the check: <success>$pass</success>" ; $ output -> writeln ( $ buffer ) ; }
3270	public function appendToFile ( string $ line ) { $ file = $ this -> openFile ( static :: FILE_APPEND ) ; $ file -> fwrite ( $ line ) ; $ this -> closeFile ( $ file ) ; }
11827	public function getBom ( $ encoding = 'UTF-8' ) { $ boms = array ( 'UTF-8' => pack ( 'CCC' , 0xef , 0xbb , 0xbf ) , 'UTF-16 Big Endian' => pack ( 'CC' , 0xfe , 0xff ) , 'UTF-16 Little Endian' => pack ( 'CC' , 0xff , 0xfe ) , 'UTF-32 Big Endian' => pack ( 'CCCC' , 0x00 , 0x00 , 0xfe , 0xff ) , 'UTF-32 Little Endian' => pack ( 'CCCC' , 0xff , 0xfe , 0x00 , 0x00 ) , 'SCSU' => pack ( 'CCC' , 0x0e , 0xfe , 0xff ) , 'UTF-7 (1)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x38 ) , 'UTF-7 (2)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x39 ) , 'UTF-7 (3)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x2b ) , 'UTF-7 (4)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x2f ) , 'UTF-7 (5)' => pack ( 'CCCCC' , 0x2b , 0x2f , 0x76 , 0x38 , 0x2d ) , 'UTF-1' => pack ( 'CCC' , 0xF7 , 0x64 , 0x4c ) , 'UTF-EBCDIC' => pack ( 'CCCC' , 0xdd , 0x73 , 0x66 , 0x73 ) , 'BOCU-1' => pack ( 'CCC' , 0xfb , 0xee , 0x28 ) , 'GB-18030' => pack ( 'CCCC' , 0x84 , 0x31 , 0x95 , 0x33 ) , ) ; if ( 'all' == $ encoding ) { return $ boms ; } return $ boms [ $ encoding ] ; }
4645	public function setDimension ( $ name , array $ values ) { if ( empty ( $ values ) ) { $ values = array ( null ) ; } $ this -> dimensions [ $ name ] = $ values ; }
1456	protected function validateHasMany ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasManyExpected ( $ key ) ) ; return false ; } $ identifiers = $ relationship -> getIdentifiers ( ) ; if ( ! $ this -> validateIdentifiers ( $ identifiers , $ record , $ key , $ resource ) ) { return false ; } return true ; }
5601	public function paintPass ( $ message ) { if ( ! $ this -> pass ) { $ this -> message = self :: escapeVal ( $ message ) ; } $ this -> pass = true ; }
271	protected function renderSeparator ( $ spanLeft , $ spanMid , $ spanMidMid , $ spanRight ) { $ separator = $ spanLeft ; foreach ( $ this -> _columnWidths as $ index => $ rowSize ) { if ( $ index !== 0 ) { $ separator .= $ spanMid ; } $ separator .= str_repeat ( $ spanMidMid , $ rowSize ) ; } $ separator .= $ spanRight . "\n" ; return $ separator ; }
2220	public static function findPublishedDefaultByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.source='default'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
10474	public function lookupItem ( $ item_id ) { $ request = new ItemRequest ( $ item_id ) ; $ this -> emit ( 'request.item' , array ( $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new ItemResponse ( $ response ) ; }
2263	public function listTables ( $ strDatabase = null , $ blnNoCache = false ) { if ( $ blnNoCache || ! isset ( $ this -> arrCache [ $ strDatabase ] ) ) { $ strOldDatabase = $ this -> resConnection -> getDatabase ( ) ; if ( $ strDatabase !== null && $ strDatabase != $ strOldDatabase ) { $ this -> setDatabase ( $ strDatabase ) ; } $ this -> arrCache [ $ strDatabase ] = $ this -> resConnection -> getSchemaManager ( ) -> listTableNames ( ) ; if ( $ strDatabase !== null && $ strDatabase != $ strOldDatabase ) { $ this -> setDatabase ( $ strOldDatabase ) ; } } return $ this -> arrCache [ $ strDatabase ] ; }
9042	private function emptyEnvironment ( ) { foreach ( array_keys ( $ _ENV ) as $ key ) { putenv ( $ key ) ; unset ( $ _ENV [ $ key ] ) ; unset ( $ _SERVER [ $ key ] ) ; } }
10428	private function initSyncStorage ( ContainerBuilder $ container , array $ config ) { $ availableStorages = array_keys ( $ config [ 'sync' ] [ 'sync_storage' ] ) ; $ syncStorageStorage = current ( $ availableStorages ) ; if ( empty ( $ syncStorageStorage ) ) { throw new LogicException ( 'Data synchronization storage must be set.' ) ; } $ syncStorageStorageConfig = $ config [ 'sync' ] [ 'sync_storage' ] [ $ syncStorageStorage ] ; switch ( $ syncStorageStorage ) { case SyncStorage :: STORAGE_MYSQL : $ this -> initSyncStorageForMysql ( $ container , $ syncStorageStorageConfig ) ; break ; default : throw new LogicException ( "Unknown storage is set: {$syncStorageStorage}" ) ; } }
9788	public function setConditions ( $ pValue ) { if ( ! is_array ( $ pValue ) ) { $ pValue = [ $ pValue ] ; } $ this -> condition = $ pValue ; return $ this ; }
3821	private function getReferer ( Request $ request , $ table , $ encodeAmp = false ) { $ uri = $ this -> systemAdapter -> getReferer ( $ encodeAmp , $ table ) ; if ( ! preg_match ( '@^https?://@i' , $ uri ) ) { $ uri = $ request -> getBasePath ( ) . '/' . ltrim ( $ uri , '/' ) ; } return $ uri ; }
10754	public function getDateBorn ( UserEntity $ user , $ sm ) { $ dateFormatter = new \ IntlDateFormatter ( \ Locale :: getDefault ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , \ date_default_timezone_get ( ) , \ IntlDateFormatter :: GREGORIAN , "dd MMMM YYYY" ) ; $ date = $ user -> getDateBorn ( ) ; return $ dateFormatter -> format ( $ date ) ; }
6541	public function fetchOne ( $ tableName , array $ identifier , $ shardingKey = null , $ forceFromMaster = true ) { return $ this -> fetch ( $ tableName , $ identifier , $ shardingKey , array ( '*' ) , false , $ forceFromMaster ) ; }
12216	protected function yieldConfigurationFiles ( CompilerContext $ context ) : Generator { $ configDirs = [ ] ; foreach ( $ context -> getProjectSearchPaths ( SearchPathAttribute :: SEARCH_PATH_USER_CONFIG ) as $ configDir ) { $ configDirs [ ] = ( string ) $ configDir ; } $ pattern = $ this -> info [ static :: INFO_PATTERN_KEY ] ; $ defaultFile = $ this -> info [ static :: INFO_CUSTOM_FILENAME_KEY ] ?? NULL ; foreach ( $ context -> getSourceCodeManager ( ) -> yieldSourceFiles ( $ pattern , $ configDirs ) as $ fileName => $ file ) { if ( basename ( $ fileName ) == $ defaultFile ) continue ; yield $ fileName => $ file ; } }
8495	public function getFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7952	public function setReverseProperties ( $ ipblock , $ ip , $ reverse ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Parameter $ip is missing.' ) ; $ payload = array ( 'ipReverse' => $ ip , 'reverse' => $ reverse ) ; try { $ r = $ this -> post ( 'ip/' . urlencode ( $ ipblock ) . '/reverse' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
9677	public function allBorders ( Spreadsheet $ spreadsheet ) { $ aBorders = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aBorders [ $ style -> getBorders ( ) -> getHashCode ( ) ] ) ) { $ aBorders [ $ style -> getBorders ( ) -> getHashCode ( ) ] = $ style -> getBorders ( ) ; } } return $ aBorders ; }
2025	public static function findPublishedByIdOrAlias ( $ varId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , $ varId , $ arrOptions ) ; }
8736	public function insert ( array $ values ) { list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; if ( $ this -> query -> insert ( $ values ) ) { return $ this -> insertI18n ( $ i18nValues , $ values [ $ this -> model -> getKeyName ( ) ] ) ; } }
11877	public static function getDumpQueryResult ( $ var ) { $ header = true ; $ dump = '<table cellpadding=5 cellspacing=0>' ; $ i = 1 ; foreach ( $ var as $ ligne ) { if ( $ header ) { $ dump .= '<tr>' ; foreach ( $ ligne as $ key => $ value ) { if ( ! is_numeric ( $ key ) ) { $ dump .= '<th>' . $ key . '</th>' ; } } $ dump .= '</tr>' ; $ header = false ; } $ class = '' ; if ( ! ( $ i % 2 ) ) { $ class = 'highlight' ; } $ dump .= '<tr class="' . $ class . '">' ; foreach ( $ ligne as $ key => $ value ) { if ( ! is_numeric ( $ key ) ) { if ( $ value != '' ) { $ dump .= '<td>' . $ value . '</td>' ; } else { $ dump .= '<td>&nbsp;</td>' ; } } } $ dump .= '</tr>' ; $ i ++ ; } $ dump .= '</table>' ; return $ dump ; }
235	protected function getColumnPhpType ( $ column ) { static $ typeMap = [ self :: TYPE_TINYINT => 'integer' , self :: TYPE_SMALLINT => 'integer' , self :: TYPE_INTEGER => 'integer' , self :: TYPE_BIGINT => 'integer' , self :: TYPE_BOOLEAN => 'boolean' , self :: TYPE_FLOAT => 'double' , self :: TYPE_DOUBLE => 'double' , self :: TYPE_BINARY => 'resource' , self :: TYPE_JSON => 'array' , ] ; if ( isset ( $ typeMap [ $ column -> type ] ) ) { if ( $ column -> type === 'bigint' ) { return PHP_INT_SIZE === 8 && ! $ column -> unsigned ? 'integer' : 'string' ; } elseif ( $ column -> type === 'integer' ) { return PHP_INT_SIZE === 4 && $ column -> unsigned ? 'string' : 'integer' ; } return $ typeMap [ $ column -> type ] ; } return 'string' ; }
5063	public function outputJson ( int $ depth = 512 , int $ options = 0 ) { $ json = json_decode ( $ this -> output ( ) , false , $ depth , $ options ) ; if ( is_null ( $ json ) ) { $ errorMessage = json_last_error_msg ( ) ; throw new JsonDecodeException ( $ errorMessage ) ; } return $ json ; }
9812	protected function putRaw ( string $ path , $ body = null , array $ headers = [ ] ) { $ response = $ this -> client -> put ( $ path , $ headers , $ body ) ; return ResponseMediator :: getContent ( $ response ) ; }
12334	private function _checkPasswordIsGood ( ) : bool { $ sLogin = self :: $ _sLogin ; $ sPassword = Config :: get ( 'security' ) -> users -> $ sLogin -> password ; if ( $ sPassword == self :: $ _sPassword ) { return true ; } else if ( $ sPassword == md5 ( self :: $ _sPassword ) ) { return true ; } else { return false ; } }
1075	public static function fromArray ( array $ node ) : Node { if ( ! isset ( $ node [ 'kind' ] ) || ! isset ( NodeKind :: $ classMap [ $ node [ 'kind' ] ] ) ) { throw new InvariantViolation ( 'Unexpected node structure: ' . Utils :: printSafeJson ( $ node ) ) ; } $ kind = $ node [ 'kind' ] ?? null ; $ class = NodeKind :: $ classMap [ $ kind ] ; $ instance = new $ class ( [ ] ) ; if ( isset ( $ node [ 'loc' ] , $ node [ 'loc' ] [ 'start' ] , $ node [ 'loc' ] [ 'end' ] ) ) { $ instance -> loc = Location :: create ( $ node [ 'loc' ] [ 'start' ] , $ node [ 'loc' ] [ 'end' ] ) ; } foreach ( $ node as $ key => $ value ) { if ( $ key === 'loc' || $ key === 'kind' ) { continue ; } if ( is_array ( $ value ) ) { if ( isset ( $ value [ 0 ] ) || empty ( $ value ) ) { $ value = new NodeList ( $ value ) ; } else { $ value = self :: fromArray ( $ value ) ; } } $ instance -> { $ key } = $ value ; } return $ instance ; }
610	public function get ( $ class , $ params = [ ] , $ config = [ ] ) { if ( isset ( $ this -> _singletons [ $ class ] ) ) { return $ this -> _singletons [ $ class ] ; } elseif ( ! isset ( $ this -> _definitions [ $ class ] ) ) { return $ this -> build ( $ class , $ params , $ config ) ; } $ definition = $ this -> _definitions [ $ class ] ; if ( is_callable ( $ definition , true ) ) { $ params = $ this -> resolveDependencies ( $ this -> mergeParams ( $ class , $ params ) ) ; $ object = call_user_func ( $ definition , $ this , $ params , $ config ) ; } elseif ( is_array ( $ definition ) ) { $ concrete = $ definition [ 'class' ] ; unset ( $ definition [ 'class' ] ) ; $ config = array_merge ( $ definition , $ config ) ; $ params = $ this -> mergeParams ( $ class , $ params ) ; if ( $ concrete === $ class ) { $ object = $ this -> build ( $ class , $ params , $ config ) ; } else { $ object = $ this -> get ( $ concrete , $ params , $ config ) ; } } elseif ( is_object ( $ definition ) ) { return $ this -> _singletons [ $ class ] = $ definition ; } else { throw new InvalidConfigException ( 'Unexpected object definition type: ' . gettype ( $ definition ) ) ; } if ( array_key_exists ( $ class , $ this -> _singletons ) ) { $ this -> _singletons [ $ class ] = $ object ; } return $ object ; }
1825	public function setRow ( array $ arrData ) { foreach ( $ arrData as $ k => $ v ) { if ( strpos ( $ k , '__' ) !== false ) { unset ( $ arrData [ $ k ] ) ; } } $ this -> arrData = $ arrData ; return $ this ; }
3598	public function parserHttpRequest ( HttpRequest $ httpRequest ) { $ json = \ json_decode ( $ httpRequest -> getContent ( ) , true ) ; if ( JSON_ERROR_NONE !== \ json_last_error ( ) ) { throw new Exceptions \ ParseException ( ) ; } $ createJsonRequest = function ( $ json ) use ( $ httpRequest ) { $ id = null ; $ method = null ; $ params = [ ] ; if ( \ is_array ( $ json ) ) { $ id = \ array_key_exists ( 'id' , $ json ) ? $ json [ 'id' ] : null ; $ method = \ array_key_exists ( 'method' , $ json ) ? $ json [ 'method' ] : null ; $ params = \ array_key_exists ( 'params' , $ json ) ? $ json [ 'params' ] : [ ] ; } $ request = new JsonRequest ( $ method , $ params , $ id ) ; $ request -> headers ( ) -> add ( $ httpRequest -> headers -> all ( ) ) ; return $ request ; } ; if ( \ array_keys ( $ json ) === \ range ( 0 , \ count ( $ json ) - 1 ) ) { $ requests = [ ] ; foreach ( $ json as $ part ) { $ requests [ ] = $ createJsonRequest ( $ part ) ; } } else { $ requests = $ createJsonRequest ( $ json ) ; } return $ requests ; }
8799	public function make ( $ value , array $ options = [ ] ) { $ hash = password_hash ( $ value , PASSWORD_ARGON2I , [ 'memory_cost' => $ this -> memory ( $ options ) , 'time_cost' => $ this -> time ( $ options ) , 'threads' => $ this -> threads ( $ options ) , ] ) ; if ( $ hash === false ) { throw new RuntimeException ( 'Argon2 hashing not supported.' ) ; } return $ hash ; }
6892	protected function resolveSoldDeltaQuantity ( SaleItemInterface $ item ) { $ old = $ new = $ item -> getQuantity ( ) ; if ( $ this -> persistenceHelper -> isChanged ( $ item , 'quantity' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ item , 'quantity' ) ; } $ parent = $ item ; while ( null !== $ parent = $ parent -> getParent ( ) ) { if ( $ this -> persistenceHelper -> isChanged ( $ parent , 'quantity' ) ) { list ( $ parentOld , $ parentNew ) = $ this -> persistenceHelper -> getChangeSet ( $ parent , 'quantity' ) ; } else { $ parentOld = $ parentNew = $ parent -> getQuantity ( ) ; } $ old *= $ parentOld ; $ new *= $ parentNew ; } $ sale = $ item -> getSale ( ) ; $ shippedOld = $ shippedNew = 0 ; $ f = $ t = false ; if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'released' ) ) { list ( $ f , $ t ) = $ this -> persistenceHelper -> getChangeSet ( $ sale , 'released' ) ; } elseif ( $ item -> getSale ( ) -> isReleased ( ) ) { $ f = $ t = true ; } if ( $ f || $ t ) { foreach ( $ item -> getStockAssignments ( ) as $ assignment ) { if ( $ this -> persistenceHelper -> isChanged ( $ assignment , 'shippedQuantity' ) ) { list ( $ o , $ n ) = $ this -> persistenceHelper -> getChangeSet ( $ assignment , 'shippedQuantity' ) ; } else { $ o = $ n = $ assignment -> getShippedQuantity ( ) ; } if ( $ f ) { $ shippedOld += $ o ; } if ( $ t ) { $ shippedNew += $ n ; } } if ( $ f ) { $ old = min ( $ old , $ shippedOld ) ; } if ( $ t ) { $ new = min ( $ new , $ shippedNew ) ; } } return $ new - $ old ; }
8583	public function getLowestOfferListingsForSKU ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceProducts_Model_GetLowestOfferListingsForSKURequest ) ) { $ request = new MarketplaceWebServiceProducts_Model_GetLowestOfferListingsForSKURequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetLowestOfferListingsForSKU' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceProducts_Model_GetLowestOfferListingsForSKUResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
139	public function uninstall ( RepositoryInterface $ repo , UninstallOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; $ installer -> uninstall ( $ repo , $ package ) ; }
4141	protected function getSignatureBaseString ( ) { $ method = strtoupper ( $ this -> method ) ; $ url = rawurlencode ( $ this -> getUrl ( ) ) ; return $ method . '&' . $ url . '&' . $ this -> getRequestString ( ) ; }
4861	public function pushLazy ( $ service , $ payload = null , array $ options = [ ] ) { $ manager = $ this -> getJobPluginManager ( ) ; $ serviceOptions = [ ] ; if ( is_array ( $ service ) ) { $ serviceOptions = $ service [ 'options' ] ?? $ service [ 1 ] ?? [ ] ; $ service = $ service [ 'name' ] ?? $ service [ 0 ] ?? null ; } if ( ! $ manager -> has ( $ service ) && ! class_exists ( $ service ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Service name "%s" is not a known job service or existent class' , $ service ) ) ; } $ lazyOptions = [ 'name' => $ service , 'options' => $ serviceOptions , 'content' => $ payload , ] ; $ job = $ this -> getJobPluginManager ( ) -> build ( 'lazy' , $ lazyOptions ) ; $ this -> push ( $ job , $ options ) ; }
7012	private function formatF ( & $ str ) { if ( strstr ( $ str , '%F' ) ) $ str = str_replace ( '%F' , $ this -> monthName ( true ) , $ str ) ; }
3737	protected function createNewItem ( $ item ) { $ data = [ 'tstamp' => $ item -> get ( 'tstamp' ) ] ; $ isNewItem = false ; if ( $ this -> hasVariants ( ) ) { if ( $ item -> get ( 'vargroup' ) === null ) { $ item -> set ( 'varbase' , '1' ) ; $ item -> set ( 'vargroup' , '0' ) ; $ isNewItem = true ; } $ data [ 'varbase' ] = $ item -> get ( 'varbase' ) ; $ data [ 'vargroup' ] = $ item -> get ( 'vargroup' ) ; } $ connection = $ this -> getConnection ( ) ; $ builder = $ connection -> createQueryBuilder ( ) ; $ parameters = [ ] ; foreach ( array_keys ( $ data ) as $ key ) { $ parameters [ $ key ] = ':' . $ key ; } $ builder -> insert ( $ this -> getTableName ( ) ) -> values ( $ parameters ) -> setParameters ( $ data ) -> execute ( ) ; $ item -> set ( 'id' , $ connection -> lastInsertId ( ) ) ; if ( $ isNewItem ) { $ this -> saveSimpleColumn ( 'vargroup' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'id' ) ) ; } }
2477	public function request ( $ method , Endpoint $ endpoint , $ path , Message $ message = null ) { $ message = $ message ? : new Message ( ) ; $ i = 0 ; do { ++ $ i ; if ( $ responseMessage = $ this -> requestStream ( $ method , $ endpoint , $ path , $ message ) ) { return $ responseMessage ; } usleep ( $ this -> retryWaitMs * 1000 ) ; } while ( $ i < $ this -> connectionRetry ) ; if ( $ this -> logger instanceof LoggerInterface ) { $ this -> logger -> error ( sprintf ( 'Connection to %s failed, attempted %d times' , $ endpoint -> getURL ( ) , $ this -> connectionRetry ) ) ; } throw new ConnectionException ( $ endpoint -> getURL ( ) , $ path , $ method ) ; }
12538	public function setRelations ( $ value ) { if ( $ this -> companionObject ) { $ baseObject = $ this -> companionObject ; } else { $ baseObject = $ this -> owner ; } $ fields = $ baseObject -> getFields ( ) ; foreach ( $ value as $ tabId => $ relation ) { if ( ! isset ( $ relation [ '_moduleHandler' ] ) ) { \ d ( "boom" ) ; exit ; continue ; } if ( ! isset ( $ fields [ $ relation [ '_moduleHandler' ] ] ) ) { \ d ( $ relation [ '_moduleHandler' ] ) ; \ d ( array_keys ( $ fields ) ) ; exit ; continue ; } $ baseAttributes = [ ] ; $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> model ; if ( empty ( $ model ) ) { $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> resetModel ( ) ; } $ model -> attributes = $ relation ; $ model -> _moduleHandler = $ relation [ '_moduleHandler' ] ; $ model -> tabularId = $ relation [ '_moduleHandler' ] ; list ( $ relationship , $ role ) = $ baseObject -> objectType -> getRelationship ( $ model -> _moduleHandler ) ; $ relatedHandler = $ baseObject -> objectType -> getRelatedType ( $ model -> _moduleHandler ) ; if ( ! $ relatedHandler ) { continue ; } if ( ! $ this -> owner -> tabularId && ! $ this -> owner -> isNewRecord && empty ( $ model -> parent_object_id ) && empty ( $ model -> child_object_id ) ) { continue ; } $ this -> _relations [ $ tabId ] = $ model ; } }
5718	public function doPublishAndClose ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return $ this -> publish ( $ data , $ form , $ this -> owner , $ this -> getBackLink ( ) ) ; }
10903	public function delete ( ) : bool { return ( bool ) $ this -> medoo -> delete ( $ this -> getTable ( ) , [ 'id' => $ this -> getId ( ) ] ) ; }
6787	protected function fixDefault ( CustomerGroupInterface $ customerGroup ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ customerGroup , [ 'default' ] ) ) { return ; } if ( $ customerGroup -> isDefault ( ) ) { try { $ previousGroup = $ this -> customerGroupRepository -> findDefault ( ) ; } catch ( RuntimeException $ e ) { return ; } if ( $ previousGroup === $ customerGroup ) { return ; } $ previousGroup -> setDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ previousGroup , false ) ; } }
5489	public static function parseArguments ( $ argv , $ mutliValueMode = false ) { $ args = array ( ) ; $ args [ 'extraArguments' ] = array ( ) ; array_shift ( $ argv ) ; foreach ( $ argv as $ arg ) { if ( preg_match ( '#^--([^=]+)=(.*)#' , $ arg , $ reg ) ) { $ args [ $ reg [ 1 ] ] = $ reg [ 2 ] ; if ( $ mutliValueMode ) { self :: addItemAsArray ( $ args , $ reg [ 1 ] , $ reg [ 2 ] ) ; } } elseif ( preg_match ( '#^[-]{1,2}([^[:blank:]]+)#' , $ arg , $ reg ) ) { $ nonnull = '' ; $ args [ $ reg [ 1 ] ] = $ nonnull ; if ( $ mutliValueMode ) { self :: addItemAsArray ( $ args , $ reg [ 1 ] , $ nonnull ) ; } } else { $ args [ 'extraArguments' ] [ ] = $ arg ; } } return $ args ; }
6614	protected function validateSettings ( $ settings ) { if ( ! is_array ( $ settings ) ) { throw new InvalidProviderSettingsException ( ) ; } $ intersection = array_intersect ( array_keys ( $ settings ) , $ this -> mandatory ) ; return count ( $ intersection ) === count ( $ this -> mandatory ) ; }
8595	public function getServiceStatus ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_GetServiceStatusRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_GetServiceStatusRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetServiceStatus' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_GetServiceStatusResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4341	public function end ( ) { \ unregister_tick_function ( array ( $ this , 'tickFunction' ) ) ; while ( $ this -> funcStack ) { $ this -> popStack ( ) ; } \ uasort ( $ this -> data , function ( $ valA , $ valB ) { return ( $ valA [ 'totalTime' ] < $ valB [ 'totalTime' ] ) ? 1 : - 1 ; } ) ; $ data = \ array_map ( function ( $ row ) { $ row [ 'totalTime' ] = \ round ( $ row [ 'totalTime' ] , 6 ) ; $ row [ 'ownTime' ] = \ round ( $ row [ 'ownTime' ] , 6 ) ; return $ row ; } , $ this -> data ) ; $ this -> data = array ( ) ; $ this -> funcStack = array ( ) ; $ this -> isProfiling = false ; $ this -> rootStack = array ( ) ; return $ data ; }
2262	public function query ( $ strQuery ) { $ objStatement = new Statement ( $ this -> resConnection , $ this -> blnDisableAutocommit ) ; return $ objStatement -> query ( $ strQuery ) ; }
741	public function beforeRun ( $ event ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ fragmentCacheConfiguration = $ this -> getFragmentCacheConfiguration ( ) ; if ( ! $ this -> owner -> view -> beginCache ( $ cacheKey , $ fragmentCacheConfiguration ) ) { $ event -> isValid = false ; } }
9535	private function parseVariadicParameter ( & $ i , & $ results , $ closure , & $ closure_arguments , $ prefix , $ parameter ) { $ i ++ ; while ( isset ( $ this -> argv [ $ i ] ) && ( $ argument = $ this -> argv [ $ i ] ) != null && ! $ this -> prefixExists ( $ argument ) ) { $ closure_arguments [ ] = $ argument ; $ i ++ ; } $ parameterClosure = $ this -> getParameterClosure ( $ parameter ) ; if ( $ parameterClosure -> parent != null ) { if ( count ( $ closure_arguments ) > 0 ) { $ results [ $ parameterClosure -> parent -> parameterName ] = $ closure ( ... $ closure_arguments ) ; } else { $ this -> valid = false ; if ( $ this -> errorHandler != null ) { $ this -> errorHandler -> call ( $ this , $ parameterClosure , 'Missing argument for parameter closure.' ) ; } } } else { if ( count ( $ closure_arguments ) > 0 ) { $ results [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] = $ closure ( ... $ closure_arguments ) ; } else { $ this -> valid = false ; if ( $ this -> errorHandler != null ) { $ this -> errorHandler -> call ( $ this , $ parameterClosure , 'Missing argument for parameter closure.' ) ; } } } }
7553	protected function match_tags ( $ tags ) { $ res = false ; foreach ( $ tags as $ tag => $ match ) { if ( ! is_array ( $ match ) ) { $ match = array ( 'match' => $ match , 'operator' => 'or' , 'compare' => 'total' , 'case_sensitive' => false ) ; } else { if ( is_int ( $ tag ) ) { $ tag = $ match [ 'tag' ] ; } if ( ! isset ( $ match [ 'match' ] ) ) { $ match [ 'match' ] = true ; } if ( ! isset ( $ match [ 'operator' ] ) ) { $ match [ 'operator' ] = 'or' ; } if ( ! isset ( $ match [ 'compare' ] ) ) { $ match [ 'compare' ] = 'total' ; } if ( ! isset ( $ match [ 'case_sensitive' ] ) ) { $ match [ 'case_sensitive' ] = false ; } } if ( ( $ match [ 'operator' ] === 'and' ) && ( ! $ res ) ) { return false ; } elseif ( ! ( $ res && ( $ match [ 'operator' ] === 'or' ) ) ) { if ( $ match [ 'compare' ] === 'total' ) { $ a = $ this -> tag ; } elseif ( $ match [ 'compare' ] === 'namespace' ) { $ a = $ this -> getNamespace ( ) ; } elseif ( $ match [ 'compare' ] === 'name' ) { $ a = $ this -> getTag ( ) ; } if ( $ match [ 'case_sensitive' ] ) { $ res = ( ( $ a === $ tag ) === $ match [ 'match' ] ) ; } else { $ res = ( ( strcasecmp ( $ a , $ tag ) === 0 ) === $ match [ 'match' ] ) ; } } } return $ res ; }
12373	private function applyRuleToField ( string $ fieldName , string $ ruleName , array $ options = [ ] ) : void { if ( ! isset ( $ this -> rules [ $ ruleName ] ) ) { throw new Exception ( 'Undefined rule name.' ) ; } $ func = $ this -> rules [ $ ruleName ] [ 0 ] ; if ( ! $ func ( $ fieldName , $ options ) ) { if ( isset ( $ this -> rules [ $ ruleName ] [ 1 ] ) ) { if ( is_callable ( $ this -> rules [ $ ruleName ] [ 1 ] ) ) { $ funcMsg = $ this -> rules [ $ ruleName ] [ 1 ] ; $ this -> addError ( $ funcMsg ( $ fieldName , $ options ) ) ; } else { $ this -> addError ( ( string ) $ this -> rules [ $ ruleName ] [ 1 ] ) ; } } else { $ this -> addDefaultError ( $ fieldName ) ; } } }
10348	public function rewind ( ) { if ( $ this -> yearOffset !== 0 ) { $ this -> generateTimetable ( 0 ) ; } else { reset ( $ this -> minutes ) ; reset ( $ this -> hours ) ; reset ( $ this -> monthAndDays ) ; } }
10397	protected function processDiscriminatorMap ( ClassMetadataInfo $ metadata ) { $ newMap = [ ] ; foreach ( $ metadata -> discriminatorMap as $ mapId => $ mappedEntityName ) { $ newKey = $ this -> doReplacement ( $ mapId ) ; $ newMap [ $ newKey ] = $ mappedEntityName ; } $ metadata -> discriminatorMap = $ newMap ; }
6697	public function isMethodHidden ( $ methodName ) { if ( ! method_exists ( $ this , $ methodName ) ) { throw new Exception ( 500 , "The method '$methodName' does not exist in " . get_called_class ( ) ) ; } return isset ( $ this -> hiddenMethods [ $ methodName ] ) ; }
6914	public function removeShipment ( ShipmentInterface $ shipment ) { if ( $ this -> shipments -> contains ( $ shipment ) ) { $ this -> shipments -> removeElement ( $ shipment ) ; } return $ this ; }
4319	protected function interpolate ( $ message , array & $ context = array ( ) ) { \ preg_match_all ( '/\{([a-z0-9_.]+)\}/' , $ message , $ matches ) ; $ placeholders = \ array_unique ( $ matches [ 1 ] ) ; $ replace = array ( ) ; foreach ( $ placeholders as $ key ) { if ( ! isset ( $ context [ $ key ] ) ) { continue ; } $ val = $ context [ $ key ] ; if ( ! \ is_array ( $ val ) && ( ! \ is_object ( $ val ) || \ method_exists ( $ val , '__toString' ) ) ) { $ replace [ '{' . $ key . '}' ] = $ val ; } } $ context = \ array_diff_key ( $ context , \ array_flip ( $ placeholders ) ) ; if ( ! $ context ) { $ context = $ this -> debug -> meta ( ) ; } return \ strtr ( $ message , $ replace ) ; }
405	public function addCorsHeaders ( $ response , $ headers ) { if ( empty ( $ headers ) === false ) { $ responseHeaders = $ response -> getHeaders ( ) ; foreach ( $ headers as $ field => $ value ) { $ responseHeaders -> set ( $ field , $ value ) ; } } }
1137	public function setDepthWithSubtree ( ) { $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ self -> descendantsAndSelf ( ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ oldDepth = ! is_null ( $ self -> getDepth ( ) ) ? $ self -> getDepth ( ) : 0 ; $ newDepth = $ self -> getLevel ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ self -> getKeyName ( ) , '=' , $ self -> getKey ( ) ) -> update ( array ( $ self -> getDepthColumnName ( ) => $ newDepth ) ) ; $ self -> setAttribute ( $ self -> getDepthColumnName ( ) , $ newDepth ) ; $ diff = $ newDepth - $ oldDepth ; if ( ! $ self -> isLeaf ( ) && $ diff != 0 ) $ self -> descendants ( ) -> increment ( $ self -> getDepthColumnName ( ) , $ diff ) ; } ) ; return $ this ; }
7970	public function deleteBlacklist ( $ domain , $ number ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ number ) throw new BadMethodCallException ( 'Parameter $number is missing.' ) ; try { $ r = $ this -> delete ( 'sms/' . $ domain . '/blacklists/' . $ number ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
5937	public function setFunctionalities ( array $ functionalities ) { $ this -> functionalities = [ ] ; foreach ( $ functionalities as $ item ) { $ this -> addFunctionality ( $ item ) ; } return $ this ; }
12880	public function register ( ) { if ( ! $ this -> validate ( ) ) { return false ; } $ this -> user -> setAttributes ( [ 'email' => $ this -> email , 'username' => $ this -> username , 'password' => $ this -> password ] ) ; return $ this -> user -> register ( ) ; }
11156	public function getArrayValue ( array $ values ) { if ( empty ( $ values ) ) { throw new InvalidArgumentException ( 'Empty parameter' ) ; } $ values = \ array_values ( $ values ) ; return $ values [ $ this -> generator -> getInt ( 0 , count ( $ values ) - 1 ) ] ; }
360	function normalizeRequirement ( $ requirement , $ requirementKey = 0 ) { if ( ! is_array ( $ requirement ) ) { $ this -> usageError ( 'Requirement must be an array!' ) ; } if ( ! array_key_exists ( 'condition' , $ requirement ) ) { $ this -> usageError ( "Requirement '{$requirementKey}' has no condition!" ) ; } else { $ evalPrefix = 'eval:' ; if ( is_string ( $ requirement [ 'condition' ] ) && strpos ( $ requirement [ 'condition' ] , $ evalPrefix ) === 0 ) { $ expression = substr ( $ requirement [ 'condition' ] , strlen ( $ evalPrefix ) ) ; $ requirement [ 'condition' ] = $ this -> evaluateExpression ( $ expression ) ; } } if ( ! array_key_exists ( 'name' , $ requirement ) ) { $ requirement [ 'name' ] = is_numeric ( $ requirementKey ) ? 'Requirement #' . $ requirementKey : $ requirementKey ; } if ( ! array_key_exists ( 'mandatory' , $ requirement ) ) { if ( array_key_exists ( 'required' , $ requirement ) ) { $ requirement [ 'mandatory' ] = $ requirement [ 'required' ] ; } else { $ requirement [ 'mandatory' ] = false ; } } if ( ! array_key_exists ( 'by' , $ requirement ) ) { $ requirement [ 'by' ] = 'Unknown' ; } if ( ! array_key_exists ( 'memo' , $ requirement ) ) { $ requirement [ 'memo' ] = '' ; } return $ requirement ; }
12279	public function moveUsers ( array $ openIds , $ groupId ) { $ params = [ 'openid_list' => $ openIds , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_UPDATE , $ params ] ) ; }
757	protected function renderImageByGD ( $ code ) { $ image = imagecreatetruecolor ( $ this -> width , $ this -> height ) ; $ backColor = imagecolorallocate ( $ image , ( int ) ( $ this -> backColor % 0x1000000 / 0x10000 ) , ( int ) ( $ this -> backColor % 0x10000 / 0x100 ) , $ this -> backColor % 0x100 ) ; imagefilledrectangle ( $ image , 0 , 0 , $ this -> width - 1 , $ this -> height - 1 , $ backColor ) ; imagecolordeallocate ( $ image , $ backColor ) ; if ( $ this -> transparent ) { imagecolortransparent ( $ image , $ backColor ) ; } $ foreColor = imagecolorallocate ( $ image , ( int ) ( $ this -> foreColor % 0x1000000 / 0x10000 ) , ( int ) ( $ this -> foreColor % 0x10000 / 0x100 ) , $ this -> foreColor % 0x100 ) ; $ length = strlen ( $ code ) ; $ box = imagettfbbox ( 30 , 0 , $ this -> fontFile , $ code ) ; $ w = $ box [ 4 ] - $ box [ 0 ] + $ this -> offset * ( $ length - 1 ) ; $ h = $ box [ 1 ] - $ box [ 5 ] ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ fontSize = ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ; $ angle = mt_rand ( - 10 , 10 ) ; $ letter = $ code [ $ i ] ; $ box = imagettftext ( $ image , $ fontSize , $ angle , $ x , $ y , $ foreColor , $ this -> fontFile , $ letter ) ; $ x = $ box [ 2 ] + $ this -> offset ; } imagecolordeallocate ( $ image , $ foreColor ) ; ob_start ( ) ; imagepng ( $ image ) ; imagedestroy ( $ image ) ; return ob_get_clean ( ) ; }
5121	private function sendRequest ( RequestInterface $ request , int $ attempt = 0 ) : \ Psr \ Http \ Message \ StreamInterface { if ( $ attempt >= $ this -> options -> get ( 'max_attempt' ) ) { throw new \ Exception ( 'MAX attempt reached for ' . $ request -> getUri ( ) . ' with payload ' . ( string ) $ request ) ; } try { $ response = $ this -> httpClient -> send ( $ request , [ 'allow_redirects' => false , 'synchronous' => true , 'curl' => [ CURLOPT_FORBID_REUSE => true , CURLOPT_MAXCONNECTS => 30 , CURLOPT_SSL_VERIFYPEER => false , CURLOPT_SSL_VERIFYSTATUS => false , ] , ] ) ; if ( $ response -> getStatusCode ( ) === 200 ) { return $ response -> getBody ( ) ; } return $ this -> sendRequest ( $ request , $ attempt ++ ) ; } catch ( ClientException $ err ) { if ( $ err -> getResponse ( ) -> getStatusCode ( ) === 401 && $ request -> getRequestTarget ( ) !== self :: AUTHENTICATION ) { $ this -> renewAuthToken ( ) ; return $ this -> sendRequest ( $ request , $ attempt ++ ) ; } throw $ err ; } catch ( \ Throwable $ err ) { throw $ err ; } }
1350	public function none ( string ... $ resourceTypes ) : self { foreach ( $ resourceTypes as $ resourceType ) { $ this -> allow ( $ resourceType , [ ] ) ; } return $ this ; }
12621	public function set ( $ key , $ value ) { ArrayDot :: set ( $ _SESSION [ $ this -> root ] , $ key , $ value ) ; }
10979	public function postPersist ( LifecycleEventArgs $ args ) : void { if ( ! $ this -> enableIndexing ) { return ; } $ this -> updateEntity ( $ args -> getObject ( ) , $ args -> getObjectManager ( ) ) ; }
11012	protected function importSchemaFile ( string $ schemaFile , string $ controlTableName = null ) : void { if ( $ controlTableName !== null ) { if ( $ this -> db -> getSchemaManager ( ) -> tablesExist ( [ $ controlTableName ] ) ) { $ this -> output -> writeln ( '<comment>Schema already exists in the database, skipping schema import for file <info>' . $ schemaFile . '</info></comment>' ) ; return ; } } $ this -> runQueriesFromFile ( $ schemaFile ) ; }
10346	protected function getNextFutureTimestamp ( ) { if ( $ this -> yearOffset === 0 ) { $ currentHour = ( int ) date ( 'H' , $ this -> getCurrentTime ( ) ) ; $ currentMinute = ( int ) date ( 'i' , $ this -> getCurrentTime ( ) ) ; $ currentDay = ( int ) date ( 'd' , $ this -> getCurrentTime ( ) ) ; $ currentMonth = ( int ) date ( 'm' , $ this -> getCurrentTime ( ) ) ; } do { $ minute = current ( $ this -> minutes ) ; $ hour = current ( $ this -> hours ) ; $ monthAndDay = current ( $ this -> monthAndDays ) ; $ minute = next ( $ this -> minutes ) ; if ( $ minute === false ) { $ minute = reset ( $ this -> minutes ) ; $ hour = next ( $ this -> hours ) ; if ( $ hour === false ) { $ hour = reset ( $ this -> hours ) ; $ monthAndDay = next ( $ this -> monthAndDays ) ; if ( $ monthAndDay === false ) { $ this -> generateTimetable ( $ this -> yearOffset + 1 ) ; $ minute = reset ( $ this -> minutes ) ; $ hour = reset ( $ this -> hours ) ; $ monthAndDay = reset ( $ this -> monthAndDays ) ; } } } if ( $ this -> yearOffset === 0 ) { if ( ( $ month = ( int ) substr ( $ monthAndDay , 0 , 2 ) ) === $ currentMonth ) { if ( ( $ day = ( int ) substr ( $ monthAndDay , 3 , 2 ) ) < $ currentDay ) { continue ; } if ( $ day === $ currentDay ) { if ( $ hour < $ currentHour ) { continue ; } if ( $ hour === $ currentHour ) { if ( $ minute < $ currentMinute ) { continue ; } } } } } $ nextElement = strtotime ( sprintf ( '%d-%s %02d:%02d:00' , $ this -> year + $ this -> yearOffset , $ monthAndDay , $ hour , $ minute ) ) ; break ; } while ( true ) ; return $ nextElement ; }
7927	public function registerNamespace ( $ ns , $ def ) { list ( $ ns , $ def ) = $ this -> fireEvent ( 'namespace.register' , [ $ ns , $ def ] ) ; $ this -> namespaces [ $ ns ] = $ def ; return $ this ; }
3537	public function getGroupsAssignedInLdap ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } $ ldapUser = $ this -> queryLdapUserObject ( ) ; $ ldapGroupsConverted = [ ] ; if ( $ ldapUser != null ) { if ( static :: getGroupAssigmentOptions ( 'SEARCH_NESTED_GROUPS' , $ this -> individualGroupAssignmentOptions ) == true ) { $ ldapGroups = static :: getAdldapProvider ( ) -> search ( ) -> rawFilter ( '(member:1.2.840.113556.1.4.1941:=' . $ ldapUser -> getDn ( ) . ')' ) -> select ( 'cn' ) -> raw ( ) -> get ( ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } foreach ( $ ldapGroups as $ groupDn ) { if ( is_array ( $ groupDn ) && array_key_exists ( 'cn' , $ groupDn ) ) { array_push ( $ ldapGroupsConverted , $ groupDn [ 'cn' ] [ 0 ] ) ; } } } else { $ ldapGroups = $ ldapUser -> getAttribute ( 'memberof' ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } foreach ( $ ldapGroups as $ groupDn ) { $ n = Utilities :: explodeDn ( $ groupDn ) [ 0 ] ; array_push ( $ ldapGroupsConverted , $ n ) ; } } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } return $ ldapGroupsConverted ; }
10185	static function json_decode ( $ jsonString , $ deserializationType = null ) { if ( is_array ( $ deserializationType ) && count ( $ deserializationType ) > 1 ) { $ type = $ deserializationType [ 0 ] ; $ innerType = $ deserializationType [ 1 ] ; } else { $ type = $ deserializationType ; $ innerType = null ; } return self :: fromArray ( json_decode ( $ jsonString ) , $ type , $ innerType ) ; }
4988	public function setForms ( array $ forms , $ enabled = true ) { foreach ( $ forms as $ key => $ spec ) { if ( is_array ( $ spec ) && isset ( $ spec [ 'enabled' ] ) ) { $ currentEnabled = $ spec [ 'enabled' ] ; unset ( $ spec [ 'enabled' ] ) ; } else { $ currentEnabled = $ enabled ; } $ this -> setForm ( $ key , $ spec , $ currentEnabled ) ; } return $ this ; }
1864	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( $ request -> isMethod ( 'POST' ) ) { return ; } if ( null === ( $ session = $ request -> getSession ( ) ) || ! $ session -> isStarted ( ) ) { return ; } $ this -> clearLegacyAttributeBags ( 'FE_DATA' ) ; $ this -> clearLegacyAttributeBags ( 'BE_DATA' ) ; $ this -> clearLegacyFormData ( ) ; }
9990	private function writeImageInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getDrawingCollection ( ) as $ drawing ) { if ( $ drawing instanceof Drawing ) { if ( $ drawing -> getCoordinates ( ) == $ coordinates ) { $ filename = $ drawing -> getPath ( ) ; if ( substr ( $ filename , 0 , 1 ) == '.' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = $ this -> getImagesRoot ( ) . $ filename ; if ( substr ( $ filename , 0 , 1 ) == '.' && substr ( $ filename , 0 , 2 ) != './' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = htmlspecialchars ( $ filename ) ; $ html .= PHP_EOL ; if ( ( ! $ this -> embedImages ) || ( $ this -> isPdf ) ) { $ imageData = $ filename ; } else { $ imageDetails = getimagesize ( $ filename ) ; if ( $ fp = fopen ( $ filename , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ filename ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; } else { $ imageData = $ filename ; } } $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ drawing -> getOffsetX ( ) . 'px; top: ' . $ drawing -> getOffsetY ( ) . 'px; width: ' . $ drawing -> getWidth ( ) . 'px; height: ' . $ drawing -> getHeight ( ) . 'px;" src="' . $ imageData . '" border="0" />' ; $ html .= '</div>' ; } } elseif ( $ drawing instanceof MemoryDrawing ) { if ( $ drawing -> getCoordinates ( ) != $ coordinates ) { continue ; } ob_start ( ) ; imagepng ( $ drawing -> getImageResource ( ) ) ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; $ dataUri = 'data:image/jpeg;base64,' . base64_encode ( $ contents ) ; $ html .= '<img src="' . $ dataUri . '" style="max-width:100%;width:' . $ drawing -> getWidth ( ) . 'px;" />' ; } } return $ html ; }
11684	protected function registerCommands ( ) { $ this -> commands ( \ Lab123 \ Odin \ Command \ AppRestart :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ AppStart :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ GeneratePasswordCommand :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenAppNameCommand :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenRouteList :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenVendorPublish :: class ) ; $ this -> commands ( \ Lab123 \ Odin \ Command \ LumenModelMake :: class ) ; }
1214	public static function isObject ( $ value ) { if ( is_array ( $ value ) ) { return ! $ value || array_keys ( $ value ) [ 0 ] !== 0 ; } return $ value instanceof \ Countable && $ value instanceof \ ArrayAccess ? count ( $ value ) == 0 || ! $ value -> offsetExists ( 0 ) : $ value instanceof \ stdClass || $ value instanceof JmesPathableObjectInterface ; }
10435	public function post ( $ request ) { if ( $ request instanceof Request ) { $ request = $ request -> xml ( ) ; } $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> url ) ; if ( $ this -> user_agent != null ) { curl_setopt ( $ ch , CURLOPT_USERAGENT , $ this -> user_agent ) ; } curl_setopt ( $ ch , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_POST , 1 ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ request ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-type: application/xml; charset=utf-8' , ) ) ; $ response = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; if ( empty ( $ response ) ) { return null ; } return $ response ; }
11318	public function getBaseData ( ) { $ data = new FluidXml ( false ) ; $ message = $ data -> addChild ( 'Message' , [ 'version' => $ this -> getApiVersion ( ) ] , true ) ; $ header = $ message -> addChild ( 'Header' , true ) ; $ header -> addChild ( 'Time' , $ this -> getTime ( ) ) ; $ itentity = $ header -> addChild ( 'Identity' , true ) ; $ itentity -> addChild ( 'UserID' , $ this -> getUserId ( ) ) ; $ body = $ message -> addChild ( 'Body' , [ 'type' => 'GetInvoice' , 'live' => $ this -> getLive ( ) ] , true ) ; $ order = $ body -> addChild ( 'Order' , [ 'paymentMethod' => $ this -> getPaymentMethod ( ) ] , true ) ; $ order -> addChild ( 'MerchantID' , $ this -> getMerchantId ( ) ) ; $ order -> addChild ( 'SiteAddress' , $ this -> getSiteAddress ( ) ) ; $ order -> addChild ( 'PostbackURL' , $ this -> getNotifyUrl ( ) ) ; $ order -> addChild ( 'SuccessURL' , $ this -> getReturnUrl ( ) ) ; $ order -> addChild ( 'FailureURL' , $ this -> getCancelUrl ( ) ) ; return $ message ; }
8053	public function deleteCalendarEvent ( $ id ) { $ cache = $ this -> cache ; $ this -> calendarEvent -> destroy ( $ id ) ; $ allEvents = $ this -> getAllEvents ( ) ; unset ( $ allEvents [ $ id ] ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
7171	protected function resolveTaxRule ( CountryInterface $ country , $ business = false ) : ? TaxRuleInterface { if ( $ business ) { return $ this -> taxRuleRepository -> findOneByCountryForBusiness ( $ country ) ; } return $ this -> taxRuleRepository -> findOneByCountryForCustomer ( $ country ) ; }
1357	public function field ( string $ field , string $ inverse = null ) : self { $ this -> defaults = array_merge ( $ this -> defaults , [ ResourceRegistrar :: PARAM_RELATIONSHIP_NAME => $ field , ResourceRegistrar :: PARAM_RELATIONSHIP_INVERSE_TYPE => $ inverse ? : Str :: plural ( $ field ) , ] ) ; return $ this ; }
425	protected function addErrorClassIfNeeded ( & $ options ) { $ attributeName = Html :: getAttributeName ( $ this -> attribute ) ; if ( $ this -> model -> hasErrors ( $ attributeName ) ) { Html :: addCssClass ( $ options , $ this -> form -> errorCssClass ) ; } }
11597	public static function setCacheType ( string $ sCacheName ) { if ( $ sCacheName === 'file' ) { self :: $ _sTypeOfCache = 'file' ; } else if ( $ sCacheName === 'memcache' ) { self :: $ _sTypeOfCache = 'memcache' ; } else if ( $ sCacheName === 'apc' ) { self :: $ _sTypeOfCache = 'apc' ; } else if ( $ sCacheName === 'redis' ) { self :: $ _sTypeOfCache = 'redis' ; } else { self :: $ _sTypeOfCache = 'mock' ; } }
8764	private function createUniqueFilename ( $ filename ) { $ full_size_dir = config ( 'dropzoner.upload-path' ) ; $ full_image_path = $ full_size_dir . $ filename . '.jpg' ; if ( \ File :: exists ( $ full_image_path ) ) { $ image_token = substr ( sha1 ( mt_rand ( ) ) , 0 , 5 ) ; return $ filename . '-' . $ image_token ; } return $ filename ; }
12839	static public function generateFilename ( $ directory , $ extension , $ length = 16 ) { do { $ name = \ Extlib \ Generator :: generate ( $ length ) ; $ filepath = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . sprintf ( '%s.%s' , $ name , $ extension ) ; } while ( file_exists ( $ filepath ) ) ; return $ name ; }
1098	public function updateStructure ( ) { list ( $ a , $ b , $ c , $ d ) = $ this -> boundaries ( ) ; $ this -> applyLockBetween ( $ a , $ d ) ; $ connection = $ this -> node -> getConnection ( ) ; $ grammar = $ connection -> getQueryGrammar ( ) ; $ currentId = $ this -> quoteIdentifier ( $ this -> node -> getKey ( ) ) ; $ parentId = $ this -> quoteIdentifier ( $ this -> parentId ( ) ) ; $ leftColumn = $ this -> node -> getLeftColumnName ( ) ; $ rightColumn = $ this -> node -> getRightColumnName ( ) ; $ parentColumn = $ this -> node -> getParentColumnName ( ) ; $ wrappedLeft = $ grammar -> wrap ( $ leftColumn ) ; $ wrappedRight = $ grammar -> wrap ( $ rightColumn ) ; $ wrappedParent = $ grammar -> wrap ( $ parentColumn ) ; $ wrappedId = $ grammar -> wrap ( $ this -> node -> getKeyName ( ) ) ; $ lftSql = "CASE WHEN $wrappedLeft BETWEEN $a AND $b THEN $wrappedLeft + $d - $b WHEN $wrappedLeft BETWEEN $c AND $d THEN $wrappedLeft + $a - $c ELSE $wrappedLeft END" ; $ rgtSql = "CASE WHEN $wrappedRight BETWEEN $a AND $b THEN $wrappedRight + $d - $b WHEN $wrappedRight BETWEEN $c AND $d THEN $wrappedRight + $a - $c ELSE $wrappedRight END" ; $ parentSql = "CASE WHEN $wrappedId = $currentId THEN $parentId ELSE $wrappedParent END" ; $ updateConditions = array ( $ leftColumn => $ connection -> raw ( $ lftSql ) , $ rightColumn => $ connection -> raw ( $ rgtSql ) , $ parentColumn => $ connection -> raw ( $ parentSql ) ) ; if ( $ this -> node -> timestamps ) $ updateConditions [ $ this -> node -> getUpdatedAtColumn ( ) ] = $ this -> node -> freshTimestamp ( ) ; return $ this -> node -> newNestedSetQuery ( ) -> where ( function ( $ query ) use ( $ leftColumn , $ rightColumn , $ a , $ d ) { $ query -> whereBetween ( $ leftColumn , array ( $ a , $ d ) ) -> orWhereBetween ( $ rightColumn , array ( $ a , $ d ) ) ; } ) -> update ( $ updateConditions ) ; }
4213	public static function colKeys ( $ rows ) { if ( ! \ is_array ( $ rows ) ) { return array ( ) ; } if ( Abstracter :: isAbstraction ( $ rows ) && $ rows [ 'traverseValues' ] ) { $ rows = $ rows [ 'traverseValues' ] ; } $ lastKeys = array ( ) ; $ newKeys = array ( ) ; $ curKeys = array ( ) ; foreach ( $ rows as $ row ) { $ curKeys = self :: keys ( $ row ) ; if ( empty ( $ lastKeys ) ) { $ lastKeys = $ curKeys ; } elseif ( $ curKeys != $ lastKeys ) { $ newKeys = array ( ) ; $ count = \ count ( $ curKeys ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ curKey = $ curKeys [ $ i ] ; if ( $ lastKeys && $ curKey === $ lastKeys [ 0 ] ) { \ array_push ( $ newKeys , $ curKey ) ; \ array_shift ( $ lastKeys ) ; } elseif ( false !== $ position = \ array_search ( $ curKey , $ lastKeys , true ) ) { $ segment = \ array_splice ( $ lastKeys , 0 , $ position + 1 ) ; \ array_splice ( $ newKeys , \ count ( $ newKeys ) , 0 , $ segment ) ; } elseif ( ! \ in_array ( $ curKey , $ newKeys , true ) ) { \ array_push ( $ newKeys , $ curKey ) ; } } \ array_splice ( $ newKeys , \ count ( $ newKeys ) , 0 , $ lastKeys ) ; $ lastKeys = \ array_unique ( $ newKeys ) ; } } return $ lastKeys ; }
2999	public function setErrors ( $ email , $ title = null ) { $ this -> set ( 'Sender' , $ this -> buildMail ( $ email , $ title ) ) ; }
7061	private function setClasses ( array $ classes ) { if ( ! empty ( $ classes ) ) { $ this -> vars [ 'attr' ] [ 'class' ] = ' ' . trim ( implode ( ' ' , $ classes ) ) ; } else { unset ( $ this -> vars [ 'attr' ] [ 'class' ] ) ; } }
10190	public function getAllSpContainers ( ) { $ allSpContainers = [ ] ; foreach ( $ this -> children as $ child ) { if ( $ child instanceof self ) { $ allSpContainers = array_merge ( $ allSpContainers , $ child -> getAllSpContainers ( ) ) ; } else { $ allSpContainers [ ] = $ child ; } } return $ allSpContainers ; }
11342	public function setDesigner ( Designer $ designer ) { $ this -> designer = $ designer ; $ this -> designer -> build ( $ this ) ; }
6270	private function matchesAcademicDomain ( $ domain ) { if ( empty ( $ domain [ 'tld' ] ) or empty ( $ domain [ 'sld' ] ) ) { return false ; } return file_exists ( $ this -> getPath ( $ domain ) ) ; }
5287	public static function request ( $ method , $ params = null ) { $ url = self :: getUrl ( $ method ) ; $ request_method = self :: getRequestMethodName ( ) ; $ response_body = self :: $ request_method ( $ url , $ params ) ; $ response = json_decode ( $ response_body ) ; if ( ! is_object ( $ response ) ) throw new Error ( "Invalid server response: $response_body" ) ; if ( isset ( $ response -> error ) ) throw new Error ( $ response -> error -> message ) ; return $ response ; }
3645	public function old ( string $ key , $ default = null , bool $ trim = true , bool $ clean = true ) { $ value = $ this -> request -> old ( $ key , $ default ) ; return $ this -> clean ( $ value , $ trim , $ clean ) ; }
3010	public function setConsumer ( $ consumerKey , $ consumerSecret ) { $ this -> apiKey = $ consumerKey ; $ this -> requestHandler -> setConsumer ( $ consumerKey , $ consumerSecret ) ; }
6204	public function onError ( $ type , $ message , $ file = null , $ line = null , $ context = null ) { if ( ini_get ( 'error_reporting' ) == 0 ) { return true ; } if ( isset ( $ this -> fatalErrors [ $ type ] ) ) { throw new Exception ( $ message ) ; } if ( $ this -> shouldNotifyError ( $ type , $ message , $ file , $ line , $ context ) ) { $ backtrace = debug_backtrace ( ) ; array_shift ( $ backtrace ) ; $ this -> airbrakeClient -> notifyOnError ( $ message , $ backtrace ) ; return true ; } return true ; }
10814	protected function _setDataStore ( $ dataStore ) { if ( ! is_null ( $ dataStore ) ) { $ dataStore = $ this -> _normalizeContainer ( $ dataStore ) ; } $ this -> dataStore = $ dataStore ; }
8469	public function emergency ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'emergency' , $ scope , $ message , $ context , $ config ) ; }
7670	function ServerHostname ( ) { if ( $ this -> Hostname != "" ) $ result = $ this -> Hostname ; elseif ( $ this -> ServerVar ( 'SERVER_NAME' ) != "" ) $ result = $ this -> ServerVar ( 'SERVER_NAME' ) ; else $ result = "localhost.localdomain" ; return $ result ; }
6819	protected function writeInvoiceShipmentLine ( ) { $ amount = $ this -> invoice -> getShipmentBase ( ) ; if ( 0 === $ this -> compare ( $ amount , 0 ) ) { return ; } $ amount = $ this -> round ( $ amount ) ; $ sale = $ this -> invoice -> getSale ( ) ; $ date = $ sale -> getCreatedAt ( ) ; $ taxRule = $ this -> taxResolver -> resolveSaleTaxRule ( $ sale ) ; $ account = $ this -> getShipmentAccountNumber ( $ taxRule , $ this -> invoice -> getNumber ( ) ) ; if ( $ this -> invoice -> getType ( ) === InvoiceTypes :: TYPE_CREDIT ) { $ this -> writer -> credit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance -= $ amount ; } else { $ this -> writer -> debit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance += $ amount ; } }
9945	private function createNewCell ( $ pCoordinate ) { $ cell = new Cell ( null , DataType :: TYPE_NULL , $ this ) ; $ this -> cellCollection -> add ( $ pCoordinate , $ cell ) ; $ this -> cellCollectionIsSorted = false ; $ aCoordinates = Coordinate :: coordinateFromString ( $ pCoordinate ) ; if ( Coordinate :: columnIndexFromString ( $ this -> cachedHighestColumn ) < Coordinate :: columnIndexFromString ( $ aCoordinates [ 0 ] ) ) { $ this -> cachedHighestColumn = $ aCoordinates [ 0 ] ; } $ this -> cachedHighestRow = max ( $ this -> cachedHighestRow , $ aCoordinates [ 1 ] ) ; $ rowDimension = $ this -> getRowDimension ( $ aCoordinates [ 1 ] , false ) ; $ columnDimension = $ this -> getColumnDimension ( $ aCoordinates [ 0 ] , false ) ; if ( $ rowDimension !== null && $ rowDimension -> getXfIndex ( ) > 0 ) { $ cell -> setXfIndex ( $ rowDimension -> getXfIndex ( ) ) ; } elseif ( $ columnDimension !== null && $ columnDimension -> getXfIndex ( ) > 0 ) { $ cell -> setXfIndex ( $ columnDimension -> getXfIndex ( ) ) ; } return $ cell ; }
236	protected function getCacheKey ( $ name ) { return [ __CLASS__ , $ this -> db -> dsn , $ this -> db -> username , $ this -> getRawTableName ( $ name ) , ] ; }
5453	public function endElement ( $ name ) { if ( $ name === 'label' ) { $ this -> acceptLabelEnd ( ) ; return true ; } if ( $ name === 'form' ) { $ this -> acceptFormEnd ( ) ; return true ; } if ( $ name === 'frameset' ) { $ this -> acceptFramesetEnd ( ) ; return true ; } if ( $ this -> hasNamedTagOnOpenTagStack ( $ name ) ) { $ tag = array_pop ( $ this -> tags [ $ name ] ) ; if ( $ tag -> isPrivateContent ( ) && $ this -> private_content_tag -> getTagName ( ) == $ name ) { unset ( $ this -> private_content_tag ) ; } $ this -> addContentTagToOpenTags ( $ tag ) ; $ this -> acceptTag ( $ tag ) ; return true ; } return true ; }
12057	public function getTarget ( ) { if ( is_null ( $ this -> _target ) && ! empty ( $ this -> possibleTargets ) ) { $ this -> _target = $ this -> possibleTargets [ 0 ] ; } return $ this -> _target ; }
5206	public function areActiveRoutes ( array $ routeNames , $ output = "active" ) { foreach ( $ routeNames as $ routeName ) { if ( $ this -> isActiveRoute ( $ routeName , true ) ) { return $ output ; } } return null ; }
433	public function setModules ( $ modules ) { foreach ( $ modules as $ id => $ module ) { $ this -> _modules [ $ id ] = $ module ; } }
12817	public function fetchAll ( ) { $ list = [ ] ; foreach ( $ this -> cache as $ domain => $ values ) { foreach ( $ values as $ key => $ value ) $ list [ sprintf ( "%s.%s" , $ domain != '<NULL>' ? $ domain : '' , $ key ) ] = $ value ; } return $ list ; }
5955	public function channelPermList ( $ cid , $ permsid = false ) { return $ this -> execute ( "channelpermlist" , array ( "cid" => $ cid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
5070	protected function determineHeaderTags ( $ topLevel , $ depth ) { $ desired = range ( ( int ) $ topLevel , ( int ) $ topLevel + ( ( int ) $ depth - 1 ) ) ; $ allowed = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; return array_map ( function ( $ val ) { return 'h' . $ val ; } , array_intersect ( $ desired , $ allowed ) ) ; }
9995	private function writeComment ( Worksheet $ pSheet , $ coordinate ) { $ result = '' ; if ( ! $ this -> isPdf && isset ( $ pSheet -> getComments ( ) [ $ coordinate ] ) ) { $ result .= '<a class="comment-indicator"></a>' ; $ result .= '<div class="comment">' . nl2br ( $ pSheet -> getComment ( $ coordinate ) -> getText ( ) -> getPlainText ( ) ) . '</div>' ; $ result .= PHP_EOL ; } return $ result ; }
3718	protected function getMetaModelFromModel ( ModelInterface $ model ) { if ( ! ( ( $ model -> getProviderName ( ) == 'tl_metamodel_dca_sortgroup' ) && $ model -> getProperty ( 'pid' ) ) ) { throw new DcGeneralInvalidArgumentException ( sprintf ( 'Model must originate from tl_metamodel_dca_sortgroup and be saved, this one originates from %s ' . 'and has pid %s' , $ model -> getProviderName ( ) , $ model -> getProperty ( 'pid' ) ) ) ; } $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'pid' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchColumn ( ) ; $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; return $ this -> factory -> getMetaModel ( $ tableName ) ; }
3300	public function post ( $ url , $ params = [ ] ) { $ key = is_array ( $ params ) ? 'form_params' : 'body' ; return $ this -> request ( 'POST' , $ url , [ $ key => $ params ] ) ; }
9523	private function getConfig ( ) { $ yaml = new Parser ( ) ; $ configFile = getenv ( 'TRAVIS_BUILD_DIR' ) . '/.travis.yml' ; $ config = $ yaml -> parse ( file_get_contents ( $ configFile ) ) ; $ config = $ config [ 'travisdeployer' ] ; $ this -> branches = $ config [ 'branches' ] ; if ( count ( $ this -> branches ) === 0 ) { die ( 'No branches are configured to deploy to.' . PHP_EOL ) ; } $ this -> verbose = filter_input ( FILTER_VALIDATE_BOOLEAN , $ config [ 'verbose' ] ) ; }
8049	public function createCalendarEvent ( array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEvent = $ this -> calendarEvent -> create ( $ eventData ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents [ $ calendarEvent -> id ] = $ calendarEvent ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
138	public function update ( RepositoryInterface $ repo , UpdateOperation $ operation ) { $ initial = $ operation -> getInitialPackage ( ) ; $ target = $ operation -> getTargetPackage ( ) ; $ initialType = $ initial -> getType ( ) ; $ targetType = $ target -> getType ( ) ; if ( $ initialType === $ targetType ) { $ installer = $ this -> getInstaller ( $ initialType ) ; $ installer -> update ( $ repo , $ initial , $ target ) ; $ this -> markForNotification ( $ target ) ; } else { $ this -> getInstaller ( $ initialType ) -> uninstall ( $ repo , $ initial ) ; $ this -> getInstaller ( $ targetType ) -> install ( $ repo , $ target ) ; } }
12721	public function isShared ( $ abstract ) { if ( ! isset ( $ this -> bindings [ $ abstract ] ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be valid keys in binding container stack." , __METHOD__ ) ) ; } return ( $ this -> bindings [ $ abstract ] [ 'shared' ] ? true : false ) ; }
1398	public function error ( $ error , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( is_string ( $ error ) ) { $ error = $ this -> api -> getErrors ( ) -> error ( $ error ) ; } else if ( is_array ( $ error ) ) { $ error = Error :: create ( $ error ) ; } if ( ! $ error instanceof ErrorInterface ) { throw new \ InvalidArgumentException ( 'Expecting a string, array or error object.' ) ; } return $ this -> errors ( $ error , $ defaultStatusCode , $ headers ) ; }
11422	public function get ( $ openId , $ lang = 'zh_CN' ) { $ params = [ 'openid' => $ openId , 'lang' => $ lang , ] ; return $ this -> parseJSON ( 'get' , [ self :: API_GET , $ params ] ) ; }
11265	public function model ( $ pathname ) { $ fullPath = $ this -> config [ 'pathToModels' ] . $ this -> getPath ( $ pathname ) . $ this -> config [ 'modelsPrefix' ] . $ this -> getName ( $ pathname ) . $ this -> config [ 'modelsPostfix' ] . '.php' ; include_once ( $ fullPath ) ; }
7874	private function checkConfig ( ) : void { if ( empty ( $ this -> userkey ) ) { Log :: warning ( 'Config "message.zenziva.userkey" is not defined.' ) ; } if ( empty ( $ this -> passkey ) ) { Log :: warning ( 'Config "message.zenziva.passkey" is not defined.' ) ; } }
6872	private function initializeRelayPoint ( ShipmentInterface $ shipment ) { if ( null === $ method = $ shipment -> getMethod ( ) ) { if ( null !== $ shipment -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( null ) ; } return ; } $ gateway = $ this -> registry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( ! $ gateway -> supports ( GatewayInterface :: CAPABILITY_RELAY ) ) { if ( null !== $ shipment -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( null ) ; } return ; } if ( null !== $ relayPoint = $ shipment -> getSale ( ) -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( $ relayPoint ) ; } }
8245	protected function abortIfExpired ( $ id , $ userData ) { if ( isset ( $ userData [ 'pwreset' ] ) && $ userData [ 'pwreset' ] ) { $ this -> session -> addFlash ( "error" , "Please set a new password." ) ; $ this -> picoAuth -> getContainer ( ) -> get ( 'PasswordReset' ) -> startPasswordResetSession ( $ id ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
12429	public function getAuthorizerList ( $ offset = 0 , $ count = 500 ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'offset' => $ offset , 'count' => $ count , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_LIST , $ params ] ) ; }
1859	public function copy ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; return copy ( $ this -> strRootDir . '/' . $ strSource , $ this -> strRootDir . '/' . $ strDestination ) ; }
3771	public function fixupModules ( DataContainer $ dataContainer ) { if ( ! class_exists ( 'tl_user_group' , false ) ) { throw new \ RuntimeException ( 'data container is not loaded!' ) ; } $ original = new \ tl_user_group ( ) ; $ modules = $ original -> getModules ( ) ; foreach ( array_keys ( $ modules ) as $ group ) { foreach ( $ modules [ $ group ] as $ key => $ module ) { if ( strpos ( $ module , 'metamodel_' ) === 0 ) { unset ( $ modules [ $ group ] [ $ key ] ) ; } } $ modules [ $ group ] = array_values ( $ modules [ $ group ] ) ; } $ modules [ 'metamodels' ] [ ] = 'support_metamodels' ; if ( false !== $ index = array_search ( 'metamodels' , $ modules [ 'metamodels' ] , true ) ) { unset ( $ modules [ 'metamodels' ] [ $ index ] ) ; $ modules [ 'metamodels' ] = array_values ( $ modules [ 'metamodels' ] ) ; } $ combinations = $ this -> combinationBuilder -> getCombinationsForUser ( [ $ dataContainer -> activeRecord -> id ] , 'be' ) ; $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ locale = $ this -> requestStack -> getCurrentRequest ( ) -> getLocale ( ) ; foreach ( $ screens as $ metaModel => $ screen ) { if ( 'standalone' === $ screen [ 'meta' ] [ 'rendertype' ] ) { $ modules [ $ screen [ 'meta' ] [ 'backendsection' ] ] [ ] = 'metamodel_' . $ metaModel ; $ this -> buildLanguageString ( 'metamodel_' . $ metaModel , $ screen , $ locale ) ; } } return $ modules ; }
9270	public function load ( ContainerBuilder $ container ) { $ loader = $ this -> getContainerLoader ( $ container ) ; $ loader -> load ( $ this -> configFile ) ; }
4724	public function render ( ) { $ html = new Text ( ) ; $ html -> append ( '<' ) -> append ( $ this -> getName ( ) ) ; foreach ( $ this -> attributes as $ name => $ value ) { $ html -> append ( ' ' ) -> append ( $ name ) -> append ( '=' ) -> append ( '"' ) -> append ( $ value ) -> append ( '"' ) ; } if ( $ this -> text -> isEmpty ( ) ) { if ( $ this -> type == self :: TYPE_BLOCK ) { return ( string ) $ html -> append ( '>' ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; } else { return ( string ) $ html -> append ( $ this -> emptyTagSuffix ) ; } } return ( string ) $ html -> append ( '>' ) -> append ( $ this -> text ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; }
2759	protected function getStorageKey ( $ key , $ limit , $ milliseconds ) { $ window = $ milliseconds * ( floor ( ( microtime ( 1 ) * 1000 ) / $ milliseconds ) ) ; $ date = date ( 'YmdHis' , $ window / 1000 ) ; return $ date . '::' . $ key . '::' . $ limit . '::' . $ milliseconds . '::COUNT' ; }
10243	public function isImplemented ( $ pFunction ) { $ pFunction = strtoupper ( $ pFunction ) ; $ notImplemented = ! isset ( self :: $ phpSpreadsheetFunctions [ $ pFunction ] ) || ( is_array ( self :: $ phpSpreadsheetFunctions [ $ pFunction ] [ 'functionCall' ] ) && self :: $ phpSpreadsheetFunctions [ $ pFunction ] [ 'functionCall' ] [ 1 ] === 'DUMMY' ) ; return ! $ notImplemented ; }
9183	protected function forgetByKey ( $ key ) { $ result = false ; if ( Cache :: has ( $ key ) ) { $ result = Cache :: forget ( $ key ) ; } return $ result ; }
3930	private function buildProperty ( PropertiesDefinitionInterface $ definition , IAttribute $ attribute , array $ propInfo ) { if ( ! $ attribute ) { return ; } $ property = $ this -> getOrCreateProperty ( $ definition , $ attribute -> getColName ( ) ) ; $ this -> setLabel ( $ property , $ propInfo , $ attribute ) ; $ this -> setDescription ( $ property , $ propInfo ) ; $ this -> setDefaultValue ( $ property , $ propInfo ) ; $ this -> setExcluded ( $ property , $ propInfo ) ; $ this -> setSearchable ( $ property , $ propInfo ) ; $ this -> setFilterable ( $ property , $ propInfo ) ; $ this -> setWidgetType ( $ property , $ propInfo ) ; $ this -> setOptions ( $ property , $ propInfo ) ; $ this -> setExplanation ( $ property , $ propInfo ) ; $ this -> setEval ( $ property , $ propInfo , ( $ attribute instanceof ITranslated ) ) ; $ this -> setEmptyValue ( $ property , $ propInfo ) ; }
5920	public function setUpdated ( $ updated ) { if ( $ updated instanceof DateTime ) { $ this -> updated = $ updated ; } else { try { $ this -> updated = new DateTime ( $ updated ) ; } catch ( \ Exception $ e ) { $ this -> updated = null ; } } return $ this ; }
3950	private function buildChildOperationButton ( $ idParameter , $ itemId , $ href , $ label , $ name , $ icon , $ attributes , $ table ) { $ modelId = ModelId :: fromValues ( $ table , $ itemId ) ; $ url = $ href . '&amp;' . $ idParameter . '=' . $ modelId -> getSerialized ( ) ; if ( 'id' !== $ idParameter ) { $ url .= '&amp;id=' ; } $ url = $ this -> controller -> addToUrl ( $ url ) ; if ( 'id' !== $ idParameter ) { $ url = preg_replace ( '#(&amp;)id=(?:&amp;)?#' , '$1' , $ url ) ; } $ title = sprintf ( $ label ? : $ name , $ itemId ) ; return sprintf ( '<a href="%1$s" title="%2$s"%3$s>%4$s</a> ' , $ url , specialchars ( $ title ) , $ attributes , $ this -> iconBuilder -> getBackendIconImageTag ( $ icon , $ label ) ) ; }
10713	public function saveMany ( ArrayAccess $ models ) { if ( ! $ models instanceof Collection ) { $ models = collect ( $ models ) ; } foreach ( $ models as $ model ) { $ this -> save ( $ model ) ; } return $ models ; }
5363	public function generate ( Registry $ registry ) { $ context = $ this -> createContext ( $ registry , 'Client' ) ; $ files = [ ] ; foreach ( $ registry -> getSchemas ( ) as $ schema ) { $ context -> setCurrentSchema ( $ schema ) ; $ files = array_merge ( $ files , $ this -> modelGenerator -> generate ( $ schema , $ schema -> getRootName ( ) , $ context ) ) ; $ files = array_merge ( $ files , $ this -> normalizerGenerator -> generate ( $ schema , $ schema -> getRootName ( ) , $ context ) ) ; $ clients = $ this -> clientGenerator -> generate ( $ schema -> getParsed ( ) , $ schema -> getNamespace ( ) , $ context , $ schema -> getOrigin ( ) . '#' ) ; foreach ( $ clients as $ node ) { $ files [ ] = new File ( $ schema -> getDirectory ( ) . DIRECTORY_SEPARATOR . 'Resource' . DIRECTORY_SEPARATOR . $ node -> stmts [ 2 ] -> name . '.php' , $ node , '' ) ; } } return $ files ; }
1154	public function makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'makeReplacements' , [ $ message , $ attribute , $ rule , $ parameters ] ) ; }
9909	public function setPositionXL ( $ positionXL ) { if ( ! isset ( self :: $ positionXLref [ $ positionXL ] ) ) { return false ; } $ this -> position = self :: $ positionXLref [ $ positionXL ] ; return true ; }
7512	function next ( ) { $ this -> token_start = null ; if ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { return ( $ this -> token = self :: TOK_NULL ) ; } }
2651	public function activateVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/activate' ; $ result = $ this -> _fetch ( $ url , 'PUT' ) ; return $ result ; }
5773	public function isUpdatable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } if ( $ this -> authorization -> hasTopRole ( ) ) { return true ; } if ( ! $ this -> hasTopRole ( ) ) { return true ; } return false ; }
1885	public function getItemsAsString ( $ strSeparator = ' ' ) { $ arrLinks = array ( ) ; foreach ( $ this -> getItemsAsArray ( ) as $ arrItem ) { if ( $ arrItem [ 'href' ] === null ) { $ arrLinks [ ] = sprintf ( '<li><strong class="active">%s</strong></li>' , $ arrItem [ 'page' ] ) ; } else { $ arrLinks [ ] = sprintf ( '<li><a href="%s" class="link" title="%s">%s</a></li>' , $ arrItem [ 'href' ] , $ arrItem [ 'title' ] , $ arrItem [ 'page' ] ) ; } } return implode ( $ strSeparator , $ arrLinks ) ; }
7768	public function validate ( array $ data , $ rules = [ ] ) { $ this -> clearErrors ( ) ; $ this -> clearFieldAliases ( ) ; $ data = $ this -> extractFieldAliases ( $ data ) ; if ( empty ( $ rules ) ) { $ rules = $ this -> extractRules ( $ data ) ; $ data = $ this -> extractInput ( $ data ) ; } $ this -> input = $ data ; foreach ( $ this -> before as $ before ) { call_user_func_array ( $ before , [ $ this ] ) ; } foreach ( $ data as $ field => $ value ) { $ fieldRules = explode ( '|' , $ rules [ $ field ] ) ; foreach ( $ fieldRules as $ rule ) { $ continue = $ this -> validateAgainstRule ( $ field , $ value , $ this -> getRuleName ( $ rule ) , $ this -> getRuleArgs ( $ rule ) ) ; if ( ! $ continue ) { break ; } } } return $ this ; }
9672	private function writeBorderPr ( XMLWriter $ objWriter , $ pName , Border $ pBorder ) { if ( $ pBorder -> getBorderStyle ( ) != Border :: BORDER_NONE ) { $ objWriter -> startElement ( $ pName ) ; $ objWriter -> writeAttribute ( 'style' , $ pBorder -> getBorderStyle ( ) ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pBorder -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; } }
6139	public static function check ( $ uri ) { try { $ uri = new self ( strval ( $ uri ) ) ; } catch ( Ts3Exception $ e ) { return false ; } return $ uri -> valid ( ) ; }
12728	public function expectsOutcome ( IOutcomeRule $ rule , IOutcomeRule $ rule2 = null , IOutcomeRule $ rule3 = null , IOutcomeRule $ rule4 = null , IOutcomeRule $ rule5 = null , IOutcomeRule $ rule6 = null , IOutcomeRule $ rule7 = null , IOutcomeRule $ rule8 = null , IOutcomeRule $ rule9 = null , IOutcomeRule $ rule10 = null ) { foreach ( func_get_args ( ) as $ arg ) { if ( $ arg instanceof IInputRule ) { $ this -> outcomeRules [ ] = $ arg ; } } return $ this ; }
6867	protected function getSaleFromInvoice ( InvoiceInterface $ invoice ) { if ( null === $ sale = $ invoice -> getSale ( ) ) { $ cs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , $ this -> getSalePropertyPath ( ) ) ; if ( ! empty ( $ cs ) ) { $ sale = $ cs [ 0 ] ; } } if ( ! $ sale instanceof SaleInterface ) { throw new Exception \ RuntimeException ( "Failed to retrieve invoice's sale." ) ; } return $ sale ; }
3432	protected function normalizeSelect ( ) { if ( $ this -> fieldsMustBeSelected ( ) ) { $ this -> select = array_merge ( $ this -> standardFields , $ this -> select ) ; } if ( $ this -> propsMustBeSelected ( ) ) { $ this -> select [ ] = 'IBLOCK_ID' ; $ this -> select [ ] = 'UF_*' ; } $ this -> select [ ] = 'ID' ; return $ this -> clearSelectArray ( ) ; }
6581	public function translate ( $ shift , $ y = null , $ z = null ) { if ( $ shift instanceof self ) return new static ( $ this -> gps [ 'x' ] + $ shift -> gps [ 'x' ] , $ this -> gps [ 'y' ] + $ shift -> gps [ 'y' ] , $ this -> gps [ 'z' ] + $ shift -> gps [ 'z' ] ) ; else return new static ( $ this -> gps [ 'x' ] + $ shift , $ this -> gps [ 'y' ] + $ y , $ this -> gps [ 'z' ] + $ z ) ; }
201	private function valueExists ( $ targetClass , $ query , $ value ) { $ db = $ targetClass :: getDb ( ) ; $ exists = false ; if ( $ this -> forceMasterDb && method_exists ( $ db , 'useMaster' ) ) { $ db -> useMaster ( function ( $ db ) use ( $ query , $ value , & $ exists ) { $ exists = $ this -> queryValueExists ( $ query , $ value ) ; } ) ; } else { $ exists = $ this -> queryValueExists ( $ query , $ value ) ; } return $ exists ; }
5357	protected function createQueryParamStatements ( Operation $ operation ) { $ queryParamDocumentation = [ ] ; $ queryParamVariable = new Expr \ Variable ( 'queryParam' ) ; $ queryParamStatements = [ new Expr \ Assign ( $ queryParamVariable , new Expr \ New_ ( new Name ( 'QueryParam' ) ) ) ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof FormDataParameterSubSchema ) { $ queryParamStatements = array_merge ( $ queryParamStatements , $ this -> formDataParameterGenerator -> generateQueryParamStatements ( $ parameter , $ queryParamVariable ) ) ; $ queryParamDocumentation [ ] = $ this -> formDataParameterGenerator -> generateQueryDocParameter ( $ parameter ) ; } if ( $ parameter instanceof HeaderParameterSubSchema ) { $ queryParamStatements = array_merge ( $ queryParamStatements , $ this -> headerParameterGenerator -> generateQueryParamStatements ( $ parameter , $ queryParamVariable ) ) ; $ queryParamDocumentation [ ] = $ this -> headerParameterGenerator -> generateQueryDocParameter ( $ parameter ) ; } if ( $ parameter instanceof QueryParameterSubSchema ) { $ queryParamStatements = array_merge ( $ queryParamStatements , $ this -> queryParameterGenerator -> generateQueryParamStatements ( $ parameter , $ queryParamVariable ) ) ; $ queryParamDocumentation [ ] = $ this -> queryParameterGenerator -> generateQueryDocParameter ( $ parameter ) ; } } } return [ $ queryParamDocumentation , $ queryParamStatements , $ queryParamVariable ] ; }
7011	private function formatS ( & $ str ) { if ( strstr ( $ str , '%S' ) ) $ str = str_replace ( '%S' , static :: ordinal ( $ this -> day ) , $ str ) ; }
10870	public function verifyHash ( string $ password , string $ hash ) : bool { return Passwords :: verify ( $ password , $ hash ) ; }
12255	public function removeCompiler ( $ compiler ) { if ( ( $ idx = array_search ( $ compiler , $ this -> compilers ) ) !== false ) { unset ( $ this -> compilers [ $ idx ] ) ; $ this -> orderedCompilers = NULL ; } }
4652	public function cleanDirectories ( $ jobs = array ( ) ) { foreach ( $ jobs as $ job ) { $ this -> filesystem -> remove ( $ job -> getDirectory ( ) ) ; } }
6598	protected function getParameters ( array $ lines ) { $ comment = implode ( "\n" , $ lines ) ; preg_match_all ( '/@param\s([\s\S]+?(?=@))/' , $ comment , $ paramsDoc ) ; $ params = [ ] ; if ( isset ( $ paramsDoc [ 1 ] ) ) { foreach ( $ paramsDoc [ 1 ] as $ paramDoc ) { $ documentation = [ ] ; preg_match ( '/([^$]+)?\$(\w+)(.+)?/s' , $ paramDoc , $ documentation ) ; list ( , $ type , $ name , $ description ) = $ documentation ; $ lines = preg_split ( "/((\r?\n)|(\r\n?))/" , $ description ) ; foreach ( $ lines as $ key => $ value ) { $ value = preg_replace ( '/\r/' , '' , $ value ) ; $ value = preg_replace ( '/^\s+\*/' , '' , $ value ) ; $ value = trim ( $ value ) ; $ lines [ $ key ] = $ value ; } $ description = implode ( "\n" , $ lines ) ; $ params [ $ name ] = [ 'type' => trim ( $ type ) , 'description' => trim ( $ description ) , ] ; } } return $ params ; }
9308	public function register ( ) { $ app = $ this -> app ; $ app -> bind ( 'Germanazo\CkanApi\CkanApiClient' , function ( ) { $ config = [ 'base_uri' => config ( 'ckan_api.url' ) , 'headers' => [ 'Authorization' => config ( 'ckan_api.api_key' ) ] , ] ; return new CkanApiClient ( new Client ( $ config ) ) ; } ) ; $ app -> alias ( 'Germanazo\CkanApi\CkanApiClient' , 'CkanApi' ) ; }
956	public function isActiveTrial ( ) { return $ this -> isTrial ( ) && Carbon :: today ( ) -> lte ( Carbon :: parse ( $ this -> trial_ends_on ) ) ; }
12196	public static function current ( ) { if ( defined ( 'PHPUNIT_RUNNING' ) ) { return 'http://localhost' ; } $ protocol = 'http://' ; if ( ! empty ( $ _SERVER [ 'HTTPS' ] ) || ( ! empty ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] === 'https' ) ) { $ protocol = 'https://' ; } return $ protocol . request ( ) -> server ( 'HTTP_HOST' ) . request ( ) -> server ( 'REQUEST_URI' ) ; }
6317	public function execute ( $ sql ) { $ this -> dispatcher -> dispatch ( 'rentgen.sql_executed' , new SqlEvent ( $ sql ) ) ; return $ this -> getConnection ( ) -> exec ( $ sql ) ; }
1118	public static function allLeaves ( ) { $ instance = new static ; $ grammar = $ instance -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ instance -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ instance -> getQualifiedLeftColumnName ( ) ) ; return $ instance -> newQuery ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
7335	private function addMappings ( ClassMetadata $ metadata , array $ mappings ) { foreach ( $ mappings as $ mapping ) { if ( ! $ metadata -> hasField ( $ mapping [ 'fieldName' ] ) ) { $ metadata -> mapField ( $ mapping ) ; } } }
8621	public function compile ( ) { $ compiled_blocks = [ ] ; foreach ( $ this -> blocks as $ key => $ block ) $ compiled_blocks [ ] = $ block -> compile ( ) ; return implode ( "\n\n" , $ compiled_blocks ) . "\n" ; }
5348	public function installOperatingSystem ( $ vpsName , $ operatingSystemName , $ hostname ) { return $ this -> call ( self :: SERVICE , 'installOperatingSystem' , [ $ vpsName , $ operatingSystemName , $ hostname ] ) ; }
3397	public function urlDecodeUnreservedChars ( $ string ) { $ string = rawurldecode ( $ string ) ; $ string = rawurlencode ( $ string ) ; $ string = str_replace ( array ( '%2F' , '%3A' , '%40' ) , array ( '/' , ':' , '@' ) , $ string ) ; return $ string ; }
9098	public function initThemeManager ( ModuleEvent $ e ) { $ moduleManager = $ e -> getTarget ( ) ; $ sm = $ moduleManager -> getEvent ( ) -> getParam ( 'ServiceManager' ) ; $ themManager = $ sm -> get ( 'yimaTheme.Manager' ) ; if ( ! $ themManager instanceof ManagerInterface ) { throw new \ Exception ( sprintf ( 'yimaTheme theme manager most instance of "ManagerInterface" but "%s" given.' , get_class ( $ themManager ) ) ) ; } $ themManager -> init ( ) ; }
10761	public function encodeString ( $ string ) { $ string = strtolower ( $ string ) ; $ src = "abcdefghijklmnopqrstuvwxyz0123456789 " ; $ dst = "jklmnopqrstuvwxyz0123456789abcdefghi " ; for ( $ i = 0 ; $ i < strlen ( $ string ) ; $ i ++ ) { $ pos = strpos ( $ src , $ string [ $ i ] ) ; if ( $ pos === false ) { throw new \ Exception ( "Please provide only numbers and alphanumerical characters" ) ; } $ string [ $ i ] = $ dst [ $ pos ] ; } return $ string ; }
3047	protected function getToolStates ( ) { $ toolStates = $ this -> getRunnerService ( ) -> getToolsStates ( $ this -> getServiceContext ( ) ) ; array_walk ( $ toolStates , function ( & $ toolState ) { $ toolState = json_decode ( $ toolState ) ; } ) ; return $ toolStates ; }
12018	protected function setup ( \ AMQPQueue $ queue ) { $ queue -> declareQueue ( ) ; foreach ( $ this -> binds as $ exchange => $ params ) { $ queue -> bind ( $ exchange , $ params [ 'routing_key' ] , $ params [ 'arguments' ] ) ; } }
12693	public function generate ( ) { $ templates = array_merge ( array_keys ( $ this -> templates [ "base" ] ) , array_keys ( $ this -> templates [ "template" ] ) ) ; foreach ( $ templates as $ template ) { $ templateDir = $ this -> themeDir . '/' . $ template ; if ( ! is_dir ( $ templateDir ) ) { continue ; } $ finder = new Finder ( ) ; $ files = $ finder -> files ( ) -> depth ( 0 ) -> in ( $ templateDir ) ; foreach ( $ files as $ file ) { $ file = ( string ) $ file ; $ slotName = basename ( $ file , '.json' ) ; $ json = FilesystemTools :: readFile ( $ file ) ; $ slot = json_decode ( $ json , true ) ; $ blocks = array ( ) ; if ( array_key_exists ( "blocks" , $ slot ) ) { $ blocks = $ slot [ "blocks" ] ; } $ slotManager = $ this -> slotsManagerFactory -> createSlotManager ( $ slot [ "repeat" ] ) ; $ slotManager -> addSlot ( $ slotName , $ blocks ) ; } } }
12970	private function getReflectionAndClassObject ( ) { if ( $ this -> isCalledAfterOn ) { $ this -> isCalledAfterOn = false ; $ classObj = $ this -> classObjOn ; $ reflection = $ this -> reflectionOn ; unset ( $ this -> classObjOn ) ; unset ( $ this -> reflectionOn ) ; return [ $ reflection , $ classObj ] ; } return [ $ this -> reflection , $ this -> classObj ] ; }
11589	public function matrix ( ) { if ( $ this -> _matrix ) { return $ this -> _matrix ; } $ this -> _matrix = new Matrix ( $ this -> tasks ( ) ) ; $ this -> _matrix -> process ( ) ; return $ this -> _matrix ; }
228	public function getTableNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _tableNames [ $ schema ] ) || $ refresh ) { $ this -> _tableNames [ $ schema ] = $ this -> findTableNames ( $ schema ) ; } return $ this -> _tableNames [ $ schema ] ; }
9931	public function getRule ( $ pIndex ) { if ( ! isset ( $ this -> ruleset [ $ pIndex ] ) ) { $ this -> ruleset [ $ pIndex ] = new Column \ Rule ( $ this ) ; } return $ this -> ruleset [ $ pIndex ] ; }
6408	public static function filterBy ( IteratorAggregate $ unfiltered , string $ className ) : IteratorAggregate { return self :: from ( Iterators :: filterBy ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ className ) ) ; }
11870	public function hideAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "page_manager" => $ app [ "red_kite_cms.page_manager" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: hide ( $ options ) ; }
7298	public function append_signature ( $ message , $ signature = '' ) { if ( empty ( $ signature ) ) { return $ message ; } $ separator = apply_filters ( 'iac_signature_separator' , str_repeat ( PHP_EOL , 2 ) . '--' . PHP_EOL ) ; return $ message . $ separator . $ signature ; }
5193	public function dispatch ( ServerRequestInterface $ request ) : ServerRequestInterface { $ dispatcher = simpleDispatcher ( [ $ this , 'addRoutes' ] ) ; $ routeInfo = $ dispatcher -> dispatch ( $ request -> getMethod ( ) , $ request -> getUri ( ) -> getPath ( ) ) ; if ( $ routeInfo [ 0 ] === Dispatcher :: METHOD_NOT_ALLOWED ) { throw new MethodNotAllowedException ( $ request -> getMethod ( ) , $ routeInfo [ 1 ] ) ; } if ( $ routeInfo [ 0 ] === Dispatcher :: NOT_FOUND ) { throw new NotFoundHttpException ( sprintf ( "Route '%s' not found." , $ request -> getUri ( ) -> getPath ( ) ) ) ; } foreach ( $ routeInfo [ 2 ] as $ key => $ value ) { $ request = $ request -> withAttribute ( $ key , $ value ) ; } return $ request -> withAttribute ( 'route' , $ this -> routes [ $ routeInfo [ 1 ] ] ) ; }
8125	protected function getSchemaRequested ( ) { $ parts = $ this -> owner -> getRequest ( ) -> getHeader ( LeftAndMain :: SCHEMA_HEADER ) ; return ! empty ( $ parts ) ; }
10478	protected function resolveItemAction ( AbstractDiffItem $ item ) { if ( $ item instanceof CreateDiffItem ) { $ action = ActionTypes :: CREATE ; return $ action ; } elseif ( $ item instanceof DeleteDiffItem ) { $ action = ActionTypes :: DELETE ; return $ action ; } elseif ( $ item instanceof UpdateDiffItem ) { $ action = ActionTypes :: UPDATE ; return $ action ; } else { throw new \ InvalidArgumentException ( 'Unsupported diff item type. Got: ' . get_class ( $ item ) ) ; } }
6889	protected function getAssignments ( $ item ) { if ( $ item instanceof ShipmentItemInterface ) { $ item = $ item -> getSaleItem ( ) ; } elseif ( $ item instanceof InvoiceLineInterface ) { if ( ! $ item = $ item -> getSaleItem ( ) ) { return null ; } } if ( ! $ this -> supportsAssignment ( $ item ) ) { return null ; } return $ item -> getStockAssignments ( ) -> toArray ( ) ; }
11613	public function create ( $ account , $ nickname ) { $ params = [ 'kf_account' => $ account , 'nickname' => $ nickname , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CREATE , $ params ] ) ; }
7765	private function documentClassProperties ( \ ML \ HydraBundle \ Mapping \ ClassMetadata $ class ) { $ result = array ( ) ; $ propertyDomain = $ this -> getTypeReferenceIri ( $ class -> getName ( ) ) ; foreach ( $ class -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( '@' , $ property -> getExposeAs ( ) , 1 ) ) { continue ; } $ result [ ] = array ( 'property' => ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : array ( '@id' => 'vocab:' . $ property -> getIri ( ) , '@type' => ( $ property -> getRoute ( ) ) ? 'hydra:Link' : 'rdf:Property' , 'label' => $ property -> getTitle ( ) , 'description' => $ property -> getDescription ( ) , 'domain' => $ propertyDomain , 'range' => $ this -> getTypeReferenceIri ( $ property -> getType ( ) ) , 'supportedOperation' => $ this -> documentOperations ( $ property -> getOperations ( ) ) ) , 'hydra:title' => $ property -> getTitle ( ) , 'hydra:description' => $ property -> getDescription ( ) , 'required' => $ property -> getRequired ( ) , 'readonly' => $ property -> isReadOnly ( ) , 'writeonly' => $ property -> isWriteOnly ( ) ) ; } return $ result ; }
8802	public function get ( $ key = null ) { return ( is_null ( $ key ) ? $ _SESSION : ( $ this -> has ( $ key ) ? $ _SESSION [ $ key ] : null ) ) ; }
1590	protected function invokeMany ( iterable $ hooks , ... $ arguments ) { foreach ( $ hooks as $ hook ) { $ result = $ this -> invoke ( $ hook , ... $ arguments ) ; if ( ! is_null ( $ result ) ) { return $ result ; } } return null ; }
8221	protected function getEntityId ( $ blockType , $ config , $ params = array ( ) ) { $ entityId = null ; if ( $ blockType === "account" && isset ( $ params [ "name" ] ) ) { $ entityId = md5 ( $ params [ "name" ] ) ; } elseif ( $ blockType === "email" && isset ( $ params [ "email" ] ) ) { $ entityId = md5 ( $ params [ "email" ] ) ; } elseif ( $ blockType === "ip" ) { $ entityId = $ this -> getIp ( $ config ) ; } return $ entityId ; }
7840	public function addNumber ( int $ id , string $ number ) : ? array { $ response = Request :: put ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
10370	public static function add ( $ type , $ data = [ ] ) { $ is_admin = is_admin ( ) ; if ( self :: validate ( $ type , $ data , $ is_admin ) ) { $ hook = $ is_admin ? 'admin_enqueue_scripts' : 'wp_enqueue_scripts' ; $ method = __CLASS__ . "::add_{$type}s" ; if ( has_action ( $ hook , $ method ) === false ) { add_action ( $ hook , $ method ) ; } return true ; } return false ; }
1179	protected function getValidationData ( array $ rules , array $ customAttributes = [ ] ) { $ attributes = array_filter ( array_keys ( $ rules ) , function ( $ attribute ) { return $ attribute !== '' && mb_strpos ( $ attribute , '*' ) !== false ; } ) ; $ attributes = array_merge ( array_keys ( $ customAttributes ) , $ attributes ) ; $ data = array_reduce ( $ attributes , function ( $ data , $ attribute ) { Arr :: set ( $ data , $ attribute , true ) ; return $ data ; } , [ ] ) ; return $ data ; }
9641	public function validate ( $ validator ) { $ this -> value = trim ( $ this -> value ) ; $ regex = $ this -> config [ 'validregex' ] ; if ( $ this -> value && $ regex && ! preg_match ( $ regex , $ this -> value ) ) { $ validator -> validationError ( $ this -> name , _t ( 'ExternalURLField.VALIDATION' , "Please enter a valid URL" ) , "validation" ) ; return false ; } return true ; }
3747	protected function extractSorting ( $ config ) { $ sorting = $ config -> getSorting ( ) ; $ sortBy = key ( $ sorting ) ; $ sortDir = current ( $ sorting ) ? : DCGE :: MODEL_SORTING_ASC ; return array ( $ sortBy , $ sortDir ) ; }
1653	public function getArea ( ) : float { $ area = 0 ; if ( $ this -> getNumberOfPoints ( ) <= 2 ) { return $ area ; } $ referencePoint = $ this -> points [ 0 ] ; $ radius = $ referencePoint -> getEllipsoid ( ) -> getArithmeticMeanRadius ( ) ; $ segments = $ this -> getSegments ( ) ; foreach ( $ segments as $ segment ) { $ point1 = $ segment -> getPoint1 ( ) ; $ point2 = $ segment -> getPoint2 ( ) ; $ x1 = deg2rad ( $ point1 -> getLng ( ) - $ referencePoint -> getLng ( ) ) * cos ( deg2rad ( $ point1 -> getLat ( ) ) ) ; $ y1 = deg2rad ( $ point1 -> getLat ( ) - $ referencePoint -> getLat ( ) ) ; $ x2 = deg2rad ( $ point2 -> getLng ( ) - $ referencePoint -> getLng ( ) ) * cos ( deg2rad ( $ point2 -> getLat ( ) ) ) ; $ y2 = deg2rad ( $ point2 -> getLat ( ) - $ referencePoint -> getLat ( ) ) ; $ area += ( $ x2 * $ y1 - $ x1 * $ y2 ) ; } $ area *= 0.5 * $ radius ** 2 ; return ( float ) abs ( $ area ) ; }
5717	public function doPublishAndAdd ( $ data , $ form ) { return $ this -> publish ( $ data , $ form , $ this -> owner , $ this -> owner -> Link ( 'addnew' ) ) ; }
11377	public function getAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)(\/(\w+))?$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } $ pageName = $ matches [ 1 ] ; $ language = $ matches [ 2 ] ; $ pageTexts = $ this -> getTextModel ( $ pageName ) ; if ( empty ( $ matches [ 4 ] ) ) { $ result = array_values ( $ pageTexts -> getTextsWithBaseTexts ( $ language ) ) ; } else { $ result = $ pageTexts -> getText ( $ matches [ 4 ] , $ language ) ; } $ this -> environment -> sendJSONResult ( $ result ) ; }
3911	protected function fetchAdditionalData ( ) { $ this -> modifiedTime = array ( ) ; $ this -> outputBuffer = array ( ) ; if ( ! $ this -> foundFiles ) { return ; } foreach ( $ this -> foundFiles as $ strFile ) { $ this -> processFile ( $ strFile ) ; } }
592	public function combineJsFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; foreach ( $ inputFiles as $ file ) { $ fileContent = rtrim ( file_get_contents ( $ file ) ) ; if ( substr ( $ fileContent , - 1 ) !== ';' ) { $ fileContent .= "\n;" ; } $ content .= "/*** BEGIN FILE: $file ***/\n" . $ fileContent . "\n" . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output JavaScript file '{$outputFile}'." ) ; } }
653	protected function getCacheKey ( $ method , $ fetchMode , $ rawSql ) { return [ __CLASS__ , $ method , $ fetchMode , $ this -> db -> dsn , $ this -> db -> username , $ rawSql , ] ; }
7211	public function validateLoginToken ( string $ token ) : ? array { $ token = base64_decode ( $ token ) ; $ serializedData = Security :: decrypt ( $ token , $ this -> getKey ( ) , $ this -> getSalt ( ) ) ; if ( $ serializedData === false ) { return null ; } $ data = unserialize ( $ serializedData ) ; if ( ! empty ( $ data [ 'expireInterval' ] ) && ! empty ( $ data [ 'timestamp' ] ) ) { $ tokenCreated = new Time ( $ data [ 'timestamp' ] ) ; if ( ! $ tokenCreated -> wasWithinLast ( $ data [ 'expireInterval' ] ) ) { return null ; } } return $ data ; }
12309	public function resetPasswordAction ( ) { if ( $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getDefaultUserRoute ( ) ) ; } if ( $ token = $ this -> params ( ) -> fromRoute ( 'token' ) ) { $ identity = $ this -> getUserService ( ) -> confirmPasswordReset ( $ token ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-success' ) ; return $ viewModel ; } return $ this -> redirect ( ) -> toRoute ( ) ; } $ url = $ this -> url ( ) -> fromRoute ( ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getResetPasswordForm ( ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ identity = $ this -> getUserService ( ) -> resetPassword ( $ form -> get ( 'identity' ) -> getValue ( ) ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-warning' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
3391	public function confirm ( $ confirmation_code ) { $ model = $ this -> guard ( ) -> getProvider ( ) -> createModel ( ) ; $ user = $ model -> where ( 'confirmation_code' , $ confirmation_code ) -> firstOrFail ( ) ; $ user -> confirmation_code = null ; $ user -> confirmed_at = now ( ) ; $ user -> save ( ) ; event ( new Confirmed ( $ user ) ) ; return $ this -> confirmed ( $ user ) ? : redirect ( $ this -> redirectAfterConfirmationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_successful' ) ) ; }
9758	function closeTo ( $ value , float $ delta ) : self { return $ this -> expect ( $ this -> target , equalTo ( $ value , $ delta ) ) ; }
9354	public function subMatrix ( $ int_m , $ int_n ) { $ sm = new self ( $ this -> size -> rows - 1 , $ this -> size -> cols - 1 ) ; foreach ( $ this -> arr as $ m => $ row ) { if ( $ m != $ int_m ) { $ arr_row = array ( ) ; foreach ( $ row as $ n => $ v ) { if ( $ n != $ int_n ) { $ arr_row [ ] = $ v ; } } $ sm -> addRow ( $ arr_row ) ; } } return $ sm ; }
8944	public function getDetails ( ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/details' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'GET' , $ parameters ) ; return $ response -> body ; }
9244	private function __loadConfigFiles ( ) { $ additionalConfigs = $ this -> config ( 'additionalConfigFiles' ) ; foreach ( $ additionalConfigs as $ additionalConfig ) { Configure :: load ( $ additionalConfig ) ; } }
5724	protected function getToplevelController ( ) { $ c = $ this -> owner -> getController ( ) ; while ( $ c && $ c instanceof GridFieldDetailForm_ItemRequest ) { $ c = $ c -> getController ( ) ; } return $ c ; }
5524	public function generatePartial ( $ methods ) { if ( ! $ this -> reflection -> classExists ( $ this -> class ) ) { return false ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { trigger_error ( 'Partial mock class [' . $ this -> mock_class . '] already exists' ) ; return false ; } $ code = $ this -> extendClassCode ( $ methods ) ; return eval ( "$code return \$code;" ) ; }
10726	public function getUsers ( ) { $ select = $ this -> tableGateway -> getSql ( ) -> select ( ) ; $ select -> columns ( [ "fullname" => new Expression ( "DISTINCT(CONCAT(usr_firstname, ' ', usr_lastname))" ) ] ) ; $ select -> join ( 'melis_core_user' , 'melis_core_user.usr_id = melis_hist_page_historic.hist_user_id' , [ ] , $ select :: JOIN_INNER ) ; $ resultSet = $ this -> tableGateway -> selectWith ( $ select ) ; return $ resultSet ; }
2044	public static function create ( array $ parameters ) : ? Connection { $ params = [ 'driver' => 'pdo_mysql' , 'host' => $ parameters [ 'parameters' ] [ 'database_host' ] , 'port' => $ parameters [ 'parameters' ] [ 'database_port' ] , 'user' => $ parameters [ 'parameters' ] [ 'database_user' ] , 'password' => $ parameters [ 'parameters' ] [ 'database_password' ] , 'dbname' => $ parameters [ 'parameters' ] [ 'database_name' ] , ] ; try { return DriverManager :: getConnection ( $ params ) ; } catch ( DBALException $ e ) { } return null ; }
11461	public static function enable ( $ state = true , $ enable_assert = false ) { $ state = ( bool ) $ state ; self :: enableAssert ( ( bool ) $ enable_assert ) ; if ( $ state && self :: $ _enabled || ! $ state && ! self :: $ _enabled ) { return ; } if ( $ state ) { set_exception_handler ( __CLASS__ . '::exception' ) ; set_error_handler ( __CLASS__ . '::error' , error_reporting ( ) ) ; assert_options ( ASSERT_CALLBACK , __CLASS__ . '::assert' ) ; self :: $ _enabled = true ; } else { restore_exception_handler ( ) ; restore_error_handler ( ) ; assert_options ( ASSERT_CALLBACK , function ( ) { } ) ; self :: $ _enabled = false ; } }
6363	public function start ( $ name ) : Profiler { if ( ! $ this -> globalStopwatch -> isRunning ( ) ) { $ this -> globalStopwatch -> start ( ) ; } if ( $ this -> entryStopwatch -> isRunning ( ) ) { $ this -> recordEntry ( ) ; } $ this -> currentName = $ name ; $ this -> entryStopwatch -> start ( ) ; return $ this ; }
5270	private function translateUpdate ( ) { $ build = array ( "update {$this->table} set" ) ; $ values = array ( ) ; foreach ( $ this -> statements [ 'values' ] as $ key => $ value ) { $ values [ ] = $ key . ' = ' . $ this -> esc_value ( $ value ) ; } if ( ! empty ( $ values ) ) { $ build [ ] = join ( ', ' , $ values ) ; } if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
7083	public function method ( $ method = NULL ) { if ( $ method === NULL ) { return $ this -> _method ; } $ this -> _method = strtoupper ( $ method ) ; return $ this ; }
1274	private function createRequestLandedCost ( LandedCostRequest $ landedCostRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ tradeabilityRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LandedCostRequest' ) ) ; $ tradeabilityRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ tradeabilityRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LandedCost' ) ) ; if ( $ landedCostRequest -> getQueryRequest ( ) !== null ) { $ tradeabilityRequest -> appendChild ( $ landedCostRequest -> getQueryRequest ( ) -> toNode ( $ xml ) ) ; } return $ xml -> saveXML ( ) ; }
1883	public static function find ( array $ arrOptions ) { $ objBase = DcaExtractor :: getInstance ( $ arrOptions [ 'table' ] ) ; if ( ! $ objBase -> hasRelations ( ) ) { $ strQuery = "SELECT * FROM " . $ arrOptions [ 'table' ] ; } else { $ arrJoins = array ( ) ; $ arrFields = array ( $ arrOptions [ 'table' ] . ".*" ) ; $ intCount = 0 ; foreach ( $ objBase -> getRelations ( ) as $ strKey => $ arrConfig ) { if ( $ arrConfig [ 'load' ] == 'eager' || $ arrOptions [ 'eager' ] ) { if ( $ arrConfig [ 'type' ] == 'hasOne' || $ arrConfig [ 'type' ] == 'belongsTo' ) { ++ $ intCount ; $ objRelated = DcaExtractor :: getInstance ( $ arrConfig [ 'table' ] ) ; foreach ( array_keys ( $ objRelated -> getFields ( ) ) as $ strField ) { $ arrFields [ ] = 'j' . $ intCount . '.' . Database :: quoteIdentifier ( $ strField ) . ' AS ' . $ strKey . '__' . $ strField ; } $ arrJoins [ ] = " LEFT JOIN " . $ arrConfig [ 'table' ] . " j$intCount ON " . $ arrOptions [ 'table' ] . "." . Database :: quoteIdentifier ( $ strKey ) . "=j$intCount." . $ arrConfig [ 'field' ] ; } } } $ strQuery = "SELECT " . implode ( ', ' , $ arrFields ) . " FROM " . $ arrOptions [ 'table' ] . implode ( "" , $ arrJoins ) ; } if ( isset ( $ arrOptions [ 'column' ] ) ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } if ( isset ( $ arrOptions [ 'group' ] ) ) { $ strQuery .= " GROUP BY " . $ arrOptions [ 'group' ] ; } if ( isset ( $ arrOptions [ 'having' ] ) ) { $ strQuery .= " HAVING " . $ arrOptions [ 'having' ] ; } if ( isset ( $ arrOptions [ 'order' ] ) ) { $ strQuery .= " ORDER BY " . $ arrOptions [ 'order' ] ; } return $ strQuery ; }
11218	public static function dispatch ( ) { self :: routeValidator ( ) ; self :: $ routes = str_replace ( '//' , '/' , self :: $ routes ) ; if ( in_array ( self :: $ uri , self :: $ routes , true ) ) { return self :: checkRoutes ( ) ; } if ( self :: checkRegexRoutes ( ) !== false ) { return self :: checkRegexRoutes ( ) ; } return self :: getErrorCallback ( ) ; }
1754	public static function getLanguages ( $ blnInstalledOnly = false ) { $ return = array ( ) ; $ languages = array ( ) ; $ arrAux = array ( ) ; $ langsNative = array ( ) ; static :: loadLanguageFile ( 'languages' ) ; include __DIR__ . '/../../config/languages.php' ; foreach ( $ languages as $ strKey => $ strName ) { $ arrAux [ $ strKey ] = isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) ? Utf8 :: toAscii ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) : $ strName ; } asort ( $ arrAux ) ; $ arrBackendLanguages = self :: getContainer ( ) -> getParameter ( 'contao.locales' ) ; foreach ( array_keys ( $ arrAux ) as $ strKey ) { if ( $ blnInstalledOnly && ! \ in_array ( $ strKey , $ arrBackendLanguages ) ) { continue ; } $ return [ $ strKey ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ?? $ languages [ $ strKey ] ; if ( isset ( $ langsNative [ $ strKey ] ) && $ langsNative [ $ strKey ] != $ return [ $ strKey ] ) { $ return [ $ strKey ] .= ' - ' . $ langsNative [ $ strKey ] ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ return , $ languages , $ langsNative , $ blnInstalledOnly ) ; } } return $ return ; }
5970	public function accounts ( ) { if ( ! $ this -> accounts instanceof AccountsController ) { $ this -> accounts = new AccountsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> accounts -> setLogger ( $ this -> logger ) ; } return $ this -> accounts ; }
6506	public function serializeReturnValue ( $ type , $ value ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> serialize ( $ value , 'json' , $ this -> getResponseSerializationContext ( $ jobType ) ) ; }
3897	public function pagePicker ( ManipulateWidgetEvent $ event ) { if ( ! $ this -> scopeDeterminator -> currentScopeIsBackend ( ) || ! ( 'tl_metamodel_rendersettings' === $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ! ( ( 0 === strpos ( $ event -> getProperty ( ) -> getName ( ) , 'jumpTo' ) ) && ( '[value]' === substr ( $ event -> getProperty ( ) -> getName ( ) , - \ strlen ( '[value]' ) ) ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ pickerUrl = $ this -> pickerBuilder -> getUrl ( 'cca_link' ) ; $ urlEvent = new GenerateHtmlEvent ( 'pickpage.svg' , $ environment -> getTranslator ( ) -> translate ( 'MSC.pagepicker' ) , 'style="vertical-middle:top;cursor:pointer"' ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: IMAGE_GET_HTML , $ urlEvent ) ; $ template = new ContaoBackendViewTemplate ( 'dc_general_wizard_link_url_picker' ) ; $ template -> set ( 'name' , $ event -> getWidget ( ) -> name ) -> set ( 'popupUrl' , $ pickerUrl ) -> set ( 'html' , ' ' . $ urlEvent -> getHtml ( ) ) -> set ( 'label' , $ event -> getProperty ( ) -> getLabel ( ) [ 1 ] ) -> set ( 'id' , $ event -> getWidget ( ) -> id ) ; $ event -> getWidget ( ) -> wizard = $ template -> parse ( ) ; }
962	public function buildAuthUrl ( $ mode = null ) { return $ this -> api -> getAuthUrl ( Config :: get ( 'shopify-app.api_scopes' ) , URL :: secure ( Config :: get ( 'shopify-app.api_redirect' ) ) , $ mode ?? 'offline' ) ; }
1041	public function wait ( Promise $ promise ) { $ this -> beforeWait ( $ promise ) ; $ dfdQueue = Deferred :: getQueue ( ) ; $ promiseQueue = SyncPromise :: getQueue ( ) ; while ( $ promise -> adoptedPromise -> state === SyncPromise :: PENDING && ! ( $ dfdQueue -> isEmpty ( ) && $ promiseQueue -> isEmpty ( ) ) ) { Deferred :: runQueue ( ) ; SyncPromise :: runQueue ( ) ; $ this -> onWait ( $ promise ) ; } $ syncPromise = $ promise -> adoptedPromise ; if ( $ syncPromise -> state === SyncPromise :: FULFILLED ) { return $ syncPromise -> result ; } if ( $ syncPromise -> state === SyncPromise :: REJECTED ) { throw $ syncPromise -> result ; } throw new InvariantViolation ( 'Could not resolve promise' ) ; }
5088	public function queryMap ( $ key = 0 , $ value = 1 ) { $ fetchMode = $ this -> resolveFetchMode ( is_string ( $ key ) || is_string ( $ value ) ) ; $ result = $ this -> execute ( ) ; $ map = [ ] ; try { while ( $ row = $ result -> fetch ( $ fetchMode ) ) { if ( ! isset ( $ row [ $ key ] ) || ! key_exists ( $ value , $ row ) ) throw new MySqlException ( "Key '$key' or Value '$value' columns not found in the query result: " . implode ( array_keys ( $ row ) ) ) ; $ map [ $ row [ $ key ] ] = $ row [ $ value ] ; } } finally { $ result -> closeCursor ( ) ; } return $ map ; }
1693	protected function convertHexColor ( $ color , $ blnWriteToFile = false , $ vars = array ( ) ) { if ( strncmp ( $ color , '$' , 1 ) === 0 ) { if ( ! $ blnWriteToFile ) { return array ( $ color ) ; } else { $ color = str_replace ( array_keys ( $ vars ) , $ vars , $ color ) ; } } $ rgb = array ( ) ; if ( \ strlen ( $ color ) == 6 ) { $ dec = hexdec ( $ color ) ; $ rgb [ 'red' ] = 0xFF & ( $ dec >> 0x10 ) ; $ rgb [ 'green' ] = 0xFF & ( $ dec >> 0x8 ) ; $ rgb [ 'blue' ] = 0xFF & $ dec ; } elseif ( \ strlen ( $ color ) == 3 ) { $ rgb [ 'red' ] = hexdec ( str_repeat ( substr ( $ color , 0 , 1 ) , 2 ) ) ; $ rgb [ 'green' ] = hexdec ( str_repeat ( substr ( $ color , 1 , 1 ) , 2 ) ) ; $ rgb [ 'blue' ] = hexdec ( str_repeat ( substr ( $ color , 2 , 1 ) , 2 ) ) ; } return $ rgb ; }
10896	public function setHost ( $ host ) { foreach ( $ this -> uris as $ name => $ uri ) { $ this -> add ( $ name , $ uri -> withHost ( $ host ) ) ; } }
11470	public function store ( ResponseRequest $ request ) { try { $ request = $ request -> all ( ) ; $ slug = $ request [ 'slug' ] ; $ attributes [ 'comment' ] = $ request [ 'comment' ] ; $ attributes [ 'question_id' ] = $ request [ 'question_id' ] ; $ attributes [ 'user_id' ] = user_id ( ) ; $ attributes [ 'user_type' ] = user_type ( ) ; $ response = $ this -> repository -> create ( $ attributes ) ; return $ this -> response -> message ( trans ( 'messages.success.created' , [ 'Module' => trans ( 'forum::response.name' ) ] ) ) -> code ( 204 ) -> status ( 'success' ) -> url ( trans_url ( '/discussion/' . $ slug ) ) -> redirect ( ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( trans_url ( '/question/' . $ slug ) ) -> redirect ( ) ; } }
8725	public function translationModel ( ) { $ translation = new TranslationModel ( ) ; $ translation -> setConnection ( $ this -> getI18nConnection ( ) ) ; $ translation -> setTable ( $ this -> getI18nTable ( ) ) ; $ translation -> setKeyName ( $ this -> getForeignKey ( ) ) ; $ translation -> setLocaleKey ( $ this -> getLocaleKey ( ) ) ; if ( $ attributes = $ this -> translatableAttributes ( ) ) { $ translation -> fillable ( array_intersect ( $ attributes , $ this -> getFillable ( ) ) ) ; } return $ translation ; }
7368	protected function checkShipmentIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ sale = $ item -> getSale ( ) ; if ( ! $ sale instanceof Shipment \ ShipmentSubjectInterface ) { return ; } if ( empty ( $ sale -> getShipments ( ) -> toArray ( ) ) ) { return ; } $ min = $ this -> shipmentCalculator -> calculateShippedQuantity ( $ item ) ; if ( 1 === bccomp ( $ min , 0 , 3 ) && 1 === bccomp ( $ min , $ item -> getTotalQuantity ( ) , 3 ) ) { $ this -> context -> buildViolation ( $ constraint -> quantity_is_lower_than_shipped , [ '%min%' => $ min , ] ) -> setInvalidValue ( $ item -> getQuantity ( ) ) -> atPath ( 'quantity' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
2707	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ response = $ this -> api -> getResponse ( $ activeVersion , Config :: WAF_PAGE_RESPONSE_OBJECT ) ; if ( ! $ response ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch WAF page Response object.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'wafPageResp' => $ response ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
9778	function writable ( ) : self { if ( ! $ this -> hasFlag ( 'directory' ) && ! $ this -> hasFlag ( 'file' ) ) throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , isWritable ( ) ) ; }
9029	public function error ( Request $ request ) { $ this -> response -> setCode ( 404 ) ; printf ( "<h2>%s</h2>" , HttpStatus :: getStatus ( 404 ) ) ; printf ( "Requested document %s on %s could not be found!" , $ request -> getAction ( ) , $ request -> getController ( ) ) ; }
7676	function TbsQuickLoad ( $ NameLst ) { if ( ! is_array ( $ NameLst ) ) $ NameLst = array ( $ NameLst ) ; $ nbr = 0 ; $ TBS = & $ this -> TBS ; foreach ( $ NameLst as $ FileName ) { $ idx = $ this -> FileGetIdx ( $ FileName ) ; if ( ( ! isset ( $ this -> TbsStoreLst [ $ idx ] ) ) && ( ! isset ( $ this -> TbsNoField [ $ idx ] ) ) ) { $ txt = $ this -> FileRead ( $ idx , true ) ; if ( strpos ( $ txt , $ TBS -> _ChrOpen ) !== false ) { $ nbr ++ ; if ( $ nbr == 1 ) { $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ SaveIdx = $ this -> TbsCurrIdx ; $ SaveName = $ TBS -> OtbsCurrFile ; $ this -> TbsSwitchMode ( true ) ; } $ this -> TbsStorePark ( ) ; $ TBS -> Source = $ txt ; unset ( $ txt ) ; $ TBS -> OtbsCurrFile = $ FileName ; $ this -> TbsCurrIdx = $ idx ; if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } else { $ this -> TbsNoField [ $ idx ] = true ; } } } if ( $ nbr > 0 ) { $ this -> TbsSwitchMode ( false ) ; $ this -> TbsStorePark ( ) ; $ this -> TbsStoreLoad ( $ SaveIdx , $ SaveName ) ; } return $ nbr ; }
7418	protected function setJSONContent ( array $ content ) { if ( $ this -> deleteJsonKeys ) { $ content = $ this -> deleteArrayKeys ( $ content ) ; } $ content = json_encode ( $ content , JSON_UNESCAPED_UNICODE ) ; $ this -> response -> setContentTypeJson ( ) ; $ this -> response -> setContent ( $ content ) ; }
10146	private function readStyle ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ ixfe = self :: getUInt2d ( $ recordData , 0 ) ; $ xfIndex = ( 0x0FFF & $ ixfe ) >> 0 ; $ isBuiltIn = ( bool ) ( ( 0x8000 & $ ixfe ) >> 15 ) ; if ( $ isBuiltIn ) { $ builtInId = ord ( $ recordData [ 2 ] ) ; switch ( $ builtInId ) { case 0x00 : break ; default : break ; } } } }
11177	public function create ( ? string $ name = null ) { Whois :: print ( $ this -> getNotify ( ) ) ; $ this -> creator -> create ( $ this -> filesystem , $ name ) ; }
8668	public function setSelf ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Self' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12715	protected function circularDependencyResolver ( $ class ) { if ( ! is_string ( $ class ) && ! class_exists ( $ class ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be a string of valid class name." , __METHOD__ ) ) ; } $ reflector = Internal \ ReflectionClassFactory :: create ( $ class ) ; if ( ! $ this -> hasConstructor ( $ reflector ) ) { return $ this -> resolveInstanceWithoutConstructor ( $ reflector ) ; } else { $ param = $ this -> getMethodParameters ( $ reflector , '__construct' ) ; if ( empty ( $ param ) ) { return $ reflector -> newInstance ( ) ; } else { foreach ( $ param as $ key => $ value ) { $ class = $ value -> getClass ( ) ; if ( $ class instanceof \ ReflectionClass ) { if ( $ class -> isInterface ( ) ) { $ param [ $ key ] = $ this -> getConcreteFromInterface ( $ class -> getName ( ) ) ; } else { $ param [ $ key ] = $ this -> circularDependencyResolver ( $ class -> getName ( ) ) ; } } } return $ reflector -> newInstanceArgs ( $ param ) ; } } }
10577	private static function get ( $ style , $ setting , $ defaultValue = '' ) { if ( isset ( self :: $ styles [ $ style ] ) ) { $ style = self :: $ styles [ $ style ] ; if ( isset ( $ style [ $ setting ] ) ) { return $ style [ $ setting ] ; } } return $ defaultValue ; }
6342	final public static function valueOf ( $ name ) : self { $ className = static :: class ; Preconditions :: checkArgument ( array_key_exists ( $ className , self :: $ cache ) && array_key_exists ( $ name , self :: $ cache [ $ className ] ) , "The enum '%s' type has no constant with name '%s'" , $ className , $ name ) ; return self :: $ cache [ $ className ] [ $ name ] ; }
928	public function delete ( $ path ) { if ( isset ( $ this -> files [ $ path ] ) ) { unset ( $ this -> files [ $ path ] ) ; } $ this -> unlink ( $ path ) ; }
10037	function createCustomField ( $ name , $ type = 'string' ) { $ queryParameters = array ( 'type' => $ type ) ; $ encodedName = urlencode ( mb_convert_encoding ( $ name , "UTF-8" ) ) ; return $ this -> post ( "contacts/fields/custom/${encodedName}" , "" , $ queryParameters ) ; }
7816	public function event ( string $ event ) : self { $ events = [ 'MESSAGE_RECEIVED' , 'MESSAGE_SENT' , 'MESSAGE_FAILED' , ] ; if ( ! in_array ( $ event , $ events ) ) { abort ( 500 , sprintf ( 'Event %s not available.' , $ event ) ) ; } $ this -> event = $ event ; return $ this ; }
11082	public static function GUIDv5 ( $ namespace , $ name ) { if ( ! Validate :: isGuid ( $ namespace ) ) { return false ; } $ nHex = str_replace ( [ '-' , '{' , '}' ] , '' , $ namespace ) ; $ nStr = '' ; $ nHexLen = \ strlen ( $ nHex ) ; for ( $ i = 0 ; $ i < $ nHexLen ; $ i += 2 ) { $ nStr .= \ chr ( \ intval ( $ nHex [ $ i ] . $ nHex [ $ i + 1 ] , 16 ) ) ; } $ hash = sha1 ( $ nStr . $ name ) ; return sprintf ( '%08s-%04s-%04x-%04x-%12s' , substr ( $ hash , 0 , 8 ) , substr ( $ hash , 8 , 4 ) , ( \ intval ( substr ( $ hash , 12 , 4 ) , 16 ) & 0x0fff ) | 0x5000 , ( \ intval ( substr ( $ hash , 16 , 4 ) , 16 ) & 0x3fff ) | 0x8000 , substr ( $ hash , 20 , 12 ) ) ; }
8769	public function bootstrap ( ) { $ this -> hasBeenBootstrapped = true ; $ this [ 'events' ] -> dispatch ( 'bootstrapping' , [ $ this ] ) ; $ this -> boot ( ) ; $ this [ 'events' ] -> dispatch ( 'bootstrapped' , [ $ this ] ) ; }
8224	protected function logRateLimitReached ( $ actionName , $ blockType , $ entityId , $ config ) { $ this -> getLogger ( ) -> notice ( "Rate limit of {cnt} reached: {action} for {entity} ({type})." , array ( 'cnt' => $ config [ "count" ] , 'action' => $ actionName , 'entity' => $ entityId , 'type' => $ blockType ) ) ; }
2091	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ 'form' ] [ 0 ] ) . ' ###' ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> title ; $ objTemplate -> href = 'contao/main.php?do=form&amp;table=tl_form_field&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> customTpl != '' && TL_MODE == 'FE' ) { $ this -> strTemplate = $ this -> customTpl ; } return parent :: generate ( ) ; }
2722	public function aroundSendPurgeRequest ( PurgeCache $ subject , callable $ proceed , ... $ args ) { if ( $ this -> config -> isFastlyEnabled ( ) !== true ) { $ proceed ( ... $ args ) ; } }
6632	public function requestAccessToken ( $ code ) { if ( ! $ code || empty ( $ code ) ) { throw new InvalidFacebookCodeException ( ) ; } $ request = [ 'url' => $ this -> settings [ 'token_url' ] , 'params' => [ 'client_id' => $ this -> settings [ 'api_key' ] , 'redirect_uri' => $ this -> settings [ 'redirect_uri' ] , 'client_secret' => $ this -> settings [ 'secret' ] , 'code' => $ code , 'format' => 'json' , ] , ] ; return $ this -> access_token -> make ( $ this -> http -> get ( $ request ) ) ; }
10380	protected static function is_modified_hash ( $ url , $ path ) { if ( self :: is_external_url ( $ url ) ) { if ( sha1_file ( $ url ) !== sha1_file ( $ path ) ) { self :: $ changes = true ; return self :: $ changes ; } } return false ; }
4419	protected function checkPermissions ( ) { if ( $ this -> isGranted ( 'ROLE_NGBM_EDITOR' ) ) { return ; } if ( $ this -> isGranted ( 'nglayouts:ui:access' ) ) { return ; } $ exception = $ this -> createAccessDeniedException ( ) ; $ exception -> setAttributes ( 'nglayouts:ui:access' ) ; throw $ exception ; }
8901	public function update_batch ( $ data , $ where_key ) { $ _data = array ( ) ; foreach ( $ data as $ key => $ row ) { if ( false !== $ row = $ this -> _do_pre_update ( $ row ) ) { $ _data [ $ key ] = $ row ; } } return $ this -> _database -> update_batch ( $ this -> _table , $ _data , $ where_key ) ; }
12022	function addCheckScopeMethod ( ) { $ scopes = $ this -> operationDefinition -> getScopes ( ) ; if ( count ( $ scopes ) == 0 ) { return ; } $ methodGenerator = new MethodGenerator ( 'checkScopeRequirement' ) ; $ parameterGenerator = new ParameterGenerator ( 'allowedScopes' , 'array' ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ body = '//For each of the elements, all of the scopes in that element' . PHP_EOL ; $ body .= '//must be satisfied' . PHP_EOL ; $ body .= '$requiredScopesArray = [' . PHP_EOL ; foreach ( $ scopes as $ scopeList ) { $ body .= ' [' ; $ separator = '' ; foreach ( $ scopeList as $ scope ) { $ body .= sprintf ( "%s'%s'" , $ separator , $ scope ) ; $ separator = ', ' ; } $ body .= ']' . PHP_EOL ; } $ body .= '];' . PHP_EOL . PHP_EOL ; $ body .= <<< 'END'foreach($requiredScopesArray as $requiredScopes) { $requirementMet = true; foreach ($requiredScopes as $requiredScope) { if (in_array($requiredScope, $allowedScopes) == false) { $requirementMet = false; break; } } if ($requirementMet == true) { return true; }}return false;END ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
1518	public function replaceRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doReplaceRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
11781	public function fromEntityToDb ( $ document ) { $ unitOfWork = $ this -> documentManager -> getUnitOfWork ( ) ; $ persistenceBuilder = new PersistenceBuilder ( $ this -> documentManager , $ unitOfWork ) ; $ mapping = array ( 'targetDocument' => $ this -> documentClass , ) ; return $ persistenceBuilder -> prepareEmbeddedDocumentValue ( $ mapping , $ document , true ) ; }
9536	private function prefixExists ( $ parameter ) { $ prefixExists = false ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { $ prefixExists = true ; break ; } } return $ prefixExists ; }
4893	protected function array_compare ( $ array1 , $ array2 , $ maxDepth = 2 ) { $ result = array ( ) ; $ arraykeys = array_unique ( array_merge ( array_keys ( $ array1 ) , array_keys ( $ array2 ) ) ) ; foreach ( $ arraykeys as $ key ) { if ( ! empty ( $ key ) && is_string ( $ key ) && $ key [ 0 ] != "\0" && substr ( $ key , 0 , 8 ) != 'Doctrine' ) { if ( array_key_exists ( $ key , $ array1 ) && ! array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , '' ) ; } if ( ! array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( '' , $ array2 [ $ key ] ) ; } if ( array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ subResult = null ; if ( is_array ( $ array1 [ $ key ] ) && is_array ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ subResult = $ this -> array_compare ( $ array1 [ $ key ] , $ array2 [ $ key ] , $ maxDepth - 1 ) ; } } elseif ( is_object ( $ array1 [ $ key ] ) && is_object ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ hydrator = new EntityHydrator ( ) ; $ a1 = $ hydrator -> extract ( $ array1 [ $ key ] ) ; $ a2 = $ hydrator -> extract ( $ array2 [ $ key ] ) ; $ subResult = $ this -> array_compare ( $ a1 , $ a2 , $ maxDepth - 1 ) ; } } else { if ( $ array1 [ $ key ] != $ array2 [ $ key ] ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , $ array2 [ $ key ] ) ; } } if ( ! empty ( $ subResult ) ) { foreach ( $ subResult as $ subKey => $ subValue ) { if ( ! empty ( $ subKey ) && is_string ( $ subKey ) ) { $ result [ $ key . '.' . $ subKey ] = $ subValue ; } } } } } } return $ result ; }
10670	protected static function _fromArray ( $ dom , $ node , & $ data , $ format ) { if ( $ data === null || $ data === '' || ! \ is_array ( $ data ) ) { return ; } foreach ( $ data as $ key => $ value ) { if ( \ is_string ( $ key ) ) { if ( ! \ is_array ( $ value ) ) { if ( \ is_bool ( $ value ) ) { $ value = ( int ) $ value ; } elseif ( $ value === null ) { $ value = '' ; } $ isNamespace = strpos ( $ key , 'xmlns:' ) ; if ( $ isNamespace !== false ) { $ node -> setAttributeNS ( 'http://www.w3.org/2000/xmlns/' , $ key , $ value ) ; continue ; } if ( $ key [ 0 ] !== '@' && $ format === 'tags' ) { $ child = null ; if ( ! is_numeric ( $ value ) ) { $ child = $ dom -> createElement ( $ key , '' ) ; $ child -> appendChild ( new \ DOMText ( $ value ) ) ; } else { $ child = $ dom -> createElement ( $ key , $ value ) ; } $ node -> appendChild ( $ child ) ; } else { if ( $ key [ 0 ] === '@' ) { $ key = substr ( $ key , 1 ) ; } $ attribute = $ dom -> createAttribute ( $ key ) ; $ attribute -> appendChild ( $ dom -> createTextNode ( $ value ) ) ; $ node -> appendChild ( $ attribute ) ; } } else { if ( $ key [ 0 ] === '@' ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid array' ) ) ; } if ( array_keys ( $ value ) === range ( 0 , \ count ( $ value ) - 1 ) ) { foreach ( $ value as $ item ) { $ data = compact ( 'dom' , 'node' , 'key' , 'format' ) ; $ data [ 'value' ] = $ item ; self :: _createChild ( $ data ) ; } } else { self :: _createChild ( compact ( 'dom' , 'node' , 'key' , 'value' , 'format' ) ) ; } } } else { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid array' ) ) ; } } }
3280	protected function normalizeConfig ( array $ config ) : array { $ defaultConfig = [ 'dir' => getcwd ( ) , 'ext' => '.dat' , 'gzip' => false , 'cache' => true , 'formatter' => null , 'swap_memory_limit' => 2097152 , ] ; return array_replace ( $ defaultConfig , $ config ) ; }
5846	public function syslog ( $ message , $ severity = \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK ) { switch ( $ severity ) { case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: NOTICE : $ severity = GeneralUtility :: SYSLOG_SEVERITY_NOTICE ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: INFO : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: WARNING : $ severity = GeneralUtility :: SYSLOG_SEVERITY_WARNING ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR : $ severity = GeneralUtility :: SYSLOG_SEVERITY_ERROR ; break ; } GeneralUtility :: sysLog ( $ message , 'image_autoresize' , $ severity ) ; }
9739	public function setFitToWidth ( $ pValue , $ pUpdate = true ) { $ this -> fitToWidth = $ pValue ; if ( $ pUpdate ) { $ this -> fitToPage = true ; } return $ this ; }
6435	public function completeLogin ( $ extrainputs = array ( ) ) { if ( ! isset ( $ extrainputs [ 'oauth_token' ] ) || $ extrainputs [ 'oauth_token' ] == '' ) { throw new \ Exception ( 'Xing oauth. Somethign went wrong. No token in the session' ) ; } $ credentials = array ( 'identifier' => $ this -> options [ 'consumer_key' ] , 'secret' => $ this -> options [ 'consumer_secret' ] ) ; $ server = new \ League \ OAuth1 \ Client \ Server \ Xing ( $ credentials ) ; $ this -> access_token = $ server -> getTokenCredentials ( $ this -> temp_credentials , $ extrainputs [ 'oauth_token' ] , $ extrainputs [ 'oauth_verifier' ] ) ; return $ this -> getUserProfile ( ) ; }
4013	protected function calculate ( ) { if ( ! $ this -> isDirty ( ) ) { return ; } $ this -> isDirty = false ; $ this -> calculatedOffset = null ; $ this -> calculatedLimit = null ; if ( $ this -> isLimited ( ) ) { if ( $ this -> getLimit ( ) ) { $ this -> calculatedLimit = $ this -> getLimit ( ) ; } if ( $ this -> getOffset ( ) ) { $ this -> calculatedOffset = $ this -> getOffset ( ) ; } } if ( $ this -> getPerPage ( ) > 0 ) { $ this -> calculatePaginated ( ) ; return ; } if ( $ this -> calculatedLimit === null ) { $ this -> calculatedLimit = 0 ; } if ( $ this -> calculatedOffset === null ) { $ this -> calculatedOffset = 0 ; } }
23	public function removePackage ( PackageInterface $ package ) { $ packageId = $ package -> getUniqueName ( ) ; foreach ( $ this -> getPackages ( ) as $ key => $ repoPackage ) { if ( $ packageId === $ repoPackage -> getUniqueName ( ) ) { array_splice ( $ this -> packages , $ key , 1 ) ; return ; } } }
6199	protected function transformParam ( $ param , $ k ) { if ( isset ( $ this -> routeMapParse [ $ k ] [ $ param ] ) and ! is_array ( $ this -> routeMapParse [ $ k ] [ $ param ] ) ) { return $ this -> routeMapParse [ $ k ] [ $ param ] ; } else { return '(.+?)' ; } }
9618	public function registerStackMiddleware ( $ class ) { if ( func_num_args ( ) === 0 ) { throw new \ InvalidArgumentException ( "Missing argument(s) when calling registerStackMiddlerware" ) ; } if ( ! class_exists ( $ class ) && ! is_callable ( $ class ) ) { throw new \ InvalidArgumentException ( "{$class} not found or not callable" ) ; } call_user_func_array ( [ $ this -> builder , "push" ] , func_get_args ( ) ) ; }
4785	function offsetExists ( $ key ) { $ this -> access ( $ key ) ; $ return = array_key_exists ( $ key , $ this -> row ) ; if ( ! $ return ) { $ this -> access ( $ key , true ) ; } return $ return ; }
834	private function getFunctionyTokenKinds ( ) { static $ tokens = [ T_ARRAY , T_ECHO , T_EMPTY , T_EVAL , T_EXIT , T_INCLUDE , T_INCLUDE_ONCE , T_ISSET , T_LIST , T_PRINT , T_REQUIRE , T_REQUIRE_ONCE , T_UNSET , T_VARIABLE , ] ; return $ tokens ; }
6829	protected function prioritizeAssignment ( Stock \ StockAssignmentInterface $ assignment ) { if ( $ assignment -> isFullyShipped ( ) || $ assignment -> isFullyShippable ( ) ) { return false ; } if ( 0 >= $ quantity = $ assignment -> getSoldQuantity ( ) - $ assignment -> getShippableQuantity ( ) ) { return false ; } $ changed = false ; $ helper = new PrioritizeHelper ( $ this -> unitResolver ) ; $ sourceUnit = $ assignment -> getStockUnit ( ) ; $ candidates = $ helper -> getUnitCandidates ( $ assignment , $ quantity ) ; foreach ( $ candidates as $ candidate ) { $ targetUnit = $ candidate -> unit ; if ( ( 0 < $ quantity - $ targetUnit -> getReservableQuantity ( ) ) && ( $ combination = $ candidate -> combination ) ) { foreach ( $ combination -> map as $ id => $ qty ) { if ( null === $ a = $ candidate -> getAssignmentById ( $ id ) ) { throw new StockLogicException ( "Assignment not found." ) ; } $ this -> moveAssignment ( $ a , $ sourceUnit , min ( $ qty , $ quantity ) ) ; } } $ delta = min ( $ quantity , $ targetUnit -> getReservableQuantity ( ) ) ; $ quantity -= $ this -> moveAssignment ( $ assignment , $ targetUnit , $ delta ) ; $ changed = true ; if ( 0 >= $ quantity ) { break ; } } return $ changed ; }
6489	private function addHeaderValue ( HttpHeaders $ headers , string $ name , $ value , bool $ append ) : void { $ decodedValue = trim ( ( string ) ( isset ( self :: $ headersToUrlDecode [ $ name ] ) ? urldecode ( $ value ) : $ value ) ) ; if ( isset ( self :: $ specialCaseHeaders [ $ name ] ) ) { $ headers -> add ( $ name , $ decodedValue , $ append ) ; } elseif ( strpos ( $ name , 'HTTP_' ) === 0 ) { $ normalizedName = substr ( $ name , 5 ) ; $ headers -> add ( $ normalizedName , $ decodedValue , $ append ) ; } }
8558	public function setFinancialEventGroupList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FinancialEventGroupList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5048	protected function callPlugin ( $ name , $ args ) { $ controller = $ this -> getController ( ) ; $ plugin = $ controller -> plugin ( $ name ) ; unset ( $ args [ 'as' ] ) ; array_push ( $ args , $ this -> parameters ) ; return call_user_func_array ( $ plugin , $ args ) ; }
541	protected function serializeModelErrors ( $ model ) { $ this -> response -> setStatusCode ( 422 , 'Data Validation Failed.' ) ; $ result = [ ] ; foreach ( $ model -> getFirstErrors ( ) as $ name => $ message ) { $ result [ ] = [ 'field' => $ name , 'message' => $ message , ] ; } return $ result ; }
12594	protected function makeDir ( $ dirName , LoggerInterface $ logger ) { $ dn = explode ( getcwd ( ) , $ dirName ) [ 1 ] ?? $ dirName ; if ( @ mkdir ( $ dirName ) ) { $ logger -> logText ( "Created directory <fg=green>%s</>" , LoggerInterface :: VERBOSITY_NORMAL , NULL , $ dn ) ; } else { $ logger -> logWarning ( "Creating directory $dn failed" ) ; } }
4052	private function fetchPropertiesFor ( $ inputScreenId , IMetaModel $ metaModel ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return array_map ( function ( $ column ) use ( $ inputScreenId , $ metaModel ) { if ( 'attribute' !== $ column [ 'dcatype' ] ) { return $ column ; } if ( ! ( $ attribute = $ metaModel -> getAttributeById ( $ column [ 'attr_id' ] ) ) ) { @ trigger_error ( 'Unknown attribute "' . $ column [ 'attr_id' ] . '" in input screen "' . $ inputScreenId . '"' , E_USER_WARNING ) ; return $ column ; } $ column = array_merge ( $ column , $ attribute -> getFieldDefinition ( $ column ) , [ 'col_name' => $ attribute -> getColName ( ) ] ) ; return $ column ; } , $ builder -> select ( '*' ) -> from ( 'tl_metamodel_dcasetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'published=:published' ) -> setParameter ( 'pid' , $ inputScreenId ) -> setParameter ( 'published' , 1 ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; }
232	public function quoteValue ( $ str ) { if ( ! is_string ( $ str ) ) { return $ str ; } if ( ( $ value = $ this -> db -> getSlavePdo ( ) -> quote ( $ str ) ) !== false ) { return $ value ; } return "'" . addcslashes ( str_replace ( "'" , "''" , $ str ) , "\000\n\r\\\032" ) . "'" ; }
11594	public function postAction ( ) { $ request = $ this -> environment -> getRequestHelper ( ) ; $ id = $ request -> getIdentifierParam ( 'name' ) ; try { $ this -> pageList -> getPage ( $ id ) ; } catch ( InvalidParameterException $ e ) { $ page = $ this -> pageList -> addPageFromRequest ( $ id , $ request ) ; $ this -> environment -> sendJSONResult ( $ page -> getJSON ( ) ) ; return ; } throw new InvalidParameterException ( "Page already exists" ) ; }
8619	public function getBlockWithKey ( $ key ) { if ( isset ( $ this -> blocks [ $ key ] ) ) return $ this -> blocks [ $ key ] ; return null ; }
12086	public function save ( ) { $ this -> checkPermission ( "special" , "/admin" ) ; $ referer = $ this -> application -> input -> getReferer ( ) ; if ( ! $ this -> application -> input -> methodIs ( "post" ) ) { $ this -> response -> addAlert ( "No configuration data recieved" , 'error' ) ; } else { if ( ( $ data = $ this -> application -> input -> getArray ( "options" , array ( ) , "post" ) ) == FALSE ) { $ this -> response -> addAlert ( "No input data recieved, Something went wrong" , 'error' ) ; } else { $ namespace = $ this -> application -> input -> getString ( "options_namespace" , "" , "post" ) ; $ this -> application -> config -> mergeParams ( $ namespace , $ data ) ; if ( ! $ this -> application -> config -> saveParams ( ) ) { $ this -> response -> addAlert ( 'Something went wrong, Did not save the parameters' , 'error' ) ; } else { $ this -> response -> addAlert ( "Your configuration settings have now been saved" , "success" ) ; } } } $ this -> application -> dispatcher -> redirect ( $ referer , HTTP_FOUND , null , $ this -> response -> getAlerts ( ) ) ; return true ; }
9782	private function parseIf ( ) { $ if_open = $ this -> pop ( 'IF_OPEN' ) ; $ output = 'if(' . $ if_open [ 1 ] . ') {' . "\n" ; $ this -> currLine ++ ; $ seeking = true ; while ( $ seeking ) { list ( $ type , $ value ) = $ this -> peek ( ) ; switch ( $ type ) { case 'IF_CLOSE' : $ this -> pop ( ) ; $ output .= "}\n" ; $ seeking = false ; $ this -> currLine ++ ; break ; case 'ELSE' : $ this -> pop ( ) ; $ output .= "} else {\n" ; $ this -> currLine ++ ; break ; case 'ELSE_IF' : $ token = $ this -> pop ( ) ; $ output .= '} elseif(' . $ token [ 1 ] . ") {\n" ; $ this -> currLine ++ ; break ; default : $ output .= $ this -> parseExpression ( ) ; break ; } } return $ output ; }
6657	protected function createFailSafeResponse ( ) { $ status = new Status ( 500 ) ; $ response = new Response ( ) ; $ response -> setRequest ( new Request ( ) ) ; $ response -> setWriter ( new Json ( ) ) ; $ response -> setStatus ( $ status ) ; $ response -> setBodyData ( $ status -> getMessage ( ) ) ; return $ response ; }
12325	protected function execute ( InputInterface $ input , OutputInterface $ output ) { try { $ this -> doPreExecute ( $ input , $ output ) ; $ this -> returnCode = $ this -> doExecute ( $ input , $ output ) ; $ this -> doPostExecute ( $ input , $ output ) ; } catch ( Exception $ e ) { $ this -> returnCode = static :: RETURN_ERROR ; throw $ e ; } return $ this -> returnCode ; }
2835	public function completeRendering ( Mage_Core_Block_Abstract $ block ) { $ this -> isRendering = false ; $ this -> renderedCompletedAt = microtime ( true ) ; $ this -> renderedDuration += ( $ this -> renderedCompletedAt * 1000 - $ this -> renderedAt * 1000 ) ; $ this -> templateFile = $ block instanceof Mage_Core_Block_Template ? $ block -> getTemplateFile ( ) : '' ; self :: $ endRenderingTime = $ this -> renderedCompletedAt ; }
9392	protected function skipRowsClause ( ) { $ skipClause = [ ] ; foreach ( $ this -> skipRows as $ cl => $ val ) { $ skipClause [ ] = [ '<>' , $ cl , $ val ] ; } if ( count ( $ skipClause ) > 1 ) array_unshift ( $ skipClause , 'and' ) ; return $ skipClause ; }
145	public function propagateLiteral ( $ decidedLiteral , $ level , $ decisions ) { $ literal = - $ decidedLiteral ; if ( ! isset ( $ this -> watchChains [ $ literal ] ) ) { return null ; } $ chain = $ this -> watchChains [ $ literal ] ; $ chain -> rewind ( ) ; while ( $ chain -> valid ( ) ) { $ node = $ chain -> current ( ) ; $ otherWatch = $ node -> getOtherWatch ( $ literal ) ; if ( ! $ node -> getRule ( ) -> isDisabled ( ) && ! $ decisions -> satisfy ( $ otherWatch ) ) { $ ruleLiterals = $ node -> getRule ( ) -> getLiterals ( ) ; $ alternativeLiterals = array_filter ( $ ruleLiterals , function ( $ ruleLiteral ) use ( $ literal , $ otherWatch , $ decisions ) { return $ literal !== $ ruleLiteral && $ otherWatch !== $ ruleLiteral && ! $ decisions -> conflict ( $ ruleLiteral ) ; } ) ; if ( $ alternativeLiterals ) { reset ( $ alternativeLiterals ) ; $ this -> moveWatch ( $ literal , current ( $ alternativeLiterals ) , $ node ) ; continue ; } if ( $ decisions -> conflict ( $ otherWatch ) ) { return $ node -> getRule ( ) ; } $ decisions -> decide ( $ otherWatch , $ level , $ node -> getRule ( ) ) ; } $ chain -> next ( ) ; } return null ; }
9684	public function getStorage ( ) { if ( null === $ this -> storage ) { $ this -> setStorage ( new Storage \ File ( array ( 'dir' => DATA_PATH ) ) ) ; } return $ this -> storage ; }
10877	public function isValidForgotten ( string $ hash ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { return $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ; } return false ; }
4698	public static function compare ( $ hasha = "" , $ hashb = "" ) { $ hashes_are_not_equal = strlen ( $ hasha ) ^ strlen ( $ hashb ) ; $ length = min ( strlen ( $ hasha ) , strlen ( $ hashb ) ) ; $ hasha = substr ( $ hasha , 0 , $ length ) ; $ hashb = substr ( $ hashb , 0 , $ length ) ; for ( $ i = 0 ; $ i < strlen ( $ hasha ) ; $ i ++ ) { $ hashes_are_not_equal += ! ( ord ( $ hasha [ $ i ] ) === ord ( $ hashb [ $ i ] ) ) ; } return ! $ hashes_are_not_equal ; }
5919	public function setCreated ( $ created ) { if ( $ created instanceof DateTime ) { $ this -> created = $ created ; } else { try { $ this -> created = new DateTime ( $ created ) ; } catch ( \ Exception $ e ) { $ this -> created = null ; } } return $ this ; }
5858	protected function notify ( $ callbackNotification , $ message , $ severity ) { $ callableName = '' ; if ( is_callable ( $ callbackNotification , false , $ callableName ) ) { call_user_func ( $ callbackNotification , $ message , $ severity ) ; } }
12591	protected function checkParams ( $ params , $ operator ) { if ( ! is_array ( $ params ) ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: first param must be an array' ) ; } if ( $ operator == 'IN' ) { if ( count ( $ params ) < 1 ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: IN operator requires at least one param' ) ; } } elseif ( $ operator == 'BETWEEN' ) { if ( count ( $ params ) != 2 ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: BETWEEN operator requires exactly two params' ) ; } } else { throw new Exception ( 'Web2All_Table_MultiValueOperator: unsupported operator "' . $ operator . '"' ) ; } }
9110	protected function attainPathName ( ) { $ path = false ; $ config = $ this -> getConfig ( ) ; if ( isset ( $ config [ 'theme_locator' ] [ 'themes_default_path' ] ) ) { $ path = $ config [ 'theme_locator' ] [ 'themes_default_path' ] ; } $ themeName = $ this -> attainThemeName ( ) ; if ( isset ( $ config [ 'themes' ] ) && is_array ( $ config [ 'themes' ] ) && isset ( $ config [ 'themes' ] [ $ themeName ] ) ) { if ( array_key_exists ( 'dir_path' , $ config [ 'themes' ] [ $ themeName ] ) ) { $ path = $ config [ 'themes' ] [ $ themeName ] [ 'dir_path' ] ; } } return $ path ; }
1171	protected function getProtected ( $ instance , $ property ) { $ closure = function ( $ property ) { return $ this -> $ property ; } ; $ callback = $ closure -> bindTo ( $ instance , $ instance ) ; return $ callback ( $ property ) ; }
4908	public function render ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ renderer -> headscript ( ) -> appendFile ( $ renderer -> basepath ( 'modules/Core/js/jquery.summary-form.js' ) ) ; $ label = $ form -> getLabel ( ) ; $ labelContent = $ label ? '<div class="sf-headline"><h3>' . $ this -> getView ( ) -> translate ( $ label ) . '</h3></div>' : '' ; $ formContent = $ this -> renderForm ( $ form , $ layout , $ parameter ) ; $ summaryContent = $ this -> renderSummary ( $ form ) ; $ formContent = sprintf ( '<div class="sf-form"><div class="panel panel-info"><div class="panel-body">%s</div></div></div> <div class="sf-summary">%s</div> ' , $ formContent , $ summaryContent ) ; if ( $ form instanceof DescriptionAwareFormInterface && $ form -> isDescriptionsEnabled ( ) ) { $ this -> getView ( ) -> headscript ( ) -> appendFile ( $ this -> getView ( ) -> basepath ( 'modules/Core/js/forms.descriptions.js' ) ) ; if ( $ desc = $ form -> getOption ( 'description' , '' ) ) { $ translator = $ this -> getTranslator ( ) ; $ textDomain = $ this -> getTranslatorTextDomain ( ) ; $ desc = $ translator -> translate ( $ desc , $ textDomain ) ; } $ formContent = sprintf ( '<div class="daf-form-container row"> <div class="daf-form col-md-8">%s</div> <div class="daf-desc col-md-4"> <div class="daf-desc-content alert alert-info">%s</div> </div> </div>' , $ formContent , $ desc ) ; } $ markup = '<div id="sf-%s" class="sf-container" data-display-mode="%s">' . '%s' . '%s' . '</div>' ; $ id = str_replace ( '.' , '-' , $ form -> getAttribute ( 'name' ) ) ; $ content = sprintf ( $ markup , $ id , $ form -> getDisplayMode ( ) , $ labelContent , $ formContent ) ; return $ content ; }
2446	public function checkPermission ( ) { switch ( Contao \ Input :: get ( 'act' ) ) { case 'select' : case 'show' : break ; case 'edit' : case 'delete' : case 'toggle' : $ objComment = $ this -> Database -> prepare ( "SELECT id, parent, source FROM tl_comments WHERE id=?" ) -> limit ( 1 ) -> execute ( Contao \ Input :: get ( 'id' ) ) ; if ( $ objComment -> numRows < 1 ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Invalid comment ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } if ( ! $ this -> isAllowedToEditComment ( $ objComment -> parent , $ objComment -> source ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to ' . Contao \ Input :: get ( 'act' ) . ' comment ID ' . Contao \ Input :: get ( 'id' ) . ' (parent element: ' . $ objComment -> source . ' ID ' . $ objComment -> parent . ').' ) ; } break ; case 'editAll' : case 'deleteAll' : case 'overrideAll' : $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; if ( empty ( $ session [ 'CURRENT' ] [ 'IDS' ] ) || ! \ is_array ( $ session [ 'CURRENT' ] [ 'IDS' ] ) ) { break ; } $ objComment = $ this -> Database -> execute ( "SELECT id, parent, source FROM tl_comments WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ session [ 'CURRENT' ] [ 'IDS' ] ) ) . ")" ) ; while ( $ objComment -> next ( ) ) { if ( ! $ this -> isAllowedToEditComment ( $ objComment -> parent , $ objComment -> source ) && ( $ key = array_search ( $ objComment -> id , $ session [ 'CURRENT' ] [ 'IDS' ] ) ) !== false ) { unset ( $ session [ 'CURRENT' ] [ 'IDS' ] [ $ key ] ) ; } } $ session [ 'CURRENT' ] [ 'IDS' ] = array_values ( $ session [ 'CURRENT' ] [ 'IDS' ] ) ; $ objSession -> replace ( $ session ) ; break ; default : if ( \ strlen ( Contao \ Input :: get ( 'act' ) ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Invalid command "' . Contao \ Input :: get ( 'act' ) . '.' ) ; } break ; } }
12524	public function deserializeJSON ( $ jsonString ) { $ data = json_decode ( $ jsonString ) ; $ this -> setContent ( $ data -> content ) ; $ this -> setContext ( $ data -> context ) ; }
11231	public function post ( $ section , $ body = null , array $ headers = [ ] ) { if ( is_array ( $ body ) ) { $ body = array_merge ( $ this -> parameters , $ body , $ this -> defaultParameters ) ; $ body = http_build_query ( $ body ) ; } return $ this -> client -> post ( $ this -> getUrl ( $ section ) , $ headers , $ body ) ; }
51	public function addRepository ( RepositoryInterface $ repository ) { if ( $ repository instanceof self ) { foreach ( $ repository -> getRepositories ( ) as $ repo ) { $ this -> addRepository ( $ repo ) ; } } else { $ this -> repositories [ ] = $ repository ; } }
6052	public function retrieveFolder ( $ id , $ depth = 0 , $ includeProperties = true , $ includeObjectCounts = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'depth' => $ depth , 'includeProperties' => $ includeProperties , 'includeObjectCounts' => $ includeObjectCounts ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
6434	public function getLoginStartUrl ( $ redirecturl ) { $ credentials = array ( 'identifier' => $ this -> options [ 'consumer_key' ] , 'secret' => $ this -> options [ 'consumer_secret' ] , 'callback_uri' => $ redirecturl ) ; $ server = new \ League \ OAuth1 \ Client \ Server \ Xing ( $ credentials ) ; $ this -> temp_credentials = $ server -> getTemporaryCredentials ( ) ; return $ server -> getAuthorizationUrl ( $ this -> temp_credentials ) ; }
11404	public function changeAction ( ) { $ theme = $ this -> container -> get ( 'request' ) -> request -> get ( 'admin_theme' ) ; $ this -> container -> get ( 'vince_t.admin.theme.handler' ) -> setCurrentTheme ( $ theme ) ; $ headers = $ this -> container -> get ( 'request' ) -> server -> getHeaders ( ) ; $ referer = $ headers [ 'REFERER' ] ; return new RedirectResponse ( $ referer ) ; }
9036	protected function insert ( $ entity , $ tableName = null , HydratorInterface $ hydrator = null ) { $ result = parent :: insert ( $ entity , $ tableName , $ hydrator ) ; $ entity -> setId ( $ result -> getGeneratedValue ( ) ) ; return $ result ; }
7420	protected function getNumList ( ) : array { preg_match_all ( '/\/\d+/u' , $ this -> request -> route ( ) , $ numList ) ; $ numList = $ numList [ 0 ] ; $ numList = array_map ( function ( $ val ) { return intval ( ltrim ( $ val , '/' ) ) ; } , $ numList ) ; return $ numList ; }
10144	private function readBof ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ substreamType = self :: getUInt2d ( $ recordData , 2 ) ; switch ( $ substreamType ) { case self :: XLS_WORKBOOKGLOBALS : $ version = self :: getUInt2d ( $ recordData , 0 ) ; if ( ( $ version != self :: XLS_BIFF8 ) && ( $ version != self :: XLS_BIFF7 ) ) { throw new Exception ( 'Cannot read this Excel file. Version is too old.' ) ; } $ this -> version = $ version ; break ; case self :: XLS_WORKSHEET : break ; default : do { $ code = self :: getUInt2d ( $ this -> data , $ this -> pos ) ; $ this -> readDefault ( ) ; } while ( $ code != self :: XLS_TYPE_EOF && $ this -> pos < $ this -> dataSize ) ; break ; } }
8342	public static function addData ( string $ title , array $ data ) { if ( self :: $ isInit === true ) { self :: $ prettyPageHandler -> AddDataTable ( $ title , $ data ) ; } }
3059	public function selectAdaptiveNextItem ( ) { $ lastItemId = $ this -> getCurrentCatItemId ( ) ; $ lastOutput = $ this -> getLastCatItemOutput ( ) ; $ catSession = $ this -> getCatSession ( ) ; $ preSelection = $ catSession -> getTestMap ( ) ; try { if ( ! $ this -> syncingMode ) { $ selection = $ catSession -> getTestMap ( array_values ( $ lastOutput ) ) ; if ( ! $ this -> saveAdaptiveResults ( $ catSession ) ) { \ common_Logger :: w ( 'Unable to save CatService results.' ) ; } $ isShadowItem = false ; } else { $ selection = $ catSession -> getTestMap ( ) ; $ isShadowItem = true ; } } catch ( CatEngineException $ e ) { \ common_Logger :: e ( 'Error during CatEngine processing. ' . $ e -> getMessage ( ) ) ; $ selection = $ catSession -> getTestMap ( ) ; $ isShadowItem = true ; } $ event = new SelectAdaptiveNextItemEvent ( $ this -> getTestSession ( ) , $ lastItemId , $ preSelection , $ selection , $ isShadowItem ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ this -> persistCatSession ( $ catSession ) ; if ( is_array ( $ selection ) && count ( $ selection ) > 0 ) { \ common_Logger :: d ( "New CAT item selection is '" . implode ( ', ' , $ selection ) . "'." ) ; return $ selection [ 0 ] ; } else { \ common_Logger :: d ( 'No new CAT item selection.' ) ; return null ; } }
9715	private function writeNumberFormat ( $ format , $ ifmt ) { $ record = 0x041E ; $ numberFormatString = StringHelper :: UTF8toBIFF8UnicodeLong ( $ format ) ; $ length = 2 + strlen ( $ numberFormatString ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ ifmt ) . $ numberFormatString ; $ this -> append ( $ header . $ data ) ; }
5626	public function addRequestParameter ( $ key , $ value ) { $ this -> raw = false ; $ this -> request -> add ( $ key , $ value ) ; }
12558	public function actionFlush ( $ category = null ) { if ( is_null ( $ category ) ) { $ category = $ this -> prompt ( "Category (blank for all): " ) ; } if ( empty ( $ category ) ) { $ category = 'all' ; } else { $ category = [ 'category' , $ category ] ; } Cacher :: invalidateGroup ( $ category ) ; $ this -> out ( "Done!" ) ; }
4700	protected function handleInput ( InputInterface $ input ) { if ( $ file = $ input -> getArgument ( 'file' ) ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The input file "%s" not found' , $ file ) ) ; } return file_get_contents ( $ file ) ; } else { $ contents = '' ; if ( $ stdin = fopen ( 'php://stdin' , 'r' ) ) { if ( stream_set_blocking ( $ stdin , false ) ) { $ contents = stream_get_contents ( $ stdin ) ; } fclose ( $ stdin ) ; } if ( $ contents ) { return $ contents ; } } throw new \ InvalidArgumentException ( 'No input file' ) ; }
6400	public static function init ( ) : void { self :: $ classMap = new CallbackLazyMap ( function ( $ className ) { $ trimmedClassName = trim ( $ className , '\\' ) ; return $ trimmedClassName === $ className ? new ObjectClass ( $ className ) : ObjectClass :: $ classMap -> $ trimmedClassName ; } ) ; }
9983	public static function dataTypeForValue ( $ pValue ) { if ( $ pValue === null ) { return DataType :: TYPE_NULL ; } elseif ( $ pValue === '' ) { return DataType :: TYPE_STRING ; } elseif ( $ pValue instanceof RichText ) { return DataType :: TYPE_INLINE ; } elseif ( $ pValue [ 0 ] === '=' && strlen ( $ pValue ) > 1 ) { return DataType :: TYPE_FORMULA ; } elseif ( is_bool ( $ pValue ) ) { return DataType :: TYPE_BOOL ; } elseif ( is_float ( $ pValue ) || is_int ( $ pValue ) ) { return DataType :: TYPE_NUMERIC ; } elseif ( preg_match ( '/^[\+\-]?(\d+\\.?\d*|\d*\\.?\d+)([Ee][\-\+]?[0-2]?\d{1,3})?$/' , $ pValue ) ) { $ tValue = ltrim ( $ pValue , '+-' ) ; if ( is_string ( $ pValue ) && $ tValue [ 0 ] === '0' && strlen ( $ tValue ) > 1 && $ tValue [ 1 ] !== '.' ) { return DataType :: TYPE_STRING ; } elseif ( ( strpos ( $ pValue , '.' ) === false ) && ( $ pValue > PHP_INT_MAX ) ) { return DataType :: TYPE_STRING ; } return DataType :: TYPE_NUMERIC ; } elseif ( is_string ( $ pValue ) ) { $ errorCodes = DataType :: getErrorCodes ( ) ; if ( isset ( $ errorCodes [ $ pValue ] ) ) { return DataType :: TYPE_ERROR ; } } return DataType :: TYPE_STRING ; }
12681	public function send ( ) { if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message to send.' ) ; } $ transformer = new Transformer ( ) ; if ( $ this -> message instanceof RawMessage ) { $ message = $ this -> message -> get ( 'content' ) ; } else { $ content = $ transformer -> transform ( $ this -> message ) ; $ message = [ 'touser' => $ this -> to , ] ; if ( $ this -> account ) { $ message [ 'customservice' ] = [ 'kf_account' => $ this -> account ] ; } $ message = array_merge ( $ message , $ content ) ; } return $ this -> staff -> send ( $ message ) ; }
12924	public function getHandledLocalDataItems ( ) { $ handled = [ ] ; foreach ( $ this -> localDataItems as $ local ) { if ( $ local -> handled ) { $ handled [ ] = $ local ; } } return $ handled ; }
3696	protected function extractIdFrom ( EnvironmentInterface $ environment , $ parameterName = 'pid' ) { $ parameter = $ environment -> getInputProvider ( ) -> getParameter ( $ parameterName ) ; return ModelId :: fromSerialized ( $ parameter ) -> getId ( ) ; }
5776	public function add ( string $ sql ) { $ args = func_get_args ( ) ; array_shift ( $ args ) ; $ this -> sql .= $ sql ; $ this -> args = array_merge ( $ this -> args , $ args ) ; return $ this ; }
11062	public static function isEncodingSupported ( $ encoding ) { $ encoding = strtolower ( $ encoding ) ; if ( isset ( static :: supportedEncodings ( ) [ $ encoding ] ) ) { return true ; } return false ; }
5757	private function selectArray ( ? string $ selectColumns = null , array $ whereColumnsInfo = null , string $ orderBy = null ) : array { $ columns = $ selectColumns ?? $ this -> defaultSelectColumnsString ; $ permissionsArray = [ ] ; if ( null !== $ records = $ this -> select ( $ columns , $ whereColumnsInfo , $ orderBy ) ) { $ rolesTableMapper = RolesTableMapper :: getInstance ( ) ; foreach ( $ records as $ record ) { if ( null === $ key = $ this -> getPermissionsArrayKeyForId ( $ permissionsArray , ( int ) $ record [ 'id' ] ) ) { $ permissionsArray [ ] = [ 'id' => ( int ) $ record [ 'id' ] , 'title' => $ record [ 'title' ] , 'description' => $ record [ 'description' ] , 'roles' => [ $ rolesTableMapper -> getObjectById ( ( int ) $ record [ 'role_id' ] ) ] , 'active' => Postgres :: convertPostgresBoolToBool ( $ record [ 'active' ] ) , 'created' => new \ DateTimeImmutable ( $ record [ 'created' ] ) , ] ; } else { array_push ( $ permissionsArray [ $ key ] [ 'roles' ] , $ rolesTableMapper -> getObjectById ( ( int ) $ record [ 'role_id' ] ) ) ; } } } return $ permissionsArray ; }
10384	protected static function set_new_params ( $ type , $ hash , $ url , $ extension ) { $ data = [ 'name' => self :: $ id , 'url' => $ url . $ hash . $ extension , 'deps' => self :: unify_params ( $ type , 'deps' ) , 'version' => self :: unify_params ( $ type , 'version' , '1.0.0' ) , ] ; switch ( $ type ) { case 'style' : $ data [ 'media' ] = self :: unify_params ( $ type , 'media' , 'all' ) ; break ; case 'script' : $ data [ 'params' ] = self :: unify_params ( $ type , 'params' ) ; $ data [ 'footer' ] = self :: unify_params ( $ type , 'footer' , false ) ; $ data [ 'params' ] [ 'nonce' ] = wp_create_nonce ( self :: $ id ) ; break ; default : } self :: $ data [ $ type ] = [ $ data [ 'name' ] => $ data ] ; return true ; }
1997	public function dump ( ) : void { if ( empty ( $ this -> parameters [ 'parameters' ] [ 'secret' ] ) || 'ThisTokenIsNotSoSecretChangeIt' === $ this -> parameters [ 'parameters' ] [ 'secret' ] ) { $ this -> parameters [ 'parameters' ] [ 'secret' ] = bin2hex ( random_bytes ( 32 ) ) ; } if ( isset ( $ this -> parameters [ 'parameters' ] [ 'database_port' ] ) ) { $ this -> parameters [ 'parameters' ] [ 'database_port' ] = ( int ) $ this -> parameters [ 'parameters' ] [ 'database_port' ] ; } $ this -> filesystem -> dumpFile ( $ this -> rootDir . '/app/config/parameters.yml' , "# This file has been auto-generated during installation\n" . Yaml :: dump ( $ this -> getEscapedValues ( ) ) ) ; }
3990	private function getInputScreens ( ) { $ combinations = $ this -> getCombinations ( ) ; if ( null === $ combinations ) { return [ ] ; } $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; if ( $ this -> cache -> contains ( $ cacheKey = 'screens_' . implode ( ',' , $ screenIds ) ) ) { return $ this -> cache -> fetch ( $ cacheKey ) ; } $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ this -> cache -> save ( $ cacheKey , $ screens ) ; return $ screens ; }
7647	public function stream_open ( $ path , $ mode , $ options , & $ opened_path ) { $ this -> fileName = $ path ; $ this -> temporaryFileName = tempnam ( sys_get_temp_dir ( ) , 'azure' ) ; $ fh = @ fopen ( $ this -> temporaryFileName , $ mode ) ; if ( $ fh === false ) { return false ; } fclose ( $ fh ) ; if ( strpbrk ( $ mode , 'wax+' ) ) { $ this -> writeMode = true ; } else { $ this -> writeMode = false ; } if ( ! $ this -> writeMode || strpbrk ( $ mode , 'ra+' ) ) { $ this -> getStorageClient ( $ this -> fileName ) -> getBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } $ this -> temporaryFileHandle = fopen ( $ this -> temporaryFileName , $ mode ) ; return true ; }
96	public function read ( $ url ) { $ xml = $ this -> requestXml ( $ url , "/channel.xml" ) ; $ channelName = ( string ) $ xml -> name ; $ channelAlias = ( string ) $ xml -> suggestedalias ; $ supportedVersions = array_keys ( $ this -> readerMap ) ; $ selectedRestVersion = $ this -> selectRestVersion ( $ xml , $ supportedVersions ) ; if ( ! $ selectedRestVersion ) { throw new \ UnexpectedValueException ( sprintf ( 'PEAR repository %s does not supports any of %s protocols.' , $ url , implode ( ', ' , $ supportedVersions ) ) ) ; } $ reader = $ this -> readerMap [ $ selectedRestVersion [ 'version' ] ] ; $ packageDefinitions = $ reader -> read ( $ selectedRestVersion [ 'baseUrl' ] ) ; return new ChannelInfo ( $ channelName , $ channelAlias , $ packageDefinitions ) ; }
6422	public function getMenu ( $ level = 1 ) { if ( class_exists ( ContentController :: class ) ) { $ controller = ContentController :: singleton ( ) ; return $ controller -> getMenu ( $ level ) ; } }
10784	public function parse ( UriInterface $ uri ) : ParsedURL { $ matches = [ ] ; if ( preg_match ( $ this -> pattern , $ uri -> getPath ( ) , $ matches ) === 0 ) { throw new InvalidRequestURLException ( "Unable to parse request path: did not match regex" ) ; } if ( ! ( $ endpoint = $ matches [ "endpoint" ] ?? null ) ) { throw new InvalidRequestURLException ( "Unable to match endpoint in url" ) ; } $ element = $ matches [ "element" ] ?? null ; $ version = $ matches [ "version" ] ?? null ; $ apiKey = $ matches [ "apiKey" ] ?? null ; $ acceptableMimeTypes = [ ] ; if ( ( $ acceptableExtension = $ matches [ "acceptableExtension" ] ?? null ) ) { if ( ! $ this -> MIMEProvider ) { throw new UnableToParseURLException ( "Unable to accept acceptable extensions" ) ; } else { try { $ acceptableMimeTypes [ ] = $ this -> MIMEProvider -> provideMIME ( $ acceptableExtension ) ; } catch ( UnableToProvideMIMEException $ exception ) { throw new UnableToParseURLException ( $ exception -> getMessage ( ) ) ; } } } return new ParsedURL ( $ endpoint , $ element , $ version , $ apiKey , $ acceptableMimeTypes , $ uri -> getQuery ( ) ) ; }
7317	public function toJD ( $ scale = null ) { if ( $ scale ) { return bcadd ( ( string ) $ this -> jd , ( string ) $ this -> dayFrac , $ scale ) ; } else { return $ this -> jd + $ this -> dayFrac ; } }
3632	public function config ( Request $ request ) { if ( $ key = $ request -> query ( 'key' ) ) { return \ config ( $ key ) ; } return \ bean ( 'config' ) -> toArray ( ) ; }
1235	public function elementMeta ( $ elementName ) { $ class = get_class ( $ this ) ; if ( array_key_exists ( $ elementName , self :: $ properties [ $ class ] ) ) { $ info = self :: $ properties [ $ class ] [ $ elementName ] ; $ nameKey = $ info [ 'attribute' ] ? 'attributeName' : 'elementName' ; if ( array_key_exists ( $ nameKey , $ info ) ) { if ( $ info [ $ nameKey ] === $ elementName ) { $ meta = new \ stdClass ( ) ; $ meta -> propertyName = $ elementName ; $ meta -> phpType = $ info [ 'type' ] ; $ meta -> repeatable = $ info [ 'repeatable' ] ; $ meta -> attribute = $ info [ 'attribute' ] ; $ meta -> elementName = $ info [ $ nameKey ] ; $ meta -> strData = '' ; return $ meta ; } } } return null ; }
1958	private function getTaskFromInput ( InputInterface $ input , OutputInterface $ output ) : string { $ commands = $ this -> getCommands ( ) ; $ task = $ input -> getArgument ( 'task' ) ; if ( null !== $ task ) { if ( ! \ in_array ( $ task , $ commands , true ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid task "%s"' , $ task ) ) ; } return $ task ; } $ question = new ChoiceQuestion ( 'Please select a task:' , $ commands ) ; $ question -> setMaxAttempts ( 1 ) ; $ helper = $ this -> getHelper ( 'question' ) ; return $ helper -> ask ( $ input , $ output , $ question ) ; }
5402	public function isExpired ( $ now ) { if ( ! $ this -> expiry ) { return true ; } if ( is_string ( $ now ) ) { $ now = strtotime ( $ now ) ; } return ( $ this -> expiry < $ now ) ; }
7198	protected function fixCustomers ( OrderInterface $ order ) { $ changed = false ; $ originCustomer = $ order -> getOriginCustomer ( ) ; $ customer = $ order -> getCustomer ( ) ; if ( is_null ( $ customer ) ) { if ( $ originCustomer && $ originCustomer -> hasParent ( ) ) { $ order -> setCustomer ( $ originCustomer -> getParent ( ) ) ; $ changed = true ; } } elseif ( $ customer -> hasParent ( ) ) { $ order -> setCustomer ( $ customer -> getParent ( ) ) ; if ( null === $ order -> getOriginCustomer ( ) ) { $ order -> setOriginCustomer ( $ customer ) ; } $ changed = true ; } if ( $ changed ) { $ this -> persistenceHelper -> persistAndRecompute ( $ order , false ) ; } return $ changed ; }
2868	public function preDispatch ( ) { parent :: preDispatch ( ) ; if ( ! Mage :: helper ( 'sheep_debug' ) -> isAllowed ( ) ) { $ this -> setFlag ( '' , 'no-dispatch' , true ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; } }
3131	public function persist ( QtiRunnerServiceContext $ context ) { $ testSession = $ context -> getTestSession ( ) ; $ sessionId = $ testSession -> getSessionId ( ) ; \ common_Logger :: d ( "Persisting QTI Assessment Test Session '${sessionId}'..." ) ; $ context -> getStorage ( ) -> persist ( $ testSession ) ; if ( $ this -> isTerminated ( $ context ) ) { $ userId = \ common_session_SessionManager :: getSession ( ) -> getUser ( ) -> getIdentifier ( ) ; $ eventManager = $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) ; $ eventManager -> trigger ( new AfterAssessmentTestSessionClosedEvent ( $ testSession , $ userId ) ) ; } }
4462	private function readErrorFromSocket ( $ socket ) : ? string { $ error = '' ; while ( ! empty ( $ res = socket_read ( $ socket , 8192 ) ) ) { $ error .= $ res ; } $ error = unserialize ( $ error ) ; if ( is_array ( $ error ) ) { $ handler = new ErrorFormatter ( ) ; return sprintf ( '%s: %s in %s on line %d' , $ handler -> constant ( $ error [ 'type' ] ) ? : 'Unknown' , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } return null ; }
7394	public function replace ( $ in ) : void { $ this -> _massageBlockInput ( $ in ) ; if ( empty ( $ in ) ) { return ; } foreach ( $ in as $ k => $ v ) { if ( $ this -> _keyExists ( $ k ) ) { if ( $ this -> { $ k } instanceof TypedAbstract ) { $ this -> { $ k } -> replace ( $ v ) ; } else { $ this -> _setByName ( $ k , $ v ) ; } } } $ this -> _checkRelatedProperties ( ) ; }
12381	public static function interval ( $ startDate , $ endDate ) { $ hits = DB :: table ( 'views' ) -> select ( 'id' , 'ip' , 'created_at' ) -> whereBetween ( 'created_at' , [ $ startDate , $ endDate ] ) -> groupBy ( 'ip' ) -> get ( ) ; return count ( $ hits ) ; }
11697	public function __ ( $ key , array $ parameters = [ ] , $ locale = null , $ default = null , $ parseBBCode = true ) { return $ this -> translate ( $ key , $ parameters , $ locale , $ default , $ parseBBCode ) ; }
5833	protected function headerToArray ( $ header ) { $ tmp = explode ( "\r\n" , $ header ) ; $ headers = array ( ) ; foreach ( $ tmp as $ singleHeader ) { $ delimiter = strpos ( $ singleHeader , ': ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 2 ) ; $ headers [ $ key ] = $ val ; } else { $ delimiter = strpos ( $ singleHeader , ' ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 1 ) ; $ headers [ $ key ] = $ val ; } } } return $ headers ; }
4333	private static function buildAttribBoolVal ( $ key , $ value = true ) { if ( $ key == 'autocomplete' ) { $ value = $ value ? 'on' : 'off' ; } elseif ( $ key == 'spellcheck' ) { $ value = $ value ? 'true' : 'false' ; } elseif ( $ key == 'translate' ) { $ value = $ value ? 'yes' : 'no' ; } elseif ( $ value ) { $ value = $ key ; } else { $ value = null ; } return $ value ; }
10331	public function load ( $ url ) { if ( ! is_string ( $ url ) ) { throw new \ InvalidArgumentException ( 'The url argument must be of type string' ) ; } $ this -> url = $ url ; set_error_handler ( function ( ) { throw new \ Exception ( func_get_arg ( 1 ) ) ; } ) ; $ errorReason = '' ; try { $ urlData = parse_url ( $ this -> url ) ; if ( isset ( $ urlData [ 'host' ] ) ) { $ hostname = $ urlData [ 'host' ] ; if ( substr ( $ hostname , 0 , 4 ) === 'www.' ) { $ hostname = substr ( $ hostname , 4 ) ; } foreach ( self :: $ providers as $ name => $ domains ) { $ done = false ; foreach ( $ domains as $ domain ) { if ( preg_match ( '/^' . str_replace ( [ '.' , '*' ] , [ '\.' , '.*' ] , $ domain ) . '$/' , $ hostname ) ) { include_once __DIR__ . DIRECTORY_SEPARATOR . 'VideoEmbed' . DIRECTORY_SEPARATOR . 'Internal' . DIRECTORY_SEPARATOR . 'Providers' . DIRECTORY_SEPARATOR . $ name . '.php' ; call_user_func ( [ '\IvoPetkov\VideoEmbed\Internal\Providers\\' . $ name , 'load' ] , $ this -> url , $ this ) ; $ done = true ; break ; } } if ( $ done ) { break ; } } } } catch ( \ Exception $ e ) { $ errorReason = $ e -> getMessage ( ) ; } restore_error_handler ( ) ; if ( $ this -> html === null ) { throw new \ Exception ( 'Cannot retrieve information about ' . $ this -> url . ' (reason: ' . ( isset ( $ errorReason { 0 } ) ? $ errorReason : 'unknown' ) . ')' ) ; } }
10739	public function supports ( $ query ) { foreach ( $ this -> engines as $ eachEngine ) { if ( $ eachEngine -> supports ( $ query ) ) { return true ; } } return false ; }
147	protected function processUrl ( PackageInterface $ package , $ url ) { if ( ! extension_loaded ( 'openssl' ) && 0 === strpos ( $ url , 'https:' ) ) { throw new \ RuntimeException ( 'You must enable the openssl extension to download files via https' ) ; } if ( $ package -> getDistReference ( ) ) { $ url = UrlUtil :: updateDistReference ( $ this -> config , $ url , $ package -> getDistReference ( ) ) ; } return $ url ; }
1379	protected function validateRelationship ( $ relation , ? string $ field = null ) : bool { $ path = $ field ? '/data/relationships' : '/' ; $ member = $ field ? : 'data' ; if ( ! is_object ( $ relation ) ) { $ this -> memberNotObject ( $ path , $ member ) ; return false ; } $ path = $ field ? "{$path}/{$field}" : $ path ; if ( ! property_exists ( $ relation , 'data' ) ) { $ this -> memberRequired ( $ path , 'data' ) ; return false ; } $ data = $ relation -> data ; if ( is_array ( $ data ) ) { return $ this -> validateToMany ( $ data , $ field ) ; } return $ this -> validateToOne ( $ data , $ field ) ; }
1174	protected function generateJavascriptValidations ( ) { $ jsValidations = [ ] ; foreach ( $ this -> validator -> getRules ( ) as $ attribute => $ rules ) { if ( ! $ this -> jsValidationEnabled ( $ attribute ) ) { continue ; } $ newRules = $ this -> jsConvertRules ( $ attribute , $ rules , $ this -> remote ) ; $ jsValidations = array_merge ( $ jsValidations , $ newRules ) ; } return $ jsValidations ; }
12277	public function update ( $ groupId , $ name ) { $ params = [ 'group' => [ 'id' => $ groupId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
8407	private function getIcon ( ) { if ( isset ( $ this -> model ) ) { $ icon = $ this -> attribute ; if ( isset ( $ this -> model -> $ icon ) ) { return $ this -> model -> $ icon ; } } if ( isset ( $ this -> icon ) ) { return $ this -> icon ; } return $ this -> default ; }
237	protected function setTableMetadata ( $ name , $ type , $ data ) { $ this -> _tableMetadata [ $ this -> getRawTableName ( $ name ) ] [ $ type ] = $ data ; }
1527	protected function doReplaceRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ name = Str :: classify ( $ field = $ request -> getRelationshipName ( ) ) ; if ( $ result = $ this -> invokeMany ( [ 'replacing' , "replacing{$name}" ] , $ record , $ request ) ) { return $ result ; } $ record = $ store -> replaceRelationship ( $ record , $ field , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> invokeMany ( [ "replaced{$name}" , "replaced" ] , $ record , $ request ) ? : $ record ; }
5496	public function register ( $ method , $ args , $ action ) { $ args = $ this -> replaceWildcards ( $ args ) ; $ method = strtolower ( $ method ) ; if ( ! isset ( $ this -> always [ $ method ] ) ) { $ this -> always [ $ method ] = new SimpleSignatureMap ( ) ; } $ this -> always [ $ method ] -> add ( $ args , $ action ) ; }
12379	public function handle ( ) : void { $ help = " -----------------------------------------------------------------\n" ; $ help .= " | Command Line Interface\n" ; $ help .= " | See more in https://github.com/senhungwong/command-line-interface\n" ; $ help .= " -------------------------------------------------------------------\n" ; $ commands = CommandEntry :: getCommands ( ) ; if ( $ command = $ this -> getArgument ( 'function-name' ) ) { $ command = new $ commands [ $ command ] ; $ help .= " - " . $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } else { foreach ( $ commands as $ command ) { $ command = new $ command ; $ help .= " - " ; $ help .= $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } } echo $ help ; }
1620	public function buildOne ( $ query ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "do return redis.call('HGETALL',$key .. pk) end" , 'pks' ) ; }
4849	protected function createDriver ( $ driverClass ) : Driver \ DriverInterface { return isset ( $ this -> container ) ? $ this -> container -> get ( $ driverClass ) : new $ driverClass ( ) ; }
11010	public function addDefaultSrc ( string $ source ) : bool { if ( ! in_array ( $ source , $ this -> tags [ 'default-src' ] ) ) { $ this -> tags [ 'default-src' ] [ ] = $ source ; return true ; } return false ; }
12403	public function replace ( $ id , $ document = null ) { return Parser :: replace ( $ id , $ document , $ this -> connection ) ; }
4766	protected function validateInvoiceAddressOptIn ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_invoiceaddress' ) ; $ changeExistigAddress = ( int ) $ this -> getRequestParameter ( 'oegdproptin_changeInvAddress' ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinInvoiceAddress' ) && ( 1 == $ changeExistigAddress ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
698	public function actionRun ( $ command ) { $ command = implode ( ' ' , \ func_get_args ( ) ) ; $ base = \ dirname ( \ dirname ( __DIR__ ) ) ; $ dirs = $ this -> listSubDirs ( "$base/extensions" ) ; $ dirs = array_merge ( $ dirs , $ this -> listSubDirs ( "$base/apps" ) ) ; asort ( $ dirs ) ; $ oldcwd = getcwd ( ) ; foreach ( $ dirs as $ dir ) { $ displayDir = substr ( $ dir , \ strlen ( $ base ) ) ; $ this -> stdout ( "Running '$command' in $displayDir...\n" , Console :: BOLD ) ; chdir ( $ dir ) ; passthru ( $ command ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } chdir ( $ oldcwd ) ; }
1252	private function normalizeElementName ( $ name ) { $ nsElement = explode ( '@' , $ name ) ; if ( count ( $ nsElement ) > 1 ) { array_shift ( $ nsElement ) ; return $ nsElement [ 0 ] ; } else { return $ name ; } }
5202	public function open ( ) { try { $ additionalConnectionOptions = array ( ) ; foreach ( array ( 'connection_timeout' , 'read_write_timeout' , 'keepalive' , 'heartbeat' ) as $ option ) { if ( isset ( $ this -> $ option ) ) { $ additionalConnectionOptions [ $ option ] = $ this -> $ option ; } } $ this -> AMQPConnection = new AMQPSSLConnection ( $ this -> host , $ this -> port , $ this -> username , $ this -> password , $ this -> vhost , $ this -> ssl_context_options , $ additionalConnectionOptions ) ; $ this -> channel = $ this -> AMQPConnection -> channel ( ) ; $ this -> channel -> queue_declare ( $ this -> queue_name , false , false , false , false ) ; $ this -> channel -> exchange_declare ( $ this -> exchange , $ this -> exchange_type , false , true , false ) ; $ this -> channel -> queue_bind ( $ this -> queue_name , $ this -> exchange ) ; } catch ( Exception $ e ) { throw new Exception ( $ e ) ; } }
11202	public function toArray ( ) { $ collection = $ this -> getIterator ( ) ; $ plainArray = [ ] ; foreach ( $ collection as $ prop => $ result ) { if ( is_object ( $ result ) && method_exists ( $ result , 'toArray' ) ) { $ plainArray [ ] = $ result -> toArray ( ) ; } else { $ plainArray [ ] = $ result ; } } return $ plainArray ; }
4537	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Uuidentifiable ) { return ; } $ this -> idService -> generateUuid ( $ entity ) ; }
5245	private function replace ( string $ pattern , string $ replacement , string $ targetFile ) { $ this -> filesystem -> put ( $ targetFile , preg_replace ( $ pattern , $ replacement , $ this -> filesystem -> get ( $ targetFile ) ) ) ; }
11092	public static function poorManTranslate ( $ category , $ text , array $ params = [ ] ) { if ( class_exists ( 'Yii' ) ) { return \ Yii :: t ( $ category , $ text , $ params ) ; } $ pos = strrpos ( $ category , '/' ) ; $ category = $ pos === false ? $ category : substr ( $ category , $ pos + 1 ) ; $ translation = @ include 'messages/cs/' . $ category . '.php' ; if ( $ translation !== null && \ is_array ( $ translation ) && array_key_exists ( $ text , $ translation ) ) { $ keys = array_keys ( $ params ) ; array_walk ( $ keys , function ( & $ v ) { $ v = '{' . $ v . '}' ; } ) ; return str_replace ( array_values ( $ params ) , $ keys , $ translation [ $ text ] ) ; } return $ text ; }
1231	public function resolveOptions ( array $ configuration ) { foreach ( $ configuration as $ key => $ value ) { if ( isset ( $ this -> definitions [ $ key ] ) ) { $ def = $ this -> definitions [ $ key ] ; $ this -> checkType ( $ def [ 'valid' ] , $ key , $ value ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ configuration [ $ key ] , $ configuration ) ; } } } return $ configuration ; }
6126	public function addRole ( $ item ) { if ( ! ( $ item instanceof Role ) ) { if ( is_array ( $ item ) ) { try { $ item = new Role ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Role. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Role"!' , E_USER_WARNING ) ; } } $ this -> roles [ ] = $ item ; return $ this ; }
12025	private function generateExecuteFragment ( ) { $ body = '' ; if ( $ this -> operationDefinition -> getNeedsSigning ( ) ) { $ body .= '$request = $this->api->signRequest($request);' . PHP_EOL ; } $ body .= '$response = $this->api->execute($request, $this);' . PHP_EOL ; $ body .= '$this->response = $response;' . PHP_EOL ; return $ body ; }
5385	public function isId ( $ id ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> widgets [ $ i ] -> isId ( $ id ) ) { return true ; } } return false ; }
5499	public function respond ( $ step , $ method , $ args ) { $ method = strtolower ( $ method ) ; if ( isset ( $ this -> at [ $ method ] [ $ step ] ) ) { if ( $ this -> at [ $ method ] [ $ step ] -> isMatch ( $ args ) ) { $ action = $ this -> at [ $ method ] [ $ step ] -> findFirstAction ( $ args ) ; if ( isset ( $ action ) ) { return $ action -> act ( ) ; } } } if ( isset ( $ this -> always [ $ method ] ) ) { $ action = $ this -> always [ $ method ] -> findFirstAction ( $ args ) ; if ( isset ( $ action ) ) { return $ action -> act ( ) ; } } return ; }
7562	protected function parse_pipe ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_PREFIX ) ; } else { return ( $ this -> token = self :: TOK_PIPE ) ; } }
11048	function add_system_var ( & $ datatree , $ index , $ last , $ key ) { $ datatree -> _key = $ key ; $ datatree -> _index = $ index ; $ datatree -> _rank = $ index + 1 ; $ datatree -> _odd = $ datatree -> _not_even = ( 1 == $ datatree -> _rank % 2 ) ; $ datatree -> _even = $ datatree -> _not_odd = ( 0 == $ datatree -> _rank % 2 ) ; $ datatree -> _first = ( 0 == $ index ) ; $ datatree -> _middle = ! $ datatree -> _first && ! $ last ; $ datatree -> _last = $ last ; $ datatree -> _not_first = ! $ datatree -> _first ; $ datatree -> _not_last = ! $ last ; $ datatree -> _not_middle = ! $ datatree -> _middle ; }
8312	public function handlePasswordReset ( Request $ httpRequest ) { $ this -> httpRequest = $ httpRequest ; $ this -> checkResetLink ( ) ; $ resetData = $ this -> session -> get ( "pwreset" ) ; if ( $ resetData === null ) { $ this -> beginPasswordReset ( ) ; } else { $ this -> finishPasswordReset ( $ resetData ) ; } }
9542	public function runSyncAction ( $ syncActionBaseUrl , $ component , $ action , array $ configData ) { $ uriParts = [ ] ; if ( $ this -> super ) { $ uriParts [ ] = $ this -> super ; } $ uriParts [ ] = $ component ; $ uriParts [ ] = 'action' ; $ uriParts [ ] = $ action ; $ uri = rtrim ( $ syncActionBaseUrl , '/' ) . '/' . implode ( '/' , $ uriParts ) ; $ body = [ 'configData' => $ configData , ] ; try { $ request = new Request ( 'POST' , $ uri , [ ] , json_encode ( $ body ) ) ; $ response = $ this -> guzzle -> send ( $ request ) ; } catch ( RequestException $ e ) { throw new ClientException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return $ this -> decodeResponse ( $ response ) ; }
3803	private function createProperty ( PropertyInterface $ property , $ propertyName , $ variantHandling , ConditionInterface $ condition = null , ConditionInterface $ legendCondition = null ) { $ paletteProperty = new Property ( $ propertyName ) ; $ extra = $ property -> getExtra ( ) ; $ chain = new PropertyConditionChain ( ) ; $ paletteProperty -> setEditableCondition ( $ chain ) ; if ( isset ( $ extra [ 'readonly' ] ) ) { $ chain -> addCondition ( new BooleanCondition ( $ extra [ 'readonly' ] ) ) ; } $ chain = new PropertyConditionChain ( ) ; $ paletteProperty -> setVisibleCondition ( $ chain ) ; if ( $ variantHandling ) { $ chain -> addCondition ( new IsVariantAttribute ( ) ) ; } $ chain -> addCondition ( new BooleanCondition ( ! ( ( isset ( $ extra [ 'doNotShow' ] ) && $ extra [ 'doNotShow' ] ) || ( isset ( $ extra [ 'hideInput' ] ) && $ extra [ 'hideInput' ] ) ) ) ) ; if ( null !== $ condition ) { $ chain -> addCondition ( $ condition ) ; } if ( null !== $ legendCondition ) { $ chain -> addCondition ( $ legendCondition ) ; } return $ paletteProperty ; }
738	protected function saveItems ( ) { $ items = [ ] ; foreach ( $ this -> items as $ name => $ item ) { $ items [ $ name ] = array_filter ( [ 'type' => $ item -> type , 'description' => $ item -> description , 'ruleName' => $ item -> ruleName , 'data' => $ item -> data , ] ) ; if ( isset ( $ this -> children [ $ name ] ) ) { foreach ( $ this -> children [ $ name ] as $ child ) { $ items [ $ name ] [ 'children' ] [ ] = $ child -> name ; } } } $ this -> saveToFile ( $ items , $ this -> itemFile ) ; }
6304	protected function process ( array $ nav ) { foreach ( $ nav as $ key => $ value ) { if ( ! isset ( $ value [ 'url' ] ) ) { $ nav [ $ key ] [ 'url' ] = $ this -> url -> to ( $ value [ 'slug' ] ) ; } unset ( $ nav [ $ key ] [ 'slug' ] ) ; } return $ nav ; }
9486	protected function checkFieldsSet ( $ fields ) { foreach ( $ fields as $ field ) { if ( property_exists ( $ this , $ field ) && $ this -> $ field === null ) { throw new \ Exception ( "'$field' is required" ) ; } } }
5151	protected function textAfterString ( $ haystack , $ needle ) { $ result = "" ; $ needleLength = strlen ( $ needle ) ; if ( $ needleLength > 0 && preg_match ( "#$needle([^\r\n]+)#i" , $ haystack , $ match ) ) { $ result = trim ( substr ( $ match [ 0 ] , - ( strlen ( $ match [ 0 ] ) - $ needleLength ) ) ) ; } return $ result ; }
8410	public function connect ( ) { if ( $ this -> isConnected ( ) === false ) { try { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'all' ] ) ; $ this -> servers [ 'all' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'all' ] [ 'user' ] , $ this -> servers [ 'all' ] [ 'pass' ] ) ; } else { $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'read' ] ) ; $ this -> servers [ 'read' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'read' ] [ 'user' ] , $ this -> servers [ 'read' ] [ 'pass' ] ) ; $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'write' ] ) ; $ this -> servers [ 'write' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'write' ] [ 'user' ] , $ this -> servers [ 'write' ] [ 'pass' ] ) ; } } catch ( \ PDOException $ e ) { throw new ExternalLink ( 'can\'t connect to database (' . $ e -> getMessage ( ) . ')' ) ; } } }
1538	public function willSeeOne ( $ request ) : bool { if ( $ this -> route -> isRelationship ( ) ) { return false ; } if ( $ this -> route -> isResource ( ) ) { return true ; } return $ request -> isMethod ( 'POST' ) ; }
8117	public function onBeforeWrite ( ) { $ changedFields = $ this -> owner -> getChangedFields ( true , 2 ) ; if ( $ changedFields ) { $ this -> owner -> LastEditedByName = $ this -> owner -> getEditorName ( ) ; $ this -> owner -> OwnerNames = $ this -> owner -> getOwnerNames ( ) ; } if ( $ this -> owner -> isChanged ( "ContentReviewType" , 2 ) ) { if ( $ this -> owner -> ContentReviewType == "Disabled" ) { $ this -> setDefaultReviewDateForDisabled ( ) ; } elseif ( $ this -> owner -> ContentReviewType == "Custom" ) { $ this -> setDefaultReviewDateForCustom ( ) ; } else { $ this -> setDefaultReviewDateForInherited ( ) ; } } if ( $ this -> owner -> ContentReviewType == "Inherit" && ! $ this -> owner -> NextReviewDate ) { $ this -> setDefaultReviewDateForInherited ( ) ; } if ( ! $ this -> owner -> exists ( ) ) { return ; } if ( $ this -> owner -> isChanged ( 'ReviewPeriodDays' , 2 ) ) { $ nextReviewUnixSec = strtotime ( ' + ' . $ this -> owner -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ this -> owner -> NextReviewDate = DBDate :: create ( ) -> setValue ( $ nextReviewUnixSec ) -> Format ( 'y-MM-dd' ) ; } }
12814	private static function getNullableNames ( string $ table ) : array { if ( self :: $ nullablesCache === null || ! array_key_exists ( $ table , self :: $ nullablesCache ) ) self :: getNullables ( $ table ) ; return array_keys ( self :: $ nullablesCache [ $ table ] ) ; }
7643	protected function parseMetadataHeaders ( $ headers = array ( ) ) { if ( ! is_array ( $ headers ) ) { return array ( ) ; } $ metadata = array ( ) ; foreach ( $ headers as $ key => $ value ) { if ( substr ( strtolower ( $ key ) , 0 , 10 ) == "x-ms-meta-" ) { $ metadata [ str_replace ( "x-ms-meta-" , '' , strtolower ( $ key ) ) ] = $ value ; } } return $ metadata ; }
5743	protected function parseContentType ( $ contentType ) { if ( false === stripos ( $ contentType , ';' ) ) { throw new ParserException ( 'ContentType does not contain a \';\'' ) ; } list ( $ mime , $ boundary ) = explode ( ';' , $ contentType , 2 ) ; list ( $ key , $ boundaryValue ) = explode ( '=' , trim ( $ boundary ) , 2 ) ; if ( 'boundary' != $ key ) { throw new ParserException ( 'Boundary does not start with \'boundary=\'' ) ; } return [ strtolower ( trim ( $ mime ) ) , $ boundaryValue ] ; }
1225	private function buildQueryParameters ( array $ paramValues ) { if ( empty ( $ paramValues ) ) { return '' ; } $ query = [ ] ; foreach ( $ paramValues as $ param => $ value ) { if ( is_array ( $ value ) ) { $ value = join ( ',' , $ value ) ; } elseif ( is_bool ( $ value ) ) { $ value = $ value ? 'true' : 'false' ; } elseif ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } $ query [ ] = $ param . '=' . urlencode ( $ value ) ; } return '?' . join ( '&' , $ query ) ; }
5386	public function isLabel ( $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> widgets [ $ i ] -> isLabel ( $ label ) ) { return true ; } } return false ; }
4259	public function getSubscribers ( $ eventName = null ) { if ( $ eventName !== null ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return array ( ) ; } if ( ! isset ( $ this -> sorted [ $ eventName ] ) ) { $ this -> sortSubscribers ( $ eventName ) ; } return $ this -> sorted [ $ eventName ] ; } foreach ( \ array_keys ( $ this -> subscribers ) as $ eventName ) { if ( ! isset ( $ this -> sorted [ $ eventName ] ) ) { $ this -> sortSubscribers ( $ eventName ) ; } } return \ array_filter ( $ this -> sorted ) ; }
5420	protected function parseCookie ( $ cookie_line ) { $ parts = explode ( ';' , $ cookie_line ) ; $ cookie = array ( ) ; preg_match ( '/\s*(.*?)\s*=(.*)/' , array_shift ( $ parts ) , $ cookie ) ; foreach ( $ parts as $ part ) { if ( preg_match ( '/\s*(.*?)\s*=(.*)/' , $ part , $ matches ) ) { $ cookie [ $ matches [ 1 ] ] = trim ( $ matches [ 2 ] ) ; } } return new SimpleCookie ( $ cookie [ 1 ] , trim ( $ cookie [ 2 ] ) , isset ( $ cookie [ 'path' ] ) ? $ cookie [ 'path' ] : '' , isset ( $ cookie [ 'expires' ] ) ? $ cookie [ 'expires' ] : false ) ; }
8176	public function actionRecoverPassword ( ) { $ model = new AccountRecoverPasswordForm ( ) ; if ( $ model -> load ( Yii :: $ app -> request -> post ( ) ) ) { if ( $ model -> validate ( ) ) { $ model -> recoverPassword ( ) ; } } return $ this -> render ( 'recoverPassword' , [ 'model' => $ model ] ) ; }
7824	public function getHalfWidth ( $ up = false ) { $ number = $ this -> getTotalWidth ( ) ; return $ this -> roundHalf ( $ number , $ up ) ; }
1748	protected function listSingleRecord ( $ id ) { if ( ! \ strlen ( $ this -> list_info_layout ) ) { $ this -> list_info_layout = 'info_default' ; } $ this -> Template = new FrontendTemplate ( $ this -> list_info_layout ) ; $ this -> Template -> record = array ( ) ; $ this -> Template -> referer = 'javascript:history.go(-1)' ; $ this -> Template -> back = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goBack' ] ; $ this -> list_info = StringUtil :: deserialize ( $ this -> list_info ) ; $ this -> list_info_where = $ this -> replaceInsertTags ( $ this -> list_info_where , false ) ; $ objRecord = $ this -> Database -> prepare ( "SELECT " . implode ( ', ' , array_map ( 'Database::quoteIdentifier' , trimsplit ( ',' , $ this -> list_info ) ) ) . " FROM " . $ this -> list_table . " WHERE " . ( ( $ this -> list_info_where != '' ) ? "(" . $ this -> list_info_where . ") AND " : "" ) . Database :: quoteIdentifier ( $ this -> strPk ) . "=?" ) -> limit ( 1 ) -> execute ( $ id ) ; if ( $ objRecord -> numRows < 1 ) { return ; } $ arrFields = array ( ) ; $ arrRow = $ objRecord -> row ( ) ; $ limit = \ count ( $ arrRow ) ; $ count = - 1 ; foreach ( $ arrRow as $ k => $ v ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'password' ) { -- $ limit ; continue ; } $ class = 'row_' . ++ $ count . ( ( $ count == 0 ) ? ' row_first' : '' ) . ( ( $ count >= ( $ limit - 1 ) ) ? ' row_last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' even' : ' odd' ) ; $ arrFields [ $ k ] = array ( 'raw' => $ v , 'label' => ( \ strlen ( $ label = $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ) ? $ label : $ k ) , 'content' => $ this -> formatValue ( $ k , $ v , true ) , 'class' => $ class ) ; } $ this -> Template -> record = $ arrFields ; }
4493	public function setLocalizedText ( ? string $ key , ? array $ arguments = null ) : self { $ this -> setLocalizedKey ( $ key ) ; $ this -> setLocalizedArguments ( $ arguments ) ; return $ this ; }
6175	public function rightJoin ( $ table , $ column , $ operator = null , $ value = null ) { if ( $ column instanceof \ Closure ) { $ where = new Where ( ) ; call_user_func_array ( $ column , [ & $ where ] ) ; } else { $ where = ( new Where ( ) ) -> where ( $ column , $ operator , $ value ) ; } $ this -> request [ 'rightJoin' ] [ $ table ] [ 'table' ] = $ table ; $ this -> request [ 'rightJoin' ] [ $ table ] [ 'where' ] = $ where ; return $ this ; }
1908	private function getArgumentName ( Request $ request , ArgumentMetadata $ argument ) : ? string { if ( $ request -> attributes -> has ( $ argument -> getName ( ) ) ) { return $ argument -> getName ( ) ; } $ className = lcfirst ( $ this -> stripNamespace ( $ argument -> getType ( ) ) ) ; if ( $ request -> attributes -> has ( $ className ) ) { return $ className ; } return null ; }
5307	protected function getPathFromPolygon ( SimpleXMLElement $ polygon ) { $ points = $ this -> getValuesFromList ( $ polygon [ 'points' ] ) ; $ path = 'M' . array_shift ( $ points ) . ' ' . array_shift ( $ points ) ; while ( count ( $ points ) ) { $ path .= 'L' . array_shift ( $ points ) . ' ' . array_shift ( $ points ) ; } return $ path . 'Z' ; }
2470	public function getMaxDepthForContent ( ContentType $ contentType ) : int { if ( isset ( $ this -> contentTypeMap [ $ contentType -> identifier ] ) ) { return $ this -> contentTypeMap [ $ contentType -> identifier ] ; } return $ this -> defaultIndexingDepth ; }
3674	private function extractPostData ( FilterUrl $ filterUrl , $ options , Request $ request ) : void { if ( empty ( $ options [ 'postAsSlug' ] ) && empty ( $ options [ 'postAsGet' ] ) ) { return ; } foreach ( $ request -> request -> all ( ) as $ name => $ value ) { if ( is_array ( $ value ) ) { $ value = implode ( ',' , $ value ) ; } if ( in_array ( $ name , $ options [ 'postAsSlug' ] ) ) { $ filterUrl -> setSlug ( $ name , $ value ) ; } if ( in_array ( $ name , $ options [ 'postAsGet' ] ) ) { $ filterUrl -> setGet ( $ name , $ value ) ; } } }
11098	public static function secondsBetweenWorkingDays ( $ dateFrom , $ dateTo , $ workDayFrom , $ workDayTo , $ weekends = false , $ holidays = false , $ timeZone = 'Europe/Prague' ) { $ timeZoneObj = new \ DateTimeZone ( $ timeZone ) ; $ dateFromObj = new DateTime ( $ dateFrom , $ timeZoneObj ) ; $ dateToObj = new DateTime ( $ dateTo , $ timeZoneObj ) ; $ workDayFromObj = new DateTime ( $ workDayFrom , $ timeZoneObj ) ; $ workDayToObj = new DateTime ( $ workDayTo , $ timeZoneObj ) ; $ workDayLength = self :: secondsBetweenDates ( $ workDayFrom , $ workDayTo , true , $ timeZone ) ; $ period = new \ DatePeriod ( new DateTime ( $ dateFromObj -> format ( 'Y-m-d 00:00:00' ) , $ timeZoneObj ) , new \ DateInterval ( 'P1D' ) , new DateTime ( $ dateToObj -> format ( 'Y-m-d 23:59:59' ) , $ timeZoneObj ) ) ; $ workedTime = 0 ; foreach ( $ period as $ date ) { if ( ( ! $ weekends && ( int ) $ date -> format ( 'N' ) > 5 ) || ( ! $ holidays && self :: isCzechHoliday ( $ date ) ) ) { continue ; } if ( $ date -> format ( 'Y-m-d' ) === $ dateFromObj -> format ( 'Y-m-d' ) ) { $ endOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayToObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateFromObj < $ endOfDay && $ dateFromObj -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ diff = $ dateToObj -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } else { $ diff = $ endOfDay -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } elseif ( $ date -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ startOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayFromObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateToObj > $ startOfDay ) { $ diff = $ startOfDay -> diff ( $ dateToObj ) -> format ( '%H:%I:%S' ) ; $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } } else { $ workedTime += $ workDayLength ; } } return $ workedTime ; }
4797	function fetch ( $ column = '' ) { $ this -> execute ( ) ; $ return = current ( $ this -> data ) ; next ( $ this -> data ) ; if ( $ return && $ column != '' ) { return $ return [ $ column ] ; } return $ return ; }
404	public function prepareHeaders ( $ requestHeaders ) { $ responseHeaders = [ ] ; if ( isset ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { if ( in_array ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] , true ) ) { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = $ requestHeaders [ 'Origin' ] ; } if ( in_array ( '*' , $ this -> cors [ 'Origin' ] , true ) ) { if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) && $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) { if ( YII_DEBUG ) { throw new InvalidConfigException ( "Allowing credentials for wildcard origins is insecure. Please specify more restrictive origins or set 'credentials' to false in your CORS configuration." ) ; } else { Yii :: error ( "Allowing credentials for wildcard origins is insecure. Please specify more restrictive origins or set 'credentials' to false in your CORS configuration." , __METHOD__ ) ; } } else { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = '*' ; } } } $ this -> prepareAllowHeaders ( 'Headers' , $ requestHeaders , $ responseHeaders ) ; if ( isset ( $ requestHeaders [ 'Access-Control-Request-Method' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Methods' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Request-Method' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Credentials' ] = $ this -> cors [ 'Access-Control-Allow-Credentials' ] ? 'true' : 'false' ; } if ( isset ( $ this -> cors [ 'Access-Control-Max-Age' ] ) && $ this -> request -> getIsOptions ( ) ) { $ responseHeaders [ 'Access-Control-Max-Age' ] = $ this -> cors [ 'Access-Control-Max-Age' ] ; } if ( isset ( $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Expose-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Allow-Headers' ] ) ; } return $ responseHeaders ; }
4249	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ value = null ; $ firePhpMeta = $ this -> getMeta ( $ method , $ meta ) ; if ( $ method == 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; $ value = $ args [ 0 ] ; } elseif ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ firePhpMeta [ 'Label' ] = $ args [ 0 ] ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ firePhpMeta [ 'Type' ] = \ is_array ( $ args [ 0 ] ) ? $ this -> firephpMethods [ 'table' ] : $ this -> firephpMethods [ 'log' ] ; $ value = $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ; if ( $ meta [ 'caption' ] ) { $ firePhpMeta [ 'Label' ] = $ meta [ 'caption' ] ; } } elseif ( $ method == 'trace' ) { $ firePhpMeta [ 'Type' ] = $ this -> firephpMethods [ 'table' ] ; $ value = $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ; $ firePhpMeta [ 'Label' ] = 'trace' ; } elseif ( \ count ( $ args ) ) { if ( \ count ( $ args ) == 1 ) { $ value = $ args [ 0 ] ; } else { $ firePhpMeta [ 'Label' ] = \ array_shift ( $ args ) ; $ value = \ count ( $ args ) > 1 ? $ args : $ args [ 0 ] ; } } $ value = $ this -> dump ( $ value ) ; if ( $ this -> messageIndex < self :: MESSAGE_LIMIT ) { $ this -> setFirephpHeader ( $ firePhpMeta , $ value ) ; } elseif ( $ this -> messageIndex === self :: MESSAGE_LIMIT ) { $ this -> setFirephpHeader ( array ( 'Type' => $ this -> firephpMethods [ 'warn' ] ) , 'FirePhp\'s limit of ' . \ number_format ( self :: MESSAGE_LIMIT ) . ' messages reached!' ) ; } return ; }
12614	public function have_required_properties ( ) { return ( ! empty ( $ this -> handle ) && ! empty ( $ this -> relative_path ) && ! empty ( $ this -> filename ) ) ; }
6855	private function transform ( SaleInterface $ sale ) { $ order = $ this -> newOrder ( ) ; $ this -> saleTransformer -> initialize ( $ sale , $ order ) ; if ( null === $ event = $ this -> saleTransformer -> transform ( ) ) { return $ order ; } return null ; }
9422	public function getMetadata ( $ key = null ) { isset ( $ this -> stream ) && $ this -> meta = stream_get_meta_data ( $ this -> stream ) ; $ metadata = isset ( $ this -> meta [ $ key ] ) ? $ this -> meta [ $ key ] : null ; return is_null ( $ key ) ? $ this -> meta : $ metadata ; }
12425	public function getAuthorizerToken ( $ appId , $ refreshToken ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ appId , 'authorizer_refresh_token' => $ refreshToken , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_TOKEN , $ params ] ) ; }
7271	public function delete ( ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; if ( isset ( $ this -> $ idColumn ) ) { $ status = Db :: query ( " delete from $tableName where $idColumn = :id " , [ "id" => $ this -> $ idColumn ] , static :: getDbName ( ) , false ) ; } else { $ condition = "" ; $ params = [ ] ; foreach ( $ columns as $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( isset ( $ this -> $ name ) ) { $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } } $ condition = substr ( $ condition , 0 , - 5 ) ; var_dump ( " delete from $tableName where $condition " ) ; var_dump ( $ params ) ; $ status = Db :: query ( " delete from $tableName where $condition " , $ params , static :: getDbName ( ) , false ) ; } return $ status !== false && $ status > 0 ; }
8783	protected function publishes ( array $ paths , $ group = null ) { $ this -> ensurePublishArrayInitialized ( $ class = static :: class ) ; static :: $ publishes [ $ class ] = array_merge ( static :: $ publishes [ $ class ] , $ paths ) ; if ( $ group ) { $ this -> addPublishGroup ( $ group , $ paths ) ; } }
11328	public function setFormField ( $ value ) { if ( is_array ( $ value ) ) { if ( is_null ( $ this -> formFieldClass ) ) { throw new Exception ( "DB Field incorrectly set up. What is the form class?" ) ; } if ( is_null ( $ this -> _formField ) ) { $ config = $ value ; $ config [ 'class' ] = $ this -> formFieldClass ; $ config [ 'modelField' ] = $ this ; $ value = Yii :: createObject ( $ config ) ; } else { $ settings = $ value ; $ value = $ this -> _formField ; unset ( $ settings [ 'class' ] ) ; Yii :: configure ( $ value , $ settings ) ; } } $ this -> _formField = $ value ; return true ; }
6464	public function isJson ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/application\/json/i" , $ contentType ) === 1 ; }
3430	protected function rememberInCache ( $ key , $ minutes , Closure $ callback ) { $ minutes = ( double ) $ minutes ; if ( $ minutes <= 0 ) { return $ callback ( ) ; } $ cache = Cache :: createInstance ( ) ; if ( $ cache -> initCache ( $ minutes * 60 , $ key , '/bitrix-models' ) ) { $ vars = $ cache -> getVars ( ) ; return ! empty ( $ vars [ 'isCollection' ] ) ? new Collection ( $ vars [ 'cache' ] ) : $ vars [ 'cache' ] ; } $ cache -> startDataCache ( ) ; $ result = $ callback ( ) ; $ isCollection = $ result instanceof Collection ; if ( $ isCollection ) { $ result = $ result -> all ( ) ; } $ cache -> endDataCache ( [ 'cache' => $ result , 'isCollection' => $ isCollection ] ) ; return $ isCollection ? new Collection ( $ result ) : $ result ; }
11111	public function migrate ( array $ options = [ ] ) : void { $ files = $ this -> getMigrationFiles ( M :: TYPE_UP ) ; $ migrations = $ this -> pendingMigrations ( $ files , $ this -> repository -> getRan ( ) ) ; $ this -> runPending ( $ migrations , $ options ) ; }
10205	public function setIndent ( $ pValue ) { if ( $ pValue > 0 ) { if ( $ this -> getHorizontal ( ) != self :: HORIZONTAL_GENERAL && $ this -> getHorizontal ( ) != self :: HORIZONTAL_LEFT && $ this -> getHorizontal ( ) != self :: HORIZONTAL_RIGHT ) { $ pValue = 0 ; } } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'indent' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> indent = $ pValue ; } return $ this ; }
10130	private function writeScenProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } if ( ! $ this -> phpSheet -> getProtection ( ) -> getScenarios ( ) ) { return ; } $ record = 0x00DD ; $ length = 0x0002 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , 1 ) ; $ this -> append ( $ header . $ data ) ; }
12474	public function getTheme ( $ identifier ) { $ themes = $ this -> getAvailableThemes ( ) ; if ( ! isset ( $ themes [ $ identifier ] ) ) { $ themeIds = array ( ) ; foreach ( $ themes as $ key => $ value ) { $ themeIds [ ] = $ key ; } throw new \ Exception ( sprintf ( 'Theme "%s" does not exist. Possible values are [%s]' , $ identifier , implode ( ', ' , $ themeIds ) ) , 1 ) ; } return $ themes [ $ identifier ] ; }
1829	public function delete ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ intAffected = Database :: getInstance ( ) -> prepare ( "DELETE FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) -> affectedRows ; if ( $ intAffected ) { Registry :: getInstance ( ) -> unregister ( $ this ) ; $ this -> arrData [ static :: $ strPk ] = null ; } return $ intAffected ; }
10325	protected function setOptions ( array $ options ) { if ( ! array_key_exists ( 'adapter' , $ options ) || ! array_key_exists ( 'table' , $ options ) || ! array_key_exists ( 'column_key' , $ options ) || ! array_key_exists ( 'column_value' , $ options ) ) { throw new Exception \ InvalidArgumentException ( 'Db adapter options must be defined "adapter", "table", "column_key" and "column_value" keys.' ) ; } if ( ! $ options [ 'adapter' ] instanceof Adapter ) { throw new Exception \ InvalidArgumentException ( 'Db adapter must be an instance of Zend\Db\Adapter\Adapter.' ) ; } $ this -> adapter = $ options [ 'adapter' ] ; $ options [ 'table' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'table' ] ) ; $ options [ 'column_key' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'column_key' ] ) ; $ options [ 'column_value' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'column_value' ] ) ; $ this -> options = $ options ; return $ this ; }
10943	public function encode ( $ rawString ) { $ bytes = unpack ( 'C*' , $ rawString ) ; $ byteCount = count ( $ bytes ) ; $ encodedString = '' ; $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; $ chars = $ this -> chars ; $ bitsPerCharacter = $ this -> bitsPerCharacter ; $ rightPadFinalBits = $ this -> rightPadFinalBits ; $ padFinalGroup = $ this -> padFinalGroup ; $ padCharacter = $ this -> padCharacter ; for ( $ c = 0 ; $ c < $ byteCount * 8 / $ bitsPerCharacter ; ++ $ c ) { if ( $ bitsRead + $ bitsPerCharacter > 8 ) { $ oldBitCount = 8 - $ bitsRead ; $ oldBits = $ byte ^ ( $ byte >> $ oldBitCount << $ oldBitCount ) ; $ newBitCount = $ bitsPerCharacter - $ oldBitCount ; if ( ! $ bytes ) { if ( $ rightPadFinalBits ) { $ oldBits <<= $ newBitCount ; } $ encodedString .= $ chars [ $ oldBits ] ; if ( $ padFinalGroup ) { $ lcmMap = array ( 1 => 1 , 2 => 1 , 3 => 3 , 4 => 1 , 5 => 5 , 6 => 3 , 7 => 7 , 8 => 1 ) ; $ bytesPerGroup = $ lcmMap [ $ bitsPerCharacter ] ; $ pads = $ bytesPerGroup * 8 / $ bitsPerCharacter - ceil ( ( strlen ( $ rawString ) % $ bytesPerGroup ) * 8 / $ bitsPerCharacter ) ; $ encodedString .= str_repeat ( $ padCharacter [ 0 ] , $ pads ) ; } break ; } $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; } else { $ oldBitCount = 0 ; $ newBitCount = $ bitsPerCharacter ; } $ bits = $ byte >> 8 - ( $ bitsRead + ( $ newBitCount ) ) ; $ bits ^= $ bits >> $ newBitCount << $ newBitCount ; $ bitsRead += $ newBitCount ; if ( $ oldBitCount ) { $ bits = ( $ oldBits << $ newBitCount ) | $ bits ; } $ encodedString .= $ chars [ $ bits ] ; } return $ encodedString ; }
4928	public function setListener ( $ event , $ service , $ method = null , $ priority = 0 ) { if ( is_int ( $ method ) ) { $ priority = $ method ; $ method = null ; } $ name = uniqid ( ) ; $ this -> listenerSpecs [ $ name ] = [ 'event' => $ event , 'service' => $ service , 'method' => $ method , 'priority' => $ priority , 'instance' => null , ] ; return $ this ; }
1867	private function validateSessionLifetime ( User $ user ) : void { if ( ! $ this -> session -> isStarted ( ) ) { return ; } $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ timeout = ( int ) $ config -> get ( 'sessionTimeout' ) ; if ( $ timeout > 0 && ( time ( ) - $ this -> session -> getMetadataBag ( ) -> getLastUsed ( ) ) < $ timeout ) { return ; } if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has been logged out automatically due to inactivity' , $ user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ user -> username ) ] ) ; } throw new UsernameNotFoundException ( sprintf ( 'User "%s" has been logged out automatically due to inactivity.' , $ user -> username ) ) ; }
10900	public function validate ( string $ method = 'save' ) : array { $ errors = [ ] ; foreach ( $ this -> getValidators ( ) [ $ method ] ?? [ ] as $ field => $ validator ) { try { $ validator -> setName ( $ field ) -> assert ( $ this -> get ( $ field ) ) ; } catch ( NestedValidationException $ e ) { $ errors [ $ field ] = $ e -> getMessages ( ) ; } } return $ errors ; }
5573	public function setField ( $ label , $ value , $ position = false ) { return $ this -> page -> setField ( new SelectByLabelOrName ( $ label ) , $ value , $ position ) ; }
10692	protected function getDialectStatement ( $ method , $ setTable = true ) { $ dialect = $ this -> getDialect ( ) ; if ( ! method_exists ( $ dialect , $ method ) ) { throw new BadMethodCallException ( Message :: get ( Message :: BUILDER_UNKNOWN_METHOD , $ method ) , Message :: BUILDER_UNKNOWN_METHOD ) ; } $ statement = call_user_func ( [ $ dialect , $ method ] , $ this ) ; if ( $ this -> hasPrevious ( ) ) { $ statement -> setPrevious ( $ this -> getPrevious ( ) ) ; $ this -> setPrevious ( null ) ; } elseif ( $ setTable && count ( $ this -> tables ) ) { if ( method_exists ( $ statement , 'from' ) ) { $ statement -> from ( $ this -> tables ) ; } else { $ statement -> into ( $ this -> tables [ array_keys ( $ this -> tables ) [ 0 ] ] ) ; } } return $ statement ; }
11905	public function getType ( ) { if ( is_null ( $ this -> _type ) ) { $ this -> _type = FieldTypeDetector :: detect ( $ this -> modelField ) ; } return $ this -> _type ; }
471	public function down ( ) { $ transaction = $ this -> db -> beginTransaction ( ) ; try { if ( $ this -> safeDown ( ) === false ) { $ transaction -> rollBack ( ) ; return false ; } $ transaction -> commit ( ) ; } catch ( \ Exception $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } catch ( \ Throwable $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } return null ; }
11364	public static function headerTagger ( $ name = '' , $ value = '' , $ adds = array ( ) ) { $ str = $ name . ': ' . $ value ; if ( count ( $ adds ) ) { foreach ( $ adds as $ n => $ v ) { $ str .= Mailer :: $ HEADERS_SEPARATOR . ( $ n == 'boundary' ? "\n\t" : '' ) . $ n . "=\"" . $ v . "\"" ; } } return ( trim ( $ str , Mailer :: $ HEADERS_SEPARATOR ) ) ; }
11753	public function close ( $ msgId , $ index ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CLOSE_COMMENT , $ params ] ) ; }
1273	public function isAmbiguous ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> AmbiguousAddressIndicator ) ; }
11000	public function selectLocaleFromAcceptHeader ( Accept $ header ) { $ my_locales = [ ] ; foreach ( $ this -> locales as $ supported_locale ) { $ list = $ supported_locale -> getFallbackList ( ) ; foreach ( $ list as $ locale ) $ my_locales [ $ locale -> getLocale ( ) ] = $ supported_locale -> getLocale ( ) ; } $ best = $ header -> getBestResponseType ( array_keys ( $ my_locales ) ) ; return empty ( $ best ) ? null : ( $ my_locales [ $ best ] ?? null ) ; }
11948	public function getSignature ( $ baseString , array $ params ) { unset ( $ params [ 'oauth_signature' ] ) ; if ( $ this -> signature_method === 'HMAC-SHA1' ) { $ result = $ this -> sign_HMAC_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'RSA-SHA1' ) { $ result = $ this -> sign_RSA_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'PLAINTEXT' ) { $ result = $ this -> sign_PLAINTEXT ( $ baseString ) ; } else { throw new ArtaxServiceException ( 'Unknown signature method: ' . $ this -> signature_method ) ; } return base64_encode ( $ result ) ; }
7615	private function encodeBearer ( $ consumer_key , $ consumer_secret ) { $ consumer_key = rawurlencode ( $ consumer_key ) ; $ consumer_secret = rawurlencode ( $ consumer_secret ) ; return base64_encode ( $ consumer_key . ':' . $ consumer_secret ) ; }
417	public function getETags ( ) { if ( $ this -> headers -> has ( 'If-None-Match' ) ) { return preg_split ( '/[\s,]+/' , str_replace ( '-gzip' , '' , $ this -> headers -> get ( 'If-None-Match' ) ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } return [ ] ; }
9448	public function getPackPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) ; } return $ paths [ $ me ] ; }
11168	public function getApiAsArray ( ) { if ( $ this -> useCache ( ) ) { if ( $ this -> getExtCache ( ) -> isApiCached ( ) ) { return $ this -> getExtCache ( ) -> getApi ( ) ; } } $ api = $ this -> generateApi ( ) ; if ( $ this -> useCache ( ) ) { $ this -> getExtCache ( ) -> cacheApi ( $ api ) ; } return $ api ; }
12654	public function getText ( $ name , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { return $ allTexts [ $ name ] ; } else { return null ; } }
10100	private function writeRichTextString ( $ row , $ col , $ str , $ xfIndex , $ arrcRun ) { $ record = 0x00FD ; $ length = 0x000A ; $ str = StringHelper :: UTF8toBIFF8UnicodeShort ( $ str , $ arrcRun ) ; if ( ! isset ( $ this -> stringTable [ $ str ] ) ) { $ this -> stringTable [ $ str ] = $ this -> stringUnique ++ ; } ++ $ this -> stringTotal ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvV' , $ row , $ col , $ xfIndex , $ this -> stringTable [ $ str ] ) ; $ this -> append ( $ header . $ data ) ; }
2836	public function getLayoutUpdates ( ) { if ( $ this -> uncompressedLayoutUpdates === null ) { $ this -> uncompressedLayoutUpdates = $ this -> layoutUpdates ? json_decode ( gzuncompress ( $ this -> layoutUpdates ) , true ) : array ( ) ; } return $ this -> uncompressedLayoutUpdates ; }
7794	protected function accountNumber ( $ text ) { if ( $ account = $ this -> getLine ( '25' , $ text ) ) { return ltrim ( substr ( $ account , 12 ) , '0' ) ; } return null ; }
6661	protected function getControllerMethod ( $ methodName ) { $ reflectionMethod = $ this -> reflectedController -> getMethod ( $ methodName ) ; $ reflectionMethod -> setAccessible ( true ) ; return function ( ) use ( $ reflectionMethod ) { return $ reflectionMethod -> invokeArgs ( $ this -> controller , func_get_args ( ) ) ; } ; }
3304	public function appendSignature ( array $ params = [ ] , $ timestamp = '' , $ noncestr = '' ) { $ params += [ 'app_id' => $ this -> appId , 'time_stamp' => $ timestamp ? : time ( ) , 'nonce_str' => $ noncestr ? : md5 ( uniqid ( ) ) ] ; if ( isset ( $ params [ 'app_key' ] ) ) { unset ( $ params [ 'app_key' ] ) ; } ksort ( $ params ) ; $ params [ 'sign' ] = strtoupper ( md5 ( http_build_query ( $ params + [ 'app_key' => $ this -> appKey ] ) ) ) ; return $ params ; }
8198	public function next ( ) { if ( ! isset ( $ this -> tokens [ ++ $ this -> current ] ) ) { throw new Twig_Error_Syntax ( 'Unexpected end of template.' , $ this -> tokens [ $ this -> current - 1 ] -> getLine ( ) , $ this -> source ) ; } return $ this -> tokens [ $ this -> current - 1 ] ; }
8582	public function setAny ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Any' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10998	public function getLineCount ( ) : int { $ ret = 0 ; $ fh = fopen ( $ this -> path , "r" ) ; while ( ! feof ( $ fh ) ) { $ buffer = fread ( $ fh , 8192 ) ; $ ret += substr_count ( $ buffer , PHP_EOL ) ; } fclose ( $ fh ) ; return $ ret ; }
6331	private function registerPostProcessor ( string $ type , string $ class ) : void { if ( \ class_exists ( $ class ) ) { $ interfaces = \ class_implements ( $ class ) ; if ( \ in_array ( PostProcessor :: class , $ interfaces , true ) ) { $ this -> postProcessorsMap [ $ type ] = $ class ; } else { throw new ConfigException ( "Class {$class} don't implement interface " . PostProcessor :: class ) ; } } else { throw new ConfigException ( "Class {$class} not found" ) ; } }
10261	public function getEmail ( $ person_name = null , $ domain = null ) { $ username = $ this -> getUsername ( $ person_name ) ; $ domains = [ ] ; $ domains [ ] = ! empty ( $ domain ) ? $ domain : $ this -> getDomain ( ) ; $ domains [ ] = 'gmail.com' ; $ domains [ ] = 'yahoo.com' ; $ domains [ ] = 'me.com' ; $ domains [ ] = 'msn.com' ; $ domains [ ] = 'hotmail.com' ; $ domain = $ this -> fromArray ( $ domains ) ; return preg_replace ( '/[^0-9a-z_A-Z.]/' , '' , strtolower ( $ username ) ) . '@' . $ domain ; }
73	public function authorizeOAuthInteractively ( $ originUrl , $ message = null ) { if ( $ message ) { $ this -> io -> writeError ( $ message ) ; } $ url = 'https://confluence.atlassian.com/bitbucket/oauth-on-bitbucket-cloud-238027431.html' ; $ this -> io -> writeError ( sprintf ( 'Follow the instructions on %s' , $ url ) ) ; $ this -> io -> writeError ( sprintf ( 'to create a consumer. It will be stored in "%s" for future use by Composer.' , $ this -> config -> getAuthConfigSource ( ) -> getName ( ) ) ) ; $ this -> io -> writeError ( 'Ensure you enter a "Callback URL" (http://example.com is fine) or it will not be possible to create an Access Token (this callback url will not be used by composer)' ) ; $ consumerKey = trim ( $ this -> io -> askAndHideAnswer ( 'Consumer Key (hidden): ' ) ) ; if ( ! $ consumerKey ) { $ this -> io -> writeError ( '<warning>No consumer key given, aborting.</warning>' ) ; $ this -> io -> writeError ( 'You can also add it manually later by using "composer config --global --auth bitbucket-oauth.bitbucket.org <consumer-key> <consumer-secret>"' ) ; return false ; } $ consumerSecret = trim ( $ this -> io -> askAndHideAnswer ( 'Consumer Secret (hidden): ' ) ) ; if ( ! $ consumerSecret ) { $ this -> io -> writeError ( '<warning>No consumer secret given, aborting.</warning>' ) ; $ this -> io -> writeError ( 'You can also add it manually later by using "composer config --global --auth bitbucket-oauth.bitbucket.org <consumer-key> <consumer-secret>"' ) ; return false ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return false ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; $ this -> config -> getAuthConfigSource ( ) -> removeConfigSetting ( 'http-basic.' . $ originUrl ) ; $ this -> io -> writeError ( '<info>Consumer stored successfully.</info>' ) ; return true ; }
8927	public function fetch ( $ name ) { $ generator = false ; if ( array_key_exists ( $ name , $ this -> generators ) ) { $ generator = $ this -> generators [ $ name ] ; } return $ generator ; }
2327	public function setRow ( array $ arrData ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ this -> arrModels [ $ this -> intIndex ] -> setRow ( $ arrData ) ; return $ this ; }
11983	public function getConfig ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> settings ) ? $ this -> settings [ $ name ] : $ default ; }
12162	public function getForm ( $ primaryModel = false , $ settings = [ ] ) { if ( ! $ primaryModel ) { return false ; } $ formSegments = [ $ this -> getFormSegment ( $ primaryModel , $ settings ) ] ; $ config = [ 'class' => $ this -> formGeneratorClass , 'models' => $ primaryModel -> collectModels ( ) , 'items' => $ formSegments ] ; return Yii :: createObject ( $ config ) ; }
6799	public function installCountries ( $ code = 'US' ) { $ countryNames = Intl :: getRegionBundle ( ) -> getCountryNames ( ) ; if ( ! isset ( $ countryNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default country code '$code'." ) ; } asort ( $ countryNames ) ; $ this -> generate ( Country :: class , $ countryNames , $ code ) ; }
4489	public function registerDevice ( string $ deviceId , string $ platform , ? string $ userData = null ) : string { if ( ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } try { $ args = [ 'PlatformApplicationArn' => $ this -> arns [ $ platform ] , 'Token' => $ deviceId , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ; if ( $ userData ) { $ args [ 'CustomUserData' ] = $ userData ; } $ res = $ this -> sns -> createPlatformEndpoint ( $ args ) ; } catch ( SnsException $ e ) { preg_match ( '/Endpoint (.+?) already/' , $ e -> getMessage ( ) , $ matches ) ; if ( isset ( $ matches [ 1 ] ) ) { $ this -> sns -> setEndpointAttributes ( [ 'EndpointArn' => $ matches [ 1 ] , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ) ; return $ matches [ 1 ] ; } else { throw $ e ; } } return $ res [ 'EndpointArn' ] ; }
10204	public function setShrinkToFit ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = false ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'shrinkToFit' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> shrinkToFit = $ pValue ; } return $ this ; }
9197	public function getTag ( ) { if ( null !== $ this -> tag ) { return $ this -> tag ; } $ categoryId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'categoryid' ) ; if ( is_numeric ( $ categoryId ) ) { return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ categoryId ) ; } $ topicId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'topicid' ) ; if ( is_numeric ( $ topicId ) ) { $ topic = $ this -> getDiscussService ( ) -> getTopicById ( $ topicId ) ; return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ topic -> getforumCategoryId ( ) ) ; } return false ; }
6060	public function retrieveFileData ( $ id , $ template = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'template' => $ template ] , 'body' => json_encode ( [ ] ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/asset' , $ parameters , $ cachePolicy ) ; return $ result ; }
12407	public function set ( $ key , $ value ) { try { $ filenameCache = $ this -> location . DS . $ key ; file_put_contents ( $ filenameCache , $ value ) ; } catch ( \ Exception $ e ) { return false ; } return true ; }
10416	protected function addStatusField ( Table $ table ) { if ( empty ( $ this -> shops ) ) { $ table -> addColumn ( 'status' , 'boolean' , [ 'default' => 0 ] ) -> setComment ( '0-new,1-done' ) ; $ table -> addIndex ( [ 'status' ] ) ; } else { foreach ( $ this -> shops as $ shop ) { $ fieldName = "status_{$shop}" ; $ table -> addColumn ( $ fieldName , 'boolean' , [ 'default' => 0 ] ) -> setComment ( '0-new,1-done' ) ; $ table -> addIndex ( [ $ fieldName ] ) ; } } }
1160	protected function fakeValidationData ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> validator -> getData ( ) ; $ this -> fakeFileData ( $ data , $ attribute ) ; $ this -> fakeRequiredIfData ( $ data , $ rule , $ parameters ) ; return $ data ; }
6772	protected function didInvoiceCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } if ( null !== $ newAddress = $ sale -> getInvoiceAddress ( ) ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
791	public function addErrors ( array $ items ) { foreach ( $ items as $ attribute => $ errors ) { if ( is_array ( $ errors ) ) { foreach ( $ errors as $ error ) { $ this -> addError ( $ attribute , $ error ) ; } } else { $ this -> addError ( $ attribute , $ errors ) ; } } }
10496	public function exp ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( pow ( $ this -> value , $ value ) ) ; }
5885	protected function renderDropdown ( ) { $ config = $ this -> dropdown ; $ config [ 'clientOptions' ] = false ; $ config [ 'view' ] = $ this -> getView ( ) ; return Dropdown :: widget ( $ config ) ; }
4625	public function prepare ( Command $ command , Node $ node ) { if ( $ this -> connection ) { $ this -> resetConnection ( ) ; } parent :: prepare ( $ command , $ node ) ; $ this -> buildPath ( ) ; $ this -> prepareConnection ( ) ; $ this -> prepareRequest ( ) ; return $ this ; }
278	private function notifyUnloaded ( $ fixtures ) { $ this -> stdout ( "\nFixtures were successfully unloaded from namespace: " , Console :: FG_YELLOW ) ; $ this -> stdout ( Yii :: getAlias ( $ this -> namespace ) . "\"\n\n" , Console :: FG_GREEN ) ; $ this -> outputList ( $ fixtures ) ; }
11674	public function setConfigurationOptions ( array $ options = array ( ) ) { $ resolver = new OptionsResolver ( ) ; $ resolver -> setDefined ( array ( 'web_dir' , 'uploads_dir' , ) ) ; $ resolver -> resolve ( $ options ) ; if ( array_key_exists ( 'web_dir' , $ options ) ) { $ this -> webDirname = $ options [ 'web_dir' ] ; } if ( array_key_exists ( 'uploads_dir' , $ options ) ) { $ this -> absoluteUploadAssetsDir = $ options [ 'uploads_dir' ] ; } }
9548	public function validate ( UploadedFile $ file ) { foreach ( $ this -> constraints as $ constraint ) { if ( ! $ constraint -> validate ( $ file ) ) { throw new ConstraintException ( $ constraint , $ file ) ; } } return true ; }
8068	public function connect ( ) { $ port = $ this -> ssl ? $ this :: PORT_SSL : $ this :: PORT ; $ hostname = $ this -> domainController -> getHostname ( ) ; return $ this -> connection = ldap_connect ( $ hostname , $ port ) ; }
3657	private function tryDispatch ( $ eventName , MetaModelsBootEvent $ event ) { $ dispatcher = System :: getContainer ( ) -> get ( 'event_dispatcher' ) ; if ( $ dispatcher -> hasListeners ( $ eventName ) ) { @ trigger_error ( 'Event "' . $ eventName . '" has been deprecated - Use registered services.' , E_USER_DEPRECATED ) ; $ dispatcher -> dispatch ( $ eventName , $ event ) ; } }
705	public function getDefaultRoleInstances ( ) { $ result = [ ] ; foreach ( $ this -> defaultRoles as $ roleName ) { $ result [ $ roleName ] = $ this -> createRole ( $ roleName ) ; } return $ result ; }
2335	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ this -> tokenStorage -> initialize ( $ this -> getTokensFromCookies ( $ event -> getRequest ( ) -> cookies ) ) ; }
9233	public function actionCreate ( ) { $ model = new Post ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> author_id = Yii :: $ app -> user -> id ; $ model -> isdel = 0 ; if ( Yii :: $ app -> request -> post ( ) ) { $ post = Yii :: $ app -> request -> post ( ) ; $ category = [ ] ; if ( isset ( $ post [ 'Post' ] [ 'category' ] ) ) { $ category = $ post [ 'Post' ] [ 'category' ] ; } if ( is_array ( $ post [ 'Post' ] [ 'tags' ] ) ) { $ post [ 'Post' ] [ 'tags' ] = implode ( "," , $ post [ 'Post' ] [ 'tags' ] ) ; } $ model -> load ( $ post ) ; $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> save ( ) ) { $ cs = BlogCatPos :: deleteAll ( "post_id = :id" , [ "id" => $ model -> id ] ) ; foreach ( $ category as $ d ) { $ c = new BlogCatPos ( ) ; $ c -> post_id = $ model -> id ; $ c -> category_id = $ d ; $ c -> isdel = 0 ; $ c -> save ( ) ; } $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ model -> id = array_merge ( $ category , [ ] ) ; $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } } return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; }
9224	public function setupToken ( $ token ) { if ( ! empty ( $ token ) ) { $ this -> headers [ 'Authorization' ] = "Bearer $token" ; return true ; } else { if ( $ this -> throw_exceptions ) { throw new CanvasPest_Exception ( 'API authorization token must be a non-zero-length string' , CanvasPest_Exception :: INVALID_TOKEN ) ; } return false ; } }
11691	public function getData ( $ origin ) { return array_reduce ( $ this -> structure -> getChildren ( ) , function ( $ acc , $ childDef ) { return array_merge ( $ acc , array ( $ childDef [ 'name' ] => $ childDef [ 'name' ] ) ) ; } , $ this -> getMetadataValues ( ) ) ; }
12632	public function query ( $ orderNo , $ type = self :: OUT_TRADE_NO ) { $ params = [ $ type => $ orderNo , ] ; return $ this -> request ( $ this -> wrapApi ( self :: API_QUERY ) , $ params ) ; }
9278	public function fetchByWhere ( $ where = null , array $ options = array ( ) ) { $ select = $ this -> sql -> select ( ) ; if ( $ where instanceof Where ) { $ select -> where ( $ where ) ; } elseif ( is_string ( $ where ) && ! empty ( $ where ) ) { $ select -> where ( $ where ) ; } $ limit = array_key_exists ( 'limit' , $ options ) ? ( int ) $ limit : null ; if ( ! is_null ( $ limit ) && ( int ) $ limit > 0 ) { $ select -> limit ( $ limit ) ; } $ stmt = $ this -> sql -> prepareStatementForSqlObject ( $ select ) ; $ result = $ stmt -> execute ( ) ; $ hydrate = array_key_exists ( 'hydrate' , $ options ) ? ( bool ) $ options [ 'hydrate' ] : true ; if ( $ hydrate !== true ) { return $ result ; } return $ this -> hydrateResult ( $ result ) ; }
11854	public function getHeader ( string $ name ) : ? string { $ name = strtolower ( $ name ) ; foreach ( $ this -> getAllHeaders ( ) as $ key => $ value ) { if ( strtolower ( $ key ) === $ name ) { return $ value ; } } return null ; }
6667	public function prepareResponse ( ) { if ( ! $ this -> writer ) { $ this -> writer = $ this -> writerFactory -> getWriterFor ( $ this -> request -> getFormats ( ) ) ; } $ this -> preparedResponse = $ this -> writer -> format ( $ this -> getBody ( ) , $ this -> responseName ) ; return $ this ; }
3852	public function setSorting ( $ strSortBy , $ strDirection = 'ASC' ) { $ this -> strSortBy = $ strSortBy ; $ this -> strSortDirection = ( $ strDirection == 'DESC' ) ? 'DESC' : 'ASC' ; return $ this ; }
3772	private function buildLanguageString ( $ name , $ screen , $ locale ) { if ( isset ( $ screen [ 'label' ] [ $ locale ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ $ locale ] ; return ; } $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ '' ] ; }
9083	private static function parseGetPostSessionCookie ( Request & $ request ) { foreach ( $ _GET as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _POST as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _COOKIE as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _FILES as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } if ( isset ( $ _SESSION ) ) { foreach ( $ _SESSION as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } } }
8757	public function run ( \ Traversable $ items , callable $ itemCallback ) { $ this -> start ( ) ; foreach ( $ items as $ item ) { call_user_func ( $ itemCallback , $ this , $ item ) ; } return $ this -> finish ( ) ; }
4382	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ str = '' ; $ str .= $ this -> processAlerts ( ) ; $ str .= $ this -> processSummary ( ) ; $ str .= $ this -> processLog ( ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
9901	public function parse ( $ formula ) { $ this -> currentCharacter = 0 ; $ this -> formula = $ formula ; $ this -> lookAhead = isset ( $ formula [ 1 ] ) ? $ formula [ 1 ] : '' ; $ this -> advance ( ) ; $ this -> parseTree = $ this -> condition ( ) ; return true ; }
3978	private function parseModelOperations ( Contao2BackendViewDefinitionInterface $ view ) { $ collection = $ view -> getModelCommands ( ) ; $ scrOffsetAttributes = [ 'attributes' => 'onclick="Backend.getScrollOffset();"' ] ; $ this -> createCommand ( $ collection , 'edit' , [ 'act' => 'edit' ] , 'edit.svg' ) ; $ this -> createCommand ( $ collection , 'copy' , [ 'act' => '' ] , 'copy.svg' , $ scrOffsetAttributes ) ; $ this -> createCommand ( $ collection , 'cut' , [ 'act' => 'paste' , 'mode' => 'cut' ] , 'cut.svg' , $ scrOffsetAttributes ) ; $ this -> createCommand ( $ collection , 'delete' , [ 'act' => 'delete' ] , 'delete.svg' , [ 'attributes' => sprintf ( 'onclick="if (!confirm(\'%s\')) return false; Backend.getScrollOffset();"' , $ this -> translator -> trans ( 'MSC.deleteConfirm' , [ ] , 'contao_default' ) ) ] ) ; $ this -> createCommand ( $ collection , 'show' , [ 'act' => 'show' ] , 'show.svg' ) ; if ( $ this -> factory -> getMetaModel ( $ this -> container -> getName ( ) ) -> hasVariants ( ) ) { $ this -> createCommand ( $ collection , 'createvariant' , [ 'act' => 'createvariant' ] , 'bundles/metamodelscore/images/icons/variants.png' ) ; } foreach ( $ this -> viewCombination -> getChildrenOf ( $ this -> container -> getName ( ) ) as $ tableName => $ screen ) { $ metaModel = $ this -> factory -> getMetaModel ( $ tableName ) ; $ caption = $ this -> getChildModelCaption ( $ metaModel , $ screen ) ; $ this -> createCommand ( $ collection , 'edit_' . $ tableName , [ 'table' => $ tableName ] , $ this -> iconBuilder -> getBackendIcon ( $ screen [ 'meta' ] [ 'backendicon' ] ) , [ 'label' => $ caption [ 0 ] , 'description' => $ caption [ 1 ] , 'idparam' => 'pid' ] ) ; } }
3949	private function buildCaption ( $ metaModel , $ inputScreen ) : array { $ caption = [ sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) , '' ] ; foreach ( $ inputScreen [ 'label' ] as $ langCode => $ label ) { if ( $ label !== '' && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ label , $ inputScreen [ 'description' ] [ $ langCode ] ] ; } } return $ caption ; }
7310	public static function solsticeSummer ( $ year ) { $ jd = static :: solsticeJune ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
4760	public function updateStats ( $ stats , $ delta = 1 , $ sampleRate = 1 ) { if ( ! is_array ( $ stats ) ) { $ stats = array ( $ stats ) ; } $ data = array ( ) ; foreach ( $ stats as $ stat ) { $ data [ $ stat ] = "$delta|c" ; } $ this -> queue ( $ data , $ sampleRate ) ; }
4091	public function createPayload ( ) { $ payloads = array ( ) ; foreach ( $ this -> operations as $ operation ) { foreach ( $ operation as $ partial ) { $ payloads [ ] = json_encode ( $ partial ) ; } } return join ( "\n" , $ payloads ) . "\n" ; }
8021	public function payload ( array $ payload ) { $ client = new GuzzleClient ( [ 'base_uri' => $ this -> server ] ) ; $ client -> request ( 'POST' , $ this -> getUri ( ) , [ 'form_params' => [ 'payload' => json_encode ( $ payload ) ] ] ) ; }
10777	private function total_size ( ) { $ arr = array ( "width" => 0 , "height" => 0 ) ; foreach ( $ this -> images as $ image ) { if ( $ arr [ "width" ] < $ image [ "width" ] ) { $ arr [ "width" ] = $ image [ "width" ] ; } $ arr [ "height" ] += $ image [ "height" ] ; } return $ arr ; }
11871	public function buildForm ( FormBuilderInterface $ builder , CustomField $ customField ) { $ options = $ customField -> getOptions ( ) ; $ type = ( $ options [ self :: MAX_LENGTH ] < 256 ) ? 'text' : 'textarea' ; $ attrArray = array ( ) ; if ( array_key_exists ( self :: MULTIPLE_CF_INLINE , $ options ) and $ options [ self :: MULTIPLE_CF_INLINE ] ) { $ attrArray [ 'class' ] = 'multiple-cf-inline' ; } $ builder -> add ( $ customField -> getSlug ( ) , $ type , array ( 'label' => $ this -> translatableStringHelper -> localize ( $ customField -> getName ( ) ) , 'required' => false , 'attr' => $ attrArray ) ) ; }
7460	public function lookup ( $ hash , $ className = 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) { try { return $ this -> hashedEntityHelper -> lookup ( $ hash , $ className ) ; } catch ( \ RuntimeException $ e ) { return null ; } }
5694	public function index ( HTTPRequest $ r ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/betterbuttons_nested_form.css' ) ; return $ this -> customise ( array ( 'Form' => $ this -> Form ( ) ) ) -> renderWith ( BetterButtonNestedForm :: class ) ; }
2329	public function delete ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } return $ this -> arrModels [ $ this -> intIndex ] -> delete ( ) ; }
11950	private function buildAuthorizationHeader ( array $ params ) { foreach ( $ params as $ key => $ value ) { $ params [ $ key ] = $ key . '="' . rawurlencode ( $ value ) . '"' ; } if ( $ this -> realm ) { array_unshift ( $ params , 'realm="' . rawurlencode ( $ this -> realm ) . '"' ) ; } return [ 'Authorization' , 'OAuth ' . implode ( ', ' , $ params ) ] ; }
819	private function isCommentLastLineToken ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isComment ( ) || ! $ tokens [ $ index + 1 ] -> isWhitespace ( ) ) { return false ; } $ content = $ tokens [ $ index + 1 ] -> getContent ( ) ; return $ content !== ltrim ( $ content , "\r\n" ) ; }
6053	public function retrieveParents ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders/' . $ id . '/parents' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderParent ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12844	protected function loadAnswerMatching ( ) { if ( $ this -> input -> hasOption ( 'load-choice-matching' ) ) { $ fs = new Filesystem ( ) ; $ filename = $ this -> input -> getOption ( 'load-choice-matching' ) ; if ( ! $ fs -> exists ( $ filename ) ) { $ this -> logger -> warning ( "The file $filename is not found. Choice matching not loaded" ) ; } else { $ this -> logger -> debug ( "Loading $filename as choice matching" ) ; $ this -> cacheAnswersMapping = \ json_decode ( \ file_get_contents ( $ filename ) , true ) ; } } }
12670	public function stream_open ( $ path ) { $ scheme = parse_url ( $ path , PHP_URL_SCHEME ) ; if ( substr ( $ scheme , - 10 ) === '-emulation' ) { $ scheme = substr ( $ scheme , 0 , - 10 ) ; } $ emulator = static :: getEmulatorInstance ( $ scheme , $ path , $ this -> getContext ( ) ) ; if ( ! $ emulator ) { return false ; } $ this -> setEmulator ( $ emulator ) ; $ this -> getEmulator ( ) -> setResponseStream ( $ this -> callEmulation ( $ this -> getEmulator ( ) -> getIncomingStream ( ) ) ) ; $ this -> setResponse ( $ this -> getEmulator ( ) -> getOutgoingStream ( ) ) ; return true ; }
9019	public function getKeywords ( $ string , $ amount = 10 ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ keywords = $ analysis -> getKeyValuesByFrequency ( ) ; return array_slice ( $ keywords , 0 , $ amount ) ; }
11771	private function retryCommandOnFailure ( CommandInterface $ command , $ method ) { $ retries = 0 ; SENTINEL_RETRY : { try { $ response = $ this -> getConnectionByCommand ( $ command ) -> $ method ( $ command ) ; } catch ( CommunicationException $ exception ) { $ this -> wipeServerList ( ) ; $ exception -> getConnection ( ) -> disconnect ( ) ; if ( $ retries == $ this -> retryLimit ) { throw $ exception ; } usleep ( $ this -> retryWait * 1000 ) ; ++ $ retries ; goto SENTINEL_RETRY ; } } return $ response ; }
8518	public function setSelectionRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SelectionRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3388	public function redirectAfterConfirmationPath ( ) { if ( method_exists ( $ this , 'redirectConfirmationTo' ) ) { return $ this -> redirectConfirmationTo ( ) ; } return property_exists ( $ this , 'redirectConfirmationTo' ) ? $ this -> redirectConfirmationTo : route ( 'login' ) ; }
5089	public function queryMapRow ( $ key = 0 , $ removeColumnFromRow = false ) { $ fetchMode = $ this -> resolveFetchMode ( is_string ( $ key ) ) ; $ result = $ this -> execute ( ) ; $ map = [ ] ; try { while ( $ row = $ result -> fetch ( $ fetchMode ) ) { if ( ! isset ( $ row [ $ key ] ) ) throw new MySqlException ( "Key '$key' column not found in the query result: " . implode ( array_keys ( $ row ) ) ) ; if ( $ removeColumnFromRow ) { $ map [ $ row [ $ key ] ] = $ row ; unset ( $ map [ $ row [ $ key ] ] [ $ key ] ) ; } else { $ map [ $ row [ $ key ] ] = $ row ; } } } finally { $ result -> closeCursor ( ) ; } return $ map ; }
5096	public function queryExists ( ) { foreach ( $ this -> selects as $ select ) { $ result = $ select -> queryExists ( ) ; if ( is_null ( $ result ) || $ result ) { return $ result ; } } return false ; }
7858	private function registerPipelineRepository ( ) { $ abstract = 'Cerbero\Workflow\Repositories\PipelineRepositoryInterface' ; $ this -> app -> bind ( $ abstract , function ( $ app ) { return new YamlPipelineRepository ( new SymfonyYamlParser , new \ Illuminate \ Filesystem \ Filesystem , config ( 'workflow.path' ) ) ; } ) ; }
7123	protected function updateTicket ( TicketMessageInterface $ message ) { $ ticket = $ message -> getTicket ( ) -> setUpdatedAt ( new \ DateTime ( ) ) ; if ( $ message -> isLatest ( ) && ( $ ticket -> getState ( ) !== TicketStates :: STATE_CLOSED ) ) { if ( $ message -> isCustomer ( ) ) { if ( $ ticket -> getState ( ) === TicketStates :: STATE_PENDING ) { $ ticket -> setState ( TicketStates :: STATE_OPENED ) ; } } elseif ( $ ticket -> getState ( ) === TicketStates :: STATE_OPENED ) { $ ticket -> setState ( TicketStates :: STATE_PENDING ) ; } } $ this -> persistenceHelper -> persistAndRecompute ( $ ticket , false ) ; }
11263	protected function isUnique ( $ instance ) { foreach ( $ this -> getCollection ( ) as $ entry ) { if ( $ entry -> getAnnotatedName ( ) === $ instance -> getAnnotatedName ( ) ) { return false ; } } return true ; }
6370	public static function forMap ( array $ map ) : callable { return function ( $ index ) use ( $ map ) { Preconditions :: checkArgument ( array_key_exists ( $ index , $ map ) , "The given key '%s' does not exist in the map" , $ index ) ; return $ map [ $ index ] ; } ; }
5133	public static function create ( string $ string = '' ) : \ One \ Uri { if ( empty ( $ string ) ) { $ string = '/' ; } return self :: createFromString ( $ string ) ; }
7152	public function copy ( SubjectIdentity $ identity ) { $ this -> provider = $ identity -> getProvider ( ) ; $ this -> identifier = $ identity -> getIdentifier ( ) ; }
6723	protected function validateAuthParams ( ) { if ( empty ( $ this -> authUrl ) || filter_var ( $ this -> authUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_AUTH_URL , $ this -> authUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
7791	public function setClosingBalanceClass ( $ closingBalanceClass ) { if ( ! is_callable ( $ closingBalanceClass ) && ! class_exists ( $ closingBalanceClass ) ) { throw new \ InvalidArgumentException ( '$closingBalanceClass must be a valid classname or a PHP callable' ) ; } $ this -> closingBalanceClass = $ closingBalanceClass ; return $ this ; }
993	public static function isValidLiteralValue ( Type $ type , $ valueNode ) { $ emptySchema = new Schema ( [ ] ) ; $ emptyDoc = new DocumentNode ( [ 'definitions' => [ ] ] ) ; $ typeInfo = new TypeInfo ( $ emptySchema , $ type ) ; $ context = new ValidationContext ( $ emptySchema , $ emptyDoc , $ typeInfo ) ; $ validator = new ValuesOfCorrectType ( ) ; $ visitor = $ validator -> getVisitor ( $ context ) ; Visitor :: visit ( $ valueNode , Visitor :: visitWithTypeInfo ( $ typeInfo , $ visitor ) ) ; return $ context -> getErrors ( ) ; }
621	protected function splitCondition ( InCondition $ condition , & $ params ) { $ operator = $ condition -> getOperator ( ) ; $ values = $ condition -> getValues ( ) ; $ column = $ condition -> getColumn ( ) ; if ( $ values instanceof \ Traversable ) { $ values = iterator_to_array ( $ values ) ; } if ( ! is_array ( $ values ) ) { return null ; } $ maxParameters = 1000 ; $ count = count ( $ values ) ; if ( $ count <= $ maxParameters ) { return null ; } $ slices = [ ] ; for ( $ i = 0 ; $ i < $ count ; $ i += $ maxParameters ) { $ slices [ ] = $ this -> queryBuilder -> createConditionFromArray ( [ $ operator , $ column , array_slice ( $ values , $ i , $ maxParameters ) ] ) ; } array_unshift ( $ slices , ( $ operator === 'IN' ) ? 'OR' : 'AND' ) ; return $ this -> queryBuilder -> buildCondition ( $ slices , $ params ) ; }
10945	public function onPrerenderPost ( PrerenderEvent $ events ) { $ cache = $ this -> getServiceLocator ( ) -> get ( $ this -> moduleOptions -> getCacheKey ( ) ) ; $ response = $ events -> getResponse ( ) ; $ key = $ this -> getCacheEntryKey ( $ events -> getRequest ( ) ) ; $ cache -> setItem ( $ key , $ events -> getResponse ( ) ) ; return $ this ; }
6916	public function removeAttachment ( AttachmentInterface $ attachment ) { if ( $ this -> attachments -> contains ( $ attachment ) ) { $ this -> attachments -> removeElement ( $ attachment ) ; } return $ this ; }
494	public function flush ( $ final = false ) { $ messages = $ this -> messages ; $ this -> messages = [ ] ; if ( $ this -> dispatcher instanceof Dispatcher ) { $ this -> dispatcher -> dispatch ( $ messages , $ final ) ; } }
4783	public function getModule ( ) { if ( ! is_object ( $ this -> _module ) ) { $ this -> _module = Yii :: $ app -> getModule ( $ this -> _module ) ; } return $ this -> _module ; }
6557	protected function mapLogLevelToStyle ( $ logLevel ) { if ( isset ( $ this -> logLevelStyleMapping [ $ logLevel ] ) ) { return $ this -> logLevelStyleMapping [ $ logLevel ] ; } return Simple :: DEFAULT_STYLE ; }
6758	private function messageInMessage ( string $ message ) : string { $ decodedMessage = json_decode ( $ message , true ) ; if ( is_array ( $ decodedMessage ) && isset ( $ decodedMessage [ 'message' ] ) && is_string ( $ decodedMessage [ 'message' ] ) ) { return $ decodedMessage [ 'message' ] ; } return $ message ; }
12498	public static function insertOne ( $ document , $ connection ) { $ connection -> query = self :: singleDocument ( $ document ) ; return self :: insert ( $ connection ) ; }
4304	public function profileEnd ( $ name = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) ) ; if ( $ meta [ 'name' ] === null ) { \ end ( $ this -> data [ 'profileInstances' ] ) ; $ meta [ 'name' ] = \ key ( $ this -> data [ 'profileInstances' ] ) ; } $ name = $ meta [ 'name' ] ; if ( isset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ) { $ instance = $ this -> data [ 'profileInstances' ] [ $ name ] ; $ data = $ instance -> end ( ) ; $ caption = 'Profile \'' . $ name . '\' Results' ; if ( $ data ) { $ args = array ( $ data ) ; $ meta [ 'sortable' ] = true ; $ meta [ 'caption' ] = $ caption ; $ meta [ 'totalCols' ] = array ( 'ownTime' ) ; $ meta [ 'columns' ] = array ( ) ; } else { $ args = array ( $ caption , 'no data' ) ; } unset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ; } else { $ args = array ( $ name !== null ? 'profileEnd: No such Profile: ' . $ name : 'profileEnd: Not currently profiling' ) ; } $ this -> appendLog ( __FUNCTION__ , $ args , $ meta ) ; }
6746	public function getCatalogue ( $ locale = null ) { if ( $ this -> translator instanceof TranslatorBagInterface ) { return $ this -> translator -> getCatalogue ( $ locale ) ; } return null ; }
5914	public function updateLastLogin ( $ id , $ successful = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'successful' => $ successful ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/registerloginattempt' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
11578	public function actionResend ( ) { if ( $ this -> module -> enableConfirmation == false ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( ResendForm :: className ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> resend ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'A new confirmation link has been sent' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'resend' , [ 'model' => $ model ] ) ; }
18	private function getPackageTime ( PackageInterface $ package ) { if ( ! function_exists ( 'proc_open' ) ) { return null ; } $ path = realpath ( $ this -> installationManager -> getInstallPath ( $ package ) ) ; $ sourceType = $ package -> getSourceType ( ) ; $ datetime = null ; if ( $ path && in_array ( $ sourceType , array ( 'git' , 'hg' ) ) ) { $ sourceRef = $ package -> getSourceReference ( ) ? : $ package -> getDistReference ( ) ; switch ( $ sourceType ) { case 'git' : GitUtil :: cleanEnv ( ) ; if ( 0 === $ this -> process -> execute ( 'git log -n1 --pretty=%ct ' . ProcessExecutor :: escape ( $ sourceRef ) , $ output , $ path ) && preg_match ( '{^\s*\d+\s*$}' , $ output ) ) { $ datetime = new \ DateTime ( '@' . trim ( $ output ) , new \ DateTimeZone ( 'UTC' ) ) ; } break ; case 'hg' : if ( 0 === $ this -> process -> execute ( 'hg log --template "{date|hgdate}" -r ' . ProcessExecutor :: escape ( $ sourceRef ) , $ output , $ path ) && preg_match ( '{^\s*(\d+)\s*}' , $ output , $ match ) ) { $ datetime = new \ DateTime ( '@' . $ match [ 1 ] , new \ DateTimeZone ( 'UTC' ) ) ; } break ; } } return $ datetime ? $ datetime -> format ( DATE_RFC3339 ) : null ; }
6543	public function current ( ) { $ this -> prepareQuery ( ) ; if ( false !== current ( $ this -> idsArray ) ) { return current ( $ this -> idsArray ) ; } else { throw new PointerException ( 'Can\'t retrieve the current element' ) ; } }
6396	public function run ( ) : void { $ thrownException = null ; try { $ this -> lock -> lock ( ) ; try { $ this -> runnable -> run ( ) ; } catch ( Exception $ e ) { self :: getLogger ( ) -> error ( $ e ) ; $ thrownException = $ e ; } $ this -> lock -> unLock ( ) ; } catch ( LockException $ e ) { throw new RunException ( 'Lock error during running.' , 0 , $ e ) ; } if ( $ thrownException !== null ) { throw new RunException ( 'Error during execution wrapped Runnable object.' , 0 , $ thrownException ) ; } }
9287	public function drop ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ DropTable ( self :: TABLE_NAME ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
12563	public function sendNews ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_NEWS , $ message , $ to ) ; }
1990	protected function jumpToOrReload ( $ intId , $ strParams = null , $ strForceLang = null ) { if ( $ strForceLang !== null ) { @ trigger_error ( 'Using Frontend::jumpToOrReload() with $strForceLang has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; } global $ objPage ; $ blnForceRedirect = ( $ strParams !== null || $ strForceLang !== null ) ; if ( \ is_array ( $ intId ) ) { $ intId = $ intId [ 'id' ] ?? 0 ; } if ( $ intId > 0 && ( $ intId != $ objPage -> id || $ blnForceRedirect ) && ( $ objNextPage = PageModel :: findPublishedById ( $ intId ) ) !== null ) { $ this -> redirect ( $ objNextPage -> getFrontendUrl ( $ strParams , $ strForceLang ) ) ; } $ this -> reload ( ) ; }
9015	function getRoot ( ) { $ sm = $ this -> sl -> getServiceLocator ( ) ; $ event = $ sm -> get ( 'Application' ) -> getMvcEvent ( ) ; return $ event -> getViewModel ( ) ; }
7063	protected function getAcceptedStates ( PaymentInterface $ payment ) { $ acceptedStates = PaymentStates :: getPaidStates ( ) ; if ( $ payment -> getMethod ( ) -> isOutstanding ( ) ) { $ acceptedStates [ ] = PaymentStates :: STATE_EXPIRED ; } return $ acceptedStates ; }
5638	public function shouldInvoke ( $ test_case , $ method ) { if ( $ this -> shouldRunTest ( $ test_case , $ method ) ) { return $ this -> reporter -> shouldInvoke ( $ test_case , $ method ) ; } return false ; }
5311	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing HTML file to "' . $ outputFile . '" ...' ) ; if ( $ input -> getOption ( 'as-list' ) ) { $ html = $ this -> getHTMLListFromGenerator ( $ generator , basename ( $ fontFile ) ) ; } else { $ html = $ this -> getHTMLFromGenerator ( $ generator , basename ( $ fontFile ) ) ; } file_put_contents ( $ outputFile , $ html ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created HTML info page successfully</success>' ) ; }
12597	public function getCacheAdapter ( $ namespace ) { if ( ! $ this -> isCacheable ( $ namespace ) ) { return null ; } if ( is_array ( $ this -> cacheOptions -> getAdapter ( ) ) ) { if ( ! isset ( $ this -> cacheOptions -> getAdapter ( ) [ $ namespace ] ) ) { return null ; } $ adapter = $ this -> cacheOptions -> getAdapter ( ) [ $ namespace ] ; } else { $ adapter = $ this -> cacheOptions -> getAdapter ( ) ; } if ( is_object ( $ adapter ) ) { return $ adapter ; } if ( $ this -> getServiceLocator ( ) -> has ( $ adapter ) ) { return $ this -> getServiceLocator ( ) -> get ( $ adapter ) ; } return new $ adapter ; }
12677	public function approveRemoval ( $ sourceDir , array $ options , $ username ) { $ this -> init ( $ sourceDir , $ options , $ username ) ; $ targetFilename = sprintf ( '%s/blocks/%s.json' , $ this -> productionDir , $ options [ 'blockname' ] ) ; if ( ! file_exists ( $ targetFilename ) ) { return ; } Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVING_REMOVAL , new BlockApprovingRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; $ this -> filesystem -> remove ( $ targetFilename ) ; $ slotDefinition = $ this -> getSlotDefinition ( $ this -> productionDir ) ; $ blocks = $ slotDefinition [ "blocks" ] ; $ key = array_search ( $ options [ 'blockname' ] , $ blocks ) ; unset ( $ blocks [ $ key ] ) ; $ slotDefinition [ "blocks" ] = $ blocks ; $ this -> saveSlotDefinition ( $ this -> productionDir , $ slotDefinition , $ username ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVED_REMOVAL , new BlockApprovedRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been approved for removal on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
2923	public function lines ( ) { $ content = [ ] ; $ lines = $ this -> readLinesFromFile ( ) ; foreach ( $ lines as $ row => $ line ) { $ data = [ 'line' => $ row + 1 , 'raw_data' => $ line , 'parsed_data' => $ this -> formatter -> parseLine ( $ line ) ] ; $ content [ ] = $ data ; } return $ content ; }
5729	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; foreach ( $ this -> children as $ child ) { if ( ! $ child instanceof BetterButton && ! $ child instanceof BetterButtonAction ) { throw new Exception ( "DropdownFormAction must be passed instances of BetterButton" ) ; } $ child -> bindGridField ( $ form , $ request ) ; $ child -> setIsGrouped ( true ) ; if ( $ child instanceof FormAction ) { $ child -> setUseButtonTag ( true ) ; } } return $ this ; }
8882	private function isValidGlobalCommand ( string $ command ) : bool { $ valid = false ; if ( strlen ( $ command ) ) { foreach ( $ this -> paths as $ pathDir ) { $ tmpPath = $ pathDir . DIRECTORY_SEPARATOR . $ command ; if ( $ this -> isValidFullPath ( $ tmpPath ) ) { $ valid = true ; break ; } } } return $ valid ; }
2089	public static function findPublishedBySourceAndParent ( $ strSource , $ intParent , $ blnDesc = false , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.source=? AND $t.parent=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = ( $ blnDesc ? "$t.date DESC" : "$t.date" ) ; } return static :: findBy ( $ arrColumns , array ( $ strSource , ( int ) $ intParent ) , $ arrOptions ) ; }
8650	private function getFormattedTimestamp ( $ dateTime ) { if ( ! $ dateTime instanceof DateTime ) { $ dateTime = new DateTime ( $ dateTime ) ; } return $ dateTime -> format ( DATE_ISO8601 ) ; }
9592	public function checkboxFilled ( $ options = [ ] , $ enclosedByLabel = true ) { Html :: addCssClass ( $ options , $ this -> checkboxFilledCssClass ) ; return parent :: checkbox ( $ options , $ enclosedByLabel ) ; }
9360	protected function middleware ( FinalCallback $ callback , ServerRequestInterface $ request ) { $ response = $ this -> container -> get ( self :: RESPONSE ) ; if ( interface_exists ( Application :: MIDDLEWARE ) === true ) { $ middleware = new Dispatcher ( $ this -> middlewares , $ response ) ; $ delegate = new Delegate ( $ callback ) ; $ result = $ middleware -> process ( $ request , $ delegate ) ; } return isset ( $ result ) ? $ result : $ callback ( $ request ) ; }
7416	public function getMaxFileSize ( ) : int { $ iniMax = strtolower ( ini_get ( 'upload_max_filesize' ) ) ; if ( '' === $ iniMax ) { return PHP_INT_MAX ; } $ max = ltrim ( $ iniMax , '+' ) ; if ( 0 === strpos ( $ max , '0x' ) ) { $ max = intval ( $ max , 16 ) ; } elseif ( 0 === strpos ( $ max , '0' ) ) { $ max = intval ( $ max , 8 ) ; } else { $ max = ( int ) $ max ; } switch ( substr ( $ iniMax , - 1 ) ) { case 't' : $ max *= 1024 ; case 'g' : $ max *= 1024 ; case 'm' : $ max *= 1024 ; case 'k' : $ max *= 1024 ; } return $ max ; }
2672	public function upsertDictionaryItem ( $ dictionaryId , $ itemKey , $ itemValue ) { $ body = [ 'item_value' => $ itemValue ] ; $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/item/' . urlencode ( $ itemKey ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ body ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create Dictionary item.' ) ) ; } }
5639	public function paintGroupStart ( $ test_name , $ size ) { if ( ! isset ( $ this -> size ) ) { $ this -> size = $ size ; } if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintHeader ( $ test_name ) ; } $ this -> test_stack [ ] = $ test_name ; }
5141	public function run ( ) : void { $ request = $ request = ServerRequestFactory :: fromGlobals ( ) ; $ response = $ this -> process ( $ request ) ; $ emitter = $ this -> getContainer ( ) -> has ( EmitterInterface :: class ) ? $ this -> getContainer ( ) -> get ( EmitterInterface :: class ) : new SapiEmitter ( ) ; $ emitter -> emit ( $ response ) ; }
37	protected function printLicenses ( CompletePackageInterface $ package ) { $ spdxLicenses = new SpdxLicenses ( ) ; $ licenses = $ package -> getLicense ( ) ; $ io = $ this -> getIO ( ) ; foreach ( $ licenses as $ licenseId ) { $ license = $ spdxLicenses -> getLicenseByIdentifier ( $ licenseId ) ; if ( ! $ license ) { $ out = $ licenseId ; } else { if ( $ license [ 1 ] === true ) { $ out = sprintf ( '%s (%s) (OSI approved) %s' , $ license [ 0 ] , $ licenseId , $ license [ 2 ] ) ; } else { $ out = sprintf ( '%s (%s) %s' , $ license [ 0 ] , $ licenseId , $ license [ 2 ] ) ; } } $ io -> write ( '<info>license</info> : ' . $ out ) ; } }
11918	public function register ( callable $ inject ) : void { $ reflection = new ReflectionFunction ( $ inject ) ; $ parameters = $ reflection -> getParameters ( ) ; foreach ( $ parameters as $ parameter ) { $ key = $ parameter -> name ; $ getter = function ( $ c ) use ( $ reflection , $ parameters , $ key ) { if ( isset ( $ c -> delegate ) ) { try { return $ c -> delegate -> get ( $ key ) ; } catch ( NotFoundExceptionInterface $ e ) { } } $ args = [ ] ; foreach ( $ parameters as $ param ) { if ( ! $ param -> isPassedByReference ( ) ) { $ args [ ] = $ c -> get ( $ param -> name ) ; } else { $ { $ param -> name } = null ; $ args [ $ param -> name ] = & $ { $ param -> name } ; } } $ reflection -> invokeArgs ( $ args ) ; foreach ( $ args as $ found => $ value ) { if ( ! is_numeric ( $ found ) && $ found == $ key ) { $ c :: $ map [ $ found ] = $ value ; } } if ( array_key_exists ( $ key , $ args ) ) { return $ args [ $ key ] ; } throw new NotFoundException ( $ key ) ; } ; static :: $ map [ $ key ] = new ReflectionFunction ( $ getter ) ; } }
7850	protected function marshal ( ) { $ reflection = new ReflectionClass ( $ this -> command ) ; $ constructor = $ reflection -> getConstructor ( ) ; $ params = $ this -> getParamsToInject ( $ constructor -> getParameters ( ) ) ; return $ reflection -> newInstanceArgs ( $ params ) ; }
1593	protected function validateTypeAndId ( ) : bool { if ( ! ( $ this -> validateType ( ) && $ this -> validateId ( ) ) ) { return false ; } $ type = $ this -> dataGet ( 'type' ) ; $ id = $ this -> dataGet ( 'id' ) ; if ( $ id && ! $ this -> isNotFound ( $ type , $ id ) ) { $ this -> resourceExists ( $ type , $ id ) ; return false ; } return true ; }
10508	private function registerChecker ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogChecker :: class , Utilities \ LogChecker :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.checker' , Contracts \ Utilities \ LogChecker :: class ) ; }
1500	public function unless ( bool $ test , $ encodings ) : self { return $ this -> when ( true !== $ test , $ encodings ) ; }
2294	public static function getTinyMceLanguage ( ) { $ lang = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( $ lang == '' ) { return 'en' ; } $ lang = str_replace ( '-' , '_' , $ lang ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ lang . '.js' ) ) { return $ lang ; } if ( ( $ short = substr ( $ GLOBALS [ 'TL_LANGUAGE' ] , 0 , 2 ) ) != $ lang ) { if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ short . '.js' ) ) { return $ short ; } } elseif ( ( $ long = $ short . '_' . strtoupper ( $ short ) ) != $ lang ) { if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ long . '.js' ) ) { return $ long ; } } return 'en' ; }
5728	public function Field ( $ properties = array ( ) ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/dropdown_form_action.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/dropdown_form_action.js' ) ; $ this -> setAttribute ( 'data-form-action-dropdown' , '#' . $ this -> DropdownID ( ) ) ; return parent :: Field ( ) ; }
5750	public function setRoles ( ) { $ this -> roles = [ ] ; if ( null !== $ records = $ this -> select ( ) ) { foreach ( $ records as $ record ) { $ this -> roles [ ( int ) $ record [ 'id' ] ] = $ record [ 'role' ] ; } } }
4771	public function status ( Request $ request , WidgetInterface $ widget , string $ widgetId , bool $ status = true ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'status' => $ status ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
5097	private function appendByField ( $ values ) { $ fixed = array ( ) ; foreach ( $ this -> fields as $ field ) { $ fixed [ ] = $ values [ $ field ] ; } return $ this -> appendByPosition ( $ fixed ) ; }
8880	private function isValidFullPath ( string $ path ) : bool { $ valid = false ; if ( '/' === substr ( $ path , 0 , 1 ) && is_executable ( $ path ) ) { $ valid = true ; } return $ valid ; }
6832	protected function getSupplierOrderItemFromEvent ( ResourceEventInterface $ event ) { $ item = $ event -> getResource ( ) ; if ( ! $ item instanceof SupplierOrderItemInterface ) { throw new InvalidArgumentException ( "Expected instance of SupplierOrderItemInterface." ) ; } return $ item ; }
5418	public function writeCookiesToJar ( $ jar , $ url ) { foreach ( $ this -> cookies as $ cookie ) { $ jar -> setCookie ( $ cookie -> getName ( ) , $ cookie -> getValue ( ) , $ url -> getHost ( ) , $ cookie -> getPath ( ) , $ cookie -> getExpiry ( ) ) ; } }
11026	protected function country ( ) { $ this -> parts [ '{country}' ] = $ this -> form -> field ( $ this -> model , $ this -> model -> getCountryPropertyName ( ) , [ 'options' => [ 'class' => 'form-group' ] ] ) -> dropDownList ( ArrayHelper :: map ( Country :: find ( ) -> orderBy ( [ 'name' => SORT_ASC ] ) -> all ( ) , 'id' , 'name' ) , [ 'id' => $ this -> fieldIds [ 'country' ] , 'prompt' => Yii :: t ( 'jlorente/location' , 'Select country' ) , 'name' => $ this -> getSubmitModelName ( $ this -> model -> getCountryPropertyName ( ) ) ] ) ; }
11120	protected function runMigration ( array $ file ) { $ this -> repository -> transaction ( function ( SqlMigrationRepository $ repo ) use ( $ file ) { $ contents = ( string ) $ this -> filesystem -> read ( $ file [ 'path' ] ) ; $ repo -> execute ( $ contents ) ; } ) ; }
9004	protected function months_dropdown ( $ post_type ) { global $ wpdb , $ wp_locale ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ months = $ wpdb -> get_results ( " SELECT DISTINCT YEAR( time ) AS year, MONTH( time ) AS month FROM $tn ORDER BY time DESC " ) ; $ month_count = count ( $ months ) ; if ( ! $ month_count || ( 1 == $ month_count && 0 == $ months [ 0 ] -> month ) ) { return ; } $ m = isset ( $ _GET [ 'm' ] ) ? ( int ) $ _GET [ 'm' ] : 0 ; ?> <label for="filter-by-date" class="screen-reader-text"> <?php _e ( 'Filter by date' ) ; ?> </label> <select name="m" id="filter-by-date"> <option <?php selected ( $ m , 0 ) ; ?> value="0"> <?php _e ( 'All dates' ) ; ?> </option> <?php foreach ( $ months as $ arc_row ) { if ( 0 == $ arc_row -> year ) { continue ; } $ month = zeroise ( $ arc_row -> month , 2 ) ; $ year = $ arc_row -> year ; printf ( "<option %s value='%s'>%s</option>\n" , selected ( $ m , $ year . $ month , false ) , esc_attr ( $ arc_row -> year . $ month ) , sprintf ( __ ( '%1$s %2$d' ) , $ wp_locale -> get_month ( $ month ) , $ year ) ) ; } ?> </select> <?php }
7577	protected function setFileFieldValue ( $ value ) { if ( version_compare ( PHP_VERSION , '5.5.0' ) >= 0 ) { if ( ! ( $ value instanceof \ CURLFile ) ) { $ value = ltrim ( $ value , "@" ) ; $ value = new \ CURLFile ( $ value ) ; } } else { if ( strpos ( $ value , '@' ) !== 0 ) { $ value = '@' . $ value ; } } return $ value ; }
7141	private function registerFactories ( ContainerBuilder $ container ) { $ defaultConfig = [ ] ; $ builder = $ container -> getDefinition ( 'payum.builder' ) ; $ builder -> addMethodCall ( 'addGatewayFactoryConfig' , [ Offline \ Constants :: FACTORY_NAME , $ defaultConfig , ] ) ; $ builder -> addMethodCall ( 'addGatewayFactory' , [ Offline \ Constants :: FACTORY_NAME , [ Offline \ OfflineGatewayFactory :: class , 'build' ] , ] ) ; $ builder -> addMethodCall ( 'addGatewayFactoryConfig' , [ Outstanding \ Constants :: FACTORY_NAME , $ defaultConfig , ] ) ; $ builder -> addMethodCall ( 'addGatewayFactory' , [ Outstanding \ Constants :: FACTORY_NAME , [ Outstanding \ OutstandingGatewayFactory :: class , 'build' ] , ] ) ; $ builder -> addMethodCall ( 'addGatewayFactoryConfig' , [ Credit \ Constants :: FACTORY_NAME , $ defaultConfig , ] ) ; $ builder -> addMethodCall ( 'addGatewayFactory' , [ Credit \ Constants :: FACTORY_NAME , [ Credit \ CreditGatewayFactory :: class , 'build' ] , ] ) ; }
1877	public function delete ( $ source = null ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ blnDoNotRedirect = ( $ source !== null ) ; if ( $ source === null ) { $ source = $ this -> intId ; } $ this -> isValid ( $ source ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ source ) || ! $ this -> isMounted ( $ source ) ) { throw new AccessDeniedException ( 'File or folder "' . $ source . '" is not mounted or cannot be found.' ) ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ondelete_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ondelete_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ source , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ source , $ this ) ; } } } $ this -> import ( Files :: class , 'Files' ) ; if ( is_dir ( $ this -> strRootDir . '/' . $ source ) ) { $ this -> Files -> rrdir ( $ source ) ; $ strWebDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.web_dir' ) ) ; if ( is_link ( $ this -> strRootDir . '/' . $ strWebDir . '/' . $ source ) ) { $ this -> Files -> delete ( $ strWebDir . '/' . $ source ) ; } } else { $ this -> Files -> delete ( $ source ) ; } if ( $ this -> blnIsDbAssisted && Dbafs :: shouldBeSynchronized ( $ source ) ) { Dbafs :: deleteResource ( $ source ) ; } $ this -> log ( 'File or folder "' . $ source . '" has been deleted' , __METHOD__ , TL_FILES ) ; if ( ! $ blnDoNotRedirect ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } }
7919	protected function renderInput ( $ options = [ ] , $ resultsOptions = [ ] ) { Html :: addCssClass ( $ options , 'prompt' ) ; $ lines = [ ] ; $ input = $ this -> hasModel ( ) ? Html :: activeTextInput ( $ this -> model , $ this -> attribute , $ options ) : Html :: textInput ( $ this -> name , $ this -> value , $ options ) ; if ( ! empty ( $ this -> displayIcon ) ) { $ lines [ ] = Html :: beginTag ( 'div' , [ 'class' => 'ui icon input' ] ) ; $ lines [ ] = $ input ; $ lines [ ] = Html :: tag ( 'i' , '' , [ 'class' => 'icon search' ] ) ; $ lines [ ] = Html :: endTag ( 'div' ) ; } else { $ lines [ ] = $ input ; } $ lines [ ] = Html :: tag ( 'div' , '' , $ resultsOptions ) ; return implode ( "\n" , $ lines ) ; }
9483	public function toArray ( $ changedOnly = false , $ extraData = null ) { $ vars = get_object_vars ( $ this ) ; $ object = array ( ) ; if ( ! is_array ( $ this -> _changes ) ) { $ this -> _changes = array ( ) ; } if ( is_array ( $ extraData ) ) { $ vars = array_merge ( $ vars , $ extraData ) ; } foreach ( $ vars as $ k => $ v ) { if ( strpos ( $ k , '_' ) !== 0 && $ v !== null && ( ! $ changedOnly || array_key_exists ( $ k , $ this -> _changes ) || array_key_exists ( $ k , $ extraData ) ) ) { if ( is_array ( $ v ) ) { $ subV = array ( ) ; foreach ( $ v as $ sub ) { if ( is_a ( $ sub , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ subV [ ] = $ sub -> toArray ( ) ; } else { $ subV [ ] = $ sub ; } } $ object [ $ k ] = $ subV ; } else if ( is_a ( $ v , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ object [ $ k ] = $ v -> toArray ( ) ; } else { $ object [ $ k ] = $ v ; } } } return $ object ; }
12847	private function _loadController ( $ oControllerName , string $ sActionName , array $ aParams = array ( ) ) { $ aPhpDoc = PhpDoc :: getPhpDocOfMethod ( $ oControllerName , $ sActionName ) ; if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { if ( ! isset ( $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ) { $ aPhpDoc [ 'Cache' ] [ 'maxage' ] = 0 ; } $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } $ mCacheReturn = Cache :: get ( $ sActionName . $ sCacheExt , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; if ( $ mCacheReturn !== false ) { return $ mCacheReturn ; } } if ( isset ( $ aPhpDoc [ 'Secure' ] ) ) { if ( isset ( $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) && $ this -> _oSecurity -> getUserRole ( ) != $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) { $ this -> _getPage403 ( ) ; } } $ oController = new $ oControllerName ; ob_start ( ) ; if ( ! defined ( 'PORTAL' ) ) { define ( 'PORTAL' , 'Batch' ) ; } if ( method_exists ( $ oController , 'beforeExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'beforeExecuteRoute' ) , array ( ) ) ; } $ mReturnController = call_user_func_array ( array ( $ oController , $ sActionName ) , $ aParams ) ; if ( method_exists ( $ oController , 'afterExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'afterExecuteRoute' ) , array ( ) ) ; } $ mReturn = ob_get_clean ( ) ; if ( $ mReturn == '' ) { $ mReturn = $ mReturnController ; } if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } if ( defined ( 'COMPRESS_HTML' ) && COMPRESS_HTML ) { $ mReturn = str_replace ( array ( "\t" , "\r" , " " ) , array ( "" , "" , "" , " " ) , $ mReturn ) ; } Cache :: set ( $ sActionName . $ sCacheExt , $ mReturn , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; } return $ mReturn ; }
9147	private function open ( ) { $ this -> handle = @ socket_create ( AF_INET , SOCK_STREAM , SOL_TCP ) ; if ( ! is_resource ( $ this -> handle ) ) { $ code = socket_last_error ( ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
7540	function index ( $ count_all = true ) { if ( ! $ this -> parent ) { return - 1 ; } elseif ( $ count_all ) { return $ this -> parent -> findChild ( $ this ) ; } else { $ index = - 1 ; foreach ( array_keys ( $ this -> parent -> children ) as $ k ) { if ( ! $ this -> parent -> children [ $ k ] -> isTextOrComment ( ) ) { ++ $ index ; } if ( $ this -> parent -> children [ $ k ] === $ this ) { return $ index ; } } return - 1 ; } }
12940	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a monitor consumer over aggregate connections.' ) ; } if ( $ client -> getCommandFactory ( ) -> supportsCommand ( 'MONITOR' ) === false ) { throw new NotSupportedException ( "'MONITOR' is not supported by the current command factory." ) ; } }
12862	public function parseBehaviour ( \ stdClass $ block , $ search ) { if ( ! isset ( $ block -> behaviour ) ) { return false ; } $ behaviours = array ( ) ; foreach ( explode ( ' ' , trim ( $ block -> behaviour ) ) as $ b ) { if ( strstr ( $ b , ':' ) ) { list ( $ name , $ prop ) = explode ( ':' , $ b , 2 ) ; $ behaviours [ $ name ] = $ prop ; } else { $ behaviours [ $ b ] = true ; } } return isset ( $ behaviours [ $ search ] ) ? $ behaviours [ $ search ] : false ; }
2544	protected function analyzeWithErrCodeCategoryMsgNodeName ( SendResult $ response , $ nodeErr , $ nodeCat , $ nodeMsg ) { $ analyzeResponse = new Result ( $ response ) ; $ domDoc = $ this -> loadDomDocument ( $ response -> responseXml ) ; $ errorCodeNode = $ domDoc -> getElementsByTagName ( $ nodeErr ) -> item ( 0 ) ; if ( ! is_null ( $ errorCodeNode ) ) { $ errorCatNode = $ domDoc -> getElementsByTagName ( $ nodeCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } else { $ analyzeResponse -> status = Result :: STATUS_ERROR ; } $ errorCode = $ errorCodeNode -> nodeValue ; $ errorTextNodeList = $ domDoc -> getElementsByTagName ( $ nodeMsg ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ) ; } return $ analyzeResponse ; }
11077	public function getHttpAdapter ( ) { if ( null === $ this -> httpAdapter ) { $ this -> httpAdapter = new Curl ( ) ; $ this -> httpAdapter -> setOptions ( array ( 'sslverifypeer' => false , ) ) ; } return $ this -> httpAdapter ; }
11008	public function addReportUri ( string $ reportUri ) : bool { if ( ! filter_var ( $ reportUri , FILTER_VALIDATE_URL ) ) { throw new MiddlewareException ( $ this , sprintf ( "'%s' is not a valid URI and can not be set as the CSP report URI" , $ reportUri ) ) ; } if ( ! in_array ( $ reportUri , $ this -> tags [ 'report-uri' ] ) ) { $ this -> tags [ 'report-uri' ] [ ] = $ reportUri ; return true ; } return false ; }
5647	public function paintCaseEnd ( $ test_name ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> paintCaseEnd ( $ test_name ) ; } }
5806	public function validate ( ValidationResult $ result ) { $ validate = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ validate = $ field ; } } if ( $ result -> valid ( ) && ! $ this -> owner -> $ validate ) { $ result -> error ( "\"{$validate}\" required!" ) ; } $ this -> owner -> extend ( 'validateFusionExtension' , $ result ) ; return $ result ; }
5918	protected function setSecretKey ( $ passphrase ) { $ length = strlen ( $ passphrase ) ; if ( strlen ( $ passphrase ) < 1 || strlen ( $ passphrase ) > 56 ) { throw new Ts3Exception ( "secret passphrase must contain at least one but less than 56 characters" ) ; } $ k = 0 ; $ data = 0 ; $ datal = 0 ; $ datar = 0 ; for ( $ i = 0 ; $ i < 18 ; $ i ++ ) { $ data = 0 ; for ( $ j = 4 ; $ j > 0 ; $ j -- ) { $ data = $ data << 8 | ord ( $ passphrase { $ k } ) ; $ k = ( $ k + 1 ) % $ length ; } $ this -> p [ $ i ] ^= $ data ; } for ( $ i = 0 ; $ i <= 16 ; $ i += 2 ) { $ this -> encipher ( $ datal , $ datar ) ; $ this -> p [ $ i ] = $ datal ; $ this -> p [ $ i + 1 ] = $ datar ; } foreach ( $ this -> s as $ key => $ val ) { for ( $ i = 0 ; $ i < 256 ; $ i += 2 ) { $ this -> encipher ( $ datal , $ datar ) ; $ this -> s [ $ key ] [ $ i ] = $ datal ; $ this -> s [ $ key ] [ $ i + 1 ] = $ datar ; } } }
9835	public static function imagecreatefrombmp ( $ p_sFile ) { $ file = fopen ( $ p_sFile , 'rb' ) ; $ read = fread ( $ file , 10 ) ; while ( ! feof ( $ file ) && ( $ read != '' ) ) { $ read .= fread ( $ file , 1024 ) ; } $ temp = unpack ( 'H*' , $ read ) ; $ hex = $ temp [ 1 ] ; $ header = substr ( $ hex , 0 , 108 ) ; if ( substr ( $ header , 0 , 4 ) == '424d' ) { $ header_parts = str_split ( $ header , 2 ) ; $ width = hexdec ( $ header_parts [ 19 ] . $ header_parts [ 18 ] ) ; $ height = hexdec ( $ header_parts [ 23 ] . $ header_parts [ 22 ] ) ; unset ( $ header_parts ) ; } $ x = 0 ; $ y = 1 ; $ image = imagecreatetruecolor ( $ width , $ height ) ; $ body = substr ( $ hex , 108 ) ; $ body_size = ( strlen ( $ body ) / 2 ) ; $ header_size = ( $ width * $ height ) ; $ usePadding = ( $ body_size > ( $ header_size * 3 ) + 4 ) ; for ( $ i = 0 ; $ i < $ body_size ; $ i += 3 ) { if ( $ x >= $ width ) { if ( $ usePadding ) { $ i += $ width % 4 ; } $ x = 0 ; ++ $ y ; if ( $ y > $ height ) { break ; } } $ i_pos = $ i * 2 ; $ r = hexdec ( $ body [ $ i_pos + 4 ] . $ body [ $ i_pos + 5 ] ) ; $ g = hexdec ( $ body [ $ i_pos + 2 ] . $ body [ $ i_pos + 3 ] ) ; $ b = hexdec ( $ body [ $ i_pos ] . $ body [ $ i_pos + 1 ] ) ; $ color = imagecolorallocate ( $ image , $ r , $ g , $ b ) ; imagesetpixel ( $ image , $ x , $ height - $ y , $ color ) ; ++ $ x ; } unset ( $ body ) ; return $ image ; }
10060	public function set ( $ key , $ value ) { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> first ( ) ; if ( $ meta === null ) { $ meta = new $ this -> metaModel ; $ meta -> key = $ key ; } $ meta -> value = $ value ; $ meta -> save ( ) ; }
6726	public function get_movie_votes ( $ post_id ) { $ votes = get_post_meta ( $ post_id , 'imdbTotalVotes' , true ) ; if ( ! empty ( $ votes ) ) { return json_decode ( $ votes , true ) ; } return false ; }
2902	public function downloadAction ( ) { $ type = $ this -> getRequest ( ) -> getParam ( 'type' , 'xml' ) ; $ configNode = Mage :: app ( ) -> getConfig ( ) -> getNode ( ) ; switch ( $ type ) { case 'txt' ; $ this -> downloadAsText ( $ configNode ) ; break ; case 'xml' : default : $ this -> downloadAsXml ( $ configNode ) ; } }
5163	public function serialize ( EntityContract $ entity , Collection $ select = null ) { $ bag = parent :: serialize ( $ entity , $ select ) ; return $ bag ; }
8508	public function getPrepInstructionsForASIN ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForASINRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForASINRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForASIN' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForASINResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12253	public function dump ( ) { $ dom = new DOMDocument ( '1.0' ) ; $ dom -> preserveWhiteSpace = false ; $ dom -> formatOutput = true ; $ dom -> loadXML ( $ this -> asXML ( ) ) ; return $ dom -> saveXML ( ) ; }
4030	protected function getLabelPattern ( EnvironmentInterface $ environment , ModelInterface $ model ) { $ translator = $ environment -> getTranslator ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ combined = 'typedesc.' . $ type ; if ( ( $ resultPattern = $ translator -> translate ( $ combined , 'tl_metamodel_filtersetting' ) ) == $ combined ) { $ resultPattern = $ translator -> translate ( 'typedesc._default_' , 'tl_metamodel_filtersetting' ) ; } return $ resultPattern ; }
4589	public function setWithVariablesInReturn ( ? bool $ withVariablesInReturn ) { $ this -> withVariablesInReturn = $ withVariablesInReturn ; $ this -> _withVariablesInReturn = null !== $ withVariablesInReturn ; return $ this ; }
4279	public function stream_seek ( $ offset , $ whence = SEEK_SET ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ fseek ( $ this -> handle , $ offset , $ whence ) ; $ success = $ result !== - 1 ; self :: register ( ) ; return $ success ; }
4687	public function where ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ expression ; $ this -> args [ 'where' ] = $ args ; return $ this ; }
1674	public function synchronize ( ) { if ( ! $ this -> isUnsynchronized ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot synchronize the folder "%s" because one of its parent folders is unsynchronized' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.nosync' ) ) -> delete ( ) ; }
7730	public function api ( $ url , $ body = null , $ type = self :: TYPE_POST ) { $ body [ 'access_token' ] = $ this -> accessToken ; $ this -> setBody ( $ body ) ; $ headers = [ 'Content-Type: application/json' , ] ; if ( $ type == self :: TYPE_GET ) { $ url .= '?' . http_build_query ( $ body ) ; } $ curl = curl_init ( $ this -> url . $ url ) ; if ( $ type == self :: TYPE_POST ) { curl_setopt ( $ curl , CURLOPT_POST , 1 ) ; curl_setopt ( $ curl , CURLOPT_POSTFIELDS , http_build_query ( $ body ) ) ; } curl_setopt ( $ curl , CURLOPT_HTTPHEADER , $ headers ) ; curl_setopt ( $ curl , CURLOPT_SSL_VERIFYPEER , false ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; $ response = curl_exec ( $ curl ) ; curl_close ( $ curl ) ; return json_decode ( $ response , true ) ; }
12455	public function hasToolbar ( ) { $ fileSkeleton = '/Resources/views/Editor/Toolbar/_toolbar_%s_buttons.html.twig' ; return file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'left' ) ) || file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'right' ) ) ; }
6473	private function compareAcceptCharsetHeaders ( AcceptCharsetHeaderValue $ a , AcceptCharsetHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aValue = $ a -> getCharset ( ) ; $ bValue = $ b -> getCharset ( ) ; if ( $ aValue === '*' ) { if ( $ bValue === '*' ) { return 0 ; } return 1 ; } if ( $ bValue === '*' ) { return - 1 ; } return 0 ; }
12979	protected function registerBehaviors ( EventManager $ evm , Configuration $ config ) { $ reader = new AnnotationReader ; if ( $ cache = $ config -> getMetadataCacheImpl ( ) ) { $ reader = new CachedReader ( $ reader , $ cache ) ; } foreach ( $ this -> getConfig ( 'behaviors' , array ( ) ) as $ behavior ) { if ( $ class = DiC :: resolve ( 'doctrine.behavior.' . $ behavior ) ) { $ class -> setAnnotationReader ( $ reader ) ; $ this -> configureBehavior ( $ behavior , $ class ) ; $ evm -> addEventSubscriber ( $ class ) ; } } if ( $ mapping = $ config -> getMetadataDriverImpl ( ) ) { $ type = 'registerMappingIntoDriverChainORM' ; if ( $ this -> getConfig ( 'behavior.superclass' , false ) ) { $ type = 'registerAbstractMappingIntoDriverChainORM' ; } DoctrineExtensions :: $ type ( $ mapping , $ reader ) ; } }
11163	protected function getResponseFormat ( array $ config ) { if ( isset ( $ config [ 'responseFormat' ] ) ) { if ( ! is_string ( $ config [ 'responseFormat' ] ) ) { throw new \ DomainException ( 'responseFormat must reference a string' , self :: ERR_INVALID_RESPONSEFORMAT ) ; } return $ config [ 'responseFormat' ] ; } return '[ %link% ] "%title%" by %author%' . '; Length %duration%' . '; Published %published%' . '; Views %views%' . '; Likes %likes%' ; }
7398	public function setStatusCode ( int $ statusCode , string $ version = '1.1' , string $ statusText = '' ) : bool { if ( ! headers_sent ( ) ) { $ statusCode = intval ( $ statusCode ) ; if ( '' == $ statusText ) { $ statusTexts = [ 100 => 'Continue' , 101 => 'Switching Protocols' , 102 => 'Processing' , 200 => 'OK' , 201 => 'Created' , 202 => 'Accepted' , 203 => 'Non-Authoritative Information' , 204 => 'No Content' , 205 => 'Reset Content' , 206 => 'Partial Content' , 207 => 'Multi-Status' , 208 => 'Already Reported' , 226 => 'IM Used' , 300 => 'Multiple Choices' , 301 => 'Moved Permanently' , 302 => 'Found' , 303 => 'See Other' , 304 => 'Not Modified' , 305 => 'Use Proxy' , 307 => 'Temporary Redirect' , 308 => 'Permanent Redirect' , 400 => 'Bad Request' , 401 => 'Unauthorized' , 402 => 'Payment Required' , 403 => 'Forbidden' , 404 => 'Not Found' , 405 => 'Method Not Allowed' , 406 => 'Not Acceptable' , 407 => 'Proxy Authentication Required' , 408 => 'Request Timeout' , 409 => 'Conflict' , 410 => 'Gone' , 411 => 'Length Required' , 412 => 'Precondition Failed' , 413 => 'Payload Too Large' , 414 => 'URI Too Long' , 415 => 'Unsupported Media Type' , 416 => 'Range Not Satisfiable' , 417 => 'Expectation Failed' , 418 => 'I\'m a teapot' , 422 => 'Unprocessable Entity' , 423 => 'Locked' , 424 => 'Failed Dependency' , 425 => 'Reserved for WebDAV advanced collections expired proposal' , 426 => 'Upgrade Required' , 428 => 'Precondition Required' , 429 => 'Too Many Requests' , 431 => 'Request Header Fields Too Large' , 500 => 'Internal Server Error' , 501 => 'Not Implemented' , 502 => 'Bad Gateway' , 503 => 'Service Unavailable' , 504 => 'Gateway Timeout' , 505 => 'HTTP Version Not Supported' , 506 => 'Variant Also Negotiates (Experimental)' , 507 => 'Insufficient Storage' , 508 => 'Loop Detected' , 510 => 'Not Extended' , 511 => 'Network Authentication Required' , ] ; $ statusText = $ statusTexts [ $ statusCode ] ; } header ( sprintf ( 'HTTP/%s %s %s' , $ version , $ statusCode , $ statusText ) , true , $ statusCode ) ; return true ; } return false ; }
12518	public static function files ( $ path , $ filter = '.' , $ recurse = false , $ full = false , $ exclude = array ( '.svn' , 'CVS' , '.DS_Store' , '__MACOSX' , 'Thumbs.db' ) , $ excludefilter = array ( '^\..*' , '.*~' ) , $ naturalSort = true ) { $ path = Path :: clean ( $ path ) ; if ( ! is_dir ( $ path ) ) { throw new Exception ( Helper :: getTranslation ( 'NOT_A_FOLDER' ) ) ; } if ( count ( $ excludefilter ) ) { $ excludefilter_string = '/(' . implode ( '|' , $ excludefilter ) . ')/' ; } else { $ excludefilter_string = '' ; } $ arr = Folder :: _items ( $ path , $ filter , $ recurse , $ full , $ exclude , $ excludefilter_string , true ) ; if ( $ naturalSort ) { natsort ( $ arr ) ; } else { asort ( $ arr ) ; } return array_values ( $ arr ) ; }
8766	protected function loadConfigFiles ( ) { try { if ( file_exists ( $ this -> cachePath ( 'config.php' ) ) ) { $ this -> config = require $ this -> cachePath ( 'config.php' ) ; } else { $ dotenv = new \ Dotenv \ Dotenv ( $ this -> root ) ; $ dotenv -> load ( ) ; foreach ( glob ( $ this -> root . '/config/*.php' ) as $ file ) { $ keyName = strtolower ( str_replace ( [ $ this -> root . '/config/' , '.php' ] , '' , $ file ) ) ; $ this -> config [ $ keyName ] = require $ file ; } } } catch ( Exception $ e ) { die ( printf ( "Configuration information could not be retrieved properly.\nError Message: %s" , $ e -> getMessage ( ) ) ) ; } }
12374	public function run ( ) : void { if ( ! $ this -> isRan ) { $ this -> isRan = true ; foreach ( $ this -> items as $ item ) { $ options = $ item [ 2 ] ?? [ ] ; $ ruleName = $ item [ 1 ] ; foreach ( is_array ( $ item [ 0 ] ) ? $ item [ 0 ] : [ $ item [ 0 ] ] as $ fieldName ) { self :: applyRuleToField ( $ fieldName , $ ruleName , $ options ) ; } } } }
9749	public function _calcSize ( & $ raList ) { list ( $ iSBDcnt , $ iBBcnt , $ iPPScnt ) = [ 0 , 0 , 0 ] ; $ iSmallLen = 0 ; $ iSBcnt = 0 ; $ iCount = count ( $ raList ) ; for ( $ i = 0 ; $ i < $ iCount ; ++ $ i ) { if ( $ raList [ $ i ] -> Type == OLE :: OLE_PPS_TYPE_FILE ) { $ raList [ $ i ] -> Size = $ raList [ $ i ] -> getDataLen ( ) ; if ( $ raList [ $ i ] -> Size < OLE :: OLE_DATA_SIZE_SMALL ) { $ iSBcnt += floor ( $ raList [ $ i ] -> Size / $ this -> smallBlockSize ) + ( ( $ raList [ $ i ] -> Size % $ this -> smallBlockSize ) ? 1 : 0 ) ; } else { $ iBBcnt += ( floor ( $ raList [ $ i ] -> Size / $ this -> bigBlockSize ) + ( ( $ raList [ $ i ] -> Size % $ this -> bigBlockSize ) ? 1 : 0 ) ) ; } } } $ iSmallLen = $ iSBcnt * $ this -> smallBlockSize ; $ iSlCnt = floor ( $ this -> bigBlockSize / OLE :: OLE_LONG_INT_SIZE ) ; $ iSBDcnt = floor ( $ iSBcnt / $ iSlCnt ) + ( ( $ iSBcnt % $ iSlCnt ) ? 1 : 0 ) ; $ iBBcnt += ( floor ( $ iSmallLen / $ this -> bigBlockSize ) + ( ( $ iSmallLen % $ this -> bigBlockSize ) ? 1 : 0 ) ) ; $ iCnt = count ( $ raList ) ; $ iBdCnt = $ this -> bigBlockSize / OLE :: OLE_PPS_SIZE ; $ iPPScnt = ( floor ( $ iCnt / $ iBdCnt ) + ( ( $ iCnt % $ iBdCnt ) ? 1 : 0 ) ) ; return [ $ iSBDcnt , $ iBBcnt , $ iPPScnt ] ; }
7849	public function dispatchFrom ( $ command , ArrayAccess $ source , array $ extras = [ ] ) { $ this -> command = $ command ; $ this -> values = array_merge ( ( array ) $ source , $ extras ) ; return $ this -> dispatcher -> dispatch ( $ this -> marshal ( ) ) ; }
6499	public function beforeStep ( Scope \ StepScope $ scope ) { self :: $ pageUrl = $ this -> getCurrentUrl ( ) ; $ _GET [ 'q' ] = ltrim ( parse_url ( static :: $ pageUrl ) [ 'path' ] , '/' ) ; drupal_path_initialize ( ) ; }
11546	public function changeSecurityQuestion ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangeSecurityQuestionForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
8252	protected function logInvalidLoginAttempt ( $ name ) { $ max = $ this -> config [ "registration" ] [ "nameLenMax" ] ; if ( strlen ( $ name ) > $ max ) { $ max = substr ( $ name , 0 , $ max ) . " (trimmed)" ; } $ this -> getLogger ( ) -> notice ( "Invalid login attempt for {name} by {addr}" , array ( "name" => $ name , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] , ) ) ; }
11503	private function createDeleteForm ( Comment $ comment ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_comment_delete' , array ( 'id' => $ comment -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
6275	protected function read ( $ start , $ len ) { $ end = $ start + $ len ; if ( $ end <= 2048 ) { return substr ( $ this -> index , $ start , $ len ) ; } $ bytes = '' ; if ( $ this -> buf && $ start >= $ this -> bufStart ) { $ bytes .= substr ( $ this -> buf , $ start - $ this -> bufStart , $ len ) ; $ bytesRead = strlen ( $ bytes ) ; $ len -= $ bytesRead ; $ start += $ bytesRead ; } else { $ bytesRead = 0 ; } if ( ! $ len ) { return $ bytes ; } if ( $ start !== $ this -> filePos ) { if ( fseek ( $ this -> handle , $ start ) === - 1 ) { throw new Exception ( 'Seek failed, file "' . $ this -> fileName . '" may be corrupted.' ) ; } } $ buf = fread ( $ this -> handle , max ( $ len , 1024 ) ) ; if ( $ buf === false ) { $ buf = '' ; } $ bytes .= substr ( $ buf , 0 , $ len ) ; if ( strlen ( $ bytes ) !== $ len + $ bytesRead ) { throw new Exception ( 'Read from CDB file failed, file "' . $ this -> fileName . '" may be corrupted.' ) ; } $ this -> filePos = $ end ; $ this -> bufStart = $ start ; $ this -> buf = $ buf ; return $ bytes ; }
12126	public function validate ( string $ sValue = null ) : bool { if ( $ this -> _sType == 'DateTime' ) { if ( preg_match ( '#^[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}#' , $ sValue ) ) { return true ; } } return false ; }
12015	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a MULTI/EXEC transaction over aggregate connections.' ) ; } if ( ! $ client -> getCommandFactory ( ) -> supportsCommands ( array ( 'MULTI' , 'EXEC' , 'DISCARD' ) ) ) { throw new NotSupportedException ( 'MULTI, EXEC and DISCARD are not supported by the current command factory.' ) ; } }
11663	public static function saveToFile ( $ file , $ properties ) { $ prop_string = self :: saveToString ( $ properties ) ; $ real_file = File :: asFile ( $ file ) ; if ( ! $ real_file -> exists ( ) ) { $ real_file -> touch ( ) ; } $ real_file -> setContent ( $ prop_string ) ; }
1051	public static function getArgumentValues ( $ def , $ node , $ variableValues = null ) { if ( empty ( $ def -> args ) ) { return [ ] ; } $ argumentNodes = $ node -> arguments ; if ( empty ( $ argumentNodes ) ) { return [ ] ; } $ argumentValueMap = [ ] ; foreach ( $ argumentNodes as $ argumentNode ) { $ argumentValueMap [ $ argumentNode -> name -> value ] = $ argumentNode -> value ; } return static :: getArgumentValuesForMap ( $ def , $ argumentValueMap , $ variableValues , $ node ) ; }
2395	public function close ( ) { $ arrArchive [ 'archive_signature' ] = self :: CENTRAL_DIR_END ; $ arrArchive [ 'number_of_this_disk' ] = "\x00\x00" ; $ arrArchive [ 'number_of_disk_with_cd' ] = "\x00\x00" ; $ arrArchive [ 'total_cd_entries_disk' ] = pack ( 'v' , $ this -> intCount ) ; $ arrArchive [ 'total_cd_entries' ] = pack ( 'v' , $ this -> intCount ) ; $ arrArchive [ 'size_of_cd' ] = pack ( 'V' , \ strlen ( $ this -> strCentralDir ) ) ; $ arrArchive [ 'offset_start_cd' ] = pack ( 'V' , @ ftell ( $ this -> resFile ) ) ; $ arrArchive [ 'zipfile_comment_length' ] = "\x00\x00" ; $ arrArchive [ 'zipfile_comment' ] = '' ; fwrite ( $ this -> resFile , $ this -> strCentralDir ) ; fwrite ( $ this -> resFile , implode ( '' , $ arrArchive ) ) ; fclose ( $ this -> resFile ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } } Files :: getInstance ( ) -> rename ( self :: TEMPORARY_FOLDER . '/' . basename ( $ this -> strTemp ) , $ this -> strFile ) ; }
3693	public function createAttribute ( $ information , $ metaModel ) { $ event = new CreateAttributeEvent ( $ information , $ metaModel ) ; $ this -> eventDispatcher -> dispatch ( CreateAttributeEvent :: NAME , $ event ) ; if ( $ event -> getAttribute ( ) ) { return $ event -> getAttribute ( ) ; } $ factory = $ this -> getTypeFactory ( $ information [ 'type' ] ) ; if ( ! $ factory ) { return null ; } return $ factory -> createInstance ( $ information , $ metaModel ) ; }
8442	public function render ( array $ args , bool $ prettyPrint = null ) { header ( 'Content-type: application/json' ) ; if ( ( constant ( 'STRAY_ENV' ) === 'development' && $ prettyPrint !== false ) || $ prettyPrint === true ) { return ( string ) json_encode ( $ args , JSON_PRETTY_PRINT ) ; } return ( string ) json_encode ( $ args ) ; }
1361	public function is ( string ... $ mediaTypes ) : bool { $ mediaTypes = collect ( $ mediaTypes ) -> map ( function ( $ mediaType , $ index ) { return MediaType :: parse ( $ index , $ mediaType ) ; } ) ; return $ this -> any ( ... $ mediaTypes ) ; }
10937	protected function getObfuscatedEmail ( CustomerInterface $ user ) { $ email = $ user -> getEmail ( ) ; if ( false !== $ pos = strpos ( $ email , '@' ) ) { $ email = '...' . substr ( $ email , $ pos ) ; } return $ email ; }
6928	private function persistInvoice ( Invoice \ InvoiceInterface $ invoice ) { $ this -> persistenceHelper -> persistAndRecompute ( $ invoice , true ) ; foreach ( $ invoice -> getLines ( ) as $ line ) { $ this -> persistenceHelper -> persistAndRecompute ( $ line , true ) ; } $ this -> persistenceHelper -> persistAndRecompute ( $ invoice -> getShipment ( ) , false ) ; }
90	private static function throwEncodeError ( $ code ) { switch ( $ code ) { case JSON_ERROR_DEPTH : $ msg = 'Maximum stack depth exceeded' ; break ; case JSON_ERROR_STATE_MISMATCH : $ msg = 'Underflow or the modes mismatch' ; break ; case JSON_ERROR_CTRL_CHAR : $ msg = 'Unexpected control character found' ; break ; case JSON_ERROR_UTF8 : $ msg = 'Malformed UTF-8 characters, possibly incorrectly encoded' ; break ; default : $ msg = 'Unknown error' ; } throw new \ RuntimeException ( 'JSON encoding failed: ' . $ msg ) ; }
5356	public function parseSchema ( $ openApiSpec ) { $ openApiSpecContents = file_get_contents ( $ openApiSpec ) ; $ schemaClass = self :: OPEN_API_MODEL ; $ schema = null ; $ jsonException = null ; $ yamlException = null ; try { return $ this -> serializer -> deserialize ( $ openApiSpecContents , $ schemaClass , self :: CONTENT_TYPE_JSON , [ 'document-origin' => $ openApiSpec ] ) ; } catch ( \ Exception $ exception ) { $ jsonException = $ exception ; } $ content = Yaml :: parse ( $ openApiSpecContents , Yaml :: PARSE_OBJECT | Yaml :: PARSE_OBJECT_FOR_MAP | Yaml :: PARSE_DATETIME | Yaml :: PARSE_EXCEPTION_ON_INVALID_TYPE ) ; $ openApiSpecContents = json_encode ( $ content ) ; return $ this -> serializer -> deserialize ( $ openApiSpecContents , $ schemaClass , self :: CONTENT_TYPE_JSON , [ 'document-origin' => $ openApiSpec ] ) ; }
4692	public function andHaving ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> having = $ this -> having ? '(' . $ this -> having . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'having' , $ args ) ; return $ this ; }
9205	public function init ( ) { $ path = $ this -> absolutePath ( $ this -> getFile ( ) ) ; $ this -> quiet ( 'Initializing seed file: ' . $ this -> shortPath ( $ path ) ) ; $ this -> existsOrCreate ( $ path ) ; }
5119	private function assessOptions ( array $ options ) : void { $ defaultOptions = [ 'rest_server' => self :: REST_SERVER , 'auth_url' => self :: AUTHENTICATION , 'max_attempt' => self :: DEFAULT_MAX_ATTEMPT , 'default_headers' => [ 'Accept' => 'application/json' , ] , ] ; $ this -> options = new Collection ( array_merge ( $ defaultOptions , $ options ) ) ; if ( isset ( $ options [ 'access_token' ] ) ) { $ this -> setAuthorizationHeader ( $ options [ 'access_token' ] ) ; } if ( isset ( $ options [ 'recycle_token' ] ) && is_callable ( $ options [ 'recycle_token' ] ) ) { $ this -> recycleToken ( $ options [ 'recycle_token' ] ) ; } if ( isset ( $ options [ 'token_saver' ] ) && is_callable ( $ options [ 'token_saver' ] ) ) { $ this -> setTokenSaver ( $ options [ 'token_saver' ] ) ; } $ this -> httpClient = new Client ( [ 'base_uri' => $ this -> options -> get ( 'rest_server' ) , ] ) ; }
8649	private function calculateStringToSignV2 ( array $ parameters , $ queuepath = null ) { $ parsedUrl = parse_url ( $ this -> config [ 'ServiceURL' ] ) ; $ endpoint = $ parsedUrl [ 'host' ] ; if ( isset ( $ parsedUrl [ 'port' ] ) && ! is_null ( $ parsedUrl [ 'port' ] ) ) { $ endpoint .= ':' . $ parsedUrl [ 'port' ] ; } $ data = 'POST' ; $ data .= "\n" ; $ data .= $ endpoint ; $ data .= "\n" ; if ( $ queuepath ) { $ uri = $ queuepath ; } else { $ uri = "/" ; } $ uriencoded = implode ( "/" , array_map ( array ( $ this , "urlencode" ) , explode ( "/" , $ uri ) ) ) ; $ data .= $ uriencoded ; $ data .= "\n" ; uksort ( $ parameters , 'strcmp' ) ; $ data .= $ this -> getParametersAsString ( $ parameters ) ; return $ data ; }
12669	public function addNamespace ( $ namespaceOptions , $ namespace = null ) { if ( ! $ namespaceOptions instanceof NamespaceOptionsInterface ) { if ( is_array ( $ namespaceOptions ) ) { $ namespaceOptions = new NamespaceOptions ( $ namespaceOptions ) ; if ( $ namespace !== null ) { $ namespaceOptions -> setName ( $ namespace ) ; } } else { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be array or an instance of HtSettingsModule\Options\NamespaceOptionsInterface, %s provided instead' , __METHOD__ , is_object ( $ namespaceOptions ) ? get_class ( $ namespaceOptions ) : gettype ( $ namespaceOptions ) ) ) ; } } else { if ( ! $ namespaceOptions -> getName ( ) && $ namespace ) { $ namespaceOptions -> setName ( $ namespace ) ; } } if ( $ namespace === null ) { $ namespace = $ namespaceOptions -> getName ( ) ; } $ this -> namespaces [ $ namespace ] = $ namespaceOptions ; }
2307	protected function doCreateFileList ( $ strFolder = null , $ level = - 1 , $ strFilter = '' ) { if ( $ strFilter === true ) { @ trigger_error ( 'Passing "true" to Backend::doCreateFileList() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ strFilter = 'gif,jpg,jpeg,png' ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrPages = scan ( $ rootDir . '/' . $ strFolder ) ; if ( empty ( $ arrPages ) ) { return '' ; } if ( \ in_array ( '.htaccess' , $ arrPages ) ) { return '' ; } ++ $ level ; $ strFolders = '' ; $ strFiles = '' ; foreach ( $ arrPages as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ rootDir . '/' . $ strFolder . '/' . $ strFile ) ) { $ strFolders .= $ this -> doCreateFileList ( $ strFolder . '/' . $ strFile , $ level , $ strFilter ) ; } else { if ( $ strFilter != '' && ! preg_match ( '/\.(' . str_replace ( ',' , '|' , $ strFilter ) . ')$/i' , $ strFile ) ) { continue ; } $ strFiles .= sprintf ( '<option value="%s"%s>%s</option>' , $ strFolder . '/' . $ strFile , ( ( $ strFolder . '/' . $ strFile == Input :: get ( 'value' ) ) ? ' selected="selected"' : '' ) , StringUtil :: specialchars ( $ strFile ) ) ; } } if ( \ strlen ( $ strFiles ) ) { return '<optgroup label="' . StringUtil :: specialchars ( $ strFolder ) . '">' . $ strFiles . $ strFolders . '</optgroup>' ; } return $ strFiles . $ strFolders ; }
6591	protected function asset ( $ type ) { $ busters = $ this -> checkAndGetBusters ( ) ; $ bustersOfThisType = array ( ) ; foreach ( $ busters as $ key => $ value ) { if ( strpos ( $ key , $ type ) !== false ) { $ bustersOfThisType [ $ key ] = $ value ; } } $ busterStrings = $ this -> parseTags ( $ bustersOfThisType , $ type ) ; return implode ( "\n" , $ busterStrings ) ; }
4554	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; foreach ( $ this -> removed as $ property ) { if ( array_key_exists ( $ property , $ payload ) ) { $ event -> markAsInvalid ( ) ; break ; } } }
9268	public function setTimeoutMinutes ( $ value ) { if ( $ value ) $ this -> timeoutMinutes = ( int ) $ value ; else $ this -> timeoutMinutes = null ; return $ this ; }
12579	public function previewImageByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_IMAGE , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
7644	protected function parseMetadataElement ( $ element = null ) { if ( ! is_null ( $ element ) && isset ( $ element -> Metadata ) && ! is_null ( $ element -> Metadata ) ) { return get_object_vars ( $ element -> Metadata ) ; } return array ( ) ; }
2393	public function addFile ( $ strFile , $ strName = null ) { if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFile ) ) { throw new \ Exception ( "File $strFile does not exist" ) ; } if ( strncmp ( $ strName , '/' , 1 ) === 0 ) { $ strName = substr ( $ strName , 1 ) ; } $ this -> addString ( file_get_contents ( $ this -> strRootDir . '/' . $ strFile ) , $ strName ? : $ strFile , filemtime ( $ this -> strRootDir . '/' . $ strFile ) ) ; }
7250	protected function validateDeliveryAddress ( SaleInterface $ sale , Constraint $ constraint ) { if ( ! $ sale -> isSameAddress ( ) && null === $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_is_required ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } elseif ( $ sale -> isSameAddress ( ) && null !== $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_should_be_null ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } }
6708	protected function getReaderFactory ( ) { if ( ! $ this -> readerFactory ) { $ this -> readerFactory = new ReaderFactory ( [ new Json ( ) , new Xml ( ) , ] ) ; } return $ this -> readerFactory ; }
5203	public function close ( ) { if ( isset ( $ this -> channel ) ) $ this -> channel -> close ( ) ; if ( isset ( $ this -> AMQPConnection ) ) $ this -> AMQPConnection -> close ( ) ; }
7135	public function getPercent ( ) : float { $ amount = $ this -> getAmount ( ) ; if ( 0 < $ this -> sellingPrice ) { return round ( $ amount * 100 / $ this -> sellingPrice , 2 ) ; } return 0 ; }
1915	protected function getQuestion ( ) { $ this -> generateCaptcha ( ) ; $ question = $ GLOBALS [ 'TL_LANG' ] [ 'SEC' ] [ 'question' . random_int ( 1 , 3 ) ] ; $ question = sprintf ( $ question , $ this -> arrCaptcha [ 'int1' ] , $ this -> arrCaptcha [ 'int2' ] ) ; $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ question ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( '&#%s;' , Utf8 :: ord ( $ strCharacter ) ) ; } return $ strEncoded ; }
1689	public function updateStyleSheets ( ) { $ objStyleSheets = $ this -> Database -> execute ( "SELECT * FROM tl_style_sheet" ) ; $ arrStyleSheets = $ objStyleSheets -> fetchEach ( 'name' ) ; if ( file_exists ( $ this -> strRootDir . '/system/config/dcaconfig.php' ) ) { @ trigger_error ( 'Using the dcaconfig.php file has been deprecated and will no longer work in Contao 5.0. Create one or more DCA files in app/Resources/contao/dca instead.' , E_USER_DEPRECATED ) ; include $ this -> strRootDir . '/system/config/dcaconfig.php' ; } foreach ( scan ( $ this -> strRootDir . '/assets/css' , true ) as $ file ) { if ( is_dir ( $ this -> strRootDir . '/assets/css/' . $ file ) ) { continue ; } if ( \ is_array ( Config :: get ( 'rootFiles' ) ) && \ in_array ( $ file , Config :: get ( 'rootFiles' ) ) ) { continue ; } if ( preg_match ( '/^[a-f0-9]{12}\.css$/' , $ file ) ) { continue ; } $ objFile = new File ( 'assets/css/' . $ file ) ; if ( $ objFile -> extension == 'css' && ! \ in_array ( $ objFile -> filename , $ arrStyleSheets ) ) { $ objFile -> delete ( ) ; } } $ objStyleSheets -> reset ( ) ; while ( $ objStyleSheets -> next ( ) ) { $ this -> writeStyleSheet ( $ objStyleSheets -> row ( ) ) ; $ this -> log ( 'Generated style sheet "' . $ objStyleSheets -> name . '.css"' , __METHOD__ , TL_CRON ) ; } }
5706	public function shouldDisplay ( ) { return $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsPublished ( ) && $ this -> gridFieldRequest -> record -> canEdit ( ) ; }
8164	static public function render ( $ template , $ userData ) { if ( ! is_string ( $ template ) ) return '' ; $ path = strlen ( $ template ) <= 256 ? trim ( $ template ) : '' ; $ data = array_merge ( Tpl :: $ data , is_array ( $ userData ) ? $ userData : [ ] ) ; $ twig = TwigEnv :: instance ( ) ; if ( Str :: startsWith ( $ path , '@' ) || Str :: endsWith ( strtolower ( $ path ) , '.twig' ) ) { return $ twig -> renderPath ( $ path , $ data ) ; } return $ twig -> renderString ( $ template , $ data ) ; }
1976	public static function findMultipleFoldersByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='folder' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; }
1882	protected function getMD5Folders ( $ strPath ) { $ arrFiles = array ( ) ; foreach ( scan ( $ this -> strRootDir . '/' . $ strPath ) as $ strFile ) { if ( ! is_dir ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) ) { continue ; } $ arrFiles [ substr ( md5 ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) , 0 , 8 ) ] = 1 ; foreach ( $ this -> getMD5Folders ( $ strPath . '/' . $ strFile ) as $ k => $ v ) { $ arrFiles [ $ k ] = $ v ; } } return $ arrFiles ; }
8478	public function log ( $ level , $ message , array $ context = [ ] ) { if ( $ this -> config ( 'requiredScope' ) && ( empty ( $ context [ 'scope' ] ) ) ) return false ; $ scopes = ( empty ( $ context [ 'scope' ] ) ) ? [ null ] : $ context [ 'scope' ] ; unset ( $ context [ 'scope' ] ) ; $ this -> _context = $ context ; $ Table = TableRegistry :: get ( $ this -> config ( 'model' ) , [ 'table' => $ this -> config ( 'table' ) ] ) ; foreach ( $ scopes as $ scope ) { $ entity = $ Table -> newEntity ( ) ; $ data = [ 'level' => $ level , 'user_id' => $ this -> _userId ( ) , 'scope' => $ scope , 'message' => $ message , 'context' => $ this -> _context , ] ; $ entity = $ Table -> patchEntity ( $ entity , $ data ) ; $ Table -> save ( $ entity ) ; } return true ; }
2578	protected function loadArnk ( Segment \ ArrivalUnknown $ segment ) { $ this -> travelProduct = new TravelProduct ( ) ; $ this -> travelProduct -> productDetails = new ProductDetails ( $ segment -> identification ) ; $ this -> messageAction = new MessageAction ( Business :: FUNC_ARNK ) ; }
1280	public function extractEnvironmentId ( array $ data ) : string { if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Space' === $ data [ 'sys' ] [ 'type' ] ) { return $ this -> environmentId ; } if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Environment' === $ data [ 'sys' ] [ 'type' ] ) { return $ data [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'sys' ] [ 'environment' ] ) ) { return $ data [ 'sys' ] [ 'environment' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'environment' ] ) ) { return $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'environment' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] ) && ! $ data [ 'items' ] ) { return $ this -> environmentId ; } return 'master' ; }
10624	private static function checkAndMoveFile ( $ sourceMigrationFile , $ appMigrationDir , IOInterface $ io ) { $ explodedPath = explode ( '/' , $ sourceMigrationFile ) ; $ filename = array_pop ( $ explodedPath ) ; if ( file_exists ( $ appMigrationDir . '/' . $ filename ) ) { if ( md5_file ( $ appMigrationDir . '/' . $ filename ) === md5_file ( $ sourceMigrationFile ) ) { if ( $ io -> isVeryVerbose ( ) ) { $ io -> write ( "<info>found that $sourceMigrationFile is equal" . " to $appMigrationDir/$filename</info>" ) ; } $ doTheMove = false ; } else { $ doTheMove = $ io -> askConfirmation ( "<question>The file \n" . " \t$sourceMigrationFile\n has the same name than the previous " . "migrated file located at \n\t$appMigrationDir/$filename\n " . "but the content is not equal.\n Overwrite the file ?[y,N]" , false ) ; } } else { $ doTheMove = true ; } if ( $ doTheMove ) { $ fs = new Filesystem ( ) ; $ fs -> copy ( $ sourceMigrationFile , $ appMigrationDir . '/' . $ filename ) ; $ io -> write ( "<info>Importing '$filename' migration file</info>" ) ; return true ; } return false ; }
11344	public function removeField ( $ name ) { for ( $ i = 0 ; $ i < count ( $ this -> fields ) ; $ i ++ ) { if ( $ this -> fields [ $ i ] -> getName ( ) == $ name ) { array_splice ( $ this -> fields , $ i , 1 ) ; break ; } } }
5054	public function init ( ) { $ this -> setLabel ( 'general settings' ) ; $ this -> add ( array ( 'type' => 'Core\Form\Element\Select' , 'name' => 'language' , 'options' => array ( 'label' => 'choose your language' , 'value_options' => array ( 'en' => 'English' , 'fr' => 'French' , 'de' => 'German' , 'it' => 'Italian' , 'po' => 'Polish' , 'ru' => 'Russian' , 'tr' => 'Turkish' , 'es' => 'Spanish' , ) , 'description' => 'defines the languages of this frontend.' ) , ) ) ; $ timezones = array_merge ( \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: AFRICA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: AMERICA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: ASIA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: ATLANTIC ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: AUSTRALIA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: EUROPE ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: INDIAN ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: PACIFIC ) ) ; $ this -> add ( array ( 'type' => 'Core\Form\Element\Select' , 'name' => 'timezone' , 'options' => array ( 'label' => 'choose your timzone' , 'value_options' => $ timezones , 'description' => 'defines your local timezone.' ) , ) ) ; }
4163	protected function _makeCall ( $ function , $ params = null , $ method = 'GET' ) { if ( isset ( $ params [ 'count' ] ) && $ params [ 'count' ] < 1 ) { throw new InvalidParameterException ( 'InstagramClient: you are trying to query 0 records!' ) ; } if ( true === isset ( $ this -> _accesstoken ) ) { $ authMethod = '?access_token=' . $ this -> getAccessToken ( ) ; } else { throw new AuthException ( "Error: _makeCall() | This method requires an valid users access token." ) ; } if ( isset ( $ params ) && is_array ( $ params ) ) { $ paramString = '&' . http_build_query ( $ params ) ; } else { $ paramString = null ; } $ apiCall = self :: API_URL . $ function . $ authMethod . ( ( 'GET' === $ method ) ? $ paramString : null ) ; $ headerData = array ( 'Accept: application/json' ) ; if ( $ this -> _enforceSignedRequests ) { $ apiCall .= ( strstr ( $ apiCall , '?' ) ? '&' : '?' ) . 'sig=' . $ this -> _signHeader ( $ function , $ authMethod , $ params ) ; } $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ apiCall ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , $ headerData ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , 5 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , false ) ; if ( 'POST' === $ method ) { curl_setopt ( $ ch , CURLOPT_POST , count ( $ params ) ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , ltrim ( $ paramString , '&' ) ) ; } else if ( 'DELETE' === $ method ) { curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'DELETE' ) ; } $ jsonData = curl_exec ( $ ch ) ; $ httpcode = curl_getinfo ( $ ch , CURLINFO_HTTP_CODE ) ; if ( 403 === $ httpcode ) { $ error = json_decode ( $ jsonData , true ) ; throw new CurlException ( '_makeCall() - ' . $ error [ 'error_type' ] . ' error: ' . $ error [ 'error_message' ] ) ; } if ( false === $ jsonData ) { throw new CurlException ( '_makeCall() - cURL error: ' . curl_error ( $ ch ) ) ; } curl_close ( $ ch ) ; return json_decode ( $ jsonData ) ; }
10133	public function insertBitmap ( $ row , $ col , $ bitmap , $ x = 0 , $ y = 0 , $ scale_x = 1 , $ scale_y = 1 ) { $ bitmap_array = ( is_resource ( $ bitmap ) ? $ this -> processBitmapGd ( $ bitmap ) : $ this -> processBitmap ( $ bitmap ) ) ; list ( $ width , $ height , $ size , $ data ) = $ bitmap_array ; $ width *= $ scale_x ; $ height *= $ scale_y ; $ this -> positionImage ( $ col , $ row , $ x , $ y , $ width , $ height ) ; $ record = 0x007f ; $ length = 8 + $ size ; $ cf = 0x09 ; $ env = 0x01 ; $ lcb = $ size ; $ header = pack ( 'vvvvV' , $ record , $ length , $ cf , $ env , $ lcb ) ; $ this -> append ( $ header . $ data ) ; }
7032	public function run ( $ prog = "migrate" ) { switch ( trim ( $ prog ) ) { case "migrate" : return $ this -> migrate ( ) ; case "drop" : return $ this -> drop ( ) ; case "reset" : return $ this -> drop ( ) & $ this -> migrate ( ) ; default : error_log ( "\n\e[1;31m!\e[0m program $prog not applicable\n" ) ; return false ; } }
2598	public function moveNext ( ) { $ this -> peek = 0 ; $ this -> token = $ this -> lookahead ; $ this -> lookahead = ( isset ( $ this -> tokens [ $ this -> position ] ) ) ? $ this -> tokens [ $ this -> position ++ ] : null ; return $ this -> lookahead !== null ; }
1371	protected function make ( array $ data ) { $ validator = $ this -> validatorFactory -> make ( $ data , $ this -> getRules ( ) , $ this -> getMessages ( ) , $ this -> getAttributes ( ) ) ; $ this -> configureValidator ( $ validator ) ; return $ validator ; }
12810	private static function getForeignKeys ( string $ table ) : array { if ( self :: $ foreignKeysCache !== null && array_key_exists ( $ table , self :: $ foreignKeysCache ) ) return self :: $ foreignKeysCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '$table' " ; self :: $ foreignKeysCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ foreignKeysCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ foreignKeysCache [ $ table ] ; }
6694	public static function applyActive ( & $ Nav ) { if ( $ Nav ) { foreach ( $ Nav as & $ one ) { if ( isset ( $ one [ 'items' ] ) ) { self :: applyActive ( $ one [ 'items' ] ) ; } if ( ! isset ( $ one [ 'active' ] ) ) { if ( is_array ( $ one [ 'url' ] ) ) { $ url = $ one [ 'url' ] [ 0 ] ; $ route = Yii :: $ app -> requestedRoute ; $ params = Yii :: $ app -> request -> getQueryParams ( ) ; if ( $ url === '/' && $ route === Yii :: $ app -> controller -> module -> id . '/dashboard/index' ) { $ one [ 'active' ] = true ; } else { $ url = $ one [ 'url' ] ; $ urlExploded = explode ( '/' , $ url [ 0 ] ) ; $ one [ 'submenuTemplate' ] = '' ; foreach ( self :: $ active as $ activeAction ) { $ urlExploded [ count ( $ urlExploded ) - 1 ] = $ activeAction ; $ url [ 0 ] = implode ( '/' , $ urlExploded ) ; $ one [ 'items' ] [ ] = [ 'label' => $ one [ 'label' ] . ' - ' . $ activeAction , 'url' => $ url , 'options' => [ 'class' => 'hidden' ] ] ; if ( '/' . Yii :: $ app -> request -> getQueryParam ( 'parentRoute' ) === trim ( $ url [ 0 ] ) ) { $ one [ 'items' ] [ ] = [ 'label' => $ one [ 'label' ] . ' - Sub List' , 'url' => array_merge ( [ '/' . $ route ] , $ params ) , 'options' => [ 'class' => 'hidden' ] ] ; } } } } } } } }
1968	public static function findByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; if ( Validator :: isStringUuid ( $ intPid ) ) { $ intPid = StringUtil :: uuidToBin ( $ intPid ) ; } return static :: findBy ( array ( "$t.pid=UNHEX(?)" ) , bin2hex ( $ intPid ) , $ arrOptions ) ; }
6568	protected function createMigration ( ) { $ app = app ( ) ; $ migrationFiles = array ( $ this -> laravel -> path . "/database/migrations/*_create_countries_table.php" => 'countries::generators.migration' , ) ; $ seconds = 0 ; foreach ( $ migrationFiles as $ migrationFile => $ outputFile ) { if ( sizeof ( glob ( $ migrationFile ) ) == 0 ) { $ migrationFile = str_replace ( '*' , date ( 'Y_m_d_His' , strtotime ( '+' . $ seconds . ' seconds' ) ) , $ migrationFile ) ; $ fs = fopen ( $ migrationFile , 'x' ) ; if ( $ fs ) { $ output = "<?php\n\n" . $ app [ 'view' ] -> make ( $ outputFile ) -> with ( 'table' , 'countries' ) -> render ( ) ; fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; } else { return false ; } $ seconds ++ ; } } $ seeder_file = $ this -> laravel -> path . "/database/seeds/CountriesSeeder.php" ; $ output = "<?php\n\n" . $ app [ 'view' ] -> make ( 'countries::generators.seeder' ) -> render ( ) ; if ( ! file_exists ( $ seeder_file ) ) { $ fs = fopen ( $ seeder_file , 'x' ) ; if ( $ fs ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; } else { return false ; } } return true ; }
6531	protected function applyAnalyzer ( array $ mapping , Field $ field , \ stdClass $ rootObject , $ path = null ) { if ( null === $ this -> defaultAnalyzer ) { return $ mapping ; } if ( ! isset ( $ mapping [ 'type' ] ) || 'text' !== $ mapping [ 'type' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'index' ] ) && false === $ mapping [ 'index' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'analyzer' ] ) ) { return $ mapping ; } $ mapping [ 'analyzer' ] = $ this -> defaultAnalyzer ; return $ mapping ; }
8748	public function addMethodCall ( $ methodName , array $ arguments = array ( ) ) { $ this -> actions [ ] = $ methodCall = new MethodCall ( $ methodName , $ arguments ) ; return $ methodCall ; }
6812	private function getDateTimeFormatter ( ) { if ( $ this -> dateTimeFormatter ) { return $ this -> dateTimeFormatter ; } return $ this -> dateTimeFormatter = IntlDateFormatter :: create ( $ this -> locale , IntlDateFormatter :: SHORT , IntlDateFormatter :: SHORT , ini_get ( 'date.timezone' ) , IntlDateFormatter :: GREGORIAN ) ; }
669	protected function generateDependencyData ( $ cache ) { $ db = Instance :: ensure ( $ this -> db , Connection :: className ( ) ) ; if ( $ this -> sql === null ) { throw new InvalidConfigException ( 'DbDependency::sql must be set.' ) ; } if ( $ db -> enableQueryCache ) { $ db -> enableQueryCache = false ; $ result = $ db -> createCommand ( $ this -> sql , $ this -> params ) -> queryOne ( ) ; $ db -> enableQueryCache = true ; } else { $ result = $ db -> createCommand ( $ this -> sql , $ this -> params ) -> queryOne ( ) ; } return $ result ; }
10658	private function _uxsortmRec ( ArrayObject $ a , array $ sortFuncs , $ depth = 0 , $ sortMode = '' ) { $ goOn = ( count ( $ sortFuncs ) > $ depth + 1 ) ; $ it = $ a -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( null !== $ sortFuncs [ $ depth ] ) { if ( $ sortMode == 'a' ) { $ it -> current ( ) -> uasort ( $ sortFuncs [ $ depth ] ) ; } else if ( $ sortMode == 'k' ) { $ it -> current ( ) -> uksort ( $ sortFuncs [ $ depth ] ) ; } else { $ it -> current ( ) -> usort ( $ sortFuncs [ $ depth ] ) ; } } if ( $ goOn ) { $ this -> _uxsortmRec ( $ it -> current ( ) , $ sortFuncs , $ depth + 1 , $ sortMode ) ; } $ it -> next ( ) ; } }
10632	private function getFiles ( $ pattern ) { $ files = $ this -> filesystem -> glob ( $ this -> storagePath . DIRECTORY_SEPARATOR . $ pattern , GLOB_BRACE ) ; return array_filter ( array_map ( 'realpath' , $ files ) ) ; }
6296	private static function migrateConfig ( array $ config ) : array { if ( isset ( $ config [ 'class' ] ) ) { do_action ( 'inpsyde.assets.debug' , 'The asset config-format with "type" and "class" is deprecated.' , $ config ) ; $ config [ 'location' ] = $ config [ 'type' ] ?? Asset :: FRONTEND ; $ config [ 'type' ] = $ config [ 'class' ] ; unset ( $ config [ 'class' ] ) ; } return $ config ; }
9756	function above ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , greaterThan ( $ value ) ) ; }
11253	public function transaction ( callable $ callback ) : void { $ this -> pdo -> beginTransaction ( ) ; $ callback ( $ this ) ; $ this -> pdo -> commit ( ) ; }
243	protected function renderAttribute ( $ attribute , $ index ) { if ( is_string ( $ this -> template ) ) { $ captionOptions = Html :: renderTagAttributes ( ArrayHelper :: getValue ( $ attribute , 'captionOptions' , [ ] ) ) ; $ contentOptions = Html :: renderTagAttributes ( ArrayHelper :: getValue ( $ attribute , 'contentOptions' , [ ] ) ) ; return strtr ( $ this -> template , [ '{label}' => $ attribute [ 'label' ] , '{value}' => $ this -> formatter -> format ( $ attribute [ 'value' ] , $ attribute [ 'format' ] ) , '{captionOptions}' => $ captionOptions , '{contentOptions}' => $ contentOptions , ] ) ; } return call_user_func ( $ this -> template , $ attribute , $ index , $ this ) ; }
2872	public function init ( Mage_Core_Model_Abstract $ model ) { $ this -> class = get_class ( $ model ) ; $ this -> resource = $ model -> getResourceName ( ) ; $ this -> count = 0 ; }
7482	public function changeEncoding ( $ encoding ) { $ encoding = ( string ) $ encoding ; $ this -> string = iconv ( $ this -> encoding , $ encoding , $ this -> string ) ; $ this -> encoding = $ encoding ; return $ this ; }
6865	protected function updateCustomerBalance ( InvoiceInterface $ invoice ) { if ( ! InvoiceTypes :: isCredit ( $ invoice ) ) { return ; } $ sale = $ this -> getSaleFromInvoice ( $ invoice ) ; if ( null === $ customer = $ sale -> getCustomer ( ) ) { return ; } $ methodCs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'paymentMethod' ) ; $ amountCs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'grandTotal' ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ invoice ) ) { $ method = empty ( $ methodCs ) ? $ invoice -> getPaymentMethod ( ) : $ methodCs [ 0 ] ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 0 ] ; if ( $ method && $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , - $ amount , true ) ; } return ; } if ( empty ( $ methodCs ) && empty ( $ amountCs ) ) { return ; } if ( ! empty ( $ methodCs ) && null !== $ method = $ methodCs [ 0 ] ) { $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 0 ] ; if ( $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , - $ amount , true ) ; } } if ( empty ( $ methodCs ) ) { $ method = $ invoice -> getPaymentMethod ( ) ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 1 ] - $ amountCs [ 0 ] ; } else { $ method = $ methodCs [ 1 ] ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 1 ] ; } if ( $ method && $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , $ amount , true ) ; } }
3453	protected function determineStreamName ( string $ aggregateId ) : StreamName { if ( $ this -> oneStreamPerAggregate ) { if ( null === $ this -> streamName ) { $ prefix = $ this -> aggregateType -> toString ( ) ; } else { $ prefix = $ this -> streamName -> toString ( ) ; } return new StreamName ( $ prefix . '-' . $ aggregateId ) ; } if ( null === $ this -> streamName ) { return new StreamName ( 'event_stream' ) ; } return $ this -> streamName ; }
5175	public function set ( string $ key , $ value ) : self { if ( ! isset ( $ this -> props [ $ key ] ) ) { throw new \ Exception ( 'Cannot add new property from set. Use add()' ) ; } $ this -> props [ $ key ] = $ value ; return $ this ; }
3078	protected function hasChannel ( $ channelName , $ channelType ) { $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; return isset ( $ channels [ $ channelType ] [ $ channelName ] ) ; }
9396	public function setSafe ( $ options ) { if ( is_string ( $ options ) ) { $ this -> safe [ ] = $ options ; return $ this ; } if ( is_array ( $ options ) ) { foreach ( $ options as $ key => $ value ) { $ this -> safe [ ] = $ value ; } return $ this ; } throw new InvalidArgumentException ( 'This method expects a string or an array argument.' ) ; }
1746	public function addEnclosure ( $ strFile , $ strUrl = null , $ strMedia = 'enclosure' ) { if ( $ strFile == '' || ! file_exists ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFile ) ) { return ; } if ( $ strUrl === null ) { $ strUrl = Environment :: get ( 'base' ) ; } $ objFile = new File ( $ strFile ) ; $ this -> arrData [ 'enclosure' ] [ ] = array ( 'media' => $ strMedia , 'url' => $ strUrl . System :: urlEncode ( $ strFile ) , 'length' => $ objFile -> size , 'type' => $ objFile -> mime ) ; }
320	protected function renderBodyEndHtml ( $ ajaxMode ) { $ lines = [ ] ; if ( ! empty ( $ this -> jsFiles [ self :: POS_END ] ) ) { $ lines [ ] = implode ( "\n" , $ this -> jsFiles [ self :: POS_END ] ) ; } if ( $ ajaxMode ) { $ scripts = [ ] ; if ( ! empty ( $ this -> js [ self :: POS_END ] ) ) { $ scripts [ ] = implode ( "\n" , $ this -> js [ self :: POS_END ] ) ; } if ( ! empty ( $ this -> js [ self :: POS_READY ] ) ) { $ scripts [ ] = implode ( "\n" , $ this -> js [ self :: POS_READY ] ) ; } if ( ! empty ( $ this -> js [ self :: POS_LOAD ] ) ) { $ scripts [ ] = implode ( "\n" , $ this -> js [ self :: POS_LOAD ] ) ; } if ( ! empty ( $ scripts ) ) { $ lines [ ] = Html :: script ( implode ( "\n" , $ scripts ) ) ; } } else { if ( ! empty ( $ this -> js [ self :: POS_END ] ) ) { $ lines [ ] = Html :: script ( implode ( "\n" , $ this -> js [ self :: POS_END ] ) ) ; } if ( ! empty ( $ this -> js [ self :: POS_READY ] ) ) { $ js = "jQuery(function ($) {\n" . implode ( "\n" , $ this -> js [ self :: POS_READY ] ) . "\n});" ; $ lines [ ] = Html :: script ( $ js ) ; } if ( ! empty ( $ this -> js [ self :: POS_LOAD ] ) ) { $ js = "jQuery(window).on('load', function () {\n" . implode ( "\n" , $ this -> js [ self :: POS_LOAD ] ) . "\n});" ; $ lines [ ] = Html :: script ( $ js ) ; } } return empty ( $ lines ) ? '' : implode ( "\n" , $ lines ) ; }
7969	public function getVoiceConsumptions ( $ params = null ) { $ consumptionList = json_decode ( self :: getClient ( ) -> getVoiceConsumptions ( $ this -> service , $ this -> billingAccount , $ params ) ) ; $ consumptions = array ( ) ; foreach ( $ consumptionList as $ consumption ) { $ consumptions [ ] = new VoiceConsumption ( $ consumption , $ this ) ; } return $ consumptions ; }
8596	public function listMarketplaceParticipations ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4286	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method === 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method === 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ i => $ arg ) { $ args [ $ i ] = $ this -> dump ( $ arg ) ; } $ this -> json [ 'rows' ] [ ] = array ( $ args , isset ( $ meta [ 'file' ] ) ? $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] : null , $ method === 'log' ? '' : $ method , ) ; }
2985	protected function generateIndexView ( $ dir ) { $ this -> renderFile ( 'crud/views/index.html.twig.twig' , $ dir . '/index.html.twig' , array ( 'bundle' => $ this -> bundle -> getName ( ) , 'entity' => $ this -> entity , 'entity_pluralized' => $ this -> entityPluralized , 'entity_singularized' => $ this -> entitySingularized , 'identifier' => $ this -> metadata -> identifier [ 0 ] , 'fields' => $ this -> metadata -> fieldMappings , 'actions' => $ this -> actions , 'record_actions' => $ this -> getRecordActions ( ) , 'route_prefix' => $ this -> routePrefix , 'route_name_prefix' => $ this -> routeNamePrefix , ) ) ; }
9320	protected function getEchoMethods ( ) { $ methods = [ 'compileRawEchos' => strlen ( stripcslashes ( $ this -> rawTags [ 0 ] ) ) , 'compileEscapedEchos' => strlen ( stripcslashes ( $ this -> escapedTags [ 0 ] ) ) , 'compileMarkdownEchos' => strlen ( stripcslashes ( $ this -> markdownTags [ 0 ] ) ) , 'compileRegularEchos' => strlen ( stripcslashes ( $ this -> contentTags [ 0 ] ) ) , ] ; uksort ( $ methods , function ( $ method1 , $ method2 ) use ( $ methods ) { if ( $ methods [ $ method1 ] > $ methods [ $ method2 ] ) { return - 1 ; } if ( $ methods [ $ method1 ] < $ methods [ $ method2 ] ) { return 1 ; } if ( $ method1 === 'compileRawEchos' ) { return - 1 ; } if ( $ method2 === 'compileRawEchos' ) { return 1 ; } if ( $ method1 === 'compileEscapedEchos' ) { return - 1 ; } if ( $ method2 === 'compileEscapedEchos' ) { return 1 ; } if ( $ method1 === 'compileMarkdownEchos' ) { return - 1 ; } if ( $ method2 === 'compileMarkdownEchos' ) { return 1 ; } } ) ; return $ methods ; }
10183	private function getAllCacheKeys ( ) { $ keys = [ ] ; foreach ( $ this -> getCoordinates ( ) as $ coordinate ) { $ keys [ ] = $ this -> cachePrefix . $ coordinate ; } return $ keys ; }
9927	private function cleanUnwanted ( Parameters $ params , $ permitted ) { foreach ( $ params -> toArray ( ) as $ key => $ value ) { if ( is_array ( $ value ) && ! is_int ( $ key ) ) { if ( ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } elseif ( ! is_int ( $ key ) && ! in_array ( $ key , $ permitted ) && ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } }
9377	protected function extract ( $ filepath , array $ data ) { extract ( $ data ) ; ob_start ( ) ; include $ filepath ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; return $ contents ; }
2791	public function hasOks ( $ output ) { $ result = preg_match_all ( "%##teamcity\[testFinished%" , $ output ) ; if ( $ result ) { $ this -> okCount += $ result ; return $ this -> okCount ; } return false ; }
10680	protected function generateURLSegment ( $ title ) { $ filter = URLSegmentFilter :: create ( ) ; $ t = $ filter -> filter ( $ title ) ; if ( ! $ t || $ t == '-' || $ t == '-1' ) { $ t = "{$this->owner->ClassName}-{$this->owner->ID}" ; } else { $ class = $ this -> owner -> ClassName ; $ obj = $ class :: get ( ) -> filter ( array ( "URLSegment" => $ t ) ) -> exclude ( array ( "ID" => $ this -> owner -> ID ) ) -> first ( ) ; if ( $ obj ) { $ t .= "-{$this->owner->ID}" ; } } return $ t ; }
10360	public static function fatal ( ) { $ e = error_get_last ( ) ; if ( $ e !== null && ( error_reporting ( ) & $ e [ 'type' ] ) !== 0 ) { ErrorHandler :: exception ( new \ ErrorException ( $ e [ 'message' ] , $ e [ 'type' ] , 0 , $ e [ 'file' ] , $ e [ 'line' ] ) ) ; exit ( 1 ) ; } }
6869	protected function buildInvoiceList ( IM \ InvoiceSubjectInterface $ subject ) { $ invoices = $ subject -> getInvoices ( true ) -> toArray ( ) ; usort ( $ invoices , function ( IM \ InvoiceInterface $ a , IM \ InvoiceInterface $ b ) { return $ a -> getCreatedAt ( ) -> getTimestamp ( ) - $ b -> getCreatedAt ( ) -> getTimestamp ( ) ; } ) ; return array_map ( function ( IM \ InvoiceInterface $ invoice ) { return [ 'invoice' => $ invoice , 'total' => $ invoice -> getGrandTotal ( ) , ] ; } , $ invoices ) ; }
3480	public function withLaunchImage ( string $ launchImage ) : Alert { $ cloned = clone $ this ; $ cloned -> launchImage = $ launchImage ; return $ cloned ; }
8191	public function actionConfirm ( $ id , $ code ) { $ user = UserIdentity :: findByActivationToken ( $ id , $ code ) ; if ( $ user == NULL ) throw new NotFoundHttpException ; if ( ! empty ( $ user ) ) { $ user -> activation_token = NULL ; $ user -> status = User :: STATUS_ACTIVE ; $ user -> save ( FALSE ) ; Yii :: $ app -> session -> setFlash ( 'success' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' has successfully been activated' ) ) ; } else Yii :: $ app -> session -> setFlash ( 'error' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' could not been activated. Please contact the Administrator' ) ) ; return $ this -> render ( 'confirm' , [ 'user' => $ user ] ) ; }
1390	protected function resourceDoesNotExist ( string $ path ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotExist ( $ path ) ) ; }
3549	protected function registerRepository ( ) { $ this -> app -> singleton ( CachingRepository :: class , function ( Container $ app ) { $ repo = new GitHubRepository ( GuzzleFactory :: make ( ) , $ app -> config -> get ( 'emoji.token' ) ) ; $ cache = $ app -> cache -> store ( $ app -> config -> get ( 'emoji.connection' ) ) ; $ key = $ app -> config -> get ( 'emoji.key' , 'emoji' ) ; $ life = ( int ) $ app -> config -> get ( 'emoji.life' , 10080 ) ; return new CachingRepository ( $ repo , $ cache , $ key , $ life ) ; } ) ; $ this -> app -> alias ( CachingRepository :: class , RepositoryInterface :: class ) ; }
1995	public function generateRss ( ) { $ this -> adjustPublicationDate ( ) ; $ xml = '<?xml version="1.0" encoding="' . Config :: get ( 'characterSet' ) . '"?>' ; $ xml .= '<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/" xmlns:atom="http://www.w3.org/2005/Atom">' ; $ xml .= '<channel>' ; $ xml .= '<title>' . StringUtil :: specialchars ( $ this -> title ) . '</title>' ; $ xml .= '<description>' . StringUtil :: specialchars ( $ this -> description ) . '</description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ this -> link ) . '</link>' ; $ xml .= '<language>' . $ this -> language . '</language>' ; $ xml .= '<pubDate>' . date ( 'r' , $ this -> published ) . '</pubDate>' ; $ xml .= '<generator>Contao Open Source CMS</generator>' ; $ xml .= '<atom:link href="' . StringUtil :: specialchars ( Environment :: get ( 'base' ) . 'share/' . $ this -> strName ) . '.xml" rel="self" type="application/rss+xml" />' ; foreach ( $ this -> arrItems as $ objItem ) { $ xml .= '<item>' ; $ xml .= '<title>' . StringUtil :: specialchars ( strip_tags ( StringUtil :: stripInsertTags ( $ objItem -> title ) ) ) . '</title>' ; $ xml .= '<description><![CDATA[' . preg_replace ( '/[\n\r]+/' , ' ' , $ objItem -> description ) . ']]></description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ objItem -> link ) . '</link>' ; $ xml .= '<pubDate>' . date ( 'r' , $ objItem -> published ) . '</pubDate>' ; if ( $ objItem -> guid ) { if ( strncmp ( $ objItem -> guid , 'http://' , 7 ) !== 0 && strncmp ( $ objItem -> guid , 'https://' , 8 ) !== 0 ) { $ xml .= '<guid isPermaLink="false">' . $ objItem -> guid . '</guid>' ; } else { $ xml .= '<guid>' . $ objItem -> guid . '</guid>' ; } } else { $ xml .= '<guid>' . StringUtil :: specialchars ( $ objItem -> link ) . '</guid>' ; } if ( \ is_array ( $ objItem -> enclosure ) ) { foreach ( $ objItem -> enclosure as $ arrEnclosure ) { if ( ! empty ( $ arrEnclosure [ 'media' ] ) && $ arrEnclosure [ 'media' ] == 'media:content' ) { $ xml .= '<media:content url="' . $ arrEnclosure [ 'url' ] . '" type="' . $ arrEnclosure [ 'type' ] . '" />' ; } else { $ xml .= '<enclosure url="' . $ arrEnclosure [ 'url' ] . '" length="' . $ arrEnclosure [ 'length' ] . '" type="' . $ arrEnclosure [ 'type' ] . '" />' ; } } } $ xml .= '</item>' ; } $ xml .= '</channel>' ; $ xml .= '</rss>' ; return $ xml ; }
426	public static function getInstance ( ) { $ class = get_called_class ( ) ; return isset ( Yii :: $ app -> loadedModules [ $ class ] ) ? Yii :: $ app -> loadedModules [ $ class ] : null ; }
935	public static function isKeyCaseSensitive ( $ caseSensitive , $ key ) { if ( \ is_array ( $ caseSensitive ) ) { return isset ( $ caseSensitive [ $ key ] ) ? $ caseSensitive [ $ key ] : true ; } return $ caseSensitive ; }
11866	public function lock ( string $ sessionIdentifier ) : bool { if ( in_array ( $ sessionIdentifier , self :: $ lockedIdentifiers ) ) { return true ; } self :: $ lockedIdentifiers [ ] = $ sessionIdentifier ; return true ; }
608	private function addTokenFromBuffer ( ) { if ( $ this -> _buffer === '' ) { return ; } $ isKeyword = $ this -> isKeyword ( $ this -> _buffer , $ content ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => $ isKeyword ? SqlToken :: TYPE_KEYWORD : SqlToken :: TYPE_TOKEN , 'content' => is_string ( $ content ) ? $ content : $ this -> _buffer , 'startOffset' => $ this -> offset - mb_strlen ( $ this -> _buffer , 'UTF-8' ) , 'endOffset' => $ this -> offset , ] ) ; $ this -> _buffer = '' ; }
9565	public function addBeforeHook ( $ hook ) { if ( ! isset ( $ this -> options [ 'before' ] ) ) { $ this -> options [ 'before' ] = [ ] ; } $ this -> options [ 'before' ] [ ] = $ hook ; }
5194	public function addRoutes ( RouteCollector $ routeCollector ) : void { foreach ( $ this -> routes as $ index => $ route ) { $ routeCollector -> addRoute ( $ route -> getMethods ( ) , $ route -> getPath ( ) , $ index ) ; } }
10279	public static function coordinateFromString ( $ pCoordinateString ) { if ( preg_match ( '/^([$]?[A-Z]{1,3})([$]?\\d{1,7})$/' , $ pCoordinateString , $ matches ) ) { return [ $ matches [ 1 ] , $ matches [ 2 ] ] ; } elseif ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } elseif ( $ pCoordinateString == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string' ) ; } throw new Exception ( 'Invalid cell coordinate ' . $ pCoordinateString ) ; }
12063	public function can_save_post_meta ( $ post_id , $ action , $ nonce ) { $ is_autosave = wp_is_post_autosave ( $ post_id ) ; $ is_revision = wp_is_post_revision ( $ post_id ) ; $ is_valid_nonce = ( isset ( $ _POST [ $ nonce ] ) && wp_verify_nonce ( $ _POST [ $ nonce ] , $ action ) ) ; return ! ( $ is_autosave || $ is_revision ) && $ is_valid_nonce ; }
1047	public static function create ( array $ params , bool $ readonly = false ) : OperationParams { $ instance = new static ( ) ; $ params = array_change_key_case ( $ params , CASE_LOWER ) ; $ instance -> originalInput = $ params ; $ params += [ 'query' => null , 'queryid' => null , 'documentid' => null , 'id' => null , 'operationname' => null , 'variables' => null , 'extensions' => null , ] ; if ( $ params [ 'variables' ] === '' ) { $ params [ 'variables' ] = null ; } foreach ( [ 'extensions' , 'variables' ] as $ param ) { if ( ! is_string ( $ params [ $ param ] ) ) { continue ; } $ tmp = json_decode ( $ params [ $ param ] , true ) ; if ( json_last_error ( ) ) { continue ; } $ params [ $ param ] = $ tmp ; } $ instance -> query = $ params [ 'query' ] ; $ instance -> queryId = $ params [ 'queryid' ] ? : $ params [ 'documentid' ] ? : $ params [ 'id' ] ; $ instance -> operation = $ params [ 'operationname' ] ; $ instance -> variables = $ params [ 'variables' ] ; $ instance -> extensions = $ params [ 'extensions' ] ; $ instance -> readOnly = $ readonly ; if ( isset ( $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ) && empty ( $ instance -> query ) && empty ( $ instance -> queryId ) ) { $ instance -> queryId = $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ; } return $ instance ; }
8848	public function tag ( ) { $ tag = $ this -> getCurrentTag ( ) ; if ( $ tag ) { $ this -> blogPosts = $ tag -> BlogPosts ( ) ; return $ this -> render ( ) ; } return $ this -> httpError ( 404 , "Not Found" ) ; }
4567	public function resolve ( Form $ form ) { switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ resolve = function ( & $ component ) use ( & $ resolve , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as & $ subComponent ) { $ resolve ( $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as & $ subComponent ) { $ resolve ( $ subComponent ) ; } } break ; case property_exists ( $ component , 'defaultValue' ) : if ( null !== $ component -> defaultValue ) { try { $ component -> defaultValue = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ component -> defaultValue = null ; } catch ( UnmatchedException $ exception ) { } } break ; } } ; foreach ( $ components as & $ component ) { $ resolve ( $ component ) ; } $ form -> setSchema ( $ components ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ form ; }
4361	public static function isUtf8 ( $ str , & $ special = false ) { self :: setStr ( $ str ) ; $ special = false ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial ) ; if ( ! $ isUtf8 ) { return false ; } if ( $ isSpecial ) { $ special = true ; } } $ special = $ special || self :: hasSpecial ( $ str ) ; return true ; }
982	public function index ( Plan $ plan ) { if ( is_null ( $ plan ) || ( $ plan && ! $ plan -> exists ) ) { $ plan = Plan :: where ( 'on_install' , true ) -> first ( ) ; } $ bp = new BillingPlan ( ShopifyApp :: shop ( ) , $ plan ) ; $ url = $ bp -> confirmationUrl ( ) ; return View :: make ( 'shopify-app::billing.fullpage_redirect' , compact ( 'url' ) ) ; }
8397	public function getDefinition ( ) : array { if ( $ this -> definition == null ) { $ data = Mapping :: get ( $ this -> mapping ) ; $ this -> definition = Config :: get ( $ data [ 'config' ] [ 'schema' ] ) ; } return $ this -> definition ; }
205	public static function wrapText ( $ text , $ indent = 0 , $ refresh = false ) { $ size = static :: getScreenSize ( $ refresh ) ; if ( $ size === false || $ size [ 0 ] <= $ indent ) { return $ text ; } $ pad = str_repeat ( ' ' , $ indent ) ; $ lines = explode ( "\n" , wordwrap ( $ text , $ size [ 0 ] - $ indent , "\n" , true ) ) ; $ first = true ; foreach ( $ lines as $ i => $ line ) { if ( $ first ) { $ first = false ; continue ; } $ lines [ $ i ] = $ pad . $ line ; } return implode ( "\n" , $ lines ) ; }
4653	public function getJobsToRemove ( $ projectPath , $ keep = 1 ) { $ currentJobs = $ this -> strategy -> getJobs ( $ projectPath ) ; $ existingJobs = $ this -> getJobs ( $ projectPath ) ; $ uniqList = array ( ) ; $ removes = array ( ) ; $ ordered = array ( ) ; foreach ( $ currentJobs as $ job ) { $ uniqList [ ] = $ job -> getUniq ( ) ; } foreach ( $ existingJobs as $ job ) { if ( ! in_array ( $ job -> getUniq ( ) , $ uniqList ) ) { $ removes [ ] = $ job ; } else { $ ordered [ $ job -> getUniq ( ) ] [ $ job -> getCreated ( ) -> format ( 'U' ) ] = $ job ; } } foreach ( $ ordered as $ jobs ) { ksort ( $ jobs ) ; $ keeped = count ( $ jobs ) ; while ( $ keeped > $ keep ) { $ removes [ ] = array_shift ( $ jobs ) ; $ keeped -- ; } } return $ removes ; }
1332	protected function readWithFilters ( $ record , EncodingParametersInterface $ parameters ) { $ query = $ this -> newQuery ( ) -> whereKey ( $ record -> getKey ( ) ) ; $ this -> applyFilters ( $ query , collect ( $ parameters -> getFilteringParameters ( ) ) ) ; return $ query -> exists ( ) ? $ record : null ; }
285	public function setDefault ( $ name , $ value ) { $ name = strtolower ( $ name ) ; if ( empty ( $ this -> _headers [ $ name ] ) ) { $ this -> _headers [ $ name ] [ ] = $ value ; } return $ this ; }
4345	public function getCfgLazy ( $ name ) { if ( ! isset ( $ this -> cfgLazy [ $ name ] ) ) { return array ( ) ; } $ return = $ this -> cfgLazy [ $ name ] ; unset ( $ this -> cfgLazy [ $ name ] ) ; return $ return ; }
55	public function download ( PackageInterface $ package , $ targetDir , $ preferSource = null ) { $ preferSource = null !== $ preferSource ? $ preferSource : $ this -> preferSource ; $ sourceType = $ package -> getSourceType ( ) ; $ distType = $ package -> getDistType ( ) ; $ sources = array ( ) ; if ( $ sourceType ) { $ sources [ ] = 'source' ; } if ( $ distType ) { $ sources [ ] = 'dist' ; } if ( empty ( $ sources ) ) { throw new \ InvalidArgumentException ( 'Package ' . $ package . ' must have a source or dist specified' ) ; } if ( ! $ preferSource && ( $ this -> preferDist || 'dist' === $ this -> resolvePackageInstallPreference ( $ package ) ) ) { $ sources = array_reverse ( $ sources ) ; } $ this -> filesystem -> ensureDirectoryExists ( $ targetDir ) ; foreach ( $ sources as $ i => $ source ) { if ( isset ( $ e ) ) { $ this -> io -> writeError ( ' <warning>Now trying to download from ' . $ source . '</warning>' ) ; } $ package -> setInstallationSource ( $ source ) ; try { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> download ( $ package , $ targetDir ) ; } break ; } catch ( \ RuntimeException $ e ) { if ( $ i === count ( $ sources ) - 1 ) { throw $ e ; } $ this -> io -> writeError ( ' <warning>Failed to download ' . $ package -> getPrettyName ( ) . ' from ' . $ source . ': ' . $ e -> getMessage ( ) . '</warning>' ) ; } } }
939	public function isWhitespace ( $ whitespaces = " \t\n\r\0\x0B" ) { if ( null === $ whitespaces ) { $ whitespaces = " \t\n\r\0\x0B" ; } if ( $ this -> isArray && ! $ this -> isGivenKind ( T_WHITESPACE ) ) { return false ; } return '' === trim ( $ this -> content , $ whitespaces ) ; }
11426	public function blacklist ( $ beginOpenid = null ) { $ params = [ 'begin_openid' => $ beginOpenid ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_BLACK_LIST , $ params ] ) ; }
470	public function up ( ) { $ transaction = $ this -> db -> beginTransaction ( ) ; try { if ( $ this -> safeUp ( ) === false ) { $ transaction -> rollBack ( ) ; return false ; } $ transaction -> commit ( ) ; } catch ( \ Exception $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } catch ( \ Throwable $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } return null ; }
11189	public static function json ( $ jsonStr , $ k = null , $ default = null ) { $ json = json_decode ( $ jsonStr , true ) ; if ( $ k && $ json ) { return self :: get ( $ json , $ k , $ default ) ; } return $ json ; }
7668	function RFCDate ( ) { $ tz = date ( "Z" ) ; $ tzs = ( $ tz < 0 ) ? "-" : "+" ; $ tz = abs ( $ tz ) ; $ tz = ( $ tz / 3600 ) * 100 + ( $ tz % 3600 ) / 60 ; $ result = sprintf ( "%s %s%04d" , date ( "D, j M Y H:i:s" ) , $ tzs , $ tz ) ; return $ result ; }
1015	public function setValidationRules ( $ validationRules ) { if ( ! is_callable ( $ validationRules ) && ! is_array ( $ validationRules ) && $ validationRules !== null ) { throw new InvariantViolation ( 'Server config expects array of validation rules or callable returning such array, but got ' . Utils :: printSafe ( $ validationRules ) ) ; } $ this -> validationRules = $ validationRules ; return $ this ; }
10597	protected function getRouteLocalizedRecord ( \ MvcCore \ IRoute & $ route , $ getter ) { $ result = $ route -> $ getter ( $ this -> requestLang ) ; if ( $ result === NULL && $ this -> defaultLang !== NULL ) $ result = $ route -> $ getter ( $ this -> defaultLang ) ; return $ result ; }
7501	public function clearCache ( string $ namespace = null ) { if ( null !== $ namespace ) { $ this -> cacheStore -> remove ( self :: APP_CACHE_PREFIX . $ namespace , array ( ) ) ; return ; } $ this -> cacheStore -> clear ( ) ; }
12678	public function toJSON ( $ pretty = false ) { if ( $ pretty ) { return json_encode ( $ this -> scope -> results , JSON_PRETTY_PRINT ) ; } return json_encode ( $ this -> scope -> results ) ; }
4075	protected function setTableMapping ( $ modelId , $ tableName ) { $ this -> information [ $ tableName ] [ self :: MODELID ] = $ modelId ; $ this -> tableMap [ $ modelId ] = $ tableName ; }
10171	function fromXML ( $ xmlElement ) { foreach ( $ xmlElement -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = $ field -> type ; } }
5972	public function deployment ( ) { if ( ! $ this -> deployment instanceof DeploymentController ) { $ this -> deployment = new DeploymentController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> deployment -> setLogger ( $ this -> logger ) ; } return $ this -> deployment ; }
4241	public function onError ( Event $ error ) { if ( $ this -> debug -> getCfg ( 'collect' ) ) { $ this -> error = $ error ; $ errInfo = $ error [ 'typeStr' ] . ': ' . $ error [ 'file' ] . ' (line ' . $ error [ 'line' ] . ')' ; $ errMsg = $ error [ 'message' ] ; if ( $ error [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ) { $ this -> debug -> error ( $ errInfo . ': ' , $ errMsg ) ; } else { $ this -> debug -> warn ( $ errInfo . ': ' , $ errMsg ) ; } $ error [ 'continueToNormal' ] = false ; $ error [ 'inConsole' ] = true ; $ error [ 'email' ] = false ; $ this -> error = null ; } elseif ( $ this -> debug -> getCfg ( 'output' ) ) { $ error [ 'email' ] = false ; $ error [ 'inConsole' ] = false ; } else { $ error [ 'inConsole' ] = false ; } }
8070	private function getDomainControllerStrategy ( array $ domain_controller ) { $ protocol = $ this -> ssl ? $ this :: PROTOCOL_SSL : $ this :: PROTOCOL ; if ( count ( $ domain_controller ) === 1 ) { return new SingleDomainController ( $ protocol , $ domain_controller ) ; } if ( $ this -> backup === true ) { return new RebindDomainController ( $ protocol , $ domain_controller ) ; } else { return new LoadBalancingDomainController ( $ protocol , $ domain_controller ) ; } }
11851	public function show ( ) { $ response = new \ Venus \ lib \ Response ( ) ; $ response -> setContent ( '<html><body><h1>Hello world!</h1></body></html>' ) ; $ response -> setStatusCode ( \ Venus \ lib \ Response :: HTTP_OK ) ; $ response -> headers -> set ( 'Content-Type' , 'text/html' ) ; $ response -> send ( ) ; }
9731	public function canRead ( $ pFilename ) { try { $ this -> openFile ( $ pFilename ) ; } catch ( Exception $ e ) { return false ; } $ data = fread ( $ this -> fileHandle , 2048 ) ; $ delimiterCount = substr_count ( $ data , ';' ) ; $ hasDelimiter = $ delimiterCount > 0 ; $ lines = explode ( "\n" , $ data ) ; $ hasId = substr ( $ lines [ 0 ] , 0 , 4 ) === 'ID;P' ; fclose ( $ this -> fileHandle ) ; return $ hasDelimiter && $ hasId ; }
9349	public function multiplyAllow ( $ matrix ) { if ( is_numeric ( $ matrix ) ) { return true ; } if ( $ matrix instanceof Complex ) { return true ; } if ( $ matrix instanceof Matrix ) { return $ this -> size -> cols == $ matrix -> rows ; } return false ; }
6820	protected function writeInvoiceTaxesLine ( ) { $ sale = $ this -> invoice -> getSale ( ) ; $ date = $ sale -> getCreatedAt ( ) ; $ credit = $ this -> invoice -> getType ( ) === InvoiceTypes :: TYPE_CREDIT ; foreach ( $ this -> invoice -> getTaxesDetails ( ) as $ detail ) { $ amount = $ this -> round ( $ detail [ 'amount' ] ) ; if ( 0 === $ this -> compare ( $ amount , 0 ) ) { continue ; } $ account = $ this -> getTaxAccountNumber ( $ detail [ 'rate' ] , $ this -> invoice -> getNumber ( ) ) ; if ( $ credit ) { $ this -> writer -> credit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance -= $ amount ; } else { $ this -> writer -> debit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance += $ amount ; } } }
7358	private function loadPriceMap ( ) { if ( null === $ this -> pricesMap ) { $ this -> pricesMap = $ this -> getPricesMapLoader ( ) -> load ( $ this -> currency ) ; } }
9643	public static function getDriver ( MappingDriver $ originalDriver , $ namespace ) { if ( $ originalDriver instanceof MappingDriverChain ) { $ driver = new Driver \ Chain ( ) ; foreach ( $ originalDriver -> getDrivers ( ) as $ nestedNamespace => $ nestedDriver ) { $ driver -> addDriver ( static :: getDriver ( $ nestedDriver , $ namespace ) , $ nestedNamespace ) ; } if ( $ originalDriver -> getDefaultDriver ( ) !== null ) { $ driver -> setDefaultDriver ( static :: getDriver ( $ originalDriver -> getDefaultDriver ( ) , $ namespace ) ) ; } return $ driver ; } preg_match ( '/(?P<type>Xml|Yaml|Annotation)Driver$/' , get_class ( $ originalDriver ) , $ m ) ; $ type = isset ( $ m [ 'type' ] ) ? $ m [ 'type' ] : null ; $ driverClass = sprintf ( '%s\Mapping\Driver\%s' , $ namespace , $ type ) ; if ( ! $ type || ! class_exists ( $ driverClass ) ) { $ driverClass = sprintf ( '%s\Mapping\Driver\Annotation' , $ namespace ) ; if ( ! class_exists ( $ driverClass ) ) { throw new \ RuntimeException ( sprintf ( 'Failed to fallback to annotation driver: (%s), extension driver was not found.' , $ driverClass ) ) ; } } $ driver = new $ driverClass ( ) ; $ driver -> setOriginalDriver ( $ originalDriver ) ; if ( $ driver instanceof Driver \ File ) { $ driver -> setLocator ( $ originalDriver -> getLocator ( ) ) ; } elseif ( $ driver instanceof AnnotationDriverInterface ) { $ reader = static :: getAnnotationReader ( ) ; $ driver -> setAnnotationReader ( $ reader ) ; } return $ driver ; }
4959	public function detach ( EventManagerInterface $ events ) { foreach ( $ this -> listeners as $ index => $ listener ) { if ( $ events -> detach ( $ listener ) ) { unset ( $ this -> listeners [ $ index ] ) ; } } $ sharedEvents = $ events -> getSharedManager ( ) ; foreach ( $ this -> sharedListeners as $ index => $ listener ) { if ( $ sharedEvents -> detach ( $ listener ) ) { unset ( $ this -> sharedListeners [ $ index ] ) ; } } }
2521	public function pnrIgnore ( RequestOptions \ PnrIgnoreOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Ignore' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
2005	protected function validateForm ( Widget $ objWidget = null ) { $ varInput = Idna :: encodeEmail ( Input :: post ( 'email' , true ) ) ; if ( ! Validator :: isEmail ( $ varInput ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'email' ] ; return false ; } $ this -> Template -> email = $ varInput ; $ arrChannels = Input :: post ( 'channels' ) ; if ( ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ arrChannels = array_intersect ( $ arrChannels , $ this -> nl_channels ) ; if ( empty ( $ arrChannels ) || ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ this -> Template -> selectedChannels = $ arrChannels ; $ arrSubscriptions = array ( ) ; if ( ( $ objSubscription = NewsletterRecipientsModel :: findBy ( array ( "email=? AND active='1'" ) , $ varInput ) ) !== null ) { $ arrSubscriptions = $ objSubscription -> fetchEach ( 'pid' ) ; } $ arrChannels = array_intersect ( $ arrChannels , $ arrSubscriptions ) ; if ( empty ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unsubscribed' ] ; return false ; } if ( $ objWidget !== null ) { $ objWidget -> validate ( ) ; if ( $ objWidget -> hasErrors ( ) ) { return false ; } } return array ( $ varInput , $ arrChannels ) ; }
4860	public function push ( JobInterface $ job , array $ options = [ ] ) { $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; $ result = $ this -> mongoCollection -> insertOne ( $ envelope ) ; $ job -> setId ( ( string ) $ result -> getInsertedId ( ) ) ; }
9570	public function addMiddleware ( $ middleware , $ priority = null ) { $ this -> middlewares -> insert ( $ middleware , ( int ) $ priority ) ; }
3572	public function set ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { return $ this -> setInstance ( $ key ) ; } if ( $ this -> has ( $ key ) ) { $ this -> update ( $ key , $ value , $ group ) ; } else { $ this -> items [ $ key ] = $ this -> newAttribute ( $ key , $ value , $ group ) ; } return $ this ; }
10200	private function writeXfStyles ( XMLWriter $ writer , Spreadsheet $ spreadsheet ) { foreach ( $ spreadsheet -> getCellXfCollection ( ) as $ style ) { $ writer -> startElement ( 'style:style' ) ; $ writer -> writeAttribute ( 'style:name' , self :: CELL_STYLE_PREFIX . $ style -> getIndex ( ) ) ; $ writer -> writeAttribute ( 'style:family' , 'table-cell' ) ; $ writer -> writeAttribute ( 'style:parent-style-name' , 'Default' ) ; $ writer -> startElement ( 'style:text-properties' ) ; $ font = $ style -> getFont ( ) ; if ( $ font -> getBold ( ) ) { $ writer -> writeAttribute ( 'fo:font-weight' , 'bold' ) ; $ writer -> writeAttribute ( 'style:font-weight-complex' , 'bold' ) ; $ writer -> writeAttribute ( 'style:font-weight-asian' , 'bold' ) ; } if ( $ font -> getItalic ( ) ) { $ writer -> writeAttribute ( 'fo:font-style' , 'italic' ) ; } if ( $ color = $ font -> getColor ( ) ) { $ writer -> writeAttribute ( 'fo:color' , sprintf ( '#%s' , $ color -> getRGB ( ) ) ) ; } if ( $ family = $ font -> getName ( ) ) { $ writer -> writeAttribute ( 'fo:font-family' , $ family ) ; } if ( $ size = $ font -> getSize ( ) ) { $ writer -> writeAttribute ( 'fo:font-size' , sprintf ( '%.1fpt' , $ size ) ) ; } if ( $ font -> getUnderline ( ) && $ font -> getUnderline ( ) != Font :: UNDERLINE_NONE ) { $ writer -> writeAttribute ( 'style:text-underline-style' , 'solid' ) ; $ writer -> writeAttribute ( 'style:text-underline-width' , 'auto' ) ; $ writer -> writeAttribute ( 'style:text-underline-color' , 'font-color' ) ; switch ( $ font -> getUnderline ( ) ) { case Font :: UNDERLINE_DOUBLE : $ writer -> writeAttribute ( 'style:text-underline-type' , 'double' ) ; break ; case Font :: UNDERLINE_SINGLE : $ writer -> writeAttribute ( 'style:text-underline-type' , 'single' ) ; break ; } } $ writer -> endElement ( ) ; $ writer -> startElement ( 'style:table-cell-properties' ) ; $ writer -> writeAttribute ( 'style:rotation-align' , 'none' ) ; if ( $ fill = $ style -> getFill ( ) ) { switch ( $ fill -> getFillType ( ) ) { case Fill :: FILL_SOLID : $ writer -> writeAttribute ( 'fo:background-color' , sprintf ( '#%s' , strtolower ( $ fill -> getStartColor ( ) -> getRGB ( ) ) ) ) ; break ; case Fill :: FILL_GRADIENT_LINEAR : case Fill :: FILL_GRADIENT_PATH : break ; case Fill :: FILL_NONE : default : } } $ writer -> endElement ( ) ; $ writer -> endElement ( ) ; } }
16	public static function getContentHash ( $ composerFileContents ) { $ content = json_decode ( $ composerFileContents , true ) ; $ relevantKeys = array ( 'name' , 'version' , 'require' , 'require-dev' , 'conflict' , 'replace' , 'provide' , 'minimum-stability' , 'prefer-stable' , 'repositories' , 'extra' , ) ; $ relevantContent = array ( ) ; foreach ( array_intersect ( $ relevantKeys , array_keys ( $ content ) ) as $ key ) { $ relevantContent [ $ key ] = $ content [ $ key ] ; } if ( isset ( $ content [ 'config' ] [ 'platform' ] ) ) { $ relevantContent [ 'config' ] [ 'platform' ] = $ content [ 'config' ] [ 'platform' ] ; } ksort ( $ relevantContent ) ; return md5 ( json_encode ( $ relevantContent ) ) ; }
12736	public function mapModelToLangName ( $ modelName , $ langName ) { $ modelName = $ this -> getClassName ( $ modelName ) ; $ this -> modelToLangName [ $ modelName ] = $ langName ; }
97	private function selectRestVersion ( $ channelXml , $ supportedVersions ) { $ channelXml -> registerXPathNamespace ( 'ns' , self :: CHANNEL_NS ) ; foreach ( $ supportedVersions as $ version ) { $ xpathTest = "ns:servers/ns:*/ns:rest/ns:baseurl[@type='{$version}']" ; $ testResult = $ channelXml -> xpath ( $ xpathTest ) ; foreach ( $ testResult as $ result ) { $ result = ( string ) $ result ; if ( preg_match ( '{^https://}i' , $ result ) ) { return array ( 'version' => $ version , 'baseUrl' => $ result ) ; } } if ( count ( $ testResult ) > 0 ) { return array ( 'version' => $ version , 'baseUrl' => ( string ) $ testResult [ 0 ] ) ; } } return null ; }
6382	public function readQuestions ( $ quizId ) { $ quizSlots = $ this -> readStoreRecords ( 'quiz_slots' , [ 'quizid' => $ quizId ] ) ; $ questions = [ ] ; foreach ( $ quizSlots as $ index => $ quizSlot ) { try { $ question = $ this -> readStoreRecord ( 'question' , [ 'id' => $ quizSlot -> questionid ] ) ; $ question -> answers = $ this -> readStoreRecords ( 'question_answers' , [ 'question' => $ question -> id ] ) ; $ question -> url = $ this -> cfg -> wwwroot . '/mod/question/question.php?id=' . $ question -> id ; if ( $ question -> qtype == 'numerical' ) { $ question -> numerical = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_numerical' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_numerical_options' , [ 'question' => $ question -> id ] ) , 'units' => $ this -> readStoreRecords ( 'question_numerical_units' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'match' ) { $ question -> match = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_match_options' , [ 'questionid' => $ question -> id ] ) , 'subquestions' => $ this -> readStoreRecords ( 'qtype_match_subquestions' , [ 'questionid' => $ question -> id ] ) ] ; } else if ( strpos ( $ question -> qtype , 'calculated' ) === 0 ) { $ question -> calculated = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_calculated' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_calculated_options' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'shortanswer' ) { $ question -> shortanswer = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_shortanswer_options' , [ 'questionid' => $ question -> id ] ) ] ; } $ questions [ $ question -> id ] = $ question ; } catch ( \ Exception $ e ) { } } return $ questions ; }
2048	private function createStatement ( ) : void { if ( null !== $ this -> statement ) { return ; } if ( null === $ this -> container || ! $ this -> container -> has ( $ this -> dbalServiceName ) ) { throw new \ RuntimeException ( 'The container has not been injected or the database service is missing' ) ; } $ connection = $ this -> container -> get ( $ this -> dbalServiceName ) ; $ this -> statement = $ connection -> prepare ( ' INSERT INTO tl_log (tstamp, source, action, username, text, func, browser) VALUES (:tstamp, :source, :action, :username, :text, :func, :browser) ' ) ; }
1042	private function printBlockString ( $ value , $ isDescription ) { $ escaped = str_replace ( '"""' , '\\"""' , $ value ) ; return ( $ value [ 0 ] === ' ' || $ value [ 0 ] === "\t" ) && strpos ( $ value , "\n" ) === false ? ( '"""' . preg_replace ( '/"$/' , "\"\n" , $ escaped ) . '"""' ) : ( '"""' . "\n" . ( $ isDescription ? $ escaped : $ this -> indent ( $ escaped ) ) . "\n" . '"""' ) ; }
2334	public function onSwitchUser ( SwitchUserEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'The token storage did not contain a token.' ) ; } $ sourceUser = $ token -> getUser ( ) ; if ( $ sourceUser instanceof UserInterface ) { $ sourceUser = $ sourceUser -> getUsername ( ) ; } $ targetUser = $ event -> getTargetUser ( ) ; if ( $ targetUser instanceof UserInterface ) { $ targetUser = $ targetUser -> getUsername ( ) ; } $ this -> logger -> info ( sprintf ( 'User "%s" has switched to user "%s"' , $ sourceUser , $ targetUser ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ sourceUser ) ] ) ; }
8827	public function token ( ) { $ token = ! empty ( $ this -> csrfToken ) ? $ this -> csrfToken : csrfToken ( ) ; return $ this -> hidden ( '_token' , $ token ) ; }
7150	public function clear ( ) { $ this -> provider = null ; $ this -> identifier = null ; $ this -> subject = null ; }
7591	public function render ( $ sBadgeMessage , array $ aBadgeAttributes = null ) { if ( ! is_scalar ( $ sBadgeMessage ) ) { throw new InvalidArgumentException ( sprintf ( 'Badge message expects a scalar value, "%s" given' , is_object ( $ sBadgeMessage ) ? get_class ( $ sBadgeMessage ) : gettype ( $ sBadgeMessage ) ) ) ; } if ( empty ( $ aBadgeAttributes ) ) { $ aBadgeAttributes = array ( 'class' => 'badge' ) ; } else { if ( empty ( $ aBadgeAttributes [ 'class' ] ) ) { $ aBadgeAttributes [ 'class' ] = 'badge' ; } elseif ( ! preg_match ( '/(\s|^)badge(\s|$)/' , $ aBadgeAttributes [ 'class' ] ) ) { $ aBadgeAttributes [ 'class' ] .= ' badge' ; } } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sBadgeMessage = $ oTranslator -> translate ( $ sBadgeMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ badgeFormat , $ this -> createAttributesString ( $ aBadgeAttributes ) , $ sBadgeMessage ) ; }
11788	private function updateTv ( $ dwnl ) { $ entity = new EBonDwnl ( ) ; foreach ( $ dwnl as $ one ) { $ tv = $ one -> getTv ( ) ; $ calcId = $ one -> getCalculationRef ( ) ; $ custId = $ one -> getCustomerRef ( ) ; $ entity -> setTv ( $ tv ) ; $ id = [ EBonDwnl :: A_CALC_REF => $ calcId , EBonDwnl :: A_CUST_REF => $ custId ] ; $ this -> daoBonDwnl -> updateById ( $ id , $ entity ) ; } }
2449	public function editComment ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> isAllowedToEditComment ( $ row [ 'parent' ] , $ row [ 'source' ] ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg/i' , '_.svg' , $ icon ) ) . ' ' ; }
1537	protected function fillRelationship ( $ record , $ field , array $ relationship , EncodingParametersInterface $ parameters ) { $ relation = $ this -> getRelated ( $ field ) ; $ relation -> update ( $ record , $ relationship , $ parameters ) ; }
4535	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Tenantable ) { return ; } if ( null !== $ entity -> getTenant ( ) ) { return ; } $ tenant = $ this -> container -> get ( TenantService :: class ) -> getContext ( ) ; $ entity -> setTenant ( $ tenant ) ; }
1888	public function generateAjax ( $ id , $ strField , $ level ) { if ( ! Environment :: get ( 'isAjaxRequest' ) ) { return '' ; } $ this -> strField = $ strField ; $ this -> loadDataContainer ( $ this -> strTable ) ; switch ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'dataContainer' ] ) { case 'File' : if ( Config :: get ( $ this -> strField ) != '' ) { $ this -> varValue = Config :: get ( $ this -> strField ) ; } break ; case 'Table' : if ( ! $ this -> Database -> fieldExists ( $ this -> strField , $ this -> strTable ) ) { break ; } $ objField = $ this -> Database -> prepare ( "SELECT " . Database :: quoteIdentifier ( $ this -> strField ) . " FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> strId ) ; if ( $ objField -> numRows ) { $ this -> varValue = StringUtil :: deserialize ( $ objField -> { $ this -> strField } ) ; } break ; } $ this -> getPathNodes ( ) ; $ tree = '' ; $ level *= 20 ; $ objPage = $ this -> Database -> prepare ( "SELECT id FROM tl_page WHERE pid=? ORDER BY sorting" ) -> execute ( $ id ) ; while ( $ objPage -> next ( ) ) { $ tree .= $ this -> renderPagetree ( $ objPage -> id , $ level ) ; } return $ tree ; }
8701	public function getString ( ) { $ this -> validateElement ( ) ; $ elementStringData = '' ; $ elementStringData = '<' . static :: TYPE ; foreach ( $ this -> attributes as $ key => $ data ) { $ elementStringData .= ' ' . $ key . '="' . $ data . '"' ; } $ elementStringData .= '>' ; if ( $ this -> text !== null ) { $ elementStringData .= $ this -> text ; } if ( count ( $ this -> childElements ) > 0 ) { if ( static :: TYPE == 'svg' ) { foreach ( $ this -> childElements as $ childElement ) { $ this -> defs = array_merge ( $ this -> defs , $ childElement -> getDefs ( ) ) ; } if ( count ( $ this -> defs ) > 0 ) { $ defArea = new \ SVGCreator \ Elements \ Defs ( ) ; foreach ( $ this -> defs as $ def ) { $ defArea -> append ( $ def ) ; } $ elementStringData .= $ defArea -> getString ( ) ; } } foreach ( $ this -> childElements as $ childElement ) { $ elementStringData .= $ childElement -> getString ( ) ; } } $ elementStringData .= '</' . static :: TYPE . '>' ; $ this -> elementString = $ elementStringData ; return $ this -> elementString ; }
10179	public function removeColumn ( $ column ) { foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ c == $ column ) { $ this -> delete ( $ coord ) ; } } }
5992	public function setSortFields ( array $ sortFields ) { $ this -> sortFields = [ ] ; foreach ( $ sortFields as $ item ) { $ this -> addSearchSort ( $ item ) ; } return $ this ; }
1094	public function roots ( ) { return $ this -> node -> newQuery ( ) -> whereNull ( $ this -> node -> getQualifiedParentColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) -> get ( ) ; }
9403	public static function get ( ContainerInterface $ container , array $ components = array ( ) , & $ globals = null ) { $ configuration = new Configuration ; $ collection = new Collection ; foreach ( ( array ) $ components as $ component ) { $ instance = self :: prepare ( $ collection , $ component ) ; $ container = $ instance -> define ( $ container , $ configuration ) ; } $ collection -> setContainer ( $ container ) ; $ globals === null || $ globals [ 'container' ] = $ container ; return $ collection ; }
2792	public function get ( $ option ) { if ( ! array_key_exists ( $ option , $ this -> inputOptions ) ) { throw new \ InvalidArgumentException ( 'Option "' . $ option . ' not exists' ) ; } return $ this -> inputOptions [ $ option ] ; }
12104	public function handleRequest ( ) : void { global $ argv ; if ( ! is_array ( $ argv ) || empty ( $ argv ) ) { throw new Exception ( 'Invalid value of the cli args array was given.' ) ; } ( new CliCtrlResolver ( $ argv ) ) -> run ( ) ; }
9646	public function build ( ) : Route { return new $ this -> routeClass ( $ this -> methods , $ this -> path , $ this -> target , $ this -> matchers , $ this -> name ) ; }
10544	public function setSites ( array $ sites ) { $ this -> sites = array ( ) ; foreach ( $ sites as $ site ) $ this -> addSite ( $ site ) ; return $ this ; }
6287	private function buildReactRequest ( RequestInterface $ request ) { $ headers = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ headers [ $ name ] = ( is_array ( $ value ) ? $ value [ 0 ] : $ value ) ; } $ reactRequest = $ this -> client -> request ( $ request -> getMethod ( ) , ( string ) $ request -> getUri ( ) , $ headers , $ request -> getProtocolVersion ( ) ) ; return $ reactRequest ; }
2356	public function hasBackendUser ( ) : bool { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof BackendUser ; }
195	public function sendContentAsFile ( $ content , $ attachmentName , $ options = [ ] ) { $ headers = $ this -> getHeaders ( ) ; $ contentLength = StringHelper :: byteLength ( $ content ) ; $ range = $ this -> getHttpRange ( $ contentLength ) ; if ( $ range === false ) { $ headers -> set ( 'Content-Range' , "bytes */$contentLength" ) ; throw new RangeNotSatisfiableHttpException ( ) ; } list ( $ begin , $ end ) = $ range ; if ( $ begin != 0 || $ end != $ contentLength - 1 ) { $ this -> setStatusCode ( 206 ) ; $ headers -> set ( 'Content-Range' , "bytes $begin-$end/$contentLength" ) ; $ this -> content = StringHelper :: byteSubstr ( $ content , $ begin , $ end - $ begin + 1 ) ; } else { $ this -> setStatusCode ( 200 ) ; $ this -> content = $ content ; } $ mimeType = isset ( $ options [ 'mimeType' ] ) ? $ options [ 'mimeType' ] : 'application/octet-stream' ; $ this -> setDownloadHeaders ( $ attachmentName , $ mimeType , ! empty ( $ options [ 'inline' ] ) , $ end - $ begin + 1 ) ; $ this -> format = self :: FORMAT_RAW ; return $ this ; }
6626	public function processRequest ( Request $ request , Controller $ controller , array $ requestChain = null ) { $ reflectionController = $ this -> getControllerReflector ( ) -> reflectController ( $ controller ) ; if ( is_null ( $ requestChain ) ) { $ requestChain = $ request -> getRequestChain ( ) ; } $ nextLink = array_shift ( $ requestChain ) ; if ( $ nextLink ) { if ( $ reflectionController -> hasChildController ( $ nextLink ) ) { return $ this -> processRequest ( $ request , $ reflectionController -> getChildController ( $ nextLink ) , $ requestChain ) ; } if ( $ reflectionController -> hasEndpoint ( $ request -> getMethod ( ) , $ nextLink ) ) { $ data = $ reflectionController -> getEndpointResult ( $ request -> getMethod ( ) , $ nextLink , $ request ) ; $ this -> setStatus ( $ reflectionController -> getStatus ( ) ) ; return $ data ; } $ message = "Could not find controller or endpoint matching '$nextLink'" ; throw new Exception ( $ message , 404 ) ; } if ( $ reflectionController -> hasEndpoint ( $ request -> getMethod ( ) , 'index' ) ) { $ data = $ reflectionController -> getEndpointResult ( $ request -> getMethod ( ) , 'index' , $ request ) ; $ this -> setStatus ( $ reflectionController -> getStatus ( ) ) ; return $ data ; } return $ reflectionController -> getDocumentation ( ) ; }
4456	protected function fetchQueue ( string $ eventName ) : SplPriorityQueue { if ( isset ( $ this -> events [ $ eventName ] ) == false ) { $ this -> events [ $ eventName ] = $ this -> createQueue ( ) ; } return $ this -> events [ $ eventName ] ; }
4128	protected function loadMetadata ( $ className ) { if ( class_exists ( $ className ) ) { return parent :: loadMetadata ( $ className ) ; } throw MappingException :: classNotFound ( $ className ) ; }
2139	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } $ this -> fetchHttpHeaders ( ) ; $ this -> setResponseHeaders ( $ event -> getResponse ( ) ) ; }
7458	public function background ( ) : Font { if ( $ this -> color !== null ) { $ this -> turnToBackground ( ) ; } $ this -> background = true ; return $ this ; }
3958	protected function registerAssets ( $ objSettings ) { if ( ! $ objSettings ) { return ; } $ arrCss = $ objSettings -> get ( 'additionalCss' ) ; foreach ( ( array ) $ arrCss as $ arrFile ) { if ( $ arrFile [ 'published' ] ) { $ GLOBALS [ 'TL_CSS' ] [ md5 ( $ arrFile [ 'file' ] ) ] = $ arrFile [ 'file' ] ; } } $ arrJs = $ objSettings -> get ( 'additionalJs' ) ; foreach ( ( array ) $ arrJs as $ arrFile ) { if ( $ arrFile [ 'published' ] ) { $ GLOBALS [ 'TL_JAVASCRIPT' ] [ md5 ( $ arrFile [ 'file' ] ) ] = $ arrFile [ 'file' ] ; } } }
5292	public function buildGravatarURL ( $ email , $ hash_email = true ) { if ( $ this -> usingSecureImages ( ) ) { $ url = static :: HTTPS_URL ; } else { $ url = static :: HTTP_URL ; } if ( $ hash_email == true && ! empty ( $ email ) ) { $ url .= $ this -> getEmailHash ( $ email ) ; } elseif ( ! empty ( $ email ) ) { $ url .= $ email ; } else { $ url .= str_repeat ( '0' , 32 ) ; } if ( $ this -> param_cache === NULL ) { $ params = array ( ) ; $ params [ ] = 's=' . $ this -> getAvatarSize ( ) ; $ params [ ] = 'r=' . $ this -> getMaxRating ( ) ; if ( $ this -> getDefaultImage ( ) ) { $ params [ ] = 'd=' . $ this -> getDefaultImage ( ) ; } $ this -> params_cache = ( ! empty ( $ params ) ) ? '?' . implode ( '&' , $ params ) : '' ; } $ tail = '' ; if ( empty ( $ email ) ) { $ tail = ! empty ( $ this -> params_cache ) ? '&f=y' : '?f=y' ; } return $ url . $ this -> params_cache . $ tail ; }
1509	public function getResourceUrl ( string $ type , $ id , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id ] , $ params ) ; }
11057	public function pathFunction ( $ route , array $ params = [ ] ) { return $ this -> container [ 'url_generator' ] -> generate ( $ route , $ params , UrlGeneratorInterface :: ABSOLUTE_PATH ) ; }
11556	protected function findParameter ( $ namespace , $ name , $ namespaceParameters ) { foreach ( $ namespaceParameters as $ namespaceParameter ) { if ( $ namespaceParameter -> getNamespace ( ) === $ namespace && $ namespaceParameter -> getName ( ) === $ name ) { return $ namespaceParameter ; } } return null ; }
1700	public function unzip ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ strName = $ this -> arrFiles [ $ this -> intIndex ] [ 'file_name' ] ; if ( $ this -> arrFiles [ $ this -> intIndex ] [ 'general_purpose_bit_flag' ] & 0x0001 ) { throw new \ Exception ( "File $strName is encrypted" ) ; } if ( @ fseek ( $ this -> resFile , $ this -> arrFiles [ $ this -> intIndex ] [ 'offset_of_local_header' ] ) !== 0 ) { throw new \ Exception ( "Cannot reposition pointer" ) ; } $ strSignature = @ fread ( $ this -> resFile , 4 ) ; if ( $ strSignature != self :: FILE_SIGNATURE ) { throw new \ Exception ( "$strName is not a compressed file" ) ; } fseek ( $ this -> resFile , 24 , SEEK_CUR ) ; $ arrEFL = unpack ( 'v' , @ fread ( $ this -> resFile , 2 ) ) ; fseek ( $ this -> resFile , ( $ this -> arrFiles [ $ this -> intIndex ] [ 'file_name_length' ] + $ arrEFL [ 1 ] ) , SEEK_CUR ) ; if ( $ this -> arrFiles [ $ this -> intIndex ] [ 'compressed_size' ] < 1 ) { return '' ; } $ strBuffer = @ fread ( $ this -> resFile , $ this -> arrFiles [ $ this -> intIndex ] [ 'compressed_size' ] ) ; switch ( $ this -> arrFiles [ $ this -> intIndex ] [ 'compression_method' ] ) { case 0 : break ; case 8 : $ strBuffer = gzinflate ( $ strBuffer ) ; break ; case 12 : if ( ! \ extension_loaded ( 'bz2' ) ) { throw new \ Exception ( 'PHP extension "bz2" required to decompress BZIP2 files' ) ; } $ strBuffer = bzdecompress ( $ strBuffer ) ; break ; default : throw new \ Exception ( 'Unknown compression method' ) ; break ; } if ( $ strBuffer === false ) { throw new \ Exception ( 'Could not decompress data' ) ; } if ( \ strlen ( $ strBuffer ) != $ this -> arrFiles [ $ this -> intIndex ] [ 'uncompressed_size' ] ) { throw new \ Exception ( 'Size of the uncompressed file does not match header value' ) ; } return $ strBuffer ; }
4787	function offsetSet ( $ key , $ value ) { $ this -> row [ $ key ] = $ value ; $ this -> modified [ $ key ] = $ value ; }
8771	public function registerConfiguredProviders ( ) { $ providers = Collection :: make ( $ this -> config [ 'app.providers' ] ) -> partition ( function ( $ provider ) { return Str :: startsWith ( $ provider , 'Nur\\' ) ; } ) ; $ providers -> splice ( 1 , 0 , [ $ this -> make ( PackageManifest :: class ) -> providers ( ) ] ) ; ( new ProviderRepository ( $ this , new Filesystem , $ this -> getCachedServicesPath ( ) ) ) -> load ( $ providers -> collapse ( ) -> toArray ( ) ) ; }
1564	public function setResource ( $ resource ) : ClientJob { $ schema = $ this -> getApi ( ) -> getContainer ( ) -> getSchema ( $ resource ) ; $ this -> fill ( [ 'resource_type' => $ schema -> getResourceType ( ) , 'resource_id' => $ schema -> getId ( $ resource ) , ] ) ; return $ this ; }
3780	protected function getFilteredAttribute ( ) { if ( ! ( $ attributeId = $ this -> get ( 'attr_id' ) ) ) { return null ; } if ( $ attribute = $ this -> getMetaModel ( ) -> getAttributeById ( $ attributeId ) ) { return $ attribute ; } return null ; }
9924	public function filter ( Parameters $ params , array $ permitted = array ( ) ) { $ this -> cleanUnwanted ( $ params , $ permitted ) ; $ this -> handleArrays ( $ params , $ permitted ) ; $ this -> handleCollections ( $ params , $ permitted ) ; }
3795	private function checkEmpty ( $ action ) { if ( $ this -> hasVariants ( ) && $ this -> currentModel !== null ) { $ this -> disablePA = false ; } elseif ( $ action == 'create' ) { $ this -> disablePA = false ; $ this -> disablePI = false ; } }
12664	public function requirePackage ( string $ package_class ) : ApplicationInterface { if ( ! in_array ( PackageInterface :: class , class_implements ( $ package_class ) ) ) { throw new PackageRequireException ( 'Specified package does not implements PackageInterface: ' . $ package_class , $ package_class ) ; } $ module_list = call_user_func ( [ $ package_class , 'getModuleList' ] ) ; if ( ! is_array ( $ module_list ) ) { throw new PackageRequireException ( 'Failed to call getModuleList: ' . $ package_class , $ package_class ) ; } $ this -> required_modules = array_merge ( $ this -> required_modules , $ module_list ) ; return $ this ; }
6866	protected function preventForbiddenChange ( InvoiceInterface $ invoice ) { if ( $ this -> persistenceHelper -> isChanged ( $ invoice , 'type' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'type' ) ; if ( $ old != $ new ) { throw new Exception \ IllegalOperationException ( "Changing the invoice type is not yet supported." ) ; } } }
8387	public function distinct ( $ distinct ) { if ( is_array ( $ distinct ) === true ) { $ this -> distinct = implode ( ', ' , $ distinct ) ; } else { $ this -> distinct = $ distinct ; } return $ this ; }
10800	public function renderPageHistoricTableAction ( ) { $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ melisKey = $ this -> params ( ) -> fromRoute ( 'melisKey' , '' ) ; $ melisTool = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreTool' ) ; $ melisTool -> setMelisToolKey ( self :: PLUGIN_INDEX , self :: TOOL_KEY ) ; $ columns = $ melisTool -> getColumns ( ) ; $ idPage = $ this -> params ( ) -> fromRoute ( 'idPage' , $ this -> params ( ) -> fromQuery ( 'idPage' , '' ) ) ; $ container = new Container ( 'meliscore' ) ; $ locale = $ container [ 'melis-lang-locale' ] ; $ view = new ViewModel ( ) ; $ view -> melisKey = $ melisKey ; $ view -> tableColumns = $ columns ; $ view -> getToolDataTableConfig = $ melisTool -> getDataTableConfiguration ( '#tableHistoricPageId' . $ idPage , true ) ; $ view -> idPage = $ idPage ; $ view -> tableId = 'tableHistoricPageId' . $ idPage ; return $ view ; }
4932	public function renderJSON ( MvcEvent $ event ) { if ( ! $ this -> hasRunned ) { $ valueToPlainStati = array ( 1 => 'error' , 2 => 'error' , 3 => 'error' , 4 => 'error' , 5 => 'success' , 6 => 'info' , 7 => 'info' ) ; $ viewModel = $ event -> getViewModel ( ) ; if ( $ viewModel instanceof JsonModel ) { if ( ! empty ( $ this -> notifications ) ) { $ jsonNotifications = $ viewModel -> getVariable ( 'notifications' , array ( ) ) ; foreach ( $ this -> notifications as $ notification ) { $ status = 'info' ; if ( array_key_exists ( $ notification -> getPriority ( ) , $ valueToPlainStati ) ) { $ status = $ valueToPlainStati [ $ notification -> getPriority ( ) ] ; } $ jsonNotifications [ ] = array ( 'text' => $ notification -> getNotification ( ) , 'status' => $ status ) ; } $ viewModel -> setVariable ( 'notifications' , $ jsonNotifications ) ; } $ this -> hasRunned = true ; } } return ; }
1619	public function buildAll ( $ query ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "n=n+1 pks[n]=redis.call('HGETALL',$key .. pk)" , 'pks' ) ; }
4611	public function get ( $ iSize = 150 , $ sECLevel = 'L' , $ iMargin = 1 ) { return self :: API_URL . $ iSize . 'x' . $ iSize . '&cht=qr&chld=' . $ sECLevel . '|' . $ iMargin . '&chl=' . $ this -> sData ; }
5575	public function clickSubmitByName ( $ name , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectByName ( $ name ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectByName ( $ name ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
3966	public function getInputScreen ( ) { return new InputScreen ( \ System :: getContainer ( ) -> get ( 'cca.legacy_dic' ) -> getService ( 'metamodels-service-container' ) , $ this -> inputScreen [ 'meta' ] , $ this -> inputScreen [ 'properties' ] , $ this -> inputScreen [ 'conditions' ] , $ this -> inputScreen [ 'groupSort' ] ) ; }
347	public static function removeCssClass ( & $ options , $ class ) { if ( isset ( $ options [ 'class' ] ) ) { if ( is_array ( $ options [ 'class' ] ) ) { $ classes = array_diff ( $ options [ 'class' ] , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = $ classes ; } } else { $ classes = preg_split ( '/\s+/' , $ options [ 'class' ] , - 1 , PREG_SPLIT_NO_EMPTY ) ; $ classes = array_diff ( $ classes , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = implode ( ' ' , $ classes ) ; } } } }
12439	public function render ( $ template , $ data ) { $ tplReady = '' ; $ this -> template = $ template ; $ this -> data = $ data ; if ( $ this -> loadTemplate ( ) ) { $ tplReady = $ this -> dataRender ; } if ( Settings :: getInstance ( ) -> get ( 'minifyTemplate' ) && ! Settings :: getInstance ( ) -> inDebug ( ) ) { $ tplReady = $ this -> minify ( $ tplReady ) ; } $ this -> release ( ) ; return $ tplReady ; }
11670	public function getClientBy ( $ selector , $ value , $ callable = null ) { $ selector = strtolower ( $ selector ) ; if ( ! in_array ( $ selector , array ( 'id' , 'key' , 'slot' , 'role' , 'alias' , 'command' ) ) ) { throw new \ InvalidArgumentException ( "Invalid selector type: `$selector`" ) ; } if ( ! method_exists ( $ this -> connection , $ method = "getConnectionBy$selector" ) ) { $ class = get_class ( $ this -> connection ) ; throw new \ InvalidArgumentException ( "Selecting connection by $selector is not supported by $class" ) ; } if ( ! $ connection = $ this -> connection -> $ method ( $ value ) ) { throw new \ InvalidArgumentException ( "Cannot find a connection by $selector matching `$value`" ) ; } $ client = new static ( $ connection , $ this -> getOptions ( ) ) ; if ( $ callable ) { return call_user_func ( $ callable , $ client ) ; } else { return $ client ; } }
3237	public function getTotalAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return $ this -> totalPrice + $ this -> totalTax + $ this -> totalShipping ; }
4331	public static function unserializeLog ( $ str ) { $ strStart = 'START DEBUG' ; $ strEnd = 'END DEBUG' ; if ( \ preg_match ( '/' . $ strStart . '[\r\n]+(.+)[\r\n]+' . $ strEnd . '/s' , $ str , $ matches ) ) { $ str = $ matches [ 1 ] ; } $ str = self :: isBase64Encoded ( $ str ) ? \ base64_decode ( $ str ) : false ; if ( $ str && \ function_exists ( 'gzinflate' ) ) { $ strInflated = \ gzinflate ( $ str ) ; if ( $ strInflated ) { $ str = $ strInflated ; } } $ data = \ unserialize ( $ str ) ; return $ data ; }
463	public function buildAndCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
3394	protected function sendConfirmationToUser ( $ user ) { $ user -> confirmation_code = str_random ( 25 ) ; $ user -> save ( ) ; $ notification = app ( config ( 'confirmation.notification' ) ) ; $ user -> notify ( $ notification ) ; }
2254	protected function eliminateNestedPaths ( $ arrPaths ) { $ arrPaths = array_filter ( $ arrPaths ) ; if ( empty ( $ arrPaths ) || ! \ is_array ( $ arrPaths ) ) { return array ( ) ; } $ nested = array ( ) ; foreach ( $ arrPaths as $ path ) { $ nested [ ] = preg_grep ( '/^' . preg_quote ( $ path , '/' ) . '\/.+/' , $ arrPaths ) ; } if ( ! empty ( $ nested ) ) { $ nested = array_merge ( ... $ nested ) ; } return array_values ( array_diff ( $ arrPaths , $ nested ) ) ; }
4827	public static function find ( $ id ) { $ endpoint = self :: $ endpoint . '/' . $ id ; return new self ( GoCardless :: $ client , GoCardless :: $ client -> request ( 'get' , $ endpoint ) ) ; }
1975	public static function findMultipleFilesByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='file' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; }
9435	public function theta ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set theta value, because algebraic form is in use.' ) ; } $ this -> theta = new \ stdClass ( ) ; $ this -> theta -> min = $ float_min ; $ this -> theta -> max = $ float_max ; return $ this ; }
3235	public function getCountAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> itemCount , 2 ) ; }
89	public function write ( array $ hash , $ options = 448 ) { $ dir = dirname ( $ this -> path ) ; if ( ! is_dir ( $ dir ) ) { if ( file_exists ( $ dir ) ) { throw new \ UnexpectedValueException ( $ dir . ' exists and is not a directory.' ) ; } if ( ! @ mkdir ( $ dir , 0777 , true ) ) { throw new \ UnexpectedValueException ( $ dir . ' does not exist and could not be created.' ) ; } } $ retries = 3 ; while ( $ retries -- ) { try { file_put_contents ( $ this -> path , static :: encode ( $ hash , $ options ) . ( $ options & self :: JSON_PRETTY_PRINT ? "\n" : '' ) ) ; break ; } catch ( \ Exception $ e ) { if ( $ retries ) { usleep ( 500000 ) ; continue ; } throw $ e ; } } }
6322	private function parseConfiguration ( array $ config ) { $ this -> currentEnvironment = 'dev' ; foreach ( $ config as $ environment => $ connection ) { if ( isset ( $ connection [ 'dsn' ] ) ) { $ this -> dsn [ $ environment ] = $ connection [ 'dsn' ] ; } else { $ this -> dsn [ $ environment ] = sprintf ( 'pgsql:host=%s; port=%s; dbname=%s;' , $ connection [ 'host' ] , $ connection [ 'port' ] , $ connection [ 'database' ] ) ; } $ this -> username [ $ environment ] = $ connection [ 'username' ] ; $ this -> password [ $ environment ] = $ connection [ 'password' ] ; } }
12045	public function destroy ( UserPolicy $ user , Question $ question ) { return $ question -> user_id == user_id ( ) && $ question -> user_type == user_type ( ) ; }
742	public function afterRun ( $ event ) { echo $ event -> result ; $ event -> result = null ; $ this -> owner -> view -> endCache ( ) ; }
606	private function tokenizeDelimitedString ( & $ length ) { $ isIdentifier = $ this -> isIdentifier ( $ length , $ content ) ; $ isStringLiteral = ! $ isIdentifier && $ this -> isStringLiteral ( $ length , $ content ) ; if ( ! $ isIdentifier && ! $ isStringLiteral ) { return false ; } $ this -> addTokenFromBuffer ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => $ isIdentifier ? SqlToken :: TYPE_IDENTIFIER : SqlToken :: TYPE_STRING_LITERAL , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; return true ; }
5155	public function setConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } unset ( $ this -> configuration ) ; $ this -> configuration = $ configuration ; if ( $ configure ) { $ this -> configure ( ) ; } }
11949	protected function createBaseString ( Request $ request , array $ params ) { $ request = clone $ request ; $ uri = $ request -> getUri ( ) ; $ queryString = '' ; if ( $ questionMark = strpos ( $ uri , '?' ) ) { $ uri = substr ( $ uri , 0 , $ questionMark ) ; $ request -> setUri ( $ uri ) ; } $ query = http_build_query ( $ params , '' , '&' , PHP_QUERY_RFC3986 ) ; return strtoupper ( $ request -> getMethod ( ) ) . '&' . rawurlencode ( $ uri ) . '&' . rawurlencode ( $ query ) ; }
10656	public function usort ( $ cmp_function ) { $ tmp = $ this -> getArrayCopy ( ) ; $ ret = usort ( $ tmp , $ cmp_function ) ; $ tmp = new self ( $ tmp ) ; $ this -> exchangeArray ( $ tmp -> getArrayCopy ( ) ) ; return $ ret ; }
1926	public function countColors ( $ max = null ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return imagecolorstotal ( $ this -> gdResource ) ; } $ colors = array ( ) ; $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ colors [ imagecolorat ( $ this -> gdResource , $ x , $ y ) ] = true ; if ( $ max !== null && \ count ( $ colors ) > $ max ) { break 2 ; } } } return \ count ( $ colors ) ; }
8058	public function setWorkerPoolSize ( $ size ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Worker Pool Size for a created pool.' ) ; } $ size = ( int ) $ size ; if ( $ size <= 0 ) { throw new \ InvalidArgumentException ( '"' . $ size . '" is not an integer greater than 0.' ) ; } $ this -> workerPoolSize = $ size ; return $ this ; }
779	public function get ( $ name ) { return isset ( $ this -> _cookies [ $ name ] ) ? $ this -> _cookies [ $ name ] : null ; }
969	public function getType ( ) { $ config = Config :: get ( 'shopify-app.api_grant_mode' ) ; if ( $ config === self :: GRANT_PERUSER ) { return self :: GRANT_PERUSER ; } return self :: GRANT_OFFLINE ; }
6410	public static function concatIterables ( IteratorAggregate $ iterables ) : IteratorAggregate { return self :: from ( Iterators :: concatIterators ( FluentIterable :: from ( $ iterables ) -> transform ( function ( Traversable $ element ) { return Iterators :: from ( $ element ) ; } ) -> iterator ( ) ) ) ; }
6757	public function supportsDenormalization ( $ data , $ type , $ format = null ) { if ( ! \ class_exists ( $ type ) ) { return false ; } $ classAnnotation = $ this -> annotationReader -> getClassAnnotation ( new \ ReflectionClass ( $ type ) , NestedPropertyDenormalizerAnnotation :: class ) ; return $ classAnnotation instanceof NestedPropertyDenormalizerAnnotation ; }
6454	private function createNotAcceptableException ( string $ type ) : HttpException { $ headers = new HttpHeaders ( ) ; $ headers -> add ( 'Content-Type' , 'application/json' ) ; $ body = new StringBody ( json_encode ( $ this -> contentNegotiator -> getAcceptableResponseMediaTypes ( $ type ) ) ) ; $ response = new Response ( HttpStatusCodes :: HTTP_NOT_ACCEPTABLE , $ headers , $ body ) ; return new HttpException ( $ response ) ; }
3588	protected function getMetaBetweenConstraint ( $ column , array $ values ) { $ min = $ values [ 0 ] ; $ max = $ values [ 1 ] ; return function ( $ query ) use ( $ column , $ min , $ max ) { $ query -> where ( 'meta_key' , $ column ) -> where ( 'meta_value' , '>=' , $ min ) -> where ( 'meta_value' , '<=' , $ max ) ; } ; }
9112	public function setVisitTime ( $ visitTime ) { if ( $ visitTime instanceof \ DateTime ) { $ this -> visitTime = $ visitTime ; } else { $ this -> visitTime = new \ DateTime ( $ visitTime ) ; } return $ this ; }
1150	public function render ( $ view = null , $ selector = null ) { $ this -> view ( $ view ) ; $ this -> selector ( $ selector ) ; return View :: make ( $ this -> view , [ 'validator' => $ this -> getViewData ( ) ] ) -> render ( ) ; }
3698	private function getOrCreateDefinition ( ) { if ( $ this -> container -> hasDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ) { $ view = $ this -> container -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; if ( ! $ view instanceof Contao2BackendViewDefinitionInterface ) { throw new DcGeneralInvalidArgumentException ( 'Configured BackendViewDefinition does not implement Contao2BackendViewDefinitionInterface.' ) ; } return $ view ; } $ this -> container -> setDefinition ( Contao2BackendViewDefinitionInterface :: NAME , $ view = new Contao2BackendViewDefinition ( ) ) ; return $ view ; }
10026	function getContacts ( $ page_index = 1 , $ page_size = 100 , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'page_index' => $ page_index , 'page_size' => $ page_size , 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts' , $ queryParameters ) ; }
8971	protected function fromJson ( $ json ) { $ data = json_decode ( $ json , true ) ; return new Rate ( $ data [ 'sourceName' ] , ( float ) $ data [ 'value' ] , $ data [ 'currencyCode' ] , $ data [ 'rateType' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'date' ] ) , $ data [ 'baseCurrencyCode' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'createdAt' ] ) , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'modifiedAt' ] ) ) ; }
7775	protected function handleError ( $ field , $ value , $ rule , array $ args ) { $ this -> errors [ $ rule ] [ ] = [ 'field' => $ field , 'value' => $ value , 'args' => $ args , ] ; }
3167	private function isThemeSwitcherEnabled ( ) { $ extensionsManager = $ this -> getServiceLocator ( ) -> get ( \ common_ext_ExtensionsManager :: SERVICE_ID ) ; $ config = $ extensionsManager -> getExtensionById ( "taoTests" ) -> getConfig ( "test_runner_plugin_registry" ) ; return array_key_exists ( self :: TOOL_ITEM_THEME_SWITCHER_KEY , $ config ) && $ config [ self :: TOOL_ITEM_THEME_SWITCHER_KEY ] [ "active" ] === true ; }
2981	private function findLastImportedPath ( $ yamlContents ) { $ data = Yaml :: parse ( $ yamlContents ) ; if ( ! isset ( $ data [ 'imports' ] ) ) { return false ; } $ lastImport = end ( $ data [ 'imports' ] ) ; if ( ! isset ( $ lastImport [ 'resource' ] ) ) { return false ; } return $ lastImport [ 'resource' ] ; }
1436	public static function camelize ( $ value ) { if ( isset ( self :: $ camelized [ $ value ] ) ) { return self :: $ camelized [ $ value ] ; } return self :: $ camelized [ $ value ] = lcfirst ( self :: classify ( $ value ) ) ; }
10382	protected static function save_external_file ( $ url , $ path ) { $ data = file_get_contents ( $ url ) ; return ( $ data && self :: save_file ( $ path , $ data ) ) ? $ data : '' ; }
2022	public static function findFirstPublishedRootByHostAndLanguage ( $ strHost , $ varLanguage , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using PageModel::findFirstPublishedRootByHostAndLanguage() has been deprecated and will no longer work Contao 5.0.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; if ( \ is_array ( $ varLanguage ) ) { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='')" ) ; if ( ! empty ( $ varLanguage ) ) { $ arrColumns [ ] = "($t.language IN('" . implode ( "','" , $ varLanguage ) . "') OR $t.fallback='1')" ; } else { $ arrColumns [ ] = "$t.fallback='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC" . ( ! empty ( $ varLanguage ) ? ", " . $ objDatabase -> findInSet ( "$t.language" , array_reverse ( $ varLanguage ) ) . " DESC" : "" ) . ", $t.sorting" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; } else { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='') AND ($t.language=? OR $t.fallback='1')" ) ; $ arrValues = array ( $ strHost , $ varLanguage ) ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC, $t.fallback" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; } }
7854	protected function deleteIfForced ( array $ files ) { if ( ! $ this -> option ( 'force' ) ) return ; foreach ( $ files as $ file ) { if ( $ this -> files -> exists ( $ path = $ this -> getPath ( $ file ) ) ) { $ this -> files -> delete ( $ path ) ; } } }
3043	protected function unpackTimeLine ( & $ data ) { $ timeLine = new QtiTimeLine ( ) ; if ( isset ( $ data [ self :: STORAGE_KEY_TIMELINE_POINTS ] ) ) { $ epoch = 0 ; if ( isset ( $ data [ self :: STORAGE_KEY_TIMELINE_EPOCH ] ) ) { $ epoch = $ data [ self :: STORAGE_KEY_TIMELINE_EPOCH ] ; } $ tags = $ data [ self :: STORAGE_KEY_TIMELINE_TAGS ] ; foreach ( $ data [ self :: STORAGE_KEY_TIMELINE_POINTS ] as & $ dataPoint ) { $ point = new TimePoint ( $ tags , $ dataPoint [ 2 ] + $ epoch , $ dataPoint [ 1 ] , $ dataPoint [ 0 ] ) ; $ timeLine -> add ( $ point ) ; } $ points = $ timeLine -> getPoints ( ) ; foreach ( $ data [ self :: STORAGE_KEY_TIMELINE_INDEX ] as $ tag => & $ list ) { foreach ( $ list as $ index ) { $ points [ $ index ] -> addTag ( $ tag ) ; } } } else { $ timeLine -> fromArray ( $ data ) ; } return $ timeLine ; }
9698	public function html ( $ paragraphs = null ) { $ this -> paragraphs = $ paragraphs ; unset ( $ this -> params [ 'plaintext' ] ) ; return $ this -> generate ( ) ; }
11576	public function actionConnect ( $ account_id ) { $ account = $ this -> finder -> findAccountById ( $ account_id ) ; if ( $ account === null || $ account -> getIsConnected ( ) ) { throw new NotFoundHttpException ; } $ user = \ Yii :: createObject ( [ 'class' => User :: className ( ) , 'scenario' => 'connect' ] ) ; if ( $ user -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ user -> create ( ) ) { $ account -> user_id = $ user -> id ; $ account -> save ( false ) ; \ Yii :: $ app -> user -> login ( $ user , $ this -> module -> rememberFor ) ; return $ this -> goBack ( ) ; } return $ this -> render ( 'connect' , [ 'model' => $ user , 'account' => $ account ] ) ; }
2683	public function getWafSettings ( $ id ) { $ url = $ this -> _getWafEndpoint ( ) . $ id ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
3182	public function getMinimumRemainingTime ( ) { if ( ( $ timeLimits = $ this -> getSource ( ) -> getTimeLimits ( ) ) !== null && ( $ minTime = $ timeLimits -> getMinTime ( ) ) !== null ) { return $ this -> getRemainingTimeFrom ( $ minTime ) ; } return false ; }
812	private function fixSpaceBelowClassMethod ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ elementEndIndex ) ; $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; }
8045	public static function select ( array $ readSockets = array ( ) , array $ writeSockets = array ( ) , array $ exceptSockets = array ( ) , $ sec = 0 , $ usec = 0 ) { $ out = array ( ) ; $ out [ 'read' ] = array ( ) ; $ out [ 'write' ] = array ( ) ; $ out [ 'except' ] = array ( ) ; if ( count ( $ readSockets ) === 0 ) { return $ out ; } $ readSocketsResources = array ( ) ; $ writeSocketsResources = array ( ) ; $ exceptSocketsResources = array ( ) ; $ readSockets = self :: createSocketsIndex ( $ readSockets , $ readSocketsResources ) ; $ writeSockets = self :: createSocketsIndex ( $ writeSockets , $ writeSocketsResources ) ; $ exceptSockets = self :: createSocketsIndex ( $ exceptSockets , $ exceptSocketsResources ) ; $ socketsSelected = @ socket_select ( $ readSocketsResources , $ writeSocketsResources , $ exceptSocketsResources , $ sec , $ usec ) ; if ( $ socketsSelected === FALSE ) { $ socketError = socket_last_error ( ) ; if ( $ socketError === SOCKET_EINTR ) { socket_clear_error ( ) ; $ socketsSelected = socket_select ( $ readSocketsResources , $ writeSocketsResources , $ exceptSocketsResources , $ sec , $ usec ) ; if ( $ socketsSelected === FALSE ) { return $ out ; } } else { trigger_error ( sprintf ( 'socket_select(): unable to select [%d]: %s' , $ socketError , socket_strerror ( $ socketError ) ) , E_USER_WARNING ) ; return $ out ; } } foreach ( $ readSocketsResources as $ socketResource ) { $ out [ 'read' ] [ ] = $ readSockets [ intval ( $ socketResource ) ] ; } foreach ( $ writeSocketsResources as $ socketResource ) { $ out [ 'write' ] [ ] = $ writeSockets [ intval ( $ socketResource ) ] ; } foreach ( $ exceptSocketsResources as $ socketResource ) { $ out [ 'except' ] [ ] = $ exceptSockets [ intval ( $ socketResource ) ] ; } return $ out ; }
407	public function getBodyParams ( ) { if ( $ this -> _bodyParams === null ) { if ( isset ( $ _POST [ $ this -> methodParam ] ) ) { $ this -> _bodyParams = $ _POST ; unset ( $ this -> _bodyParams [ $ this -> methodParam ] ) ; return $ this -> _bodyParams ; } $ rawContentType = $ this -> getContentType ( ) ; if ( ( $ pos = strpos ( $ rawContentType , ';' ) ) !== false ) { $ contentType = substr ( $ rawContentType , 0 , $ pos ) ; } else { $ contentType = $ rawContentType ; } if ( isset ( $ this -> parsers [ $ contentType ] ) ) { $ parser = Yii :: createObject ( $ this -> parsers [ $ contentType ] ) ; if ( ! ( $ parser instanceof RequestParserInterface ) ) { throw new InvalidConfigException ( "The '$contentType' request parser is invalid. It must implement the yii\\web\\RequestParserInterface." ) ; } $ this -> _bodyParams = $ parser -> parse ( $ this -> getRawBody ( ) , $ rawContentType ) ; } elseif ( isset ( $ this -> parsers [ '*' ] ) ) { $ parser = Yii :: createObject ( $ this -> parsers [ '*' ] ) ; if ( ! ( $ parser instanceof RequestParserInterface ) ) { throw new InvalidConfigException ( 'The fallback request parser is invalid. It must implement the yii\\web\\RequestParserInterface.' ) ; } $ this -> _bodyParams = $ parser -> parse ( $ this -> getRawBody ( ) , $ rawContentType ) ; } elseif ( $ this -> getMethod ( ) === 'POST' ) { $ this -> _bodyParams = $ _POST ; } else { $ this -> _bodyParams = [ ] ; mb_parse_str ( $ this -> getRawBody ( ) , $ this -> _bodyParams ) ; } } return $ this -> _bodyParams ; }
5671	protected function describeStringDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } $ position = $ this -> stringDiffersAt ( $ first , $ second ) ; return sprintf ( 'at character %s with [%s] and [%s]' , $ position , $ this -> clipString ( $ first , 200 , $ position ) , $ this -> clipString ( $ second , 200 , $ position ) ) ; }
6895	protected function compareStockUnitByEda ( StockUnitInterface $ u1 , StockUnitInterface $ u2 ) { $ u1HasEda = null !== $ u1 -> getEstimatedDateOfArrival ( ) ; $ u2HasEda = null !== $ u2 -> getEstimatedDateOfArrival ( ) ; if ( ! $ u1HasEda && $ u2HasEda ) { return 1 ; } if ( $ u1HasEda && ! $ u2HasEda ) { return - 1 ; } if ( $ u1 -> getEstimatedDateOfArrival ( ) != $ u2 -> getEstimatedDateOfArrival ( ) ) { return $ u1 -> getEstimatedDateOfArrival ( ) > $ u2 -> getEstimatedDateOfArrival ( ) ? 1 : - 1 ; } return 0 ; }
4794	function group ( $ columns , $ having = "" ) { $ this -> __destruct ( ) ; $ this -> group = $ columns ; $ this -> having = $ having ; return $ this ; }
9885	private function writeDefinedNameForNamedRange ( XMLWriter $ objWriter , NamedRange $ pNamedRange ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , $ pNamedRange -> getName ( ) ) ; if ( $ pNamedRange -> getLocalOnly ( ) ) { $ objWriter -> writeAttribute ( 'localSheetId' , $ pNamedRange -> getScope ( ) -> getParent ( ) -> getIndex ( $ pNamedRange -> getScope ( ) ) ) ; } $ range = Coordinate :: splitRange ( $ pNamedRange -> getRange ( ) ) ; $ iMax = count ( $ range ) ; for ( $ i = 0 ; $ i < $ iMax ; ++ $ i ) { $ range [ $ i ] [ 0 ] = '\'' . str_replace ( "'" , "''" , $ pNamedRange -> getWorksheet ( ) -> getTitle ( ) ) . '\'!' . Coordinate :: absoluteReference ( $ range [ $ i ] [ 0 ] ) ; if ( isset ( $ range [ $ i ] [ 1 ] ) ) { $ range [ $ i ] [ 1 ] = Coordinate :: absoluteReference ( $ range [ $ i ] [ 1 ] ) ; } } $ range = Coordinate :: buildRange ( $ range ) ; $ objWriter -> writeRawData ( $ range ) ; $ objWriter -> endElement ( ) ; }
8222	protected function getLimitFor ( $ actionName , $ blockType , $ entityId ) { $ limit = $ this -> storage -> getLimitFor ( $ actionName , $ blockType , $ entityId ) ; if ( $ limit === null ) { $ limit = array ( "ts" => 0 , "cnt" => 0 ) ; } return $ limit ; }
8719	public function fresh ( $ with = [ ] ) { if ( ! $ this -> exists ) { return ; } $ query = static :: newQueryWithoutScopes ( ) -> with ( is_string ( $ with ) ? func_get_args ( ) : $ with ) -> where ( $ this -> getKeyName ( ) , $ this -> getKey ( ) ) ; ( new TranslatableScope ( ) ) -> apply ( $ query , $ this ) ; return $ query -> first ( ) ; }
4442	public function completed ( int $ offset = 0 , int $ count = 25 ) { return $ this -> client -> jobs ( 'complete' , null , $ offset , $ count ) ; }
2562	protected function loadGeoCode ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAllNotEmpty ( $ params -> latitude , $ params -> longitude ) ) { $ this -> porFndQryParams -> geoCode = new GeoCode ( $ params -> longitude , $ params -> latitude ) ; } }
11358	public function removeBlock ( $ blockFile ) { foreach ( $ this -> permalinks as $ permalink => $ associatedBlocks ) { $ tmp = array_flip ( $ associatedBlocks ) ; unset ( $ tmp [ $ blockFile ] ) ; if ( empty ( $ tmp ) ) { unset ( $ this -> permalinks [ $ permalink ] ) ; continue ; } $ this -> permalinks [ $ permalink ] = array_flip ( $ tmp ) ; } return $ this ; }
3786	public function addListener ( $ eventName , $ listener , $ priority = 200 ) { $ dispatcher = $ this -> getServiceContainer ( ) -> getEventDispatcher ( ) ; $ dispatcher -> addListener ( $ eventName , $ listener , $ priority ) ; return $ this ; }
1046	public static function toSafeTrace ( $ error ) { $ trace = $ error -> getTrace ( ) ; if ( isset ( $ trace [ 0 ] [ 'function' ] ) && isset ( $ trace [ 0 ] [ 'class' ] ) && ( $ trace [ 0 ] [ 'class' ] . '::' . $ trace [ 0 ] [ 'function' ] === 'GraphQL\Utils\Utils::invariant' ) ) { array_shift ( $ trace ) ; } elseif ( ! isset ( $ trace [ 0 ] [ 'file' ] ) ) { array_shift ( $ trace ) ; } return array_map ( static function ( $ err ) { $ safeErr = array_intersect_key ( $ err , [ 'file' => true , 'line' => true ] ) ; if ( isset ( $ err [ 'function' ] ) ) { $ func = $ err [ 'function' ] ; $ args = ! empty ( $ err [ 'args' ] ) ? array_map ( [ self :: class , 'printVar' ] , $ err [ 'args' ] ) : [ ] ; $ funcStr = $ func . '(' . implode ( ', ' , $ args ) . ')' ; if ( isset ( $ err [ 'class' ] ) ) { $ safeErr [ 'call' ] = $ err [ 'class' ] . '::' . $ funcStr ; } else { $ safeErr [ 'function' ] = $ funcStr ; } } return $ safeErr ; } , $ trace ) ; }
11710	public function actionConfirm ( $ id , $ back = 'index' ) { $ this -> findModel ( $ id ) -> confirm ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been confirmed' ) ) ; $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
1675	public function unsynchronize ( ) { if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { System :: getContainer ( ) -> get ( 'filesystem' ) -> touch ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ; } }
11709	public function actionUpdate ( $ id ) { $ user = $ this -> findModel ( $ id ) ; $ user -> scenario = 'update' ; $ profile = $ this -> finder -> findProfileById ( $ id ) ; $ r = \ Yii :: $ app -> request ; $ this -> performAjaxValidation ( [ $ user , $ profile ] ) ; if ( $ user -> load ( $ r -> post ( ) ) && $ profile -> load ( $ r -> post ( ) ) && $ user -> save ( ) && $ profile -> save ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been updated' ) ) ; return $ this -> refresh ( ) ; } return $ this -> render ( 'update' , [ 'user' => $ user , 'profile' => $ profile , 'module' => $ this -> module , ] ) ; }
3789	protected function getSetValues ( $ arrValue , $ intId , $ strLangCode ) { if ( ( $ arrValue !== null ) && ! is_array ( $ arrValue ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid value provided: %s' , var_export ( $ arrValue , true ) ) ) ; } return array ( 'tstamp' => time ( ) , 'value' => ( string ) $ arrValue [ 'value' ] , 'att_id' => $ this -> get ( 'id' ) , 'langcode' => $ strLangCode , 'item_id' => $ intId , ) ; }
10226	public function noAssociationsMenuFor ( $ model , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ menuFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\NoAssociationsIndexMenuFactory' ) ; return $ menuFactory -> create ( $ modelName , $ config ) ; }
2532	protected function loadOptionalSegmentInformation ( $ options ) { if ( ! empty ( $ options -> operatingCompany ) ) { $ this -> segmentInformation -> companyDetails -> operatingCompany = $ options -> operatingCompany ; } if ( $ options -> arrivalDate instanceof \ DateTime ) { $ this -> segmentInformation -> flightDate -> setArrivalDate ( $ options -> arrivalDate ) ; } if ( ! empty ( $ options -> groupNumber ) ) { $ this -> segmentInformation -> flightTypeDetails = new FlightTypeDetails ( $ options -> groupNumber ) ; } $ this -> loadAdditionalSegmentDetails ( $ options -> airplaneCode , $ options -> nrOfStops ) ; }
12477	private function getTransformation ( ) { $ transforms = [ ] ; foreach ( $ this -> fields as $ field => $ extra ) { if ( is_int ( $ field ) ) { $ transforms [ $ extra ] = $ extra ; continue ; } $ transform = ( key_exists ( 'transform' , $ extra ) ) ? $ extra [ 'transform' ] : $ field ; if ( $ transform === false ) { continue ; } $ transforms [ $ field ] = $ transform ; } return $ transforms ; }
1845	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objCalendar = CalendarModel :: findByProtected ( '' ) ; if ( $ objCalendar !== null ) { while ( $ objCalendar -> next ( ) ) { if ( ! $ objCalendar -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objCalendar -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objCalendar -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objCalendar -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objCalendar -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/events/%s' ) ; } $ strUrl = $ arrProcessed [ $ objCalendar -> jumpTo ] ; $ objEvents = CalendarEventsModel :: findPublishedDefaultByPid ( $ objCalendar -> id ) ; if ( $ objEvents !== null ) { while ( $ objEvents -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objEvents -> alias ? : $ objEvents -> id ) ) ; } } } } return $ arrPages ; }
12360	public static function encodeHashId ( $ id ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ id ; } $ hashids = App :: make ( 'Hashids' ) ; return $ hashids -> encode ( $ id , date ( 'd' ) ) ; }
5765	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ administrators = $ this -> administratorsEntityMapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) , null , $ this -> authentication , $ this -> authorization ) ; } catch ( QueryFailureException $ e ) { $ administrators = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ administrators ) ; }
3004	public function save ( $ filename ) { $ f3 = \ Base :: instance ( ) ; $ lines = explode ( "\n" , $ this -> smtp -> log ( ) ) ; $ start = false ; $ out = '' ; for ( $ i = 0 , $ max = count ( $ lines ) ; $ i < $ max ; $ i ++ ) { if ( ! $ start && preg_match ( '/^354.*?$/' , $ lines [ $ i ] , $ matches ) ) { $ start = true ; continue ; } elseif ( preg_match ( '/^250.*?$\s^QUIT/m' , $ lines [ $ i ] . ( $ i + 1 < $ max ? "\n" . $ lines [ $ i + 1 ] : '' ) , $ matches ) ) break ; if ( $ start ) $ out .= $ lines [ $ i ] . "\n" ; } if ( $ out ) { $ path = $ f3 -> get ( 'mailer.storage_path' ) ; if ( ! is_dir ( $ path ) ) mkdir ( $ path , 0777 , true ) ; $ f3 -> write ( $ path . $ filename , $ out ) ; } }
12980	protected function configureBehavior ( $ behavior , EventSubscriber $ es ) { switch ( $ behavior ) { case 'translatable' : $ es -> setTranslatableLocale ( \ Config :: get ( 'language' , 'en' ) ) ; $ es -> setDefaultLocale ( \ Config :: get ( 'language_fallback' , 'en' ) ) ; break ; } }
2371	public static function splitCsv ( $ strString , $ strDelimiter = ',' ) { $ arrValues = preg_split ( '/' . $ strDelimiter . '(?=(?:[^"]*"[^"]*")*(?![^"]*"))/' , $ strString ) ; foreach ( $ arrValues as $ k => $ v ) { $ arrValues [ $ k ] = trim ( $ v , ' "' ) ; } return $ arrValues ; }
4981	public function convertToPhpValue ( $ value ) { if ( ! is_array ( $ value ) || ! isset ( $ value [ 'date' ] ) || ! $ value [ 'date' ] instanceof \ MongoDate || ! isset ( $ value [ 'tz' ] ) ) { return null ; } $ timestamp = $ value [ 'date' ] -> sec ; $ date = new \ DateTime ( '@' . $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ value [ 'tz' ] ) ) ; return $ date ; }
4884	public function addDependencies ( $ name , $ entities = null , array $ options = null ) { return $ this -> dependencyResultCollection -> add ( $ name , $ entities , $ options ) ; }
8999	public function fileExists ( $ fileName ) : bool { if ( ! $ this -> exists ( ) ) { return false ; } $ file = sprintf ( "%s/%s" , $ this -> path , $ fileName ) ; return file_exists ( $ file ) ; }
9381	public function set ( $ id , $ concrete , $ share = false ) { return $ this -> add ( $ id , $ concrete , $ share ) ; }
3634	public function events ( Request $ request ) : array { $ em = \ bean ( 'eventManager' ) ; if ( $ event = \ trim ( $ request -> query ( 'name' ) ) ) { if ( ! $ queue = $ em -> getListenerQueue ( $ event ) ) { return [ 'msg' => 'event name is invalid: ' . $ event ] ; } $ classes = [ ] ; foreach ( $ queue -> getIterator ( ) as $ listener ) { $ classes [ ] = \ get_class ( $ listener ) ; } return $ classes ; } return $ em -> getListenedEvents ( ) ; }
4678	public function render ( string $ file , array $ data ) : void { if ( ! is_readable ( $ file ) ) { throw new Exception ( "Could not find template file: " . $ this -> template ) ; } $ di = $ this -> di ; $ app = null ; if ( $ di -> has ( "app" ) ) { $ app = $ di -> get ( "app" ) ; } extract ( $ data ) ; require $ file ; }
1625	public static function updateAllCounters ( $ counters , $ condition = null ) { if ( empty ( $ counters ) ) { return 0 ; } $ db = static :: getDb ( ) ; $ n = 0 ; foreach ( self :: fetchPks ( $ condition ) as $ pk ) { $ key = static :: keyPrefix ( ) . ':a:' . static :: buildKey ( $ pk ) ; foreach ( $ counters as $ attribute => $ value ) { $ db -> executeCommand ( 'HINCRBY' , [ $ key , $ attribute , $ value ] ) ; } $ n ++ ; } return $ n ; }
11451	public function getParentKeyName ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; $ relat = $ this -> $ func ( ) ; $ field = $ relat -> getForeignKey ( ) ; return $ field ; } return 'id' ; }
11712	protected function performAjaxValidation ( $ models ) { if ( \ Yii :: $ app -> request -> isAjax ) { if ( is_array ( $ models ) ) { $ result = [ ] ; foreach ( $ models as $ model ) { if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; $ result = array_merge ( $ result , ActiveForm :: validate ( $ model ) ) ; } } echo json_encode ( $ result ) ; \ Yii :: $ app -> end ( ) ; } else { if ( $ models -> load ( \ Yii :: $ app -> request -> post ( ) ) ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; echo json_encode ( ActiveForm :: validate ( $ models ) ) ; \ Yii :: $ app -> end ( ) ; } } } }
9822	public function writeRelationships ( Spreadsheet $ spreadsheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ customPropertyList = $ spreadsheet -> getProperties ( ) -> getCustomProperties ( ) ; if ( ! empty ( $ customPropertyList ) ) { $ this -> writeRelationship ( $ objWriter , 4 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties' , 'docProps/custom.xml' ) ; } $ this -> writeRelationship ( $ objWriter , 3 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties' , 'docProps/app.xml' ) ; $ this -> writeRelationship ( $ objWriter , 2 , 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties' , 'docProps/core.xml' ) ; $ this -> writeRelationship ( $ objWriter , 1 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' , 'xl/workbook.xml' ) ; if ( $ spreadsheet -> hasRibbon ( ) ) { $ this -> writeRelationShip ( $ objWriter , 5 , 'http://schemas.microsoft.com/office/2006/relationships/ui/extensibility' , $ spreadsheet -> getRibbonXMLData ( 'target' ) ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
8700	public function append ( $ element ) { if ( true === $ element instanceof \ SVGCreator \ Element ) { $ this -> childElements [ ] = $ element ; return $ element ; } else { $ elementCreated = $ this -> factoryElement ( $ element ) ; $ this -> childElements [ ] = $ elementCreated ; return $ elementCreated ; } }
9980	private function writeComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment , array $ pAuthors ) { $ objWriter -> startElement ( 'comment' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pCellReference ) ; $ objWriter -> writeAttribute ( 'authorId' , $ pAuthors [ $ pComment -> getAuthor ( ) ] ) ; $ objWriter -> startElement ( 'text' ) ; $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichText ( $ objWriter , $ pComment -> getText ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
2518	public function pnrRetrieveAndDisplay ( RequestOptions \ PnrRetrieveAndDisplayOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_RetrieveAndDisplay' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
6955	private function getTaxesRates ( ShipmentMethodInterface $ method , CountryInterface $ country ) { return array_map ( function ( TaxInterface $ tax ) { return $ tax -> getRate ( ) ; } , $ this -> taxResolver -> resolveTaxes ( $ method , $ country ) ) ; }
6460	public function radioAction ( $ customized , $ selector ) { $ field = $ this -> getWorkingElement ( ) -> findField ( $ selector ) ; $ customized = ( bool ) $ customized ; if ( $ field !== null && ! $ customized ) { $ field -> selectOption ( $ field -> getAttribute ( 'value' ) ) ; return ; } foreach ( $ this -> findLabels ( $ selector ) as $ label ) { if ( $ customized && ! $ label -> isVisible ( ) ) { continue ; } $ label -> click ( ) ; return ; } $ this -> throwNoSuchElementException ( $ selector , $ field ) ; }
6905	public function removeRecipient ( Recipient $ recipient ) { if ( $ this -> recipients -> contains ( $ recipient ) ) { $ this -> recipients -> removeElement ( $ recipient ) ; } return $ this ; }
2467	private function setImpersonatedLogout ( ) { $ token = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ impersonatorUser = null ; foreach ( $ token -> getRoles ( ) as $ role ) { if ( $ role instanceof SwitchUserRole ) { $ impersonatorUser = $ role -> getSource ( ) -> getUsername ( ) ; break ; } } if ( ! $ impersonatorUser ) { return ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ firewallMap = System :: getContainer ( ) -> get ( 'security.firewall.map' ) ; if ( ( $ firewallConfig = $ firewallMap -> getFirewallConfig ( $ request ) ) === null || ( $ switchUserConfig = $ firewallConfig -> getSwitchUser ( ) ) === null ) { return ; } $ arrParams = array ( 'do' => 'user' , urlencode ( $ switchUserConfig [ 'parameter' ] ) => SwitchUserListener :: EXIT_VALUE ) ; $ this -> Template -> logout = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'switchBT' ] , $ impersonatorUser ) ; $ this -> Template -> logoutLink = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_backend' , $ arrParams ) ; }
11224	private static function getRegexRoutes ( ) { foreach ( self :: $ routes as $ key => $ value ) { unset ( self :: $ routes [ $ key ] ) ; if ( strpos ( $ key , ':' ) !== false ) { self :: any ( $ key , $ value ) ; } } }
5122	private function setAuthorizationHeader ( string $ accessToken ) : self { $ this -> accessToken = $ accessToken ; $ this -> options -> set ( 'default_headers' , array_merge ( $ this -> options -> get ( 'default_headers' ) , [ 'Authorization' => 'Bearer ' . $ accessToken , ] ) ) ; return $ this ; }
10221	public static function getConversionGroupUnits ( $ group = null ) { $ conversionGroups = [ ] ; foreach ( self :: $ conversionUnits as $ conversionUnit => $ conversionGroup ) { if ( ( $ group === null ) || ( $ conversionGroup [ 'Group' ] == $ group ) ) { $ conversionGroups [ $ conversionGroup [ 'Group' ] ] [ ] = $ conversionUnit ; } } return $ conversionGroups ; }
12879	public function render ( ) { $ plugins = $ this -> pluginManager -> getBlockPlugins ( ) ; $ toolbar = array ( ) ; $ left [ ] = $ this -> twig -> render ( "RedKiteCms/Resources/views/Editor/Toolbar/_toolbar_left_buttons.html.twig" ) ; $ right [ ] = $ this -> twig -> render ( "RedKiteCms/Resources/views/Editor/Toolbar/_toolbar_right_buttons.html.twig" ) ; foreach ( $ plugins as $ plugin ) { if ( ! $ plugin -> hasToolbar ( ) ) { continue ; } $ left [ ] = $ this -> addButtons ( $ plugin , 'left' ) ; $ right [ ] = $ this -> addButtons ( $ plugin , 'right' ) ; } $ toolbar [ "left" ] = implode ( "\n" , $ left ) ; $ toolbar [ "right" ] = implode ( "\n" , $ right ) ; return $ toolbar ; }
8102	public function getStatement ( $ sql , $ args = false ) { $ query = $ this -> buildQuery ( $ sql , $ args ) ; if ( $ connection = $ this -> db -> getConnection ( ) ) { if ( $ stmt = $ connection -> prepare ( $ query ) ) { $ this -> log -> report ( "SQL Statement: {$query}" ) ; $ stmt -> setFetchMode ( \ PDO :: FETCH_INTO , new Collection ( ) ) ; if ( $ args ) { $ this -> log -> report ( "SQL Data Sent: [" . implode ( ', ' , $ args ) . "]" ) ; $ stmt -> execute ( $ args ) ; } if ( $ stmt -> errorCode ( ) > 0 ) { $ error = $ stmt -> errorInfo ( ) ; $ this -> log -> error ( "PDO({$error[0]})[{$error[1]}] {$error[2]}" ) ; return false ; } return $ stmt ; } else { $ this -> log -> error ( 'Failed to create a PDO statement with: ' . $ query ) ; return false ; } } else { return false ; } }
10434	protected function prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) { return array_merge ( $ serviceConfig , $ typeConfig [ 'config' ] , [ 'entity_class' => $ typeConfig [ 'entity_class' ] , 'document_class' => $ typeConfig [ 'document_class' ] , 'document_type' => $ type , ] ) ; }
5328	public function getCpuinfoByLsCpu ( ) { if ( ! $ this -> cpuInfoByLsCpu ) { $ lscpu = shell_exec ( 'lscpu' ) ; $ lscpu = explode ( "\n" , $ lscpu ) ; $ values = [ ] ; foreach ( $ lscpu as $ v ) { $ v = array_map ( 'trim' , explode ( ':' , $ v ) ) ; if ( isset ( $ v [ 0 ] , $ v [ 1 ] ) ) { $ values [ $ v [ 0 ] ] = $ v [ 1 ] ; } } $ this -> cpuInfoByLsCpu = $ values ; } return $ this -> cpuInfoByLsCpu ; }
7686	function Misc_ColNum ( $ ColRef , $ IsODF ) { if ( $ IsODF ) { $ p = strpos ( $ ColRef , '.' ) ; if ( $ p !== false ) $ ColRef = substr ( $ ColRef , $ p ) ; $ ColRef = str_replace ( array ( '.' , '$' ) , '' , $ ColRef ) ; $ ColRef = explode ( ':' , $ ColRef ) ; $ ColRef = $ ColRef [ 0 ] ; } $ num = 0 ; $ rank = 0 ; for ( $ i = strlen ( $ ColRef ) - 1 ; $ i >= 0 ; $ i -- ) { $ l = $ ColRef [ $ i ] ; if ( ! is_numeric ( $ l ) ) { $ l = ord ( strtoupper ( $ l ) ) - 64 ; if ( $ l > 0 && $ l < 27 ) { $ num = $ num + $ l * pow ( 26 , $ rank ) ; } else { return $ this -> RaiseError ( '(Sheet) Reference of cell \'' . $ ColRef . '\' cannot be recognized.' ) ; } $ rank ++ ; } } return $ num ; }
3954	public function getVariants ( $ objFilter ) { if ( $ this -> isVariantBase ( ) ) { return $ this -> getMetaModel ( ) -> findVariants ( array ( $ this -> get ( 'id' ) ) , $ objFilter ) ; } return null ; }
9721	public function getSamples ( ) { $ baseDir = realpath ( __DIR__ . '/../../../samples' ) ; $ directory = new RecursiveDirectoryIterator ( $ baseDir ) ; $ iterator = new RecursiveIteratorIterator ( $ directory ) ; $ regex = new RegexIterator ( $ iterator , '/^.+\.php$/' , RecursiveRegexIterator :: GET_MATCH ) ; $ files = [ ] ; foreach ( $ regex as $ file ) { $ file = str_replace ( $ baseDir . '/' , '' , $ file [ 0 ] ) ; $ info = pathinfo ( $ file ) ; $ category = str_replace ( '_' , ' ' , $ info [ 'dirname' ] ) ; $ name = str_replace ( '_' , ' ' , preg_replace ( '/(|\.php)/' , '' , $ info [ 'filename' ] ) ) ; if ( ! in_array ( $ category , [ '.' , 'boostrap' , 'templates' ] ) ) { if ( ! isset ( $ files [ $ category ] ) ) { $ files [ $ category ] = [ ] ; } $ files [ $ category ] [ $ name ] = $ file ; } } ksort ( $ files ) ; foreach ( $ files as & $ f ) { asort ( $ f ) ; } return $ files ; }
931	public function clear ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> content = '' ; $ this -> id = null ; $ this -> isArray = false ; }
4616	protected function validate ( ) { if ( ! $ this -> config -> getHost ( ) || ! $ this -> config -> getPort ( ) ) { throw new Node \ Builder \ Exception ( 'Node host address and port number are required.' ) ; } if ( $ this -> config -> getUser ( ) && $ this -> config -> getCertificate ( ) ) { throw new Node \ Builder \ Exception ( 'Connect with password OR certificate authentication, not both.' ) ; } if ( $ this -> config -> isAuth ( ) && ! $ this -> config -> getCaDirectory ( ) && ! $ this -> config -> getCaFile ( ) ) { throw new Node \ Builder \ Exception ( 'Certificate authority file is required for authentication.' ) ; } }
10056	public function getItem ( $ key ) { if ( $ this -> hasItem ( $ key ) !== true ) { $ this -> data [ $ key ] = new CacheItem ( $ key , null , false ) ; } return $ this -> data [ $ key ] ; }
5390	protected function valueIsPossible ( $ value ) { $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ widgets [ $ i ] -> getAttribute ( 'value' ) == $ value ) { return true ; } } return false ; }
6105	public function getHost ( ) { if ( $ this -> host === null ) { $ this -> host = new Host ( $ this ) ; } return $ this -> host ; }
3708	protected function checkRedirect ( $ widgets , $ wantedParameter , $ allParameter ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the new "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( Input :: post ( 'FORM_SUBMIT' ) != $ this -> formId ) { return ; } $ redirectParameters = $ allParameter [ 'other' ] ; foreach ( $ wantedParameter as $ widgetName ) { $ filter = $ widgets [ $ widgetName ] ; if ( $ filter [ 'urlvalue' ] !== null ) { $ redirectParameters [ $ widgetName ] = $ filter [ 'urlvalue' ] ; } } $ filterUrl = new FilterUrl ( $ this -> objFilterConfig -> getJumpTo ( ) , [ ] , $ redirectParameters ) ; $ dispatcher = $ this -> getDispatcher ( ) ; $ dispatcher -> dispatch ( ContaoEvents :: CONTROLLER_REDIRECT , new RedirectEvent ( $ this -> filterUrlBuilder -> generate ( $ filterUrl ) ) ) ; }
5620	protected function chompCoordinates ( & $ url ) { if ( preg_match ( '/(.*)\?(\d+),(\d+)$/' , $ url , $ matches ) ) { $ url = $ matches [ 1 ] ; return array ( ( integer ) $ matches [ 2 ] , ( integer ) $ matches [ 3 ] ) ; } return array ( false , false ) ; }
3143	public function timeout ( RunnerServiceContext $ context , $ scope , $ ref , $ late = false ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Select next item before timeout" ) ; $ context -> selectAdaptiveNextItem ( ) ; } try { $ session -> closeTimer ( $ ref , $ scope ) ; if ( $ late ) { if ( $ scope == 'assessmentTest' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW ; } else if ( $ scope == 'testPart' ) { $ code = AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW ; } else if ( $ scope == 'assessmentSection' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW ; } else { $ code = AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW ; } throw new AssessmentTestSessionException ( "Maximum duration of ${scope} '${ref}' not respected." , $ code ) ; } else { $ session -> checkTimeLimits ( false , true , false ) ; } } catch ( AssessmentTestSessionException $ e ) { $ this -> onTimeout ( $ context , $ e ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'timeout' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
4490	public function createTopic ( string $ name ) : string { $ res = $ this -> sns -> createTopic ( [ 'Name' => $ name , ] ) ; return $ res [ 'TopicArn' ] ; }
5682	public function getFrameset ( ) { if ( ! $ this -> hasFrames ( ) ) { return false ; } $ urls = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ name = $ this -> frames [ $ i ] -> getAttribute ( 'name' ) ; $ url = new SimpleUrl ( $ this -> frames [ $ i ] -> getAttribute ( 'src' ) ) ; $ key = $ name ? $ name : $ i + 1 ; $ urls [ $ key ] = $ this -> expandUrl ( $ url ) ; } return $ urls ; }
12854	public function process ( Pipeline \ Pipeline $ pipeline , $ payload ) { $ runner = clone ( $ this ) ; $ runner -> stages = $ pipeline -> getIterator ( ) ; return $ runner -> handle ( $ payload ) ; }
5510	public function expectAt ( $ timing , $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments at time' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments at time' ) ; $ args = $ this -> replaceWildcards ( $ args ) ; if ( ! isset ( $ this -> expected_args_at [ $ timing ] ) ) { $ this -> expected_args_at [ $ timing ] = array ( ) ; } $ method = strtolower ( $ method ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args_at [ $ timing ] [ $ method ] = new ParametersExpectation ( $ args , $ message ) ; }
1049	public static function getVariableValues ( Schema $ schema , $ varDefNodes , array $ inputs ) { $ errors = [ ] ; $ coercedValues = [ ] ; foreach ( $ varDefNodes as $ varDefNode ) { $ varName = $ varDefNode -> variable -> name -> value ; $ varType = TypeInfo :: typeFromAST ( $ schema , $ varDefNode -> type ) ; if ( Type :: isInputType ( $ varType ) ) { if ( array_key_exists ( $ varName , $ inputs ) ) { $ value = $ inputs [ $ varName ] ; $ coerced = Value :: coerceValue ( $ value , $ varType , $ varDefNode ) ; $ coercionErrors = $ coerced [ 'errors' ] ; if ( empty ( $ coercionErrors ) ) { $ coercedValues [ $ varName ] = $ coerced [ 'value' ] ; } else { $ messagePrelude = sprintf ( 'Variable "$%s" got invalid value %s; ' , $ varName , Utils :: printSafeJson ( $ value ) ) ; foreach ( $ coercionErrors as $ error ) { $ errors [ ] = new Error ( $ messagePrelude . $ error -> getMessage ( ) , $ error -> getNodes ( ) , $ error -> getSource ( ) , $ error -> getPositions ( ) , $ error -> getPath ( ) , $ error , $ error -> getExtensions ( ) ) ; } } } else { if ( $ varType instanceof NonNull ) { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" of required type "%s" was not provided.' , $ varName , $ varType ) , [ $ varDefNode ] ) ; } elseif ( $ varDefNode -> defaultValue ) { $ coercedValues [ $ varName ] = AST :: valueFromAST ( $ varDefNode -> defaultValue , $ varType ) ; } } } else { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" expected value of type "%s" which cannot be used as an input type.' , $ varName , Printer :: doPrint ( $ varDefNode -> type ) ) , [ $ varDefNode -> type ] ) ; } } if ( ! empty ( $ errors ) ) { return [ $ errors , null ] ; } return [ null , $ coercedValues ] ; }
4058	private function drawAttribute ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ type = $ attribute -> get ( 'type' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> attributeFactory -> getIconForType ( $ type ) , $ type , '' , 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = $ attribute -> getName ( ) ; $ colName = $ attribute -> getColName ( ) ; $ isUnique = $ attribute -> get ( 'isunique' ) ; } else { $ type = 'unknown ID: ' . $ model -> getProperty ( 'attr_id' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = 'unknown attribute' ; $ colName = 'unknown column' ; $ isUnique = false ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong><span class="mandatory">%s</span> <span class="tl_class">%s</span> </div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ colName , $ type , $ image , $ name , $ model -> getProperty ( 'mandatory' ) || $ isUnique ? ' [' . $ this -> trans ( 'mandatory.0' ) . ']' : '' , $ model -> getProperty ( 'tl_class' ) ? sprintf ( '[%s]' , $ model -> getProperty ( 'tl_class' ) ) : '' ] ) ; }
12503	public static function beginTransaction ( $ connection ) { $ connection -> query = 'BEGIN_TRANSACTION' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
6026	public function setMimetype ( $ mimetype ) { if ( $ mimetype instanceof MimeType ) { $ this -> mimetype = $ mimetype ; } elseif ( is_array ( $ mimetype ) ) { $ this -> mimetype = new MimeType ( $ mimetype ) ; } else { $ this -> mimetype = null ; trigger_error ( 'Argument must be an object of class MimeType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
2136	protected static function loadParameters ( ) { $ container = System :: getContainer ( ) ; if ( $ container === null ) { return ; } if ( $ container -> hasParameter ( 'contao.localconfig' ) && \ is_array ( $ params = $ container -> getParameter ( 'contao.localconfig' ) ) ) { foreach ( $ params as $ key => $ value ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ key ] = $ value ; } } $ arrMap = array ( 'dbHost' => 'database_host' , 'dbPort' => 'database_port' , 'dbUser' => 'database_user' , 'dbPass' => 'database_password' , 'dbDatabase' => 'database_name' , 'smtpHost' => 'mailer_host' , 'smtpUser' => 'mailer_user' , 'smtpPass' => 'mailer_password' , 'smtpPort' => 'mailer_port' , 'smtpEnc' => 'mailer_encryption' , 'addLanguageToUrl' => 'contao.prepend_locale' , 'encryptionKey' => 'contao.encryption_key' , 'urlSuffix' => 'contao.url_suffix' , 'uploadPath' => 'contao.upload_path' , 'debugMode' => 'kernel.debug' , ) ; foreach ( $ arrMap as $ strKey => $ strParam ) { if ( $ container -> hasParameter ( $ strParam ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ strKey ] = $ container -> getParameter ( $ strParam ) ; } } if ( $ container -> hasParameter ( 'contao.image.valid_extensions' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'validImageTypes' ] = implode ( ',' , $ container -> getParameter ( 'contao.image.valid_extensions' ) ) ; } if ( $ container -> hasParameter ( 'contao.image.imagine_options' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'jpgQuality' ] = $ container -> getParameter ( 'contao.image.imagine_options' ) [ 'jpeg_quality' ] ; } }
5768	public function addColumn ( string $ name , $ value ) { $ this -> args [ ] = $ value ; if ( count ( $ this -> args ) > 1 ) { $ this -> setColumnsValues .= ", " ; } $ argNum = count ( $ this -> args ) ; $ this -> setColumnsValues .= "$name = \$" . $ argNum ; }
2275	public function getLayoutSections ( ) { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; $ objLayout = $ this -> Database -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = Contao \ StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ arrSections [ ] = $ v [ 'id' ] ; } } } } return Contao \ Backend :: convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) ; }
5965	public function channelGroupPermList ( $ cgid , $ permsid = false ) { return $ this -> execute ( "channelgrouppermlist" , array ( "cgid" => $ cgid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
9214	public function actionCreate ( ) { $ model = new StaticPage ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> isdel = 0 ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { $ post [ 'StaticPage' ] [ 'tags' ] = implode ( "," , $ post [ 'StaticPage' ] [ 'tags' ] ) ; } } if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; } }
5721	public function doSaveAndPrev ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; $ link = $ this -> getEditLink ( $ this -> getPreviousRecordID ( ) ) ; return $ this -> saveAndRedirect ( $ data , $ form , $ link ) ; }
6257	public function authorize ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; if ( ! isset ( $ user [ $ roleField ] ) ) { throw new RuntimeException ( sprintf ( 'The role field `%s` does not exist!' , $ roleField ) ) ; } if ( is_string ( $ user [ $ roleField ] ) ) { $ user [ $ roleField ] = array ( $ user [ $ roleField ] ) ; } if ( $ this -> authorizeByPrefix ( $ user [ $ roleField ] , $ request ) ) { return true ; } if ( $ this -> authorizeByControllerAndAction ( $ user , $ request ) ) { return true ; } return false ; }
2071	private function getDateAndTime ( CalendarEventsModel $ objEvent , PageModel $ objPage , $ intStartTime , $ intEndTime , $ span ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) ; if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> dateFormat , $ intEndTime ) ; } $ strTime = '' ; if ( $ objEvent -> addTime ) { if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> datimFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> datimFormat , $ intEndTime ) ; } elseif ( $ intStartTime == $ intEndTime ) { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) ; } else { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> timeFormat , $ intEndTime ) ; } } return array ( $ strDate , $ strTime ) ; }
9609	protected function _checkVectorSpace ( self $ b ) { if ( ! $ this -> isSameDimension ( $ b ) ) { throw new Exception ( 'The vectors must be of the same dimension' ) ; } if ( ! $ this -> isSameVectorSpace ( $ b ) ) { throw new Exception ( 'The vectors\' components must have the same keys' ) ; } }
11901	private function assembleUrl ( ) { $ address = '' ; if ( ! empty ( $ this -> scheme ) ) { $ address .= $ this -> scheme . '://' ; } if ( ! empty ( $ this -> user ) ) { $ address .= $ this -> user ; } if ( ! empty ( $ this -> pass ) ) { $ address .= ':' . $ this -> pass . '@' ; } if ( ! empty ( $ this -> host ) ) { $ address .= $ this -> host ; } if ( ! empty ( $ this -> port ) ) { $ address .= ':' . $ this -> port ; } if ( ! empty ( $ this -> path ) ) { $ address .= $ this -> path ; } if ( count ( $ this -> query ) > 0 ) { $ this -> query_string = http_build_query ( $ this -> query ) ; $ address .= '?' . $ this -> query_string ; } if ( ! empty ( $ this -> fragment ) ) { $ address .= '#' . $ this -> fragment ; } $ this -> full_address = $ address ; }
7295	public function send_mail ( $ to , $ subject = '' , $ message = '' , $ headers = array ( ) , $ attachments = array ( ) ) { if ( $ this -> options [ 'static_options' ] [ 'mail_to_chunking' ] [ 'chunking' ] === TRUE ) { $ send_next_group = array ( ) ; if ( array_key_exists ( 'send_next_group' , $ this -> options [ 'static_options' ] ) ) { $ object_id = $ this -> options [ 'static_options' ] [ 'object' ] [ 'id' ] ; $ send_next_group = $ this -> options [ 'static_options' ] [ 'send_next_group' ] [ $ object_id ] ; } if ( $ this -> options [ 'send_by_bcc' ] ) { $ headers [ 'Bcc' ] = $ this -> get_mail_to_chunk ( $ headers [ 'Bcc' ] , $ send_next_group ) ; } else { $ to = $ this -> get_mail_to_chunk ( $ to , $ send_next_group ) ; } } foreach ( $ headers as $ k => $ v ) { $ headers [ ] = $ k . ': ' . $ v ; unset ( $ headers [ $ k ] ) ; } return wp_mail ( $ to , $ subject , $ message , $ headers , $ attachments ) ; }
11804	public function isRelation ( $ key ) { if ( ! method_exists ( $ this -> model , $ key ) ) { return false ; } $ relation = $ this -> model -> { $ key } ( ) ; return ( $ relation instanceof Relation ) ; }
6022	public function request ( $ endPoint , $ httpVerb = 'GET' , $ data = array ( ) ) { if ( ! $ this -> apiKey ) { throw new \ Exception ( 'MailChimp API Key must be set before making request!' ) ; } $ endPoint = ltrim ( $ endPoint , '/' ) ; $ httpVerb = strtoupper ( $ httpVerb ) ; $ requestUrl = $ this -> apiUrl . $ endPoint ; return $ this -> curlRequest ( $ requestUrl , $ httpVerb , $ data ) ; }
12689	public function get ( $ namespace , $ name , $ default = null , $ require = false ) { $ configuration = $ this -> load ( $ namespace , $ require ) ; return array_key_exists ( $ name , $ configuration ) ? $ configuration [ $ name ] : $ default ; }
7427	public function renderEmbed ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> embedDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
9047	public function getType ( $ data_type = 'metadata' , $ type = 'text' ) { if ( isset ( $ this -> types [ $ data_type ] [ $ type ] ) ) { return $ this -> types [ $ data_type ] [ $ type ] ; } return false ; }
2556	protected static function loadObFees ( $ obFees , $ obFeeRefs ) { $ opt = [ ] ; if ( ! empty ( $ obFees ) ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_OB_FEES ) ; $ po -> penDisInformation = new PenDisInformation ( PenDisInformation :: QUAL_OB_FEES , $ obFees ) ; if ( ! empty ( $ obFeeRefs ) ) { $ po -> paxSegTstReference = new PaxSegTstReference ( $ obFeeRefs ) ; } $ opt [ ] = $ po ; } return $ opt ; }
3733	protected function getAttributeByNames ( $ attrNames = array ( ) ) { if ( empty ( $ attrNames ) ) { return $ this -> arrAttributes ; } $ result = array ( ) ; foreach ( $ attrNames as $ attributeName ) { $ result [ $ attributeName ] = $ this -> arrAttributes [ $ attributeName ] ; } return $ result ; }
9169	public function setTimestampCreated ( $ postTime ) { if ( $ postTime instanceof DateTime ) { $ this -> timestampCreated = $ postTime ; } else { $ this -> timestampCreated = new DateTime ( $ postTime ) ; } return $ this ; }
6577	public function getList ( $ sort = null ) { $ countries = $ this -> getCountries ( ) ; $ validSorts = array ( 'name' , 'fullname' , 'iso_3166_2' , 'iso_3166_3' , 'capital' , 'citizenship' , 'currency' , 'currency_code' , 'calling_code' ) ; if ( ! is_null ( $ sort ) && in_array ( $ sort , $ validSorts ) ) { uasort ( $ countries , function ( $ a , $ b ) use ( $ sort ) { if ( ! isset ( $ a [ $ sort ] ) && ! isset ( $ b [ $ sort ] ) ) { return 0 ; } elseif ( ! isset ( $ a [ $ sort ] ) ) { return - 1 ; } elseif ( ! isset ( $ b [ $ sort ] ) ) { return 1 ; } else { return strcasecmp ( $ a [ $ sort ] , $ b [ $ sort ] ) ; } } ) ; } return $ countries ; }
7585	public static function getSDKEndpointRegistry ( ) { $ entryPoints = array ( ) ; require __DIR__ . DIRECTORY_SEPARATOR . 'registry.php' ; foreach ( $ entryPoints as $ funcName => $ className ) { $ className = "SugarAPI\\SDK\\Endpoint\\" . $ className ; $ entryPoints [ $ funcName ] = $ className ; } return $ entryPoints ; }
6343	public function equals ( ObjectInterface $ object = null ) : bool { return $ object instanceof static && $ object -> name === $ this -> name ; }
4792	function select ( $ columns ) { $ this -> __destruct ( ) ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { $ this -> select [ ] = $ columns ; } } else { $ this -> select = array ( ) ; } return $ this ; }
9127	private function checkConnection ( $ start ) : bool { if ( ! $ this -> ready ( ) ) { if ( time ( ) - $ start > $ this -> timeout ) { $ this -> disconnect ( ) ; throw new HttpException ( "Connection timed out!" ) ; } return false ; } return true ; }
362	protected function getClientOptions ( ) { $ filterUrl = isset ( $ this -> filterUrl ) ? $ this -> filterUrl : Yii :: $ app -> request -> url ; $ id = $ this -> filterRowOptions [ 'id' ] ; $ filterSelector = "#$id input, #$id select" ; if ( isset ( $ this -> filterSelector ) ) { $ filterSelector .= ', ' . $ this -> filterSelector ; } return [ 'filterUrl' => Url :: to ( $ filterUrl ) , 'filterSelector' => $ filterSelector , ] ; }
7798	public function parse ( $ text ) { $ statements = array ( ) ; foreach ( $ this -> splitStatements ( $ text ) as $ chunk ) { if ( $ statement = $ this -> statement ( $ chunk ) ) { $ statements [ ] = $ statement ; } } return $ statements ; }
724	public function getUniqueId ( ) { return $ this -> module instanceof Application ? $ this -> id : $ this -> module -> getUniqueId ( ) . '/' . $ this -> id ; }
1896	private function purgeOldFiles ( string $ webDir ) : void { if ( file_exists ( $ webDir . '/app_dev.php' ) ) { $ this -> fs -> remove ( $ webDir . '/app_dev.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/app_dev.php</comment> file.' ) ; } if ( file_exists ( $ webDir . '/install.php' ) ) { $ this -> fs -> remove ( $ webDir . '/install.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/install.php</comment> file.' ) ; } }
8947	public function uploadTrace ( $ file , $ description , $ tags , $ public , $ visibility , $ username , $ password ) { $ parameters = array ( 'file' => $ file , 'description' => $ description , 'tags' => $ tags , 'public' => $ public , 'visibility' => $ visibility , ) ; $ base = 'gpx/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'Content-Type' ] = 'multipart/form-data' ; $ header = array_merge ( $ header , $ parameters ) ; $ header = array_merge ( $ header , array ( 'Authorization' => 'Basic ' . base64_encode ( $ username . ':' . $ password ) ) ) ; return $ this -> sendRequest ( $ path , 'POST' , $ header , array ( ) ) ; }
6012	public function addCommentResponse ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate CommentResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "CommentResponse"!' , E_USER_WARNING ) ; } } $ this -> replies [ ] = $ item ; return $ this ; }
4348	private function getConfigKeys ( ) { if ( isset ( $ this -> configKeys ) ) { return $ this -> configKeys ; } $ this -> configKeys = array ( 'debug' => array ( ) , 'abstracter' => array ( 'cacheMethods' , 'collectConstants' , 'collectMethods' , 'objectsExclude' , 'objectSort' , 'useDebugInfo' , ) , 'errorEmailer' => array ( 'emailBacktraceDumper' , 'emailMask' , 'emailMin' , 'emailThrottledSummary' , 'emailThrottleFile' , 'emailThrottleRead' , 'emailThrottleWrite' , 'emailTraceMask' , ) , 'errorHandler' => \ array_keys ( $ this -> debug -> errorHandler -> getCfg ( ) ) , 'output' => array ( 'addBR' , 'css' , 'displayListKeys' , 'filepathCss' , 'filepathScript' , 'onOutput' , 'outputAs' , 'outputAsDefaultNonHtml' , 'outputConstants' , 'outputCss' , 'outputHeaders' , 'outputMethodDescription' , 'outputMethods' , 'outputScript' , ) , ) ; return $ this -> configKeys ; }
2140	private function fetchHttpHeaders ( ) : void { $ this -> headers = array_merge ( $ this -> headers , $ this -> headerStorage -> all ( ) ) ; $ this -> headerStorage -> clear ( ) ; }
6634	public function parseProfileResponse ( Response $ response , AccessTokenInterface $ access_token ) { $ profile = $ response -> json ( ) ; if ( gettype ( $ profile ) !== 'object' ) { throw new InvalidProfileException ( ) ; } if ( isset ( $ profile -> error ) ) { $ error = $ profile -> error ; throw new InvalidProfileException ( $ error -> type . ': ' . $ error -> message , $ error -> code ) ; } $ profile -> access_token = $ access_token -> token ( ) ; return $ this -> profile -> instantiate ( $ profile , $ this -> name ) ; }
7934	public function alreadyLoaded ( $ name ) { foreach ( $ this -> loaded as $ item ) { if ( $ item [ 'name' ] === $ name ) { return true ; } } return false ; }
10246	public static function ascToUcs ( $ ascii ) { $ rawname = '' ; $ iMax = strlen ( $ ascii ) ; for ( $ i = 0 ; $ i < $ iMax ; ++ $ i ) { $ rawname .= $ ascii [ $ i ] . "\x00" ; } return $ rawname ; }
7493	public function trimLeft ( $ characters = null ) { $ this -> string = ltrim ( $ this -> string , $ characters ) ; return $ this ; }
8735	public function decrement ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> decrement ( $ column , $ amount , $ extra ) ; }
6445	public function getLoginStartUrl ( $ redirecturl ) { $ linkedin = $ this -> getClient ( $ redirecturl ) ; $ url = $ linkedin -> getLoginUrl ( array ( \ LinkedIn \ LinkedIn :: SCOPE_BASIC_PROFILE , \ LinkedIn \ LinkedIn :: SCOPE_EMAIL_ADDRESS ) ) ; return $ url ; }
12659	private function setExtraLanguagesOutdated ( $ name , $ content ) { foreach ( $ this -> extraLangs as $ lang ) { $ this -> getPageTexts ( $ lang ) ; $ this -> contents [ $ lang ] [ $ name ] [ 'outdated' ] = true ; if ( ! isset ( $ this -> contents [ $ lang ] [ $ name ] [ 'content' ] ) ) { $ this -> contents [ $ lang ] [ $ name ] [ 'content' ] = $ content ; } $ this -> writeTextsToFile ( $ lang ) ; } }
3621	public function useEcoTempWhenAway ( $ enabled , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'auto_away_enable' => $ enabled ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
1412	public function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_FORBIDDEN , $ this -> trans ( 'resource_client_ids_not_supported' , 'code' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'title' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
4254	public function build ( $ stats ) { $ this -> stats = $ stats ; return '' . $ this -> buildFatal ( ) . $ this -> buildInConsole ( ) . $ this -> buildNotInConsole ( ) ; }
9319	public function markdown ( $ contents ) { $ contents = app ( 'markdown' ) -> convertToHtml ( $ contents ) ; if ( ! is_null ( $ this -> cachePath ) ) { $ this -> files -> put ( $ this -> getCompiledPath ( $ this -> getPath ( ) ) , $ contents ) ; } return $ contents ; }
12194	public function instantiate ( $ className , array $ data = [ ] ) { $ refl = new \ ReflectionClass ( $ className ) ; $ instanceArgs = [ ] ; if ( $ data ) { $ instanceArgs = $ this -> extractArguments ( $ refl -> getConstructor ( ) -> getParameters ( ) , $ data ) ; } return $ refl -> newInstanceArgs ( $ instanceArgs ) ; }
829	private function isStringPartToken ( Token $ token ) { return $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) || $ token -> isGivenKind ( T_START_HEREDOC ) || '"' === $ token -> getContent ( ) || 'b"' === strtolower ( $ token -> getContent ( ) ) ; }
6906	public function addExtraRecipient ( Recipient $ recipient ) { if ( ! $ this -> extraRecipients -> contains ( $ recipient ) ) { $ this -> extraRecipients -> add ( $ recipient ) ; } return $ this ; }
6864	protected function updateTotals ( InvoiceInterface $ invoice ) { $ changed = $ this -> invoiceCalculator -> calculate ( $ invoice ) ; if ( $ changed ) { foreach ( $ invoice -> getLines ( ) as $ line ) { $ this -> persistenceHelper -> persistAndRecompute ( $ line , false ) ; } } return $ changed ; }
5211	public function convert ( Node $ node , $ parentPrecedence , $ parentAssociativity , $ childPosition ) { $ type = $ node -> getType ( ) ; if ( $ this -> dispatcher -> issetPrecedenceMap ( $ type ) === true ) { $ childPrecedences = $ this -> dispatcher -> getPrecedenceMap ( $ type ) ; $ childPrecedence = $ childPrecedences [ 0 ] ; if ( $ childPrecedence > $ parentPrecedence || ( $ parentPrecedence == $ childPrecedence && $ parentAssociativity != $ childPosition ) ) { return '(' . $ this -> dispatcher -> { 'p' . $ type } ( $ node ) . ')' ; } } return $ this -> dispatcher -> { 'p' . $ type } ( $ node ) ; }
5298	public function addGlyph ( $ char , $ path , $ name = null , $ width = null ) { $ glyph = $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> addChild ( 'glyph' ) ; $ glyph -> addAttribute ( 'unicode' , $ char ) ; if ( $ name !== null ) { $ glyph -> addAttribute ( 'glyph-name' , $ name ) ; } if ( $ width !== null ) { $ glyph -> addAttribute ( 'horiz-adv-x' , $ width ) ; } $ glyph -> addAttribute ( 'd' , $ path ) ; }
1005	public function toPsrResponse ( $ result , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { if ( $ result instanceof Promise ) { return $ result -> then ( function ( $ actualResult ) use ( $ response , $ writableBodyStream ) { return $ this -> doConvertToPsrResponse ( $ actualResult , $ response , $ writableBodyStream ) ; } ) ; } return $ this -> doConvertToPsrResponse ( $ result , $ response , $ writableBodyStream ) ; }
11113	public function runPending ( array $ migrations , array $ options = [ ] ) { if ( count ( $ migrations ) === 0 ) { $ this -> notify -> note ( '<info>Nothing to migrate.</info>' ) ; return ; } $ batch = $ this -> repository -> getNextBatchNumber ( ) ; $ step = $ options [ 'step' ] ?? false ; $ this -> notify -> note ( '' ) ; foreach ( $ migrations as $ file ) { $ this -> runUp ( $ file , $ batch ) ; if ( $ step ) { $ batch ++ ; } } }
10344	protected function extractStep ( $ definition ) { if ( ( $ position = strpos ( $ definition , '/' ) ) !== false ) { return ( int ) substr ( $ definition , $ position + 1 ) ; } return false ; }
7906	protected function renderMenu ( $ items , $ parentItem ) { $ options = ArrayHelper :: getValue ( $ parentItem , 'options' ) ; $ label = $ this -> getLabel ( $ parentItem ) ; $ items = Html :: tag ( 'div' , $ this -> renderItems ( $ items ) , [ 'class' => 'menu' ] ) ; Html :: addCssClass ( $ options , 'ui' ) ; Html :: addCssClass ( $ options , 'header' ) ; return Html :: tag ( 'div' , Html :: tag ( 'div' , $ label , $ options ) . $ items , [ 'class' => 'item' ] ) ; }
9839	public function createSymmetricEncryptedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SharedEncryptionKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricEncryptedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
6208	public function load ( $ data ) { if ( ! is_array ( $ data ) && ! $ data instanceof \ stdClass ) { return ; } foreach ( $ data as $ key => $ value ) { $ this -> set ( $ key , $ value ) ; } }
11292	protected function _getAttributeDataWhenUnset ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { if ( $ attributeName != $ this -> getPrimaryKey ( ) ) { if ( $ this -> _isRelation ( $ attributeName ) && ! isset ( $ this -> model_dynamicOff ) ) { $ this -> $ attributeName = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap , $ record ) ; } else { $ this -> $ attributeName = $ this -> _fetchData ( $ attributeName ) ; } } else { $ this -> $ attributeName = null ; } $ this -> beforeGet ( $ attributeName ) ; $ returnValue = $ this -> model_data [ $ attributeName ] ; $ this -> afterGet ( $ attributeName , $ returnValue ) ; return $ returnValue ; }
9939	public function addChart ( Chart $ pChart , $ iChartIndex = null ) { $ pChart -> setWorksheet ( $ this ) ; if ( $ iChartIndex === null ) { $ this -> chartCollection [ ] = $ pChart ; } else { array_splice ( $ this -> chartCollection , $ iChartIndex , 0 , [ $ pChart ] ) ; } return $ pChart ; }
5126	public static function init ( array $ directories , EnvironmentInterface $ environment = null , bool $ handleErrors = true ) : ? self { if ( $ handleErrors ) { ExceptionHandler :: register ( ) ; } $ core = new static ( new Container ( ) , $ directories ) ; $ core -> container -> bindSingleton ( EnvironmentInterface :: class , $ environment ?? new Environment ( ) ) ; try { ContainerScope :: runScope ( $ core -> container , function ( ) use ( $ core ) { $ core -> bootload ( ) ; $ core -> bootstrap ( ) ; } ) ; } catch ( \ Throwable $ e ) { ExceptionHandler :: handleException ( $ e ) ; return null ; } return $ core ; }
11081	public static function GUIDv4 ( ) { return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x' , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0x0fff ) | 0x4000 , mt_rand ( 0 , 0x3fff ) | 0x8000 , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) ) ; }
5944	public function categories ( $ categoryIds , $ deploymentSiteIds = null , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/categories/' . $ categoryIds . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
4901	public static function loadConfig ( $ configuration = [ ] ) { $ configDir = static :: getConfigDir ( ) ; if ( empty ( $ configuration ) ) { $ configFile = $ configDir . '/config.php' ; if ( ! is_file ( $ configFile ) ) { throw new InvalidArgumentException ( sprintf ( 'Can not load config file "%s". Please be sure that this file exists and readable' , $ configFile ) ) ; } $ configuration = include $ configFile ; } $ isCli = php_sapi_name ( ) === 'cli' ; $ modules = $ configuration [ 'modules' ] ; $ modules = static :: generateModuleConfiguration ( $ modules ) ; $ yawikConfig = $ configDir . '/autoload/yawik.config.global.php' ; $ installMode = false ; if ( ! $ isCli && ! file_exists ( $ yawikConfig ) ) { $ modules = static :: generateModuleConfiguration ( [ 'Install' ] ) ; $ installMode = true ; } elseif ( in_array ( 'Install' , $ modules ) ) { $ modules = array_diff ( $ modules , [ 'Install' ] ) ; } static :: $ env = $ env = getenv ( 'APPLICATION_ENV' ) ? : 'production' ; $ defaults = [ 'module_listener_options' => [ 'module_paths' => [ './module' , './vendor' , './modules' ] , 'config_glob_paths' => [ sprintf ( $ configDir . '/autoload/{,*.}{global,%s,local}.php' , $ env ) ] , 'config_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_key' => 'module_map' , 'check_dependencies' => ( $ env != 'production' ) , 'cache_dir' => getcwd ( ) . "/var/cache" , ] , ] ; $ envConfig = [ ] ; $ envConfigFile = $ configDir . '/config.' . $ env . '.php' ; if ( file_exists ( $ envConfigFile ) ) { if ( is_readable ( $ envConfigFile ) ) { $ envConfig = include $ envConfigFile ; } else { \ trigger_error ( sprintf ( 'Environment config file "%s" is not readable.' , $ envConfigFile ) , E_USER_NOTICE ) ; } } $ configuration = ArrayUtils :: merge ( $ defaults , $ configuration ) ; $ configuration = ArrayUtils :: merge ( $ configuration , $ envConfig ) ; $ configuration [ 'modules' ] = $ modules ; if ( $ installMode ) { $ configuration [ 'module_listener_options' ] [ 'config_cache_enabled' ] = false ; $ configuration [ 'module_listener_options' ] [ 'module_map_cache_enabled' ] = false ; } if ( getenv ( 'DOCKER_ENV' ) == 'yes' ) { $ configuration = ArrayUtils :: merge ( $ configuration , static :: getDockerEnv ( $ configuration ) ) ; } return $ configuration ; }
3557	protected function setType ( $ value ) { $ this -> attributes [ 'meta_type' ] = $ this -> hasMutator ( $ value , 'setter' ) ? $ this -> getMutatedType ( $ value , 'setter' ) : $ this -> getValueType ( $ value ) ; }
6646	public function authenticate ( ) { $ request_token = $ this -> oauth -> getRequestToken ( $ this -> settings , $ this -> consumer , $ this -> token ) ; $ auth_url = $ this -> settings ( 'auth_api_url' ) . $ this -> settings ( 'authentication_uri' ) ; $ auth_url .= '?' . http_build_query ( [ 'oauth_token' => $ request_token -> key ] ) ; return $ this -> redirect -> to ( $ auth_url ) ; }
10759	public function set ( $ col , $ value = ClauseInterface :: NO_VALUE ) { if ( is_array ( $ col ) ) { return $ this -> setWithArrayData ( $ col ) ; } if ( ! isset ( $ this -> clause_set [ $ col ] ) ) { $ this -> clause_set [ $ col ] = true ; } if ( ClauseInterface :: NO_VALUE !== $ value ) { $ this -> clause_data [ $ this -> clause_rownum ] [ $ col ] = $ value ; } return $ this ; }
12146	public function get ( $ name ) { if ( $ this -> exists ( $ name ) ) { $ value = $ this -> settings [ $ name ] ; return $ value ; } return false ; }
6336	public function overlay ( $ title , $ message , $ level = 'info' , $ key = 'flash_message' ) { return $ this -> create ( $ title , $ message , $ level , $ key . '_overlay' ) ; }
8023	public function synchronize ( \ Closure $ closure ) { $ this -> acquire ( ) ; call_user_func ( $ closure ) ; $ this -> release ( ) ; return $ this ; }
1633	protected function fireLogEvent ( $ level , $ message , array $ context = [ ] ) { if ( ! isset ( $ this -> dispatcher ) ) { return ; } if ( class_exists ( MessageLogged :: class ) ) { $ this -> dispatcher -> dispatch ( new MessageLogged ( $ level , $ message , $ context ) ) ; } else { $ this -> dispatcher -> fire ( 'illuminate.log' , compact ( 'level' , 'message' , 'context' ) ) ; } }
10548	public function setTemplate ( Template $ template ) { $ this -> template = $ template ; $ this -> setVariable ( 'template' , $ template ) ; $ this -> setVariable ( 'tpl' , $ template ) ; return $ this ; }
4454	private function registerSyncCompleteEvent ( ) : void { $ this -> getEventsManager ( ) -> attach ( QueueEvent \ AfterEnqueue :: getName ( ) , function ( QueueEvent \ AfterEnqueue $ event ) { if ( ! $ this -> client -> config -> get ( 'sync-enabled' ) ) { return ; } $ job = $ this -> popByJid ( $ event -> getJid ( ) ) ; if ( ! empty ( $ job ) ) { $ job -> perform ( ) ; } } ) ; }
7887	protected function parse ( ) { $ log = [ ] ; $ pattern = "/\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\].*/" ; preg_match_all ( $ pattern , $ this -> raw , $ headings ) ; $ data = preg_split ( $ pattern , $ this -> raw ) ; if ( $ data [ 0 ] < 1 ) { $ trash = array_shift ( $ data ) ; unset ( $ trash ) ; } foreach ( $ headings as $ heading ) { for ( $ i = 0 , $ j = count ( $ heading ) ; $ i < $ j ; $ i ++ ) { foreach ( $ this -> levels as $ level ) { if ( $ this -> level == $ level || $ this -> level == 'all' ) { if ( strpos ( strtolower ( $ heading [ $ i ] ) , strtolower ( '.' . $ level ) ) ) { $ log [ ] = [ 'level' => $ level , 'header' => $ heading [ $ i ] , 'stack' => $ data [ $ i ] ] ; } } } } } unset ( $ headings ) ; unset ( $ data ) ; return array_reverse ( $ log ) ; }
1358	public static function create ( $ mediaType , int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , new EncoderOptions ( $ options , $ urlPrefix , $ depth ) ) ; }
8903	public function delete_by_at ( $ condition , $ time ) { $ this -> prevent_if_not_soft_deletable ( ) ; $ this -> _set_where ( $ condition ) ; return $ this -> _delete ( $ condition , $ time ) ; }
9312	public function indexAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; $ console -> writeLine ( 'TODO Finish indexAction!' , ConsoleColor :: LIGHT_RED ) ; }
180	protected function loadDummyBundle ( $ name ) { if ( ! isset ( $ this -> _dummyBundles [ $ name ] ) ) { $ this -> _dummyBundles [ $ name ] = $ this -> loadBundle ( $ name , [ 'sourcePath' => null , 'js' => [ ] , 'css' => [ ] , 'depends' => [ ] , ] ) ; } return $ this -> _dummyBundles [ $ name ] ; }
685	public function getCurrencySymbol ( $ currencyCode = null ) { $ locale = $ this -> locale ; if ( $ currencyCode !== null ) { $ locale .= '@currency=' . $ currencyCode ; } $ formatter = new \ NumberFormatter ( $ locale , \ NumberFormatter :: CURRENCY ) ; return $ formatter -> getSymbol ( \ NumberFormatter :: CURRENCY_SYMBOL ) ; }
32	public function addRule ( Rule $ rule ) { $ this -> addReason ( spl_object_hash ( $ rule ) , array ( 'rule' => $ rule , 'job' => $ rule -> getJob ( ) , ) ) ; }
1838	public static function findBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ blnModel = false ; $ arrColumn = ( array ) $ strColumn ; if ( \ count ( $ arrColumn ) == 1 && ( $ arrColumn [ 0 ] === static :: getPk ( ) || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) ) { $ blnModel = true ; } $ arrOptions = array_merge ( array ( 'column' => $ strColumn , 'value' => $ varValue , 'return' => $ blnModel ? 'Model' : 'Collection' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
4718	public function processStandardUrl ( Text $ text ) { $ hashes = array ( ) ; $ text -> replace ( '{<code>.*?</code>}m' , function ( Text $ w ) use ( & $ hashes ) { $ md5 = md5 ( $ w ) ; $ hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '{(?<!]\(|"|<|\[)((?:https?|ftp)://[^\'">\s]+)(?!>|\"|\])}' , '<\1>' ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) use ( & $ hashes ) { return $ hashes [ ( string ) $ md5 ] ; } ) ; }
7031	private function findMatchingShipmentItem ( InvoiceLineInterface $ line , ShipmentInterface $ shipment ) { $ saleItem = $ line -> getSaleItem ( ) ; foreach ( $ shipment -> getItems ( ) as $ shipmentItem ) { if ( $ saleItem === $ shipmentItem -> getSaleItem ( ) ) { return $ shipmentItem ; } } return null ; }
6769	public function onStateChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } $ this -> handleStateChange ( $ sale ) ; }
3865	public function render ( $ blnNoNativeParsing , $ objCaller ) { $ event = new RenderItemListEvent ( $ this , $ this -> objTemplate , $ objCaller ) ; $ this -> getEventDispatcher ( ) -> dispatch ( MetaModelsEvents :: RENDER_ITEM_LIST , $ event ) ; $ this -> objTemplate -> noItemsMsg = $ this -> getNoItemsCaption ( ) ; $ this -> objTemplate -> details = $ this -> getCaptionText ( 'details' ) ; $ this -> prepare ( ) ; $ strOutputFormat = $ this -> getOutputFormat ( ) ; if ( $ this -> objItems -> getCount ( ) && ! $ blnNoNativeParsing ) { $ this -> objTemplate -> data = $ this -> objItems -> parseAll ( $ strOutputFormat , $ this -> objView ) ; } else { $ this -> objTemplate -> data = array ( ) ; } $ this -> setTitleAndDescription ( ) ; $ this -> objTemplate -> caller = $ objCaller ; $ this -> objTemplate -> items = $ this -> objItems ; $ this -> objTemplate -> filterParams = $ this -> arrParam ; return $ this -> objTemplate -> parse ( $ strOutputFormat ) ; }
5364	protected function fix ( $ directory ) { if ( ! class_exists ( 'PhpCsFixer\Config' ) ) { return ; } $ fixerConfig = $ this -> fixerConfig ; if ( null === $ fixerConfig ) { $ fixerConfig = Config :: create ( ) -> setRiskyAllowed ( true ) -> setRules ( array ( '@Symfony' => true , 'array_syntax' => array ( 'syntax' => 'short' ) , 'simplified_null_return' => false , 'ordered_imports' => true , 'phpdoc_order' => true , 'binary_operator_spaces' => array ( 'align_equals' => true ) , 'concat_space' => false , 'yoda_style' => false , 'header_comment' => [ 'header' => <<<EOHThis file has been auto generated by Jane,Do no edit it directly.EOH , ] ) ) ; } $ resolverOptions = array ( 'allow-risky' => true ) ; $ resolver = new ConfigurationResolver ( $ fixerConfig , $ resolverOptions , $ directory , new ToolInfo ( ) ) ; $ finder = new Finder ( ) ; $ finder -> in ( $ directory ) ; $ fixerConfig -> setFinder ( $ finder ) ; $ runner = new Runner ( $ resolver -> getConfig ( ) -> getFinder ( ) , $ resolver -> getFixers ( ) , new NullDiffer ( ) , null , new ErrorsManager ( ) , new Linter ( ) , false , new NullCacheManager ( ) ) ; return $ runner -> fix ( ) ; }
10451	public function getTtl ( $ key ) { $ getResult = $ this -> getValue ( $ key ) ; $ unserialized = @ unserialize ( $ getResult ) ; if ( ! Util :: hasInternalExpireTime ( $ unserialized ) ) { throw new \ Exception ( 'Cannot retrieve ttl' ) ; } return $ this -> handleTtl ( $ key , $ unserialized [ 'ts' ] , $ unserialized [ 's' ] ) ; }
4164	public function setAccessToken ( $ data ) { ( true === is_object ( $ data ) ) ? $ token = $ data -> access_token : $ token = $ data ; $ this -> _accesstoken = $ token ; }
5839	protected function trim ( Builder $ url , $ args ) { $ args = ( is_string ( $ args ) ) ? $ args : null ; $ url -> trim ( $ args ) ; }
11856	public function isAjax ( ) : bool { $ param = $ this -> getServerParam ( 'HTTP_X_REQUESTED_WITH' , \ FILTER_SANITIZE_STRING ) ; return ! is_null ( $ param ) && strtolower ( $ param ) === 'xmlhttprequest' ; }
9227	public function post ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: post ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
2545	protected function makeDomXpath ( $ response ) { $ domDoc = $ this -> loadDomDocument ( $ response ) ; $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( self :: XMLNS_PREFIX , $ domDoc -> documentElement -> lookupNamespaceUri ( null ) ) ; return $ domXpath ; }
6743	public function supports ( ParamConverter $ configuration ) { return $ configuration -> getClass ( ) && is_a ( $ configuration -> getClass ( ) , $ this -> getClass ( ) , true ) ; }
2321	public static function get ( $ image , $ width , $ height , $ mode = '' , $ target = null , $ force = false ) { @ trigger_error ( 'Using Image::get() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; if ( $ image == '' ) { return null ; } try { $ imageObj = static :: create ( $ image , array ( $ width , $ height , $ mode ) ) ; $ imageObj -> setTargetPath ( $ target ) ; $ imageObj -> setForceOverride ( $ force ) ; if ( $ path = $ imageObj -> executeResize ( ) -> getResizedPath ( ) ) { return $ path ; } } catch ( \ Exception $ e ) { System :: log ( 'Image "' . $ image . '" could not be processed: ' . $ e -> getMessage ( ) , __METHOD__ , 'ERROR' ) ; } return null ; }
8712	public function whereTranslated ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( func_num_args ( ) == 2 ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } elseif ( $ this -> invalidOperatorAndValue ( $ operator , $ value ) ) { throw new InvalidArgumentException ( 'Illegal operator and value combination.' ) ; } if ( ! in_array ( strtolower ( $ operator ) , $ this -> operators , true ) ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } $ fallbackColumn = $ this -> qualifyTranslationColumn ( $ column , true ) ; $ column = $ this -> qualifyTranslationColumn ( $ column ) ; if ( ! $ this -> model -> shouldFallback ( ) || $ column instanceof Closure ) { return $ this -> where ( $ column , $ operator , $ value , $ boolean ) ; } $ condition = $ this -> compileIfNull ( $ column , $ fallbackColumn ) ; return $ this -> whereRaw ( "$condition $operator ?" , [ $ value ] , $ boolean ) ; }
6520	private function populateDefault ( Field $ field ) { if ( $ this -> has ( $ field -> getName ( ) ) ) { return true ; } $ default = $ field -> getDefault ( $ this ) ; if ( null === $ default ) { return false ; } if ( $ field -> isASingleValue ( ) ) { $ this -> data [ $ field -> getName ( ) ] = $ default ; unset ( $ this -> clearedFields [ $ field -> getName ( ) ] ) ; return true ; } if ( empty ( $ default ) ) { return false ; } if ( $ field -> isASet ( ) ) { $ this -> addToSet ( $ field -> getName ( ) , $ default ) ; return true ; } $ this -> data [ $ field -> getName ( ) ] = $ default ; unset ( $ this -> clearedFields [ $ field -> getName ( ) ] ) ; return true ; }
8879	private function isValidHomeDirectory ( string $ path ) : bool { $ valid = false ; if ( '~/' === substr ( $ path , 0 , 2 ) ) { $ valid = $ this -> isValidFullPath ( $ this -> expandHomeDirectory ( $ path ) ) ; } return $ valid ; }
8813	public function blade ( $ view , array $ data = [ ] , array $ mergeData = [ ] ) { if ( function_exists ( 'app' ) ) { $ this -> setContent ( app ( 'view' ) -> make ( $ view , $ data , $ mergeData ) -> render ( ) ) ; return $ this ; } return ; }
8017	public function fileExists ( $ name ) { $ http = new \ Guzzle \ Http \ Client ( ) ; try { $ response = $ http -> get ( $ this -> getUrl ( $ name ) ) -> send ( ) ; } catch ( ClientErrorResponseException $ e ) { return false ; } return $ response -> isSuccessful ( ) ; }
12912	public function join ( BaseManager $ manager , $ type = null , $ column = null , $ column_right = null ) { $ this -> joins [ $ manager -> table ] = array ( 'manager' => $ manager , 'type' => $ type , 'column' => $ column , 'column_right' => $ column_right ) ; return $ this ; }
5029	public function findForView ( $ id ) { $ type = $ this -> doctrine -> getConnection ( ) -> fetchColumn ( 'SELECT type FROM page WHERE id=:id' , array ( 'id' => $ id ) ) ; if ( ! $ type ) { throw new NotFoundHttpException ; } $ types = $ this -> em -> getClassMetadata ( $ this -> pageClassName ) -> discriminatorMap ; $ class = $ types [ $ type ] ; $ repos = $ this -> em -> getRepository ( $ class ) ; if ( $ repos instanceof ViewablePageRepository ) { $ ret = $ repos -> findForView ( $ id ) ; } else { $ ret = $ repos -> find ( $ id ) ; } if ( ! $ ret ) { throw new NotFoundHttpException ; } $ this -> setLoadedPage ( $ ret ) ; return $ ret ; }
2574	protected function loadSessionHandlerParams ( $ params ) { if ( isset ( $ params [ 'sessionHandlerParams' ] ) ) { if ( $ params [ 'sessionHandlerParams' ] instanceof SessionHandlerParams ) { $ this -> sessionHandlerParams = $ params [ 'sessionHandlerParams' ] ; } elseif ( is_array ( $ params [ 'sessionHandlerParams' ] ) ) { $ this -> sessionHandlerParams = new SessionHandlerParams ( $ params [ 'sessionHandlerParams' ] ) ; } } }
8888	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ requestHandler ) : ResponseInterface { $ this -> container -> set ( ServerRequestInterface :: class , $ request ) ; $ result = $ this -> dispatch ( $ this -> route ( $ request ) ) ; if ( $ result instanceof ResponseInterface ) { return $ result ; } return $ response = ( new Response ( ) ) -> withProtocolVersion ( '1.1' ) -> withBody ( \ GuzzleHttp \ Psr7 \ stream_for ( $ result ) ) ; }
8824	protected function errorMessage ( $ filter , $ field , $ params = null ) { $ text = ( isset ( $ this -> texts [ $ field ] [ $ filter ] ) && ! is_null ( $ this -> texts [ $ field ] [ $ filter ] ) ? $ this -> texts [ $ field ] [ $ filter ] : $ this -> msg ) ; $ text = str_replace ( [ ':label:' , ':value:' ] , '%s' , $ text ) ; if ( ! isset ( $ this -> data [ $ field ] ) ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } elseif ( ! is_null ( $ params ) ) { if ( $ filter == 'matches' ) { if ( $ this -> matches ( $ this -> data [ $ field ] , $ this -> data [ $ params ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] , $ params ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } }
4628	protected function prepareRequestUrl ( ) { $ protocol = $ this -> node -> useTls ( ) ? 'https' : 'http' ; $ this -> requestURL = sprintf ( '%s://%s%s?%s' , $ protocol , $ this -> node -> getUri ( ) , $ this -> path , $ this -> query ) ; $ this -> options [ CURLOPT_URL ] = $ this -> requestURL ; return $ this ; }
3903	public function renameColumn ( $ strNewColumnName ) { $ this -> tableManipulator -> checkColumnName ( $ strNewColumnName ) ; $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; $ columns = $ schemaManager -> listTableIndexes ( $ this -> getMetaModel ( ) -> getTableName ( ) ) ; if ( $ this -> getColName ( ) && isset ( $ columns [ $ this -> getColName ( ) ] ) ) { $ this -> tableManipulator -> renameColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) , $ strNewColumnName , $ this -> getSQLDataType ( ) ) ; } else { $ strBackupColName = $ this -> getColName ( ) ; $ this -> set ( 'colname' , $ strNewColumnName ) ; $ this -> createColumn ( ) ; $ this -> set ( 'colname' , $ strBackupColName ) ; } }
6503	public function produce ( Message $ message ) { $ type = $ message -> getType ( ) ; $ body = array ( 'ticket' => $ message -> getTicket ( ) ) ; try { $ this -> logger -> debug ( sprintf ( 'Publish message for job %s to sonata backend' , $ message -> getTicket ( ) ) , [ 'type' => $ type , 'body' => $ body ] ) ; $ queue = $ this -> registry -> get ( $ message -> getType ( ) ) -> getQueue ( ) ; $ this -> backendProvider -> getBackend ( $ queue ) -> createAndPublish ( $ type , $ body ) ; } catch ( \ Exception $ e ) { $ this -> logger -> error ( sprintf ( 'Failed to publish message (Error: %s)' , $ e -> getMessage ( ) ) , [ 'exception' => $ e ] ) ; if ( ! $ e instanceof \ RuntimeException ) { $ e = new \ RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } throw $ e ; } }
6842	public function produce ( $ key , $ params = array ( ) , $ enable_reflect = true ) { if ( isset ( $ this -> data [ $ key ] ) ) return $ this -> data [ $ key ] ; if ( isset ( $ this -> caches [ $ key ] ) ) return $ this -> caches [ $ key ] ; if ( isset ( $ this -> objects [ $ key ] ) ) { $ obj = $ this -> get ( $ key ) ; $ concrete = $ obj [ self :: INDEX_CONCRETE ] ; } else { if ( $ this -> MUST_REG || ! $ enable_reflect ) { throw new InjectorException ( "$key not registered" ) ; } else { $ concrete = $ key ; $ not_reg = true ; } } $ result = $ this -> build ( $ concrete , $ params ) ; if ( $ not_reg === true || $ obj [ self :: INDEX_CACHED ] === true ) { $ this -> caches [ $ key ] = $ result ; } return $ result ; }
3671	private function getFolderUrlFragments ( string $ alias , string $ host , string $ locale = null ) : ? array { $ pages = $ this -> getPageCandidates ( $ alias ) ; if ( null === $ pages ) { return null ; } if ( isset ( $ pages [ $ host ] ) ) { $ languages = $ pages [ $ host ] ; } else { $ languages = $ pages [ '*' ] ? : [ ] ; } unset ( $ pages ) ; $ pages = [ ] ; if ( ! $ this -> isLocalePrepended ) { $ pages = current ( $ languages ) ; } elseif ( $ locale && isset ( $ languages [ $ locale ] ) ) { $ pages = $ languages [ $ locale ] ; } if ( empty ( $ pages ) ) { return null ; } $ page = $ pages [ 0 ] ; if ( $ alias == $ page -> alias ) { $ arrFragments = [ $ alias ] ; } else { $ arrFragments = explode ( '/' , substr ( $ alias , ( \ strlen ( $ page -> alias ) + 1 ) ) ) ; array_unshift ( $ arrFragments , $ page -> alias ) ; } return $ arrFragments ; }
7419	protected function setRedirect ( string $ url = '' , int $ statusCode = 303 ) { $ this -> response -> redirect ( $ url , $ statusCode ) ; }
8662	private function convertGetFeedSubmissionList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionIdList ( ) ) { $ feedSubmissionIdList = $ request -> getFeedSubmissionIdList ( ) ; foreach ( $ feedSubmissionIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'FeedSubmissionIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
12567	public function sendCard ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_CARD , $ message , $ to ) ; }
4916	public function setValue ( $ value ) { if ( ! $ value ) { if ( ! $ this -> getName ( ) ) { throw new \ InvalidArgumentException ( 'Value must not be empty.' ) ; } $ value = self :: filterValue ( $ this -> getName ( ) ) ; } $ this -> value = ( string ) $ value ; return $ this ; }
913	private function moveReturnAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ returns = $ doc -> getAnnotationsOfType ( 'return' ) ; if ( empty ( $ returns ) ) { return $ content ; } $ others = $ doc -> getAnnotationsOfType ( [ 'param' , 'throws' ] ) ; if ( empty ( $ others ) ) { return $ content ; } $ start = $ returns [ 0 ] -> getStart ( ) ; $ line = $ doc -> getLine ( $ start ) ; foreach ( array_reverse ( $ others ) as $ other ) { if ( $ other -> getEnd ( ) > $ start ) { $ line -> setContent ( $ other -> getContent ( ) . $ line -> getContent ( ) ) ; $ other -> remove ( ) ; } } return $ doc -> getContent ( ) ; }
5543	public function getFrames ( ) { $ report = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ report [ $ this -> getPublicNameFromIndex ( $ i ) ] = $ this -> frames [ $ i ] -> getFrames ( ) ; } return $ report ; }
11953	public function deleteFromDB ( ) { if ( ! $ this -> isValid ( ) ) { return false ; } if ( count ( $ this -> key_properties ) == 0 ) { return false ; } $ where_part = '' ; foreach ( $ this -> key_properties as $ key ) { if ( $ where_part ) { $ where_part .= ' AND ' ; } if ( $ this -> { $ key } instanceof Web2All_Table_SQLOperation ) { trigger_error ( 'Web2All_Table_SaveObjectTrait->deleteFromDB(): using Web2All_Table_SQLOperation object for key value ' . $ key , E_USER_NOTICE ) ; $ where_part .= $ this -> obj_to_db_trans [ $ key ] . '=' . $ this -> { $ key } -> toSQLString ( ) ; } else if ( $ this -> { $ key } instanceof Web2All_Table_SQLOperationList ) { throw new Exception ( "Web2All_Table_SaveObjectTrait: can't delete using a Web2All_Table_SQLOperationList for key value " . $ key ) ; } else { $ where_part .= $ this -> obj_to_db_trans [ $ key ] . '=' . $ this -> db -> Quote ( $ this -> { $ key } ) ; } } $ this -> db -> Execute ( 'DELETE FROM ' . $ this -> quote ( $ this -> tablename ) . ' WHERE ' . $ where_part . ' ' ) ; return true ; }
10173	public function has ( $ pCoord ) { if ( $ pCoord === $ this -> currentCoordinate ) { return true ; } return isset ( $ this -> index [ $ pCoord ] ) ; }
3127	protected function isEndPoint ( TimePoint $ point ) { return $ point -> match ( null , TimePoint :: TARGET_ALL , TimePoint :: TYPE_END ) ; }
4471	public function requeue ( ? string $ queue = null , array $ opts = [ ] ) : string { $ opts = array_merge ( [ 'delay' => 0 , 'data' => $ this -> data , 'priority' => $ this -> priority , 'retries' => $ this -> retries , 'tags' => $ this -> tags , 'depends' => $ this -> dependencies , ] , $ opts ) ; $ queueName = $ queue ? : $ this -> queue ; $ data = json_encode ( $ opts [ 'data' ] , JSON_UNESCAPED_SLASHES ) ? : '{}' ; return $ this -> client -> requeue ( $ this -> worker , $ queueName , $ this -> jid , $ this -> klass , $ data , $ opts [ 'delay' ] , 'priority' , $ opts [ 'priority' ] , 'tags' , json_encode ( $ opts [ 'tags' ] , JSON_UNESCAPED_SLASHES ) , 'retries' , $ opts [ 'retries' ] , 'depends' , json_encode ( $ opts [ 'depends' ] , JSON_UNESCAPED_SLASHES ) ) ; }
10445	protected function handleParam ( ) { if ( preg_match ( '/^@([0-9]+)=(.*)$/' , $ this -> getNextLine ( self :: LINE_TYPE_ANY ) , $ part ) ) { $ paramValue = trim ( $ part [ 2 ] , "'" ) ; return [ $ part [ 1 ] => $ paramValue ] ; } return null ; }
10561	public function createController ( $ route , $ params ) { $ control = NULL ; $ route = ltrim ( $ route , '/' ) ; $ route = rtrim ( $ route , '/' ) ; $ vars = explode ( '/' , $ route ) ; if ( 1 === count ( $ vars ) && '' == $ vars [ 0 ] ) { $ control = $ this -> _buildControllerName ( $ this -> defaultController . 'Controller' ) ; $ aName = $ this -> _buildActionName ( $ control , $ this -> defaultAction ) ; } else if ( 1 === count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ this -> defaultAction ) ; } else if ( 2 === count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ vars [ 0 ] ) ; } else if ( 2 < count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ vars [ 0 ] ) ; array_shift ( $ vars ) ; } else { $ control = $ this -> _buildControllerName ( $ this -> defaultController . 'Controller' ) ; $ aName = $ this -> defaultAction . 'Action' ; } $ action = new Action ( $ aName , $ params ) ; $ controller = new $ control ( $ this -> config ) ; $ controller -> setAction ( $ action ) ; $ controller -> setDispatcher ( $ this -> dispatcher ) ; $ controller -> addDefaultListeners ( ) ; return $ controller ; }
1732	public function generate ( ) { $ objArticle = ArticleModel :: findPublishedById ( $ this -> article ) ; if ( $ objArticle === null ) { return '' ; } $ objParent = PageModel :: findPublishedById ( $ objArticle -> pid ) ; if ( $ objParent === null ) { return '' ; } $ this -> objArticle = $ objArticle ; $ this -> objParent = $ objParent ; return parent :: generate ( ) ; }
4550	public function setAssigneeLike ( ? string $ assigneeLike ) { $ this -> assigneeLike = $ assigneeLike ; $ this -> _assigneeLike = null !== $ assigneeLike ; return $ this ; }
6351	public static function size ( Iterator $ iterator ) { $ result = 0 ; Iterators :: each ( $ iterator , function ( ) use ( & $ result ) { $ result ++ ; } ) ; return $ result ; }
11533	public static function readFile ( $ file ) { if ( ! file_exists ( $ file ) ) { return null ; } $ handle = fopen ( $ file , 'r' ) ; if ( ! self :: lockFile ( $ handle , LOCK_SH | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_reading' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } $ contents = file_get_contents ( $ file ) ; self :: unlockFile ( $ handle ) ; return $ contents ; }
6918	public function hasAdjustments ( $ type = null ) { if ( null !== $ type ) { AdjustmentTypes :: isValidType ( $ type ) ; return $ this -> getAdjustments ( $ type ) -> count ( ) ; } return 0 < $ this -> adjustments -> count ( ) ; }
707	public function bigPrimaryKey ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BIGPK , $ length ) ; }
10254	public function getStreet ( ) { $ number = rand ( 100 , 9999 ) ; $ street_name = Street :: orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; return $ number . ' ' . $ street_name ; }
11228	protected function getUrl ( $ section , array $ uriParams = [ ] ) { $ endpoint = rtrim ( $ this -> getEndpoint ( ) , '/' ) ; $ section = ltrim ( $ section , '/' ) ; $ params = http_build_query ( $ uriParams ) ; if ( $ params ) { return sprintf ( "%s/%s?%s" , $ endpoint , $ section , $ params ) ; } else { return sprintf ( "%s/%s" , $ endpoint , $ section ) ; } }
7303	public function onParentChange ( ResourceEventInterface $ event ) { $ customer = $ this -> getCustomerFromEvent ( $ event ) ; if ( $ this -> updateFromParent ( $ customer ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ customer , true ) ; } }
9433	protected static function checkOrder ( $ float_min , $ float_max ) { if ( ! is_numeric ( $ float_min ) && ! is_numeric ( $ float_max ) ) { throw new \ InvalidArgumentException ( 'Min and max values must be valid numbers.' ) ; } if ( $ float_min >= $ float_max ) { throw new \ InvalidArgumentException ( 'Max value must be greater than min value!' ) ; } }
680	protected function validateConjunctionCondition ( $ operator , $ condition ) { if ( ! is_array ( $ condition ) || ! ArrayHelper :: isIndexed ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; return ; } foreach ( $ condition as $ part ) { $ this -> validateCondition ( $ part ) ; } }
7884	public function getShow ( $ date , $ level = null ) { $ logs = LogViewer :: logs ( ) ; if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ page = Input :: get ( 'page' ) ; if ( empty ( $ page ) ) { $ page = '1' ; } $ data = [ 'logs' => $ logs , 'date' => $ date , 'url' => 'logviewer' , 'data_url' => URL :: route ( 'logviewer.index' ) . '/data/' . $ date . '/' . $ level . '?page=' . $ page , 'levels' => LogViewer :: levels ( ) , 'current' => $ level , ] ; return View :: make ( 'logviewer::show' , $ data ) ; }
3183	private function durationToMs ( $ duration ) { if ( ! is_null ( $ duration ) && $ duration instanceof QtiDuration ) { return TestRunnerUtils :: getDurationWithMicroseconds ( $ duration ) ; } return false ; }
2821	protected function _beforeSave ( ) { parent :: _beforeSave ( ) ; if ( ! $ this -> getId ( ) ) { $ this -> setToken ( $ this -> generateToken ( ) ) ; $ this -> setHttpMethod ( $ this -> getController ( ) -> getHttpMethod ( ) ) ; $ this -> setResponseCode ( $ this -> getController ( ) -> getResponseCode ( ) ) ; $ this -> setIp ( $ this -> getController ( ) -> getRemoteIp ( ) ) ; } $ this -> setRequestPath ( $ this -> getController ( ) -> getRequestOriginalPath ( ) ) ; $ this -> setSessionId ( $ this -> getController ( ) -> getSessionId ( ) ) ; $ this -> setInfo ( $ this -> getSerializedInfo ( ) ) ; return $ this ; }
2322	public static function getPixelValue ( $ size ) { @ trigger_error ( 'Using Image::getPixelValue() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ value = preg_replace ( '/[^0-9.-]+/' , '' , $ size ) ; $ unit = preg_replace ( '/[^acehimnprtvwx%]/' , '' , $ size ) ; switch ( $ unit ) { case '' : case 'px' : return ( int ) round ( $ value ) ; break ; case 'em' : return ( int ) round ( $ value * 16 ) ; break ; case 'ex' : return ( int ) round ( $ value * 16 / 2 ) ; break ; case 'pt' : return ( int ) round ( $ value * 16 / 12 ) ; break ; case 'pc' : return ( int ) round ( $ value * 16 ) ; break ; case 'in' : return ( int ) round ( $ value * 16 * 6 ) ; break ; case 'cm' : return ( int ) round ( $ value * 16 / ( 2.54 / 6 ) ) ; break ; case 'mm' : return ( int ) round ( $ value * 16 / ( 25.4 / 6 ) ) ; break ; case '%' : return ( int ) round ( $ value * 16 / 100 ) ; break ; } return 0 ; }
12939	public function setMax ( $ value ) { $ this -> setTag ( 'max' , $ value ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'max' , $ value ) ; } }
8714	public function whereSubQuery ( $ column , $ query , $ boolean = 'and' ) { list ( $ type , $ operator ) = [ 'Sub' , 'in' ] ; $ this -> wheres [ ] = compact ( 'type' , 'column' , 'operator' , 'query' , 'boolean' ) ; $ this -> addBinding ( $ query -> getBindings ( ) , 'where' ) ; return $ this ; }
1480	private function flip ( array $ resources ) { $ all = [ ] ; foreach ( $ resources as $ resourceType => $ types ) { foreach ( ( array ) $ types as $ type ) { $ all [ $ type ] = $ resourceType ; } } return $ all ; }
11385	public static function signUrlForGoogle ( string $ sUrlToSign , string $ sClientId , string $ sPrivateKey ) : string { $ aUrl = parse_url ( $ sUrlToSign ) ; $ aUrl [ 'query' ] .= '&client=' . $ sClientId ; $ aUrlToSign = $ aUrl [ 'path' ] . "?" . $ aUrl [ 'query' ] ; $ decodedKey = base64_decode ( str_replace ( array ( '-' , '_' ) , array ( '+' , '/' ) , $ sPrivateKey ) ) ; $ sSignature = hash_hmac ( "sha1" , $ aUrlToSign , $ decodedKey , true ) ; $ sEncodedSignature = str_replace ( array ( '+' , '/' ) , array ( '-' , '_' ) , base64_encode ( $ sSignature ) ) ; $ sOriginalUrl = $ aUrl [ 'scheme' ] . "://" . $ aUrl [ 'host' ] . $ aUrl [ 'path' ] . "?" . $ aUrl [ 'query' ] ; return $ sOriginalUrl . '&signature=' . $ sEncodedSignature ; }
3013	public function like ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/like' , $ options , false ) ; }
10664	public function withRequest ( RequestInterface $ request ) { $ object = clone $ this ; $ object -> request = $ request ; $ object -> method = $ request -> getMethod ( ) ; return $ object ; }
12737	protected function translate ( ) { $ translatorOptions = $ this -> getTranslatorOptions ( ) ; if ( empty ( $ translatorOptions ) && ! array_key_exists ( "fields" , $ translatorOptions ) ) { return ; } $ params = array ( ) ; if ( array_key_exists ( "params" , $ translatorOptions ) ) { $ params = $ translatorOptions [ "params" ] ; } $ domain = "RedKiteCms" ; if ( array_key_exists ( "domain" , $ translatorOptions ) ) { $ domain = $ translatorOptions [ "domain" ] ; } foreach ( $ translatorOptions [ "fields" ] as $ field ) { $ field = ucfirst ( $ field ) ; $ method = 'get' . $ field ; $ value = Translator :: translate ( $ this -> $ method ( ) , $ params , $ domain ) ; $ method = 'set' . $ field ; $ this -> $ method ( $ value ) ; } }
872	private static function wordwrap ( $ string , $ width ) { $ result = [ ] ; $ currentLine = 0 ; $ lineLength = 0 ; foreach ( explode ( ' ' , $ string ) as $ word ) { $ wordLength = \ strlen ( Preg :: replace ( '~</?(\w+)>~' , '' , $ word ) ) ; if ( 0 !== $ lineLength ) { ++ $ wordLength ; } if ( $ lineLength + $ wordLength > $ width ) { ++ $ currentLine ; $ lineLength = 0 ; } $ result [ $ currentLine ] [ ] = $ word ; $ lineLength += $ wordLength ; } return array_map ( static function ( $ line ) { return implode ( ' ' , $ line ) ; } , $ result ) ; }
3590	public function allowsMeta ( $ key ) { $ allowed = $ this -> getAllowedMeta ( ) ; return empty ( $ allowed ) || in_array ( $ key , $ allowed ) ; }
1196	protected function renderHtmlAttribute ( $ name , $ value ) { if ( true === $ value ) { return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ name ) ) ; } return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ value ) ) ; }
1936	protected function getForwardUrl ( $ objPage ) { if ( $ objPage -> jumpTo ) { $ objNextPage = PageModel :: findPublishedById ( $ objPage -> jumpTo ) ; } else { $ objNextPage = PageModel :: findFirstPublishedRegularByPid ( $ objPage -> id ) ; } if ( ! $ objNextPage instanceof PageModel ) { $ this -> log ( 'Forward page ID "' . $ objPage -> jumpTo . '" does not exist' , __METHOD__ , TL_ERROR ) ; throw new ForwardPageNotFoundException ( 'Forward page not found' ) ; } $ strGet = '' ; $ strQuery = Environment :: get ( 'queryString' ) ; $ arrQuery = array ( ) ; if ( $ strQuery != '' ) { $ arrChunks = explode ( '&' , $ strQuery ) ; foreach ( $ arrChunks as $ strChunk ) { list ( $ k ) = explode ( '=' , $ strChunk , 2 ) ; $ arrQuery [ ] = $ k ; } } if ( ! empty ( $ _GET ) ) { foreach ( array_keys ( $ _GET ) as $ key ) { if ( Config :: get ( 'addLanguageToUrl' ) && $ key == 'language' ) { continue ; } if ( \ in_array ( $ key , $ arrQuery ) ) { continue ; } if ( $ key == 'auto_item' ) { $ strGet .= '/' . Input :: get ( $ key ) ; } else { $ strGet .= '/' . $ key . '/' . Input :: get ( $ key ) ; } } } if ( $ strQuery != '' ) { $ strQuery = '?' . $ strQuery ; } return $ objNextPage -> getAbsoluteUrl ( $ strGet ) . $ strQuery ; }
3962	private function createOrGetDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasMetaModelDefinition ( ) ) { return $ container -> getMetaModelDefinition ( ) ; } $ container -> setMetaModelDefinition ( $ definition = new MetaModelDefinition ( ) ) ; return $ definition ; }
8629	public function setParticipation ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Participation' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3608	public function getResourceOwnerDetailsUrl ( AccessToken $ token ) { $ uri = new Uri ( $ this -> urlResourceOwnerDetails ) ; return ( string ) Uri :: withQueryValue ( $ uri , 'access_token' , ( string ) $ token ) ; }
8345	public static function prefix ( string $ namespace , $ subdomain = null , string $ uri = null ) { self :: $ namespace = $ namespace ; self :: $ subdomain = is_array ( $ subdomain ) ? $ subdomain : [ $ subdomain ] ; self :: $ uri = $ uri ; }
3103	public function load ( ) { $ storage = $ this -> getStorage ( ) ; if ( $ storage ) { $ data = $ storage -> get ( $ this -> userId , $ this -> getStorageKey ( ) ) ; if ( $ data ) { $ this -> state = json_decode ( $ data , true ) ; } else { $ this -> state = [ ] ; } $ success = is_array ( $ this -> state ) ; } else { $ success = false ; } return $ success ; }
5228	public static function createInjector ( callable ... $ applyBindings ) { $ self = new self ( ) ; foreach ( $ applyBindings as $ applyBinding ) { $ applyBinding ( $ self ) ; } return $ self -> getInjector ( ) ; }
2558	protected function loadPaymentModule ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> fopType , $ options -> payMerchant , $ options -> payments , $ options -> installmentsInfo , $ options -> mopPaymentType , $ options -> creditCardInfo , $ options -> fraudScreening , $ options -> payIds , $ options -> paySupData ) ) { if ( $ this instanceof MopDescription14 ) { $ this -> paymentModule = new PaymentModule14 ( $ options -> fopType ) ; } else { $ this -> paymentModule = new PaymentModule ( $ options -> fopType ) ; } $ this -> paymentModule -> loadPaymentData ( $ options ) ; $ this -> loadMopInformation ( $ options ) ; $ this -> loadPaymentSupplementaryData ( $ options ) ; } }
10700	public static function isMobilePhoneNumber ( $ phone ) { $ phoneNumber = substr ( Tools :: removeSpace ( $ phone ) , - 9 , 1 ) ; return ( ! self :: isCzechPhoneNumber ( $ phoneNumber ) || ( $ phoneNumber === '6' || $ phoneNumber === '7' ) ) ; }
6623	public function parseResponse ( Response $ response ) { $ json = $ response -> json ( ) ; if ( ! is_null ( $ json ) ) { if ( isset ( $ json -> error ) ) { $ error = $ json -> error ; throw new AccessTokenException ( $ error -> type . ': ' . $ error -> message , $ error -> code ) ; } } $ token = $ response -> content ( ) ; return $ this -> parseToken ( $ token ) ; }
9806	private function readBSE ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ BSE = new BSE ( ) ; $ this -> object -> addBSE ( $ BSE ) ; $ BSE -> setBLIPType ( $ recInstance ) ; $ btWin32 = ord ( $ recordData [ 0 ] ) ; $ btMacOS = ord ( $ recordData [ 1 ] ) ; $ rgbUid = substr ( $ recordData , 2 , 16 ) ; $ tag = Xls :: getUInt2d ( $ recordData , 18 ) ; $ size = Xls :: getInt4d ( $ recordData , 20 ) ; $ cRef = Xls :: getInt4d ( $ recordData , 24 ) ; $ foDelay = Xls :: getInt4d ( $ recordData , 28 ) ; $ unused1 = ord ( $ recordData [ 32 ] ) ; $ cbName = ord ( $ recordData [ 33 ] ) ; $ unused2 = ord ( $ recordData [ 34 ] ) ; $ unused3 = ord ( $ recordData [ 35 ] ) ; $ nameData = substr ( $ recordData , 36 , $ cbName ) ; $ blipData = substr ( $ recordData , 36 + $ cbName ) ; $ reader = new self ( $ BSE ) ; $ reader -> load ( $ blipData ) ; }
6730	public function set_user_vote ( $ post_id , $ votes , $ vote , $ ip ) { global $ wpdb ; $ table_name = $ wpdb -> prefix . 'efg_custom_rating' ; $ result = $ wpdb -> get_row ( " SELECT id, vote FROM $table_name WHERE ip = '$ip' AND post_id = $post_id " ) ; if ( ! isset ( $ result -> id ) && ! isset ( $ result -> vote ) ) { $ wpdb -> insert ( $ table_name , [ 'post_id' => $ post_id , 'ip' => $ ip , 'vote' => $ vote , ] , [ '%d' , '%s' , '%d' ] ) ; $ votes [ $ vote ] ++ ; } else { if ( $ result -> vote != $ vote ) { $ wpdb -> update ( $ table_name , [ 'post_id' => $ post_id , 'ip' => $ ip , 'vote' => $ vote , ] , [ 'id' => $ result -> id ] , [ '%d' , '%s' , '%d' ] , [ '%d' ] ) ; $ votes [ $ result -> vote ] -- ; $ votes [ $ vote ] ++ ; } } return $ votes ; }
2729	public function beforeToHtml ( Image $ subject ) { if ( $ this -> config -> isImageOptimizationPixelRatioEnabled ( ) !== true ) { return ; } $ srcSet = [ ] ; $ imageUrl = $ subject -> getData ( 'image_url' ) ; $ pixelRatios = $ this -> config -> getImageOptimizationRatios ( ) ; $ pixelRatiosArray = explode ( ',' , $ pixelRatios ) ; $ glue = ( strpos ( $ imageUrl , '?' ) !== false ) ? '&' : '?' ; foreach ( $ pixelRatiosArray as $ pr ) { $ ratio = 'dpr=' . $ pr . ' ' . $ pr . 'x' ; $ srcSet [ ] = $ imageUrl . $ glue . $ ratio ; } $ subject -> setData ( 'custom_attributes' , 'srcset="' . implode ( ',' , $ srcSet ) . '"' ) ; }
628	public function bindValue ( $ name , $ value , $ dataType = null ) { if ( $ dataType === null ) { $ dataType = $ this -> db -> getSchema ( ) -> getPdoType ( $ value ) ; } $ this -> _pendingParams [ $ name ] = [ $ value , $ dataType ] ; $ this -> params [ $ name ] = $ value ; return $ this ; }
54	public function getDownloader ( $ type ) { $ type = strtolower ( $ type ) ; if ( ! isset ( $ this -> downloaders [ $ type ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Unknown downloader type: %s. Available types: %s.' , $ type , implode ( ', ' , array_keys ( $ this -> downloaders ) ) ) ) ; } return $ this -> downloaders [ $ type ] ; }
11752	public function open ( $ msgId , $ index ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_OPEN_COMMENT , $ params ] ) ; }
3081	protected function buildOptions ( RunnerServiceContext $ context ) { $ session = $ context -> getTestSession ( ) ; $ options = [ 'allowComment' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowComment ( $ session ) , 'allowSkipping' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowSkipping ( $ session ) , 'exitButton' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowExit ( $ session , $ context ) , 'logoutButton' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowLogout ( $ session ) , 'validateResponses' => \ taoQtiTest_helpers_TestRunnerUtils :: doesValidateResponses ( $ session ) , 'sectionPause' => $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> couldBePaused ( $ session ) ] ; $ categories = $ this -> getCategories ( $ context ) ; $ prefixCategory = 'x-tao-option-' ; $ prefixCategoryLen = strlen ( $ prefixCategory ) ; foreach ( $ categories as $ category ) { if ( ! strncmp ( $ category , $ prefixCategory , $ prefixCategoryLen ) ) { $ optionName = lcfirst ( str_replace ( ' ' , '' , ucwords ( strtr ( substr ( $ category , $ prefixCategoryLen ) , [ '-' => ' ' , '_' => ' ' ] ) ) ) ) ; $ options [ $ optionName ] = true ; } } return $ options ; }
6038	protected function initTransport ( $ options , $ transport = "TCP" ) { if ( ! is_array ( $ options ) ) { throw new Ts3Exception ( "transport parameters must provided in an array" ) ; } if ( $ transport == "TCP" ) $ this -> transport = new TCP ( $ options ) ; else $ this -> transport = new UDP ( $ options ) ; }
11796	public function setSubject ( $ subject = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'subject' ) ; } $ this -> subject = $ subject ; return $ this ; }
8296	public function write ( $ data ) { if ( ! is_string ( $ data ) ) { throw new \ InvalidArgumentException ( "The data is not a string." ) ; } $ this -> open ( ) ; if ( ! ftruncate ( $ this -> handle , 0 ) ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not truncate file " . $ this -> filePath ) ; } fseek ( $ this -> handle , 0 ) ; $ res = fwrite ( $ this -> handle , $ data ) ; if ( strlen ( $ data ) !== $ res ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not write to file " . $ this -> filePath ) ; } }
9597	protected function flashMessages ( $ messages ) { $ flashBag = $ this -> getSession ( ) -> getFlashBag ( ) ; foreach ( ( array ) $ messages as $ message ) { $ flashBag -> add ( '_messages' , $ message ) ; } }
8181	public function getDefaultStrategy ( $ name ) { if ( ! is_string ( $ this -> defaultStrategy ) && false !== $ this -> defaultStrategy ) { return call_user_func ( $ this -> defaultStrategy , $ name ) ; } return $ this -> defaultStrategy ; }
2429	public static function initializeApplication ( Event $ event ) : void { $ webDir = self :: getWebDir ( $ event ) ; static :: purgeCacheFolder ( ) ; static :: addAppDirectory ( ) ; static :: executeCommand ( 'contao:install-web-dir' , $ event ) ; static :: executeCommand ( 'cache:clear --no-warmup' , $ event ) ; static :: executeCommand ( 'cache:warmup' , $ event ) ; static :: executeCommand ( sprintf ( 'assets:install %s --symlink --relative' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:install %s' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:symlinks %s' , $ webDir ) , $ event ) ; $ event -> getIO ( ) -> write ( '<info>Done! Please open the Contao install tool and make sure the database is up-to-date.</info>' ) ; }
4324	public static function getBytes ( $ size ) { if ( \ is_string ( $ size ) && \ preg_match ( '/^([\d,.]+)\s?([kmgtp])b?$/i' , $ size , $ matches ) ) { $ size = \ str_replace ( ',' , '' , $ matches [ 1 ] ) ; switch ( \ strtolower ( $ matches [ 2 ] ) ) { case 'p' : $ size *= 1024 ; case 't' : $ size *= 1024 ; case 'g' : $ size *= 1024 ; case 'm' : $ size *= 1024 ; case 'k' : $ size *= 1024 ; } } $ units = array ( 'B' , 'kB' , 'MB' , 'GB' , 'TB' , 'PB' ) ; $ pow = \ pow ( 1024 , ( $ i = \ floor ( \ log ( $ size , 1024 ) ) ) ) ; $ size = $ pow == 0 ? '0 B' : \ round ( $ size / $ pow , 2 ) . ' ' . $ units [ $ i ] ; return $ size ; }
11914	public function addDynamic ( $ name , $ factory , $ createDefault = 0 , $ forceDefault = false ) { $ control = new RContainer ( $ factory , $ createDefault , $ forceDefault ) ; $ control -> currentGroup = $ this -> currentGroup ; return $ this [ $ name ] = $ control ; }
10863	protected function createIterator ( ) { $ options = \ RecursiveDirectoryIterator :: SKIP_DOTS ; $ iterator = new \ RecursiveDirectoryIterator ( $ this -> dir , $ options ) ; $ options = \ RecursiveIteratorIterator :: SELF_FIRST ; return new \ RecursiveIteratorIterator ( $ iterator , $ options ) ; }
10098	public function setOutline ( $ visible = true , $ symbols_below = true , $ symbols_right = true , $ auto_style = false ) { $ this -> outlineOn = $ visible ; $ this -> outlineBelow = $ symbols_below ; $ this -> outlineRight = $ symbols_right ; $ this -> outlineStyle = $ auto_style ; if ( $ this -> outlineOn ) { $ this -> outlineOn = 1 ; } }
7980	public function getSessionFiles ( $ sessId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionFiles ( $ this -> pp , $ this -> sn , $ sessId ) ) ; }
2745	public function isImageOptimizationEnabled ( ) { if ( $ this -> isFastlyEnabled ( ) !== true ) { return false ; } return $ this -> _scopeConfig -> isSetFlag ( self :: XML_FASTLY_IMAGE_OPTIMIZATIONS ) ; }
7085	public function setDbQueryConditionsForDefaultOptionsLoader ( $ conditonsAndOptions ) { if ( ! is_array ( $ conditonsAndOptions ) && ! ( $ conditonsAndOptions instanceof DbExpr ) && ! ( $ conditonsAndOptions instanceof \ Closure ) ) { throw new \ InvalidArgumentException ( '$conditonsAndOptions argument must be a string, DbExpr or a Closure' ) ; } $ this -> dbQueryConditionsForDefaultOptionsLoader = $ conditonsAndOptions ; return $ this ; }
2851	public function searchConfig ( $ query ) { $ configArray = array ( ) ; $ configArray = Mage :: helper ( 'sheep_debug' ) -> xml2array ( $ this -> getConfig ( ) -> getNode ( ) , $ configArray ) ; $ results = array ( ) ; $ configKeys = array_keys ( $ configArray ) ; foreach ( $ configKeys as $ configKey ) { if ( strpos ( $ configKey , $ query ) !== FALSE ) { $ results [ $ configKey ] = $ configArray [ $ configKey ] ; } } return $ results ; }
12152	public function setup ( ) { $ results = [ true ] ; if ( ! empty ( $ this -> primaryModel ) && ! empty ( $ this -> collectorItem -> parents ) ) { $ groups = [ 'top' ] ; foreach ( $ groups as $ groupName ) { $ group = Group :: getBySystemName ( $ groupName , false ) ; if ( empty ( $ group ) ) { continue ; } if ( $ this -> inheritParentAccess ) { $ results [ ] = $ this -> objectTypeModel -> parentAccess ( null , $ group ) ; } } } return min ( $ results ) ; }
7779	protected function extractRules ( array $ data ) { $ rules = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ rules [ $ field ] = $ fieldData [ 1 ] ; } return $ rules ; }
8490	public static function getUpTime ( ) { $ wmi = Windows :: getInstance ( ) ; $ booted_str = '' ; foreach ( $ wmi -> ExecQuery ( "SELECT LastBootUpTime FROM Win32_OperatingSystem" ) as $ os ) { $ booted_str = $ os -> LastBootUpTime ; } $ booted = [ 'year' => substr ( $ booted_str , 0 , 4 ) , 'month' => substr ( $ booted_str , 4 , 2 ) , 'day' => substr ( $ booted_str , 6 , 2 ) , 'hour' => substr ( $ booted_str , 8 , 2 ) , 'minute' => substr ( $ booted_str , 10 , 2 ) , 'second' => substr ( $ booted_str , 12 , 2 ) ] ; $ booted_ts = mktime ( $ booted [ 'hour' ] , $ booted [ 'minute' ] , $ booted [ 'second' ] , $ booted [ 'month' ] , $ booted [ 'day' ] , $ booted [ 'year' ] ) ; return date ( 'm/d/y h:i A (T)' , $ booted_ts ) ; }
8738	protected function filterValues ( array $ values ) { $ attributes = $ this -> model -> translatableAttributes ( ) ; $ translatable = [ ] ; foreach ( $ attributes as $ key ) { if ( array_key_exists ( $ key , $ values ) ) { $ translatable [ $ key ] = $ values [ $ key ] ; unset ( $ values [ $ key ] ) ; } } return [ $ values , $ translatable ] ; }
7247	protected function purge ( ShipmentInterface $ shipment ) { foreach ( $ shipment -> getItems ( ) as $ item ) { if ( 0 == $ item -> getAvailable ( ) ) { $ shipment -> removeItem ( $ item ) ; } } }
7396	public function execute ( ) { $ addresses = $ this -> addressRepository -> createQueryBuilder ( 'a' ) -> where ( 'a.latitude IS NULL' ) -> orWhere ( 'a.longitude IS NULL' ) -> setMaxResults ( 500 ) -> getQuery ( ) -> getResult ( ) ; foreach ( $ addresses as $ address ) { try { $ this -> updateLatLong ( $ address ) ; } catch ( \ RuntimeException $ e ) { echo "Stopping work -- over the API query limit.\n" ; break ; } $ this -> entityManager -> persist ( $ address ) ; usleep ( self :: MILLISECONDS_PAUSE_BETWEEN_QUERIES ) ; } $ this -> entityManager -> flush ( ) ; }
7269	public function belongsTo ( $ refClass , $ forColumn = null ) { $ refTable = $ refClass :: tableName ( ) ; $ forTable = static :: tableName ( ) ; $ refColumn = $ refClass :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( $ refClass :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select R.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and F.$forColumn = :id " , [ "id" => $ this -> $ forColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ refModel = new $ refClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ refModel -> $ col = $ refModel -> decodeValue ( $ val , $ col ) ; return $ refModel ; }
5805	public function increment ( ) { $ this -> counter ++ ; if ( 1 === $ this -> counter ) { $ this -> expiresAt = $ this -> now ( ) + $ this -> expiresIn ; } }
11559	public function SetWeekWords ( $ weekWords , $ lang = '' ) { if ( ! $ lang ) $ lang = $ this -> lang ; if ( is_array ( $ weekWords ) ) { $ this -> weekWords [ $ lang ] = $ weekWords ; } else { $ this -> weekWords [ $ lang ] = explode ( ',' , ( string ) $ weekWords ) ; } return $ this ; }
12843	protected function addOptionShortcut ( $ name , $ description , $ default ) { $ this -> addOption ( $ name , null , InputOption :: VALUE_OPTIONAL , $ description , $ default ) ; return $ this ; }
10081	protected function registerManager ( ) { $ this -> app -> singleton ( 'auja' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new Auja ( $ app , $ app [ 'auja.configurator' ] , $ config [ 'models' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Auja' , 'auja' ) ; }
4093	public function wildcard ( $ val , $ field = false ) { $ this -> wildcard = ( $ field ) ? array ( $ field => $ val ) : $ val ; return $ this ; }
7216	protected function getTaxGroupFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof TaxGroupInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . TaxGroupInterface :: class ) ; } return $ resource ; }
7378	public function fetchBool ( string $ key , bool $ default = false ) : bool { return $ this -> fetchFilter ( $ key , $ default , FILTER_VALIDATE_BOOLEAN ) ; }
9008	private function prepareColumn ( Row $ row ) : string { $ nullable = $ row -> Null === 'YES' ; if ( $ row -> Default === null && ! $ nullable ) { $ default = ' NOT null' ; } elseif ( $ row -> Default === null && $ nullable ) { $ default = ' DEFAULT null' ; } else { $ default = ( $ nullable ? '' : ' NOT null' ) . " DEFAULT '{$row->Default}'" ; } if ( ! empty ( $ row -> Collation ) ) { $ collate = ' COLLATE ' . $ row -> Collation ; } else { $ collate = '' ; } if ( $ row -> Extra === 'auto_increment' ) { $ autoIncrement = ' AUTO_INCREMENT' ; } else { $ autoIncrement = '' ; } return "`{$row->Field}` " . $ row -> Type . $ collate . $ default . $ autoIncrement ; }
6222	public function getElevation ( $ latitude , $ longitude ) { if ( $ latitude === 0.0 && $ longitude === 0.0 ) { return false ; } if ( ! $ this -> locationIsInBounds ( $ latitude , $ longitude ) ) { throw new InvalidArgumentException ( sprintf ( 'Location (%f, %f) is out of bounds ([-%f, %f], [-%f, %f]).' , $ latitude , $ longitude , static :: MAX_LATITUDE , static :: MAX_LATITUDE , static :: MAX_LONGITUDE , static :: MAX_LONGITUDE ) ) ; } $ filename = $ this -> getFilenameFor ( $ latitude , $ longitude ) ; if ( $ this -> CurrentFilename !== $ filename ) { $ this -> openResource ( $ filename ) ; } return $ this -> getElevationFromResource ( $ latitude , $ longitude ) ; }
120	protected function hasAuth ( ) { if ( null !== $ this -> hasAuth ) { return $ this -> hasAuth ; } if ( false === $ this -> createAuthFromConfig ( ) ) { $ this -> createAuthFromUrl ( ) ; } return $ this -> hasAuth ; }
36	protected function printLinks ( CompletePackageInterface $ package , $ linkType , $ title = null ) { $ title = $ title ? : $ linkType ; $ io = $ this -> getIO ( ) ; if ( $ links = $ package -> { 'get' . ucfirst ( $ linkType ) } ( ) ) { $ io -> write ( "\n<info>" . $ title . "</info>" ) ; foreach ( $ links as $ link ) { $ io -> write ( $ link -> getTarget ( ) . ' <comment>' . $ link -> getPrettyConstraint ( ) . '</comment>' ) ; } } }
1680	public function handleUserProfile ( Contao \ DataContainer $ dc ) { if ( Contao \ Input :: get ( 'do' ) != 'login' ) { return ; } if ( Contao \ BackendUser :: getInstance ( ) -> id != Contao \ Input :: get ( 'id' ) || Contao \ Input :: get ( 'act' ) != 'edit' ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not allowed to edit this page.' ) ; } $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'closed' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'hideVersionMenu' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] = array ( '__selector__' => $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ '__selector__' ] , 'default' => $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ 'login' ] ) ; $ arrFields = Contao \ StringUtil :: trimsplit ( '[,;]' , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ 'default' ] ) ; foreach ( $ arrFields as $ strField ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ strField ] [ 'exclude' ] = false ; } }
6073	public function group ( $ id , array $ children ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'children' => $ children ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/group' , $ parameters ) ; return $ result ; }
11731	protected function generateSlot ( $ path , $ blocks = array ( ) , $ username = null ) { if ( is_dir ( $ path ) && ! $ this -> override ) { return ; } $ folders = array ( ) ; $ activeDir = $ path . '/active' ; $ contributorsDir = $ path . '/contributors' ; $ folders [ ] = $ activeDir . '/blocks' ; $ folders [ ] = $ activeDir . '/archive' ; $ folders [ ] = $ contributorsDir ; $ targetDir = $ activeDir ; $ blocksDir = $ activeDir . '/blocks' ; if ( null !== $ username ) { $ targetDir = $ contributorsDir . '/' . $ username ; $ blocksDir = $ targetDir . '/blocks' ; $ folders [ ] = $ targetDir ; $ folders [ ] = $ targetDir . '/archive' ; $ folders [ ] = $ blocksDir ; } $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> generateBlocks ( $ blocks , $ blocksDir , $ targetDir ) ; }
10059	public function commit ( ) { foreach ( $ this -> deferred as $ item ) { $ this -> save ( $ item ) ; } $ this -> deferred = [ ] ; return true ; }
674	private function normalizeTableRowData ( $ table , $ columns ) { if ( $ columns instanceof Query ) { return $ columns ; } if ( ( $ tableSchema = $ this -> db -> getSchema ( ) -> getTableSchema ( $ table ) ) !== null ) { $ columnSchemas = $ tableSchema -> columns ; foreach ( $ columns as $ name => $ value ) { if ( isset ( $ columnSchemas [ $ name ] ) && $ columnSchemas [ $ name ] -> type === Schema :: TYPE_BINARY && is_string ( $ value ) ) { $ columns [ $ name ] = new PdoValue ( $ value , \ PDO :: PARAM_LOB ) ; } } } return $ columns ; }
2291	public function onKernelTerminate ( PostResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } if ( preg_match ( '~(?:^|/)' . preg_quote ( $ this -> fragmentPath , '~' ) . '/~' , $ request -> getPathInfo ( ) ) ) { return ; } $ frontend = $ this -> framework -> getAdapter ( Frontend :: class ) ; $ frontend -> indexPageIfApplicable ( $ event -> getResponse ( ) ) ; }
8593	public function listOrders ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceOrders_Model_ListOrdersRequest ) ) { $ request = new MarketplaceWebServiceOrders_Model_ListOrdersRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListOrders' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceOrders_Model_ListOrdersResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1874	private function addComponents ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; foreach ( Versions :: VERSIONS as $ name => $ version ) { if ( 0 !== strncmp ( 'contao-components/' , $ name , 18 ) ) { continue ; } $ serviceId = 'assets._package_' . $ name ; $ basePath = 'assets/' . substr ( $ name , 18 ) ; $ version = $ this -> createVersionStrategy ( $ container , $ version , $ name ) ; $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ version , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ name , new Reference ( $ serviceId ) ] ) ; } }
8846	public function getBlogPosts ( ) { $ blogPosts = BlogPost :: get ( ) -> filter ( "ParentID" , $ this -> ID ) ; $ this -> extend ( 'updateGetBlogPosts' , $ blogPosts ) ; return $ blogPosts ; }
5979	public function propertysets ( ) { if ( ! $ this -> propertysets instanceof PropertysetsController ) { $ this -> propertysets = new PropertysetsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> propertysets -> setLogger ( $ this -> logger ) ; } return $ this -> propertysets ; }
3026	private function parseResponse ( $ response ) { $ response -> json = json_decode ( $ response -> body ) ; if ( $ response -> status < 400 ) { return $ response -> json -> response ; } else { throw new RequestException ( $ response ) ; } }
3254	private function getItem ( $ sku ) { $ className = Config :: get ( 'shop.item' ) ; $ item = new $ className ( ) ; return $ item -> where ( 'sku' , $ sku ) -> where ( 'cart_id' , $ this -> attributes [ 'id' ] ) -> first ( ) ; }
8391	public function addFullOuterJoin ( $ table , $ on ) { $ this -> fullOuterJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
3067	public function process ( ) { $ this -> validate ( ) ; $ ref = ( $ this -> getRequestParameter ( 'ref' ) === false ) ? null : $ this -> getRequestParameter ( 'ref' ) ; $ direction = $ this -> getRequestParameter ( 'direction' ) ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = ( $ this -> getRequestParameter ( 'start' ) !== false ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( ! $ this -> getRunnerService ( ) -> isTerminated ( $ serviceContext ) ) { $ this -> endItemTimer ( $ this -> getTime ( ) ) ; $ this -> saveItemState ( ) ; } $ this -> initServiceContext ( ) ; $ this -> saveItemResponses ( false ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ serviceContext -> getTestSession ( ) -> initItemTimer ( $ this -> getTime ( ) ) ; $ result = $ this -> getRunnerService ( ) -> move ( $ serviceContext , $ direction , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } common_Logger :: d ( 'Test session state : ' . $ serviceContext -> getTestSession ( ) -> getState ( ) ) ; if ( $ start === true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { common_Logger :: e ( $ e -> getMessage ( ) ) ; $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
2399	public static function notifyCommentsSubscribers ( CommentsModel $ objComment ) { if ( $ objComment -> notified ) { return ; } $ objNotify = CommentsNotifyModel :: findActiveBySourceAndParent ( $ objComment -> source , $ objComment -> parent ) ; if ( $ objNotify !== null ) { while ( $ objNotify -> next ( ) ) { if ( $ objNotify -> email == $ objComment -> email ) { continue ; } $ strUrl = Idna :: decode ( Environment :: get ( 'base' ) ) . $ objNotify -> url ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifySubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifyMessage' ] , $ objNotify -> name , $ strUrl . '#c' . $ objComment -> id , $ strUrl . '?token=' . $ objNotify -> tokenRemove ) ; $ objEmail -> sendTo ( $ objNotify -> email ) ; } } $ objComment -> notified = '1' ; $ objComment -> save ( ) ; }
710	public function tinyInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TINYINT , $ length ) ; }
11180	protected function set ( $ key , $ value ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; $ cache [ $ key ] = $ value ; apc_store ( $ this -> getKey ( ) , $ cache ) ; }
5787	public function routeGetLogout ( Request $ request , Response $ response ) { $ this -> events -> setAdministratorId ( $ this -> authentication -> getAdministratorId ( ) ) ; if ( null === $ username = $ this -> authentication -> getAdministratorUsername ( ) ) { $ this -> events -> insertWarning ( EVENT_LOGOUT_FAULT ) ; } else { $ this -> events -> insertInfo ( EVENT_LOGOUT ) ; $ this -> authentication -> logout ( ) ; } return $ response -> withRedirect ( $ this -> router -> pathFor ( ROUTE_HOME ) ) ; }
3378	private function showLink ( $ link ) { if ( ! $ link [ 'show_menu' ] ) return false ; $ user = \ Auth :: guard ( 'panel' ) -> user ( ) ; return $ user -> hasRole ( 'super' ) || $ user -> hasPermission ( '/' . $ link [ 'url' ] . '/all' ) ; }
9875	private function writeLegacyDrawingHF ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getHeaderFooter ( ) -> getImages ( ) ) > 0 ) { $ objWriter -> startElement ( 'legacyDrawingHF' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId_headerfooter_vml1' ) ; $ objWriter -> endElement ( ) ; } }
11100	public static function fillToSize ( & $ array , $ size , $ fill ) { $ cnt = \ count ( $ array ) ; if ( $ cnt >= $ size ) { return ; } $ array = array_merge ( $ array , array_fill ( $ cnt + 1 , $ size - $ cnt , $ fill ) ) ; }
8745	protected function resetListener ( ) { $ this -> currentKey = null ; $ this -> escapePressedAt = null ; $ this -> charSequenceEnabled = false ; $ this -> isListening = true ; return $ this ; }
9464	private function registerLogViewerPackage ( ) { $ this -> registerProvider ( LogViewerServiceProvider :: class ) ; $ config = $ this -> config ( ) ; $ config -> set ( 'log-viewer.route.enabled' , false ) ; $ config -> set ( 'log-viewer.menu.filter-route' , $ config -> get ( 'arcanesoft.foundation.log-viewer.filter-route' ) ) ; }
4186	public function search ( ) { $ url = self :: PACKAGIST_URL . 'search.json?q=' . $ this -> getPackageName ( ) ; $ response = $ this -> client -> get ( $ url ) -> getBody ( ) -> getContents ( ) ; $ this -> rawPackages = collect ( json_decode ( $ response , true ) ) ; return collect ( $ this -> rawPackages -> get ( 'results' ) ) ; }
7034	protected function saveMigration ( array $ tables ) { try { $ tables = serialize ( $ tables ) ; return Db :: query ( "insert into migrations(host, tables) values(?, ?)" , [ gethostname ( ) , $ tables ] , $ this -> dbName , false ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
9532	private function preloadAliases ( ) { foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { foreach ( $ this -> parameterCluster -> prefixes [ $ prefix ] as $ parameterClosure ) { foreach ( $ parameterClosure -> aliases as $ prefix => $ alias ) { $ aliasClosure = new ParameterClosure ( $ prefix , $ alias , $ parameterClosure -> parameterClosure ) ; $ aliasClosure -> parent = $ parameterClosure ; $ this -> parameterCluster -> add ( $ aliasClosure ) ; } } } }
12765	public function addByHttpCode ( int $ code ) : self { $ serverProtocol = filter_input ( \ INPUT_SERVER , 'SERVER_PROTOCOL' , \ FILTER_SANITIZE_STRING ) ; $ protocol = ! empty ( $ serverProtocol ) ? $ serverProtocol : 'HTTP/1.1' ; $ sHeader = "{$protocol} {$code} " . self :: getHTTPExplanationByCode ( $ code ) ; return $ this -> add ( $ sHeader ) ; }
12903	private function createCacheAdapter ( ) { $ extraData = & $ this -> extraData ; return new CallbackAdapter ( function ( Request $ request ) use ( & $ extraData ) { $ poolName = 'default' ; if ( isset ( $ this -> source [ 'cache' ] [ 'pool' ] ) ) { $ poolName = $ this -> source [ 'cache' ] [ 'pool' ] ; } $ adapter = new CacheAdapter ( $ this -> registry -> getCachePool ( $ poolName ) , new HttpApiAdapter ( ) , function ( Request $ request ) { $ data = $ request -> getData ( ) ; return $ this -> registry -> generateCacheItemKey ( sprintf ( '%s.%s.%s' , $ data [ 'service' ] , $ data [ 'group' ] , $ data [ 'action' ] ) , $ data [ 'arguments' ] ) ; } ) ; $ response = $ adapter -> receive ( $ request ) ; $ extraData = $ response -> getHeaders ( ) ; return $ response ; } ) ; }
9095	public function validate ( ) { hypePrototyper ( ) -> prototype -> saveStickyValues ( $ this -> action ) ; $ valid = true ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } $ validation = $ field -> validate ( $ this -> entity ) ; hypePrototyper ( ) -> prototype -> setFieldValidationStatus ( $ this -> action , $ field -> getShortname ( ) , $ validation ) ; if ( ! $ validation -> isValid ( ) ) { $ valid = false ; } } if ( ! $ valid ) { throw new \ hypeJunction \ Exceptions \ ActionValidationException ( "Invalid input" ) ; } hypePrototyper ( ) -> prototype -> clearStickyValues ( $ this -> action ) ; return true ; }
9031	public function execute ( Closure $ callback ) { foreach ( $ this -> getServices ( ) as $ service ) { try { return $ callback ( $ this -> container -> make ( $ service ) ) ; } catch ( Exception $ e ) { } } throw new RuntimeException ( 'Could not execute any service.' ) ; }
1383	protected function dataGet ( $ key , $ default = null ) { if ( ! isset ( $ this -> document -> data ) ) { return $ default ; } return data_get ( $ this -> document -> data , $ key , $ default ) ; }
7243	public function description ( ) { $ default = Inform_About_Content :: default_opt_in ( NULL ) ; $ subscribed_by_default = apply_filters ( 'iac_default_opt_in' , $ default ) ; $ description = $ subscribed_by_default ? __ ( 'Note: Users must opt-out from e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) : __ ( 'Note: Users must opt-in to e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) ; printf ( '<p class="description">%s</p>' , $ description ) ; }
1911	protected function getType ( ) : string { if ( isset ( $ this -> options [ 'type' ] ) ) { return $ this -> options [ 'type' ] ; } $ className = ltrim ( strrchr ( static :: class , '\\' ) , '\\' ) ; if ( 'Controller' === substr ( $ className , - 10 ) ) { $ className = substr ( $ className , 0 , - 10 ) ; } return Container :: underscore ( $ className ) ; }
3364	public function flush ( $ args , $ assoc_args ) { self :: apache_modules ( ) ; if ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) && ! in_array ( 'mod_rewrite' , ( array ) WP_CLI :: get_config ( 'apache_modules' ) , true ) ) { WP_CLI :: warning ( 'Regenerating a .htaccess file requires special configuration. See usage docs.' ) ; } if ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) && is_multisite ( ) ) { WP_CLI :: warning ( "WordPress can't generate .htaccess file for a multisite install." ) ; } self :: check_skip_plugins_themes ( ) ; flush_rewrite_rules ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) ) ; if ( ! get_option ( 'rewrite_rules' ) ) { WP_CLI :: warning ( "Rewrite rules are empty, possibly because of a missing permalink_structure option. Use 'wp rewrite list' to verify, or 'wp rewrite structure' to update permalink_structure." ) ; } else { WP_CLI :: success ( 'Rewrite rules flushed.' ) ; } }
2908	public function decodeSubject ( $ subject ) { if ( $ this -> hasQueue ( ) && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageParameters ( 'subject' ) ; } return base64_decode ( substr ( $ subject , strlen ( '=?utf-8?B?' ) , - 1 * strlen ( '?=' ) ) ) ; }
12794	public function delete ( $ id ) { try { $ response = $ this -> client -> request -> delete ( $ this -> apiEndpoint . "/droplets/$id" ) ; $ status = $ this -> client -> getStatus ( $ response ) ; if ( 204 != $ status ) { throw new Exception ( 'Digital Ocean responded that it could not delete it.' ) ; } return $ status ; } catch ( Exception $ e ) { echo 'Unable to delete server because ' . $ e -> getMessage ( ) ; } }
616	public function setDefinitions ( array $ definitions ) { foreach ( $ definitions as $ class => $ definition ) { if ( is_array ( $ definition ) && count ( $ definition ) === 2 && array_values ( $ definition ) === $ definition ) { $ this -> set ( $ class , $ definition [ 0 ] , $ definition [ 1 ] ) ; continue ; } $ this -> set ( $ class , $ definition ) ; } }
6624	public function process ( Request $ request ) : Response { $ router = $ request -> attributes -> get ( 'router' ) ; $ next = next ( $ this -> middlewareStack ) ; if ( $ next instanceof Middleware ) { $ router -> log ( "Router: Calling Middleware: %s" , get_class ( $ next ) ) ; $ response = $ next -> process ( $ request , $ this ) ; $ router -> log ( "Router: Leaving Middleware: %s" , get_class ( $ next ) ) ; return $ response ; } elseif ( is_string ( $ next ) ) { $ router -> log ( "Router: Calling Middleware: %s" , $ next ) ; $ response = $ router -> getMiddleware ( $ next ) -> process ( $ request , $ this ) ; $ router -> log ( "Router: Leaving Middleware: %s" , $ next ) ; return $ response ; } else { $ params = $ request -> attributes -> get ( 'controller' ) ; $ router -> log ( "Router: Calling Controller: %s@%s" , $ params -> className , $ params -> method ) ; $ return = ( new $ params -> className ( $ params -> container ) ) -> { $ params -> method } ( $ request , ... array_values ( $ params -> args ) ) ; $ router -> log ( "Router: Controller Left" ) ; if ( $ return instanceof Response ) { return $ return ; } if ( is_array ( $ return ) or is_object ( $ return ) ) { return new JsonResponse ( $ return , Response :: HTTP_OK , array ( 'content-type' => 'application/json' ) ) ; } return new Response ( $ return , Response :: HTTP_OK , array ( 'content-type' => 'text/html' ) ) ; } }
2861	public function getRange ( $ logFile ) { if ( ! array_key_exists ( $ logFile , $ this -> ranges ) ) { throw new Exception ( 'Invalid log file' ) ; } return $ this -> ranges [ $ logFile ] ; }
7320	public function diff ( AstroDate $ b ) { $ prec = 12 ; $ jd1 = $ this -> toJD ( $ prec ) ; $ jd2 = $ b -> toJD ( $ prec ) ; $ days = bcsub ( $ jd1 , $ jd2 , $ prec ) ; return Time :: days ( - 1 * $ days ) ; }
2115	private function getFieldValue ( ? PageModel $ page ) : string { if ( null === $ page ) { return '' ; } return ( string ) $ page -> { $ this -> field } ; }
4682	private static function formatTime ( float $ value , $ format ) : string { switch ( $ format ) { case static :: FORMAT_PRECISE : return ( string ) ( $ value * 1000 ) ; case static :: FORMAT_MILLISECONDS : return ( string ) round ( $ value * 1000 , 2 ) ; case static :: FORMAT_SECONDS : return ( string ) round ( $ value , 3 ) ; default : return ( string ) ( $ value * 1000 ) ; } }
8645	private function parseHttpHeader ( $ header ) { $ parsedHeader = array ( ) ; foreach ( explode ( "\n" , $ header ) as $ line ) { $ splitLine = preg_split ( '/:\s/' , $ line , 2 , PREG_SPLIT_NO_EMPTY ) ; if ( sizeof ( $ splitLine ) == 2 ) { $ k = strtolower ( trim ( $ splitLine [ 0 ] ) ) ; $ v = trim ( $ splitLine [ 1 ] ) ; if ( array_key_exists ( $ k , $ parsedHeader ) ) { $ parsedHeader [ $ k ] = $ parsedHeader [ $ k ] . "," . $ v ; } else { $ parsedHeader [ $ k ] = $ v ; } } } return $ parsedHeader ; }
5488	public function submit ( $ additional = false ) { $ encoding = $ this -> encode ( ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; }
12796	public function clear ( $ queue ) { $ this -> client -> request -> post ( $ this -> apiEndpoint . '/projects/' . $ this -> params [ 'project' ] . '/queues/' . $ queue . '/clear' ) ; }
6600	public function unlinkFiles ( $ fileName ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ fileName ) { if ( @ file_exists ( $ folder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ fileName ) ; } if ( @ file_exists ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ; } if ( is_array ( $ this -> sizes ) ) { $ i = 0 ; foreach ( $ this -> sizes as $ size ) { if ( @ file_exists ( $ folder . '/' . $ i . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ i . '/' . $ fileName ) ; } $ i ++ ; } } } }
3819	private function checkboxCaption ( $ key , $ table , IAttribute $ attribute ) { return $ this -> translator -> trans ( $ table . '.' . $ key , [ $ attribute -> getName ( ) ] , 'contao_' . $ table ) ; }
1451	protected function validatorForDelete ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> createValidator ( $ data , $ rules , $ messages , $ customAttributes ) ; }
2752	public function processBlockedItems ( $ strippedBlockedItems , $ blockingType = null ) { if ( empty ( $ blockingType ) ) { $ blockingType = $ this -> _scopeConfig -> getValue ( self :: XML_FASTLY_BLOCKING_TYPE ) ; } if ( $ blockingType == '1' ) { $ strippedBlockedItems = '!(' . $ strippedBlockedItems . ')' ; } return $ strippedBlockedItems ; }
8438	public function setPostLink ( TimelineLinkEvent $ event ) : void { $ action = $ event -> getAction ( ) ; if ( ! in_array ( $ action -> getVerb ( ) , [ 'post' , 'reply' ] ) ) { return ; } $ production = $ action -> getComponent ( 'indirectComplement' ) -> getData ( ) ; $ post = $ action -> getComponent ( 'directComplement' ) -> getData ( ) ; $ event -> setLink ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) , '_fragment' => 'post-' . $ post -> getId ( ) , ] ) ) ; }
5645	public function shouldInvoke ( $ test_case_name , $ method ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { if ( ! $ this -> reporters [ $ i ] -> shouldInvoke ( $ test_case_name , $ method ) ) { return false ; } } return true ; }
4685	public function select ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> select = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'select' ] = $ args ; return $ this ; }
8522	public function setGlobalSellingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GlobalSellingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1796	private function addIndexRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/' , $ defaults ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_index' , $ route ) ; }
11496	public static function end ( ) { if ( self :: $ startTime ) { $ time = round ( ( microtime ( true ) - self :: $ startTime ) , 4 ) ; self :: $ startTime = false ; } return ( isset ( $ time ) ) ? $ time : false ; }
8598	public function createSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_CreateSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CreateSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_CreateSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CreateSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_CreateSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1766	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } $ response = $ event -> getResponse ( ) ; if ( 200 !== $ response -> getStatusCode ( ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ this -> storeBackendReferer ( $ request ) ; } else { $ this -> storeFrontendReferer ( $ request ) ; } }
9751	public function set_images ( $ post_id ) { if ( ! $ post_id || is_null ( $ post_id ) ) { return 0 ; } update_post_meta ( $ post_id , 'custom_images_grifus' , 'true' ) ; $ count = 0 ; $ tmdb = 'image.tmdb.org' ; $ poster = get_post_meta ( $ post_id , 'poster_url' , true ) ; if ( filter_var ( $ poster , FILTER_VALIDATE_URL ) && strpos ( $ poster , $ tmdb ) ) { $ count ++ ; $ poster = WP_Image :: save ( $ poster , $ post_id , true ) ; update_post_meta ( $ post_id , 'poster_url' , $ poster ) ; } $ main = get_post_meta ( $ post_id , 'fondo_player' , true ) ; if ( filter_var ( $ main , FILTER_VALIDATE_URL ) && strpos ( $ main , $ tmdb ) ) { $ count ++ ; $ main = WP_Image :: save ( $ main , $ post_id ) ; update_post_meta ( $ post_id , 'fondo_player' , $ main ) ; } $ images = get_post_meta ( $ post_id , 'imagenes' , true ) ; $ images_array = explode ( "\n" , $ images ) ; $ new_images = '' ; foreach ( $ images_array as $ image ) { $ image = trim ( $ image ) ; if ( filter_var ( $ image , FILTER_VALIDATE_URL ) && strpos ( $ image , $ tmdb ) ) { $ count ++ ; $ url = WP_Image :: save ( $ image , $ post_id ) ; $ new_images .= $ url . "\n" ; } } if ( ! empty ( $ new_images ) ) { update_post_meta ( $ post_id , 'imagenes' , $ new_images ) ; } return $ count ; }
2050	public function findBy ( $ strColumn , $ varValue ) { if ( parent :: findBy ( $ strColumn , $ varValue ) === false ) { return false ; } $ this -> arrGroups = $ this -> groups ; return true ; }
571	public function generatePasswordHash ( $ password , $ cost = null ) { if ( $ cost === null ) { $ cost = $ this -> passwordHashCost ; } if ( function_exists ( 'password_hash' ) ) { return password_hash ( $ password , PASSWORD_DEFAULT , [ 'cost' => $ cost ] ) ; } $ salt = $ this -> generateSalt ( $ cost ) ; $ hash = crypt ( $ password , $ salt ) ; if ( ! is_string ( $ hash ) || strlen ( $ hash ) !== 60 ) { throw new Exception ( 'Unknown error occurred while generating hash.' ) ; } return $ hash ; }
8069	public function bind ( $ username , $ password ) { if ( $ this -> tls ) { if ( ! ldap_start_tls ( $ this -> connection ) ) { throw new ConnectionException ( 'Unable to Connect to LDAP using TLS.' ) ; } } try { $ this -> bound = ldap_bind ( $ this -> connection , $ username , $ password ) ; } catch ( ErrorException $ e ) { $ this -> bound = false ; } return $ this -> bound ; }
8509	public function getPrepInstructionsForSKU ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForSKU' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForSKUResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6970	protected function calculateShipmentLine ( Model \ DocumentLineInterface $ line , Amount $ final ) : Amount { if ( $ line -> getType ( ) !== Model \ DocumentLineTypes :: TYPE_SHIPMENT ) { throw new LogicException ( sprintf ( "Expected document line with type '%s'." , Model \ DocumentLineTypes :: TYPE_SHIPMENT ) ) ; } $ sale = $ line -> getDocument ( ) -> getSale ( ) ; $ result = $ this -> calculator -> calculateSaleShipment ( $ sale , $ final ) ; if ( null === $ result ) { throw new LogicException ( "Unexpected document shipment line." ) ; } $ this -> syncLineWithResult ( $ line , $ result ) ; return $ result ; }
1177	public function make ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , $ selector = null ) { $ validator = $ this -> getValidatorInstance ( $ rules , $ messages , $ customAttributes ) ; return $ this -> validator ( $ validator , $ selector ) ; }
4461	private function handleChildErrors ( & $ socket ) : Closure { $ reserved = str_repeat ( '*' , 32 * 1024 ) ; return function ( ) use ( & $ reserved , & $ socket ) : void { unset ( $ reserved ) ; $ error = error_get_last ( ) ; if ( $ error === null ) { unset ( $ reserved ) ; return ; } $ handler = new ErrorFormatter ( ) ; if ( $ handler -> constant ( $ error [ 'type' ] ) === null ) { $ this -> logger -> warning ( '{type}: Unable to recognize error type. Skip sending error to master: {message}' , $ this -> logContext + [ 'message' => $ error [ 'message' ] ] ) ; return ; } if ( is_resource ( $ socket ) == false ) { $ this -> logger -> warning ( '{type}: supplied resource is not a valid socket resource. Skip sending error to master: {message}' , $ this -> logContext + [ 'message' => $ error [ 'message' ] ] ) ; return ; } $ this -> logger -> debug ( '{type}: sending error to master' , $ this -> logContext ) ; $ data = serialize ( $ error ) ; do { $ len = socket_write ( $ socket , $ data ) ; if ( $ len === false || $ len === 0 ) { break ; } $ data = substr ( $ data , $ len ) ; } while ( is_numeric ( $ len ) && $ len > 0 && is_resource ( $ socket ) ) ; } ; }
1851	public function generate ( $ rootPageId , $ blnReturn = false , $ blnPreferAlias = false ) { if ( ! $ blnReturn ) { $ this -> redirect ( $ this -> getRedirectUrl ( $ rootPageId ) , 302 ) ; } $ objNextPage = $ this -> getNextPage ( $ rootPageId ) ; return ( $ blnPreferAlias && $ objNextPage -> alias != '' ) ? $ objNextPage -> alias : $ objNextPage -> id ; }
9587	protected function getAttribute ( SimpleXmlElement $ node , $ name ) { $ attributes = $ node -> attributes ( ) ; return ( string ) $ attributes [ $ name ] ; }
10075	public static function controlCharacterOOXML2PHP ( $ value ) { self :: buildCharacterSets ( ) ; return str_replace ( array_keys ( self :: $ controlCharacters ) , array_values ( self :: $ controlCharacters ) , $ value ) ; }
9578	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; if ( $ this -> materializeAsset ) { MaterializeAsset :: register ( $ view ) ; } if ( $ this -> customAsset ) { MaterializeCustomAsset :: register ( $ view ) ; } $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } $ this -> registerClientEvents ( ) ; }
2466	protected function welcomeScreen ( ) { System :: loadLanguageFile ( 'explain' ) ; $ objTemplate = new BackendTemplate ( 'be_welcome' ) ; $ objTemplate -> messages = Message :: generateUnwrapped ( ) . Backend :: getSystemMessages ( ) ; $ objTemplate -> loginMsg = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'firstLogin' ] ; if ( $ this -> User -> lastLogin > 0 ) { $ formatter = new DateTimeFormatter ( System :: getContainer ( ) -> get ( 'translator' ) ) ; $ diff = $ formatter -> formatDiff ( new \ DateTime ( date ( 'Y-m-d H:i:s' , $ this -> User -> lastLogin ) ) , new \ DateTime ( ) ) ; $ objTemplate -> loginMsg = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lastLogin' ] [ 1 ] , '<time title="' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ this -> User -> lastLogin ) . '">' . $ diff . '</time>' ) ; } Versions :: addToTemplate ( $ objTemplate ) ; $ objTemplate -> showDifferences = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) ) ; $ objTemplate -> recordOfTable = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] ) ) ; $ objTemplate -> systemMessages = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'systemMessages' ] ; $ objTemplate -> shortcuts = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 0 ] ; $ objTemplate -> shortcutsLink = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 1 ] ; $ objTemplate -> editElement = StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editElement' ] ) ; return $ objTemplate -> parse ( ) ; }
3343	public function createLocalCopy ( $ source , $ store = true ) { $ data = $ this -> __preparedRequest ( 'file_copy' , 'POST' , array ( ) , array ( 'source' => $ source , 'store' => $ store ) ) ; if ( array_key_exists ( 'result' , ( array ) $ data ) == true ) { if ( $ data -> type == 'file' ) { return new File ( ( string ) $ data -> result -> uuid , $ this ) ; } else { return ( string ) $ data -> result ; } } else { return ( string ) $ data -> detail ; } }
6554	public function removeLineFromFile ( $ line , $ fh ) { $ lines = array ( ) ; $ found = false ; rewind ( $ fh ) ; while ( ( $ buffer = fgets ( $ fh , 4096 ) ) !== false ) { $ buffer = trim ( $ buffer ) ; if ( $ line === $ buffer ) { $ found = true ; continue ; } $ lines [ ] = $ buffer ; } if ( ! $ found ) { throw new LineNotFoundException ( sprintf ( 'Line %s can not be found' , $ line ) ) ; } ftruncate ( $ fh , 0 ) ; rewind ( $ fh ) ; foreach ( $ lines as $ ln ) { if ( fwrite ( $ fh , $ ln . PHP_EOL ) === false ) { throw new \ Exception ( sprintf ( 'Can\'t write %s to file' , $ ln ) ) ; } } }
11889	public function paginate ( ) { $ model = $ this -> model ; if ( property_exists ( $ model , 'order' ) ) { $ paginator = $ model :: orderBy ( $ model :: $ order , $ model :: $ sort ) -> paginate ( $ model :: $ paginate , $ model :: $ index ) ; } else { $ paginator = $ model :: paginate ( $ model :: $ paginate , $ model :: $ index ) ; } if ( ! $ this -> isPageInRange ( $ paginator ) && ! $ this -> isFirstPage ( $ paginator ) ) { throw new NotFoundHttpException ( ) ; } if ( $ paginator -> getTotal ( ) ) { $ this -> paginateLinks = $ paginator -> links ( ) ; } return $ paginator ; }
3025	public function postRequest ( $ path , $ options , $ addApiKey ) { if ( isset ( $ options [ 'source' ] ) && is_array ( $ options [ 'source' ] ) ) { $ sources = $ options [ 'source' ] ; unset ( $ options [ 'source' ] ) ; foreach ( $ sources as $ i => $ source ) { $ options [ "source[$i]" ] = $ source ; } } $ response = $ this -> makeRequest ( 'POST' , $ path , $ options , $ addApiKey ) ; return $ this -> parseResponse ( $ response ) ; }
12967	public function getObjectType ( ) { if ( is_null ( $ this -> _objectType ) && isset ( $ this -> object ) ) { $ this -> _objectType = $ this -> object -> objectType -> systemId ; } return $ this -> _objectType ; }
11416	private function saveLog ( $ operId , $ calcId ) { $ entity = new ELogOper ( ) ; $ entity -> setOperId ( $ operId ) ; $ entity -> setCalcId ( $ calcId ) ; $ this -> daoLogOper -> create ( $ entity ) ; }
2943	public function hasRoleWithPermission ( $ permission ) { return $ this -> roles -> contains ( function ( $ role ) use ( $ permission ) { return $ role -> getPermissions -> contains ( 'permission_slug' , $ permission ) ; } ) ; }
3994	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'name_langcode' , 'tl_metamodel_dcasetting' ) , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'name_value' , 'tl_metamodel_dcasetting' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( 'legendtitle' ) , true ) ) ; }
6645	public static function formatPhoneNumberToInternationalFormat ( $ countryCode , $ number , $ numberLength ) { $ actualNumber = substr ( $ number , - ( $ numberLength ) , $ numberLength ) ; if ( ! $ actualNumber ) { return $ number ; } return '+' . $ countryCode . $ actualNumber ; }
7933	public function loadFromArray ( array $ data ) { list ( $ data ) = $ this -> fireEvent ( 'load-from-array' , [ $ data ] ) ; $ files = [ ] ; if ( isset ( $ data [ 'files' ] [ 'js' ] ) && is_array ( $ data [ 'files' ] [ 'js' ] ) ) $ files [ 'js' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'js' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; if ( isset ( $ data [ 'files' ] [ 'css' ] ) && is_array ( $ data [ 'files' ] [ 'css' ] ) ) $ files [ 'css' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'css' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; $ item = [ 'order' => isset ( $ data [ 'order' ] ) ? $ data [ 'order' ] : 0 , 'name' => isset ( $ data [ 'name' ] ) ? $ data [ 'name' ] : uniqid ( ) , 'files' => $ files , 'group' => isset ( $ data [ 'group' ] ) ? $ data [ 'group' ] : $ this -> defaultGroup , 'require' => isset ( $ data [ 'require' ] ) ? $ data [ 'require' ] : [ ] ] ; if ( isset ( $ item [ 'files' ] [ 'js' ] ) && is_array ( $ item [ 'files' ] [ 'js' ] ) ) $ item [ 'files' ] [ 'js' ] = $ this -> applyNamespaces ( $ item [ 'files' ] [ 'js' ] ) ; if ( isset ( $ item [ 'files' ] [ 'css' ] ) && is_array ( $ item [ 'files' ] [ 'css' ] ) ) $ item [ 'files' ] [ 'css' ] = $ this -> applyNamespaces ( $ item [ 'files' ] [ 'css' ] ) ; $ this -> loaded [ ] = $ item ; if ( isset ( $ item [ 'require' ] ) && is_array ( $ item [ 'require' ] ) ) { foreach ( $ item [ 'require' ] as $ name ) { $ this -> loadFromCollection ( $ name ) ; } } return $ this ; }
1684	public function checkAdminStatus ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == '' && $ this -> User -> id == $ dc -> id ) { $ varValue = 1 ; } return $ varValue ; }
12135	public function show ( QuestionRequest $ request , Question $ question ) { if ( $ question -> exists ) { $ view = 'forum::question.show' ; } else { $ view = 'forum::question.new' ; } return $ this -> response -> title ( trans ( 'app.view' ) . ' ' . trans ( 'forum::question.name' ) ) -> data ( compact ( 'question' ) ) -> view ( $ view , true ) -> output ( ) ; }
2236	public function generate ( $ blnNoMarkup = false ) { if ( TL_MODE == 'FE' && ! BE_USER_LOGGED_IN && ( ! $ this -> published || ( $ this -> start != '' && $ this -> start > time ( ) ) || ( $ this -> stop != '' && $ this -> stop < time ( ) ) ) ) { return '' ; } $ this -> type = 'article' ; $ this -> blnNoMarkup = $ blnNoMarkup ; if ( System :: getContainer ( ) -> has ( 'fos_http_cache.http.symfony_response_tagger' ) ) { $ responseTagger = System :: getContainer ( ) -> get ( 'fos_http_cache.http.symfony_response_tagger' ) ; $ responseTagger -> addTags ( array ( 'contao.db.tl_article.' . $ this -> id ) ) ; } return parent :: generate ( ) ; }
5057	private function getClassName ( $ requestedName ) { $ exp = explode ( '/' , $ requestedName ) ; $ className = array_shift ( $ exp ) . '\\Controller\\' . implode ( '\\' , $ exp ) . 'Controller' ; if ( ! class_exists ( $ className ) ) { throw new ServiceNotCreatedException ( sprintf ( 'Can\'t find correct controller class for "%s"' , $ requestedName ) ) ; } return $ className ; }
9303	public function setSuccessLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`successLogLifetime` expects integer value!' ) ; } $ this -> options [ 'successLogLifetime' ] = ( int ) $ time ; return $ this ; }
11393	public static function activateError ( $ iLevel ) { if ( self :: $ _bFirstActivation === true ) { self :: _setFileNameInErrorFile ( ) ; self :: $ _bFirstActivation = false ; } self :: _initLogFile ( ) ; self :: $ _bActivateError = true ; error_reporting ( $ iLevel ) ; set_error_handler ( function ( $ iErrNo , $ sErrStr , $ sErrFile , $ iErrLine ) { $ aContext = array ( 'file' => $ sErrFile , 'line' => $ iErrLine ) ; $ sType = self :: getTranslateErrorCode ( $ iErrNo ) ; self :: getInstance ( ) -> $ sType ( $ sErrStr , $ aContext ) ; return true ; } , $ iLevel ) ; register_shutdown_function ( function ( ) { if ( null !== ( $ aLastError = error_get_last ( ) ) ) { $ aContext = array ( 'file' => $ aLastError [ 'file' ] , 'line' => $ aLastError [ 'line' ] ) ; $ sType = self :: getTranslateErrorCode ( $ aLastError [ 'type' ] ) ; self :: getInstance ( ) -> $ sType ( $ aLastError [ 'message' ] , $ aContext ) ; } } ) ; }
6619	public function hasChildController ( $ controllerName ) { $ methodName = $ this -> parseControllerName ( $ controllerName ) ; return $ this -> reflection -> hasMethod ( $ methodName ) ; }
7776	protected function getRuleArgs ( $ rule ) { if ( ! $ this -> ruleHasArgs ( $ rule ) ) { return [ ] ; } list ( $ ruleName , $ argsWithBracketAtTheEnd ) = explode ( '(' , $ rule ) ; $ args = rtrim ( $ argsWithBracketAtTheEnd , ')' ) ; $ args = preg_replace ( '/\s+/' , '' , $ args ) ; $ args = explode ( ',' , $ args ) ; return $ args ; }
4734	public function write_data ( ) { $ option_key = "_wp_session_{$this->session_id}" ; if ( $ this -> dirty ) { if ( false === get_option ( $ option_key ) ) { add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; add_option ( "_wp_session_expires_{$this->session_id}" , $ this -> expires , '' , 'no' ) ; } else { delete_option ( "_wp_session_{$this->session_id}" ) ; add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; } } }
8363	public static function translate ( $ key , array $ args = array ( ) ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'locale doesn\'t seem to have been initialized' ) ; } $ oldKey = $ key ; $ section = self :: $ translations ; while ( isset ( $ section [ $ key ] ) === false && ( $ pos = strpos ( $ key , '.' ) ) !== false ) { if ( ! is_int ( $ pos ) ) { break ; } $ subSection = substr ( $ key , 0 , $ pos ) ; if ( isset ( $ section [ $ subSection ] ) === false ) { break ; } $ section = $ section [ $ subSection ] ; $ key = substr ( $ key , $ pos + 1 ) ; } if ( isset ( $ section [ $ key ] ) === false ) { Logger :: get ( ) -> error ( 'can\'t find translation for key "' . $ oldKey . '"' ) ; return '(null)' ; } return $ section [ $ key ] ; }
12608	public function getChild ( $ type ) { if ( isset ( $ this -> _children [ $ type ] ) ) { return $ this -> _children [ $ type ] ; } return false ; }
4781	public function addWidgetConfig ( string $ widgetId , array $ config = [ ] ) { $ this -> config [ $ widgetId ] = array_merge ( $ this -> config [ $ widgetId ] ?? [ ] , $ config ) ; return $ this ; }
6075	public function setStatus ( $ id , $ status ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'status' => $ status ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/status' , $ parameters ) ; return $ result ; }
6240	public static function getMimeFor ( string $ extension ) : ? string { $ extensions = static :: getExtensions ( ) ; if ( isset ( $ extensions [ $ extension ] ) ) { return $ extensions [ $ extension ] ; } return null ; }
12289	private function make ( string $ block , array $ vars = null ) : string { $ commonVars = static :: COMMON_NAME . static :: VARS_PROPERTY_SUFFIX ; $ blockVars = $ block . static :: VARS_PROPERTY_SUFFIX ; $ allVars = [ ] ; if ( isset ( $ this -> $ commonVars ) && is_array ( $ this -> $ commonVars ) ) { $ allVars = $ this -> $ commonVars ; } if ( isset ( $ this -> $ blockVars ) && is_array ( $ this -> $ blockVars ) ) { $ allVars += $ this -> $ blockVars ; } if ( isset ( $ vars ) ) { $ allVars += $ vars ; } $ file = $ this -> path . $ this -> { $ block . static :: BLOCK_PROPERTY_SUFFIX } . '.' . static :: FILE_EXTENSION ; $ localScope = function ( $ vars , $ file ) { ob_start ( ) ; extract ( $ vars ) ; try { require $ file ; } catch ( \ Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } $ _ = isset ( $ _ ) ? str_pad ( '' , $ _ ) : '' ; return str_replace ( PHP_EOL , PHP_EOL . $ _ , PHP_EOL . ob_get_clean ( ) ) ; } ; return $ localScope ( $ allVars , $ file ) ; }
248	public function destroy ( ) { if ( $ this -> getIsActive ( ) ) { $ sessionId = session_id ( ) ; $ this -> close ( ) ; $ this -> setId ( $ sessionId ) ; $ this -> open ( ) ; session_unset ( ) ; session_destroy ( ) ; $ this -> setId ( $ sessionId ) ; } }
2404	public function asset ( $ path , $ packageName = null ) { $ url = System :: getContainer ( ) -> get ( 'assets.packages' ) -> getUrl ( $ path , $ packageName ) ; return ltrim ( $ url , '/' ) ; }
11270	public function display ( $ template , array $ vars = array ( ) ) { if ( null === ( $ path = $ this -> locator -> locate ( $ template ) ) ) { throw TemplateNotFoundException :: format ( 'The template "%s" does not exist.' , $ template ) ; } $ this -> renderInScope ( $ path , array_replace ( $ this -> getArrayCopy ( ) , $ vars ) ) ; }
1560	protected function modelKeyForField ( $ field , $ model ) { if ( isset ( $ this -> attributes [ $ field ] ) ) { return $ this -> attributes [ $ field ] ; } $ key = $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; return $ this -> attributes [ $ field ] = $ key ; }
4786	function offsetGet ( $ key ) { $ this -> access ( $ key ) ; if ( ! array_key_exists ( $ key , $ this -> row ) ) { $ this -> access ( $ key , true ) ; } return $ this -> row [ $ key ] ; }
150	public function addError ( $ model , $ attribute , $ message , $ params = [ ] ) { $ params [ 'attribute' ] = $ model -> getAttributeLabel ( $ attribute ) ; if ( ! isset ( $ params [ 'value' ] ) ) { $ value = $ model -> $ attribute ; if ( is_array ( $ value ) ) { $ params [ 'value' ] = 'array()' ; } elseif ( is_object ( $ value ) && ! method_exists ( $ value , '__toString' ) ) { $ params [ 'value' ] = '(object)' ; } else { $ params [ 'value' ] = $ value ; } } $ model -> addError ( $ attribute , $ this -> formatMessage ( $ message , $ params ) ) ; }
8529	public function listFinancialEvents ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10963	public static function getUri ( ) { $ parts = [ $ uri = self :: getScheme ( ) , '://' ] ; $ authUsername = self :: getAuthUsername ( ) ; $ authPassword = self :: getAuthPassword ( ) ; if ( $ authUsername !== null && $ authPassword !== null ) { $ parts [ ] = $ authUsername . ':' . $ authPassword . '@' ; } $ parts [ ] = self :: getHost ( ) ; $ port = self :: getPort ( ) ; if ( $ port != self :: getStandardPort ( self :: getScheme ( ) ) ) { $ parts [ ] = ':' . $ port ; } $ path = self :: getPath ( ) ; if ( $ path !== null && $ path != '' ) { $ parts [ ] = '/' . $ path ; } $ query = Input :: getQuery ( ) ; if ( is_array ( $ query ) && count ( $ query ) > 0 ) { $ queryString = [ ] ; foreach ( $ query as $ key => $ value ) { $ queryKeyValue = $ key . '=' ; if ( $ value !== null ) { if ( is_string ( $ value ) ) { $ value = urlencode ( $ value ) ; } $ queryKeyValue .= $ value ; } $ queryString [ ] = $ queryKeyValue ; } if ( count ( $ queryString ) > 0 ) { $ parts [ ] = '?' . implode ( '&' , $ queryString ) ; } } return implode ( '' , $ parts ) ; }
1058	public static function findTypesRemovedFromUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesRemovedFromUnion = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInNewUnion = [ ] ; foreach ( $ newType -> getTypes ( ) as $ type ) { $ typeNamesInNewUnion [ $ type -> name ] = true ; } foreach ( $ oldType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInNewUnion [ $ type -> name ] ) ) { continue ; } $ typesRemovedFromUnion [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_REMOVED_FROM_UNION , 'description' => sprintf ( '%s was removed from union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesRemovedFromUnion ; }
9593	public function checkboxListFilled ( $ items , $ options = [ ] ) { $ this -> addListInputCssClass ( $ options , $ this -> checkboxFilledCssClass ) ; return self :: checkboxList ( $ items , $ options ) ; }
7003	public function match ( $ test ) { $ isArray = [ ] ; $ pattern = preg_replace_callback ( "~/\{(?<arg>\w+)(?<arr>\[\])?\}(?<num>\?|\+|\*|\{[0-9,]+\})?~" , function ( $ matches ) use ( & $ isArray ) { $ name = $ matches [ "arg" ] ; $ num = $ matches [ "num" ] ?? "" ; $ isArray [ $ name ] = ! empty ( $ matches [ 2 ] ) ; return "(?<$name>(?:/[^\\s/?]+)$num)" ; } , $ this -> url ) ; if ( ! $ pattern || empty ( $ pattern ) ) { error_log ( "pattern error: found in route with pattern: {$this->url}" ) ; return false ; } $ pattern = "^$pattern/?(?:\?.*)?$" ; if ( preg_match ( "~$pattern~" , $ test , $ matches ) ) { foreach ( $ matches as $ name => $ val ) { $ val = urldecode ( $ val ) ; if ( is_int ( $ name ) ) { if ( $ name === 0 ) $ this -> args [ $ name ] = $ val ; } else { $ val = ltrim ( $ val , "/" ) ; $ this -> args [ $ name ] = $ isArray [ $ name ] ? explode ( "/" , $ val ) : $ val ; } } return true ; } return false ; }
11463	public static function exception ( $ Throwable ) { while ( @ ob_end_clean ( ) ) ; try { if ( PHP_SAPI == 'cli' ) { $ message = BaseException :: displayConsoleException ( $ Throwable ) ; if ( @ fwrite ( STDERR , $ message ) === false ) echo $ message ; } else { @ header ( "HTTP/1.1 500 Internal Server Error" ) ; @ header ( 'Content-Type: text/html' ) ; echo BaseException :: displayException ( $ Throwable ) ; } } catch ( \ Throwable $ e ) { $ class = get_class ( $ e ) ; $ message = $ e -> getMessage ( ) ; echo "Uncaught $class inside exception-handler: \"$message\"" ; } exit ( 1 ) ; }
11567	public function set ( string $ sNameOfDi , callable $ cFunction , bool $ bShared = false ) : Di { if ( $ bShared === true ) { self :: $ _aSharedDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } else { $ this -> _aDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } return $ this ; }
10884	public function report ( ErrorStreamReport $ report ) { $ report -> tags = $ this -> tags ; $ report -> context = $ this -> context ; return $ this -> makeRequest ( $ report ) ; }
472	public function insert ( $ table , $ columns ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> insert ( $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
5128	public function readQDateTime ( ) { $ day = $ this -> readUInt ( ) ; $ msec = $ this -> readUInt ( ) ; $ this -> readBool ( ) ; if ( $ day === 0 && $ msec === 0xFFFFFFFF ) { return null ; } $ time = ( $ day - 2440588 ) * 86400 + $ msec / 1000 ; $ dt = \ DateTime :: createFromFormat ( 'U.u' , sprintf ( '%.6F' , $ time ) ) ; $ dt -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; return $ dt ; }
11954	public function resetAllPropertiesExcept ( $ properties = array ( ) ) { foreach ( $ this -> obj_to_db_trans as $ obj_prop => $ db_field ) { if ( ! in_array ( $ obj_prop , $ this -> key_properties ) && ! in_array ( $ obj_prop , $ properties ) ) { $ this -> { $ obj_prop } = null ; } } }
224	protected function asIntegerStringFallback ( $ value ) { if ( empty ( $ value ) ) { $ value = 0 ; } $ value = $ this -> normalizeNumericStringValue ( ( string ) $ value ) ; $ separatorPosition = strrpos ( $ value , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ value , 0 , $ separatorPosition ) ; } else { $ integerPart = $ value ; } return $ this -> asDecimalStringFallback ( $ integerPart , 0 ) ; }
4088	protected function transformDSLSortToString ( $ dslSort ) { $ string = "" ; if ( is_array ( $ dslSort ) ) { foreach ( $ dslSort as $ sort ) { if ( is_array ( $ sort ) ) { $ field = key ( $ sort ) ; $ info = current ( $ sort ) ; } else $ field = $ sort ; $ string .= "&sort=" . $ field ; if ( isset ( $ info ) ) { if ( is_string ( $ info ) && $ info == "desc" ) $ string .= ":reverse" ; elseif ( is_array ( $ info ) && array_key_exists ( "reverse" , $ info ) && $ info [ 'reverse' ] ) $ string .= ":reverse" ; } } } return $ string ; }
1741	public function checkFilename ( $ varValue , Contao \ DataContainer $ dc ) { $ varValue = str_replace ( '"' , '' , $ varValue ) ; if ( strpos ( $ varValue , '/' ) !== false || preg_match ( '/\.$/' , $ varValue ) ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidName' ] ) ; } if ( $ dc -> activeRecord && $ varValue != '' ) { $ intMaxlength = $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'maxlength' ] ; if ( $ dc -> activeRecord -> type == 'file' ) { $ intMaxlength -= ( \ strlen ( $ dc -> activeRecord -> extension ) + 1 ) ; } if ( $ intMaxlength && Patchwork \ Utf8 :: strlen ( $ varValue ) > $ intMaxlength ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'maxlength' ] , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'label' ] [ 0 ] , $ intMaxlength ) ) ; } } return $ varValue ; }
9624	public function makeHandler ( $ ident ) { if ( ! isset ( $ this -> factories [ $ ident ] ) ) { throw new \ InvalidArgumentException ( "Unknown session handler: $ident" ) ; } return $ this -> factories [ $ ident ] ( ) ; }
10066	public function actionGenerate ( ) { $ input = $ this -> parseArguments ( func_get_args ( ) ) ; $ container = new Container ( ) ; $ container -> set ( GeneratorInterface :: class , array_merge ( [ 'class' => $ this -> generator_fqn ] , $ input [ 'generator' ] ) ) ; $ container -> set ( DbProviderInterface :: class , array_merge ( [ 'class' => $ this -> dbprovider_fqn ] , $ input [ 'dbprovider' ] ) ) ; $ this -> generator_obj = $ container -> get ( GeneratorInterface :: class ) ; if ( ! $ this -> force && ! $ this -> confirmGeneration ( ) ) { return ; } $ this -> dbprovider_obj = $ container -> get ( DbProviderInterface :: class ) ; Console :: startProgress ( 0 , $ this -> count ) ; foreach ( $ this -> dbprovider_obj -> export ( $ this -> count ) as $ count ) { Console :: updateProgress ( $ this -> count - $ count , $ this -> count ) ; } Console :: endProgress ( true ) ; }
9938	private static function checkSheetTitle ( $ pValue ) { if ( str_replace ( self :: $ invalidCharacters , '' , $ pValue ) !== $ pValue ) { throw new Exception ( 'Invalid character found in sheet title' ) ; } if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 31 ) { throw new Exception ( 'Maximum 31 characters allowed in sheet title.' ) ; } return $ pValue ; }
1880	protected function isMounted ( $ strFolder ) { if ( $ strFolder == '' ) { return false ; } if ( empty ( $ this -> arrFilemounts ) ) { return true ; } $ path = $ strFolder ; while ( \ is_array ( $ this -> arrFilemounts ) && substr_count ( $ path , '/' ) > 0 ) { if ( \ in_array ( $ path , $ this -> arrFilemounts ) ) { return true ; } $ path = \ dirname ( $ path ) ; } return false ; }
11294	public function getDataAttributes ( $ excludeExtended = false ) { $ attributes = new \ Cora \ Collection ( ) ; foreach ( $ this -> model_attributes as $ key => $ def ) { if ( ! isset ( $ def [ 'model' ] ) && ! isset ( $ def [ 'models' ] ) ) { $ attributes -> add ( $ key ) ; } } if ( isset ( $ this -> model_extends ) && isset ( $ this -> model_attributes [ $ this -> model_extends ] ) ) { $ extendedModel = $ this -> { $ this -> model_extends } ; if ( $ extendedModel ) { $ attributes -> merge ( $ extendedModel -> getDataAttributes ( ) ) ; } } return array_unique ( $ attributes -> toArray ( ) ) ; }
6946	private function getRegularDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; return $ qb -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ ex -> eq ( 'o.shipmentState' , ':shipped' ) , $ ex -> isNull ( 'o.paymentTerm' ) ) ) -> addOrderBy ( 'o.createdAt' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'shipped' , ShipmentStates :: STATE_COMPLETED ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; }
10542	public static function createFromApplication ( Application $ app ) { $ dispatch = new static ( $ app -> request , $ app -> resolver , $ app -> config ) ; $ dispatch -> setApplication ( $ app ) ; return $ dispatch ; }
8716	public static function createInLocale ( $ locale , array $ attributes = [ ] , $ translations = [ ] ) { $ model = ( new static ( $ attributes ) ) -> setLocale ( $ locale ) ; if ( $ model -> save ( ) && is_array ( $ translations ) ) { $ model -> saveTranslations ( $ translations ) ; } return $ model ; }
7822	protected function refreshPipelines ( ) { $ yaml = $ this -> parser -> dump ( $ this -> pipelines ) ; $ this -> files -> put ( $ this -> getSource ( ) , $ yaml ) ; }
1668	public function purge ( ) { $ this -> Files -> rrdir ( $ this -> strFolder , true ) ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { $ objFiles = FilesModel :: findMultipleByBasepath ( $ this -> strFolder . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objFiles -> delete ( ) ; } } Dbafs :: updateFolderHashes ( $ this -> strFolder ) ; } }
11070	public function setBoolean ( string $ key , $ value , bool $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( bool ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
8772	protected function markAsRegistered ( ServiceProvider $ provider ) { $ this -> serviceProviders [ ] = $ provider ; $ this -> loadedProviders [ get_class ( $ provider ) ] = true ; }
12242	public function asPrettyXML ( $ filepath = null ) { $ xml = dom_import_simplexml ( new SimpleXMLElement ( $ this -> asXML ( ) ) ) ; $ xsl = new DOMDocument ; $ xsl -> loadXML ( '<?xml version="1.0" encoding="utf-8"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="xml" indent="yes" /> <xsl:template match="text()"> <!-- remove everything that contains only whitespace, with at least one LF ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; $ result = trim ( $ xslt -> transformToXML ( $ xml ) ) ; if ( isset ( $ filepath ) ) { return ( bool ) file_put_contents ( $ filepath , $ result ) ; } return $ result ; }
12512	public function login ( ) { if ( $ this -> validate ( ) ) { return \ Yii :: $ app -> getUser ( ) -> login ( $ this -> user , $ this -> rememberMe ? $ this -> module -> rememberFor : 0 ) ; } else { return false ; } }
12943	public function authenticate ( AdapterInterface $ adapter = null ) { $ event = clone $ this -> getEvent ( ) ; $ event -> setName ( AuthenticationEvent :: EVENT_AUTH ) ; if ( ! $ adapter ) { $ adapter = $ this -> getAdapter ( ) ; } if ( $ adapter ) { $ event -> setAdapter ( $ adapter ) ; } $ this -> getEventManager ( ) -> trigger ( $ event ) ; return $ event -> getResult ( ) ; }
7675	function TbsStoreGet ( $ idx , $ caller ) { $ this -> LastReadNotStored = false ; if ( $ idx === $ this -> TbsCurrIdx ) { return $ this -> TBS -> Source ; } elseif ( isset ( $ this -> TbsStoreLst [ $ idx ] ) ) { $ txt = $ this -> TbsStoreLst [ $ idx ] [ 'src' ] ; if ( $ caller === false ) $ this -> TbsStoreLst [ $ idx ] [ 'src' ] = '' ; return $ txt ; } else { $ this -> LastReadNotStored = true ; $ txt = $ this -> FileRead ( $ idx , true ) ; if ( $ this -> LastReadComp > 0 ) { if ( $ caller === false ) { return $ txt ; } else { return $ this -> RaiseError ( "(" . $ caller . ") unable to uncompress '" . $ this -> TbsGetFileName ( $ idx ) . "'." ) ; } } else { return $ txt ; } } }
3936	private function setWidgetType ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getWidgetType ( ) || ! isset ( $ propInfo [ 'inputType' ] ) ) { return ; } $ property -> setWidgetType ( $ propInfo [ 'inputType' ] ) ; }
2831	public function selectSqlAction ( ) { if ( $ query = $ this -> _initQuery ( ) ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ results = $ helper -> runSql ( $ query -> getQuery ( ) , $ query -> getQueryParams ( ) ) ; $ this -> renderTable ( $ results ) ; } }
7555	function match ( $ conditions , $ match = true , $ custom_filters = array ( ) ) { $ t = isset ( $ conditions [ 'tags' ] ) ; $ a = isset ( $ conditions [ 'attributes' ] ) ; $ f = isset ( $ conditions [ 'filters' ] ) ; if ( ! ( $ t || $ a || $ f ) ) { if ( is_array ( $ conditions ) && $ conditions ) { foreach ( $ conditions as $ c ) { if ( $ this -> match ( $ c , $ match ) ) { return true ; } } } return false ; } else { if ( ( $ t && ( ! $ this -> match_tags ( $ conditions [ 'tags' ] ) ) ) === $ match ) { return false ; } if ( ( $ a && ( ! $ this -> match_attributes ( $ conditions [ 'attributes' ] ) ) ) === $ match ) { return false ; } if ( ( $ f && ( ! $ this -> match_filters ( $ conditions [ 'filters' ] , $ custom_filters ) ) ) === $ match ) { return false ; } return true ; } }
946	public function handle ( Request $ request , Closure $ next ) { $ query = $ request -> query -> all ( ) ; $ signature = $ query [ 'signature' ] ; unset ( $ query [ 'signature' ] ) ; $ signatureLocal = ShopifyApp :: createHmac ( [ 'data' => $ query , 'buildQuery' => true ] ) ; if ( $ signature !== $ signatureLocal || ! isset ( $ query [ 'shop' ] ) ) { return Response :: make ( 'Invalid proxy signature.' , 401 ) ; } Session :: put ( 'shopify_domain' , ShopifyApp :: sanitizeShopDomain ( $ request -> get ( 'shop' ) ) ) ; return $ next ( $ request ) ; }
992	public static function visitUsingRules ( Schema $ schema , TypeInfo $ typeInfo , DocumentNode $ documentNode , array $ rules ) { $ context = new ValidationContext ( $ schema , $ documentNode , $ typeInfo ) ; $ visitors = [ ] ; foreach ( $ rules as $ rule ) { $ visitors [ ] = $ rule -> getVisitor ( $ context ) ; } Visitor :: visit ( $ documentNode , Visitor :: visitWithTypeInfo ( $ typeInfo , Visitor :: visitInParallel ( $ visitors ) ) ) ; return $ context -> getErrors ( ) ; }
1971	public static function findMultipleByUuids ( $ arrUuids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || ! \ is_array ( $ arrUuids ) ) { return null ; } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { if ( Validator :: isStringUuid ( $ v ) ) { $ v = StringUtil :: uuidToBin ( $ v ) ; } $ arrUuids [ $ k ] = "UNHEX('" . bin2hex ( $ v ) . "')" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.uuid!=" . implode ( ", $t.uuid!=" , $ arrUuids ) ; } return static :: findBy ( array ( "$t.uuid IN(" . implode ( "," , $ arrUuids ) . ")" ) , null , $ arrOptions ) ; }
8219	protected function getIp ( $ config ) { $ remoteAddr = $ _SERVER [ 'REMOTE_ADDR' ] ; if ( filter_var ( $ remoteAddr , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) ) { $ netmask = ( isset ( $ config [ "netmask_IPv4" ] ) ) ? $ config [ "netmask_IPv4" ] : self :: DEFAULT_NETMASK_IPV4 ; } else { $ netmask = ( isset ( $ config [ "netmask_IPv6" ] ) ) ? $ config [ "netmask_IPv6" ] : self :: DEFAULT_NETMASK_IPV6 ; } $ ipSubnet = $ this -> getSubnet ( $ remoteAddr , $ netmask ) ; return $ ipSubnet ; }
9253	protected function getContainerInitializer ( ) { $ initializer = new DefaultInitializer ( $ this -> getConfigurationProvider ( ) ) ; if ( $ this -> cache ) { $ initializer = new CachedInitializer ( $ initializer , $ this -> getCacheDir ( ) ) ; } return $ initializer ; }
7723	public function objectToArray ( $ object , $ array = [ ] ) { $ reflectionClass = new \ ReflectionClass ( get_class ( $ object ) ) ; foreach ( $ reflectionClass -> getProperties ( ) as $ property ) { $ property -> setAccessible ( true ) ; $ name = trim ( strtolower ( preg_replace ( '/[A-Z]([A-Z](?![a-z]))*/' , '_$0' , $ property -> getName ( ) ) ) , '_' ) ; if ( empty ( $ property -> getValue ( $ object ) ) ) { continue ; } else if ( is_object ( $ property -> getValue ( $ object ) ) ) { $ array [ $ name ] = $ this -> objectToArray ( $ property -> getValue ( $ object ) ) ; } else if ( is_array ( $ property -> getValue ( $ object ) ) ) { foreach ( $ property -> getValue ( $ object ) as $ key => $ value ) { if ( is_object ( $ value ) ) { $ array [ $ name ] [ ] = $ this -> objectToArray ( $ value ) ; } } } else { $ array [ $ name ] = $ property -> getValue ( $ object ) ; } $ property -> setAccessible ( false ) ; } return $ array ; }
1769	public function __isset ( $ strKey ) { switch ( $ strKey ) { case 'id' : return isset ( $ this -> strId ) ; break ; case 'name' : return isset ( $ this -> strName ) ; break ; case 'label' : return isset ( $ this -> strLabel ) ; break ; case 'value' : return isset ( $ this -> varValue ) ; break ; case 'class' : return isset ( $ this -> strClass ) ; break ; case 'template' : return isset ( $ this -> strTemplate ) ; break ; case 'wizard' : return isset ( $ this -> strWizard ) ; break ; case 'required' : return isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; case 'forAttribute' : return isset ( $ this -> blnForAttribute ) ; break ; case 'dataContainer' : return isset ( $ this -> objDca ) ; break ; case 'activeRecord' : return isset ( $ this -> objDca -> activeRecord ) ; break ; default : return isset ( $ this -> arrAttributes [ $ strKey ] ) || isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; } }
2484	protected function getAllSearchTargets ( ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = [ ] ; $ searchTargets = $ this -> endpointResolver -> getEndpoints ( ) ; if ( ! empty ( $ searchTargets ) ) { foreach ( $ searchTargets as $ endpointName ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
2685	public function aroundDispatch ( FrontController $ subject , callable $ proceed , ... $ args ) { $ isRateLimitingEnabled = $ this -> config -> isRateLimitingEnabled ( ) ; $ isCrawlerProtectionEnabled = $ this -> config -> isCrawlerProtectionEnabled ( ) ; if ( ! $ isRateLimitingEnabled && ! $ isCrawlerProtectionEnabled ) { return $ proceed ( ... $ args ) ; } $ path = strtolower ( $ this -> request -> getPathInfo ( ) ) ; if ( $ isRateLimitingEnabled && $ this -> sensitivePathProtection ( $ path ) ) { return $ this -> response ; } if ( $ isCrawlerProtectionEnabled && $ this -> crawlerProtection ( $ path ) ) { return $ this -> response ; } return $ proceed ( ... $ args ) ; }
1348	public function allow ( string $ resourceType , array $ fields = null ) : self { $ this -> all = false ; $ this -> allowed [ $ resourceType ] = $ fields ; return $ this ; }
9032	public function loadClassMetadata ( LoadClassMetadataEventArgs $ eventArgs ) { $ this -> classMetadata = $ eventArgs -> getClassMetadata ( ) ; $ reflectionClass = $ this -> classMetadata -> getReflectionClass ( ) ; if ( null === $ reflectionClass ) { return ; } if ( $ this -> hasMethod ( $ reflectionClass , 'updateTimestamps' ) ) { $ this -> addLifecycleCallbacks ( ) ; $ this -> mapFields ( ) ; } }
8090	static public function generate ( $ uid = 0 , $ hash = false ) { if ( $ uid ) { $ e_uid = self :: encode ( $ uid ) ; $ e_uid_length = strlen ( $ e_uid ) ; $ e_uid_length = str_pad ( $ e_uid_length , 2 , 0 , STR_PAD_LEFT ) ; $ e_uid_pos = rand ( 10 , 32 - $ e_uid_length - 1 ) ; if ( ! $ hash ) { $ hash = sha1 ( uniqid ( rand ( ) , true ) ) ; } $ code = $ e_uid_pos . $ e_uid_length ; $ code .= substr ( $ hash , 0 , $ e_uid_pos - strlen ( $ code ) ) ; $ code .= $ e_uid ; $ code .= substr ( $ hash , strlen ( $ code ) ) ; return $ code ; } else { return sha1 ( uniqid ( rand ( ) , true ) ) ; } }
4927	public function setListeners ( array $ specs ) { foreach ( $ specs as $ spec ) { if ( ! isset ( $ spec [ 'event' ] ) || ! isset ( $ spec [ 'service' ] ) ) { throw new \ DomainException ( 'Listener specification must be an array with the keys "event" and "service".' ) ; } $ method = isset ( $ spec [ 'method' ] ) ? $ spec [ 'method' ] : null ; $ priority = isset ( $ spec [ 'priority' ] ) ? $ spec [ 'priority' ] : 0 ; $ this -> setListener ( $ spec [ 'event' ] , $ spec [ 'service' ] , $ method , $ priority ) ; } return $ this ; }
6492	private function getBestMediaTypeFormatterMatch ( string $ type , array $ formatters , array $ mediaTypeHeaders , string $ ioType ) : ? MediaTypeFormatterMatch { if ( count ( $ mediaTypeHeaders ) > 0 && $ mediaTypeHeaders [ 0 ] instanceof IHeaderValueWithQualityScore ) { $ mediaTypeHeaders = $ this -> rankAcceptMediaTypeHeaders ( $ mediaTypeHeaders ) ; } foreach ( $ mediaTypeHeaders as $ mediaTypeHeader ) { [ $ mediaType , $ mediaSubType ] = explode ( '/' , $ mediaTypeHeader -> getMediaType ( ) ) ; foreach ( $ formatters as $ formatter ) { foreach ( $ formatter -> getSupportedMediaTypes ( ) as $ supportedMediaType ) { if ( $ ioType === self :: FORMATTER_TYPE_INPUT && ! $ formatter -> canReadType ( $ type ) ) { continue ; } if ( $ ioType === self :: FORMATTER_TYPE_OUTPUT && ! $ formatter -> canWriteType ( $ type ) ) { continue ; } [ $ supportedType , $ supportedSubType ] = explode ( '/' , $ supportedMediaType ) ; if ( $ mediaType === '*' || ( $ mediaSubType === '*' && $ mediaType === $ supportedType ) || ( $ mediaType === $ supportedType && $ mediaSubType === $ supportedSubType ) ) { return new MediaTypeFormatterMatch ( $ formatter , $ supportedMediaType , $ mediaTypeHeader ) ; } } } } return null ; }
9218	protected function pageNumberToKey ( $ pageNumber ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { return ( $ pageNumber - 1 ) * $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getPerPage ( ) ; } return false ; }
1531	public static function create ( ValidatorInterface $ validator ) : self { $ ex = new self ( $ validator -> getErrors ( ) ) ; $ ex -> validator = $ validator ; return $ ex ; }
3874	protected function removeEmptyDetailPages ( $ jumpTos ) { foreach ( $ jumpTos as $ jumpTo ) { $ event = new GetPageDetailsEvent ( $ jumpTo [ 'value' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null ) { continue ; } $ baseUrl = $ this -> getBaseUrl ( $ pageDetails ) ; if ( ( $ strKey = array_search ( $ baseUrl -> getUrl ( ) , $ this -> foundPages ) ) !== false ) { unset ( $ this -> foundPages [ $ strKey ] ) ; } $ baseUrl = $ this -> getBaseUrl ( $ pageDetails , null , true ) ; if ( ( $ strKey = array_search ( $ baseUrl -> getUrl ( ) , $ this -> foundPages ) ) !== false ) { unset ( $ this -> foundPages [ $ strKey ] ) ; } } }
3357	public function getImgTag ( $ postfix = null , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<img src="%s" %s />' , $ this -> getUrl ( ) , join ( ' ' , $ to_compile ) ) ; }
6202	public function methodFail ( $ errors = null ) { if ( $ errors === null ) { return $ this -> methodResult ( false ) ; } if ( ! is_array ( $ errors ) ) { $ errors = [ $ errors ] ; } return $ this -> methodResult ( false , [ 'errors' => $ errors ] ) ; }
846	public function generatePartialCode ( $ start , $ end ) { $ code = '' ; for ( $ i = $ start ; $ i <= $ end ; ++ $ i ) { $ code .= $ this [ $ i ] -> getContent ( ) ; } return $ code ; }
12016	public function unwatch ( ) { if ( ! $ this -> client -> getCommandFactory ( ) -> supportsCommand ( 'UNWATCH' ) ) { throw new NotSupportedException ( 'UNWATCH is not supported by the current command factory.' ) ; } $ this -> state -> unflag ( MultiExecState :: WATCH ) ; $ this -> __call ( 'UNWATCH' , array ( ) ) ; return $ this ; }
6776	protected function updateInformation ( SaleInterface $ sale , $ persistence = false ) { $ changed = false ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( null === $ sale -> getCustomerGroup ( ) ) { $ sale -> setCustomerGroup ( $ customer -> getCustomerGroup ( ) ) ; $ changed = true ; } if ( 0 == strlen ( $ sale -> getEmail ( ) ) ) { $ sale -> setEmail ( $ customer -> getEmail ( ) ) ; $ changed = true ; } if ( 0 == strlen ( $ sale -> getGender ( ) ) ) { $ sale -> setGender ( $ customer -> getGender ( ) ) ; $ changed = true ; } if ( 0 == strlen ( $ sale -> getFirstName ( ) ) ) { $ sale -> setFirstName ( $ customer -> getFirstName ( ) ) ; $ changed = true ; } if ( 0 == strlen ( $ sale -> getLastName ( ) ) ) { $ sale -> setLastName ( $ customer -> getLastName ( ) ) ; $ changed = true ; } if ( 0 == strlen ( $ sale -> getCompany ( ) ) && 0 < strlen ( $ customer -> getCompany ( ) ) ) { $ sale -> setCompany ( $ customer -> getCompany ( ) ) ; $ changed = true ; } $ changed |= $ this -> updateVatData ( $ sale ) ; if ( null === $ sale -> getInvoiceAddress ( ) && null !== $ address = $ customer -> getDefaultInvoiceAddress ( true ) ) { $ changed |= $ this -> saleUpdater -> updateInvoiceAddressFromAddress ( $ sale , $ address , $ persistence ) ; } if ( $ sale -> isSameAddress ( ) ) { if ( null !== $ address = $ sale -> getDeliveryAddress ( ) ) { $ sale -> setDeliveryAddress ( null ) ; if ( $ persistence ) { $ this -> persistenceHelper -> remove ( $ address , true ) ; } } } else if ( null === $ sale -> getDeliveryAddress ( ) && null !== $ address = $ customer -> getDefaultDeliveryAddress ( ) ) { $ changed |= $ this -> saleUpdater -> updateDeliveryAddressFromAddress ( $ sale , $ address , $ persistence ) ; } } $ changed |= $ this -> updateVatDisplayMode ( $ sale ) ; return $ changed ; }
5138	public static function handleException ( \ Throwable $ e ) { if ( php_sapi_name ( ) == 'cli' ) { $ handler = new ConsoleHandler ( self :: $ output ) ; } else { $ handler = new HtmlHandler ( HtmlHandler :: INVERTED ) ; } fwrite ( self :: $ output , $ handler -> renderException ( $ e , AbstractHandler :: VERBOSITY_VERBOSE ) ) ; }
5786	private function databaseRecordNotFound ( Response $ response , $ primaryKey , TableMapper $ tableMapper , string $ routeAction , ? string $ title = null ) { if ( $ routeAction != 'update' && $ routeAction != 'delete' ) { throw new \ Exception ( "routeAction $routeAction must be update or delete" ) ; } $ this -> events -> insertWarning ( EVENT_QUERY_NO_RESULTS , [ $ tableMapper -> getPrimaryKeyColumnName ( ) => $ primaryKey , 'table' => $ tableMapper -> getTableName ( ) ] ) ; $ noticeTitle = ( $ title != null ) ? $ title : 'Record' ; SlimPostgres :: setAdminNotice ( "$noticeTitle $primaryKey Not Found" , 'failure' ) ; return $ response -> withRedirect ( $ this -> router -> pathFor ( SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ) ) ; }
7932	public function load ( $ data ) { list ( $ data ) = $ this -> fireEvent ( 'load' , [ $ data ] ) ; if ( is_array ( $ data ) ) { $ this -> loadFromArray ( $ data ) ; } else { $ this -> loadFromCollection ( $ data ) ; } return $ this ; }
3091	public function store ( $ data ) { $ this -> cache [ $ this -> testSessionId ] = & $ data ; $ encodedData = $ this -> getStorageFormat ( ) -> encode ( $ data ) ; $ this -> getStorageService ( ) -> set ( $ this -> getUserKey ( ) , $ this -> getStorageKey ( ) , $ encodedData ) ; \ common_Logger :: d ( sprintf ( 'QtiTimer: Stored %d bytes into state storage' , strlen ( $ encodedData ) ) ) ; return $ this ; }
6809	public function currency ( float $ number , string $ currency = null ) : string { return $ this -> getCurrencyFormatter ( ) -> formatCurrency ( $ number , $ currency ? $ currency : $ this -> currency ) ; }
10475	public function listen ( string $ event , callable $ callback ) : EventChannelInterface { $ this -> channel -> listen ( $ event , $ callback ) ; return $ this ; }
930	public function transform ( Tokens $ tokens ) { foreach ( $ this -> items as $ transformer ) { foreach ( $ tokens as $ index => $ token ) { $ transformer -> process ( $ tokens , $ token , $ index ) ; } } }
2141	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof User ) { return ; } $ sessionBag = $ this -> getSessionBag ( $ event -> getRequest ( ) ) ; $ data = $ sessionBag -> all ( ) ; $ this -> connection -> update ( $ user -> getTable ( ) , [ 'session' => serialize ( $ data ) ] , [ 'id' => $ user -> id ] ) ; }
2955	public function PhpSerial ( ) { setlocale ( LC_ALL , "en_US" ) ; $ sysName = php_uname ( ) ; if ( substr ( $ sysName , 0 , 5 ) === "Linux" ) { $ this -> _os = "linux" ; if ( $ this -> _exec ( "stty" ) === 0 ) { register_shutdown_function ( array ( $ this , "deviceClose" ) ) ; } else { trigger_error ( "No stty availible, unable to run." , E_USER_ERROR ) ; } } elseif ( substr ( $ sysName , 0 , 6 ) === "Darwin" ) { $ this -> _os = "osx" ; register_shutdown_function ( array ( $ this , "deviceClose" ) ) ; } elseif ( substr ( $ sysName , 0 , 7 ) === "Windows" ) { $ this -> _os = "windows" ; register_shutdown_function ( array ( $ this , "deviceClose" ) ) ; } else { trigger_error ( "Host OS is neither osx, linux nor windows, unable " . "to run." , E_USER_ERROR ) ; exit ( ) ; } }
6781	protected function updateLocale ( SaleInterface $ sale ) { if ( null !== $ sale -> getLocale ( ) ) { return false ; } $ sale -> setLocale ( $ this -> localeProvider -> getCurrentLocale ( ) ) ; return true ; }
1045	public static function createFromException ( $ e , $ debug = false , $ internalErrorMessage = null ) { Utils :: invariant ( $ e instanceof Exception || $ e instanceof Throwable , 'Expected exception, got %s' , Utils :: getVariableType ( $ e ) ) ; $ internalErrorMessage = $ internalErrorMessage ? : self :: $ internalErrorMessage ; if ( $ e instanceof ClientAware ) { $ formattedError = [ 'message' => $ e -> isClientSafe ( ) ? $ e -> getMessage ( ) : $ internalErrorMessage , 'extensions' => [ 'category' => $ e -> getCategory ( ) , ] , ] ; } else { $ formattedError = [ 'message' => $ internalErrorMessage , 'extensions' => [ 'category' => Error :: CATEGORY_INTERNAL , ] , ] ; } if ( $ e instanceof Error ) { $ locations = Utils :: map ( $ e -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ formattedError [ 'locations' ] = $ locations ; } if ( ! empty ( $ e -> path ) ) { $ formattedError [ 'path' ] = $ e -> path ; } if ( ! empty ( $ e -> getExtensions ( ) ) ) { $ formattedError [ 'extensions' ] = $ e -> getExtensions ( ) + $ formattedError [ 'extensions' ] ; } } if ( $ debug ) { $ formattedError = self :: addDebugEntries ( $ formattedError , $ e , $ debug ) ; } return $ formattedError ; }
8511	public function listInboundShipmentItems ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentItemsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentItemsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentItems' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentItemsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3914	protected function sortByName ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } \ uasort ( $ arrFiles , ( $ blnAscending ) ? '\basename_natcasecmp' : '\basename_natcasercmp' ) ; return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; }
1781	public static function isInsecurePath ( $ strPath ) { $ strPath = strtr ( $ strPath , '\\' , '/' ) ; $ strPath = preg_replace ( '#//+#' , '/' , $ strPath ) ; if ( $ strPath == '..' ) { return true ; } if ( substr ( $ strPath , 0 , 2 ) == './' ) { return true ; } if ( substr ( $ strPath , 0 , 3 ) == '../' ) { return true ; } if ( substr ( $ strPath , - 2 ) == '/.' ) { return true ; } if ( substr ( $ strPath , - 3 ) == '/..' ) { return true ; } if ( strpos ( $ strPath , '/../' ) !== false ) { return true ; } return false ; }
6425	public function getLoginStartUrl ( $ redirecturl ) { $ client = $ this -> getClient ( $ redirecturl ) ; $ authUrl = $ client -> createAuthUrl ( ) ; return $ authUrl ; }
11464	public static function error ( $ severity , $ message , $ file , $ line ) { if ( error_reporting ( ) == 0 ) return ; elseif ( error_reporting ( ) && $ severity ) { $ ErrorException = new PHPErrorException ( $ message , 0 , $ severity , $ file , $ line ) ; if ( assert_options ( ASSERT_ACTIVE ) ) { foreach ( $ ErrorException -> getStackTrace ( ) as $ element ) { if ( isset ( $ element [ 'function' ] ) && $ element [ 'function' ] == 'assert' ) { self :: exception ( $ ErrorException ) ; } } } $ recoverable = [ E_WARNING , E_NOTICE , E_USER_WARNING , E_USER_NOTICE , E_STRICT , E_DEPRECATED , E_USER_DEPRECATED ] ; if ( in_array ( $ severity , $ recoverable ) ) { return ; } throw $ ErrorException ; } }
623	protected function createModels ( $ rows ) { if ( $ this -> asArray ) { return $ rows ; } else { $ models = [ ] ; $ class = $ this -> modelClass ; foreach ( $ rows as $ row ) { $ model = $ class :: instantiate ( $ row ) ; $ modelClass = get_class ( $ model ) ; $ modelClass :: populateRecord ( $ model , $ row ) ; $ models [ ] = $ model ; } return $ models ; } }
10408	public function addDocumentParameter ( $ field , $ value ) { $ this -> documentParamCache [ md5 ( $ value . $ field ) ] = [ $ field , $ value ] ; }
9429	public function getFontIconClassNames ( ) { $ classes = [ ] ; if ( $ this -> owner -> FontIcon ) { if ( $ this -> owner -> FontIconListItem ) { $ classes [ ] = $ this -> backend -> getClassName ( 'list-item' ) ; } if ( $ this -> owner -> FontIconFixedWidth ) { $ classes [ ] = $ this -> backend -> getClassName ( 'fixed-width' ) ; } $ classes [ ] = $ this -> backend -> getClassName ( 'icon' , [ $ this -> owner -> FontIcon ] ) ; } return $ classes ; }
11903	public function getDescriptor ( ) { $ logModel = $ this -> getLogModel ( true ) ; if ( empty ( $ logModel ) || ! isset ( $ logModel -> dataInterface ) ) { return 'Unknown Data Interface' ; } return 'Interface: ' . $ logModel -> dataInterface -> name ; }
9946	public function cellExists ( $ pCoordinate ) { if ( strpos ( $ pCoordinate , '!' ) !== false ) { $ worksheetReference = self :: extractSheetTitle ( $ pCoordinate , true ) ; return $ this -> parent -> getSheetByName ( $ worksheetReference [ 0 ] ) -> cellExists ( strtoupper ( $ worksheetReference [ 1 ] ) ) ; } if ( ( ! preg_match ( '/^' . Calculation :: CALCULATION_REGEXP_CELLREF . '$/i' , $ pCoordinate , $ matches ) ) && ( preg_match ( '/^' . Calculation :: CALCULATION_REGEXP_NAMEDRANGE . '$/i' , $ pCoordinate , $ matches ) ) ) { $ namedRange = NamedRange :: resolveRange ( $ pCoordinate , $ this ) ; if ( $ namedRange !== null ) { $ pCoordinate = $ namedRange -> getRange ( ) ; if ( $ this -> getHashCode ( ) != $ namedRange -> getWorksheet ( ) -> getHashCode ( ) ) { if ( ! $ namedRange -> getLocalOnly ( ) ) { return $ namedRange -> getWorksheet ( ) -> cellExists ( $ pCoordinate ) ; } throw new Exception ( 'Named range ' . $ namedRange -> getName ( ) . ' is not accessible from within sheet ' . $ this -> getTitle ( ) ) ; } } else { return false ; } } $ pCoordinate = strtoupper ( $ pCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCoordinate ) ) { throw new Exception ( 'Cell coordinate can not be a range of cells.' ) ; } elseif ( strpos ( $ pCoordinate , '$' ) !== false ) { throw new Exception ( 'Cell coordinate must not be absolute.' ) ; } return $ this -> cellCollection -> has ( $ pCoordinate ) ; }
11147	public function getFromLocation ( Neuron_GameServer_Map_Location $ location ) { $ area = new Neuron_GameServer_Map_Area ( $ location , 1 ) ; $ objects = $ this -> getDisplayObjects ( $ area ) ; $ out = array ( ) ; foreach ( $ objects as $ v ) { if ( $ v -> getLocation ( ) -> equals ( $ location ) ) { $ out [ ] = $ v ; } } return $ out ; }
7164	private function buildSaleDiscountsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) ) { return ; } foreach ( $ sale -> getAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ adjustment ) { $ this -> view -> addDiscount ( $ this -> buildDiscountLine ( $ adjustment ) ) ; } }
11638	public function getAuthorities ( ) { $ authorities = [ ] ; foreach ( $ this -> getAll ( ) as $ typeItem ) { if ( isset ( $ typeItem -> object ) && $ typeItem -> object -> getBehavior ( 'Authority' ) !== null ) { $ authorities [ $ typeItem -> object -> systemId ] = $ typeItem -> object ; } } return $ authorities ; }
7532	function html ( $ value = null ) { if ( $ value !== null ) { $ this -> setInnerText ( $ value ) ; } return $ this -> getInnerText ( ) ; }
11209	public function login ( $ subject ) { $ caller = $ this -> identifier -> identify ( $ subject ) ; if ( $ this -> authenticator -> authenticate ( $ subject , $ caller ) ) { $ this -> driver -> setLoginToken ( $ caller -> getLoginToken ( ) ) ; $ this -> currentCaller = $ caller ; return true ; } return false ; }
782	public function add ( $ cookie ) { if ( $ this -> readOnly ) { throw new InvalidCallException ( 'The cookie collection is read only.' ) ; } $ this -> _cookies [ $ cookie -> name ] = $ cookie ; }
12866	public function init_locales ( ) { if ( ! empty ( $ this -> textdomain ) && $ this -> locales_initialized !== true ) { load_plugin_textdomain ( $ this -> textdomain , true , $ this -> get_id ( ) ) ; $ this -> locales_initialized = true ; } }
9717	private function writeRecalcId ( ) { $ record = 0x01C1 ; $ length = 8 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'VV' , 0x000001C1 , 0x00001E667 ) ; return $ this -> writeData ( $ header . $ data ) ; }
1671	public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new self ( $ strParent ) ; } $ this -> Files -> rcopy ( $ this -> strFolder , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { Dbafs :: copyResource ( $ this -> strFolder , $ strNewName ) ; } elseif ( $ syncTarget ) { Dbafs :: addResource ( $ strNewName ) ; } return true ; }
12699	static function pake_antpattern ( $ files , $ rootdir ) { $ results = array ( ) ; foreach ( $ files as $ file ) { $ file = str_replace ( '/**/**/' , '/**/' , $ file ) ; $ type = 'any' ; if ( substr ( $ file , - 1 ) == '/' ) { $ type = 'dir' ; $ file = substr ( $ file , 0 , - 1 ) ; } if ( strlen ( $ file ) >= 3 && substr ( $ file , - 3 ) == '/**' ) { $ file .= '/*' ; } $ dir = dirname ( $ file ) ; $ file = basename ( $ file ) ; if ( strpos ( $ dir , '**' ) !== false ) { $ split = explode ( '/' , $ dir ) ; $ path = '' ; foreach ( $ split as $ i => $ part ) { if ( $ part != '**' ) { $ path .= "/$part" ; } else { $ newfile = implode ( '/' , array_slice ( $ split , $ i + 1 ) ) . "/$file" . ( $ type == 'dir' ? '/' : '' ) ; $ dirs = pakeFinder :: type ( 'dir' ) -> in ( $ rootdir . $ path ) ; $ dirs [ ] = $ rootdir . $ path ; foreach ( $ dirs as $ newdir ) { $ found = self :: pake_antpattern ( array ( $ newfile ) , $ newdir ) ; $ results = array_merge ( $ results , $ found ) ; } break ; } } } else { $ found = pakeFinder :: type ( $ type ) -> name ( $ file ) -> maxdepth ( 0 ) -> in ( $ rootdir . '/' . $ dir ) ; $ results = array_merge ( $ results , $ found ) ; } } return $ results ; }
2040	private function createConfigItem ( $ imageSize ) : PictureConfigurationItem { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; if ( null !== $ imageSize ) { $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; $ configItem -> setResizeConfig ( $ resizeConfig ) -> setSizes ( $ imageSize -> sizes ) -> setDensities ( $ imageSize -> densities ) ; if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } } return $ configItem ; }
12066	public function invokeRpcCall ( $ method , $ arguments = [ ] ) { if ( ! is_null ( $ this -> namespace ) ) { $ method = $ this -> namespace . '.' . $ method ; } $ body = XmlRpcBuilder :: createRequest ( $ method , $ arguments ) ; $ guzzle = new \ GuzzleHttp \ Client ( ) ; $ this -> getLogger ( ) -> info ( "sending request for $method to {$this->url}" ) ; $ this -> getLogger ( ) -> debug ( "sending request for $method to {$this->url}, with parameters: " . print_r ( $ arguments , true ) ) ; $ response = $ guzzle -> post ( $ this -> url , [ 'body' => $ body , 'headers' => [ 'User-Agent' => 'Devedge\XmlRpc\Client/' . self :: $ version , 'Content-Type' => 'text/xml' ] ] ) ; if ( $ response -> xml ( ) -> fault -> count ( ) > 0 ) { $ this -> logger -> warning ( "serverside error occured, details: " . $ response -> getBody ( ) ) ; throw XmlRpcParser :: parseFault ( $ response -> xml ( ) -> fault ) ; } return array_shift ( XmlRpcParser :: parseParams ( $ response -> xml ( ) -> params ) ) ; }
911	public function addBlank ( ) { $ matched = Preg :: match ( '/^([ \t]*\*)[^\r\n]*(\r?\n)$/' , $ this -> content , $ matches ) ; if ( 1 !== $ matched ) { return ; } $ this -> content .= $ matches [ 1 ] . $ matches [ 2 ] ; }
10721	public function getLabel ( ) { $ label = $ this -> label ; $ title = $ this -> title ; if ( $ label ) { return $ label ; } else { return $ title ; } }
1554	protected function resourceRelationships ( $ record = null ) { $ validator = $ this -> validatorFactory ( ) -> relationships ( ) ; $ this -> relationshipRules ( $ validator , $ record ) ; return $ validator ; }
8891	public function singleton ( $ key , $ value ) { if ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } }
8309	public function assertIntOrFalse ( $ config , $ key , $ lowest = null , $ highest = null ) { try { $ this -> assertInteger ( $ config , $ key , $ lowest , $ highest ) ; } catch ( ConfigurationException $ e ) { if ( $ config [ $ key ] !== false ) { throw new ConfigurationException ( "Key `{$key}` can be either false or a non-negative integer." ) ; } } return $ this ; }
9337	public function isComplementary ( Angle $ angle ) { $ out = new self ( $ this -> float_rad + $ angle -> rad ) ; return $ out -> isRight ( ) ; }
12303	protected function generateSiteMap ( ) { $ urls = array ( ) ; $ siteName = $ this -> configurationHandler -> siteName ( ) ; foreach ( $ this -> pagesCollectionParser -> pages ( ) as $ page ) { foreach ( $ page [ "seo" ] as $ seo ) { $ urls [ ] = array ( 'href' => $ siteName . '/' . $ seo [ "permalink" ] , 'frequency' => $ seo [ "sitemap_frequency" ] , 'priority' => $ seo [ "sitemap_priority" ] , ) ; } } return $ this -> twig -> render ( 'RedKiteCms/Resources/views/Sitemap/sitemap.html.twig' , array ( 'urls' => $ urls ) ) ; }
9671	private function writeCellStyleDxf ( XMLWriter $ objWriter , \ PhpOffice \ PhpSpreadsheet \ Style \ Style $ pStyle ) { $ objWriter -> startElement ( 'dxf' ) ; $ this -> writeFont ( $ objWriter , $ pStyle -> getFont ( ) ) ; $ this -> writeNumFmt ( $ objWriter , $ pStyle -> getNumberFormat ( ) ) ; $ this -> writeFill ( $ objWriter , $ pStyle -> getFill ( ) ) ; $ objWriter -> startElement ( 'alignment' ) ; if ( $ pStyle -> getAlignment ( ) -> getHorizontal ( ) !== null ) { $ objWriter -> writeAttribute ( 'horizontal' , $ pStyle -> getAlignment ( ) -> getHorizontal ( ) ) ; } if ( $ pStyle -> getAlignment ( ) -> getVertical ( ) !== null ) { $ objWriter -> writeAttribute ( 'vertical' , $ pStyle -> getAlignment ( ) -> getVertical ( ) ) ; } if ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) !== null ) { $ textRotation = 0 ; if ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) >= 0 ) { $ textRotation = $ pStyle -> getAlignment ( ) -> getTextRotation ( ) ; } elseif ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) < 0 ) { $ textRotation = 90 - $ pStyle -> getAlignment ( ) -> getTextRotation ( ) ; } $ objWriter -> writeAttribute ( 'textRotation' , $ textRotation ) ; } $ objWriter -> endElement ( ) ; $ this -> writeBorder ( $ objWriter , $ pStyle -> getBorders ( ) ) ; if ( ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== null ) || ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== null ) ) { if ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== Protection :: PROTECTION_INHERIT || $ pStyle -> getProtection ( ) -> getHidden ( ) !== Protection :: PROTECTION_INHERIT ) { $ objWriter -> startElement ( 'protection' ) ; if ( ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== null ) && ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== Protection :: PROTECTION_INHERIT ) ) { $ objWriter -> writeAttribute ( 'locked' , ( $ pStyle -> getProtection ( ) -> getLocked ( ) == Protection :: PROTECTION_PROTECTED ? 'true' : 'false' ) ) ; } if ( ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== null ) && ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== Protection :: PROTECTION_INHERIT ) ) { $ objWriter -> writeAttribute ( 'hidden' , ( $ pStyle -> getProtection ( ) -> getHidden ( ) == Protection :: PROTECTION_PROTECTED ? 'true' : 'false' ) ) ; } $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; }
4957	public function onFlush ( OnFlushEventArgs $ args ) { $ dm = $ args -> getDocumentManager ( ) ; $ uow = $ dm -> getUnitOfWork ( ) ; $ filter = function ( $ element ) { return $ element instanceof $ this -> targetDocument && $ element instanceof PermissionsAwareInterface && $ element -> getPermissions ( ) -> hasChanged ( ) ; } ; $ inserts = array_filter ( $ uow -> getScheduledDocumentInsertions ( ) , $ filter ) ; $ updates = array_filter ( $ uow -> getScheduledDocumentUpdates ( ) , $ filter ) ; $ this -> process ( $ inserts , $ dm , $ uow , true ) ; $ this -> process ( $ updates , $ dm , $ uow ) ; }
5235	public function withEntryFromProvider ( $ key , $ provider ) { $ this -> bindings [ $ key ] = $ this -> getProviderCreator ( $ provider ) ; return $ this ; }
11683	protected function _pushMessage ( $ message , $ type = 'error' , array $ interpolateParams = [ ] ) { $ this -> _messages [ ] = [ 'message' => vsprintf ( $ message , $ interpolateParams ) , 'type' => $ type , ] ; return $ this ; }
7134	public function findOrCreateGoodLine ( Invoice \ InvoiceInterface $ invoice , Common \ SaleItemInterface $ item , $ available , $ expected = null ) { $ line = null ; if ( 0 >= $ available ) { return $ line ; } foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_GOOD ) as $ invoiceLine ) { if ( $ invoiceLine -> getSaleItem ( ) === $ item ) { $ line = $ invoiceLine ; } } if ( null === $ line ) { $ line = $ this -> createLine ( $ invoice ) ; $ line -> setInvoice ( $ invoice ) -> setType ( Document \ DocumentLineTypes :: TYPE_GOOD ) -> setSaleItem ( $ item ) -> setDesignation ( $ item -> getDesignation ( ) ) -> setDescription ( $ item -> getDescription ( ) ) -> setReference ( $ item -> getReference ( ) ) ; } $ line -> setAvailable ( $ available ) ; $ line -> setExpected ( $ expected ) ; if ( Invoice \ InvoiceTypes :: isInvoice ( $ invoice ) && null === $ invoice -> getId ( ) ) { $ line -> setQuantity ( min ( $ expected , $ available ) ) ; } return $ line ; }
7573	public function validateRequiredFields ( $ postVars ) { $ requiredFields = $ this -> getRequiredFields ( $ postVars [ 'id' ] ) ; $ missingKeys = array ( ) ; foreach ( $ requiredFields as $ human => $ keys ) { if ( ! $ this -> hasRequiredValue ( $ postVars , $ keys ) ) { $ missingKeys [ ] = $ human ; } } if ( ! empty ( $ missingKeys ) ) { throw new GreenhouseApplicationException ( 'Submission missing required answers for: ' . implode ( ', ' , $ missingKeys ) ) ; } return true ; }
5355	protected function getClassFromOperation ( $ name , Operation $ operation = null , $ reference , $ registry ) { if ( $ operation === null ) { return ; } if ( $ operation -> getParameters ( ) ) { foreach ( $ operation -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ this -> chainGuesser -> guessClass ( $ parameter -> getSchema ( ) , $ name . 'Body' , $ reference . '/parameters/' . $ key , $ registry ) ; } } } if ( $ operation -> getResponses ( ) ) { foreach ( $ operation -> getResponses ( ) as $ status => $ response ) { if ( $ response instanceof Response ) { $ this -> chainGuesser -> guessClass ( $ response -> getSchema ( ) , $ name . 'Response' . $ status , $ reference . '/responses/' . $ status , $ registry ) ; } } } }
7505	public function assignNamespace ( string $ namespace , $ prepend = false ) { if ( $ prepend ) { array_unshift ( $ this -> namespaces , $ namespace ) ; return ; } array_push ( $ this -> namespaces , $ namespace ) ; }
874	public function getAnnotationsOfType ( $ types ) { $ annotations = [ ] ; $ types = ( array ) $ types ; foreach ( $ this -> getAnnotations ( ) as $ annotation ) { $ tag = $ annotation -> getTag ( ) -> getName ( ) ; foreach ( $ types as $ type ) { if ( $ type === $ tag ) { $ annotations [ ] = $ annotation ; } } } return $ annotations ; }
3712	public function generateClearAll ( $ strContent , $ strTemplate ) { if ( substr ( $ strTemplate , 0 , 3 ) === 'fe_' ) { if ( preg_match_all ( '#\[\[\[metamodelfrontendfilterclearall::(ce|mod)::([^\]]*)\]\]\]#' , $ strContent , $ arrMatches , PREG_SET_ORDER ) ) { foreach ( $ arrMatches as $ arrMatch ) { switch ( $ arrMatch [ 1 ] ) { case 'ce' : $ strContent = $ this -> generateContentElement ( $ strContent , $ arrMatch [ 0 ] , $ arrMatch [ 2 ] ) ; break ; case 'mod' : $ strContent = $ this -> generateModule ( $ strContent , $ arrMatch [ 0 ] , $ arrMatch [ 2 ] ) ; break ; default : throw new \ RuntimeException ( 'Unexpected element determinator encountered: ' . $ arrMatch [ 1 ] ) ; } } } } return $ strContent ; }
10485	protected function getTableMapping ( $ table ) { if ( array_key_exists ( $ table , $ this -> mappings ) ) { return $ this -> mappings [ $ table ] ; } $ mapping = $ this -> retrieveMapping ( $ table ) ; if ( empty ( $ mapping ) ) { throw new \ UnderflowException ( "Table with name {$table} not found." ) ; } $ this -> mappings [ $ table ] = $ mapping ; return $ mapping ; }
7153	public function add_rule ( $ access , $ role , $ action ) : void { $ roles = ( array ) $ role ; foreach ( $ roles as $ r ) { $ action = ( array ) $ action ; foreach ( $ action as $ a ) { $ this -> _rules [ $ r ] [ $ a ] = $ access ; } } }
4937	protected function createNestedOptions ( $ className , $ options ) { $ class = new $ className ( ) ; foreach ( $ options as $ key => $ spec ) { if ( is_array ( $ spec ) && array_key_exists ( '__class__' , $ spec ) ) { $ nestedClassName = $ spec [ '__class__' ] ; unset ( $ spec [ '__class__' ] ) ; $ spec = $ this -> createNestedOptions ( $ nestedClassName , $ spec ) ; } $ class -> { $ key } = $ spec ; } return $ class ; }
286	public function remove ( $ name ) { $ name = strtolower ( $ name ) ; if ( isset ( $ this -> _headers [ $ name ] ) ) { $ value = $ this -> _headers [ $ name ] ; unset ( $ this -> _headers [ $ name ] ) ; return $ value ; } return null ; }
6606	public function validateAccessTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'access token' ) ; } return true ; }
12855	function goWait ( $ maxExecution = null ) { $ jobExecution = 0 ; $ sleep = 0 ; while ( 1 ) { if ( 0 == $ executed = $ this -> goUntilEmpty ( ) ) { $ sleep += 100000 ; usleep ( $ sleep ) ; if ( $ sleep > 2 * 1000000 ) $ sleep = 100000 ; continue ; } $ jobExecution += $ executed ; if ( $ jobExecution >= $ maxExecution ) break ; if ( $ sleep = $ this -> getSleep ( ) ) usleep ( $ sleep ) ; $ sleep = 0 ; } }
183	public function getPublishedUrl ( $ path ) { $ path = Yii :: getAlias ( $ path ) ; if ( isset ( $ this -> _published [ $ path ] ) ) { return $ this -> _published [ $ path ] [ 1 ] ; } if ( is_string ( $ path ) && ( $ path = realpath ( $ path ) ) !== false ) { return $ this -> baseUrl . '/' . $ this -> hash ( $ path ) . ( is_file ( $ path ) ? '/' . basename ( $ path ) : '' ) ; } return false ; }
9569	public function setContainer ( ContainerInterface $ container ) { $ this -> container = $ container ; $ container -> instance ( 'Autarky\Application' , $ this ) ; $ container -> instance ( 'Symfony\Component\HttpFoundation\RequestStack' , $ this -> requests ) ; }
8108	public function getReviewFrom ( ) { $ from = $ this -> owner -> getField ( 'ReviewFrom' ) ; if ( $ from ) { return $ from ; } return Config :: inst ( ) -> get ( Email :: class , 'admin_email' ) ; }
11500	protected function _setupDatabaseAdapter ( ) { if ( Zend_Registry :: isRegistered ( 'multidb' ) ) { return $ this -> _setAdapter ( Zend_Registry :: get ( 'multidb' ) -> getDb ( $ this -> _connection ) ) ; } return parent :: _setupDatabaseAdapter ( ) ; }
2772	public function init ( array $ options = [ ] ) : string { $ argsAndOptions = [ $ this -> directory , $ options ] ; return $ this -> run ( 'init' , $ argsAndOptions , false ) ; }
11513	public function actionReset ( $ id , $ code ) { if ( ! $ this -> module -> enablePasswordRecovery ) { throw new NotFoundHttpException ; } $ token = $ this -> finder -> findToken ( [ 'user_id' => $ id , 'code' => $ code , 'type' => Token :: TYPE_RECOVERY ] ) -> one ( ) ; if ( $ token === null || $ token -> isExpired || $ token -> user === null ) { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'Recovery link is invalid or expired. Please try requesting a new one.' ) ) ; return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Invalid or expired link' ) , 'module' => $ this -> module , ] ) ; } $ model = \ Yii :: createObject ( [ 'class' => RecoveryForm :: className ( ) , 'scenario' => 'reset' , ] ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> getRequest ( ) -> post ( ) ) && $ model -> resetPassword ( $ token ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Password has been changed' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'reset' , [ 'model' => $ model , ] ) ; }
3607	protected function getTableNames ( ) { $ schemas = DB :: getConfig ( 'used_schemas' ) ? : [ DB :: getConfig ( 'schema' ) ] ; $ schemaCount = count ( $ schemas ) ; $ binds = implode ( ',' , array_fill ( 0 , $ schemaCount , '?' ) ) ; return collect ( DB :: select ( "SELECT schemaname || '.' || tablename AS table FROM pg_catalog.pg_tables WHERE schemaname IN (" . $ binds . ')' , $ schemas ) ) -> pluck ( 'table' ) -> reject ( function ( $ value , $ key ) { $ tableName = explode ( '.' , $ value ) [ 1 ] ; return $ tableName === 'spatial_ref_sys' ; } ) ; }
12417	static function run_copy_paste_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcpd = self :: getTool ( 'phpcpd' , $ opts , true ) ; try { $ out = pake_sh ( "$phpcpd " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcpd.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
8485	public static function getCpuModel ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT Name FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> Name ; } return 'Unknown' ; }
10649	private function buildUniqueRules ( ) { $ rulescopes = $ this -> rules ; foreach ( $ rulescopes as $ scope => & $ rules ) { foreach ( $ rules as $ field => & $ ruleset ) { $ ruleset = ( is_string ( $ ruleset ) ) ? explode ( '|' , $ ruleset ) : $ ruleset ; foreach ( $ ruleset as & $ rule ) { if ( str_contains ( $ rule , 'unique' ) && str_contains ( $ rule , '{id}' ) == false ) { $ params = explode ( ',' , $ rule ) ; $ uniqueRules = array ( ) ; $ table = explode ( ':' , $ params [ 0 ] ) ; if ( count ( $ table ) == 1 ) $ uniqueRules [ 1 ] = $ this -> table ; else $ uniqueRules [ 1 ] = $ table [ 1 ] ; if ( count ( $ params ) == 1 ) $ uniqueRules [ 2 ] = $ field ; else $ uniqueRules [ 2 ] = $ params [ 1 ] ; $ uniqueRules [ 3 ] = $ this -> getKey ( ) ; $ uniqueRules [ 4 ] = $ this -> getKeyName ( ) ; $ rule = 'unique:' . implode ( ',' , $ uniqueRules ) ; } elseif ( str_contains ( $ rule , 'unique' ) && str_contains ( $ rule , '{id}' ) ) { $ rule = str_replace ( '{id}' , $ this -> getKey ( ) , $ rule ) ; } } } } $ this -> rules = $ rulescopes ; }
8995	protected function addActions ( SymfonyController $ controller , Resource $ resource , $ chainName = '' ) { $ actions = array ( ) ; $ chainName = $ chainName . '_' . strtolower ( str_replace ( array ( '{' , '}' ) , '' , $ resource -> getDisplayName ( ) ) ) ; foreach ( $ resource -> getMethods ( ) as $ method ) { $ actionName = strtolower ( $ method -> getType ( ) ) . str_replace ( ' ' , '' , ucwords ( str_replace ( '_' , ' ' , $ chainName ) ) ) . 'Action' ; $ route = new SymfonyRoute ( $ resource -> getUri ( ) , strtolower ( $ method -> getType ( ) . $ chainName ) ) ; $ action = new SymfonyAction ( $ actionName , $ route , $ method -> getType ( ) , $ method -> getDescription ( ) ) ; preg_match_all ( '/\{[a-zA-Z]+\}/' , $ resource -> getUri ( ) , $ parameters ) ; foreach ( $ parameters [ 0 ] as $ parameter ) { $ action -> addParameter ( substr ( $ parameter , 1 , strlen ( $ parameter ) - 2 ) ) ; } if ( $ method -> getResponses ( ) ) { foreach ( $ method -> getResponses ( ) as $ code => $ response ) { $ headers = array ( ) ; foreach ( $ response -> getHeaders ( ) as $ key => $ value ) { if ( isset ( $ value [ 'required' ] ) && $ value [ 'required' ] ) { $ headers [ $ key ] = isset ( $ value [ 'example' ] ) ? $ value [ 'example' ] : '' ; } } $ _response = new SymfonyResponse ( $ code , $ headers ) ; foreach ( $ this -> config [ 'allowed_response_types' ] as $ allowedResponsetype ) { if ( null !== $ example = $ response -> getExampleByType ( $ allowedResponsetype ) ) { $ _response -> addContent ( new SymfonyResponseContent ( $ allowedResponsetype , str_replace ( array ( "\r\n" , "\n" , "\r" , "\t" , " " ) , '' , $ example ) ) ) ; } } $ action -> addResponse ( $ _response ) ; } } $ controller -> addAction ( $ action ) ; } foreach ( $ resource -> getResources ( ) as $ subresource ) { $ this -> addActions ( $ controller , $ subresource , $ chainName ) ; } }
10393	private function isValidOperation ( $ operationType ) { $ operationType = strtoupper ( $ operationType ) ; return in_array ( $ operationType , [ ActionTypes :: CREATE , ActionTypes :: UPDATE , ActionTypes :: DELETE , ] ) ; }
8659	private function convertGetFeedSubmissionCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
10757	public function totals ( $ locale = null ) { $ this -> setLocale ( $ locale ) ; $ totals = Collection :: make ( ) ; foreach ( Arr :: except ( $ this -> footer ( ) , 'all' ) as $ level => $ count ) { $ totals -> put ( $ level , [ 'label' => trans ( 'dashboard::logs.' . $ level ) , 'value' => $ count , 'color' => $ this -> color ( $ level ) , 'highlight' => $ this -> color ( $ level ) , ] ) ; } return $ totals ; }
7642	public function getBaseUrl ( ) { if ( $ this -> credentials -> usePathStyleUri ( ) ) { return $ this -> host . '/' . $ this -> accountName ; } return $ this -> host ; }
8781	public function save ( $ content = null , $ time = 30 ) { $ fileName = md5 ( $ this -> prefix . http ( ) -> server ( 'REQUEST_URI' ) ) . $ this -> extension ; $ this -> file = cache_path ( 'html' . DIRECTORY_SEPARATOR . $ fileName ) ; $ this -> start ( $ time ) ; return $ this -> finish ( $ content ) ; }
2346	public function close ( ) { if ( \ is_resource ( $ this -> resFile ) ) { $ this -> Files -> fclose ( $ this -> resFile ) ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } } $ return = $ this -> Files -> rename ( $ this -> strTmp , $ this -> strFile ) ; $ this -> strTmp = null ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ) { $ this -> objModel = Dbafs :: addResource ( $ this -> strFile ) ; } return $ return ; }
1448	protected function dataForRelationship ( $ record , string $ field , array $ document ) : array { $ schema = $ this -> container -> getSchema ( $ record ) ; return [ 'type' => $ schema -> getResourceType ( ) , 'id' => $ schema -> getId ( $ record ) , 'relationships' => [ $ field => [ 'data' => $ document [ 'data' ] , ] , ] , ] ; }
2073	public function getAllTables ( ) { $ arrTables = $ this -> Database -> listTables ( ) ; $ arrViews = Contao \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> listViews ( ) ; if ( ! empty ( $ arrViews ) ) { $ arrTables = array_merge ( $ arrTables , array_keys ( $ arrViews ) ) ; natsort ( $ arrTables ) ; } return array_values ( $ arrTables ) ; }
1931	public function attachFileFromString ( $ strContent , $ strFilename , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( new \ Swift_Attachment ( $ strContent , $ strFilename , $ strMime ) ) ; }
11795	public function setAttachment ( $ file = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } if ( is_array ( $ file ) ) { foreach ( $ file as $ _f ) { if ( file_exists ( $ _f ) ) { $ this -> attachment [ ] = $ _f ; } } } else { if ( file_exists ( $ file ) ) { $ this -> attachment [ ] = $ file ; } } return $ this ; }
11418	public static function createInstance ( $ environment , $ options = null ) { if ( ! self :: $ _instance ) { self :: $ _instance = new static ( $ environment , $ options , false ) ; } return self :: $ _instance ; }
1258	private function makeVar ( $ prefix ) { if ( ! isset ( $ this -> vars [ $ prefix ] ) ) { $ this -> vars [ $ prefix ] = 0 ; return '$' . $ prefix ; } return '$' . $ prefix . ++ $ this -> vars [ $ prefix ] ; }
10747	protected function sendItems ( Response $ response , iterable $ items , ? Pagination $ pagination = null , ? int $ total = null ) : Response { $ items = is_array ( $ items ) ? $ items : ( $ items instanceof \ Traversable ? iterator_to_array ( $ items , false ) : [ ] ) ; $ total = $ total ?? count ( $ items ) ; $ start = $ pagination === null ? 0 : $ pagination -> getOffset ( ) ; $ max = $ pagination === null ? 0 : $ pagination -> getMax ( ) ; $ end = max ( min ( ( PHP_INT_MAX - $ max < $ start ? PHP_INT_MAX : $ start + $ max ) , $ total ) - 1 , 0 ) ; return $ this -> sendJson ( $ response -> withHeader ( 'Content-Range' , "items $start-$end/$total" ) , $ items ) ; }
4868	protected function parseOptionsToDateTime ( $ options ) { $ time = microtime ( true ) ; $ micro = sprintf ( "%06d" , ( $ time - floor ( $ time ) ) * 1000000 ) ; $ this -> now = new \ DateTime ( date ( 'Y-m-d H:i:s.' . $ micro , $ time ) , new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; $ scheduled = isset ( $ options [ 'scheduled' ] ) ? Utils :: createDateTime ( $ options [ 'scheduled' ] ) : clone ( $ this -> now ) ; if ( isset ( $ options [ 'delay' ] ) ) { $ delay = Utils :: createDateInterval ( $ options [ 'delay' ] ) ; $ scheduled -> add ( $ delay ) ; } return $ scheduled ; }
3396	public function toMail ( $ notifiable ) { return ( new MailMessage ) -> subject ( __ ( 'confirmation::confirmation.confirmation_subject' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_subject_title' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_body' ) ) -> action ( __ ( 'confirmation::confirmation.confirmation_button' ) , url ( "register/confirm/$notifiable->confirmation_code" ) ) ; }
7549	function deleteChild ( $ child , $ soft_delete = false ) { if ( is_object ( $ child ) ) { $ child = $ this -> findChild ( $ child ) ; } elseif ( $ child < 0 ) { $ child += count ( $ this -> children ) ; } if ( ! $ soft_delete ) { $ this -> children [ $ child ] -> delete ( ) ; } unset ( $ this -> children [ $ child ] ) ; $ tmp = array ( ) ; foreach ( array_keys ( $ this -> children ) as $ k ) { $ tmp [ ] = & $ this -> children [ $ k ] ; } $ this -> children = $ tmp ; }
2668	public function getAuthDictionary ( $ version ) { $ name = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> getSingleDictionary ( $ version , $ name ) ; return $ dictionary ; }
9469	private function registerLogViewerRoutes ( ) { $ this -> prefix ( 'log-viewer' ) -> name ( 'log-viewer.' ) -> group ( function ( ) { $ this -> get ( '/' , 'LogViewerController@index' ) -> name ( 'index' ) ; $ this -> prefix ( 'logs' ) -> name ( 'logs.' ) -> group ( function ( ) { $ this -> get ( '/' , 'LogViewerController@listLogs' ) -> name ( 'list' ) ; $ this -> prefix ( '{logviewer_log_date}' ) -> group ( function ( ) { $ this -> get ( '/' , 'LogViewerController@show' ) -> name ( 'show' ) ; $ this -> get ( 'download' , 'LogViewerController@download' ) -> name ( 'download' ) ; $ this -> get ( '{level}' , 'LogViewerController@showByLevel' ) -> name ( 'filter' ) ; $ this -> get ( '{level}/search' , 'LogViewerController@search' ) -> name ( 'search' ) ; $ this -> delete ( 'delete' , 'LogViewerController@delete' ) -> middleware ( 'ajax' ) -> name ( 'delete' ) ; } ) ; } ) ; } ) ; }
9554	public function naming ( $ namer ) { if ( $ namer instanceof \ Closure ) { $ namer = new ClosureNamer ( $ namer ) ; } $ this -> namer = $ namer ; return $ this ; }
12299	public function getPivotFields ( $ obj , $ prop ) { $ reflection = new \ ReflectionClass ( $ obj ) ; $ property = $ reflection -> getProperty ( $ prop ) ; $ property -> setAccessible ( true ) ; $ value = $ property -> getValue ( $ obj ) ; $ property -> setAccessible ( false ) ; return array_diff ( $ value , [ 'deleted_at' , 'created_at' , 'updated_at' ] ) ; }
4816	public function appendRow ( $ singleRow = null ) { if ( ! is_null ( $ singleRow ) ) { if ( $ singleRow instanceof Row ) { $ this -> collection [ ] = $ singleRow ; $ singleRow -> acceptChanges ( ) ; } elseif ( is_array ( $ singleRow ) ) { $ this -> collection [ ] = new Row ( $ singleRow ) ; } else { throw new InvalidArgumentException ( "You must pass an array or a Row object" ) ; } } else { $ singleRow = new Row ( ) ; $ this -> collection [ ] = $ singleRow ; $ singleRow -> acceptChanges ( ) ; } $ this -> currentRow = count ( $ this -> collection ) - 1 ; }
773	public function actionExtract ( $ configFile = null ) { $ this -> initConfig ( $ configFile ) ; $ files = FileHelper :: findFiles ( realpath ( $ this -> config [ 'sourcePath' ] ) , $ this -> config ) ; $ messages = [ ] ; foreach ( $ files as $ file ) { $ messages = array_merge_recursive ( $ messages , $ this -> extractMessages ( $ file , $ this -> config [ 'translator' ] , $ this -> config [ 'ignoreCategories' ] ) ) ; } $ catalog = isset ( $ this -> config [ 'catalog' ] ) ? $ this -> config [ 'catalog' ] : 'messages' ; if ( in_array ( $ this -> config [ 'format' ] , [ 'php' , 'po' ] ) ) { foreach ( $ this -> config [ 'languages' ] as $ language ) { $ dir = $ this -> config [ 'messagePath' ] . DIRECTORY_SEPARATOR . $ language ; if ( ! is_dir ( $ dir ) && ! @ mkdir ( $ dir ) ) { throw new Exception ( "Directory '{$dir}' can not be created." ) ; } if ( $ this -> config [ 'format' ] === 'po' ) { $ this -> saveMessagesToPO ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ catalog , $ this -> config [ 'markUnused' ] ) ; } else { $ this -> saveMessagesToPHP ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ this -> config [ 'markUnused' ] ) ; } } } elseif ( $ this -> config [ 'format' ] === 'db' ) { $ db = Instance :: ensure ( $ this -> config [ 'db' ] , Connection :: className ( ) ) ; $ sourceMessageTable = isset ( $ this -> config [ 'sourceMessageTable' ] ) ? $ this -> config [ 'sourceMessageTable' ] : '{{%source_message}}' ; $ messageTable = isset ( $ this -> config [ 'messageTable' ] ) ? $ this -> config [ 'messageTable' ] : '{{%message}}' ; $ this -> saveMessagesToDb ( $ messages , $ db , $ sourceMessageTable , $ messageTable , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'languages' ] , $ this -> config [ 'markUnused' ] ) ; } elseif ( $ this -> config [ 'format' ] === 'pot' ) { $ this -> saveMessagesToPOT ( $ messages , $ this -> config [ 'messagePath' ] , $ catalog ) ; } }
6214	protected function initialize ( ) { if ( $ this -> get ( 'serverData' ) === null ) { $ this -> set ( 'serverData' , ( array ) $ _SERVER ) ; } if ( $ this -> get ( 'getData' ) === null ) { $ this -> set ( 'getData' , ( array ) $ _GET ) ; } if ( $ this -> get ( 'postData' ) === null ) { $ this -> set ( 'postData' , ( array ) $ _POST ) ; } if ( $ this -> get ( 'sessionData' ) === null && isset ( $ _SESSION ) ) { $ this -> set ( 'sessionData' , ( array ) $ _SESSION ) ; } $ serverData = $ this -> get ( 'serverData' ) ; if ( ! $ this -> get ( 'projectRoot' ) ) { $ projectRoot = isset ( $ serverData [ '_' ] ) ? $ serverData [ '_' ] : $ serverData [ 'DOCUMENT_ROOT' ] ; $ this -> set ( 'projectRoot' , $ projectRoot ) ; } if ( ! $ this -> get ( 'url' ) ) { if ( isset ( $ serverData [ 'REDIRECT_URL' ] ) ) { $ this -> set ( 'url' , $ serverData [ 'REDIRECT_URL' ] ) ; } elseif ( isset ( $ serverData [ 'SCRIPT_NAME' ] ) ) { $ this -> set ( 'url' , $ serverData [ 'SCRIPT_NAME' ] ) ; } } if ( ! $ this -> get ( 'hostname' ) ) { $ this -> set ( 'hostname' , isset ( $ serverData [ 'HTTP_HOST' ] ) ? $ serverData [ 'HTTP_HOST' ] : 'No Host' ) ; } $ protocol = $ this -> get ( 'secure' ) ? 'https' : 'http' ; $ endPoint = $ this -> get ( 'apiEndPoint' ) ? : $ protocol . '://' . $ this -> get ( 'host' ) . $ this -> get ( 'resource' ) ; $ this -> set ( 'apiEndPoint' , $ endPoint ) ; }
10659	protected function normalizeHeaderName ( $ keyName ) { if ( ! is_string ( $ keyName ) ) { return null ; } return ucwords ( trim ( strtolower ( $ keyName ) ) , '-' ) ? : null ; }
5441	public function parse ( $ raw ) { if ( ! isset ( $ this -> parser ) ) { return false ; } $ length = strlen ( $ raw ) ; while ( is_array ( $ parsed = $ this -> reduce ( $ raw ) ) ) { list ( $ raw , $ unmatched , $ matched , $ mode ) = $ parsed ; if ( ! $ this -> dispatchTokens ( $ unmatched , $ matched , $ mode ) ) { return false ; } if ( $ raw === '' ) { return true ; } if ( strlen ( $ raw ) == $ length ) { return false ; } $ length = strlen ( $ raw ) ; } if ( ! $ parsed ) { return false ; } return $ this -> invokeParser ( $ raw , LEXER_UNMATCHED ) ; }
8093	public function get ( $ keyPath ) { $ stops = explode ( '.' , $ keyPath ) ; $ value = $ this ; foreach ( $ stops as $ key ) { if ( $ value instanceof Collection ) { $ value = $ value -> $ key ; } else { $ value = null ; break ; } } return $ value ; }
217	public function asImage ( $ value , $ options = [ ] ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return Html :: img ( $ value , $ options ) ; }
11323	protected function getAnnotationMethodForMethod ( ClassInterface $ class , $ requestMethod ) { foreach ( $ class -> getMethods ( ) as $ method ) { if ( $ method -> getAnnotatedName ( ) === $ requestMethod ) { return $ method ; } } throw new ExtDirectException ( "extjs method name '{$requestMethod}' does not exist'" ) ; }
6898	public function delete ( ... $ args ) { $ this -> open ( ) ; foreach ( $ args as $ key ) { unset ( $ this -> _data [ $ key ] ) ; } return $ this ; }
6539	public function transform ( $ iterator ) { if ( null === $ iterator ) { return array ( ) ; } if ( is_array ( $ iterator ) ) { return $ iterator ; } if ( ! $ iterator instanceof Iterator ) { throw new TransformationFailedException ( 'Expected a Yucca\Component\Iterator\Iterator object.' ) ; } return $ iterator -> getArray ( ) ; }
9121	public function retrieveHeaders ( ) : array { $ this -> setHeader ( 'Connection' , 'close' ) ; $ this -> setHeader ( 'Accept' , '' ) ; $ this -> setHeader ( 'Accept-Language' , '' ) ; $ this -> setHeader ( 'User-Agent' , '' ) ; $ savedProto = $ this -> protocol ; $ this -> protocol = 'HTTP/1.0' ; $ this -> request ( 'HEAD' ) ; $ this -> protocol = $ savedProto ; return $ this -> getHeaders ( ) ; }
3418	public static function registerEloquent ( ) { $ capsule = self :: bootstrapIlluminateDatabase ( ) ; class_alias ( Capsule :: class , 'DB' ) ; if ( $ _COOKIE [ "show_sql_stat" ] == "Y" ) { Capsule :: enableQueryLog ( ) ; $ em = \ Bitrix \ Main \ EventManager :: getInstance ( ) ; $ em -> addEventHandler ( 'main' , 'OnAfterEpilog' , [ IlluminateQueryDebugger :: class , 'onAfterEpilogHandler' ] ) ; } static :: addEventListenersForHelpersHighloadblockTables ( $ capsule ) ; }
11943	private function validateUrl ( Request $ request , ConfigContainer $ config , $ position ) { $ url = $ request -> getUrl ( ) ; $ default = $ config -> getValue ( 'default' ) ; if ( preg_match ( '/^' . $ config -> getValue ( 'pattern' ) . '$/' , $ url , $ matches ) && isset ( $ matches [ 1 ] ) ) { return $ matches [ 1 ] ; } else if ( $ default !== false ) { return $ config -> getValue ( 'default' ) ; } else { throw new RequiredArgumentException ( $ position , $ config -> getValue ( 'name' ) ) ; } }
8056	public function setChildProcessTitleFormat ( $ string ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Parent\'s Process Title Format for a created pool.' ) ; } $ this -> childProcessTitleFormat = ProcessDetails :: sanitizeProcessTitleFormat ( $ string ) ; return $ this ; }
3062	public function canMoveBackward ( ) { $ moveBack = false ; $ session = $ this -> getTestSession ( ) ; if ( $ this -> isAdaptive ( ) ) { $ positionInCatSession = array_search ( $ this -> getCurrentCatItemId ( ) , $ this -> getShadowTest ( ) ) ; if ( $ positionInCatSession === 0 ) { if ( $ session -> getRoute ( ) -> getPosition ( ) !== 0 ) { $ moveBack = $ session -> getPreviousRouteItem ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> getRoute ( ) -> current ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> canMoveBackward ( ) ; if ( $ moveBack ) { $ moveBack = $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> canMoveBackward ( $ session ) ; } } return $ moveBack ; }
5046	public function form ( $ form , $ options = null , $ as = 'searchform' ) { if ( is_string ( $ options ) ) { $ as = $ options ; $ options = null ; } $ this -> stack [ 'form' ] = [ 'as' => $ as , $ form , $ options ] ; return $ this ; }
10479	protected function inlineContext ( $ selectQuery , $ itemRow ) { $ selectQuery = str_replace ( [ 'OLD.' , 'NEW.' ] , '__ctx__' , $ selectQuery ) ; $ prefixedKeys = array_map ( function ( $ key ) { return '__ctx__' . $ key ; } , array_keys ( $ itemRow ) ) ; $ connection = $ this -> getConnection ( ) ; $ escapedValues = array_map ( function ( $ value ) use ( $ connection ) { return $ connection -> quote ( $ value ) ; } , array_values ( $ itemRow ) ) ; $ sql = str_replace ( $ prefixedKeys , $ escapedValues , $ selectQuery ) ; return $ sql ; }
9753	public static function sysGetTempDir ( ) { if ( self :: $ useUploadTempDirectory ) { if ( ini_get ( 'upload_tmp_dir' ) !== false ) { if ( $ temp = ini_get ( 'upload_tmp_dir' ) ) { if ( file_exists ( $ temp ) ) { return realpath ( $ temp ) ; } } } } return realpath ( sys_get_temp_dir ( ) ) ; }
2911	public function xml2array ( $ xml , array & $ arr , $ parentKey = '' ) { if ( ! $ xml ) { return ; } if ( count ( $ xml -> children ( ) ) == 0 ) { $ arr [ $ parentKey ] = ( string ) $ xml ; } else { foreach ( $ xml -> children ( ) as $ key => $ item ) { $ key = $ parentKey ? $ parentKey . DS . $ key : $ key ; $ this -> xml2array ( $ item , $ arr , $ key ) ; } } return $ arr ; }
8567	private function _convertGetShipment ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetShipment' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentId ( ) ) { $ parameters [ 'ShipmentId' ] = $ request -> getShipmentId ( ) ; } return $ parameters ; }
3411	public function format ( ) : string { foreach ( $ this -> times as $ unit => $ value ) { if ( $ this -> time >= $ value ) { $ time = floor ( $ this -> time / $ value * 100 ) / 100 ; return "{$time} {$unit}" ; } } return round ( $ this -> time * 1000 ) . " ms" ; }
7914	protected function renderLabel ( ) { $ label = $ this -> encodeLabel ? Html :: encode ( $ this -> label ) : $ this -> label ; return $ this -> hasModel ( ) ? Html :: activeLabel ( $ this -> model , $ this -> attribute , $ this -> labelOptions ) : Html :: label ( $ label , $ this -> getId ( ) , $ this -> labelOptions ) ; }
11626	private function isrunning ( ) { $ pids = explode ( PHP_EOL , `ps -e | awk '{print $1}'` ) ; if ( in_array ( $ this -> pid , $ pids ) ) return true ; return false ; }
1833	public function onUnregister ( Registry $ registry ) { foreach ( static :: getUniqueFields ( ) as $ strColumn ) { $ varAliasValue = $ this -> { $ strColumn } ; if ( $ registry -> isRegisteredAlias ( $ this , $ strColumn , $ varAliasValue ) ) { $ registry -> unregisterAlias ( $ this , $ strColumn , $ varAliasValue ) ; } } }
3879	public function addSubProcedure ( FilterBuilderSql $ subProcedure ) { $ this -> procedures [ ] = $ subProcedure -> getProcedure ( ) ; $ this -> parameter = array_merge ( $ this -> parameter , $ subProcedure -> getParameters ( ) ) ; return $ this ; }
766	public function setIdentity ( $ identity ) { if ( $ identity instanceof IdentityInterface ) { $ this -> _identity = $ identity ; } elseif ( $ identity === null ) { $ this -> _identity = null ; } else { throw new InvalidValueException ( 'The identity object must implement IdentityInterface.' ) ; } $ this -> _access = [ ] ; }
7344	protected function preventForbiddenChange ( ShipmentInterface $ shipment ) { if ( $ this -> persistenceHelper -> isChanged ( $ shipment , 'return' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ shipment , 'return' ) ; if ( $ old != $ new ) { throw new RuntimeException ( "Changing the shipment type is not yet supported." ) ; } } }
11399	public function getCustomFieldByType ( $ type ) { if ( isset ( $ this -> servicesByType [ $ type ] ) ) { return $ this -> servicesByType [ $ type ] ; } else { throw new \ LogicException ( 'the custom field with type ' . $ type . ' ' . 'is not found' ) ; } }
9420	public function search ( HTTPRequest $ request ) { if ( ! $ request -> isAjax ( ) ) { return ; } $ data = [ ] ; if ( $ term = $ request -> getVar ( 'term' ) ) { $ groups = [ ] ; foreach ( $ this -> backend -> getGroupedIcons ( ) as $ group => $ icons ) { $ children = [ ] ; foreach ( $ icons as $ id => $ icon ) { if ( stripos ( $ id , $ term ) !== false ) { $ children [ ] = $ this -> getResultData ( $ this -> getIconData ( $ id ) ) ; } } if ( ! empty ( $ children ) ) { $ groups [ ] = [ 'text' => $ group , 'children' => $ children ] ; } } $ data [ 'results' ] = $ groups ; } return $ this -> respond ( $ data ) ; }
8414	public function getMasterLink ( ) { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return $ this -> servers [ 'all' ] [ 'link' ] ; } return $ this -> servers [ 'write' ] [ 'link' ] ; }
2247	public static function generateMargin ( $ arrValues , $ strType = 'margin' ) { if ( ! \ is_array ( $ arrValues ) ) { $ arrValues = array ( 'top' => '' , 'right' => '' , 'bottom' => '' , 'left' => '' , 'unit' => '' ) ; } $ top = $ arrValues [ 'top' ] ; $ right = $ arrValues [ 'right' ] ; $ bottom = $ arrValues [ 'bottom' ] ; $ left = $ arrValues [ 'left' ] ; if ( $ top != '' && $ right != '' && $ bottom != '' && $ left != '' ) { if ( $ top == $ right && $ top == $ bottom && $ top == $ left ) { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ';' ; } elseif ( $ top == $ bottom && $ right == $ left ) { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ' ' . $ left . $ arrValues [ 'unit' ] . ';' ; } elseif ( $ top != $ bottom && $ right == $ left ) { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ' ' . $ right . $ arrValues [ 'unit' ] . ' ' . $ bottom . $ arrValues [ 'unit' ] . ';' ; } else { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ' ' . $ right . $ arrValues [ 'unit' ] . ' ' . $ bottom . $ arrValues [ 'unit' ] . ' ' . $ left . $ arrValues [ 'unit' ] . ';' ; } } $ return = array ( ) ; $ arrDir = compact ( 'top' , 'right' , 'bottom' , 'left' ) ; foreach ( $ arrDir as $ k => $ v ) { if ( $ v != '' ) { $ return [ ] = $ strType . '-' . $ k . ':' . $ v . $ arrValues [ 'unit' ] . ';' ; } } return implode ( $ return ) ; }
9340	public function load ( $ directory ) { $ configurations = glob ( $ directory . '/*.php' ) ; foreach ( $ configurations as $ configuration ) { $ items = require $ configuration ; $ name = basename ( $ configuration , '.php' ) ; $ this -> data = array_merge ( $ this -> data , array ( $ name => $ items ) ) ; } return $ this -> data ; }
10749	protected function sendDeleted ( Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { return $ this -> sendVerb ( 'deleted' , $ response , $ type , $ ids , $ extra ) ; }
12833	private function generateConfigCreatorMethod ( ConfigService $ config ) { $ configClass = Util :: normalizeFqcn ( $ config -> getClass ( ) ) ; $ configData = var_export ( $ config -> getData ( ) , true ) ; return <<<PHP public function getAppConfig() : {$configClass} { if (isset(\$this->singletons['{$config->getId()}}'])) { return \$this->singletons['{$config->getId()}']; } \$data = {$configData}; return \$this->singletons['{$config->getId()}'] = new {$configClass}(\$data); }PHP ; }
6009	public function setDeleted ( $ deleted ) { if ( $ deleted instanceof DateTime ) { $ this -> deleted = $ deleted ; } else { try { $ this -> deleted = new DateTime ( $ deleted ) ; } catch ( \ Exception $ e ) { $ this -> deleted = null ; } } return $ this ; }
9443	public function setPackOptions ( Container $ app ) { foreach ( $ this -> packOptions as $ key => & $ value ) { $ key = $ this -> _ns ( $ key ) ; if ( isset ( $ app [ $ key ] ) ) { $ value = $ app [ $ key ] ; } } }
11510	public static function parse ( $ program ) { $ i = 0 ; $ len = strlen ( $ program ) ; $ forms = [ ] ; while ( $ i < $ len ) { if ( strpos ( self :: WHITESPACES , $ program [ $ i ] ) === false ) { try { $ form = self :: parseExpression ( substr ( $ program , $ i ) , $ offset ) ; if ( ! is_null ( $ form ) ) $ forms [ ] = $ form ; } catch ( ParseException $ e ) { throw new ParseException ( $ program , $ e -> offset + $ i ) ; } $ i += $ offset ; } else ++ $ i ; } return $ forms ; }
101	public function setPsr4 ( $ prefix , $ paths ) { if ( ! $ prefix ) { $ this -> fallbackDirsPsr4 = ( array ) $ paths ; } else { $ length = strlen ( $ prefix ) ; if ( '\\' !== $ prefix [ $ length - 1 ] ) { throw new \ InvalidArgumentException ( "A non-empty PSR-4 prefix must end with a namespace separator." ) ; } $ this -> prefixLengthsPsr4 [ $ prefix [ 0 ] ] [ $ prefix ] = $ length ; $ this -> prefixDirsPsr4 [ $ prefix ] = ( array ) $ paths ; } }
12809	private static function isPrimaryKey ( string $ table , string $ column ) : bool { return self :: getPrimaryKey ( $ table ) [ "column_name" ] === $ column ; }
233	public function quoteSimpleTableName ( $ name ) { if ( is_string ( $ this -> tableQuoteCharacter ) ) { $ startingCharacter = $ endingCharacter = $ this -> tableQuoteCharacter ; } else { list ( $ startingCharacter , $ endingCharacter ) = $ this -> tableQuoteCharacter ; } return strpos ( $ name , $ startingCharacter ) !== false ? $ name : $ startingCharacter . $ name . $ endingCharacter ; }
12132	static public function addParams ( $ url , $ params ) { $ query = parse_url ( $ url , PHP_URL_QUERY ) ; $ separator = ( Text :: isEmpty ( $ query ) ? "?" : "&" ) ; return Text :: concat ( $ separator , $ url , http_build_query ( $ params ) ) ; }
8818	public function files ( $ key = null , $ name = null ) { if ( is_null ( $ key ) ) { return $ _FILES ; } if ( isset ( $ _FILES [ $ key ] ) ) { if ( ! is_null ( $ name ) ) { return $ _FILES [ $ key ] [ $ name ] ; } return $ _FILES [ $ key ] ; } return false ; }
6248	public function getAll ( ) { $ permissions = $ this -> modules -> getAllPermissions ( ) ; $ permissions = array_merge ( $ permissions , $ this -> getCustom ( ) ) ; return array_unique ( $ permissions ) ; }
7125	static public function equals ( AddressInterface $ source , AddressInterface $ target ) { if ( ! ( $ source -> getCompany ( ) === $ target -> getCompany ( ) && $ source -> getGender ( ) === $ target -> getGender ( ) && $ source -> getFirstName ( ) === $ target -> getFirstName ( ) && $ source -> getLastName ( ) === $ target -> getLastName ( ) && $ source -> getStreet ( ) === $ target -> getStreet ( ) && $ source -> getComplement ( ) === $ target -> getComplement ( ) && $ source -> getSupplement ( ) === $ target -> getSupplement ( ) && $ source -> getExtra ( ) === $ target -> getExtra ( ) && $ source -> getCity ( ) === $ target -> getCity ( ) && $ source -> getPostalCode ( ) === $ target -> getPostalCode ( ) && $ source -> getDigicode1 ( ) === $ target -> getDigicode1 ( ) && $ source -> getDigicode2 ( ) === $ target -> getDigicode2 ( ) && $ source -> getIntercom ( ) === $ target -> getIntercom ( ) ) ) { return false ; } $ sourceCountryId = $ source -> getCountry ( ) ? $ source -> getCountry ( ) -> getId ( ) : null ; $ targetCountryId = $ target -> getCountry ( ) ? $ target -> getCountry ( ) -> getId ( ) : null ; if ( $ sourceCountryId != $ targetCountryId ) { return false ; } $ sourceStateId = $ source -> getState ( ) ? $ source -> getState ( ) -> getId ( ) : null ; $ targetStateId = $ target -> getState ( ) ? $ target -> getState ( ) -> getId ( ) : null ; if ( $ sourceStateId != $ targetStateId ) { return false ; } $ sourcePhone = ( string ) $ source -> getPhone ( ) ; $ targetPhone = ( string ) $ target -> getPhone ( ) ; if ( $ sourcePhone !== $ targetPhone ) { return false ; } $ sourceMobile = ( string ) $ source -> getMobile ( ) ; $ targetMobile = ( string ) $ target -> getMobile ( ) ; if ( $ sourceMobile !== $ targetMobile ) { return false ; } return true ; }
4986	public function executeAction ( $ name , array $ data = [ ] ) { if ( false !== strpos ( $ name , '.' ) ) { list ( $ name , $ childKey ) = explode ( '.' , $ name , 2 ) ; $ container = $ this -> getForm ( $ name ) ; return $ container -> executeAction ( $ childKey , $ data ) ; } return [ ] ; }
3592	protected function loadMetaAttributes ( ) { if ( ! array_key_exists ( 'metaAttributes' , $ this -> relations ) ) { $ this -> reloadMetaAttributes ( ) ; } $ attributes = $ this -> getRelation ( 'metaAttributes' ) ; if ( ! $ attributes instanceof AttributeBag ) { $ this -> setRelation ( 'metaAttributes' , ( new Attribute ) -> newBag ( $ attributes -> all ( ) ) ) ; } }
4349	private function normalizeArray ( $ cfg ) { $ return = array ( 'debug' => array ( ) , ) ; $ configKeys = $ this -> getConfigKeys ( ) ; foreach ( $ cfg as $ k => $ v ) { $ translated = false ; foreach ( $ configKeys as $ objName => $ objKeys ) { if ( $ k == $ objName && \ is_array ( $ v ) ) { $ return [ $ objName ] = isset ( $ return [ $ objName ] ) ? \ array_merge ( $ return [ $ objName ] , $ v ) : $ v ; $ translated = true ; break ; } elseif ( \ is_array ( $ v ) && isset ( $ configKeys [ $ k ] ) ) { continue ; } elseif ( \ in_array ( $ k , $ objKeys ) ) { $ return [ $ objName ] [ $ k ] = $ v ; $ translated = true ; break ; } } if ( ! $ translated ) { $ return [ 'debug' ] [ $ k ] = $ v ; } } if ( ! $ return [ 'debug' ] ) { unset ( $ return [ 'debug' ] ) ; } return $ return ; }
4041	public function render ( ModelToLabelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ viewSection = $ definition -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; $ listing = $ viewSection -> getListingConfig ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ data = array ( $ nativeItem -> parseValue ( 'html5' , $ renderSetting ) ) ; if ( $ listing -> getShowColumns ( ) ) { $ event -> setArgs ( $ data [ 0 ] [ 'html5' ] ) ; return ; } $ template = new Template ( $ renderSetting -> get ( 'template' ) ) ; $ renderSetting = self :: removeInvariantAttributes ( $ nativeItem , $ renderSetting ) ; $ template -> setData ( array ( 'settings' => $ renderSetting , 'items' => new Items ( array ( $ nativeItem ) ) , 'view' => $ renderSetting , 'data' => $ data ) ) ; $ event -> setLabel ( '%s' ) -> setArgs ( array ( $ template -> parse ( 'html5' ) ) ) ; }
11848	private function checkReadOnly ( ) { if ( true === $ this -> _readOnly ) { $ this -> _pushError ( '' , self :: ERR_READ_ONLY , 'This row has been marked read-only' ) ; return false ; } return true ; }
8199	public function expect ( $ type , $ value = null , $ message = null ) { $ token = $ this -> tokens [ $ this -> current ] ; if ( ! $ token -> test ( $ type , $ value ) ) { $ line = $ token -> getLine ( ) ; throw new Twig_Error_Syntax ( sprintf ( '%sUnexpected token "%s" of value "%s" ("%s" expected%s).' , $ message ? $ message . '. ' : '' , Twig_Token :: typeToEnglish ( $ token -> getType ( ) ) , $ token -> getValue ( ) , Twig_Token :: typeToEnglish ( $ type ) , $ value ? sprintf ( ' with value "%s"' , $ value ) : '' ) , $ line , $ this -> source ) ; } $ this -> next ( ) ; return $ token ; }
5692	public function baseTransform ( ) { parent :: baseTransform ( ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons_delete.js' ) ; return $ this -> setUseButtonTag ( true ) -> addExtraClass ( 'btn-danger-outline btn-hide-outline font-icon-trash-bin gridfield-better-buttons-delete' ) -> setAttribute ( "data-toggletext" , _t ( 'GridFieldBetterButtons.AREYOUSURE' , 'Yes. Delete this item.' ) ) -> setAttribute ( "data-confirmtext" , _t ( 'GridFieldDetailForm.CANCELDELETE' , 'No. Don\'t delete.' ) ) ; }
10845	protected function refreshProductBuyPrices ( ProductInterface $ product ) { $ buyPrice = $ product -> getBuyPrice ( ) ; $ grossAmount = $ buyPrice -> getGrossAmount ( ) ; $ taxRate = $ product -> getBuyPriceTax ( ) -> getValue ( ) ; $ netAmount = TaxHelper :: calculateNetPrice ( $ grossAmount , $ taxRate ) ; $ buyPrice -> setTaxRate ( $ taxRate ) ; $ buyPrice -> setTaxAmount ( $ grossAmount - $ netAmount ) ; $ buyPrice -> setNetAmount ( $ netAmount ) ; }
11040	function leaf_path_walk ( $ elements , $ rank , $ ptype , & $ i , $ cvalue ) { if ( count ( $ elements ) == 1 ) { $ elt [ $ ptype . ':' . $ i . ':' . $ elements [ 0 ] . ':' . $ cvalue ] = '' ; } else { $ element1 = array_shift ( $ elements ) ; $ elt [ _ETS_TEMPLATE . ':' . $ i . '.' . $ rank . ':' . $ element1 ] = $ this -> leaf_path_walk ( $ elements , $ rank + 1 , $ ptype , $ i , $ cvalue ) ; } return $ elt ; }
10082	protected function registerConfigurator ( ) { $ this -> app -> singleton ( 'auja.database' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; switch ( $ config [ 'database' ] ) { case 'mysql' : return new MySQLDatabaseHelper ( ) ; break ; default : throw new NoDatabaseHelperException ( 'No Auja database helper for ' . $ config [ 'database' ] ) ; break ; } } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Database\DatabaseHelper' , 'auja.database' ) ; $ this -> app -> singleton ( 'auja.configurator' , function ( $ app ) { return new AujaConfigurator ( $ app , $ app [ 'auja.database' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Config\AujaConfigurator' , 'auja.configurator' ) ; }
7916	public function initOptions ( ) { Ui :: addCssClasses ( $ this -> options , [ 'ui' , 'message' ] ) ; if ( ! empty ( $ this -> header ) && isset ( $ this -> header [ 'options' ] ) ) { Ui :: addCssClass ( $ this -> header [ 'options' ] , 'header' ) ; } if ( isset ( $ this -> icon ) ) { Ui :: addCssClass ( $ this -> options , 'icon' ) ; } }
9645	public function makePdo ( array $ config , $ connection = null ) { if ( ! isset ( $ config [ 'driver' ] ) && ! isset ( $ config [ 'dsn' ] ) ) { throw new InvalidArgumentException ( 'DSN or driver must be set' ) ; } $ options = isset ( $ config [ 'pdo_options' ] ) ? $ config [ 'pdo_options' ] : [ ] ; unset ( $ config [ 'pdo_options' ] ) ; $ options = array_replace ( $ this -> defaultPdoOptions , $ options ) ; $ initCommands = isset ( $ config [ 'pdo_init_commands' ] ) ? $ config [ 'pdo_init_commands' ] : [ ] ; unset ( $ config [ 'pdo_init_commands' ] ) ; if ( isset ( $ config [ 'driver' ] ) && $ config [ 'driver' ] == 'sqlite' ) { $ this -> validate ( $ config , 'path' , $ connection ) ; $ dsn = $ this -> makeSqliteDsn ( $ config [ 'path' ] ) ; return $ this -> makePdoInner ( $ dsn , null , null , $ options , $ initCommands ) ; } elseif ( isset ( $ config [ 'dsn' ] ) && strpos ( $ config [ 'dsn' ] , 'sqlite:' ) === 0 ) { return $ this -> makePdoInner ( $ config [ 'dsn' ] , null , null , $ options , $ initCommands ) ; } $ this -> validate ( $ config , 'username' , $ connection , false ) ; $ username = $ config [ 'username' ] ; unset ( $ config [ 'username' ] ) ; $ this -> validate ( $ config , 'password' , $ connection , true ) ; $ password = $ config [ 'password' ] ; unset ( $ config [ 'password' ] ) ; if ( isset ( $ config [ 'dsn' ] ) ) { $ dsn = $ config [ 'dsn' ] ; } else { $ driver = $ config [ 'driver' ] ; unset ( $ config [ 'driver' ] ) ; $ this -> validate ( $ config , 'host' , $ connection ) ; $ this -> validate ( $ config , 'dbname' , $ connection ) ; $ dsn = $ this -> makeDsn ( $ driver , $ config ) ; } return $ this -> makePdoInner ( $ dsn , $ username , $ password , $ options , $ initCommands ) ; }
1955	public function getStyleSheets ( Contao \ DataContainer $ dc ) { $ intPid = $ dc -> activeRecord -> pid ; if ( Contao \ Input :: get ( 'act' ) == 'overrideAll' ) { $ intPid = Contao \ Input :: get ( 'id' ) ; } $ objStyleSheet = $ this -> Database -> prepare ( "SELECT id, name FROM tl_style_sheet WHERE pid=?" ) -> execute ( $ intPid ) ; if ( $ objStyleSheet -> numRows < 1 ) { return array ( ) ; } $ return = array ( ) ; while ( $ objStyleSheet -> next ( ) ) { $ return [ $ objStyleSheet -> id ] = $ objStyleSheet -> name ; } return $ return ; }
3272	public function setConfig ( Config $ config ) { $ this -> config = $ config ; $ this -> getDatabase ( ) -> setConfig ( $ config ) ; }
5759	public function buildPermission ( int $ id , string $ title , ? string $ description , bool $ active , \ DateTimeImmutable $ created , array $ roles ) : Permission { return new Permission ( $ id , $ title , $ description , $ active , $ created , $ roles ) ; }
5700	protected function getDefaultButtonList ( $ config ) { $ new = ( $ this -> owner -> ID == 0 ) ; $ list = $ new ? Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_create" : "create" ) : Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_edit" : "edit" ) ; return $ list ? : array ( ) ; }
4445	public function failed ( ) : array { $ results = json_decode ( $ this -> client -> failed ( ) , true ) ; return is_array ( $ results ) ? $ results : [ ] ; }
2422	public static function deleteResource ( $ strResource ) { $ objModel = FilesModel :: findByPath ( $ strResource ) ; if ( $ objModel !== null ) { $ objModel -> delete ( ) ; } $ objFiles = FilesModel :: findMultipleByBasepath ( $ strResource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objFiles -> delete ( ) ; } } static :: updateFolderHashes ( \ dirname ( $ strResource ) ) ; return null ; }
9049	private function renderButtons ( $ rendered , $ buttons ) { foreach ( $ buttons as $ button ) { if ( ! isset ( $ button [ 'name' ] ) ) { throw new ControlException ( "Button must have at least a name!" ) ; } $ buttonType = isset ( $ button [ 'type' ] ) ? $ button [ 'type' ] : "submit" ; $ id = isset ( $ button [ 'id' ] ) ? $ button [ 'id' ] : $ button [ 'name' ] ; $ class = isset ( $ button [ 'class' ] ) ? $ button [ 'class' ] : $ button [ 'name' ] ; $ label = isset ( $ button [ 'label' ] ) ? $ button [ 'label' ] : $ button [ 'name' ] ; $ rendered .= sprintf ( '<button type="%s" id="%s" class="%s" name="%s">%s</button>' , $ buttonType , $ id , $ class , $ button [ 'name' ] , $ label ) ; } return $ rendered ; }
1322	private function parseHeaders ( $ header ) { $ headers = [ ] ; foreach ( explode ( "\r\n" , $ header ) as $ line ) { if ( strpos ( $ line , ':' ) !== false ) { list ( $ key , $ value ) = explode ( ': ' , $ line ) ; $ key = str_replace ( '-' , '_' , strtolower ( $ key ) ) ; $ headers [ $ key ] = trim ( $ value ) ; } } return $ headers ; }
7687	function Misc_CellRef ( $ Col , $ Row ) { $ r = '' ; $ x = $ Col ; do { $ x = $ x - 1 ; $ c = ( $ x % 26 ) ; $ x = ( $ x - $ c ) / 26 ; $ r = chr ( 65 + $ c ) . $ r ; } while ( $ x > 0 ) ; return $ r . $ Row ; }
3188	public function getFirstTimestamp ( $ tags ) { $ range = $ this -> getRange ( $ tags ) ; $ last = false ; if ( count ( $ range ) ) { $ last = $ range [ 0 ] -> getTimestamp ( ) ; } return $ last ; }
3426	public function sort ( $ by , $ order = 'ASC' ) { $ this -> sort = is_array ( $ by ) ? $ by : [ $ by => $ order ] ; return $ this ; }
1360	public static function custom ( $ mediaType ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , null ) ; }
7986	public function getModels ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/models' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
673	public function alterColumn ( $ table , $ column , $ type ) { $ columnName = $ this -> db -> quoteColumnName ( $ column ) ; $ tableName = $ this -> db -> quoteTableName ( $ table ) ; if ( preg_match ( '/^(DROP|SET|RESET)\s+/i' , $ type ) ) { return "ALTER TABLE {$tableName} ALTER COLUMN {$columnName} {$type}" ; } $ type = 'TYPE ' . $ this -> getColumnType ( $ type ) ; $ multiAlterStatement = [ ] ; $ constraintPrefix = preg_replace ( '/[^a-z0-9_]/i' , '' , $ table . '_' . $ column ) ; if ( preg_match ( '/\s+DEFAULT\s+(["\']?\w+["\']?)/i' , $ type , $ matches ) ) { $ type = preg_replace ( '/\s+DEFAULT\s+(["\']?\w+["\']?)/i' , '' , $ type ) ; $ multiAlterStatement [ ] = "ALTER COLUMN {$columnName} SET DEFAULT {$matches[1]}" ; } else { $ multiAlterStatement [ ] = "ALTER COLUMN {$columnName} DROP DEFAULT" ; } $ type = preg_replace ( '/\s+NOT\s+NULL/i' , '' , $ type , - 1 , $ count ) ; if ( $ count ) { $ multiAlterStatement [ ] = "ALTER COLUMN {$columnName} SET NOT NULL" ; } else { $ type = preg_replace ( '/\s+NULL/i' , '' , $ type ) ; $ multiAlterStatement [ ] = "ALTER COLUMN {$columnName} DROP NOT NULL" ; } if ( preg_match ( '/\s+CHECK\s+\((.+)\)/i' , $ type , $ matches ) ) { $ type = preg_replace ( '/\s+CHECK\s+\((.+)\)/i' , '' , $ type ) ; $ multiAlterStatement [ ] = "ADD CONSTRAINT {$constraintPrefix}_check CHECK ({$matches[1]})" ; } $ type = preg_replace ( '/\s+UNIQUE/i' , '' , $ type , - 1 , $ count ) ; if ( $ count ) { $ multiAlterStatement [ ] = "ADD UNIQUE ({$columnName})" ; } array_unshift ( $ multiAlterStatement , "ALTER COLUMN {$columnName} {$type}" ) ; return 'ALTER TABLE ' . $ tableName . ' ' . implode ( ', ' , $ multiAlterStatement ) ; }
11436	private function _removeDirectory ( $ sName ) { if ( $ rDirectory = opendir ( $ sName ) ) { while ( ( $ sFile = readdir ( $ rDirectory ) ) !== false ) { if ( $ sFile > '0' && filetype ( $ sName . $ sFile ) == "file" ) { unlink ( $ sName . $ sFile ) ; } elseif ( $ sFile > '0' && filetype ( $ sName . $ sFile ) == "dir" ) { remove_dir ( $ sName . $ sFile . "\\" ) ; } } closedir ( $ rDirectory ) ; rmdir ( $ sName ) ; } }
5005	protected function attachListeners ( $ services , $ eventManager , $ listeners ) { $ lazyListeners = [ ] ; foreach ( $ listeners as $ name => $ options ) { $ options = $ this -> normalizeListenerOptions ( $ name , $ options ) ; if ( $ options [ 'lazy' ] && null !== $ options [ 'attach' ] ) { foreach ( $ options [ 'attach' ] as $ spec ) { $ lazyListeners [ ] = [ 'service' => $ options [ 'service' ] , 'event' => $ spec [ 'event' ] , 'method' => $ spec [ 'method' ] , 'priority' => $ spec [ 'priority' ] , ] ; } continue ; } if ( $ services -> has ( $ options [ 'service' ] ) ) { $ listener = $ services -> get ( $ options [ 'service' ] ) ; } elseif ( class_exists ( $ options [ 'service' ] , true ) ) { $ listener = new $ options [ 'service' ] ( ) ; } else { throw new \ UnexpectedValueException ( sprintf ( 'Class or service %s does not exists. Cannot create listener instance.' , $ options [ 'service' ] ) ) ; } if ( $ listener instanceof ListenerAggregateInterface ) { $ listener -> attach ( $ eventManager , $ options [ 'priority' ] ) ; continue ; } foreach ( $ options [ 'attach' ] as $ spec ) { $ callback = $ spec [ 'method' ] ? [ $ listener , $ spec [ 'method' ] ] : $ listener ; $ eventManager -> attach ( $ spec [ 'event' ] , $ callback , $ spec [ 'priority' ] ) ; } } if ( ! empty ( $ lazyListeners ) ) { $ aggregate = $ services -> get ( 'Core/Listener/DeferredListenerAggregate' ) ; $ aggregate -> setListeners ( $ lazyListeners ) -> attach ( $ eventManager ) ; } }
10259	public function getPhone ( $ state_code = null , $ zip = null , $ include_toll_free = false ) { if ( ! empty ( $ zip ) ) { $ areacodes = Zipcode :: where ( 'zip' , $ zip ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> area_codes ; } else { $ state_code = ! empty ( $ state_code ) ? $ state_code : $ this -> getState ( ) -> code ; $ areacodes = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> area_codes ; } $ code_list = explode ( ',' , $ areacodes ) ; if ( $ include_toll_free === true ) { $ code_list [ ] = 800 ; $ code_list [ ] = 888 ; $ code_list [ ] = 877 ; $ code_list [ ] = 866 ; $ code_list [ ] = 855 ; } $ areacode = $ this -> fromArray ( $ code_list ) ; $ prefix = rand ( 100 , 999 ) ; $ number = rand ( 1 , 9999 ) ; return $ areacode . '-' . $ prefix . '-' . str_pad ( $ number , 4 , '0' , STR_PAD_LEFT ) ; }
3206	private function parse_response_headers ( $ headers ) { $ head = array ( ) ; foreach ( $ headers as $ key => $ value ) { $ tag = explode ( ':' , $ value , 2 ) ; if ( isset ( $ tag [ 1 ] ) ) { $ head [ trim ( $ tag [ 0 ] ) ] = trim ( $ tag [ 1 ] ) ; } else { $ head [ ] = $ value ; if ( preg_match ( '`HTTP/[0-9\.]+\s+([0-9]+)`' , $ value , $ out ) ) { $ head [ 'response_code' ] = intval ( $ out [ 1 ] ) ; } } } return $ head ; }
1084	private function expectKeyword ( $ value ) { $ token = $ this -> lexer -> token ; if ( $ token -> kind === Token :: NAME && $ token -> value === $ value ) { $ this -> lexer -> advance ( ) ; return $ token ; } throw new SyntaxError ( $ this -> lexer -> source , $ token -> start , 'Expected "' . $ value . '", found ' . $ token -> getDescription ( ) ) ; }
5536	public function addFrame ( $ page , $ name = false ) { $ this -> frames [ ] = $ page ; if ( $ name ) { $ this -> names [ $ name ] = count ( $ this -> frames ) - 1 ; } }
1884	public static function count ( array $ arrOptions ) { $ strQuery = "SELECT COUNT(*) AS count FROM " . $ arrOptions [ 'table' ] ; if ( $ arrOptions [ 'column' ] !== null ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } return $ strQuery ; }
5378	public function wrapIsEnabled ( ) { if ( $ this -> getAttribute ( 'cols' ) ) { $ wrap = $ this -> getAttribute ( 'wrap' ) ; if ( ( $ wrap === 'physical' ) || ( $ wrap === 'hard' ) ) { return true ; } } return false ; }
2195	protected function resendActivationMail ( MemberModel $ objMember ) { if ( $ objMember -> disable == '' ) { return ; } $ this -> strTemplate = 'mod_message' ; $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = null ; $ models = OptInModel :: findByRelatedTableAndIds ( 'tl_member' , array ( $ objMember -> id ) ) ; foreach ( $ models as $ model ) { if ( ( $ token = $ optIn -> find ( $ model -> token ) ) && $ token -> isValid ( ) && ! $ token -> isConfirmed ( ) ) { $ optInToken = $ token ; break ; } } if ( $ optInToken === null ) { return ; } $ optInToken -> send ( ) ; $ this -> Template -> type = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resendActivation' ] ; }
1935	public function generate ( $ objPage ) { $ this -> redirect ( $ this -> getForwardUrl ( $ objPage ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; }
6974	private function buildAssociationValue ( ClassMetadata $ metadata , $ propertyPath , $ value ) { $ childMetadata = $ this -> manager -> getClassMetadata ( $ metadata -> getAssociationTargetClass ( $ propertyPath ) ) ; if ( $ metadata -> isSingleValuedAssociation ( $ propertyPath ) ) { if ( is_string ( $ value ) && '#' === substr ( $ value , 0 , 1 ) ) { return $ this -> getReference ( substr ( $ value , 1 ) ) ; } elseif ( is_array ( $ value ) ) { return $ this -> buildEntity ( $ childMetadata , $ value ) ; } throw new \ Exception ( "Unexpected value for single association '$propertyPath'." ) ; } elseif ( $ metadata -> isCollectionValuedAssociation ( $ propertyPath ) ) { if ( ! is_array ( $ value ) ) { throw new \ Exception ( 'Expected array.' ) ; } $ builtValue = [ ] ; foreach ( $ value as $ childData ) { if ( is_string ( $ childData ) && '#' === substr ( $ childData , 0 , 1 ) ) { array_push ( $ builtValue , $ this -> getReference ( substr ( $ childData , 1 ) ) ) ; } elseif ( is_array ( $ value ) ) { array_push ( $ builtValue , $ this -> buildEntity ( $ childMetadata , $ childData ) ) ; } else { throw new \ Exception ( "Unexpected value for association '$propertyPath'." ) ; } } return $ builtValue ; } throw new \ Exception ( "Unexpected association path '$propertyPath'." ) ; }
2834	public function startRendering ( Mage_Core_Block_Abstract $ block ) { if ( $ this -> isRendering ) { $ this -> renderedCount ++ ; Mage :: log ( "Recursive block rendering {$this->getName()}" , Zend_Log :: DEBUG ) ; return ; } $ this -> init ( $ block ) ; $ this -> isRendering = true ; $ this -> renderedCount ++ ; $ this -> renderedAt = microtime ( true ) ; if ( self :: $ startRenderingTime === null ) { self :: $ startRenderingTime = $ this -> renderedAt ; } }
7755	private function doDeserialize ( $ data , $ entity ) { $ metadata = $ this -> hydraApi -> getMetadataFor ( get_class ( $ entity ) ) ; if ( null === $ metadata ) { throw new \ Exception ( sprintf ( '"%s" cannot be serialized as it is not documented.' , get_class ( $ data ) ) ) ; } $ vocabPrefix = $ this -> router -> generate ( 'hydra_vocab' , array ( ) , true ) . '#' ; $ typeIri = ( $ metadata -> isExternalReference ( ) ) ? $ metadata -> getIri ( ) : $ vocabPrefix . $ metadata -> getIri ( ) ; $ graph = JsonLD :: getDocument ( $ data ) -> getGraph ( ) ; $ node = $ graph -> getNodesByType ( $ typeIri ) ; if ( 1 !== count ( $ node ) ) { throw new RuntimeException ( 'The passed data contains ' . count ( $ node ) . ' nodes of the type ' . $ typeIri . '; expected 1.' ) ; } $ node = reset ( $ node ) ; foreach ( $ metadata -> getProperties ( ) as $ property ) { if ( $ property -> isReadOnly ( ) ) { continue ; } if ( null !== ( $ route = $ property -> getRoute ( ) ) ) { continue ; } $ propertyIri = ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : $ vocabPrefix . $ property -> getIri ( ) ; $ value = $ node -> getProperty ( $ propertyIri ) ; if ( $ value instanceof \ ML \ JsonLD \ Value ) { $ value = $ value -> getValue ( ) ; } if ( ! is_null ( $ value ) && $ this -> hydraApi -> hasNormalizer ( $ property -> getType ( ) ) ) { $ normalizer = $ this -> hydraApi -> getNormalizer ( $ property -> getType ( ) ) ; $ value = $ normalizer -> denormalize ( $ value , $ property -> getType ( ) ) ; } $ property -> setValue ( $ entity , $ value ) ; } return $ entity ; }
7526	public static function parseFile ( $ path , $ context = null ) { $ html_str = file_get_contents ( $ path , false , $ context ) ; return static :: parseStr ( $ html_str ) ; }
10040	public function load ( $ pFilename ) { $ spreadsheet = new Spreadsheet ( ) ; $ spreadsheet -> removeSheetByIndex ( 0 ) ; return $ this -> loadIntoExisting ( $ pFilename , $ spreadsheet ) ; }
2251	public static function convertRelativeUrls ( $ strContent , $ strBase = '' , $ blnHrefOnly = false ) { if ( $ strBase == '' ) { $ strBase = Environment :: get ( 'base' ) ; } $ search = $ blnHrefOnly ? 'href' : 'href|src' ; $ arrUrls = preg_split ( '/((' . $ search . ')="([^"]+)")/i' , $ strContent , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; $ strContent = '' ; for ( $ i = 0 , $ c = \ count ( $ arrUrls ) ; $ i < $ c ; $ i += 4 ) { $ strContent .= $ arrUrls [ $ i ] ; if ( ! isset ( $ arrUrls [ $ i + 2 ] ) ) { continue ; } $ strAttribute = $ arrUrls [ $ i + 2 ] ; $ strUrl = $ arrUrls [ $ i + 3 ] ; if ( ! preg_match ( '@^(?:[a-z0-9]+:|#)@i' , $ strUrl ) ) { $ strUrl = $ strBase . ( ( $ strUrl != '/' ) ? $ strUrl : '' ) ; } $ strContent .= $ strAttribute . '="' . $ strUrl . '"' ; } return $ strContent ; }
996	public function offsetExists ( $ offset ) { if ( $ offset === false ) { return $ this -> falseValueIsSet ; } if ( $ offset === true ) { return $ this -> trueValueIsSet ; } if ( is_int ( $ offset ) || is_string ( $ offset ) ) { return array_key_exists ( $ offset , $ this -> standardStore ) ; } if ( is_float ( $ offset ) ) { return array_key_exists ( ( string ) $ offset , $ this -> floatStore ) ; } if ( is_object ( $ offset ) ) { return $ this -> objectStore -> offsetExists ( $ offset ) ; } if ( is_array ( $ offset ) ) { foreach ( $ this -> arrayKeys as $ index => $ entry ) { if ( $ entry === $ offset ) { $ this -> lastArrayKey = $ offset ; $ this -> lastArrayValue = $ this -> arrayValues [ $ index ] ; return true ; } } } if ( $ offset === null ) { return $ this -> nullValueIsSet ; } return false ; }
11562	protected function getWeekWordsUnitsAndShortcuts ( $ lang ) { if ( ! isset ( $ this -> weekWords [ $ lang ] ) ) { if ( isset ( static :: $ WeekWordsDefault [ $ lang ] ) ) { $ this -> weekWords [ $ lang ] = explode ( ',' , static :: $ WeekWordsDefault [ $ lang ] ) ; } else { $ this -> weekWords [ $ lang ] = [ ] ; } } if ( ! $ this -> units ) $ this -> units = explode ( ',' , static :: $ UnitsDefault ) ; if ( ! isset ( $ this -> shortcuts [ $ lang ] ) ) { if ( isset ( static :: $ ShortcutsDefault [ $ lang ] ) ) { $ shortcuts = [ ] ; foreach ( static :: $ ShortcutsDefault [ $ lang ] as $ shortcutsLocalized ) foreach ( $ shortcutsLocalized as $ shortcut ) $ shortcuts [ $ shortcut ] = str_replace ( ' ' , '&nbsp;' , $ shortcut ) ; $ this -> shortcuts [ $ lang ] = & $ shortcuts ; } else { $ this -> shortcuts [ $ lang ] = [ ] ; } } return [ $ this -> weekWords [ $ lang ] , $ this -> units , $ this -> shortcuts [ $ lang ] ] ; }
2988	public function hasResourceInAnnotation ( $ bundle ) { if ( ! file_exists ( $ this -> file ) ) { return false ; } $ config = Yaml :: parse ( file_get_contents ( $ this -> file ) ) ; $ search = sprintf ( '@%s/Controller/' , $ bundle ) ; foreach ( $ config as $ resource ) { if ( array_key_exists ( 'resource' , $ resource ) ) { return $ resource [ 'resource' ] === $ search ; } } return false ; }
7181	protected function generateNumber ( PaymentInterface $ payment ) { if ( 0 == strlen ( $ payment -> getNumber ( ) ) ) { $ this -> numberGenerator -> generate ( $ payment ) ; return true ; } return false ; }
7168	public function updateTab ( $ tabLabel , array $ formInputs ) { $ tabExists = false ; foreach ( $ this -> getTabs ( ) as $ tabIndex => $ tabInfo ) { if ( array_get ( $ tabInfo , 'label' ) === $ tabLabel ) { $ this -> currentTab = $ tabIndex ; $ this -> currentInputsGroup = null ; if ( count ( ( array ) array_get ( $ tabInfo , 'groups' , [ ] ) ) === 1 && is_int ( array_keys ( $ tabInfo [ 'groups' ] ) [ 0 ] ) ) { $ this -> currentInputsGroup = array_keys ( $ tabInfo [ 'groups' ] ) [ 0 ] ; } $ tabExists = true ; break ; } } if ( ! $ tabExists ) { $ this -> newTab ( $ tabLabel ) ; } $ this -> setFormInputs ( $ formInputs ) ; $ this -> currentTab = null ; $ this -> currentInputsGroup = null ; return $ this ; }
787	public function formName ( ) { $ reflector = new ReflectionClass ( $ this ) ; if ( PHP_VERSION_ID >= 70000 && $ reflector -> isAnonymous ( ) ) { throw new InvalidConfigException ( 'The "formName()" method should be explicitly defined for anonymous models' ) ; } return $ reflector -> getShortName ( ) ; }
5263	public function fields ( $ fields = false ) { if ( $ fields === false ) { $ this -> query [ 'body' ] [ '_source' ] = false ; } elseif ( ( array ) $ fields == [ '*' ] ) { unset ( $ this -> query [ 'body' ] [ '_source' ] ) ; } else { $ this -> query [ 'body' ] [ '_source' ] = $ fields ; } return $ this ; }
3246	public function onCallbackFail ( $ order , $ data = null ) { $ this -> statusCode = 'failed' ; $ this -> detail = 'failed callback' ; $ this -> didCallback = true ; }
3724	private function buildCacheService ( ContainerBuilder $ container , array $ config ) { if ( ! $ config [ 'enable_cache' ] ) { $ cache = $ container -> getDefinition ( 'metamodels.cache' ) ; $ cache -> setClass ( ArrayCache :: class ) ; $ cache -> setArguments ( [ ] ) ; $ container -> setParameter ( 'metamodels.cache_dir' , null ) ; return ; } $ container -> setParameter ( 'metamodels.cache_dir' , $ config [ 'cache_dir' ] ) ; }
11417	public function addPiwikCode ( ViewEvent $ event ) { $ model = $ event -> getModel ( ) ; if ( ! $ model instanceof \ Zend \ View \ Model \ ViewModel ) { return ; } $ options = $ model -> getOptions ( ) ; if ( array_key_exists ( 'has_parent' , $ options ) && $ options [ 'has_parent' ] ) { return ; } $ renderer = $ event -> getRenderer ( ) ; if ( ! $ renderer instanceof \ Zend \ View \ Renderer \ PhpRenderer ) { return ; } $ config = $ this -> serviceManager -> get ( 'config' ) ; $ piwikConfig = $ config [ 'orgHeiglPiwik' ] ; $ code = str_replace ( array_map ( function ( $ e ) { return '%%' . $ e . '%%' ; } , array_keys ( $ piwikConfig ) ) , array_values ( $ piwikConfig ) , $ this -> template ) ; $ renderer -> headScript ( ) -> appendScript ( '//<![CDATA[' . "\n" . $ code . "\n" . '//]]>' ) ; return $ renderer ; }
6841	public function getCache ( $ key ) { return isset ( $ this -> caches [ $ key ] ) ? $ this -> caches [ $ key ] : null ; }
212	protected function initClientOptions ( ) { $ options = $ this -> clientOptions ; foreach ( $ options as $ key => $ value ) { if ( ! $ value instanceof JsExpression && in_array ( $ key , [ 'oncomplete' , 'onincomplete' , 'oncleared' , 'onKeyUp' , 'onKeyDown' , 'onBeforeMask' , 'onBeforePaste' , 'onUnMask' , 'isComplete' , 'determineActiveMasksetIndex' , ] , true ) ) { $ options [ $ key ] = new JsExpression ( $ value ) ; } } $ this -> clientOptions = $ options ; }
12411	public function lists ( $ begin , $ count ) { $ params = [ 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_LIST , $ params ] ) ; }
2411	public function exportTheme ( DataContainer $ dc ) { $ objTheme = $ this -> Database -> prepare ( "SELECT * FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objTheme -> numRows < 1 ) { return ; } $ strName = Utf8 :: toAscii ( $ objTheme -> name ) ; $ strName = strtolower ( str_replace ( ' ' , '_' , $ strName ) ) ; $ strName = preg_replace ( '/[^A-Za-z0-9._-]/' , '' , $ strName ) ; $ strName = basename ( $ strName ) ; $ xml = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ xml -> formatOutput = true ; $ tables = $ xml -> createElement ( 'tables' ) ; $ tables = $ xml -> appendChild ( $ tables ) ; $ this -> addTableTlTheme ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlStyleSheet ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlImageSize ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlModule ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlLayout ( $ xml , $ tables , $ objTheme ) ; $ strTmp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objArchive = new ZipWriter ( 'system/tmp/' . $ strTmp ) ; $ this -> addTableTlFiles ( $ xml , $ tables , $ objTheme , $ objArchive ) ; $ this -> addTemplatesToArchive ( $ objArchive , $ objTheme -> templates ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] as $ callback ) { System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ xml , $ objArchive , $ objTheme -> id ) ; } } $ objArchive -> addString ( $ xml -> saveXML ( ) , 'theme.xml' ) ; $ objArchive -> close ( ) ; $ objFile = new File ( 'system/tmp/' . $ strTmp ) ; $ objFile -> sendToBrowser ( $ strName . '.cto' ) ; }
1148	protected function getAttributeName ( $ attribute ) { $ attributeArray = explode ( '.' , $ attribute ) ; if ( count ( $ attributeArray ) > 1 ) { return $ attributeArray [ 0 ] . '[' . implode ( '][' , array_slice ( $ attributeArray , 1 ) ) . ']' ; } return $ attribute ; }
10607	public function checkLoggedInAction ( ) { $ data = array ( 'logged' => 0 , 'data' => null ) ; if ( ! $ this -> zfcUserAuthentication ( ) -> hasIdentity ( ) ) { return new JsonModel ( $ data ) ; } $ identity = $ this -> zfcUserAuthentication ( ) -> getIdentity ( ) ; $ data [ 'logged' ] = 1 ; $ userModel = $ this -> getServiceLocator ( ) -> get ( 'user.model.user' ) ; $ data [ 'data' ] = $ userModel -> init ( $ identity , $ this -> getServiceLocator ( ) ) ; return new JsonModel ( $ data ) ; }
6834	private function getFindNewBySupplierQuery ( ) { if ( null !== $ this -> findNewBySupplierQuery ) { return $ this -> findNewBySupplierQuery ; } $ qb = $ this -> createQueryBuilder ( ) ; $ as = $ this -> getAlias ( ) ; return $ this -> findNewBySupplierQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.supplier' , ':supplier' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.state' , ':state' ) ) -> getQuery ( ) -> setParameter ( 'state' , Model \ SupplierOrderStates :: STATE_NEW ) ; }
3080	public static function isAssessmentSectionAdaptive ( AssessmentSection $ section , $ namespace = '' ) { if ( $ namespace === '' ) { $ namespace = CatService :: QTI_2X_ADAPTIVE_XML_NAMESPACE ; } $ isAdaptive = false ; if ( ( $ selection = $ section -> getSelection ( ) ) !== null && ( ( $ xmlExtension = $ selection -> getXml ( ) ) ) !== null ) { $ xpath = new \ DOMXPath ( $ xmlExtension ) ; $ xpath -> registerNamespace ( 'ais' , $ namespace ) ; if ( $ xpath -> query ( './/ais:adaptiveItemSelection' , $ xmlExtension ) -> length > 0 ) { $ isAdaptive = true ; } } return $ isAdaptive ; }
4365	public function onErrorHighPri ( Event $ error ) { $ this -> throttleDataRead ( ) ; $ hash = $ error [ 'hash' ] ; $ error [ 'email' ] = ( $ error [ 'type' ] & $ this -> cfg [ 'emailMask' ] ) && $ error [ 'isFirstOccur' ] && $ this -> cfg [ 'emailTo' ] ; $ error [ 'stats' ] = array ( 'tsEmailed' => 0 , 'countSince' => 0 , 'emailedTo' => '' , ) ; if ( isset ( $ this -> throttleData [ 'errors' ] [ $ hash ] ) ) { $ stats = \ array_intersect_key ( $ this -> throttleData [ 'errors' ] [ $ hash ] , $ error [ 'stats' ] ) ; $ error [ 'stats' ] = \ array_merge ( $ error [ 'stats' ] , $ stats ) ; } return ; }
9704	public function writeWorkbook ( array $ pWorksheetSizes ) { $ this -> worksheetSizes = $ pWorksheetSizes ; $ total_worksheets = $ this -> spreadsheet -> getSheetCount ( ) ; $ this -> storeBof ( 0x0005 ) ; $ this -> writeCodepage ( ) ; $ this -> writeWindow1 ( ) ; $ this -> writeDateMode ( ) ; $ this -> writeAllFonts ( ) ; $ this -> writeAllNumberFormats ( ) ; $ this -> writeAllXfs ( ) ; $ this -> writeAllStyles ( ) ; $ this -> writePalette ( ) ; $ part3 = '' ; if ( $ this -> countryCode != - 1 ) { $ part3 .= $ this -> writeCountry ( ) ; } $ part3 .= $ this -> writeRecalcId ( ) ; $ part3 .= $ this -> writeSupbookInternal ( ) ; $ part3 .= $ this -> writeExternalsheetBiff8 ( ) ; $ part3 .= $ this -> writeAllDefinedNamesBiff8 ( ) ; $ part3 .= $ this -> writeMsoDrawingGroup ( ) ; $ part3 .= $ this -> writeSharedStringsTable ( ) ; $ part3 .= $ this -> writeEof ( ) ; $ this -> calcSheetOffsets ( ) ; for ( $ i = 0 ; $ i < $ total_worksheets ; ++ $ i ) { $ this -> writeBoundSheet ( $ this -> spreadsheet -> getSheet ( $ i ) , $ this -> worksheetOffsets [ $ i ] ) ; } $ this -> _data .= $ part3 ; return $ this -> _data ; }
3253	public function clear ( ) { DB :: table ( Config :: get ( 'shop.item_table' ) ) -> where ( 'cart_id' , $ this -> attributes [ 'id' ] ) -> delete ( ) ; $ this -> resetCalculations ( ) ; return $ this ; }
4705	public function slice ( $ offset , $ length = null ) { return new Collection ( array_slice ( $ this -> objects , $ offset , $ length ) ) ; }
8175	protected function optimizePrintNode ( Twig_NodeInterface $ node , Twig_Environment $ env ) { if ( ! $ node instanceof Twig_Node_Print ) { return $ node ; } $ exprNode = $ node -> getNode ( 'expr' ) ; if ( $ exprNode instanceof Twig_Node_Expression_BlockReference || $ exprNode instanceof Twig_Node_Expression_Parent ) { $ exprNode -> setAttribute ( 'output' , true ) ; return $ exprNode ; } return $ node ; }
10816	public static function write ( $ messages , $ style = '' , $ length = 0 , $ suffix = '' ) { if ( self :: $ silent ) { return ; } if ( ! is_array ( $ messages ) ) { $ messages = [ ( string ) $ messages ] ; } if ( count ( $ messages ) > 0 ) { foreach ( $ messages as $ message ) { if ( $ length > 0 ) { $ message = str_pad ( $ message , $ length , ' ' , STR_PAD_RIGHT ) ; } print ( Style :: applyStyle ( $ message , $ style ) ) ; if ( $ suffix != '' ) { print ( $ suffix ) ; } } } }
1607	public function save ( $ uri , $ to , $ type , $ siteId = null , $ id = null ) { if ( $ siteId === 'null' ) $ siteId = null ; if ( $ id ) { $ record = RedirectRecord :: findOne ( compact ( 'id' ) ) ; if ( ! $ record ) return 'Unable to find redirect with ID: ' . $ id ; } else { $ existing = RedirectRecord :: findOne ( compact ( 'uri' , 'siteId' ) ) ; if ( $ existing ) return 'A redirect with that URI already exists!' ; $ record = new RedirectRecord ( ) ; } $ record -> uri = $ uri ; $ record -> to = $ to ; $ record -> type = $ type ; if ( $ siteId !== false ) $ record -> siteId = $ siteId ; if ( ! $ record -> save ( ) ) return $ record -> getErrors ( ) ; return $ record -> id ; }
4956	protected function proxy ( ) { $ args = func_get_args ( ) ; $ method = array_shift ( $ args ) ; $ callback = array ( $ this -> object , $ method ) ; if ( ! is_callable ( $ callback ) ) { throw new \ BadMethodCallException ( sprintf ( 'Cannot proxy "%s" to "%s": Unknown method.' , $ method , get_class ( $ this -> object ) ) ) ; } $ return = call_user_func_array ( $ callback , $ args ) ; if ( $ return === $ this -> object ) { $ return = $ this ; } return $ return ; }
1534	protected function methodForRelation ( $ field ) { if ( method_exists ( $ this , $ field ) ) { return $ field ; } $ method = Str :: camelize ( $ field ) ; return method_exists ( $ this , $ method ) ? $ method : null ; }
5164	public function send ( EmailSender $ email , array $ data = [ ] ) { $ result = ( new DataBuilderManager ( ) ) -> validateRaw ( $ email -> data_builder , $ data ) ; dispatch ( new SendEmail ( $ email , $ data , $ this -> getAgent ( ) ) ) ; return $ result ; }
5881	public function processUpload_postProcessAction ( & $ filename , DataHandler $ pObj ) { $ filename = static :: $ imageResizer -> processFile ( $ filename , '' , '' , null , $ GLOBALS [ 'BE_USER' ] , [ $ this , 'notify' ] ) ; }
9011	public function tinytext ( string $ charset = null ) : self { $ this -> type = 'tinytext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
806	private function findReturnAnnotations ( Tokens $ tokens , $ index ) { do { $ index = $ tokens -> getPrevNonWhitespace ( $ index ) ; } while ( $ tokens [ $ index ] -> isGivenKind ( [ T_ABSTRACT , T_FINAL , T_PRIVATE , T_PROTECTED , T_PUBLIC , T_STATIC , ] ) ) ; if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DOC_COMMENT ) ) { return [ ] ; } $ doc = new DocBlock ( $ tokens [ $ index ] -> getContent ( ) ) ; return $ doc -> getAnnotationsOfType ( 'return' ) ; }
11963	private function setParam ( $ key , $ value , $ allowed_keys ) { if ( in_array ( $ key , $ allowed_keys ) ) { $ this -> { $ key } = $ value ; } }
7977	public function deleteSecondaryDnsDomains ( $ domain2delete ) { json_decode ( self :: getClient ( ) -> deleteSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2delete ) ) ; return true ; }
12281	public function getCode ( ) { $ data = [ 'component_appid' => $ this -> getAppId ( ) , ] ; $ result = $ this -> parseJSON ( 'json' , [ self :: CREATE_PRE_AUTH_CODE , $ data ] ) ; if ( empty ( $ result [ 'pre_auth_code' ] ) ) { throw new InvalidArgumentException ( 'Invalid response.' ) ; } return $ result [ 'pre_auth_code' ] ; }
4439	public static function unregister ( ? array $ signals = null ) : void { if ( empty ( $ signals ) ) { $ signals = self :: KNOWN_SIGNALS ; } foreach ( $ signals as $ signal ) { if ( is_string ( $ signal ) ) { if ( ! defined ( $ signal ) ) { continue ; } $ signal = constant ( $ signal ) ; } pcntl_signal ( $ signal , SIG_DFL ) ; } }
3756	public function createVariant ( ConfigInterface $ objConfig ) { $ objItem = $ this -> getMetaModel ( ) -> findById ( $ objConfig -> getId ( ) ) -> varCopy ( ) ; if ( ! $ objItem ) { return null ; } $ model = new Model ( $ objItem ) ; $ model -> setMeta ( $ model :: IS_CHANGED , true ) ; return $ model ; }
3018	public function createPost ( $ blogName , $ data ) { $ path = $ this -> blogPath ( $ blogName , '/post' ) ; return $ this -> postRequest ( $ path , $ data , false ) ; }
2227	public function editHeader ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> User -> canEditFieldsOf ( 'tl_faq_category' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
2674	public function deleteAcl ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/acl/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; }
7963	public function ipSetMonitoringNotifications ( $ ip , $ frequency = 'once' , $ email = '' , $ sms = array ( ) ) { return json_decode ( self :: getClient ( ) -> ipSetMonitoringNotifications ( $ this -> id , $ ip , $ frequency , $ email , $ sms ) ) ; }
8534	public function setChargeInstrumentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ChargeInstrumentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4478	public function getInstance ( ) { if ( $ this -> instance === null ) { $ this -> instance = $ this -> jobFactory -> create ( $ this -> klass , $ this -> getPerformMethod ( ) ) ; } return $ this -> instance ; }
12948	public function removeTagValues ( $ tags ) { $ this -> _tagsList = array_diff ( $ this -> getTagValues ( ) , $ this -> parseTags ( $ tags ) ) ; $ this -> updateOwnerTags ( ) ; }
4299	public function countReset ( $ label = 'default' , $ flags = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; if ( \ count ( $ args ) == 1 && \ is_int ( $ args [ 0 ] ) ) { $ label = 'default' ; $ flags = $ args [ 0 ] ; } else { $ args = \ array_combine ( array ( 'label' , 'flags' ) , \ array_replace ( array ( 'default' , 0 ) , $ args ) ) ; \ extract ( $ args ) ; } if ( isset ( $ this -> data [ 'counts' ] [ $ label ] ) ) { $ this -> data [ 'counts' ] [ $ label ] = 0 ; $ args = array ( ( string ) $ label , 0 , ) ; } else { $ args = array ( 'Counter \'' . $ label . '\' doesn\'t exist.' ) ; } if ( ! ( $ flags & self :: COUNT_NO_OUT ) ) { $ this -> appendLog ( 'countReset' , $ args , $ meta ) ; } }
11325	public static function hasSuffix ( $ string , $ suffix ) { $ len = strlen ( $ suffix ) ; if ( $ len && substr ( $ string , - $ len ) === $ suffix ) { return true ; } return false ; }
9723	private function getTemporaryFolder ( ) { $ tempFolder = sys_get_temp_dir ( ) . '/phpspreadsheet' ; if ( ! is_dir ( $ tempFolder ) ) { if ( ! mkdir ( $ tempFolder ) && ! is_dir ( $ tempFolder ) ) { throw new \ RuntimeException ( sprintf ( 'Directory "%s" was not created' , $ tempFolder ) ) ; } } return $ tempFolder ; }
4301	public function groupSummary ( $ priority = 0 ) { array ( $ priority ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'priority' => 0 ) , array ( 'priority' ) ) ; $ this -> data [ 'groupPriorityStack' ] [ ] = $ meta [ 'priority' ] ; $ this -> setLogDest ( 'summary' ) ; $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; }
6459	public function fillInWithValueOfFieldOfCurrentUser ( $ field , $ user_field ) { if ( ! empty ( $ this -> user ) && ! $ this -> user -> uid ) { throw new \ Exception ( 'Anonymous user have no fields' ) ; } $ entity = new EntityDrupalWrapper ( 'user' ) ; $ wrapper = $ entity -> wrapper ( $ this -> user -> uid ) ; $ user_field = $ entity -> getFieldNameByLocator ( $ user_field ) ; if ( empty ( $ wrapper -> { $ user_field } ) ) { throw new \ InvalidArgumentException ( sprintf ( 'User entity has no "%s" field.' , $ user_field ) ) ; } $ value = $ wrapper -> { $ user_field } -> value ( ) ; if ( empty ( $ value ) ) { throw new \ UnexpectedValueException ( 'The value of "%s" field is empty.' , $ user_field ) ; } $ this -> fillField ( $ field , $ value ) ; }
9355	public function det ( ) { if ( ! $ this -> isSquare ( ) ) { throw new \ RuntimeException ( 'Cannot compute determinant of non square matrix!' ) ; } if ( $ this -> size -> rows == 2 ) { return $ this -> get ( 0 , 0 ) * $ this -> get ( 1 , 1 ) - $ this -> get ( 0 , 1 ) * $ this -> get ( 1 , 0 ) ; } else { $ int_out = 0 ; $ arr_row = $ this -> arr [ 0 ] ; foreach ( $ arr_row as $ n => $ v ) { $ int_out += pow ( - 1 , $ n + 2 ) * $ v * $ this -> subMatrix ( 0 , $ n ) -> det ( ) ; } return $ int_out ; } }
9707	private function writeDefinedNameBiff8 ( $ name , $ formulaData , $ sheetIndex = 0 , $ isBuiltIn = false ) { $ record = 0x0018 ; $ options = $ isBuiltIn ? 0x20 : 0x00 ; $ nlen = StringHelper :: countCharacters ( $ name ) ; $ name = substr ( StringHelper :: UTF8toBIFF8UnicodeLong ( $ name ) , 2 ) ; $ sz = strlen ( $ formulaData ) ; $ data = pack ( 'vCCvvvCCCC' , $ options , 0 , $ nlen , $ sz , 0 , $ sheetIndex , 0 , 0 , 0 , 0 ) . $ name . $ formulaData ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
6582	public static function getSession ( ServerRequestInterface $ request ) : SessionDataHolder { $ session = $ request -> getAttribute ( static :: REQ_ATTR ) ; if ( ! $ session instanceof SessionDataHolder ) { throw new SessionMiddlewareException ( "No session object is available in the request attributes" ) ; } return $ session ; }
3850	public function getServiceContainer ( ) { if ( ! $ this -> serviceContainer ) { $ this -> useDefaultServiceContainer ( ) ; } if ( is_callable ( $ this -> serviceContainer ) ) { return $ this -> serviceContainer = $ this -> serviceContainer -> __invoke ( ) ; } return $ this -> serviceContainer ; }
7088	public function error ( Callable $ action = null ) { if ( $ action ) $ this -> errorAction = $ action ; return $ this -> errorAction ; }
4710	public function detab ( Text $ text , array $ options = array ( ) ) { $ text -> replace ( '/(.*?)\t/' , function ( Text $ whole , Text $ string ) use ( $ options ) { return $ string . str_repeat ( ' ' , $ options [ 'tabWidth' ] - $ string -> getLength ( ) % $ options [ 'tabWidth' ] ) ; } ) ; }
9192	public function init ( ) { if ( $ this -> isInitialized ( ) ) return true ; $ sm = $ this -> getServiceManager ( ) ; $ defaultListeners = $ sm -> get ( 'yimaTheme.Manager.ListenerAggregate' ) ; if ( $ defaultListeners instanceof self ) $ defaultListeners -> manager = $ this ; $ sharedEvents = $ this -> getEventManager ( ) -> getSharedManager ( ) ; $ sharedEvents -> attachAggregate ( $ defaultListeners ) ; $ this -> isInitialized = true ; return $ this ; }
4896	public function start ( $ type = self :: TYPE_INFO , array $ options = array ( ) ) { if ( $ this -> captureLock ) { throw new \ RuntimeException ( 'Cannot start capture, there is already a capture running.' ) ; } $ this -> captureLock = true ; $ this -> captureType = $ type ; $ this -> captureOptions = $ options ; ob_start ( ) ; return $ this ; }
7009	private function formatL ( & $ str ) { if ( strstr ( $ str , '%L' ) ) $ str = str_replace ( '%L' , strtolower ( $ this -> dayName ( true ) ) , $ str ) ; }
6923	private function buildKey ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false ) { return sprintf ( '%s-%s-%s' , $ taxGroup -> getId ( ) , $ country -> getId ( ) , ( int ) $ business ) ; }
1495	public static function createCustom ( ... $ mediaTypes ) : self { $ encodings = new self ( ) ; $ encodings -> stack = collect ( $ mediaTypes ) -> map ( function ( $ mediaType ) { return Encoding :: custom ( $ mediaType ) ; } ) -> all ( ) ; return $ encodings ; }
11561	public function SetUnits ( $ units ) { if ( is_array ( $ units ) ) { $ this -> units = $ units ; } else { $ this -> units = explode ( ',' , ( string ) $ units ) ; } return $ this ; }
8346	public static function route ( $ method , $ path , $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'route' , 'method' => $ method , 'path' => $ path , 'action' => $ action , 'namespace' => self :: $ namespace , 'subdomain' => self :: $ subdomain , 'uri' => self :: $ uri ) ; } }
2709	public function beforeSave ( \ Magento \ Config \ Model \ Config $ subject ) { $ data = $ subject -> getData ( ) ; if ( ! empty ( $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ) ) { $ currentCacheConfig = $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ; $ oldCacheConfig = $ this -> scopeConfig -> getValue ( \ Magento \ PageCache \ Model \ Config :: XML_PAGECACHE_TYPE ) ; if ( $ oldCacheConfig == \ Fastly \ Cdn \ Model \ Config :: FASTLY && $ currentCacheConfig != $ oldCacheConfig ) { $ this -> purge = true ; } } }
9940	public function calculateColumnWidths ( ) { $ autoSizes = [ ] ; foreach ( $ this -> getColumnDimensions ( ) as $ colDimension ) { if ( $ colDimension -> getAutoSize ( ) ) { $ autoSizes [ $ colDimension -> getColumnIndex ( ) ] = - 1 ; } } if ( ! empty ( $ autoSizes ) ) { $ isMergeCell = [ ] ; foreach ( $ this -> getMergeCells ( ) as $ cells ) { foreach ( Coordinate :: extractAllCellReferencesInRange ( $ cells ) as $ cellReference ) { $ isMergeCell [ $ cellReference ] = true ; } } foreach ( $ this -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ this -> getCell ( $ coordinate , false ) ; if ( $ cell !== null && isset ( $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] ) ) { $ isMerged = isset ( $ isMergeCell [ $ this -> cellCollection -> getCurrentCoordinate ( ) ] ) ; $ isMergedButProceed = false ; if ( $ isMerged && $ cell -> isMergeRangeValueCell ( ) ) { $ range = $ cell -> getMergeRange ( ) ; $ rangeBoundaries = Coordinate :: rangeDimension ( $ range ) ; if ( $ rangeBoundaries [ 0 ] == 1 ) { $ isMergedButProceed = true ; } } if ( ! $ isMerged || $ isMergedButProceed ) { $ cellValue = NumberFormat :: toFormattedString ( $ cell -> getCalculatedValue ( ) , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] = max ( ( float ) $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] , ( float ) Shared \ Font :: calculateColumnWidth ( $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getFont ( ) , $ cellValue , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getAlignment ( ) -> getTextRotation ( ) , $ this -> getParent ( ) -> getDefaultStyle ( ) -> getFont ( ) ) ) ; } } } foreach ( $ autoSizes as $ columnIndex => $ width ) { if ( $ width == - 1 ) { $ width = $ this -> getDefaultColumnDimension ( ) -> getWidth ( ) ; } $ this -> getColumnDimension ( $ columnIndex ) -> setWidth ( $ width ) ; } } return $ this ; }
5983	protected function withOAuth2MiddleWare ( HandlerStack $ stack ) { if ( ! ( $ this -> oauth2Middleware instanceof OAuthMiddleware ) ) { $ oauthClient = new Client ( [ 'base_uri' => $ this -> basepath , 'verify' => $ this -> verifyCertificates , 'headers' => [ 'User-Agent' => 'qbank3api-phpwrapper/2 (qbankapi: 1; swagger: 1.1)' , ] , ] ) ; $ config = [ PasswordCredentials :: CONFIG_USERNAME => $ this -> credentials -> getUsername ( ) , PasswordCredentials :: CONFIG_PASSWORD => $ this -> credentials -> getPassword ( ) , PasswordCredentials :: CONFIG_CLIENT_ID => $ this -> credentials -> getClientId ( ) , PasswordCredentials :: CONFIG_TOKEN_URL => 'oauth2/token' , ] ; $ this -> oauth2Middleware = new OAuthMiddleware ( $ oauthClient , new PasswordCredentials ( $ oauthClient , $ config ) , new RefreshToken ( $ oauthClient , $ config ) ) ; $ tokens = $ this -> getTokens ( ) ; if ( ! empty ( $ tokens [ 'accessTokens' ] ) ) { $ this -> oauth2Middleware -> setAccessToken ( $ tokens [ 'accessTokens' ] ) ; } if ( ! empty ( $ tokens [ 'refreshTokens' ] ) ) { $ this -> oauth2Middleware -> setRefreshToken ( $ tokens [ 'refreshTokens' ] ) ; } } $ stack -> push ( $ this -> oauth2Middleware -> onBefore ( ) ) ; $ stack -> push ( $ this -> oauth2Middleware -> onFailure ( 3 ) ) ; return $ stack ; }
6924	protected function getFindOneBySaleQuery ( ) { if ( null !== $ this -> findOneBySaleQuery ) { return $ this -> findOneBySaleQuery ; } $ qb = $ this -> createQueryBuilder ( 'r' ) ; $ e = $ qb -> expr ( ) ; return $ this -> findOneBySaleQuery = $ qb -> andWhere ( $ e -> orX ( $ e -> andX ( $ e -> eq ( 'r.vatMode' , ':net_mode' ) , $ e -> lte ( 'r.baseTotal' , ':net_base' ) ) , $ e -> andX ( $ e -> eq ( 'r.vatMode' , ':ati_mode' ) , $ e -> lte ( 'r.baseTotal' , ':ati_base' ) ) ) ) -> andWhere ( $ e -> orX ( 'r.methods IS EMPTY' , $ e -> isMemberOf ( ':method' , 'r.methods' ) ) ) -> andWhere ( $ e -> orX ( 'r.countries IS EMPTY' , $ e -> isMemberOf ( ':country' , 'r.countries' ) ) ) -> andWhere ( $ e -> orX ( 'r.customerGroups IS EMPTY' , $ e -> isMemberOf ( ':group' , 'r.customerGroups' ) ) ) -> andWhere ( $ e -> orX ( 'r.startAt IS NULL' , $ e -> lte ( 'r.startAt' , ':date' ) ) ) -> andWhere ( $ e -> orX ( 'r.endAt IS NULL' , $ e -> gte ( 'r.endAt' , ':date' ) ) ) -> getQuery ( ) -> setMaxResults ( 1 ) -> useQueryCache ( true ) ; }
4605	public function setEntityUuid ( ? string $ entityUuid ) { if ( null !== $ entityUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ entityUuid ) ) { throw new InvalidArgumentException ( 'Entity uuid is not valid.' ) ; } } $ this -> entityUuid = $ entityUuid ; return $ this ; }
8464	public static function getDomain ( $ url = false ) { if ( $ url ) { preg_match ( '/([\w]+[.]){1,}[a-z]+/' , $ url , $ matches ) ; return isset ( $ matches [ 0 ] ) ? $ matches [ 0 ] : false ; } return $ _SERVER [ 'SERVER_NAME' ] ; }
2566	protected function checkAnyNotEmpty ( ) { $ foundNotEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! empty ( $ arg ) ) { $ foundNotEmpty = true ; break ; } } return $ foundNotEmpty ; }
5973	public function events ( ) { if ( ! $ this -> events instanceof EventsController ) { $ this -> events = new EventsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> events -> setLogger ( $ this -> logger ) ; } return $ this -> events ; }
5192	public function map ( array $ methods , string $ path , RequestHandlerInterface $ handler ) : Route { return $ this -> routes [ ] = new Route ( $ methods , $ path , $ handler ) ; }
7239	protected function getAddressFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerAddressInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerAddressInterface :: class ) ; } return $ resource ; }
213	public function registerClientScript ( ) { $ js = '' ; $ view = $ this -> getView ( ) ; $ this -> initClientOptions ( ) ; if ( ! empty ( $ this -> mask ) ) { $ this -> clientOptions [ 'mask' ] = $ this -> mask ; } $ this -> hashPluginOptions ( $ view ) ; if ( is_array ( $ this -> definitions ) && ! empty ( $ this -> definitions ) ) { $ js .= ucfirst ( self :: PLUGIN_NAME ) . '.extendDefinitions(' . Json :: htmlEncode ( $ this -> definitions ) . ');' ; } if ( is_array ( $ this -> aliases ) && ! empty ( $ this -> aliases ) ) { $ js .= ucfirst ( self :: PLUGIN_NAME ) . '.extendAliases(' . Json :: htmlEncode ( $ this -> aliases ) . ');' ; } $ id = $ this -> options [ 'id' ] ; $ js .= 'jQuery("#' . $ id . '").' . self :: PLUGIN_NAME . '(' . $ this -> _hashVar . ');' ; MaskedInputAsset :: register ( $ view ) ; $ view -> registerJs ( $ js ) ; }
10312	function getRecipientsCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeDeletedRecipients = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeDeletedRecipients ) ) $ params [ 'exclude_deleted_recipients' ] = ( $ excludeDeletedRecipients == true ) ? "true" : "false" ; return $ this -> get ( 'reports/recipients/count' , $ params ) ; }
1513	public function create ( StoreInterface $ store , CreateResource $ request ) { $ record = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doCreate ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ record ) ) { return $ record ; } return $ this -> reply ( ) -> created ( $ record ) ; }
1099	protected function resolveNode ( $ node ) { if ( $ node instanceof \ Baum \ Node ) return $ node -> reload ( ) ; return $ this -> node -> newNestedSetQuery ( ) -> find ( $ node ) ; }
12645	public function render ( ElementInterface $ element ) { $ label = $ element -> getLabel ( ) ; if ( isset ( $ label ) && '' !== $ label ) { if ( null !== ( $ translator = $ this -> getTranslator ( ) ) ) { $ label = $ translator -> translate ( $ label , $ this -> getTranslatorTextDomain ( ) ) ; $ element -> setLabel ( $ label ) ; } } return parent :: render ( $ element ) ; }
3472	public function extract ( string $ namespace ) : Config { $ extracted = $ this -> get ( $ namespace ) ; if ( ! is_array ( $ extracted ) ) { throw ConfigException :: forExtractionFailure ( $ namespace ) ; } return new self ( $ extracted ) ; }
10946	public function post ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getBodyParams ( ) ; } else { return $ this -> getBodyParam ( $ name , $ defaultValue ) ; } }
1406	protected function getDefaultAttributes ( Model $ model ) { $ defaults = [ ] ; if ( $ this -> hasCreatedAtAttribute ( $ model ) ) { $ createdAt = $ model -> getCreatedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ createdAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ createdAt , $ field ) ; } if ( $ this -> hasUpdatedAtAttribute ( $ model ) ) { $ updatedAt = $ model -> getUpdatedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ updatedAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ updatedAt , $ field ) ; } if ( $ this -> hasDeletedAtAttribute ( $ model ) ) { $ deletedAt = $ model -> getDeletedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ deletedAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ deletedAt , $ field ) ; } return $ defaults ; }
4613	public function withScalarValue ( $ value ) { $ this -> match = $ value ; $ this -> lowerBound = null ; $ this -> upperBound = null ; return $ this ; }
11303	protected static function checkPath ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new NotFoundException ( Message :: get ( Message :: MSG_PATH_NOTFOUND , $ path ) , Message :: MSG_PATH_NOTFOUND ) ; } if ( ! is_readable ( $ path ) ) { throw new RuntimeException ( Message :: get ( Message :: MSG_PATH_NONREADABLE , $ path ) , Message :: MSG_PATH_NONREADABLE ) ; } }
4580	public function encrypt ( Encryptable $ model ) : EncryptionService { if ( $ model -> getEncrypted ( ) ) { return $ this ; } $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ property -> setAccessible ( true ) ; $ property -> setValue ( $ model , $ this -> cipherService -> encrypt ( $ property -> getValue ( $ model ) ) ) ; } $ model -> setEncrypted ( true ) ; return $ this ; }
999	public function getType ( $ name ) { if ( ! isset ( $ this -> resolvedTypes [ $ name ] ) ) { $ type = $ this -> loadType ( $ name ) ; if ( ! $ type ) { return null ; } $ this -> resolvedTypes [ $ name ] = $ type ; } return $ this -> resolvedTypes [ $ name ] ; }
5802	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ permissions = $ this -> permissionsEntityMapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) ) ; } catch ( QueryFailureException $ e ) { $ permissions = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ permissions ) ; }
2824	public function getExpirationDate ( $ currentDate ) { $ numberOfDays = Mage :: helper ( 'sheep_debug' ) -> getPersistLifetime ( ) ; return date ( self :: DATE_FORMAT , strtotime ( "-{$numberOfDays} days {$currentDate}" ) ) ; }
774	protected function extractMessages ( $ fileName , $ translator , $ ignoreCategories = [ ] ) { $ this -> stdout ( 'Extracting messages from ' ) ; $ this -> stdout ( $ fileName , Console :: FG_CYAN ) ; $ this -> stdout ( "...\n" ) ; $ subject = file_get_contents ( $ fileName ) ; $ messages = [ ] ; $ tokens = token_get_all ( $ subject ) ; foreach ( ( array ) $ translator as $ currentTranslator ) { $ translatorTokens = token_get_all ( '<?php ' . $ currentTranslator ) ; array_shift ( $ translatorTokens ) ; $ messages = array_merge_recursive ( $ messages , $ this -> extractMessagesFromTokens ( $ tokens , $ translatorTokens , $ ignoreCategories ) ) ; } $ this -> stdout ( "\n" ) ; return $ messages ; }
9045	protected function getConfig ( ) { if ( $ this -> config === null ) { if ( file_exists ( $ this -> filename ) ) { $ this -> filename = realpath ( $ this -> filename ) ; $ this -> config = new Config ( include $ this -> filename , true ) ; } else { $ this -> filename = getcwd ( ) . $ this -> filename ; $ this -> config = new Config ( [ ] , true ) ; } } return $ this -> config ; }
3524	private function fetch ( $ account_id ) { if ( ! $ account_id ) return null ; $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_API . 'stats/accountId/' . $ account_id . '/bulk/window/alltime' , $ this -> access_token ) ; $ this -> display_name = Account :: getDisplayNameFromID ( str_replace ( "-" , "" , $ this -> account_id ) , $ this -> access_token ) ; $ compiledStats = [ ] ; foreach ( $ data as $ stat ) { $ parsed = $ this -> parseStatItem ( $ stat ) ; $ compiledStats = array_merge_recursive ( $ compiledStats , $ parsed ) ; } $ platforms = [ ] ; foreach ( $ compiledStats as $ key => $ platform ) { $ platforms [ $ key ] = new Platform ( $ platform ) ; } return $ platforms ; }
9176	public function getPlugins ( ) { foreach ( $ this -> getOperations ( ) as $ operation ) { if ( $ this -> getOperation ( ) -> equals ( $ operation ) ) { return $ operation -> getPlugins ( ) ; } } throw new \ Exception ( sprintf ( 'Can\'t find any plugins for operation %s' , $ this -> getOperation ( ) ) ) ; }
5319	public function isSuccessExit ( ) { $ this -> exitCode = pcntl_wexitstatus ( $ this -> status ) ; return ( pcntl_wifexited ( $ this -> status ) && ( $ this -> exitCode === 0 ) ) ; }
3099	public function getItems ( RunnerServiceContext $ serviceContext ) { $ this -> getRunnerService ( ) -> assertQtiRunnerServiceContext ( $ serviceContext ) ; $ runnerService = $ this -> getRunnerService ( ) ; $ testMap = $ runnerService -> getTestMap ( $ serviceContext ) ; $ items = [ ] ; foreach ( $ this -> getItemIdentifiersFromTestMap ( $ testMap ) as $ itemIdentifier ) { $ itemRef = $ runnerService -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; $ items [ $ itemIdentifier ] = [ 'baseUrl' => $ runnerService -> getItemPublicUrl ( $ serviceContext , $ itemRef ) , 'itemData' => $ this -> getItemData ( $ serviceContext , $ itemRef ) , 'itemState' => $ runnerService -> getItemState ( $ serviceContext , $ itemIdentifier ) , 'itemIdentifier' => $ itemIdentifier , 'portableElements' => $ runnerService -> getItemPortableElements ( $ serviceContext , $ itemRef ) , ] ; } return $ items ; }
5387	public function setValue ( $ values ) { $ values = $ this -> makeArray ( $ values ) ; if ( ! $ this -> valuesArePossible ( $ values ) ) { return false ; } $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { $ possible = $ widgets [ $ i ] -> getAttribute ( 'value' ) ; if ( in_array ( $ widgets [ $ i ] -> getAttribute ( 'value' ) , $ values ) ) { $ widgets [ $ i ] -> setValue ( $ possible ) ; } else { $ widgets [ $ i ] -> setValue ( false ) ; } } return true ; }
7971	public function getIncoming ( $ domain , $ id ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( $ id !== 0 && ! $ id ) throw new BadMethodCallException ( 'Parameter $id is missing.' ) ; $ id = intval ( $ id ) ; try { $ r = $ this -> get ( 'sms/' . $ domain . '/incoming/' . $ id ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
12271	public function getRoute ( ) : string { $ uri = $ _SERVER [ 'REQUEST_URI' ] ; if ( $ this -> uriBase != '/' ) { $ uri = str_replace ( $ this -> uriBase , '/' , $ uri ) ; } $ pos = strpos ( $ uri , '?' ) ; if ( $ pos !== false ) { $ uri = substr ( $ uri , 0 , $ pos ) ; } return $ uri ; }
4314	private function doGroup ( $ method , $ args ) { $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ this -> rootInstance -> groupStackRef [ ] = array ( 'channel' => $ meta [ 'channel' ] , 'collect' => $ this -> cfg [ 'collect' ] , ) ; if ( ! $ this -> cfg [ 'collect' ] ) { return ; } if ( empty ( $ args ) ) { $ caller = $ this -> utilities -> getCallerInfo ( ) ; if ( isset ( $ caller [ 'class' ] ) ) { $ args [ ] = $ caller [ 'class' ] . $ caller [ 'type' ] . $ caller [ 'function' ] ; $ meta [ 'isMethodName' ] = true ; } elseif ( isset ( $ caller [ 'function' ] ) ) { $ args [ ] = $ caller [ 'function' ] ; } else { $ args [ ] = 'group' ; } } $ this -> appendLog ( $ method , $ args , $ meta ) ; }
8551	public function setPerformanceBondRefundEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PerformanceBondRefundEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8355	private function buildModel ( string $ modelName , array $ modelDefinition ) { $ mapping = Mapping :: get ( $ this -> mapping ) ; $ definition = $ this -> getDefinition ( ) ; $ database = GlobalDatabase :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ tableName = null ; if ( isset ( $ modelDefinition [ 'name' ] ) === true ) { $ tableName = $ modelDefinition [ 'name' ] ; } else { $ tableName = Helper :: codifyName ( $ this -> mapping ) . '_' . Helper :: codifyName ( $ modelName ) ; } if ( isset ( $ modelDefinition [ 'fields' ] ) === false ) { throw new InvalidSchemaDefinition ( 'model "' . $ modelName . '" has no field' ) ; } $ statement = Mutation \ AddTable :: statement ( $ database , $ this -> getDefinition ( ) , $ this -> mapping , $ tableName , $ modelName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } if ( isset ( $ modelDefinition [ 'indexes' ] ) === true ) { foreach ( $ modelDefinition [ 'indexes' ] as $ indexName => $ indexDefinition ) { $ statement = Mutation \ AddIndex :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ indexName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } if ( isset ( $ modelDefinition [ 'uniques' ] ) === true ) { foreach ( $ modelDefinition [ 'uniques' ] as $ uniqueName => $ uniqueDefinition ) { $ statement = Mutation \ AddUnique :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ uniqueName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } echo $ modelName . ' - Done' . PHP_EOL ; }
6662	public function get ( $ url , $ params = [ ] ) { if ( ! is_array ( $ params ) ) { throw new HttpClientException ( HttpClientErrorMessages :: INVALID_QUERY_PARAMS ) ; } $ params = $ this -> filterParams ( $ params ) ; $ this -> lastRequestParams = $ params ; $ this -> lastRequestUrl = $ this -> buildUrl ( $ url , $ params ) ; return $ this -> curlAgent -> get ( $ this -> lastRequestUrl , $ this -> rawResponse ) ; }
4807	public function schedule_event ( ) { if ( $ this -> is_scheduled ( $ this -> args [ 'name' ] ) ) { return ; } if ( $ this -> args [ 'run_on_creation' ] ) { call_user_func ( $ this -> args [ 'cb' ] , $ this -> args [ 'args' ] ) ; } if ( $ this -> args [ 'schedule' ] === 'schedule' ) { wp_schedule_event ( $ this -> args [ 'time' ] , $ this -> args [ 'recurrence' ] , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } elseif ( $ this -> args [ 'schedule' ] === 'single' ) { wp_schedule_single_event ( $ this -> args [ 'recurrence' ] , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } if ( is_multisite ( ) && ! wp_is_large_network ( ) ) { $ sites = ( array ) get_site_option ( $ this -> args [ 'name' ] . '_sites' , array ( ) ) ; $ sites [ ] = get_current_blog_id ( ) ; update_site_option ( $ this -> args [ 'name' ] . '_sites' , $ sites ) ; } return true ; }
7691	function OpenMXL_GarbageCollector ( ) { if ( ( count ( $ this -> IdxToCheck ) == 0 ) && ( count ( $ this -> OtbsSheetSlidesDelete ) == 0 ) ) return ; $ pic_path = $ this -> ExtInfo [ 'pic_path' ] ; $ pic_path_len = strlen ( $ pic_path ) ; $ rels_ext = '.rels' ; $ rels_ext_len = strlen ( $ rels_ext ) ; $ pictures = array ( ) ; $ rels = array ( ) ; foreach ( $ this -> CdFileLst as $ idx => $ f ) { $ n = $ f [ 'v_name' ] ; if ( substr ( $ n , 0 , $ pic_path_len ) == $ pic_path ) { $ short = basename ( $ pic_path ) . '/' . basename ( $ n ) ; $ pictures [ ] = array ( 'name' => $ n , 'idx' => $ idx , 'nbr' => 0 , 'short' => $ short ) ; } elseif ( substr ( $ n , - $ rels_ext_len ) == $ rels_ext ) { if ( $ this -> FileGetState ( $ idx ) != 'd' ) $ rels [ $ n ] = $ idx ; } } foreach ( $ rels as $ n => $ idx ) { $ txt = $ this -> TbsStoreGet ( $ idx , 'GarbageCollector' ) ; foreach ( $ pictures as $ i => $ info ) { if ( strpos ( $ txt , $ info [ 'short' ] . '"' ) !== false ) $ pictures [ $ i ] [ 'nbr' ] ++ ; } } foreach ( $ pictures as $ info ) { if ( $ info [ 'nbr' ] == 0 ) $ this -> FileReplace ( $ info [ 'idx' ] , false ) ; } }
9746	public function setQuarter ( $ quarter ) { if ( ! $ quarter ) { return $ this ; } if ( ! ( $ quarter instanceof Quarter ) ) { $ quarter = new Quarter ( $ quarter ) ; } if ( $ quarter -> isEmpty ( ) ) { $ this -> invalidArguments ( '10005' ) ; } return $ this -> setParameter ( 'quarter' , $ quarter ) ; }
10047	protected function copyRecursive ( $ src , $ dst , $ depth , Logger $ logger ) { if ( $ depth == 0 ) { return ; } if ( ! is_file ( $ src ) && ! is_dir ( $ src ) ) { $ logger -> log ( "$src is not a valid source." , Logger :: WARNING ) ; return ; } if ( ! is_readable ( $ src ) ) { $ logger -> log ( "$src is not readable, skipping." , Logger :: WARNING ) ; return ; } if ( is_file ( $ dst ) || is_dir ( $ dst ) ) { $ logger -> log ( "$dst already exists, and cannot be overwritten." , Logger :: WARNING ) ; return ; } if ( is_dir ( $ src ) ) { mkdir ( $ dst ) ; } elseif ( is_file ( $ src ) ) { copy ( $ src , $ dst ) ; return ; } $ dh = opendir ( $ src ) ; while ( ( $ file = readdir ( $ dh ) ) !== false ) { if ( ( $ file === '.' ) || ( $ file === '..' ) ) { continue ; } $ this -> copyRecursive ( $ src . '/' . $ file , $ dst . '/' . $ file , $ depth - 1 , $ logger ) ; } }
891	public function setTypes ( array $ types ) { $ pattern = '/' . preg_quote ( $ this -> getTypesContent ( ) , '/' ) . '/' ; $ this -> lines [ 0 ] -> setContent ( Preg :: replace ( $ pattern , implode ( '|' , $ types ) , $ this -> lines [ 0 ] -> getContent ( ) , 1 ) ) ; $ this -> clearCache ( ) ; }
8424	public function generate ( Request $ request ) { if ( count ( $ request -> getArgs ( ) ) != 1 ) { echo 'Wrong arguments.' . PHP_EOL . 'Usage : db/generate mapping_name' . PHP_EOL ; } else { $ mapping = $ request -> getArgs ( ) [ 0 ] ; $ schema = Schema :: getSchema ( $ mapping ) ; $ schema -> generateModels ( ) ; } }
5277	public function where ( $ column , $ param1 = null , $ param2 = null , $ type = 'and' ) { if ( ! in_array ( $ type , array ( 'and' , 'or' , 'where' ) ) ) { throw new \ Exception ( 'Invalid where type "' . $ type . '"' ) ; } $ sub_type = is_null ( $ param1 ) ? $ type : $ param1 ; if ( empty ( $ this -> statements [ 'wheres' ] ) ) { $ type = 'where' ; } if ( is_array ( $ column ) ) { $ subquery = array ( ) ; foreach ( $ column as $ value ) { if ( ! isset ( $ value [ 2 ] ) ) { $ value [ 2 ] = $ value [ 1 ] ; $ value [ 1 ] = '=' ; } $ subquery [ ] = $ this -> generateWhere ( $ value [ 0 ] , $ value [ 1 ] , $ value [ 2 ] , empty ( $ subquery ) ? '' : $ sub_type ) ; } $ this -> statements [ 'wheres' ] [ ] = $ type . ' ( ' . trim ( join ( ' ' , $ subquery ) ) . ' )' ; return $ this ; } $ this -> statements [ 'wheres' ] [ ] = $ this -> generateWhere ( $ column , $ param1 , $ param2 , $ type ) ; return $ this ; }
12607	public static function makeSafe ( $ file ) { $ regex = [ '#(\.){2,}#' , '#[^A-Za-z0-9\.\_\- ]#' , '#^\.#' , ] ; $ file = rtrim ( $ file , '.' ) ; $ clean = preg_replace ( $ regex , ' ' , $ file ) ; $ clean = preg_replace ( "/[ \_]/" , '-' , $ clean ) ; $ clean = preg_replace ( "/[\-]+/" , '-' , $ clean ) ; return $ clean ; }
2037	public function getSlugOptions ( ) { $ slugOptions = array ( 'locale' => $ this -> language ) ; if ( $ this -> validAliasCharacters ) { $ slugOptions [ 'validChars' ] = $ this -> validAliasCharacters ; } return $ slugOptions ; }
468	public function buildSimpleCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
5098	private function appendByPosition ( $ values ) { $ this -> setPart ( CmdInsert :: PART_AS , false ) ; if ( ! $ this -> placeholder ) $ this -> placeholder = Assembly :: placeholder ( count ( $ values ) , true ) ; return $ this -> appendPart ( CmdInsert :: PART_VALUES , $ this -> placeholder , $ values ) ; }
5810	public function updateSearchableFields ( & $ fields ) { $ fields = array_merge ( array ( 'Tagging' => array ( 'title' => 'Tags' , 'field' => ListboxField :: create ( 'Tagging' , 'Tags' , FusionTag :: get ( ) -> map ( 'Title' , 'Title' ) -> toArray ( ) , ( Controller :: has_curr ( ) && ( $ filtering = Controller :: curr ( ) -> getRequest ( ) -> getVar ( 'q' ) ) && isset ( $ filtering [ 'Tagging' ] ) ) ? $ filtering [ 'Tagging' ] : array ( ) , null , true ) , 'filter' => $ this -> owner -> dbObject ( 'Tagging' ) -> stat ( 'default_search_filter_class' ) ) ) , $ fields ) ; $ this -> owner -> extend ( 'updateTaggingExtensionSearchableFields' , $ fields ) ; }
983	public function process ( Plan $ plan ) { $ shop = ShopifyApp :: shop ( ) ; $ bp = new BillingPlan ( $ shop , $ plan ) ; $ bp -> setChargeId ( Request :: query ( 'charge_id' ) ) ; $ bp -> activate ( ) ; $ bp -> save ( ) ; $ shop -> update ( [ 'freemium' => false , 'plan_id' => $ plan -> id , ] ) ; return Redirect :: route ( 'home' ) -> with ( 'success' , 'billing' ) ; }
4837	public function confirm_resource ( $ params ) { $ endpoint = '/confirm' ; $ required_params = array ( 'resource_id' , 'resource_type' ) ; foreach ( $ required_params as $ key => $ value ) { if ( ! isset ( $ params [ $ value ] ) ) { throw new GoCardless_ArgumentsException ( "$value missing" ) ; } $ data [ $ value ] = $ params [ $ value ] ; } if ( isset ( $ params [ 'state' ] ) ) { $ data [ 'state' ] = $ params [ 'state' ] ; } if ( isset ( $ params [ 'resource_uri' ] ) ) { $ data [ 'resource_uri' ] = $ params [ 'resource_uri' ] ; } $ sig_validation_data = array ( 'data' => $ data , 'secret' => $ this -> account_details [ 'app_secret' ] , 'signature' => $ params [ 'signature' ] ) ; if ( $ this -> validate_signature ( $ sig_validation_data ) == false ) { throw new GoCardless_SignatureException ( ) ; } $ confirm_params = array ( 'resource_id' => $ params [ 'resource_id' ] , 'resource_type' => $ params [ 'resource_type' ] ) ; $ confirm_params [ 'http_authorization' ] = $ this -> account_details [ 'app_id' ] . ':' . $ this -> account_details [ 'app_secret' ] ; if ( ! isset ( $ params [ 'redirect_uri' ] ) && isset ( $ this -> redirect_uri ) ) { $ confirm_params [ 'redirect_uri' ] = $ this -> redirect_uri ; } $ response = $ this -> request ( 'post' , $ endpoint , $ confirm_params ) ; if ( $ response [ 'success' ] == true ) { $ endpoint = '/' . $ params [ 'resource_type' ] . 's/' . $ params [ 'resource_id' ] ; $ class_name = 'GoCardless_' . GoCardless_Utils :: camelize ( $ params [ 'resource_type' ] ) ; return new $ class_name ( $ this , $ this -> request ( 'get' , $ endpoint ) ) ; } else { throw new GoCardless_ClientException ( 'Failed to fetch the confirmed resource.' ) ; } }
10797	public function getCryptedPassword ( $ password ) { $ bcrypt = new Bcrypt ; $ bcrypt -> setCost ( $ this -> getOptions ( ) -> getPasswordCost ( ) ) ; return $ bcrypt -> create ( $ password ) ; }
7485	public function charAt ( $ index ) { $ index = ( int ) $ index ; if ( $ index < 0 || $ index >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_substr ( $ this -> string , $ index , 1 , $ this -> encoding ) ; }
7459	private function color ( string $ color ) : Font { $ this -> color = $ color ; if ( $ this -> background ) { $ this -> turnToBackground ( ) ; } return $ this ; }
2933	public function deleteKeys ( $ keys = [ ] ) { foreach ( $ keys as $ key ) { $ this -> writer -> deleteSetter ( $ key ) ; } return $ this ; }
10085	public function setMapping ( $ severity , $ pipe ) { if ( ! isset ( $ this -> mapping [ $ severity ] ) ) { throw new \ RuntimeException ( "Unknown severity: " . $ severity ) ; } if ( ( $ pipe !== self :: SILENCE ) && ( $ pipe !== self :: STDOUT ) && ( $ pipe !== self :: STDERR ) ) { throw new \ RuntimeException ( "Unknown output pipe: " . $ pipe ) ; } $ this -> mapping [ $ severity ] = $ pipe ; }
8074	public function delete ( $ endpoint , $ headers = [ ] ) { $ request = new Request ( 'DELETE' , $ endpoint , $ headers ) ; $ response = $ this -> guzzle -> send ( $ request ) ; return $ this -> handle ( $ response ) ; }
4021	protected function validator ( $ varInput ) { $ blnHasError = false ; foreach ( $ this -> arrSubFields as $ strFieldName => & $ arrSubField ) { if ( ! $ this -> validateWidget ( $ arrSubField , $ strFieldName , 'value' , $ varInput ) ) { $ blnHasError = true ; } foreach ( $ this -> arrFlagFields as $ strFlag => $ arrFlagField ) { if ( ! $ this -> validateWidget ( $ arrFlagField , $ strFieldName , $ strFlag , $ varInput ) ) { $ blnHasError = true ; } } } unset ( $ arrSubField ) ; if ( $ blnHasError ) { $ this -> blnSubmitInput = false ; $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] ) ; } return $ varInput ; }
11003	public function URL ( $ path = '' , $ current_url = null ) { $ url = new URL ( $ this -> url ) ; $ path = ltrim ( $ path , '/' ) ; $ url -> set ( 'path' , $ url -> path . $ path ) ; if ( $ current_url instanceof URL ) { if ( $ url -> host === $ current_url -> host && $ url -> scheme === $ current_url -> scheme && $ url -> port === $ current_url -> port ) { $ url -> host = null ; $ url -> scheme = null ; } } return $ url ; }
12307	public function getDatePeriod ( ) { $ intervaloDiario = DateInterval :: createFromDateString ( '1 day' ) ; $ dataFim = clone $ this -> endDate ; $ dataFim -> add ( $ intervaloDiario ) ; return new DatePeriod ( $ this -> startDate , $ intervaloDiario , $ dataFim ) ; }
1096	protected function scopedAttributes ( $ node ) { $ keys = $ this -> node -> getScopedColumns ( ) ; if ( count ( $ keys ) == 0 ) return array ( ) ; $ values = array_map ( function ( $ column ) use ( $ node ) { return $ node -> getAttribute ( $ column ) ; } , $ keys ) ; return array_combine ( $ keys , $ values ) ; }
3565	public function getAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( is_null ( $ value ) ) { $ value = $ this -> getMeta ( $ key ) ; } return $ next ( $ value , $ args ) ; } ; }
11179	protected function get ( $ key ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; if ( ! is_array ( $ cache ) ) { return false ; } else { if ( isset ( $ cache [ $ key ] ) ) { return $ cache [ $ key ] ; } return false ; } }
8100	protected function validate ( $ name , $ limit , $ regEx = false ) { $ Name = ucfirst ( $ name ) ; $ value = $ this -> _updates -> $ name ; $ length = explode ( '-' , $ limit ) ; $ min = intval ( $ length [ 0 ] ) ; $ max = intval ( $ length [ 1 ] ) ; if ( ! $ max and ! $ min ) { $ this -> log -> error ( "Invalid second parameter for the $name validation" ) ; return false ; } if ( ! $ value ) { if ( is_null ( $ value ) ) { $ this -> log -> report ( "Missing index $name from the input" ) ; } if ( strlen ( $ value ) == $ min ) { $ this -> log -> report ( "$Name is blank and optional - skipped" ) ; return true ; } $ this -> log -> formError ( $ name , "$Name is required." ) ; return false ; } if ( strlen ( $ value ) > $ max ) { $ this -> log -> formError ( $ name , "The $Name is larger than $max characters." ) ; return false ; } if ( strlen ( $ value ) < $ min ) { $ this -> log -> formError ( $ name , "The $Name is too short. It should at least be $min characters long" ) ; return false ; } if ( $ regEx ) { preg_match ( $ regEx , $ value , $ match ) ; if ( preg_match ( $ regEx , $ value , $ match ) === 0 ) { $ this -> log -> formError ( $ name , "The $Name \"{$value}\" is not valid" ) ; return false ; } } $ this -> log -> report ( "The $name is Valid" ) ; return true ; }
2427	public function onBuild ( MenuEvent $ event ) : void { if ( null === $ this -> managerPath || ! $ this -> isAdminUser ( ) ) { return ; } $ categoryNode = $ event -> getTree ( ) -> getChild ( 'system' ) ; if ( null === $ categoryNode ) { return ; } $ item = $ event -> getFactory ( ) -> createItem ( 'contao_manager' , [ 'label' => 'Contao Manager' , 'attributes' => [ 'title' => 'Contao Manager' , 'href' => '/' . $ this -> managerPath , 'class' => 'navigation contao_manager' , ] , ] ) ; $ categoryNode -> addChild ( $ item ) ; }
9681	function fromXML ( $ xmlElement ) { if ( $ xmlElement -> getName ( ) == "contacts" ) { foreach ( $ xmlElement -> children ( ) as $ contactXml ) { $ contact = new Contact ( ) ; $ contact -> fromXML ( $ contactXml ) ; $ this -> contacts [ ] = $ contact ; } } }
4977	public function send ( \ Zend \ Mail \ Message $ message ) { $ options = $ this -> options ; $ filename = call_user_func ( $ options -> getCallback ( ) , $ this ) ; $ file = $ options -> getPath ( ) . DIRECTORY_SEPARATOR . $ filename ; $ contents = $ message -> toString ( ) ; $ umask = umask ( ) ; umask ( 022 ) ; if ( false === file_put_contents ( $ file , $ contents , LOCK_EX ) ) { throw new RuntimeException ( sprintf ( 'Unable to write mail to file (directory "%s")' , $ options -> getPath ( ) ) ) ; } umask ( $ umask ) ; $ this -> lastFile = $ file ; }
82	public function extractTo ( $ target , array $ roles = array ( 'php' => '/' , 'script' => '/bin' ) , $ vars = array ( ) ) { $ extractionPath = $ target . '/tarball' ; try { $ archive = new \ PharData ( $ this -> file ) ; $ archive -> extractTo ( $ extractionPath , null , true ) ; if ( ! is_file ( $ this -> combine ( $ extractionPath , '/package.xml' ) ) ) { throw new \ RuntimeException ( 'Invalid PEAR package. It must contain package.xml file.' ) ; } $ fileCopyActions = $ this -> buildCopyActions ( $ extractionPath , $ roles , $ vars ) ; $ this -> copyFiles ( $ fileCopyActions , $ extractionPath , $ target , $ roles , $ vars ) ; $ this -> filesystem -> removeDirectory ( $ extractionPath ) ; } catch ( \ Exception $ exception ) { throw new \ UnexpectedValueException ( sprintf ( 'Failed to extract PEAR package %s to %s. Reason: %s' , $ this -> file , $ target , $ exception -> getMessage ( ) ) , 0 , $ exception ) ; } }
804	private function hasReturnTypeHint ( Tokens $ tokens , $ index ) { $ endFuncIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ ')' ] ) ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ endFuncIndex ) ; return $ tokens [ $ nextIndex ] -> isGivenKind ( CT :: T_TYPE_COLON ) ; }
1669	public function delete ( ) { $ this -> Files -> rrdir ( $ this -> strFolder ) ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { Dbafs :: deleteResource ( $ this -> strFolder ) ; } }
11196	public function __isset ( $ name ) { $ value = $ this -> find ( $ name ) ; if ( $ value !== null && ! ( $ value instanceof \ Exception ) ) { return true ; } return false ; }
9409	protected function transform ( $ middleware , $ wrappable = true ) { if ( is_a ( $ middleware , Application :: MIDDLEWARE ) === false ) { $ approach = ( boolean ) $ this -> approach ( $ middleware ) ; $ response = $ approach === self :: SINGLE_PASS ? $ this -> response : null ; $ wrapper = new CallableMiddlewareWrapper ( $ middleware , $ response ) ; $ middleware = $ wrappable === true ? $ wrapper : $ middleware ; } return $ middleware ; }
1496	public function prepend ( Encoding ... $ encodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ encodings ) ; return $ copy ; }
6980	protected function findOneAddressBy ( $ expression ) { if ( 0 < $ this -> addresses -> count ( ) ) { $ criteria = Criteria :: create ( ) -> where ( $ expression ) -> setMaxResults ( 1 ) ; $ matches = $ this -> addresses -> matching ( $ criteria ) ; if ( $ matches -> count ( ) == 1 ) { return $ matches -> first ( ) ; } } return null ; }
1488	public function when ( bool $ test , $ decodings ) : self { if ( ! $ test ) { return $ this ; } if ( $ decodings instanceof \ Closure ) { return $ decodings ( $ this ) ; } $ decodings = $ decodings instanceof Decoding ? [ $ decodings ] : $ decodings ; return $ this -> push ( ... $ decodings ) ; }
1649	public function getLats ( ) : array { $ lats = [ ] ; foreach ( $ this -> points as $ point ) { $ lats [ ] = $ point -> getLat ( ) ; } return $ lats ; }
11897	public function getStatusLog ( $ checkRecent = false ) { if ( ! isset ( $ this -> _statusLog ) ) { $ this -> _statusLog = Cacher :: get ( [ get_called_class ( ) , $ this -> primaryKey , $ this -> created ] ) ; if ( empty ( $ this -> _statusLog ) ) { if ( is_null ( $ this -> message ) ) { $ this -> _statusLog = $ this -> _startStatus ( ) ; } else { $ this -> _statusLog = unserialize ( $ this -> message ) ; } } elseif ( $ checkRecent ) { $ testStatusLog = unserialize ( $ this -> message ) ; if ( $ testStatusLog && $ testStatusLog -> lastUpdate > $ this -> _statusLog -> lastUpdate ) { $ this -> _statusLog = $ testStatusLog ; } } if ( empty ( $ this -> _statusLog ) ) { $ this -> _statusLog = new Status ( ) ; } } $ this -> _statusLog -> log = $ this ; return $ this -> _statusLog ; }
10753	protected function getMobile ( UserEntity $ user ) { $ metadata = $ user -> getMetadata ( ) ; foreach ( $ metadata as $ meta ) { if ( 'cellulare' == $ meta -> getKey ( ) ) { return $ meta -> getValue ( ) ; } } return null ; }
11720	public function countPost ( $ actor ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( 'actor' => $ actor ) ) ; return count ( $ entities ) ; }
12696	static function getAvailableExtNames ( ) { $ files = pakeFinder :: type ( 'file' ) -> name ( 'options-*.yaml' ) -> not_name ( 'options-sample.yaml' ) -> not_name ( 'options-user.yaml' ) -> maxdepth ( 0 ) -> in ( self :: getOptionsDir ( ) ) ; foreach ( $ files as $ i => $ file ) { $ files [ $ i ] = substr ( basename ( $ file ) , 8 , - 5 ) ; } return $ files ; }
1612	private function _setCriteriaIdByType ( $ criteria , Element $ type , $ id ) { switch ( $ type :: className ( ) ) { case 'Entry' : $ criteria -> sectionId = $ id ; break ; case 'Category' : $ criteria -> groupId = $ id ; break ; } }
7808	public function setCurlNumRetries ( $ retries ) { if ( ! is_numeric ( $ retries ) || $ retries < 0 ) { throw new \ InvalidArgumentException ( 'Retries value must be numeric and a non-negative number.' ) ; } $ this -> curlNumRetries = $ retries ; return $ this ; }
12893	public function create ( $ account , $ openId ) { $ params = [ 'kf_account' => $ account , 'openid' => $ openId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CREATE , $ params ] ) ; }
3603	public function createJsonResponseFromException ( \ Exception $ exception , JsonRequest $ jsonRequest = null ) { $ jsonResponse = new JsonResponse ( ) ; if ( $ exception instanceof Exceptions \ ErrorException ) { $ jsonResponse -> setErrorCode ( 0 !== $ exception -> getCode ( ) ? $ exception -> getCode ( ) : - 32603 ) ; $ jsonResponse -> setErrorMessage ( ! empty ( $ exception -> getMessage ( ) ) ? $ exception -> getMessage ( ) : 'Internal error' ) ; $ jsonResponse -> setErrorData ( $ exception -> getData ( ) ) ; } else { $ jsonResponse -> setErrorCode ( 0 !== $ exception -> getCode ( ) ? $ exception -> getCode ( ) : - 32603 ) ; $ jsonResponse -> setErrorMessage ( ! empty ( $ exception -> getMessage ( ) ) ? $ exception -> getMessage ( ) : 'Internal error' ) ; } if ( $ jsonRequest ) { $ jsonResponse -> setId ( $ jsonRequest -> getId ( ) ) ; } return $ jsonResponse ; }
6286	public static function hash ( $ s ) { $ h = 5381 ; $ len = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ h5 = ( $ h << 5 ) & 0xffffffff ; $ sum = ( $ h & 0x3fffffff ) + ( $ h5 & 0x3fffffff ) ; $ h = ( ( $ sum & 0x40000000 ? 1 : 0 ) + ( $ h & 0x80000000 ? 2 : 0 ) + ( $ h & 0x40000000 ? 1 : 0 ) + ( $ h5 & 0x80000000 ? 2 : 0 ) + ( $ h5 & 0x40000000 ? 1 : 0 ) ) << 30 | ( $ sum & 0x3fffffff ) ; $ h ^= ord ( $ s [ $ i ] ) ; $ h &= 0xffffffff ; } return $ h ; }
5350	public function setMailBoxPassword ( $ domainName , $ mailBox , $ password ) { return $ this -> call ( self :: SERVICE , 'setMailBoxPassword' , [ $ domainName , $ mailBox , $ password ] ) ; }
6788	protected function getCustomerGroupFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerGroupInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerGroupInterface :: class ) ; } return $ resource ; }
7928	public function unregisterNamespace ( $ ns ) { list ( $ ns ) = $ this -> fireEvent ( 'namespace.unregister' , [ $ ns ] ) ; unset ( $ this -> namespaces [ $ ns ] ) ; return $ this ; }
7589	protected function configureType ( ) { switch ( $ this -> type ) { case 'POST' : $ this -> setOption ( CURLOPT_POST , true ) ; break ; case 'DELETE' : case 'PUT' : $ this -> setOption ( CURLOPT_CUSTOMREQUEST , $ this -> type ) ; break ; } }
1677	protected function getHash ( ) { @ trigger_error ( 'Using Folder::getHash() has been deprecated and will no longer work in Contao 5.0. Use Dbafs::getFolderHash() instead.' , E_USER_DEPRECATED ) ; $ arrFiles = array ( ) ; $ it = new \ RecursiveIteratorIterator ( new \ RecursiveDirectoryIterator ( $ this -> strRootDir . '/' . $ this -> strFolder , \ FilesystemIterator :: UNIX_PATHS | \ FilesystemIterator :: FOLLOW_SYMLINKS | \ FilesystemIterator :: SKIP_DOTS ) , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ it as $ i ) { if ( strncmp ( $ i -> getFilename ( ) , '.' , 1 ) !== 0 ) { $ arrFiles [ ] = substr ( $ i -> getPathname ( ) , \ strlen ( $ this -> strRootDir . '/' . $ this -> strFolder . '/' ) ) ; } } return md5 ( implode ( '-' , $ arrFiles ) ) ; }
8421	private function getTexture ( ) { if ( isset ( $ this -> model ) ) { $ texture = $ this -> attribute ; if ( isset ( $ this -> model -> $ texture ) ) { return $ this -> model -> $ texture ; } } if ( isset ( $ this -> texture ) ) { return $ this -> texture ; } return $ this -> default ; }
9827	public function setPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> password = $ pValue ; return $ this ; }
5493	public function add ( $ parameters , $ action ) { $ place = count ( $ this -> map ) ; $ this -> map [ $ place ] = array ( ) ; $ this -> map [ $ place ] [ 'params' ] = new ParametersExpectation ( $ parameters ) ; $ this -> map [ $ place ] [ 'content' ] = $ action ; }
10156	private function readSharedFmla ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ cellRange = substr ( $ recordData , 0 , 6 ) ; $ cellRange = $ this -> readBIFF5CellRangeAddressFixed ( $ cellRange ) ; $ no = ord ( $ recordData [ 7 ] ) ; $ formula = substr ( $ recordData , 8 ) ; $ this -> sharedFormulas [ $ this -> baseCell ] = $ formula ; }
3539	public static function getAdldapProvider ( ) { if ( static :: getExtensionOptions ( 'adldap-providername' ) != '__USE_DEFAULT_PROVIDER__' ) { $ provider = Yii :: $ app -> ad -> getProvider ( static :: getExtensionOptions ( 'adldap-providername' ) ) ; } else { $ provider = Yii :: $ app -> ad -> getDefaultProvider ( ) ; } return $ provider ; }
10674	private function _cmpFrm ( $ txt ) { $ CmpFrmRV = '' ; $ length = mb_strlen ( $ txt , 'UTF-8' ) ; for ( $ CmpFrmI = 0 ; $ CmpFrmI < $ length ; $ CmpFrmI ++ ) { if ( mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) === '0' ) { $ CmpFrmRV .= $ this -> aCmpReg [ 0 ] ; } elseif ( mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) === '1' ) { $ CmpFrmRV .= $ this -> aCmpReg [ 1 ] ; } elseif ( mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) === '2' ) { $ CmpFrmRV .= $ this -> aCmpReg [ 2 ] ; } else { $ CmpFrmRV .= mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) ; } } return $ CmpFrmRV ; }
5651	public function explainFlag ( $ flags , $ explanation ) { $ flags = is_array ( $ flags ) ? $ flags : array ( $ flags ) ; $ this -> flag_sets [ ] = $ flags ; $ this -> explanations [ ] = $ explanation ; }
11569	public static function search ( $ query , & $ results = array ( ) ) { $ attachments = static :: getInstance ( ) ; if ( ! empty ( $ query ) ) : $ words = explode ( ' ' , $ query ) ; foreach ( $ words as $ word ) { $ _results = $ attachments -> setListLookUpConditions ( "attachment_name" , $ word , 'OR' ) -> setListLookUpConditions ( "attachment_title" , $ word , 'OR' ) -> setListLookUpConditions ( "attachment_description" , $ word , 'OR' ) -> setListLookUpConditions ( "attachment_tags" , $ word , 'OR' ) ; } $ _results = $ attachments -> setListLookUpConditions ( "attachment_owner" , array ( $ attachments -> user -> get ( "user_name_id" ) ) , "AND" , true ) -> setListOrderBy ( "o.object_created_on" , "DESC" ) -> getObjectsList ( "attachment" ) ; $ rows = $ _results -> fetchAll ( ) ; $ browsable = array ( "image/jpg" , "image/jpeg" , "image/png" , "image/gif" ) ; $ documents = array ( "filterid" => "attachments" , "title" => "Documents" , "results" => array ( ) ) ; foreach ( $ rows as $ attachment ) { $ document = array ( "title" => $ attachment [ 'attachment_title' ] , "description" => "" , "type" => $ attachment [ 'object_type' ] , "object_uri" => $ attachment [ 'object_uri' ] ) ; if ( in_array ( $ attachment [ 'attachment_type' ] , $ browsable ) ) : $ document [ 'icon' ] = "/system/object/{$attachment['object_uri']}/resize/170/170" ; $ document [ 'link' ] = "/system/media/photo/view/{$attachment['object_uri']}" ; else : $ document [ 'media_uri' ] = $ attachment [ 'object_uri' ] ; $ document [ 'link' ] = "/system/object/{$attachment['object_uri']}" ; endif ; $ documents [ "results" ] [ ] = $ document ; } if ( ! empty ( $ documents [ "results" ] ) ) $ results [ ] = $ documents ; endif ; return true ; }
3895	protected function getMetaModel ( $ metaModelId ) { if ( null === $ this -> factory ) { throw new \ RuntimeException ( 'No factory set.' ) ; } $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; return $ metaModel ; }
260	public function renderFile ( $ viewFile , $ params = [ ] , $ context = null ) { $ viewFile = $ requestedFile = Yii :: getAlias ( $ viewFile ) ; if ( $ this -> theme !== null ) { $ viewFile = $ this -> theme -> applyTo ( $ viewFile ) ; } if ( is_file ( $ viewFile ) ) { $ viewFile = FileHelper :: localize ( $ viewFile ) ; } else { throw new ViewNotFoundException ( "The view file does not exist: $viewFile" ) ; } $ oldContext = $ this -> context ; if ( $ context !== null ) { $ this -> context = $ context ; } $ output = '' ; $ this -> _viewFiles [ ] = [ 'resolved' => $ viewFile , 'requested' => $ requestedFile ] ; if ( $ this -> beforeRender ( $ viewFile , $ params ) ) { Yii :: debug ( "Rendering view file: $viewFile" , __METHOD__ ) ; $ ext = pathinfo ( $ viewFile , PATHINFO_EXTENSION ) ; if ( isset ( $ this -> renderers [ $ ext ] ) ) { if ( is_array ( $ this -> renderers [ $ ext ] ) || is_string ( $ this -> renderers [ $ ext ] ) ) { $ this -> renderers [ $ ext ] = Yii :: createObject ( $ this -> renderers [ $ ext ] ) ; } $ renderer = $ this -> renderers [ $ ext ] ; $ output = $ renderer -> render ( $ this , $ viewFile , $ params ) ; } else { $ output = $ this -> renderPhpFile ( $ viewFile , $ params ) ; } $ this -> afterRender ( $ viewFile , $ params , $ output ) ; } array_pop ( $ this -> _viewFiles ) ; $ this -> context = $ oldContext ; return $ output ; }
1128	public function isSelfOrAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) <= $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; }
2604	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ checkIfSettingExists = $ this -> api -> hasSnippet ( $ activeVersion , Config :: WAF_SETTING_NAME ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> config -> getWafAllowByAcl ( ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; if ( ! $ checkIfSettingExists ) { foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key , 'type' => $ key , 'dynamic' => 1 , 'priority' => 10 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } } else { foreach ( $ snippet as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; if ( $ this -> api -> hasSnippet ( $ clone -> number , $ name ) == true ) { $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ checkIfSettingExists , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON WAF ACL Bypass' ] ; if ( $ checkIfSettingExists ) { $ comment = [ 'comment' => 'Magento Module turned OFF WAF ACL Bypass' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
8829	protected function option ( $ display , $ value , $ selected , array $ attributes = [ ] ) { $ selected = $ this -> getSelectedValue ( $ value , $ selected ) ; $ options = array_merge ( [ 'value' => $ value , 'selected' => $ selected ] , $ attributes ) ; return $ this -> toHtmlString ( '<option' . $ this -> html -> attributes ( $ options ) . '>' . e ( $ display ) . '</option>' ) ; }
897	private function fixTokensCompare ( Tokens $ tokens , $ startLeft , $ endLeft , $ compareOperatorIndex , $ startRight , $ endRight ) { $ type = $ tokens [ $ compareOperatorIndex ] -> getId ( ) ; $ content = $ tokens [ $ compareOperatorIndex ] -> getContent ( ) ; if ( \ array_key_exists ( $ type , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ type ] ; } elseif ( \ array_key_exists ( $ content , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ content ] ; } $ right = $ this -> fixTokensComparePart ( $ tokens , $ startRight , $ endRight ) ; $ left = $ this -> fixTokensComparePart ( $ tokens , $ startLeft , $ endLeft ) ; for ( $ i = $ startRight ; $ i <= $ endRight ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } for ( $ i = $ startLeft ; $ i <= $ endLeft ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens -> insertAt ( $ startRight , $ left ) ; $ tokens -> insertAt ( $ startLeft , $ right ) ; return $ startLeft ; }
2086	public static function getPath ( $ template , $ format , $ custom = 'templates' ) { $ file = $ template . '.' . $ format ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ custom . '/' . $ file ) ) { return $ rootDir . '/' . $ custom . '/' . $ file ; } if ( $ custom != 'templates' ) { if ( file_exists ( $ rootDir . '/templates/' . $ file ) ) { return $ rootDir . '/templates/' . $ file ; } } return static :: getDefaultPath ( $ template , $ format ) ; }
6721	private function handleTokenResponse ( $ response ) { $ params = ( $ response instanceof OAuthToken ) ? $ response -> getParams ( ) : $ response ; $ status = ArrayHelper :: getValue ( $ params , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ token = ArrayHelper :: getValue ( $ params , 'data' ) ; if ( is_null ( $ token ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ token ; } else { $ message = ArrayHelper :: getValue ( $ params , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
12323	protected function askQuestions ( InputInterface $ input , OutputInterface $ output ) { foreach ( $ this -> questions as $ question ) { if ( ! $ question -> ask ( $ input , $ output ) ) { return static :: RETURN_ERROR ; } } return static :: RETURN_SUCCESS ; }
5829	public function newRawRequest ( $ method , $ url , $ data = '' ) { return $ this -> newRequest ( $ method , $ url , $ data , Request :: ENCODING_RAW ) ; }
9365	public function multiply ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return new self ( ( $ this -> float_r * $ z -> re ) - ( $ this -> float_i * $ z -> im ) , ( $ this -> float_r * $ z -> im ) + ( $ z -> re * $ this -> float_i ) ) ; }
7596	protected function renderHelpBlock ( ElementInterface $ oElement ) { if ( $ sHelpBlock = $ oElement -> getOption ( 'help-block' ) ) { if ( $ oTranslator = $ this -> getTranslator ( ) ) { $ sHelpBlock = $ oTranslator -> translate ( $ sHelpBlock , $ this -> getTranslatorTextDomain ( ) ) ; } $ sHelpBlockString = strip_tags ( $ sHelpBlock ) ; if ( $ sHelpBlock === $ sHelpBlockString ) { $ sHelpBlock = $ this -> getEscapeHtmlHelper ( ) -> __invoke ( $ sHelpBlock ) ; } return sprintf ( static :: $ helpBlockFormat , $ sHelpBlock ) ; } else { return '' ; } }
7674	function TbsStoreLoad ( $ idx , $ file = false ) { $ this -> TBS -> Source = $ this -> TbsStoreGet ( $ idx , false ) ; $ this -> TbsCurrIdx = $ idx ; if ( $ file === false ) $ file = $ this -> TbsGetFileName ( $ idx ) ; $ this -> TBS -> OtbsCurrFile = $ file ; }
2994	protected function encode ( $ str ) { if ( empty ( $ str ) || $ this -> charset == 'UTF-8' ) return $ str ; if ( extension_loaded ( 'iconv' ) ) $ out = @ iconv ( "UTF-8" , $ this -> charset . "//IGNORE" , $ str ) ; if ( ! isset ( $ out ) || ! $ out ) $ out = extension_loaded ( 'mbstring' ) ? mb_convert_encoding ( $ str , $ this -> charset , "UTF-8" ) : utf8_decode ( $ str ) ; return $ out ? : $ str ; }
7206	public function addTaxAdjustment ( Adjustment $ tax ) : void { foreach ( $ this -> taxes as $ t ) { if ( $ t -> isSameAs ( $ tax ) ) { $ t -> addAmount ( $ tax -> getAmount ( ) ) ; return ; } } $ this -> taxes [ ] = clone $ tax ; }
9323	protected function registerMarkdownParser ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.docparser' , function ( $ app ) { $ environment = $ app [ 'commonmark.environment' ] ; return new DocParser ( $ environment ) ; } ) ; $ app -> alias ( 'commonmark.docparser' , DocParser :: class ) ; }
7170	protected function resolveTargetCountry ( $ target ) : CountryInterface { if ( null === $ target ) { return $ this -> countryProvider -> getCountry ( ) ; } if ( $ target instanceof CountryInterface ) { return $ target ; } if ( $ target instanceof SaleInterface ) { $ country = $ this -> resolveSaleTargetCountry ( $ target ) ; } elseif ( $ target instanceof CustomerInterface ) { $ country = $ this -> resolveCustomerTargetCountry ( $ target ) ; } elseif ( is_string ( $ target ) && 2 == strlen ( $ target ) ) { $ country = $ this -> getCountryByCode ( $ target ) ; } else { throw new InvalidArgumentException ( "Unexpected taxation target." ) ; } return $ country ? : $ this -> countryProvider -> getCountry ( ) ; }
4846	public static function register ( array $ aliases ) { if ( ! $ aliases ) { return ; } if ( ! isset ( self :: $ autoloadFn ) ) { $ classAliases = & self :: $ aliases ; self :: $ autoloadFn = function ( $ className ) use ( & $ classAliases ) { if ( isset ( $ classAliases [ $ className ] ) ) { if ( strtolower ( $ classAliases [ $ className ] ) === strtolower ( $ className ) ) { throw new \ LogicException ( "Class alias is referencing the alias itself" ) ; } $ facadeClass = $ classAliases [ $ className ] ; class_alias ( $ facadeClass , $ className ) ; } } ; spl_autoload_register ( self :: $ autoloadFn ) ; } self :: $ aliases = array_merge ( self :: $ aliases , $ aliases ) ; }
7494	public function trimRight ( $ characters = null ) { $ this -> string = rtrim ( $ this -> string , $ characters ) ; return $ this ; }
1791	private function prepareDomain ( RequestContext $ context , array & $ parameters , int & $ referenceType ) : void { if ( isset ( $ parameters [ '_ssl' ] ) ) { $ context -> setScheme ( true === $ parameters [ '_ssl' ] ? 'https' : 'http' ) ; } if ( isset ( $ parameters [ '_domain' ] ) && '' !== $ parameters [ '_domain' ] ) { $ this -> addHostToContext ( $ context , $ parameters , $ referenceType ) ; } unset ( $ parameters [ '_domain' ] , $ parameters [ '_ssl' ] ) ; }
5388	protected function valuesArePossible ( $ values ) { $ matches = array ( ) ; $ widgets = & $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { $ possible = $ widgets [ $ i ] -> getAttribute ( 'value' ) ; if ( in_array ( $ possible , $ values ) ) { $ matches [ ] = $ possible ; } } return ( $ values == $ matches ) ; }
1998	public function getLocale ( ) : string { foreach ( $ this -> getAcceptedLocales ( ) as $ locale ) { if ( file_exists ( $ this -> translationsDir . '/messages.' . $ locale . '.xlf' ) ) { return $ locale ; } } return 'en' ; }
617	private function parseArray ( $ value , & $ i = 0 ) { $ result = [ ] ; $ len = strlen ( $ value ) ; for ( ++ $ i ; $ i < $ len ; ++ $ i ) { switch ( $ value [ $ i ] ) { case '{' : $ result [ ] = $ this -> parseArray ( $ value , $ i ) ; break ; case '}' : break 2 ; case $ this -> delimiter : if ( empty ( $ result ) ) { $ result [ ] = null ; } if ( in_array ( $ value [ $ i + 1 ] , [ $ this -> delimiter , '}' ] , true ) ) { $ result [ ] = null ; } break ; default : $ result [ ] = $ this -> parseString ( $ value , $ i ) ; } } return $ result ; }
882	private function normalizeType ( $ type ) { if ( '[]' === substr ( $ type , - 2 ) ) { return $ this -> normalize ( substr ( $ type , 0 , - 2 ) ) . '[]' ; } return $ this -> normalize ( $ type ) ; }
8676	public function flip ( ) { if ( ! $ this -> items ) { return $ this -> createFrom ( [ ] ) ; } try { return $ this -> createFrom ( Thrower :: call ( 'array_flip' , $ this -> items ) ) ; } catch ( ErrorException $ e ) { throw new LogicException ( 'Only string and integer values can be flipped' ) ; } }
8067	public function run ( $ input ) { while ( $ this -> workerPoolSize > 0 ) { try { $ processDetailsOfFreeWorker = $ this -> getNextFreeWorker ( ) ; $ processDetailsOfFreeWorker -> getSocket ( ) -> send ( array ( 'cmd' => 'run' , 'data' => $ input ) ) ; return $ processDetailsOfFreeWorker -> getPid ( ) ; } catch ( \ Exception $ e ) { pcntl_signal_dispatch ( ) ; } } throw new WorkerPoolException ( 'Unable to run the task.' ) ; }
5857	protected function localize ( $ input ) { if ( TYPO3_MODE === 'FE' ) { $ output = is_object ( $ GLOBALS [ 'TSFE' ] ) ? $ GLOBALS [ 'TSFE' ] -> sL ( $ input ) : $ input ; } else { $ output = $ GLOBALS [ 'LANG' ] -> sL ( $ input ) ; } return $ output ; }
4693	public function orderBy ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> order = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'order' ] = $ args ; return $ this ; }
5236	public function get ( $ name = null ) { $ constructor = $ this -> class -> getConstructor ( ) ; if ( null === $ constructor || $ this -> class -> isInternal ( ) ) { return $ this -> class -> newInstance ( ) ; } $ params = $ this -> injectionValuesForMethod ( $ constructor ) ; if ( count ( $ params ) === 0 ) { return $ this -> class -> newInstance ( ) ; } return $ this -> class -> newInstanceArgs ( $ params ) ; }
977	protected function getUrlFromName ( string $ name ) { if ( Str :: endsWith ( $ name , 'Job' ) ) { $ name = substr ( $ name , 0 , - 3 ) ; } return strtolower ( preg_replace ( '/(?<!^)[A-Z]/' , '-$0' , $ name ) ) ; }
6438	public function completeLogin ( $ extrainputs = array ( ) ) { $ request_token = [ ] ; $ request_token [ 'oauth_token' ] = $ this -> request_token [ 'oauth_token' ] ; $ request_token [ 'oauth_token_secret' ] = $ this -> request_token [ 'oauth_token_secret' ] ; $ this -> logQ ( 'session token ' . print_r ( $ request_token , true ) , 'twitter' ) ; $ this -> logQ ( 'extra options ' . print_r ( $ extrainputs , true ) , 'twitter' ) ; if ( isset ( $ extrainputs [ 'oauth_token' ] ) && $ request_token [ 'oauth_token' ] !== $ extrainputs [ 'oauth_token' ] ) { throw new \ Exception ( 'Twitter oauth. Somethign went wrong. No token in the session' ) ; } $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] , $ request_token [ 'oauth_token' ] , $ request_token [ 'oauth_token_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ access_token = $ connection -> oauth ( "oauth/access_token" , array ( "oauth_verifier" => $ extrainputs [ 'oauth_verifier' ] ) ) ; $ this -> access_token = $ access_token ; return $ this -> getUserProfile ( ) ; }
5931	public function setDefinition ( $ definition ) { if ( is_array ( $ definition ) ) { $ this -> definition = $ definition ; return $ this ; } $ this -> definition = json_decode ( $ definition , true ) ; if ( null === $ this -> definition ) { $ this -> definition = $ definition ; } return $ this ; }
4090	public function delete ( $ id = false , $ index , $ type , array $ options = array ( ) ) { $ params = array ( '_id' => $ id , '_index' => $ index , '_type' => $ type ) ; foreach ( $ options as $ key => $ value ) { $ params [ '_' . $ key ] = $ value ; } $ operation = array ( array ( 'delete' => $ params ) ) ; $ this -> operations [ ] = $ operation ; return $ this ; }
12177	public function addArgument ( ArgumentInterface $ argument ) { $ this -> argumentPositions [ $ argument -> getPosition ( ) ] = $ argument ; $ this -> argumentNames [ $ argument -> getName ( ) ] = $ argument ; if ( $ argument -> isClass ( ) ) { $ this -> argumentClasses [ $ argument -> getClass ( ) ] = $ argument ; } return $ argument ; }
9918	public function getTableName ( Model $ model , ModelConfig $ config = null ) { if ( empty ( $ this -> models ) ) { throw new \ LogicException ( 'AujaConfigurator not configured yet! Call configure first.' ) ; } if ( ! isset ( $ this -> configs [ $ model -> getName ( ) ] ) ) { throw new \ LogicException ( sprintf ( 'AujaConfigurator not configured for model %s' , $ model -> getName ( ) ) ) ; } $ result = null ; if ( $ config != null && $ config -> getTableName ( ) != null ) { $ result = $ config -> getTableName ( ) ; } else { $ modelConfig = $ this -> configs [ $ model -> getName ( ) ] ; $ result = $ modelConfig -> getTableName ( ) ; } return $ result ; }
8938	public function updateChangeset ( $ id , $ tags = array ( ) ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <changeset>' . $ tagList . '</changeset> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> changeset ; }
2573	protected function loadAuthParams ( $ params ) { if ( isset ( $ params [ 'authParams' ] ) ) { if ( $ params [ 'authParams' ] instanceof AuthParams ) { $ this -> authParams = $ params [ 'authParams' ] ; } elseif ( is_array ( $ params [ 'authParams' ] ) ) { $ this -> authParams = new AuthParams ( $ params [ 'authParams' ] ) ; } } }
403	public function overrideDefaultSettings ( $ action ) { if ( isset ( $ this -> actions [ $ action -> id ] ) ) { $ actionParams = $ this -> actions [ $ action -> id ] ; $ actionParamsKeys = array_keys ( $ actionParams ) ; foreach ( $ this -> cors as $ headerField => $ headerValue ) { if ( in_array ( $ headerField , $ actionParamsKeys ) ) { $ this -> cors [ $ headerField ] = $ actionParams [ $ headerField ] ; } } } }
6135	public function search ( Search $ search , $ returnType = self :: RETURN_OBJECTS , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'returnType' => $ returnType ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> call ( 'v1/search' , $ parameters , self :: METHOD_POST , $ cachePolicy ) ; $ result = new SearchResult ( $ result ) ; return $ result ; }
10675	private function _sklon ( $ nPad , $ vzndx , $ txt , $ zivotne = false ) { if ( $ vzndx < 0 || $ vzndx >= \ count ( $ this -> vzor ) ) { return '???' ; } $ txt3 = $ this -> _xEdeten ( $ txt ) ; $ kndx = $ this -> _isShoda ( $ this -> vzor [ $ vzndx ] [ 1 ] , $ txt3 ) ; if ( $ kndx < 0 || $ nPad < 1 || $ nPad > 14 ) { return '???' ; } if ( $ this -> vzor [ $ vzndx ] [ $ nPad ] === '?' ) { return '?' ; } if ( ! $ this -> isDbgMode & $ nPad === 1 ) { $ rv = $ this -> _xDetene ( $ txt3 ) ; } else { $ rv = $ this -> _leftStr ( $ kndx , $ txt3 ) . '-' . $ this -> _cmpFrm ( $ this -> vzor [ $ vzndx ] [ $ nPad ] ) ; } if ( $ this -> isDbgMode ) { return $ rv ; } $ length = mb_strlen ( $ rv , 'UTF-8' ) ; for ( $ nnn = 0 ; $ nnn < $ length ; $ nnn ++ ) { if ( mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) === '-' ) { break ; } } $ ndx1 = $ nnn ; for ( $ nnn = 0 ; $ nnn < $ length ; $ nnn ++ ) { if ( mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) === '/' ) { break ; } } $ ndx2 = $ nnn ; if ( $ ndx1 !== $ length && $ ndx2 !== $ length ) { if ( $ zivotne ) { $ rv = $ this -> _leftStr ( $ ndx1 , $ rv ) . $ this -> _rightStr ( $ ndx2 + 1 , $ rv ) ; } else { $ rv = $ this -> _leftStr ( $ ndx2 , $ rv ) ; } $ length = mb_strlen ( $ rv , 'UTF-8' ) ; } $ txt3 = '' ; for ( $ nnn = 0 ; $ nnn < $ length ; $ nnn ++ ) { $ subStr = mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) ; if ( ! ( $ subStr === '-' || $ subStr === '/' ) ) { $ txt3 .= mb_substr ( $ rv , $ nnn , 1 , 'UTF-8' ) ; } } $ rv = $ this -> _xDetene ( $ txt3 ) ; return $ rv ; }
810	private function toComparableNames ( array $ types , array $ symbolShortNames ) { $ normalized = array_map ( function ( $ type ) use ( $ symbolShortNames ) { $ type = strtolower ( $ type ) ; if ( isset ( $ symbolShortNames [ $ type ] ) ) { return $ symbolShortNames [ $ type ] ; } return $ type ; } , $ types ) ; sort ( $ normalized ) ; return $ normalized ; }
2451	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoRequest ( $ event -> getRequest ( ) ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( '_locale' , $ this -> getLocale ( $ request ) ) ; }
6237	private static function getOptions ( ) { return [ '1/6' => Craft :: t ( 'width-fieldtype' , '1/6' ) , '1/5' => Craft :: t ( 'width-fieldtype' , '1/5' ) , '1/4' => Craft :: t ( 'width-fieldtype' , '1/4' ) , '1/3' => Craft :: t ( 'width-fieldtype' , '1/3' ) , '2/5' => Craft :: t ( 'width-fieldtype' , '2/5' ) , '1/2' => Craft :: t ( 'width-fieldtype' , '1/2' ) , '3/5' => Craft :: t ( 'width-fieldtype' , '3/5' ) , '2/3' => Craft :: t ( 'width-fieldtype' , '2/3' ) , '3/4' => Craft :: t ( 'width-fieldtype' , '3/4' ) , '4/5' => Craft :: t ( 'width-fieldtype' , '4/5' ) , '5/6' => Craft :: t ( 'width-fieldtype' , '5/6' ) , 'full' => Craft :: t ( 'width-fieldtype' , 'Full' ) , ] ; }
2705	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_AUTH_SNIPPET_PATH ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> hasSnippet ( $ activeVersion , $ name ) ; if ( $ status == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
5434	protected function isStaticMethod ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; if ( ! $ interface -> hasMethod ( $ name ) ) { return false ; } return $ interface -> getMethod ( $ name ) -> isStatic ( ) ; }
6122	public function permissionGetNameById ( $ permid ) { foreach ( $ this -> permissionList ( ) as $ name => $ perm ) { if ( $ perm [ "permid" ] == $ permid ) { return new Ts3Exception ( $ name ) ; } } throw new Ts3Exception ( "invalid permission ID" , 0xA02 ) ; }
11374	private function getInjectHint ( \ ReflectionMethod $ method , \ ReflectionParameter $ parameter ) { $ hint = Psi :: it ( $ this -> reader -> getMethodAnnotations ( $ method ) ) -> filter ( new IsInstanceOf ( Di \ DiInjectHintAnnotation :: class ) ) -> filter ( function ( Di \ DiInjectHintAnnotation $ i ) use ( $ parameter ) { return $ i -> getParameter ( ) === $ parameter -> getName ( ) ; } ) -> getFirst ( ) ; if ( $ hint !== null ) { return $ hint ; } try { if ( $ parameter -> getClass ( ) === null ) { throw new \ InvalidArgumentException ( "Cannot inject constructor-param '{$parameter->getName()}' into {$method->getDeclaringClass()->getName()}. " . 'The parameter does not have a an @Inject hint and it has no type-hint.' ) ; } } catch ( \ ReflectionException $ e ) { } return Di \ Inject \ ByType :: create ( $ parameter -> getName ( ) , Util :: normalizeFqcn ( ( string ) $ parameter -> getType ( ) ) ) ; }
2992	private function parse ( $ content ) { if ( $ this -> method == 'downloadFile' ) { return $ this -> parseResponseDownloadFile ( $ content ) ; } $ xml = new SimpleXMLElement ( $ content ) ; if ( isset ( $ xml -> error ) ) { throw new Exception \ ZohoErrorException ( new ZohoError ( ( string ) $ xml -> error -> code , ( string ) $ xml -> error -> message ) ) ; } if ( isset ( $ xml -> nodata ) ) { throw new Exception \ NoDataException ( new ZohoError ( ( string ) $ xml -> nodata -> code , ( string ) $ xml -> nodata -> message ) ) ; } if ( $ this -> method == 'getFields' ) { return $ this -> parseResponseGetFields ( $ xml ) ; } if ( $ this -> method == 'deleteRecords' ) { return $ this -> parseResponseDeleteRecords ( $ xml ) ; } if ( $ this -> method == 'uploadFile' ) { return $ this -> parseResponseUploadFile ( $ xml ) ; } if ( $ this -> method == 'deleteFile' ) { return $ this -> parseResponseDeleteFile ( $ xml ) ; } if ( $ this -> method == 'getDeletedRecordIds' ) { return $ this -> parseResponseGetDeletedRecordIds ( $ xml ) ; } if ( $ this -> method == 'convertLead' ) { return $ this -> parseResponseConvertLead ( $ xml ) ; } if ( $ this -> method == 'updateRelatedRecords' ) { return $ this -> parseUpdateRelatedRecords ( $ xml ) ; } if ( isset ( $ xml -> result -> { $ this -> module } ) ) { return $ this -> parseResponseGetRecords ( $ xml ) ; } if ( isset ( $ xml -> result -> row -> success ) || isset ( $ xml -> result -> row -> error ) ) { return $ this -> parseResponsePostRecordsMultiple ( $ xml ) ; } throw new Exception \ UnexpectedValueException ( 'Xml doesn\'t contain expected fields' ) ; }
6514	public function invoke ( JobInterface $ job , ContextInterface $ context ) { $ jobType = $ this -> registry -> get ( $ job -> getType ( ) ) ; $ callableArray = $ jobType -> getCallable ( ) ; $ parameters = static :: resolveParameters ( $ jobType , $ context , $ job -> getParameters ( ) ) ; if ( is_array ( $ callableArray ) && $ callable = $ callableArray [ 0 ] ) { if ( $ callable instanceof JobAwareInterface ) { $ callable -> setJob ( $ job ) ; } if ( $ callable instanceof ManagerAwareInterface ) { $ callable -> setManager ( $ this -> manager ) ; } if ( $ callable instanceof ControllerAwareInterface ) { $ callable -> setController ( $ this -> controllerFactory -> create ( $ job ) ) ; } if ( $ callable instanceof LoggerAwareInterface && $ context -> has ( 'abc.logger' ) ) { $ callable -> setLogger ( $ context -> get ( 'abc.logger' ) ) ; } } return call_user_func_array ( $ callableArray , $ parameters ) ; }
6178	private function keySort ( $ a , $ b , $ c = null ) { $ d = $ c !== null ? $ c : 1 ; if ( $ a == $ b ) { return 0 ; } return ( $ a > $ b ) ? 1 * $ d : - 1 * $ d ; }
6782	public function setFormParameters ( $ optionNames ) { foreach ( ( array ) $ optionNames as $ option ) { $ this -> formParameters [ $ option ] = true ; } return $ this ; }
11858	public function getHandler ( ) { if ( $ this -> pairedDataItem ) { if ( ! isset ( $ this -> primaryObject ) ) { return $ this -> pairedDataItem ; } elseif ( isset ( $ this -> companionObject ) ) { return static :: getHandlingObject ( $ this , $ this -> pairedDataItem ) ; } } return $ this ; }
12646	public function setTrue ( $ obData = null ) { $ this -> bStatus = true ; $ this -> obData = $ obData ; return $ this ; }
4758	protected function transformCacheAnnotation ( Cache $ cache ) { return array ( 'expires' => $ cache -> getExpires ( ) , 'maxage' => $ cache -> getMaxAge ( ) , 'smaxage' => $ cache -> getSMaxAge ( ) , 'public' => $ this -> transformBoolean ( $ cache -> isPublic ( ) ) , 'vary' => $ cache -> getVary ( ) , 'lastModified' => $ cache -> getLastModified ( ) , 'etag' => $ cache -> getETag ( ) , ) ; }
3761	private function getLegend ( PaletteInterface $ palette , $ legendName ) { if ( $ palette -> hasLegend ( $ legendName ) ) { return $ palette -> getLegend ( $ legendName ) ; } $ legend = new Legend ( $ legendName ) ; $ palette -> addLegend ( $ legend ) ; return $ legend ; }
5893	public function listAudioTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/audio' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new AudioTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5026	protected function getCustomizationOptions ( ContainerInterface $ container , $ requestedName , array $ options = null ) { if ( ! static :: OPTIONS_NAME ) { throw new \ RuntimeException ( 'The class constants "OPTIONS_NAME" must be non empty.' ) ; } return $ container -> get ( static :: OPTIONS_NAME ) ; }
4801	public function injectSpecialBindings ( string $ sql , array $ bindings ) : string { foreach ( self :: SPECIAL_BINDINGS as $ special ) { $ specialPlaceholder = ":" . $ special ; if ( ! array_key_exists ( $ special , $ bindings ) ) { continue ; } $ replacement = $ this -> escapeSpecialBinding ( $ bindings [ $ special ] , $ special ) ; $ sql = str_replace ( $ specialPlaceholder , $ replacement , $ sql ) ; unset ( $ bindings [ $ special ] ) ; } foreach ( $ bindings as $ key => $ value ) { if ( is_array ( $ value ) ) { $ inString = "" ; foreach ( $ value as $ i => $ innerValue ) { $ newKey = $ key . "__" . $ i ; $ keyParamString = ":$newKey" ; $ inString .= "$keyParamString, " ; } $ inString = rtrim ( $ inString , " ," ) ; $ sql = str_replace ( ":$key" , $ inString , $ sql ) ; } } return $ sql ; }
4064	private static function calculateDiff ( $ expected , $ actual , $ strict ) { if ( $ expected === $ actual ) { return ; } if ( gettype ( $ expected ) !== gettype ( $ actual ) ) { if ( ! $ strict && self :: isEmptyArrayEquivalent ( $ expected , $ actual ) ) { return ; } throw new \ LogicException ( sprintf ( 'Encountered type %s expected %s (Found %s, expected %s)' , gettype ( $ actual ) , gettype ( $ expected ) , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: TYPE_MISMATCH ) ; } if ( is_array ( $ expected ) ) { self :: calculateArrayDiff ( $ expected , $ actual , $ strict ) ; } throw new \ LogicException ( sprintf ( 'Found %s expected %s' , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: VALUE_MISMATCH ) ; }
646	public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> checkIntegrity ( $ check , $ schema , $ table ) ; return $ this -> setSql ( $ sql ) ; }
11117	protected function rollbackMigrations ( array $ migrations ) : void { $ this -> notify -> note ( '' ) ; foreach ( $ this -> getMigrationFiles ( M :: TYPE_DOWN ) as $ file ) { if ( in_array ( $ name = $ this -> getMigrationName ( $ file ) , $ migrations , true ) ) { $ this -> runDown ( $ file ) ; continue ; } $ this -> notify -> note ( "<fg=red>Migrate not found (in database table):</> {$name}" ) ; } }
5248	public function find ( $ id ) { $ child = $ this -> childClassName ; $ model = $ child :: findWithParentId ( $ id , $ this -> parent -> getId ( ) ) ; if ( $ model ) { $ model -> setParent ( $ this -> parent ) ; } return $ model ; }
3825	protected function compile ( ) { $ objItemRenderer = new ItemList ( ) ; $ this -> Template -> searchable = ! $ this -> metamodel_donotindex ; $ sorting = $ this -> metamodel_sortby ; $ direction = $ this -> metamodel_sortby_direction ; if ( $ this -> metamodel_sort_override ) { if ( \ Input :: get ( 'orderBy' ) ) { $ sorting = \ Input :: get ( 'orderBy' ) ; } if ( \ Input :: get ( 'orderDir' ) ) { $ direction = \ Input :: get ( 'orderDir' ) ; } } $ objItemRenderer -> setServiceContainerFallback ( function ( ) { return $ this -> getServiceContainer ( ) ; } ) -> setFactory ( System :: getContainer ( ) -> get ( 'metamodels.factory' ) ) -> setFilterFactory ( System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ) -> setRenderSettingFactory ( System :: getContainer ( ) -> get ( 'metamodels.render_setting_factory' ) ) -> setEventDispatcher ( System :: getContainer ( ) -> get ( 'event_dispatcher' ) ) -> setMetaModel ( $ this -> metamodel , $ this -> metamodel_rendersettings ) -> setLimit ( $ this -> metamodel_use_limit , $ this -> metamodel_offset , $ this -> metamodel_limit ) -> setPageBreak ( $ this -> perPage ) -> setSorting ( $ sorting , $ direction ) -> setFilterSettings ( $ this -> metamodel_filtering ) -> setFilterParameters ( StringUtil :: deserialize ( $ this -> metamodel_filterparams , true ) , $ this -> getFilterParameters ( $ objItemRenderer ) ) -> setMetaTags ( $ this -> metamodel_meta_title , $ this -> metamodel_meta_description ) ; $ this -> Template -> items = \ StringUtil :: encodeEmail ( $ objItemRenderer -> render ( $ this -> metamodel_noparsing , $ this ) ) ; $ this -> Template -> numberOfItems = $ objItemRenderer -> getItems ( ) -> getCount ( ) ; $ this -> Template -> pagination = $ objItemRenderer -> getPagination ( ) ; }
12115	public static function getExceptionTree ( \ Throwable $ Throwable ) { $ exception = get_class ( $ Throwable ) ; for ( $ exception_tree [ ] = $ exception ; $ exception = get_parent_class ( $ exception ) ; $ exception_tree [ ] = $ exception ) { ; } $ exception_tree = array_reverse ( $ exception_tree ) ; if ( count ( $ exception_tree ) > 1 ) { array_shift ( $ exception_tree ) ; } return $ exception_tree ; }
3512	public function getInsertTranslationsElement ( $ translation , $ timeStamp ) { return '(' . self :: dbValue ( $ translation -> status , Translation :: STATUS_SAVED ) . ',' . self :: dbValue ( $ translation -> locale ) . ',' . self :: dbValue ( $ translation -> group ) . ',' . self :: dbValue ( $ translation -> key ) . ',' . self :: dbValue ( $ translation -> value ) . ',' . self :: dbValue ( $ translation -> created_at , $ timeStamp ) . ',' . self :: dbValue ( $ translation -> updated_at , $ timeStamp ) . ',' . self :: dbValue ( $ translation -> source ) . ',' . self :: dbValue ( $ translation -> saved_value ) . ',' . self :: dbValue ( $ translation -> is_deleted , 0 ) . ',' . self :: dbValue ( $ translation -> was_used , 0 ) . ')' ; }
6091	public function removeMoodboard ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/moodboards/' . $ id . '' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
4436	public function get ( string $ name , $ default = null ) { $ res = $ this -> client -> call ( 'config.get' , $ name ) ; return $ res === null ? $ default : $ res ; }
8057	public function setParentProcessTitleFormat ( $ string ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Children\'s Process Title Format for a created pool.' ) ; } $ this -> parentProcessTitleFormat = ProcessDetails :: sanitizeProcessTitleFormat ( $ string ) ; return $ this ; }
3016	public function reblogPost ( $ blogName , $ postId , $ reblogKey , $ options = null ) { $ params = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; $ params = array_merge ( $ options ? : array ( ) , $ params ) ; $ path = $ this -> blogPath ( $ blogName , '/post/reblog' ) ; return $ this -> postRequest ( $ path , $ params , false ) ; }
12878	public function setValue ( $ value ) { $ this -> value = $ value ; if ( is_array ( $ value ) && array_key_exists ( 'start' , $ value ) && array_key_exists ( 'end' , $ value ) ) { $ start = ( float ) $ value [ 'start' ] ; $ end = ( float ) $ value [ 'end' ] ; if ( $ start <= $ end ) { $ this -> startElement -> setValue ( $ start ) ; $ this -> endElement -> setValue ( $ end ) ; } } return $ this ; }
11595	private function getPageId ( ) { if ( preg_match ( '/\/page\/(\w+)$/' , $ this -> name , $ matches ) ) { $ id = $ matches [ 1 ] ; } else { $ id = $ this -> environment -> getRequestHelper ( ) -> getIdentifierParam ( 'id' , null , true ) ; } return $ id ; }
6551	static function send ( $ channel_code = null ) { try { if ( is_numeric ( $ channel_code ) ) { $ channel_id = $ channel_code ; } else { $ channel_id = env ( 'telegram.' . $ channel_code ) ; $ channel_id = $ channel_id ? : env ( 'telegram' ) ; } if ( ! $ channel_id ) { echo 'No channel' ; return ; } if ( is_array ( $ channel_code ) ) { foreach ( $ channel_code as $ _code ) { self :: send ( $ _code ) ; } return ; } $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_TIMEOUT , 3 ) ; curl_setopt ( $ ch , CURLOPT_HEADER , 0 ) ; $ partials = [ ] ; $ current = '' ; foreach ( static :: $ messages as $ message ) { if ( mb_strlen ( $ current ) + mb_strlen ( $ message ) < self :: MAX ) { $ current .= PHP_EOL . $ message ; } else { $ partials [ ] = $ current ; $ current = '' ; if ( mb_strlen ( $ message ) > self :: MAX ) { $ strlen = mb_strlen ( $ message ) ; while ( $ strlen ) { $ partials [ ] = mb_substr ( $ message , 0 , self :: MAX , "UTF-8" ) ; $ message = mb_substr ( $ message , self :: MAX , mb_strlen ( $ message ) , "UTF-8" ) ; $ strlen = mb_strlen ( $ message ) ; } } else { $ current = $ message ; } } } $ partials [ ] = $ current ; foreach ( $ partials as $ partial ) { $ params = http_build_query ( [ 'disable_web_page_preview' => 'true' , 'parse_mode' => 'HTML' , 'chat_id' => $ channel_id , 'text' => $ partial , ] ) ; $ url = 'https://api.telegram.org/bot' . env ( 'telegram.key' ) . '/sendMessage?' ; curl_setopt ( $ ch , CURLOPT_URL , $ url . $ params ) ; curl_exec ( $ ch ) ; } curl_close ( $ ch ) ; } catch ( \ Exception $ e ) { echo $ e -> getMessage ( ) ; } }
8354	private function buildEnum ( string $ enumName , array $ enumDefinition ) { $ mapping = Mapping :: get ( $ this -> mapping ) ; $ definition = $ this -> getDefinition ( ) ; $ database = GlobalDatabase :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ enumRealName = null ; if ( isset ( $ enumDefinition [ 'name' ] ) === true ) { $ enumRealName = $ enumDefinition [ 'name' ] ; } else { $ enumRealName = Helper :: codifyName ( $ this -> mapping ) . '_' . Helper :: codifyName ( $ enumName ) ; } if ( isset ( $ enumDefinition [ 'values' ] ) === false ) { throw new InvalidSchemaDefinition ( 'enum "' . $ enumName . '" has no value' ) ; } $ values = array ( ) ; foreach ( $ enumDefinition [ 'values' ] as $ valueName => $ valueAlias ) { $ valueRealName = null ; if ( is_string ( $ valueName ) === true ) { $ valueRealName = $ valueName ; } else { $ valueRealName = Helper :: codifyName ( $ enumName ) . '_' . Helper :: codifyName ( $ valueAlias ) ; } $ values [ ] = $ valueRealName ; } $ statement = Mutation \ AddEnum :: statement ( $ database , $ enumRealName , $ values ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } echo $ enumName . ' - Done' . PHP_EOL ; }
7536	function detach ( $ move_children_up = false ) { if ( ( $ p = $ this -> parent ) !== null ) { $ index = $ this -> index ( ) ; $ this -> parent = null ; if ( $ move_children_up ) { $ this -> moveChildren ( $ p , $ index ) ; } $ p -> deleteChild ( $ this , true ) ; } }
7428	public function renderObject ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> objectDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
5152	static function sortEmailsByCreationDatePredicate ( $ emailA , $ emailB ) { $ sortKeyA = $ emailA -> sent_at ; $ sortKeyB = $ emailB -> sent_at ; return ( $ sortKeyA > $ sortKeyB ) ? - 1 : 1 ; }
3653	public static function render ( $ strTemplate , $ strOutputFormat , $ arrTplData , $ blnFailIfNotFound = false ) { $ objTemplate = new self ( $ strTemplate ) ; $ objTemplate -> setData ( $ arrTplData ) ; return $ objTemplate -> parse ( $ strOutputFormat , $ blnFailIfNotFound ) ; }
4157	function cron ( $ expression , Job $ job ) { $ expression = new CronExpression ( $ expression ) ; $ this -> add ( $ expression , $ job ) ; return $ this ; }
7279	public function file ( $ name = null ) { return ! $ name ? $ this -> files : ( $ this -> files [ $ name ] ?? null ) ; }
6504	public function serializeParameters ( $ type , array $ parameters ) { $ jobType = $ this -> registry -> get ( $ type ) ; $ indices = $ jobType -> getIndicesOfSerializableParameters ( ) ; if ( count ( $ indices ) < count ( $ parameters ) ) { throw new \ InvalidArgumentException ( sprintf ( 'More parameters provided for serialization than defined for job "%s"' , $ type ) ) ; } $ i = 0 ; $ serializedParameters = array ( ) ; foreach ( $ parameters as $ parameter ) { if ( null == $ parameter ) { $ serializedParameters [ ] = null ; } else { $ serializedParameters [ ] = $ this -> serializer -> serialize ( $ parameter , 'json' , $ this -> getParamSerializationContext ( $ jobType , $ indices [ $ i ] ) ) ; } $ i ++ ; } $ data = json_encode ( $ serializedParameters ) ; if ( false === $ data ) { throw new \ RuntimeException ( sprintf ( 'Serialization failed with error "%s"' , json_last_error_msg ( ) ) ) ; } return $ data ; }
12691	protected function outputError ( $ errorNumber , $ test , $ exception ) { $ feature = null ; $ scenario = null ; $ testDescription = null ; $ node = $ test ; while ( $ node !== null ) { $ class = get_class ( $ node ) ; $ description = str_replace ( "\n " , "\n " , $ node -> getDescription ( ) ) ; if ( $ description === '' ) { $ node = $ node -> getParent ( ) ; continue ; } if ( $ class === 'Peridot\Core\Test' ) { $ testDescription = $ description ; } elseif ( $ class === 'Peridot\Core\Suite' ) { if ( strpos ( $ description , 'Feature:' ) === 0 ) { $ feature = $ description ; } else { $ scenario = trim ( $ description ) ; } } $ node = $ node -> getParent ( ) ; } if ( $ this -> lastFeature !== $ feature ) { $ this -> output -> writeln ( " " . $ feature . "\n" ) ; $ this -> lastFeature = $ feature ; $ this -> lastScenario = null ; } if ( $ this -> lastScenario !== $ scenario ) { $ this -> output -> writeln ( " " . $ scenario . "\n" ) ; $ this -> lastScenario = $ scenario ; } $ this -> output -> writeln ( $ this -> color ( 'error' , sprintf ( " %d) %s" , $ errorNumber , $ testDescription ) ) ) ; $ message = sprintf ( " %s" , str_replace ( "\n" , "\n " , $ exception -> getMessage ( ) ) ) ; $ this -> output -> writeln ( $ this -> color ( 'pending' , $ message ) ) ; $ class = method_exists ( $ exception , 'getClass' ) ? $ exception -> getClass ( ) : get_class ( $ exception ) ; $ trace = method_exists ( $ exception , 'getTrueTrace' ) ? $ exception -> getTrueTrace ( ) : $ exception -> getTrace ( ) ; array_unshift ( $ trace , [ 'function' => $ class . ' thrown' , 'file' => $ exception -> getFile ( ) , 'line' => $ exception -> getLine ( ) ] ) ; $ this -> outputTrace ( $ trace ) ; }
9373	public function display ( ) { $ handler = new PrettyPageHandler ; error_reporting ( E_ALL ) ; $ this -> __call ( 'pushHandler' , array ( $ handler ) ) ; return $ this -> whoops -> register ( ) ; }
1237	private function set ( $ class , $ name , $ value ) { self :: ensurePropertyExists ( $ class , $ name ) ; self :: ensurePropertyType ( $ class , $ name , $ value ) ; $ this -> setValue ( $ class , $ name , $ value ) ; }
3039	public function has ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { return $ this -> getStorage ( ) -> has ( $ userId , $ callId ) ; } return $ this -> exists ( $ key ) ; }
5372	public function merge ( $ query ) { if ( is_object ( $ query ) ) { $ this -> request = array_merge ( $ this -> request , $ query -> getAll ( ) ) ; } elseif ( is_array ( $ query ) ) { foreach ( $ query as $ key => $ value ) { $ this -> add ( $ key , $ value ) ; } } }
3716	public function handle ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ options = [ ] ; foreach ( $ this -> conditionFactory -> getTypeNames ( ) as $ condition ) { $ options [ $ condition ] = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.conditionnames.' . $ condition , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; } $ event -> setOptions ( $ options ) ; }
9521	public function addAlias ( $ parameterName , $ prefix = null ) { if ( $ prefix == null ) { $ this -> aliases [ $ this -> prefix ] = $ parameterName ; } else { $ this -> aliases [ $ prefix ] = $ parameterName ; } }
12333	private function _checkBlackListIps ( ) : bool { $ oSecurity = Config :: get ( 'security' ) ; if ( isset ( $ oSecurity -> blacklist_ips ) ) { foreach ( $ oSecurity -> blacklist_ips as $ sIp ) { if ( $ _SERVER [ 'REMOTE_ADDR' ] == $ sIp ) { return false ; } } } return true ; }
4497	private function getAndroidJsonInner ( ? string $ text ) : array { $ data = [ ] ; if ( null !== $ text ) { $ data [ 'message' ] = $ text ; } if ( null !== $ this -> localizedKey ) { $ data [ 'message-loc-key' ] = $ this -> localizedKey ; if ( $ this -> localizedArguments ) { $ data [ 'message-loc-args' ] = $ this -> localizedArguments ; } } return $ data ; }
11433	public function query ( $ keyword , $ categories , array $ other = [ ] ) { $ params = [ 'query' => $ keyword , 'category' => implode ( ',' , ( array ) $ categories ) , 'appid' => $ this -> getAccessToken ( ) -> getAppId ( ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , array_merge ( $ params , $ other ) ] ) ; }
5367	public function paintException ( $ message ) { parent :: paintException ( $ message ) ; $ this -> results [ ] = new SimpleResultOfException ( parent :: getTestList ( ) , $ message ) ; }
3089	protected function alterTimeoutCallValue ( array $ options ) { $ timeoutValue = null ; if ( $ this -> isInitialCall === true ) { if ( $ this -> hasOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ; } } else { if ( $ this -> hasOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ; } } if ( ! is_null ( $ timeoutValue ) ) { $ options [ self :: OPTION_ENGINE_CLIENT ] [ 'options' ] [ 'http_client_options' ] [ 'timeout' ] = $ timeoutValue ; } return $ options ; }
1426	protected function convertIncludePath ( $ path ) { if ( array_key_exists ( $ path , $ this -> includePaths ) ) { return $ this -> includePaths [ $ path ] ? : null ; } return collect ( explode ( '.' , $ path ) ) -> map ( function ( $ segment ) { return $ this -> modelRelationForField ( $ segment ) ; } ) -> implode ( '.' ) ; }
11807	public function lists ( $ column , $ key = null ) { return $ this -> buildQuery ( [ $ column ] ) -> lists ( $ column , $ key ) ; }
6101	public function listPropertySets ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/propertysets' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new PropertySet ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
6491	protected function getInstance ( $ selector = '' ) { if ( empty ( $ this -> object ) ) { throw new \ RuntimeException ( 'Editor instance was not set.' ) ; } if ( empty ( $ this -> selector ) && empty ( $ selector ) ) { throw new \ RuntimeException ( 'No such editor was not selected.' ) ; } $ this -> setSelector ( $ selector ) ; if ( empty ( $ this -> instances [ $ this -> selector ] ) ) { $ instanceId = $ this -> context -> element ( 'field' , $ this -> selector ) -> getAttribute ( 'id' ) ; $ instance = sprintf ( $ this -> object , $ instanceId ) ; if ( ! $ this -> context -> executeJs ( "return !!$instance" ) ) { throw new \ Exception ( sprintf ( 'Editor "%s" was not found.' , $ instanceId ) ) ; } $ this -> instances [ $ this -> selector ] = $ instance ; } return $ this -> instances [ $ this -> selector ] ; }
6021	public function setApiKey ( $ apiKey ) { $ this -> apiKey = $ apiKey ; list ( , $ datacentre ) = explode ( '-' , $ this -> apiKey ) ; $ this -> apiUrl = str_replace ( '<dc>' , $ datacentre , $ this -> apiUrl ) ; }
1102	protected function hasChange ( ) { return ! ( $ this -> bound1 ( ) == $ this -> node -> getRight ( ) || $ this -> bound1 ( ) == $ this -> node -> getLeft ( ) ) ; }
796	public function getAnnotationEnd ( $ index ) { $ currentIndex = null ; if ( isset ( $ this [ $ index + 2 ] ) ) { if ( $ this [ $ index + 2 ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { $ currentIndex = $ index + 2 ; } elseif ( isset ( $ this [ $ index + 3 ] ) && $ this [ $ index + 2 ] -> isType ( DocLexer :: T_NONE ) && $ this [ $ index + 3 ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) && Preg :: match ( '/^(\R\s*\*\s*)*\s*$/' , $ this [ $ index + 2 ] -> getContent ( ) ) ) { $ currentIndex = $ index + 3 ; } } if ( null !== $ currentIndex ) { $ level = 0 ; for ( $ max = \ count ( $ this ) ; $ currentIndex < $ max ; ++ $ currentIndex ) { if ( $ this [ $ currentIndex ] -> isType ( DocLexer :: T_OPEN_PARENTHESIS ) ) { ++ $ level ; } elseif ( $ this [ $ currentIndex ] -> isType ( DocLexer :: T_CLOSE_PARENTHESIS ) ) { -- $ level ; } if ( 0 === $ level ) { return $ currentIndex ; } } return null ; } return $ index + 1 ; }
671	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } $ model -> scenario = $ this -> scenario ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) === false && ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to update the object for unknown reason.' ) ; } return $ model ; }
8565	private function _convertGetEligibleShippingServices ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsGetEligibleShippingServicesRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsGetEligibleShippingServicesRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } return $ parameters ; }
3421	protected function loadModels ( ) { $ queryType = 'UserQuery::getList' ; $ sort = $ this -> sort ; $ filter = $ this -> normalizeFilter ( ) ; $ params = [ 'SELECT' => $ this -> propsMustBeSelected ( ) ? [ 'UF_*' ] : ( $ this -> normalizeUfSelect ( ) ? : false ) , 'NAV_PARAMS' => $ this -> navigation , 'FIELDS' => $ this -> normalizeSelect ( ) , ] ; $ selectGroups = $ this -> groupsMustBeSelected ( ) ; $ keyBy = $ this -> keyBy ; $ callback = function ( ) use ( $ sort , $ filter , $ params , $ selectGroups ) { $ users = [ ] ; $ rsUsers = $ this -> bxObject -> getList ( $ sort , $ sortOrder = false , $ filter , $ params ) ; while ( $ arUser = $ this -> performFetchUsingSelectedMethod ( $ rsUsers ) ) { if ( $ selectGroups ) { $ arUser [ 'GROUP_ID' ] = $ this -> bxObject -> getUserGroup ( $ arUser [ 'ID' ] ) ; } $ this -> addItemToResultsUsingKeyBy ( $ users , new $ this -> modelName ( $ arUser [ 'ID' ] , $ arUser ) ) ; } return new Collection ( $ users ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'sort' , 'filter' , 'params' , 'selectGroups' , 'keyBy' ) , $ callback ) ; }
2453	public static function findByHashAndPid ( $ strHash , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findOneBy ( array ( "($t.hash=? AND $t.pid=?)" ) , array ( $ strHash , $ intPid ) , $ arrOptions ) ; }
4239	public function onBootstrap ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ collectWas = $ this -> debug -> setCfg ( 'collect' , true ) ; $ this -> debug -> groupSummary ( ) ; $ this -> debug -> group ( 'environment' , $ this -> debug -> meta ( array ( 'hideIfEmpty' => true , 'level' => 'info' , ) ) ) ; $ this -> logPhpInfo ( ) ; $ this -> logServerVals ( ) ; $ this -> logRequest ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> setCfg ( 'collect' , $ collectWas ) ; }
8501	public function setGetMatchingProductForIdResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMatchingProductForIdResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10600	public function returnUrl ( ) { $ return = '' ; $ return .= empty ( $ this -> _urlParts [ 'scheme' ] ) ? '' : $ this -> _urlParts [ 'scheme' ] . '://' ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : $ this -> _urlParts [ 'user' ] ; $ return .= empty ( $ this -> _urlParts [ 'pass' ] ) || empty ( $ this -> _urlParts [ 'user' ] ) ? '' : ':' . $ this -> _urlParts [ 'pass' ] ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : '@' ; $ return .= empty ( $ this -> _urlParts [ 'host' ] ) ? '' : $ this -> _urlParts [ 'host' ] ; $ return .= empty ( $ this -> _urlParts [ 'port' ] ) ? '' : ':' . $ this -> _urlParts [ 'port' ] ; $ return .= empty ( $ this -> _urlParts [ 'path' ] ) ? '' : '/' . ltrim ( $ this -> _urlParts [ 'path' ] , '/' ) ; $ return .= empty ( $ this -> _urlParts [ 'query' ] ) ? '' : '?' . $ this -> _urlParts [ 'query' ] ; $ return .= empty ( $ this -> _urlParts [ 'fragment' ] ) ? '' : '#' . $ this -> _urlParts [ 'fragment' ] ; return $ return ; }
2864	public function getLastFilePosition ( $ filePath ) { if ( ! file_exists ( $ filePath ) ) { return 0 ; } $ f = fopen ( $ filePath , 'r' ) ; fseek ( $ f , - 1 , SEEK_END ) ; return ftell ( $ f ) ; }
10244	public function getImplementedFunctionNames ( ) { $ returnValue = [ ] ; foreach ( self :: $ phpSpreadsheetFunctions as $ functionName => $ function ) { if ( $ this -> isImplemented ( $ functionName ) ) { $ returnValue [ ] = $ functionName ; } } return $ returnValue ; }
11512	public function actionRequest ( ) { if ( ! $ this -> module -> enablePasswordRecovery ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( [ 'class' => RecoveryForm :: className ( ) , 'scenario' => 'request' , ] ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> sendRecoveryMessage ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Recovery message sent' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'request' , [ 'model' => $ model , ] ) ; }
9790	public function getFormattedValue ( ) { return ( string ) NumberFormat :: toFormattedString ( $ this -> getCalculatedValue ( ) , $ this -> getStyle ( ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; }
12956	public function remove ( $ id ) { if ( ! $ this -> has ( $ id ) ) { throw new NotFoundException ( sprintf ( '%s not found in %s' , $ id , __CLASS__ ) ) ; } unset ( $ this -> objects [ $ id ] ) ; }
12781	private function decrypt ( $ encrypted , $ appId ) { try { $ key = $ this -> getAESKey ( ) ; $ ciphertext = base64_decode ( $ encrypted , true ) ; $ iv = substr ( $ key , 0 , 16 ) ; $ decrypted = openssl_decrypt ( $ ciphertext , 'aes-256-cbc' , $ key , OPENSSL_RAW_DATA | OPENSSL_NO_PADDING , $ iv ) ; } catch ( BaseException $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_DECRYPT_AES ) ; } try { $ result = $ this -> decode ( $ decrypted ) ; if ( strlen ( $ result ) < 16 ) { return '' ; } $ content = substr ( $ result , 16 , strlen ( $ result ) ) ; $ listLen = unpack ( 'N' , substr ( $ content , 0 , 4 ) ) ; $ xmlLen = $ listLen [ 1 ] ; $ xml = substr ( $ content , 4 , $ xmlLen ) ; $ fromAppId = trim ( substr ( $ content , $ xmlLen + 4 ) ) ; } catch ( BaseException $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_INVALID_XML ) ; } if ( $ fromAppId !== $ appId ) { throw new EncryptionException ( 'Invalid appId.' , EncryptionException :: ERROR_INVALID_APPID ) ; } $ dataSet = json_decode ( $ xml , true ) ; if ( $ dataSet && ( JSON_ERROR_NONE === json_last_error ( ) ) ) { $ xml = XML :: build ( $ dataSet ) ; } return $ xml ; }
3566	public function setAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ this -> hasColumn ( $ key ) && $ this -> allowsMeta ( $ key ) && ! $ this -> hasSetMutator ( $ key ) ) { return $ this -> setMeta ( $ key , $ value ) ; } return $ next ( $ value , $ args ) ; } ; }
5890	protected function filterList ( array $ nodes = array ( ) , array $ rules = array ( ) ) { if ( ! empty ( $ rules ) ) { foreach ( $ nodes as $ node ) { if ( ! $ node instanceof AbstractNode ) { continue ; } $ props = $ node -> getInfo ( false ) ; $ props = array_intersect_key ( $ props , $ rules ) ; $ match = true ; foreach ( $ props as $ key => $ val ) { if ( $ val instanceof StringHelper ) { $ match = $ val -> contains ( $ rules [ $ key ] , true ) ; } else { $ match = $ val == $ rules [ $ key ] ; } if ( $ match === false ) { unset ( $ nodes [ $ node -> getId ( ) ] ) ; } } } } return $ nodes ; }
12123	public function onEntryUpdate ( ContentfulEntryEvent $ e ) { $ entry = $ e -> getEntry ( ) ; $ key = $ this -> getCacheKeyItem ( $ entry -> getId ( ) , 'uri' ) ; $ urisForItemOption = Option :: fromValue ( $ this -> cache -> fetch ( $ key ) , false ) ; if ( $ urisForItemOption -> isEmpty ( ) ) { Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ entry ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] Entry "%s" is not used.' , $ entry -> getId ( ) ) ) ; } ) ; return ; } $ urisForItem = $ urisForItemOption -> get ( ) ; foreach ( $ urisForItem as $ uri => $ bool ) { $ key = $ this -> getCacheKeyRequest ( sha1 ( $ uri ) , 'lastmodified' ) ; $ lastModified = $ this -> cache -> fetch ( $ key ) ; if ( $ lastModified >= $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) { Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ lastModified , $ uri ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] "%s" was last modified at "%s". Entry is older.' , $ uri , $ lastModified ) ) ; } ) ; continue ; } $ this -> cache -> save ( $ key , $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) ; Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ entry , $ uri ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] Setting last modified time for "%s" to "%s".' , $ uri , $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) ) ; } ) ; } }
4624	public function pickNewNode ( ) { $ this -> getActiveNode ( ) -> setInactive ( true ) ; $ this -> attempts ++ ; $ this -> inactiveNodes [ $ this -> getActiveNodeIndex ( ) ] = $ this -> getActiveNode ( ) ; unset ( $ this -> nodes [ $ this -> getActiveNodeIndex ( ) ] ) ; $ this -> setActiveNodeIndex ( $ this -> pickNode ( ) ) ; return $ this ; }
3487	private static function tryResolveByWebTokenJwtSystem ( ) : ? WebTokenJwtSignatureGenerator { $ requiredClasses = [ WebTokenComponentJws :: class , WebTokenComponentJwk :: class , WebTokenComponentJWKFactory :: class , ] ; foreach ( $ requiredClasses as $ requiredClass ) { if ( ! class_exists ( $ requiredClass ) ) { return null ; } } return new WebTokenJwtSignatureGenerator ( ) ; }
6160	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyRequest ( $ item ) ; } return $ this ; }
6138	protected function parseUri ( $ uriString = '' ) { $ status = @ preg_match ( "~^((//)([^/?#]*))([^?#]*)(\?([^#]*))?(#(.*))?$~" , $ uriString , $ matches ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI scheme-specific decomposition failed" ) ; } if ( ! $ status ) { return ; } $ this -> path = ( isset ( $ matches [ 4 ] ) ) ? $ matches [ 4 ] : '' ; $ this -> query = ( isset ( $ matches [ 6 ] ) ) ? $ matches [ 6 ] : '' ; $ this -> fragment = ( isset ( $ matches [ 8 ] ) ) ? $ matches [ 8 ] : '' ; $ status = @ preg_match ( "~^(([^:@]*)(:([^@]*))?@)?([^:]+)(:(.*))?$~" , ( isset ( $ matches [ 3 ] ) ) ? $ matches [ 3 ] : "" , $ matches ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI scheme-specific authority decomposition failed" ) ; } if ( ! $ status ) { return ; } $ this -> user = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : "" ; $ this -> pass = isset ( $ matches [ 4 ] ) ? $ matches [ 4 ] : "" ; $ this -> host = isset ( $ matches [ 5 ] ) ? $ matches [ 5 ] : "" ; $ this -> port = isset ( $ matches [ 7 ] ) ? $ matches [ 7 ] : "" ; }
307	private function sizeToBytes ( $ sizeStr ) { switch ( substr ( $ sizeStr , - 1 ) ) { case 'M' : case 'm' : return ( int ) $ sizeStr * 1048576 ; case 'K' : case 'k' : return ( int ) $ sizeStr * 1024 ; case 'G' : case 'g' : return ( int ) $ sizeStr * 1073741824 ; default : return ( int ) $ sizeStr ; } }
6862	protected function registerFactory ( ) { $ this -> app -> singleton ( 'notifyme.factory' , function ( ) { return new NotifyMeFactory ( ) ; } ) ; $ this -> app -> alias ( 'notifyme.factory' , NotifyMeFactory :: class ) ; $ this -> app -> alias ( 'notifyme.factory' , FactoryInterface :: class ) ; }
788	public function getAttributeHint ( $ attribute ) { $ hints = $ this -> attributeHints ( ) ; return isset ( $ hints [ $ attribute ] ) ? $ hints [ $ attribute ] : '' ; }
5709	public function getButtonName ( ) { $ raw = $ this -> buttonName ? : $ this -> getButtonText ( ) ; return preg_replace ( '/[^a-z0-9-_]/' , '' , strtolower ( $ this -> getButtonText ( ) ) ) ; }
9198	public function getRedirectUrlForAuth ( ) { $ oauth = new Oauth1 ( array ( 'consumer_key' => $ this -> credentials -> getConsumerKey ( ) , 'consumer_secret' => $ this -> credentials -> getConsumerSecret ( ) , 'callback' => $ this -> credentials -> getCallbackUrl ( ) ) ) ; $ this -> guzzleClient -> getEmitter ( ) -> attach ( $ oauth ) ; $ requestTokenResponse = $ this -> guzzleClient -> post ( Config :: get ( 'oauth_request_token' ) , array ( 'auth' => 'oauth' ) ) ; $ oauthToken = array ( ) ; parse_str ( $ requestTokenResponse -> getBody ( ) , $ oauthToken ) ; $ params = http_build_query ( array ( 'oauth_token' => $ oauthToken [ 'oauth_token' ] ) ) ; return ( Config :: get ( 'base_url' ) . Config :: get ( 'oauth_authenticate' ) . '?' . $ params ) ; }
9941	public function setTitle ( $ pValue , $ updateFormulaCellReferences = true , $ validate = true ) { if ( $ this -> getTitle ( ) == $ pValue ) { return $ this ; } $ oldTitle = $ this -> getTitle ( ) ; if ( $ validate ) { self :: checkSheetTitle ( $ pValue ) ; if ( $ this -> parent ) { if ( $ this -> parent -> sheetNameExists ( $ pValue ) ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 29 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 29 ) ; } $ i = 1 ; while ( $ this -> parent -> sheetNameExists ( $ pValue . ' ' . $ i ) ) { ++ $ i ; if ( $ i == 10 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 28 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 28 ) ; } } elseif ( $ i == 100 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 27 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 27 ) ; } } } $ pValue .= " $i" ; } } } $ this -> title = $ pValue ; $ this -> dirty = true ; if ( $ this -> parent && $ this -> parent -> getCalculationEngine ( ) ) { $ newTitle = $ this -> getTitle ( ) ; $ this -> parent -> getCalculationEngine ( ) -> renameCalculationCacheForWorksheet ( $ oldTitle , $ newTitle ) ; if ( $ updateFormulaCellReferences ) { ReferenceHelper :: getInstance ( ) -> updateNamedFormulas ( $ this -> parent , $ oldTitle , $ newTitle ) ; } } return $ this ; }
10906	public function remove ( ) : bool { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE | \ sndsgd \ Fs :: WRITABLE ) === false ) { $ this -> error = "failed to remove directory; {$this->error}" ; return false ; } foreach ( $ this -> getList ( ) as $ entity ) { if ( $ entity -> remove ( ) === false ) { $ this -> error = $ entity -> getError ( ) ; return false ; } } if ( @ rmdir ( $ this -> path ) === false ) { $ this -> setError ( "failed to remove directory '{$this->path}'" ) ; return false ; } return true ; }
11363	public static function mailListTagger ( array $ list ) { $ str = '' ; foreach ( $ list as $ name => $ mail ) { if ( is_string ( $ mail ) ) { $ str .= self :: mailTagger ( $ mail , $ name ) . Mailer :: $ ADDERSSES_SEPARATOR ; } elseif ( is_array ( $ mail ) ) { foreach ( $ mail as $ subname => $ submail ) { $ str .= self :: mailTagger ( $ submail , $ subname ) . Mailer :: $ ADDERSSES_SEPARATOR ; } } } return $ str ; }
11941	public function onExecuteAction ( ExecuteActionEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ position = 1 ; foreach ( $ request -> getConfig ( ) -> getArray ( 'argument' ) as $ argument ) { $ this -> validateArgument ( $ request , $ argument , $ position ++ ) ; } }
10758	protected function prepareHeader ( array $ data ) { return array_merge_recursive ( [ 'date' => trans ( 'dashboard::logs.date' ) , 'all' => trans ( 'dashboard::logs.all' ) , ] , $ this -> levels -> names ( $ this -> locale ) ) ; }
1316	public function post ( $ path , array $ parameters = [ ] , $ json = false ) { return $ this -> http ( 'POST' , self :: API_HOST , $ path , $ parameters , $ json ) ; }
7865	protected function drawBordered ( $ content ) { $ left = $ this -> geometry -> getLeftBordersWith ( static :: BORDER_X ) ; $ right = $ this -> geometry -> getRightBordersWith ( static :: BORDER_X ) ; $ this -> drawRow ( $ left . $ content . $ right ) ; }
6005	public function addCategoryResponse ( $ item ) { if ( ! ( $ item instanceof CategoryResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new CategoryResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate CategoryResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "CategoryResponse"!' , E_USER_WARNING ) ; } } $ this -> categories [ ] = $ item ; return $ this ; }
582	public function setAssetManager ( $ assetManager ) { if ( is_scalar ( $ assetManager ) ) { throw new Exception ( '"' . get_class ( $ this ) . '::assetManager" should be either object or array - "' . gettype ( $ assetManager ) . '" given.' ) ; } $ this -> _assetManager = $ assetManager ; }
6925	private function getFindOneByCountryAndMethodAndWeightQuery ( ) { if ( null === $ this -> findOneByCountryAndMethodAndWeightQuery ) { $ qb = $ this -> getCollectionQueryBuilder ( 'o' ) ; $ qb -> join ( 'o.zone' , 'z' ) -> join ( 'o.method' , 'm' ) -> andWhere ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'z.countries' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'o.weight' , ':weight' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.method' , ':method' ) ) -> addOrderBy ( 'o.weight' , 'ASC' ) -> setMaxResults ( 1 ) ; $ this -> findOneByCountryAndMethodAndWeightQuery = $ qb -> getQuery ( ) ; } return $ this -> findOneByCountryAndMethodAndWeightQuery ; }
8325	public function deletePingback ( $ uri ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=del_pingback&addr={$uri}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
8228	protected function assertLimits ( ) { if ( $ this -> storage -> getUsersCount ( ) >= $ this -> config [ "maxUsers" ] ) { $ this -> session -> addFlash ( "error" , "New registrations are currently disabled." ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } }
8660	private function convertGetReportList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetReportRequestIdList ( ) ) { $ reportRequestIdList = $ request -> getReportRequestIdList ( ) ; foreach ( $ reportRequestIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportRequestIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
76	public function remove ( ) { $ offset = $ this -> key ( ) ; $ this -> offsetUnset ( $ offset ) ; $ this -> seek ( $ offset ) ; }
7976	public function addSecondaryDnsDomains ( $ domain2add , $ ip ) { self :: getClient ( ) -> addSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2add , $ ip ) ; return true ; }
208	public static function select ( $ prompt , $ options = [ ] ) { top : static :: stdout ( "$prompt [" . implode ( ',' , array_keys ( $ options ) ) . ',?]: ' ) ; $ input = static :: stdin ( ) ; if ( $ input === '?' ) { foreach ( $ options as $ key => $ value ) { static :: output ( " $key - $value" ) ; } static :: output ( ' ? - Show help' ) ; goto top ; } elseif ( ! array_key_exists ( $ input , $ options ) ) { goto top ; } return $ input ; }
7028	static function getDefaultImplementations ( ) { return [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ Cart :: class , Cart \ Model \ CartAddressInterface :: class => Cart \ Entity \ CartAddress :: class , Customer \ Model \ CustomerInterface :: class => Customer \ Entity \ Customer :: class , Customer \ Model \ CustomerGroupInterface :: class => Customer \ Entity \ CustomerGroup :: class , Customer \ Model \ CustomerAddressInterface :: class => Customer \ Entity \ CustomerAddress :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ Order :: class , Order \ Model \ OrderAddressInterface :: class => Order \ Entity \ OrderAddress :: class , Payment \ Model \ PaymentMethodInterface :: class => Payment \ Entity \ PaymentMethod :: class , Payment \ Model \ PaymentTermInterface :: class => Payment \ Entity \ PaymentTerm :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ Quote :: class , Quote \ Model \ QuoteAddressInterface :: class => Quote \ Entity \ QuoteAddress :: class , Shipment \ Model \ ShipmentMethodInterface :: class => Shipment \ Entity \ ShipmentMethod :: class , Supplier \ Model \ SupplierInterface :: class => Supplier \ Entity \ Supplier :: class , Supplier \ Model \ SupplierAddressInterface :: class => Supplier \ Entity \ SupplierAddress :: class , Supplier \ Model \ SupplierDeliveryInterface :: class => Supplier \ Entity \ SupplierDelivery :: class , Supplier \ Model \ SupplierOrderInterface :: class => Supplier \ Entity \ SupplierOrder :: class , Supplier \ Model \ SupplierProductInterface :: class => Supplier \ Entity \ SupplierProduct :: class , Support \ Model \ TicketInterface :: class => Support \ Entity \ Ticket :: class , Support \ Model \ TicketMessageInterface :: class => Support \ Entity \ TicketMessage :: class , ] ; }
4854	protected function profiling ( $ signal = true ) { static $ timeStart ; if ( $ signal ) { $ timeStart = microtime ( true ) ; } if ( ! $ signal ) { $ this -> timeExecution = ( microtime ( true ) - $ timeStart ) / 60 ; return $ this -> timeExecution ; } }
1938	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> newsletters ) || ! \ is_array ( $ this -> User -> newsletters ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> newsletters ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_newsletter_channel' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_newsletter_channel' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, newsletters, newsletterp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrNewsletterp = Contao \ StringUtil :: deserialize ( $ objGroup -> newsletterp ) ; if ( \ is_array ( $ arrNewsletterp ) && \ in_array ( 'create' , $ arrNewsletterp ) ) { $ arrNewsletters = Contao \ StringUtil :: deserialize ( $ objGroup -> newsletters , true ) ; $ arrNewsletters [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET newsletters=? WHERE id=?" ) -> execute ( serialize ( $ arrNewsletters ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT newsletters, newsletterp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrNewsletterp = Contao \ StringUtil :: deserialize ( $ objUser -> newsletterp ) ; if ( \ is_array ( $ arrNewsletterp ) && \ in_array ( 'create' , $ arrNewsletterp ) ) { $ arrNewsletters = Contao \ StringUtil :: deserialize ( $ objUser -> newsletters , true ) ; $ arrNewsletters [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET newsletters=? WHERE id=?" ) -> execute ( serialize ( $ arrNewsletters ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> newsletter = $ root ; } }
7856	private function publishConfig ( ) { $ config = __DIR__ . '/config/workflow.php' ; $ this -> publishes ( [ $ config => config_path ( 'workflow.php' ) ] ) ; $ this -> mergeConfigFrom ( $ config , 'workflow' ) ; }
4492	public function broadcast ( Message $ message , string $ topicArn ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $topicArn" , [ 'Message' => $ message , ] ) ; return ; } $ this -> messages -> send ( $ message , $ topicArn ) ; }
12098	public function niceDate ( \ DateTime $ date ) { $ now = $ this -> system -> getDate ( ) ; if ( $ now -> format ( 'Y-m-d' ) === $ date -> format ( 'Y-m-d' ) ) { return $ date -> format ( 'H:i' ) ; } elseif ( $ now -> format ( 'Y-m' ) === $ date -> format ( 'Y-m' ) && $ date -> format ( 'd' ) + 1 == $ now -> format ( 'd' ) ) { return sprintf ( $ this -> translate ( 'yesterday, %s' ) , $ date -> format ( 'H:i' ) ) ; } return $ date -> format ( 'd-m-Y' ) ; }
5196	public function addSearchResult ( $ index , $ type , array $ documents ) { $ result = [ 'took' => 5 , 'timed_out' => false , '_shards' => [ 'total' => 5 , 'successful' => 5 , 'failed' => 0 ] , 'hits' => [ 'total' => count ( $ documents ) , 'max_score' => 1 , 'hits' => [ ] ] ] ; foreach ( $ documents as $ document ) { $ result [ 'hits' ] [ 'hits' ] [ ] = [ '_index' => $ index , '_type' => $ type , '_id' => $ document [ 'id' ] , '_score' => 1 , '_source' => $ document ] ; } return $ this -> addResult ( 'search' , $ result ) ; }
135	public function ensureBinariesPresence ( PackageInterface $ package ) { try { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; } catch ( \ InvalidArgumentException $ e ) { return ; } if ( $ installer instanceof BinaryPresenceInterface ) { $ installer -> ensureBinariesPresence ( $ package ) ; } }
7185	public static function build ( StockUnitInterface $ unit , SaleInterface $ sale ) { $ releasable = 0 ; $ map = [ ] ; foreach ( $ unit -> getStockAssignments ( ) as $ a ) { if ( $ sale === $ s = $ a -> getSaleItem ( ) -> getSale ( ) ) { continue ; } if ( $ s -> getShipmentState ( ) === ShipmentStates :: STATE_PREPARATION ) { continue ; } if ( 0 < $ d = $ a -> getSoldQuantity ( ) - $ a -> getShippedQuantity ( ) ) { $ releasable += $ d ; $ map [ $ a -> getId ( ) ] = $ d ; } } arsort ( $ map , \ SORT_NUMERIC ) ; $ candidate = new static ; $ candidate -> unit = $ unit ; $ candidate -> shippable = $ unit -> getShippableQuantity ( ) ; $ candidate -> reservable = $ unit -> getReservableQuantity ( ) ; $ candidate -> releasable = $ releasable ; $ candidate -> map = $ map ; return $ candidate ; }
6816	public function isSameAs ( Adjustment $ adjustment ) : bool { return $ this -> name === $ adjustment -> getName ( ) && $ this -> rate === $ adjustment -> getRate ( ) ; }
12946	protected function parseTags ( $ tags ) { return array_unique ( is_array ( $ tags ) ? array_filter ( $ tags ) : preg_split ( '/\s*,\s*/' , $ tags , - 1 , PREG_SPLIT_NO_EMPTY ) ) ; }
2842	public function getBlocksAsTree ( ) { $ blocks = $ this -> getRequestInfo ( ) -> getBlocks ( ) ; $ tree = new Varien_Data_Tree ( ) ; $ rootNodes = array ( ) ; foreach ( $ blocks as $ block ) { $ parentNode = $ tree -> getNodeById ( $ block -> getParentName ( ) ) ; $ node = new Varien_Data_Tree_Node ( array ( 'name' => $ block -> getName ( ) , 'class' => $ block -> getClass ( ) , 'template' => $ block -> getTemplateFile ( ) , 'duration' => $ block -> getRenderedDuration ( ) , 'count' => $ block -> getRenderedCount ( ) ) , 'name' , $ tree , $ parentNode ) ; $ tree -> addNode ( $ node , $ parentNode ) ; if ( ! $ parentNode ) { $ rootNodes [ ] = $ node ; } } return $ rootNodes ; }
7139	protected function getGroupsForStep ( $ step ) { $ groups = [ 'Default' ] ; if ( $ step === static :: CHECKOUT_STEP ) { $ groups [ ] = 'Checkout' ; $ groups [ ] = 'Identity' ; $ groups [ ] = 'Availability' ; } elseif ( $ step === static :: SHIPMENT_STEP ) { $ groups [ ] = 'Availability' ; } return $ groups ; }
12336	public function changePasswordAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'change-password' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getChangePasswordForm ( ) ; $ form -> setObject ( $ this -> cmsAuthentication ( ) -> getIdentity ( ) ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ identity = $ this -> getUserService ( ) -> changePassword ( $ post ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/index/change-password-success' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
72	public function authorizeOAuth ( $ originUrl ) { if ( $ originUrl !== 'bitbucket.org' ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config bitbucket.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , 'x-token-auth' , trim ( $ output ) ) ; return true ; } return false ; }
9411	protected function exceptions ( \ Exception $ exception , $ uri ) { $ interface = 'Phroute\Phroute\Exception\HttpRouteNotFoundException' ; $ message = ( string ) $ exception -> getMessage ( ) ; is_a ( $ exception , $ interface ) && $ message = 'Route "' . $ uri . '" not found' ; throw new \ UnexpectedValueException ( ( string ) $ message ) ; }
844	public function clearEmptyTokens ( ) { $ limit = $ this -> count ( ) ; $ index = 0 ; for ( ; $ index < $ limit ; ++ $ index ) { if ( $ this -> isEmptyAt ( $ index ) ) { break ; } } if ( $ limit === $ index ) { return ; } for ( $ count = $ index ; $ index < $ limit ; ++ $ index ) { if ( ! $ this -> isEmptyAt ( $ index ) ) { $ this [ $ count ++ ] = $ this [ $ index ] ; } } $ this -> setSize ( $ count ) ; }
3245	public function onCharge ( $ order ) { $ this -> statusCode = 'pending' ; $ this -> detail = 'pending response, token:' . $ this -> token ; return parent :: onCharge ( $ order ) ; }
7978	public function setSshKey ( $ key ) { self :: getClient ( ) -> setSshKey ( $ this -> pp , $ this -> sn , $ key ) ; }
490	protected function findPrimaryKeys ( $ table ) { $ result = [ ] ; foreach ( $ this -> findTableConstraints ( $ table , 'PRIMARY KEY' ) as $ row ) { $ result [ ] = $ row [ 'field_name' ] ; } $ table -> primaryKey = $ result ; }
12046	public function getThumbnails ( $ videoId , $ format = null ) { $ listResponse = $ this -> videos -> listVideos ( 'snippet' , array ( 'id' => $ videoId ) ) ; if ( empty ( $ listResponse ) ) { throw new \ RuntimeException ( sprintf ( 'Could not find video with id %s' , $ videoId ) ) ; } $ video = $ listResponse [ 0 ] ; $ videoSnippet = $ video [ 'snippet' ] ; if ( is_null ( $ format ) ) { return $ videoSnippet [ 'thumbnails' ] [ 'data' ] ; } if ( ! in_array ( $ format , array ( 'default' , 'medium' , 'high' ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid format "%s"' , $ format ) ) ; } return $ videoSnippet [ 'thumbnails' ] [ 'data' ] [ $ format ] ; }
10014	public function getIndex ( Worksheet $ pSheet ) { foreach ( $ this -> workSheetCollection as $ key => $ value ) { if ( $ value -> getHashCode ( ) == $ pSheet -> getHashCode ( ) ) { return $ key ; } } throw new Exception ( 'Sheet does not exist.' ) ; }
8203	protected function peekJob ( $ tube , $ state ) { $ peekMethod = 'peek' . ucfirst ( $ state ) ; try { return $ this -> getPheanstalk ( ) -> $ peekMethod ( $ tube ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
1863	protected function validate ( ) { foreach ( \ func_get_args ( ) as $ strPath ) { if ( $ strPath == '' ) { throw new \ RuntimeException ( 'No file or folder name given' ) ; } elseif ( Validator :: isInsecurePath ( $ strPath ) ) { throw new \ RuntimeException ( 'Invalid file or folder name ' . $ strPath ) ; } } }
1516	public function readRelatedResource ( StoreInterface $ store , FetchRelated $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelated ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ related ) ; }
954	protected function returnTo ( ) { $ return_to = Session :: get ( 'return_to' ) ; if ( $ return_to ) { Session :: forget ( 'return_to' ) ; return Redirect :: to ( $ return_to ) ; } return Redirect :: route ( 'home' ) ; }
7960	public function canChangeDslamProfile ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canChangeDslamProfile ; }
2285	protected static function server ( ) { $ strServer = ! empty ( $ _SERVER [ 'SERVER_ADDR' ] ) ? $ _SERVER [ 'SERVER_ADDR' ] : $ _SERVER [ 'LOCAL_ADDR' ] ; if ( empty ( $ strServer ) ) { $ strServer = @ gethostbyname ( $ _SERVER [ 'SERVER_NAME' ] ) ; } return $ strServer ; }
7045	private function getColumnNamesFromTable ( $ tableName , $ typeFilter = null ) { if ( ! $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ tableName ] ) ) { return [ ] ; } $ result = [ ] ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ tableName ) as $ column ) { if ( ( $ typeFilter === null ) || \ in_array ( $ column -> getType ( ) -> getName ( ) , $ typeFilter , true ) ) { $ result [ $ column -> getName ( ) ] = $ column -> getName ( ) ; } } if ( ! empty ( $ result ) ) { \ asort ( $ result ) ; return $ result ; } return $ result ; }
1109	protected function groupRootsByScope ( $ roots ) { $ rootsGroupedByScope = array ( ) ; foreach ( $ roots as $ root ) { $ key = $ this -> keyForScope ( $ root ) ; if ( ! isset ( $ rootsGroupedByScope [ $ key ] ) ) $ rootsGroupedByScope [ $ key ] = array ( ) ; $ rootsGroupedByScope [ $ key ] [ ] = $ root ; } return $ rootsGroupedByScope ; }
10430	protected function createPipelines ( ContainerBuilder $ container , array $ config ) { foreach ( $ config [ 'pipelines' ] as $ pipelineName => $ pipelineConfig ) { if ( ! isset ( $ pipelineConfig [ 'shop' ] ) ) { $ pipelineConfig [ 'shop' ] = $ container -> getParameter ( 'ongr_connections.active_shop' ) ; } $ serviceConfig = $ this -> prepareServiceConfigs ( $ container , $ pipelineConfig , $ pipelineName ) ; $ this -> createServices ( $ container , $ pipelineConfig [ 'provide_sources' ] , $ serviceConfig , "data_sync.{$pipelineName}.source" , 'onSource' ) ; $ this -> createServices ( $ container , $ pipelineConfig [ 'provide_consumers' ] , $ serviceConfig , "data_sync.{$pipelineName}.consume" , 'onConsume' ) ; foreach ( $ pipelineConfig [ 'types' ] as $ type => $ typeConfig ) { $ typeServiceConfig = $ this -> prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) ; $ serviceList = $ this -> getServiceList ( $ pipelineName , $ type ) ; foreach ( $ serviceList as $ name => $ service ) { $ this -> createServices ( $ container , array_merge ( $ pipelineConfig [ $ name ] , $ typeConfig [ $ name ] ) , $ typeServiceConfig , $ service [ 'tag' ] , $ service [ 'method' ] ) ; } } } }
5552	public function getResponseCode ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getResponseCode ( ) ; } return $ this -> frameset -> getResponseCode ( ) ; }
8516	public function updateInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_UpdateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8242	protected function handleLogin ( Request $ httpRequest ) { $ post = $ httpRequest -> request ; if ( ! $ post -> has ( "username" ) || ! $ post -> has ( "password" ) ) { return ; } if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: LOGIN_CSRF_ACTION ) ) { $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } $ username = strtolower ( trim ( $ post -> get ( "username" ) ) ) ; $ password = new Password ( $ post -> get ( "password" ) ) ; if ( ! $ this -> limit -> action ( "login" , false , array ( "name" => $ username ) ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } if ( ! $ this -> loginAttempt ( $ username , $ password ) ) { $ this -> logInvalidLoginAttempt ( $ username ) ; $ this -> limit -> action ( "login" , true , array ( "name" => $ username ) ) ; $ this -> session -> addFlash ( "error" , "Invalid username or password" ) ; $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } else { $ userData = $ this -> storage -> getUserByName ( $ username ) ; if ( $ this -> needsPasswordRehash ( $ userData ) ) { $ this -> passwordRehash ( $ username , $ password ) ; } $ this -> login ( $ username , $ userData ) ; $ this -> picoAuth -> afterLogin ( ) ; } }
6203	public static function start ( $ apiKey , $ notifyOnWarning = false , array $ options = array ( ) ) { if ( ! isset ( self :: $ instance ) ) { $ config = new Configuration ( $ apiKey , $ options ) ; $ client = new Client ( $ config ) ; self :: $ instance = new self ( $ client , $ notifyOnWarning ) ; if ( null !== $ config -> get ( 'errorReportingLevel' ) ) { self :: $ instance -> addErrorFilter ( new ErrorReporting ( $ config ) ) ; } self :: $ instance -> addExceptionFilter ( new AirbrakeExceptionFilter ( ) ) ; set_error_handler ( array ( self :: $ instance , 'onError' ) ) ; set_exception_handler ( array ( self :: $ instance , 'onException' ) ) ; register_shutdown_function ( array ( self :: $ instance , 'onShutdown' ) ) ; } return self :: $ instance ; }
4347	private function getCfgAll ( ) { $ cfg = array ( ) ; foreach ( \ array_keys ( $ this -> configKeys ) as $ classname ) { if ( $ classname === 'debug' ) { $ cfg [ 'debug' ] = $ this -> cfg ; } elseif ( isset ( $ this -> debug -> { $ classname } ) ) { $ cfg [ $ classname ] = $ this -> debug -> { $ classname } -> getCfg ( ) ; } elseif ( isset ( $ this -> cfgLazy [ $ classname ] ) ) { $ cfg [ $ classname ] = $ this -> cfgLazy [ $ classname ] ; } } return $ cfg ; }
12285	public function end ( ) : string { $ property = static :: END_ASSETS_NAME . static :: BLOCK_PROPERTY_SUFFIX ; return isset ( $ this -> $ property ) ? trim ( $ this -> make ( static :: END_ASSETS_NAME ) ) . PHP_EOL : PHP_EOL ; }
5024	private function findLeaf ( NodeInterface $ leaf , $ value ) { $ parts = is_array ( $ value ) ? $ value : explode ( $ this -> shouldUseNames ( ) ? ' | ' : '-' , $ value ) ; $ value = array_shift ( $ parts ) ; foreach ( $ leaf -> getChildren ( ) as $ item ) { $ compare = $ this -> shouldUseNames ( ) ? $ item -> getName ( ) : $ item -> getValue ( ) ; if ( $ compare == $ value ) { if ( count ( $ parts ) ) { return $ this -> findLeaf ( $ item , $ parts ) ; } return $ item ; } } if ( $ value && $ this -> shouldCreateLeafs ( ) ) { $ nodeClass = get_class ( $ leaf ) ; $ node = new $ nodeClass ( $ value ) ; $ leaf -> addChild ( $ node ) ; if ( count ( $ parts ) ) { return $ this -> findLeaf ( $ node , $ parts ) ; } return $ node ; } return null ; }
10045	private function createFromType ( Model $ model , Column $ column , $ item ) { $ result = null ; switch ( $ column -> getType ( ) ) { case Type :: TEXT : case Type :: TARRAY : case Type :: SIMPLE_ARRAY : case Type :: JSON_ARRAY : case Type :: OBJECT : case Type :: BLOB : $ result = new TextAreaFormItem ( ) ; break ; case Type :: INTEGER : case Type :: SMALLINT : case Type :: BIGINT : $ result = new IntegerFormItem ( ) ; break ; case Type :: DECIMAL : case Type :: FLOAT : $ result = new NumberFormItem ( ) ; break ; case Type :: BOOLEAN : $ result = new CheckboxFormItem ( ) ; break ; case Type :: DATE : $ result = new DateFormItem ( ) ; break ; case Type :: DATETIME : case Type :: DATETIMETZ : $ result = new DateTimeFormItem ( ) ; break ; case Type :: TIME : $ result = new TimeFormItem ( ) ; break ; case Type :: STRING : case Type :: GUID : default : $ result = new TextFormItem ( ) ; break ; } $ columnName = $ column -> getName ( ) ; $ result -> setName ( $ columnName ) ; $ result -> setLabel ( Lang :: trans ( $ this -> aujaConfigurator -> getColumnDisplayName ( $ model , $ columnName ) ) ) ; if ( $ item != null && isset ( $ item -> $ columnName ) ) { $ result -> setValue ( $ item -> $ columnName ) ; } return $ result ; }
2357	public function getFrontendUsername ( ) : ? string { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof FrontendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; }
2102	protected static function resolveCustomModifiers ( $ strDate ) { if ( strpos ( $ strDate , '::' ) === false ) { return $ strDate ; } System :: loadLanguageFile ( 'default' ) ; if ( ! $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'dayShortLength' ] ) { $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'dayShortLength' ] = 3 ; } if ( ! $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'monthShortLength' ] ) { $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'monthShortLength' ] = 3 ; } $ strReturn = '' ; $ chunks = preg_split ( "/([0-9]{1,2}::[1-4])/" , $ strDate , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; foreach ( $ chunks as $ chunk ) { list ( $ index , $ flag ) = explode ( '::' , $ chunk ) ; switch ( $ flag ) { case 1 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] [ $ index ] ; break ; case 2 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'DAYS_SHORT' ] [ $ index ] ; break ; case 3 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] [ ( $ index - 1 ) ] ; break ; case 4 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS_SHORT' ] [ ( $ index - 1 ) ] ; break ; default : $ strReturn .= $ chunk ; break ; } } return $ strReturn ; }
4743	public function validateOptIn ( ) { $ optInValue = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'rvw_oegdproptin' ) ; if ( $ this -> isReviewOptInValidationRequired ( ) && ! $ optInValue ) { return false ; } return true ; }
1629	public function getMonolog ( ) { foreach ( $ this -> loggers as $ logger ) { if ( is_callable ( [ $ logger , 'getMonolog' ] ) ) { $ monolog = $ logger -> getMonolog ( ) ; if ( $ monolog === null ) { continue ; } return $ monolog ; } } }
10457	public function to ( Uom $ uom ) { $ conversionFactor = Uom :: getConversionFactor ( $ this -> getUom ( ) , $ uom ) ; return new static ( $ this -> getAmount ( ) -> multiply ( $ conversionFactor ) , $ uom ) ; }
6405	public function consume ( $ remaining_taf ) { $ chunk_regexp = $ this -> getRegexp ( ) ; if ( preg_match ( $ chunk_regexp , $ remaining_taf , $ matches ) ) { $ found = $ matches ; } else { $ found = null ; } $ new_remaining_taf = preg_replace ( $ chunk_regexp , '' , $ remaining_taf , 1 ) ; return array ( 'found' => $ found , 'remaining' => $ new_remaining_taf , ) ; }
4644	public function stop ( Job $ job , $ timeout = 10 ) { foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { try { $ this -> docker -> getContainerManager ( ) -> stop ( $ service -> getContainer ( ) , [ 't' => $ timeout ] ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) != 304 ) { throw $ e ; } } $ this -> docker -> getContainerManager ( ) -> remove ( $ service -> getContainer ( ) , [ 'v' => true , 'force' => true ] ) ; $ service -> setContainer ( null ) ; } } }
12616	public function setAttributes ( array $ attributes ) { foreach ( $ attributes as $ key => $ attribute ) { if ( ! ( $ attribute instanceof AttributeInterface ) ) { if ( is_array ( $ attribute ) ) { $ attr = new AttributeCollection ( $ key ) ; $ attr -> setAttributes ( $ attribute ) ; $ attribute = $ attr ; } else { $ attribute = new Attribute ( $ key , $ attribute ) ; } } $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; } }
2611	public function getActiveVersion ( $ service , $ activeVersion ) { $ currActiveVersion = $ this -> determineVersions ( $ service -> versions ) ; if ( $ currActiveVersion [ 'active_version' ] != $ activeVersion ) { throw new LocalizedException ( __ ( 'Active versions mismatch.' ) ) ; } return $ currActiveVersion ; }
1901	public function validate ( ) { $ mandatory = $ this -> mandatory ; $ options = $ this -> getPost ( $ this -> strName ) ; if ( $ mandatory && \ is_array ( $ options ) ) { foreach ( $ options as $ option ) { if ( \ strlen ( $ option ) ) { $ this -> mandatory = false ; break ; } } } $ varInput = $ this -> validator ( $ options ) ; if ( ! empty ( $ varInput ) && ! $ this -> isValidOption ( $ varInput ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalid' ] ) ; } if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } else { $ this -> varValue = $ varInput ; } if ( $ mandatory ) { $ this -> mandatory = true ; } }
8597	public function listMarketplaceParticipationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6584	public function sum ( $ n , $ m = 0 ) { if ( $ m > 0 ) return $ this -> sum ( $ n + $ m ) - $ this -> sum ( $ m ) ; static :: ensureValid ( $ n ) ; return $ this -> b * ( 1 - pow ( $ this -> q , $ n ) ) / ( 1 - $ this -> q ) ; }
7697	function MsPowerpoint_SearchInSlides ( $ str , $ returnFirstFound = true ) { $ this -> MsPowerpoint_InitSlideLst ( ) ; $ files = array ( ) ; foreach ( $ this -> OpenXmlSlideLst as $ i => $ s ) $ files [ $ i + 1 ] = $ s [ 'idx' ] ; $ find = $ this -> TbsSearchInFiles ( $ files , $ str , $ returnFirstFound ) ; return $ find ; }
4584	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ this -> getSignature ( ) ) ; $ event -> setData ( $ data ) ; }
526	public function init ( ) { if ( $ this -> sourcePath !== null ) { $ this -> sourcePath = rtrim ( Yii :: getAlias ( $ this -> sourcePath ) , '/\\' ) ; } if ( $ this -> basePath !== null ) { $ this -> basePath = rtrim ( Yii :: getAlias ( $ this -> basePath ) , '/\\' ) ; } if ( $ this -> baseUrl !== null ) { $ this -> baseUrl = rtrim ( Yii :: getAlias ( $ this -> baseUrl ) , '/' ) ; } }
7683	function Ext_GetMainIdx ( ) { if ( ( $ this -> ExtInfo !== false ) && isset ( $ this -> ExtInfo [ 'main' ] ) ) { return $ this -> FileGetIdx ( $ this -> ExtInfo [ 'main' ] ) ; } else { return false ; } }
7870	protected function drawBorderBottom ( $ isCore = false ) { $ this -> geometry -> decreaseNesting ( ) ; $ crossroads = $ isCore ? static :: CROSSROADS_DOWN : static :: CROSSROADS ; $ this -> drawBorder ( static :: BORDER_SW , $ crossroads , static :: BORDER_SE ) ; }
2440	public function urlEncode ( ) : string { $ data = json_encode ( $ this ) ; if ( \ function_exists ( 'gzencode' ) && false !== ( $ encoded = @ gzencode ( $ data ) ) ) { $ data = $ encoded ; } return strtr ( base64_encode ( $ data ) , '+/=' , '-_,' ) ; }
1577	protected function validateDocumentCompliance ( $ document , ? ValidatorFactoryInterface $ validators ) : void { $ this -> passes ( $ this -> factory -> createNewResourceDocumentValidator ( $ document , $ this -> getResourceType ( ) , $ validators && $ validators -> supportsClientIds ( ) ) ) ; }
1189	protected function isImplemented ( $ rule ) { return in_array ( $ rule , $ this -> clientRules ) || in_array ( $ rule , $ this -> serverRules ) ; }
2832	public function stacktraceSqlAction ( ) { if ( $ query = $ this -> _initQuery ( ) ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ stripZendPath = $ helper -> canStripZendDbTrace ( ) ? 'lib/Zend/Db/Adapter' : '' ; $ trimPath = $ helper -> canTrimMagentoBaseDir ( ) ? Mage :: getBaseDir ( ) . DS : '' ; $ html = '<pre>' . Mage :: helper ( 'sheep_debug' ) -> formatStacktrace ( $ query -> getStackTrace ( ) , $ stripZendPath , $ trimPath ) . '</pre>' ; $ this -> getResponse ( ) -> setBody ( $ html ) ; } }
7287	public function getInvoicedAt ( $ latest = false ) { if ( 0 == $ this -> invoices -> count ( ) ) { return null ; } $ criteria = Criteria :: create ( ) ; $ criteria -> andWhere ( Criteria :: expr ( ) -> eq ( 'type' , InvoiceTypes :: TYPE_INVOICE ) ) -> orderBy ( [ 'createdAt' => $ latest ? Criteria :: DESC : Criteria :: ASC ] ) ; $ invoices = $ this -> invoices ; $ invoices = $ invoices -> matching ( $ criteria ) ; if ( false !== $ invoice = $ invoices -> first ( ) ) { return $ invoice -> getCreatedAt ( ) ; } return null ; }
1461	protected function orderAsc ( ) { $ this -> query -> orderBy ( $ this -> column ) ; if ( $ this -> isNotPagingOnKey ( ) ) { $ this -> query -> orderBy ( $ this -> key ) ; } return $ this ; }
4751	public function getPriceByPlanCode ( string $ planCode ) : float { $ plan = $ this -> getPlan ( $ planCode ) ; return ( array_key_exists ( 'recurring_price' , $ plan ) ) ? $ plan [ 'recurring_price' ] : 0 ; }
9384	public function getIcons ( ) { $ icons = [ ] ; foreach ( $ this -> getGroupedIcons ( ) as $ name => $ group ) { foreach ( $ group as $ id => $ icon ) { if ( ! isset ( $ icons [ $ id ] ) ) { $ icons [ $ id ] = isset ( $ icon [ 'name' ] ) ? $ icon [ 'name' ] : $ id ; } } } ksort ( $ icons ) ; return $ icons ; }
10297	private function writeTitle ( XMLWriter $ objWriter , Title $ title = null ) { if ( $ title === null ) { return ; } $ objWriter -> startElement ( 'c:title' ) ; $ objWriter -> startElement ( 'c:tx' ) ; $ objWriter -> startElement ( 'c:rich' ) ; $ objWriter -> startElement ( 'a:bodyPr' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:lstStyle' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:p' ) ; $ caption = $ title -> getCaption ( ) ; if ( ( is_array ( $ caption ) ) && ( count ( $ caption ) > 0 ) ) { $ caption = $ caption [ 0 ] ; } $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichTextForCharts ( $ objWriter , $ caption , 'a' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writeLayout ( $ objWriter , $ title -> getLayout ( ) ) ; $ objWriter -> startElement ( 'c:overlay' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
8324	public function getPingbacks ( ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get_pingback" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( strpos ( $ responseText , 'OK|' ) !== false ) { $ data = explode ( '|' , $ responseText ) ; unset ( $ data [ 0 ] ) ; return empty ( $ data [ 1 ] ) ? [ ] : array_values ( $ data ) ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
4569	protected function cast ( $ element ) { if ( $ element instanceof Permission ) { return $ element ; } if ( ! is_array ( $ element ) ) { throw new InvalidArgumentException ( 'Element is not an array.' ) ; } foreach ( [ 'attributes' , 'type' , 'value' , 'title' ] as $ key ) { if ( ! array_key_exists ( $ key , $ element ) ) { throw new InvalidArgumentException ( 'Element is missing key "' . $ key . '".' ) ; } } $ permission = new Permission ( $ element [ 'key' ] , $ element [ 'attributes' ] , $ element [ 'type' ] , $ element [ 'value' ] , $ element [ 'title' ] ) ; return $ permission ; }
12418	static function run_php_loc_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phploc = self :: getTool ( 'phploc' , $ opts , true ) ; $ out = pake_sh ( "$phploc -n " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phploc.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
6704	public function baseURL ( $ httpverb , $ url , $ params ) { uksort ( $ params , 'strcmp' ) ; return strtoupper ( $ httpverb ) . '&' . rawurlencode ( $ url ) . '&' . rawurlencode ( http_build_query ( $ params ) ) ; }
9217	protected function parsePageLinks ( $ headers = false ) { $ pagination = [ ] ; if ( ! $ headers ) { $ headers = $ this -> api -> lastHeader ( 'link' ) ; } if ( preg_match_all ( '%<([^>]*)>\s*;\s*rel="([^"]+)"%' , $ headers , $ links , PREG_SET_ORDER ) ) { foreach ( $ links as $ link ) { $ pagination [ $ link [ 2 ] ] = new CanvasPageLink ( $ link [ 1 ] , $ link [ 2 ] ) ; } } return $ pagination ; }
12908	public function update ( FilterRequest $ request , $ id ) { $ this -> fieldManager = $ this -> getFieldManager ( ) ; $ this -> validate ( $ request -> request , $ this -> fieldManager -> update ( ) ) ; $ id = $ this -> getRealId ( $ id ) ; $ resource = $ this -> repository -> update ( $ request -> all ( ) , $ id ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
6754	private static function createFolderIfNotExists ( string $ path ) { if ( false === @ mkdir ( $ path , 0777 , true ) && ! is_dir ( $ path ) ) { throw new \ RuntimeException ( sprintf ( "Unable to create the %s directory\n" , $ path ) ) ; } }
7617	public function api_request ( $ path , $ options ) { $ data = $ this -> requestHandler -> request ( $ path , $ options ) ; return json_encode ( $ data -> json ) ; }
5233	public function handleException ( \ Exception $ exception ) { if ( $ this -> loggingEnabled ) { $ this -> exceptionLogger -> log ( $ exception ) ; } if ( 'cgi' === $ this -> sapi ) { $ this -> header ( 'Status: 500 Internal Server Error' ) ; } else { $ this -> header ( 'HTTP/1.1 500 Internal Server Error' ) ; } $ this -> writeBody ( $ this -> createResponseBody ( $ exception ) ) ; }
9490	protected function getFileDataValue ( $ obFile ) { if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } $ sUploadFolder = Config :: get ( 'cms.storage.uploads.path' , '/storage/app/uploads' ) ; return [ 'full_path' => $ obFile -> getPath ( ) , 'path' => $ sUploadFolder . str_replace ( 'uploads' , '' , $ obFile -> getDiskPath ( ) ) , 'title' => $ obFile -> getAttribute ( 'title' ) , 'alt' => $ obFile -> getAttribute ( 'description' ) , ] ; }
1034	private function completeListValue ( ListOfType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ itemType = $ returnType -> getWrappedType ( ) ; Utils :: invariant ( is_array ( $ result ) || $ result instanceof Traversable , 'User Error: expected iterable, but did not find one for field ' . $ info -> parentType . '.' . $ info -> fieldName . '.' ) ; $ containsPromise = false ; $ i = 0 ; $ completedItems = [ ] ; foreach ( $ result as $ item ) { $ fieldPath = $ path ; $ fieldPath [ ] = $ i ++ ; $ completedItem = $ this -> completeValueCatchingError ( $ itemType , $ fieldNodes , $ info , $ fieldPath , $ item ) ; if ( ! $ containsPromise && $ this -> getPromise ( $ completedItem ) ) { $ containsPromise = true ; } $ completedItems [ ] = $ completedItem ; } return $ containsPromise ? $ this -> exeContext -> promises -> all ( $ completedItems ) : $ completedItems ; }
9347	public function isDiagonal ( ) { $ int_size = min ( ( array ) $ this -> size ) ; if ( $ int_size > 0 ) { for ( $ i = 0 ; $ i < $ int_size ; $ i ++ ) { $ arr_row = $ this -> getRow ( $ i ) ; if ( $ arr_row [ $ i ] != 0 ) { unset ( $ arr_row [ $ i ] ) ; foreach ( $ arr_row as $ v ) { if ( $ v != 0 ) { return false ; } } } else { return false ; } } return true ; } return false ; }
5271	private function translateDelete ( ) { $ build = array ( "delete from {$this->table}" ) ; if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
1597	protected function validateRelationships ( ) : bool { if ( ! $ this -> dataHas ( 'relationships' ) ) { return true ; } $ relationships = $ this -> dataGet ( 'relationships' ) ; if ( ! is_object ( $ relationships ) ) { $ this -> memberNotObject ( '/data' , 'relationships' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ relationships ) { return property_exists ( $ relationships , $ field ) ; } ) ; $ valid = $ disallowed -> isEmpty ( ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'relationships' , $ disallowed ) ; foreach ( $ relationships as $ field => $ relation ) { if ( ! $ this -> validateRelationship ( $ relation , $ field ) ) { $ valid = false ; } } return $ valid ; }
11960	public function reduce ( Closure $ fn , $ initial = null ) { return array_reduce ( $ this -> elements , $ fn , $ initial ) ; }
10251	public function getFirstName ( $ gender = null ) { if ( empty ( $ gender ) ) { $ gender = $ this -> getGender ( ) ; } return FirstName :: where ( 'gender' , $ gender ) -> where ( 'rank' , '<=' , 250 ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; }
7382	public static function toInsert ( $ input , array $ include = [ ] ) { if ( is_object ( $ input ) ) { if ( method_exists ( $ input , 'toArray' ) ) { $ input = $ input -> toArray ( ) ; } elseif ( $ input instanceof \ Traversable ) { $ input = iterator_to_array ( $ input ) ; } else { $ input = ( array ) $ input ; } } elseif ( ! is_array ( $ input ) ) { throw new InvalidArgumentException ( 'input must be an associative array or traversable object' ) ; } if ( count ( $ include ) ) { $ arr = [ ] ; foreach ( $ include as $ i ) { if ( isset ( $ input [ $ i ] ) ) { $ arr [ $ i ] &= $ input [ $ i ] ; } } } else { $ arr = & $ input ; } $ sqlStrs = [ ] ; foreach ( $ arr as $ k => & $ v ) { $ kEq = '`' . $ k . '` = ' ; switch ( gettype ( $ v ) ) { case 'bool' : case 'boolean' : $ sqlStrs [ ] = $ kEq . ( $ v ? '1' : '0' ) ; break ; case 'int' : case 'integer' : case 'float' : case 'double' : $ sqlStrs [ ] = $ kEq . $ v ; break ; case 'string' : if ( $ v === 'NULL' ) { $ sqlStrs [ ] = $ kEq . 'NULL' ; } else { $ sqlStrs [ ] = $ kEq . '"' . addslashes ( $ v ) . '"' ; } break ; case 'null' : case 'NULL' : $ sqlStrs [ ] = $ kEq . 'NULL' ; break ; case 'object' : if ( $ v instanceof DateTime ) { $ sqlStrs [ ] = $ kEq . '"' . $ v . '"' ; break ; } case 'array' : $ sqlStrs [ ] = $ kEq . '"' . addslashes ( json_encode ( $ v ) ) . '"' ; $ jsonLastErr = json_last_error ( ) ; if ( $ jsonLastErr !== JSON_ERROR_NONE ) { throw new UnexpectedValueException ( json_last_error_msg ( ) , $ jsonLastErr ) ; } break ; default : break ; } } return implode ( ",\n" , $ sqlStrs ) ; }
4123	public function generateProxyClasses ( array $ classes , $ toDir = null ) { $ proxyDir = $ toDir ? : $ this -> proxyDir ; $ proxyDir = rtrim ( $ proxyDir , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; foreach ( $ classes as $ class ) { if ( $ class -> isMappedSuperclass ) { continue ; } $ proxyFileName = $ this -> getProxyFileName ( $ class -> name , $ toDir ) ; $ this -> generateProxyClass ( $ class , $ proxyFileName , self :: $ proxyClassTemplate ) ; } }
3341	public function getFileList ( $ options = array ( ) ) { $ options = array_replace ( array ( 'from' => null , 'to' => null , 'limit' => null , 'request_limit' => null , 'stored' => $ this -> defaultFilters [ 'file' ] [ 'stored' ] , 'removed' => $ this -> defaultFilters [ 'file' ] [ 'removed' ] , 'reversed' => false , ) , $ options ) ; if ( ! empty ( $ options [ 'from' ] ) && ! empty ( $ options [ 'to' ] ) ) { throw new \ Exception ( 'Only one of "from" and "to" arguments is allowed' ) ; } $ options [ 'from' ] = self :: dateTimeString ( $ options [ 'from' ] ) ; $ options [ 'to' ] = self :: dateTimeString ( $ options [ 'to' ] ) ; foreach ( $ this -> defaultFilters [ 'file' ] as $ k => $ v ) { if ( ! is_null ( $ options [ $ k ] ) ) { $ options [ $ k ] = self :: booleanString ( $ options [ $ k ] ) ; } } return new FileIterator ( $ this , $ options ) ; }
11786	public function delete ( $ pageId ) { $ params = [ 'page_id' => intval ( $ pageId ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE , $ params ] ) ; }
1410	public function resourceTypeNotRecognised ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'resource_type_not_recognised' , 'code' ) , $ this -> trans ( 'resource_type_not_recognised' , 'title' ) , $ this -> trans ( 'resource_type_not_recognised' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'type' ) ) ; }
5910	public function createSetting ( $ key , $ value ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'key' => $ key , 'value' => $ value ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/settings' , $ parameters ) ; return $ result ; }
2283	protected static function url ( ) { $ host = static :: get ( 'httpHost' ) ; $ xhost = static :: get ( 'httpXForwardedHost' ) ; if ( $ xhost != '' && $ xhost == Config :: get ( 'sslProxyDomain' ) ) { return 'https://' . $ xhost . '/' . $ host ; } return ( static :: get ( 'ssl' ) ? 'https://' : 'http://' ) . $ host ; }
10013	public function getSheetByName ( $ pName ) { $ worksheetCount = count ( $ this -> workSheetCollection ) ; for ( $ i = 0 ; $ i < $ worksheetCount ; ++ $ i ) { if ( $ this -> workSheetCollection [ $ i ] -> getTitle ( ) === $ pName ) { return $ this -> workSheetCollection [ $ i ] ; } } return null ; }
7713	function FindEndTag ( $ Encaps = false ) { if ( is_null ( $ this -> SelfClosing ) ) { $ pe = $ this -> PosEnd ; $ SelfClosing = ( substr ( $ this -> Txt , $ pe - 1 , 1 ) == '/' ) ; if ( ! $ SelfClosing ) { if ( $ Encaps ) { $ loc = clsTinyButStrong :: f_Xml_FindTag ( $ this -> Txt , $ this -> FindName ( ) , null , $ pe , true , - 1 , false , false ) ; if ( $ loc === false ) return false ; $ this -> pET_PosBeg = $ loc -> PosBeg ; $ this -> PosEnd = $ loc -> PosEnd ; } else { $ pe = clsTinyButStrong :: f_Xml_FindTagStart ( $ this -> Txt , $ this -> FindName ( ) , false , $ pe , true , true ) ; if ( $ pe === false ) return false ; $ this -> pET_PosBeg = $ pe ; $ pe = strpos ( $ this -> Txt , '>' , $ pe ) ; if ( $ pe === false ) return false ; $ this -> PosEnd = $ pe ; } } $ this -> SelfClosing = $ SelfClosing ; } return true ; }
7290	static public function isValidMode ( $ mode , $ throw = true ) { if ( in_array ( $ mode , static :: getModes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( 'Invalid adjustment mode.' ) ; } return false ; }
4913	public function add ( $ name , $ entities = null , array $ options = null ) { if ( $ name instanceof DependencyResult ) { return $ this -> addResult ( $ name ) ; } if ( $ name instanceof \ Traversable ) { return $ this -> addTraversable ( $ name ) ; } if ( is_array ( $ name ) ) { return $ this -> addArray ( $ name ) ; } if ( null === $ entities ) { throw new \ UnexpectedValueException ( '$entities must not be null.' ) ; } return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ entities , 'options' => $ options , ] ) ; }
6019	public function removeSite ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/deployment/' . $ id . '' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
2337	private function setLegacyOptions ( Table $ table ) : void { if ( ! $ table -> hasOption ( 'engine' ) ) { $ table -> addOption ( 'engine' , 'MyISAM' ) ; } if ( ! $ table -> hasOption ( 'charset' ) ) { $ table -> addOption ( 'charset' , 'utf8' ) ; } if ( ! $ table -> hasOption ( 'collate' ) ) { $ table -> addOption ( 'collate' , 'utf8_general_ci' ) ; } }
10167	private function readBIFF8CellRangeAddressB ( $ subData , $ baseCell = 'A1' ) { list ( $ baseCol , $ baseRow ) = Coordinate :: coordinateFromString ( $ baseCell ) ; $ baseCol = Coordinate :: columnIndexFromString ( $ baseCol ) - 1 ; $ frIndex = self :: getUInt2d ( $ subData , 0 ) ; $ lrIndex = self :: getUInt2d ( $ subData , 2 ) ; if ( ! ( 0x4000 & self :: getUInt2d ( $ subData , 4 ) ) ) { $ fcIndex = 0x00FF & self :: getUInt2d ( $ subData , 4 ) ; $ fc = Coordinate :: stringFromColumnIndex ( $ fcIndex + 1 ) ; $ fc = '$' . $ fc ; } else { $ relativeFcIndex = 0x00FF & self :: getInt2d ( $ subData , 4 ) ; $ fcIndex = $ baseCol + $ relativeFcIndex ; $ fcIndex = ( $ fcIndex < 256 ) ? $ fcIndex : $ fcIndex - 256 ; $ fcIndex = ( $ fcIndex >= 0 ) ? $ fcIndex : $ fcIndex + 256 ; $ fc = Coordinate :: stringFromColumnIndex ( $ fcIndex + 1 ) ; } if ( ! ( 0x8000 & self :: getUInt2d ( $ subData , 4 ) ) ) { $ fr = $ frIndex + 1 ; $ fr = '$' . $ fr ; } else { $ frIndex = ( $ frIndex <= 32767 ) ? $ frIndex : $ frIndex - 65536 ; $ fr = $ baseRow + $ frIndex ; } if ( ! ( 0x4000 & self :: getUInt2d ( $ subData , 6 ) ) ) { $ lcIndex = 0x00FF & self :: getUInt2d ( $ subData , 6 ) ; $ lc = Coordinate :: stringFromColumnIndex ( $ lcIndex + 1 ) ; $ lc = '$' . $ lc ; } else { $ relativeLcIndex = 0x00FF & self :: getInt2d ( $ subData , 4 ) ; $ lcIndex = $ baseCol + $ relativeLcIndex ; $ lcIndex = ( $ lcIndex < 256 ) ? $ lcIndex : $ lcIndex - 256 ; $ lcIndex = ( $ lcIndex >= 0 ) ? $ lcIndex : $ lcIndex + 256 ; $ lc = Coordinate :: stringFromColumnIndex ( $ lcIndex + 1 ) ; } if ( ! ( 0x8000 & self :: getUInt2d ( $ subData , 6 ) ) ) { $ lr = $ lrIndex + 1 ; $ lr = '$' . $ lr ; } else { $ lrIndex = ( $ lrIndex <= 32767 ) ? $ lrIndex : $ lrIndex - 65536 ; $ lr = $ baseRow + $ lrIndex ; } return "$fc$fr:$lc$lr" ; }
959	public function cancel ( ) { if ( ! $ this -> isType ( self :: CHARGE_ONETIME ) && ! $ this -> isType ( self :: CHARGE_RECURRING ) ) { throw new Exception ( 'Cancel may only be called for single and recurring charges.' ) ; } $ this -> status = self :: STATUS_CANCELLED ; $ this -> cancelled_on = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; return $ this -> save ( ) ; }
1381	protected function validateToMany ( array $ value , ? string $ field = null ) : bool { $ path = $ field ? "/data/relationships/{$field}/data" : "/data" ; $ valid = true ; foreach ( $ value as $ index => $ item ) { if ( ! $ this -> validateIdentifier ( $ item , $ path , $ index ) ) { $ valid = false ; continue ; } if ( $ this -> isNotFound ( $ item -> type , $ item -> id ) ) { $ this -> resourceDoesNotExist ( "{$path}/{$index}" ) ; $ valid = false ; } } return $ valid ; }
4578	public function start ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_START ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_START_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_START_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' , 'Content-Type' => 'application/json' ] ] ; if ( $ parameters ) { $ parameters = ( array ) $ parameters -> toObject ( true ) ; foreach ( $ parameters as $ name => $ value ) { switch ( $ name ) { case 'variables' : foreach ( $ value as $ variable ) { $ options [ 'json' ] [ $ name ] [ $ variable -> name ] = [ 'value' => Variable :: TYPE_JSON === $ variable -> type ? json_encode ( $ variable -> value ) : $ variable -> value , 'type' => $ variable -> type ] ; } break ; case 'key' : break ; default : $ options [ 'json' ] [ $ name ] = $ value ; } } } $ object = $ this -> execute ( 'POST' , $ resource , $ options ) ; $ model = ProcessInstanceService :: toModel ( $ object ) ; return $ model ; }
10660	public function withHeaders ( array $ headers ) { $ object = clone $ this ; $ object -> configs [ 'headers' ] = [ ] ; $ object -> inProcessingLoop = true ; $ object -> replaceHeaders ( $ headers ) ; $ object -> inProcessingLoop = true ; return $ object -> buildConfigClient ( ) ; }
9093	public function getPagePartial ( $ page ) { if ( isset ( $ this -> pagePartials [ $ page ] ) ) { return $ this -> pagePartials [ $ page ] ; } return null ; }
6302	protected function getBar ( $ name = 'default' ) { $ this -> events -> fire ( 'navigation.bar' , [ [ 'name' => $ name ] ] ) ; if ( $ name !== 'default' && ! array_key_exists ( $ name , $ this -> bar ) ) { $ name = 'default' ; } if ( ! array_key_exists ( $ name , $ this -> bar ) ) { $ this -> bar [ $ name ] = [ ] ; } $ nav = $ this -> bar [ $ name ] ; return $ this -> process ( $ nav ) ; }
12585	static function run_convert_configuration ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ extname = @ $ args [ 0 ] ; if ( $ extname == '' ) { $ extname = dirname ( __FILE__ ) ; } while ( ! is_file ( "ant/$extname.properties" ) ) { $ extname = pake_input ( 'What is the name of the current extension?' ) ; if ( ! is_file ( "ant/$extname.properties" ) ) { pake_echo ( "File ant/$extname.properties not found" ) ; } } self :: convertPropertyFileToYamlFile ( "ant/$extname.properties" , self :: getConfigDir ( ) . "/options-$extname.yaml" , array ( $ extname => '' , 'external' => 'dependencies' , 'dependency' => 'extensions' , 'repository' => array ( 'svn' , 'url' ) ) , "extension:\n name: $extname\n\n" ) ; foreach ( array ( 'files.to.parse.txt' => 'to_parse' , 'files.to.exclude.txt' => 'to_exclude' ) as $ file => $ option ) { $ src = "ant/$file" ; if ( file_exists ( $ src ) ) { if ( count ( $ in = file ( $ src , FILE_SKIP_EMPTY_LINES | FILE_IGNORE_NEW_LINES ) ) ) { $ in = "\n\nfiles:\n $option: [" . implode ( ', ' , $ in ) . "]\n" ; file_put_contents ( self :: getConfigDir ( ) . "options-$extname.yaml" , $ in , FILE_APPEND ) ; } } } }
79	public function createRepository ( $ type , $ config , $ name = null ) { if ( ! isset ( $ this -> repositoryClasses [ $ type ] ) ) { throw new \ InvalidArgumentException ( 'Repository type is not registered: ' . $ type ) ; } if ( isset ( $ config [ 'packagist' ] ) && false === $ config [ 'packagist' ] ) { $ this -> io -> writeError ( '<warning>Repository "' . $ name . '" (' . json_encode ( $ config ) . ') has a packagist key which should be in its own repository definition</warning>' ) ; } $ class = $ this -> repositoryClasses [ $ type ] ; $ reflMethod = new \ ReflectionMethod ( $ class , '__construct' ) ; $ params = $ reflMethod -> getParameters ( ) ; if ( isset ( $ params [ 4 ] ) && $ params [ 4 ] -> getClass ( ) && $ params [ 4 ] -> getClass ( ) -> getName ( ) === 'Composer\Util\RemoteFilesystem' ) { return new $ class ( $ config , $ this -> io , $ this -> config , $ this -> eventDispatcher , $ this -> rfs ) ; } return new $ class ( $ config , $ this -> io , $ this -> config , $ this -> eventDispatcher ) ; }
11452	public function getActions ( ) { $ actions = [ ] ; if ( is_array ( $ this -> actions ) ) { foreach ( $ this -> actions as $ action ) { $ actions [ $ action ] = $ action ; } } return $ actions ; }
10152	private function readHcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isHorizontalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setHorizontalCentered ( $ isHorizontalCentered ) ; } }
4607	public function statuses ( int $ account_id , int $ limit = 40 , int $ since_id = null ) : array { $ url = "/accounts/${account_id}/statuses" ; $ query = [ 'limit' => $ limit , 'since_id' => $ since_id , ] ; return $ this -> get ( $ url , $ query ) ; }
12830	public function compileSource ( $ source ) { $ source = $ this -> stripComments ( $ source ) ; $ source = $ this -> saveLiterals ( $ source ) ; $ result = preg_replace_callback ( '#' . $ this -> _config [ 'tokenStart' ] . '(.*)' . $ this -> _config [ 'tokenEnd' ] . '#smU' , array ( $ this , 'onTokenFound' ) , $ source ) ; $ result = $ this -> restoreLiterals ( $ result ) ; return $ result ; }
10429	private function initSyncStorageForMysql ( ContainerBuilder $ container , array $ config ) { $ doctrineConnection = sprintf ( 'doctrine.dbal.%s_connection' , $ config [ 'connection' ] ) ; $ definition = $ container -> getDefinition ( 'ongr_connections.sync.storage_manager.mysql_storage_manager' ) ; $ definition -> setArguments ( [ new Reference ( $ doctrineConnection , ContainerInterface :: IGNORE_ON_INVALID_REFERENCE ) , $ config [ 'table_name' ] , ] ) ; $ definition -> addMethodCall ( 'setContainer' , [ new Reference ( 'service_container' ) ] ) ; $ container -> getDefinition ( 'ongr_connections.sync.sync_storage' ) -> setArguments ( [ $ definition ] ) ; }
8910	private function getCallableFunction ( $ method ) { if ( is_callable ( $ method ) ) { return $ method ; } if ( is_string ( $ method ) && is_callable ( array ( $ this , $ method ) ) ) { return array ( $ this , $ method ) ; } return FALSE ; }
9797	public function getHyperlink ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot get hyperlink for cell that is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> getHyperlink ( $ this -> getCoordinate ( ) ) ; }
881	private function fixTypes ( Annotation $ annotation ) { $ types = $ annotation -> getTypes ( ) ; $ new = $ this -> normalizeTypes ( $ types ) ; if ( $ types !== $ new ) { $ annotation -> setTypes ( $ new ) ; } }
9103	protected function parse_message ( ) { if ( empty ( $ this -> args [ 'message' ] ) ) { return null ; } $ like = esc_sql ( $ this -> args [ 'message' ] ) ; return new Where ( 'message' , 'LIKE' , "%{$like}%" ) ; }
8206	protected function buryJob ( $ job , $ priority = null ) { if ( is_null ( $ priority ) ) { $ priority = Pheanstalk :: DEFAULT_PRIORITY ; } $ this -> getPheanstalk ( ) -> bury ( $ job , $ priority ) ; }
12090	public function then ( callable $ success = null , callable $ fail = null ) { if ( $ this -> success && is_callable ( $ success ) ) { return $ success ( $ this -> request , $ this -> request -> getStatusCode ( ) ) ; } elseif ( is_callable ( $ fail ) ) { return $ fail ( $ this -> error ) ; } }
9877	private function writeFileVersion ( XMLWriter $ objWriter ) { $ objWriter -> startElement ( 'fileVersion' ) ; $ objWriter -> writeAttribute ( 'appName' , 'xl' ) ; $ objWriter -> writeAttribute ( 'lastEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'lowestEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'rupBuild' , '4505' ) ; $ objWriter -> endElement ( ) ; }
9655	public function override ( $ name , array $ routeData ) { if ( ! isset ( $ this -> routes [ $ name ] ) ) { throw new \ InvalidArgumentException ( "No route for name $name defined" ) ; } $ this -> routes [ $ name ] = $ routeData + $ this -> routes [ $ name ] ; }
746	protected function buildDefaultString ( ) { if ( $ this -> default === null ) { return $ this -> isNotNull === false ? ' DEFAULT NULL' : '' ; } $ string = ' DEFAULT ' ; switch ( gettype ( $ this -> default ) ) { case 'integer' : $ string .= ( string ) $ this -> default ; break ; case 'double' : $ string .= StringHelper :: floatToString ( $ this -> default ) ; break ; case 'boolean' : $ string .= $ this -> default ? 'TRUE' : 'FALSE' ; break ; case 'object' : $ string .= ( string ) $ this -> default ; break ; default : $ string .= "'{$this->default}'" ; } return $ string ; }
9537	private function getPrefix ( $ parameter ) { $ prefix = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ _prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ _prefix ) ) == $ _prefix ) { $ prefix = $ _prefix ; } } return $ prefix ; }
2041	public static function symlink ( string $ target , string $ link , string $ rootDir ) : void { static :: validateSymlink ( $ target , $ link , $ rootDir ) ; $ fs = new Filesystem ( ) ; if ( ! $ fs -> isAbsolutePath ( $ target ) ) { $ target = $ rootDir . '/' . $ target ; } if ( ! $ fs -> isAbsolutePath ( $ link ) ) { $ link = $ rootDir . '/' . $ link ; } if ( '\\' === \ DIRECTORY_SEPARATOR ) { $ fs -> symlink ( $ target , $ link ) ; } else { $ fs -> symlink ( rtrim ( $ fs -> makePathRelative ( $ target , \ dirname ( $ link ) ) , '/' ) , $ link ) ; } }
8761	public function writeLogLine ( Tick $ tick ) { $ lineSegs = array ( ) ; switch ( $ tick -> getStatus ( ) ) { case Tick :: SUCCESS : $ lineSegs [ ] = sprintf ( "<fg=green>%s</fg=green>" , $ this -> linePrefixMap [ Tick :: SUCCESS ] ) ; break ; case Tick :: FAIL : $ lineSegs [ ] = sprintf ( "<fg=red>%s</fg=red>" , $ this -> linePrefixMap [ Tick :: FAIL ] ) ; break ; case Tick :: SKIP : default : $ lineSegs [ ] = $ this -> linePrefixMap [ Tick :: SKIP ] ; } $ lineSegs [ ] = sprintf ( "[%s%s]" , $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , $ tick -> getReport ( ) -> getTotalItemCount ( ) != Tracker :: UNKNOWN ? "/" . $ tick -> getReport ( ) -> getTotalItemCount ( ) : '' ) ; if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERBOSE ) { $ lineSegs [ ] = $ this -> formatSeconds ( $ tick -> getReport ( ) -> getTimeElapsed ( ) ) ; $ lineSegs [ ] = sprintf ( '(<fg=green>%s</fg=green>/%s/<fg=red>%s</fg=red>)' , $ tick -> getReport ( ) -> getNumItemsSuccess ( ) , $ tick -> getReport ( ) -> getNumItemsSkip ( ) , $ tick -> getReport ( ) -> getNumItemsFail ( ) ) ; } if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERY_VERBOSE ) { $ lineSegs [ ] = sprintf ( "{%s/%s}" , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemUsage ( ) ) , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemPeakUsage ( ) ) ) ; } $ lineSegs [ ] = $ tick -> getMessage ( ) ? : sprintf ( "Processing item %s" , number_format ( $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , 0 ) ) ; $ this -> output -> writeln ( implode ( ' ' , $ lineSegs ) ) ; }
10444	protected function handleStatement ( $ line , $ type ) { if ( ! preg_match ( "/^{$type}$/" , $ line ) ) { throw new \ UnexpectedValueException ( "Expected a {$type} statement, got {$line}" ) ; } $ params = [ ] ; $ param = $ this -> handleParam ( ) ; while ( $ param !== null ) { $ params = $ params + $ param ; $ param = $ this -> handleParam ( ) ; } return $ params ; }
3212	static function loadFromJsonFileWithRaw ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new AppInfoLoadException ( "File doesn't exist: \"$path\"" ) ; } $ str = Util :: stripUtf8Bom ( file_get_contents ( $ path ) ) ; $ jsonArr = json_decode ( $ str , true , 10 ) ; if ( is_null ( $ jsonArr ) ) { throw new AppInfoLoadException ( "JSON parse error: \"$path\"" ) ; } $ appInfo = self :: loadFromJson ( $ jsonArr ) ; return array ( $ jsonArr , $ appInfo ) ; }
5464	public function isWithin ( $ url ) { if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) ) ) { return true ; } if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) . $ url -> getPage ( ) . '/' ) ) { return true ; } return false ; }
8308	public function assertArrayOfStrings ( $ config , $ key ) { if ( ! array_key_exists ( $ key , $ config ) ) { return $ this ; } if ( ! is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " section must be an array." ) ; } foreach ( $ config [ $ key ] as $ value ) { if ( ! is_string ( $ value ) ) { throw new ConfigurationException ( "Values in the `{$key}` must be strings" . gettype ( $ value ) . " found." ) ; } elseif ( $ value === "" ) { throw new ConfigurationException ( "Empty string not allowed in `{$key}` array." ) ; } } return $ this ; }
4288	public function onError ( Event $ event ) { if ( $ event [ 'inConsole' ] || ! $ event [ 'isFirstOccur' ] ) { return ; } $ this -> processLogEntry ( 'errorNotConsoled' , array ( $ event [ 'typeStr' ] . ': ' . $ event [ 'file' ] . ' (line ' . $ event [ 'line' ] . '): ' . $ event [ 'message' ] ) , array ( 'channel' => 'phpError' , 'class' => $ event [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ? 'danger' : 'warning' , ) ) ; }
797	public function getArrayEnd ( $ index ) { $ level = 1 ; for ( ++ $ index , $ max = \ count ( $ this ) ; $ index < $ max ; ++ $ index ) { if ( $ this [ $ index ] -> isType ( DocLexer :: T_OPEN_CURLY_BRACES ) ) { ++ $ level ; } elseif ( $ this [ $ index ] -> isType ( $ index , DocLexer :: T_CLOSE_CURLY_BRACES ) ) { -- $ level ; } if ( 0 === $ level ) { return $ index ; } } return null ; }
6649	public function uploadFile ( $ event ) { if ( ! array_key_exists ( $ this -> attribute , $ event -> sender -> attributes ) ) { throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Attribute {attribute} not found in model {model}' , [ 'attribute' => $ this -> attribute , 'model' => $ event -> sender -> className ( ) ] ) ) ; } $ oldFile = false ; if ( isset ( $ event -> sender -> oldAttributes [ $ this -> attribute ] ) ) { $ oldFile = $ event -> sender -> oldAttributes [ $ this -> attribute ] ; } $ uploadedFile = UploadedFile :: getInstance ( $ event -> sender , $ this -> attribute ) ; if ( null !== $ uploadedFile && $ uploadedFile -> size !== 0 ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ oldFile ) { $ this -> unlinkFiles ( $ oldFile ) ; } $ baseName = $ uploadedFile -> baseName ; $ fileName = $ baseName . '.' . $ uploadedFile -> extension ; while ( @ file_exists ( $ folder . '/' . $ fileName ) ) { $ baseName .= '_' ; $ fileName = $ baseName . '.' . $ uploadedFile -> extension ; } FileHelper :: createDirectory ( $ folder , 0777 ) ; $ uploadedFile -> saveAs ( $ folder . '/' . $ fileName ) ; $ event -> sender -> { $ this -> attribute } = $ fileName ; } else { if ( Yii :: $ app -> request -> post ( $ this -> attribute . '_file_delete' ) ) { $ this -> unlinkFiles ( $ oldFile ) ; $ event -> sender -> { $ this -> attribute } = null ; } else { $ event -> sender -> { $ this -> attribute } = $ oldFile ; } } }
1591	protected function validateData ( ) : bool { if ( ! property_exists ( $ this -> document , 'data' ) ) { $ this -> memberRequired ( '/' , 'data' ) ; return false ; } $ data = $ this -> document -> data ; if ( ! is_object ( $ data ) ) { $ this -> memberNotObject ( '/' , 'data' ) ; return false ; } return true ; }
5142	public function process ( ServerRequestInterface $ request ) : ResponseInterface { $ filteredMiddleware = $ this -> middleware ; try { $ request = $ this -> router -> dispatch ( $ request ) ; $ route = $ request -> getAttribute ( 'route' ) ; $ filteredMiddleware = array_filter ( $ filteredMiddleware , function ( Middleware $ middleware ) use ( $ route ) { return $ middleware -> executeFor ( $ route ) ; } ) ; $ requestHandler = $ route -> getHandler ( ) ; } catch ( HttpException $ e ) { $ requestHandler = new NextHandler ( function ( ) use ( $ e ) { throw $ e ; } ) ; } $ filteredMiddleware = array_map ( function ( Middleware $ middleware ) { return $ middleware -> getMiddleware ( ) ; } , $ filteredMiddleware ) ; $ dispatcher = new Stack ( $ filteredMiddleware , $ requestHandler ) ; return $ dispatcher -> dispatch ( $ request ) ; }
3527	private function fetch ( ) { $ data = FortniteClient :: sendFortnitePostRequest ( FortniteClient :: FORTNITE_API . 'game/v2/profile/' . $ this -> account_id . '/client/QueryProfile?profileId=athena&rvn=-1' , $ this -> access_token , new \ StdClass ( ) ) ; return $ data -> profileChanges [ 0 ] -> profile ; }
3530	public static function sendUnrealClientPostRequest ( $ endpoint , $ params = null , $ authorization = self :: EPIC_LAUNCHER_AUTHORIZATION , $ oauth = false ) { $ client = new Client ( [ 'http_errors' => false ] ) ; try { $ response = $ client -> post ( $ endpoint , [ 'form_params' => $ params , 'headers' => [ 'User-Agent' => self :: UNREAL_CLIENT_USER_AGENT , 'Authorization' => ( ! $ oauth ) ? 'basic ' . $ authorization : 'bearer ' . $ authorization , 'X-Epic-Device-ID' => self :: generateDeviceId ( ) ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
12340	protected function print ( string $ msg , bool $ withTime = true ) : void { $ preMsg = '' ; if ( $ withTime ) { $ preMsg = ( new \ DateTime ( 'now' ) ) -> format ( 'H:i:s' ) . "\t" ; } echo "{$preMsg}{$msg}" . \ PHP_EOL ; }
3063	protected function saveAdaptiveResults ( CatSession $ catSession ) { $ testResult = $ catSession -> getTestResult ( ) ; $ testResult = empty ( $ testResult ) ? [ ] : [ $ testResult ] ; return $ this -> storeResult ( array_merge ( $ testResult , $ catSession -> getItemResults ( ) ) ) ; }
5449	public function acceptEndToken ( $ token , $ event ) { if ( ! preg_match ( '/<\/(.*)>/' , $ token , $ matches ) ) { return false ; } return $ this -> listener -> endElement ( strtolower ( $ matches [ 1 ] ) ) ; }
3684	protected function buildNativeSqlProcedure ( FilterBuilderSql $ procedure , $ children ) { $ skipped = array ( ) ; $ metaModel = $ this -> getMetaModel ( ) ; $ tableName = $ metaModel -> getTableName ( ) ; foreach ( $ children as $ child ) { if ( isset ( $ child [ 'property' ] ) && $ metaModel -> hasAttribute ( $ child [ 'property' ] ) ) { $ skipped [ ] = $ child ; continue ; } if ( ( 'AND' === $ child [ 'operation' ] ) || ( 'OR' === $ child [ 'operation' ] ) ) { if ( null === $ child [ 'children' ] ) { continue ; } $ subProcedure = new FilterBuilderSql ( $ tableName , $ child [ 'operation' ] , $ this -> connection ) ; $ subSkipped = $ this -> buildNativeSqlProcedure ( $ subProcedure , $ child [ 'children' ] ) ; if ( count ( $ subSkipped ) !== count ( $ child [ 'children' ] ) ) { $ procedure -> addSubProcedure ( $ subProcedure ) ; } if ( ! empty ( $ subSkipped ) ) { $ skipped += $ subSkipped ; } continue ; } $ procedure -> addChild ( $ child ) ; } return $ skipped ; }
3616	public function setFanMode ( $ mode , $ serial_number = NULL ) { $ duty_cycle = NULL ; $ timer = NULL ; if ( is_array ( $ mode ) ) { $ modes = $ mode ; $ mode = $ modes [ 0 ] ; if ( count ( $ modes ) > 1 ) { if ( $ mode == FAN_MODE_MINUTES_PER_HOUR ) { $ duty_cycle = ( int ) $ modes [ 1 ] ; } else { $ timer = ( int ) $ modes [ 1 ] ; } } else { throw new Exception ( "setFanMode(array \$mode[, ...]) needs at least a mode and a value in the \$mode array." ) ; } } elseif ( ! is_string ( $ mode ) ) { throw new Exception ( "setFanMode() can only take a string or an array as it's first parameter." ) ; } return $ this -> _setFanMode ( $ mode , $ duty_cycle , $ timer , $ serial_number ) ; }
10623	public static function synchronizeMigrations ( CommandEvent $ event ) { $ packages = $ event -> getComposer ( ) -> getRepositoryManager ( ) -> getLocalRepository ( ) -> getPackages ( ) ; $ installer = $ event -> getComposer ( ) -> getInstallationManager ( ) ; $ appMigrationDir = self :: getDestinationDir ( $ event -> getComposer ( ) ) ; $ io = $ event -> getIO ( ) ; $ areFileMigrated = array ( ) ; $ areFileMigrated [ ] = self :: handlePackage ( '.' , $ event -> getComposer ( ) -> getPackage ( ) , $ io , $ appMigrationDir ) ; foreach ( $ packages as $ package ) { $ areFileMigrated [ ] = self :: handlePackage ( $ installer -> getInstallPath ( $ package ) , $ package , $ io , $ appMigrationDir ) ; } if ( in_array ( true , $ areFileMigrated ) ) { $ io -> write ( "<warning>Some migration files have been imported. " . "You should run `php app/console doctrine:migrations:status` and/or " . "`php app/console doctrine:migrations:migrate` to apply them to your DB." ) ; } }
1615	public function readSession ( $ id ) { $ data = $ this -> redis -> executeCommand ( 'GET' , [ $ this -> calculateKey ( $ id ) ] ) ; return $ data === false || $ data === null ? '' : $ data ; }
11940	public function getUrl ( string $ sCode , array $ aParams = array ( ) ) : string { if ( isset ( $ _SERVER ) && isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { foreach ( Config :: get ( 'route' ) as $ sHost => $ oHost ) { if ( ( ! strstr ( $ sHost , '/' ) && $ sHost == $ _SERVER [ 'HTTP_HOST' ] ) || ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) ) { if ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) { $ this -> _sBaseUri = preg_replace ( '#^[^/]+#' , '' , $ sHost ) ; } if ( isset ( $ oHost -> routes ) ) { foreach ( $ oHost -> routes as $ sKey => $ oRoute ) { if ( $ sKey === $ sCode ) { $ sRoute = $ this -> _sBaseUri . $ oRoute -> route ; if ( isset ( $ oRoute -> constraints ) ) { foreach ( $ oRoute -> constraints as $ sName => $ sType ) { if ( ! isset ( $ aParams [ $ sName ] ) ) { $ aParams [ $ sName ] = '' ; } if ( preg_match ( '#' . $ sType . '#' , $ aParams [ $ sName ] ) ) { if ( $ aParams [ $ sName ] ) { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '/' . $ aParams [ $ sName ] , $ sRoute ) ; } else { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '' , $ sRoute ) ; } $ sRoute = str_replace ( '[:' . $ sName . ']' , $ aParams [ $ sName ] , $ sRoute ) ; continue ; } else if ( isset ( $ oRoute -> defaults_constraints ) && isset ( $ oRoute -> defaults_constraints -> { $ sName } ) && preg_match ( '#' . $ sType . '#' , $ oRoute -> defaults_constraints -> { $ sName } ) ) { continue ; } throw new \ Exception ( 'For the route ' . $ sCode . ' the parameter ' . $ sName . ' is not good!' ) ; } } return $ sRoute ; } } } } } } }
1149	protected function setDefaults ( $ options ) { $ this -> selector = empty ( $ options [ 'selector' ] ) ? 'form' : $ options [ 'selector' ] ; $ this -> view = empty ( $ options [ 'view' ] ) ? 'jsvalidation::bootstrap' : $ options [ 'view' ] ; $ this -> remote = isset ( $ options [ 'remote' ] ) ? $ options [ 'remote' ] : true ; }
6239	public static function getExtensionFor ( string $ mimetype ) : ? string { $ extensions = static :: getExtensions ( ) ; if ( false !== $ match = array_search ( $ mimetype , $ extensions , true ) ) { return $ match ; } return null ; }
6659	protected function getEndpoints ( ) { if ( ! $ this -> endpointsCache ) { $ isHidden = $ this -> getControllerMethod ( 'isMethodHidden' ) ; $ endpoints = [ ] ; $ parts = [ ] ; $ methods = $ this -> reflectedController -> getMethods ( \ ReflectionMethod :: IS_PUBLIC ) ; foreach ( $ methods as $ method ) { if ( preg_match ( '/([a-z]+)([A-Z]\w+)Endpoint$/' , $ method -> getName ( ) , $ parts ) ) { if ( ! $ isHidden ( $ method -> getName ( ) ) ) { $ httpVerb = strtolower ( $ parts [ 1 ] ) ; $ endpoint = $ this -> camelcaseToHyphenated ( $ parts [ 2 ] ) ; if ( ! array_key_exists ( $ httpVerb , $ endpoints ) ) { $ endpoints [ $ httpVerb ] = array ( ) ; } $ endpoints [ $ httpVerb ] [ $ endpoint ] = $ this -> documentation -> getMethodDocumentation ( $ method ) ; } } } $ this -> endpointsCache = $ endpoints ; } return $ this -> endpointsCache ; }
7586	public function setDestinationPath ( $ destination = null ) { if ( empty ( $ destination ) ) { $ destination = sys_get_temp_dir ( ) . '/SugarAPI' ; } $ this -> destinationPath = $ destination ; return $ this ; }
8050	public function getCalendarEvent ( $ id ) { $ calendarEvent = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: CACHE_KEY . $ id ) ) { return $ cache :: get ( self :: CACHE_KEY . $ id ) ; } $ calendarEvent = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> where ( 'id' , $ id ) -> firstOrFail ( ) ; $ cache :: put ( self :: CACHE_KEY . $ id , $ calendarEvent , $ this -> cacheTimeToLive ) ; return $ calendarEvent ; }
730	public function run ( ) { if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id ) ; } $ model = new $ this -> modelClass ( [ 'scenario' => $ this -> scenario , ] ) ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> setStatusCode ( 201 ) ; $ id = implode ( ',' , array_values ( $ model -> getPrimaryKey ( true ) ) ) ; $ response -> getHeaders ( ) -> set ( 'Location' , Url :: toRoute ( [ $ this -> viewAction , 'id' => $ id ] , true ) ) ; } elseif ( ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to create the object for unknown reason.' ) ; } return $ model ; }
5996	public function setSavedSearch ( $ savedSearch ) { if ( $ savedSearch instanceof SavedSearch ) { $ this -> savedSearch = $ savedSearch ; } elseif ( is_array ( $ savedSearch ) ) { $ this -> savedSearch = new SavedSearch ( $ savedSearch ) ; } else { $ this -> savedSearch = null ; trigger_error ( 'Argument must be an object of class SavedSearch. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
11017	public function run ( ) { $ event = new BeforeControllerRunEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_BEFORE_CONTROLLER_RUN , $ event ) ; $ action = $ this -> action -> getName ( ) ; if ( $ this -> action -> hasParams ( ) ) { call_user_func_array ( [ $ this , $ action ] , $ this -> action -> getParams ( ) ) ; } else { $ this -> $ action ( ) ; } $ event = new AfterControllerRunEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_AFTER_CONTROLLER_RUN , $ event ) ; }
2920	public function deleteSetter ( $ key ) { $ pattern = "/^(export\h)?\h*{$key}=.*\n/m" ; $ this -> buffer = preg_replace ( $ pattern , null , $ this -> buffer ) ; return $ this ; }
11726	public function render ( $ filter = null ) : string { if ( empty ( $ this -> output ) ) { extract ( array_merge ( $ this -> vars , View :: $ global_vars ) , EXTR_REFS ) ; ob_start ( ) ; include ( $ this -> view_file ) ; $ this -> output = ob_get_clean ( ) ; } if ( $ filter !== null ) { $ this -> output = call_user_func ( $ filter , $ this -> output ) ; } return $ this -> output ; }
2245	public static function getPageStatusIcon ( $ objPage ) { $ sub = 0 ; $ image = $ objPage -> type . '.svg' ; if ( ! $ objPage -> published || ( $ objPage -> start != '' && $ objPage -> start > time ( ) ) || ( $ objPage -> stop != '' && $ objPage -> stop < time ( ) ) ) { ++ $ sub ; } if ( $ objPage -> hide && ! \ in_array ( $ objPage -> type , array ( 'root' , 'error_401' , 'error_403' , 'error_404' ) ) ) { $ sub += 2 ; } if ( $ objPage -> protected && ! \ in_array ( $ objPage -> type , array ( 'root' , 'error_401' , 'error_403' , 'error_404' ) ) ) { $ sub += 4 ; } if ( $ sub > 0 ) { $ image = $ objPage -> type . '_' . $ sub . '.svg' ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] as $ callback ) { $ image = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objPage , $ image ) ; } } return $ image ; }
12583	static function run_tool_version ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { pake_echo ( "eZ Extension Builder ver." . self :: VERSION . "\nRunning on pake " . pakeApp :: VERSION ) ; }
8554	public function setLoanServicingEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LoanServicingEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6107	public function clientPermList ( $ cldbid , $ permsid = false ) { return $ this -> getParent ( ) -> channelClientPermList ( $ this -> getId ( ) , $ cldbid , $ permsid ) ; }
7908	protected function renderDropdown ( ) { $ lines = [ ] ; $ lines [ ] = $ this -> encodeText ? Html :: encode ( $ this -> text ) : $ this -> text ; if ( $ this -> icon && is_string ( $ this -> icon ) ) { $ lines [ ] = $ this -> icon ; } $ lines [ ] = $ this -> renderItems ( $ this -> items , $ this -> options , $ this -> displaySearchInput ) ; return Html :: tag ( 'div' , implode ( "\n" , $ lines ) , $ this -> options ) ; }
4882	public function getPermissions ( ) { if ( ! $ this -> permissions ) { $ perms = new Permissions ( ) ; if ( $ this -> user instanceof UserInterface ) { $ perms -> grant ( $ this -> user , PermissionsInterface :: PERMISSION_ALL ) ; } $ this -> setPermissions ( $ perms ) ; } return $ this -> permissions ; }
3191	public function timeout ( $ timeLimit , $ tags , $ target ) { $ duration = $ this -> compute ( $ tags , $ target ) ; return $ duration >= $ timeLimit ; }
11198	public function delete ( $ name ) { $ name = $ this -> getName ( $ name ) ; $ resourceKey = $ name ; if ( is_numeric ( $ name ) ) { $ resourceKey = $ this -> fetchOffsetKey ( $ name ) ; } if ( $ this -> processDelete ( $ resourceKey ) ) { $ this -> contentModified = true ; $ this -> size -= 1 ; } }
5713	public function updateItemEditForm ( $ form ) { if ( $ this -> owner -> record -> stat ( 'better_buttons_enabled' ) !== true ) { return false ; } Requirements :: css ( BETTER_BUTTONS_DIR . '/css/gridfield_betterbuttons.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons.js' ) ; $ actions = $ this -> owner -> record -> getBetterButtonsActions ( ) ; $ form -> setActions ( $ this -> filterFieldList ( $ form , $ actions ) ) ; if ( $ form -> Fields ( ) -> hasTabSet ( ) ) { $ form -> Fields ( ) -> findOrMakeTab ( 'Root' ) -> setTemplate ( TabSet :: class ) ; $ form -> addExtraClass ( 'cms-tabset' ) ; } $ utils = $ this -> owner -> record -> getBetterButtonsUtils ( ) ; $ form -> Utils = $ this -> filterFieldList ( $ form , $ utils ) ; $ form -> setTemplate ( [ 'type' => 'Includes' , 'BetterButtons_EditForm' , ] ) ; $ form -> addExtraClass ( 'better-buttons-form' ) ; }
6786	public function buildHeaders ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ headerOptions = [ ] ; foreach ( $ this -> headerParameters as $ key => $ isHeaderParameter ) { if ( $ isHeaderParameter && isset ( $ options [ $ key ] ) ) { $ headerOptions [ $ key ] = $ options [ $ key ] ; } } return $ headerOptions ; }
7326	private function configureTaxableMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Pricing \ Model \ TaxableInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> taxableClassCache ) ) { return ; } if ( ! $ metadata -> hasAssociation ( 'taxGroup' ) ) { $ metadata -> mapManyToOne ( [ 'fieldName' => 'taxGroup' , 'targetEntity' => Pricing \ Entity \ TaxGroup :: class , 'joinColumns' => [ [ 'name' => 'tax_group_id' , 'referencedColumnName' => 'id' , 'onDelete' => 'RESTRICT' , 'nullable' => true , ] , ] , ] ) ; } $ this -> taxableClassCache [ ] = $ class ; }
130	protected function requestXml ( $ origin , $ path ) { $ xml = simplexml_load_string ( $ this -> requestContent ( $ origin , $ path ) , "SimpleXMLElement" , LIBXML_NOERROR ) ; if ( false === $ xml ) { throw new \ UnexpectedValueException ( sprintf ( 'The PEAR channel at ' . $ origin . ' is broken. (Invalid XML at file `%s`)' , $ path ) ) ; } return $ xml ; }
3088	public function isAssessmentSectionAdaptive ( AssessmentSection $ section ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; return count ( $ assessmentItemRefs ) === 1 && $ this -> isAdaptivePlaceholder ( $ assessmentItemRefs [ 0 ] ) ; }
7711	function Delete ( $ Contents = true ) { $ this -> FindEndTag ( ) ; if ( $ Contents || $ this -> SelfClosing ) { $ this -> ReplaceSrc ( '' ) ; } else { $ inner = $ this -> GetInnerSrc ( ) ; $ this -> ReplaceSrc ( $ inner ) ; } }
5304	public function getPath ( $ scale = 1 , $ roundPrecision = null , $ flip = 'none' , $ onlyFilled = true , $ xOffset = 0 , $ yOffset = 0 ) { $ path = $ this -> getPathPart ( $ this -> xmlDocument , $ onlyFilled ) ; if ( $ scale !== 1 || $ roundPrecision !== null || $ flip !== 'none' || $ xOffset !== 0 || $ yOffset !== 0 ) { $ path = $ this -> transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset / $ scale , $ yOffset / $ scale ) ; } return trim ( $ path ) ; }
6765	protected function handleUpdate ( SaleInterface $ sale ) { $ changed = false ; $ changed |= $ this -> updateNumber ( $ sale ) ; $ changed |= $ this -> updateKey ( $ sale ) ; $ changed |= $ this -> updateInformation ( $ sale , true ) ; if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'vatNumber' ) ) { $ changed |= $ this -> pricingUpdater -> updateVatNumberSubject ( $ sale ) ; } if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'customer' ) ) { $ changed |= $ this -> saleUpdater -> updatePaymentTerm ( $ sale ) ; } if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'shipmentMethod' , 'customerGroup' ] ) ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; } if ( $ this -> isDiscountUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateDiscounts ( $ sale , true ) ; } if ( $ this -> isTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateTaxation ( $ sale , true ) ; } elseif ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } return $ changed ; }
11867	public function unlock ( string $ sessionIdentifier ) : void { $ index = array_search ( $ sessionIdentifier , self :: $ lockedIdentifiers ) ; if ( $ index !== false ) { unset ( self :: $ lockedIdentifiers [ $ index ] ) ; } }
8143	public function getLexer ( ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 1.25 and will be removed in 2.0.' , __FUNCTION__ ) , E_USER_DEPRECATED ) ; if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer ; }
2508	public function createRequest ( $ messageName , RequestOptionsInterface $ params ) { $ this -> checkMessageIsInWsdl ( $ messageName ) ; $ builder = $ this -> findBuilderForMessage ( $ messageName ) ; if ( $ builder instanceof ConvertInterface ) { return $ builder -> convert ( $ params , $ this -> getActiveVersionFor ( $ messageName ) ) ; } else { throw new \ RuntimeException ( 'No builder found for message ' . $ messageName ) ; } }
8945	public function replacePreferences ( $ preferences ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ preferenceList = '' ; if ( ! empty ( $ preferences ) ) { foreach ( $ preferences as $ key => $ value ) { $ preferenceList .= '<preference k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <preferences>' . $ preferenceList . '</preferences> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
3144	public function finish ( RunnerServiceContext $ context , $ finalState = DeliveryExecution :: STATE_FINISHED ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ executionUri = $ context -> getTestExecutionUri ( ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ executionService = ServiceProxy :: singleton ( ) ; $ deliveryExecution = $ executionService -> getDeliveryExecution ( $ executionUri ) ; if ( $ deliveryExecution -> getUserIdentifier ( ) == $ userUri ) { \ common_Logger :: i ( "Finishing the delivery execution {$executionUri}" ) ; $ result = $ deliveryExecution -> setState ( $ finalState ) ; } else { \ common_Logger :: w ( "Non owner {$userUri} tried to finish deliveryExecution {$executionUri}" ) ; $ result = false ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ executionUri ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'finish' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; }
5395	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'exception>' ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "exception>\n" ; }
12720	public function callInstance ( $ instance , $ args = [ ] ) { $ args = ( is_array ( $ args ) ? $ args : array_slice ( func_get_args ( ) , 1 ) ) ; $ current = $ this -> make ( $ instance ) ; return call_user_func_array ( $ current , $ args ) ; }
1606	public function findRedirectByPath ( $ path ) { $ redirects = $ this -> findAllRedirects ( true ) ; foreach ( $ redirects as $ redirect ) { $ to = false ; if ( trim ( $ redirect [ 'uri' ] , '/' ) == $ path ) $ to = $ redirect [ 'to' ] ; elseif ( $ uri = $ this -> _isRedirectRegex ( $ redirect [ 'uri' ] ) ) if ( preg_match ( $ uri , $ path ) ) $ to = preg_replace ( $ uri , $ redirect [ 'to' ] , $ path ) ; if ( $ to ) { return [ 'to' => strpos ( $ to , '://' ) !== false ? $ to : UrlHelper :: siteUrl ( $ to ) , 'type' => $ redirect [ 'type' ] , ] ; } } return false ; }
6714	public function getRequestChain ( ) { if ( is_null ( $ this -> requestChain ) ) { $ this -> requestChain = $ this -> getRequestChainFromUri ( $ this -> requestedUri ) ; } return $ this -> requestChain ; }
5680	public function getText ( ) { if ( ! $ this -> text ) { $ this -> text = self :: normalise ( $ this -> raw ) ; } return $ this -> text ; }
2525	public function getConsumerId ( $ generate = false ) { if ( is_null ( $ this -> consumerId ) && $ generate ) { $ this -> consumerId = $ this -> generateGuid ( ) ; } return $ this -> consumerId ; }
413	public function setPort ( $ value ) { if ( $ value != $ this -> _port ) { $ this -> _port = ( int ) $ value ; $ this -> _hostInfo = null ; } }
6618	protected function parseEndpointName ( $ method , $ endpoint ) { $ endpoint = str_replace ( ' ' , '' , ucwords ( str_replace ( [ '-' , '+' , '%20' ] , ' ' , $ endpoint ) ) ) ; $ method = strtolower ( $ method ) ; return $ method . $ endpoint . 'Endpoint' ; }
7531	function toString ( $ attributes = true , $ recursive = true , $ content_only = false ) { if ( $ content_only ) { if ( is_int ( $ content_only ) ) { -- $ content_only ; } return $ this -> toString_content ( $ attributes , $ recursive , $ content_only ) ; } $ s = '<' . $ this -> tag ; if ( $ attributes ) { $ s .= $ this -> toString_attributes ( ) ; } if ( $ this -> self_close ) { $ s .= $ this -> self_close_str . '>' ; } else { $ s .= '>' ; if ( $ recursive ) { $ s .= $ this -> toString_content ( $ attributes ) ; } $ s .= '</' . $ this -> tag . '>' ; } return $ s ; }
2900	public function initFromAction ( $ action ) { if ( ! $ action ) { return ; } $ request = $ action -> getRequest ( ) ; $ this -> httpMethod = $ request -> getMethod ( ) ; $ this -> requestOriginalPath = $ request -> getOriginalPathInfo ( ) ; $ this -> requestPath = $ request -> getPathInfo ( ) ; $ this -> remoteIp = Mage :: helper ( 'core/http' ) -> getRemoteAddr ( ) ; $ this -> routeName = $ request -> getRouteName ( ) ; $ this -> module = $ request -> getControllerModule ( ) ; $ this -> class = get_class ( $ action ) ; $ this -> action = $ action -> getActionMethodName ( $ request -> getActionName ( ) ) ; }
6739	public function set_options ( ) { $ slug = Module :: CustomRatingGrifus ( ) -> getOption ( 'slug' ) ; $ options = $ this -> model -> get_options ( ) ; foreach ( $ options as $ option => $ value ) { Module :: CustomRatingGrifus ( ) -> setOption ( $ option , $ value ) ; } }
10282	public static function splitRange ( $ pRange ) { if ( empty ( $ pRange ) ) { $ pRange = self :: DEFAULT_RANGE ; } $ exploded = explode ( ',' , $ pRange ) ; $ counter = count ( $ exploded ) ; for ( $ i = 0 ; $ i < $ counter ; ++ $ i ) { $ exploded [ $ i ] = explode ( ':' , $ exploded [ $ i ] ) ; } return $ exploded ; }
8225	public function handleRegistration ( Request $ httpRequest ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ user = $ this -> picoAuth -> getUser ( ) ; if ( $ user -> getAuthenticated ( ) ) { $ this -> picoAuth -> redirectToPage ( "index" ) ; } $ this -> picoAuth -> addAllowed ( "register" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/register.md' ) ; $ post = $ httpRequest -> request ; if ( $ post -> has ( "username" ) && $ post -> has ( "email" ) && $ post -> has ( "password" ) && $ post -> has ( "password_repeat" ) ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: REGISTER_CSRF_ACTION ) ) { $ this -> picoAuth -> redirectToPage ( "register" ) ; } $ this -> assertLimits ( ) ; $ reg = array ( "username" => strtolower ( trim ( $ post -> get ( "username" ) ) ) , "email" => trim ( $ post -> get ( "email" ) ) , "password" => new Password ( $ post -> get ( "password" ) ) , "passwordRepeat" => new Password ( $ post -> get ( "password_repeat" ) ) , ) ; $ isValid = $ this -> validateRegistration ( $ reg ) ; if ( $ isValid ) { if ( ! $ this -> limit -> action ( "registration" ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } $ this -> logSuccessfulRegistration ( $ reg ) ; $ userData = array ( 'email' => $ reg [ "email" ] ) ; $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ reg [ "password" ] ) ; $ this -> storage -> saveUser ( $ reg [ "username" ] , $ userData ) ; $ this -> session -> addFlash ( "success" , "Registration completed successfully, you can now log in." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; } else { $ this -> session -> addFlash ( "old" , array ( 'username' => $ reg [ "username" ] , 'email' => $ reg [ "email" ] ) ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } } }
8539	public function setGetMyPriceForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMyPriceForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7681	function TbsPrepareMergeCell ( & $ Txt , & $ Loc ) { if ( $ this -> ExtEquiv == 'docx' ) { $ xml = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'w:tcPr' , $ Loc -> PosBeg , false ) ; if ( $ xml ) { $ Txt = substr_replace ( $ Txt , '' , $ Loc -> PosBeg , $ Loc -> PosEnd - $ Loc -> PosBeg + 1 ) ; $ Loc -> PosBeg = $ xml -> PosEnd + 1 ; $ Loc -> PosEnd = $ xml -> PosEnd ; $ this -> PrevVals [ $ Loc -> FullName ] = '' ; $ Loc -> ConvStr = false ; } } }
6249	protected function prepareForPresentation ( ) { if ( $ this -> prepared ) { return ; } $ this -> permissionGroups = new Collection ; $ this -> ungroupedPermissions = [ ] ; $ this -> groupedPermissionIndex = [ ] ; $ this -> loadPermissionsFromModules ( ) -> loadCustomPermissions ( ) -> loadCustomPermissionGroups ( ) -> addUngroupedPermissionGroup ( ) -> filterEmptyGroups ( ) ; }
10414	public function createTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return null ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ schemaManager -> createTable ( $ table ) ; return true ; }
7842	public function handle ( $ job , Closure $ next ) { $ this -> callBefore ( $ job ) ; $ handled = $ next ( $ job ) ; $ this -> callAfter ( $ handled , $ job ) ; return $ handled ; }
8585	public function setProductGroupList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ProductGroupList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5440	public function addEntryPattern ( $ pattern , $ mode , $ new_mode ) { if ( ! isset ( $ this -> regexes [ $ mode ] ) ) { $ this -> regexes [ $ mode ] = new ParallelRegex ( $ this -> case ) ; } $ this -> regexes [ $ mode ] -> addPattern ( $ pattern , $ new_mode ) ; if ( ! isset ( $ this -> mode_handlers [ $ new_mode ] ) ) { $ this -> mode_handlers [ $ new_mode ] = $ new_mode ; } }
45	public function dispatchPackageEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations , OperationInterface $ operation ) { return $ this -> doDispatch ( new PackageEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations , $ operation ) ) ; }
4433	public function createSubscriber ( array $ channels ) : WatchdogSubscriber { $ redis = clone $ this -> redis ; $ redis -> disconnect ( ) ; $ redis -> connect ( ) ; return new WatchdogSubscriber ( $ redis , $ channels ) ; }
11687	public function getAccompanyingPeriodsOrdered ( ) { $ periods = $ this -> getAccompanyingPeriods ( ) -> toArray ( ) ; usort ( $ periods , function ( $ a , $ b ) { $ dateA = $ a -> getOpeningDate ( ) ; $ dateB = $ b -> getOpeningDate ( ) ; if ( $ dateA == $ dateB ) { $ dateEA = $ a -> getClosingDate ( ) ; $ dateEB = $ b -> getClosingDate ( ) ; if ( $ dateEA == $ dateEB ) { return 0 ; } if ( $ dateEA < $ dateEB ) { return - 1 ; } else { return + 1 ; } } if ( $ dateA < $ dateB ) { return - 1 ; } else { return 1 ; } } ) ; return $ periods ; }
5197	protected function version ( ) { $ version = explode ( '(' , $ this -> app -> version ( ) ) ; if ( isset ( $ version [ 1 ] ) ) { return substr ( $ version [ 1 ] , 0 , 3 ) ; } return null ; }
734	public function init ( ) { parent :: init ( ) ; $ this -> itemFile = Yii :: getAlias ( $ this -> itemFile ) ; $ this -> assignmentFile = Yii :: getAlias ( $ this -> assignmentFile ) ; $ this -> ruleFile = Yii :: getAlias ( $ this -> ruleFile ) ; $ this -> load ( ) ; }
2896	public function captureEmail ( ) { $ email = Mage :: getModel ( 'sheep_debug/email' ) ; $ email -> setFromEmail ( $ this -> getFromEmail ( ) ) ; $ email -> setFromName ( $ this -> getFromName ( ) ) ; $ email -> setToEmail ( $ this -> getToEmail ( ) ) ; $ email -> setToName ( $ this -> getToName ( ) ) ; $ email -> setSubject ( $ this -> getSubject ( ) ) ; $ email -> setIsPlain ( $ this -> getType ( ) != 'html' ) ; $ email -> setBody ( $ this -> getBody ( ) ) ; $ email -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; $ email -> setIsAccepted ( true ) ; $ requestInfo = Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) ; $ requestInfo -> addEmail ( $ email ) ; }
3984	private function addMenu ( & $ modules , $ section , $ name , $ module , Request $ request ) { if ( ! isset ( $ modules [ $ section ] ) ) { $ modules [ $ section ] = $ this -> buildBackendMenuSection ( $ section , $ request ) ; } $ active = $ this -> isActive ( $ module [ 'route' ] , $ module [ 'param' ] , $ request ) ; $ class = 'navigation ' . $ name ; if ( isset ( $ module [ 'class' ] ) ) { $ class .= ' ' . $ module [ 'class' ] ; } if ( $ active ) { $ class .= ' active' ; } if ( $ request -> query -> has ( 'ref' ) ) { $ module [ 'param' ] [ 'ref' ] = $ request -> query -> get ( 'ref' ) ; } $ modules [ $ section ] [ 'modules' ] [ $ name ] = [ 'label' => $ module [ 'label' ] , 'title' => $ module [ 'title' ] , 'class' => $ class , 'isActive' => $ active , 'href' => $ this -> urlGenerator -> generate ( $ module [ 'route' ] , $ module [ 'param' ] ) , ] ; }
2255	protected function eliminateNestedPages ( $ arrPages , $ strTable = null , $ blnSorting = false ) { if ( empty ( $ arrPages ) || ! \ is_array ( $ arrPages ) ) { return array ( ) ; } if ( ! $ strTable ) { $ strTable = 'tl_page' ; } $ arrPages = array_intersect ( $ arrPages , $ this -> Database -> getChildRecords ( 0 , $ strTable , $ blnSorting ) ) ; $ arrPages = array_values ( array_diff ( $ arrPages , $ this -> Database -> getChildRecords ( $ arrPages , $ strTable , $ blnSorting ) ) ) ; return $ arrPages ; }
12329	public function enqueue_style ( WP_Enqueue_Options $ options ) { if ( ! $ options -> have_required_properties ( ) ) { trigger_error ( 'Trying to enqueue style, but required properties are missing.' ) ; return ; } $ handle = $ options -> get_handle ( ) ; $ relative_path = $ options -> get_relative_path ( ) ; $ filename = $ options -> get_filename ( ) ; $ filename_debug = $ options -> get_filename_debug ( ) ; $ dependencies = $ options -> get_dependencies ( ) ; $ version = $ options -> get_version ( ) ; $ media = $ options -> get_media ( ) ; $ source = $ this -> get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug ) ; wp_enqueue_style ( $ handle , $ source , $ dependencies , $ version , $ media ) ; }
4824	public function removeValue ( $ fieldName , $ value ) { $ result = $ this -> row [ $ fieldName ] ; if ( ! is_array ( $ result ) ) { if ( $ value == $ result ) { unset ( $ this -> row [ $ fieldName ] ) ; $ this -> informChanges ( ) ; } } else { $ qty = count ( $ result ) ; for ( $ i = 0 ; $ i < $ qty ; $ i ++ ) { if ( $ result [ $ i ] == $ value ) { unset ( $ result [ $ i ] ) ; $ this -> informChanges ( ) ; } } $ this -> row [ $ fieldName ] = array_values ( $ result ) ; } }
5860	public function getAllFileTypes ( ) { $ fileTypes = [ ] ; foreach ( $ this -> rulesets as $ ruleset ) { if ( is_array ( $ ruleset [ 'file_types' ] ) ) { $ fileTypes = array_merge ( $ fileTypes , $ ruleset [ 'file_types' ] ) ; } } $ fileTypes = array_unique ( $ fileTypes ) ; return $ fileTypes ; }
2794	public function setTempDirectory ( $ dir ) { $ dir = rtrim ( $ dir , ' \\/' ) ; if ( ! is_dir ( $ dir ) || ! is_readable ( $ dir ) ) { throw new InvalidArgumentException ( 'Invalid cache directory: "' . $ dir . '"' ) ; } $ this -> tempDirectory = $ dir ; return $ this ; }
257	public function init ( ) { parent :: init ( ) ; if ( is_array ( $ this -> theme ) ) { if ( ! isset ( $ this -> theme [ 'class' ] ) ) { $ this -> theme [ 'class' ] = 'yii\base\Theme' ; } $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } elseif ( is_string ( $ this -> theme ) ) { $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } }
4201	private function addMethodsMin ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( \ method_exists ( $ obj , '__toString' ) ) { $ abs [ 'methods' ] [ '__toString' ] = array ( 'returnValue' => \ call_user_func ( array ( $ obj , '__toString' ) ) , 'visibility' => 'public' , ) ; } if ( \ method_exists ( $ obj , '__get' ) ) { $ abs [ 'methods' ] [ '__get' ] = array ( 'visibility' => 'public' ) ; } if ( \ method_exists ( $ obj , '__set' ) ) { $ abs [ 'methods' ] [ '__set' ] = array ( 'visibility' => 'public' ) ; } return ; }
8667	public function setMessage ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Message' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3993	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: encodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( $ values ) ; }
11161	protected function getReplacements ( $ entry ) { $ link = 'https://youtu.be/' . $ entry -> id ; $ title = $ entry -> snippet -> title ; $ author = $ entry -> snippet -> channelTitle ; $ published = date ( $ this -> publishedFormat , strtotime ( $ entry -> snippet -> publishedAt ) ) ; $ views = number_format ( $ entry -> statistics -> viewCount , 0 ) ; $ likes = number_format ( $ entry -> statistics -> likeCount , 0 ) ; $ dislikes = number_format ( $ entry -> statistics -> dislikeCount , 0 ) ; $ favorites = number_format ( $ entry -> statistics -> favoriteCount , 0 ) ; $ comments = number_format ( $ entry -> statistics -> commentCount , 0 ) ; $ durationInterval = new \ DateInterval ( $ entry -> contentDetails -> duration ) ; $ duration = $ durationInterval -> format ( $ this -> durationFormat ) ; return array ( '%link%' => $ link , '%title%' => $ title , '%author%' => $ author , '%published%' => $ published , '%views%' => $ views , '%likes%' => $ likes , '%dislikes%' => $ dislikes , '%favorites%' => $ favorites , '%comments%' => $ comments , '%duration%' => $ duration , ) ; }
11193	protected function setPath ( $ url ) { $ cleanURI = str_replace ( '?' . $ _SERVER [ 'QUERY_STRING' ] , '' , $ url ) ; $ this -> pathString = explode ( $ this -> config [ 'site_url' ] , $ cleanURI , 2 ) [ 1 ] ; if ( $ this -> config [ 'lowercase_url' ] ) { $ this -> pathString = strtolower ( $ this -> pathString ) ; } $ this -> path = explode ( '/' , $ this -> pathString ) ; }
11071	public function setInteger ( string $ key , $ value , int $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( int ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
1854	public static function findCurrentByPid ( $ intPid , $ intStart , $ intEnd , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ intStart = ( int ) $ intStart ; $ intEnd = ( int ) $ intEnd ; $ arrColumns = array ( "$t.pid=? AND (($t.startTime>=$intStart AND $t.startTime<=$intEnd) OR ($t.endTime>=$intStart AND $t.endTime<=$intEnd) OR ($t.startTime<=$intStart AND $t.endTime>=$intEnd) OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$intStart) AND $t.startTime<=$intEnd))" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
11153	public function getBoolean ( $ probability = 0.5 ) { if ( ( \ is_int ( $ probability ) || \ is_float ( $ probability ) ) === false || $ probability < 0 || $ probability > 1 ) { throw new InvalidArgumentException ( 'Invalid probability' ) ; } if ( $ probability == 0 ) { $ result = false ; } else { $ random = $ this -> generator -> getFloat ( 0 , 1 ) ; $ result = ( $ probability >= $ random ) ; } return $ result ; }
2021	public static function findPublishedByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
6306	private function register ( array $ providers , array $ values ) { foreach ( $ providers as $ provider ) { $ factories = $ provider -> getFactories ( ) ; foreach ( $ factories as $ key => $ callable ) { $ this [ $ key ] = function ( ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c ) ; } ; } } foreach ( $ providers as $ provider ) { $ extensions = $ provider -> getExtensions ( ) ; foreach ( $ extensions as $ key => $ callable ) { if ( isset ( $ this -> keys [ $ key ] ) ) { $ this [ $ key ] = $ this -> extend ( $ key , function ( $ previous , ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c , $ previous ) ; } ) ; } else { $ this [ $ key ] = function ( ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c ) ; } ; } } } foreach ( $ values as $ key => $ value ) { $ this [ $ key ] = $ value ; } }
5594	protected function createRequest ( $ url , $ encoding ) { $ request = $ this -> createHttpRequest ( $ url , $ encoding ) ; $ this -> addAdditionalHeaders ( $ request ) ; if ( $ this -> cookies_enabled ) { $ request -> readCookiesFromJar ( $ this -> cookie_jar , $ url ) ; } $ this -> authenticator -> addHeaders ( $ request , $ url ) ; if ( $ this -> http_referer ) { $ headers = $ request -> getHeaders ( ) ; if ( is_array ( $ headers ) ) { $ custom_referer = false ; foreach ( $ headers as $ header ) { if ( preg_match ( '~^referer:~i' , $ header ) ) { $ custom_referer = true ; break ; } } if ( ! $ custom_referer ) { $ request -> addHeaderLine ( 'Referer: ' . $ this -> http_referer ) ; } } } return $ request ; }
1770	public function getErrorsAsString ( $ strSeparator = null ) { if ( $ strSeparator === null ) { $ strSeparator = '<br' . $ this -> strTagEnding . "\n" ; } return $ this -> hasErrors ( ) ? implode ( $ strSeparator , $ this -> arrErrors ) : '' ; }
12449	static function run_check_gnu_files ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; if ( $ opts [ 'files' ] [ 'gnu_dir' ] ) { $ destdir .= '/' . $ opts [ 'files' ] [ 'gnu_dir' ] ; } $ files = pakeFinder :: type ( 'file' ) -> name ( array ( 'README' , 'LICENSE' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) != 2 ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "README and/or LICENSE files missing. Please fix" ) ; } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
11220	private static function cleanResources ( ) { self :: $ callbacks = [ ] ; self :: $ methods = [ ] ; self :: $ halts = false ; self :: $ response = false ; }
10083	protected function registerRouter ( ) { $ this -> app -> singleton ( 'auja.router' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new AujaRouter ( $ app [ 'auja' ] , $ app [ 'router' ] , $ config [ 'route' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Routing\AujaRouter' , 'auja.router' ) ; }
11541	public function editProfile ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getEditProfileForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __FUNCTION__ , $ this , compact ( 'user' ) ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __FUNCTION__ . '.post' , $ this , compact ( 'user' ) ) ; return $ user ; }
1261	protected function createTransactionNode ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trxRef = $ xml -> appendChild ( $ xml -> createElement ( 'TransactionReference' ) ) ; if ( null !== $ this -> context ) { $ trxRef -> appendChild ( $ xml -> createElement ( 'CustomerContext' , $ this -> context ) ) ; } return $ trxRef -> cloneNode ( true ) ; }
8220	protected function getSubnet ( $ ip , $ netmask ) { $ binString = @ inet_pton ( $ ip ) ; if ( $ binString === false ) { throw new \ InvalidArgumentException ( "Not a valid IP address." ) ; } $ byteLen = mb_strlen ( $ binString , "8bit" ) ; if ( ! is_int ( $ netmask ) || $ netmask < 0 || $ netmask > $ byteLen * 8 ) { throw new \ InvalidArgumentException ( "Not a valid netmask." ) ; } for ( $ byte = $ byteLen - 1 ; ( $ byte + 1 ) * 8 > $ netmask ; -- $ byte ) { $ maskLen = min ( 8 , ( $ byte + 1 ) * 8 - $ netmask ) ; $ mask = ( ~ ( ( 1 << $ maskLen ) - 1 ) ) & 0xff ; $ maskedByte = $ mask & unpack ( 'C' , $ binString [ $ byte ] ) [ 1 ] ; $ binString [ $ byte ] = pack ( 'C' , $ maskedByte ) ; } return inet_ntop ( $ binString ) . '/' . $ netmask ; }
6364	public function nullsFirst ( ) : Ordering { return Ordering :: from ( Collections :: comparatorFrom ( function ( $ object1 , $ object2 ) { return $ object1 === null ? - 1 : ( $ object2 === null ? 1 : $ this -> compare ( $ object1 , $ object2 ) ) ; } ) ) ; }
2024	public static function findByAliases ( $ arrAliases , array $ arrOptions = array ( ) ) { if ( empty ( $ arrAliases ) || ! \ is_array ( $ arrAliases ) ) { return null ; } $ arrAliases = array_filter ( array_map ( function ( $ v ) { return preg_match ( '/^[\w\/.-]+$/u' , $ v ) ? $ v : null ; } , $ arrAliases ) ) ; if ( empty ( $ arrAliases ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.alias IN('" . implode ( "','" , array_filter ( $ arrAliases ) ) . "')" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.alias" , $ arrAliases ) ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
11497	public static function all ( $ pageNumber = 0 , $ pageSize = 10 , $ order = null ) { return ( new static ( ) ) -> fetchAll ( null , $ order , $ pageSize , $ pageNumber ) ; }
5016	public function logJobStart ( ProcessJobEvent $ event ) : void { $ queue = $ event -> getQueue ( ) ; $ job = $ event -> getJob ( ) ; $ logger = $ this -> getLogger ( ) ; $ logger -> info ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue -> getName ( ) , 'START' , $ this -> formatJob ( $ job ) , '' ) ) ; $ this -> injectLoggerInObject ( $ job ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
7517	function parse_text ( ) { $ len = $ this -> pos - 1 - $ this -> status [ 'last_pos' ] ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ this -> status [ 'last_pos' ] + 1 , $ len ) : '' ) ; }
12345	public function editAction ( Request $ request , Post $ post ) { if ( is_object ( $ post -> getPublished ( ) ) && $ post -> getPublished ( ) -> format ( 'dmY' ) == '3011-0001' ) { $ post -> setPublished ( null ) ; } $ deleteForm = $ this -> createDeleteForm ( $ post ) ; $ editForm = $ this -> createForm ( 'BlogBundle\Form\PostType' , $ post , array ( 'translator' => $ this -> get ( 'translator' ) ) ) ; $ editForm -> handleRequest ( $ request ) ; if ( $ editForm -> isSubmitted ( ) && $ editForm -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ post ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'post.edited' ) ; return $ this -> redirectToRoute ( 'blog_post_index' ) ; } return array ( 'entity' => $ post , 'edit_form' => $ editForm -> createView ( ) , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
2408	public function flushAllData ( ) { @ trigger_error ( 'Using Template::flushAllData() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ function_exists ( 'fastcgi_finish_request' ) ) { fastcgi_finish_request ( ) ; } elseif ( PHP_SAPI !== 'cli' ) { $ status = ob_get_status ( true ) ; $ level = \ count ( $ status ) ; while ( $ level -- > 0 && ( ! empty ( $ status [ $ level ] [ 'del' ] ) || ( isset ( $ status [ $ level ] [ 'flags' ] ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_REMOVABLE ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_FLUSHABLE ) ) ) ) { ob_end_flush ( ) ; } flush ( ) ; } }
2952	protected function prepareTemplate ( $ templateTxt ) { $ patterns = [ '/\\\{%(.*)%\\\}/U' , '/\s+/' , ] ; $ replacements = [ '(?<$1>.*)' , ' ' , ] ; $ templateTxt = preg_replace ( $ patterns , $ replacements , preg_quote ( $ templateTxt , '/' ) ) ; return trim ( $ templateTxt ) ; }
640	public function dropPrimaryKey ( $ name , $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropPrimaryKey ( $ name , $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
9935	public function setOperator ( $ pOperator ) { if ( empty ( $ pOperator ) ) { $ pOperator = self :: AUTOFILTER_COLUMN_RULE_EQUAL ; } if ( ( ! in_array ( $ pOperator , self :: $ operators ) ) && ( ! in_array ( $ pOperator , self :: $ topTenValue ) ) ) { throw new PhpSpreadsheetException ( 'Invalid operator for column AutoFilter Rule.' ) ; } $ this -> operator = $ pOperator ; return $ this ; }
9757	function below ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , lessThan ( $ value ) ) ; }
948	public function api ( ) { $ apiClass = Config :: get ( 'shopify-app.api_class' ) ; $ api = new $ apiClass ( ) ; $ api -> setApiKey ( Config :: get ( 'shopify-app.api_key' ) ) ; $ api -> setApiSecret ( Config :: get ( 'shopify-app.api_secret' ) ) ; $ version = Config :: get ( 'shopify-app.api_version' ) ; if ( $ version !== null ) { $ api -> setVersion ( $ version ) ; } if ( Config :: get ( 'shopify-app.api_rate_limiting_enabled' ) === true ) { $ api -> enableRateLimiting ( Config :: get ( 'shopify-app.api_rate_limit_cycle' ) , Config :: get ( 'shopify-app.api_rate_limit_cycle_buffer' ) ) ; } return $ api ; }
6665	public function parseFb ( $ raw_profile ) { $ profile = $ raw_profile ; $ profile -> avatar = sprintf ( 'http://graph.facebook.com/%s/picture' , $ profile -> id ) ; return ( array ) $ profile ; }
10882	protected function aggregateTernaryValues ( array $ values ) { if ( in_array ( false , $ values , true ) ) { return false ; } elseif ( in_array ( true , $ values , true ) ) { return true ; } else { return null ; } }
1728	public function save ( ) { $ arrFields = $ this -> Database -> getFieldNames ( $ this -> strTable ) ; $ arrSet = array_intersect_key ( $ this -> arrData , array_flip ( $ arrFields ) ) ; $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " %s WHERE id=?" ) -> set ( $ arrSet ) -> execute ( $ this -> id ) ; }
103	protected function pruneToHighestPriorityOrInstalled ( Pool $ pool , array $ installedMap , array $ literals ) { $ selected = array ( ) ; $ priority = null ; foreach ( $ literals as $ literal ) { $ package = $ pool -> literalToPackage ( $ literal ) ; if ( isset ( $ installedMap [ $ package -> id ] ) ) { $ selected [ ] = $ literal ; continue ; } if ( null === $ priority ) { $ priority = $ this -> getPriority ( $ pool , $ package ) ; } if ( $ this -> getPriority ( $ pool , $ package ) != $ priority ) { break ; } $ selected [ ] = $ literal ; } return $ selected ; }
8603	private function _convertDeregisterDestination ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationDeregisterDestinationInput = $ request -> getDestination ( ) ; foreach ( $ DestinationDeregisterDestinationInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
8282	public function onPageRendering ( & $ templateName , array & $ twigVariables ) { $ twigVariables [ 'auth' ] [ 'plugin' ] = $ this ; $ twigVariables [ 'auth' ] [ 'vars' ] = $ this -> output ; if ( ! $ this -> errorOccurred ) { $ twigVariables [ 'auth' ] [ 'user' ] = $ this -> user ; $ old = $ this -> session -> getFlash ( 'old' ) ; if ( count ( $ old ) && isset ( $ old [ 0 ] ) ) { $ twigVariables [ 'auth' ] [ 'old' ] = $ old [ 0 ] ; } } }
3118	public function removeCatValue ( $ testSessionId , $ assessmentSectionId , $ key ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> removeCatValue ( $ assessmentSectionId , $ key ) ; $ extendedState -> save ( ) ; }
12202	public function create ( int $ status = 200 , array $ headers = [ ] , $ body = null ) : ResponseInterface { return new Response ( $ status , $ headers , $ body ) ; }
9577	protected function registerMaterializePlugin ( $ name ) { $ view = $ this -> getView ( ) ; if ( $ this -> materializeAsset ) { MaterializeAsset :: register ( $ view ) ; } if ( $ this -> customAsset ) { MaterializeCustomAsset :: register ( $ view ) ; } $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false && is_array ( $ this -> clientOptions ) ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: htmlEncode ( $ this -> clientOptions ) ; $ js = "Materialize.$name.apply(null, $options);" ; $ view -> registerJs ( $ js ) ; } $ this -> registerClientEvents ( ) ; }
4906	public function indexAction ( ) { $ view = $ this -> params ( 'view' ) ; $ view = 'content/' . $ view ; $ viewModel = new ViewModel ( ) ; $ viewModel -> setTemplate ( $ view ) ; $ request = $ this -> getRequest ( ) ; if ( $ request -> isXmlHttpRequest ( ) ) { $ viewModel -> setTerminal ( true ) ; } return $ viewModel ; }
10094	protected function srvGet ( $ domain , $ https = false ) { if ( isset ( $ https ) && $ https === true ) { $ subdomain = '_avatars-sec._tcp.' ; $ fallback = 'seccdn.' ; $ port = 443 ; } else { $ subdomain = '_avatars._tcp.' ; $ fallback = 'cdn.' ; $ port = 80 ; } if ( $ domain === null ) { return $ fallback . 'libravatar.org' ; } $ srv = dns_get_record ( $ subdomain . $ domain , DNS_SRV ) ; if ( count ( $ srv ) == 0 ) { return $ fallback . 'libravatar.org' ; } usort ( $ srv , array ( $ this , 'comparePriority' ) ) ; $ top = $ srv [ 0 ] ; $ sum = 0 ; shuffle ( $ srv ) ; $ srvs = array ( ) ; foreach ( $ srv as $ s ) { if ( $ s [ 'weight' ] == 0 ) { array_unshift ( $ srvs , $ s ) ; } else { array_push ( $ srvs , $ s ) ; } } foreach ( $ srvs as $ s ) { if ( $ s [ 'pri' ] == $ top [ 'pri' ] ) { $ sum += ( int ) $ s [ 'weight' ] ; $ pri [ $ sum ] = $ s ; } } $ random = rand ( 0 , $ sum ) ; foreach ( $ pri as $ k => $ v ) { if ( $ k >= $ random ) { $ target = $ v [ 'target' ] ; if ( $ v [ 'port' ] !== $ port ) { $ target .= ':' . $ v [ 'port' ] ; } return $ target ; } } }
10067	protected function registerTags ( ) { $ tags = array ( 'error' , 'hint' , 'label' , 'radioset' , 'checkboxset' ) ; foreach ( $ tags as $ tag ) { $ tagClass = str_replace ( ' ' , '' , ucwords ( str_replace ( '-' , ' ' , $ tag ) ) ) ; $ this -> registerTag ( $ tag , __NAMESPACE__ . '\Tag\\' . $ tagClass ) ; } $ widgets = array ( 'text' , 'file' , 'textarea' , 'radio' , 'checkbox' , 'select' , 'multiselect' , 'checkboxset' , 'radioset' , 'email' , 'password' , 'radioset' , 'checkboxset' , 'button' , 'submit' , 'reset' , 'group' , 'fieldset' , 'collection' , 'form' ) ; foreach ( $ widgets as $ widget ) { $ widgetClass = str_replace ( ' ' , '' , ucwords ( str_replace ( '-' , ' ' , $ widget ) ) ) ; $ this -> registerTag ( 'widget-' . $ widget , __NAMESPACE__ . '\Widget\\' . $ widgetClass ) ; } }
1993	protected function prepareMetaDescription ( $ strText ) { $ strText = $ this -> replaceInsertTags ( $ strText , false ) ; $ strText = strip_tags ( $ strText ) ; $ strText = str_replace ( "\n" , ' ' , $ strText ) ; $ strText = StringUtil :: substr ( $ strText , 320 ) ; return trim ( $ strText ) ; }
3509	private static function renderToTextFromOpcode ( $ opcode , $ from , $ from_offset , $ from_len ) { if ( $ opcode === 'c' || $ opcode === 'i' ) { echo substr ( $ from , $ from_offset , $ from_len ) ; } }
12872	public function setElementRequired ( \ Zend \ Form \ Element $ element ) { $ element -> setAttribute ( 'required' , 'true' ) ; $ this -> form -> getInputFilter ( ) -> get ( $ element -> getAttribute ( 'name' ) ) -> setAllowEmpty ( false ) ; }
5784	public function routePutUpdate ( Request $ request , Response $ response , $ args ) { if ( ! $ this -> authorization -> isAuthorized ( constant ( strtoupper ( $ this -> routePrefix ) . "_UPDATE_RESOURCE" ) ) ) { throw new \ Exception ( 'No permission.' ) ; } $ primaryKeyValue = $ args [ ROUTEARG_PRIMARY_KEY ] ; $ this -> setRequestInput ( $ request , DatabaseTableForm :: getFieldNames ( $ this -> tableMapper ) , $ this -> tableMapper -> getBooleanColumnNames ( ) ) ; $ redirectRoute = SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ; if ( null === $ record = $ this -> tableMapper -> selectForPrimaryKey ( $ primaryKeyValue ) ) { return $ this -> databaseRecordNotFound ( $ response , $ primaryKeyValue , $ this -> tableMapper , 'update' ) ; } $ changedColumnsValues = $ this -> getMapper ( ) -> getChangedColumnsValues ( $ this -> requestInput , $ record ) ; if ( count ( $ changedColumnsValues ) == 0 ) { SlimPostgres :: setAdminNotice ( "No changes made" , 'failure' ) ; return $ this -> view -> updateView ( $ request , $ response , $ args ) ; } $ validator = new DatabaseTableUpdateFormValidator ( $ this -> requestInput , $ this -> tableMapper , $ record ) ; if ( ! $ validator -> validate ( ) ) { FormHelper :: setFieldErrors ( $ validator -> getFirstErrors ( ) ) ; $ args [ SlimPostgres :: USER_INPUT_KEY ] = $ this -> requestInput ; return $ this -> view -> updateView ( $ request , $ response , $ args ) ; } $ this -> tableMapper -> updateByPrimaryKey ( $ changedColumnsValues , $ primaryKeyValue ) ; $ this -> enterEventAndNotice ( 'update' , $ primaryKeyValue ) ; return $ response -> withRedirect ( $ this -> router -> pathFor ( $ redirectRoute ) ) ; }
4262	public function subscribe ( $ eventName , $ callable , $ priority = 0 ) { unset ( $ this -> sorted [ $ eventName ] ) ; $ this -> subscribers [ $ eventName ] [ $ priority ] [ ] = $ callable ; }
3180	public function useClientContainer ( ) { if ( $ this -> hasOption ( self :: OPTION_CLIENT_TESTRUNNER ) ) { return $ this -> getOption ( self :: OPTION_CLIENT_TESTRUNNER ) ; } else { $ itemModel = $ this -> getServiceLocator ( ) -> get ( ItemModel :: SERVICE_ID ) ; return $ itemModel -> getCompilerClass ( ) == QtiJsonItemCompiler :: class ; } }
3145	public function pause ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> suspend ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'pause' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
5679	protected function noResponse ( ) { $ this -> transport_error = 'No page fetched yet' ; $ this -> raw = false ; $ this -> sent = false ; $ this -> headers = false ; $ this -> method = 'GET' ; $ this -> url = false ; $ this -> request_data = false ; }
7178	public function isValidType ( $ type ) { return in_array ( $ type , array ( self :: ANY , self :: FIXED_LINE , self :: MOBILE , self :: PAGER , self :: PERSONAL_NUMBER , self :: PREMIUM_RATE , self :: SHARED_COST , self :: TOLL_FREE , self :: UAN , self :: VOIP , self :: VOICEMAIL , ) , true ) ; }
1565	public function getResource ( ) { if ( ! $ this -> resource_type || ! $ this -> resource_id ) { return null ; } return $ this -> getApi ( ) -> getStore ( ) -> find ( ResourceIdentifier :: create ( $ this -> resource_type , ( string ) $ this -> resource_id ) ) ; }
3441	protected function normalizePropertyFormat ( ) { if ( empty ( $ this -> fields [ 'PROPERTIES' ] ) ) { return ; } foreach ( $ this -> fields [ 'PROPERTIES' ] as $ code => $ prop ) { $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE' ] = $ prop [ 'VALUE' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_VALUE' ] = $ prop [ '~VALUE' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ 'DESCRIPTION' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ '~DESCRIPTION' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE_ID' ] = $ prop [ 'PROPERTY_VALUE_ID' ] ; } }
8380	protected function applyFilters ( $ value , $ key ) { foreach ( $ this -> filters as $ filter ) { $ value = $ filter ( $ value , $ key ) ; } return $ value ; }
3420	public function delete ( ) { if ( $ this -> onBeforeDelete ( ) === false ) { return false ; } $ result = static :: $ bxObject -> delete ( $ this -> id ) ; $ this -> setEventErrorsOnFail ( $ result , static :: $ bxObject ) ; $ this -> onAfterDelete ( $ result ) ; $ this -> resetEventErrors ( ) ; $ this -> throwExceptionOnFail ( $ result , static :: $ bxObject ) ; return $ result ; }
12064	public function setFlashBag ( $ sName , $ sValue ) { if ( ! isset ( $ _SESSION [ 'flashbag' ] ) ) { $ _SESSION [ 'flashbag' ] = array ( ) ; } $ _SESSION [ 'flashbag' ] [ $ sName ] = $ sValue ; return $ this ; }
9687	public function jsonSerialize ( ) { return array_map ( function ( $ value ) { if ( $ value instanceof JsonSerializable ) { return $ value -> jsonSerialize ( ) ; } elseif ( $ value instanceof JsonableInterface ) { return json_decode ( $ value -> toJson ( ) , true ) ; } elseif ( $ value instanceof ArrayableInterface ) { return $ value -> toArray ( ) ; } else { return $ value ; } } , $ this -> items ) ; }
2242	public static function getContentElement ( $ intId , $ strColumn = 'main' ) { if ( \ is_object ( $ intId ) ) { $ objRow = $ intId ; } else { if ( ! \ strlen ( $ intId ) || $ intId < 1 ) { return '' ; } $ objRow = ContentModel :: findByPk ( $ intId ) ; if ( $ objRow === null ) { return '' ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } $ strClass = ContentElement :: findClass ( $ objRow -> type ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Content element class "' . $ strClass . '" (content element "' . $ objRow -> type . '") does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = 'ce_' ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } if ( $ objElement -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
3973	public function encodeAttributeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ value = substr ( $ value , \ strlen ( $ metaModel -> getTableName ( ) . '_' ) ) ; $ attribute = $ metaModel -> getAttribute ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ attribute -> get ( 'id' ) ) ; } }
2471	public function findContent ( Query $ query , array $ languageFilter = array ( ) ) { $ query = clone $ query ; $ query -> filter = $ query -> filter ? : new Criterion \ MatchAll ( ) ; $ query -> query = $ query -> query ? : new Criterion \ MatchAll ( ) ; $ this -> coreFilter -> apply ( $ query , $ languageFilter , DocumentMapper :: DOCUMENT_TYPE_IDENTIFIER_CONTENT ) ; return $ this -> resultExtractor -> extract ( $ this -> gateway -> findContent ( $ query , $ languageFilter ) , $ query -> facetBuilders ) ; }
4741	private function createProfilerProbes ( $ name , ContainerBuilder $ container ) { $ key = sprintf ( "socloz_monitoring.profiler.probe.definition.%s" , $ name ) ; if ( $ container -> hasParameter ( $ key ) ) { $ definition = $ container -> getParameter ( $ key ) ; return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS | Probe :: TRACKER_TIMING , $ definition , $ container ) ) ; } else { return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS , $ container -> getParameter ( $ key . '.calls' ) , $ container ) , $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_TIMING , $ container -> getParameter ( $ key . '.timing' ) , $ container ) , ) ; } }
162	public function addParams ( $ params ) { if ( ! empty ( $ params ) ) { if ( empty ( $ this -> params ) ) { $ this -> params = $ params ; } else { foreach ( $ params as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> params [ ] = $ value ; } else { $ this -> params [ $ name ] = $ value ; } } } } return $ this ; }
5764	public function routeIndexResetFilter ( Request $ request , Response $ response , $ args ) { return $ this -> indexViewObjects ( $ response , true ) ; }
11371	public function destroy ( $ menuId = null ) { if ( $ menuId !== null ) { return $ this -> parseJSON ( 'json' , [ self :: API_CONDITIONAL_DELETE , [ 'menuid' => $ menuId ] ] ) ; } return $ this -> parseJSON ( 'get' , [ self :: API_DELETE ] ) ; }
7603	public function render ( ElementInterface $ oElement ) { $ sElementType = $ oElement -> getAttribute ( 'type' ) ; if ( ! in_array ( $ sElementType , $ this -> options -> getIgnoredViewHelpers ( ) ) && ! ( $ oElement instanceof Collection ) ) { if ( $ sElementClass = $ oElement -> getAttribute ( 'class' ) ) { if ( ! preg_match ( '/(\s|^)form-control(\s|$)/' , $ sElementClass ) ) { $ oElement -> setAttribute ( 'class' , trim ( $ sElementClass . ' form-control' ) ) ; } } else { $ oElement -> setAttribute ( 'class' , 'form-control' ) ; } } $ sMarkup = parent :: render ( $ oElement ) ; if ( $ aAddOnPrepend = $ oElement -> getOption ( 'add-on-prepend' ) ) { $ sMarkup = $ this -> renderAddOn ( $ aAddOnPrepend ) . $ sMarkup ; } if ( $ aAddOnAppend = $ oElement -> getOption ( 'add-on-append' ) ) { $ sMarkup .= $ this -> renderAddOn ( $ aAddOnAppend ) ; } if ( $ aAddOnAppend || $ aAddOnPrepend ) { $ sSpecialClass = '' ; if ( $ sElementClass = $ oElement -> getAttribute ( 'class' ) ) { if ( preg_match ( '/(\s|^)input-lg(\s|$)/' , $ sElementClass ) ) { $ sSpecialClass .= ' input-group-lg' ; } elseif ( preg_match ( '/(\s|^)input-sm(\s|$)/' , $ sElementClass ) ) { $ sSpecialClass .= ' input-group-sm' ; } } return sprintf ( static :: $ inputGroupFormat , trim ( $ sSpecialClass ) , $ sMarkup ) ; } return $ sMarkup ; }
839	public static function fromCode ( $ code ) { $ codeHash = self :: calculateCodeHash ( $ code ) ; if ( self :: hasCache ( $ codeHash ) ) { $ tokens = self :: getCache ( $ codeHash ) ; $ tokens -> generateCode ( ) ; if ( $ codeHash === $ tokens -> codeHash ) { $ tokens -> clearEmptyTokens ( ) ; $ tokens -> clearChanged ( ) ; return $ tokens ; } } $ tokens = new self ( ) ; $ tokens -> setCode ( $ code ) ; $ tokens -> clearChanged ( ) ; return $ tokens ; }
8860	public function onBeforePublish ( ) { if ( $ this -> dbObject ( 'PublishDate' ) -> InPast ( ) && ! $ this -> isPublished ( ) ) { $ this -> setCastedField ( "PublishDate" , time ( ) ) ; $ this -> write ( ) ; } }
4540	public function get ( string $ key ) { $ config = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ config ) { throw new OutOfRangeException ( 'Config "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ config ) ; return $ config -> getValue ( ) ; }
5191	private function handleString ( $ str ) : string { return is_string ( $ str ) && strlen ( $ str ) > 0 && $ str !== null ? $ str : '' ; }
3942	private static function buildLanguageArray ( IMetaModel $ metaModel , TranslatorInterface $ translator ) { $ languages = array ( ) ; foreach ( ( array ) $ metaModel -> getAvailableLanguages ( ) as $ langCode ) { $ languages [ $ langCode ] = $ translator -> translate ( 'LNG.' . $ langCode , 'languages' ) ; } asort ( $ languages ) ; return $ languages ; }
2415	protected function addTableTlImageSize ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ imageSizeTable = $ xml -> createElement ( 'table' ) ; $ imageSizeTable -> setAttribute ( 'name' , 'tl_image_size' ) ; $ imageSizeTable = $ tables -> appendChild ( $ imageSizeTable ) ; $ imageSizeItemTable = $ xml -> createElement ( 'table' ) ; $ imageSizeItemTable -> setAttribute ( 'name' , 'tl_image_size_item' ) ; $ imageSizeItemTable = $ tables -> appendChild ( $ imageSizeItemTable ) ; $ objSizes = $ this -> Database -> prepare ( "SELECT * FROM tl_image_size WHERE pid=?" ) -> execute ( $ objTheme -> id ) ; while ( $ objSizes -> next ( ) ) { $ this -> addDataRow ( $ xml , $ imageSizeTable , $ objSizes -> row ( ) ) ; $ objSizeItems = $ this -> Database -> prepare ( "SELECT * FROM tl_image_size_item WHERE pid=?" ) -> execute ( $ objSizes -> id ) ; while ( $ objSizeItems -> next ( ) ) { $ this -> addDataRow ( $ xml , $ imageSizeItemTable , $ objSizeItems -> row ( ) ) ; } } }
6201	public function addRoute ( $ newRoute ) { $ this -> routeMap [ 'routes' ] = array_merge ( $ this -> routeMap [ 'routes' ] , $ newRoute ) ; $ this -> routeMapParse = array_merge ( $ this -> routeMapParse , $ newRoute ) ; }
6298	public function addToMain ( array $ item , $ name = 'default' , $ first = false ) { if ( ! array_key_exists ( $ name , $ this -> main ) ) { $ this -> main [ $ name ] = [ ] ; } if ( $ first ) { $ this -> main [ $ name ] = array_merge ( [ $ item ] , $ this -> main [ $ name ] ) ; } else { $ this -> main [ $ name ] [ ] = $ item ; } return $ this ; }
6152	public function run ( ) { if ( ! empty ( $ this -> _fields ) ) { throw new InvalidCallException ( 'Each beginField() should have a matching endField() call.' ) ; } $ id = $ this -> options [ 'id' ] ; $ options = Json :: encode ( $ this -> getClientOptions ( ) ) ; $ attributes = Json :: encode ( $ this -> attributes ) ; $ view = $ this -> getView ( ) ; AdminUiActiveForm :: register ( $ view ) ; $ view -> registerJs ( "jQuery('#$id').yiiActiveForm($attributes, $options);" ) ; echo Html :: endForm ( ) ; }
10213	public function getSharedComponent ( ) { switch ( $ this -> parentPropertyName ) { case 'allBorders' : case 'horizontal' : case 'inside' : case 'outline' : case 'vertical' : throw new PhpSpreadsheetException ( 'Cannot get shared component for a pseudo-border.' ) ; break ; case 'bottom' : return $ this -> parent -> getSharedComponent ( ) -> getBottom ( ) ; case 'diagonal' : return $ this -> parent -> getSharedComponent ( ) -> getDiagonal ( ) ; case 'left' : return $ this -> parent -> getSharedComponent ( ) -> getLeft ( ) ; case 'right' : return $ this -> parent -> getSharedComponent ( ) -> getRight ( ) ; case 'top' : return $ this -> parent -> getSharedComponent ( ) -> getTop ( ) ; } }
5062	public function output ( ) : string { if ( is_null ( $ this -> buffer ) ) { $ this -> exec ( ) ; } curl_close ( $ this -> ch ) ; if ( strlen ( $ this -> buffer ) === 0 ) { throw new NoOutputException ( ) ; } return $ this -> buffer ; }
2096	public function getWeekBegin ( $ intStartDay = 0 ) { $ intOffset = date ( 'w' , $ this -> strDate ) - $ intStartDay ; if ( $ intOffset < 0 ) { $ intOffset += 7 ; } return strtotime ( '-' . $ intOffset . ' days' , $ this -> strDate ) ; }
4944	public function grant ( $ resource , $ permission = null , $ build = true ) { if ( is_array ( $ resource ) ) { foreach ( $ resource as $ r ) { $ this -> grant ( $ r , $ permission , false ) ; } if ( $ build ) { $ this -> build ( ) ; } return $ this ; } true === $ permission || ( null === $ permission && $ resource instanceof PermissionsResourceInterface ) || $ this -> checkPermission ( $ permission ) ; $ resourceId = $ this -> getResourceId ( $ resource ) ; if ( true === $ permission ) { $ permission = $ this -> getFrom ( $ resource ) ; } if ( self :: PERMISSION_NONE == $ permission ) { if ( $ resource instanceof PermissionsResourceInterface ) { $ refs = $ this -> getResources ( ) ; if ( $ refs -> contains ( $ resource ) ) { $ refs -> removeElement ( $ resource ) ; } } unset ( $ this -> assigned [ $ resourceId ] ) ; } else { if ( $ resource instanceof PermissionsResourceInterface ) { $ spec = $ resource -> getPermissionsUserIds ( $ this -> type ) ; if ( ! is_array ( $ spec ) || ! count ( $ spec ) ) { $ spec = array ( ) ; } elseif ( is_numeric ( key ( $ spec ) ) ) { $ spec = array ( $ permission => $ spec ) ; } } else { $ spec = array ( $ permission => $ resource instanceof UserInterface ? array ( $ resource -> getId ( ) ) : array ( $ resource ) ) ; } $ this -> assigned [ $ resourceId ] = $ spec ; if ( $ resource instanceof PermissionsResourceInterface ) { try { $ refs = $ this -> getResources ( ) ; if ( ! $ refs -> contains ( $ resource ) ) { $ refs -> add ( $ resource ) ; } } catch ( \ Exception $ e ) { } ; } } if ( $ build ) { $ this -> build ( ) ; } $ this -> hasChanged = true ; return $ this ; }
7121	private function createFindBySubjectQueryBuilder ( ) { $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createQueryBuilder ( ) ; return $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.subjectIdentity.provider' , ':provider' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.subjectIdentity.identifier' , ':identifier' ) ) ; }
20	protected function propagate ( $ level ) { while ( $ this -> decisions -> validOffset ( $ this -> propagateIndex ) ) { $ decision = $ this -> decisions -> atOffset ( $ this -> propagateIndex ) ; $ conflict = $ this -> watchGraph -> propagateLiteral ( $ decision [ Decisions :: DECISION_LITERAL ] , $ level , $ this -> decisions ) ; $ this -> propagateIndex ++ ; if ( $ conflict ) { return $ conflict ; } } return null ; }
7753	public function serialize ( $ data , $ format , array $ context = array ( ) ) { if ( 'jsonld' !== $ format ) { throw new UnexpectedValueException ( 'Serialization for the format ' . $ format . ' is not supported' ) ; } if ( false === is_object ( $ data ) ) { throw new \ Exception ( 'Only objects can be serialized' ) ; } return JsonLD :: toString ( $ this -> doSerialize ( $ data , true ) , true ) ; }
9016	public function markAllNotificationsAsRead ( ) { $ object = Auth :: user ( ) ; $ object -> unreadNotifications -> markAsRead ( ) ; \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
6449	private function compareAcceptLanguageHeaders ( AcceptLanguageHeaderValue $ a , AcceptLanguageHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aValue = $ a -> getLanguage ( ) ; $ bValue = $ b -> getLanguage ( ) ; if ( $ aValue === '*' ) { if ( $ bValue === '*' ) { return 0 ; } return 1 ; } if ( $ bValue === '*' ) { return - 1 ; } return 0 ; }
2753	protected function getRequestForPath ( $ path , array $ exclude ) { if ( ! empty ( $ exclude [ $ path ] ) ) { return NULL ; } $ request = Request :: create ( $ path ) ; $ request -> headers -> set ( 'Accept' , 'text/html' ) ; $ processed = $ this -> pathProcessor -> processInbound ( $ path , $ request ) ; if ( empty ( $ processed ) || ! empty ( $ exclude [ $ processed ] ) ) { return NULL ; } $ this -> currentPath -> setPath ( $ processed , $ request ) ; try { $ request -> attributes -> add ( $ this -> router -> matchRequest ( $ request ) ) ; return $ request ; } catch ( ParamNotConvertedException $ e ) { return NULL ; } catch ( ResourceNotFoundException $ e ) { return NULL ; } catch ( MethodNotAllowedException $ e ) { return NULL ; } catch ( AccessDeniedHttpException $ e ) { return NULL ; } }
7104	public static function title ( $ title , $ separator = '-' , $ ascii_only = FALSE ) { if ( $ ascii_only === TRUE ) { $ title = UTF8 :: transliterate_to_ascii ( $ title ) ; $ title = preg_replace ( '![^' . preg_quote ( $ separator ) . 'a-z0-9\s]+!' , '' , strtolower ( $ title ) ) ; } else { $ title = preg_replace ( '![^' . preg_quote ( $ separator ) . '\pL\pN\s]+!u' , '' , UTF8 :: strtolower ( $ title ) ) ; } $ title = preg_replace ( '![' . preg_quote ( $ separator ) . '\s]+!u' , $ separator , $ title ) ; return trim ( $ title , $ separator ) ; }
5161	public function attach ( string $ field , Model $ item ) : self { $ this -> attachment [ $ field ] [ ] = $ item ; return $ this ; }
7828	protected function getSpacesByWord ( $ word ) { $ length = $ this -> getSideBordersLength ( ) + static :: SPACE_FROM_ARROW + static :: ARROW_WIDTH ; $ extra = $ this -> getHalfWidth ( true ) - $ length - strlen ( $ word ) ; return $ extra > 0 ? str_repeat ( ' ' , $ extra ) : '' ; }
8633	public function setOrderChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3600	public function createHttpResponseFromException ( \ Exception $ exception ) { $ httpResponse = HttpResponse :: create ( ) ; $ json = [ ] ; $ json [ 'jsonrpc' ] = '2.0' ; $ json [ 'error' ] = [ ] ; if ( $ exception instanceof Exceptions \ ErrorException ) { $ json [ 'error' ] [ 'code' ] = $ exception -> getCode ( ) ; $ json [ 'error' ] [ 'message' ] = $ exception -> getMessage ( ) ; if ( $ exception -> getData ( ) ) { $ json [ 'error' ] [ 'data' ] = $ exception -> getData ( ) ; } $ json [ 'id' ] = $ exception -> getId ( ) ; } else { $ json [ 'error' ] [ 'code' ] = - 32603 ; $ json [ 'error' ] [ 'message' ] = 'Internal error' ; $ json [ 'id' ] = null ; } $ httpResponse -> headers -> set ( 'Content-Type' , 'application/json' ) ; $ httpResponse -> setContent ( \ json_encode ( $ json ) ) ; $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; $ this -> dispatch ( Event \ HttpResponseEvent :: EVENT , new Event \ HttpResponseEvent ( $ httpResponse ) ) ; return $ httpResponse ; }
1813	public function setRteSyntax ( $ varValue , Contao \ DataContainer $ dc ) { switch ( $ dc -> activeRecord -> highlight ) { case 'C' : case 'CSharp' : $ syntax = 'c_cpp' ; break ; case 'CSS' : case 'Diff' : case 'Groovy' : case 'HTML' : case 'Java' : case 'JavaScript' : case 'Perl' : case 'PHP' : case 'PowerShell' : case 'Python' : case 'Ruby' : case 'Scala' : case 'SQL' : case 'Text' : case 'YAML' : $ syntax = strtolower ( $ dc -> activeRecord -> highlight ) ; break ; case 'VB' : $ syntax = 'vbscript' ; break ; case 'XML' : case 'XHTML' : $ syntax = 'xml' ; break ; default : $ syntax = 'text' ; break ; } if ( $ dc -> activeRecord -> type == 'markdown' ) { $ syntax = 'markdown' ; } $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'code' ] [ 'eval' ] [ 'rte' ] = 'ace|' . $ syntax ; return $ varValue ; }
6448	public function getBestLanguageMatch ( array $ supportedLanguages , array $ languageHeaders ) : ? string { usort ( $ languageHeaders , [ $ this , 'compareAcceptLanguageHeaders' ] ) ; $ rankedLanguageHeaders = array_filter ( $ languageHeaders , [ $ this , 'filterZeroScores' ] ) ; $ rankedLanguageHeaderValues = $ this -> getLanguageValuesFromHeaders ( $ rankedLanguageHeaders ) ; foreach ( $ rankedLanguageHeaderValues as $ language ) { $ languageParts = explode ( '-' , $ language ) ; do { foreach ( $ supportedLanguages as $ supportedLanguage ) { if ( $ language === '*' || implode ( '-' , $ languageParts ) === $ supportedLanguage ) { return $ supportedLanguage ; } } array_pop ( $ languageParts ) ; } while ( count ( $ languageParts ) > 0 ) ; } return null ; }
11044	function masktree_merge ( $ masktree1 , $ masktree2 , $ maskname ) { $ merged = array_merge ( $ masktree1 , $ masktree2 ) ; if ( count ( $ merged ) < count ( $ masktree1 ) + count ( $ masktree2 ) ) { $ keys1 = array_keys ( $ masktree1 ) ; $ keys2 = array_keys ( $ masktree2 ) ; $ keysm = array_merge ( $ keys1 , $ keys2 ) ; $ keysc = array_count_values ( $ keysm ) ; foreach ( $ keysc as $ keyn => $ keyc ) { if ( $ keyc > 1 ) { if ( $ keyn == '0reduce' ) { $ this -> error ( 6 , 49 , 'reduce element already used' ) ; } elseif ( $ keyn != '0include' ) { $ this -> error ( 16 , 60 , "template $keyn already defined in <b>$maskname</b>" ) ; } } } } return $ merged ; }
6779	protected function configureAcceptedSale ( SaleInterface $ sale ) { if ( null === $ date = $ sale -> getAcceptedAt ( ) ) { return false ; } $ changed = $ this -> updateExchangeRate ( $ sale ) ; $ changed |= $ this -> updateLocale ( $ sale ) ; return $ changed ; }
2289	protected function activateRecipient ( ) { $ this -> Template = new FrontendTemplate ( 'mod_newsletter' ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) < 1 || key ( $ arrRelated ) != 'tl_newsletter_recipients' || \ count ( $ arrIds = current ( $ arrRelated ) ) < 1 ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } $ arrRecipients = array ( ) ; foreach ( $ arrIds as $ intId ) { if ( ! $ objRecipient = NewsletterRecipientsModel :: findByPk ( $ intId ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objRecipient -> email ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ arrRecipients [ ] = $ objRecipient ; } $ time = time ( ) ; $ arrAdd = array ( ) ; $ arrCids = array ( ) ; foreach ( $ arrRecipients as $ objRecipient ) { $ arrAdd [ ] = $ objRecipient -> id ; $ arrCids [ ] = $ objRecipient -> pid ; $ objRecipient -> tstamp = $ time ; $ objRecipient -> active = '1' ; $ objRecipient -> save ( ) ; } $ optInToken -> confirm ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ optInToken -> getEmail ( ) , $ arrAdd , $ arrCids ) ; } } $ this -> Template -> mclass = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_activate' ] ; }
2006	protected function removeRecipient ( $ strEmail , $ arrRemove ) { if ( ( $ objRemove = NewsletterRecipientsModel :: findByEmailAndPids ( $ strEmail , $ arrRemove ) ) !== null ) { while ( $ objRemove -> next ( ) ) { $ strHash = md5 ( $ objRemove -> email ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( $ strHash , $ objRemove -> pid ) ) === null ) { $ objBlacklist = new NewsletterBlacklistModel ( ) ; $ objBlacklist -> pid = $ objRemove -> pid ; $ objBlacklist -> hash = $ strHash ; $ objBlacklist -> save ( ) ; } $ objRemove -> delete ( ) ; } } $ objChannels = NewsletterChannelModel :: findByIds ( $ arrRemove ) ; $ arrChannels = $ objChannels -> fetchEach ( 'title' ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strEmail , $ arrRemove ) ; } } $ arrData = array ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ arrChannels ) ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ this -> nl_unsubscribe , $ arrData ) ; $ objEmail -> sendTo ( $ strEmail ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_removed' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_removed' ] ) ; $ this -> reload ( ) ; }
6729	public function set_movie_rating ( $ post_id , $ rating ) { if ( ! add_post_meta ( $ post_id , 'imdbRating' , $ rating , true ) ) { update_post_meta ( $ post_id , 'imdbRating' , $ rating ) ; } }
2790	public static function getMutation ( array & $ tokens , $ index ) { $ num = ( float ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1.0 ; } elseif ( $ num == 1 ) { $ replace = 0.0 ; } elseif ( $ num < 2 ) { $ replace = $ num + 1 ; } else { $ replace = 1.0 ; } $ tokens [ $ index ] = [ T_DNUMBER , sprintf ( "%.2f" , $ replace ) ] ; }
322	public static function pluralize ( $ word ) { if ( isset ( static :: $ specials [ $ word ] ) ) { return static :: $ specials [ $ word ] ; } foreach ( static :: $ plurals as $ rule => $ replacement ) { if ( preg_match ( $ rule , $ word ) ) { return preg_replace ( $ rule , $ replacement , $ word ) ; } } return $ word ; }
7875	protected function settleRepositoryIfNotExists ( ) { $ source = $ this -> pipelines -> getSource ( ) ; if ( ! $ this -> files -> exists ( $ source ) ) { $ this -> pipelines -> settle ( ) ; } }
9662	private static function getReaderTypeFromExtension ( $ filename ) { $ pathinfo = pathinfo ( $ filename ) ; if ( ! isset ( $ pathinfo [ 'extension' ] ) ) { return null ; } switch ( strtolower ( $ pathinfo [ 'extension' ] ) ) { case 'xlsx' : case 'xlsm' : case 'xltx' : case 'xltm' : return 'Xlsx' ; case 'xls' : case 'xlt' : return 'Xls' ; case 'ods' : case 'ots' : return 'Ods' ; case 'slk' : return 'Slk' ; case 'xml' : return 'Xml' ; case 'gnumeric' : return 'Gnumeric' ; case 'htm' : case 'html' : return 'Html' ; case 'csv' : return null ; default : return null ; } }
6998	protected function prepareRelatedRecord ( $ relationName , array $ relationRecordData , $ index = null ) { $ recordWithBackup = $ relationRecordData ; $ valueViewers = $ this -> getViewersForRelations ( ) ; foreach ( $ relationRecordData as $ columnName => $ value ) { $ viewerName = $ relationName . '.' . ( $ index === null ? '' : $ index . '.' ) . $ columnName ; if ( array_key_exists ( $ viewerName , $ valueViewers ) && $ valueViewers [ $ viewerName ] -> getRelation ( ) -> getName ( ) === $ relationName ) { $ recordWithBackup [ $ columnName ] = $ recordWithBackup [ '__' . $ columnName ] = $ value ; $ valueViewer = $ valueViewers [ $ viewerName ] ; if ( is_object ( $ valueViewer ) && method_exists ( $ valueViewer , 'convertValue' ) && ( ! method_exists ( $ valueViewer , 'isVisible' ) || $ valueViewer -> isVisible ( ) ) ) { $ recordWithBackup [ $ columnName ] = $ valueViewer -> convertValue ( $ recordWithBackup [ $ columnName ] , $ relationRecordData ) ; } } } return $ recordWithBackup ; }
247	public function init ( ) { parent :: init ( ) ; register_shutdown_function ( [ $ this , 'close' ] ) ; if ( $ this -> getIsActive ( ) ) { Yii :: warning ( 'Session is already started' , __METHOD__ ) ; $ this -> updateFlashCounters ( ) ; } }
7161	private function initialize ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> lineNumber = 1 ; $ this -> view = new SaleView ( ) ; $ this -> types = $ this -> registry -> getTypesForSale ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> configureOptions ( $ sale , $ this -> view , $ options ) ; } $ this -> options = $ this -> getOptionsResolver ( ) -> resolve ( $ options ) ; $ this -> view -> setTemplate ( $ this -> options [ 'template' ] ) ; if ( ! is_null ( $ this -> options [ 'ati' ] ) ) { $ this -> view -> setAti ( $ this -> options [ 'ati' ] ) ; } else { $ this -> view -> setAti ( $ sale -> isAtiDisplayMode ( ) ) ; } $ this -> formatter = $ this -> formatterFactory -> create ( $ this -> options [ 'locale' ] , $ sale -> getCurrency ( ) -> getCode ( ) ) ; foreach ( $ this -> types as $ type ) { $ type -> setFormatter ( $ this -> formatter ) ; } }
4005	protected function createInstanceViaLegacyFactory ( CreateMetaModelEvent $ event , $ arrData ) { $ name = $ arrData [ 'tableName' ] ; if ( ! isset ( $ GLOBALS [ 'METAMODELS' ] [ 'factories' ] [ $ name ] ) ) { return false ; } @ trigger_error ( 'Creating MetaModel instances via global factories is deprecated.' , E_USER_DEPRECATED ) ; $ factoryClass = $ GLOBALS [ 'METAMODELS' ] [ 'factories' ] [ $ name ] ; $ event -> setMetaModel ( call_user_func_array ( array ( $ factoryClass , 'createInstance' ) , array ( $ arrData ) ) ) ; return $ event -> getMetaModel ( ) !== null ; }
10788	protected function getSearchFacets ( SessionInterface $ session ) { $ facets = $ session -> get ( $ this -> getSessionPrefix ( ) . '_facets' , false ) ; return $ facets ? \ json_decode ( $ facets , true ) : $ this -> getDefaultFacets ( ) ; }
4323	public static function buildTag ( $ tagName , $ attribs = array ( ) , $ innerhtml = '' ) { $ tagName = \ strtolower ( $ tagName ) ; $ attribStr = self :: buildAttribString ( $ attribs ) ; return \ in_array ( $ tagName , self :: $ htmlEmptyTags ) ? '<' . $ tagName . $ attribStr . ' />' : '<' . $ tagName . $ attribStr . '>' . $ innerhtml . '</' . $ tagName . '>' ; }
10218	private static function cleanComplex ( $ complexNumber ) { if ( $ complexNumber [ 0 ] == '+' ) { $ complexNumber = substr ( $ complexNumber , 1 ) ; } if ( $ complexNumber [ 0 ] == '0' ) { $ complexNumber = substr ( $ complexNumber , 1 ) ; } if ( $ complexNumber [ 0 ] == '.' ) { $ complexNumber = '0' . $ complexNumber ; } if ( $ complexNumber [ 0 ] == '+' ) { $ complexNumber = substr ( $ complexNumber , 1 ) ; } return $ complexNumber ; }
6044	public function view ( $ sessionId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaId' => $ mediaId ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/view' , $ parameters , true ) ; return $ result ; }
2528	protected function getActionFromWsdl ( $ wsdlFilePath , $ messageName ) { $ wsdlId = $ this -> getWsdlIdFor ( $ messageName ) ; return WsdlAnalyser :: exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , sprintf ( self :: XPATH_OPERATION_ACTION , $ messageName ) ) ; }
2144	public function onBadCredentials ( User $ user , AuthenticationException $ exception ) : AuthenticationException { -- $ user -> loginCount ; if ( $ user -> loginCount > 0 ) { $ user -> save ( ) ; return new BadCredentialsException ( sprintf ( 'Invalid password submitted for username "%s"' , $ user -> username ) , $ exception -> getCode ( ) , $ exception ) ; } $ user -> locked = time ( ) + $ this -> options [ 'lock_period' ] ; $ user -> loginCount = $ this -> options [ 'login_attempts' ] ; $ user -> save ( ) ; $ lockedSeconds = $ user -> locked - time ( ) ; $ lockedMinutes = ( int ) ceil ( $ lockedSeconds / 60 ) ; $ exception = new LockedException ( $ lockedSeconds , sprintf ( 'User "%s" has been locked for %s minutes' , $ user -> username , $ lockedMinutes ) , 0 , $ exception ) ; $ exception -> setUser ( $ user ) ; return $ exception ; }
9970	public function setDataValidation ( $ pCellCoordinate , DataValidation $ pDataValidation = null ) { if ( $ pDataValidation === null ) { unset ( $ this -> dataValidationCollection [ $ pCellCoordinate ] ) ; } else { $ this -> dataValidationCollection [ $ pCellCoordinate ] = $ pDataValidation ; } return $ this ; }
5215	private function getAnnotatedBinding ( \ ReflectionClass $ class ) { $ annotations = annotationsOf ( $ class ) ; if ( $ class -> isInterface ( ) && $ annotations -> contain ( 'ImplementedBy' ) ) { return $ this -> bind ( $ class -> getName ( ) ) -> to ( $ this -> findImplementation ( $ annotations , $ class -> getName ( ) ) ) ; } elseif ( $ annotations -> contain ( 'ProvidedBy' ) ) { return $ this -> bind ( $ class -> getName ( ) ) -> toProviderClass ( $ annotations -> firstNamed ( 'ProvidedBy' ) -> getProviderClass ( ) ) ; } return $ this -> getImplicitBinding ( $ class ) ; }
11414	public function decryptData ( $ sessionKey , $ iv , $ encrypted ) { try { $ decrypted = openssl_decrypt ( base64_decode ( $ encrypted , true ) , 'aes-128-cbc' , base64_decode ( $ sessionKey , true ) , OPENSSL_RAW_DATA | OPENSSL_NO_PADDING , base64_decode ( $ iv , true ) ) ; } catch ( Exception $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_DECRYPT_AES ) ; } if ( is_null ( $ result = json_decode ( $ this -> decode ( $ decrypted ) , true ) ) ) { throw new EncryptionException ( 'ILLEGAL_BUFFER' , EncryptionException :: ILLEGAL_BUFFER ) ; } return $ result ; }
1703	protected function getLink ( $ objItem , $ strUrl , $ strBase = '' ) { switch ( $ objItem -> source ) { case 'external' : return $ objItem -> url ; break ; case 'internal' : if ( ( $ objTarget = $ objItem -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { return $ objTarget -> getAbsoluteUrl ( ) ; } break ; case 'article' : if ( ( $ objArticle = ArticleModel :: findByPk ( $ objItem -> articleId ) ) instanceof ArticleModel && ( $ objPid = $ objArticle -> getRelated ( 'pid' ) ) instanceof PageModel ) { return ampersand ( $ objPid -> getAbsoluteUrl ( '/articles/' . ( $ objArticle -> alias ? : $ objArticle -> id ) ) ) ; } break ; } if ( $ strBase != '' && ! preg_match ( '#^https?://#' , $ strUrl ) ) { $ strUrl = $ strBase . $ strUrl ; } return sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItem -> alias ? : $ objItem -> id ) ) ; }
2058	public function makeRedirectPageMandatory ( Contao \ DataContainer $ dc ) { $ objPage = $ this -> Database -> prepare ( "SELECT * FROM " . $ dc -> table . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objPage -> numRows && $ objPage -> type == 'logout' ) { $ GLOBALS [ 'TL_DCA' ] [ 'tl_page' ] [ 'fields' ] [ 'jumpTo' ] [ 'eval' ] [ 'mandatory' ] = true ; } }
12825	protected function getSlotDefinition ( $ dir ) { $ slotsFilename = $ this -> getSlotDefinitionFile ( $ dir ) ; return json_decode ( FilesystemTools :: readFile ( $ slotsFilename ) , true ) ; }
4119	public static function addType ( $ name , $ className ) { if ( isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeExists ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
6112	public function dirCreate ( $ cpw = "" , $ dirname = "/" ) { return $ this -> getParent ( ) -> channelDirCreate ( $ this -> getId ( ) , $ cpw , $ dirname ) ; }
6674	public function restart_when_add ( ) { $ state = isset ( $ _POST [ 'state' ] ) ? $ _POST [ 'state' ] : null ; $ nonce = isset ( $ _POST [ 'nonce' ] ) ? $ _POST [ 'nonce' ] : '' ; if ( ! wp_verify_nonce ( $ nonce , 'eliasis' ) && ! wp_verify_nonce ( $ nonce , 'customRatingGrifusAdmin' ) ) { die ( 'Busted!' ) ; } App :: setCurrentID ( 'EFG' ) ; $ slug = Module :: CustomRatingGrifus ( ) -> getOption ( 'slug' ) ; $ this -> model -> set_restart_when_add ( $ slug , $ state ) ; $ response = [ 'restart-when-add' => $ state ] ; echo json_encode ( $ response ) ; die ( ) ; }
9074	protected function getRouteInformation ( Route $ route ) { return $ this -> filterRoute ( [ 'name' => $ route -> getName ( ) , 'isAuthorized' => $ this -> isAuthorized ( $ route ) , ] ) ; }
226	protected function asCurrencyStringFallback ( $ value , $ currency = null ) { if ( $ currency === null ) { if ( $ this -> currencyCode === null ) { throw new InvalidConfigException ( 'The default currency code for the formatter is not defined.' ) ; } $ currency = $ this -> currencyCode ; } return $ currency . ' ' . $ this -> asDecimalStringFallback ( $ value , 2 ) ; }
7291	private function getByMethodAndStatesFromDateQuery ( ) { if ( null !== $ this -> byMethodAndStatesFromDateQuery ) { return $ this -> byMethodAndStatesFromDateQuery ; } $ qb = $ this -> createQueryBuilder ( 'p' ) ; $ query = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.method' , ':method' ) ) -> andWhere ( $ qb -> expr ( ) -> in ( 'p.state' , ':states' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'p.createdAt' , ':date' ) ) -> addOrderBy ( 'p.createdAt' , 'ASC' ) -> getQuery ( ) -> useQueryCache ( true ) ; return $ this -> byMethodAndStatesFromDateQuery = $ query ; }
11315	public static function getNormalizedParameters ( array $ data ) { $ params = array ( ) ; $ keys = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_keys ( $ data ) ) ; $ values = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_values ( $ data ) ) ; $ data = array_combine ( $ keys , $ values ) ; uksort ( $ data , 'strnatcmp' ) ; foreach ( $ data as $ k => $ v ) { if ( $ k != 'oauth_signature' ) { $ params [ ] = $ k . '=' . $ v ; } } return implode ( '&' , $ params ) ; }
11334	public function getFormattedValue ( ) { if ( $ this -> format instanceof BaseFormat ) { $ formattedValue = $ this -> format -> get ( ) ; } elseif ( is_callable ( $ this -> format ) || ( is_array ( $ this -> format ) && ! empty ( $ this -> format [ 0 ] ) && is_object ( $ this -> format [ 0 ] ) ) ) { $ formattedValue = $ this -> evaluateExpression ( $ this -> format , [ $ this -> value ] ) ; } else { $ formattedValue = $ this -> value ; } if ( is_object ( $ formattedValue ) ) { $ formattedValue = $ formattedValue -> viewLink ; } return $ formattedValue ; }
11412	public function batchTagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_TAG , $ params ] ) ; }
8814	public function post ( $ key = null , $ filter = false ) { if ( is_null ( $ key ) ) { return $ _POST ; } $ value = ( isset ( $ _POST [ $ key ] ) ? $ _POST [ $ key ] : null ) ; return $ this -> filter ( $ value , $ filter ) ; }
6861	public function doDefaultValueConversionByType ( $ value , $ type , array $ record ) { switch ( $ type ) { case static :: TYPE_DATETIME : return date ( static :: FORMAT_DATETIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_DATE : return date ( static :: FORMAT_DATE , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_TIME : return date ( static :: FORMAT_TIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_MULTILINE : return '<pre class="multiline-text">' . $ value . '</pre>' ; case static :: TYPE_JSON : case static :: TYPE_JSONB : if ( ! is_array ( $ value ) && $ value !== null ) { if ( is_string ( $ value ) || is_numeric ( $ value ) || is_bool ( $ value ) ) { $ value = json_decode ( $ value , true ) ; if ( $ value === null && strtolower ( $ value ) !== 'null' ) { $ value = 'Failed to decode JSON: ' . print_r ( $ value , true ) ; } } else { $ value = 'Invalid value for JSON: ' . print_r ( $ value , true ) ; } } return '<pre class="json-text">' . htmlentities ( stripslashes ( json_encode ( $ value , JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE ) ) ) . '</pre>' ; break ; } return $ value ; }
6236	public static function try ( array $ paths ) : Storage { foreach ( $ paths as $ diskpath ) { if ( is_string ( $ diskpath ) ) { if ( file_exists ( $ diskpath ) ) { return new Storage \ Disk ( $ diskpath ) ; } } elseif ( $ diskpath instanceof Path ) { if ( $ diskpath -> fileInfo ( ) -> isFile ( ) || $ diskpath -> fileInfo ( ) -> isDir ( ) ) { return new Storage \ Disk ( $ diskpath ) ; } } elseif ( $ diskpath instanceof Storage ) { if ( $ diskpath -> isFile ( ) || $ diskpath -> isDir ( ) ) { return $ diskpath ; } } elseif ( $ diskpath instanceof FileSystem ) { if ( $ diskpath -> isFile ( ) || $ diskpath -> isDir ( ) ) { return $ diskpath -> storage ( ) ; } } else { throw new UnexpectedValueException ( sprintf ( 'invalid search-path of type \'%s\'' , is_object ( $ diskpath ) ? get_class ( $ diskpath ) : gettype ( $ diskpath ) ) , 500 ) ; } } throw new FileNotFoundException ( 'file not found' , 404 ) ; }
9915	public function render ( $ action = null , $ layout = null ) { $ this -> viewPath .= DS . 'Spreadsheet' ; $ content = parent :: render ( $ action , false ) ; if ( $ this -> response -> type ( ) == 'text/html' ) { return $ content ; } ob_start ( ) ; $ writer = IOFactory :: createWriter ( $ this -> Spreadsheet , CAKE_SPREADSHEET_PHPSPREADSHEET_WRITER ) ; $ writer -> setPreCalculateFormulas ( false ) ; $ writer -> save ( 'php://output' ) ; $ content = ob_get_clean ( ) ; $ this -> Blocks -> set ( 'content' , $ content ) ; $ fileName = $ this -> getFileName ( ) ; $ fileName .= '.' . CAKE_SPREADSHEET_FILE_EXTENSION ; $ this -> response -> download ( $ fileName ) ; return $ this -> Blocks -> get ( 'content' ) ; }
12901	private function addSource ( array $ arguments = array ( ) ) { $ this -> builder -> addSource ( array_key_exists ( 'cache' , $ this -> source ) ? $ this -> createCacheAdapter ( ) : new HttpApiAdapter ( ) , new Request ( array ( 'source' => $ this -> source , 'arguments' => $ arguments , 'service' => $ this -> getGroup ( ) -> getService ( ) -> getName ( ) , 'group' => $ this -> getGroup ( ) -> getName ( ) , 'action' => $ this -> getName ( ) , ) ) ) ; }
12314	public function newAction ( Request $ request ) { $ category = new Category ( ) ; $ form = $ this -> createForm ( 'BlogBundle\Form\CategoryType' , $ category ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ category ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'category.created' ) ; return $ this -> redirectToRoute ( 'blog_category_index' ) ; } return array ( 'category' => $ category , 'form' => $ form -> createView ( ) , ) ; }
8933	private function addDependency ( $ name , $ template ) { $ this -> commands [ ] = strtr ( $ template , [ '$namespace' => $ this -> namespaceRoot , '$name' => $ name ] ) ; }
1116	public function newNestedSetQuery ( $ excludeDeleted = true ) { $ builder = $ this -> newQuery ( $ excludeDeleted ) -> orderBy ( $ this -> getQualifiedOrderColumnName ( ) ) ; if ( $ this -> isScoped ( ) ) { foreach ( $ this -> scoped as $ scopeFld ) $ builder -> where ( $ scopeFld , '=' , $ this -> $ scopeFld ) ; } return $ builder ; }
4160	public function getLoginUrl ( $ scope = array ( ) , $ state = null ) { $ scope = $ this -> mergeScope ( $ scope ) ; $ state = is_string ( $ state ) ? "&state={$state}" : '' ; return self :: API_OAUTH_URL . '?client_id=' . $ this -> getApiKey ( ) . '&redirect_uri=' . urlencode ( $ this -> getApiCallback ( ) ) . '&scope=' . implode ( '+' , $ scope ) . '&response_type=code' . $ state ; }
2785	private function extractFail ( $ output ) { if ( preg_match ( '%##teamcity\[testFailed.*\]%' , $ output , $ matches ) ) { preg_match ( "/##teamcity\\[testFailed.*name='(.*)' message='(.*)' details='\\s*(.*)' flowId=.*/" , $ output , $ matches ) ; $ matches = $ this -> replaceEscapedChars ( $ matches ) ; $ fail = sprintf ( 'Test Name: %s' . PHP_EOL . 'Failure Message: %s' . PHP_EOL . 'Trace:' . PHP_EOL . '%s' , $ matches [ 1 ] , $ matches [ 2 ] , $ matches [ 3 ] ) ; return $ fail ; } return 'No failure output was detected by Humbug, but a failure was reported by PHPUnit.' ; }
5186	private function makeAttachmentObject ( string $ attachmentType , array $ attrReferences , array $ item ) { $ attrValues = [ ] ; foreach ( $ attrReferences as $ attrReference ) { $ attrValues [ $ attrReference ] = $ this -> getValue ( $ attrReference , $ item ) ; } switch ( $ attachmentType ) { case self :: JSON_PHOTO_FIELD : return $ this -> createPhoto ( $ attrValues [ 'photo_url' ] , $ attrValues [ 'photo_ratio' ] , '' , '' ) ; case self :: JSON_PAGE_FIELD : return $ this -> createPage ( $ attrValues [ 'page_title' ] , $ attrValues [ 'page_body' ] , $ attrValues [ 'page_source' ] , $ attrValues [ 'page_order' ] , $ attrValues [ 'page_cover' ] , $ attrValues [ 'page_lead' ] ) ; case self :: JSON_GALLERY_FIELD : return $ this -> createGallery ( $ attrValues [ 'gallery_body' ] , $ attrValues [ 'gallery_order' ] , $ attrValues [ 'gallery_photo' ] , $ attrValues [ 'gallery_source' ] , $ attrValues [ 'gallery_lead' ] ) ; case self :: JSON_VIDEO_FIELD : return $ this -> createVideo ( $ attrValues [ 'video_body' ] , $ attrValues [ 'video_source' ] , $ attrValues [ 'video_order' ] , $ attrValues [ 'video_cover' ] , $ attrValues [ 'video_lead' ] ) ; default : return null ; } }
3458	public function extend ( $ module ) : void { if ( is_object ( $ module ) || class_exists ( $ module ) ) { $ this -> modules [ ] = $ module ; } else { throw ApplicationException :: forInvalidModule ( $ module ) ; } }
10411	public function invalidate ( ) { $ script = escapeshellcmd ( $ this -> rootDir . "/../{$this->cacheScript}" ) ; $ urlsFile = escapeshellarg ( $ this -> createUrlsTempFile ( ) ) ; $ curlTimeout = escapeshellarg ( $ this -> curlTimeout ) ; $ process = new Process ( sprintf ( '%s %s %s' , $ script , $ urlsFile , $ curlTimeout ) ) ; $ process -> start ( ) ; $ this -> resetCache ( ) ; return $ urlsFile ; }
7441	protected function hasAccessToAction ( $ packageKey , $ subpackageKey , $ controllerName , $ actionName ) { $ actionControllerName = $ this -> router -> getControllerObjectName ( $ packageKey , $ subpackageKey , $ controllerName ) ; try { return $ this -> privilegeManager -> isGranted ( 'Neos\Flow\Security\Authorization\Privilege\Method\MethodPrivilege' , new MethodPrivilegeSubject ( new JoinPoint ( NULL , $ actionControllerName , $ actionName . 'Action' , array ( ) ) ) ) ; } catch ( AccessDeniedException $ e ) { return FALSE ; } }
3243	public function getShopUrlAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> shopUrl ; if ( ! property_exists ( $ this , 'itemRouteName' ) && ! property_exists ( $ this , 'itemRouteParams' ) ) return '#' ; $ params = [ ] ; foreach ( array_keys ( $ this -> attributes ) as $ attribute ) { if ( in_array ( $ attribute , $ this -> itemRouteParams ) ) $ params [ $ attribute ] = $ this -> attributes [ $ attribute ] ; } return empty ( $ this -> itemRouteName ) ? '#' : \ route ( $ this -> itemRouteName , $ params ) ; }
5340	public function setBalancingMode ( $ haipName , $ balancingMode , $ cookieName = '' ) { return $ this -> call ( self :: SERVICE , 'setBalancingMode' , [ $ haipName , $ balancingMode , $ cookieName ] ) ; }
4325	public static function getCallerInfo ( $ offset = 0 ) { $ return = array ( 'file' => null , 'line' => null , 'function' => null , 'class' => null , 'type' => null , ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS | DEBUG_BACKTRACE_PROVIDE_OBJECT , 8 ) ; $ numFrames = \ count ( $ backtrace ) ; $ regexInternal = '/^' . \ preg_quote ( __NAMESPACE__ ) . '\b/' ; if ( isset ( $ backtrace [ 1 ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ 1 ] [ 'class' ] ) ) { for ( $ i = $ numFrames - 1 ; $ i >= 0 ; $ i -- ) { if ( isset ( $ backtrace [ $ i ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ $ i ] [ 'class' ] ) ) { break ; } } } else { $ i = 1 ; } $ i += $ offset ; $ iLine = $ i ; $ iFunc = $ i + 1 ; if ( isset ( $ backtrace [ $ iFunc ] ) && \ in_array ( $ backtrace [ $ iFunc ] [ 'function' ] , array ( 'call_user_func' , 'call_user_func_array' ) ) ) { $ iLine ++ ; $ iFunc ++ ; } elseif ( isset ( $ backtrace [ $ iFunc ] [ 'class' ] ) && $ backtrace [ $ iFunc ] [ 'class' ] == 'ReflectionMethod' && $ backtrace [ $ iFunc ] [ 'function' ] == 'invoke' ) { $ iLine ++ ; $ iFunc -- ; } if ( isset ( $ backtrace [ $ iFunc ] ) ) { $ return = \ array_merge ( $ return , \ array_intersect_key ( $ backtrace [ $ iFunc ] , $ return ) ) ; if ( $ return [ 'type' ] == '->' ) { $ return [ 'class' ] = \ get_class ( $ backtrace [ $ iFunc ] [ 'object' ] ) ; } } if ( isset ( $ backtrace [ $ iLine ] ) ) { $ return [ 'file' ] = $ backtrace [ $ iLine ] [ 'file' ] ; $ return [ 'line' ] = $ backtrace [ $ iLine ] [ 'line' ] ; } else { $ return [ 'file' ] = $ backtrace [ $ numFrames - 1 ] [ 'file' ] ; $ return [ 'line' ] = 0 ; } return $ return ; }
8140	public function createTemplate ( $ template ) { $ name = sprintf ( '__string_template__%s' , hash ( 'sha256' , $ template , false ) ) ; $ loader = new Twig_Loader_Chain ( array ( new Twig_Loader_Array ( array ( $ name => $ template ) ) , $ current = $ this -> getLoader ( ) , ) ) ; $ this -> setLoader ( $ loader ) ; try { $ template = $ this -> loadTemplate ( $ name ) ; } catch ( Exception $ e ) { $ this -> setLoader ( $ current ) ; throw $ e ; } catch ( Throwable $ e ) { $ this -> setLoader ( $ current ) ; throw $ e ; } $ this -> setLoader ( $ current ) ; return $ template ; }
3577	protected function metaQuery ( Builder $ query , $ method , ArgumentBag $ args ) { if ( in_array ( $ method , [ 'pluck' , 'value' , 'aggregate' , 'orderBy' , 'lists' ] ) ) { return $ this -> metaJoinQuery ( $ query , $ method , $ args ) ; } return $ this -> metaHasQuery ( $ query , $ method , $ args ) ; }
12112	public function getForeignDataModel ( $ key ) { $ config = $ this -> settings [ 'foreignPullParams' ] ; if ( ! isset ( $ config [ 'where' ] ) ) { $ config [ 'where' ] = [ ] ; } if ( ! empty ( $ config [ 'where' ] ) ) { $ config [ 'where' ] = [ 'and' , $ config [ 'where' ] , [ $ this -> foreignModel -> primaryKey ( ) => $ key ] ] ; } else { $ config [ 'where' ] [ $ this -> foreignModel -> primaryKey ( ) ] = $ key ; } return $ this -> foreignModel -> findOne ( $ config ) ; }
3218	function chunkedUploadFinish ( $ uploadId , $ path , $ writeMode ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Path :: checkArgNonRoot ( "path" , $ path ) ; WriteMode :: checkArg ( "writeMode" , $ writeMode ) ; $ params = array_merge ( array ( "upload_id" => $ uploadId ) , $ writeMode -> getExtraParams ( ) ) ; $ response = $ this -> doPost ( $ this -> contentHost , $ this -> appendFilePath ( "1/commit_chunked_upload" , $ path ) , $ params ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
2546	protected function makeStatusFromErrorQualifier ( $ qualifier , $ defaultStatus = Result :: STATUS_ERROR ) { $ statusQualMapping = [ 'INF' => Result :: STATUS_INFO , 'WEC' => Result :: STATUS_WARN , 'WZZ' => Result :: STATUS_WARN , 'WA' => Result :: STATUS_WARN , 'W' => Result :: STATUS_WARN , 'EC' => Result :: STATUS_ERROR , 'ERR' => Result :: STATUS_ERROR , 'ERC' => Result :: STATUS_ERROR , 'X' => Result :: STATUS_ERROR , '001' => Result :: STATUS_ERROR , 'O' => Result :: STATUS_OK , 'STA' => Result :: STATUS_OK , 'ZZZ' => Result :: STATUS_UNKNOWN ] ; if ( array_key_exists ( $ qualifier , $ statusQualMapping ) ) { $ status = $ statusQualMapping [ $ qualifier ] ; } elseif ( is_null ( $ qualifier ) ) { $ status = $ defaultStatus ; } else { $ status = Result :: STATUS_UNKNOWN ; } return $ status ; }
8985	public function isComparable ( TableNode $ expected , TableNode $ actual , array $ diff_options , $ message = NULL ) { $ this -> doAssert ( 'Failed comparing two tables: ' , $ diff_options , $ expected , $ actual , $ message ) ; }
9601	public function add ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; $ bComponents = $ b -> components ( ) ; $ sum = [ ] ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ sum [ $ i ] = $ component + $ bComponents [ $ i ] ; } return new static ( $ sum ) ; }
10009	public function createSheet ( $ sheetIndex = null ) { $ newSheet = new Worksheet ( $ this ) ; $ this -> addSheet ( $ newSheet , $ sheetIndex ) ; return $ newSheet ; }
10973	public static function getAuthPassword ( ) { $ result = null ; if ( isset ( $ _SERVER [ 'PHP_AUTH_PW' ] ) ) { $ result = $ _SERVER [ 'PHP_AUTH_PW' ] ; } if ( trim ( $ result ) == '' ) { $ result = null ; } return $ result ; }
3504	private function createByReason ( string $ reason , array $ json ) : SendNotificationException { $ reason = strtolower ( $ reason ) ; switch ( $ reason ) { case 'badcollapseid' : return new BadCollapseIdException ( ) ; case 'baddevicetoken' : return new BadDeviceTokenException ( ) ; case 'badexpirationdate' : return new BadExpirationDateException ( ) ; case 'badmessageid' : return new BadMessageIdException ( ) ; case 'badpriority' : return new BadPriorityException ( ) ; case 'badtopic' : return new BadTopicException ( ) ; case 'devicetokennotfortopic' : return new DeviceTokenNotForTopicException ( ) ; case 'duplicateheaders' : return new DuplicateHeadersException ( ) ; case 'idletimeout' : return new IdleTimeoutException ( ) ; case 'missingdevicetoken' : return new MissingDeviceTokenException ( ) ; case 'missingtopic' : return new MissingTopicException ( ) ; case 'payloadempty' : return new PayloadEmptyException ( ) ; case 'topicdisallowed' : return new TopicDisallowedException ( ) ; case 'badcertificate' : return new BadCertificateException ( ) ; case 'badcertificateenvironment' : return new BadCertificateEnvironmentException ( ) ; case 'expiredprovidertoken' : return new ExpiredProviderTokenException ( ) ; case 'forbidden' : return new ForbiddenException ( ) ; case 'invalidprovidertoken' : return new InvalidProviderTokenException ( ) ; case 'missingprovidertoken' : return new MissingProviderTokenException ( ) ; case 'badpath' : return new BadPathException ( ) ; case 'methodnotallowed' : return new MethodNotAllowedException ( ) ; case 'unregistered' : $ timestamp = array_key_exists ( 'timestamp' , $ json ) ? $ json [ 'timestamp' ] : 0 ; $ lastConfirmed = new \ DateTime ( 'now' , new \ DateTimeZone ( 'UTC' ) ) ; $ lastConfirmed -> setTimestamp ( $ timestamp ) ; return new UnregisteredException ( $ lastConfirmed ) ; case 'payloadtoolarge' : return new PayloadTooLargeException ( ) ; case 'toomanyprovidertokenupdates' : return new TooManyProviderTokenUpdatesException ( ) ; case 'toomanyrequests' : return new TooManyRequestsException ( ) ; case 'internalservererror' : return new InternalServerErrorException ( ) ; case 'serviceunavailable' : return new ServiceUnavailableException ( ) ; case 'shutdown' : return new ShutdownException ( ) ; default : return new UndefinedErrorException ( ) ; } }
4633	protected function getHeader ( $ key ) { return isset ( $ this -> headers [ $ key ] ) ? $ this -> headers [ $ key ] : NULL ; }
7770	public function errors ( ) { $ messages = [ ] ; foreach ( $ this -> errors as $ rule => $ items ) { foreach ( $ items as $ item ) { $ field = $ item [ 'field' ] ; $ message = $ this -> fetchMessage ( $ field , $ rule ) ; if ( isset ( $ this -> fieldAliases [ $ field ] ) ) { $ item [ 'field' ] = $ this -> fieldAliases [ $ field ] ; } $ messages [ $ field ] [ ] = $ this -> replaceMessageFormat ( $ message , $ item ) ; } } return new MessageBag ( $ messages ) ; }
9663	public static function registerWriter ( $ writerType , $ writerClass ) { if ( ! is_a ( $ writerClass , Writer \ IWriter :: class , true ) ) { throw new Writer \ Exception ( 'Registered writers must implement ' . Writer \ IWriter :: class ) ; } self :: $ writers [ $ writerType ] = $ writerClass ; }
7565	protected function parse_callback ( $ conditions , $ recursive = true , $ check_root = false ) { return ( $ this -> result = $ this -> root -> getChildrenByMatch ( $ conditions , $ recursive , $ check_root , $ this -> custom_filter_map ) ) ; }
6668	public function respond ( ) { if ( is_null ( $ this -> preparedResponse ) ) { $ this -> prepareResponse ( ) ; } if ( $ this -> status instanceof Status ) { header ( $ this -> status -> getHttpHeader ( ) ) ; } header ( "Content-Type: {$this->writer->getContentType()}" ) ; echo $ this -> preparedResponse ; return $ this ; }
7575	public function getCustomFields ( $ parameters = array ( ) ) { $ this -> _harvest = $ this -> _harvestHelper -> parse ( 'getCustomFields' , $ parameters ) ; if ( ! array_key_exists ( 'id' , $ parameters ) ) $ this -> _harvest [ 'url' ] = $ this -> _harvest [ 'url' ] . '/' ; $ this -> sendRequest ( ) ; }
11495	public function showAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "page_collection_manager" => $ app [ "red_kite_cms.page_collection_manager" ] , 'form_factory' => $ app [ "form.factory" ] , "pages_collection_parser" => $ app [ "red_kite_cms.pages_collection_parser" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , 'theme' => $ app [ "red_kite_cms.theme" ] , 'template_assets' => $ app [ "red_kite_cms.template_assets" ] , 'twig' => $ app [ "twig" ] , ) ; return parent :: show ( $ options ) ; }
10371	public static function add_scripts ( ) { self :: look_if_process_files ( 'script' ) ; foreach ( self :: $ data [ 'script' ] as $ data ) { $ params = [ 'plugin_url' => defined ( 'WP_PLUGIN_URL' ) ? WP_PLUGIN_URL . '/' : '' , 'nonce' => wp_create_nonce ( $ data [ 'name' ] ) , ] ; $ data [ 'params' ] = array_merge ( $ data [ 'params' ] , $ params ) ; wp_register_script ( $ data [ 'name' ] , $ data [ 'url' ] , $ data [ 'deps' ] , $ data [ 'version' ] , $ data [ 'footer' ] ) ; wp_enqueue_script ( $ data [ 'name' ] ) ; wp_localize_script ( $ data [ 'name' ] , $ data [ 'name' ] , $ data [ 'params' ] ) ; } }
2601	public function getLiteral ( $ token ) { $ className = get_class ( $ this ) ; $ reflClass = new \ ReflectionClass ( $ className ) ; $ constants = $ reflClass -> getConstants ( ) ; foreach ( $ constants as $ name => $ value ) { if ( $ value === $ token ) { return $ className . '::' . $ name ; } } return $ token ; }
10829	public static function dir ( string $ path ) : fs \ entity \ DirEntity { return ( new fs \ entity \ DirEntity ( $ path ) ) -> normalize ( ) ; }
35	protected function printVersions ( CompletePackageInterface $ package , array $ versions , RepositoryInterface $ installedRepo ) { uasort ( $ versions , 'version_compare' ) ; $ versions = array_keys ( array_reverse ( $ versions ) ) ; if ( $ installedRepo -> hasPackage ( $ package ) ) { $ installedVersion = $ package -> getPrettyVersion ( ) ; $ key = array_search ( $ installedVersion , $ versions ) ; if ( false !== $ key ) { $ versions [ $ key ] = '<info>* ' . $ installedVersion . '</info>' ; } } $ versions = implode ( ', ' , $ versions ) ; $ this -> getIO ( ) -> write ( '<info>versions</info> : ' . $ versions ) ; }
3146	public function resume ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> resume ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'resume' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
7107	static public function round ( $ amount , $ currency ) { $ precision = static :: getPrecision ( $ currency ) ; $ roundingIncrement = static :: getRoundingIncrement ( $ currency ) ; $ amount = round ( $ amount , $ precision , \ PHP_ROUND_HALF_EVEN ) ; if ( 0 < $ roundingIncrement && 0 < $ precision ) { $ roundingFactor = $ roundingIncrement / pow ( 10 , $ precision ) ; $ amount = round ( $ amount / $ roundingFactor ) * $ roundingFactor ; } return $ amount ; }
4588	public function setMaxResults ( ? int $ maxResults ) { $ this -> maxResults = $ maxResults ; $ this -> _maxResults = null !== $ maxResults ; return $ this ; }
11685	public function getCachePath ( ) { if ( empty ( $ this -> basePath ) ) { return false ; } $ cachePath = $ this -> basePath . DIRECTORY_SEPARATOR . 'cache' ; if ( ! is_dir ( $ cachePath ) ) { @ mkdir ( $ cachePath , 0777 , true ) ; } if ( ! is_dir ( $ cachePath ) ) { return false ; } return $ cachePath ; }
4470	public function complete ( ? string $ nextq = null , int $ delay = 0 , array $ depends = [ ] ) : string { if ( $ this -> completed || $ this -> failed ) { throw new JobAlreadyFinishedException ( ) ; } $ params = [ $ this -> jid , $ this -> worker , $ this -> queue , json_encode ( $ this -> data , JSON_UNESCAPED_SLASHES ) ? : '{}' ] ; if ( $ nextq ) { $ next = [ 'next' , $ nextq , 'delay' , $ delay , 'depends' , json_encode ( $ depends , JSON_UNESCAPED_SLASHES ) ] ; $ params = array_merge ( $ params , $ next ) ; } $ this -> completed = true ; return call_user_func_array ( [ $ this -> client , 'complete' ] , $ params ) ; }
2659	public function createRequest ( $ version , $ request ) { $ checkIfExists = $ this -> getRequest ( $ version , $ request [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ request [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ request ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create the REQUEST object.' ) ) ; } }
11080	public static function getDayName ( $ day ) { if ( $ day < self :: DOW_MONDAY || $ day > self :: DOW_SUNDAY ) { return '' ; } $ dayNames = [ self :: DOW_MONDAY => self :: poorManTranslate ( 'fts-shared' , 'Monday' ) , self :: DOW_TUESDAY => self :: poorManTranslate ( 'fts-shared' , 'Tuesday' ) , self :: DOW_WEDNESDAY => self :: poorManTranslate ( 'fts-shared' , 'Wednesday' ) , self :: DOW_THURSDAY => self :: poorManTranslate ( 'fts-shared' , 'Thursday' ) , self :: DOW_FRIDAY => self :: poorManTranslate ( 'fts-shared' , 'Friday' ) , self :: DOW_SATURDAY => self :: poorManTranslate ( 'fts-shared' , 'Saturday' ) , self :: DOW_SUNDAY => self :: poorManTranslate ( 'fts-shared' , 'Sunday' ) , ] ; return $ dayNames [ $ day ] ; }
7922	private function isValidPath ( $ path ) { $ pathParts = explode ( '/' , $ path ) ; if ( ! strncmp ( $ path , '/' , 1 ) || array_search ( '..' , $ pathParts ) !== false || strpos ( $ path , ':' ) !== false ) { return false ; } return true ; }
46	public function dispatchInstallerEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations = array ( ) ) { return $ this -> doDispatch ( new InstallerEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations ) ) ; }
11757	public function delete ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_COMMENT , $ params ] ) ; }
978	protected function validateShop ( Request $ request ) { $ shopParam = ShopifyApp :: sanitizeShopDomain ( $ request -> get ( 'shop' ) ) ; $ shop = ShopifyApp :: shop ( $ shopParam ) ; $ session = new ShopSession ( $ shop ) ; if ( $ shop === null || $ shop -> trashed ( ) || empty ( $ session -> getToken ( true ) ) || ( $ shopParam && $ shopParam !== $ shop -> shopify_domain ) === true ) { $ session -> forget ( ) ; Session :: put ( 'return_to' , $ request -> fullUrl ( ) ) ; return Redirect :: route ( 'authenticate' , [ 'shop' => $ shopParam ] ) ; } return true ; }
1588	public function getMeta ( ) { $ meta = $ this -> hasMeta ( ) ? $ this -> get ( DocumentInterface :: KEYWORD_META ) : new StandardObject ( ) ; if ( ! is_null ( $ meta ) && ! $ meta instanceof StandardObjectInterface ) { throw new RuntimeException ( 'Data member is not an object.' ) ; } return $ meta ; }
5661	private function attributes ( $ node ) { if ( ! preg_match ( '|<[^ ]+\s(.*?)/?>|s' , $ node -> value , $ first_tag_contents ) ) { return array ( ) ; } $ attributes = array ( ) ; preg_match_all ( '/\S+\s*=\s*\'[^\']*\'|(\S+\s*=\s*"[^"]*")|([^ =]+\s*=\s*[^ "\']+?)|[^ "\']+/' , $ first_tag_contents [ 1 ] , $ matches ) ; foreach ( $ matches [ 0 ] as $ unparsed ) { $ attributes = $ this -> mergeAttribute ( $ attributes , $ unparsed ) ; } return $ attributes ; }
6992	static protected function getCacheKeyForOptimizedUiTemplatesBasedOnUserId ( $ group ) : string { if ( static :: getAuthModule ( ) -> getAccessPolicyClassName ( ) === CmfAccessPolicy :: class ) { $ userId = 'any' ; } else { $ user = static :: getUser ( ) ; $ userId = $ user ? $ user -> getAuthIdentifier ( ) : 'not_authenticated' ; } return static :: url_prefix ( ) . '_templates_' . static :: getShortLocale ( ) . '_' . $ group . '_user_' . $ userId ; }
39	protected function generatePackageTree ( PackageInterface $ package , RepositoryInterface $ installedRepo , RepositoryInterface $ distantRepos ) { $ requires = $ package -> getRequires ( ) ; ksort ( $ requires ) ; $ children = array ( ) ; foreach ( $ requires as $ requireName => $ require ) { $ packagesInTree = array ( $ package -> getName ( ) , $ requireName ) ; $ treeChildDesc = array ( 'name' => $ requireName , 'version' => $ require -> getPrettyConstraint ( ) , ) ; $ deepChildren = $ this -> addTree ( $ requireName , $ require , $ installedRepo , $ distantRepos , $ packagesInTree ) ; if ( $ deepChildren ) { $ treeChildDesc [ 'requires' ] = $ deepChildren ; } $ children [ ] = $ treeChildDesc ; } $ tree = array ( 'name' => $ package -> getPrettyName ( ) , 'version' => $ package -> getPrettyVersion ( ) , 'description' => $ package -> getDescription ( ) , ) ; if ( $ children ) { $ tree [ 'requires' ] = $ children ; } return $ tree ; }
5325	protected function lockExecute ( callable $ task ) { if ( $ this -> mutex -> isAcquired ( ) ) { return $ task ( ) ; } return $ this -> mutex -> lockExecute ( $ task ) ; }
12315	public function sortAction ( Request $ request ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; if ( $ request -> isXmlHttpRequest ( ) ) { $ this -> get ( 'admin_manager' ) -> sort ( 'BlogBundle:Category' , $ request -> get ( 'values' ) ) ; return new Response ( 0 , 200 ) ; } $ categories = $ em -> getRepository ( 'BlogBundle:Category' ) -> findBy ( array ( 'parentCategory' => NULL ) , array ( 'order' => 'asc' ) ) ; return array ( 'categories' => $ categories ) ; }
12925	public function setSearch ( $ value ) { if ( ! is_object ( $ value ) ) { if ( ! isset ( $ value [ 'class' ] ) ) { $ value [ 'class' ] = $ this -> searchClass ; } $ value = Yii :: createObject ( $ value ) ; } $ value -> dataSource = $ this ; $ this -> _search = $ value ; }
5222	public function hasProperty ( $ name ) { if ( $ this -> properties -> containValue ( $ this -> environment , $ name ) ) { return true ; } return $ this -> properties -> containValue ( 'config' , $ name ) ; }
3875	public function addPages ( $ pages , $ rootPage = null , $ fromSiteMap = false , $ language = null ) { $ this -> foundPages = $ pages ; unset ( $ pages ) ; foreach ( $ this -> getConfigs ( ) as $ config ) { if ( ! $ config [ 'published' ] ) { continue ; } $ this -> getMetaModelsPages ( $ config , $ rootPage , $ language ) ; } asort ( $ this -> foundPages ) ; return $ this -> foundPages ; }
3041	public function persist ( $ userId = null , $ callId = null ) { if ( $ userId && $ callId ) { $ keys = [ $ this -> getCacheKey ( $ userId , $ callId ) ] ; } else { $ keys = array_keys ( $ this -> cache ) ; } $ success = true ; foreach ( $ keys as $ key ) { if ( ! $ this -> persistCacheEntry ( $ key ) ) { $ success = false ; } } return $ success ; }
142	public function getInstallPath ( PackageInterface $ package ) { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; return $ installer -> getInstallPath ( $ package ) ; }
5410	public function close ( ) { if ( ! $ this -> is_open ) { return false ; } $ this -> is_open = false ; return fclose ( $ this -> handle ) ; }
3970	protected function attributeIdToName ( IMetaModel $ metaModel , $ attributeId ) { if ( null === $ attribute = $ metaModel -> getAttributeById ( $ attributeId ) ) { throw new \ RuntimeException ( sprintf ( 'Could not retrieve attribute %s from MetaModel %s.' , $ attributeId , $ metaModel -> getTableName ( ) ) ) ; } return $ attribute -> getColName ( ) ; }
5061	public function calculateWidth ( $ text , $ size = self :: TEXT_SIZE ) { $ size = $ this -> convertToPt ( $ size ) ; $ box = imagettfbbox ( $ size , 0 , $ this -> fontPath , $ text ) ; return round ( abs ( $ box [ 2 ] - $ box [ 0 ] ) + self :: SHIELD_PADDING_EXTERNAL + self :: SHIELD_PADDING_INTERNAL , 1 ) ; }
4970	public function process ( array $ event ) { $ event = parent :: process ( $ event ) ; $ event [ 'uniqueId' ] = substr ( $ event [ 'extra' ] [ 'requestId' ] , 0 , 7 ) ; unset ( $ event [ 'extra' ] [ 'requestId' ] ) ; return $ event ; }
3029	public function setToken ( $ token , $ secret ) { $ this -> token = new \ Eher \ OAuth \ Token ( $ token , $ secret ) ; }
7955	public function setUnblockSpam ( $ ipblock , $ ipv4 ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ipv4 ) throw new BadMethodCallException ( 'Parameter $ipv4 is missing.' ) ; try { $ r = $ this -> post ( 'ip/' . urlencode ( $ ipblock ) . '/spam/' . $ ipv4 . '/unblock' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
4139	protected function getOauthParameters ( ) { $ time = time ( ) ; return array ( 'oauth_consumer_key' => $ this -> getConsumerKey ( ) , 'oauth_nonce' => trim ( base64_encode ( $ time ) , '=' ) , 'oauth_signature_method' => 'HMAC-SHA1' , 'oauth_timestamp' => $ time , 'oauth_token' => $ this -> getAccessToken ( ) , 'oauth_version' => '1.0' ) ; }
8816	public function put ( $ key = null , $ filter = true ) { parse_str ( file_get_contents ( "php://input" ) , $ _PUT ) ; if ( $ key == null ) { return $ _PUT ; } return $ this -> filter ( $ _PUT [ $ key ] , $ filter ) ; }
1604	public function onException ( ExceptionEvent $ event ) { $ exception = $ event -> exception ; $ craft = \ Craft :: $ app ; if ( ! ( $ exception instanceof HttpException ) || $ exception -> statusCode !== 404 ) return ; $ path = $ craft -> request -> getFullPath ( ) ; $ query = $ craft -> request -> getQueryStringWithoutPath ( ) ; if ( $ query ) $ path .= '?' . $ query ; if ( $ redirect = $ this -> findRedirectByPath ( $ path ) ) { $ event -> handled = true ; $ craft -> response -> redirect ( $ redirect [ 'to' ] , $ redirect [ 'type' ] ) -> send ( ) ; $ craft -> end ( ) ; } }
9203	public function get ( $ endpoint , $ params = null ) { $ endpoint = $ this -> prependVersionToEndpoint ( $ endpoint , Config :: get ( 'api_version' ) ) ; $ options = $ this -> constructRequestOptions ( $ params ) ; $ response = $ this -> guzzleClient -> get ( $ endpoint , $ options ) ; return $ response ; }
8216	private function getNextJob ( $ tube , $ state ) { if ( 'ready' == $ this -> state ) { return $ this -> reserveJob ( $ tube ) ; } return $ this -> peekJob ( $ tube , $ state ) ; }
2993	public function initSMTP ( ) { $ f3 = \ Base :: instance ( ) ; $ this -> smtp = new \ SMTP ( $ f3 -> get ( 'mailer.smtp.host' ) , $ f3 -> get ( 'mailer.smtp.port' ) , $ f3 -> get ( 'mailer.smtp.scheme' ) , $ f3 -> get ( 'mailer.smtp.user' ) , $ f3 -> get ( 'mailer.smtp.pw' ) ) ; if ( ! $ f3 -> devoid ( 'mailer.errors_to' , $ errors_to ) ) $ this -> setErrors ( $ errors_to ) ; if ( ! $ f3 -> devoid ( 'mailer.reply_to' , $ reply_to ) ) $ this -> setReply ( $ reply_to ) ; if ( ! $ f3 -> devoid ( 'mailer.from_mail' , $ from_mail ) ) { if ( $ f3 -> devoid ( 'mailer.from_name' , $ from_name ) ) $ from_name = NULL ; $ this -> setFrom ( $ from_mail , $ from_name ) ; } }
5916	public function resetPassword ( $ hash , $ password ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'hash' => $ hash , 'password' => $ password ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/resetpassword' , $ parameters ) ; return $ result ; }
3521	public static function login ( $ email , $ password , $ challenge = '' , $ code = '' ) { $ requestParams = [ 'includePerms' => 'false' , 'token_type' => 'eg1' ] ; if ( empty ( $ challenge ) && empty ( $ code ) ) { $ requestParams = array_merge ( $ requestParams , [ 'grant_type' => 'password' , 'username' => $ email , 'password' => $ password , ] ) ; } else { $ requestParams = array_merge ( $ requestParams , [ 'grant_type' => 'otp' , 'otp' => $ code , 'challenge' => $ challenge , ] ) ; } $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , $ requestParams ) ; if ( ! isset ( $ data -> access_token ) ) { if ( $ data -> errorCode === 'errors.com.epicgames.common.two_factor_authentication.required' ) { throw new TwoFactorAuthRequiredException ( $ data -> challenge ) ; } throw new \ Exception ( $ data -> errorMessage ) ; } $ data = FortniteClient :: sendUnrealClientGetRequest ( FortniteClient :: EPIC_OAUTH_EXCHANGE_ENDPOINT , $ data -> access_token , true ) ; if ( ! isset ( $ data -> code ) ) { throw new \ Exception ( $ data -> errorMessage ) ; } $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , [ 'grant_type' => 'exchange_code' , 'exchange_code' => $ data -> code , 'includePerms' => false , 'token_type' => 'eg1' ] , FortniteClient :: FORTNITE_AUTHORIZATION ) ; if ( ! isset ( $ data -> access_token ) ) { throw new \ Exception ( $ data -> errorMessage ) ; } return new self ( $ data -> access_token , $ data -> in_app_id , $ data -> refresh_token , $ data -> account_id , $ data -> expires_in ) ; }
1991	protected function getLoginStatus ( $ strCookie ) { @ trigger_error ( 'Using Frontend::getLoginStatus() has been deprecated and will no longer work in Contao 5.0. Use Symfony security instead.' , E_USER_DEPRECATED ) ; $ objTokenChecker = System :: getContainer ( ) -> get ( 'contao.security.token_checker' ) ; if ( $ strCookie == 'BE_USER_AUTH' && $ objTokenChecker -> hasBackendUser ( ) ) { if ( TL_MODE == 'FE' && ! $ objTokenChecker -> isPreviewMode ( ) ) { return false ; } return true ; } if ( $ strCookie == 'FE_USER_AUTH' && $ objTokenChecker -> hasFrontendUser ( ) ) { return true ; } return false ; }
1423	protected function with ( $ query , EncodingParametersInterface $ parameters ) { $ query -> with ( $ this -> getRelationshipPaths ( ( array ) $ parameters -> getIncludePaths ( ) ) ) ; }
11615	public function delete ( $ account ) { $ accessTokenField = sprintf ( '%s=%s' , $ this -> accessToken -> getQueryName ( ) , $ this -> accessToken -> getToken ( ) ) ; $ url = sprintf ( self :: API_DELETE . '?%s&kf_account=%s' , $ accessTokenField , $ account ) ; $ contents = $ this -> getHttp ( ) -> parseJSON ( file_get_contents ( $ url ) ) ; $ this -> checkAndThrow ( $ contents ) ; return new Collection ( $ contents ) ; }
6686	public function showFlashMessages ( $ sticky = false ) { $ timeout = $ sticky ? 0 : 5000 ; $ flashMessages = [ ] ; $ allMessages = $ this -> getSession ( ) -> getAllFlashes ( ) ; foreach ( $ allMessages as $ key => $ message ) { if ( is_array ( $ message ) ) { $ message = $ this -> mergeFlashMessages ( $ message ) ; } $ flashMessages [ ] = [ 'message' => $ message , 'type' => $ key , 'timeout' => $ timeout ] ; } $ this -> getSession ( ) -> removeAllFlashes ( ) ; return Html :: script ( 'var notifications =' . json_encode ( $ flashMessages ) ) ; }
9922	private function defineManyToManyRelation ( Model $ model1 , Model $ model2 ) { $ this -> relations [ $ model1 -> getName ( ) ] [ ] = new Relation ( $ model1 , $ model2 , Relation :: HAS_AND_BELONGS_TO ) ; $ this -> relations [ $ model2 -> getName ( ) ] [ ] = new Relation ( $ model2 , $ model1 , Relation :: HAS_AND_BELONGS_TO ) ; }
9252	protected function initializeContainer ( ) { $ this -> registerDefaultExtensions ( ) ; $ initializer = $ this -> getContainerInitializer ( ) ; $ this -> container = $ initializer -> initializeContainer ( $ this , $ this -> extensions , $ this -> compilerPasses ) ; $ this -> container -> set ( 'app' , $ this ) ; return $ this -> container ; }
11506	public function offsetSet ( $ slot , $ connection ) { if ( ! static :: isValid ( $ slot ) ) { throw new \ OutOfBoundsException ( "Invalid slot $slot for `$connection`" ) ; } $ this -> slots [ ( int ) $ slot ] = ( string ) $ connection ; }
6915	public function addAttachment ( AttachmentInterface $ attachment ) { if ( ! $ this -> attachments -> contains ( $ attachment ) ) { $ this -> attachments -> add ( $ attachment ) ; } return $ this ; }
725	public function render ( $ view , $ params = [ ] ) { $ content = $ this -> getView ( ) -> render ( $ view , $ params , $ this ) ; return $ this -> renderContent ( $ content ) ; }
1248	private static function getHomeDir ( ) { if ( $ homeDir = getenv ( 'HOME' ) ) { return $ homeDir ; } $ homeDrive = getenv ( 'HOMEDRIVE' ) ; $ homePath = getenv ( 'HOMEPATH' ) ; return ( $ homeDrive && $ homePath ) ? $ homeDrive . $ homePath : null ; }
11246	public function getMigrations ( int $ steps ) : array { $ sql = "select migration from {$this->table} where batch >= 1 order by batch, migration desc limit ?" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> bindParam ( 1 , $ steps , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
4661	public function send ( ) { $ eventManager = $ this -> getManager ( ) -> getEventsManager ( ) ; if ( $ eventManager ) { $ result = $ eventManager -> fire ( 'mailer:beforeSend' , $ this ) ; } else { $ result = true ; } if ( $ result === false ) { return false ; } $ this -> failedRecipients = [ ] ; $ queue = $ this -> getManager ( ) -> getQueue ( ) ; if ( $ this -> auth ) { $ queue -> putInTube ( $ this -> queueName , [ 'message' => $ this -> getMessage ( ) , 'auth' => $ this -> smtp , ] ) ; } else { $ queue -> putInTube ( $ this -> queueName , $ this -> getMessage ( ) ) ; } }
12589	protected function sendEmails ( ContactInquiry $ inquiry ) { $ recipients = $ this -> container -> getParameter ( 'c33s_contact_form.email.recipients' ) ; if ( $ this -> container -> getParameter ( 'c33s_contact_form.email.send_copy_to_user' ) && $ inquiry -> hasSenderEmail ( ) ) { $ recipients [ ] = $ inquiry -> getSenderEmail ( ) ; } if ( empty ( $ recipients ) ) { return ; } $ translator = $ this -> get ( 'translator' ) ; $ subject = $ this -> container -> getParameter ( 'c33s_contact_form.email.subject' ) ; $ message = \ Swift_Message :: newInstance ( ) -> setSubject ( $ translator -> trans ( $ subject , array ( ) , 'C33sContactForm' ) ) -> setFrom ( $ this -> container -> getParameter ( 'c33s_contact_form.email.sender_email' ) ) -> setTo ( $ recipients ) -> setBody ( $ this -> renderView ( 'C33sContactFormBundle:ContactForm:email.txt.twig' , array ( 'inquiry' => $ inquiry ) ) ) ; $ this -> get ( 'mailer' ) -> send ( $ message ) ; }
6151	public function redirect ( string $ url ) : object { $ this -> addHeader ( "Location: " . $ url ) ; $ this -> body = null ; return $ this ; }
1240	private static function propertyToXml ( $ name , $ value ) { if ( is_subclass_of ( $ value , '\DTS\eBaySDK\Types\BaseType' , false ) ) { return $ value -> toXml ( $ name ) ; } else { return sprintf ( '<%s>%s</%s>' , $ name , self :: encodeValueXml ( $ value ) , $ name ) ; } }
6376	public function sorted ( Comparator $ comparator ) : FluentIterable { $ array = $ this -> toArray ( ) ; Arrays :: sort ( $ array , $ comparator ) ; return self :: of ( $ array ) ; }
11894	public function encrypt ( $ data ) { if ( $ this -> iv === null ) { $ dataEncrypted = mcrypt_encrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode ) ; } else { $ dataEncrypted = mcrypt_encrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode , $ this -> iv ) ; } return bin2hex ( $ dataEncrypted ) ; }
8187	public function hasBlock ( $ name , array $ context = null , array $ blocks = array ( ) ) { if ( null === $ context ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is internal and should never be called; calling it directly is deprecated since version 1.28 and won\'t be possible anymore in 2.0.' , E_USER_DEPRECATED ) ; return isset ( $ this -> blocks [ ( string ) $ name ] ) ; } if ( isset ( $ blocks [ $ name ] ) ) { return $ blocks [ $ name ] [ 0 ] instanceof self ; } if ( isset ( $ this -> blocks [ $ name ] ) ) { return true ; } if ( false !== $ parent = $ this -> getParent ( $ context ) ) { return $ parent -> hasBlock ( $ name , $ context ) ; } return false ; }
9785	public function parseFor ( ) { $ for_open_token = $ this -> pop ( 'FOR_OPEN' ) ; $ this -> currLine ++ ; $ output = '$for_index = 0; foreach(' . $ for_open_token [ 1 ] [ 1 ] . ' as ' . $ for_open_token [ 1 ] [ 0 ] . ') {' . "\n" ; while ( true ) { list ( $ type , $ value ) = $ this -> peek ( ) ; if ( $ type == 'FOR_CLOSE' ) { $ this -> pop ( ) ; $ output .= '$for_index++; }' . "\n" ; $ this -> currLine ++ ; break ; } else { $ output .= $ this -> parseExpression ( ) ; } } return $ output ; }
5050	public function trigger ( $ eventName , $ target = null , $ argv = [ ] ) { $ event = $ eventName instanceof EventInterface ? $ eventName : $ this -> getEvent ( $ eventName , $ target , $ argv ) ; return $ this -> triggerListeners ( $ event ) ; }
9238	private function getTextualPath ( array $ path , Vertex $ startVertex ) { $ currentVertex = $ startVertex ; $ currentTable = $ currentVertex -> getId ( ) ; $ textPath = $ currentTable ; foreach ( $ path as $ edge ) { if ( $ fk = $ edge -> getAttribute ( 'fk' ) ) { if ( $ fk -> getForeignTableName ( ) == $ currentTable ) { $ currentTable = $ fk -> getLocalTable ( ) -> getName ( ) ; $ isForward = false ; } else { $ currentTable = $ fk -> getForeignTableName ( ) ; $ isForward = true ; } $ columns = implode ( ',' , $ fk -> getLocalColumns ( ) ) ; $ textPath .= ' ' . ( ! $ isForward ? '<' : '' ) ; $ textPath .= '--(' . $ columns . ')--' ; $ textPath .= ( $ isForward ? '>' : '' ) . ' ' ; $ textPath .= $ currentTable ; } elseif ( $ junctionTable = $ edge -> getAttribute ( 'junction' ) ) { $ junctionFks = array_values ( $ junctionTable -> getForeignKeys ( ) ) ; $ fk = $ junctionFks [ 0 ] ; if ( $ fk -> getForeignTableName ( ) == $ currentTable ) { $ currentTable = $ junctionFks [ 1 ] -> getForeignTableName ( ) ; } else { $ currentTable = $ fk -> getForeignTableName ( ) ; } $ textPath .= ' <=(' . $ junctionTable -> getName ( ) . ')=> ' . $ currentTable ; } else { throw new SchemaAnalyzerException ( 'Unexpected edge. We should have a fk or a junction attribute.' ) ; } } return $ textPath ; }
6221	public function setHttpClient ( $ httpClient ) { if ( is_null ( $ httpClient ) ) { $ httpClient = new Curl ; $ threeScaleVersion = new ThreeScaleVersion ( ) ; $ version = $ threeScaleVersion -> getVersion ( ) ; $ httpClient -> options [ 'CURLOPT_FOLLOWLOCATION' ] = false ; $ httpClient -> headers [ 'X-3scale-User-Agent' ] = 'plugin-php-v' . $ version ; } $ this -> httpClient = $ httpClient ; }
2720	public function execute ( ) { $ resultLayout = null ; try { $ resultLayout = $ this -> resultLayoutFactory -> create ( ) ; $ resultLayout -> addDefaultHandle ( ) ; $ countryCode = $ this -> getRequest ( ) -> getParam ( self :: REQUEST_PARAM_COUNTRY ) ; $ storeId = $ this -> config -> getGeoIpMappingForCountry ( $ countryCode ) ; if ( $ storeId !== null ) { $ redirectUrl = null ; $ targetStore = $ this -> storeRepository -> getActiveStoreById ( $ storeId ) ; $ currentStore = $ this -> storeManager -> getStore ( ) ; if ( $ currentStore -> getId ( ) != $ targetStore -> getId ( ) ) { $ this -> url -> setScope ( $ targetStore -> getId ( ) ) ; $ this -> url -> addQueryParams ( [ ' store' => $ targetStore -> getCode ( ) , ' from_store' => $ currentStore -> getCode ( ) ] ) ; $ redirectUrl = $ this -> url -> getUrl ( 'stores/store/switch' ) ; } if ( $ redirectUrl ) { switch ( $ this -> config -> getGeoIpAction ( ) ) { case Config :: GEOIP_ACTION_DIALOG : $ resultLayout -> getLayout ( ) -> getUpdate ( ) -> load ( [ 'geoip_getaction_dialog' ] ) ; $ resultLayout -> getLayout ( ) -> getBlock ( 'geoip_getaction' ) -> setMessage ( $ this -> getMessageInStoreLocale ( $ targetStore ) ) ; break ; case Config :: GEOIP_ACTION_REDIRECT : $ resultLayout -> getLayout ( ) -> getUpdate ( ) -> load ( [ 'geoip_getaction_redirect' ] ) ; break ; } $ resultLayout -> getLayout ( ) -> getBlock ( 'geoip_getaction' ) -> setRedirectUrl ( $ redirectUrl ) ; } } } catch ( \ Exception $ e ) { $ this -> logger -> critical ( $ e -> getMessage ( ) ) ; } $ resultLayout -> setHeader ( "x-esi" , "1" ) ; return $ resultLayout ; }
10537	public function prepareHeaders ( $ requestHeaders ) { $ responseHeaders = [ ] ; if ( isset ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { if ( in_array ( '*' , $ this -> cors [ 'Origin' ] ) || in_array ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = $ requestHeaders [ 'Origin' ] ; } } $ this -> prepareAllowHeaders ( 'Headers' , $ requestHeaders , $ responseHeaders ) ; if ( isset ( $ requestHeaders [ 'Access-Control-Request-Method' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Methods' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Request-Method' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Credentials' ] = $ this -> cors [ 'Access-Control-Allow-Credentials' ] ? 'true' : 'false' ; } if ( isset ( $ this -> cors [ 'Access-Control-Max-Age' ] ) && Yii :: $ app -> getRequest ( ) -> getIsOptions ( ) ) { $ responseHeaders [ 'Access-Control-Max-Age' ] = $ this -> cors [ 'Access-Control-Max-Age' ] ; } if ( isset ( $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Expose-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ; } return $ responseHeaders ; }
3219	function getDelta ( $ cursor = null , $ pathPrefix = null ) { Checker :: argStringNonEmptyOrNull ( "cursor" , $ cursor ) ; Path :: checkArgOrNull ( "pathPrefix" , $ pathPrefix ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/delta" , array ( "cursor" => $ cursor , "path_prefix" => $ pathPrefix ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
5219	public static function castFrom ( $ predicate ) { if ( $ predicate instanceof self ) { return $ predicate ; } elseif ( is_callable ( $ predicate ) ) { return new CallablePredicate ( $ predicate ) ; } throw new \ InvalidArgumentException ( 'Given predicate is neither a callable nor an instance of ' . __CLASS__ ) ; }
8116	public function canBeReviewedBy ( Member $ member = null ) { if ( ! $ this -> owner -> obj ( "NextReviewDate" ) -> exists ( ) ) { return false ; } if ( $ this -> owner -> obj ( "NextReviewDate" ) -> InFuture ( ) ) { return false ; } $ options = $ this -> getOptions ( ) ; if ( ! $ options ) { return false ; } if ( ! $ options || ( ! $ options -> hasExtension ( __CLASS__ ) && ! $ options -> hasExtension ( ContentReviewDefaultSettings :: class ) ) ) { return false ; } if ( $ options -> OwnerGroups ( ) -> count ( ) == 0 && $ options -> OwnerUsers ( ) -> count ( ) == 0 ) { return false ; } if ( ! $ member ) { return true ; } if ( $ member -> inGroups ( $ options -> OwnerGroups ( ) ) ) { return true ; } if ( $ options -> OwnerUsers ( ) -> find ( "ID" , $ member -> ID ) ) { return true ; } return false ; }
11173	public static function decrypt ( $ data , $ key , $ cipher = MCRYPT_RIJNDAEL_128 , $ mode = MCRYPT_MODE_CBC ) { $ key = hash ( 'sha256' , $ key , true ) ; @ list ( $ iv , $ encrypted ) = ( array ) unserialize ( base64_decode ( $ data ) ) ; return unserialize ( trim ( mcrypt_decrypt ( $ cipher , $ key , $ encrypted , $ mode , $ iv ) ) ) ; }
12543	public function getLink ( ) : string { if ( $ this -> link === null ) { return str_replace ( "?" . $ _SERVER [ "QUERY_STRING" ] , "" , $ _SERVER [ "REQUEST_URI" ] ) ; } else { return $ this -> link ; } }
8715	public function getAccessToken ( ) : ApiAccessToken { try { $ accessToken = $ this -> tokenStorage -> getAccessToken ( ) ; } catch ( UnableToAcquireAccessToken $ e ) { $ accessToken = null ; } if ( $ accessToken && $ accessToken -> isExpired ( ) ) { $ this -> tokenStorage -> unsetAccessToken ( ) ; $ accessToken = null ; } return $ accessToken ? : $ this -> refreshToken ( ) ; }
11643	public function getFormatter ( ) { if ( $ this -> _formatter === null ) { $ this -> _formatter = Yii :: $ app -> format ; } return $ this -> _formatter ; }
11476	public function authenticate ( Zend_Auth_Adapter_Interface $ adapter ) { $ result = $ adapter -> authenticate ( ) ; if ( $ this -> hasIdentity ( ) ) { $ this -> clearIdentity ( ) ; } if ( $ result -> isValid ( ) ) { $ this -> getStorage ( ) -> write ( $ adapter -> getResultRowObject ( ) ) ; } return $ result ; }
8297	protected function createBkFile ( ) { if ( ! is_writable ( dirname ( $ this -> filePath ) ) ) { return ; } $ this -> bkFilePath = $ this -> filePath . '.' . date ( "y-m-d-H-i-s" ) . '.bak' ; $ bkHandle = @ fopen ( $ this -> bkFilePath , 'x+' ) ; if ( $ bkHandle === false ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a temporary file " . $ this -> bkFilePath ) ; } $ stat = fstat ( $ this -> handle ) ; if ( stream_copy_to_stream ( $ this -> handle , $ bkHandle ) !== $ stat [ 'size' ] ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a copy of " . $ this -> filePath ) ; } if ( ! fclose ( $ bkHandle ) ) { throw new \ RuntimeException ( "Could not close a backup file " . $ this -> bkFilePath ) ; } fseek ( $ this -> handle , 0 ) ; }
9330	static function filter ( $ width , $ height ) { return array ( new ezcImageFilter ( 'scale' , array ( 'width' => intval ( $ width ) , 'height' => intval ( $ height ) , 'direction' => ezcImageGeometryFilters :: SCALE_BOTH ) ) ) ; }
8869	public function attach ( Runner $ runner ) { if ( $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t attach already attached runner.' ) ; } $ this -> runners -> attach ( $ runner ) ; return $ this ; }
6154	public function setValue ( $ value ) { $ definition = $ this -> propertyType -> getDefinition ( ) ; if ( isset ( $ definition [ 'hierarchical' ] ) && $ definition [ 'hierarchical' ] ) { $ this -> value = [ ] ; foreach ( $ value as $ v ) { foreach ( $ v [ 'value' ] as $ itemValue ) { $ this -> value [ ] = $ this -> convertValue ( $ itemValue [ 'value' ] ) ; } } } elseif ( ! empty ( $ definition [ 'array' ] ) ) { if ( empty ( $ definition [ 'multiplechoice' ] ) && isset ( $ definition [ 'options' ] ) && is_array ( $ definition [ 'options' ] ) ) { $ this -> value = $ this -> convertValue ( current ( $ value ) [ 'value' ] ) ; } else { $ this -> value = [ ] ; foreach ( $ value as $ v ) { $ this -> value [ ] = $ this -> convertValue ( $ v [ 'value' ] ) ; } } } else { $ this -> value = $ this -> convertValue ( $ value ) ; } return $ this ; }
1941	public function checkBlacklistedRecipient ( $ varValue , Contao \ DataContainer $ dc ) { $ objBlacklist = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_blacklist WHERE hash=? AND pid=(SELECT pid FROM tl_newsletter_recipients WHERE id=?) AND id!=?" ) -> execute ( md5 ( $ varValue ) , $ dc -> id , $ dc -> id ) ; if ( $ objBlacklist -> count > 0 ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'blacklisted' ] ) ; } return $ varValue ; }
8562	public function createShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_CreateShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_CreateShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_CreateShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1582	public function withRelationships ( $ relationships ) : self { $ copy = clone $ this ; $ copy -> relationships = collect ( $ relationships ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; }
2829	public function enableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( true ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was enabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to enable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
605	protected function indexAfter ( $ string , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + mb_strlen ( $ string , 'UTF-8' ) > $ this -> length ) { return $ this -> length ; } $ afterIndexOf = mb_strpos ( $ this -> sql , $ string , $ offset , 'UTF-8' ) ; if ( $ afterIndexOf === false ) { $ afterIndexOf = $ this -> length ; } else { $ afterIndexOf += mb_strlen ( $ string , 'UTF-8' ) ; } return $ afterIndexOf ; }
5003	protected function getConfig ( $ services , $ name ) { $ defaults = [ 'service' => 'EventManager' , 'configure' => true , 'identifiers' => [ $ name ] , 'event' => '\Zend\EventManager\Event' , 'listeners' => [ ] , ] ; $ config = $ services -> get ( 'Config' ) ; $ config = isset ( $ config [ 'event_manager' ] [ $ name ] ) ? $ config [ 'event_manager' ] [ $ name ] : [ ] ; $ config = array_replace_recursive ( $ defaults , $ config ) ; return $ config ; }
9277	public function renderRest ( $ request , $ data , $ statusCode = Response :: HTTP_OK , $ headers = [ ] ) { $ requestSerializer = $ this -> get ( 'ongr_api.request_serializer' ) ; return new Response ( $ requestSerializer -> serializeRequest ( $ request , $ data ) , $ statusCode , array_merge ( [ 'Content-Type' => 'application/' . $ requestSerializer -> checkAcceptHeader ( $ request ) ] , $ headers ) ) ; }
7892	public function set ( $ property_name , $ value ) { $ this -> validateProperty ( $ property_name , $ value ) ; $ this -> data [ $ property_name ] = $ value ; return $ this ; }
6537	public function registerAssetFiles ( $ view ) { if ( \ Yii :: $ app -> request -> isPjax ) { return parent :: registerAssetFiles ( $ view ) ; } parent :: registerAssetFiles ( $ view ) ; }
220	private function formatNumber ( $ value , $ decimals , $ maxPosition , $ formatBase , $ options , $ textOptions ) { $ value = $ this -> normalizeNumericValue ( $ value ) ; $ position = 0 ; if ( is_array ( $ formatBase ) ) { $ maxPosition = count ( $ formatBase ) - 1 ; } do { if ( is_array ( $ formatBase ) ) { if ( ! isset ( $ formatBase [ $ position + 1 ] ) ) { break ; } if ( abs ( $ value ) < $ formatBase [ $ position + 1 ] ) { break ; } } else { if ( abs ( $ value ) < $ formatBase ) { break ; } $ value /= $ formatBase ; } $ position ++ ; } while ( $ position < $ maxPosition + 1 ) ; if ( is_array ( $ formatBase ) && $ position !== 0 ) { $ value /= $ formatBase [ $ position ] ; } if ( $ position === 0 ) { $ decimals = 0 ; } elseif ( $ decimals !== null ) { $ value = round ( $ value , $ decimals ) ; } $ oldThousandSeparator = $ this -> thousandSeparator ; $ this -> thousandSeparator = '' ; if ( $ this -> _intlLoaded && ! isset ( $ options [ NumberFormatter :: GROUPING_USED ] ) ) { $ options [ NumberFormatter :: GROUPING_USED ] = false ; } $ params = [ 'n' => abs ( $ value ) , 'nFormatted' => $ this -> asDecimal ( $ value , $ decimals , $ options , $ textOptions ) , ] ; $ this -> thousandSeparator = $ oldThousandSeparator ; return [ $ params , $ position ] ; }
1738	public function generate ( ) { if ( $ this -> singleSRC == '' ) { return '' ; } $ objFile = FilesModel :: findByUuid ( $ this -> singleSRC ) ; if ( $ objFile === null ) { return '' ; } $ allowedDownload = StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'allowedDownload' ) ) ) ; if ( ! \ in_array ( $ objFile -> extension , $ allowedDownload ) ) { return '' ; } $ file = Input :: get ( 'file' , true ) ; if ( $ file && ( ! isset ( $ _GET [ 'cid' ] ) || Input :: get ( 'cid' ) == $ this -> id ) ) { if ( $ file == $ objFile -> path ) { Controller :: sendFileToBrowser ( $ file , ( bool ) $ this -> inline ) ; } if ( isset ( $ _GET [ 'cid' ] ) ) { throw new PageNotFoundException ( 'Invalid file name' ) ; } } $ this -> objFile = $ objFile ; $ this -> singleSRC = $ objFile -> path ; return parent :: generate ( ) ; }
9007	public function sort ( ) { $ this -> uasort ( function ( $ a , $ b ) { $ priority_a = ( int ) $ a -> get ( 'priority' ) ? : 500 ; $ priority_b = ( int ) $ b -> get ( 'priority' ) ? : 500 ; if ( $ priority_a == $ priority_b ) { return 0 ; } return ( $ priority_a < $ priority_b ) ? - 1 : 1 ; } ) ; return $ this ; }
2811	public function getEvents ( ) { if ( $ this -> events === null ) { $ this -> events = array ( ) ; foreach ( $ this -> getTimers ( ) as $ timerName => $ timer ) { if ( strpos ( $ timerName , 'DISPATCH EVENT:' ) === 0 ) { $ this -> events [ str_replace ( 'DISPATCH EVENT:' , '' , $ timerName ) ] = array ( 'name' => str_replace ( 'DISPATCH EVENT:' , '' , $ timerName ) , 'count' => $ timer [ 'count' ] , 'sum' => round ( $ timer [ 'sum' ] * 1000 , 2 ) , 'mem_diff' => $ timer [ 'realmem' ] / pow ( 1024 , 2 ) , ) ; } } } return $ this -> events ; }
10241	public function calculateFormula ( $ formula , $ cellID = null , Cell $ pCell = null ) { $ this -> formulaError = null ; $ this -> debugLog -> clearLog ( ) ; $ this -> cyclicReferenceStack -> clear ( ) ; if ( $ this -> spreadsheet !== null && $ cellID === null && $ pCell === null ) { $ cellID = 'A1' ; $ pCell = $ this -> spreadsheet -> getActiveSheet ( ) -> getCell ( $ cellID ) ; } else { $ resetCache = $ this -> getCalculationCacheEnabled ( ) ; $ this -> calculationCacheEnabled = false ; } try { $ result = self :: unwrapResult ( $ this -> _calculateFormulaValue ( $ formula , $ cellID , $ pCell ) ) ; } catch ( \ Exception $ e ) { throw new Exception ( $ e -> getMessage ( ) ) ; } if ( $ this -> spreadsheet === null ) { $ this -> calculationCacheEnabled = $ resetCache ; } return $ result ; }
5715	public function doSaveAndAdd ( $ data , $ form ) { return $ this -> saveAndRedirect ( $ data , $ form , $ this -> owner -> Link ( "addnew" ) ) ; }
4437	public function set ( string $ name , $ value ) : void { $ this -> client -> call ( 'config.set' , $ name , $ value ) ; }
518	private function generateClassName ( $ name ) { $ namespace = null ; $ name = trim ( $ name , '\\' ) ; if ( strpos ( $ name , '\\' ) !== false ) { $ namespace = substr ( $ name , 0 , strrpos ( $ name , '\\' ) ) ; $ name = substr ( $ name , strrpos ( $ name , '\\' ) + 1 ) ; } else { if ( $ this -> migrationPath === null ) { $ migrationNamespaces = $ this -> migrationNamespaces ; $ namespace = array_shift ( $ migrationNamespaces ) ; } } if ( $ namespace === null ) { $ class = 'm' . gmdate ( 'ymd_His' ) . '_' . $ name ; } else { $ class = 'M' . gmdate ( 'ymdHis' ) . ucfirst ( $ name ) ; } return [ $ namespace , $ class ] ; }
4430	protected function writeInstallerSummary ( $ errors ) { if ( ! $ errors ) { $ this -> writeSection ( 'You can now continue installation as per instructions in the README.md file!' ) ; return ; } $ this -> writeSection ( array ( 'The command was not able to install everything automatically.' , 'You must do the following changes manually.' , ) , 'error' ) ; $ this -> output -> writeln ( $ errors ) ; }
4049	public function fetchInputScreens ( $ idList ) : array { $ idList = array_filter ( $ idList ) ; $ builder = $ this -> connection -> createQueryBuilder ( ) ; $ screens = $ builder -> select ( 'd.*' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel' , 'm' , 'm.id=d.pid' ) -> where ( $ builder -> expr ( ) -> in ( 'd.id' , ':idList' ) ) -> setParameter ( 'idList' , $ idList , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'm.sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; $ keys = array_flip ( $ idList ) ; foreach ( $ screens as $ screen ) { $ metaModelName = $ keys [ $ screen [ 'id' ] ] ; $ result [ $ metaModelName ] = $ this -> prepareInputScreen ( $ metaModelName , $ screen ) ; } return $ result ; }
4866	public function delete ( JobInterface $ job , array $ options = [ ] ) { $ result = $ this -> mongoCollection -> deleteOne ( [ '_id' => $ job -> getId ( ) ] ) ; return ( bool ) $ result -> getDeletedCount ( ) ; }
4112	public function searchFullPath ( $ filename ) { $ paths = explode ( PATH_SEPARATOR , get_include_path ( ) ) ; foreach ( $ paths as $ path ) { $ fullPath = $ path . DIRECTORY_SEPARATOR . $ filename ; if ( file_exists ( $ fullPath ) ) { return $ fullPath ; } } return false ; }
8624	public function setShippingServiceList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShippingServiceList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7114	static public function isBetterMode ( $ modeA , $ modeB ) { if ( $ modeA === static :: MODE_DISABLED ) { return $ modeB !== static :: MODE_DISABLED ; } elseif ( $ modeA === static :: MODE_JUST_IN_TIME ) { return in_array ( $ modeB , [ static :: MODE_MANUAL , static :: MODE_AUTO ] , true ) ; } return false ; }
9361	public function norm ( ) { if ( $ this -> original ) { return $ this -> original -> rho ; } return sqrt ( pow ( $ this -> float_r , 2 ) + pow ( $ this -> float_i , 2 ) ) ; }
1218	public function setConfig ( array $ configuration ) { $ this -> config = Functions \ arrayMergeDeep ( $ this -> config , $ this -> resolver -> resolveOptions ( $ configuration ) ) ; }
595	private function deletePublishedAssets ( $ bundles ) { $ this -> stdout ( "Deleting source files...\n" ) ; if ( $ this -> getAssetManager ( ) -> linkAssets ) { $ this -> stdout ( "`AssetManager::linkAssets` option is enabled. Deleting of source files canceled.\n" , Console :: FG_YELLOW ) ; return ; } foreach ( $ bundles as $ bundle ) { if ( $ bundle -> sourcePath !== null ) { foreach ( $ bundle -> js as $ jsFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ jsFile ) ; } foreach ( $ bundle -> css as $ cssFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ cssFile ) ; } } } $ this -> stdout ( "Source files deleted.\n" , Console :: FG_GREEN ) ; }
6313	private function loadConstraints ( Table $ table ) { foreach ( $ this -> getConstraints ( ) as $ constraint ) { switch ( $ constraint [ 'constraint_type' ] ) { case 'FOREIGN KEY' : $ foreignKey = new ForeignKey ( new Table ( $ constraint [ 'table_name' ] ) , new Table ( $ constraint [ 'column_name' ] ) ) ; $ foreignKey -> setColumns ( $ constraint [ 'references_table' ] ) ; $ foreignKey -> setReferencedColumns ( $ constraint [ 'references_field' ] ) ; $ table -> addConstraint ( $ foreignKey ) ; break ; case 'PRIMARY KEY' : $ table -> addConstraint ( new PrimaryKey ( $ constraint [ 'column_name' ] , $ table ) ) ; break ; case 'UNIQUE' : $ table -> addConstraint ( new Unique ( $ constraint [ 'column_name' ] , new Table ( $ constraint [ 'table_name' ] ) ) ) ; break ; } } }
5506	public function returnsAt ( $ timing , $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return value sequence' ) ; $ this -> actions -> registerAt ( $ timing , $ method , $ args , new SimpleReturn ( $ value ) ) ; }
8085	public function addPredefinedError ( $ id , $ message = '' ) { if ( is_array ( $ id ) ) { $ this -> errorList = array_diff_key ( $ this -> errorList , $ id ) + $ id ; } else { $ this -> errorList [ $ id ] = $ message ; } }
10619	public function send ( ) { $ input = Input :: only ( array ( 'name' , 'email' , 'comment' , 'to_email' , 'to_name' , 'security-code' ) ) ; $ input [ 'security-code' ] = $ this -> quickSanitize ( $ input [ 'security-code' ] ) ; if ( strlen ( $ input [ 'security-code' ] ) < 2 ) { $ message = "Please enter the security code again. Thank you!" ; return view ( 'lasallecmscontact::step_two_form' , [ 'input' => $ input , 'message' => $ message , ] ) ; } $ input [ 'name' ] = $ this -> quickSanitize ( $ input [ 'name' ] ) ; $ input [ 'email' ] = $ this -> quickSanitize ( $ input [ 'email' ] ) ; $ input [ 'comment' ] = $ this -> quickSanitize ( $ input [ 'comment' ] ) ; $ to_email = Config :: get ( 'lasallecmscontact.to_email' ) ; $ to_name = Config :: get ( 'lasallecmscontact.to_name' ) ; if ( $ input [ 'to_email' ] != "" ) { $ to_email = $ input [ 'to_email' ] ; $ to_name = $ input [ 'to_name' ] ; } Mail :: send ( 'lasallecmscontact::email' , $ input , function ( $ message ) use ( $ to_email , $ to_name ) { $ message -> from ( Config :: get ( 'lasallecmscontact.from_email' ) , Config :: get ( 'lasallecmscontact.from_name' ) ) ; $ message -> to ( $ to_email , $ to_name ) -> subject ( Config :: get ( 'lasallecmscontact.subject_email' ) ) ; } ) ; return Redirect :: route ( 'contact-processing.thankyou' ) ; }
1963	public static function encodeUrl ( $ strUrl ) { if ( $ strUrl == '' ) { return '' ; } if ( $ strUrl == '#' || strncmp ( $ strUrl , '{{' , 2 ) === 0 ) { return $ strUrl ; } if ( strncmp ( $ strUrl , 'mailto:' , 7 ) === 0 ) { return static :: encodeEmail ( $ strUrl ) ; } $ arrUrl = parse_url ( $ strUrl ) ; if ( ! isset ( $ arrUrl [ 'scheme' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Expected a FQDN, got "%s"' , $ strUrl ) ) ; } if ( isset ( $ arrUrl [ 'scheme' ] ) ) { $ arrUrl [ 'scheme' ] .= ( ( substr ( $ strUrl , \ strlen ( $ arrUrl [ 'scheme' ] ) , 3 ) == '://' ) ? '://' : ':' ) ; } if ( isset ( $ arrUrl [ 'user' ] ) ) { $ arrUrl [ 'user' ] .= isset ( $ arrUrl [ 'pass' ] ) ? ':' : '@' ; } if ( isset ( $ arrUrl [ 'pass' ] ) ) { $ arrUrl [ 'pass' ] .= '@' ; } if ( isset ( $ arrUrl [ 'host' ] ) ) { $ arrUrl [ 'host' ] = static :: encode ( $ arrUrl [ 'host' ] ) ; } if ( isset ( $ arrUrl [ 'port' ] ) ) { $ arrUrl [ 'port' ] = ':' . $ arrUrl [ 'port' ] ; } if ( isset ( $ arrUrl [ 'query' ] ) ) { $ arrUrl [ 'query' ] = '?' . $ arrUrl [ 'query' ] ; } if ( isset ( $ arrUrl [ 'fragment' ] ) ) { $ arrUrl [ 'fragment' ] = '#' . $ arrUrl [ 'fragment' ] ; } $ strReturn = '' ; foreach ( array ( 'scheme' , 'user' , 'pass' , 'host' , 'port' , 'path' , 'query' , 'fragment' ) as $ key ) { if ( isset ( $ arrUrl [ $ key ] ) ) { $ strReturn .= $ arrUrl [ $ key ] ; } } return $ strReturn ; }
10835	private function compileOn ( array $ join ) { $ sql = array ( ) ; list ( $ on , $ table , $ type , $ c1 , $ op , $ c2 ) = $ join ; if ( $ type !== null ) { $ sql [ ] = $ type ; } array_push ( $ sql , "JOIN" , $ table , "ON" , $ c1 , $ op , $ c2 ) ; return join ( ' ' , $ sql ) ; }
8683	public static function from ( $ iterable ) { if ( is_array ( $ iterable ) ) { return $ iterable ; } if ( $ iterable instanceof ImmutableBag ) { return $ iterable -> toArray ( ) ; } if ( $ iterable instanceof Traversable ) { return iterator_to_array ( $ iterable ) ; } if ( $ iterable === null ) { return [ ] ; } if ( $ iterable instanceof \ stdClass ) { return ( array ) $ iterable ; } Assert :: nullOrIsIterable ( $ iterable ) ; }
6843	public function call ( Closure $ c , $ params = array ( ) ) { $ ref = new ReflectionFunction ( $ c ) ; $ params_need = $ ref -> getParameters ( ) ; $ args = $ this -> apply ( $ params_need , $ params ) ; return call_user_func_array ( $ c , $ args ) ; }
523	protected function includeMigrationFile ( $ class ) { $ class = trim ( $ class , '\\' ) ; if ( strpos ( $ class , '\\' ) === false ) { if ( is_array ( $ this -> migrationPath ) ) { foreach ( $ this -> migrationPath as $ path ) { $ file = $ path . DIRECTORY_SEPARATOR . $ class . '.php' ; if ( is_file ( $ file ) ) { require_once $ file ; break ; } } } else { $ file = $ this -> migrationPath . DIRECTORY_SEPARATOR . $ class . '.php' ; require_once $ file ; } } }
7829	public function getLeftBordersWith ( $ border ) { $ border = str_repeat ( $ border , static :: BORDER_WIDTH ) ; $ space = str_repeat ( ' ' , static :: MIN_SPACE_FROM_BORDER_X ) ; return str_repeat ( "{$border}{$space}" , $ this -> nesting ) ; }
8305	public function assertGreaterThan ( $ config , $ keyGreater , $ keyLower ) { if ( ! isset ( $ config [ $ keyLower ] ) || ! isset ( $ config [ $ keyGreater ] ) || $ config [ $ keyLower ] >= $ config [ $ keyGreater ] ) { throw new ConfigurationException ( $ keyGreater . " must be greater than " . $ keyLower ) ; } return $ this ; }
2271	public function getUuid ( ) { static $ ids ; if ( empty ( $ ids ) ) { $ statement = $ this -> resConnection -> executeQuery ( implode ( ' UNION ALL ' , array_fill ( 0 , 10 , "SELECT UNHEX(REPLACE(UUID(), '-', '')) AS uuid" ) ) ) ; $ ids = $ statement -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; } return array_pop ( $ ids ) ; }
8201	protected function exportJob ( $ job ) { $ stats = $ this -> getJobStats ( $ job ) ; $ contents = $ this -> renderForExport ( $ job , $ stats ) ; $ filename = trim ( $ this -> path , '/' ) . '/' . $ this -> buildJobFileName ( $ job , $ stats ) ; if ( file_exists ( $ filename ) ) { throw new \ RuntimeException ( 'File already exists.' ) ; } if ( ! file_put_contents ( $ filename , $ contents ) ) { throw new \ RuntimeException ( 'Error saving the file.' ) ; } }
2582	protected function loadTransactionFlowLink ( $ params ) { if ( isset ( $ params [ 'enableTransactionFlowLink' ] ) && $ params [ 'enableTransactionFlowLink' ] === true ) { $ this -> enableTransactionFlowLink = true ; $ this -> consumerId = ( isset ( $ params [ 'consumerId' ] ) ) ? $ params [ 'consumerId' ] : null ; } }
10897	public function setScheme ( $ scheme ) { foreach ( $ this -> uris as $ name => $ uri ) { $ this -> add ( $ name , $ uri -> withScheme ( $ scheme ) ) ; } }
4867	public function fail ( JobInterface $ job , array $ options = [ ] ) { $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; unset ( $ envelope [ 'scheduled' ] ) ; $ envelope [ 'status' ] = self :: STATUS_FAILED ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectId ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
12635	protected function getSignkey ( $ api ) { return $ this -> sandboxEnabled && $ api !== self :: API_SANDBOX_SIGN_KEY ? $ this -> getSandboxSignKey ( ) : $ this -> merchant -> key ; }
5741	protected static function prefixData ( $ data ) { $ prefixedData = array ( ) ; foreach ( $ data as $ stat => $ value ) { $ prefixedKey = self :: prefix ( $ stat ) ; $ prefixedData [ $ prefixedKey ] = $ value ; } return $ prefixedData ; }
3997	protected function getItem ( $ metaModelIdOrName , $ mixDataId , $ intIdRenderSetting , $ strOutput = null ) { $ objMetaModel = $ this -> loadMetaModel ( $ metaModelIdOrName ) ; if ( $ objMetaModel == null ) { return false ; } if ( empty ( $ strOutput ) ) { $ strOutput = 'html5' ; } $ objMetaModelList = new ItemList ( ) ; $ objMetaModelList -> setServiceContainer ( $ this -> getServiceContainer ( ) ) -> setMetaModel ( $ objMetaModel -> get ( 'id' ) , $ intIdRenderSetting ) -> overrideOutputFormat ( $ strOutput ) ; $ arrIds = StringUtil :: trimsplit ( ',' , $ mixDataId ) ; foreach ( $ arrIds as $ intKey => $ intId ) { if ( ! $ this -> isPublishedItem ( $ objMetaModel , $ intId ) ) { unset ( $ arrIds [ $ intKey ] ) ; } } if ( count ( $ arrIds ) < 1 ) { return '' ; } $ objMetaModelList -> addFilterRule ( new StaticIdList ( $ arrIds ) ) ; return $ objMetaModelList -> render ( false , $ this ) ; }
2028	public static function findPublishedRegularWithoutGuestsByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.type!='root' AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( FE_USER_LOGGED_IN ) { $ arrColumns [ ] = "$t.guests=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
8383	public function fetchAll ( ) { if ( $ this -> statement == null || $ this -> getErrorState ( ) != '00000' ) { return false ; } return $ this -> statement -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
5595	protected function createRoute ( $ url ) { if ( $ this -> proxy ) { return new SimpleProxyRoute ( $ url , $ this -> proxy , $ this -> proxy_username , $ this -> proxy_password ) ; } return new SimpleRoute ( $ url ) ; }
5704	public function Field ( $ properties = array ( ) ) { if ( $ this -> isGrouped ( ) ) { $ this -> transformToInput ( ) ; } else { $ this -> transformToButton ( ) ; } return parent :: Field ( $ properties ) ; }
11976	public function handleCommandHelp ( Event $ event , Queue $ queue ) { $ this -> sendIrcResponse ( $ event , $ queue , $ this -> getHelpLines ( ) ) ; }
8941	public function expandBBoxChangeset ( $ id , $ nodes ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/expand_bbox' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ nodeList = '' ; if ( ! empty ( $ nodes ) ) { foreach ( $ nodes as $ node ) { $ nodeList .= '<node lat="' . $ node [ 0 ] . '" lon="' . $ node [ 1 ] . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <changeset>' . $ nodeList . '</changeset> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'POST' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> changeset ; }
3126	protected function isStartPoint ( TimePoint $ point ) { return $ point -> match ( null , TimePoint :: TARGET_ALL , TimePoint :: TYPE_START ) ; }
976	public function deleteWebhooks ( ) { $ shopWebhooks = $ this -> shopWebhooks ( ) ; $ deleted = [ ] ; foreach ( $ shopWebhooks as $ webhook ) { $ this -> api -> rest ( 'DELETE' , "/admin/webhooks/{$webhook->id}.json" ) ; $ deleted [ ] = $ webhook ; } $ this -> shopWebhooks = null ; return $ deleted ; }
12529	public function getForeignDataSource ( $ foreignModelClass ) { foreach ( $ this -> dataSources as $ dataSource ) { if ( $ dataSource -> foreignModel -> modelName === $ foreignModelClass ) { return $ dataSource ; } } return false ; }
10454	public function resetPassword ( $ user , $ password ) { $ user -> password = $ password ; $ user -> reset_token = null ; $ user -> save ( ) ; }
12286	public function inset ( string $ block , array $ vars = null ) : string { return trim ( $ this -> make ( $ block , $ vars ) ) . PHP_EOL ; }
1744	public function deleteFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ path = $ rootDir . '/' . urldecode ( $ row [ 'id' ] ) ; if ( ! is_dir ( $ path ) ) { return ( $ this -> User -> hasAccess ( 'f3' , 'fop' ) || $ this -> User -> hasAccess ( 'f4' , 'fop' ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } $ finder = Symfony \ Component \ Finder \ Finder :: create ( ) -> in ( $ path ) ; if ( $ finder -> count ( ) > 0 ) { return $ this -> User -> hasAccess ( 'f4' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } return $ this -> User -> hasAccess ( 'f3' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
8031	public function getProcessDetails ( $ pid ) { if ( $ this -> hasProcess ( $ pid ) === FALSE ) { return NULL ; } return $ this -> processDetails [ $ pid ] ; }
459	public function getColumnType ( $ type ) { if ( $ type instanceof ColumnSchemaBuilder ) { $ type = $ type -> __toString ( ) ; } if ( isset ( $ this -> typeMap [ $ type ] ) ) { return $ this -> typeMap [ $ type ] ; } elseif ( preg_match ( '/^(\w+)\((.+?)\)(.*)$/' , $ type , $ matches ) ) { if ( isset ( $ this -> typeMap [ $ matches [ 1 ] ] ) ) { return preg_replace ( '/\(.+\)/' , '(' . $ matches [ 2 ] . ')' , $ this -> typeMap [ $ matches [ 1 ] ] ) . $ matches [ 3 ] ; } } elseif ( preg_match ( '/^(\w+)\s+/' , $ type , $ matches ) ) { if ( isset ( $ this -> typeMap [ $ matches [ 1 ] ] ) ) { return preg_replace ( '/^\w+/' , $ this -> typeMap [ $ matches [ 1 ] ] , $ type ) ; } } return $ type ; }
8864	public function augmentSQL ( SQLQuery & $ query ) { $ stage = Versioned :: current_stage ( ) ; if ( $ stage == 'Live' || ! Permission :: check ( "VIEW_DRAFT_CONTENT" ) ) { $ query -> addWhere ( "PublishDate < '" . Convert :: raw2sql ( SS_Datetime :: now ( ) ) . "'" ) ; } }
940	public function override ( $ other ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ prototype = $ other instanceof self ? $ other -> getPrototype ( ) : $ other ; if ( $ this -> equals ( $ prototype ) ) { return ; } $ this -> changed = true ; if ( \ is_array ( $ prototype ) ) { $ this -> isArray = true ; $ this -> id = $ prototype [ 0 ] ; $ this -> content = $ prototype [ 1 ] ; return ; } $ this -> isArray = false ; $ this -> id = null ; $ this -> content = $ prototype ; }
11883	public function getTicketCacheKey ( ) { if ( is_null ( $ this -> ticketCacheKey ) ) { return $ this -> ticketCachePrefix . $ this -> getAccessToken ( ) -> getAppId ( ) ; } return $ this -> ticketCacheKey ; }
9105	protected function parse_time ( ) { if ( ! empty ( $ this -> args [ 'time' ] ) ) { $ date_query = new \ WP_Date_Query ( $ this -> args [ 'time' ] , 'q.time' ) ; return new Where_Date ( $ date_query ) ; } else { return null ; } }
6673	public function update_rating ( $ post_id , $ post , $ update ) { App :: setCurrentID ( 'EFG' ) ; if ( App :: main ( ) -> is_after_update_post ( $ post , $ update ) ) { if ( isset ( $ _POST [ 'efg-update-rating' ] ) ) { for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { if ( ! isset ( $ _POST [ "efg-rating-$i" ] ) ) { return false ; } $ votes [ "$i" ] = ( int ) $ _POST [ "efg-rating-$i" ] ; } $ this -> set_rating_and_votes ( $ post_id , $ votes ) ; } } return true ; }
5482	public function setField ( SelectorInterface $ selector , $ value , $ position = false ) { $ success = false ; $ _position = 0 ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { $ _position ++ ; if ( $ position === false or $ _position === ( int ) $ position ) { if ( $ this -> widgets [ $ i ] -> setValue ( $ value ) ) { $ success = true ; } } } } return $ success ; }
2392	public function getAllowedCalendars ( ) { if ( $ this -> User -> isAdmin ) { $ objCalendar = Contao \ CalendarModel :: findAll ( ) ; } else { $ objCalendar = Contao \ CalendarModel :: findMultipleByIds ( $ this -> User -> calendars ) ; } $ return = array ( ) ; if ( $ objCalendar !== null ) { while ( $ objCalendar -> next ( ) ) { $ return [ $ objCalendar -> id ] = $ objCalendar -> title ; } } return $ return ; }
9919	private function findColumns ( Model $ model ) { $ tableName = $ this -> getTableName ( $ model ) ; if ( ! $ this -> databaseRepository -> hasTable ( $ tableName ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Table %s for %s does not exist!' , $ tableName , $ model -> getName ( ) ) ) ; } $ columns = $ this -> databaseRepository -> getColumnListing ( $ tableName ) ; foreach ( $ columns as $ columnName ) { $ columnType = $ this -> databaseRepository -> getColumnType ( $ tableName , $ columnName ) ; $ model -> addColumn ( new Column ( $ columnName , $ columnType ) ) ; } }
10744	public function getArray ( $ keys , array $ default = [ ] ) : array { $ result = $ this -> get ( $ keys , $ default ) ; if ( ! is_array ( $ result ) ) { $ result = $ default ; } return $ result ; }
4612	public function prepare ( Command $ command , Node $ node ) { $ this -> setCommand ( $ command ) ; $ this -> setNode ( $ node ) ; return $ this ; }
8530	private function _convertListFinancialEvents ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMaxResultsPerPage ( ) ) { $ parameters [ 'MaxResultsPerPage' ] = $ request -> getMaxResultsPerPage ( ) ; } if ( $ request -> isSetAmazonOrderId ( ) ) { $ parameters [ 'AmazonOrderId' ] = $ request -> getAmazonOrderId ( ) ; } if ( $ request -> isSetFinancialEventGroupId ( ) ) { $ parameters [ 'FinancialEventGroupId' ] = $ request -> getFinancialEventGroupId ( ) ; } if ( $ request -> isSetPostedAfter ( ) ) { $ parameters [ 'PostedAfter' ] = $ request -> getPostedAfter ( ) ; } if ( $ request -> isSetPostedBefore ( ) ) { $ parameters [ 'PostedBefore' ] = $ request -> getPostedBefore ( ) ; } return $ parameters ; }
1573	public function getProcessIdentifier ( ) : ? ResourceIdentifierInterface { if ( ! $ id = $ this -> getProcessId ( ) ) { return null ; } return ResourceIdentifier :: create ( $ this -> getProcessType ( ) , $ id ) ; }
6736	public function instantiate ( $ provider ) { if ( ! $ this -> supported ( $ provider ) ) { throw new ProviderNotSupportedException ( $ provider ) ; } $ class = $ this -> providerClass ( $ provider ) ; switch ( $ provider ) { case 'facebook' : return new $ class ( $ this -> config , $ this -> redirector , $ this -> http , $ this -> store , $ this -> profile , $ this -> access_token ) ; break ; case 'twitter' : return new $ class ( $ this -> config , $ this -> http , $ this -> redirector , $ this -> store , $ this -> profile , $ this -> signature , $ this -> consumer , $ this -> token , $ this -> oauth ) ; break ; } }
4138	public function postMedia ( $ call , $ filename ) { $ this -> resetCallState ( ) ; $ this -> call = $ call ; $ this -> method = 'POST' ; $ this -> withMedia = true ; $ mimeBoundary = sha1 ( $ call . microtime ( ) ) ; $ params = array ( 'post' => $ this -> buildMultipart ( $ mimeBoundary , $ filename ) , 'headers' => $ this -> buildUploadMediaHeader ( $ mimeBoundary ) , ) ; $ response = $ this -> curl -> send ( $ this -> getUrl ( ) , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> token_type ) || $ obj -> token_type != 'bearer' ) { $ this -> findExceptions ( $ response ) ; } $ this -> headers = $ response [ 'headers' ] ; $ this -> withMedia = null ; unset ( $ call , $ filename , $ mimeBoundary , $ params , $ obj ) ; return $ this -> serializer -> format ( $ response [ 'body' ] ) ; }
3922	private function resizeImage ( $ fileName ) { list ( $ width , $ height , $ mode ) = $ this -> getResizeImages ( ) ; if ( $ this -> getShowImages ( ) && ( $ width || $ height || $ mode ) ) { if ( $ this -> imageFactory ) { $ image = $ this -> imageFactory -> create ( $ this -> rootDir . '/' . $ fileName , [ $ width , $ height , $ mode ] ) ; return $ image -> getUrl ( $ this -> rootDir ) ; } $ event = new ResizeImageEvent ( $ fileName , $ width , $ height , $ mode ) ; $ this -> dispatcher -> dispatch ( ContaoEvents :: IMAGE_RESIZE , $ event ) ; return $ event -> getResultImage ( ) ; } return $ fileName ; }
7449	public function exec ( string $ execfile , array $ args ) : bool { return $ this -> process -> exec ( $ execfile , $ args ) ; }
3087	public function validateAdaptiveAssessmentSection ( SectionPartCollection $ sectionsParts , $ ref , $ testAdminId ) { $ engine = $ this -> getEngine ( $ ref ) ; $ adaptSection = $ engine -> setupSection ( $ testAdminId ) ; if ( method_exists ( $ adaptSection , 'getItemReferences' ) ) { $ itemReferences = $ adaptSection -> getItemReferences ( ) ; $ dependencies = $ sectionsParts -> getKeys ( ) ; if ( $ catDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some CAT service items: ' . implode ( ', ' , $ catDiff ) , $ catDiff ) ; } if ( $ packageDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some package items: ' . implode ( ', ' , $ packageDiff ) , $ packageDiff ) ; } } }
5813	public function getCMSFields ( ) { $ fields = parent :: getCMSFields ( ) ; $ types = array ( ) ; foreach ( $ this -> service -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } if ( count ( $ types ) ) { $ fields -> replaceField ( 'TagTypes' , $ list = ListboxField :: create ( 'Types' , 'Tag Types' , $ types ) -> setMultiple ( true ) ) ; $ items = is_string ( $ this -> TagTypes ) ? array_keys ( unserialize ( $ this -> TagTypes ) ) : array ( ) ; $ list -> setValue ( $ items ) ; $ list -> setDisabledItems ( $ items ) ; } else { $ fields -> removeByName ( 'TagTypes' ) ; } $ this -> extend ( 'updateFusionTagCMSFields' , $ fields ) ; return $ fields ; }
2862	public function startRequest ( ) { foreach ( $ this -> files as $ logFile ) { $ logFilePath = $ this -> getLogFilePath ( $ logFile ) ; $ this -> ranges [ $ logFile ] = array ( 'start' => $ this -> getLastFilePosition ( $ logFilePath ) , 'end' => 0 ) ; } }
12944	function setDefaultQueues ( array $ defaultQueues ) { $ this -> _defaults = $ defaultQueues ; $ queues = StdArray :: of ( $ this -> queues ) -> withMergeRecursive ( $ defaultQueues , true ) ; $ this -> queues = $ queues -> value ; return $ this ; }
12520	protected function getWhereFromParameter ( ParameterInterface $ parameter ) { if ( $ parameter instanceof IdAwareParameterInterface && $ parameter -> getId ( ) ) { return [ 'id' => $ parameter -> getId ( ) ] ; } else { return [ 'namespace' => $ parameter -> getNamespace ( ) , 'name' => $ parameter -> getName ( ) ] ; } }
2260	protected static function braceGlob ( $ pattern ) { if ( false === strpos ( $ pattern , '/**/' ) && ( \ defined ( 'GLOB_BRACE' ) || false === strpos ( $ pattern , '{' ) ) ) { return glob ( $ pattern , \ defined ( 'GLOB_BRACE' ) ? GLOB_BRACE : 0 ) ; } $ finder = new Finder ( ) ; $ regex = Glob :: toRegex ( $ pattern ) ; $ filesIterator = $ finder -> files ( ) -> followLinks ( ) -> sortByName ( ) -> in ( \ dirname ( $ pattern ) ) ; $ filesIterator = $ filesIterator -> filter ( function ( \ SplFileInfo $ info ) use ( $ regex ) { $ path = $ info -> getPathname ( ) ; return preg_match ( $ regex , $ path ) && $ info -> isFile ( ) ; } ) ; $ files = iterator_to_array ( $ filesIterator ) ; return array_keys ( $ files ) ; }
8653	private function convertUpdateReportAcknowledgements ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'UpdateReportAcknowledgements' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportIdList ( ) ) { $ reportIdList = $ request -> getReportIdList ( ) ; foreach ( $ reportIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
8135	public function displayBlock ( $ name , $ context = array ( ) ) { $ this -> template -> displayBlock ( $ name , $ this -> env -> mergeGlobals ( $ context ) ) ; }
2534	public function setSessionData ( array $ sessionData ) { if ( isset ( $ sessionData [ 'sessionId' ] , $ sessionData [ 'sequenceNumber' ] , $ sessionData [ 'securityToken' ] ) ) { $ this -> sessionData [ 'sessionId' ] = $ sessionData [ 'sessionId' ] ; $ this -> sessionData [ 'sequenceNumber' ] = $ sessionData [ 'sequenceNumber' ] ; $ this -> sessionData [ 'securityToken' ] = $ sessionData [ 'securityToken' ] ; $ this -> isAuthenticated = true ; } else { $ this -> isAuthenticated = false ; } return $ this -> isAuthenticated ; }
3381	public function hasRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles -> contains ( 'name' , $ role ) ; } return ! ! $ role -> intersect ( $ this -> roles ) -> count ( ) ; }
8029	public function registerFreeProcessId ( $ pid ) { $ processDetails = $ this -> getProcessDetails ( $ pid ) ; if ( $ processDetails !== NULL ) { $ this -> registerFreeProcess ( $ processDetails ) ; } return $ this ; }
5714	protected function filterFieldList ( Form $ form , FieldList $ actions ) { $ list = FieldList :: create ( ) ; foreach ( $ actions as $ a ) { if ( ! $ a instanceof BetterButtonInterface ) { throw new Exception ( "{$buttonObj->class} must implement BetterButtonInterface" ) ; } $ a -> bindGridField ( $ form , $ this -> owner ) ; if ( ! $ a -> shouldDisplay ( ) ) { continue ; } if ( ( $ a instanceof BetterButton_Versioned ) && ! $ this -> owner -> record -> checkVersioned ( ) ) { continue ; } $ list -> push ( $ a ) ; } return $ list ; }
9498	public function saveEntity ( BaseEntity $ entity , $ endPoint = '' , $ extraData = null ) { $ end_point = strtolower ( $ endPoint ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; $ method = $ entity -> getId ( ) ? 'put' : 'post' ; if ( $ method == 'post' ) { $ entity -> checkCreatable ( ) ; } $ changes = $ entity -> toArray ( true , $ extraData ) ; if ( empty ( $ changes ) ) { return null ; } $ request = $ this -> api -> $ method ( $ end_point , null , json_encode ( array ( $ baseName => $ changes ) ) ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ changeResult = new ChangeResult ( ) ; $ t = new $ type ( ) ; $ this -> manage ( $ t ) ; $ t -> fromArray ( $ result [ $ baseName ] ) ; $ changeResult -> setItem ( $ t ) ; if ( isset ( $ result [ 'audit' ] ) ) { $ audit = new TicketAudit ( ) ; $ audit -> fromArray ( $ result [ 'audit' ] ) ; $ changeResult -> setAudit ( $ audit ) ; } return $ changeResult ; } return null ; }
803	private function hasVoidReturnAnnotation ( Tokens $ tokens , $ index ) { foreach ( $ this -> findReturnAnnotations ( $ tokens , $ index ) as $ return ) { if ( [ 'void' ] === $ return -> getTypes ( ) ) { return true ; } } return false ; }
8156	public function addPath ( $ path , $ namespace = self :: MAIN_NAMESPACE ) { $ this -> cache = $ this -> errorCache = array ( ) ; $ checkPath = $ this -> isAbsolutePath ( $ path ) ? $ path : $ this -> rootPath . $ path ; if ( ! is_dir ( $ checkPath ) ) { throw new Twig_Error_Loader ( sprintf ( 'The "%s" directory does not exist ("%s").' , $ path , $ checkPath ) ) ; } $ this -> paths [ $ namespace ] [ ] = rtrim ( $ path , '/\\' ) ; }
7472	public function resetPasswordAction ( Request $ request , $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( ChangePasswordType :: class , null , array ( 'require_current' => false ) ) ; if ( $ request -> isMethod ( 'POST' ) ) { $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ data = $ form -> getData ( ) ; $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ user -> setPassword ( $ encoder -> encodePassword ( $ data [ 'password' ] , $ user -> getSalt ( ) ) ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The password has been changed.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ id ) ) ) ; } } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
6040	public function download ( $ sessionId , array $ downloads ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'downloads' => $ downloads ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/download' , $ parameters , true ) ; return $ result ; }
7983	public function addRestoreTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaRestoreTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
921	private function fixAnnotations ( DocBlock $ doc ) { foreach ( $ doc -> getAnnotations ( ) as $ index => $ annotation ) { $ next = $ doc -> getAnnotation ( $ index + 1 ) ; if ( null === $ next ) { break ; } if ( true === $ next -> getTag ( ) -> valid ( ) ) { if ( TagComparator :: shouldBeTogether ( $ annotation -> getTag ( ) , $ next -> getTag ( ) ) ) { $ this -> ensureAreTogether ( $ doc , $ annotation , $ next ) ; } else { $ this -> ensureAreSeparate ( $ doc , $ annotation , $ next ) ; } } } return $ doc -> getContent ( ) ; }
5967	public function tempPasswordList ( $ resolve = false ) { $ passwords = $ this -> request ( "servertemppasswordlist" ) -> toAssocArray ( "pw_clear" ) ; if ( $ resolve ) { foreach ( $ passwords as $ password => $ array ) { try { $ channel = $ this -> channelGetById ( $ array [ "tcid" ] ) ; $ passwords [ $ password ] [ "tcname" ] = $ channel -> toString ( ) ; $ passwords [ $ password ] [ "tcpath" ] = $ channel -> getPathway ( ) ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0xA00 ) { throw $ e ; } } } } return $ passwords ; }
5818	public function updateTagging ( $ fusionID ) { $ configuration = Config :: inst ( ) ; $ classes = ClassInfo :: subclassesFor ( 'DataObject' ) ; unset ( $ classes [ 'DataObject' ] ) ; foreach ( $ classes as $ class ) { $ extensions = $ configuration -> get ( $ class , 'extensions' , Config :: UNINHERITED ) ; if ( is_array ( $ extensions ) && in_array ( 'TaggingExtension' , $ extensions ) ) { $ mode = Versioned :: get_reading_mode ( ) ; Versioned :: reading_stage ( 'Stage' ) ; $ objects = $ class :: get ( ) -> filter ( 'FusionTags.ID' , $ fusionID ) ; if ( $ class :: has_extension ( $ class , 'Versioned' ) ) { foreach ( $ objects as $ object ) { $ object -> writeWithoutVersion ( ) ; } Versioned :: reading_stage ( 'Live' ) ; $ objects = $ class :: get ( ) -> filter ( 'FusionTags.ID' , $ fusionID ) ; foreach ( $ objects as $ object ) { $ object -> writeWithoutVersion ( ) ; } } else { foreach ( $ objects as $ object ) { $ object -> write ( ) ; } } Versioned :: set_reading_mode ( $ mode ) ; } } }
3239	private function resetCalculations ( ) { $ this -> shopCalculations = null ; if ( Config :: get ( 'shop.cache_calculations' ) ) { Cache :: forget ( $ this -> calculationsCacheKey ) ; } }
329	public function buildKey ( $ key ) { if ( is_string ( $ key ) ) { $ key = ctype_alnum ( $ key ) && StringHelper :: byteLength ( $ key ) <= 32 ? $ key : md5 ( $ key ) ; } else { if ( $ this -> _igbinaryAvailable ) { $ serializedKey = igbinary_serialize ( $ key ) ; } else { $ serializedKey = serialize ( $ key ) ; } $ key = md5 ( $ serializedKey ) ; } return $ this -> keyPrefix . $ key ; }
7389	public function getResponse ( array $ packageList , array $ languageList , array $ customRouteList , string $ url = '' ) : Response { $ request = new Request ( $ languageList , $ packageList , $ url ) ; $ this -> packageRoot .= 'package/' . $ request -> package ( ) . '/' ; try { if ( isset ( $ customRouteList [ $ request -> package ( ) ] ) ) { $ path = $ this -> packageRoot . 'CustomRoute.php' ; if ( file_exists ( $ path ) ) { require $ path ; $ route = $ request -> package ( ) . '\\CustomRoute' ; $ route = new $ route ( ) ; $ this -> response = $ route -> getResponse ( $ this -> packageRoot , $ request ) ; if ( $ this -> response -> is404 ( ) ) { $ this -> set404 ( ) ; } return $ this -> response ; } else { throw new RouteException ( sprintf ( 'The file "%s" does not exist' , $ path ) ) ; } } else { $ this -> response = ( new DefaultRoute ( ) ) -> getResponse ( $ this -> packageRoot , $ request ) ; if ( $ this -> response -> is404 ( ) ) { $ this -> set404 ( ) ; } return $ this -> response ; } } catch ( RouteException $ e ) { if ( Wrap :: isEnabled ( ) ) { throw $ e ; } else { $ this -> response = new Response ( ) ; $ this -> set404 ( ) ; return $ this -> response ; } } }
3222	function createShareableLink ( $ path ) { Path :: checkArg ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/shares" , $ path ) , array ( "short_url" => "false" , ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ j = RequestUtil :: parseResponseJson ( $ response -> body ) ; return self :: getField ( $ j , "url" ) ; }
11488	public function setName ( string $ name ) : void { if ( ! empty ( $ name ) ) { if ( ! is_numeric ( $ name ) ) { @ session_name ( $ name ) ; } else { throw new Exception ( 'The session name can\'t consist only of digits, ' . 'at least one letter must be presented.' ) ; } } else { throw new Exception ( 'Empty session name value was passed.' ) ; } }
2284	protected static function ip ( ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { return '' ; } return $ request -> getClientIp ( ) ; }
10126	private function writeGuts ( ) { $ record = 0x0080 ; $ length = 0x0008 ; $ dxRwGut = 0x0000 ; $ dxColGut = 0x0000 ; $ maxRowOutlineLevel = 0 ; foreach ( $ this -> phpSheet -> getRowDimensions ( ) as $ rowDimension ) { $ maxRowOutlineLevel = max ( $ maxRowOutlineLevel , $ rowDimension -> getOutlineLevel ( ) ) ; } $ col_level = 0 ; $ colcount = count ( $ this -> columnInfo ) ; for ( $ i = 0 ; $ i < $ colcount ; ++ $ i ) { $ col_level = max ( $ this -> columnInfo [ $ i ] [ 5 ] , $ col_level ) ; } $ col_level = max ( 0 , min ( $ col_level , 7 ) ) ; if ( $ maxRowOutlineLevel ) { ++ $ maxRowOutlineLevel ; } if ( $ col_level ) { ++ $ col_level ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ dxRwGut , $ dxColGut , $ maxRowOutlineLevel , $ col_level ) ; $ this -> append ( $ header . $ data ) ; }
2882	protected function _initEmail ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ index = $ this -> getRequest ( ) -> getParam ( 'index' ) ; if ( $ token === null || $ index === null ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return null ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return null ; } $ emails = $ requestProfile -> getEmails ( ) ; if ( ! $ emails || ! ( $ index < count ( $ emails ) ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'E-mail not found' ) ; return null ; } return $ emails [ ( int ) $ index ] ; }
2316	protected function prepareResizeConfig ( ) { $ resizeConfig = new ResizeConfiguration ( ) ; $ resizeConfig -> setWidth ( $ this -> targetWidth ) ; $ resizeConfig -> setHeight ( $ this -> targetHeight ) ; $ resizeConfig -> setZoomLevel ( $ this -> zoomLevel ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; $ resizeConfig -> setZoomLevel ( 0 ) ; } else { try { $ resizeConfig -> setMode ( $ this -> resizeMode ) ; } catch ( \ InvalidArgumentException $ exception ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; } } return $ resizeConfig ; }
2362	public static function findFirstActiveWithJumpToByIds ( $ arrIds ) { @ trigger_error ( 'Using MemberGroupModel::findFirstActiveWithJumpToByIds() has been deprecated and will no longer work in Contao 5.0. Use PageModel::findFirstActiveByMemberGroups() instead.' , E_USER_DEPRECATED ) ; if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } return new static ( $ objResult ) ; }
12154	public function getRequiredRoles ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = false ; switch ( $ roleItem -> systemId ) { case 'owner' : $ test = $ this -> isOwnable ; break ; } if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
4054	private function fetchGroupSort ( $ inputScreenId , IMetaModel $ metaModel ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return array_map ( function ( $ information ) use ( $ inputScreenId , $ metaModel ) { $ information [ 'isdefault' ] = ( bool ) $ information [ 'isdefault' ] ; $ information [ 'ismanualsort' ] = ( bool ) $ information [ 'ismanualsort' ] ; $ information [ 'rendergrouplen' ] = ( int ) $ information [ 'rendergrouplen' ] ; if ( $ information [ 'ismanualsort' ] ) { $ information [ 'rendergrouptype' ] = 'none' ; } if ( ! empty ( $ information [ 'rendersortattr' ] ) ) { if ( ! ( $ attribute = $ metaModel -> getAttributeById ( $ information [ 'rendersortattr' ] ) ) ) { @ trigger_error ( sprintf ( 'Unknown attribute "%1$s" in group sorting "%2$s.%3$s"' , $ information [ 'rendersortattr' ] , $ inputScreenId , $ information [ 'id' ] ) , E_USER_WARNING ) ; return $ information ; } $ information [ 'col_name' ] = $ attribute -> getColName ( ) ; } return $ information ; } , $ builder -> select ( '*' ) -> from ( 'tl_metamodel_dca_sortgroup' ) -> where ( 'pid=:screenId' ) -> setParameter ( 'screenId' , $ inputScreenId ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; }
408	public function get ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getQueryParams ( ) ; } return $ this -> getQueryParam ( $ name , $ defaultValue ) ; }
7883	public function getDelete ( $ date ) { try { LogViewer :: delete ( $ date ) ; $ today = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; return Redirect :: to ( 'logviewer/' . $ today . '/all' ) -> with ( 'success' , 'Log deleted successfully!' ) ; } catch ( \ Exception $ e ) { return Redirect :: to ( 'logviewer/' . $ date . '/all' ) -> with ( 'error' , 'There was an error while deleting the log.' ) ; } }
4848	public function destinationsFor ( string $ filePath ) : array { $ filePath = Path :: canonicalize ( $ filePath ) ; $ source = $ this -> matchingSource ( $ filePath ) ; return $ this -> resolveDestinations ( $ filePath , $ source ) ; }
5631	public function paintFooter ( $ test_name ) { ob_start ( ) ; parent :: paintFooter ( $ test_name ) ; $ output = trim ( ob_get_clean ( ) ) ; if ( $ output ) { if ( ( $ this -> getFailCount ( ) + $ this -> getExceptionCount ( ) ) == 0 ) { $ color = $ this -> _passColor ; } else { $ color = $ this -> _failColor ; } $ this -> _setColor ( $ color ) ; echo $ output ; $ this -> _resetColor ( ) ; } }
3161	protected function getTransmissionId ( QtiRunnerServiceContext $ context , $ itemId = null ) { if ( is_null ( $ itemId ) ) { $ itemId = $ context -> getCurrentAssessmentItemRef ( ) ; } elseif ( $ itemId != $ context -> getCurrentAssessmentItemRef ( ) ) { throw new \ common_exception_NotImplemented ( 'Item variables can be stored only for the current item' ) ; } $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ currentOccurrence = $ context -> getTestSession ( ) -> getCurrentAssessmentItemRefOccurence ( ) ; return $ sessionId . '.' . $ itemId . '.' . $ currentOccurrence ; }
8166	public function write ( ) { $ strings = func_get_args ( ) ; foreach ( $ strings as $ string ) { $ this -> source .= str_repeat ( ' ' , $ this -> indentation * 4 ) . $ string ; } return $ this ; }
7030	public function toArray ( ) { return [ 'o_msg' => $ this -> overflowMessage , 'min_qty' => $ this -> minimumQuantity , 'min_msg' => $ this -> minimumMessage , 'max_qty' => INF === $ this -> maximumQuantity ? 'INF' : $ this -> maximumQuantity , 'max_msg' => $ this -> maximumMessage , 'a_qty' => INF === $ this -> availableQuantity ? 'INF' : $ this -> availableQuantity , 'a_msg' => $ this -> availableMessage , 'r_qty' => $ this -> resupplyQuantity , 'r_msg' => $ this -> resupplyMessage , ] ; }
12072	private function getForcedCustomersIds ( ) { $ mlmIds = array_keys ( $ this -> QUALIFIED_CUSTOMERS ) ; $ where = '' ; foreach ( $ mlmIds as $ one ) { if ( strlen ( $ where ) > 0 ) { $ where .= ' OR ' ; } $ quoted = $ this -> conn -> quote ( $ one ) ; $ where .= Customer :: A_MLM_ID . "=\"$quoted\"" ; } $ cols = [ Customer :: A_CUSTOMER_REF , Customer :: A_MLM_ID ] ; $ result = $ this -> daoGeneric -> getEntities ( Customer :: ENTITY_NAME , $ cols , $ where ) ; return $ result ; }
9747	public function setTimeZone ( $ timezone ) { if ( ! $ timezone ) { return $ this ; } try { Carbon :: now ( $ timezone ) ; } catch ( \ Exception $ e ) { $ this -> invalidArguments ( '10004' , sprintf ( 'Invalid timezone set "%s"' , $ timezone ) ) ; } return $ this -> setParameter ( 'timezone' , $ timezone ) ; }
10019	public function addCellXf ( Style $ style ) { $ this -> cellXfCollection [ ] = $ style ; $ style -> setIndex ( count ( $ this -> cellXfCollection ) - 1 ) ; }
12510	public function buildPreview ( $ by ) { if ( ! in_array ( $ by , $ this -> previewBys , true ) ) { throw new InvalidArgumentException ( 'This preview by not exist.' ) ; } if ( empty ( $ this -> msgType ) ) { throw new RuntimeException ( 'Message type not exist.' ) ; } elseif ( $ this -> msgType === Broadcast :: MSG_TYPE_VIDEO ) { if ( is_array ( $ this -> message ) ) { $ this -> message = array_shift ( $ this -> message ) ; } $ this -> msgType = 'mpvideo' ; } if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message content to send.' ) ; } if ( empty ( $ this -> to ) ) { throw new RuntimeException ( 'No to.' ) ; } $ content = ( new Transformer ( $ this -> msgType , $ this -> message ) ) -> transform ( ) ; $ message = array_merge ( $ this -> buildTo ( $ this -> to , $ by ) , $ content ) ; return $ message ; }
11849	protected function getSettingsFromRealSource ( $ namespace ) { $ arraySettings = $ this -> getSettingsArray ( $ namespace ) ; $ namespaceOptions = $ this -> options -> getNamespaceOptions ( $ namespace ) ; $ entity = clone ( $ namespaceOptions -> getEntityPrototype ( ) ) ; if ( ! empty ( $ arraySettings ) ) { $ hydrator = $ this -> namespaceHydratorProvider -> getHydrator ( $ namespace ) ; $ entity = $ hydrator -> hydrate ( $ arraySettings , $ entity ) ; } return $ entity ; }
10290	protected function storeLastRun ( ) { if ( ! @ file_put_contents ( $ this -> lockDir . '/lastRun' , time ( ) ) ) { $ this -> logger -> log ( 'Failure storing last run time: ' . ( isset ( $ php_errormsg ) ? $ php_errormsg : 'Unknown error - enable the track_errors ini directive.' ) , Logger :: ERROR ) ; return ; } $ this -> logger -> log ( 'Stored last run time.' , Logger :: INFO ) ; }
9781	private function setFlag ( string $ name , bool $ value = true ) : self { $ this -> flags [ $ name ] = $ value ; return $ this ; }
9502	public function runPeridot ( InputInterface $ input , OutputInterface $ output ) { global $ argv ; $ command = $ this -> joinCommand ( $ argv ) ; $ process = new Process ( $ command ) ; $ process -> run ( function ( $ type , $ buffer ) use ( $ output ) { $ buffer = preg_replace ( '/\[([\d]{1,2})m/' , "\033[$1m" , $ buffer ) ; $ output -> write ( $ buffer ) ; } ) ; }
3972	public function decodeAttributeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ attribute = $ metaModel -> getAttributeById ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ) ; } }
10526	public function setFieldFromData ( $ name ) { $ value = $ this -> getFieldFormData ( $ name ) ; return $ this -> setFieldValue ( $ name , $ value ) ; }
2106	public function getMaxUploadFileSize ( ) { $ objResult = Database :: getInstance ( ) -> prepare ( "SELECT MAX(maxlength) AS maxlength FROM tl_form_field WHERE pid=? AND invisible='' AND type='upload' AND maxlength>0" ) -> execute ( $ this -> id ) ; if ( $ objResult -> numRows > 0 && $ objResult -> maxlength > 0 ) { return $ objResult -> maxlength ; } else { return Config :: get ( 'maxFileSize' ) ; } }
1739	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'login' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( ! $ _POST && $ this -> redirectBack && ( $ strReferer = $ this -> getReferer ( ) ) != Environment :: get ( 'request' ) ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ strReferer ; } return parent :: generate ( ) ; }
8336	public function setValueMutator ( callable $ callback ) : self { $ this -> valueMutator = $ callback ; $ this -> value = ( $ this -> valueMutator ) ( $ this -> value ) ; return $ this ; }
11428	public function toSelect ( array & $ optgroups = [ ] , $ level = 1 , $ root = true ) { $ options = [ ] ; foreach ( $ this -> items as $ item ) { $ options [ ] = $ item -> toSelect ( ) ; } if ( $ root === true ) { $ text = $ this -> text ; } else { $ text = '|' . str_repeat ( '-' , $ level ) . ' ' . $ this -> text ; } $ optgroups [ ] = [ 'text' => $ text , 'options' => $ options , ] ; foreach ( $ this -> groups as $ group ) { $ group -> toSelect ( $ optgroups , $ level + 1 , false ) ; } }
10121	private function writeMarginBottom ( ) { $ record = 0x0029 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getBottom ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
2657	public function createResponse ( $ version , array $ response ) { $ checkIfExists = $ this -> getResponse ( $ version , $ response [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/response_object' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ response [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ response ) ; return $ result ; }
7020	private function format_i ( & $ str ) { if ( strstr ( $ str , '%i' ) ) $ str = str_replace ( '%i' , sprintf ( '%02d' , $ this -> min ) , $ str ) ; }
1570	public function getResource ( ) { $ resource = $ this -> parameter ( ResourceRegistrar :: PARAM_RESOURCE_ID ) ; return is_object ( $ resource ) ? $ resource : null ; }
12320	public static function getBundleLocationName ( string $ sName ) : string { $ oConfig = self :: get ( $ sName , null , true ) ; if ( isset ( $ oConfig -> redirect ) ) { return $ oConfig -> redirect ; } else { return PORTAL ; } }
11776	public function getHelper ( ) { if ( $ this -> helper === null ) { $ this -> helper = $ this -> command -> getHelper ( 'question' ) ; } return $ this -> helper ; }
9279	public function save ( JobEntity $ job ) { $ query = null ; if ( ( int ) $ job -> getId ( ) == 0 ) { $ query = $ this -> sql -> insert ( ) ; $ query -> values ( $ job -> getArrayCopy ( ) ) ; } else { $ query = $ this -> sql -> update ( ) ; $ query -> set ( $ job -> getArrayCopy ( ) ) ; $ query -> where ( array ( 'id' => $ job -> getId ( ) ) ) ; } $ stmt = $ this -> sql -> prepareStatementForSqlObject ( $ query ) ; $ res = $ stmt -> execute ( ) ; if ( ( int ) $ job -> getId ( ) == 0 ) { $ job -> setId ( ( int ) $ res -> getGeneratedValue ( ) ) ; } return $ job ; }
1913	protected function generateCaptcha ( ) { if ( $ this -> arrCaptcha ) { return ; } $ int1 = random_int ( 1 , 9 ) ; $ int2 = random_int ( 1 , 9 ) ; $ this -> arrCaptcha = array ( 'int1' => $ int1 , 'int2' => $ int2 , 'sum' => $ int1 + $ int2 , 'key' => $ this -> strCaptchaKey , 'hashes' => $ this -> generateHashes ( $ int1 + $ int2 ) ) ; }
11636	public function getDeviceByPageId ( $ pageId , $ begin , $ count ) { $ params = [ 'type' => 2 , 'page_id' => intval ( $ pageId ) , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RELATION_SEARCH , $ params ] ) ; }
8471	public function critical ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'critical' , $ scope , $ message , $ context , $ config ) ; }
1807	public function storeDateAdded ( $ dc ) { if ( ! $ dc instanceof Contao \ DataContainer ) { return ; } if ( ! $ dc -> activeRecord || $ dc -> activeRecord -> dateAdded > 0 ) { return ; } if ( $ dc -> activeRecord -> lastLogin > 0 ) { $ time = $ dc -> activeRecord -> lastLogin ; } else { $ time = time ( ) ; } $ this -> Database -> prepare ( "UPDATE tl_member SET dateAdded=? WHERE id=?" ) -> execute ( $ time , $ dc -> id ) ; }
6957	private function _getRenderedToc ( $ list , $ depth = 1 ) { if ( ! isset ( $ list ) || empty ( $ list ) ) return ( '' ) ; $ html = "<ul class=\"toc-list\">\n" ; foreach ( $ list as $ entry ) { $ html .= "<li class=\"toc-entry\">\n" ; $ html .= '<a href="#' . $ this -> getParam ( 'anchorsPrefix' ) . $ this -> titleToIdentifier ( $ depth , $ entry [ 'value' ] ) . '">' . $ entry [ 'value' ] . "</a>\n" ; if ( isset ( $ entry [ 'sub' ] ) ) $ html .= $ this -> _getRenderedToc ( $ entry [ 'sub' ] , ( $ depth + 1 ) ) ; $ html .= "</li>\n" ; } $ html .= "</ul>\n" ; return ( $ html ) ; }
8575	public function setItemChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7993	public function getDiskUsage ( $ diskId , $ type ) { return json_decode ( self :: getClient ( ) -> getDiskUsage ( $ this -> getDomain ( ) , $ diskId , $ type ) ) ; }
7092	protected function add ( $ url , $ method , Callable $ action ) { $ url = $ this -> base !== "" && $ url === "/" ? $ this -> base : $ this -> base . $ url ; $ route = new Route ( $ url , $ method , $ action ) ; $ this -> routes [ ] = $ route ; return $ route ; }
5637	public function paintError ( $ message ) { parent :: paintError ( $ message ) ; print 'Exception ' . $ this -> getExceptionCount ( ) . "!\n$message\n" ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print "\tin " . implode ( "\n\tin " , array_reverse ( $ breadcrumb ) ) ; print "\n" ; }
11042	function store_text ( & $ elts , & $ i , $ ptype , $ ntext , $ ctext ) { if ( $ ntext == 1 && $ ptype != _ETS_ROOT ) { $ elts [ _ETS_TEXT . ':' . $ i ] = $ ctext ; } }
12900	public function offsetGet ( $ offset ) { if ( $ offset === 'headers' ) { $ headers = [ 'HTTP/' . $ this -> getResponse ( ) -> getProtocolVersion ( ) . ' ' . $ this -> getResponse ( ) -> getStatusCode ( ) . ' ' . $ this -> getResponse ( ) -> getReasonPhrase ( ) ] ; foreach ( $ this -> getResponse ( ) -> getHeaders ( ) as $ header => $ values ) { foreach ( $ values as $ value ) { $ headers [ ] = $ header . ': ' . $ value ; } } return $ headers ; } }
371	public function isColorEnabled ( $ stream = \ STDOUT ) { return $ this -> color === null ? Console :: streamSupportsAnsiColors ( $ stream ) : $ this -> color ; }
6337	public function parse ( SaxHandlerInterface $ saxHandler , $ xmlDocument ) { $ xmlDocument = ( $ xmlDocument instanceof StreamInterface ) ? $ xmlDocument : $ this -> getDocumentStream ( $ xmlDocument ) ; return $ saxHandler -> parse ( $ xmlDocument ) ; }
10372	public static function add_styles ( ) { self :: look_if_process_files ( 'style' ) ; foreach ( self :: $ data [ 'style' ] as $ data ) { wp_register_style ( $ data [ 'name' ] , $ data [ 'url' ] , $ data [ 'deps' ] , $ data [ 'version' ] , $ data [ 'media' ] ) ; wp_enqueue_style ( $ data [ 'name' ] ) ; } }
5946	public function property ( $ systemName , $ preloadNames = false , $ categoryIds = null , $ deploymentSiteIds = null , $ isHierarchical = false , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'preloadNames' => $ preloadNames , 'categoryIds' => $ categoryIds , 'deploymentSiteIds' => $ deploymentSiteIds , 'isHierarchical' => $ isHierarchical , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/property/' . $ systemName . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
826	public function isBeforeStructuralElement ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_COMMENT , T_DOC_COMMENT ] ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ nextIndex = $ index ; do { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ; } while ( null !== $ nextIndex && $ tokens [ $ nextIndex ] -> equals ( '(' ) ) ; if ( null === $ nextIndex || $ tokens [ $ nextIndex ] -> equals ( '}' ) ) { return false ; } $ nextToken = $ tokens [ $ nextIndex ] ; if ( $ this -> isStructuralElement ( $ nextToken ) ) { return true ; } if ( $ this -> isValidControl ( $ tokens , $ token , $ nextIndex ) ) { return true ; } if ( $ this -> isValidVariable ( $ tokens , $ nextIndex ) ) { return true ; } if ( $ this -> isValidLanguageConstruct ( $ tokens , $ token , $ nextIndex ) ) { return true ; } return false ; }
318	public function registerCssFile ( $ url , $ options = [ ] , $ key = null ) { $ url = Yii :: getAlias ( $ url ) ; $ key = $ key ? : $ url ; $ depends = ArrayHelper :: remove ( $ options , 'depends' , [ ] ) ; if ( empty ( $ depends ) ) { $ this -> cssFiles [ $ key ] = Html :: cssFile ( $ url , $ options ) ; } else { $ this -> getAssetManager ( ) -> bundles [ $ key ] = Yii :: createObject ( [ 'class' => AssetBundle :: className ( ) , 'baseUrl' => '' , 'css' => [ strncmp ( $ url , '//' , 2 ) === 0 ? $ url : ltrim ( $ url , '/' ) ] , 'cssOptions' => $ options , 'depends' => ( array ) $ depends , ] ) ; $ this -> registerAssetBundle ( $ key ) ; } }
5290	protected static function requestCurl ( $ url , $ params ) { $ ch = curl_init ( ) ; $ options = array ( CURLOPT_URL => $ url , CURLOPT_HTTPHEADER => self :: getHeaders ( ) , CURLOPT_POSTFIELDS => json_encode ( $ params ) , CURLOPT_CONNECTTIMEOUT => self :: $ connectTimeout , CURLOPT_TIMEOUT => self :: $ requestTimeout , CURLOPT_USERAGENT => self :: getUserAgent ( ) , CURLOPT_RETURNTRANSFER => true ) ; curl_setopt_array ( $ ch , $ options ) ; $ result = curl_exec ( $ ch ) ; if ( $ result === false ) { $ e = new Error ( curl_error ( $ ch ) ) ; curl_close ( $ ch ) ; throw $ e ; } curl_close ( $ ch ) ; return $ result ; }
8578	public function setItemFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8794	protected function writeNewEnvironmentFileWith ( $ key ) { file_put_contents ( base_path ( '.env' ) , preg_replace ( $ this -> keyReplacementPattern ( ) , 'APP_KEY=' . $ key , file_get_contents ( base_path ( '.env' ) ) ) ) ; }
10699	public static function isBirthDate ( $ date ) { if ( $ date === null || $ date === '0000-00-00' ) { return true ; } if ( preg_match ( '/^(\d{4})-((?:0?[1-9])|(?:1[0-2]))-((?:0?[1-9])|(?:[1-2]\d)|(?:3[01]))(\d{2}:\d{2}:\d{2})?$/' , $ date , $ birth_date ) ) { return ! ( ( $ birth_date [ 1 ] > date ( 'Y' ) && $ birth_date [ 2 ] > date ( 'm' ) && $ birth_date [ 3 ] > date ( 'd' ) ) || ( $ birth_date [ 1 ] === date ( 'Y' ) && $ birth_date [ 2 ] === date ( 'm' ) && $ birth_date [ 3 ] > date ( 'd' ) ) || ( $ birth_date [ 1 ] === date ( 'Y' ) && $ birth_date [ 2 ] > date ( 'm' ) ) ) ; } return false ; }
8084	public function clearErrors ( $ channelName = '' ) { $ channel = $ this -> namespaceChannel ( $ channelName ) ; $ this -> console [ 'errors' ] [ $ channel ] = array ( ) ; $ this -> console [ 'form' ] [ $ channel ] = array ( ) ; }
3814	private function injectServiceContainerIntoDataDrivers ( $ providerDefinitions , $ environment ) { foreach ( $ providerDefinitions as $ provider ) { $ providerInstance = $ environment -> getDataProvider ( $ provider -> getName ( ) ) ; if ( $ providerInstance instanceof Driver ) { $ initialization = $ provider -> getInitializationData ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ initialization [ 'source' ] ) ; $ providerInstance -> setBaseConfig ( array_merge ( $ initialization , [ 'metaModel' => $ metaModel ] ) ) ; $ providerInstance -> setDispatcher ( $ this -> dispatcher ) ; $ providerInstance -> setConnection ( $ this -> connection ) ; } } }
12346	private function createDeleteForm ( Post $ post ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_category_delete' , array ( 'id' => $ post -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
675	public function getPage ( $ recalculate = false ) { if ( $ this -> _page === null || $ recalculate ) { $ page = ( int ) $ this -> getQueryParam ( $ this -> pageParam , 1 ) - 1 ; $ this -> setPage ( $ page , true ) ; } return $ this -> _page ; }
6243	public function isInOpenBasedir ( ) : bool { if ( ! $ this -> loaded ) { $ this -> resolvePath ( ) ; } static $ openBaseDirs = null ; if ( $ openBaseDirs === null ) { $ openBaseDirs = array_filter ( explode ( ':' , trim ( ini_get ( 'open_basedir' ) ) ) , function ( $ dir ) : bool { return ! empty ( $ dir ) ; } ) ; } if ( empty ( $ openBaseDirs ) ) { return true ; } foreach ( ( array ) $ openBaseDirs as $ dir ) { $ dir = realpath ( $ dir ) ; if ( stripos ( $ this -> raw , $ dir ) === 0 ) { return true ; } } return false ; }
2921	public function save ( $ filePath ) { $ this -> ensureFileIsWritable ( $ filePath ) ; file_put_contents ( $ filePath , $ this -> buffer ) ; return $ this ; }
9157	final public function call ( $ action , Request $ request , View $ view ) { $ this -> request = $ request ; ob_start ( ) ; $ rf = new \ ReflectionMethod ( $ this , $ action ) ; $ anno = $ rf -> getDocComment ( ) ; $ matches = array ( ) ; if ( preg_match ( '#@responseType ([\w\/]+)#' , $ anno , $ matches ) ) { $ this -> response -> setType ( $ matches [ 1 ] ) ; } if ( preg_match ( '#@title ([^\\n]+)#' , $ anno , $ matches ) ) { $ this -> response -> setTitle ( $ matches [ 1 ] ) ; } $ rf -> invoke ( $ this , $ this -> request ) ; $ this -> response -> appendBody ( ob_get_clean ( ) ) ; $ view -> render ( $ this -> response , $ request , $ this -> viewParams ) ; $ this -> addControls ( $ this -> response , $ request , $ view ) ; return $ this -> response ; }
8553	public function setDebtRecoveryEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DebtRecoveryEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12550	public function installAssets ( ) { $ this -> doInstallAssets ( $ this -> core ) ; $ this -> doInstallAssets ( $ this -> blocks ) ; $ this -> doInstallAssets ( $ this -> themes ) ; }
9776	function throw ( string $ className = '' ) : self { if ( ! is_callable ( $ this -> target ) ) throw new \ BadMethodCallException ( 'The function target is not callable.' ) ; $ exception = null ; try { call_user_func ( $ this -> target ) ; } catch ( \ Throwable $ e ) { $ exception = $ e ; } $ constraint = logicalNot ( isNull ( ) ) ; return $ this -> expect ( $ exception , mb_strlen ( $ className ) ? logicalAnd ( $ constraint , isInstanceOf ( $ className ) ) : $ constraint ) ; }
6071	public function uploadFileChunked ( $ fileData , $ name , $ chunk , $ chunks , $ fileId , $ categoryId , $ title = null ) { $ parameters = [ 'query' => [ 'name' => $ name , 'chunk' => $ chunk , 'chunks' => $ chunks , 'fileId' => $ fileId , 'categoryId' => $ categoryId , 'title' => $ title , ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => $ name , ] , ] , 'headers' => null , ] ; $ result = $ this -> post ( 'v1/media.json' , $ parameters ) ; return $ result ; }
6320	public function getColumn ( $ name ) { foreach ( $ this -> columns as $ column ) { if ( $ column -> getName ( ) == $ name ) { return $ column ; } } return null ; }
12389	protected function updateCredentialHash ( PasswordableInterface $ identityObject , $ password ) { $ cryptoService = $ this -> getMapper ( ) -> getPasswordService ( ) ; if ( ! $ cryptoService instanceof Bcrypt ) { return $ this ; } $ hash = explode ( '$' , $ identityObject -> getPassword ( ) ) ; if ( $ hash [ 2 ] === $ cryptoService -> getCost ( ) ) { return $ this ; } $ identityObject -> setPassword ( $ cryptoService -> create ( $ password ) ) ; return $ this ; }
11749	public function material ( ) { if ( is_null ( $ this -> material ) ) { $ this -> material = new Material ( $ this -> accessToken ) ; } return $ this -> material ; }
6773	protected function isTaxationUpdateNeeded ( SaleInterface $ sale ) { if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'taxExempt' , 'customer' , 'vatValid' ] ) ) { return true ; } return $ this -> didDeliveryCountryChanged ( $ sale ) ; }
7201	public function getUnit ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> unit ) : $ this -> unit ; }
11733	public function publish ( $ pageName , $ languageName ) { $ this -> contributorDefined ( ) ; $ baseDir = $ this -> pagesDir . '/' . $ pageName ; $ pageCollectionSourceFile = $ baseDir . '/' . $ this -> username . '.json' ; $ pageCollectionTargetFile = $ baseDir . '/page.json' ; $ pageDir = $ baseDir . '/' . $ languageName ; $ pageSourceFile = $ pageDir . '/' . $ this -> username . '.json' ; $ pageTargetFile = $ pageDir . '/seo.json' ; Dispatcher :: dispatch ( PageEvents :: PAGE_PUBLISHING , new PagePublishingEvent ( ) ) ; copy ( $ pageCollectionSourceFile , $ pageCollectionTargetFile ) ; copy ( $ pageSourceFile , $ pageTargetFile ) ; Dispatcher :: dispatch ( PageEvents :: PAGE_PUBLISHED , new PagePublishedEvent ( ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" for language "%s" was published in production' , $ pageName , $ languageName ) ) ; }
1069	private function collectConflictsBetweenFieldsAndFragment ( ValidationContext $ context , array & $ conflicts , array & $ comparedFragments , $ areMutuallyExclusive , array $ fieldMap , $ fragmentName ) { if ( isset ( $ comparedFragments [ $ fragmentName ] ) ) { return ; } $ comparedFragments [ $ fragmentName ] = true ; $ fragment = $ context -> getFragment ( $ fragmentName ) ; if ( ! $ fragment ) { return ; } [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getReferencedFieldsAndFragmentNames ( $ context , $ fragment ) ; if ( $ fieldMap === $ fieldMap2 ) { return ; } $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; for ( $ i = 0 ; $ i < $ fragmentNames2Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap , $ fragmentNames2 [ $ i ] ) ; } }
10169	public function write ( Spreadsheet $ spreadsheet = null ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-settings' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:config' , 'urn:oasis:names:tc:opendocument:xmlns:config:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:settings' ) ; $ objWriter -> startElement ( 'config:config-item-set' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'ooo:view-settings' ) ; $ objWriter -> startElement ( 'config:config-item-map-indexed' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'Views' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'config:config-item-set' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'ooo:configuration-settings' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
9462	private function getEventMap ( ) { return [ WatcherInterface :: CREATE_EVENT => FilesystemEvent :: CREATE , WatcherInterface :: MODIFY_EVENT => FilesystemEvent :: MODIFY , WatcherInterface :: DELETE_EVENT => FilesystemEvent :: DELETE , WatcherInterface :: ALL_EVENT => FilesystemEvent :: ALL ] ; }
11345	public function render ( ) { $ html = $ this -> formatter -> renderFormBegin ( $ this -> formTags ) ; foreach ( $ this -> fields as $ field ) { $ html .= $ this -> formatter -> renderField ( $ field ) ; } $ html .= $ this -> renderSubmit ( ) ; $ html .= $ this -> renderEnd ( ) ; return $ html ; }
5586	public function restart ( $ date = false ) { $ this -> cookie_jar -> restartSession ( $ date ) ; $ this -> authenticator -> restartSession ( ) ; $ this -> http_referer = null ; }
6562	public static function joinPath ( $ base , $ path ) { if ( substr ( $ path , 0 , 1 ) === '/' ) { return $ path ; } if ( substr ( $ base , 0 , 1 ) !== '/' ) { return false ; } $ pathParts = self :: splitPath ( $ path ) ; $ resultParts = self :: splitPath ( $ base ) ; while ( ( $ part = array_shift ( $ pathParts ) ) !== null ) { switch ( $ part ) { case '.' : break ; case '..' : if ( count ( $ resultParts ) > 1 ) { array_pop ( $ resultParts ) ; } break ; default : $ resultParts [ ] = $ part ; break ; } } return implode ( '/' , $ resultParts ) ; }
2309	public function getImportantPart ( ) { if ( $ this -> importantPart ) { return $ this -> importantPart ; } return array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight ) ; }
2379	public static function deserialize ( $ varValue , $ blnForceArray = false ) { if ( \ is_array ( $ varValue ) ) { return $ varValue ; } if ( $ varValue === null ) { return $ blnForceArray ? array ( ) : null ; } if ( ! \ is_string ( $ varValue ) ) { return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } if ( trim ( $ varValue ) == '' ) { return $ blnForceArray ? array ( ) : '' ; } if ( strncmp ( $ varValue , 'a:' , 2 ) !== 0 ) { return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } if ( preg_match ( '/[OoC]:\+?[0-9]+:"/' , $ varValue ) ) { trigger_error ( 'StringUtil::deserialize() does not allow serialized objects' , E_USER_WARNING ) ; return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } $ varUnserialized = @ unserialize ( $ varValue , array ( 'allowed_classes' => false ) ) ; if ( \ is_array ( $ varUnserialized ) ) { $ varValue = $ varUnserialized ; } elseif ( $ blnForceArray ) { $ varValue = array ( $ varValue ) ; } return $ varValue ; }
5522	public function generate ( $ methods ) { if ( ! $ this -> reflection -> classOrInterfaceExists ( ) ) { return false ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { return false ; } $ code = $ this -> createCodeForClass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; }
11517	protected function GenerateIOSPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ IOSPinicon ) { $ metadata .= $ this -> owner -> MarkupComment ( 'iOS Pinned Icon' ) ; if ( $ config -> fetchPiniconTitle ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'apple-mobile-web-app-title' , $ config -> fetchPiniconTitle ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 57 , 57 ) -> getAbsoluteURL ( ) , 'image/png' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 60 , 60 ) -> getAbsoluteURL ( ) , 'image/png' , '60x60' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'image/png' , '72x72' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 76 , 76 ) -> getAbsoluteURL ( ) , 'image/png' , '76x76' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 114 , 114 ) -> getAbsoluteURL ( ) , 'image/png' , '114x114' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 120 , 120 ) -> getAbsoluteURL ( ) , 'image/png' , '120x120' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'image/png' , '144x144' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 152 , 152 ) -> getAbsoluteURL ( ) , 'image/png' , '152x152' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 180 , 180 ) -> getAbsoluteURL ( ) , 'image/png' , '180x180' ) ; }
11302	public function loadAll ( ) { $ this -> data -> id = $ this -> id ; foreach ( $ this -> model_attributes as $ key => $ value ) { $ temp = $ this -> $ key ; } }
1950	public function resendToken ( Contao \ DataContainer $ dc ) { $ model = Contao \ OptInModel :: findByPk ( $ dc -> id ) ; Contao \ System :: getContainer ( ) -> get ( 'contao.opt-in' ) -> find ( $ model -> token ) -> send ( ) ; Contao \ Message :: addConfirmation ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resendToken' ] , $ model -> email ) ) ; Contao \ Controller :: redirect ( $ this -> getReferer ( ) ) ; }
11424	public function lists ( $ nextOpenId = null ) { $ params = [ 'next_openid' => $ nextOpenId ] ; return $ this -> parseJSON ( 'get' , [ self :: API_LIST , $ params ] ) ; }
4769	public function run ( ) { if ( ! $ this -> is_debug ( ) || ! $ this -> is_debug_display ( ) ) { return ; } $ run = $ this [ 'run' ] ; $ run -> register ( ) ; ob_start ( ) ; }
8983	public function isSame ( TableNode $ expected , TableNode $ actual , $ message = NULL ) { $ this -> doAssert ( 'Failed asserting that two tables were identical: ' , [ ] , $ expected , $ actual , $ message ) ; }
8329	public function whereExists ( Closure $ callback , $ boolean = 'and' , $ not = false ) { $ type = $ not ? 'NotExists' : 'Exists' ; $ this -> wheres [ ] = compact ( 'type' , 'callback' , 'boolean' ) ; return $ this ; }
9926	private function handleArrays ( Parameters $ params , array $ permitted = array ( ) ) { foreach ( $ permitted as $ key => $ allowed ) { if ( is_array ( $ allowed ) && $ params -> hasKey ( $ key ) ) { $ value = $ params [ $ key ] ; if ( $ value instanceof Parameters ) { $ this -> filter ( $ value , $ allowed ) ; } else { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } } }
1972	public static function findByPath ( $ path , array $ arrOptions = array ( ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ path , $ rootDir . '/' , \ strlen ( $ rootDir ) + 1 ) === 0 ) { $ path = substr ( $ path , \ strlen ( $ rootDir ) + 1 ) ; } return static :: findOneBy ( 'path' , $ path , $ arrOptions ) ; }
8832	public function tokenise ( $ pattern , $ expand = false ) { preg_match_all ( ' / (?<class_U_explicit>\\\U) \{ (?<class_U_repetition>[0-9]+) \} | (?<class_U_implicit>\\\U) | \[ (?<range_token_explicit>[^]]+) \] \{ (?<range_repetition>[0-9]+) \} | \[ (?<range_token_implicit>[^]]+) \] | (?<literal_string>[^\\\[]+) /x ' , $ pattern , $ matches , \ PREG_SET_ORDER ) ; $ tokens = [ ] ; foreach ( $ matches as $ match ) { if ( ! empty ( $ match [ 'class_U_explicit' ] ) ) { $ token = [ 'type' => 'class' , 'class' => static :: CLASS_UPPERCASE_UNAMBIGUOUS , 'repetition' => ( int ) $ match [ 'class_U_repetition' ] ] ; if ( $ expand ) { $ token [ 'haystack' ] = 'ABCDEFGHKMNOPRSTUVWXYZ23456789' ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'class_U_implicit' ] ) ) { $ token = [ 'type' => 'class' , 'class' => static :: CLASS_UPPERCASE_UNAMBIGUOUS , 'repetition' => 1 ] ; if ( $ expand ) { $ token [ 'haystack' ] = 'ABCDEFGHKMNOPRSTUVWXYZ23456789' ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'range_token_explicit' ] ) ) { $ token = [ 'type' => 'range' , 'token' => $ match [ 'range_token_explicit' ] , 'repetition' => ( int ) $ match [ 'range_repetition' ] ] ; if ( $ expand ) { $ token [ 'haystack' ] = static :: expandRange ( $ match [ 'range_token_explicit' ] ) ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'range_token_implicit' ] ) ) { $ token = [ 'type' => 'range' , 'token' => $ match [ 'range_token_implicit' ] , 'repetition' => 1 ] ; if ( $ expand ) { $ token [ 'haystack' ] = static :: expandRange ( $ match [ 'range_token_implicit' ] ) ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'literal_string' ] ) ) { $ tokens [ ] = [ 'type' => 'literal' , 'string' => $ match [ 'literal_string' ] ] ; } } return $ tokens ; }
8682	public function setPath ( $ path , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; Arr :: set ( $ this -> items , $ path , $ value ) ; }
3006	static public function jump ( \ Base $ f3 , $ params ) { $ target = $ f3 -> get ( 'GET.target' ) ; if ( $ f3 -> exists ( 'mailer.on.jump' , $ jump_handler ) ) $ f3 -> call ( $ jump_handler , array ( $ target , $ params ) ) ; $ f3 -> reroute ( urldecode ( $ target ) ) ; }
1964	public static function decodeUrl ( $ strUrl ) { if ( $ strUrl == '' ) { return '' ; } if ( $ strUrl == '#' || strncmp ( $ strUrl , '{{' , 2 ) === 0 ) { return $ strUrl ; } if ( strncmp ( $ strUrl , 'mailto:' , 7 ) === 0 ) { return static :: decodeEmail ( $ strUrl ) ; } $ arrUrl = parse_url ( $ strUrl ) ; if ( ! isset ( $ arrUrl [ 'scheme' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Expected a FQDN, got "%s"' , $ strUrl ) ) ; } if ( isset ( $ arrUrl [ 'scheme' ] ) ) { $ arrUrl [ 'scheme' ] .= ( ( substr ( $ strUrl , \ strlen ( $ arrUrl [ 'scheme' ] ) , 3 ) == '://' ) ? '://' : ':' ) ; } if ( isset ( $ arrUrl [ 'user' ] ) ) { $ arrUrl [ 'user' ] .= isset ( $ arrUrl [ 'pass' ] ) ? ':' : '@' ; } if ( isset ( $ arrUrl [ 'pass' ] ) ) { $ arrUrl [ 'pass' ] .= '@' ; } if ( isset ( $ arrUrl [ 'host' ] ) ) { $ arrUrl [ 'host' ] = static :: decode ( $ arrUrl [ 'host' ] ) ; } if ( isset ( $ arrUrl [ 'port' ] ) ) { $ arrUrl [ 'port' ] = ':' . $ arrUrl [ 'port' ] ; } if ( isset ( $ arrUrl [ 'query' ] ) ) { $ arrUrl [ 'query' ] = '?' . $ arrUrl [ 'query' ] ; } if ( isset ( $ arrUrl [ 'fragment' ] ) ) { $ arrUrl [ 'fragment' ] = '#' . $ arrUrl [ 'fragment' ] ; } $ strReturn = '' ; foreach ( array ( 'scheme' , 'user' , 'pass' , 'host' , 'port' , 'path' , 'query' , 'fragment' ) as $ key ) { if ( isset ( $ arrUrl [ $ key ] ) ) { $ strReturn .= $ arrUrl [ $ key ] ; } } return $ strReturn ; }
1801	protected function switchToEdit ( $ id ) { $ arrKeys = array ( ) ; $ arrUnset = array ( 'act' , 'id' , 'table' ) ; foreach ( array_keys ( $ _GET ) as $ strKey ) { if ( ! \ in_array ( $ strKey , $ arrUnset ) ) { $ arrKeys [ $ strKey ] = $ strKey . '=' . Input :: get ( $ strKey ) ; } } $ strUrl = TL_SCRIPT . '?' . implode ( '&' , $ arrKeys ) ; return $ strUrl . ( ! empty ( $ arrKeys ) ? '&' : '' ) . ( Input :: get ( 'table' ) ? 'table=' . Input :: get ( 'table' ) . '&amp;' : '' ) . 'act=edit&amp;id=' . rawurlencode ( $ id ) ; }
10778	private function create_image ( ) { $ total = $ this -> total_size ( ) ; $ sprite = imagecreatetruecolor ( $ total [ "width" ] , $ total [ "height" ] ) ; imagesavealpha ( $ sprite , true ) ; $ transparent = imagecolorallocatealpha ( $ sprite , 0 , 0 , 0 , 127 ) ; imagefill ( $ sprite , 0 , 0 , $ transparent ) ; $ top = 0 ; foreach ( $ this -> images as $ image ) { $ func = "imagecreatefrom" . $ image [ 'type' ] ; $ img = $ func ( $ image [ "path" ] ) ; imagecopy ( $ sprite , $ img , ( $ total [ "width" ] - $ image [ "width" ] ) , $ top , 0 , 0 , $ image [ "width" ] , $ image [ "height" ] ) ; $ top += $ image [ "height" ] ; } return $ sprite ; }
1795	private function addFrontendRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/{alias}' . $ this -> urlSuffix , $ defaults , [ 'alias' => '.+' ] ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_frontend' , $ route ) ; }
8026	public function remove ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; if ( $ this -> hasProcess ( $ pid ) === FALSE ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not remove process. Process (%d) not in list.' , $ processDetails -> getPid ( ) ) , 1400761297 ) ; } if ( isset ( $ this -> freeProcessIds [ $ pid ] ) ) { unset ( $ this -> freeProcessIds [ $ pid ] ) ; } if ( isset ( $ this -> sockets [ $ pid ] ) ) { unset ( $ this -> sockets [ $ pid ] ) ; } unset ( $ this -> processDetails [ $ pid ] ) ; return $ this ; }
2860	public function getLimitOptionsSelect ( ) { $ filterHelper = Mage :: helper ( 'sheep_debug/filter' ) ; $ select = $ this -> getLayout ( ) -> createBlock ( 'core/html_select' ) ; $ select -> setName ( 'limit' ) -> setId ( 'limit' ) -> setValue ( $ this -> getRequest ( ) -> getParam ( 'limit' , $ filterHelper -> getLimitDefaultValue ( ) ) ) -> setOptions ( $ this -> getOptionArray ( $ filterHelper -> getLimitValues ( ) ) ) ; return $ select -> getHtml ( ) ; }
1871	public function generateAjax ( $ strFolder , $ strField , $ level , $ mount = false ) { if ( ! Environment :: get ( 'isAjaxRequest' ) ) { return '' ; } $ this -> strField = $ strField ; $ this -> loadDataContainer ( $ this -> strTable ) ; switch ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'dataContainer' ] ) { case 'File' : if ( Config :: get ( $ this -> strField ) != '' ) { $ this -> varValue = Config :: get ( $ this -> strField ) ; } break ; case 'Table' : $ this -> import ( Database :: class , 'Database' ) ; if ( ! $ this -> Database -> fieldExists ( $ this -> strField , $ this -> strTable ) ) { break ; } $ objField = $ this -> Database -> prepare ( "SELECT " . Database :: quoteIdentifier ( $ this -> strField ) . " FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> strId ) ; if ( $ objField -> numRows ) { $ this -> varValue = StringUtil :: deserialize ( $ objField -> { $ this -> strField } ) ; } break ; } $ this -> convertValuesToPaths ( ) ; if ( $ this -> extensions != '' ) { $ this -> arrValidFileTypes = StringUtil :: trimsplit ( ',' , $ this -> extensions ) ; } return $ this -> renderFiletree ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFolder , ( $ level * 20 ) , $ mount , $ this -> isProtectedPath ( $ strFolder ) ) ; }
6859	protected static function solsticeDecember ( $ year , $ vsop = true ) { $ month = 12 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
2767	public function pushTag ( string $ tag , string $ repository = 'origin' , array $ options = [ ] ) : string { return $ this -> push ( $ repository , 'tag' , $ tag , $ options ) ; }
12120	public function onViewCreate ( ContentfulViewEvent $ e ) { $ viewMeta = $ e -> getView ( ) -> cfMeta ; $ updated = $ viewMeta [ 'updatedAt' ] ; $ this -> itemIds [ $ viewMeta [ 'itemId' ] ] = true ; if ( $ this -> lastModifiedContent === null ) { $ this -> lastModifiedContent = $ updated ; } else { if ( $ this -> lastModifiedContent < $ updated ) { $ this -> lastModifiedContent = $ updated ; } } }
12263	public function renderCustomField ( array $ fields , $ classOrCustomField , $ documentType = 'html' , $ slug = null , $ showIfEmpty = true ) { $ customField = ( $ classOrCustomField instanceof CustomField ) ? $ classOrCustomField : $ this -> getCustomField ( $ classOrCustomField , $ slug ) ; $ slug = $ customField -> getSlug ( ) ; $ rawValue = ( isset ( $ fields [ $ slug ] ) ) ? $ fields [ $ slug ] : null ; $ customFieldType = $ this -> provider -> getCustomFieldByType ( $ customField -> getType ( ) ) ; return $ customFieldType -> render ( $ rawValue , $ customField , $ documentType ) ; }
8838	private function getStatus ( ) : array { $ status = proc_get_status ( $ this -> process ) ; if ( ! $ status [ 'running' ] && is_null ( $ this -> exitCode ) ) { $ this -> exitCode = $ status [ 'exitcode' ] ; } return $ status ; }
418	public function getCookies ( ) { if ( $ this -> _cookies === null ) { $ this -> _cookies = new CookieCollection ( $ this -> loadCookies ( ) , [ 'readOnly' => true , ] ) ; } return $ this -> _cookies ; }
3070	protected function saveItemState ( ) { if ( $ this -> getRequestParameter ( 'itemDefinition' ) && $ this -> getRequestParameter ( 'itemState' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemIdentifier = $ this -> getRequestParameter ( 'itemDefinition' ) ; $ state = $ this -> getRequestParameter ( 'itemState' ) ? json_decode ( $ this -> getRequestParameter ( 'itemState' ) , true ) : new \ stdClass ( ) ; return $ this -> getRunnerService ( ) -> setItemState ( $ serviceContext , $ itemIdentifier , $ state ) ; } return false ; }
4327	public static function isList ( $ val ) { if ( ! \ is_array ( $ val ) ) { return false ; } $ keys = \ array_keys ( $ val ) ; foreach ( $ keys as $ i => $ key ) { if ( $ i != $ key ) { return false ; } } return true ; }
1193	private function addCustomElements ( array $ elements , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ elements as $ element ) { $ name = $ element [ 0 ] ; $ contentSet = $ element [ 1 ] ; $ allowedChildren = $ element [ 2 ] ; $ attributeCollection = $ element [ 3 ] ; $ attributes = isset ( $ element [ 4 ] ) ? $ element [ 4 ] : null ; if ( ! empty ( $ attributes ) ) { $ definition -> addElement ( $ name , $ contentSet , $ allowedChildren , $ attributeCollection , $ attributes ) ; } else { $ definition -> addElement ( $ name , $ contentSet , $ allowedChildren , $ attributeCollection ) ; } } }
8872	private function buildAttachmentPart ( ) { if ( count ( $ this -> attachments ) > 0 ) { $ attachment_part = '' ; foreach ( $ this -> attachments as $ attachment ) { $ file_str = chunk_split ( base64_encode ( file_get_contents ( $ attachment ) ) ) ; $ attachment_part .= "--MIME_BOUNDRY\nContent-Type: " . $ this -> getMimeType ( $ attachment ) . "; name=" . basename ( $ attachment ) . "\nContent-disposition: attachment\nContent-Transfer-Encoding: base64\n\n{$file_str}\n\n" ; } return $ attachment_part ; } }
5856	public function initializeRulesets ( array $ configuration ) { $ general = $ configuration ; $ general [ 'usergroup' ] = '' ; unset ( $ general [ 'rulesets' ] ) ; $ general = $ this -> expandValuesInRuleset ( $ general ) ; if ( $ general [ 'conversion_mapping' ] === '' ) { $ general [ 'conversion_mapping' ] = [ ] ; } if ( isset ( $ configuration [ 'rulesets' ] ) ) { $ rulesets = $ this -> compileRuleSets ( $ configuration [ 'rulesets' ] ) ; } else { $ rulesets = [ ] ; } foreach ( $ rulesets as $ k => & $ ruleset ) { foreach ( $ general as $ key => $ value ) { if ( ! isset ( $ ruleset [ $ key ] ) ) { $ ruleset [ $ key ] = $ value ; } elseif ( $ ruleset [ $ key ] === '' ) { $ ruleset [ $ key ] = $ value ; } } if ( count ( $ ruleset [ 'usergroup' ] ) == 0 ) { $ ruleset [ 'directories' ] = array_diff ( $ ruleset [ 'directories' ] , $ general [ 'directories' ] ) ; if ( count ( $ ruleset [ 'directories' ] ) == 0 ) { unset ( $ rulesets [ $ k ] ) ; } } } $ rulesets [ ] = $ general ; $ this -> rulesets = $ rulesets ; }
615	protected function resolveDependencies ( $ dependencies , $ reflection = null ) { foreach ( $ dependencies as $ index => $ dependency ) { if ( $ dependency instanceof Instance ) { if ( $ dependency -> id !== null ) { $ dependencies [ $ index ] = $ this -> get ( $ dependency -> id ) ; } elseif ( $ reflection !== null ) { $ name = $ reflection -> getConstructor ( ) -> getParameters ( ) [ $ index ] -> getName ( ) ; $ class = $ reflection -> getName ( ) ; throw new InvalidConfigException ( "Missing required parameter \"$name\" when instantiating \"$class\"." ) ; } } } return $ dependencies ; }
1340	public function exists ( ResourceIdentifierInterface $ identifier ) { $ record = $ this -> lookup ( $ identifier ) ; return is_object ( $ record ) ? true : $ record ; }
3599	public function handleHttpRequest ( HttpRequest $ httpRequest ) { $ event = $ this -> dispatch ( Event \ HttpRequestEvent :: EVENT , new Event \ HttpRequestEvent ( $ httpRequest ) ) ; $ httpRequest = $ event -> getHttpRequest ( ) ; try { $ jsonRequests = $ this -> parserHttpRequest ( $ httpRequest ) ; } catch ( Exceptions \ ParseException $ e ) { return $ this -> createHttpResponseFromException ( $ e ) ; } $ jsonResponses = $ this -> jsonHandler -> handleJsonRequest ( $ jsonRequests ) ; $ httpResponse = HttpResponse :: create ( ) ; if ( $ this -> profiler ) { $ collect = function ( $ jsonResponse ) use ( & $ collect , $ httpRequest , $ httpResponse ) { if ( \ is_array ( $ jsonResponse ) ) { foreach ( $ jsonResponse as $ value ) { $ collect ( $ value ) ; } } else { if ( $ jsonResponse -> isError ( ) ) { $ this -> collectException ( $ httpRequest , $ httpResponse , new Exceptions \ ErrorException ( $ jsonResponse -> getErrorMessage ( ) , $ jsonResponse -> getErrorCode ( ) , $ jsonResponse -> getErrorData ( ) , $ jsonResponse -> getId ( ) ) ) ; } } } ; $ collect ( $ jsonResponses ) ; } if ( \ is_array ( $ jsonResponses ) ) { $ results = [ ] ; foreach ( $ jsonResponses as $ jsonResponse ) { if ( $ jsonResponse -> isError ( ) || $ jsonResponse -> getId ( ) ) { $ results [ ] = $ jsonResponse ; } if ( $ jsonResponse -> isError ( ) ) { $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; } } $ httpResponse -> setContent ( \ json_encode ( $ results ) ) ; } else { if ( $ jsonResponses -> isError ( ) || $ jsonResponses -> getId ( ) ) { $ httpResponse -> setContent ( \ json_encode ( $ jsonResponses ) ) ; } if ( $ jsonResponses -> isError ( ) ) { $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; } } if ( \ is_array ( $ jsonResponses ) ) { foreach ( $ jsonResponses as $ jsonResponse ) { if ( $ jsonResponse -> isError ( ) || $ jsonResponse -> getId ( ) ) { $ httpResponse -> headers -> add ( $ jsonResponse -> headers ( ) -> all ( ) ) ; } } } else { $ httpResponse -> headers -> add ( $ jsonResponses -> headers ( ) -> all ( ) ) ; } $ httpResponse -> headers -> set ( 'Content-Type' , 'application/json' ) ; $ this -> dispatch ( Event \ HttpResponseEvent :: EVENT , new Event \ HttpResponseEvent ( $ httpResponse ) ) ; return $ httpResponse ; }
7355	public static function isValidSize ( $ size , $ throw = false ) { if ( in_array ( $ size , static :: getSizes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Unknown size '$size'." ) ; } return false ; }
3066	public function process ( QtiRunnerServiceContext $ context , array $ data = [ ] ) { return $ this -> getServiceManager ( ) -> get ( SynchronisationService :: SERVICE_ID ) -> process ( $ data , $ context ) ; }
483	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ time = $ this -> beginCommand ( 'create' . ( $ unique ? ' unique' : '' ) . " index $name on $table (" . implode ( ',' , ( array ) $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
316	public function renderAjax ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; $ this -> beginPage ( ) ; $ this -> head ( ) ; $ this -> beginBody ( ) ; echo $ this -> renderFile ( $ viewFile , $ params , $ context ) ; $ this -> endBody ( ) ; $ this -> endPage ( true ) ; return ob_get_clean ( ) ; }
2348	public static function putContent ( $ strFile , $ strContent ) { $ objFile = new static ( $ strFile ) ; $ objFile -> write ( $ strContent ) ; $ objFile -> close ( ) ; }
2054	protected function getConfigurationItem ( $ imageSize ) { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; $ mode = $ imageSize -> resizeMode ; if ( substr_count ( $ mode , '_' ) === 1 ) { $ importantPart = $ this -> image -> setImportantPart ( null ) -> getImportantPart ( ) ; $ mode = explode ( '_' , $ mode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } $ this -> image -> setImportantPart ( $ importantPart ) ; $ mode = ResizeConfiguration :: MODE_CROP ; } $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setZoomLevel ( $ imageSize -> zoom ) ; if ( $ mode ) { $ resizeConfig -> setMode ( $ mode ) ; } $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( isset ( $ imageSize -> sizes ) ) { $ configItem -> setSizes ( $ imageSize -> sizes ) ; } if ( isset ( $ imageSize -> densities ) ) { $ configItem -> setDensities ( $ imageSize -> densities ) ; } if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } return $ configItem ; }
6996	public static function parseApplePriceMatrixAll ( $ file , $ directory = null ) { $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTMLFile ( $ file ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ currencies = array ( ) ; $ currencyElements = $ xpath -> query ( '//table[1]//tr[2]//td[position() > 1]' ) ; foreach ( $ currencyElements as $ currencyElement ) { $ currency = trim ( $ currencyElement -> textContent ) ; if ( 'Euro' == $ currency ) { $ currency = 'EUR' ; } $ currencies [ ] = $ currency ; } if ( ! count ( $ currencies ) ) { throw new \ RuntimeException ( sprintf ( 'Not found currencies in ApplePriceMatrix in file "%s".' , $ file ) ) ; } $ currencies = array_flip ( $ currencies ) ; foreach ( $ currencies as $ currency => $ null ) { $ currencies [ $ currency ] = static :: parseApplePriceMatrix ( $ dom , $ currency , $ directory ) ; } return $ currencies ; }
9380	protected function retrieve ( array $ routes , $ uri ) { $ routes = array_values ( array_filter ( $ routes ) ) ; if ( empty ( $ routes ) ) { $ message = 'Route "' . $ uri . '" not found' ; throw new \ UnexpectedValueException ( $ message ) ; } $ route = current ( $ routes ) ; $ route [ 1 ] = ( count ( $ route [ 1 ] ) > 0 ) ? array_combine ( $ route [ 3 ] , $ route [ 1 ] ) : $ route [ 1 ] ; return $ route ; }
11365	public static function listAddresses ( $ list = array ( ) , $ type = 'to' ) { if ( empty ( $ list ) ) { return ; } $ str = ucfirst ( strtolower ( $ type ) ) . ': ' . self :: mailListTagger ( $ list ) ; return ( trim ( $ str , Mailer :: $ ADDERSSES_SEPARATOR ) . Mailer :: $ LINE_ENDING ) ; }
920	private function fixDescription ( DocBlock $ doc ) { foreach ( $ doc -> getLines ( ) as $ index => $ line ) { if ( $ line -> containsATag ( ) ) { break ; } if ( $ line -> containsUsefulContent ( ) ) { $ next = $ doc -> getLine ( $ index + 1 ) ; if ( $ next -> containsATag ( ) ) { $ line -> addBlank ( ) ; break ; } } } }
155	public function scalar ( $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } return $ this -> createCommand ( $ db ) -> queryScalar ( ) ; }
181	public function getConverter ( ) { if ( $ this -> _converter === null ) { $ this -> _converter = Yii :: createObject ( AssetConverter :: className ( ) ) ; } elseif ( is_array ( $ this -> _converter ) || is_string ( $ this -> _converter ) ) { if ( is_array ( $ this -> _converter ) && ! isset ( $ this -> _converter [ 'class' ] ) ) { $ this -> _converter [ 'class' ] = AssetConverter :: className ( ) ; } $ this -> _converter = Yii :: createObject ( $ this -> _converter ) ; } return $ this -> _converter ; }
4717	public function emit ( $ event , $ parameters ) { if ( ! isset ( $ this -> callbacks [ $ event ] ) ) { return ; } if ( ! $ this -> callbacks [ $ event ] [ 0 ] ) { usort ( $ this -> callbacks [ $ event ] [ 1 ] , function ( $ A , $ B ) { if ( $ A [ 0 ] == $ B [ 0 ] ) { return 0 ; } return ( $ A [ 0 ] > $ B [ 0 ] ) ? 1 : - 1 ; } ) ; $ this -> callbacks [ $ event ] [ 0 ] = true ; } foreach ( $ this -> callbacks [ $ event ] [ 1 ] as $ item ) { call_user_func_array ( $ item [ 1 ] , $ this -> buildParameters ( $ parameters ) ) ; } }
10666	public function setReportUri ( string $ reportUri ) : void { if ( ! $ this -> enableProtection ) { throw new MiddlewareException ( $ this , "You can't set the report URI because the XSS protection is disabled" ) ; } if ( $ this -> blockMode ) { throw new MiddlewareException ( $ this , sprintf ( "You can't set the report URI because the block mode is already enabled (see %s)" , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/X-XSS-Protection' ) ) ; } $ this -> reportUri = $ reportUri ; }
5349	public function installOperatingSystemUnattended ( $ vpsName , $ operatingSystemName , $ base64InstallText ) { return $ this -> call ( self :: SERVICE , 'installOperatingSystemUnattended' , [ $ vpsName , $ operatingSystemName , $ base64InstallText ] ) ; }
11961	public function each ( Closure $ fn ) { foreach ( $ this -> elements as $ key => $ element ) { if ( $ fn ( $ element , $ key ) === false ) { return false ; } } return true ; }
10274	public function setLocked ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'locked' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> locked = $ pValue ; } return $ this ; }
1800	protected function combiner ( $ names ) { $ return = array ( '' ) ; $ names = array_values ( $ names ) ; for ( $ i = 0 , $ c = \ count ( $ names ) ; $ i < $ c ; $ i ++ ) { $ buffer = array ( ) ; foreach ( $ return as $ k => $ v ) { $ buffer [ ] = ( $ k % 2 == 0 ) ? $ v : $ v . $ names [ $ i ] ; $ buffer [ ] = ( $ k % 2 == 0 ) ? $ v . $ names [ $ i ] : $ v ; } $ return = $ buffer ; } return array_filter ( $ return ) ; }
1493	public function index ( $ resourceType , $ meta = null , array $ queryParams = [ ] ) { return $ this -> factory -> createLink ( $ this -> urls -> index ( $ resourceType , $ queryParams ) , $ meta , true ) ; }
358	function compareByteSize ( $ a , $ b , $ compare = '>=' ) { $ compareExpression = '(' . $ this -> getByteSize ( $ a ) . $ compare . $ this -> getByteSize ( $ b ) . ')' ; return $ this -> evaluateExpression ( $ compareExpression ) ; }
11210	protected function addRegistry ( $ registry ) { $ this -> removeFromLookup ( $ registry ) ; if ( $ registry instanceof DelegatorAwareInterface ) { $ registry -> setDelegator ( $ this ) ; } $ this -> lookup_pool [ ] = $ registry ; return $ this ; }
7214	public function debit ( $ account , $ amount , \ DateTime $ date ) { $ data = [ $ this -> date , $ account , $ this -> identity , null , $ amount , $ this -> number , $ date -> format ( 'Y-m-d' ) , ] ; if ( false === fputcsv ( $ this -> handle , $ data , ';' , '"' ) ) { throw new RuntimeException ( "Failed to write line." ) ; } }
7026	public function checkRememberMeCookie ( ) { if ( ! $ this -> loggedIn ( ) && $ this -> Cookie -> read ( 'User.id' ) ) { return $ this -> Cookie -> read ( 'User.id' ) ; } return false ; }
11222	private static function checkRoutes ( ) { $ method = $ _SERVER [ 'REQUEST_METHOD' ] ; $ route_pos = array_keys ( self :: $ routes , self :: $ uri , true ) ; foreach ( $ route_pos as $ route ) { $ methodRoute = self :: $ methods [ $ route ] ; if ( $ methodRoute == $ method || $ methodRoute == 'ANY' ) { if ( ! is_object ( $ callback = self :: $ callbacks [ $ route ] ) ) { self :: $ response = self :: invokeObject ( $ callback ) ; } else { self :: $ response = call_user_func ( $ callback ) ; } if ( ! self :: $ halts ) { return self :: $ response ; } self :: $ halts -- ; } } return self :: $ response ; }
2730	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , Config :: AUTH_DICTIONARY_NAME ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; if ( ( $ status == true && is_array ( $ authItems ) && count ( $ authItems ) < 2 ) || $ authItems == false ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'While Basic Authentication is enabled, at least one user must exist.' , ] ) ; } $ itemKey = $ this -> getRequest ( ) -> getParam ( 'item_key_id' ) ; $ deleteItem = $ this -> api -> deleteDictionaryItem ( $ dictionary -> id , $ itemKey ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Dictionary item.' ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
5361	protected function createHeaderStatements ( Operation $ operation , $ queryParamVariable ) { $ headerVariable = new Expr \ Variable ( 'headers' ) ; $ headers = [ new Expr \ ArrayItem ( new Scalar \ String_ ( $ operation -> getHost ( ) ) , new Scalar \ String_ ( 'Host' ) ) , ] ; $ produces = $ operation -> getOperation ( ) -> getProduces ( ) ; if ( $ produces && in_array ( "application/json" , $ produces ) ) { $ headers [ ] = new Expr \ ArrayItem ( new Expr \ Array_ ( [ new Expr \ ArrayItem ( new Scalar \ String_ ( "application/json" ) ) , ] ) , new Scalar \ String_ ( 'Accept' ) ) ; } $ consumes = $ operation -> getOperation ( ) -> getProduces ( ) ; if ( $ operation -> getOperation ( ) -> getParameters ( ) && $ consumes ) { $ bodyParameters = array_filter ( $ operation -> getOperation ( ) -> getParameters ( ) , function ( $ parameter ) { return $ parameter instanceof BodyParameter ; } ) ; if ( count ( $ bodyParameters ) > 0 && in_array ( "application/json" , $ consumes ) ) { $ headers [ ] = new Expr \ ArrayItem ( new Scalar \ String_ ( "application/json" ) , new Scalar \ String_ ( 'Content-Type' ) ) ; } } return [ [ new Expr \ Assign ( $ headerVariable , new Expr \ FuncCall ( new Name ( 'array_merge' ) , [ new Arg ( new Expr \ Array_ ( $ headers ) ) , new Arg ( new Expr \ MethodCall ( $ queryParamVariable , 'buildHeaders' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] ) ) ] , $ headerVariable ] ; }
1928	protected function validator ( $ varInput ) { foreach ( $ varInput as $ k => $ v ) { if ( $ k != 'unit' ) { $ varInput [ $ k ] = parent :: validator ( $ v ) ; } } return $ varInput ; }
9772	function property ( string $ name , $ value = null ) : self { $ isArray = is_array ( $ this -> target ) || $ this -> target instanceof \ ArrayAccess ; if ( ! $ isArray && ! is_object ( $ this -> target ) ) throw new \ BadMethodCallException ( 'The target is not an array nor an object.' ) ; $ hasProperty = $ isArray ? array_key_exists ( $ name , $ this -> target ) : property_exists ( $ this -> target , $ name ) ; $ hasPropertyConstraint = $ isArray ? arrayHasKey ( $ name ) : objectHasAttribute ( $ name ) ; $ property = $ isArray ? ( $ this -> target [ $ name ] ?? null ) : ( $ this -> target -> $ name ?? null ) ; if ( ! $ hasProperty || $ value === null ) $ this -> expect ( $ this -> target , $ hasPropertyConstraint ) ; else { assertThat ( $ this -> target , $ hasPropertyConstraint ) ; $ this -> expect ( $ property , equalTo ( $ value ) ) ; } $ this -> target = $ property ; return $ this ; }
11656	public function getShortName ( ) { preg_match ( '/Widget([A-Za-z]+)\\\Module/' , get_class ( $ this ) , $ matches ) ; if ( ! isset ( $ matches [ 1 ] ) ) { throw new Exception ( get_class ( $ this ) . " is not set up correctly!" ) ; } return $ matches [ 1 ] ; }
2819	public function initQueries ( ) { $ this -> queries = array ( ) ; $ profiler = Mage :: helper ( 'sheep_debug' ) -> getSqlProfiler ( ) ; if ( $ profiler -> getEnabled ( ) && $ profiler instanceof Sheep_Debug_Model_Db_Profiler ) { $ this -> queries = $ profiler -> getQueryModels ( ) ? : array ( ) ; $ this -> setQueryCount ( $ profiler -> getTotalNumQueries ( ) ) ; $ this -> setQueryTime ( $ profiler -> getTotalElapsedSecs ( ) ) ; } }
391	protected static function filterValidAliases ( Query $ query ) { $ tables = $ query -> getTablesUsedInFrom ( ) ; $ aliases = array_diff ( array_keys ( $ tables ) , $ tables ) ; return array_map ( function ( $ alias ) { return preg_replace ( '/{{([\w]+)}}/' , '$1' , $ alias ) ; } , array_values ( $ aliases ) ) ; }
5832	protected function createResponseObject ( $ response ) { $ info = curl_getinfo ( $ this -> ch ) ; $ headerSize = curl_getinfo ( $ this -> ch , CURLINFO_HEADER_SIZE ) ; $ headerText = substr ( $ response , 0 , $ headerSize ) ; $ headers = $ this -> headerToArray ( $ headerText ) ; $ body = substr ( $ response , $ headerSize ) ; $ class = $ this -> responseClass ; $ obj = new $ class ( $ body , $ headers , $ info ) ; return $ obj ; }
10011	public function removeSheetByIndex ( $ pIndex ) { $ numSheets = count ( $ this -> workSheetCollection ) ; if ( $ pIndex > $ numSheets - 1 ) { throw new Exception ( "You tried to remove a sheet by the out of bounds index: {$pIndex}. The actual number of sheets is {$numSheets}." ) ; } array_splice ( $ this -> workSheetCollection , $ pIndex , 1 ) ; if ( ( $ this -> activeSheetIndex >= $ pIndex ) && ( $ pIndex > count ( $ this -> workSheetCollection ) - 1 ) ) { -- $ this -> activeSheetIndex ; } }
8036	public static function convert ( $ input , $ outputFormat = Code :: FORMAT_ALNUM , $ minLength = null ) { if ( is_int ( $ minLength ) ) { $ input += self :: getMinForlength ( $ outputFormat , $ minLength ) ; } static :: throwUnlessAcceptable ( $ outputFormat , $ input ) ; return self :: convertBase ( $ input , self :: FORMAT_NUMBER , $ outputFormat ) ; }
1057	public static function findTypesThatChangedKind ( Schema $ schemaA , Schema $ schemaB ) : iterable { $ schemaATypeMap = $ schemaA -> getTypeMap ( ) ; $ schemaBTypeMap = $ schemaB -> getTypeMap ( ) ; $ breakingChanges = [ ] ; foreach ( $ schemaATypeMap as $ typeName => $ schemaAType ) { if ( ! isset ( $ schemaBTypeMap [ $ typeName ] ) ) { continue ; } $ schemaBType = $ schemaBTypeMap [ $ typeName ] ; if ( $ schemaAType instanceof $ schemaBType ) { continue ; } if ( $ schemaBType instanceof $ schemaAType ) { continue ; } $ schemaATypeKindName = self :: typeKindName ( $ schemaAType ) ; $ schemaBTypeKindName = self :: typeKindName ( $ schemaBType ) ; $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_CHANGED_KIND , 'description' => "${typeName} changed from ${schemaATypeKindName} to ${schemaBTypeKindName}." , ] ; } return $ breakingChanges ; }
3092	public function load ( ) { if ( ! isset ( $ this -> cache [ $ this -> testSessionId ] ) ) { $ encodedData = $ this -> getStorageService ( ) -> get ( $ this -> getUserKey ( ) , $ this -> getStorageKey ( ) ) ; \ common_Logger :: d ( sprintf ( 'QtiTimer: Loaded %d bytes from state storage' , strlen ( $ encodedData ) ) ) ; $ this -> cache [ $ this -> testSessionId ] = $ this -> getStorageFormat ( ) -> decode ( $ encodedData ) ; } return $ this -> cache [ $ this -> testSessionId ] ; }
12065	public function destroy ( ) { session_start ( ) ; $ _SESSION = array ( ) ; if ( ini_get ( "session.use_cookies" ) ) { $ aParams = session_get_cookie_params ( ) ; setcookie ( session_name ( ) , '' , time ( ) - 42000 , $ aParams [ "path" ] , $ aParams [ "domain" ] , $ aParams [ "secure" ] , $ aParams [ "httponly" ] ) ; } session_destroy ( ) ; }
4307	public function timeEnd ( $ label = null , $ returnOrTemplate = false , $ precision = 4 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'label' => null , 'returnOrTemplate' => false , 'precision' => 4 , ) ) ; \ extract ( $ args ) ; if ( \ is_bool ( $ label ) || \ strpos ( $ label , '%time' ) !== false ) { if ( \ is_numeric ( $ returnOrTemplate ) ) { $ precision = $ returnOrTemplate ; } $ returnOrTemplate = $ label ; $ label = null ; } $ ret = $ this -> timeGet ( $ label , true , null ) ; if ( isset ( $ label ) ) { if ( isset ( $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] ) ) { $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] = array ( $ ret , null , ) ; } } else { $ label = 'time' ; \ array_pop ( $ this -> data [ 'timers' ] [ 'stack' ] ) ; } if ( \ is_int ( $ precision ) ) { $ ret = \ number_format ( $ ret , $ precision , '.' , '' ) ; } $ this -> doTime ( $ ret , $ returnOrTemplate , $ label , $ meta ) ; return $ ret ; }
2162	public function run35Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_member` CHANGE `username` `username` varchar(64) COLLATE utf8_bin NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_member` SET username=NULL WHERE username=''" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_member` DROP INDEX `username`, ADD UNIQUE KEY `username` (`username`)" ) ; }
7029	public function getMessagesForQuantity ( float $ quantity ) { $ messages = [ ] ; if ( $ quantity < $ this -> minimumQuantity ) { $ messages [ ] = $ this -> minimumMessage ; } elseif ( 0 < $ this -> maximumQuantity && $ quantity > $ this -> maximumQuantity ) { $ messages [ ] = $ this -> maximumMessage ; } else { if ( null !== $ this -> availableMessage ) { $ messages [ ] = $ this -> availableMessage ; } if ( $ quantity > $ this -> availableQuantity ) { if ( null !== $ this -> resupplyMessage ) { $ messages [ ] = $ this -> resupplyMessage ; if ( $ quantity > $ this -> availableQuantity + $ this -> resupplyQuantity ) { $ messages [ ] = $ this -> overflowMessage ; } } else { $ messages [ ] = $ this -> overflowMessage ; } } } if ( empty ( $ messages ) ) { $ messages [ ] = $ this -> overflowMessage ; } return $ messages ; }
2784	private function indent ( $ output , $ asArray = false ) { $ lines = explode ( "\n" , $ output ) ; $ out = [ ] ; foreach ( $ lines as $ line ) { $ out [ ] = ' > ' . $ line ; } if ( $ asArray ) { return $ out ; } $ return = implode ( "\n" , $ out ) ; return $ return ; }
12783	protected function createIntersections ( ) { $ totalNumberOfCombinations = min ( pow ( 2 , $ this -> arraysSize ) , $ this -> maxNumberOfCombinations ) ; $ maskGenerator = new BitMaskGenerator ( $ this -> arraysSize , 2 ) ; $ i = 0 ; $ noresult = 0 ; while ( $ i < $ totalNumberOfCombinations && $ noresult < $ totalNumberOfCombinations && $ mask = $ maskGenerator -> getNextMask ( ) ) { if ( ! $ this -> isNoResultMask ( $ mask ) ) { $ i ++ ; $ this -> generateIntersection ( $ mask ) ; continue ; } $ noresult ++ ; } if ( ! is_null ( $ this -> intersections ) ) { uasort ( $ this -> intersections , function ( $ a , $ b ) { return count ( $ b ) - count ( $ a ) ; } ) ; } }
5788	public function runExecute ( bool $ alterBooleanArgs = false ) { if ( ! isset ( $ this -> sql ) ) { $ this -> setSql ( ) ; } if ( isset ( $ this -> primaryKeyName ) ) { return parent :: executeWithReturnField ( $ this -> primaryKeyName , $ alterBooleanArgs ) ; } else { return parent :: execute ( $ alterBooleanArgs ) ; } }
7445	public function editAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } $ form = $ this -> createForm ( GroupType :: class , $ group ) ; return array ( 'group' => $ group , 'form' => $ form -> createView ( ) , ) ; }
3568	public function replicate ( ) { return function ( $ next , $ copy , $ args ) { $ metaAttributes = $ args -> get ( 'original' ) -> getMetaAttributes ( ) -> replicate ( $ args -> get ( 'except' ) ) ; $ copy -> setRelation ( 'metaAttributes' , $ metaAttributes ) ; return $ next ( $ copy , $ args ) ; } ; }
1836	public static function findMultipleByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ arrRegistered = array ( ) ; $ arrUnregistered = array ( ) ; foreach ( $ arrIds as $ intId ) { if ( empty ( $ arrOptions ) ) { $ arrRegistered [ $ intId ] = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ intId ) ; } if ( ! isset ( $ arrRegistered [ $ intId ] ) ) { $ arrUnregistered [ ] = $ intId ; } } if ( ! empty ( $ arrUnregistered ) ) { $ t = static :: $ strTable ; $ arrOptions = array_merge ( array ( 'column' => array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrUnregistered ) ) . ")" ) , 'value' => null , 'order' => Database :: getInstance ( ) -> findInSet ( "$t.id" , $ arrIds ) , 'return' => 'Collection' ) , $ arrOptions ) ; $ objMissing = static :: find ( $ arrOptions ) ; if ( $ objMissing !== null ) { while ( $ objMissing -> next ( ) ) { $ intId = $ objMissing -> { static :: $ strPk } ; $ arrRegistered [ $ intId ] = $ objMissing -> current ( ) ; } } } $ arrRegistered = array_filter ( array_values ( $ arrRegistered ) ) ; if ( empty ( $ arrRegistered ) ) { return null ; } return static :: createCollection ( $ arrRegistered , static :: $ strTable ) ; }
11204	public function where ( $ key = false , $ desiredValue , $ op = "==" ) { $ collection = $ this -> getIterator ( ) ; $ subset = new Collection ( ) ; foreach ( $ collection as $ prop => $ result ) { $ realValue = $ result ; if ( is_object ( $ result ) ) { $ realValue = $ result -> $ key ; } else if ( is_array ( $ result ) ) { $ realValue = $ result [ $ key ] ; } $ add = false ; if ( $ op == '==' && $ realValue == $ desiredValue ) { $ add = true ; } else if ( $ op == '>=' && $ realValue >= $ desiredValue ) { $ add = true ; } else if ( $ op == '<=' && $ realValue <= $ desiredValue ) { $ add = true ; } else if ( $ op == '>' && $ realValue > $ desiredValue ) { $ add = true ; } else if ( $ op == '<' && $ realValue < $ desiredValue ) { $ add = true ; } else if ( $ op == '===' && $ realValue === $ desiredValue ) { $ add = true ; } else if ( $ op == '!=' && $ realValue != $ desiredValue ) { $ add = true ; } if ( $ add ) { $ subset -> add ( $ result , $ prop ) ; } } return $ subset ; }
4974	private function hydrateTree ( NodeInterface $ object , \ ArrayObject $ currentData = null ) { if ( null === $ currentData ) { $ currentData = $ this -> hydrateData [ '__root__' ] ; } if ( 'set' == $ currentData [ 'do' ] ) { $ object -> setName ( $ currentData [ 'name' ] ) -> setValue ( $ currentData [ 'value' ] ) -> setPriority ( $ currentData [ 'priority' ] ) ; } if ( isset ( $ this -> hydrateData [ $ currentData [ 'current' ] ] ) ) { foreach ( $ this -> hydrateData [ $ currentData [ 'current' ] ] as $ childData ) { $ child = $ this -> findOrCreateChild ( $ object , $ childData [ 'id' ] ) ; if ( 'remove' == $ childData [ 'do' ] ) { $ object -> removeChild ( $ child ) ; } else { $ this -> hydrateTree ( $ child , $ childData ) ; } } } return $ object ; }
11526	public function resolve ( $ templatePath ) { $ templatePathReal = realpath ( $ templatePath ) ; if ( $ templatePathReal === false ) { throw new \ Exception ( 'Template file does not exist: ' . $ templatePath ) ; } if ( $ this -> hasCache ( $ templatePathReal ) ) { return $ this -> getCache ( $ templatePathReal ) ; } $ template = file_get_contents ( $ templatePathReal ) ; $ this -> setCache ( $ templatePathReal , $ template ) ; return $ template ; }
6860	private static function horner ( $ x , $ c ) { if ( count ( $ c ) == 0 ) throw new InvalidArgumentException ( 'No coefficients were provided' ) ; $ i = count ( $ c ) - 1 ; $ y = $ c [ $ i ] ; while ( $ i > 0 ) { $ i -- ; $ y = $ y * $ x + $ c [ $ i ] ; } return $ y ; }
9754	public static function assertFile ( $ filename ) { if ( ! is_file ( $ filename ) ) { throw new InvalidArgumentException ( 'File "' . $ filename . '" does not exist.' ) ; } if ( ! is_readable ( $ filename ) ) { throw new InvalidArgumentException ( 'Could not open "' . $ filename . '" for reading.' ) ; } }
11037	function store_reduce ( & $ elts , $ value ) { switch ( strtoupper ( $ value ) ) { case 'OFF' : case 'NOTHING' : $ elts [ '0reduce' ] = _ETS_REDUCE_OFF ; return TRUE ; case 'SPACE' : case 'SPACES' : $ elts [ '0reduce' ] = _ETS_REDUCE_SPACES ; return TRUE ; case 'CRLF' : case 'ON' : case 'ALL' : $ elts [ '0reduce' ] = _ETS_REDUCE_ALL ; return TRUE ; default : return FALSE ; } }
5554	public function getHeaders ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getHeaders ( ) ; } return $ this -> frameset -> getHeaders ( ) ; }
11721	public function getCarouselItemsBlog ( $ entity ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; if ( $ entity instanceof Category ) { $ qb = $ em -> getRepository ( 'BlogBundle:Post' ) -> createQueryBuilder ( 'p' ) -> join ( 'p.categories' , 'c' ) -> join ( 'p.translations' , 't' ) -> where ( 'c.id = :category' ) -> andWhere ( 'p.highlighted = true' ) -> setParameter ( 'category' , $ entity -> getId ( ) ) -> setMaxResults ( 3 ) -> orderBy ( 'p.published' , 'DESC' ) ; } elseif ( $ entity instanceof Tag ) { $ qb = $ em -> getRepository ( 'BlogBundle:Post' ) -> createQueryBuilder ( 'p' ) -> join ( 'p.tags' , 'tag' ) -> join ( 'p.translations' , 't' ) -> where ( 't.id = :tag' ) -> andWhere ( 'p.highlighted = true' ) -> setParameter ( 'tag' , $ entity -> getId ( ) ) -> setMaxResults ( 3 ) -> orderBy ( 'p.published' , 'DESC' ) ; } $ entities = $ qb -> getQuery ( ) -> getResult ( ) ; return $ entities ; }
7478	public function getFormFor ( $ entity , $ className = null , array $ options = array ( ) ) { if ( empty ( $ this -> _formHelper ) && ( $ this -> _formHelper = $ this -> get ( 'orkestra.application.helper.form' ) ) == null ) { throw new \ RuntimeException ( 'Orkestra FormHelper is not registered as a service' ) ; } $ type = $ this -> container -> get ( 'orkestra.application.helper.form' ) -> getType ( $ entity , $ className ) ; return $ this -> createForm ( $ type , $ entity , $ options ) ; }
12749	private function validateSKU ( string $ sku ) { if ( strlen ( $ sku ) == 0 ) { throw new SKUException ( "A SKU cannot be empty" ) ; } $ containsWhitespace = preg_match ( $ this -> whiteSpacePattern , $ sku ) == 1 ; if ( $ containsWhitespace ) { throw new SKUException ( sprintf ( "A SKU cannot contain white space characters: \"%s\"" , $ sku ) ) ; } $ containsUppercaseCharacters = preg_match ( $ this -> uppercaseCharactersPattern , $ sku ) == 1 ; if ( $ containsUppercaseCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot contain uppercase characters: \"%s\"" , $ sku ) ) ; } $ containsInvalidCharacters = preg_match ( $ this -> invalidCharactersPattern , $ sku ) == 1 ; if ( $ containsInvalidCharacters ) { throw new SKUException ( sprintf ( "The SKU \"%s\" contains invalid characters. A SKU can only contain the following characters: a-z, 0-9 and -" , $ sku ) ) ; } $ prefixMatches = [ ] ; $ prefixContainsInvalidCharacters = preg_match ( $ this -> invalidPrefixCharacters , $ sku , $ prefixMatches ) == 1 ; if ( $ prefixContainsInvalidCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot start with the given characters: \"%s\"" , implode ( "" , $ prefixMatches ) ) ) ; } $ suffixMatches = [ ] ; $ suffixContainsInvalidCharacters = preg_match ( $ this -> invalidSuffixCharacters , $ sku , $ suffixMatches ) == 1 ; if ( $ suffixContainsInvalidCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot end with the given characters: \"%s\"" , implode ( "" , $ suffixMatches ) ) ) ; } if ( strlen ( $ sku ) < $ this -> minLength ) { throw new SKUException ( sprintf ( "The given SKU \"%s\" is too short. The minimum length for a SKU is: %s" , $ sku , $ this -> minLength ) ) ; } if ( strlen ( $ sku ) > $ this -> maxLength ) { throw new SKUException ( sprintf ( "The given SKU \"%s\" is too long (%s character). The maximum length for a SKU is: %s" , strlen ( $ sku ) , $ sku , $ this -> maxLength ) ) ; } }
856	public function overrideAt ( $ index , $ token ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0, use offsetSet instead.' , E_USER_DEPRECATED ) ; self :: $ isLegacyMode = true ; $ this [ $ index ] -> override ( $ token ) ; $ this -> registerFoundToken ( $ token ) ; }
9371	public function integrate ( $ integrations , ConfigurationInterface $ config = null ) { list ( $ config , $ container ) = array ( $ config ? : $ this -> config , static :: $ container ) ; foreach ( ( array ) $ integrations as $ item ) { $ integration = is_string ( $ item ) ? new $ item : $ item ; $ container = $ integration -> define ( $ container , $ config ) ; } static :: $ container = $ container ; return $ this ; }
6796	protected function getValues ( $ valueIds , $ language ) { $ queryBuilder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ where = $ this -> getWhereColumn ( ) ? '(' . $ this -> getWhereColumn ( ) . ')' : null ; $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'source.*' ) -> from ( $ this -> getTagSource ( ) , 'source' ) -> where ( $ queryBuilder -> expr ( ) -> in ( 'source.' . $ this -> getIdColumn ( ) , $ valueIds ) ) -> andWhere ( $ queryBuilder -> expr ( ) -> andX ( ) -> add ( 'source.' . $ this -> getTagLangColumn ( ) . '=:lang' ) -> add ( $ where ) ) -> setParameter ( 'lang' , $ language ) -> groupBy ( 'source.' . $ this -> getIdColumn ( ) ) ; if ( $ this -> getTagSortSourceTable ( ) ) { $ statement -> addSelect ( $ this -> getTagSortSourceTable ( ) . '.*' ) ; $ statement -> join ( 's' , $ this -> getTagSortSourceTable ( ) , 'sort' , $ queryBuilder -> expr ( ) -> eq ( 'source.' . $ this -> getIdColumn ( ) , 'sort.id' ) ) ; if ( $ this -> getTagSortSourceColumn ( ) ) { $ statement -> orderBy ( $ this -> getTagSortSourceColumn ( 'sort' ) ) ; } } $ statement -> addOrderBy ( 'source.' . $ this -> getSortingColumn ( ) ) ; return $ statement -> execute ( ) ; }
9046	public function registerType ( $ type , $ classname , $ options = array ( ) ) { if ( ! class_exists ( $ classname ) || ! is_callable ( array ( $ classname , 'getDataType' ) ) ) { return ; } $ data_type = call_user_func ( array ( $ classname , 'getDataType' ) ) ; $ options = ( array ) $ options ; $ options [ 'type' ] = $ type ; $ options [ 'class_name' ] = $ classname ; $ options [ 'data_type' ] = $ data_type ; $ this -> types [ $ data_type ] [ $ type ] = $ options ; }
6917	public function isEmpty ( ) { return empty ( $ this -> subject ) || ( empty ( $ this -> customMessage ) && empty ( $ this -> paymentMessage ) && empty ( $ this -> shipmentMessage ) ) ; }
2913	public function formatMemorySize ( $ size , $ precision = 2 ) { $ sizes = array ( " Bytes" , " KB" , " MB" , " GB" , " TB" , " PB" , " EB" , " ZB" , " YB" ) ; if ( $ size == 0 ) { return $ this -> __ ( 'n/a' ) ; } else { $ value = round ( $ size / pow ( 1000 , ( $ i = floor ( log ( $ size , 1000 ) ) ) ) , $ precision ) ; $ unitIndex = ( int ) $ i ; return $ this -> __ ( '%s%s' , $ this -> formatNumber ( $ value , $ precision ) , $ sizes [ $ unitIndex ] ) ; } }
10230	public function getContext ( ) { $ s = '' ; foreach ( [ 'a' , 'b' , 'c' , 'd' ] as $ i ) { $ v = $ this -> { $ i } ; $ s .= chr ( $ v & 0xff ) ; $ s .= chr ( ( $ v >> 8 ) & 0xff ) ; $ s .= chr ( ( $ v >> 16 ) & 0xff ) ; $ s .= chr ( ( $ v >> 24 ) & 0xff ) ; } return $ s ; }
7959	public function getPairsNumber ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> pairsNumber ; }
6103	public function request ( $ cmd , $ throw = true ) { $ query = StringHelper :: factory ( $ cmd ) -> section ( TeamSpeak3 :: SEPARATOR_CELL ) ; if ( strstr ( $ cmd , "\r" ) || strstr ( $ cmd , "\n" ) ) { throw new Ts3Exception ( "illegal characters in command '" . $ query . "'" ) ; } elseif ( in_array ( $ query , $ this -> block ) ) { throw new Ts3Exception ( "command not found" , 0x100 ) ; } Signal :: getInstance ( ) -> emit ( "serverqueryCommandStarted" , $ cmd ) ; $ this -> getProfiler ( ) -> start ( ) ; $ this -> getTransport ( ) -> sendLine ( $ cmd ) ; $ this -> timer = time ( ) ; $ this -> count ++ ; $ rpl = array ( ) ; do { $ str = $ this -> getTransport ( ) -> readLine ( ) ; $ rpl [ ] = $ str ; } while ( $ str instanceof StringHelper && $ str -> section ( TeamSpeak3 :: SEPARATOR_CELL ) != TeamSpeak3 :: ERROR ) ; $ this -> getProfiler ( ) -> stop ( ) ; $ reply = new Reply ( $ rpl , $ cmd , $ this -> getHost ( ) , $ throw ) ; Signal :: getInstance ( ) -> emit ( "serverqueryCommandFinished" , $ cmd , $ reply ) ; return $ reply ; }
7323	protected function checkDate ( $ status ) { switch ( $ status ) { case 3 : case 2 : throw new Exception ( 'time is after end of day' ) ; case - 1 : throw new Exception ( 'bad year' ) ; case - 2 : throw new Exception ( 'bad month' ) ; case - 3 : throw new Exception ( 'bad day' ) ; case - 4 : throw new Exception ( 'bad hour' ) ; case - 5 : throw new Exception ( 'bad minute' ) ; case - 6 : throw new Exception ( 'bad second' ) ; default : return ; } }
12288	public function loop ( array $ collection , string $ block , string $ emptyBlock = null ) : string { if ( empty ( $ collection ) ) { return isset ( $ emptyBlock ) ? trim ( $ this -> make ( $ emptyBlock ) ) . PHP_EOL : PHP_EOL ; } else { $ items = '' ; foreach ( $ collection as $ key => $ item ) { $ items .= rtrim ( $ this -> make ( $ block , [ 'key' => $ key , 'item' => $ item ] ) ) ; } return ltrim ( $ items ) . PHP_EOL ; } }
8581	public function setPrepInstruction ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PrepInstruction' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8158	public function register ( $ isSuperAdmin = FALSE , $ status = 1 ) { if ( $ this -> getIsNewRecord ( ) == FALSE ) { throw new RuntimeException ( 'Calling "' . __CLASS__ . '::' . __METHOD__ . '" on existing user' ) ; } $ this -> super_admin = $ isSuperAdmin ? 1 : 0 ; $ this -> status = $ status ; if ( $ this -> save ( ) ) { return TRUE ; } return FALSE ; }
9654	public function getForPath ( $ path ) { $ extension = $ this -> getExtension ( $ path ) ; if ( ! isset ( $ this -> loaders [ $ extension ] ) ) { $ this -> resolveLoader ( $ extension ) ; } return $ this -> loaders [ $ extension ] ; }
2765	public function isUpToDate ( ) : bool { if ( ! $ this -> isTracking ( ) ) { throw new GitException ( 'Error: HEAD does not have a remote tracking branch. Cannot check if it is up-to-date.' ) ; } $ mergeBase = $ this -> run ( 'merge-base' , [ '@' , '@{u}' ] ) ; $ remoteSha = $ this -> run ( 'rev-parse' , [ '@{u}' ] ) ; return $ mergeBase === $ remoteSha ; }
2644	public function getCustomerInfo ( ) { $ uri = $ this -> config -> getApiEndpoint ( ) . 'current_customer' ; $ result = $ this -> _fetch ( $ uri ) ; return $ result ; }
10219	private static function nbrConversionFormat ( $ xVal , $ places ) { if ( $ places !== null ) { if ( is_numeric ( $ places ) ) { $ places = ( int ) $ places ; } else { return Functions :: VALUE ( ) ; } if ( $ places < 0 ) { return Functions :: NAN ( ) ; } if ( strlen ( $ xVal ) <= $ places ) { return substr ( str_pad ( $ xVal , $ places , '0' , STR_PAD_LEFT ) , - 10 ) ; } return Functions :: NAN ( ) ; } return substr ( $ xVal , - 10 ) ; }
8283	protected function resolveRealUrl ( $ fileName ) { $ fileNameClean = str_replace ( "\0" , '' , $ fileName ) ; $ realPath = realpath ( $ fileNameClean ) ; if ( $ realPath === false ) { return $ this -> requestUrl ; } $ contentPath = realpath ( $ this -> pico -> getConfig ( 'content_dir' ) ) ; $ contentExt = $ this -> pico -> getConfig ( 'content_ext' ) ; if ( strpos ( $ realPath , $ contentPath ) !== 0 ) { throw new \ RuntimeException ( "The plugin cannot be used with " . "symbolic links inside the content directory." ) ; } $ name = substr ( $ realPath , strlen ( $ contentPath ) + 1 , - strlen ( $ contentExt ) ) ; if ( DIRECTORY_SEPARATOR !== '/' ) { $ name = str_replace ( DIRECTORY_SEPARATOR , '/' , $ name ) ; } if ( strlen ( $ name ) >= 5 && 0 === substr_compare ( $ name , "index" , - 5 ) ) { $ name = rtrim ( substr ( $ name , 0 , - 5 ) , '/' ) ; } return $ name ; }
12256	public function getSkylineAppDirectory ( string $ dirName ) { $ name = CC :: get ( [ ] , $ dirName ) ; if ( $ name ) { return $ this -> getSkylineAppDataDirectory ( ) . "/$name" ; } return NULL ; }
2600	public function peek ( ) { if ( isset ( $ this -> tokens [ $ this -> position + $ this -> peek ] ) ) { return $ this -> tokens [ $ this -> position + $ this -> peek ++ ] ; } else { return null ; } }
5099	public function into ( $ table , array $ fields = null ) { $ this -> setPart ( CmdInsert :: PART_INTO , $ table ) ; if ( ! is_null ( $ fields ) ) { $ this -> placeholder = false ; $ this -> fields = $ fields ; } return $ this ; }
68	public function junction ( $ target , $ junction ) { if ( ! Platform :: isWindows ( ) ) { throw new \ LogicException ( sprintf ( 'Function %s is not available on non-Windows platform' , __CLASS__ ) ) ; } if ( ! is_dir ( $ target ) ) { throw new IOException ( sprintf ( 'Cannot junction to "%s" as it is not a directory.' , $ target ) , 0 , null , $ target ) ; } $ cmd = sprintf ( 'mklink /J %s %s' , ProcessExecutor :: escape ( str_replace ( '/' , DIRECTORY_SEPARATOR , $ junction ) ) , ProcessExecutor :: escape ( realpath ( $ target ) ) ) ; if ( $ this -> getProcess ( ) -> execute ( $ cmd , $ output ) !== 0 ) { throw new IOException ( sprintf ( 'Failed to create junction to "%s" at "%s".' , $ target , $ junction ) , 0 , null , $ target ) ; } clearstatcache ( true , $ junction ) ; }
8378	public function setAction ( AbstractAction $ action ) { $ this -> action = $ action ; $ this -> action -> setArrayContainer ( $ this ) ; return $ this ; }
12446	protected function _setContainer ( $ container ) { if ( ! is_null ( $ container ) && ! ( $ container instanceof BaseContainerInterface ) ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Not a valid container' ) , 0 , null , $ container ) ; } $ this -> container = $ container ; return $ this ; }
6578	public function parse ( $ url ) { $ parts = $ this -> _parse_url ( $ url ) ; foreach ( array ( 'user' , 'pass' , 'fragment' ) as $ part ) if ( isset ( $ parts [ $ part ] ) ) $ parts [ $ part ] = urldecode ( $ parts [ $ part ] ) ; if ( isset ( $ parts [ 'host' ] ) ) $ parts [ 'host' ] = idn_to_utf8 ( $ parts [ 'host' ] ) ; if ( isset ( $ parts [ 'path' ] ) ) $ parts [ 'path' ] = rawurldecode ( str_ireplace ( '%2F' , '%252F' , $ parts [ 'path' ] ) ) ; return $ this -> setParts ( $ parts ) ; }
2318	public static function getPath ( $ src ) { if ( $ src == '' ) { return '' ; } $ src = rawurldecode ( $ src ) ; if ( strpos ( $ src , '/' ) !== false ) { return $ src ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ src , 'icon' , 4 ) === 0 ) { if ( pathinfo ( $ src , PATHINFO_EXTENSION ) == 'svg' ) { return 'assets/contao/images/' . $ src ; } $ filename = pathinfo ( $ src , PATHINFO_FILENAME ) ; if ( file_exists ( $ rootDir . '/assets/contao/images/' . $ filename . '.svg' ) ) { return 'assets/contao/images/' . $ filename . '.svg' ; } return 'assets/contao/images/' . $ src ; } else { $ theme = Backend :: getTheme ( ) ; if ( pathinfo ( $ src , PATHINFO_EXTENSION ) == 'svg' ) { return 'system/themes/' . $ theme . '/icons/' . $ src ; } $ filename = pathinfo ( $ src , PATHINFO_FILENAME ) ; if ( file_exists ( $ rootDir . '/system/themes/' . $ theme . '/icons/' . $ filename . '.svg' ) ) { return 'system/themes/' . $ theme . '/icons/' . $ filename . '.svg' ; } return 'system/themes/' . $ theme . '/images/' . $ src ; } }
5674	protected function isMatchingKeys ( $ first , $ second , $ identical ) { $ first_keys = array_keys ( $ first ) ; $ second_keys = array_keys ( $ second ) ; if ( $ identical ) { return ( $ first_keys === $ second_keys ) ; } sort ( $ first_keys ) ; sort ( $ second_keys ) ; return ( $ first_keys == $ second_keys ) ; }
4909	public function renderForm ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ formHelper = $ renderer -> plugin ( 'form' ) ; $ fieldset = $ form -> getBaseFieldset ( ) ; $ resetPartial = false ; if ( $ fieldset instanceof ViewPartialProviderInterface ) { $ origPartial = $ fieldset -> getViewPartial ( ) ; $ partial = "$origPartial.form" ; if ( $ renderer -> resolver ( $ partial ) ) { $ fieldset -> setViewPartial ( $ partial ) ; $ resetPartial = true ; } } $ markup = $ formHelper -> renderBare ( $ form , $ layout , $ parameter ) ; if ( $ resetPartial ) { $ fieldset -> setViewPartial ( $ origPartial ) ; } return $ markup ; }
2744	public function execute ( \ Magento \ Framework \ Event \ Observer $ observer ) { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { $ this -> purgeCache -> sendPurgeRequest ( ) ; } }
9631	public function setSetting ( $ key , $ value ) { $ settings = $ this -> getSettings ( ) ; $ settings [ $ key ] = $ value ; $ this -> setSettings ( $ settings ) ; }
7072	protected function getAttachmentFromEvent ( ResourceEventInterface $ event ) { $ attachment = $ event -> getResource ( ) ; if ( ! $ attachment instanceof TicketAttachmentInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketAttachmentInterface :: class ) ; } return $ attachment ; }
388	public function getAttributeOrder ( $ attribute ) { $ orders = $ this -> getAttributeOrders ( ) ; return isset ( $ orders [ $ attribute ] ) ? $ orders [ $ attribute ] : null ; }
189	public function setTransactionIsolationLevel ( $ level ) { switch ( $ level ) { case Transaction :: SERIALIZABLE : $ this -> db -> createCommand ( 'PRAGMA read_uncommitted = False;' ) -> execute ( ) ; break ; case Transaction :: READ_UNCOMMITTED : $ this -> db -> createCommand ( 'PRAGMA read_uncommitted = True;' ) -> execute ( ) ; break ; default : throw new NotSupportedException ( get_class ( $ this ) . ' only supports transaction isolation levels READ UNCOMMITTED and SERIALIZABLE.' ) ; } }
12128	public function run ( InputInterface $ input , OutputInterface $ output ) { $ this -> returnCode = static :: RETURN_SUCCESS ; $ this -> doPreRun ( $ input , $ output ) ; if ( ! $ this -> executeDependencies ( $ input , $ output ) ) { $ this -> returnCode = static :: RETURN_ERROR ; } else { $ this -> returnCode = ( int ) $ this -> execute ( $ input , $ output ) ; } $ this -> doPostRun ( $ input , $ output , $ this -> returnCode ) ; return $ this -> returnCode ; }
11801	public function hookTemplateRender ( $ templates , $ data , $ rendered , $ controller ) { $ template = reset ( $ templates ) ; if ( strpos ( $ template , '/modules/ga_report/templates/panels/' ) !== false && isset ( $ data [ 'content' ] [ 'data' ] [ 'report' ] [ 'data' ] ) && isset ( $ data [ 'content' ] [ 'data' ] [ 'handler' ] [ 'id' ] ) ) { $ handler_id = $ data [ 'content' ] [ 'data' ] [ 'handler' ] [ 'id' ] ; $ controller -> setJsSettings ( "ga_chart_$handler_id" , $ data [ 'content' ] [ 'data' ] [ 'report' ] [ 'data' ] ) ; $ controller -> setJs ( __DIR__ . "/js/handlers/$handler_id.js" ) ; $ controller -> setJs ( __DIR__ . "/js/common.js" ) ; } }
4815	public function getAsDom ( ) { $ anyDataSet = XmlUtil :: createXmlDocumentFromStr ( "<anydataset></anydataset>" ) ; $ nodeRoot = $ anyDataSet -> getElementsByTagName ( "anydataset" ) -> item ( 0 ) ; foreach ( $ this -> collection as $ sr ) { $ row = $ sr -> getAsDom ( ) ; $ nodeRow = $ row -> getElementsByTagName ( "row" ) -> item ( 0 ) ; $ newRow = XmlUtil :: createChild ( $ nodeRoot , "row" ) ; XmlUtil :: addNodeFromNode ( $ newRow , $ nodeRow ) ; } return $ anyDataSet ; }
5409	public function selectAsPairs ( $ url ) { $ pairs = array ( ) ; foreach ( $ this -> cookies as $ cookie ) { if ( $ this -> isMatch ( $ cookie , $ url -> getHost ( ) , $ url -> getPath ( ) , $ cookie -> getName ( ) ) ) { $ pairs [ ] = $ cookie -> getName ( ) . '=' . $ cookie -> getValue ( ) ; } } return $ pairs ; }
9647	public function whateverMatches ( string $ param ) : RouteBuilder { if ( array_key_exists ( $ param , $ this -> matchers ) ) { unset ( $ this -> matchers [ $ param ] ) ; } return $ this ; }
12593	public function setOperator ( $ operator ) { $ this -> checkParams ( $ this -> operation , $ operator ) ; $ this -> operator = $ operator ; }
5130	protected function withString ( string $ string , string $ name = 'query' ) : self { $ string = ltrim ( ( string ) $ string , '#' ) ; $ clone = clone $ this ; $ clone -> { $ name } = $ this -> filterQuery ( $ string ) ; return $ clone ; }
7664	function AttachAll ( ) { $ mime = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> attachment ) ; $ i ++ ) { $ bString = $ this -> attachment [ $ i ] [ 5 ] ; if ( $ bString ) $ string = $ this -> attachment [ $ i ] [ 0 ] ; else $ path = $ this -> attachment [ $ i ] [ 0 ] ; $ filename = $ this -> attachment [ $ i ] [ 1 ] ; $ name = $ this -> attachment [ $ i ] [ 2 ] ; $ encoding = $ this -> attachment [ $ i ] [ 3 ] ; $ type = $ this -> attachment [ $ i ] [ 4 ] ; $ disposition = $ this -> attachment [ $ i ] [ 6 ] ; $ cid = $ this -> attachment [ $ i ] [ 7 ] ; $ mime [ ] = sprintf ( "--%s%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Type: %s; name=\"%s\"%s" , $ type , $ name , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Transfer-Encoding: %s%s" , $ encoding , $ this -> LE ) ; if ( $ disposition == "inline" ) $ mime [ ] = sprintf ( "Content-ID: <%s>%s" , $ cid , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Disposition: %s; filename=\"%s\"%s" , $ disposition , $ name , $ this -> LE . $ this -> LE ) ; if ( $ bString ) { $ mime [ ] = $ this -> EncodeString ( $ string , $ encoding ) ; if ( $ this -> IsError ( ) ) { return "" ; } $ mime [ ] = $ this -> LE . $ this -> LE ; } else { $ mime [ ] = $ this -> EncodeFile ( $ path , $ encoding ) ; if ( $ this -> IsError ( ) ) { return "" ; } $ mime [ ] = $ this -> LE . $ this -> LE ; } } $ mime [ ] = sprintf ( "--%s--%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; return join ( "" , $ mime ) ; }
4892	protected function getGenerator ( ) { if ( isset ( $ this -> generator ) ) { return $ this -> generator ; } if ( $ this -> entity instanceof SnapshotGeneratorProviderInterface ) { $ serviceLocator = $ this -> getServicelocator ( ) ; $ className = get_class ( $ this -> entity ) ; if ( $ serviceLocator -> has ( 'snapshotgenerator' . $ className ) ) { $ generator = $ this -> serviceLocator -> get ( 'snapshotgenerator' . $ className ) ; if ( is_array ( $ generator ) ) { $ this -> options = ArrayUtils :: merge ( $ generator , $ this -> options ) ; $ generator = null ; } } if ( ! isset ( $ generator ) ) { $ generator = $ this -> entity -> getSnapshotGenerator ( ) ; if ( is_array ( $ generator ) ) { $ this -> options = ArrayUtils :: merge ( $ generator , $ this -> options ) ; if ( array_key_exists ( 'generator' , $ generator ) ) { $ generator = $ this -> options [ 'generator' ] ; unset ( $ this -> options [ 'generator' ] ) ; } else { $ generator = null ; } } if ( is_string ( $ generator ) ) { $ generator = $ serviceLocator -> get ( $ generator ) ; } } if ( ! isset ( $ generator ) ) { $ generator = new SnapshotGenerator ( ) ; } if ( array_key_exists ( 'hydrator' , $ this -> options ) ) { $ hydrator = $ this -> options [ 'hydrator' ] ; if ( is_string ( $ hydrator ) && ! empty ( $ hydrator ) ) { $ hydrator = $ serviceLocator -> get ( 'HydratorManager' ) -> get ( $ hydrator ) ; } $ generator -> setHydrator ( $ hydrator ) ; } if ( array_key_exists ( 'exclude' , $ this -> options ) ) { $ hydrator = $ generator -> getHydrator ( ) ; $ exclude = $ this -> options [ 'exclude' ] ; if ( is_array ( $ exclude ) ) { $ hydrator -> setExcludeMethods ( $ exclude ) ; } } $ generator -> setSource ( $ this -> entity ) ; $ this -> generator = $ generator ; } return $ this -> generator ; }
9851	public static function hashPassword ( $ pPassword ) { $ password = 0x0000 ; $ charPos = 1 ; $ chars = preg_split ( '//' , $ pPassword , - 1 , PREG_SPLIT_NO_EMPTY ) ; foreach ( $ chars as $ char ) { $ value = ord ( $ char ) << $ charPos ++ ; $ rotated_bits = $ value >> 15 ; $ value &= 0x7fff ; $ password ^= ( $ value | $ rotated_bits ) ; } $ password ^= strlen ( $ pPassword ) ; $ password ^= 0xCE4B ; return strtoupper ( dechex ( $ password ) ) ; }
11959	public function splice ( $ offset = 0 , $ length = 0 , $ replacement = [ ] ) { return new static ( array_splice ( $ this -> elements , $ offset , $ length , $ replacement ) ) ; }
10024	public static function flattenArrayIndexed ( $ array ) { if ( ! is_array ( $ array ) ) { return ( array ) $ array ; } $ arrayValues = [ ] ; foreach ( $ array as $ k1 => $ value ) { if ( is_array ( $ value ) ) { foreach ( $ value as $ k2 => $ val ) { if ( is_array ( $ val ) ) { foreach ( $ val as $ k3 => $ v ) { $ arrayValues [ $ k1 . '.' . $ k2 . '.' . $ k3 ] = $ v ; } } else { $ arrayValues [ $ k1 . '.' . $ k2 ] = $ val ; } } } else { $ arrayValues [ $ k1 ] = $ value ; } } return $ arrayValues ; }
3855	public function setMetaTags ( $ strTitleAttribute , $ strDescriptionAttribute ) { $ this -> strDescriptionAttribute = $ strDescriptionAttribute ; $ this -> strTitleAttribute = $ strTitleAttribute ; return $ this ; }
11606	public function getPHPHint ( $ namespaceContext = NULL ) { if ( ! isset ( $ this -> class ) ) { return '\stdClass' ; } if ( isset ( $ namespaceContext ) && trim ( $ this -> class -> getNamespace ( ) , '\\' ) === trim ( $ namespaceContext , '\\' ) ) { return $ this -> class -> getName ( ) ; } return '\\' . $ this -> class -> getFQN ( ) ; }
5548	public function getUrl ( ) { if ( is_integer ( $ this -> focus ) ) { $ url = $ this -> frames [ $ this -> focus ] -> getUrl ( ) ; $ url -> setTarget ( $ this -> getPublicNameFromIndex ( $ this -> focus ) ) ; } else { $ url = $ this -> frameset -> getUrl ( ) ; } return $ url ; }
3427	public function addFilter ( $ filters ) { foreach ( $ filters as $ field => $ value ) { $ this -> filter [ $ field ] = $ value ; } return $ this ; }
9826	private function writeRelationship ( XMLWriter $ objWriter , $ pId , $ pType , $ pTarget , $ pTargetMode = '' ) { if ( $ pType != '' && $ pTarget != '' ) { $ objWriter -> startElement ( 'Relationship' ) ; $ objWriter -> writeAttribute ( 'Id' , 'rId' . $ pId ) ; $ objWriter -> writeAttribute ( 'Type' , $ pType ) ; $ objWriter -> writeAttribute ( 'Target' , $ pTarget ) ; if ( $ pTargetMode != '' ) { $ objWriter -> writeAttribute ( 'TargetMode' , $ pTargetMode ) ; } $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
12859	public function addRoute ( string $ verb , string $ path , array $ callback ) : Router { $ this -> routeCollector -> addRoute ( $ verb , $ path , $ callback ) ; return $ this ; }
10229	public function set_language ( ) { $ plugin_slug = App :: EFG ( ) -> getOption ( 'slug' ) ; $ module_slug = Module :: CustomImagesGrifus ( ) -> getOption ( 'slug' ) ; $ path = $ plugin_slug . '/modules/' . $ module_slug . '/languages/' ; load_plugin_textdomain ( $ plugin_slug . '-images' , false , $ path ) ; }
12030	function addFilteredParameterMethod ( ) { $ methodGenerator = new MethodGenerator ( 'getFilteredParameter' ) ; $ body = 'if (array_key_exists($name, $this->parameters) == false) {' . PHP_EOL ; $ body .= ' throw new \Exception(\'Parameter \'.$name.\' does not exist.\');' . PHP_EOL ; $ body .= '}' . PHP_EOL ; $ body .= '' . PHP_EOL ; $ body .= '$value = $this->parameters[$name];' . PHP_EOL ; $ body .= '' . PHP_EOL ; $ paramFilterBlocks = [ ] ; foreach ( $ this -> operationDefinition -> getParameters ( ) as $ parameter ) { $ parameterFilters = $ parameter -> getFilters ( ) ; if ( count ( $ parameterFilters ) ) { $ paramFilterBlocks [ ] = $ this -> generateParamFilterBlock ( $ parameter ) ; } } if ( count ( $ paramFilterBlocks ) ) { $ body .= 'switch ($name) {' . PHP_EOL ; $ body .= '' . PHP_EOL ; foreach ( $ paramFilterBlocks as $ paramFilterBlock ) { $ body .= $ paramFilterBlock . PHP_EOL ; $ body .= '' . PHP_EOL ; } $ body .= ' default:{}' . PHP_EOL ; $ body .= '' . PHP_EOL ; $ body .= '}' . PHP_EOL ; } $ body .= '' . PHP_EOL ; $ body .= 'return $value;' . PHP_EOL ; $ methodGenerator -> setBody ( $ body ) ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Apply any filters necessary to the parameter' ) ; $ parameterGenerator = new ParameterGenerator ( 'name' , 'string' ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ tag = createParamTag ( $ parameterGenerator , "The name of the parameter to get." ) ; $ docBlock -> setTag ( $ tag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
2823	public function deleteExpiredRequests ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( ! $ helper -> isEnabled ( ) ) { return 'skipped: module is disabled.' ; } if ( $ helper -> getPersistLifetime ( ) == 0 ) { return 'skipped: lifetime is set to 0' ; } $ expirationDate = $ this -> getExpirationDate ( date ( self :: DATE_FORMAT ) ) ; $ table = $ this -> getRequestsTable ( ) ; $ deleteSql = "DELETE FROM {$table} WHERE date <= '{$expirationDate}'" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return "{$result->rowCount()} requests deleted" ; }
7179	public function getType ( ) { if ( is_string ( $ this -> type ) ) { $ type = $ this -> type ; } elseif ( is_array ( $ this -> type ) ) { $ type = reset ( $ this -> type ) ; } else { $ type = null ; } return $ this -> isValidType ( $ type ) ? $ type : self :: ANY ; }
3077	public function processOutput ( QtiRunnerServiceContext $ context ) { $ messages = [ ] ; $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; if ( is_array ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] ) ) { foreach ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] as $ outputChannelName => $ outputChannelClass ) { $ channel = $ this -> getChannel ( $ outputChannelName , self :: CHANNEL_TYPE_OUTPUT ) ; $ message = $ this -> processChannel ( $ channel , $ context ) ; if ( $ message !== null ) { $ messages [ ] = [ 'channel' => $ channel -> getName ( ) , 'message' => $ message , ] ; } } } return $ messages ; }
3033	public function getSessionDescription ( \ taoQtiTest_helpers_TestSession $ session ) { if ( $ session -> isRunning ( ) ) { $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ progressScope = isset ( $ config [ 'progress-indicator-scope' ] ) ? $ config [ 'progress-indicator-scope' ] : 'test' ; $ progress = $ this -> getSessionProgress ( $ session ) ; $ itemPosition = $ progress [ $ progressScope ] ; $ itemCount = $ progress [ $ progressScope . 'Length' ] ; $ format = $ this -> hasOption ( self :: OPTION_STATE_FORMAT ) ? $ this -> getOption ( self :: OPTION_STATE_FORMAT ) : __ ( '%s - item %p/%c' ) ; $ map = array ( '%s' => $ session -> getCurrentAssessmentSection ( ) -> getTitle ( ) , '%p' => $ itemPosition , '%c' => $ itemCount ) ; return strtr ( $ format , $ map ) ; } else { return __ ( 'finished' ) ; } }
4081	public function getRenderSetting ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> information [ $ metaModelName ] [ self :: COMBINATION ] [ 'view_id' ] ) ? $ this -> information [ $ metaModelName ] [ self :: COMBINATION ] [ 'view_id' ] : null ; }
1632	public function log ( $ level , $ message , array $ context = [ ] ) { parent :: log ( $ level , $ message , $ context ) ; $ this -> fireLogEvent ( $ level , $ message , $ context ) ; }
7059	public function addClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( ! in_array ( $ class , $ classes ) ) { $ classes [ ] = $ class ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
7982	public function addDeleteTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaDeleteTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
9344	public function addCol ( $ arr_col ) { if ( isset ( $ this -> arr [ 0 ] ) && ( count ( $ this -> arr [ 0 ] ) == $ this -> size -> cols ) ) { throw new \ OutOfRangeException ( sprintf ( 'You cannot add another column! Max number of columns is %d' , $ this -> size -> cols ) ) ; } if ( count ( $ arr_col ) != $ this -> size -> rows ) { throw new \ InvalidArgumentException ( 'New column must have same amout of rows than previous columns.' ) ; } $ arr_col = array_values ( $ arr_col ) ; foreach ( $ arr_col as $ k => $ v ) { $ this -> arr [ $ k ] [ ] = $ arr_col [ $ k ] ; } return $ this ; }
3735	protected function saveAttribute ( $ objAttribute , $ arrIds , $ varData , $ strLangCode ) { if ( $ this -> isSimpleAttribute ( $ objAttribute ) ) { $ varData = $ objAttribute -> serializeData ( $ varData ) ; } $ arrData = array ( ) ; foreach ( $ arrIds as $ intId ) { $ arrData [ $ intId ] = $ varData ; } if ( $ strLangCode && $ this -> isTranslatedAttribute ( $ objAttribute ) ) { $ objAttribute -> setTranslatedDataFor ( $ arrData , $ strLangCode ) ; } elseif ( $ this -> isComplexAttribute ( $ objAttribute ) ) { $ objAttribute -> setDataFor ( $ arrData ) ; } elseif ( $ this -> isSimpleAttribute ( $ objAttribute ) ) { $ objAttribute -> setDataFor ( $ arrData ) ; } else { throw new \ RuntimeException ( 'Unknown attribute type, can not save. Interfaces implemented: ' . implode ( ', ' , class_implements ( $ objAttribute ) ) ) ; } }
8404	public static function registerApp ( string $ namespace , string $ path = null ) { $ namespace = rtrim ( $ namespace , '\\' ) ; if ( $ path == null ) { $ path = constant ( 'STRAY_PATH_APPS' ) . str_replace ( '_' , DIRECTORY_SEPARATOR , str_replace ( '\\' , DIRECTORY_SEPARATOR , $ namespace ) ) ; } self :: $ namespaces [ $ namespace ] = $ path ; self :: $ applications [ ] = $ namespace ; }
10702	public static function getPasswordComplexity ( $ password , $ minLength ) { $ group = [ 'upper' => '/[A-Z]/' , 'lower' => '/[a-z]/' , 'number' => '/[0-9]/' , 'special' => '/[^A-Za-z0-9]/' , ] ; $ score = 0 ; $ length = \ strlen ( $ password ) ; if ( $ length < $ minLength ) { return 0 ; } foreach ( $ group as $ pattern ) { if ( preg_match ( $ pattern , $ password ) ) { $ score ++ ; } } if ( $ score < 3 ) { $ score -- ; } if ( $ length > $ minLength ) { $ score += ( int ) floor ( ( $ length - $ minLength ) / 2 ) ; } return $ score ; }
684	public function mergeRules ( array $ rules ) { $ this -> setRules ( ArrayHelper :: merge ( $ this -> getRules ( ) , $ rules ) ) ; return $ this ; }
9744	public function setState ( $ state ) { if ( ! $ state ) { return $ this ; } if ( ! ( $ state instanceof State ) ) { $ state = new State ( $ state ) ; } if ( $ state -> isEmpty ( ) ) { $ this -> invalidArguments ( '10002' ) ; } return $ this -> setParameter ( 'state' , $ state ) ; }
8416	public function commit ( ) : bool { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( $ this -> transactionLevel > 0 ) { -- $ this -> transactionLevel ; if ( $ this -> transactionLevel == 0 ) { return $ this -> providerDatabase -> commit ( $ this -> GetMasterLink ( ) ) ; } return $ this -> providerDatabase -> releaseSavePoint ( $ this -> GetMasterLink ( ) , 'LEVEL' . $ this -> transactionLevel ) ; } return false ; }
4963	public function addViewTemplate ( $ name , $ template , $ vars = [ ] , $ priority = 0 ) { if ( is_int ( $ vars ) ) { $ priority = $ vars ; $ vars = [ ] ; } $ model = new ViewModel ( $ vars ) ; $ model -> setTemplate ( $ template ) ; return $ this -> addViewModel ( $ name , $ model , $ priority ) ; }
1327	public function toUrl ( ) { $ postData = $ this -> toPostdata ( ) ; $ out = $ this -> getNormalizedHttpUrl ( ) ; if ( $ postData ) { $ out .= '?' . $ postData ; } return $ out ; }
6871	private function initializeMethod ( ShipmentInterface $ shipment ) { if ( null !== $ shipment -> getMethod ( ) ) { return ; } $ sale = $ shipment -> getSale ( ) ; if ( null === $ method = $ sale -> getShipmentMethod ( ) ) { return ; } $ gateway = $ this -> registry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( ! $ shipment -> isReturn ( ) && $ gateway -> supports ( GatewayInterface :: CAPABILITY_SHIPMENT ) ) { $ shipment -> setMethod ( $ method ) ; return ; } if ( $ shipment -> isReturn ( ) && $ gateway -> supports ( GatewayInterface :: CAPABILITY_RETURN ) ) { $ shipment -> setMethod ( $ method ) ; return ; } }
11291	protected function _getAttributeDataWhenSet ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { if ( is_numeric ( $ this -> model_data [ $ attributeName ] ) ) { if ( $ this -> _isRelation ( $ attributeName ) && ! isset ( $ this -> model_dynamicOff ) ) { $ this -> $ attributeName = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap , $ record ) ; } } $ this -> beforeGet ( $ attributeName ) ; $ returnValue = $ this -> model_data [ $ attributeName ] ; $ this -> afterGet ( $ attributeName , $ returnValue ) ; return $ returnValue ; }
9311	protected function query ( $ uri , $ data = [ ] ) { $ this -> setActionUri ( $ uri ) ; try { $ response = $ this -> client -> get ( $ this -> uri , [ 'query' => $ data ] ) ; } catch ( ClientException $ e ) { $ response = $ e -> getResponse ( ) ; } catch ( ServerException $ e ) { $ response = $ e -> getResponse ( ) ; } return $ this -> responseToJson ( $ response ) ; }
291	public function populateRelation ( $ name , $ records ) { foreach ( $ this -> _relationsDependencies as & $ relationNames ) { unset ( $ relationNames [ $ name ] ) ; } $ this -> _related [ $ name ] = $ records ; }
4793	function order ( $ columns ) { $ this -> rows = null ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { if ( $ this -> union ) { $ this -> unionOrder [ ] = $ columns ; } else { $ this -> order [ ] = $ columns ; } } } elseif ( $ this -> union ) { $ this -> unionOrder = array ( ) ; } else { $ this -> order = array ( ) ; } return $ this ; }
8279	public function onRequestFile ( & $ file ) { if ( $ this -> errorOccurred ) { $ file = $ this -> requestFile ; return ; } try { $ realUrl = ( $ this -> requestFile ) ? $ this -> requestUrl : $ this -> resolveRealUrl ( $ file ) ; if ( ! in_array ( $ realUrl , $ this -> alwaysAllowed , true ) ) { $ this -> triggerEvent ( 'denyAccessIfRestricted' , [ $ realUrl ] ) ; } } catch ( \ Exception $ e ) { $ realUrl = ( isset ( $ realUrl ) ) ? $ realUrl : "" ; $ this -> errorHandler ( $ e , $ realUrl ) ; } if ( $ this -> requestFile ) { $ file = $ this -> requestFile ; } else { switch ( $ this -> requestUrl ) { case 'login' : $ file = $ this -> pluginDir . '/content/login.md' ; break ; case 'logout' : $ file = $ this -> pluginDir . '/content/logout.md' ; break ; } } }
8642	public function getReportRequestListByNextToken ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestListByNextToken ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestListByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11465	public static function assert ( $ file , $ line , $ expression ) { $ Exception = new PHPAssertionFailed ( '' , 0 , null , $ file , $ line , $ expression ) ; if ( assert_options ( ASSERT_BAIL ) ) { self :: exception ( $ Exception ) ; } else { throw $ Exception ; } }
3924	public function getValueOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ options = $ this -> getOptionsViaDcGeneral ( $ metaModel , $ event -> getEnvironment ( ) , $ attribute ) ; $ mangled = [ ] ; foreach ( ( array ) $ options as $ key => $ option ) { $ mangled [ 'value_' . $ key ] = $ option ; } $ event -> setOptions ( $ mangled ) ; } }
4597	public function setDeserializeValues ( ? bool $ deserializeValues ) { $ this -> deserializeValues = $ deserializeValues ; $ this -> _deserializeValues = null !== $ deserializeValues ; return $ this ; }
6887	private function httpGet ( $ path , array $ query = array ( ) ) { $ url = new Uri ( $ this -> baseUrl . $ path ) ; foreach ( $ query as $ name => $ value ) { $ url = Uri :: withQueryValue ( $ url , $ name , $ value ) ; } $ request = new Request ( 'GET' , $ url , $ this -> buildHeaders ( ) ) ; try { $ response = $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; } catch ( \ RuntimeException $ e ) { throw new Exception \ PostcodeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } if ( $ response -> getStatusCode ( ) != 200 ) { throw $ this -> createErrorException ( $ response ) ; } return $ response ; }
11332	public function setAttributes ( $ value ) { $ this -> _attributes = $ value ; if ( $ this -> model ) { $ this -> _model -> attributes = $ value ; } }
5981	protected function buildBasepath ( $ url ) { if ( ! preg_match ( '#(\w+:)?//#' , $ url ) ) { $ url = '//' . $ url ; } $ urlParts = parse_url ( $ url ) ; if ( false === $ urlParts ) { throw new \ InvalidArgumentException ( 'Could not parse QBank URL.' ) ; } if ( empty ( $ urlParts [ 'scheme' ] ) ) { $ urlParts [ 'scheme' ] = 'http' ; } if ( ( empty ( $ urlParts [ 'path' ] ) || '/' == $ urlParts [ 'path' ] ) && 'qbank.se' == substr ( $ urlParts [ 'host' ] , - strlen ( 'qbank.se' ) ) ) { $ urlParts [ 'path' ] = '/api/' ; } if ( '/' != substr ( $ urlParts [ 'path' ] , - 1 ) ) { $ urlParts [ 'path' ] .= '/' ; } return $ urlParts [ 'scheme' ] . '://' . $ urlParts [ 'host' ] . ( ! empty ( $ urlParts [ 'port' ] ) ? ':' . $ urlParts [ 'port' ] : '' ) . $ urlParts [ 'path' ] ; }
8351	protected function toSqlLevel ( array $ tree ) : string { if ( count ( $ tree ) == 0 ) { return '' ; } $ sql = '(' ; reset ( $ tree ) ; if ( is_numeric ( key ( $ tree ) ) === true ) { foreach ( $ tree as $ elem ) { $ sql .= $ elem . ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } elseif ( key ( $ tree ) === 'OR' ) { foreach ( $ tree as $ value ) { if ( is_array ( $ value ) === true ) { $ sql .= $ this -> toSqlLevel ( $ value ) ; } else { $ sql .= $ value ; } $ sql .= ' OR ' ; } $ sql = substr ( $ sql , 0 , - 4 ) ; } elseif ( key ( $ tree ) === 'AND' ) { foreach ( $ tree as $ value ) { if ( is_array ( $ value ) === true ) { $ sql .= $ this -> toSqlLevel ( $ value ) ; } else { $ sql .= $ value ; } $ sql .= ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } else { foreach ( $ tree as $ key => $ value ) { $ sql .= $ key . ' = ' . $ value . ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } $ sql .= ')' ; return $ sql ; }
8681	public function set ( $ key , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; $ this -> items [ $ key ] = $ value ; }
1776	protected function isSelected ( $ arrOption ) { if ( empty ( $ this -> varValue ) && empty ( $ _POST ) && $ arrOption [ 'default' ] ) { return static :: optionSelected ( 1 , 1 ) ; } return static :: optionSelected ( $ arrOption [ 'value' ] , $ this -> varValue ) ; }
5330	public function getEmojiPattern ( ) { if ( null === self :: $ emojiPattern ) { $ codeString = '' ; foreach ( $ this -> getEmojiCodeList ( ) as $ code ) { if ( is_array ( $ code ) ) { $ first = dechex ( array_shift ( $ code ) ) ; $ last = dechex ( array_pop ( $ code ) ) ; $ codeString .= '\x{' . $ first . '}-\x{' . $ last . '}' ; } else { $ codeString .= '\x{' . dechex ( $ code ) . '}' ; } } self :: $ emojiPattern = "/[$codeString]/u" ; } return self :: $ emojiPattern ; }
5673	protected function describeArrayDifference ( $ first , $ second , $ identical ) { if ( ! is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } if ( ! $ this -> isMatchingKeys ( $ first , $ second , $ identical ) ) { return sprintf ( 'as key list [%s] does not match key list [%s]' , implode ( ', ' , array_keys ( $ first ) ) , implode ( ', ' , array_keys ( $ second ) ) ) ; } foreach ( array_keys ( $ first ) as $ key ) { if ( $ identical && ( $ first [ $ key ] === $ second [ $ key ] ) ) { continue ; } if ( ! $ identical && ( $ first [ $ key ] == $ second [ $ key ] ) ) { continue ; } return sprintf ( 'with member [%s] %s' , $ key , $ this -> describeDifference ( $ first [ $ key ] , $ second [ $ key ] , $ identical ) ) ; } return '' ; }
5400	protected function truncateHost ( $ host ) { $ tlds = SimpleUrl :: getAllTopLevelDomains ( ) ; if ( preg_match ( '/[a-z\-]+\.(' . $ tlds . ')$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } elseif ( preg_match ( '/[a-z\-]+\.[a-z\-]+\.[a-z\-]+$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } return false ; }
8290	protected function checkLogoutSubmission ( ) { $ post = $ this -> request -> request ; if ( $ post -> has ( "logout" ) ) { if ( ! $ this -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: LOGOUT_CSRF_ACTION ) ) { $ this -> redirectToPage ( "logout" ) ; } $ this -> logout ( ) ; } }
4344	protected function pushStack ( $ funcName ) { $ this -> funcStack [ ] = array ( 'function' => $ funcName , 'tsStart' => $ this -> timeLastTick , 'subTime' => 0 , ) ; if ( ! isset ( $ this -> data [ $ funcName ] ) ) { $ this -> data [ $ funcName ] = array ( 'calls' => 0 , 'totalTime' => 0 , 'ownTime' => 0 , ) ; } $ this -> data [ $ funcName ] [ 'calls' ] ++ ; }
8258	protected function finishAuthentication ( Request $ httpRequest ) { $ sessionCode = $ this -> session -> get ( "oauth2state" ) ; $ this -> session -> remove ( "oauth2state" ) ; if ( $ httpRequest -> query -> get ( "state" ) !== $ sessionCode ) { $ this -> onStateMismatch ( ) ; } if ( $ httpRequest -> query -> has ( "error" ) ) { $ this -> onOAuthError ( $ httpRequest -> query -> get ( "error" ) ) ; } if ( ! $ httpRequest -> query -> has ( "code" ) ) { $ this -> onOAuthError ( "no_code" ) ; } try { $ accessToken = $ this -> provider -> getAccessToken ( 'authorization_code' , [ 'code' => $ httpRequest -> query -> get ( "code" ) , ] ) ; $ resourceOwner = $ this -> provider -> getResourceOwner ( $ accessToken ) ; $ this -> saveLoginInfo ( $ resourceOwner ) ; } catch ( IdentityProviderException $ e ) { $ this -> onOauthResourceError ( $ e ) ; } }
10801	public function renderPageHistoricContentFiltersActionsAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPagehistoricTable' ) ; $ actions = $ melisPageHistoricTable -> getPageHistoricListOfActions ( ) -> toArray ( ) ; $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ options = '<option value="">' . $ translator -> translate ( 'tr_melispagehistoric_filter_action_select' ) . '</option>' ; foreach ( $ actions as $ action ) { $ options .= '<option value="' . $ action [ 'action' ] . '">' . $ action [ 'action' ] . '</option>' ; } $ view = new ViewModel ( ) ; $ view -> options = $ options ; return $ view ; }
5249	public function save ( $ child ) { $ children = ! is_array ( $ child ) ? [ $ child ] : $ child ; foreach ( $ children as $ child ) { $ child -> setParent ( $ this -> parent ) ; $ child -> save ( ) ; } }
2079	public function purgeInternalCache ( ) { $ container = System :: getContainer ( ) ; $ clearer = $ container -> get ( 'contao.cache.clear_internal' ) ; $ clearer -> clear ( $ container -> getParameter ( 'kernel.cache_dir' ) ) ; $ this -> log ( 'Purged the internal cache' , __METHOD__ , TL_CRON ) ; }
851	public function getTokenNotOfKindSibling ( $ index , $ direction , array $ tokens = [ ] ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( $ this -> isEmptyAt ( $ index ) ) { continue ; } if ( $ this [ $ index ] -> equalsAny ( $ tokens ) ) { continue ; } return $ index ; } }
3400	protected function makeRequest ( $ arguments = [ ] ) { $ defaults = $ this -> getDefaultOptions ( ) ; $ arguments = array_merge ( $ defaults , $ arguments ) ; $ client = $ this -> resource -> getGuzzle ( ) ; $ request = $ client -> createRequest ( $ this -> getMethod ( ) , $ this -> url , $ arguments ) ; $ response = $ client -> send ( $ request ) ; $ this -> setResponse ( $ response ) ; $ this -> setContent ( ( string ) $ response -> getBody ( ) ) ; }
9421	public function getContents ( ) { if ( is_null ( $ this -> stream ) || ! $ this -> isReadable ( ) ) { $ message = 'Could not get contents of stream' ; throw new \ RuntimeException ( $ message ) ; } return stream_get_contents ( $ this -> stream ) ; }
5883	public function beforeFind ( Event $ event , Query $ query , ArrayObject $ options , $ primary ) { $ orders = $ this -> _config [ 'orders' ] ; $ args = [ $ query , $ options , $ primary ] ; foreach ( $ orders as $ config ) { if ( ( ! empty ( $ config [ 'callback' ] ) && call_user_func_array ( $ config [ 'callback' ] , $ args ) ) || ! $ query -> clause ( 'order' ) ) { $ query -> order ( $ config [ 'order' ] ) ; break ; } } }
2069	public function cutPage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_PAGE_HIERARCHY , $ row ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
12186	public function getCompanionNiceId ( $ queryRole ) { $ companionRoleType = $ this -> companionRoleType ( $ queryRole ) ; if ( empty ( $ companionRoleType ) ) { return false ; } return implode ( ':' , [ $ this -> companionRole ( $ queryRole ) , $ companionRoleType -> systemId ] ) ; }
3141	public function move ( RunnerServiceContext $ context , $ direction , $ scope , $ ref ) { $ result = true ; if ( $ context instanceof QtiRunnerServiceContext ) { try { $ result = QtiRunnerNavigation :: move ( $ direction , $ scope , $ context , $ ref ) ; if ( $ result ) { $ this -> continueInteraction ( $ context ) ; } } catch ( AssessmentTestSessionException $ e ) { switch ( $ e -> getCode ( ) ) { case AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW : case AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW : case AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW : case AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW : $ this -> onTimeout ( $ context , $ e ) ; break ; } } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'move' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; }
7341	protected function assertDeletable ( ResourceInterface $ resource ) { if ( $ resource instanceof Model \ SupplierOrderItemInterface ) { if ( null === $ stockUnit = $ resource -> getStockUnit ( ) ) { return ; } if ( 0 < $ stockUnit -> getShippedQuantity ( ) ) { throw new Exception \ IllegalOperationException ( "Supplier delivery can't be removed as at least one " . "of its items is linked to a shipped stock unit." ) ; } } elseif ( $ resource instanceof Model \ SupplierOrderInterface ) { foreach ( $ resource -> getItems ( ) as $ item ) { $ this -> assertDeletable ( $ item ) ; } } elseif ( $ resource instanceof Model \ SupplierDeliveryItemInterface ) { $ this -> assertDeletable ( $ resource -> getOrderItem ( ) ) ; } elseif ( $ resource instanceof Model \ SupplierDeliveryInterface ) { foreach ( $ resource -> getItems ( ) as $ item ) { $ this -> assertDeletable ( $ item ) ; } } else { throw new Exception \ InvalidArgumentException ( "Unexpected resource." ) ; } }
6920	static public function validateIdentity ( ExecutionContextInterface $ context , IdentityInterface $ identity , array $ config = [ ] , $ pathPrefix = null ) { $ violationList = $ context -> getValidator ( ) -> validate ( $ identity , [ new Identity ( $ config ) ] ) ; if ( ! empty ( $ pathPrefix ) ) { $ pathPrefix = rtrim ( $ pathPrefix , '.' ) . '.' ; } foreach ( $ violationList as $ violation ) { $ context -> buildViolation ( $ violation -> getMessage ( ) ) -> atPath ( $ pathPrefix . $ violation -> getPropertyPath ( ) ) -> addViolation ( ) ; } }
7257	public function urlAllowed ( $ url ) { if ( $ this -> _viewAuth ) { return $ this -> _viewAuth [ 'AuthActions' ] -> urlAllowed ( $ this -> user ( ) , $ url ) ; } return false ; }
1402	public function getErrors ( ) { if ( ! is_null ( $ this -> errors ) ) { return collect ( $ this -> errors ) ; } try { $ this -> errors = $ this -> parse ( ) ; } catch ( \ Exception $ ex ) { $ this -> errors = [ ] ; } return collect ( $ this -> errors ) ; }
6533	protected function getConnectionFactory ( $ type ) { if ( false === isset ( $ this -> connectionFactories [ $ type ] ) ) { throw new \ InvalidArgumentException ( "Missing connection factory \"$type\"" ) ; } return $ this -> connectionFactories [ $ type ] ; }
3964	private function getJsonFile ( $ filename ) { if ( ! is_readable ( $ filename ) ) { return [ ] ; } $ contents = json_decode ( file_get_contents ( $ filename ) , true ) ; return $ contents ? : [ ] ; }
8622	public function setGetLowestOfferListingsForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetLowestOfferListingsForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2938	public function deleteBackups ( $ filePaths = [ ] ) { if ( empty ( $ filePaths ) ) { $ allBackups = $ this -> getBackups ( ) ; foreach ( $ allBackups as $ backup ) { $ filePaths [ ] = $ backup [ 'filepath' ] ; } } foreach ( $ filePaths as $ filePath ) { if ( is_file ( $ filePath ) ) { unlink ( $ filePath ) ; } } return $ this ; }
4858	public function getList ( $ namespace , $ callback ) { $ session = new Container ( $ namespace ) ; $ params = $ session -> params ? : array ( ) ; if ( ! $ session -> list ) { $ session -> list = is_array ( $ callback ) ? call_user_func ( $ callback , $ session -> params ) : $ callback -> getPaginationList ( $ session -> params ) ; } return $ session -> list ; }
10766	private function implodeContent ( ) { ksort ( $ this -> content ) ; $ output = '' ; foreach ( $ this -> content as $ key => $ value ) { $ output .= $ key . self :: KV_DELIMITER . $ value . self :: DELIMITER ; } return rtrim ( $ output , self :: DELIMITER ) ; }
6710	protected function parseHeader ( array $ headers = [ ] ) { $ processedHeaders = array ( ) ; foreach ( $ headers as $ key => $ value ) { if ( substr ( $ key , 0 , 5 ) == 'HTTP_' ) { $ name = str_replace ( ' ' , '-' , ucwords ( strtolower ( str_replace ( '_' , ' ' , substr ( $ key , 5 ) ) ) ) ) ; $ processedHeaders [ $ name ] = $ value ; } elseif ( $ key == 'CONTENT_TYPE' ) { $ processedHeaders [ 'Content-Type' ] = $ value ; } elseif ( $ key == 'CONTENT_LENGTH' ) { $ processedHeaders [ 'Content-Length' ] = $ value ; } } return $ processedHeaders ; }
4089	protected function buildUrl ( $ path = false , array $ options = array ( ) ) { $ isAbsolute = ( is_array ( $ path ) ? $ path [ 0 ] [ 0 ] : $ path [ 0 ] ) === '/' ; $ url = $ isAbsolute || null === $ this -> index ? '' : "/" . $ this -> index ; if ( $ path && is_array ( $ path ) && count ( $ path ) > 0 ) $ url .= "/" . implode ( "/" , array_filter ( $ path ) ) ; if ( substr ( $ url , - 1 ) == "/" ) $ url = substr ( $ url , 0 , - 1 ) ; if ( count ( $ options ) > 0 ) $ url .= "?" . http_build_query ( $ options , '' , '&' ) ; return $ url ; }
4729	public function isSingular ( $ word ) { $ inflection = $ this -> getCachedPlural ( $ word ) ; if ( $ inflection !== false ) { return true ; } $ pluralWord = $ this -> toPlural ( $ word ) ; if ( $ pluralWord === false ) { return false ; } return $ this -> toSingular ( $ pluralWord ) == $ word ; }
9014	public function longtext ( string $ charset = null ) : self { $ this -> type = 'longtext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
10240	public function calculateCellValue ( Cell $ pCell = null , $ resetLog = true ) { if ( $ pCell === null ) { return null ; } $ returnArrayAsType = self :: $ returnArrayAsType ; if ( $ resetLog ) { $ this -> formulaError = null ; $ this -> debugLog -> clearLog ( ) ; $ this -> cyclicReferenceStack -> clear ( ) ; $ this -> cyclicFormulaCounter = 1 ; self :: $ returnArrayAsType = self :: RETURN_ARRAY_AS_ARRAY ; } $ this -> cellStack [ ] = [ 'sheet' => $ pCell -> getWorksheet ( ) -> getTitle ( ) , 'cell' => $ pCell -> getCoordinate ( ) , ] ; try { $ result = self :: unwrapResult ( $ this -> _calculateFormulaValue ( $ pCell -> getValue ( ) , $ pCell -> getCoordinate ( ) , $ pCell ) ) ; $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; } catch ( \ Exception $ e ) { $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; throw new Exception ( $ e -> getMessage ( ) ) ; } if ( ( is_array ( $ result ) ) && ( self :: $ returnArrayAsType != self :: RETURN_ARRAY_AS_ARRAY ) ) { self :: $ returnArrayAsType = $ returnArrayAsType ; $ testResult = Functions :: flattenArray ( $ result ) ; if ( self :: $ returnArrayAsType == self :: RETURN_ARRAY_AS_ERROR ) { return Functions :: VALUE ( ) ; } if ( count ( $ testResult ) != 1 ) { $ r = array_keys ( $ result ) ; $ r = array_shift ( $ r ) ; if ( ! is_numeric ( $ r ) ) { return Functions :: VALUE ( ) ; } if ( is_array ( $ result [ $ r ] ) ) { $ c = array_keys ( $ result [ $ r ] ) ; $ c = array_shift ( $ c ) ; if ( ! is_numeric ( $ c ) ) { return Functions :: VALUE ( ) ; } } } $ result = array_shift ( $ testResult ) ; } self :: $ returnArrayAsType = $ returnArrayAsType ; if ( $ result === null ) { return 0 ; } elseif ( ( is_float ( $ result ) ) && ( ( is_nan ( $ result ) ) || ( is_infinite ( $ result ) ) ) ) { return Functions :: NAN ( ) ; } return $ result ; }
2344	protected function createIfNotExists ( ) { if ( file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { return ; } if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strFile , 'wb' ) ) { throw new \ Exception ( sprintf ( 'Cannot create file "%s"' , $ this -> strFile ) ) ; } }
11157	public function handleUrl ( $ url , Event $ event , Queue $ queue ) { $ logger = $ this -> getLogger ( ) ; $ logger -> info ( 'handleUrl' , array ( 'url' => $ url ) ) ; $ v = $ this -> getVideoId ( $ url ) ; $ logger -> info ( 'getVideoId' , array ( 'url' => $ url , 'v' => $ v ) ) ; if ( ! $ v ) { return ; } $ apiUrl = $ this -> getApiUrl ( $ v ) ; $ request = $ this -> getApiRequest ( $ apiUrl , $ event , $ queue ) ; $ this -> getEventEmitter ( ) -> emit ( 'http.request' , array ( $ request ) ) ; }
3497	public function addDefaultVisitors ( ) : Http20Builder { if ( $ this -> addedDefaultVisitors ) { return $ this ; } $ this -> addedDefaultVisitors = true ; $ this -> addVisitor ( new AddExpirationHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddPriorityHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddApnIdHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddCollapseIdHeaderVisitor ( ) ) ; return $ this ; }
2513	protected function isWorseStatus ( $ newStatus , $ currentStatus ) { $ levels = [ self :: STATUS_UNKNOWN => - 1 , self :: STATUS_OK => 0 , self :: STATUS_INFO => 2 , self :: STATUS_WARN => 5 , self :: STATUS_ERROR => 10 , self :: STATUS_FATAL => 20 , ] ; return ( $ currentStatus === null || $ levels [ $ newStatus ] > $ levels [ $ currentStatus ] ) ; }
12705	public function getContentAttribute ( $ value ) { if ( $ value === null ) { $ value = '' ; } if ( getenv ( "BYPASS_HOOKS" ) != true ) { global $ hooks , $ codes ; return markdown_interpreter ( $ hooks -> apply_filters ( "TCT-Core-Main-Model-Page-Content" , $ codes -> do_shortcode ( $ value ) ) ) ; } else { return $ value ; } }
7663	function AddAttachment ( $ path , $ name = "" , $ encoding = "base64" , $ type = "application/octet-stream" ) { if ( ! @ is_file ( $ path ) ) { $ this -> SetError ( $ this -> Lang ( "file_access" ) . $ path ) ; return false ; } $ filename = basename ( $ path ) ; if ( $ name == "" ) $ name = $ filename ; $ cur = count ( $ this -> attachment ) ; $ this -> attachment [ $ cur ] [ 0 ] = $ path ; $ this -> attachment [ $ cur ] [ 1 ] = $ filename ; $ this -> attachment [ $ cur ] [ 2 ] = $ name ; $ this -> attachment [ $ cur ] [ 3 ] = $ encoding ; $ this -> attachment [ $ cur ] [ 4 ] = $ type ; $ this -> attachment [ $ cur ] [ 5 ] = false ; $ this -> attachment [ $ cur ] [ 6 ] = "attachment" ; $ this -> attachment [ $ cur ] [ 7 ] = 0 ; return true ; }
7047	protected function buildAddressData ( Common \ AddressInterface $ address , string $ locale ) { $ country = Intl :: getRegionBundle ( ) -> getCountryName ( $ address -> getCountry ( ) -> getCode ( ) , $ locale ) ; $ fullName = trim ( $ address -> getFirstName ( ) . ' ' . $ address -> getLastName ( ) ) ; $ data = [ 'company' => $ address -> getCompany ( ) , 'full_name' => $ fullName , 'street' => $ address -> getStreet ( ) , 'complement' => $ address -> getComplement ( ) , 'supplement' => $ address -> getSupplement ( ) , 'postal_code' => $ address -> getPostalCode ( ) , 'city' => $ address -> getCity ( ) , 'country' => $ country , 'state' => '' , 'phone' => $ this -> formatPhoneNumber ( $ address -> getPhone ( ) ) , 'mobile' => $ this -> formatPhoneNumber ( $ address -> getMobile ( ) ) , ] ; if ( $ address instanceof RelayPointInterface ) { $ data [ 'number' ] = $ address -> getNumber ( ) ; } return $ data ; }
2678	public function updateAclItem ( $ aclId , $ aclItemId , $ itemValue , $ negated , $ comment = '' , $ subnet = false ) { $ body = [ 'ip' => $ itemValue , 'negated' => $ negated , 'comment' => $ comment ] ; if ( $ subnet ) { $ body [ 'subnet' ] = $ subnet ; } $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry/' . $ aclItemId ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , json_encode ( $ body ) ) ; return $ result ; }
1842	public function process ( ContainerBuilder $ container ) : void { if ( ! $ container -> has ( 'contao.fragment.registry' ) ) { return ; } $ this -> registerFragments ( $ container , ContentElementReference :: TAG_NAME ) ; $ this -> registerFragments ( $ container , FrontendModuleReference :: TAG_NAME ) ; }
7639	public static function createResourceName ( $ containerName = '' , $ blobName = '' ) { $ resourceName = $ containerName . '/' . $ blobName ; if ( $ containerName === '' || $ containerName === '$root' ) { $ resourceName = $ blobName ; } if ( $ blobName === '' ) { $ resourceName = $ containerName ; } return $ resourceName ; }
6380	public function readAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'quiz_attempts' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/quiz/attempt.php?attempt=' . $ id ; $ model -> name = 'Attempt ' . $ id ; return $ model ; }
1396	public function updated ( $ resource = null , array $ links = [ ] , $ meta = null , array $ headers = [ ] ) { return $ this -> getResourceResponse ( $ resource , $ links , $ meta , $ headers ) ; }
1130	public function makeFirstChildOf ( $ node ) { if ( $ node -> children ( ) -> count ( ) == 0 ) return $ this -> makeChildOf ( $ node ) ; return $ this -> moveToLeftOf ( $ node -> children ( ) -> first ( ) ) ; }
1064	private function collectConflictsWithin ( ValidationContext $ context , array & $ conflicts , array $ fieldMap ) { foreach ( $ fieldMap as $ responseName => $ fields ) { $ fieldsLength = count ( $ fields ) ; if ( $ fieldsLength <= 1 ) { continue ; } for ( $ i = 0 ; $ i < $ fieldsLength ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ fieldsLength ; $ j ++ ) { $ conflict = $ this -> findConflict ( $ context , false , $ responseName , $ fields [ $ i ] , $ fields [ $ j ] ) ; if ( ! $ conflict ) { continue ; } $ conflicts [ ] = $ conflict ; } } } }
2391	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> calendarfeeds ) || ! \ is_array ( $ this -> User -> calendarfeeds ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> calendarfeeds ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_calendar_feed' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_calendar_feed' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, calendarfeeds, calendarfeedp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT calendarfeeds, calendarfeedp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> calendarfeeds = $ root ; } }
2679	public function queryHistoricStats ( array $ parameters ) { $ uri = $ this -> _getHistoricalEndpoint ( ) . '?region=' . $ parameters [ 'region' ] . '&from=' . $ parameters [ 'from' ] . '&to=' . $ parameters [ 'to' ] . '&by=' . $ parameters [ 'sample_rate' ] ; $ result = $ this -> _fetch ( $ uri ) ; return $ result ; }
5849	protected function moduleContent ( array $ row ) { $ this -> formResultCompiler = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormResultCompiler :: class ) ; $ wizard = $ this -> formResultCompiler -> addCssFiles ( ) ; $ wizard .= $ this -> buildForm ( $ row ) ; $ wizard .= $ this -> formResultCompiler -> printNeededJSFunctions ( ) ; $ this -> content .= $ wizard ; }
7764	private function documentOperations ( $ operations ) { if ( null === $ operations ) { return null ; } $ result = array ( ) ; foreach ( $ operations as $ operation ) { $ statusCodes = array ( ) ; foreach ( $ operation -> getStatusCodes ( ) as $ code => $ description ) { $ statusCodes [ ] = array ( 'code' => $ code , 'description' => $ description ) ; } $ result [ ] = array ( '@id' => '_:' . $ operation -> getName ( ) , '@type' => $ operation -> getType ( ) ? : 'hydra:Operation' , 'method' => $ operation -> getMethod ( ) , 'label' => ( $ operation -> getTitle ( ) ) ? : $ operation -> getDescription ( ) , 'description' => ( null === $ operation -> getTitle ( ) ) ? null : $ operation -> getDescription ( ) , 'expects' => $ this -> getTypeReferenceIri ( $ operation -> getExpects ( ) ) , 'returns' => $ this -> getTypeReferenceIri ( $ operation -> getReturns ( ) ) , 'statusCodes' => $ statusCodes ) ; } return $ result ; }
2635	public function checkUpdate ( $ currentVersion = null ) { $ lastVersion = $ this -> getLastVersion ( ) ; if ( ! $ lastVersion || version_compare ( $ lastVersion , $ currentVersion , '<=' ) ) { return ; } $ versionPath = Config :: XML_FASTLY_LAST_CHECKED_ISSUED_VERSION ; $ oldValue = $ this -> scopeConfig -> getValue ( $ versionPath ) ; if ( version_compare ( $ oldValue , $ lastVersion , '<' ) ) { $ this -> configWriter -> save ( $ versionPath , $ lastVersion ) ; $ inboxFactory = $ this -> _inboxFactory ; $ inbox = $ inboxFactory -> create ( ) ; $ inbox -> addNotice ( 'Fastly CDN' , "Version $lastVersion is available. You are currently running $currentVersion." . ' Please consider upgrading at your earliest convenience.' ) ; $ this -> cacheManager -> clean ( [ \ Magento \ Framework \ App \ Cache \ Type \ Config :: TYPE_IDENTIFIER ] ) ; } }
11898	public function getEstimateTimeRemaining ( ) { $ estimatedDuration = $ this -> dataInterface -> estimateDuration ( ) ; if ( $ estimatedDuration ) { $ startedTime = strtotime ( $ this -> started ) ; $ estimatedEndTime = $ startedTime + $ estimatedDuration ; if ( time ( ) > $ estimatedEndTime ) { return false ; } return $ estimatedEndTime - time ( ) ; } return false ; }
12803	public function getADORecordSet ( ) { if ( ! $ this -> sql ) { throw new Exception ( 'Web2All_Table_Collection_SimpleDataProvider::getADORecordSet: no SQL query set' ) ; } return $ this -> db -> SelectLimit ( $ this -> sql , $ this -> limit , $ this -> offset , $ this -> params ) ; }
6479	public function getClientIPAddress ( IHttpRequestMessage $ request ) : ? string { $ clientIPAddress = null ; $ request -> getProperties ( ) -> tryGet ( self :: CLIENT_IP_ADDRESS_PROPERTY , $ clientIPAddress ) ; return $ clientIPAddress ; }
9563	protected function callHandler ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return $ handler -> handle ( $ exception ) ; } return call_user_func ( $ handler , $ exception ) ; }
11906	public function handle ( ServerRequestInterface $ request ) : ResponseInterface { $ msg = "This is the default request handler. This means no middleware produced a response before hitting it." ; $ contents = json_encode ( [ 'type' => MiddlewareStackExhaustedException :: class , 'message' => $ msg , ] ) ; $ response = $ this -> factory -> createResponse ( 404 ) -> withHeader ( 'Content-type' , 'application/json' ) ; $ response -> getBody ( ) -> write ( $ contents ) ; return $ response ; }
7974	public function getSender ( $ domain , $ sender ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ sender ) throw new BadMethodCallException ( 'Parameter $sender is missing.' ) ; $ sender = urlencode ( $ sender ) ; try { $ r = $ this -> get ( 'sms/' . $ domain . '/senders/' . $ sender ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
4513	public function toObject ( ) : stdClass { $ object = new stdClass ; $ object -> timestamp = $ this -> timestamp ; $ object -> collection = $ this -> collection -> toArray ( ) ; foreach ( $ object -> collection as $ alias => $ status ) { $ object -> collection [ $ alias ] = $ status -> toObject ( ) ; } return $ object ; }
8973	private function filter ( $ sources , array $ filters = array ( ) ) { $ result = array ( ) ; foreach ( $ sources as $ source ) { if ( SourceFilterUtil :: matches ( $ source , $ filters ) ) { $ result [ ] = $ source ; } } return $ result ; }
8770	protected function bindPathsInContainer ( ) { $ this -> instance ( 'path' , $ this -> path ( ) ) ; $ this -> instance ( 'path.base' , $ this -> basePath ( ) ) ; $ this -> instance ( 'path.lang' , $ this -> langPath ( ) ) ; $ this -> instance ( 'path.config' , $ this -> configPath ( ) ) ; $ this -> instance ( 'path.storage' , $ this -> storagePath ( ) ) ; $ this -> instance ( 'path.database' , $ this -> databasePath ( ) ) ; $ this -> instance ( 'path.cache' , $ this -> cachePath ( ) ) ; $ this -> instance ( 'path.public' , $ this -> publicPath ( ) ) ; }
6550	public function current ( ) { if ( $ this -> iterator -> valid ( ) === false ) { return null ; } $ iterator = $ this -> iterator -> current ( ) -> getCellIterator ( ) ; $ iterator -> setIterateOnlyExistingCells ( false ) ; $ result = [ ] ; foreach ( $ iterator as $ cell ) { $ result [ ] = $ cell -> getValue ( ) ; } return $ result ; }
4244	private function buildErrorList ( ) { $ errorStr = '' ; $ errors = $ this -> debug -> errorHandler -> get ( 'errors' ) ; \ uasort ( $ errors , function ( $ a1 , $ a2 ) { return \ strcmp ( $ a1 [ 'file' ] . $ a1 [ 'line' ] , $ a2 [ 'file' ] . $ a2 [ 'line' ] ) ; } ) ; $ lastFile = '' ; foreach ( $ errors as $ error ) { if ( $ error [ 'isSuppressed' ] ) { continue ; } if ( $ error [ 'file' ] !== $ lastFile ) { $ errorStr .= $ error [ 'file' ] . ':' . "\n" ; $ lastFile = $ error [ 'file' ] ; } $ typeStr = $ error [ 'type' ] === E_STRICT ? 'Strict' : $ error [ 'typeStr' ] ; $ errorStr .= ' Line ' . $ error [ 'line' ] . ': (' . $ typeStr . ') ' . $ error [ 'message' ] . "\n" ; } return $ errorStr ; }
1621	public function buildColumn ( $ query , $ column ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "n=n+1 pks[n]=redis.call('HGET',$key .. pk," . $ this -> quoteValue ( $ column ) . ")" , 'pks' ) ; }
6785	public function buildFormDataString ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ formOptions = [ ] ; foreach ( $ this -> formParameters as $ key => $ isFormParameter ) { if ( $ isFormParameter && isset ( $ options [ $ key ] ) ) { $ formOptions [ $ key ] = $ options [ $ key ] ; } } return http_build_query ( $ formOptions ) ; }
6987	protected function fillFromCustomer ( ContextInterface $ context , CustomerInterface $ customer ) : void { if ( null === $ context -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ customer -> getCustomerGroup ( ) ) ; } if ( null === $ context -> getInvoiceCountry ( ) ) { if ( null !== $ address = $ customer -> getDefaultInvoiceAddress ( true ) ) { $ context -> setInvoiceCountry ( $ address -> getCountry ( ) ) ; } } if ( null === $ context -> getDeliveryCountry ( ) ) { if ( null !== $ address = $ customer -> getDefaultDeliveryAddress ( true ) ) { $ context -> setDeliveryCountry ( $ address -> getCountry ( ) ) ; } } }
10266	public function setRotation ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'rotation' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> rotation = $ pValue ; } return $ this ; }
11682	public function init ( ) { $ request = $ this -> getRequest ( ) ; if ( $ request -> isGet ( ) ) { $ action = $ this -> getParam ( 'id' ) ? 'get' : 'index' ; } else { $ action = $ this -> getParam ( 'x-method' , $ request -> getMethod ( ) ) ; } $ request -> setActionName ( $ action ) -> setDispatched ( false ) -> setParam ( 'action' , $ action ) ; }
6149	public function sendJson ( $ data , $ statusCode = null ) { return $ this -> setStatusCode ( $ statusCode ) -> setJsonBody ( $ data ) -> send ( ) ; }
1749	protected function import ( $ strClass , $ strKey = null , $ blnForce = false ) { $ strKey = $ strKey ? : $ strClass ; if ( \ is_object ( $ strKey ) ) { $ strKey = \ get_class ( $ strClass ) ; } if ( $ blnForce || ! isset ( $ this -> arrObjects [ $ strKey ] ) ) { $ container = static :: getContainer ( ) ; if ( \ is_object ( $ strClass ) ) { $ this -> arrObjects [ $ strKey ] = $ strClass ; } elseif ( $ container -> has ( $ strClass ) && ( strpos ( $ strClass , '\\' ) !== false || ! class_exists ( $ strClass ) ) ) { $ this -> arrObjects [ $ strKey ] = $ container -> get ( $ strClass ) ; } elseif ( $ container instanceof Container && isset ( $ container -> getRemovedIds ( ) [ $ strClass ] ) ) { throw new ServiceNotFoundException ( $ strClass , null , null , array ( ) , sprintf ( 'The "%s" service or alias has been removed or inlined when the container was compiled. You should either make it public, or stop using the container directly and use dependency injection instead.' , $ strClass ) ) ; } elseif ( \ in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) { $ this -> arrObjects [ $ strKey ] = \ call_user_func ( array ( $ strClass , 'getInstance' ) ) ; } else { $ this -> arrObjects [ $ strKey ] = new $ strClass ( ) ; } } }
6706	public function beforeUpdate ( $ event ) { if ( is_array ( $ this -> fields ) ) { foreach ( $ this -> fields as $ field ) { if ( is_array ( $ event -> sender -> { $ field } ) ) { $ event -> sender -> { $ field } = implode ( ';' , $ event -> sender -> { $ field } ) ; } } } }
748	protected function buildCompleteString ( $ format ) { $ placeholderValues = [ '{type}' => $ this -> type , '{length}' => $ this -> buildLengthString ( ) , '{unsigned}' => $ this -> buildUnsignedString ( ) , '{notnull}' => $ this -> buildNotNullString ( ) , '{unique}' => $ this -> buildUniqueString ( ) , '{default}' => $ this -> buildDefaultString ( ) , '{check}' => $ this -> buildCheckString ( ) , '{comment}' => $ this -> buildCommentString ( ) , '{pos}' => $ this -> isFirst ? $ this -> buildFirstString ( ) : $ this -> buildAfterString ( ) , '{append}' => $ this -> buildAppendString ( ) , ] ; return strtr ( $ format , $ placeholderValues ) ; }
12560	public function fixFileSlashes ( $ file , & $ contents ) { $ changed = false ; foreach ( $ contents as $ lineNumber => $ line ) { if ( preg_match ( '/(psesd|canis|cascade)\\\\\\\/' , $ line ) === 1 ) { $ fixedLine = preg_replace ( '/\\\\\\\/' , '\\' , $ line ) ; if ( $ fixedLine !== $ line ) { $ contents [ $ lineNumber ] = $ fixedLine ; $ changed = true ; } } } return $ changed ; }
4923	public function removeTypeFromRegion ( $ type , $ region ) { if ( array_key_exists ( $ region , $ this -> matrix ) ) { array_walk ( $ this -> matrix [ $ region ] , function ( $ value , $ idx , $ matrix ) use ( $ type , $ region ) { $ class = explode ( '\\' , $ value ) ; $ className = array_pop ( $ class ) ; if ( $ className === $ type ) { unset ( $ matrix [ $ region ] [ $ idx ] ) ; } } , $ this -> matrix ) ; } return $ this ; }
6488	protected function getClientIPAddress ( array $ server ) : ? string { $ serverRemoteAddress = $ server [ 'REMOTE_ADDR' ] ?? null ; if ( $ this -> isUsingTrustedProxy ( $ server ) ) { return $ serverRemoteAddress ?? null ; } $ ipAddresses = [ ] ; if ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ) ) { $ header = $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ; preg_match_all ( "/for=(?:\"?\[?)([a-z0-9:\.\-\/_]*)/" , $ header , $ matches ) ; $ ipAddresses = $ matches [ 1 ] ; } elseif ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ) { $ ipAddresses = explode ( ',' , $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ; $ ipAddresses = array_map ( 'trim' , $ ipAddresses ) ; } if ( $ serverRemoteAddress !== null ) { $ ipAddresses [ ] = $ serverRemoteAddress ; } $ fallbackIPAddresses = count ( $ ipAddresses ) === 0 ? [ ] : [ $ ipAddresses [ 0 ] ] ; foreach ( $ ipAddresses as $ index => $ ipAddress ) { if ( filter_var ( $ ipAddress , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) === false ) { unset ( $ ipAddresses [ $ index ] ) ; } if ( in_array ( $ ipAddress , $ this -> trustedProxyIPAddresses , true ) ) { unset ( $ ipAddresses [ $ index ] ) ; } } $ clientIPAddresses = count ( $ ipAddresses ) === 0 ? $ fallbackIPAddresses : array_reverse ( $ ipAddresses ) ; return $ clientIPAddresses [ 0 ] ?? null ; }
9659	public static function createReader ( $ readerType ) { if ( ! isset ( self :: $ readers [ $ readerType ] ) ) { throw new Reader \ Exception ( "No reader found for type $readerType" ) ; } $ className = self :: $ readers [ $ readerType ] ; $ reader = new $ className ( ) ; return $ reader ; }
10719	public function addThumbnail ( \ TYPO3 \ CMS \ Extbase \ Domain \ Model \ FileReference $ thumbnail ) { $ this -> thumbnails -> attach ( $ thumbnail ) ; }
11742	public function add ( Theme $ theme , array $ pageValues ) { $ pageName = $ pageValues [ "name" ] ; $ pageDir = $ this -> pagesDir . '/' . $ pageName ; $ this -> pageExists ( $ pageDir ) ; if ( ! @ mkdir ( $ pageDir ) ) { $ this -> folderNotCreated ( $ pageDir ) ; } $ seoValues = $ pageValues [ "seo" ] ; unset ( $ pageValues [ "seo" ] ) ; $ encodedPage = json_encode ( $ pageValues ) ; $ pageFile = $ pageDir . '/' . $ this -> pageFile ; $ event = Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDING , new PageCollectionAddingEvent ( $ pageFile , $ encodedPage ) ) ; $ encodedPage = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ pageFile , $ encodedPage ) ; if ( $ this -> pageFile != 'page.json' ) { FilesystemTools :: writeFile ( $ pageDir . '/page.json' , $ encodedPage ) ; } foreach ( $ seoValues as $ seoValue ) { $ languageName = $ seoValue [ "language" ] ; unset ( $ seoValue [ "language" ] ) ; $ languageDir = $ pageDir . '/' . $ languageName ; @ mkdir ( $ languageDir ) ; FilesystemTools :: writeFile ( $ languageDir . '/' . $ this -> seoFile , json_encode ( $ seoValue ) ) ; $ theme -> addTemplateSlots ( $ pageValues [ "template" ] , $ this -> username ) ; } Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDED , new PageCollectionAddedEvent ( $ pageFile , $ encodedPage ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully added to the website' , $ pageName ) ) ; return $ pageValues ; }
11553	public function dispatch ( DispatchConfirmationInterface $ dispatchConfirmation ) { try { $ event = new EventDispatchConfirmation ( $ dispatchConfirmation ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENTS_DISPATCH , $ event ) ; $ adapter = $ this -> getAdapter ( $ dispatchConfirmation -> getConsignments ( ) -> first ( ) ) ; $ adapter -> dispatch ( $ dispatchConfirmation ) ; $ this -> dispatchConfirmationRepository -> saveDispatchConfirmation ( $ dispatchConfirmation ) ; foreach ( $ dispatchConfirmation -> getConsignments ( ) as $ consignment ) { $ consignment -> setDispatchConfirmation ( $ dispatchConfirmation ) ; $ previousStatus = $ consignment -> getStatus ( ) ; foreach ( $ consignment -> getParcels ( ) as $ parcel ) { $ parcel -> setStatus ( ConsignmentStatusList :: STATUS_DISPATCHED ) ; } $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_DISPATCHED ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; $ this -> dispatchOnConsignmentStatusChange ( $ consignment , $ previousStatus ) ; } $ event = new EventDispatchConfirmation ( $ dispatchConfirmation ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENTS_DISPATCH , $ event ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignments dispatching.' , null , $ e ) ; } }
5498	public function expectArguments ( $ method , $ args , $ message ) { $ args = $ this -> replaceWildcards ( $ args ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args [ strtolower ( $ method ) ] = new ParametersExpectation ( $ args , $ message ) ; }
2259	protected function createInitialVersion ( $ strTable , $ intId ) { @ trigger_error ( 'Using Controller::createInitialVersion() has been deprecated and will no longer work in Contao 5.0. Use Versions->initialize() instead.' , E_USER_DEPRECATED ) ; $ objVersions = new Versions ( $ strTable , $ intId ) ; $ objVersions -> initialize ( ) ; }
3372	private function getFormFactory ( ContainerInterface $ services ) { $ elements = null ; if ( $ services -> has ( 'FormElementManager' ) ) { $ elements = $ services -> get ( 'FormElementManager' ) ; } return new Factory ( $ elements ) ; }
7261	protected function assertAdjustmentType ( Model \ AdjustmentInterface $ adjustment , string $ expected ) : void { if ( $ expected !== $ type = $ adjustment -> getType ( ) ) { throw new Exception \ InvalidArgumentException ( "Unexpected adjustment type '$type'." ) ; } }
2188	public function register ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; if ( isset ( $ this -> arrIdentities [ $ intObjectId ] ) ) { return ; } $ strTable = $ objModel -> getTable ( ) ; if ( ! \ is_array ( $ this -> arrAliases [ $ strTable ] ) ) { $ this -> arrAliases [ $ strTable ] = array ( ) ; } if ( ! \ is_array ( $ this -> arrRegistry [ $ strTable ] ) ) { $ this -> arrRegistry [ $ strTable ] = array ( ) ; } $ strPk = $ objModel -> getPk ( ) ; $ varPk = $ objModel -> $ strPk ; if ( $ varPk === null ) { throw new \ RuntimeException ( 'The primary key has not been set' ) ; } if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ varPk ] ) ) { throw new \ RuntimeException ( "The registry already contains an instance for $strTable::$strPk($varPk)" ) ; } $ this -> arrIdentities [ $ intObjectId ] = $ objModel ; $ this -> arrRegistry [ $ strTable ] [ $ varPk ] = $ objModel ; $ objModel -> onRegister ( $ this ) ; }
12655	public function addTextContainer ( $ name , $ content , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { throw new \ Exception ( "Text container name already used." ) ; } $ this -> contents [ $ language ] [ $ name ] = array ( 'id' => $ name , 'name' => $ name , 'content' => $ content , 'outdated' => false ) ; $ this -> writeTextsToFile ( $ language ) ; if ( $ language === $ this -> baseLang ) { $ this -> setExtraLanguagesOutdated ( $ name , $ content ) ; } return $ this -> contents [ $ language ] [ $ name ] ; }
7391	public function assign ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; if ( empty ( $ in ) ) { foreach ( $ this -> _publicNames as $ publicName ) { $ this -> __unset ( $ publicName ) ; } } elseif ( is_object ( $ in ) ) { foreach ( $ this -> _publicNames as $ publicName ) { if ( isset ( $ in -> { $ publicName } ) ) { $ this -> _setByName ( $ publicName , $ in -> { $ publicName } ) ; } else { $ this -> __unset ( $ publicName ) ; } } } else { foreach ( $ this -> _publicNames as $ publicName ) { if ( isset ( $ in [ $ publicName ] ) ) { $ this -> _setByName ( $ publicName , $ in [ $ publicName ] ) ; } else { $ this -> __unset ( $ publicName ) ; } } } $ this -> _checkRelatedProperties ( ) ; }
2426	protected static function isFileSyncExclude ( $ strPath ) { if ( Config :: get ( 'uploadPath' ) == 'templates' ) { return true ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; while ( $ strPath != '.' && ! is_dir ( $ rootDir . '/' . $ strPath ) ) { $ strPath = \ dirname ( $ strPath ) ; } if ( $ strPath == '.' ) { return true ; } $ uploadPath = System :: getContainer ( ) -> getParameter ( 'contao.upload_path' ) ; if ( strncmp ( $ strPath . '/' , $ uploadPath . '/' , \ strlen ( $ uploadPath ) + 1 ) !== 0 ) { return true ; } return ( new Folder ( $ strPath ) ) -> isUnsynchronized ( ) ; }
662	public function transaction ( callable $ callback , $ isolationLevel = null ) { $ transaction = $ this -> beginTransaction ( $ isolationLevel ) ; $ level = $ transaction -> level ; try { $ result = call_user_func ( $ callback , $ this ) ; if ( $ transaction -> isActive && $ transaction -> level === $ level ) { $ transaction -> commit ( ) ; } } catch ( \ Exception $ e ) { $ this -> rollbackTransactionOnLevel ( $ transaction , $ level ) ; throw $ e ; } catch ( \ Throwable $ e ) { $ this -> rollbackTransactionOnLevel ( $ transaction , $ level ) ; throw $ e ; } return $ result ; }
8284	protected function init ( ) { $ this -> loadModules ( ) ; $ this -> session = $ this -> container -> get ( 'session' ) ; $ this -> csrf = new CSRF ( $ this -> session ) ; $ this -> user = $ this -> getUserFromSession ( ) ; $ this -> request = Request :: createFromGlobals ( ) ; $ this -> sessionTimeoutCheck ( "sessionInterval" , "_migT" , false ) ; $ this -> sessionTimeoutCheck ( "sessionTimeout" , "_start" , true ) ; $ this -> sessionTimeoutCheck ( "sessionIdle" , "_idle" , true , true ) ; }
8588	public function setASINPrepInstructions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ASINPrepInstructions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1977	public function onPreviewUrlCreate ( PreviewUrlCreateEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || 'news' !== $ event -> getKey ( ) ) { return ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_news' === $ request -> query -> get ( 'table' ) && ! $ request -> query -> has ( 'act' ) ) { return ; } if ( null === ( $ newsModel = $ this -> getNewsModel ( $ this -> getId ( $ event , $ request ) ) ) ) { return ; } $ event -> setQuery ( 'news=' . $ newsModel -> id ) ; }
11059	public static function files ( $ path , array $ extensions = array ( ) ) { $ files = array ( ) ; $ it = new \ RecursiveDirectoryIterator ( $ path ) ; $ filter = false ; if ( ! empty ( $ extensions ) && is_array ( $ extensions ) ) { $ filter = true ; } foreach ( new \ RecursiveIteratorIterator ( $ it ) as $ file ) { if ( $ filter ) { $ f = explode ( '.' , $ file ) ; $ ext = strtolower ( array_pop ( $ f ) ) ; if ( in_array ( $ ext , $ extensions ) ) { $ files [ ] = $ file ; } } else { $ files [ ] = $ file ; } } return $ files ; }
9351	public function add ( $ matrix ) { if ( ! ( $ matrix instanceof Matrix ) ) { throw new \ InvalidArgumentException ( 'Given argument must be an instance of \Malenki\Math\Matrix' ) ; } if ( ! $ this -> sameSize ( $ matrix ) ) { throw new \ RuntimeException ( 'Cannot adding given matrix: it has wrong size.' ) ; } $ out = new self ( $ this -> size -> rows , $ this -> size -> cols ) ; foreach ( $ this -> arr as $ k => $ v ) { $ arrOther = $ matrix -> getRow ( $ k ) ; $ arrNew = array ( ) ; foreach ( $ v as $ kk => $ vv ) { if ( $ arrOther [ $ kk ] instanceof Complex ) { $ arrNew [ ] = $ arrOther [ $ kk ] -> add ( $ vv ) ; } elseif ( $ vv instanceof Complex ) { $ arrNew [ ] = $ vv -> add ( $ arrOther [ $ kk ] ) ; } else { $ arrNew [ ] = $ arrOther [ $ kk ] + $ vv ; } } $ out -> addRow ( $ arrNew ) ; } return $ out ; }
6055	public function addMediaToFolder ( $ folderId , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders/' . $ folderId . '/media' , $ parameters ) ; return $ result ; }
1982	public static function hasError ( $ strScope = TL_MODE ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return false ; } return $ session -> getFlashBag ( ) -> has ( static :: getFlashBagKey ( 'error' , $ strScope ) ) ; }
11362	public static function mailTagger ( $ mail = '' , $ name = null ) { return ( ( ! is_int ( $ name ) ? "\"" . $ name . "\" <" : '' ) . $ mail . ( ! is_int ( $ name ) ? ">" : '' ) ) ; }
2905	public function addEmailToProfile ( $ email , $ name , $ variables , $ result , Zend_Mail $ mail ) { $ emailCapture = Mage :: getModel ( 'sheep_debug/email' ) ; $ subject = $ this -> decodeSubject ( $ mail -> getSubject ( ) ) ; $ body = $ this -> getContent ( $ mail ) ; $ emailCapture -> setFromName ( $ this -> getSenderName ( ) ) ; $ emailCapture -> setFromEmail ( $ this -> getSenderEmail ( ) ) ; $ emailCapture -> setToEmail ( $ email ) ; $ emailCapture -> setToName ( $ name ) ; $ emailCapture -> setSubject ( $ subject ) ; $ emailCapture -> setIsPlain ( $ this -> isPlain ( ) ) ; $ emailCapture -> setBody ( $ body ) ; $ emailCapture -> setIsAccepted ( $ result ) ; $ emailCapture -> setVariables ( $ variables ) ; $ emailCapture -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) -> addEmail ( $ emailCapture ) ; }
12492	public static function orderBy ( $ field , $ order ) { if ( ! $ order ) { $ order = 'DESC' ; } $ order = strtoupper ( $ order ) ; if ( ! ( $ order == 'ASC' || $ order == 'DESC' ) ) { throw new ClusterpointException ( "\"->order()\" function: ordering should be DESC or ASC." , 9002 ) ; } if ( ! ( gettype ( $ field ) == "string" || $ field instanceof Key || $ field instanceof Raw ) ) { throw new ClusterpointException ( "\"->order()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } return "{$field} {$order}" ; }
10567	public function newAction ( ) { $ entity = new Media ( ) ; $ form = $ this -> createCreateForm ( $ entity ) ; return $ this -> render ( 'MMMediaBundle:Media:new.html.twig' , array ( 'entity' => $ entity , 'form' => $ form -> createView ( ) , ) ) ; }
2223	protected function doGetTemplateFolders ( $ path , $ level = 0 ) { $ return = array ( ) ; $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( scan ( $ rootDir . '/' . $ path ) as $ file ) { if ( is_dir ( $ rootDir . '/' . $ path . '/' . $ file ) ) { $ return [ $ path . '/' . $ file ] = str_repeat ( ' &nbsp; &nbsp; ' , $ level ) . $ file ; $ return = array_merge ( $ return , $ this -> doGetTemplateFolders ( $ path . '/' . $ file , $ level + 1 ) ) ; } } return $ return ; }
1279	private function extractSpaceId ( array $ data ) : string { if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Space' === $ data [ 'sys' ] [ 'type' ] ) { return $ data [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Environment' === $ data [ 'sys' ] [ 'type' ] ) { return $ this -> spaceId ; } if ( isset ( $ data [ 'sys' ] [ 'space' ] ) ) { return $ data [ 'sys' ] [ 'space' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'space' ] ) ) { return $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'space' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] ) && ! $ data [ 'items' ] ) { return $ this -> spaceId ; } return '[blank]' ; }
9082	private static function parseRemoteHost ( Request & $ request , $ serverVars = array ( ) ) { if ( isset ( $ serverVars [ 'REMOTE_ADDR' ] ) ) { $ request -> remoteHost = $ serverVars [ 'REMOTE_ADDR' ] ; } if ( isset ( $ serverVars [ 'HTTP_X_FORWARDED_FOR' ] ) ) { $ request -> remoteHost = $ serverVars [ 'HTTP_X_FORWARDED_FOR' ] ; } }
385	public function getOrders ( $ recalculate = false ) { $ attributeOrders = $ this -> getAttributeOrders ( $ recalculate ) ; $ orders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ direction ) { $ definition = $ this -> attributes [ $ attribute ] ; $ columns = $ definition [ $ direction === SORT_ASC ? 'asc' : 'desc' ] ; if ( is_array ( $ columns ) || $ columns instanceof \ Traversable ) { foreach ( $ columns as $ name => $ dir ) { $ orders [ $ name ] = $ dir ; } } else { $ orders [ ] = $ columns ; } } return $ orders ; }
5077	public function getId ( $ aData = [ ] ) { $ sIds = '' ; $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; if ( ! empty ( $ oInput -> get ( 'id' ) ) ) { $ sIds = $ oInput -> get ( 'id' ) ; } if ( ! empty ( $ oInput -> get ( 'ids' ) ) ) { $ sIds = $ oInput -> get ( 'ids' ) ; } $ aIds = explode ( ',' , $ sIds ) ; $ aIds = array_filter ( $ aIds ) ; $ aIds = array_unique ( $ aIds ) ; if ( count ( $ aIds ) > self :: CONFIG_MAX_ITEMS_PER_REQUEST ) { throw new ApiException ( 'You can request a maximum of ' . self :: CONFIG_MAX_ITEMS_PER_REQUEST . ' items per request' , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ aResults = $ oItemModel -> getByIds ( $ aIds , $ aData ) ; if ( $ oInput -> get ( 'id' ) ) { $ oItem = reset ( $ aResults ) ; $ mData = $ oItem ? $ this -> formatObject ( $ oItem ) : null ; } else { $ mData = array_map ( [ $ this , 'formatObject' ] , $ aResults ) ; } $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ mData ) ; return $ oResponse ; }
4460	private function fork ( & $ socket ) : int { $ pair = [ ] ; $ domain = ( strtoupper ( substr ( PHP_OS , 0 , 3 ) ) == 'WIN' ? AF_INET : AF_UNIX ) ; if ( \ socket_create_pair ( $ domain , SOCK_STREAM , 0 , $ pair ) === false ) { $ error = socket_strerror ( socket_last_error ( $ pair [ 0 ] ?? null ) ) ; $ this -> logger -> error ( '{type}: unable to create socket pair; ' . $ error , $ this -> logContext ) ; exit ( 0 ) ; } $ pid = pcntl_fork ( ) ; if ( $ pid === - 1 ) { throw new RuntimeException ( 'Unable to fork child worker.' ) ; } if ( $ pid !== 0 ) { $ this -> childProcesses ++ ; $ socket = $ pair [ 0 ] ; socket_close ( $ pair [ 1 ] ) ; socket_set_option ( $ socket , SOL_SOCKET , SO_RCVTIMEO , [ 'sec' => 0 , 'usec' => 10000 ] ) ; return $ pid ; } $ socket = $ pair [ 1 ] ; socket_close ( $ pair [ 0 ] ) ; register_shutdown_function ( $ this -> handleChildErrors ( $ socket ) ) ; return $ pid ; }
1592	protected function validateResource ( ) : bool { $ identifier = $ this -> validateTypeAndId ( ) ; $ attributes = $ this -> validateAttributes ( ) ; $ relationships = $ this -> validateRelationships ( ) ; if ( $ attributes && $ relationships ) { return $ this -> validateAllFields ( ) && $ identifier ; } return $ identifier && $ attributes && $ relationships ; }
4311	public function output ( $ options = array ( ) ) { $ cfgRestore = $ this -> config -> setCfg ( $ options ) ; if ( ! $ this -> cfg [ 'output' ] ) { $ this -> config -> setCfg ( $ cfgRestore ) ; return null ; } $ outputAs = $ this -> output -> getCfg ( 'outputAs' ) ; if ( \ is_string ( $ outputAs ) ) { $ this -> output -> setCfg ( 'outputAs' , $ outputAs ) ; } $ channels = $ this -> getChannels ( true ) ; $ channels [ ] = $ this ; $ headers = array ( ) ; foreach ( $ channels as $ channel ) { $ event = $ channel -> eventManager -> publish ( 'debug.output' , $ channel , array ( 'headers' => array ( ) , 'return' => '' , 'isTarget' => $ channel === $ this , ) ) ; $ headers = \ array_merge ( $ headers , $ event [ 'headers' ] ) ; } if ( ! $ this -> getCfg ( 'outputHeaders' ) || ! $ headers ) { $ this -> data [ 'headers' ] = \ array_merge ( $ this -> data [ 'headers' ] , $ event [ 'headers' ] ) ; } elseif ( \ headers_sent ( $ file , $ line ) ) { \ trigger_error ( 'PHPDebugConsole: headers already sent: ' . $ file . ', line ' . $ line , E_USER_NOTICE ) ; } else { foreach ( $ headers as $ nameVal ) { \ header ( $ nameVal [ 0 ] . ': ' . $ nameVal [ 1 ] ) ; } } if ( ! $ this -> parentInstance ) { $ this -> data [ 'outputSent' ] = true ; } $ this -> config -> setCfg ( $ cfgRestore ) ; return $ event [ 'return' ] ; }
4392	public function checkConfigBE ( array $ attributes ) { return array_merge ( parent :: checkConfigBE ( $ attributes ) , $ this -> checkConfig ( $ this -> beConfig , $ attributes ) ) ; }
1055	public static function findBreakingChanges ( Schema $ oldSchema , Schema $ newSchema ) { return array_merge ( self :: findRemovedTypes ( $ oldSchema , $ newSchema ) , self :: findTypesThatChangedKind ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnObjectOrInterfaceTypes ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnInputObjectTypes ( $ oldSchema , $ newSchema ) [ 'breakingChanges' ] , self :: findTypesRemovedFromUnions ( $ oldSchema , $ newSchema ) , self :: findValuesRemovedFromEnums ( $ oldSchema , $ newSchema ) , self :: findArgChanges ( $ oldSchema , $ newSchema ) [ 'breakingChanges' ] , self :: findInterfacesRemovedFromObjectTypes ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectives ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectiveArgs ( $ oldSchema , $ newSchema ) , self :: findAddedNonNullDirectiveArgs ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectiveLocations ( $ oldSchema , $ newSchema ) ) ; }
4306	public function time ( $ label = null ) { $ args = \ func_get_args ( ) ; $ this -> internal -> getMetaVals ( $ args , array ( ) , array ( 'label' => null ) ) ; \ extract ( $ args ) ; if ( isset ( $ label ) ) { $ timers = & $ this -> data [ 'timers' ] [ 'labels' ] ; if ( ! isset ( $ timers [ $ label ] ) ) { $ timers [ $ label ] = array ( 0 , \ microtime ( true ) ) ; } elseif ( ! isset ( $ timers [ $ label ] [ 1 ] ) ) { $ timers [ $ label ] [ 1 ] = \ microtime ( true ) ; } } else { $ this -> data [ 'timers' ] [ 'stack' ] [ ] = \ microtime ( true ) ; } }
12666	public function edit ( $ sourceDir , array $ options , $ username , $ values ) { $ this -> resolveOptions ( $ options ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ filename = sprintf ( '%s/blocks/%s.json' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ currentBlock = $ options [ "baseBlock" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; $ values = $ this -> parseChildren ( $ values ) ; $ block = JsonTools :: join ( $ currentBlock , $ values ) ; $ encodedBlock = json_encode ( $ block ) ; $ blockClass = BlockFactory :: getBlockClass ( $ block [ "type" ] ) ; $ event = Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITING , new BlockEditingEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; $ blockContent = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ filename , $ blockContent ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITED , new BlockEditedEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been edited on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
955	public function retrieve ( ) { $ path = null ; switch ( $ this -> type ) { case self :: CHARGE_CREDIT : $ path = 'application_credits' ; break ; case self :: CHARGE_ONETIME : $ path = 'application_charges' ; break ; default : $ path = 'recurring_application_charges' ; break ; } return $ this -> shop -> api ( ) -> rest ( 'GET' , "/admin/{$path}/{$this->charge_id}.json" ) -> body -> { substr ( $ path , 0 , - 1 ) } ; }
5807	public function onAfterWrite ( ) { parent :: onAfterWrite ( ) ; $ write = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ write = $ field ; } } $ changed = $ this -> owner -> getChangedFields ( ) ; $ existing = FusionTag :: get ( ) -> filter ( 'Title' , $ this -> owner -> $ write ) -> first ( ) ; if ( is_null ( $ this -> owner -> FusionTagID ) && ! $ existing ) { $ fusion = FusionTag :: create ( ) ; $ fusion -> Title = $ this -> owner -> $ write ; $ fusion -> TagTypes = serialize ( array ( $ class => $ class ) ) ; $ fusion -> write ( ) ; $ this -> owner -> FusionTagID = $ fusion -> ID ; $ this -> owner -> write ( ) ; } else if ( is_null ( $ this -> owner -> FusionTagID ) && $ existing ) { $ types = unserialize ( $ existing -> TagTypes ) ; $ types [ $ class ] = $ class ; $ existing -> TagTypes = serialize ( $ types ) ; $ existing -> write ( ) ; $ this -> owner -> FusionTagID = $ existing -> ID ; $ this -> owner -> write ( ) ; } else if ( isset ( $ changed [ $ write ] ) && ! isset ( $ changed [ 'FusionTagID' ] ) && $ existing && ( $ existing -> ID != $ this -> owner -> FusionTagID ) ) { $ fusion = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ; $ types = unserialize ( $ fusion -> TagTypes ) ; unset ( $ types [ $ this -> owner -> ClassName ] ) ; $ fusion -> TagTypes = ! empty ( $ types ) ? serialize ( $ types ) : null ; $ fusion -> write ( ) ; $ types = unserialize ( $ existing -> TagTypes ) ; $ types [ $ class ] = $ class ; $ existing -> TagTypes = serialize ( $ types ) ; $ existing -> write ( ) ; $ this -> owner -> FusionTagID = $ existing -> ID ; $ this -> owner -> write ( ) ; } else if ( isset ( $ changed [ $ write ] ) && ! isset ( $ changed [ 'FusionTagID' ] ) && ( $ existing = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ) ) { $ existing -> Title = $ changed [ $ write ] [ 'after' ] ; $ existing -> write ( ) ; } }
2293	public static function getThemes ( ) { $ arrReturn = array ( ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrThemes = scan ( $ rootDir . '/system/themes' ) ; foreach ( $ arrThemes as $ strTheme ) { if ( strncmp ( $ strTheme , '.' , 1 ) === 0 || ! is_dir ( $ rootDir . '/system/themes/' . $ strTheme ) ) { continue ; } $ arrReturn [ $ strTheme ] = $ strTheme ; } return $ arrReturn ; }
6660	protected function getControllers ( ) { if ( ! $ this -> controllersCache ) { $ isHidden = $ this -> getControllerMethod ( 'isMethodHidden' ) ; $ methods = $ this -> reflectedController -> getMethods ( \ ReflectionMethod :: IS_PUBLIC ) ; $ controllers = [ ] ; foreach ( $ methods as $ method ) { if ( preg_match ( '/(\w+)Controller$/' , $ method -> getName ( ) , $ parts ) ) { if ( ! $ isHidden ( $ method -> getName ( ) ) ) { $ controllers [ ] = $ this -> camelcaseToHyphenated ( $ parts [ 1 ] ) ; } } } $ this -> controllersCache = $ controllers ; } return $ this -> controllersCache ; }
11604	public function notify ( ) { declare ( ticks = 1 ) ; if ( is_array ( $ this -> _caller ) && ! empty ( $ this -> _caller ) ) { return call_user_func_array ( $ this -> _caller , [ $ this -> _interrupt ] ) ; } else if ( $ this -> _caller instanceof Closure ) { return $ this -> _caller -> call ( $ this , $ this -> _interrupt ) ; } else if ( is_callable ( $ this -> _caller ) ) { $ cl = Closure :: fromCallable ( $ this -> _caller ) ; return $ cl -> call ( $ this , $ this -> _interrupt ) ; } return null ; }
6683	public function sendSuccessResponse ( $ data ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; \ Yii :: $ app -> response -> setStatusCode ( 200 , $ this -> httpStatuses -> getReasonPhrase ( 200 ) ) ; return [ 'status' => 'success' , 'data' => $ data ] ; }
4675	public function addString ( $ content , $ region = "main" , $ sort = 0 ) { $ view = new View ( ) ; $ view -> set ( $ content , [ ] , $ sort , "string" ) ; $ this -> views [ $ region ] [ ] = $ view ; return $ this ; }
241	public function init ( ) { parent :: init ( ) ; if ( $ this -> model === null ) { throw new InvalidConfigException ( 'Please specify the "model" property.' ) ; } if ( $ this -> formatter === null ) { $ this -> formatter = Yii :: $ app -> getFormatter ( ) ; } elseif ( is_array ( $ this -> formatter ) ) { $ this -> formatter = Yii :: createObject ( $ this -> formatter ) ; } if ( ! $ this -> formatter instanceof Formatter ) { throw new InvalidConfigException ( 'The "formatter" property must be either a Format object or a configuration array.' ) ; } $ this -> normalizeAttributes ( ) ; if ( ! isset ( $ this -> options [ 'id' ] ) ) { $ this -> options [ 'id' ] = $ this -> getId ( ) ; } }
7329	private function configurePaymentTermSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Payment \ PaymentTermSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> paymentTermSubjectClassCache ) ) { return ; } if ( ! $ metadata -> hasAssociation ( 'paymentTerm' ) ) { $ metadata -> mapManyToOne ( [ 'fieldName' => 'paymentTerm' , 'targetEntity' => Payment \ PaymentTermInterface :: class , 'joinColumns' => [ [ 'name' => 'payment_term_id' , 'referencedColumnName' => 'id' , 'onDelete' => 'RESTRICT' , 'nullable' => true , ] , ] , ] ) ; } $ this -> paymentTermSubjectClassCache [ ] = $ class ; }
10245	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; if ( isset ( $ xmlElement -> last_type ) ) $ this -> lastType = $ xmlElement -> last_type ; if ( isset ( $ xmlElement -> count ) ) $ this -> count = $ xmlElement -> count ; if ( isset ( $ xmlElement -> count_hard ) ) $ this -> countHard = $ xmlElement -> count_hard ; if ( isset ( $ xmlElement -> count_soft ) ) $ this -> countSoft = $ xmlElement -> count_soft ; }
9791	public function getCalculatedValue ( $ resetLog = true ) { if ( $ this -> dataType == DataType :: TYPE_FORMULA ) { try { $ result = Calculation :: getInstance ( $ this -> getWorksheet ( ) -> getParent ( ) ) -> calculateCellValue ( $ this , $ resetLog ) ; if ( is_array ( $ result ) ) { while ( is_array ( $ result ) ) { $ result = array_pop ( $ result ) ; } } } catch ( Exception $ ex ) { if ( ( $ ex -> getMessage ( ) === 'Unable to access External Workbook' ) && ( $ this -> calculatedValue !== null ) ) { return $ this -> calculatedValue ; } throw new \ PhpOffice \ PhpSpreadsheet \ Calculation \ Exception ( $ this -> getWorksheet ( ) -> getTitle ( ) . '!' . $ this -> getCoordinate ( ) . ' -> ' . $ ex -> getMessage ( ) ) ; } if ( $ result === '#Not Yet Implemented' ) { return $ this -> calculatedValue ; } return $ result ; } elseif ( $ this -> value instanceof RichText ) { return $ this -> value -> getPlainText ( ) ; } return $ this -> value ; }
3303	public function getClient ( ) { if ( empty ( $ this -> client ) || ! ( $ this -> client instanceof HttpClient ) ) { $ this -> client = new HttpClient ( ) ; } return $ this -> client ; }
12248	public function xpathSingle ( $ strXpathQuery ) { $ arrResults = $ this -> xpath ( $ strXpathQuery ) ; if ( $ arrResults === false ) { return null ; } if ( is_array ( $ arrResults ) && count ( $ arrResults ) == 0 ) { return null ; } else { if ( count ( $ arrResults ) > 1 ) { throw new Exception ( 'xpathSingle expects a single element as result, got ' . count ( $ arrResults ) . ' elements instead.' ) ; } else { return current ( $ arrResults ) ; } } }
6728	public function set_total_votes ( $ post_id , $ votes ) { $ votes = json_encode ( $ votes , true ) ; if ( ! add_post_meta ( $ post_id , 'imdbTotalVotes' , $ votes , true ) ) { update_post_meta ( $ post_id , 'imdbTotalVotes' , $ votes ) ; } }
4697	public static function validate ( $ request_data = array ( ) , $ token_name = self :: TOKEN_NAME ) { if ( empty ( $ _SESSION [ $ token_name ] ) ) { static :: generateToken ( $ token_name ) ; return false ; } elseif ( empty ( $ request_data [ $ token_name ] ) ) { return false ; } else { if ( static :: compare ( $ request_data [ $ token_name ] , static :: getToken ( $ token_name ) ) ) { static :: generateToken ( $ token_name ) ; return true ; } else { return false ; } } }
3358	public function resize ( $ width = false , $ height = false ) { if ( ! $ width && ! $ height ) { throw new \ Exception ( 'Please, provide at least $width or $height for resize' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'resize' ] = array ( 'width' => $ width , 'height' => $ height , ) ; return $ result ; }
8373	protected function configure ( ) { $ this -> setName ( 'worker/process' ) -> setHidden ( true ) -> setDescription ( 'Runs a given worker' ) -> setDefinition ( new InputDefinition ( [ new InputOption ( 'config' , 'c' , InputOption :: VALUE_REQUIRED , 'A YAML configuration file' ) , new InputOption ( 'jobId' , null , InputOption :: VALUE_REQUIRED , 'A Job UUID' ) , new InputOption ( 'name' , null , InputOption :: VALUE_REQUIRED , 'The queue name to work with. Defaults to `default`.' ) , ] ) ) ; }
7435	public function scan ( ) { $ files = $ this -> extensionsFile ( $ this -> files ) ; foreach ( $ files as $ file ) { $ content = file_get_contents ( $ file ) ; if ( str_contains ( $ file , '.php' ) && ! str_contains ( $ file , $ this -> exceptionsValid ) && ! $ this -> checkForValidPhp ( $ content ) ) { $ this -> notValid [ ] = $ file ; } if ( str_contains ( $ content , $ this -> signatures ) ) { $ this -> dangerFiles [ ] = $ file ; } } return $ this ; }
4118	public static function getType ( $ name ) { if ( ! isset ( self :: $ _typeObjects [ $ name ] ) ) { if ( ! isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: unknownType ( $ name ) ; } self :: $ _typeObjects [ $ name ] = new self :: $ _typesMap [ $ name ] ( ) ; } return self :: $ _typeObjects [ $ name ] ; }
4256	protected function buildNotInConsole ( ) { if ( ! $ this -> stats [ 'notInConsole' ] ) { return '' ; } $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ lis = array ( ) ; foreach ( $ errors as $ err ) { if ( \ array_intersect_assoc ( array ( 'category' => 'fatal' , 'inConsole' => true , 'isSuppressed' => true , ) , $ err -> getValues ( ) ) ) { continue ; } $ lis [ ] = '<li>' . $ err [ 'typeStr' ] . ': ' . $ err [ 'file' ] . ' (line ' . $ err [ 'line' ] . '): ' . ( $ err [ 'isHtml' ] ? $ err [ 'message' ] : \ htmlspecialchars ( $ err [ 'message' ] ) ) . '</li>' ; } if ( ! $ lis ) { return '' ; } $ count = \ count ( $ lis ) ; $ header = \ sprintf ( '%s %s captured while not collecting debug log' , $ this -> stats [ 'inConsole' ] || isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ? 'Additionally, there' : 'There' , $ count === 1 ? 'was 1 error' : 'were ' . $ count . ' errors' ) ; $ html = '<h3>' . $ header . '</h3>' . '<ul class="list-unstyled indent">' . "\n" . \ implode ( "\n" , $ lis ) . "\n" . '</ul>' ; return $ html ; }
451	protected function prepareInsertSelectSubQuery ( $ columns , $ schema , $ params = [ ] ) { if ( ! is_array ( $ columns -> select ) || empty ( $ columns -> select ) || in_array ( '*' , $ columns -> select ) ) { throw new InvalidArgumentException ( 'Expected select query object with enumerated (named) parameters' ) ; } list ( $ values , $ params ) = $ this -> build ( $ columns , $ params ) ; $ names = [ ] ; $ values = ' ' . $ values ; foreach ( $ columns -> select as $ title => $ field ) { if ( is_string ( $ title ) ) { $ names [ ] = $ schema -> quoteColumnName ( $ title ) ; } elseif ( preg_match ( '/^(.*?)(?i:\s+as\s+|\s+)([\w\-_\.]+)$/' , $ field , $ matches ) ) { $ names [ ] = $ schema -> quoteColumnName ( $ matches [ 2 ] ) ; } else { $ names [ ] = $ schema -> quoteColumnName ( $ field ) ; } } return [ $ names , $ values , $ params ] ; }
5431	protected function onlyParents ( $ interfaces ) { $ parents = array ( ) ; $ blacklist = array ( ) ; foreach ( $ interfaces as $ interface ) { foreach ( $ interfaces as $ possible_parent ) { if ( $ interface -> getName ( ) == $ possible_parent -> getName ( ) ) { continue ; } if ( $ interface -> isSubClassOf ( $ possible_parent ) ) { $ blacklist [ $ possible_parent -> getName ( ) ] = true ; } } if ( ! isset ( $ blacklist [ $ interface -> getName ( ) ] ) ) { $ parents [ ] = $ interface -> getName ( ) ; } } return $ parents ; }
12710	public function make ( $ instance , $ parameters = [ ] ) { return $ this -> resolve ( $ instance , is_array ( $ parameters ) ? $ parameters : array_slice ( func_get_args ( ) , 1 ) ) ; }
4765	protected function validateRegistrationOptin ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_userregistration' ) ; $ registrationOption = ( int ) $ this -> getRequestParameter ( 'option' ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinUserRegistration' ) && ( 3 == $ registrationOption ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
5754	protected function setIndexFilter ( Request $ request , Response $ response , $ args , array $ listViewColumns , AdminListView $ view ) { $ this -> setRequestInput ( $ request , [ $ view -> getSessionFilterFieldKey ( ) ] ) ; if ( ! isset ( $ this -> requestInput [ $ view -> getSessionFilterFieldKey ( ) ] ) ) { throw new \ Exception ( "session filter input must be set" ) ; } $ this -> storeFilterFieldValueInSession ( $ view ) ; if ( null !== $ filterColumnsInfo = $ this -> getFilterColumns ( $ view -> getSessionFilterFieldKey ( ) , $ listViewColumns ) ) { $ this -> storeFilterColumnsInfoInSession ( $ filterColumnsInfo , $ view ) ; } }
979	protected function response ( Request $ request , Closure $ next ) { $ response = $ next ( $ request ) ; if ( Config :: get ( 'shopify-app.esdk_enabled' ) && ( $ request -> ajax ( ) || $ request -> expectsJson ( ) || $ request -> isJson ( ) ) === false ) { if ( ( $ response instanceof BaseResponse ) === false ) { $ response = new Response ( $ response ) ; } $ response -> headers -> set ( 'P3P' , 'CP="Not used"' ) ; $ response -> headers -> remove ( 'X-Frame-Options' ) ; } return $ response ; }
12884	public function getKeyTranslation ( Model $ foreignObject , $ key = null ) { if ( isset ( $ key ) ) { return $ this -> internalGetKeyTranslation ( $ foreignObject , $ key ) ; } foreach ( $ this -> keys as $ keyName => $ keyField ) { if ( ! empty ( $ foreignObject -> { $ keyField } ) ) { $ key = $ this -> generateKey ( $ foreignObject , $ keyName , $ foreignObject -> { $ keyField } ) ; $ result = $ this -> internalGetKeyTranslation ( $ foreignObject , $ key ) ; if ( ! empty ( $ result ) ) { return $ result ; } } } return false ; }
6307	public function success ( $ message , $ title = null , $ options = [ ] ) { return $ this -> add ( 'success' , $ message , $ title , $ options ) ; }
6431	public function getUserProfile ( ) { $ facebook = $ this -> getFacebookObject ( ) ; $ response = $ facebook -> get ( '/me' , $ this -> accesstoken ) ; $ me = $ response -> getGraphUser ( ) ; return array ( 'userid' => $ me -> getId ( ) , 'name' => $ me -> getName ( ) , 'email' => $ me -> getField ( 'email' ) , 'imageurl' => 'https://graph.facebook.com/' . $ me -> getId ( ) . '/picture?type=large' ) ; }
1711	public function setEmptyEndTime ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue === null ) { $ varValue = $ dc -> activeRecord -> startTime ; } return $ varValue ; }
1501	public function matchesTo ( MediaTypeInterface $ mediaType ) : ? Encoding { return collect ( $ this -> stack ) -> first ( function ( Encoding $ encoding ) use ( $ mediaType ) { return $ encoding -> matchesTo ( $ mediaType ) ; } ) ; }
10807	public function select ( ) { $ cols = func_get_args ( ) ; return $ this -> getBuilder ( ) -> setPrevious ( $ this ) -> select ( false ) -> col ( $ cols ) ; }
3434	public function refreshGroups ( ) { if ( $ this -> id === null ) { return [ ] ; } global $ USER ; $ this -> fields [ 'GROUP_ID' ] = $ this -> isCurrent ( ) ? $ USER -> getUserGroupArray ( ) : static :: $ bxObject -> getUserGroup ( $ this -> id ) ; $ this -> groupsAreFetched = true ; return $ this -> fields [ 'GROUP_ID' ] ; }
306	public function getSizeLimit ( ) { $ limit = $ this -> sizeToBytes ( ini_get ( 'upload_max_filesize' ) ) ; $ postLimit = $ this -> sizeToBytes ( ini_get ( 'post_max_size' ) ) ; if ( $ postLimit > 0 && $ postLimit < $ limit ) { Yii :: warning ( 'PHP.ini\'s \'post_max_size\' is less than \'upload_max_filesize\'.' , __METHOD__ ) ; $ limit = $ postLimit ; } if ( $ this -> maxSize !== null && $ limit > 0 && $ this -> maxSize < $ limit ) { $ limit = $ this -> maxSize ; } if ( isset ( $ _POST [ 'MAX_FILE_SIZE' ] ) && $ _POST [ 'MAX_FILE_SIZE' ] > 0 && $ _POST [ 'MAX_FILE_SIZE' ] < $ limit ) { $ limit = ( int ) $ _POST [ 'MAX_FILE_SIZE' ] ; } return $ limit ; }
8569	public function setSKUPrepInstructions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SKUPrepInstructions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9348	public function sameSize ( $ matrix ) { return ( $ this -> size -> cols == $ matrix -> cols && $ this -> size -> rows == $ matrix -> rows ) ; }
10803	public function deletePageHistoricAction ( ) { $ responseData = $ this -> params ( ) -> fromRoute ( 'datas' , $ this -> params ( ) -> fromQuery ( 'datas' , '' ) ) ; $ idPage = $ responseData [ 0 ] [ 'idPage' ] ; $ response = array ( 'idPage' => $ idPage ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_delete_start' , $ this , $ response ) ; $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ melisCoreAuth = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreAuth' ) ; $ userId = ( int ) null ; $ userAuthDatas = $ melisCoreAuth -> getStorage ( ) -> read ( ) ; if ( $ userAuthDatas ) $ userId = $ userAuthDatas -> usr_id ; $ histDatas = array ( 'hist_page_id' => $ idPage , 'hist_action' => 'Delete' , 'hist_date' => date ( 'Y-m-d H:i:s' ) , 'hist_user_id' => $ userId , 'hist_description' => 'tr_melispagehistoric_action_text_Delete' ) ; $ melisPageHistoricTable -> save ( $ histDatas ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_delete_end' , $ this , $ responseData ) ; }
4559	protected function execute ( LifecycleEventArgs $ args , $ action ) { $ this -> tokenStorage = $ this -> container -> get ( 'security.token_storage' ) ; $ this -> configService = $ this -> container -> get ( 'ds_config.service.config' ) ; $ this -> auditService = $ this -> container -> get ( 'ds_audit.service.audit' ) ; $ entity = $ args -> getEntity ( ) ; if ( $ entity instanceof Audit ) { return ; } if ( ! $ entity instanceof Auditable ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( ! $ token ) { return ; } $ user = $ token -> getUser ( ) ; $ edits = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getEntityChangeSet ( $ entity ) ; $ properties = $ this -> auditService -> getProperties ( $ entity ) ; foreach ( array_keys ( $ edits ) as $ key ) { if ( ! in_array ( $ key , $ properties ) ) { unset ( $ edits [ $ key ] ) ; } } $ audit = $ this -> auditService -> createInstance ( ) ; $ audit -> setOwner ( $ this -> configService -> get ( 'ds_audit.audit.owner' ) ) -> setOwnerUuid ( $ this -> configService -> get ( 'ds_audit.audit.owner_uuid' ) ) -> setUserUuid ( $ user -> getUuid ( ) ) -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) -> setAction ( $ action ) -> setData ( [ 'entity' => basename ( str_replace ( '\\' , '/' , get_class ( $ entity ) ) ) , 'entityUuid' => $ entity -> getUuid ( ) , 'edits' => $ edits ] ) ; $ manager = $ this -> auditService -> getManager ( ) ; $ manager -> persist ( $ audit ) ; $ manager -> flush ( ) ; }
11554	public function cancelConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_CANCEL , $ event ) ; try { $ adapter -> cancelConsignment ( $ consignment ) ; foreach ( $ consignment -> getParcels ( ) as $ parcel ) { $ parcel -> setStatus ( ConsignmentStatusList :: STATUS_CANCELED ) ; } $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_CANCELED ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment cancel.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_CANCEL , $ event ) ; }
731	protected function getUniqueIndexInformation ( $ table ) { $ sql = <<<'SQL'SELECT i.relname as indexname, pg_get_indexdef(idx.indexrelid, k + 1, TRUE) AS columnnameFROM ( SELECT *, generate_subscripts(indkey, 1) AS k FROM pg_index) idxINNER JOIN pg_class i ON i.oid = idx.indexrelidINNER JOIN pg_class c ON c.oid = idx.indrelidINNER JOIN pg_namespace ns ON c.relnamespace = ns.oidWHERE idx.indisprimary = FALSE AND idx.indisunique = TRUEAND c.relname = :tableName AND ns.nspname = :schemaNameORDER BY i.relname, kSQL ; return $ this -> db -> createCommand ( $ sql , [ ':schemaName' => $ table -> schemaName , ':tableName' => $ table -> name , ] ) -> queryAll ( ) ; }
8834	private function getObserver ( ) : ProcessObserverInterface { if ( 1 === count ( $ this -> observerList ) ) { $ observer = $ this -> observerList [ 0 ] ; } elseif ( count ( $ this -> observerList ) ) { $ observer = new AggregateLogger ( $ this -> observerList ) ; } else { $ observer = new NullProcessObserver ( ) ; } return $ observer ; }
943	private function computeConfigFiles ( ) { $ configFile = $ this -> options [ 'config' ] ; if ( null !== $ configFile ) { if ( false === file_exists ( $ configFile ) || false === is_readable ( $ configFile ) ) { throw new InvalidConfigurationException ( sprintf ( 'Cannot read config file "%s".' , $ configFile ) ) ; } return [ $ configFile ] ; } $ path = $ this -> getPath ( ) ; if ( $ this -> isStdIn ( ) || 0 === \ count ( $ path ) ) { $ configDir = $ this -> cwd ; } elseif ( 1 < \ count ( $ path ) ) { throw new InvalidConfigurationException ( 'For multiple paths config parameter is required.' ) ; } elseif ( is_file ( $ path [ 0 ] ) && $ dirName = pathinfo ( $ path [ 0 ] , PATHINFO_DIRNAME ) ) { $ configDir = $ dirName ; } else { $ configDir = $ path [ 0 ] ; } $ candidates = [ $ configDir . \ DIRECTORY_SEPARATOR . '.php_cs' , $ configDir . \ DIRECTORY_SEPARATOR . '.php_cs.dist' , ] ; if ( $ configDir !== $ this -> cwd ) { $ candidates [ ] = $ this -> cwd . \ DIRECTORY_SEPARATOR . '.php_cs' ; $ candidates [ ] = $ this -> cwd . \ DIRECTORY_SEPARATOR . '.php_cs.dist' ; } return $ candidates ; }
11618	private function compressPhase2 ( $ calcIdWriteOff , $ calcIdPhase1 , $ calcIdPhase2 , $ scheme ) { $ pv = $ this -> rouGetPv -> exec ( $ calcIdWriteOff ) ; $ dwnlPlain = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdWriteOff ) ; $ dwnlPhase1 = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdPhase1 ) ; $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_CALC_ID_PHASE2 , $ calcIdPhase2 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_SCHEME , $ scheme ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PLAIN , $ dwnlPlain ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PHASE1 , $ dwnlPhase1 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_MAP_PV , $ pv ) ; $ out = $ this -> procCmprsPhase2 -> exec ( $ ctx ) ; $ dwnlPhase2 = $ out -> get ( PCpmrsPhase2 :: OUT_DWNL_PHASE2 ) ; $ legs = $ out -> get ( PCpmrsPhase2 :: OUT_LEGS ) ; $ result = [ $ dwnlPhase2 , $ legs ] ; return $ result ; }
2610	public function determineVersions ( array $ versions ) { $ activeVersion = null ; $ nextVersion = null ; if ( ! empty ( $ versions ) ) { foreach ( $ versions as $ version ) { if ( $ version -> active ) { $ activeVersion = $ version -> number ; } } $ nextVersion = ( int ) end ( $ versions ) -> number + 1 ; } return [ 'active_version' => $ activeVersion , 'next_version' => $ nextVersion ] ; }
12795	public function images ( $ params ) { try { $ response = $ this -> client -> request -> get ( $ this -> apiEndpoint . '/images' . $ this -> paramsToString ( $ params ) ) ; $ status = $ this -> client -> getStatus ( $ response ) ; if ( 200 != $ status ) { throw new Exception ( 'Digital Ocean was not able to successfully provide a list of snapshots.' ) ; } return $ this -> client -> getBody ( $ response ) ; } catch ( Exception $ e ) { echo 'Unable to list snapshots because ' . $ e -> getMessage ( ) ; } }
6934	protected function getOperator ( SaleInterface $ sale ) { if ( $ sale instanceof CartInterface ) { return $ this -> cartOperator ; } elseif ( $ sale instanceof QuoteInterface ) { return $ this -> quoteOperator ; } elseif ( $ sale instanceof OrderInterface ) { return $ this -> orderOperator ; } throw new InvalidArgumentException ( "Unexpected sale type." ) ; }
7741	public function addOperation ( OperationDefinition $ operation ) { if ( false === $ this -> supportsOperation ( $ operation -> getName ( ) ) ) { $ this -> operations [ ] = $ operation ; } return $ this ; }
104	public function isRateLimited ( array $ headers ) { foreach ( $ headers as $ header ) { if ( preg_match ( '{^X-RateLimit-Remaining: *0$}i' , trim ( $ header ) ) ) { return true ; } } return false ; }
7936	public function getSeeOffers ( $ countryDestination , $ countryCurrencyPrice , $ quantity ) { return json_decode ( self :: getClient ( ) -> getSeeOffers ( $ this -> domain , $ countryDestination , $ countryCurrencyPrice , $ quantity ) ) ; }
1659	public static function create ( $ reply = null ) { $ suggestion = new self ( ) ; if ( $ reply ) { $ suggestion -> reply ( $ reply ) ; } return $ suggestion ; }
548	protected function addMemcachedServers ( $ cache , $ servers ) { $ existingServers = [ ] ; if ( $ this -> persistentId !== null ) { foreach ( $ cache -> getServerList ( ) as $ s ) { $ existingServers [ $ s [ 'host' ] . ':' . $ s [ 'port' ] ] = true ; } } foreach ( $ servers as $ server ) { if ( empty ( $ existingServers ) || ! isset ( $ existingServers [ $ server -> host . ':' . $ server -> port ] ) ) { $ cache -> addServer ( $ server -> host , $ server -> port , $ server -> weight ) ; } } }
12653	public function getTextsWithBaseTexts ( $ language ) { $ texts = $ this -> getPageTexts ( $ language ) ; if ( $ language !== $ this -> baseLang ) { $ baseTexts = $ this -> getPageTexts ( $ this -> baseLang ) ; $ texts = array_map ( function ( $ text , $ baseText ) { return $ text + array ( "basecontent" => $ baseText [ 'content' ] ) ; } , $ texts , $ baseTexts ) ; } return $ texts ; }
10853	public function setLimit ( $ num , $ offset = 0 ) { $ this -> limit = ( int ) $ num ; $ this -> offset = ( int ) $ offset ; }
3090	public function process ( ) { $ this -> validate ( ) ; $ itemRef = $ this -> hasRequestParameter ( 'itemDefinition' ) ? $ this -> getItemRef ( $ this -> getRequestParameter ( 'itemDefinition' ) ) : null ; $ traceData = json_decode ( html_entity_decode ( $ this -> getRequestParameter ( 'traceData' ) ) , true ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ stored = 0 ; $ size = count ( $ traceData ) ; foreach ( $ traceData as $ variableIdentifier => $ variableValue ) { if ( $ this -> getRunnerService ( ) -> storeTraceVariable ( $ serviceContext , $ itemRef , $ variableIdentifier , $ variableValue ) ) { $ stored ++ ; } } $ response = [ 'success' => $ stored == $ size ] ; common_Logger :: d ( 'Stored "' . $ stored . '/' . $ size . '" trace variables' ) ; $ eventManager = $ this -> getServiceLocator ( ) -> get ( EventManager :: SERVICE_ID ) ; $ event = new TraceVariableStored ( $ serviceContext -> getTestSession ( ) -> getSessionId ( ) , $ traceData ) ; $ eventManager -> trigger ( $ event ) ; } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
9395	public function buildCommand ( ) { if ( $ this -> escape !== false ) { $ this -> options = $ this -> escape ( $ this -> options ) ; } if ( $ this -> builder !== null ) { $ this -> command = $ this -> builder -> build ( $ this -> options ) ; } return $ this ; }
3907	public function handle ( BuildDataDefinitionEvent $ event ) { $ container = $ event -> getContainer ( ) ; if ( $ container instanceof IMetaModelDataDefinition ) { $ this -> build ( $ container ) ; } }
3967	protected function getMetaModelByModelPid ( ModelInterface $ model ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; if ( $ metaModel === null ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ model -> getProperty ( 'pid' ) ) ; } return $ metaModel ; }
2786	public static function mutates ( array & $ tokens , $ index ) { $ t = $ tokens [ $ index ] ; if ( ! is_array ( $ t ) && $ t == '+' ) { $ tokenCount = count ( $ tokens ) ; for ( $ i = $ index + 1 ; $ i < $ tokenCount ; $ i ++ ) { if ( ! is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == '[' ) { return false ; } if ( is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == T_ARRAY && $ tokens [ $ i ] [ 1 ] == 'array' ) { return false ; } if ( ! is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] == ';' ) { return true ; } } return true ; } return false ; }
8677	public function unique ( ) { $ items = [ ] ; foreach ( $ this -> items as $ item ) { if ( array_search ( $ item , $ items , true ) === false ) { $ items [ ] = $ item ; } } return $ this -> createFrom ( $ items ) ; }
9529	private function validateRequiredParameters ( ) { $ ret = true ; foreach ( $ this -> parameterCluster -> prefixes as $ prefix => $ parameters ) { foreach ( $ parameters as $ parameterClosure ) { if ( $ parameterClosure -> required ) { if ( ! in_array ( $ parameterClosure -> prefix . $ parameterClosure -> parameterName , $ this -> argv ) ) { $ aliasFound = false ; foreach ( $ parameterClosure -> aliases as $ prefix => $ alias ) { if ( in_array ( $ prefix . $ alias , $ this -> argv ) ) { $ aliasFound = true ; break ; } } if ( ! $ aliasFound ) { $ ret = $ parameterClosure ; break 2 ; } } } } } return $ ret ; }
10821	public static function title ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'title' , $ length , $ separator ) ; }
1683	public function getModules ( ) { $ arrModules = array ( ) ; foreach ( $ GLOBALS [ 'BE_MOD' ] as $ k => $ v ) { if ( ! empty ( $ v ) ) { if ( $ k == 'accounts' ) { unset ( $ v [ 'login' ] ) ; } if ( $ k == 'system' ) { unset ( $ v [ 'undo' ] ) ; } $ arrModules [ $ k ] = array_keys ( $ v ) ; } } return $ arrModules ; }
4403	public function loadRelatedLayouts ( Location $ location ) { $ query = $ this -> databaseConnection -> createQueryBuilder ( ) ; $ valueColumnName = class_exists ( 'Netgen\BlockManager\Version' ) && Version :: VERSION_ID < 1100 ? 'value_id' : 'value' ; $ query -> select ( 'DISTINCT b.layout_id' ) -> from ( 'ngbm_collection_item' , 'ci' ) -> innerJoin ( 'ci' , 'ngbm_block_collection' , 'bc' , $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> eq ( 'bc.collection_id' , 'ci.collection_id' ) , $ query -> expr ( ) -> eq ( 'bc.collection_status' , 'ci.status' ) ) ) -> innerJoin ( 'bc' , 'ngbm_block' , 'b' , $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> eq ( 'b.id' , 'bc.block_id' ) , $ query -> expr ( ) -> eq ( 'b.status' , 'bc.block_status' ) ) ) -> where ( $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> orX ( $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> eq ( 'ci.value_type' , ':content_value_type' ) , $ query -> expr ( ) -> eq ( 'ci.' . $ valueColumnName , ':content_id' ) ) , $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> eq ( 'ci.value_type' , ':location_value_type' ) , $ query -> expr ( ) -> eq ( 'ci.' . $ valueColumnName , ':location_id' ) ) ) , $ query -> expr ( ) -> eq ( 'ci.status' , ':status' ) ) ) -> setParameter ( 'status' , Value :: STATUS_PUBLISHED , Type :: INTEGER ) -> setParameter ( 'content_value_type' , 'ezcontent' , Type :: STRING ) -> setParameter ( 'location_value_type' , 'ezlocation' , Type :: STRING ) -> setParameter ( 'content_id' , $ location -> contentInfo -> id , Type :: INTEGER ) -> setParameter ( 'location_id' , $ location -> id , Type :: INTEGER ) ; $ relatedLayouts = array_map ( function ( array $ dataRow ) { return $ this -> layoutService -> loadLayout ( $ dataRow [ 'layout_id' ] ) ; } , $ query -> execute ( ) -> fetchAll ( PDO :: FETCH_ASSOC ) ) ; usort ( $ relatedLayouts , function ( Layout $ layout1 , Layout $ layout2 ) { if ( $ layout1 -> getName ( ) === $ layout2 -> getName ( ) ) { return 0 ; } return $ layout1 -> getName ( ) > $ layout2 -> getName ( ) ? 1 : - 1 ; } ) ; return $ relatedLayouts ; }
6148	public function setBody ( $ body ) { if ( is_string ( $ body ) ) { $ this -> body = $ body ; } elseif ( is_array ( $ body ) ) { $ this -> setJsonBody ( $ body ) ; } elseif ( is_callable ( $ body ) ) { ob_start ( ) ; $ res1 = call_user_func ( $ body ) ; $ res2 = ob_get_contents ( ) ; $ this -> body = $ res2 . $ res1 ; ob_end_clean ( ) ; } return $ this ; }
12509	public function build ( ) { if ( empty ( $ this -> msgType ) ) { throw new RuntimeException ( 'message type not exist.' ) ; } if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message content to send.' ) ; } if ( $ this -> msgType === Broadcast :: MSG_TYPE_VIDEO ) { if ( is_array ( $ this -> message ) ) { $ this -> message = array_shift ( $ this -> message ) ; } $ this -> msgType = 'mpvideo' ; } $ content = ( new Transformer ( $ this -> msgType , $ this -> message ) ) -> transform ( ) ; $ group = isset ( $ this -> to ) ? $ this -> to : null ; $ message = array_merge ( $ this -> buildGroup ( $ group ) , $ content ) ; return $ message ; }
10993	public function getByteSize ( ) : int { if ( $ this -> test ( \ sndsgd \ Fs :: READABLE ) !== true ) { $ this -> error = "failed to stat filesize; {$this->error}" ; return - 1 ; } $ bytes = @ filesize ( $ this -> path ) ; if ( $ bytes === false ) { $ this -> setError ( "failed to stat filesize for '{$this->path}'" ) ; return - 1 ; } return $ bytes ; }
11382	public function pipe ( $ stage ) { $ pipeline = new self ( $ this -> container , $ this -> stages ) ; $ this -> handleStage ( $ pipeline -> stages , $ stage ) ; return $ pipeline ; }
10992	public function splitName ( string $ defaultExtension = "" ) : array { $ filename = basename ( $ this -> path ) ; $ extpos = strrpos ( $ filename , "." ) ; if ( $ extpos === false || $ extpos === 0 ) { $ name = $ filename ; $ ext = $ defaultExtension ; } else { $ name = substr ( $ filename , 0 , $ extpos ) ; $ ext = substr ( $ filename , $ extpos + 1 ) ; } return [ $ name , $ ext ] ; }
2105	protected function generateFaqLink ( $ objFaq ) { $ objCategory = $ objFaq -> getRelated ( 'pid' ) ; $ jumpTo = ( int ) $ objCategory -> jumpTo ; if ( $ jumpTo < 1 ) { throw new \ Exception ( "FAQ categories without redirect page cannot be used in an FAQ list" ) ; } if ( ! isset ( $ this -> arrTargets [ $ jumpTo ] ) ) { $ this -> arrTargets [ $ jumpTo ] = ampersand ( Environment :: get ( 'request' ) , true ) ; if ( $ jumpTo > 0 && ( $ objTarget = PageModel :: findByPk ( $ jumpTo ) ) !== null ) { $ this -> arrTargets [ $ jumpTo ] = ampersand ( $ objTarget -> getFrontendUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ) ; } } return sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ this -> arrTargets [ $ jumpTo ] ) , ( $ objFaq -> alias ? : $ objFaq -> id ) ) ; }
7886	public function levels ( ) { if ( ! $ this -> levels ) { $ class = new ReflectionClass ( new LogLevel ( ) ) ; $ this -> levels = $ class -> getConstants ( ) ; } return $ this -> levels ; }
12291	public function findPost ( $ search ) { $ qb = $ this -> getQueryBuilder ( ) -> select ( 'p, pTrans' ) -> join ( 'p.translations' , 'pTrans' ) ; if ( ! empty ( $ search ) ) { $ qb -> where ( 'pTrans.title LIKE :search' ) -> orWhere ( 'pTrans.description LIKE :search' ) -> setParameter ( 'search' , '%' . $ search . '%' ) ; } $ qb -> orderBy ( 'p.published' , 'DESC' ) ; return $ qb -> getQuery ( ) -> getResult ( ) ; }
8587	public function setLowestOfferListing ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LowestOfferListing' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10092	protected function identifierHash ( $ identifier , $ hash = 'md5' ) { if ( filter_var ( $ identifier , FILTER_VALIDATE_EMAIL ) || $ identifier === null ) { return hash ( $ hash , $ identifier ) ; } return hash ( 'sha256' , $ identifier ) ; }
6016	public function createSite ( DeploymentSite $ deploymentSite ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'deploymentSite' => $ deploymentSite ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
9670	private function writeBorder ( XMLWriter $ objWriter , Borders $ pBorders ) { $ objWriter -> startElement ( 'border' ) ; switch ( $ pBorders -> getDiagonalDirection ( ) ) { case Borders :: DIAGONAL_UP : $ objWriter -> writeAttribute ( 'diagonalUp' , 'true' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'false' ) ; break ; case Borders :: DIAGONAL_DOWN : $ objWriter -> writeAttribute ( 'diagonalUp' , 'false' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'true' ) ; break ; case Borders :: DIAGONAL_BOTH : $ objWriter -> writeAttribute ( 'diagonalUp' , 'true' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'true' ) ; break ; } $ this -> writeBorderPr ( $ objWriter , 'left' , $ pBorders -> getLeft ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'right' , $ pBorders -> getRight ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'top' , $ pBorders -> getTop ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'bottom' , $ pBorders -> getBottom ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'diagonal' , $ pBorders -> getDiagonal ( ) ) ; $ objWriter -> endElement ( ) ; }
7745	private function findGetter ( ) { $ reflClass = new \ ReflectionClass ( $ this -> class ) ; $ camelProp = $ this -> camelize ( $ this -> name ) ; $ getter = 'get' . $ camelProp ; $ isser = 'is' . $ camelProp ; $ hasser = 'has' . $ camelProp ; $ classHasProperty = $ reflClass -> hasProperty ( $ this -> name ) ; if ( $ reflClass -> hasMethod ( $ this -> name ) && $ reflClass -> getMethod ( $ this -> name ) -> isPublic ( ) ) { $ this -> getter = $ this -> name ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( $ reflClass -> hasMethod ( $ getter ) && $ reflClass -> getMethod ( $ getter ) -> isPublic ( ) ) { $ this -> getter = $ getter ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( $ reflClass -> hasMethod ( $ isser ) && $ reflClass -> getMethod ( $ isser ) -> isPublic ( ) ) { $ this -> getter = $ isser ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( $ reflClass -> hasMethod ( $ hasser ) && $ reflClass -> getMethod ( $ hasser ) -> isPublic ( ) ) { $ this -> getter = $ hasser ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( ( $ reflClass -> hasMethod ( '__get' ) && $ reflClass -> getMethod ( '__get' ) -> isPublic ( ) ) || ( $ classHasProperty && $ reflClass -> getProperty ( $ this -> name ) -> isPublic ( ) ) ) { $ this -> getter = $ this -> name ; $ this -> getterType = self :: GETTER_SETTER_PROPERTY ; } }
11321	function getRow ( $ sql , $ params = array ( ) ) { $ data = $ this -> query ( $ sql , $ params ) ; $ row = false ; if ( count ( $ data ) > 0 ) { $ row = $ data [ 0 ] ; } return $ row ; }
10834	public function using ( $ column ) { if ( $ this -> active_join === null ) { throw new \ Peyote \ Exception ( "You need to start a join before calling \Peyote\Join::using()" ) ; } list ( $ table , $ type ) = $ this -> active_join ; $ this -> active_join = null ; $ this -> joins [ ] = array ( "USING" , $ table , $ type , $ column ) ; return $ this ; }
3174	private function getTimeConstraint ( TestSession $ session , QtiComponent $ source , $ navigationMode ) { $ constraint = new QtiTimeConstraint ( $ source , $ session -> getTimerDuration ( $ source -> getIdentifier ( ) ) , $ navigationMode , true , true , $ session -> getTimerTarget ( ) ) ; $ constraint -> setTimer ( $ session -> getTimer ( ) ) ; return $ constraint ; }
5043	public function addMessage ( $ message , $ namespace = self :: NAMESPACE_INFO ) { if ( ! $ message instanceof NotificationEntityInterface ) { $ messageText = $ this -> isTranslatorEnabled ( ) ? $ this -> getTranslator ( ) -> translate ( $ message , $ this -> getTranslatorTextDomain ( ) ) : $ message ; $ message = new NotificationEntity ( ) ; $ message -> setNotification ( $ messageText ) ; $ message -> setPriority ( $ this -> namespace2priority [ $ namespace ] ) ; } $ nEvent = new NotificationEvent ( ) ; $ nEvent -> setNotification ( $ message ) ; $ this -> notificationListener -> trigger ( NotificationEvent :: EVENT_NOTIFICATION_ADD , $ nEvent ) ; return $ this ; }
9636	public function write ( $ path , $ contents , $ blocking = false ) { $ flockFlags = $ blocking ? LOCK_EX : LOCK_EX | LOCK_NB ; $ file = fopen ( $ path , 'c' ) ; if ( ! flock ( $ file , $ flockFlags ) ) { fclose ( $ file ) ; throw new IOException ( "Could not aquire file lock for file: $path" ) ; } ftruncate ( $ file , 0 ) ; fwrite ( $ file , $ contents ) ; fflush ( $ file ) ; flock ( $ file , LOCK_UN | LOCK_NB ) ; fclose ( $ file ) ; }
5572	public function authenticate ( $ username , $ password ) { if ( ! $ this -> page -> getRealm ( ) ) { return false ; } $ url = $ this -> page -> getUrl ( ) ; if ( ! $ url ) { return false ; } $ this -> user_agent -> setIdentity ( $ url -> getHost ( ) , $ this -> page -> getRealm ( ) , $ username , $ password ) ; return $ this -> retry ( ) ; }
134	public function isPackageInstalled ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( $ package instanceof AliasPackage ) { return $ repo -> hasPackage ( $ package ) && $ this -> isPackageInstalled ( $ repo , $ package -> getAliasOf ( ) ) ; } return $ this -> getInstaller ( $ package -> getType ( ) ) -> isInstalled ( $ repo , $ package ) ; }
6070	public function downloadArchive ( array $ ids , $ template = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'ids' => $ ids , 'template' => $ template ] , 'body' => json_encode ( [ ] ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/download' , $ parameters , $ cachePolicy ) ; return $ result ; }
7957	public function getProperties ( ) { $ this -> properties = json_decode ( self :: getClient ( ) -> getProperties ( $ this -> id ) ) ; return $ this -> properties ; }
2444	public static function decrypt ( $ varValue , $ strKey = null ) { if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: decrypt ( $ v ) ; } return $ varValue ; } elseif ( $ varValue == '' ) { return '' ; } if ( static :: $ resTd === null ) { static :: initialize ( ) ; } $ varValue = base64_decode ( $ varValue ) ; $ ivsize = mcrypt_enc_get_iv_size ( static :: $ resTd ) ; $ iv = substr ( $ varValue , 0 , $ ivsize ) ; $ varValue = substr ( $ varValue , $ ivsize ) ; if ( $ varValue == '' ) { return '' ; } if ( ! $ strKey ) { $ strKey = System :: getContainer ( ) -> getParameter ( 'contao.encryption_key' ) ; } mcrypt_generic_init ( static :: $ resTd , md5 ( $ strKey ) , $ iv ) ; $ strDecrypted = mdecrypt_generic ( static :: $ resTd , $ varValue ) ; mcrypt_generic_deinit ( static :: $ resTd ) ; return $ strDecrypted ; }
3757	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values , [ 'allowed_classes' => false ] ) ) ; }
990	public static function validate ( Schema $ schema , DocumentNode $ ast , ? array $ rules = null , ? TypeInfo $ typeInfo = null ) { if ( $ rules === null ) { $ rules = static :: allRules ( ) ; } if ( is_array ( $ rules ) === true && count ( $ rules ) === 0 ) { return [ ] ; } $ typeInfo = $ typeInfo ? : new TypeInfo ( $ schema ) ; return static :: visitUsingRules ( $ schema , $ typeInfo , $ ast , $ rules ) ; }
8066	protected function collectWorkerResults ( $ sec = 0 ) { $ this -> respawnIfRequired ( ) ; pcntl_signal_dispatch ( ) ; if ( isset ( $ this -> workerProcesses ) === FALSE ) { throw new WorkerPoolException ( 'There is no list of worker processes. Maybe you destroyed the worker pool?' , 1401179881 ) ; } $ result = SimpleSocket :: select ( $ this -> workerProcesses -> getSockets ( ) , array ( ) , array ( ) , $ sec ) ; foreach ( $ result [ 'read' ] as $ socket ) { $ processId = $ socket -> annotation [ 'pid' ] ; $ result = $ socket -> receive ( ) ; $ possibleArrayKeys = array ( 'data' , 'poolException' , 'workerException' ) ; if ( is_array ( $ result ) && count ( ( $ resultTypes = array_intersect ( array_keys ( $ result ) , $ possibleArrayKeys ) ) ) === 1 ) { $ this -> workerProcesses -> registerFreeProcessId ( $ processId ) ; $ result [ 'pid' ] = $ processId ; $ resultType = reset ( $ resultTypes ) ; if ( $ resultType !== 'data' || $ result [ 'data' ] !== NULL ) { array_push ( $ this -> results , $ result ) ; } } } pcntl_signal_dispatch ( ) ; $ this -> respawnIfRequired ( ) ; }
519	private function findMigrationPath ( $ namespace ) { if ( empty ( $ namespace ) ) { return is_array ( $ this -> migrationPath ) ? reset ( $ this -> migrationPath ) : $ this -> migrationPath ; } if ( ! in_array ( $ namespace , $ this -> migrationNamespaces , true ) ) { throw new Exception ( "Namespace '{$namespace}' not found in `migrationNamespaces`" ) ; } return $ this -> getNamespacePath ( $ namespace ) ; }
6385	public function readCourse ( $ id ) { if ( $ id == 0 ) { $ courses = $ this -> store -> get_records ( 'course' , array ( ) ) ; $ id = key ( $ courses ) ; } $ model = $ this -> readObject ( $ id , 'course' ) ; $ model -> url = $ this -> cfg -> wwwroot . ( $ id > 0 ? '/course/view.php?id=' . $ id : '' ) ; return $ model ; }
2646	public function cloneVersion ( $ curVersion ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ curVersion . '/clone' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to clone active version.' ) ) ; } return $ result ; }
9852	public function setPath ( $ pValue , $ pVerifyFile = true ) { if ( $ pVerifyFile ) { if ( file_exists ( $ pValue ) ) { $ this -> path = $ pValue ; if ( $ this -> width == 0 && $ this -> height == 0 ) { list ( $ this -> width , $ this -> height ) = getimagesize ( $ pValue ) ; } } else { throw new PhpSpreadsheetException ( "File $pValue not found!" ) ; } } else { $ this -> path = $ pValue ; } return $ this ; }
3661	private function addParameters ( $ parameters ) { if ( empty ( $ parameters ) ) { return ; } $ this -> queryParameter = array_merge ( $ this -> queryParameter , $ parameters ) ; }
11711	public function actionBlock ( $ id , $ back = 'index' ) { if ( $ id == \ Yii :: $ app -> user -> getId ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'You can not block your own account' ) ) ; } else { $ user = $ this -> findModel ( $ id ) ; if ( $ user -> getIsBlocked ( ) ) { $ user -> unblock ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been unblocked' ) ) ; } else { $ user -> block ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been blocked' ) ) ; } } $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
3864	private function setTitleAndDescription ( ) { $ page = $ this -> getPage ( ) ; if ( $ page && $ this -> objItems -> getCount ( ) ) { if ( ! empty ( $ this -> strTitleAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrTitle = $ objCurrentItem -> parseAttribute ( $ this -> strTitleAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrTitle [ 'text' ] ) ) { $ page -> pageTitle = strip_tags ( $ arrTitle [ 'text' ] ) ; break ; } } $ this -> objItems -> reset ( ) ; } if ( ! empty ( $ this -> strDescriptionAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrDescription = $ objCurrentItem -> parseAttribute ( $ this -> strDescriptionAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrDescription [ 'text' ] ) ) { $ page -> description = StringUtil :: substr ( $ arrDescription [ 'text' ] , 160 ) ; break ; } } $ this -> objItems -> reset ( ) ; } } }
11472	public function update ( ResponseRequest $ request , Response $ response ) { try { $ attributes = $ request -> all ( ) ; $ id = $ attributes [ 'question_id' ] ; $ question = $ this -> question -> selectquestion ( $ id ) ; $ response -> update ( $ attributes ) ; return redirect ( '/discussion/' . $ question [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/response/' . $ response -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
10584	public static function createDir ( string $ prefix = "tmp" , int $ mode = 0777 , int $ maxAttempts = 10 ) : entity \ DirEntity { $ tmpdir = static :: getDir ( ) ; $ prefix = \ sndsgd \ Fs :: sanitizeName ( $ prefix ) ; $ attempts = 0 ; do { $ attempts ++ ; if ( $ attempts > $ maxAttempts ) { throw new \ RuntimeException ( "failed to create temp directory; " . "reached max number ($maxAttempts) of attempts" ) ; } $ rand = \ sndsgd \ Str :: random ( 10 ) ; $ path = "$tmpdir/$prefix-$rand" ; } while ( @ mkdir ( $ path , $ mode ) === false ) ; $ dir = new entity \ DirEntity ( $ path ) ; static :: registerEntity ( $ dir ) ; return $ dir ; }
6383	public function readFeedbackAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'feedback_completed' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/feedback/complete.php?id=' . $ id ; $ model -> name = 'Attempt ' . $ id ; $ model -> responses = $ this -> readStoreRecords ( 'feedback_value' , [ 'completed' => $ id ] ) ; return $ model ; }
8796	public function helper ( $ name , $ directory = 'Helpers' ) { $ file = app_path ( $ directory . DIRECTORY_SEPARATOR . $ name . '.php' ) ; if ( file_exists ( $ file ) ) { return require $ file ; } throw new ExceptionHandler ( 'Oppss! File not found.' , 'Helper::' . $ name . ' not found.' ) ; }
9106	public function getPreparedThemeObject ( ) { $ name = $ this -> attainThemeName ( ) ; $ path = $ this -> attainPathName ( ) ; $ return = false ; if ( $ name && $ path ) { $ return = $ this -> getThemeObject ( ) ; $ return -> setName ( $ name ) ; $ return -> setThemesPath ( $ path ) ; } return $ return ; }
8693	public static function createSymlink ( $ symlinkTarget , $ symlinkName ) { if ( false === @ symlink ( $ symlinkTarget , $ symlinkName ) ) { throw new \ UnexpectedValueException ( "An error occurred while creating symlink '{$symlinkName}'" ) ; } if ( false === $ target = readlink ( $ symlinkName ) ) { throw new \ UnexpectedValueException ( "Symlink {$symlinkName} points to target {$target}" ) ; } }
12774	public function __authorize ( $ hashEmail = null , $ hashPassword = null ) { $ asyncResult = $ this -> __async_authorize ( $ hashEmail , $ hashPassword ) ; if ( $ asyncResult ) { } }
952	public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } $ planCharge = $ this -> shop -> planCharge ( ) ; $ charge = new Charge ( ) ; $ charge -> type = Charge :: CHARGE_USAGE ; $ charge -> reference_charge = $ planCharge -> charge_id ; $ charge -> shop_id = $ this -> shop -> id ; $ charge -> charge_id = $ this -> response -> id ; $ charge -> price = $ this -> response -> price ; $ charge -> description = $ this -> response -> description ; $ charge -> billing_on = $ this -> response -> billing_on ; return $ charge -> save ( ) ; }
8451	public function setProfilePhoto ( $ mediaUri ) { $ processedMedia = $ this -> processMediaUri ( $ mediaUri ) ; if ( ! $ processedMedia ) { return false ; } $ result = $ this -> exec ( 'set_profile_photo ' . $ processedMedia [ 'filepath' ] ) ; $ this -> cleanUpMedia ( $ processedMedia ) ; return $ result ; }
658	public function cache ( callable $ callable , $ duration = null , $ dependency = null ) { $ this -> _queryCacheInfo [ ] = [ $ duration === null ? $ this -> queryCacheDuration : $ duration , $ dependency ] ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
3977	private function addEditMultipleCommand ( Contao2BackendViewDefinitionInterface $ view ) { $ definition = $ this -> container -> getBasicDefinition ( ) ; if ( ! $ definition -> isEditable ( ) && ! $ definition -> isDeletable ( ) && ! $ definition -> isCreatable ( ) ) { return ; } $ commands = $ view -> getGlobalCommands ( ) ; $ command = new SelectCommand ( ) ; $ command -> setName ( 'all' ) -> setLabel ( 'MSC.all.0' ) -> setDescription ( 'MSC.all.1' ) ; $ parameters = $ command -> getParameters ( ) ; $ parameters [ 'act' ] = 'select' ; $ extra = $ command -> getExtra ( ) ; $ extra [ 'class' ] = 'header_edit_all' ; $ commands -> addCommand ( $ command ) ; }
2403	public function trans ( $ strId , array $ arrParams = array ( ) , $ strDomain = 'contao_default' ) { return System :: getContainer ( ) -> get ( 'translator' ) -> trans ( $ strId , $ arrParams , $ strDomain ) ; }
5954	public function channelCreate ( array $ properties ) { $ cid = $ this -> execute ( "channelcreate" , $ properties ) -> toList ( ) ; $ this -> channelListReset ( ) ; if ( ! isset ( $ properties [ "client_flag_permanent" ] ) && ! isset ( $ properties [ "client_flag_semi_permanent" ] ) ) { $ this -> getParent ( ) -> whoamiSet ( "client_channel_id" , $ cid [ "cid" ] ) ; } return $ cid [ "cid" ] ; }
12562	public function sendText ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_TEXT , $ message , $ to ) ; }
1453	protected function excluded ( string ... $ keys ) : Collection { return collect ( $ keys ) -> mapWithKeys ( function ( $ key ) { return [ $ key => new DisallowedParameter ( $ key ) ] ; } ) ; }
10550	public function dispatch ( ) { $ response = null ; try { $ this -> resolveApp ( ) ; $ this -> getTemplate ( ) ; $ this -> request -> startSession ( $ this -> vhost -> getHost ( ) , $ this -> config ) ; FlashMessage :: setStorage ( $ this -> request -> session ) ; $ this -> setupLocale ( ) ; if ( $ this -> route === null ) throw new HTTPError ( 404 , 'Could not resolve ' . $ this -> url ) ; $ app = new AppRunner ( $ this -> app , $ this -> arguments ) ; $ app -> setVariables ( $ this -> variables ) ; $ app -> setVariable ( 'dispatcher' , $ this ) ; $ app -> execute ( ) ; } catch ( Throwable $ e ) { if ( ! ( $ e instanceof Response ) ) $ e = new HTTPError ( 500 , "Exception of type " . get_class ( $ e ) . " thrown: " . $ e -> getMessage ( ) , null , $ e ) ; if ( $ e instanceof HTTPError ) $ this -> prepareErrorResponse ( $ e ) ; $ response = $ e ; } return $ response ; }
695	public function beforeSend ( $ message ) { $ event = new MailEvent ( [ 'message' => $ message ] ) ; $ this -> trigger ( self :: EVENT_BEFORE_SEND , $ event ) ; return $ event -> isValid ; }
11660	public static function readFromString ( $ string ) { $ xml = new \ DOMDocument ( ) ; $ xml -> loadXML ( $ string ) ; $ result = [ ] ; $ props = $ xml -> childNodes -> item ( $ xml -> childNodes -> length - 1 ) -> childNodes ; for ( $ i = 0 ; $ i < $ props -> length ; $ i ++ ) { $ entry = $ props -> item ( $ i ) ; if ( $ entry -> nodeName == "entry" ) $ result [ $ entry -> attributes -> getNamedItem ( "key" ) -> nodeValue ] = $ entry -> textContent ; } return $ result ; }
5537	public function setFrame ( $ path , $ page ) { $ name = array_shift ( $ path ) ; if ( isset ( $ this -> names [ $ name ] ) ) { $ index = $ this -> names [ $ name ] ; } else { $ index = $ name - 1 ; } if ( count ( $ path ) === 0 ) { $ this -> frames [ $ index ] = $ page ; return ; } $ this -> frames [ $ index ] -> setFrame ( $ path , $ page ) ; }
12174	public function addScalarArgument ( $ name , $ type , $ required = true , $ default = null ) { return $ this -> addArgument ( new ScalarArgument ( $ this -> argumentPosition ++ , $ name , $ type , $ required , $ default ) ) ; }
8028	public function registerFreeProcess ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; if ( $ this -> hasProcess ( $ pid ) === FALSE ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not register free process. Process (%d) not in list.' , $ processDetails -> getPid ( ) ) , 1400761296 ) ; } $ this -> freeProcessIds [ $ pid ] = $ pid ; return $ this ; }
10592	public function display ( $ level = 0 ) { $ value = $ this -> getContent ( ) ; if ( null === $ value ) { $ value = 'null' ; } elseif ( is_object ( $ value ) ) { $ value = get_class ( $ value ) ; } elseif ( is_array ( $ value ) ) { $ value = 'Array' ; } $ ret = str_repeat ( ' ' , $ level * 4 ) . $ value . "\n" ; $ children = $ this -> getChildren ( ) ; foreach ( $ children as $ child ) { $ ret .= $ child -> display ( $ level + 1 ) ; } return $ ret ; }
6565	public static function register ( $ prepend = true , $ callback = null , $ app = null ) { if ( ! static :: $ registered ) { static :: $ registered = spl_autoload_register ( array ( '\\Sbp\\Laravel\\ClassLoader' , 'load' ) , true , $ prepend ) ; if ( is_null ( $ app ) ) { $ app = __DIR__ . '/../../../../../../app' ; } if ( ! file_exists ( $ app . '/storage' ) || ! is_writable ( $ app . '/storage' ) ) { throw new SbpException ( "Laravel app and/or writable storage directory not found at $app, please specify the path with the following code:\nSbp\\Laravel\\ClassLoader::register(true, 'sha1', \$laravelAppPath)" ) ; } Sbp :: writeIn ( Sbp :: SAME_DIR ) ; Sbp :: fileExists ( $ app . '/routes' ) ; $ storage = $ app . '/storage/sbp' ; if ( ! file_exists ( $ storage ) ) { if ( mkdir ( $ storage , 0777 ) ) { file_put_contents ( $ storage . '/.gitignore' , "*\n!.gitignore" ) ; } } Sbp :: writeIn ( $ storage , $ callback ) ; } }
6932	private function isShipmentAmountInvoiced ( Invoice \ InvoiceInterface $ invoice ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getInvoices ( ) as $ i ) { if ( $ i === $ invoice ) { continue ; } if ( $ i -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_SHIPMENT ) ) { return true ; } } return false ; }
2812	public function getObservers ( ) { if ( $ this -> observers === null ) { $ this -> observers = array ( ) ; foreach ( $ this -> getTimers ( ) as $ timerName => $ timer ) { if ( strpos ( $ timerName , 'OBSERVER' ) === 0 ) { $ this -> observers [ ] = array ( 'name' => $ timerName , 'count' => $ timer [ 'count' ] , 'sum' => round ( $ timer [ 'sum' ] * 1000 , 2 ) , 'mem_diff' => $ timer [ 'realmem' ] / pow ( 1024 , 2 ) , ) ; } } } return $ this -> observers ; }
2699	private function upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) { foreach ( $ oldConfigPaths as $ key => $ value ) { $ oldValue = $ this -> scopeConfig -> getValue ( $ value ) ; if ( $ oldValue != null ) { $ this -> configWriter -> save ( $ newConfigPaths [ $ key ] , $ oldValue ) ; } } }
10762	public function setAlternativeAccount ( $ iban1 , $ swift1 = null , $ iban2 = null , $ swift2 = null ) { if ( $ swift1 !== null ) { $ iban1 .= '+' . $ swift1 ; } if ( $ iban2 !== null ) { if ( $ swift2 !== null ) { $ iban2 .= '+' . $ swift2 ; } $ iban1 .= ',' . $ iban2 ; } return $ this -> add ( 'ALT-ACC' , $ iban1 ) ; }
3782	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ image = '<img src="' . $ this -> attributeFactory -> getIconForType ( $ type ) . '" />' ; $ metaModel = $ this -> getMetaModelByModelPid ( $ model ) ; $ attribute = $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ metaModel ) ; if ( ! $ attribute ) { $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> <strong>%s</strong><br /> </div>' ) -> setArgs ( array ( $ translator -> translate ( 'error_unknown_attribute.0' , 'tl_metamodel_attribute' ) , $ type , $ translator -> translate ( 'error_unknown_attribute.1' , 'tl_metamodel_attribute' , array ( $ type ) ) , ) ) ; return ; } $ colName = $ attribute -> getColName ( ) ; $ name = $ attribute -> getName ( ) ; $ arrDescription = StringUtil :: deserialize ( $ attribute -> get ( 'description' ) ) ; if ( is_array ( $ arrDescription ) ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getActiveLanguage ( ) ] ; if ( ! $ description ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; } } else { $ description = $ arrDescription ? : $ attribute -> getName ( ) ; } $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong> - %s </div>' ) -> setArgs ( array ( $ colName , $ type , $ image , $ name , $ description ) ) ; }
10652	protected function _unsetMany ( $ keys ) { $ keys = $ this -> _normalizeIterable ( $ keys ) ; $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerUnsetMany ( $ store , $ keys ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } }
8704	public function apply ( EloquentBuilder $ builder , Eloquent $ model ) { $ this -> table = $ model -> getTable ( ) ; $ this -> locale = $ model -> getLocale ( ) ; $ this -> i18nTable = $ model -> getI18nTable ( ) ; $ this -> fallback = $ model -> getFallbackLocale ( ) ; if ( ! starts_with ( $ this -> table , 'laravel_reserved_' ) ) { $ this -> createJoin ( $ builder , $ model ) ; $ this -> createWhere ( $ builder , $ model ) ; $ this -> createSelect ( $ builder , $ model ) ; } }
9905	private function updateSingleCellReference ( $ pCellReference = 'A1' , $ pBefore = 'A1' , $ pNumCols = 0 , $ pNumRows = 0 ) { if ( Coordinate :: coordinateIsRange ( $ pCellReference ) ) { throw new Exception ( 'Only single cell references may be passed to this method.' ) ; } list ( $ beforeColumn , $ beforeRow ) = Coordinate :: coordinateFromString ( $ pBefore ) ; list ( $ newColumn , $ newRow ) = Coordinate :: coordinateFromString ( $ pCellReference ) ; $ updateColumn = ( ( $ newColumn [ 0 ] != '$' ) && ( $ beforeColumn [ 0 ] != '$' ) && ( Coordinate :: columnIndexFromString ( $ newColumn ) >= Coordinate :: columnIndexFromString ( $ beforeColumn ) ) ) ; $ updateRow = ( ( $ newRow [ 0 ] != '$' ) && ( $ beforeRow [ 0 ] != '$' ) && $ newRow >= $ beforeRow ) ; if ( $ updateColumn ) { $ newColumn = Coordinate :: stringFromColumnIndex ( Coordinate :: columnIndexFromString ( $ newColumn ) + $ pNumCols ) ; } if ( $ updateRow ) { $ newRow = $ newRow + $ pNumRows ; } return $ newColumn . $ newRow ; }
1647	public function calculateBearing ( Coordinate $ point1 , Coordinate $ point2 ) : float { $ lat1 = deg2rad ( $ point1 -> getLat ( ) ) ; $ lat2 = deg2rad ( $ point2 -> getLat ( ) ) ; $ lng1 = deg2rad ( $ point1 -> getLng ( ) ) ; $ lng2 = deg2rad ( $ point2 -> getLng ( ) ) ; $ y = sin ( $ lng2 - $ lng1 ) * cos ( $ lat2 ) ; $ x = cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lng2 - $ lng1 ) ; $ bearing = rad2deg ( atan2 ( $ y , $ x ) ) ; if ( $ bearing < 0 ) { $ bearing = fmod ( $ bearing + 360 , 360 ) ; } return $ bearing ; }
4277	public function stream_open ( $ path , $ mode , $ options , & $ openedPath ) { if ( $ this -> handle ) { return false ; } $ useIncludePath = ( bool ) $ options & STREAM_USE_PATH ; $ context = $ this -> context ; if ( $ context === null ) { $ context = \ stream_context_get_default ( ) ; } self :: restorePrev ( ) ; if ( \ strpos ( $ mode , 'r' ) !== false && ! \ file_exists ( $ path ) ) { return false ; } elseif ( \ strpos ( $ mode , 'x' ) !== false && \ file_exists ( $ path ) ) { return false ; } $ handle = \ fopen ( $ path , $ mode , $ useIncludePath , $ context ) ; self :: register ( ) ; if ( $ handle === false ) { return false ; } $ meta = \ stream_get_meta_data ( $ handle ) ; if ( ! isset ( $ meta [ 'uri' ] ) ) { throw new \ UnexpectedValueException ( 'Uri not in meta data' ) ; } $ this -> filepath = $ openedPath = $ meta [ 'uri' ] ; $ this -> handle = $ handle ; return true ; }
2552	private function getStringBetween ( $ string , $ start , $ end ) { $ startPos = strpos ( $ string , $ start ) + strlen ( $ start ) ; $ endPos = strlen ( $ string ) - strpos ( $ string , $ end ) ; return substr ( $ string , $ startPos , - $ endPos ) ; }
4371	public function markupClassname ( $ str , $ tagName = 'span' , $ attribs = array ( ) ) { if ( \ preg_match ( '/^(.+)(::|->)(.+)$/' , $ str , $ matches ) ) { $ classname = $ matches [ 1 ] ; $ opMethod = '<span class="t_operator">' . \ htmlspecialchars ( $ matches [ 2 ] ) . '</span>' . '<span class="method-name">' . $ matches [ 3 ] . '</span>' ; } else { $ classname = $ str ; $ opMethod = '' ; } $ idx = \ strrpos ( $ classname , '\\' ) ; if ( $ idx ) { $ classname = '<span class="namespace">' . \ substr ( $ classname , 0 , $ idx + 1 ) . '</span>' . \ substr ( $ classname , $ idx + 1 ) ; } $ attribs = \ array_merge ( array ( 'class' => 't_classname' , ) , $ attribs ) ; return $ this -> debug -> utilities -> buildTag ( $ tagName , $ attribs , $ classname ) . $ opMethod ; }
1311	public function checkSignature ( Request $ request , Consumer $ consumer , Token $ token , $ signature ) { $ built = $ this -> buildSignature ( $ request , $ consumer , $ token ) ; if ( strlen ( $ built ) == 0 || strlen ( $ signature ) == 0 ) { return false ; } if ( strlen ( $ built ) != strlen ( $ signature ) ) { return false ; } $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ signature ) ; $ i ++ ) { $ result |= ord ( $ built { $ i } ) ^ ord ( $ signature { $ i } ) ; } return $ result == 0 ; }
10824	public static function confirm ( $ question , $ allowShort , $ defaultValue = false ) { $ value = $ defaultValue ? 'yes' : 'no' ; $ value = self :: ask ( $ question . ' (yes/no)' , $ value ) ; return $ value == 'yes' || ( $ value == 'y' && $ allowShort ) ; }
112	private function collectDependencies ( Pool $ pool , array $ collected , PackageInterface $ package ) { $ requires = array_merge ( $ package -> getRequires ( ) , $ package -> getDevRequires ( ) ) ; foreach ( $ requires as $ requireLink ) { $ requiredPackage = $ this -> lookupInstalledPackage ( $ pool , $ requireLink ) ; if ( $ requiredPackage && ! isset ( $ collected [ $ requiredPackage -> getName ( ) ] ) ) { $ collected [ $ requiredPackage -> getName ( ) ] = $ requiredPackage ; $ collected = $ this -> collectDependencies ( $ pool , $ collected , $ requiredPackage ) ; } } return $ collected ; }
12071	private function getCfgParamsByRanks ( ) { $ asParams = 'pbhcp' ; $ asRank = 'pbhr' ; $ tblParams = $ this -> resource -> getTableName ( CfgParam :: ENTITY_NAME ) ; $ tblRank = $ this -> resource -> getTableName ( Rank :: ENTITY_NAME ) ; $ query = $ this -> conn -> select ( ) ; $ query -> from ( [ $ asParams => $ tblParams ] ) ; $ on = "$asParams." . CfgParam :: A_RANK_ID . "=$asRank." . Rank :: A_ID ; $ cols = [ Rank :: A_CODE ] ; $ query -> joinLeft ( [ $ asRank => $ tblRank ] , $ on , $ cols ) ; $ entries = $ this -> conn -> fetchAll ( $ query ) ; $ result = [ ] ; foreach ( $ entries as $ entry ) { $ rankCode = $ entry [ Rank :: A_CODE ] ; $ rankScheme = $ entry [ CfgParam :: A_SCHEME ] ; $ result [ $ rankCode ] [ $ rankScheme ] = $ entry ; } return $ result ; }
12257	public function getProjectSearchPaths ( string $ name ) : array { $ srcPaths = $ this -> getProject ( ) -> getAttribute ( AttributeInterface :: SEARCH_PATHS_ATTR_NAME ) ; if ( $ srcPaths instanceof SearchPathCollection ) { return $ srcPaths -> getSearchPaths ( $ name ) ?? [ ] ; } return [ ] ; }
7444	public function createAction ( ) { $ group = new Group ( ) ; $ form = $ this -> createForm ( GroupType :: class , $ group ) ; $ form -> bindRequest ( $ this -> getRequest ( ) ) ; if ( $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ em -> persist ( $ group ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The group has been created.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_group_show' , array ( 'id' => $ group -> getId ( ) ) ) ) ; } return array ( 'group' => $ group , 'form' => $ form -> createView ( ) ) ; }
6601	protected function buildUrl ( $ url , $ params = [ ] ) { if ( $ this -> useOauth ) { $ params [ 'access_token' ] = $ this -> getAccessToken ( ) ; } $ params = http_build_query ( $ params ) ; return $ this -> baseUrl . $ url . '?' . $ params ; }
7662	function CreateBody ( ) { $ result = "" ; $ this -> SetWordWrap ( ) ; switch ( $ this -> message_type ) { case "alt" : $ result .= $ this -> GetBoundary ( $ this -> boundary [ 1 ] , "" , "text/plain" , "" ) ; $ result .= $ this -> EncodeString ( $ this -> AltBody , $ this -> Encoding ) ; $ result .= $ this -> LE . $ this -> LE ; $ result .= $ this -> GetBoundary ( $ this -> boundary [ 1 ] , "" , "text/html" , "" ) ; $ result .= $ this -> EncodeString ( $ this -> Body , $ this -> Encoding ) ; $ result .= $ this -> LE . $ this -> LE ; $ result .= $ this -> EndBoundary ( $ this -> boundary [ 1 ] ) ; break ; case "plain" : $ result .= $ this -> EncodeString ( $ this -> Body , $ this -> Encoding ) ; break ; case "attachments" : $ result .= $ this -> GetBoundary ( $ this -> boundary [ 1 ] , "" , "" , "" ) ; $ result .= $ this -> EncodeString ( $ this -> Body , $ this -> Encoding ) ; $ result .= $ this -> LE ; $ result .= $ this -> AttachAll ( ) ; break ; case "alt_attachments" : $ result .= sprintf ( "--%s%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; $ result .= sprintf ( "Content-Type: %s;%s" . "\tboundary=\"%s\"%s" , "multipart/alternative" , $ this -> LE , $ this -> boundary [ 2 ] , $ this -> LE . $ this -> LE ) ; $ result .= $ this -> GetBoundary ( $ this -> boundary [ 2 ] , "" , "text/plain" , "" ) . $ this -> LE ; $ result .= $ this -> EncodeString ( $ this -> AltBody , $ this -> Encoding ) ; $ result .= $ this -> LE . $ this -> LE ; $ result .= $ this -> GetBoundary ( $ this -> boundary [ 2 ] , "" , "text/html" , "" ) . $ this -> LE ; $ result .= $ this -> EncodeString ( $ this -> Body , $ this -> Encoding ) ; $ result .= $ this -> LE . $ this -> LE ; $ result .= $ this -> EndBoundary ( $ this -> boundary [ 2 ] ) ; $ result .= $ this -> AttachAll ( ) ; break ; } if ( $ this -> IsError ( ) ) $ result = "" ; return $ result ; }
9322	protected function registerMarkdownEnvironment ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.environment' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'markdown' ] ; $ environment = Environment :: createCommonMarkEnvironment ( ) ; if ( $ config [ 'configurations' ] ) { $ environment -> mergeConfig ( $ config [ 'configurations' ] ) ; } foreach ( $ config [ 'extensions' ] as $ extension ) { if ( class_exists ( $ extension ) ) { $ environment -> addExtension ( new $ extension ( ) ) ; } } return $ environment ; } ) ; $ app -> alias ( 'commonmark.environment' , Environment :: class ) ; }
6595	protected function getMethodComment ( \ ReflectionMethod $ method ) { $ lines = preg_split ( "/((\r?\n)|(\r\n?))/" , $ method -> getDocComment ( ) ) ; $ count = count ( $ lines ) ; foreach ( $ lines as $ i => $ line ) { $ line = preg_replace ( '/^\s*(\/\*\*|\*\/?)\s*/' , '' , $ line ) ; $ line = trim ( $ line ) ; $ lines [ $ i ] = $ line ; if ( ! $ line && ( $ i == 0 || $ i == $ count - 1 ) ) { unset ( $ lines [ $ i ] ) ; } } return array_values ( $ lines ) ; }
10831	public static function createFromSplFileInfo ( \ SplFileInfo $ info ) { $ realpath = $ info -> getRealPath ( ) ; if ( $ info -> isFile ( ) ) { return new fs \ entity \ FileEntity ( $ realpath ) ; } return new fs \ entity \ DirEntity ( $ realpath ) ; }
3274	public function set ( string $ key , $ data ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , $ data ) ; return ; } $ this -> getDatabase ( ) -> appendToFile ( $ this -> getLineString ( $ key , $ data ) ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> delete ( $ key ) ; } }
8965	public function rewriteCountQuery ( $ query ) { if ( \ preg_match ( '/^\s*SELECT\s+\bDISTINCT\b/is' , $ query ) || \ preg_match ( '/\s+GROUP\s+BY\s+/is' , $ query ) ) { return '' ; } $ openParenthesis = '(?:\()' ; $ closeParenthesis = '(?:\))' ; $ subQueryInSelect = $ openParenthesis . '.*\bFROM\b.*' . $ closeParenthesis ; $ pattern = '/(?:.*' . $ subQueryInSelect . '.*)\bFROM\b\s+/Uims' ; if ( \ preg_match ( $ pattern , $ query ) ) { return '' ; } $ subQueryWithLimitOrder = $ openParenthesis . '.*\b(LIMIT|ORDER)\b.*' . $ closeParenthesis ; $ pattern = '/.*\bFROM\b.*(?:.*' . $ subQueryWithLimitOrder . '.*).*/Uims' ; if ( \ preg_match ( $ pattern , $ query ) ) { return '' ; } $ queryCount = \ preg_replace ( '/(?:.*)\bFROM\b\s+/Uims' , 'SELECT COUNT(*) FROM ' , $ query , 1 ) ; list ( $ queryCount ) = \ preg_split ( '/\s+ORDER\s+BY\s+/is' , $ queryCount ) ; list ( $ queryCount ) = \ preg_split ( '/\bLIMIT\b/is' , $ queryCount ) ; return \ trim ( $ queryCount ) ; }
8123	public function savereview ( $ data , Form $ form ) { $ page = $ this -> findRecord ( $ data ) ; $ results = $ this -> getReviewContentHandler ( ) -> submitReview ( $ page , $ data ) ; if ( is_null ( $ results ) ) { return null ; } if ( $ this -> getSchemaRequested ( ) ) { $ extraData = [ 'message' => $ results ] ; $ schemaId = $ this -> owner -> join_links ( $ this -> owner -> Link ( 'schema/ReviewContentForm' ) , $ page -> ID ) ; return $ this -> getSchemaResponse ( $ schemaId , $ form , null , $ extraData ) ; } return $ results ; }
9710	private function writeWindow1 ( ) { $ record = 0x003D ; $ length = 0x0012 ; $ xWn = 0x0000 ; $ yWn = 0x0000 ; $ dxWn = 0x25BC ; $ dyWn = 0x1572 ; $ grbit = 0x0038 ; $ ctabsel = 1 ; $ wTabRatio = 0x0258 ; $ itabFirst = 0 ; $ itabCur = $ this -> spreadsheet -> getActiveSheetIndex ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvvvvvvv' , $ xWn , $ yWn , $ dxWn , $ dyWn , $ grbit , $ itabCur , $ itabFirst , $ ctabsel , $ wTabRatio ) ; $ this -> append ( $ header . $ data ) ; }
7169	public function resolveSaleTaxRule ( SaleInterface $ sale ) : ? TaxRuleInterface { return $ this -> resolveTaxRule ( $ this -> resolveTargetCountry ( $ sale ) , $ sale -> isBusiness ( ) ) ; }
3403	protected function loadFromYml ( $ file ) { $ this -> parser = new Parser ( $ file ) ; $ this -> parser -> load ( $ this ) ; }
9732	public function writeFont ( ) { $ font_outline = 0 ; $ font_shadow = 0 ; $ icv = $ this -> colorIndex ; if ( $ this -> font -> getSuperscript ( ) ) { $ sss = 1 ; } elseif ( $ this -> font -> getSubscript ( ) ) { $ sss = 2 ; } else { $ sss = 0 ; } $ bFamily = 0 ; $ bCharSet = \ PhpOffice \ PhpSpreadsheet \ Shared \ Font :: getCharsetFromFontName ( $ this -> font -> getName ( ) ) ; $ record = 0x31 ; $ reserved = 0x00 ; $ grbit = 0x00 ; if ( $ this -> font -> getItalic ( ) ) { $ grbit |= 0x02 ; } if ( $ this -> font -> getStrikethrough ( ) ) { $ grbit |= 0x08 ; } if ( $ font_outline ) { $ grbit |= 0x10 ; } if ( $ font_shadow ) { $ grbit |= 0x20 ; } $ data = pack ( 'vvvvvCCCC' , $ this -> font -> getSize ( ) * 20 , $ grbit , $ icv , self :: mapBold ( $ this -> font -> getBold ( ) ) , $ sss , self :: mapUnderline ( $ this -> font -> getUnderline ( ) ) , $ bFamily , $ bCharSet , $ reserved ) ; $ data .= StringHelper :: UTF8toBIFF8UnicodeShort ( $ this -> font -> getName ( ) ) ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
12280	protected function initTemplateAssetsManager ( ) { $ templateAssetsManager = $ this -> options [ "template_assets" ] ; $ pluginManager = $ this -> options [ "plugin_manager" ] ; $ templateAssetsManager -> backend ( ) -> add ( $ pluginManager -> getAssets ( ) ) ; return $ templateAssetsManager ; }
4182	public static function instance ( ) { switch ( func_num_args ( ) ) { case func_num_args ( ) == 0 : return new static ( ) ; case func_num_args ( ) == 1 : return new static ( func_get_arg ( 0 ) ) ; case func_num_args ( ) == 2 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) ) ; case func_num_args ( ) == 3 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) ) ; case func_num_args ( ) == 4 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) ) ; case func_num_args ( ) == 5 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) , func_get_arg ( 4 ) ) ; default : throw new Exception ( 'Unable to instantiate class with given arguments' ) ; } }
9054	public function createRelationTable ( $ tableName ) : self { $ table = $ this -> getTableData ( $ tableName ) ; $ name = $ this -> name . '_x_' . $ table -> name ; return $ this -> relationTables [ ] = $ this -> tableFactory -> create ( $ name , $ this -> prefix ) ; }
11573	public function SendHeaders ( ) { if ( headers_sent ( ) ) { return $ this ; } header ( 'HTTP/' . $ this -> Version . ' ' . $ this -> StatusCode . ' ' . $ this -> StatusText , true , $ this -> StatusCode ) ; foreach ( $ this -> Headers -> GetCookies ( ) as $ cookie ) { } return $ this ; }
622	public function with ( ) { $ with = func_get_args ( ) ; if ( isset ( $ with [ 0 ] ) && is_array ( $ with [ 0 ] ) ) { $ with = $ with [ 0 ] ; } if ( empty ( $ this -> with ) ) { $ this -> with = $ with ; } elseif ( ! empty ( $ with ) ) { foreach ( $ with as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> with [ ] = $ value ; } else { $ this -> with [ $ name ] = $ value ; } } } return $ this ; }
7708	function ReplaceSrc ( $ new ) { $ len = $ this -> GetLen ( ) ; $ this -> Txt = substr_replace ( $ this -> Txt , $ new , $ this -> PosBeg , $ len ) ; $ diff = strlen ( $ new ) - $ len ; $ this -> PosEnd += $ diff ; $ this -> pST_Src = false ; if ( $ new === '' ) { $ this -> pST_PosBeg = false ; $ this -> pST_PosEnd = false ; $ this -> pET_PosBeg = false ; } else { $ this -> pST_PosEnd += $ diff ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ diff ; } }
6244	protected function getPermissionGroupIndex ( $ groups ) { $ index = [ ] ; foreach ( $ groups as $ key => $ presence ) { $ permissions = $ presence -> permissions ( ) ; if ( ! $ permissions ) { continue ; } if ( ! is_array ( $ permissions ) ) { $ permissions = [ $ permissions ] ; } foreach ( $ permissions as $ permission ) { $ index [ $ permission ] = $ key ; } } return $ index ; }
12413	public function addDevice ( $ groupId , array $ deviceIdentifiers ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'device_identifiers' => $ deviceIdentifiers , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_ADD_DEVICE , $ params ] ) ; }
11970	public function extendExpiration ( ) { if ( null === $ this -> ttl ) { throw new DomainException ( 'There is no TTL set for this Lock.' ) ; } if ( ! $ this -> expiresAt ) { $ this -> expiresAt = new \ DateTime ( ) ; $ this -> expiresAt -> setTimestamp ( time ( ) ) ; } $ this -> expiresAt -> add ( $ this -> ttl ) ; }
2887	public function onLayoutGenerate ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ layout = $ observer -> getData ( 'layout' ) ; $ requestInfo = $ this -> getRequestInfo ( ) ; $ layoutBlocks = $ layout -> getAllBlocks ( ) ; foreach ( $ layoutBlocks as $ block ) { if ( ! $ this -> canCaptureBlock ( $ block ) ) { continue ; } $ requestInfo -> addBlock ( $ block ) ; } $ design = Mage :: getSingleton ( 'core/design_package' ) ; $ requestInfo -> addLayout ( $ layout , $ design ) ; $ this -> saveProfiling ( ) ; }
1028	private function resolveField ( ObjectType $ parentType , $ source , $ fieldNodes , $ path ) { $ exeContext = $ this -> exeContext ; $ fieldNode = $ fieldNodes [ 0 ] ; $ fieldName = $ fieldNode -> name -> value ; $ fieldDef = $ this -> getFieldDef ( $ exeContext -> schema , $ parentType , $ fieldName ) ; if ( ! $ fieldDef ) { return self :: $ UNDEFINED ; } $ returnType = $ fieldDef -> getType ( ) ; $ info = new ResolveInfo ( $ fieldName , $ fieldNodes , $ returnType , $ parentType , $ path , $ exeContext -> schema , $ exeContext -> fragments , $ exeContext -> rootValue , $ exeContext -> operation , $ exeContext -> variableValues ) ; if ( $ fieldDef -> resolveFn !== null ) { $ resolveFn = $ fieldDef -> resolveFn ; } elseif ( $ parentType -> resolveFieldFn !== null ) { $ resolveFn = $ parentType -> resolveFieldFn ; } else { $ resolveFn = $ this -> exeContext -> fieldResolver ; } $ context = $ exeContext -> contextValue ; $ result = $ this -> resolveOrError ( $ fieldDef , $ fieldNode , $ resolveFn , $ source , $ context , $ info ) ; $ result = $ this -> completeValueCatchingError ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; return $ result ; }
8172	private function getSourceExcerpt ( $ source = '' , $ line = 1 , $ plus = 1 , $ format = false ) { $ excerpt = [ ] ; $ twig = Escape :: html ( $ source ) ; $ lines = preg_split ( "/(\r\n|\n|\r)/" , $ twig ) ; $ start = max ( 1 , $ line - $ plus ) ; $ limit = min ( count ( $ lines ) , $ line + $ plus ) ; for ( $ i = $ start - 1 ; $ i < $ limit ; $ i ++ ) { if ( $ format ) { $ attr = 'data-line="' . ( $ i + 1 ) . '"' ; if ( $ i === $ line - 1 ) $ excerpt [ ] = "<mark $attr>$lines[$i]</mark>" ; else $ excerpt [ ] = "<span $attr>$lines[$i]</span>" ; } else { $ excerpt [ ] = $ lines [ $ i ] ; } } return implode ( "\n" , $ excerpt ) ; }
12148	public function getExceptionCode ( \ Exception $ exception ) { $ class = get_class ( $ exception ) ; $ exceptions = $ this -> getExceptions ( ) ; if ( ! isset ( $ exceptions [ $ class ] ) ) { throw new \ RuntimeException ( sprintf ( 'Not exist exception "%s" in storage.' , $ class ) ) ; } return $ exceptions [ $ class ] ; }
9166	public function getValidationStatus ( $ action = '' ) { $ validation_status = null ; if ( isset ( $ _SESSION [ 'prototyper_validation' ] [ $ action ] ) ) { $ validation_status = $ _SESSION [ 'prototyper_validation' ] [ $ action ] ; } return $ validation_status ; }
152	public function batch ( $ batchSize = 100 , $ db = null ) { return Yii :: createObject ( [ 'class' => BatchQueryResult :: className ( ) , 'query' => $ this , 'batchSize' => $ batchSize , 'db' => $ db , 'each' => false , ] ) ; }
835	protected function find ( $ functionNameToSearch , Tokens $ tokens , $ start = 0 , $ end = null ) { $ end = null === $ end ? $ tokens -> count ( ) : $ end ; $ candidateSequence = [ [ T_STRING , $ functionNameToSearch ] , '(' ] ; $ matches = $ tokens -> findSequence ( $ candidateSequence , $ start , $ end , false ) ; if ( null === $ matches ) { return null ; } list ( $ functionName , $ openParenthesis ) = array_keys ( $ matches ) ; $ functionsAnalyzer = new FunctionsAnalyzer ( ) ; if ( ! $ functionsAnalyzer -> isGlobalFunctionCall ( $ tokens , $ functionName ) ) { return $ this -> find ( $ functionNameToSearch , $ tokens , $ openParenthesis , $ end ) ; } return [ $ functionName , $ openParenthesis , $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ openParenthesis ) ] ; }
769	public static function isFatalError ( $ error ) { return isset ( $ error [ 'type' ] ) && in_array ( $ error [ 'type' ] , [ E_ERROR , E_PARSE , E_CORE_ERROR , E_CORE_WARNING , E_COMPILE_ERROR , E_COMPILE_WARNING , self :: E_HHVM_FATAL_ERROR ] ) ; }
2456	public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( \ is_array ( $ ids ) && \ strlen ( $ ids [ 0 ] ) ) { foreach ( $ ids as $ id ) { $ this -> intId = $ id ; $ this -> delete ( true ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
7173	protected function resolveCustomerTargetCountry ( CustomerInterface $ customer ) : ? CountryInterface { if ( null !== $ address = $ customer -> getDefaultDeliveryAddress ( ) ) { return $ address -> getCountry ( ) ; } return null ; }
6653	public function removeExtraData ( array $ extraDataKeys = [ ] ) { foreach ( $ extraDataKeys as $ key ) { if ( array_key_exists ( $ key , $ this -> extraData ) ) { unset ( $ this -> extraData [ $ key ] ) ; } } }
5421	protected function parse ( $ raw ) { if ( ! $ raw ) { $ this -> setError ( 'Nothing fetched' ) ; $ this -> headers = new SimpleHttpHeaders ( '' ) ; } elseif ( 'file' === $ this -> url -> getScheme ( ) ) { $ this -> headers = new SimpleHttpHeaders ( '' ) ; $ this -> content = $ raw ; } elseif ( ! strstr ( $ raw , "\r\n\r\n" ) ) { $ this -> setError ( 'Could not split headers from content' ) ; $ this -> headers = new SimpleHttpHeaders ( $ raw ) ; } else { list ( $ headers , $ this -> content ) = explode ( "\r\n\r\n" , $ raw , 2 ) ; $ this -> headers = new SimpleHttpHeaders ( $ headers ) ; } }
8436	public static function fetchArray ( array $ conditions , array $ orderBy = null , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( $ entity -> getAllFieldsRealNames ( ) ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( is_array ( $ orderBy ) && count ( $ orderBy ) > 0 ) { $ orders = array ( ) ; foreach ( $ orderBy as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ orders [ $ realName ] = strtoupper ( ucfirst ( $ value ) ) ; } $ selectQuery -> orderBy ( $ orders ) ; } $ selectQuery -> limit ( 1 ) ; if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( is_array ( $ data ) === false ) { return false ; } return $ data ; }
5344	public function make ( $ wsdl , array $ classMap = [ ] ) { return new SoapClient ( $ wsdl , [ 'trace' => true , 'exceptions' => true , 'encoding' => 'utf-8' , 'features' => SOAP_SINGLE_ELEMENT_ARRAYS , 'classmap' => $ classMap , 'cache_wsdl' => WSDL_CACHE_MEMORY , ] ) ; }
12522	public function renderWidget ( array $ fields , $ customFieldOrClass , $ documentType = 'html' , $ slug = null ) { return $ this -> container -> get ( 'chill.custom_field.helper' ) -> renderCustomField ( $ fields , $ customFieldOrClass , $ documentType , $ slug ) ; }
5345	public function requestAccess ( $ when , $ duration , array $ visitors , $ phoneNumber ) { return $ this -> call ( self :: SERVICE , 'requestAccess' , [ $ when , $ duration , $ visitors , $ phoneNumber ] ) ; }
1222	private function wrapExpression ( $ from , callable $ expr , array $ types ) { list ( $ fn , $ pos ) = explode ( ':' , $ from ) ; $ from = "The expression return value of argument {$pos} of {$fn}" ; return function ( $ value ) use ( $ from , $ expr , $ types ) { $ value = $ expr ( $ value ) ; $ this -> validateType ( $ from , $ value , $ types ) ; return $ value ; } ; }
9314	public function storageClearAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ dbAdapter = $ this -> getDbAdapter ( ) ; $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; try { $ table = new JobTable ( $ dbAdapter ) ; $ table -> truncate ( ) ; } catch ( \ Exception $ exception ) { $ console -> writeLine ( 'Truncating database table failed!' , ConsoleColor :: LIGHT_RED ) ; return ; } $ console -> writeLine ( 'Storage was successfully cleared!' , ConsoleColor :: LIGHT_GREEN ) ; }
4518	public function preFlush ( PreFlushEventArgs $ args ) { $ entities = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getScheduledEntityInsertions ( ) ; foreach ( $ entities as $ entity ) { if ( ! $ entity instanceof Parameter ) { continue ; } $ entity -> setValue ( serialize ( $ entity -> getValue ( ) ) ) ; } }
3375	public function open ( $ file ) { if ( strlen ( $ file ) >= 1 && $ file [ 0 ] == '@' ) { try { if ( $ this -> fileLocator instanceof FileLocatorInterface ) { $ file = $ this -> fileLocator -> locate ( $ file ) ; } else { $ this -> fileLocator -> locateResource ( $ file ) ; } } catch ( \ InvalidArgumentException $ exception ) { if ( $ this -> throwException || false == $ this -> fallbackImage ) { throw $ exception ; } $ file = $ this -> fallbackImage ; } } return $ this -> createInstance ( $ file ) ; }
11891	private function createCreateForm ( CustomField $ entity , $ type ) { $ form = $ this -> createForm ( 'custom_field_choice' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfield_create' , array ( 'type' => $ type ) ) , 'method' => 'POST' , 'type' => $ type , 'group_widget' => ( $ entity -> getCustomFieldsGroup ( ) ) ? 'hidden' : 'entity' ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Create' ) ) ; return $ form ; }
2597	public function isNextTokenAny ( array $ tokens ) { return null !== $ this -> lookahead && in_array ( $ this -> lookahead [ 'type' ] , $ tokens , true ) ; }
12643	public function getWidgetId ( ) { if ( ! is_null ( $ this -> _widgetId ) ) { return $ this -> _widgetId ; } return $ this -> _widgetId = 'ic-widget-' . md5 ( microtime ( ) . mt_rand ( ) ) ; }
11038	function node_path_walk ( $ elements , $ rank , $ ptype , & $ i , & $ line , $ cvalue , $ ncontent , $ content , $ code ) { if ( count ( $ elements ) == 1 ) { $ elt [ $ ptype . ':' . $ i . ':' . $ elements [ 0 ] . ':' . $ cvalue ] = $ this -> parse ( $ code ? _ETS_CODE : $ ptype , $ i , $ line , $ ncontent , $ content ) ; } else { $ element1 = array_shift ( $ elements ) ; $ masktype = ( $ ptype == _ETS_MIS || $ ptype == _ETS_MISVAL ) ? _ETS_MIS_TEMPLATE : _ETS_TEMPLATE ; $ elt [ $ masktype . ':' . $ i . '.' . $ rank . ':' . $ element1 ] = $ this -> node_path_walk ( $ elements , $ rank + 1 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } return $ elt ; }
10752	protected function getStateFormatted ( UserEntity $ user ) { switch ( $ user -> getState ( ) ) { case UserEntity :: USER_STATE_ACTIVE : $ this -> stateClass = 'success' ; return 'Attivo' ; break ; case UserEntity :: USER_STATE_BANNED : $ this -> stateClass = 'danger' ; return 'Bannato' ; break ; case UserEntity :: USER_STATE_DEACTIVE : $ this -> stateClass = 'warning' ; return 'Disattivo' ; break ; case UserEntity :: USER_STATE_DELETED : $ this -> stateClass = 'danger' ; return 'Eliminato' ; break ; } $ this -> stateClass = 'danger' ; return 'Error with user state' ; }
2332	public function validator ( $ varInput ) { if ( ! \ is_array ( $ varInput ) ) { return null ; } foreach ( $ varInput as $ k => $ v ) { if ( $ k != 'language' ) { $ varInput [ $ k ] = array_map ( 'trim' , $ v ) ; } else { if ( $ v != '' ) { $ varInput [ $ v ] = array_combine ( array_keys ( $ this -> metaFields ) , array_fill ( 0 , \ count ( $ this -> metaFields ) , '' ) ) ; } unset ( $ varInput [ $ k ] ) ; } } return $ varInput ; }
9873	private function writeDrawings ( XMLWriter $ objWriter = null , PhpspreadsheetWorksheet $ pSheet = null , $ includeCharts = false ) { $ chartCount = ( $ includeCharts ) ? $ pSheet -> getChartCollection ( ) -> count ( ) : 0 ; if ( ( $ pSheet -> getDrawingCollection ( ) -> count ( ) > 0 ) || ( $ chartCount > 0 ) ) { $ objWriter -> startElement ( 'drawing' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId1' ) ; $ objWriter -> endElement ( ) ; } }
11649	protected function _authenticateCreateSelect ( ) { $ dbSelect = clone $ this -> getDbSelect ( ) ; $ dbSelect -> from ( $ this -> _tableName ) -> where ( "{$this->_identityColumn} = ?" , $ this -> _identity ) -> limit ( 1 ) ; return $ dbSelect ; }
5037	public function setImages ( array $ images , PermissionsInterface $ permissions = null ) { $ this -> clear ( ) ; foreach ( $ images as $ prop => $ image ) { $ this -> set ( $ prop , $ image , false ) ; } if ( $ permissions ) { $ this -> setPermissions ( $ permissions ) ; } return $ this ; }
2281	protected static function httpHost ( ) { if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_HOST' ] ; } else { $ host = $ _SERVER [ 'SERVER_NAME' ] ; if ( $ _SERVER [ 'SERVER_PORT' ] != 80 ) { $ host .= ':' . $ _SERVER [ 'SERVER_PORT' ] ; } } return preg_replace ( '/[^A-Za-z0-9[\].:-]/' , '' , $ host ) ; }
2187	public function fetchByAlias ( $ strTable , $ strAlias , $ varValue ) { if ( isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ) { $ strPk = $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ; if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ strPk ] ) ) { return $ this -> arrRegistry [ $ strTable ] [ $ strPk ] ; } } return null ; }
9869	private function writePageMargins ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'pageMargins' ) ; $ objWriter -> writeAttribute ( 'left' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getLeft ( ) ) ) ; $ objWriter -> writeAttribute ( 'right' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getRight ( ) ) ) ; $ objWriter -> writeAttribute ( 'top' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getTop ( ) ) ) ; $ objWriter -> writeAttribute ( 'bottom' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getBottom ( ) ) ) ; $ objWriter -> writeAttribute ( 'header' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getHeader ( ) ) ) ; $ objWriter -> writeAttribute ( 'footer' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getFooter ( ) ) ) ; $ objWriter -> endElement ( ) ; }
5273	public static function table ( $ table_name ) { global $ wpdb ; if ( empty ( self :: $ instances ) || empty ( self :: $ instances [ $ table_name ] ) ) { self :: $ instances [ $ table_name ] = new Query_Builder ( $ wpdb -> prefix . $ table_name ) ; } return self :: $ instances [ $ table_name ] ; }
10320	function getUnsubscribers ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ source = null , $ embedFieldBackups = false , $ pageIndex = 1 , $ pageSize = 100 ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source , $ embedFieldBackups ) ; return $ this -> get ( 'reports/unsubscriptions' , $ params ) ; }
9947	public function getRowDimension ( $ pRow , $ create = true ) { $ found = null ; if ( ! isset ( $ this -> rowDimensions [ $ pRow ] ) ) { if ( ! $ create ) { return null ; } $ this -> rowDimensions [ $ pRow ] = new RowDimension ( $ pRow ) ; $ this -> cachedHighestRow = max ( $ this -> cachedHighestRow , $ pRow ) ; } return $ this -> rowDimensions [ $ pRow ] ; }
9215	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { $ post [ 'StaticPage' ] [ 'tags' ] = implode ( "," , $ post [ 'StaticPage' ] [ 'tags' ] ) ; } } if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; } }
9987	private function mapBorderStyle ( $ borderStyle ) { switch ( $ borderStyle ) { case Border :: BORDER_NONE : return 'none' ; case Border :: BORDER_DASHDOT : return '1px dashed' ; case Border :: BORDER_DASHDOTDOT : return '1px dotted' ; case Border :: BORDER_DASHED : return '1px dashed' ; case Border :: BORDER_DOTTED : return '1px dotted' ; case Border :: BORDER_DOUBLE : return '3px double' ; case Border :: BORDER_HAIR : return '1px solid' ; case Border :: BORDER_MEDIUM : return '2px solid' ; case Border :: BORDER_MEDIUMDASHDOT : return '2px dashed' ; case Border :: BORDER_MEDIUMDASHDOTDOT : return '2px dotted' ; case Border :: BORDER_MEDIUMDASHED : return '2px dashed' ; case Border :: BORDER_SLANTDASHDOT : return '2px dashed' ; case Border :: BORDER_THICK : return '3px solid' ; case Border :: BORDER_THIN : return '1px solid' ; default : return '1px solid' ; } }
9406	protected function approach ( $ middleware ) { if ( $ middleware instanceof \ Closure ) { $ object = new \ ReflectionFunction ( $ middleware ) ; return count ( $ object -> getParameters ( ) ) === 2 ; } $ class = ( string ) get_class ( $ middleware ) ; $ object = new \ ReflectionMethod ( $ class , '__invoke' ) ; return count ( $ object -> getParameters ( ) ) === 2 ; }
8641	public function setShipmentItemAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentItemAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
871	public static function getDisplayableAllowedValues ( FixerOptionInterface $ option ) { $ allowed = $ option -> getAllowedValues ( ) ; if ( null !== $ allowed ) { $ allowed = array_filter ( $ allowed , static function ( $ value ) { return ! ( $ value instanceof \ Closure ) ; } ) ; usort ( $ allowed , static function ( $ valueA , $ valueB ) { if ( $ valueA instanceof AllowedValueSubset ) { return - 1 ; } if ( $ valueB instanceof AllowedValueSubset ) { return 1 ; } return strcasecmp ( self :: toString ( $ valueA ) , self :: toString ( $ valueB ) ) ; } ) ; if ( 0 === \ count ( $ allowed ) ) { $ allowed = null ; } } return $ allowed ; }
10769	public function run ( ) { $ viewName = $ this -> resolveViewName ( ) ; $ this -> controller -> actionParams [ $ this -> viewParam ] = Yii :: $ app -> request -> get ( $ this -> viewParam ) ; $ controllerLayout = null ; if ( $ this -> layout !== null ) { $ controllerLayout = $ this -> controller -> layout ; $ this -> controller -> layout = $ this -> layout ; } try { $ output = $ this -> render ( $ viewName ) ; if ( $ controllerLayout ) { $ this -> controller -> layout = $ controllerLayout ; } } catch ( InvalidParamException $ e ) { if ( $ controllerLayout ) { $ this -> controller -> layout = $ controllerLayout ; } if ( YII_DEBUG ) { throw new NotFoundHttpException ( $ e -> getMessage ( ) ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return $ output ; }
5118	public function deleteAttachment ( string $ idArticle , string $ field , string $ order ) : string { return $ this -> delete ( $ this -> getAttachmentEndPoint ( $ idArticle , $ field ) . "/${order}" ) ; }
3309	protected function buildSignatureKey ( ) { $ signatures = [ 'a' => $ this -> appId , 'b' => $ this -> bucket , 'k' => $ this -> secretId , 'e' => time ( ) + 2592000 , 't' => time ( ) , 'r' => rand ( ) , 'u' => '0' , 'f' => '' ] ; return http_build_query ( $ signatures ) ; }
11475	public function setObjectType ( $ type ) { if ( ! is_object ( $ type ) ) { if ( Yii :: $ app -> collectors [ 'types' ] -> has ( $ type ) ) { $ type = Yii :: $ app -> collectors [ 'types' ] -> getOne ( $ type ) -> object ; } else { $ type = null ; } } $ this -> _objectType = $ type ; }
8507	public function getPackageLabels ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPackageLabelsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPackageLabelsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPackageLabels' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPackageLabelsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11192	public function exists ( $ uri = false , $ httpMethod = false ) { if ( $ uri && $ httpMethod ) { $ this -> routeProcess ( $ uri , $ httpMethod ) ; } if ( ! isset ( $ this -> controllerPath ) ) { return false ; } return true ; }
1861	public function chmod ( $ strFile , $ varMode ) { $ this -> validate ( $ strFile ) ; return chmod ( $ this -> strRootDir . '/' . $ strFile , $ varMode ) ; }
9331	private function region ( $ filter , $ resource , $ region , $ colorspace = null , $ value = null ) { $ dest = imagecreatetruecolor ( $ region [ "w" ] , $ region [ "h" ] ) ; if ( ! imagecopy ( $ dest , $ resource , 0 , 0 , $ region [ "x" ] , $ region [ "y" ] , $ region [ "w" ] , $ region [ "h" ] ) ) { throw new ezcImageFilterFailedException ( "1/ {$function} applied on region {$region['x']}x{$region['y']}" ) ; } if ( ! $ colorspace ) { if ( $ filter == "pixelateImg" ) { $ result = $ this -> $ filter ( $ dest , imagesx ( $ resource ) , imagesy ( $ resource ) ) ; } else $ result = $ this -> $ filter ( $ dest , $ value ) ; } else { $ this -> setActiveResource ( $ dest ) ; parent :: colorspace ( $ colorspace ) ; $ result = $ dest ; } if ( ! imagecopy ( $ resource , $ result , $ region [ "x" ] , $ region [ "y" ] , 0 , 0 , $ region [ "w" ] , $ region [ "h" ] ) ) { throw new ezcImageFilterFailedException ( "2/ {$function} applied on region {$region['x']}x{$region['y']}" ) ; } return $ resource ; }
9963	public function removeRow ( $ pRow , $ pNumRows = 1 ) { if ( $ pRow >= 1 ) { $ highestRow = $ this -> getHighestDataRow ( ) ; $ objReferenceHelper = ReferenceHelper :: getInstance ( ) ; $ objReferenceHelper -> insertNewBefore ( 'A' . ( $ pRow + $ pNumRows ) , 0 , - $ pNumRows , $ this ) ; for ( $ r = 0 ; $ r < $ pNumRows ; ++ $ r ) { $ this -> getCellCollection ( ) -> removeRow ( $ highestRow ) ; -- $ highestRow ; } } else { throw new Exception ( 'Rows to be deleted should at least start from row 1.' ) ; } return $ this ; }
1334	protected function fillRelated ( $ record , ResourceObject $ resource , EncodingParametersInterface $ parameters ) { $ relationships = $ resource -> getRelationships ( ) ; $ changed = false ; foreach ( $ relationships as $ field => $ value ) { if ( $ this -> isNotFillable ( $ field , $ record ) ) { continue ; } if ( ! $ this -> isRelation ( $ field ) ) { continue ; } $ relation = $ this -> getRelated ( $ field ) ; if ( $ this -> requiresPrimaryRecordPersistence ( $ relation ) ) { $ relation -> update ( $ record , $ value , $ parameters ) ; $ changed = true ; } } if ( $ changed ) { $ record -> refresh ( ) ; } }
3579	protected function metaJoinQuery ( Builder $ query , $ method , ArgumentBag $ args ) { $ alias = $ this -> joinMeta ( $ query , $ args -> get ( 'column' ) ) ; $ method = $ args -> get ( 'function' ) ? : $ method ; return ( in_array ( $ method , [ 'orderBy' , 'lists' , 'pluck' ] ) ) ? $ this -> { "{$method}Meta" } ( $ query , $ args , $ alias ) : $ this -> metaSingleResult ( $ query , $ method , $ alias ) ; }
409	public function getHostInfo ( ) { if ( $ this -> _hostInfo === null ) { $ secure = $ this -> getIsSecureConnection ( ) ; $ http = $ secure ? 'https' : 'http' ; if ( $ this -> headers -> has ( 'X-Forwarded-Host' ) ) { $ this -> _hostInfo = $ http . '://' . trim ( explode ( ',' , $ this -> headers -> get ( 'X-Forwarded-Host' ) ) [ 0 ] ) ; } elseif ( $ this -> headers -> has ( 'Host' ) ) { $ this -> _hostInfo = $ http . '://' . $ this -> headers -> get ( 'Host' ) ; } elseif ( isset ( $ _SERVER [ 'SERVER_NAME' ] ) ) { $ this -> _hostInfo = $ http . '://' . $ _SERVER [ 'SERVER_NAME' ] ; $ port = $ secure ? $ this -> getSecurePort ( ) : $ this -> getPort ( ) ; if ( ( $ port !== 80 && ! $ secure ) || ( $ port !== 443 && $ secure ) ) { $ this -> _hostInfo .= ':' . $ port ; } } } return $ this -> _hostInfo ; }
7857	public function register ( ) { $ this -> registerPipelineRepository ( ) ; $ this -> registerInflector ( ) ; $ this -> registerDispatcher ( ) ; $ this -> registerWorkflow ( ) ; $ this -> registerWorkflowRunnersHook ( ) ; $ this -> registerCommands ( ) ; }
3159	public function storeVariables ( QtiRunnerServiceContext $ context , $ itemUri , $ metaVariables , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariables ( $ testUri , $ itemUri , $ metaVariables , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariables ( $ testUri , $ metaVariables , $ sessionId ) ; } return true ; }
11390	public function getStatus ( ) { if ( isset ( $ this -> _log ) ) { $ this -> _status = $ this -> log -> statusLog ; } elseif ( ! isset ( $ this -> _status ) ) { $ this -> _status = new Status ( $ this -> log ) ; } return $ this -> _status ; }
3489	private function createTemporaryFile ( ) : string { $ tmpDir = $ this -> tmpDir ; $ tmpFileName = md5 ( uniqid ( ( string ) mt_rand ( ) , true ) ) . '.p8' ; $ tmpFilePath = $ tmpDir . '/' . $ tmpFileName ; $ errorCode = $ errorMessage = null ; set_error_handler ( function ( $ errCode , $ errMessage ) use ( & $ errorCode , & $ errorMessage ) { $ errorCode = $ errCode ; $ errorMessage = $ errMessage ; } ) ; if ( ! file_exists ( $ tmpDir ) ) { mkdir ( $ tmpDir , 0600 , true ) ; if ( $ errorCode || $ errorMessage ) { restore_error_handler ( ) ; throw new \ RuntimeException ( sprintf ( 'Can not create temporary directory "%s". Error: %s [%d].' , $ tmpDir , $ errorMessage ? : 'Undefined' , $ errorCode ? : '0' ) ) ; } } touch ( $ tmpFilePath ) ; if ( $ errorCode || $ errorMessage ) { restore_error_handler ( ) ; throw new \ RuntimeException ( sprintf ( 'Can not create temporary certificate file "%s". Error: %s [%d].' , $ tmpFilePath , $ errorMessage ? : 'Undefined' , $ errorCode ? : '0' ) ) ; } restore_error_handler ( ) ; return $ tmpFilePath ; }
2406	public static function generateStyleTag ( $ href , $ media = null , $ mtime = false ) { if ( $ mtime === null && ! preg_match ( '@^https?://@' , $ href ) ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ href ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ href ) ; } else { $ webDir = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.web_dir' ) ) ; if ( file_exists ( $ rootDir . '/' . $ webDir . '/' . $ href ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ webDir . '/' . $ href ) ; } } } if ( $ mtime ) { $ href .= '?v=' . substr ( md5 ( $ mtime ) , 0 , 8 ) ; } return '<link rel="stylesheet" href="' . $ href . '"' . ( ( $ media && $ media != 'all' ) ? ' media="' . $ media . '"' : '' ) . '>' ; }
5507	public function returnsByValue ( $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return value' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleByValue ( $ value ) ) ; }
2950	private function failedDispatch ( $ queue , \ Exception $ error ) { foreach ( $ queue as $ index => $ data ) { $ this -> clear ( $ data [ 'key' ] ) ; $ data [ 'reject' ] ( $ error ) ; } }
10304	public function resolve ( $ key ) { if ( ! ( $ this -> getAdapter ( ) instanceof ResolverInterface ) ) { throw new \ LogicException ( 'This adapter can not resolve keys' ) ; } return $ this -> getAdapter ( ) -> resolve ( $ key ) ; }
1514	public function update ( StoreInterface $ store , UpdateResource $ request ) { $ record = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doUpdate ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ record ) ) { return $ record ; } return $ this -> reply ( ) -> updated ( $ record ) ; }
10655	public function groupBy ( $ func ) { $ ret = array ( ) ; $ it = $ this -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( is_object ( $ it -> current ( ) ) ) { $ key = call_user_func ( $ func , $ it -> current ( ) ) ; } else { $ value = $ it -> current ( ) ; $ key = call_user_func_array ( $ func , array ( & $ value ) ) ; $ it -> offsetSet ( $ it -> key ( ) , $ value ) ; unset ( $ value ) ; } if ( is_array ( $ key ) ) { $ ref = & $ ret ; foreach ( $ key as $ subkey ) { if ( ! array_key_exists ( $ subkey , $ ref ) ) { $ ref [ $ subkey ] = array ( ) ; } $ ref = & $ ref [ $ subkey ] ; } $ ref [ ] = $ it -> current ( ) ; } else { $ ret [ $ key ] [ ] = $ it -> current ( ) ; } $ it -> next ( ) ; } unset ( $ ref ) ; $ ret = new self ( $ ret ) ; $ this -> exchangeArray ( $ ret -> getArrayCopy ( ) ) ; return $ this ; }
11994	public function pipe ( $ data , $ index , $ isHeader = false ) { $ this -> lastIndex ++ ; $ this -> data [ $ this -> lastIndex ] = $ data ; }
10225	public function itemsFor ( $ model , $ items = null , $ targetUrl = null , $ nextPageUrl = null , $ offset = - 1 , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ items == null ) { $ items = call_user_func ( array ( $ modelName , 'simplePaginate' ) , 10 ) ; } $ factory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\ResourceItemsFactory' ) ; return $ factory -> create ( $ modelName , $ items , $ targetUrl , $ nextPageUrl , $ offset , $ config ) ; }
3354	public function copy ( $ target = null ) { Helper :: deprecate ( '2.0.0' , '3.0.0' , 'Use createLocalCopy() or createRemoteCopy() instead' ) ; return $ this -> api -> copyFile ( $ this -> getUrl ( ) , $ target ) ; }
8953	public function createNode ( $ changeset , $ latitude , $ longitude , $ tags ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'node/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <node changeset="' . $ changeset . '" lat="' . $ latitude . '" lon="' . $ longitude . '">' . $ tagList . '</node> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
9588	protected function isAttributeSet ( SimpleXmlElement $ node , $ name ) { $ attributes = $ node -> attributes ( ) ; return isset ( $ attributes [ $ name ] ) ; }
6720	public function authorize ( ) { $ this -> validateAuthParams ( ) ; try { $ response = $ this -> curl -> setOption ( CURLOPT_POSTFIELDS , http_build_query ( array ( 'grant_type' => self :: GRANT_TYPE_AUTHORIZATION_CODE , 'client_id' => $ this -> clientId , 'client_secret' => $ this -> clientSecret , 'response_type' => self :: RESPONSE_TYPE_CODE , 'state' => self :: STATE_ALIVE ) ) ) -> post ( $ this -> authUrl , false ) ; } catch ( InvalidParamException $ invalidParamException ) { throw new Oauth2ClientException ( $ invalidParamException -> getMessage ( ) ) ; } return $ this -> handleAuthorizeResponse ( $ response ) ; }
6687	protected function mergeFlashMessages ( $ messageArray ) { $ messages = array_values ( $ messageArray ) ; $ flashMessage = '' ; $ flashMessageArr = [ ] ; foreach ( $ messages as $ message ) { if ( is_array ( $ message ) ) { if ( strlen ( $ flashMessage ) > 0 ) { $ flashMessage .= '<br/>' ; } $ flashMessage .= $ this -> mergeFlashMessages ( $ message ) ; } else { $ flashMessageArr [ ] = $ message ; } } return $ flashMessage . implode ( '<br/>' , $ flashMessageArr ) ; }
4544	public function kernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof ValidationException ) { return ; } $ data = [ 'type' => 'https://tools.ietf.org/html/rfc2616#section-10' , 'title' => 'An error occurred' ] ; if ( in_array ( $ this -> environment , [ 'dev' , 'test' ] , true ) ) { $ data [ 'detail' ] = $ exception -> getMessage ( ) ; $ data [ 'trace' ] = $ exception -> getTrace ( ) ; } $ request = $ event -> getRequest ( ) ; $ contentTypes = $ request -> getAcceptableContentTypes ( ) ; $ accept = array_shift ( $ contentTypes ) ; switch ( $ accept ) { case 'application/json' : case 'application/ld+json' : $ code = Response :: HTTP_INTERNAL_SERVER_ERROR ; if ( $ exception instanceof HttpException ) { $ code = $ exception -> getStatusCode ( ) ; } $ response = new JsonResponse ( $ data , $ code ) ; $ event -> setResponse ( $ response ) ; break ; } }
2686	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ req = $ this -> api -> checkImageOptimizationStatus ( ) ; if ( ! $ req ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check image optimization status.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4221	public function getAbstraction ( & $ array , $ method = null , & $ hist = array ( ) ) { if ( \ in_array ( $ array , $ hist , true ) ) { return $ this -> abstracter -> RECURSION ; } if ( self :: isCallable ( $ array ) ) { return array ( 'debug' => $ this -> abstracter -> ABSTRACTION , 'type' => 'callable' , 'values' => array ( \ get_class ( $ array [ 0 ] ) , $ array [ 1 ] ) , ) ; } $ return = array ( ) ; $ hist [ ] = $ array ; foreach ( $ array as $ k => $ v ) { if ( $ this -> abstracter -> needsAbstraction ( $ v ) ) { $ v = $ this -> abstracter -> getAbstraction ( $ array [ $ k ] , $ method , $ hist ) ; } $ return [ $ k ] = $ v ; } return $ return ; }
5467	protected function findRealmFromUrl ( $ url ) { if ( ! isset ( $ this -> realms [ $ url -> getHost ( ) ] ) ) { return false ; } foreach ( $ this -> realms [ $ url -> getHost ( ) ] as $ name => $ realm ) { if ( $ realm -> isWithin ( $ url ) ) { return $ realm ; } } return false ; }
8844	private function log ( string $ message , array $ context = [ ] ) : void { $ this -> logger -> log ( $ this -> logLevel , $ message , $ context ) ; }
8034	private function buildAttributesFromLdap ( $ entry ) { $ this -> attributes [ 'dn' ] = $ entry [ 'dn' ] ; foreach ( $ entry as $ index => $ key ) { if ( array_key_exists ( $ index , config ( 'ldap.search_fields' ) ) ) { $ this -> attributes [ $ key ] = isset ( $ entry [ $ key ] [ 1 ] ) ? $ entry [ $ key ] : $ entry [ $ key ] [ 0 ] ; } } ; }
11872	protected function _setDataKey ( $ key ) { if ( ! is_null ( $ key ) && ! is_string ( $ key ) && ! ( $ key instanceof Stringable ) ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Data key must be a string or stringable' ) , 0 , null , $ key ) ; } $ this -> dataKey = $ key ; return $ this ; }
5748	public static function removeLastCharsFromString ( string $ input , int $ numChars = 1 ) : string { if ( $ numChars > strlen ( $ input ) ) { throw new \ InvalidArgumentException ( "Cannot remove $numChars from $input" ) ; } return substr ( $ input , 0 , strlen ( $ input ) - $ numChars ) ; }
2874	public function enableAction ( ) { $ moduleName = ( string ) $ this -> getRequest ( ) -> getParam ( 'module' ) ; try { $ this -> getService ( ) -> setModuleStatus ( $ moduleName , true ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'Module was enabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to enable module: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
9720	public function setEscher ( \ PhpOffice \ PhpSpreadsheet \ Shared \ Escher $ pValue = null ) { $ this -> escher = $ pValue ; }
12697	static function getOpts ( $ extname = '' , $ version = '' , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; if ( $ version == '' && self :: isValidVersion ( $ extname ) ) { $ version = $ extname ; $ extname = '' ; } if ( $ version != '' && ! self :: isValidVersion ( $ version ) ) { throw new PakeException ( "'$version' is not a valid version number" ) ; } if ( $ extname == '' ) { $ extname = self :: getDefaultExtName ( ) ; } if ( ! isset ( self :: $ options [ $ extname ] ) || ! is_array ( self :: $ options [ $ extname ] ) ) { if ( isset ( $ cliopts [ 'config-file' ] ) ) { $ cfgfile = $ cliopts [ 'config-file' ] ; } else { $ cfgfile = self :: getOptionsDir ( ) . "/options-$extname.yaml" ; } if ( isset ( $ cliopts [ 'user-config-file' ] ) ) { $ usercfgfile = $ cliopts [ 'user-config-file' ] ; if ( ! is_file ( $ cliopts [ 'user-config-file' ] ) ) { throw new PakeException ( "Could not find user-configuration-file {$cliopts['user-config-file']}" ) ; } } else { $ usercfgfile = self :: getOptionsDir ( ) . "/options-user.yaml" ; } foreach ( $ cliopts as $ opt => $ val ) { if ( substr ( $ opt , 0 , 7 ) == 'option.' ) { unset ( $ cliopts [ $ opt ] ) ; $ work = array_reverse ( explode ( '.' , substr ( $ opt , 7 ) ) ) ; $ built = array ( array_shift ( $ work ) => $ val ) ; foreach ( $ work as $ key ) { $ built = array ( $ key => $ built ) ; } self :: recursivemerge ( $ cliopts , $ built ) ; } } self :: loadConfiguration ( $ cfgfile , $ extname , $ version , $ usercfgfile , $ cliopts ) ; } pake_echo ( "Building extension $extname ( " . self :: $ options [ $ extname ] [ 'extension' ] [ 'name' ] . " ) version " . self :: $ options [ $ extname ] [ 'version' ] [ 'alias' ] . self :: $ options [ $ extname ] [ 'releasenr' ] [ 'separator' ] . self :: $ options [ $ extname ] [ 'version' ] [ 'release' ] ) ; return self :: $ options [ $ extname ] ; }
10792	public function get ( $ idOrUser ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; if ( 'current' == $ idOrUser ) { return $ userRepository -> get ( $ idOrUser , $ this -> getServiceLocator ( ) ) ; } $ user = $ this -> getEntity ( $ idOrUser ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } return $ userRepository -> get ( $ user , $ this -> getServiceLocator ( ) ) ; }
7737	private function getAnnotation ( Reflector $ element , $ annotation ) { if ( $ element instanceof ReflectionClass ) { return $ this -> reader -> getClassAnnotation ( $ element , $ annotation ) ; } elseif ( $ element instanceof ReflectionMethod ) { return $ this -> reader -> getMethodAnnotation ( $ element , $ annotation ) ; } elseif ( $ element instanceof ReflectionProperty ) { return $ this -> reader -> getPropertyAnnotation ( $ element , $ annotation ) ; } return null ; }
7078	static public function isSaleSupportsDocumentType ( SaleInterface $ sale , $ type ) { if ( ! DocumentTypes :: isValidType ( $ type ) ) { return false ; } if ( empty ( $ classes = DocumentTypes :: getClasses ( $ type ) ) ) { return false ; } foreach ( $ classes as $ class ) { if ( is_subclass_of ( $ sale , $ class ) ) { return true ; } } return false ; }
534	protected function fixFileDoc ( & $ lines ) { $ namespace = false ; $ namespaceLine = '' ; $ contentAfterNamespace = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( ! empty ( $ line ) ) { if ( strncmp ( $ line , 'namespace' , 9 ) === 0 ) { $ namespace = $ i ; $ namespaceLine = $ line ; } elseif ( $ namespace !== false ) { $ contentAfterNamespace = $ i ; break ; } } } if ( $ namespace !== false && $ contentAfterNamespace !== false ) { while ( $ contentAfterNamespace > 0 ) { array_shift ( $ lines ) ; $ contentAfterNamespace -- ; } $ lines = array_merge ( [ '<?php' , '/**' , ' * @link http://www.yiiframework.com/' , ' * @copyright Copyright (c) 2008 Yii Software LLC' , ' * @license http://www.yiiframework.com/license/' , ' */' , '' , $ namespaceLine , '' , ] , $ lines ) ; } }
4681	public static function start ( string $ key = 'default' ) : void { if ( isset ( self :: $ timers [ $ key ] ) ) { self :: $ timers [ $ key ] -> start ( ) ; } else { self :: $ timers [ $ key ] = new Stopwatch ( ) ; } }
2941	public static function getUnit ( $ unit ) { if ( ! is_array ( static :: $ unitDefinitions ) ) { static :: $ unitDefinitions = [ ] ; static :: initialize ( ) ; } $ key = static :: buildUnitCacheKey ( $ unit ) ; if ( isset ( self :: $ unitCache [ $ key ] ) ) { return self :: $ unitCache [ $ key ] ; } foreach ( static :: $ unitDefinitions as $ unitOfMeasure ) { if ( $ unit === $ unitOfMeasure -> getName ( ) || $ unitOfMeasure -> isAliasOf ( $ unit ) ) { return self :: $ unitCache [ $ key ] = $ unitOfMeasure ; } } throw new Exception \ UnknownUnitOfMeasure ( [ ':unit' => $ unit ] ) ; }
6447	public function getUserProfile ( ) { $ linkedin = $ this -> getClient ( ) ; $ response = $ linkedin -> get ( '/people/~:(id,first-name,last-name,picture-url,public-profile-url,email-address)' ) ; if ( isset ( $ response [ 'emailAddress' ] ) ) { return array ( 'userid' => $ response [ 'id' ] , 'name' => $ response [ 'firstName' ] . ' ' . $ response [ 'lastName' ] , 'email' => $ response [ 'emailAddress' ] , 'imageurl' => $ response [ 'pictureUrl' ] ) ; } }
4948	public function findDraftsBy ( array $ criteria , array $ sort = null , $ limit = null , $ skip = null ) { $ criteria [ 'isDraft' ] = true ; return parent :: findBy ( $ criteria , $ sort , $ limit , $ skip ) ; }
11811	protected function loadLocalObject ( ) { if ( $ this -> _isLoadingLocalObject ) { throw new RecursionException ( 'Ran into recursion while loading local object' ) ; } $ this -> _isLoadingLocalObject = true ; if ( isset ( $ this -> foreignObject ) && ! isset ( $ this -> _localObject ) ) { $ keyTranslation = $ this -> dataSource -> getKeyTranslation ( $ this -> foreignObject ) ; if ( ! empty ( $ keyTranslation ) && ( $ localObject = $ keyTranslation -> object ) ) { $ this -> localObject = $ localObject ; } } $ this -> _isLoadingLocalObject = false ; }
3971	public function getAttributeOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ result = [ ] ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ conditionType = $ event -> getModel ( ) -> getProperty ( 'type' ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( ! $ this -> conditionFactory -> supportsAttribute ( $ conditionType , $ attribute -> get ( 'type' ) ) ) { continue ; } $ typeName = $ attribute -> get ( 'type' ) ; $ strSelectVal = $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ; $ result [ $ strSelectVal ] = $ attribute -> getName ( ) . ' [' . $ typeName . ']' ; } $ event -> setOptions ( $ result ) ; }
6838	public function mapDatas ( $ kvs ) { foreach ( $ kvs as $ k => $ v ) { $ this -> mapData ( $ k , $ v ) ; } }
1853	public function onReplaceInsertTags ( string $ tag ) { $ chunks = explode ( '::' , $ tag ) ; if ( 'trans' !== $ chunks [ 0 ] ) { return false ; } $ parameters = isset ( $ chunks [ 3 ] ) ? explode ( ':' , $ chunks [ 3 ] ) : [ ] ; return $ this -> translator -> trans ( $ chunks [ 1 ] , $ parameters , $ chunks [ 2 ] ?? null ) ; }
11840	public static function size ( $ inputImg ) { if ( is_string ( $ inputImg ) ) $ img = self :: imgCreate ( $ inputImg ) ; else $ img = $ inputImg ; $ imgW = imagesx ( $ img ) ; $ imgH = imagesy ( $ img ) ; if ( is_string ( $ inputImg ) ) imagedestroy ( $ img ) ; return array ( $ imgW , $ imgH ) ; }
8367	public static function get ( string $ name ) : array { if ( isset ( self :: $ mappings [ $ name ] ) === false ) { throw new MappingNotFound ( 'there\'s no registered mapping with name "' . $ name . '"' ) ; } return self :: $ mappings [ $ name ] ; }
8231	public static function getItemByUrl ( $ items , $ url ) { if ( ! isset ( $ items ) ) { return null ; } if ( array_key_exists ( "/" . $ url , $ items ) ) { return $ items [ "/" . $ url ] ; } $ urlParts = explode ( "/" , trim ( $ url , "/" ) ) ; $ urlPartsLen = count ( $ urlParts ) ; while ( $ urlPartsLen > 0 ) { unset ( $ urlParts [ -- $ urlPartsLen ] ) ; $ subUrl = "/" . join ( "/" , $ urlParts ) ; if ( array_key_exists ( $ subUrl , $ items ) && ( ! isset ( $ items [ $ subUrl ] [ "recursive" ] ) || $ items [ $ subUrl ] [ "recursive" ] === true ) ) { return $ items [ $ subUrl ] ; } } return null ; }
12461	private function createMakeDefaultForm ( CustomFieldsGroup $ group = null ) { return $ this -> createFormBuilder ( $ group , array ( 'method' => 'POST' , 'action' => $ this -> generateUrl ( 'customfieldsgroup_makedefault' ) ) ) -> add ( 'id' , 'hidden' ) -> add ( 'submit' , 'submit' , array ( 'label' => 'Make default' ) ) -> getForm ( ) ; }
11307	public function sendMessage ( $ chatId , $ text , $ disableWebPagePreview = null , $ replyToMessageId = null , $ replyMarkup = null ) { $ response = $ this -> apiRequest ( "sendMessage" , [ "chat_id" => $ chatId , "text" => $ text , "disable_web_page_preview" => $ disableWebPagePreview , "reply_to_message_id" => $ replyToMessageId , "reply_markup" => $ replyMarkup ? $ replyMarkup -> toArray ( ) : null , ] ) ; return $ this -> entityFromBody ( $ response -> getBody ( ) , new Message ( ) ) ; }
8005	public static function calculatePayloadOffset ( $ negotiate_flags ) { $ offset = 0 ; $ offset += strlen ( static :: SIGNATURE ) ; $ offset += 4 ; $ offset += 4 ; $ offset += 8 ; $ offset += 8 ; return $ offset ; }
7918	public static function labelGroup ( $ labels = [ ] , $ options = [ ] ) { Ui :: addCssClasses ( $ options , [ 'ui' , 'labels' ] ) ; $ lines = [ ] ; foreach ( $ labels as $ label ) { $ content = ArrayHelper :: remove ( $ label , 'content' ) ; $ lines [ ] = static :: label ( $ content , $ label ) ; } return Ui :: tag ( 'div' , implode ( "\n" , $ lines ) , $ options ) ; }
6355	public function setTimestamp ( $ ts = false ) { $ m = [ ] ; $ da = [ ] ; $ strtime = '' ; if ( ! $ ts || $ ts === "\0\0\0\0\0\0\0\0\0\0\0\0\0\0" ) { $ uts = self :: time ( ) ; $ strtime = "@$uts" ; } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4}):(\d\d):(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(-?\d{1,13})$/D' , $ ts , $ m ) ) { $ strtime = "@{$m[1]}" ; } elseif ( preg_match ( '/^(-?\d{1,13})(\.\d+)$/D' , $ ts , $ m ) ) { $ strtime = 'unixmicro' ; } elseif ( preg_match ( '/^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}.\d{6}$/' , $ ts ) ) { $ strtime = preg_replace ( '/(\d\d)\.(\d\d)\.(\d\d)(\.(\d+))?/' , "$1:$2:$3" , str_replace ( '+00:00' , 'UTC' , $ ts ) ) ; } elseif ( preg_match ( '/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d*[\+\- ](\d\d)$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d* GMT$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^[ \t\r\n]*([A-Z][a-z]{2},[ \t\r\n]*)?' . '\d\d?[ \t\r\n]*[A-Z][a-z]{2}[ \t\r\n]*\d{2}(?:\d{2})?' . '[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d/S' , $ ts ) ) { $ strtime = strtok ( $ ts , ';' ) ; } elseif ( preg_match ( '/^[A-Z][a-z]{5,8}, \d\d-[A-Z][a-z]{2}-\d{2} \d\d:\d\d:\d\d/' , $ ts ) ) { $ strtime = $ ts ; } elseif ( preg_match ( '/^[A-Z][a-z]{2} [A-Z][a-z]{2} +\d{1,2} \d\d:\d\d:\d\d \d{4}/' , $ ts ) ) { $ strtime = $ ts ; } else { throw new TimestampException ( __METHOD__ . ": Invalid timestamp - $ts" ) ; } if ( ! $ strtime ) { $ da = array_map ( 'intval' , $ da ) ; $ da [ 0 ] = "%04d-%02d-%02dT%02d:%02d:%02d.00+00:00" ; $ strtime = call_user_func_array ( "sprintf" , $ da ) ; } try { if ( $ strtime === 'unixmicro' ) { $ final = DateTime :: createFromFormat ( 'U.u' , $ ts , new DateTimeZone ( 'GMT' ) ) ; } else { $ final = new DateTime ( $ strtime , new DateTimeZone ( 'GMT' ) ) ; } } catch ( Exception $ e ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' , $ e -> getCode ( ) , $ e ) ; } if ( $ final === false ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' ) ; } $ this -> timestamp = $ final ; }
9706	private function writeAllNumberFormats ( ) { foreach ( $ this -> numberFormats as $ numberFormatIndex => $ numberFormat ) { $ this -> writeNumberFormat ( $ numberFormat -> getFormatCode ( ) , $ numberFormatIndex ) ; } }
1708	public static function removeEntry ( $ strUrl ) { $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT id FROM tl_search WHERE url=?" ) -> execute ( $ strUrl ) ; while ( $ objResult -> next ( ) ) { $ objDatabase -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ objDatabase -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } }
4951	public function getTargetFQCN ( ) { return is_object ( $ this -> target ) ? get_class ( $ this -> target ) : ( string ) $ this -> target ; }
11819	public function addAppDependencies ( ) { $ container = $ this -> getContainer ( ) ; $ container [ 'person' ] = $ container -> protect ( function ( $ name ) { return 'Person name: ' . $ name ; } ) ; return $ this ; }
4753	private function getContactFormMethod ( ) { $ method = self :: CONTACT_FORM_METHOD_DEFAULT ; if ( $ configMethod = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'OeGdprOptinContactFormMethod' ) ) { $ method = $ configMethod ; } return $ method ; }
6362	public function convert ( float $ duration , TimeUnit $ timeUnit ) : float { return $ duration * ( $ timeUnit -> inMicros / $ this -> inMicros ) ; }
7651	public function rename ( $ path_from , $ path_to ) { if ( $ this -> getContainerName ( $ path_from ) != $ this -> getContainerName ( $ path_to ) ) { throw new BlobException ( 'Container name can not be changed.' ) ; } if ( $ this -> getFileName ( $ path_from ) == $ this -> getContainerName ( $ path_to ) ) { return true ; } $ this -> getStorageClient ( $ path_from ) -> copyBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) , $ this -> getContainerName ( $ path_to ) , $ this -> getFileName ( $ path_to ) ) ; $ this -> getStorageClient ( $ path_from ) -> deleteBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) ) ; clearstatcache ( true , $ path_from ) ; clearstatcache ( true , $ path_to ) ; return true ; }
2514	public function setConsumerId ( $ id ) { $ this -> sessionHandler -> setTransactionFlowLink ( true ) ; $ this -> sessionHandler -> setConsumerId ( $ id ) ; }
8230	public static function writeFile ( $ fileName , $ data , $ options = [ ] ) { $ writer = new File \ FileWriter ( $ fileName , $ options ) ; $ isSuccess = true ; $ written = 0 ; try { $ writer -> open ( ) ; $ written = $ writer -> write ( $ data ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ isSuccess = false ; } try { $ writer -> close ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ isSuccess = false ; } return $ isSuccess ; }
325	public static function variablize ( $ word ) { $ word = static :: camelize ( $ word ) ; return mb_strtolower ( mb_substr ( $ word , 0 , 1 , self :: encoding ( ) ) ) . mb_substr ( $ word , 1 , null , self :: encoding ( ) ) ; }
10522	protected function quoteIndex ( array $ cols ) { $ q = [ ] ; foreach ( $ cols as $ col ) { $ q [ ] = $ this -> quoteLeading ( $ col ) ; } return $ q ; }
10951	private function validateCsrfTokenInternal ( $ token , $ trueToken ) { $ token = base64_decode ( str_replace ( '.' , '+' , $ token ) ) ; $ n = StringHelper :: byteLength ( $ token ) ; if ( $ n <= static :: CSRF_MASK_LENGTH ) { return false ; } $ mask = StringHelper :: byteSubstr ( $ token , 0 , static :: CSRF_MASK_LENGTH ) ; $ token = StringHelper :: byteSubstr ( $ token , static :: CSRF_MASK_LENGTH , $ n - static :: CSRF_MASK_LENGTH ) ; $ token = $ this -> xorTokens ( $ mask , $ token ) ; return $ token === $ trueToken ; }
4289	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ meta = \ array_merge ( array ( 'format' => 'raw' , 'requestId' => $ this -> requestId , ) , $ meta ) ; if ( $ meta [ 'channel' ] == $ this -> debug -> getCfg ( 'channel' ) ) { unset ( $ meta [ 'channel' ] ) ; } if ( $ meta [ 'format' ] == 'raw' ) { $ args = $ this -> crateValues ( $ args ) ; } if ( ! empty ( $ meta [ 'backtrace' ] ) ) { $ meta [ 'backtrace' ] = $ this -> crateValues ( $ meta [ 'backtrace' ] ) ; } $ this -> wamp -> publish ( $ this -> topic , array ( $ method , $ args , $ meta ) ) ; }
1048	public static function value ( $ rawString ) { $ lines = preg_split ( "/\\r\\n|[\\n\\r]/" , $ rawString ) ; $ commonIndent = null ; $ linesLength = count ( $ lines ) ; for ( $ i = 1 ; $ i < $ linesLength ; $ i ++ ) { $ line = $ lines [ $ i ] ; $ indent = self :: leadingWhitespace ( $ line ) ; if ( $ indent >= mb_strlen ( $ line ) || ( $ commonIndent !== null && $ indent >= $ commonIndent ) ) { continue ; } $ commonIndent = $ indent ; if ( $ commonIndent === 0 ) { break ; } } if ( $ commonIndent ) { for ( $ i = 1 ; $ i < $ linesLength ; $ i ++ ) { $ line = $ lines [ $ i ] ; $ lines [ $ i ] = mb_substr ( $ line , $ commonIndent ) ; } } while ( count ( $ lines ) > 0 && trim ( $ lines [ 0 ] , " \t" ) === '' ) { array_shift ( $ lines ) ; } while ( count ( $ lines ) > 0 && trim ( $ lines [ count ( $ lines ) - 1 ] , " \t" ) === '' ) { array_pop ( $ lines ) ; } return implode ( "\n" , $ lines ) ; }
1712	public function getArticleAlias ( Contao \ DataContainer $ dc ) { $ arrPids = array ( ) ; $ arrAlias = array ( ) ; if ( ! $ this -> User -> isAdmin ) { foreach ( $ this -> User -> pagemounts as $ id ) { $ arrPids [ ] = array ( $ id ) ; $ arrPids [ ] = $ this -> Database -> getChildRecords ( $ id , 'tl_page' ) ; } if ( ! empty ( $ arrPids ) ) { $ arrPids = array_merge ( ... $ arrPids ) ; } else { return $ arrAlias ; } $ objAlias = $ this -> Database -> prepare ( "SELECT a.id, a.title, a.inColumn, p.title AS parent FROM tl_article a LEFT JOIN tl_page p ON p.id=a.pid WHERE a.pid IN(" . implode ( ',' , array_map ( '\intval' , array_unique ( $ arrPids ) ) ) . ") ORDER BY parent, a.sorting" ) -> execute ( $ dc -> id ) ; } else { $ objAlias = $ this -> Database -> prepare ( "SELECT a.id, a.title, a.inColumn, p.title AS parent FROM tl_article a LEFT JOIN tl_page p ON p.id=a.pid ORDER BY parent, a.sorting" ) -> execute ( $ dc -> id ) ; } if ( $ objAlias -> numRows ) { Contao \ System :: loadLanguageFile ( 'tl_article' ) ; while ( $ objAlias -> next ( ) ) { $ arrAlias [ $ objAlias -> parent ] [ $ objAlias -> id ] = $ objAlias -> title . ' (' . ( $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ objAlias -> inColumn ] ? : $ objAlias -> inColumn ) . ', ID ' . $ objAlias -> id . ')' ; } } return $ arrAlias ; }
5987	public function setCreatedRange ( $ createdRange ) { if ( $ createdRange instanceof DateTimeRange ) { $ this -> createdRange = $ createdRange ; } elseif ( is_array ( $ createdRange ) ) { $ this -> createdRange = new DateTimeRange ( $ createdRange ) ; } else { $ this -> createdRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
10552	public function resolveApp ( ) { $ this -> determineVirtualHost ( ) ; $ path = $ this -> vhost -> getPath ( $ this -> request -> url ) ; $ resolved = $ this -> resolver -> resolve ( "app" , $ path ) ; if ( $ resolved !== null ) { if ( $ resolved [ 'ext' ] ) { $ mime = new FileType ( $ resolved [ 'ext' ] , "" ) ; if ( ! empty ( $ mime ) ) { $ str = $ mime -> getMimeType ( ) . ";q=1.5," . ( string ) $ this -> request -> accept ; $ this -> request -> setAccept ( new Accept ( $ str ) ) ; } $ this -> suffix = $ resolved [ 'ext' ] ; } $ this -> route = $ resolved [ 'route' ] ; $ this -> app = $ resolved [ 'path' ] ; $ this -> arguments = new Dictionary ( $ resolved [ 'remainder' ] ) ; } else { $ this -> route = null ; $ this -> app = null ; $ this -> arguments = new Dictionary ( ) ; } }
4395	public function isImplemented ( $ what ) { $ provider = $ this -> getProvider ( ) ; switch ( $ what ) { case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_CAPTURE : return $ provider -> supportsCapture ( ) ; case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_CANCEL : return $ provider -> supportsVoid ( ) ; case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_REFUND : return $ provider -> supportsRefund ( ) ; case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_REPAY : return method_exists ( $ provider , 'createCard' ) ; } return false ; }
1152	public function selector ( $ selector ) { $ this -> selector = is_null ( $ selector ) ? $ this -> selector : $ selector ; return $ this ; }
8475	public function debug ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'debug' , $ scope , $ message , $ context , $ config ) ; }
9639	public function setValue ( $ url ) { if ( $ url ) { $ url = $ this -> rebuildURL ( $ url ) ; } parent :: setValue ( $ url ) ; }
3297	public function doAutoRunEnhancements ( LeadEvent $ event ) { $ lead = $ event -> getLead ( ) ; if ( $ lead && ( null !== $ lead -> getDateIdentified ( ) || ! $ lead -> isAnonymous ( ) ) ) { $ leadKey = strtolower ( implode ( '|' , [ $ lead -> getFirstname ( ) , ( $ lead -> getLastActive ( ) ? $ lead -> getLastActive ( ) -> format ( 'c' ) : '' ) , $ lead -> getEmail ( ) , $ lead -> getPhone ( ) , $ lead -> getMobile ( ) , ] ) ) ; if ( strlen ( $ leadKey ) > 3 ) { if ( isset ( $ this -> leadsEnhanced [ $ leadKey ] ) ) { return ; } else { $ this -> leadsEnhanced [ $ leadKey ] = true ; } } $ integrations = $ this -> enhancerHelper -> getEnhancerIntegrations ( ) ; foreach ( $ integrations as $ integration ) { $ settings = $ integration -> getIntegrationSettings ( ) ; if ( $ settings -> getIsPublished ( ) ) { $ features = $ settings -> getFeatureSettings ( ) ; if ( isset ( $ features [ 'autorun_enabled' ] ) && $ features [ 'autorun_enabled' ] ) { try { $ integration -> doEnhancement ( $ lead ) ; } catch ( \ Exception $ exception ) { $ e = new ApiErrorException ( 'There was an issue using enhancer: ' . $ integration -> getName ( ) , 0 , $ exception ) ; if ( ! empty ( $ lead ) ) { $ e -> setContact ( $ lead ) ; } throw $ e ; } } } } $ this -> logger -> info ( 'doAutoRunEnhancements complete' ) ; } }
8341	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ prettyPageHandler = new PrettyPageHandler ( ) ; self :: $ prettyPageHandler -> setPageTitle ( 'I just broke a string... - strayFw' ) ; $ whoops = new Run ( ) ; $ whoops -> pushHandler ( new JsonResponseHandler ( ) ) ; $ whoops -> pushHandler ( self :: $ prettyPageHandler ) ; $ whoops -> register ( ) ; self :: $ isInit = true ; } }
6219	public function getPeriodEnd ( ) { if ( is_null ( $ this -> parsedPeriodEnd ) ) { $ this -> parsedPeriodEnd = strtotime ( $ this -> periodEnd ) ; } return $ this -> parsedPeriodEnd ; }
12274	public static function createFromFormat ( $ format , $ time , $ object = null ) { if ( empty ( $ object ) ) { $ object = new DateTimeZone ( 'America/Sao_Paulo' ) ; } return self :: cast ( parent :: createFromFormat ( $ format , $ time , $ object ) ) ; }
11078	public static function formatPhoneNumber ( $ phoneNumber , $ formatType = Tools :: PHONE_NUMBER_FORMAT_NUMBER ) { $ formatType = ( int ) $ formatType ; if ( $ formatType !== self :: PHONE_NUMBER_FORMAT_INTERNATIONAL && $ formatType !== self :: PHONE_NUMBER_FORMAT_INTERNATIONAL_NICE && $ formatType !== self :: PHONE_NUMBER_FORMAT_NUMBER && $ formatType !== self :: PHONE_NUMBER_FORMAT_NICE && $ formatType !== self :: PHONE_NUMBER_FORMAT_SMSTOOLS ) { return false ; } if ( ! Validate :: isPhoneNumber ( $ phoneNumber ) ) { return false ; } $ phoneNumber = self :: removeSpace ( $ phoneNumber ) ; $ phoneLen = \ strlen ( $ phoneNumber ) ; if ( $ phoneLen > 9 && 0 !== strpos ( $ phoneNumber , '+' ) ) { $ phoneNumber = '+' . $ phoneNumber ; $ phoneLen ++ ; } if ( $ phoneLen !== 9 && ! ( $ phoneLen >= 11 && $ phoneLen <= 13 && 0 === strpos ( $ phoneNumber , '+' ) ) ) { return false ; } $ international = ( $ phoneLen !== 9 ) ; switch ( $ formatType ) { case self :: PHONE_NUMBER_FORMAT_INTERNATIONAL_NICE : $ formattedPhone = preg_replace ( '/^(\+\d{1,3})(\d{3})(\d{3})(\d{3})$/' , '$1 $2 $3 $4' , $ international ? $ phoneNumber : '+420' . $ phoneNumber ) ; break ; case self :: PHONE_NUMBER_FORMAT_INTERNATIONAL : $ formattedPhone = $ international ? $ phoneNumber : '+420' . $ phoneNumber ; break ; case self :: PHONE_NUMBER_FORMAT_NICE : $ formattedPhone = preg_replace ( '/^(\+\d{1,3})(\d{3})(\d{3})(\d{3})$/' , '$2 $3 $4' , $ international ? $ phoneNumber : '+420' . $ phoneNumber ) ; break ; case self :: PHONE_NUMBER_FORMAT_NUMBER : $ formattedPhone = $ international ? substr ( $ phoneNumber , - 9 ) : $ phoneNumber ; break ; case self :: PHONE_NUMBER_FORMAT_SMSTOOLS : $ formattedPhone = $ international ? trim ( $ phoneNumber , '+' ) : '420' . $ phoneNumber ; break ; default : $ formattedPhone = false ; } return $ formattedPhone ; }
6321	public function addConstraint ( ConstraintInterface $ constraint ) { $ constraint -> setTable ( $ this ) ; $ this -> constraints [ ] = $ constraint ; return $ this ; }
3759	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) -> getName ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_langcode' , [ ] , 'contao_tl_metamodel_attribute' ) , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_value' , [ ] , 'contao_tl_metamodel_attribute' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) -> getName ( ) ) , true ) ) ; }
1275	private function sendRequest ( $ request , $ endpoint , $ operation , $ wsdl ) { $ endpointurl = $ this -> compileEndpointUrl ( $ endpoint ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ endpointurl , $ operation , $ wsdl ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } return $ this -> formatResponse ( $ response ) ; }
491	public function via ( $ relationName , callable $ callable = null ) { $ relation = $ this -> primaryModel -> getRelation ( $ relationName ) ; $ callableUsed = $ callable !== null ; $ this -> via = [ $ relationName , $ relation , $ callableUsed ] ; if ( $ callable !== null ) { call_user_func ( $ callable , $ relation ) ; } return $ this ; }
194	public function sendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( ! isset ( $ options [ 'mimeType' ] ) ) { $ options [ 'mimeType' ] = FileHelper :: getMimeTypeByExtension ( $ filePath ) ; } if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } $ handle = fopen ( $ filePath , 'rb' ) ; $ this -> sendStreamAsFile ( $ handle , $ attachmentName , $ options ) ; return $ this ; }
1601	public function injectRobots ( ) { $ headers = \ Craft :: $ app -> getResponse ( ) -> getHeaders ( ) ; if ( \ Craft :: $ app -> config -> general -> devMode ) { $ headers -> set ( 'x-robots-tag' , 'none, noimageindex' ) ; return ; } list ( $ field , $ element ) = $ this -> _getElementAndSeoFields ( ) ; $ robots = $ field -> robots ; if ( $ robots !== null ) $ headers -> set ( 'x-robots-tag' , $ robots ) ; if ( isset ( $ element -> expiryDate ) ) $ expiry = $ element -> expiryDate -> format ( \ DATE_RFC850 ) ; else $ expiry = null ; if ( $ expiry ) $ headers -> add ( 'x-robots-tag' , 'unavailable_after: ' . $ expiry ) ; }
8362	public static function registerTranslations ( $ baseDir , $ localesDir , $ prefix = null ) { if ( self :: $ isInit === true ) { $ dir = $ baseDir . DIRECTORY_SEPARATOR . $ localesDir ; if ( is_dir ( $ dir ) === false ) { throw new InvalidDirectory ( 'directory "' . $ dir . '" can\'t be identified' ) ; } $ language = self :: $ currentLanguage ; if ( ( $ pos = strpos ( $ language , '-' ) ) !== false ) { $ pos = ( int ) $ pos ; $ language = substr ( $ language , 0 , $ pos ) ; } if ( ( $ pos = strpos ( $ language , '_' ) ) !== false ) { $ pos = ( int ) $ pos ; $ language = substr ( $ language , 0 , $ pos ) ; } if ( is_readable ( $ dir . DIRECTORY_SEPARATOR . $ language . '.yml' ) === true ) { $ newOnes = Config :: get ( $ dir . DIRECTORY_SEPARATOR . $ language . '.yml' ) ; if ( is_array ( $ newOnes ) === true ) { if ( $ prefix != null ) { $ newOnes = array ( $ prefix => $ newOnes ) ; } self :: $ translations = array_merge ( self :: $ translations , $ newOnes ) ; } } else { Logger :: get ( ) -> notice ( 'can\'t find language "' . $ language . '" in directory "' . $ dir . '"' ) ; } } }
12391	public function setHydrator ( $ hydrator ) { if ( ! is_string ( $ hydrator ) && ! $ hydrator instanceof HydratorInterface ) { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be an object of instance Zend\Stdlib\Hydrator\HydratorInterface or string, %s provided instead' , __METHOD__ , is_object ( $ hydrator ) ? get_class ( $ hydrator ) : gettype ( $ hydrator ) ) ) ; } $ this -> hydrator = $ hydrator ; return $ this ; }
8132	public function getSourceContext ( ) { return $ this -> filename ? new Twig_Source ( $ this -> sourceCode , $ this -> filename , $ this -> sourcePath ) : null ; }
11727	public function setTaxonomy_id ( $ value ) { if ( ! is_array ( $ value ) ) { $ value = [ $ value ] ; } foreach ( $ value as $ k => $ v ) { if ( is_object ( $ v ) ) { $ value [ $ k ] = $ v -> primaryKey ; } elseif ( is_array ( $ v ) ) { unset ( $ value [ $ k ] ) ; if ( isset ( $ v [ 'systemId' ] ) && isset ( $ v [ 'taxonomyType' ] ) ) { $ taxonomyType = Yii :: $ app -> collectors [ 'taxonomies' ] -> getOne ( $ v [ 'taxonomyType' ] ) ; if ( isset ( $ taxonomyType ) && ( $ taxonomy = $ taxonomyType -> getTaxonomy ( $ v [ 'systemId' ] ) ) ) { $ value [ $ k ] = $ taxonomy -> primaryKey ; } } } } $ this -> _taxonomy_id = $ value ; }
12012	private function addDoctrineSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> children ( ) -> arrayNode ( 'doctrine' ) -> info ( 'doctrine configuration' ) -> canBeEnabled ( ) -> children ( ) -> booleanNode ( 'enabled' ) -> defaultTrue ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; }
10407	private function save ( Pair $ pair ) { $ this -> manager -> persist ( $ pair ) ; $ this -> manager -> commit ( ) ; $ this -> manager -> refresh ( ) ; }
9633	public function onBeforeWrite ( ) { $ return = parent :: onBeforeWrite ( ) ; $ exists = self :: get ( ) -> filter ( 'Name' , $ this -> Name ) -> exclude ( 'ID' , $ this -> ID ) ; if ( $ exists -> count ( ) ) { throw new ValidationException ( _t ( 'Moo_EditableField.UNIQUENAME' , 'Field name "{name}" must be unique' , '' , [ 'name' => $ this -> Name ] ) ) ; } $ this -> Name = preg_replace ( '/[^a-zA-Z0-9_]+/' , '' , $ this -> Name ) ; $ customSettings = $ this -> getSettings ( ) ; if ( empty ( $ customSettings ) ) { $ customSettings = ( array ) Controller :: curr ( ) -> getRequest ( ) -> postVar ( 'CustomSettings' ) ; } if ( ! empty ( $ this -> customSettingsFields ) ) { $ customSettings = array_intersect_key ( $ customSettings , array_flip ( ( array ) $ this -> customSettingsFields ) ) ; } $ this -> setSettings ( $ customSettings ) ; return $ return ; }
7495	private static function convertString ( $ string , $ outputEncoding ) { if ( $ string instanceof StringBuilder ) { $ inputEncoding = $ string -> getEncoding ( ) ; } else { $ inputEncoding = mb_detect_encoding ( ( string ) $ string ) ; } $ string = ( string ) $ string ; if ( $ inputEncoding != $ outputEncoding ) { $ string = iconv ( $ inputEncoding , $ outputEncoding , $ string ) ; } return $ string ; }
11592	public function getFullPath ( $ file = '' ) { $ this -> name = ( $ file ) ? $ file : $ this -> name ; return config ( 'odin.assetsUrl' ) . $ this -> getPath ( ) . $ this -> name ; }
800	private function findStart ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ $ index ] -> equalsAny ( [ '$' , [ T_VARIABLE ] ] ) ) { if ( $ tokens [ $ index ] -> equals ( ']' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_INDEX_SQUARE_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_PROP_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_PROP_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_VAR_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_VAR_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_INDEX_CURLY_BRACE , $ index ) ; } else { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } } while ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> equals ( '$' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } if ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return $ this -> findStart ( $ tokens , $ tokens -> getPrevMeaningfulToken ( $ index ) ) ; } return $ index ; }
6495	public function visitPage ( $ path , $ code = 200 ) { if ( ! $ this -> assertStatusCode ( $ path , $ code ) ) { throw new \ Exception ( sprintf ( 'The page "%s" is not accessible!' , $ path ) ) ; } self :: debug ( [ 'Visited page: %s' ] , [ $ path ] ) ; $ this -> visitPath ( $ path ) ; }
9581	public function getChannel ( $ channel = null ) { $ channel = $ channel ? : $ this -> defaultChannel ; if ( isset ( $ this -> deferredChannels [ $ channel ] ) ) { $ this -> setChannel ( $ channel , $ this -> deferredChannels [ $ channel ] ( ) ) ; unset ( $ this -> deferredChannels [ $ channel ] ) ; } if ( isset ( $ this -> channels [ $ channel ] ) ) { return $ this -> channels [ $ channel ] ; } throw new InvalidArgumentException ( "Undefined channel: $channel" ) ; }
9860	private static function getInt4d ( $ data , $ pos ) { if ( trim ( $ data ) == '' ) { throw new ReaderException ( 'Parameter data is empty.' ) ; } elseif ( $ pos < 0 ) { throw new ReaderException ( 'Parameter pos=' . $ pos . ' is invalid.' ) ; } $ len = strlen ( $ data ) ; if ( $ len < $ pos + 4 ) { $ data .= str_repeat ( "\0" , $ pos + 4 - $ len ) ; } $ _or_24 = ord ( $ data [ $ pos + 3 ] ) ; if ( $ _or_24 >= 128 ) { $ _ord_24 = - abs ( ( 256 - $ _or_24 ) << 24 ) ; } else { $ _ord_24 = ( $ _or_24 & 127 ) << 24 ; } return ord ( $ data [ $ pos ] ) | ( ord ( $ data [ $ pos + 1 ] ) << 8 ) | ( ord ( $ data [ $ pos + 2 ] ) << 16 ) | $ _ord_24 ; }
2185	public function onInitialize ( InitializeApplicationEvent $ event ) : void { $ this -> installAssets ( $ event ) ; $ this -> installContao ( $ event ) ; $ this -> createSymlinks ( $ event ) ; }
1826	public function mergeRow ( array $ arrData ) { foreach ( $ arrData as $ k => $ v ) { if ( strpos ( $ k , '__' ) !== false ) { continue ; } if ( ! isset ( $ this -> arrModified [ $ k ] ) ) { $ this -> arrData [ $ k ] = $ v ; } } return $ this ; }
552	public function actionFlushAll ( ) { $ caches = $ this -> findCaches ( ) ; $ cachesInfo = [ ] ; if ( empty ( $ caches ) ) { $ this -> notifyNoCachesFound ( ) ; return ExitCode :: OK ; } foreach ( $ caches as $ name => $ class ) { $ cachesInfo [ ] = [ 'name' => $ name , 'class' => $ class , 'is_flushed' => $ this -> canBeFlushed ( $ class ) ? Yii :: $ app -> get ( $ name ) -> flush ( ) : false , ] ; } $ this -> notifyFlushed ( $ cachesInfo ) ; }
8608	public function registerDestination ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_RegisterDestinationInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/RegisterDestinationInput.php' ) ; $ request = new MWSSubscriptionsService_Model_RegisterDestinationInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'RegisterDestination' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/RegisterDestinationResponse.php' ) ; $ response = MWSSubscriptionsService_Model_RegisterDestinationResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6118	public function serverCreate ( array $ properties = array ( ) ) { $ this -> serverListReset ( ) ; $ detail = $ this -> execute ( "servercreate" , $ properties ) -> toList ( ) ; $ server = new Server ( $ this , array ( "virtualserver_id" => intval ( $ detail [ "sid" ] ) ) ) ; Signal :: getInstance ( ) -> emit ( "notifyServercreated" , $ this , $ detail [ "sid" ] ) ; Signal :: getInstance ( ) -> emit ( "notifyTokencreated" , $ server , $ detail [ "token" ] ) ; return $ detail ; }
8207	protected function putJob ( $ tube , $ body , $ priority , $ delay , $ ttr ) { $ id = $ this -> getPheanstalk ( ) -> putInTube ( $ tube , $ body , $ priority , $ delay , $ ttr ) ; return $ id ; }
7786	public function createStatement ( AccountInterface $ account , $ number ) { return $ this -> createObject ( $ this -> statementClass , 'Jejik\MT940\StatementInterface' , array ( $ account , $ number ) ) ; }
9595	public function makeSessionStorage ( ) { $ storage = $ this -> config -> get ( 'session.storage' ) ; if ( $ storage == 'mock_array' ) { return new MockArraySessionStorage ; } if ( $ storage == 'mock_file' ) { return new MockFileSessionStorage ; } $ handler = $ this -> dic -> resolve ( 'SessionHandlerInterface' ) ; if ( $ storage == 'bridge' ) { return new PhpBridgeSessionStorage ( $ handler ) ; } $ options = $ this -> config -> get ( 'session.storage_options' , [ ] ) ; if ( $ storage == 'native' ) { return new NativeSessionStorage ( $ options , $ handler ) ; } if ( ! is_string ( $ storage ) ) { $ storage = gettype ( $ storage ) ; } throw new \ RuntimeException ( "Unknown session storage driver: $storage" ) ; }
7640	public static function isValidContainerName ( $ containerName = '' ) { if ( $ containerName == '$root' ) { return true ; } if ( preg_match ( "/^[a-z0-9][a-z0-9-]*$/" , $ containerName ) === 0 ) { return false ; } if ( strpos ( $ containerName , '--' ) !== false ) { return false ; } if ( strtolower ( $ containerName ) != $ containerName ) { return false ; } if ( strlen ( $ containerName ) < 3 || strlen ( $ containerName ) > 63 ) { return false ; } if ( substr ( $ containerName , - 1 ) == '-' ) { return false ; } return true ; }
4178	public function getFiles ( ) { return $ this -> files ? : $ this -> files = Finder :: create ( ) -> in ( realpath ( $ this -> directory ) ) ; }
602	public function tokenize ( ) { $ this -> length = mb_strlen ( $ this -> sql , 'UTF-8' ) ; $ this -> offset = 0 ; $ this -> _substrings = [ ] ; $ this -> _buffer = '' ; $ this -> _token = new SqlToken ( [ 'type' => SqlToken :: TYPE_CODE , 'content' => $ this -> sql , ] ) ; $ this -> _tokenStack = new \ SplStack ( ) ; $ this -> _tokenStack -> push ( $ this -> _token ) ; $ this -> _token [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_STATEMENT ] ) ; $ this -> _tokenStack -> push ( $ this -> _token [ 0 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; while ( ! $ this -> isEof ( ) ) { if ( $ this -> isWhitespace ( $ length ) || $ this -> isComment ( $ length ) ) { $ this -> addTokenFromBuffer ( ) ; $ this -> advance ( $ length ) ; continue ; } if ( $ this -> tokenizeOperator ( $ length ) || $ this -> tokenizeDelimitedString ( $ length ) ) { $ this -> advance ( $ length ) ; continue ; } $ this -> _buffer .= $ this -> substring ( 1 ) ; $ this -> advance ( 1 ) ; } $ this -> addTokenFromBuffer ( ) ; if ( $ this -> _token -> getHasChildren ( ) && ! $ this -> _token [ - 1 ] -> getHasChildren ( ) ) { unset ( $ this -> _token [ - 1 ] ) ; } return $ this -> _token ; }
7920	private function openZipFile ( $ zipFile ) { $ zipArchive = new \ ZipArchive ; if ( $ zipArchive -> open ( $ zipFile ) !== true ) { throw new \ Exception ( 'Error opening ' . $ zipFile ) ; } return $ zipArchive ; }
6223	public function getMenuPresence ( ) { return [ 'id' => 'simple-acl' , 'type' => MenuPresenceType :: GROUP , 'label' => 'Access Control' , 'children' => [ [ 'id' => 'simple-acl-users' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Users' , 'permissions' => 'acl.users.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.index' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-create-user' , 'type' => MenuPresenceType :: ACTION , 'label' => 'New User' , 'permissions' => 'acl.users.create' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.create' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-roles' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Roles' , 'permissions' => 'acl.roles.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.roles.index' ) , 'parameters' => [ ] , ] , ] ] ; }
8447	public function sendRequest ( $ endpoint , array $ parameters , IncomingMessage $ matchingMessage ) { $ this -> connection -> post ( $ endpoint , $ parameters , true ) ; return Response :: create ( $ this -> connection -> getLastBody ( ) , $ this -> connection -> getLastHttpCode ( ) ) ; }
2535	public function getMessagesAndVersions ( ) { if ( empty ( $ this -> messagesAndVersions ) ) { $ this -> messagesAndVersions = WsdlAnalyser :: loadMessagesAndVersions ( $ this -> params -> wsdl ) ; } return $ this -> messagesAndVersions ; }
12760	public static function dispatch ( $ eventName , Event $ event ) { if ( null === self :: $ dispatcher ) { return $ event ; } self :: $ dispatcher -> dispatch ( $ eventName , $ event ) ; DataLogger :: log ( sprintf ( 'The "%s" event was dispatched' , $ eventName ) ) ; if ( $ event -> getAbort ( ) ) { DataLogger :: log ( sprintf ( 'The "%s" event was aborted' , $ eventName ) , DataLogger :: ERROR ) ; throw new EventAbortedException ( $ event -> getAbortMessage ( ) ) ; } return $ event ; }
2233	public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } $ objSteps = $ this -> Database -> prepare ( "SELECT id FROM tl_undo WHERE pid=?" ) -> execute ( $ this -> User -> id ) ; $ GLOBALS [ 'TL_DCA' ] [ 'tl_undo' ] [ 'list' ] [ 'sorting' ] [ 'root' ] = $ objSteps -> numRows ? $ objSteps -> fetchEach ( 'id' ) : array ( 0 ) ; if ( Contao \ Input :: get ( 'act' ) && ! \ in_array ( Contao \ Input :: get ( 'id' ) , $ GLOBALS [ 'TL_DCA' ] [ 'tl_undo' ] [ 'list' ] [ 'sorting' ] [ 'root' ] ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to ' . Contao \ Input :: get ( 'act' ) . ' undo step ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } }
9644	protected function mapParams ( array $ params ) : array { unset ( $ params [ 0 ] ) ; foreach ( $ params as $ name => $ value ) { if ( ! is_string ( $ name ) ) { unset ( $ params [ $ name ] ) ; } else { $ params [ $ name ] = urldecode ( $ value [ 0 ] ) ; } } return $ params ; }
8150	public function initRuntime ( ) { $ this -> runtimeInitialized = true ; foreach ( $ this -> getExtensions ( ) as $ name => $ extension ) { if ( ! $ extension instanceof Twig_Extension_InitRuntimeInterface ) { $ m = new ReflectionMethod ( $ extension , 'initRuntime' ) ; if ( 'Twig_Extension' !== $ m -> getDeclaringClass ( ) -> getName ( ) ) { @ trigger_error ( sprintf ( 'Defining the initRuntime() method in the "%s" extension is deprecated since version 1.23. Use the `needs_environment` option to get the Twig_Environment instance in filters, functions, or tests; or explicitly implement Twig_Extension_InitRuntimeInterface if needed (not recommended).' , $ name ) , E_USER_DEPRECATED ) ; } } $ extension -> initRuntime ( $ this ) ; } }
5612	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , true ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ current ) { $ current -> putChild ( $ node ) ; } else { echo 'no current node' ; } }
9745	public function setCity ( $ city ) { if ( ! ( $ city instanceof City ) ) { $ city = new City ( $ city ) ; } if ( $ city -> isEmpty ( ) ) { $ this -> invalidArguments ( '10003' ) ; } return $ this -> setParameter ( 'city' , $ city ) ; }
10439	protected function nextBufferLine ( ) { $ query = $ this -> parseQuery ( ) ; if ( ! empty ( $ query ) ) { $ this -> buffer [ $ this -> key ] [ self :: PARAM_QUERY ] = $ query ; } else { $ this -> buffer [ $ this -> key ] = false ; } }
10119	private function writeMarginRight ( ) { $ record = 0x0027 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getRight ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
3210	function disableOAuth1AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; }
11152	public function setParameters ( array $ request ) { foreach ( $ this -> getRequiredParameters ( ) as $ param ) { if ( isset ( $ request [ $ param ] ) ) { $ dynamicMethod = "set" . ucfirst ( $ param ) ; if ( method_exists ( $ this , $ dynamicMethod ) ) { $ this -> $ dynamicMethod ( $ request [ $ param ] ) ; } else { throw new ExtDirectException ( "Method for required parameter '{$param}' not implemented" ) ; } } else { throw new ExtDirectException ( "Required parameter '{$param}' is missing" ) ; } } }
3623	public function temperatureInCelsius ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature - 32 ) / 1.8 ; } return $ temperature ; }
44	public function dispatchScript ( $ eventName , $ devMode = false , $ additionalArgs = array ( ) , $ flags = array ( ) ) { return $ this -> doDispatch ( new Script \ Event ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ additionalArgs , $ flags ) ) ; }
10929	public function getCountOf ( string $ strSQL , ? array $ parans = null ) : int { $ r = $ this -> getDataColumn ( $ strSQL , $ parans , "int" ) ; return ( ( $ r === null ) ? 0 : $ r ) ; }
11401	public function startAt ( $ startAt = 0 ) { if ( ! is_numeric ( $ startAt ) || $ startAt < 0 ) { throw new Exception ( "startAt: bad value" , 10 ) ; } $ this -> startAt = $ startAt ; return $ this ; }
7702	function OpenDoc_GetDraw ( $ Tag , $ Txt , $ Pos , $ Forward , $ LevelStop ) { return $ this -> XML_BlockAlias_Prefix ( 'draw:' , $ Txt , $ Pos , $ Forward , $ LevelStop ) ; }
10250	public function getDln ( $ state_code = null , $ min = 900000001 , $ max = 999999999 ) { $ dln = new Entities \ DriverLicense ( ) ; $ dln -> number = rand ( $ min , $ max ) ; $ dln -> state = ! empty ( $ state_code ) ? $ state_code : $ this -> getState ( ) ; $ dln -> expiration = $ this -> getExpiration ( ) ; return $ dln ; }
2246	public static function isVisibleElement ( Model $ objElement ) { $ blnReturn = true ; if ( TL_MODE == 'FE' ) { if ( $ objElement -> protected ) { if ( ! FE_USER_LOGGED_IN ) { $ blnReturn = false ; } else { $ objUser = FrontendUser :: getInstance ( ) ; if ( ! \ is_array ( $ objUser -> groups ) ) { $ blnReturn = false ; } else { $ groups = StringUtil :: deserialize ( $ objElement -> groups ) ; if ( empty ( $ groups ) || ! \ is_array ( $ groups ) || ! \ count ( array_intersect ( $ groups , $ objUser -> groups ) ) ) { $ blnReturn = false ; } } } } elseif ( $ objElement -> guests && FE_USER_LOGGED_IN ) { $ blnReturn = false ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] as $ callback ) { $ blnReturn = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objElement , $ blnReturn ) ; } } return $ blnReturn ; }
1627	public function useFiles ( $ path , $ level = 'debug' ) { foreach ( $ this -> loggers as $ logger ) { if ( $ logger instanceof Log ) { $ logger -> useFiles ( $ path , $ level ) ; } } }
9180	final public function getViewSettings ( ) { $ rf = new \ ReflectionClass ( $ this ) ; $ this -> viewName = str_replace ( 'View' , '' , $ rf -> getShortName ( ) ) ; $ matches = array ( ) ; if ( preg_match ( "#@applyTo\((.*)\)#" , $ rf -> getDocComment ( ) , $ matches ) ) { $ params = array ( ) ; parse_str ( str_replace ( ',' , '&' , $ matches [ 1 ] ) , $ params ) ; if ( is_array ( $ params ) ) { foreach ( $ params as $ param => $ value ) { if ( $ param == 'controller' ) { $ this -> controllers = explode ( '|' , $ value ) ; } if ( $ param == 'action' ) { $ this -> actions = explode ( '|' , $ value ) ; } } } } return $ this ; }
3057	public function isAdaptive ( AssessmentItemRef $ currentAssessmentItemRef = null ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> isAdaptive ( $ this -> getTestSession ( ) , $ currentAssessmentItemRef ) ; }
33	protected function addReason ( $ id , $ reason ) { if ( ! isset ( $ this -> reasonSeen [ $ id ] ) ) { $ this -> reasonSeen [ $ id ] = true ; $ this -> reasons [ $ this -> section ] [ ] = $ reason ; } }
10802	public function savePageHistoricAction ( ) { $ responseData = $ this -> params ( ) -> fromRoute ( 'datas' , $ this -> params ( ) -> fromQuery ( 'datas' , '' ) ) ; $ idPage = isset ( $ responseData [ 'idPage' ] ) ? $ responseData [ 'idPage' ] : ( ! empty ( $ responseData [ 0 ] [ 'idPage' ] ) ? ( $ responseData [ 0 ] [ 'idPage' ] ) : 0 ) ; $ isNew = isset ( $ responseData [ 'isNew' ] ) ? $ responseData [ 'isNew' ] : ( ! empty ( $ responseData [ 0 ] [ 'isNew' ] ) ? ( $ responseData [ 0 ] [ 'isNew' ] ) : 0 ) ; $ response = array ( 'idPage' => $ idPage , 'isNew' => $ isNew ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_save_start' , $ this , $ response ) ; $ melisCoreAuth = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreAuth' ) ; $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ pageAction = $ this -> params ( ) -> fromRoute ( 'pageActionUsed' , $ this -> params ( ) -> fromQuery ( 'pageActionUsed' , '' ) ) ; $ histDatas = array ( ) ; $ container = new Container ( 'meliscms' ) ; $ datas = array ( ) ; if ( isset ( $ container [ 'action-page-tmp' ] [ 'success' ] ) && $ container [ 'action-page-tmp' ] [ 'success' ] == 0 ) return ; if ( ! empty ( $ container [ 'action-page-tmp' ] ) ) { if ( ! empty ( $ container [ 'action-page-tmp' ] [ 'datas' ] ) ) $ datas = $ container [ 'action-page-tmp' ] [ 'datas' ] ; } $ description = '' ; switch ( $ pageAction ) { case 'Save' : if ( $ isNew ) { $ description = 'tr_melispagehistoric_description_text_new' ; } else { $ description = 'tr_melispagehistoric_description_text_save' ; } break ; case 'Publish' : $ description = 'tr_melispagehistoric_description_text_publish' ; break ; case 'Unpublish' : $ description = 'tr_melispagehistoric_description_text_unpublished' ; break ; } if ( $ idPage ) { $ userId = ( int ) null ; $ userAuthDatas = $ melisCoreAuth -> getStorage ( ) -> read ( ) ; if ( $ userAuthDatas ) $ userId = $ userAuthDatas -> usr_id ; $ histDatas = array ( 'hist_page_id' => $ idPage , 'hist_action' => $ pageAction , 'hist_date' => date ( 'Y-m-d H:i:s' ) , 'hist_user_id' => $ userId , 'hist_description' => $ description ) ; $ melisPageHistoricTable -> save ( $ histDatas ) ; } $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_save_end' , $ this , $ histDatas ) ; }
8949	function constructUrl ( Request $ appRequest , Nette \ Http \ Url $ refUrl ) { return $ this -> getRouter ( ) -> constructUrl ( $ appRequest , $ refUrl ) ; }
370	protected function isEmpty ( $ value ) { return $ value === '' || $ value === [ ] || $ value === null || is_string ( $ value ) && trim ( $ value ) === '' ; }
3095	protected function resolve ( $ data ) { if ( ! isset ( $ data [ 'action' ] ) || ! isset ( $ data [ 'timestamp' ] ) || ! isset ( $ data [ 'parameters' ] ) || ! is_array ( $ data [ 'parameters' ] ) ) { throw new \ common_exception_InconsistentData ( 'Action parameters have to contain "action", "timestamp" and "parameters" fields.' ) ; } $ availableActions = $ this -> getAvailableActions ( ) ; $ actionName = $ data [ 'action' ] ; $ actionClass = null ; if ( isset ( $ availableActions [ $ actionName ] ) ) { $ actionClass = $ availableActions [ $ actionName ] ; } if ( is_null ( $ actionClass ) || ! is_a ( $ actionClass , TestRunnerAction :: class , true ) ) { throw new \ ResolverException ( 'Action name "' . $ actionName . '" could not be resolved.' ) ; } return $ this -> getServiceManager ( ) -> propagate ( new $ actionClass ( $ actionName , $ data [ 'timestamp' ] , $ data [ 'parameters' ] ) ) ; }
1446	protected function dataForUpdate ( $ record , array $ document ) : array { $ resource = $ document [ 'data' ] ?? [ ] ; if ( $ this -> mustValidateExisting ( $ record , $ document ) ) { $ resource [ 'attributes' ] = $ this -> extractAttributes ( $ record , $ resource [ 'attributes' ] ?? [ ] ) ; $ resource [ 'relationships' ] = $ this -> extractRelationships ( $ record , $ resource [ 'relationships' ] ?? [ ] ) ; } return $ resource ; }
8874	public function addAttachment ( $ attachment ) { if ( ! file_exists ( $ attachment ) ) { pines_error ( 'Invalid attachment.' ) ; return false ; } $ this -> attachments [ ] = $ attachment ; return true ; }
1713	protected function executePostActionsHook ( DataContainer $ dc ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> strAction , $ dc ) ; } } }
10306	public function setLineStyleProperties ( $ line_width = null , $ compound_type = null , $ dash_type = null , $ cap_type = null , $ join_type = null , $ head_arrow_type = null , $ head_arrow_size = null , $ end_arrow_type = null , $ end_arrow_size = null ) { ( $ line_width !== null ) ? $ this -> lineStyleProperties [ 'width' ] = $ this -> getExcelPointsWidth ( ( float ) $ line_width ) : null ; ( $ compound_type !== null ) ? $ this -> lineStyleProperties [ 'compound' ] = ( string ) $ compound_type : null ; ( $ dash_type !== null ) ? $ this -> lineStyleProperties [ 'dash' ] = ( string ) $ dash_type : null ; ( $ cap_type !== null ) ? $ this -> lineStyleProperties [ 'cap' ] = ( string ) $ cap_type : null ; ( $ join_type !== null ) ? $ this -> lineStyleProperties [ 'join' ] = ( string ) $ join_type : null ; ( $ head_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'type' ] = ( string ) $ head_arrow_type : null ; ( $ head_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'size' ] = ( string ) $ head_arrow_size : null ; ( $ end_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'type' ] = ( string ) $ end_arrow_type : null ; ( $ end_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'size' ] = ( string ) $ end_arrow_size : null ; }
12247	public function getNodeByName ( $ strXpath , $ strName ) { $ varResult = $ this -> xpath ( $ strXpath . "[@name='" . $ strName . "']" ) ; if ( $ varResult !== false ) { return reset ( $ varResult ) ; } else { return false ; } }
9185	protected function toArray ( $ data , $ type , $ format ) { $ serializer = SerializerBuilder :: create ( ) -> build ( ) ; return $ serializer -> toArray ( $ serializer -> deserialize ( $ data , $ type , $ format ) ) ; }
3790	private function determineLanguages ( ) { $ languages = $ this -> getMetaModel ( ) -> getAvailableLanguages ( ) ; if ( $ languages === null ) { throw new \ RuntimeException ( 'MetaModel ' . $ this -> getMetaModel ( ) -> getName ( ) . ' does not seem to be translated.' ) ; } return $ languages ; }
10673	protected function _getCached ( $ key , $ default = null , $ ttl = null ) { try { return $ this -> _get ( $ key ) ; } catch ( NotFoundExceptionInterface $ e ) { if ( is_callable ( $ default ) ) { try { $ args = $ this -> _normalizeArray ( $ this -> _getGeneratorArgs ( $ key , $ default , $ ttl ) ) ; $ default = $ this -> _invokeCallable ( $ default , $ args ) ; } catch ( RootException $ e ) { throw $ this -> _createRuntimeException ( $ this -> __ ( 'Could not generate value' ) , null , $ e ) ; } } $ this -> _set ( $ key , $ default , $ ttl ) ; return $ default ; } }
7649	public function stream_flush ( ) { $ result = fflush ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } return $ result ; }
8249	protected function needsPasswordRehash ( array $ userData ) { if ( $ this -> config [ "login" ] [ "passwordRehash" ] !== true ) { return false ; } if ( isset ( $ userData [ 'encoder' ] ) && $ userData [ 'encoder' ] !== $ this -> config [ "encoder" ] ) { return true ; } $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; return $ encoder -> needsRehash ( $ userData [ 'pwhash' ] ) ; }
5605	public function paintMethodEnd ( $ method ) { if ( $ this -> fail || $ this -> error || ! $ this -> pass ) { } else { $ this -> listener -> write ( '{status:"pass",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
4987	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( $ spec instanceof FormParentInterface ) { $ spec -> setParent ( $ this ) ; } $ spec = [ '__instance__' => $ spec , 'name' => $ key , 'entity' => '*' ] ; } if ( ! is_array ( $ spec ) ) { $ spec = array ( 'type' => $ spec , 'name' => $ key ) ; } if ( ! isset ( $ spec [ 'name' ] ) ) { $ spec [ 'name' ] = $ key ; } if ( ! isset ( $ spec [ 'entity' ] ) ) { $ spec [ 'entity' ] = '*' ; } $ this -> forms [ $ key ] = $ spec ; if ( $ enabled ) { $ this -> enableForm ( $ key ) ; } elseif ( true === $ this -> activeForms ) { $ this -> activeForms = false ; } return $ this ; }
4484	protected function registerSignalHandler ( WorkerInterface $ worker ) : void { $ this -> logger -> info ( 'Register a signal handler that a worker should respond to' ) ; SignalHandler :: create ( SignalHandler :: KNOWN_SIGNALS , function ( int $ signal , string $ signalName ) use ( $ worker ) { $ this -> logger -> info ( '{type}: Was received recognized signal {signal}' , [ 'type' => $ worker -> getName ( ) , 'signal' => $ signalName , ] ) ; switch ( $ signal ) { case SIGTERM : $ worker -> shutDownNow ( ) ; break ; case SIGINT : $ worker -> shutDownNow ( ) ; break ; case SIGQUIT : $ worker -> shutdown ( ) ; break ; case SIGUSR1 : $ worker -> killChildren ( ) ; break ; case SIGUSR2 : $ worker -> pauseProcessing ( ) ; break ; case SIGCONT : $ worker -> unPauseProcessing ( ) ; break ; } } ) ; }
7880	protected function registerLogViewerController ( ) { $ this -> app -> bind ( LogViewerController :: class , function ( $ app ) { $ perPage = $ app [ 'config' ] [ 'logviewer.per_page' ] ; $ middleware = $ app [ 'config' ] [ 'logviewer.middleware' ] ; return new LogViewerController ( $ perPage , $ middleware ) ; } ) ; }
365	public function renderColumnGroup ( ) { foreach ( $ this -> columns as $ column ) { if ( ! empty ( $ column -> options ) ) { $ cols = [ ] ; foreach ( $ this -> columns as $ col ) { $ cols [ ] = Html :: tag ( 'col' , '' , $ col -> options ) ; } return Html :: tag ( 'colgroup' , implode ( "\n" , $ cols ) ) ; } } return false ; }
11110	private function findExtensionsDirectories ( Container $ app ) { $ directories = $ app [ 'config.finder' ] -> ignoreUnreadableDirs ( ) -> directories ( ) -> name ( '*Extension' ) -> in ( $ app [ 'app.extensions.dir' ] ) -> depth ( '< 3' ) -> sortByName ( ) ; return $ directories ; }
10575	public static function apply ( $ text , $ foreground = '' , $ background = '' ) { try { $ style = new OutputFormatterStyle ( ) ; if ( $ foreground != '' ) { $ style -> setForeground ( $ foreground ) ; } if ( $ background != '' ) { $ style -> setBackground ( $ background ) ; } return $ style -> apply ( $ text ) ; } catch ( \ Exception $ e ) { return $ text ; } }
8415	public function beginTransaction ( ) : bool { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } ++ $ this -> transactionLevel ; if ( $ this -> transactionLevel == 1 ) { return $ this -> providerDatabase -> beginTransaction ( $ this -> GetMasterLink ( ) ) ; } return $ this -> providerDatabase -> savePoint ( $ this -> GetMasterLink ( ) , 'LEVEL' . ( $ this -> transactionLevel - 1 ) ) ; }
11223	private static function checkRegexRoutes ( ) { $ pos = 0 ; self :: getRegexRoutes ( ) ; $ method = $ _SERVER [ 'REQUEST_METHOD' ] ; $ searches = array_keys ( self :: $ patterns ) ; $ replaces = array_values ( self :: $ patterns ) ; foreach ( self :: $ routes as $ route ) { $ segments = explode ( '/' , str_replace ( $ searches , '' , $ route ) ) ; $ route = str_replace ( $ searches , $ replaces , $ route ) ; $ route = Url :: addBackSlash ( $ route ) ; if ( preg_match ( '#^' . $ route . '$#' , self :: $ uri , $ matched ) ) { $ methodRoute = self :: $ methods [ $ pos ] ; if ( $ methodRoute == $ method || $ methodRoute == 'ANY' ) { $ matched = explode ( '/' , trim ( $ matched [ 0 ] , '/' ) ) ; $ matched = array_diff ( $ matched , $ segments ) ; if ( ! is_object ( self :: $ callbacks [ $ pos ] ) ) { self :: $ response = self :: invokeObject ( self :: $ callbacks [ $ pos ] , $ matched ) ; } else { self :: $ response = call_user_func_array ( self :: $ callbacks [ $ pos ] , $ matched ) ; } if ( ! self :: $ halts ) { return self :: $ response ; } self :: $ halts -- ; } } $ pos ++ ; } return self :: $ response ; }
11119	protected function runUp ( array $ file , int $ batch ) : void { $ this -> notify -> note ( "<comment>Migrating:</comment> {$file['basename']}" ) ; $ this -> runMigration ( $ file ) ; $ this -> repository -> log ( $ this -> getMigrationName ( $ file ) , $ batch ) ; $ this -> notify -> note ( "<info>Migrated:</info> {$file['basename']}" ) ; }
2059	public function generateSitemap ( ) { $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; if ( empty ( $ session ) || ! \ is_array ( $ session ) ) { return ; } $ this -> import ( 'Contao\Automator' , 'Automator' ) ; foreach ( $ session as $ id ) { $ this -> Automator -> generateSitemap ( $ id ) ; } $ objSession -> set ( 'sitemap_updater' , null ) ; }
209	protected function formatScalarValue ( $ value ) { if ( $ value === true ) { return 'true' ; } if ( $ value === false ) { return 'false' ; } if ( is_float ( $ value ) ) { return StringHelper :: floatToString ( $ value ) ; } return ( string ) $ value ; }
297	public function getDirtyAttributes ( $ names = null ) { if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } $ names = array_flip ( $ names ) ; $ attributes = [ ] ; if ( $ this -> _oldAttributes === null ) { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } else { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _oldAttributes ) || $ value !== $ this -> _oldAttributes [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } return $ attributes ; }
10277	public static function getDefaultRowHeightByFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { switch ( $ font -> getName ( ) ) { case 'Arial' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; case 'Calibri' : switch ( $ font -> getSize ( ) ) { case 11 : $ rowHeight = 15 ; break ; case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6.00 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } break ; case 'Verdana' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 11.25 ; break ; case 8 : $ rowHeight = 10.50 ; break ; case 7 : $ rowHeight = 9.00 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } return $ rowHeight ; }
3686	protected function getAndOrFilter ( IFilter $ filter , $ operation ) { if ( ! $ operation [ 'children' ] ) { return ; } if ( $ operation [ 'operation' ] == 'AND' ) { $ filterRule = new ConditionAnd ( ) ; } else { $ filterRule = new ConditionOr ( ) ; } $ filter -> addFilterRule ( $ filterRule ) ; $ children = $ this -> optimizedFilter ( $ filterRule , $ operation [ 'children' ] , $ operation [ 'operation' ] ) ; foreach ( $ children as $ child ) { $ subFilter = $ this -> getMetaModel ( ) -> getEmptyFilter ( ) ; $ filterRule -> addChild ( $ subFilter ) ; $ this -> calculateSubfilter ( $ child , $ subFilter ) ; } }
4703	protected function lint ( OutputInterface $ output , Ciconia $ ciconia , $ content ) { try { $ ciconia -> render ( $ content , array ( 'strict' => true ) ) ; $ output -> writeln ( 'No syntax errors detected.' ) ; return 0 ; } catch ( SyntaxError $ e ) { $ output -> writeln ( '<error>' . $ e -> getMessage ( ) . '</error>' ) ; return 1 ; } }
1574	public function defaultApi ( $ apiName = null ) { if ( is_null ( $ apiName ) ) { return LaravelJsonApi :: $ defaultApi ; } LaravelJsonApi :: defaultApi ( $ apiName ) ; return $ apiName ; }
12031	function addCreateAndExecuteMethod ( ) { $ methodGenerator = new MethodGenerator ( 'createAndExecute' ) ; $ body = '' ; $ body .= $ this -> generateCreateFragment ( ) ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= PHP_EOL ; $ body .= 'return $response;' . PHP_EOL ; ; $ docBlock = new DocBlockGenerator ( 'Create and execute the operation, returning the raw response from the server.' , null ) ; $ tags [ ] = new GenericTag ( 'return' , '\Amp\Artax\Response' ) ; $ docBlock -> setTags ( $ tags ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
10612	public function confirmedAction ( ) { $ user = $ this -> getUser ( ) ; if ( ! is_object ( $ user ) || ! $ user instanceof UserInterface ) { throw $ this -> createAccessDeniedException ( 'This user does not have access to this section.' ) ; } return $ this -> render ( "@MikyUser/Frontend/Registration/confirmed.html.twig" , array ( 'user' => $ user , ) ) ; }
5771	public function hasOneRole ( array $ roleIds ) : bool { foreach ( $ roleIds as $ roleId ) { if ( $ this -> hasRole ( ( int ) $ roleId ) ) { return true ; } } return false ; }
4917	public function setParams ( array $ params ) { foreach ( $ params as $ key => $ value ) { $ this -> setParam ( $ key , $ value ) ; } return $ this ; }
10645	public function bindInstance ( object $ object ) : Binding { return $ this -> bind ( \ get_class ( $ object ) ) -> instance ( $ object ) ; }
11956	function addQueue ( $ channel , $ queue , $ weight = 1 ) { $ orig = $ channel ; $ channel = $ this -> _normalizeQueueName ( $ channel ) ; if ( ! $ queue instanceof iQueueDriver ) throw new \ Exception ( sprintf ( 'Queue must be instance of iQueueDriver; given: (%s).' , \ Poirot \ Std \ flatten ( $ queue ) ) ) ; if ( isset ( $ this -> channels_queue [ $ channel ] ) ) throw new \ RuntimeException ( sprintf ( 'Channel (%s) is currently filled with (%s) and is not empty.' , $ orig , get_class ( $ this -> channels_queue [ $ channel ] ) ) ) ; $ this -> channels_queue [ $ channel ] = $ queue ; $ this -> channels_weight [ $ channel ] = $ weight ; return $ this ; }
8528	public function listFinancialEventGroupsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroupsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3477	public function withLocalizedTitle ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> title = '' ; $ cloned -> titleLocalized = $ localized ; return $ cloned ; }
11069	protected function getStatusData ( $ identifier ) { foreach ( $ this -> options [ 'statuses' ] as $ status ) { if ( ( int ) $ status [ 'id' ] === ( int ) $ identifier ) { return $ status ; } } return null ; }
12377	public function superadmin ( User $ account , Container $ application , Database $ database ) { $ config = $ this -> config ; $ username = $ application -> input -> getString ( "user_first_name" , "" , "post" , FALSE , array ( ) ) ; $ usernameid = $ application -> input -> getString ( "user_name_id" , "" , "post" , FALSE , array ( ) ) ; $ userpass = $ application -> input -> getString ( "user_password" , "" , "post" , FALSE , array ( ) ) ; $ userpass2 = $ application -> input -> getString ( "user_password_2" , "" , "post" , FALSE , array ( ) ) ; $ useremail = $ application -> input -> getString ( "user_email" , "" , "post" , FALSE , array ( ) ) ; if ( empty ( $ userpass ) || empty ( $ username ) || empty ( $ usernameid ) || empty ( $ useremail ) ) { throw new Exception ( t ( 'Please provide at least a Name, Username, E-mail and Password' ) ) ; return false ; } if ( $ userpass <> $ userpass2 ) { throw new Exception ( t ( 'The user passwords do not match' ) ) ; return false ; } if ( ! $ account -> store ( $ application -> input -> data ( "post" ) , true ) ) { throw new Exception ( t ( 'Could not store the admin user account' ) ) ; return false ; } $ adminAuthority = $ this -> config -> get ( "setup.site.superadmin-authority" , NULL ) ; if ( ! empty ( $ adminAuthority ) ) { $ query = "INSERT INTO ?objects_authority( authority_id, object_id ) SELECT {$database->quote((int)$adminAuthority)}, object_id FROM ?objects WHERE object_uri={$database->quote($usernameid)}" ; $ database -> exec ( $ query ) ; } $ config -> set ( "setup.session.store" , "database" ) ; $ config -> set ( "setup.database.installed" , TRUE ) ; if ( ! $ config -> saveParams ( ) ) { throw new Exception ( "could not save config" ) ; return false ; } return true ; }
12734	public function unregister ( Listener $ register ) { $ id = $ register -> id ; $ success = false ; if ( isset ( $ this -> _byId [ $ id ] ) ) { unset ( $ this -> _byId [ $ id ] ) ; $ success = true ; } foreach ( $ this -> _bySignal as $ signal => $ reg ) { if ( isset ( $ reg [ $ id ] ) ) { unset ( $ this -> _bySignal [ $ signal ] [ $ id ] ) ; } } return $ success ; }
4453	public function isPaused ( ) : bool { $ stat = json_decode ( $ this -> client -> queues ( $ this -> name ) , true ) ; return isset ( $ stat [ 'name' ] ) && $ stat [ 'name' ] === $ this -> name && $ stat [ 'paused' ] == true ; }
10399	protected function start ( InputInterface $ input , OutputInterface $ output , $ serviceClass , $ prefix ) { $ benchmark = new CommandBenchmark ( $ output ) ; $ benchmark -> start ( ) ; $ service = $ this -> getContainer ( ) -> get ( $ serviceClass ) ; $ factory = $ service -> getPipelineFactory ( ) ; $ factory -> setProgressBar ( new ProgressBar ( $ output ) ) ; $ service -> startPipeline ( $ prefix , $ input -> getArgument ( 'target' ) ) ; $ benchmark -> finish ( ) ; }
1594	protected function validateType ( ) : bool { if ( ! $ this -> dataHas ( 'type' ) ) { $ this -> memberRequired ( '/data' , 'type' ) ; return false ; } $ value = $ this -> dataGet ( 'type' ) ; if ( ! $ this -> validateTypeMember ( $ value , '/data' ) ) { return false ; } if ( $ this -> expectedType !== $ value ) { $ this -> resourceTypeNotSupported ( $ value ) ; return false ; } return true ; }
8488	public static function getLoad ( ) { $ wmi = Windows :: getInstance ( ) ; $ load = [ ] ; foreach ( $ wmi -> ExecQuery ( "SELECT LoadPercentage FROM Win32_Processor" ) as $ cpu ) { $ load [ ] = $ cpu -> LoadPercentage ; } return round ( array_sum ( $ load ) / count ( $ load ) , 2 ) . "%" ; }
3765	private function mapTranslations ( $ array , $ domain , StaticTranslator $ translator , $ baseKey = '' ) { foreach ( $ array as $ key => $ value ) { $ newKey = ( $ baseKey ? $ baseKey . '.' : '' ) . $ key ; if ( is_array ( $ value ) ) { $ this -> mapTranslations ( $ value , $ domain , $ translator , $ newKey ) ; } else { $ translator -> setValue ( $ newKey , $ value , $ domain ) ; } } }
11288	protected function _getRelation ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = false ; if ( isset ( $ def [ 'models' ] ) ) { $ result = $ this -> _getModels ( $ attributeName , $ def [ 'models' ] , $ query , $ loadMap , $ record ) ; } else if ( isset ( $ def [ 'model' ] ) ) { $ result = $ this -> _getModel ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap , $ record ) ; } return $ result ; }
12029	function generateParamFilterBlock ( \ ArtaxServiceBuilder \ Parameter $ parameter ) { $ i1 = ' ' ; $ i2 = ' ' ; $ text = '' ; $ text .= sprintf ( $ i1 . "case ('%s'): {" . PHP_EOL , $ parameter -> getName ( ) ) ; foreach ( $ parameter -> getFilters ( ) as $ filter ) { if ( is_array ( $ filter ) ) { $ text .= $ i2 . '$args = [];' . PHP_EOL ; if ( isset ( $ filter [ 'args' ] ) == true ) { if ( is_array ( $ filter [ 'args' ] ) == false ) { throw new \ ArtaxServiceBuilder \ APIBuilderException ( "Filter args should be an array instead received " . var_export ( $ filter [ 'args' ] , true ) ) ; } foreach ( $ filter [ 'args' ] as $ data ) { if ( $ data == '@value' ) { $ text .= $ i2 . '$args[] = $value;' . PHP_EOL ; } elseif ( $ data == '@api' ) { $ text .= $ i2 . "\$args[] = \$this->\$api;" . PHP_EOL ; } else { $ text .= $ i2 . "\$args[] = $data;" . PHP_EOL ; } } } $ text .= sprintf ( $ i2 . '$value = call_user_func_array([$value, \'%s\'], $args);' . PHP_EOL , $ filter [ 'method' ] ) ; } else { $ text .= sprintf ( $ i2 . 'call_user_func(\'%s\', $value);' . PHP_EOL , $ filter ) ; } } $ text .= $ i1 . ' break;' . PHP_EOL ; $ text .= $ i1 . '}' . PHP_EOL ; return $ text ; }
7800	protected function splitStatements ( $ text ) { $ chunks = preg_split ( '/^:20:/m' , $ text , - 1 ) ; $ chunks = array_filter ( array_map ( 'trim' , array_slice ( $ chunks , 1 ) ) ) ; return array_map ( function ( $ statement ) { return ':20:' . $ statement ; } , $ chunks ) ; }
6183	public function add ( $ type , $ message , $ redirect = null ) { if ( ! isset ( $ type ) or ! isset ( $ message [ 0 ] ) ) { return false ; } if ( strlen ( trim ( $ type ) ) === 1 ) { $ type = str_replace ( [ 'h' , 'i' , 'w' , 'e' , 's' ] , [ 'help' , 'info' , 'warning' , 'error' , 'success' ] , $ type ) ; } $ router = new Router ( ) ; try { if ( ! in_array ( $ type , $ this -> msgTypes ) ) { throw new BaseException ( '"' . strip_tags ( $ type ) . '" is not a valid message type!' , 501 ) ; } } catch ( BaseException $ e ) { $ msg = null ; if ( ini_get ( 'display_errors' ) === "on" ) { $ msg .= '<pre>' ; $ msg .= 'Message: <b>' . $ e -> getMessage ( ) . '</b><br><br>' ; $ msg .= 'Accept: ' . $ _SERVER [ 'HTTP_ACCEPT' ] . '<br>' ; if ( isset ( $ _SERVER [ 'HTTP_REFERER' ] ) ) { $ msg .= 'Referer: ' . $ _SERVER [ 'HTTP_REFERER' ] . '<br><br>' ; } $ msg .= 'Request Method: ' . $ _SERVER [ 'REQUEST_METHOD' ] . '<br><br>' ; $ msg .= 'Current file Path: <b>' . $ this -> router -> currentPath ( ) . '</b><br>' ; $ msg .= 'File Exception: ' . $ e -> getFile ( ) . ':' . $ e -> getLine ( ) . '<br><br>' ; $ msg .= 'Trace: <br>' . $ e -> getTraceAsString ( ) . '<br>' ; $ msg .= '</pre>' ; return Response :: create ( $ msg ) -> display ( ) ; } return Response :: create ( $ e -> getMessage ( ) ) -> status ( 501 ) -> display ( ) ; } $ get = $ this -> driver -> get ( 'flash_messages' ) ; $ get [ $ type ] [ ] = $ message ; $ this -> driver -> set ( 'flash_messages' , $ get ) ; if ( ! is_null ( $ redirect ) ) { return $ router -> redirect ( $ redirect , 301 ) ; } return true ; }
7202	public function getGross ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> gross ) : $ this -> gross ; }
4296	public function assert ( $ assertion , $ msg = null ) { array ( $ msg ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args ) ; $ assertion = \ array_shift ( $ args ) ; if ( ! $ assertion ) { if ( ! $ args ) { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ args [ ] = 'Assertion failed in ' . $ callerInfo [ 'file' ] . ' on line ' . $ callerInfo [ 'line' ] ; } $ this -> appendLog ( 'assert' , $ args , $ meta ) ; } }
7246	private function hasStockableSubject ( Common \ SaleItemInterface $ saleItem ) { if ( ! $ saleItem instanceof Stock \ StockAssignmentsInterface ) { return false ; } if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ saleItem ) ) { return false ; } if ( ! $ subject instanceof Stock \ StockSubjectInterface ) { return false ; } if ( $ subject -> isStockCompound ( ) ) { return false ; } if ( $ subject -> getStockMode ( ) === Stock \ StockSubjectModes :: MODE_DISABLED ) { return false ; } return true ; }
3098	public function getStateMessage ( $ testSession ) { if ( $ testSession instanceof AssessmentTestSession ) { switch ( $ testSession -> getState ( ) ) { case AssessmentTestSessionState :: SUSPENDED : return $ this -> getPausedStateMessage ( $ testSession ) ; case AssessmentTestSessionState :: CLOSED : return $ this -> getTerminatedStateMessage ( $ testSession ) ; case AssessmentTestSessionState :: INITIAL : return $ this -> getInitialStateMessage ( $ testSession ) ; default : return $ this -> getRunningStateMessages ( $ testSession ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerMessageService' , 'getStateMessage' , 0 , 'qtism\runtime\tests\AssessmentTestSession' , $ testSession ) ; } }
12396	public function where ( $ field , $ operator = null , $ value = null , $ logical = '&&' ) { if ( $ field instanceof Closure ) { $ this -> scope -> where .= $ this -> scope -> where == '' ? ' (' : $ logical . ' (' ; call_user_func ( $ field , $ this ) ; $ this -> scope -> where .= ') ' ; } else { $ logical = ( strlen ( $ this -> scope -> where ) <= 1 || substr ( $ this -> scope -> where , - 1 ) == '(' ) ? '' : $ logical ; $ this -> scope -> where .= Parser :: where ( $ field , $ operator , $ value , $ logical ) ; } return $ this ; }
5845	public function execute ( ) { $ configuration = ConfigurationController :: readConfiguration ( ) ; $ this -> imageResizer = GeneralUtility :: makeInstance ( \ Causal \ ImageAutoresize \ Service \ ImageResizer :: class ) ; $ this -> imageResizer -> initializeRulesets ( $ configuration ) ; if ( empty ( $ this -> directories ) ) { $ directories = $ this -> imageResizer -> getAllDirectories ( ) ; } else { $ directories = GeneralUtility :: trimExplode ( LF , $ this -> directories , true ) ; } $ processedDirectories = [ ] ; $ expandedDirectories = [ ] ; foreach ( $ directories as $ directory ) { if ( ( $ pos = strpos ( $ directory , '/*' ) ) !== false ) { $ pattern = $ this -> imageResizer -> getDirectoryPattern ( $ directory ) ; $ basePath = substr ( $ directory , 0 , $ pos + 1 ) ; $ objects = new \ RecursiveIteratorIterator ( new \ RecursiveDirectoryIterator ( PATH_site . $ basePath ) , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ objects as $ name => $ object ) { $ relativePath = substr ( $ name , strlen ( PATH_site ) ) ; if ( substr ( $ relativePath , - 2 ) === DIRECTORY_SEPARATOR . '.' ) { if ( preg_match ( $ pattern , $ relativePath ) ) { $ expandedDirectories [ ] = substr ( $ relativePath , 0 , - 1 ) ; } } } } else { $ expandedDirectories [ ] = $ directory ; } } $ directories = $ expandedDirectories ; $ success = true ; foreach ( $ directories as $ directory ) { $ skip = false ; foreach ( $ processedDirectories as $ processedDirectory ) { if ( GeneralUtility :: isFirstPartOfStr ( $ directory , $ processedDirectory ) ) { continue 2 ; } } $ success |= $ this -> batchResizePictures ( $ directory ) ; $ processedDirectories [ ] = $ directory ; } return $ success ; }
2222	public static function countPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
893	private function getTypesContent ( ) { if ( null === $ this -> typesContent ) { $ name = $ this -> getTag ( ) -> getName ( ) ; if ( ! $ this -> supportTypes ( ) ) { throw new \ RuntimeException ( 'This tag does not support types.' ) ; } $ matchingResult = Preg :: match ( '{^(?:\s*\*|/\*\*)\s*@' . $ name . '\s+' . self :: REGEX_TYPES . '(?:[ \t].*)?$}sx' , $ this -> lines [ 0 ] -> getContent ( ) , $ matches ) ; $ this -> typesContent = 1 === $ matchingResult ? $ matches [ 'types' ] : '' ; } return $ this -> typesContent ; }
4945	public function revoke ( $ resource , $ permission = null , $ build = true ) { if ( self :: PERMISSION_NONE == $ permission || ! $ this -> isAssigned ( $ resource ) ) { return $ this ; } if ( self :: PERMISSION_CHANGE == $ permission ) { return $ this -> grant ( $ resource , self :: PERMISSION_VIEW , $ build ) ; } return $ this -> grant ( $ resource , self :: PERMISSION_NONE , $ build ) ; }
219	public function asBoolean ( $ value ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return $ value ? $ this -> booleanFormat [ 1 ] : $ this -> booleanFormat [ 0 ] ; }
8015	protected function execute ( Command $ command ) { $ command -> setJar ( $ this -> getPathToPdfBox ( ) ) ; $ command -> setOptions ( $ this -> _options ) ; exec ( ( string ) $ command . ' 2>&1' , $ stdErr , $ exitCode ) ; if ( $ command -> getPdfFileIsTemp ( ) ) { unlink ( $ command -> getPdfFile ( ) ) ; } if ( $ exitCode > 0 ) { throw new \ RuntimeException ( join ( "\n" , $ stdErr ) , $ exitCode ) ; } $ resultFile = $ command -> getTextFile ( ) ; $ result = file_get_contents ( $ resultFile ) ; if ( $ command -> getTextFileIsTemp ( ) ) { unlink ( $ resultFile ) ; } return $ result ; }
9973	public function setFormatCode ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: FORMAT_GENERAL ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'formatCode' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> formatCode = $ pValue ; $ this -> builtInFormatCode = self :: builtInFormatCodeIndex ( $ pValue ) ; } return $ this ; }
11240	public function def ( $ checkName , $ class , $ method , $ errorMessage , $ passing = true , $ arguments = false ) { $ this -> customChecks -> $ checkName = [ '_call' , $ class , $ method , $ passing , $ arguments ] ; $ this -> lang -> $ checkName = $ errorMessage ; }
5963	public function serverGroupGetProfiles ( ) { $ profiles = array ( ) ; foreach ( $ this -> serverGroupList ( ) as $ sgid => $ sgroup ) { if ( $ sgroup [ "type" ] != TeamSpeak3 :: GROUP_DBTYPE_REGULAR ) { continue ; } $ profiles [ $ sgid ] = array ( "b_permission_modify_power_ignore" => 0 , "i_group_needed_member_add_power" => 0 , "i_group_member_add_power" => 0 , "i_group_needed_member_remove_power" => 0 , "i_group_member_remove_power" => 0 , "i_needed_modify_power_count" => 0 , "i_needed_modify_power_total" => 0 , "i_permission_modify_power" => 0 , "i_group_needed_modify_power" => 0 , "i_group_modify_power" => 0 , "i_client_needed_modify_power" => 0 , "i_client_modify_power" => 0 , "b_virtualserver_servergroup_create" => 0 , "b_virtualserver_servergroup_delete" => 0 , "b_client_ignore_bans" => 0 , "b_client_ignore_antiflood" => 0 , "b_group_is_permanent" => 0 , "i_client_needed_ban_power" => 0 , "i_client_needed_kick_power" => 0 , "i_client_needed_move_power" => 0 , "i_client_talk_power" => 0 , "__sgid" => $ sgid , "__name" => $ sgroup -> toString ( ) , "__node" => $ sgroup , ) ; try { $ perms = $ this -> serverGroupPermList ( $ sgid , true ) ; $ grant = isset ( $ perms [ "i_permission_modify_power" ] ) ? $ perms [ "i_permission_modify_power" ] [ "permvalue" ] : null ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0x501 ) { throw $ e ; } $ perms = array ( ) ; $ grant = null ; } foreach ( $ perms as $ permsid => $ perm ) { if ( in_array ( $ permsid , array_keys ( $ profiles [ $ sgid ] ) ) ) { $ profiles [ $ sgid ] [ $ permsid ] = $ perm [ "permvalue" ] ; } elseif ( StringHelper :: factory ( $ permsid ) -> startsWith ( "i_needed_modify_power_" ) ) { if ( ! $ grant || $ perm [ "permvalue" ] > $ grant ) { continue ; } $ profiles [ $ sgid ] [ "i_needed_modify_power_total" ] = $ profiles [ $ sgid ] [ "i_needed_modify_power_total" ] + $ perm [ "permvalue" ] ; $ profiles [ $ sgid ] [ "i_needed_modify_power_count" ] ++ ; } } } array_multisort ( $ profiles , SORT_DESC ) ; return $ profiles ; }
3179	public function getQtiItems ( \ core_kernel_classes_Class $ itemClass , $ format = 'list' , $ search = '' , $ offset = 0 , $ limit = 30 ) { $ propertyFilters = [ ] ; if ( $ this -> hasOption ( self :: ITEM_MODEL_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_MODEL_URI ] = $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) ; } if ( $ this -> hasOption ( self :: ITEM_CONTENT_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_CONTENT_URI ] = '*' ; } if ( is_string ( $ search ) && strlen ( trim ( $ search ) ) > 0 ) { $ propertyFilters [ self :: LABEL_URI ] = $ search ; } if ( is_array ( $ search ) ) { foreach ( $ search as $ uri => $ value ) { if ( is_string ( $ uri ) && ( is_string ( $ value ) && strlen ( trim ( $ value ) ) > 0 ) || ( is_array ( $ value ) && count ( $ value ) > 0 ) ) { $ propertyFilters [ $ uri ] = $ value ; } } } $ result = [ ] ; if ( in_array ( $ format , self :: $ formats ) ) { $ itemLookup = $ this -> getServiceLocator ( ) -> get ( self :: SERVICE_ID . '/' . $ format ) ; if ( ! is_null ( $ itemLookup ) && $ itemLookup instanceof ItemLookup ) { $ result = $ itemLookup -> getItems ( $ itemClass , $ propertyFilters , $ offset , $ limit ) ; } } return $ result ; }
2365	public static function prepareSlug ( $ strSlug ) { $ strSlug = static :: stripInsertTags ( $ strSlug ) ; $ strSlug = static :: restoreBasicEntities ( $ strSlug ) ; $ strSlug = static :: decodeEntities ( $ strSlug ) ; return $ strSlug ; }
5381	public function getValue ( ) { if ( $ this -> choice === false ) { return $ this -> getDefault ( ) ; } return $ this -> options [ $ this -> choice ] -> getValue ( ) ; }
6169	protected function writeException ( $ exception ) { $ this -> writeNewLine ( ) ; do { $ exceptionStack [ ] = $ exception ; } while ( $ exception = $ exception -> getPreviousWrapped ( ) ) ; foreach ( explode ( "\n" , $ exception = array_shift ( $ exceptionStack ) ) as $ line ) { if ( $ exception && false !== $ pos = strpos ( $ line , $ exception -> getClassName ( ) . ': ' ) ) { $ whitespace = str_repeat ( ' ' , ( $ pos += strlen ( $ exception -> getClassName ( ) ) ) + 2 ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , sprintf ( ' %s ' , substr ( $ line , 0 , $ pos ) ) , false ) ; $ this -> writeWithColor ( 'fg-red' , substr ( $ line , $ pos + 1 ) ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ exception = array_shift ( $ exceptionStack ) ; continue ; } $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
9561	protected function makeResponse ( $ response , Exception $ exception ) { if ( ! $ response instanceof Response ) { $ response = new Response ( $ response ) ; } if ( ! $ response -> isClientError ( ) && ! $ response -> isServerError ( ) && ! $ response -> isRedirect ( ) ) { if ( $ exception instanceof HttpExceptionInterface ) { $ response -> setStatusCode ( $ exception -> getStatusCode ( ) ) ; $ response -> headers -> add ( $ exception -> getHeaders ( ) ) ; } else { $ response -> setStatusCode ( 500 ) ; } } return $ response ; }
11235	protected function checkReferenceLoop ( $ loop , $ name ) { if ( $ loop > 20 ) { throw new RuntimeException ( Message :: get ( Message :: MSG_REF_LOOP , $ name ) , Message :: MSG_REF_LOOP ) ; } }
9868	private function writePrintOptions ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'printOptions' ) ; $ objWriter -> writeAttribute ( 'gridLines' , ( $ pSheet -> getPrintGridlines ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'gridLinesSet' , 'true' ) ; if ( $ pSheet -> getPageSetup ( ) -> getHorizontalCentered ( ) ) { $ objWriter -> writeAttribute ( 'horizontalCentered' , 'true' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getVerticalCentered ( ) ) { $ objWriter -> writeAttribute ( 'verticalCentered' , 'true' ) ; } $ objWriter -> endElement ( ) ; }
1584	public function withMeta ( $ meta ) : self { $ copy = clone $ this ; $ copy -> meta = collect ( $ meta ) -> all ( ) ; return $ copy ; }
10231	public function write ( Spreadsheet $ spreadsheet = null ) { if ( ! $ spreadsheet ) { $ spreadsheet = $ this -> getParentWriter ( ) -> getSpreadsheet ( ) ; } $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-meta' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:dc' , 'http://purl.org/dc/elements/1.1/' ) ; $ objWriter -> writeAttribute ( 'xmlns:meta' , 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'xmlns:grddl' , 'http://www.w3.org/2003/g/data-view#' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:meta' ) ; $ objWriter -> writeElement ( 'meta:initial-creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'dc:creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'meta:creation-date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:title' , $ spreadsheet -> getProperties ( ) -> getTitle ( ) ) ; $ objWriter -> writeElement ( 'dc:description' , $ spreadsheet -> getProperties ( ) -> getDescription ( ) ) ; $ objWriter -> writeElement ( 'dc:subject' , $ spreadsheet -> getProperties ( ) -> getSubject ( ) ) ; $ keywords = explode ( ' ' , $ spreadsheet -> getProperties ( ) -> getKeywords ( ) ) ; foreach ( $ keywords as $ keyword ) { $ objWriter -> writeElement ( 'meta:keyword' , $ keyword ) ; } $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'Company' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCompany ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'category' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCategory ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
12595	protected function getMinifier ( SplFileInfo $ file , string $ source ) : Minifier { $ minifier = '\Gears\Asset\Minifiers\\' ; $ minifier .= ucfirst ( $ this -> destination -> getExtension ( ) ) ; if ( ! class_exists ( $ minifier ) ) { throw new RuntimeException ( 'Minification is not supported for type: ' . $ this -> destination -> getExtension ( ) ) ; } return new $ minifier ( $ file , $ source ) ; }
4840	public function validate_webhook ( $ params ) { $ sig = $ params [ 'signature' ] ; unset ( $ params [ 'signature' ] ) ; if ( ! isset ( $ sig ) ) { return false ; } $ data = array ( 'data' => $ params , 'secret' => $ this -> account_details [ 'app_secret' ] , 'signature' => $ sig ) ; return $ this -> validate_signature ( $ data ) ; }
6381	public function readQuestionAttempts ( $ id ) { $ questionAttempts = $ this -> readStoreRecords ( 'question_attempts' , [ 'questionusageid' => $ id ] ) ; foreach ( $ questionAttempts as $ questionIndex => $ questionAttempt ) { $ questionAttemptSteps = $ this -> readStoreRecords ( 'question_attempt_steps' , [ 'questionattemptid' => $ questionAttempt -> id ] ) ; foreach ( $ questionAttemptSteps as $ stepIndex => $ questionAttemptStep ) { $ questionAttemptStep -> data = $ this -> readStoreRecords ( 'question_attempt_step_data' , [ 'attemptstepid' => $ questionAttemptStep -> id ] ) ; } $ questionAttempt -> steps = $ questionAttemptSteps ; } return $ questionAttempts ; }
2308	public function setImportantPart ( array $ importantPart = null ) { if ( $ importantPart !== null ) { if ( ! isset ( $ importantPart [ 'x' ] ) || ! isset ( $ importantPart [ 'y' ] ) || ! isset ( $ importantPart [ 'width' ] ) || ! isset ( $ importantPart [ 'height' ] ) ) { throw new \ InvalidArgumentException ( 'Malformed array for setting the important part!' ) ; } $ this -> importantPart = array ( 'x' => max ( 0 , min ( $ this -> fileObj -> viewWidth - 1 , ( int ) $ importantPart [ 'x' ] ) ) , 'y' => max ( 0 , min ( $ this -> fileObj -> viewHeight - 1 , ( int ) $ importantPart [ 'y' ] ) ) , ) ; $ this -> importantPart [ 'width' ] = max ( 1 , min ( $ this -> fileObj -> viewWidth - $ this -> importantPart [ 'x' ] , ( int ) $ importantPart [ 'width' ] ) ) ; $ this -> importantPart [ 'height' ] = max ( 1 , min ( $ this -> fileObj -> viewHeight - $ this -> importantPart [ 'y' ] , ( int ) $ importantPart [ 'height' ] ) ) ; } else { $ this -> importantPart = null ; } return $ this ; }
7448	function encrypt ( $ data , $ password ) { $ salt = openssl_random_pseudo_bytes ( 16 ) ; $ salted = '' ; $ dx = '' ; while ( strlen ( $ salted ) < 48 ) { $ dx = hash ( 'sha256' , $ dx . $ password . $ salt , true ) ; $ salted .= $ dx ; } $ key = substr ( $ salted , 0 , 32 ) ; $ iv = substr ( $ salted , 32 , 16 ) ; $ encrypted_data = openssl_encrypt ( $ data , 'AES-256-CBC' , $ key , true , $ iv ) ; return base64_encode ( $ salt . $ encrypted_data ) ; }
7992	public function setPassword ( $ pp , $ pca , $ passwd ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ passwd ) throw new BadMethodCallException ( 'Missing parameter $passwd (Password for this pca).' ) ; $ payload = array ( 'password' => $ passwd ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
8122	public function getReviewContentForm ( $ id ) { $ page = $ this -> findRecord ( [ 'ID' => $ id ] ) ; $ user = Security :: getCurrentUser ( ) ; if ( ! $ page -> canEdit ( ) || ( $ page -> hasMethod ( 'canBeReviewedBy' ) && ! $ page -> canBeReviewedBy ( $ user ) ) ) { $ this -> owner -> httpError ( 403 , _t ( __CLASS__ . '.ErrorItemPermissionDenied' , 'It seems you don\'t have the necessary permissions to review this content' ) ) ; return null ; } $ form = $ this -> getReviewContentHandler ( ) -> Form ( $ page ) ; $ form -> setValidationResponseCallback ( function ( ValidationResult $ errors ) use ( $ form , $ id ) { $ schemaId = $ this -> owner -> join_links ( $ this -> owner -> Link ( 'schema/ReviewContentForm' ) , $ id ) ; return $ this -> getSchemaResponse ( $ schemaId , $ form , $ errors ) ; } ) ; return $ form ; }
5044	public function onRoute ( MvcEvent $ e ) { $ routeMatch = $ e -> getRouteMatch ( ) ; if ( 0 !== strpos ( $ routeMatch -> getMatchedRouteName ( ) , 'lang' ) ) { $ lang = $ this -> detectLanguage ( $ e ) ; $ this -> setLocale ( $ e , $ lang ) ; return ; } $ language = $ routeMatch -> getParam ( 'lang' , '__NOT_SET__' ) ; if ( $ this -> localeService -> isLanguageSupported ( $ language ) ) { $ this -> setLocale ( $ e , $ language ) ; } else { $ e -> setError ( Application :: ERROR_ROUTER_NO_MATCH ) ; $ e -> setTarget ( $ this ) ; $ eventManager = $ e -> getApplication ( ) -> getEventManager ( ) ; $ eventManager -> setEventPrototype ( $ e ) ; $ result = $ eventManager -> trigger ( MvcEvent :: EVENT_DISPATCH_ERROR , $ e ) ; return $ result -> last ( ) ; } }
2647	public function addComment ( $ version , $ comment ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ comment ) ; return $ result ; }
10369	public function reset ( ResetRequest $ request , $ token ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'reset' ) ) -> dispatchFrom ( ResetJob :: class , $ request , compact ( 'token' ) ) ; return redirect ( ) -> route ( 'login.index' ) -> withSuccess ( trans ( 'auth::reset.success' ) ) ; }
11609	public function actionDisconnect ( $ id ) { $ account = $ this -> finder -> findAccountById ( $ id ) ; if ( $ account === null ) { throw new NotFoundHttpException ; } if ( $ account -> user_id != \ Yii :: $ app -> user -> id ) { throw new ForbiddenHttpException ; } $ account -> delete ( ) ; return $ this -> redirect ( [ 'networks' ] ) ; }
6212	protected function array2Node ( $ parentNode , $ key , $ params ) { if ( count ( $ params ) == 0 ) { return ; } $ node = $ parentNode -> addChild ( $ key ) ; foreach ( $ params as $ key => $ value ) { if ( is_array ( $ value ) || is_object ( $ value ) ) { $ value = json_encode ( ( array ) $ value ) ; } $ node -> addChild ( 'var' , htmlspecialchars ( $ value ) ) -> addAttribute ( 'key' , $ key ) ; } }
9249	public function generate ( $ name , array $ parameters = array ( ) , $ absolute = false ) { if ( ! $ this -> initialized ) { $ this -> initialize ( ) ; } $ path = $ this -> routes [ $ name ] ; if ( is_array ( $ path ) ) { $ params = $ path [ 'params' ] ; $ path = $ path [ 'path' ] ; foreach ( $ params as $ param ) { if ( ! isset ( $ parameters [ $ param ] ) ) { throw new \ RuntimeException ( 'Missing required parameter "' . $ param . '". Optional parameters not currently supported' ) ; } $ path = str_replace ( '{' . $ param . '}' , $ parameters [ $ param ] , $ path ) ; } } if ( $ this -> request ) { $ path = $ this -> request -> getBaseUrl ( ) . $ path ; if ( $ absolute ) { $ path = $ this -> request -> getSchemeAndHttpHost ( ) . $ path ; } } return $ path ; }
10901	public function loadAll ( array $ where = [ ] , bool $ assoc = false , array $ fields = null ) : Collection { $ allData = $ this -> medoo -> select ( $ this -> getTable ( ) , $ fields ? $ fields : '*' , $ where ) ; $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::loadAll(' . \ print_r ( $ where , true ) . ', ' . $ assoc . ', ' . \ print_r ( $ fields , true ) . ')' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; $ items = [ ] ; foreach ( $ allData as $ data ) { $ items [ ] = ( $ assoc ) ? $ data : $ this -> container [ 'entity' ] ( $ this -> __getEntityName ( ) ) -> setData ( $ data ) ; } return new Collection ( $ items ) ; }
4086	public function handle ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'filterparams' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ objFilterSettings = $ this -> settingFactory -> createCollection ( $ model -> getProperty ( 'filter' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'subfields' ] = $ objFilterSettings -> getParameterDCA ( ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; }
6115	public function serverGetPortById ( $ sid ) { if ( ! array_key_exists ( ( string ) $ sid , $ this -> serverList ( ) ) ) { throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; } return $ this -> serverList [ intval ( ( string ) $ sid ) ] [ "virtualserver_port" ] ; }
8577	public function setItemFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8227	protected function logSuccessfulRegistration ( array $ reg ) { $ this -> getLogger ( ) -> info ( "New registration: {name} ({email}) from {addr}" , array ( "name" => $ reg [ "username" ] , "email" => $ reg [ "email" ] , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] ) ) ; $ max = $ this -> config [ "maxUsers" ] ; $ count = $ this -> storage -> getUsersCount ( ) + 1 ; if ( $ count % ceil ( $ max / 10 ) === 0 ) { $ percent = intval ( $ count / ceil ( $ max / 100 ) ) ; $ this -> getLogger ( ) -> warning ( "The amount of users has reached {percent} of the maximum capacity {max}." , array ( "percent" => $ percent , "max" => $ max ) ) ; } }
967	protected function cleanShop ( ) { $ this -> shop -> shopify_token = null ; $ this -> shop -> plan_id = null ; $ this -> shop -> save ( ) ; }
10318	function getBlocks ( $ fromDate = null , $ toDate = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ reasons = null , $ oldStatus = null , $ newStatus = null , $ excludeAnonymousBlocks = false , $ standardFields = null , $ customFields = null , $ pageIndex = 1 , $ pageSize = 100 ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , null , null , null ) ; $ params = $ this -> appendArrayFields ( $ params , "standard_field" , $ standardFields ) ; $ params = $ this -> appendArrayFields ( $ params , "custom_field" , $ customFields ) ; if ( isset ( $ embedEmailClientInfos ) ) $ params [ 'embed_email_client_infos' ] = ( $ embedEmailClientInfos == true ) ? "true" : "false" ; if ( isset ( $ excludeAnonymousBlocks ) ) $ params [ 'exclude_anonymous_blocks' ] = ( $ excludeAnonymousBlocks == true ) ? "true" : "false" ; $ params = $ this -> appendArrayFields ( $ params , "reasons" , $ reasons ) ; if ( isset ( $ oldStatus ) ) $ params [ 'old_status' ] = $ oldStatus ; if ( isset ( $ newStatus ) ) $ params [ 'new_status' ] = $ newStatus ; return $ this -> get ( 'reports/blocks' , $ params ) ; }
12726	public function getContent ( array $ contentData ) { foreach ( $ this -> mandatoryFields as $ mandatoryField ) { if ( ! array_key_exists ( $ mandatoryField , $ contentData ) ) { throw new ContentException ( "The field '$mandatoryField' is missing in the given content data" ) ; } } try { $ title = "" ; if ( isset ( $ contentData [ self :: FIELD_TITLE ] ) ) { $ title = $ contentData [ self :: FIELD_TITLE ] ; } $ summary = "" ; if ( isset ( $ contentData [ self :: FIELD_SUMMARY ] ) ) { $ summary = $ contentData [ self :: FIELD_SUMMARY ] ; } $ description = "" ; if ( isset ( $ contentData [ self :: FIELD_DESCRIPTION ] ) ) { $ description = $ contentData [ self :: FIELD_DESCRIPTION ] ; } $ content = new Content ( $ title , $ summary , $ description ) ; return $ content ; } catch ( \ Exception $ contentException ) { throw new ContentException ( sprintf ( "Failed to create a content model from the given data: %s" , $ contentException -> getMessage ( ) ) , $ contentException ) ; } }
12372	public function addRule ( string $ name , callable $ func , $ errorMsg = null ) : self { $ this -> rules [ $ name ] = array ( $ func , $ errorMsg ) ; return $ this ; }
3635	public function httpMiddles ( Request $ request ) : array { $ dispatcher = \ bean ( 'serverDispatcher' ) ; $ middleType = ( int ) $ request -> query ( 'type' ) ; if ( $ middleType === 1 ) { return $ dispatcher -> getMiddlewares ( ) ; } return $ dispatcher -> requestMiddleware ( ) ; }
3202	protected function process_css_style ( $ stackPtr ) { if ( ! isset ( $ this -> target_css_properties [ $ this -> tokens [ $ stackPtr ] [ 'content' ] ] ) ) { return ; } $ css_property = $ this -> target_css_properties [ $ this -> tokens [ $ stackPtr ] [ 'content' ] ] ; $ opener = $ this -> phpcsFile -> findPrevious ( \ T_OPEN_CURLY_BRACKET , $ stackPtr ) ; if ( false !== $ opener ) { for ( $ i = ( $ opener - 1 ) ; $ i >= 0 ; $ i -- ) { if ( isset ( Tokens :: $ commentTokens [ $ this -> tokens [ $ i ] [ 'code' ] ] ) || \ T_CLOSE_CURLY_BRACKET === $ this -> tokens [ $ i ] [ 'code' ] ) { break ; } } $ start = ( $ i + 1 ) ; $ selector = trim ( $ this -> phpcsFile -> getTokensAsString ( $ start , ( $ opener - $ start ) ) ) ; unset ( $ i ) ; foreach ( $ this -> target_css_selectors as $ target_selector ) { if ( false !== strpos ( $ selector , $ target_selector ) ) { $ error = true ; if ( true === $ this -> remove_only ) { $ valuePtr = $ this -> phpcsFile -> findNext ( array ( \ T_COLON , \ T_WHITESPACE ) , ( $ stackPtr + 1 ) , null , true ) ; $ value = $ this -> tokens [ $ valuePtr ] [ 'content' ] ; $ valid = $ this -> validate_css_property_value ( $ value , $ css_property [ 'type' ] , $ css_property [ 'value' ] ) ; if ( true === $ valid ) { $ error = false ; } } if ( true === $ error ) { $ this -> phpcsFile -> addError ( 'Hiding of the admin bar is not allowed.' , $ stackPtr , 'HidingDetected' ) ; } } } } }
1161	private function fakeRequiredIfData ( $ data , $ rule , $ parameters ) { if ( $ rule !== 'RequiredIf' ) { return ; } $ newData = $ data ; $ newData [ $ parameters [ 0 ] ] = $ parameters [ 1 ] ; $ this -> validator -> setData ( $ newData ) ; }
1757	public static function getReadableSize ( $ intSize , $ intDecimals = 1 ) { for ( $ i = 0 ; $ intSize >= 1024 ; $ i ++ ) { $ intSize /= 1024 ; } return static :: getFormattedNumber ( $ intSize , $ intDecimals ) . ' ' . $ GLOBALS [ 'TL_LANG' ] [ 'UNITS' ] [ $ i ] ; }
7093	private function checkHierarchyIntegrity ( InvoiceInterface $ invoice ) { if ( null !== $ shipment = $ invoice -> getShipment ( ) ) { if ( $ invoice -> getSale ( ) !== $ shipment -> getSale ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isCredit ( $ invoice ) && ! $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isInvoice ( $ invoice ) && $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } } }
5146	public function accessInboxFor ( $ address ) { $ inbox = array ( ) ; $ addressPlusDelimiters = '<' . $ address . '>' ; foreach ( $ this -> fetchedEmails as & $ email ) { $ email -> Headers = $ this -> getHeaders ( $ email -> id ) -> headers ; if ( ! isset ( $ email -> Headers -> bcc ) ) { if ( strpos ( $ email -> Headers -> to , $ addressPlusDelimiters ) || strpos ( $ email -> Headers -> cc , $ addressPlusDelimiters ) ) { array_push ( $ inbox , $ email ) ; } } else if ( strpos ( $ email -> Headers -> bcc , $ addressPlusDelimiters ) ) { array_push ( $ inbox , $ email ) ; } } $ this -> setCurrentInbox ( $ inbox ) ; }
8536	public function setRentalChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2226	private function renderErrorScreenByException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; $ statusCode = $ this -> getStatusCodeForException ( $ exception ) ; $ template = null ; $ this -> logException ( $ exception ) ; do { if ( $ exception instanceof \ Exception ) { $ template = $ this -> getTemplateForException ( $ exception ) ; } } while ( null === $ template && null !== ( $ exception = $ exception -> getPrevious ( ) ) ) ; $ this -> renderTemplate ( $ template ? : 'error' , $ statusCode , $ event ) ; }
5299	public function getGlyphs ( ) { if ( ! isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> glyph ) || ! count ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> glyph ) ) { return array ( ) ; } $ glyphs = array ( ) ; foreach ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> glyph as $ xmlGlyph ) { if ( isset ( $ xmlGlyph [ 'unicode' ] ) && isset ( $ xmlGlyph [ 'd' ] ) ) { $ glyph = array ( 'char' => ( string ) $ xmlGlyph [ 'unicode' ] , 'path' => ( string ) $ xmlGlyph [ 'd' ] , ) ; if ( isset ( $ xmlGlyph [ 'glyph-name' ] ) ) { $ glyph [ 'name' ] = ( string ) $ xmlGlyph [ 'glyph-name' ] ; } if ( isset ( $ xmlGlyph [ 'horiz-adv-x' ] ) ) { $ glyph [ 'width' ] = ( string ) $ xmlGlyph [ 'horiz-adv-x' ] ; } $ glyphs [ ] = $ glyph ; } } return $ glyphs ; }
553	public function actionFlushSchema ( $ db = 'db' ) { $ connection = Yii :: $ app -> get ( $ db , false ) ; if ( $ connection === null ) { $ this -> stdout ( "Unknown component \"$db\".\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } if ( ! $ connection instanceof \ yii \ db \ Connection ) { $ this -> stdout ( "\"$db\" component doesn't inherit \\yii\\db\\Connection.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } elseif ( ! $ this -> confirm ( "Flush cache schema for \"$db\" connection?" ) ) { return ExitCode :: OK ; } try { $ schema = $ connection -> getSchema ( ) ; $ schema -> refresh ( ) ; $ this -> stdout ( "Schema cache for component \"$db\", was flushed.\n\n" , Console :: FG_GREEN ) ; } catch ( \ Exception $ e ) { $ this -> stdout ( $ e -> getMessage ( ) . "\n\n" , Console :: FG_RED ) ; } }
1062	public static function findTypesAddedToUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesAddedToUnion = [ ] ; foreach ( $ newTypeMap as $ typeName => $ newType ) { $ oldType = $ oldTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInOldUnion = [ ] ; foreach ( $ oldType -> getTypes ( ) as $ type ) { $ typeNamesInOldUnion [ $ type -> name ] = true ; } foreach ( $ newType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInOldUnion [ $ type -> name ] ) ) { continue ; } $ typesAddedToUnion [ ] = [ 'type' => self :: DANGEROUS_CHANGE_TYPE_ADDED_TO_UNION , 'description' => sprintf ( '%s was added to union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesAddedToUnion ; }
1828	public function save ( ) { if ( \ count ( \ func_get_args ( ) ) ) { throw new \ InvalidArgumentException ( 'The $blnForceInsert argument has been removed (see system/docs/UPGRADE.md)' ) ; } if ( $ this -> blnPreventSaving ) { throw new \ RuntimeException ( 'The model instance has been detached and cannot be saved' ) ; } $ objDatabase = Database :: getInstance ( ) ; $ arrFields = $ objDatabase -> getFieldNames ( static :: $ strTable ) ; if ( Registry :: getInstance ( ) -> isRegistered ( $ this ) ) { $ arrSet = array ( ) ; $ arrRow = $ this -> row ( ) ; foreach ( $ this -> arrModified as $ k => $ v ) { if ( \ in_array ( $ k , $ arrFields ) ) { $ arrSet [ $ k ] = $ arrRow [ $ k ] ; } } $ arrSet = $ this -> preSave ( $ arrSet ) ; if ( empty ( $ arrSet ) ) { return $ this ; } $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } if ( $ intPk === null ) { throw new \ RuntimeException ( 'The primary key has not been set' ) ; } $ objDatabase -> prepare ( "UPDATE " . static :: $ strTable . " %s WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> set ( $ arrSet ) -> execute ( $ intPk ) ; $ this -> postSave ( self :: UPDATE ) ; $ this -> arrModified = array ( ) ; } else { $ arrSet = $ this -> row ( ) ; foreach ( $ arrSet as $ k => $ v ) { if ( ! \ in_array ( $ k , $ arrFields ) ) { unset ( $ arrSet [ $ k ] ) ; } } $ arrSet = $ this -> preSave ( $ arrSet ) ; if ( empty ( $ arrSet ) ) { return $ this ; } $ stmt = $ objDatabase -> prepare ( "INSERT INTO " . static :: $ strTable . " %s" ) -> set ( $ arrSet ) -> execute ( ) ; if ( static :: $ strPk == 'id' ) { $ this -> id = $ stmt -> insertId ; } $ this -> postSave ( self :: INSERT ) ; $ this -> arrModified = array ( ) ; Registry :: getInstance ( ) -> register ( $ this ) ; } return $ this ; }
2432	public function updateAfterRestore ( $ id , $ table , $ data ) { if ( $ table != 'tl_style' ) { return ; } $ this -> Database -> prepare ( "UPDATE tl_style_sheet SET tstamp=? WHERE id=?" ) -> execute ( time ( ) , $ data [ 'pid' ] ) ; $ this -> import ( 'Contao\StyleSheets' , 'StyleSheets' ) ; $ this -> StyleSheets -> updateStyleSheet ( $ data [ 'pid' ] ) ; }
10413	public function loadUrlsByType ( $ type ) { foreach ( $ this -> urlCollectors as $ collector ) { $ this -> addUrls ( $ collector -> getUrlsByType ( $ type , $ this -> router ) ) ; } }
12790	public static function createView ( string $ actionName , ? string $ ctrlName = null ) : ? View { $ viewsRoot = AppHelper :: getInstance ( ) -> getComponentRoot ( 'views' ) ; $ addPath = '' ; if ( ! empty ( $ ctrlName ) ) { $ addPath .= \ DIRECTORY_SEPARATOR . strtolower ( $ ctrlName ) ; } $ viewFile = $ viewsRoot . $ addPath . \ DIRECTORY_SEPARATOR . strtolower ( $ actionName ) . '.php' ; if ( is_readable ( $ viewFile ) ) { return new View ( $ viewFile ) ; } return null ; }
2051	public function save ( ) { $ groups = $ this -> groups ; $ this -> arrData [ 'groups' ] = $ this -> arrGroups ; parent :: save ( ) ; $ this -> groups = $ groups ; }
8204	protected function reserveJob ( $ tube ) { try { return $ this -> getPheanstalk ( ) -> reserveFromTube ( $ tube , 0 ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
12871	public function search ( string $ sFilter , array $ aAttributes ) { return ldap_search ( $ this -> _rConnect , $ this -> _sBase , $ sFilter , $ aAttributes ) ; }
4448	public function put ( string $ className , array $ data , ? string $ jid = null , ? int $ delay = null , ? int $ retries = null , ? int $ priority = null , ? array $ tags = null , ? array $ depends = null ) { try { $ jid = $ jid ? : str_replace ( '-' , '' , Uuid :: uuid4 ( ) -> toString ( ) ) ; } catch ( \ Exception $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } $ data = new JobData ( $ data ) ; $ this -> getEventsManager ( ) -> fire ( new QueueEvent \ BeforeEnqueue ( $ this , $ jid , $ data , $ className ) ) ; if ( ! $ putData = json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ) { throw new RuntimeException ( sprintf ( 'Unable to encode payload to put the described job "%s" to the "%s" queue.' , $ jid , $ this -> name ) ) ; } $ jid = $ this -> client -> put ( '' , $ this -> name , $ jid , $ className , $ putData , is_null ( $ delay ) ? 0 : $ delay , 'priority' , is_null ( $ priority ) ? 0 : $ priority , 'tags' , json_encode ( $ tags ? : [ ] , JSON_UNESCAPED_SLASHES ) , 'retries' , is_null ( $ retries ) ? 5 : $ retries , 'depends' , json_encode ( $ depends ? : [ ] , JSON_UNESCAPED_SLASHES ) ) ; $ this -> getEventsManager ( ) -> fire ( new QueueEvent \ AfterEnqueue ( $ this , $ jid , $ data -> toArray ( ) , $ className ) ) ; return $ jid ; }
1184	protected function wrapValidator ( ) { $ resolver = new Resolver ( $ this -> factory ) ; $ this -> factory -> resolver ( $ resolver -> resolver ( $ this -> field ) ) ; $ this -> factory -> extend ( RemoteValidator :: EXTENSION_NAME , $ resolver -> validatorClosure ( ) ) ; }
3205	protected function get_docblock_tags ( $ comment_opener ) { $ tags = array ( ) ; $ opener = $ this -> tokens [ $ comment_opener ] ; if ( ! isset ( $ opener [ 'comment_tags' ] ) ) { return $ tags ; } $ closer = null ; if ( isset ( $ opener [ 'comment_closer' ] ) ) { $ closer = $ opener [ 'comment_closer' ] ; } $ tag_count = count ( $ opener [ 'comment_tags' ] ) ; for ( $ i = 0 ; $ i < $ tag_count ; $ i ++ ) { $ tag_token = $ opener [ 'comment_tags' ] [ $ i ] ; $ tag = trim ( $ this -> tokens [ $ tag_token ] [ 'content' ] , '@' ) ; $ search_end = $ closer ; if ( ( $ i + 1 ) < $ tag_count ) { $ search_end = $ opener [ 'comment_tags' ] [ ( $ i + 1 ) ] ; } $ value_token = $ this -> phpcsFile -> findNext ( T_DOC_COMMENT_STRING , ( $ tag_token + 1 ) , $ search_end ) ; $ tags [ $ tag ] = trim ( $ this -> tokens [ $ value_token ] [ 'content' ] ) ; unset ( $ tag_token , $ tag , $ search_end , $ value ) ; } return $ tags ; }
1497	public function push ( Encoding ... $ encodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ encodings ) -> all ( ) ; return $ copy ; }
4528	public function postLoad ( Permission $ permission , LifecycleEventArgs $ event ) { $ item = $ this -> permissionCollection -> get ( $ permission -> getKey ( ) ) ; if ( ! $ item ) { throw new UnexpectedValueException ( 'Permission "' . $ permission -> getKey ( ) . '" does not exist.' ) ; } $ permission -> setType ( $ item -> getType ( ) ) -> setValue ( $ item -> getValue ( ) ) ; }
7249	protected function validateShipmentMethodRequirements ( SaleInterface $ sale , Constraint $ constraint ) { if ( null === $ method = $ sale -> getShipmentMethod ( ) ) { return ; } if ( $ sale -> isSameAddress ( ) ) { $ address = $ sale -> getInvoiceAddress ( ) ; $ path = 'invoiceAddress' ; } else { $ address = $ sale -> getDeliveryAddress ( ) ; $ path = 'deliveryAddress' ; } if ( null === $ address ) { return ; } $ gateway = $ this -> gatewayRegistry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( $ gateway -> requires ( Gateway \ GatewayInterface :: REQUIREMENT_MOBILE ) ) { if ( is_null ( $ address -> getMobile ( ) ) ) { $ this -> context -> buildViolation ( $ constraint -> shipment_method_require_mobile ) -> atPath ( $ path . '.mobile' ) -> addViolation ( ) ; } } }
5945	public function freetext ( $ freetext , $ deploymentSiteIds = null , $ mode = self :: FREETEXT_OR , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'mode' => $ mode , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/freetext/' . $ freetext . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
8514	public function listInboundShipmentsByNextToken ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3525	public function lookup ( $ username ) { try { $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_PERSONA_API . 'public/account/lookup?q=' . urlencode ( $ username ) , $ this -> access_token ) ; return new self ( $ this -> access_token , $ data -> id ) ; } catch ( GuzzleException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) throw new UserNotFoundException ( 'User ' . $ username . ' was not found.' ) ; throw $ e ; } }
5170	public static function getNameByType ( $ type ) { static $ map = array ( self :: TYPE_BOOL => 'Bool' , self :: TYPE_INT => 'Int' , self :: TYPE_UINT => 'UInt' , self :: TYPE_QCHAR => 'QChar' , self :: TYPE_QVARIANT_MAP => 'QVariantMap' , self :: TYPE_QVARIANT_LIST => 'QVariantList' , self :: TYPE_QSTRING => 'QString' , self :: TYPE_QSTRING_LIST => 'QStringList' , self :: TYPE_QBYTE_ARRAY => 'QByteArray' , self :: TYPE_QTIME => 'QTime' , self :: TYPE_QDATETIME => 'QDateTime' , self :: TYPE_QUSER_TYPE => 'QUserType' , self :: TYPE_SHORT => 'Short' , self :: TYPE_CHAR => 'Char' , self :: TYPE_USHORT => 'UShort' , self :: TYPE_UCHAR => 'UChar' , ) ; if ( ! isset ( $ map [ $ type ] ) ) { throw new \ InvalidArgumentException ( 'Invalid/unknown variant type (' . $ type . ')' ) ; } return $ map [ $ type ] ; }
6323	public function getA ( StringType $ name ) { if ( ! $ this -> hasA ( $ name ) ) { throw new AttributesException ( "Attribute: {$name} does not exist" ) ; } return $ this -> attributes [ $ name ( ) ] ; }
10134	public function positionImage ( $ col_start , $ row_start , $ x1 , $ y1 , $ width , $ height ) { $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) ) { $ x1 = 0 ; } if ( $ y1 >= Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ) { $ width -= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ; ++ $ col_end ; } while ( $ height >= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ) { $ height -= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) * 1024 ; $ y1 = $ y1 / Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) * 256 ; $ x2 = $ width / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) * 1024 ; $ y2 = $ height / Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) * 256 ; $ this -> writeObjPicture ( $ col_start , $ x1 , $ row_start , $ y1 , $ col_end , $ x2 , $ row_end , $ y2 ) ; }
10373	public static function unify ( $ id , $ params , $ minify = '' ) { self :: $ id = $ id ; self :: $ unify = $ params ; self :: $ minify = $ minify ; return true ; }
4938	protected function getOptionsConfig ( $ fullName ) { if ( array_key_exists ( $ fullName , $ this -> optionsConfig ) ) { return $ this -> optionsConfig [ $ fullName ] ; } return false ; }
238	protected function normalizePdoRowKeyCase ( array $ row , $ multiple ) { if ( $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_CASE ) !== \ PDO :: CASE_UPPER ) { return $ row ; } if ( $ multiple ) { return array_map ( function ( array $ row ) { return array_change_key_case ( $ row , CASE_LOWER ) ; } , $ row ) ; } return array_change_key_case ( $ row , CASE_LOWER ) ; }
7423	protected function registerWidget ( $ name = null , $ id = null ) { if ( $ name === null ) { $ name = $ this -> getDefaultJsWidgetName ( ) ; } $ this -> _registerBundle ( ) ; if ( ! $ this -> isAjaxCrud && $ this -> getUpdateUrl ( ) ) { if ( $ id === null ) { $ id = $ this -> options [ 'id' ] ; } $ options = empty ( $ this -> clientOptions ) ? '' : Json :: htmlEncode ( [ 'updateUrl' => Url :: to ( $ this -> getUpdateUrl ( ) ) ] ) ; $ js = "jQuery('#$id').$name($options);" ; $ this -> getView ( ) -> registerJs ( $ js ) ; } }
12864	public function postDispatch ( Zend_Controller_Request_Abstract $ request ) { $ methods = implode ( ', ' , array_unique ( $ this -> _methods ) ) ; $ headers = implode ( ', ' , array_unique ( $ this -> _headers ) ) ; if ( $ this -> _credentials ) { header ( 'Access-Control-Allow-Credentials: true' , true ) ; } header ( "Access-Control-Allow-Origin: {$this->_origin}" , true ) ; header ( "Access-Control-Allow-Methods: {$methods}" , true ) ; header ( "Access-Control-Allow-Headers: {$headers}" , true ) ; header ( "Access-Control-Max-Age: {$this->_maxAge}" , true ) ; header ( 'X-XSS-Protection: 1; mode=block' , true ) ; header ( 'X-Frame-Options: SAMEORIGIN' , true ) ; }
12159	public function getTitle ( ) { if ( ! is_object ( $ this -> _title ) ) { $ this -> _title = new Noun ( $ this -> _title ) ; } return $ this -> _title ; }
6134	public function setMetadata ( $ metadata ) { if ( is_array ( $ metadata ) ) { $ this -> metadata = $ metadata ; return $ this ; } $ this -> metadata = json_decode ( $ metadata , true ) ; if ( null === $ this -> metadata ) { $ this -> metadata = $ metadata ; } return $ this ; }
2606	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItemId = $ this -> getRequest ( ) -> getParam ( 'acl_item_id' ) ; $ deleteItem = $ this -> api -> deleteAclItem ( $ aclId , $ aclItemId ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12824	protected function addBlockToSlot ( $ dir , array $ options ) { $ slot = $ this -> getSlotDefinition ( $ dir ) ; $ blocks = $ slot [ "blocks" ] ; $ blockName = $ options [ "blockname" ] ; $ position = $ options [ "position" ] ; array_splice ( $ blocks , $ position , 0 , $ blockName ) ; $ slot [ "next" ] = str_replace ( 'block' , '' , $ blockName ) + 1 ; $ slot [ "blocks" ] = $ blocks ; $ this -> saveSlotDefinition ( $ dir , $ slot ) ; return $ blockName ; }
2524	protected function loadFromAuthParams ( AuthParams $ authParams ) { $ this -> officeId = $ authParams -> officeId ; $ this -> dutyCode = $ authParams -> dutyCode ; $ this -> organizationId = $ authParams -> organizationId ; $ this -> originatorTypeCode = $ authParams -> originatorTypeCode ; $ this -> userId = $ authParams -> userId ; $ this -> passwordLength = $ authParams -> passwordLength ; $ this -> passwordData = $ authParams -> passwordData ; }
12212	public function getSnippet ( string $ snptName = '' ) { if ( empty ( $ snptName ) ) { return $ this -> snippets ; } else { return isset ( $ this -> snippets [ $ snptName ] ) ? $ this -> snippets [ $ snptName ] : null ; } }
58	protected function resolvePackageInstallPreference ( PackageInterface $ package ) { foreach ( $ this -> packagePreferences as $ pattern => $ preference ) { $ pattern = '{^' . str_replace ( '\\*' , '.*' , preg_quote ( $ pattern ) ) . '$}i' ; if ( preg_match ( $ pattern , $ package -> getName ( ) ) ) { if ( 'dist' === $ preference || ( ! $ package -> isDev ( ) && 'auto' === $ preference ) ) { return 'dist' ; } return 'source' ; } } return $ package -> isDev ( ) ? 'source' : 'dist' ; }
12652	public function getPageTexts ( $ language ) { if ( ! isset ( $ this -> contents [ $ language ] ) ) { $ this -> contents [ $ language ] = $ this -> readFileContents ( $ language ) ; } return $ this -> contents [ $ language ] ; }
12304	public function adminIndex ( ) { $ config = [ 'title' => trans ( 'HCLanguages::languages.page_title' ) , 'listURL' => route ( 'admin.api.languages' ) , 'newFormUrl' => route ( 'admin.api.form-manager' , [ 'languages-new' ] ) , 'editFormUrl' => route ( 'admin.api.form-manager' , [ 'languages-edit' ] ) , 'imagesUrl' => route ( 'resource.get' , [ '/' ] ) , 'headers' => $ this -> getAdminListHeader ( ) , ] ; $ config [ 'actions' ] [ ] = 'search' ; return hcview ( 'HCCoreUI::admin.content.list' , [ 'config' => $ config ] ) ; }
7333	private function getStockUnitMapper ( EntityManagerInterface $ em ) { if ( null === $ this -> stockUnitMapper ) { $ this -> stockUnitMapper = new DiscriminatorMapper ( $ em , AbstractStockUnit :: class ) ; } return $ this -> stockUnitMapper ; }
2098	public static function formatToJs ( $ strFormat ) { $ chunks = str_split ( $ strFormat ) ; foreach ( $ chunks as $ k => $ v ) { switch ( $ v ) { case 'D' : $ chunks [ $ k ] = 'a' ; break ; case 'j' : $ chunks [ $ k ] = 'e' ; break ; case 'l' : $ chunks [ $ k ] = 'A' ; break ; case 'S' : $ chunks [ $ k ] = 'o' ; break ; case 'F' : $ chunks [ $ k ] = 'B' ; break ; case 'M' : $ chunks [ $ k ] = 'b' ; break ; case 'a' : $ chunks [ $ k ] = 'p' ; break ; case 'A' : $ chunks [ $ k ] = 'p' ; break ; case 'g' : $ chunks [ $ k ] = 'l' ; break ; case 'G' : $ chunks [ $ k ] = 'k' ; break ; case 'h' : $ chunks [ $ k ] = 'I' ; break ; case 'i' : $ chunks [ $ k ] = 'M' ; break ; case 's' : $ chunks [ $ k ] = 'S' ; break ; case 'U' : $ chunks [ $ k ] = 's' ; break ; } } return preg_replace ( '/([a-zA-Z])/' , '%$1' , implode ( '' , $ chunks ) ) ; }
2843	public function getBlockTreeHtml ( ) { $ content = '' ; $ rootNodes = $ this -> getBlocksAsTree ( ) ; foreach ( $ rootNodes as $ rootNode ) { $ content .= $ this -> renderTreeNode ( $ rootNode ) ; } return $ content ; }
3201	public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ result = $ this -> getListResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; array_map ( function ( $ item ) { return array_merge ( $ item , [ 'categories' => $ this -> getCategoryService ( ) -> getItemCategories ( $ this -> getResource ( $ item [ 'uri' ] ) ) ] ) ; } , $ result [ 'nodes' ] ) ; return $ result ; }
6846	public static function hours ( $ step = 1 , $ long = false , $ start = null ) { if ( ! $ start ) { $ start = $ long ? 0 : 1 ; } $ size = $ long ? 23 : 12 ; $ step = ( int ) $ step ; $ hours = array ( ) ; for ( $ i = $ start ; $ i <= $ size ; $ i += $ step ) { $ hours [ $ i ] = ( string ) $ i ; } return $ hours ; }
11654	protected function _initMultiDbResources ( ) { $ registry = $ this -> getPluginResource ( 'multidb' ) ; if ( ! $ registry ) { return ; } $ options = $ registry -> getOptions ( ) ; foreach ( $ options as & $ connection ) { if ( 'db://' === substr ( $ connection [ 'dbname' ] , 0 , 5 ) ) { $ connection = array_replace ( $ connection , $ this -> _parseDsn ( $ connection [ 'dbname' ] ) ) ; } } Zend_Registry :: set ( 'multidb' , $ registry -> setOptions ( $ options ) ) ; }
2733	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ html = $ this -> getRequest ( ) -> getParam ( 'html' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_ERROR_SNIPPET_PATH , Config :: VCL_ERROR_SNIPPET ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_' . $ key , 'type' => $ key , 'dynamic' => '0' , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_condition' , 'statement' => 'req.http.ResponseObject == "970"' , 'type' => 'REQUEST' , 'priority' => '9' ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ response = [ 'name' => Config :: ERROR_PAGE_RESPONSE_OBJECT , 'request_condition' => $ createCondition -> name , 'content' => $ html , 'status' => "503" , 'content_type' => "text/html; charset=utf-8" , 'response' => "Service Temporarily Unavailable" ] ; $ createResponse = $ this -> api -> createResponse ( $ clone -> number , $ response ) ; if ( ! $ createResponse ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create a RESPONSE object.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*New Error/Maintenance page has updated and activated under config version ' . $ clone -> number . '*' ) ; } $ comment = [ 'comment' => 'Magento Module updated Error Page html' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
7415	public function errorMessage ( ) : string { static $ errors = array ( UPLOAD_ERR_INI_SIZE => 'The file "%s" exceeds your upload_max_filesize ini directive (limit is %d KiB).' , UPLOAD_ERR_FORM_SIZE => 'The file "%s" exceeds the upload limit defined in your form.' , UPLOAD_ERR_PARTIAL => 'The file "%s" was only partially uploaded.' , UPLOAD_ERR_NO_FILE => 'No file was uploaded.' , UPLOAD_ERR_CANT_WRITE => 'The file "%s" could not be written on disk.' , UPLOAD_ERR_NO_TMP_DIR => 'File could not be uploaded: missing temporary directory.' , UPLOAD_ERR_EXTENSION => 'File upload was stopped by a PHP extension.' , ) ; $ errorCode = $ this -> error ; $ maxFileSize = $ errorCode === UPLOAD_ERR_INI_SIZE ? $ this -> getMaxFileSize ( ) / 1024 : 0 ; $ message = isset ( $ errors [ $ errorCode ] ) ? $ errors [ $ errorCode ] : 'The file "%s" was not uploaded due to an unknown error.' ; return sprintf ( $ message , $ this -> name , $ maxFileSize ) ; }
5703	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; return $ this ; }
9953	public function mergeCells ( $ pRange ) { $ pRange = strtoupper ( $ pRange ) ; if ( strpos ( $ pRange , ':' ) !== false ) { $ this -> mergeCells [ $ pRange ] = $ pRange ; $ aReferences = Coordinate :: extractAllCellReferencesInRange ( $ pRange ) ; $ upperLeft = $ aReferences [ 0 ] ; if ( ! $ this -> cellExists ( $ upperLeft ) ) { $ this -> getCell ( $ upperLeft ) -> setValueExplicit ( null , DataType :: TYPE_NULL ) ; } $ count = count ( $ aReferences ) ; for ( $ i = 1 ; $ i < $ count ; ++ $ i ) { if ( $ this -> cellExists ( $ aReferences [ $ i ] ) ) { $ this -> getCell ( $ aReferences [ $ i ] ) -> setValueExplicit ( null , DataType :: TYPE_NULL ) ; } } } else { throw new Exception ( 'Merge must be set on a range of cells.' ) ; } return $ this ; }
11091	public static function gpsDistance ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) { $ lat1 = deg2rad ( $ lat1 ) ; $ lon1 = deg2rad ( $ lon1 ) ; $ lat2 = deg2rad ( $ lat2 ) ; $ lon2 = deg2rad ( $ lon2 ) ; $ lonDelta = $ lon2 - $ lon1 ; $ a = ( ( cos ( $ lat2 ) * sin ( $ lonDelta ) ) ** 2 ) + ( ( cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lonDelta ) ) ** 2 ) ; $ b = sin ( $ lat1 ) * sin ( $ lat2 ) + cos ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lonDelta ) ; return atan2 ( sqrt ( $ a ) , $ b ) * 6371.0088 ; }
9727	public function logRead ( $ format , $ path , $ callStartTime ) { $ callEndTime = microtime ( true ) ; $ callTime = $ callEndTime - $ callStartTime ; $ message = "Read {$format} format from <code>{$path}</code> in " . sprintf ( '%.4f' , $ callTime ) . ' seconds' ; $ this -> log ( $ message ) ; }
6268	public function isAcademic ( $ text ) { if ( empty ( $ text ) ) { return false ; } $ domain = $ this -> getDomain ( $ text ) ; if ( $ domain === null ) { return false ; } foreach ( $ this -> getBlacklistedTopLevelDomains ( ) as $ blacklistedDomain ) { $ name = ( string ) $ domain [ 'host' ] ; if ( preg_match ( '/' . preg_quote ( $ blacklistedDomain ) . '$/' , $ name ) ) { return false ; } } if ( in_array ( $ domain [ 'tld' ] , $ this -> getAcademicTopLevelDomains ( ) ) ) { return true ; } if ( $ this -> matchesAcademicDomain ( $ domain ) ) { return true ; } return false ; }
5174	public function get ( string $ key ) { return isset ( $ this -> props [ $ key ] ) ? $ this -> props [ $ key ] : null ; }
7981	public function getSessionFilesProperties ( $ sessId , $ fileId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionFilesProperties ( $ this -> pp , $ this -> sn , $ sessId , $ fileId ) ) ; }
12733	public function register ( array $ signals , $ callableArray = null ) { foreach ( $ signals as $ signal ) { if ( ! in_array ( $ signal , $ this -> _signals , true ) ) { $ signalName = static :: getSignalName ( $ signal ) ; throw new InvalidArgumentException ( "Signal [{$signalName}] is not supported. Use setSignals() to add support." , $ signal ) ; } } $ reg = new Listener ( $ signals ) ; $ reg -> setNotification ( $ callableArray ) ; $ this -> _byId [ $ reg -> id ] = $ reg ; foreach ( $ signals as $ signal ) { $ this -> _bySignal [ $ signal ] [ $ reg -> id ] = $ reg ; } return $ reg ; }
2217	public function getChannels ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> newsletters ) ) { return array ( ) ; } $ arrChannels = array ( ) ; $ objChannels = $ this -> Database -> execute ( "SELECT id, title FROM tl_newsletter_channel ORDER BY title" ) ; while ( $ objChannels -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objChannels -> id , 'newsletters' ) ) { $ arrChannels [ $ objChannels -> id ] = $ objChannels -> title ; } } return $ arrChannels ; }
9615	public function addManagerRegistry ( ManagerRegistry $ registry ) { if ( ! in_array ( $ registry , $ this -> registries , true ) ) { $ this -> registries [ ] = $ registry ; } }
613	protected function build ( $ class , $ params , $ config ) { list ( $ reflection , $ dependencies ) = $ this -> getDependencies ( $ class ) ; foreach ( $ params as $ index => $ param ) { $ dependencies [ $ index ] = $ param ; } $ dependencies = $ this -> resolveDependencies ( $ dependencies , $ reflection ) ; if ( ! $ reflection -> isInstantiable ( ) ) { throw new NotInstantiableException ( $ reflection -> name ) ; } if ( empty ( $ config ) ) { return $ reflection -> newInstanceArgs ( $ dependencies ) ; } $ config = $ this -> resolveDependencies ( $ config ) ; if ( ! empty ( $ dependencies ) && $ reflection -> implementsInterface ( 'yii\base\Configurable' ) ) { $ dependencies [ count ( $ dependencies ) - 1 ] = $ config ; return $ reflection -> newInstanceArgs ( $ dependencies ) ; } $ object = $ reflection -> newInstanceArgs ( $ dependencies ) ; foreach ( $ config as $ name => $ value ) { $ object -> $ name = $ value ; } return $ object ; }
7456	private function ensureDirectoryExists ( $ path ) { if ( ! is_dir ( $ path ) ) { if ( ! mkdir ( $ path , 0777 , true ) ) { throw new \ RuntimeException ( sprintf ( 'Could not create directory "%s"' , $ path ) ) ; } } return $ path ; }
2099	public static function getNumericDateFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> dateFormat != '' && static :: isNumericFormat ( $ objPage -> dateFormat ) ) { return $ objPage -> dateFormat ; } } return Config :: get ( 'dateFormat' ) ; }
10418	public static function extract ( $ yamlArray , $ key , $ needed = false ) { if ( ! empty ( $ yamlArray ) && array_key_exists ( $ key , $ yamlArray ) ) return $ yamlArray [ $ key ] ; if ( $ needed ) { throw new \ Deployer \ Exception \ Exception ( 'Cannot find the setting: ' . $ key . '. This key needs to be given!' ) ; } return null ; }
11818	public function setServiceLocator ( ServiceLocatorInterface $ serviceLocator ) { $ this -> serviceLocator = $ serviceLocator ; $ config = $ serviceLocator -> getServiceLocator ( ) -> get ( 'config' ) ; if ( isset ( $ config [ 'rznviewcomponent' ] ) ) { $ this -> config = $ config [ 'rznviewcomponent' ] ; } return $ this ; }
10345	protected function applyStepping ( $ range , $ step ) { if ( $ step === false || $ step === 1 ) { return $ range ; } foreach ( $ range as $ value => $ tmp ) { if ( ( $ value % $ step ) !== 0 ) { unset ( $ range [ $ value ] ) ; } } return array_values ( $ range ) ; }
3729	protected function getAttributeImplementing ( $ interface ) { $ result = array ( ) ; foreach ( $ this -> getAttributes ( ) as $ colName => $ attribute ) { if ( $ attribute instanceof $ interface ) { $ result [ $ colName ] = $ attribute ; } } return $ result ; }
9628	protected function validateParams ( Route $ route , array $ params , array $ requiredParams ) { $ identifier = $ this -> getRouteIdentifier ( $ route ) ; $ givenParams = array_keys ( $ params ) ; $ missingParams = array_diff ( $ requiredParams , $ givenParams ) ; if ( count ( $ missingParams ) > 0 ) { throw new \ InvalidArgumentException ( sprintf ( 'Error while validating params "%s": Required parameters "%s" are missing' , $ identifier , implode ( ', ' , $ missingParams ) ) ) ; } if ( ! $ this -> matchParams ( $ route , $ params ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Error while validing params for target "%s": Params don\'t fulfill their matcher\'s criteria' , $ identifier ) ) ; } }
904	public function isUnarySuccessorOperator ( $ index ) { static $ allowedPrevToken = [ ']' , [ T_STRING ] , [ T_VARIABLE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , ] ; $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_INC , T_DEC ] ) ) { return false ; } $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; return $ prevToken -> equalsAny ( $ allowedPrevToken ) ; }
11419	protected function getValues ( $ fields , $ preCalculatedResult = false ) { if ( $ preCalculatedResult ) { return $ preCalculatedResult ; } $ app = App :: getInstance ( ) ; $ sql = $ this -> constructSelectSQL ( $ fields ) ; $ item = $ this -> getCache ( $ fields [ $ this -> pk ] ) ; $ results = $ item -> get ( \ Stash \ Invalidation :: PRECOMPUTE , 300 ) ; if ( $ item -> isMiss ( ) ) { $ results = $ this -> runGetRow ( $ sql ) ; if ( $ app [ 'db' ] -> last_error ) { throw new SQLException ( $ app [ 'db' ] -> last_error , $ app [ 'db' ] -> captured_errors ) ; } if ( is_null ( $ results ) ) { throw new ModelNotFoundException ( 'No model in database' , $ this -> dbtable , $ this -> constructorId ) ; } $ app [ 'cache' ] -> save ( $ item -> set ( $ results ) ) ; } return $ results ; }
252	public function removeAllFlashes ( ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; foreach ( array_keys ( $ counters ) as $ key ) { unset ( $ _SESSION [ $ key ] ) ; } unset ( $ _SESSION [ $ this -> flashParam ] ) ; }
3681	public function getJumpTo ( ) { if ( ! isset ( $ this -> arrJumpTo ) ) { $ page = $ GLOBALS [ 'objPage' ] ; $ this -> setJumpTo ( $ page -> row ( ) ) ; if ( $ this -> metamodel_jumpTo ) { $ statement = $ this -> getConnection ( ) -> prepare ( 'SELECT id, alias FROM tl_page WHERE id=? LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ this -> metamodel_jumpTo ) ; $ statement -> execute ( ) ; if ( $ statement -> rowCount ( ) ) { $ this -> setJumpTo ( $ statement -> fetch ( \ PDO :: FETCH_ASSOC ) ) ; } } } return $ this -> arrJumpTo ; }
10978	protected function setVerificationCode ( $ code = null ) { $ this -> { Config :: get ( 'verifier.store_column' ) } = $ code ; if ( $ code ) { $ this -> { Config :: get ( 'verifier.flag_column' ) } = false ; } else { $ this -> { Config :: get ( 'verifier.flag_column' ) } = true ; } $ this -> save ( ) ; }
10987	public static function D ( $ value , $ options = array ( ) ) { if ( is_numeric ( $ options ) ) { $ options = array ( 'depth' => $ options ) ; } elseif ( empty ( $ options ) ) { $ options = array ( ) ; } $ plop = new Dumpling ( $ options ) ; return $ plop -> dump ( $ value ) ; }
11432	protected function head ( $ path , array $ parameters = array ( ) , $ requestHeaders = array ( ) ) { if ( array_key_exists ( 'ref' , $ parameters ) && is_null ( $ parameters [ 'ref' ] ) ) { unset ( $ parameters [ 'ref' ] ) ; } $ response = $ this -> client -> getHttpClient ( ) -> request ( $ path , null , 'HEAD' , $ requestHeaders , array ( 'query' => $ parameters ) ) ; return $ response ; }
1388	protected function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotSupportClientIds ( $ type , $ path ) ) ; }
1317	public function delete ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'DELETE' , self :: API_HOST , $ path , $ parameters , false ) ; }
5828	public function newRequest ( $ method , $ url , $ data = array ( ) , $ encoding = Request :: ENCODING_QUERY ) { $ class = $ this -> requestClass ; $ request = new $ class ( $ this ) ; $ request -> setMethod ( $ method ) ; $ request -> setUrl ( $ url ) ; $ request -> setData ( $ data ) ; $ request -> setEncoding ( $ encoding ) ; return $ request ; }
12627	public function format ( $ format = null ) { if ( null === $ format ) { $ format = $ this -> _format ; } return parent :: format ( $ format ) ; }
908	private function isShortArray ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> equals ( '[' ) ) { return false ; } static $ disallowedPrevTokens = [ ')' , ']' , '}' , '"' , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_STRING ] , [ T_STRING_VARNAME ] , [ T_VARIABLE ] , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return false ; } $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; if ( $ nextToken -> equals ( ']' ) ) { return true ; } return ! $ this -> isArrayDestructing ( $ tokens , $ index ) ; }
9246	private function replaceOnce ( $ search , $ replace , $ subject ) { $ pos = strpos ( $ subject , $ search ) ; if ( $ pos !== false ) { $ subject = substr_replace ( $ subject , $ replace , $ pos , strlen ( $ search ) ) ; } return $ subject ; }
8109	protected function getWithDefault ( $ field ) { $ value = $ this -> owner -> getField ( $ field ) ; if ( $ value ) { return $ value ; } $ defaults = $ this -> owner -> config ( ) -> get ( 'defaults' ) ; if ( isset ( $ defaults [ $ field ] ) ) { return $ defaults [ $ field ] ; } }
2419	protected function addTemplatesToArchive ( ZipWriter $ objArchive , $ strFolder ) { $ strFolder = preg_replace ( '@^templates/@' , '' , $ strFolder ) ; if ( $ strFolder == '' ) { $ strFolder = 'templates' ; } else { $ strFolder = 'templates/' . $ strFolder ; } if ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new \ RuntimeException ( 'Insecure path ' . $ strFolder ) ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { return ; } foreach ( scan ( $ this -> strRootDir . '/' . $ strFolder ) as $ strFile ) { if ( preg_match ( '/\.(html5|sql)$/' , $ strFile ) && strncmp ( $ strFile , 'be_' , 3 ) !== 0 && strncmp ( $ strFile , 'nl_' , 3 ) !== 0 ) { $ objArchive -> addFile ( $ strFolder . '/' . $ strFile ) ; } } }
1920	private function getSqlDefinitions ( ) : array { $ this -> framework -> initialize ( ) ; $ installer = $ this -> framework -> createInstance ( Installer :: class ) ; $ sqlTarget = $ installer -> getFromDca ( ) ; $ sqlLegacy = $ installer -> getFromFile ( ) ; if ( ! empty ( $ sqlLegacy ) ) { foreach ( $ sqlLegacy as $ table => $ categories ) { foreach ( $ categories as $ category => $ fields ) { if ( \ is_array ( $ fields ) ) { foreach ( $ fields as $ name => $ sql ) { $ sqlTarget [ $ table ] [ $ category ] [ $ name ] = $ sql ; } } else { $ sqlTarget [ $ table ] [ $ category ] = $ fields ; } } } } if ( $ filter = $ this -> doctrine -> getConnection ( ) -> getConfiguration ( ) -> getFilterSchemaAssetsExpression ( ) ) { foreach ( array_keys ( $ sqlTarget ) as $ key ) { if ( ! preg_match ( $ filter , $ key ) ) { unset ( $ sqlTarget [ $ key ] ) ; } } } return $ sqlTarget ; }
10616	protected function setLifetime ( Response $ response , $ lifetime ) { if ( $ lifetime >= 0 ) { $ date = clone $ response -> getDate ( ) ; $ response -> setMaxAge ( $ lifetime ) -> setExpires ( $ date -> modify ( sprintf ( '+%s seconds' , $ lifetime ) ) ) ; if ( ! $ response -> headers -> hasCacheControlDirective ( 'private' ) ) { $ response -> setPublic ( ) -> setSharedMaxAge ( $ lifetime ) ; } } return $ this ; }
3646	public function clean ( $ value , bool $ trim = true , bool $ clean = true ) { if ( is_bool ( $ value ) || is_int ( $ value ) || is_float ( $ value ) ) { return $ value ; } $ final = null ; if ( $ value !== null ) { if ( is_array ( $ value ) ) { $ all = $ value ; $ final = [ ] ; foreach ( $ all as $ key => $ value ) { if ( $ value !== null ) { $ final [ $ key ] = $ this -> clean ( $ value , $ trim , $ clean ) ; } } } else { if ( $ value !== null ) { $ final = $ this -> process ( ( string ) $ value , $ trim , $ clean ) ; } } } return $ final ; }
6572	protected function registerCommands ( ) { $ this -> app [ 'command.countries.migration' ] = $ this -> app -> share ( function ( $ app ) { return new MigrationCommand ( $ app ) ; } ) ; $ this -> commands ( 'command.countries.migration' ) ; }
11403	public function getAppCodeUnlimit ( $ scene , $ width = 430 , $ autoColor = false , $ lineColor = [ 'r' => 0 , 'g' => 0 , 'b' => 0 ] ) { $ params = [ 'scene' => $ scene , 'width' => $ width , 'auto_color' => $ autoColor , 'line_color' => $ lineColor , ] ; return $ this -> getStream ( self :: API_GET_WXACODE_UNLIMIT , $ params ) ; }
8128	public static function findByPasswordResetToken ( $ id , $ code ) { if ( ! static :: isPasswordResetTokenValid ( $ code ) ) { return NULL ; } return static :: findOne ( [ 'id' => $ id , 'password_reset_token' => $ code , 'status' => self :: STATUS_ACTIVE , ] ) ; }
2870	public function getExtensionStatus ( ) { $ status = array ( ) ; $ extensions = $ this -> getExtensionRequirements ( ) ; foreach ( $ extensions as $ extension ) { $ status [ $ extension ] = extension_loaded ( $ extension ) ; } return $ status ; }
3185	public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ itemDuration = null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = $ this -> getRequestParameter ( 'start' ) !== false ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ this -> getTime ( ) ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> skip ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } if ( $ start == true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
8180	public function setDefaultStrategy ( $ defaultStrategy ) { if ( true === $ defaultStrategy ) { @ trigger_error ( 'Using "true" as the default strategy is deprecated since version 1.21. Use "html" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'html' ; } if ( 'filename' === $ defaultStrategy ) { @ trigger_error ( 'Using "filename" as the default strategy is deprecated since version 1.27. Use "name" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'name' ; } if ( 'name' === $ defaultStrategy ) { $ defaultStrategy = array ( 'Twig_FileExtensionEscapingStrategy' , 'guess' ) ; } $ this -> defaultStrategy = $ defaultStrategy ; }
10914	public function execute ( ) { try { $ this -> output_buffer_level = ob_get_level ( ) ; ob_start ( ) ; $ response = $ this -> doExecute ( ) ; if ( ( is_object ( $ response ) && ! ( $ response instanceof Response ) ) || ( is_string ( $ response ) && class_exists ( $ response ) ) ) { $ response = $ this -> reflect ( $ response ) ; } if ( $ response instanceof Response ) throw $ response ; throw new HTTPError ( 500 , "App did not produce any response" ) ; } catch ( Response $ response ) { self :: $ logger -> debug ( "Response type {0} returned from controller: {1}" , [ get_class ( $ response ) , $ this -> app ] ) ; throw $ response ; } catch ( Throwable $ e ) { self :: $ logger -> debug ( "While executing controller: {0}" , [ $ this -> app ] ) ; self :: $ logger -> notice ( "Unexpected exception of type {0} thrown while processing request: {1}" , [ get_class ( $ e ) , $ e ] ) ; throw $ e ; } finally { $ this -> logScriptOutput ( ) ; } }
4404	public function getPath ( $ locationId ) { $ pathArray = array ( ) ; $ startingLocation = $ this -> locationService -> loadLocation ( $ locationId ) ; $ path = $ startingLocation -> path ; array_shift ( $ path ) ; $ rootLocationFound = false ; foreach ( $ path as $ index => $ pathItem ) { if ( ( int ) $ pathItem === $ this -> rootLocationId ) { $ rootLocationFound = true ; } if ( ! $ rootLocationFound ) { continue ; } try { $ location = $ this -> locationService -> loadLocation ( $ pathItem ) ; } catch ( UnauthorizedException $ e ) { return array ( ) ; } $ pathArray [ ] = array ( 'text' => $ this -> translationHelper -> getTranslatedContentNameByContentInfo ( $ location -> contentInfo ) , 'url' => $ location -> id !== $ startingLocation -> id ? $ this -> router -> generate ( $ location ) : false , 'locationId' => $ location -> id , 'contentId' => $ location -> contentId , ) ; } return $ pathArray ; }
11030	public function getSubmitModelName ( $ attribute ) { return empty ( $ this -> submitModelName ) ? Html :: getInputName ( $ this -> model , $ attribute ) : $ this -> submitModelName . "[$attribute]" ; }
1533	protected function isFillableRelation ( $ field , $ record ) { return $ this -> isRelation ( $ field ) && $ this -> isFillable ( $ field , $ record ) ; }
902	public function isAnonymousClass ( $ index ) { $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isClassy ( ) ) { throw new \ LogicException ( sprintf ( 'No classy token at given index %d.' , $ index ) ) ; } if ( ! $ token -> isGivenKind ( T_CLASS ) ) { return false ; } return $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_NEW ) ; }
12540	public static function camelize ( $ str , $ ucfirst = false ) { $ replace = str_replace ( ' ' , '' , ucwords ( str_replace ( [ '_' , '-' ] , ' ' , strtolower ( $ str ) ) ) ) ; if ( ! $ ucfirst ) { return lcfirst ( $ replace ) ; } return $ replace ; }
7551	function hasAttribute ( $ attr , $ compare = 'total' , $ case_sensitive = false ) { return ( ( bool ) $ this -> findAttribute ( $ attr , $ compare , $ case_sensitive ) ) ; }
11645	function addOperationGetter ( $ methodName , OperationDefinition $ operation , OperationGenerator $ operationGenerator ) { $ operationName = $ this -> normalizeMethodName ( $ methodName ) ; $ operationClassName = $ this -> normalizeClassName ( $ methodName ) ; $ methodGenerator = new MethodGenerator ( $ operationName ) ; $ apiParameters = $ this -> getAPIParameters ( ) ; $ body = '' ; $ requiredParameters = $ operation -> getRequiredParams ( ) ; $ paramsStrings = [ ] ; $ requiredParamsStringsWithDollar = [ ] ; $ tags = [ ] ; $ requiredParamsStringsWithDollar [ ] = '$this' ; foreach ( $ requiredParameters as $ requiredParam ) { $ translatedParam = ucfirst ( $ this -> translateParameter ( $ requiredParam -> getName ( ) ) ) ; $ normalizedParamName = normalizeParamName ( $ requiredParam -> getName ( ) ) ; if ( array_key_exists ( $ requiredParam -> getName ( ) , $ apiParameters ) == true ) { $ requiredParamsStringsWithDollar [ ] = sprintf ( '$this->get%s()' , $ translatedParam ) ; } else { $ paramsStrings [ ] = $ normalizedParamName ; $ tags [ ] = new GenericTag ( 'param' , $ requiredParam -> getType ( ) . ' $' . $ requiredParam -> getName ( ) . ' ' . $ requiredParam -> getDescription ( ) ) ; $ requiredParamsStringsWithDollar [ ] = '$' . $ normalizedParamName ; } } $ paramString = implode ( ', ' , $ requiredParamsStringsWithDollar ) ; $ methodGenerator -> setParameters ( $ paramsStrings ) ; $ tags [ ] = new GenericTag ( 'return' , '\\' . $ operationGenerator -> getFQCN ( ) . ' The new operation ' ) ; $ body .= "\$instance = new $operationClassName($paramString);" . PHP_EOL ; $ body .= "return \$instance;" . PHP_EOL ; $ docBlockGenerator = new DocBlockGenerator ( $ methodName ) ; $ docBlockGenerator -> setLongDescription ( $ operation -> getSummary ( ) ) ; $ docBlockGenerator -> setTags ( $ tags ) ; $ methodGenerator -> setDocBlock ( $ docBlockGenerator ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; $ this -> interfaceGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
2072	public function getAllowedArchives ( ) { if ( $ this -> User -> isAdmin ) { $ objArchive = Contao \ NewsArchiveModel :: findAll ( ) ; } else { $ objArchive = Contao \ NewsArchiveModel :: findMultipleByIds ( $ this -> User -> news ) ; } $ return = array ( ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { $ return [ $ objArchive -> id ] = $ objArchive -> title ; } } return $ return ; }
7503	public function tf ( string $ key , array $ args = null , array $ replacements = null , string ... $ namespaces ) { $ this -> view -> out ( $ this -> getTf ( $ key , $ args , $ replacements , ... $ namespaces ) ) ; }
8086	private function cleanConsole ( ) { $ channel = $ this -> namespaceChannel ( $ this -> currentChannel ) ; if ( empty ( $ this -> console [ 'errors' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'errors' ] [ $ channel ] ) ; } if ( empty ( $ this -> console [ 'form' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'form' ] [ $ channel ] ) ; } if ( empty ( $ this -> console [ 'reports' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'reports' ] [ $ channel ] ) ; } }
5542	protected function clearNestedFramesFocus ( ) { for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ this -> frames [ $ i ] -> clearFrameFocus ( ) ; } }
1460	protected function orderDesc ( ) { $ this -> query -> orderByDesc ( $ this -> column ) ; if ( $ this -> isNotPagingOnKey ( ) ) { $ this -> query -> orderByDesc ( $ this -> key ) ; } return $ this ; }
7288	public function setColumnForLinksLabels ( $ columnNameOrClosure ) { if ( ! is_string ( $ columnNameOrClosure ) && ! ( $ columnNameOrClosure instanceof DbExpr ) ) { throw new \ InvalidArgumentException ( '$columnNameOrClosure argument must be a string or a closure' ) ; } $ this -> columnForLinksLabels = $ columnNameOrClosure ; return $ this ; }
5201	public function buildConnectionOptions ( ) { $ connection_name = $ this -> config -> get ( "tail-settings.default" ) ; if ( $ this -> connection_name ) $ connection_name = $ this -> connection_name ; $ connectionOptions = $ this -> config -> get ( "tail-settings.connections.$connection_name" ) ; if ( ! isset ( $ connectionOptions [ 'exchange_type' ] ) ) $ connectionOptions [ 'exchange_type' ] = 'direct' ; if ( ! isset ( $ connectionOptions [ 'content_type' ] ) ) $ connectionOptions [ 'content_type' ] = 'text/plain' ; if ( $ this -> vhost ) $ connectionOptions [ 'vhost' ] = $ this -> vhost ; if ( $ this -> exchange ) $ connectionOptions [ 'exchange' ] = $ this -> exchange ; if ( $ this -> exchange_type ) $ connectionOptions [ 'exchange_type' ] = $ this -> exchange_type ; if ( $ this -> content_type ) $ connectionOptions [ 'content_type' ] = $ this -> content_type ; $ connectionOptions [ 'queue_name' ] = $ this -> queue_name ; return $ connectionOptions ; }
11852	protected function setLayout ( string $ layoutName ) : void { if ( is_null ( $ this -> view ) ) { throw new Exception ( "It's unable to set Layout without View." ) ; } $ this -> layout = ViewFactory :: createLayout ( $ layoutName , $ this -> view ) ; }
5580	public function submitFormById ( $ id , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormById ( $ id ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submit ( $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
3380	public function getModel ( $ entity ) { if ( \ Links :: isMain ( $ entity ) ) { $ modelClass = 'Serverfireteam\\Panel\\' . $ entity ; } else { if ( ! empty ( \ Config :: get ( 'panel.modelPath' ) ) ) { $ modelClass = $ this -> getNameSpace ( ) . \ Config :: get ( 'panel.modelPath' ) . '\\' . $ entity ; } else { $ modelClass = $ this -> getNameSpace ( ) . $ entity ; } } return $ modelClass ; }
6881	public function reverseTransform ( $ address ) { if ( null === $ address ) { return null ; } if ( ! $ address instanceof ShipmentAddress ) { throw new InvalidArgumentException ( "Expected instance of " . ShipmentAddress :: class ) ; } $ data = [ ] ; foreach ( $ this -> fields as $ field ) { $ value = $ this -> accessor -> getValue ( $ address , $ field ) ; if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof CountryInterface ) { $ value = $ value -> getId ( ) ; } elseif ( $ value instanceof StateInterface ) { $ value = $ value -> getId ( ) ; } elseif ( $ value instanceof PhoneNumber ) { $ value = serialize ( $ value ) ; } $ data [ $ field ] = $ value ; } if ( empty ( $ data ) ) { return null ; } return $ data ; }
2673	public function getSingleAcl ( $ version , $ acl ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/acl/' . $ acl ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
11397	public static function parseFault ( \ SimpleXMLElement $ fault ) { $ faultData = static :: parseStruct ( $ fault -> value -> struct ) ; return new \ Devedge \ XmlRpc \ Client \ RemoteException ( $ faultData [ 'faultString' ] , $ faultData [ 'faultCode' ] ) ; }
10186	private static function fromArray ( $ object , $ type = null , $ innerType = null ) { if ( $ type == 'array' ) { foreach ( $ object as $ element ) { $ result [ ] = self :: fromArray ( $ element , $ innerType ) ; } return $ result ; } else if ( class_exists ( $ type ) ) { $ class = new $ type ( ) ; if ( is_subclass_of ( $ class , 'AbstractJSONWrapper' ) ) { $ class -> fromArray ( $ object ) ; return $ class ; } else { trigger_error ( __CLASS__ . ": Trying to deserialize " . get_class ( $ class ) ) ; return $ object ; } } else { return $ object ; } }
4067	public function get ( $ strName ) { return isset ( $ this -> arrBase [ $ strName ] ) ? $ this -> arrBase [ $ strName ] : null ; }
10222	public function authenticationForm ( $ title , $ target ) { $ formFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\AuthenticationFormFactory' ) ; return $ formFactory -> create ( $ title , $ target ) ; }
4183	public function fileHas ( $ contains ) { $ this -> files = ( new ClassIterator ( $ this -> finder -> contains ( $ contains ) ) ) -> getClassMap ( ) ; $ this -> count = count ( $ this -> files ) ; return $ this ; }
10529	protected function normalizeProxyHeader ( $ header ) { $ header = strtoupper ( $ header ) ; $ header = str_replace ( '-' , '_' , $ header ) ; if ( 0 !== strpos ( $ header , 'HTTP_' ) ) { $ header = 'HTTP_' . $ header ; } return $ header ; }
10142	private function readDefault ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ this -> pos += 4 + $ length ; }
2088	public static function initialize ( ) { $ objFilesystem = new Filesystem ( ) ; $ container = System :: getContainer ( ) ; $ strCacheDir = $ container -> getParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ strCacheDir . '/contao/config/templates.php' ) ) { self :: addFiles ( include $ strCacheDir . '/contao/config/templates.php' ) ; } else { try { foreach ( System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> name ( '*.html5' ) as $ file ) { self :: addFile ( $ file -> getBasename ( '.html5' ) , rtrim ( $ objFilesystem -> makePathRelative ( $ file -> getPath ( ) , $ container -> getParameter ( 'kernel.project_dir' ) ) , '/' ) ) ; } } catch ( \ InvalidArgumentException $ e ) { } } }
6956	private function calculatePaymentBase ( SupplierOrderInterface $ order ) { $ base = $ this -> calculateItemsTotal ( $ order ) + $ order -> getShippingCost ( ) - $ order -> getDiscountTotal ( ) ; $ currency = $ order -> getCurrency ( ) -> getCode ( ) ; return Money :: round ( $ base , $ currency ) ; }
7359	public static function getDefaultPriceMapLoader ( ) { if ( null === self :: $ defaultPriceMapLoader ) { $ currencyDir = realpath ( __DIR__ . '/../../../data/prices' ) ; self :: $ defaultPriceMapLoader = new PhpFileLoader ( array ( $ currencyDir ) ) ; } return self :: $ defaultPriceMapLoader ; }
11002	public function setRedirect ( $ hostname ) { if ( ! empty ( $ hostname ) ) { $ this -> redirect = new URL ( $ hostname ) ; $ this -> redirect -> set ( 'path' , rtrim ( $ this -> redirect -> path , '/' ) ) ; } else $ this -> redirect = false ; return $ this ; }
8584	public function setASIN ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ASIN' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5712	public function addnew ( HTTPRequest $ r ) { return Controller :: curr ( ) -> redirect ( Controller :: join_links ( $ this -> owner -> gridField -> Link ( "item" ) , "new" ) ) ; }
4383	protected function buildArgString ( $ args ) { $ numArgs = \ count ( $ args ) ; if ( $ numArgs == 1 && \ is_string ( $ args [ 0 ] ) ) { $ args [ 0 ] = \ strip_tags ( $ args [ 0 ] ) ; } foreach ( $ args as $ k => $ v ) { if ( $ k > 0 || ! \ is_string ( $ v ) ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ this -> valDepth = 0 ; } $ glue = ', ' ; $ glueAfterFirst = true ; if ( $ numArgs && \ is_string ( $ args [ 0 ] ) ) { if ( \ preg_match ( '/[=:] ?$/' , $ args [ 0 ] ) ) { $ glueAfterFirst = false ; } elseif ( \ count ( $ args ) == 2 ) { $ glue = ' = ' ; } } if ( ! $ glueAfterFirst ) { return $ args [ 0 ] . \ implode ( $ glue , \ array_slice ( $ args , 1 ) ) ; } else { return \ implode ( $ glue , $ args ) ; } }
6090	public function addMediaToMoodboard ( $ moodboardId , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards/' . $ moodboardId . '/media' , $ parameters ) ; return $ result ; }
7836	protected function deleteAllFilesOfWorkflowIfForced ( $ workflow ) { $ files = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ files [ ] = $ this -> inflector -> getRequest ( ) ; $ files [ ] = $ this -> inflector -> getJob ( ) ; $ this -> deleteIfForced ( $ files ) ; }
6586	protected function request ( array $ options ) { $ this -> info = null ; $ this -> setOpt ( $ options ) ; $ result = $ this -> perform ( 'curl_exec' ) ; $ this -> info = $ this -> perform ( 'curl_getinfo' ) ; return $ result ; }
7667	function InlineImageExists ( ) { $ result = false ; for ( $ i = 0 ; $ i < count ( $ this -> attachment ) ; $ i ++ ) { if ( $ this -> attachment [ $ i ] [ 6 ] == "inline" ) { $ result = true ; break ; } } return $ result ; }
6810	public function rates ( Adjustment ... $ adjustments ) : string { return implode ( ', ' , array_map ( function ( Adjustment $ adjustment ) { return $ this -> percent ( $ adjustment -> getRate ( ) ) ; } , $ adjustments ) ) ; }
12552	private function addHeaders ( ) { self :: response ( ) -> addHeader ( 'Cache-Control' , 'no-cache, no-store, must-revalidate' ) ; self :: response ( ) -> addHeader ( 'Pragma' , 'no-cache' ) ; self :: response ( ) -> addHeader ( 'Expires' , '-1' ) ; }
12004	public static function objectToArray ( $ mObject ) : array { if ( is_object ( $ mObject ) ) { $ mObject = ( array ) $ mObject ; } if ( is_array ( $ mObject ) ) { $ aNew = array ( ) ; foreach ( $ mObject as $ sKey => $ mValues ) { $ sKey = preg_replace ( "/^\\0(.*)\\0/" , "" , $ sKey ) ; $ aNew [ $ sKey ] = self :: objectToArray ( $ mValues ) ; } } else { $ aNew = $ mObject ; } return $ aNew ; }
4885	public function setExcludeMethods ( $ methods ) { if ( is_string ( $ methods ) ) { $ methods = array ( $ methods ) ; } foreach ( $ methods as $ method ) { $ this -> addFilter ( $ method , new MethodMatchFilter ( $ method ) , FilterComposite :: CONDITION_AND ) ; } }
5767	private function create ( ) { $ m = new \ PHPMailer ( ) ; switch ( $ this -> protocol ) { case 'sendmail' : $ m -> isSendmail ( ) ; break ; case 'smtp' : $ m -> isSMTP ( ) ; $ m -> Host = $ this -> smtpHost ; $ m -> SMTPAuth = false ; $ m -> SMTPAutoTLS = false ; $ m -> Port = $ this -> smtpPort ; break ; case 'mail' : $ m -> isMail ( ) ; break ; case 'qmail' : $ m -> isQmail ( ) ; break ; default : throw new \ Exception ( 'bad phpmailerType: ' . $ this -> protocol ) ; } return $ m ; }
1008	public static function suggestionList ( $ input , array $ options ) { $ optionsByDistance = [ ] ; $ inputThreshold = mb_strlen ( $ input ) / 2 ; foreach ( $ options as $ option ) { if ( $ input === $ option ) { $ distance = 0 ; } else { $ distance = ( strtolower ( $ input ) === strtolower ( $ option ) ? 1 : levenshtein ( $ input , $ option ) ) ; } $ threshold = max ( $ inputThreshold , mb_strlen ( $ option ) / 2 , 1 ) ; if ( $ distance > $ threshold ) { continue ; } $ optionsByDistance [ $ option ] = $ distance ; } asort ( $ optionsByDistance ) ; return array_keys ( $ optionsByDistance ) ; }
12399	public function orderBy ( $ field , $ order = null ) { $ this -> scope -> orderBy [ ] = Parser :: orderBy ( $ field , $ order ) ; return $ this ; }
3227	function buildUrlForGetOrPut ( $ host , $ path , $ params = null ) { return RequestUtil :: buildUrlForGetOrPut ( $ this -> userLocale , $ host , $ path , $ params ) ; }
6857	protected static function equinoxSeptember ( $ year , $ vsop = true ) { $ month = 9 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
12650	protected function readFileContents ( $ language ) { $ fileName = $ this -> getFileName ( $ language ) ; $ fs = $ this -> env -> getFileSystem ( ) ; if ( ! $ fs -> fileExists ( $ fileName ) ) { return array ( ) ; } $ content = json_decode ( preg_replace ( '/^.*?define\((.*)\);\s*/s' , '$1' , $ fs -> getFile ( $ fileName ) ) , true ) ; if ( $ language === $ this -> baseLang ) { $ content = $ content [ 'root' ] ; } $ outdateInfo = [ ] ; $ fileName = $ this -> getOutdateInfoFileName ( $ language ) ; if ( $ fs -> fileExists ( $ fileName ) ) { $ outdateInfo = json_decode ( $ fs -> getFile ( $ fileName ) , true ) ; } foreach ( $ content as $ id => $ text ) { $ outdated = isset ( $ outdateInfo [ $ id ] ) ? $ outdateInfo [ $ id ] : true ; $ content [ $ id ] = array ( 'id' => $ id , 'name' => $ id , 'content' => $ text , 'outdated' => $ outdated ) ; } return $ content ; }
10811	protected function bindValues ( $ sql , array $ settings ) { $ bindings = & $ this -> bindings ; $ escape = $ this -> getEscapeCallable ( $ settings [ 'escapeFunction' ] ) ; $ params = $ this -> getBuilder ( ) -> getPlaceholderMapping ( ) ; $ function = function ( $ v ) use ( $ settings , & $ bindings , $ escape ) { if ( $ settings [ 'positionedParam' ] ) { $ bindings [ ] = $ v ; return '?' ; } elseif ( $ settings [ 'namedParam' ] && isset ( $ v [ 0 ] ) && ':' == $ v [ 0 ] ) { return $ v ; } elseif ( is_numeric ( $ v ) && ! is_string ( $ v ) ) { return $ v ; } else { return $ escape ( $ v ) ; } } ; return preg_replace_callback ( '/\b__PH_[0-9]++__\b/' , function ( $ m ) use ( & $ params , $ function ) { return $ function ( $ params [ $ m [ 0 ] ] ) ; } , $ sql ) ; }
9030	public function exception ( Request $ request ) { $ ex = $ request -> getException ( ) ; $ this -> response -> setCode ( 500 ) ; printf ( "<h2>%s</h2>" , HttpStatus :: getStatus ( 500 ) ) ; while ( $ ex != null ) { printf ( "<h3>%s</h3><pre>%s</pre>" , $ ex -> getMessage ( ) , $ ex -> getTraceAsString ( ) ) ; $ ex = $ ex -> getPrevious ( ) ; } }
7196	public function handleReleasedChange ( OrderInterface $ order ) { if ( $ this -> persistenceHelper -> isChanged ( $ order , 'sample' ) ) { if ( $ order -> isReleased ( ) && ! $ order -> isSample ( ) ) { throw new IllegalOperationException ( "Can't turn 'sample' into false if order is released." ) ; } } if ( ! $ this -> persistenceHelper -> isChanged ( $ order , 'released' ) ) { return false ; } if ( ! $ order -> isSample ( ) && $ order -> isReleased ( ) ) { $ order -> setReleased ( false ) ; return true ; } if ( ! OrderStates :: isStockableState ( $ order -> getState ( ) ) ) { return false ; } foreach ( $ order -> getItems ( ) as $ item ) { $ this -> applySaleItemRecursively ( $ item ) ; } return false ; }
3130	public function getServiceContext ( $ testDefinitionUri , $ testCompilationUri , $ testExecutionUri , $ userUri = null ) { $ serviceContext = new QtiRunnerServiceContext ( $ testDefinitionUri , $ testCompilationUri , $ testExecutionUri ) ; $ serviceContext -> setServiceManager ( $ this -> getServiceManager ( ) ) ; $ serviceContext -> setTestConfig ( $ this -> getTestConfig ( ) ) ; $ serviceContext -> setUserUri ( $ userUri ) ; $ sessionService = $ this -> getServiceManager ( ) -> get ( TestSessionService :: SERVICE_ID ) ; $ sessionService -> registerTestSession ( $ serviceContext -> getTestSession ( ) , $ serviceContext -> getStorage ( ) , $ serviceContext -> getCompilationDirectory ( ) ) ; return $ serviceContext ; }
2270	public function getSizeOf ( $ strTable ) { $ statement = $ this -> resConnection -> executeQuery ( 'SHOW TABLE STATUS LIKE ' . $ this -> resConnection -> quote ( $ strTable ) ) ; $ status = $ statement -> fetch ( \ PDO :: FETCH_ASSOC ) ; return $ status [ 'Data_length' ] + $ status [ 'Index_length' ] ; }
12273	public static function cast ( $ date ) { return $ date instanceof self ? $ date : new self ( $ date -> format ( self :: ISO8601 ) , $ date -> getTimezone ( ) ) ; }
7144	public static function remove_author_meta_values ( ) { global $ blog_id ; if ( isset ( $ blog_id ) && ! empty ( $ blog_id ) ) { $ blogusers = get_users ( array ( 'blog_id' => $ blog_id ) ) ; foreach ( $ blogusers as $ user_object ) { delete_user_meta ( $ user_object -> ID , 'post_subscription' ) ; delete_user_meta ( $ user_object -> ID , 'comment_subscription' ) ; } } }
1642	public static function fromString ( string $ string , Ellipsoid $ ellipsoid = null ) : Coordinate { $ string = self :: mergeSecondsToMinutes ( $ string ) ; $ result = self :: parseDecimalMinutesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalMinutesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } throw new InvalidArgumentException ( 'Format of coordinates was not recognized' ) ; }
3571	public function queryHook ( ) { return function ( $ next , $ query , $ bag ) { $ method = $ bag -> get ( 'method' ) ; $ args = $ bag -> get ( 'args' ) ; $ column = $ args -> get ( 'column' ) ; if ( ! $ this -> hasColumn ( $ column ) && $ this -> allowsMeta ( $ column ) && $ this -> isMetaQueryable ( $ method ) ) { return call_user_func_array ( [ $ this , 'metaQuery' ] , [ $ query , $ method , $ args ] ) ; } if ( in_array ( $ method , [ 'select' , 'addSelect' ] ) ) { call_user_func_array ( [ $ this , 'metaSelect' ] , [ $ query , $ args ] ) ; } return $ next ( $ query , $ bag ) ; } ; }
10184	function createContactFilter ( $ newFilterObject , $ createTargetGroup , $ version = 1.0 ) { if ( $ version == 1.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> put ( "contactfilters/contactfilter" , $ newFilterObject -> toXMLString ( ) , $ queryParameters ) ; } else if ( $ version == 2.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> post ( "contactfilters/v2" , $ newFilterObject , $ queryParameters , "application/json" ) ; } }
3528	public function getFriends ( ) { $ data = FortniteClient :: sendUnrealClientGetRequest ( FortniteClient :: EPIC_FRIENDS_ENDPOINT . $ this -> account_id , $ this -> access_token , true ) ; return $ data ; }
4870	private function entityToString ( EntityInterface $ entity ) { if ( method_exists ( $ entity , '__toString' ) ) { return $ entity -> __toString ( ) ; } $ str = get_class ( $ entity ) ; if ( $ entity instanceof \ Core \ Entity \ IdentifiableEntityInterface ) { $ str .= '( ' . $ entity -> getId ( ) . ' )' ; } return $ str ; }
12758	public static function getNew ( ) { $ class = new MediaLink ; $ medialink = get_class_vars ( get_class ( $ class ) ) ; foreach ( $ medialink as $ name => $ default ) : $ class :: set ( $ name , null ) ; $ class :: set ( "objectType" , "medialink" ) ; endforeach ; return $ class ; }
5760	public function getObjects ( array $ whereColumnsInfo = null , string $ orderBy = null ) : array { $ permissions = [ ] ; foreach ( $ this -> selectArray ( null , $ whereColumnsInfo , $ orderBy ) as $ permissionArray ) { $ permissions [ ] = $ this -> buildPermission ( $ permissionArray [ 'id' ] , $ permissionArray [ 'title' ] , $ permissionArray [ 'description' ] , $ permissionArray [ 'active' ] , $ permissionArray [ 'created' ] , $ permissionArray [ 'roles' ] ) ; } return $ permissions ; }
2376	public static function sanitizeFileName ( $ strName ) { $ strName = preg_replace ( '/[\pC]/u' , '' , $ strName ) ; if ( $ strName === null ) { throw new \ InvalidArgumentException ( 'The file name could not be sanitzied' ) ; } $ strName = str_replace ( array ( '\\' , '/' , ':' , '*' , '?' , '"' , '<' , '>' , '|' ) , '-' , $ strName ) ; return $ strName ; }
3058	public function containsAdaptive ( ) { $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ this -> getCompilationDirectory ( ) [ 'private' ] ) ; return ! empty ( $ adaptiveSectionMap ) ; }
4127	public function newDefaultAnnotationDriver ( $ paths = array ( ) ) { $ reader = new \ Doctrine \ Common \ Annotations \ SimpleAnnotationReader ( ) ; $ reader -> addNamespace ( 'Doctrine\ODM\CouchDB\Mapping\Annotations' ) ; return new \ Doctrine \ ODM \ CouchDB \ Mapping \ Driver \ AnnotationDriver ( $ reader , ( array ) $ paths ) ; }
6099	protected function put ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_PUT , null , $ fireAndForget ) ; }
3021	public function getBlogAvatar ( $ blogName , $ size = null ) { $ path = $ this -> blogPath ( $ blogName , '/avatar' ) ; if ( $ size ) { $ path .= "/$size" ; } return $ this -> getRedirect ( $ path , null , true ) ; }
8473	public function warning ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'warning' , $ scope , $ message , $ context , $ config ) ; }
1922	public static function fromFile ( File $ file ) { $ extension = strtolower ( $ file -> extension ) ; $ function = null ; if ( $ extension === 'jpg' ) { $ extension = 'jpeg' ; } if ( \ in_array ( $ extension , array ( 'gif' , 'jpeg' , 'png' ) ) ) { $ function = 'imagecreatefrom' . $ extension ; } if ( $ function === null || ! \ is_callable ( $ function ) ) { throw new \ InvalidArgumentException ( 'Image type "' . $ file -> extension . '" cannot be processed by GD' ) ; } $ image = $ function ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ file -> path ) ; if ( $ image === false ) { throw new \ RuntimeException ( 'Image "' . $ file -> path . '" failed to be processed by GD' ) ; } return new static ( $ image ) ; }
8499	public function updateFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10425	private function headers ( ResponseInterface $ response ) : void { if ( ! headers_sent ( ) ) { foreach ( $ response -> getHeaders ( ) as $ name => $ values ) { $ cookie = stripos ( $ name , 'Set-Cookie' ) === 0 ? false : true ; foreach ( $ values as $ value ) { header ( sprintf ( '%s: %s' , $ name , $ value ) , $ cookie ) ; $ cookie = false ; } } header ( sprintf ( 'HTTP/%s %s %s' , $ response -> getProtocolVersion ( ) , $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) , true , $ response -> getStatusCode ( ) ) ; } }
10293	protected static function validateTimeZone ( $ timeZone ) { if ( is_object ( $ timeZone ) && $ timeZone instanceof DateTimeZone ) { return $ timeZone ; } elseif ( is_string ( $ timeZone ) ) { return new DateTimeZone ( $ timeZone ) ; } throw new \ Exception ( 'Invalid timezone' ) ; }
539	protected function serializePagination ( $ pagination ) { return [ $ this -> linksEnvelope => Link :: serialize ( $ pagination -> getLinks ( true ) ) , $ this -> metaEnvelope => [ 'totalCount' => $ pagination -> totalCount , 'pageCount' => $ pagination -> getPageCount ( ) , 'currentPage' => $ pagination -> getPage ( ) + 1 , 'perPage' => $ pagination -> getPageSize ( ) , ] , ] ; }
10147	private function readPalette ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ nm = self :: getUInt2d ( $ recordData , 0 ) ; for ( $ i = 0 ; $ i < $ nm ; ++ $ i ) { $ rgb = substr ( $ recordData , 2 + 4 * $ i , 4 ) ; $ this -> palette [ ] = self :: readRGB ( $ rgb ) ; } } }
6777	protected function updateVatData ( SaleInterface $ sale ) { $ changed = false ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( 0 == strlen ( $ sale -> getVatNumber ( ) ) && 0 < strlen ( $ customer -> getVatNumber ( ) ) ) { $ sale -> setVatNumber ( $ customer -> getVatNumber ( ) ) ; $ changed = true ; } if ( empty ( $ sale -> getVatDetails ( ) ) && ! empty ( $ customer -> getVatDetails ( ) ) ) { $ sale -> setVatDetails ( $ customer -> getVatDetails ( ) ) ; $ changed = true ; } if ( ! $ sale -> isVatValid ( ) && $ customer -> isVatValid ( ) ) { $ sale -> setVatValid ( true ) ; $ changed = true ; } } return $ changed ; }
12076	public function childStore ( $ idParent , FilterRequest $ filters , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ resource = $ this -> repository -> storeChild ( $ idParent , $ relation , $ filters -> all ( ) ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
6722	public function fetchAccessToken ( $ code ) { $ this -> validateTokenParams ( ) ; $ this -> oauth2 -> tokenUrl = $ this -> tokenUrl ; $ this -> oauth2 -> clientId = $ this -> clientId ; $ this -> oauth2 -> clientSecret = $ this -> clientSecret ; try { $ response = $ this -> oauth2 -> fetchAccessToken ( $ code ) ; } catch ( Exception $ ex ) { throw new Oauth2ClientException ( $ ex -> getMessage ( ) ) ; } return $ this -> handleTokenResponse ( $ response ) ; }
8859	private function _hardCopy ( string $ originDir , string $ targetDir ) : string { $ this -> filesystem -> mkdir ( $ targetDir , 0777 ) ; $ this -> filesystem -> mirror ( $ originDir , $ targetDir , Finder :: create ( ) -> ignoreDotFiles ( false ) -> in ( $ originDir ) ) ; return AssetsInstallCommand :: METHOD_COPY ; }
2267	public function getFieldNames ( $ strTable , $ blnNoCache = false ) { $ arrNames = array ( ) ; $ arrFields = $ this -> listFields ( $ strTable , $ blnNoCache ) ; foreach ( $ arrFields as $ arrField ) { if ( $ arrField [ 'type' ] != 'index' ) { $ arrNames [ ] = $ arrField [ 'name' ] ; } } return $ arrNames ; }
11264	public function repeat ( & $ property , $ repeatTag , $ classes = '' , $ outerTag = false , $ outerClasses = '' ) { if ( isset ( $ property ) ) { $ output = '' ; if ( $ outerTag ) { $ output .= '<' . $ outerTag . ' class="' . $ outerClasses . '">' ; } if ( is_array ( $ property ) ) { foreach ( $ property as $ value ) { $ output .= '<' . $ repeatTag . ' class="' . $ classes . '">' ; $ output .= $ value ; $ output .= '</' . $ repeatTag . '>' ; } } else { $ output .= '<' . $ repeatTag . ' class="' . $ classes . '">' ; $ output .= $ property ; $ output .= '</' . $ repeatTag . '>' ; } if ( $ outerTag ) { $ output .= '</' . $ outerTag . '>' ; } echo $ output ; } else echo '' ; }
2118	public function generateSqlForm ( ) { @ trigger_error ( 'Using the Installer::generateSqlForm() method has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ count = 0 ; $ return = '' ; $ sql_command = $ this -> compileCommands ( ) ; if ( empty ( $ sql_command ) ) { return '' ; } $ _SESSION [ 'sql_commands' ] = array ( ) ; $ arrOperations = array ( 'CREATE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'CREATE' ] , 'ALTER_ADD' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_ADD' ] , 'ALTER_CHANGE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_CHANGE' ] , 'ALTER_DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_DROP' ] , 'DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'DROP' ] ) ; foreach ( $ arrOperations as $ command => $ label ) { if ( \ is_array ( $ sql_command [ $ command ] ) ) { $ return .= ' <tr> <td colspan="2" class="tl_col_0">' . $ label . '</td> </tr>' ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" id="check_all_' . $ count . '" class="tl_checkbox" onclick="Backend.toggleCheckboxElements(this, \'' . strtolower ( $ command ) . '\')"></td> <td class="tl_col_2"><label for="check_all_' . $ count . '" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label></td> </tr>' ; foreach ( $ sql_command [ $ command ] as $ vv ) { $ key = md5 ( $ vv ) ; $ _SESSION [ 'sql_commands' ] [ $ key ] = $ vv ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" name="sql[]" id="sql_' . $ count . '" class="tl_checkbox ' . strtolower ( $ command ) . '" value="' . $ key . '"' . ( ( stripos ( $ command , 'DROP' ) === false ) ? ' checked="checked"' : '' ) . '></td> <td class="tl_col_2"><pre><label for="sql_' . $ count ++ . '">' . $ vv . '</label></pre></td> </tr>' ; } } } return '<div id="sql_wrapper"> <table id="sql_table">' . $ return . ' </table></div>' ; }
2145	public function replace ( $ strBuffer , $ blnCache = true ) { $ strBuffer = $ this -> doReplace ( $ strBuffer , $ blnCache ) ; while ( strpos ( $ strBuffer , '{{' ) !== false && ( $ strTmp = $ this -> doReplace ( $ strBuffer , $ blnCache ) ) != $ strBuffer ) { $ strBuffer = $ strTmp ; } return $ strBuffer ; }
10743	public function getDateTime ( $ keys , DateTime $ default = null ) { $ value = $ this -> getString ( $ keys ) ; if ( empty ( $ value ) ) { $ result = $ default ; } elseif ( $ value === ( string ) ( int ) $ value ) { $ result = new DateTime ( ) ; $ result -> setTimestamp ( ( int ) $ value ) ; } else { $ result = new DateTime ( $ value ) ; } return $ result ; }
1528	protected function transaction ( Closure $ closure ) { if ( ! $ this -> useTransactions ) { return $ closure ( ) ; } return app ( 'db' ) -> connection ( $ this -> connection ) -> transaction ( $ closure ) ; }
7155	private function nullDateIfLowerThanToday ( \ DateTime $ eda = null ) { if ( null === $ eda ) { return null ; } $ today = new \ DateTime ( ) ; $ today -> setTime ( 0 , 0 , 0 ) ; if ( $ eda < $ today ) { return null ; } return $ eda ; }
4915	private function addArray ( array $ result ) { if ( 1 < count ( $ result ) && ! isset ( $ result [ 'name' ] ) && ! is_string ( $ result [ 0 ] ) ) { foreach ( $ result as $ r ) { if ( is_array ( $ r ) ) { $ this -> add ( $ r ) ; } else { return $ this -> addTraversable ( new \ ArrayIterator ( $ result ) ) ; } } return $ this ; } if ( is_string ( $ result [ 0 ] ) ) { $ result = [ 'name' => $ result [ 0 ] , 'entities' => isset ( $ result [ 1 ] ) ? $ result [ 1 ] : null , 'options' => isset ( $ result [ 2 ] ) && is_array ( $ result [ 2 ] ) ? $ result [ 2 ] : [ 'description' => isset ( $ result [ 2 ] ) ? $ result [ 2 ] : null , 'viewScript' => isset ( $ result [ 3 ] ) ? $ result [ 3 ] : null , ] , ] ; } if ( ! isset ( $ result [ 'name' ] ) || ! isset ( $ result [ 'entities' ] ) ) { throw new \ UnexpectedValueException ( 'Array must have the keys "name" and "entities".' ) ; } if ( ! count ( $ result [ 'entities' ] ) ) { throw new \ UnexpectedValueException ( 'Entities must be non-empty.' ) ; } $ result = new DependencyResult ( $ result [ 'name' ] , $ result [ 'entities' ] , isset ( $ result [ 'options' ] ) ? $ result [ 'options' ] : null ) ; return $ this -> addResult ( $ result ) ; }
80	public static function suppress ( $ mask = null ) { if ( ! isset ( $ mask ) ) { $ mask = E_WARNING | E_NOTICE | E_USER_WARNING | E_USER_NOTICE | E_DEPRECATED | E_USER_DEPRECATED | E_STRICT ; } $ old = error_reporting ( ) ; self :: $ stack [ ] = $ old ; error_reporting ( $ old & ~ $ mask ) ; return $ old ; }
5279	protected function generateWhere ( $ column , $ param1 = null , $ param2 = null , $ type = 'and' ) { if ( is_null ( $ param2 ) ) { $ param2 = $ param1 ; $ param1 = '=' ; } if ( is_array ( $ param2 ) ) { $ param2 = $ this -> esc_array ( array_unique ( $ param2 ) ) ; if ( in_array ( $ param1 , array ( 'between' , 'not between' ) ) ) { $ param2 = join ( ' and ' , $ param2 ) ; } else { $ param2 = '(' . join ( ', ' , $ param2 ) . ')' ; } } elseif ( is_scalar ( $ param2 ) ) { $ param2 = $ this -> esc_value ( $ param2 ) ; } return join ( ' ' , array ( $ type , $ column , $ param1 , $ param2 ) ) ; }
7653	public function dir_opendir ( $ path , $ options ) { $ this -> blobs = $ this -> getStorageClient ( $ path ) -> listBlobs ( $ this -> getContainerName ( $ path ) ) ; return is_array ( $ this -> blobs ) ; }
9208	protected function truncateTable ( $ Table ) { $ truncateSql = $ Table -> schema ( ) -> truncateSql ( $ Table -> connection ( ) ) [ 0 ] ; $ success = $ Table -> connection ( ) -> query ( $ truncateSql ) ; if ( $ success ) { $ this -> verbose ( "<success>{$Table->alias()}: Existing DB records truncated.</success>" ) ; } else { $ this -> quiet ( "<warning>{$Table->alias()}: Can not truncate existing records.</warning>" ) ; } return $ success ; }
10826	public static function table ( array $ rows , array $ headers = [ ] ) { $ table = new Table ( ) ; $ table -> setRows ( $ rows ) ; if ( count ( $ headers ) > 0 ) { $ table -> setHeaders ( $ headers ) ; } $ output = $ table -> render ( ) ; self :: writeln ( $ output ) ; }
2288	public static function findUnactivatedByEmail ( $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE email=? AND disable='1' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn>? AND o.confirmedOn=0)" ) -> limit ( 1 ) -> execute ( $ strEmail , strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objMember = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { return $ objMember ; } return new static ( $ objResult ) ; }
949	public function sanitizeShopDomain ( $ domain ) { if ( empty ( $ domain ) ) { return ; } $ configEndDomain = Config :: get ( 'shopify-app.myshopify_domain' ) ; $ domain = strtolower ( preg_replace ( '/https?:\/\//i' , '' , trim ( $ domain ) ) ) ; if ( strpos ( $ domain , $ configEndDomain ) === false && strpos ( $ domain , '.' ) === false ) { $ domain .= ".{$configEndDomain}" ; } return parse_url ( "http://{$domain}" , PHP_URL_HOST ) ; }
414	public function setSecurePort ( $ value ) { if ( $ value != $ this -> _securePort ) { $ this -> _securePort = ( int ) $ value ; $ this -> _hostInfo = null ; } }
5265	public function getNotCachedAttributes ( $ key , array $ attributes = [ '*' ] ) { if ( ! $ this -> has ( $ key ) ) { return $ attributes ; } $ cachedAttributes = $ this -> cache [ $ key ] [ 'attributes' ] ; return $ cachedAttributes == [ '*' ] ? [ ] : array_diff ( $ attributes , $ cachedAttributes ) ; }
6282	public static function buildHttpClient ( LoopInterface $ loop , $ connector = null ) { if ( class_exists ( HttpClientFactory :: class ) ) { return static :: buildHttpClient04 ( $ loop , $ connector ) ; } else { return static :: buildHttpClient05 ( $ loop , $ connector ) ; } }
6029	public function addDeploymentFile ( $ item ) { if ( ! ( $ item instanceof DeploymentFile ) ) { if ( is_array ( $ item ) ) { try { $ item = new DeploymentFile ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate DeploymentFile. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "DeploymentFile"!' , E_USER_WARNING ) ; } } $ this -> deployedFiles [ ] = $ item ; return $ this ; }
9740	public function getPrintArea ( $ index = 0 ) { if ( $ index == 0 ) { return $ this -> printArea ; } $ printAreas = explode ( ',' , $ this -> printArea ) ; if ( isset ( $ printAreas [ $ index - 1 ] ) ) { return $ printAreas [ $ index - 1 ] ; } throw new PhpSpreadsheetException ( 'Requested Print Area does not exist' ) ; }
3940	private function setEmptyValue ( PropertyInterface $ property , array $ propInfo ) { if ( ! array_key_exists ( 'empty_value' , $ propInfo ) || ! ( $ property instanceof EmptyValueAwarePropertyInterface ) ) { return ; } $ property -> setEmptyValue ( $ propInfo [ 'empty_value' ] ) ; }
4257	protected function getErrorsInCategory ( $ category ) { $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ errorsInCat = array ( ) ; foreach ( $ errors as $ err ) { if ( $ err [ 'category' ] == $ category && $ err [ 'inConsole' ] ) { $ errorsInCat [ ] = $ err ; } } return $ errorsInCat ; }
8139	public function load ( $ name ) { if ( $ name instanceof Twig_TemplateWrapper ) { return $ name ; } if ( $ name instanceof Twig_Template ) { return new Twig_TemplateWrapper ( $ this , $ name ) ; } return new Twig_TemplateWrapper ( $ this , $ this -> loadTemplate ( $ name ) ) ; }
8981	private static function matchesDateCriteria ( $ key , RateInterface $ rate , array $ criteria ) { $ date = self :: extractDateCriteria ( $ key , $ criteria ) ; if ( $ date === null ) { return true ; } if ( $ key === 'dateFrom' ) { $ rateDate = new \ DateTime ( $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) ) ; $ rateDate -> setTime ( 23 , 59 , 59 ) ; return $ date <= $ rateDate ; } if ( $ key === 'dateTo' ) { $ rateDate = new \ DateTime ( $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) ) ; $ rateDate -> setTime ( 0 , 0 , 0 ) ; return $ date >= $ rateDate ; } return $ date -> format ( 'Y-m-d' ) === $ rate -> getDate ( ) -> format ( 'Y-m-d' ) ; }
8984	public function isEqual ( TableNode $ expected , TableNode $ actual , $ message = NULL ) { $ this -> doAssert ( 'Failed asserting that two tables were equivalent: ' , [ 'ignoreColumnSequence' => TRUE ] , $ expected , $ actual , $ message ) ; }
4980	public function convertToDatabaseValue ( $ value ) { if ( ! $ value instanceof \ DateTime ) { return null ; } $ timezone = $ value -> getTimezone ( ) -> getName ( ) ; $ timestamp = $ value -> getTimestamp ( ) ; $ date = new \ MongoDate ( $ timestamp ) ; return array ( 'date' => $ date , 'tz' => $ timezone , ) ; }
11718	protected function basicFetchQuery ( $ context , array $ args ) { if ( $ context !== 'person' ) { throw new \ LogicException ( 'TimelineAccompanyingPeriod is not able ' . 'to render context ' . $ context ) ; } $ metadata = $ this -> em -> getClassMetadata ( 'ChillPersonBundle:AccompanyingPeriod' ) ; return array ( 'id' => $ metadata -> getColumnName ( 'id' ) , 'date' => $ metadata -> getColumnName ( 'openingDate' ) , 'FROM' => $ metadata -> getTableName ( ) , ) ; }
10523	protected function getDepDropParents ( $ post = 'depdrop_parents' ) { $ parents = Yii :: $ app -> request -> post ( $ post ) ; $ filteredParents = [ ] ; foreach ( $ parents as $ key => $ parent ) { if ( is_numeric ( $ parent ) ) { $ filteredParents [ $ key ] = $ parent ; } else { return [ ] ; } } return $ filteredParents ; }
9356	public function withUri ( UriInterface $ uri , $ preserve = false ) { $ static = clone $ this ; $ static -> uri = $ uri ; if ( ! $ preserve && $ host = $ uri -> getHost ( ) ) { $ port = $ host . ':' . $ uri -> getPort ( ) ; $ host = $ uri -> getPort ( ) ? $ port : $ host ; $ static -> headers [ 'Host' ] = ( array ) $ host ; } return $ static ; }
7989	public function getTemplateProperties ( $ domain , $ templateId ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ templateId = ( string ) $ templateId ; if ( ! $ templateId ) throw new BadMethodCallException ( "Parameter $templateId is missing" ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/templates/' . $ templateId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( ) ; }
9896	private function convertNumber ( $ num ) { if ( ( preg_match ( '/^\\d+$/' , $ num ) ) and ( $ num <= 65535 ) ) { return pack ( 'Cv' , $ this -> ptg [ 'ptgInt' ] , $ num ) ; } if ( BIFFwriter :: getByteOrder ( ) ) { $ num = strrev ( $ num ) ; } return pack ( 'Cd' , $ this -> ptg [ 'ptgNum' ] , $ num ) ; }
11942	private function validateArgument ( Request $ request , ConfigContainer $ config , $ position ) { $ value = null ; switch ( $ config -> getValue ( 'storage' ) ) { case 'url' : $ value = $ this -> validateUrl ( $ request , $ config , $ position ) ; break ; case 'post' : $ value = $ this -> validateGetPost ( $ request -> getData ( ) , $ config , $ position ) ; break ; case 'get' : $ value = $ this -> validateGetPost ( $ request -> getQuery ( ) , $ config , $ position ) ; break ; default : throw new InvalidConfigValueException ( 'storage' , $ config -> getValue ( 'storage' ) ) ; } $ validatorName = $ config -> getValue ( 'validator' ) ; if ( $ validatorName !== '' ) { $ validatorObject = new $ validatorName ( ) ; $ error = $ validatorObject -> validate ( $ value ) ; if ( $ error ) { throw new InvalidArgumentException ( $ position , $ config -> getValue ( 'name' ) , $ error ) ; } } $ mapperName = $ config -> getValue ( 'mapper' ) ; if ( $ mapperName !== '' ) { $ mapper = new $ mapperName ( $ this -> container ) ; $ value = $ mapper -> cast ( $ value ) ; } $ request -> setArgument ( $ config -> getValue ( 'name' ) , $ value ) ; }
10961	protected function restoreResponse ( $ response , $ data ) { if ( isset ( $ data [ 'format' ] ) ) { $ response -> format = $ data [ 'format' ] ; } if ( isset ( $ data [ 'version' ] ) ) { $ response -> version = $ data [ 'version' ] ; } if ( isset ( $ data [ 'statusCode' ] ) ) { $ response -> statusCode = $ data [ 'statusCode' ] ; } if ( isset ( $ data [ 'statusText' ] ) ) { $ response -> statusText = $ data [ 'statusText' ] ; } if ( isset ( $ data [ 'headers' ] ) && is_array ( $ data [ 'headers' ] ) ) { $ headers = $ response -> getHeaders ( ) -> toArray ( ) ; $ response -> getHeaders ( ) -> fromArray ( array_merge ( $ data [ 'headers' ] , $ headers ) ) ; } if ( isset ( $ data [ 'cookies' ] ) && is_array ( $ data [ 'cookies' ] ) ) { $ cookies = $ response -> getCookies ( ) -> toArray ( ) ; $ response -> getCookies ( ) -> fromArray ( array_merge ( $ data [ 'cookies' ] , $ cookies ) ) ; } }
873	public function getAnnotations ( ) { if ( null === $ this -> annotations ) { $ this -> annotations = [ ] ; $ total = \ count ( $ this -> lines ) ; for ( $ index = 0 ; $ index < $ total ; ++ $ index ) { if ( $ this -> lines [ $ index ] -> containsATag ( ) ) { $ lines = \ array_slice ( $ this -> lines , $ index , $ this -> findAnnotationLength ( $ index ) , true ) ; $ annotation = new Annotation ( $ lines ) ; $ index = $ annotation -> getEnd ( ) ; $ this -> annotations [ ] = $ annotation ; } } } return $ this -> annotations ; }
8697	protected function validateMandatoryAttribs ( ) { foreach ( static :: $ mandatoryFields as $ field ) { if ( ! array_key_exists ( $ field , $ this -> attributes ) ) { throw new \ SVGCreator \ SVGException ( "The field " . $ field . " does not exist for " . static :: TYPE . "." , 1 ) ; } } }
3552	protected static function boot ( ) { parent :: boot ( ) ; if ( ! isset ( static :: $ attributeMutator ) ) { if ( function_exists ( 'app' ) && app ( ) -> bound ( 'eloquence.mutator' ) ) { static :: $ attributeMutator = app ( 'eloquence.mutator' ) ; } else { static :: $ attributeMutator = new Mutator ; } } }
193	public function clear ( ) { $ this -> _headers = null ; $ this -> _cookies = null ; $ this -> _statusCode = 200 ; $ this -> statusText = 'OK' ; $ this -> data = null ; $ this -> stream = null ; $ this -> content = null ; $ this -> isSent = false ; }
9136	public function clearTag ( $ name ) { if ( isset ( $ this -> tags [ $ name ] ) ) { unset ( $ this -> tags [ $ name ] ) ; } return $ this ; }
