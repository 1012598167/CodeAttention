4630	protected function prepareRequestHeaders ( ) { $ curl_headers = [ ] ; foreach ( $ this -> headers as $ key => $ value ) { $ curl_headers [ ] = sprintf ( '%s: %s' , $ key , $ value ) ; } $ object = $ this -> command -> getObject ( ) ; if ( $ object ) { if ( $ object -> getVclock ( ) ) { $ curl_headers [ ] = sprintf ( '%s: %s' , static :: VCLOCK_KEY , $ object -> getVclock ( ) ) ; } if ( $ object -> getContentType ( ) ) { $ charset = '' ; if ( $ object -> getCharset ( ) ) { $ charset = sprintf ( '; charset=%s' , $ object -> getCharset ( ) ) ; } $ curl_headers [ ] = sprintf ( '%s: %s' , static :: CONTENT_TYPE_KEY , $ object -> getContentType ( ) , $ charset ) ; } $ translator = new Api \ Http \ Translator \ SecondaryIndex ( ) ; $ indexHeaders = $ translator -> createHeadersFromIndexes ( $ object -> getIndexes ( ) ) ; foreach ( $ indexHeaders as $ value ) { $ curl_headers [ ] = sprintf ( '%s: %s' , $ value [ 0 ] , $ value [ 1 ] ) ; } foreach ( $ object -> getMetaData ( ) as $ key => $ value ) { $ curl_headers [ ] = sprintf ( '%s%s: %s' , static :: METADATA_PREFIX , $ key , $ value ) ; } } $ this -> options [ CURLOPT_HTTPHEADER ] = $ curl_headers ; $ this -> headers = [ ] ; return $ this ; }
10241	public function calculateFormula ( $ formula , $ cellID = null , Cell $ pCell = null ) { $ this -> formulaError = null ; $ this -> debugLog -> clearLog ( ) ; $ this -> cyclicReferenceStack -> clear ( ) ; if ( $ this -> spreadsheet !== null && $ cellID === null && $ pCell === null ) { $ cellID = 'A1' ; $ pCell = $ this -> spreadsheet -> getActiveSheet ( ) -> getCell ( $ cellID ) ; } else { $ resetCache = $ this -> getCalculationCacheEnabled ( ) ; $ this -> calculationCacheEnabled = false ; } try { $ result = self :: unwrapResult ( $ this -> _calculateFormulaValue ( $ formula , $ cellID , $ pCell ) ) ; } catch ( \ Exception $ e ) { throw new Exception ( $ e -> getMessage ( ) ) ; } if ( $ this -> spreadsheet === null ) { $ this -> calculationCacheEnabled = $ resetCache ; } return $ result ; }
1660	public function reply ( $ reply ) { if ( is_string ( $ reply ) ) { $ this -> replies = [ $ reply ] ; } elseif ( is_array ( $ reply ) ) { $ this -> replies = $ reply ; } return $ this ; }
3147	public function check ( RunnerServiceContext $ context ) { $ state = $ context -> getTestSession ( ) -> getState ( ) ; if ( $ state == AssessmentTestSessionState :: CLOSED ) { throw new QtiRunnerClosedException ( ) ; } return true ; }
9877	private function writeFileVersion ( XMLWriter $ objWriter ) { $ objWriter -> startElement ( 'fileVersion' ) ; $ objWriter -> writeAttribute ( 'appName' , 'xl' ) ; $ objWriter -> writeAttribute ( 'lastEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'lowestEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'rupBuild' , '4505' ) ; $ objWriter -> endElement ( ) ; }
3904	public function handle ( GetOptionsEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getPropertyName ( ) ) || ( 'dca_id' !== $ event -> getSubPropertyName ( ) ) ) { return ; } $ screens = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' ) -> addSelect ( 'name' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ event -> getModel ( ) -> getProperty ( 'id' ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; foreach ( $ screens as $ screen ) { $ result [ $ screen [ 'id' ] ] = $ screen [ 'name' ] ; } $ event -> setOptions ( $ result ) ; }
2172	private function purgeSymfonyCache ( ) : void { $ filesystem = new Filesystem ( ) ; $ cacheDir = $ this -> getContainerParameter ( 'kernel.cache_dir' ) ; $ ref = new \ ReflectionObject ( $ this -> container ) ; $ containerDir = basename ( \ dirname ( $ ref -> getFileName ( ) ) ) ; $ finder = Finder :: create ( ) -> depth ( 0 ) -> exclude ( $ containerDir ) -> in ( $ cacheDir ) ; foreach ( $ finder as $ file ) { $ filesystem -> remove ( $ file -> getPathname ( ) ) ; } if ( \ function_exists ( 'opcache_reset' ) ) { opcache_reset ( ) ; } if ( \ function_exists ( 'apc_clear_cache' ) && ! ini_get ( 'apc.stat' ) ) { apc_clear_cache ( ) ; } }
7767	public function loadMetadataForClass ( $ className ) { foreach ( $ this -> drivers as $ namespace => $ driver ) { if ( strpos ( $ className , $ namespace ) === 0 ) { return $ driver -> loadMetadataForClass ( $ className ) ; } } return null ; }
2411	public function exportTheme ( DataContainer $ dc ) { $ objTheme = $ this -> Database -> prepare ( "SELECT * FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objTheme -> numRows < 1 ) { return ; } $ strName = Utf8 :: toAscii ( $ objTheme -> name ) ; $ strName = strtolower ( str_replace ( ' ' , '_' , $ strName ) ) ; $ strName = preg_replace ( '/[^A-Za-z0-9._-]/' , '' , $ strName ) ; $ strName = basename ( $ strName ) ; $ xml = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ xml -> formatOutput = true ; $ tables = $ xml -> createElement ( 'tables' ) ; $ tables = $ xml -> appendChild ( $ tables ) ; $ this -> addTableTlTheme ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlStyleSheet ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlImageSize ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlModule ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlLayout ( $ xml , $ tables , $ objTheme ) ; $ strTmp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objArchive = new ZipWriter ( 'system/tmp/' . $ strTmp ) ; $ this -> addTableTlFiles ( $ xml , $ tables , $ objTheme , $ objArchive ) ; $ this -> addTemplatesToArchive ( $ objArchive , $ objTheme -> templates ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] as $ callback ) { System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ xml , $ objArchive , $ objTheme -> id ) ; } } $ objArchive -> addString ( $ xml -> saveXML ( ) , 'theme.xml' ) ; $ objArchive -> close ( ) ; $ objFile = new File ( 'system/tmp/' . $ strTmp ) ; $ objFile -> sendToBrowser ( $ strName . '.cto' ) ; }
3271	public function writeTempToFile ( SplTempFileObject & $ tmpFile ) { $ file = $ this -> openFile ( static :: FILE_WRITE ) ; foreach ( $ tmpFile as $ line ) { $ file -> fwrite ( $ line ) ; } $ this -> closeFile ( $ file ) ; $ tmpFile = null ; }
6636	protected function initLanguages ( ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } if ( ! isset ( Yii :: $ app -> wavecms ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Component "wavecms" not defined in config.php' ) ) ; if ( ! count ( Yii :: $ app -> wavecms -> languages ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Property "languages" is not defined in config file for component "wavecms"' ) ) ; if ( ! Yii :: $ app -> session -> get ( 'editedLanguage' ) ) { Yii :: $ app -> session -> set ( 'editedLanguage' , Yii :: $ app -> wavecms -> languages [ 0 ] ) ; } Yii :: $ app -> wavecms -> editedLanguage = Yii :: $ app -> session -> get ( 'editedLanguage' ) ; }
12223	public function get ( $ keys = [ ] ) { $ this -> buildIfNotBuilded ( ) ; $ keys = $ keys == [ ] ? $ this -> keys ( ) : $ keys ; if ( ! $ keys ) { return $ this -> builder -> get ( ) ; } return $ this -> builder -> withColumns ( $ keys ) -> get ( $ keys ) ; }
5071	protected function traverseHeaderTags ( \ DOMDocument $ domDocument , $ topLevel , $ depth ) { $ xpath = new \ DOMXPath ( $ domDocument ) ; $ xpathQuery = sprintf ( "//*[%s]" , implode ( ' or ' , array_map ( function ( $ v ) { return sprintf ( 'local-name() = "%s"' , $ v ) ; } , $ this -> determineHeaderTags ( $ topLevel , $ depth ) ) ) ) ; $ nodes = [ ] ; foreach ( $ xpath -> query ( $ xpathQuery ) as $ node ) { $ nodes [ ] = $ node ; } return new \ ArrayIterator ( $ nodes ) ; }
5784	public function routePutUpdate ( Request $ request , Response $ response , $ args ) { if ( ! $ this -> authorization -> isAuthorized ( constant ( strtoupper ( $ this -> routePrefix ) . "_UPDATE_RESOURCE" ) ) ) { throw new \ Exception ( 'No permission.' ) ; } $ primaryKeyValue = $ args [ ROUTEARG_PRIMARY_KEY ] ; $ this -> setRequestInput ( $ request , DatabaseTableForm :: getFieldNames ( $ this -> tableMapper ) , $ this -> tableMapper -> getBooleanColumnNames ( ) ) ; $ redirectRoute = SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ; if ( null === $ record = $ this -> tableMapper -> selectForPrimaryKey ( $ primaryKeyValue ) ) { return $ this -> databaseRecordNotFound ( $ response , $ primaryKeyValue , $ this -> tableMapper , 'update' ) ; } $ changedColumnsValues = $ this -> getMapper ( ) -> getChangedColumnsValues ( $ this -> requestInput , $ record ) ; if ( count ( $ changedColumnsValues ) == 0 ) { SlimPostgres :: setAdminNotice ( "No changes made" , 'failure' ) ; return $ this -> view -> updateView ( $ request , $ response , $ args ) ; } $ validator = new DatabaseTableUpdateFormValidator ( $ this -> requestInput , $ this -> tableMapper , $ record ) ; if ( ! $ validator -> validate ( ) ) { FormHelper :: setFieldErrors ( $ validator -> getFirstErrors ( ) ) ; $ args [ SlimPostgres :: USER_INPUT_KEY ] = $ this -> requestInput ; return $ this -> view -> updateView ( $ request , $ response , $ args ) ; } $ this -> tableMapper -> updateByPrimaryKey ( $ changedColumnsValues , $ primaryKeyValue ) ; $ this -> enterEventAndNotice ( 'update' , $ primaryKeyValue ) ; return $ response -> withRedirect ( $ this -> router -> pathFor ( $ redirectRoute ) ) ; }
8006	public static function forReasonCode ( $ code = 0 , Exception $ previous = null ) { switch ( $ code ) { case self :: CODE_FOR_ENCRYPTION_FAILURE : $ message = self :: MESSAGE_FOR_ENCRYPTION_FAILURE ; break ; case self :: CODE_FOR_RANDOM_DATA_GENERATION_FAILURE : $ message = self :: MESSAGE_FOR_RANDOM_DATA_GENERATION_FAILURE ; break ; default : $ message = self :: DEFAULT_MESSAGE ; } return new static ( $ message , $ code , $ previous ) ; }
5409	public function selectAsPairs ( $ url ) { $ pairs = array ( ) ; foreach ( $ this -> cookies as $ cookie ) { if ( $ this -> isMatch ( $ cookie , $ url -> getHost ( ) , $ url -> getPath ( ) , $ cookie -> getName ( ) ) ) { $ pairs [ ] = $ cookie -> getName ( ) . '=' . $ cookie -> getValue ( ) ; } } return $ pairs ; }
975	public function shopWebhooks ( ) { if ( ! $ this -> shopWebhooks ) { $ this -> shopWebhooks = $ this -> api -> rest ( 'GET' , '/admin/webhooks.json' , [ 'limit' => 250 , 'fields' => 'id,address' , ] ) -> body -> webhooks ; } return $ this -> shopWebhooks ; }
2754	public static function plainText ( $ value ) { $ element = render ( $ value ) ; $ element = strip_tags ( $ element ) ; $ element = html_entity_decode ( $ element , ENT_QUOTES ) ; return $ element ; }
11411	public function usersOfTag ( $ tagId , $ nextOpenId = '' ) { $ params = [ 'tagid' => $ tagId , 'next_openid' => $ nextOpenId ] ; return $ this -> parseJSON ( 'json' , [ self :: API_USERS_OF_TAG , $ params ] ) ; }
6479	public function getClientIPAddress ( IHttpRequestMessage $ request ) : ? string { $ clientIPAddress = null ; $ request -> getProperties ( ) -> tryGet ( self :: CLIENT_IP_ADDRESS_PROPERTY , $ clientIPAddress ) ; return $ clientIPAddress ; }
11814	protected function step1 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/license" ) ; $ this -> view -> setData ( "step" , "1" ) ; $ this -> view -> setData ( "title" , t ( "Installation | EULA" ) ) ; return ; }
3026	private function parseResponse ( $ response ) { $ response -> json = json_decode ( $ response -> body ) ; if ( $ response -> status < 400 ) { return $ response -> json -> response ; } else { throw new RequestException ( $ response ) ; } }
8364	public static function setCurrentLanguage ( $ language ) { self :: $ currentLanguage = $ language ; Session :: set ( '_stray_language' , self :: $ currentLanguage ) ; setlocale ( LC_ALL , $ language ) ; }
11124	public static function create ( $ notify ) { switch ( true ) { case $ notify === NotifyInterface :: STDOUT : return new NotifyStdout ( ) ; case $ notify === NotifyInterface :: LOGGER : return new NotifyLogger ( PrettyLogger :: create ( ) ) ; case $ notify === NotifyInterface :: BLACKHOLE : return new NotifyBlackhole ( ) ; case $ notify instanceof Output : return new NotifyConsole ( $ notify ) ; case $ notify instanceof LoggerInterface : return new NotifyLogger ( $ notify ) ; default : throw InvalidArgumentException :: forNotSupportedNotifier ( ) ; } }
22	public function addPackage ( PackageInterface $ package ) { if ( null === $ this -> packages ) { $ this -> initialize ( ) ; } $ package -> setRepository ( $ this ) ; $ this -> packages [ ] = $ package ; if ( $ package instanceof AliasPackage ) { $ aliasedPackage = $ package -> getAliasOf ( ) ; if ( null === $ aliasedPackage -> getRepository ( ) ) { $ this -> addPackage ( $ aliasedPackage ) ; } } }
4104	protected static function parseDsn ( $ dsn ) { $ parts = parse_url ( $ dsn ) ; $ protocol = $ parts [ 'scheme' ] ; $ servers = $ parts [ 'host' ] . ':' . $ parts [ 'port' ] ; if ( isset ( $ parts [ 'path' ] ) ) { $ path = explode ( '/' , $ parts [ 'path' ] ) ; list ( $ index , $ type ) = array_values ( array_filter ( $ path ) ) ; } return compact ( 'protocol' , 'servers' , 'index' , 'type' ) ; }
9131	public function load ( $ file , $ type = null ) { $ path = $ this -> locator -> locate ( $ file ) ; if ( ! stream_is_local ( $ path ) ) { throw new \ InvalidArgumentException ( sprintf ( 'This is not a local file "%s".' , $ path ) ) ; } if ( ! file_exists ( $ path ) ) { throw new \ InvalidArgumentException ( sprintf ( 'File "%s" not found.' , $ path ) ) ; } if ( null === $ this -> yamlParser ) { $ this -> yamlParser = new YamlParser ( ) ; } $ config = $ this -> yamlParser -> parse ( file_get_contents ( $ path ) ) ; $ collection = new RuleCollection ( ) ; $ collection -> addResource ( new FileResource ( $ path ) ) ; if ( null === $ config ) { return $ collection ; } if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The file "%s" must contain a YAML array.' , $ path ) ) ; } foreach ( $ config as $ name => $ subConfig ) { $ this -> validate ( $ subConfig , $ name , $ path ) ; if ( isset ( $ subConfig [ 'resource' ] ) ) { $ this -> parseImport ( $ collection , $ subConfig , $ path , $ file ) ; } else { $ this -> parseRule ( $ collection , $ name , $ subConfig , $ path ) ; } } return $ collection ; }
11249	public function log ( string $ file , int $ batch ) : void { $ stmt = $ this -> pdo -> prepare ( "insert into {$this->table} (migration, batch) values (?, ?)" ) ; $ stmt -> bindParam ( 1 , $ file ) ; $ stmt -> bindParam ( 2 , $ batch , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; }
2390	private function findLegendForField ( array & $ config , string $ field ) { foreach ( $ config as $ legend => $ group ) { if ( \ in_array ( $ field , $ group [ 'fields' ] , true ) ) { return $ legend ; } } return false ; }
2344	protected function createIfNotExists ( ) { if ( file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { return ; } if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strFile , 'wb' ) ) { throw new \ Exception ( sprintf ( 'Cannot create file "%s"' , $ this -> strFile ) ) ; } }
2630	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ comment = $ this -> getRequest ( ) -> getParam ( 'comment_value' ) ; $ negated = 0 ; if ( $ value [ 0 ] == '!' ) { $ negated = 1 ; $ value = ltrim ( $ value , '!' ) ; } $ ipParts = explode ( '/' , $ value ) ; $ subnet = false ; if ( ! empty ( $ ipParts [ 1 ] ) ) { if ( is_numeric ( $ ipParts [ 1 ] ) && ( int ) $ ipParts [ 1 ] < 129 ) { $ subnet = $ ipParts [ 1 ] ; } else { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP subnet format.' ] ) ; } } if ( ! filter_var ( $ ipParts [ 0 ] , FILTER_VALIDATE_IP ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP address format.' ] ) ; } $ createAclItem = $ this -> api -> upsertAclItem ( $ aclId , $ ipParts [ 0 ] , $ negated , $ comment , $ subnet ) ; if ( ! $ createAclItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Acl entry.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'id' => $ createAclItem -> id , 'comment' => $ createAclItem -> comment , 'created_at' => $ createAclItem -> created_at ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4947	protected function checkPermission ( $ permission ) { $ perms = array ( self :: PERMISSION_ALL , self :: PERMISSION_CHANGE , self :: PERMISSION_NONE , self :: PERMISSION_VIEW , ) ; if ( ! in_array ( $ permission , $ perms ) ) { throw new \ InvalidArgumentException ( 'Invalid permission. Must be one of ' . implode ( ', ' , $ perms ) ) ; } }
7388	public function fetch ( string $ key , $ default = null ) { if ( isset ( $ _SERVER [ $ key ] ) ) { return $ _SERVER [ $ key ] ; } else { $ key = 'HTTP_' . $ key ; return $ _SERVER [ $ key ] ?? $ default ; } }
6604	public function makeAccessToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateAccessTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'user_id' ] = $ params [ 'user_id' ] ; $ this -> credentials [ 'screen_name' ] = $ params [ 'screen_name' ] ; return $ this ; }
4561	public function transfer ( Translatable $ model ) { $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ get = 'get' . $ property -> getName ( ) ; $ set = 'set' . $ property -> getName ( ) ; $ values = $ model -> $ get ( ) ; if ( null !== $ values ) { foreach ( $ values as $ locale => $ value ) { $ model -> translate ( $ locale , false ) -> $ set ( $ value ) ; } } } $ model -> mergeNewTranslations ( ) ; }
12196	public static function current ( ) { if ( defined ( 'PHPUNIT_RUNNING' ) ) { return 'http://localhost' ; } $ protocol = 'http://' ; if ( ! empty ( $ _SERVER [ 'HTTPS' ] ) || ( ! empty ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] === 'https' ) ) { $ protocol = 'https://' ; } return $ protocol . request ( ) -> server ( 'HTTP_HOST' ) . request ( ) -> server ( 'REQUEST_URI' ) ; }
11574	public function openTag ( $ attributesOrElement = null ) { if ( null === $ attributesOrElement ) { return '<button>' ; } if ( is_array ( $ attributesOrElement ) ) { $ attributes = $ this -> createAttributesString ( $ attributesOrElement ) ; return sprintf ( '<button %s>' , $ attributes ) ; } if ( ! $ attributesOrElement instanceof ElementInterface ) { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects an array or Zend\Form\ElementInterface instance; received "%s"' , __METHOD__ , ( is_object ( $ attributesOrElement ) ? get_class ( $ attributesOrElement ) : gettype ( $ attributesOrElement ) ) ) ) ; } $ element = $ attributesOrElement ; $ attributes = $ element -> getAttributes ( ) ; $ name = $ element -> getName ( ) ; if ( $ name ) { $ attributes [ 'name' ] = $ name ; } $ attributes [ 'type' ] = $ this -> getType ( $ element ) ; $ classList = [ 'btn' , 'btn-white' ] ; if ( isset ( $ attributes [ 'class' ] ) ) { $ attributes [ 'class' ] = implode ( ' ' , array_unique ( array_merge ( explode ( ' ' , $ attributes [ 'class' ] ) , $ classList ) ) ) ; } else { $ attributes [ 'class' ] = implode ( ' ' , $ classList ) ; } return sprintf ( '<button %s>' , $ this -> createAttributesString ( $ attributes ) ) ; }
5633	public function collect ( & $ test , $ path ) { $ path = $ this -> removeTrailingSlash ( $ path ) ; if ( $ handle = opendir ( $ path ) ) { while ( ( $ entry = readdir ( $ handle ) ) !== false ) { if ( $ this -> isHidden ( $ entry ) ) { continue ; } $ this -> handle ( $ test , $ path . DIRECTORY_SEPARATOR . $ entry ) ; } closedir ( $ handle ) ; } }
9070	protected static function parseEachPart ( array $ parts , $ format ) { $ lastPartKey = count ( $ parts ) - 1 ; for ( $ p = 0 ; $ p <= $ lastPartKey ; $ p ++ ) { $ parsedPart = static :: parse ( $ parts [ $ p ] , $ format ) ; $ numNewParts = count ( $ parsedPart ) ; if ( $ numNewParts > 1 ) { array_splice ( $ parts , $ p , 1 , $ parsedPart ) ; $ p += $ numNewParts ; $ lastPartKey += $ numNewParts - 1 ; } } return $ parts ; }
9793	public function hasDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for data validation when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> dataValidationExists ( $ this -> getCoordinate ( ) ) ; }
7418	protected function setJSONContent ( array $ content ) { if ( $ this -> deleteJsonKeys ) { $ content = $ this -> deleteArrayKeys ( $ content ) ; } $ content = json_encode ( $ content , JSON_UNESCAPED_UNICODE ) ; $ this -> response -> setContentTypeJson ( ) ; $ this -> response -> setContent ( $ content ) ; }
7923	private function extractFilename ( \ ZipArchive $ zipArchive , $ fileIndex ) { $ entry = $ zipArchive -> statIndex ( $ fileIndex ) ; $ filename = str_replace ( '\\' , '/' , $ entry [ 'name' ] ) ; if ( $ this -> isValidPath ( $ filename ) ) { return $ filename ; } throw new \ Exception ( 'Invalid filename path in zip archive' ) ; }
2305	protected function doCreatePageList ( $ intId = 0 , $ level = - 1 ) { $ objPages = $ this -> Database -> prepare ( "SELECT id, title, type, dns FROM tl_page WHERE pid=? ORDER BY sorting" ) -> execute ( $ intId ) ; if ( $ objPages -> numRows < 1 ) { return '' ; } ++ $ level ; $ strOptions = '' ; while ( $ objPages -> next ( ) ) { if ( $ objPages -> type == 'root' ) { if ( $ objPages -> dns && $ objPages -> dns != Environment :: get ( 'host' ) ) { continue ; } $ strOptions .= '<optgroup label="' . $ objPages -> title . '">' ; $ strOptions .= $ this -> doCreatePageList ( $ objPages -> id , - 1 ) ; $ strOptions .= '</optgroup>' ; } else { $ strOptions .= sprintf ( '<option value="{{link_url::%s}}"%s>%s%s</option>' , $ objPages -> id , ( ( '{{link_url::' . $ objPages -> id . '}}' == Input :: get ( 'value' ) ) ? ' selected="selected"' : '' ) , str_repeat ( ' &nbsp; &nbsp; ' , $ level ) , StringUtil :: specialchars ( $ objPages -> title ) ) ; $ strOptions .= $ this -> doCreatePageList ( $ objPages -> id , $ level ) ; } } return $ strOptions ; }
8464	public static function getDomain ( $ url = false ) { if ( $ url ) { preg_match ( '/([\w]+[.]){1,}[a-z]+/' , $ url , $ matches ) ; return isset ( $ matches [ 0 ] ) ? $ matches [ 0 ] : false ; } return $ _SERVER [ 'SERVER_NAME' ] ; }
3	private function buildDependency20Info ( $ depArray ) { $ result = array ( ) ; $ optionals = array ( ) ; $ defaultOptionals = array ( ) ; foreach ( $ depArray as $ depType => $ depTypeGroup ) { if ( ! is_array ( $ depTypeGroup ) ) { continue ; } if ( 'required' == $ depType || 'optional' == $ depType ) { foreach ( $ depTypeGroup as $ depItemType => $ depItem ) { switch ( $ depItemType ) { case 'php' : $ result [ ] = new DependencyConstraint ( $ depType , $ this -> parse20VersionConstraint ( $ depItem ) , 'php' , '' ) ; break ; case 'package' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'extension' : $ deps = $ this -> buildDepExtensionConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'subpackage' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , 'replaces' ) ; $ defaultOptionals += $ deps ; break ; case 'os' : case 'pearinstaller' : break ; default : break ; } } } elseif ( 'group' == $ depType ) { if ( $ this -> isHash ( $ depTypeGroup ) ) { $ depTypeGroup = array ( $ depTypeGroup ) ; } foreach ( $ depTypeGroup as $ depItem ) { $ groupName = $ depItem [ 'attribs' ] [ 'name' ] ; if ( ! isset ( $ optionals [ $ groupName ] ) ) { $ optionals [ $ groupName ] = array ( ) ; } if ( isset ( $ depItem [ 'subpackage' ] ) ) { $ optionals [ $ groupName ] += $ this -> buildDepPackageConstraints ( $ depItem [ 'subpackage' ] , 'replaces' ) ; } else { $ result += $ this -> buildDepPackageConstraints ( $ depItem [ 'package' ] , 'optional' ) ; } } } } if ( count ( $ defaultOptionals ) > 0 ) { $ optionals [ '*' ] = $ defaultOptionals ; } return new DependencyInfo ( $ result , $ optionals ) ; }
12377	public function superadmin ( User $ account , Container $ application , Database $ database ) { $ config = $ this -> config ; $ username = $ application -> input -> getString ( "user_first_name" , "" , "post" , FALSE , array ( ) ) ; $ usernameid = $ application -> input -> getString ( "user_name_id" , "" , "post" , FALSE , array ( ) ) ; $ userpass = $ application -> input -> getString ( "user_password" , "" , "post" , FALSE , array ( ) ) ; $ userpass2 = $ application -> input -> getString ( "user_password_2" , "" , "post" , FALSE , array ( ) ) ; $ useremail = $ application -> input -> getString ( "user_email" , "" , "post" , FALSE , array ( ) ) ; if ( empty ( $ userpass ) || empty ( $ username ) || empty ( $ usernameid ) || empty ( $ useremail ) ) { throw new Exception ( t ( 'Please provide at least a Name, Username, E-mail and Password' ) ) ; return false ; } if ( $ userpass <> $ userpass2 ) { throw new Exception ( t ( 'The user passwords do not match' ) ) ; return false ; } if ( ! $ account -> store ( $ application -> input -> data ( "post" ) , true ) ) { throw new Exception ( t ( 'Could not store the admin user account' ) ) ; return false ; } $ adminAuthority = $ this -> config -> get ( "setup.site.superadmin-authority" , NULL ) ; if ( ! empty ( $ adminAuthority ) ) { $ query = "INSERT INTO ?objects_authority( authority_id, object_id ) SELECT {$database->quote((int)$adminAuthority)}, object_id FROM ?objects WHERE object_uri={$database->quote($usernameid)}" ; $ database -> exec ( $ query ) ; } $ config -> set ( "setup.session.store" , "database" ) ; $ config -> set ( "setup.database.installed" , TRUE ) ; if ( ! $ config -> saveParams ( ) ) { throw new Exception ( "could not save config" ) ; return false ; } return true ; }
12558	public function actionFlush ( $ category = null ) { if ( is_null ( $ category ) ) { $ category = $ this -> prompt ( "Category (blank for all): " ) ; } if ( empty ( $ category ) ) { $ category = 'all' ; } else { $ category = [ 'category' , $ category ] ; } Cacher :: invalidateGroup ( $ category ) ; $ this -> out ( "Done!" ) ; }
439	public function hasProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { return $ this -> canGetProperty ( $ name , $ checkVars , $ checkBehaviors ) || $ this -> canSetProperty ( $ name , false , $ checkBehaviors ) ; }
9853	public function expiresAt ( $ expires ) { if ( $ expires instanceof DateTimeInterface ) { $ this -> expires = $ expires ; } else { $ this -> expires = null ; } return $ this ; }
12425	public function getAuthorizerToken ( $ appId , $ refreshToken ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ appId , 'authorizer_refresh_token' => $ refreshToken , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_TOKEN , $ params ] ) ; }
1109	protected function groupRootsByScope ( $ roots ) { $ rootsGroupedByScope = array ( ) ; foreach ( $ roots as $ root ) { $ key = $ this -> keyForScope ( $ root ) ; if ( ! isset ( $ rootsGroupedByScope [ $ key ] ) ) $ rootsGroupedByScope [ $ key ] = array ( ) ; $ rootsGroupedByScope [ $ key ] [ ] = $ root ; } return $ rootsGroupedByScope ; }
2355	public function hasFrontendUser ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof FrontendUser ; }
8772	protected function markAsRegistered ( ServiceProvider $ provider ) { $ this -> serviceProviders [ ] = $ provider ; $ this -> loadedProviders [ get_class ( $ provider ) ] = true ; }
16	public static function getContentHash ( $ composerFileContents ) { $ content = json_decode ( $ composerFileContents , true ) ; $ relevantKeys = array ( 'name' , 'version' , 'require' , 'require-dev' , 'conflict' , 'replace' , 'provide' , 'minimum-stability' , 'prefer-stable' , 'repositories' , 'extra' , ) ; $ relevantContent = array ( ) ; foreach ( array_intersect ( $ relevantKeys , array_keys ( $ content ) ) as $ key ) { $ relevantContent [ $ key ] = $ content [ $ key ] ; } if ( isset ( $ content [ 'config' ] [ 'platform' ] ) ) { $ relevantContent [ 'config' ] [ 'platform' ] = $ content [ 'config' ] [ 'platform' ] ; } ksort ( $ relevantContent ) ; return md5 ( json_encode ( $ relevantContent ) ) ; }
9002	public function column_time ( AbstractLog $ item ) { $ time = $ item -> get_time ( ) ; if ( empty ( $ time ) ) { echo '-' ; } else { echo $ time -> format ( get_option ( 'date_format' ) . ' ' . get_option ( 'time_format' ) ) ; } }
11533	public static function readFile ( $ file ) { if ( ! file_exists ( $ file ) ) { return null ; } $ handle = fopen ( $ file , 'r' ) ; if ( ! self :: lockFile ( $ handle , LOCK_SH | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_reading' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } $ contents = file_get_contents ( $ file ) ; self :: unlockFile ( $ handle ) ; return $ contents ; }
5736	private function getShowParameters ( Request $ request ) { $ showingAll = FALSE ; $ start = - 100 ; $ count = - 1 ; if ( $ request -> query -> has ( 'all' ) ) { $ start = 0 ; $ count = - 1 ; $ showingAll = TRUE ; } return [ $ start , $ count , $ showingAll ] ; }
4521	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; if ( $ user instanceof User ) { $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getIdentity ( ) -> getType ( ) ) ; } else { $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getIdentity ( ) ) ; } $ event -> setData ( $ data ) ; }
6170	protected function onAddError ( \ Exception $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'E' ) ; $ this -> exception = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
9600	public function length ( ) { $ sumOfSquares = 0 ; foreach ( $ this -> components ( ) as $ component ) { $ sumOfSquares += pow ( $ component , 2 ) ; } return sqrt ( $ sumOfSquares ) ; }
7239	protected function getAddressFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerAddressInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerAddressInterface :: class ) ; } return $ resource ; }
1791	private function prepareDomain ( RequestContext $ context , array & $ parameters , int & $ referenceType ) : void { if ( isset ( $ parameters [ '_ssl' ] ) ) { $ context -> setScheme ( true === $ parameters [ '_ssl' ] ? 'https' : 'http' ) ; } if ( isset ( $ parameters [ '_domain' ] ) && '' !== $ parameters [ '_domain' ] ) { $ this -> addHostToContext ( $ context , $ parameters , $ referenceType ) ; } unset ( $ parameters [ '_domain' ] , $ parameters [ '_ssl' ] ) ; }
7041	protected function setState ( PaymentSubjectInterface $ subject , $ state ) { if ( $ state !== $ subject -> getPaymentState ( ) ) { $ subject -> setPaymentState ( $ state ) ; return true ; } return false ; }
5156	private function getFilename ( string $ name ) : string { return sprintf ( "%s/%s.%s" , $ this -> directory , strtolower ( str_replace ( [ '/' , '\\' ] , '-' , $ name ) ) , self :: EXTENSION ) ; }
4864	public function pop ( array $ options = [ ] ) { $ time = microtime ( true ) ; $ micro = sprintf ( "%06d" , ( $ time - floor ( $ time ) ) * 1000000 ) ; $ this -> now = new \ DateTime ( date ( 'Y-m-d H:i:s.' . $ micro , $ time ) , new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; $ now = $ this -> dateTimeToUTCDateTime ( $ this -> now ) ; $ envelope = $ this -> mongoCollection -> findOneAndUpdate ( [ 'queue' => $ this -> getName ( ) , 'status' => self :: STATUS_PENDING , 'scheduled' => [ '$lte' => $ now ] , ] , [ '$set' => [ 'status' => self :: STATUS_RUNNING , 'executed' => $ now , ] , ] , [ 'sort' => [ 'priority' => 1 , 'scheduled' => 1 ] , 'returnDocument' => \ MongoDB \ Operation \ FindOneAndUpdate :: RETURN_DOCUMENT_AFTER ] ) ; if ( ! $ envelope ) { return null ; } return $ this -> unserializeJob ( $ envelope [ 'data' ] , [ '__id__' => $ envelope [ '_id' ] ] ) ; }
7964	public function ipGetMonitoringNotification ( $ ip , $ notificationId ) { return json_decode ( self :: getClient ( ) -> ipGetMonitoringNotification ( $ this -> id , $ ip , $ notificationId ) ) ; }
2544	protected function analyzeWithErrCodeCategoryMsgNodeName ( SendResult $ response , $ nodeErr , $ nodeCat , $ nodeMsg ) { $ analyzeResponse = new Result ( $ response ) ; $ domDoc = $ this -> loadDomDocument ( $ response -> responseXml ) ; $ errorCodeNode = $ domDoc -> getElementsByTagName ( $ nodeErr ) -> item ( 0 ) ; if ( ! is_null ( $ errorCodeNode ) ) { $ errorCatNode = $ domDoc -> getElementsByTagName ( $ nodeCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } else { $ analyzeResponse -> status = Result :: STATUS_ERROR ; } $ errorCode = $ errorCodeNode -> nodeValue ; $ errorTextNodeList = $ domDoc -> getElementsByTagName ( $ nodeMsg ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ) ; } return $ analyzeResponse ; }
11461	public static function enable ( $ state = true , $ enable_assert = false ) { $ state = ( bool ) $ state ; self :: enableAssert ( ( bool ) $ enable_assert ) ; if ( $ state && self :: $ _enabled || ! $ state && ! self :: $ _enabled ) { return ; } if ( $ state ) { set_exception_handler ( __CLASS__ . '::exception' ) ; set_error_handler ( __CLASS__ . '::error' , error_reporting ( ) ) ; assert_options ( ASSERT_CALLBACK , __CLASS__ . '::assert' ) ; self :: $ _enabled = true ; } else { restore_exception_handler ( ) ; restore_error_handler ( ) ; assert_options ( ASSERT_CALLBACK , function ( ) { } ) ; self :: $ _enabled = false ; } }
5862	protected function expandValuesInRuleset ( array $ ruleset ) { $ values = [ ] ; foreach ( $ ruleset as $ key => $ value ) { switch ( $ key ) { case 'usergroup' : $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; break ; case 'directories' : $ values [ 'directories_config' ] = '' ; $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; foreach ( $ value as & $ directory ) { $ directory = rtrim ( $ directory , '/' ) . '/' ; if ( ! empty ( $ values [ 'directories_config' ] ) ) { $ values [ 'directories_config' ] .= ',' ; } $ values [ 'directories_config' ] .= $ directory ; $ directory = $ this -> getDirectoryPattern ( $ directory ) ; } if ( count ( $ value ) == 0 ) { $ value = '' ; } break ; case 'file_types' : $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; if ( count ( $ value ) == 0 ) { $ value = '' ; } break ; case 'threshold' : if ( ! is_numeric ( $ value ) ) { $ unit = strtoupper ( substr ( $ value , - 1 ) ) ; $ factor = 1 * ( $ unit === 'K' ? 1024 : ( $ unit === 'M' ? 1024 * 1024 : 0 ) ) ; $ value = intval ( trim ( substr ( $ value , 0 , strlen ( $ value ) - 1 ) ) ) * $ factor ; } case 'max_width' : case 'max_height' : if ( $ value <= 0 ) { $ value = '' ; } break ; case 'max_size' : if ( ! is_numeric ( $ value ) ) { $ unit = strtoupper ( substr ( $ value , - 1 ) ) ; $ factor = 1 * ( $ unit === 'M' ? 1000000 : 1 ) ; $ value = intval ( trim ( substr ( $ value , 0 , strlen ( $ value ) - 1 ) ) ) * $ factor ; } break ; case 'conversion_mapping' : if ( strpos ( $ value , CRLF ) !== false ) { $ mapping = GeneralUtility :: trimExplode ( CRLF , $ value , true ) ; } else { $ mapping = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; } if ( count ( $ mapping ) > 0 ) { $ value = $ this -> expandConversionMapping ( $ mapping ) ; } else { $ value = '' ; } break ; } $ values [ $ key ] = $ value ; } return $ values ; }
3944	public static function searchFiles ( $ folder , $ extension ) { $ scanResult = array ( ) ; $ result = array ( ) ; if ( is_dir ( TL_ROOT . '/' . $ folder ) ) { $ scanResult = scan ( TL_ROOT . '/' . $ folder ) ; } foreach ( $ scanResult as $ value ) { if ( ! is_file ( TL_ROOT . '/' . $ folder . '/' . $ value ) ) { $ result += self :: searchFiles ( $ folder . '/' . $ value , $ extension ) ; } else { if ( preg_match ( '/' . $ extension . '$/i' , $ value ) ) { $ result [ $ folder ] [ $ folder . '/' . $ value ] = $ value ; } } } return $ result ; }
6921	public function get ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false ) { $ key = $ this -> buildKey ( $ taxGroup , $ country , $ business ) ; if ( isset ( $ this -> taxes [ $ key ] ) ) { return $ this -> taxes [ $ key ] ; } return null ; }
2382	public static function findPublishedByParentAndIdOrAlias ( $ varId , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrColumns [ ] = "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ varId , $ arrOptions ) ; }
1150	public function render ( $ view = null , $ selector = null ) { $ this -> view ( $ view ) ; $ this -> selector ( $ selector ) ; return View :: make ( $ this -> view , [ 'validator' => $ this -> getViewData ( ) ] ) -> render ( ) ; }
15	public function replaceVersion ( $ version , $ prettyVersion ) { $ this -> version = $ version ; $ this -> prettyVersion = $ prettyVersion ; $ this -> stability = VersionParser :: parseStability ( $ version ) ; $ this -> dev = $ this -> stability === 'dev' ; }
10342	protected function isValidDate ( $ year , $ month , $ day ) { if ( $ month <= 0 || $ month > 12 || $ day <= 0 || $ day > 31 ) { return false ; } if ( ( $ month == 4 || $ month == 6 || $ month == 9 || $ month == 11 ) && ( $ day == 31 ) ) { return false ; } if ( $ month == 2 ) { if ( $ day > 29 ) { return false ; } $ leap = date ( 'L' , strtotime ( $ year . '-01-01' ) ) ; if ( $ leap === '0' && $ day > 28 ) { return false ; } } return true ; }
958	public function remainingTrialDaysFromCancel ( ) { if ( ! $ this -> isTrial ( ) ) { return ; } $ cancelledDate = Carbon :: parse ( $ this -> cancelled_on ) ; $ trialEndsDate = Carbon :: parse ( $ this -> trial_ends_on ) ; if ( $ this -> isCancelled ( ) && $ cancelledDate -> lte ( $ trialEndsDate ) ) { return $ this -> trial_days - ( $ this -> trial_days - $ cancelledDate -> diffInDays ( $ trialEndsDate ) ) ; } return 0 ; }
10427	private function initShops ( ContainerBuilder $ container , array $ config ) { $ activeShop = ! empty ( $ config [ 'active_shop' ] ) ? $ config [ 'active_shop' ] : null ; if ( $ activeShop !== null && ! isset ( $ config [ 'shops' ] [ $ activeShop ] ) ) { throw new LogicException ( "Parameter 'ongr_connections.active_shop' must be set to one" . "of the values defined in 'ongr_connections.shops'." ) ; } $ container -> setParameter ( 'ongr_connections.active_shop' , $ activeShop ) ; $ container -> setParameter ( 'ongr_connections.shops' , $ config [ 'shops' ] ) ; $ container -> setDefinition ( 'ongr_connections.shop_service' , new Definition ( 'ONGR\ConnectionsBundle\Service\ShopService' , [ $ activeShop , $ config [ 'shops' ] , ] ) ) ; }
2265	public function fieldExists ( $ strField , $ strTable , $ blnNoCache = false ) { if ( $ strField == '' || $ strTable == '' ) { return false ; } foreach ( $ this -> listFields ( $ strTable , $ blnNoCache ) as $ arrField ) { if ( $ arrField [ 'name' ] == $ strField && $ arrField [ 'type' ] != 'index' ) { return true ; } } return false ; }
10768	public static function accountToIBAN ( $ account , $ country = 'CZ' ) { $ allowedCountries = [ 'AT' , 'BE' , 'BG' , 'CZ' , 'CY' , 'DK' , 'EE' , 'FI' , 'FR' , 'DE' , 'GI' , 'GR' , 'HU' , 'IE' , 'IS' , 'IT' , 'LI' , 'LT' , 'LU' , 'LV' , 'MC' , 'MT' , 'NL' , 'NO' , 'PL' , 'PT' , 'RO' , 'SE' , 'CH' , 'SI' , 'SK' , 'ES' , 'GB' ] ; $ account = self :: normalizeAccountNumber ( $ account ) ; $ accountArray = explode ( '/' , str_replace ( '-' , '' , $ account ) ) ; if ( 2 !== \ count ( $ accountArray ) ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Wrong bank account (some part missing).' ) ) ; } $ country = strtoupper ( $ country ) ; if ( ! \ in_array ( $ country , $ allowedCountries , true ) ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid country code.' ) ) ; } $ accountStr = str_pad ( $ accountArray [ 1 ] , 4 , '0' , STR_PAD_LEFT ) . str_pad ( $ accountArray [ 0 ] , 16 , '0' , STR_PAD_LEFT ) . ( \ ord ( $ country [ 0 ] ) - 55 ) . ( \ ord ( $ country [ 1 ] ) - 55 ) . '00' ; $ crc = '' ; $ pos = 0 ; while ( \ strlen ( $ accountStr ) > 0 ) { $ len = 9 - \ strlen ( $ crc ) ; $ crc = ( int ) ( $ crc . substr ( $ accountStr , $ pos , $ len ) ) % 97 ; $ accountStr = substr ( $ accountStr , $ len ) ; } return ( $ country . str_pad ( 98 - $ crc , 2 , '0' , STR_PAD_LEFT ) . $ accountArray [ 1 ] . $ accountArray [ 0 ] ) ; }
12480	protected function findSlotsInTemplates ( ) { $ templates = $ this -> findTemplates ( ) ; $ slots = array ( ) ; foreach ( $ templates [ "base" ] as $ templateName => $ templateFile ) { $ templateContents = FilesystemTools :: readFile ( $ templateFile ) ; $ slots = array_merge_recursive ( $ slots , $ this -> findSlots ( $ templateName , $ templateContents ) ) ; } $ baseSlots [ "base" ] = $ slots ; $ slots = array ( ) ; foreach ( $ templates [ "template" ] as $ templateName => $ templateFile ) { $ templateContents = FilesystemTools :: readFile ( $ templateFile ) ; $ slots [ $ templateName ] = $ this -> findSlots ( $ templateName , $ templateContents ) ; } return array ( 'base' => $ baseSlots , 'templates' => $ slots , ) ; }
5360	protected function createBodyStatements ( Operation $ operation , $ queryParamVariable , Context $ context ) { $ bodyParameter = null ; $ bodyVariable = new Expr \ Variable ( 'body' ) ; $ parameterKey = 0 ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ bodyParameter = $ parameter ; $ parameterKey = $ key ; } } } if ( null === $ bodyParameter ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( $ queryParamVariable , 'buildFormDataString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] , $ bodyVariable ] ; } if ( $ bodyParameter -> getSchema ( ) instanceof Reference || $ context -> getRegistry ( ) -> hasClass ( $ operation -> getReference ( ) . '/parameters/' . $ parameterKey ) ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( new Expr \ PropertyFetch ( new Expr \ Variable ( 'this' ) , 'serializer' ) , 'serialize' , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) , new Arg ( new Scalar \ String_ ( 'json' ) ) ] ) ) ] , $ bodyVariable ] ; } return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) ] , $ bodyVariable ] ; }
5275	public function having ( $ column , $ param1 = null , $ param2 = null ) { $ this -> statements [ 'having' ] = $ this -> generateWhere ( $ column , $ param1 , $ param2 , 'having' ) ; return $ this ; }
12123	public function onEntryUpdate ( ContentfulEntryEvent $ e ) { $ entry = $ e -> getEntry ( ) ; $ key = $ this -> getCacheKeyItem ( $ entry -> getId ( ) , 'uri' ) ; $ urisForItemOption = Option :: fromValue ( $ this -> cache -> fetch ( $ key ) , false ) ; if ( $ urisForItemOption -> isEmpty ( ) ) { Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ entry ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] Entry "%s" is not used.' , $ entry -> getId ( ) ) ) ; } ) ; return ; } $ urisForItem = $ urisForItemOption -> get ( ) ; foreach ( $ urisForItem as $ uri => $ bool ) { $ key = $ this -> getCacheKeyRequest ( sha1 ( $ uri ) , 'lastmodified' ) ; $ lastModified = $ this -> cache -> fetch ( $ key ) ; if ( $ lastModified >= $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) { Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ lastModified , $ uri ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] "%s" was last modified at "%s". Entry is older.' , $ uri , $ lastModified ) ) ; } ) ; continue ; } $ this -> cache -> save ( $ key , $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) ; Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ entry , $ uri ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] Setting last modified time for "%s" to "%s".' , $ uri , $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) ) ; } ) ; } }
9979	public function writeComments ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ comments = $ pWorksheet -> getComments ( ) ; $ authors = [ ] ; $ authorId = 0 ; foreach ( $ comments as $ comment ) { if ( ! isset ( $ authors [ $ comment -> getAuthor ( ) ] ) ) { $ authors [ $ comment -> getAuthor ( ) ] = $ authorId ++ ; } } $ objWriter -> startElement ( 'comments' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> startElement ( 'authors' ) ; foreach ( $ authors as $ author => $ index ) { $ objWriter -> writeElement ( 'author' , $ author ) ; } $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'commentList' ) ; foreach ( $ comments as $ key => $ value ) { $ this -> writeComment ( $ objWriter , $ key , $ value , $ authors ) ; } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
1300	private function getLocaleForCacheKey ( string $ locale = null ) : string { if ( $ locale ) { return $ locale ; } return $ this -> getEnvironment ( ) -> getDefaultLocale ( ) -> getCode ( ) ; }
741	public function beforeRun ( $ event ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ fragmentCacheConfiguration = $ this -> getFragmentCacheConfiguration ( ) ; if ( ! $ this -> owner -> view -> beginCache ( $ cacheKey , $ fragmentCacheConfiguration ) ) { $ event -> isValid = false ; } }
2867	public function getContent ( $ filePath , $ startPosition , $ endPosition ) { if ( ! file_exists ( $ filePath ) ) { return '' ; } if ( ! $ endPosition ) { return trim ( file_get_contents ( $ filePath , null , null , $ startPosition ) ) ; } if ( $ endPosition <= $ startPosition ) { return '' ; } return trim ( file_get_contents ( $ filePath , null , null , $ startPosition , $ endPosition - $ startPosition ) ) ; }
10031	function synchronizeContacts ( $ contacts , $ permission = null , $ syncMode = null , $ useExternalId = false , $ ignoreInvalidContacts = false , $ reimportUnsubscribedContacts = true , $ overridePermission = true , $ updateOnly = false , $ preferMaileonId = false ) { $ queryParameters = array ( 'permission' => ( $ permission == null ) ? 1 : $ permission -> getCode ( ) , 'sync_mode' => ( $ syncMode == null ) ? 2 : $ syncMode -> getCode ( ) , 'use_external_id' => ( $ useExternalId == TRUE ) ? "true" : "false" , 'ignore_invalid_contacts' => ( $ ignoreInvalidContacts == TRUE ) ? "true" : "false" , 'reimport_unsubscribed_contacts' => ( $ reimportUnsubscribedContacts == TRUE ) ? "true" : "false" , 'override_permission' => ( $ overridePermission == TRUE ) ? "true" : "false" , 'update_only' => ( $ updateOnly == TRUE ) ? "true" : "false" , 'prefer_maileon_id' => ( $ preferMaileonId == TRUE ) ? "true" : "false" ) ; $ cleanedContacts = new Contacts ( ) ; foreach ( $ contacts as $ contact ) { $ cleanedContact = new Contact ( $ contact -> id , $ contact -> email , null , $ contact -> external_id , null , $ contact -> standard_fields , $ contact -> custom_fields ) ; $ cleanedContacts -> addContact ( $ cleanedContact ) ; } return $ this -> post ( "contacts" , $ cleanedContacts -> toXMLString ( ) , $ queryParameters ) ; }
8098	protected function toCollection ( $ data ) { if ( is_array ( $ data ) ) { return new Collection ( $ data ) ; } else { if ( ! ( $ data instanceof Collection ) ) { $ data = new Collection ( ) ; } } return $ data ; }
6681	public function afterAction ( $ action , $ result ) { $ result = parent :: afterAction ( $ action , $ result ) ; $ this -> setSecurityHeaders ( ) ; if ( extension_loaded ( 'newrelic' ) ) { newrelic_name_transaction ( $ action -> controller -> id . '/' . $ action -> id ) ; } return $ result ; }
1984	public function getAllOptions ( ) : array { $ this -> loadOptions ( ) ; $ event = new ImageSizesEvent ( $ this -> options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_ALL , $ event ) ; return $ event -> getImageSizes ( ) ; }
12585	static function run_convert_configuration ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ extname = @ $ args [ 0 ] ; if ( $ extname == '' ) { $ extname = dirname ( __FILE__ ) ; } while ( ! is_file ( "ant/$extname.properties" ) ) { $ extname = pake_input ( 'What is the name of the current extension?' ) ; if ( ! is_file ( "ant/$extname.properties" ) ) { pake_echo ( "File ant/$extname.properties not found" ) ; } } self :: convertPropertyFileToYamlFile ( "ant/$extname.properties" , self :: getConfigDir ( ) . "/options-$extname.yaml" , array ( $ extname => '' , 'external' => 'dependencies' , 'dependency' => 'extensions' , 'repository' => array ( 'svn' , 'url' ) ) , "extension:\n name: $extname\n\n" ) ; foreach ( array ( 'files.to.parse.txt' => 'to_parse' , 'files.to.exclude.txt' => 'to_exclude' ) as $ file => $ option ) { $ src = "ant/$file" ; if ( file_exists ( $ src ) ) { if ( count ( $ in = file ( $ src , FILE_SKIP_EMPTY_LINES | FILE_IGNORE_NEW_LINES ) ) ) { $ in = "\n\nfiles:\n $option: [" . implode ( ', ' , $ in ) . "]\n" ; file_put_contents ( self :: getConfigDir ( ) . "options-$extname.yaml" , $ in , FILE_APPEND ) ; } } } }
11079	public static function getMonthName ( $ month ) { if ( $ month < 1 || $ month > 12 ) { return '' ; } $ monthNames = [ 1 => self :: poorManTranslate ( 'fts-shared' , 'January' ) , 2 => self :: poorManTranslate ( 'fts-shared' , 'February' ) , 3 => self :: poorManTranslate ( 'fts-shared' , 'March' ) , 4 => self :: poorManTranslate ( 'fts-shared' , 'April' ) , 5 => self :: poorManTranslate ( 'fts-shared' , 'May' ) , 6 => self :: poorManTranslate ( 'fts-shared' , 'June' ) , 7 => self :: poorManTranslate ( 'fts-shared' , 'July' ) , 8 => self :: poorManTranslate ( 'fts-shared' , 'August' ) , 9 => self :: poorManTranslate ( 'fts-shared' , 'September' ) , 10 => self :: poorManTranslate ( 'fts-shared' , 'October' ) , 11 => self :: poorManTranslate ( 'fts-shared' , 'November' ) , 12 => self :: poorManTranslate ( 'fts-shared' , 'December' ) , ] ; return $ monthNames [ $ month ] ; }
52	public function setOutputProgress ( $ outputProgress ) { foreach ( $ this -> downloaders as $ downloader ) { $ downloader -> setOutputProgress ( $ outputProgress ) ; } return $ this ; }
327	public function send ( MailerInterface $ mailer = null ) { if ( $ mailer === null && $ this -> mailer === null ) { $ mailer = Yii :: $ app -> getMailer ( ) ; } elseif ( $ mailer === null ) { $ mailer = $ this -> mailer ; } return $ mailer -> send ( $ this ) ; }
4924	public function type ( $ className ) { if ( ! class_exists ( $ className ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Class %s is non-existent or could not be loaded' , $ className ) ) ; } $ this -> matrix [ $ this -> currentRegion ] [ ] = $ className ; return $ this ; }
4812	public function add ( $ name , $ value ) { if ( array_key_exists ( $ name , $ this -> storage ) ) { throw new AlreadyDefinedException ( sprintf ( 'Context value with key `%s` already defined' , $ name ) ) ; } $ this -> storage [ $ name ] = $ value ; }
565	public function getScriptFile ( ) { if ( $ this -> _scriptFile === null ) { if ( isset ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ) { $ this -> setScriptFile ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ; } else { throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } } return $ this -> _scriptFile ; }
4586	protected function getSignature ( ) : string { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; $ signature = substr ( md5 ( $ request -> server -> get ( 'HTTP_USER_AGENT' ) ) , 0 , $ this -> length ) ; return $ signature ; }
5402	public function isExpired ( $ now ) { if ( ! $ this -> expiry ) { return true ; } if ( is_string ( $ now ) ) { $ now = strtotime ( $ now ) ; } return ( $ this -> expiry < $ now ) ; }
5794	private function addBooleanColumnFalse ( array $ columnValues ) : array { foreach ( $ this -> getBooleanColumnNames ( ) as $ booleanColumnName ) { if ( ! isset ( $ columnValues [ $ booleanColumnName ] ) ) { $ columnValues [ $ booleanColumnName ] = Postgres :: BOOLEAN_FALSE ; } } return $ columnValues ; }
4588	public function setMaxResults ( ? int $ maxResults ) { $ this -> maxResults = $ maxResults ; $ this -> _maxResults = null !== $ maxResults ; return $ this ; }
8783	protected function publishes ( array $ paths , $ group = null ) { $ this -> ensurePublishArrayInitialized ( $ class = static :: class ) ; static :: $ publishes [ $ class ] = array_merge ( static :: $ publishes [ $ class ] , $ paths ) ; if ( $ group ) { $ this -> addPublishGroup ( $ group , $ paths ) ; } }
7245	private function buildSaleItemRemaining ( Common \ SaleItemInterface $ saleItem , Shipment \ RemainingList $ list , array $ shipments ) { if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ quantity = $ saleItem -> getTotalQuantity ( ) ; foreach ( $ shipments as $ shipment ) { foreach ( $ shipment -> getItems ( ) as $ item ) { if ( $ item -> getSaleItem ( ) === $ saleItem ) { $ quantity += $ shipment -> isReturn ( ) ? $ item -> getQuantity ( ) : - $ item -> getQuantity ( ) ; continue 2 ; } } } if ( 0 < $ quantity ) { $ entry = new Shipment \ RemainingEntry ( ) ; $ entry -> setSaleItem ( $ saleItem ) -> setQuantity ( $ quantity ) ; $ list -> addEntry ( $ entry ) ; } } foreach ( $ saleItem -> getChildren ( ) as $ child ) { $ this -> buildSaleItemRemaining ( $ child , $ list , $ shipments ) ; } }
11648	public function authenticate ( ) { $ this -> _authenticateSetup ( ) ; $ dbSelect = $ this -> _authenticateCreateSelect ( ) ; $ identity = $ this -> _authenticateQuerySelect ( $ dbSelect ) ; $ authResult = $ this -> _authenticateValidateResultSet ( $ identity ) ; if ( $ authResult instanceof Zend_Auth_Result ) { return $ authResult ; } return $ this -> _authenticateValidateResult ( array_shift ( $ identity ) ) ; }
5424	public function expectException ( $ expected = false , $ message = '%s' ) { $ this -> expected = $ this -> forceToExpectation ( $ expected ) ; $ this -> message = $ message ; }
884	private function getBestDelimiter ( $ pattern ) { $ delimiters = [ ] ; foreach ( self :: $ delimiters as $ k => $ d ) { if ( false === strpos ( $ pattern , $ d ) ) { return $ d ; } $ delimiters [ $ d ] = [ substr_count ( $ pattern , $ d ) , $ k ] ; } uasort ( $ delimiters , static function ( $ a , $ b ) { if ( $ a [ 0 ] === $ b [ 0 ] ) { return Utils :: cmpInt ( $ a , $ b ) ; } return $ a [ 0 ] < $ b [ 0 ] ? - 1 : 1 ; } ) ; return key ( $ delimiters ) ; }
12701	public function setEditorConfig ( $ config ) { if ( $ config instanceof Traversable ) { $ config = ArrayUtils :: iteratorToArray ( $ config ) ; } if ( ! is_array ( $ config ) ) { throw new InvalidArgumentException ( 'The options parameter must be an array or a Traversable' ) ; } $ this -> editorConfig = $ config ; return $ this ; }
12192	protected function doSave ( $ id , $ data , $ lifeTime = 0 ) { return $ this -> delegate -> doSave ( $ id , $ data , $ lifeTime ) ; }
12461	private function createMakeDefaultForm ( CustomFieldsGroup $ group = null ) { return $ this -> createFormBuilder ( $ group , array ( 'method' => 'POST' , 'action' => $ this -> generateUrl ( 'customfieldsgroup_makedefault' ) ) ) -> add ( 'id' , 'hidden' ) -> add ( 'submit' , 'submit' , array ( 'label' => 'Make default' ) ) -> getForm ( ) ; }
2052	public static function create ( $ file , $ size = null ) { if ( \ is_string ( $ file ) ) { $ file = new File ( rawurldecode ( $ file ) ) ; } $ imageSize = null ; $ picture = new static ( $ file ) ; if ( \ is_array ( $ size ) && ! empty ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ size = ( int ) $ size [ 2 ] ; } $ imageSize = null ; if ( ! \ is_array ( $ size ) ) { $ imageSize = ImageSizeModel :: findByPk ( $ size ) ; if ( $ imageSize === null ) { $ size = array ( ) ; } } if ( \ is_array ( $ size ) ) { $ size += array ( 0 , 0 , 'crop' ) ; $ imageSize = new \ stdClass ( ) ; $ imageSize -> width = $ size [ 0 ] ; $ imageSize -> height = $ size [ 1 ] ; $ imageSize -> resizeMode = $ size [ 2 ] ; $ imageSize -> zoom = 0 ; } $ picture -> setImageSize ( $ imageSize ) ; if ( $ imageSize !== null && ! empty ( $ imageSize -> id ) ) { $ picture -> setImageSizeItems ( ImageSizeItemModel :: findVisibleByPid ( $ imageSize -> id , array ( 'order' => 'sorting ASC' ) ) ) ; } $ fileRecord = FilesModel :: findByPath ( $ file -> path ) ; if ( $ fileRecord !== null && $ fileRecord -> importantPartWidth && $ fileRecord -> importantPartHeight ) { $ picture -> setImportantPart ( array ( 'x' => ( int ) $ fileRecord -> importantPartX , 'y' => ( int ) $ fileRecord -> importantPartY , 'width' => ( int ) $ fileRecord -> importantPartWidth , 'height' => ( int ) $ fileRecord -> importantPartHeight , ) ) ; } return $ picture ; }
8418	public static function registerDatabase ( string $ alias ) { if ( isset ( self :: $ databases [ $ alias ] ) === false ) { self :: $ databases [ $ alias ] = new static ( $ alias ) ; } }
1729	protected function regenerateSessionId ( ) { @ trigger_error ( 'Using User::regenerateSessionId() has been deprecated and will no longer work in Contao 5.0. Use Symfony authentication instead.' , E_USER_DEPRECATED ) ; $ container = System :: getContainer ( ) ; $ strategy = $ container -> getParameter ( 'security.authentication.session_strategy.strategy' ) ; switch ( $ strategy ) { case SessionAuthenticationStrategy :: NONE : break ; case SessionAuthenticationStrategy :: MIGRATE : $ container -> get ( 'session' ) -> migrate ( ) ; break ; case SessionAuthenticationStrategy :: INVALIDATE : $ container -> get ( 'session' ) -> invalidate ( ) ; break ; default : throw new \ RuntimeException ( sprintf ( 'Invalid session authentication strategy "%s"' , $ strategy ) ) ; } }
1783	protected function countItems ( $ newsArchives , $ blnFeatured ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] as $ callback ) { if ( ( $ intResult = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ newsArchives , $ blnFeatured , $ this ) ) === false ) { continue ; } if ( \ is_int ( $ intResult ) ) { return $ intResult ; } } } return NewsModel :: countPublishedByPids ( $ newsArchives , $ blnFeatured ) ; }
1973	public static function findMultipleByPaths ( $ arrPaths , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPaths ) || ! \ is_array ( $ arrPaths ) ) { return null ; } $ t = static :: $ strTable ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.path" , $ arrPaths ) ; } return static :: findBy ( array ( "$t.path IN(" . implode ( ',' , array_fill ( 0 , \ count ( $ arrPaths ) , '?' ) ) . ")" ) , $ arrPaths , $ arrOptions ) ; }
3237	public function getTotalAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return $ this -> totalPrice + $ this -> totalTax + $ this -> totalShipping ; }
10475	public function listen ( string $ event , callable $ callback ) : EventChannelInterface { $ this -> channel -> listen ( $ event , $ callback ) ; return $ this ; }
2674	public function deleteAcl ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/acl/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; }
11676	protected function get ( $ locale , $ file , $ key ) { $ this -> load ( $ locale , $ file ) ; if ( array_key_exists ( $ key , $ this -> translations [ $ locale ] [ $ file ] ) === false ) { throw new TranslationKeyNotFound ( $ key , $ this -> getPath ( ) , $ locale , $ file ) ; } $ result = $ this -> translations [ $ locale ] [ $ file ] [ $ key ] ; if ( is_string ( $ result ) === false ) { throw new TranslationKeyIsNotAString ( $ result , $ key , $ this -> getPath ( ) , $ locale , $ file ) ; } return $ result ; }
5692	public function baseTransform ( ) { parent :: baseTransform ( ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons_delete.js' ) ; return $ this -> setUseButtonTag ( true ) -> addExtraClass ( 'btn-danger-outline btn-hide-outline font-icon-trash-bin gridfield-better-buttons-delete' ) -> setAttribute ( "data-toggletext" , _t ( 'GridFieldBetterButtons.AREYOUSURE' , 'Yes. Delete this item.' ) ) -> setAttribute ( "data-confirmtext" , _t ( 'GridFieldDetailForm.CANCELDELETE' , 'No. Don\'t delete.' ) ) ; }
6369	public static function compose ( callable $ g , callable $ f ) : callable { return function ( $ input ) use ( $ g , $ f ) { return Functions :: call ( $ g , Functions :: call ( $ f , $ input ) ) ; } ; }
9439	public function alias ( $ id , $ original ) { $ this -> instances [ $ id ] = $ this -> get ( $ original ) ; return $ this ; }
5259	public static function all ( $ query = [ ] ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ collection = collect ( ) ; static :: map ( $ query , function ( ElasticsearchModel $ document ) use ( $ collection ) { $ collection -> put ( $ document -> getId ( ) , $ document ) ; } ) ; return $ collection ; }
4237	public static function getMetaVals ( & $ args , $ defaultMeta = array ( ) , $ defaultArgs = array ( ) , $ argsToMeta = array ( ) ) { $ meta = array ( ) ; foreach ( $ args as $ i => $ v ) { if ( \ is_array ( $ v ) && isset ( $ v [ 'debug' ] ) && $ v [ 'debug' ] === Debug :: META ) { unset ( $ v [ 'debug' ] ) ; $ meta = \ array_merge ( $ meta , $ v ) ; unset ( $ args [ $ i ] ) ; } } $ args = \ array_values ( $ args ) ; if ( $ defaultArgs ) { $ args = \ array_slice ( $ args , 0 , \ count ( $ defaultArgs ) ) ; $ args = \ array_combine ( \ array_keys ( $ defaultArgs ) , \ array_replace ( \ array_values ( $ defaultArgs ) , $ args ) ) ; } foreach ( $ argsToMeta as $ argk => $ metak ) { if ( \ is_int ( $ argk ) ) { $ argk = $ metak ; } $ defaultMeta [ $ metak ] = $ args [ $ argk ] ; unset ( $ args [ $ argk ] ) ; } $ meta = \ array_merge ( $ defaultMeta , $ meta ) ; return $ meta ; }
6123	public function login ( $ username , $ password ) { $ this -> execute ( "login" , array ( "client_login_name" => $ username , "client_login_password" => $ password ) ) ; $ this -> whoamiReset ( ) ; $ crypt = new Crypt ( $ username ) ; $ this -> setStorage ( "_login_user" , $ username ) ; $ this -> setStorage ( "_login_pass" , $ crypt -> encrypt ( $ password ) ) ; Signal :: getInstance ( ) -> emit ( "notifyLogin" , $ this ) ; }
2091	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ 'form' ] [ 0 ] ) . ' ###' ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> title ; $ objTemplate -> href = 'contao/main.php?do=form&amp;table=tl_form_field&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> customTpl != '' && TL_MODE == 'FE' ) { $ this -> strTemplate = $ this -> customTpl ; } return parent :: generate ( ) ; }
10647	private function buildMessages ( $ scope = 'create' ) { $ custom_messages = $ this -> messages [ 'global' ] ; foreach ( $ this -> messages [ $ scope ] as $ key => $ value ) { $ custom_messages [ $ key ] = $ value ; } return $ custom_messages ; }
501	protected function getHeaderCheckBoxName ( ) { $ name = $ this -> name ; if ( substr_compare ( $ name , '[]' , - 2 , 2 ) === 0 ) { $ name = substr ( $ name , 0 , - 2 ) ; } if ( substr_compare ( $ name , ']' , - 1 , 1 ) === 0 ) { $ name = substr ( $ name , 0 , - 1 ) . '_all]' ; } else { $ name .= '_all' ; } return $ name ; }
10174	public function delete ( $ pCoord ) { if ( $ pCoord === $ this -> currentCoordinate && $ this -> currentCell !== null ) { $ this -> currentCell -> detach ( ) ; $ this -> currentCoordinate = null ; $ this -> currentCell = null ; $ this -> currentCellIsDirty = false ; } unset ( $ this -> index [ $ pCoord ] ) ; $ this -> cache -> delete ( $ this -> cachePrefix . $ pCoord ) ; }
7371	public function editAction ( ) { $ user = $ this -> getUser ( ) ; $ form = $ this -> createForm ( ProfileType :: class , $ user ) ; return array ( 'form' => $ form -> createView ( ) , ) ; }
12613	private function checkOptions ( $ options ) { foreach ( $ this -> required as $ req ) { if ( ! array_key_exists ( $ req , $ options ) ) { throw new \ Exception ( '"' . $ req . '" option has not been defined' ) ; } } }
8011	private static function setParityBit ( $ byte ) { $ parity = 1 ; for ( $ i = 1 ; $ i < 8 ; $ i ++ ) { $ parity = ( $ parity + ( ( $ byte >> $ i ) & 1 ) ) % 2 ; } $ byte = $ byte | ( $ parity & 1 ) ; return $ byte ; }
4701	protected function createCiconia ( InputInterface $ input ) { if ( $ input -> getOption ( 'diagnose' ) ) { $ ciconia = new \ Ciconia \ Diagnose \ Ciconia ( ) ; } else { $ ciconia = new Ciconia ( ) ; } if ( $ input -> getOption ( 'format' ) == 'xhtml' ) { $ ciconia -> setRenderer ( new XhtmlRenderer ( ) ) ; } if ( $ input -> getOption ( 'gfm' ) ) { $ ciconia -> addExtensions ( [ new FencedCodeBlockExtension ( ) , new InlineStyleExtension ( ) , new TaskListExtension ( ) , new WhiteSpaceExtension ( ) , new TableExtension ( ) , new UrlAutoLinkExtension ( ) ] ) ; } return $ ciconia ; }
2022	public static function findFirstPublishedRootByHostAndLanguage ( $ strHost , $ varLanguage , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using PageModel::findFirstPublishedRootByHostAndLanguage() has been deprecated and will no longer work Contao 5.0.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; if ( \ is_array ( $ varLanguage ) ) { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='')" ) ; if ( ! empty ( $ varLanguage ) ) { $ arrColumns [ ] = "($t.language IN('" . implode ( "','" , $ varLanguage ) . "') OR $t.fallback='1')" ; } else { $ arrColumns [ ] = "$t.fallback='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC" . ( ! empty ( $ varLanguage ) ? ", " . $ objDatabase -> findInSet ( "$t.language" , array_reverse ( $ varLanguage ) ) . " DESC" : "" ) . ", $t.sorting" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; } else { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='') AND ($t.language=? OR $t.fallback='1')" ) ; $ arrValues = array ( $ strHost , $ varLanguage ) ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC, $t.fallback" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; } }
5225	private function resolve ( Injector $ injector , $ type ) { $ resolved = [ ] ; foreach ( $ this -> getBindings ( ) as $ key => $ bindingValue ) { $ value = $ bindingValue ( $ injector , $ this -> name , $ key ) ; if ( $ this -> isTypeMismatch ( $ type , $ value ) ) { $ valueType = ( ( is_object ( $ value ) ) ? ( get_class ( $ value ) ) : ( gettype ( $ value ) ) ) ; throw new BindingException ( 'Value of type ' . $ valueType . ' for ' . ( ( is_int ( $ key ) ) ? ( 'list' ) : ( 'map' ) ) . ' named ' . $ this -> name . ' at position ' . $ key . ' is not of type ' . $ type -> getName ( ) ) ; } $ resolved [ $ key ] = $ value ; } return $ resolved ; }
9620	protected function httpPost ( $ host , $ path , array $ data , $ port = 80 ) { $ req = $ this -> qsencode ( $ data ) ; $ http_request = "POST {$path} HTTP/1.0\r\n" ; $ http_request .= "Host: {$host}\r\n" ; $ http_request .= "Content-Type: application/x-www-form-urlencoded;\r\n" ; $ http_request .= "Content-Length: " . strlen ( $ req ) . "\r\n" ; $ http_request .= "User-Agent: reCAPTCHA/PHP\r\n" ; $ http_request .= "\r\n" ; $ http_request .= $ req ; $ response = '' ; if ( false == ( $ fs = @ fsockopen ( $ host , ( int ) $ port , $ errno , $ errstr , 10 ) ) ) { throw new \ Exception ( 'Could not open socket' ) ; } fwrite ( $ fs , $ http_request ) ; while ( ! feof ( $ fs ) ) { $ response .= fgets ( $ fs , 1160 ) ; } fclose ( $ fs ) ; $ response = explode ( "\r\n\r\n" , $ response , 2 ) ; return $ response ; }
6338	public static function factory ( $ streamClass = 'GuzzleHttp\\Psr7\\Stream' ) { return new static ( [ new ResourceAdapter ( $ streamClass ) , new DomDocumentAdapter ( $ streamClass ) , new SimpleXmlAdapter ( $ streamClass ) , new StringAdapter ( $ streamClass ) , ] ) ; }
241	public function init ( ) { parent :: init ( ) ; if ( $ this -> model === null ) { throw new InvalidConfigException ( 'Please specify the "model" property.' ) ; } if ( $ this -> formatter === null ) { $ this -> formatter = Yii :: $ app -> getFormatter ( ) ; } elseif ( is_array ( $ this -> formatter ) ) { $ this -> formatter = Yii :: createObject ( $ this -> formatter ) ; } if ( ! $ this -> formatter instanceof Formatter ) { throw new InvalidConfigException ( 'The "formatter" property must be either a Format object or a configuration array.' ) ; } $ this -> normalizeAttributes ( ) ; if ( ! isset ( $ this -> options [ 'id' ] ) ) { $ this -> options [ 'id' ] = $ this -> getId ( ) ; } }
223	protected function normalizeNumericStringValue ( $ value ) { $ powerPosition = strrpos ( $ value , 'E' ) ; if ( $ powerPosition !== false ) { $ valuePart = substr ( $ value , 0 , $ powerPosition ) ; $ powerPart = substr ( $ value , $ powerPosition + 1 ) ; } else { $ powerPart = null ; $ valuePart = $ value ; } $ separatorPosition = strrpos ( $ valuePart , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ valuePart , 0 , $ separatorPosition ) ; $ fractionalPart = substr ( $ valuePart , $ separatorPosition + 1 ) ; } else { $ integerPart = $ valuePart ; $ fractionalPart = null ; } $ integerPart = preg_replace ( '/^\+?(-?)0*(\d+)$/' , '$1$2' , $ integerPart ) ; $ integerPart = preg_replace ( '/^\+?(-?)0*$/' , '${1}0' , $ integerPart ) ; if ( $ fractionalPart !== null ) { $ fractionalPart = rtrim ( $ fractionalPart , '0' ) ; if ( empty ( $ fractionalPart ) ) { $ fractionalPart = $ powerPart !== null ? '0' : null ; } } $ normalizedValue = $ integerPart ; if ( $ fractionalPart !== null ) { $ normalizedValue .= '.' . $ fractionalPart ; } elseif ( $ normalizedValue === '-0' ) { $ normalizedValue = '0' ; } if ( $ powerPart !== null ) { $ normalizedValue .= 'E' . $ powerPart ; } return $ normalizedValue ; }
691	protected function isActive ( $ action ) { $ id = $ this -> getActionId ( $ action ) ; if ( empty ( $ this -> only ) ) { $ onlyMatch = true ; } else { $ onlyMatch = false ; foreach ( $ this -> only as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ onlyMatch = true ; break ; } } } $ exceptMatch = false ; foreach ( $ this -> except as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ exceptMatch = true ; break ; } } return ! $ exceptMatch && $ onlyMatch ; }
949	public function sanitizeShopDomain ( $ domain ) { if ( empty ( $ domain ) ) { return ; } $ configEndDomain = Config :: get ( 'shopify-app.myshopify_domain' ) ; $ domain = strtolower ( preg_replace ( '/https?:\/\//i' , '' , trim ( $ domain ) ) ) ; if ( strpos ( $ domain , $ configEndDomain ) === false && strpos ( $ domain , '.' ) === false ) { $ domain .= ".{$configEndDomain}" ; } return parse_url ( "http://{$domain}" , PHP_URL_HOST ) ; }
11356	public function getInputFilter ( ) { if ( $ this -> filter ) { return $ this -> filter ; } $ specifications = [ ] ; if ( $ this -> object && $ this -> object instanceof InputFilterProviderInterface ) { $ specifications = $ this -> object -> getInputFilterSpecification ( ) ; } if ( $ this instanceof InputFilterProviderInterface ) { $ specifications = ArrayUtils :: merge ( $ specifications , $ this -> getInputFilterSpecification ( ) ) ; } $ this -> addRequiredAttributeToFields ( $ specifications ) ; if ( ! empty ( $ specifications ) && null === $ this -> baseFieldset ) { $ formFactory = $ this -> getFormFactory ( ) ; $ inputFactory = $ formFactory -> getInputFilterFactory ( ) ; if ( ! ( $ this -> filter instanceof InputFilterInterface ) ) { $ this -> filter = new InputFilter ( ) ; $ this -> filter -> setFactory ( $ inputFactory ) ; } foreach ( $ specifications as $ name => $ specification ) { $ input = $ inputFactory -> createInput ( $ specification ) ; $ this -> filter -> add ( $ input , $ name ) ; } } return parent :: getInputFilter ( ) ; }
10434	protected function prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) { return array_merge ( $ serviceConfig , $ typeConfig [ 'config' ] , [ 'entity_class' => $ typeConfig [ 'entity_class' ] , 'document_class' => $ typeConfig [ 'document_class' ] , 'document_type' => $ type , ] ) ; }
9538	private function getRealName ( $ param ) { $ parameterClosure = $ this -> getParameterClosure ( $ param ) ; if ( $ parameterClosure -> parent != null ) { return $ parameterClosure -> parent -> parameterName ; } else { return $ parameterClosure -> parameterName ; } }
10935	public function checkEmailAction ( ) { $ session = $ this -> get ( 'session' ) ; $ email = $ session -> get ( static :: SESSION_EMAIL ) ; $ session -> remove ( static :: SESSION_EMAIL ) ; if ( empty ( $ email ) ) { return new RedirectResponse ( $ this -> get ( 'router' ) -> generate ( 'miky_app_customer_resetting_request' ) ) ; } return $ this -> render ( 'MikyUserBundle:Frontend/Resetting:checkEmail.html.twig' , array ( 'email' => $ email , ) ) ; }
11526	public function resolve ( $ templatePath ) { $ templatePathReal = realpath ( $ templatePath ) ; if ( $ templatePathReal === false ) { throw new \ Exception ( 'Template file does not exist: ' . $ templatePath ) ; } if ( $ this -> hasCache ( $ templatePathReal ) ) { return $ this -> getCache ( $ templatePathReal ) ; } $ template = file_get_contents ( $ templatePathReal ) ; $ this -> setCache ( $ templatePathReal , $ template ) ; return $ template ; }
7879	protected function registerLogViewer ( ) { $ this -> app -> singleton ( 'logviewer' , function ( $ app ) { $ factory = $ app [ 'logviewer.factory' ] ; $ filesystem = $ app [ 'logviewer.filesystem' ] ; $ data = $ app [ 'logviewer.data' ] ; return new LogViewer ( $ factory , $ filesystem , $ data ) ; } ) ; $ this -> app -> alias ( 'logviewer' , LogViewer :: class ) ; }
7241	private function getDefaultClasses ( ) { return [ 'address' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAddress :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAddress :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAddress :: class , ] , 'attachment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAttachment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAttachment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAttachment :: class , ] , 'notification' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartNotification :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderNotification :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteNotification :: class , ] , 'item' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartItem :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderItem :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteItem :: class , ] , 'adjustment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAdjustment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAdjustment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAdjustment :: class , ] , 'item_adjustment' => [ Cart \ Model \ CartItemInterface :: class => Cart \ Entity \ CartItemAdjustment :: class , Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemAdjustment :: class , Quote \ Model \ QuoteItemInterface :: class => Quote \ Entity \ QuoteItemAdjustment :: class , ] , 'item_stock_assignment' => [ Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemStockAssignment :: class , ] , 'payment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartPayment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderPayment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuotePayment :: class , ] , 'shipment' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderShipment :: class , ] , 'shipment_item' => [ Order \ Model \ OrderShipmentInterface :: class => Order \ Entity \ OrderShipmentItem :: class , ] , 'invoice' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderInvoice :: class , ] , 'invoice_line' => [ Order \ Model \ OrderInvoiceInterface :: class => Order \ Entity \ OrderInvoiceLine :: class , ] , ] ; }
5443	protected function invokeParser ( $ content , $ is_match ) { if ( ( $ content === '' ) || ( $ content === false ) ) { return true ; } $ handler = $ this -> mode_handlers [ $ this -> mode -> getCurrent ( ) ] ; return $ this -> parser -> $ handler ( $ content , $ is_match ) ; }
365	public function renderColumnGroup ( ) { foreach ( $ this -> columns as $ column ) { if ( ! empty ( $ column -> options ) ) { $ cols = [ ] ; foreach ( $ this -> columns as $ col ) { $ cols [ ] = Html :: tag ( 'col' , '' , $ col -> options ) ; } return Html :: tag ( 'colgroup' , implode ( "\n" , $ cols ) ) ; } } return false ; }
1105	protected function applyLockBetween ( $ lft , $ rgt ) { $ this -> node -> newQuery ( ) -> where ( $ this -> node -> getLeftColumnName ( ) , '>=' , $ lft ) -> where ( $ this -> node -> getRightColumnName ( ) , '<=' , $ rgt ) -> select ( $ this -> node -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; }
3341	public function getFileList ( $ options = array ( ) ) { $ options = array_replace ( array ( 'from' => null , 'to' => null , 'limit' => null , 'request_limit' => null , 'stored' => $ this -> defaultFilters [ 'file' ] [ 'stored' ] , 'removed' => $ this -> defaultFilters [ 'file' ] [ 'removed' ] , 'reversed' => false , ) , $ options ) ; if ( ! empty ( $ options [ 'from' ] ) && ! empty ( $ options [ 'to' ] ) ) { throw new \ Exception ( 'Only one of "from" and "to" arguments is allowed' ) ; } $ options [ 'from' ] = self :: dateTimeString ( $ options [ 'from' ] ) ; $ options [ 'to' ] = self :: dateTimeString ( $ options [ 'to' ] ) ; foreach ( $ this -> defaultFilters [ 'file' ] as $ k => $ v ) { if ( ! is_null ( $ options [ $ k ] ) ) { $ options [ $ k ] = self :: booleanString ( $ options [ $ k ] ) ; } } return new FileIterator ( $ this , $ options ) ; }
9833	public function setWorkbookPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> workbookPassword = $ pValue ; return $ this ; }
864	private function registerFoundToken ( $ token ) { $ tokenKind = $ token instanceof Token ? ( $ token -> isArray ( ) ? $ token -> getId ( ) : $ token -> getContent ( ) ) : ( \ is_array ( $ token ) ? $ token [ 0 ] : $ token ) ; if ( ! isset ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { $ this -> foundTokenKinds [ $ tokenKind ] = 0 ; } ++ $ this -> foundTokenKinds [ $ tokenKind ] ; }
3729	protected function getAttributeImplementing ( $ interface ) { $ result = array ( ) ; foreach ( $ this -> getAttributes ( ) as $ colName => $ attribute ) { if ( $ attribute instanceof $ interface ) { $ result [ $ colName ] = $ attribute ; } } return $ result ; }
3050	protected function initStorage ( ) { $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ this -> getTestExecutionUri ( ) ) ; $ testResource = new \ core_kernel_classes_Resource ( $ this -> getTestDefinitionUri ( ) ) ; $ sessionManager = new \ taoQtiTest_helpers_SessionManager ( $ resultStore , $ testResource ) ; $ seeker = new BinaryAssessmentTestSeeker ( $ this -> getTestDefinition ( ) ) ; $ userUri = $ this -> getUserUri ( ) ; $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ storageClassName = $ config [ 'test-session-storage' ] ; $ this -> storage = new $ storageClassName ( $ sessionManager , $ seeker , $ userUri ) ; $ this -> sessionManager = $ sessionManager ; }
6280	public function nextkey ( ) { if ( $ this -> keyIterPos >= $ this -> keyIterStop ) { return false ; } $ keyLen = $ this -> readInt31 ( $ this -> keyIterPos ) ; $ dataLen = $ this -> readInt31 ( $ this -> keyIterPos + 4 ) ; $ key = $ this -> read ( $ this -> keyIterPos + 8 , $ keyLen ) ; $ this -> keyIterPos += 8 + $ keyLen + $ dataLen ; return $ key ; }
2002	public static function getVersion ( string $ packageName ) : string { $ version = Versions :: getVersion ( $ packageName ) ; return static :: parseVersion ( $ version ) ; }
9978	public function request ( $ url ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , $ this -> timeout ) ; $ response = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; if ( $ response === false ) { throw new \ RuntimeException ( 'Connection timeout.' ) ; } return $ response ; }
3071	protected function saveItemResponses ( $ emptyAllowed = true ) { if ( $ this -> getRequestParameter ( 'itemDefinition' ) && $ this -> getRequestParameter ( 'itemResponse' ) ) { $ itemDefinition = $ this -> getRequestParameter ( 'itemDefinition' ) ; $ serviceContext = $ this -> getServiceContext ( ) ; $ itemResponse = $ this -> getRequestParameter ( 'itemResponse' ) ? json_decode ( $ this -> getRequestParameter ( 'itemResponse' ) , true ) : null ; if ( ! is_null ( $ itemResponse ) && ! empty ( $ itemDefinition ) ) { $ responses = $ this -> getRunnerService ( ) -> parsesItemResponse ( $ serviceContext , $ itemDefinition , $ itemResponse ) ; if ( ! $ emptyAllowed && $ this -> getRunnerService ( ) -> getTestConfig ( ) -> getConfigValue ( 'enableAllowSkipping' ) && ! TestRunnerUtils :: doesAllowSkipping ( $ serviceContext -> getTestSession ( ) ) ) { if ( $ this -> getRunnerService ( ) -> emptyResponse ( $ serviceContext , $ responses ) ) { throw new QtiRunnerEmptyResponsesException ( ) ; } } return $ this -> getRunnerService ( ) -> storeItemResponse ( $ serviceContext , $ itemDefinition , $ responses ) ; } } return false ; }
10267	public function setEndColor ( Color $ pValue ) { $ color = $ pValue -> getIsSupervisor ( ) ? $ pValue -> getSharedComponent ( ) : $ pValue ; if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getEndColor ( ) -> getStyleArray ( [ 'argb' => $ color -> getARGB ( ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> endColor = $ color ; } return $ this ; }
1361	public function is ( string ... $ mediaTypes ) : bool { $ mediaTypes = collect ( $ mediaTypes ) -> map ( function ( $ mediaType , $ index ) { return MediaType :: parse ( $ index , $ mediaType ) ; } ) ; return $ this -> any ( ... $ mediaTypes ) ; }
4404	public function getPath ( $ locationId ) { $ pathArray = array ( ) ; $ startingLocation = $ this -> locationService -> loadLocation ( $ locationId ) ; $ path = $ startingLocation -> path ; array_shift ( $ path ) ; $ rootLocationFound = false ; foreach ( $ path as $ index => $ pathItem ) { if ( ( int ) $ pathItem === $ this -> rootLocationId ) { $ rootLocationFound = true ; } if ( ! $ rootLocationFound ) { continue ; } try { $ location = $ this -> locationService -> loadLocation ( $ pathItem ) ; } catch ( UnauthorizedException $ e ) { return array ( ) ; } $ pathArray [ ] = array ( 'text' => $ this -> translationHelper -> getTranslatedContentNameByContentInfo ( $ location -> contentInfo ) , 'url' => $ location -> id !== $ startingLocation -> id ? $ this -> router -> generate ( $ location ) : false , 'locationId' => $ location -> id , 'contentId' => $ location -> contentId , ) ; } return $ pathArray ; }
10037	function createCustomField ( $ name , $ type = 'string' ) { $ queryParameters = array ( 'type' => $ type ) ; $ encodedName = urlencode ( mb_convert_encoding ( $ name , "UTF-8" ) ) ; return $ this -> post ( "contacts/fields/custom/${encodedName}" , "" , $ queryParameters ) ; }
7679	function TbsMergeVarFields ( $ PrmVal , $ FldVal ) { $ this -> TBS -> meth_Merge_AutoVar ( $ PrmVal , true ) ; $ PrmVal = str_replace ( $ this -> TBS -> _ChrVal , $ FldVal , $ PrmVal ) ; return $ PrmVal ; }
5478	protected function setWidget ( $ tag ) { if ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'radio' ) { $ this -> addRadioButton ( $ tag ) ; } elseif ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'checkbox' ) { $ this -> addCheckbox ( $ tag ) ; } else { $ this -> widgets [ ] = $ tag ; } }
8748	public function addMethodCall ( $ methodName , array $ arguments = array ( ) ) { $ this -> actions [ ] = $ methodCall = new MethodCall ( $ methodName , $ arguments ) ; return $ methodCall ; }
11580	public function getStatus ( ) { $ message = 'Tracking ' ; $ numRepos = 0 ; if ( isset ( $ this [ 'repositories' ] ) && ( 1 === ( $ numRepos = count ( $ this [ 'repositories' ] ) ) ) ) { $ message .= '1 repository.' ; } else { $ message .= $ numRepos . ' repositories.' ; } return $ message ; }
5223	protected function getValueCreator ( $ value ) { if ( is_string ( $ value ) && class_exists ( $ value ) ) { return function ( $ injector ) use ( $ value ) { return $ injector -> getInstance ( $ value ) ; } ; } return function ( ) use ( $ value ) { return $ value ; } ; }
1965	public function generate ( ) { $ this -> multiSRC = StringUtil :: deserialize ( $ this -> multiSRC ) ; if ( empty ( $ this -> multiSRC ) || ! \ is_array ( $ this -> multiSRC ) ) { return '' ; } $ this -> objFiles = FilesModel :: findMultipleByUuids ( $ this -> multiSRC ) ; if ( $ this -> objFiles === null ) { return '' ; } return parent :: generate ( ) ; }
3409	public function setLockPath ( string $ path ) : Application { if ( ! is_dir ( $ path ) ) { ( new Filesystem ( ) ) -> mkdir ( $ path ) ; } if ( ! $ realpath = realpath ( $ path ) ) { throw new \ InvalidArgumentException ( "The directory (" . $ path . ") is unavailable" ) ; } $ this -> lockPath = $ realpath ; return $ this ; }
10045	private function createFromType ( Model $ model , Column $ column , $ item ) { $ result = null ; switch ( $ column -> getType ( ) ) { case Type :: TEXT : case Type :: TARRAY : case Type :: SIMPLE_ARRAY : case Type :: JSON_ARRAY : case Type :: OBJECT : case Type :: BLOB : $ result = new TextAreaFormItem ( ) ; break ; case Type :: INTEGER : case Type :: SMALLINT : case Type :: BIGINT : $ result = new IntegerFormItem ( ) ; break ; case Type :: DECIMAL : case Type :: FLOAT : $ result = new NumberFormItem ( ) ; break ; case Type :: BOOLEAN : $ result = new CheckboxFormItem ( ) ; break ; case Type :: DATE : $ result = new DateFormItem ( ) ; break ; case Type :: DATETIME : case Type :: DATETIMETZ : $ result = new DateTimeFormItem ( ) ; break ; case Type :: TIME : $ result = new TimeFormItem ( ) ; break ; case Type :: STRING : case Type :: GUID : default : $ result = new TextFormItem ( ) ; break ; } $ columnName = $ column -> getName ( ) ; $ result -> setName ( $ columnName ) ; $ result -> setLabel ( Lang :: trans ( $ this -> aujaConfigurator -> getColumnDisplayName ( $ model , $ columnName ) ) ) ; if ( $ item != null && isset ( $ item -> $ columnName ) ) { $ result -> setValue ( $ item -> $ columnName ) ; } return $ result ; }
12266	public function renderCmsBlocks ( array $ blocks , $ username , array $ options = array ( ) ) { $ tmp = array ( ) ; foreach ( $ blocks as $ block ) { $ tmp [ ] = $ this -> renderCmsBlock ( $ block , $ username , $ options ) ; } return implode ( "\n" , $ tmp ) ; }
11740	public function exportAction ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ chillSecurityHelper = $ this -> get ( 'chill.main.security.authorization.helper' ) ; $ user = $ this -> get ( 'security.context' ) -> getToken ( ) -> getUser ( ) ; $ reachableCenters = $ chillSecurityHelper -> getReachableCenters ( $ user , new Role ( 'CHILL_PERSON_SEE' ) ) ; $ personRepository = $ em -> getRepository ( 'ChillPersonBundle:Person' ) ; $ qb = $ personRepository -> createQueryBuilder ( 'p' ) ; $ qb -> where ( $ qb -> expr ( ) -> in ( 'p.center' , ':centers' ) ) -> setParameter ( 'centers' , $ reachableCenters ) ; $ persons = $ qb -> getQuery ( ) -> getResult ( ) ; $ response = $ this -> render ( 'ChillPersonBundle:Person:export.csv.twig' , array ( 'persons' => $ persons , 'cf_group' => $ this -> getCFGroup ( ) ) ) ; $ response -> headers -> set ( 'Content-Type' , 'text/csv; charset=utf-8' ) ; $ response -> headers -> set ( 'Content-Disposition' , 'attachment; filename="export_person.csv"' ) ; return $ response ; }
11456	public function batchDeviceSummary ( $ timestamp , $ pageIndex ) { $ params = [ 'date' => $ timestamp , 'page_index' => $ pageIndex , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_LIST , $ params ] ) ; }
10826	public static function table ( array $ rows , array $ headers = [ ] ) { $ table = new Table ( ) ; $ table -> setRows ( $ rows ) ; if ( count ( $ headers ) > 0 ) { $ table -> setHeaders ( $ headers ) ; } $ output = $ table -> render ( ) ; self :: writeln ( $ output ) ; }
6605	public function validateRequestTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'request token' ) ; } return true ; }
2699	private function upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) { foreach ( $ oldConfigPaths as $ key => $ value ) { $ oldValue = $ this -> scopeConfig -> getValue ( $ value ) ; if ( $ oldValue != null ) { $ this -> configWriter -> save ( $ newConfigPaths [ $ key ] , $ oldValue ) ; } } }
8799	public function make ( $ value , array $ options = [ ] ) { $ hash = password_hash ( $ value , PASSWORD_ARGON2I , [ 'memory_cost' => $ this -> memory ( $ options ) , 'time_cost' => $ this -> time ( $ options ) , 'threads' => $ this -> threads ( $ options ) , ] ) ; if ( $ hash === false ) { throw new RuntimeException ( 'Argon2 hashing not supported.' ) ; } return $ hash ; }
12633	public function close ( $ tradeNo ) { $ params = [ 'out_trade_no' => $ tradeNo , ] ; return $ this -> request ( $ this -> wrapApi ( self :: API_CLOSE ) , $ params ) ; }
7732	public function denormalize ( $ data , $ class , $ format = null , array $ context = array ( ) ) { $ value = $ data ; if ( is_array ( $ data ) ) { if ( ! isset ( $ data [ '@value' ] ) || ! isset ( $ data [ '@type' ] ) ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a valid JSON-LD typed value: " . var_export ( $ data , true ) ) ; } if ( self :: XSD_DATETIME_IRI !== $ data [ '@type' ] ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a XSD dateTime value: " . var_export ( $ data , true ) ) ; } $ value = $ data [ '@value' ] ; } elseif ( ! is_string ( $ data ) ) { throw new RuntimeException ( "Cannot denormalize the data into a DateTime object: " . var_export ( $ data , true ) ) ; } try { $ date = new \ DateTime ( $ value ) ; return $ date ; } catch ( Exception $ e ) { throw new RuntimeException ( "Cannot denormalize the data as the value is invalid: " . var_export ( $ data , true ) , 0 , $ e ) ; } }
703	public function parse ( $ rawBody , $ contentType ) { try { $ parameters = Json :: decode ( $ rawBody , $ this -> asArray ) ; return $ parameters === null ? [ ] : $ parameters ; } catch ( InvalidArgumentException $ e ) { if ( $ this -> throwException ) { throw new BadRequestHttpException ( 'Invalid JSON data in request body: ' . $ e -> getMessage ( ) ) ; } return [ ] ; } }
7906	protected function renderMenu ( $ items , $ parentItem ) { $ options = ArrayHelper :: getValue ( $ parentItem , 'options' ) ; $ label = $ this -> getLabel ( $ parentItem ) ; $ items = Html :: tag ( 'div' , $ this -> renderItems ( $ items ) , [ 'class' => 'menu' ] ) ; Html :: addCssClass ( $ options , 'ui' ) ; Html :: addCssClass ( $ options , 'header' ) ; return Html :: tag ( 'div' , Html :: tag ( 'div' , $ label , $ options ) . $ items , [ 'class' => 'item' ] ) ; }
5205	public function isActiveMatch ( $ string , $ output = "active" ) { if ( strpos ( $ this -> url -> current ( ) , $ string ) !== false ) { return $ output ; } return null ; }
7473	public function editAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
984	public function usageCharge ( StoreUsageCharge $ request ) { $ validated = $ request -> validated ( ) ; $ uc = new UsageCharge ( ShopifyApp :: shop ( ) , $ validated ) ; $ uc -> activate ( ) ; $ uc -> save ( ) ; return isset ( $ validated [ 'redirect' ] ) ? Redirect :: to ( $ validated [ 'redirect' ] ) -> with ( 'success' , 'usage_charge' ) : Redirect :: back ( ) -> with ( 'success' , 'usage_charge' ) ; }
8951	public function getCapabilities ( ) { $ base = 'capabilities' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'GET' , array ( ) ) ; return simplexml_load_string ( $ response -> body ) ; }
7445	public function editAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } $ form = $ this -> createForm ( GroupType :: class , $ group ) ; return array ( 'group' => $ group , 'form' => $ form -> createView ( ) , ) ; }
9864	private function writeDataValidations ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ dataValidationCollection = $ pSheet -> getDataValidationCollection ( ) ; if ( ! empty ( $ dataValidationCollection ) ) { $ dataValidationCollection = Coordinate :: mergeRangesInCollection ( $ dataValidationCollection ) ; $ objWriter -> startElement ( 'dataValidations' ) ; $ objWriter -> writeAttribute ( 'count' , count ( $ dataValidationCollection ) ) ; foreach ( $ dataValidationCollection as $ coordinate => $ dv ) { $ objWriter -> startElement ( 'dataValidation' ) ; if ( $ dv -> getType ( ) != '' ) { $ objWriter -> writeAttribute ( 'type' , $ dv -> getType ( ) ) ; } if ( $ dv -> getErrorStyle ( ) != '' ) { $ objWriter -> writeAttribute ( 'errorStyle' , $ dv -> getErrorStyle ( ) ) ; } if ( $ dv -> getOperator ( ) != '' ) { $ objWriter -> writeAttribute ( 'operator' , $ dv -> getOperator ( ) ) ; } $ objWriter -> writeAttribute ( 'allowBlank' , ( $ dv -> getAllowBlank ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showDropDown' , ( ! $ dv -> getShowDropDown ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showInputMessage' , ( $ dv -> getShowInputMessage ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showErrorMessage' , ( $ dv -> getShowErrorMessage ( ) ? '1' : '0' ) ) ; if ( $ dv -> getErrorTitle ( ) !== '' ) { $ objWriter -> writeAttribute ( 'errorTitle' , $ dv -> getErrorTitle ( ) ) ; } if ( $ dv -> getError ( ) !== '' ) { $ objWriter -> writeAttribute ( 'error' , $ dv -> getError ( ) ) ; } if ( $ dv -> getPromptTitle ( ) !== '' ) { $ objWriter -> writeAttribute ( 'promptTitle' , $ dv -> getPromptTitle ( ) ) ; } if ( $ dv -> getPrompt ( ) !== '' ) { $ objWriter -> writeAttribute ( 'prompt' , $ dv -> getPrompt ( ) ) ; } $ objWriter -> writeAttribute ( 'sqref' , $ coordinate ) ; if ( $ dv -> getFormula1 ( ) !== '' ) { $ objWriter -> writeElement ( 'formula1' , $ dv -> getFormula1 ( ) ) ; } if ( $ dv -> getFormula2 ( ) !== '' ) { $ objWriter -> writeElement ( 'formula2' , $ dv -> getFormula2 ( ) ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
8504	public function confirmTransportRequest ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ConfirmTransportRequest' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ConfirmTransportRequestResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
9630	public function verifyAndMoveUploadedFile ( $ originSize , $ tmpDestination , $ publicDestination ) { $ remoteTempSize = $ this -> getSize ( $ tmpDestination ) ; $ this -> logger -> debug ( 'Temp size: ' . $ remoteTempSize ) ; $ this -> logger -> debug ( 'Origin size: ' . $ originSize ) ; if ( $ remoteTempSize <= 0 ) { throw new VerifySizeException ( 'Uploaded file has size ' . $ remoteTempSize ) ; } if ( $ remoteTempSize !== $ originSize ) { throw new VerifySizeException ( sprintf ( 'Uploaded file has wrong size. Expected %s, got %s.' , $ originSize , $ remoteTempSize ) ) ; } $ this -> logger -> info ( 'OK: Uploaded temp file has right size.' ) ; if ( ! $ this -> move ( $ tmpDestination , $ publicDestination ) ) { throw new FtpException ( 'Error renaming uploaded file from temp to public.' ) ; } $ remotePublicSize = $ this -> getSize ( $ publicDestination ) ; $ this -> logger -> debug ( 'Renamed size: ' . $ remotePublicSize ) ; if ( $ remotePublicSize <= 0 ) { throw new VerifySizeException ( 'Renamed file has size ' . $ remotePublicSize ) ; } if ( $ remotePublicSize !== $ originSize ) { throw new VerifySizeException ( sprintf ( 'Renamed file has wrong size. Expected %s, got %s.' , $ originSize , $ remotePublicSize ) ) ; } $ this -> logger -> info ( 'OK: Renamed file has right size.' ) ; return true ; }
7811	private static function filterArray ( $ needle , $ heystack , $ always = array ( ) ) { foreach ( $ heystack as $ k => $ v ) { if ( ! in_array ( $ v , $ needle ) && ! in_array ( $ v , $ always ) ) unset ( $ heystack [ $ k ] ) ; } return $ heystack ; }
11506	public function offsetSet ( $ slot , $ connection ) { if ( ! static :: isValid ( $ slot ) ) { throw new \ OutOfBoundsException ( "Invalid slot $slot for `$connection`" ) ; } $ this -> slots [ ( int ) $ slot ] = ( string ) $ connection ; }
2953	protected function extractData ( $ text , $ template ) { preg_match ( '/' . $ template . '/s' , $ text , $ matches ) ; $ keys = array_filter ( array_keys ( $ matches ) , 'is_string' ) ; $ matches = array_intersect_key ( $ matches , array_flip ( $ keys ) ) ; if ( ! empty ( $ matches ) ) { return $ this -> cleanExtractedData ( $ matches ) ; } return false ; }
9104	protected function parse_user ( ) { if ( ! empty ( $ this -> args [ 'user' ] ) ) { $ this -> args [ 'user__in' ] = array ( $ this -> args [ 'user' ] ) ; } return $ this -> parse_in_or_not_in_query ( 'user' , $ this -> args [ 'user__in' ] , $ this -> args [ 'user__not_in' ] ) ; }
5095	protected function getDefaultParts ( ) { if ( ! isset ( CmdUpsert :: $ DEFAULT ) ) { CmdUpsert :: $ DEFAULT = parent :: getDefaultParts ( ) ; CmdUpsert :: $ PART_SET = count ( CmdUpsert :: $ DEFAULT ) ; CmdUpsert :: $ DEFAULT [ CmdUpsert :: $ PART_SET ] = false ; } return CmdUpsert :: $ DEFAULT ; }
10575	public static function apply ( $ text , $ foreground = '' , $ background = '' ) { try { $ style = new OutputFormatterStyle ( ) ; if ( $ foreground != '' ) { $ style -> setForeground ( $ foreground ) ; } if ( $ background != '' ) { $ style -> setBackground ( $ background ) ; } return $ style -> apply ( $ text ) ; } catch ( \ Exception $ e ) { return $ text ; } }
11146	public function move ( Neuron_GameServer_Map_MapObject $ object , Neuron_GameServer_Map_Location $ location , Neuron_GameServer_Map_Date $ start , Neuron_GameServer_Map_Date $ end ) { throw new Neuron_Exceptions_NotImplemented ( "The move method is not implemented in this map." ) ; }
10744	public function getArray ( $ keys , array $ default = [ ] ) : array { $ result = $ this -> get ( $ keys , $ default ) ; if ( ! is_array ( $ result ) ) { $ result = $ default ; } return $ result ; }
12082	public function getMedia ( $ objectType = 'media' , $ objectURI = NULL , $ objectId = NULL ) { return $ this -> getAllMedia ( $ objectType , $ objectURI , $ objectId ) ; }
11279	public static function applyDataToView ( $ view , $ data ) { if ( ! empty ( $ data ) ) { foreach ( $ data as $ name => $ value ) { if ( is_string ( $ value ) ) { $ view = str_replace ( '{' . $ name . '}' , $ value , $ view ) ; } } } return $ view ; }
5418	public function writeCookiesToJar ( $ jar , $ url ) { foreach ( $ this -> cookies as $ cookie ) { $ jar -> setCookie ( $ cookie -> getName ( ) , $ cookie -> getValue ( ) , $ url -> getHost ( ) , $ cookie -> getPath ( ) , $ cookie -> getExpiry ( ) ) ; } }
3699	private function parseListing ( ) { $ listing = $ this -> definition -> getListingConfig ( ) ; if ( null === $ listing -> getRootLabel ( ) ) { $ listing -> setRootLabel ( $ this -> metaModel -> get ( 'name' ) ) ; } if ( null === $ listing -> getRootIcon ( ) ) { $ listing -> setRootIcon ( $ this -> iconBuilder -> getBackendIcon ( $ this -> inputScreen [ 'meta' ] [ 'backendicon' ] ) ) ; } $ this -> parseListSorting ( $ listing ) ; $ this -> parseListLabel ( $ listing ) ; $ listing -> setShowColumns ( ( bool ) $ this -> inputScreen [ 'meta' ] [ 'showColumns' ] ) ; }
4780	public function clearWidgetCache ( ) { $ widgets = $ this -> getWidgets ( false ) ; $ userId = $ this -> token -> getToken ( ) -> getUser ( ) -> getId ( ) ; foreach ( $ widgets as $ widget ) { $ this -> cache -> deleteItem ( $ widget -> getId ( ) . $ userId ) ; } }
4572	public function setIdentityUuid ( ? string $ identityUuid ) { if ( null !== $ identityUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ identityUuid ) ) { throw new InvalidArgumentException ( 'Identity uuid is not valid.' ) ; } } $ this -> identityUuid = $ identityUuid ; return $ this ; }
5921	public function getProperty ( $ systemName ) { foreach ( $ this -> propertySets as $ propertySet ) { foreach ( $ propertySet -> getProperties ( ) as $ property ) { if ( $ property -> getPropertyType ( ) -> getSystemName ( ) == $ systemName ) { return $ property ; } } } throw new PropertyNotFoundException ( 'No Property with the system name "' . $ systemName . '" exists.' ) ; }
5727	public function recordIsDeletedFromStage ( ) { if ( $ this -> owner -> hasMethod ( 'getIsDeletedFromStage' ) ) { return $ this -> owner -> IsDeletedFromStage ; } if ( ! $ this -> owner -> record -> checkVersioned ( ) ) { return false ; } if ( ! $ this -> owner -> record -> isInDB ( ) ) { return true ; } $ class = $ this -> owner -> record -> class ; $ stageVersion = Versioned :: get_versionnumber_by_stage ( $ class , 'Stage' , $ this -> owner -> record -> ID ) ; return ! ( $ stageVersion ) ; }
126	protected function createRemoveRule ( PackageInterface $ package , $ reason , $ job ) { return new GenericRule ( array ( - $ package -> id ) , $ reason , $ job [ 'packageName' ] , $ job ) ; }
3066	public function process ( QtiRunnerServiceContext $ context , array $ data = [ ] ) { return $ this -> getServiceManager ( ) -> get ( SynchronisationService :: SERVICE_ID ) -> process ( $ data , $ context ) ; }
9174	private function hierarchyToFlatArray ( $ items ) { $ flatArray = [ ] ; foreach ( $ items as $ item ) { $ flatArray [ ] = $ item -> getId ( ) ; if ( $ items -> getChildren ( ) -> count ( ) > 0 ) { $ flatArray = array_merge ( $ flatArray , $ this -> hierarchyToFlatArray ( $ items -> getChildren ( ) ) ) ; } } return $ flatArray ; }
10224	private function buildComplexIndexMenu ( $ modelName , $ modelId , ModelConfig $ config = null ) { $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; $ relations = $ this -> aujaConfigurator -> getRelationsForModel ( $ model ) ; $ associationRelations = array ( ) ; foreach ( $ relations as $ relation ) { if ( $ relation -> getType ( ) == Relation :: HAS_MANY || $ relation -> getType ( ) == Relation :: HAS_AND_BELONGS_TO ) { $ associationRelations [ ] = $ relation ; } } switch ( count ( $ associationRelations ) ) { case 0 : $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; break ; case 1 : $ menu = $ this -> singleAssociationMenuFor ( $ modelName , $ modelId , $ associationRelations [ 0 ] , $ config ) ; break ; default : $ menu = $ this -> multipleAssociationsMenuFor ( $ modelName , $ modelId , $ associationRelations , $ config ) ; break ; } return $ menu ; }
3737	protected function createNewItem ( $ item ) { $ data = [ 'tstamp' => $ item -> get ( 'tstamp' ) ] ; $ isNewItem = false ; if ( $ this -> hasVariants ( ) ) { if ( $ item -> get ( 'vargroup' ) === null ) { $ item -> set ( 'varbase' , '1' ) ; $ item -> set ( 'vargroup' , '0' ) ; $ isNewItem = true ; } $ data [ 'varbase' ] = $ item -> get ( 'varbase' ) ; $ data [ 'vargroup' ] = $ item -> get ( 'vargroup' ) ; } $ connection = $ this -> getConnection ( ) ; $ builder = $ connection -> createQueryBuilder ( ) ; $ parameters = [ ] ; foreach ( array_keys ( $ data ) as $ key ) { $ parameters [ $ key ] = ':' . $ key ; } $ builder -> insert ( $ this -> getTableName ( ) ) -> values ( $ parameters ) -> setParameters ( $ data ) -> execute ( ) ; $ item -> set ( 'id' , $ connection -> lastInsertId ( ) ) ; if ( $ isNewItem ) { $ this -> saveSimpleColumn ( 'vargroup' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'id' ) ) ; } }
9888	static function getPermission ( $ code ) { switch ( $ code ) { case 1 : return self :: $ NONE ; case "none" : return self :: $ NONE ; case 2 : return self :: $ SOI ; case "soi" : return self :: $ SOI ; case 3 : return self :: $ COI ; case "coi" : return self :: $ COI ; case 4 : return self :: $ DOI ; case "doi" : return self :: $ DOI ; case 5 : return self :: $ DOI_PLUS ; case "doi+" : return self :: $ DOI_PLUS ; case 6 : return self :: $ OTHER ; case "other" : return self :: $ OTHER ; default : return self :: $ OTHER ; } }
4730	public static function transcode ( $ source , $ fromEncoding , $ toEncoding ) { if ( \ is_string ( $ source ) ) { switch ( ICONV_IMPL ) { case 'glibc' : return @ iconv ( $ fromEncoding , $ toEncoding . '//TRANSLIT,IGNORE' , $ source ) ; case 'libiconv' : default : return iconv ( $ fromEncoding , $ toEncoding . '//IGNORE//TRANSLIT' , $ source ) ; } } }
361	public function renderErrors ( ) { if ( $ this -> filterModel instanceof Model && $ this -> filterModel -> hasErrors ( ) ) { return Html :: errorSummary ( $ this -> filterModel , $ this -> filterErrorSummaryOptions ) ; } return '' ; }
9813	protected function deleteRaw ( string $ path , $ body = null , array $ headers = [ ] ) { $ response = $ this -> client -> delete ( $ path , $ headers , $ body ) ; return ResponseMediator :: getContent ( $ response ) ; }
1983	public static function hasMessages ( $ strScope = TL_MODE ) { return static :: hasError ( $ strScope ) || static :: hasConfirmation ( $ strScope ) || static :: hasNew ( $ strScope ) || static :: hasInfo ( $ strScope ) || static :: hasRaw ( $ strScope ) ; }
10404	public function get ( $ key ) { $ pair = $ this -> repository -> find ( $ key ) ; return $ pair ? $ pair -> getValue ( ) : null ; }
3651	protected function callParseTemplateHook ( ) { if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ objCallback -> $ strMethod ( $ this ) ; } } }
11345	public function render ( ) { $ html = $ this -> formatter -> renderFormBegin ( $ this -> formTags ) ; foreach ( $ this -> fields as $ field ) { $ html .= $ this -> formatter -> renderField ( $ field ) ; } $ html .= $ this -> renderSubmit ( ) ; $ html .= $ this -> renderEnd ( ) ; return $ html ; }
10478	protected function resolveItemAction ( AbstractDiffItem $ item ) { if ( $ item instanceof CreateDiffItem ) { $ action = ActionTypes :: CREATE ; return $ action ; } elseif ( $ item instanceof DeleteDiffItem ) { $ action = ActionTypes :: DELETE ; return $ action ; } elseif ( $ item instanceof UpdateDiffItem ) { $ action = ActionTypes :: UPDATE ; return $ action ; } else { throw new \ InvalidArgumentException ( 'Unsupported diff item type. Got: ' . get_class ( $ item ) ) ; } }
8239	public function setAuthenticated ( $ v ) { if ( ! $ v ) { $ this -> authenticator = null ; } $ this -> authenticated = $ v ; return $ this ; }
5184	private function lookUp ( array $ articleConstant ) : array { $ copyListAttributes = $ this -> listAttributes ; return array_map ( function ( $ singleConst ) use ( $ copyListAttributes ) { $ res = $ copyListAttributes [ $ singleConst ] ; return array_map ( function ( $ str ) use ( $ singleConst ) { return $ singleConst . $ str ; } , $ res ) ; } , $ articleConstant ) ; }
701	protected function cleanupVendorDir ( $ dir ) { if ( is_link ( $ link = "$dir/vendor/yiisoft/yii2" ) ) { $ this -> stdout ( "Removing symlink $link.\n" ) ; FileHelper :: unlink ( $ link ) ; } $ extensions = $ this -> findDirs ( "$dir/vendor/yiisoft" ) ; foreach ( $ extensions as $ ext ) { if ( is_link ( $ link = "$dir/vendor/yiisoft/yii2-$ext" ) ) { $ this -> stdout ( "Removing symlink $link.\n" ) ; FileHelper :: unlink ( $ link ) ; } } }
6717	protected function setParameters ( $ newParameters ) { if ( is_scalar ( $ newParameters ) ) { if ( ! is_string ( $ newParameters ) ) { throw new \ Exception ( 'newParameters can not be scalar' ) ; } $ newParameters = $ this -> stringToArray ( $ newParameters ) ; } foreach ( $ newParameters as $ field => $ value ) { $ this -> setParameter ( $ field , $ value ) ; } return $ this ; }
11641	public function getColumns ( ) { if ( is_null ( $ this -> _columns ) ) { $ this -> columns = $ this -> dataProvider -> model -> attributeNames ( ) ; } return $ this -> _columns ; }
6304	protected function process ( array $ nav ) { foreach ( $ nav as $ key => $ value ) { if ( ! isset ( $ value [ 'url' ] ) ) { $ nav [ $ key ] [ 'url' ] = $ this -> url -> to ( $ value [ 'slug' ] ) ; } unset ( $ nav [ $ key ] [ 'slug' ] ) ; } return $ nav ; }
5351	public function setDatabasePassword ( $ domainName , $ database , $ password ) { return $ this -> call ( self :: SERVICE , 'setDatabasePassword' , [ $ domainName , $ database , $ password ] ) ; }
675	public function getPage ( $ recalculate = false ) { if ( $ this -> _page === null || $ recalculate ) { $ page = ( int ) $ this -> getQueryParam ( $ this -> pageParam , 1 ) - 1 ; $ this -> setPage ( $ page , true ) ; } return $ this -> _page ; }
2027	public static function findPublishedRegularWithoutGuestsByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ") AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( empty ( $ arrOptions [ 'includeRoot' ] ) ) { $ arrColumns [ ] = "$t.type!='root'" ; } if ( FE_USER_LOGGED_IN ) { $ arrColumns [ ] = "$t.guests=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.id" , $ arrIds ) ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
10593	public function toArray ( ) { return [ 'level' => $ this -> level , 'datetime' => $ this -> datetime -> format ( 'Y-m-d H:i:s' ) , 'header' => $ this -> header , 'stack' => $ this -> stack , ] ; }
10913	public function setVariable ( string $ name , $ value , bool $ as_instance = true ) { $ this -> variables [ $ name ] = $ value ; if ( is_object ( $ value ) ) $ this -> instances [ get_class ( $ value ) ] = $ value ; return $ this ; }
6970	protected function calculateShipmentLine ( Model \ DocumentLineInterface $ line , Amount $ final ) : Amount { if ( $ line -> getType ( ) !== Model \ DocumentLineTypes :: TYPE_SHIPMENT ) { throw new LogicException ( sprintf ( "Expected document line with type '%s'." , Model \ DocumentLineTypes :: TYPE_SHIPMENT ) ) ; } $ sale = $ line -> getDocument ( ) -> getSale ( ) ; $ result = $ this -> calculator -> calculateSaleShipment ( $ sale , $ final ) ; if ( null === $ result ) { throw new LogicException ( "Unexpected document shipment line." ) ; } $ this -> syncLineWithResult ( $ line , $ result ) ; return $ result ; }
10347	public function current ( ) { $ minute = current ( $ this -> minutes ) ; $ hour = current ( $ this -> hours ) ; $ monthAndDay = current ( $ this -> monthAndDays ) ; $ currentElement = strtotime ( sprintf ( '%d-%s %02d:%02d:00' , $ this -> year + $ this -> yearOffset , $ monthAndDay , $ hour , $ minute ) ) ; if ( $ currentElement < $ this -> getCurrentTime ( ) ) { $ currentElement = $ this -> getNextFutureTimestamp ( ) ; } return $ currentElement ; }
10450	public function delete ( $ key ) { try { $ this -> get ( $ key ) ; } catch ( KeyNotFoundException $ e ) { return false ; } return $ this -> getClient ( ) -> delete ( $ key ) ; }
5559	protected function findFormInFrame ( $ page , $ index , $ method , $ attribute ) { $ form = $ this -> frames [ $ index ] -> $ method ( $ attribute ) ; if ( isset ( $ form ) ) { $ form -> setDefaultTarget ( $ this -> getPublicNameFromIndex ( $ index ) ) ; } return $ form ; }
9892	protected function createError ( ) { $ error = $ this -> getForm ( ) -> getValidator ( ) -> getMessages ( $ this -> getElement ( ) -> getName ( ) ) ; if ( $ error ) { $ this -> error = $ this -> builder -> make ( 'error' , [ ] , $ error ) ; } }
7872	public function send ( array $ destinations , string $ message ) : ? array { $ this -> checkConfig ( ) ; if ( ! empty ( $ destinations ) ) { $ destination = $ destinations [ 0 ] ; } $ query = http_build_query ( [ 'userkey' => $ this -> userkey , 'passkey' => $ this -> passkey , 'nohp' => $ destination , 'pesan' => $ message , ] ) ; $ response = Request :: get ( $ this -> baseUrl . '/smsapi.php?' . $ query ) ; $ xml = simplexml_load_string ( $ response -> body ) ; $ body = json_decode ( json_encode ( $ xml ) , true ) ; if ( ! empty ( $ body [ 'message' ] ) and $ body [ 'message' ] [ 'status' ] != 0 ) { Log :: error ( sprintf ( 'Zenziva: %s.' , $ body [ 'message' ] [ 'text' ] ) ) ; } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ body [ 'message' ] [ 'text' ] ?? '' , 'data' => $ body , ] ; }
765	private function extractUsedParams ( SqlToken $ statement , $ params ) { preg_match_all ( '/(?P<placeholder>[:][a-zA-Z0-9_]+)/' , $ statement -> getSql ( ) , $ matches , PREG_SET_ORDER ) ; $ result = [ ] ; foreach ( $ matches as $ match ) { $ phName = ltrim ( $ match [ 'placeholder' ] , ':' ) ; if ( isset ( $ params [ $ phName ] ) ) { $ result [ $ phName ] = $ params [ $ phName ] ; } elseif ( isset ( $ params [ ':' . $ phName ] ) ) { $ result [ ':' . $ phName ] = $ params [ ':' . $ phName ] ; } } return $ result ; }
5038	public function get ( $ key , $ fallback = true ) { foreach ( $ this -> getImages ( ) as $ image ) { if ( $ key == $ image -> getKey ( ) ) { return $ image ; } } return ! $ fallback || self :: ORIGINAL == $ key ? null : $ this -> get ( self :: ORIGINAL ) ; }
10889	public function parse ( ) { list ( $ opt_str , $ long_opts , $ mapping ) = $ this -> getOptString ( ) ; $ opts = \ getopt ( $ opt_str , $ long_opts ) ; $ options = $ this -> mapOptions ( $ opts , $ mapping ) ; return new Dictionary ( $ options ) ; }
9395	public function buildCommand ( ) { if ( $ this -> escape !== false ) { $ this -> options = $ this -> escape ( $ this -> options ) ; } if ( $ this -> builder !== null ) { $ this -> command = $ this -> builder -> build ( $ this -> options ) ; } return $ this ; }
11011	public function getHeaderValue ( ) : ? string { $ headerValue = [ ] ; foreach ( $ this -> tags as $ name => $ tagValue ) { if ( is_array ( $ tagValue ) && ! empty ( $ tagValue ) ) { $ headerValue [ ] = $ name . ' ' . implode ( ' ' , $ tagValue ) . ';' ; } elseif ( is_string ( $ tagValue ) && ! empty ( $ tagValue ) ) { $ headerValue [ ] = $ name . ' ' . $ tagValue . ';' ; } elseif ( is_bool ( $ tagValue ) && $ tagValue ) { $ headerValue [ ] = $ name . ';' ; } } return $ headerValue ? implode ( ' ' , $ headerValue ) : null ; }
3352	public function getUserAgentHeader ( ) { $ userAgentName = $ this -> getUserAgentName ( ) ; if ( $ userAgentName ) { return $ userAgentName ; } $ userAgent = sprintf ( '%s/%s/%s (PHP/%s.%s.%s' , $ this -> getLibraryName ( ) , $ this -> getVersion ( ) , $ this -> getPublicKey ( ) , PHP_MAJOR_VERSION , PHP_MINOR_VERSION , PHP_RELEASE_VERSION ) ; $ framework = $ this -> getFramework ( ) ; if ( $ framework ) { $ userAgent .= '; ' . $ framework ; } $ extension = $ this -> getExtension ( ) ; if ( $ extension ) { $ userAgent .= '; ' . $ extension ; } $ userAgent .= ')' ; return $ userAgent ; }
3548	public function create ( $ request ) { $ model = $ this -> repository -> create ( $ request -> all ( ) ) ; $ model -> { $ this -> getShortRelationName ( ) } ( ) -> sync ( $ request -> get ( $ this -> getRelationName ( ) , [ ] ) ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ model ) ) ; return $ model ; }
4775	private function loadUserConfig ( ) { if ( ! $ this -> widgetConfig ) { $ this -> widgetConfig = $ this -> entityManager -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> tokenStorage -> getToken ( ) -> getUser ( ) , ] ) ; if ( null !== $ this -> widgetConfig ) { $ this -> widgetConfig = $ this -> widgetConfig -> getConfig ( ) ; } } }
4722	public function setText ( $ text ) { $ this -> text = $ text ; if ( ! $ this -> text instanceof Text ) { $ this -> text = new Text ( $ this -> text ) ; } return $ this ; }
5602	public function paintFail ( $ message ) { if ( ! $ this -> fail && ! $ this -> error ) { $ this -> fail = true ; $ this -> message = self :: escapeVal ( $ message ) ; $ this -> listener -> write ( '{status:"fail",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
6013	public function listProtocols ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/protocols' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Protocol ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
9925	private function handleCollections ( Parameters $ params , array $ permitted = array ( ) ) { if ( empty ( $ permitted ) ) { return ; } $ keys = $ params -> keys ( ) ; $ intKeys = $ keys -> select ( function ( $ value ) { return is_int ( $ value ) ; } ) ; if ( $ keys -> count ( ) === $ intKeys -> count ( ) ) { foreach ( $ keys as $ key ) { $ value = $ params [ $ key ] ; if ( $ value instanceof Parameters ) { $ this -> filter ( $ value , $ permitted ) ; } } } }
4653	public function getJobsToRemove ( $ projectPath , $ keep = 1 ) { $ currentJobs = $ this -> strategy -> getJobs ( $ projectPath ) ; $ existingJobs = $ this -> getJobs ( $ projectPath ) ; $ uniqList = array ( ) ; $ removes = array ( ) ; $ ordered = array ( ) ; foreach ( $ currentJobs as $ job ) { $ uniqList [ ] = $ job -> getUniq ( ) ; } foreach ( $ existingJobs as $ job ) { if ( ! in_array ( $ job -> getUniq ( ) , $ uniqList ) ) { $ removes [ ] = $ job ; } else { $ ordered [ $ job -> getUniq ( ) ] [ $ job -> getCreated ( ) -> format ( 'U' ) ] = $ job ; } } foreach ( $ ordered as $ jobs ) { ksort ( $ jobs ) ; $ keeped = count ( $ jobs ) ; while ( $ keeped > $ keep ) { $ removes [ ] = array_shift ( $ jobs ) ; $ keeped -- ; } } return $ removes ; }
9039	public function getByHash ( $ columns , string $ hash ) : ? IEntity { if ( $ this -> manager -> hasher === null ) { throw new MissingServiceException ( 'Hasher is missing' ) ; } return $ this -> toEntity ( $ this -> manager -> hasher -> hashSQL ( $ this -> builder ( ) , $ columns , $ hash ) ) ; }
5897	public function listVideoTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/videos' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new VideoTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
6153	public function setPropertyType ( $ propertyType ) { if ( $ propertyType instanceof PropertyType ) { $ this -> propertyType = $ propertyType ; } elseif ( is_array ( $ propertyType ) ) { $ this -> propertyType = new PropertyType ( $ propertyType ) ; } else { $ this -> propertyType = null ; trigger_error ( 'Argument must be an object of class PropertyType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
3636	public function rpcMiddles ( Request $ request ) : array { $ beanName = 'serviceDispatcher' ; if ( ! \ Swoft :: hasBean ( $ beanName ) ) { return [ ] ; } $ dispatcher = \ bean ( $ beanName ) ; $ middleType = ( int ) $ request -> query ( 'type' ) ; if ( $ middleType === 1 ) { return $ dispatcher -> getMiddlewares ( ) ; } return $ dispatcher -> requestMiddleware ( ) ; }
8551	public function setPerformanceBondRefundEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PerformanceBondRefundEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8071	public function retrieveByCredentials ( array $ credentials ) { $ username = $ credentials [ 'username' ] ; $ result = $ this -> ldap -> find ( $ username ) ; if ( ! is_null ( $ result ) ) { $ user = new $ this -> model ; $ user -> build ( $ result ) ; return $ user ; } return null ; }
6876	private function findRevenues ( $ type , \ DateTime $ from , \ DateTime $ to = null , $ detailed = false ) { if ( $ type === OrderStat :: TYPE_DAY ) { if ( null === $ to ) { $ from = ( clone $ from ) -> modify ( 'first day of this month' ) ; $ to = ( clone $ from ) -> modify ( 'last day of this month' ) ; } $ interval = new \ DateInterval ( 'P1D' ) ; $ format = 'Y-m-d' ; } elseif ( $ type === OrderStat :: TYPE_MONTH ) { if ( null === $ to ) { $ from = ( clone $ from ) -> modify ( 'first day of january ' . $ from -> format ( 'Y' ) ) ; $ to = ( clone $ from ) -> modify ( 'last day of december ' . $ from -> format ( 'Y' ) ) ; } $ interval = new \ DateInterval ( 'P1M' ) ; $ format = 'Y-m' ; } else { throw new InvalidArgumentException ( "Unexpected order stat type." ) ; } $ result = $ this -> getRevenueQuery ( ) -> setParameters ( [ 'type' => $ type , 'from' => $ from -> format ( $ format ) , 'to' => $ to -> format ( $ format ) , ] ) -> getScalarResult ( ) ; $ data = $ this -> buildRevenueData ( $ result , $ detailed ) ; $ period = new \ DatePeriod ( $ from , $ interval , $ to ) ; $ defaults = $ detailed ? [ ] : 0 ; if ( $ detailed ) { foreach ( SaleSources :: getSources ( ) as $ source ) { $ defaults [ $ source ] = 0 ; } } foreach ( $ period as $ d ) { $ index = $ d -> format ( $ format ) ; if ( ! isset ( $ data [ $ index ] ) ) { $ data [ $ index ] = $ defaults ; } ; } ksort ( $ data ) ; return $ data ; }
10835	private function compileOn ( array $ join ) { $ sql = array ( ) ; list ( $ on , $ table , $ type , $ c1 , $ op , $ c2 ) = $ join ; if ( $ type !== null ) { $ sql [ ] = $ type ; } array_push ( $ sql , "JOIN" , $ table , "ON" , $ c1 , $ op , $ c2 ) ; return join ( ' ' , $ sql ) ; }
2490	protected function processConnectionConfiguration ( ContainerBuilder $ container , array $ config ) { $ alias = $ this -> getAlias ( ) ; if ( isset ( $ config [ 'default_connection' ] ) ) { $ container -> setParameter ( "{$alias}.default_connection" , $ config [ 'default_connection' ] ) ; } elseif ( ! empty ( $ config [ 'connections' ] ) ) { reset ( $ config [ 'connections' ] ) ; $ container -> setParameter ( "{$alias}.default_connection" , key ( $ config [ 'connections' ] ) ) ; } foreach ( $ config [ 'connections' ] as $ name => $ params ) { $ this -> configureSearchServices ( $ container , $ name , $ params ) ; $ this -> configureBoostMap ( $ container , $ name , $ params ) ; $ this -> configureIndexingDepth ( $ container , $ name , $ params ) ; $ container -> setParameter ( "$alias.connection.$name" , $ params ) ; } foreach ( $ config [ 'endpoints' ] as $ name => $ params ) { $ this -> defineEndpoint ( $ container , $ name , $ params ) ; } $ searchEngineDef = $ container -> findDefinition ( self :: ENGINE_ID ) ; $ searchEngineDef -> setFactory ( [ new Reference ( 'ezpublish.solr.engine_factory' ) , 'buildEngine' ] ) ; $ boostFactorProviderDef = $ container -> findDefinition ( self :: BOOST_FACTOR_PROVIDER_ID ) ; $ boostFactorProviderDef -> setFactory ( [ new Reference ( 'ezpublish.solr.boost_factor_provider_factory' ) , 'buildService' ] ) ; }
12840	static public function getMimeType ( $ filePath , $ default = 'application/octet-stream' ) { $ mimeType = finfo_file ( finfo_open ( FILEINFO_MIME_TYPE ) , $ filePath ) ; if ( $ mimeType === false ) { $ mimeType = $ default ; } return $ mimeType ; }
7392	public function serialize ( ) : string { $ toSerialize = [ '_arrayOptions' => $ this -> _arrayOptions , '_jsonOptions' => $ this -> _jsonOptions , ] ; foreach ( $ this -> _publicNames as $ k ) { $ toSerialize [ $ k ] = $ this -> { $ k } ; } return serialize ( $ toSerialize ) ; }
1785	private function isRequestPrivate ( Request $ request ) : bool { if ( $ request -> headers -> has ( 'Authorization' ) ) { return true ; } if ( \ count ( $ request -> cookies -> all ( ) ) ) { return true ; } return false ; }
3083	public function getAssessmentItemRefByIdentifier ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , $ identifier ) { $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-item-ref-${identifier}" ; return $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , "${filename}" ) ; }
6366	public function compound ( Comparator $ secondaryComparator ) : Ordering { return Ordering :: from ( Collections :: comparatorFrom ( function ( $ object1 , $ object2 ) use ( $ secondaryComparator ) { $ res = $ this -> compare ( $ object1 , $ object2 ) ; return $ res !== 0 ? $ res : $ secondaryComparator -> compare ( $ object1 , $ object2 ) ; } ) ) ; }
4200	private function addMethods ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( ! $ abs [ 'collectMethods' ] ) { $ this -> addMethodsMin ( $ abs ) ; return ; } if ( $ this -> abstracter -> getCfg ( 'cacheMethods' ) && isset ( static :: $ methodCache [ $ abs [ 'className' ] ] ) ) { $ abs [ 'methods' ] = static :: $ methodCache [ $ abs [ 'className' ] ] ; } else { $ methodArray = array ( ) ; $ methods = $ abs [ 'reflector' ] -> getMethods ( ) ; $ interfaceMethods = array ( 'ArrayAccess' => array ( 'offsetExists' , 'offsetGet' , 'offsetSet' , 'offsetUnset' ) , 'Countable' => array ( 'count' ) , 'Iterator' => array ( 'current' , 'key' , 'next' , 'rewind' , 'void' ) , 'IteratorAggregate' => array ( 'getIterator' ) , ) ; $ interfacesHide = \ array_intersect ( $ abs [ 'implements' ] , \ array_keys ( $ interfaceMethods ) ) ; foreach ( $ methods as $ reflectionMethod ) { $ info = $ this -> methodInfo ( $ obj , $ reflectionMethod ) ; $ methodName = $ reflectionMethod -> getName ( ) ; if ( $ info [ 'visibility' ] === 'private' && $ info [ 'inheritedFrom' ] ) { continue ; } foreach ( $ interfacesHide as $ interface ) { if ( \ in_array ( $ methodName , $ interfaceMethods [ $ interface ] ) ) { $ info [ 'implements' ] = $ interface ; break ; } } $ methodArray [ $ methodName ] = $ info ; } $ abs [ 'methods' ] = $ methodArray ; $ this -> addMethodsPhpDoc ( $ abs ) ; static :: $ methodCache [ $ abs [ 'className' ] ] = $ abs [ 'methods' ] ; } if ( isset ( $ abs [ 'methods' ] [ '__toString' ] ) ) { $ abs [ 'methods' ] [ '__toString' ] [ 'returnValue' ] = $ obj -> __toString ( ) ; } return ; }
3326	public function render ( OptionCollection $ options ) { $ lines = array ( ) ; foreach ( $ options as $ option ) { $ c1 = $ this -> renderOption ( $ option ) ; $ lines [ ] = "\t" . $ c1 ; $ lines [ ] = wordwrap ( "\t\t" . $ option -> desc , $ this -> screenWidth , "\n\t\t" ) ; $ lines [ ] = '' ; } return implode ( "\n" , $ lines ) ; }
632	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> update ( $ table , $ columns , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
4027	protected function getLabelComment ( ModelInterface $ model , TranslatorInterface $ translator ) { if ( $ model -> getProperty ( 'comment' ) ) { return sprintf ( $ translator -> translate ( 'typedesc._comment_' , 'tl_metamodel_filtersetting' ) , StringUtil :: specialchars ( $ model -> getProperty ( 'comment' ) ) ) ; } return '' ; }
10727	public function getYear ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'year' ] ; } }
12798	public function getLines ( $ lazy = true , $ raw = false ) { if ( is_null ( $ this -> _lines ) ) { $ file = $ this -> filePointer ; if ( ! $ file ) { return false ; } rewind ( $ file ) ; $ this -> _lines = [ ] ; $ currentLineNumber = 0 ; while ( ( $ buffer = fgetcsv ( $ this -> filePointer , 0 , $ this -> delimeter ) ) !== false ) { $ currentLineNumber ++ ; if ( $ currentLineNumber <= $ this -> skipLines ) { continue ; } $ line = Yii :: createObject ( [ 'class' => SourceFileLine :: className ( ) , 'sourceFile' => $ this , 'lineNumber' => $ currentLineNumber - 1 , 'content' => $ buffer ] ) ; if ( $ this -> testIgnore ( $ line ) ) { continue ; } $ lineId = $ line -> id ; if ( ! isset ( $ lineId ) ) { continue ; } $ this -> _lines [ $ lineId ] = $ line ; if ( $ lazy ) { $ line -> clean ( ) ; } } } return $ this -> _lines ; }
1116	public function newNestedSetQuery ( $ excludeDeleted = true ) { $ builder = $ this -> newQuery ( $ excludeDeleted ) -> orderBy ( $ this -> getQualifiedOrderColumnName ( ) ) ; if ( $ this -> isScoped ( ) ) { foreach ( $ this -> scoped as $ scopeFld ) $ builder -> where ( $ scopeFld , '=' , $ this -> $ scopeFld ) ; } return $ builder ; }
10567	public function newAction ( ) { $ entity = new Media ( ) ; $ form = $ this -> createCreateForm ( $ entity ) ; return $ this -> render ( 'MMMediaBundle:Media:new.html.twig' , array ( 'entity' => $ entity , 'form' => $ form -> createView ( ) , ) ) ; }
10386	protected function createInitializer ( ) { $ initializer = new Initializer ( ) ; $ initializer -> addTemplate ( 'Common' , new CommonTemplate ( ) ) ; $ initializer -> addTemplate ( 'Laravel' , new LaravelTemplate ( ) ) ; $ initializer -> addTemplate ( 'Symfony' , new SymfonyTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii' , new YiiTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii2 Basic App' , new Yii2BasicAppTemplate ( ) ) ; $ initializer -> addTemplate ( 'Yii2 Advanced App' , new Yii2AdvancedAppTemplate ( ) ) ; return $ initializer ; }
9321	protected function compileMarkdownEchos ( $ value ) { $ pattern = sprintf ( '/(@)?%s\s*(.+?)\s*%s(\r?\n)?/s' , $ this -> markdownTags [ 0 ] , $ this -> markdownTags [ 1 ] ) ; $ callback = function ( $ matches ) { $ wrapper = sprintf ( $ this -> markdownFormat , $ this -> compileEchoDefaults ( $ matches [ 2 ] ) ) ; return $ matches [ 1 ] ? strlen ( stripcslashes ( $ this -> markdownTags [ 0 ] ) ) > 2 ? $ matches [ 0 ] : substr ( $ matches [ 0 ] , 1 ) : '<?php echo ' . $ wrapper . '; ?>' ; } ; return preg_replace_callback ( $ pattern , $ callback , $ value ) ; }
2939	public static function linearUnitFactory ( $ name , $ toNativeUnitFactor ) { return new static ( $ name , function ( $ valueInNativeUnit ) use ( $ toNativeUnitFactor ) { return $ valueInNativeUnit / $ toNativeUnitFactor ; } , function ( $ valueInThisUnit ) use ( $ toNativeUnitFactor ) { return $ valueInThisUnit * $ toNativeUnitFactor ; } ) ; }
11855	public function getUrlPath ( ) : ? string { $ uri = $ this -> getServerParam ( 'REQUEST_URI' , \ FILTER_SANITIZE_URL ) ; if ( ! is_null ( $ uri ) ) { return parse_url ( $ uri , \ PHP_URL_PATH ) ; } return null ; }
5606	public function paintGroupStart ( $ group , $ size ) { $ this -> group = self :: escapeVal ( $ group ) ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { xdebug_start_code_coverage ( XDEBUG_CC_UNUSED | XDEBUG_CC_DEAD_CODE ) ; } } }
7959	public function getPairsNumber ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> pairsNumber ; }
7262	protected function assertAdjustmentMode ( Model \ AdjustmentInterface $ adjustment , string $ expected ) : void { if ( $ expected !== $ mode = $ adjustment -> getMode ( ) ) { throw new Exception \ InvalidArgumentException ( "Unexpected adjustment mode '$mode'." ) ; } }
7165	private function buildDiscountLine ( Model \ SaleAdjustmentInterface $ adjustment , $ level = 0 ) { if ( Model \ AdjustmentTypes :: TYPE_DISCOUNT !== $ adjustment -> getType ( ) ) { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ lineNumber = $ this -> lineNumber ++ ; $ view = new LineView ( 'adjustment_' . ( $ lineNumber - 1 ) , 'adjustment_' . $ adjustment -> getId ( ) , $ lineNumber , $ level ) ; if ( empty ( $ designation = $ adjustment -> getDesignation ( ) ) ) { $ designation = 'Discount ' ; if ( $ adjustment -> getMode ( ) === Model \ AdjustmentModes :: MODE_PERCENT ) { $ designation .= $ this -> formatter -> percent ( $ adjustment -> getAmount ( ) ) ; } } $ result = $ adjustment -> getResult ( ) ; $ view -> setDesignation ( $ designation ) -> setBase ( $ this -> formatter -> currency ( $ result -> getBase ( ) ) ) -> setTaxAmount ( $ this -> formatter -> currency ( $ result -> getTax ( ) ) ) -> setTotal ( $ this -> formatter -> currency ( $ result -> getTotal ( ) ) ) ; foreach ( $ this -> types as $ type ) { $ type -> buildAdjustmentView ( $ adjustment , $ view , $ this -> options ) ; } return $ view ; }
12001	static protected function doctrine2Query ( \ Doctrine \ ORM \ EntityManager $ entityManager , $ entityName , $ field , $ generate ) { $ result = $ entityManager -> createQueryBuilder ( ) -> select ( "entity.$field" ) -> from ( $ entityName , 'entity' ) -> where ( "entity.$field = :$field" ) -> setParameter ( "$field" , $ generate ) -> getQuery ( ) -> getResult ( ) ; return ! empty ( $ result ) ; }
12030	function addFilteredParameterMethod ( ) { $ methodGenerator = new MethodGenerator ( 'getFilteredParameter' ) ; $ body = 'if (array_key_exists($name, $this->parameters) == false) {' . PHP_EOL ; $ body .= ' throw new \Exception(\'Parameter \'.$name.\' does not exist.\');' . PHP_EOL ; $ body .= '}' . PHP_EOL ; $ body .= '' . PHP_EOL ; $ body .= '$value = $this->parameters[$name];' . PHP_EOL ; $ body .= '' . PHP_EOL ; $ paramFilterBlocks = [ ] ; foreach ( $ this -> operationDefinition -> getParameters ( ) as $ parameter ) { $ parameterFilters = $ parameter -> getFilters ( ) ; if ( count ( $ parameterFilters ) ) { $ paramFilterBlocks [ ] = $ this -> generateParamFilterBlock ( $ parameter ) ; } } if ( count ( $ paramFilterBlocks ) ) { $ body .= 'switch ($name) {' . PHP_EOL ; $ body .= '' . PHP_EOL ; foreach ( $ paramFilterBlocks as $ paramFilterBlock ) { $ body .= $ paramFilterBlock . PHP_EOL ; $ body .= '' . PHP_EOL ; } $ body .= ' default:{}' . PHP_EOL ; $ body .= '' . PHP_EOL ; $ body .= '}' . PHP_EOL ; } $ body .= '' . PHP_EOL ; $ body .= 'return $value;' . PHP_EOL ; $ methodGenerator -> setBody ( $ body ) ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Apply any filters necessary to the parameter' ) ; $ parameterGenerator = new ParameterGenerator ( 'name' , 'string' ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ tag = createParamTag ( $ parameterGenerator , "The name of the parameter to get." ) ; $ docBlock -> setTag ( $ tag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
6358	public function setTimezone ( $ timezone ) { try { $ this -> timestamp -> setTimezone ( new DateTimeZone ( $ timezone ) ) ; } catch ( Exception $ e ) { throw new TimestampException ( __METHOD__ . ': Invalid timezone.' , $ e -> getCode ( ) , $ e ) ; } }
5701	protected function createFieldList ( $ buttons ) { $ actions = FieldList :: create ( ) ; foreach ( $ buttons as $ buttonType => $ bool ) { if ( ! $ bool || ! $ buttonType ) { continue ; } if ( substr ( $ buttonType , 0 , 6 ) == "Group_" ) { $ group = $ this -> createButtonGroup ( substr ( $ buttonType , 6 ) ) ; if ( $ group -> children -> exists ( ) ) { $ actions -> push ( $ group ) ; } } elseif ( $ b = $ this -> instantiateButton ( $ buttonType ) ) { $ actions -> push ( $ b ) ; } } return $ actions ; }
7366	protected function checkPrivacyIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ parent = $ item -> getParent ( ) ; if ( $ item -> isPrivate ( ) ) { if ( null === $ parent ) { $ this -> context -> buildViolation ( $ constraint -> root_item_cant_be_private ) -> atPath ( 'private' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } elseif ( $ item -> getTaxGroup ( ) !== $ parent -> getTaxGroup ( ) ) { $ this -> context -> buildViolation ( $ constraint -> tax_group_integrity ) -> atPath ( 'taxGroup' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } } elseif ( null !== $ parent && $ parent -> isPrivate ( ) ) { $ this -> context -> buildViolation ( $ constraint -> privacy_integrity ) -> atPath ( 'private' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
7683	function Ext_GetMainIdx ( ) { if ( ( $ this -> ExtInfo !== false ) && isset ( $ this -> ExtInfo [ 'main' ] ) ) { return $ this -> FileGetIdx ( $ this -> ExtInfo [ 'main' ] ) ; } else { return false ; } }
5457	protected function addContentTagToOpenTags ( & $ tag ) { if ( $ tag -> getTagName ( ) != 'option' ) { return ; } foreach ( array_keys ( $ this -> tags ) as $ name ) { for ( $ i = 0 , $ count = count ( $ this -> tags [ $ name ] ) ; $ i < $ count ; $ i ++ ) { $ this -> tags [ $ name ] [ $ i ] -> addTag ( $ tag ) ; } } }
11168	public function getApiAsArray ( ) { if ( $ this -> useCache ( ) ) { if ( $ this -> getExtCache ( ) -> isApiCached ( ) ) { return $ this -> getExtCache ( ) -> getApi ( ) ; } } $ api = $ this -> generateApi ( ) ; if ( $ this -> useCache ( ) ) { $ this -> getExtCache ( ) -> cacheApi ( $ api ) ; } return $ api ; }
9668	private function writePatternFill ( XMLWriter $ objWriter , Fill $ pFill ) { $ objWriter -> startElement ( 'fill' ) ; $ objWriter -> startElement ( 'patternFill' ) ; $ objWriter -> writeAttribute ( 'patternType' , $ pFill -> getFillType ( ) ) ; if ( $ pFill -> getFillType ( ) !== Fill :: FILL_NONE ) { if ( $ pFill -> getStartColor ( ) -> getARGB ( ) ) { $ objWriter -> startElement ( 'fgColor' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getStartColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } } if ( $ pFill -> getFillType ( ) !== Fill :: FILL_NONE ) { if ( $ pFill -> getEndColor ( ) -> getARGB ( ) ) { $ objWriter -> startElement ( 'bgColor' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getEndColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
2571	public static function isValidFopType ( $ fopType ) { return ( $ fopType == self :: IDENT_CASH || $ fopType == self :: IDENT_CHECK || $ fopType == self :: IDENT_CREDITCARD || $ fopType == self :: IDENT_MISC ) ; }
7193	private function copy ( $ source , $ target , array $ properties ) { $ properties = ( array ) $ properties ; foreach ( $ properties as $ property ) { $ this -> accessor -> setValue ( $ target , $ property , $ this -> accessor -> getValue ( $ source , $ property ) ) ; } }
6324	public function start ( ) { if ( ! isset ( $ this -> _dir ) ) { return false ; } $ this -> _page = $ this -> url ; $ this -> _file = $ this -> _dir . md5 ( $ this -> _page ) . '.' . $ this -> _ext ; $ ignore_page = false ; for ( $ i = 0 ; $ i < count ( $ this -> _ignoreList ) ; $ i ++ ) { $ ignore_page = ( strpos ( $ this -> _page , $ this -> _ignoreList [ $ i ] ) !== false ) ? true : $ ignore_page ; } $ cachefile_created = ( file_exists ( $ this -> _file ) && ( $ ignore_page === false ) ) ? filemtime ( $ this -> _file ) : 0 ; clearstatcache ( ) ; if ( time ( ) - $ this -> _time < $ cachefile_created ) { ob_start ( 'ob_gzhandler' ) ; readfile ( $ this -> _file ) ; ob_end_flush ( ) ; exit ( ) ; } ob_start ( 'ob_gzhandler' ) ; }
307	private function sizeToBytes ( $ sizeStr ) { switch ( substr ( $ sizeStr , - 1 ) ) { case 'M' : case 'm' : return ( int ) $ sizeStr * 1048576 ; case 'K' : case 'k' : return ( int ) $ sizeStr * 1024 ; case 'G' : case 'g' : return ( int ) $ sizeStr * 1073741824 ; default : return ( int ) $ sizeStr ; } }
11022	public function listTasks ( $ ostr = STDOUT ) { $ this -> findTasks ( ) ; if ( count ( $ this -> task_list ) === 0 ) { fprintf ( $ ostr , "No tasks available\n" ) ; } else { fprintf ( $ ostr , "Listing available tasks: \n" ) ; foreach ( $ this -> task_list as $ task => $ desc ) { $ task = str_replace ( '\\' , ':' , $ task ) ; fprintf ( $ ostr , "- %-30s" , $ task ) ; CLI :: formatText ( 32 , CLI :: MAX_LINE_LENGTH , ' ' . $ desc , $ ostr ) ; } printf ( "\n" ) ; } }
5342	private function getSoapClient ( $ service , $ method , array $ parameters ) { $ timestamp = time ( ) ; $ nonce = uniqid ( null , true ) ; $ soapClient = $ this -> client -> buildSoapClient ( $ service ) ; $ soapClient -> setTimestamp ( $ timestamp ) ; $ soapClient -> setNonce ( $ nonce ) ; $ soapClient -> setSignature ( array_merge ( $ parameters , [ '__method' => $ method ] ) , $ this -> client -> getPrivateKey ( ) , $ service , $ this -> client -> getEndpoint ( ) , $ timestamp , $ nonce ) ; return $ soapClient ; }
770	public function getIterator ( ) { $ value = $ this -> getValue ( ) ; if ( $ value instanceof QueryInterface ) { throw new InvalidConfigException ( 'The ArrayExpression class can not be iterated when the value is a QueryInterface object' ) ; } if ( $ value === null ) { $ value = [ ] ; } return new \ ArrayIterator ( $ value ) ; }
7909	protected function renderSearchInput ( ) { $ lines = [ ] ; $ lines [ ] = Html :: beginTag ( 'div' , [ 'class' => 'ui icon search input' ] ) ; $ lines [ ] = Html :: tag ( 'i' , '' , [ 'class' => 'search icon' ] ) ; $ lines [ ] = Html :: input ( 'text' , $ this -> getId ( ) . '-search' , '' , $ this -> searchInputOptions ) ; $ lines [ ] = Html :: endTag ( 'div' ) ; $ lines [ ] = Html :: tag ( 'div' , '' , [ 'class' => 'divider' ] ) ; return implode ( "\n" , $ lines ) ; }
2181	private function filterNestedPaths ( Finder $ finder , string $ prepend ) : array { $ parents = [ ] ; $ files = iterator_to_array ( $ finder ) ; foreach ( $ files as $ key => $ file ) { $ path = rtrim ( strtr ( $ prepend . '/' . $ file -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; if ( ! empty ( $ parents ) ) { $ parent = \ dirname ( $ path ) ; while ( false !== strpos ( $ parent , '/' ) ) { if ( \ in_array ( $ parent , $ parents , true ) ) { $ this -> rows [ ] = [ sprintf ( '<fg=yellow;options=bold>%s</>' , '\\' === \ DIRECTORY_SEPARATOR ? 'WARNING' : '!' ) , $ this -> webDir . '/' . $ path , sprintf ( '<comment>Skipped because %s will be symlinked.</comment>' , $ parent ) , ] ; unset ( $ files [ $ key ] ) ; break ; } $ parent = \ dirname ( $ parent ) ; } } $ parents [ ] = $ path ; } return array_values ( $ files ) ; }
12127	public function getSetting ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> settings ) ? $ this -> settings [ $ name ] : $ default ; }
8665	private function convertGetReportRequestCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportRequestCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetReportProcessingStatusList ( ) ) { $ reportProcessingStatusList = $ request -> getReportProcessingStatusList ( ) ; foreach ( $ reportProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'ReportProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetRequestedFromDate ( ) ) { $ parameters [ 'RequestedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedFromDate ( ) ) ; } if ( $ request -> isSetRequestedToDate ( ) ) { $ parameters [ 'RequestedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
2240	public static function getTemplateGroup ( $ strPrefix ) { $ arrTemplates = array ( ) ; foreach ( TemplateLoader :: getPrefixedFiles ( $ strPrefix ) as $ strTemplate ) { $ arrTemplates [ $ strTemplate ] [ ] = 'root' ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrCustomized = self :: braceGlob ( $ rootDir . '/templates/' . $ strPrefix . '*.html5' ) ; if ( \ is_array ( $ arrCustomized ) ) { foreach ( $ arrCustomized as $ strFile ) { $ strTemplate = basename ( $ strFile , strrchr ( $ strFile , '.' ) ) ; $ arrTemplates [ $ strTemplate ] [ ] = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'global' ] ; } } if ( $ strPrefix != 'be_' && $ strPrefix != 'mail_' ) { try { $ objTheme = ThemeModel :: findAll ( array ( 'order' => 'name' ) ) ; } catch ( \ Exception $ e ) { $ objTheme = null ; } if ( $ objTheme !== null ) { while ( $ objTheme -> next ( ) ) { if ( $ objTheme -> templates != '' ) { $ arrThemeTemplates = self :: braceGlob ( $ rootDir . '/' . $ objTheme -> templates . '/' . $ strPrefix . '*.html5' ) ; if ( \ is_array ( $ arrThemeTemplates ) ) { foreach ( $ arrThemeTemplates as $ strFile ) { $ strTemplate = basename ( $ strFile , strrchr ( $ strFile , '.' ) ) ; $ arrTemplates [ $ strTemplate ] [ ] = $ objTheme -> name ; } } } } } } foreach ( $ arrTemplates as $ k => $ v ) { $ v = array_filter ( $ v , function ( $ a ) { return $ a != 'root' ; } ) ; if ( empty ( $ v ) ) { $ arrTemplates [ $ k ] = $ k ; } else { $ arrTemplates [ $ k ] = $ k . ' (' . implode ( ', ' , $ v ) . ')' ; } } ksort ( $ arrTemplates ) ; return $ arrTemplates ; }
4336	private function closeOpenGroups ( ) { $ this -> data [ 'groupPriorityStack' ] [ ] = 'main' ; while ( $ this -> data [ 'groupPriorityStack' ] ) { $ priority = \ array_pop ( $ this -> data [ 'groupPriorityStack' ] ) ; foreach ( $ this -> data [ 'groupStacks' ] [ $ priority ] as $ i => $ info ) { if ( $ info [ 'collect' ] ) { unset ( $ this -> data [ 'groupStacks' ] [ $ priority ] [ $ i ] ) ; $ meta = array ( 'channel' => $ info [ 'channel' ] , ) ; if ( $ priority === 'main' ) { $ this -> data [ 'log' ] [ ] = array ( 'groupEnd' , array ( ) , $ meta ) ; } else { $ this -> data [ 'logSummary' ] [ $ priority ] [ ] = array ( 'groupEnd' , array ( ) , $ meta ) ; } } } } }
6858	protected static function solsticeJune ( $ year , $ vsop = true ) { $ month = 6 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
680	protected function validateConjunctionCondition ( $ operator , $ condition ) { if ( ! is_array ( $ condition ) || ! ArrayHelper :: isIndexed ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; return ; } foreach ( $ condition as $ part ) { $ this -> validateCondition ( $ part ) ; } }
3945	public function onLoadDataContainer ( $ tableName ) { static $ tableExists ; if ( null === $ tableExists ) { $ tableExists = \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' ] ) ; } if ( false === $ tableExists ) { return ; } $ this -> handleMetaModelTable ( $ tableName ) ; $ this -> handleNonMetaModelTable ( $ tableName ) ; }
12064	public function setFlashBag ( $ sName , $ sValue ) { if ( ! isset ( $ _SESSION [ 'flashbag' ] ) ) { $ _SESSION [ 'flashbag' ] = array ( ) ; } $ _SESSION [ 'flashbag' ] [ $ sName ] = $ sValue ; return $ this ; }
9299	public function postAction ( Request $ request ) { try { $ data = $ this -> get ( 'ongr_api.batch_request_handler' ) -> handleRequest ( $ request , $ repository = $ this -> getRequestRepository ( $ request ) , 'create' ) ; return $ this -> renderRest ( $ request , $ data , Response :: HTTP_OK ) ; } catch ( \ Exception $ e ) { return $ this -> renderError ( $ request , $ e -> getMessage ( ) , Response :: HTTP_BAD_REQUEST ) ; } }
7973	public function purchase ( $ domain , $ quantity ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ quantity ) throw new BadMethodCallException ( 'Parameter $quantity is missing.' ) ; $ quantity = intval ( $ quantity ) ; $ allowedQ = array ( 100 , 200 , 250 , 500 , 1000 , 5000 , 2500 , 10000 , 50000 , 100000 ) ; if ( ! in_array ( $ quantity , $ allowedQ ) ) throw new BadMethodCallException ( 'Parameter $quantity must be in array (' . implode ( ', ' , $ allowedQ ) . '), "' . $ quantity . '" given.' ) ; try { $ r = $ this -> post ( 'sms/' . $ domain . '/purchase' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ quantity ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
12907	public function store ( FilterRequest $ request ) { $ this -> fieldManager = $ this -> getFieldManager ( ) ; $ this -> validate ( $ request -> request , $ this -> fieldManager -> store ( ) ) ; $ input = $ request -> all ( ) ; $ resource = $ this -> repository -> create ( $ input ) ; if ( ! $ resource ) { } return $ this -> created ( $ resource ) ; }
754	public function run ( ) { if ( Yii :: $ app -> request -> getQueryParam ( self :: REFRESH_GET_VAR ) !== null ) { $ code = $ this -> getVerifyCode ( true ) ; Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; return [ 'hash1' => $ this -> generateValidationHash ( $ code ) , 'hash2' => $ this -> generateValidationHash ( strtolower ( $ code ) ) , 'url' => Url :: to ( [ $ this -> id , 'v' => uniqid ( '' , true ) ] ) , ] ; } $ this -> setHttpHeaders ( ) ; Yii :: $ app -> response -> format = Response :: FORMAT_RAW ; return $ this -> renderImage ( $ this -> getVerifyCode ( ) ) ; }
2772	public function init ( array $ options = [ ] ) : string { $ argsAndOptions = [ $ this -> directory , $ options ] ; return $ this -> run ( 'init' , $ argsAndOptions , false ) ; }
10200	private function writeXfStyles ( XMLWriter $ writer , Spreadsheet $ spreadsheet ) { foreach ( $ spreadsheet -> getCellXfCollection ( ) as $ style ) { $ writer -> startElement ( 'style:style' ) ; $ writer -> writeAttribute ( 'style:name' , self :: CELL_STYLE_PREFIX . $ style -> getIndex ( ) ) ; $ writer -> writeAttribute ( 'style:family' , 'table-cell' ) ; $ writer -> writeAttribute ( 'style:parent-style-name' , 'Default' ) ; $ writer -> startElement ( 'style:text-properties' ) ; $ font = $ style -> getFont ( ) ; if ( $ font -> getBold ( ) ) { $ writer -> writeAttribute ( 'fo:font-weight' , 'bold' ) ; $ writer -> writeAttribute ( 'style:font-weight-complex' , 'bold' ) ; $ writer -> writeAttribute ( 'style:font-weight-asian' , 'bold' ) ; } if ( $ font -> getItalic ( ) ) { $ writer -> writeAttribute ( 'fo:font-style' , 'italic' ) ; } if ( $ color = $ font -> getColor ( ) ) { $ writer -> writeAttribute ( 'fo:color' , sprintf ( '#%s' , $ color -> getRGB ( ) ) ) ; } if ( $ family = $ font -> getName ( ) ) { $ writer -> writeAttribute ( 'fo:font-family' , $ family ) ; } if ( $ size = $ font -> getSize ( ) ) { $ writer -> writeAttribute ( 'fo:font-size' , sprintf ( '%.1fpt' , $ size ) ) ; } if ( $ font -> getUnderline ( ) && $ font -> getUnderline ( ) != Font :: UNDERLINE_NONE ) { $ writer -> writeAttribute ( 'style:text-underline-style' , 'solid' ) ; $ writer -> writeAttribute ( 'style:text-underline-width' , 'auto' ) ; $ writer -> writeAttribute ( 'style:text-underline-color' , 'font-color' ) ; switch ( $ font -> getUnderline ( ) ) { case Font :: UNDERLINE_DOUBLE : $ writer -> writeAttribute ( 'style:text-underline-type' , 'double' ) ; break ; case Font :: UNDERLINE_SINGLE : $ writer -> writeAttribute ( 'style:text-underline-type' , 'single' ) ; break ; } } $ writer -> endElement ( ) ; $ writer -> startElement ( 'style:table-cell-properties' ) ; $ writer -> writeAttribute ( 'style:rotation-align' , 'none' ) ; if ( $ fill = $ style -> getFill ( ) ) { switch ( $ fill -> getFillType ( ) ) { case Fill :: FILL_SOLID : $ writer -> writeAttribute ( 'fo:background-color' , sprintf ( '#%s' , strtolower ( $ fill -> getStartColor ( ) -> getRGB ( ) ) ) ) ; break ; case Fill :: FILL_GRADIENT_LINEAR : case Fill :: FILL_GRADIENT_PATH : break ; case Fill :: FILL_NONE : default : } } $ writer -> endElement ( ) ; $ writer -> endElement ( ) ; } }
2775	public function streamOutput ( bool $ streamOutput = true ) : void { if ( $ streamOutput && ! isset ( $ this -> gitOutputListener ) ) { $ this -> gitOutputListener = new GitOutputStreamListener ( ) ; $ this -> addOutputListener ( $ this -> gitOutputListener ) ; } if ( ! $ streamOutput && isset ( $ this -> gitOutputListener ) ) { $ this -> removeOutputListener ( $ this -> gitOutputListener ) ; unset ( $ this -> gitOutputListener ) ; } }
2296	public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ arrUnset [ ] = 'nb' ; return parent :: addToUrl ( $ strRequest . ( ( $ strRequest != '' ) ? '&amp;' : '' ) . 'rt=' . REQUEST_TOKEN , $ blnAddRef , $ arrUnset ) ; }
8470	public function alert ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'alert' , $ scope , $ message , $ context , $ config ) ; }
4843	public static function sortPairs ( $ a , $ b ) { $ keys = strcmp ( $ a [ 0 ] , $ b [ 0 ] ) ; if ( $ keys !== 0 ) { return $ keys ; } return strcmp ( $ a [ 1 ] , $ b [ 1 ] ) ; }
6032	public function getDeployedFile ( $ templateId , $ templateType = self :: TEMPLATE_IMAGE , $ siteId = null ) { foreach ( $ this -> deployedFiles as $ deployedFile ) { if ( null === $ siteId || $ siteId == $ deployedFile -> getDeployMentSiteId ( ) ) { if ( self :: TEMPLATE_VIDEO == $ templateType ) { if ( $ templateId == $ deployedFile -> getVideoTemplateId ( ) && null === $ deployedFile -> getImageTemplateId ( ) ) { return $ deployedFile ; } } elseif ( self :: TEMPLATE_IMAGE == $ templateType && $ templateId == $ deployedFile -> getImageTemplateId ( ) || ( null === $ templateId && null === $ deployedFile -> getImageTemplateId ( ) && null === $ deployedFile -> getVideoTemplateId ( ) ) ) { return $ deployedFile ; } } } throw new NotFoundException ( 'No DeploymentFile with the id "' . $ templateId . '" exists.' ) ; }
10075	public static function controlCharacterOOXML2PHP ( $ value ) { self :: buildCharacterSets ( ) ; return str_replace ( array_keys ( self :: $ controlCharacters ) , array_values ( self :: $ controlCharacters ) , $ value ) ; }
3499	public function create ( DeviceToken $ deviceToken , bool $ sandbox ) : string { $ uri = 'https://api.push.apple.com/3/device/%s' ; if ( $ sandbox ) { $ uri = 'https://api.development.push.apple.com/3/device/%s' ; } return sprintf ( $ uri , $ deviceToken ) ; }
5398	public function paintSignal ( $ type , $ payload ) { parent :: paintSignal ( $ type , $ payload ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . "signal type=\"$type\">" ; print '<![CDATA[' . serialize ( $ payload ) . ']]>' ; print '</' . $ this -> namespace . "signal>\n" ; }
6050	public function addPropertyResponse ( $ item ) { if ( ! ( $ item instanceof PropertyResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertyResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertyResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertyResponse"!' , E_USER_WARNING ) ; } } $ this -> properties [ ] = $ item ; return $ this ; }
2167	protected static function generateHelperObject ( $ value ) { $ return = new \ stdClass ( ) ; if ( ! \ is_array ( $ value ) ) { $ return -> value = rtrim ( $ value , "\x00" ) ; $ return -> isUuid = ( \ strlen ( $ value ) == 16 && ! is_numeric ( $ return -> value ) && strncmp ( $ return -> value , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value ) && $ return -> value > 0 ) ; } else { $ return -> value = array_map ( function ( $ var ) { return rtrim ( $ var , "\x00" ) ; } , $ value ) ; $ return -> isUuid = ( \ strlen ( $ value [ 0 ] ) == 16 && ! is_numeric ( $ return -> value [ 0 ] ) && strncmp ( $ return -> value [ 0 ] , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value [ 0 ] ) && $ return -> value [ 0 ] > 0 ) ; } return $ return ; }
3858	public function setFilterSettings ( $ intFilter ) { $ this -> intFilter = $ intFilter ; $ this -> objFilterSettings = $ this -> getFilterFactory ( ) -> createCollection ( $ this -> intFilter ) ; if ( ! $ this -> objFilterSettings ) { throw new \ RuntimeException ( 'Error: no filter object defined.' ) ; } return $ this ; }
5576	public function clickSubmitById ( $ id , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectById ( $ id ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectById ( $ id ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
8171	public function renderString ( $ tplString = '' , $ tplData = [ ] ) { try { return $ this -> twig -> createTemplate ( $ tplString ) -> render ( $ tplData ) ; } catch ( Twig_Error $ err ) { return $ this -> error ( $ err , false , $ tplString ) ; } }
9463	public function compose ( View $ view ) { $ this -> sidebar -> loadItemsFromConfig ( 'arcanesoft.foundation.sidebar.items' ) ; $ this -> sidebar -> setCurrent ( Arr :: get ( $ view -> getData ( ) , 'current_page' , '' ) ) ; }
11539	public function add ( $ sourceDir , array $ options , $ username ) { $ this -> resolveAddOptions ( $ options ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ this -> addBlockToSlot ( $ dir , $ options ) ; $ blockContent = $ this -> addBlock ( $ dir , $ options , $ blockName ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been added to the "%s" slot on page "%s" for the "%s_%s" language' , $ blockName , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; return $ blockContent ; }
10282	public static function splitRange ( $ pRange ) { if ( empty ( $ pRange ) ) { $ pRange = self :: DEFAULT_RANGE ; } $ exploded = explode ( ',' , $ pRange ) ; $ counter = count ( $ exploded ) ; for ( $ i = 0 ; $ i < $ counter ; ++ $ i ) { $ exploded [ $ i ] = explode ( ':' , $ exploded [ $ i ] ) ; } return $ exploded ; }
4301	public function groupSummary ( $ priority = 0 ) { array ( $ priority ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'priority' => 0 ) , array ( 'priority' ) ) ; $ this -> data [ 'groupPriorityStack' ] [ ] = $ meta [ 'priority' ] ; $ this -> setLogDest ( 'summary' ) ; $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; }
10421	public function addToUpdateFields ( $ updateField , $ updateType = null ) { $ this -> updateFields [ $ updateField ] = [ 'priority' => isset ( $ updateType ) ? $ updateType : $ this -> defaultJobType ] ; }
9024	public function hasDenial ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( in_array ( $ word , $ this -> denialWords ) ) { $ result = true ; } } return $ result ; }
10135	public function processBitmapGd ( $ image ) { $ width = imagesx ( $ image ) ; $ height = imagesy ( $ image ) ; $ data = pack ( 'Vvvvv' , 0x000c , $ width , $ height , 0x01 , 0x18 ) ; for ( $ j = $ height ; -- $ j ; ) { for ( $ i = 0 ; $ i < $ width ; ++ $ i ) { $ color = imagecolorsforindex ( $ image , imagecolorat ( $ image , $ i , $ j ) ) ; foreach ( [ 'red' , 'green' , 'blue' ] as $ key ) { $ color [ $ key ] = $ color [ $ key ] + round ( ( 255 - $ color [ $ key ] ) * $ color [ 'alpha' ] / 127 ) ; } $ data .= chr ( $ color [ 'blue' ] ) . chr ( $ color [ 'green' ] ) . chr ( $ color [ 'red' ] ) ; } if ( 3 * $ width % 4 ) { $ data .= str_repeat ( "\x00" , 4 - 3 * $ width % 4 ) ; } } return [ $ width , $ height , strlen ( $ data ) , $ data ] ; }
6151	public function redirect ( string $ url ) : object { $ this -> addHeader ( "Location: " . $ url ) ; $ this -> body = null ; return $ this ; }
2203	public static function decodeEntities ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: decodeEntities ( $ v ) ; } return $ varValue ; } $ varValue = static :: preserveBasicEntities ( $ varValue ) ; $ varValue = html_entity_decode ( $ varValue , ENT_QUOTES , Config :: get ( 'characterSet' ) ) ; return $ varValue ; }
104	public function isRateLimited ( array $ headers ) { foreach ( $ headers as $ header ) { if ( preg_match ( '{^X-RateLimit-Remaining: *0$}i' , trim ( $ header ) ) ) { return true ; } } return false ; }
1382	protected function dataHas ( $ key ) : bool { if ( ! isset ( $ this -> document -> data ) ) { return false ; } return property_exists ( $ this -> document -> data , $ key ) ; }
1476	public function createQueryValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ data , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) { return $ this -> invalidQueryParameter ( $ key , $ detail , $ failed ) ; } ) ; }
3110	public function removeCatValue ( $ assessmentSectionId , $ key ) { if ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) { unset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ; } return $ this ; }
7738	public function serialize ( $ entity ) { if ( ! $ this -> container -> has ( 'hydra.serializer' ) ) { throw new \ LogicException ( 'The HydraBundle is not registered in your application.' ) ; } return $ this -> container -> get ( 'hydra.serializer' ) -> serialize ( $ entity , self :: FORMAT ) ; }
7026	public function checkRememberMeCookie ( ) { if ( ! $ this -> loggedIn ( ) && $ this -> Cookie -> read ( 'User.id' ) ) { return $ this -> Cookie -> read ( 'User.id' ) ; } return false ; }
8139	public function load ( $ name ) { if ( $ name instanceof Twig_TemplateWrapper ) { return $ name ; } if ( $ name instanceof Twig_Template ) { return new Twig_TemplateWrapper ( $ this , $ name ) ; } return new Twig_TemplateWrapper ( $ this , $ this -> loadTemplate ( $ name ) ) ; }
1019	public static function createLocatedError ( $ error , $ nodes = null , $ path = null ) { if ( $ error instanceof self ) { if ( $ error -> path && $ error -> nodes ) { return $ error ; } $ nodes = $ nodes ? : $ error -> nodes ; $ path = $ path ? : $ error -> path ; } $ source = $ positions = $ originalError = null ; $ extensions = [ ] ; if ( $ error instanceof self ) { $ message = $ error -> getMessage ( ) ; $ originalError = $ error ; $ nodes = $ error -> nodes ? : $ nodes ; $ source = $ error -> source ; $ positions = $ error -> positions ; $ extensions = $ error -> extensions ; } elseif ( $ error instanceof Exception || $ error instanceof Throwable ) { $ message = $ error -> getMessage ( ) ; $ originalError = $ error ; } else { $ message = ( string ) $ error ; } return new static ( $ message ? : 'An unknown error occurred.' , $ nodes , $ source , $ positions , $ path , $ originalError , $ extensions ) ; }
5828	public function newRequest ( $ method , $ url , $ data = array ( ) , $ encoding = Request :: ENCODING_QUERY ) { $ class = $ this -> requestClass ; $ request = new $ class ( $ this ) ; $ request -> setMethod ( $ method ) ; $ request -> setUrl ( $ url ) ; $ request -> setData ( $ data ) ; $ request -> setEncoding ( $ encoding ) ; return $ request ; }
6073	public function group ( $ id , array $ children ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'children' => $ children ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/group' , $ parameters ) ; return $ result ; }
4317	private static function getMethodDefaultArgs ( $ methodName ) { $ defaultArgs = array ( ) ; if ( isset ( self :: $ methodDefaultArgs [ $ methodName ] ) ) { $ defaultArgs = self :: $ methodDefaultArgs [ $ methodName ] ; } elseif ( \ method_exists ( self :: $ instance , $ methodName ) ) { $ reflectionMethod = new ReflectionMethod ( self :: $ instance , $ methodName ) ; $ params = $ reflectionMethod -> getParameters ( ) ; foreach ( $ params as $ reflectionParameter ) { $ defaultArgs [ ] = $ reflectionParameter -> isOptional ( ) ? $ reflectionParameter -> getDefaultValue ( ) : null ; } self :: $ methodDefaultArgs [ $ methodName ] = $ defaultArgs ; } return $ defaultArgs ; }
5388	protected function valuesArePossible ( $ values ) { $ matches = array ( ) ; $ widgets = & $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { $ possible = $ widgets [ $ i ] -> getAttribute ( 'value' ) ; if ( in_array ( $ possible , $ values ) ) { $ matches [ ] = $ possible ; } } return ( $ values == $ matches ) ; }
8516	public function updateInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_UpdateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3106	public function getEvents ( ) { if ( isset ( $ this -> state [ self :: VAR_EVENTS_QUEUE ] ) ) { $ events = $ this -> state [ self :: VAR_EVENTS_QUEUE ] ; } else { $ events = [ ] ; } return $ events ; }
9230	public function patch ( $ path , $ data = array ( ) , $ headers = array ( ) ) { if ( $ this -> throw_exceptions ) { throw new CanvasPest_Exception ( 'The Canvas API does not support the PATCH method' , CanvasPest_Exception :: UNSUPPORTED_METHOD ) ; } return false ; }
2327	public function setRow ( array $ arrData ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ this -> arrModels [ $ this -> intIndex ] -> setRow ( $ arrData ) ; return $ this ; }
12397	public function orWhere ( $ field , $ operator = null , $ value = null ) { return $ this -> where ( $ field , $ operator , $ value , '||' ) ; }
6670	public function get_movie_rating ( $ votes ) { $ votations = [ ] ; foreach ( $ votes as $ key => $ value ) { for ( $ i = 0 ; $ i < $ value ; $ i ++ ) { $ votations [ ] = $ key ; } } if ( count ( $ votations ) ) { $ rating = array_sum ( $ votations ) / count ( $ votations ) ; return round ( $ rating , 1 ) ; } return 'N/A' ; }
4948	public function findDraftsBy ( array $ criteria , array $ sort = null , $ limit = null , $ skip = null ) { $ criteria [ 'isDraft' ] = true ; return parent :: findBy ( $ criteria , $ sort , $ limit , $ skip ) ; }
4256	protected function buildNotInConsole ( ) { if ( ! $ this -> stats [ 'notInConsole' ] ) { return '' ; } $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ lis = array ( ) ; foreach ( $ errors as $ err ) { if ( \ array_intersect_assoc ( array ( 'category' => 'fatal' , 'inConsole' => true , 'isSuppressed' => true , ) , $ err -> getValues ( ) ) ) { continue ; } $ lis [ ] = '<li>' . $ err [ 'typeStr' ] . ': ' . $ err [ 'file' ] . ' (line ' . $ err [ 'line' ] . '): ' . ( $ err [ 'isHtml' ] ? $ err [ 'message' ] : \ htmlspecialchars ( $ err [ 'message' ] ) ) . '</li>' ; } if ( ! $ lis ) { return '' ; } $ count = \ count ( $ lis ) ; $ header = \ sprintf ( '%s %s captured while not collecting debug log' , $ this -> stats [ 'inConsole' ] || isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ? 'Additionally, there' : 'There' , $ count === 1 ? 'was 1 error' : 'were ' . $ count . ' errors' ) ; $ html = '<h3>' . $ header . '</h3>' . '<ul class="list-unstyled indent">' . "\n" . \ implode ( "\n" , $ lis ) . "\n" . '</ul>' ; return $ html ; }
11664	public function isValid ( array $ values ) { $ this -> errorMessages = [ ] ; foreach ( $ this -> elements -> getElements ( ) as $ element ) { $ elementId = $ element -> getID ( ) ; if ( empty ( $ elementId ) ) { continue ; } $ value = null ; if ( array_key_exists ( $ elementId , $ values ) ) { $ value = $ values [ $ elementId ] ; } $ element -> setValue ( $ value ) ; $ this -> filterElement ( $ element ) ; $ this -> validateElement ( $ element ) ; } return count ( $ this -> errorMessages ) === 0 ; }
11110	private function findExtensionsDirectories ( Container $ app ) { $ directories = $ app [ 'config.finder' ] -> ignoreUnreadableDirs ( ) -> directories ( ) -> name ( '*Extension' ) -> in ( $ app [ 'app.extensions.dir' ] ) -> depth ( '< 3' ) -> sortByName ( ) ; return $ directories ; }
11498	public static function locate ( $ column , $ value ) { $ table = new static ( ) ; $ select = $ table -> select ( ) -> where ( "{$table->getAdapter()->quoteIdentifier($column)} = ?" , $ value ) -> limit ( 1 ) ; return $ table -> fetchRow ( $ select ) ; }
12834	private function generatePureCreatorMethod ( ServiceDefinition $ service ) : string { $ taggedAs = implode ( ', ' , $ service -> getTags ( ) ) ; $ classNormalized = $ this -> normalizeFqcn ( $ service -> getClass ( ) ) ; if ( $ service -> isSingleton ( ) ) { return <<<PHP /** * Get service {$service->getId()} (Singleton) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { if (isset(\$this->singletons['{$service->getId()}'])) { return \$this->singletons['{$service->getId()}']; } /** @noinspection OneTimeUseVariablesInspection */ \$service = \$this->singletons['{$service->getId()}'] = new $classNormalized({$this->buildInjectionParameters($this->container, $service->getInjection()->getCreatorInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; } return <<<PHP /** * Get a fresh instance of service "{$service->getId()}" (Prototype) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { \$this->prototypes['{$service->getId()}'] = (\$this->prototypes['{$service->getId()}'] ?? 0) + 1; /** @noinspection OneTimeUseVariablesInspection */ \$service = new $classNormalized({$this->buildInjectionParameters($this->container, $service->getInjection()->getCreatorInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; }
3035	protected function exists ( $ key ) { return isset ( $ this -> cache [ $ key ] ) && in_array ( $ this -> cache [ $ key ] [ 'state' ] , [ self :: STATE_ALIGNED , self :: STATE_PENDING_WRITE ] ) ; }
2450	public function invalidateSourceCacheTag ( Contao \ DataContainer $ dc , array $ tags ) { $ commentModel = Contao \ CommentsModel :: findByPk ( $ dc -> id ) ; if ( null !== $ commentModel ) { $ tags [ ] = sprintf ( 'contao.comments.%s.%s' , $ commentModel -> source , $ commentModel -> parent ) ; } return $ tags ; }
5504	public function getCallCount ( $ method ) { $ this -> dieOnNoMethod ( $ method , 'get call count' ) ; $ method = strtolower ( $ method ) ; if ( ! isset ( $ this -> call_counts [ $ method ] ) ) { return 0 ; } return $ this -> call_counts [ $ method ] ; }
12249	public function xpathByAttribute ( $ strXpathQuery , $ strIndexAttribute = 'name' ) { $ arrOut = array ( ) ; $ objResult = $ this -> xpath ( $ strXpathQuery ) ; foreach ( $ objResult as $ intIndex => $ objNode ) { $ strIndex = ( string ) $ objNode -> attributes ( ) -> $ strIndexAttribute ; $ arrOut [ $ strIndex ] = $ objResult [ $ intIndex ] ; } return $ arrOut ; }
8923	public function generate ( $ sourceDocument , $ targetDocument ) { if ( $ sourceDocument === null || $ targetDocument === null ) { return $ targetDocument ; } if ( $ sourceDocument == new \ stdClass ( ) ) { return null ; } if ( is_array ( $ sourceDocument ) ) { if ( $ sourceDocument !== $ targetDocument ) { return $ targetDocument ; } return null ; } $ patchDocument = new \ stdClass ( ) ; $ sourceDocumentVars = get_object_vars ( $ sourceDocument ) ; $ targetDocumentVars = get_object_vars ( $ targetDocument ) ; foreach ( $ targetDocumentVars as $ var => $ value ) { if ( ! in_array ( $ var , array_keys ( $ sourceDocumentVars ) ) || ! in_array ( $ value , array_values ( $ sourceDocumentVars ) ) ) { $ patchDocument -> $ var = $ value ; } } foreach ( $ sourceDocumentVars as $ var => $ value ) { if ( $ targetDocumentVars === [ ] ) { $ patchDocument -> $ var = null ; break ; } if ( is_object ( $ value ) ) { if ( $ sourceDocument -> $ var !== null && is_object ( $ sourceDocument -> $ var ) ) { $ subPatch = $ this -> generate ( $ sourceDocument -> $ var , $ targetDocument -> $ var ) ; if ( $ subPatch !== null ) { $ patchDocument -> $ var = $ subPatch ; } } } elseif ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) || ! in_array ( $ value , array_values ( $ targetDocumentVars ) ) ) { $ sourceDocument -> $ var = null ; if ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) ) { $ patchDocument -> $ var = null ; } } } if ( count ( get_object_vars ( $ patchDocument ) ) > 0 ) { return $ patchDocument ; } return null ; }
7297	private function modulate_next_group ( $ object_id , $ object_type , $ mail_to_chunks ) { if ( ! empty ( $ mail_to_chunks ) ) { $ this -> options [ 'static_options' ] [ 'send_next_group' ] [ $ object_id ] = $ mail_to_chunks ; if ( $ object_type == 'post' ) { $ this -> transit_posts [ $ object_id ] = array ( 'new_status' => 'publish' , 'old_status' => 'draft' ) ; $ this -> inform_about_posts ( $ object_id ) ; } elseif ( $ object_type == 'comment' ) { $ this -> inform_about_comment ( $ object_id ) ; } } else { } }
11709	public function actionUpdate ( $ id ) { $ user = $ this -> findModel ( $ id ) ; $ user -> scenario = 'update' ; $ profile = $ this -> finder -> findProfileById ( $ id ) ; $ r = \ Yii :: $ app -> request ; $ this -> performAjaxValidation ( [ $ user , $ profile ] ) ; if ( $ user -> load ( $ r -> post ( ) ) && $ profile -> load ( $ r -> post ( ) ) && $ user -> save ( ) && $ profile -> save ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been updated' ) ) ; return $ this -> refresh ( ) ; } return $ this -> render ( 'update' , [ 'user' => $ user , 'profile' => $ profile , 'module' => $ this -> module , ] ) ; }
3020	public function getBlogInfo ( $ blogName ) { $ path = $ this -> blogPath ( $ blogName , '/info' ) ; return $ this -> getRequest ( $ path , null , true ) ; }
7043	public function handleSrcTableNames ( GetPropertyOptionsEvent $ event ) { if ( ( $ event -> getPropertyName ( ) !== 'tag_srctable' ) || ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_attribute' ) ) { return ; } $ sqlTable = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.sql-table' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ translated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.translated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ untranslated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.untranslated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ result = $ this -> getMetaModelTableNames ( $ translated , $ untranslated ) ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableNames ( ) as $ table ) { if ( 0 !== \ strpos ( $ table , 'mm_' ) ) { $ result [ $ sqlTable ] [ $ table ] = $ table ; } } if ( \ is_array ( $ result [ $ translated ] ) ) { \ asort ( $ result [ $ translated ] ) ; } if ( \ is_array ( $ result [ $ untranslated ] ) ) { \ asort ( $ result [ $ untranslated ] ) ; } if ( \ is_array ( $ result [ $ sqlTable ] ) ) { \ asort ( $ result [ $ sqlTable ] ) ; } $ event -> setOptions ( $ result ) ; }
10615	public function configure ( Response $ response , \ DateTime $ last_modified , $ lifetime ) { $ request = $ this -> request_stack -> getMasterRequest ( ) ; if ( ! ( $ request instanceof Request ) ) { return $ response ; } $ this -> setPrivateCache ( $ response , $ request ) -> setLastModified ( $ response , $ last_modified ) -> setLifetime ( $ response , $ lifetime ) -> setEtag ( $ response ) ; return $ response ; }
3726	public static function createFromQueryBuilder ( QueryBuilder $ builder , $ columnName = 'id' ) { return new self ( $ builder -> getSQL ( ) , $ builder -> getParameters ( ) , $ columnName , $ builder -> getConnection ( ) , $ builder -> getParameterTypes ( ) ) ; }
7770	public function errors ( ) { $ messages = [ ] ; foreach ( $ this -> errors as $ rule => $ items ) { foreach ( $ items as $ item ) { $ field = $ item [ 'field' ] ; $ message = $ this -> fetchMessage ( $ field , $ rule ) ; if ( isset ( $ this -> fieldAliases [ $ field ] ) ) { $ item [ 'field' ] = $ this -> fieldAliases [ $ field ] ; } $ messages [ $ field ] [ ] = $ this -> replaceMessageFormat ( $ message , $ item ) ; } } return new MessageBag ( $ messages ) ; }
3078	protected function hasChannel ( $ channelName , $ channelType ) { $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; return isset ( $ channels [ $ channelType ] [ $ channelName ] ) ; }
7355	public static function isValidSize ( $ size , $ throw = false ) { if ( in_array ( $ size , static :: getSizes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Unknown size '$size'." ) ; } return false ; }
10738	public function search ( $ query ) { $ results = new ResultCollection ( ) ; foreach ( $ this -> engines as $ eachEngine ) { if ( ! $ eachEngine -> supports ( $ query ) ) { continue ; } if ( $ more = $ eachEngine -> search ( $ query ) ) { if ( ! is_array ( $ more ) and ! $ more instanceof \ Traversable ) { throw new DomainException ( 'The returned result set is not traversable.' ) ; } foreach ( $ more as $ eachResult ) { $ results -> add ( $ eachResult ) ; } } } return $ results ; }
4815	public function getAsDom ( ) { $ anyDataSet = XmlUtil :: createXmlDocumentFromStr ( "<anydataset></anydataset>" ) ; $ nodeRoot = $ anyDataSet -> getElementsByTagName ( "anydataset" ) -> item ( 0 ) ; foreach ( $ this -> collection as $ sr ) { $ row = $ sr -> getAsDom ( ) ; $ nodeRow = $ row -> getElementsByTagName ( "row" ) -> item ( 0 ) ; $ newRow = XmlUtil :: createChild ( $ nodeRoot , "row" ) ; XmlUtil :: addNodeFromNode ( $ newRow , $ nodeRow ) ; } return $ anyDataSet ; }
11169	public static function boot ( ) { parent :: boot ( ) ; static :: addGlobalScope ( 'type' , function ( $ query ) { return $ query -> when ( static :: class !== StripeObject :: class , function ( $ query ) { $ query -> where ( 'type' , class_basename ( ( new static ( ) ) -> objectClass ) ) ; } ) ; } ) ; static :: created ( function ( StripeObject $ object ) { if ( $ object -> relatesWith ) { list ( $ related , $ tag ) = $ object -> relatesWith ; $ object -> relations ( get_class ( $ related ) ) -> attach ( $ related -> id , [ 'tag' => $ tag ] ) ; } } ) ; }
3168	private function getCurrentThemeId ( ) { $ themeService = $ this -> getServiceLocator ( ) -> get ( ThemeService :: SERVICE_ID ) ; return $ themeService -> getTheme ( ) -> getId ( ) ; }
11057	public function pathFunction ( $ route , array $ params = [ ] ) { return $ this -> container [ 'url_generator' ] -> generate ( $ route , $ params , UrlGeneratorInterface :: ABSOLUTE_PATH ) ; }
8907	public function get_next_id ( ) { return ( int ) $ this -> _database -> select ( 'AUTO_INCREMENT' ) -> from ( 'information_schema.TABLES' ) -> where ( 'TABLE_NAME' , $ this -> _database -> dbprefix ( $ this -> get_table ( ) ) ) -> where ( 'TABLE_SCHEMA' , $ this -> _database -> database ) -> get ( ) -> row ( ) -> AUTO_INCREMENT ; }
4052	private function fetchPropertiesFor ( $ inputScreenId , IMetaModel $ metaModel ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return array_map ( function ( $ column ) use ( $ inputScreenId , $ metaModel ) { if ( 'attribute' !== $ column [ 'dcatype' ] ) { return $ column ; } if ( ! ( $ attribute = $ metaModel -> getAttributeById ( $ column [ 'attr_id' ] ) ) ) { @ trigger_error ( 'Unknown attribute "' . $ column [ 'attr_id' ] . '" in input screen "' . $ inputScreenId . '"' , E_USER_WARNING ) ; return $ column ; } $ column = array_merge ( $ column , $ attribute -> getFieldDefinition ( $ column ) , [ 'col_name' => $ attribute -> getColName ( ) ] ) ; return $ column ; } , $ builder -> select ( '*' ) -> from ( 'tl_metamodel_dcasetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'published=:published' ) -> setParameter ( 'pid' , $ inputScreenId ) -> setParameter ( 'published' , 1 ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; }
10236	private function writeDefaultContentType ( XMLWriter $ objWriter , $ pPartname , $ pContentType ) { if ( $ pPartname != '' && $ pContentType != '' ) { $ objWriter -> startElement ( 'Default' ) ; $ objWriter -> writeAttribute ( 'Extension' , $ pPartname ) ; $ objWriter -> writeAttribute ( 'ContentType' , $ pContentType ) ; $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
5343	public function build ( SoapClientBuilderInterface $ builder ) { $ builder -> createWsdl ( $ this -> endpoint ) ; $ builder -> createSoapClient ( ) ; $ builder -> setLogin ( $ this -> login ) ; $ builder -> setMode ( $ this -> mode ) ; $ builder -> setClientVersion ( self :: CLIENT_VERSION ) ; return $ builder -> getSoapClient ( ) ; }
2842	public function getBlocksAsTree ( ) { $ blocks = $ this -> getRequestInfo ( ) -> getBlocks ( ) ; $ tree = new Varien_Data_Tree ( ) ; $ rootNodes = array ( ) ; foreach ( $ blocks as $ block ) { $ parentNode = $ tree -> getNodeById ( $ block -> getParentName ( ) ) ; $ node = new Varien_Data_Tree_Node ( array ( 'name' => $ block -> getName ( ) , 'class' => $ block -> getClass ( ) , 'template' => $ block -> getTemplateFile ( ) , 'duration' => $ block -> getRenderedDuration ( ) , 'count' => $ block -> getRenderedCount ( ) ) , 'name' , $ tree , $ parentNode ) ; $ tree -> addNode ( $ node , $ parentNode ) ; if ( ! $ parentNode ) { $ rootNodes [ ] = $ node ; } } return $ rootNodes ; }
6401	public function getResource ( $ resource ) : ? string { Preconditions :: checkState ( $ this -> isPsr0Compatible ( ) , "Class '%s' must be PSR-0 compatible!" , $ this -> getName ( ) ) ; $ slashedFileName = $ this -> getSlashedFileName ( ) ; $ filePath = $ resource [ 0 ] == '/' ? str_replace ( "/{$this->getSlashedName()}.php" , '' , $ slashedFileName ) . $ resource : dirname ( $ slashedFileName ) . '/' . $ resource ; return is_file ( $ filePath ) ? $ filePath : null ; }
2777	public function init ( string $ directory , array $ options = [ ] ) : GitWorkingCopy { $ git = $ this -> workingCopy ( $ directory ) ; $ git -> init ( $ options ) ; $ git -> setCloned ( true ) ; return $ git ; }
7654	public function dir_readdir ( ) { $ object = current ( $ this -> blobs ) ; if ( $ object !== false ) { next ( $ this -> blobs ) ; return $ object -> Name ; } return false ; }
3918	private function checkDownloads ( ) { if ( $ this -> getShowImages ( ) ) { return ; } if ( ( $ file = Input :: get ( 'file' ) ) && ( $ key = Input :: get ( 'fileKey' ) ) ) { if ( ! ( array_key_exists ( $ file , $ _SESSION [ 'metaModels_downloads' ] ) && $ _SESSION [ 'metaModels_downloads' ] [ $ file ] === $ key ) ) { $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_403' ] ( ) ; $ objHandler -> generate ( $ file ) ; } Controller :: sendFileToBrowser ( $ file ) ; } }
7383	public static function toValues ( $ input , array $ include = [ ] ) { if ( ! is_array ( $ input ) && ! is_object ( $ input ) ) { throw new InvalidArgumentException ( 'input must be an associative array or traversable object' ) ; } $ sqlStrs = [ ] ; if ( count ( $ include ) ) { foreach ( $ include as $ i ) { if ( array_key_exists ( $ i , $ input ) ) { $ sqlStrs [ ] = '`' . $ i . '` = VALUES(`' . $ i . '`)' ; } } } else { foreach ( $ input as $ k => & $ v ) { $ sqlStrs [ ] = '`' . $ k . '` = VALUES(`' . $ k . '`)' ; } } return implode ( ",\n" , $ sqlStrs ) ; }
3290	public function join ( ) : Promise { if ( ! $ this -> handle ) { throw new StatusError ( "Process has not been started." ) ; } return $ this -> processRunner -> join ( $ this -> handle ) ; }
4474	public function perform ( ) : bool { try { $ instance = $ this -> getInstance ( ) ; if ( method_exists ( $ instance , 'setUp' ) ) { $ instance -> setUp ( ) ; } $ this -> getEventsManager ( ) -> fire ( new JobEvent \ BeforePerform ( $ this , $ this ) ) ; $ performMethod = $ this -> getPerformMethod ( ) ; $ instance -> $ performMethod ( $ this ) ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ AfterPerform ( $ this , $ this ) ) ; if ( method_exists ( $ instance , 'tearDown' ) ) { $ instance -> tearDown ( ) ; } } catch ( \ Throwable $ e ) { $ this -> fail ( 'system:fatal' , sprintf ( '%s: %s in %s on line %d' , get_class ( $ e ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) ) ) ; return false ; } return true ; }
3221	function searchFileNames ( $ basePath , $ query , $ limit = null , $ includeDeleted = false ) { Path :: checkArg ( "basePath" , $ basePath ) ; Checker :: argStringNonEmpty ( "query" , $ query ) ; Checker :: argNatOrNull ( "limit" , $ limit ) ; Checker :: argBool ( "includeDeleted" , $ includeDeleted ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/search" , $ basePath ) , array ( "query" => $ query , "file_limit" => $ limit , "include_deleted" => $ includeDeleted , ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
1394	public function withMediaType ( string $ mediaType ) : self { if ( ! $ encoding = $ this -> api -> getEncodings ( ) -> find ( $ mediaType ) ) { throw new \ InvalidArgumentException ( "Media type {$mediaType} is not valid for API {$this->api->getName()}." ) ; } $ codec = $ this -> factory -> createCodec ( $ this -> api -> getContainer ( ) , $ encoding , null ) ; return $ this -> withCodec ( $ codec ) ; }
7748	private function isAccessible ( \ ReflectionClass $ class , $ methodName , $ parameters ) { if ( $ class -> hasMethod ( $ methodName ) ) { $ method = $ class -> getMethod ( $ methodName ) ; if ( $ method -> isPublic ( ) && $ method -> getNumberOfRequiredParameters ( ) === $ parameters ) { return true ; } } return false ; }
2905	public function addEmailToProfile ( $ email , $ name , $ variables , $ result , Zend_Mail $ mail ) { $ emailCapture = Mage :: getModel ( 'sheep_debug/email' ) ; $ subject = $ this -> decodeSubject ( $ mail -> getSubject ( ) ) ; $ body = $ this -> getContent ( $ mail ) ; $ emailCapture -> setFromName ( $ this -> getSenderName ( ) ) ; $ emailCapture -> setFromEmail ( $ this -> getSenderEmail ( ) ) ; $ emailCapture -> setToEmail ( $ email ) ; $ emailCapture -> setToName ( $ name ) ; $ emailCapture -> setSubject ( $ subject ) ; $ emailCapture -> setIsPlain ( $ this -> isPlain ( ) ) ; $ emailCapture -> setBody ( $ body ) ; $ emailCapture -> setIsAccepted ( $ result ) ; $ emailCapture -> setVariables ( $ variables ) ; $ emailCapture -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) -> addEmail ( $ emailCapture ) ; }
4871	public function setEventPrototype ( EventInterface $ prototype ) { if ( ! $ prototype instanceof DependencyResultEvent ) { throw new \ InvalidArgumentException ( 'This event manager only accepts events of the type ' . DependencyResultEvent :: class ) ; } parent :: setEventPrototype ( $ prototype ) ; }
10708	public function getMany ( $ columns = [ '*' ] , $ paginated = false , $ perPage = null ) { $ results = $ paginated ? $ this -> getManyPaginated ( $ perPage , $ columns ) : $ this -> getQuery ( ) -> get ( $ columns ) ; return $ this -> returnResults ( $ results ) ; }
12933	protected function generateContent ( $ type , $ id , $ name , $ language ) { $ content = new Content ( ) ; $ content -> setContentId ( $ id ) ; $ content -> setContentType ( $ type ) ; $ content -> setDeleted ( false ) ; $ content -> setName ( $ name ) ; $ content -> setLanguage ( $ language ) ; $ content -> setStatus ( $ this -> getReference ( 'status-published' ) ) ; $ content -> setVersion ( '1' ) ; $ content -> setSiteId ( '2' ) ; $ date = new \ DateTime ( "now" ) ; $ content -> setVersionName ( $ content -> getName ( ) . '_' . $ date -> format ( "Y-m-d_H:i:s" ) ) ; return $ content ; }
8708	public function select ( $ columns = [ '*' ] ) { parent :: select ( $ columns ) ; $ this -> columns = $ this -> qualifyColumns ( $ this -> columns ) ; return $ this ; }
8838	private function getStatus ( ) : array { $ status = proc_get_status ( $ this -> process ) ; if ( ! $ status [ 'running' ] && is_null ( $ this -> exitCode ) ) { $ this -> exitCode = $ status [ 'exitcode' ] ; } return $ status ; }
4254	public function build ( $ stats ) { $ this -> stats = $ stats ; return '' . $ this -> buildFatal ( ) . $ this -> buildInConsole ( ) . $ this -> buildNotInConsole ( ) ; }
9382	public function getTag ( $ classNames , $ color = null ) { return ArrayData :: create ( [ 'ClassNames' => $ classNames , 'Color' => $ color ] ) -> renderWith ( sprintf ( '%s\Tag' , self :: class ) ) ; }
11726	public function render ( $ filter = null ) : string { if ( empty ( $ this -> output ) ) { extract ( array_merge ( $ this -> vars , View :: $ global_vars ) , EXTR_REFS ) ; ob_start ( ) ; include ( $ this -> view_file ) ; $ this -> output = ob_get_clean ( ) ; } if ( $ filter !== null ) { $ this -> output = call_user_func ( $ filter , $ this -> output ) ; } return $ this -> output ; }
390	public function loadDefaultValues ( $ skipIfSet = true ) { foreach ( static :: getTableSchema ( ) -> columns as $ column ) { if ( $ column -> defaultValue !== null && ( ! $ skipIfSet || $ this -> { $ column -> name } === null ) ) { $ this -> { $ column -> name } = $ column -> defaultValue ; } } return $ this ; }
8259	protected function getResourceAttribute ( $ name , $ resourceOwner ) { $ method = "get" . $ name ; if ( is_callable ( array ( $ resourceOwner , $ method ) ) ) { $ res = $ resourceOwner -> $ method ( ) ; return $ res ; } else { $ resourceArray = $ resourceOwner -> toArray ( ) ; $ res = $ this -> getValueByKey ( $ resourceArray , $ name ) ; return $ res ; } }
7052	public function logoutCurrentUser ( ) { $ this -> getAuthGuard ( ) -> logout ( ) ; \ Session :: remove ( $ this -> originalUserFromLoginAsActionSessionKey ) ; \ Session :: invalidate ( ) ; $ this -> getCmfConfig ( ) -> resetLocale ( ) ; }
1918	public static function findByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")" ) , null , $ arrOptions ) ; }
9584	public function getRouteForRequest ( Request $ request ) { $ method = $ request -> getMethod ( ) ; $ path = $ request -> getPathInfo ( ) ? : '/' ; $ result = $ this -> getDispatcher ( ) -> dispatch ( $ method , $ path ) ; if ( $ result [ 0 ] == \ FastRoute \ Dispatcher :: NOT_FOUND ) { throw new NotFoundHttpException ( "No route match for path $path" ) ; } else if ( $ result [ 0 ] == \ FastRoute \ Dispatcher :: METHOD_NOT_ALLOWED ) { throw new MethodNotAllowedHttpException ( $ result [ 1 ] , "Method $method not allowed for path $path" ) ; } else if ( $ result [ 0 ] !== \ FastRoute \ Dispatcher :: FOUND ) { throw new \ RuntimeException ( 'Unknown result from FastRoute: ' . $ result [ 0 ] ) ; } return $ this -> matchRoute ( $ result [ 1 ] , $ result [ 2 ] , $ request ) ; }
8261	protected function saveAfterLogin ( Request $ httpRequest ) { $ referer = $ httpRequest -> headers -> get ( "referer" , null , true ) ; $ afterLogin = Utils :: getRefererQueryParam ( $ referer , "afterLogin" ) ; if ( $ afterLogin && Utils :: isValidPageId ( $ afterLogin ) ) { $ this -> session -> set ( "afterLogin" , $ afterLogin ) ; } }
8697	protected function validateMandatoryAttribs ( ) { foreach ( static :: $ mandatoryFields as $ field ) { if ( ! array_key_exists ( $ field , $ this -> attributes ) ) { throw new \ SVGCreator \ SVGException ( "The field " . $ field . " does not exist for " . static :: TYPE . "." , 1 ) ; } } }
9216	public function actionDelete ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> isdel = 1 ; $ model -> save ( ) ; return $ this -> redirect ( [ 'index' ] ) ; }
1626	public static function buildKey ( $ key ) { if ( is_numeric ( $ key ) ) { return $ key ; } elseif ( is_string ( $ key ) ) { return ctype_alnum ( $ key ) && StringHelper :: byteLength ( $ key ) <= 32 ? $ key : md5 ( $ key ) ; } elseif ( is_array ( $ key ) ) { if ( count ( $ key ) == 1 ) { return self :: buildKey ( reset ( $ key ) ) ; } ksort ( $ key ) ; $ isNumeric = true ; foreach ( $ key as $ value ) { if ( ! is_numeric ( $ value ) ) { $ isNumeric = false ; } } if ( $ isNumeric ) { return implode ( '-' , $ key ) ; } } return md5 ( json_encode ( $ key , JSON_NUMERIC_CHECK ) ) ; }
10777	private function total_size ( ) { $ arr = array ( "width" => 0 , "height" => 0 ) ; foreach ( $ this -> images as $ image ) { if ( $ arr [ "width" ] < $ image [ "width" ] ) { $ arr [ "width" ] = $ image [ "width" ] ; } $ arr [ "height" ] += $ image [ "height" ] ; } return $ arr ; }
9885	private function writeDefinedNameForNamedRange ( XMLWriter $ objWriter , NamedRange $ pNamedRange ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , $ pNamedRange -> getName ( ) ) ; if ( $ pNamedRange -> getLocalOnly ( ) ) { $ objWriter -> writeAttribute ( 'localSheetId' , $ pNamedRange -> getScope ( ) -> getParent ( ) -> getIndex ( $ pNamedRange -> getScope ( ) ) ) ; } $ range = Coordinate :: splitRange ( $ pNamedRange -> getRange ( ) ) ; $ iMax = count ( $ range ) ; for ( $ i = 0 ; $ i < $ iMax ; ++ $ i ) { $ range [ $ i ] [ 0 ] = '\'' . str_replace ( "'" , "''" , $ pNamedRange -> getWorksheet ( ) -> getTitle ( ) ) . '\'!' . Coordinate :: absoluteReference ( $ range [ $ i ] [ 0 ] ) ; if ( isset ( $ range [ $ i ] [ 1 ] ) ) { $ range [ $ i ] [ 1 ] = Coordinate :: absoluteReference ( $ range [ $ i ] [ 1 ] ) ; } } $ range = Coordinate :: buildRange ( $ range ) ; $ objWriter -> writeRawData ( $ range ) ; $ objWriter -> endElement ( ) ; }
8938	public function updateChangeset ( $ id , $ tags = array ( ) ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <changeset>' . $ tagList . '</changeset> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> changeset ; }
9	public function authorizeOAuth ( $ originUrl ) { if ( ! in_array ( $ originUrl , $ this -> config -> get ( 'gitlab-domains' ) , true ) ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config gitlab.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , trim ( $ output ) , 'oauth2' ) ; return true ; } $ authTokens = $ this -> config -> get ( 'gitlab-token' ) ; if ( isset ( $ authTokens [ $ originUrl ] ) ) { $ this -> io -> setAuthentication ( $ originUrl , $ authTokens [ $ originUrl ] , 'private-token' ) ; return true ; } return false ; }
10209	private function performRequest ( $ curlSession , $ deserializationType = null ) { $ response = curl_exec ( $ curlSession ) ; $ response = $ response ? $ response : null ; try { $ result = new MaileonAPIResult ( $ response , $ curlSession , $ this -> throwException , $ deserializationType ) ; $ this -> printDebugInformation ( $ curlSession , $ result ) ; curl_close ( $ curlSession ) ; return $ result ; } catch ( MaileonAPIException $ e ) { if ( $ this -> debug ) { $ this -> printDebugInformation ( $ curlSession , null , $ this -> throwException ? null : $ e ) ; } curl_close ( $ curlSession ) ; if ( $ this -> throwException ) { throw $ e ; } return null ; } }
7437	public static function handleFatal ( ) { $ error = error_get_last ( ) ; if ( null !== $ error ) { self :: render ( $ error [ "type" ] , $ error [ "message" ] , $ error [ "file" ] , $ error [ "line" ] ) ; } }
4109	public function toOptionArray ( ) { $ options = array ( ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_comment' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Comments' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_opentip' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_tipOnly' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups (border initially invisible)' ) ) ; Mage :: dispatchEvent ( 'aoetemplatehints_hintrenderer_options' , array ( 'options' => & $ options ) ) ; return $ options ; }
3849	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'tableName' ) ) { return ; } $ tableName = strtolower ( $ event -> getValue ( ) ) ; if ( ! strlen ( $ tableName ) ) { throw new \ RuntimeException ( 'Table name not given' ) ; } if ( substr ( $ tableName , 0 , 3 ) !== 'mm_' ) { $ tableName = 'mm_' . $ tableName ; } $ dataProvider = $ event -> getEnvironment ( ) -> getDataProvider ( 'tl_metamodel' ) ; try { if ( ! $ event -> getModel ( ) -> getId ( ) ) { $ this -> tableManipulator -> checkTableDoesNotExist ( $ tableName ) ; } else { $ oldVersion = $ dataProvider -> fetch ( $ dataProvider -> getEmptyConfig ( ) -> setId ( $ event -> getModel ( ) -> getId ( ) ) ) ; if ( $ oldVersion -> getProperty ( 'tableName' ) !== $ event -> getModel ( ) -> getProperty ( 'tableName' ) ) { $ this -> tableManipulator -> checkTableDoesNotExist ( $ tableName ) ; } } } catch ( \ Exception $ exception ) { throw new \ RuntimeException ( $ exception -> getMessage ( ) , $ exception -> getCode ( ) , $ exception ) ; } $ event -> setValue ( $ tableName ) ; }
9224	public function setupToken ( $ token ) { if ( ! empty ( $ token ) ) { $ this -> headers [ 'Authorization' ] = "Bearer $token" ; return true ; } else { if ( $ this -> throw_exceptions ) { throw new CanvasPest_Exception ( 'API authorization token must be a non-zero-length string' , CanvasPest_Exception :: INVALID_TOKEN ) ; } return false ; } }
4293	public function getAbstraction ( & $ mixed , $ method = null , $ hist = array ( ) ) { if ( \ is_array ( $ mixed ) ) { return $ this -> abstractArray -> getAbstraction ( $ mixed , $ method , $ hist ) ; } elseif ( \ is_object ( $ mixed ) ) { return $ this -> abstractObject -> getAbstraction ( $ mixed , $ method , $ hist ) ; } elseif ( \ is_resource ( $ mixed ) || \ strpos ( \ print_r ( $ mixed , true ) , 'Resource' ) === 0 ) { return array ( 'debug' => self :: ABSTRACTION , 'type' => 'resource' , 'value' => \ print_r ( $ mixed , true ) . ': ' . \ get_resource_type ( $ mixed ) , ) ; } }
10781	public function assetFunction ( $ asset , $ serverPath = false ) { $ request = isset ( $ this -> container [ 'request' ] ) ? $ this -> container [ 'request' ] : null ; $ path = \ ltrim ( $ asset , '/\\' ) ; $ assetPath = Utils :: fixPath ( $ this -> container -> getRootDir ( ) . '/' . $ path ) ; if ( ! $ serverPath ) if ( $ request instanceof Request ) $ assetPath = $ request -> getSchemeAndHttpHost ( ) . '/' . $ path ; else $ assetPath = '/' . $ path ; return $ assetPath ; }
1819	public function extractYouTubeId ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> youtube != $ varValue ) { $ matches = array ( ) ; if ( preg_match ( '%(?:youtube(?:-nocookie)?\.com/(?:[^/]+/.+/|(?:v|e(?:mbed)?)/|.*[?&]v=)|youtu\.be/)([^"&?/ ]{11})%i' , $ varValue , $ matches ) ) { $ varValue = $ matches [ 1 ] ; } } return $ varValue ; }
6902	public function url ( $ page = 1 ) { $ page = max ( 1 , ( int ) $ page ) ; if ( $ page === 1 AND ! $ this -> first_page_in_url ) { $ page = NULL ; } switch ( $ this -> current_page_source ) { case 'query_string' : case 'mixed' : return URL :: site ( $ this -> request -> uri ( ) . $ this -> query ( [ $ this -> current_page_source_key => $ page ] ) ) ; case 'route' : return URL :: site ( $ this -> route -> url ( array_merge ( $ this -> route_params , array ( $ this -> current_page_source_key => $ page ) ) ) . $ this -> query ( ) ) ; } return '#' ; }
9222	public function serialize ( ) { $ this -> requestAllPages ( ) ; return serialize ( array ( 'page' => $ this -> page , 'key' => $ this -> key , 'data' => $ this -> data ) ) ; }
3031	public function resumeSession ( AssessmentTestSession $ session ) { $ deliveryExecutionState = $ this -> getSessionState ( $ session ) ; if ( $ deliveryExecutionState === DeliveryExecution :: STATE_PAUSED ) { $ this -> updateTimeReference ( $ session ) ; $ this -> getDeliveryExecution ( $ session ) -> setState ( DeliveryExecution :: STATE_ACTIVE ) ; } }
3036	protected function persistCacheEntry ( $ key ) { $ success = true ; if ( isset ( $ this -> cache [ $ key ] ) ) { $ cache = $ this -> cache [ $ key ] ; switch ( $ cache [ 'state' ] ) { case self :: STATE_PENDING_WRITE : $ success = $ this -> getStorage ( ) -> set ( $ cache [ 'userId' ] , $ cache [ 'callId' ] , $ cache [ 'data' ] ) ; if ( ! $ success ) { throw new \ common_exception_Error ( 'Can\'t write into test runner state storage at ' . static :: class ) ; } $ this -> cache [ $ key ] [ 'state' ] = self :: STATE_ALIGNED ; break ; case self :: STATE_PENDING_DELETE : $ success = $ this -> getStorage ( ) -> del ( $ cache [ 'userId' ] , $ cache [ 'callId' ] ) ; if ( $ success ) { unset ( $ this -> cache [ $ key ] ) ; } break ; } } return $ success ; }
3404	public function lock ( Output $ output ) { if ( ! $ this -> lock ) { return ; } $ this -> lock = $ this -> getApplication ( ) -> getLockFactory ( ) -> createLock ( $ this -> getName ( ) ) ; if ( ! $ this -> lock -> acquire ( ) ) { $ output -> error ( "Another instance of this command (" . $ this -> getName ( ) . ") is currently running" ) ; exit ( Application :: STATUS_LOCKED ) ; } }
3369	private function getClassString ( ClassMetadata $ class ) { $ this -> visitAssociation ( $ class -> getName ( ) ) ; $ className = $ class -> getName ( ) ; $ classText = '[' . str_replace ( '\\' , '.' , $ className ) ; $ fields = [ ] ; $ parent = $ this -> getParent ( $ class ) ; $ parentFields = $ parent ? $ parent -> getFieldNames ( ) : [ ] ; foreach ( $ class -> getFieldNames ( ) as $ fieldName ) { if ( in_array ( $ fieldName , $ parentFields ) ) { continue ; } if ( $ class -> isIdentifier ( $ fieldName ) ) { $ fields [ ] = '+' . $ fieldName ; } else { $ fields [ ] = $ fieldName ; } } if ( ! empty ( $ fields ) ) { $ classText .= '|' . implode ( ';' , $ fields ) ; } $ classText .= ']' ; return $ classText ; }
10724	public function getNumRows ( ) { $ builtSql = SqlBuilder :: buildRowCountSql ( $ this ) ; if ( is_array ( $ builtSql ) ) { $ preparedSth = $ this -> connect ( ) -> prepare ( $ builtSql [ 0 ] ) ; $ boundSth = StatementBuilder :: bindValues ( $ preparedSth , $ builtSql [ 1 ] ) ; $ boundSth -> execute ( ) ; } else { $ boundSth = $ this -> connect ( ) -> query ( $ builtSql ) ; } $ result = $ boundSth -> fetch ( PDO :: FETCH_ASSOC ) ; return ( int ) $ result [ 'total_count' ] ; }
804	private function hasReturnTypeHint ( Tokens $ tokens , $ index ) { $ endFuncIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ ')' ] ) ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ endFuncIndex ) ; return $ tokens [ $ nextIndex ] -> isGivenKind ( CT :: T_TYPE_COLON ) ; }
7604	protected function renderAddOn ( $ aAddOnOptions ) { if ( empty ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( 'Addon options are empty' ) ; } if ( $ aAddOnOptions instanceof ElementInterface ) { $ aAddOnOptions = array ( 'element' => $ aAddOnOptions ) ; } elseif ( is_scalar ( $ aAddOnOptions ) ) { $ aAddOnOptions = array ( 'text' => $ aAddOnOptions ) ; } elseif ( ! is_array ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( sprintf ( 'Addon options expects an array or a scalar value, "%s" given' , is_object ( $ aAddOnOptions ) ? get_class ( $ aAddOnOptions ) : gettype ( $ aAddOnOptions ) ) ) ; } $ sMarkup = '' ; $ sAddonTagName = 'span' ; $ sAddonClass = '' ; if ( ! empty ( $ aAddOnOptions [ 'text' ] ) ) { if ( ! is_scalar ( $ aAddOnOptions [ 'text' ] ) ) { throw new InvalidArgumentException ( sprintf ( '"text" option expects a scalar value, "%s" given' , is_object ( $ aAddOnOptions [ 'text' ] ) ? get_class ( $ aAddOnOptions [ 'text' ] ) : gettype ( $ aAddOnOptions [ 'text' ] ) ) ) ; } elseif ( ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sMarkup .= $ oTranslator -> translate ( $ aAddOnOptions [ 'text' ] , $ this -> getTranslatorTextDomain ( ) ) ; } else { $ sMarkup .= $ aAddOnOptions [ 'text' ] ; } $ sAddonClass .= ' input-group-addon' ; } elseif ( ! empty ( $ aAddOnOptions [ 'element' ] ) ) { if ( is_array ( $ aAddOnOptions [ 'element' ] ) || ( $ aAddOnOptions [ 'element' ] instanceof Traversable && ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ aAddOnOptions [ 'element' ] = $ oFactory -> create ( $ aAddOnOptions [ 'element' ] ) ; } elseif ( ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( '"element" option expects an instanceof Zend\Form\ElementInterface, "%s" given' , is_object ( $ aAddOnOptions [ 'element' ] ) ? get_class ( $ aAddOnOptions [ 'element' ] ) : gettype ( $ aAddOnOptions [ 'element' ] ) ) ) ; } $ aAddOnOptions [ 'element' ] -> setOptions ( array_merge ( $ aAddOnOptions [ 'element' ] -> getOptions ( ) , array ( 'disable-twb' => true ) ) ) ; $ sMarkup .= $ this -> render ( $ aAddOnOptions [ 'element' ] ) ; if ( $ aAddOnOptions [ 'element' ] instanceof Button ) { $ sAddonClass .= ' input-group-btn' ; $ sAddonTagName = 'div' ; } else { $ sAddonClass .= ' input-group-addon' ; } } return sprintf ( static :: $ addonFormat , $ sAddonTagName , trim ( $ sAddonClass ) , $ sMarkup , $ sAddonTagName ) ; }
11131	public static function getRootBackslash ( $ pathname ) { if ( $ pathname [ 0 ] == '\\' ) { $ pathname = substr ( $ pathname , 1 ) ; } $ arr = explode ( '\\' , $ pathname ) ; if ( count ( $ arr ) > 1 ) { return $ arr [ 0 ] ; } return '' ; }
901	public function getMethodAttributes ( $ index ) { $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_FUNCTION ) ) { throw new \ LogicException ( sprintf ( 'No T_FUNCTION at given index %d, got %s.' , $ index , $ token -> getName ( ) ) ) ; } $ attributes = [ 'visibility' => null , 'static' => false , 'abstract' => false , 'final' => false , ] ; for ( $ i = $ index ; $ i >= 0 ; -- $ i ) { $ tokenIndex = $ tokens -> getPrevMeaningfulToken ( $ i ) ; $ i = $ tokenIndex ; $ token = $ tokens [ $ tokenIndex ] ; if ( $ token -> isGivenKind ( T_STATIC ) ) { $ attributes [ 'static' ] = true ; continue ; } if ( $ token -> isGivenKind ( T_FINAL ) ) { $ attributes [ 'final' ] = true ; continue ; } if ( $ token -> isGivenKind ( T_ABSTRACT ) ) { $ attributes [ 'abstract' ] = true ; continue ; } if ( $ token -> isGivenKind ( T_PRIVATE ) ) { $ attributes [ 'visibility' ] = T_PRIVATE ; continue ; } if ( $ token -> isGivenKind ( T_PROTECTED ) ) { $ attributes [ 'visibility' ] = T_PROTECTED ; continue ; } if ( $ token -> isGivenKind ( T_PUBLIC ) ) { $ attributes [ 'visibility' ] = T_PUBLIC ; continue ; } break ; } return $ attributes ; }
2836	public function getLayoutUpdates ( ) { if ( $ this -> uncompressedLayoutUpdates === null ) { $ this -> uncompressedLayoutUpdates = $ this -> layoutUpdates ? json_decode ( gzuncompress ( $ this -> layoutUpdates ) , true ) : array ( ) ; } return $ this -> uncompressedLayoutUpdates ; }
2143	public function generate ( $ objRootPage = null ) { global $ objPage ; $ obj403 = $ this -> prepare ( $ objRootPage ) ; $ objPage = $ obj403 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 403 Forbidden' ) ; $ objHandler -> generate ( $ objPage ) ; }
9680	public function getColumnDisplayName ( $ columnName ) { return isset ( $ this -> columnDisplayNames [ $ columnName ] ) ? $ this -> columnDisplayNames [ $ columnName ] : $ columnName ; }
6823	protected function getShipmentAccountNumber ( TaxRuleInterface $ rule , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_SHIPPING ) { continue ; } if ( $ account -> getTaxRule ( ) !== $ rule ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No shipment account number configured for tax rule '%s' (%s)" , $ rule -> getName ( ) , $ origin ) ) ; }
7713	function FindEndTag ( $ Encaps = false ) { if ( is_null ( $ this -> SelfClosing ) ) { $ pe = $ this -> PosEnd ; $ SelfClosing = ( substr ( $ this -> Txt , $ pe - 1 , 1 ) == '/' ) ; if ( ! $ SelfClosing ) { if ( $ Encaps ) { $ loc = clsTinyButStrong :: f_Xml_FindTag ( $ this -> Txt , $ this -> FindName ( ) , null , $ pe , true , - 1 , false , false ) ; if ( $ loc === false ) return false ; $ this -> pET_PosBeg = $ loc -> PosBeg ; $ this -> PosEnd = $ loc -> PosEnd ; } else { $ pe = clsTinyButStrong :: f_Xml_FindTagStart ( $ this -> Txt , $ this -> FindName ( ) , false , $ pe , true , true ) ; if ( $ pe === false ) return false ; $ this -> pET_PosBeg = $ pe ; $ pe = strpos ( $ this -> Txt , '>' , $ pe ) ; if ( $ pe === false ) return false ; $ this -> PosEnd = $ pe ; } } $ this -> SelfClosing = $ SelfClosing ; } return true ; }
10490	public function neg ( ) { if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value * - 1 ) ; }
5932	public function setEndDate ( $ endDate ) { if ( $ endDate instanceof DateTime ) { $ this -> endDate = $ endDate ; } else { try { $ this -> endDate = new DateTime ( $ endDate ) ; } catch ( \ Exception $ e ) { $ this -> endDate = null ; } } return $ this ; }
1846	public static function unixToJd ( $ tstamp ) { list ( $ year , $ month , $ day ) = explode ( ',' , date ( 'Y,m,d' , $ tstamp ) ) ; $ year += ( $ year < 0 ? 4801 : 4800 ) ; if ( $ month > 2 ) { $ month -= 3 ; } else { $ month += 9 ; -- $ year ; } $ sdn = floor ( ( floor ( $ year / 100 ) * 146097 ) / 4 ) ; $ sdn += floor ( ( ( $ year % 100 ) * 1461 ) / 4 ) ; $ sdn += floor ( ( $ month * 153 + 2 ) / 5 ) ; $ sdn += $ day - 32045 ; return $ sdn ; }
11429	public function run ( Request $ request ) { $ dispatcher = $ this -> router -> getDispatcher ( ) ; $ routeInfo = $ dispatcher -> dispatch ( $ request -> server ( 'REQUEST_METHOD' ) , $ request -> server ( 'REQUEST_URI_PATH' ) ) ; switch ( $ routeInfo [ 0 ] ) { case Dispatcher :: NOT_FOUND : $ routeInfo = $ this -> getNotFoundRoute ( $ dispatcher ) ; break ; case Dispatcher :: METHOD_NOT_ALLOWED : $ routeInfo = $ this -> runMethodNotAllowed ( $ dispatcher ) ; break ; case Dispatcher :: FOUND : break ; } $ response = $ this -> runRoute ( $ routeInfo ) ; $ response -> send ( ) ; }
606	private function tokenizeDelimitedString ( & $ length ) { $ isIdentifier = $ this -> isIdentifier ( $ length , $ content ) ; $ isStringLiteral = ! $ isIdentifier && $ this -> isStringLiteral ( $ length , $ content ) ; if ( ! $ isIdentifier && ! $ isStringLiteral ) { return false ; } $ this -> addTokenFromBuffer ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => $ isIdentifier ? SqlToken :: TYPE_IDENTIFIER : SqlToken :: TYPE_STRING_LITERAL , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; return true ; }
4979	public function get ( $ form , $ options = null , $ params = null ) { if ( ! is_object ( $ form ) ) { $ form = $ this -> formElementManager -> get ( $ form , $ options ) ; } $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; $ hydrator = $ form -> getHydrator ( ) ; $ data = $ hydrator -> extract ( $ params ) ; $ form -> setData ( $ data ) ; $ hydrator -> hydrate ( $ data , $ params ) ; return $ form ; }
1939	public function clearOptInData ( Contao \ DataContainer $ dc ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET addedOn='' WHERE id=?" ) -> execute ( $ dc -> id ) ; }
8406	private function getModelName ( ) { if ( isset ( $ this -> class ) ) { return $ this -> class ; } if ( isset ( $ this -> model ) ) { $ rClass = new \ ReflectionClass ( $ this -> model ) ; return $ rClass -> getShortName ( ) ; } return 'Icon' ; }
1142	public function availableOptionValues ( ) { $ options = [ ] ; foreach ( $ this -> selector -> getOptions ( ) as $ option ) { $ options [ ] = $ option -> getAttribute ( 'value' ) ; } return $ options ; }
5584	public function click ( $ label ) { $ raw = $ this -> clickSubmit ( $ label ) ; if ( ! $ raw ) { $ raw = $ this -> clickLink ( $ label ) ; } if ( ! $ raw ) { $ raw = $ this -> clickImage ( $ label ) ; } return $ raw ; }
3406	public function loadCommands ( string $ path , string $ namespace = "" , string $ suffix = "Command" ) : Application { $ commands = [ ] ; $ realpath = ( string ) realpath ( $ path ) ; $ finder = ( new Finder ( ) ) -> files ( ) -> in ( $ path ) -> name ( "/[A-Z].*{$suffix}.php/" ) ; foreach ( $ finder as $ file ) { $ filename = ( string ) $ file -> getRealPath ( ) ; require_once $ filename ; $ class = $ filename ; $ class = str_replace ( $ realpath , "" , $ class ) ; $ class = str_replace ( ".php" , "" , $ class ) ; $ class = str_replace ( "/" , "\\" , $ class ) ; $ command = $ class ; if ( substr ( $ command , 0 , 1 ) == "\\" ) { $ command = substr ( $ command , 1 ) ; } $ command = ( string ) preg_replace_callback ( "/^([A-Z])(.*){$suffix}$/" , function ( $ match ) { return strtolower ( $ match [ 1 ] ) . $ match [ 2 ] ; } , $ command ) ; $ command = preg_replace_callback ( "/(\\\\)?([A-Z])/" , function ( $ match ) { $ result = ( $ match [ 1 ] ) ? ":" : "-" ; $ result .= strtolower ( $ match [ 2 ] ) ; return $ result ; } , $ command ) ; $ class = $ namespace . $ class ; $ reflected = new \ ReflectionClass ( $ class ) ; if ( ! $ reflected -> isInstantiable ( ) ) { continue ; } $ commands [ ] = new $ class ( $ command ) ; } if ( count ( $ commands ) < 1 ) { throw new \ InvalidArgumentException ( "No commands were found in the path (" . $ path . ")" ) ; } $ this -> addCommands ( $ commands ) ; return $ this ; }
8310	public function standardizeUrlFormat ( & $ rules , $ pageUrl ) { if ( ! is_string ( $ pageUrl ) || $ pageUrl === "" || ! is_array ( $ rules ) || ! array_key_exists ( $ pageUrl , $ rules ) ) { return ; } $ oldIndex = $ pageUrl ; if ( $ pageUrl [ 0 ] !== '/' ) { $ pageUrl = '/' . $ pageUrl ; } $ len = strlen ( $ pageUrl ) ; if ( $ len > 1 && $ pageUrl [ $ len - 1 ] === '/' ) { $ pageUrl = rtrim ( $ pageUrl , '/' ) ; } if ( $ oldIndex !== $ pageUrl ) { $ rules [ $ pageUrl ] = $ rules [ $ oldIndex ] ; unset ( $ rules [ $ oldIndex ] ) ; } }
10860	protected function createObject ( string $ typeName , ? bool $ nullable = false , ? bool $ checkCycles = true , ? bool $ treatAsNotFound = true ) : ? object { if ( $ checkCycles ) { $ this -> underConstruction [ $ typeName ] = true ; } try { if ( ! isset ( $ this -> typeCache [ $ typeName ] ) ) { if ( \ class_exists ( $ typeName ) || \ interface_exists ( $ typeName , false ) ) { $ this -> typeCache [ $ typeName ] = new \ ReflectionClass ( $ typeName ) ; } else { $ this -> typeCache [ $ typeName ] = false ; } } if ( $ this -> typeCache [ $ typeName ] === false ) { if ( $ nullable ) { return null ; } if ( $ treatAsNotFound ) { throw new NotFoundException ( \ sprintf ( 'Cannot load type: %s' , $ typeName ) ) ; } throw new ContainerException ( \ sprintf ( 'Cannot load type: %s' , $ typeName ) ) ; } if ( ! $ this -> typeCache [ $ typeName ] -> isInstantiable ( ) ) { if ( $ nullable ) { return null ; } throw new NotFoundException ( \ sprintf ( 'Type is not instantiable: %s' , $ typeName ) ) ; } if ( isset ( $ this -> constructorCache [ $ typeName ] ) ) { $ con = $ this -> constructorCache [ $ typeName ] ; } else { $ con = $ this -> constructorCache [ $ typeName ] = $ this -> typeCache [ $ typeName ] -> getConstructor ( ) ? : false ; } return ( $ con === false ) ? new $ typeName ( ) : new $ typeName ( ... $ this -> populateArguments ( $ con , null , $ typeName ) ) ; } finally { if ( $ checkCycles ) { unset ( $ this -> underConstruction [ $ typeName ] ) ; } } }
2795	public function getTempDirectory ( ) { if ( is_null ( $ this -> tempDirectory ) ) { $ root = sys_get_temp_dir ( ) ; if ( ! is_dir ( $ root . '/humbug' ) ) { mkdir ( $ root . '/humbug' , 0777 , true ) ; } $ this -> tempDirectory = $ root . '/humbug' ; } return $ this -> tempDirectory ; }
3549	protected function registerRepository ( ) { $ this -> app -> singleton ( CachingRepository :: class , function ( Container $ app ) { $ repo = new GitHubRepository ( GuzzleFactory :: make ( ) , $ app -> config -> get ( 'emoji.token' ) ) ; $ cache = $ app -> cache -> store ( $ app -> config -> get ( 'emoji.connection' ) ) ; $ key = $ app -> config -> get ( 'emoji.key' , 'emoji' ) ; $ life = ( int ) $ app -> config -> get ( 'emoji.life' , 10080 ) ; return new CachingRepository ( $ repo , $ cache , $ key , $ life ) ; } ) ; $ this -> app -> alias ( CachingRepository :: class , RepositoryInterface :: class ) ; }
5091	private function asScalarSubQuery ( $ callback , $ default = false ) { $ sql = $ this -> sql ; $ this -> sql = $ callback ( $ sql ) ; $ result = $ this -> queryScalar ( null ) ; $ this -> sql = $ sql ; return ( is_null ( $ result ) ? $ default : $ result ) ; }
2701	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ modules = $ this -> manifest -> getAllModlyManifests ( ) ; if ( ! $ modules ) { return $ result -> setData ( [ 'status' => false , 'modules' => '' , 'msg' => 'Use the Refresh button to get the latest modules.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'modules' => $ modules ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
6755	private static function createCopy ( string $ from , string $ fromFilename , string $ to , string $ toFilename ) { if ( file_exists ( "$to/$toFilename" ) ) { unlink ( "$to/$toFilename" ) ; } copy ( realpath ( $ from ) . "/$fromFilename" , realpath ( $ to ) . "/$toFilename" ) ; echo '> * Copy origin - ' . realpath ( $ from ) . "/$toFilename" . PHP_EOL ; echo '> * Copy destination - ' . realpath ( $ to ) . "/$toFilename" . PHP_EOL ; }
722	public function json ( ) { if ( version_compare ( PHP_VERSION , '5.6' , '<' ) && $ this -> getDb ( ) -> getDriverName ( ) === 'mysql' ) { throw new \ yii \ base \ Exception ( 'JSON column type is not supported in PHP < 5.6' ) ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_JSON ) ; }
12117	public static function displayConsoleException ( \ Throwable $ Throwable ) { ob_start ( ) ; echo PHP_EOL . ' ' ; echo ( ( $ Throwable instanceof PHPAssertionFailed ) ? 'Assertion Failed' : 'Uncaught ' . self :: getShortName ( get_class ( $ Throwable ) ) ) ; echo ' <' . basename ( $ Throwable -> getFile ( ) ) . ':' . $ Throwable -> getLine ( ) . '>' ; echo PHP_EOL . PHP_EOL . ' ' ; if ( $ Throwable instanceof PHPAssertionFailed ) { $ message = $ Throwable -> getExpression ( ) ; if ( $ message == '' ) { $ message = 'false' ; } } else { $ message = $ Throwable -> getMessage ( ) ; } echo wordwrap ( $ message , self :: CONSOLE_WIDTH - 2 , PHP_EOL . ' ' ) ; echo PHP_EOL . PHP_EOL . ' Stack Trace:' . PHP_EOL . PHP_EOL ; if ( $ Throwable instanceof BaseException || $ Throwable instanceof PHPErrorException ) { $ trace = $ Throwable -> getStackTrace ( ) ; } else { $ trace = array_reverse ( $ Throwable -> getTrace ( ) ) ; } $ trace_empty = [ 'class' => '' , 'type' => '' , 'function' => '' , 'file' => '{unknown}' , 'line' => 0 ] ; foreach ( $ trace as $ key => $ trace_item ) { $ trace_item = array_merge ( $ trace_empty , $ trace_item ) ; $ trace_item [ 'file' ] = basename ( $ trace_item [ 'file' ] ) ; if ( $ trace_item [ 'function' ] != '{closure}' ) { $ trace_item [ 'function' ] .= '()' ; } $ key ++ ; echo str_pad ( " $key. " , 6 , ' ' ) ; echo self :: getShortName ( $ trace_item [ 'class' ] ) . $ trace_item [ 'type' ] . $ trace_item [ 'function' ] ; echo " <{$trace_item['file']}:{$trace_item['line']}>" . PHP_EOL ; } return ob_get_clean ( ) ; }
8220	protected function getSubnet ( $ ip , $ netmask ) { $ binString = @ inet_pton ( $ ip ) ; if ( $ binString === false ) { throw new \ InvalidArgumentException ( "Not a valid IP address." ) ; } $ byteLen = mb_strlen ( $ binString , "8bit" ) ; if ( ! is_int ( $ netmask ) || $ netmask < 0 || $ netmask > $ byteLen * 8 ) { throw new \ InvalidArgumentException ( "Not a valid netmask." ) ; } for ( $ byte = $ byteLen - 1 ; ( $ byte + 1 ) * 8 > $ netmask ; -- $ byte ) { $ maskLen = min ( 8 , ( $ byte + 1 ) * 8 - $ netmask ) ; $ mask = ( ~ ( ( 1 << $ maskLen ) - 1 ) ) & 0xff ; $ maskedByte = $ mask & unpack ( 'C' , $ binString [ $ byte ] ) [ 1 ] ; $ binString [ $ byte ] = pack ( 'C' , $ maskedByte ) ; } return inet_ntop ( $ binString ) . '/' . $ netmask ; }
12071	private function getCfgParamsByRanks ( ) { $ asParams = 'pbhcp' ; $ asRank = 'pbhr' ; $ tblParams = $ this -> resource -> getTableName ( CfgParam :: ENTITY_NAME ) ; $ tblRank = $ this -> resource -> getTableName ( Rank :: ENTITY_NAME ) ; $ query = $ this -> conn -> select ( ) ; $ query -> from ( [ $ asParams => $ tblParams ] ) ; $ on = "$asParams." . CfgParam :: A_RANK_ID . "=$asRank." . Rank :: A_ID ; $ cols = [ Rank :: A_CODE ] ; $ query -> joinLeft ( [ $ asRank => $ tblRank ] , $ on , $ cols ) ; $ entries = $ this -> conn -> fetchAll ( $ query ) ; $ result = [ ] ; foreach ( $ entries as $ entry ) { $ rankCode = $ entry [ Rank :: A_CODE ] ; $ rankScheme = $ entry [ CfgParam :: A_SCHEME ] ; $ result [ $ rankCode ] [ $ rankScheme ] = $ entry ; } return $ result ; }
3277	public function getKeys ( ) : array { $ keys = [ ] ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { $ keys [ ] = $ line -> getKey ( ) ; } return $ keys ; }
7057	public function hasData ( $ key = null ) { if ( ! is_null ( $ key ) ) { return isset ( $ this -> data [ $ key ] ) ; } return ! empty ( $ this -> data ) ; }
8110	public static function start ( ) { $ compatibility = [ self :: SUBSITES => null , ] ; if ( ClassInfo :: exists ( Subsite :: class ) ) { $ compatibility [ self :: SUBSITES ] = Subsite :: $ disable_subsite_filter ; Subsite :: disable_subsite_filter ( true ) ; } return $ compatibility ; }
10515	public function inc ( $ key , $ expire = 0 ) { $ this -> getLock ( $ key ) ; $ this -> set ( $ key , ( int ) $ this -> get ( $ key ) + 1 ) ; $ this -> releaseLock ( $ key ) ; return true ; }
5127	public function readQTime ( ) { $ msec = $ this -> readUInt ( ) ; $ time = strtotime ( 'midnight' ) + $ msec / 1000 ; $ dt = \ DateTime :: createFromFormat ( 'U.u' , sprintf ( '%.6F' , $ time ) ) ; $ dt -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; return $ dt ; }
7210	public function getAutoLoginUrl ( array $ autoUrl , array $ redirectUrl = null , string $ expireInterval = '1 day' , bool $ addRememberMeCookie = true ) : string { $ autoUrl [ '?' ] [ 't' ] = $ this -> generateLoginToken ( $ redirectUrl , $ expireInterval , $ addRememberMeCookie ) ; $ url = Router :: url ( $ autoUrl , true ) ; $ urlLength = strlen ( $ url ) ; if ( strlen ( $ url ) > 2080 ) { throw new \ Exception ( 'Generated url "' . $ url . '" is too long' ) ; } return $ url ; }
8160	public function confirm ( ) { $ this -> status = User :: STATUS_ACTIVE ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
9502	public function runPeridot ( InputInterface $ input , OutputInterface $ output ) { global $ argv ; $ command = $ this -> joinCommand ( $ argv ) ; $ process = new Process ( $ command ) ; $ process -> run ( function ( $ type , $ buffer ) use ( $ output ) { $ buffer = preg_replace ( '/\[([\d]{1,2})m/' , "\033[$1m" , $ buffer ) ; $ output -> write ( $ buffer ) ; } ) ; }
10903	public function delete ( ) : bool { return ( bool ) $ this -> medoo -> delete ( $ this -> getTable ( ) , [ 'id' => $ this -> getId ( ) ] ) ; }
10457	public function to ( Uom $ uom ) { $ conversionFactor = Uom :: getConversionFactor ( $ this -> getUom ( ) , $ uom ) ; return new static ( $ this -> getAmount ( ) -> multiply ( $ conversionFactor ) , $ uom ) ; }
1735	public function getProvisionUri ( User $ user , Request $ request ) : string { $ issuer = rawurlencode ( $ request -> getSchemeAndHttpHost ( ) ) ; return sprintf ( 'otpauth://totp/%s:%s?secret=%s&issuer=%s' , $ issuer , rawurlencode ( $ user -> getUsername ( ) ) . '@' . $ issuer , $ this -> getUpperUnpaddedSecretForUser ( $ user ) , $ issuer ) ; }
6534	public function run ( ) { if ( ( $ exception = Yii :: $ app -> getErrorHandler ( ) -> exception ) === null ) { return '' ; } if ( $ exception instanceof \ HttpException ) { $ code = $ exception -> statusCode ; } else { $ code = $ exception -> getCode ( ) ; } if ( $ exception instanceof Exception ) { $ name = $ exception -> getName ( ) ; } else { $ name = $ this -> defaultName ? : Yii :: t ( 'yii' , 'Error' ) ; } if ( $ code ) { $ name .= " (#$code)" ; } if ( $ exception instanceof UserException ) { $ message = $ exception -> getMessage ( ) ; } else { $ message = $ this -> defaultMessage ? : Yii :: t ( 'yii' , 'An internal server error occurred.' ) ; } if ( Yii :: $ app -> getRequest ( ) -> getIsAjax ( ) ) { $ rr = new RequestResponse ( ) ; $ rr -> success = false ; $ rr -> message = "$name: $message" ; return ( array ) $ rr ; } else { if ( \ Yii :: $ app -> user -> can ( CmsManager :: PERMISSION_ADMIN_ACCESS ) ) { $ this -> controller -> layout = \ Yii :: $ app -> cms -> moduleAdmin -> layout ; return $ this -> controller -> render ( '@app/views/error/error' , [ 'message' => nl2br ( Html :: encode ( $ message ) ) ] ) ; } else { $ this -> controller -> layout = '@app/views/layouts/unauthorized' ; return $ this -> controller -> render ( '@app/views/error/unauthorized-403' , [ 'message' => nl2br ( Html :: encode ( $ message ) ) ] ) ; } } }
730	public function run ( ) { if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id ) ; } $ model = new $ this -> modelClass ( [ 'scenario' => $ this -> scenario , ] ) ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> setStatusCode ( 201 ) ; $ id = implode ( ',' , array_values ( $ model -> getPrimaryKey ( true ) ) ) ; $ response -> getHeaders ( ) -> set ( 'Location' , Url :: toRoute ( [ $ this -> viewAction , 'id' => $ id ] , true ) ) ; } elseif ( ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to create the object for unknown reason.' ) ; } return $ model ; }
12879	public function render ( ) { $ plugins = $ this -> pluginManager -> getBlockPlugins ( ) ; $ toolbar = array ( ) ; $ left [ ] = $ this -> twig -> render ( "RedKiteCms/Resources/views/Editor/Toolbar/_toolbar_left_buttons.html.twig" ) ; $ right [ ] = $ this -> twig -> render ( "RedKiteCms/Resources/views/Editor/Toolbar/_toolbar_right_buttons.html.twig" ) ; foreach ( $ plugins as $ plugin ) { if ( ! $ plugin -> hasToolbar ( ) ) { continue ; } $ left [ ] = $ this -> addButtons ( $ plugin , 'left' ) ; $ right [ ] = $ this -> addButtons ( $ plugin , 'right' ) ; } $ toolbar [ "left" ] = implode ( "\n" , $ left ) ; $ toolbar [ "right" ] = implode ( "\n" , $ right ) ; return $ toolbar ; }
3629	protected static function secureTouch ( $ fname ) { if ( file_exists ( $ fname ) ) { return ; } $ temp = tempnam ( sys_get_temp_dir ( ) , 'NEST' ) ; rename ( $ temp , $ fname ) ; }
11813	public function lists ( $ type , $ offset = 0 , $ count = 20 ) { $ params = [ 'type' => $ type , 'offset' => intval ( $ offset ) , 'count' => min ( 20 , $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_LISTS , $ params ] ) ; }
6257	public function authorize ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; if ( ! isset ( $ user [ $ roleField ] ) ) { throw new RuntimeException ( sprintf ( 'The role field `%s` does not exist!' , $ roleField ) ) ; } if ( is_string ( $ user [ $ roleField ] ) ) { $ user [ $ roleField ] = array ( $ user [ $ roleField ] ) ; } if ( $ this -> authorizeByPrefix ( $ user [ $ roleField ] , $ request ) ) { return true ; } if ( $ this -> authorizeByControllerAndAction ( $ user , $ request ) ) { return true ; } return false ; }
12361	public function getPublisherForMessage ( Message $ message ) { $ attributes = $ message -> getAttributes ( ) ; if ( ! isset ( $ attributes [ 'headers' ] ) || ! isset ( $ attributes [ 'headers' ] [ $ this -> headerName ] ) ) { throw MissingPublisherException :: noHeaderInMessage ( $ message , $ this -> headerName ) ; } $ value = $ attributes [ 'headers' ] [ $ this -> headerName ] ; foreach ( $ this -> valueMap as $ hash => $ values ) { if ( ! in_array ( $ value , $ values , true ) ) { continue ; } return $ this -> publishers [ $ hash ] ; } throw MissingPublisherException :: noKnownPublisherFor ( $ message ) ; }
2467	private function setImpersonatedLogout ( ) { $ token = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ impersonatorUser = null ; foreach ( $ token -> getRoles ( ) as $ role ) { if ( $ role instanceof SwitchUserRole ) { $ impersonatorUser = $ role -> getSource ( ) -> getUsername ( ) ; break ; } } if ( ! $ impersonatorUser ) { return ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ firewallMap = System :: getContainer ( ) -> get ( 'security.firewall.map' ) ; if ( ( $ firewallConfig = $ firewallMap -> getFirewallConfig ( $ request ) ) === null || ( $ switchUserConfig = $ firewallConfig -> getSwitchUser ( ) ) === null ) { return ; } $ arrParams = array ( 'do' => 'user' , urlencode ( $ switchUserConfig [ 'parameter' ] ) => SwitchUserListener :: EXIT_VALUE ) ; $ this -> Template -> logout = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'switchBT' ] , $ impersonatorUser ) ; $ this -> Template -> logoutLink = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_backend' , $ arrParams ) ; }
1421	protected function createBelongsToIdentity ( Model $ model , $ relationshipKey ) { $ relation = $ model -> { $ relationshipKey } ( ) ; if ( ! $ relation instanceof BelongsTo ) { throw new RuntimeException ( sprintf ( 'Expecting %s on %s to be a belongs-to relationship.' , $ relationshipKey , get_class ( $ model ) ) ) ; } $ foreignKey = method_exists ( $ relation , 'getForeignKeyName' ) ? $ relation -> getForeignKeyName ( ) : $ relation -> getForeignKey ( ) ; $ id = $ model -> { $ foreignKey } ; if ( is_null ( $ id ) ) { return null ; } $ ownerKey = method_exists ( $ relation , 'getOwnerKeyName' ) ? $ relation -> getOwnerKeyName ( ) : $ relation -> getOwnerKey ( ) ; $ related = $ relation -> getRelated ( ) -> replicate ( ) ; $ related -> { $ ownerKey } = $ id ; return $ related ; }
7554	protected function match_filters ( $ conditions , $ custom_filters = array ( ) ) { foreach ( $ conditions as $ c ) { $ c [ 'filter' ] = strtolower ( $ c [ 'filter' ] ) ; if ( isset ( $ this -> filter_map [ $ c [ 'filter' ] ] ) ) { if ( ! $ this -> { $ this -> filter_map [ $ c [ 'filter' ] ] } ( $ c [ 'params' ] ) ) { return false ; } } elseif ( isset ( $ custom_filters [ $ c [ 'filter' ] ] ) ) { if ( ! call_user_func ( $ custom_filters [ $ c [ 'filter' ] ] , $ this , $ c [ 'params' ] ) ) { return false ; } } else { trigger_error ( 'Unknown filter "' . $ c [ 'filter' ] . '"!' ) ; return false ; } } return true ; }
12118	public function getParam ( $ key , $ default = null ) { $ param = parent :: getParam ( $ key , $ default ) ; if ( is_string ( $ param ) ) { return trim ( $ param ) ; } return $ param ; }
10992	public function splitName ( string $ defaultExtension = "" ) : array { $ filename = basename ( $ this -> path ) ; $ extpos = strrpos ( $ filename , "." ) ; if ( $ extpos === false || $ extpos === 0 ) { $ name = $ filename ; $ ext = $ defaultExtension ; } else { $ name = substr ( $ filename , 0 , $ extpos ) ; $ ext = substr ( $ filename , $ extpos + 1 ) ; } return [ $ name , $ ext ] ; }
8482	public static function getOS ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Caption FROM Win32_OperatingSystem" ) as $ os ) { return $ os -> Caption ; } return "Windows" ; }
891	public function setTypes ( array $ types ) { $ pattern = '/' . preg_quote ( $ this -> getTypesContent ( ) , '/' ) . '/' ; $ this -> lines [ 0 ] -> setContent ( Preg :: replace ( $ pattern , implode ( '|' , $ types ) , $ this -> lines [ 0 ] -> getContent ( ) , 1 ) ) ; $ this -> clearCache ( ) ; }
9020	public function getUniqueWords ( $ string ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ words = $ analysis -> getKeyValuesByFrequency ( ) ; return array_unique ( array_keys ( $ words ) ) ; }
1028	private function resolveField ( ObjectType $ parentType , $ source , $ fieldNodes , $ path ) { $ exeContext = $ this -> exeContext ; $ fieldNode = $ fieldNodes [ 0 ] ; $ fieldName = $ fieldNode -> name -> value ; $ fieldDef = $ this -> getFieldDef ( $ exeContext -> schema , $ parentType , $ fieldName ) ; if ( ! $ fieldDef ) { return self :: $ UNDEFINED ; } $ returnType = $ fieldDef -> getType ( ) ; $ info = new ResolveInfo ( $ fieldName , $ fieldNodes , $ returnType , $ parentType , $ path , $ exeContext -> schema , $ exeContext -> fragments , $ exeContext -> rootValue , $ exeContext -> operation , $ exeContext -> variableValues ) ; if ( $ fieldDef -> resolveFn !== null ) { $ resolveFn = $ fieldDef -> resolveFn ; } elseif ( $ parentType -> resolveFieldFn !== null ) { $ resolveFn = $ parentType -> resolveFieldFn ; } else { $ resolveFn = $ this -> exeContext -> fieldResolver ; } $ context = $ exeContext -> contextValue ; $ result = $ this -> resolveOrError ( $ fieldDef , $ fieldNode , $ resolveFn , $ source , $ context , $ info ) ; $ result = $ this -> completeValueCatchingError ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; return $ result ; }
8526	public function listFinancialEventGroups ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroups' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10146	private function readStyle ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ ixfe = self :: getUInt2d ( $ recordData , 0 ) ; $ xfIndex = ( 0x0FFF & $ ixfe ) >> 0 ; $ isBuiltIn = ( bool ) ( ( 0x8000 & $ ixfe ) >> 15 ) ; if ( $ isBuiltIn ) { $ builtInId = ord ( $ recordData [ 2 ] ) ; switch ( $ builtInId ) { case 0x00 : break ; default : break ; } } } }
8013	protected function getBasicOptions ( ) { $ options = array ( ) ; $ options [ ] = '-encoding UTF-8' ; if ( $ this -> _asHtml ) { $ options [ ] = '-html' ; } if ( $ this -> _toConsole ) { $ options [ ] = '-console' ; } return join ( ' ' , $ options ) ; }
6805	private function generate ( $ class , array $ names , $ defaultCode ) { $ repository = $ this -> manager -> getRepository ( $ class ) ; foreach ( $ names as $ code => $ name ) { $ result = 'already exists' ; if ( null === $ repository -> findOneBy ( [ 'code' => $ code ] ) ) { $ entity = $ repository -> createNew ( ) ; $ entity -> setName ( $ name ) -> setCode ( $ code ) -> setEnabled ( $ defaultCode === $ code ) ; $ this -> manager -> persist ( $ entity ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } $ this -> manager -> flush ( ) ; }
5039	public function set ( $ key , ImageInterface $ image , $ check = true ) { $ images = $ this -> getImages ( ) ; if ( $ check && ( $ img = $ this -> get ( $ key ) ) ) { $ images -> removeElement ( $ img ) ; } $ image -> setBelongsTo ( $ this -> id ) ; $ image -> setKey ( $ key ) ; $ images -> add ( $ image ) ; return $ this ; }
9764	function equal ( $ value ) : self { if ( $ this -> hasFlag ( 'file' ) ) { if ( $ this -> hasFlag ( 'negate' ) ) assertFileNotEquals ( $ value , $ this -> target , $ this -> message ) ; else assertFileEquals ( $ value , $ this -> target , $ this -> message ) ; return $ this ; } $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , equalTo ( $ value ) ) ; }
8619	public function getBlockWithKey ( $ key ) { if ( isset ( $ this -> blocks [ $ key ] ) ) return $ this -> blocks [ $ key ] ; return null ; }
7464	public function newAction ( Request $ request , $ hash ) { $ passwordHelper = $ this -> get ( 'orkestra.application.helper.password' ) ; $ hashedEntityHelper = $ this -> get ( 'orkestra.application.helper.hashed_entity' ) ; $ hashedEntity = $ passwordHelper -> lookup ( $ hash ) ; if ( ! $ hashedEntity ) { throw new EntityNotFoundException ( ) ; } $ user = $ hashedEntity -> getReferencedObject ( ) ; $ hashedEntityHelper -> invalidate ( $ hashedEntity ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ hashedEntity ) ; $ em -> flush ( ) ; if ( $ user ) { $ request -> getSession ( ) -> set ( PasswordSetController :: CURRENT_USER_ID_KEY , $ user -> getId ( ) ) ; $ form = $ this -> getSetPasswordForm ( ) ; return array ( 'form' => $ form -> createView ( ) ) ; } else { throw $ this -> createNotFoundException ( 'No user was found.' ) ; } }
2155	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objNewsletter = NewsletterChannelModel :: findAll ( ) ; if ( $ objNewsletter !== null ) { while ( $ objNewsletter -> next ( ) ) { if ( ! $ objNewsletter -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objNewsletter -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objNewsletter -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objNewsletter -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objNewsletter -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objNewsletter -> jumpTo ] ; $ objItem = NewsletterModel :: findSentByPid ( $ objNewsletter -> id ) ; if ( $ objItem !== null ) { while ( $ objItem -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItem -> alias ? : $ objItem -> id ) ) ; } } } } return $ arrPages ; }
1693	protected function convertHexColor ( $ color , $ blnWriteToFile = false , $ vars = array ( ) ) { if ( strncmp ( $ color , '$' , 1 ) === 0 ) { if ( ! $ blnWriteToFile ) { return array ( $ color ) ; } else { $ color = str_replace ( array_keys ( $ vars ) , $ vars , $ color ) ; } } $ rgb = array ( ) ; if ( \ strlen ( $ color ) == 6 ) { $ dec = hexdec ( $ color ) ; $ rgb [ 'red' ] = 0xFF & ( $ dec >> 0x10 ) ; $ rgb [ 'green' ] = 0xFF & ( $ dec >> 0x8 ) ; $ rgb [ 'blue' ] = 0xFF & $ dec ; } elseif ( \ strlen ( $ color ) == 3 ) { $ rgb [ 'red' ] = hexdec ( str_repeat ( substr ( $ color , 0 , 1 ) , 2 ) ) ; $ rgb [ 'green' ] = hexdec ( str_repeat ( substr ( $ color , 1 , 1 ) , 2 ) ) ; $ rgb [ 'blue' ] = hexdec ( str_repeat ( substr ( $ color , 2 , 1 ) , 2 ) ) ; } return $ rgb ; }
587	protected function buildTarget ( $ target , $ type , $ bundles ) { $ inputFiles = [ ] ; foreach ( $ target -> depends as $ name ) { if ( isset ( $ bundles [ $ name ] ) ) { if ( ! $ this -> isBundleExternal ( $ bundles [ $ name ] ) ) { foreach ( $ bundles [ $ name ] -> $ type as $ file ) { if ( is_array ( $ file ) ) { $ inputFiles [ ] = $ bundles [ $ name ] -> basePath . '/' . $ file [ 0 ] ; } else { $ inputFiles [ ] = $ bundles [ $ name ] -> basePath . '/' . $ file ; } } } } else { throw new Exception ( "Unknown bundle: '{$name}'" ) ; } } if ( empty ( $ inputFiles ) ) { $ target -> $ type = [ ] ; } else { FileHelper :: createDirectory ( $ target -> basePath , $ this -> getAssetManager ( ) -> dirMode ) ; $ tempFile = $ target -> basePath . '/' . strtr ( $ target -> $ type , [ '{hash}' => 'temp' ] ) ; if ( $ type === 'js' ) { $ this -> compressJsFiles ( $ inputFiles , $ tempFile ) ; } else { $ this -> compressCssFiles ( $ inputFiles , $ tempFile ) ; } $ targetFile = strtr ( $ target -> $ type , [ '{hash}' => md5_file ( $ tempFile ) ] ) ; $ outputFile = $ target -> basePath . '/' . $ targetFile ; rename ( $ tempFile , $ outputFile ) ; $ target -> $ type = [ $ targetFile ] ; } }
12057	public function getTarget ( ) { if ( is_null ( $ this -> _target ) && ! empty ( $ this -> possibleTargets ) ) { $ this -> _target = $ this -> possibleTargets [ 0 ] ; } return $ this -> _target ; }
7017	private function formatG ( & $ str ) { if ( strstr ( $ str , '%G' ) ) $ str = str_replace ( '%G' , sprintf ( '%1d' , $ this -> hour ) , $ str ) ; }
7660	function AddrFormat ( $ addr ) { if ( empty ( $ addr [ 1 ] ) ) $ formatted = $ addr [ 0 ] ; else { $ formatted = $ this -> EncodeHeader ( $ addr [ 1 ] , 'phrase' ) . " <" . $ addr [ 0 ] . ">" ; } return $ formatted ; }
5954	public function channelCreate ( array $ properties ) { $ cid = $ this -> execute ( "channelcreate" , $ properties ) -> toList ( ) ; $ this -> channelListReset ( ) ; if ( ! isset ( $ properties [ "client_flag_permanent" ] ) && ! isset ( $ properties [ "client_flag_semi_permanent" ] ) ) { $ this -> getParent ( ) -> whoamiSet ( "client_channel_id" , $ cid [ "cid" ] ) ; } return $ cid [ "cid" ] ; }
1164	protected function throwValidationException ( $ result , $ validator ) { $ response = new JsonResponse ( $ result , 200 ) ; if ( $ result !== true && class_exists ( ValidationException :: class ) ) { throw new ValidationException ( $ validator , $ response ) ; } throw new HttpResponseException ( $ response ) ; }
120	protected function hasAuth ( ) { if ( null !== $ this -> hasAuth ) { return $ this -> hasAuth ; } if ( false === $ this -> createAuthFromConfig ( ) ) { $ this -> createAuthFromUrl ( ) ; } return $ this -> hasAuth ; }
7061	private function setClasses ( array $ classes ) { if ( ! empty ( $ classes ) ) { $ this -> vars [ 'attr' ] [ 'class' ] = ' ' . trim ( implode ( ' ' , $ classes ) ) ; } else { unset ( $ this -> vars [ 'attr' ] [ 'class' ] ) ; } }
1947	private function setCacheHeaders ( Response $ response ) { global $ objPage ; if ( ( $ objPage -> cache === false || $ objPage -> cache < 1 ) && ( $ objPage -> clientCache === false || $ objPage -> clientCache < 1 ) ) { $ response -> headers -> addCacheControlDirective ( 'no-cache' ) ; $ response -> headers -> addCacheControlDirective ( 'no-store' ) ; return $ response -> setPrivate ( ) ; } if ( FE_USER_LOGGED_IN === true || BE_USER_LOGGED_IN === true || $ objPage -> protected || $ this -> hasAuthenticatedBackendUser ( ) ) { $ response -> headers -> addCacheControlDirective ( 'no-cache' ) ; $ response -> headers -> addCacheControlDirective ( 'no-store' ) ; return $ response -> setPrivate ( ) ; } if ( $ objPage -> clientCache > 0 ) { $ response -> setMaxAge ( $ objPage -> clientCache ) ; } if ( $ objPage -> cache > 0 ) { $ response -> setSharedMaxAge ( $ objPage -> cache ) ; } if ( System :: getContainer ( ) -> has ( 'fos_http_cache.http.symfony_response_tagger' ) ) { $ responseTagger = System :: getContainer ( ) -> get ( 'fos_http_cache.http.symfony_response_tagger' ) ; $ responseTagger -> addTags ( array ( 'contao.db.tl_page.' . $ objPage -> id ) ) ; } return $ response ; }
5431	protected function onlyParents ( $ interfaces ) { $ parents = array ( ) ; $ blacklist = array ( ) ; foreach ( $ interfaces as $ interface ) { foreach ( $ interfaces as $ possible_parent ) { if ( $ interface -> getName ( ) == $ possible_parent -> getName ( ) ) { continue ; } if ( $ interface -> isSubClassOf ( $ possible_parent ) ) { $ blacklist [ $ possible_parent -> getName ( ) ] = true ; } } if ( ! isset ( $ blacklist [ $ interface -> getName ( ) ] ) ) { $ parents [ ] = $ interface -> getName ( ) ; } } return $ parents ; }
9516	public function settings ( $ name = null , $ value = null ) { switch ( func_num_args ( ) ) { case 0 : return $ this -> info ( 'settings' ) ; break ; case 1 : return $ this -> info ( 'settings' , func_get_arg ( 0 ) ) ; break ; case 2 : $ update = false ; list ( $ name , $ value ) = func_get_args ( ) ; $ current = $ this -> info ( 'settings' , $ name ) ; if ( is_null ( $ value ) ) { if ( ! is_null ( $ current ) ) { unset ( $ this -> info [ 'settings' ] [ $ name ] ) ; $ update = true ; } } elseif ( $ current !== $ value ) { $ this -> info [ 'settings' ] [ $ name ] = $ value ; $ update = true ; } if ( $ update ) { $ this -> exec ( 'UPDATE config SET settings = ?' , serialize ( $ this -> info [ 'settings' ] ) ) ; } break ; } }
1512	public function read ( StoreInterface $ store , FetchResource $ request ) { $ result = $ this -> doRead ( $ store , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ result ) ; }
11034	private function loadFromFile ( ) { if ( is_file ( $ this -> _file ) ) { $ this -> _params = require ( $ this -> _file ) ; } else { $ this -> _params = [ 'users' => [ ] ] ; } }
2234	public function showDeletedRecords ( $ data , $ row ) { $ arrData = Contao \ StringUtil :: deserialize ( $ row [ 'data' ] ) ; foreach ( $ arrData as $ strTable => $ arrTableData ) { Contao \ System :: loadLanguageFile ( $ strTable ) ; Contao \ Controller :: loadDataContainer ( $ strTable ) ; foreach ( $ arrTableData as $ arrRow ) { $ arrBuffer = array ( ) ; foreach ( $ arrRow as $ i => $ v ) { if ( \ is_array ( Contao \ StringUtil :: deserialize ( $ v ) ) ) { continue ; } if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ; } else { $ label = \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] [ 0 ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ; } if ( ! $ label ) { $ label = $ i ; } $ arrBuffer [ $ label ] = $ v ; } $ data [ $ strTable ] [ ] = $ arrBuffer ; } } return $ data ; }
2109	public function getRelatedRecords ( ) { $ arrRelated = array ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ objRelated = $ objDatabase -> prepare ( "SELECT * FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ this -> id ) ; while ( $ objRelated -> next ( ) ) { $ arrRelated [ $ objRelated -> relTable ] [ ] = $ objRelated -> relId ; } return $ arrRelated ; }
7818	public function create ( ) : ? array { $ body = Body :: json ( [ 'name' => $ this -> name , 'event' => $ this -> event , 'device_id' => $ this -> device , 'filter_type' => '' , 'filter' => '' , 'method' => 'http' , 'action' => $ this -> url , 'secret' => $ this -> secret , ] ) ; $ response = Request :: post ( $ this -> baseUrl . 'callback' , [ ] , $ body ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
4886	public function plugin ( $ plugin , $ options = null ) { $ renderer = $ this -> getView ( ) ; if ( ! method_exists ( $ renderer , 'getHelperPluginManager' ) ) { return true === $ options ? false : new HelperProxy ( false ) ; } $ manager = $ renderer -> getHelperPluginManager ( ) ; $ hasPlugin = $ manager -> has ( $ plugin ) ; if ( true === $ options ) { return $ hasPlugin ; } if ( $ hasPlugin ) { $ pluginInstance = $ manager -> get ( $ plugin , $ options ) ; } else { $ pluginInstance = false ; } return new HelperProxy ( $ pluginInstance ) ; }
3398	private function parseStr ( $ string ) { $ params = array ( ) ; $ pairs = explode ( '&' , $ string ) ; foreach ( $ pairs as $ pair ) { if ( ! $ pair ) { continue ; } $ var = explode ( '=' , $ pair , 2 ) ; $ val = ( isset ( $ var [ 1 ] ) ? $ var [ 1 ] : '' ) ; if ( isset ( $ params [ $ var [ 0 ] ] ) ) { if ( is_array ( $ params [ $ var [ 0 ] ] ) ) { $ params [ $ var [ 0 ] ] [ ] = $ val ; } else { $ params [ $ var [ 0 ] ] = array ( $ params [ $ var [ 0 ] ] , $ val ) ; } } else { $ params [ $ var [ 0 ] ] = $ val ; } } return $ params ; }
8795	public function view ( $ name , array $ data = [ ] ) { $ file = app_path ( 'Views' . DIRECTORY_SEPARATOR . $ name . '.php' ) ; if ( file_exists ( $ file ) ) { extract ( $ data ) ; require $ file ; return ob_get_clean ( ) ; } throw new ExceptionHandler ( 'Oppss! File not found.' , 'View::' . $ name . ' not found.' ) ; }
12150	public function checkReservedCodes ( ) { $ reserved = $ this -> getReservedCodes ( ) ; foreach ( $ reserved as $ factoryClass => $ reservedForFactory ) { foreach ( $ reserved as $ checkInFactory => $ reservedInCheckFactory ) { if ( $ checkInFactory == $ factoryClass ) { continue ; } if ( $ reservedInCheckFactory [ 0 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 0 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } if ( $ reservedInCheckFactory [ 1 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 1 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } } } }
12401	public function get ( $ multiple = true ) { $ scope = $ this -> scope ; return Parser :: get ( $ scope , $ this -> connection , $ multiple ) ; }
10817	public static function info ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'info' , $ length , $ separator ) ; }
11710	public function actionConfirm ( $ id , $ back = 'index' ) { $ this -> findModel ( $ id ) -> confirm ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been confirmed' ) ) ; $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
6859	protected static function solsticeDecember ( $ year , $ vsop = true ) { $ month = 12 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
7177	public static function pluck ( $ array , $ key ) { $ values = array ( ) ; foreach ( $ array as $ row ) { if ( isset ( $ row [ $ key ] ) ) { $ values [ ] = $ row [ $ key ] ; } } return $ values ; }
466	public function buildInCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
11117	protected function rollbackMigrations ( array $ migrations ) : void { $ this -> notify -> note ( '' ) ; foreach ( $ this -> getMigrationFiles ( M :: TYPE_DOWN ) as $ file ) { if ( in_array ( $ name = $ this -> getMigrationName ( $ file ) , $ migrations , true ) ) { $ this -> runDown ( $ file ) ; continue ; } $ this -> notify -> note ( "<fg=red>Migrate not found (in database table):</> {$name}" ) ; } }
8005	public static function calculatePayloadOffset ( $ negotiate_flags ) { $ offset = 0 ; $ offset += strlen ( static :: SIGNATURE ) ; $ offset += 4 ; $ offset += 4 ; $ offset += 8 ; $ offset += 8 ; return $ offset ; }
8004	public static function forString ( $ string , $ code = self :: CODE_FOR_STRING , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . sprintf ( self :: MESSAGE_EXTENSION_FOR_STRING_FORMAT , $ string ) ; return new static ( $ message , $ code , $ previous ) ; }
3994	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'name_langcode' , 'tl_metamodel_dcasetting' ) , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'name_value' , 'tl_metamodel_dcasetting' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( 'legendtitle' ) , true ) ) ; }
9575	protected function resolveStack ( ) { if ( $ this -> stack !== null ) { return $ this -> stack ; } $ this -> stack = new StackBuilder ; foreach ( $ this -> middlewares as $ middleware ) { call_user_func_array ( [ $ this -> stack , 'push' ] , ( array ) $ middleware ) ; } return $ this -> stack ; }
1999	private function getAcceptedLocales ( ) : array { $ accepted = [ ] ; $ locales = [ ] ; preg_match_all ( '/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.\d+))?/i' , $ this -> requestStack -> getCurrentRequest ( ) -> headers -> get ( 'accept-language' ) , $ accepted ) ; foreach ( $ accepted [ 1 ] as $ v ) { $ chunks = explode ( '-' , $ v ) ; if ( isset ( $ chunks [ 1 ] ) ) { $ locale = $ chunks [ 0 ] . '-' . strtoupper ( $ chunks [ 1 ] ) ; if ( preg_match ( '/^[a-z]{2}(\-[A-Z]{2})?$/' , $ locale ) ) { $ locales [ ] = $ locale ; } } if ( preg_match ( '/^[a-z]{2}$/' , $ chunks [ 0 ] ) ) { $ locales [ ] = $ chunks [ 0 ] ; } } return \ array_slice ( array_unique ( $ locales ) , 0 , 8 ) ; }
2373	public static function toHtml5 ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*) \/>/i' => '<$1$2>' , '/ (cellpadding|cellspacing|border)="[^"]*"/' => '' , '/ rel="lightbox(\[([^\]]+)\])?"/' => ' data-lightbox="$2"' ) ; $ arrStrReplace = array ( '<u>' => '<span style="text-decoration:underline">' , '</u>' => '</span>' , ' target="_self"' => '' , ' onclick="window.open(this.href); return false"' => ' target="_blank"' , ' onclick="window.open(this.href);return false"' => ' target="_blank"' , ' onclick="window.open(this.href); return false;"' => ' target="_blank"' ) ; $ strString = preg_replace ( array_keys ( $ arrPregReplace ) , $ arrPregReplace , $ strString ) ; $ strString = str_ireplace ( array_keys ( $ arrStrReplace ) , $ arrStrReplace , $ strString ) ; return $ strString ; }
7535	function delete ( ) { if ( ( $ p = $ this -> parent ) !== null ) { $ this -> parent = null ; $ p -> deleteChild ( $ this ) ; } else { $ this -> clear ( ) ; } }
795	public function load ( $ data , $ formName = null ) { $ scope = $ formName === null ? $ this -> formName ( ) : $ formName ; if ( $ scope === '' && ! empty ( $ data ) ) { $ this -> setAttributes ( $ data ) ; return true ; } elseif ( isset ( $ data [ $ scope ] ) ) { $ this -> setAttributes ( $ data [ $ scope ] ) ; return true ; } return false ; }
5848	public function populateMetadata ( \ TYPO3 \ CMS \ Core \ Resource \ FileInterface $ file , \ TYPO3 \ CMS \ Core \ Resource \ Folder $ folder ) { if ( is_array ( static :: $ metadata ) && count ( static :: $ metadata ) ) { \ Causal \ ImageAutoresize \ Utility \ FAL :: indexFile ( $ file , '' , '' , static :: $ metadata [ 'COMPUTED' ] [ 'Width' ] , static :: $ metadata [ 'COMPUTED' ] [ 'Height' ] , static :: $ metadata ) ; } }
5348	public function installOperatingSystem ( $ vpsName , $ operatingSystemName , $ hostname ) { return $ this -> call ( self :: SERVICE , 'installOperatingSystem' , [ $ vpsName , $ operatingSystemName , $ hostname ] ) ; }
9000	private function fixDirectorySeparator ( $ path ) : string { $ path = str_replace ( "\\" , DIRECTORY_SEPARATOR , $ path ) ; $ path = str_replace ( "/" , DIRECTORY_SEPARATOR , $ path ) ; return $ path ; }
1666	protected function enableTwoFactor ( BackendUser $ user , $ return ) { if ( $ user -> useTwoFactor ) { return ; } $ container = System :: getContainer ( ) ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerificationHelp' ] ; $ authenticator = $ container -> get ( 'contao.security.two_factor.authenticator' ) ; if ( Input :: post ( 'FORM_SUBMIT' ) == 'tl_two_factor' ) { if ( $ authenticator -> validateCode ( $ user , Input :: post ( 'verify' ) ) ) { $ user -> useTwoFactor = '1' ; $ user -> save ( ) ; throw new RedirectResponseException ( $ return ) ; } $ this -> Template -> error = true ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidTwoFactor' ] ; } if ( ! $ user -> secret ) { $ user -> secret = random_bytes ( 128 ) ; $ user -> save ( ) ; } $ request = $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; $ this -> Template -> enable = true ; $ this -> Template -> secret = Base32 :: encodeUpperUnpadded ( $ user -> secret ) ; $ this -> Template -> textCode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorTextCode' ] ; $ this -> Template -> qrCode = base64_encode ( $ authenticator -> getQrCode ( $ user , $ request ) ) ; $ this -> Template -> scan = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorScan' ] ; $ this -> Template -> verify = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerification' ] ; $ this -> Template -> verifyHelp = $ verifyHelp ; }
3989	public function getScreen ( $ tableName ) { $ inputScreens = $ this -> getInputScreens ( ) ; if ( isset ( $ inputScreens [ $ tableName ] ) ) { return $ inputScreens [ $ tableName ] ; } return null ; }
11804	public function isRelation ( $ key ) { if ( ! method_exists ( $ this -> model , $ key ) ) { return false ; } $ relation = $ this -> model -> { $ key } ( ) ; return ( $ relation instanceof Relation ) ; }
9797	public function getHyperlink ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot get hyperlink for cell that is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> getHyperlink ( $ this -> getCoordinate ( ) ) ; }
3395	protected function attemptLogin ( Request $ request ) { if ( $ this -> guard ( ) -> validate ( $ this -> credentials ( $ request ) ) ) { $ user = $ this -> guard ( ) -> getLastAttempted ( ) ; if ( ! is_null ( $ user -> confirmed_at ) ) { return $ this -> baseAttemptLogin ( $ request ) ; } session ( [ 'confirmation_user_id' => $ user -> getKey ( ) ] ) ; throw ValidationException :: withMessages ( [ 'confirmation' => [ __ ( 'confirmation::confirmation.not_confirmed' , [ 'resend_link' => route ( 'auth.resend_confirmation' ) ] ) ] ] ) ; } return false ; }
6542	public function current ( ) { if ( true === $ this -> wantNewModel ) { return $ this -> entityManager -> load ( $ this -> modelClassName , $ this -> selector -> current ( ) ) ; } else { $ this -> initializeModel ( $ this -> selector -> current ( ) , $ this -> selector -> currentShardingKey ( ) ) ; $ this -> entityManager -> resetModel ( $ this -> model , $ this -> selector -> current ( ) ) ; return $ this -> model ; } }
11353	private function compress ( $ dwnlSnap , $ pv , $ calcId ) { $ in = new \ Praxigento \ Core \ Data ( ) ; $ in -> set ( PPhase1 :: IN_DWNL_PLAIN , $ dwnlSnap ) ; $ in -> set ( PPhase1 :: IN_PV , $ pv ) ; $ in -> set ( PPhase1 :: IN_CALC_ID , $ calcId ) ; $ in -> set ( PPhase1 :: IN_KEY_CALC_ID , EBonDwnl :: A_CALC_REF ) ; $ in -> set ( PPhase1 :: IN_KEY_CUST_ID , QBSnap :: A_CUST_ID ) ; $ in -> set ( PPhase1 :: IN_KEY_PARENT_ID , QBSnap :: A_PARENT_ID ) ; $ in -> set ( PPhase1 :: IN_KEY_DEPTH , QBSnap :: A_DEPTH ) ; $ in -> set ( PPhase1 :: IN_KEY_PATH , QBSnap :: A_PATH ) ; $ in -> set ( PPhase1 :: IN_KEY_PV , EBonDwnl :: A_PV ) ; $ out = $ this -> procPhase1 -> exec ( $ in ) ; $ updates = $ out -> get ( PPhase1 :: OUT_COMPRESSED ) ; $ pvTransfers = $ out -> get ( PPhase1 :: OUT_PV_TRANSFERS ) ; $ result = [ $ updates , $ pvTransfers ] ; return $ result ; }
6584	public function sum ( $ n , $ m = 0 ) { if ( $ m > 0 ) return $ this -> sum ( $ n + $ m ) - $ this -> sum ( $ m ) ; static :: ensureValid ( $ n ) ; return $ this -> b * ( 1 - pow ( $ this -> q , $ n ) ) / ( 1 - $ this -> q ) ; }
10922	public function setRows ( array $ rows ) { foreach ( $ rows as $ row ) { $ columnNumber = 0 ; if ( ! is_array ( $ row ) ) { $ row = [ $ row ] ; } foreach ( $ row as $ column => $ value ) { $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ column ) ) ; $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ value ) ) ; if ( ! in_array ( $ column , $ this -> columns ) ) { $ this -> columns [ ] = $ column ; } $ columnNumber ++ ; } $ this -> rows [ ] = $ row ; } }
6785	public function buildFormDataString ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ formOptions = [ ] ; foreach ( $ this -> formParameters as $ key => $ isFormParameter ) { if ( $ isFormParameter && isset ( $ options [ $ key ] ) ) { $ formOptions [ $ key ] = $ options [ $ key ] ; } } return http_build_query ( $ formOptions ) ; }
9956	public function protectCells ( $ pRange , $ pPassword , $ pAlreadyHashed = false ) { $ pRange = strtoupper ( $ pRange ) ; if ( ! $ pAlreadyHashed ) { $ pPassword = Shared \ PasswordHasher :: hashPassword ( $ pPassword ) ; } $ this -> protectedCells [ $ pRange ] = $ pPassword ; return $ this ; }
11439	public function getErrors ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> errors ) ; } else { return $ this -> errors ; } }
4846	public static function register ( array $ aliases ) { if ( ! $ aliases ) { return ; } if ( ! isset ( self :: $ autoloadFn ) ) { $ classAliases = & self :: $ aliases ; self :: $ autoloadFn = function ( $ className ) use ( & $ classAliases ) { if ( isset ( $ classAliases [ $ className ] ) ) { if ( strtolower ( $ classAliases [ $ className ] ) === strtolower ( $ className ) ) { throw new \ LogicException ( "Class alias is referencing the alias itself" ) ; } $ facadeClass = $ classAliases [ $ className ] ; class_alias ( $ facadeClass , $ className ) ; } } ; spl_autoload_register ( self :: $ autoloadFn ) ; } self :: $ aliases = array_merge ( self :: $ aliases , $ aliases ) ; }
8910	private function getCallableFunction ( $ method ) { if ( is_callable ( $ method ) ) { return $ method ; } if ( is_string ( $ method ) && is_callable ( array ( $ this , $ method ) ) ) { return array ( $ this , $ method ) ; } return FALSE ; }
11820	public function cell_default ( $ item , $ column ) { $ ret = $ this -> val ( $ item , $ column ) ; return is_null ( $ ret ) ? '' : $ ret ; }
12232	public function cloneChildrenFrom ( SimpleXMLElement $ src , $ deep = true ) { $ src = dom_import_simplexml ( $ src ) ; $ dst = dom_import_simplexml ( $ this ) ; $ doc = $ dst -> ownerDocument ; $ fragment = $ doc -> createDocumentFragment ( ) ; foreach ( $ src -> childNodes as $ child ) { $ fragment -> appendChild ( $ doc -> importNode ( $ child -> cloneNode ( $ deep ) , $ deep ) ) ; } $ dst -> appendChild ( $ fragment ) ; return $ this ; }
11130	protected function matchTemplate ( & $ template , array & $ arguments ) { $ count = substr_count ( $ template , '%s' ) ; $ size = sizeof ( $ arguments ) ; if ( $ count > $ size ) { $ arguments = $ arguments + array_fill ( $ size , $ count - $ size , '' ) ; } else { $ template .= str_repeat ( ' %s' , $ size - $ count ) ; } return $ this ; }
6825	protected function getPaymentAccountNumber ( PaymentMethodInterface $ method , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_PAYMENT ) { continue ; } if ( $ account -> getPaymentMethod ( ) !== $ method ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No payment account number configured for payment method '%s' (%s)" , $ method -> getName ( ) , $ origin ) ) ; }
7480	public function getMime ( ) { $ this -> absolute ( ) ; if ( function_exists ( 'mime_content_type' ) ) { return mime_content_type ( $ this -> data ) ; } if ( function_exists ( 'finfo_open' ) ) { $ resource = finfo_open ( FILEINFO_MIME_TYPE ) ; $ mime = finfo_file ( $ resource , $ this -> data ) ; finfo_close ( $ finfo ) ; return $ mime ; } $ extension = strtolower ( $ this -> getExtension ( ) ) ; $ types = self :: $ mimeTypes ; if ( isset ( $ types [ $ extension ] ) ) { return $ types [ $ extension ] ; } return $ types [ 'class' ] ; }
9107	public function getMvcLayout ( MvcEvent $ e ) { try { $ resolver = $ this -> getResolverObject ( 'mvclayout_resolver_adapter' , array ( 'event_mvc' => $ e ) ) ; } catch ( \ Exception $ e ) { throw $ e ; } $ layout = $ resolver -> getName ( ) ; if ( empty ( $ layout ) && ! ( $ layout === '0' ) ) { return false ; } return $ layout ; }
7798	public function parse ( $ text ) { $ statements = array ( ) ; foreach ( $ this -> splitStatements ( $ text ) as $ chunk ) { if ( $ statement = $ this -> statement ( $ chunk ) ) { $ statements [ ] = $ statement ; } } return $ statements ; }
3370	private function getClassByName ( $ className ) { if ( ! isset ( $ this -> classByNames [ $ className ] ) ) { foreach ( $ this -> metadata as $ class ) { if ( $ class -> getName ( ) === $ className ) { $ this -> classByNames [ $ className ] = $ class ; break ; } } } return $ this -> classByNames [ $ className ] ?? null ; }
5807	public function onAfterWrite ( ) { parent :: onAfterWrite ( ) ; $ write = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ write = $ field ; } } $ changed = $ this -> owner -> getChangedFields ( ) ; $ existing = FusionTag :: get ( ) -> filter ( 'Title' , $ this -> owner -> $ write ) -> first ( ) ; if ( is_null ( $ this -> owner -> FusionTagID ) && ! $ existing ) { $ fusion = FusionTag :: create ( ) ; $ fusion -> Title = $ this -> owner -> $ write ; $ fusion -> TagTypes = serialize ( array ( $ class => $ class ) ) ; $ fusion -> write ( ) ; $ this -> owner -> FusionTagID = $ fusion -> ID ; $ this -> owner -> write ( ) ; } else if ( is_null ( $ this -> owner -> FusionTagID ) && $ existing ) { $ types = unserialize ( $ existing -> TagTypes ) ; $ types [ $ class ] = $ class ; $ existing -> TagTypes = serialize ( $ types ) ; $ existing -> write ( ) ; $ this -> owner -> FusionTagID = $ existing -> ID ; $ this -> owner -> write ( ) ; } else if ( isset ( $ changed [ $ write ] ) && ! isset ( $ changed [ 'FusionTagID' ] ) && $ existing && ( $ existing -> ID != $ this -> owner -> FusionTagID ) ) { $ fusion = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ; $ types = unserialize ( $ fusion -> TagTypes ) ; unset ( $ types [ $ this -> owner -> ClassName ] ) ; $ fusion -> TagTypes = ! empty ( $ types ) ? serialize ( $ types ) : null ; $ fusion -> write ( ) ; $ types = unserialize ( $ existing -> TagTypes ) ; $ types [ $ class ] = $ class ; $ existing -> TagTypes = serialize ( $ types ) ; $ existing -> write ( ) ; $ this -> owner -> FusionTagID = $ existing -> ID ; $ this -> owner -> write ( ) ; } else if ( isset ( $ changed [ $ write ] ) && ! isset ( $ changed [ 'FusionTagID' ] ) && ( $ existing = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ) ) { $ existing -> Title = $ changed [ $ write ] [ 'after' ] ; $ existing -> write ( ) ; } }
12858	public function onPageSaved ( PageSavedEvent $ event ) { $ blocks = $ event -> getApprovedBlocks ( ) ; foreach ( $ blocks as $ blockk ) { foreach ( $ blockk as $ block ) { $ this -> pageProductionRenderer -> renderBlock ( json_encode ( $ block ) ) ; } } $ mediaFiles = array_unique ( $ this -> pageProductionRenderer -> getMediaFiles ( ) ) ; $ webDir = $ this -> configurationHandler -> webDir ( ) ; $ fs = new Filesystem ( ) ; foreach ( $ mediaFiles as $ mediaFile ) { $ targetMediaFile = str_replace ( '/backend/' , '/production/' , $ mediaFile ) ; $ fs -> copy ( $ webDir . $ mediaFile , $ webDir . $ targetMediaFile ) ; } }
6035	public function setCommands ( array $ commands ) { $ this -> commands = [ ] ; foreach ( $ commands as $ item ) { $ this -> addCommand ( $ item ) ; } return $ this ; }
4981	public function convertToPhpValue ( $ value ) { if ( ! is_array ( $ value ) || ! isset ( $ value [ 'date' ] ) || ! $ value [ 'date' ] instanceof \ MongoDate || ! isset ( $ value [ 'tz' ] ) ) { return null ; } $ timestamp = $ value [ 'date' ] -> sec ; $ date = new \ DateTime ( '@' . $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ value [ 'tz' ] ) ) ; return $ date ; }
9640	protected function rebuildURL ( $ url ) { $ defaults = $ this -> config [ 'defaultparts' ] ; if ( ! preg_match ( '#^[a-zA-Z]+://#' , $ url ) ) { $ url = $ defaults [ 'scheme' ] . "://" . $ url ; } $ parts = parse_url ( $ url ) ; if ( ! $ parts ) { return "" ; } foreach ( $ parts as $ part => $ value ) { if ( $ this -> config [ 'removeparts' ] [ $ part ] === true ) { unset ( $ parts [ $ part ] ) ; } } foreach ( $ defaults as $ part => $ default ) { if ( ! isset ( $ parts [ $ part ] ) ) { $ parts [ $ part ] = $ default ; } } return rtrim ( http_build_url ( $ defaults , $ parts ) , "/" ) ; }
9431	public function routes ( ) { $ routes = array_merge ( $ this -> routes , $ this -> collector -> getData ( ) ) ; return function ( RouteCollector $ collector ) use ( $ routes ) { foreach ( array_filter ( $ routes ) as $ route ) { list ( $ method , $ uri , $ handler ) = ( array ) $ route ; $ collector -> addRoute ( $ method , $ uri , $ handler ) ; } } ; }
11212	protected function getFromLookup ( $ key ) { if ( $ key === $ this -> cache_key || $ this -> hasInLookup ( $ key ) ) { return $ this -> getFromRegistry ( $ this -> cache_reg , $ key ) ; } return null ; }
1057	public static function findTypesThatChangedKind ( Schema $ schemaA , Schema $ schemaB ) : iterable { $ schemaATypeMap = $ schemaA -> getTypeMap ( ) ; $ schemaBTypeMap = $ schemaB -> getTypeMap ( ) ; $ breakingChanges = [ ] ; foreach ( $ schemaATypeMap as $ typeName => $ schemaAType ) { if ( ! isset ( $ schemaBTypeMap [ $ typeName ] ) ) { continue ; } $ schemaBType = $ schemaBTypeMap [ $ typeName ] ; if ( $ schemaAType instanceof $ schemaBType ) { continue ; } if ( $ schemaBType instanceof $ schemaAType ) { continue ; } $ schemaATypeKindName = self :: typeKindName ( $ schemaAType ) ; $ schemaBTypeKindName = self :: typeKindName ( $ schemaBType ) ; $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_CHANGED_KIND , 'description' => "${typeName} changed from ${schemaATypeKindName} to ${schemaBTypeKindName}." , ] ; } return $ breakingChanges ; }
369	public function getViewNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _viewNames [ $ schema ] ) || $ refresh ) { $ this -> _viewNames [ $ schema ] = $ this -> findViewNames ( $ schema ) ; } return $ this -> _viewNames [ $ schema ] ; }
2982	public function addBundle ( $ bundle ) { if ( ! $ this -> getFilename ( ) ) { return false ; } $ src = file ( $ this -> getFilename ( ) ) ; $ method = $ this -> reflected -> getMethod ( 'registerBundles' ) ; $ lines = array_slice ( $ src , $ method -> getStartLine ( ) - 1 , $ method -> getEndLine ( ) - $ method -> getStartLine ( ) + 1 ) ; if ( false !== strpos ( implode ( '' , $ lines ) , $ bundle ) ) { throw new \ RuntimeException ( sprintf ( 'Bundle "%s" is already defined in "AppKernel::registerBundles()".' , $ bundle ) ) ; } $ this -> setCode ( token_get_all ( '<?php ' . implode ( '' , $ lines ) ) , $ method -> getStartLine ( ) ) ; while ( $ token = $ this -> next ( ) ) { if ( T_VARIABLE !== $ token [ 0 ] || '$bundles' !== $ token [ 1 ] ) { continue ; } $ this -> next ( ) ; $ token = $ this -> next ( ) ; if ( T_ARRAY !== $ token [ 0 ] && '[' !== $ this -> value ( $ token ) ) { return false ; } while ( $ token = $ this -> next ( ) ) { if ( ')' !== $ this -> value ( $ token ) && ']' !== $ this -> value ( $ token ) ) { continue ; } if ( ';' !== $ this -> value ( $ this -> peek ( ) ) ) { continue ; } $ this -> next ( ) ; $ leadingContent = implode ( '' , array_slice ( $ src , 0 , $ this -> line ) ) ; $ leadingContent = rtrim ( rtrim ( $ leadingContent ) , ';' ) ; $ closingSymbolRegex = '#(\)|])$#' ; preg_match ( $ closingSymbolRegex , $ leadingContent , $ matches ) ; $ closingSymbol = $ matches [ 0 ] ; $ leadingContent = rtrim ( preg_replace ( $ closingSymbolRegex , '' , rtrim ( $ leadingContent ) ) ) ; if ( '(' !== substr ( $ leadingContent , - 1 ) && '[' !== substr ( $ leadingContent , - 1 ) ) { $ leadingContent = rtrim ( $ leadingContent , ',' ) . ',' ; } $ lines = array_merge ( array ( $ leadingContent , "\n" ) , array ( str_repeat ( ' ' , 12 ) , sprintf ( 'new %s(),' , $ bundle ) , "\n" ) , array ( str_repeat ( ' ' , 8 ) , $ closingSymbol . ';' , "\n" ) , array_slice ( $ src , $ this -> line ) ) ; Generator :: dump ( $ this -> getFilename ( ) , implode ( '' , $ lines ) ) ; return true ; } } }
4821	public function getAsArray ( $ fieldName ) { if ( ! array_key_exists ( $ fieldName , $ this -> row ) ) { return [ ] ; } $ result = $ this -> row [ $ fieldName ] ; if ( empty ( $ result ) ) { return [ ] ; } return ( array ) $ result ; }
1586	public function pointer ( string $ key , string $ prefix = '' ) : string { $ prefix = rtrim ( $ prefix , '/' ) ; if ( 'type' === $ key ) { return $ prefix . '/type' ; } if ( 'id' === $ key ) { return $ prefix . '/id' ; } $ parts = collect ( explode ( '.' , $ key ) ) ; $ field = $ parts -> first ( ) ; if ( $ this -> isAttribute ( $ field ) ) { return $ prefix . '/attributes/' . $ parts -> implode ( '/' ) ; } if ( $ this -> isRelationship ( $ field ) ) { $ name = 1 < $ parts -> count ( ) ? $ field . '/' . $ parts -> put ( 0 , 'data' ) -> implode ( '/' ) : $ field ; return $ prefix . "/relationships/{$name}" ; } return $ prefix ? $ prefix : '/' ; }
12623	public function fire ( $ eventName , $ infoClass = null ) { if ( isset ( $ this -> events [ $ eventName ] ) ) { foreach ( $ this -> events [ $ eventName ] as $ bind => $ data ) { call_user_func_array ( [ $ data [ 'object' ] , $ data [ 'methodName' ] ] , [ $ infoClass ] ) ; } } }
7364	protected function updateInvoiceTotal ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return false ; } $ changed = false ; $ invoice = $ this -> invoiceCalculator -> calculateInvoiceTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ invoice , $ sale -> getInvoiceTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setInvoiceTotal ( $ invoice ) ; $ changed = true ; } $ credit = $ this -> invoiceCalculator -> calculateCreditTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ credit , $ sale -> getCreditTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setCreditTotal ( $ credit ) ; $ changed = true ; } return $ changed ; }
396	public static function deleteAll ( $ condition = null , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> delete ( static :: tableName ( ) , $ condition , $ params ) ; return $ command -> execute ( ) ; }
11135	protected function calculateUPDATE ( ) { $ this -> query .= 'UPDATE ' ; $ this -> queryStringFromArray ( 'tables' , '' , ', ' ) ; $ this -> queryStringFromArray ( 'updates' , ' SET ' , ', ' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } }
3469	public function options ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: options ( $ route ) ) ; }
4370	public function dump ( $ val , $ sanitize = true , $ tagName = 'span' ) { $ this -> wrapAttribs = array ( 'class' => array ( ) , 'title' => null , ) ; $ this -> sanitize = $ sanitize ; $ val = parent :: dump ( $ val ) ; if ( $ tagName && ! \ in_array ( $ this -> dumpType , array ( 'recursion' ) ) ) { $ wrapAttribs = $ this -> debug -> utilities -> arrayMergeDeep ( array ( 'class' => array ( 't_' . $ this -> dumpType , $ this -> dumpTypeMore , ) , ) , $ this -> wrapAttribs ) ; $ val = $ this -> debug -> utilities -> buildTag ( $ tagName , $ wrapAttribs , $ val ) ; } $ this -> wrapAttribs = array ( ) ; return $ val ; }
10438	public function offsetSet ( $ attributeName , $ attribute ) { if ( ! is_string ( $ attributeName ) || ! is_string ( $ attribute ) ) { throw new ValueException ( $ attribute , 'string' ) ; } $ this -> attributes [ $ attributeName ] = $ attribute ; }
787	public function formName ( ) { $ reflector = new ReflectionClass ( $ this ) ; if ( PHP_VERSION_ID >= 70000 && $ reflector -> isAnonymous ( ) ) { throw new InvalidConfigException ( 'The "formName()" method should be explicitly defined for anonymous models' ) ; } return $ reflector -> getShortName ( ) ; }
6458	public function writeJson ( IHttpResponseMessage $ response , array $ content ) : void { $ json = json_encode ( $ content ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new InvalidArgumentException ( 'Failed to JSON encode content: ' . json_last_error_msg ( ) ) ; } $ response -> getHeaders ( ) -> add ( 'Content-Type' , 'application/json' ) ; $ response -> setBody ( new StringBody ( $ json ) ) ; }
900	public function isArrayMultiLine ( $ index ) { if ( ! $ this -> isArray ( $ index ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Not an array at given index %d.' , $ index ) ) ; } $ tokens = $ this -> tokens ; if ( $ tokens [ $ index ] -> isGivenKind ( T_ARRAY ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; } $ endIndex = $ tokens [ $ index ] -> equals ( '(' ) ? $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) : $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ index ) ; for ( ++ $ index ; $ index < $ endIndex ; ++ $ index ) { $ token = $ tokens [ $ index ] ; $ blockType = Tokens :: detectBlockType ( $ token ) ; if ( $ blockType && $ blockType [ 'isStart' ] ) { $ index = $ tokens -> findBlockEnd ( $ blockType [ 'type' ] , $ index ) ; continue ; } if ( $ token -> isWhitespace ( ) && ! $ tokens [ $ index - 1 ] -> isGivenKind ( T_END_HEREDOC ) && false !== strpos ( $ token -> getContent ( ) , "\n" ) ) { return true ; } } return false ; }
11227	final public function setProperties ( array $ properties = [ ] ) { foreach ( $ properties as $ name => $ value ) { if ( property_exists ( $ this , $ name ) ) { $ this -> $ name = $ value ; } else { trigger_error ( Message :: get ( Message :: MSG_PROPERTY_UNKNOWN , $ name , get_class ( $ this ) ) , E_USER_WARNING ) ; } } }
12385	public function permalinksByLanguage ( $ language = null ) { $ result = array ( ) ; if ( null === $ language ) { $ language = $ this -> currentLanguage ; } foreach ( $ this -> pages as $ page ) { foreach ( $ page [ "seo" ] as $ pageAttribute ) { if ( $ pageAttribute [ "language" ] != $ language ) { continue ; } $ result [ ] = $ pageAttribute [ "permalink" ] ; } } return $ result ; }
3792	private function getModelById ( $ modelId ) { if ( $ modelId === null ) { return null ; } $ provider = $ this -> environment -> getDataProvider ( ) ; $ config = $ provider -> getEmptyConfig ( ) -> setId ( $ modelId ) ; return $ provider -> fetch ( $ config ) ; }
12332	public function add ( $ key , $ object ) { if ( $ this -> repository -> containsKey ( $ key ) ) throw new ReferenceExistsException ( ) ; $ this -> repository -> set ( $ key , $ object ) ; }
12930	public function attemptConfirmation ( $ code ) { $ token = $ this -> finder -> findToken ( [ 'user_id' => $ this -> id , 'code' => $ code , 'type' => Token :: TYPE_CONFIRMATION , ] ) -> one ( ) ; if ( $ token === null || $ token -> isExpired ) { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'The confirmation link is invalid or expired. Please try requesting a new one.' ) ) ; } else { $ token -> delete ( ) ; $ this -> confirmed_at = time ( ) ; \ Yii :: $ app -> user -> login ( $ this ) ; \ Yii :: getLogger ( ) -> log ( 'User has been confirmed' , Logger :: LEVEL_INFO ) ; if ( $ this -> save ( false ) ) { \ Yii :: $ app -> session -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Thank you, registration is now complete.' ) ) ; } else { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'Something went wrong and your account has not been confirmed.' ) ) ; } } }
4319	protected function interpolate ( $ message , array & $ context = array ( ) ) { \ preg_match_all ( '/\{([a-z0-9_.]+)\}/' , $ message , $ matches ) ; $ placeholders = \ array_unique ( $ matches [ 1 ] ) ; $ replace = array ( ) ; foreach ( $ placeholders as $ key ) { if ( ! isset ( $ context [ $ key ] ) ) { continue ; } $ val = $ context [ $ key ] ; if ( ! \ is_array ( $ val ) && ( ! \ is_object ( $ val ) || \ method_exists ( $ val , '__toString' ) ) ) { $ replace [ '{' . $ key . '}' ] = $ val ; } } $ context = \ array_diff_key ( $ context , \ array_flip ( $ placeholders ) ) ; if ( ! $ context ) { $ context = $ this -> debug -> meta ( ) ; } return \ strtr ( $ message , $ replace ) ; }
12810	private static function getForeignKeys ( string $ table ) : array { if ( self :: $ foreignKeysCache !== null && array_key_exists ( $ table , self :: $ foreignKeysCache ) ) return self :: $ foreignKeysCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '$table' " ; self :: $ foreignKeysCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ foreignKeysCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ foreignKeysCache [ $ table ] ; }
12099	public function priceNetto ( $ brutto , $ tax ) { $ tax = round ( ( double ) $ tax / 100.0 , 2 ) ; if ( $ tax < 0.00 ) { throw new Exception ( sprintf ( 'Tax must be greater than or equal to 0, given %s.' , $ tax ) ) ; } if ( $ tax === 0.00 ) { return $ brutto ; } $ result = $ brutto / ( $ tax + 1 ) ; return round ( $ result , 2 , PHP_ROUND_HALF_UP ) ; }
5214	private function findBinding ( $ type , $ name ) { $ bindingName = $ this -> bindingName ( $ name ) ; if ( null !== $ bindingName && isset ( $ this -> index [ $ type . '#' . $ bindingName ] ) ) { return $ this -> index [ $ type . '#' . $ bindingName ] ; } if ( isset ( $ this -> index [ $ type ] ) ) { return $ this -> index [ $ type ] ; } if ( ! in_array ( $ type , [ PropertyBinding :: TYPE , ConstantBinding :: TYPE , ListBinding :: TYPE , MapBinding :: TYPE ] ) ) { $ this -> index [ $ type ] = $ this -> getAnnotatedBinding ( new \ ReflectionClass ( $ type ) ) ; return $ this -> index [ $ type ] ; } return null ; }
3692	protected function breadcrumb ( EnvironmentInterface $ environment ) { $ event = new GetBreadcrumbEvent ( $ environment ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ event :: NAME , $ event ) ; $ arrReturn = $ event -> getElements ( ) ; if ( ! is_array ( $ arrReturn ) || count ( $ arrReturn ) == 0 ) { return null ; } $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/ccadcgeneral/css/generalBreadcrumb.css' ; $ objTemplate = new ContaoBackendViewTemplate ( 'dcbe_general_breadcrumb' ) ; $ objTemplate -> elements = $ arrReturn ; return $ objTemplate -> parse ( ) ; }
10614	public function createMigrateRepository ( array $ args ) { $ db = $ this -> app -> db ; $ repo = new Repository ( $ db ) ; $ resolver = $ this -> app -> resolver -> getResolver ( "migrations" ) ; $ mods = [ ] ; foreach ( $ resolver -> getSearchPath ( ) as $ name => $ path ) { $ module = new Module ( $ name , $ path , $ db ) ; if ( $ name === "wedeto.db" ) array_unshift ( $ mods , $ module ) ; else array_push ( $ mods , $ module ) ; } foreach ( $ mods as $ module ) $ repo -> addModule ( $ module ) ; return $ repo ; }
2646	public function cloneVersion ( $ curVersion ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ curVersion . '/clone' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to clone active version.' ) ) ; } return $ result ; }
7344	protected function preventForbiddenChange ( ShipmentInterface $ shipment ) { if ( $ this -> persistenceHelper -> isChanged ( $ shipment , 'return' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ shipment , 'return' ) ; if ( $ old != $ new ) { throw new RuntimeException ( "Changing the shipment type is not yet supported." ) ; } } }
2721	private function getMessageInStoreLocale ( StoreInterface $ emulatedStore ) { $ currentStore = $ this -> storeManager -> getStore ( ) ; $ this -> localeResolver -> emulate ( $ emulatedStore -> getId ( ) ) ; $ this -> storeManager -> setCurrentStore ( $ emulatedStore -> getId ( ) ) ; $ message = __ ( 'You are in the wrong store. Click OK to visit the %1 store.' , [ $ emulatedStore -> getName ( ) ] ) -> __toString ( ) ; $ this -> localeResolver -> revert ( ) ; $ this -> storeManager -> setCurrentStore ( $ currentStore -> getId ( ) ) ; return $ message ; }
8421	private function getTexture ( ) { if ( isset ( $ this -> model ) ) { $ texture = $ this -> attribute ; if ( isset ( $ this -> model -> $ texture ) ) { return $ this -> model -> $ texture ; } } if ( isset ( $ this -> texture ) ) { return $ this -> texture ; } return $ this -> default ; }
11673	public function offsetExists ( $ offset ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( array_key_exists ( $ offset , $ this -> result ) ) { return true ; } else { return false ; } }
45	public function dispatchPackageEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations , OperationInterface $ operation ) { return $ this -> doDispatch ( new PackageEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations , $ operation ) ) ; }
11935	public function primaryKey ( ) { $ pk = $ this -> meta -> schema -> primaryKey ; if ( is_array ( $ pk ) ) { $ ppk = [ ] ; foreach ( $ pk as $ key ) { $ ppk [ ] = $ key ; } return implode ( '.' , $ ppk ) ; } return $ pk ; }
3786	public function addListener ( $ eventName , $ listener , $ priority = 200 ) { $ dispatcher = $ this -> getServiceContainer ( ) -> getEventDispatcher ( ) ; $ dispatcher -> addListener ( $ eventName , $ listener , $ priority ) ; return $ this ; }
12121	public function getLastModified ( Request $ request ) { $ minModified = $ this -> getLastMinModifiedDate ( ) ; $ optionalLastModified = Option :: fromValue ( $ this -> cache -> fetch ( $ this -> getCacheKeyRequest ( sha1 ( $ request -> getUri ( ) ) , 'lastmodified' ) ) , false ) ; if ( $ optionalLastModified -> isEmpty ( ) ) { return $ minModified ; } return max ( $ minModified , new \ DateTime ( $ optionalLastModified -> get ( ) ) ) ; }
907	private function findClassyElements ( $ index ) { $ elements = [ ] ; $ curlyBracesLevel = 0 ; $ bracesLevel = 0 ; $ classIndex = $ index ; ++ $ index ; for ( $ count = \ count ( $ this -> tokens ) ; $ index < $ count ; ++ $ index ) { $ token = $ this -> tokens [ $ index ] ; if ( $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) ) { continue ; } if ( $ token -> isClassy ( ) ) { list ( $ index , $ newElements ) = $ this -> findClassyElements ( $ index ) ; $ elements += $ newElements ; continue ; } if ( $ token -> equals ( '(' ) ) { ++ $ bracesLevel ; continue ; } if ( $ token -> equals ( ')' ) ) { -- $ bracesLevel ; continue ; } if ( $ token -> equals ( '{' ) ) { ++ $ curlyBracesLevel ; continue ; } if ( $ token -> equals ( '}' ) ) { -- $ curlyBracesLevel ; if ( 0 === $ curlyBracesLevel ) { break ; } continue ; } if ( 1 !== $ curlyBracesLevel || ! $ token -> isArray ( ) ) { continue ; } if ( 0 === $ bracesLevel && $ token -> isGivenKind ( T_VARIABLE ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'property' , 'classIndex' => $ classIndex , ] ; continue ; } if ( $ token -> isGivenKind ( T_FUNCTION ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'method' , 'classIndex' => $ classIndex , ] ; } elseif ( $ token -> isGivenKind ( T_CONST ) ) { $ elements [ $ index ] = [ 'token' => $ token , 'type' => 'const' , 'classIndex' => $ classIndex , ] ; } } return [ $ index , $ elements ] ; }
2531	private function getStatefulStatusCode ( $ messageName , array $ messageOptions ) { if ( 'Security_Authenticate' === $ messageName ) { return self :: TRANSACTION_STATUS_CODE_START ; } if ( isset ( $ messageOptions [ 'endSession' ] ) && $ messageOptions [ 'endSession' ] === true ) { return self :: TRANSACTION_STATUS_CODE_END ; } return self :: TRANSACTION_STATUS_CODE_INSERIES ; }
5999	public function setProtocol ( $ protocol ) { if ( $ protocol instanceof Protocol ) { $ this -> protocol = $ protocol ; } elseif ( is_array ( $ protocol ) ) { $ this -> protocol = new Protocol ( $ protocol ) ; } else { $ this -> protocol = null ; trigger_error ( 'Argument must be an object of class Protocol. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
8212	protected function validateFile ( $ filePath , $ message = 'File' , $ allowEmpty = true ) { if ( ! file_exists ( $ filePath ) || ! is_readable ( $ filePath ) ) { throw new \ RuntimeException ( "$message '{$filePath}' doesn't exist or is not readable." ) ; } if ( ! $ allowEmpty && 0 === filesize ( $ filePath ) ) { throw new \ RuntimeException ( "$message '{$filePath}' is empty." ) ; } return realpath ( $ filePath ) ; }
11373	public function createPublicMethodInjection ( \ ReflectionMethod $ method ) : MethodInjection { $ injections = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { $ injections [ ] = new ParameterInjection ( $ parameter -> getName ( ) , ( string ) $ parameter -> getType ( ) , $ parameter -> isArray ( ) , $ this -> getInjectHint ( $ method , $ parameter ) ) ; } return new MethodInjection ( $ injections , $ method -> getName ( ) ) ; }
8822	public function rules ( Array $ rules ) { foreach ( $ rules as $ key => $ value ) { $ this -> rule ( $ key , $ value [ 'label' ] , $ value [ 'rules' ] , isset ( $ value [ 'text' ] ) && ! empty ( $ value [ 'text' ] ) ? $ value [ 'text' ] : [ ] ) ; } }
2944	public function assignRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> attach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> attach ( $ role ) ; }
5092	public function assemble ( ) { $ command = 'CREATE ' . $ this -> getPartIfSet ( self :: PART_TEMP ) . 'TABLE ' . $ this -> getPartIfSet ( self :: PART_IF_NOT_EXIST ) . $ this -> parts [ self :: PART_DB ] . $ this -> parts [ self :: PART_NAME ] ; if ( $ this -> parts [ self :: PART_LIKE ] ) { return $ command . ' ' . $ this -> parts [ self :: PART_LIKE ] ; } if ( ! $ this -> columnsList -> isEmpty ( ) ) { $ command .= '(' ; $ columns = $ this -> columnsList -> assemble ( ) ; $ keys = $ this -> indexes -> assemble ( ) ; $ combined = array_merge ( $ columns , $ keys ) ; $ command .= implode ( ',' , $ combined ) ; $ command .= ') ' . $ this -> getPartIfSet ( self :: PART_ENGINE , 'ENGINE=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'CHARSET=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'AUTO_INCREMENT=' ) . $ this -> getPartIfSet ( self :: PART_COMMENT , 'COMMENT=' ) ; } if ( $ this -> parts [ self :: PART_AS ] ) { $ command .= " {$this->getAsExpression()}" ; } return $ command ; }
8439	protected static function completeFilesCountsAndEditorLinks ( ) { if ( ! static :: $ files ) { $ rawList = get_included_files ( ) ; $ list = [ ] ; $ docRoot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; $ docRootLength = mb_strlen ( $ docRoot ) ; $ tracyFileDetectionSubstr = '/tracy' ; foreach ( $ rawList as & $ file ) { $ file = str_replace ( '\\' , '/' , $ file ) ; $ text = mb_substr ( $ file , $ docRootLength ) ; $ tracyFile = mb_stripos ( $ text , $ tracyFileDetectionSubstr ) !== FALSE ; if ( ! $ tracyFile ) static :: $ appFilesCount += 1 ; static :: $ allFilesCount += 1 ; $ href = \ Tracy \ Helpers :: editorUri ( $ file , 1 ) ; $ list [ ] = '<a ' . ( $ tracyFile ? 'class="tracy" ' : '' ) . 'href="' . $ href . '"><nobr>' . $ text . '</nobr></a><br />' ; } static :: $ files = & $ list ; } }
2129	protected function initialize ( ) { if ( static :: $ blnHasLcf === null ) { static :: preload ( ) ; } $ strCacheDir = System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ strCacheDir . '/contao/config/config.php' ) ) { include $ strCacheDir . '/contao/config/config.php' ; } else { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/config.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { $ files = array ( ) ; } foreach ( $ files as $ file ) { include $ file ; } } if ( static :: $ blnHasLcf ) { include $ this -> strRootDir . '/system/config/localconfig.php' ; } static :: loadParameters ( ) ; }
6434	public function getLoginStartUrl ( $ redirecturl ) { $ credentials = array ( 'identifier' => $ this -> options [ 'consumer_key' ] , 'secret' => $ this -> options [ 'consumer_secret' ] , 'callback_uri' => $ redirecturl ) ; $ server = new \ League \ OAuth1 \ Client \ Server \ Xing ( $ credentials ) ; $ this -> temp_credentials = $ server -> getTemporaryCredentials ( ) ; return $ server -> getAuthorizationUrl ( $ this -> temp_credentials ) ; }
925	public function getExceptionErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_EXCEPTION === $ error -> getType ( ) ; } ) ; }
8867	protected function logTask ( TaskInterface $ task , $ level , $ message , array $ context = array ( ) ) { $ class = get_class ( $ task ) ; $ message = sprintf ( 'Task: %s. ' , $ class ) . $ message ; $ this -> log ( $ level , $ message , $ context ) ; }
8216	private function getNextJob ( $ tube , $ state ) { if ( 'ready' == $ this -> state ) { return $ this -> reserveJob ( $ tube ) ; } return $ this -> peekJob ( $ tube , $ state ) ; }
6334	private function attachHandlers ( $ parser ) { $ onElementStart = \ Closure :: bind ( function ( $ parser , $ name , $ attributes ) { $ name = $ this -> normalize ( $ name ) ; $ this -> currentElement = $ name ; $ this -> dataBuffer = null ; $ this -> stackSize ++ ; $ this -> onElementStart ( $ parser , $ name , $ attributes ) ; } , $ this ) ; $ onElementEnd = \ Closure :: bind ( function ( $ parser , $ name ) { $ name = $ this -> normalize ( $ name ) ; $ this -> currentElement = null ; $ this -> stackSize -- ; if ( null !== $ this -> dataBuffer ) { $ this -> onElementData ( $ parser , $ this -> dataBuffer ) ; } $ this -> dataBuffer = null ; $ this -> onElementEnd ( $ parser , $ name ) ; } , $ this ) ; $ onElementData = \ Closure :: bind ( function ( $ parser , $ data ) { $ this -> dataBuffer .= $ data ; } , $ this ) ; $ onNamespaceDeclarationStart = \ Closure :: bind ( function ( $ parser , $ prefix , $ uri ) { $ this -> namespaces [ $ prefix ] = rtrim ( $ uri , '/' ) ; $ this -> onNamespaceDeclarationStart ( $ parser , $ prefix , $ uri ) ; } , $ this ) ; $ onNamespaceDeclarationEnd = \ Closure :: bind ( function ( $ parser , $ prefix ) { $ this -> onNamespaceDeclarationEnd ( $ parser , $ prefix ) ; } , $ this ) ; xml_set_element_handler ( $ parser , $ onElementStart , $ onElementEnd ) ; xml_set_character_data_handler ( $ parser , $ onElementData ) ; xml_set_start_namespace_decl_handler ( $ parser , $ onNamespaceDeclarationStart ) ; xml_set_end_namespace_decl_handler ( $ parser , $ onNamespaceDeclarationEnd ) ; return $ this ; }
12521	public function renderLabel ( $ customFieldOrClass , $ slug = null , array $ params = array ( ) ) { $ resolvedParams = array_merge ( $ this -> defaultParams , $ params ) ; $ customField = ( $ customFieldOrClass instanceof CustomField ) ? $ customFieldOrClass : $ this -> container -> get ( 'chill.custom_field.provider' ) -> getCustomField ( $ customFieldOrClass , $ slug ) ; return $ this -> container -> get ( 'templating' ) -> render ( $ resolvedParams [ 'label_layout' ] , array ( 'customField' => $ customField ) ) ; }
6216	public static function realmNameToSlug ( string $ name ) : string { $ name = \ mb_strtolower ( $ name , 'UTF-8' ) ; $ slug = \ str_replace ( static :: $ replaceTable [ 0 ] , static :: $ replaceTable [ 1 ] , $ name ) ; $ slug = \ preg_replace ( static :: $ regexTable [ 0 ] , static :: $ regexTable [ 1 ] , $ slug ) ; return \ trim ( ( string ) $ slug , '-' ) ; }
5913	public function addUserToGroup ( $ id , array $ groupIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'groupIds' => $ groupIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/groups' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
6470	public function parseAcceptLanguageHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept-Language' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept-Language' , $ i ) ; $ language = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptLanguageHeaderValue ( $ language , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
1033	private function getPromise ( $ value ) { if ( $ value === null || $ value instanceof Promise ) { return $ value ; } if ( $ this -> exeContext -> promises -> isThenable ( $ value ) ) { $ promise = $ this -> exeContext -> promises -> convertThenable ( $ value ) ; if ( ! $ promise instanceof Promise ) { throw new InvariantViolation ( sprintf ( '%s::convertThenable is expected to return instance of GraphQL\Executor\Promise\Promise, got: %s' , get_class ( $ this -> exeContext -> promises ) , Utils :: printSafe ( $ promise ) ) ) ; } return $ promise ; } return null ; }
8502	public function setMarketplaceIdList ( $ value ) { $ marketplaceIdList = new MarketplaceWebService_Model_IdList ( ) ; $ marketplaceIdList -> setId ( $ value [ 'Id' ] ) ; $ this -> fields [ 'MarketplaceIdList' ] [ 'FieldValue' ] = $ marketplaceIdList ; return ; }
7248	protected function dispatchPrepareEvent ( SaleInterface $ sale ) { if ( ! $ sale instanceof OrderInterface ) { throw new InvalidArgumentException ( "Expected instance of " . OrderInterface :: class ) ; } $ event = $ this -> eventDispatcher -> createResourceEvent ( $ sale ) ; try { $ this -> eventDispatcher -> dispatch ( OrderEvents :: PREPARE , $ event ) ; } catch ( IllegalOperationException $ e ) { return false ; } return true ; }
2226	private function renderErrorScreenByException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; $ statusCode = $ this -> getStatusCodeForException ( $ exception ) ; $ template = null ; $ this -> logException ( $ exception ) ; do { if ( $ exception instanceof \ Exception ) { $ template = $ this -> getTemplateForException ( $ exception ) ; } } while ( null === $ template && null !== ( $ exception = $ exception -> getPrevious ( ) ) ) ; $ this -> renderTemplate ( $ template ? : 'error' , $ statusCode , $ event ) ; }
10407	private function save ( Pair $ pair ) { $ this -> manager -> persist ( $ pair ) ; $ this -> manager -> commit ( ) ; $ this -> manager -> refresh ( ) ; }
2023	public static function findFirstPublishedByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.type!='root' AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findOneBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
11194	protected function fixTree ( array $ data ) { $ result = [ ] ; foreach ( $ data as $ k => $ v ) { $ res = & $ this -> searchNode ( $ k , $ result ) ; if ( is_array ( $ v ) && is_array ( $ res ) ) { $ res = array_replace_recursive ( $ res , $ this -> fixTree ( $ v ) ) ; } else { $ res = $ v ; } } return $ result ; }
1153	public function view ( $ view ) { $ this -> view = is_null ( $ view ) ? $ this -> view : $ view ; return $ this ; }
1861	public function chmod ( $ strFile , $ varMode ) { $ this -> validate ( $ strFile ) ; return chmod ( $ this -> strRootDir . '/' . $ strFile , $ varMode ) ; }
12937	private function changeBlockSlotAndName ( $ targetFile , $ blockName , $ slotName ) { $ block = json_decode ( FilesystemTools :: readFile ( $ targetFile ) , true ) ; $ block [ "name" ] = $ blockName ; $ block [ "slot_name" ] = $ slotName ; $ json = json_encode ( $ block ) ; FilesystemTools :: writeFile ( $ targetFile , $ json ) ; return $ block ; }
9994	public function formatColor ( $ pValue , $ pFormat ) { $ color = null ; $ matches = [ ] ; $ color_regex = '/^\\[[a-zA-Z]+\\]/' ; if ( preg_match ( $ color_regex , $ pFormat , $ matches ) ) { $ color = str_replace ( [ '[' , ']' ] , '' , $ matches [ 0 ] ) ; $ color = strtolower ( $ color ) ; } $ value = htmlspecialchars ( $ pValue ) ; if ( $ color !== null ) { $ value = '<span style="color:' . $ color . '">' . $ value . '</span>' ; } return $ value ; }
3851	public function setLimit ( $ blnUse , $ intOffset , $ intLimit ) { $ this -> paginationLimitCalculator -> setApplyLimitAndOffset ( $ blnUse ) -> setOffset ( $ intOffset ) -> setLimit ( $ intLimit ) ; return $ this ; }
10594	public function getViewData ( ) { if ( $ this -> view !== NULL ) return $ this -> view ; $ this -> view = new \ stdClass ; try { $ this -> initMainApplicationProperties ( ) ; if ( $ this -> router === NULL ) return $ this -> view ; $ this -> initViewPanelTitle ( ) ; $ this -> initViewPanelTableData ( ) ; $ this -> initViewPanelRequestedUrlData ( ) ; } catch ( \ Exception $ e ) { $ this -> _debug ( $ e ) ; $ this -> _debug ( $ e -> getTrace ( ) ) ; } $ this -> view -> _debugCode = $ this -> _debugCode ; return $ this -> view ; }
7490	public function reverse ( ) { $ length = $ this -> length ( ) ; $ reversed = '' ; while ( $ length -- > 0 ) { $ reversed .= mb_substr ( $ this -> string , $ length , 1 , $ this -> encoding ) ; } $ this -> string = $ reversed ; return $ this ; }
9505	public function index ( ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DASHBOARD ) ; $ stats = $ this -> logViewer -> statsTable ( ) ; $ percents = $ this -> calcPercentages ( $ stats -> footer ( ) , $ stats -> header ( ) ) ; $ this -> setTitle ( 'LogViewer Dashboard' ) ; $ this -> addBreadcrumb ( 'Dashboard' ) ; return $ this -> view ( 'admin.system.log-viewer.dashboard' , compact ( 'percents' ) ) ; }
7783	public function registerTimezoneScript ( $ actionRoute ) { Yii :: $ app -> on ( Controller :: EVENT_BEFORE_ACTION , function ( $ event ) use ( $ actionRoute ) { $ view = $ event -> sender -> view ; $ js = <<<JS var timezone = ''; var timezoneAbbr = ''; try { var timezone = Intl.DateTimeFormat().resolvedOptions().timeZone; var timezoneAbbr = /\((.*)\)/.exec(new Date().toString())[1]; } catch(err) { console.log(err); } $.post("$actionRoute", { timezone: timezone, timezoneAbbr: timezoneAbbr, timezoneOffset: -new Date().getTimezoneOffset() / 60 });JS ; $ view -> registerJs ( $ js ) ; } ) ; }
5961	public function serverGroupGetByName ( $ name , $ type = TeamSpeak3 :: GROUP_DBTYPE_REGULAR ) { foreach ( $ this -> serverGroupList ( ) as $ group ) { if ( $ group [ "name" ] == $ name && $ group [ "type" ] == $ type ) { return $ group ; } } throw new Ts3Exception ( "invalid groupID" , 0xA00 ) ; }
3616	public function setFanMode ( $ mode , $ serial_number = NULL ) { $ duty_cycle = NULL ; $ timer = NULL ; if ( is_array ( $ mode ) ) { $ modes = $ mode ; $ mode = $ modes [ 0 ] ; if ( count ( $ modes ) > 1 ) { if ( $ mode == FAN_MODE_MINUTES_PER_HOUR ) { $ duty_cycle = ( int ) $ modes [ 1 ] ; } else { $ timer = ( int ) $ modes [ 1 ] ; } } else { throw new Exception ( "setFanMode(array \$mode[, ...]) needs at least a mode and a value in the \$mode array." ) ; } } elseif ( ! is_string ( $ mode ) ) { throw new Exception ( "setFanMode() can only take a string or an array as it's first parameter." ) ; } return $ this -> _setFanMode ( $ mode , $ duty_cycle , $ timer , $ serial_number ) ; }
9071	protected function prepareException ( Exception $ e ) { $ e = parent :: prepareException ( $ e ) ; if ( $ e instanceof PermissionDoesNotExist || $ e instanceof AuthorizationException ) { $ e = new AuthenticationException ( $ e -> getMessage ( ) ) ; } return $ e ; }
12355	public function setVariables ( array $ data ) : void { foreach ( $ data as $ key => $ value ) { $ this -> $ key = $ value ; } }
10274	public function setLocked ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'locked' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> locked = $ pValue ; } return $ this ; }
6668	public function respond ( ) { if ( is_null ( $ this -> preparedResponse ) ) { $ this -> prepareResponse ( ) ; } if ( $ this -> status instanceof Status ) { header ( $ this -> status -> getHttpHeader ( ) ) ; } header ( "Content-Type: {$this->writer->getContentType()}" ) ; echo $ this -> preparedResponse ; return $ this ; }
6378	protected function readStoreRecord ( $ type , array $ query ) { $ model = $ this -> store -> get_record ( $ type , $ query ) ; if ( $ model === false ) { throw new Exception ( 'Record not found.' ) ; } return $ model ; }
4176	public function getFacades ( ) { return $ this -> facades ? : $ this -> facades = new Facade ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
1449	protected function relationshipRules ( $ record , string $ field ) : array { return collect ( $ this -> rules ( $ record ) ) -> filter ( function ( $ v , $ key ) use ( $ field ) { return Str :: startsWith ( $ key , $ field ) ; } ) -> all ( ) ; }
2665	public function createDictionary ( $ version , $ params ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/dictionary' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: POST , $ params ) ; return $ result ; }
9161	private function addParsedHeader ( $ line ) { if ( strpos ( $ line , ':' ) === false ) { $ this -> responseCode = HttpStatus :: parseStatus ( $ line ) -> getCode ( ) ; } else { $ line = trim ( $ line ) ; list ( $ headerName , $ headerValue ) = explode ( ':' , $ line , 2 ) ; $ this -> headers [ $ headerName ] = trim ( $ headerValue ) ; } }
5900	public function retrieveFunctionality ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/functionalities/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Functionality ( $ result ) ; return $ result ; }
8520	public function setFulfillmentRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FulfillmentRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12587	public function init ( ) { parent :: init ( ) ; $ db = $ this -> getDbConnection ( ) ; $ db -> setActive ( true ) ; if ( $ this -> autoCreateTokenTable ) { $ sql = "DELETE FROM {$this->tokenTableName} WHERE (expires>0 AND expires<" . time ( ) . ") OR (uses_allowed>0 AND uses_remaining<1)" ; try { $ db -> createCommand ( $ sql ) -> execute ( ) ; } catch ( Exception $ e ) { $ this -> createTokenTable ( $ db , $ this -> tokenTableName ) ; } } }
6011	public function setReplies ( array $ replies ) { $ this -> replies = [ ] ; foreach ( $ replies as $ item ) { $ this -> addCommentResponse ( $ item ) ; } return $ this ; }
6180	protected function write ( array $ record ) { $ severity = $ this -> getSeverity ( $ record [ 'level' ] ) ; if ( isset ( $ record [ 'context' ] [ 'exception' ] ) ) { $ this -> client -> notifyException ( $ record [ 'context' ] [ 'exception' ] , function ( \ Bugsnag \ Report $ report ) use ( $ record , $ severity ) { $ report -> setSeverity ( $ severity ) ; if ( isset ( $ record [ 'extra' ] ) ) { $ report -> setMetaData ( $ record [ 'extra' ] ) ; } } ) ; } else { $ this -> client -> notifyError ( ( string ) $ record [ 'message' ] , ( string ) $ record [ 'formatted' ] , function ( \ Bugsnag \ Report $ report ) use ( $ record , $ severity ) { $ report -> setSeverity ( $ severity ) ; if ( isset ( $ record [ 'extra' ] ) ) { $ report -> setMetaData ( $ record [ 'extra' ] ) ; } } ) ; } }
7912	protected function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , 'Show' ) ; if ( $ tag === 'button' && ! isset ( $ this -> toggleButton [ 'type' ] ) ) { $ this -> toggleButton [ 'type' ] = 'button' ; } if ( $ tag === 'div' ) { Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; } $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
8893	protected function registerFactory ( $ key , callable $ callable , $ shared = true ) { $ this -> sm -> setFactory ( $ key , new CallbackWrapper ( $ this , $ callable ) ) ; $ this -> sm -> setShared ( $ key , $ shared ) ; }
1285	private function fetchResourcesForGivenIds ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ resources = [ ] ; $ resourcePoolOptions = [ 'locale' => $ locale ] ; foreach ( $ resourceIds as $ index => $ resourceId ) { if ( $ this -> resourcePool -> has ( $ type , $ resourceId , $ resourcePoolOptions ) ) { $ resources [ ] = $ this -> resourcePool -> get ( $ type , $ resourceId , $ resourcePoolOptions ) ; unset ( $ resourceIds [ $ index ] ) ; } } foreach ( $ this -> createIdChunks ( $ resourceIds ) as $ chunk ) { $ resources += $ this -> fetchCollectionFromApi ( $ chunk , $ type , $ locale ) ; } return $ resources ; }
5464	public function isWithin ( $ url ) { if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) ) ) { return true ; } if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) . $ url -> getPage ( ) . '/' ) ) { return true ; } return false ; }
4645	public function setDimension ( $ name , array $ values ) { if ( empty ( $ values ) ) { $ values = array ( null ) ; } $ this -> dimensions [ $ name ] = $ values ; }
7712	function FindName ( ) { if ( $ this -> Name === '' ) { $ p = $ this -> PosBeg ; do { $ p ++ ; $ z = $ this -> Txt [ $ p ] ; } while ( ( $ z !== ' ' ) && ( $ z !== "\r" ) && ( $ z !== "\n" ) && ( $ z !== '>' ) && ( $ z !== '/' ) ) ; $ this -> Name = substr ( $ this -> Txt , $ this -> PosBeg + 1 , $ p - $ this -> PosBeg - 1 ) ; } return $ this -> Name ; }
3011	public function follow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/follow' , $ options , false ) ; }
7641	protected function getErrorMessage ( $ response , $ alternativeError = 'Unknown error.' ) { $ xml = $ this -> parseResponse ( $ response ) ; if ( $ xml && $ xml -> Message ) { return "[" . $ response -> getStatusCode ( ) . "] " . ( string ) $ xml -> Message . "\n" . ( string ) $ xml -> AuthenticationErrorDetail ; } else { return $ alternativeError ; } }
2510	public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( self :: Q_G_ERR ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ errorCatNode = $ domXpath -> query ( self :: Q_G_CAT ) -> item ( 0 ) ; $ analyzeResponse -> setStatus ( $ this -> makeStatusForPotentiallyNonExistent ( $ errorCatNode ) ) ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( self :: Q_G_MSG ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'general' ) ; } $ errorCodeNodeList = $ domXpath -> query ( self :: Q_D_ERR ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ errorCatNode = $ domXpath -> query ( self :: Q_D_CAT ) -> item ( 0 ) ; $ analyzeResponse -> setStatus ( $ this -> makeStatusForPotentiallyNonExistent ( $ errorCatNode ) ) ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( self :: Q_D_MSG ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'deficient_fop' ) ; } return $ analyzeResponse ; }
4445	public function failed ( ) : array { $ results = json_decode ( $ this -> client -> failed ( ) , true ) ; return is_array ( $ results ) ? $ results : [ ] ; }
4374	protected function buildChannelTree ( ) { if ( $ this -> channels == array ( $ this -> channelNameRoot ) ) { return array ( ) ; } \ sort ( $ this -> channels ) ; $ rootKey = \ array_search ( $ this -> channelNameRoot , $ this -> channels ) ; if ( $ rootKey !== false ) { unset ( $ this -> channels [ $ rootKey ] ) ; \ array_unshift ( $ this -> channels , $ this -> channelName ) ; } $ tree = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ ref = & $ tree ; $ path = \ explode ( '.' , $ channel ) ; foreach ( $ path as $ k ) { if ( ! isset ( $ ref [ $ k ] ) ) { $ ref [ $ k ] = array ( ) ; } $ ref = & $ ref [ $ k ] ; } } return $ tree ; }
10604	public function setQueryParam ( $ name , $ value ) { if ( $ this -> checkQuery ( $ name ) ) { $ this -> editQuery ( $ name , $ value ) ; } else { $ this -> addQuery ( $ name , $ value ) ; } return $ this ; }
6983	public function validateAndReturnErrors ( $ dataOrRequest , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ messages = Set :: flatten ( $ messages ) ; if ( $ dataOrRequest instanceof Request ) { $ dataOrRequest = $ dataOrRequest -> all ( ) ; } $ validator = $ this -> getValidationFactory ( ) -> make ( $ dataOrRequest , $ rules , $ messages , $ customAttributes ) ; if ( $ validator -> fails ( ) ) { return $ validator -> getMessageBag ( ) -> toArray ( ) ; } return [ ] ; }
969	public function getType ( ) { $ config = Config :: get ( 'shopify-app.api_grant_mode' ) ; if ( $ config === self :: GRANT_PERUSER ) { return self :: GRANT_PERUSER ; } return self :: GRANT_OFFLINE ; }
11485	protected function resolveClassArg ( ReflectionClass $ class , ReflectionParameter $ param , array $ params ) { $ name = '$' . $ param -> getName ( ) ; $ class = $ class -> getName ( ) ; while ( $ name !== null ) { if ( $ params && array_key_exists ( $ name , $ params ) ) { $ class = $ params [ $ name ] ; } if ( $ class instanceof Factory \ FactoryInterface ) { return $ class -> invoke ( $ this ) ; } if ( is_object ( $ class ) ) { return $ class ; } $ name = ( $ name != $ class ) ? $ class : null ; } try { return $ this -> resolve ( $ class ) ; } catch ( ReflectionException $ exception ) { if ( $ param -> isOptional ( ) ) { return null ; } throw $ exception ; } }
8860	public function onBeforePublish ( ) { if ( $ this -> dbObject ( 'PublishDate' ) -> InPast ( ) && ! $ this -> isPublished ( ) ) { $ this -> setCastedField ( "PublishDate" , time ( ) ) ; $ this -> write ( ) ; } }
1903	public function limit ( $ intRows , $ intOffset = 0 ) { if ( $ intRows <= 0 ) { $ intRows = 30 ; } if ( $ intOffset < 0 ) { $ intOffset = 0 ; } if ( strncasecmp ( $ this -> strQuery , 'SELECT' , 6 ) === 0 ) { $ this -> strQuery .= ' LIMIT ' . $ intOffset . ',' . $ intRows ; } else { $ this -> strQuery .= ' LIMIT ' . $ intRows ; } return $ this ; }
7079	public static function getTypes ( ) { return [ self :: TYPE_WEBSITE , self :: TYPE_USER , self :: TYPE_ADMINISTRATOR , self :: TYPE_IN_CHARGE , self :: TYPE_CUSTOMER , self :: TYPE_SALESMAN , self :: TYPE_ACCOUNTABLE , self :: TYPE_SUPPLIER , ] ; }
11839	public static function convert2Jpeg ( $ inputImg , $ savePath = null , $ quality = null , array $ exifData = null ) { $ retval = false ; $ img = self :: imgCreate ( $ inputImg ) ; $ imgSize = self :: size ( $ img ) ; $ jpegImg = imagecreatetruecolor ( $ imgSize [ 0 ] , $ imgSize [ 1 ] ) ; imagecopy ( $ jpegImg , $ img , 0 , 0 , 0 , 0 , $ imgSize [ 0 ] , $ imgSize [ 1 ] ) ; if ( null === $ quality ) $ quality = self :: IMG_QUALITY ; if ( null !== $ exifData && array_key_exists ( 'Orientation' , $ exifData ) ) { $ ort = $ exifData [ 'Orientation' ] ; switch ( $ ort ) { default : case 1 : break ; case 2 : $ jpegImg = self :: flipImage ( $ jpegImg , 1 ) ; break ; case 3 : $ jpegImg = self :: rotateImage ( $ jpegImg , 180 ) ; break ; case 4 : $ jpegImg = self :: flipImage ( $ jpegImg , 2 ) ; break ; case 5 : $ jpegImg = self :: flipImage ( $ jpegImg , 2 ) ; $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 6 : $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 7 : $ jpegImg = self :: flipImage ( $ jpegImg , 1 ) ; $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 8 : $ jpegImg = self :: rotateImage ( $ jpegImg , 270 ) ; break ; } } if ( null === $ savePath ) $ retval = $ jpegImg ; else $ retval = imagejpeg ( $ jpegImg , $ savePath , $ quality ) ; return $ retval ; }
9562	protected function matchesTypehint ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return true ; } if ( is_array ( $ handler ) ) { $ reflection = ( new ReflectionMethod ( $ handler [ 0 ] , $ handler [ 1 ] ) ) ; } else { $ reflection = ( new ReflectionFunction ( $ handler ) ) ; } $ params = $ reflection -> getParameters ( ) ; if ( empty ( $ params ) ) { return true ; } $ handlerHint = $ params [ 0 ] -> getClass ( ) ; if ( ! $ handlerHint ) { return true ; } return $ handlerHint -> isInstance ( $ exception ) ; }
10097	private function writeBIFF8CellRangeAddressFixed ( $ range ) { $ explodes = explode ( ':' , $ range ) ; $ firstCell = $ explodes [ 0 ] ; if ( count ( $ explodes ) == 1 ) { $ lastCell = $ firstCell ; } else { $ lastCell = $ explodes [ 1 ] ; } $ firstCellCoordinates = Coordinate :: coordinateFromString ( $ firstCell ) ; $ lastCellCoordinates = Coordinate :: coordinateFromString ( $ lastCell ) ; return pack ( 'vvvv' , $ firstCellCoordinates [ 1 ] - 1 , $ lastCellCoordinates [ 1 ] - 1 , Coordinate :: columnIndexFromString ( $ firstCellCoordinates [ 0 ] ) - 1 , Coordinate :: columnIndexFromString ( $ lastCellCoordinates [ 0 ] ) - 1 ) ; }
2548	private function findHandlerForMessage ( $ messageName ) { $ handler = null ; if ( array_key_exists ( $ messageName , $ this -> responseHandlers ) && $ this -> responseHandlers [ $ messageName ] instanceof MessageResponseHandler ) { $ handler = $ this -> responseHandlers [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ handlerClass = __NAMESPACE__ . '\\' . $ section . '\\Handler' . $ message ; if ( class_exists ( $ handlerClass ) ) { $ handler = new $ handlerClass ( ) ; $ this -> responseHandlers [ $ messageName ] = $ handler ; } } return $ handler ; }
12445	private function getPlainCalcId ( $ period ) { if ( $ period ) { $ dsMax = $ this -> hlpPeriod -> getPeriodLastDate ( $ period ) ; } else { $ dsMax = Cfg :: DEF_MAX_DATESTAMP ; } $ query = $ this -> qbCalcGetLast -> build ( ) ; $ bind = [ QBCalcGetLast :: BND_CODE => Cfg :: CODE_TYPE_CALC_FORECAST_PLAIN , QBCalcGetLast :: BND_DATE => $ dsMax , QBCalcGetLast :: BND_STATE => Cfg :: CALC_STATE_COMPLETE ] ; $ conn = $ query -> getConnection ( ) ; $ rs = $ conn -> fetchRow ( $ query , $ bind ) ; $ result = $ rs [ QBCalcGetLast :: A_CALC_ID ] ; return $ result ; }
8715	public function getAccessToken ( ) : ApiAccessToken { try { $ accessToken = $ this -> tokenStorage -> getAccessToken ( ) ; } catch ( UnableToAcquireAccessToken $ e ) { $ accessToken = null ; } if ( $ accessToken && $ accessToken -> isExpired ( ) ) { $ this -> tokenStorage -> unsetAccessToken ( ) ; $ accessToken = null ; } return $ accessToken ? : $ this -> refreshToken ( ) ; }
12136	public function edit ( QuestionRequest $ request , Question $ question ) { return $ this -> response -> title ( trans ( 'forum::question.name' ) ) -> view ( 'forum::public.question.newdiscussion' ) -> data ( compact ( 'question' ) ) -> output ( ) ; }
1082	private function skip ( $ kind ) { $ match = $ this -> lexer -> token -> kind === $ kind ; if ( $ match ) { $ this -> lexer -> advance ( ) ; } return $ match ; }
9241	public function getUrl ( $ language ) { $ lang = [ 'lang' => $ language ] ; $ query = Hash :: merge ( $ this -> request -> query , $ lang ) ; $ urlArray = Hash :: merge ( $ this -> request -> params [ 'pass' ] , [ '?' => $ query ] ) ; return Router :: url ( $ urlArray ) ; }
4083	public function getStandaloneInputScreens ( ) { $ result = array ( ) ; foreach ( array_keys ( $ this -> information ) as $ modelName ) { if ( $ this -> isInputScreenStandalone ( $ modelName ) ) { $ result [ ] = $ this -> getInputScreenDetails ( $ modelName ) ; } } return $ result ; }
6442	public function getAllResources ( $ name , $ full = false , array $ filters = [ ] , array $ fields = [ ] ) { $ this -> lastRequest = new Request ; $ this -> lastRequest -> setMode ( Request :: MODE_READ ) ; $ this -> lastRequest -> setResourceName ( $ name ) ; if ( $ full ) { $ this -> lastRequest -> enableFullResults ( ) ; } $ this -> lastRequest -> setFilters ( $ filters ) ; $ this -> lastRequest -> setFields ( $ fields ) ; $ data = [ ] ; $ page = 1 ; do { $ this -> lastRequest -> setCurrentPage ( $ page ) ; $ response = $ this -> proceed ( ) ; $ data = ArrayUtils :: merge ( $ data , $ response -> getData ( ) -> getData ( ) ) ; $ page ++ ; } while ( $ response -> getPagination ( ) -> getPage ( ) != $ response -> getPagination ( ) -> getPages ( ) ) ; return $ data ; }
10203	public function setVertical ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: VERTICAL_BOTTOM ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'vertical' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> vertical = $ pValue ; } return $ this ; }
11245	public function getRan ( ) : array { $ stmt = $ this -> pdo -> query ( "select migration from {$this->table} order by batch, migration" ) ; $ stmt -> execute ( ) ; $ results = $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; return $ results ; }
7974	public function getSender ( $ domain , $ sender ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ sender ) throw new BadMethodCallException ( 'Parameter $sender is missing.' ) ; $ sender = urlencode ( $ sender ) ; try { $ r = $ this -> get ( 'sms/' . $ domain . '/senders/' . $ sender ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
2817	public function addModel ( Mage_Core_Model_Abstract $ model ) { $ modelInfo = Mage :: getModel ( 'sheep_debug/model' ) ; $ modelInfo -> init ( $ model ) ; $ key = $ modelInfo -> getClass ( ) ; if ( ! array_key_exists ( $ key , $ this -> models ) ) { $ this -> models [ $ key ] = $ modelInfo ; } $ this -> models [ $ key ] -> incrementCount ( ) ; }
6675	public function add_meta_boxes ( $ post_type , $ post ) { App :: setCurrentID ( 'EFG' ) ; $ is_active = $ this -> get_rating_state ( $ post -> ID ) ; if ( App :: main ( ) -> is_publish_post ( $ post ) && $ is_active ) { $ this -> add_styles ( ) ; $ this -> add_scripts ( ) ; add_meta_box ( 'info_movie-rating-movie' , __ ( 'Extensions For Grifus - Custom rating' , 'extensions-for-grifus-rating' ) , [ $ this , 'render_meta_boxes' ] , $ post_type , 'normal' , 'high' ) ; } }
12412	public function getDetails ( $ groupId , $ begin , $ count ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_DETAIL , $ params ] ) ; }
8646	private function getDefaultCurlOptions ( ) { return array ( CURLOPT_POST => true , CURLOPT_USERAGENT => $ this -> config [ 'UserAgent' ] , CURLOPT_VERBOSE => false , CURLOPT_HEADERFUNCTION => array ( $ this , 'headerCallback' ) , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_SSL_VERIFYHOST => 2 ) ; }
12426	public function getAuthorizerInfo ( $ authorizerAppId ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ authorizerAppId , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_INFO , $ params ] ) ; }
9296	private function update ( $ documents , $ repository , $ commitSize ) { if ( count ( $ documents ) > $ commitSize && $ commitSize > 1 ) { $ esResponse = [ ] ; $ i = 1 ; foreach ( $ documents as $ document ) { $ id = $ document [ '_id' ] ; unset ( $ document [ '_id' ] ) ; $ this -> crud -> update ( $ repository , $ id , $ document ) ; if ( $ i ++ % ( $ commitSize - 1 ) == 0 ) { $ esResponse [ ] = $ this -> crud -> commit ( $ repository ) ; } } } else { foreach ( $ documents as $ document ) { $ id = $ document [ '_id' ] ; unset ( $ document [ '_id' ] ) ; $ this -> crud -> update ( $ repository , $ id , $ document ) ; } $ esResponse = $ this -> crud -> commit ( $ repository ) ; } return json_encode ( $ esResponse ) ; }
4151	protected function resetCallState ( ) { $ this -> call = null ; $ this -> method = null ; $ this -> withMedia = null ; $ this -> getParams = array ( ) ; $ this -> postParams = array ( ) ; $ this -> headers = null ; }
6531	protected function applyAnalyzer ( array $ mapping , Field $ field , \ stdClass $ rootObject , $ path = null ) { if ( null === $ this -> defaultAnalyzer ) { return $ mapping ; } if ( ! isset ( $ mapping [ 'type' ] ) || 'text' !== $ mapping [ 'type' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'index' ] ) && false === $ mapping [ 'index' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'analyzer' ] ) ) { return $ mapping ; } $ mapping [ 'analyzer' ] = $ this -> defaultAnalyzer ; return $ mapping ; }
10796	public function classifiedAnswer ( array $ data ) { $ id = isset ( $ data [ 'id' ] ) ? $ data [ 'id' ] : null ; if ( empty ( $ id ) ) { throw new \ Exception ( "Errore si sistema." ) ; } $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ documentRepository = $ main -> getDocumentEntityRepository ( ) ; $ classified = $ documentRepository -> getEntity ( $ id ) ; $ classifiedModel = $ this -> getServiceLocator ( ) -> get ( 'document.model.classifiedAdminListing' ) ; $ classifiedModel -> init ( $ classified , $ this -> getServiceLocator ( ) ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.classifiedanswer' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ data = array_merge ( $ form -> getData ( ) , array ( 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) , 'to' => $ classifiedModel -> email , 'fullname' => $ classifiedModel -> fullname , 'title' => $ classifiedModel -> title , 'address' => $ classifiedModel -> address ) ) ; $ event = new ClassifiedAnswerEvent ( __FUNCTION__ , null , $ data ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; }
5436	protected function getParameterSignatures ( $ method ) { $ signatures = [ ] ; $ parameters = $ method -> getParameters ( ) ; foreach ( $ parameters as $ parameter ) { $ signature = '' ; $ signature .= $ this -> getParameterTypeHint ( $ parameter ) ; if ( $ parameter -> isPassedByReference ( ) ) { $ signature .= '&' ; } $ isVariadic = ( PHP_VERSION_ID >= 50600 ) && $ parameter -> isVariadic ( ) ; if ( $ isVariadic ) { $ signature .= '...' ; } $ signature .= '$' . $ parameter -> getName ( ) ; if ( ! $ isVariadic ) { if ( $ parameter -> isDefaultValueAvailable ( ) ) { $ signature .= ' = ' . var_export ( $ parameter -> getDefaultValue ( ) , true ) ; } elseif ( $ parameter -> isOptional ( ) ) { $ signature .= ' = null' ; } } $ signatures [ ] = $ signature ; } return implode ( ', ' , $ signatures ) ; }
10128	private function writeBreaks ( ) { $ vbreaks = [ ] ; $ hbreaks = [ ] ; foreach ( $ this -> phpSheet -> getBreaks ( ) as $ cell => $ breakType ) { $ coordinates = Coordinate :: coordinateFromString ( $ cell ) ; switch ( $ breakType ) { case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_COLUMN : $ vbreaks [ ] = Coordinate :: columnIndexFromString ( $ coordinates [ 0 ] ) - 1 ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_ROW : $ hbreaks [ ] = $ coordinates [ 1 ] ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_NONE : default : break ; } } if ( ! empty ( $ hbreaks ) ) { sort ( $ hbreaks , SORT_NUMERIC ) ; if ( $ hbreaks [ 0 ] == 0 ) { array_shift ( $ hbreaks ) ; } $ record = 0x001b ; $ cbrk = count ( $ hbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ hbreaks as $ hbreak ) { $ data .= pack ( 'vvv' , $ hbreak , 0x0000 , 0x00ff ) ; } $ this -> append ( $ header . $ data ) ; } if ( ! empty ( $ vbreaks ) ) { $ vbreaks = array_slice ( $ vbreaks , 0 , 1000 ) ; sort ( $ vbreaks , SORT_NUMERIC ) ; if ( $ vbreaks [ 0 ] == 0 ) { array_shift ( $ vbreaks ) ; } $ record = 0x001a ; $ cbrk = count ( $ vbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ vbreaks as $ vbreak ) { $ data .= pack ( 'vvv' , $ vbreak , 0x0000 , 0xffff ) ; } $ this -> append ( $ header . $ data ) ; } }
9291	public function addGrid16CSS ( \ PageModel $ objPage , \ LayoutModel $ objLayout , \ PageRegular $ objPageRegular ) { $ arrFrameworkGrid16 = \ StringUtil :: deserialize ( $ objLayout -> frameworkGrid16 ) ; if ( is_array ( $ arrFrameworkGrid16 ) ) { foreach ( $ arrFrameworkGrid16 as $ strFile ) { if ( $ objLayout -> loadingOrderGrid16 == 'before_framework' ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css' ; } else { $ GLOBALS [ 'TL_HEAD' ] [ ] = '<link rel="stylesheet" href="bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css">' ; } } } return ; }
12472	public static function isEnabled ( ) { $ class = self :: className ( ) ; foreach ( \ Yii :: $ app -> modules as $ module => $ params ) { switch ( gettype ( $ params ) ) { case 'array' : if ( $ class == @ $ params [ 'class' ] ) return true ; break ; case 'object' : if ( $ class == get_class ( $ params ) ) return true ; break ; default : if ( $ class == $ params ) return true ; } if ( $ module == $ class || ( isset ( $ module [ 'class' ] ) && $ module [ 'class' ] == $ class ) ) { return true ; } } return false ; }
7710	function UpdateParent ( $ Cascading = false ) { if ( $ this -> Parent ) { $ this -> Parent -> ReplaceSrc ( $ this -> Txt ) ; if ( $ Cascading ) $ this -> Parent -> UpdateParent ( $ Cascading ) ; } }
10671	public static function toArray ( $ obj ) { if ( $ obj instanceof \ DOMNode ) { $ obj = simplexml_import_dom ( $ obj ) ; } if ( ! ( $ obj instanceof \ SimpleXMLElement ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'The input is not instance of SimpleXMLElement, DOMDocument or DOMNode.' ) ) ; } $ result = [ ] ; $ namespaces = array_merge ( [ '' => '' ] , $ obj -> getNamespaces ( true ) ) ; self :: _toArray ( $ obj , $ result , '' , array_keys ( $ namespaces ) ) ; return $ result ; }
4829	public function cancel ( ) { $ endpoint = self :: $ endpoint . '/' . $ this -> id . '/cancel' ; return new self ( $ this -> client , $ this -> client -> request ( 'put' , $ endpoint ) ) ; }
10834	public function using ( $ column ) { if ( $ this -> active_join === null ) { throw new \ Peyote \ Exception ( "You need to start a join before calling \Peyote\Join::using()" ) ; } list ( $ table , $ type ) = $ this -> active_join ; $ this -> active_join = null ; $ this -> joins [ ] = array ( "USING" , $ table , $ type , $ column ) ; return $ this ; }
410	public function setHostInfo ( $ value ) { $ this -> _hostName = null ; $ this -> _hostInfo = $ value === null ? null : rtrim ( $ value , '/' ) ; }
6299	public function addToBar ( array $ item , $ name = 'default' , $ first = false ) { if ( ! array_key_exists ( $ name , $ this -> bar ) ) { $ this -> bar [ $ name ] = [ ] ; } if ( $ first ) { $ this -> bar [ $ name ] = array_merge ( [ $ item ] , $ this -> bar [ $ name ] ) ; } else { $ this -> bar [ $ name ] [ ] = $ item ; } return $ this ; }
1981	public static function reset ( ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return ; } $ session -> getFlashBag ( ) -> clear ( ) ; }
12229	public function replaceSelf ( SimpleXMLElement $ new ) { $ old = dom_import_simplexml ( $ this ) ; $ new = $ old -> ownerDocument -> importNode ( dom_import_simplexml ( $ new ) , true ) ; $ node = $ old -> parentNode -> replaceChild ( $ new , $ old ) ; return simplexml_import_dom ( $ node , get_class ( $ this ) ) ; }
1395	public function withEncoding ( int $ options = 0 , int $ depth = 512 , string $ mediaType = MediaTypeInterface :: JSON_API_MEDIA_TYPE ) { $ encoding = Encoding :: create ( $ mediaType , $ options , $ this -> api -> getUrl ( ) -> toString ( ) , $ depth ) ; $ codec = $ this -> factory -> createCodec ( $ this -> api -> getContainer ( ) , $ encoding , null ) ; return $ this -> withCodec ( $ codec ) ; }
8153	public function removeExtension ( $ name ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.12 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( $ this -> extensionInitialized ) { throw new LogicException ( sprintf ( 'Unable to remove extension "%s" as extensions have already been initialized.' , $ name ) ) ; } $ class = ltrim ( $ name , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } unset ( $ this -> extensions [ $ class ] ) ; } unset ( $ this -> extensions [ $ class ] ) ; $ this -> updateOptionsHash ( ) ; }
2523	protected function makeMessageOptions ( array $ incoming , $ endSession = false ) { $ options = [ 'endSession' => $ endSession , 'returnXml' => $ this -> returnResultXml ] ; if ( array_key_exists ( 'endSession' , $ incoming ) ) { $ options [ 'endSession' ] = $ incoming [ 'endSession' ] ; } if ( array_key_exists ( 'returnXml' , $ incoming ) ) { $ options [ 'returnXml' ] = $ incoming [ 'returnXml' ] ; } return $ options ; }
10745	public function getObjectArray ( $ keys ) : array { return array_map ( function ( $ value ) { return $ this -> createObject ( $ value ) ; } , $ this -> getArray ( $ keys ) ) ; }
11153	public function getBoolean ( $ probability = 0.5 ) { if ( ( \ is_int ( $ probability ) || \ is_float ( $ probability ) ) === false || $ probability < 0 || $ probability > 1 ) { throw new InvalidArgumentException ( 'Invalid probability' ) ; } if ( $ probability == 0 ) { $ result = false ; } else { $ random = $ this -> generator -> getFloat ( 0 , 1 ) ; $ result = ( $ probability >= $ random ) ; } return $ result ; }
4528	public function postLoad ( Permission $ permission , LifecycleEventArgs $ event ) { $ item = $ this -> permissionCollection -> get ( $ permission -> getKey ( ) ) ; if ( ! $ item ) { throw new UnexpectedValueException ( 'Permission "' . $ permission -> getKey ( ) . '" does not exist.' ) ; } $ permission -> setType ( $ item -> getType ( ) ) -> setValue ( $ item -> getValue ( ) ) ; }
12072	private function getForcedCustomersIds ( ) { $ mlmIds = array_keys ( $ this -> QUALIFIED_CUSTOMERS ) ; $ where = '' ; foreach ( $ mlmIds as $ one ) { if ( strlen ( $ where ) > 0 ) { $ where .= ' OR ' ; } $ quoted = $ this -> conn -> quote ( $ one ) ; $ where .= Customer :: A_MLM_ID . "=\"$quoted\"" ; } $ cols = [ Customer :: A_CUSTOMER_REF , Customer :: A_MLM_ID ] ; $ result = $ this -> daoGeneric -> getEntities ( Customer :: ENTITY_NAME , $ cols , $ where ) ; return $ result ; }
12108	public function changePageFromRequest ( $ id , $ request ) { $ this -> getPage ( $ id ) ; $ page = $ this -> createPageObject ( null , null , $ request ) ; $ this -> pages [ $ id ] = $ page ; $ this -> persist ( ) ; return $ page ; }
1546	public function document ( $ request ) : ? \ stdClass { if ( $ this -> cannotDecodeJsonApi ( ) ) { return null ; } return $ this -> decoding -> getJsonApiDecoder ( ) -> document ( $ request ) ; }
4808	public function unschedule_specific_event ( $ timestamp = '' ) { if ( empty ( $ timestamp ) ) { $ timestamp = wp_next_scheduled ( $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } wp_unschedule_event ( $ timestamp , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; }
2773	public function fetchTags ( ) : array { $ output = $ this -> gitWorkingCopy -> tag ( [ 'l' => true ] ) ; $ tags = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimTags' ] , $ tags ) ; }
7293	public function save_transit_posts ( $ new_status , $ old_status , $ post ) { $ this -> transit_posts [ $ post -> ID ] = array ( 'old_status' => $ old_status , 'new_status' => $ new_status ) ; }
1574	public function defaultApi ( $ apiName = null ) { if ( is_null ( $ apiName ) ) { return LaravelJsonApi :: $ defaultApi ; } LaravelJsonApi :: defaultApi ( $ apiName ) ; return $ apiName ; }
321	public function normalizePathInfo ( $ pathInfo , $ suffix , & $ normalized = false ) { if ( empty ( $ pathInfo ) ) { return $ pathInfo ; } $ sourcePathInfo = $ pathInfo ; if ( $ this -> collapseSlashes ) { $ pathInfo = $ this -> collapseSlashes ( $ pathInfo ) ; } if ( $ this -> normalizeTrailingSlash === true ) { $ pathInfo = $ this -> normalizeTrailingSlash ( $ pathInfo , $ suffix ) ; } $ normalized = $ sourcePathInfo !== $ pathInfo ; return $ pathInfo ; }
1391	protected function resourceFieldsExistInAttributesAndRelationships ( iterable $ fields ) : void { foreach ( $ fields as $ field ) { $ this -> errors -> add ( $ this -> translator -> resourceFieldExistsInAttributesAndRelationships ( $ field ) ) ; } }
5886	public function resolve ( $ tsdns ) { $ this -> getTransport ( ) -> sendLine ( $ tsdns ) ; $ repl = $ this -> getTransport ( ) -> readLine ( ) ; $ this -> getTransport ( ) -> disconnect ( ) ; if ( $ repl -> section ( ":" , 0 ) -> toInt ( ) == 404 ) { throw new Ts3Exception ( "unable to resolve TSDNS hostname (" . $ tsdns . ")" ) ; } Signal :: getInstance ( ) -> emit ( "tsdnsResolved" , $ tsdns , $ repl ) ; return $ repl ; }
6577	public function getList ( $ sort = null ) { $ countries = $ this -> getCountries ( ) ; $ validSorts = array ( 'name' , 'fullname' , 'iso_3166_2' , 'iso_3166_3' , 'capital' , 'citizenship' , 'currency' , 'currency_code' , 'calling_code' ) ; if ( ! is_null ( $ sort ) && in_array ( $ sort , $ validSorts ) ) { uasort ( $ countries , function ( $ a , $ b ) use ( $ sort ) { if ( ! isset ( $ a [ $ sort ] ) && ! isset ( $ b [ $ sort ] ) ) { return 0 ; } elseif ( ! isset ( $ a [ $ sort ] ) ) { return - 1 ; } elseif ( ! isset ( $ b [ $ sort ] ) ) { return 1 ; } else { return strcasecmp ( $ a [ $ sort ] , $ b [ $ sort ] ) ; } } ) ; } return $ countries ; }
412	public function getPort ( ) { if ( $ this -> _port === null ) { $ serverPort = $ this -> getServerPort ( ) ; $ this -> _port = ! $ this -> getIsSecureConnection ( ) && $ serverPort !== null ? $ serverPort : 80 ; } return $ this -> _port ; }
5434	protected function isStaticMethod ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; if ( ! $ interface -> hasMethod ( $ name ) ) { return false ; } return $ interface -> getMethod ( $ name ) -> isStatic ( ) ; }
1404	public function add ( $ record , array $ relationship , EncodingParametersInterface $ parameters ) { $ related = $ this -> findRelated ( $ record , $ relationship ) ; $ relation = $ this -> getRelation ( $ record , $ this -> key ) ; $ existing = $ relation -> getQuery ( ) -> whereKey ( $ related -> modelKeys ( ) ) -> get ( ) ; $ relation -> saveMany ( $ related -> diff ( $ existing ) ) ; $ record -> refresh ( ) ; return $ record ; }
1392	public function isJsonApi ( $ request , Exception $ e ) { if ( Helpers :: wantsJsonApi ( $ request ) ) { return true ; } $ route = app ( JsonApiService :: class ) -> currentRoute ( ) ; return $ route -> hasCodec ( ) && $ route -> getCodec ( ) -> willEncode ( ) ; }
10263	public function getCreditCard ( $ weighted = true ) { if ( $ weighted ) { $ weight [ ] = [ 'American Express' , 1 ] ; $ weight [ ] = [ 'Discover' , 2 ] ; $ weight [ ] = [ 'MasterCard' , 10 ] ; $ weight [ ] = [ 'Visa' , 10 ] ; foreach ( $ weight as $ w ) { $ type = $ w [ 0 ] ; $ count = $ w [ 1 ] ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ card_types [ ] = $ type ; } } } else { $ card_types = [ 'American Express' , 'Discover' , 'MasterCard' , 'Visa' ] ; } $ cc = new Entities \ CreditCard ; $ cc -> type = $ this -> fromArray ( $ card_types ) ; $ cc -> number = $ this -> getBankNumber ( $ cc -> type ) ; $ cc -> expiration = $ this -> getExpiration ( ) ; return $ cc ; }
5844	public function saveAdditionalFields ( array $ submittedData , \ TYPO3 \ CMS \ Scheduler \ Task \ AbstractTask $ task ) { $ task -> directories = trim ( $ submittedData [ 'scheduler_batchResize_directories' ] ) ; $ task -> excludeDirectories = trim ( $ submittedData [ 'scheduler_batchResize_excludeDirectories' ] ) ; }
463	public function buildAndCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
11275	protected function buildResponse ( ) { $ res = array ( ) ; $ res [ 'type' ] = $ this -> getParameters ( ) -> getType ( ) ; $ res [ 'tid' ] = $ this -> getParameters ( ) -> getTid ( ) ; $ res [ 'action' ] = $ this -> getParameters ( ) -> getAction ( ) ; $ res [ 'method' ] = $ this -> getParameters ( ) -> getMethod ( ) ; $ res [ 'result' ] = $ this -> getResult ( ) ; return $ res ; }
7795	protected function statementBody ( $ text ) { switch ( substr ( $ this -> getLine ( '20' , $ text ) , 0 , 4 ) ) { case '940A' : $ this -> format = self :: FORMAT_CLASSIC ; break ; case '940S' : $ this -> format = self :: FORMAT_STRUCTURED ; break ; default : throw new \ RuntimeException ( 'Unknown file format' ) ; } return parent :: statementBody ( $ text ) ; }
5368	public function asMime ( ) { $ part = 'Content-Disposition: form-data; ' ; $ part .= 'name="' . $ this -> key . '"; ' ; $ part .= 'filename="' . $ this -> filename . '"' ; $ part .= "\r\nContent-Type: " . $ this -> deduceMimeType ( ) ; $ part .= "\r\n\r\n" . $ this -> content ; return $ part ; }
10899	public function save ( bool $ validate = true ) : self { if ( $ validate && $ this -> validate ( ) ) { throw new Exception ( 'Entity ' . $ this -> __getEntityName ( ) . ' data is not valid' ) ; } $ scheme = \ array_keys ( $ this -> getScheme ( ) ) ; foreach ( $ this -> data as $ key => $ value ) { if ( ! \ in_array ( $ key , $ scheme , true ) ) { unset ( $ this -> data [ $ key ] ) ; } } if ( $ this -> getId ( ) ) { $ this -> medoo -> update ( $ this -> getTable ( ) , $ this -> data , [ 'id' => $ this -> getId ( ) ] ) ; } else { $ this -> medoo -> insert ( $ this -> getTable ( ) , $ this -> data ) ; $ this -> setId ( $ this -> medoo -> id ( ) ) ; } $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::save()' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; return $ this ; }
618	private function parseString ( $ value , & $ i ) { $ isQuoted = $ value [ $ i ] === '"' ; $ stringEndChars = $ isQuoted ? [ '"' ] : [ $ this -> delimiter , '}' ] ; $ result = '' ; $ len = strlen ( $ value ) ; for ( $ i += $ isQuoted ? 1 : 0 ; $ i < $ len ; ++ $ i ) { if ( in_array ( $ value [ $ i ] , [ '\\' , '"' ] , true ) && in_array ( $ value [ $ i + 1 ] , [ $ value [ $ i ] , '"' ] , true ) ) { ++ $ i ; } elseif ( in_array ( $ value [ $ i ] , $ stringEndChars , true ) ) { break ; } $ result .= $ value [ $ i ] ; } $ i -= $ isQuoted ? 0 : 1 ; if ( ! $ isQuoted && $ result === 'NULL' ) { $ result = null ; } return $ result ; }
3437	public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ sectionsBackup = isset ( $ this -> fields [ 'IBLOCK_SECTION' ] ) ? $ this -> fields [ 'IBLOCK_SECTION' ] : null ; $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; if ( ! empty ( $ sectionsBackup ) ) { $ this -> fields [ 'IBLOCK_SECTION' ] = $ sectionsBackup ; } $ this -> fieldsAreFetched = true ; $ this -> original = $ this -> fields ; return $ this -> fields ; }
9270	public function load ( ContainerBuilder $ container ) { $ loader = $ this -> getContainerLoader ( $ container ) ; $ loader -> load ( $ this -> configFile ) ; }
88	public function equals ( Rule $ rule ) { if ( $ rule instanceof self ) { if ( $ this -> literal1 !== $ rule -> literal1 ) { return false ; } if ( $ this -> literal2 !== $ rule -> literal2 ) { return false ; } return true ; } $ literals = $ rule -> getLiterals ( ) ; if ( 2 != count ( $ literals ) ) { return false ; } if ( $ this -> literal1 !== $ literals [ 0 ] ) { return false ; } if ( $ this -> literal2 !== $ literals [ 1 ] ) { return false ; } return true ; }
5413	protected function createSocket ( $ scheme , $ host , $ port , $ timeout ) { if ( in_array ( $ scheme , array ( 'file' ) ) ) { return new SimpleFileSocket ( $ this -> url ) ; } elseif ( in_array ( $ scheme , array ( 'https' ) ) ) { return new SimpleSecureSocket ( $ host , $ port , $ timeout ) ; } else { return new SimpleSocket ( $ host , $ port , $ timeout ) ; } }
7632	public function putBlobData ( $ containerName = '' , $ blobName = '' , $ data = '' , $ metadata = array ( ) , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ headers [ Storage :: PREFIX_STORAGE_HEADER . 'blob-type' ] = self :: BLOBTYPE_BLOCK ; $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , array ( ) , 'PUT' , $ headers , false , $ data , self :: RESOURCE_BLOB , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } return new BlobInstance ( $ containerName , $ blobName , null , $ response -> getHeader ( 'Etag' ) , $ response -> getHeader ( 'Last-modified' ) , $ this -> getBaseUrl ( ) . '/' . $ containerName . '/' . $ blobName , strlen ( $ data ) , '' , '' , '' , false , $ metadata ) ; }
10265	public function getPerson ( $ state_code = null ) { $ state_code = ! empty ( $ state_code ) ? $ state_code : $ this -> getState ( ) -> code ; $ person = new Entities \ Person ; $ person -> guid = $ this -> getGuid ( ) ; $ person -> unique_hash = $ this -> getUniqueHash ( ) ; $ person -> name = $ this -> getFullName ( ) ; if ( rand ( 1 , 100 ) % 5 == 0 ) { $ person -> company = $ this -> getCompanyName ( $ person -> name -> last ) ; } else { $ person -> company = $ this -> getCompanyName ( ) ; } $ person -> address = $ this -> getAddress ( $ state_code ) ; $ person -> address2 = $ this -> getAddress ( $ state_code , $ person -> address -> zip ) ; $ person -> internet = $ this -> getInternet ( $ person -> name , $ person -> company ) ; $ person -> phone = new stdclass ( ) ; $ person -> phone -> home = $ this -> getPhone ( $ state_code , $ person -> address -> zip ) ; $ person -> phone -> mobile = $ this -> getPhone ( $ state_code , $ person -> address -> zip ) ; $ person -> phone -> work = $ this -> getPhone ( $ state_code , $ person -> address -> zip ) ; $ person -> ssn = $ this -> getSsn ( $ state_code ) ; $ person -> dln = $ this -> getDln ( $ state_code ) ; $ person -> dob = $ this -> getBirthDate ( ) ; $ person -> credit_card = $ this -> getCreditCard ( ) ; $ person -> bank_account = $ this -> getBank ( ) ; return $ person ; }
7517	function parse_text ( ) { $ len = $ this -> pos - 1 - $ this -> status [ 'last_pos' ] ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ this -> status [ 'last_pos' ] + 1 , $ len ) : '' ) ; }
3439	public function section ( $ load = false ) { $ fields = $ this -> getFields ( ) ; $ sectionModel = static :: sectionModel ( ) ; return $ load ? $ sectionModel :: query ( ) -> getById ( $ fields [ 'IBLOCK_SECTION_ID' ] ) : new $ sectionModel ( $ fields [ 'IBLOCK_SECTION_ID' ] ) ; }
10033	function addUnsubscriptionReasonsToUnsubscribedContact ( $ id , $ checksum = null , $ reasons = null , $ ignore_checksum = false ) { $ queryParameters = array ( ) ; $ queryParameters [ 'id' ] = $ id ; if ( ! empty ( $ checksum ) ) { $ queryParameters [ 'checksum' ] = $ checksum ; } if ( $ ignore_checksum === true ) $ queryParameters [ 'ignore_checksum' ] = "true" ; if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } return $ this -> put ( "contacts/contact/unsubscribe/reasons" , null , $ queryParameters ) ; }
3883	public function getBackendIcon ( $ icon , $ defaultIcon = 'bundles/metamodelscore/images/icons/metamodels.png' ) { $ realIcon = $ this -> convertValueToPath ( $ icon , $ defaultIcon ) ; $ targetPath = $ this -> outputPath . '/' . basename ( $ realIcon ) ; if ( \ file_exists ( $ targetPath ) ) { return $ this -> webPath . '/' . basename ( $ realIcon ) ; } $ this -> imageFactory -> create ( $ realIcon , [ 16 , 16 , 'center_center' ] , $ targetPath ) ; return $ this -> webPath . '/' . basename ( $ realIcon ) ; }
4831	public function retry ( ) { $ endpoint = self :: $ endpoint . '/' . $ this -> id . '/retry' ; return new self ( $ this -> client , $ this -> client -> request ( 'post' , $ endpoint ) ) ; }
11421	public function constructSelectSQL ( $ fields ) { $ sql = array ( ) ; $ sql [ ] = "SELECT" ; $ sql [ ] = "`" . implode ( "`, `" , array_keys ( $ fields ) ) . "`" ; $ sql [ ] = "FROM `" . $ this -> dbtable . "`" ; $ sql [ ] = "WHERE `" . $ this -> pk . "` = " . $ fields [ $ this -> pk ] -> getSQL ( ) ; return implode ( " " , $ sql ) ; }
1399	public function errors ( $ errors , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( $ errors instanceof ErrorResponseInterface ) { return $ this -> getErrorResponse ( $ errors ) ; } if ( is_array ( $ errors ) ) { $ errors = $ this -> api -> getErrors ( ) -> errors ( ... $ errors ) ; } return $ this -> errors ( $ this -> factory -> createErrorResponse ( $ errors , $ defaultStatusCode , $ headers ) ) ; }
5286	private function reset ( ) { $ this -> distinct = false ; $ this -> found_rows = false ; $ this -> limit = null ; $ this -> statements = [ 'select' => [ ] , 'wheres' => [ ] , 'orders' => [ ] , 'values' => [ ] , 'groups' => [ ] , 'having' => '' , ] ; return $ this ; }
8706	public function setLastFolderID ( $ folderID ) { $ request = Controller :: curr ( ) -> getRequest ( ) ; $ session = $ request -> getSession ( ) ; $ session -> set ( get_class ( ) . '.FolderID' , $ folderID ) ; }
2466	protected function welcomeScreen ( ) { System :: loadLanguageFile ( 'explain' ) ; $ objTemplate = new BackendTemplate ( 'be_welcome' ) ; $ objTemplate -> messages = Message :: generateUnwrapped ( ) . Backend :: getSystemMessages ( ) ; $ objTemplate -> loginMsg = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'firstLogin' ] ; if ( $ this -> User -> lastLogin > 0 ) { $ formatter = new DateTimeFormatter ( System :: getContainer ( ) -> get ( 'translator' ) ) ; $ diff = $ formatter -> formatDiff ( new \ DateTime ( date ( 'Y-m-d H:i:s' , $ this -> User -> lastLogin ) ) , new \ DateTime ( ) ) ; $ objTemplate -> loginMsg = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lastLogin' ] [ 1 ] , '<time title="' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ this -> User -> lastLogin ) . '">' . $ diff . '</time>' ) ; } Versions :: addToTemplate ( $ objTemplate ) ; $ objTemplate -> showDifferences = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) ) ; $ objTemplate -> recordOfTable = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] ) ) ; $ objTemplate -> systemMessages = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'systemMessages' ] ; $ objTemplate -> shortcuts = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 0 ] ; $ objTemplate -> shortcutsLink = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 1 ] ; $ objTemplate -> editElement = StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editElement' ] ) ; return $ objTemplate -> parse ( ) ; }
5621	protected function chompScheme ( & $ url ) { if ( preg_match ( '#^([^/:]*):(//)(.*)#' , $ url , $ matches ) ) { $ url = $ matches [ 2 ] . $ matches [ 3 ] ; return $ matches [ 1 ] ; } return false ; }
11314	public static function getNormalizedUrl ( Url $ url ) { $ scheme = $ url -> getScheme ( ) ; $ host = $ url -> getHost ( ) ; $ port = $ url -> getPort ( ) ; $ path = $ url -> getPath ( ) ; if ( ( ( $ port == 80 || empty ( $ port ) ) && strcasecmp ( $ scheme , 'http' ) == 0 ) || ( ( $ port == 443 || empty ( $ port ) ) && strcasecmp ( $ scheme , 'https' ) == 0 ) ) { $ normalizedUrl = $ scheme . '://' . $ host . $ path ; } else { if ( ! empty ( $ port ) ) { $ normalizedUrl = $ scheme . '://' . $ host . ':' . $ port . $ path ; } else { throw new RuntimeException ( 'No port specified' ) ; } } return strtolower ( $ normalizedUrl ) ; }
4634	public function getComputedAttachments ( ) : array { if ( ! $ this -> hasAttachments ( ) ) { return [ ] ; } $ attachments = $ this -> getAttachments ( ) ; $ dir = $ this -> getAttachmentsDir ( ) ; $ path = $ dir [ 'path' ] ?? null ; $ recursive = $ dir [ 'recursive' ] ?? false ; if ( is_string ( $ path ) && is_dir ( $ path ) ) { $ files = $ recursive ? new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ path , RecursiveDirectoryIterator :: SKIP_DOTS ) , RecursiveIteratorIterator :: CHILD_FIRST ) : new DirectoryIterator ( $ path ) ; foreach ( $ files as $ fileInfo ) { if ( $ fileInfo -> isDir ( ) ) { continue ; } $ attachments [ ] = $ fileInfo -> getPathname ( ) ; } } return $ attachments ; }
10403	public function onConsume ( ItemPipelineEvent $ event ) { if ( $ event -> getItemSkip ( ) ) { $ this -> skip ( $ event ) ; } else { $ this -> consume ( $ event ) ; } }
8840	public function setExitCode ( $ exitCode ) { \ Assert \ that ( $ exitCode ) -> integer ( ) -> min ( 0 ) ; $ this -> exitCode = $ exitCode ; return $ this ; }
3199	protected function getRange ( $ tags ) { $ range = $ this -> timeLine -> find ( $ tags , TimePoint :: TARGET_SERVER ) ; TimePoint :: sort ( $ range ) ; return $ range ; }
6241	protected function normalizePathComponents ( ) : array { $ components = [ ] ; $ keys = array_keys ( $ this -> components ) ; $ positionStart = reset ( $ keys ) ; $ positionEnd = end ( $ keys ) ; foreach ( $ this -> components as $ position => $ component ) { $ path = self :: normalize ( $ component , $ position === $ positionStart , $ position === $ positionEnd ) ; $ path = str_replace ( [ '/' , '\\' , DIRECTORY_SEPARATOR . DIRECTORY_SEPARATOR ] , DIRECTORY_SEPARATOR , $ path ) ; if ( $ position === $ positionStart && $ path === DIRECTORY_SEPARATOR ) { $ components [ ] = DIRECTORY_SEPARATOR ; } elseif ( $ position === $ positionStart ) { $ components [ ] = rtrim ( $ path , DIRECTORY_SEPARATOR ) ; } else { $ components [ ] = trim ( $ path , DIRECTORY_SEPARATOR ) ; } } return $ components ; }
5149	protected function getFullEmail ( $ id ) { try { $ response = $ this -> sendRequest ( 'GET' , "/api/v1/inboxes/{$this->config['inbox_id']}/messages/{$id}" ) ; } catch ( Exception $ e ) { $ this -> fail ( 'Exception: ' . $ e -> getMessage ( ) ) ; } $ fullEmail = json_decode ( $ response -> getBody ( ) ) ; return $ fullEmail ; }
11330	public function getMultiline ( ) { if ( is_null ( $ this -> _multiline ) ) { $ this -> _multiline = MultilineDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _multiline ; }
311	private function applyTableAlias ( $ query , $ conditions , $ alias = null ) { if ( $ alias === null ) { $ alias = array_keys ( $ query -> getTablesUsedInFrom ( ) ) [ 0 ] ; } $ prefixedConditions = [ ] ; foreach ( $ conditions as $ columnName => $ columnValue ) { if ( strpos ( $ columnName , '(' ) === false ) { $ columnName = preg_replace ( '/^' . preg_quote ( $ alias ) . '\.(.*)$/' , '$1' , $ columnName ) ; if ( strpos ( $ columnName , '[[' ) === 0 ) { $ prefixedColumn = "{$alias}.{$columnName}" ; } else { $ prefixedColumn = "{$alias}.[[{$columnName}]]" ; } } else { $ prefixedColumn = $ columnName ; } $ prefixedConditions [ $ prefixedColumn ] = $ columnValue ; } return $ prefixedConditions ; }
7511	protected function parse_linebreak ( ) { if ( $ this -> doc [ $ this -> pos ] === "\r" ) { ++ $ this -> line_pos [ 0 ] ; if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === "\n" ) ) { ++ $ this -> pos ; } $ this -> line_pos [ 1 ] = $ this -> pos ; } elseif ( $ this -> doc [ $ this -> pos ] === "\n" ) { ++ $ this -> line_pos [ 0 ] ; $ this -> line_pos [ 1 ] = $ this -> pos ; } }
7828	protected function getSpacesByWord ( $ word ) { $ length = $ this -> getSideBordersLength ( ) + static :: SPACE_FROM_ARROW + static :: ARROW_WIDTH ; $ extra = $ this -> getHalfWidth ( true ) - $ length - strlen ( $ word ) ; return $ extra > 0 ? str_repeat ( ' ' , $ extra ) : '' ; }
11464	public static function error ( $ severity , $ message , $ file , $ line ) { if ( error_reporting ( ) == 0 ) return ; elseif ( error_reporting ( ) && $ severity ) { $ ErrorException = new PHPErrorException ( $ message , 0 , $ severity , $ file , $ line ) ; if ( assert_options ( ASSERT_ACTIVE ) ) { foreach ( $ ErrorException -> getStackTrace ( ) as $ element ) { if ( isset ( $ element [ 'function' ] ) && $ element [ 'function' ] == 'assert' ) { self :: exception ( $ ErrorException ) ; } } } $ recoverable = [ E_WARNING , E_NOTICE , E_USER_WARNING , E_USER_NOTICE , E_STRICT , E_DEPRECATED , E_USER_DEPRECATED ] ; if ( in_array ( $ severity , $ recoverable ) ) { return ; } throw $ ErrorException ; } }
6234	protected function applyAccessMode ( int $ mode ) : void { if ( $ this -> mode === self :: MODE_CLOSED ) { $ this -> mode = $ mode ; return ; } elseif ( $ mode === $ this -> mode ) { return ; } throw new AccessDeniedException ( 'unable to switch access-mode for existing binary file handle' , 500 ) ; }
9043	protected function logImpl ( $ level , $ message , array $ context = array ( ) ) { if ( ! $ this -> levelHasReached ( $ level ) ) { return ; } if ( $ this -> isRotationNeeded ( ) ) { unlink ( $ this -> file ) ; } $ ms = $ this -> getMessage ( $ level , $ message , $ context ) ; $ fos = new FileOutputStream ( $ this -> file , true ) ; $ fos -> write ( $ ms ) ; $ fos -> flush ( ) ; $ fos -> close ( ) ; }
9966	public function fromArray ( array $ source , $ nullValue = null , $ startCell = 'A1' , $ strictNullComparison = false ) { if ( ! is_array ( end ( $ source ) ) ) { $ source = [ $ source ] ; } list ( $ startColumn , $ startRow ) = Coordinate :: coordinateFromString ( $ startCell ) ; foreach ( $ source as $ rowData ) { $ currentColumn = $ startColumn ; foreach ( $ rowData as $ cellValue ) { if ( $ strictNullComparison ) { if ( $ cellValue !== $ nullValue ) { $ this -> getCell ( $ currentColumn . $ startRow ) -> setValue ( $ cellValue ) ; } } else { if ( $ cellValue != $ nullValue ) { $ this -> getCell ( $ currentColumn . $ startRow ) -> setValue ( $ cellValue ) ; } } ++ $ currentColumn ; } ++ $ startRow ; } return $ this ; }
5594	protected function createRequest ( $ url , $ encoding ) { $ request = $ this -> createHttpRequest ( $ url , $ encoding ) ; $ this -> addAdditionalHeaders ( $ request ) ; if ( $ this -> cookies_enabled ) { $ request -> readCookiesFromJar ( $ this -> cookie_jar , $ url ) ; } $ this -> authenticator -> addHeaders ( $ request , $ url ) ; if ( $ this -> http_referer ) { $ headers = $ request -> getHeaders ( ) ; if ( is_array ( $ headers ) ) { $ custom_referer = false ; foreach ( $ headers as $ header ) { if ( preg_match ( '~^referer:~i' , $ header ) ) { $ custom_referer = true ; break ; } } if ( ! $ custom_referer ) { $ request -> addHeaderLine ( 'Referer: ' . $ this -> http_referer ) ; } } } return $ request ; }
4859	public function getNeighbours ( $ namespace , $ callback , $ id ) { $ list = $ this -> getList ( $ namespace , $ callback ) ; $ list -> setCurrent ( $ id ) ; return [ $ list -> getPrevious ( ) , $ list -> getNext ( ) ] ; }
8806	protected function ensureFacadeExists ( $ alias ) { if ( file_exists ( $ path = storage_path ( 'cache/facade-' . sha1 ( $ alias ) . '.php' ) ) ) { return $ path ; } file_put_contents ( $ path , $ this -> formatFacadeStub ( $ alias , file_get_contents ( __DIR__ . '/stubs/facade.stub' ) ) ) ; return $ path ; }
761	public function getSql ( ) { $ code = $ this ; while ( $ code -> parent !== null ) { $ code = $ code -> parent ; } return mb_substr ( $ code -> content , $ this -> startOffset , $ this -> endOffset - $ this -> startOffset , 'UTF-8' ) ; }
6689	public function setSessionAndRedirect ( $ key , $ value , $ redirectUrl ) { $ this -> getSession ( ) -> set ( $ key , $ value ) ; return $ this -> redirect ( $ redirectUrl ) ; }
5182	private function fillSource ( $ source , $ photo ) : string { if ( ! empty ( $ source ) ) { return $ this -> filterUriInstance ( $ source ) ; } return ( string ) $ photo ; }
12805	private static function getColumnName ( string $ name ) : ? string { $ class = self :: getStaticChildClass ( ) ; if ( self :: $ columnPropertiesCache === null || ! array_key_exists ( $ class , self :: $ columnPropertiesCache ) || self :: $ columnPropertiesCache [ $ class ] === null ) self :: buildColumnPropertiesCache ( ) ; if ( array_key_exists ( $ name , self :: $ columnPropertiesCache [ $ class ] ) ) return $ name ; foreach ( self :: $ columnPropertiesCache [ $ class ] as $ column => $ properties ) { if ( in_array ( $ name , $ properties ) ) return $ column ; } return null ; }
8630	public function setGetLowestOfferListingsForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetLowestOfferListingsForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11186	public function setPrivateChatUpdateRead ( Neuron_GameServer_Player $ from , Neuron_GameServer_Player $ target ) { $ db = Neuron_DB_Database :: getInstance ( ) ; $ db -> query ( " UPDATE n_privatechat_updates SET pu_read = '1' WHERE pu_to = {$target->getId ()} AND pu_from = {$from->getId ()} " ) ; }
8573	public function listRecommendationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsByNextTokenRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsByNextTokenResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3946	private function handleMetaModelTable ( $ tableName ) { static $ tableNames ; if ( ! $ tableNames ) { $ tableNames = $ this -> factory -> collectNames ( ) ; } if ( ! in_array ( $ tableName , $ tableNames ) ) { return ; } $ this -> controller -> loadLanguageFile ( 'tl_metamodel_item' ) ; $ this -> controller -> loadDataContainer ( 'tl_metamodel_item' ) ; if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] ) ) { $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] = [ ] ; } $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] = array_replace_recursive ( ( array ) $ GLOBALS [ 'TL_DCA' ] [ 'tl_metamodel_item' ] , ( array ) $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] ) ; }
2912	public function formatNumber ( $ number , $ precision = 2 ) { $ locale = Mage :: app ( ) -> getLocale ( ) -> getLocale ( ) ; return Zend_Locale_Format :: toNumber ( $ number , array ( 'locale' => $ locale , 'precision' => $ precision ) ) ; }
11854	public function getHeader ( string $ name ) : ? string { $ name = strtolower ( $ name ) ; foreach ( $ this -> getAllHeaders ( ) as $ key => $ value ) { if ( strtolower ( $ key ) === $ name ) { return $ value ; } } return null ; }
4129	public function createQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new ODMQuery ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; $ query -> setDocumentManager ( $ this ) ; return $ query ; }
10704	public function getModel ( ) { if ( null === $ this -> model ) { $ mainService = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ this -> model = $ mainService -> getUserEntityRepository ( ) ; } return $ this -> model ; }
9552	public function allowMimeTypes ( $ mimeTypes ) { if ( ! is_array ( $ mimeTypes ) ) { $ mimeTypes = [ $ mimeTypes ] ; } $ this -> constraints [ ] = new MimeTypeConstraint ( $ mimeTypes ) ; return $ this ; }
11271	public function render ( $ template , array $ vars = array ( ) ) { ob_start ( ) ; try { $ this -> display ( $ template , $ vars ) ; } catch ( Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } return ob_get_clean ( ) ; }
1039	private static function printPath ( ? array $ path = null ) { $ pathStr = '' ; $ currentPath = $ path ; while ( $ currentPath ) { $ pathStr = ( is_string ( $ currentPath [ 'key' ] ) ? '.' . $ currentPath [ 'key' ] : '[' . $ currentPath [ 'key' ] . ']' ) . $ pathStr ; $ currentPath = $ currentPath [ 'prev' ] ; } return $ pathStr ? 'value' . $ pathStr : '' ; }
5094	public function executeIterator ( ) { $ result = $ this -> execute ( ) ; if ( ! $ result ) throw new MySqlException ( 'Could not execute multiset query!' ) ; while ( true ) { yield new StatementResult ( $ result ) ; if ( ! $ result -> nextRowset ( ) ) { $ this -> checkForError ( $ result ) ; break ; } } }
2426	protected static function isFileSyncExclude ( $ strPath ) { if ( Config :: get ( 'uploadPath' ) == 'templates' ) { return true ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; while ( $ strPath != '.' && ! is_dir ( $ rootDir . '/' . $ strPath ) ) { $ strPath = \ dirname ( $ strPath ) ; } if ( $ strPath == '.' ) { return true ; } $ uploadPath = System :: getContainer ( ) -> getParameter ( 'contao.upload_path' ) ; if ( strncmp ( $ strPath . '/' , $ uploadPath . '/' , \ strlen ( $ uploadPath ) + 1 ) !== 0 ) { return true ; } return ( new Folder ( $ strPath ) ) -> isUnsynchronized ( ) ; }
1136	public function setDepth ( ) { $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ level = $ self -> getLevel ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ self -> getKeyName ( ) , '=' , $ self -> getKey ( ) ) -> update ( array ( $ self -> getDepthColumnName ( ) => $ level ) ) ; $ self -> setAttribute ( $ self -> getDepthColumnName ( ) , $ level ) ; } ) ; return $ this ; }
11339	public function getModuleSetModules ( ) { if ( empty ( $ this -> moduleSet ) || ! isset ( Yii :: $ app -> extensions [ $ this -> moduleSet ] ) ) { return '' ; } $ bsClass = Yii :: $ app -> extensions [ $ this -> moduleSet ] [ 'bootstrap' ] ; $ p = [ ] ; $ bs = new $ bsClass ( ) ; $ modules = $ bs -> getModules ( ) ; $ modules [ $ this -> moduleID ] = [ 'class' => $ this -> moduleClass ] ; foreach ( $ modules as $ id => $ module ) { $ e = '$m[\'' . $ id . '\'] = [' ; if ( ! is_array ( $ module ) ) { $ module = [ 'class' => $ module ] ; } $ n = 0 ; foreach ( $ module as $ k => $ v ) { $ e .= "\n\t\t\t'{$k}' => " ; if ( is_string ( $ v ) ) { $ e .= "'" . addslashes ( $ v ) . "'" ; } elseif ( is_numeric ( $ v ) ) { $ e .= $ v ; } $ n ++ ; if ( $ n !== count ( $ module ) ) { $ e .= ',' ; } } $ e .= "\n\t\t];" ; $ p [ ] = $ e ; } return implode ( "\n\t\t" , $ p ) ; }
826	public function isBeforeStructuralElement ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_COMMENT , T_DOC_COMMENT ] ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ nextIndex = $ index ; do { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ; } while ( null !== $ nextIndex && $ tokens [ $ nextIndex ] -> equals ( '(' ) ) ; if ( null === $ nextIndex || $ tokens [ $ nextIndex ] -> equals ( '}' ) ) { return false ; } $ nextToken = $ tokens [ $ nextIndex ] ; if ( $ this -> isStructuralElement ( $ nextToken ) ) { return true ; } if ( $ this -> isValidControl ( $ tokens , $ token , $ nextIndex ) ) { return true ; } if ( $ this -> isValidVariable ( $ tokens , $ nextIndex ) ) { return true ; } if ( $ this -> isValidLanguageConstruct ( $ tokens , $ token , $ nextIndex ) ) { return true ; } return false ; }
7435	public function scan ( ) { $ files = $ this -> extensionsFile ( $ this -> files ) ; foreach ( $ files as $ file ) { $ content = file_get_contents ( $ file ) ; if ( str_contains ( $ file , '.php' ) && ! str_contains ( $ file , $ this -> exceptionsValid ) && ! $ this -> checkForValidPhp ( $ content ) ) { $ this -> notValid [ ] = $ file ; } if ( str_contains ( $ content , $ this -> signatures ) ) { $ this -> dangerFiles [ ] = $ file ; } } return $ this ; }
8985	public function isComparable ( TableNode $ expected , TableNode $ actual , array $ diff_options , $ message = NULL ) { $ this -> doAssert ( 'Failed comparing two tables: ' , $ diff_options , $ expected , $ actual , $ message ) ; }
10256	public function getState ( $ state_code = null ) { if ( ! empty ( $ state_code ) ) { $ res = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } else { $ res = Zipcode :: orderByRaw ( Database :: random ( ) ) -> first ( ) ; } $ State = new Entities \ State ; $ State -> code = $ res -> state_code ; $ State -> name = $ res -> state ; return $ State ; }
6851	public static function fuzzySpan ( $ timestamp , $ local_timestamp = null ) { $ local_timestamp = ( $ local_timestamp === null ) ? time ( ) : ( int ) $ local_timestamp ; $ offset = abs ( $ local_timestamp - $ timestamp ) ; if ( $ offset <= static :: MINUTE ) { $ span = 'moments' ; } elseif ( $ offset < ( static :: MINUTE * 20 ) ) { $ span = 'a few minutes' ; } elseif ( $ offset < static :: HOUR ) { $ span = 'less than an hour' ; } elseif ( $ offset < ( static :: HOUR * 4 ) ) { $ span = 'a couple of hours' ; } elseif ( $ offset < static :: DAY ) { $ span = 'less than a day' ; } elseif ( $ offset < ( static :: DAY * 2 ) ) { $ span = 'about a day' ; } elseif ( $ offset < ( static :: DAY * 4 ) ) { $ span = 'a couple of days' ; } elseif ( $ offset < static :: WEEK ) { $ span = 'less than a week' ; } elseif ( $ offset < ( static :: WEEK * 2 ) ) { $ span = 'about a week' ; } elseif ( $ offset < static :: MONTH ) { $ span = 'less than a month' ; } elseif ( $ offset < ( static :: MONTH * 2 ) ) { $ span = 'about a month' ; } elseif ( $ offset < ( static :: MONTH * 4 ) ) { $ span = 'a couple of months' ; } elseif ( $ offset < static :: YEAR ) { $ span = 'less than a year' ; } elseif ( $ offset < ( static :: YEAR * 2 ) ) { $ span = 'about a year' ; } elseif ( $ offset < ( static :: YEAR * 4 ) ) { $ span = 'a couple of years' ; } elseif ( $ offset < ( static :: YEAR * 8 ) ) { $ span = 'a few years' ; } elseif ( $ offset < ( static :: YEAR * 12 ) ) { $ span = 'about a decade' ; } elseif ( $ offset < ( static :: YEAR * 24 ) ) { $ span = 'a couple of decades' ; } elseif ( $ offset < ( static :: YEAR * 64 ) ) { $ span = 'several decades' ; } else { $ span = 'a long time' ; } if ( $ timestamp <= $ local_timestamp ) { return $ span . ' ago' ; } else { return 'in ' . $ span ; } }
3113	public function setStoreId ( $ testSessionId , $ storeId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setStoreId ( $ storeId ) ; $ extendedState -> save ( ) ; }
10143	private function readTextObject ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( $ this -> readDataOnly ) { return ; } $ grbitOpts = self :: getUInt2d ( $ recordData , 0 ) ; $ rot = self :: getUInt2d ( $ recordData , 2 ) ; $ cchText = self :: getUInt2d ( $ recordData , 10 ) ; $ cbRuns = self :: getUInt2d ( $ recordData , 12 ) ; $ text = $ this -> getSplicedRecordData ( ) ; $ textByte = $ text [ 'spliceOffsets' ] [ 1 ] - $ text [ 'spliceOffsets' ] [ 0 ] - 1 ; $ textStr = substr ( $ text [ 'recordData' ] , $ text [ 'spliceOffsets' ] [ 0 ] + 1 , $ textByte ) ; $ is16Bit = ord ( $ text [ 'recordData' ] [ 0 ] ) ; if ( ( $ is16Bit & 0x01 ) === 0 ) { $ textStr = StringHelper :: ConvertEncoding ( $ textStr , 'UTF-8' , 'ISO-8859-1' ) ; } else { $ textStr = $ this -> decodeCodepage ( $ textStr ) ; } $ this -> textObjects [ $ this -> textObjRef ] = [ 'text' => $ textStr , 'format' => substr ( $ text [ 'recordData' ] , $ text [ 'spliceOffsets' ] [ 1 ] , $ cbRuns ) , 'alignment' => $ grbitOpts , 'rotation' => $ rot , ] ; }
10949	protected function loadCsrfToken ( ) { if ( $ this -> enableCsrfCookie ) { return $ this -> getCookies ( ) -> getValue ( $ this -> csrfParam ) ; } else { return Yii :: $ app -> getSession ( ) -> get ( $ this -> csrfParam ) ; } }
103	protected function pruneToHighestPriorityOrInstalled ( Pool $ pool , array $ installedMap , array $ literals ) { $ selected = array ( ) ; $ priority = null ; foreach ( $ literals as $ literal ) { $ package = $ pool -> literalToPackage ( $ literal ) ; if ( isset ( $ installedMap [ $ package -> id ] ) ) { $ selected [ ] = $ literal ; continue ; } if ( null === $ priority ) { $ priority = $ this -> getPriority ( $ pool , $ package ) ; } if ( $ this -> getPriority ( $ pool , $ package ) != $ priority ) { break ; } $ selected [ ] = $ literal ; } return $ selected ; }
10828	public static function sanitizeName ( string $ name ) : string { $ basename = basename ( $ name ) ; $ dir = ( $ basename === $ name ) ? null : dirname ( $ name ) ; $ basename = preg_replace ( "/[^a-zA-Z0-9-_.]/" , "_" , $ basename ) ; return ( $ dir === null ) ? $ basename : "$dir/$basename" ; }
1385	protected function memberRequired ( string $ path , string $ member ) : void { $ this -> errors -> add ( $ this -> translator -> memberRequired ( $ path , $ member ) ) ; }
752	public function addRateLimitHeaders ( $ response , $ limit , $ remaining , $ reset ) { if ( $ this -> enableRateLimitHeaders ) { $ response -> getHeaders ( ) -> set ( 'X-Rate-Limit-Limit' , $ limit ) -> set ( 'X-Rate-Limit-Remaining' , $ remaining ) -> set ( 'X-Rate-Limit-Reset' , $ reset ) ; } }
1954	public static function findExpiredSubscriptions ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE active='' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn<=? AND o.confirmedOn=0)" ) -> execute ( strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } return static :: createCollectionFromDbResult ( $ objResult , $ t ) ; }
4675	public function addString ( $ content , $ region = "main" , $ sort = 0 ) { $ view = new View ( ) ; $ view -> set ( $ content , [ ] , $ sort , "string" ) ; $ this -> views [ $ region ] [ ] = $ view ; return $ this ; }
9586	public function scaffoldFormField ( $ title = null , $ params = null ) { $ field = new ExternalURLField ( $ this -> name , $ title ) ; $ field -> setMaxLength ( $ this -> getSize ( ) ) ; return $ field ; }
8750	public static function dumpValue ( $ value , $ containerVariable , array $ usedVariables ) : InlineEntryInterface { if ( is_array ( $ value ) ) { return self :: dumpArray ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( $ value instanceof ReferenceInterface ) { return self :: dumpReference ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( $ value instanceof DumpableInterface ) { return self :: dumpDefinition ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( is_object ( $ value ) || is_resource ( $ value ) ) { throw new \ RuntimeException ( 'Unable to dump a container if a parameter is an object or a resource.' ) ; } else { return new InlineEntry ( var_export ( $ value , true ) , null , $ usedVariables , false ) ; } }
8208	public function getPheanstalk ( ) { if ( ! $ this -> pheanstalk ) { $ this -> pheanstalk = new Pheanstalk ( $ this -> host , $ this -> port ) ; } return $ this -> pheanstalk ; }
2950	private function failedDispatch ( $ queue , \ Exception $ error ) { foreach ( $ queue as $ index => $ data ) { $ this -> clear ( $ data [ 'key' ] ) ; $ data [ 'reject' ] ( $ error ) ; } }
4367	protected function emailErr ( Event $ error ) { $ dateTimeFmt = 'Y-m-d H:i:s (T)' ; $ errMsg = $ error [ 'message' ] ; if ( $ error [ 'isHtml' ] ) { $ errMsg = \ strip_tags ( $ errMsg ) ; $ errMsg = \ htmlspecialchars_decode ( $ errMsg ) ; } $ countSince = $ error [ 'stats' ] [ 'countSince' ] ; $ isCli = $ this -> isCli ( ) ; $ subject = $ isCli ? 'Error: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) : 'Website Error: ' . $ _SERVER [ 'SERVER_NAME' ] ; $ subject .= ': ' . $ errMsg . ( $ countSince ? ' (' . $ countSince . 'x)' : '' ) ; $ emailBody = '' ; if ( ! empty ( $ countSince ) ) { $ dateTimePrev = \ date ( $ dateTimeFmt , $ error [ 'stats' ] [ 'tsEmailed' ] ) ; $ emailBody .= 'Error has occurred ' . $ countSince . ' times since last email (' . $ dateTimePrev . ').' . "\n\n" ; } $ emailBody .= '' . 'datetime: ' . \ date ( $ dateTimeFmt ) . "\n" . 'errormsg: ' . $ errMsg . "\n" . 'errortype: ' . $ error [ 'type' ] . ' (' . $ error [ 'typeStr' ] . ')' . "\n" . 'file: ' . $ error [ 'file' ] . "\n" . 'line: ' . $ error [ 'line' ] . "\n" . '' ; if ( ! $ isCli ) { $ emailBody .= '' . 'remote_addr: ' . $ _SERVER [ 'REMOTE_ADDR' ] . "\n" . 'http_host: ' . $ _SERVER [ 'HTTP_HOST' ] . "\n" . 'referer: ' . ( isset ( $ _SERVER [ 'HTTP_REFERER' ] ) ? $ _SERVER [ 'HTTP_REFERER' ] : 'null' ) . "\n" . 'request_uri: ' . $ _SERVER [ 'REQUEST_URI' ] . "\n" . '' ; } if ( ! empty ( $ _POST ) ) { $ emailBody .= 'post params: ' . \ var_export ( $ _POST , true ) . "\n" ; } if ( $ error [ 'type' ] & $ this -> cfg [ 'emailTraceMask' ] ) { $ backtraceStr = $ this -> backtraceStr ( $ error ) ; $ emailBody .= "\n" . ( $ backtraceStr ? 'backtrace: ' . $ backtraceStr : 'no backtrace' ) ; } $ this -> email ( $ this -> cfg [ 'emailTo' ] , $ subject , $ emailBody ) ; return ; }
3561	protected function getMutatedType ( $ value , $ dir = 'setter' ) { foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ this -> getValueType ( $ value ) == $ mutated || $ value instanceof $ mutated ) { return $ mutated ; } } }
1812	public function getForms ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> forms ) ) { return array ( ) ; } $ arrForms = array ( ) ; $ objForms = $ this -> Database -> execute ( "SELECT id, title FROM tl_form ORDER BY title" ) ; while ( $ objForms -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objForms -> id , 'forms' ) ) { $ arrForms [ $ objForms -> id ] = $ objForms -> title . ' (ID ' . $ objForms -> id . ')' ; } } return $ arrForms ; }
5857	protected function localize ( $ input ) { if ( TYPO3_MODE === 'FE' ) { $ output = is_object ( $ GLOBALS [ 'TSFE' ] ) ? $ GLOBALS [ 'TSFE' ] -> sL ( $ input ) : $ input ; } else { $ output = $ GLOBALS [ 'LANG' ] -> sL ( $ input ) ; } return $ output ; }
12408	protected function load ( ) { $ this -> config = array ( ) ; if ( file_exists ( $ this -> filePath ) ) { $ this -> config = Yaml :: parse ( $ this -> filePath ) ; } }
286	public function remove ( $ name ) { $ name = strtolower ( $ name ) ; if ( isset ( $ this -> _headers [ $ name ] ) ) { $ value = $ this -> _headers [ $ name ] ; unset ( $ this -> _headers [ $ name ] ) ; return $ value ; } return null ; }
245	public function getColumn ( $ name ) { return isset ( $ this -> columns [ $ name ] ) ? $ this -> columns [ $ name ] : null ; }
4625	public function prepare ( Command $ command , Node $ node ) { if ( $ this -> connection ) { $ this -> resetConnection ( ) ; } parent :: prepare ( $ command , $ node ) ; $ this -> buildPath ( ) ; $ this -> prepareConnection ( ) ; $ this -> prepareRequest ( ) ; return $ this ; }
10302	private function writePrintSettings ( $ objWriter ) { $ objWriter -> startElement ( 'c:printSettings' ) ; $ objWriter -> startElement ( 'c:headerFooter' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:pageMargins' ) ; $ objWriter -> writeAttribute ( 'footer' , 0.3 ) ; $ objWriter -> writeAttribute ( 'header' , 0.3 ) ; $ objWriter -> writeAttribute ( 'r' , 0.7 ) ; $ objWriter -> writeAttribute ( 'l' , 0.7 ) ; $ objWriter -> writeAttribute ( 't' , 0.75 ) ; $ objWriter -> writeAttribute ( 'b' , 0.75 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:pageSetup' ) ; $ objWriter -> writeAttribute ( 'orientation' , 'portrait' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
10492	public function sub ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value - $ value ) ; }
6409	public static function concat ( IteratorAggregate $ a , IteratorAggregate $ b ) : IteratorAggregate { return self :: from ( Iterators :: concat ( Iterators :: from ( $ a -> getIterator ( ) ) , Iterators :: from ( $ b -> getIterator ( ) ) ) ) ; }
11876	public static function getDump ( $ var , $ maxSize = null ) { $ trace = debug_backtrace ( ) ; $ dump = '' ; $ dump .= static :: getHeader ( 'Dump de variable' ) ; $ dump .= '<div class="dump_segment">Contexte</div>' ; if ( count ( $ trace ) > 2 ) { $ dump .= static :: getContext ( $ trace [ 1 ] , $ trace [ 2 ] ) ; } else { $ dump .= static :: getContext ( $ trace [ 1 ] ) ; } if ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\common\sgbd\Query' ) { $ dump .= '<div class="dump_segment">Requête SQL</div>'; $ dump .= '<div class="dump_segment_content"><pre>' . $ var -> getSql ( ) . '</pre></div>' ; } $ dump .= '<div class="dump_segment">Exploration de la variable</div>' ; $ dump .= '<div class="dump_segment_content"><pre>' ; if ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\framework\query\Query' ) { $ dump .= static :: getDumpQueryResult ( $ var -> getQueryResults ( ) ) ; } elseif ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\framework\query\QueryResult' ) { $ dump .= static :: getDumpQueryResult ( $ var ) ; } else { $ dump .= static :: getDumpContent ( $ var , $ maxSize ) ; } $ dump .= '</pre></div>' ; $ dump .= static :: getFooter ( ) ; return $ dump ; }
3005	static public function ping ( \ Base $ f3 , $ params ) { $ hash = $ params [ 'hash' ] ; if ( $ f3 -> exists ( 'mailer.on.ping' , $ ping_handler ) ) $ f3 -> call ( $ ping_handler , array ( $ hash ) ) ; $ img = new \ Image ( ) ; $ img -> load ( base64_decode ( 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMA' . 'AAAl21bKAAAABGdBTUEAALGPC/xhBQAAAANQTFRFAAAAp3o92gAAAAF0U' . 'k5TAEDm2GYAAAAKSURBVAjXY2AAAAACAAHiIbwzAAAAAElFTkSuQmCC' ) ) ; $ img -> render ( ) ; }
2924	public function formatSetterLine ( $ key , $ value = null , $ comment = null , $ export = false ) { $ forceQuotes = ( strlen ( $ comment ) > 0 && strlen ( trim ( $ value ) ) == 0 ) ; $ value = $ this -> formatValue ( $ value , $ forceQuotes ) ; $ key = $ this -> formatKey ( $ key ) ; $ comment = $ this -> formatComment ( $ comment ) ; $ export = $ export ? 'export ' : '' ; $ line = "{$export}{$key}={$value}{$comment}" ; return $ line ; }
12149	public function getReservedCodes ( ) { $ reserved = [ ] ; foreach ( $ this -> factories as $ factoryClass => $ factory ) { $ reserved [ $ factoryClass ] = $ factory -> getReservedDiapason ( ) ; } return $ reserved ; }
3705	public function handle ( CreateMetaModelEvent $ event ) { if ( null === $ metaModel = $ event -> getMetaModel ( ) ) { return ; } foreach ( $ this -> attributeFactory -> createAttributesForMetaModel ( $ metaModel ) as $ attribute ) { $ metaModel -> addAttribute ( $ attribute ) ; } }
4327	public static function isList ( $ val ) { if ( ! \ is_array ( $ val ) ) { return false ; } $ keys = \ array_keys ( $ val ) ; foreach ( $ keys as $ i => $ key ) { if ( $ i != $ key ) { return false ; } } return true ; }
4822	public function set ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> addField ( $ name , $ value ) ; } else { $ this -> row [ $ name ] = $ value ; } $ this -> informChanges ( ) ; }
7765	private function documentClassProperties ( \ ML \ HydraBundle \ Mapping \ ClassMetadata $ class ) { $ result = array ( ) ; $ propertyDomain = $ this -> getTypeReferenceIri ( $ class -> getName ( ) ) ; foreach ( $ class -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( '@' , $ property -> getExposeAs ( ) , 1 ) ) { continue ; } $ result [ ] = array ( 'property' => ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : array ( '@id' => 'vocab:' . $ property -> getIri ( ) , '@type' => ( $ property -> getRoute ( ) ) ? 'hydra:Link' : 'rdf:Property' , 'label' => $ property -> getTitle ( ) , 'description' => $ property -> getDescription ( ) , 'domain' => $ propertyDomain , 'range' => $ this -> getTypeReferenceIri ( $ property -> getType ( ) ) , 'supportedOperation' => $ this -> documentOperations ( $ property -> getOperations ( ) ) ) , 'hydra:title' => $ property -> getTitle ( ) , 'hydra:description' => $ property -> getDescription ( ) , 'required' => $ property -> getRequired ( ) , 'readonly' => $ property -> isReadOnly ( ) , 'writeonly' => $ property -> isWriteOnly ( ) ) ; } return $ result ; }
7865	protected function drawBordered ( $ content ) { $ left = $ this -> geometry -> getLeftBordersWith ( static :: BORDER_X ) ; $ right = $ this -> geometry -> getRightBordersWith ( static :: BORDER_X ) ; $ this -> drawRow ( $ left . $ content . $ right ) ; }
5957	public function channelGetByName ( $ name ) { foreach ( $ this -> channelList ( ) as $ channel ) { if ( $ channel [ "channel_name" ] == $ name ) { return $ channel ; } } throw new Ts3Exception ( "invalid channelID" , 0x300 ) ; }
1956	public function styleSheetLink ( Contao \ DataContainer $ dc ) { return ' <a href="contao/main.php?do=themes&amp;table=tl_style_sheet&amp;id=' . $ dc -> activeRecord -> pid . '&amp;popup=1&amp;nb=1&amp;rt=' . REQUEST_TOKEN . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_styles' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . Contao \ StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_styles' ] ) ) . '\',\'url\':this.href});return false">' . Contao \ Image :: getHtml ( 'edit.svg' ) . '</a>' ; }
10310	function getUniqueOpensCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousOpens = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousOpens ) ) $ params [ 'exclude_anonymous_opens' ] = ( $ excludeAnonymousOpens == true ) ? "true" : "false" ; return $ this -> get ( 'reports/opens/unique/count' , $ params ) ; }
3553	protected function set ( $ key , $ value , $ group = 'default' ) { $ this -> setMetaKey ( $ key ) ; $ this -> setValue ( $ value ) ; $ this -> setMetaGroup ( $ group ) ; }
8825	protected function valid_cc ( $ data ) { $ number = preg_replace ( '/\D/' , '' , $ data ) ; if ( function_exists ( 'mb_strlen' ) ) { $ number_length = mb_strlen ( $ number ) ; } else { $ number_length = strlen ( $ number ) ; } $ parity = $ number_length % 2 ; $ total = 0 ; for ( $ i = 0 ; $ i < $ number_length ; $ i ++ ) { $ digit = $ number [ $ i ] ; if ( $ i % 2 == $ parity ) { $ digit *= 2 ; if ( $ digit > 9 ) { $ digit -= 9 ; } } $ total += $ digit ; } return ( $ total % 10 == 0 ) ? true : false ; }
12161	public function getIsChildless ( ) { if ( empty ( $ this -> collectorItem ) || empty ( $ this -> collectorItem -> children ) ) { return true ; } return false ; }
84	public static function expandPath ( $ path ) { if ( preg_match ( '#^~[\\/]#' , $ path ) ) { return self :: getUserDirectory ( ) . substr ( $ path , 1 ) ; } return preg_replace_callback ( '#^(\$|(?P<percent>%))(?P<var>\w++)(?(percent)%)(?P<path>.*)#' , function ( $ matches ) { if ( Platform :: isWindows ( ) && $ matches [ 'var' ] == 'HOME' ) { return ( getenv ( 'HOME' ) ? : getenv ( 'USERPROFILE' ) ) . $ matches [ 'path' ] ; } return getenv ( $ matches [ 'var' ] ) . $ matches [ 'path' ] ; } , $ path ) ; }
1041	public function wait ( Promise $ promise ) { $ this -> beforeWait ( $ promise ) ; $ dfdQueue = Deferred :: getQueue ( ) ; $ promiseQueue = SyncPromise :: getQueue ( ) ; while ( $ promise -> adoptedPromise -> state === SyncPromise :: PENDING && ! ( $ dfdQueue -> isEmpty ( ) && $ promiseQueue -> isEmpty ( ) ) ) { Deferred :: runQueue ( ) ; SyncPromise :: runQueue ( ) ; $ this -> onWait ( $ promise ) ; } $ syncPromise = $ promise -> adoptedPromise ; if ( $ syncPromise -> state === SyncPromise :: FULFILLED ) { return $ syncPromise -> result ; } if ( $ syncPromise -> state === SyncPromise :: REJECTED ) { throw $ syncPromise -> result ; } throw new InvariantViolation ( 'Could not resolve promise' ) ; }
9761	function containOnlyInstancesOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , containsOnlyInstancesOf ( $ className ) ) ; }
1370	protected function bindExceptionParser ( ) { $ this -> app -> singleton ( ExceptionParserInterface :: class , ExceptionParser :: class ) ; $ this -> app -> alias ( ExceptionParserInterface :: class , 'json-api.exceptions' ) ; }
9441	public function get ( ) { if ( $ this -> range -> as_integer ) { return mt_rand ( $ this -> range -> min , $ this -> range -> max ) ; } else { return mt_rand ( 0 , mt_getrandmax ( ) ) / mt_getrandmax ( ) ; } }
4279	public function stream_seek ( $ offset , $ whence = SEEK_SET ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ fseek ( $ this -> handle , $ offset , $ whence ) ; $ success = $ result !== - 1 ; self :: register ( ) ; return $ success ; }
7069	static function isValid ( $ unit , $ throw = false ) { if ( in_array ( $ unit , static :: getUnits ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Invalid unit '$unit'." ) ; } return false ; }
9479	public function respondWithMessage ( $ message = null ) { $ res [ 'status' ] = $ this -> getStatusText ( ) ; if ( $ this -> getErrorCode ( ) ) { $ res [ 'error' ] = $ this -> getErrorCode ( ) ; if ( is_null ( $ message ) ) $ res [ 'message' ] = $ this -> getErrorMessage ( ) ; else $ res [ 'message' ] = $ message ; } else { $ res [ 'message' ] = $ message ; } return $ this -> respond ( $ res ) ; }
6699	public function setBuild ( $ build ) { $ this -> build = array_values ( ( array ) $ build ) ; array_walk ( $ this -> build , function ( & $ v ) { if ( preg_match ( '/^[0-9]+$/' , $ v ) ) { $ v = ( int ) $ v ; } } ) ; }
450	public static function encode ( $ value , $ options = 320 ) { $ expressions = [ ] ; $ value = static :: processData ( $ value , $ expressions , uniqid ( '' , true ) ) ; set_error_handler ( function ( ) { static :: handleJsonError ( JSON_ERROR_SYNTAX ) ; } , E_WARNING ) ; $ json = json_encode ( $ value , $ options ) ; restore_error_handler ( ) ; static :: handleJsonError ( json_last_error ( ) ) ; return $ expressions === [ ] ? $ json : strtr ( $ json , $ expressions ) ; }
4935	private function triggerEvent ( $ name , EntityInterface $ entity ) { $ params = $ this -> options ; $ params [ 'entity' ] = $ entity ; $ params [ 'repositories' ] = $ this -> repositories ; $ event = $ this -> entityEraserEvents -> getEvent ( $ name , $ this , $ params ) ; $ this -> entityEraserEvents -> triggerEvent ( $ event ) ; $ dependencies = $ event -> getDependencyResultCollection ( ) ; return $ dependencies ; }
10245	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; if ( isset ( $ xmlElement -> last_type ) ) $ this -> lastType = $ xmlElement -> last_type ; if ( isset ( $ xmlElement -> count ) ) $ this -> count = $ xmlElement -> count ; if ( isset ( $ xmlElement -> count_hard ) ) $ this -> countHard = $ xmlElement -> count_hard ; if ( isset ( $ xmlElement -> count_soft ) ) $ this -> countSoft = $ xmlElement -> count_soft ; }
8565	private function _convertGetEligibleShippingServices ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsGetEligibleShippingServicesRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsGetEligibleShippingServicesRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } return $ parameters ; }
8050	public function getCalendarEvent ( $ id ) { $ calendarEvent = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: CACHE_KEY . $ id ) ) { return $ cache :: get ( self :: CACHE_KEY . $ id ) ; } $ calendarEvent = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> where ( 'id' , $ id ) -> firstOrFail ( ) ; $ cache :: put ( self :: CACHE_KEY . $ id , $ calendarEvent , $ this -> cacheTimeToLive ) ; return $ calendarEvent ; }
11039	function store_node ( & $ elts , $ ptype , & $ i , & $ line , $ cname , $ cvalue , $ ncontent , $ content , $ code = FALSE ) { $ isabsolute = FALSE ; if ( $ cname { 0 } == '/' && $ cname { 1 } == '/' ) { $ isabsolute = TRUE ; $ cname = substr ( $ cname , 2 ) ; } $ elements = explode ( '/' , $ cname ) ; if ( count ( $ elements ) == 1 && ! $ isabsolute ) { $ elts [ $ ptype . ':' . $ i . ':' . $ cname . ':' . $ cvalue ] = $ this -> parse ( $ code ? _ETS_CODE : $ ptype , $ i , $ line , $ ncontent , $ content ) ; } else { if ( $ isabsolute ) { $ elts [ _ETS_TEMPLATE . ':' . $ i . '.1://' ] = $ this -> node_path_walk ( $ elements , 2 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } else { $ element1 = array_shift ( $ elements ) ; $ masktype = ( $ ptype == _ETS_MIS || $ ptype == _ETS_MISVAL ) ? _ETS_MIS_TEMPLATE : _ETS_TEMPLATE ; $ elts [ $ masktype . ':' . $ i . '.1:' . $ element1 ] = $ this -> node_path_walk ( $ elements , 2 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } } }
11908	private function getChangedAt ( string $ filename ) : float { clearstatcache ( true , $ filename ) ; return file_exists ( $ filename ) ? ( float ) file_get_contents ( $ filename ) : - 1 ; }
3503	private function prepareCurlResourceByRequest ( Request $ request ) : void { curl_setopt ( $ this -> resource , CURLOPT_URL , $ request -> getUrl ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_POSTFIELDS , $ request -> getContent ( ) ) ; if ( $ request -> getCertificate ( ) ) { curl_setopt ( $ this -> resource , CURLOPT_SSLCERT , $ request -> getCertificate ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_SSLCERTPASSWD , $ request -> getCertificatePassPhrase ( ) ) ; } $ inlineHeaders = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ inlineHeaders [ ] = sprintf ( '%s: %s' , $ name , $ value ) ; } curl_setopt ( $ this -> resource , CURLOPT_HTTPHEADER , $ inlineHeaders ) ; }
3826	protected function isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( empty ( $ strKeyOption ) && ! isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) ) { return true ; } $ blnIsActive = isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) && ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] == $ strKeyOption ) ; if ( ! $ blnIsActive && $ this -> get ( 'defaultid' ) ) { $ blnIsActive = ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] == $ this -> get ( 'defaultid' ) ) ; } return $ blnIsActive ; }
11379	public function putAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)\/(\w+)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ language , $ oldName ) = $ matches ; $ request = $ this -> environment -> getRequestHelper ( ) ; $ newName = $ request -> getIdentifierParam ( 'name' ) ; $ content = $ request -> getParam ( 'content' , '' ) ; try { $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ text = $ pageTexts -> modifyTextContainer ( $ oldName , $ newName , $ this -> filter ( $ content ) , $ language ) ; $ this -> environment -> sendJSONResult ( $ text ) ; } catch ( \ Exception $ e ) { throw new InvalidParameterException ( $ e -> getMessage ( ) ) ; } }
2062	public function generateArticle ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord ) { return ; } if ( $ dc -> activeRecord -> title == '' || ! \ in_array ( $ dc -> activeRecord -> type , array ( 'regular' , 'error_401' , 'error_403' , 'error_404' ) ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ new_records = $ objSessionBag -> get ( 'new_records' ) ; if ( ! $ new_records || ! \ is_array ( $ new_records [ $ dc -> table ] ) || ! \ in_array ( $ dc -> id , $ new_records [ $ dc -> table ] ) ) { return ; } $ objTotal = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_article WHERE pid=?" ) -> execute ( $ dc -> id ) ; if ( $ objTotal -> count > 0 ) { return ; } $ arrSet [ 'pid' ] = $ dc -> id ; $ arrSet [ 'sorting' ] = 128 ; $ arrSet [ 'tstamp' ] = time ( ) ; $ arrSet [ 'author' ] = $ this -> User -> id ; $ arrSet [ 'inColumn' ] = 'main' ; $ arrSet [ 'title' ] = $ dc -> activeRecord -> title ; $ arrSet [ 'alias' ] = str_replace ( '/' , '-' , $ dc -> activeRecord -> alias ) ; $ arrSet [ 'published' ] = $ dc -> activeRecord -> published ; $ this -> Database -> prepare ( "INSERT INTO tl_article %s" ) -> set ( $ arrSet ) -> execute ( ) ; }
6720	public function authorize ( ) { $ this -> validateAuthParams ( ) ; try { $ response = $ this -> curl -> setOption ( CURLOPT_POSTFIELDS , http_build_query ( array ( 'grant_type' => self :: GRANT_TYPE_AUTHORIZATION_CODE , 'client_id' => $ this -> clientId , 'client_secret' => $ this -> clientSecret , 'response_type' => self :: RESPONSE_TYPE_CODE , 'state' => self :: STATE_ALIVE ) ) ) -> post ( $ this -> authUrl , false ) ; } catch ( InvalidParamException $ invalidParamException ) { throw new Oauth2ClientException ( $ invalidParamException -> getMessage ( ) ) ; } return $ this -> handleAuthorizeResponse ( $ response ) ; }
9685	public function setStorage ( $ storage , $ options = null ) { if ( ! $ storage instanceof Storage \ StorageInterface ) { $ storage = $ this -> getStoragePluginManager ( ) -> get ( $ storage , $ options ) ; } $ this -> storage = $ storage ; return $ this ; }
7663	function AddAttachment ( $ path , $ name = "" , $ encoding = "base64" , $ type = "application/octet-stream" ) { if ( ! @ is_file ( $ path ) ) { $ this -> SetError ( $ this -> Lang ( "file_access" ) . $ path ) ; return false ; } $ filename = basename ( $ path ) ; if ( $ name == "" ) $ name = $ filename ; $ cur = count ( $ this -> attachment ) ; $ this -> attachment [ $ cur ] [ 0 ] = $ path ; $ this -> attachment [ $ cur ] [ 1 ] = $ filename ; $ this -> attachment [ $ cur ] [ 2 ] = $ name ; $ this -> attachment [ $ cur ] [ 3 ] = $ encoding ; $ this -> attachment [ $ cur ] [ 4 ] = $ type ; $ this -> attachment [ $ cur ] [ 5 ] = false ; $ this -> attachment [ $ cur ] [ 6 ] = "attachment" ; $ this -> attachment [ $ cur ] [ 7 ] = 0 ; return true ; }
6457	public function redirectToUri ( IHttpResponseMessage $ response , $ uri , int $ statusCode = 302 ) : void { if ( is_string ( $ uri ) ) { $ uriString = $ uri ; } elseif ( $ uri instanceof Uri ) { $ uriString = ( string ) $ uri ; } else { throw new InvalidArgumentException ( 'Uri must be instance of ' . Uri :: class . ' or string' ) ; } $ response -> setStatusCode ( $ statusCode ) ; $ response -> getHeaders ( ) -> add ( 'Location' , $ uriString ) ; }
1239	private static function getActualType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } return $ actualType ; }
5397	public function paintMessage ( $ message ) { parent :: paintMessage ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'message>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "message>\n" ; }
9511	public function delete ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DELETE ) ; $ date = $ log -> date ; if ( $ this -> logViewer -> delete ( $ date ) ) { $ this -> notifySuccess ( $ message = trans ( 'foundation::log-viewer.messages.deleted.message' , compact ( 'date' ) ) , trans ( 'foundation::log-viewer.messages.deleted.title' ) ) ; return $ this -> jsonResponseSuccess ( compact ( 'message' ) ) ; } return $ this -> jsonResponseError ( [ 'message' => "An error occurred while deleting the log [$date]" ] ) ; }
5262	protected function mergeBoolQuery ( array $ query1 , array $ query2 , $ type ) { if ( empty ( $ query2 [ 'bool' ] [ $ type ] ) ) { return $ query1 ; } else { if ( empty ( $ query1 [ 'bool' ] [ $ type ] ) ) { $ query1 [ 'bool' ] [ $ type ] = [ ] ; } } $ query1 [ 'bool' ] [ $ type ] = array_merge ( $ query1 [ 'bool' ] [ $ type ] , $ query2 [ 'bool' ] [ $ type ] ) ; return $ query1 ; }
11785	public function pagination ( $ begin , $ count ) { $ params = [ 'type' => 2 , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , $ params ] ) ; }
5819	private function createAlertsForType ( $ type , array $ messages ) { $ alerts = array ( ) ; foreach ( $ messages as $ msg ) { $ alerts [ ] = new Alert ( $ type , $ msg ) ; } return $ alerts ; }
3333	public function createGroup ( $ files ) { $ data = array ( 'pub_key' => $ this -> api -> getPublicKey ( ) , ) ; foreach ( $ files as $ i => $ file ) { $ data [ "files[$i]" ] = $ file -> getUrl ( ) ; } $ ch = $ this -> __initRequest ( 'group' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ resp = $ this -> __runRequest ( $ ch ) ; $ group = $ this -> api -> getGroup ( $ resp -> id ) ; return $ group ; }
10461	public function initialize ( $ filePath , $ params ) { copy ( __DIR__ . '/../../../recipe/releaz.php' , $ filePath ) ; $ exampleFile = $ this -> getExamplePath ( ) ; $ projectFile = dirname ( $ filePath ) . '/' . $ this -> getExample ( ) ; copy ( $ exampleFile , $ projectFile ) ; $ this -> setParamsInExample ( $ projectFile , $ params ) ; }
137	public function install ( RepositoryInterface $ repo , InstallOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; $ installer -> install ( $ repo , $ package ) ; $ this -> markForNotification ( $ package ) ; }
4672	public function setPaths ( array $ paths ) : object { foreach ( $ paths as $ path ) { if ( ! ( is_dir ( $ path ) && is_readable ( $ path ) ) ) { throw new Exception ( "Directory '$path' is not readable." ) ; } } $ this -> paths = $ paths ; return $ this ; }
9665	public function setHeader ( $ header , $ value ) { if ( strlen ( $ header ) < 1 ) { throw new Exception ( 'Header must be a string.' ) ; } $ this -> customHeaders [ $ header ] = $ value ; return $ this ; }
8166	public function write ( ) { $ strings = func_get_args ( ) ; foreach ( $ strings as $ string ) { $ this -> source .= str_repeat ( ' ' , $ this -> indentation * 4 ) . $ string ; } return $ this ; }
8434	private function write ( array $ mapping , string $ mappingName , string $ name , array $ up = [ ] , array $ down = [ ] , array $ import = [ ] ) { $ path = rtrim ( $ mapping [ 'config' ] [ 'migrations' ] [ 'path' ] , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; $ path .= $ name . DIRECTORY_SEPARATOR ; if ( file_exists ( $ path . $ name . '.php' ) === true ) { echo 'A migration with this name already exists. Do you want to overwrite it ? [y/n] : ' ; if ( fgetc ( STDIN ) != 'y' ) { return false ; } } if ( is_dir ( $ path ) === false ) { if ( mkdir ( $ path ) === false ) { throw new FileNotWritable ( 'can\'t mkdir "' . $ path . '"' ) ; } } $ path .= $ name . '.php' ; $ file = fopen ( $ path , 'w+' ) ; if ( $ file === false ) { throw new FileNotWritable ( 'can\'t open "' . $ path . '" with write permission' ) ; } $ content = "<?php\n\nnamespace " . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'migrations' ] [ 'namespace' ] , '\\' ) , '\\' ) . '\\' . $ name . ";\n\nuse " . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Migration;' . PHP_EOL ; if ( count ( $ import ) >= 1 ) { $ content .= 'use ' . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Mutation\\{' ; $ content .= implode ( ', ' , $ import ) . "};\n" ; } $ up = implode ( '' , array_map ( function ( string $ a ) { return ' ' . $ a . '->execute();' . PHP_EOL ; } , $ up ) ) ; $ down = implode ( '' , array_map ( function ( string $ a ) { return ' ' . $ a . '->execute();' . PHP_EOL ; } , $ down ) ) ; var_dump ( $ up ) ; $ content .= "\nclass " . $ name . " extends Migration\n{\n" ; $ content .= ' const NAME = \'' . $ name . "';\n\n" ; $ content .= " public function getMappingName() : string\n {\n return '" . $ mappingName . "';\n }\n\n" ; $ content .= " public function up()\n {\n" . $ up . " }\n\n" ; $ content .= " public function down()\n {\n" . $ down . " }\n" ; $ content .= "}" ; if ( fwrite ( $ file , $ content ) === false ) { throw new FileNotWritable ( 'can\'t write in "' . $ path . '"' ) ; } fclose ( $ file ) ; return true ; }
6559	public function get_number_type ( $ phone_number = '' , $ region = NULL ) { $ inputParams = array ( 'phone_number' => $ phone_number , 'region' => $ region ) ; $ this -> debug -> info ( __FUNCTION__ , 'Input Params: ' , $ inputParams ) ; if ( empty ( $ phone_number ) ) { $ this -> debug -> warning ( __FUNCTION__ , 'Phone Number input is Empty!' ) ; return NULL ; } $ phone_number = trim ( $ phone_number ) ; try { $ phoneNumberUtil = PhoneNumberUtil :: getInstance ( ) ; $ use_region = NULL !== $ region ? strtoupper ( $ region ) : self :: DEFAULT_REGION ; $ phoneNumberObject = $ phoneNumberUtil -> parse ( trim ( $ phone_number ) , $ use_region ) ; $ result = $ phoneNumberUtil -> getNumberType ( $ phoneNumberObject ) ; $ this -> debug -> debug ( __FUNCTION__ , 'Use REGION: ' . $ use_region ) ; $ this -> debug -> info ( __FUNCTION__ , 'Final Result: ' . $ result ) ; return $ result ; } catch ( \ Exception $ e ) { $ message = 'Error File: ' . $ e -> getFile ( ) . ' - Line: ' . $ e -> getLine ( ) . ' - Code: ' . $ e -> getCode ( ) . ' - Message: ' . $ e -> getMessage ( ) ; $ this -> debug -> error ( __FUNCTION__ , $ message ) ; return NULL ; } }
4668	public function generate ( ) { $ this -> beforeGeneration ( ) ; $ this -> config -> getLogger ( ) -> startBreak ( 'Class Generation' ) ; foreach ( $ this -> XSDMap as $ fhirElementName => $ mapEntry ) { $ this -> config -> getLogger ( ) -> debug ( "Generating class for element {$fhirElementName}..." ) ; $ classTemplate = ClassGenerator :: buildFHIRElementClassTemplate ( $ this -> config , $ this -> XSDMap , $ mapEntry ) ; FileUtils :: createDirsFromNS ( $ classTemplate -> getNamespace ( ) , $ this -> config ) ; MethodGenerator :: implementConstructor ( $ this -> config , $ classTemplate ) ; $ classTemplate -> writeToFile ( $ this -> config -> getOutputPath ( ) ) ; $ this -> mapTemplate -> addEntry ( $ classTemplate ) ; $ this -> autoloadMap -> addPHPFHIRClassEntry ( $ classTemplate ) ; $ this -> config -> getLogger ( ) -> debug ( "{$fhirElementName} completed." ) ; } $ this -> config -> getLogger ( ) -> endBreak ( 'Class Generation' ) ; $ this -> afterGeneration ( ) ; }
10346	protected function getNextFutureTimestamp ( ) { if ( $ this -> yearOffset === 0 ) { $ currentHour = ( int ) date ( 'H' , $ this -> getCurrentTime ( ) ) ; $ currentMinute = ( int ) date ( 'i' , $ this -> getCurrentTime ( ) ) ; $ currentDay = ( int ) date ( 'd' , $ this -> getCurrentTime ( ) ) ; $ currentMonth = ( int ) date ( 'm' , $ this -> getCurrentTime ( ) ) ; } do { $ minute = current ( $ this -> minutes ) ; $ hour = current ( $ this -> hours ) ; $ monthAndDay = current ( $ this -> monthAndDays ) ; $ minute = next ( $ this -> minutes ) ; if ( $ minute === false ) { $ minute = reset ( $ this -> minutes ) ; $ hour = next ( $ this -> hours ) ; if ( $ hour === false ) { $ hour = reset ( $ this -> hours ) ; $ monthAndDay = next ( $ this -> monthAndDays ) ; if ( $ monthAndDay === false ) { $ this -> generateTimetable ( $ this -> yearOffset + 1 ) ; $ minute = reset ( $ this -> minutes ) ; $ hour = reset ( $ this -> hours ) ; $ monthAndDay = reset ( $ this -> monthAndDays ) ; } } } if ( $ this -> yearOffset === 0 ) { if ( ( $ month = ( int ) substr ( $ monthAndDay , 0 , 2 ) ) === $ currentMonth ) { if ( ( $ day = ( int ) substr ( $ monthAndDay , 3 , 2 ) ) < $ currentDay ) { continue ; } if ( $ day === $ currentDay ) { if ( $ hour < $ currentHour ) { continue ; } if ( $ hour === $ currentHour ) { if ( $ minute < $ currentMinute ) { continue ; } } } } } $ nextElement = strtotime ( sprintf ( '%d-%s %02d:%02d:00' , $ this -> year + $ this -> yearOffset , $ monthAndDay , $ hour , $ minute ) ) ; break ; } while ( true ) ; return $ nextElement ; }
4410	public function onBuildView ( CollectViewParametersEvent $ event ) { $ view = $ event -> getView ( ) ; if ( ! $ view instanceof LayoutViewInterface && ! $ view instanceof RuleViewInterface ) { return ; } if ( $ view -> getContext ( ) !== 'ngadminui' ) { return ; } $ event -> addParameter ( 'is_enterprise' , $ this -> isEnterpriseVersion ) ; }
4845	protected static function call ( $ method , $ url , $ params = array ( ) ) { $ ch = curl_init ( ) ; $ curl_options = array ( CURLOPT_CONNECTTIMEOUT => 10 , CURLOPT_RETURNTRANSFER => true , CURLOPT_TIMEOUT => 60 , CURLOPT_USERAGENT => 'gocardless-php/v' . GoCardless :: VERSION , ) ; if ( isset ( $ params [ 'ua_tag' ] ) ) { $ curl_options [ CURLOPT_USERAGENT ] .= ' ' . $ params [ 'ua_tag' ] ; unset ( $ params [ 'ua_tag' ] ) ; } $ curl_options [ CURLOPT_HTTPHEADER ] [ ] = 'Accept: application/json' ; $ curl_options [ CURLOPT_SSL_VERIFYPEER ] = true ; if ( isset ( $ params [ 'http_authorization' ] ) ) { $ curl_options [ CURLOPT_USERPWD ] = $ params [ 'http_authorization' ] ; unset ( $ params [ 'http_authorization' ] ) ; } else { if ( ! isset ( $ params [ 'http_bearer' ] ) ) { throw new GoCardless_ClientException ( 'Access token missing' ) ; } $ curl_options [ CURLOPT_HTTPHEADER ] [ ] = 'Authorization: Bearer ' . $ params [ 'http_bearer' ] ; unset ( $ params [ 'http_bearer' ] ) ; } if ( $ method == 'post' ) { $ curl_options [ CURLOPT_POST ] = 1 ; if ( ! empty ( $ params ) ) { $ curl_options [ CURLOPT_POSTFIELDS ] = http_build_query ( $ params , null , '&' ) ; } } elseif ( $ method == 'get' ) { $ curl_options [ CURLOPT_HTTPGET ] = 1 ; if ( ! empty ( $ params ) ) { $ url .= '?' . http_build_query ( $ params , null , '&' ) ; } } elseif ( $ method == 'put' ) { $ curl_options [ CURLOPT_PUT ] = 1 ; $ fh = fopen ( 'php://memory' , 'rw+' ) ; $ curl_options [ CURLOPT_INFILE ] = $ fh ; $ curl_options [ CURLOPT_INFILESIZE ] = 0 ; } curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt_array ( $ ch , $ curl_options ) ; $ result = curl_exec ( $ ch ) ; $ error = curl_errno ( $ ch ) ; if ( $ error == CURLE_SSL_PEER_CERTIFICATE || $ error == CURLE_SSL_CACERT || $ error == 77 ) { curl_setopt ( $ ch , CURLOPT_CAINFO , dirname ( __FILE__ ) . '/cert-bundle.crt' ) ; $ result = curl_exec ( $ ch ) ; } $ http_response_code = curl_getinfo ( $ ch , CURLINFO_HTTP_CODE ) ; if ( $ http_response_code < 200 || $ http_response_code > 300 ) { $ message = print_r ( json_decode ( $ result , true ) , true ) ; throw new GoCardless_ApiException ( $ message , $ http_response_code , $ result ) ; } curl_close ( $ ch ) ; if ( isset ( $ fh ) ) { fclose ( $ fh ) ; } return json_decode ( $ result , true ) ; }
6905	public function removeRecipient ( Recipient $ recipient ) { if ( $ this -> recipients -> contains ( $ recipient ) ) { $ this -> recipients -> removeElement ( $ recipient ) ; } return $ this ; }
8008	public static function forStringAndEncodings ( $ string , $ from_encoding , $ to_encoding , $ code = self :: CODE_FOR_STRING_AND_ENCODING_INFO , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . sprintf ( self :: MESSAGE_EXTENSION_FOR_STRING_FORMAT , $ string ) . sprintf ( self :: MESSAGE_EXTENSION_FOR_ENCODING_INFO_FORMAT , $ from_encoding , $ to_encoding ) ; return new static ( $ message , $ code , $ previous ) ; }
10379	protected static function is_modified_file ( $ filepath ) { $ actual = filemtime ( $ filepath ) ; $ last = isset ( self :: $ files [ $ filepath ] ) ? self :: $ files [ $ filepath ] : 0 ; if ( $ actual !== $ last ) { self :: $ files [ $ filepath ] = $ actual ; self :: $ changes = true ; return self :: $ changes ; } return false ; }
6201	public function addRoute ( $ newRoute ) { $ this -> routeMap [ 'routes' ] = array_merge ( $ this -> routeMap [ 'routes' ] , $ newRoute ) ; $ this -> routeMapParse = array_merge ( $ this -> routeMapParse , $ newRoute ) ; }
4136	public function getParams ( array $ params ) { $ r = '' ; ksort ( $ params ) ; foreach ( $ params as $ key => $ value ) { $ r .= '&' . $ key . '=' . rawurlencode ( $ value ) ; } unset ( $ params , $ key , $ value ) ; return trim ( $ r , '&' ) ; }
4032	private function preCreateInverseImage ( ModelInterface $ model , string $ image ) : void { if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return ; } if ( $ model -> getProperty ( 'enabled' ) ) { $ this -> iconBuilder -> getBackendIcon ( substr_replace ( $ image , '_1' , $ intPos , 0 ) ) ; return ; } $ this -> iconBuilder -> getBackendIcon ( $ image ) ; }
5120	private function requestGate ( string $ method , string $ path , array $ header = [ ] , array $ body = [ ] , array $ options = [ ] ) : string { if ( empty ( $ this -> accessToken ) ) { $ this -> renewAuthToken ( ) ; } $ request = new \ GuzzleHttp \ Psr7 \ Request ( $ method , $ path , array_merge ( $ this -> options -> get ( 'default_headers' ) , $ header ) , $ this -> createBodyForRequest ( $ this -> prepareMultipartData ( $ body ) ) ) ; return ( string ) $ this -> sendRequest ( $ request ) ; }
9425	public function f ( ) { if ( is_null ( $ this -> arr_f ) ) { $ arr = $ this -> frequency ( ) ; array_walk ( $ arr , function ( & $ v , $ k , $ n ) { $ v = $ v / $ n ; } , count ( $ this ) ) ; $ this -> arr_f = $ arr ; } return $ this -> arr_f ; }
4205	private function getParams ( \ ReflectionMethod $ reflectionMethod , $ phpDoc = array ( ) ) { $ paramArray = array ( ) ; $ params = $ reflectionMethod -> getParameters ( ) ; if ( empty ( $ phpDoc ) ) { $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; } foreach ( $ params as $ i => $ reflectionParameter ) { $ nameNoPrefix = $ reflectionParameter -> getName ( ) ; $ name = '$' . $ nameNoPrefix ; if ( \ method_exists ( $ reflectionParameter , 'isVariadic' ) && $ reflectionParameter -> isVariadic ( ) ) { $ name = '...' . $ name ; } if ( $ reflectionParameter -> isPassedByReference ( ) ) { $ name = '&' . $ name ; } $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( $ reflectionParameter -> isDefaultValueAvailable ( ) ) { $ defaultValue = $ reflectionParameter -> getDefaultValue ( ) ; if ( \ version_compare ( PHP_VERSION , '5.4.6' , '>=' ) && $ reflectionParameter -> isDefaultValueConstant ( ) ) { $ constantName = $ reflectionParameter -> getDefaultValueConstantName ( ) ; } } $ paramInfo = array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , 'desc' => null , 'isOptional' => $ reflectionParameter -> isOptional ( ) , 'name' => $ name , 'type' => $ this -> getParamTypeHint ( $ reflectionParameter ) , ) ; if ( isset ( $ phpDoc [ 'param' ] [ $ i ] ) ) { $ paramInfo [ 'desc' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'desc' ] ; if ( ! isset ( $ paramInfo [ 'type' ] ) ) { $ paramInfo [ 'type' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'type' ] ; } } $ paramArray [ $ nameNoPrefix ] = $ paramInfo ; } return $ paramArray ; }
2455	public function copyAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not copyable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; if ( isset ( $ arrClipboard [ $ this -> strTable ] ) && \ is_array ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] ) ) { foreach ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] as $ id ) { $ this -> intId = $ id ; $ id = $ this -> copy ( true ) ; Input :: setGet ( 'pid' , $ id ) ; Input :: setGet ( 'mode' , 1 ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
5455	public function addContent ( $ text ) { if ( isset ( $ this -> private_content_tag ) ) { $ this -> private_content_tag -> addContent ( $ text ) ; } else { $ this -> addContentToAllOpenTags ( $ text ) ; } return true ; }
10635	public function update ( \ SplSubject $ eventManager ) { $ this -> isUpdate = true ; if ( $ eventManager -> event -> function !== NULL ) { $ this -> { $ eventManager -> event -> function } ( $ eventManager ) ; } }
6481	private function createDefaultResponseContentNegotiationResult ( string $ type , ? string $ language , array $ acceptCharsetHeaders ) : ContentNegotiationResult { $ selectedMediaTypeFormatter = null ; foreach ( $ this -> mediaTypeFormatters as $ mediaTypeFormatter ) { if ( $ mediaTypeFormatter -> canWriteType ( $ type ) ) { $ selectedMediaTypeFormatter = $ mediaTypeFormatter ; break ; } } if ( $ selectedMediaTypeFormatter === null ) { return new ContentNegotiationResult ( null , null , null , $ language ) ; } $ encoding = $ this -> encodingMatcher -> getBestEncodingMatch ( $ selectedMediaTypeFormatter , $ acceptCharsetHeaders , null ) ; return new ContentNegotiationResult ( $ selectedMediaTypeFormatter , $ selectedMediaTypeFormatter -> getDefaultMediaType ( ) , $ encoding , $ language ) ; }
3801	public function getCache ( ) { @ trigger_error ( '"' . __METHOD__ . '" is deprecated as the service container will get removed.' , E_USER_DEPRECATED ) ; if ( \ is_callable ( $ this -> cache ) ) { $ this -> cache = \ call_user_func ( $ this -> cache ) ; } return $ this -> cache ; }
10326	function addRule ( $ rule ) { if ( ! $ this -> rules ) $ this -> rules = array ( ) ; array_push ( $ this -> rules , $ rule ) ; }
7644	protected function parseMetadataElement ( $ element = null ) { if ( ! is_null ( $ element ) && isset ( $ element -> Metadata ) && ! is_null ( $ element -> Metadata ) ) { return get_object_vars ( $ element -> Metadata ) ; } return array ( ) ; }
9879	private function writeBookViews ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ objWriter -> startElement ( 'bookViews' ) ; $ objWriter -> startElement ( 'workbookView' ) ; $ objWriter -> writeAttribute ( 'activeTab' , $ spreadsheet -> getActiveSheetIndex ( ) ) ; $ objWriter -> writeAttribute ( 'autoFilterDateGrouping' , '1' ) ; $ objWriter -> writeAttribute ( 'firstSheet' , '0' ) ; $ objWriter -> writeAttribute ( 'minimized' , '0' ) ; $ objWriter -> writeAttribute ( 'showHorizontalScroll' , '1' ) ; $ objWriter -> writeAttribute ( 'showSheetTabs' , '1' ) ; $ objWriter -> writeAttribute ( 'showVerticalScroll' , '1' ) ; $ objWriter -> writeAttribute ( 'tabRatio' , '600' ) ; $ objWriter -> writeAttribute ( 'visibility' , 'visible' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
1253	private function newPhpObject ( \ stdClass $ meta ) { $ phpTypes = explode ( '|' , $ meta -> phpType ) ; foreach ( $ phpTypes as $ phpType ) { switch ( $ phpType ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'DateTime' : continue ; default : return $ meta -> phpType !== '' ? new $ phpType ( ) : null ; } } return null ; }
9180	final public function getViewSettings ( ) { $ rf = new \ ReflectionClass ( $ this ) ; $ this -> viewName = str_replace ( 'View' , '' , $ rf -> getShortName ( ) ) ; $ matches = array ( ) ; if ( preg_match ( "#@applyTo\((.*)\)#" , $ rf -> getDocComment ( ) , $ matches ) ) { $ params = array ( ) ; parse_str ( str_replace ( ',' , '&' , $ matches [ 1 ] ) , $ params ) ; if ( is_array ( $ params ) ) { foreach ( $ params as $ param => $ value ) { if ( $ param == 'controller' ) { $ this -> controllers = explode ( '|' , $ value ) ; } if ( $ param == 'action' ) { $ this -> actions = explode ( '|' , $ value ) ; } } } } return $ this ; }
12612	public function getIP ( ) { $ ip = "UNKNOWN" ; if ( getenv ( "HTTP_CLIENT_IP" ) ) { $ ip = getenv ( "HTTP_CLIENT_IP" ) ; } else if ( getenv ( "HTTP_X_FORWARDED_FOR" ) ) { $ ip = getenv ( "HTTP_X_FORWARDED_FOR" ) ; } else if ( getenv ( "REMOTE_ADDR" ) ) { $ ip = getenv ( "REMOTE_ADDR" ) ; } return $ ip ; }
11474	public function setObject ( $ object ) { if ( is_null ( $ this -> _objectType ) ) { $ this -> objectType = $ object -> objectType ; } $ this -> _object = $ object ; }
6206	public function onShutdown ( ) { if ( self :: $ instance == null ) { return ; } self :: $ instance = null ; if ( ! $ error = error_get_last ( ) ) { return ; } if ( ! $ this -> shouldNotifyError ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ) { return ; } $ backtrace = array ( array ( 'file' => $ error [ 'file' ] , 'line' => $ error [ 'line' ] , 'function' => '' , 'args' => array ( ) , ) ) ; $ this -> airbrakeClient -> notifyOnError ( '[Improper Shutdown] ' . $ error [ 'message' ] , $ backtrace ) ; }
9541	private function decodeResponse ( Response $ response ) { $ data = json_decode ( $ response -> getBody ( ) -> read ( $ response -> getBody ( ) -> getSize ( ) ) , true ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new ClientException ( 'Unable to parse response body into JSON: ' . json_last_error ( ) ) ; } return $ data === null ? array ( ) : $ data ; }
3306	protected function request ( $ url , array $ options = [ ] ) { $ httpClient = new Http ; try { $ response = $ httpClient -> request ( 'POST' , $ url , [ 'form_params' => $ options , 'query' => [ $ this -> accessToken -> getQueryName ( ) => $ this -> accessToken -> getAccessToken ( true ) ] ] ) ; } catch ( \ GuzzleHttp \ Exception \ ClientException $ e ) { if ( $ e -> hasResponse ( ) ) { $ response = $ e -> getResponse ( ) ; } else { throw $ e ; } } return $ httpClient -> parseJson ( $ response ) ; }
4051	private function buildConditionTree ( array $ conditions ) : array { $ conditionMap = [ ] ; $ bySetting = [ ] ; foreach ( $ conditions as $ condition ) { unset ( $ converted ) ; if ( array_key_exists ( $ condition [ 'id' ] , $ conditionMap ) ) { $ converted = & $ conditionMap [ $ condition [ 'id' ] ] ; foreach ( $ condition as $ key => $ value ) { $ converted [ $ key ] = $ value ; } } else { $ converted = \ array_slice ( $ condition , 0 ) ; $ conditionMap [ $ condition [ 'id' ] ] = & $ converted ; } if ( empty ( $ condition [ 'pid' ] ) ) { $ bySetting [ $ condition [ 'settingId' ] ] [ ] = & $ converted ; continue ; } if ( ! isset ( $ conditionMap [ $ condition [ 'pid' ] ] ) ) { $ temp = [ 'children' => [ ] ] ; $ conditionMap [ $ condition [ 'pid' ] ] = & $ temp ; } $ conditionMap [ $ condition [ 'pid' ] ] [ 'children' ] [ ] = & $ converted ; } return $ bySetting ; }
3416	protected function normalizeFieldsForSave ( $ selectedFields ) { $ fields = [ ] ; if ( $ this -> fields === null ) { return [ ] ; } foreach ( $ this -> fields as $ field => $ value ) { if ( ! $ this -> fieldShouldNotBeSaved ( $ field , $ value , $ selectedFields ) ) { $ fields [ $ field ] = $ value ; } } return $ fields ? : null ; }
5640	public function paintGroupEnd ( $ test_name ) { array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
4888	public function gotoAction ( Request $ r ) { return $ this -> redirect ( $ this -> get ( 'zicht_url.provider' ) -> url ( $ this -> getPageManager ( ) -> findForView ( $ r -> get ( 'id' ) ) ) ) ; }
2306	public function createFileList ( $ strFilter = '' , $ filemount = false ) { if ( $ strFilter === true ) { @ trigger_error ( 'Passing "true" to Backend::createFileList() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ strFilter = 'gif,jpg,jpeg,png' ; } $ this -> import ( BackendUser :: class , 'User' ) ; if ( $ this -> User -> isAdmin ) { return $ this -> doCreateFileList ( Config :: get ( 'uploadPath' ) , - 1 , $ strFilter ) ; } $ return = '' ; $ processed = array ( ) ; if ( $ filemount ) { $ this -> User -> filemounts = array ( $ filemount ) ; } foreach ( $ this -> eliminateNestedPaths ( $ this -> User -> filemounts ) as $ path ) { if ( \ in_array ( $ path , $ processed ) ) { continue ; } $ processed [ ] = $ path ; $ return .= $ this -> doCreateFileList ( $ path , - 1 , $ strFilter ) ; } return $ return ; }
2339	public function renderDropdown ( ) { $ objVersion = $ this -> Database -> prepare ( "SELECT tstamp, version, username, active FROM tl_version WHERE fromTable=? AND pid=? ORDER BY version DESC" ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> numRows < 2 ) { return '' ; } $ versions = '' ; while ( $ objVersion -> next ( ) ) { $ versions .= ' <option value="' . $ objVersion -> version . '"' . ( $ objVersion -> active ? ' selected="selected"' : '' ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'version' ] . ' ' . $ objVersion -> version . ' (' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ objVersion -> tstamp ) . ') ' . $ objVersion -> username . '</option>' ; } return '<div class="tl_version_panel"><form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_version" class="tl_form" method="post" aria-label="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versioning' ] ) . '"><div class="tl_formbody"><input type="hidden" name="FORM_SUBMIT" value="tl_version"><input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"><select name="version" class="tl_select">' . $ versions . '</select><button type="submit" name="showVersion" id="showVersion" class="tl_submit">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'restore' ] . '</button><a href="' . Backend :: addToUrl ( 'versions=1&amp;popup=1' ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . StringUtil :: specialchars ( str_replace ( "'" , "\\'" , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] , $ this -> intPid , $ this -> strTable ) ) ) . '\',\'url\':this.href});return false">' . Image :: getHtml ( 'diff.svg' ) . '</a></div></form></div>' ; }
7012	private function formatF ( & $ str ) { if ( strstr ( $ str , '%F' ) ) $ str = str_replace ( '%F' , $ this -> monthName ( true ) , $ str ) ; }
5169	public static function getTypeByValue ( $ value ) { if ( is_int ( $ value ) ) { return self :: TYPE_INT ; } elseif ( is_string ( $ value ) ) { return self :: TYPE_QSTRING ; } elseif ( is_bool ( $ value ) ) { return self :: TYPE_BOOL ; } elseif ( self :: isList ( $ value ) ) { return self :: TYPE_QVARIANT_LIST ; } elseif ( self :: isMap ( $ value ) ) { return self :: TYPE_QVARIANT_MAP ; } elseif ( $ value instanceof \ DateTime ) { return self :: TYPE_QDATETIME ; } else { throw new \ InvalidArgumentException ( 'Can not guess variant type for type "' . gettype ( $ value ) . '"' ) ; } }
1552	protected function adapterFor ( $ relation ) { $ adapter = $ this -> getStore ( ) -> adapterFor ( $ relation -> getModel ( ) ) ; if ( ! $ adapter instanceof AbstractAdapter ) { throw new RuntimeException ( 'Expecting inverse resource adapter to be an Eloquent adapter.' ) ; } return $ adapter ; }
6901	public function destroy ( ) : void { if ( $ this -> is_active ( ) ) { session_unset ( ) ; session_destroy ( ) ; $ this -> _data = [ ] ; Cookie :: delete ( $ this -> name ) ; } }
2921	public function save ( $ filePath ) { $ this -> ensureFileIsWritable ( $ filePath ) ; file_put_contents ( $ filePath , $ this -> buffer ) ; return $ this ; }
7242	public function validate ( $ request ) { if ( ! empty ( $ request [ 'send_by_bcc' ] ) && '1' === $ request [ 'send_by_bcc' ] ) $ request [ 'send_by_bcc' ] = '1' ; else $ request [ 'send_by_bcc' ] = '0' ; if ( ! empty ( $ request [ 'send_attachments' ] ) && '1' === $ request [ 'send_attachments' ] ) $ request [ 'send_attachments' ] = '1' ; else $ request [ 'send_attachments' ] = '0' ; return $ request ; }
4004	public function getMetaModelNameFromId ( GetMetaModelNameFromIdEvent $ event ) { $ metaModelId = $ event -> getMetaModelId ( ) ; if ( array_key_exists ( $ metaModelId , $ this -> instancesById ) ) { $ event -> setMetaModelName ( $ this -> instancesById [ $ metaModelId ] -> getTableName ( ) ) ; return ; } if ( isset ( $ this -> tableNames [ $ metaModelId ] ) ) { $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; return ; } if ( ! $ this -> tableNamesCollected ) { $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ metaModelId ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ this -> tableNames [ $ metaModelId ] = $ table [ 'tableName' ] ; $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; } } }
2738	private function setToken ( $ token ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_API_KEY , $ token ) ; $ this -> output -> writeln ( '<info>Token updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
7866	protected function drawBorderTop ( $ isCore = false ) { $ crossroads = $ isCore ? static :: CROSSROADS_UP : static :: CROSSROADS ; $ this -> drawBorder ( static :: BORDER_NW , $ crossroads , static :: BORDER_NE ) ; $ this -> geometry -> increaseNesting ( ) ; }
10220	public static function getConversionGroups ( ) { $ conversionGroups = [ ] ; foreach ( self :: $ conversionUnits as $ conversionUnit ) { $ conversionGroups [ ] = $ conversionUnit [ 'Group' ] ; } return array_merge ( array_unique ( $ conversionGroups ) ) ; }
7577	protected function setFileFieldValue ( $ value ) { if ( version_compare ( PHP_VERSION , '5.5.0' ) >= 0 ) { if ( ! ( $ value instanceof \ CURLFile ) ) { $ value = ltrim ( $ value , "@" ) ; $ value = new \ CURLFile ( $ value ) ; } } else { if ( strpos ( $ value , '@' ) !== 0 ) { $ value = '@' . $ value ; } } return $ value ; }
12637	public static function connect ( string $ host = "" , int $ port = 0 , string $ dbname = "" , string $ user = "" , string $ pass = "" , bool $ reconnect = false ) : ? \ PDO { if ( self :: $ pdo !== null && ! $ reconnect ) return self :: $ pdo ; if ( $ host === "" && ( self :: $ databaseHost === null || self :: $ databaseHost === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid host name was not provided!" ) ; $ host = $ host ? : self :: $ databaseHost ; if ( $ port === 0 && ( self :: $ databasePort === null || self :: $ databasePort === 0 ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid port number was not provided!" ) ; $ port = $ port ? : self :: $ databasePort ; if ( $ dbname === "" && ( self :: $ databaseName === null || self :: $ databaseName === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid database name was not provided!" ) ; $ dbname = $ dbname ? : self :: $ databaseName ; if ( $ user === "" && ( self :: $ databaseUser === null || self :: $ databaseUser === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid username was not provided!" ) ; $ user = $ user ? : self :: $ databaseUser ; if ( $ pass === "" && ( self :: $ databasePass === null || self :: $ databasePass === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid password was not provided!" ) ; $ pass = $ pass ? : self :: $ databasePass ; try { self :: $ pdo = new \ PDO ( "pgsql:host=$host;port=$port;dbname=$dbname" , $ user , $ pass , [ \ PDO :: ATTR_DEFAULT_FETCH_MODE => \ PDO :: FETCH_ASSOC , ] ) ; if ( self :: $ pdo ) return self :: $ pdo ; } catch ( \ PDOException $ e ) { throw new Exceptions \ DatabaseConnectionException ( $ e -> getMessage ( ) ) ; } return null ; }
179	protected function loadBundle ( $ name , $ config = [ ] , $ publish = true ) { if ( ! isset ( $ config [ 'class' ] ) ) { $ config [ 'class' ] = $ name ; } $ bundle = Yii :: createObject ( $ config ) ; if ( $ publish ) { $ bundle -> publish ( $ this ) ; } return $ bundle ; }
7010	private function formatN ( & $ str ) { if ( strstr ( $ str , '%N' ) ) { $ wdn = $ this -> weekDayNum ( ) ; $ str = str_replace ( '%N' , $ wdn == 0 ? 7 : $ wdn , $ str ) ; } }
1088	private static function getFieldDefinition ( Schema $ schema , Type $ parentType , FieldNode $ fieldNode ) { $ name = $ fieldNode -> name -> value ; $ schemaMeta = Introspection :: schemaMetaFieldDef ( ) ; if ( $ name === $ schemaMeta -> name && $ schema -> getQueryType ( ) === $ parentType ) { return $ schemaMeta ; } $ typeMeta = Introspection :: typeMetaFieldDef ( ) ; if ( $ name === $ typeMeta -> name && $ schema -> getQueryType ( ) === $ parentType ) { return $ typeMeta ; } $ typeNameMeta = Introspection :: typeNameMetaFieldDef ( ) ; if ( $ name === $ typeNameMeta -> name && $ parentType instanceof CompositeType ) { return $ typeNameMeta ; } if ( $ parentType instanceof ObjectType || $ parentType instanceof InterfaceType ) { $ fields = $ parentType -> getFields ( ) ; return $ fields [ $ name ] ?? null ; } return null ; }
5273	public static function table ( $ table_name ) { global $ wpdb ; if ( empty ( self :: $ instances ) || empty ( self :: $ instances [ $ table_name ] ) ) { self :: $ instances [ $ table_name ] = new Query_Builder ( $ wpdb -> prefix . $ table_name ) ; } return self :: $ instances [ $ table_name ] ; }
2885	public function saveProfiling ( ) { if ( ! $ this -> canCollect ( ) || ! Mage :: helper ( 'sheep_debug' ) -> canPersist ( ) ) { return ; } if ( Mage :: helper ( 'sheep_debug' ) -> hasDisablePersistenceCookie ( ) ) { return ; } if ( ! $ this -> getRequestInfo ( ) -> getIsStarted ( ) ) { return ; } $ this -> getRequestInfo ( ) -> save ( ) ; }
2010	public function indexAction ( ) : InitializeControllerResponse { @ trigger_error ( 'Custom entry points are deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ masterRequest = $ this -> get ( 'request_stack' ) -> getMasterRequest ( ) ; if ( null === $ masterRequest ) { throw new \ RuntimeException ( 'The request stack did not contain a master request.' ) ; } $ realRequest = Request :: createFromGlobals ( ) ; foreach ( [ 'REQUEST_URI' , 'SCRIPT_NAME' , 'SCRIPT_FILENAME' , 'PHP_SELF' ] as $ name ) { $ realRequest -> server -> set ( $ name , str_replace ( TL_SCRIPT , 'index.php' , $ realRequest -> server -> get ( $ name ) ) ) ; } $ realRequest -> attributes -> replace ( $ masterRequest -> attributes -> all ( ) ) ; $ this -> get ( 'request_stack' ) -> push ( $ realRequest ) ; $ this -> get ( 'contao.framework' ) -> initialize ( ) ; $ this -> get ( 'request_stack' ) -> push ( $ masterRequest ) ; return new InitializeControllerResponse ( '' , 204 ) ; }
4397	protected function getRedirectForm ( \ Omnipay \ Common \ Message \ RedirectResponseInterface $ response ) { $ list = [ ] ; foreach ( ( array ) $ response -> getRedirectData ( ) as $ key => $ value ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( array ( 'label' => $ key , 'code' => $ key , 'type' => 'string' , 'internalcode' => $ key , 'internaltype' => 'string' , 'default' => $ value , 'public' => false , ) ) ; } $ url = $ response -> getRedirectUrl ( ) ; $ method = $ response -> getRedirectMethod ( ) ; return new \ Aimeos \ MShop \ Common \ Helper \ Form \ Standard ( $ url , $ method , $ list ) ; }
11757	public function delete ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_COMMENT , $ params ] ) ; }
9670	private function writeBorder ( XMLWriter $ objWriter , Borders $ pBorders ) { $ objWriter -> startElement ( 'border' ) ; switch ( $ pBorders -> getDiagonalDirection ( ) ) { case Borders :: DIAGONAL_UP : $ objWriter -> writeAttribute ( 'diagonalUp' , 'true' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'false' ) ; break ; case Borders :: DIAGONAL_DOWN : $ objWriter -> writeAttribute ( 'diagonalUp' , 'false' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'true' ) ; break ; case Borders :: DIAGONAL_BOTH : $ objWriter -> writeAttribute ( 'diagonalUp' , 'true' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'true' ) ; break ; } $ this -> writeBorderPr ( $ objWriter , 'left' , $ pBorders -> getLeft ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'right' , $ pBorders -> getRight ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'top' , $ pBorders -> getTop ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'bottom' , $ pBorders -> getBottom ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'diagonal' , $ pBorders -> getDiagonal ( ) ) ; $ objWriter -> endElement ( ) ; }
1110	protected function keyForScope ( $ node ) { return implode ( '-' , array_map ( function ( $ column ) use ( $ node ) { $ value = $ node -> getAttribute ( $ column ) ; if ( is_null ( $ value ) ) return 'NULL' ; return $ value ; } , $ node -> getScopedColumns ( ) ) ) ; }
10294	public static function excelToTimestamp ( $ excelTimestamp , $ timeZone = null ) { return ( int ) self :: excelToDateTimeObject ( $ excelTimestamp , $ timeZone ) -> format ( 'U' ) ; }
9564	protected function makeFatalErrorException ( ) { $ error = error_get_last ( ) ; if ( $ error !== null ) { return new FatalErrorException ( $ error [ 'message' ] , $ error [ 'type' ] , 0 , $ error [ 'file' ] , $ error [ 'line' ] ) ; } return null ; }
6603	public function makeRequestToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateRequestTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'callback_confirmed' ] = ( isset ( $ params [ 'oauth_callback_confirmed' ] ) ) ? ( boolean ) $ params [ 'oauth_callback_confirmed' ] : null ; return $ this ; }
784	protected function validateCache ( $ lastModified , $ etag ) { if ( Yii :: $ app -> request -> headers -> has ( 'If-None-Match' ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getETags ( ) , true ) ; } elseif ( Yii :: $ app -> request -> headers -> has ( 'If-Modified-Since' ) ) { return $ lastModified !== null && @ strtotime ( Yii :: $ app -> request -> headers -> get ( 'If-Modified-Since' ) ) >= $ lastModified ; } return false ; }
6124	public function logout ( ) { $ this -> request ( "logout" ) ; $ this -> whoamiReset ( ) ; $ this -> delStorage ( "_login_user" ) ; $ this -> delStorage ( "_login_pass" ) ; Signal :: getInstance ( ) -> emit ( "notifyLogout" , $ this ) ; }
3002	public function setContent ( $ data , $ mime , $ charset = NULL ) { if ( ! $ charset ) $ charset = $ this -> charset ; $ this -> message [ $ mime ] = [ 'content' => $ data , 'type' => $ mime . '; ' . $ charset ] ; }
9045	protected function getConfig ( ) { if ( $ this -> config === null ) { if ( file_exists ( $ this -> filename ) ) { $ this -> filename = realpath ( $ this -> filename ) ; $ this -> config = new Config ( include $ this -> filename , true ) ; } else { $ this -> filename = getcwd ( ) . $ this -> filename ; $ this -> config = new Config ( [ ] , true ) ; } } return $ this -> config ; }
2138	public function onKernelRequest ( GetResponseEvent $ event ) : void { $ request = $ event -> getRequest ( ) ; if ( \ in_array ( $ request -> getClientIp ( ) , [ '127.0.0.1' , 'fe80::1' , '::1' ] , true ) ) { return ; } if ( '' === $ request -> getBasePath ( ) ) { return ; } throw new InsecureInstallationException ( 'Your installation is not secure. Please set the document root to the /web subfolder.' ) ; }
1032	private function completeValue ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ promise = $ this -> getPromise ( $ result ) ; if ( $ promise ) { return $ promise -> then ( function ( & $ resolved ) use ( $ returnType , $ fieldNodes , $ info , $ path ) { return $ this -> completeValue ( $ returnType , $ fieldNodes , $ info , $ path , $ resolved ) ; } ) ; } if ( $ result instanceof Exception || $ result instanceof Throwable ) { throw $ result ; } if ( $ returnType instanceof NonNull ) { $ completed = $ this -> completeValue ( $ returnType -> getWrappedType ( ) , $ fieldNodes , $ info , $ path , $ result ) ; if ( $ completed === null ) { throw new InvariantViolation ( 'Cannot return null for non-nullable field ' . $ info -> parentType . '.' . $ info -> fieldName . '.' ) ; } return $ completed ; } if ( $ result === null ) { return null ; } if ( $ returnType instanceof ListOfType ) { return $ this -> completeListValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } if ( $ returnType !== $ this -> exeContext -> schema -> getType ( $ returnType -> name ) ) { $ hint = '' ; if ( $ this -> exeContext -> schema -> getConfig ( ) -> typeLoader ) { $ hint = sprintf ( 'Make sure that type loader returns the same instance as defined in %s.%s' , $ info -> parentType , $ info -> fieldName ) ; } throw new InvariantViolation ( sprintf ( 'Schema must contain unique named types but contains multiple types named "%s". %s ' . '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).' , $ returnType , $ hint ) ) ; } if ( $ returnType instanceof LeafType ) { return $ this -> completeLeafValue ( $ returnType , $ result ) ; } if ( $ returnType instanceof AbstractType ) { return $ this -> completeAbstractValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } if ( $ returnType instanceof ObjectType ) { return $ this -> completeObjectValue ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } throw new RuntimeException ( sprintf ( 'Cannot complete value of unexpected type "%s".' , $ returnType ) ) ; }
8566	public function getShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_GetShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_GetShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_GetShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
858	public function setCode ( $ code ) { if ( $ code === $ this -> generateCode ( ) ) { return ; } $ this -> setSize ( 0 ) ; $ tokens = \ defined ( 'TOKEN_PARSE' ) ? token_get_all ( $ code , TOKEN_PARSE ) : token_get_all ( $ code ) ; $ this -> setSize ( \ count ( $ tokens ) ) ; foreach ( $ tokens as $ index => $ token ) { $ this [ $ index ] = new Token ( $ token ) ; } $ transformers = Transformers :: create ( ) ; $ transformers -> transform ( $ this ) ; $ this -> foundTokenKinds = [ ] ; foreach ( $ this as $ token ) { $ this -> registerFoundToken ( $ token ) ; } $ this -> rewind ( ) ; $ this -> changeCodeHash ( self :: calculateCodeHash ( $ code ) ) ; $ this -> changed = true ; }
11157	public function handleUrl ( $ url , Event $ event , Queue $ queue ) { $ logger = $ this -> getLogger ( ) ; $ logger -> info ( 'handleUrl' , array ( 'url' => $ url ) ) ; $ v = $ this -> getVideoId ( $ url ) ; $ logger -> info ( 'getVideoId' , array ( 'url' => $ url , 'v' => $ v ) ) ; if ( ! $ v ) { return ; } $ apiUrl = $ this -> getApiUrl ( $ v ) ; $ request = $ this -> getApiRequest ( $ apiUrl , $ event , $ queue ) ; $ this -> getEventEmitter ( ) -> emit ( 'http.request' , array ( $ request ) ) ; }
1542	protected function query ( $ query ) { return new CursorBuilder ( $ query , $ this -> column , $ this -> identifier , $ this -> descending ) ; }
6112	public function dirCreate ( $ cpw = "" , $ dirname = "/" ) { return $ this -> getParent ( ) -> channelDirCreate ( $ this -> getId ( ) , $ cpw , $ dirname ) ; }
9336	public function turn ( ) { if ( $ this -> original -> type == self :: TYPE_TURN ) { return $ this -> original -> value ; } return $ this -> float_rad / ( 2 * pi ( ) ) ; }
6750	public function getTransformer ( ) { if ( ! property_exists ( $ this , 'transformer' ) || ! $ this -> transformer ) { if ( ! $ this -> _defaultTransformer ) { $ this -> createQualifiedTransformerClass ( ) ; } return $ this -> _defaultTransformer ; } return $ this -> transformer ; }
3511	protected function adjustTranslationTable ( $ sql ) { $ adjustedSql = $ this -> tableRenameNeeded ? str_replace ( ' ltm_translations ' , ' ' . $ this -> tableName . ' ' , $ sql ) : $ sql ; return $ adjustedSql ; }
4865	public function listing ( array $ options = [ ] ) { $ filter = [ 'queue' => $ this -> getName ( ) ] ; if ( isset ( $ options [ 'status' ] ) ) { $ filter [ 'status' ] = $ options [ 'status' ] ; } $ opt = [ 'sort' => [ 'scheduled' => 1 , 'priority' => 1 ] ] ; if ( isset ( $ options [ 'limit' ] ) ) { $ opt [ 'limit' ] = $ options [ 'limit' ] ; } $ cursor = $ this -> mongoCollection -> find ( $ filter , $ opt ) ; $ jobs = $ cursor -> toArray ( ) ; foreach ( $ jobs as & $ envelope ) { $ envelope [ 'job' ] = $ this -> unserializeJob ( $ envelope [ 'data' ] , [ '__id__' => $ envelope [ '_id' ] ] ) ; } return $ jobs ; }
10240	public function calculateCellValue ( Cell $ pCell = null , $ resetLog = true ) { if ( $ pCell === null ) { return null ; } $ returnArrayAsType = self :: $ returnArrayAsType ; if ( $ resetLog ) { $ this -> formulaError = null ; $ this -> debugLog -> clearLog ( ) ; $ this -> cyclicReferenceStack -> clear ( ) ; $ this -> cyclicFormulaCounter = 1 ; self :: $ returnArrayAsType = self :: RETURN_ARRAY_AS_ARRAY ; } $ this -> cellStack [ ] = [ 'sheet' => $ pCell -> getWorksheet ( ) -> getTitle ( ) , 'cell' => $ pCell -> getCoordinate ( ) , ] ; try { $ result = self :: unwrapResult ( $ this -> _calculateFormulaValue ( $ pCell -> getValue ( ) , $ pCell -> getCoordinate ( ) , $ pCell ) ) ; $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; } catch ( \ Exception $ e ) { $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; throw new Exception ( $ e -> getMessage ( ) ) ; } if ( ( is_array ( $ result ) ) && ( self :: $ returnArrayAsType != self :: RETURN_ARRAY_AS_ARRAY ) ) { self :: $ returnArrayAsType = $ returnArrayAsType ; $ testResult = Functions :: flattenArray ( $ result ) ; if ( self :: $ returnArrayAsType == self :: RETURN_ARRAY_AS_ERROR ) { return Functions :: VALUE ( ) ; } if ( count ( $ testResult ) != 1 ) { $ r = array_keys ( $ result ) ; $ r = array_shift ( $ r ) ; if ( ! is_numeric ( $ r ) ) { return Functions :: VALUE ( ) ; } if ( is_array ( $ result [ $ r ] ) ) { $ c = array_keys ( $ result [ $ r ] ) ; $ c = array_shift ( $ c ) ; if ( ! is_numeric ( $ c ) ) { return Functions :: VALUE ( ) ; } } } $ result = array_shift ( $ testResult ) ; } self :: $ returnArrayAsType = $ returnArrayAsType ; if ( $ result === null ) { return 0 ; } elseif ( ( is_float ( $ result ) ) && ( ( is_nan ( $ result ) ) || ( is_infinite ( $ result ) ) ) ) { return Functions :: NAN ( ) ; } return $ result ; }
6570	public function getMessage ( ) { return '[' . $ this -> prefix . ( $ this -> context === null ? '' : ( ' - ' . get_class ( $ this -> context ) ) ) . '] ' . $ this -> msg ; }
4818	public function addField ( $ name , $ value ) { if ( $ this -> currentRow < 0 ) { $ this -> appendRow ( ) ; } $ this -> collection [ $ this -> currentRow ] -> addField ( $ name , $ value ) ; }
3624	public function temperatureInUserScale ( $ temperature_in_celsius , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature_in_celsius * 1.8 ) + 32 ; } return $ temperature_in_celsius ; }
4288	public function onError ( Event $ event ) { if ( $ event [ 'inConsole' ] || ! $ event [ 'isFirstOccur' ] ) { return ; } $ this -> processLogEntry ( 'errorNotConsoled' , array ( $ event [ 'typeStr' ] . ': ' . $ event [ 'file' ] . ' (line ' . $ event [ 'line' ] . '): ' . $ event [ 'message' ] ) , array ( 'channel' => 'phpError' , 'class' => $ event [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ? 'danger' : 'warning' , ) ) ; }
5433	public function isAbstractMethodInParents ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; $ parent = $ interface -> getParentClass ( ) ; while ( $ parent ) { if ( ! $ parent -> hasMethod ( $ name ) ) { return false ; } if ( $ parent -> getMethod ( $ name ) -> isAbstract ( ) ) { return true ; } $ parent = $ parent -> getParentClass ( ) ; } return false ; }
12934	public function move ( $ baseDir , array $ options , $ username ) { $ this -> resolveMoveOptions ( $ options ) ; if ( array_key_exists ( "targetSlot" , $ options ) ) { $ options [ "slot" ] = $ options [ "targetSlot" ] ; $ block = $ this -> moveBlockToAnotherSlot ( $ baseDir , $ options , $ username ) ; return $ block ; } $ options [ "slot" ] = $ options [ "sourceSlot" ] ; $ block = $ this -> moveBlockToSameSlot ( $ baseDir , $ options , $ username ) ; return $ block ; }
6698	public function compareTo ( $ version ) { $ major = $ version -> getMajor ( ) ; $ minor = $ version -> getMinor ( ) ; $ patch = $ version -> getPatch ( ) ; $ pre = $ version -> getPreRelease ( ) ; $ build = $ version -> getBuild ( ) ; switch ( true ) { case ( $ this -> major < $ major ) : return 1 ; case ( $ this -> major > $ major ) : return - 1 ; case ( $ this -> minor > $ minor ) : return - 1 ; case ( $ this -> minor < $ minor ) : return 1 ; case ( $ this -> patch > $ patch ) : return - 1 ; case ( $ this -> patch < $ patch ) : return 1 ; } if ( $ pre || $ this -> pre ) { if ( empty ( $ this -> pre ) && $ pre ) { return - 1 ; } if ( $ this -> pre && empty ( $ pre ) ) { return 1 ; } if ( 0 !== ( $ weight = $ this -> precedence ( $ this -> pre , $ pre ) ) ) { return $ weight ; } } if ( $ build || $ this -> build ) { if ( ( null === $ this -> build ) && $ build ) { return 1 ; } if ( $ this -> build && ( null === $ build ) ) { return - 1 ; } return $ this -> precedence ( $ this -> build , $ build ) ; } return 0 ; }
5018	public function isEnabled ( $ field ) { return ! isset ( $ this -> fields [ $ field ] [ 'enabled' ] ) || ( bool ) $ this -> fields [ $ field ] [ 'enabled' ] ; }
8390	public function addRightOuterJoin ( $ table , $ on ) { $ this -> rightOuterJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
10907	public static function get ( array $ server ) : array { $ params = [ ] ; if ( isset ( $ server [ 'QUERY_STRING' ] ) ) { $ query = ltrim ( $ server [ 'QUERY_STRING' ] , '?' ) ; foreach ( explode ( '&' , $ query ) as $ pair ) { if ( $ pair ) { list ( $ name , $ value ) = self :: normalize ( array_map ( 'urldecode' , explode ( '=' , $ pair , 2 ) ) ) ; $ params [ $ name ] [ ] = $ value ; } } } return $ params ? array_map ( function ( $ v ) { return count ( $ v ) === 1 ? $ v [ 0 ] : $ v ; } , $ params ) : $ params ; }
5480	protected function addCheckbox ( $ tag ) { if ( ! isset ( $ this -> checkboxes [ $ tag -> getName ( ) ] ) ) { $ this -> widgets [ ] = $ tag ; $ this -> checkboxes [ $ tag -> getName ( ) ] = count ( $ this -> widgets ) - 1 ; } else { $ index = $ this -> checkboxes [ $ tag -> getName ( ) ] ; if ( ! is_a ( $ this -> widgets [ $ index ] , 'SimpleCheckboxGroup' ) ) { $ previous = $ this -> widgets [ $ index ] ; $ this -> widgets [ $ index ] = new SimpleCheckboxGroup ( ) ; $ this -> widgets [ $ index ] -> addWidget ( $ previous ) ; } $ this -> widgets [ $ index ] -> addWidget ( $ tag ) ; } }
5338	public function buildSoapClient ( $ service ) { $ director = new Soap \ SoapClientDirector ( $ this -> username , $ this -> mode , $ this -> endpoint ) ; switch ( $ service ) { case 'DomainService' : return $ director -> build ( new Soap \ Builder \ DomainSoapClientBuilder ) ; case 'ColocationService' : return $ director -> build ( new Soap \ Builder \ ColocationSoapClientBuilder ) ; case 'ForwardService' : return $ director -> build ( new Soap \ Builder \ ForwardSoapClientBuilder ) ; case 'VpsService' : return $ director -> build ( new Soap \ Builder \ VpsSoapClientBuilder ) ; case 'WebhostingService' : return $ director -> build ( new Soap \ Builder \ WebHostingSoapClientBuilder ) ; case 'HaipService' : return $ director -> build ( new Soap \ Builder \ HaipSoapClientBuilder ) ; default : throw new \ InvalidArgumentException ( sprintf ( 'Undefined soap client service builder called: [%s]' , $ service ) ) ; } }
1403	private function parse ( ) { if ( ! $ this -> response ) { return [ ] ; } $ body = json_decode ( ( string ) $ this -> response -> getBody ( ) , true ) ; return isset ( $ body [ 'errors' ] ) ? $ body [ 'errors' ] : [ ] ; }
659	public function noCache ( callable $ callable ) { $ this -> _queryCacheInfo [ ] = false ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
290	public function __isset ( $ name ) { try { return $ this -> __get ( $ name ) !== null ; } catch ( \ Throwable $ t ) { return false ; } catch ( \ Exception $ e ) { return false ; } }
11878	protected static function getDumpContent ( $ var , $ maxSize = null ) { $ dump = '<div class="dump_segment_content_main">' ; $ dump .= '<div class="dump_variable">' ; $ dump .= sprintf ( '<ul>%s</ul>' , static :: dumpElement ( $ var , '' , $ maxSize ) ) ; $ dump .= '</div>' ; $ dump .= '</div>' ; return $ dump ; }
5401	public function isValidPath ( $ path ) { return ( strncmp ( $ this -> fixPath ( $ path ) , $ this -> getPath ( ) , strlen ( $ this -> getPath ( ) ) ) == 0 ) ; }
12320	public static function getBundleLocationName ( string $ sName ) : string { $ oConfig = self :: get ( $ sName , null , true ) ; if ( isset ( $ oConfig -> redirect ) ) { return $ oConfig -> redirect ; } else { return PORTAL ; } }
7221	protected function createLabel ( $ content , $ type , $ format , $ size ) { $ label = new OrderShipmentLabel ( ) ; $ label -> setContent ( $ content ) -> setType ( $ type ) -> setFormat ( $ format ) -> setSize ( $ size ) ; return $ label ; }
8058	public function setWorkerPoolSize ( $ size ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Worker Pool Size for a created pool.' ) ; } $ size = ( int ) $ size ; if ( $ size <= 0 ) { throw new \ InvalidArgumentException ( '"' . $ size . '" is not an integer greater than 0.' ) ; } $ this -> workerPoolSize = $ size ; return $ this ; }
12143	public static function user ( ) { if ( ! static :: $ user and static :: $ factory ) { $ id = static :: provider ( ) -> get ( 'id' ) ; static :: $ user = call_user_func ( static :: $ factory , $ id ) ; } return static :: $ user ; }
8144	public function tokenize ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer -> tokenize ( $ source ) ; }
9660	public static function identify ( $ pFilename ) { $ reader = self :: createReaderForFile ( $ pFilename ) ; $ className = get_class ( $ reader ) ; $ classType = explode ( '\\' , $ className ) ; unset ( $ reader ) ; return array_pop ( $ classType ) ; }
838	public static function fromArray ( $ array , $ saveIndexes = null ) { $ tokens = new self ( \ count ( $ array ) ) ; if ( null === $ saveIndexes || $ saveIndexes ) { foreach ( $ array as $ key => $ val ) { $ tokens [ $ key ] = $ val ; } } else { $ index = 0 ; foreach ( $ array as $ val ) { $ tokens [ $ index ++ ] = $ val ; } } $ tokens -> generateCode ( ) ; return $ tokens ; }
9554	public function naming ( $ namer ) { if ( $ namer instanceof \ Closure ) { $ namer = new ClosureNamer ( $ namer ) ; } $ this -> namer = $ namer ; return $ this ; }
1634	public function boot ( ) { $ this -> app [ 'auth' ] -> viaRequest ( 'api' , function ( $ request ) { if ( $ request -> input ( 'api_token' ) ) { return User :: where ( 'api_token' , $ request -> input ( 'api_token' ) ) -> first ( ) ; } } ) ; }
10681	public function onBeforeWrite ( ) { if ( $ this -> owner -> Title ) { $ this -> owner -> URLSegment = $ this -> generateURLSegment ( $ this -> owner -> Title ) ; } parent :: onBeforeWrite ( ) ; }
3865	public function render ( $ blnNoNativeParsing , $ objCaller ) { $ event = new RenderItemListEvent ( $ this , $ this -> objTemplate , $ objCaller ) ; $ this -> getEventDispatcher ( ) -> dispatch ( MetaModelsEvents :: RENDER_ITEM_LIST , $ event ) ; $ this -> objTemplate -> noItemsMsg = $ this -> getNoItemsCaption ( ) ; $ this -> objTemplate -> details = $ this -> getCaptionText ( 'details' ) ; $ this -> prepare ( ) ; $ strOutputFormat = $ this -> getOutputFormat ( ) ; if ( $ this -> objItems -> getCount ( ) && ! $ blnNoNativeParsing ) { $ this -> objTemplate -> data = $ this -> objItems -> parseAll ( $ strOutputFormat , $ this -> objView ) ; } else { $ this -> objTemplate -> data = array ( ) ; } $ this -> setTitleAndDescription ( ) ; $ this -> objTemplate -> caller = $ objCaller ; $ this -> objTemplate -> items = $ this -> objItems ; $ this -> objTemplate -> filterParams = $ this -> arrParam ; return $ this -> objTemplate -> parse ( $ strOutputFormat ) ; }
2386	public function removeField ( $ name , string $ legend = null ) : self { $ this -> removes [ ] = [ 'fields' => ( array ) $ name , 'parents' => ( array ) $ legend , ] ; return $ this ; }
10979	public function postPersist ( LifecycleEventArgs $ args ) : void { if ( ! $ this -> enableIndexing ) { return ; } $ this -> updateEntity ( $ args -> getObject ( ) , $ args -> getObjectManager ( ) ) ; }
1261	protected function createTransactionNode ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trxRef = $ xml -> appendChild ( $ xml -> createElement ( 'TransactionReference' ) ) ; if ( null !== $ this -> context ) { $ trxRef -> appendChild ( $ xml -> createElement ( 'CustomerContext' , $ this -> context ) ) ; } return $ trxRef -> cloneNode ( true ) ; }
12914	protected function getWhereAsArray ( ) { $ filters = [ ] ; if ( ! empty ( $ this -> filters ) ) { $ filters = $ this -> filters ; } if ( ! $ this -> allowDeleted ) { $ filters [ ] = "(`" . $ this -> table . "`.deleted = 0 OR `" . $ this -> table . "`.deleted IS NULL)" ; } if ( ! empty ( $ this -> joins ) ) { foreach ( $ this -> joins as $ join ) { $ manager = $ join [ 'manager' ] ; $ filters = array_merge ( $ filters , $ manager -> getWhereAsArray ( ) ) ; } } return $ filters ; }
3226	function move ( $ fromPath , $ toPath ) { Path :: checkArgNonRoot ( "fromPath" , $ fromPath ) ; Path :: checkArgNonRoot ( "toPath" , $ toPath ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/move" , array ( "root" => "auto" , "from_path" => $ fromPath , "to_path" => $ toPath , ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
3724	private function buildCacheService ( ContainerBuilder $ container , array $ config ) { if ( ! $ config [ 'enable_cache' ] ) { $ cache = $ container -> getDefinition ( 'metamodels.cache' ) ; $ cache -> setClass ( ArrayCache :: class ) ; $ cache -> setArguments ( [ ] ) ; $ container -> setParameter ( 'metamodels.cache_dir' , null ) ; return ; } $ container -> setParameter ( 'metamodels.cache_dir' , $ config [ 'cache_dir' ] ) ; }
7014	private function format_n ( & $ str ) { if ( strstr ( $ str , '%n' ) ) $ str = str_replace ( '%n' , sprintf ( '%01d' , $ this -> month ) , $ str ) ; }
489	protected function findTableConstraints ( $ table , $ type ) { $ keyColumnUsageTableName = 'INFORMATION_SCHEMA.KEY_COLUMN_USAGE' ; $ tableConstraintsTableName = 'INFORMATION_SCHEMA.TABLE_CONSTRAINTS' ; if ( $ table -> catalogName !== null ) { $ keyColumnUsageTableName = $ table -> catalogName . '.' . $ keyColumnUsageTableName ; $ tableConstraintsTableName = $ table -> catalogName . '.' . $ tableConstraintsTableName ; } $ keyColumnUsageTableName = $ this -> quoteTableName ( $ keyColumnUsageTableName ) ; $ tableConstraintsTableName = $ this -> quoteTableName ( $ tableConstraintsTableName ) ; $ sql = <<<SQLSELECT [kcu].[constraint_name] AS [index_name], [kcu].[column_name] AS [field_name]FROM {$keyColumnUsageTableName} AS [kcu]LEFT JOIN {$tableConstraintsTableName} AS [tc] ON [kcu].[table_schema] = [tc].[table_schema] AND [kcu].[table_name] = [tc].[table_name] AND [kcu].[constraint_name] = [tc].[constraint_name]WHERE [tc].[constraint_type] = :type AND [kcu].[table_name] = :tableName AND [kcu].[table_schema] = :schemaNameSQL ; return $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ':type' => $ type , ] ) -> queryAll ( ) ; }
9873	private function writeDrawings ( XMLWriter $ objWriter = null , PhpspreadsheetWorksheet $ pSheet = null , $ includeCharts = false ) { $ chartCount = ( $ includeCharts ) ? $ pSheet -> getChartCollection ( ) -> count ( ) : 0 ; if ( ( $ pSheet -> getDrawingCollection ( ) -> count ( ) > 0 ) || ( $ chartCount > 0 ) ) { $ objWriter -> startElement ( 'drawing' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId1' ) ; $ objWriter -> endElement ( ) ; } }
9775	function startWith ( string $ value ) : self { return $ this -> expect ( $ this -> target , stringStartsWith ( $ value ) ) ; }
6522	public function isCompatibleForMerge ( Field $ other ) { if ( $ this -> name !== $ other -> name ) { return false ; } if ( $ this -> type !== $ other -> type ) { return false ; } if ( $ this -> rule !== $ other -> rule ) { return false ; } if ( $ this -> className !== $ other -> className ) { return false ; } if ( ! array_intersect ( $ this -> anyOfClassNames , $ other -> anyOfClassNames ) ) { return false ; } return true ; }
4207	private function getPropCommentInfo ( \ ReflectionProperty $ reflectionProperty ) { $ name = $ reflectionProperty -> name ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionProperty ) ; $ info = array ( 'type' => null , 'desc' => $ phpDoc [ 'summary' ] ? $ phpDoc [ 'summary' ] : null , ) ; if ( isset ( $ phpDoc [ 'var' ] ) ) { if ( \ count ( $ phpDoc [ 'var' ] ) == 1 ) { $ var = $ phpDoc [ 'var' ] [ 0 ] ; } else { foreach ( $ phpDoc [ 'var' ] as $ var ) { if ( $ var [ 'name' ] == $ name ) { break ; } } } $ info [ 'type' ] = $ var [ 'type' ] ; if ( ! $ info [ 'desc' ] ) { $ info [ 'desc' ] = $ var [ 'desc' ] ; } elseif ( $ var [ 'desc' ] ) { $ info [ 'desc' ] = $ info [ 'desc' ] . ': ' . $ var [ 'desc' ] ; } } return $ info ; }
2645	public function checkServiceDetails ( $ test = false , $ serviceId = null , $ apiKey = null ) { if ( ! $ test ) { $ uri = rtrim ( $ this -> _getApiServiceUri ( ) , '/' ) ; $ result = $ this -> _fetch ( $ uri ) ; } else { $ uri = $ this -> config -> getApiEndpoint ( ) . 'service/' . $ serviceId ; $ result = $ this -> _fetch ( $ uri , \ Zend_Http_Client :: GET , null , true , $ apiKey ) ; } if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to check Service details.' ) ) ; } return $ result ; }
10773	public static function with ( array $ theseObjects ) : MapsObjectsByIdentity { $ objects = [ ] ; $ entityIds = [ ] ; foreach ( $ theseObjects as $ id => $ object ) { $ objects = IdentityMap :: addTo ( $ objects , ( string ) $ id , $ object ) ; $ entityIds [ theInstanceIdOf ( $ object ) ] = ( string ) $ id ; } return new self ( $ objects , $ entityIds ) ; }
6592	protected function checkAndGetBusters ( ) { if ( $ this -> fileSystem -> fileExists ( $ this -> config [ 'bustersJsonPath' ] ) === false ) { throw new LengthException ( 'busters json not found.' ) ; } $ bustersJson = $ this -> fileSystem -> getFile ( $ this -> config [ 'bustersJsonPath' ] ) ; if ( $ bustersJson == '' ) { throw new UnderflowException ( 'busters json is empty.' ) ; } $ busters = json_decode ( $ bustersJson ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new UnexpectedValueException ( 'bustersJson is invalid JSON.' ) ; } return $ busters ; }
424	protected function adjustLabelFor ( $ options ) { if ( ! isset ( $ options [ 'id' ] ) ) { return ; } $ this -> _inputId = $ options [ 'id' ] ; if ( ! isset ( $ this -> labelOptions [ 'for' ] ) ) { $ this -> labelOptions [ 'for' ] = $ options [ 'id' ] ; } }
8383	public function fetchAll ( ) { if ( $ this -> statement == null || $ this -> getErrorState ( ) != '00000' ) { return false ; } return $ this -> statement -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
5158	public static function create ( array $ data ) : \ One \ Model \ Gallery { $ body = self :: validateString ( ( string ) self :: checkData ( $ data , 'body' , '' ) ) ; $ order = self :: validateInteger ( ( int ) self :: checkData ( $ data , 'order' , null ) ) ; $ photo = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'photo' , '' ) ) ; $ source = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'source' , '' ) ) ; $ lead = self :: validateString ( ( string ) self :: checkData ( $ data , 'lead' , '' ) ) ; return self :: createGallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
8324	public function getPingbacks ( ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get_pingback" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( strpos ( $ responseText , 'OK|' ) !== false ) { $ data = explode ( '|' , $ responseText ) ; unset ( $ data [ 0 ] ) ; return empty ( $ data [ 1 ] ) ? [ ] : array_values ( $ data ) ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
10842	protected function refreshProductSellPrices ( ProductInterface $ product ) { $ sellPrice = $ product -> getSellPrice ( ) ; $ grossAmount = $ sellPrice -> getGrossAmount ( ) ; $ discountedGrossAmount = $ sellPrice -> getDiscountedGrossAmount ( ) ; $ taxRate = $ product -> getSellPriceTax ( ) -> getValue ( ) ; $ netAmount = TaxHelper :: calculateNetPrice ( $ grossAmount , $ taxRate ) ; $ discountedNetAmount = TaxHelper :: calculateNetPrice ( $ discountedGrossAmount , $ taxRate ) ; $ sellPrice -> setTaxRate ( $ taxRate ) ; $ sellPrice -> setTaxAmount ( $ grossAmount - $ netAmount ) ; $ sellPrice -> setNetAmount ( $ netAmount ) ; $ sellPrice -> setDiscountedTaxAmount ( $ discountedGrossAmount - $ discountedNetAmount ) ; $ sellPrice -> setDiscountedNetAmount ( $ discountedNetAmount ) ; }
203	protected function createQuery ( $ targetClass , $ condition ) { $ query = $ targetClass :: find ( ) -> andWhere ( $ condition ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ query ) ; } elseif ( $ this -> filter !== null ) { $ query -> andWhere ( $ this -> filter ) ; } return $ query ; }
3879	public function addSubProcedure ( FilterBuilderSql $ subProcedure ) { $ this -> procedures [ ] = $ subProcedure -> getProcedure ( ) ; $ this -> parameter = array_merge ( $ this -> parameter , $ subProcedure -> getParameters ( ) ) ; return $ this ; }
11221	private static function routeValidator ( ) { self :: $ uri = Url :: getUriMethods ( ) ; self :: $ uri = Url :: setUrlParams ( self :: $ uri ) ; self :: $ uri = Url :: addBackSlash ( self :: $ uri ) ; self :: cleanResources ( ) ; if ( self :: getMethod ( self :: $ uri ) ) { self :: any ( self :: $ uri , self :: $ routes [ self :: $ uri ] ) ; } }
1453	protected function excluded ( string ... $ keys ) : Collection { return collect ( $ keys ) -> mapWithKeys ( function ( $ key ) { return [ $ key => new DisallowedParameter ( $ key ) ] ; } ) ; }
9142	public function getParams ( ) { $ params = array ( ) ; if ( $ paramsAvailable = reset ( $ this -> params ) ) { foreach ( array_keys ( $ paramsAvailable ) as $ paramKey ) { $ params [ $ paramKey ] = $ this -> getParam ( $ paramKey ) ; } } return $ params ; }
3804	private function buildCondition ( $ condition , $ metaModel ) { if ( null === $ condition ) { return null ; } return $ this -> conditionFactory -> createCondition ( $ condition , $ metaModel ) ; }
9219	protected function requestPageNumber ( $ pageNumber , $ forceRefresh = false ) { if ( ! isset ( $ this -> data [ $ this -> pageNumberToKey ( $ pageNumber ) ] ) || ( $ forceRefresh && isset ( $ this -> api ) ) ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { $ params = $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getParams ( ) ; $ params [ CanvasPageLink :: PARAM_PAGE_NUMBER ] = $ pageNumber ; $ page = $ this -> api -> get ( $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getEndpoint ( ) , $ params ) ; $ this -> data = array_replace ( $ this -> data , $ page -> data ) ; $ pagination = $ this -> parsePageLinks ( ) ; $ this -> paginationPerPage [ $ pagination [ CanvasPageLink :: CURRENT ] -> getPageNumber ( ) ] = $ pagination ; return true ; } } return false ; }
12950	public function beforeDelete ( ) { $ this -> _tagsForDelete = [ ] ; $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ this -> _tagsForDelete = ( new Query ( ) ) -> select ( current ( $ relation -> link ) ) -> from ( $ relation -> via -> from [ 0 ] ) -> where ( [ key ( $ relation -> via -> link ) => $ this -> owner -> getPrimaryKey ( ) ] ) -> column ( $ this -> owner -> getDb ( ) ) ; } }
12927	public function lists ( $ offset = 0 , $ limit = 10 ) { $ params = [ 'begin' => $ offset , 'limit' => $ limit , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_LIST , $ params ] ) ; }
6395	public function init ( ) { parent :: init ( ) ; $ this -> path = Yii :: getAlias ( $ this -> path ) ; FileHelper :: createDirectory ( $ this -> path , $ this -> dirMode , true ) ; }
2317	public function computeResize ( ) { $ resizeCoordinates = System :: getContainer ( ) -> get ( 'contao.image.resize_calculator' ) -> calculate ( $ this -> prepareResizeConfig ( ) , new ImageDimensions ( new Box ( $ this -> fileObj -> viewWidth , $ this -> fileObj -> viewHeight ) , $ this -> fileObj -> viewWidth !== $ this -> fileObj -> width ) , $ this -> prepareImportantPart ( ) ) ; return array ( 'width' => $ resizeCoordinates -> getCropSize ( ) -> getWidth ( ) , 'height' => $ resizeCoordinates -> getCropSize ( ) -> getHeight ( ) , 'target_x' => - $ resizeCoordinates -> getCropStart ( ) -> getX ( ) , 'target_y' => - $ resizeCoordinates -> getCropStart ( ) -> getY ( ) , 'target_width' => $ resizeCoordinates -> getSize ( ) -> getWidth ( ) , 'target_height' => $ resizeCoordinates -> getSize ( ) -> getHeight ( ) , ) ; }
348	public static function cssStyleFromArray ( array $ style ) { $ result = '' ; foreach ( $ style as $ name => $ value ) { $ result .= "$name: $value; " ; } return $ result === '' ? null : rtrim ( $ result ) ; }
10701	public static function isBirthNumber ( $ no ) { if ( ! preg_match ( '#^\s*(\d\d)(\d\d)(\d\d)[ /]*(\d\d\d)(\d?)\s*$#' , $ no , $ matches ) ) { return false ; } list ( , $ year , $ month , $ day , $ ext , $ c ) = $ matches ; if ( $ c === '' ) { $ year += $ year < 54 ? 1900 : 1800 ; } else { $ mod = ( $ year . $ month . $ day . $ ext ) % 11 ; if ( $ mod === 10 ) { $ mod = 0 ; } if ( $ mod !== ( int ) $ c ) { return false ; } $ year += $ year < 54 ? 2000 : 1900 ; } if ( $ year > 2003 ) { if ( $ month > 70 ) { $ month -= 70 ; } if ( $ month > 20 && $ month < 50 ) { $ month -= 20 ; } } if ( $ month > 50 ) { $ month -= 50 ; } return checkdate ( $ month , $ day , $ year ) ; }
5052	public function getContentType ( ) { if ( ! $ this -> contentType ) { $ this -> setContentType ( $ this -> getParam ( 'contentType' ) ? : static :: TYPE_JSON ) ; } return $ this -> contentType ; }
12447	static function run_build_dependencies ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; $ current = $ opts [ 'extension' ] [ 'name' ] ; foreach ( $ opts [ 'dependencies' ] [ 'extensions' ] as $ ext => $ source ) { if ( $ ext != $ current ) { foreach ( $ source as $ type => $ def ) { break ; } $ tempconf = array ( 'extension' => array ( 'name' => $ ext ) , 'version' => array ( 'major' => 0 , 'minor' => 0 , 'release' => 0 ) , $ type => $ def ) ; $ tempconffile = self :: getOptionsDir ( ) . "/options-tmp_$ext.yaml" ; pakeYaml :: emitfile ( $ tempconf , $ tempconffile ) ; $ task = pakeTask :: get ( 'init' ) ; $ task -> execute ( array ( "tmp_$ext" ) , array_merge ( $ cliopts , array ( 'skip-init' => false , 'skip-init-fetch' => false , 'skip-init-clean' => true ) ) ) ; if ( is_file ( self :: getBuildDir ( $ opts ) . "/$ext/pake/options-$ext.yaml" ) ) { pake_copy ( self :: getBuildDir ( $ opts ) . "/$ext/pake/options-$ext.yaml" , self :: getOptionsDir ( ) . "/options-$ext.yaml" ) ; } else { throw new pakeException ( "Missing pake/options.yaml extension in dependent extension $ext" ) ; } $ task -> execute ( array ( "tmp_$ext" ) , array_merge ( $ cliopts , array ( 'skip-init' => false , 'skip-init-fetch' => true , 'skip-init-clean' => false ) ) ) ; pake_remove ( $ tempconffile , '' ) ; $ task = pakeTask :: get ( 'build' ) ; foreach ( $ task -> get_prerequisites ( ) as $ pretask ) { $ pretask = pakeTask :: get ( $ pretask ) ; $ pretask -> execute ( array ( $ ext ) , array_merge ( $ opts , array ( 'skip-init' => true ) ) ) ; } $ task -> execute ( array ( $ ext ) , array_merge ( $ opts , array ( 'skip-init' => true ) ) ) ; } } }
5972	public function deployment ( ) { if ( ! $ this -> deployment instanceof DeploymentController ) { $ this -> deployment = new DeploymentController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> deployment -> setLogger ( $ this -> logger ) ; } return $ this -> deployment ; }
4150	protected function getBinaryFile ( $ filename ) { if ( ! file_exists ( $ filename ) ) { throw new FileNotFoundException ; } if ( ! is_readable ( $ filename ) ) { throw new FileNotReadableException ; } ob_start ( ) ; readfile ( $ filename ) ; $ binary = ob_get_contents ( ) ; ob_end_clean ( ) ; unset ( $ filename ) ; return $ binary ; }
10338	function toXML ( ) { $ xml = new SimpleXMLElement ( "<?xml version=\"1.0\"?><property></property>" ) ; $ xml -> addChild ( "key" , $ this -> key ) ; $ xml -> addChild ( "value" , $ this -> value ) ; return $ xml ; }
1207	public function moveToPosition ( ItemInterface $ item , $ position ) { $ this -> moveChildToPosition ( $ item -> getParent ( ) , $ item , $ position ) ; }
9738	public function setFitToHeight ( $ pValue , $ pUpdate = true ) { $ this -> fitToHeight = $ pValue ; if ( $ pUpdate ) { $ this -> fitToPage = true ; } return $ this ; }
10261	public function getEmail ( $ person_name = null , $ domain = null ) { $ username = $ this -> getUsername ( $ person_name ) ; $ domains = [ ] ; $ domains [ ] = ! empty ( $ domain ) ? $ domain : $ this -> getDomain ( ) ; $ domains [ ] = 'gmail.com' ; $ domains [ ] = 'yahoo.com' ; $ domains [ ] = 'me.com' ; $ domains [ ] = 'msn.com' ; $ domains [ ] = 'hotmail.com' ; $ domain = $ this -> fromArray ( $ domains ) ; return preg_replace ( '/[^0-9a-z_A-Z.]/' , '' , strtolower ( $ username ) ) . '@' . $ domain ; }
4400	protected function saveTransationRef ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ baseItem , $ ref ) { $ type = \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT ; $ serviceItem = $ this -> getBasketService ( $ baseItem , $ type , $ this -> getServiceItem ( ) -> getCode ( ) ) ; $ attr = array ( 'TRANSACTIONID' => $ ref ) ; $ this -> setAttributes ( $ serviceItem , $ attr , 'payment/omnipay' ) ; $ this -> saveOrderBase ( $ baseItem ) ; }
209	protected function formatScalarValue ( $ value ) { if ( $ value === true ) { return 'true' ; } if ( $ value === false ) { return 'false' ; } if ( is_float ( $ value ) ) { return StringHelper :: floatToString ( $ value ) ; } return ( string ) $ value ; }
9030	public function exception ( Request $ request ) { $ ex = $ request -> getException ( ) ; $ this -> response -> setCode ( 500 ) ; printf ( "<h2>%s</h2>" , HttpStatus :: getStatus ( 500 ) ) ; while ( $ ex != null ) { printf ( "<h3>%s</h3><pre>%s</pre>" , $ ex -> getMessage ( ) , $ ex -> getTraceAsString ( ) ) ; $ ex = $ ex -> getPrevious ( ) ; } }
1202	public function buildItem ( ItemInterface $ item , array $ options ) { $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setCurrent ( $ options [ 'current' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) ; $ this -> buildExtras ( $ item , $ options ) ; }
2814	public function getBlock ( $ blockName ) { if ( ! array_key_exists ( $ blockName , $ this -> blocks ) ) { throw new Exception ( 'Unable to find block with name ' . $ blockName ) ; } return $ this -> blocks [ $ blockName ] ; }
12148	public function getExceptionCode ( \ Exception $ exception ) { $ class = get_class ( $ exception ) ; $ exceptions = $ this -> getExceptions ( ) ; if ( ! isset ( $ exceptions [ $ class ] ) ) { throw new \ RuntimeException ( sprintf ( 'Not exist exception "%s" in storage.' , $ class ) ) ; } return $ exceptions [ $ class ] ; }
11020	public function handle ( IEvent $ event , $ name , IDispatcher $ dispatcher ) { if ( $ event instanceof BeforeControllerRunEvent ) { return $ this -> onBeforeAction ( ) ; } elseif ( $ event instanceof AfterControllerRunEvent ) { return $ this -> onAfterAction ( ) ; } }
12899	public function getResponse ( ) { if ( $ this -> response ) { return $ this -> response ; } return $ this -> response = \ GuzzleHttp \ Psr7 \ parse_response ( $ this -> getResponseStream ( ) ) ; }
9786	public function parseEscape ( ) { $ token = $ this -> pop ( 'ESCAPE' ) ; $ value = $ this -> stripQuotes ( $ token [ 1 ] ) ; $ this -> currLine += substr_count ( $ value , "\n" ) ; return '$output .= \'' . $ value . "';\n" ; }
155	public function scalar ( $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } return $ this -> createCommand ( $ db ) -> queryScalar ( ) ; }
7944	public function ipGetRange ( $ id , $ ip ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Missing parameter $ip.' ) ; return json_decode ( $ this -> getIpProperties ( $ id , $ ip ) ) -> range ; }
5817	public function getFusionTagTypes ( ) { $ types = array ( ) ; $ configuration = Config :: inst ( ) ; $ exclusions = $ configuration -> get ( 'FusionService' , 'tag_type_exclusions' ) ; $ classes = ClassInfo :: subclassesFor ( 'DataObject' ) ; unset ( $ classes [ 'FusionTag' ] ) ; foreach ( $ classes as $ class ) { if ( ( strpos ( strrev ( $ class ) , strrev ( 'Tag' ) ) === 0 ) && ! in_array ( $ class , $ exclusions ) && ! ClassInfo :: classImplements ( $ class , 'TestOnly' ) ) { $ types [ $ class ] = 'Title' ; } } foreach ( $ configuration -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( in_array ( $ type , $ classes ) && ! in_array ( $ type , $ exclusions ) ) { $ types [ $ type ] = $ field ; } } return $ types ; }
594	private function composeCircularDependencyTrace ( $ circularDependencyName , array $ registered ) { $ dependencyTrace = [ ] ; $ startFound = false ; foreach ( $ registered as $ name => $ value ) { if ( $ name === $ circularDependencyName ) { $ startFound = true ; } if ( $ startFound && $ value === false ) { $ dependencyTrace [ ] = $ name ; } } $ dependencyTrace [ ] = $ circularDependencyName ; return implode ( ' -> ' , $ dependencyTrace ) ; }
12343	public function newAction ( Request $ request ) { $ post = new Post ( ) ; $ form = $ this -> createForm ( 'BlogBundle\Form\PostType' , $ post , array ( 'translator' => $ this -> get ( 'translator' ) ) ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ user = $ this -> container -> get ( 'security.token_storage' ) -> getToken ( ) -> getUser ( ) ; $ post -> setActor ( $ user ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ post ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'post.created' ) ; return $ this -> redirectToRoute ( 'blog_post_index' ) ; } return array ( 'category' => $ post , 'form' => $ form -> createView ( ) , ) ; }
8920	protected function parseRelator ( & $ node , & $ out , $ default = null ) { $ relterm = $ node -> text ( 'marc:subfield[@code="e"]' ) ; $ relcode = $ node -> text ( 'marc:subfield[@code="4"]' ) ; if ( ! empty ( $ relcode ) ) { $ out [ 'role' ] = $ relcode ; } elseif ( ! empty ( $ relterm ) ) { $ out [ 'role' ] = $ relterm ; } elseif ( ! is_null ( $ default ) ) { $ out [ 'role' ] = $ default ; } }
9322	protected function registerMarkdownEnvironment ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.environment' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'markdown' ] ; $ environment = Environment :: createCommonMarkEnvironment ( ) ; if ( $ config [ 'configurations' ] ) { $ environment -> mergeConfig ( $ config [ 'configurations' ] ) ; } foreach ( $ config [ 'extensions' ] as $ extension ) { if ( class_exists ( $ extension ) ) { $ environment -> addExtension ( new $ extension ( ) ) ; } } return $ environment ; } ) ; $ app -> alias ( 'commonmark.environment' , Environment :: class ) ; }
2872	public function init ( Mage_Core_Model_Abstract $ model ) { $ this -> class = get_class ( $ model ) ; $ this -> resource = $ model -> getResourceName ( ) ; $ this -> count = 0 ; }
138	public function update ( RepositoryInterface $ repo , UpdateOperation $ operation ) { $ initial = $ operation -> getInitialPackage ( ) ; $ target = $ operation -> getTargetPackage ( ) ; $ initialType = $ initial -> getType ( ) ; $ targetType = $ target -> getType ( ) ; if ( $ initialType === $ targetType ) { $ installer = $ this -> getInstaller ( $ initialType ) ; $ installer -> update ( $ repo , $ initial , $ target ) ; $ this -> markForNotification ( $ target ) ; } else { $ this -> getInstaller ( $ initialType ) -> uninstall ( $ repo , $ initial ) ; $ this -> getInstaller ( $ targetType ) -> install ( $ repo , $ target ) ; } }
3719	protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) ) { return false ; } if ( $ event -> getPropertyName ( ) !== 'type' ) { return false ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ request -> request -> get ( 'act' , null ) === 'select' && ! $ event -> getModel ( ) -> getId ( ) ) { return false ; } return true ; }
3127	protected function isEndPoint ( TimePoint $ point ) { return $ point -> match ( null , TimePoint :: TARGET_ALL , TimePoint :: TYPE_END ) ; }
671	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } $ model -> scenario = $ this -> scenario ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) === false && ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to update the object for unknown reason.' ) ; } return $ model ; }
9281	public function getPending ( array $ options = array ( ) ) { $ where = new Where ( ) ; $ where -> equalTo ( "{$this->tableName}.status" , JobEntity :: STATUS_PENDING ) ; return $ this -> fetchByWhere ( $ where , $ options ) ; }
2824	public function getExpirationDate ( $ currentDate ) { $ numberOfDays = Mage :: helper ( 'sheep_debug' ) -> getPersistLifetime ( ) ; return date ( self :: DATE_FORMAT , strtotime ( "-{$numberOfDays} days {$currentDate}" ) ) ; }
3846	protected static function changeSubPalettesToConditions ( ) { $ objDB = self :: DB ( ) ; if ( ! $ objDB -> tableExists ( 'tl_metamodel_dcasetting_condition' ) ) { $ objDB -> execute ( 'CREATE TABLE `tl_metamodel_dcasetting_condition` ( `id` int(10) unsigned NOT NULL auto_increment, `pid` int(10) unsigned NOT NULL default \'0\', `settingId` int(10) unsigned NOT NULL default \'0\', `sorting` int(10) unsigned NOT NULL default \'0\', `tstamp` int(10) unsigned NOT NULL default \'0\', `enabled` char(1) NOT NULL default \'\', `type` varchar(255) NOT NULL default \'\', `attr_id` int(10) unsigned NOT NULL default \'0\', `comment` varchar(255) NOT NULL default \'\', `value` blob NULL, PRIMARY KEY (`id`) )ENGINE=MyISAM DEFAULT CHARSET=utf8;' ) ; } if ( $ objDB -> tableExists ( 'tl_metamodel_dcasetting' , null , true ) && $ objDB -> fieldExists ( 'subpalette' , 'tl_metamodel_dcasetting' , true ) ) { $ subpalettes = $ objDB -> execute ( 'SELECT * FROM tl_metamodel_dcasetting WHERE subpalette!=0' ) ; if ( $ subpalettes -> numRows ) { $ attributes = $ objDB -> execute ( ' SELECT attr_id, colName FROM tl_metamodel_dcasetting AS setting LEFT JOIN tl_metamodel_attribute AS attribute ON (setting.attr_id=attribute.id) WHERE dcatype=\'attribute\' ' ) ; $ attr = array ( ) ; while ( $ attributes -> next ( ) ) { $ attr [ $ attributes -> attr_id ] = $ attributes -> colName ; } $ checkboxes = $ objDB -> execute ( ' SELECT * FROM tl_metamodel_dcasetting WHERE subpalette=0 AND dcatype=\'attribute\' ' ) ; $ check = array ( ) ; while ( $ checkboxes -> next ( ) ) { $ check [ $ checkboxes -> id ] = $ checkboxes -> attr_id ; } while ( $ subpalettes -> next ( ) ) { $ data = array ( 'pid' => 0 , 'settingId' => $ subpalettes -> id , 'sorting' => '128' , 'tstamp' => time ( ) , 'enabled' => '1' , 'type' => 'conditionpropertyvalueis' , 'attr_id' => $ check [ $ subpalettes -> subpalette ] , 'comment' => sprintf ( 'Only show when checkbox "%s" is checked' , $ attr [ $ check [ $ subpalettes -> subpalette ] ] ) , 'value' => '1' , ) ; $ objDB -> prepare ( 'INSERT INTO tl_metamodel_dcasetting_condition %s' ) -> set ( $ data ) -> execute ( ) ; $ objDB -> prepare ( 'UPDATE tl_metamodel_dcasetting SET subpalette=0 WHERE id=?' ) -> execute ( $ subpalettes -> id ) ; $ objDB -> prepare ( 'UPDATE tl_metamodel_dcasetting SET submitOnChange=1 WHERE id=?' ) -> execute ( $ subpalettes -> subpalette ) ; } } TableManipulation :: dropColumn ( 'tl_metamodel_dcasetting' , 'subpalette' , true ) ; } }
9548	public function validate ( UploadedFile $ file ) { foreach ( $ this -> constraints as $ constraint ) { if ( ! $ constraint -> validate ( $ file ) ) { throw new ConstraintException ( $ constraint , $ file ) ; } } return true ; }
11171	public function getFilters ( $ columnDescriptions = [ ] , $ activeFieldName = false ) { $ filters = [ ] ; if ( count ( $ this -> filtersArray ) > 0 ) { foreach ( $ this -> filtersArray as $ key => $ value ) { if ( isset ( $ this -> filters [ $ key ] ) ) { $ activeFieldName = $ activeFieldName ? : $ this -> filtersArray [ 'orderBy' ] ; $ friendlyFieldName = isset ( $ columnDescriptions [ $ activeFieldName ] ) ? $ columnDescriptions [ $ activeFieldName ] : $ activeFieldName ; $ filters [ ] = sprintf ( $ this -> filters [ $ key ] , $ friendlyFieldName , $ value ) ; } } } return $ filters ; }
7541	function setIndex ( $ index ) { if ( $ this -> parent ) { if ( $ index > $ this -> index ( ) ) { -- $ index ; } $ this -> delete ( ) ; $ this -> parent -> addChild ( $ this , $ index ) ; } }
9722	public function write ( Spreadsheet $ spreadsheet , $ filename , array $ writers = [ 'Xlsx' , 'Xls' ] ) { $ spreadsheet -> setActiveSheetIndex ( 0 ) ; foreach ( $ writers as $ writerType ) { $ path = $ this -> getFilename ( $ filename , mb_strtolower ( $ writerType ) ) ; $ writer = IOFactory :: createWriter ( $ spreadsheet , $ writerType ) ; if ( $ writer instanceof Pdf ) { $ tempDir = $ this -> getTemporaryFolder ( ) ; $ writer -> setTempDir ( $ tempDir ) ; } $ callStartTime = microtime ( true ) ; $ writer -> save ( $ path ) ; $ this -> logWrite ( $ writer , $ path , $ callStartTime ) ; } $ this -> logEndingNotes ( ) ; }
6816	public function isSameAs ( Adjustment $ adjustment ) : bool { return $ this -> name === $ adjustment -> getName ( ) && $ this -> rate === $ adjustment -> getRate ( ) ; }
2889	public function onCollectionLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ collection = $ observer -> getData ( 'collection' ) ; $ this -> getRequestInfo ( ) -> addCollection ( $ collection ) ; }
2794	public function setTempDirectory ( $ dir ) { $ dir = rtrim ( $ dir , ' \\/' ) ; if ( ! is_dir ( $ dir ) || ! is_readable ( $ dir ) ) { throw new InvalidArgumentException ( 'Invalid cache directory: "' . $ dir . '"' ) ; } $ this -> tempDirectory = $ dir ; return $ this ; }
12253	public function dump ( ) { $ dom = new DOMDocument ( '1.0' ) ; $ dom -> preserveWhiteSpace = false ; $ dom -> formatOutput = true ; $ dom -> loadXML ( $ this -> asXML ( ) ) ; return $ dom -> saveXML ( ) ; }
10998	public function getLineCount ( ) : int { $ ret = 0 ; $ fh = fopen ( $ this -> path , "r" ) ; while ( ! feof ( $ fh ) ) { $ buffer = fread ( $ fh , 8192 ) ; $ ret += substr_count ( $ buffer , PHP_EOL ) ; } fclose ( $ fh ) ; return $ ret ; }
113	private function getInstallPath ( PackageInterface $ package , $ global = false ) { if ( ! $ global ) { return $ this -> composer -> getInstallationManager ( ) -> getInstallPath ( $ package ) ; } return $ this -> globalComposer -> getInstallationManager ( ) -> getInstallPath ( $ package ) ; }
2705	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_AUTH_SNIPPET_PATH ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> hasSnippet ( $ activeVersion , $ name ) ; if ( $ status == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
6850	public static function years ( $ start = false , $ end = false ) { $ start = ( $ start === false ) ? ( date ( 'Y' ) - 5 ) : ( int ) $ start ; $ end = ( $ end === false ) ? ( date ( 'Y' ) + 5 ) : ( int ) $ end ; $ years = array ( ) ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { $ years [ $ i ] = ( string ) $ i ; } return $ years ; }
3569	public function __issetHook ( ) { return function ( $ next , $ isset , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ isset ) { $ isset = ( bool ) $ this -> hasMeta ( $ key ) ; } return $ next ( $ isset , $ args ) ; } ; }
1255	private function getValueToAssignToValue ( \ stdClass $ meta ) { if ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\Base64BinaryType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\BooleanType' , false ) ) { return strtolower ( $ meta -> strData ) === 'true' ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DecimalType' , false ) ) { return is_int ( 0 + $ meta -> strData ) ? ( integer ) $ meta -> strData : ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DoubleType' , false ) ) { return ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\IntegerType' , false ) ) { return ( integer ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\StringType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\TokenType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\URIType' , false ) ) { return $ meta -> strData ; } return $ meta -> strData ; }
3666	public function convertParameter ( $ arrMatch ) { list ( $ strSource , $ strQuery ) = explode ( '?' , $ arrMatch [ 1 ] , 2 ) ; parse_str ( $ strQuery , $ arrArgs ) ; $ arrName = ( array ) $ arrArgs [ 'name' ] ; $ var = $ this -> getValueFromSource ( $ strSource , array_shift ( $ arrName ) , $ arrArgs ) ; $ index = 0 ; $ count = count ( $ arrName ) ; while ( $ index < $ count && is_array ( $ var ) ) { $ var = $ var [ $ arrName [ $ index ++ ] ] ; } if ( $ index != $ count || $ var === null ) { if ( array_key_exists ( 'default' , $ arrArgs ) && ( null !== $ arrArgs [ 'default' ] ) ) { $ this -> addParameter ( $ arrArgs [ 'default' ] ) ; return '?' ; } else { return 'NULL' ; } } if ( ! isset ( $ arrArgs [ 'aggregate' ] ) ) { $ this -> addParameter ( $ var ) ; return '?' ; } return $ this -> convertParameterAggregate ( $ var , $ arrArgs ) ; }
8370	public function perform ( array $ args = [ ] ) : int { $ this -> args = $ args ; unset ( $ this -> args [ 'messages' ] ) ; $ transport = new Swift_SmtpTransport ( $ args [ 'smtp' ] [ 'host' ] , $ args [ 'smtp' ] [ 'port' ] ) ; $ transport -> setUsername ( $ args [ 'smtp' ] [ 'username' ] ) ; $ transport -> setPassword ( $ args [ 'smtp' ] [ 'password' ] ) ; $ this -> messages = $ args [ 'messages' ] ; foreach ( $ messages as & $ message ) { if ( $ shutdown ) { break ; } $ mailer = new Swift_Mailer ( $ transport ) ; $ m = ( new Swift_Message ( $ message [ 'subject' ] ) ) -> setFrom ( [ $ message [ 'from' ] [ 'email' ] => $ message [ 'from' ] [ 'email' ] ] ) -> setTo ( [ $ message [ 'to' ] [ 'email' ] => $ message [ 'to' ] [ 'name' ] ] ) -> setBody ( $ message [ 'message' ] ) ; $ message [ 'sent' ] = ( $ mailer -> send ( $ m ) === 1 ) ; } return 0 ; }
2918	public function appendSetter ( $ key , $ value = null , $ comment = null , $ export = false ) { $ line = $ this -> formatter -> formatSetterLine ( $ key , $ value , $ comment , $ export ) ; return $ this -> appendLine ( $ line ) ; }
11822	public function render_admin_header ( ) { $ page = filter_input ( INPUT_GET , 'page' ) ; if ( $ this -> page != $ page ) { return ; } echo '<style type="text/css">' ; echo $ this -> twig -> render ( 'list_table.css.twig' , array ( ) ) ; echo '</style>' ; }
1130	public function makeFirstChildOf ( $ node ) { if ( $ node -> children ( ) -> count ( ) == 0 ) return $ this -> makeChildOf ( $ node ) ; return $ this -> moveToLeftOf ( $ node -> children ( ) -> first ( ) ) ; }
10362	public static function exception ( $ exception ) { try { while ( ob_get_level ( ) > 0 ) ob_end_clean ( ) ; $ error [ 'code' ] = $ exception -> getCode ( ) ; $ error [ 'message' ] = $ exception -> getMessage ( ) ; $ error [ 'file' ] = $ exception -> getFile ( ) ; $ error [ 'line' ] = $ exception -> getLine ( ) ; if ( $ exception instanceof \ ErrorException ) { $ error [ 'type' ] = 'ErrorException: ' ; $ error [ 'type' ] .= in_array ( $ error [ 'code' ] , array_keys ( ErrorHandler :: $ levels ) ) ? ErrorHandler :: $ levels [ $ error [ 'code' ] ] : 'Unknown Error' ; } else { $ error [ 'type' ] = get_class ( $ exception ) ; } ErrorHandler :: writeLogs ( "{$error['type']}: {$error['message']} in {$error['file']} at line {$error['line']}" ) ; @ header ( 'Content-Type: text/html; charset=UTF-8' ) ; if ( DEVELOPMENT ) { $ error [ 'backtrace' ] = $ exception -> getTrace ( ) ; if ( $ exception instanceof \ ErrorException ) { $ error [ 'backtrace' ] = array_slice ( $ error [ 'backtrace' ] , 1 ) ; } $ error [ 'backtrace' ] = self :: formatBacktrace ( $ error [ 'backtrace' ] ) ; $ error [ 'highlighted' ] = self :: highlightCode ( $ error [ 'file' ] , $ error [ 'line' ] ) ; @ header ( 'HTTP/1.1 500 Internal Server Error' ) ; include 'views/exception.php' ; } else { @ header ( 'HTTP/1.1 500 Internal Server Error' ) ; include 'views/production.php' ; } } catch ( Exception $ e ) { while ( ob_get_level ( ) > 0 ) ob_end_clean ( ) ; echo $ e -> getMessage ( ) . ' in ' . $ e -> getFile ( ) . ' (line ' . $ e -> getLine ( ) . ').' ; } exit ( 1 ) ; }
4909	public function renderForm ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ formHelper = $ renderer -> plugin ( 'form' ) ; $ fieldset = $ form -> getBaseFieldset ( ) ; $ resetPartial = false ; if ( $ fieldset instanceof ViewPartialProviderInterface ) { $ origPartial = $ fieldset -> getViewPartial ( ) ; $ partial = "$origPartial.form" ; if ( $ renderer -> resolver ( $ partial ) ) { $ fieldset -> setViewPartial ( $ partial ) ; $ resetPartial = true ; } } $ markup = $ formHelper -> renderBare ( $ form , $ layout , $ parameter ) ; if ( $ resetPartial ) { $ fieldset -> setViewPartial ( $ origPartial ) ; } return $ markup ; }
9171	public function getControllerPluginConfig ( ) { return [ 'aliases' => [ 'email' => Controller \ Plugin \ Email :: class , 'mutex' => Controller \ Plugin \ Mutex :: class , 'referer' => Controller \ Plugin \ Referer :: class , 'settings' => Controller \ Plugin \ Settings :: class , 'thumbnail' => Controller \ Plugin \ Thumbnail :: class , 'zettaUrl' => Controller \ Plugin \ Url :: class , ] , 'factories' => [ Controller \ Plugin \ Email :: class => Controller \ Plugin \ Factory \ EmailFactory :: class , Controller \ Plugin \ Mutex :: class => Controller \ Plugin \ Factory \ MutexFactory :: class , Controller \ Plugin \ Referer :: class => InvokableFactory :: class , Controller \ Plugin \ Settings :: class => Factory \ WithSettingsFactory :: class , Controller \ Plugin \ Thumbnail :: class => Factory \ WithThumbnailFactory :: class , Controller \ Plugin \ Url :: class => Factory \ WithUrlConfigFactory :: class , ] , ] ; }
3260	protected function process ( Request $ request ) { $ validator = Validator :: make ( [ 'order_id' => $ request -> get ( 'order_id' ) , 'status' => $ request -> get ( 'status' ) , 'shoptoken' => $ request -> get ( 'shoptoken' ) , ] , [ 'order_id' => 'required|exists:' . config ( 'shop.order_table' ) . ',id' , 'status' => 'required|in:success,fail' , 'shoptoken' => 'required|exists:' . config ( 'shop.transaction_table' ) . ',token,order_id,' . $ request -> get ( 'order_id' ) , ] ) ; if ( $ validator -> fails ( ) ) { abort ( 404 ) ; } $ order = call_user_func ( config ( 'shop.order' ) . '::find' , $ request -> get ( 'order_id' ) ) ; $ transaction = $ order -> transactions ( ) -> where ( 'token' , $ request -> get ( 'shoptoken' ) ) -> first ( ) ; Shop :: callback ( $ order , $ transaction , $ request -> get ( 'status' ) , $ request -> all ( ) ) ; $ transaction -> token = null ; $ transaction -> save ( ) ; return redirect ( ) -> route ( config ( 'shop.callback_redirect_route' ) , [ 'orderId' => $ order -> id ] ) ; }
3708	protected function checkRedirect ( $ widgets , $ wantedParameter , $ allParameter ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the new "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( Input :: post ( 'FORM_SUBMIT' ) != $ this -> formId ) { return ; } $ redirectParameters = $ allParameter [ 'other' ] ; foreach ( $ wantedParameter as $ widgetName ) { $ filter = $ widgets [ $ widgetName ] ; if ( $ filter [ 'urlvalue' ] !== null ) { $ redirectParameters [ $ widgetName ] = $ filter [ 'urlvalue' ] ; } } $ filterUrl = new FilterUrl ( $ this -> objFilterConfig -> getJumpTo ( ) , [ ] , $ redirectParameters ) ; $ dispatcher = $ this -> getDispatcher ( ) ; $ dispatcher -> dispatch ( ContaoEvents :: CONTROLLER_REDIRECT , new RedirectEvent ( $ this -> filterUrlBuilder -> generate ( $ filterUrl ) ) ) ; }
2457	public function deleteChilds ( $ table , $ id , & $ delete ) { $ cctable = array ( ) ; $ ctable = $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'ctable' ] ; if ( ! \ is_array ( $ ctable ) ) { return ; } foreach ( $ ctable as $ v ) { $ this -> loadDataContainer ( $ v ) ; $ cctable [ $ v ] = $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'ctable' ] ; if ( $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'dynamicPtable' ] ) { $ ptable = $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'ptable' ] ; $ cond = ( $ ptable == 'tl_article' ) ? "(ptable=? OR ptable='')" : "ptable=?" ; $ objDelete = $ this -> Database -> prepare ( "SELECT id FROM $v WHERE pid=? AND $cond" ) -> execute ( $ id , $ ptable ) ; } else { $ objDelete = $ this -> Database -> prepare ( "SELECT id FROM $v WHERE pid=?" ) -> execute ( $ id ) ; } if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ v ] [ 'config' ] [ 'doNotDeleteRecords' ] && \ strlen ( $ v ) && $ objDelete -> numRows ) { foreach ( $ objDelete -> fetchAllAssoc ( ) as $ row ) { $ delete [ $ v ] [ ] = $ row [ 'id' ] ; if ( ! empty ( $ cctable [ $ v ] ) ) { $ this -> deleteChilds ( $ v , $ row [ 'id' ] , $ delete ) ; } } } } }
10919	public static function getArray ( $ language ) { $ fileName = __DIR__ . '/stop-words/' . $ language . '.txt' ; if ( file_exists ( $ fileName ) ) { return array_map ( 'trim' , file ( $ fileName ) ) ; } return [ ] ; }
2026	public static function findPublishedSubpagesWithoutGuestsByPid ( $ intPid , $ blnShowHidden = false , $ blnIsSitemap = false ) { $ time = Date :: floorToMinute ( ) ; $ objSubpages = Database :: getInstance ( ) -> prepare ( "SELECT p1.*, (SELECT COUNT(*) FROM tl_page p2 WHERE p2.pid=p1.id AND p2.type!='root' AND p2.type!='error_401' AND p2.type!='error_403' AND p2.type!='error_404'" . ( ! $ blnShowHidden ? ( $ blnIsSitemap ? " AND (p2.hide='' OR sitemap='map_always')" : " AND p2.hide=''" ) : "" ) . ( FE_USER_LOGGED_IN ? " AND p2.guests=''" : "" ) . ( ! BE_USER_LOGGED_IN ? " AND (p2.start='' OR p2.start<='$time') AND (p2.stop='' OR p2.stop>'" . ( $ time + 60 ) . "') AND p2.published='1'" : "" ) . ") AS subpages FROM tl_page p1 WHERE p1.pid=? AND p1.type!='root' AND p1.type!='error_401' AND p1.type!='error_403' AND p1.type!='error_404'" . ( ! $ blnShowHidden ? ( $ blnIsSitemap ? " AND (p1.hide='' OR sitemap='map_always')" : " AND p1.hide=''" ) : "" ) . ( FE_USER_LOGGED_IN ? " AND p1.guests=''" : "" ) . ( ! BE_USER_LOGGED_IN ? " AND (p1.start='' OR p1.start<='$time') AND (p1.stop='' OR p1.stop>'" . ( $ time + 60 ) . "') AND p1.published='1'" : "" ) . " ORDER BY p1.sorting" ) -> execute ( $ intPid ) ; if ( $ objSubpages -> numRows < 1 ) { return null ; } return static :: createCollectionFromDbResult ( $ objSubpages , 'tl_page' ) ; }
12145	public function set ( $ name , $ value = null ) { if ( $ value == null ) { return false ; } $ this -> settings [ $ name ] = $ value ; }
2465	public function checkPermission ( ) { $ bundles = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( ! isset ( $ bundles [ 'ContaoCommentsBundle' ] ) ) { $ key = array_search ( 'allowComments' , $ GLOBALS [ 'TL_DCA' ] [ 'tl_faq' ] [ 'list' ] [ 'sorting' ] [ 'headerFields' ] ) ; unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_faq' ] [ 'list' ] [ 'sorting' ] [ 'headerFields' ] [ $ key ] ) ; } }
12372	public function addRule ( string $ name , callable $ func , $ errorMsg = null ) : self { $ this -> rules [ $ name ] = array ( $ func , $ errorMsg ) ; return $ this ; }
9149	public function markAsUnread ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; if ( ! is_null ( $ object -> read_at ) ) { $ object -> forceFill ( [ 'read_at' => null ] ) -> save ( ) ; } \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
4062	private static function isEmptyArrayEquivalent ( $ expected , $ actual ) { return ( gettype ( $ expected ) == 'string' ) && ( ( gettype ( $ actual ) == 'array' ) || ( gettype ( $ actual ) == 'NULL' ) ) && empty ( $ actual ) && empty ( $ expected ) ; }
8349	public static function toArray ( ) : array { if ( static :: $ array == null ) { $ ref = new \ ReflectionClass ( static :: class ) ; $ consts = $ ref -> getConstants ( ) ; static :: $ array = array ( ) ; foreach ( $ consts as $ key => $ value ) { if ( stripos ( $ key , 'VALUE_' ) === 0 ) { static :: $ array [ $ key ] = $ value ; } } } return static :: $ array ; }
6408	public static function filterBy ( IteratorAggregate $ unfiltered , string $ className ) : IteratorAggregate { return self :: from ( Iterators :: filterBy ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ className ) ) ; }
9352	public function cofactor ( ) { $ c = new self ( $ this -> size -> rows , $ this -> size -> cols ) ; for ( $ m = 0 ; $ m < $ this -> size -> rows ; $ m ++ ) { $ arr_row = array ( ) ; for ( $ n = 0 ; $ n < $ this -> size -> cols ; $ n ++ ) { if ( $ this -> size -> cols == 2 ) { $ arr_row [ ] = pow ( - 1 , $ m + $ n ) * $ this -> subMatrix ( $ m , $ n ) -> get ( 0 , 0 ) ; } else { $ arr_row [ ] = pow ( - 1 , $ m + $ n ) * $ this -> subMatrix ( $ m , $ n ) -> det ( ) ; } } $ c -> addRow ( $ arr_row ) ; } return $ c ; }
8083	public function & getFormErrors ( $ channel = '' ) { $ channel = $ this -> namespaceChannel ( $ channel ) ; if ( ! isset ( $ this -> console [ 'form' ] [ $ channel ] ) ) { $ this -> console [ 'form' ] [ $ channel ] = array ( ) ; } return $ this -> console [ 'form' ] [ $ channel ] ; }
11753	public function close ( $ msgId , $ index ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CLOSE_COMMENT , $ params ] ) ; }
1159	public function getMessage ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> fakeValidationData ( $ attribute , $ rule , $ parameters ) ; $ message = $ this -> validator -> getMessage ( $ attribute , $ rule ) ; $ message = $ this -> validator -> makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) ; $ this -> validator -> setData ( $ data ) ; return $ message ; }
14	public function copyTo ( $ file , $ target ) { if ( $ this -> enabled ) { $ file = preg_replace ( '{[^' . $ this -> whitelist . ']}i' , '-' , $ file ) ; if ( file_exists ( $ this -> root . $ file ) ) { try { touch ( $ this -> root . $ file , filemtime ( $ this -> root . $ file ) , time ( ) ) ; } catch ( \ ErrorException $ e ) { Silencer :: call ( 'touch' , $ this -> root . $ file ) ; } $ this -> io -> writeError ( 'Reading ' . $ this -> root . $ file . ' from cache' , true , IOInterface :: DEBUG ) ; return copy ( $ this -> root . $ file , $ target ) ; } } return false ; }
6388	public function readSite ( ) { $ model = $ this -> readCourse ( 1 ) ; $ model -> url = $ this -> cfg -> wwwroot ; $ model -> type = "site" ; return $ model ; }
636	public function dropTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropTable ( $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
10980	public function preRemove ( LifecycleEventArgs $ args ) : void { if ( ! $ this -> enableIndexing ) { return ; } $ this -> removeEntity ( $ args -> getObject ( ) , $ args -> getObjectManager ( ) ) ; }
2346	public function close ( ) { if ( \ is_resource ( $ this -> resFile ) ) { $ this -> Files -> fclose ( $ this -> resFile ) ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } } $ return = $ this -> Files -> rename ( $ this -> strTmp , $ this -> strFile ) ; $ this -> strTmp = null ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ) { $ this -> objModel = Dbafs :: addResource ( $ this -> strFile ) ; } return $ return ; }
10788	protected function getSearchFacets ( SessionInterface $ session ) { $ facets = $ session -> get ( $ this -> getSessionPrefix ( ) . '_facets' , false ) ; return $ facets ? \ json_decode ( $ facets , true ) : $ this -> getDefaultFacets ( ) ; }
2090	public static function countPublishedBySourceAndParent ( $ strSource , $ intParent , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.source=? AND $t.parent=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ strSource , ( int ) $ intParent ) ) ; }
6191	public function run ( $ controller = null , $ action = null , $ args = [ ] ) { $ this -> router = $ this -> router -> boot ( $ this ) ; if ( is_null ( $ controller ?? null ) and is_null ( $ action ?? null ) ) { $ this -> router -> parseGets ( ) ; $ controller = $ this -> router -> controller ; $ action = $ this -> router -> action ; $ namespace = $ this -> router -> namespace ; } $ loader = new Loader ( $ this -> baseClass ) ; $ Controller = $ loader -> loadController ( $ controller , $ namespace ?? '\\' ) ; $ response = [ ] ; if ( method_exists ( $ Controller , 'start' ) ) { $ response [ ] = [ 'start' , [ ] ] ; } if ( method_exists ( $ Controller , 'init' ) ) { $ response [ ] = [ 'init' , [ ] ] ; } if ( method_exists ( $ Controller , $ action ) or is_callable ( [ $ Controller , $ action ] ) ) { $ response [ ] = [ $ action , $ args ] ; } if ( method_exists ( $ Controller , 'end' ) ) { $ response [ ] = [ 'end' , [ ] ] ; } foreach ( $ response as $ key => $ data ) { $ run = call_user_func_array ( [ $ Controller , $ data [ 0 ] ] , $ data [ 1 ] ) ; if ( $ run instanceof Response ) { if ( isset ( $ this -> debug ) ) { $ this -> debug -> addHeader ( [ 'X-DF-Debug-Controller' => $ controller ] ) ; $ this -> debug -> addHeader ( [ 'X-DF-Debug-Method' => $ action ] ) ; $ run -> headers ( $ this -> debug -> getHeader ( ) ) ; } return $ run -> display ( ) ; } } return true ; }
6690	public function canAccess ( $ permissionKeys , $ fullAccessKey , $ errorMsg , $ defaultUrl , $ redirect = false ) { if ( $ this -> getUser ( ) -> isGuest ) { return $ this -> getUser ( ) -> loginRequired ( ) ; } if ( $ this -> getPermissionManager ( ) -> canAccess ( $ fullAccessKey ) ) { return true ; } if ( ! is_array ( $ permissionKeys ) ) { $ permissionKeys = [ $ permissionKeys ] ; } foreach ( $ permissionKeys as $ permissionKey ) { if ( $ this -> getPermissionManager ( ) -> canAccess ( $ permissionKey ) ) { return true ; } } if ( $ redirect ) { $ this -> flashError ( $ errorMsg ) ; $ request = $ this -> getRequest ( ) ; $ referrerUrl = $ request -> referrer ; $ redirectUrl = ( $ referrerUrl == $ request -> url || is_null ( $ referrerUrl ) ) ? $ defaultUrl : $ referrerUrl ; $ this -> redirect ( $ redirectUrl ) -> send ( ) ; Yii :: $ app -> end ( ) ; } return false ; }
12056	public function getLabels ( ) { $ labels = [ ] ; $ labels [ 'delete_object' ] = [ 'short' => 'Delete ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'delete the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been deleted' , 'options' => [ 'class' => 'btn-danger' ] , 'response' => 'home' , ] ; $ labels [ 'archive_object' ] = [ 'short' => 'Archive ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'archive the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been archived' , 'response' => 'refresh' , ] ; $ labels [ 'unarchive_object' ] = [ 'short' => 'Unarchive ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'unarchive the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been unarchived' , 'response' => 'refresh' , ] ; if ( isset ( $ this -> relationshipWith ) ) { $ labels [ 'delete_relationship' ] = [ 'short' => 'Delete Relationship' , 'long' => 'delete the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em>' , 'past' => 'the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em> has been deleted' , 'options' => [ 'class' => 'btn-warning' ] , ] ; $ labels [ 'end_relationship' ] = [ 'short' => 'End Relationship' , 'long' => 'end the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em>' , 'past' => 'the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em> has been ended' , ] ; } return $ labels ; }
11149	protected function process ( array $ requestParams ) { $ request = new ExtDirectRequest ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; $ response = new ExtDirectResponse ( ) ; $ requestParameters = new Parameters ( ) ; try { $ request -> setApplicationPath ( $ this -> getApplicationPath ( ) ) ; $ requestParameters -> setParameters ( $ requestParams ) ; $ request -> injectParameters ( $ requestParameters ) ; $ response -> injectParameters ( $ requestParameters ) ; $ request -> injectResponse ( $ response ) ; $ request -> setParamMethod ( $ this -> getParamMethod ( ) ) ; $ request -> setMethodCalls ( $ this -> getMethodsToCall ( ) ) ; $ request -> run ( ) ; } catch ( ExtDirectApplicationException $ e ) { $ result = $ e -> getResponse ( ) ; if ( ! empty ( $ result ) ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) , "actions" => $ result ) ) ; } else { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } } catch ( \ Exception $ e ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } return $ response ; }
7411	public function combine ( array $ keys ) : self { if ( count ( $ keys ) !== count ( $ this -> _container ) ) { throw new LengthException ( 'array counts do not match' ) ; } $ this -> _container = array_combine ( $ keys , $ this -> _container ) ; return $ this ; }
1688	public function updateStyleSheet ( $ intId ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intId ) ; if ( $ objStyleSheet -> numRows < 1 ) { return ; } if ( Input :: get ( 'act' ) == 'delete' ) { $ this -> import ( Files :: class , 'Files' ) ; $ this -> Files -> delete ( 'assets/css/' . $ objStyleSheet -> name . '.css' ) ; } else { $ this -> writeStyleSheet ( $ objStyleSheet -> row ( ) ) ; $ this -> log ( 'Generated style sheet "' . $ objStyleSheet -> name . '.css"' , __METHOD__ , TL_CRON ) ; } }
1151	protected function getViewData ( ) { $ this -> validator -> setRemote ( $ this -> remote ) ; $ data = $ this -> validator -> validationData ( ) ; $ data [ 'selector' ] = $ this -> selector ; if ( ! is_null ( $ this -> ignore ) ) { $ data [ 'ignore' ] = $ this -> ignore ; } return $ data ; }
11559	public function SetWeekWords ( $ weekWords , $ lang = '' ) { if ( ! $ lang ) $ lang = $ this -> lang ; if ( is_array ( $ weekWords ) ) { $ this -> weekWords [ $ lang ] = $ weekWords ; } else { $ this -> weekWords [ $ lang ] = explode ( ',' , ( string ) $ weekWords ) ; } return $ this ; }
3338	public static function dateTimeString ( $ datetime ) { if ( $ datetime === null ) { return null ; } if ( is_object ( $ datetime ) && ! ( $ datetime instanceof \ DateTime ) ) { throw new \ Exception ( 'Only \DateTime objects allowed' ) ; } if ( is_string ( $ datetime ) ) { $ datetime = new \ DateTime ( $ datetime ) ; } return $ datetime -> format ( "Y-m-d\TH:i:s.uP" ) ; }
7145	public function add_custom_profile_fields ( $ user ) { $ user_settings = apply_filters ( 'iac_get_user_settings' , array ( ) , $ user -> ID ) ; $ nonce = wp_create_nonce ( 'iac_user_settings' ) ; ?> <h3> <?php _e ( 'Informer?' , $ this -> get_textdomain ( ) ) ; ?> </h3> <table class="form-table"> <tr id="post_subscription"> <th> <label for="post_subscription_checkbox"> <?php _e ( 'Posts subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="post_subscription_checkbox" name="post_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_posts' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new posts via e-mail, without your own posts.' , $ this -> get_textdomain ( ) ) ; ?> </span> </td> </tr> <tr id="comment_subscription"> <th> <label for="comment_subscription_checkbox"> <?php _e ( 'Comments subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="comment_subscription_checkbox" name="comment_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_comments' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new comments via e-mail, without your own comments.' , $ this -> get_textdomain ( ) ) ; ?> </span> <input type="hidden" name="iac_nonce" value=" <?php echo $ nonce ; ?> " /> </td> </tr> </table> <?php }
1049	public static function getVariableValues ( Schema $ schema , $ varDefNodes , array $ inputs ) { $ errors = [ ] ; $ coercedValues = [ ] ; foreach ( $ varDefNodes as $ varDefNode ) { $ varName = $ varDefNode -> variable -> name -> value ; $ varType = TypeInfo :: typeFromAST ( $ schema , $ varDefNode -> type ) ; if ( Type :: isInputType ( $ varType ) ) { if ( array_key_exists ( $ varName , $ inputs ) ) { $ value = $ inputs [ $ varName ] ; $ coerced = Value :: coerceValue ( $ value , $ varType , $ varDefNode ) ; $ coercionErrors = $ coerced [ 'errors' ] ; if ( empty ( $ coercionErrors ) ) { $ coercedValues [ $ varName ] = $ coerced [ 'value' ] ; } else { $ messagePrelude = sprintf ( 'Variable "$%s" got invalid value %s; ' , $ varName , Utils :: printSafeJson ( $ value ) ) ; foreach ( $ coercionErrors as $ error ) { $ errors [ ] = new Error ( $ messagePrelude . $ error -> getMessage ( ) , $ error -> getNodes ( ) , $ error -> getSource ( ) , $ error -> getPositions ( ) , $ error -> getPath ( ) , $ error , $ error -> getExtensions ( ) ) ; } } } else { if ( $ varType instanceof NonNull ) { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" of required type "%s" was not provided.' , $ varName , $ varType ) , [ $ varDefNode ] ) ; } elseif ( $ varDefNode -> defaultValue ) { $ coercedValues [ $ varName ] = AST :: valueFromAST ( $ varDefNode -> defaultValue , $ varType ) ; } } } else { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" expected value of type "%s" which cannot be used as an input type.' , $ varName , Printer :: doPrint ( $ varDefNode -> type ) ) , [ $ varDefNode -> type ] ) ; } } if ( ! empty ( $ errors ) ) { return [ $ errors , null ] ; } return [ null , $ coercedValues ] ; }
7680	function TbsSheetSlide_DeleteDisplay ( $ id_or_name , $ ok , $ delete ) { if ( is_null ( $ ok ) ) $ ok = true ; $ ext = $ this -> ExtEquiv ; $ ok = ( boolean ) $ ok ; if ( ! is_array ( $ id_or_name ) ) $ id_or_name = array ( $ id_or_name ) ; foreach ( $ id_or_name as $ item => $ action ) { if ( ! is_bool ( $ action ) ) { $ item = $ action ; $ action = $ ok ; } $ item_ref = ( is_string ( $ item ) ) ? 'n:' . htmlspecialchars ( $ item ) : 'i:' . $ item ; if ( $ delete ) { if ( $ ok ) { $ this -> OtbsSheetSlidesDelete [ $ item_ref ] = $ item ; } else { unset ( $ this -> OtbsSheetSlidesVisible [ $ item_ref ] ) ; } } else { $ this -> OtbsSheetSlidesVisible [ $ item_ref ] = $ ok ; } } }
11503	private function createDeleteForm ( Comment $ comment ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_comment_delete' , array ( 'id' => $ comment -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
358	function compareByteSize ( $ a , $ b , $ compare = '>=' ) { $ compareExpression = '(' . $ this -> getByteSize ( $ a ) . $ compare . $ this -> getByteSize ( $ b ) . ')' ; return $ this -> evaluateExpression ( $ compareExpression ) ; }
12772	public function register ( $ email , $ hashedPassword = null , & $ user = null , $ valid = false ) { $ result = new EmailStatus ( 0 ) ; if ( ! dbQuery ( $ this -> dbTable ) -> cond ( $ this -> dbEmailField , $ email ) -> first ( $ user ) ) { if ( ! isset ( $ user ) ) { $ user = new $ this -> dbTable ( false ) ; } $ user [ $ this -> dbEmailField ] = $ email ; $ user [ $ this -> dbHashEmailField ] = $ this -> hash ( $ email ) ; if ( isset ( $ hashedPassword ) ) { $ user [ $ this -> dbHashPasswordField ] = $ hashedPassword ; } else { $ user [ $ this -> dbHashPasswordField ] = $ this -> generatePassword ( ) ; } if ( ! $ valid ) { $ user [ $ this -> dbConfirmField ] = $ this -> hash ( $ email . time ( ) ) ; } else { $ user [ $ this -> dbConfirmField ] = 1 ; } $ activeField = $ this -> dbActiveField ; $ createdField = $ this -> dbCreatedField ; $ user -> $ activeField = 1 ; $ user -> $ createdField = date ( 'Y-m-d H:i:s' ) ; $ user -> save ( ) ; $ this -> authorize ( $ user ) ; $ result = new EmailStatus ( EmailStatus :: SUCCESS_EMAIL_REGISTERED ) ; } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_REGISTER_FOUND ) ; } if ( is_callable ( $ this -> registerHandler ) ) { if ( ! call_user_func_array ( $ this -> registerHandler , array ( & $ user , & $ result ) ) ) { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_REGISTER_HANDLER ) ; } } return $ result ; }
9632	public function getSetting ( $ setting ) { $ settings = $ this -> getSettings ( ) ; if ( isset ( $ settings ) && count ( $ settings ) > 0 ) { if ( isset ( $ settings [ $ setting ] ) ) { return $ settings [ $ setting ] ; } } return '' ; }
4309	public function getChannel ( $ channelName , $ config = array ( ) ) { if ( \ strpos ( $ channelName , '.' ) !== false ) { $ this -> error ( 'getChannel(): channelName should not contain period (.)' ) ; return $ this ; } if ( ! isset ( $ this -> channels [ $ channelName ] ) ) { $ cfg = $ this -> getCfg ( ) ; $ cfg = \ array_diff_key ( $ cfg , \ array_flip ( array ( 'errorEmailer' , 'errorHandler' , 'output' , ) ) ) ; unset ( $ cfg [ 'debug' ] [ 'onBootstrap' ] ) ; $ cfg [ 'debug' ] [ 'channel' ] = $ this -> parentInstance ? $ this -> cfg [ 'channel' ] . '.' . $ channelName : $ channelName ; $ cfg [ 'debug' ] [ 'parent' ] = $ this ; $ this -> channels [ $ channelName ] = new static ( $ cfg ) ; if ( $ config ) { $ this -> channels [ $ channelName ] -> setCfg ( $ config ) ; } } return $ this -> channels [ $ channelName ] ; }
334	protected function getTableSequenceName ( $ tableName ) { $ sequenceNameSql = <<<'SQL'SELECT UD.REFERENCED_NAME AS SEQUENCE_NAMEFROM USER_DEPENDENCIES UD JOIN USER_TRIGGERS UT ON (UT.TRIGGER_NAME = UD.NAME)WHERE UT.TABLE_NAME = :tableName AND UD.TYPE = 'TRIGGER' AND UD.REFERENCED_TYPE = 'SEQUENCE'SQL ; $ sequenceName = $ this -> db -> createCommand ( $ sequenceNameSql , [ ':tableName' => $ tableName ] ) -> queryScalar ( ) ; return $ sequenceName === false ? null : $ sequenceName ; }
1225	private function buildQueryParameters ( array $ paramValues ) { if ( empty ( $ paramValues ) ) { return '' ; } $ query = [ ] ; foreach ( $ paramValues as $ param => $ value ) { if ( is_array ( $ value ) ) { $ value = join ( ',' , $ value ) ; } elseif ( is_bool ( $ value ) ) { $ value = $ value ? 'true' : 'false' ; } elseif ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } $ query [ ] = $ param . '=' . urlencode ( $ value ) ; } return '?' . join ( '&' , $ query ) ; }
5909	public function retrieveUser ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/users/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new User ( $ result ) ; return $ result ; }
919	public function getEnd ( ) { $ reachedContent = false ; foreach ( $ this -> doc -> getLines ( ) as $ index => $ line ) { if ( $ reachedContent && ( $ line -> containsATag ( ) || ! $ line -> containsUsefulContent ( ) ) ) { return $ index - 1 ; } if ( $ line -> containsATag ( ) ) { return null ; } if ( $ line -> containsUsefulContent ( ) ) { $ reachedContent = true ; } } }
6045	protected function renderItems ( $ items ) { $ lines = [ ] ; foreach ( $ items as $ i => $ item ) { if ( isset ( $ item [ 'visible' ] ) && ! $ item [ 'visible' ] ) { unset ( $ items [ $ i ] ) ; continue ; } if ( is_string ( $ item ) ) { $ lines [ ] = $ item ; continue ; } $ options = ArrayHelper :: getValue ( $ item , 'options' , [ ] ) ; if ( isset ( $ item [ 'divider' ] ) ) { Html :: addCssClass ( $ options , 'divider' ) ; $ lines [ ] = Html :: tag ( 'li' , '' , $ options ) ; continue ; } if ( ! isset ( $ item [ 'label' ] ) ) { throw new InvalidConfigException ( "The 'label' option is required." ) ; } $ label = $ this -> encodeLabels ? Html :: encode ( $ item [ 'label' ] ) : $ item [ 'label' ] ; $ linkOptions = ArrayHelper :: getValue ( $ item , 'linkOptions' , [ ] ) ; $ linkOptions [ 'tabindex' ] = '-1' ; $ badgeOptions = ArrayHelper :: getValue ( $ item , 'badgeOptions' , [ ] ) ; $ label = Html :: tag ( 'i' , '' , $ linkOptions ) . Html :: tag ( 'span' , $ label ) ; $ label .= $ this -> renderBadge ( $ badgeOptions ) ; $ content = Html :: a ( $ label , ArrayHelper :: getValue ( $ item , 'url' , '#' ) ) ; if ( ! empty ( $ item [ 'items' ] ) ) { $ content .= $ this -> renderItems ( $ item [ 'items' ] ) ; Html :: addCssClass ( $ options , 'dropdown-submenu' ) ; } $ lines [ ] = Html :: tag ( 'li' , $ content , $ options ) ; } return Html :: tag ( 'ul' , implode ( "\n" , $ lines ) , $ this -> options ) ; }
4064	private static function calculateDiff ( $ expected , $ actual , $ strict ) { if ( $ expected === $ actual ) { return ; } if ( gettype ( $ expected ) !== gettype ( $ actual ) ) { if ( ! $ strict && self :: isEmptyArrayEquivalent ( $ expected , $ actual ) ) { return ; } throw new \ LogicException ( sprintf ( 'Encountered type %s expected %s (Found %s, expected %s)' , gettype ( $ actual ) , gettype ( $ expected ) , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: TYPE_MISMATCH ) ; } if ( is_array ( $ expected ) ) { self :: calculateArrayDiff ( $ expected , $ actual , $ strict ) ; } throw new \ LogicException ( sprintf ( 'Found %s expected %s' , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: VALUE_MISMATCH ) ; }
5790	private function setDefaultValue ( $ columnDefault ) { if ( is_null ( $ columnDefault ) ) { $ this -> defaultValue = '' ; } else { switch ( $ this -> type ) { case 'character' : case 'character varying' : case 'text' : case 'USER-DEFINED' : $ parseColumnDefault = explode ( "'" , $ columnDefault ) ; $ this -> defaultValue = $ parseColumnDefault [ 1 ] ; break ; case 'boolean' : if ( $ columnDefault == 'true' ) { $ this -> defaultValue = Postgres :: BOOLEAN_TRUE ; } break ; default : $ this -> defaultValue = $ columnDefault ; } } }
4703	protected function lint ( OutputInterface $ output , Ciconia $ ciconia , $ content ) { try { $ ciconia -> render ( $ content , array ( 'strict' => true ) ) ; $ output -> writeln ( 'No syntax errors detected.' ) ; return 0 ; } catch ( SyntaxError $ e ) { $ output -> writeln ( '<error>' . $ e -> getMessage ( ) . '</error>' ) ; return 1 ; } }
7990	public function getPcaServices ( $ pp ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (passport).' ) ; try { $ r = $ this -> get ( 'cloud/' . $ pp . '/pca' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
7778	protected function extractInput ( array $ data ) { $ input = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ input [ $ field ] = $ fieldData [ 0 ] ; } return $ input ; }
6509	public function createHandlers ( JobInterface $ job , $ level , $ bubble ) { $ handlers = [ ] ; foreach ( $ this -> factories as $ factory ) { $ handlers [ ] = $ factory -> createHandler ( $ job , $ level , $ bubble ) ; } return $ handlers ; }
2459	public function move ( ) { if ( $ this -> intId && Input :: get ( 'sid' ) && ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'root' ] || ! \ in_array ( $ this -> intId , $ this -> root ) ) ) { $ objRow = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=? OR id=?" ) -> limit ( 2 ) -> execute ( $ this -> intId , Input :: get ( 'sid' ) ) ; $ row = $ objRow -> fetchAllAssoc ( ) ; if ( $ row [ 0 ] [ 'pid' ] == $ row [ 1 ] [ 'pid' ] ) { $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET sorting=? WHERE id=?" ) -> execute ( $ row [ 0 ] [ 'sorting' ] , $ row [ 1 ] [ 'id' ] ) ; $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET sorting=? WHERE id=?" ) -> execute ( $ row [ 1 ] [ 'sorting' ] , $ row [ 0 ] [ 'id' ] ) ; $ this -> invalidateCacheTags ( $ this ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
1721	private function getStringRepresentation ( array $ chunks , $ value ) : string { switch ( \ count ( $ chunks ) ) { case 2 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteValue ( $ value ) ) ; case 3 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteValue ( $ value ) ) ; case 4 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteKey ( $ chunks [ 3 ] ) , $ this -> quoteValue ( $ value ) ) ; } throw new \ OutOfBoundsException ( 'Cannot load less than 2 or more than 4 levels in XLIFF language files.' ) ; }
5599	public function tally ( ) { while ( list ( $ severity , $ message , $ file , $ line ) = $ this -> extract ( ) ) { $ severity = $ this -> getSeverityAsString ( $ severity ) ; $ this -> test -> error ( $ severity , $ message , $ file , $ line ) ; } while ( list ( $ expected , $ message ) = $ this -> extractExpectation ( ) ) { $ this -> test -> assert ( $ expected , false , '%s -> Expected error not caught' ) ; } }
2139	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } $ this -> fetchHttpHeaders ( ) ; $ this -> setResponseHeaders ( $ event -> getResponse ( ) ) ; }
9384	public function getIcons ( ) { $ icons = [ ] ; foreach ( $ this -> getGroupedIcons ( ) as $ name => $ group ) { foreach ( $ group as $ id => $ icon ) { if ( ! isset ( $ icons [ $ id ] ) ) { $ icons [ $ id ] = isset ( $ icon [ 'name' ] ) ? $ icon [ 'name' ] : $ id ; } } } ksort ( $ icons ) ; return $ icons ; }
2822	protected function _afterLoad ( ) { $ info = $ this -> getUnserializedInfo ( ) ; $ this -> logging = $ info [ 'logging' ] ; $ this -> action = $ info [ 'action' ] ; $ this -> design = $ info [ 'design' ] ; $ this -> blocks = $ info [ 'blocks' ] ; $ this -> models = $ info [ 'models' ] ; $ this -> collections = $ info [ 'collections' ] ; $ this -> queries = $ info [ 'queries' ] ; $ this -> timers = $ info [ 'timers' ] ; $ this -> emails = $ info [ 'emails' ] ; return parent :: _afterLoad ( ) ; }
1748	protected function listSingleRecord ( $ id ) { if ( ! \ strlen ( $ this -> list_info_layout ) ) { $ this -> list_info_layout = 'info_default' ; } $ this -> Template = new FrontendTemplate ( $ this -> list_info_layout ) ; $ this -> Template -> record = array ( ) ; $ this -> Template -> referer = 'javascript:history.go(-1)' ; $ this -> Template -> back = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goBack' ] ; $ this -> list_info = StringUtil :: deserialize ( $ this -> list_info ) ; $ this -> list_info_where = $ this -> replaceInsertTags ( $ this -> list_info_where , false ) ; $ objRecord = $ this -> Database -> prepare ( "SELECT " . implode ( ', ' , array_map ( 'Database::quoteIdentifier' , trimsplit ( ',' , $ this -> list_info ) ) ) . " FROM " . $ this -> list_table . " WHERE " . ( ( $ this -> list_info_where != '' ) ? "(" . $ this -> list_info_where . ") AND " : "" ) . Database :: quoteIdentifier ( $ this -> strPk ) . "=?" ) -> limit ( 1 ) -> execute ( $ id ) ; if ( $ objRecord -> numRows < 1 ) { return ; } $ arrFields = array ( ) ; $ arrRow = $ objRecord -> row ( ) ; $ limit = \ count ( $ arrRow ) ; $ count = - 1 ; foreach ( $ arrRow as $ k => $ v ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'password' ) { -- $ limit ; continue ; } $ class = 'row_' . ++ $ count . ( ( $ count == 0 ) ? ' row_first' : '' ) . ( ( $ count >= ( $ limit - 1 ) ) ? ' row_last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' even' : ' odd' ) ; $ arrFields [ $ k ] = array ( 'raw' => $ v , 'label' => ( \ strlen ( $ label = $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ) ? $ label : $ k ) , 'content' => $ this -> formatValue ( $ k , $ v , true ) , 'class' => $ class ) ; } $ this -> Template -> record = $ arrFields ; }
8276	public function triggerEvent ( $ eventName , array $ params = array ( ) ) { foreach ( $ this -> modules as $ module ) { $ module -> handleEvent ( $ eventName , $ params ) ; } }
2005	protected function validateForm ( Widget $ objWidget = null ) { $ varInput = Idna :: encodeEmail ( Input :: post ( 'email' , true ) ) ; if ( ! Validator :: isEmail ( $ varInput ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'email' ] ; return false ; } $ this -> Template -> email = $ varInput ; $ arrChannels = Input :: post ( 'channels' ) ; if ( ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ arrChannels = array_intersect ( $ arrChannels , $ this -> nl_channels ) ; if ( empty ( $ arrChannels ) || ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ this -> Template -> selectedChannels = $ arrChannels ; $ arrSubscriptions = array ( ) ; if ( ( $ objSubscription = NewsletterRecipientsModel :: findBy ( array ( "email=? AND active='1'" ) , $ varInput ) ) !== null ) { $ arrSubscriptions = $ objSubscription -> fetchEach ( 'pid' ) ; } $ arrChannels = array_intersect ( $ arrChannels , $ arrSubscriptions ) ; if ( empty ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unsubscribed' ] ; return false ; } if ( $ objWidget !== null ) { $ objWidget -> validate ( ) ; if ( $ objWidget -> hasErrors ( ) ) { return false ; } } return array ( $ varInput , $ arrChannels ) ; }
2407	public static function generateScriptTag ( $ src , $ async = false , $ mtime = false , $ hash = null , $ crossorigin = null ) { if ( $ mtime === null && ! preg_match ( '@^https?://@' , $ src ) ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ src ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ src ) ; } else { $ webDir = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.web_dir' ) ) ; if ( file_exists ( $ rootDir . '/' . $ webDir . '/' . $ src ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ webDir . '/' . $ src ) ; } } } if ( $ mtime ) { $ src .= '?v=' . substr ( md5 ( $ mtime ) , 0 , 8 ) ; } return '<script src="' . $ src . '"' . ( $ async ? ' async' : '' ) . ( $ hash ? ' integrity="' . $ hash . '"' : '' ) . ( $ crossorigin ? ' crossorigin="' . $ crossorigin . '"' : '' ) . '></script>' ; }
3088	public function isAssessmentSectionAdaptive ( AssessmentSection $ section ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; return count ( $ assessmentItemRefs ) === 1 && $ this -> isAdaptivePlaceholder ( $ assessmentItemRefs [ 0 ] ) ; }
9264	protected function createController ( $ controller ) { $ parts = explode ( ':' , $ controller ) ; if ( count ( $ parts ) === 2 ) { $ service = $ this -> container -> get ( $ parts [ 0 ] ) ; return array ( $ service , $ parts [ 1 ] ) ; } $ controller = parent :: createController ( $ controller ) ; if ( $ controller [ 0 ] instanceof ContainerAwareInterface ) { $ controller [ 0 ] -> setContainer ( $ this -> container ) ; } return $ controller ; }
11088	public static function getUserBrowser ( ) { $ user_agent = $ _SERVER [ 'HTTP_USER_AGENT' ] ; $ user_browser = 'unknown' ; if ( false !== stripos ( $ user_agent , 'MSIE' ) && false === stripos ( $ user_agent , 'Opera' ) ) { $ user_browser = 'Internet Explorer' ; } elseif ( false !== stripos ( $ user_agent , 'Firefox' ) ) { $ user_browser = 'Mozilla Firefox' ; } elseif ( false !== stripos ( $ user_agent , 'Chrome' ) ) { $ user_browser = 'Google Chrome' ; } elseif ( false !== stripos ( $ user_agent , 'Safari' ) ) { $ user_browser = 'Apple Safari' ; } elseif ( false !== stripos ( $ user_agent , 'Opera' ) ) { $ user_browser = 'Opera' ; } elseif ( false !== stripos ( $ user_agent , 'Netscape' ) ) { $ user_browser = 'Netscape' ; } return $ user_browser ; }
8494	public function createFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_CreateFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_CreateFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_CreateFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10698	public static function isPasswd ( $ passwd , $ size = Validate :: PASSWORD_LENGTH ) { return self :: getPasswordComplexity ( $ passwd , $ size ) >= self :: PASSWORD_COMPLEXITY_MEDIUM ; }
9924	public function filter ( Parameters $ params , array $ permitted = array ( ) ) { $ this -> cleanUnwanted ( $ params , $ permitted ) ; $ this -> handleArrays ( $ params , $ permitted ) ; $ this -> handleCollections ( $ params , $ permitted ) ; }
1140	protected function computeLevel ( ) { list ( $ node , $ nesting ) = $ this -> determineDepth ( $ this ) ; if ( $ node -> equals ( $ this ) ) return $ this -> ancestors ( ) -> count ( ) ; return $ node -> getLevel ( ) + $ nesting ; }
8375	public function where ( $ where ) { $ this -> where = ( $ where instanceof Condition ? $ where : new Condition ( $ where ) ) ; return $ this ; }
8408	public static function set ( $ name , $ value , $ expire = 0 , $ path = null ) { if ( $ path === null ) { setcookie ( $ name , $ value , $ expire ) ; } else { setcookie ( $ name , $ value , $ expire , $ path ) ; } }
10827	public static function words ( array $ words , $ style = '' , $ separator = ', ' ) { self :: write ( implode ( $ separator , $ words ) , $ style ) ; }
10632	private function getFiles ( $ pattern ) { $ files = $ this -> filesystem -> glob ( $ this -> storagePath . DIRECTORY_SEPARATOR . $ pattern , GLOB_BRACE ) ; return array_filter ( array_map ( 'realpath' , $ files ) ) ; }
8823	public function rule ( $ field , $ label , $ rules , array $ text = [ ] ) { $ this -> labels [ $ field ] = $ label ; $ this -> rules [ $ field ] = $ rules ; $ this -> texts [ $ field ] = ( ! empty ( $ text ) ? $ text : null ) ; }
7506	function setDoc ( $ doc , $ pos = 0 ) { $ this -> doc = $ doc ; $ this -> size = strlen ( $ doc ) ; $ this -> setPos ( $ pos ) ; }
3622	public function enableHumidifier ( $ enabled , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'target_humidity_enabled' => ( ( boolean ) $ enabled ) ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
4425	protected function generateLegacyAutoloads ( ) { $ this -> output -> writeln ( '' ) ; $ this -> output -> write ( 'Generating legacy autoloads... ' ) ; $ currentWorkingDirectory = getcwd ( ) ; try { chdir ( $ this -> getContainer ( ) -> getParameter ( 'ezpublish_legacy.root_dir' ) ) ; $ processBuilder = new ProcessBuilder ( array ( 'php' , 'bin/php/ezpgenerateautoloads.php' , '--quiet' , ) ) ; $ process = $ processBuilder -> getProcess ( ) ; $ process -> setTimeout ( 3600 ) ; $ process -> run ( function ( $ type , $ buffer ) { echo $ buffer ; } ) ; chdir ( $ currentWorkingDirectory ) ; if ( ! $ process -> isSuccessful ( ) ) { return array ( '- Run the following command from your ezpublish_legacy root to generate legacy autoloads:' , '' , ' <comment>php bin/php/ezpgenerateautoloads.php</comment>' , '' , ) ; } } catch ( Exception $ e ) { chdir ( $ currentWorkingDirectory ) ; return array ( 'There was an error generating legacy autoloads: ' . $ e -> getMessage ( ) , '' , ) ; } }
11542	public function confirmEmail ( $ token ) { $ user = $ this -> getMapper ( ) -> findOneBy ( [ 'registrationToken' => $ token ] ) ; if ( ! $ user instanceof UserInterface ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setRegistrationToken ( $ this -> getRegistrationToken ( ) ) ; $ user -> setEmailConfirmed ( true ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
247	public function init ( ) { parent :: init ( ) ; register_shutdown_function ( [ $ this , 'close' ] ) ; if ( $ this -> getIsActive ( ) ) { Yii :: warning ( 'Session is already started' , __METHOD__ ) ; $ this -> updateFlashCounters ( ) ; } }
3171	public function getMap ( RunnerServiceContext $ context , RunnerConfig $ config ) { return $ this -> getScopedMap ( $ context , $ config , RunnerMap :: SCOPE_TEST ) ; }
8032	public function validateDatesArray ( $ attribute , $ value , array $ parameters , Validator $ validator ) { foreach ( $ value as $ date ) { if ( false === strtotime ( $ date ) || empty ( $ date ) ) { return false ; } } return true ; }
11945	protected function handleEventMessage ( array $ message ) { Log :: debug ( 'OpenPlatform Event Message detail:' , $ message ) ; $ message = new Collection ( $ message ) ; $ infoType = $ message -> get ( 'InfoType' ) ; if ( $ handler = $ this -> getHandler ( $ infoType ) ) { $ handler -> handle ( $ message ) ; } else { Log :: notice ( "No existing handler for '{$infoType}'." ) ; } if ( $ messageHandler = $ this -> getMessageHandler ( ) ) { call_user_func_array ( $ messageHandler , [ $ message ] ) ; } }
3620	public function setFanEveryDaySchedule ( $ start_hour , $ end_hour , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'fan_duty_start_time' => $ start_hour * 3600 , 'fan_duty_end_time' => $ end_hour * 3600 ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
2793	public function getCacheDirectory ( ) { if ( ! is_null ( $ this -> cacheDirectory ) ) { return $ this -> cacheDirectory ; } if ( defined ( 'PHP_WINDOWS_VERSION_MAJOR' ) ) { if ( ! getenv ( 'APPDATA' ) ) { throw new RuntimeException ( 'The APPDATA environment variable must be set for humbug.' ) ; } $ home = strtr ( getenv ( 'APPDATA' ) , '\\' , '/' ) . '/Humbug' ; } else { if ( ! getenv ( 'HOME' ) ) { throw new RuntimeException ( 'The HOME environment variable must be set for humbug.' ) ; } $ home = rtrim ( getenv ( 'HOME' ) , '/' ) . '/.humbug' ; } $ cache = $ home . '/cache' ; foreach ( [ $ home , $ cache ] as $ dir ) { if ( ! is_dir ( $ dir ) ) { mkdir ( $ dir , 0777 ) ; } } file_put_contents ( $ home . '/.htaccess' , 'Deny from all' ) ; $ this -> cacheDirectory = $ cache ; return $ cache ; }
3324	public function advance ( ) { if ( $ this -> index >= $ this -> length ) { throw new LogicException ( "Argument index out of bounds." ) ; } return $ this -> argv [ $ this -> index ++ ] ; }
4047	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'jumpTo' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; if ( $ metaModel -> isTranslated ( ) ) { $ arrLanguages = [ ] ; foreach ( ( array ) $ metaModel -> getAvailableLanguages ( ) as $ strLangCode ) { $ arrLanguages [ $ strLangCode ] = $ this -> translator -> trans ( 'LNG.' . $ strLangCode , [ ] , 'contao_languages' ) ; } asort ( $ arrLanguages ) ; $ extra [ 'minCount' ] = count ( $ arrLanguages ) ; $ extra [ 'maxCount' ] = count ( $ arrLanguages ) ; $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] = $ arrLanguages ; } else { $ extra [ 'minCount' ] = 1 ; $ extra [ 'maxCount' ] = 1 ; $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] = [ 'xx' => $ this -> translator -> trans ( 'tl_metamodel_rendersettings.jumpTo_allLanguages' , [ ] , 'contao_tl_metamodel_rendersettings' ) ] ; } $ extra [ 'columnFields' ] [ 'filter' ] [ 'options' ] = $ this -> getFilterSettings ( $ model ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; }
8410	public function connect ( ) { if ( $ this -> isConnected ( ) === false ) { try { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'all' ] ) ; $ this -> servers [ 'all' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'all' ] [ 'user' ] , $ this -> servers [ 'all' ] [ 'pass' ] ) ; } else { $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'read' ] ) ; $ this -> servers [ 'read' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'read' ] [ 'user' ] , $ this -> servers [ 'read' ] [ 'pass' ] ) ; $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'write' ] ) ; $ this -> servers [ 'write' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'write' ] [ 'user' ] , $ this -> servers [ 'write' ] [ 'pass' ] ) ; } } catch ( \ PDOException $ e ) { throw new ExternalLink ( 'can\'t connect to database (' . $ e -> getMessage ( ) . ')' ) ; } } }
10613	protected function authenticateUser ( UserInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> container -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
12310	private function findFile ( $ uriPath ) { return array_reduce ( $ this -> paths , function ( $ file , $ path ) use ( $ uriPath ) { if ( false !== $ file ) { return $ file ; } $ file = $ path . $ uriPath ; if ( is_file ( $ file ) && is_readable ( $ file ) ) { return $ file ; } return false ; } , false ) ; }
6660	protected function getControllers ( ) { if ( ! $ this -> controllersCache ) { $ isHidden = $ this -> getControllerMethod ( 'isMethodHidden' ) ; $ methods = $ this -> reflectedController -> getMethods ( \ ReflectionMethod :: IS_PUBLIC ) ; $ controllers = [ ] ; foreach ( $ methods as $ method ) { if ( preg_match ( '/(\w+)Controller$/' , $ method -> getName ( ) , $ parts ) ) { if ( ! $ isHidden ( $ method -> getName ( ) ) ) { $ controllers [ ] = $ this -> camelcaseToHyphenated ( $ parts [ 1 ] ) ; } } } $ this -> controllersCache = $ controllers ; } return $ this -> controllersCache ; }
7397	public function header ( string $ name , string $ value ) : bool { if ( ! empty ( $ name ) && ! empty ( $ value ) && ! headers_sent ( ) ) { header ( $ name . ': ' . $ value ) ; return true ; } return false ; }
7399	public function redirect ( string $ url = '' , int $ statusCode = 302 ) { $ this -> is404 = false ; $ server = filter_input_array ( INPUT_SERVER ) ; if ( '' == $ url && isset ( $ server [ 'REQUEST_URI' ] ) ) { $ url = '/' . trim ( $ server [ 'REQUEST_URI' ] , '/' ) ; preg_match ( '/^[\\a-zA-Z0-9-\._~:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=%]*$/iD' , $ url , $ match ) ; $ url = $ match [ 1 ] ?? '' ; } if ( ! headers_sent ( ) ) { header ( 'Location: ' . $ url , true , $ statusCode ) ; } echo sprintf ( '<!DOCTYPE html><html> <head> <meta charset="UTF-8" /> <meta http-equiv="refresh" content="0;url=%1$s" /> <title>Redirecting to %1$s</title> </head> <body> <script type="text/javascript"> window.location.href = "%1$s"; </script> Redirecting to <a href="%1$s">%1$s</a>. </body></html>' , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' ) ) ; }
12471	protected function setDatabaseFactoryNamespaces ( ) { $ this -> replaceIn ( $ this -> laravel -> databasePath ( ) . '/factories/ModelFactory.php' , $ this -> currentRoot , $ this -> argument ( 'name' ) ) ; }
1215	public static function isEqual ( $ a , $ b ) { if ( $ a === $ b ) { return true ; } elseif ( $ a instanceof \ stdClass ) { return self :: isEqual ( ( array ) $ a , $ b ) ; } elseif ( $ b instanceof \ stdClass ) { return self :: isEqual ( $ a , ( array ) $ b ) ; } elseif ( $ a instanceof JmesPathableArrayInterface ) { return Utils :: isEqual ( iterator_to_array ( $ a ) , $ b ) ; } elseif ( $ b instanceof JmesPathableArrayInterface ) { return Utils :: isEqual ( $ a , iterator_to_array ( $ b ) ) ; } elseif ( $ a instanceof JmesPathableObjectInterface ) { return Utils :: isEqual ( $ a -> toArray ( ) , $ b ) ; } elseif ( $ b instanceof JmesPathableObjectInterface ) { return Utils :: isEqual ( $ a , $ b -> toArray ( ) ) ; } else { return false ; } }
12078	public function childAssociate ( $ request , $ idParent , $ idChild , $ relation ) { $ request -> request -> merge ( [ 'url' => $ request -> request -> path ( ) ] ) ; $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resourceChild = $ this -> repository -> attach ( $ idParent , $ idChild , $ relation , $ request -> all ( ) ) ; if ( ! $ resourceChild ) { } return $ this -> success ( [ $ resourceChild ] ) ; }
2723	public function execute ( Observer $ observer ) { if ( $ this -> fastlyConfig -> isFastlyEnabled ( ) != true ) { return ; } $ event = $ observer -> getEvent ( ) ; $ name = $ event -> getElementName ( ) ; $ layout = $ event -> getLayout ( ) ; $ block = $ layout -> getBlock ( $ name ) ; if ( $ block instanceof AbstractBlock ) { $ blockTtl = $ block -> getTtl ( ) ; if ( isset ( $ blockTtl ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } } }
4560	public function translate ( Translatable $ model ) { $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ get = 'get' . $ property -> getName ( ) ; $ set = 'set' . $ property -> getName ( ) ; $ values = [ ] ; foreach ( $ model -> getTranslations ( ) as $ translation ) { $ values [ $ translation -> getLocale ( ) ] = $ translation -> $ get ( ) ; } $ model -> $ set ( $ values ) ; } }
6357	public function getTimestamp ( $ style = TS_UNIX ) { if ( ! isset ( self :: $ formats [ $ style ] ) ) { throw new TimestampException ( __METHOD__ . ': Illegal timestamp output type.' ) ; } $ output = $ this -> timestamp -> format ( self :: $ formats [ $ style ] ) ; if ( $ style == TS_RFC2822 ) { $ output .= ' GMT' ; } if ( $ style == TS_MW && strlen ( $ output ) !== 14 ) { throw new TimestampException ( __METHOD__ . ': The timestamp cannot be represented in ' . 'the specified format' ) ; } return $ output ; }
24	public function copy ( $ originUrl , $ fileUrl , $ fileName , $ progress = true , $ options = array ( ) ) { return $ this -> get ( $ originUrl , $ fileUrl , $ options , $ fileName , $ progress ) ; }
8842	private function stringToArray ( string $ string ) : array { $ lines = preg_split ( '/\R/' , $ string ) ; if ( 1 === count ( $ lines ) && '' === $ lines [ 0 ] ) { $ lines = [ ] ; } return $ lines ; }
3169	protected function getItemHrefIndexFile ( QtiRunnerServiceContext $ context , $ itemIdentifier ) { $ compilationDirectory = $ context -> getCompilationDirectory ( ) [ 'private' ] ; return $ compilationDirectory -> getFile ( \ taoQtiTest_models_classes_QtiTestCompiler :: buildHrefIndexPath ( $ itemIdentifier ) ) ; }
7905	public function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , Html :: tag ( 'i' , '' , [ 'class' => 'content icon' ] ) ) ; Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'launch-sidebar icon' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; Html :: addCssClass ( $ this -> toggleButton , 'fixed' ) ; Html :: addCssClass ( $ this -> toggleButton , 'attached' ) ; if ( $ this -> position === static :: POS_LEFT ) { $ position = static :: POS_RIGHT ; } else { $ position = static :: POS_LEFT ; } Html :: addCssClass ( $ this -> toggleButton , $ position ) ; $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
4887	public function createAttachedEntity ( $ entityClass , $ values = [ ] , $ key = null ) { if ( is_string ( $ values ) ) { $ key = $ values ; $ values = [ ] ; } $ entity = $ this -> repositories -> getRepository ( $ entityClass ) -> create ( $ values ) ; $ this -> addAttachedEntity ( $ entity , $ key ) ; return $ entity ; }
2598	public function moveNext ( ) { $ this -> peek = 0 ; $ this -> token = $ this -> lookahead ; $ this -> lookahead = ( isset ( $ this -> tokens [ $ this -> position ] ) ) ? $ this -> tokens [ $ this -> position ++ ] : null ; return $ this -> lookahead !== null ; }
1762	public static function convertXlfToPhp ( $ strName , $ strLanguage , $ blnLoad = false ) { @ trigger_error ( 'Using System::convertXlfToPhp() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\XliffFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new XliffFileLoader ( static :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) , $ blnLoad ) ; return $ loader -> load ( $ strName , $ strLanguage ) ; }
7148	public function getTotal ( $ discounted = true ) { $ base = $ this -> base ; if ( $ discounted && $ this -> hasDiscounts ( ) ) { foreach ( $ this -> discounts as $ discount ) { $ base -= $ this -> calculateAdjustment ( $ discount , $ base ) ; } } $ total = $ base ; if ( ! empty ( $ this -> taxes ) && $ this -> mode === VatDisplayModes :: MODE_ATI ) { foreach ( $ this -> taxes as $ tax ) { $ total += $ this -> calculateAdjustment ( $ tax , $ base ) ; } } return $ total ; }
10785	public function runQuery ( \ Peyote \ Query $ query ) { return $ this -> run ( $ query -> compile ( ) , $ query -> getParams ( ) ) ; }
9200	public function uploadMedia ( $ filepaths , $ client = null ) { $ maxMediaIds = Config :: get ( 'max_media_ids' ) ; if ( count ( $ filepaths ) > $ maxMediaIds ) { throw new MediaUploadLimitException ( "You cannot upload more than ${maxMediaIds} media files in a tweet!" ) ; } $ mediaIds = array ( ) ; if ( is_null ( $ client ) ) { $ client = $ this -> createGuzzleClient ( Config :: get ( 'base_upload_url' ) ) ; } $ endpoint = $ this -> prependVersionToEndpoint ( "media/upload.json" , Config :: get ( 'api_version' ) ) ; foreach ( $ filepaths as $ filepath ) { $ options = $ this -> constructRequestOptions ( array ( ) , $ client ) ; $ options [ 'body' ] = array ( 'media' => new PostFile ( 'media' , fopen ( $ filepath , 'r' ) ) ) ; $ response = $ client -> post ( $ endpoint , $ options ) ; array_push ( $ mediaIds , $ response -> json ( ) [ 'media_id_string' ] ) ; } return ( implode ( "," , $ mediaIds ) ) ; }
12545	public function listen ( $ event , callable $ callback , $ priority = 100 ) { $ this -> event -> on ( $ event , $ callback , $ priority ) ; }
9225	private function preprocessData ( $ data ) { if ( is_array ( $ data ) && ! array_key_exists ( self :: PARAM_PER_PAGE , $ data ) ) { $ data [ self :: PARAM_PER_PAGE ] = CanvasArray :: MAXIMUM_PER_PAGE ; } return $ data ; }
10619	public function send ( ) { $ input = Input :: only ( array ( 'name' , 'email' , 'comment' , 'to_email' , 'to_name' , 'security-code' ) ) ; $ input [ 'security-code' ] = $ this -> quickSanitize ( $ input [ 'security-code' ] ) ; if ( strlen ( $ input [ 'security-code' ] ) < 2 ) { $ message = "Please enter the security code again. Thank you!" ; return view ( 'lasallecmscontact::step_two_form' , [ 'input' => $ input , 'message' => $ message , ] ) ; } $ input [ 'name' ] = $ this -> quickSanitize ( $ input [ 'name' ] ) ; $ input [ 'email' ] = $ this -> quickSanitize ( $ input [ 'email' ] ) ; $ input [ 'comment' ] = $ this -> quickSanitize ( $ input [ 'comment' ] ) ; $ to_email = Config :: get ( 'lasallecmscontact.to_email' ) ; $ to_name = Config :: get ( 'lasallecmscontact.to_name' ) ; if ( $ input [ 'to_email' ] != "" ) { $ to_email = $ input [ 'to_email' ] ; $ to_name = $ input [ 'to_name' ] ; } Mail :: send ( 'lasallecmscontact::email' , $ input , function ( $ message ) use ( $ to_email , $ to_name ) { $ message -> from ( Config :: get ( 'lasallecmscontact.from_email' ) , Config :: get ( 'lasallecmscontact.from_name' ) ) ; $ message -> to ( $ to_email , $ to_name ) -> subject ( Config :: get ( 'lasallecmscontact.subject_email' ) ) ; } ) ; return Redirect :: route ( 'contact-processing.thankyou' ) ; }
8989	public function getTemplate ( $ data_type , $ type ) { $ options = ( array ) $ this -> config -> getType ( $ data_type , $ type ) ; return new UI \ Template ( $ data_type , $ type , $ options ) ; }
12886	public function setRawPhoto ( $ photo ) { if ( empty ( $ photo ) ) { return true ; } if ( ! ( $ photo instanceof FileInterface ) ) { $ photo = RawFile :: createRawInstance ( $ photo ) ; } return $ this -> setStorage ( $ photo ) ; }
7463	private static function renderTemplate ( string $ __file__ , array $ data ) : string { ob_start ( ) ; extract ( $ data ) ; include $ __file__ ; return ob_get_clean ( ) ; }
10961	protected function restoreResponse ( $ response , $ data ) { if ( isset ( $ data [ 'format' ] ) ) { $ response -> format = $ data [ 'format' ] ; } if ( isset ( $ data [ 'version' ] ) ) { $ response -> version = $ data [ 'version' ] ; } if ( isset ( $ data [ 'statusCode' ] ) ) { $ response -> statusCode = $ data [ 'statusCode' ] ; } if ( isset ( $ data [ 'statusText' ] ) ) { $ response -> statusText = $ data [ 'statusText' ] ; } if ( isset ( $ data [ 'headers' ] ) && is_array ( $ data [ 'headers' ] ) ) { $ headers = $ response -> getHeaders ( ) -> toArray ( ) ; $ response -> getHeaders ( ) -> fromArray ( array_merge ( $ data [ 'headers' ] , $ headers ) ) ; } if ( isset ( $ data [ 'cookies' ] ) && is_array ( $ data [ 'cookies' ] ) ) { $ cookies = $ response -> getCookies ( ) -> toArray ( ) ; $ response -> getCookies ( ) -> fromArray ( array_merge ( $ data [ 'cookies' ] , $ cookies ) ) ; } }
12324	protected function doExecute ( InputInterface $ input , OutputInterface $ output ) { if ( $ this -> askQuestions ( $ input , $ output ) == static :: RETURN_ERROR ) { return static :: RETURN_ERROR ; } $ data = $ this -> prepareData ( $ input ) ; $ this -> doPreExecuteTasks ( $ input , $ output , $ data ) ; $ return = $ this -> executeTasks ( $ input , $ output , $ data ) ; $ this -> doPostExecuteTasks ( $ input , $ output , $ data , $ return ) ; return $ return ; }
9661	public static function createReaderForFile ( $ filename ) { File :: assertFile ( $ filename ) ; $ guessedReader = self :: getReaderTypeFromExtension ( $ filename ) ; if ( $ guessedReader !== null ) { $ reader = self :: createReader ( $ guessedReader ) ; if ( isset ( $ reader ) && $ reader -> canRead ( $ filename ) ) { return $ reader ; } } foreach ( self :: $ readers as $ type => $ class ) { if ( $ type !== $ guessedReader ) { $ reader = self :: createReader ( $ type ) ; if ( $ reader -> canRead ( $ filename ) ) { return $ reader ; } } } throw new Reader \ Exception ( 'Unable to identify a reader for this file' ) ; }
9957	public function protectCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 , $ password , $ alreadyHashed = false ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> protectCells ( $ cellRange , $ password , $ alreadyHashed ) ; }
11659	public static function removeEntriesFromFile ( $ file , $ entries ) { $ properties = self :: readFromFile ( $ file ) ; if ( is_string ( $ entries ) ) { unset ( $ properties [ $ entries ] ) ; } else { foreach ( $ entries as $ i => $ key ) { unset ( $ properties [ $ key ] ) ; } } self :: saveToFile ( $ file , $ properties ) ; }
8181	public function getDefaultStrategy ( $ name ) { if ( ! is_string ( $ this -> defaultStrategy ) && false !== $ this -> defaultStrategy ) { return call_user_func ( $ this -> defaultStrategy , $ name ) ; } return $ this -> defaultStrategy ; }
11484	protected function getFunctionArguments ( ReflectionFunctionAbstract $ func , array $ params = array ( ) ) { $ args = [ ] ; foreach ( $ func -> getParameters ( ) as $ param ) { $ class = $ param -> getClass ( ) ; if ( $ class ) { $ args [ ] = $ this -> resolveClassArg ( $ class , $ param , $ params ) ; } else { $ args [ ] = $ this -> resolveNonClassArg ( $ param , $ params , $ func ) ; } } return $ args ; }
2249	public static function redirect ( $ strLocation , $ intStatus = 303 ) { $ strLocation = str_replace ( '&amp;' , '&' , $ strLocation ) ; $ strLocation = static :: replaceOldBePaths ( $ strLocation ) ; if ( ! preg_match ( '@^https?://@i' , $ strLocation ) ) { $ strLocation = Environment :: get ( 'base' ) . ltrim ( $ strLocation , '/' ) ; } if ( Environment :: get ( 'isAjaxRequest' ) ) { throw new AjaxRedirectResponseException ( $ strLocation ) ; } throw new RedirectResponseException ( $ strLocation , $ intStatus ) ; }
9319	public function markdown ( $ contents ) { $ contents = app ( 'markdown' ) -> convertToHtml ( $ contents ) ; if ( ! is_null ( $ this -> cachePath ) ) { $ this -> files -> put ( $ this -> getCompiledPath ( $ this -> getPath ( ) ) , $ contents ) ; } return $ contents ; }
12621	public function set ( $ key , $ value ) { ArrayDot :: set ( $ _SESSION [ $ this -> root ] , $ key , $ value ) ; }
5023	public function allowSelectMultipleItems ( ) { $ flagOrCallback = $ this -> allowSelectMultipleItems ; return is_callable ( $ flagOrCallback ) ? ( bool ) $ flagOrCallback ( ) : ( bool ) $ flagOrCallback ; }
10770	protected function resolveViewName ( ) { $ viewName = Yii :: $ app -> request -> get ( $ this -> viewParam , $ this -> defaultView ) ; if ( ! is_string ( $ viewName ) || ! preg_match ( '~^\w(?:(?!\/\.{0,2}\/)[\w\/\-\.])*$~' , $ viewName ) ) { if ( YII_DEBUG ) { throw new NotFoundHttpException ( "The requested view \"$viewName\" must start with a word character, must not contain /../ or /./, can contain only word characters, forward slashes, dots and dashes." ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return empty ( $ this -> viewPrefix ) ? $ viewName : $ this -> viewPrefix . '/' . $ viewName ; }
567	private function parseDateValueFormat ( $ value , $ format ) { if ( is_array ( $ value ) ) { return false ; } if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { if ( extension_loaded ( 'intl' ) ) { return $ this -> parseDateValueIntl ( $ value , $ format ) ; } $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } return $ this -> parseDateValuePHP ( $ value , $ format ) ; }
11909	public function getRequiredParams ( ) { $ requiredParams = [ ] ; foreach ( $ this -> parameters as $ parameter ) { if ( $ parameter -> getIsOptional ( ) || $ parameter -> hasDefault ( ) ) { continue ; } $ requiredParams [ ] = $ parameter ; } return $ requiredParams ; }
2462	public function generateMarkup ( ) { $ intMaxSize = round ( static :: getMaxUploadSize ( ) / 1024 / 1024 ) ; $ strAccepted = implode ( ',' , array_map ( function ( $ a ) { return '.' . $ a ; } , StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'uploadTypes' ) ) ) ) ) ; $ GLOBALS [ 'TL_CSS' ] [ ] = 'assets/dropzone/css/dropzone.min.css' ; $ GLOBALS [ 'TL_JAVASCRIPT' ] [ ] = 'assets/dropzone/js/dropzone.min.js' ; $ return = ' <input type="hidden" name="action" value="fileupload"> <div class="fallback"> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple> </div> <div class="dropzone"> <div class="dz-default dz-message"> <span>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzone' ] . '</span> </div> <span class="dropzone-previews"></span> </div> <script> Dropzone.autoDiscover = false; window.addEvent("domready", function() { new Dropzone("#tl_files", { paramName: "' . $ this -> strName . '", maxFilesize: ' . $ intMaxSize . ', acceptedFiles: "' . $ strAccepted . '", timeout: 0, previewsContainer: ".dropzone-previews", clickable: ".dropzone", dictFileTooBig: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneFileTooBig' ] ) . ', dictInvalidFileType: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneInvalidType' ] ) . ' }).on("addedfile", function() { $$(".dz-message").setStyle("display", "none"); }).on("success", function(file, message) { if (!message) return; var container = $("tl_message"); if (!container) { container = new Element("div", { "id": "tl_message", "class": "tl_message" }).inject($("tl_buttons"), "before"); } container.appendHTML(message); }); $$("div.tl_formbody_submit").setStyle("display", "none"); }); </script>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; }
5318	public function wait ( ) { $ this -> internalWait ( ) ; $ event = $ this -> isSuccessExit ( ) ? 'success' : 'error' ; $ this -> internalEmit ( 'exit' , $ this -> pid ) ; $ this -> internalEmit ( $ event ) ; return $ this ; }
9400	public function export ( ) { foreach ( $ this -> messages as $ message ) { list ( $ msg , $ level , $ catagory , $ timestamp , $ traces ) = $ message ; $ errStr = '' ; $ options = [ 'level' => yii \ log \ Logger :: getLevelName ( $ level ) , 'extra' => [ ] , ] ; $ templateData = null ; if ( is_array ( $ msg ) ) { $ errStr = isset ( $ msg [ 'msg' ] ) ? $ msg [ 'msg' ] : '' ; if ( isset ( $ msg [ 'data' ] ) ) $ options [ 'extra' ] = $ msg [ 'data' ] ; } else { $ errStr = $ msg ; } $ traces = array_map ( function ( $ v ) { return "{$v['file']}" . PHP_EOL . "{$v['class']}::{$v['function']} [{$v['line']}]" ; } , $ traces ) ; if ( ! empty ( $ traces ) ) $ options [ 'extra' ] [ 'traces' ] = $ traces ; $ this -> client -> captureMessage ( $ errStr , array ( ) , $ options , false ) ; } }
5274	public function groupBy ( $ columns ) { if ( is_string ( $ columns ) ) { $ columns = $ this -> argument_to_array ( $ columns ) ; } $ this -> statements [ 'groups' ] = $ this -> statements [ 'groups' ] + $ columns ; return $ this ; }
7967	public function setProperties ( $ billingAccount , $ properties ) { if ( ! $ billingAccount ) throw new BadMethodCallException ( 'Parameter $billingAccount is missing.' ) ; if ( ! $ properties ) throw new BadMethodCallException ( 'Parameter $properties is missing.' ) ; if ( ! is_array ( $ properties ) ) throw new BadMethodCallException ( 'Parameter $properties must be a array.' ) ; $ t = array ( ) ; if ( array_key_exists ( 'description' , $ properties ) ) $ t [ 'description' ] = $ properties [ 'description' ] ; $ properties = $ t ; unset ( $ t ) ; if ( count ( $ properties ) == 0 ) throw new BadMethodCallException ( 'Parameter $properties does not contain valid key. valid key is "description"' ) ; try { $ r = $ this -> put ( 'telephony/' . $ billingAccount , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ properties ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new TelephonyException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return true ; }
8986	public function get_columns ( ) { return array ( 'id' => new IntegerBased ( 'BIGINT' , 'id' , array ( 'NOT NULL' , 'auto_increment' ) , array ( 20 ) ) , 'message' => new StringBased ( 'VARCHAR' , 'message' , array ( ) , array ( 255 ) ) , 'level' => new StringBased ( 'VARCHAR' , 'level' , array ( ) , array ( 20 ) ) , 'lgroup' => new StringBased ( 'VARCHAR' , 'lgroup' , array ( ) , array ( 20 ) ) , 'time' => new DateTime ( 'time' ) , 'user' => new ForeignUser ( 'user' ) , 'ip' => new StringBased ( 'VARCHAR' , 'ip' , array ( ) , array ( 45 ) ) , 'exception' => new StringBased ( 'VARCHAR' , 'exception' , array ( ) , array ( 255 ) ) , 'trace' => new StringBased ( 'LONGTEXT' , 'trace' ) , 'context' => new StringBased ( 'LONGTEXT' , 'context' ) , ) ; }
592	public function combineJsFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; foreach ( $ inputFiles as $ file ) { $ fileContent = rtrim ( file_get_contents ( $ file ) ) ; if ( substr ( $ fileContent , - 1 ) !== ';' ) { $ fileContent .= "\n;" ; } $ content .= "/*** BEGIN FILE: $file ***/\n" . $ fileContent . "\n" . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output JavaScript file '{$outputFile}'." ) ; } }
7943	public function deleteSecondaryDnsDomains ( $ domain , $ domain2delete ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ domain2delete = ( string ) $ domain2delete ; if ( ! $ domain2delete ) throw new BadMethodCallException ( 'Parameter $domain2getInfo is missing.' ) ; try { $ r = $ this -> delete ( 'dedicated/server/' . $ domain . '/secondaryDnsDomains/' . $ domain2delete ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
728	public static function off ( $ class , $ name , $ handler = null ) { $ class = ltrim ( $ class , '\\' ) ; if ( empty ( self :: $ _events [ $ name ] [ $ class ] ) && empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { return false ; } if ( $ handler === null ) { unset ( self :: $ _events [ $ name ] [ $ class ] ) ; unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; return true ; } if ( isset ( self :: $ _events [ $ name ] [ $ class ] ) ) { $ removed = false ; foreach ( self :: $ _events [ $ name ] [ $ class ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( self :: $ _events [ $ name ] [ $ class ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { self :: $ _events [ $ name ] [ $ class ] = array_values ( self :: $ _events [ $ name ] [ $ class ] ) ; return $ removed ; } } $ removed = false ; if ( isset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { foreach ( self :: $ _eventWildcards [ $ name ] [ $ class ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { self :: $ _eventWildcards [ $ name ] [ $ class ] = array_values ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; if ( empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; if ( empty ( self :: $ _eventWildcards [ $ name ] ) ) { unset ( self :: $ _eventWildcards [ $ name ] ) ; } } } } return $ removed ; }
8564	public function getEligibleShippingServices ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetEligibleShippingServicesRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetEligibleShippingServicesResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
295	public function getOldAttribute ( $ name ) { return isset ( $ this -> _oldAttributes [ $ name ] ) ? $ this -> _oldAttributes [ $ name ] : null ; }
5190	private function filterString ( $ str ) : string { if ( is_string ( $ str ) && strlen ( $ str ) > 0 && $ str !== null ) { return $ str ; } throw new \ Exception ( 'String required' , 1 ) ; }
8587	public function setLowestOfferListing ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LowestOfferListing' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6935	protected function formatMessage ( $ message , $ format = [ Console :: FG_RED , Console :: BOLD ] ) { $ stream = ( PHP_SAPI === 'cli' ) ? \ STDERR : \ STDOUT ; if ( Console :: stream_supports_ansi_colors ( $ stream ) ) { $ message = Console :: ansi_format ( $ message , $ format ) ; } return $ message ; }
6704	public function baseURL ( $ httpverb , $ url , $ params ) { uksort ( $ params , 'strcmp' ) ; return strtoupper ( $ httpverb ) . '&' . rawurlencode ( $ url ) . '&' . rawurlencode ( http_build_query ( $ params ) ) ; }
11551	public function saveConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_SAVE , $ event ) ; if ( ! $ consignment -> getStatus ( ) ) { $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_NEW ) ; } try { $ adapter -> saveConsignment ( $ consignment ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment saving.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_SAVE , $ event ) ; }
5329	final public function push ( string $ data ) { if ( $ this -> generator === null ) { throw new \ Error ( "The parser is no longer writable" ) ; } $ this -> buffer .= $ data ; $ end = false ; try { while ( $ this -> buffer !== "" ) { if ( \ is_int ( $ this -> delimiter ) ) { if ( \ strlen ( $ this -> buffer ) < $ this -> delimiter ) { break ; } $ send = \ substr ( $ this -> buffer , 0 , $ this -> delimiter ) ; $ this -> buffer = \ substr ( $ this -> buffer , $ this -> delimiter ) ; } elseif ( \ is_string ( $ this -> delimiter ) ) { if ( ( $ position = \ strpos ( $ this -> buffer , $ this -> delimiter ) ) === false ) { break ; } $ send = \ substr ( $ this -> buffer , 0 , $ position ) ; $ this -> buffer = \ substr ( $ this -> buffer , $ position + \ strlen ( $ this -> delimiter ) ) ; } else { $ send = $ this -> buffer ; $ this -> buffer = "" ; } $ this -> delimiter = $ this -> generator -> send ( $ send ) ; if ( ! $ this -> generator -> valid ( ) ) { $ end = true ; break ; } if ( $ this -> delimiter !== null && ( ! \ is_int ( $ this -> delimiter ) || $ this -> delimiter <= 0 ) && ( ! \ is_string ( $ this -> delimiter ) || ! \ strlen ( $ this -> delimiter ) ) ) { throw new InvalidDelimiterError ( $ this -> generator , \ sprintf ( "Invalid value yielded: Expected NULL, an int greater than 0, or a non-empty string; %s given" , \ is_object ( $ this -> delimiter ) ? \ sprintf ( "instance of %s" , \ get_class ( $ this -> delimiter ) ) : \ gettype ( $ this -> delimiter ) ) ) ; } } } catch ( \ Throwable $ exception ) { $ end = true ; throw $ exception ; } finally { if ( $ end ) { $ this -> generator = null ; } } }
5934	public function setLastLogin ( $ lastLogin ) { if ( $ lastLogin instanceof DateTime ) { $ this -> lastLogin = $ lastLogin ; } else { try { $ this -> lastLogin = new DateTime ( $ lastLogin ) ; } catch ( \ Exception $ e ) { $ this -> lastLogin = null ; } } return $ this ; }
10305	private function recursiveReplace ( $ path ) { $ patterns = [ '/*.md' , '/*.php' , '/*.phtml' , '/*.txt' , '/*.TXT' , ] ; $ from = array_keys ( $ this -> getMapping ( ) ) ; $ to = array_values ( $ this -> getMapping ( ) ) ; foreach ( $ patterns as $ pattern ) { foreach ( glob ( $ path . $ pattern ) as $ file ) { $ original = file_get_contents ( $ file ) ; $ converted = str_replace ( $ from , $ to , $ original ) ; if ( $ original !== $ converted ) { echo $ file . " converted\n" ; file_put_contents ( $ file , $ converted ) ; } } } foreach ( glob ( $ path . '/*' , GLOB_ONLYDIR ) as $ subpath ) { if ( strpos ( $ subpath , $ path . '/' ) === 0 ) { $ this -> recursiveReplace ( $ subpath ) ; } } }
11809	protected function fillRelationConfig ( & $ config , $ otherObject ) { if ( isset ( $ config [ 'parent_object_id' ] ) ) { $ config [ 'child_object_id' ] = $ otherObject ; } elseif ( isset ( $ config [ 'child_object_id' ] ) ) { $ config [ 'parent_object_id' ] = $ otherObject ; } }
1862	public function move_uploaded_file ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; return move_uploaded_file ( $ strSource , $ this -> strRootDir . '/' . $ strDestination ) ; }
709	public function string ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_STRING , $ length ) ; }
4693	public function orderBy ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> order = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'order' ] = $ args ; return $ this ; }
997	public function offsetUnset ( $ offset ) { if ( $ offset === true ) { $ this -> trueValue = null ; $ this -> trueValueIsSet = false ; } elseif ( $ offset === false ) { $ this -> falseValue = null ; $ this -> falseValueIsSet = false ; } elseif ( is_int ( $ offset ) || is_string ( $ offset ) ) { unset ( $ this -> standardStore [ $ offset ] ) ; } elseif ( is_float ( $ offset ) ) { unset ( $ this -> floatStore [ ( string ) $ offset ] ) ; } elseif ( is_object ( $ offset ) ) { $ this -> objectStore -> offsetUnset ( $ offset ) ; } elseif ( is_array ( $ offset ) ) { $ index = array_search ( $ offset , $ this -> arrayKeys , true ) ; if ( $ index !== false ) { array_splice ( $ this -> arrayKeys , $ index , 1 ) ; array_splice ( $ this -> arrayValues , $ index , 1 ) ; } } elseif ( $ offset === null ) { $ this -> nullValue = null ; $ this -> nullValueIsSet = false ; } }
2408	public function flushAllData ( ) { @ trigger_error ( 'Using Template::flushAllData() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ function_exists ( 'fastcgi_finish_request' ) ) { fastcgi_finish_request ( ) ; } elseif ( PHP_SAPI !== 'cli' ) { $ status = ob_get_status ( true ) ; $ level = \ count ( $ status ) ; while ( $ level -- > 0 && ( ! empty ( $ status [ $ level ] [ 'del' ] ) || ( isset ( $ status [ $ level ] [ 'flags' ] ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_REMOVABLE ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_FLUSHABLE ) ) ) ) { ob_end_flush ( ) ; } flush ( ) ; } }
12286	public function inset ( string $ block , array $ vars = null ) : string { return trim ( $ this -> make ( $ block , $ vars ) ) . PHP_EOL ; }
10548	public function setTemplate ( Template $ template ) { $ this -> template = $ template ; $ this -> setVariable ( 'template' , $ template ) ; $ this -> setVariable ( 'tpl' , $ template ) ; return $ this ; }
3902	public function deleteColumn ( ) { $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; $ columns = $ schemaManager -> listTableColumns ( $ this -> getMetaModel ( ) -> getTableName ( ) ) ; if ( $ this -> getColName ( ) && isset ( $ columns [ $ this -> getColName ( ) ] ) ) { $ this -> tableManipulator -> dropColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) ) ; } }
6991	static public function getLocaleWithSuffix ( $ separator = '_' , $ lowercased = false ) : ? string { $ locale = preg_split ( '%[-_]%' , strtolower ( app ( ) -> getLocale ( ) ) ) ; if ( count ( $ locale ) === 2 ) { return $ locale [ 0 ] . $ separator . ( $ lowercased ? $ locale [ 1 ] : strtoupper ( $ locale [ 1 ] ) ) ; } else { $ localeSuffix = isset ( static :: $ localeSuffixMap [ $ locale [ 0 ] ] ) ? static :: $ localeSuffixMap [ $ locale [ 0 ] ] : $ locale [ 0 ] ; return $ locale [ 0 ] . $ separator . ( $ lowercased ? $ localeSuffix : strtoupper ( $ localeSuffix ) ) ; } }
7676	function TbsQuickLoad ( $ NameLst ) { if ( ! is_array ( $ NameLst ) ) $ NameLst = array ( $ NameLst ) ; $ nbr = 0 ; $ TBS = & $ this -> TBS ; foreach ( $ NameLst as $ FileName ) { $ idx = $ this -> FileGetIdx ( $ FileName ) ; if ( ( ! isset ( $ this -> TbsStoreLst [ $ idx ] ) ) && ( ! isset ( $ this -> TbsNoField [ $ idx ] ) ) ) { $ txt = $ this -> FileRead ( $ idx , true ) ; if ( strpos ( $ txt , $ TBS -> _ChrOpen ) !== false ) { $ nbr ++ ; if ( $ nbr == 1 ) { $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ SaveIdx = $ this -> TbsCurrIdx ; $ SaveName = $ TBS -> OtbsCurrFile ; $ this -> TbsSwitchMode ( true ) ; } $ this -> TbsStorePark ( ) ; $ TBS -> Source = $ txt ; unset ( $ txt ) ; $ TBS -> OtbsCurrFile = $ FileName ; $ this -> TbsCurrIdx = $ idx ; if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } else { $ this -> TbsNoField [ $ idx ] = true ; } } } if ( $ nbr > 0 ) { $ this -> TbsSwitchMode ( false ) ; $ this -> TbsStorePark ( ) ; $ this -> TbsStoreLoad ( $ SaveIdx , $ SaveName ) ; } return $ nbr ; }
12698	static function archiveDir ( $ sourcedir , $ archivefile , $ no_top_dir = false ) { $ archivefile = str_replace ( '\\' , '/' , $ archivefile ) ; $ sourcedir = str_replace ( '\\' , '/' , realpath ( $ sourcedir ) ) ; if ( $ no_top_dir ) { $ srcdir = '.' ; $ workdir = $ sourcedir ; } else { $ srcdir = basename ( $ sourcedir ) ; $ workdir = dirname ( $ sourcedir ) ; } $ archivedir = dirname ( $ archivefile ) ; $ extra = '' ; $ tar = self :: getTool ( 'tar' ) ; if ( substr ( $ archivefile , - 7 ) == '.tar.gz' || substr ( $ archivefile , - 4 ) == '.tgz' ) { $ cmd = "$tar -z -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 8 ) == '.tar.bz2' ) { $ cmd = "$tar -j -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 4 ) == '.tar' ) { $ cmd = "$tar -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 4 ) == '.zip' ) { $ zip = self :: getTool ( 'zip' ) ; $ cmd = "$zip -9 -r" ; } else { throw new pakeException ( "Can not determine archive type from filename: $archivefile" ) ; } pake_sh ( self :: getCdCmd ( $ workdir ) . " && $cmd $archivefile $extra $srcdir" ) ; pake_echo_action ( 'file+' , $ archivefile ) ; }
7817	public function secret ( string $ secret = '' ) : self { if ( empty ( $ secret ) ) { $ secret = str_random ( 15 ) ; } $ this -> secret = $ secret ; return $ this ; }
2806	public function viewLogAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ log = $ this -> getRequest ( ) -> getParam ( 'log' ) ; if ( ! $ token || ! $ log ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return ; } try { $ content = $ requestProfile -> getLogging ( ) -> getLoggedContent ( $ log ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( $ content ) ; } catch ( Exception $ e ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( 'Unable to retrieve logged content' ) ; } }
8637	public function setOrderFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7629	public function setContainerAcl ( $ containerName = '' , $ acl = self :: ACL_PRIVATE , $ signedIdentifiers = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ headers = array ( ) ; if ( $ acl != self :: ACL_PRIVATE && ! is_null ( $ acl ) && $ acl != '' ) { $ headers [ Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ] = $ acl ; } $ policies = null ; if ( is_array ( $ signedIdentifiers ) && count ( $ signedIdentifiers ) > 0 ) { $ policies = '' ; $ policies .= '<?xml version="1.0" encoding="utf-8"?>' . "\r\n" ; $ policies .= '<SignedIdentifiers>' . "\r\n" ; foreach ( $ signedIdentifiers as $ signedIdentifier ) { $ policies .= ' <SignedIdentifier>' . "\r\n" ; $ policies .= ' <Id>' . $ signedIdentifier -> Id . '</Id>' . "\r\n" ; $ policies .= ' <AccessPolicy>' . "\r\n" ; if ( $ signedIdentifier -> Start != '' ) $ policies .= ' <Start>' . $ signedIdentifier -> Start . '</Start>' . "\r\n" ; if ( $ signedIdentifier -> Expiry != '' ) $ policies .= ' <Expiry>' . $ signedIdentifier -> Expiry . '</Expiry>' . "\r\n" ; if ( $ signedIdentifier -> Permissions != '' ) $ policies .= ' <Permission>' . $ signedIdentifier -> Permissions . '</Permission>' . "\r\n" ; $ policies .= ' </AccessPolicy>' . "\r\n" ; $ policies .= ' </SignedIdentifier>' . "\r\n" ; } $ policies .= '</SignedIdentifiers>' . "\r\n" ; } $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'PUT' , $ headers , false , $ policies , self :: RESOURCE_CONTAINER , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
4861	public function pushLazy ( $ service , $ payload = null , array $ options = [ ] ) { $ manager = $ this -> getJobPluginManager ( ) ; $ serviceOptions = [ ] ; if ( is_array ( $ service ) ) { $ serviceOptions = $ service [ 'options' ] ?? $ service [ 1 ] ?? [ ] ; $ service = $ service [ 'name' ] ?? $ service [ 0 ] ?? null ; } if ( ! $ manager -> has ( $ service ) && ! class_exists ( $ service ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Service name "%s" is not a known job service or existent class' , $ service ) ) ; } $ lazyOptions = [ 'name' => $ service , 'options' => $ serviceOptions , 'content' => $ payload , ] ; $ job = $ this -> getJobPluginManager ( ) -> build ( 'lazy' , $ lazyOptions ) ; $ this -> push ( $ job , $ options ) ; }
4147	protected function getResponse ( ) { $ url = $ this -> getUrl ( ) ; $ params = array ( 'get' => $ this -> getParams , 'post' => $ this -> postParams , 'headers' => $ this -> buildRequestHeader ( ) , ) ; return $ this -> curl -> send ( $ url , $ params ) ; }
6728	public function set_total_votes ( $ post_id , $ votes ) { $ votes = json_encode ( $ votes , true ) ; if ( ! add_post_meta ( $ post_id , 'imdbTotalVotes' , $ votes , true ) ) { update_post_meta ( $ post_id , 'imdbTotalVotes' , $ votes ) ; } }
159	public function having ( $ condition , $ params = [ ] ) { $ this -> having = $ condition ; $ this -> addParams ( $ params ) ; return $ this ; }
2393	public function addFile ( $ strFile , $ strName = null ) { if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFile ) ) { throw new \ Exception ( "File $strFile does not exist" ) ; } if ( strncmp ( $ strName , '/' , 1 ) === 0 ) { $ strName = substr ( $ strName , 1 ) ; } $ this -> addString ( file_get_contents ( $ this -> strRootDir . '/' . $ strFile ) , $ strName ? : $ strFile , filemtime ( $ this -> strRootDir . '/' . $ strFile ) ) ; }
11336	public function getBaseNamespace ( ) { if ( ! empty ( $ this -> moduleSet ) && isset ( Yii :: $ app -> extensions [ $ this -> moduleSet ] ) ) { $ bsClass = Yii :: $ app -> extensions [ $ this -> moduleSet ] [ 'bootstrap' ] ; $ bsReflector = new \ ReflectionClass ( new $ bsClass ( ) ) ; return $ bsReflector -> getNamespaceName ( ) ; } return 'cascade\modules' ; }
459	public function getColumnType ( $ type ) { if ( $ type instanceof ColumnSchemaBuilder ) { $ type = $ type -> __toString ( ) ; } if ( isset ( $ this -> typeMap [ $ type ] ) ) { return $ this -> typeMap [ $ type ] ; } elseif ( preg_match ( '/^(\w+)\((.+?)\)(.*)$/' , $ type , $ matches ) ) { if ( isset ( $ this -> typeMap [ $ matches [ 1 ] ] ) ) { return preg_replace ( '/\(.+\)/' , '(' . $ matches [ 2 ] . ')' , $ this -> typeMap [ $ matches [ 1 ] ] ) . $ matches [ 3 ] ; } } elseif ( preg_match ( '/^(\w+)\s+/' , $ type , $ matches ) ) { if ( isset ( $ this -> typeMap [ $ matches [ 1 ] ] ) ) { return preg_replace ( '/^\w+/' , $ this -> typeMap [ $ matches [ 1 ] ] , $ type ) ; } } return $ type ; }
8747	public function select ( ) { $ read = [ $ this -> stream ] ; $ write = null ; $ except = null ; $ this -> selected = @ stream_select ( $ read , $ write , $ except , 0 , $ this -> timeout ) ; return $ this ; }
3135	public function getItemState ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; $ state = is_null ( $ userUri ) ? null : $ serviceService -> get ( $ userUri , $ stateId ) ; if ( $ state ) { $ state = json_decode ( $ state , true ) ; if ( is_null ( $ state ) ) { throw new \ common_exception_InconsistentData ( 'Unable to decode the state for the item ' . $ itemRef ) ; } } return $ state ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
6996	public static function parseApplePriceMatrixAll ( $ file , $ directory = null ) { $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTMLFile ( $ file ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ currencies = array ( ) ; $ currencyElements = $ xpath -> query ( '//table[1]//tr[2]//td[position() > 1]' ) ; foreach ( $ currencyElements as $ currencyElement ) { $ currency = trim ( $ currencyElement -> textContent ) ; if ( 'Euro' == $ currency ) { $ currency = 'EUR' ; } $ currencies [ ] = $ currency ; } if ( ! count ( $ currencies ) ) { throw new \ RuntimeException ( sprintf ( 'Not found currencies in ApplePriceMatrix in file "%s".' , $ file ) ) ; } $ currencies = array_flip ( $ currencies ) ; foreach ( $ currencies as $ currency => $ null ) { $ currencies [ $ currency ] = static :: parseApplePriceMatrix ( $ dom , $ currency , $ directory ) ; } return $ currencies ; }
11973	private function genericParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( count ( $ params ) >= 1 && count ( $ params ) <= 2 ) ; }
6985	protected function createSaleContext ( SaleInterface $ sale ) : ContextInterface { $ context = $ this -> createContext ( ) ; if ( null !== $ group = $ sale -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ group ) -> setBusiness ( $ group -> isBusiness ( ) ) ; } if ( null !== $ address = $ sale -> getInvoiceAddress ( ) ) { $ context -> setInvoiceCountry ( $ address -> getCountry ( ) ) ; } $ address = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ address ) { $ context -> setDeliveryCountry ( $ address -> getCountry ( ) ) ; } if ( null !== $ currency = $ sale -> getCurrency ( ) ) { $ context -> setCurrency ( $ currency ) ; } if ( null !== $ mode = $ sale -> getVatDisplayMode ( ) ) { $ context -> setVatDisplayMode ( $ mode ) ; } if ( $ sale instanceof OrderInterface && null !== $ date = $ sale -> getCreatedAt ( ) ) { $ context -> setDate ( $ date ) ; } $ context -> setTaxExempt ( $ sale -> isTaxExempt ( ) ) ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ customer ) ; } elseif ( $ this -> customerProvider -> hasCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ this -> customerProvider -> getCustomer ( ) ) ; } $ this -> finalize ( $ context ) ; $ sale -> setContext ( $ context ) ; return $ context ; }
3542	public static function getExtensionOptions ( $ optionName ) { if ( isset ( Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) && is_array ( Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) ) { return Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: EXTENSION_OPTIONS_DEFAULT ) ) { return static :: EXTENSION_OPTIONS_DEFAULT [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Extension-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
3998	protected function getAttribute ( $ metaModelIdOrName , $ intDataId , $ strAttributeName , $ strOutput = 'raw' ) { $ objMM = $ this -> loadMetaModel ( $ metaModelIdOrName ) ; if ( null === $ objMM ) { return false ; } if ( empty ( $ strOutput ) ) { $ strOutput = 'raw' ; } $ objMetaModelItem = $ objMM -> findById ( $ intDataId ) ; if ( null === $ objMetaModelItem ) { throw new \ RuntimeException ( 'MetaModel item not found: ' . $ intDataId ) ; } $ arrAttr = $ objMetaModelItem -> parseAttribute ( $ strAttributeName ) ; return $ arrAttr [ $ strOutput ] ; }
11147	public function getFromLocation ( Neuron_GameServer_Map_Location $ location ) { $ area = new Neuron_GameServer_Map_Area ( $ location , 1 ) ; $ objects = $ this -> getDisplayObjects ( $ area ) ; $ out = array ( ) ; foreach ( $ objects as $ v ) { if ( $ v -> getLocation ( ) -> equals ( $ location ) ) { $ out [ ] = $ v ; } } return $ out ; }
1061	public static function findValuesAddedToEnums ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ valuesAddedToEnums = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof EnumType ) || ! ( $ newType instanceof EnumType ) ) { continue ; } $ valuesInOldEnum = [ ] ; foreach ( $ oldType -> getValues ( ) as $ value ) { $ valuesInOldEnum [ $ value -> name ] = true ; } foreach ( $ newType -> getValues ( ) as $ value ) { if ( isset ( $ valuesInOldEnum [ $ value -> name ] ) ) { continue ; } $ valuesAddedToEnums [ ] = [ 'type' => self :: DANGEROUS_CHANGE_VALUE_ADDED_TO_ENUM , 'description' => sprintf ( '%s was added to enum type %s.' , $ value -> name , $ typeName ) , ] ; } } return $ valuesAddedToEnums ; }
5110	private function appendBind ( $ part , $ bind ) { if ( $ bind === false ) return $ this ; if ( ! is_array ( $ bind ) ) $ bind = [ $ bind ] ; if ( ! $ this -> bind [ $ part ] ) { $ this -> bind [ $ part ] = $ bind ; } else { $ this -> bind [ $ part ] = array_merge ( $ this -> bind [ $ part ] , $ bind ) ; } return $ this ; }
4794	function group ( $ columns , $ having = "" ) { $ this -> __destruct ( ) ; $ this -> group = $ columns ; $ this -> having = $ having ; return $ this ; }
419	private function validateCsrfTokenInternal ( $ clientSuppliedToken , $ trueToken ) { if ( ! is_string ( $ clientSuppliedToken ) ) { return false ; } $ security = Yii :: $ app -> security ; return $ security -> compareString ( $ security -> unmaskToken ( $ clientSuppliedToken ) , $ security -> unmaskToken ( $ trueToken ) ) ; }
3615	public function setEcoTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = array ( ) ; if ( $ temp_low === FALSE ) { $ data [ 'away_temperature_low_enabled' ] = FALSE ; } elseif ( $ temp_low != NULL ) { $ data [ 'away_temperature_low_enabled' ] = TRUE ; $ data [ 'away_temperature_low' ] = $ temp_low ; } if ( $ temp_high === FALSE ) { $ data [ 'away_temperature_high_enabled' ] = FALSE ; } elseif ( $ temp_high != NULL ) { $ data [ 'away_temperature_high_enabled' ] = TRUE ; $ data [ 'away_temperature_high' ] = $ temp_high ; } $ data = json_encode ( $ data ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
7514	function next_search ( $ characters , $ callback = true ) { $ this -> token_start = $ this -> pos ; if ( ! is_array ( $ characters ) ) { $ characters = array_fill_keys ( str_split ( $ characters ) , true ) ; } while ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ characters [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( $ callback && isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
12632	public function query ( $ orderNo , $ type = self :: OUT_TRADE_NO ) { $ params = [ $ type => $ orderNo , ] ; return $ this -> request ( $ this -> wrapApi ( self :: API_QUERY ) , $ params ) ; }
768	protected function regenerateCsrfToken ( ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ request -> enableCsrfCookie || $ this -> enableSession ) { $ request -> getCsrfToken ( true ) ; } }
1841	public static function parse ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( 'Invalid file ' . $ file ) ; } $ table = '' ; $ return = array ( ) ; $ data = file ( $ file ) ; foreach ( $ data as $ k => $ v ) { $ key_name = array ( ) ; $ subpatterns = array ( ) ; if ( preg_match ( '/^[#-]+/' , $ v ) || ! \ strlen ( trim ( $ v ) ) ) { unset ( $ data [ $ k ] ) ; continue ; } if ( preg_match ( '/^CREATE TABLE `([^`]+)`/i' , $ v , $ subpatterns ) ) { $ table = $ subpatterns [ 1 ] ; } elseif ( $ table != '' && preg_match ( '/^\)([^;]+);/' , $ v , $ subpatterns ) ) { $ return [ $ table ] [ 'TABLE_OPTIONS' ] = $ subpatterns [ 1 ] ; $ table = '' ; } elseif ( $ table != '' ) { preg_match ( '/^[^`]*`([^`]+)`/' , trim ( $ v ) , $ key_name ) ; $ first = preg_replace ( '/\s[^\n\r]+/' , '' , $ key_name [ 0 ] ) ; $ key = $ key_name [ 1 ] ; if ( \ in_array ( $ first , array ( 'KEY' , 'PRIMARY' , 'PRIMARY KEY' , 'FOREIGN' , 'FOREIGN KEY' , 'INDEX' , 'UNIQUE' , 'FULLTEXT' , 'CHECK' ) ) ) { if ( strncmp ( $ first , 'PRIMARY' , 7 ) === 0 ) { $ key = 'PRIMARY' ; } $ return [ $ table ] [ 'TABLE_CREATE_DEFINITIONS' ] [ $ key ] = preg_replace ( '/,$/' , '' , trim ( $ v ) ) ; } else { $ return [ $ table ] [ 'TABLE_FIELDS' ] [ $ key ] = preg_replace ( '/,$/' , '' , trim ( $ v ) ) ; } } } foreach ( array_keys ( $ return ) as $ table ) { if ( ! isset ( $ return [ $ table ] [ 'TABLE_CREATE_DEFINITIONS' ] [ 'PRIMARY' ] ) ) { unset ( $ return [ $ table ] [ 'TABLE_OPTIONS' ] ) ; } } return $ return ; }
1128	public function isSelfOrAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) <= $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; }
12022	function addCheckScopeMethod ( ) { $ scopes = $ this -> operationDefinition -> getScopes ( ) ; if ( count ( $ scopes ) == 0 ) { return ; } $ methodGenerator = new MethodGenerator ( 'checkScopeRequirement' ) ; $ parameterGenerator = new ParameterGenerator ( 'allowedScopes' , 'array' ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ body = '//For each of the elements, all of the scopes in that element' . PHP_EOL ; $ body .= '//must be satisfied' . PHP_EOL ; $ body .= '$requiredScopesArray = [' . PHP_EOL ; foreach ( $ scopes as $ scopeList ) { $ body .= ' [' ; $ separator = '' ; foreach ( $ scopeList as $ scope ) { $ body .= sprintf ( "%s'%s'" , $ separator , $ scope ) ; $ separator = ', ' ; } $ body .= ']' . PHP_EOL ; } $ body .= '];' . PHP_EOL . PHP_EOL ; $ body .= <<< 'END'foreach($requiredScopesArray as $requiredScopes) { $requirementMet = true; foreach ($requiredScopes as $requiredScope) { if (in_array($requiredScope, $allowedScopes) == false) { $requirementMet = false; break; } } if ($requirementMet == true) { return true; }}return false;END ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
7593	public function openTag ( FormInterface $ form = null ) { $ this -> setFormClass ( $ form , $ this -> formLayout ) ; return parent :: openTag ( $ form ) ; }
7608	public function renderListItems ( array $ aDropdownOptions ) { if ( ! isset ( $ aDropdownOptions [ 'items' ] ) ) { throw new LogicException ( __METHOD__ . ' expects "items" option' ) ; } if ( ! is_array ( $ aDropdownOptions [ 'items' ] ) ) { throw new LogicException ( '"items" option expects an array, "' . gettype ( $ aDropdownOptions [ 'items' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'list_attributes' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] = array ( 'class' => 'dropdown-menu' ) ; } else { if ( ! is_array ( $ aDropdownOptions [ 'list_attributes' ] ) ) { throw new \ LogicException ( '"list_attributes" option expects an array, "' . gettype ( $ aDropdownOptions [ 'list_attributes' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] = 'dropdown-menu' ; } elseif ( ! preg_match ( '/(\s|^)dropdown-menu(\s|$)/' , $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] .= ' dropdown-menu' ; } } if ( empty ( $ aDropdownOptions [ 'list_attributes' ] [ 'role' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'role' ] = 'menu' ; } if ( ! empty ( $ aDropdownOptions [ 'name' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'aria-labelledby' ] = $ aDropdownOptions [ 'name' ] ; } $ sItems = '' ; foreach ( $ aDropdownOptions [ 'items' ] as $ sKey => $ aItemOptions ) { if ( ! is_array ( $ aItemOptions ) ) { if ( ! is_scalar ( $ aItemOptions ) ) { throw new \ LogicException ( 'item option expects an array or a scalar value, "' . gettype ( $ aItemOptions ) . '" given' ) ; } $ aItemOptions = $ aItemOptions === self :: TYPE_ITEM_DIVIDER ? array ( 'type' => self :: TYPE_ITEM_DIVIDER ) : array ( 'label' => $ aItemOptions , 'type' => self :: TYPE_ITEM_LINK , 'item_attributes' => array ( 'href' => is_string ( $ sKey ) ? $ sKey : null ) ) ; } else { if ( ! isset ( $ aItemOptions [ 'label' ] ) ) { $ aItemOptions [ 'label' ] = is_string ( $ sKey ) ? $ sKey : null ; } if ( ! isset ( $ aItemOptions [ 'type' ] ) ) { $ aItemOptions [ 'type' ] = self :: TYPE_ITEM_LINK ; } } $ sItems .= $ this -> renderItem ( $ aItemOptions ) . "\n" ; } return sprintf ( static :: $ dropdownListFormat , $ this -> createAttributesString ( $ aDropdownOptions [ 'list_attributes' ] ) , $ sItems ) ; }
3962	private function createOrGetDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasMetaModelDefinition ( ) ) { return $ container -> getMetaModelDefinition ( ) ; } $ container -> setMetaModelDefinition ( $ definition = new MetaModelDefinition ( ) ) ; return $ definition ; }
6113	public function sendPluginCmd ( $ plugin , $ data , $ cpw = null , $ subscribed = false ) { if ( $ this -> getId ( ) != $ this -> getParent ( ) -> whoamiGet ( "client_channel_id" ) ) { $ this -> getParent ( ) -> clientMove ( $ this -> getParent ( ) -> whoamiGet ( "client_id" ) , $ this -> getId ( ) , $ cpw ) ; } $ this -> execute ( "plugincmd" , array ( "name" => $ plugin , "data" => $ data , "targetmode" => $ subscribed ? TeamSpeak3 :: PLUGINCMD_CHANNEL_SUBSCRIBED : TeamSpeak3 :: PLUGINCMD_CHANNEL ) ) ; }
12169	private function createPropertyValuesTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?property_values`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?property_values` ( `value_id` mediumint(11) NOT NULL AUTO_INCREMENT, `value_data` text NOT NULL, `value_updated_on` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `property_id` int(11) NOT NULL, `object_id` int(11) NOT NULL, PRIMARY KEY (`value_id`), UNIQUE KEY `object_property_uid` (`object_id`,`property_id`), KEY `property_id_idxfk` (`property_id`), KEY `object_id_idxfk` (`object_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;" ) ; $ this -> database -> query ( "DROP PROCEDURE IF EXISTS `property_value_validate`;" ) ; $ this -> database -> query ( "CREATE PROCEDURE `?property_value_validate`(IN _property_id INT, IN _value_data LONGTEXT) BEGIN DECLARE _validationFails CONDITION FOR SQLSTATE '99001'; DECLARE _dataTypeRegExp VARCHAR(255); DECLARE _signalText TEXT; SELECT r.datatype_validation FROM `?properties` AS d INNER JOIN `?property_datatypes` AS r WHERE `property_id`= _property_id AND d.property_datatype=r.datatype_name INTO _dataTypeRegExp; IF (_dataTypeRegExp IS NOT NULL) THEN IF (_value_data NOT REGEXP(_dataTypeRegExp)) THEN SET _signalText = CONCAT('The inserted/updated value fails the property data type validation'); SIGNAL _validationFails SET MESSAGE_TEXT=_signalText; END IF; END IF; END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?property_value_validate_insert`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?property_value_validate_insert` BEFORE INSERT ON `?property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?property_value_validate_update`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?property_value_validate_update` BEFORE UPDATE ON `?property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; }
572	public function validatePassword ( $ password , $ hash ) { if ( ! is_string ( $ password ) || $ password === '' ) { throw new InvalidArgumentException ( 'Password must be a string and cannot be empty.' ) ; } if ( ! preg_match ( '/^\$2[axy]\$(\d\d)\$[\.\/0-9A-Za-z]{22}/' , $ hash , $ matches ) || $ matches [ 1 ] < 4 || $ matches [ 1 ] > 30 ) { throw new InvalidArgumentException ( 'Hash is invalid.' ) ; } if ( function_exists ( 'password_verify' ) ) { return password_verify ( $ password , $ hash ) ; } $ test = crypt ( $ password , $ hash ) ; $ n = strlen ( $ test ) ; if ( $ n !== 60 ) { return false ; } return $ this -> compareString ( $ test , $ hash ) ; }
9706	private function writeAllNumberFormats ( ) { foreach ( $ this -> numberFormats as $ numberFormatIndex => $ numberFormat ) { $ this -> writeNumberFormat ( $ numberFormat -> getFormatCode ( ) , $ numberFormatIndex ) ; } }
7243	public function description ( ) { $ default = Inform_About_Content :: default_opt_in ( NULL ) ; $ subscribed_by_default = apply_filters ( 'iac_default_opt_in' , $ default ) ; $ description = $ subscribed_by_default ? __ ( 'Note: Users must opt-out from e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) : __ ( 'Note: Users must opt-in to e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) ; printf ( '<p class="description">%s</p>' , $ description ) ; }
4721	public function processListItems ( Text $ list , array $ options = array ( ) , $ level = 0 ) { $ list -> replace ( '/\n{2,}\z/' , "\n" ) ; $ list -> replace ( '{ (\n)? # leading line = $1 (^[ \t]*) # leading whitespace = $2 (' . $ this -> getPattern ( ) . ') [ \t]+ # list marker = $3 ((?s:.+?) # list item text = $4 (\n{1,2})) (?= \n* (\z | \2 (' . $ this -> getPattern ( ) . ') [ \t]+)) }mx' , function ( Text $ w , Text $ leadingLine , Text $ ls , Text $ m , Text $ item ) use ( $ options , $ level ) { if ( ( string ) $ leadingLine || $ item -> match ( '/\n{2,}/' ) ) { $ this -> markdown -> emit ( 'outdent' , array ( $ item ) ) ; $ this -> markdown -> emit ( 'block' , array ( $ item ) ) ; } else { $ this -> markdown -> emit ( 'outdent' , array ( $ item ) ) ; $ this -> processList ( $ item , $ options , ++ $ level ) ; $ item -> rtrim ( ) ; $ this -> markdown -> emit ( 'inline' , array ( $ item ) ) ; } return $ this -> getRenderer ( ) -> renderListItem ( $ item ) . "\n" ; } ) ; }
7457	public function persist ( ObjectManager $ manager ) { foreach ( $ this -> entities as $ entity ) { $ manager -> persist ( $ entity ) ; } if ( $ this -> root ) { $ manager -> persist ( $ this -> root ) ; } }
8427	public static function get ( string $ class ) { if ( isset ( self :: $ controllers [ $ class ] ) === false ) { self :: $ controllers [ $ class ] = new $ class ( ) ; } return self :: $ controllers [ $ class ] ; }
8215	protected function getServerStats ( $ pattern = '' ) { $ stats = ( array ) $ this -> getPheanstalk ( ) -> stats ( ) ; if ( ! empty ( $ pattern ) ) { $ stats = array_filter ( $ stats , function ( $ key ) use ( $ pattern ) { return 1 === preg_match ( "/$pattern/i" , $ key ) ; } , ARRAY_FILTER_USE_KEY ) ; } ksort ( $ stats ) ; return $ stats ; }
6088	public function createMoodboard ( Moodboard $ moodboard ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'moodboard' => $ moodboard ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
4993	public function getActiveFormActual ( $ setDefault = true ) { $ key = null ; if ( ! empty ( $ this -> activeForms ) ) { $ key = $ this -> activeForms [ 0 ] ; } if ( ! isset ( $ key ) && $ setDefault ) { $ formsAvailable = array_keys ( $ this -> forms ) ; $ key = array_shift ( $ formsAvailable ) ; } return $ key ; }
2869	public function renderArray ( array $ data , $ noDataLabel = 'No Data' , $ header = null ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ html = $ block -> renderArray ( $ data , $ noDataLabel , $ header ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( $ html ) ; }
10275	public static function getTextWidthPixelsExact ( $ text , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font , $ rotation = 0 ) { if ( ! function_exists ( 'imagettfbbox' ) ) { throw new PhpSpreadsheetException ( 'GD library needs to be enabled' ) ; } $ fontFile = self :: getTrueTypeFontFileFromFont ( $ font ) ; $ textBox = imagettfbbox ( $ font -> getSize ( ) , $ rotation , $ fontFile , $ text ) ; $ lowerLeftCornerX = $ textBox [ 0 ] ; $ lowerRightCornerX = $ textBox [ 2 ] ; $ upperRightCornerX = $ textBox [ 4 ] ; $ upperLeftCornerX = $ textBox [ 6 ] ; $ textWidth = max ( $ lowerRightCornerX - $ upperLeftCornerX , $ upperRightCornerX - $ lowerLeftCornerX ) ; return $ textWidth ; }
11771	private function retryCommandOnFailure ( CommandInterface $ command , $ method ) { $ retries = 0 ; SENTINEL_RETRY : { try { $ response = $ this -> getConnectionByCommand ( $ command ) -> $ method ( $ command ) ; } catch ( CommunicationException $ exception ) { $ this -> wipeServerList ( ) ; $ exception -> getConnection ( ) -> disconnect ( ) ; if ( $ retries == $ this -> retryLimit ) { throw $ exception ; } usleep ( $ this -> retryWait * 1000 ) ; ++ $ retries ; goto SENTINEL_RETRY ; } } return $ response ; }
6248	public function getAll ( ) { $ permissions = $ this -> modules -> getAllPermissions ( ) ; $ permissions = array_merge ( $ permissions , $ this -> getCustom ( ) ) ; return array_unique ( $ permissions ) ; }
12962	public function getTables ( ) { $ tables = $ this -> getDb ( ) -> getAllTables ( ) ; $ return = array ( ) ; foreach ( $ tables as $ name => $ table ) { foreach ( $ table as $ key => $ value ) { $ return [ $ table [ $ key ] ] = $ table [ $ key ] ; } } return $ return ; }
10630	public static function memory ( ) { $ memory = new \ StdClass ( ) ; $ memory -> real = new \ StdClass ( ) ; $ memory -> swap = new \ StdClass ( ) ; if ( false !== ( $ data = @ file ( '/proc/meminfo' ) ) ) { $ data = implode ( "" , $ data ) ; preg_match_all ( "/MemTotal\s{0,}\:+\s{0,}([\d\.]+).+?MemFree\s{0,}\:+\s{0,}([\d\.]+).+?Cached\s{0,}\:+\s{0,}([\d\.]+).+?SwapTotal\s{0,}\:+\s{0,}([\d\.]+).+?SwapFree\s{0,}\:+\s{0,}([\d\.]+)/s" , $ data , $ meminfo ) ; preg_match_all ( "/Buffers\s{0,}\:+\s{0,}([\d\.]+)/s" , $ data , $ buffers ) ; $ memory -> total = $ meminfo [ 1 ] [ 0 ] * 1024 ; $ memory -> free = $ meminfo [ 2 ] [ 0 ] * 1024 ; $ memory -> used = $ memory -> total - $ memory -> free ; $ memory -> cached = $ meminfo [ 3 ] [ 0 ] * 1024 ; $ memory -> buffers = $ buffers [ 1 ] [ 0 ] * 1024 ; $ memory -> real -> used = $ memory -> total - $ memory -> free - $ memory -> cached - $ memory -> buffers ; $ memory -> real -> free = $ memory -> total - $ memory -> real -> used ; $ memory -> swap -> free = $ meminfo [ 5 ] [ 0 ] * 1024 ; $ memory -> swap -> used = $ meminfo [ 4 ] [ 0 ] * 1024 - $ memory -> swap -> free ; } return $ memory ; }
146	protected function moveWatch ( $ fromLiteral , $ toLiteral , $ node ) { if ( ! isset ( $ this -> watchChains [ $ toLiteral ] ) ) { $ this -> watchChains [ $ toLiteral ] = new RuleWatchChain ; } $ node -> moveWatch ( $ fromLiteral , $ toLiteral ) ; $ this -> watchChains [ $ fromLiteral ] -> remove ( ) ; $ this -> watchChains [ $ toLiteral ] -> unshift ( $ node ) ; }
8392	public function routes ( Request $ request ) { $ table = new \ cli \ Table ( ) ; $ table -> setHeaders ( [ 'Type' , 'Subdomain' , 'Method' , 'Path' , 'Action' ] ) ; $ rows = [ ] ; $ routes = Http :: getRoutes ( ) ; usort ( $ routes , function ( array $ a , array $ b ) { if ( $ a [ 'subdomain' ] != $ b [ 'subdomain' ] ) { return strcmp ( $ a [ 'subdomain' ] , $ b [ 'subdomain' ] ) ; } if ( $ a [ 'path' ] != $ a [ 'path' ] ) { return strcmp ( $ a [ 'path' ] , $ b [ 'path' ] ) ; } return strcmp ( $ a [ 'method' ] , $ b [ 'method' ] ) ; } ) ; foreach ( $ routes as $ route ) { $ rows [ ] = [ $ route [ 'type' ] , $ route [ 'subdomain' ] , $ route [ 'method' ] , empty ( $ route [ 'uri' ] ) === false ? '/' . ltrim ( rtrim ( $ route [ 'uri' ] , '/' ) , '/' ) . $ route [ 'path' ] : $ route [ 'path' ] , $ route [ 'action' ] [ 0 ] == '\\' ? $ route [ 'action' ] : rtrim ( $ route [ 'namespace' ] , '\\' ) . '\\' . $ route [ 'action' ] , ] ; } $ table -> setRows ( $ rows ) ; $ table -> display ( ) ; }
4253	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method == 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method == 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { if ( isset ( $ meta [ 'file' ] ) ) { $ args [ ] = $ meta [ 'file' ] . ': line ' . $ meta [ 'line' ] ; } } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ k => $ arg ) { $ args [ $ k ] = \ json_encode ( $ this -> dump ( $ arg ) ) ; } $ str = 'console.' . $ method . '(' . \ implode ( ',' , $ args ) . ');' . "\n" ; $ str = \ str_replace ( \ json_encode ( $ this -> debug -> abstracter -> UNDEFINED ) , 'undefined' , $ str ) ; return $ str ; }
8508	public function getPrepInstructionsForASIN ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForASINRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForASINRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForASIN' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForASINResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11763	public function replace ( $ needle , $ replacement ) : Pipeline { $ stages = [ ] ; $ found = false ; foreach ( $ this -> stages as $ stage ) { if ( $ this -> matches ( $ stage , $ needle ) ) { $ stages [ ] = $ replacement ; $ found = true ; continue ; } $ stages [ ] = $ stage ; } if ( $ found ) { $ pipeline = clone $ this ; $ pipeline -> stages = $ stages ; return $ pipeline ; } unset ( $ stages ) ; return $ this ; }
1816	public function pagePicker ( Contao \ DataContainer $ dc ) { @ trigger_error ( 'Using tl_content::pagePicker() has been deprecated and will no longer work in Contao 5.0. Set the "dcaPicker" eval attribute instead.' , E_USER_DEPRECATED ) ; return Contao \ Backend :: getDcaPickerWizard ( true , $ dc -> table , $ dc -> field , $ dc -> inputName ) ; }
2600	public function peek ( ) { if ( isset ( $ this -> tokens [ $ this -> position + $ this -> peek ] ) ) { return $ this -> tokens [ $ this -> position + $ this -> peek ++ ] ; } else { return null ; } }
2064	public function checkFeedAlias ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == $ dc -> value || $ varValue == '' ) { return $ varValue ; } $ varValue = Contao \ StringUtil :: standardize ( $ varValue ) ; $ this -> import ( 'Contao\Automator' , 'Automator' ) ; $ arrFeeds = $ this -> Automator -> purgeXmlFiles ( true ) ; if ( \ in_array ( $ varValue , $ arrFeeds ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
413	public function setPort ( $ value ) { if ( $ value != $ this -> _port ) { $ this -> _port = ( int ) $ value ; $ this -> _hostInfo = null ; } }
5850	protected function buildForm ( array $ row ) { $ record = [ 'uid' => static :: virtualRecordId , 'pid' => 0 , ] ; $ record = array_merge ( $ record , $ row ) ; $ dataProviders = & $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'formEngine' ] [ 'formDataGroup' ] [ 'tcaDatabaseRecord' ] ; $ dataProviders [ \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: class ] = [ 'before' => [ \ TYPO3 \ CMS \ Backend \ Form \ FormDataProvider \ DatabaseEditRow :: class , ] ] ; \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: initialize ( $ record ) ; $ formDataGroup = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormDataGroup \ TcaDatabaseRecord :: class ) ; $ formDataCompiler = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormDataCompiler :: class , $ formDataGroup ) ; $ nodeFactory = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ NodeFactory :: class ) ; $ formDataCompilerInput = [ 'tableName' => static :: virtualTable , 'vanillaUid' => $ record [ 'uid' ] , 'command' => 'edit' , 'returnUrl' => '' , ] ; $ this -> loadVirtualTca ( ) ; $ formData = $ formDataCompiler -> compile ( $ formDataCompilerInput ) ; $ formData [ 'renderType' ] = 'outerWrapContainer' ; $ formResult = $ nodeFactory -> create ( $ formData ) -> render ( ) ; $ html = preg_replace ( '/<h1>.*<\/h1>/' , '' , $ formResult [ 'html' ] ) ; $ startFooter = strrpos ( $ html , '<div class="help-block text-right">' ) ; $ endTag = '</div>' ; if ( $ startFooter !== false ) { $ endFooter = strpos ( $ html , $ endTag , $ startFooter ) ; $ html = substr ( $ html , 0 , $ startFooter ) . substr ( $ html , $ endFooter + strlen ( $ endTag ) ) ; } $ formResult [ 'html' ] = '' ; $ formResult [ 'doSaveFieldName' ] = 'doSave' ; $ this -> formResultCompiler -> mergeResult ( $ formResult ) ; $ formContent = ' <!-- EDITING FORM . $ html . ' <input type="hidden" name="returnUrl" value="' . htmlspecialchars ( $ this -> retUrl ) . '" /> <input type="hidden" name="closeDoc" value="0" /> <input type="hidden" name="doSave" value="0" /> <input type="hidden" name="_serialNumber" value="' . md5 ( microtime ( ) ) . '" /> <input type="hidden" name="_scrollPosition" value="" />' ; $ overriddenAjaxUrl = GeneralUtility :: quoteJSvalue ( BackendUtility :: getModuleUrl ( 'TxImageAutoresize::record_flex_container_add' ) ) ; $ formContent .= <<<HTML<script type="text/javascript"> TYPO3.settings.ajaxUrls['record_flex_container_add'] = $overriddenAjaxUrl;</script>HTML ; return $ formContent ; }
1533	protected function isFillableRelation ( $ field , $ record ) { return $ this -> isRelation ( $ field ) && $ this -> isFillable ( $ field , $ record ) ; }
2187	public function fetchByAlias ( $ strTable , $ strAlias , $ varValue ) { if ( isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ) { $ strPk = $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ; if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ strPk ] ) ) { return $ this -> arrRegistry [ $ strTable ] [ $ strPk ] ; } } return null ; }
4295	public function alert ( $ message , $ class = 'danger' , $ dismissible = false ) { array ( $ class , $ dismissible ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'message' => null , 'class' => 'danger' , 'dismissible' => false , ) , array ( 'class' , 'dismissible' ) ) ; \ extract ( $ args ) ; $ this -> setLogDest ( 'alerts' ) ; $ this -> appendLog ( 'alert' , array ( $ message ) , $ meta ) ; $ this -> setLogDest ( 'auto' ) ; }
10188	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> name ) ) $ this -> name = $ xmlElement -> name ; if ( isset ( $ xmlElement -> active ) ) $ this -> active = $ xmlElement -> active ; if ( isset ( $ xmlElement -> anonymizable ) ) $ this -> anonymizable = $ xmlElement -> anonymizable ; if ( isset ( $ xmlElement -> description ) ) $ this -> description = $ xmlElement -> description ; if ( isset ( $ xmlElement -> created ) ) $ this -> created = $ xmlElement -> created ; if ( isset ( $ xmlElement -> updated ) ) $ this -> updated = $ xmlElement -> updated ; if ( isset ( $ xmlElement -> attributes ) ) { $ this -> attributes = array ( ) ; foreach ( $ xmlElement -> attributes -> children ( ) as $ xmlAttribute ) { $ attribute = array ( ) ; if ( isset ( $ xmlAttribute -> name ) ) $ attribute [ 'name' ] = trim ( $ xmlAttribute -> name ) ; if ( isset ( $ xmlAttribute -> datatype ) ) $ attribute [ 'datatype' ] = DataType :: getDataType ( $ xmlAttribute -> datatype ) ; if ( isset ( $ xmlAttribute -> description ) ) $ attribute [ 'description' ] = trim ( $ xmlAttribute -> description ) ; if ( isset ( $ xmlAttribute -> required ) ) $ attribute [ 'required' ] = $ xmlAttribute -> required ; array_push ( $ this -> attributes , $ attribute ) ; } } }
10806	protected function getConfig ( ) { $ config = array_replace ( $ this -> config , $ this -> dialect_config ) ; ksort ( $ config ) ; return $ config ; }
8687	public static function replaceRecursive ( $ iterable1 , $ iterable2 ) { Assert :: allIsIterable ( [ $ iterable1 , $ iterable2 ] ) ; if ( $ iterable1 instanceof Traversable ) { $ iterable1 = iterator_to_array ( $ iterable1 ) ; } if ( $ iterable2 instanceof Traversable ) { $ iterable2 = iterator_to_array ( $ iterable2 ) ; } $ merged = $ iterable1 ; foreach ( $ iterable2 as $ key => $ value ) { if ( $ value instanceof Traversable ) { $ value = iterator_to_array ( $ value ) ; } if ( is_array ( $ value ) && static :: isAssociative ( $ value ) && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { $ merged [ $ key ] = static :: replaceRecursive ( $ merged [ $ key ] , $ value ) ; } elseif ( $ value === null && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { if ( $ merged [ $ key ] instanceof Traversable ) { $ merged [ $ key ] = iterator_to_array ( $ merged [ $ key ] ) ; } continue ; } else { $ merged [ $ key ] = $ value ; } } return $ merged ; }
6256	public function searchPickupPointsByText ( $ query_text , $ service_provider = null , $ limit = 5 ) { if ( $ query_text == null || trim ( $ query_text ) == '' ) { return '[]' ; } $ post_params = array ( 'query' => ( string ) $ query_text , 'service_provider' => ( string ) $ service_provider , 'limit' => ( int ) $ limit ) ; return $ this -> doPost ( '/pickup-points/search' , $ post_params ) ; }
9325	protected function registerMarkdown ( ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown' , function ( $ app ) { return new Converter ( $ app [ 'commonmark.docparser' ] , $ app [ 'commonmark.htmlrenderer' ] ) ; } ) ; $ app -> alias ( 'markdown' , Converter :: class ) ; }
7895	public function extend ( $ provider , Closure $ callback ) { if ( $ this -> isProviderAliasExists ( $ provider ) ) { throw new InvalidArgumentException ( "Alias provider is already reserved [{$provider}]" ) ; } $ this -> customProviders [ $ provider ] = $ callback ; return $ this ; }
2676	public function upsertAclItem ( $ aclId , $ itemValue , $ negated , $ comment = 'Added by Magento Module' , $ subnet = false ) { $ body = [ 'ip' => $ itemValue , 'negated' => $ negated , 'comment' => $ comment ] ; if ( $ subnet ) { $ body [ 'subnet' ] = $ subnet ; } $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: POST , $ body ) ; return $ result ; }
5327	public function end ( string $ profile ) { Craft :: endProfile ( $ profile , Craft :: t ( 'twig-profiler' , self :: CATEGORY_PREFIX ) . TwigProfiler :: $ renderingTemplate ) ; }
3630	protected function validateItems ( array $ items , $ type ) { foreach ( $ items as $ item ) { $ this -> validateItem ( $ item , $ type ) ; } }
9625	public function getById ( $ characterId ) { try { $ result = $ this -> client -> get ( $ this -> slug . '/' . $ characterId ) ; } catch ( RequestException $ e ) { $ return [ 'request' ] = $ e -> getRequest ( ) . "\n" ; if ( $ e -> hasResponse ( ) ) { return $ return [ 'response' ] = $ e -> getResponse ( ) . "\n" ; } } return $ result -> json ( ) ; }
2007	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; if ( $ exception -> getPrevious ( ) instanceof ResourceNotFoundException && ! $ this -> hasRootPages ( ) ) { $ exception = new NoRootPageFoundException ( 'No root page found' , 0 , $ exception ) ; } $ class = $ this -> getTargetClass ( $ exception ) ; if ( null === $ class ) { return ; } if ( null !== ( $ httpException = $ this -> convertToHttpException ( $ exception , $ class ) ) ) { $ event -> setException ( $ httpException ) ; } }
5965	public function channelGroupPermList ( $ cgid , $ permsid = false ) { return $ this -> execute ( "channelgrouppermlist" , array ( "cgid" => $ cgid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
284	private function getFixturesConfig ( $ fixtures ) { $ config = [ ] ; foreach ( $ fixtures as $ fixture ) { $ isNamespaced = ( strpos ( $ fixture , '\\' ) !== false ) ; $ fixture = str_replace ( '/' , '\\' , $ fixture ) ; $ fullClassName = $ isNamespaced ? $ fixture : $ this -> namespace . '\\' . $ fixture ; if ( class_exists ( $ fullClassName ) ) { $ config [ ] = $ fullClassName ; } elseif ( class_exists ( $ fullClassName . 'Fixture' ) ) { $ config [ ] = $ fullClassName . 'Fixture' ; } } return $ config ; }
11646	private function generateExecuteDocBlock ( $ methodDescription , $ returnType ) { $ docBlock = new DocBlockGenerator ( $ methodDescription , null ) ; $ tags [ ] = new GenericTag ( 'return' , $ returnType ) ; $ docBlock -> setTags ( $ tags ) ; return $ docBlock ; }
10839	protected function deleteRaw ( $ Key ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; if ( file_exists ( $ CacheFile ) ) { return unlink ( $ CacheFile ) ; } return true ; }
11934	public function walk ( Callable $ callback ) { $ arrayCopy = $ this -> getArrayCopy ( ) ; $ result = array_walk ( $ arrayCopy , $ callback ) ; $ this -> exchangeArray ( $ arrayCopy ) ; return $ result ; }
4712	public function escapeHtml ( $ option = ENT_QUOTES ) { $ this -> text = htmlspecialchars ( $ this -> text , $ option , 'UTF-8' , false ) ; return $ this ; }
2584	public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ qPassErrors = "//m:passengerErrorInEnhancedData//m:errorDetails/m:errorCode" ; $ qPassErrorCat = "//m:passengerErrorInEnhancedData//m:errorDetails/m:errorCategory" ; $ qPassErrorMsg = "//m:passengerErrorInEnhancedData//m:freeText" ; $ errorCodeNodeList = $ domXpath -> query ( $ qPassErrors ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ errorCatNode = $ domXpath -> query ( $ qPassErrorCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( $ qPassErrorMsg ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'passenger' ) ; } if ( empty ( $ analyzeResponse -> messages ) && $ analyzeResponse -> status === Result :: STATUS_OK ) { $ analyzeResponse = $ this -> analyzeSimpleResponseErrorCodeAndMessage ( $ response ) ; } return $ analyzeResponse ; }
3075	public function process ( ) { $ this -> validate ( ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> pause ( $ serviceContext ) ; $ response = [ 'success' => $ result ] ; } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
657	public function release ( $ name ) { if ( $ this -> releaseLock ( $ name ) ) { $ index = array_search ( $ name , $ this -> _locks ) ; if ( $ index !== false ) { unset ( $ this -> _locks [ $ index ] ) ; } return true ; } return false ; }
941	public function getPath ( ) { if ( null === $ this -> path ) { $ filesystem = new Filesystem ( ) ; $ cwd = $ this -> cwd ; if ( 1 === \ count ( $ this -> options [ 'path' ] ) && '-' === $ this -> options [ 'path' ] [ 0 ] ) { $ this -> path = $ this -> options [ 'path' ] ; } else { $ this -> path = array_map ( static function ( $ path ) use ( $ cwd , $ filesystem ) { $ absolutePath = $ filesystem -> isAbsolutePath ( $ path ) ? $ path : $ cwd . \ DIRECTORY_SEPARATOR . $ path ; if ( ! file_exists ( $ absolutePath ) ) { throw new InvalidConfigurationException ( sprintf ( 'The path "%s" is not readable.' , $ path ) ) ; } return $ absolutePath ; } , $ this -> options [ 'path' ] ) ; } } return $ this -> path ; }
2700	private function upgrade1010 ( $ newConfigPaths ) { $ oldData = $ this -> scopeConfig -> getValue ( $ newConfigPaths [ 'geoip_country_mapping' ] ) ; try { $ oldData = unserialize ( $ oldData ) ; } catch ( \ Exception $ e ) { $ oldData = [ ] ; } $ oldData = ( is_array ( $ oldData ) ) ? $ oldData : [ ] ; $ newData = json_encode ( $ oldData ) ; if ( false === $ newData ) { throw new \ InvalidArgumentException ( 'Unable to encode data.' ) ; } $ this -> configWriter -> save ( $ newConfigPaths [ 'geoip_country_mapping' ] , $ newData ) ; $ this -> cacheManager -> clean ( [ \ Magento \ Framework \ App \ Cache \ Type \ Config :: TYPE_IDENTIFIER ] ) ; }
6841	public function getCache ( $ key ) { return isset ( $ this -> caches [ $ key ] ) ? $ this -> caches [ $ key ] : null ; }
9065	protected function checkMVC ( ) { $ viewResolver = $ this -> sm -> get ( 'ViewResolver' ) ; $ return = true ; if ( $ viewResolver instanceof ViewResolver \ AggregateResolver ) { if ( $ viewResolver -> count ( ) == 2 ) { $ defResolvers = array ( 'Zend\View\Resolver\TemplateMapResolver' , 'Zend\View\Resolver\TemplatePathStack' ) ; foreach ( $ viewResolver -> getIterator ( ) -> toArray ( ) as $ i => $ ro ) { if ( $ defResolvers [ $ i ] != get_class ( $ ro ) ) { $ return = false ; break ; } } } else { $ return = false ; } } else { $ return = false ; } $ viewTemplatePathStack = $ this -> sm -> get ( 'ViewTemplatePathStack' ) ; if ( ! $ viewTemplatePathStack instanceof ViewResolver \ TemplatePathStack ) { throw new \ Exception ( 'yimaTheme work with PathStack' ) ; } return $ return ; }
6849	public static function months ( $ format = null ) { $ months = array ( ) ; if ( $ format === static :: MONTHS_LONG || $ format === static :: MONTHS_SHORT ) { for ( $ i = 1 ; $ i <= 12 ; ++ $ i ) { $ months [ $ i ] = strftime ( $ format , mktime ( 0 , 0 , 0 , $ i , 1 ) ) ; } } else { $ months = static :: hours ( ) ; } return $ months ; }
11329	public function getHuman ( ) { if ( is_null ( $ this -> _human ) ) { $ this -> _human = HumanFieldDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _human ; }
7238	protected function fixDeliveryDefault ( CustomerAddressInterface $ address ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ address , [ 'deliveryDefault' ] ) ) { return ; } $ customer = $ address -> getCustomer ( ) ; if ( $ address -> isDeliveryDefault ( ) ) { foreach ( $ customer -> getAddresses ( ) as $ a ) { if ( $ a === $ address ) { continue ; } if ( $ a -> isDeliveryDefault ( ) ) { $ a -> setDeliveryDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ a , false ) ; } } } elseif ( null === $ customer -> getDefaultDeliveryAddress ( true ) ) { $ address -> setDeliveryDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } }
11521	public function off ( $ eventType , $ listener = null ) { foreach ( $ this -> _eventListeners as $ i => $ l ) { if ( $ l -> getType ( ) == $ eventType ) { if ( $ listener === null || $ l -> getListener ( ) === $ listener ) { unset ( $ this -> _eventListeners [ $ i ] ) ; } } } }
11566	public function register ( string ... $ mods ) : void { $ this -> kms = array_unique ( array_merge ( $ this -> kms , $ mods ) ) ; }
11285	public function isPlaceholder ( $ attributeName ) { $ def = $ this -> model_attributes [ $ attributeName ] ; if ( isset ( $ def [ 'models' ] ) || ( isset ( $ def [ 'model' ] ) && isset ( $ def [ 'usesRefTable' ] ) ) ) { return true ; } return false ; }
12935	protected function resolveMoveOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'page' , 'language' , 'country' , 'sourceSlot' , 'position' , ) ) ; $ this -> optionsResolver -> setDefined ( array ( 'targetSlot' , 'blockname' , 'oldName' , 'newName' , 'slot' , ) ) ; $ this -> optionsResolver -> resolve ( $ options ) ; $ this -> optionsResolved = true ; }
6611	public function getFirstError ( $ attribute = null ) { if ( ! $ this -> errors ) { return null ; } elseif ( is_null ( $ attribute ) ) { $ errors = $ this -> getErrors ( ) ; reset ( $ errors ) ; $ firstError = current ( $ errors ) ; $ arrayKeys = array_keys ( $ firstError ) ; $ error = $ firstError [ $ arrayKeys [ 0 ] ] ; return $ error ; } return parent :: getFirstError ( $ attribute ) ; }
1775	protected function isChecked ( $ arrOption ) { if ( empty ( $ this -> varValue ) && empty ( $ _POST ) && $ arrOption [ 'default' ] ) { return static :: optionChecked ( 1 , 1 ) ; } return static :: optionChecked ( $ arrOption [ 'value' ] , $ this -> varValue ) ; }
6284	protected static function buildHttpClient05 ( LoopInterface $ loop , $ connector = null ) { if ( $ connector instanceof DnsResolver ) { @ trigger_error ( sprintf ( 'Passing a %s to buildHttpClient is deprecated since version 2.1.0 and will be removed in 3.0. If you need no specific behaviour, omit the $dns argument, otherwise pass a %s' , DnsResolver :: class , ConnectorInterface :: class ) , E_USER_DEPRECATED ) ; $ connector = static :: buildConnector ( $ loop , $ connector ) ; } if ( null !== $ connector && ! $ connector instanceof ConnectorInterface ) { throw new \ InvalidArgumentException ( '$connector must be an instance of DnsResolver or ConnectorInterface' ) ; } return new HttpClient ( $ loop , $ connector ) ; }
11116	public function drop ( ) : void { $ dropped = $ this -> repository -> drop ( ) ; if ( count ( $ dropped ) === 0 ) { return ; } $ this -> notify -> note ( '' ) ; foreach ( $ dropped as [ $ type , $ value ] ) { $ type = ucfirst ( $ type ) ; $ this -> notify -> note ( "<comment>{$type}</comment> \"{$value}\" <comment>dropped</comment>" ) ; } }
9188	public function connect ( ) { if ( ! is_resource ( $ this -> handle ) ) { throw new SocketException ( "Socket is not available" ) ; } if ( ! @ socket_connect ( $ this -> handle , $ this -> endpoint -> getAddress ( ) , $ this -> endpoint -> getPort ( ) ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ this -> conntected = true ; }
1461	protected function orderAsc ( ) { $ this -> query -> orderBy ( $ this -> column ) ; if ( $ this -> isNotPagingOnKey ( ) ) { $ this -> query -> orderBy ( $ this -> key ) ; } return $ this ; }
6276	protected function readInt31 ( $ pos = 0 ) { $ uint31 = $ this -> readInt32 ( $ pos ) ; if ( $ uint31 > 0x7fffffff ) { throw new Exception ( 'Error in CDB file "' . $ this -> fileName . '", integer too big.' ) ; } return $ uint31 ; }
2988	public function hasResourceInAnnotation ( $ bundle ) { if ( ! file_exists ( $ this -> file ) ) { return false ; } $ config = Yaml :: parse ( file_get_contents ( $ this -> file ) ) ; $ search = sprintf ( '@%s/Controller/' , $ bundle ) ; foreach ( $ config as $ resource ) { if ( array_key_exists ( 'resource' , $ resource ) ) { return $ resource [ 'resource' ] === $ search ; } } return false ; }
11940	public function getUrl ( string $ sCode , array $ aParams = array ( ) ) : string { if ( isset ( $ _SERVER ) && isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { foreach ( Config :: get ( 'route' ) as $ sHost => $ oHost ) { if ( ( ! strstr ( $ sHost , '/' ) && $ sHost == $ _SERVER [ 'HTTP_HOST' ] ) || ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) ) { if ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) { $ this -> _sBaseUri = preg_replace ( '#^[^/]+#' , '' , $ sHost ) ; } if ( isset ( $ oHost -> routes ) ) { foreach ( $ oHost -> routes as $ sKey => $ oRoute ) { if ( $ sKey === $ sCode ) { $ sRoute = $ this -> _sBaseUri . $ oRoute -> route ; if ( isset ( $ oRoute -> constraints ) ) { foreach ( $ oRoute -> constraints as $ sName => $ sType ) { if ( ! isset ( $ aParams [ $ sName ] ) ) { $ aParams [ $ sName ] = '' ; } if ( preg_match ( '#' . $ sType . '#' , $ aParams [ $ sName ] ) ) { if ( $ aParams [ $ sName ] ) { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '/' . $ aParams [ $ sName ] , $ sRoute ) ; } else { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '' , $ sRoute ) ; } $ sRoute = str_replace ( '[:' . $ sName . ']' , $ aParams [ $ sName ] , $ sRoute ) ; continue ; } else if ( isset ( $ oRoute -> defaults_constraints ) && isset ( $ oRoute -> defaults_constraints -> { $ sName } ) && preg_match ( '#' . $ sType . '#' , $ oRoute -> defaults_constraints -> { $ sName } ) ) { continue ; } throw new \ Exception ( 'For the route ' . $ sCode . ' the parameter ' . $ sName . ' is not good!' ) ; } } return $ sRoute ; } } } } } } }
6166	protected function writeProgress ( $ progress ) { $ this -> progress = ! $ this -> flawless && $ progress === '.' ? $ this -> formatWithColor ( 'fg-red' , '!' ) : $ progress ; ++ $ this -> numTestsRun ; }
8191	public function actionConfirm ( $ id , $ code ) { $ user = UserIdentity :: findByActivationToken ( $ id , $ code ) ; if ( $ user == NULL ) throw new NotFoundHttpException ; if ( ! empty ( $ user ) ) { $ user -> activation_token = NULL ; $ user -> status = User :: STATUS_ACTIVE ; $ user -> save ( FALSE ) ; Yii :: $ app -> session -> setFlash ( 'success' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' has successfully been activated' ) ) ; } else Yii :: $ app -> session -> setFlash ( 'error' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' could not been activated. Please contact the Administrator' ) ) ; return $ this -> render ( 'confirm' , [ 'user' => $ user ] ) ; }
4636	public function send ( $ email , array $ options = [ ] ) : ResultInterface { if ( is_string ( $ email ) ) { $ email = $ this -> emailBuilder -> build ( $ email , $ options ) ; } elseif ( is_array ( $ email ) ) { $ email = $ this -> emailBuilder -> build ( Email :: class , $ email ) ; } elseif ( ! $ email instanceof Email ) { throw Exception \ InvalidArgumentException :: fromValidTypes ( [ 'string' , 'array' , Email :: class ] , $ email , 'email' ) ; } $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_PRE_RENDER ) ) ; $ this -> renderEmailBody ( $ email ) ; $ eventResp = $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_PRE_SEND ) ) ; if ( $ eventResp -> contains ( false ) ) { return new MailResult ( $ email , false ) ; } try { $ message = MessageFactory :: createMessageFromEmail ( $ email ) -> setBody ( $ this -> buildBody ( $ email -> getBody ( ) , $ email -> getCharset ( ) ) ) ; $ this -> attachFiles ( $ message , $ email ) ; $ this -> addCustomHeaders ( $ message , $ email ) ; $ this -> transport -> send ( $ message ) ; $ result = new MailResult ( $ email ) ; $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_POST_SEND , $ result ) ) ; return $ result ; } catch ( Throwable $ e ) { $ this -> events -> triggerEvent ( $ this -> createMailEvent ( $ email , MailEvent :: EVENT_MAIL_SEND_ERROR , new MailResult ( $ email , false , $ e ) ) ) ; throw new Exception \ MailException ( 'An error occurred while trying to send the email' , $ e -> getCode ( ) , $ e ) ; } }
3931	private function getOrCreateProperty ( PropertiesDefinitionInterface $ definition , $ propName ) { if ( $ definition -> hasProperty ( $ propName ) ) { return $ definition -> getProperty ( $ propName ) ; } $ property = new DefaultProperty ( $ propName ) ; $ definition -> addProperty ( $ property ) ; return $ property ; }
8352	public function handle ( int $ signal ) { if ( isset ( $ this -> handlers [ $ signal ] ) && $ this -> handlers [ $ signal ] === true ) { return new Failure ( new Exception ( 'Signal is already being processed.' ) ) ; } $ this -> handlers [ $ signal ] = true ; $ this -> dispatcher -> setIsRunning ( false ) ; $ fn = $ this -> signals [ $ signal ] ; $ result = $ this -> $ fn ( ) ; if ( $ result === true ) { unset ( $ this -> handlers [ $ signal ] ) ; return new Success ( $ result ) ; } $ deferred = new Deferred ; Loop :: repeat ( 1000 , function ( $ watcherId , $ callback ) use ( $ deferred , $ signal , $ result ) { if ( count ( $ this -> dispatcher -> getProcesses ( ) ) === 0 ) { Loop :: cancel ( $ watcherId ) ; unset ( $ this -> handlers [ $ signal ] ) ; return $ deferred -> resolve ( $ result ) ; } } ) ; return $ deferred -> promise ( ) ; }
5685	protected function getUrlFromLink ( $ link ) { $ url = $ this -> expandUrl ( $ link -> getHref ( ) ) ; if ( $ link -> getAttribute ( 'target' ) ) { $ url -> setTarget ( $ link -> getAttribute ( 'target' ) ) ; } return $ url ; }
7672	function TbsLoadSubFileAsTemplate ( $ SubFileLst ) { if ( ! is_array ( $ SubFileLst ) ) $ SubFileLst = array ( $ SubFileLst ) ; $ ok = true ; $ TBS = false ; foreach ( $ SubFileLst as $ SubFile ) { $ idx = $ this -> FileGetIdx ( $ SubFile ) ; if ( $ idx === false ) { $ ok = $ this -> RaiseError ( 'Cannot load "' . $ SubFile . '". The file is not found in the archive "' . $ this -> ArchFile . '".' ) ; } elseif ( $ idx !== $ this -> TbsCurrIdx ) { $ this -> TbsStorePark ( ) ; if ( ! is_string ( $ SubFile ) ) $ SubFile = $ this -> TbsGetFileName ( $ idx ) ; $ this -> TbsStoreLoad ( $ idx , $ SubFile ) ; if ( $ this -> LastReadNotStored ) { if ( $ TBS === false ) { $ this -> TbsSwitchMode ( true ) ; $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ TBS = & $ this -> TBS ; } if ( $ this -> LastReadComp <= 0 ) { if ( $ this -> ExtInfo !== false ) { $ i = $ this -> ExtInfo ; $ e = $ this -> ExtEquiv ; if ( isset ( $ i [ 'rpl_what' ] ) ) { $ TBS -> Source = str_replace ( $ i [ 'rpl_what' ] , $ i [ 'rpl_with' ] , $ TBS -> Source ) ; } if ( ( $ e === 'odt' ) && $ TBS -> OtbsClearWriter ) { $ this -> OpenDoc_CleanRsID ( $ TBS -> Source ) ; } if ( ( $ e === 'ods' ) && $ TBS -> OtbsMsExcelCompatibility ) { $ this -> OpenDoc_MsExcelCompatibility ( $ TBS -> Source ) ; } if ( $ e === 'docx' ) { if ( $ TBS -> OtbsSpacePreserve ) $ this -> MsWord_CleanSpacePreserve ( $ TBS -> Source ) ; if ( $ TBS -> OtbsClearMsWord ) $ this -> MsWord_Clean ( $ TBS -> Source ) ; } if ( ( $ e === 'pptx' ) && $ TBS -> OtbsClearMsPowerpoint ) { $ this -> MsPowerpoint_Clean ( $ TBS -> Source ) ; } if ( ( $ e === 'xlsx' ) && $ TBS -> OtbsMsExcelConsistent ) { $ this -> MsExcel_DeleteFormulaResults ( $ TBS -> Source ) ; $ this -> MsExcel_ConvertToRelative ( $ TBS -> Source ) ; } } if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } } } } if ( $ TBS !== false ) $ this -> TbsSwitchMode ( false ) ; return $ ok ; }
1849	protected function generateLink ( $ strLink , $ objArticle , $ blnAddArchive = false , $ blnIsReadMore = false ) { if ( $ objArticle -> source != 'external' ) { return sprintf ( '<a href="%s" title="%s" itemprop="url"><span itemprop="headline">%s</span>%s</a>' , News :: generateNewsUrl ( $ objArticle , $ blnAddArchive ) , StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'readMore' ] , $ objArticle -> headline ) , true ) , $ strLink , ( $ blnIsReadMore ? '<span class="invisible"> ' . $ objArticle -> headline . '</span>' : '' ) ) ; } if ( substr ( $ objArticle -> url , 0 , 7 ) == 'mailto:' ) { $ strArticleUrl = StringUtil :: encodeEmail ( $ objArticle -> url ) ; } else { $ strArticleUrl = ampersand ( $ objArticle -> url ) ; } return sprintf ( '<a href="%s" title="%s"%s itemprop="url"><span itemprop="headline">%s</span></a>' , $ strArticleUrl , StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'open' ] , $ strArticleUrl ) ) , ( $ objArticle -> target ? ' target="_blank"' : '' ) , $ strLink ) ; }
9664	public static function registerReader ( $ readerType , $ readerClass ) { if ( ! is_a ( $ readerClass , Reader \ IReader :: class , true ) ) { throw new Reader \ Exception ( 'Registered readers must implement ' . Reader \ IReader :: class ) ; } self :: $ readers [ $ readerType ] = $ readerClass ; }
9689	static function getDataType ( $ value ) { switch ( $ value ) { case "string" : return self :: $ STRING ; case "double" : return self :: $ DOUBLE ; case "float" : return self :: $ FLOAT ; case "integer" : return self :: $ INTEGER ; case "boolean" : return self :: $ BOOLEAN ; case "timestamp" : return self :: $ TIMESTAMP ; case "json" : return self :: $ JSON ; default : return null ; } }
9486	protected function checkFieldsSet ( $ fields ) { foreach ( $ fields as $ field ) { if ( property_exists ( $ this , $ field ) && $ this -> $ field === null ) { throw new \ Exception ( "'$field' is required" ) ; } } }
12137	public function update ( QuestionRequest $ request , Question $ question ) { try { $ request = $ request -> all ( ) ; $ attributes [ 'title' ] = $ request [ 'title' ] ; $ attributes [ 'question' ] = $ request [ 'question' ] ; $ attributes [ 'category_id' ] = $ request [ 'category_id' ] ; $ question -> update ( $ attributes ) ; return redirect ( '/discussion/' . $ request [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/question/' . $ question -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
714	public function float ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_FLOAT , $ precision ) ; }
121	private function createAuthFromConfig ( ) { if ( ! $ this -> config -> has ( 'http-basic' ) ) { return $ this -> hasAuth = false ; } $ authConfig = $ this -> config -> get ( 'http-basic' ) ; $ host = parse_url ( $ this -> url , PHP_URL_HOST ) ; if ( isset ( $ authConfig [ $ host ] ) ) { $ this -> credentials [ 'username' ] = $ authConfig [ $ host ] [ 'username' ] ; $ this -> credentials [ 'password' ] = $ authConfig [ $ host ] [ 'password' ] ; return $ this -> hasAuth = true ; } return $ this -> hasAuth = false ; }
12103	private function phpSizeToBytes ( $ size ) { if ( is_numeric ( $ size ) ) { return $ size ; } $ suffix = substr ( $ size , - 1 ) ; $ value = substr ( $ size , 0 , - 1 ) ; switch ( strtolower ( $ suffix ) ) { case 'p' : $ value *= 1024 ; case 't' : $ value *= 1024 ; case 'g' : $ value *= 1024 ; case 'm' : $ value *= 1024 ; case 'k' : $ value *= 1024 ; break ; } return $ value ; }
11801	public function hookTemplateRender ( $ templates , $ data , $ rendered , $ controller ) { $ template = reset ( $ templates ) ; if ( strpos ( $ template , '/modules/ga_report/templates/panels/' ) !== false && isset ( $ data [ 'content' ] [ 'data' ] [ 'report' ] [ 'data' ] ) && isset ( $ data [ 'content' ] [ 'data' ] [ 'handler' ] [ 'id' ] ) ) { $ handler_id = $ data [ 'content' ] [ 'data' ] [ 'handler' ] [ 'id' ] ; $ controller -> setJsSettings ( "ga_chart_$handler_id" , $ data [ 'content' ] [ 'data' ] [ 'report' ] [ 'data' ] ) ; $ controller -> setJs ( __DIR__ . "/js/handlers/$handler_id.js" ) ; $ controller -> setJs ( __DIR__ . "/js/common.js" ) ; } }
5935	public function setGroups ( array $ groups ) { $ this -> groups = [ ] ; foreach ( $ groups as $ item ) { $ this -> addGroup ( $ item ) ; } return $ this ; }
3767	private function getOptions ( $ attribute , $ onlyUsed ) { $ options = [ ] ; foreach ( $ attribute -> getFilterOptions ( null , $ onlyUsed ) as $ key => $ value ) { $ value = trim ( strip_tags ( $ value ) ) ; if ( ! empty ( $ value ) ) { $ options [ $ key ] = $ value ; } } return $ options ; }
4124	private function generateProxyClass ( $ class , $ fileName , $ template ) { $ methods = $ this -> generateMethods ( $ class ) ; $ sleepImpl = $ this -> generateSleep ( $ class ) ; $ placeholders = array ( '<namespace>' , '<proxyClassName>' , '<className>' , '<methods>' , '<sleepImpl>' ) ; $ className = ltrim ( $ class -> name , '\\' ) ; $ proxyClassName = ClassUtils :: generateProxyClassName ( $ class -> name , $ this -> proxyNamespace ) ; $ parts = explode ( '\\' , strrev ( $ proxyClassName ) , 2 ) ; $ proxyClassNamespace = strrev ( $ parts [ 1 ] ) ; $ proxyClassName = strrev ( $ parts [ 0 ] ) ; $ replacements = array ( $ proxyClassNamespace , $ proxyClassName , $ className , $ methods , $ sleepImpl ) ; $ template = str_replace ( $ placeholders , $ replacements , $ template ) ; file_put_contents ( $ fileName , $ template , LOCK_EX ) ; }
12712	public function getResolvedConcreteFlag ( $ abstract ) { if ( ! $ this -> hasResolvedConcrete ( $ abstract ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be an abstract class name which exists in resolved concrete stack." , __METHOD__ ) ) ; } return explode ( '|' , $ this -> resolved [ $ abstract ] [ 'flag' ] ) ; }
5073	private function createController ( ) : void { $ aFields = $ this -> getArguments ( ) ; $ aCreated = [ ] ; try { $ aModels = array_filter ( explode ( ',' , $ aFields [ 'MODEL_NAME' ] ) ) ; foreach ( $ aModels as $ sModel ) { $ aFields [ 'MODEL_NAME' ] = $ sModel ; $ this -> oOutput -> write ( 'Creating controller <comment>' . $ sModel . '</comment>... ' ) ; Factory :: model ( $ sModel , $ aFields [ 'MODEL_PROVIDER' ] ) ; $ sPath = static :: CONTROLLER_PATH . $ sModel . '.php' ; if ( file_exists ( $ sPath ) ) { throw new ControllerExistsException ( 'Controller "' . $ sModel . '" exists already at path "' . $ sPath . '"' ) ; } $ this -> createFile ( $ sPath , $ this -> getResource ( 'template/controller.php' , $ aFields ) ) ; $ aCreated [ ] = $ sPath ; $ this -> oOutput -> writeln ( '<info>done!</info>' ) ; } } catch ( \ Exception $ e ) { $ this -> oOutput -> writeln ( '<error>failed!</error>' ) ; if ( ! empty ( $ aCreated ) ) { $ this -> oOutput -> writeln ( '<error>Cleaning up - removing newly created controllers</error>' ) ; foreach ( $ aCreated as $ sPath ) { @ unlink ( $ sPath ) ; } } throw $ e ; } }
8592	public function setFilterOptions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FilterOptions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12122	public function setLastModified ( Request $ request , \ DateTime $ lastModified ) { $ this -> cache -> save ( $ this -> getCacheKeyRequest ( sha1 ( $ request -> getUri ( ) ) , 'lastmodified' ) , $ lastModified -> format ( 'r' ) ) ; foreach ( $ this -> itemIds as $ itemId => $ bool ) { $ key = $ this -> getCacheKeyItem ( $ itemId , 'uri' ) ; $ urisForItem = Option :: fromValue ( $ this -> cache -> fetch ( $ key ) , false ) -> getOrElse ( array ( ) ) ; $ urisForItem [ $ request -> getUri ( ) ] = $ bool ; $ this -> cache -> save ( $ key , $ urisForItem ) ; Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ request , $ itemId ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] "%s" is used on "%s".' , $ itemId , $ request -> getUri ( ) ) ) ; } ) ; } }
9524	public function deploy ( ) { $ pullRequest = getenv ( 'TRAVIS_PULL_REQUEST' ) ; $ branch = getenv ( 'TRAVIS_BRANCH' ) ; if ( ( int ) $ pullRequest >= 1 ) { die ( 'Not deploying pull requests.' . PHP_EOL ) ; } if ( ! array_key_exists ( $ branch , $ this -> branches ) ) { die ( 'Branch ' . $ branch . ' has no environment to deploy to.' . PHP_EOL ) ; } $ environment = $ this -> branches [ $ branch ] ; echo 'Downloading Deployer.phar...' . PHP_EOL ; passthru ( 'wget http://deployer.org/deployer.phar' ) ; echo 'Deploying...' . PHP_EOL ; $ deployCommand = 'php deployer.phar deploy' ; $ deployCommand .= ' ' . $ environment ; $ deployCommand .= $ this -> verbose ? ' -vvv' : '' ; passthru ( $ deployCommand ) ; }
343	protected function renderSortLinks ( ) { $ attributes = empty ( $ this -> attributes ) ? array_keys ( $ this -> sort -> attributes ) : $ this -> attributes ; $ links = [ ] ; foreach ( $ attributes as $ name ) { $ links [ ] = $ this -> sort -> link ( $ name , $ this -> linkOptions ) ; } return Html :: ul ( $ links , array_merge ( $ this -> options , [ 'encode' => false ] ) ) ; }
9862	private function writeSheetFormatPr ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'sheetFormatPr' ) ; if ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , 'true' ) ; $ objWriter -> writeAttribute ( 'defaultRowHeight' , StringHelper :: formatNumber ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) ) ) ; } else { $ objWriter -> writeAttribute ( 'defaultRowHeight' , '14.4' ) ; } if ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) == '1' || strtolower ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) ) == 'true' ) { $ objWriter -> writeAttribute ( 'zeroHeight' , '1' ) ; } if ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'defaultColWidth' , StringHelper :: formatNumber ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) ) ) ; } $ outlineLevelRow = 0 ; foreach ( $ pSheet -> getRowDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelRow ) { $ outlineLevelRow = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelRow' , ( int ) $ outlineLevelRow ) ; $ outlineLevelCol = 0 ; foreach ( $ pSheet -> getColumnDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelCol ) { $ outlineLevelCol = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelCol' , ( int ) $ outlineLevelCol ) ; $ objWriter -> endElement ( ) ; }
733	public function toArray ( array $ fields = [ ] , array $ expand = [ ] , $ recursive = true ) { $ data = [ ] ; foreach ( $ this -> resolveFields ( $ fields , $ expand ) as $ field => $ definition ) { $ attribute = is_string ( $ definition ) ? $ this -> $ definition : $ definition ( $ this , $ field ) ; if ( $ recursive ) { $ nestedFields = $ this -> extractFieldsFor ( $ fields , $ field ) ; $ nestedExpand = $ this -> extractFieldsFor ( $ expand , $ field ) ; if ( $ attribute instanceof Arrayable ) { $ attribute = $ attribute -> toArray ( $ nestedFields , $ nestedExpand ) ; } elseif ( is_array ( $ attribute ) ) { $ attribute = array_map ( function ( $ item ) use ( $ nestedFields , $ nestedExpand ) { if ( $ item instanceof Arrayable ) { return $ item -> toArray ( $ nestedFields , $ nestedExpand ) ; } return $ item ; } , $ attribute ) ; } } $ data [ $ field ] = $ attribute ; } if ( $ this instanceof Linkable ) { $ data [ '_links' ] = Link :: serialize ( $ this -> getLinks ( ) ) ; } return $ recursive ? ArrayHelper :: toArray ( $ data ) : $ data ; }
985	public function getCharge ( ) { if ( ! $ this -> chargeId ) { throw new Exception ( 'Can not get charge information without charge ID.' ) ; } return $ this -> api -> rest ( 'GET' , "/admin/{$this->plan->typeAsString(true)}/{$this->chargeId}.json" ) -> body -> { $ this -> plan -> typeAsString ( ) } ; }
4763	public function createUser ( ) { if ( false == $ this -> validateRegistrationOptin ( ) ) { if ( $ this -> getRequestParameter ( 'stoken' ) ) { \ OxidEsales \ Eshop \ Core \ Registry :: get ( \ OxidEsales \ Eshop \ Core \ UtilsView :: class ) -> addErrorToDisplay ( 'OEGDPROPTIN_CONFIRM_USER_REGISTRATION_OPTIN' , false , true ) ; \ OxidEsales \ Eshop \ Core \ Registry :: get ( \ OxidEsales \ Eshop \ Core \ UtilsView :: class ) -> addErrorToDisplay ( 'OEGDPROPTIN_CONFIRM_USER_REGISTRATION_OPTIN' , false , true , 'oegdproptin_userregistration' ) ; } } else { return parent :: createUser ( ) ; } }
6719	private function handleAuthorizeResponse ( $ response ) { $ status = ArrayHelper :: getValue ( $ response , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ code = ArrayHelper :: getValue ( $ response , 'data.code' ) ; if ( is_null ( $ code ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ code ; } else { $ message = ArrayHelper :: getValue ( $ response , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
2369	public static function splitFriendlyEmail ( $ strEmail ) { if ( strpos ( $ strEmail , '<' ) !== false ) { return array_map ( 'trim' , explode ( ' <' , str_replace ( '>' , '' , $ strEmail ) ) ) ; } elseif ( strpos ( $ strEmail , '[' ) !== false ) { return array_map ( 'trim' , explode ( ' [' , str_replace ( ']' , '' , $ strEmail ) ) ) ; } else { return array ( '' , $ strEmail ) ; } }
7852	protected function dispatchWorkflow ( $ workflow ) { $ job = $ this -> inflector -> getJob ( ) ; $ request = $ this -> resolveRequest ( ) ; $ pipes = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ parameters = $ this -> container -> make ( 'router' ) -> current ( ) -> parameters ( ) ; return $ this -> dispatcher -> pipeThrough ( $ pipes ) -> dispatchFrom ( $ job , $ request , $ parameters ) ; }
8463	public static function getProtocol ( $ url = false ) { if ( $ url ) { return ( preg_match ( '/^https/' , $ url ) ) ? 'https' : 'http' ; } $ protocol = strtolower ( $ _SERVER [ 'SERVER_PROTOCOL' ] ) ; $ protocol = substr ( $ protocol , 0 , strpos ( $ protocol , '/' ) ) ; $ ssl = ( isset ( $ _SERVER [ 'HTTPS' ] ) && $ _SERVER [ 'HTTPS' ] == 'on' ) ; return ( $ ssl ) ? $ protocol . 's' : $ protocol ; }
2429	public static function initializeApplication ( Event $ event ) : void { $ webDir = self :: getWebDir ( $ event ) ; static :: purgeCacheFolder ( ) ; static :: addAppDirectory ( ) ; static :: executeCommand ( 'contao:install-web-dir' , $ event ) ; static :: executeCommand ( 'cache:clear --no-warmup' , $ event ) ; static :: executeCommand ( 'cache:warmup' , $ event ) ; static :: executeCommand ( sprintf ( 'assets:install %s --symlink --relative' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:install %s' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:symlinks %s' , $ webDir ) , $ event ) ; $ event -> getIO ( ) -> write ( '<info>Done! Please open the Contao install tool and make sure the database is up-to-date.</info>' ) ; }
8969	protected function initialize ( ) { if ( ! file_exists ( dirname ( $ this -> pathToFile ) ) && ! mkdir ( dirname ( $ this -> pathToFile ) , 0777 , true ) ) { throw new RuntimeException ( sprintf ( 'Could not create storage file on path "%s".' , $ this -> pathToFile ) ) ; } if ( ! file_exists ( $ this -> pathToFile ) && ! ( touch ( $ this -> pathToFile ) && chmod ( $ this -> pathToFile , 0777 ) ) ) { throw new RuntimeException ( sprintf ( 'Could not create storage file on path "%s".' , $ this -> pathToFile ) ) ; } if ( ! is_readable ( $ this -> pathToFile ) ) { throw new RuntimeException ( sprintf ( 'File on path "%s" for storing rates must be readable.' , $ this -> pathToFile ) ) ; } if ( ! is_writable ( $ this -> pathToFile ) ) { throw new RuntimeException ( sprintf ( 'File on path "%s" for storing rates must be writeable.' , $ this -> pathToFile ) ) ; } }
3394	protected function sendConfirmationToUser ( $ user ) { $ user -> confirmation_code = str_random ( 25 ) ; $ user -> save ( ) ; $ notification = app ( config ( 'confirmation.notification' ) ) ; $ user -> notify ( $ notification ) ; }
9004	protected function months_dropdown ( $ post_type ) { global $ wpdb , $ wp_locale ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ months = $ wpdb -> get_results ( " SELECT DISTINCT YEAR( time ) AS year, MONTH( time ) AS month FROM $tn ORDER BY time DESC " ) ; $ month_count = count ( $ months ) ; if ( ! $ month_count || ( 1 == $ month_count && 0 == $ months [ 0 ] -> month ) ) { return ; } $ m = isset ( $ _GET [ 'm' ] ) ? ( int ) $ _GET [ 'm' ] : 0 ; ?> <label for="filter-by-date" class="screen-reader-text"> <?php _e ( 'Filter by date' ) ; ?> </label> <select name="m" id="filter-by-date"> <option <?php selected ( $ m , 0 ) ; ?> value="0"> <?php _e ( 'All dates' ) ; ?> </option> <?php foreach ( $ months as $ arc_row ) { if ( 0 == $ arc_row -> year ) { continue ; } $ month = zeroise ( $ arc_row -> month , 2 ) ; $ year = $ arc_row -> year ; printf ( "<option %s value='%s'>%s</option>\n" , selected ( $ m , $ year . $ month , false ) , esc_attr ( $ arc_row -> year . $ month ) , sprintf ( __ ( '%1$s %2$d' ) , $ wp_locale -> get_month ( $ month ) , $ year ) ) ; } ?> </select> <?php }
2718	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ snippet = $ this -> getRequest ( ) -> getParam ( 'snippet_id' ) ; $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ read -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ snippet ) ; if ( $ read -> isExist ( $ snippetPath ) ) { $ explodeId = explode ( '.' , $ snippet , - 1 ) ; $ snippetParts = explode ( '_' , $ explodeId [ 0 ] , 3 ) ; $ type = $ snippetParts [ 0 ] ; $ priority = $ snippetParts [ 1 ] ; $ name = $ snippetParts [ 2 ] ; $ content = $ read -> readFile ( $ snippetPath ) ; } else { throw new LocalizedException ( __ ( 'Custom snippet not found.' ) ) ; } return $ result -> setData ( [ 'status' => true , 'type' => $ type , 'priority' => $ priority , 'name' => $ name , 'content' => $ content , 'original' => $ snippet ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4546	public function setIncludeAssignedTasks ( ? bool $ includeAssignedTasks ) { $ this -> includeAssignedTasks = $ includeAssignedTasks ; $ this -> _includeAssignedTasks = null !== $ includeAssignedTasks ; return $ this ; }
5661	private function attributes ( $ node ) { if ( ! preg_match ( '|<[^ ]+\s(.*?)/?>|s' , $ node -> value , $ first_tag_contents ) ) { return array ( ) ; } $ attributes = array ( ) ; preg_match_all ( '/\S+\s*=\s*\'[^\']*\'|(\S+\s*=\s*"[^"]*")|([^ =]+\s*=\s*[^ "\']+?)|[^ "\']+/' , $ first_tag_contents [ 1 ] , $ matches ) ; foreach ( $ matches [ 0 ] as $ unparsed ) { $ attributes = $ this -> mergeAttribute ( $ attributes , $ unparsed ) ; } return $ attributes ; }
2525	public function getConsumerId ( $ generate = false ) { if ( is_null ( $ this -> consumerId ) && $ generate ) { $ this -> consumerId = $ this -> generateGuid ( ) ; } return $ this -> consumerId ; }
8307	public function assertStringContaining ( $ config , $ key , $ searchedPart ) { $ this -> assertString ( $ config , $ key ) ; if ( array_key_exists ( $ key , $ config ) && strpos ( $ config [ $ key ] , $ searchedPart ) === false ) { throw new ConfigurationException ( $ key . " must contain " . $ searchedPart ) ; } return $ this ; }
1186	protected function resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) { $ validateAll = Arr :: get ( $ data , $ field . '_validate_all' , false ) ; $ validationRule = 'bail|' . Validator :: EXTENSION_NAME . ':' . $ validateAll ; $ rules = [ $ field => $ validationRule ] + $ rules ; $ validator = $ this -> createValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; return $ validator ; }
7914	protected function renderLabel ( ) { $ label = $ this -> encodeLabel ? Html :: encode ( $ this -> label ) : $ this -> label ; return $ this -> hasModel ( ) ? Html :: activeLabel ( $ this -> model , $ this -> attribute , $ this -> labelOptions ) : Html :: label ( $ label , $ this -> getId ( ) , $ this -> labelOptions ) ; }
17	public function getLockedRepository ( $ withDevReqs = false ) { $ lockData = $ this -> getLockData ( ) ; $ packages = new ArrayRepository ( ) ; $ lockedPackages = $ lockData [ 'packages' ] ; if ( $ withDevReqs ) { if ( isset ( $ lockData [ 'packages-dev' ] ) ) { $ lockedPackages = array_merge ( $ lockedPackages , $ lockData [ 'packages-dev' ] ) ; } else { throw new \ RuntimeException ( 'The lock file does not contain require-dev information, run install with the --no-dev option or run update to install those packages.' ) ; } } if ( empty ( $ lockedPackages ) ) { return $ packages ; } if ( isset ( $ lockedPackages [ 0 ] [ 'name' ] ) ) { foreach ( $ lockedPackages as $ info ) { $ packages -> addPackage ( $ this -> loader -> load ( $ info ) ) ; } return $ packages ; } throw new \ RuntimeException ( 'Your composer.lock was created before 2012-09-15, and is not supported anymore. Run "composer update" to generate a new one.' ) ; }
4660	public function getConsoleLogger ( $ verbose = false ) { $ logger = new Logger ( "standalone-logger" ) ; $ handler = new StreamHandler ( "php://stdout" , $ verbose ? Logger :: DEBUG : Logger :: INFO ) ; $ simpleFormatter = new SimpleFormatter ( ) ; $ handler -> setFormatter ( $ simpleFormatter ) ; $ logger -> pushHandler ( $ handler ) ; if ( ! $ verbose ) { $ stdErrHandler = new StreamHandler ( "php://stderr" , Logger :: DEBUG ) ; $ fingerCrossedHandler = new FingersCrossedHandler ( $ stdErrHandler , new ErrorLevelActivationStrategy ( Logger :: ERROR ) , 10 ) ; $ logger -> pushHandler ( $ fingerCrossedHandler ) ; $ stdErrHandler -> setFormatter ( $ simpleFormatter ) ; } return $ logger ; }
2607	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ ioOptions = $ this -> api -> getImageOptimizationDefaultConfigOptions ( $ activeVersion ) -> data -> attributes ; if ( ! $ ioOptions ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch image optimization default config options.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'io_options' => $ ioOptions ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
10867	public function getList ( ) : IDataSource { $ columns = array_map ( function ( $ item ) { return $ this -> tableName [ 0 ] . '.' . $ item ; } , $ this -> columns ) ; return $ this -> connection -> select ( $ columns ) -> from ( $ this -> tableIdentity ) -> as ( $ this -> tableName [ 0 ] ) ; }
6957	private function _getRenderedToc ( $ list , $ depth = 1 ) { if ( ! isset ( $ list ) || empty ( $ list ) ) return ( '' ) ; $ html = "<ul class=\"toc-list\">\n" ; foreach ( $ list as $ entry ) { $ html .= "<li class=\"toc-entry\">\n" ; $ html .= '<a href="#' . $ this -> getParam ( 'anchorsPrefix' ) . $ this -> titleToIdentifier ( $ depth , $ entry [ 'value' ] ) . '">' . $ entry [ 'value' ] . "</a>\n" ; if ( isset ( $ entry [ 'sub' ] ) ) $ html .= $ this -> _getRenderedToc ( $ entry [ 'sub' ] , ( $ depth + 1 ) ) ; $ html .= "</li>\n" ; } $ html .= "</ul>\n" ; return ( $ html ) ; }
12672	public static function emulate ( $ emulation , callable $ assertionCallable = null ) { if ( ( is_string ( $ emulation ) ) && ( class_exists ( $ emulation ) ) ) { $ emulation = new $ emulation ( $ assertionCallable ) ; } static :: $ emulation = $ emulation ; }
12486	public function allFromAdapter ( Adapter $ adapter ) { if ( $ adapter instanceof KnowsItsBehaviors ) { return $ adapter -> getBehaviors ( ) ; } $ rfl = new \ ReflectionClass ( $ adapter ) ; $ behaviors = array ( ) ; foreach ( $ rfl -> getInterfaces ( ) as $ interface ) { if ( true === $ interface -> isSubclassOf ( 'Gaufrette\Core\Adapter\Behavior' ) ) { $ behaviors [ ] = $ interface -> getName ( ) ; } } return $ behaviors ; }
4187	public function publish ( $ provider ) { $ class = last ( explode ( '\\' , $ provider ) ) ; $ this -> console -> info ( "Searching {$provider} to publish vendor file." ) ; if ( ! $ this -> finder -> contains ( $ class ) -> contains ( '/\$this->publishes/i' ) -> count ( ) ) { $ this -> console -> warn ( 'Nothing to publish.' ) ; return true ; } $ tag = $ this -> console -> ask ( "If the \"{$this->console->tokenizePackageInfo()['name']}\" has specify vendor publish tag in installation guide then please add it here or press enter to skip adding tag." , false ) ; $ this -> console -> call ( 'vendor:publish' , [ '--provider' => $ provider , '--tag' => $ tag , ] ) ; return $ this -> registered = true ; }
6817	protected function buildAdjustments ( $ type , Model \ AdjustableInterface $ adjustable , array $ data , $ persistence = false ) { Model \ AdjustmentTypes :: isValidType ( $ type ) ; $ change = false ; $ newAdjustments = [ ] ; foreach ( $ data as $ d ) { $ adjustment = $ this -> saleFactory -> createAdjustmentFor ( $ adjustable ) ; $ adjustment -> setType ( $ type ) -> setMode ( $ d -> getMode ( ) ) -> setDesignation ( $ d -> getDesignation ( ) ) -> setAmount ( $ d -> getAmount ( ) ) -> setImmutable ( $ d -> isImmutable ( ) ) ; $ newAdjustments [ ] = $ adjustment ; } $ oldAdjustments = $ adjustable -> getAdjustments ( $ type ) ; foreach ( $ oldAdjustments as $ oldAdjustment ) { if ( ! $ oldAdjustment -> isImmutable ( ) ) { continue ; } foreach ( $ newAdjustments as $ index => $ newAdjustment ) { if ( $ oldAdjustment -> equals ( $ newAdjustment ) ) { unset ( $ newAdjustments [ $ index ] ) ; continue 2 ; } } $ adjustable -> removeAdjustment ( $ oldAdjustment ) ; if ( $ persistence ) { $ this -> persistenceHelper -> remove ( $ oldAdjustment , true ) ; } $ change = true ; } foreach ( $ newAdjustments as $ newAdjustment ) { $ adjustable -> addAdjustment ( $ newAdjustment ) ; if ( $ persistence ) { $ this -> persistenceHelper -> persistAndRecompute ( $ newAdjustment , true ) ; } $ change = true ; } return $ change ; }
1915	protected function getQuestion ( ) { $ this -> generateCaptcha ( ) ; $ question = $ GLOBALS [ 'TL_LANG' ] [ 'SEC' ] [ 'question' . random_int ( 1 , 3 ) ] ; $ question = sprintf ( $ question , $ this -> arrCaptcha [ 'int1' ] , $ this -> arrCaptcha [ 'int2' ] ) ; $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ question ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( '&#%s;' , Utf8 :: ord ( $ strCharacter ) ) ; } return $ strEncoded ; }
7370	public function setTranslations ( array $ translations ) { foreach ( $ translations as $ key => $ string ) { if ( ! ( is_string ( $ string ) && ! empty ( $ string ) ) ) { throw new \ InvalidArgumentException ( "Invalid translation for key '$key'." ) ; } } $ this -> translations = array_replace ( $ this -> getDefaultTranslations ( ) , $ translations ) ; }
4729	public function isSingular ( $ word ) { $ inflection = $ this -> getCachedPlural ( $ word ) ; if ( $ inflection !== false ) { return true ; } $ pluralWord = $ this -> toPlural ( $ word ) ; if ( $ pluralWord === false ) { return false ; } return $ this -> toSingular ( $ pluralWord ) == $ word ; }
11188	public static function set ( array $ arr , $ k , $ v ) { $ nested = ! is_array ( $ k ) ? explode ( '.' , $ k ) : $ k ; $ count = count ( $ nested ) ; if ( $ count == 1 ) { return $ arr [ $ k ] = $ v ; } elseif ( $ count > 1 ) { $ prev = '' ; $ loop = 1 ; $ unshift = $ nested ; foreach ( $ nested as $ part ) { if ( isset ( $ arr [ $ part ] ) && $ count > $ loop ) { $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; continue ; } else { if ( $ loop > 1 && $ loop < $ count ) { if ( ! isset ( $ arr [ $ prev ] [ $ part ] ) ) $ arr [ $ prev ] [ $ part ] = [ ] ; $ arr [ $ prev ] = static :: set ( $ arr [ $ prev ] , $ unshift , $ v ) ; $ loop ++ ; break ; } elseif ( $ loop >= 1 && $ loop == $ count ) { if ( ! is_array ( $ arr [ $ prev ] ) ) $ arr [ $ prev ] = [ ] ; if ( $ part == '' ) $ arr [ $ prev ] [ ] = $ v ; else $ arr [ $ prev ] [ $ part ] = $ v ; } else { $ arr [ $ part ] = [ ] ; $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; } } } } return $ arr ; }
9961	public function freezePane ( $ cell , $ topLeftCell = null ) { if ( is_string ( $ cell ) && Coordinate :: coordinateIsRange ( $ cell ) ) { throw new Exception ( 'Freeze pane can not be set on a range of cells.' ) ; } if ( $ cell !== null && $ topLeftCell === null ) { $ coordinate = Coordinate :: coordinateFromString ( $ cell ) ; $ topLeftCell = $ coordinate [ 0 ] . $ coordinate [ 1 ] ; } $ this -> freezePane = $ cell ; $ this -> topLeftCell = $ topLeftCell ; return $ this ; }
2028	public static function findPublishedRegularWithoutGuestsByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.type!='root' AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( FE_USER_LOGGED_IN ) { $ arrColumns [ ] = "$t.guests=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
5856	public function initializeRulesets ( array $ configuration ) { $ general = $ configuration ; $ general [ 'usergroup' ] = '' ; unset ( $ general [ 'rulesets' ] ) ; $ general = $ this -> expandValuesInRuleset ( $ general ) ; if ( $ general [ 'conversion_mapping' ] === '' ) { $ general [ 'conversion_mapping' ] = [ ] ; } if ( isset ( $ configuration [ 'rulesets' ] ) ) { $ rulesets = $ this -> compileRuleSets ( $ configuration [ 'rulesets' ] ) ; } else { $ rulesets = [ ] ; } foreach ( $ rulesets as $ k => & $ ruleset ) { foreach ( $ general as $ key => $ value ) { if ( ! isset ( $ ruleset [ $ key ] ) ) { $ ruleset [ $ key ] = $ value ; } elseif ( $ ruleset [ $ key ] === '' ) { $ ruleset [ $ key ] = $ value ; } } if ( count ( $ ruleset [ 'usergroup' ] ) == 0 ) { $ ruleset [ 'directories' ] = array_diff ( $ ruleset [ 'directories' ] , $ general [ 'directories' ] ) ; if ( count ( $ ruleset [ 'directories' ] ) == 0 ) { unset ( $ rulesets [ $ k ] ) ; } } } $ rulesets [ ] = $ general ; $ this -> rulesets = $ rulesets ; }
4091	public function createPayload ( ) { $ payloads = array ( ) ; foreach ( $ this -> operations as $ operation ) { foreach ( $ operation as $ partial ) { $ payloads [ ] = json_encode ( $ partial ) ; } } return join ( "\n" , $ payloads ) . "\n" ; }
4	private function buildDepExtensionConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { $ depChannelName = 'ext' ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
8341	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ prettyPageHandler = new PrettyPageHandler ( ) ; self :: $ prettyPageHandler -> setPageTitle ( 'I just broke a string... - strayFw' ) ; $ whoops = new Run ( ) ; $ whoops -> pushHandler ( new JsonResponseHandler ( ) ) ; $ whoops -> pushHandler ( self :: $ prettyPageHandler ) ; $ whoops -> register ( ) ; self :: $ isInit = true ; } }
734	public function init ( ) { parent :: init ( ) ; $ this -> itemFile = Yii :: getAlias ( $ this -> itemFile ) ; $ this -> assignmentFile = Yii :: getAlias ( $ this -> assignmentFile ) ; $ this -> ruleFile = Yii :: getAlias ( $ this -> ruleFile ) ; $ this -> load ( ) ; }
8931	private function addRoute ( $ method ) { switch ( $ method ) { case 'index' : $ methodMap = [ 'GET' ] ; $ realRoute = '$route' ; $ controllerCallable = $ this -> controllerLocation . ':indexAction' ; break ; case 'get' : $ methodMap = [ 'GET' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':getAction' ; break ; case 'post' : $ methodMap = [ 'POST' ] ; $ realRoute = '$route' ; $ controllerCallable = $ this -> controllerLocation . ':postAction' ; break ; case 'put' : $ methodMap = [ 'POST' , 'PUT' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':putAction' ; break ; case 'delete' : $ methodMap = [ 'DELETE' ] ; $ realRoute = '$route/{id}' ; $ controllerCallable = $ this -> controllerLocation . ':deleteAction' ; break ; default : throw new \ Exception ( 'Invalid method.' . $ method ) ; break ; } $ methodMap = "['" . implode ( "', '" , $ methodMap ) . "']" ; $ command = strtr ( $ this -> template , [ '$methodMap' => $ methodMap , '$route' => $ realRoute , '$controllerCallable' => $ controllerCallable ] ) ; $ this -> commands [ ] = $ command ; }
9093	public function getPagePartial ( $ page ) { if ( isset ( $ this -> pagePartials [ $ page ] ) ) { return $ this -> pagePartials [ $ page ] ; } return null ; }
62	public function unlink ( $ path ) { $ unlinked = @ $ this -> unlinkImplementation ( $ path ) ; if ( ! $ unlinked ) { if ( Platform :: isWindows ( ) ) { usleep ( 350000 ) ; $ unlinked = @ $ this -> unlinkImplementation ( $ path ) ; } if ( ! $ unlinked ) { $ error = error_get_last ( ) ; $ message = 'Could not delete ' . $ path . ': ' . @ $ error [ 'message' ] ; if ( Platform :: isWindows ( ) ) { $ message .= "\nThis can be due to an antivirus or the Windows Search Indexer locking the file while they are analyzed" ; } throw new \ RuntimeException ( $ message ) ; } } return true ; }
5506	public function returnsAt ( $ timing , $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return value sequence' ) ; $ this -> actions -> registerAt ( $ timing , $ method , $ args , new SimpleReturn ( $ value ) ) ; }
6653	public function removeExtraData ( array $ extraDataKeys = [ ] ) { foreach ( $ extraDataKeys as $ key ) { if ( array_key_exists ( $ key , $ this -> extraData ) ) { unset ( $ this -> extraData [ $ key ] ) ; } } }
11652	protected function _initRestRoute ( ) { $ front = Zend_Controller_Front :: getInstance ( ) ; $ front -> setResponse ( new Benri_Controller_Response_Http ( ) ) ; $ front -> setRequest ( new Benri_Controller_Request_Http ( ) ) ; $ front -> getRouter ( ) -> addRoute ( 'benri-app' , new Zend_Rest_Route ( $ front ) ) ; }
10094	protected function srvGet ( $ domain , $ https = false ) { if ( isset ( $ https ) && $ https === true ) { $ subdomain = '_avatars-sec._tcp.' ; $ fallback = 'seccdn.' ; $ port = 443 ; } else { $ subdomain = '_avatars._tcp.' ; $ fallback = 'cdn.' ; $ port = 80 ; } if ( $ domain === null ) { return $ fallback . 'libravatar.org' ; } $ srv = dns_get_record ( $ subdomain . $ domain , DNS_SRV ) ; if ( count ( $ srv ) == 0 ) { return $ fallback . 'libravatar.org' ; } usort ( $ srv , array ( $ this , 'comparePriority' ) ) ; $ top = $ srv [ 0 ] ; $ sum = 0 ; shuffle ( $ srv ) ; $ srvs = array ( ) ; foreach ( $ srv as $ s ) { if ( $ s [ 'weight' ] == 0 ) { array_unshift ( $ srvs , $ s ) ; } else { array_push ( $ srvs , $ s ) ; } } foreach ( $ srvs as $ s ) { if ( $ s [ 'pri' ] == $ top [ 'pri' ] ) { $ sum += ( int ) $ s [ 'weight' ] ; $ pri [ $ sum ] = $ s ; } } $ random = rand ( 0 , $ sum ) ; foreach ( $ pri as $ k => $ v ) { if ( $ k >= $ random ) { $ target = $ v [ 'target' ] ; if ( $ v [ 'port' ] !== $ port ) { $ target .= ':' . $ v [ 'port' ] ; } return $ target ; } } }
112	private function collectDependencies ( Pool $ pool , array $ collected , PackageInterface $ package ) { $ requires = array_merge ( $ package -> getRequires ( ) , $ package -> getDevRequires ( ) ) ; foreach ( $ requires as $ requireLink ) { $ requiredPackage = $ this -> lookupInstalledPackage ( $ pool , $ requireLink ) ; if ( $ requiredPackage && ! isset ( $ collected [ $ requiredPackage -> getName ( ) ] ) ) { $ collected [ $ requiredPackage -> getName ( ) ] = $ requiredPackage ; $ collected = $ this -> collectDependencies ( $ pool , $ collected , $ requiredPackage ) ; } } return $ collected ; }
11138	protected function calculateCREATE ( ) { $ this -> query .= 'CREATE TABLE IF NOT EXISTS ' ; $ this -> query .= $ this -> create . ' (' ; $ this -> queryStringFromArray ( 'fields' , '' , ', ' , false , true ) ; $ this -> primaryKeyStringFromArray ( 'primaryKeys' , ', CONSTRAINT ' ) ; $ this -> foreignKeyStringFromArray ( 'foreignKeys' , ', CONSTRAINT ' ) ; $ this -> indexStringFromArray ( 'indexes' , ', INDEX ' ) ; $ this -> query .= ')' ; }
11779	protected function buildClass ( $ name ) { $ stub = $ this -> files -> get ( $ this -> getStub ( ) ) ; return str_replace ( 'DummyHelper' , $ this -> getNameInput ( ) , $ stub ) ; }
19	protected function getRepoData ( ) { $ resource = sprintf ( 'https://api.bitbucket.org/2.0/repositories/%s/%s?%s' , $ this -> owner , $ this -> repository , http_build_query ( array ( 'fields' => '-project,-owner' ) , null , '&' ) ) ; $ repoData = JsonFile :: parseJson ( $ this -> getContentsWithOAuthCredentials ( $ resource , true ) , $ resource ) ; if ( $ this -> fallbackDriver ) { return false ; } $ this -> parseCloneUrls ( $ repoData [ 'links' ] [ 'clone' ] ) ; $ this -> hasIssues = ! empty ( $ repoData [ 'has_issues' ] ) ; $ this -> branchesUrl = $ repoData [ 'links' ] [ 'branches' ] [ 'href' ] ; $ this -> tagsUrl = $ repoData [ 'links' ] [ 'tags' ] [ 'href' ] ; $ this -> homeUrl = $ repoData [ 'links' ] [ 'html' ] [ 'href' ] ; $ this -> website = $ repoData [ 'website' ] ; $ this -> vcsType = $ repoData [ 'scm' ] ; return true ; }
5157	public function executeFor ( Route $ route ) : bool { if ( null === $ this -> pathConstraint ) { return true ; } return strpos ( $ route -> getPath ( ) , $ this -> pathConstraint ) === 0 ; }
8964	private static function matchesArrayCriteria ( $ key , $ object , array $ criteria ) { $ criteria = self :: extractArrayCriteria ( $ key , $ criteria ) ; if ( count ( $ criteria ) === 0 ) { return true ; } $ getter = sprintf ( 'get%s' , ucfirst ( $ key ) ) ; if ( ! method_exists ( $ object , $ getter ) ) { throw new RuntimeException ( sprintf ( 'Object instance of "%s" does not have required getter "%s" to be used for filtering.' , get_class ( $ object ) , $ getter ) ) ; } return in_array ( $ object -> { $ getter } ( ) , $ criteria , true ) ; }
11468	public function index ( ResponseRequest $ request ) { $ view = $ this -> response -> theme -> listView ( ) ; if ( $ this -> response -> typeIs ( 'json' ) ) { $ function = camel_case ( 'get-' . $ view ) ; return $ this -> repository -> setPresenter ( \ Litecms \ Forum \ Repositories \ Presenter \ ResponsePresenter :: class ) -> $ function ( ) ; } $ responses = $ this -> repository -> paginate ( ) ; return $ this -> response -> title ( trans ( 'forum::response.names' ) ) -> view ( 'forum::response.index' , true ) -> data ( compact ( 'responses' ) ) -> output ( ) ; }
10947	public function getAcceptableContentTypes ( ) { if ( $ this -> _contentTypes === null ) { if ( isset ( $ _SERVER [ 'HTTP_ACCEPT' ] ) ) { $ this -> _contentTypes = $ this -> parseAcceptHeader ( $ _SERVER [ 'HTTP_ACCEPT' ] ) ; } else { $ this -> _contentTypes = [ ] ; } } return $ this -> _contentTypes ; }
6061	public function listDeploymentSites ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/deployment/sites' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new DeploymentSiteResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
9023	public function hasConfirmation ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( in_array ( $ word , $ this -> confirmationWords ) ) { $ result = true ; } } return $ result ; }
9826	private function writeRelationship ( XMLWriter $ objWriter , $ pId , $ pType , $ pTarget , $ pTargetMode = '' ) { if ( $ pType != '' && $ pTarget != '' ) { $ objWriter -> startElement ( 'Relationship' ) ; $ objWriter -> writeAttribute ( 'Id' , 'rId' . $ pId ) ; $ objWriter -> writeAttribute ( 'Type' , $ pType ) ; $ objWriter -> writeAttribute ( 'Target' , $ pTarget ) ; if ( $ pTargetMode != '' ) { $ objWriter -> writeAttribute ( 'TargetMode' , $ pTargetMode ) ; } $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
1557	protected function defaultOrder ( $ query ) { if ( $ this -> doesRequireOrdering ( $ query ) ) { $ query -> orderBy ( $ this -> primaryKey ) ; } return $ this ; }
7406	public function replace ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; foreach ( $ in as $ k => $ v ) { $ this -> offsetSet ( $ k , $ v ) ; } }
5517	public function errorAt ( $ timing , $ method , $ error = 'A mock error' , $ args = false , $ severity = E_USER_ERROR ) { $ this -> dieOnNoMethod ( $ method , 'error at' ) ; $ this -> actions -> registerAt ( $ timing , $ method , $ args , new SimpleErrorThrower ( $ error , $ severity ) ) ; }
9235	public function actionCreate ( ) { $ model = new Banner ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> position = $ model -> getLast ( ) ; $ model -> isdel = 0 ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'Banner' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'Banner' ] [ 'tags' ] ) ) { $ post [ 'Banner' ] [ 'tags' ] = implode ( "," , $ post [ 'Banner' ] [ 'tags' ] ) ; } } $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { $ model -> updatePosition ( $ model -> position ) ; $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; }
11643	public function getFormatter ( ) { if ( $ this -> _formatter === null ) { $ this -> _formatter = Yii :: $ app -> format ; } return $ this -> _formatter ; }
12651	private function writeTextsToFile ( $ language ) { $ textInfo = array ( ) ; $ outdateInfo = array ( ) ; foreach ( $ this -> contents [ $ language ] as $ id => $ info ) { $ textInfo [ $ id ] = $ info [ 'content' ] ; $ outdateInfo [ $ id ] = $ info [ 'outdated' ] ; } if ( $ language === $ this -> baseLang ) { $ content = array ( 'root' => $ textInfo ) + array_fill_keys ( $ this -> extraLangs , true ) ; } else { $ content = $ textInfo ; } $ encodeFlags = JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES ; $ content = "'use strict';\n/*global define*/\ndefine(" . json_encode ( $ content , $ encodeFlags ) . ");\n" ; $ fs = $ this -> env -> getFileSystem ( ) ; $ fs -> putFile ( $ this -> getFileName ( $ language ) , $ content ) ; $ fs -> putFile ( $ this -> getOutdateInfoFileName ( $ language ) , json_encode ( $ outdateInfo , $ encodeFlags ) ) ; }
7202	public function getGross ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> gross ) : $ this -> gross ; }
8048	public function receive ( ) { $ hdr = '' ; do { $ read = socket_read ( $ this -> socket , 4 - strlen ( $ hdr ) ) ; if ( $ read === FALSE ) { throw new SimpleSocketException ( 'Reception failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } elseif ( $ read === '' || $ read === NULL ) { return NULL ; } $ hdr .= $ read ; } while ( strlen ( $ hdr ) < 4 ) ; list ( $ len ) = array_values ( unpack ( "N" , $ hdr ) ) ; $ buffer = '' ; do { $ read = socket_read ( $ this -> socket , $ len - strlen ( $ buffer ) ) ; if ( $ read === FALSE || $ read == '' ) { throw new SimpleSocketException ( 'Reception failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } elseif ( $ read == '' ) { return NULL ; } $ buffer .= $ read ; } while ( strlen ( $ buffer ) < $ len ) ; $ data = unserialize ( $ buffer ) ; return $ data ; }
4042	public function getReadableValue ( RenderReadablePropertyValueEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ result = $ nativeItem -> parseAttribute ( $ event -> getProperty ( ) -> getName ( ) , 'text' , $ renderSetting ) ; if ( ! isset ( $ result [ 'text' ] ) ) { $ event -> setRendered ( sprintf ( 'Unexpected behaviour, attribute %s text representation was not rendered.' , $ event -> getProperty ( ) -> getName ( ) ) ) ; return ; } $ event -> setRendered ( $ result [ 'text' ] ) ; }
3328	private function getPriceConfigurations ( ) { static $ priceConfigurations ; if ( null === $ priceConfigurations ) { $ priceConfigurations = $ this -> itemsSalesPricesApi -> findAll ( ) ; $ shopIdentities = $ this -> identityService -> findBy ( [ 'adapterName' => PlentymarketsAdapter :: NAME , 'objectType' => Shop :: TYPE , ] ) ; $ shopIdentities = array_filter ( $ shopIdentities , function ( Identity $ identity ) { $ isMappedIdentity = $ this -> identityService -> isMappedIdentity ( $ identity -> getObjectIdentifier ( ) , $ identity -> getObjectType ( ) , $ identity -> getAdapterName ( ) ) ; if ( ! $ isMappedIdentity ) { return false ; } return true ; } ) ; if ( empty ( $ shopIdentities ) ) { $ priceConfigurations = [ ] ; return $ priceConfigurations ; } $ priceConfigurations = array_filter ( $ priceConfigurations , function ( $ priceConfiguration ) use ( $ shopIdentities ) { foreach ( $ shopIdentities as $ identity ) { foreach ( ( array ) $ priceConfiguration [ 'clients' ] as $ client ) { if ( $ client [ 'plentyId' ] === - 1 || $ identity -> getAdapterIdentifier ( ) === ( string ) $ client [ 'plentyId' ] ) { return true ; } } } return false ; } ) ; if ( empty ( $ priceConfigurations ) ) { $ this -> logger -> notice ( 'no valid price configuration found' ) ; } } return $ priceConfigurations ; }
9708	private function writeShortNameBiff8 ( $ name , $ sheetIndex , $ rangeBounds , $ isHidden = false ) { $ record = 0x0018 ; $ options = ( $ isHidden ? 0x21 : 0x00 ) ; $ extra = pack ( 'Cvvvvv' , 0x3B , $ sheetIndex - 1 , $ rangeBounds [ 0 ] [ 1 ] - 1 , $ rangeBounds [ 1 ] [ 1 ] - 1 , $ rangeBounds [ 0 ] [ 0 ] - 1 , $ rangeBounds [ 1 ] [ 0 ] - 1 ) ; $ sz = strlen ( $ extra ) ; $ data = pack ( 'vCCvvvCCCCC' , $ options , 0 , 1 , $ sz , 0 , $ sheetIndex , 0 , 0 , 0 , 0 , 0 ) . $ name . $ extra ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
6986	protected function createDefaultContext ( ) : ContextInterface { $ context = $ this -> createContext ( ) ; if ( $ this -> customerProvider -> hasCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ this -> customerProvider -> getCustomer ( ) ) ; } $ this -> finalize ( $ context ) ; return $ context ; }
428	public function init ( ) { if ( $ this -> controllerNamespace === null ) { $ class = get_class ( $ this ) ; if ( ( $ pos = strrpos ( $ class , '\\' ) ) !== false ) { $ this -> controllerNamespace = substr ( $ class , 0 , $ pos ) . '\\controllers' ; } } }
9377	protected function extract ( $ filepath , array $ data ) { extract ( $ data ) ; ob_start ( ) ; include $ filepath ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; return $ contents ; }
6246	public function files ( ? int $ constraints = null ) : \ Generator { foreach ( $ this -> all ( $ constraints ) as $ file ) { if ( ! $ file -> isDir ( ) ) { yield $ file ; } } }
9497	protected function getOne ( $ end_point ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ t = new $ type ( ) ; $ t -> setManagingClient ( $ this ) ; return $ t -> fromArray ( $ result [ $ baseName ] ) ; } return null ; }
2908	public function decodeSubject ( $ subject ) { if ( $ this -> hasQueue ( ) && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageParameters ( 'subject' ) ; } return base64_decode ( substr ( $ subject , strlen ( '=?utf-8?B?' ) , - 1 * strlen ( '?=' ) ) ) ; }
4424	protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( ! $ input -> isInteractive ( ) ) { $ output -> writeln ( '<error>This command only supports interactive execution</error>' ) ; return 1 ; } $ this -> writeSection ( 'Installation' ) ; $ legacySiteAccessGenerator = new LegacySiteAccessGenerator ( $ this -> getContainer ( ) , $ this -> questionHelper ) ; $ legacySiteAccessGenerator -> generate ( $ this -> input , $ this -> output ) ; $ configurationGenerator = new ConfigurationGenerator ( $ this -> getContainer ( ) , $ this -> questionHelper ) ; $ configurationGenerator -> generate ( $ this -> input , $ this -> output ) ; $ errors = array ( ) ; $ runner = $ this -> getRunner ( $ errors ) ; $ runner ( $ this -> generateLegacyAutoloads ( ) ) ; $ this -> writeInstallerSummary ( $ errors ) ; return 0 ; }
4294	public static function getType ( $ val , & $ typeMore = null ) { if ( \ is_string ( $ val ) ) { $ type = 'string' ; if ( \ is_numeric ( $ val ) ) { $ typeMore = 'numeric' ; } elseif ( $ val === self :: UNDEFINED ) { $ type = 'undefined' ; } elseif ( $ val === self :: RECURSION ) { $ type = 'recursion' ; } } elseif ( \ is_array ( $ val ) ) { if ( \ in_array ( self :: ABSTRACTION , $ val , true ) ) { $ type = $ val [ 'type' ] ; $ typeMore = 'abstraction' ; } elseif ( AbstractArray :: isCallable ( $ val ) ) { $ type = 'callable' ; $ typeMore = 'raw' ; } else { $ type = 'array' ; $ typeMore = 'raw' ; } } elseif ( \ is_bool ( $ val ) ) { $ type = 'bool' ; $ typeMore = \ json_encode ( $ val ) ; } elseif ( \ is_float ( $ val ) ) { $ type = 'float' ; } elseif ( \ is_int ( $ val ) ) { $ type = 'int' ; } elseif ( \ is_null ( $ val ) ) { $ type = 'null' ; } elseif ( \ is_object ( $ val ) ) { $ type = 'object' ; $ typeMore = 'raw' ; } elseif ( \ is_resource ( $ val ) || \ strpos ( \ print_r ( $ val , true ) , 'Resource' ) === 0 ) { $ type = 'resource' ; $ typeMore = 'raw' ; } return $ type ; }
61	public function isDirEmpty ( $ dir ) { $ finder = Finder :: create ( ) -> ignoreVCS ( false ) -> ignoreDotFiles ( false ) -> depth ( 0 ) -> in ( $ dir ) ; return count ( $ finder ) === 0 ; }
6169	protected function writeException ( $ exception ) { $ this -> writeNewLine ( ) ; do { $ exceptionStack [ ] = $ exception ; } while ( $ exception = $ exception -> getPreviousWrapped ( ) ) ; foreach ( explode ( "\n" , $ exception = array_shift ( $ exceptionStack ) ) as $ line ) { if ( $ exception && false !== $ pos = strpos ( $ line , $ exception -> getClassName ( ) . ': ' ) ) { $ whitespace = str_repeat ( ' ' , ( $ pos += strlen ( $ exception -> getClassName ( ) ) ) + 2 ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , sprintf ( ' %s ' , substr ( $ line , 0 , $ pos ) ) , false ) ; $ this -> writeWithColor ( 'fg-red' , substr ( $ line , $ pos + 1 ) ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ exception = array_shift ( $ exceptionStack ) ; continue ; } $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
8177	public static function sendWelcomeMessage ( User $ user ) { return Mailer :: sendMail ( $ user -> email , 'Welcome to ' . Yii :: $ app -> name , 'welcome' , [ 'user' => $ user ] ) ; }
4923	public function removeTypeFromRegion ( $ type , $ region ) { if ( array_key_exists ( $ region , $ this -> matrix ) ) { array_walk ( $ this -> matrix [ $ region ] , function ( $ value , $ idx , $ matrix ) use ( $ type , $ region ) { $ class = explode ( '\\' , $ value ) ; $ className = array_pop ( $ class ) ; if ( $ className === $ type ) { unset ( $ matrix [ $ region ] [ $ idx ] ) ; } } , $ this -> matrix ) ; } return $ this ; }
12146	public function get ( $ name ) { if ( $ this -> exists ( $ name ) ) { $ value = $ this -> settings [ $ name ] ; return $ value ; } return false ; }
5728	public function Field ( $ properties = array ( ) ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/dropdown_form_action.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/dropdown_form_action.js' ) ; $ this -> setAttribute ( 'data-form-action-dropdown' , '#' . $ this -> DropdownID ( ) ) ; return parent :: Field ( ) ; }
7903	protected function dynamicUploadTo ( $ uploadTo ) { $ disk = Str :: snake ( substr ( $ uploadTo , 8 ) ) ; return $ this -> uploadTo ( $ disk ) ; }
8762	public function upload ( $ input ) { $ validator = \ Validator :: make ( $ input , config ( 'dropzoner.validator' ) , config ( 'dropzoner.validator-messages' ) ) ; if ( $ validator -> fails ( ) ) { return response ( ) -> json ( [ 'error' => true , 'message' => $ validator -> messages ( ) -> first ( ) , 'code' => 400 ] , 400 ) ; } $ photo = $ input [ 'file' ] ; $ original_name = $ photo -> getClientOriginalName ( ) ; $ extension = $ photo -> getClientOriginalExtension ( ) ; $ original_name_without_extension = substr ( $ original_name , 0 , strlen ( $ original_name ) - strlen ( $ extension ) - 1 ) ; $ filename = $ this -> sanitize ( $ original_name_without_extension ) ; $ allowed_filename = $ this -> createUniqueFilename ( $ filename ) ; $ filename_with_extension = $ allowed_filename . '.' . $ extension ; $ manager = new ImageManager ( ) ; $ image = $ manager -> make ( $ photo ) -> save ( config ( 'dropzoner.upload-path' ) . $ filename_with_extension ) ; if ( ! $ image ) { return response ( ) -> json ( [ 'error' => true , 'message' => 'Server error while uploading' , 'code' => 500 ] , 500 ) ; } event ( new ImageWasUploaded ( $ original_name , $ filename_with_extension ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 , 'filename' => $ filename_with_extension ] , 200 ) ; }
3389	public function redirectAfterRegistrationPath ( ) { if ( method_exists ( $ this , 'redirectAfterRegistrationTo' ) ) { return $ this -> redirectAfterRegistrationTo ( ) ; } return property_exists ( $ this , 'redirectAfterRegistrationTo' ) ? $ this -> redirectAfterRegistrationTo : route ( 'login' ) ; }
7483	public function startsWith ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; return $ string === $ this -> substring ( 0 , ( mb_strlen ( $ string , $ this -> encoding ) - 1 ) ) -> __toString ( ) ; }
4492	public function broadcast ( Message $ message , string $ topicArn ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $topicArn" , [ 'Message' => $ message , ] ) ; return ; } $ this -> messages -> send ( $ message , $ topicArn ) ; }
11581	public function bootstrap ( $ rootDir , $ siteName ) { $ this -> app [ "red_kite_cms.root_dir" ] = $ rootDir ; $ this -> siteName = $ siteName ; $ this -> checkPermissions ( $ rootDir ) ; $ this -> initCmsRequiredServices ( ) ; $ this -> registerProviders ( ) ; $ this -> registerServices ( ) ; $ this -> registerListeners ( ) ; $ this -> register ( $ this -> app ) ; $ this -> boot ( ) ; $ this -> addWebsiteRoutes ( ) ; $ this -> app [ "dispatcher" ] -> dispatch ( CmsEvents :: CMS_BOOTED , new CmsBootedEvent ( $ this -> app [ "red_kite_cms.configuration_handler" ] ) ) ; }
1801	protected function switchToEdit ( $ id ) { $ arrKeys = array ( ) ; $ arrUnset = array ( 'act' , 'id' , 'table' ) ; foreach ( array_keys ( $ _GET ) as $ strKey ) { if ( ! \ in_array ( $ strKey , $ arrUnset ) ) { $ arrKeys [ $ strKey ] = $ strKey . '=' . Input :: get ( $ strKey ) ; } } $ strUrl = TL_SCRIPT . '?' . implode ( '&' , $ arrKeys ) ; return $ strUrl . ( ! empty ( $ arrKeys ) ? '&' : '' ) . ( Input :: get ( 'table' ) ? 'table=' . Input :: get ( 'table' ) . '&amp;' : '' ) . 'act=edit&amp;id=' . rawurlencode ( $ id ) ; }
7408	public function merge ( $ ta ) : self { $ this -> _massageBlockInput ( $ in ) ; $ ret = clone $ this ; foreach ( $ ta as $ k => $ v ) { if ( is_int ( $ k ) ) { $ ret [ ] = $ v ; } else { $ ret [ $ k ] = $ v ; } } return $ ret ; }
3679	private function buildBackendModules ( & $ localMenu ) { foreach ( $ this -> viewCombination -> getStandalone ( ) as $ metaModelName => $ screen ) { $ section = $ screen [ 'meta' ] [ 'backendsection' ] ; if ( ! isset ( $ localMenu [ $ section ] ) ) { $ localMenu [ $ section ] = [ ] ; } if ( ! isset ( $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] ) ) { $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] = [ 'tables' => [ ] ] ; } $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] [ 'callback' ] = Module :: class ; array_unshift ( $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] [ 'tables' ] , $ metaModelName ) ; } }
7474	public function updateAction ( Request $ request , $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ id ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
10891	public function syntax ( $ error = "Please specify valid options" ) { $ ostr = ( ! $ error ) ? STDOUT : STDERR ; if ( is_string ( $ error ) ) fprintf ( $ ostr , "Error: %s\n" , $ error ) ; fprintf ( $ ostr , "Syntax: php " . $ _SERVER [ 'argv' ] [ 0 ] . " <options> <action>\n\n" ) ; fprintf ( $ ostr , "Options: \n" ) ; $ max_opt_length = 0 ; $ max_arg_length = 0 ; $ params = $ this -> parameters ; usort ( $ params , function ( $ a , $ b ) { $ lo = ! empty ( $ a [ 0 ] ) ? $ a [ 0 ] : $ a [ 1 ] ; $ ro = ! empty ( $ b [ 0 ] ) ? $ b [ 0 ] : $ b [ 1 ] ; return strcmp ( $ lo , $ ro ) ; } ) ; foreach ( $ params as $ param ) { $ max_opt_length = max ( strlen ( $ param [ 1 ] ) + 3 , $ max_opt_length ) ; $ max_arg_length = max ( strlen ( $ param [ 2 ] ) + 3 , $ max_arg_length ) ; } foreach ( $ this -> parameters as $ param ) { fprintf ( $ ostr , " " ) ; $ so = $ param [ 0 ] ? "-" . $ param [ 0 ] : "" ; $ lo = $ param [ 1 ] ? "--" . $ param [ 1 ] : "" ; $ arg = $ param [ 2 ] ? '<' . $ param [ 2 ] . '>' : "" ; $ pstr = sprintf ( "%-2s %-" . $ max_opt_length . "s %-" . $ max_arg_length . "s " , $ so , $ lo , $ arg ) ; $ indent = strlen ( $ pstr ) + 4 ; fprintf ( $ ostr , $ pstr ) ; self :: formatText ( $ indent , self :: MAX_LINE_LENGTH , $ param [ 3 ] , $ ostr ) ; } exit ( $ error === false ? 0 : 1 ) ; }
11956	function addQueue ( $ channel , $ queue , $ weight = 1 ) { $ orig = $ channel ; $ channel = $ this -> _normalizeQueueName ( $ channel ) ; if ( ! $ queue instanceof iQueueDriver ) throw new \ Exception ( sprintf ( 'Queue must be instance of iQueueDriver; given: (%s).' , \ Poirot \ Std \ flatten ( $ queue ) ) ) ; if ( isset ( $ this -> channels_queue [ $ channel ] ) ) throw new \ RuntimeException ( sprintf ( 'Channel (%s) is currently filled with (%s) and is not empty.' , $ orig , get_class ( $ this -> channels_queue [ $ channel ] ) ) ) ; $ this -> channels_queue [ $ channel ] = $ queue ; $ this -> channels_weight [ $ channel ] = $ weight ; return $ this ; }
5297	protected function getOptionsFromXML ( ) { $ options = array ( ) ; foreach ( array ( 'id' , 'horiz-adv-x' ) as $ key ) { if ( isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ $ key ] ) ) { $ options [ $ key ] = ( string ) $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ $ key ] ; } } foreach ( array ( 'units-per-em' , 'ascent' , 'descent' , 'x-height' , 'cap-height' ) as $ key ) { if ( isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ $ key ] ) ) { $ options [ $ key ] = ( string ) $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ $ key ] ; } } return $ options ; }
2536	protected function getWsdlIdFor ( $ messageName ) { $ msgAndVer = $ this -> getMessagesAndVersions ( ) ; if ( isset ( $ msgAndVer [ $ messageName ] ) && isset ( $ msgAndVer [ $ messageName ] [ 'wsdl' ] ) ) { return $ msgAndVer [ $ messageName ] [ 'wsdl' ] ; } return null ; }
12404	public function transaction ( ) { $ transaction_id = Parser :: beginTransaction ( $ this -> connection ) ; $ connection = clone $ this -> connection ; $ connection -> transactionId = $ transaction_id ; return new Service ( $ connection ) ; }
4574	public function getProperties ( Localizable $ model ) : array { $ class = get_class ( $ model ) ; if ( substr ( $ class , 0 , 15 ) === 'Proxies\\__CG__\\' ) { $ class = substr ( $ class , 15 ) ; } $ properties = [ ] ; $ reflection = new ReflectionClass ( $ class ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Locale :: class ) ; if ( ! $ annotation ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
6881	public function reverseTransform ( $ address ) { if ( null === $ address ) { return null ; } if ( ! $ address instanceof ShipmentAddress ) { throw new InvalidArgumentException ( "Expected instance of " . ShipmentAddress :: class ) ; } $ data = [ ] ; foreach ( $ this -> fields as $ field ) { $ value = $ this -> accessor -> getValue ( $ address , $ field ) ; if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof CountryInterface ) { $ value = $ value -> getId ( ) ; } elseif ( $ value instanceof StateInterface ) { $ value = $ value -> getId ( ) ; } elseif ( $ value instanceof PhoneNumber ) { $ value = serialize ( $ value ) ; } $ data [ $ field ] = $ value ; } if ( empty ( $ data ) ) { return null ; } return $ data ; }
9916	public function configure ( array $ modelConfigurations ) { if ( empty ( $ modelConfigurations ) ) { throw new \ LogicException ( 'Supply at least one model or model configuration!' ) ; } foreach ( $ modelConfigurations as $ className ) { $ modelClass = $ className ; if ( is_subclass_of ( $ className , 'Illuminate\Database\Eloquent\Model' ) ) { $ config = new ModelConfig ( ) ; $ config -> setModelClass ( $ modelClass ) ; } else if ( is_subclass_of ( $ className , 'Label305\AujaLaravel\Config\ModelConfig' ) ) { $ config = new $ className ( ) ; $ modelClass = $ config -> getModelClass ( ) ; } else { throw new \ InvalidArgumentException ( "Model configuration should be class name string of either a ModelConfig or Eloquent subclass." ) ; } $ model = new Model ( $ modelClass ) ; $ this -> models [ $ modelClass ] = $ model ; $ this -> relations [ $ modelClass ] = [ ] ; $ configResolver = new ConfigResolver ( $ config , $ model ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; $ this -> findColumns ( $ this -> models [ $ modelClass ] ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; } $ this -> findRelations ( array_values ( $ this -> models ) ) ; }
7797	protected function statementNumber ( $ text ) { if ( $ line = $ this -> getLine ( '60F' , $ text ) ) { if ( preg_match ( '/(C|D)(\d{6})([A-Z]{3})([0-9,]{1,15})/' , $ line , $ match ) ) { return $ match [ 2 ] ; } } return null ; }
9740	public function getPrintArea ( $ index = 0 ) { if ( $ index == 0 ) { return $ this -> printArea ; } $ printAreas = explode ( ',' , $ this -> printArea ) ; if ( isset ( $ printAreas [ $ index - 1 ] ) ) { return $ printAreas [ $ index - 1 ] ; } throw new PhpSpreadsheetException ( 'Requested Print Area does not exist' ) ; }
2930	public function getValue ( $ key ) { $ allKeys = $ this -> getKeys ( [ $ key ] ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return $ allKeys [ $ key ] [ 'value' ] ; } throw new KeyNotFoundException ( 'Requested key not found in your file.' ) ; }
9007	public function sort ( ) { $ this -> uasort ( function ( $ a , $ b ) { $ priority_a = ( int ) $ a -> get ( 'priority' ) ? : 500 ; $ priority_b = ( int ) $ b -> get ( 'priority' ) ? : 500 ; if ( $ priority_a == $ priority_b ) { return 0 ; } return ( $ priority_a < $ priority_b ) ? - 1 : 1 ; } ) ; return $ this ; }
2981	private function findLastImportedPath ( $ yamlContents ) { $ data = Yaml :: parse ( $ yamlContents ) ; if ( ! isset ( $ data [ 'imports' ] ) ) { return false ; } $ lastImport = end ( $ data [ 'imports' ] ) ; if ( ! isset ( $ lastImport [ 'resource' ] ) ) { return false ; } return $ lastImport [ 'resource' ] ; }
3187	public function end ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'end() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; } else { \ common_Logger :: t ( 'Range already closed, or missing START TimePoint in QtiTimer, continue anyway' ) ; } return $ this ; }
11094	public static function getDateFromBirthNumber ( $ no ) { if ( ! preg_match ( '#^\s*(\d\d)(\d\d)(\d\d)[ /]*(\d\d\d)(\d?)\s*$#' , $ no , $ matches ) ) { return null ; } list ( , $ year , $ month , $ day , $ ext , $ c ) = $ matches ; if ( $ c === '' ) { $ year += $ year < 54 ? 1900 : 1800 ; } else { $ mod = ( $ year . $ month . $ day . $ ext ) % 11 ; if ( $ mod === 10 ) { $ mod = 0 ; } if ( $ mod !== ( int ) $ c ) { return null ; } $ year += $ year < 54 ? 2000 : 1900 ; } if ( $ year > 2003 ) { if ( $ month > 70 ) { $ month -= 70 ; } if ( $ month > 20 && $ month < 50 ) { $ month -= 20 ; } } if ( $ month > 50 ) { $ month -= 50 ; } return new DateTime ( sprintf ( '%04d-%02d-%02d' , $ year , $ month , $ day ) ) ; }
281	private function confirmUnload ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be unloaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be unloaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } return $ this -> confirm ( "\nUnload fixtures?" ) ; }
4175	public function getProviders ( ) { return $ this -> providers ? : $ this -> providers = new ServiceProvider ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
9666	private function writeFill ( XMLWriter $ objWriter , Fill $ pFill ) { if ( $ pFill -> getFillType ( ) === Fill :: FILL_GRADIENT_LINEAR || $ pFill -> getFillType ( ) === Fill :: FILL_GRADIENT_PATH ) { $ this -> writeGradientFill ( $ objWriter , $ pFill ) ; } elseif ( $ pFill -> getFillType ( ) !== null ) { $ this -> writePatternFill ( $ objWriter , $ pFill ) ; } }
5510	public function expectAt ( $ timing , $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments at time' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments at time' ) ; $ args = $ this -> replaceWildcards ( $ args ) ; if ( ! isset ( $ this -> expected_args_at [ $ timing ] ) ) { $ this -> expected_args_at [ $ timing ] = array ( ) ; } $ method = strtolower ( $ method ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args_at [ $ timing ] [ $ method ] = new ParametersExpectation ( $ args , $ message ) ; }
12488	public static function write ( $ output ) { if ( self :: $ enabled ) { $ d = new \ DateTime ( ) ; $ f = new File ( self :: $ logFilePath , true ) ; $ f -> write ( $ d -> format ( 'd/m/Y H:i:s' ) . ' - ' . $ output . "\n" , true ) ; } }
2931	public function setKeys ( $ data ) { foreach ( $ data as $ setter ) { if ( array_key_exists ( 'key' , $ setter ) ) { $ key = $ this -> formatter -> formatKey ( $ setter [ 'key' ] ) ; $ value = array_key_exists ( 'value' , $ setter ) ? $ setter [ 'value' ] : null ; $ comment = array_key_exists ( 'comment' , $ setter ) ? $ setter [ 'comment' ] : null ; $ export = array_key_exists ( 'export' , $ setter ) ? $ setter [ 'export' ] : false ; if ( ! is_file ( $ this -> filePath ) || ! $ this -> keyExists ( $ key ) ) { $ this -> writer -> appendSetter ( $ key , $ value , $ comment , $ export ) ; } else { $ oldInfo = $ this -> getKeys ( [ $ key ] ) ; $ comment = is_null ( $ comment ) ? $ oldInfo [ $ key ] [ 'comment' ] : $ comment ; $ this -> writer -> updateSetter ( $ key , $ value , $ comment , $ export ) ; } } } return $ this ; }
3181	public function getMaximumRemainingTime ( ) { if ( ( $ timeLimits = $ this -> getSource ( ) -> getTimeLimits ( ) ) !== null && ( $ maxTime = $ timeLimits -> getMaxTime ( ) ) !== null ) { return $ this -> getRemainingTimeFrom ( $ maxTime ) ; } return false ; }
1814	public function listImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=list' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a>' ; }
6279	public function firstkey ( ) { $ this -> keyIterPos = 4 ; if ( ! $ this -> keyIterStop ) { $ pos = INF ; for ( $ i = 0 ; $ i < 2048 ; $ i += 8 ) { $ pos = min ( $ this -> readInt31 ( $ i ) , $ pos ) ; } $ this -> keyIterStop = $ pos ; } $ this -> keyIterPos = 2048 ; return $ this -> nextkey ( ) ; }
12015	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a MULTI/EXEC transaction over aggregate connections.' ) ; } if ( ! $ client -> getCommandFactory ( ) -> supportsCommands ( array ( 'MULTI' , 'EXEC' , 'DISCARD' ) ) ) { throw new NotSupportedException ( 'MULTI, EXEC and DISCARD are not supported by the current command factory.' ) ; } }
12084	public function getObject ( Entity $ subject ) { $ object = NULL ; $ mediaObjectURI = $ subject -> getObjectURI ( ) ; if ( ! empty ( $ mediaObjectURI ) ) : $ mediaSubject = new Object ( ) ; $ mediaObjectType = $ subject -> getObjectType ( ) ; if ( is_object ( $ mediaSubject ) && method_exists ( $ mediaSubject , "getArray" ) ) : $ object = $ mediaSubject :: getArray ( ) ; endif ; else : endif ; return $ object ; }
11062	public static function isEncodingSupported ( $ encoding ) { $ encoding = strtolower ( $ encoding ) ; if ( isset ( static :: supportedEncodings ( ) [ $ encoding ] ) ) { return true ; } return false ; }
9121	public function retrieveHeaders ( ) : array { $ this -> setHeader ( 'Connection' , 'close' ) ; $ this -> setHeader ( 'Accept' , '' ) ; $ this -> setHeader ( 'Accept-Language' , '' ) ; $ this -> setHeader ( 'User-Agent' , '' ) ; $ savedProto = $ this -> protocol ; $ this -> protocol = 'HTTP/1.0' ; $ this -> request ( 'HEAD' ) ; $ this -> protocol = $ savedProto ; return $ this -> getHeaders ( ) ; }
8547	public function setPayWithAmazonEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PayWithAmazonEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7212	public function generateLoginToken ( array $ redirectUrl = null , string $ expireInterval = '1 day' , bool $ addRememberMeCookie = true ) : string { $ data = [ 'url' => $ redirectUrl , 'timestamp' => Time :: now ( ) -> toUnixString ( ) , 'expireInterval' => $ expireInterval , 'addRememberMeCookie' => $ addRememberMeCookie ] ; $ serializedData = serialize ( $ data ) ; $ token = Security :: encrypt ( $ serializedData , $ this -> getKey ( ) , $ this -> getSalt ( ) ) ; return base64_encode ( $ token ) ; }
5813	public function getCMSFields ( ) { $ fields = parent :: getCMSFields ( ) ; $ types = array ( ) ; foreach ( $ this -> service -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } if ( count ( $ types ) ) { $ fields -> replaceField ( 'TagTypes' , $ list = ListboxField :: create ( 'Types' , 'Tag Types' , $ types ) -> setMultiple ( true ) ) ; $ items = is_string ( $ this -> TagTypes ) ? array_keys ( unserialize ( $ this -> TagTypes ) ) : array ( ) ; $ list -> setValue ( $ items ) ; $ list -> setDisabledItems ( $ items ) ; } else { $ fields -> removeByName ( 'TagTypes' ) ; } $ this -> extend ( 'updateFusionTagCMSFields' , $ fields ) ; return $ fields ; }
10985	public static function checkPhpVersion ( ) { $ version = null ; if ( \ defined ( 'PHP_VERSION' ) ) { $ version = PHP_VERSION ; } else { $ version = phpversion ( '' ) ; } if ( strpos ( $ version , '-' ) !== false ) { $ version = substr ( $ version , 0 , strpos ( $ version , '-' ) ) ; } return $ version ; }
3470	public function head ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: head ( $ route ) ) ; }
6708	protected function getReaderFactory ( ) { if ( ! $ this -> readerFactory ) { $ this -> readerFactory = new ReaderFactory ( [ new Json ( ) , new Xml ( ) , ] ) ; } return $ this -> readerFactory ; }
2099	public static function getNumericDateFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> dateFormat != '' && static :: isNumericFormat ( $ objPage -> dateFormat ) ) { return $ objPage -> dateFormat ; } } return Config :: get ( 'dateFormat' ) ; }
2295	public static function getTinyTemplates ( ) { $ strDir = Config :: get ( 'uploadPath' ) . '/tiny_templates' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strDir ) ) { return '' ; } $ arrFiles = array ( ) ; $ arrTemplates = scan ( $ rootDir . '/' . $ strDir ) ; foreach ( $ arrTemplates as $ strFile ) { if ( strncmp ( '.' , $ strFile , 1 ) !== 0 && is_file ( $ rootDir . '/' . $ strDir . '/' . $ strFile ) ) { $ arrFiles [ ] = '{ title: "' . $ strFile . '", url: "' . $ strDir . '/' . $ strFile . '" }' ; } } return implode ( ",\n" , $ arrFiles ) . "\n" ; }
4058	private function drawAttribute ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ type = $ attribute -> get ( 'type' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> attributeFactory -> getIconForType ( $ type ) , $ type , '' , 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = $ attribute -> getName ( ) ; $ colName = $ attribute -> getColName ( ) ; $ isUnique = $ attribute -> get ( 'isunique' ) ; } else { $ type = 'unknown ID: ' . $ model -> getProperty ( 'attr_id' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = 'unknown attribute' ; $ colName = 'unknown column' ; $ isUnique = false ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong><span class="mandatory">%s</span> <span class="tl_class">%s</span> </div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ colName , $ type , $ image , $ name , $ model -> getProperty ( 'mandatory' ) || $ isUnique ? ' [' . $ this -> trans ( 'mandatory.0' ) . ']' : '' , $ model -> getProperty ( 'tl_class' ) ? sprintf ( '[%s]' , $ model -> getProperty ( 'tl_class' ) ) : '' ] ) ; }
299	public function beforeSave ( $ insert ) { $ event = new ModelEvent ( ) ; $ this -> trigger ( $ insert ? self :: EVENT_BEFORE_INSERT : self :: EVENT_BEFORE_UPDATE , $ event ) ; return $ event -> isValid ; }
3758	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; $ values = Helper :: encodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( $ values ) ; }
12566	public function sendVideo ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VIDEO , $ message , $ to ) ; }
9614	public function authenticate ( TokenInterface $ token ) { $ user = $ this -> userProvider -> loadUserByApiKey ( $ this -> encoder -> encodePassword ( $ token -> getCredentials ( ) ) ) ; if ( ! $ user || ! ( $ user instanceof UserInterface ) ) { throw new AuthenticationException ( 'Bad credentials' ) ; } $ token = new ApiKeyToken ( $ token -> getCredentials ( ) , $ user -> getRoles ( ) ) ; $ token -> setUser ( $ user ) ; return $ token ; }
2749	public function getVclFile ( $ vclTemplatePath ) { $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) ; $ configFilePath = $ moduleEtcPath . '/' . $ this -> _scopeConfig -> getValue ( self :: FASTLY_CONFIGURATION_PATH ) ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; $ configFilePath = $ directoryRead -> getRelativePath ( $ configFilePath ) ; $ data = $ directoryRead -> readFile ( $ configFilePath ) ; return strtr ( $ data , $ this -> getReplacements ( ) ) ; }
6350	public static function get ( Iterator $ iterator , int $ position ) { Iterators :: advance ( $ iterator , $ position ) ; if ( ! $ iterator -> valid ( ) ) { throw new OutOfBoundsException ( "The requested index '{$position}' is invalid" ) ; } return $ iterator -> current ( ) ; }
9284	private function checkImports ( $ lessPath , $ cssPath , $ callback ) { static $ needsRecompile = false ; if ( $ needsRecompile ) return $ needsRecompile ; $ lessContent = file_get_contents ( $ lessPath ) ; preg_match_all ( '/(?<=@import)\s+"([^"]+)/im' , $ lessContent , $ imports ) ; foreach ( $ imports [ 1 ] as $ import ) { $ importPath = realpath ( dirname ( $ lessPath ) . DIRECTORY_SEPARATOR . $ import ) ; if ( file_exists ( $ importPath ) ) { if ( $ callback ( $ importPath , $ cssPath ) ) { $ needsRecompile = true ; break ; } else $ needsRecompile = $ this -> checkImports ( $ importPath , $ cssPath , $ callback ) ; } } return $ needsRecompile ; }
1899	private function createConfig ( $ size , ImageInterface $ image ) : array { if ( ! \ is_array ( $ size ) ) { $ size = [ 0 , 0 , $ size ] ; } $ config = new ResizeConfiguration ( ) ; if ( isset ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ imageModel = $ this -> framework -> getAdapter ( ImageSizeModel :: class ) ; $ imageSize = $ imageModel -> findByPk ( $ size [ 2 ] ) ; if ( null !== $ imageSize ) { $ config -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; } return [ $ config , null ] ; } if ( ! empty ( $ size [ 0 ] ) ) { $ config -> setWidth ( $ size [ 0 ] ) ; } if ( ! empty ( $ size [ 1 ] ) ) { $ config -> setHeight ( $ size [ 1 ] ) ; } if ( ! isset ( $ size [ 2 ] ) || 1 !== substr_count ( $ size [ 2 ] , '_' ) ) { if ( ! empty ( $ size [ 2 ] ) ) { $ config -> setMode ( $ size [ 2 ] ) ; } return [ $ config , null ] ; } $ config -> setMode ( ResizeConfigurationInterface :: MODE_CROP ) ; return [ $ config , $ this -> getImportantPartFromLegacyMode ( $ image , $ size [ 2 ] ) ] ; }
12677	public function approveRemoval ( $ sourceDir , array $ options , $ username ) { $ this -> init ( $ sourceDir , $ options , $ username ) ; $ targetFilename = sprintf ( '%s/blocks/%s.json' , $ this -> productionDir , $ options [ 'blockname' ] ) ; if ( ! file_exists ( $ targetFilename ) ) { return ; } Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVING_REMOVAL , new BlockApprovingRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; $ this -> filesystem -> remove ( $ targetFilename ) ; $ slotDefinition = $ this -> getSlotDefinition ( $ this -> productionDir ) ; $ blocks = $ slotDefinition [ "blocks" ] ; $ key = array_search ( $ options [ 'blockname' ] , $ blocks ) ; unset ( $ blocks [ $ key ] ) ; $ slotDefinition [ "blocks" ] = $ blocks ; $ this -> saveSlotDefinition ( $ this -> productionDir , $ slotDefinition , $ username ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVED_REMOVAL , new BlockApprovedRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been approved for removal on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
9368	protected function globals ( Configuration $ config ) { $ cookies = $ config -> get ( 'app.http.cookies' , array ( ) ) ; $ files = $ config -> get ( 'app.http.files' , array ( ) ) ; $ get = $ config -> get ( 'app.http.get' , array ( ) ) ; $ post = $ config -> get ( 'app.http.post' , array ( ) ) ; $ server = $ config -> get ( 'app.http.server' , $ this -> server ( ) ) ; return array ( $ server , $ cookies , $ get , $ files , $ post ) ; }
1270	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ quantumViewRequest = $ xml -> appendChild ( $ xml -> createElement ( 'QuantumViewRequest' ) ) ; $ quantumViewRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; if ( null !== $ this -> name || null !== $ this -> beginDateTime || null !== $ this -> fileName ) { $ subscriptionRequest = $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'SubscriptionRequest' ) ) ; if ( null !== $ this -> name ) { $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'Name' , $ this -> name ) ) ; } if ( null !== $ this -> beginDateTime ) { $ dateTimeRange = $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'DateTimeRange' ) ) ; $ dateTimeRange -> appendChild ( $ xml -> createElement ( 'BeginDateTime' , $ this -> beginDateTime ) ) ; $ dateTimeRange -> appendChild ( $ xml -> createElement ( 'EndDateTime' , $ this -> endDateTime ) ) ; } elseif ( null !== $ this -> fileName ) { $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'FileName' , $ this -> fileName ) ) ; } } if ( null !== $ this -> bookmark ) { $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'Bookmark' , $ this -> bookmark ) ) ; } $ request = $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'QVEvents' ) ) ; return $ xml -> saveXML ( ) ; }
10878	public function processForgotten ( string $ hash , string $ password ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { $ values [ 'hash' ] = $ this -> getHash ( $ password ) ; if ( $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ) { return $ this -> update ( $ item [ 'id' ] , $ values ) ; } else { throw new IdentityException ( 'Invalid hash!' ) ; } } else { throw new IdentityException ( 'User does not exist!' ) ; } }
9901	public function parse ( $ formula ) { $ this -> currentCharacter = 0 ; $ this -> formula = $ formula ; $ this -> lookAhead = isset ( $ formula [ 1 ] ) ? $ formula [ 1 ] : '' ; $ this -> advance ( ) ; $ this -> parseTree = $ this -> condition ( ) ; return true ; }
7093	private function checkHierarchyIntegrity ( InvoiceInterface $ invoice ) { if ( null !== $ shipment = $ invoice -> getShipment ( ) ) { if ( $ invoice -> getSale ( ) !== $ shipment -> getSale ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isCredit ( $ invoice ) && ! $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isInvoice ( $ invoice ) && $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } } }
8373	protected function configure ( ) { $ this -> setName ( 'worker/process' ) -> setHidden ( true ) -> setDescription ( 'Runs a given worker' ) -> setDefinition ( new InputDefinition ( [ new InputOption ( 'config' , 'c' , InputOption :: VALUE_REQUIRED , 'A YAML configuration file' ) , new InputOption ( 'jobId' , null , InputOption :: VALUE_REQUIRED , 'A Job UUID' ) , new InputOption ( 'name' , null , InputOption :: VALUE_REQUIRED , 'The queue name to work with. Defaults to `default`.' ) , ] ) ) ; }
30	public function appendPackages ( array $ packages , array $ bucket ) { foreach ( $ packages as $ package ) { $ bucket [ $ package -> getName ( ) ] = $ package ; } return $ bucket ; }
12340	protected function print ( string $ msg , bool $ withTime = true ) : void { $ preMsg = '' ; if ( $ withTime ) { $ preMsg = ( new \ DateTime ( 'now' ) ) -> format ( 'H:i:s' ) . "\t" ; } echo "{$preMsg}{$msg}" . \ PHP_EOL ; }
6268	public function isAcademic ( $ text ) { if ( empty ( $ text ) ) { return false ; } $ domain = $ this -> getDomain ( $ text ) ; if ( $ domain === null ) { return false ; } foreach ( $ this -> getBlacklistedTopLevelDomains ( ) as $ blacklistedDomain ) { $ name = ( string ) $ domain [ 'host' ] ; if ( preg_match ( '/' . preg_quote ( $ blacklistedDomain ) . '$/' , $ name ) ) { return false ; } } if ( in_array ( $ domain [ 'tld' ] , $ this -> getAcademicTopLevelDomains ( ) ) ) { return true ; } if ( $ this -> matchesAcademicDomain ( $ domain ) ) { return true ; } return false ; }
11880	protected function getRunner ( ) { if ( null === $ this -> runner ) { $ this -> runner = new ConsoleApplication ( $ this -> name , $ this -> version , $ this -> description , $ this -> alias ) ; } return $ this -> runner ; }
3753	public function save ( ModelInterface $ objItem , $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } if ( $ objItem instanceof Model ) { $ backupLanguage = $ this -> setLanguage ( $ this -> getCurrentLanguage ( ) ) ; $ objItem -> getItem ( ) -> save ( $ timestamp ) ; $ this -> setLanguage ( $ backupLanguage ) ; return $ objItem ; } throw new \ RuntimeException ( 'ERROR: incompatible object passed to GeneralDataMetaModel::save()' ) ; }
10464	private function deductionForDeletion ( $ connection , $ tableName , $ documentType , $ documentId , $ shopId ) { $ sql = sprintf ( "SELECT `id` FROM {$tableName} WHERE `type` != 'D' AND `document_type` = :documentType AND `document_id` = :documentId AND `status` = :status AND `id` < :id" ) ; $ statement = $ connection -> prepare ( $ sql ) ; $ statement -> execute ( [ 'documentType' => $ documentType , 'documentId' => $ documentId , 'status' => self :: STATUS_NEW , 'id' => $ connection -> lastInsertId ( ) , ] ) ; $ entries = $ statement -> fetchAll ( ) ; foreach ( $ entries as $ entry ) { $ this -> removeRecord ( $ entry [ 'id' ] , [ $ shopId ] ) ; } }
9343	public function addRow ( array $ arr_row ) { if ( count ( $ this -> arr ) == $ this -> size -> rows ) { throw new \ OutOfRangeException ( sprintf ( 'You cannot add another row! Max number of rows is %d' , $ this -> size -> rows ) ) ; } if ( count ( $ arr_row ) != $ this -> size -> cols ) { throw new \ InvalidArgumentException ( 'New row must have same amout of columns than defined into the size matrix' ) ; } $ this -> arr [ ] = $ arr_row ; return $ this ; }
2579	protected function loadCustomerRefs ( $ dkNumber ) { if ( ! is_null ( $ dkNumber ) ) { $ this -> customerRef = new MasterPricer \ CustomerRef ( ) ; $ this -> customerRef -> customerReferences [ ] = new MasterPricer \ CustomerReferences ( $ dkNumber , MasterPricer \ CustomerReferences :: QUAL_AGENCY_GROUPING_ID ) ; } }
5113	public function writeQTime ( $ timestamp ) { if ( $ timestamp instanceof \ DateTime ) { $ msec = $ timestamp -> format ( 'H' ) * 3600000 + $ timestamp -> format ( 'i' ) * 60000 + $ timestamp -> format ( 's' ) * 1000 + ( int ) ( $ timestamp -> format ( '0.u' ) * 1000 ) ; } else { $ msec = round ( ( $ timestamp - strtotime ( 'midnight' , ( int ) $ timestamp ) ) * 1000 ) ; } $ this -> writeUInt ( $ msec ) ; }
11232	public function getLocation ( $ ip = '' , $ baseCurrency = '' , $ renameArrayKeys = false ) { $ params = [ 'ip' => ! $ ip ? $ _SERVER [ 'REMOTE_ADDR' ] : $ ip , 'base_currency' => $ baseCurrency , ] ; $ response = $ this -> client -> get ( 'json.gp' , $ params ) ; $ data = $ this -> handleResponseContent ( $ response , 'json' ) ; if ( $ renameArrayKeys ) { $ tmpData = [ ] ; foreach ( $ data as $ key => $ value ) { $ tmpData [ str_replace ( 'geoplugin_' , '' , $ key ) ] = $ value ; } $ data = $ tmpData ; } return $ data ; }
7190	private function copyAttachment ( Model \ SaleAttachmentInterface $ source , Model \ SaleAttachmentInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'path' , 'title' , 'type' , 'size' , 'internal' , 'createdAt' , 'updatedAt' , ] ) ; }
6774	protected function didDeliveryCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldSameAddress = isset ( $ saleCs [ 'sameAddress' ] ) ? $ saleCs [ 'sameAddress' ] [ 0 ] : $ sale -> isSameAddress ( ) ; if ( $ oldSameAddress ) { $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; } else { $ oldAddress = isset ( $ saleCs [ 'deliveryAddress' ] ) ? $ saleCs [ 'deliveryAddress' ] [ 0 ] : $ sale -> getDeliveryAddress ( ) ; } if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } $ newAddress = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ newAddress ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
10924	private function renderLine ( ) { $ output = [ ] ; $ output [ ] = $ this -> charCross ; if ( count ( $ this -> columns ) > 0 ) { for ( $ columnNumber = 0 ; $ columnNumber < count ( $ this -> columns ) ; $ columnNumber ++ ) { $ output [ ] = $ this -> renderCell ( $ columnNumber , $ this -> charHorizontal , $ this -> charHorizontal ) ; $ output [ ] = $ this -> charCross ; } } return implode ( '' , $ output ) ; }
8906	public function count_by ( ) { $ where = func_get_args ( ) ; $ this -> _set_where ( $ where ) ; $ this -> apply_soft_delete_filter ( ) ; return $ this -> _database -> count_all_results ( $ this -> _table ) ; }
2964	public function performRequest ( $ method , $ path , array $ params = [ ] ) { $ request = $ this -> buildRequest ( $ method , $ path , $ params ) ; try { $ response = $ this -> httpClient -> send ( $ request ) ; $ content = json_decode ( $ response -> getBody ( ) -> getContents ( ) , true ) ; } catch ( ClientException $ ex ) { if ( $ ex -> getResponse ( ) -> getStatusCode ( ) == 401 ) { if ( $ this -> isPsr7Version ( ) ) { $ uri = $ request -> getUri ( ) ; } else { $ uri = $ request -> getUrl ( ) ; } $ message = sprintf ( 'Unauthorized %s Request to %s' , $ request -> getMethod ( ) , $ uri ) ; throw new UnauthorizedRequestException ( $ message ) ; } throw $ ex ; } return $ this -> createResponseFromData ( $ content ) ; }
6989	private function addRate ( $ pair , $ rate ) { if ( ! preg_match ( '~^[A-Z]{3}/[A-Z]{3}$~' , $ pair ) ) { throw new InvalidArgumentException ( "Unexpected currency pair '$pair'." ) ; } if ( ! ( is_float ( $ rate ) && 0 < $ rate ) ) { throw new InvalidArgumentException ( "Unexpected rate '$rate'." ) ; } $ this -> rates [ $ pair ] = $ rate ; return $ this ; }
4015	protected function makeMandatory ( $ field , $ row , $ key ) { $ field [ 'eval' ] [ 'required' ] = false ; if ( empty ( $ field [ 'eval' ] [ 'mandatory' ] ) ) { return $ field ; } if ( is_array ( $ this -> varValue [ $ row ] [ $ key ] ) ) { if ( empty ( $ this -> varValue [ $ row ] [ $ key ] ) ) { $ field [ 'eval' ] [ 'required' ] = true ; } } else { if ( ! strlen ( $ this -> varValue [ $ row ] [ $ key ] ) ) { $ field [ 'eval' ] [ 'required' ] = true ; } } return $ field ; }
8022	public function addField ( $ title , $ value , $ short = false ) { $ this -> fields [ ] = [ 'title' => $ title , 'value' => $ value , 'short' => $ short ] ; }
8811	public function header ( $ key , $ value ) { if ( is_array ( $ key ) && ! empty ( $ key ) ) { foreach ( $ key as $ k => $ v ) { $ this -> headers -> set ( $ k , $ v ) ; } } elseif ( is_string ( $ key ) && ! empty ( $ key ) ) { $ this -> headers -> set ( $ key , $ value ) ; } return $ this ; }
8851	public function PaginatedList ( ) { $ posts = new PaginatedList ( $ this -> blogPosts ) ; if ( $ this -> PostsPerPage > 0 ) $ posts -> setPageLength ( $ this -> PostsPerPage ) ; else $ posts -> setPageLength ( $ this -> getBlogPosts ( ) -> count ( ) ) ; $ start = $ this -> request -> getVar ( $ posts -> getPaginationGetVar ( ) ) ; $ posts -> setPageStart ( $ start ) ; return $ posts ; }
3524	private function fetch ( $ account_id ) { if ( ! $ account_id ) return null ; $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_API . 'stats/accountId/' . $ account_id . '/bulk/window/alltime' , $ this -> access_token ) ; $ this -> display_name = Account :: getDisplayNameFromID ( str_replace ( "-" , "" , $ this -> account_id ) , $ this -> access_token ) ; $ compiledStats = [ ] ; foreach ( $ data as $ stat ) { $ parsed = $ this -> parseStatItem ( $ stat ) ; $ compiledStats = array_merge_recursive ( $ compiledStats , $ parsed ) ; } $ platforms = [ ] ; foreach ( $ compiledStats as $ key => $ platform ) { $ platforms [ $ key ] = new Platform ( $ platform ) ; } return $ platforms ; }
7916	public function initOptions ( ) { Ui :: addCssClasses ( $ this -> options , [ 'ui' , 'message' ] ) ; if ( ! empty ( $ this -> header ) && isset ( $ this -> header [ 'options' ] ) ) { Ui :: addCssClass ( $ this -> header [ 'options' ] , 'header' ) ; } if ( isset ( $ this -> icon ) ) { Ui :: addCssClass ( $ this -> options , 'icon' ) ; } }
2627	public function renderCellTemplate ( $ columnName ) { if ( $ columnName == 'store_id' && isset ( $ this -> _columns [ $ columnName ] ) ) { $ options = $ this -> getOptions ( __ ( '-- Select Store --' ) ) ; $ element = $ this -> elementFactory -> create ( 'select' ) ; $ element -> setForm ( $ this -> getForm ( ) ) -> setName ( $ this -> _getCellInputElementName ( $ columnName ) ) -> setHtmlId ( $ this -> _getCellInputElementId ( '<%- _id %>' , $ columnName ) ) -> setValues ( $ options ) ; return str_replace ( "\n" , '' , $ element -> getElementHtml ( ) ) ; } return parent :: renderCellTemplate ( $ columnName ) ; }
3534	public static function createNewUser ( $ username , $ individualGroupAssignmentOptions = null ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } $ userObjectDb = new static ( ) ; $ userObjectDb -> username = $ username ; $ userObjectDb -> setIndividualGroupAssignmentOptions ( $ individualGroupAssignmentOptions ) ; if ( $ userObjectDb -> queryLdapUserObject ( ) == null ) { $ userObjectDb = null ; } else { $ roles = $ userObjectDb -> updateGroupAssignment ( ) ; if ( count ( $ roles ) > 0 || static :: getGroupAssigmentOptions ( 'LOGIN_POSSIBLE_WITH_ROLE_ASSIGNED_MATCHING_REGEX' , $ userObjectDb -> individualGroupAssignmentOptions ) == null ) { $ userObjectDb -> generateAuthKey ( ) ; $ userObjectDb -> updateAccountStatus ( ) ; $ userObjectDb -> save ( ) ; } else { $ userObjectDb = null ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } return $ userObjectDb ; }
5639	public function paintGroupStart ( $ test_name , $ size ) { if ( ! isset ( $ this -> size ) ) { $ this -> size = $ size ; } if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintHeader ( $ test_name ) ; } $ this -> test_stack [ ] = $ test_name ; }
1774	public function addAttributes ( $ arrAttributes ) { if ( ! \ is_array ( $ arrAttributes ) ) { return ; } foreach ( $ arrAttributes as $ k => $ v ) { $ this -> $ k = $ v ; } }
10006	public function getRibbonXMLData ( $ what = 'all' ) { $ returnData = null ; $ what = strtolower ( $ what ) ; switch ( $ what ) { case 'all' : $ returnData = $ this -> ribbonXMLData ; break ; case 'target' : case 'data' : if ( is_array ( $ this -> ribbonXMLData ) && isset ( $ this -> ribbonXMLData [ $ what ] ) ) { $ returnData = $ this -> ribbonXMLData [ $ what ] ; } break ; } return $ returnData ; }
1223	public function resolve ( $ uri , $ version , $ resource , array $ paramDefs , array $ paramValues ) { foreach ( $ paramValues as $ param => $ value ) { if ( ! array_key_exists ( $ param , $ paramDefs ) ) { throw new \ InvalidArgumentException ( "Unknown uri parameter \"$param\" provided" ) ; } } foreach ( $ paramDefs as $ key => $ def ) { if ( ! isset ( $ paramValues [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ paramValues [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ paramValues ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ paramDefs , $ paramValues ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ paramValues [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ paramValues [ $ key ] , $ paramValues ) ; } } return ( "$uri/" . "$version/" . $ this -> fillPathParams ( $ resource , $ paramValues ) . $ this -> buildQueryParameters ( $ paramValues ) ) ; }
1650	public function getLngs ( ) : array { $ lngs = [ ] ; foreach ( $ this -> points as $ point ) { $ lngs [ ] = $ point -> getLng ( ) ; } return $ lngs ; }
5871	protected static function rationalToDecimal ( array $ components ) { foreach ( $ components as $ key => $ value ) { $ rationalParts = explode ( '/' , $ value ) ; if ( ! empty ( $ rationalParts [ 1 ] ) ) { $ components [ $ key ] = $ rationalParts [ 0 ] / $ rationalParts [ 1 ] ; } else { $ components [ $ key ] = 0 ; } } list ( $ hours , $ minutes , $ seconds ) = $ components ; return $ hours + ( $ minutes / 60 ) + ( $ seconds / 3600 ) ; }
4848	public function destinationsFor ( string $ filePath ) : array { $ filePath = Path :: canonicalize ( $ filePath ) ; $ source = $ this -> matchingSource ( $ filePath ) ; return $ this -> resolveDestinations ( $ filePath , $ source ) ; }
10735	public function setUpper ( $ upper ) : self { if ( ! is_numeric ( $ upper ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, upper, to be a number" ) ; } $ this -> upper = $ upper ; return $ this ; }
4945	public function revoke ( $ resource , $ permission = null , $ build = true ) { if ( self :: PERMISSION_NONE == $ permission || ! $ this -> isAssigned ( $ resource ) ) { return $ this ; } if ( self :: PERMISSION_CHANGE == $ permission ) { return $ this -> grant ( $ resource , self :: PERMISSION_VIEW , $ build ) ; } return $ this -> grant ( $ resource , self :: PERMISSION_NONE , $ build ) ; }
7068	static function getUnits ( ) { return [ static :: PIECE , static :: METER , static :: CENTIMETER , static :: MILLIMETER , static :: INCH , static :: FOOT , static :: KILOGRAM , static :: GRAM , static :: CUBIC_METER , static :: LITER , static :: MILLILITER , static :: DAY , static :: HOUR , static :: MINUTE , static :: SECOND , ] ; }
7518	function parse_comment ( ) { $ this -> pos += 3 ; if ( $ this -> next_pos ( ' , false ) !== self :: TOK_UNKNOWN ) { $ this -> status [ 'comment' ] = $ this -> getTokenString ( 1 , - 1 ) ; -- $ this -> pos ; } else { $ this -> status [ 'comment' ] = $ this -> getTokenString ( 1 , - 1 ) ; $ this -> pos += 2 ; } $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; }
2221	public static function findPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; return static :: findBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
7290	static public function isValidMode ( $ mode , $ throw = true ) { if ( in_array ( $ mode , static :: getModes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( 'Invalid adjustment mode.' ) ; } return false ; }
477	public function renameTable ( $ table , $ newName ) { $ time = $ this -> beginCommand ( "rename table $table to $newName" ) ; $ this -> db -> createCommand ( ) -> renameTable ( $ table , $ newName ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
7047	protected function buildAddressData ( Common \ AddressInterface $ address , string $ locale ) { $ country = Intl :: getRegionBundle ( ) -> getCountryName ( $ address -> getCountry ( ) -> getCode ( ) , $ locale ) ; $ fullName = trim ( $ address -> getFirstName ( ) . ' ' . $ address -> getLastName ( ) ) ; $ data = [ 'company' => $ address -> getCompany ( ) , 'full_name' => $ fullName , 'street' => $ address -> getStreet ( ) , 'complement' => $ address -> getComplement ( ) , 'supplement' => $ address -> getSupplement ( ) , 'postal_code' => $ address -> getPostalCode ( ) , 'city' => $ address -> getCity ( ) , 'country' => $ country , 'state' => '' , 'phone' => $ this -> formatPhoneNumber ( $ address -> getPhone ( ) ) , 'mobile' => $ this -> formatPhoneNumber ( $ address -> getMobile ( ) ) , ] ; if ( $ address instanceof RelayPointInterface ) { $ data [ 'number' ] = $ address -> getNumber ( ) ; } return $ data ; }
7954	public function getSpamStats ( $ ipblock , $ spamstate , $ fromdate , $ todate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ipv4 ) throw new BadMethodCallException ( 'Parameter $ipv4 is missing.' ) ; if ( ! $ fromdate ) throw new BadMethodCallException ( 'Parameter $fromdate is missing.' ) ; if ( ! $ todate ) throw new BadMethodCallException ( 'Parameter $todate is missing.' ) ; try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/' . $ ipv4 . '/stats?from=' . urlencode ( $ fromdate ) . '&to=' . urlencode ( $ todate ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
12003	public function getSessionKey ( $ jsCode ) { $ params = [ 'appid' => $ this -> config [ 'app_id' ] , 'secret' => $ this -> config [ 'secret' ] , 'js_code' => $ jsCode , 'grant_type' => 'authorization_code' , ] ; return $ this -> parseJSON ( 'GET' , [ self :: JSCODE_TO_SESSION , $ params ] ) ; }
6330	private function registerEffect ( string $ type , string $ class ) : void { if ( \ class_exists ( $ class ) ) { $ interfaces = \ class_implements ( $ class ) ; if ( \ in_array ( Effect :: class , $ interfaces , true ) ) { $ this -> effectsMap [ $ type ] = $ class ; } else { throw new ConfigException ( "Class {$class} don't implement interface " . Effect :: class ) ; } } else { throw new ConfigException ( "Class {$class} not found" ) ; } }
5931	public function setDefinition ( $ definition ) { if ( is_array ( $ definition ) ) { $ this -> definition = $ definition ; return $ this ; } $ this -> definition = json_decode ( $ definition , true ) ; if ( null === $ this -> definition ) { $ this -> definition = $ definition ; } return $ this ; }
4576	public function get ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = static :: toModel ( $ object ) ; return $ model ; }
7263	protected function convert ( Model \ SaleInterface $ sale , float $ amount , string $ currency , bool $ round ) { if ( $ currency === $ this -> converter -> getDefaultCurrency ( ) ) { return $ round ? Money :: round ( $ amount , $ currency ) : $ amount ; } if ( null !== $ rate = $ sale -> getExchangeRate ( ) ) { return $ this -> converter -> convertWithRate ( $ amount , $ rate , $ currency , $ round ) ; } $ date = $ this -> contextProvider -> getContext ( $ sale ) -> getDate ( ) ; return $ this -> converter -> convert ( $ amount , $ this -> converter -> getDefaultCurrency ( ) , $ currency , $ date , $ round ) ; }
4520	public function set ( string $ key , $ value ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ parameter -> setKey ( $ key ) -> setValue ( $ value ) ; $ this -> manager -> persist ( $ parameter ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> detach ( $ parameter ) ; }
5945	public function freetext ( $ freetext , $ deploymentSiteIds = null , $ mode = self :: FREETEXT_OR , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'mode' => $ mode , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/freetext/' . $ freetext . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11818	public function setServiceLocator ( ServiceLocatorInterface $ serviceLocator ) { $ this -> serviceLocator = $ serviceLocator ; $ config = $ serviceLocator -> getServiceLocator ( ) -> get ( 'config' ) ; if ( isset ( $ config [ 'rznviewcomponent' ] ) ) { $ this -> config = $ config [ 'rznviewcomponent' ] ; } return $ this ; }
5377	public function getAttribute ( $ label ) { $ label = strtolower ( $ label ) ; if ( ! isset ( $ this -> attributes [ $ label ] ) ) { return false ; } return ( string ) $ this -> attributes [ $ label ] ; }
1216	public static function stableSort ( array $ data , callable $ sortFn ) { array_walk ( $ data , function ( & $ v , $ k ) { $ v = [ $ v , $ k ] ; } ) ; uasort ( $ data , function ( $ a , $ b ) use ( $ sortFn ) { return $ sortFn ( $ a [ 0 ] , $ b [ 0 ] ) ? : ( $ a [ 1 ] < $ b [ 1 ] ? - 1 : 1 ) ; } ) ; return array_map ( function ( $ v ) { return $ v [ 0 ] ; } , array_values ( $ data ) ) ; }
12630	public function pay ( Order $ order ) { return $ this -> request ( $ this -> wrapApi ( self :: API_PAY_ORDER ) , $ order -> all ( ) ) ; }
12750	public function getUserAlias4User ( UserInterface $ user ) { if ( ! isset ( $ this -> userAliasCache [ $ user -> getUsername ( ) ] ) ) { $ userAliasEntityTmp = $ this -> getUserAliasEntity4User ( $ user ) ; if ( ! $ userAliasEntityTmp ) { $ userAliasEntityTmp = false ; } $ this -> userAliasCache [ $ user -> getUsername ( ) ] = $ userAliasEntityTmp ; } $ userAliasEntity = $ this -> userAliasCache [ $ user -> getUsername ( ) ] ; if ( $ userAliasEntity ) { $ result = $ userAliasEntity -> getCharName ( ) ; } else { $ result = $ user -> getUsername ( ) ; } return $ result ; }
11015	public static function sec2time ( $ seconds ) { $ sec = intval ( $ seconds ) ; $ dtF = new \ DateTime ( "@0" ) ; $ dtT = new \ DateTime ( "@$sec" ) ; return $ dtF -> diff ( $ dtT ) -> format ( '%a days, %h hours, %i minutes and %s seconds' ) ; }
425	protected function addErrorClassIfNeeded ( & $ options ) { $ attributeName = Html :: getAttributeName ( $ this -> attribute ) ; if ( $ this -> model -> hasErrors ( $ attributeName ) ) { Html :: addCssClass ( $ options , $ this -> form -> errorCssClass ) ; } }
8322	public function getLoad ( $ paramsList = [ 'waiting' , 'load' , 'minbid' , 'averageRecognitionTime' ] ) { $ parser = $ this -> getLoadXml ( ) ; if ( is_string ( $ paramsList ) ) { return $ parser -> $ paramsList -> __toString ( ) ; } $ statusData = [ ] ; foreach ( $ paramsList as $ item ) { $ statusData [ $ item ] = $ parser -> $ item -> __toString ( ) ; } return $ statusData ; }
1977	public function onPreviewUrlCreate ( PreviewUrlCreateEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || 'news' !== $ event -> getKey ( ) ) { return ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_news' === $ request -> query -> get ( 'table' ) && ! $ request -> query -> has ( 'act' ) ) { return ; } if ( null === ( $ newsModel = $ this -> getNewsModel ( $ this -> getId ( $ event , $ request ) ) ) ) { return ; } $ event -> setQuery ( 'news=' . $ newsModel -> id ) ; }
3403	protected function loadFromYml ( $ file ) { $ this -> parser = new Parser ( $ file ) ; $ this -> parser -> load ( $ this ) ; }
9116	public function registerView ( $ view , $ order = null , $ applicationName = 'default' ) { if ( ! class_exists ( $ view ) ) { throw new ViewException ( "No such view class {view} found" , array ( 'view' => $ view ) ) ; } $ v = new $ view ( ) ; if ( ! $ v instanceof View ) { throw new ViewException ( "View {view} is not in application scope" , array ( 'view' => $ view ) ) ; } $ viewOrder = $ v -> getOrder ( ) ; if ( null !== $ order ) { $ viewOrder = intval ( $ order ) ; } $ settings = $ v -> getViewSettings ( ) ; $ this -> views [ $ applicationName ] [ $ viewOrder ] [ $ settings -> getViewSimpleName ( ) ] = $ settings ; return $ this ; }
3323	protected function consumeOptionToken ( Option $ spec , $ arg , $ next , & $ success = false ) { if ( $ spec -> isFlag ( ) ) { if ( $ spec -> isIncremental ( ) ) { $ spec -> increaseValue ( ) ; } else { $ spec -> setValue ( true ) ; } return 0 ; } else if ( $ spec -> isRequired ( ) ) { if ( $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> setValue ( $ next -> arg ) ; return 1 ; } else { throw new RequireValueException ( "Option '{$arg->getOptionName()}' requires a value." ) ; } } else if ( $ spec -> isMultiple ( ) ) { if ( $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ this -> pushOptionValue ( $ spec , $ arg , $ next ) ; return 1 ; } } else if ( $ spec -> isOptional ( ) && $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> setValue ( $ next -> arg ) ; return 1 ; } return 0 ; }
5608	public function after ( $ method ) { $ this -> invoker -> after ( $ method ) ; $ output = ob_get_contents ( ) ; ob_end_clean ( ) ; if ( $ output !== '' ) { $ result = $ this -> listener -> write ( '{status:"info",message:"' . EclipseReporter :: escapeVal ( $ output ) . '"}' ) ; } }
3350	private function __getPath ( $ type , $ params = array ( ) ) { switch ( $ type ) { case 'root' : return '/' ; case 'account' : return '/account/' ; case 'file_list' : return '/files/' . $ this -> __getQueryString ( $ params , '?' ) ; case 'file_storage' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/files/%s/storage/' , $ params [ 'uuid' ] ) ; case 'file_copy' : return '/files/' ; case 'files_storage' : return '/files/storage/' ; case 'file' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/files/%s/' , $ params [ 'uuid' ] ) ; case 'group_list' : return '/groups/' . $ this -> __getQueryString ( $ params , '?' ) ; case 'group' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/groups/%s/' , $ params [ 'uuid' ] ) ; case 'group_storage' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/groups/%s/storage/' , $ params [ 'uuid' ] ) ; default : throw new \ Exception ( 'No api url type is provided for request "' . $ type . '". Use store, or appropriate constants.' ) ; } }
10905	public function getList ( $ asStrings = false ) { $ list = scandir ( $ this -> path ) ; if ( $ asStrings === true ) { return array_diff ( $ list , [ "." , ".." ] ) ; } $ ret = [ ] ; foreach ( $ list as $ name ) { if ( $ name === "." || $ name === ".." ) { continue ; } $ path = $ this -> path . DIRECTORY_SEPARATOR . $ name ; $ ret [ ] = ( is_dir ( $ path ) ) ? new static ( $ path ) : new FileEntity ( $ path ) ; } return $ ret ; }
4713	public function replace ( $ pattern , $ replacement ) { if ( is_callable ( $ replacement ) ) { $ this -> text = preg_replace_callback ( $ pattern , function ( $ matches ) use ( $ replacement ) { $ args = array_map ( function ( $ item ) { return new Text ( $ item ) ; } , $ matches ) ; return call_user_func_array ( $ replacement , $ args ) ; } , $ this -> text ) ; } else { $ this -> text = preg_replace ( $ pattern , $ replacement , $ this -> text ) ; } return $ this ; }
3425	public function getById ( $ id ) { if ( ! $ id || $ this -> queryShouldBeStopped ) { return false ; } $ this -> sort = [ ] ; $ this -> filter [ 'ID' ] = $ id ; return $ this -> getList ( ) -> first ( null , false ) ; }
7155	private function nullDateIfLowerThanToday ( \ DateTime $ eda = null ) { if ( null === $ eda ) { return null ; } $ today = new \ DateTime ( ) ; $ today -> setTime ( 0 , 0 , 0 ) ; if ( $ eda < $ today ) { return null ; } return $ eda ; }
517	public function actionFresh ( ) { if ( YII_ENV_PROD ) { $ this -> stdout ( "YII_ENV is set to 'prod'.\nRefreshing migrations is not possible on production systems.\n" ) ; return ExitCode :: OK ; } if ( $ this -> confirm ( "Are you sure you want to reset the database and start the migration from the beginning?\nAll data will be lost irreversibly!" ) ) { $ this -> truncateDatabase ( ) ; $ this -> actionUp ( ) ; } else { $ this -> stdout ( 'Action was cancelled by user. Nothing has been performed.' ) ; } }
4358	protected function processSubstitutions ( $ args , & $ hasSubs ) { $ subRegex = '/%' . '(?:' . '[coO]|' . '[+-]?' . '(?:[ 0]|\'.{1})?' . '-?' . '\d*' . '(?:\.\d+)?' . '[difs]' . ')' . '/' ; if ( ! \ is_string ( $ args [ 0 ] ) ) { return $ args ; } $ index = 0 ; $ indexes = array ( 'c' => array ( ) , ) ; $ hasSubs = false ; $ args [ 0 ] = \ preg_replace_callback ( $ subRegex , function ( $ matches ) use ( & $ args , & $ hasSubs , & $ index , & $ indexes ) { $ hasSubs = true ; $ index ++ ; $ replacement = $ matches [ 0 ] ; $ type = \ substr ( $ matches [ 0 ] , - 1 ) ; if ( \ strpos ( 'difs' , $ type ) !== false ) { $ format = $ matches [ 0 ] ; $ sub = $ args [ $ index ] ; if ( $ type == 'i' ) { $ format = \ substr_replace ( $ format , 'd' , - 1 , 1 ) ; } elseif ( $ type === 's' ) { $ sub = $ this -> substitutionAsString ( $ sub ) ; } $ replacement = \ sprintf ( $ format , $ sub ) ; } elseif ( $ type === 'c' ) { $ asHtml = \ get_called_class ( ) == __NAMESPACE__ . '\\Html' ; if ( ! $ asHtml ) { return '' ; } $ replacement = '' ; if ( $ indexes [ 'c' ] ) { $ replacement = '</span>' ; } $ replacement .= '<span' . $ this -> debug -> utilities -> buildAttribString ( array ( 'style' => $ args [ $ index ] , ) ) . '>' ; $ indexes [ 'c' ] [ ] = $ index ; } elseif ( \ strpos ( 'oO' , $ type ) !== false ) { $ replacement = $ this -> dump ( $ args [ $ index ] ) ; } return $ replacement ; } , $ args [ 0 ] ) ; if ( $ indexes [ 'c' ] ) { $ args [ 0 ] .= '</span>' ; } if ( $ hasSubs ) { $ args = array ( $ args [ 0 ] ) ; } return $ args ; }
9696	function createTransactions ( $ transactions , $ release = true , $ ignoreInvalidEvents = false ) { $ queryParameters = array ( 'release' => ( $ release == true ) ? 'true' : 'false' , 'ignore_invalid_transactions' => ( $ ignoreInvalidEvents == true ) ? 'true' : 'false' ) ; $ data = JSONSerializer :: json_encode ( $ transactions ) ; $ result = $ this -> post ( "transactions" , $ data , $ queryParameters , "application/json" , 'com_maileon_api_transactions_ProcessingReports' ) ; return $ result ; }
12666	public function edit ( $ sourceDir , array $ options , $ username , $ values ) { $ this -> resolveOptions ( $ options ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ filename = sprintf ( '%s/blocks/%s.json' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ currentBlock = $ options [ "baseBlock" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; $ values = $ this -> parseChildren ( $ values ) ; $ block = JsonTools :: join ( $ currentBlock , $ values ) ; $ encodedBlock = json_encode ( $ block ) ; $ blockClass = BlockFactory :: getBlockClass ( $ block [ "type" ] ) ; $ event = Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITING , new BlockEditingEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; $ blockContent = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ filename , $ blockContent ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITED , new BlockEditedEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been edited on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
5426	private function forceToExpectation ( $ exception ) { if ( $ exception === false ) { return new AnythingExpectation ( ) ; } if ( ! SimpleExpectation :: isExpectation ( $ exception ) ) { return new ExceptionExpectation ( $ exception ) ; } return $ exception ; }
12722	protected function turnIntoResolvableClosure ( $ abstract , $ concrete ) { return function ( Container $ container , $ parameters = [ ] ) use ( $ abstract , $ concrete ) { return ( $ abstract == $ concrete ? $ container -> resolve ( $ abstract ) : $ container -> resolve ( $ concrete , $ parameters ) ) ; } ; }
8081	public function error ( $ message ) { if ( $ message ) { if ( is_int ( $ message ) && isset ( $ this -> errorList [ $ message ] ) ) { $ errorMessage = $ this -> errorList [ $ message ] ; $ this -> report ( "Error[{$message}]: {$errorMessage}" ) ; } else { $ errorMessage = $ message ; $ this -> report ( "Error: {$errorMessage}" ) ; } $ errors = & $ this -> getErrors ( ) ; $ errors [ ] = $ errorMessage ; } return $ this ; }
2148	public function removeSubscriptions ( $ intUser , $ strMode ) { if ( ! $ intUser ) { return ; } if ( $ strMode == 'close_delete' ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } else { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active='' WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } }
3456	public static function fromString ( string $ aggregateTypeString ) : AggregateType { if ( empty ( $ aggregateTypeString ) ) { throw new Exception \ InvalidArgumentException ( 'AggregateType must be a non empty string' ) ; } $ self = new static ( ) ; $ self -> aggregateType = $ aggregateTypeString ; return $ self ; }
8127	public static function findByUsernameOrEmail ( $ emailOrUsername ) { if ( filter_var ( $ emailOrUsername , FILTER_VALIDATE_EMAIL ) ) { return UserIdentity :: findByEmail ( $ emailOrUsername ) ; } return UserIdentity :: findByUsername ( $ emailOrUsername ) ; }
12938	public function setMin ( $ value ) { $ this -> setTag ( 'min' , $ value ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'min' , $ value ) ; } }
9732	public function writeFont ( ) { $ font_outline = 0 ; $ font_shadow = 0 ; $ icv = $ this -> colorIndex ; if ( $ this -> font -> getSuperscript ( ) ) { $ sss = 1 ; } elseif ( $ this -> font -> getSubscript ( ) ) { $ sss = 2 ; } else { $ sss = 0 ; } $ bFamily = 0 ; $ bCharSet = \ PhpOffice \ PhpSpreadsheet \ Shared \ Font :: getCharsetFromFontName ( $ this -> font -> getName ( ) ) ; $ record = 0x31 ; $ reserved = 0x00 ; $ grbit = 0x00 ; if ( $ this -> font -> getItalic ( ) ) { $ grbit |= 0x02 ; } if ( $ this -> font -> getStrikethrough ( ) ) { $ grbit |= 0x08 ; } if ( $ font_outline ) { $ grbit |= 0x10 ; } if ( $ font_shadow ) { $ grbit |= 0x20 ; } $ data = pack ( 'vvvvvCCCC' , $ this -> font -> getSize ( ) * 20 , $ grbit , $ icv , self :: mapBold ( $ this -> font -> getBold ( ) ) , $ sss , self :: mapUnderline ( $ this -> font -> getUnderline ( ) ) , $ bFamily , $ bCharSet , $ reserved ) ; $ data .= StringHelper :: UTF8toBIFF8UnicodeShort ( $ this -> font -> getName ( ) ) ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
6657	protected function createFailSafeResponse ( ) { $ status = new Status ( 500 ) ; $ response = new Response ( ) ; $ response -> setRequest ( new Request ( ) ) ; $ response -> setWriter ( new Json ( ) ) ; $ response -> setStatus ( $ status ) ; $ response -> setBodyData ( $ status -> getMessage ( ) ) ; return $ response ; }
8788	public function style ( $ url , $ attributes = [ ] , $ secure = null ) { $ defaults = [ 'media' => 'all' , 'type' => 'text/css' , 'rel' => 'stylesheet' ] ; $ attributes = array_merge ( $ attributes , $ defaults ) ; $ attributes [ 'href' ] = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> toHtmlString ( '<link' . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL ) ; }
8752	public function addDefinition ( $ identifier , DefinitionInterface $ definition ) { $ this -> definitions [ $ identifier ] = $ definition ; unset ( $ this -> dumpableDefinitions [ $ identifier ] ) ; }
7431	public static function getInstance ( ) : MimeType { if ( null === self :: $ instance ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
2396	protected function unixToHex ( $ intTime = 0 ) { $ arrTime = $ intTime ? getdate ( $ intTime ) : getdate ( ) ; $ hexTime = dechex ( ( ( $ arrTime [ 'year' ] - 1980 ) << 25 ) | ( $ arrTime [ 'mon' ] << 21 ) | ( $ arrTime [ 'mday' ] << 16 ) | ( $ arrTime [ 'hours' ] << 11 ) | ( $ arrTime [ 'minutes' ] << 5 ) | ( $ arrTime [ 'seconds' ] >> 1 ) ) ; return pack ( "H*" , $ hexTime [ 6 ] . $ hexTime [ 7 ] . $ hexTime [ 4 ] . $ hexTime [ 5 ] . $ hexTime [ 2 ] . $ hexTime [ 3 ] . $ hexTime [ 0 ] . $ hexTime [ 1 ] ) ; }
283	private function findFixtures ( array $ fixtures = [ ] ) { $ fixturesPath = $ this -> getFixturePath ( ) ; $ filesToSearch = [ '*Fixture.php' ] ; $ findAll = ( $ fixtures === [ ] ) ; if ( ! $ findAll ) { $ filesToSearch = [ ] ; foreach ( $ fixtures as $ fileName ) { $ filesToSearch [ ] = $ fileName . 'Fixture.php' ; } } $ files = FileHelper :: findFiles ( $ fixturesPath , [ 'only' => $ filesToSearch ] ) ; $ foundFixtures = [ ] ; foreach ( $ files as $ fixture ) { $ foundFixtures [ ] = $ this -> getFixtureRelativeName ( $ fixture ) ; } return $ foundFixtures ; }
557	protected function buildConjunctionCondition ( $ operator , $ condition ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } $ result = [ $ operator ] ; foreach ( $ condition as $ part ) { $ result [ ] = $ this -> buildCondition ( $ part ) ; } return $ result ; }
7900	public function upload ( $ file , Closure $ callback = null ) { $ uploadedFile = $ this -> runUpload ( $ file ) ; if ( ! $ uploadedFile ) { return false ; } if ( $ callback ) { $ callback ( $ uploadedFile ) ; } return true ; }
8996	protected function buildNamespace ( ApiDefinition $ definition , $ namespace ) { if ( $ this -> config [ 'version_in_namespace' ] && $ definition -> getVersion ( ) ) { $ namespace .= '\\' . preg_replace ( array ( '/(^[0-9])/' , '/[^a-zA-Z0-9]/' ) , array ( 'Version\1' , '_' ) , $ definition -> getVersion ( ) ) ; } return $ namespace ; }
7751	protected function loadMetadata ( $ className ) { if ( false === isset ( $ this -> loadedMetadata [ $ className ] ) ) { if ( null === ( $ class = $ this -> driver -> loadMetadataForClass ( $ className ) ) ) { throw new \ Exception ( "Can't load metadata for $className" ) ; } $ this -> completeMetadata ( $ class ) ; $ this -> loadedMetadata [ $ className ] = $ class ; } return $ this -> loadedMetadata [ $ className ] ; }
2506	public static function exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , $ xpath ) { WsdlAnalyser :: loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) ; return self :: $ wsdlDomXpath [ $ wsdlId ] -> evaluate ( $ xpath ) ; }
5395	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'exception>' ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "exception>\n" ; }
9413	public static function instance ( array $ server ) { $ secure = isset ( $ server [ 'HTTPS' ] ) ? $ server [ 'HTTPS' ] : 'off' ; $ http = $ secure === 'off' ? 'http' : 'https' ; $ url = $ http . '://' . $ server [ 'SERVER_NAME' ] ; $ url .= ( string ) $ server [ 'SERVER_PORT' ] ; return new Uri ( $ url . $ server [ 'REQUEST_URI' ] ) ; }
1952	public static function findBySourceParentAndEmail ( $ strSource , $ intParent , $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findOneBy ( array ( "$t.source=? AND $t.parent=? AND $t.email=?" ) , array ( $ strSource , $ intParent , $ strEmail ) , $ arrOptions ) ; }
7984	public function getCurrentMonitoring ( $ domain , $ type ) { $ type = strtolower ( $ type ) ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! in_array ( $ type , array ( 'cpu:max' , 'cpu:used' , 'mem:max' , 'mem:used' , 'net:rx' , 'net:tx' ) ) ) throw new BadMethodCallException ( 'Parameter $type must be "cpu:max" or "cpu:used" or "mem:max" or "mem:used" or "net:rx" or "net:tx". "' . $ type . '" given.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/use?type=' . $ type ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
9912	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> fields ) ) { $ this -> fields = array ( ) ; foreach ( $ xmlElement -> fields -> children ( ) as $ field ) { $ this -> fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
4398	protected function getTransactionReference ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ base ) { $ code = $ this -> getServiceItem ( ) -> getCode ( ) ; $ service = $ base -> getService ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT , $ code ) ; return $ service -> getAttribute ( 'TRANSACTIONID' , 'payment/omnipay' ) ; }
11742	public function add ( Theme $ theme , array $ pageValues ) { $ pageName = $ pageValues [ "name" ] ; $ pageDir = $ this -> pagesDir . '/' . $ pageName ; $ this -> pageExists ( $ pageDir ) ; if ( ! @ mkdir ( $ pageDir ) ) { $ this -> folderNotCreated ( $ pageDir ) ; } $ seoValues = $ pageValues [ "seo" ] ; unset ( $ pageValues [ "seo" ] ) ; $ encodedPage = json_encode ( $ pageValues ) ; $ pageFile = $ pageDir . '/' . $ this -> pageFile ; $ event = Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDING , new PageCollectionAddingEvent ( $ pageFile , $ encodedPage ) ) ; $ encodedPage = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ pageFile , $ encodedPage ) ; if ( $ this -> pageFile != 'page.json' ) { FilesystemTools :: writeFile ( $ pageDir . '/page.json' , $ encodedPage ) ; } foreach ( $ seoValues as $ seoValue ) { $ languageName = $ seoValue [ "language" ] ; unset ( $ seoValue [ "language" ] ) ; $ languageDir = $ pageDir . '/' . $ languageName ; @ mkdir ( $ languageDir ) ; FilesystemTools :: writeFile ( $ languageDir . '/' . $ this -> seoFile , json_encode ( $ seoValue ) ) ; $ theme -> addTemplateSlots ( $ pageValues [ "template" ] , $ this -> username ) ; } Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDED , new PageCollectionAddedEvent ( $ pageFile , $ encodedPage ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully added to the website' , $ pageName ) ) ; return $ pageValues ; }
8459	public function getVersion ( ) { if ( empty ( $ this -> drushVersion ) ) { $ isPrinted = $ this -> isPrinted ; $ this -> isPrinted = false ; $ result = $ this -> executeCommand ( $ this -> executable . ' version' ) ; $ output = $ result -> getMessage ( ) ; $ this -> drushVersion = 'unknown' ; if ( preg_match ( '#[0-9.]+#' , $ output , $ matches ) ) { $ this -> drushVersion = $ matches [ 0 ] ; } $ this -> isPrinted = $ isPrinted ; } return $ this -> drushVersion ; }
6873	protected function buildItem ( SaleItemInterface $ saleItem , ShipmentInterface $ shipment ) { if ( $ saleItem -> isCompound ( ) ) { $ available = $ expected = null ; foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { if ( null !== $ child = $ this -> buildItem ( $ childSaleItem , $ shipment ) ) { $ saleItemQty = $ childSaleItem -> getQuantity ( ) ; $ e = $ child -> getExpected ( ) / $ saleItemQty ; if ( null === $ expected || $ expected > $ e ) { $ expected = $ e ; } $ a = $ child -> getAvailable ( ) / $ saleItemQty ; if ( null === $ available || $ available > $ a ) { $ available = $ a ; } } } if ( 0 < $ expected ) { return $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected , $ available ) ; } return null ; } $ item = null ; if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ expected = $ shipment -> isReturn ( ) ? $ this -> calculator -> calculateReturnableQuantity ( $ saleItem , $ shipment ) : $ this -> calculator -> calculateShippableQuantity ( $ saleItem , $ shipment ) ; if ( 0 < $ expected ) { $ item = $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected ) ; } } if ( $ saleItem -> hasChildren ( ) ) { foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { $ this -> buildItem ( $ childSaleItem , $ shipment ) ; } } return $ item ; }
7240	private function resolveClassAndCreateObject ( $ type , $ subject ) { foreach ( $ this -> classes [ $ type ] as $ source => $ target ) { if ( $ subject instanceof $ source ) { return new $ target ; } } throw new InvalidArgumentException ( 'Unsupported object class.' ) ; }
7182	protected function generateKey ( PaymentInterface $ payment ) { if ( 0 == strlen ( $ payment -> getKey ( ) ) ) { $ this -> keyGenerator -> generate ( $ payment ) ; return true ; } return false ; }
10892	public function isPrime ( ) { if ( $ this -> value < 2 ) { return false ; } if ( $ this -> value === 2 ) { return true ; } if ( $ this -> isEven ( ) ) { return false ; } for ( $ i = 3 ; $ i <= ceil ( sqrt ( $ this -> value ) ) ; $ i = $ i + 2 ) { if ( $ this -> value % $ i == 0 ) { return false ; } } return true ; }
12257	public function getProjectSearchPaths ( string $ name ) : array { $ srcPaths = $ this -> getProject ( ) -> getAttribute ( AttributeInterface :: SEARCH_PATHS_ATTR_NAME ) ; if ( $ srcPaths instanceof SearchPathCollection ) { return $ srcPaths -> getSearchPaths ( $ name ) ?? [ ] ; } return [ ] ; }
3142	public function skip ( RunnerServiceContext $ context , $ scope , $ ref ) { return $ this -> move ( $ context , 'skip' , $ scope , $ ref ) ; }
3016	public function reblogPost ( $ blogName , $ postId , $ reblogKey , $ options = null ) { $ params = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; $ params = array_merge ( $ options ? : array ( ) , $ params ) ; $ path = $ this -> blogPath ( $ blogName , '/post/reblog' ) ; return $ this -> postRequest ( $ path , $ params , false ) ; }
4148	protected function findExceptions ( $ response ) { $ response = $ response [ 'body' ] ; $ data = json_decode ( $ response , true ) ; if ( isset ( $ response [ 0 ] ) && $ response [ 0 ] !== '{' && $ response [ 0 ] !== '[' && ! $ data ) { if ( strpos ( $ response , 'oauth_token=' ) !== false ) { parse_str ( $ response , $ data ) ; } if ( empty ( $ data ) || ! is_array ( $ data ) ) { throw new TwitterException ( $ response , 0 ) ; } return json_encode ( $ data ) ; } if ( ! empty ( $ data [ 'errors' ] ) || ! empty ( $ data [ 'error' ] ) ) { if ( ! empty ( $ data [ 'errors' ] ) ) { $ data = current ( $ data [ 'errors' ] ) ; } if ( empty ( $ data [ 'message' ] ) && ! empty ( $ data [ 'error' ] ) ) { $ data [ 'message' ] = $ data [ 'error' ] ; } if ( ! isset ( $ data [ 'code' ] ) || empty ( $ data [ 'code' ] ) ) { $ data [ 'code' ] = 0 ; } throw new TwitterException ( $ data [ 'message' ] , $ data [ 'code' ] ) ; } unset ( $ data ) ; return $ response ; }
3458	public function extend ( $ module ) : void { if ( is_object ( $ module ) || class_exists ( $ module ) ) { $ this -> modules [ ] = $ module ; } else { throw ApplicationException :: forInvalidModule ( $ module ) ; } }
10351	public function channel ( string $ channel_id ) : EventChannelInterface { if ( isset ( $ this -> channel_adapters [ $ channel_id ] ) ) { return $ this -> channel_adapters [ $ channel_id ] ; } $ adapter = new Stk2kEventChannelAdapter ( $ this -> eventstream -> channel ( $ channel_id , function ( ) { return new SimpleEventSource ( ) ; } , function ( ) { return new WildCardEventEmitter ( ) ; } ) ) ; $ this -> channel_adapters [ $ channel_id ] = $ adapter ; return $ adapter ; }
12539	public static function dasherize ( $ str , $ replacement = '_' ) { return preg_replace_callback ( '/([A-Z0-9-\s]+)/' , function ( $ match ) use ( $ replacement ) { return $ replacement . strtolower ( $ match [ 1 ] ) ; } , lcfirst ( $ str ) ) ; }
6768	protected function handleContentChange ( SaleInterface $ sale ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; if ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed = $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } $ changed |= $ this -> saleUpdater -> updateTotals ( $ sale ) ; $ changed |= $ this -> updateState ( $ sale ) ; $ changed |= $ this -> saleUpdater -> updateOutstandingDate ( $ sale ) ; return $ changed ; }
181	public function getConverter ( ) { if ( $ this -> _converter === null ) { $ this -> _converter = Yii :: createObject ( AssetConverter :: className ( ) ) ; } elseif ( is_array ( $ this -> _converter ) || is_string ( $ this -> _converter ) ) { if ( is_array ( $ this -> _converter ) && ! isset ( $ this -> _converter [ 'class' ] ) ) { $ this -> _converter [ 'class' ] = AssetConverter :: className ( ) ; } $ this -> _converter = Yii :: createObject ( $ this -> _converter ) ; } return $ this -> _converter ; }
6065	public function listSocialMediaFiles ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/socialmedia/files' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new DeploymentFile ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11864	public function save ( string $ sessionIdentifier , string $ sessionData ) : void { self :: $ files [ $ sessionIdentifier ] = [ 'data' => $ sessionData , 'time' => microtime ( true ) ] ; }
5899	public function listFunctionalities ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/functionalities' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Functionality ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11246	public function getMigrations ( int $ steps ) : array { $ sql = "select migration from {$this->table} where batch >= 1 order by batch, migration desc limit ?" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> bindParam ( 1 , $ steps , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
7561	protected function parse_sibling ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_CONTAINS_WORD ) ; } else { return ( $ this -> token = self :: TOK_SIBLING ) ; } }
6198	public function parseGets ( ) { $ request = preg_replace ( '!' . $ this -> uri . '(.*)$!i' , '$1' , $ _SERVER [ 'REQUEST_URI' ] ) ; if ( defined ( 'MOD_REWRITE' ) and MOD_REWRITE === true ) { if ( substr ( $ request , - 1 ) != '/' ) { $ request .= '/' ; } $ parseUrl = $ this -> parseUrl ( $ request ) ; $ this -> namespace = $ parseUrl [ 'v' ] [ 'namespace' ] ?? '' ; parse_str ( $ parseUrl [ 'sVars' ] , $ gets ) ; $ this -> controller = ! empty ( $ gets [ 'task' ] ) ? $ gets [ 'task' ] : $ this -> routeMap [ 'NAME_CONTROLLER' ] ; unset ( $ gets [ 'task' ] ) ; $ this -> action = ! empty ( $ gets [ 'action' ] ) ? $ gets [ 'action' ] : $ this -> routeMap [ 'NAME_METHOD' ] ; unset ( $ gets [ 'action' ] ) ; $ _GET = array_merge ( $ _GET , $ gets ) ; } else { $ this -> controller = ! empty ( $ _GET [ 'task' ] ) ? $ _GET [ 'task' ] : $ this -> routeMap [ 'NAME_CONTROLLER' ] ; $ this -> action = ! empty ( $ _GET [ 'action' ] ) ? $ _GET [ 'action' ] : $ this -> routeMap [ 'NAME_METHOD' ] ; } $ _GET [ 'task' ] = $ this -> controller ; $ _GET [ 'action' ] = $ this -> action ; }
6096	public function memberOf ( ) { $ groups = array ( $ this -> getParent ( ) -> channelGroupGetById ( $ this [ "client_channel_group_id" ] ) ) ; foreach ( explode ( "," , $ this [ "client_servergroups" ] ) as $ sgid ) { $ groups [ ] = $ this -> getParent ( ) -> serverGroupGetById ( $ sgid ) ; } return $ groups ; }
11515	public function getNamedParam ( string $ category , string $ key ) { $ params = $ this -> getNamedParams ( $ category ) ; return $ params [ $ key ] ?? '' ; }
3396	public function toMail ( $ notifiable ) { return ( new MailMessage ) -> subject ( __ ( 'confirmation::confirmation.confirmation_subject' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_subject_title' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_body' ) ) -> action ( __ ( 'confirmation::confirmation.confirmation_button' ) , url ( "register/confirm/$notifiable->confirmation_code" ) ) ; }
10880	public function renderPreviousExceptions ( $ exception ) { if ( ( $ previous = $ exception -> getPrevious ( ) ) !== null ) { return $ this -> renderFile ( $ this -> previousExceptionView , [ 'exception' => $ previous ] ) ; } else { return '' ; } }
4199	public function addConstants ( Event $ abs ) { if ( ! $ this -> abstracter -> getCfg ( 'collectConstants' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; $ constants = $ reflector -> getConstants ( ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ constants = \ array_merge ( $ reflector -> getConstants ( ) , $ constants ) ; } if ( $ this -> abstracter -> getCfg ( 'objectSort' ) == 'name' ) { \ ksort ( $ constants ) ; } $ abs [ 'constants' ] = $ constants ; }
2858	public function layoutUpdatesAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; } $ layoutUpdates = $ requestProfile -> getDesign ( ) -> getLayoutUpdates ( ) ; $ this -> renderArray ( $ layoutUpdates , 'No Data' , array ( '#' , 'XML' ) ) ; }
988	public function activate ( ) { if ( ! $ this -> chargeId ) { throw new Exception ( 'Can not activate plan without a charge ID.' ) ; } $ this -> response = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}/{$this->chargeId}/activate.json" ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ this -> response ; }
11343	public function addField ( FormField $ field ) { $ this -> fields [ ] = $ field ; if ( $ field -> getName ( ) == null ) { $ field -> setName ( 'name_' . count ( $ this -> fields ) ) ; } if ( $ field -> getId ( ) == null ) { $ field -> setId ( 'id_' . count ( $ this -> fields ) ) ; } if ( $ field instanceof FileField ) { $ this -> formTags [ 'enctype' ] = 'multipart/form-data' ; } }
9240	public function renderLanguageSwitcher ( ) { return $ this -> _View -> element ( $ this -> config ( 'element' ) , [ 'availableLanguages' => $ this -> config ( 'availableLanguages' ) , 'displayNames' => $ this -> config ( 'displayNames' ) , 'imageMapping' => $ this -> config ( 'imageMapping' ) , 'renderToggleButtonDisplayName' => $ this -> config ( 'renderToggleButtonDisplayName' ) ] ) ; }
11725	public function assign ( string $ key , $ value , bool $ global = false ) { if ( $ global === false ) { $ this -> vars [ $ key ] = $ value ; } else { View :: $ global_vars [ $ key ] = $ value ; } return $ this ; }
10626	public static function docroot ( ) { if ( ! empty ( $ _SERVER [ 'DOCUMENT_ROOT' ] ) ) { $ docroot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; } else { $ docroot = str_replace ( '\\' , '/' , dirname ( __FILE__ ) ) ; } return $ docroot ; }
10918	public function getUserEntity ( $ identity , $ credential ) { $ credential = $ this -> preProcessCredential ( $ credential ) ; $ userObject = NULL ; $ fields = $ this -> getOptions ( ) -> getAuthIdentityFields ( ) ; while ( ! is_object ( $ userObject ) && count ( $ fields ) > 0 ) { $ mode = array_shift ( $ fields ) ; switch ( $ mode ) { case 'username' : $ userObject = $ this -> getMapper ( ) -> findByUsername ( $ identity ) ; break ; case 'email' : $ userObject = $ this -> getMapper ( ) -> findByEmail ( $ identity ) ; break ; } } if ( ! $ userObject ) { return null ; } $ bcrypt = new Bcrypt ( ) ; $ bcrypt -> setCost ( $ this -> getOptions ( ) -> getPasswordCost ( ) ) ; if ( ! $ bcrypt -> verify ( $ credential , $ userObject -> getPassword ( ) ) ) { return null ; } return $ userObject ; }
5446	protected function addInTagTokens ( ) { $ this -> mapHandler ( 'tag' , 'acceptStartToken' ) ; $ this -> addSpecialPattern ( '\s+' , 'tag' , 'ignore' ) ; $ this -> addAttributeTokens ( ) ; $ this -> addExitPattern ( '/>' , 'tag' ) ; $ this -> addExitPattern ( '>' , 'tag' ) ; }
9217	protected function parsePageLinks ( $ headers = false ) { $ pagination = [ ] ; if ( ! $ headers ) { $ headers = $ this -> api -> lastHeader ( 'link' ) ; } if ( preg_match_all ( '%<([^>]*)>\s*;\s*rel="([^"]+)"%' , $ headers , $ links , PREG_SET_ORDER ) ) { foreach ( $ links as $ link ) { $ pagination [ $ link [ 2 ] ] = new CanvasPageLink ( $ link [ 1 ] , $ link [ 2 ] ) ; } } return $ pagination ; }
6024	public function setMetadata ( array $ metadata ) { $ this -> metadata = [ ] ; foreach ( $ metadata as $ item ) { $ this -> addMetaData ( $ item ) ; } return $ this ; }
12500	public static function update ( $ id , $ document , $ connection ) { $ from = $ connection -> db ; if ( strpos ( $ from , '.' ) !== false ) { $ tmp = explode ( '.' , $ connection -> db ) ; $ from = end ( $ tmp ) ; } $ connection -> method = 'PATCH' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; switch ( gettype ( $ document ) ) { case "string" : $ connection -> query = $ document ; break ; case "array" : case "object" : $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; $ connection -> query = 'UPDATE ' . $ from . '["' . $ id . '"] SET ' . self :: updateRecursion ( $ document ) ; break ; default : throw new ClusterpointException ( "\"->update()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid format." , 9002 ) ; break ; } return self :: sendQuery ( $ connection ) ; }
7076	private function addDiscountDetails ( array & $ details , Model \ SaleAdjustmentInterface $ discount ) { $ discountResult = $ discount -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ discount -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = '-' . $ this -> format ( $ discountResult -> getTotal ( ) ) ; $ this -> line ++ ; return - $ discountResult -> getTotal ( ) ; }
2532	protected function loadOptionalSegmentInformation ( $ options ) { if ( ! empty ( $ options -> operatingCompany ) ) { $ this -> segmentInformation -> companyDetails -> operatingCompany = $ options -> operatingCompany ; } if ( $ options -> arrivalDate instanceof \ DateTime ) { $ this -> segmentInformation -> flightDate -> setArrivalDate ( $ options -> arrivalDate ) ; } if ( ! empty ( $ options -> groupNumber ) ) { $ this -> segmentInformation -> flightTypeDetails = new FlightTypeDetails ( $ options -> groupNumber ) ; } $ this -> loadAdditionalSegmentDetails ( $ options -> airplaneCode , $ options -> nrOfStops ) ; }
8099	protected function validateAll ( $ includeAllRules = false ) { if ( $ includeAllRules ) { $ fieldData = new Collection ( array_fill_keys ( array_keys ( $ this -> _validations -> toArray ( ) ) , null ) ) ; $ fieldData -> update ( $ this -> _updates -> toArray ( ) ) ; } else { $ fieldData = clone $ this -> _updates ; } foreach ( $ fieldData -> toArray ( ) as $ field => $ val ) { $ field2 = $ field . '2' ; if ( ! is_null ( $ fieldData -> $ field2 ) ) { if ( $ val != $ fieldData -> $ field2 ) { $ this -> log -> formError ( $ field , ucfirst ( $ field ) . 's did not match' ) ; } else { $ this -> log -> report ( ucfirst ( $ field ) . 's matched' ) ; } } if ( $ this -> _updates -> $ field ) { $ this -> _updates -> $ field = trim ( $ val ) ; } if ( $ validation = $ this -> _validations -> $ field ) { $ this -> validate ( $ field , $ validation -> limit , $ validation -> regEx ) ; } } return ! $ this -> log -> hasError ( ) ; }
6752	public static function getCallable ( Logger $ logger , $ type , $ maxMessageLength ) { return function ( MessageInterface $ message ) use ( $ logger , $ type , $ maxMessageLength ) { $ startMessage = null ; if ( $ message instanceof RequestInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getMethod ( ) , $ message -> getRequestTarget ( ) ) ; } elseif ( $ message instanceof ResponseInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getStatusCode ( ) , $ message -> getReasonPhrase ( ) ) ; } if ( ! is_null ( $ startMessage ) ) { $ logger -> log ( Logger :: INFO , $ startMessage ) ; } foreach ( $ message -> getHeaders ( ) as $ name => $ value ) { $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s header: %s => %s" , $ type , $ name , implode ( ', ' , $ value ) ) ) ; } $ body = $ message -> getBody ( ) ; if ( strlen ( $ body ) > $ maxMessageLength ) { $ body = substr ( $ body , 0 , $ maxMessageLength ) . '[TRUNCATED]' ; } $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s body: %s" , $ type , $ body ) ) ; if ( ! is_null ( $ message ) && $ message -> getBody ( ) -> isSeekable ( ) ) { $ message -> getBody ( ) -> rewind ( ) ; } return $ message ; } ; }
2398	public static function changeSubscriptionStatus ( FrontendTemplate $ objTemplate ) { if ( strncmp ( Input :: get ( 'token' ) , 'com-' , 4 ) === 0 ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) != 1 || key ( $ arrRelated ) != 'tl_comments_notify' || \ count ( $ arrIds = current ( $ arrRelated ) ) != 1 || ( ! $ objNotify = CommentsNotifyModel :: findByPk ( $ arrIds [ 0 ] ) ) ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objNotify -> email ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ objNotify -> active = '1' ; $ objNotify -> save ( ) ; $ optInToken -> confirm ( ) ; $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_optInConfirm' ] ; } elseif ( strncmp ( Input :: get ( 'token' ) , 'cor-' , 4 ) === 0 ) { $ objNotify = CommentsNotifyModel :: findOneByTokenRemove ( Input :: get ( 'token' ) ) ; if ( $ objNotify === null ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } $ objNotify -> delete ( ) ; $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_optInCancel' ] ; } }
11172	public static function encrypt ( $ data , $ key , $ cipher = MCRYPT_RIJNDAEL_128 , $ mode = MCRYPT_MODE_CBC ) { $ data = serialize ( $ data ) ; $ key = hash ( 'sha256' , $ key , true ) ; $ iv_size = mcrypt_get_iv_size ( $ cipher , $ mode ) ; $ iv = mcrypt_create_iv ( $ iv_size , MCRYPT_RAND ) ; return base64_encode ( serialize ( array ( $ iv , mcrypt_encrypt ( $ cipher , $ key , $ data , $ mode , $ iv ) ) ) ) ; }
272	public function asJson ( $ data ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> format = Response :: FORMAT_JSON ; $ response -> data = $ data ; return $ response ; }
9220	protected function requestAllPages ( $ forceRefresh = false ) { $ _page = $ this -> page ; $ _key = $ this -> key ; $ nextPageNumber = false ; if ( isset ( $ this -> pagination [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> pagination [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } while ( $ nextPageNumber !== false ) { $ this -> requestPageNumber ( $ nextPageNumber , $ forceRefresh ) ; if ( isset ( $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } else { $ nextPageNumber = false ; } } $ this -> page = $ _page ; $ this -> key = $ _key ; }
2708	public function afterSave ( \ Magento \ Config \ Model \ Config $ subject ) { if ( $ this -> purge ) { $ this -> api -> cleanBySurrogateKey ( [ 'text' ] ) ; } }
8608	public function registerDestination ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_RegisterDestinationInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/RegisterDestinationInput.php' ) ; $ request = new MWSSubscriptionsService_Model_RegisterDestinationInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'RegisterDestination' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/RegisterDestinationResponse.php' ) ; $ response = MWSSubscriptionsService_Model_RegisterDestinationResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10976	public function sendVerification ( ) { $ this -> setVerificationCode ( $ this -> createVerificationCode ( ) ) ; $ user = & $ this ; return Mail :: queue ( Config :: get ( 'verifier.template' ) , [ 'user' => $ this ] , function ( $ message ) use ( $ user ) { $ message -> to ( $ user -> email , $ user -> getVerificationEmailName ( ) ) -> subject ( $ user -> getVerificationEmailSubject ( ) ) ; } ) ; }
2157	public function generate ( ) { if ( $ this -> youtube == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://youtu.be/' . $ this -> youtube . '" target="_blank" rel="noreferrer noopener">youtu.be/' . $ this -> youtube . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
3720	protected function validator ( $ varInput ) { if ( is_array ( $ varInput ) ) { $ value = array ( ) ; foreach ( $ varInput as $ key => $ input ) { $ value [ $ key ] = parent :: validator ( $ input ) ; } return $ value ; } return parent :: validator ( trim ( $ varInput ) ) ; }
6085	public function retrieveMoodboard ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/moodboards/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
4740	protected static function _clear ( $ fileName , $ filePath ) { if ( ! in_array ( $ fileName , [ '.' , '..' , '.gitkeep' , '.htaccess' ] ) ) { if ( is_file ( $ filePath ) ) { @ unlink ( $ filePath ) ; } else { self :: clearTmp ( $ filePath ) ; } } }
4628	protected function prepareRequestUrl ( ) { $ protocol = $ this -> node -> useTls ( ) ? 'https' : 'http' ; $ this -> requestURL = sprintf ( '%s://%s%s?%s' , $ protocol , $ this -> node -> getUri ( ) , $ this -> path , $ this -> query ) ; $ this -> options [ CURLOPT_URL ] = $ this -> requestURL ; return $ this ; }
12441	public function attach ( $ key , $ instance , $ type = self :: OBJECT ) { switch ( $ type ) { case self :: OBJECT : case self :: CACHE : if ( ! is_object ( $ instance ) ) { throw new \ LogicException ( 'Instance is not an object!' ) ; } break ; case self :: DATABASE : if ( ! ( $ instance instanceof \ PDO ) ) { throw new \ LogicException ( ) ; } break ; } if ( isset ( $ this -> instances [ $ key ] ) ) { return $ this ; } $ this -> instances [ $ key ] = $ instance ; return $ this ; }
436	public function afterAction ( $ action , $ result ) { $ event = new ActionEvent ( $ action ) ; $ event -> result = $ result ; $ this -> trigger ( self :: EVENT_AFTER_ACTION , $ event ) ; return $ event -> result ; }
4771	public function status ( Request $ request , WidgetInterface $ widget , string $ widgetId , bool $ status = true ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'status' => $ status ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
10131	private function writeObjectProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } if ( ! $ this -> phpSheet -> getProtection ( ) -> getObjects ( ) ) { return ; } $ record = 0x0063 ; $ length = 0x0002 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , 1 ) ; $ this -> append ( $ header . $ data ) ; }
5215	private function getAnnotatedBinding ( \ ReflectionClass $ class ) { $ annotations = annotationsOf ( $ class ) ; if ( $ class -> isInterface ( ) && $ annotations -> contain ( 'ImplementedBy' ) ) { return $ this -> bind ( $ class -> getName ( ) ) -> to ( $ this -> findImplementation ( $ annotations , $ class -> getName ( ) ) ) ; } elseif ( $ annotations -> contain ( 'ProvidedBy' ) ) { return $ this -> bind ( $ class -> getName ( ) ) -> toProviderClass ( $ annotations -> firstNamed ( 'ProvidedBy' ) -> getProviderClass ( ) ) ; } return $ this -> getImplicitBinding ( $ class ) ; }
4003	protected function isPublishedItem ( $ objMetaModel , $ intItemId ) { $ statement = $ this -> connection -> prepare ( 'SELECT colname FROM tl_metamodel_attribute WHERE pid=? AND check_publish=1 LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ objMetaModel -> get ( 'id' ) ) ; $ statement -> execute ( ) ; if ( $ statement -> rowCount ( ) > 0 ) { $ objAttrCheckPublish = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ; $ objItem = $ objMetaModel -> findById ( $ intItemId ) ; if ( ! $ objItem -> get ( $ objAttrCheckPublish -> colname ) ) { return false ; } } return true ; }
4171	public function askPackageKey ( $ summary , $ message = 'Please provide an id' ) { $ this -> table ( [ 'id' , 'name' ] , $ summary ) ; $ selected = $ this -> ask ( $ message ) ; $ key = collect ( $ summary ) -> pluck ( 'id' ) -> search ( $ selected ) ; if ( $ key === false ) { $ this -> warn ( 'Invalid package name or id given.' ) ; return $ this -> askPackageKey ( $ summary , 'Please provide a valid id' ) ; } return $ key ; }
6480	private function getSetCookieHeaderValue ( Cookie $ cookie ) : string { $ headerValue = "{$cookie->getName()}=" . urlencode ( $ cookie -> getValue ( ) ) ; if ( ( $ expiration = $ cookie -> getExpiration ( ) ) !== null ) { $ headerValue .= '; Expires=' . $ expiration -> format ( self :: EXPIRATION_DATE_FORMAT ) ; } if ( ( $ maxAge = $ cookie -> getMaxAge ( ) ) !== null ) { $ headerValue .= "; Max-Age=$maxAge" ; } if ( ( $ domain = $ cookie -> getDomain ( ) ) !== null ) { $ headerValue .= '; Domain=' . urlencode ( $ domain ) ; } if ( ( $ path = $ cookie -> getPath ( ) ) !== null ) { $ headerValue .= '; Path=' . urlencode ( $ path ) ; } if ( $ cookie -> isSecure ( ) ) { $ headerValue .= '; Secure' ; } if ( $ cookie -> isHttpOnly ( ) ) { $ headerValue .= '; HttpOnly' ; } if ( ( $ sameSite = $ cookie -> getSameSite ( ) ) !== null ) { $ headerValue .= '; SameSite=' . urlencode ( $ sameSite ) ; } return $ headerValue ; }
11963	private function setParam ( $ key , $ value , $ allowed_keys ) { if ( in_array ( $ key , $ allowed_keys ) ) { $ this -> { $ key } = $ value ; } }
8556	private function fromDOMElement ( DOMElement $ dom ) { $ xpath = new DOMXPath ( $ dom -> ownerDocument ) ; $ xpath -> registerNamespace ( 'a' , 'http://mws.amazonaws.com/doc/2009-01-01/' ) ; foreach ( $ this -> fields as $ fieldName => $ field ) { $ fieldType = $ field [ 'FieldType' ] ; if ( is_array ( $ fieldType ) ) { if ( $ this -> isComplexType ( $ fieldType [ 0 ] ) ) { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length >= 1 ) { foreach ( $ elements as $ element ) { $ this -> fields [ $ fieldName ] [ 'FieldValue' ] [ ] = new $ fieldType [ 0 ] ( $ element ) ; } } } else { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length >= 1 ) { foreach ( $ elements as $ element ) { $ text = $ xpath -> query ( './text()' , $ element ) ; $ this -> fields [ $ fieldName ] [ 'FieldValue' ] [ ] = $ text -> item ( 0 ) -> data ; } } } } else { if ( $ this -> isComplexType ( $ fieldType ) ) { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length == 1 ) { $ this -> fields [ $ fieldName ] [ 'FieldValue' ] = new $ fieldType ( $ elements -> item ( 0 ) ) ; } } else { $ element = $ xpath -> query ( "./a:$fieldName/text()" , $ dom ) ; $ data = null ; if ( $ element -> length == 1 ) { switch ( $ this -> fields [ $ fieldName ] [ 'FieldType' ] ) { case 'DateTime' : $ data = new DateTime ( $ element -> item ( 0 ) -> data , new DateTimeZone ( 'UTC' ) ) ; break ; case 'bool' : $ value = $ element -> item ( 0 ) -> data ; $ data = $ value === 'true' ? true : false ; break ; default : $ data = $ element -> item ( 0 ) -> data ; break ; } $ this -> fields [ $ fieldName ] [ 'FieldValue' ] = $ data ; } } } } }
7714	function switchToRelative ( ) { $ this -> FindEndTag ( ) ; $ this -> rel_Txt = & $ this -> Txt ; $ this -> rel_PosBeg = $ this -> PosBeg ; $ this -> rel_Len = $ this -> GetLen ( ) ; $ src = $ this -> GetSrc ( ) ; $ this -> Txt = & $ src ; $ this -> _ApplyDiffToAll ( - $ this -> PosBeg ) ; }
6396	public function run ( ) : void { $ thrownException = null ; try { $ this -> lock -> lock ( ) ; try { $ this -> runnable -> run ( ) ; } catch ( Exception $ e ) { self :: getLogger ( ) -> error ( $ e ) ; $ thrownException = $ e ; } $ this -> lock -> unLock ( ) ; } catch ( LockException $ e ) { throw new RunException ( 'Lock error during running.' , 0 , $ e ) ; } if ( $ thrownException !== null ) { throw new RunException ( 'Error during execution wrapped Runnable object.' , 0 , $ thrownException ) ; } }
6309	public function drop ( DatabaseObjectInterface $ databaseObject , $ cascade = false ) { $ command = $ this -> getCommand ( $ databaseObject , false ) ; if ( $ cascade ) { $ command -> cascade ( ) ; } return $ command -> execute ( ) ; }
8717	public static function forceCreate ( array $ attributes , $ translations = [ ] ) { $ model = new static ; return static :: unguarded ( function ( ) use ( $ model , $ attributes , $ translations ) { return $ model -> create ( $ attributes , $ translations ) ; } ) ; }
2458	public function undo ( ) { $ objRecords = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; if ( $ objRecords -> numRows < 1 ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ error = false ; $ query = $ objRecords -> query ; $ data = StringUtil :: deserialize ( $ objRecords -> data ) ; if ( ! \ is_array ( $ data ) ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } $ arrFields = array ( ) ; foreach ( $ data as $ table => $ fields ) { $ this -> loadDataContainer ( $ table ) ; if ( ! isset ( $ arrFields [ $ table ] ) ) { $ arrFields [ $ table ] = array_flip ( $ this -> Database -> getFieldNames ( $ table ) ) ; } foreach ( $ fields as $ row ) { $ row = array_intersect_key ( $ row , $ arrFields [ $ table ] ) ; $ objInsertStmt = $ this -> Database -> prepare ( "INSERT INTO " . $ table . " %s" ) -> set ( $ row ) -> execute ( ) ; if ( $ objInsertStmt -> affectedRows < 1 ) { $ error = true ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'onundo_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'onundo_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ table , $ row , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ table , $ row , $ this ) ; } } } } } if ( ! $ error ) { $ this -> log ( 'Undone ' . $ query , __METHOD__ , TL_GENERAL ) ; $ this -> Database -> prepare ( "DELETE FROM " . $ this -> strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> intId ) ; } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
3531	public static function sendFortniteGetRequest ( $ endpoint , $ access_token , $ extra_headers = array ( ) ) { $ client = new Client ( ) ; $ headers = [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ; $ headers = array_merge ( $ headers , $ extra_headers ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => $ headers ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
10074	static function init ( ) { if ( self :: $ initialized == false ) { self :: $ UPDATE = new SynchronizationMode ( 1 ) ; self :: $ IGNORE = new SynchronizationMode ( 2 ) ; self :: $ initialized = true ; } }
9837	public function createSymmetricAuthenticatedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SharedAuthenticationKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricAuthenticatedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
1845	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objCalendar = CalendarModel :: findByProtected ( '' ) ; if ( $ objCalendar !== null ) { while ( $ objCalendar -> next ( ) ) { if ( ! $ objCalendar -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objCalendar -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objCalendar -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objCalendar -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objCalendar -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/events/%s' ) ; } $ strUrl = $ arrProcessed [ $ objCalendar -> jumpTo ] ; $ objEvents = CalendarEventsModel :: findPublishedDefaultByPid ( $ objCalendar -> id ) ; if ( $ objEvents !== null ) { while ( $ objEvents -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objEvents -> alias ? : $ objEvents -> id ) ) ; } } } } return $ arrPages ; }
2959	public function confFlowControl ( $ mode ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set flow control mode : the device is " . "either not set or opened" , E_USER_WARNING ) ; return false ; } $ linuxModes = array ( "none" => "clocal -crtscts -ixon -ixoff" , "rts/cts" => "-clocal crtscts -ixon -ixoff" , "xon/xoff" => "-clocal -crtscts ixon ixoff" ) ; $ windowsModes = array ( "none" => "xon=off octs=off rts=on" , "rts/cts" => "xon=off octs=on rts=hs" , "xon/xoff" => "xon=on octs=off rts=on" , ) ; if ( $ mode !== "none" and $ mode !== "rts/cts" and $ mode !== "xon/xoff" ) { trigger_error ( "Invalid flow control mode specified" , E_USER_ERROR ) ; return false ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " " . $ windowsModes [ $ mode ] , $ out ) ; } if ( $ ret === 0 ) { return true ; } else { trigger_error ( "Unable to set flow control : " . $ out [ 1 ] , E_USER_ERROR ) ; return false ; } }
12894	public function close ( $ account , $ openId ) { $ params = [ 'kf_account' => $ account , 'openid' => $ openId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CLOSE , $ params ] ) ; }
10333	function fromXML ( $ xmlElement ) { parent :: fromXML ( $ xmlElement ) ; if ( isset ( $ xmlElement -> permissionType ) ) $ this -> permission = Permission :: getPermission ( $ xmlElement -> permissionType ) ; if ( isset ( $ xmlElement -> field_backups ) ) $ this -> fieldBackups = XMLDeserializer :: deserialize ( $ xmlElement -> field_backups ) ; }
1860	public function rcopy ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; $ this -> mkdir ( $ strDestination ) ; $ arrFiles = scan ( $ this -> strRootDir . '/' . $ strSource , true ) ; foreach ( $ arrFiles as $ strFile ) { if ( is_dir ( $ this -> strRootDir . '/' . $ strSource . '/' . $ strFile ) ) { $ this -> rcopy ( $ strSource . '/' . $ strFile , $ strDestination . '/' . $ strFile ) ; } else { $ this -> copy ( $ strSource . '/' . $ strFile , $ strDestination . '/' . $ strFile ) ; } } }
11414	public function decryptData ( $ sessionKey , $ iv , $ encrypted ) { try { $ decrypted = openssl_decrypt ( base64_decode ( $ encrypted , true ) , 'aes-128-cbc' , base64_decode ( $ sessionKey , true ) , OPENSSL_RAW_DATA | OPENSSL_NO_PADDING , base64_decode ( $ iv , true ) ) ; } catch ( Exception $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_DECRYPT_AES ) ; } if ( is_null ( $ result = json_decode ( $ this -> decode ( $ decrypted ) , true ) ) ) { throw new EncryptionException ( 'ILLEGAL_BUFFER' , EncryptionException :: ILLEGAL_BUFFER ) ; } return $ result ; }
12693	public function generate ( ) { $ templates = array_merge ( array_keys ( $ this -> templates [ "base" ] ) , array_keys ( $ this -> templates [ "template" ] ) ) ; foreach ( $ templates as $ template ) { $ templateDir = $ this -> themeDir . '/' . $ template ; if ( ! is_dir ( $ templateDir ) ) { continue ; } $ finder = new Finder ( ) ; $ files = $ finder -> files ( ) -> depth ( 0 ) -> in ( $ templateDir ) ; foreach ( $ files as $ file ) { $ file = ( string ) $ file ; $ slotName = basename ( $ file , '.json' ) ; $ json = FilesystemTools :: readFile ( $ file ) ; $ slot = json_decode ( $ json , true ) ; $ blocks = array ( ) ; if ( array_key_exists ( "blocks" , $ slot ) ) { $ blocks = $ slot [ "blocks" ] ; } $ slotManager = $ this -> slotsManagerFactory -> createSlotManager ( $ slot [ "repeat" ] ) ; $ slotManager -> addSlot ( $ slotName , $ blocks ) ; } } }
12787	public static function getPut ( ) { $ aPut = array ( ) ; $ rPutResource = fopen ( "php://input" , "r" ) ; while ( $ sData = fread ( $ rPutResource , 1024 ) ) { $ aSeparatePut = explode ( '&' , $ sData ) ; foreach ( $ aSeparatePut as $ sOne ) { $ aOnePut = explode ( '=' , $ sOne ) ; $ aPut [ $ aOnePut [ 0 ] ] = $ aOnePut [ 1 ] ; } } return $ aPut ; }
8313	protected function beginPasswordReset ( ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ this -> picoAuth -> addAllowed ( "password_reset" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/pwbeginreset.md' ) ; if ( count ( $ this -> session -> getFlash ( '_pwresetsent' ) ) ) { $ this -> picoAuth -> addOutput ( "resetSent" , true ) ; return ; } $ post = $ this -> httpRequest -> request ; if ( $ post -> has ( "reset_email" ) ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ email = trim ( $ post -> get ( "reset_email" ) ) ; if ( ! filter_var ( $ email , FILTER_VALIDATE_EMAIL ) ) { $ this -> session -> addFlash ( "error" , "Email address does not have a valid format." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( ! $ this -> limit -> action ( "passwordReset" , true , array ( "email" => $ email ) ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( $ userData = $ this -> storage -> getUserByEmail ( $ email ) ) { $ this -> sendResetMail ( $ userData ) ; } $ this -> session -> addFlash ( "_pwresetsent" , true ) ; $ this -> session -> addFlash ( "success" , "Reset link sent via email." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
4075	protected function setTableMapping ( $ modelId , $ tableName ) { $ this -> information [ $ tableName ] [ self :: MODELID ] = $ modelId ; $ this -> tableMap [ $ modelId ] = $ tableName ; }
6958	public function setForcedRedirect ( $ url ) { $ data = $ this -> getData ( true ) ; $ data [ static :: $ forcedRedirectKey ] = $ url ; return $ this -> setData ( $ data ) ; }
4914	private function addTraversable ( \ Traversable $ result ) { foreach ( $ result as $ item ) { break ; } if ( ! $ item instanceof EntityInterface ) { throw new \ InvalidArgumentException ( 'Traversable objects must be a non-empty collection of Entity instances.' ) ; } $ name = get_class ( $ item ) ; return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ result , ] ) ; }
3259	public function placeTransaction ( $ gateway , $ transactionId , $ detail = null , $ token = null ) { return call_user_func ( Config :: get ( 'shop.transaction' ) . '::create' , [ 'order_id' => $ this -> attributes [ 'id' ] , 'gateway' => $ gateway , 'transaction_id' => $ transactionId , 'detail' => $ detail , 'token' => $ token , ] ) ; }
7829	public function getLeftBordersWith ( $ border ) { $ border = str_repeat ( $ border , static :: BORDER_WIDTH ) ; $ space = str_repeat ( ' ' , static :: MIN_SPACE_FROM_BORDER_X ) ; return str_repeat ( "{$border}{$space}" , $ this -> nesting ) ; }
9327	protected function registerMarkdownEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md' , 'markdown' ) ; }
1882	protected function getMD5Folders ( $ strPath ) { $ arrFiles = array ( ) ; foreach ( scan ( $ this -> strRootDir . '/' . $ strPath ) as $ strFile ) { if ( ! is_dir ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) ) { continue ; } $ arrFiles [ substr ( md5 ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) , 0 , 8 ) ] = 1 ; foreach ( $ this -> getMD5Folders ( $ strPath . '/' . $ strFile ) as $ k => $ v ) { $ arrFiles [ $ k ] = $ v ; } } return $ arrFiles ; }
2193	protected function sendActivationMail ( $ arrData ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = $ optIn -> create ( 'reg' , $ arrData [ 'email' ] , array ( 'tl_member' => array ( $ arrData [ 'id' ] ) ) ) ; $ arrTokenData = $ arrData ; $ arrTokenData [ 'activation' ] = $ optInToken -> getIdentifier ( ) ; $ arrTokenData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrTokenData [ 'link' ] = Idna :: decode ( Environment :: get ( 'base' ) ) . Environment :: get ( 'request' ) . ( ( strpos ( Environment :: get ( 'request' ) , '?' ) !== false ) ? '&' : '?' ) . 'token=' . $ optInToken -> getIdentifier ( ) ; $ arrTokenData [ 'channels' ] = '' ; $ bundles = System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( isset ( $ bundles [ 'ContaoNewsletterBundle' ] ) ) { if ( ! \ is_array ( $ arrData [ 'newsletter' ] ) ) { if ( $ arrData [ 'newsletter' ] != '' ) { $ arrData [ 'newsletter' ] = array ( $ arrData [ 'newsletter' ] ) ; } else { $ arrData [ 'newsletter' ] = array ( ) ; } } if ( ! empty ( $ arrData [ 'newsletter' ] ) ) { $ objChannels = NewsletterChannelModel :: findByIds ( $ arrData [ 'newsletter' ] ) ; if ( $ objChannels !== null ) { $ arrTokenData [ 'channels' ] = implode ( "\n" , $ objChannels -> fetchEach ( 'title' ) ) ; } } } $ arrTokenData [ 'channel' ] = $ arrTokenData [ 'channels' ] ; $ optInToken -> send ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'emailSubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) , StringUtil :: parseSimpleTokens ( $ this -> reg_text , $ arrTokenData ) ) ; }
5028	public function decorateClassMetaData ( ClassMetadata $ c ) { $ parentClassName = $ c -> getName ( ) ; if ( isset ( $ this -> mappings [ $ parentClassName ] ) ) { $ c -> discriminatorMap = array ( ) ; $ c -> discriminatorMap [ strtolower ( Str :: classname ( $ parentClassName ) ) ] = $ parentClassName ; foreach ( $ this -> mappings [ $ parentClassName ] as $ className ) { $ bundlePrefix = Str :: infix ( $ this -> getBundleName ( $ className ) , '-' ) ; $ name = Str :: infix ( Str :: classname ( Str :: rstrip ( $ className , Str :: classname ( $ parentClassName ) ) ) , '-' ) ; $ combinedDiscriminator = sprintf ( '%s-%s' , $ bundlePrefix , $ name ) ; $ c -> discriminatorMap [ $ combinedDiscriminator ] = $ className ; $ c -> subClasses [ ] = $ className ; } $ c -> subClasses = array_unique ( $ c -> subClasses ) ; } }
7374	public function has ( string $ key ) : bool { return isset ( $ _SESSION ) ? array_key_exists ( $ key , $ _SESSION ) : false ; }
5394	public function paintError ( $ message ) { parent :: paintError ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'exception>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "exception>\n" ; }
1376	protected function validateTypeMember ( $ value , string $ path ) : bool { if ( ! is_string ( $ value ) ) { $ this -> memberNotString ( $ path , 'type' ) ; return false ; } if ( empty ( $ value ) ) { $ this -> memberEmpty ( $ path , 'type' ) ; return false ; } if ( ! $ this -> store -> isType ( $ value ) ) { $ this -> resourceTypeNotRecognised ( $ value , $ path ) ; return false ; } return true ; }
3996	protected function jumpTo ( $ mixMetaModel , $ mixDataId , $ intIdRenderSetting , $ strParam = 'url' ) { if ( empty ( $ strParam ) ) { $ strParam = 'url' ; } $ objMetaModel = $ this -> loadMetaModel ( $ mixMetaModel ) ; if ( $ objMetaModel == null ) { return false ; } $ objRenderSettings = $ this -> getServiceContainer ( ) -> getRenderSettingFactory ( ) -> createCollection ( $ objMetaModel , $ intIdRenderSetting ) ; if ( $ objRenderSettings == null ) { return false ; } $ objItem = $ objMetaModel -> findById ( $ mixDataId ) ; if ( $ objItem == null ) { return false ; } $ arrRenderedItem = $ objItem -> parseValue ( 'text' , $ objRenderSettings ) ; if ( ! isset ( $ arrRenderedItem [ 'jumpTo' ] ) ) { return false ; } if ( stripos ( $ strParam , 'params.' ) !== false ) { $ mixAttName = StringUtil :: trimsplit ( '.' , $ strParam ) ; $ mixAttName = array_pop ( $ mixAttName ) ; if ( isset ( $ arrRenderedItem [ 'jumpTo' ] [ 'params' ] [ $ mixAttName ] ) ) { return $ arrRenderedItem [ 'jumpTo' ] [ 'params' ] [ $ mixAttName ] ; } } elseif ( isset ( $ arrRenderedItem [ 'jumpTo' ] [ $ strParam ] ) ) { return $ arrRenderedItem [ 'jumpTo' ] [ $ strParam ] ; } return false ; }
681	protected function validateAttributeCondition ( $ attribute , $ condition ) { $ attributeTypes = $ this -> getSearchAttributeTypes ( ) ; if ( ! isset ( $ attributeTypes [ $ attribute ] ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'unknownAttribute' , [ 'attribute' => $ attribute ] ) ) ; return ; } if ( is_array ( $ condition ) ) { $ operatorCount = 0 ; foreach ( $ condition as $ rawOperator => $ value ) { if ( isset ( $ this -> filterControls [ $ rawOperator ] ) ) { $ operator = $ this -> filterControls [ $ rawOperator ] ; if ( isset ( $ this -> operatorTypes [ $ operator ] ) ) { $ operatorCount ++ ; $ this -> validateOperatorCondition ( $ rawOperator , $ value , $ attribute ) ; } } } if ( $ operatorCount > 0 ) { if ( $ operatorCount < count ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidAttributeValueFormat' , [ 'attribute' => $ attribute ] ) ) ; } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } }
3301	public function request ( $ method , $ url , $ options = [ ] ) { $ method = strtoupper ( $ method ) ; $ options = array_merge ( self :: $ defaults , [ 'headers' => $ this -> headers ] , $ options ) ; return $ this -> getClient ( ) -> request ( $ method , $ url , $ options ) ; }
10035	function unsubscribeContactByExternalId ( $ externalId , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } $ encodedExternalId = utf8_encode ( $ externalId ) ; return $ this -> delete ( "contacts/externalid/${encodedExternalId}/unsubscribe" , $ queryParameters ) ; }
8676	public function flip ( ) { if ( ! $ this -> items ) { return $ this -> createFrom ( [ ] ) ; } try { return $ this -> createFrom ( Thrower :: call ( 'array_flip' , $ this -> items ) ) ; } catch ( ErrorException $ e ) { throw new LogicException ( 'Only string and integer values can be flipped' ) ; } }
1044	private static function highlightSourceAtLocation ( Source $ source , SourceLocation $ location ) { $ line = $ location -> line ; $ lineOffset = $ source -> locationOffset -> line - 1 ; $ columnOffset = self :: getColumnOffset ( $ source , $ location ) ; $ contextLine = $ line + $ lineOffset ; $ contextColumn = $ location -> column + $ columnOffset ; $ prevLineNum = ( string ) ( $ contextLine - 1 ) ; $ lineNum = ( string ) $ contextLine ; $ nextLineNum = ( string ) ( $ contextLine + 1 ) ; $ padLen = strlen ( $ nextLineNum ) ; $ lines = preg_split ( '/\r\n|[\n\r]/' , $ source -> body ) ; $ lines [ 0 ] = self :: whitespace ( $ source -> locationOffset -> column - 1 ) . $ lines [ 0 ] ; $ outputLines = [ sprintf ( '%s (%s:%s)' , $ source -> name , $ contextLine , $ contextColumn ) , $ line >= 2 ? ( self :: lpad ( $ padLen , $ prevLineNum ) . ': ' . $ lines [ $ line - 2 ] ) : null , self :: lpad ( $ padLen , $ lineNum ) . ': ' . $ lines [ $ line - 1 ] , self :: whitespace ( 2 + $ padLen + $ contextColumn - 1 ) . '^' , $ line < count ( $ lines ) ? self :: lpad ( $ padLen , $ nextLineNum ) . ': ' . $ lines [ $ line ] : null , ] ; return implode ( "\n" , array_filter ( $ outputLines ) ) ; }
474	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "update $table" ) ; $ this -> db -> createCommand ( ) -> update ( $ table , $ columns , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
7298	public function append_signature ( $ message , $ signature = '' ) { if ( empty ( $ signature ) ) { return $ message ; } $ separator = apply_filters ( 'iac_signature_separator' , str_repeat ( PHP_EOL , 2 ) . '--' . PHP_EOL ) ; return $ message . $ separator . $ signature ; }
377	private function getByteSize ( $ verboseSize ) { if ( empty ( $ verboseSize ) ) { return 0 ; } if ( is_numeric ( $ verboseSize ) ) { return ( int ) $ verboseSize ; } $ sizeUnit = trim ( $ verboseSize , '0123456789' ) ; $ size = trim ( str_replace ( $ sizeUnit , '' , $ verboseSize ) ) ; if ( ! is_numeric ( $ size ) ) { return 0 ; } switch ( strtolower ( $ sizeUnit ) ) { case 'kb' : case 'k' : return $ size * 1024 ; case 'mb' : case 'm' : return $ size * 1024 * 1024 ; case 'gb' : case 'g' : return $ size * 1024 * 1024 * 1024 ; default : return 0 ; } }
7558	public function query ( $ query = '*' ) { $ select = $ this -> select ( $ query ) ; $ result = new \ pQuery ( ( array ) $ select ) ; return $ result ; }
7333	private function getStockUnitMapper ( EntityManagerInterface $ em ) { if ( null === $ this -> stockUnitMapper ) { $ this -> stockUnitMapper = new DiscriminatorMapper ( $ em , AbstractStockUnit :: class ) ; } return $ this -> stockUnitMapper ; }
11282	public function _populate ( $ record = null , $ db = false , $ loadMap = false ) { $ this -> model_hydrating = true ; if ( $ db ) { $ this -> model_db = $ db ; } if ( $ record ) { $ this -> _populateAttributes ( $ record ) ; $ this -> _populateNonModelData ( $ record ) ; } if ( $ this -> model_loadMapsEnabled ) { $ this -> _populateLoadMap ( $ record , $ loadMap ) ; } $ this -> onLoad ( ) ; if ( $ loadMap instanceof \ Cora \ Adm \ LoadMap && $ func = $ loadMap -> getOnLoadFunction ( ) ) { $ args = $ loadMap -> getOnLoadArgs ( ) ; array_unshift ( $ args , $ this ) ; call_user_func_array ( $ func , $ args ) ; } $ this -> model_hydrating = false ; return $ this ; }
3776	public function run ( ) { $ template = new BackendTemplate ( 'be_dcastylepicker' ) ; $ template -> main = '' ; $ template -> headline = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodelspicker' ] ; $ inputName = Input :: get ( 'inputName' ) ; if ( ! preg_match ( '~^[a-z\-_0-9]+$~i' , $ inputName ) ) { throw new RuntimeException ( 'Field-Parameter ERROR!' ) ; } $ template -> field = $ inputName ; $ template -> items = $ GLOBALS [ Input :: get ( 'item' ) ] ; if ( ! strlen ( $ template -> headline ) ) { $ template -> headline = $ GLOBALS [ 'TL_CONFIG' ] [ 'websiteTitle' ] ; } $ template -> theme = Backend :: getTheme ( ) ; $ template -> base = Environment :: get ( 'base' ) ; $ template -> language = $ GLOBALS [ 'TL_LANGUAGE' ] ; $ template -> title = $ GLOBALS [ 'TL_CONFIG' ] [ 'websiteTitle' ] ; $ template -> charset = $ GLOBALS [ 'TL_CONFIG' ] [ 'characterSet' ] ; $ template -> pageOffset = Input :: cookie ( 'BE_PAGE_OFFSET' ) ; $ template -> error = ( Input :: get ( 'act' ) == 'error' ) ? $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] : '' ; $ template -> skipNavigation = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'skipNavigation' ] ; $ template -> request = ampersand ( Environment :: get ( 'request' ) ) ; $ template -> top = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backToTop' ] ; $ template -> be27 = ! $ GLOBALS [ 'TL_CONFIG' ] [ 'oldBeTheme' ] ; $ template -> expandNode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] ; $ template -> collapseNode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] ; $ template -> strField = Input :: get ( 'fld' ) ; $ template -> output ( ) ; }
11070	public function setBoolean ( string $ key , $ value , bool $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( bool ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
8231	public static function getItemByUrl ( $ items , $ url ) { if ( ! isset ( $ items ) ) { return null ; } if ( array_key_exists ( "/" . $ url , $ items ) ) { return $ items [ "/" . $ url ] ; } $ urlParts = explode ( "/" , trim ( $ url , "/" ) ) ; $ urlPartsLen = count ( $ urlParts ) ; while ( $ urlPartsLen > 0 ) { unset ( $ urlParts [ -- $ urlPartsLen ] ) ; $ subUrl = "/" . join ( "/" , $ urlParts ) ; if ( array_key_exists ( $ subUrl , $ items ) && ( ! isset ( $ items [ $ subUrl ] [ "recursive" ] ) || $ items [ $ subUrl ] [ "recursive" ] === true ) ) { return $ items [ $ subUrl ] ; } } return null ; }
6724	protected function validateTokenParams ( ) { if ( empty ( $ this -> tokenUrl ) || filter_var ( $ this -> tokenUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_TOKEN_URL , $ this -> tokenUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
3573	protected function setInstance ( Attribute $ attribute ) { if ( $ this -> has ( $ attribute -> getMetaKey ( ) ) ) { $ this -> update ( $ attribute ) ; } else { $ this -> items [ $ attribute -> getMetaKey ( ) ] = $ attribute ; } return $ this ; }
8222	protected function getLimitFor ( $ actionName , $ blockType , $ entityId ) { $ limit = $ this -> storage -> getLimitFor ( $ actionName , $ blockType , $ entityId ) ; if ( $ limit === null ) { $ limit = array ( "ts" => 0 , "cnt" => 0 ) ; } return $ limit ; }
5624	public function setCoordinates ( $ x = false , $ y = false ) { if ( ( $ x === false ) || ( $ y === false ) ) { $ this -> x = $ this -> y = false ; return ; } $ this -> x = ( integer ) $ x ; $ this -> y = ( integer ) $ y ; }
686	protected function sortModels ( $ models , $ sort ) { $ orders = $ sort -> getOrders ( ) ; if ( ! empty ( $ orders ) ) { ArrayHelper :: multisort ( $ models , array_keys ( $ orders ) , array_values ( $ orders ) ) ; } return $ models ; }
8998	public function exists ( ) : bool { if ( ! file_exists ( $ this -> path ) ) { return false ; } if ( ! is_dir ( $ this -> path ) ) { throw new DirectoryException ( "Entry {path} exists, but it is not a directory!" , array ( 'path' => $ this -> path ) ) ; } return true ; }
6001	public function addImageTemplate ( $ item ) { if ( ! ( $ item instanceof ImageTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new ImageTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate ImageTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "ImageTemplate"!' , E_USER_WARNING ) ; } } $ this -> imagetemplates [ ] = $ item ; return $ this ; }
4742	public function isReviewOptInValidationRequired ( ) { return ( bool ) \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( self :: REVIEW_OPTIN_PARAM ) ; }
2891	public function onControllerFrontSendResponseAfter ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ front = $ observer -> getData ( 'front' ) ; $ this -> updateProfiling ( ) ; $ this -> getRequestInfo ( ) -> getController ( ) -> addResponseInfo ( $ front -> getResponse ( ) ) ; }
11850	public static function createFault ( $ code , $ message ) { $ response = new \ SimpleXMLElement ( "<methodResponse></methodResponse>" ) ; $ struct = $ response -> addChild ( "fault" ) -> addChild ( "value" ) -> addChild ( "struct" ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultCode" ) ; $ member -> addChild ( "value" ) -> addChild ( "int" , $ code ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultString" ) ; $ member -> addChild ( "value" , $ message ) ; return $ response -> asXML ( ) ; }
11107	public function shouldThrottle ( APIRequest $ request ) : bool { $ item = $ this -> cacheItemPool -> getItem ( $ this -> deriveCacheKey ( $ request ) ) ; return $ item -> get ( ) >= $ this -> limit ; }
7348	protected function watch ( OrderShipmentInterface $ shipment ) { $ order = $ shipment -> getOrder ( ) ; if ( ! $ order -> isAutoNotify ( ) ) { return ; } if ( $ shipment -> isReturn ( ) ) { if ( $ shipment -> getState ( ) === ShipmentStates :: STATE_PENDING ) { if ( ! $ this -> didStateChangeTo ( $ shipment , ShipmentStates :: STATE_PENDING ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: RETURN_PENDING , $ shipment -> getNumber ( ) ) ) { return ; } $ this -> notify ( NotificationTypes :: RETURN_PENDING , $ shipment ) ; return ; } if ( $ shipment -> getState ( ) === ShipmentStates :: STATE_RETURNED ) { if ( ! $ this -> didStateChangeTo ( $ shipment , ShipmentStates :: STATE_RETURNED ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: RETURN_RECEIVED , $ shipment -> getNumber ( ) ) ) { return ; } $ this -> notify ( NotificationTypes :: RETURN_RECEIVED , $ shipment ) ; } return ; } if ( ! $ this -> didStateChangeTo ( $ shipment , ShipmentStates :: STATE_SHIPPED ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: SHIPMENT_SHIPPED , $ shipment -> getNumber ( ) ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: SHIPMENT_SHIPPED , $ shipment -> getNumber ( ) ) ) { return ; } $ type = NotificationTypes :: SHIPMENT_SHIPPED ; if ( $ order -> getShipmentState ( ) !== ShipmentStates :: STATE_COMPLETED ) { $ type = NotificationTypes :: SHIPMENT_PARTIAL ; } $ this -> notify ( $ type , $ shipment ) ; }
12524	public function deserializeJSON ( $ jsonString ) { $ data = json_decode ( $ jsonString ) ; $ this -> setContent ( $ data -> content ) ; $ this -> setContext ( $ data -> context ) ; }
6247	public function dirs ( ? int $ constraints = null ) : \ Generator { foreach ( $ this -> all ( $ constraints ) as $ directory ) { if ( $ directory -> isDir ( ) ) { yield $ directory ; } } }
8597	public function listMarketplaceParticipationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5896	public function retrieveImageTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/images/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new ImageTemplate ( $ result ) ; return $ result ; }
228	public function getTableNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _tableNames [ $ schema ] ) || $ refresh ) { $ this -> _tableNames [ $ schema ] = $ this -> findTableNames ( $ schema ) ; } return $ this -> _tableNames [ $ schema ] ; }
12617	public function removeAttribute ( string $ attributeName ) { if ( isset ( $ this -> attributes [ $ attributeName ] ) ) unset ( $ this -> attributes [ $ attributeName ] ) ; }
4213	public static function colKeys ( $ rows ) { if ( ! \ is_array ( $ rows ) ) { return array ( ) ; } if ( Abstracter :: isAbstraction ( $ rows ) && $ rows [ 'traverseValues' ] ) { $ rows = $ rows [ 'traverseValues' ] ; } $ lastKeys = array ( ) ; $ newKeys = array ( ) ; $ curKeys = array ( ) ; foreach ( $ rows as $ row ) { $ curKeys = self :: keys ( $ row ) ; if ( empty ( $ lastKeys ) ) { $ lastKeys = $ curKeys ; } elseif ( $ curKeys != $ lastKeys ) { $ newKeys = array ( ) ; $ count = \ count ( $ curKeys ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ curKey = $ curKeys [ $ i ] ; if ( $ lastKeys && $ curKey === $ lastKeys [ 0 ] ) { \ array_push ( $ newKeys , $ curKey ) ; \ array_shift ( $ lastKeys ) ; } elseif ( false !== $ position = \ array_search ( $ curKey , $ lastKeys , true ) ) { $ segment = \ array_splice ( $ lastKeys , 0 , $ position + 1 ) ; \ array_splice ( $ newKeys , \ count ( $ newKeys ) , 0 , $ segment ) ; } elseif ( ! \ in_array ( $ curKey , $ newKeys , true ) ) { \ array_push ( $ newKeys , $ curKey ) ; } } \ array_splice ( $ newKeys , \ count ( $ newKeys ) , 0 , $ lastKeys ) ; $ lastKeys = \ array_unique ( $ newKeys ) ; } } return $ lastKeys ; }
3847	protected static function upgradeClosed ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_metamodel_dca' , null , true ) && ! $ objDB -> fieldExists ( 'iseditable' , 'tl_metamodel_dca' ) ) { TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'iseditable' , 'char(1) NOT NULL default \'\'' ) ; TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'iscreatable' , 'char(1) NOT NULL default \'\'' ) ; TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'isdeleteable' , 'char(1) NOT NULL default \'\'' ) ; $ objDB -> execute ( ' UPDATE tl_metamodel_dca SET iseditable=isclosed^1, iscreatable=isclosed^1, isdeleteable=isclosed^1 ' ) ; TableManipulation :: dropColumn ( 'tl_metamodel_dca' , 'isclosed' , true ) ; } }
9048	private function renderFields ( $ rendered , $ fields ) { foreach ( $ fields as $ field ) { if ( ! isset ( $ field [ 'name' ] ) ) { throw new ControlException ( "Field must have at least a name!" ) ; } $ fieldType = isset ( $ field [ 'type' ] ) ? $ field [ 'type' ] : 'text' ; $ id = isset ( $ field [ 'id' ] ) ? $ field [ 'id' ] : $ field [ 'name' ] ; $ class = isset ( $ field [ 'class' ] ) ? $ field [ 'class' ] : $ field [ 'name' ] ; $ rendered .= sprintf ( '<input type="%s" id="%s" class="%s" name="%s"/>' , $ fieldType , $ id , $ class , $ field [ 'name' ] ) ; } return $ rendered ; }
8710	public function where ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( is_array ( $ column ) ) { return $ this -> addArrayOfWheres ( $ column , $ boolean ) ; } if ( in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { return $ this -> whereTranslated ( $ column , $ operator , $ value , $ boolean ) ; } return parent :: where ( $ column , $ operator , $ value , $ boolean ) ; }
4562	public function getProperties ( Translatable $ model ) : array { $ class = get_class ( $ model ) ; if ( substr ( $ class , 0 , 15 ) === 'Proxies\\__CG__\\' ) { $ class = substr ( $ class , 15 ) ; } $ properties = [ ] ; $ reflection = new ReflectionClass ( $ class ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Translate :: class ) ; if ( ! $ annotation ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
3312	public function getCacheKey ( ) { if ( is_null ( $ this -> cacheKey ) ) { return $ this -> prefix . $ this -> appKey ; } return $ this -> cacheKey ; }
10260	public function getIp ( ) { $ parts = [ ] ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ parts [ ] = $ this -> getInteger ( 0 , 255 ) ; } return join ( '.' , $ parts ) ; }
465	public function buildBetweenCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
10510	public function detach ( \ SplObserver $ observer ) { foreach ( $ this -> _observers as $ observerItem ) { if ( $ observerItem -> observer === $ observer ) { $ this -> _observers -> detach ( $ observerItem ) ; } } }
6963	public function toDate ( ) { if ( $ this -> dt ) return $ this -> dt ; else return AstroDate :: jd ( $ this -> jd , TimeScale :: TT ( ) ) ; }
4415	public static function modify ( $ tpl , $ operatorName , $ operatorParameters , $ rootNamespace , $ currentNamespace , & $ operatorValue , $ namedParameters , $ placement ) { if ( $ operatorName === 'has_tags_bundle' ) { $ operatorValue = class_exists ( 'Netgen\TagsBundle\Version' ) && TagsBundleVersion :: VERSION_ID >= 30000 ; } }
11520	protected function GenerateWindowsPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ WindowsPinicon ) { $ metadata .= $ owner -> MarkupComment ( 'Windows Pinned Icon' ) ; $ appName = $ config -> fetchPiniconTitle ( ) ; if ( ! $ appName ) { $ appName = $ config -> Title ; } $ metadata .= $ owner -> MarkupMeta ( 'application-name' , $ appName ) ; if ( $ config -> fetchWindowsPiniconBackgroundColor ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'msapplication-TileColor' , $ config -> fetchWindowsPiniconBackgroundColor ( ) ) ; } $ metadata .= $ owner -> MarkupMeta ( 'msapplication-square70x70logo' , $ WindowsPinicon -> Fill ( 70 , 70 ) -> getAbsoluteURL ( ) ) ; $ metadata .= $ owner -> MarkupMeta ( 'msapplication-square150x150logo' , $ WindowsPinicon -> Fill ( 150 , 150 ) -> getAbsoluteURL ( ) ) ; }
10524	protected function _unsetData ( $ key ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerUnset ( $ store , $ key ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ key ) ; } }
503	public function batchInsert ( $ table , $ columns , $ rows , & $ params = [ ] ) { if ( empty ( $ rows ) ) { return '' ; } $ this -> db -> open ( ) ; if ( version_compare ( $ this -> db -> getServerVersion ( ) , '3.7.11' , '>=' ) ) { return parent :: batchInsert ( $ table , $ columns , $ rows , $ params ) ; } $ schema = $ this -> db -> getSchema ( ) ; if ( ( $ tableSchema = $ schema -> getTableSchema ( $ table ) ) !== null ) { $ columnSchemas = $ tableSchema -> columns ; } else { $ columnSchemas = [ ] ; } $ values = [ ] ; foreach ( $ rows as $ row ) { $ vs = [ ] ; foreach ( $ row as $ i => $ value ) { if ( isset ( $ columnSchemas [ $ columns [ $ i ] ] ) ) { $ value = $ columnSchemas [ $ columns [ $ i ] ] -> dbTypecast ( $ value ) ; } if ( is_string ( $ value ) ) { $ value = $ schema -> quoteValue ( $ value ) ; } elseif ( is_float ( $ value ) ) { $ value = StringHelper :: floatToString ( $ value ) ; } elseif ( $ value === false ) { $ value = 0 ; } elseif ( $ value === null ) { $ value = 'NULL' ; } elseif ( $ value instanceof ExpressionInterface ) { $ value = $ this -> buildExpression ( $ value , $ params ) ; } $ vs [ ] = $ value ; } $ values [ ] = implode ( ', ' , $ vs ) ; } if ( empty ( $ values ) ) { return '' ; } foreach ( $ columns as $ i => $ name ) { $ columns [ $ i ] = $ schema -> quoteColumnName ( $ name ) ; } return 'INSERT INTO ' . $ schema -> quoteTableName ( $ table ) . ' (' . implode ( ', ' , $ columns ) . ') SELECT ' . implode ( ' UNION SELECT ' , $ values ) ; }
6204	public function onError ( $ type , $ message , $ file = null , $ line = null , $ context = null ) { if ( ini_get ( 'error_reporting' ) == 0 ) { return true ; } if ( isset ( $ this -> fatalErrors [ $ type ] ) ) { throw new Exception ( $ message ) ; } if ( $ this -> shouldNotifyError ( $ type , $ message , $ file , $ line , $ context ) ) { $ backtrace = debug_backtrace ( ) ; array_shift ( $ backtrace ) ; $ this -> airbrakeClient -> notifyOnError ( $ message , $ backtrace ) ; return true ; } return true ; }
1407	protected function getModelAttributes ( Model $ model ) { $ attributes = [ ] ; foreach ( $ this -> attributeKeys ( $ model ) as $ modelKey => $ field ) { if ( is_numeric ( $ modelKey ) ) { $ modelKey = $ field ; $ field = $ this -> fieldForAttribute ( $ field ) ; } $ attributes [ $ field ] = $ this -> extractAttribute ( $ model , $ modelKey , $ field ) ; } return $ attributes ; }
6080	public function updateProperties ( $ id , array $ properties ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'properties' => $ properties ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/media/' . $ id . '/properties' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
5396	public function paintSkip ( $ message ) { parent :: paintSkip ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'skip>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "skip>\n" ; }
9342	public function populate ( $ arrAll ) { $ this -> arr = array_chunk ( $ arrAll , $ this -> size -> cols ) ; return $ this ; }
713	public function bigInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BIGINT , $ length ) ; }
5971	public function categories ( ) { if ( ! $ this -> categories instanceof CategoriesController ) { $ this -> categories = new CategoriesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> categories -> setLogger ( $ this -> logger ) ; } return $ this -> categories ; }
2165	public static function convertMultiField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field!=''" ) ; $ objDesc = $ objDatabase -> query ( "DESC $table $field" ) ; if ( $ objDesc -> Type != 'blob' ) { $ objDatabase -> query ( "ALTER TABLE `$table` CHANGE `$field` `$field` blob NULL" ) ; $ objDatabase -> query ( "UPDATE `$table` SET `$field`=NULL WHERE `$field`=''" ) ; } while ( $ objRow -> next ( ) ) { $ arrValues = StringUtil :: deserialize ( $ objRow -> $ field , true ) ; if ( empty ( $ arrValues ) ) { continue ; } $ objHelper = static :: generateHelperObject ( $ arrValues ) ; if ( $ objHelper -> isUuid ) { continue ; } foreach ( $ arrValues as $ k => $ v ) { if ( $ objHelper -> isNumeric ) { $ objFile = FilesModel :: findByPk ( $ objHelper -> value [ $ k ] ) ; $ arrValues [ $ k ] = $ objFile -> uuid ; } else { $ objFile = FilesModel :: findByPath ( $ objHelper -> value [ $ k ] ) ; $ arrValues [ $ k ] = $ objFile -> uuid ; } } $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( serialize ( $ arrValues ) , $ objRow -> id ) ; } }
7343	protected function initializeStock ( ) { $ this -> stockMode = StockSubjectModes :: MODE_AUTO ; $ this -> stockState = StockSubjectStates :: STATE_OUT_OF_STOCK ; $ this -> stockFloor = 0 ; $ this -> inStock = 0 ; $ this -> availableStock = 0 ; $ this -> virtualStock = 0 ; $ this -> replenishmentTime = 2 ; $ this -> minimumOrderQuantity = 1 ; $ this -> quoteOnly = false ; $ this -> endOfLife = false ; }
4834	public function fetch_access_token ( $ params ) { if ( ! isset ( $ params [ 'redirect_uri' ] ) ) { throw new GoCardless_ArgumentsException ( 'redirect_uri required' ) ; } $ params [ 'http_authorization' ] = $ this -> account_details [ 'app_id' ] . ':' . $ this -> account_details [ 'app_secret' ] ; $ response = $ this -> request ( 'post' , '/oauth/access_token' , $ params ) ; $ merchant = explode ( ':' , $ response [ 'scope' ] ) ; $ merchant_id = isset ( $ merchant [ 1 ] ) ? $ merchant [ 1 ] : null ; $ access_token = $ response [ 'access_token' ] ; return array ( 'merchant_id' => $ merchant_id , 'access_token' => $ access_token ) ; }
11592	public function getFullPath ( $ file = '' ) { $ this -> name = ( $ file ) ? $ file : $ this -> name ; return config ( 'odin.assetsUrl' ) . $ this -> getPath ( ) . $ this -> name ; }
3785	private function updateValues ( array & $ values , PropertiesDefinitionInterface $ properties , DataProviderInterface $ dataProvider ) { foreach ( $ values as $ propertyName => $ propertyValue ) { if ( ( $ dataProvider -> getIdProperty ( ) === $ propertyName ) || ( $ dataProvider -> getGroupColumnProperty ( ) === $ propertyName ) || ( $ dataProvider -> getSortingColumnProperty ( ) === $ propertyName ) || ( $ dataProvider -> getTimeStampProperty ( ) === $ propertyName ) || ! $ properties -> hasProperty ( $ propertyName ) ) { continue ; } $ values [ $ propertyName ] = ModelManipulator :: sanitizeValue ( $ properties -> getProperty ( $ propertyName ) , $ propertyValue ) ; } return $ values ; }
11745	public function getShakeInfo ( $ ticket , $ needPoi = null ) { $ params = [ 'ticket' => $ ticket , ] ; if ( $ needPoi !== null ) { $ params [ 'need_poi' ] = intval ( $ needPoi ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_GET_SHAKE_INFO , $ params ] ) ; }
11868	public function destroy ( string $ sessionIdentifier ) : void { if ( ! isset ( self :: $ files [ $ sessionIdentifier ] ) ) { throw new SessionNotFoundException ( ) ; } unset ( self :: $ files [ $ sessionIdentifier ] ) ; }
4891	protected function getTarget ( $ generateInstance = true ) { $ serviceLocator = $ this -> getServicelocator ( ) ; $ this -> getGenerator ( ) ; $ target = null ; if ( array_key_exists ( 'target' , $ this -> options ) ) { $ target = $ this -> options [ 'target' ] ; if ( is_string ( $ target ) ) { if ( $ serviceLocator -> has ( $ target ) ) { $ target = $ serviceLocator -> get ( $ target ) ; if ( $ generateInstance ) { $ target = get_class ( $ target ) ; } } else { if ( $ generateInstance ) { $ target = new $ target ; } } } } return $ target ; }
11792	public function setTo ( $ mail = '' , $ name = null ) { $ this -> to = Helper :: deduplicate ( array_merge ( $ this -> to , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
5937	public function setFunctionalities ( array $ functionalities ) { $ this -> functionalities = [ ] ; foreach ( $ functionalities as $ item ) { $ this -> addFunctionality ( $ item ) ; } return $ this ; }
1669	public function delete ( ) { $ this -> Files -> rrdir ( $ this -> strFolder ) ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { Dbafs :: deleteResource ( $ this -> strFolder ) ; } }
1746	public function addEnclosure ( $ strFile , $ strUrl = null , $ strMedia = 'enclosure' ) { if ( $ strFile == '' || ! file_exists ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFile ) ) { return ; } if ( $ strUrl === null ) { $ strUrl = Environment :: get ( 'base' ) ; } $ objFile = new File ( $ strFile ) ; $ this -> arrData [ 'enclosure' ] [ ] = array ( 'media' => $ strMedia , 'url' => $ strUrl . System :: urlEncode ( $ strFile ) , 'length' => $ objFile -> size , 'type' => $ objFile -> mime ) ; }
11350	public function getData ( ) { $ data = [ ] ; foreach ( $ this -> fields as $ field ) { if ( preg_match ( '/^(.*?)(\[.*\])$/' , $ field -> getName ( ) , $ result ) ) { if ( $ result [ 2 ] == '' ) { } else { if ( ! preg_match_all ( "/\[(.*?)\]/" , $ result [ 2 ] , $ resultDeep ) ) { throw new \ Exception ( 'Invalid field name.' ) ; } $ storage = & $ data [ $ result [ 1 ] ] ; foreach ( $ resultDeep [ 1 ] as $ deep ) { if ( ! isset ( $ storage [ $ deep ] ) ) { $ storage [ $ deep ] = [ ] ; } $ storage = & $ storage [ $ deep ] ; } $ storage = $ field -> getData ( ) ; } } else { $ data [ $ field -> getName ( ) ] = $ field -> getData ( ) ; } } return $ this -> transformer -> decode ( $ data ) ; }
3262	public static function callback ( $ order , $ transaction , $ status , $ data = null ) { $ statusCode = $ order -> statusCode ; try { if ( in_array ( $ status , [ 'success' , 'fail' ] ) ) { static :: $ gatewayKey = $ transaction -> gateway ; static :: $ gateway = static :: instanceGateway ( ) ; if ( $ status == 'success' ) { static :: $ gateway -> onCallbackSuccess ( $ order , $ data ) ; $ order -> statusCode = static :: $ gateway -> getTransactionStatusCode ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , static :: $ gateway -> getTransactionId ( ) , static :: $ gateway -> getTransactionDetail ( ) , static :: $ gateway -> getTransactionToken ( ) ) ; if ( $ order -> isCompleted ) \ event ( new OrderCompleted ( $ order -> id ) ) ; } else if ( $ status == 'fail' ) { static :: $ gateway -> onCallbackFail ( $ order , $ data ) ; $ order -> statusCode = 'failed' ; } $ order -> save ( ) ; } } catch ( ShopException $ e ) { static :: setException ( $ e ) ; $ order -> statusCode = 'failed' ; $ order -> save ( ) ; } catch ( GatewayException $ e ) { static :: setException ( $ e ) ; $ order -> statusCode = 'failed' ; $ order -> save ( ) ; } static :: checkStatusChange ( $ order , $ statusCode ) ; }
11391	public function createMainMenu ( Request $ request ) { $ menu = $ this -> factory -> createItem ( 'root' ) ; $ menu -> setCurrentUri ( $ request -> getBaseUrl ( ) . $ request -> getPathInfo ( ) ) ; $ admin_pool = $ this -> container -> get ( 'sonata.admin.pool' ) ; foreach ( $ admin_pool -> getDashboardGroups ( ) as $ group ) { $ menu -> addChild ( $ group [ 'label' ] , array ( 'translationDomain' => $ group [ 'label_catalogue' ] ) ) ; foreach ( $ group [ 'items' ] as $ admin ) { if ( $ admin -> hasRoute ( 'list' ) && $ admin -> isGranted ( 'LIST' ) ) { $ menu [ $ group [ 'label' ] ] -> addChild ( $ admin -> getLabel ( ) , array ( 'admin' => $ admin ) ) ; } } } $ dispatcher = $ this -> container -> get ( 'event_dispatcher' ) ; $ event = new MenuCreateEvent ( $ menu ) ; $ dispatcher -> dispatch ( MenuEvents :: ADMIN_MENU_CREATE , $ event ) ; return $ menu ; }
1184	protected function wrapValidator ( ) { $ resolver = new Resolver ( $ this -> factory ) ; $ this -> factory -> resolver ( $ resolver -> resolver ( $ this -> field ) ) ; $ this -> factory -> extend ( RemoteValidator :: EXTENSION_NAME , $ resolver -> validatorClosure ( ) ) ; }
9332	public function requireField ( ) { $ charset = MySQLDatabase :: config ( ) -> charset ; $ collation = MySQLDatabase :: config ( ) -> collation ; $ spec = [ 'type' => 'varchar' , 'parts' => [ 'datatype' => 'varchar' , 'precision' => 64 , 'collate' => $ collation , 'character set' => $ charset , 'arrayValue' => $ this -> arrayValue ] ] ; DB :: require_field ( $ this -> tableName , $ this -> name , $ spec ) ; }
2577	protected function hasPricingOption ( $ optionKey , $ priceOptions ) { $ found = false ; foreach ( $ priceOptions as $ pog ) { if ( $ pog -> pricingOptionKey -> pricingOptionKey === $ optionKey ) { $ found = true ; } } return $ found ; }
5118	public function deleteAttachment ( string $ idArticle , string $ field , string $ order ) : string { return $ this -> delete ( $ this -> getAttachmentEndPoint ( $ idArticle , $ field ) . "/${order}" ) ; }
7822	protected function refreshPipelines ( ) { $ yaml = $ this -> parser -> dump ( $ this -> pipelines ) ; $ this -> files -> put ( $ this -> getSource ( ) , $ yaml ) ; }
7568	protected function parse ( ) { $ p = & $ this -> parser ; $ p -> setPos ( 0 ) ; $ this -> result = array ( ) ; if ( ! $ this -> parse_single ( ) ) { return false ; } while ( count ( $ this -> result ) > 0 ) { switch ( $ p -> token ) { case CSSQueryTokenizer :: TOK_CHILD : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( false , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_SIBLING : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( true , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_PLUS : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_adjacent ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_ALL : case CSSQueryTokenizer :: TOK_IDENTIFIER : case CSSQueryTokenizer :: TOK_STRING : case CSSQueryTokenizer :: TOK_BRACE_OPEN : case CSSQueryTokenizer :: TOK_BRACKET_OPEN : case CSSQueryTokenizer :: TOK_ID : case CSSQueryTokenizer :: TOK_CLASS : case CSSQueryTokenizer :: TOK_COLON : if ( ! $ this -> parse_result ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_NULL : break 2 ; default : $ this -> error ( 'Invalid search pattern(3): No result modifier found!' ) ; return false ; } } return true ; }
8387	public function distinct ( $ distinct ) { if ( is_array ( $ distinct ) === true ) { $ this -> distinct = implode ( ', ' , $ distinct ) ; } else { $ this -> distinct = $ distinct ; } return $ this ; }
9159	protected function redirect ( $ controller = null , $ action = null ) { if ( null === $ controller ) { $ controller = Application :: getInstance ( ) -> getDefaultController ( ) ; } if ( null === $ action ) { $ action = Application :: getInstance ( ) -> getDefaultAction ( ) ; } $ destination = sprintf ( "Location: %s%s/%s" , $ this -> request -> getContextPrefix ( ) , $ controller , $ action ) ; header ( $ destination ) ; exit ( ) ; }
5011	public function getLogger ( ) : LoggerInterface { if ( ! $ this -> logger ) { $ logger = new class implements LoggerInterface { public function emerg ( $ message , $ extra = [ ] ) : void { } public function alert ( $ message , $ extra = [ ] ) : void { } public function crit ( $ message , $ extra = [ ] ) : void { } public function err ( $ message , $ extra = [ ] ) : void { } public function warn ( $ message , $ extra = [ ] ) : void { } public function notice ( $ message , $ extra = [ ] ) : void { } public function info ( $ message , $ extra = [ ] ) : void { } public function debug ( $ message , $ extra = [ ] ) : void { } } ; $ this -> setLogger ( $ logger ) ; } return $ this -> logger ; }
173	private static function firstWildcardInPattern ( $ pattern ) { $ wildcards = [ '*' , '?' , '[' , '\\' ] ; $ wildcardSearch = function ( $ r , $ c ) use ( $ pattern ) { $ p = strpos ( $ pattern , $ c ) ; return $ r === false ? $ p : ( $ p === false ? $ r : min ( $ r , $ p ) ) ; } ; return array_reduce ( $ wildcards , $ wildcardSearch , false ) ; }
8946	public function changePreference ( $ key , $ preference ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences/' . $ key ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ preference ) ; return $ response -> body ; }
4774	public function build ( $ widgets , string $ widgetGroup = '' , array $ widgetId = [ ] ) { if ( ! $ widgets ) { return $ widgets ; } $ this -> loadUserConfig ( ) ; $ outputWidget = [ ] ; if ( $ widgetId ) { foreach ( $ widgetId as $ id ) { if ( isset ( $ widgets [ $ id ] ) ) { $ widgets [ $ id ] -> setActive ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'status' ] ?? false ) ; $ widgets [ $ id ] -> setConfig ( $ this -> widgetConfig [ $ widget -> getId ( ) ] ?? [ ] ) ; $ outputWidget [ ] = $ widgets [ $ id ] ; } } return $ outputWidget ; } foreach ( $ widgets as $ widget ) { if ( '' !== $ widgetGroup && $ widget -> getGroup ( ) !== $ widgetGroup ) { continue ; } if ( isset ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'order' ] ) ) { $ widget -> setOrder ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'order' ] ) ; } if ( null !== $ widget -> getOrder ( ) ) { while ( isset ( $ outputWidget [ $ widget -> getOrder ( ) ] ) ) { $ widget -> setOrder ( $ widget -> getOrder ( ) + 1 ) ; } $ outputWidget [ $ widget -> getOrder ( ) ] = $ widget ; } else { $ outputWidget [ ] = $ widget ; } $ widget -> setActive ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'status' ] ?? false ) ; $ widget -> setConfig ( $ this -> widgetConfig [ $ widget -> getId ( ) ] ?? [ ] ) ; } ksort ( $ outputWidget ) ; return $ outputWidget ; }
276	private function printHelpMessage ( ) { $ this -> stdout ( $ this -> getHelpSummary ( ) . "\n" ) ; $ helpCommand = Console :: ansiFormat ( 'yii help fixture' , [ Console :: FG_CYAN ] ) ; $ this -> stdout ( "Use $helpCommand to get usage info.\n" ) ; }
7033	protected function lastMigration ( ) { try { $ migration = Db :: query ( "select * from migrations order by created_at desc limit 1" , [ ] , $ this -> dbName ) ; return $ migration [ 0 ] ; } catch ( PDOException $ e ) { if ( $ e -> getCode ( ) === "42S02" ) return null ; } return false ; }
7294	public function inform_about_posts ( $ post_id = FALSE ) { if ( ! $ post_id ) { return $ post_id ; } if ( ! isset ( $ this -> transit_posts [ $ post_id ] ) ) { return $ post_id ; } $ transit = $ this -> transit_posts [ $ post_id ] ; if ( 'publish' != $ transit [ 'new_status' ] || 'publish' == $ transit [ 'old_status' ] ) { return $ post_id ; } $ post_data = get_post ( $ post_id ) ; $ user = get_userdata ( $ post_data -> post_author ) ; $ to = $ this -> get_members ( $ user -> data -> user_email , 'post' ) ; if ( empty ( $ to ) ) { return $ post_id ; } $ subject = get_option ( 'blogname' ) . ': ' . get_the_title ( $ post_data -> ID ) ; $ message = $ post_data -> post_content ; $ headers = array ( ) ; $ headers [ 'From' ] = get_the_author_meta ( 'display_name' , $ user -> ID ) . ' (' . get_bloginfo ( 'name' ) . ')' . ' <' . $ user -> data -> user_email . '>' ; if ( $ this -> options [ 'send_by_bcc' ] ) { $ bcc = $ to ; $ to = empty ( $ this -> options [ 'bcc_to_recipient' ] ) ? get_bloginfo ( 'admin_email' ) : $ this -> options [ 'bcc_to_recipient' ] ; $ headers [ 'Bcc' ] = $ bcc ; } $ to = apply_filters ( 'iac_post_to' , $ to , $ this -> options , $ post_id ) ; $ subject = apply_filters ( 'iac_post_subject' , $ subject , $ this -> options , $ post_id ) ; $ message = apply_filters ( 'iac_post_message' , $ message , $ this -> options , $ post_id ) ; $ headers = apply_filters ( 'iac_post_headers' , $ headers , $ this -> options , $ post_id ) ; $ attachments = apply_filters ( 'iac_post_attachments' , array ( ) , $ this -> options , $ post_id ) ; $ signature = apply_filters ( 'iac_post_signature' , '' , $ this -> options , $ post_id ) ; $ this -> options [ 'static_options' ] [ 'object' ] = array ( 'id' => $ post_id , 'type' => 'post' ) ; $ this -> send_mail ( $ to , $ subject , $ this -> append_signature ( $ message , $ signature ) , $ headers , $ attachments ) ; return $ post_id ; }
8325	public function deletePingback ( $ uri ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=del_pingback&addr={$uri}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
10809	protected function __templates ( $ customTemplate = null , $ customTemplateSuffix = null ) { $ templates = SSViewer :: get_templates_by_class ( $ this -> class , $ customTemplateSuffix , \ FormField :: class ) ; if ( ! $ templates ) { throw new \ Exception ( "No template found for {$this->class}" ) ; } if ( $ customTemplate ) { array_unshift ( $ templates , $ customTemplate ) ; } return $ templates ; }
12800	public function getHeaders ( ) { if ( ! isset ( $ this -> _headers ) ) { $ this -> _headers = $ this -> readLine ( 1 ) ; if ( ! $ this -> _headers ) { $ this -> _headers = [ ] ; } } return $ this -> _headers ; }
9063	private function getKeys ( ) : array { $ result = [ ] ; $ rows = $ this -> connection -> query ( " SELECT [INDEX_NAME], [COLUMN_NAME], [INDEX_TYPE], [NON_UNIQUE], [SEQ_IN_INDEX] FROM [information_schema.STATISTICS] WHERE [TABLE_SCHEMA] = %s AND [TABLE_NAME] = %s AND [INDEX_NAME] != %s" , $ this -> database , $ this -> name , 'PRIMARY' ) ; foreach ( $ rows as $ row ) { $ name = $ row -> INDEX_NAME ; if ( isset ( $ result [ $ name ] ) ) { $ obj = $ result [ $ name ] ; } else { $ obj = new Key ; } $ obj -> name = $ name ; $ obj -> addColumn ( $ row -> SEQ_IN_INDEX , $ row -> COLUMN_NAME ) ; $ obj -> type = $ row -> INDEX_TYPE ; $ obj -> unique = ! $ row -> NON_UNIQUE ; $ result [ $ name ] = $ obj ; } return $ result ; }
6052	public function retrieveFolder ( $ id , $ depth = 0 , $ includeProperties = true , $ includeObjectCounts = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'depth' => $ depth , 'includeProperties' => $ includeProperties , 'includeObjectCounts' => $ includeObjectCounts ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
9195	public function setThemesPath ( $ path ) { if ( ! is_dir ( $ path ) ) { throw new \ Exception ( sprintf ( 'Path "%s" not found.' , $ path ) ) ; } $ this -> themesPath = rtrim ( $ path , DS ) ; return $ this ; }
6337	public function parse ( SaxHandlerInterface $ saxHandler , $ xmlDocument ) { $ xmlDocument = ( $ xmlDocument instanceof StreamInterface ) ? $ xmlDocument : $ this -> getDocumentStream ( $ xmlDocument ) ; return $ saxHandler -> parse ( $ xmlDocument ) ; }
2275	public function getLayoutSections ( ) { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; $ objLayout = $ this -> Database -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = Contao \ StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ arrSections [ ] = $ v [ 'id' ] ; } } } } return Contao \ Backend :: convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) ; }
7991	public function setSshKey ( $ pp , $ pca , $ key ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ key ) throw new BadMethodCallException ( 'Missing parameter $key (Public key for this pca).' ) ; $ payload = array ( 'sshkey' => $ key ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
12464	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ entity = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ id ) ; if ( ! $ entity ) { throw $ this -> createNotFoundException ( 'Unable to find CustomFieldsGroup entity.' ) ; } $ options = $ this -> getOptionsAvailable ( $ entity -> getEntity ( ) ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:show.html.twig' , array ( 'entity' => $ entity , 'create_field_form' => $ this -> createCreateFieldForm ( $ entity ) -> createView ( ) , 'options' => $ options ) ) ; }
11444	public function setTransporter ( TransportInterface $ transporter ) { if ( $ transporter -> validate ( ) ) { $ this -> transporter = $ transporter ; } else { throw new \ Exception ( sprintf ( 'Transporter "%s" is not valid for current environment!' , get_class ( $ transporter ) ) ) ; } return $ this ; }
10536	public function extractHeaders ( ) { $ headers = [ ] ; $ requestHeaders = array_keys ( $ this -> cors ) ; foreach ( $ requestHeaders as $ headerField ) { $ serverField = $ this -> headerizeToPhp ( $ headerField ) ; $ headerData = isset ( $ _SERVER [ $ serverField ] ) ? $ _SERVER [ $ serverField ] : null ; if ( $ headerData !== null ) { $ headers [ $ headerField ] = $ headerData ; } } return $ headers ; }
399	protected function deleteInternal ( ) { if ( ! $ this -> beforeDelete ( ) ) { return false ; } $ condition = $ this -> getOldPrimaryKey ( true ) ; $ lock = $ this -> optimisticLock ( ) ; if ( $ lock !== null ) { $ condition [ $ lock ] = $ this -> $ lock ; } $ result = static :: deleteAll ( $ condition ) ; if ( $ lock !== null && ! $ result ) { throw new StaleObjectException ( 'The object being deleted is outdated.' ) ; } $ this -> setOldAttributes ( null ) ; $ this -> afterDelete ( ) ; return $ result ; }
5605	public function paintMethodEnd ( $ method ) { if ( $ this -> fail || $ this -> error || ! $ this -> pass ) { } else { $ this -> listener -> write ( '{status:"pass",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
962	public function buildAuthUrl ( $ mode = null ) { return $ this -> api -> getAuthUrl ( Config :: get ( 'shopify-app.api_scopes' ) , URL :: secure ( Config :: get ( 'shopify-app.api_redirect' ) ) , $ mode ?? 'offline' ) ; }
9985	private function mapVAlign ( $ vAlign ) { switch ( $ vAlign ) { case Alignment :: VERTICAL_BOTTOM : return 'bottom' ; case Alignment :: VERTICAL_TOP : return 'top' ; case Alignment :: VERTICAL_CENTER : case Alignment :: VERTICAL_JUSTIFY : return 'middle' ; default : return 'baseline' ; } }
12908	public function update ( FilterRequest $ request , $ id ) { $ this -> fieldManager = $ this -> getFieldManager ( ) ; $ this -> validate ( $ request -> request , $ this -> fieldManager -> update ( ) ) ; $ id = $ this -> getRealId ( $ id ) ; $ resource = $ this -> repository -> update ( $ request -> all ( ) , $ id ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
3058	public function containsAdaptive ( ) { $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ this -> getCompilationDirectory ( ) [ 'private' ] ) ; return ! empty ( $ adaptiveSectionMap ) ; }
533	public function actionFix ( $ root = null ) { $ files = $ this -> findFiles ( $ root , false ) ; $ nFilesTotal = 0 ; $ nFilesUpdated = 0 ; foreach ( $ files as $ file ) { $ contents = file_get_contents ( $ file ) ; $ hash = $ this -> hash ( $ contents ) ; $ lines = preg_split ( '/(\r\n|\n|\r)/' , $ contents ) ; if ( ! $ this -> skipFrameworkRequirements ) { $ this -> fixFileDoc ( $ lines ) ; } $ this -> fixDocBlockIndentation ( $ lines ) ; $ lines = array_values ( $ this -> fixLineSpacing ( $ lines ) ) ; $ newContent = implode ( "\n" , $ lines ) ; if ( $ hash !== $ this -> hash ( $ newContent ) ) { file_put_contents ( $ file , $ newContent ) ; $ nFilesUpdated ++ ; } $ nFilesTotal ++ ; } $ this -> stdout ( "\nParsed $nFilesTotal files.\n" ) ; $ this -> stdout ( "Updated $nFilesUpdated files.\n" ) ; }
892	public function getNormalizedTypes ( ) { $ normalized = array_map ( static function ( $ type ) { return strtolower ( $ type ) ; } , $ this -> getTypes ( ) ) ; sort ( $ normalized ) ; return $ normalized ; }
5309	protected function getPathFromCircle ( SimpleXMLElement $ circle ) { $ mult = 0.55228475 ; return 'M' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . $ circle [ 'cy' ] . 'C' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] ) . ' ' . $ circle [ 'cx' ] . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] ) . 'C' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] ) . ' ' . $ circle [ 'cy' ] . 'C' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] ) . ' ' . $ circle [ 'cx' ] . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] ) . 'C' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . $ circle [ 'cy' ] . 'Z' ; }
8304	public function assertInteger ( $ config , $ key , $ lowest = null , $ highest = null ) { if ( array_key_exists ( $ key , $ config ) ) { if ( ! is_int ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be an integer." ) ; } if ( $ lowest !== null && $ config [ $ key ] < $ lowest ) { throw new ConfigurationException ( $ key . " cannot be lower than " . $ lowest ) ; } if ( $ highest !== null && $ config [ $ key ] > $ highest ) { throw new ConfigurationException ( $ key . " cannot be higher than " . $ highest ) ; } } return $ this ; }
8589	public function setReportScheduleList ( $ reportSchedule ) { if ( ! $ this -> _isNumericArray ( $ reportSchedule ) ) { $ reportSchedule = array ( $ reportSchedule ) ; } $ this -> fields [ 'ReportSchedule' ] [ 'FieldValue' ] = $ reportSchedule ; return $ this ; }
8299	public function addRule ( $ url , $ rule ) { if ( ! is_string ( $ url ) || ! is_array ( $ rule ) ) { throw new \ InvalidArgumentException ( "addRule() expects a string and an array." ) ; } $ this -> runtimeRules [ $ url ] = $ rule ; }
3788	public static function calculateConditions ( IMetaModelDataDefinition $ container , array $ inputScreen ) { if ( $ container -> hasDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ) { $ definition = $ container -> getDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ; } else { $ definition = new DefaultModelRelationshipDefinition ( ) ; $ container -> setDefinition ( ModelRelationshipDefinitionInterface :: NAME , $ definition ) ; } if ( ! $ definition instanceof ModelRelationshipDefinitionInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } $ instance = new static ( ) ; $ instance -> container = $ container ; $ instance -> inputScreen = $ inputScreen ; $ instance -> definition = $ definition ; $ instance -> calculate ( ) ; }
12690	protected function merge ( array $ configs ) { $ objects = array_filter ( $ configs , 'is_object' ) ; if ( ! empty ( $ objects ) ) { $ listConfigs = [ ] ; foreach ( $ configs as $ config ) { if ( ! is_object ( $ config ) ) { throw new RuntimeException ( 'Cannot merge object with other types' ) ; } $ listConfigs [ ] = ( array ) $ config ; } $ result = ( object ) $ this -> merge ( $ listConfigs ) ; } else { foreach ( $ configs as $ config ) { foreach ( $ config as $ key => $ value ) { $ existed = isset ( $ result [ $ key ] ) ; switch ( true ) { case ( $ existed && ( is_object ( $ result [ $ key ] ) || is_object ( $ value ) ) ) : case ( $ existed && ( is_array ( $ result [ $ key ] ) && is_array ( $ value ) ) ) : $ result [ $ key ] = $ this -> merge ( array ( $ result [ $ key ] , $ value ) ) ; break ; default : $ result [ $ key ] = $ value ; } } } } return $ result ; }
7627	public function createContainerIfNotExists ( $ containerName = '' , $ metadata = array ( ) ) { if ( ! $ this -> containerExists ( $ containerName ) ) { $ this -> createContainer ( $ containerName , $ metadata ) ; } }
3697	public function checkPurge ( AbstractModelAwareEvent $ event ) { $ table = $ event -> getModel ( ) -> getProviderName ( ) ; if ( ( $ table == 'tl_metamodel' ) || ( $ table == 'tl_metamodel_dca' ) || ( $ table == 'tl_metamodel_dca_sortgroup' ) || ( $ table == 'tl_metamodel_dcasetting' ) || ( $ table == 'tl_metamodel_dcasetting_condition' ) || ( $ table == 'tl_metamodel_attribute' ) || ( $ table == 'tl_metamodel_filter' ) || ( $ table == 'tl_metamodel_filtersetting' ) || ( $ table == 'tl_metamodel_rendersettings' ) || ( $ table == 'tl_metamodel_rendersetting' ) || ( $ table == 'tl_metamodel_dca_combine' ) ) { $ this -> purger -> purge ( ) ; } }
6474	private function rankAcceptCharsetHeaders ( array $ charsetHeaders ) : array { usort ( $ charsetHeaders , [ $ this , 'compareAcceptCharsetHeaders' ] ) ; $ rankedCharsetHeaders = array_filter ( $ charsetHeaders , [ $ this , 'filterZeroScores' ] ) ; return array_values ( $ rankedCharsetHeaders ) ; }
5191	private function handleString ( $ str ) : string { return is_string ( $ str ) && strlen ( $ str ) > 0 && $ str !== null ? $ str : '' ; }
9114	public function init ( ) { $ this -> registerController ( \ Nkey \ Caribu \ Mvc \ Controller \ ErrorController :: class ) ; $ this -> registerView ( \ Nkey \ Caribu \ Mvc \ View \ DefaultView :: class ) ; }
6289	public function set ( $ theme ) { if ( ! $ this -> has ( $ theme ) ) { throw new ThemeNotFoundException ( $ theme ) ; } $ this -> loadTheme ( $ theme ) ; }
9054	public function createRelationTable ( $ tableName ) : self { $ table = $ this -> getTableData ( $ tableName ) ; $ name = $ this -> name . '_x_' . $ table -> name ; return $ this -> relationTables [ ] = $ this -> tableFactory -> create ( $ name , $ this -> prefix ) ; }
10141	private function loadOLE ( $ pFilename ) { $ ole = new OLERead ( ) ; $ ole -> read ( $ pFilename ) ; $ this -> data = $ ole -> getStream ( $ ole -> wrkbook ) ; $ this -> summaryInformation = $ ole -> getStream ( $ ole -> summaryInformation ) ; $ this -> documentSummaryInformation = $ ole -> getStream ( $ ole -> documentSummaryInformation ) ; }
11274	public function install ( ) : Migrate { Whois :: print ( $ this -> getNotify ( ) ) ; $ this -> exists ( ) || $ this -> migrationRepository -> createRepository ( ) ; return $ this ; }
7723	public function objectToArray ( $ object , $ array = [ ] ) { $ reflectionClass = new \ ReflectionClass ( get_class ( $ object ) ) ; foreach ( $ reflectionClass -> getProperties ( ) as $ property ) { $ property -> setAccessible ( true ) ; $ name = trim ( strtolower ( preg_replace ( '/[A-Z]([A-Z](?![a-z]))*/' , '_$0' , $ property -> getName ( ) ) ) , '_' ) ; if ( empty ( $ property -> getValue ( $ object ) ) ) { continue ; } else if ( is_object ( $ property -> getValue ( $ object ) ) ) { $ array [ $ name ] = $ this -> objectToArray ( $ property -> getValue ( $ object ) ) ; } else if ( is_array ( $ property -> getValue ( $ object ) ) ) { foreach ( $ property -> getValue ( $ object ) as $ key => $ value ) { if ( is_object ( $ value ) ) { $ array [ $ name ] [ ] = $ this -> objectToArray ( $ value ) ; } } } else { $ array [ $ name ] = $ property -> getValue ( $ object ) ; } $ property -> setAccessible ( false ) ; } return $ array ; }
8405	public static function run ( ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'bootstrap doesn\'t seem to have been initialized' ) ; } foreach ( self :: $ namespaces as $ name => $ path ) { if ( is_readable ( $ path . DIRECTORY_SEPARATOR . 'init.php' ) === true ) { require $ path . DIRECTORY_SEPARATOR . 'init.php' ; } elseif ( stripos ( $ path , 'vendor' ) === false || stripos ( $ path , 'vendor' ) == strlen ( $ path ) - strlen ( 'vendor' ) ) { Logger :: get ( ) -> error ( 'namespace "' . $ name . '" doesn\'t have an init.php' ) ; } } if ( defined ( 'STRAY_IS_CLI' ) === true && constant ( 'STRAY_IS_CLI' ) === true ) { Console :: run ( ) ; } elseif ( defined ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_IS_HTTP' ) === true ) { if ( count ( self :: $ applications ) == 0 ) { throw new BadUse ( 'no application has been registered' ) ; } Http :: run ( ) ; } else { throw new BadUse ( 'unknown mode, not CLI_IS_CLI nor STRAY_IS_HTTP' ) ; } }
12838	static public function dir ( $ directory , $ date = false ) { if ( $ date ) { $ directory = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . self :: getDateDirectory ( ) ; } if ( ! is_dir ( $ directory ) ) { $ umask = umask ( 0000 ) ; if ( @ mkdir ( $ directory , 0777 , true ) === false ) { throw new Exception ( sprintf ( 'Directory "%s" cannot be created.' , $ directory ) ) ; } umask ( $ umask ) ; } return $ directory ; }
8440	public function createAction ( string $ production_slug , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_USER' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; $ post = new Post ( ) ; $ post -> setActive ( true ) ; $ post -> setPinned ( false ) ; $ post -> setAuthor ( $ user -> getUsername ( ) ) ; $ post -> addGroup ( $ production ) ; if ( $ request -> query -> has ( 'reply-to' ) ) { $ repo = $ this -> em -> getRepository ( Post :: class ) ; if ( null === $ parent = $ repo -> findOneBy ( [ 'id' => $ request -> query -> get ( 'reply-to' ) ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ parent -> getGroups ( ) -> contains ( $ production ) ) { throw new AccessDeniedException ( ) ; } if ( null !== $ parent -> getParent ( ) ) { throw new AccessDeniedException ( ) ; } $ post -> setParent ( $ parent ) ; $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> persist ( $ post ) ; $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.created' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/create.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
6598	protected function getParameters ( array $ lines ) { $ comment = implode ( "\n" , $ lines ) ; preg_match_all ( '/@param\s([\s\S]+?(?=@))/' , $ comment , $ paramsDoc ) ; $ params = [ ] ; if ( isset ( $ paramsDoc [ 1 ] ) ) { foreach ( $ paramsDoc [ 1 ] as $ paramDoc ) { $ documentation = [ ] ; preg_match ( '/([^$]+)?\$(\w+)(.+)?/s' , $ paramDoc , $ documentation ) ; list ( , $ type , $ name , $ description ) = $ documentation ; $ lines = preg_split ( "/((\r?\n)|(\r\n?))/" , $ description ) ; foreach ( $ lines as $ key => $ value ) { $ value = preg_replace ( '/\r/' , '' , $ value ) ; $ value = preg_replace ( '/^\s+\*/' , '' , $ value ) ; $ value = trim ( $ value ) ; $ lines [ $ key ] = $ value ; } $ description = implode ( "\n" , $ lines ) ; $ params [ $ name ] = [ 'type' => trim ( $ type ) , 'description' => trim ( $ description ) , ] ; } } return $ params ; }
11773	private function findComponentModuleByType ( array $ module_list , string $ find_component_type ) { foreach ( $ module_list as $ m ) { $ component_type = call_user_func ( [ $ m , 'declareComponentType' ] ) ; if ( $ component_type == $ find_component_type ) { return $ m ; } } return null ; }
11987	private function isEndOfLine ( $ i ) { $ ch = $ this -> data [ $ i ] ; if ( $ this -> getLineEndingModeCrlf ( ) ) { if ( $ ch == "\r" ) { $ more_ch = $ i + 1 < strlen ( $ this -> data ) ; if ( $ more_ch ) { $ next_n = $ this -> data [ $ i + 1 ] == "\n" ; if ( $ next_n ) return true ; } } } else { if ( $ ch == "\n" ) return true ; } return false ; }
10995	public function write ( string $ contents , int $ opts = 0 ) : bool { if ( $ this -> prepareWrite ( ) !== true ) { $ this -> error = "failed to write '{$this->path}; {$this->error}" ; return false ; } return $ this -> writeFile ( $ contents , $ opts ) ; }
7659	function AddrAppend ( $ type , $ addr ) { $ addr_str = $ type . ": " ; $ addr_str .= $ this -> AddrFormat ( $ addr [ 0 ] ) ; if ( count ( $ addr ) > 1 ) { for ( $ i = 1 ; $ i < count ( $ addr ) ; $ i ++ ) $ addr_str .= ", " . $ this -> AddrFormat ( $ addr [ $ i ] ) ; } $ addr_str .= $ this -> LE ; return $ addr_str ; }
2359	public function isPreviewMode ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return $ token instanceof FrontendPreviewToken && $ token -> showUnpublished ( ) ; }
9523	private function getConfig ( ) { $ yaml = new Parser ( ) ; $ configFile = getenv ( 'TRAVIS_BUILD_DIR' ) . '/.travis.yml' ; $ config = $ yaml -> parse ( file_get_contents ( $ configFile ) ) ; $ config = $ config [ 'travisdeployer' ] ; $ this -> branches = $ config [ 'branches' ] ; if ( count ( $ this -> branches ) === 0 ) { die ( 'No branches are configured to deploy to.' . PHP_EOL ) ; } $ this -> verbose = filter_input ( FILTER_VALIDATE_BOOLEAN , $ config [ 'verbose' ] ) ; }
9832	public function setRevisionsPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> revisionsPassword = $ pValue ; return $ this ; }
554	private function notifyCachesCanBeFlushed ( $ caches ) { $ this -> stdout ( "The following caches were found in the system:\n\n" , Console :: FG_YELLOW ) ; foreach ( $ caches as $ name => $ class ) { if ( $ this -> canBeFlushed ( $ class ) ) { $ this -> stdout ( "\t* $name ($class)\n" , Console :: FG_GREEN ) ; } else { $ this -> stdout ( "\t* $name ($class) - can not be flushed via console\n" , Console :: FG_YELLOW ) ; } } $ this -> stdout ( "\n" ) ; }
5825	public function encodeData ( ) { switch ( $ this -> encoding ) { case Request :: ENCODING_JSON : return json_encode ( $ this -> data ) ; break ; case Request :: ENCODING_RAW : return ( string ) $ this -> data ; break ; case Request :: ENCODING_QUERY : return http_build_query ( $ this -> data ) ; break ; default : throw new \ UnexpectedValueException ( "Encoding [$encoding] not a known Request::ENCODING_* constant" ) ; } }
2008	private function loadLanguageFile ( string $ name ) : void { $ system = $ this -> framework -> getAdapter ( System :: class ) ; $ system -> loadLanguageFile ( $ name ) ; }
8384	public function select ( $ select ) { if ( is_array ( $ select ) === true ) { $ this -> select = '' ; foreach ( $ select as $ key => $ elem ) { $ this -> select .= $ elem ; if ( is_numeric ( $ key ) === false ) { $ this -> select .= ' AS ' . $ key ; } $ this -> select .= ', ' ; } $ this -> select = substr ( $ this -> select , 0 , - 2 ) ; } elseif ( ! is_string ( $ select ) ) { throw new InvalidArgumentException ( sprintf ( 'Argument 1 passed to %s must be an array or string!' , __METHOD__ ) ) ; } else { $ this -> select = $ select ; } return $ this ; }
12144	public static function login ( $ rank = 1 , $ id = null ) { static :: provider ( ) -> set ( 'valid' , true ) ; static :: provider ( ) -> set ( 'rank' , $ rank ) ; static :: provider ( ) -> set ( 'id' , $ id ) ; return static :: user ( ) ; }
3662	private function parseTable ( ) { $ this -> queryString = str_replace ( '{{table}}' , $ this -> collection -> getMetaModel ( ) -> getTableName ( ) , $ this -> queryString ) ; }
8529	public function listFinancialEvents ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4347	private function getCfgAll ( ) { $ cfg = array ( ) ; foreach ( \ array_keys ( $ this -> configKeys ) as $ classname ) { if ( $ classname === 'debug' ) { $ cfg [ 'debug' ] = $ this -> cfg ; } elseif ( isset ( $ this -> debug -> { $ classname } ) ) { $ cfg [ $ classname ] = $ this -> debug -> { $ classname } -> getCfg ( ) ; } elseif ( isset ( $ this -> cfgLazy [ $ classname ] ) ) { $ cfg [ $ classname ] = $ this -> cfgLazy [ $ classname ] ; } } return $ cfg ; }
8611	private function _convertUpdateSubscription ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'UpdateSubscription' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetSubscription ( ) ) { $ SubscriptionUpdateSubscriptionInput = $ request -> getSubscription ( ) ; foreach ( $ SubscriptionUpdateSubscriptionInput -> getNotificationType ( ) as $ NotificationTypeSubscriptionIndex => $ NotificationTypeSubscription ) { $ parameters [ 'Subscription' . '.' . 'NotificationType' . '.' . ( $ NotificationTypeSubscriptionIndex + 1 ) ] = $ NotificationTypeSubscription ; } } return $ parameters ; }
10741	protected function buildRecord ( ) { $ res = [ ] ; foreach ( $ this -> clause_records as $ tbl ) { $ res [ ] = $ this -> quote ( $ tbl ) . '.*' ; } if ( ! empty ( $ res ) ) { return [ join ( ', ' , $ res ) ] ; } else { return [ ] ; } }
6416	public static function skip ( IteratorAggregate $ iterable , int $ numberToSkip ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ iterable , $ numberToSkip ) { $ iterator = Iterators :: from ( $ iterable -> getIterator ( ) ) ; Iterators :: advance ( $ iterator , $ numberToSkip ) ; return $ iterator ; } ) ; }
9182	public function remember ( $ value , $ memoryDuration = null ) { if ( is_null ( $ memoryDuration ) ) { $ memoryDuration = $ this -> memoryDuration ; } $ key = $ this -> getRememberKey ( ) ; if ( Cache :: has ( $ key ) ) { $ value = Cache :: get ( $ key ) ; } else { $ expiresAt = Carbon :: now ( ) -> addMinutes ( $ memoryDuration ) ; if ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } Cache :: put ( $ key , $ value , $ expiresAt ) ; } return $ value ; }
12579	public function previewImageByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_IMAGE , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
2585	protected function loadReferences ( $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> passengers , $ params -> segments ) ) { $ this -> psaInformation = new PsaInformation ( ) ; foreach ( $ params -> passengers as $ passenger ) { $ this -> psaInformation -> refDetails [ ] = new RefDetails ( $ passenger , RefDetails :: QUAL_PASSENGER ) ; } foreach ( $ params -> segments as $ segment ) { $ this -> psaInformation -> refDetails [ ] = new RefDetails ( $ segment , RefDetails :: QUAL_SEGMENT_REFERENCE ) ; } } }
11259	public static function pascal2snake ( string $ pascal ) : string { preg_match_all ( '/((?:^|[A-Z])[a-z]+)/' , $ pascal , $ matches ) ; if ( $ matches !== null && count ( $ matches ) > 1 && count ( $ matches [ 1 ] ) > 1 ) { $ nameParts = $ matches [ 1 ] ; $ nameParts = array_map ( "lcfirst" , $ nameParts ) ; return implode ( "_" , $ nameParts ) ; } else { return lcfirst ( $ pascal ) ; } }
8603	private function _convertDeregisterDestination ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationDeregisterDestinationInput = $ request -> getDestination ( ) ; foreach ( $ DestinationDeregisterDestinationInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
8903	public function delete_by_at ( $ condition , $ time ) { $ this -> prevent_if_not_soft_deletable ( ) ; $ this -> _set_where ( $ condition ) ; return $ this -> _delete ( $ condition , $ time ) ; }
9110	protected function attainPathName ( ) { $ path = false ; $ config = $ this -> getConfig ( ) ; if ( isset ( $ config [ 'theme_locator' ] [ 'themes_default_path' ] ) ) { $ path = $ config [ 'theme_locator' ] [ 'themes_default_path' ] ; } $ themeName = $ this -> attainThemeName ( ) ; if ( isset ( $ config [ 'themes' ] ) && is_array ( $ config [ 'themes' ] ) && isset ( $ config [ 'themes' ] [ $ themeName ] ) ) { if ( array_key_exists ( 'dir_path' , $ config [ 'themes' ] [ $ themeName ] ) ) { $ path = $ config [ 'themes' ] [ $ themeName ] [ 'dir_path' ] ; } } return $ path ; }
7640	public static function isValidContainerName ( $ containerName = '' ) { if ( $ containerName == '$root' ) { return true ; } if ( preg_match ( "/^[a-z0-9][a-z0-9-]*$/" , $ containerName ) === 0 ) { return false ; } if ( strpos ( $ containerName , '--' ) !== false ) { return false ; } if ( strtolower ( $ containerName ) != $ containerName ) { return false ; } if ( strlen ( $ containerName ) < 3 || strlen ( $ containerName ) > 63 ) { return false ; } if ( substr ( $ containerName , - 1 ) == '-' ) { return false ; } return true ; }
144	public function insert ( RuleWatchNode $ node ) { if ( $ node -> getRule ( ) -> isAssertion ( ) ) { return ; } foreach ( array ( $ node -> watch1 , $ node -> watch2 ) as $ literal ) { if ( ! isset ( $ this -> watchChains [ $ literal ] ) ) { $ this -> watchChains [ $ literal ] = new RuleWatchChain ; } $ this -> watchChains [ $ literal ] -> unshift ( $ node ) ; } }
4017	protected function handleLoadCallback ( $ field , $ value ) { if ( isset ( $ field [ 'load_callback' ] ) && is_array ( $ field [ 'load_callback' ] ) ) { foreach ( $ field [ 'load_callback' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ value = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ value , $ this ) ; } } return $ value ; }
5282	public function getVar ( ) { $ row = $ this -> one ( \ ARRAY_A ) ; return is_null ( $ row ) ? false : current ( $ row ) ; }
1615	public function readSession ( $ id ) { $ data = $ this -> redis -> executeCommand ( 'GET' , [ $ this -> calculateKey ( $ id ) ] ) ; return $ data === false || $ data === null ? '' : $ data ; }
12625	public function get ( $ url , $ data = array ( ) ) { $ client = $ this -> getClient ( ) ; return $ client -> request ( 'GET' , $ url , array ( 'query' => $ data ) ) ; }
706	public function primaryKey ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_PK , $ length ) ; }
7409	public function & offsetGet ( $ offset ) { if ( ! $ this -> offsetExists ( $ offset ) ) { $ this -> offsetSet ( $ offset , null ) ; if ( null === $ offset ) { end ( $ this -> _container ) ; $ offset = key ( $ this -> _container ) ; } } return $ this -> _container [ $ offset ] ; }
8194	public function render ( $ template , $ data = [ ] , $ return = true ) { if ( $ template instanceof Page ) { $ page = $ template ; $ file = $ page -> templateFile ( ) ; $ data = $ this -> data ( $ page , $ data ) ; } else { $ file = $ template ; $ data = $ this -> data ( null , $ data ) ; } if ( ! file_exists ( $ file ) ) { throw new Exception ( 'The template could not be found' ) ; } $ startData = Tpl :: $ data ; Tpl :: $ data = array_merge ( Tpl :: $ data , $ data ) ; if ( pathinfo ( $ file , PATHINFO_EXTENSION ) === 'twig' ) { $ twig = TwigEnv :: instance ( ) ; $ result = $ twig -> renderPath ( $ file , Tpl :: $ data , $ return , true ) ; } else { $ result = Tpl :: load ( $ file , [ ] , $ return ) ; } Tpl :: $ data = $ startData ; return $ result ; }
6834	private function getFindNewBySupplierQuery ( ) { if ( null !== $ this -> findNewBySupplierQuery ) { return $ this -> findNewBySupplierQuery ; } $ qb = $ this -> createQueryBuilder ( ) ; $ as = $ this -> getAlias ( ) ; return $ this -> findNewBySupplierQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.supplier' , ':supplier' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.state' , ':state' ) ) -> getQuery ( ) -> setParameter ( 'state' , Model \ SupplierOrderStates :: STATE_NEW ) ; }
11264	public function repeat ( & $ property , $ repeatTag , $ classes = '' , $ outerTag = false , $ outerClasses = '' ) { if ( isset ( $ property ) ) { $ output = '' ; if ( $ outerTag ) { $ output .= '<' . $ outerTag . ' class="' . $ outerClasses . '">' ; } if ( is_array ( $ property ) ) { foreach ( $ property as $ value ) { $ output .= '<' . $ repeatTag . ' class="' . $ classes . '">' ; $ output .= $ value ; $ output .= '</' . $ repeatTag . '>' ; } } else { $ output .= '<' . $ repeatTag . ' class="' . $ classes . '">' ; $ output .= $ property ; $ output .= '</' . $ repeatTag . '>' ; } if ( $ outerTag ) { $ output .= '</' . $ outerTag . '>' ; } echo $ output ; } else echo '' ; }
9920	private function findSimpleRelations ( Model $ model ) { foreach ( $ model -> getColumns ( ) as $ column ) { if ( ends_with ( $ column -> getName ( ) , self :: ID_SUFFIX ) ) { $ this -> defineRelation ( $ model , $ column -> getName ( ) ) ; } } }
11634	public function bindPage ( array $ deviceIdentifier , array $ pageIds ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'page_ids' => $ pageIds , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_BINDPAGE , $ params ] ) ; }
7119	protected function getGetMinEdaBySubjectQuery ( ) { if ( null !== $ this -> getMinEdaBySubjectQuery ) { return $ this -> getMinEdaBySubjectQuery ; } $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; $ qb -> andWhere ( $ qb -> expr ( ) -> isNotNull ( $ as . '.estimatedDateOfArrival' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> gte ( $ as . '.orderedStock' , 0 ) , $ qb -> expr ( ) -> gte ( $ as . '.availableStock' , 0 ) ) ) -> select ( 'MIN(' . $ as . '.estimatedDateOfArrival) as eda' ) ; return $ this -> getMinEdaBySubjectQuery = $ qb -> getQuery ( ) ; }
4899	public static function setupCliServerEnv ( ) { $ parseUrl = parse_url ( substr ( $ _SERVER [ "REQUEST_URI" ] , 1 ) ) ; $ route = isset ( $ parseUrl [ 'path' ] ) ? $ parseUrl [ 'path' ] : null ; if ( is_file ( __DIR__ . '/' . $ route ) ) { if ( substr ( $ route , - 4 ) == ".php" ) { require __DIR__ . '/' . $ route ; exit ; } return false ; } else { $ _GET [ "q" ] = $ route ; } return true ; }
2330	public function next ( ) { if ( ! isset ( $ this -> arrModels [ $ this -> intIndex + 1 ] ) ) { return false ; } ++ $ this -> intIndex ; return $ this ; }
10125	private function writeAutoFilterInfo ( ) { $ record = 0x009D ; $ length = 0x0002 ; $ rangeBounds = Coordinate :: rangeBoundaries ( $ this -> phpSheet -> getAutoFilter ( ) -> getRange ( ) ) ; $ iNumFilters = 1 + $ rangeBounds [ 1 ] [ 0 ] - $ rangeBounds [ 0 ] [ 0 ] ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ iNumFilters ) ; $ this -> append ( $ header . $ data ) ; }
4756	public function transform ( $ value ) { if ( $ value instanceof \ Traversable || is_array ( $ value ) ) { return $ this -> transformIterable ( $ value ) ; } if ( is_bool ( $ value ) ) { return $ this -> transformBoolean ( $ value ) ; } if ( is_scalar ( $ value ) || ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) ) { return $ value ; } if ( $ value instanceof Cache ) { return $ this -> transformCacheAnnotation ( $ value ) ; } if ( $ value instanceof Method ) { return $ this -> transformMethodAnnotation ( $ value ) ; } if ( $ value instanceof ParamConverter ) { return $ this -> transformParamConverter ( $ value ) ; } if ( $ value instanceof Security ) { return $ this -> transformSecurity ( $ value ) ; } if ( $ value instanceof Template ) { return $ this -> transformTemplate ( $ value ) ; } return get_class ( $ value ) ; }
5651	public function explainFlag ( $ flags , $ explanation ) { $ flags = is_array ( $ flags ) ? $ flags : array ( $ flags ) ; $ this -> flag_sets [ ] = $ flags ; $ this -> explanations [ ] = $ explanation ; }
3680	private function injectChildTables ( & $ localMenu ) { $ parented = $ this -> viewCombination -> getParented ( ) ; $ lastCount = count ( $ parented ) ; while ( $ parented ) { foreach ( $ parented as $ metaModelName => $ child ) { foreach ( $ localMenu as $ groupName => $ modules ) { foreach ( $ modules as $ moduleName => $ module ) { if ( isset ( $ module [ 'tables' ] ) && in_array ( $ child [ 'meta' ] [ 'ptable' ] , $ module [ 'tables' ] ) ) { $ localMenu [ $ groupName ] [ $ moduleName ] [ 'tables' ] [ ] = $ metaModelName ; unset ( $ parented [ $ metaModelName ] ) ; break ; } } } } if ( count ( $ parented ) == $ lastCount ) { break ; } $ lastCount = count ( $ parented ) ; } }
7051	private function addViolation ( $ value , Constraint $ constraint ) { if ( $ this -> context instanceof ExecutionContextInterface ) { $ this -> context -> buildViolation ( $ constraint -> getMessage ( ) ) -> setParameter ( '{{ type }}' , $ constraint -> getType ( ) ) -> setParameter ( '{{ value }}' , $ this -> formatValue ( $ value ) ) -> setCode ( PhoneNumber :: INVALID_PHONE_NUMBER_ERROR ) -> addViolation ( ) ; } else { $ this -> context -> addViolation ( $ constraint -> getMessage ( ) , array ( '{{ type }}' => $ constraint -> getType ( ) , '{{ value }}' => $ value ) ) ; } }
11445	public function getTransporter ( ) { if ( empty ( $ this -> transporter ) ) { $ transport_class = $ this -> getDefault ( 'transporter' ) ; if ( class_exists ( $ transport_class ) ) { $ this -> setTransporter ( new $ transport_class ) ; } else { throw new \ Exception ( sprintf ( 'Default transport class "%s" not found!' , $ transport_class ) ) ; } } return $ this -> transporter ; }
2499	private function getAlwaysAvailableFilter ( array $ languageCodes ) { $ conditions = array ( new CustomField ( self :: FIELD_IS_ALWAYS_AVAILABLE , Operator :: EQ , true ) , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ languageCodes ) ) , ) ; if ( $ this -> hasMainLanguagesEndpoint ) { $ conditions [ ] = new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ; } return new LogicalAnd ( $ conditions ) ; }
10235	private function getImageMimeType ( $ pFile ) { if ( File :: fileExists ( $ pFile ) ) { $ image = getimagesize ( $ pFile ) ; return image_type_to_mime_type ( $ image [ 2 ] ) ; } throw new WriterException ( "File $pFile does not exist" ) ; }
5235	public function withEntryFromProvider ( $ key , $ provider ) { $ this -> bindings [ $ key ] = $ this -> getProviderCreator ( $ provider ) ; return $ this ; }
10281	public static function absoluteCoordinate ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } list ( $ column , $ row ) = self :: coordinateFromString ( $ pCoordinateString ) ; $ column = ltrim ( $ column , '$' ) ; $ row = ltrim ( $ row , '$' ) ; return $ worksheet . '$' . $ column . '$' . $ row ; }
12060	public function getTargetLabel ( ) { if ( ! isset ( $ this -> labels [ $ this -> target ] ) ) { return [ 'long' => 'unknown' , 'short' => 'unknown' ] ; } return $ this -> labels [ $ this -> target ] ; }
3408	public function getLockFactory ( ) : Factory { if ( $ this -> lockFactory !== null ) { return $ this -> lockFactory ; } if ( ! is_dir ( $ this -> lockPath ) ) { ( new Filesystem ( ) ) -> mkdir ( $ this -> lockPath ) ; } $ store = new FlockStore ( $ this -> lockPath ) ; return $ this -> setLockStore ( $ store ) ; }
1761	protected static function readPhpFileWithoutTags ( $ strName ) { @ trigger_error ( 'Using System::readPhpFileWithoutTags() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\PhpFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new PhpFileLoader ( ) ; return $ loader -> load ( $ strName ) ; }
911	public function addBlank ( ) { $ matched = Preg :: match ( '/^([ \t]*\*)[^\r\n]*(\r?\n)$/' , $ this -> content , $ matches ) ; if ( 1 !== $ matched ) { return ; } $ this -> content .= $ matches [ 1 ] . $ matches [ 2 ] ; }
1592	protected function validateResource ( ) : bool { $ identifier = $ this -> validateTypeAndId ( ) ; $ attributes = $ this -> validateAttributes ( ) ; $ relationships = $ this -> validateRelationships ( ) ; if ( $ attributes && $ relationships ) { return $ this -> validateAllFields ( ) && $ identifier ; } return $ identifier && $ attributes && $ relationships ; }
6697	public function isMethodHidden ( $ methodName ) { if ( ! method_exists ( $ this , $ methodName ) ) { throw new Exception ( 500 , "The method '$methodName' does not exist in " . get_called_class ( ) ) ; } return isset ( $ this -> hiddenMethods [ $ methodName ] ) ; }
6595	protected function getMethodComment ( \ ReflectionMethod $ method ) { $ lines = preg_split ( "/((\r?\n)|(\r\n?))/" , $ method -> getDocComment ( ) ) ; $ count = count ( $ lines ) ; foreach ( $ lines as $ i => $ line ) { $ line = preg_replace ( '/^\s*(\/\*\*|\*\/?)\s*/' , '' , $ line ) ; $ line = trim ( $ line ) ; $ lines [ $ i ] = $ line ; if ( ! $ line && ( $ i == 0 || $ i == $ count - 1 ) ) { unset ( $ lines [ $ i ] ) ; } } return array_values ( $ lines ) ; }
622	public function with ( ) { $ with = func_get_args ( ) ; if ( isset ( $ with [ 0 ] ) && is_array ( $ with [ 0 ] ) ) { $ with = $ with [ 0 ] ; } if ( empty ( $ this -> with ) ) { $ this -> with = $ with ; } elseif ( ! empty ( $ with ) ) { foreach ( $ with as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> with [ ] = $ value ; } else { $ this -> with [ $ name ] = $ value ; } } } return $ this ; }
735	protected function getDirectPermissionsByUser ( $ userId ) { $ permissions = [ ] ; foreach ( $ this -> getAssignments ( $ userId ) as $ name => $ assignment ) { $ permission = $ this -> items [ $ assignment -> roleName ] ; if ( $ permission -> type === Item :: TYPE_PERMISSION ) { $ permissions [ $ name ] = $ permission ; } } return $ permissions ; }
10154	private function readPageSetup ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ paperSize = self :: getUInt2d ( $ recordData , 0 ) ; $ scale = self :: getUInt2d ( $ recordData , 2 ) ; $ fitToWidth = self :: getUInt2d ( $ recordData , 6 ) ; $ fitToHeight = self :: getUInt2d ( $ recordData , 8 ) ; $ isPortrait = ( 0x0002 & self :: getUInt2d ( $ recordData , 10 ) ) >> 1 ; $ isNotInit = ( 0x0004 & self :: getUInt2d ( $ recordData , 10 ) ) >> 2 ; if ( ! $ isNotInit ) { $ this -> phpSheet -> getPageSetup ( ) -> setPaperSize ( $ paperSize ) ; switch ( $ isPortrait ) { case 0 : $ this -> phpSheet -> getPageSetup ( ) -> setOrientation ( PageSetup :: ORIENTATION_LANDSCAPE ) ; break ; case 1 : $ this -> phpSheet -> getPageSetup ( ) -> setOrientation ( PageSetup :: ORIENTATION_PORTRAIT ) ; break ; } $ this -> phpSheet -> getPageSetup ( ) -> setScale ( $ scale , false ) ; $ this -> phpSheet -> getPageSetup ( ) -> setFitToPage ( ( bool ) $ this -> isFitToPages ) ; $ this -> phpSheet -> getPageSetup ( ) -> setFitToWidth ( $ fitToWidth , false ) ; $ this -> phpSheet -> getPageSetup ( ) -> setFitToHeight ( $ fitToHeight , false ) ; } $ marginHeader = self :: extractNumber ( substr ( $ recordData , 16 , 8 ) ) ; $ this -> phpSheet -> getPageMargins ( ) -> setHeader ( $ marginHeader ) ; $ marginFooter = self :: extractNumber ( substr ( $ recordData , 24 , 8 ) ) ; $ this -> phpSheet -> getPageMargins ( ) -> setFooter ( $ marginFooter ) ; } }
7552	function getChildrenByCallback ( $ callback , $ recursive = true , $ check_self = false ) { $ count = $ this -> childCount ( ) ; if ( $ check_self && $ callback ( $ this ) ) { $ res = array ( $ this ) ; } else { $ res = array ( ) ; } if ( $ count > 0 ) { if ( is_int ( $ recursive ) ) { $ recursive = ( ( $ recursive > 1 ) ? $ recursive - 1 : false ) ; } for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { if ( $ callback ( $ this -> children [ $ i ] ) ) { $ res [ ] = $ this -> children [ $ i ] ; } if ( $ recursive ) { $ res = array_merge ( $ res , $ this -> children [ $ i ] -> getChildrenByCallback ( $ callback , $ recursive ) ) ; } } } return $ res ; }
6051	public function listFolders ( $ root = 0 , $ depth = 0 , $ includeProperties = true , $ includeObjectCounts = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'root' => $ root , 'depth' => $ depth , 'includeProperties' => $ includeProperties , 'includeObjectCounts' => $ includeObjectCounts ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5607	public function paintGroupEnd ( $ group ) { $ this -> group = '' ; $ cc = '' ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { $ arrfiles = xdebug_get_code_coverage ( ) ; xdebug_stop_code_coverage ( ) ; $ thisdir = dirname ( __FILE__ ) ; $ thisdirlen = strlen ( $ thisdir ) ; foreach ( $ arrfiles as $ index => $ file ) { if ( substr ( $ index , 0 , $ thisdirlen ) === $ thisdir ) { continue ; } $ lcnt = 0 ; $ ccnt = 0 ; foreach ( $ file as $ line ) { if ( $ line == - 2 ) { continue ; } $ lcnt ++ ; if ( $ line == 1 ) { $ ccnt ++ ; } } if ( $ lcnt > 0 ) { $ cc .= round ( ( $ ccnt / $ lcnt ) * 100 , 2 ) . '%' ; } else { $ cc .= '0.00%' ; } $ cc .= "\t" . $ index . "\n" ; } } } $ this -> listener -> write ( '{status:"coverage",message:"' . self :: escapeVal ( $ cc ) . '"}' ) ; }
12457	protected function onSuccessLoad ( ) { if ( $ this -> Web2All -> DebugLevel > Web2All_Manager_Main :: DEBUGLEVEL_MEDIUM ) { $ this -> Web2All -> debugLog ( 'Web2All_Table_Object::loadFromTable(): loaded: ' . $ this -> asDebugString ( ) ) ; } }
4681	public static function start ( string $ key = 'default' ) : void { if ( isset ( self :: $ timers [ $ key ] ) ) { self :: $ timers [ $ key ] -> start ( ) ; } else { self :: $ timers [ $ key ] = new Stopwatch ( ) ; } }
6938	private function find ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( ! isset ( $ list [ $ oid ] ) ) { return false ; } if ( null === $ unit -> getId ( ) ) { return array_search ( $ unit , $ list [ $ oid ] , true ) ; } foreach ( $ list [ $ oid ] as $ index => $ u ) { if ( $ u -> getId ( ) == $ unit -> getId ( ) ) { return $ index ; } } return false ; }
6716	protected function getRequestChainFromUri ( $ requestedUri ) { $ requestedUri = preg_replace ( '/[\?\.].*$/' , '' , $ requestedUri ) ; $ requestChain = explode ( '/' , $ requestedUri ) ; if ( ! $ requestChain [ 0 ] ) { unset ( $ requestChain [ 0 ] ) ; } return array_values ( $ requestChain ) ; }
8116	public function canBeReviewedBy ( Member $ member = null ) { if ( ! $ this -> owner -> obj ( "NextReviewDate" ) -> exists ( ) ) { return false ; } if ( $ this -> owner -> obj ( "NextReviewDate" ) -> InFuture ( ) ) { return false ; } $ options = $ this -> getOptions ( ) ; if ( ! $ options ) { return false ; } if ( ! $ options || ( ! $ options -> hasExtension ( __CLASS__ ) && ! $ options -> hasExtension ( ContentReviewDefaultSettings :: class ) ) ) { return false ; } if ( $ options -> OwnerGroups ( ) -> count ( ) == 0 && $ options -> OwnerUsers ( ) -> count ( ) == 0 ) { return false ; } if ( ! $ member ) { return true ; } if ( $ member -> inGroups ( $ options -> OwnerGroups ( ) ) ) { return true ; } if ( $ options -> OwnerUsers ( ) -> find ( "ID" , $ member -> ID ) ) { return true ; } return false ; }
8106	protected function getEmailBody ( $ config , $ variables ) { $ template = SSViewer :: fromString ( $ config -> ReviewBody ) ; $ value = $ template -> process ( ArrayData :: create ( $ variables ) ) ; return DBField :: create_field ( 'HTMLText' , ( string ) $ value ) ; }
475	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "delete from $table" ) ; $ this -> db -> createCommand ( ) -> delete ( $ table , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
7169	public function resolveSaleTaxRule ( SaleInterface $ sale ) : ? TaxRuleInterface { return $ this -> resolveTaxRule ( $ this -> resolveTargetCountry ( $ sale ) , $ sale -> isBusiness ( ) ) ; }
10249	public function getDate ( $ params = [ ] , $ format = 'Y-m-d' ) { foreach ( $ params as $ k => $ v ) { $ $ k = $ v ; } if ( ! isset ( $ min_year ) ) { $ min_year = date ( 'Y' ) - 2 ; } if ( ! isset ( $ max_year ) ) { $ max_year = date ( 'Y' ) ; } if ( ! isset ( $ min_month ) ) { $ min_month = 1 ; } if ( ! isset ( $ max_month ) ) { $ max_month = 12 ; } $ rand_year = rand ( $ min_year , $ max_year ) ; $ rand_month = rand ( $ min_month , $ max_month ) ; $ date = DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , '01' ] ) ) ; $ days_in_month = $ date -> format ( 't' ) ; $ rand_day = rand ( 1 , $ days_in_month ) ; return DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , $ rand_day ] ) ) -> format ( $ format ) ; }
10525	public function setFieldValue ( $ field , $ value ) { $ type = $ this -> getFieldFormType ( $ field ) ; switch ( $ type ) { case 'select' : return $ this -> selectOptionForm ( $ field , $ value ) ; case 'checkbox' : case 'checkboxGroup' : return $ this -> checkOptionForm ( $ field ) ; default : return $ this -> fillFieldForm ( $ field , $ value ) ; } }
805	private function hasVoidReturn ( Tokens $ tokens , $ startIndex , $ endIndex ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; for ( $ i = $ startIndex ; $ i < $ endIndex ; ++ $ i ) { if ( ( $ tokens [ $ i ] -> isGivenKind ( T_CLASS ) && $ tokensAnalyzer -> isAnonymousClass ( $ i ) ) || ( $ tokens [ $ i ] -> isGivenKind ( T_FUNCTION ) && $ tokensAnalyzer -> isLambda ( $ i ) ) ) { $ i = $ tokens -> getNextTokenOfKind ( $ i , [ '{' ] ) ; $ i = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ i ) ; continue ; } if ( $ tokens [ $ i ] -> isGivenKind ( [ T_YIELD , T_YIELD_FROM ] ) ) { return false ; } if ( ! $ tokens [ $ i ] -> isGivenKind ( T_RETURN ) ) { continue ; } $ i = $ tokens -> getNextMeaningfulToken ( $ i ) ; if ( ! $ tokens [ $ i ] -> equals ( ';' ) ) { return false ; } } return true ; }
7487	public function lastIndexOf ( $ string , $ offset = null ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ offset = $ offset !== null ? ( int ) $ offset : null ; if ( $ offset !== null && ( $ offset < 0 || $ offset >= $ this -> length ( ) ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_strrpos ( $ this -> string , $ string , $ offset , $ this -> encoding ) ; }
5336	protected function encodeParameters ( $ parameters , $ keyPrefix = null ) { if ( ! is_array ( $ parameters ) && ! is_object ( $ parameters ) ) { return rawurlencode ( $ parameters ) ; } $ encodedData = [ ] ; foreach ( $ parameters as $ key => $ value ) { $ encodedKey = is_null ( $ keyPrefix ) ? rawurlencode ( $ key ) : $ keyPrefix . '[' . rawurlencode ( $ key ) . ']' ; if ( is_array ( $ value ) || is_object ( $ value ) ) { $ encodedData [ ] = $ this -> encodeParameters ( $ value , $ encodedKey ) ; } else { $ encodedData [ ] = $ encodedKey . '=' . rawurlencode ( $ value ) ; } } return implode ( '&' , $ encodedData ) ; }
6031	public function addself ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate self. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "self"!' , E_USER_WARNING ) ; } } $ this -> childMedias [ ] = $ item ; return $ this ; }
9394	public function execute ( ) { if ( $ this -> escape !== false ) { $ this -> options = $ this -> escape ( $ this -> options ) ; } if ( $ this -> builder !== null ) { $ command = $ this -> builder -> build ( $ this -> options ) ; exec ( $ command ) ; } }
8414	public function getMasterLink ( ) { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return $ this -> servers [ 'all' ] [ 'link' ] ; } return $ this -> servers [ 'write' ] [ 'link' ] ; }
12455	public function hasToolbar ( ) { $ fileSkeleton = '/Resources/views/Editor/Toolbar/_toolbar_%s_buttons.html.twig' ; return file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'left' ) ) || file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'right' ) ) ; }
492	public function findFor ( $ name , $ model ) { if ( method_exists ( $ model , 'get' . $ name ) ) { $ method = new \ ReflectionMethod ( $ model , 'get' . $ name ) ; $ realName = lcfirst ( substr ( $ method -> getName ( ) , 3 ) ) ; if ( $ realName !== $ name ) { throw new InvalidArgumentException ( 'Relation names are case sensitive. ' . get_class ( $ model ) . " has a relation named \"$realName\" instead of \"$name\"." ) ; } } return $ this -> multiple ? $ this -> all ( ) : $ this -> one ( ) ; }
2360	public static function findPublishedById ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ; } return static :: findOneBy ( $ arrColumns , $ intId , $ arrOptions ) ; }
12194	public function instantiate ( $ className , array $ data = [ ] ) { $ refl = new \ ReflectionClass ( $ className ) ; $ instanceArgs = [ ] ; if ( $ data ) { $ instanceArgs = $ this -> extractArguments ( $ refl -> getConstructor ( ) -> getParameters ( ) , $ data ) ; } return $ refl -> newInstanceArgs ( $ instanceArgs ) ; }
11724	protected function prepare ( $ path , Zend_Http_Client $ client ) { $ client -> setUri ( $ this -> uri . '/' . $ path ) ; $ client -> resetParameters ( ) ; }
10683	public function preferred ( array $ types ) : ? string { if ( empty ( $ types ) ) { return null ; } foreach ( $ this -> types as $ type ) { if ( in_array ( $ type , $ types , true ) ) { return $ type ; } elseif ( '*/*' == $ type ) { return current ( $ types ) ; } elseif ( strlen ( $ type ) > 2 && substr ( $ type , - 2 , 2 ) == '/*' ) { $ prefix = substr ( $ type , 0 , strpos ( $ type , '/' ) + 1 ) ; $ plen = strlen ( $ prefix ) ; foreach ( $ types as $ t ) { if ( strncmp ( $ prefix , $ t , $ plen ) === 0 ) { return $ t ; } } } } return null ; }
11478	public function addTemplateSlots ( $ templateName , $ username ) { if ( ! array_key_exists ( $ templateName , $ this -> templateBlocks ) ) { return null ; } $ blocks = $ this -> templateBlocks [ $ templateName ] ; $ this -> addSlots ( $ blocks , $ username ) ; }
8607	private function _convertListSubscriptions ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListSubscriptions' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } return $ parameters ; }
11734	public function hide ( $ pageName , $ languageName ) { $ this -> contributorDefined ( ) ; $ baseDir = $ this -> pagesDir . '/' . $ pageName . '/' . $ languageName ; $ sourceFile = $ baseDir . '/seo.json' ; Dispatcher :: dispatch ( PageEvents :: PAGE_HIDING , new PageHidingEvent ( ) ) ; unlink ( $ sourceFile ) ; Dispatcher :: dispatch ( PageEvents :: PAGE_HID , new PageHidEvent ( ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" for language "%s" was hidden from production' , $ pageName , $ languageName ) ) ; }
10640	protected function createUniquePath ( UploadedFile $ file ) { $ dir = 'mmmb/' . mb_substr ( mb_strtolower ( ( string ) $ file -> getClientOriginalName ( ) ) , 0 , 2 ) ; $ filename = str_replace ( array ( ' ' , $ file -> getClientOriginalExtension ( ) ) , '-' , $ file -> getClientOriginalName ( ) ) ; $ name = mb_strtolower ( $ filename . uniqid ( ) . '.' . $ file -> getClientOriginalExtension ( ) ) ; return array ( 'dir' => $ dir , 'filename' => $ name , 'path' => $ dir . '/' . $ name , ) ; }
8802	public function get ( $ key = null ) { return ( is_null ( $ key ) ? $ _SESSION : ( $ this -> has ( $ key ) ? $ _SESSION [ $ key ] : null ) ) ; }
8018	public function getUrl ( $ name , $ expires = NULL ) { return $ this -> getClient ( ) -> getObjectUrl ( $ this -> bucket , $ name , $ expires ) ; }
7536	function detach ( $ move_children_up = false ) { if ( ( $ p = $ this -> parent ) !== null ) { $ index = $ this -> index ( ) ; $ this -> parent = null ; if ( $ move_children_up ) { $ this -> moveChildren ( $ p , $ index ) ; } $ p -> deleteChild ( $ this , true ) ; } }
4186	public function search ( ) { $ url = self :: PACKAGIST_URL . 'search.json?q=' . $ this -> getPackageName ( ) ; $ response = $ this -> client -> get ( $ url ) -> getBody ( ) -> getContents ( ) ; $ this -> rawPackages = collect ( json_decode ( $ response , true ) ) ; return collect ( $ this -> rawPackages -> get ( 'results' ) ) ; }
1238	private static function ensurePropertyType ( $ class , $ name , $ value ) { $ isValid = false ; $ info = self :: propertyInfo ( $ class , $ name ) ; $ actualType = self :: getActualType ( $ value ) ; $ valid = explode ( '|' , $ info [ 'type' ] ) ; foreach ( $ valid as $ check ) { if ( $ check !== 'any' && \ DTS \ eBaySDK \ checkPropertyType ( $ check ) ) { if ( $ check === $ actualType || 'array' === $ actualType ) { return ; } $ isValid = false ; } else { $ isValid = true ; } } if ( ! $ isValid ) { $ expectedType = $ info [ 'type' ] ; throw new Exceptions \ InvalidPropertyTypeException ( $ name , $ expectedType , $ actualType ) ; } }
10291	protected function aquireLock ( ) { $ lockfile = $ this -> lockDir . '/lock' ; $ fp = @ fopen ( $ lockfile , 'x' ) ; if ( $ fp === false ) { $ this -> logger -> log ( sprintf ( 'The lockfile %s does already exist.' , $ lockfile ) , Logger :: WARNING ) ; return false ; } fwrite ( $ fp , time ( ) ) ; fclose ( $ fp ) ; $ this -> logger -> log ( 'Aquired lock.' , Logger :: INFO ) ; return true ; }
408	public function get ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getQueryParams ( ) ; } return $ this -> getQueryParam ( $ name , $ defaultValue ) ; }
292	public function hasAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) || in_array ( $ name , $ this -> attributes ( ) , true ) ; }
7566	protected function parse_single ( $ recursive = true ) { if ( ( $ c = $ this -> parse_conditions ( ) ) === false ) { return false ; } $ this -> parse_callback ( $ c , $ recursive , $ this -> search_root ) ; return true ; }
3798	private function checkModelWithVariants ( $ containedModel ) { $ isVarbase = ( bool ) $ containedModel -> getProperty ( 'varbase' ) ; $ vargroup = $ containedModel -> getProperty ( 'vargroup' ) ; $ isCurrentVarbase = ( bool ) $ this -> currentModel -> getProperty ( 'varbase' ) ; $ currentVargroup = $ this -> currentModel -> getProperty ( 'vargroup' ) ; if ( $ isVarbase && ! $ this -> circularReference && $ isCurrentVarbase ) { $ this -> disablePA = false ; } elseif ( ! $ isVarbase && ! $ isCurrentVarbase && $ vargroup == $ currentVargroup ) { $ this -> disablePA = false ; } $ this -> disablePI = ! $ isCurrentVarbase || $ isVarbase ; }
4180	protected function notifyUser ( ) { $ this -> console -> line ( '' ) ; $ this -> console -> line ( "{$this->isDone($this->getProviders()->isRegistered())} " . "{$this->getProviders()->count()} service provider registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getFacades()->isRegistered())} " . "{$this->getFacades()->count()} facade registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getMigration()->isRegistered())} " . "{$this->getMigration()->count()} migration file ran." ) ; $ this -> console -> line ( "{$this->isDone($this->getResources()->isRegistered())} " . '- ' . $ this -> console -> tokenizePackageInfo ( ) [ 'name' ] . ' file publish.' ) ; return true ; }
5099	public function into ( $ table , array $ fields = null ) { $ this -> setPart ( CmdInsert :: PART_INTO , $ table ) ; if ( ! is_null ( $ fields ) ) { $ this -> placeholder = false ; $ this -> fields = $ fields ; } return $ this ; }
12315	public function sortAction ( Request $ request ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; if ( $ request -> isXmlHttpRequest ( ) ) { $ this -> get ( 'admin_manager' ) -> sort ( 'BlogBundle:Category' , $ request -> get ( 'values' ) ) ; return new Response ( 0 , 200 ) ; } $ categories = $ em -> getRepository ( 'BlogBundle:Category' ) -> findBy ( array ( 'parentCategory' => NULL ) , array ( 'order' => 'asc' ) ) ; return array ( 'categories' => $ categories ) ; }
8351	protected function toSqlLevel ( array $ tree ) : string { if ( count ( $ tree ) == 0 ) { return '' ; } $ sql = '(' ; reset ( $ tree ) ; if ( is_numeric ( key ( $ tree ) ) === true ) { foreach ( $ tree as $ elem ) { $ sql .= $ elem . ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } elseif ( key ( $ tree ) === 'OR' ) { foreach ( $ tree as $ value ) { if ( is_array ( $ value ) === true ) { $ sql .= $ this -> toSqlLevel ( $ value ) ; } else { $ sql .= $ value ; } $ sql .= ' OR ' ; } $ sql = substr ( $ sql , 0 , - 4 ) ; } elseif ( key ( $ tree ) === 'AND' ) { foreach ( $ tree as $ value ) { if ( is_array ( $ value ) === true ) { $ sql .= $ this -> toSqlLevel ( $ value ) ; } else { $ sql .= $ value ; } $ sql .= ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } else { foreach ( $ tree as $ key => $ value ) { $ sql .= $ key . ' = ' . $ value . ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } $ sql .= ')' ; return $ sql ; }
11823	public function replace ( $ middleware , $ with ) { $ this -> pipeline = $ this -> pipeline -> replace ( $ middleware , $ with ) ; return $ this ; }
3267	protected function openFile ( int $ mode ) : SplFileObject { $ path = $ this -> getPath ( ) ; if ( ! is_file ( $ path ) && ! @ touch ( $ path ) ) { throw new Exception ( 'Could not create file: ' . $ path ) ; } if ( ! is_readable ( $ path ) || ! is_writable ( $ path ) ) { throw new Exception ( 'File does not have permission for read and write: ' . $ path ) ; } if ( $ this -> getConfig ( ) -> useGzip ( ) ) { $ path = 'compress.zlib://' . $ path ; } $ res = $ this -> fileAccessMode [ $ mode ] ; $ file = new SplFileObject ( $ path , $ res [ 'mode' ] ) ; if ( $ mode === self :: FILE_READ ) { $ file -> setFlags ( SplFileObject :: DROP_NEW_LINE | SplFileObject :: SKIP_EMPTY | SplFileObject :: READ_AHEAD ) ; } if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( $ res [ 'operation' ] ) ) { $ file = null ; throw new Exception ( 'Could not lock file: ' . $ path ) ; } return $ file ; }
10870	public function verifyHash ( string $ password , string $ hash ) : bool { return Passwords :: verify ( $ password , $ hash ) ; }
514	public function actionDown ( $ limit = 1 ) { if ( $ limit === 'all' ) { $ limit = null ; } else { $ limit = ( int ) $ limit ; if ( $ limit < 1 ) { throw new Exception ( 'The step argument must be greater than 0.' ) ; } } $ migrations = $ this -> getMigrationHistory ( $ limit ) ; if ( empty ( $ migrations ) ) { $ this -> stdout ( "No migration has been done before.\n" , Console :: FG_YELLOW ) ; return ExitCode :: OK ; } $ migrations = array_keys ( $ migrations ) ; $ n = count ( $ migrations ) ; $ this -> stdout ( "Total $n " . ( $ n === 1 ? 'migration' : 'migrations' ) . " to be reverted:\n" , Console :: FG_YELLOW ) ; foreach ( $ migrations as $ migration ) { $ this -> stdout ( "\t$migration\n" ) ; } $ this -> stdout ( "\n" ) ; $ reverted = 0 ; if ( $ this -> confirm ( 'Revert the above ' . ( $ n === 1 ? 'migration' : 'migrations' ) . '?' ) ) { foreach ( $ migrations as $ migration ) { if ( ! $ this -> migrateDown ( $ migration ) ) { $ this -> stdout ( "\n$reverted from $n " . ( $ reverted === 1 ? 'migration was' : 'migrations were' ) . " reverted.\n" , Console :: FG_RED ) ; $ this -> stdout ( "\nMigration failed. The rest of the migrations are canceled.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ reverted ++ ; } $ this -> stdout ( "\n$n " . ( $ n === 1 ? 'migration was' : 'migrations were' ) . " reverted.\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "\nMigrated down successfully.\n" , Console :: FG_GREEN ) ; } }
3675	private function collectAttributeFactories ( $ container ) { $ attributeFactory = $ container -> getDefinition ( 'metamodels.attribute_factory' ) ; foreach ( array_keys ( $ container -> findTaggedServiceIds ( self :: TAG_ATTRIBUTE_FACTORY ) ) as $ factory ) { $ attributeFactory -> addMethodCall ( 'addTypeFactory' , [ new Reference ( $ factory ) ] ) ; } }
1964	public static function decodeUrl ( $ strUrl ) { if ( $ strUrl == '' ) { return '' ; } if ( $ strUrl == '#' || strncmp ( $ strUrl , '{{' , 2 ) === 0 ) { return $ strUrl ; } if ( strncmp ( $ strUrl , 'mailto:' , 7 ) === 0 ) { return static :: decodeEmail ( $ strUrl ) ; } $ arrUrl = parse_url ( $ strUrl ) ; if ( ! isset ( $ arrUrl [ 'scheme' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Expected a FQDN, got "%s"' , $ strUrl ) ) ; } if ( isset ( $ arrUrl [ 'scheme' ] ) ) { $ arrUrl [ 'scheme' ] .= ( ( substr ( $ strUrl , \ strlen ( $ arrUrl [ 'scheme' ] ) , 3 ) == '://' ) ? '://' : ':' ) ; } if ( isset ( $ arrUrl [ 'user' ] ) ) { $ arrUrl [ 'user' ] .= isset ( $ arrUrl [ 'pass' ] ) ? ':' : '@' ; } if ( isset ( $ arrUrl [ 'pass' ] ) ) { $ arrUrl [ 'pass' ] .= '@' ; } if ( isset ( $ arrUrl [ 'host' ] ) ) { $ arrUrl [ 'host' ] = static :: decode ( $ arrUrl [ 'host' ] ) ; } if ( isset ( $ arrUrl [ 'port' ] ) ) { $ arrUrl [ 'port' ] = ':' . $ arrUrl [ 'port' ] ; } if ( isset ( $ arrUrl [ 'query' ] ) ) { $ arrUrl [ 'query' ] = '?' . $ arrUrl [ 'query' ] ; } if ( isset ( $ arrUrl [ 'fragment' ] ) ) { $ arrUrl [ 'fragment' ] = '#' . $ arrUrl [ 'fragment' ] ; } $ strReturn = '' ; foreach ( array ( 'scheme' , 'user' , 'pass' , 'host' , 'port' , 'path' , 'query' , 'fragment' ) as $ key ) { if ( isset ( $ arrUrl [ $ key ] ) ) { $ strReturn .= $ arrUrl [ $ key ] ; } } return $ strReturn ; }
9933	public function setRuleType ( $ pRuleType ) { if ( ! in_array ( $ pRuleType , self :: $ ruleTypes ) ) { throw new PhpSpreadsheetException ( 'Invalid rule type for column AutoFilter Rule.' ) ; } $ this -> ruleType = $ pRuleType ; return $ this ; }
10776	public function fromArray ( array $ array ) { $ root = new Node ( null ) ; $ map = array ( ) ; $ map [ 0 ] = $ root ; foreach ( $ array as $ element ) { if ( 3 !== count ( $ element ) ) { throw new Exception ( 'Each array must have 3 elements.' ) ; } $ map [ $ element [ 0 ] ] = new Node ( $ element [ 2 ] ) ; } foreach ( $ array as $ element ) { if ( empty ( $ element [ 1 ] ) ) { $ element [ 1 ] = 0 ; } $ found = false ; $ i = 0 ; $ keys = array_keys ( $ map ) ; $ cnt = count ( $ keys ) ; while ( ! $ found && $ i < $ cnt ) { if ( $ keys [ $ i ] === $ element [ 1 ] ) { $ map [ $ keys [ $ i ] ] -> addChild ( $ map [ $ element [ 0 ] ] ) ; $ found = true ; } else { $ i ++ ; } } if ( ! $ found ) { throw new Exception ( 'Data structure does not seem to be consistent. ' . 'Key "' . $ element [ 1 ] . '" could not be found.' ) ; } } return $ root ; }
12323	protected function askQuestions ( InputInterface $ input , OutputInterface $ output ) { foreach ( $ this -> questions as $ question ) { if ( ! $ question -> ask ( $ input , $ output ) ) { return static :: RETURN_ERROR ; } } return static :: RETURN_SUCCESS ; }
8036	public static function convert ( $ input , $ outputFormat = Code :: FORMAT_ALNUM , $ minLength = null ) { if ( is_int ( $ minLength ) ) { $ input += self :: getMinForlength ( $ outputFormat , $ minLength ) ; } static :: throwUnlessAcceptable ( $ outputFormat , $ input ) ; return self :: convertBase ( $ input , self :: FORMAT_NUMBER , $ outputFormat ) ; }
10672	private static function addSegmentsToPath ( $ path , $ segments ) { $ segments = Arr :: toArray ( $ segments ) ; if ( count ( $ segments ) > 0 ) { $ path .= '/' . implode ( '/' , $ segments ) ; } return $ path ; }
3073	public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = ( $ this -> getRequestParameter ( 'start' ) !== false ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( ! $ this -> getRunnerService ( ) -> isTerminated ( $ serviceContext ) ) { $ this -> endItemTimer ( $ this -> getTime ( ) ) ; $ this -> saveItemState ( ) ; } $ this -> initServiceContext ( ) ; $ this -> saveItemResponses ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> timeout ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } if ( $ start == true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
11426	public function blacklist ( $ beginOpenid = null ) { $ params = [ 'begin_openid' => $ beginOpenid ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_BLACK_LIST , $ params ] ) ; }
12348	protected function getConnectionInitializer ( OptionsInterface $ options , $ callable ) { if ( ! is_callable ( $ callable ) ) { $ class = get_called_class ( ) ; throw new \ InvalidArgumentException ( "$class expects a valid callable" ) ; } $ option = $ this ; return function ( $ parameters = null ) use ( $ callable , $ options , $ option ) { $ connection = call_user_func ( $ callable , $ options , $ parameters ) ; if ( ! $ connection instanceof AggregateConnectionInterface ) { $ class = get_class ( $ option ) ; throw new \ InvalidArgumentException ( "$class expects a valid connection type returned by callable initializer" ) ; } return $ connection ; } ; }
4604	protected function parse ( $ path ) : array { $ fixtures = array_key_exists ( 'FIXTURES' , $ _ENV ) ? $ _ENV [ 'FIXTURES' ] : 'dev' ; $ files = glob ( str_replace ( '{fixtures}' , $ fixtures , $ path ) ) ; if ( ! $ files ) { throw new LogicException ( 'Fixtures path "' . $ path . '" yields no files.' ) ; } $ objects = [ ] ; foreach ( $ files as $ file ) { foreach ( Objects :: parseFile ( $ file ) as $ object ) { $ objects [ ] = $ object ; } } return $ objects ; }
1829	public function delete ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ intAffected = Database :: getInstance ( ) -> prepare ( "DELETE FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) -> affectedRows ; if ( $ intAffected ) { Registry :: getInstance ( ) -> unregister ( $ this ) ; $ this -> arrData [ static :: $ strPk ] = null ; } return $ intAffected ; }
6618	protected function parseEndpointName ( $ method , $ endpoint ) { $ endpoint = str_replace ( ' ' , '' , ucwords ( str_replace ( [ '-' , '+' , '%20' ] , ' ' , $ endpoint ) ) ) ; $ method = strtolower ( $ method ) ; return $ method . $ endpoint . 'Endpoint' ; }
1356	protected function getSortColumn ( $ field , Model $ model ) { if ( isset ( $ this -> sortColumns [ $ field ] ) ) { return $ this -> sortColumns [ $ field ] ; } return $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; }
10169	public function write ( Spreadsheet $ spreadsheet = null ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-settings' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:config' , 'urn:oasis:names:tc:opendocument:xmlns:config:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:settings' ) ; $ objWriter -> startElement ( 'config:config-item-set' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'ooo:view-settings' ) ; $ objWriter -> startElement ( 'config:config-item-map-indexed' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'Views' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'config:config-item-set' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'ooo:configuration-settings' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
10496	public function exp ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( pow ( $ this -> value , $ value ) ) ; }
6600	public function unlinkFiles ( $ fileName ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ fileName ) { if ( @ file_exists ( $ folder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ fileName ) ; } if ( @ file_exists ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ; } if ( is_array ( $ this -> sizes ) ) { $ i = 0 ; foreach ( $ this -> sizes as $ size ) { if ( @ file_exists ( $ folder . '/' . $ i . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ i . '/' . $ fileName ) ; } $ i ++ ; } } } }
12981	public function preDispatch ( ) { $ error = null ; $ request = $ this -> getRequest ( ) ; if ( ! $ request -> isGet ( ) && ! $ request -> isHead ( ) ) { $ this -> _input = json_decode ( $ request -> getRawBody ( ) ) ; if ( JSON_ERROR_NONE === json_last_error ( ) ) { return ; } $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setHeader ( 'Content-Type' , 'text/plain; charset=utf-8' , true ) -> setBody ( json_last_error_msg ( ) ) -> sendResponse ( ) ; exit ( 400 ) ; } }
6333	public function validateChecksum ( $ string ) { $ xml = new \ SimpleXMLElement ( $ string ) ; $ checksum = ( string ) $ xml -> Authentication -> Checksum ; $ original = str_replace ( $ checksum , $ this -> getMerchantPassword ( ) , $ string ) ; return md5 ( $ original ) == $ checksum ; }
5001	public function removeTab ( $ tabName , FormMapper $ formMapper ) { $ tabs = $ this -> getFormTabs ( ) ; if ( array_key_exists ( $ tabName , $ tabs ) ) { $ groups = $ this -> getFormGroups ( ) ; if ( ! is_array ( $ groups ) ) { return ; } foreach ( $ tabs [ $ tabName ] [ 'groups' ] as $ group ) { if ( isset ( $ groups [ $ group ] ) ) { foreach ( $ groups [ $ group ] [ 'fields' ] as $ field ) { $ formMapper -> remove ( $ field ) ; } } unset ( $ groups [ $ group ] ) ; } $ this -> setFormGroups ( $ groups ) ; $ this -> removeEmptyGroups ( ) ; } }
2518	public function pnrRetrieveAndDisplay ( RequestOptions \ PnrRetrieveAndDisplayOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_RetrieveAndDisplay' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
4538	public function setTenantId ( ? string $ tenantId ) { $ this -> tenantId = $ tenantId ; $ this -> _tenantId = null !== $ tenantId ; return $ this ; }
10669	public static function fromArray ( $ input , array $ options = [ ] ) { if ( ! \ is_array ( $ input ) || \ count ( $ input ) !== 1 ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid input.' ) ) ; } $ key = key ( $ input ) ; if ( \ is_int ( $ key ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'The key of input must be alphanumeric.' ) ) ; } if ( ! \ is_array ( $ options ) ) { $ options = [ 'format' => ( string ) $ options ] ; } $ defaults = [ 'format' => 'tags' , 'version' => '1.0' , 'encoding' => 'utf-8' , 'return' => 'simplexml' , ] ; $ options = array_merge ( $ defaults , $ options ) ; $ dom = new \ DOMDocument ( $ options [ 'version' ] , $ options [ 'encoding' ] ) ; self :: _fromArray ( $ dom , $ dom , $ input , $ options [ 'format' ] ) ; $ options [ 'return' ] = strtolower ( $ options [ 'return' ] ) ; if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ dom -> saveXML ( ) ) ; } return $ dom ; }
7402	public function Get ( $ name = null , $ value = null , ... $ param ) { if ( ! isset ( $ name ) ) return self :: $ config ; return isset ( $ value ) ? self :: $ config [ $ name ] [ $ value ] : ( isset ( self :: $ config [ $ name ] ) ? self :: $ config [ $ name ] : null ) ; }
1784	protected function fetchItems ( $ newsArchives , $ blnFeatured , $ limit , $ offset ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListFetchItems' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListFetchItems' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListFetchItems' ] as $ callback ) { if ( ( $ objCollection = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ newsArchives , $ blnFeatured , $ limit , $ offset , $ this ) ) === false ) { continue ; } if ( $ objCollection === null || $ objCollection instanceof Collection ) { return $ objCollection ; } } } $ t = NewsModel :: getTable ( ) ; $ arrOptions = array ( ) ; switch ( $ this -> news_order ) { case 'order_headline_asc' : $ arrOptions [ 'order' ] = "$t.headline" ; break ; case 'order_headline_desc' : $ arrOptions [ 'order' ] = "$t.headline DESC" ; break ; case 'order_random' : $ arrOptions [ 'order' ] = "RAND()" ; break ; case 'order_date_asc' : $ arrOptions [ 'order' ] = "$t.date" ; break ; default : $ arrOptions [ 'order' ] = "$t.date DESC" ; } return NewsModel :: findPublishedByPids ( $ newsArchives , $ blnFeatured , $ limit , $ offset , $ arrOptions ) ; }
9687	public function jsonSerialize ( ) { return array_map ( function ( $ value ) { if ( $ value instanceof JsonSerializable ) { return $ value -> jsonSerialize ( ) ; } elseif ( $ value instanceof JsonableInterface ) { return json_decode ( $ value -> toJson ( ) , true ) ; } elseif ( $ value instanceof ArrayableInterface ) { return $ value -> toArray ( ) ; } else { return $ value ; } } , $ this -> items ) ; }
5054	public function init ( ) { $ this -> setLabel ( 'general settings' ) ; $ this -> add ( array ( 'type' => 'Core\Form\Element\Select' , 'name' => 'language' , 'options' => array ( 'label' => 'choose your language' , 'value_options' => array ( 'en' => 'English' , 'fr' => 'French' , 'de' => 'German' , 'it' => 'Italian' , 'po' => 'Polish' , 'ru' => 'Russian' , 'tr' => 'Turkish' , 'es' => 'Spanish' , ) , 'description' => 'defines the languages of this frontend.' ) , ) ) ; $ timezones = array_merge ( \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: AFRICA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: AMERICA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: ASIA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: ATLANTIC ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: AUSTRALIA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: EUROPE ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: INDIAN ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: PACIFIC ) ) ; $ this -> add ( array ( 'type' => 'Core\Form\Element\Select' , 'name' => 'timezone' , 'options' => array ( 'label' => 'choose your timzone' , 'value_options' => $ timezones , 'description' => 'defines your local timezone.' ) , ) ) ; }
1604	public function onException ( ExceptionEvent $ event ) { $ exception = $ event -> exception ; $ craft = \ Craft :: $ app ; if ( ! ( $ exception instanceof HttpException ) || $ exception -> statusCode !== 404 ) return ; $ path = $ craft -> request -> getFullPath ( ) ; $ query = $ craft -> request -> getQueryStringWithoutPath ( ) ; if ( $ query ) $ path .= '?' . $ query ; if ( $ redirect = $ this -> findRedirectByPath ( $ path ) ) { $ event -> handled = true ; $ craft -> response -> redirect ( $ redirect [ 'to' ] , $ redirect [ 'type' ] ) -> send ( ) ; $ craft -> end ( ) ; } }
3435	public function substituteGroup ( $ old , $ new ) { $ groups = $ this -> getGroups ( ) ; if ( ( $ key = array_search ( $ old , $ groups ) ) !== false ) { unset ( $ groups [ $ key ] ) ; } if ( ! in_array ( $ new , $ groups ) ) { $ groups [ ] = $ new ; } $ this -> fields [ 'GROUP_ID' ] = $ groups ; }
2012	public static function addNamespace ( $ name ) { @ trigger_error ( 'Using ClassLoader::addNamespace() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ in_array ( $ name , self :: $ namespaces ) ) { return ; } array_unshift ( self :: $ namespaces , $ name ) ; }
4564	public function kernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof NoPermissionsException ) { return ; } $ response = new JsonResponse ( [ ] ) ; $ event -> setResponse ( $ response ) ; }
10113	private function writeSetup ( ) { $ record = 0x00A1 ; $ length = 0x0022 ; $ iPaperSize = $ this -> phpSheet -> getPageSetup ( ) -> getPaperSize ( ) ; $ iScale = $ this -> phpSheet -> getPageSetup ( ) -> getScale ( ) ? $ this -> phpSheet -> getPageSetup ( ) -> getScale ( ) : 100 ; $ iPageStart = 0x01 ; $ iFitWidth = ( int ) $ this -> phpSheet -> getPageSetup ( ) -> getFitToWidth ( ) ; $ iFitHeight = ( int ) $ this -> phpSheet -> getPageSetup ( ) -> getFitToHeight ( ) ; $ grbit = 0x00 ; $ iRes = 0x0258 ; $ iVRes = 0x0258 ; $ numHdr = $ this -> phpSheet -> getPageMargins ( ) -> getHeader ( ) ; $ numFtr = $ this -> phpSheet -> getPageMargins ( ) -> getFooter ( ) ; $ iCopies = 0x01 ; $ fLeftToRight = 0x0 ; $ fLandscape = ( $ this -> phpSheet -> getPageSetup ( ) -> getOrientation ( ) == PageSetup :: ORIENTATION_LANDSCAPE ) ? 0x0 : 0x1 ; $ fNoPls = 0x0 ; $ fNoColor = 0x0 ; $ fDraft = 0x0 ; $ fNotes = 0x0 ; $ fNoOrient = 0x0 ; $ fUsePage = 0x0 ; $ grbit = $ fLeftToRight ; $ grbit |= $ fLandscape << 1 ; $ grbit |= $ fNoPls << 2 ; $ grbit |= $ fNoColor << 3 ; $ grbit |= $ fDraft << 4 ; $ grbit |= $ fNotes << 5 ; $ grbit |= $ fNoOrient << 6 ; $ grbit |= $ fUsePage << 7 ; $ numHdr = pack ( 'd' , $ numHdr ) ; $ numFtr = pack ( 'd' , $ numFtr ) ; if ( self :: getByteOrder ( ) ) { $ numHdr = strrev ( $ numHdr ) ; $ numFtr = strrev ( $ numFtr ) ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data1 = pack ( 'vvvvvvvv' , $ iPaperSize , $ iScale , $ iPageStart , $ iFitWidth , $ iFitHeight , $ grbit , $ iRes , $ iVRes ) ; $ data2 = $ numHdr . $ numFtr ; $ data3 = pack ( 'v' , $ iCopies ) ; $ this -> append ( $ header . $ data1 . $ data2 . $ data3 ) ; }
2751	public function validateCustomSnippet ( $ name , $ type , $ priority ) { $ snippetName = str_replace ( ' ' , '' , $ name ) ; $ types = [ 'init' , 'recv' , 'hit' , 'miss' , 'pass' , 'fetch' , 'error' , 'deliver' , 'log' , 'hash' , 'none' ] ; $ inArray = in_array ( $ type , $ types ) ; $ isNumeric = is_numeric ( $ priority ) ; $ isAlphanumeric = preg_match ( '/^[\w]+$/' , $ snippetName ) ; $ error = null ; if ( ! $ inArray ) { $ error = 'Type value is not recognised.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } if ( ! $ isNumeric ) { $ error = 'Please make sure that the priority value is a number.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } if ( ! $ isAlphanumeric ) { $ error = 'Please make sure that the name value contains only alphanumeric characters.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } return [ 'snippet_name' => $ snippetName , 'error' => $ error ] ; }
1600	public function serialize ( $ record , $ meta = null , array $ links = [ ] ) { $ serializer = clone $ this -> serializer ; $ serializer -> withMeta ( $ meta ) -> withLinks ( $ links ) ; $ serialized = $ serializer -> serializeData ( $ record , $ this -> createEncodingParameters ( ) ) ; $ resourceLinks = null ; if ( empty ( $ serialized [ 'data' ] [ 'id' ] ) ) { unset ( $ serialized [ 'data' ] [ 'id' ] ) ; $ resourceLinks = false ; } $ resource = $ this -> parsePrimaryResource ( $ serialized [ 'data' ] , $ resourceLinks ) ; $ document = [ 'data' => $ resource ] ; if ( isset ( $ serialized [ 'included' ] ) && $ this -> doesSerializeCompoundDocuments ( ) ) { $ document [ 'included' ] = $ this -> parseIncludedResources ( $ serialized [ 'included' ] ) ; } return $ document ; }
2215	public function next ( ) { if ( $ this -> blnDone ) { return false ; } if ( $ this -> fetchAssoc ( ) !== false ) { return $ this ; } $ this -> blnDone = true ; return false ; }
12092	public function generate ( $ name , array $ parameters = array ( ) , $ updateTrackerName = 'global' , $ referenceType = RouterInterface :: ABSOLUTE_PATH , $ timestampParameterName = null ) { if ( ! $ timestampParameterName ) { $ timestampParameterName = $ this -> timestampParameterName ; } $ parameters [ $ timestampParameterName ] = $ this -> updateManager -> getLastUpdate ( $ updateTrackerName ) -> format ( 'U' ) ; return $ this -> router -> generate ( $ name , $ parameters , $ referenceType ) ; }
8679	public function sort ( $ order = SORT_ASC , $ flags = SORT_REGULAR , $ preserveKeys = false ) { $ this -> validateSortArgs ( $ order , $ flags ) ; $ items = $ this -> items ; if ( ! $ preserveKeys ) { if ( $ order === SORT_ASC ) { sort ( $ items , $ flags ) ; } elseif ( $ order === SORT_DESC ) { rsort ( $ items , $ flags ) ; } } else { if ( $ order === SORT_ASC ) { asort ( $ items , $ flags ) ; } elseif ( $ order === SORT_DESC ) { arsort ( $ items , $ flags ) ; } } return $ this -> createFrom ( $ items ) ; }
11857	private function removeCookie ( $ cookie , \ Psr \ Http \ Message \ ResponseInterface $ response ) { return \ Dflydev \ FigCookies \ FigResponseCookies :: remove ( $ response , $ cookie ) ; }
9421	public function getContents ( ) { if ( is_null ( $ this -> stream ) || ! $ this -> isReadable ( ) ) { $ message = 'Could not get contents of stream' ; throw new \ RuntimeException ( $ message ) ; } return stream_get_contents ( $ this -> stream ) ; }
4226	public function register ( ) { if ( $ this -> registered ) { return ; } $ this -> prevDisplayErrors = \ ini_set ( 'display_errors' , 0 ) ; $ this -> prevErrorHandler = \ set_error_handler ( array ( $ this , 'handleError' ) ) ; $ this -> prevExceptionHandler = \ set_exception_handler ( array ( $ this , 'handleException' ) ) ; $ this -> registered = true ; return ; }
2151	public function onToggleVisibility ( $ blnDisabled , DataContainer $ dc ) { if ( ! $ dc -> id ) { return $ blnDisabled ; } $ objUser = $ this -> Database -> prepare ( "SELECT email FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objUser -> numRows ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET tstamp=?, active=? WHERE email=?" ) -> execute ( time ( ) , ( $ blnDisabled ? '' : '1' ) , $ objUser -> email ) ; } return $ blnDisabled ; }
5732	public function getLeague ( int $ leagueID , array $ filter = [ 'areas' => '' ] ) { $ league = $ this -> run ( "v2/competitions/{$leagueID}" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ league ) ; }
7721	public function actionIndex ( ) { $ searchModel = new MahasiswaSearch ( ) ; $ dataProvider = $ searchModel -> search ( Yii :: $ app -> request -> queryParams ) ; $ field = [ 'fileImport' => 'File Import' , ] ; $ modelImport = DynamicModel :: validateData ( $ field , [ [ [ 'fileImport' ] , 'required' ] , [ [ 'fileImport' ] , 'file' , 'extensions' => 'xls,xlsx' , 'maxSize' => 1024 * 1024 ] , ] ) ; return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , 'modelImport' => $ modelImport , ] ) ; }
2688	private function fastlyRotate ( $ angle ) { $ angle = ( int ) $ angle ; $ orient = null ; if ( $ angle == 90 ) { $ orient = 'r' ; } if ( $ angle == - 90 || $ angle == 270 ) { $ orient = 'l' ; } if ( $ angle == 180 ) { $ orient = 3 ; } if ( $ orient !== null ) { $ this -> fastlyParameters [ 'orient' ] = $ orient ; } return $ this ; }
5278	public function orWhere ( $ column , $ param1 = null , $ param2 = null ) { return $ this -> where ( $ column , $ param1 , $ param2 , 'or' ) ; }
5012	public function injectLogger ( bool $ flag = null ) : bool { if ( null === $ flag ) { return $ this -> injectLogger ; } $ this -> injectLogger = $ flag ; return $ flag ; }
4757	protected function transformIterable ( $ value ) { $ params = array ( ) ; foreach ( $ value as $ key => $ val ) { if ( ! empty ( $ val ) ) { $ params [ $ key ] = $ this -> transform ( $ val ) ; } } return $ params ; }
7315	public function setDateTime ( $ year , $ month , $ day , $ hour , $ min , $ sec ) { return $ this -> setDate ( $ year , $ month , $ day ) -> setTime ( $ hour , $ min , $ sec ) ; }
4747	public function listPlans ( array $ filters = [ ] , bool $ withAddons = true , string $ addonType = null ) : array { $ cacheKey = 'plans' ; $ hit = $ this -> getFromCache ( $ cacheKey ) ; if ( false === $ hit ) { $ response = $ this -> sendRequest ( 'GET' , 'plans' ) ; $ plans = $ this -> processResponse ( $ response ) ; $ hit = $ plans [ 'plans' ] ; $ this -> saveToCache ( $ cacheKey , $ hit ) ; } $ hit = $ this -> filterPlans ( $ hit , $ filters ) ; if ( $ withAddons ) { $ hit = $ this -> getAddonsForPlan ( $ hit , $ addonType ) ; } return $ hit ; }
10357	protected static function highlightCode ( string $ file , int $ line , int $ padding = 6 ) : array { if ( ! is_readable ( $ file ) ) { return false ; } $ handle = fopen ( $ file , 'r' ) ; $ lines = array ( ) ; $ currentLine = 0 ; while ( ! feof ( $ handle ) ) { $ currentLine ++ ; $ temp = fgets ( $ handle ) ; if ( $ currentLine > $ line + $ padding ) { break ; } if ( $ currentLine >= ( $ line - $ padding ) && $ currentLine <= ( $ line + $ padding ) ) { $ lines [ ] = array ( 'number' => str_pad ( $ currentLine , 4 , ' ' , STR_PAD_LEFT ) , 'highlighted' => ( $ currentLine === $ line ) , 'code' => ErrorHandler :: highlightString ( $ temp ) , ) ; } } fclose ( $ handle ) ; return $ lines ; }
9179	public function getDatabase ( ) { if ( $ useDbId = $ this -> getUseDbId ( ) ) { return $ this -> getDatabaseById ( $ useDbId ) ; } foreach ( $ this -> databases as $ database ) { if ( $ database -> isDefault ( ) ) { return $ database ; } } if ( $ this -> databases -> count ( ) > 0 ) { return $ this -> databases -> first ( ) ; } throw new \ Exception ( 'There is no database configuration available' ) ; }
2174	private function setUpDatabaseConnection ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( false !== getenv ( 'DATABASE_URL' ) ) { return $ this -> render ( 'misconfigured_database_url.html.twig' ) ; } $ parameters = [ 'parameters' => [ 'database_host' => $ this -> getContainerParameter ( 'database_host' ) , 'database_port' => $ this -> getContainerParameter ( 'database_port' ) , 'database_user' => $ this -> getContainerParameter ( 'database_user' ) , 'database_password' => $ this -> getContainerParameter ( 'database_password' ) , 'database_name' => $ this -> getContainerParameter ( 'database_name' ) , ] , ] ; if ( 'tl_database_login' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'database.html.twig' , $ parameters ) ; } $ parameters = [ 'parameters' => [ 'database_host' => $ request -> request -> get ( 'dbHost' ) , 'database_port' => $ request -> request -> get ( 'dbPort' ) , 'database_user' => $ request -> request -> get ( 'dbUser' ) , 'database_password' => $ this -> getContainerParameter ( 'database_password' ) , 'database_name' => $ request -> request -> get ( 'dbName' ) , ] , ] ; if ( '*****' !== $ request -> request -> get ( 'dbPassword' ) ) { $ parameters [ 'parameters' ] [ 'database_password' ] = $ request -> request -> get ( 'dbPassword' ) ; } if ( false !== strpos ( $ parameters [ 'parameters' ] [ 'database_name' ] , '.' ) ) { return $ this -> render ( 'database.html.twig' , array_merge ( $ parameters , [ 'database_error' => $ this -> trans ( 'database_dot_in_dbname' ) ] ) ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ installTool -> setConnection ( ConnectionFactory :: create ( $ parameters ) ) ; if ( ! $ installTool -> canConnectToDatabase ( $ parameters [ 'parameters' ] [ 'database_name' ] ) ) { return $ this -> render ( 'database.html.twig' , array_merge ( $ parameters , [ 'database_error' => $ this -> trans ( 'database_could_not_connect' ) ] ) ) ; } $ dumper = new ParameterDumper ( $ this -> getContainerParameter ( 'kernel.project_dir' ) ) ; $ dumper -> setParameters ( $ parameters ) ; $ dumper -> dump ( ) ; $ this -> purgeSymfonyCache ( ) ; return $ this -> getRedirectResponse ( ) ; }
12290	public function countTotal ( $ categoryId = null ) { $ qb = $ this -> getQueryBuilder ( ) -> select ( 'COUNT(p)' ) ; if ( ! is_null ( $ categoryId ) ) { $ qb -> join ( 'p.categories' , 'c' ) -> where ( 'c.id = :categoryId' ) -> setParameter ( 'categoryId' , $ categoryId ) ; } return $ qb -> getQuery ( ) -> getSingleScalarResult ( ) ; }
1635	protected function setupEvents ( Dispatcher $ events , array $ config ) { if ( isset ( $ config [ 'auto_capture_sessions' ] ) && $ config [ 'auto_capture_sessions' ] ) { $ events -> listen ( RouteMatched :: class , function ( $ event ) { $ this -> app -> bugsnag -> getSessionTracker ( ) -> startSession ( ) ; } ) ; } if ( isset ( $ config [ 'query' ] ) && ! $ config [ 'query' ] ) { return ; } $ show = isset ( $ config [ 'bindings' ] ) && $ config [ 'bindings' ] ; if ( class_exists ( QueryExecuted :: class ) ) { $ events -> listen ( QueryExecuted :: class , function ( QueryExecuted $ query ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ query -> sql , $ show ? $ query -> bindings : [ ] , $ query -> time , $ query -> connectionName ) ) ; } ) ; } else { $ events -> listen ( 'illuminate.query' , function ( $ sql , array $ bindings , $ time , $ connection ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ sql , $ show ? $ bindings : [ ] , $ time , $ connection ) ) ; } ) ; } }
4536	public function setTenantIdIn ( array $ tenantIdIn ) { $ this -> tenantIdIn = $ tenantIdIn ; $ this -> _tenantIdIn = null !== $ tenantIdIn ; return $ this ; }
5947	public function getAdapterType ( ) { if ( $ this -> adapter instanceof AbstractAdapter ) { $ string = StringHelper :: factory ( get_class ( $ this -> adapter ) ) ; return $ string -> substr ( $ string -> findLast ( "\\" ) ) -> replace ( array ( "\\" , " " ) , "" ) -> toString ( ) ; } return "Unknown" ; }
9637	public function handle ( GetResponseEvent $ event ) { $ apiKey = $ this -> getApiKeyFromQueryOrHeader ( $ event -> getRequest ( ) ) ; if ( false === $ apiKey ) { return ; } try { $ token = $ this -> authenticationManager -> authenticate ( new ApiKeyToken ( $ apiKey ) ) ; $ this -> tokenStorage -> setToken ( $ token ) ; } catch ( AuthenticationException $ failed ) { $ this -> tokenStorage -> setToken ( null ) ; $ this -> doFailureResponse ( $ event ) ; } }
6619	public function hasChildController ( $ controllerName ) { $ methodName = $ this -> parseControllerName ( $ controllerName ) ; return $ this -> reflection -> hasMethod ( $ methodName ) ; }
3386	public function authenticate ( $ identity , $ credential ) { $ adapter = $ this -> auth -> getAdapter ( ) ; $ adapter -> setIdentity ( $ identity ) ; $ adapter -> setCredential ( $ credential ) ; return $ this -> auth -> authenticate ( ) ; }
5456	protected function addContentToAllOpenTags ( $ text ) { foreach ( array_keys ( $ this -> tags ) as $ name ) { for ( $ i = 0 , $ count = count ( $ this -> tags [ $ name ] ) ; $ i < $ count ; $ i ++ ) { $ this -> tags [ $ name ] [ $ i ] -> addContent ( $ text ) ; } } }
8774	public function base ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . $ data : $ this -> url . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
3658	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getProperty ( ) ) ) { return ; } $ values = $ event -> getValue ( ) ; $ index = 0 ; $ time = time ( ) ; foreach ( array_keys ( $ values ) as $ key ) { $ values [ $ key ] [ 'sorting' ] = $ index ; $ values [ $ key ] [ 'tstamp' ] = $ time ; $ index += 128 ; } $ event -> setValue ( $ values ) ; }
5837	public function transform ( $ orig , $ transformation = null , $ overrides = array ( ) ) { return $ this -> transformer -> transform ( $ orig , $ transformation , $ overrides ) ; }
2106	public function getMaxUploadFileSize ( ) { $ objResult = Database :: getInstance ( ) -> prepare ( "SELECT MAX(maxlength) AS maxlength FROM tl_form_field WHERE pid=? AND invisible='' AND type='upload' AND maxlength>0" ) -> execute ( $ this -> id ) ; if ( $ objResult -> numRows > 0 && $ objResult -> maxlength > 0 ) { return $ objResult -> maxlength ; } else { return Config :: get ( 'maxFileSize' ) ; } }
8782	protected function finish ( $ output = null ) { if ( ! is_null ( $ output ) ) { $ file = fopen ( $ this -> file , 'w+' ) ; fwrite ( $ file , $ output ) ; fclose ( $ file ) ; return $ output ; } return false ; }
10559	private function setupTranslateLog ( ) { $ logger = Logger :: getLogger ( 'Wedeto.I18n.Translator.Translator' ) ; $ writer = new TranslationLogger ( $ this -> app -> pathConfig -> log . '/translate-%s-%s.pot' ) ; $ logger -> addLogWriter ( $ writer ) ; }
4639	private function attachFiles ( Message $ message , Email $ email ) { if ( ! $ email -> hasAttachments ( ) ) { return ; } $ attachments = $ email -> getComputedAttachments ( ) ; $ mimeMessage = $ message -> getBody ( ) ; $ oldParts = $ mimeMessage -> getParts ( ) ; $ attachmentParts = [ ] ; $ info = null ; foreach ( $ attachments as $ key => $ attachment ) { if ( is_array ( $ attachment ) && isset ( $ attachment [ 'parser_name' ] , $ attachment [ 'value' ] ) ) { $ attachment = Attachment :: fromArray ( $ attachment ) ; } $ parserName = $ this -> resolveParserNameFromAttachment ( $ attachment ) ; if ( ! $ this -> attachmentParserManager -> has ( $ parserName ) ) { throw new Exception \ ServiceNotCreatedException ( sprintf ( 'The attachment parser "%s" could not be found' , $ parserName ) ) ; } $ parser = $ this -> attachmentParserManager -> get ( $ parserName ) ; $ attachmentValue = $ attachment instanceof Attachment ? $ attachment -> getValue ( ) : $ attachment ; $ part = $ parser -> parse ( $ attachmentValue , is_string ( $ key ) ? $ key : null ) ; $ part -> charset = $ email -> getCharset ( ) ; $ attachmentParts [ ] = $ part ; } $ body = new Mime \ Message ( ) ; $ body -> setParts ( array_merge ( $ oldParts , $ attachmentParts ) ) ; $ message -> setBody ( $ body ) ; }
1191	private function addCustomDefinition ( array $ definitionConfig , HTMLPurifier_Config $ configObject = null ) { if ( ! $ configObject ) { $ configObject = HTMLPurifier_Config :: createDefault ( ) ; $ configObject -> loadArray ( $ this -> getConfig ( ) ) ; } $ configObject -> set ( 'HTML.DefinitionID' , $ definitionConfig [ 'id' ] ) ; $ configObject -> set ( 'HTML.DefinitionRev' , $ definitionConfig [ 'rev' ] ) ; if ( ! isset ( $ definitionConfig [ 'debug' ] ) || $ definitionConfig [ 'debug' ] ) { $ configObject -> set ( 'Cache.DefinitionImpl' , null ) ; } if ( $ def = $ configObject -> maybeGetRawHTMLDefinition ( ) ) { if ( ! empty ( $ definitionConfig [ 'attributes' ] ) ) { $ this -> addCustomAttributes ( $ definitionConfig [ 'attributes' ] , $ def ) ; } if ( ! empty ( $ definitionConfig [ 'elements' ] ) ) { $ this -> addCustomElements ( $ definitionConfig [ 'elements' ] , $ def ) ; } } return $ configObject ; }
1665	public function getListForSelect ( $ display = 'name' ) { foreach ( $ this -> getList ( $ display ) as $ key => $ value ) { $ countries [ $ key ] = $ value [ $ display ] ; } return $ countries ; }
183	public function getPublishedUrl ( $ path ) { $ path = Yii :: getAlias ( $ path ) ; if ( isset ( $ this -> _published [ $ path ] ) ) { return $ this -> _published [ $ path ] [ 1 ] ; } if ( is_string ( $ path ) && ( $ path = realpath ( $ path ) ) !== false ) { return $ this -> baseUrl . '/' . $ this -> hash ( $ path ) . ( is_file ( $ path ) ? '/' . basename ( $ path ) : '' ) ; } return false ; }
12801	public function createItem ( $ name , array $ options = array ( ) ) { if ( ! empty ( $ options [ 'admin' ] ) ) { $ admin = $ options [ 'admin' ] ; if ( ! $ options [ 'admin' ] instanceof AdminInterface ) { $ admin = $ this -> container -> get ( 'sonata.admin.pool' ) -> getAdminByAdminCode ( $ admin ) ; } $ action = isset ( $ options [ 'admin_action' ] ) ? $ options [ 'admin_action' ] : 'list' ; $ options [ 'uri' ] = $ admin -> generateUrl ( $ action ) ; $ options [ 'translationDomain' ] = $ admin -> getTranslationDomain ( ) ; } if ( ! empty ( $ options [ 'route' ] ) ) { $ params = isset ( $ options [ 'routeParameters' ] ) ? $ options [ 'routeParameters' ] : array ( ) ; $ absolute = isset ( $ options [ 'routeAbsolute' ] ) ? $ options [ 'routeAbsolute' ] : false ; $ options [ 'uri' ] = $ this -> generator -> generate ( $ options [ 'route' ] , $ params , $ absolute ) ; } $ item = new MenuItem ( $ name , $ this ) ; $ options = array_merge ( array ( 'uri' => null , 'label' => null , 'attributes' => array ( ) , 'linkAttributes' => array ( ) , 'childrenAttributes' => array ( ) , 'labelAttributes' => array ( ) , 'extras' => array ( ) , 'display' => true , 'displayChildren' => true , 'translationDomain' => 'messages' , 'displayLink' => true , 'displayLabel' => true , ) , $ options ) ; $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setExtras ( $ options [ 'extras' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) -> setTranslationDomain ( $ options [ 'translationDomain' ] ) -> setDisplayLink ( $ options [ 'displayLink' ] ) -> setDisplayLabel ( $ options [ 'displayLabel' ] ) ; return $ item ; return parent :: createItem ( $ name , $ options ) ; }
5269	private function translateSelect ( ) { $ build = array ( 'select' ) ; if ( $ this -> found_rows ) { $ build [ ] = 'SQL_CALC_FOUND_ROWS' ; } if ( $ this -> distinct ) { $ build [ ] = 'distinct' ; } $ build [ ] = ! empty ( $ this -> statements [ 'select' ] ) && is_array ( $ this -> statements [ 'select' ] ) ? join ( ', ' , $ this -> statements [ 'select' ] ) : '*' ; $ build [ ] = 'from ' . $ this -> table ; if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> statements [ 'groups' ] ) ) { $ build [ ] = 'group by ' . join ( ', ' , $ this -> statements [ 'groups' ] ) ; if ( ! empty ( $ this -> statements [ 'having' ] ) ) { $ build [ ] = $ this -> statements [ 'having' ] ; } } if ( ! empty ( $ this -> statements [ 'orders' ] ) ) { $ build [ ] = $ this -> translateOrderBy ( ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
7779	protected function extractRules ( array $ data ) { $ rules = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ rules [ $ field ] = $ fieldData [ 1 ] ; } return $ rules ; }
12569	public function previewText ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_TEXT , $ message , $ to , $ by ) ; }
1573	public function getProcessIdentifier ( ) : ? ResourceIdentifierInterface { if ( ! $ id = $ this -> getProcessId ( ) ) { return null ; } return ResourceIdentifier :: create ( $ this -> getProcessType ( ) , $ id ) ; }
10765	public function generateImage ( $ filename = false , $ level = Constants :: QR_ECLEVEL_L , $ size = 3 , $ margin = 4 ) { $ result = 'SPD' . self :: DELIMITER . $ this -> version . self :: DELIMITER . $ this -> implodeContent ( ) ; if ( $ this -> appendCRC32 ) { $ result .= self :: DELIMITER . 'CRC32:' . sprintf ( '%x' , crc32 ( $ result ) ) ; } QRcode :: png ( $ result , $ filename , $ level , $ size , $ margin ) ; die ( ) ; }
10936	protected function authenticateUser ( CustomerInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
3594	public static function getCurrentMacAddress ( $ interface ) { $ ifconfig = self :: runCommand ( "ifconfig {$interface}" ) ; preg_match ( "/" . self :: $ valid_mac . "/i" , $ ifconfig , $ ifconfig ) ; if ( isset ( $ ifconfig [ 0 ] ) ) { return trim ( strtoupper ( $ ifconfig [ 0 ] ) ) ; } return false ; }
4191	protected function dumpMethodParams ( $ params ) { $ paramStr = '' ; foreach ( $ params as $ info ) { $ paramStr .= '<span class="parameter">' ; if ( ! empty ( $ info [ 'type' ] ) ) { $ paramStr .= '<span class="t_type">' . $ info [ 'type' ] . '</span> ' ; } $ paramStr .= '<span class="t_parameter-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . \ htmlspecialchars ( $ info [ 'name' ] ) . '</span>' ; if ( $ info [ 'defaultValue' ] !== $ this -> debug -> abstracter -> UNDEFINED ) { $ defaultValue = $ info [ 'defaultValue' ] ; $ paramStr .= ' <span class="t_operator">=</span> ' ; if ( $ info [ 'constantName' ] ) { $ title = '' ; $ type = $ this -> debug -> abstracter -> getType ( $ defaultValue ) ; if ( ! \ in_array ( $ type , array ( 'array' , 'resource' ) ) ) { $ title = $ this -> debug -> output -> text -> dump ( $ defaultValue ) ; $ title = \ htmlspecialchars ( 'value: ' . $ title ) ; } $ paramStr .= '<span class="t_parameter-default t_const"' . ' title="' . $ title . '"' . '>' . $ info [ 'constantName' ] . '</span>' ; } else { if ( \ is_string ( $ defaultValue ) ) { $ defaultValue = \ str_replace ( "\n" , ' ' , $ defaultValue ) ; } $ parsed = $ this -> debug -> utilities -> parseTag ( $ this -> debug -> output -> html -> dump ( $ defaultValue ) ) ; $ class = \ trim ( 't_parameter-default ' . $ parsed [ 'attribs' ] [ 'class' ] ) ; $ paramStr .= '<span class="' . $ class . '">' . $ parsed [ 'innerhtml' ] . '</span>' ; } } $ paramStr .= '</span>, ' ; } $ paramStr = \ trim ( $ paramStr , ', ' ) ; return $ paramStr ; }
3009	public function fetch ( $ template , array $ data = [ ] ) { if ( isset ( $ data [ 'template' ] ) ) { throw new \ InvalidArgumentException ( "Duplicate template key found" ) ; } if ( ! is_file ( $ this -> templatePath . $ template ) ) { throw new \ RuntimeException ( "View cannot render `$template` because the template does not exist" ) ; } $ data = array_merge ( $ this -> attributes , $ data ) ; try { ob_start ( ) ; $ this -> protectedIncludeScope ( $ this -> templatePath . $ template , $ data ) ; $ output = ob_get_clean ( ) ; if ( $ this -> layout !== null ) { ob_start ( ) ; $ data [ 'content' ] = $ output ; $ this -> protectedIncludeScope ( $ this -> layout , $ data ) ; $ output = ob_get_clean ( ) ; } } catch ( \ Throwable $ e ) { ob_end_clean ( ) ; throw $ e ; } catch ( \ Exception $ e ) { ob_end_clean ( ) ; throw $ e ; } return $ output ; }
7085	public function setDbQueryConditionsForDefaultOptionsLoader ( $ conditonsAndOptions ) { if ( ! is_array ( $ conditonsAndOptions ) && ! ( $ conditonsAndOptions instanceof DbExpr ) && ! ( $ conditonsAndOptions instanceof \ Closure ) ) { throw new \ InvalidArgumentException ( '$conditonsAndOptions argument must be a string, DbExpr or a Closure' ) ; } $ this -> dbQueryConditionsForDefaultOptionsLoader = $ conditonsAndOptions ; return $ this ; }
1778	public static function optionChecked ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' checked' : '' ; }
886	private function clear ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ ++ $ index ] -> equals ( ';' ) ) { if ( $ this -> shouldClearToken ( $ tokens , $ index ) ) { $ tokens -> clearAt ( $ index ) ; } } }
7595	protected function renderLabel ( ElementInterface $ oElement ) { if ( ( $ sLabel = $ oElement -> getLabel ( ) ) && ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sLabel = $ oTranslator -> translate ( $ sLabel , $ this -> getTranslatorTextDomain ( ) ) ; } return $ sLabel ; }
8366	public static function registerMapping ( array $ config ) { self :: validateConfig ( $ config ) ; if ( isset ( self :: $ mappings [ $ config [ 'name' ] ] ) === false ) { self :: $ mappings [ $ config [ 'name' ] ] = array ( 'config' => $ config ) ; Database :: registerDatabase ( $ config [ 'database' ] ) ; } else { Logger :: get ( ) -> warning ( 'mapping with name "' . $ config [ 'name' ] . '" was already set' ) ; } }
9527	private function parseEvery ( ) { $ results = [ ] ; $ i = 0 ; while ( $ i < count ( $ this -> argv ) ) { $ parameter = $ this -> argv [ $ i ] ; if ( $ this -> parseSingle ( $ i , $ parameter , $ results ) === false ) { break ; } } return $ results ; }
590	protected function compressJsFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing JavaScript files...\n" ) ; if ( is_string ( $ this -> jsCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineJsFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> jsCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> jsCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress JavaScript files into '{$outputFile}'." ) ; } $ this -> stdout ( " JavaScript files compressed into '{$outputFile}'.\n" ) ; }
2448	public function sendNotifications ( $ varValue ) { if ( $ varValue ) { Contao \ Comments :: notifyCommentsSubscribers ( Contao \ CommentsModel :: findByPk ( Contao \ Input :: get ( 'id' ) ) ) ; } return $ varValue ; }
7901	protected function runUpload ( $ file ) { $ this -> provider -> setFile ( $ file ) ; if ( ! $ this -> provider -> isValid ( ) ) { throw new InvalidFileException ( "Given file [{$file}] is invalid." ) ; } $ filename = $ this -> getFullFileName ( $ this -> provider ) ; if ( $ this -> filesystem -> disk ( $ this -> disk ) -> put ( $ filename , $ this -> provider -> getContents ( ) , $ this -> getVisibility ( ) ) ) { return $ filename ; } return false ; }
6488	protected function getClientIPAddress ( array $ server ) : ? string { $ serverRemoteAddress = $ server [ 'REMOTE_ADDR' ] ?? null ; if ( $ this -> isUsingTrustedProxy ( $ server ) ) { return $ serverRemoteAddress ?? null ; } $ ipAddresses = [ ] ; if ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ) ) { $ header = $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ; preg_match_all ( "/for=(?:\"?\[?)([a-z0-9:\.\-\/_]*)/" , $ header , $ matches ) ; $ ipAddresses = $ matches [ 1 ] ; } elseif ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ) { $ ipAddresses = explode ( ',' , $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ; $ ipAddresses = array_map ( 'trim' , $ ipAddresses ) ; } if ( $ serverRemoteAddress !== null ) { $ ipAddresses [ ] = $ serverRemoteAddress ; } $ fallbackIPAddresses = count ( $ ipAddresses ) === 0 ? [ ] : [ $ ipAddresses [ 0 ] ] ; foreach ( $ ipAddresses as $ index => $ ipAddress ) { if ( filter_var ( $ ipAddress , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) === false ) { unset ( $ ipAddresses [ $ index ] ) ; } if ( in_array ( $ ipAddress , $ this -> trustedProxyIPAddresses , true ) ) { unset ( $ ipAddresses [ $ index ] ) ; } } $ clientIPAddresses = count ( $ ipAddresses ) === 0 ? $ fallbackIPAddresses : array_reverse ( $ ipAddresses ) ; return $ clientIPAddresses [ 0 ] ?? null ; }
3293	public function linkedin ( $ summary = '' ) { $ base = config ( 'laravel-share.services.linkedin.uri' ) ; $ mini = config ( 'laravel-share.services.linkedin.extra.mini' ) ; $ url = $ base . '?mini=' . $ mini . '&url=' . $ this -> url . '&title=' . urlencode ( $ this -> title ) . '&summary=' . urlencode ( $ summary ) ; $ this -> buildLink ( 'linkedin' , $ url ) ; return $ this ; }
9446	public function getConfigsPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ subpath = $ this -> packOptions [ 'configs_subpath' ] ; $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) . '/' . $ subpath ; } return $ paths [ $ me ] ; }
2374	public static function srcToInsertTag ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]+)")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 4 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByPath ( $ paths [ $ i + 3 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="{{file::' . static :: binToUuid ( $ file -> uuid ) . '}}"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . '"' ; } } return $ return ; }
2970	private function doSend ( MessageInterface $ message ) { $ content = $ this -> format ( $ message ) ; $ headers = $ this -> getHeaders ( ) ; $ files = $ this -> getFiles ( $ message ) ; if ( ! empty ( $ files ) ) { parse_str ( $ content , $ fields ) ; $ builder = new MultipartStreamBuilder ( ) ; foreach ( $ fields as $ name => $ value ) { if ( is_array ( $ value ) ) { foreach ( $ value as $ c ) { $ builder -> addResource ( $ name . '[]' , $ c ) ; } continue ; } $ builder -> addResource ( $ name , $ value ) ; } foreach ( $ files as $ key => $ items ) { foreach ( $ items as $ name => $ path ) { $ options = [ ] ; if ( ! is_numeric ( $ name ) ) { $ options [ 'filename' ] = $ name ; } $ value = fopen ( $ path , 'r' ) ; $ builder -> addResource ( $ key , $ value , $ options ) ; } } $ content = $ builder -> build ( ) ; $ headers [ 'Content-Type' ] = 'multipart/form-data; boundary="' . $ builder -> getBoundary ( ) . '"' ; } $ request = $ this -> getMessageFactory ( ) -> createRequest ( 'POST' , $ this -> getEndpoint ( ) , $ headers , $ content ) ; return $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; }
1435	public static function underscore ( $ value ) { if ( isset ( self :: $ underscored [ $ value ] ) ) { return self :: $ underscored [ $ value ] ; } return self :: $ underscored [ $ value ] = str_replace ( '-' , '_' , self :: decamelize ( $ value ) ) ; }
10380	protected static function is_modified_hash ( $ url , $ path ) { if ( self :: is_external_url ( $ url ) ) { if ( sha1_file ( $ url ) !== sha1_file ( $ path ) ) { self :: $ changes = true ; return self :: $ changes ; } } return false ; }
7124	protected function getMessageFromEvent ( ResourceEventInterface $ event ) { $ message = $ event -> getResource ( ) ; if ( ! $ message instanceof TicketMessageInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketMessageInterface :: class ) ; } return $ message ; }
10002	public function apply ( Tag $ tag , Renderer $ renderer ) { foreach ( $ this -> stack as $ item ) { $ result = $ item [ 'decorator' ] ( $ tag , $ renderer ) ; if ( $ result instanceof Tag ) { $ tag = $ result ; } else { trigger_error ( sprintf ( '%s does not return an instance of Sirius\\Html\\Tag' , get_class ( $ item [ 'decorator' ] ) ) , E_USER_WARNING ) ; } } return $ tag ; }
840	public function setSize ( $ size ) { if ( $ this -> getSize ( ) !== $ size ) { $ this -> changed = true ; parent :: setSize ( $ size ) ; } }
1169	protected function purgeNonRemoteRules ( $ rules , $ validator ) { $ protectedValidator = $ this -> createProtectedCaller ( $ validator ) ; foreach ( $ rules as $ i => $ rule ) { $ parsedRule = ValidationRuleParser :: parse ( [ $ rule ] ) ; if ( ! $ this -> isRemoteRule ( $ parsedRule [ 0 ] ) ) { unset ( $ rules [ $ i ] ) ; } } return $ rules ; }
3115	public function storeItemHrefIndex ( $ testSessionId , $ table ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setItemHrefIndex ( $ table ) ; $ extendedState -> save ( ) ; }
8505	public function createInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_CreateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_CreateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_CreateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1740	public function checkImportantPart ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/' . $ dc -> id ) || ! \ in_array ( strtolower ( substr ( $ dc -> id , strrpos ( $ dc -> id , '.' ) + 1 ) ) , Contao \ StringUtil :: trimsplit ( ',' , strtolower ( Contao \ Config :: get ( 'validImageTypes' ) ) ) ) ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] = str_replace ( ',importantPartX,importantPartY,importantPartWidth,importantPartHeight' , '' , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] ) ; } }
2753	protected function getRequestForPath ( $ path , array $ exclude ) { if ( ! empty ( $ exclude [ $ path ] ) ) { return NULL ; } $ request = Request :: create ( $ path ) ; $ request -> headers -> set ( 'Accept' , 'text/html' ) ; $ processed = $ this -> pathProcessor -> processInbound ( $ path , $ request ) ; if ( empty ( $ processed ) || ! empty ( $ exclude [ $ processed ] ) ) { return NULL ; } $ this -> currentPath -> setPath ( $ processed , $ request ) ; try { $ request -> attributes -> add ( $ this -> router -> matchRequest ( $ request ) ) ; return $ request ; } catch ( ParamNotConvertedException $ e ) { return NULL ; } catch ( ResourceNotFoundException $ e ) { return NULL ; } catch ( MethodNotAllowedException $ e ) { return NULL ; } catch ( AccessDeniedHttpException $ e ) { return NULL ; } }
3974	protected function build ( IMetaModelDataDefinition $ container ) { $ inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( ! $ inputScreen ) { return ; } $ meta = $ inputScreen [ 'meta' ] ; $ config = $ this -> getDataProviderDefinition ( $ container ) ; if ( ! $ config -> hasInformation ( $ container -> getName ( ) ) ) { $ providerInformation = new ContaoDataProviderInformation ( ) ; $ providerInformation -> setName ( $ container -> getName ( ) ) ; $ config -> addInformation ( $ providerInformation ) ; } else { $ providerInformation = $ config -> getInformation ( $ container -> getName ( ) ) ; } $ basicDefinition = $ container -> getBasicDefinition ( ) ; if ( $ providerInformation instanceof ContaoDataProviderInformation ) { $ providerInformation -> setTableName ( $ container -> getName ( ) ) -> setClassName ( Driver :: class ) -> setInitializationData ( [ 'source' => $ container -> getName ( ) ] ) -> setVersioningEnabled ( false ) ; $ basicDefinition -> setDataProvider ( $ container -> getName ( ) ) ; } if ( $ basicDefinition -> getMode ( ) == BasicDefinitionInterface :: MODE_HIERARCHICAL ) { $ basicDefinition -> setRootDataProvider ( $ container -> getName ( ) ) ; } if ( 'ctable' === $ meta [ 'rendertype' ] ) { $ parentTable = $ meta [ 'ptable' ] ; if ( ! $ config -> hasInformation ( $ parentTable ) ) { $ providerInformation = new ContaoDataProviderInformation ( ) ; $ providerInformation -> setName ( $ parentTable ) ; $ config -> addInformation ( $ providerInformation ) ; } else { $ providerInformation = $ config -> getInformation ( $ parentTable ) ; } if ( $ providerInformation instanceof ContaoDataProviderInformation ) { $ providerInformation -> setTableName ( $ parentTable ) -> setInitializationData ( [ 'source' => $ parentTable ] ) ; if ( in_array ( $ parentTable , $ this -> factory -> collectNames ( ) ) ) { $ providerInformation -> setClassName ( Driver :: class ) ; } $ basicDefinition -> setParentDataProvider ( $ parentTable ) ; } } }
3868	protected function getConfigs ( ) { if ( ! count ( $ this -> configs ) ) { $ statement = $ this -> connection -> query ( 'SELECT * FROM tl_metamodel_searchable_pages' ) ; $ this -> configs = $ statement -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; } return $ this -> configs ; }
7543	function getSibling ( $ offset = 1 ) { $ index = $ this -> index ( ) + $ offset ; if ( ( $ index >= 0 ) && ( $ index < $ this -> parent -> childCount ( ) ) ) { return $ this -> parent -> getChild ( $ index ) ; } else { return null ; } }
4882	public function getPermissions ( ) { if ( ! $ this -> permissions ) { $ perms = new Permissions ( ) ; if ( $ this -> user instanceof UserInterface ) { $ perms -> grant ( $ this -> user , PermissionsInterface :: PERMISSION_ALL ) ; } $ this -> setPermissions ( $ perms ) ; } return $ this -> permissions ; }
11422	public function get ( $ openId , $ lang = 'zh_CN' ) { $ params = [ 'openid' => $ openId , 'lang' => $ lang , ] ; return $ this -> parseJSON ( 'get' , [ self :: API_GET , $ params ] ) ; }
6069	public function listComments ( $ mediaId , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ mediaId . '/comments' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new CommentResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11349	public function setData ( $ data ) { $ data = $ this -> transformer -> encode ( $ data ) ; foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field -> getName ( ) ] ) ) { $ field -> setData ( $ data [ $ field -> getName ( ) ] ) ; } } }
1631	public function getMetaData ( ) { $ data = [ ] ; $ data [ 'url' ] = $ this -> request -> fullUrl ( ) ; $ data [ 'httpMethod' ] = $ this -> request -> getMethod ( ) ; $ data [ 'params' ] = $ this -> request -> input ( ) ; $ data [ 'clientIp' ] = $ this -> request -> getClientIp ( ) ; if ( $ agent = $ this -> request -> header ( 'User-Agent' ) ) { $ data [ 'userAgent' ] = $ agent ; } if ( $ headers = $ this -> request -> headers -> all ( ) ) { $ data [ 'headers' ] = $ headers ; } return [ 'request' => $ data ] ; }
5867	public static function getOrientation ( $ fileName ) { $ orientation = 1 ; $ metadata = static :: getMetadata ( $ fileName ) ; if ( isset ( $ metadata [ 'Orientation' ] ) ) { $ orientation = $ metadata [ 'Orientation' ] ; } return $ orientation ; }
3657	private function tryDispatch ( $ eventName , MetaModelsBootEvent $ event ) { $ dispatcher = System :: getContainer ( ) -> get ( 'event_dispatcher' ) ; if ( $ dispatcher -> hasListeners ( $ eventName ) ) { @ trigger_error ( 'Event "' . $ eventName . '" has been deprecated - Use registered services.' , E_USER_DEPRECATED ) ; $ dispatcher -> dispatch ( $ eventName , $ event ) ; } }
12474	public function getTheme ( $ identifier ) { $ themes = $ this -> getAvailableThemes ( ) ; if ( ! isset ( $ themes [ $ identifier ] ) ) { $ themeIds = array ( ) ; foreach ( $ themes as $ key => $ value ) { $ themeIds [ ] = $ key ; } throw new \ Exception ( sprintf ( 'Theme "%s" does not exist. Possible values are [%s]' , $ identifier , implode ( ', ' , $ themeIds ) ) , 1 ) ; } return $ themes [ $ identifier ] ; }
4437	public function set ( string $ name , $ value ) : void { $ this -> client -> call ( 'config.set' , $ name , $ value ) ; }
3505	private function convertApsToArray ( Aps $ aps ) : array { $ data = [ 'alert' => $ this -> convertAlertToArray ( $ aps -> getAlert ( ) ) , ] ; if ( $ aps -> getSound ( ) ) { $ data [ 'sound' ] = $ aps -> getSound ( ) ; } if ( $ aps -> getBadge ( ) !== null ) { $ data [ 'badge' ] = $ aps -> getBadge ( ) ; } if ( $ aps -> getCategory ( ) ) { $ data [ 'category' ] = $ aps -> getCategory ( ) ; } if ( $ aps -> isContentAvailable ( ) ) { $ data [ 'content-available' ] = 1 ; } if ( $ aps -> isMutableContent ( ) ) { $ data [ 'mutable-content' ] = 1 ; } if ( $ aps -> getThreadId ( ) ) { $ data [ 'thread-id' ] = $ aps -> getThreadId ( ) ; } return $ data ; }
8021	public function payload ( array $ payload ) { $ client = new GuzzleClient ( [ 'base_uri' => $ this -> server ] ) ; $ client -> request ( 'POST' , $ this -> getUri ( ) , [ 'form_params' => [ 'payload' => json_encode ( $ payload ) ] ] ) ; }
5671	protected function describeStringDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } $ position = $ this -> stringDiffersAt ( $ first , $ second ) ; return sprintf ( 'at character %s with [%s] and [%s]' , $ position , $ this -> clipString ( $ first , 200 , $ position ) , $ this -> clipString ( $ second , 200 , $ position ) ) ; }
8994	private function update ( ) { if ( null !== $ this -> namespace ) { $ _SESSION [ $ this -> namespace ] = $ this -> sessionData ; } else { $ _SESSION = $ this -> sessionData ; } }
9851	public static function hashPassword ( $ pPassword ) { $ password = 0x0000 ; $ charPos = 1 ; $ chars = preg_split ( '//' , $ pPassword , - 1 , PREG_SPLIT_NO_EMPTY ) ; foreach ( $ chars as $ char ) { $ value = ord ( $ char ) << $ charPos ++ ; $ rotated_bits = $ value >> 15 ; $ value &= 0x7fff ; $ password ^= ( $ value | $ rotated_bits ) ; } $ password ^= strlen ( $ pPassword ) ; $ password ^= 0xCE4B ; return strtoupper ( dechex ( $ password ) ) ; }
8809	public function delete ( $ key ) { if ( $ this -> has ( $ key ) ) { setcookie ( $ key , null , - 1 , '/' ) ; unset ( $ _COOKIE [ $ key ] ) ; } return ; }
3361	private function exists ( $ offset = null ) { return isset ( $ this -> container [ $ offset !== null ? $ offset : $ this -> position ] ) ; }
11731	protected function generateSlot ( $ path , $ blocks = array ( ) , $ username = null ) { if ( is_dir ( $ path ) && ! $ this -> override ) { return ; } $ folders = array ( ) ; $ activeDir = $ path . '/active' ; $ contributorsDir = $ path . '/contributors' ; $ folders [ ] = $ activeDir . '/blocks' ; $ folders [ ] = $ activeDir . '/archive' ; $ folders [ ] = $ contributorsDir ; $ targetDir = $ activeDir ; $ blocksDir = $ activeDir . '/blocks' ; if ( null !== $ username ) { $ targetDir = $ contributorsDir . '/' . $ username ; $ blocksDir = $ targetDir . '/blocks' ; $ folders [ ] = $ targetDir ; $ folders [ ] = $ targetDir . '/archive' ; $ folders [ ] = $ blocksDir ; } $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> generateBlocks ( $ blocks , $ blocksDir , $ targetDir ) ; }
6417	public static function size ( IteratorAggregate $ iterable ) : int { if ( $ iterable instanceof Countable ) { return $ iterable -> count ( ) ; } return Iterators :: size ( Iterators :: from ( $ iterable -> getIterator ( ) ) ) ; }
10472	public function checkInItem ( $ item_id ) { $ request = new CheckInRequest ( $ this -> connector -> agency_id , $ item_id ) ; $ this -> emit ( 'request.checkin' , array ( $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new CheckInResponse ( $ response ) ; }
12713	protected function resolve ( $ instance , $ parameters = [ ] ) { if ( $ this -> isInterface ( $ instance ) ) { return $ this -> getConcreteFromInterface ( $ instance ) ; } try { return $ this -> getResolvedSingleton ( $ instance ) ; } catch ( \ Exception $ e ) { } $ concrete = $ this -> getConcrete ( $ instance ) ; if ( ! is_null ( $ concrete ) ) { $ object = $ this -> build ( $ instance , $ concrete instanceof \ Closure ? $ concrete ( $ this ) : $ concrete ) ; if ( $ this -> isShared ( $ instance ) ) { $ this -> markAsResolved ( $ instance , $ object , 'singleton' ) ; } else { $ this -> markAsResolved ( $ instance , $ object ) ; } } else { $ object = $ this -> build ( $ instance , $ parameters ) ; } return $ object ; }
3454	public static function fromAggregateRoot ( $ eventSourcedAggregateRoot ) : AggregateType { if ( ! \ is_object ( $ eventSourcedAggregateRoot ) ) { throw new Exception \ AggregateTypeException ( \ sprintf ( 'Aggregate root must be an object but type of %s given' , \ gettype ( $ eventSourcedAggregateRoot ) ) ) ; } if ( $ eventSourcedAggregateRoot instanceof AggregateTypeProvider ) { return $ eventSourcedAggregateRoot -> aggregateType ( ) ; } $ self = new static ( ) ; $ self -> aggregateType = \ get_class ( $ eventSourcedAggregateRoot ) ; return $ self ; }
3577	protected function metaQuery ( Builder $ query , $ method , ArgumentBag $ args ) { if ( in_array ( $ method , [ 'pluck' , 'value' , 'aggregate' , 'orderBy' , 'lists' ] ) ) { return $ this -> metaJoinQuery ( $ query , $ method , $ args ) ; } return $ this -> metaHasQuery ( $ query , $ method , $ args ) ; }
10916	private function logScriptOutput ( ) { $ output_buffers = array ( ) ; $ ob_cnt = 0 ; while ( ob_get_level ( ) > $ this -> output_buffer_level ) { $ output = trim ( ob_get_contents ( ) ) ; ++ $ ob_cnt ; ob_end_clean ( ) ; if ( ! empty ( $ output ) ) { $ lines = explode ( "\n" , $ output ) ; foreach ( $ lines as $ n => $ line ) self :: $ logger -> debug ( "Script output: {0}/{1}: {2}" , [ $ ob_cnt , $ n + 1 , $ line ] ) ; } } }
11059	public static function files ( $ path , array $ extensions = array ( ) ) { $ files = array ( ) ; $ it = new \ RecursiveDirectoryIterator ( $ path ) ; $ filter = false ; if ( ! empty ( $ extensions ) && is_array ( $ extensions ) ) { $ filter = true ; } foreach ( new \ RecursiveIteratorIterator ( $ it ) as $ file ) { if ( $ filter ) { $ f = explode ( '.' , $ file ) ; $ ext = strtolower ( array_pop ( $ f ) ) ; if ( in_array ( $ ext , $ extensions ) ) { $ files [ ] = $ file ; } } else { $ files [ ] = $ file ; } } return $ files ; }
10721	public function getLabel ( ) { $ label = $ this -> label ; $ title = $ this -> title ; if ( $ label ) { return $ label ; } else { return $ title ; } }
2031	public static function findParentsById ( $ intId ) { $ arrModels = array ( ) ; while ( $ intId > 0 && ( $ objPage = static :: findByPk ( $ intId ) ) !== null ) { $ intId = $ objPage -> pid ; $ arrModels [ ] = $ objPage ; } if ( empty ( $ arrModels ) ) { return null ; } return static :: createCollection ( $ arrModels , 'tl_page' ) ; }
3227	function buildUrlForGetOrPut ( $ host , $ path , $ params = null ) { return RequestUtil :: buildUrlForGetOrPut ( $ this -> userLocale , $ host , $ path , $ params ) ; }
7328	private function configureVatNumberSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Pricing \ Model \ VatNumberSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> vatNumberSubjectClassCache ) ) { return ; } $ this -> addMappings ( $ metadata , $ this -> getVatNumberSubjectMappings ( ) ) ; $ this -> vatNumberSubjectClassCache [ ] = $ class ; }
10485	protected function getTableMapping ( $ table ) { if ( array_key_exists ( $ table , $ this -> mappings ) ) { return $ this -> mappings [ $ table ] ; } $ mapping = $ this -> retrieveMapping ( $ table ) ; if ( empty ( $ mapping ) ) { throw new \ UnderflowException ( "Table with name {$table} not found." ) ; } $ this -> mappings [ $ table ] = $ mapping ; return $ mapping ; }
12279	public function moveUsers ( array $ openIds , $ groupId ) { $ params = [ 'openid_list' => $ openIds , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_UPDATE , $ params ] ) ; }
6705	public function getWriterFactory ( ) { if ( ! $ this -> writerFactory ) { $ xmlFormatter = new Xml ( ) ; $ jsonFormatter = new Json ( ) ; $ this -> writerFactory = new WriterFactory ( [ 'xml' => $ xmlFormatter , 'text/xml' => $ xmlFormatter , 'application/xml' => $ xmlFormatter , 'json' => $ jsonFormatter , 'application/json' => $ jsonFormatter , ] ) ; } return $ this -> writerFactory ; }
8080	public function & getReports ( $ channel = null ) { $ channel = $ this -> namespaceChannel ( $ channel ) ; if ( ! isset ( $ this -> console [ 'reports' ] [ $ channel ] ) ) { $ this -> console [ 'reports' ] [ $ channel ] = array ( ) ; } return $ this -> console [ 'reports' ] [ $ channel ] ; }
4535	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Tenantable ) { return ; } if ( null !== $ entity -> getTenant ( ) ) { return ; } $ tenant = $ this -> container -> get ( TenantService :: class ) -> getContext ( ) ; $ entity -> setTenant ( $ tenant ) ; }
5459	protected function acceptTag ( $ tag ) { if ( $ tag -> getTagName ( ) === 'a' ) { $ this -> page -> addLink ( $ tag ) ; } elseif ( $ tag -> getTagName ( ) === 'base' ) { $ this -> page -> setBase ( $ tag -> getAttribute ( 'href' ) ) ; } elseif ( $ tag -> getTagName ( ) === 'title' ) { $ this -> page -> setTitle ( $ tag ) ; } elseif ( $ this -> isFormElement ( $ tag -> getTagName ( ) ) ) { for ( $ i = 0 ; $ i < count ( $ this -> open_forms ) ; $ i ++ ) { $ this -> open_forms [ $ i ] -> addWidget ( $ tag ) ; } $ this -> last_widget = $ tag ; } }
729	protected function addDefaultPrimaryKey ( & $ fields ) { foreach ( $ fields as $ field ) { if ( false !== strripos ( $ field [ 'decorators' ] , 'primarykey()' ) ) { return ; } } array_unshift ( $ fields , [ 'property' => 'id' , 'decorators' => 'primaryKey()' ] ) ; }
7378	public function fetchBool ( string $ key , bool $ default = false ) : bool { return $ this -> fetchFilter ( $ key , $ default , FILTER_VALIDATE_BOOLEAN ) ; }
5720	public function doSaveAndNext ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; $ link = $ this -> getEditLink ( $ this -> getNextRecordID ( ) ) ; return $ this -> saveAndRedirect ( $ data , $ form , $ link ) ; }
3063	protected function saveAdaptiveResults ( CatSession $ catSession ) { $ testResult = $ catSession -> getTestResult ( ) ; $ testResult = empty ( $ testResult ) ? [ ] : [ $ testResult ] ; return $ this -> storeResult ( array_merge ( $ testResult , $ catSession -> getItemResults ( ) ) ) ; }
3377	public function postRemind ( ) { \ App :: make ( 'route' ) ; \ Config :: set ( 'auth.defaults.passwords' , 'panel' ) ; $ response = \ Password :: sendResetLink ( Input :: only ( 'email' ) , function ( $ message ) { $ message -> subject ( 'Password Reminder' ) ; } ) ; switch ( $ response ) { case PasswordBrokerContract :: INVALID_USER : return \ Redirect :: back ( ) -> with ( 'message' , \ Lang :: get ( $ response ) ) -> with ( 'mesType' , 'error' ) ; case PasswordBrokerContract :: RESET_LINK_SENT : return \ Redirect :: back ( ) -> with ( 'message' , \ Lang :: get ( $ response ) ) -> with ( 'mesType' , 'info' ) ; } }
6326	public static function getClassNameWithoutNamespace ( $ object ) { $ className = get_class ( $ object ) ; if ( preg_match ( '@\\\\([\w]+)$@' , $ className , $ matches ) ) { $ className = $ matches [ 1 ] ; } return $ className ; }
3546	public function create ( $ request ) { $ data = $ request -> all ( ) ; $ user = $ this -> repository -> create ( $ data ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ user ) ) ; return $ user ; }
4122	private function getProxyFileName ( $ className , $ baseDir = null ) { $ proxyDir = $ baseDir ? : $ this -> proxyDir ; return $ proxyDir . DIRECTORY_SEPARATOR . '__CG__' . str_replace ( '\\' , '' , $ className ) . '.php' ; }
12813	private static function getNullables ( string $ table ) : array { if ( self :: $ nullablesCache !== null && array_key_exists ( $ table , self :: $ nullablesCache ) ) return self :: $ nullablesCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT column_name, data_type, is_nullable, column_default FROM information_schema.columns WHERE table_name = '$table' AND is_nullable = 'YES' " ; self :: $ nullablesCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ nullablesCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ nullablesCache [ $ table ] ; }
667	public static function startsWith ( $ string , $ with , $ caseSensitive = true ) { if ( ! $ bytes = static :: byteLength ( $ with ) ) { return true ; } if ( $ caseSensitive ) { return strncmp ( $ string , $ with , $ bytes ) === 0 ; } $ encoding = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; return mb_strtolower ( mb_substr ( $ string , 0 , $ bytes , '8bit' ) , $ encoding ) === mb_strtolower ( $ with , $ encoding ) ; }
8908	public function created_at ( $ row ) { if ( is_object ( $ row ) ) { $ row -> { $ this -> created_at_key } = date ( 'Y-m-d H:i:s' ) ; } else { $ row [ $ this -> created_at_key ] = date ( 'Y-m-d H:i:s' ) ; } return $ row ; }
3479	public function withActionLocalized ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> actionLocalized = $ localized ; return $ cloned ; }
10516	protected function createPhotosCollection ( Product $ product , $ values ) { $ photos = new ArrayCollection ( ) ; $ identifiers = $ this -> getMediaIdentifiers ( $ values ) ; $ hierarchy = 0 ; foreach ( $ identifiers as $ id ) { $ media = $ this -> getMediaById ( $ id ) ; $ photo = $ this -> getProductPhoto ( $ media , $ product , $ values ) ; $ photo -> setHierarchy ( $ hierarchy ++ ) ; if ( ! $ photos -> contains ( $ photo ) ) { $ photos -> add ( $ photo ) ; } } return $ photos ; }
521	protected function migrateDown ( $ class ) { if ( $ class === self :: BASE_MIGRATION ) { return true ; } $ this -> stdout ( "*** reverting $class\n" , Console :: FG_YELLOW ) ; $ start = microtime ( true ) ; $ migration = $ this -> createMigration ( $ class ) ; if ( $ migration -> down ( ) !== false ) { $ this -> removeMigrationHistory ( $ class ) ; $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** reverted $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_GREEN ) ; return true ; } $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** failed to revert $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_RED ) ; return false ; }
5470	protected function describePatternMatch ( $ pattern , $ subject ) { preg_match ( $ pattern , $ subject , $ matches ) ; $ position = strpos ( $ subject , $ matches [ 0 ] ) ; $ dumper = $ this -> getDumper ( ) ; return "Pattern [$pattern] detected at character [$position] in [" . $ dumper -> describeValue ( $ subject ) . '] as [' . $ matches [ 0 ] . '] in region [' . $ dumper -> clipString ( $ subject , 100 , $ position ) . ']' ; }
9467	protected function initializer ( string $ key , array $ storage ) : void { $ this -> _name = $ key ; $ this -> attached ( $ storage ) ; }
10278	public function write ( Spreadsheet $ spreadsheet = null ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-styles' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:style' , 'urn:oasis:names:tc:opendocument:xmlns:style:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:text' , 'urn:oasis:names:tc:opendocument:xmlns:text:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:table' , 'urn:oasis:names:tc:opendocument:xmlns:table:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:draw' , 'urn:oasis:names:tc:opendocument:xmlns:drawing:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:fo' , 'urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:dc' , 'http://purl.org/dc/elements/1.1/' ) ; $ objWriter -> writeAttribute ( 'xmlns:meta' , 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:number' , 'urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:presentation' , 'urn:oasis:names:tc:opendocument:xmlns:presentation:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:svg' , 'urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:chart' , 'urn:oasis:names:tc:opendocument:xmlns:chart:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:dr3d' , 'urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:math' , 'http://www.w3.org/1998/Math/MathML' ) ; $ objWriter -> writeAttribute ( 'xmlns:form' , 'urn:oasis:names:tc:opendocument:xmlns:form:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:script' , 'urn:oasis:names:tc:opendocument:xmlns:script:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooow' , 'http://openoffice.org/2004/writer' ) ; $ objWriter -> writeAttribute ( 'xmlns:oooc' , 'http://openoffice.org/2004/calc' ) ; $ objWriter -> writeAttribute ( 'xmlns:dom' , 'http://www.w3.org/2001/xml-events' ) ; $ objWriter -> writeAttribute ( 'xmlns:rpt' , 'http://openoffice.org/2005/report' ) ; $ objWriter -> writeAttribute ( 'xmlns:of' , 'urn:oasis:names:tc:opendocument:xmlns:of:1.2' ) ; $ objWriter -> writeAttribute ( 'xmlns:xhtml' , 'http://www.w3.org/1999/xhtml' ) ; $ objWriter -> writeAttribute ( 'xmlns:grddl' , 'http://www.w3.org/2003/g/data-view#' ) ; $ objWriter -> writeAttribute ( 'xmlns:tableooo' , 'http://openoffice.org/2009/table' ) ; $ objWriter -> writeAttribute ( 'xmlns:css3t' , 'http://www.w3.org/TR/css3-text/' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> writeElement ( 'office:font-face-decls' ) ; $ objWriter -> writeElement ( 'office:styles' ) ; $ objWriter -> writeElement ( 'office:automatic-styles' ) ; $ objWriter -> writeElement ( 'office:master-styles' ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
10098	public function setOutline ( $ visible = true , $ symbols_below = true , $ symbols_right = true , $ auto_style = false ) { $ this -> outlineOn = $ visible ; $ this -> outlineBelow = $ symbols_below ; $ this -> outlineRight = $ symbols_right ; $ this -> outlineStyle = $ auto_style ; if ( $ this -> outlineOn ) { $ this -> outlineOn = 1 ; } }
8142	public function clearCacheFiles ( ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( is_string ( $ this -> originalCache ) ) { foreach ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ this -> originalCache ) , RecursiveIteratorIterator :: LEAVES_ONLY ) as $ file ) { if ( $ file -> isFile ( ) ) { @ unlink ( $ file -> getPathname ( ) ) ; } } } }
10205	public function setIndent ( $ pValue ) { if ( $ pValue > 0 ) { if ( $ this -> getHorizontal ( ) != self :: HORIZONTAL_GENERAL && $ this -> getHorizontal ( ) != self :: HORIZONTAL_LEFT && $ this -> getHorizontal ( ) != self :: HORIZONTAL_RIGHT ) { $ pValue = 0 ; } } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'indent' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> indent = $ pValue ; } return $ this ; }
5130	protected function withString ( string $ string , string $ name = 'query' ) : self { $ string = ltrim ( ( string ) $ string , '#' ) ; $ clone = clone $ this ; $ clone -> { $ name } = $ this -> filterQuery ( $ string ) ; return $ clone ; }
8338	public function returning ( $ returning ) { if ( is_array ( $ returning ) === true ) { $ this -> returning = implode ( ', ' , $ returning ) ; } else { $ this -> returning = $ returning ; } return $ this ; }
9736	public function setWorksheet ( Worksheet $ pValue = null , $ pOverrideOld = false ) { if ( $ this -> worksheet === null ) { $ this -> worksheet = $ pValue ; $ this -> worksheet -> getCell ( $ this -> coordinates ) ; $ this -> worksheet -> getDrawingCollection ( ) -> append ( $ this ) ; } else { if ( $ pOverrideOld ) { $ iterator = $ this -> worksheet -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { if ( $ iterator -> current ( ) -> getHashCode ( ) == $ this -> getHashCode ( ) ) { $ this -> worksheet -> getDrawingCollection ( ) -> offsetUnset ( $ iterator -> key ( ) ) ; $ this -> worksheet = null ; break ; } } $ this -> setWorksheet ( $ pValue ) ; } else { throw new PhpSpreadsheetException ( 'A Worksheet has already been assigned. Drawings can only exist on one \\PhpOffice\\PhpSpreadsheet\\Worksheet.' ) ; } } return $ this ; }
6508	public function doStop ( ) { if ( $ this -> controller -> doStop ( ) ) { $ this -> job -> setStatus ( Status :: CANCELLED ( ) ) ; return true ; } return false ; }
2160	public function run32Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_layout` CHANGE `sections` `sections` varchar(1022) NOT NULL default ''" ) ; $ objLayout = $ this -> Database -> query ( "SELECT id, sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ strSections = '' ; $ tmp = StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ tmp ) && \ is_array ( $ tmp ) ) { $ strSections = implode ( ', ' , $ tmp ) ; } $ this -> Database -> prepare ( "UPDATE tl_layout SET sections=? WHERE id=?" ) -> execute ( $ strSections , $ objLayout -> id ) ; } if ( ! $ this -> Database -> fieldExists ( 'uuid' , 'tl_files' ) ) { $ this -> Database -> query ( "ALTER TABLE `tl_files` ADD `uuid` binary(16) NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_files` ADD UNIQUE KEY `uuid` (`uuid`)" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_files` ADD `pid_backup` int(10) unsigned NOT NULL default 0" ) ; $ this -> Database -> query ( "UPDATE `tl_files` SET `pid_backup`=`pid`" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_files` CHANGE `pid` `pid` binary(16) NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_files` SET `pid`=NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_files` SET `pid`=NULL WHERE `pid_backup`=0" ) ; $ objFiles = $ this -> Database -> query ( "SELECT id FROM tl_files" ) ; while ( $ objFiles -> next ( ) ) { $ this -> Database -> prepare ( "UPDATE tl_files SET uuid=? WHERE id=?" ) -> execute ( $ this -> Database -> getUuid ( ) , $ objFiles -> id ) ; } $ objFiles = $ this -> Database -> query ( "SELECT pid_backup FROM tl_files WHERE pid_backup>0 GROUP BY pid_backup" ) ; while ( $ objFiles -> next ( ) ) { $ objParent = $ this -> Database -> prepare ( "SELECT uuid FROM tl_files WHERE id=?" ) -> execute ( $ objFiles -> pid_backup ) ; if ( $ objParent -> numRows < 1 ) { throw new \ Exception ( 'Invalid parent ID ' . $ objFiles -> pid_backup ) ; } $ this -> Database -> prepare ( "UPDATE tl_files SET pid=? WHERE pid_backup=?" ) -> execute ( $ objParent -> uuid , $ objFiles -> pid_backup ) ; } $ this -> Database -> query ( "ALTER TABLE `tl_files` DROP `pid_backup`" ) ; } $ this -> updateFileTreeFields ( ) ; }
1632	public function log ( $ level , $ message , array $ context = [ ] ) { parent :: log ( $ level , $ message , $ context ) ; $ this -> fireLogEvent ( $ level , $ message , $ context ) ; }
4500	public function matches ( string $ selectors ) : bool { $ matches = $ this -> getRootDocument ( ) -> querySelectorAll ( $ selectors ) ; $ i = $ matches -> length ; while ( -- $ i >= 0 && $ matches -> item ( $ i ) !== $ this ) { ; } return ( $ i >= 0 ) ; }
11150	protected function setCacheState ( $ useCache ) { if ( is_bool ( $ useCache ) ) { $ this -> useCache = $ useCache ; } else { $ this -> useCache = true ; } }
3677	private function fieldExists ( $ strTableName , $ strColumnName ) { $ columns = $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ strTableName ) ; return isset ( $ columns [ $ strColumnName ] ) ; }
6261	public function getActionMap ( ) { $ actionMap = ( array ) Configure :: read ( 'SimpleRbac.actionMap' ) ; if ( empty ( $ actionMap ) && $ this -> _config [ 'allowEmptyActionMap' ] === false ) { throw new \ RuntimeException ( 'SimpleRbac.actionMap configuration is empty!' ) ; } return $ actionMap ; }
9937	private static function checkSheetCodeName ( $ pValue ) { $ CharCount = Shared \ StringHelper :: countCharacters ( $ pValue ) ; if ( $ CharCount == 0 ) { throw new Exception ( 'Sheet code name cannot be empty.' ) ; } if ( ( str_replace ( self :: $ invalidCharacters , '' , $ pValue ) !== $ pValue ) || ( Shared \ StringHelper :: substring ( $ pValue , - 1 , 1 ) == '\'' ) || ( Shared \ StringHelper :: substring ( $ pValue , 0 , 1 ) == '\'' ) ) { throw new Exception ( 'Invalid character found in sheet code name' ) ; } if ( $ CharCount > 31 ) { throw new Exception ( 'Maximum 31 characters allowed in sheet code name.' ) ; } return $ pValue ; }
12575	public function previewByName ( $ msgType , $ message , $ to ) { return $ this -> preview ( $ msgType , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
7127	public function getDetails ( ) { return [ 'valid' => $ this -> valid , 'country' => $ this -> country , 'number' => $ this -> number , 'name' => $ this -> name , 'address' => $ this -> address , 'date' => $ this -> date , ] ; }
248	public function destroy ( ) { if ( $ this -> getIsActive ( ) ) { $ sessionId = session_id ( ) ; $ this -> close ( ) ; $ this -> setId ( $ sessionId ) ; $ this -> open ( ) ; session_unset ( ) ; session_destroy ( ) ; $ this -> setId ( $ sessionId ) ; } }
12386	public function parse ( ) { $ finder = new Finder ( ) ; $ pages = $ finder -> directories ( ) -> depth ( 0 ) -> sortByName ( ) -> in ( $ this -> pagesDir ) ; $ languages = $ this -> configurationHandler -> languages ( ) ; $ homepage = $ this -> configurationHandler -> homepage ( ) ; foreach ( $ pages as $ page ) { $ pageDir = ( string ) $ page ; $ pageName = basename ( $ pageDir ) ; $ pageDefinitionFile = $ pageDir . '/' . $ this -> pageFile ; if ( ! file_exists ( $ pageDefinitionFile ) ) { continue ; } $ seoDefinition = $ this -> fetchSeoDefinition ( $ this -> pagesDir . '/' . $ pageName , $ this -> seoFile , $ languages ) ; $ pageDefinition = json_decode ( file_get_contents ( $ pageDefinitionFile ) , true ) ; $ pageDefinition [ "seo" ] = $ seoDefinition ; $ pageDefinition [ "isHome" ] = $ homepage == $ pageName ; $ this -> pages [ $ pageName ] = $ pageDefinition ; } return $ this ; }
11050	function protect_spaces ( $ data ) { $ data = str_replace ( "\n" , "\1n\1" , $ data ) ; $ data = str_replace ( "\r" , "\1r\1" , $ data ) ; $ data = str_replace ( "\t" , "\1t\1" , $ data ) ; return str_replace ( " " , "\1s\1" , $ data ) ; }
775	public function resetSequence ( $ tableName , $ value = null ) { $ table = $ this -> db -> getTableSchema ( $ tableName ) ; if ( $ table !== null && $ table -> sequenceName !== null ) { $ tableName = $ this -> db -> quoteTableName ( $ tableName ) ; if ( $ value === null ) { $ key = reset ( $ table -> primaryKey ) ; $ value = $ this -> db -> createCommand ( "SELECT MAX(`$key`) FROM $tableName" ) -> queryScalar ( ) + 1 ; } else { $ value = ( int ) $ value ; } return "ALTER TABLE $tableName AUTO_INCREMENT=$value" ; } elseif ( $ table === null ) { throw new InvalidArgumentException ( "Table not found: $tableName" ) ; } throw new InvalidArgumentException ( "There is no sequence associated with table '$tableName'." ) ; }
12339	private function getColoredMsg ( string $ msg , ? string $ fontColor , ? string $ bgColor ) : string { $ res = '' ; if ( ! is_null ( $ fontColor ) ) { $ res .= "\033[{$fontColor}m" ; } if ( ! is_null ( $ bgColor ) ) { $ res .= "\033[{$bgColor}m" ; } if ( ! is_null ( $ fontColor ) || ! is_null ( $ bgColor ) ) { return "{$res}{$msg}\033[0m" ; } return $ msg ; }
9255	public function getRootDir ( ) { if ( ! $ this -> rootDir ) { $ refl = new \ ReflectionObject ( $ this ) ; $ filename = $ refl -> getFileName ( ) ; if ( false !== ( $ pos = strrpos ( $ filename , '/vendor/' ) ) ) { $ filename = substr ( $ filename , 0 , $ pos ) ; } else { $ filename = dirname ( $ filename ) . '/..' ; } $ this -> rootDir = str_replace ( '\\' , '/' , $ filename ) ; } return $ this -> rootDir ; }
2620	public function sendInstalledReq ( ) { $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . self :: FASTLY_INSTALLED_FLAG , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . self :: FASTLY_INSTALLED_FLAG , 'dt' => ucfirst ( self :: FASTLY_INSTALLED_FLAG ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams , self :: GA_HITTYPE_PAGEVIEW ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . self :: FASTLY_INSTALLED_FLAG , 'el' => $ this -> getWebsiteName ( ) , 'ev' => 0 , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
5613	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , false ) ; $ current = $ this -> _stack -> peek ( ) ; $ current -> putChild ( $ node ) ; $ current -> fail ( ) ; }
1876	public function create ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCreatable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not creatable.' ) ; } $ this -> import ( Files :: class , 'Files' ) ; $ strFolder = Input :: get ( 'pid' , true ) ; if ( $ strFolder == '' || ! file_exists ( $ this -> strRootDir . '/' . $ strFolder ) || ! $ this -> isMounted ( $ strFolder ) ) { throw new AccessDeniedException ( 'Folder "' . $ strFolder . '" is not mounted or is not a directory.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; $ arrClipboard [ $ this -> strTable ] = array ( ) ; $ objSession -> set ( 'CLIPBOARD' , $ arrClipboard ) ; $ this -> Files -> mkdir ( $ strFolder . '/__new__' ) ; $ this -> redirect ( html_entity_decode ( $ this -> switchToEdit ( $ strFolder . '/__new__' ) ) ) ; }
7570	public function getApplicationApiService ( ) { $ applicationService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ ApplicationService ( $ this -> _apiKey , $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: APPLICATION_URL ) ) ; $ applicationService -> setClient ( $ apiClient ) ; return $ applicationService ; }
12190	public function getActive ( ) { return ( isset ( $ this -> _child ) and $ this -> _child -> active ) and ( isset ( $ this -> _parent ) and $ this -> _parent -> active ) ; }
11319	function query ( $ sql , $ params = array ( ) ) { $ db = Neuron_DB_Database :: getInstance ( ) ; $ sql = $ this -> printf ( $ sql , $ params ) ; if ( $ this -> debug ) { echo $ sql . "<br><br>" ; } try { $ data = $ db -> query ( $ sql ) ; if ( $ this -> debug ) { echo '<pre>' ; var_dump ( $ data ) ; echo "</pre><br><br>" ; } $ this -> error = false ; return $ data ; } catch ( Exception $ e ) { $ this -> error = true ; echo 'error' ; } }
3612	public function setTargetTemperatureMode ( $ mode , $ temperature = NULL , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; if ( $ temperature !== NULL ) { if ( $ mode == TARGET_TEMP_MODE_RANGE ) { if ( ! is_array ( $ temperature ) || count ( $ temperature ) != 2 || ! is_numeric ( $ temperature [ 0 ] ) || ! is_numeric ( $ temperature [ 1 ] ) ) { echo "Error: when using TARGET_TEMP_MODE_RANGE, you need to set the target temperatures (second argument of setTargetTemperatureMode) using an array of two numeric values.\n" ; return FALSE ; } $ temp_low = $ this -> temperatureInCelsius ( $ temperature [ 0 ] , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temperature [ 1 ] , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } elseif ( $ mode != TARGET_TEMP_MODE_OFF ) { if ( ! is_numeric ( $ temperature ) ) { echo "Error: when using TARGET_TEMP_MODE_HEAT or TARGET_TEMP_MODE_COLD, you need to set the target temperature (second argument of setTargetTemperatureMode) using an numeric value.\n" ; return FALSE ; } $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } } $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_type' => $ mode ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
6079	public function combineSlides ( array $ structure ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'structure' => $ structure ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/slides/combine' , $ parameters ) ; return $ result ; }
1397	public function deleted ( $ resource = null , array $ links = [ ] , $ meta = null , array $ headers = [ ] ) { return $ this -> getResourceResponse ( $ resource , $ links , $ meta , $ headers ) ; }
8039	public function buildEventData ( array $ data ) { $ start = strtotime ( $ data [ 'start' ] [ 'date' ] . ' ' . $ data [ 'start' ] [ 'time' ] ) ; $ start = date ( 'Y-m-d H:i:s' , $ start ) ; $ end = null ; if ( array_key_exists ( 'end' , $ data ) ) { $ end = strtotime ( $ data [ 'end' ] [ 'date' ] . ' ' . $ data [ 'end' ] [ 'time' ] ) ; $ end = date ( 'Y-m-d H:i:s' , $ end ) ; if ( strtotime ( $ end ) < strtotime ( $ start ) ) { throw new DateDifferenceException ( 'Start date bigger then end date!' ) ; } } $ event = [ 'title' => $ data [ 'title' ] , 'description' => $ data [ 'description' ] , 'start' => $ start , 'end' => $ end , 'all_day' => array_key_exists ( 'all_day' , $ data ) , 'border_color' => $ data [ 'border_color' ] , 'background_color' => $ data [ 'background_color' ] , 'text_color' => $ data [ 'text_color' ] , ] ; return $ event ; }
5978	public function objecttypes ( ) { if ( ! $ this -> objecttypes instanceof ObjecttypesController ) { $ this -> objecttypes = new ObjecttypesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> objecttypes -> setLogger ( $ this -> logger ) ; } return $ this -> objecttypes ; }
12012	private function addDoctrineSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> children ( ) -> arrayNode ( 'doctrine' ) -> info ( 'doctrine configuration' ) -> canBeEnabled ( ) -> children ( ) -> booleanNode ( 'enabled' ) -> defaultTrue ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; }
1436	public static function camelize ( $ value ) { if ( isset ( self :: $ camelized [ $ value ] ) ) { return self :: $ camelized [ $ value ] ; } return self :: $ camelized [ $ value ] = lcfirst ( self :: classify ( $ value ) ) ; }
4878	public function setUser ( UserInterface $ user ) { if ( $ this -> user ) { $ this -> getPermissions ( ) -> revoke ( $ this -> user , Permissions :: PERMISSION_ALL , false ) ; } $ this -> user = $ user ; $ this -> getPermissions ( ) -> grant ( $ user , Permissions :: PERMISSION_ALL ) ; return $ this ; }
12135	public function show ( QuestionRequest $ request , Question $ question ) { if ( $ question -> exists ) { $ view = 'forum::question.show' ; } else { $ view = 'forum::question.new' ; } return $ this -> response -> title ( trans ( 'app.view' ) . ' ' . trans ( 'forum::question.name' ) ) -> data ( compact ( 'question' ) ) -> view ( $ view , true ) -> output ( ) ; }
12980	protected function configureBehavior ( $ behavior , EventSubscriber $ es ) { switch ( $ behavior ) { case 'translatable' : $ es -> setTranslatableLocale ( \ Config :: get ( 'language' , 'en' ) ) ; $ es -> setDefaultLocale ( \ Config :: get ( 'language_fallback' , 'en' ) ) ; break ; } }
6612	public static function getDropdownMap ( $ keyAttribute , $ valueAttribute , array $ default = [ ] ) { $ map = ArrayHelper :: map ( self :: getActive ( ) , $ keyAttribute , $ valueAttribute ) ; if ( $ default ) { $ map = array_merge ( $ default , $ map ) ; } return $ map ; }
10353	private function fireEventOn ( $ action , $ payload ) { $ event = $ this -> getEventName ( ) ; $ this -> dispatcher -> fire ( "auth.{$event}.{$action}" , $ payload ) ; }
3123	protected function computeRange ( $ range ) { if ( count ( $ range ) % 2 ) { throw new IncompleteRangeException ( ) ; } $ duration = 0 ; $ start = null ; $ end = null ; foreach ( $ range as $ point ) { if ( $ this -> isStartPoint ( $ point ) ) { if ( $ start ) { throw new MalformedRangeException ( 'A time range must be defined by a START and a END TimePoint! Twice START found.' ) ; } $ start = $ point ; } if ( $ this -> isEndPoint ( $ point ) ) { if ( $ end ) { throw new MalformedRangeException ( 'A time range must be defined by a START and a END TimePoint! Twice END found.' ) ; } $ end = $ point ; } if ( $ start && $ end ) { $ duration += $ this -> getRangeDuration ( $ start , $ end ) ; $ start = null ; $ end = null ; } } return $ duration ; }
5119	private function assessOptions ( array $ options ) : void { $ defaultOptions = [ 'rest_server' => self :: REST_SERVER , 'auth_url' => self :: AUTHENTICATION , 'max_attempt' => self :: DEFAULT_MAX_ATTEMPT , 'default_headers' => [ 'Accept' => 'application/json' , ] , ] ; $ this -> options = new Collection ( array_merge ( $ defaultOptions , $ options ) ) ; if ( isset ( $ options [ 'access_token' ] ) ) { $ this -> setAuthorizationHeader ( $ options [ 'access_token' ] ) ; } if ( isset ( $ options [ 'recycle_token' ] ) && is_callable ( $ options [ 'recycle_token' ] ) ) { $ this -> recycleToken ( $ options [ 'recycle_token' ] ) ; } if ( isset ( $ options [ 'token_saver' ] ) && is_callable ( $ options [ 'token_saver' ] ) ) { $ this -> setTokenSaver ( $ options [ 'token_saver' ] ) ; } $ this -> httpClient = new Client ( [ 'base_uri' => $ this -> options -> get ( 'rest_server' ) , ] ) ; }
8606	public function listSubscriptions ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_ListSubscriptionsInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListSubscriptionsInput.php' ) ; $ request = new MWSSubscriptionsService_Model_ListSubscriptionsInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListSubscriptions' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListSubscriptionsResponse.php' ) ; $ response = MWSSubscriptionsService_Model_ListSubscriptionsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1474	public function createResourceValidator ( ResourceObject $ resource , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ resource -> all ( ) , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) use ( $ resource ) { return $ this -> invalidResource ( $ resource -> pointer ( $ key , '/data' ) , $ detail , $ failed ) ; } ) ; }
2168	protected function createContentElement ( Result $ objElement , $ strPtable , $ strField ) { $ set = array ( 'pid' => $ objElement -> id , 'ptable' => $ strPtable , 'sorting' => 128 , 'tstamp' => $ objElement -> tstamp , 'type' => 'text' , 'text' => $ objElement -> $ strField , 'addImage' => $ objElement -> addImage , 'singleSRC' => $ objElement -> singleSRC , 'alt' => $ objElement -> alt , 'size' => $ objElement -> size , 'imagemargin' => $ objElement -> imagemargin , 'imageUrl' => $ objElement -> imageUrl , 'fullsize' => $ objElement -> fullsize , 'caption' => $ objElement -> caption , 'floating' => $ objElement -> floating ) ; $ this -> Database -> prepare ( "INSERT INTO tl_content %s" ) -> set ( $ set ) -> execute ( ) ; }
9654	public function getForPath ( $ path ) { $ extension = $ this -> getExtension ( $ path ) ; if ( ! isset ( $ this -> loaders [ $ extension ] ) ) { $ this -> resolveLoader ( $ extension ) ; } return $ this -> loaders [ $ extension ] ; }
51	public function addRepository ( RepositoryInterface $ repository ) { if ( $ repository instanceof self ) { foreach ( $ repository -> getRepositories ( ) as $ repo ) { $ this -> addRepository ( $ repo ) ; } } else { $ this -> repositories [ ] = $ repository ; } }
7719	function meth_Conv_Str ( & $ Txt , $ ConvBr = true ) { if ( $ this -> Charset === '' ) { $ Txt = htmlspecialchars ( $ Txt ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } elseif ( $ this -> _CharsetFct ) { $ Txt = call_user_func ( $ this -> Charset , $ Txt , $ ConvBr ) ; } else { $ Txt = htmlspecialchars ( $ Txt , ENT_COMPAT , $ this -> Charset ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } }
8067	public function run ( $ input ) { while ( $ this -> workerPoolSize > 0 ) { try { $ processDetailsOfFreeWorker = $ this -> getNextFreeWorker ( ) ; $ processDetailsOfFreeWorker -> getSocket ( ) -> send ( array ( 'cmd' => 'run' , 'data' => $ input ) ) ; return $ processDetailsOfFreeWorker -> getPid ( ) ; } catch ( \ Exception $ e ) { pcntl_signal_dispatch ( ) ; } } throw new WorkerPoolException ( 'Unable to run the task.' ) ; }
4266	public static function register ( $ pathsExclude = array ( ) ) { $ result = \ stream_wrapper_unregister ( static :: PROTOCOL ) ; if ( $ result === false ) { throw new \ UnexpectedValueException ( 'Failed to unregister' ) ; } if ( $ pathsExclude ) { self :: $ pathsExclude = $ pathsExclude ; } \ stream_wrapper_register ( static :: PROTOCOL , \ get_called_class ( ) ) ; \ ini_set ( 'opcache.enable' , 0 ) ; }
4901	public static function loadConfig ( $ configuration = [ ] ) { $ configDir = static :: getConfigDir ( ) ; if ( empty ( $ configuration ) ) { $ configFile = $ configDir . '/config.php' ; if ( ! is_file ( $ configFile ) ) { throw new InvalidArgumentException ( sprintf ( 'Can not load config file "%s". Please be sure that this file exists and readable' , $ configFile ) ) ; } $ configuration = include $ configFile ; } $ isCli = php_sapi_name ( ) === 'cli' ; $ modules = $ configuration [ 'modules' ] ; $ modules = static :: generateModuleConfiguration ( $ modules ) ; $ yawikConfig = $ configDir . '/autoload/yawik.config.global.php' ; $ installMode = false ; if ( ! $ isCli && ! file_exists ( $ yawikConfig ) ) { $ modules = static :: generateModuleConfiguration ( [ 'Install' ] ) ; $ installMode = true ; } elseif ( in_array ( 'Install' , $ modules ) ) { $ modules = array_diff ( $ modules , [ 'Install' ] ) ; } static :: $ env = $ env = getenv ( 'APPLICATION_ENV' ) ? : 'production' ; $ defaults = [ 'module_listener_options' => [ 'module_paths' => [ './module' , './vendor' , './modules' ] , 'config_glob_paths' => [ sprintf ( $ configDir . '/autoload/{,*.}{global,%s,local}.php' , $ env ) ] , 'config_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_key' => 'module_map' , 'check_dependencies' => ( $ env != 'production' ) , 'cache_dir' => getcwd ( ) . "/var/cache" , ] , ] ; $ envConfig = [ ] ; $ envConfigFile = $ configDir . '/config.' . $ env . '.php' ; if ( file_exists ( $ envConfigFile ) ) { if ( is_readable ( $ envConfigFile ) ) { $ envConfig = include $ envConfigFile ; } else { \ trigger_error ( sprintf ( 'Environment config file "%s" is not readable.' , $ envConfigFile ) , E_USER_NOTICE ) ; } } $ configuration = ArrayUtils :: merge ( $ defaults , $ configuration ) ; $ configuration = ArrayUtils :: merge ( $ configuration , $ envConfig ) ; $ configuration [ 'modules' ] = $ modules ; if ( $ installMode ) { $ configuration [ 'module_listener_options' ] [ 'config_cache_enabled' ] = false ; $ configuration [ 'module_listener_options' ] [ 'module_map_cache_enabled' ] = false ; } if ( getenv ( 'DOCKER_ENV' ) == 'yes' ) { $ configuration = ArrayUtils :: merge ( $ configuration , static :: getDockerEnv ( $ configuration ) ) ; } return $ configuration ; }
12237	public function setAttributes ( array $ attr , $ ns = null ) { $ dom = dom_import_simplexml ( $ this ) ; foreach ( $ attr as $ k => $ v ) { $ dom -> setAttributeNS ( $ ns , $ k , $ v ) ; } return $ this ; }
11238	public function getRedirect ( $ url = null ) { if ( $ url ) { if ( is_numeric ( $ url ) ) { $ steps = $ url ; $ offset = count ( $ _SESSION [ 'redirect' ] [ 'history' ] ) + $ steps ; if ( isset ( $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ) ) { $ redirect = $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ; if ( ! empty ( $ redirect ) ) { return $ redirect ; } else { return BASE_URL ; } } else { return $ this -> config [ 'site_url' ] ; } } else { if ( substr ( $ url , 0 , 1 ) == '/' ) { return $ this -> config [ 'site_url' ] . substr ( $ url , 1 ) ; } else { return $ url ; } } } else { return $ this -> config [ 'site_url' ] ; } }
11105	public function join ( $ table , $ type = null ) { $ this -> join -> addJoin ( $ table , $ type ) ; return $ this ; }
11258	private function invoker ( ContainerInterface $ container ) { $ resolvers = new ResolverChain ( [ new ParameterNameContainerResolver ( $ container ) , new DefaultValueResolver ( ) , ] ) ; $ invoker = new Invoker ( $ resolvers , $ container ) ; return $ invoker ; }
8281	public function onTwigRegistered ( & $ twig ) { $ twig -> getLoader ( ) -> addPath ( $ this -> pluginDir . '/theme' ) ; $ this_instance = $ this ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_token' , function ( $ action = null ) use ( & $ this_instance ) { return $ this_instance -> csrf -> getToken ( $ action ) ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_field' , function ( $ action = null ) use ( & $ this_instance ) { return '<input type="hidden" name="csrf_token" value="' . $ this_instance -> csrf -> getToken ( $ action ) . '">' ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; }
5778	public function set ( string $ sql , array $ args ) { $ this -> sql = $ sql ; $ this -> args = $ args ; }
7531	function toString ( $ attributes = true , $ recursive = true , $ content_only = false ) { if ( $ content_only ) { if ( is_int ( $ content_only ) ) { -- $ content_only ; } return $ this -> toString_content ( $ attributes , $ recursive , $ content_only ) ; } $ s = '<' . $ this -> tag ; if ( $ attributes ) { $ s .= $ this -> toString_attributes ( ) ; } if ( $ this -> self_close ) { $ s .= $ this -> self_close_str . '>' ; } else { $ s .= '>' ; if ( $ recursive ) { $ s .= $ this -> toString_content ( $ attributes ) ; } $ s .= '</' . $ this -> tag . '>' ; } return $ s ; }
6585	protected function perform ( callable $ callback , ... $ params ) { $ result = $ callback ( $ this -> curl , ... $ params ) ; if ( curl_errno ( $ this -> curl ) !== CURLE_OK ) throw new CurlException ( $ this -> curl ) ; if ( $ result === false ) throw new CurlException ( "Unable to perform $callback - unknown error." ) ; return $ result ; }
4362	public static function ordUtf8 ( $ str , & $ offset = 0 , & $ char = null ) { $ code = \ ord ( $ str [ $ offset ] ) ; $ numBytes = 1 ; if ( $ code >= 0x80 ) { if ( $ code < 0xe0 ) { $ numBytes = 2 ; $ code -= 0xC0 ; } elseif ( $ code < 0xf0 ) { $ numBytes = 3 ; $ code -= 0xE0 ; } elseif ( $ code < 0xf8 ) { $ numBytes = 4 ; $ code -= 0xF0 ; } for ( $ i = 1 ; $ i < $ numBytes ; $ i ++ ) { $ code2 = \ ord ( $ str [ $ offset + $ i ] ) - 0x80 ; $ code = $ code * 64 + $ code2 ; } } $ char = \ substr ( $ str , $ offset , $ numBytes ) ; $ offset = $ offset + $ numBytes ; return $ code ; }
4095	protected function call ( $ url , $ method = "GET" , $ payload = null ) { $ conn = $ this -> ch ; $ protocol = "http" ; $ requestURL = $ protocol . "://" . $ this -> host . $ url ; curl_setopt ( $ conn , CURLOPT_URL , $ requestURL ) ; curl_setopt ( $ conn , CURLOPT_TIMEOUT , $ this -> timeout ) ; curl_setopt ( $ conn , CURLOPT_PORT , $ this -> port ) ; curl_setopt ( $ conn , CURLOPT_CUSTOMREQUEST , strtoupper ( $ method ) ) ; curl_setopt ( $ conn , CURLOPT_FORBID_REUSE , 0 ) ; $ headers = array ( ) ; $ headers [ ] = 'Accept: application/json' ; $ headers [ ] = 'Content-Type: application/json' ; curl_setopt ( $ conn , CURLOPT_HTTPHEADER , $ headers ) ; if ( is_array ( $ payload ) && count ( $ payload ) > 0 ) curl_setopt ( $ conn , CURLOPT_POSTFIELDS , json_encode ( $ payload ) ) ; else curl_setopt ( $ conn , CURLOPT_POSTFIELDS , $ payload ) ; ob_start ( ) ; curl_exec ( $ conn ) ; $ response = ob_get_clean ( ) ; if ( $ response !== false ) { $ data = json_decode ( $ response , true ) ; if ( ! $ data ) { $ data = array ( 'error' => $ response , "code" => curl_getinfo ( $ conn , CURLINFO_HTTP_CODE ) ) ; } } else { $ errno = curl_errno ( $ conn ) ; switch ( $ errno ) { case CURLE_UNSUPPORTED_PROTOCOL : $ error = "Unsupported protocol [$protocol]" ; break ; case CURLE_FAILED_INIT : $ error = "Internal cUrl error?" ; break ; case CURLE_URL_MALFORMAT : $ error = "Malformed URL [$requestURL] -d " . json_encode ( $ payload ) ; break ; case CURLE_COULDNT_RESOLVE_PROXY : $ error = "Couldnt resolve proxy" ; break ; case CURLE_COULDNT_RESOLVE_HOST : $ error = "Couldnt resolve host" ; break ; case CURLE_COULDNT_CONNECT : $ error = "Couldnt connect to host [{$this->host}], ElasticSearch down?" ; break ; case CURLE_OPERATION_TIMEDOUT : $ error = "Operation timed out on [$requestURL]" ; break ; default : $ error = "Unknown error" ; if ( $ errno == 0 ) { $ error .= ". Non-cUrl error" ; } else { $ errstr = curl_error ( $ conn ) ; $ error .= " ($errstr)" ; } break ; } $ exception = new HTTPException ( $ error ) ; $ exception -> payload = $ payload ; $ exception -> port = $ this -> port ; $ exception -> protocol = $ protocol ; $ exception -> host = $ this -> host ; $ exception -> method = $ method ; throw $ exception ; } return $ data ; }
12039	public function sendHeaders ( ) { if ( count ( $ this -> _headersRaw ) || count ( $ this -> _headers ) || ( 200 !== $ this -> _httpResponseCode ) ) { $ this -> canSendHeaders ( true ) ; } elseif ( 200 === $ this -> _httpResponseCode ) { return $ this ; } $ httpCodeSent = false ; foreach ( $ this -> _headersRaw as $ header ) { if ( ! $ httpCodeSent && $ this -> _httpResponseCode ) { header ( $ header , true , $ this -> _httpResponseCode ) ; $ httpCodeSent = true ; } else { header ( $ header ) ; } } foreach ( $ this -> _headers as $ header ) { header ( "{$header['name']}: {$header['value']}" , $ header [ 'replace' ] ) ; } if ( ! $ httpCodeSent ) { $ message = array_key_exists ( $ this -> _httpResponseCode , self :: $ _messages ) ? self :: $ _messages [ $ this -> _httpResponseCode ] : 'No Reason Phrase' ; header ( "HTTP/1.1 {$this->_httpResponseCode} {$message}" , true ) ; $ httpCodeSent = true ; } return $ this ; }
5674	protected function isMatchingKeys ( $ first , $ second , $ identical ) { $ first_keys = array_keys ( $ first ) ; $ second_keys = array_keys ( $ second ) ; if ( $ identical ) { return ( $ first_keys === $ second_keys ) ; } sort ( $ first_keys ) ; sort ( $ second_keys ) ; return ( $ first_keys == $ second_keys ) ; }
6177	protected function executeDelete ( ) { foreach ( $ this -> tableData as $ key => $ row ) { if ( $ this -> where && ! $ this -> where -> execute ( $ row ) ) { continue ; } unset ( $ this -> tableData [ $ key ] ) ; } $ this -> tableData = array_values ( $ this -> tableData ) ; }
367	public function renderFilters ( ) { if ( $ this -> filterModel !== null ) { $ cells = [ ] ; foreach ( $ this -> columns as $ column ) { $ cells [ ] = $ column -> renderFilterCell ( ) ; } return Html :: tag ( 'tr' , implode ( '' , $ cells ) , $ this -> filterRowOptions ) ; } return '' ; }
11031	protected function ensureFieldIds ( ) { if ( $ this -> submitModelName ) { $ formName = Inflector :: slug ( $ this -> submitModelName , '_' ) ; } else { $ model = new \ ReflectionClass ( $ this -> model ) ; $ formName = $ model -> getShortName ( ) ; } $ parts = [ ] ; preg_match_all ( '/{([^}]+)}/' , $ this -> template , $ parts ) ; $ keys = array_flip ( $ parts [ 1 ] ) ; $ fieldIds = [ ] ; if ( isset ( $ keys [ 'country' ] ) ) { $ fieldIds [ 'country' ] = $ formName . '_country_id' ; } if ( isset ( $ keys [ 'state' ] ) ) { $ fieldIds [ 'state' ] = $ formName . '_state_id' ; } if ( isset ( $ keys [ 'region' ] ) ) { $ fieldIds [ 'region' ] = $ formName . '_region_id' ; } if ( isset ( $ keys [ 'city' ] ) ) { $ fieldIds [ 'city' ] = $ formName . '_city_id' ; } if ( isset ( $ keys [ 'address' ] ) ) { $ fieldIds [ 'address' ] = $ formName . '_address' ; } if ( isset ( $ keys [ 'postalCode' ] ) ) { $ fieldIds [ 'postal_code' ] = $ formName . '_postal_code' ; } if ( isset ( $ keys [ 'geolocation' ] ) ) { $ fieldIds [ 'latitude' ] = $ formName . '_latitude' ; $ fieldIds [ 'longitude' ] = $ formName . '_longitude' ; } $ this -> fieldIds = $ fieldIds ; }
8163	static public function register ( ) { if ( static :: $ registered === true ) { return true ; } $ kirby = kirby ( ) ; if ( ! class_exists ( 'Kirby\Component\Template' ) ) { throw new Exception ( 'The Kirby Twig plugin requires Kirby 2.3 or higher. Current version: ' . $ kirby -> version ( ) ) ; } if ( ! class_exists ( 'Twig_Environment' ) ) { require_once __DIR__ . '/../lib/Twig/lib/Twig/Autoloader.php' ; \ Twig_Autoloader :: register ( ) ; } $ kirby -> set ( 'component' , 'template' , 'Kirby\Twig\TwigComponent' ) ; if ( is_executable ( 'twig' ) === false ) { require_once __DIR__ . '/helpers.php' ; } return static :: $ registered = true ; }
7982	public function addDeleteTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaDeleteTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
12796	public function clear ( $ queue ) { $ this -> client -> request -> post ( $ this -> apiEndpoint . '/projects/' . $ this -> params [ 'project' ] . '/queues/' . $ queue . '/clear' ) ; }
9771	function most ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , lessThanOrEqual ( $ value ) ) ; }
7215	protected function fixDefault ( TaxGroupInterface $ taxGroup ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ taxGroup , [ 'default' ] ) ) { return ; } if ( $ taxGroup -> isDefault ( ) ) { try { $ previousTaxGroup = $ this -> taxGroupRepository -> findDefault ( ) ; } catch ( RuntimeException $ e ) { return ; } if ( null === $ previousTaxGroup || $ previousTaxGroup === $ taxGroup ) { return ; } $ previousTaxGroup -> setDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ previousTaxGroup , false ) ; } }
3207	private static function chunk ( $ binaryString , $ bits ) { $ binaryString = chunk_split ( $ binaryString , $ bits , ' ' ) ; if ( substr ( $ binaryString , ( strlen ( $ binaryString ) ) - 1 ) == ' ' ) { $ binaryString = substr ( $ binaryString , 0 , strlen ( $ binaryString ) - 1 ) ; } return explode ( ' ' , $ binaryString ) ; }
6865	protected function updateCustomerBalance ( InvoiceInterface $ invoice ) { if ( ! InvoiceTypes :: isCredit ( $ invoice ) ) { return ; } $ sale = $ this -> getSaleFromInvoice ( $ invoice ) ; if ( null === $ customer = $ sale -> getCustomer ( ) ) { return ; } $ methodCs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'paymentMethod' ) ; $ amountCs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'grandTotal' ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ invoice ) ) { $ method = empty ( $ methodCs ) ? $ invoice -> getPaymentMethod ( ) : $ methodCs [ 0 ] ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 0 ] ; if ( $ method && $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , - $ amount , true ) ; } return ; } if ( empty ( $ methodCs ) && empty ( $ amountCs ) ) { return ; } if ( ! empty ( $ methodCs ) && null !== $ method = $ methodCs [ 0 ] ) { $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 0 ] ; if ( $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , - $ amount , true ) ; } } if ( empty ( $ methodCs ) ) { $ method = $ invoice -> getPaymentMethod ( ) ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 1 ] - $ amountCs [ 0 ] ; } else { $ method = $ methodCs [ 1 ] ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 1 ] ; } if ( $ method && $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , $ amount , true ) ; } }
12104	public function handleRequest ( ) : void { global $ argv ; if ( ! is_array ( $ argv ) || empty ( $ argv ) ) { throw new Exception ( 'Invalid value of the cli args array was given.' ) ; } ( new CliCtrlResolver ( $ argv ) ) -> run ( ) ; }
3875	public function addPages ( $ pages , $ rootPage = null , $ fromSiteMap = false , $ language = null ) { $ this -> foundPages = $ pages ; unset ( $ pages ) ; foreach ( $ this -> getConfigs ( ) as $ config ) { if ( ! $ config [ 'published' ] ) { continue ; } $ this -> getMetaModelsPages ( $ config , $ rootPage , $ language ) ; } asort ( $ this -> foundPages ) ; return $ this -> foundPages ; }
3839	private function ensureSubmitElement ( $ panelRows ) { $ hasSubmit = false ; foreach ( $ panelRows as $ panelRow ) { foreach ( $ panelRow as $ element ) { if ( $ element instanceof SubmitElementInformationInterface ) { $ hasSubmit = true ; break ; } if ( $ hasSubmit ) { break ; } } } if ( ! $ hasSubmit && $ panelRows -> getRowCount ( ) ) { $ row = $ panelRows -> getRow ( $ panelRows -> getRowCount ( ) - 1 ) ; $ row -> addElement ( new DefaultSubmitElementInformation ( ) , 0 ) ; } }
6469	public function parseAcceptHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept' , $ i ) ; $ mediaType = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptMediaTypeHeaderValue ( $ mediaType , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
2212	public function fetchField ( $ intOffset = 0 ) { $ arrFields = array_values ( $ this -> resultSet [ $ this -> intIndex ] ) ; return $ arrFields [ $ intOffset ] ; }
4616	protected function validate ( ) { if ( ! $ this -> config -> getHost ( ) || ! $ this -> config -> getPort ( ) ) { throw new Node \ Builder \ Exception ( 'Node host address and port number are required.' ) ; } if ( $ this -> config -> getUser ( ) && $ this -> config -> getCertificate ( ) ) { throw new Node \ Builder \ Exception ( 'Connect with password OR certificate authentication, not both.' ) ; } if ( $ this -> config -> isAuth ( ) && ! $ this -> config -> getCaDirectory ( ) && ! $ this -> config -> getCaFile ( ) ) { throw new Node \ Builder \ Exception ( 'Certificate authority file is required for authentication.' ) ; } }
7489	public function insert ( $ offset , $ string ) { $ offset = ( int ) $ offset ; $ string = static :: convertString ( $ string , $ this -> encoding ) ; if ( $ offset < 0 || $ offset >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } $ this -> string = mb_substr ( $ this -> string , 0 , $ offset , $ this -> encoding ) . $ string . mb_substr ( $ this -> string , $ offset , $ this -> length ( ) , $ this -> encoding ) ; return $ this ; }
11712	protected function performAjaxValidation ( $ models ) { if ( \ Yii :: $ app -> request -> isAjax ) { if ( is_array ( $ models ) ) { $ result = [ ] ; foreach ( $ models as $ model ) { if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; $ result = array_merge ( $ result , ActiveForm :: validate ( $ model ) ) ; } } echo json_encode ( $ result ) ; \ Yii :: $ app -> end ( ) ; } else { if ( $ models -> load ( \ Yii :: $ app -> request -> post ( ) ) ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; echo json_encode ( ActiveForm :: validate ( $ models ) ) ; \ Yii :: $ app -> end ( ) ; } } } }
1217	public static function slice ( $ value , $ start = null , $ stop = null , $ step = 1 ) { if ( ! Utils :: isArray ( $ value ) && ! is_string ( $ value ) ) { throw new \ InvalidArgumentException ( 'Expects string or array' ) ; } return self :: sliceIndices ( $ value , $ start , $ stop , $ step ) ; }
5836	public function handleRequest ( Request $ request ) : Promise { $ path = removeDotPathSegments ( $ request -> getUri ( ) -> getPath ( ) ) ; return new Coroutine ( ( $ fileInfo = $ this -> fetchCachedStat ( $ path , $ request ) ) ? $ this -> respondFromFileInfo ( $ fileInfo , $ request ) : $ this -> respondWithLookup ( $ this -> root . $ path , $ path , $ request ) ) ; }
5219	public static function castFrom ( $ predicate ) { if ( $ predicate instanceof self ) { return $ predicate ; } elseif ( is_callable ( $ predicate ) ) { return new CallablePredicate ( $ predicate ) ; } throw new \ InvalidArgumentException ( 'Given predicate is neither a callable nor an instance of ' . __CLASS__ ) ; }
11230	public function get ( $ section , array $ params = [ ] , $ headers = [ ] ) { $ params = array_merge ( $ this -> parameters , $ params , $ this -> defaultParameters ) ; return $ this -> client -> get ( $ this -> getUrl ( $ section , $ params ) , $ headers ) ; }
7760	protected function detectMetadataDriver ( $ dir , ContainerBuilder $ container ) { $ configPath = $ this -> getMappingResourceConfigDirectory ( ) ; $ resource = $ dir . '/' . $ configPath ; while ( ! is_dir ( $ resource ) ) { $ resource = dirname ( $ resource ) ; } $ container -> addResource ( new FileResource ( $ resource ) ) ; $ extension = $ this -> getMappingResourceExtension ( ) ; if ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.php' ) ) && count ( $ files ) ) { return 'php' ; } $ container -> addResource ( new FileResource ( $ dir ) ) ; if ( is_dir ( $ dir . '/' . $ this -> getMappingObjectDefaultName ( ) ) ) { return 'annotation' ; } return null ; }
5959	public function clientGetByUid ( $ uid ) { foreach ( $ this -> clientList ( ) as $ client ) { if ( $ client [ "client_unique_identifier" ] == $ uid ) { return $ client ; } } throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; }
10702	public static function getPasswordComplexity ( $ password , $ minLength ) { $ group = [ 'upper' => '/[A-Z]/' , 'lower' => '/[a-z]/' , 'number' => '/[0-9]/' , 'special' => '/[^A-Za-z0-9]/' , ] ; $ score = 0 ; $ length = \ strlen ( $ password ) ; if ( $ length < $ minLength ) { return 0 ; } foreach ( $ group as $ pattern ) { if ( preg_match ( $ pattern , $ password ) ) { $ score ++ ; } } if ( $ score < 3 ) { $ score -- ; } if ( $ length > $ minLength ) { $ score += ( int ) floor ( ( $ length - $ minLength ) / 2 ) ; } return $ score ; }
4278	public function stream_read ( $ count ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ buffer = \ fread ( $ this -> handle , $ count ) ; $ bufferLen = \ strlen ( $ buffer ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS , 2 ) ; $ isRequire = ! \ in_array ( $ backtrace [ 1 ] [ 'function' ] , array ( 'file_get_contents' ) ) ; if ( ! $ this -> declaredTicks && $ isRequire ) { foreach ( self :: $ pathsExclude as $ excludePath ) { if ( \ strpos ( $ this -> filepath , $ excludePath . DIRECTORY_SEPARATOR ) === 0 ) { $ this -> declaredTicks = true ; } } } if ( ! $ this -> declaredTicks && $ isRequire ) { $ buffer = \ preg_replace ( '/^(<\?php\s*)$/m' , '$0 declare(ticks=1);' , $ buffer , 1 ) ; $ this -> declaredTicks = true ; self :: $ filesModified [ ] = $ this -> filepath ; } $ buffer = $ this -> bufferPrepend . $ buffer ; $ bufferLenAfter = \ strlen ( $ buffer ) ; $ diff = $ bufferLenAfter - $ bufferLen ; $ this -> bufferPrepend = '' ; if ( $ diff ) { $ this -> bufferPrepend = \ substr ( $ buffer , $ count ) ; $ buffer = \ substr ( $ buffer , 0 , $ count ) ; } self :: register ( ) ; return $ buffer ; }
4117	public function isWithinCachedBlock ( Mage_Core_Block_Abstract $ block ) { $ step = $ block ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { if ( ! is_null ( $ step -> getCacheLifetime ( ) ) ) { return true ; } $ step = $ step -> getParentBlock ( ) ; } return false ; }
8677	public function unique ( ) { $ items = [ ] ; foreach ( $ this -> items as $ item ) { if ( array_search ( $ item , $ items , true ) === false ) { $ items [ ] = $ item ; } } return $ this -> createFrom ( $ items ) ; }
4584	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ this -> getSignature ( ) ) ; $ event -> setData ( $ data ) ; }
1978	public static function add ( $ strMessage , $ strType , $ strScope = TL_MODE ) { if ( $ strMessage == '' ) { return ; } if ( ! \ in_array ( $ strType , static :: getTypes ( ) ) ) { throw new \ Exception ( "Invalid message type $strType" ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> add ( static :: getFlashBagKey ( $ strType , $ strScope ) , $ strMessage ) ; }
12696	static function getAvailableExtNames ( ) { $ files = pakeFinder :: type ( 'file' ) -> name ( 'options-*.yaml' ) -> not_name ( 'options-sample.yaml' ) -> not_name ( 'options-user.yaml' ) -> maxdepth ( 0 ) -> in ( self :: getOptionsDir ( ) ) ; foreach ( $ files as $ i => $ file ) { $ files [ $ i ] = substr ( basename ( $ file ) , 8 , - 5 ) ; } return $ files ; }
3789	protected function getSetValues ( $ arrValue , $ intId , $ strLangCode ) { if ( ( $ arrValue !== null ) && ! is_array ( $ arrValue ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid value provided: %s' , var_export ( $ arrValue , true ) ) ) ; } return array ( 'tstamp' => time ( ) , 'value' => ( string ) $ arrValue [ 'value' ] , 'att_id' => $ this -> get ( 'id' ) , 'langcode' => $ strLangCode , 'item_id' => $ intId , ) ; }
8450	public function contactRename ( $ contact , $ firstName , $ lastName ) { $ contact = $ this -> escapePeer ( $ contact ) ; $ firstName = $ this -> escapeStringArgument ( $ firstName ) ; $ lastName = $ this -> escapeStringArgument ( $ lastName ) ; return $ this -> exec ( 'rename_contact ' . $ contact . ' ' . $ firstName . ' ' . $ lastName ) ; }
12859	public function addRoute ( string $ verb , string $ path , array $ callback ) : Router { $ this -> routeCollector -> addRoute ( $ verb , $ path , $ callback ) ; return $ this ; }
7908	protected function renderDropdown ( ) { $ lines = [ ] ; $ lines [ ] = $ this -> encodeText ? Html :: encode ( $ this -> text ) : $ this -> text ; if ( $ this -> icon && is_string ( $ this -> icon ) ) { $ lines [ ] = $ this -> icon ; } $ lines [ ] = $ this -> renderItems ( $ this -> items , $ this -> options , $ this -> displaySearchInput ) ; return Html :: tag ( 'div' , implode ( "\n" , $ lines ) , $ this -> options ) ; }
7147	public function get_user_settings ( $ default = array ( ) , $ user_id = NULL ) { if ( ! $ user_id ) return $ default ; $ default_opt_in = apply_filters ( 'iac_default_opt_in' , FALSE ) ; $ default = $ default_opt_in ? '1' : '0' ; $ settings = array ( 'inform_about_posts' => get_user_meta ( $ user_id , 'post_subscription' , TRUE ) , 'inform_about_comments' => get_user_meta ( $ user_id , 'comment_subscription' , TRUE ) ) ; foreach ( $ settings as $ k => $ v ) { if ( '' === $ v ) $ settings [ $ k ] = $ default ; } return $ settings ; }
12896	public function isClosingAfterOpening ( ) { $ diff = $ this -> getOpeningDate ( ) -> diff ( $ this -> getClosingDate ( ) ) ; if ( $ diff -> invert === 0 ) { return true ; } else { return false ; } }
9097	public function onLoadModulesPostAddServices ( ModuleEvent $ e ) { $ moduleManager = $ e -> getTarget ( ) ; $ sm = $ moduleManager -> getEvent ( ) -> getParam ( 'ServiceManager' ) ; $ sm -> setInvokableClass ( 'yimaTheme.ThemeObject' , 'yimaTheme\Theme\Theme' , false ) ; }
956	public function isActiveTrial ( ) { return $ this -> isTrial ( ) && Carbon :: today ( ) -> lte ( Carbon :: parse ( $ this -> trial_ends_on ) ) ; }
2971	public static function processAttachments ( array $ attachments ) { $ processed = [ ] ; foreach ( $ attachments as $ attachment ) { if ( ! ( $ attachment instanceof Attachment ) ) { throw new \ InvalidArgumentException ( 'Attachments must implement Stampie\\Attachment' ) ; } $ name = $ attachment -> getName ( ) ; if ( isset ( $ processed [ $ name ] ) ) { $ name = static :: findUniqueName ( $ name , array_keys ( $ processed ) ) ; } $ processed [ $ name ] = $ attachment ; } return $ processed ; }
4724	public function render ( ) { $ html = new Text ( ) ; $ html -> append ( '<' ) -> append ( $ this -> getName ( ) ) ; foreach ( $ this -> attributes as $ name => $ value ) { $ html -> append ( ' ' ) -> append ( $ name ) -> append ( '=' ) -> append ( '"' ) -> append ( $ value ) -> append ( '"' ) ; } if ( $ this -> text -> isEmpty ( ) ) { if ( $ this -> type == self :: TYPE_BLOCK ) { return ( string ) $ html -> append ( '>' ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; } else { return ( string ) $ html -> append ( $ this -> emptyTagSuffix ) ; } } return ( string ) $ html -> append ( '>' ) -> append ( $ this -> text ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; }
12282	private function stopCustomProcess ( ) : void { if ( $ this -> isCustomProcessSet ( ) ) { $ this -> getCustomProcess ( ) -> stop ( ) ; } elseif ( class_exists ( '\extensions\core\Process' ) ) { \ extensions \ core \ Process :: getInstance ( ) -> stop ( ) ; } }
10620	public function boot ( ) { if ( ! $ this -> booted ) { foreach ( $ this -> providers as $ provider ) { $ provider -> boot ( $ this ) ; } } $ this -> booted = true ; }
7186	public function getCombination ( $ quantity , $ reset = false ) { if ( null !== $ this -> combination && ! $ reset ) { return $ this -> combination ; } $ this -> combination = null ; if ( ! empty ( $ combinations = $ this -> buildCombinations ( $ quantity ) ) ) { usort ( $ combinations , function ( AssignmentCombination $ a , AssignmentCombination $ b ) use ( $ quantity ) { if ( $ a -> diff == $ b -> diff ) { if ( $ a -> size == $ b -> size ) { return 0 ; } return $ a -> size < $ b -> size ? - 1 : 1 ; } if ( 0 <= $ a -> diff ) { return intval ( 0 > $ b -> diff ? - 1 : $ a -> diff - $ b -> diff ) ; } return intval ( 0 < $ b -> diff ? 1 : $ b -> diff - $ a -> diff ) ; } ) ; $ this -> combination = reset ( $ combinations ) ; } return $ this -> combination ; }
4406	public function matches ( Request $ request ) { return in_array ( $ request -> attributes -> get ( '_route' ) , array ( FallbackRouter :: ROUTE_NAME , UrlAliasRouter :: URL_ALIAS_ROUTE_NAME ) , true ) ; }
5029	public function findForView ( $ id ) { $ type = $ this -> doctrine -> getConnection ( ) -> fetchColumn ( 'SELECT type FROM page WHERE id=:id' , array ( 'id' => $ id ) ) ; if ( ! $ type ) { throw new NotFoundHttpException ; } $ types = $ this -> em -> getClassMetadata ( $ this -> pageClassName ) -> discriminatorMap ; $ class = $ types [ $ type ] ; $ repos = $ this -> em -> getRepository ( $ class ) ; if ( $ repos instanceof ViewablePageRepository ) { $ ret = $ repos -> findForView ( $ id ) ; } else { $ ret = $ repos -> find ( $ id ) ; } if ( ! $ ret ) { throw new NotFoundHttpException ; } $ this -> setLoadedPage ( $ ret ) ; return $ ret ; }
1990	protected function jumpToOrReload ( $ intId , $ strParams = null , $ strForceLang = null ) { if ( $ strForceLang !== null ) { @ trigger_error ( 'Using Frontend::jumpToOrReload() with $strForceLang has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; } global $ objPage ; $ blnForceRedirect = ( $ strParams !== null || $ strForceLang !== null ) ; if ( \ is_array ( $ intId ) ) { $ intId = $ intId [ 'id' ] ?? 0 ; } if ( $ intId > 0 && ( $ intId != $ objPage -> id || $ blnForceRedirect ) && ( $ objNextPage = PageModel :: findPublishedById ( $ intId ) ) !== null ) { $ this -> redirect ( $ objNextPage -> getFrontendUrl ( $ strParams , $ strForceLang ) ) ; } $ this -> reload ( ) ; }
10028	function getContactsByExternalId ( $ externalId , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/externalid/' . utf8_encode ( $ externalId ) , $ queryParameters ) ; }
12199	public static function join ( $ json1 , $ json2 ) { return array_merge ( self :: jsonDecode ( $ json1 ) , self :: jsonDecode ( $ json2 ) ) ; }
12363	public function initialize ( ) { parent :: initialize ( ) ; $ this -> addClauses ( [ self :: DEFERRABLE => 'DEFERRABLE %s' , self :: EITHER => 'OR %s' , self :: MATCH => 'MATCH %s' , self :: NOT_DEFERRABLE => 'NOT DEFERRABLE %s' , self :: UNIQUE_KEY => 'UNIQUE (%2$s)' ] ) ; $ this -> addKeywords ( [ self :: ABORT => 'ABORT' , self :: BINARY => 'BINARY' , self :: AUTO_INCREMENT => 'AUTOINCREMENT' , self :: FAIL => 'FAIL' , self :: IGNORE => 'IGNORE' , self :: INIT_DEFERRED => 'INITIALLY DEFERRED' , self :: INIT_IMMEDIATE => 'INITIALLY IMMEDIATE' , self :: NOCASE => 'NOCASE' , self :: PRIMARY_KEY => 'PRIMARY KEY' , self :: REPLACE => 'REPLACE' , self :: ROLLBACK => 'ROLLBACK' , self :: RTRIM => 'RTRIM' , self :: UNIQUE => 'UNIQUE' ] ) ; $ this -> addStatements ( [ Query :: INSERT => new Statement ( 'INSERT {or} INTO {table} {fields} VALUES {values}' ) , Query :: SELECT => new Statement ( 'SELECT {distinct} {fields} FROM {table} {joins} {where} {groupBy} {having} {compounds} {orderBy} {limit}' ) , Query :: UPDATE => new Statement ( 'UPDATE {or} {table} SET {fields} {where}' ) , Query :: DELETE => new Statement ( 'DELETE FROM {table} {where}' ) , Query :: CREATE_TABLE => new Statement ( "CREATE {temporary} TABLE IF NOT EXISTS {table} (\n{columns}{keys}\n)" ) , Query :: CREATE_INDEX => new Statement ( 'CREATE {type} INDEX IF NOT EXISTS {index} ON {table} ({fields})' ) , Query :: DROP_TABLE => new Statement ( 'DROP TABLE IF EXISTS {table}' ) , Query :: DROP_INDEX => new Statement ( 'DROP INDEX IF EXISTS {index}' ) ] ) ; unset ( $ this -> _statements [ Query :: TRUNCATE ] ) ; }
2848	public function setModuleStatus ( $ moduleName , $ isActive ) { $ moduleConfigFile = $ this -> getModuleConfigFilePath ( $ moduleName ) ; $ configXml = $ this -> loadXmlFile ( $ moduleConfigFile ) ; if ( $ configXml === false ) { throw new Exception ( "Unable to parse module configuration file {$moduleConfigFile}" ) ; } $ configXml -> modules -> { $ moduleName } -> active = $ isActive ? 'true' : 'false' ; if ( $ this -> saveXml ( $ configXml , $ moduleConfigFile ) === false ) { throw new Exception ( "Unable to save module configuration file {$moduleConfigFile}. Check to see if web server user has write permissions." ) ; } }
12035	private function createMethodGenerator ( $ methodName , $ body , DocBlockGenerator $ docBlock , $ parameterInfoArray , $ returnType = null ) { $ parameters = [ ] ; foreach ( $ parameterInfoArray as $ parameterInfo ) { $ parameters [ ] = new ParameterGenerator ( $ parameterInfo [ 0 ] , $ parameterInfo [ 1 ] ) ; } $ methodGenerator = new MethodGenerator ( $ methodName ) ; $ methodGenerator -> setParameters ( $ parameters ) ; if ( $ returnType != null ) { if ( is_array ( $ returnType ) ) { $ returnType = implode ( '|' , $ returnType ) ; } $ tags [ ] = new GenericTag ( 'return' , $ returnType ) ; $ docBlock -> setTags ( $ tags ) ; } $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; return $ methodGenerator ; }
1365	protected function bootMiddleware ( Router $ router ) { $ router -> aliasMiddleware ( 'json-api' , BootJsonApi :: class ) ; $ router -> aliasMiddleware ( 'json-api.content' , NegotiateContent :: class ) ; $ router -> aliasMiddleware ( 'json-api.auth' , Authorize :: class ) ; }
12710	public function make ( $ instance , $ parameters = [ ] ) { return $ this -> resolve ( $ instance , is_array ( $ parameters ) ? $ parameters : array_slice ( func_get_args ( ) , 1 ) ) ; }
8997	public function isEmpty ( $ filter = null ) : bool { if ( ! $ this -> exists ( ) ) { throw new DirectoryException ( "Directory {dir} does not exist" , array ( 'dir' => $ this -> path ) ) ; } $ iter = new \ DirectoryIterator ( $ this -> path ) ; while ( $ iter -> valid ( ) ) { if ( ! $ iter -> isDot ( ) && ( $ filter === null || ! preg_match ( "/$filter/" , $ iter -> getFilename ( ) ) ) ) { return false ; } $ iter -> next ( ) ; } return true ; }
5211	public function convert ( Node $ node , $ parentPrecedence , $ parentAssociativity , $ childPosition ) { $ type = $ node -> getType ( ) ; if ( $ this -> dispatcher -> issetPrecedenceMap ( $ type ) === true ) { $ childPrecedences = $ this -> dispatcher -> getPrecedenceMap ( $ type ) ; $ childPrecedence = $ childPrecedences [ 0 ] ; if ( $ childPrecedence > $ parentPrecedence || ( $ parentPrecedence == $ childPrecedence && $ parentAssociativity != $ childPosition ) ) { return '(' . $ this -> dispatcher -> { 'p' . $ type } ( $ node ) . ')' ; } } return $ this -> dispatcher -> { 'p' . $ type } ( $ node ) ; }
604	protected function substring ( $ length , $ caseSensitive = true , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + $ length > $ this -> length ) { return '' ; } $ cacheKey = $ offset . ',' . $ length ; if ( ! isset ( $ this -> _substrings [ $ cacheKey . ',1' ] ) ) { $ this -> _substrings [ $ cacheKey . ',1' ] = mb_substr ( $ this -> sql , $ offset , $ length , 'UTF-8' ) ; } if ( ! $ caseSensitive && ! isset ( $ this -> _substrings [ $ cacheKey . ',0' ] ) ) { $ this -> _substrings [ $ cacheKey . ',0' ] = mb_strtoupper ( $ this -> _substrings [ $ cacheKey . ',1' ] , 'UTF-8' ) ; } return $ this -> _substrings [ $ cacheKey . ',' . ( int ) $ caseSensitive ] ; }
481	public function addPrimaryKey ( $ name , $ table , $ columns ) { $ time = $ this -> beginCommand ( "add primary key $name on $table (" . ( is_array ( $ columns ) ? implode ( ',' , $ columns ) : $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> addPrimaryKey ( $ name , $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
11619	public function site ( ) : \ TheCMSThread \ Core \ Main \ Site { static $ site ; if ( $ site === null ) { $ site = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\Site" ) ; } return $ site ; }
3292	public function twitter ( ) { if ( is_null ( $ this -> title ) ) { $ this -> title = config ( 'laravel-share.services.twitter.text' ) ; } $ base = config ( 'laravel-share.services.twitter.uri' ) ; $ url = $ base . '?text=' . urlencode ( $ this -> title ) . '&url=' . $ this -> url ; $ this -> buildLink ( 'twitter' , $ url ) ; return $ this ; }
2461	private function canonicalize ( string $ value ) : string { $ resolved = [ ] ; $ chunks = preg_split ( '#([\\\\/]+)#' , $ value , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; for ( $ i = 0 , $ c = \ count ( $ chunks ) ; $ i < $ c ; ++ $ i ) { if ( '.' === $ chunks [ $ i ] ) { ++ $ i ; continue ; } if ( '/' === $ chunks [ $ i ] [ 0 ] ) { $ resolved [ ] = '/' ; continue ; } if ( '\\' === $ chunks [ $ i ] [ 0 ] ) { $ resolved [ ] = '\\' ; continue ; } if ( '..' === $ chunks [ $ i ] ) { ++ $ i ; array_pop ( $ resolved ) ; array_pop ( $ resolved ) ; continue ; } $ resolved [ ] = $ chunks [ $ i ] ; } return rtrim ( implode ( '' , $ resolved ) , '\/' ) ; }
2830	public function disableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( false ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was disabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to disable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
7796	protected function accountNumber ( $ text ) { $ format = $ this -> format == self :: FORMAT_CLASSIC ? '/^[0-9.]+/' : '/^[0-9A-Z]+/' ; if ( $ account = $ this -> getLine ( '25' , $ text ) ) { if ( preg_match ( $ format , $ account , $ match ) ) { return str_replace ( '.' , '' , $ match [ 0 ] ) ; } } return null ; }
10020	public function removeCellXfByIndex ( $ pIndex ) { if ( $ pIndex > count ( $ this -> cellXfCollection ) - 1 ) { throw new Exception ( 'CellXf index is out of bounds.' ) ; } array_splice ( $ this -> cellXfCollection , $ pIndex , 1 ) ; foreach ( $ this -> workSheetCollection as $ worksheet ) { foreach ( $ worksheet -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ worksheet -> getCell ( $ coordinate ) ; $ xfIndex = $ cell -> getXfIndex ( ) ; if ( $ xfIndex > $ pIndex ) { $ cell -> setXfIndex ( $ xfIndex - 1 ) ; } elseif ( $ xfIndex == $ pIndex ) { $ cell -> setXfIndex ( 0 ) ; } } } }
4126	public function getDocumentNamespace ( $ documentNamespaceAlias ) { if ( ! isset ( $ this -> attributes [ 'documentNamespaces' ] [ $ documentNamespaceAlias ] ) ) { throw CouchDBException :: unknownDocumentNamespace ( $ documentNamespaceAlias ) ; } return trim ( $ this -> attributes [ 'documentNamespaces' ] [ $ documentNamespaceAlias ] , '\\' ) ; }
10939	public function get ( $ key ) { if ( ! ( $ time = $ this -> driver -> get ( $ key ) ) ) { if ( $ key == self :: LAST_UPDATE_KEY ) { $ time = $ this -> reset ( ) ; } else { $ time = $ this -> get ( self :: LAST_UPDATE_KEY ) ; } } return $ time ; }
8109	protected function getWithDefault ( $ field ) { $ value = $ this -> owner -> getField ( $ field ) ; if ( $ value ) { return $ value ; } $ defaults = $ this -> owner -> config ( ) -> get ( 'defaults' ) ; if ( isset ( $ defaults [ $ field ] ) ) { return $ defaults [ $ field ] ; } }
11516	public function updateMetadata ( SiteConfig $ config , SiteTree $ owner , & $ metadata ) { $ HTML5Favicon = $ config -> HTML5Favicon ( ) ; $ IOSPinicon = $ config -> IOSPinicon ( ) ; $ AndroidPinicon = $ config -> AndroidPinicon ( ) ; $ WindowsPinicon = $ config -> WindowsPinicon ( ) ; if ( $ IOSPinicon -> exists ( ) ) { $ this -> GenerateIOSPinicon ( $ config , $ owner , $ metadata , $ IOSPinicon ) ; } if ( $ HTML5Favicon -> exists ( ) ) { $ this -> GenerateHTML5Favicon ( $ owner , $ metadata , $ HTML5Favicon ) ; } if ( $ AndroidPinicon -> exists ( ) ) { $ this -> GenerateAndroidPinicon ( $ config , $ owner , $ metadata ) ; } if ( $ WindowsPinicon -> exists ( ) ) { $ this -> GenerateWindowsPinicon ( $ config , $ owner , $ metadata , $ WindowsPinicon ) ; } }
11896	protected function generateIV ( ) { $ sizeIV = $ this -> getSizeIV ( ) ; if ( $ sizeIV === 0 ) { return $ this ; } $ this -> setIV ( mcrypt_create_iv ( $ sizeIV , MCRYPT_RAND ) ) ; return $ this ; }
5267	public function esc_value ( $ value ) { global $ wpdb ; if ( is_int ( $ value ) ) { return $ wpdb -> prepare ( '%d' , $ value ) ; } if ( is_float ( $ value ) ) { return $ wpdb -> prepare ( '%f' , $ value ) ; } if ( is_string ( $ value ) ) { return 'null' === $ value ? $ value : $ wpdb -> prepare ( '%s' , $ value ) ; } return $ value ; }
2927	protected function resetContent ( ) { $ this -> filePath = null ; $ this -> reader -> load ( null ) ; $ this -> writer -> setBuffer ( null ) ; }
12270	protected function dispatchSlotsEvent ( $ baseEventName , Page $ page , array $ slots ) { $ eventNames = $ this -> generateEventNames ( $ baseEventName , $ page ) ; $ event = new SlotsRenderingEvent ( $ slots ) ; foreach ( $ eventNames as $ eventName ) { $ event = Dispatcher :: dispatch ( $ eventName , $ event ) ; } return $ event -> getSlots ( ) ; }
11624	public function getContent ( Location $ location = null , Operation $ operation ) { if ( $ operation ) { $ status = $ this -> contentService -> getSocialMediaScheduleByOperation ( $ operation ) ; return $ status ; } return null ; }
740	protected function saveRules ( ) { $ rules = [ ] ; foreach ( $ this -> rules as $ name => $ rule ) { $ rules [ $ name ] = serialize ( $ rule ) ; } $ this -> saveToFile ( $ rules , $ this -> ruleFile ) ; }
2515	public function pnrRetrieve ( RequestOptions \ PnrRetrieveOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Retrieve' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
9972	public function setCodeName ( $ pValue , $ validate = true ) { if ( $ this -> getCodeName ( ) == $ pValue ) { return $ this ; } if ( $ validate ) { $ pValue = str_replace ( ' ' , '_' , $ pValue ) ; self :: checkSheetCodeName ( $ pValue ) ; if ( $ this -> getParent ( ) ) { if ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue ) ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 29 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 29 ) ; } $ i = 1 ; while ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue . '_' . $ i ) ) { ++ $ i ; if ( $ i == 10 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 28 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 28 ) ; } } elseif ( $ i == 100 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 27 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 27 ) ; } } } $ pValue = $ pValue . '_' . $ i ; } } } $ this -> codeName = $ pValue ; return $ this ; }
5637	public function paintError ( $ message ) { parent :: paintError ( $ message ) ; print 'Exception ' . $ this -> getExceptionCount ( ) . "!\n$message\n" ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print "\tin " . implode ( "\n\tin " , array_reverse ( $ breadcrumb ) ) ; print "\n" ; }
100	public function set ( $ prefix , $ paths ) { if ( ! $ prefix ) { $ this -> fallbackDirsPsr0 = ( array ) $ paths ; } else { $ this -> prefixesPsr0 [ $ prefix [ 0 ] ] [ $ prefix ] = ( array ) $ paths ; } }
507	public function getMessageSource ( $ category ) { if ( isset ( $ this -> translations [ $ category ] ) ) { $ source = $ this -> translations [ $ category ] ; if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = Yii :: createObject ( $ source ) ; } foreach ( $ this -> translations as $ pattern => $ source ) { if ( strpos ( $ pattern , '*' ) > 0 && strpos ( $ category , rtrim ( $ pattern , '*' ) ) === 0 ) { if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = $ this -> translations [ $ pattern ] = Yii :: createObject ( $ source ) ; } } if ( isset ( $ this -> translations [ '*' ] ) ) { $ source = $ this -> translations [ '*' ] ; if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = $ this -> translations [ '*' ] = Yii :: createObject ( $ source ) ; } throw new InvalidConfigException ( "Unable to locate message source for category '$category'." ) ; }
383	public function getExceptionName ( $ exception ) { if ( $ exception instanceof \ yii \ base \ Exception || $ exception instanceof \ yii \ base \ InvalidCallException || $ exception instanceof \ yii \ base \ InvalidParamException || $ exception instanceof \ yii \ base \ UnknownMethodException ) { return $ exception -> getName ( ) ; } return null ; }
9544	public static function allExcept ( $ except ) { $ result = [ 'parameter' => [ 'longest' => 9 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> prefix . $ parameter -> parameterName ; } , ] , 'properties' => [ 'longest' => 10 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getPropertiesAsString ( ) ; } , ] , 'aliases' => [ 'longest' => 7 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getAliasUsage ( false ) ; } , ] , 'description' => [ 'longest' => 11 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> description ; } , ] , 'required' => [ 'longest' => 8 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> required ? 'Yes' : '' ; } , ] , ] ; foreach ( $ except as $ exceptKey ) { unset ( $ result [ $ exceptKey ] ) ; } return $ result ; }
6740	public function front ( ) { add_action ( 'wp' , function ( ) { App :: setCurrentID ( 'EFG' ) ; if ( App :: main ( ) -> is_single ( ) && ! is_preview ( ) ) { $ this -> add_scripts ( 'customRatingGrifus' ) ; $ this -> add_styles ( ) ; } elseif ( is_home ( ) || is_category ( ) || is_archive ( ) || is_search ( ) ) { $ this -> add_scripts ( 'customRatingGrifusHome' ) ; } } ) ; }
5357	protected function createQueryParamStatements ( Operation $ operation ) { $ queryParamDocumentation = [ ] ; $ queryParamVariable = new Expr \ Variable ( 'queryParam' ) ; $ queryParamStatements = [ new Expr \ Assign ( $ queryParamVariable , new Expr \ New_ ( new Name ( 'QueryParam' ) ) ) ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof FormDataParameterSubSchema ) { $ queryParamStatements = array_merge ( $ queryParamStatements , $ this -> formDataParameterGenerator -> generateQueryParamStatements ( $ parameter , $ queryParamVariable ) ) ; $ queryParamDocumentation [ ] = $ this -> formDataParameterGenerator -> generateQueryDocParameter ( $ parameter ) ; } if ( $ parameter instanceof HeaderParameterSubSchema ) { $ queryParamStatements = array_merge ( $ queryParamStatements , $ this -> headerParameterGenerator -> generateQueryParamStatements ( $ parameter , $ queryParamVariable ) ) ; $ queryParamDocumentation [ ] = $ this -> headerParameterGenerator -> generateQueryDocParameter ( $ parameter ) ; } if ( $ parameter instanceof QueryParameterSubSchema ) { $ queryParamStatements = array_merge ( $ queryParamStatements , $ this -> queryParameterGenerator -> generateQueryParamStatements ( $ parameter , $ queryParamVariable ) ) ; $ queryParamDocumentation [ ] = $ this -> queryParameterGenerator -> generateQueryDocParameter ( $ parameter ) ; } } } return [ $ queryParamDocumentation , $ queryParamStatements , $ queryParamVariable ] ; }
5226	private function isTypeMismatch ( $ type , $ value ) { if ( ! ( $ type instanceof \ ReflectionClass ) ) { return false ; } if ( ! is_object ( $ value ) ) { return true ; } return ! $ type -> isInstance ( $ value ) ; }
9036	protected function insert ( $ entity , $ tableName = null , HydratorInterface $ hydrator = null ) { $ result = parent :: insert ( $ entity , $ tableName , $ hydrator ) ; $ entity -> setId ( $ result -> getGeneratedValue ( ) ) ; return $ result ; }
4443	public function multiget ( array $ jids ) : array { if ( empty ( $ jids ) ) { return [ ] ; } $ results = call_user_func_array ( [ $ this -> client , 'multiget' ] , $ jids ) ; $ jobs = json_decode ( $ results , true ) ? : [ ] ; $ ret = [ ] ; foreach ( $ jobs as $ data ) { $ job = new BaseJob ( $ this -> client , $ data ) ; $ job -> setEventsManager ( $ this -> client -> getEventsManager ( ) ) ; $ ret [ $ job -> jid ] = $ job ; } return $ ret ; }
10329	public function set_images ( $ post_id , $ post , $ update ) { App :: setCurrentID ( 'EFG' ) ; if ( Module :: CustomImagesGrifus ( ) -> getOption ( 'replace-when-add' ) ) { $ is_insert_post = App :: main ( ) -> is_after_insert_post ( $ post , $ update ) ; $ is_update_post = App :: main ( ) -> is_after_update_post ( $ post , $ update ) ; if ( $ is_insert_post || $ is_update_post ) { $ this -> model -> set_images ( $ post_id ) ; } } }
9955	public function unmergeCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> unmergeCells ( $ cellRange ) ; }
9103	protected function parse_message ( ) { if ( empty ( $ this -> args [ 'message' ] ) ) { return null ; } $ like = esc_sql ( $ this -> args [ 'message' ] ) ; return new Where ( 'message' , 'LIKE' , "%{$like}%" ) ; }
11331	public function setModel ( $ value ) { $ this -> _model = $ value ; if ( is_object ( $ value ) && $ this -> _attributes ) { $ this -> _model -> attributes = $ this -> _attributes ; } return true ; }
8331	public function constructPdoDsn ( array $ params ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> constructPdoDsnWindows ( $ params ) ; } return $ this -> constructPdoDsnUnix ( $ params ) ; }
939	public function isWhitespace ( $ whitespaces = " \t\n\r\0\x0B" ) { if ( null === $ whitespaces ) { $ whitespaces = " \t\n\r\0\x0B" ; } if ( $ this -> isArray && ! $ this -> isGivenKind ( T_WHITESPACE ) ) { return false ; } return '' === trim ( $ this -> content , $ whitespaces ) ; }
6528	public static function registerMap ( array $ map ) { @ trigger_error ( sprintf ( '"%s" is deprecated. Use "registerManifest" instead.' , __CLASS__ ) , E_USER_DEPRECATED ) ; $ nextId = count ( self :: $ curies ) + 30000 ; foreach ( $ map as $ curie => $ class ) { ++ $ nextId ; self :: $ curies [ $ curie ] = $ nextId ; self :: $ classes [ $ nextId ] = $ class ; } }
10276	public static function getTextWidthPixelsApprox ( $ columnText , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font , $ rotation = 0 ) { $ fontName = $ font -> getName ( ) ; $ fontSize = $ font -> getSize ( ) ; switch ( $ fontName ) { case 'Calibri' : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; case 'Arial' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; case 'Verdana' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; default : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; } if ( $ rotation !== 0 ) { if ( $ rotation == - 165 ) { $ columnWidth = 4 ; } else { $ columnWidth = $ columnWidth * cos ( deg2rad ( $ rotation ) ) + $ fontSize * abs ( sin ( deg2rad ( $ rotation ) ) ) / 5 ; } } return ( int ) $ columnWidth ; }
2994	protected function encode ( $ str ) { if ( empty ( $ str ) || $ this -> charset == 'UTF-8' ) return $ str ; if ( extension_loaded ( 'iconv' ) ) $ out = @ iconv ( "UTF-8" , $ this -> charset . "//IGNORE" , $ str ) ; if ( ! isset ( $ out ) || ! $ out ) $ out = extension_loaded ( 'mbstring' ) ? mb_convert_encoding ( $ str , $ this -> charset , "UTF-8" ) : utf8_decode ( $ str ) ; return $ out ? : $ str ; }
4581	private function getProperties ( Encryptable $ model ) : array { $ properties = [ ] ; $ reflection = new ReflectionObject ( $ model ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Encrypt :: class ) ; if ( ! $ annotation ) { continue ; } if ( null !== $ annotation -> applicable && ! $ this -> expressionLanguage -> evaluate ( $ annotation -> applicable , [ 'object' => $ model ] ) ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
11970	public function extendExpiration ( ) { if ( null === $ this -> ttl ) { throw new DomainException ( 'There is no TTL set for this Lock.' ) ; } if ( ! $ this -> expiresAt ) { $ this -> expiresAt = new \ DateTime ( ) ; $ this -> expiresAt -> setTimestamp ( time ( ) ) ; } $ this -> expiresAt -> add ( $ this -> ttl ) ; }
4648	private function getConfigValue ( $ config , $ language , $ key ) { if ( ! isset ( $ config [ $ key ] ) || empty ( $ config [ $ key ] ) ) { if ( isset ( $ this -> defaults [ $ language ] [ $ key ] ) ) { return $ this -> defaults [ $ language ] [ $ key ] ; } return array ( ) ; } if ( ! is_array ( $ config [ $ key ] ) ) { return array ( $ config [ $ key ] ) ; } return $ config [ $ key ] ; }
11587	public function end ( $ taskName ) { if ( ! isset ( $ this -> _tasks [ $ taskName ] ) ) { throw new Exception ( "Undefined task name: `'{$taskName}`." ) ; } $ task = $ this -> _tasks [ $ taskName ] ; $ task -> end ( ) ; return $ task ; }
6015	public function retrieveSite ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/sites/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
11452	public function getActions ( ) { $ actions = [ ] ; if ( is_array ( $ this -> actions ) ) { foreach ( $ this -> actions as $ action ) { $ actions [ $ action ] = $ action ; } } return $ actions ; }
6028	public function setDeployedFiles ( array $ deployedFiles ) { $ this -> deployedFiles = [ ] ; foreach ( $ deployedFiles as $ item ) { $ this -> addDeploymentFile ( $ item ) ; } return $ this ; }
118	protected function getCredentialString ( ) { if ( ! $ this -> hasAuth ( ) ) { return '' ; } return sprintf ( ' %s--username %s --password %s ' , $ this -> getAuthCache ( ) , ProcessExecutor :: escape ( $ this -> getUsername ( ) ) , ProcessExecutor :: escape ( $ this -> getPassword ( ) ) ) ; }
1506	protected function buildParams ( EncodingParametersInterface $ parameters ) { return array_filter ( [ QueryParametersParserInterface :: PARAM_FILTER => $ parameters -> getFilteringParameters ( ) , QueryParametersParserInterface :: PARAM_SORT => $ this -> buildSortParams ( ( array ) $ parameters -> getSortParameters ( ) ) ] ) ; }
927	private function getCommentBlock ( Tokens $ tokens , $ index ) { $ commentType = $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ; $ empty = $ this -> isEmptyComment ( $ tokens [ $ index ] -> getContent ( ) ) ; $ start = $ index ; $ count = \ count ( $ tokens ) ; ++ $ index ; for ( ; $ index < $ count ; ++ $ index ) { if ( $ tokens [ $ index ] -> isComment ( ) ) { if ( $ commentType !== $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ) { break ; } if ( $ empty ) { $ empty = $ this -> isEmptyComment ( $ tokens [ $ index ] -> getContent ( ) ) ; } continue ; } if ( ! $ tokens [ $ index ] -> isWhitespace ( ) || $ this -> getLineBreakCount ( $ tokens , $ index , $ index + 1 ) > 1 ) { break ; } } return [ $ start , $ index - 1 , $ empty ] ; }
6344	public static function from ( Traversable $ traversable ) : Iterator { Preconditions :: checkArgument ( $ traversable instanceof Iterator || $ traversable instanceof IteratorAggregate ) ; return $ traversable instanceof Iterator ? $ traversable : Iterators :: from ( $ traversable -> getIterator ( ) ) ; }
8563	private function _convertCreateShipment ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsCreateShipmentRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsCreateShipmentRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } if ( $ request -> isSetShippingServiceId ( ) ) { $ parameters [ 'ShippingServiceId' ] = $ request -> getShippingServiceId ( ) ; } if ( $ request -> isSetShippingServiceOfferId ( ) ) { $ parameters [ 'ShippingServiceOfferId' ] = $ request -> getShippingServiceOfferId ( ) ; } return $ parameters ; }
9464	private function registerLogViewerPackage ( ) { $ this -> registerProvider ( LogViewerServiceProvider :: class ) ; $ config = $ this -> config ( ) ; $ config -> set ( 'log-viewer.route.enabled' , false ) ; $ config -> set ( 'log-viewer.menu.filter-route' , $ config -> get ( 'arcanesoft.foundation.log-viewer.filter-route' ) ) ; }
7059	public function addClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( ! in_array ( $ class , $ classes ) ) { $ classes [ ] = $ class ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
717	public function dateTime ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DATETIME , $ precision ) ; }
4031	private function updateImageWithDisabled ( ModelInterface $ model , $ image ) { $ this -> preCreateInverseImage ( $ model , $ image ) ; if ( $ model -> getProperty ( 'enabled' ) ) { return $ image ; } if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return $ image ; } return substr_replace ( $ image , '_1' , $ intPos , 0 ) ; }
8904	public function delete_many ( $ primary_values , $ time = 'NOW()' ) { $ this -> _database -> where_in ( $ this -> primary_key , $ primary_values ) ; return $ this -> _delete ( $ primary_values , $ time ) ; }
4356	protected function methodTable ( $ array , $ columns = array ( ) ) { if ( ! \ is_array ( $ array ) ) { return $ this -> dump ( $ array ) ; } $ keys = $ columns ? : $ this -> debug -> methodTable -> colKeys ( $ array ) ; $ table = array ( ) ; $ classnames = array ( ) ; if ( $ this -> debug -> abstracter -> isAbstraction ( $ array ) && $ array [ 'traverseValues' ] ) { $ array = $ array [ 'traverseValues' ] ; } foreach ( $ array as $ k => $ row ) { $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; $ values = $ this -> methodTableCleanValues ( $ values ) ; $ table [ $ k ] = $ values ; $ classnames [ $ k ] = $ objInfo [ 'row' ] ? $ objInfo [ 'row' ] [ 'className' ] : '' ; } if ( \ array_filter ( $ classnames ) ) { foreach ( $ classnames as $ k => $ classname ) { $ table [ $ k ] = \ array_merge ( array ( ' class_name' => $ classname ) , $ table [ $ k ] ) ; } } return $ table ; }
5035	public function setFrom ( $ email , $ name = null ) { if ( is_array ( $ email ) ) { $ this -> from = [ $ email [ 'email' ] => $ email [ 'name' ] ] ; } else { $ this -> from = is_object ( $ email ) || null === $ name ? $ email : array ( $ email => $ name ) ; } return $ this ; }
3010	public function setConsumer ( $ consumerKey , $ consumerSecret ) { $ this -> apiKey = $ consumerKey ; $ this -> requestHandler -> setConsumer ( $ consumerKey , $ consumerSecret ) ; }
4208	private function isObjExcluded ( $ obj ) { if ( \ in_array ( \ get_class ( $ obj ) , $ this -> abstracter -> getCfg ( 'objectsExclude' ) ) ) { return true ; } foreach ( $ this -> abstracter -> getCfg ( 'objectsExclude' ) as $ exclude ) { if ( \ is_subclass_of ( $ obj , $ exclude ) ) { return true ; } } return false ; }
1750	public static function log ( $ strText , $ strFunction , $ strCategory ) { @ trigger_error ( 'Using System::log() has been deprecated and will no longer work in Contao 5.0. Use the logger service instead.' , E_USER_DEPRECATED ) ; $ level = 'ERROR' === $ strCategory ? LogLevel :: ERROR : LogLevel :: INFO ; $ logger = static :: getContainer ( ) -> get ( 'monolog.logger.contao' ) ; $ logger -> log ( $ level , $ strText , array ( 'contao' => new ContaoContext ( $ strFunction , $ strCategory ) ) ) ; }
254	public static function end ( ) { if ( ! empty ( self :: $ stack ) ) { $ widget = array_pop ( self :: $ stack ) ; if ( get_class ( $ widget ) === get_called_class ( ) ) { if ( $ widget -> beforeRun ( ) ) { $ result = $ widget -> run ( ) ; $ result = $ widget -> afterRun ( $ result ) ; echo $ result ; } return $ widget ; } throw new InvalidCallException ( 'Expecting end() of ' . get_class ( $ widget ) . ', found ' . get_called_class ( ) ) ; } throw new InvalidCallException ( 'Unexpected ' . get_called_class ( ) . '::end() call. A matching begin() is not found.' ) ; }
3184	public function jsonSerialize ( ) { $ source = $ this -> getSource ( ) ; $ timeLimits = $ source -> getTimeLimits ( ) ; if ( ! is_null ( $ timeLimits ) ) { $ identifier = $ source -> getIdentifier ( ) ; $ maxTime = $ timeLimits -> getMaxTime ( ) ; $ minTime = $ timeLimits -> getMinTime ( ) ; $ maxTimeRemaining = $ this -> getMaximumRemainingTime ( ) ; $ minTimeRemaining = $ this -> getMinimumRemainingTime ( ) ; if ( $ maxTimeRemaining !== false || $ minTimeRemaining !== false ) { $ label = method_exists ( $ source , 'getTitle' ) ? $ source -> getTitle ( ) : $ identifier ; $ extraTime = [ ] ; if ( ! is_null ( $ this -> getTimer ( ) ) && $ source -> getTimeLimits ( ) -> hasMaxTime ( ) ) { $ timer = $ this -> getTimer ( ) ; $ maxTimeSeconds = $ source -> getTimeLimits ( ) -> getMaxTime ( ) -> getSeconds ( true ) ; $ extraTime = [ 'total' => $ timer -> getExtraTime ( $ maxTimeSeconds ) , 'consumed' => $ timer -> getConsumedExtraTime ( $ identifier , $ maxTimeSeconds , $ this -> timerTarget ) , 'remaining' => $ timer -> getRemainingExtraTime ( $ identifier , $ maxTimeSeconds , $ this -> timerTarget ) , ] ; } $ labelFormatter = ServiceManager :: getServiceManager ( ) -> get ( TimerLabelFormatterService :: SERVICE_ID ) ; return [ 'label' => $ labelFormatter -> format ( $ label ) , 'source' => $ identifier , 'qtiClassName' => $ source -> getQtiClassName ( ) , 'extraTime' => $ extraTime , 'allowLateSubmission' => $ this -> allowLateSubmission ( ) , 'minTime' => $ this -> durationToMs ( $ minTime ) , 'minTimeRemaining' => $ this -> durationToMs ( $ minTimeRemaining ) , 'maxTime' => $ this -> durationToMs ( $ maxTime ) , 'maxTimeRemaining' => $ this -> durationToMs ( $ maxTimeRemaining ) , ] ; } } return null ; }
6917	public function isEmpty ( ) { return empty ( $ this -> subject ) || ( empty ( $ this -> customMessage ) && empty ( $ this -> paymentMessage ) && empty ( $ this -> shipmentMessage ) ) ; }
3275	public function delete ( string $ key ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , false ) ; } }
1021	public function toSerializableArray ( ) { $ arr = [ 'message' => $ this -> getMessage ( ) , ] ; $ locations = Utils :: map ( $ this -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ arr [ 'locations' ] = $ locations ; } if ( ! empty ( $ this -> path ) ) { $ arr [ 'path' ] = $ this -> path ; } if ( ! empty ( $ this -> extensions ) ) { $ arr [ 'extensions' ] = $ this -> extensions ; } return $ arr ; }
4853	public function getCurrentRealRows ( $ table = null ) { $ table = $ table ? : $ this -> getCurrentTable ( ) ; if ( ! isset ( $ this -> currentRealRows [ $ table ] ) || ! $ this -> currentRealRows [ $ table ] ) { $ fields = $ this -> getPreparedFields ( ) [ $ table ] ; $ this -> currentRealRows [ $ table ] = $ this -> getRealRow ( $ fields , $ table ) ; } return $ this -> currentRealRows [ $ table ] ; }
5313	protected function getHTMLListFromGenerator ( IconFontGenerator $ generator , $ fontFile ) { $ fontOptions = $ generator -> getFont ( ) -> getOptions ( ) ; $ html = '<ul>' ; $ glyphNames = $ generator -> getGlyphNames ( ) ; asort ( $ glyphNames ) ; foreach ( $ glyphNames as $ unicode => $ glyph ) { $ html .= "\n\t" . '<li data-icon="&#x' . $ unicode . ';" title="' . htmlspecialchars ( $ glyph ) . '">' . htmlspecialchars ( $ glyph ) . '</li>' ; } $ html .= "\n" . '</ul>' . "\n" ; return $ html ; }
1402	public function getErrors ( ) { if ( ! is_null ( $ this -> errors ) ) { return collect ( $ this -> errors ) ; } try { $ this -> errors = $ this -> parse ( ) ; } catch ( \ Exception $ ex ) { $ this -> errors = [ ] ; } return collect ( $ this -> errors ) ; }
12026	private function generateExecuteDocBlock ( $ methodDescription ) { $ responseClass = $ this -> operationDefinition -> getResponseClass ( ) ; $ docBlock = new DocBlockGenerator ( $ methodDescription , null ) ; if ( $ responseClass ) { $ tags [ ] = new GenericTag ( 'return' , '\\' . $ responseClass ) ; } else { $ tags [ ] = new GenericTag ( 'return' , 'mixed' ) ; } $ docBlock -> setTags ( $ tags ) ; return $ docBlock ; }
12040	public function getCurrentUser ( ) { $ this -> authenticated = false ; $ authenticate = $ this -> session -> get ( "handler" , "auth" ) ; if ( is_a ( $ authenticate , Authenticate :: class ) ) { if ( $ authenticate -> authenticated ) { $ this -> authenticated = true ; $ this -> authority = $ this -> session -> getAuthority ( ) ; return $ this -> loadObjectByURI ( $ authenticate -> get ( "user_name_id" ) , [ ] , true ) ; } } return $ this ; }
2888	public function onBlockToHtml ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ block = $ observer -> getData ( 'block' ) ; if ( $ block -> getNameInLayout ( ) == 'debug_panels' ) { $ this -> updateProfiling ( ) ; } if ( ! $ this -> canCaptureBlock ( $ block ) ) { return ; } $ blockName = Mage :: helper ( 'sheep_debug' ) -> getBlockName ( $ block ) ; $ requestInfo = $ this -> getRequestInfo ( ) ; try { $ blockInfo = $ requestInfo -> getBlock ( $ blockName ) ; } catch ( Exception $ e ) { $ blockInfo = $ requestInfo -> addBlock ( $ block ) ; } $ blockInfo -> startRendering ( $ block ) ; }
10030	function updateContact ( $ contact , $ checksum = "" , $ src = null , $ subscriptionPage = null , $ triggerDoi = FALSE , $ doiMailingKey = null , $ ignoreChecksum = false ) { $ queryParameters = array ( 'id' => $ contact -> id , 'checksum' => $ checksum , 'triggerdoi' => ( $ triggerDoi == TRUE ) ? "true" : "false" , 'ignore_checksum' => $ ignoreChecksum ? "true" : "false" ) ; if ( isset ( $ contact -> permission ) ) $ queryParameters [ 'permission' ] = $ contact -> permission -> getCode ( ) ; if ( isset ( $ src ) ) $ queryParameters [ 'src' ] = $ src ; if ( isset ( $ subscriptionPage ) ) $ queryParameters [ 'page_key' ] = $ subscriptionPage ; $ doiMailingKey = trim ( $ doiMailingKey ) ; if ( ! empty ( $ doiMailingKey ) ) $ queryParameters [ 'doimailing' ] = $ doiMailingKey ; $ contactToSend = new Contact ( null , $ contact -> email , null , $ contact -> external_id , null , $ contact -> standard_fields , $ contact -> custom_fields ) ; return $ this -> put ( "contacts/contact" , $ contactToSend -> toXMLString ( ) , $ queryParameters ) ; }
4854	protected function profiling ( $ signal = true ) { static $ timeStart ; if ( $ signal ) { $ timeStart = microtime ( true ) ; } if ( ! $ signal ) { $ this -> timeExecution = ( microtime ( true ) - $ timeStart ) / 60 ; return $ this -> timeExecution ; } }
1755	public static function getTimeZones ( ) { $ arrReturn = array ( ) ; $ timezones = array ( ) ; require __DIR__ . '/../../config/timezones.php' ; foreach ( $ timezones as $ strGroup => $ arrTimezones ) { foreach ( $ arrTimezones as $ strTimezone ) { $ arrReturn [ $ strGroup ] [ ] = $ strTimezone ; } } return $ arrReturn ; }
8667	public function setMessage ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Message' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1282	public function getField ( string $ fieldId , bool $ tryCaseInsensitive = false ) { if ( isset ( $ this -> fields [ $ fieldId ] ) ) { return $ this -> fields [ $ fieldId ] ; } if ( $ tryCaseInsensitive ) { foreach ( $ this -> fields as $ name => $ field ) { if ( \ mb_strtolower ( $ name ) === \ mb_strtolower ( $ fieldId ) ) { return $ field ; } } } return null ; }
11090	public static function getGreeting ( $ time = null ) { if ( $ time === null ) { $ time = time ( ) ; } elseif ( \ is_string ( $ time ) ) { $ time = strtotime ( $ time ) ; } switch ( date ( 'G' , $ time ) ) { case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : return self :: poorManTranslate ( 'fts-shared' , 'Good morning' ) ; case 8 : case 9 : case 10 : case 11 : return trim ( self :: poorManTranslate ( 'fts-shared' , '_Good morning' ) , '_' ) ; case 12 : return self :: poorManTranslate ( 'fts-shared' , 'Good noon' ) ; case 13 : case 14 : case 15 : case 16 : return self :: poorManTranslate ( 'fts-shared' , 'Good afternoon' ) ; case 17 : case 18 : case 19 : return trim ( self :: poorManTranslate ( 'fts-shared' , '_Good afternoon' ) , '_' ) ; case 20 : case 21 : case 22 : case 23 : return self :: poorManTranslate ( 'fts-shared' , 'Good evening' ) ; default : return '' ; } }
11514	public function getNamedParams ( string $ category = null ) : array { switch ( $ category ) { case 'attribute' : return $ this -> request -> getAttributes ( ) ; case 'query' : return $ this -> request -> getQueryParams ( ) ; case 'uploaded_files' : return $ this -> request -> getUploadedFiles ( ) ; case 'parsed_body' : { $ body = $ this -> request -> getParsedBody ( ) ; if ( ! $ body ) { return [ ] ; } if ( is_array ( $ body ) ) { return $ body ; } if ( is_object ( $ body ) ) { return get_object_vars ( $ body ) ; } } return [ ] ; case 'server' : return $ this -> request -> getServerParams ( ) ; case 'cookie' : return $ this -> request -> getCookieParams ( ) ; } return [ ] ; }
4644	public function stop ( Job $ job , $ timeout = 10 ) { foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { try { $ this -> docker -> getContainerManager ( ) -> stop ( $ service -> getContainer ( ) , [ 't' => $ timeout ] ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) != 304 ) { throw $ e ; } } $ this -> docker -> getContainerManager ( ) -> remove ( $ service -> getContainer ( ) , [ 'v' => true , 'force' => true ] ) ; $ service -> setContainer ( null ) ; } } }
3196	public function getConsumedExtraTime ( $ tags = null , $ maxTime = 0 , $ target = TimePoint :: TARGET_SERVER ) { if ( $ maxTime ) { $ totalConsumed = $ this -> compute ( $ tags , $ target ) ; $ consumedExtraTime = $ totalConsumed - $ maxTime < 0 ? 0 : $ totalConsumed - $ maxTime ; $ this -> setConsumedExtraTime ( $ consumedExtraTime ) -> save ( ) ; } return $ this -> consumedExtraTime ; }
647	public function addCommentOnColumn ( $ table , $ column , $ comment ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addCommentOnColumn ( $ table , $ column , $ comment ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
3092	public function load ( ) { if ( ! isset ( $ this -> cache [ $ this -> testSessionId ] ) ) { $ encodedData = $ this -> getStorageService ( ) -> get ( $ this -> getUserKey ( ) , $ this -> getStorageKey ( ) ) ; \ common_Logger :: d ( sprintf ( 'QtiTimer: Loaded %d bytes from state storage' , strlen ( $ encodedData ) ) ) ; $ this -> cache [ $ this -> testSessionId ] = $ this -> getStorageFormat ( ) -> decode ( $ encodedData ) ; } return $ this -> cache [ $ this -> testSessionId ] ; }
719	public function time ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TIME , $ precision ) ; }
5379	protected function wrap ( $ text ) { $ text = str_replace ( "\r\r\n" , "\r\n" , str_replace ( "\n" , "\r\n" , $ text ) ) ; $ text = str_replace ( "\r\n\n" , "\r\n" , str_replace ( "\r" , "\r\n" , $ text ) ) ; if ( strncmp ( $ text , "\r\n" , strlen ( "\r\n" ) ) == 0 ) { $ text = substr ( $ text , strlen ( "\r\n" ) ) ; } if ( $ this -> wrapIsEnabled ( ) ) { return wordwrap ( $ text , ( integer ) $ this -> getAttribute ( 'cols' ) , "\r\n" ) ; } return $ text ; }
4911	protected function injectComponents ( array $ pages , $ routeMatch = null , $ router = null , $ request = null ) { if ( $ routeMatch ) { $ routeName = $ routeMatch -> getMatchedRouteName ( ) ; foreach ( $ pages as & $ page ) { if ( isset ( $ page [ 'active_on' ] ) && in_array ( $ routeName , ( array ) $ page [ 'active_on' ] ) ) { $ page [ 'active' ] = true ; } } } return parent :: injectComponents ( $ pages , $ routeMatch , $ router , $ request ) ; }
7295	public function send_mail ( $ to , $ subject = '' , $ message = '' , $ headers = array ( ) , $ attachments = array ( ) ) { if ( $ this -> options [ 'static_options' ] [ 'mail_to_chunking' ] [ 'chunking' ] === TRUE ) { $ send_next_group = array ( ) ; if ( array_key_exists ( 'send_next_group' , $ this -> options [ 'static_options' ] ) ) { $ object_id = $ this -> options [ 'static_options' ] [ 'object' ] [ 'id' ] ; $ send_next_group = $ this -> options [ 'static_options' ] [ 'send_next_group' ] [ $ object_id ] ; } if ( $ this -> options [ 'send_by_bcc' ] ) { $ headers [ 'Bcc' ] = $ this -> get_mail_to_chunk ( $ headers [ 'Bcc' ] , $ send_next_group ) ; } else { $ to = $ this -> get_mail_to_chunk ( $ to , $ send_next_group ) ; } } foreach ( $ headers as $ k => $ v ) { $ headers [ ] = $ k . ': ' . $ v ; unset ( $ headers [ $ k ] ) ; } return wp_mail ( $ to , $ subject , $ message , $ headers , $ attachments ) ; }
11386	public function exec ( $ calcId = null ) { if ( is_null ( $ calcId ) ) { $ calcId = $ this -> queryGetCalcId -> exec ( ) ; } if ( ! isset ( $ this -> cachedIds [ $ calcId ] ) ) { $ ids = [ ] ; $ where = \ Praxigento \ BonusHybrid \ Repo \ Data \ Registry \ SignUpDebit :: A_CALC_REF . '=' . ( int ) $ calcId ; $ rs = $ this -> daoRegistry -> get ( $ where ) ; foreach ( $ rs as $ one ) { $ ids [ ] = $ one -> getCustomerRef ( ) ; } $ this -> cachedIds [ $ calcId ] = $ ids ; } return $ this -> cachedIds [ $ calcId ] ; }
12336	public function changePasswordAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'change-password' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getChangePasswordForm ( ) ; $ form -> setObject ( $ this -> cmsAuthentication ( ) -> getIdentity ( ) ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ identity = $ this -> getUserService ( ) -> changePassword ( $ post ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/index/change-password-success' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
6094	public function isUtf8 ( ) { $ pattern = array ( ) ; $ pattern [ ] = "[\xC2-\xDF][\x80-\xBF]" ; $ pattern [ ] = "\xE0[\xA0-\xBF][\x80-\xBF]" ; $ pattern [ ] = "[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}" ; $ pattern [ ] = "\xED[\x80-\x9F][\x80-\xBF]" ; $ pattern [ ] = "\xF0[\x90-\xBF][\x80-\xBF]{2}" ; $ pattern [ ] = "[\xF1-\xF3][\x80-\xBF]{3}" ; $ pattern [ ] = "\xF4[\x80-\x8F][\x80-\xBF]{2}" ; return preg_match ( "%(?:" . implode ( "|" , $ pattern ) . ")+%xs" , $ this -> string ) ; }
11727	public function setTaxonomy_id ( $ value ) { if ( ! is_array ( $ value ) ) { $ value = [ $ value ] ; } foreach ( $ value as $ k => $ v ) { if ( is_object ( $ v ) ) { $ value [ $ k ] = $ v -> primaryKey ; } elseif ( is_array ( $ v ) ) { unset ( $ value [ $ k ] ) ; if ( isset ( $ v [ 'systemId' ] ) && isset ( $ v [ 'taxonomyType' ] ) ) { $ taxonomyType = Yii :: $ app -> collectors [ 'taxonomies' ] -> getOne ( $ v [ 'taxonomyType' ] ) ; if ( isset ( $ taxonomyType ) && ( $ taxonomy = $ taxonomyType -> getTaxonomy ( $ v [ 'systemId' ] ) ) ) { $ value [ $ k ] = $ taxonomy -> primaryKey ; } } } } $ this -> _taxonomy_id = $ value ; }
10089	function addAttachmentFromBase64Data ( $ filename , $ mimetype , $ contents ) { $ attachment = new Attachment ( $ filename , $ mimetype , $ contents ) ; $ this -> attachments [ ] = $ attachment ; }
1931	public function attachFileFromString ( $ strContent , $ strFilename , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( new \ Swift_Attachment ( $ strContent , $ strFilename , $ strMime ) ) ; }
11235	protected function checkReferenceLoop ( $ loop , $ name ) { if ( $ loop > 20 ) { throw new RuntimeException ( Message :: get ( Message :: MSG_REF_LOOP , $ name ) , Message :: MSG_REF_LOOP ) ; } }
12913	public function cache ( $ flag , $ expiry = null ) { $ this -> cache = ( boolean ) $ flag ; if ( ! is_null ( $ expiry ) ) { $ this -> cacheExpiry = $ expiry ; } return $ this ; }
3198	protected function checkTimestampCoherence ( $ points , $ timestamp ) { foreach ( $ points as $ point ) { if ( $ point -> getTimestamp ( ) > $ timestamp ) { throw new InconsistentRangeException ( 'A new TimePoint cannot be set before an existing one!' ) ; } } }
12058	public function getPossibleTargets ( ) { if ( is_null ( $ this -> _possibleTargets ) ) { $ this -> _possibleTargets = [ ] ; if ( $ this -> canEndRelation ( ) ) { $ this -> _possibleTargets [ ] = 'end_relationship' ; } if ( $ this -> canDeleteRelation ( ) ) { $ this -> _possibleTargets [ ] = 'delete_relationship' ; } if ( $ this -> canArchiveObject ( ) ) { if ( $ this -> object -> archived ) { $ this -> _possibleTargets [ ] = 'unarchive_object' ; } else { $ this -> _possibleTargets [ ] = 'archive_object' ; } } if ( $ this -> canDeleteObject ( ) ) { $ this -> _possibleTargets [ ] = 'delete_object' ; } } return $ this -> _possibleTargets ; }
4420	public function onKernelBuilt ( PostBuildKernelEvent $ event ) { $ currentRequest = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ currentRequest === null || ! $ event -> getKernelHandler ( ) instanceof ezpWebBasedKernelHandler || $ this -> configResolver -> getParameter ( 'legacy_mode' ) === true || ! $ this -> isUserAuthenticated ( ) ) { return ; } $ currentRequest -> getSession ( ) -> set ( 'eZUserLoggedInID' , $ this -> repository -> getCurrentUser ( ) -> id ) ; }
12517	public static function move ( $ src , $ dest , $ overwrite = false ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; if ( ! Folder :: exists ( $ src ) ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' : ' . $ src ) ; } if ( Folder :: exists ( $ dest ) ) { throw new Exception ( Helper :: getTranslation ( 'ALREADY_EXISTS' ) . ' : ' . $ dest ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> rename ( $ src , $ dest , $ overwrite ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_RENAMING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
3257	public function scopeWhereSKU ( $ query , $ sku ) { return $ query -> join ( config ( 'shop.item_table' ) , config ( 'shop.item_table' ) . '.order_id' , '=' , $ this -> table . '.id' ) -> where ( config ( 'shop.item_table' ) . '.sku' , $ sku ) ; }
9130	public static function create ( $ name , SymfonyRoute $ route , $ method , $ description = '' ) { return new static ( $ name , $ route , $ method , $ description ) ; }
4563	public function preUpdate ( PreUpdateEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Parameter ) { return ; } $ entity -> setValue ( serialize ( $ entity -> getValue ( ) ) ) ; }
11800	public function substitution ( $ search , $ replace ) { $ this -> body = str_replace ( $ search , $ replace , $ this -> body ) ; return $ this -> body ; }
3129	private function loadItemData ( $ itemRef , $ path ) { $ cacheKey = $ itemRef . $ path ; if ( ! empty ( $ cacheKey ) && isset ( $ this -> dataCache [ $ itemRef . $ path ] ) ) { return $ this -> dataCache [ $ itemRef . $ path ] ; } $ directoryIds = explode ( '|' , $ itemRef ) ; if ( count ( $ directoryIds ) < 3 ) { if ( is_scalar ( $ itemRef ) ) { $ itemRefInfo = gettype ( $ itemRef ) . ': ' . strval ( $ itemRef ) ; } elseif ( is_object ( $ itemRef ) ) { $ itemRefInfo = gettype ( $ itemRef ) . ': ' . get_class ( $ itemRef ) ; } else { $ itemRefInfo = gettype ( $ itemRef ) ; } throw new \ common_exception_InconsistentData ( "The itemRef (value = '${itemRefInfo}') is not formatted correctly." ) ; } $ itemUri = $ directoryIds [ 0 ] ; $ userDataLang = \ common_session_SessionManager :: getSession ( ) -> getDataLanguage ( ) ; $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 2 ] ) ; if ( $ directory -> has ( $ userDataLang ) ) { $ lang = $ userDataLang ; } elseif ( $ directory -> has ( DEFAULT_LANG ) ) { \ common_Logger :: d ( $ userDataLang . ' is not part of compilation directory for item : ' . $ itemUri . ' use ' . DEFAULT_LANG ) ; $ lang = DEFAULT_LANG ; } else { throw new \ common_Exception ( 'item : ' . $ itemUri . 'is neither compiled in ' . $ userDataLang . ' nor in ' . DEFAULT_LANG ) ; } try { $ content = $ directory -> read ( $ lang . DIRECTORY_SEPARATOR . $ path ) ; $ assetService = $ this -> getServiceManager ( ) -> get ( ItemAssetsReplacement :: SERVICE_ID ) ; $ jsonContent = json_decode ( $ content , true ) ; $ jsonAssets = [ ] ; if ( isset ( $ jsonContent [ 'assets' ] ) ) { foreach ( $ jsonContent [ 'assets' ] as $ type => $ assets ) { foreach ( $ assets as $ key => $ asset ) { $ jsonAssets [ $ type ] [ $ key ] = $ assetService -> postProcessAssets ( $ asset ) ; } } $ jsonContent [ "assets" ] = $ jsonAssets ; } $ this -> dataCache [ $ cacheKey ] = $ jsonContent ; return $ this -> dataCache [ $ cacheKey ] ; } catch ( \ FileNotFoundException $ e ) { throw new \ tao_models_classes_FileNotFoundException ( $ path . ' for item reference ' . $ itemRef ) ; } catch ( \ League \ Flysystem \ FileNotFoundException $ e ) { throw new \ tao_models_classes_FileNotFoundException ( $ path . ' for item reference ' . $ itemRef ) ; } }
10592	public function display ( $ level = 0 ) { $ value = $ this -> getContent ( ) ; if ( null === $ value ) { $ value = 'null' ; } elseif ( is_object ( $ value ) ) { $ value = get_class ( $ value ) ; } elseif ( is_array ( $ value ) ) { $ value = 'Array' ; } $ ret = str_repeat ( ' ' , $ level * 4 ) . $ value . "\n" ; $ children = $ this -> getChildren ( ) ; foreach ( $ children as $ child ) { $ ret .= $ child -> display ( $ level + 1 ) ; } return $ ret ; }
10382	protected static function save_external_file ( $ url , $ path ) { $ data = file_get_contents ( $ url ) ; return ( $ data && self :: save_file ( $ path , $ data ) ) ? $ data : '' ; }
7309	public static function now ( $ timezone = null ) { $ now = explode ( ' ' , microtime ( ) ) ; $ unix = $ now [ 1 ] ; $ micro = Time :: sec ( $ now [ 0 ] ) ; $ jd = ( $ unix / 86400.0 ) + static :: UJD ; if ( $ timezone == null ) { $ timezone = TimeZone :: UTC ( ) ; } if ( is_string ( $ timezone ) ) { $ timezone = TimeZone :: parse ( $ timezone ) ; } return static :: jd ( $ jd ) -> add ( $ micro ) -> setTimezone ( $ timezone ) ; }
8277	public function onConfigLoaded ( array & $ config ) { $ config [ self :: PLUGIN_NAME ] = $ this -> loadDefaultConfig ( $ config ) ; $ this -> config = $ config [ self :: PLUGIN_NAME ] ; $ this -> createContainer ( ) ; $ this -> initLogger ( ) ; }
4240	public function onConfig ( Event $ event ) { $ cfg = $ event [ 'config' ] ; if ( ! isset ( $ cfg [ 'debug' ] ) ) { return ; } $ cfg = $ cfg [ 'debug' ] ; if ( isset ( $ cfg [ 'file' ] ) ) { $ this -> debug -> addPlugin ( $ this -> debug -> output -> file ) ; } if ( isset ( $ cfg [ 'onBootstrap' ] ) ) { if ( ! $ this -> debug -> parentInstance ) { $ this -> debug -> eventManager -> subscribe ( 'debug.bootstrap' , $ cfg [ 'onBootstrap' ] ) ; } else { \ call_user_func ( $ cfg [ 'onBootstrap' ] , new Event ( $ this -> debug ) ) ; } } if ( isset ( $ cfg [ 'onLog' ] ) ) { if ( isset ( $ this -> cfg [ 'onLog' ] ) ) { $ this -> debug -> eventManager -> unsubscribe ( 'debug.log' , $ this -> cfg [ 'onLog' ] ) ; } $ this -> debug -> eventManager -> subscribe ( 'debug.log' , $ cfg [ 'onLog' ] ) ; } if ( ! static :: $ profilingEnabled ) { $ cfg = $ this -> debug -> getCfg ( 'debug/*' ) ; if ( $ cfg [ 'enableProfiling' ] && $ cfg [ 'collect' ] ) { static :: $ profilingEnabled = true ; $ pathsExclude = array ( __DIR__ , ) ; FileStreamWrapper :: register ( $ pathsExclude ) ; } } }
4667	public function setRenderView ( $ viewPath , $ params ) { $ this -> setViewEngines ( [ '.volt' => function ( $ view = null ) { $ volt = new Volt ( $ view ) ; $ volt -> setOptions ( [ 'compiledPath' => APP_PATH . '/cache/volt/' , 'compiledSeparator' => '_' , 'compileAlways' => ! $ this -> getDI ( ) -> get ( 'config' ) -> application -> production , ] ) ; return $ volt ; } ] ) ; $ view = $ this -> getView ( ) ; $ content = $ view -> render ( $ viewPath , $ params ) ; return $ content ; }
406	public function getIsFlash ( ) { $ userAgent = $ this -> headers -> get ( 'User-Agent' , '' ) ; return stripos ( $ userAgent , 'Shockwave' ) !== false || stripos ( $ userAgent , 'Flash' ) !== false ; }
8713	public function orWhereTranslated ( $ column , $ operator = null , $ value = null ) { return $ this -> whereTranslated ( $ column , $ operator , $ value , 'or' ) ; }
2066	public function getPageTypes ( Contao \ DataContainer $ dc ) { $ arrOptions = array ( ) ; foreach ( array_keys ( $ GLOBALS [ 'TL_PTY' ] ) as $ pty ) { if ( $ pty == 'root' && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { continue ; } if ( $ pty == $ dc -> value || $ this -> User -> hasAccess ( $ pty , 'alpty' ) ) { $ arrOptions [ ] = $ pty ; } } return $ arrOptions ; }
8131	protected function removeNodeFilter ( Twig_Node $ node ) { if ( $ node instanceof Twig_Node_Expression_Filter ) { return $ this -> removeNodeFilter ( $ node -> getNode ( 'node' ) ) ; } return $ node ; }
12711	public function register ( $ alias , $ abstract ) { if ( ! is_string ( $ alias ) || ! is_string ( $ abstract ) ) { throw new \ InvalidArgumentException ( sprintf ( "Parameter 1 and 2 of %s must be a string." , __METHOD__ ) ) ; } if ( ! isset ( $ this -> aliases [ $ alias ] ) ) { $ this -> aliases [ $ alias ] = $ this -> make ( $ abstract ) ; } return $ this ; }
8899	public function update_many ( $ primary_values , $ data ) { $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ result = $ this -> _database -> where_in ( $ this -> primary_key , $ primary_values ) -> set ( $ data ) -> update ( $ this -> _table ) ; $ this -> trigger ( 'after_update' , array ( $ data , $ result ) ) ; return $ result ; } return FALSE ; }
12703	public function publishAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "page_manager" => $ app [ "red_kite_cms.page_manager" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: publish ( $ options ) ; }
10965	public static function getStandardPort ( $ scheme = null ) { if ( $ scheme === null ) { $ scheme = self :: getScheme ( ) ; } if ( isset ( self :: $ schemes [ $ scheme ] ) ) { return self :: $ schemes [ $ scheme ] ; } return 0 ; }
5354	public function getAuthenticationData ( $ method ) { if ( ! $ this -> supportsAuthentication ( $ method ) ) { return null ; } $ authentication = $ this -> getSupportedAuthentication ( ) ; return $ authentication [ $ method ] ; }
5227	public function bindList ( $ name ) { if ( ! isset ( $ this -> listBindings [ $ name ] ) ) { $ this -> listBindings [ $ name ] = $ this -> addBinding ( new ListBinding ( $ name ) ) ; } return $ this -> listBindings [ $ name ] ; }
2616	private function prepareCustomVariables ( ) { if ( $ this -> validationServiceId != null ) { $ serviceId = $ this -> validationServiceId ; } else { $ serviceId = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_SERVICE_ID ) ; } $ customVars = [ 'cd1' => $ serviceId , 'cd2' => ( $ this -> isApiKeyValid ( ) ) ? 'yes' : 'no' , 'cd3' => $ this -> getWebsiteName ( ) , 'cd4' => $ this -> request -> getServer ( 'HTTP_HOST' ) , 'cd5' => $ this -> getSiteLocation ( ) , 'cd6' => $ this -> helper -> getModuleVersion ( ) , 'cd7' => $ this -> config -> getCID ( ) , 'cd8' => 'fastlyext' ] ; return $ customVars ; }
10422	public function addToInsertList ( $ key , $ value , $ isString = true ) { $ this -> sqlInsertList [ $ key ] = [ 'value' => $ value , 'string' => $ isString , ] ; }
2207	protected function compileYearlyMenu ( ) { $ arrData = array ( ) ; $ arrAllEvents = $ this -> getAllEvents ( $ this -> cal_calendar , 0 , 2145913200 ) ; foreach ( $ arrAllEvents as $ intDay => $ arrDay ) { foreach ( $ arrDay as $ arrEvents ) { $ arrData [ substr ( $ intDay , 0 , 4 ) ] += \ count ( $ arrEvents ) ; } } ( $ this -> cal_order == 'ascending' ) ? ksort ( $ arrData ) : krsort ( $ arrData ) ; $ arrItems = array ( ) ; $ count = 0 ; $ limit = \ count ( $ arrData ) ; foreach ( $ arrData as $ intYear => $ intCount ) { $ intDate = $ intYear ; $ quantity = sprintf ( ( ( $ intCount < 2 ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entry' ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entries' ] ) , $ intCount ) ; $ arrItems [ $ intYear ] [ 'date' ] = $ intDate ; $ arrItems [ $ intYear ] [ 'link' ] = $ intYear ; $ arrItems [ $ intYear ] [ 'href' ] = $ this -> strLink . '?year=' . $ intDate ; $ arrItems [ $ intYear ] [ 'title' ] = StringUtil :: specialchars ( $ intYear . ' (' . $ quantity . ')' ) ; $ arrItems [ $ intYear ] [ 'class' ] = trim ( ( ( ++ $ count == 1 ) ? 'first ' : '' ) . ( ( $ count == $ limit ) ? 'last' : '' ) ) ; $ arrItems [ $ intYear ] [ 'isActive' ] = ( Input :: get ( 'year' ) == $ intDate ) ; $ arrItems [ $ intYear ] [ 'quantity' ] = $ quantity ; } $ this -> Template -> yearly = true ; $ this -> Template -> items = $ arrItems ; $ this -> Template -> showQuantity = ( $ this -> cal_showQuantity != '' ) ? true : false ; }
793	public function getAttributes ( $ names = null , $ except = [ ] ) { $ values = [ ] ; if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } foreach ( $ names as $ name ) { $ values [ $ name ] = $ this -> $ name ; } foreach ( $ except as $ name ) { unset ( $ values [ $ name ] ) ; } return $ values ; }
2271	public function getUuid ( ) { static $ ids ; if ( empty ( $ ids ) ) { $ statement = $ this -> resConnection -> executeQuery ( implode ( ' UNION ALL ' , array_fill ( 0 , 10 , "SELECT UNHEX(REPLACE(UUID(), '-', '')) AS uuid" ) ) ) ; $ ids = $ statement -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; } return array_pop ( $ ids ) ; }
10547	public function setResolver ( Resolver $ resolver ) { $ this -> resolver = $ resolver ; $ this -> setVariable ( 'resolver' , $ resolver ) ; return $ this ; }
7613	public function sendEmail ( ) { $ user = User :: findOne ( [ 'status' => User :: STATUS_ACTIVE , 'email' => $ this -> email , ] ) ; if ( $ user ) { $ user -> generatePasswordResetToken ( ) ; if ( $ user -> save ( ) ) { return \ Yii :: $ app -> mailer -> compose ( '@auth/views/mail/passwordResetToken' , [ 'user' => $ user ] ) -> setFrom ( [ \ Yii :: $ app -> getModule ( 'auth' ) -> supportEmail => \ Yii :: $ app -> name ] ) -> setTo ( $ this -> email ) -> setSubject ( Yii :: t ( 'auth.reset-password' , 'Password reset for {name}' , [ 'name' => \ Yii :: $ app -> name ] ) ) -> send ( ) ; } } return false ; }
10717	public function newModel ( ) { $ model = app ( ) -> make ( $ this -> modelClass ) ; if ( ! $ model instanceof Model ) { throw new RepositoryException ( "Class {$this->modelClass} must be an instance of Illuminate\\Database\\Eloquent\\Model" ) ; } return $ model ; }
1875	private function getBundlePackageName ( string $ className ) : string { if ( 'Bundle' === substr ( $ className , - 6 ) ) { $ className = substr ( $ className , 0 , - 6 ) ; } return Container :: underscore ( $ className ) ; }
6597	protected function getDescription ( array $ lines ) { $ description = '' ; $ summaryFound = false ; $ summaryPassed = false ; foreach ( $ lines as $ line ) { if ( $ line && ! $ summaryPassed ) { $ summaryFound = true ; if ( substr ( trim ( $ line ) , - 1 ) == '.' ) { $ summaryPassed = true ; } continue ; } if ( ! $ line && $ summaryFound && ! $ summaryPassed ) { $ summaryPassed = true ; continue ; } if ( $ line && $ line [ 0 ] == '@' ) { break ; } if ( $ line && $ summaryPassed ) { $ description .= $ line . "\n" ; } } return trim ( $ description ) ; }
5400	protected function truncateHost ( $ host ) { $ tlds = SimpleUrl :: getAllTopLevelDomains ( ) ; if ( preg_match ( '/[a-z\-]+\.(' . $ tlds . ')$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } elseif ( preg_match ( '/[a-z\-]+\.[a-z\-]+\.[a-z\-]+$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } return false ; }
12830	public function compileSource ( $ source ) { $ source = $ this -> stripComments ( $ source ) ; $ source = $ this -> saveLiterals ( $ source ) ; $ result = preg_replace_callback ( '#' . $ this -> _config [ 'tokenStart' ] . '(.*)' . $ this -> _config [ 'tokenEnd' ] . '#smU' , array ( $ this , 'onTokenFound' ) , $ source ) ; $ result = $ this -> restoreLiterals ( $ result ) ; return $ result ; }
12240	public function getElementsByClassName ( $ class ) { if ( strpos ( $ class , '"' ) !== false || strpos ( $ class , "'" ) !== false ) { return array ( ) ; } $ xpath = './/*[contains(concat(" ", @class, " "), " ' . htmlspecialchars ( $ class ) . ' ")]' ; return $ this -> xpath ( $ xpath ) ; }
6437	public function getLoginStartUrl ( $ redirecturl ) { $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ request_token = $ connection -> oauth ( 'oauth/request_token' , array ( 'oauth_callback' => $ redirecturl ) ) ; $ this -> request_token = array ( ) ; $ this -> request_token [ 'oauth_token' ] = $ request_token [ 'oauth_token' ] ; $ this -> request_token [ 'oauth_token_secret' ] = $ request_token [ 'oauth_token_secret' ] ; return $ connection -> url ( 'oauth/authorize' , array ( 'oauth_token' => $ request_token [ 'oauth_token' ] ) ) ; }
3695	protected function getBreadcrumbElements ( EnvironmentInterface $ environment , BreadcrumbStore $ elements ) { if ( $ this -> parent ) { $ this -> parent -> getBreadcrumbElements ( $ environment , $ elements ) ; } }
12878	public function setValue ( $ value ) { $ this -> value = $ value ; if ( is_array ( $ value ) && array_key_exists ( 'start' , $ value ) && array_key_exists ( 'end' , $ value ) ) { $ start = ( float ) $ value [ 'start' ] ; $ end = ( float ) $ value [ 'end' ] ; if ( $ start <= $ end ) { $ this -> startElement -> setValue ( $ start ) ; $ this -> endElement -> setValue ( $ end ) ; } } return $ this ; }
1625	public static function updateAllCounters ( $ counters , $ condition = null ) { if ( empty ( $ counters ) ) { return 0 ; } $ db = static :: getDb ( ) ; $ n = 0 ; foreach ( self :: fetchPks ( $ condition ) as $ pk ) { $ key = static :: keyPrefix ( ) . ':a:' . static :: buildKey ( $ pk ) ; foreach ( $ counters as $ attribute => $ value ) { $ db -> executeCommand ( 'HINCRBY' , [ $ key , $ attribute , $ value ] ) ; } $ n ++ ; } return $ n ; }
8033	public function loadView ( $ viewName , $ data = array ( ) , $ mergeData = array ( ) ) { $ this -> htmlContent = View :: make ( $ viewName , $ data , $ mergeData ) ; return $ this ; }
7534	function getPlainTextUTF8 ( ) { $ txt = $ this -> toString ( true , true , true ) ; $ enc = $ this -> getEncoding ( ) ; if ( $ enc !== false ) { $ txt = mb_convert_encoding ( $ txt , 'UTF-8' , $ enc ) ; } return preg_replace ( '`\s+`' , ' ' , html_entity_decode ( $ txt , ENT_QUOTES , 'UTF-8' ) ) ; }
4297	public function clear ( $ flags = self :: CLEAR_LOG ) { array ( $ flags ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'flags' => self :: CLEAR_LOG ) , array ( 'flags' => 'bitmask' ) ) ; $ event = $ this -> methodClear -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ) ; $ this -> setLogDest ( 'log' ) ; $ collect = $ this -> cfg [ 'collect' ] ; $ this -> cfg [ 'collect' ] = true ; if ( $ event [ 'log' ] ) { $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; } elseif ( $ event [ 'publish' ] ) { $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ event ) ; } $ this -> cfg [ 'collect' ] = $ collect ; $ this -> setLogDest ( 'auto' ) ; }
11906	public function handle ( ServerRequestInterface $ request ) : ResponseInterface { $ msg = "This is the default request handler. This means no middleware produced a response before hitting it." ; $ contents = json_encode ( [ 'type' => MiddlewareStackExhaustedException :: class , 'message' => $ msg , ] ) ; $ response = $ this -> factory -> createResponse ( 404 ) -> withHeader ( 'Content-type' , 'application/json' ) ; $ response -> getBody ( ) -> write ( $ contents ) ; return $ response ; }
6484	private static function filterQueryString ( ? string $ queryString ) : ? string { if ( $ queryString === null ) { return null ; } return preg_replace_callback ( '/(?:[^a-zA-Z0-9_\-\.~!\$&\'\(\)\*\+,;=%:@\/\?]+|%(?![A-Fa-f0-9]{2}))/' , function ( $ match ) { return rawurlencode ( $ match [ 0 ] ) ; } , $ queryString ) ; }
4674	public function addCallback ( $ callback , $ data = [ ] , $ region = "main" , $ sort = 0 ) { $ view = new View ( ) ; $ view -> set ( [ "callback" => $ callback ] , $ data , $ sort , "callback" ) ; $ this -> views [ $ region ] [ ] = $ view ; return $ this ; }
8790	public function linkAsset ( $ url , $ title = null , $ attributes = [ ] , $ secure = null ) { $ url = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> link ( $ url , $ title ? : $ url , $ attributes , $ secure ) ; }
4755	public function stopProfiling ( ) { if ( ! $ this -> profiling ) { return false ; } $ this -> profiling = false ; $ xhprof_data = xhprof_disable ( ) ; if ( is_array ( $ xhprof_data ) ) { $ this -> parser -> parse ( $ xhprof_data ) ; } foreach ( $ this -> probes as $ probe ) { $ name = $ probe -> getName ( ) ; if ( $ probe -> isTimingProbe ( ) ) { $ this -> timers [ $ name ] = $ probe -> getTime ( ) ; } if ( $ probe -> isCallsProbe ( ) ) { $ this -> counters [ $ name ] = $ probe -> getCount ( ) ; } } return true ; }
6054	public function createFolder ( Folder $ folder , $ parentId = 0 , $ inheritAccess = null ) { $ parameters = [ 'query' => [ 'parentId' => $ parentId ] , 'body' => json_encode ( [ 'folder' => $ folder , 'inheritAccess' => $ inheritAccess ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
4685	public function select ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> select = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'select' ] = $ args ; return $ this ; }
877	private function skipClass ( Tokens $ tokens , $ classIndex , $ classOpenIndex , $ classCloseIndex ) { $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ classIndex ) ] ; if ( ! $ prevToken -> isGivenKind ( T_FINAL ) ) { return true ; } for ( $ index = $ classIndex ; $ index < $ classOpenIndex ; ++ $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_EXTENDS ) ) { return true ; } } $ useIndex = $ tokens -> getNextTokenOfKind ( $ classIndex , [ [ CT :: T_USE_TRAIT ] ] ) ; return $ useIndex && $ useIndex < $ classCloseIndex ; }
4623	public function execute ( Command $ command ) { $ response = $ this -> getActiveNode ( ) -> execute ( $ command , $ this -> api ) ; if ( empty ( $ response ) && count ( $ this -> nodes ) > 1 && $ this -> attempts < $ this -> getConfigValue ( 'max_connect_attempts' ) ) { $ response = $ this -> pickNewNode ( ) -> execute ( $ command ) ; } elseif ( empty ( $ response ) && $ this -> attempts >= $ this -> getConfigValue ( 'max_connect_attempts' ) ) { throw new Exception ( 'Nodes unreachable. Error Msg: ' . $ this -> api -> getError ( ) ) ; } elseif ( $ response == false ) { throw new Exception ( 'Command failed to execute against Riak. Error Msg: ' . $ this -> api -> getError ( ) ) ; } return $ response ; }
11627	public function lock ( ) { $ lock_file = $ this -> getLockFile ( ) ; if ( file_exists ( $ lock_file ) ) { $ this -> pid = file_get_contents ( $ lock_file ) ; if ( $ this -> isrunning ( ) ) { error_log ( "==" . $ this -> pid . "== Already in progress..." ) ; return false ; } else error_log ( "==" . $ this -> pid . "== Previous job died abruptly..." ) ; } $ this -> pid = getmypid ( ) ; $ s = file_put_contents ( $ lock_file , $ this -> pid ) ; error_log ( "==" . $ this -> pid . "== Lock acquired, processing the job..." ) ; return $ this -> pid ; }
4133	public function initializeObject ( $ obj ) { if ( $ obj instanceof PersistentCollection ) { $ obj -> initialize ( ) ; } else if ( $ obj instanceof Proxy \ Proxy ) { $ obj -> __doctrineLoad__ ( ) ; } }
469	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } return $ model ; }
10455	public function consume ( ItemPipelineEvent $ event ) { if ( ! $ this -> setItem ( $ event ) ) { return ; } $ this -> log ( sprintf ( 'Start update single document of type %s id: %s' , get_class ( $ this -> getItem ( ) -> getDocument ( ) ) , $ this -> getItem ( ) -> getDocument ( ) -> getId ( ) ) ) ; if ( ! $ this -> persistDocument ( ) ) { return ; } ; $ this -> log ( 'End an update of a single document.' ) ; }
12655	public function addTextContainer ( $ name , $ content , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { throw new \ Exception ( "Text container name already used." ) ; } $ this -> contents [ $ language ] [ $ name ] = array ( 'id' => $ name , 'name' => $ name , 'content' => $ content , 'outdated' => false ) ; $ this -> writeTextsToFile ( $ language ) ; if ( $ language === $ this -> baseLang ) { $ this -> setExtraLanguagesOutdated ( $ name , $ content ) ; } return $ this -> contents [ $ language ] [ $ name ] ; }
11410	public function update ( $ tagId , $ name ) { $ params = [ 'tag' => [ 'id' => $ tagId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
9663	public static function registerWriter ( $ writerType , $ writerClass ) { if ( ! is_a ( $ writerClass , Writer \ IWriter :: class , true ) ) { throw new Writer \ Exception ( 'Registered writers must implement ' . Writer \ IWriter :: class ) ; } self :: $ writers [ $ writerType ] = $ writerClass ; }
3727	private function sanitizeConnection ( $ connection ) { if ( $ connection instanceof Connection ) { return $ connection ; } if ( $ connection instanceof Database ) { @ trigger_error ( '"' . __METHOD__ . '" now accepts doctrine instances - ' . 'passing Contao database instances is deprecated.' , E_USER_DEPRECATED ) ; $ reflection = new \ ReflectionProperty ( Database :: class , 'resConnection' ) ; $ reflection -> setAccessible ( true ) ; return $ reflection -> getValue ( $ connection ) ; } if ( null === $ connection ) { @ trigger_error ( 'You should pass a doctrine database connection to "' . __METHOD__ . '".' , E_USER_DEPRECATED ) ; $ connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; } if ( ! ( $ connection instanceof Connection ) ) { throw new \ RuntimeException ( 'Could not obtain doctrine connection.' ) ; } return $ connection ; }
4076	protected function getMetaModelName ( $ nameOrId ) { return isset ( $ this -> tableMap [ $ nameOrId ] ) ? $ this -> tableMap [ $ nameOrId ] : $ nameOrId ; }
207	public static function confirm ( $ message , $ default = false ) { while ( true ) { static :: stdout ( $ message . ' (yes|no) [' . ( $ default ? 'yes' : 'no' ) . ']:' ) ; $ input = trim ( static :: stdin ( ) ) ; if ( empty ( $ input ) ) { return $ default ; } if ( ! strcasecmp ( $ input , 'y' ) || ! strcasecmp ( $ input , 'yes' ) ) { return true ; } if ( ! strcasecmp ( $ input , 'n' ) || ! strcasecmp ( $ input , 'no' ) ) { return false ; } } }
2474	public function bulkIndexContent ( array $ contentObjects ) { $ documents = array ( ) ; foreach ( $ contentObjects as $ content ) { try { $ documents [ ] = $ this -> mapper -> mapContentBlock ( $ content ) ; } catch ( NotFoundException $ ex ) { } } if ( ! empty ( $ documents ) ) { $ this -> gateway -> bulkIndexDocuments ( $ documents ) ; } }
6004	public function setCategories ( array $ categories ) { $ this -> categories = [ ] ; foreach ( $ categories as $ item ) { $ this -> addCategoryResponse ( $ item ) ; } return $ this ; }
12378	public function database ( Container $ application ) { $ config = $ this -> config ; $ dbName = $ application -> input -> getString ( "dbname" , "" , "post" ) ; $ dbPass = $ application -> input -> getString ( "dbpassword" , "" , "post" ) ; $ dbHost = $ application -> input -> getString ( "dbhost" , "" , "post" ) ; $ dbPref = $ application -> input -> getString ( "dbtableprefix" , "" , "post" ) ; $ dbUser = $ application -> input -> getString ( "dbusername" , "" , "post" ) ; $ dbDriver = $ application -> input -> getString ( "dbdriver" , "MySQLi" , "post" ) ; $ dbPort = $ application -> input -> getInt ( "dbport" , "" , "post" ) ; if ( empty ( $ dbName ) ) { throw new \ Exception ( t ( "Database Name is required to proceed." ) ) ; return false ; } if ( empty ( $ dbDriver ) ) { throw new \ Exception ( t ( "Database Driver Type is required to proceed." ) ) ; return false ; } if ( empty ( $ dbUser ) ) { throw new \ Exception ( t ( "Database username is required to proceed" ) ) ; return false ; } if ( empty ( $ dbHost ) ) { throw new \ Exception ( t ( "Please provide a link to your database host. If using SQLite, provide a path to the SQLite database as host" ) ) ; return false ; } $ config -> set ( "setup.database.host" , $ dbHost ) ; $ config -> set ( "setup.database.prefix" , $ dbPref ) ; $ config -> set ( "setup.database.user" , $ dbUser ) ; $ config -> set ( "setup.database.password" , $ dbPass ) ; $ config -> set ( "setup.database.name" , $ dbName ) ; $ config -> set ( "setup.database.driver" , strtolower ( $ dbDriver ) ) ; $ config -> set ( "setup.database.port" , intval ( $ dbPort ) ) ; try { $ application -> createInstance ( "database" , [ $ application -> config -> get ( "setup.database.driver" ) , $ application -> config -> get ( "setup.database" ) ] ) ; } catch ( Exception $ exception ) { return false ; } $ schema = new Schema ( ) ; if ( ! $ schema -> createTables ( $ application -> database ) ) { echo "wtf" ; return false ; } $ encryptor = $ this -> encryptor ; $ encryptKey = $ encryptor -> generateKey ( time ( ) . getRandomString ( 5 ) ) ; $ config -> set ( "setup.encrypt.key" , $ encryptKey ) ; if ( ! $ config -> saveParams ( ) ) { throw new Exception ( "could not save config" ) ; return false ; } return true ; }
11040	function leaf_path_walk ( $ elements , $ rank , $ ptype , & $ i , $ cvalue ) { if ( count ( $ elements ) == 1 ) { $ elt [ $ ptype . ':' . $ i . ':' . $ elements [ 0 ] . ':' . $ cvalue ] = '' ; } else { $ element1 = array_shift ( $ elements ) ; $ elt [ _ETS_TEMPLATE . ':' . $ i . '.' . $ rank . ':' . $ element1 ] = $ this -> leaf_path_walk ( $ elements , $ rank + 1 , $ ptype , $ i , $ cvalue ) ; } return $ elt ; }
1175	protected function jsConvertRules ( $ attribute , $ rules , $ includeRemote ) { $ jsRules = [ ] ; foreach ( $ rules as $ rawRule ) { list ( $ rule , $ parameters ) = $ this -> validator -> parseRule ( $ rawRule ) ; list ( $ jsAttribute , $ jsRule , $ jsParams ) = $ this -> rules -> getRule ( $ attribute , $ rule , $ parameters , $ rawRule ) ; if ( $ this -> isValidatable ( $ jsRule , $ includeRemote ) ) { $ jsRules [ $ jsAttribute ] [ $ jsRule ] [ ] = [ $ rule , $ jsParams , $ this -> messages -> getMessage ( $ attribute , $ rule , $ parameters ) , $ this -> validator -> isImplicit ( $ rule ) , ] ; } } return $ jsRules ; }
4369	public function buildTable ( $ rows , $ options = array ( ) ) { $ options = \ array_merge ( array ( 'attribs' => array ( ) , 'caption' => null , 'columns' => array ( ) , 'totalCols' => array ( ) , ) , $ options ) ; if ( \ is_string ( $ options [ 'attribs' ] ) ) { $ options [ 'attribs' ] = array ( 'class' => $ options [ 'attribs' ] , ) ; } if ( $ this -> debug -> abstracter -> isAbstraction ( $ rows ) && $ rows [ 'traverseValues' ] ) { $ options [ 'caption' ] .= ' (' . $ this -> markupClassname ( $ rows [ 'className' ] , 'span' , array ( 'title' => $ rows [ 'phpDoc' ] [ 'summary' ] ? : null , ) ) . ')' ; $ options [ 'caption' ] = \ trim ( $ options [ 'caption' ] ) ; $ rows = $ rows [ 'traverseValues' ] ; } $ keys = $ options [ 'columns' ] ? : $ this -> debug -> methodTable -> colKeys ( $ rows ) ; $ this -> tableInfo = array ( 'colClasses' => \ array_fill_keys ( $ keys , null ) , 'haveObjRow' => false , 'totals' => \ array_fill_keys ( $ options [ 'totalCols' ] , null ) , ) ; $ tBody = '' ; foreach ( $ rows as $ k => $ row ) { $ tBody .= $ this -> buildTableRow ( $ row , $ keys , $ k ) ; } if ( ! $ this -> tableInfo [ 'haveObjRow' ] ) { $ tBody = \ str_replace ( '<td class="t_classname"></td>' , '' , $ tBody ) ; } return $ this -> debug -> utilities -> buildTag ( 'table' , $ options [ 'attribs' ] , "\n" . ( $ options [ 'caption' ] ? '<caption>' . $ options [ 'caption' ] . '</caption>' . "\n" : '' ) . $ this -> buildTableHeader ( $ keys ) . '<tbody>' . "\n" . $ tBody . '</tbody>' . "\n" . $ this -> buildTableFooter ( $ keys ) ) ; }
11764	protected function handleStage ( & $ stages , $ stage ) { if ( $ stage instanceof Pipeline ) { $ stages = array_merge ( $ stages , $ stage -> stages ( ) ) ; } elseif ( $ stage instanceof MiddlewareInterface ) { $ stages [ ] = $ stage ; } elseif ( $ stage instanceof RequestHandlerInterface ) { $ stages [ ] = new RequestHandler ( $ stage ) ; } elseif ( is_callable ( $ stage ) ) { $ stages [ ] = new Lambda ( $ stage ) ; } else { throw new InvalidMiddlewareArgument ( is_string ( $ stage ) ? $ stage : get_class ( $ stage ) ) ; } }
10894	public function get ( $ name ) { return isset ( $ this -> uris [ $ name ] ) ? $ this -> uris [ $ name ] : null ; }
2590	public function setArrivalDate ( \ DateTime $ arrivalDate ) { $ this -> arrivalDate = ( $ arrivalDate -> format ( 'dmy' ) !== '000000' ) ? $ arrivalDate -> format ( 'dmy' ) : null ; $ time = $ arrivalDate -> format ( 'Hi' ) ; if ( $ time !== '0000' ) { $ this -> arrivalTime = $ time ; } }
2954	protected function findTemplate ( $ text ) { $ matchedTemplate = [ ] ; $ maxMatch = - 1 ; foreach ( $ this -> directoryIterator as $ fileInfo ) { $ templateContent = file_get_contents ( $ fileInfo -> getPathname ( ) ) ; similar_text ( $ text , $ templateContent , $ matchPercentage ) ; if ( $ matchPercentage > $ maxMatch ) { $ this -> logger -> debug ( sprintf ( 'Template "%s" is a best match for now' , $ fileInfo -> getPathname ( ) ) ) ; $ maxMatch = $ matchPercentage ; $ matchedTemplate = [ $ fileInfo -> getPathname ( ) => $ templateContent ] ; } } return $ matchedTemplate ; }
3141	public function move ( RunnerServiceContext $ context , $ direction , $ scope , $ ref ) { $ result = true ; if ( $ context instanceof QtiRunnerServiceContext ) { try { $ result = QtiRunnerNavigation :: move ( $ direction , $ scope , $ context , $ ref ) ; if ( $ result ) { $ this -> continueInteraction ( $ context ) ; } } catch ( AssessmentTestSessionException $ e ) { switch ( $ e -> getCode ( ) ) { case AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW : case AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW : case AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW : case AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW : $ this -> onTimeout ( $ context , $ e ) ; break ; } } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'move' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; }
978	protected function validateShop ( Request $ request ) { $ shopParam = ShopifyApp :: sanitizeShopDomain ( $ request -> get ( 'shop' ) ) ; $ shop = ShopifyApp :: shop ( $ shopParam ) ; $ session = new ShopSession ( $ shop ) ; if ( $ shop === null || $ shop -> trashed ( ) || empty ( $ session -> getToken ( true ) ) || ( $ shopParam && $ shopParam !== $ shop -> shopify_domain ) === true ) { $ session -> forget ( ) ; Session :: put ( 'return_to' , $ request -> fullUrl ( ) ) ; return Redirect :: route ( 'authenticate' , [ 'shop' => $ shopParam ] ) ; } return true ; }
8061	protected function runWorkerProcess ( WorkerInterface $ worker , SimpleSocket $ simpleSocket , $ i ) { $ replacements = array ( 'basename' => basename ( $ _SERVER [ 'PHP_SELF' ] ) , 'fullname' => $ _SERVER [ 'PHP_SELF' ] , 'class' => get_class ( $ worker ) , 'i' => $ i , 'state' => 'free' ) ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; $ this -> worker -> onProcessCreate ( $ this -> semaphore ) ; while ( TRUE ) { $ output = array ( 'pid' => getmypid ( ) ) ; try { $ replacements [ 'state' ] = 'free' ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; $ cmd = $ simpleSocket -> receive ( ) ; if ( ! isset ( $ cmd [ 'cmd' ] ) ) { break ; } $ replacements [ 'state' ] = 'busy' ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; if ( $ cmd [ 'cmd' ] == 'run' ) { try { $ output [ 'data' ] = $ this -> worker -> run ( $ cmd [ 'data' ] ) ; } catch ( \ Exception $ e ) { $ output [ 'workerException' ] = array ( 'class' => get_class ( $ e ) , 'message' => $ e -> getMessage ( ) , 'trace' => $ e -> getTraceAsString ( ) ) ; } $ simpleSocket -> send ( $ output ) ; } elseif ( $ cmd [ 'cmd' ] == 'exit' ) { break ; } } catch ( SimpleSocketException $ e ) { break ; } catch ( \ Exception $ e ) { $ output [ 'poolException' ] = array ( 'class' => get_class ( $ e ) , 'message' => $ e -> getMessage ( ) , 'trace' => $ e -> getTraceAsString ( ) ) ; $ simpleSocket -> send ( $ output ) ; } } $ this -> worker -> onProcessDestroy ( ) ; $ this -> exitPhp ( 0 ) ; }
3077	public function processOutput ( QtiRunnerServiceContext $ context ) { $ messages = [ ] ; $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; if ( is_array ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] ) ) { foreach ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] as $ outputChannelName => $ outputChannelClass ) { $ channel = $ this -> getChannel ( $ outputChannelName , self :: CHANNEL_TYPE_OUTPUT ) ; $ message = $ this -> processChannel ( $ channel , $ context ) ; if ( $ message !== null ) { $ messages [ ] = [ 'channel' => $ channel -> getName ( ) , 'message' => $ message , ] ; } } } return $ messages ; }
1250	public function parse ( $ xml ) { $ parser = xml_parser_create_ns ( 'UTF-8' , '@' ) ; xml_parser_set_option ( $ parser , XML_OPTION_CASE_FOLDING , 0 ) ; xml_parser_set_option ( $ parser , XML_OPTION_SKIP_WHITE , 1 ) ; xml_set_object ( $ parser , $ this ) ; xml_set_element_handler ( $ parser , 'startElement' , 'endElement' ) ; xml_set_character_data_handler ( $ parser , 'cdata' ) ; xml_parse ( $ parser , $ xml , true ) ; xml_parser_free ( $ parser ) ; return $ this -> rootObject ; }
1189	protected function isImplemented ( $ rule ) { return in_array ( $ rule , $ this -> clientRules ) || in_array ( $ rule , $ this -> serverRules ) ; }
6903	public function render ( $ block = null ) { if ( $ this -> auto_hide === true AND $ this -> total_pages <= 1 ) return '' ; if ( $ block === null ) { $ block = $ this -> block ; } if ( ! $ block instanceof Block ) { $ block = block ( $ block ) ; } return $ block -> set ( get_object_vars ( $ this ) ) -> set ( 'page' , $ this ) -> render ( ) ; }
12326	public function uploadImage ( $ path , $ type = 'icon' ) { if ( ! file_exists ( $ path ) || ! is_readable ( $ path ) ) { throw new InvalidArgumentException ( "File does not exist, or the file is unreadable: '$path'" ) ; } $ type = strtolower ( $ type ) ; return $ this -> parseJSON ( 'upload' , [ self :: API_MATERIAL_ADD , [ 'media' => $ path ] , [ ] , [ 'type' => $ type ] ] ) ; }
6578	public function parse ( $ url ) { $ parts = $ this -> _parse_url ( $ url ) ; foreach ( array ( 'user' , 'pass' , 'fragment' ) as $ part ) if ( isset ( $ parts [ $ part ] ) ) $ parts [ $ part ] = urldecode ( $ parts [ $ part ] ) ; if ( isset ( $ parts [ 'host' ] ) ) $ parts [ 'host' ] = idn_to_utf8 ( $ parts [ 'host' ] ) ; if ( isset ( $ parts [ 'path' ] ) ) $ parts [ 'path' ] = rawurldecode ( str_ireplace ( '%2F' , '%252F' , $ parts [ 'path' ] ) ) ; return $ this -> setParts ( $ parts ) ; }
1052	public static function build ( $ source , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ doc = $ source instanceof DocumentNode ? $ source : Parser :: parse ( $ source ) ; return self :: buildAST ( $ doc , $ typeConfigDecorator , $ options ) ; }
3379	protected function getDefaultNamespace ( $ rootNamespace ) { $ controllersPath = \ Config :: get ( 'panel.controllers' ) ; if ( isset ( $ controllersPath ) && $ controllersPath != NULL ) { return $ controllersPath ; } else { return $ rootNamespace . '\Http\Controllers' ; } }
2274	public function getEditableMemberProperties ( ) { $ return = array ( ) ; Contao \ System :: loadLanguageFile ( 'tl_member' ) ; $ this -> loadDataContainer ( 'tl_member' ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] as $ k => $ v ) { if ( $ v [ 'eval' ] [ 'feEditable' ] ) { $ return [ $ k ] = $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ; } } return $ return ; }
10371	public static function add_scripts ( ) { self :: look_if_process_files ( 'script' ) ; foreach ( self :: $ data [ 'script' ] as $ data ) { $ params = [ 'plugin_url' => defined ( 'WP_PLUGIN_URL' ) ? WP_PLUGIN_URL . '/' : '' , 'nonce' => wp_create_nonce ( $ data [ 'name' ] ) , ] ; $ data [ 'params' ] = array_merge ( $ data [ 'params' ] , $ params ) ; wp_register_script ( $ data [ 'name' ] , $ data [ 'url' ] , $ data [ 'deps' ] , $ data [ 'version' ] , $ data [ 'footer' ] ) ; wp_enqueue_script ( $ data [ 'name' ] ) ; wp_localize_script ( $ data [ 'name' ] , $ data [ 'name' ] , $ data [ 'params' ] ) ; } }
1624	protected function releaseLock ( $ name ) { static $ releaseLuaScript = <<<LUAif redis.call("GET",KEYS[1])==ARGV[1] then return redis.call("DEL",KEYS[1])else return 0endLUA ; if ( ! isset ( $ this -> _lockValues [ $ name ] ) || ! $ this -> redis -> executeCommand ( 'EVAL' , [ $ releaseLuaScript , 1 , $ this -> calculateKey ( $ name ) , $ this -> _lockValues [ $ name ] ] ) ) { return false ; } else { unset ( $ this -> _lockValues [ $ name ] ) ; return true ; } }
3581	protected function pluckMeta ( Builder $ query , ArgumentBag $ args , $ alias ) { list ( $ column , $ key ) = [ $ args -> get ( 'column' ) , $ args -> get ( 'key' ) ] ; $ query -> select ( "{$alias}.meta_value as {$column}" ) ; if ( ! is_null ( $ key ) ) { $ this -> metaSelectListsKey ( $ query , $ key ) ; } return $ query -> callParent ( 'pluck' , $ args -> all ( ) ) ; }
1386	protected function memberFieldsNotAllowed ( string $ path , string $ member , iterable $ fields ) : void { foreach ( $ fields as $ field ) { $ this -> errors -> add ( $ this -> translator -> memberFieldNotAllowed ( $ path , $ member , $ field ) ) ; } }
6030	public function setChildMedias ( array $ childMedias ) { $ this -> childMedias = [ ] ; foreach ( $ childMedias as $ item ) { $ this -> addself ( $ item ) ; } return $ this ; }
409	public function getHostInfo ( ) { if ( $ this -> _hostInfo === null ) { $ secure = $ this -> getIsSecureConnection ( ) ; $ http = $ secure ? 'https' : 'http' ; if ( $ this -> headers -> has ( 'X-Forwarded-Host' ) ) { $ this -> _hostInfo = $ http . '://' . trim ( explode ( ',' , $ this -> headers -> get ( 'X-Forwarded-Host' ) ) [ 0 ] ) ; } elseif ( $ this -> headers -> has ( 'Host' ) ) { $ this -> _hostInfo = $ http . '://' . $ this -> headers -> get ( 'Host' ) ; } elseif ( isset ( $ _SERVER [ 'SERVER_NAME' ] ) ) { $ this -> _hostInfo = $ http . '://' . $ _SERVER [ 'SERVER_NAME' ] ; $ port = $ secure ? $ this -> getSecurePort ( ) : $ this -> getPort ( ) ; if ( ( $ port !== 80 && ! $ secure ) || ( $ port !== 443 && $ secure ) ) { $ this -> _hostInfo .= ':' . $ port ; } } } return $ this -> _hostInfo ; }
11929	public function setDataInterface ( $ value ) { if ( ( $ interfaceItem = Yii :: $ app -> collectors [ 'dataInterfaces' ] -> getOne ( $ value ) ) && ( $ interface = $ interfaceItem -> object ) ) { $ this -> _interface = $ interfaceItem ; } else { throw new Exception ( "Invalid interface!" ) ; } }
9365	public function multiply ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return new self ( ( $ this -> float_r * $ z -> re ) - ( $ this -> float_i * $ z -> im ) , ( $ this -> float_r * $ z -> im ) + ( $ z -> re * $ this -> float_i ) ) ; }
5706	public function shouldDisplay ( ) { return $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsPublished ( ) && $ this -> gridFieldRequest -> record -> canEdit ( ) ; }
692	protected function createView ( array $ config ) { if ( ! array_key_exists ( 'class' , $ config ) ) { $ config [ 'class' ] = View :: className ( ) ; } return Yii :: createObject ( $ config ) ; }
4659	public function getChainStrategy ( ) { $ strategy = new ChainBuildStrategy ( ) ; $ strategy -> pushStrategy ( $ this -> getTravisCiStrategy ( ) ) ; $ strategy -> pushStrategy ( $ this -> getJoliCiStrategy ( ) ) ; return $ strategy ; }
8359	public function dashboards ( Environment $ environment , $ size ) { $ dashboards = null ; if ( $ this -> tokenStorage -> getToken ( ) -> getUser ( ) !== null ) { $ dashboardsAvailable = array ( 'ContactForm' , 'Email' , 'Events' , 'ExceptionChecker' , 'GiftVoucher' , 'PageEdit' , 'Payment' , 'PurchaseCredits' , 'Site' , 'User' ) ; foreach ( $ dashboardsAvailable as $ dashboardAvailable ) { if ( is_dir ( $ this -> container -> getParameter ( 'kernel.root_dir' ) . '/../vendor/c975l/' . strtolower ( $ dashboardAvailable ) . '-bundle' ) && $ this -> configService -> hasParameter ( 'c975L' . $ dashboardAvailable . '.roleNeeded' ) && $ this -> container -> get ( 'security.authorization_checker' ) -> isGranted ( $ this -> configService -> getParameter ( 'c975L' . $ dashboardAvailable . '.roleNeeded' ) ) ) { $ dashboards [ ] = strtolower ( $ dashboardAvailable ) ; } } } return $ environment -> render ( '@c975LToolbar/dashboards.html.twig' , array ( 'dashboards' => $ dashboards , 'size' => $ size , ) ) ; }
4248	public function onOutput ( Event $ event ) { $ this -> outputEvent = $ event ; $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-Protocol-1' , 'http://meta.wildfirehq.org/Protocol/JsonStream/0.2' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Plugin-1' , 'http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/' . self :: FIREPHP_PROTO_VER ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Structure-1' , 'http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1' ) ; $ heading = isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; $ this -> processLogEntryWEvent ( 'groupCollapsed' , array ( 'PHP: ' . $ heading ) ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; $ this -> processLogEntryWEvent ( 'groupEnd' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Index' , $ this -> messageIndex ) ; $ this -> data = array ( ) ; return ; }
1885	public function getItemsAsString ( $ strSeparator = ' ' ) { $ arrLinks = array ( ) ; foreach ( $ this -> getItemsAsArray ( ) as $ arrItem ) { if ( $ arrItem [ 'href' ] === null ) { $ arrLinks [ ] = sprintf ( '<li><strong class="active">%s</strong></li>' , $ arrItem [ 'page' ] ) ; } else { $ arrLinks [ ] = sprintf ( '<li><a href="%s" class="link" title="%s">%s</a></li>' , $ arrItem [ 'href' ] , $ arrItem [ 'title' ] , $ arrItem [ 'page' ] ) ; } } return implode ( $ strSeparator , $ arrLinks ) ; }
3148	public function isItemCompleted ( RunnerServiceContext $ context , $ routeItem , $ itemSession , $ partially = true ) { if ( $ context instanceof QtiRunnerServiceContext && $ context -> isAdaptive ( ) ) { $ itemIdentifier = $ context -> getCurrentAssessmentItemRef ( ) -> getIdentifier ( ) ; $ itemState = $ this -> getItemState ( $ context , $ itemIdentifier ) ; if ( $ itemState !== null ) { $ itemResponse = [ ] ; foreach ( $ itemState as $ key => $ value ) { if ( isset ( $ value [ 'response' ] ) ) { $ itemResponse [ $ key ] = $ value [ 'response' ] ; } } $ responses = $ this -> parsesItemResponse ( $ context , $ itemIdentifier , $ itemResponse ) ; $ excludedResponseVariables = array ( 'numAttempts' , 'duration' ) ; foreach ( $ responses as $ var ) { if ( $ var instanceof ResponseVariable && in_array ( $ var -> getIdentifier ( ) , $ excludedResponseVariables ) === false ) { $ value = $ var -> getValue ( ) ; $ defaultValue = $ var -> getDefaultValue ( ) ; if ( Utils :: isNull ( $ value ) === true ) { if ( Utils :: isNull ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } else { if ( $ value -> equals ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } } } } return ( ( $ partially ) ? false : true ) ; } else { return TestRunnerUtils :: isItemCompleted ( $ routeItem , $ itemSession , $ partially ) ; } }
11694	protected function getCompiler ( SplFileInfo $ file ) : Compiler { $ source_type = $ this -> getSourceType ( $ file ) ; $ compiler_type = '\Gears\Asset\Compilers\\' ; $ compiler_type .= ucfirst ( $ source_type ) ; if ( ! class_exists ( $ compiler_type ) ) { throw new RuntimeException ( 'The source file type is not supported! - (' . $ file . ')' ) ; } return new $ compiler_type ( $ file , $ this -> destination , $ this -> debug , $ this -> autoprefix ) ; }
313	public function setRuntimePath ( $ path ) { $ this -> _runtimePath = Yii :: getAlias ( $ path ) ; Yii :: setAlias ( '@runtime' , $ this -> _runtimePath ) ; }
9919	private function findColumns ( Model $ model ) { $ tableName = $ this -> getTableName ( $ model ) ; if ( ! $ this -> databaseRepository -> hasTable ( $ tableName ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Table %s for %s does not exist!' , $ tableName , $ model -> getName ( ) ) ) ; } $ columns = $ this -> databaseRepository -> getColumnListing ( $ tableName ) ; foreach ( $ columns as $ columnName ) { $ columnType = $ this -> databaseRepository -> getColumnType ( $ tableName , $ columnName ) ; $ model -> addColumn ( new Column ( $ columnName , $ columnType ) ) ; } }
9690	public function render ( $ file , $ env = array ( ) ) { $ file = $ this -> views_path . '/' . $ file ; if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } $ cacheHash = md5 ( $ file . serialize ( $ env ) ) ; $ cache_file = $ this -> views_cache . "/$cacheHash.cache" ; if ( ! $ this -> debug && ( file_exists ( $ cache_file ) && filemtime ( $ cache_file ) > filemtime ( $ file ) ) ) { return file_get_contents ( $ cache_file ) ; } $ this -> currFile = $ file ; $ hash = md5 ( $ file ) ; $ this -> compile ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; set_error_handler ( array ( $ this , 'onTemplateError' ) ) ; require_once ( $ compiled_file ) ; $ output = call_user_func ( 'katar_' . $ hash , $ env ) ; restore_error_handler ( ) ; file_put_contents ( $ cache_file , $ output ) ; return $ output ; }
6430	public function completeLogin ( $ extrainputs = array ( ) ) { $ facebook = $ this -> getFacebookObject ( ) ; $ old_GET = $ _GET ; $ _GET = $ extrainputs ; $ helper = $ facebook -> getRedirectLoginHelper ( ) ; $ accessToken = $ helper -> getAccessToken ( ) ; $ _GET = $ old_GET ; if ( ! isset ( $ accessToken ) ) { if ( $ helper -> getError ( ) ) { throw new \ Exception ( $ helper -> getError ( ) . ' ' . $ helper -> getErrorCode ( ) . ' ' . $ helper -> getErrorReason ( ) . ' ' . $ helper -> getErrorDescription ( ) ) ; } else { throw new \ Exception ( 'Unknown error from Facebook' ) ; } } $ this -> accesstoken = $ accessToken ; return $ this -> getUserProfile ( ) ; }
6159	public function createUrl ( $ action , $ model , $ key , $ index ) { if ( $ this -> urlCreator instanceof Closure ) { return call_user_func ( $ this -> urlCreator , $ action , $ model , $ key , $ index ) ; } else { $ params [ 0 ] = $ this -> controller ? $ this -> controller . '/' . $ action : $ action ; return Url :: toRoute ( $ params ) ; } }
10140	private function readRecordData ( $ data , $ pos , $ len ) { $ data = substr ( $ data , $ pos , $ len ) ; if ( $ this -> encryption == self :: MS_BIFF_CRYPTO_NONE || $ pos < $ this -> encryptionStartPos ) { return $ data ; } $ recordData = '' ; if ( $ this -> encryption == self :: MS_BIFF_CRYPTO_RC4 ) { $ oldBlock = floor ( $ this -> rc4Pos / self :: REKEY_BLOCK ) ; $ block = floor ( $ pos / self :: REKEY_BLOCK ) ; $ endBlock = floor ( ( $ pos + $ len ) / self :: REKEY_BLOCK ) ; if ( $ block != $ oldBlock || $ pos < $ this -> rc4Pos || ! $ this -> rc4Key ) { $ this -> rc4Key = $ this -> makeKey ( $ block , $ this -> md5Ctxt ) ; $ step = $ pos % self :: REKEY_BLOCK ; } else { $ step = $ pos - $ this -> rc4Pos ; } $ this -> rc4Key -> RC4 ( str_repeat ( "\0" , $ step ) ) ; while ( $ block != $ endBlock ) { $ step = self :: REKEY_BLOCK - ( $ pos % self :: REKEY_BLOCK ) ; $ recordData .= $ this -> rc4Key -> RC4 ( substr ( $ data , 0 , $ step ) ) ; $ data = substr ( $ data , $ step ) ; $ pos += $ step ; $ len -= $ step ; ++ $ block ; $ this -> rc4Key = $ this -> makeKey ( $ block , $ this -> md5Ctxt ) ; } $ recordData .= $ this -> rc4Key -> RC4 ( substr ( $ data , 0 , $ len ) ) ; $ this -> rc4Pos = $ pos + $ len ; } elseif ( $ this -> encryption == self :: MS_BIFF_CRYPTO_XOR ) { throw new Exception ( 'XOr encryption not supported' ) ; } return $ recordData ; }
5233	public function handleException ( \ Exception $ exception ) { if ( $ this -> loggingEnabled ) { $ this -> exceptionLogger -> log ( $ exception ) ; } if ( 'cgi' === $ this -> sapi ) { $ this -> header ( 'Status: 500 Internal Server Error' ) ; } else { $ this -> header ( 'HTTP/1.1 500 Internal Server Error' ) ; } $ this -> writeBody ( $ this -> createResponseBody ( $ exception ) ) ; }
2241	public static function getArticle ( $ varId , $ blnMultiMode = false , $ blnIsInsertTag = false , $ strColumn = 'main' ) { global $ objPage ; if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( ! $ varId ) { return '' ; } $ objRow = ArticleModel :: findByIdOrAliasAndPid ( $ varId , ( ! $ blnIsInsertTag ? $ objPage -> id : null ) ) ; if ( $ objRow === null ) { return false ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } if ( isset ( $ _GET [ 'pdf' ] ) && Input :: get ( 'pdf' ) == $ objRow -> id ) { if ( $ objRow -> printable == 1 ) { @ trigger_error ( 'Setting tl_article.printable to "1" has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } elseif ( $ objRow -> printable != '' ) { $ options = StringUtil :: deserialize ( $ objRow -> printable ) ; if ( \ is_array ( $ options ) && \ in_array ( 'pdf' , $ options ) ) { $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } } } $ objRow -> headline = $ objRow -> title ; $ objRow -> multiMode = $ blnMultiMode ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow ) ; } } $ objArticle = new ModuleArticle ( $ objRow , $ strColumn ) ; $ strBuffer = $ objArticle -> generate ( $ blnIsInsertTag ) ; if ( $ objArticle -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
10991	public function getName ( bool $ includeExtension = false ) : string { $ filename = basename ( $ this -> path ) ; if ( $ includeExtension ) { return $ filename ; } return $ this -> splitName ( ) [ 0 ] ; }
10959	private function processSplFileInfo ( \ SplFileInfo $ file ) { if ( $ this -> getCurrentCommand ( ) -> isUsePathReplace ( ) ) { $ this -> getCurrentCommand ( ) -> setToDirectory ( NULL ) ; } $ filePathFrom = $ this -> prepareFilePathFrom ( $ file ) ; $ filePathTo = $ this -> prepareFilePathTo ( $ file ) ; $ this -> currentFilePathFrom = $ filePathFrom ; $ this -> currentFilePathTo = $ filePathTo ; $ this -> validateFileFrom ( $ filePathFrom ) ; $ this -> validateFileTo ( $ filePathTo ) ; if ( ! $ this -> isMoveIt ( ) ) { return null ; } $ result = $ this -> doSystemCommand ( $ filePathFrom , $ filePathTo ) ; return $ result ; }
12511	private function buildGroup ( $ group ) { if ( is_null ( $ group ) ) { $ group = [ 'filter' => [ 'is_to_all' => true , ] , ] ; } elseif ( is_array ( $ group ) ) { $ group = [ 'touser' => $ group , ] ; } else { $ group = [ 'filter' => [ 'is_to_all' => false , 'group_id' => $ group , ] , ] ; } return $ group ; }
135	public function ensureBinariesPresence ( PackageInterface $ package ) { try { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; } catch ( \ InvalidArgumentException $ e ) { return ; } if ( $ installer instanceof BinaryPresenceInterface ) { $ installer -> ensureBinariesPresence ( $ package ) ; } }
7556	function getChildrenByAttribute ( $ attribute , $ value , $ mode = 'equals' , $ compare = 'total' , $ recursive = true ) { if ( $ this -> childCount ( ) < 1 ) { return array ( ) ; } $ mode = explode ( ' ' , strtolower ( $ mode ) ) ; $ match = ( ( isset ( $ mode [ 1 ] ) && ( $ mode [ 1 ] === 'not' ) ) ? 'false' : 'true' ) ; return $ this -> getChildrenByMatch ( array ( 'attributes' => array ( $ attribute => array ( 'operator_value' => $ mode [ 0 ] , 'value' => $ value , 'match' => $ match , 'compare' => $ compare ) ) ) , $ recursive ) ; }
1017	public static function getAllBuiltInTypes ( ) { if ( self :: $ builtInTypes === null ) { self :: $ builtInTypes = array_merge ( Introspection :: getTypes ( ) , self :: getStandardTypes ( ) ) ; } return self :: $ builtInTypes ; }
12543	public function getLink ( ) : string { if ( $ this -> link === null ) { return str_replace ( "?" . $ _SERVER [ "QUERY_STRING" ] , "" , $ _SERVER [ "REQUEST_URI" ] ) ; } else { return $ this -> link ; } }
12328	public function enqueue_script ( WP_Enqueue_Options $ options ) { if ( ! $ options -> have_required_properties ( ) ) { trigger_error ( 'Trying to enqueue script, but required properties are missing.' ) ; return ; } $ handle = $ options -> get_handle ( ) ; $ relative_path = $ options -> get_relative_path ( ) ; $ filename = $ options -> get_filename ( ) ; $ filename_debug = $ options -> get_filename_debug ( ) ; $ dependencies = $ options -> get_dependencies ( ) ; $ version = $ options -> get_version ( ) ; $ in_footer = $ options -> get_in_footer ( ) ; $ localization_name = $ options -> get_localization_name ( ) ; $ data = $ options -> get_data ( ) ; $ source = $ this -> get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug ) ; wp_register_script ( $ handle , $ source , $ dependencies , $ version , $ in_footer ) ; if ( ! empty ( $ localization_name ) && ! empty ( $ data ) ) { wp_localize_script ( $ handle , $ localization_name , $ data ) ; } wp_enqueue_script ( $ handle ) ; }
3304	public function appendSignature ( array $ params = [ ] , $ timestamp = '' , $ noncestr = '' ) { $ params += [ 'app_id' => $ this -> appId , 'time_stamp' => $ timestamp ? : time ( ) , 'nonce_str' => $ noncestr ? : md5 ( uniqid ( ) ) ] ; if ( isset ( $ params [ 'app_key' ] ) ) { unset ( $ params [ 'app_key' ] ) ; } ksort ( $ params ) ; $ params [ 'sign' ] = strtoupper ( md5 ( http_build_query ( $ params + [ 'app_key' => $ this -> appKey ] ) ) ) ; return $ params ; }
11817	protected function step4 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/user" ) ; $ this -> view -> setData ( "step" , "4" ) ; $ this -> view -> setData ( "title" , t ( "Installation | Install SuperUser" ) ) ; if ( $ this -> application -> input -> methodIs ( "post" ) ) { $ install = new Helpers \ Install ( $ this -> application -> config , $ this -> application -> encrypt ) ; if ( ! $ install -> database ( $ this -> application ) ) { $ this -> application -> dispatcher -> redirect ( "/admin/setup/install/3" ) ; } $ this -> response -> addAlert ( "Wohooo! The database was successfully configure. Now please create a super user." , "info" ) ; } return ; }
7578	protected function configureData ( $ data ) { if ( ! empty ( $ this -> _REQUIRED_DATA ) && is_array ( $ data ) ) { $ data = $ this -> configureDefaultData ( $ data ) ; } $ this -> setData ( $ data ) ; }
3065	protected function convertCatVariables ( array $ variables ) { $ runnerService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerService :: SERVICE_ID ) ; $ convertedVariables = [ ] ; foreach ( $ variables as $ variable ) { switch ( $ variable -> getVariableType ( ) ) { case ResultVariable :: TRACE_VARIABLE : $ getVariableMethod = 'getTraceVariable' ; break ; case ResultVariable :: RESPONSE_VARIABLE : $ getVariableMethod = 'getResponseVariable' ; break ; case ResultVariable :: OUTCOME_VARIABLE : $ getVariableMethod = 'getOutcomeVariable' ; break ; case ResultVariable :: TEMPLATE_VARIABLE : default : $ getVariableMethod = null ; break ; } if ( is_null ( $ getVariableMethod ) ) { \ common_Logger :: w ( 'Variable of type ' . $ variable -> getVariableType ( ) . ' is not implemented in ' . __METHOD__ ) ; throw new \ common_exception_NotImplemented ( ) ; } $ convertedVariables [ ] = call_user_func_array ( array ( $ runnerService , $ getVariableMethod ) , array ( $ variable -> getId ( ) , $ variable -> getValue ( ) ) ) ; } return $ convertedVariables ; }
9973	public function setFormatCode ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: FORMAT_GENERAL ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'formatCode' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> formatCode = $ pValue ; $ this -> builtInFormatCode = self :: builtInFormatCodeIndex ( $ pValue ) ; } return $ this ; }
5361	protected function createHeaderStatements ( Operation $ operation , $ queryParamVariable ) { $ headerVariable = new Expr \ Variable ( 'headers' ) ; $ headers = [ new Expr \ ArrayItem ( new Scalar \ String_ ( $ operation -> getHost ( ) ) , new Scalar \ String_ ( 'Host' ) ) , ] ; $ produces = $ operation -> getOperation ( ) -> getProduces ( ) ; if ( $ produces && in_array ( "application/json" , $ produces ) ) { $ headers [ ] = new Expr \ ArrayItem ( new Expr \ Array_ ( [ new Expr \ ArrayItem ( new Scalar \ String_ ( "application/json" ) ) , ] ) , new Scalar \ String_ ( 'Accept' ) ) ; } $ consumes = $ operation -> getOperation ( ) -> getProduces ( ) ; if ( $ operation -> getOperation ( ) -> getParameters ( ) && $ consumes ) { $ bodyParameters = array_filter ( $ operation -> getOperation ( ) -> getParameters ( ) , function ( $ parameter ) { return $ parameter instanceof BodyParameter ; } ) ; if ( count ( $ bodyParameters ) > 0 && in_array ( "application/json" , $ consumes ) ) { $ headers [ ] = new Expr \ ArrayItem ( new Scalar \ String_ ( "application/json" ) , new Scalar \ String_ ( 'Content-Type' ) ) ; } } return [ [ new Expr \ Assign ( $ headerVariable , new Expr \ FuncCall ( new Name ( 'array_merge' ) , [ new Arg ( new Expr \ Array_ ( $ headers ) ) , new Arg ( new Expr \ MethodCall ( $ queryParamVariable , 'buildHeaders' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] ) ) ] , $ headerVariable ] ; }
4689	public function groupBy ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'group' ] = $ args ; return $ this ; }
12047	public function range ( ) { $ arg_num = func_num_args ( ) ; if ( $ arg_num % 2 != 0 ) { throw new \ InvalidArgumentException ( "Number of args must be even" , 1 ) ; } $ value = "[" ; $ arg_list = func_get_args ( ) ; for ( $ i = 0 ; $ i < $ arg_num ; ) { $ value .= self :: sanitize ( $ arg_list [ $ i ++ ] ) . "-" . self :: sanitize ( $ arg_list [ $ i ++ ] ) ; } $ value .= "]" ; return $ this -> add ( $ value ) ; }
11251	public function getLastBatchNumber ( ) : int { $ stmt = $ this -> pdo -> query ( "select max(batch) from {$this->table}" ) ; $ stmt -> execute ( ) ; return ( int ) $ stmt -> fetch ( PDO :: FETCH_ASSOC ) [ 'max' ] ; }
10499	public function gte ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value !== null && $ this -> value >= $ value ) { return true ; } return false ; }
10852	public function echo ( $ type , $ content ) { if ( $ this -> option ( 'debug' ) == false ) { return ; } if ( trim ( $ content ) ) { $ this -> { $ type } ( $ content ) ; } }
4178	public function getFiles ( ) { return $ this -> files ? : $ this -> files = Finder :: create ( ) -> in ( realpath ( $ this -> directory ) ) ; }
9068	protected function convert_value_to_string ( $ value ) { if ( $ this -> is_resource ( $ value ) ) { $ type = get_resource_type ( $ value ) ; return "(Resource:$type)" ; } if ( is_object ( $ value ) ) { if ( $ value instanceof \ Exception || $ value instanceof \ Throwable ) { return '(' . get_class ( $ value ) . "#{$value->getCode()}:{$value->getMessage()})" ; } elseif ( $ value instanceof \ DateTime || ( interface_exists ( '\DateTimeInterface' ) && $ value instanceof \ DateTimeInterface ) ) { return $ value -> format ( \ DateTime :: ATOM ) ; } elseif ( method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } else { $ class = get_class ( $ value ) ; return "($class)" ; } } if ( is_array ( $ value ) ) { return '(Array)' ; } if ( is_scalar ( $ value ) ) { return $ value ; } if ( $ value === null ) { return '(Null)' ; } return '(Invalid)' ; }
4010	public function getMaxPaginationLinks ( ) { if ( null === $ this -> maxPaginationLinks ) { $ this -> setMaxPaginationLinks ( \ Config :: get ( 'maxPaginationLinks' ) ) ; } return $ this -> maxPaginationLinks ; }
11203	public function max ( $ key = false ) { $ collection = $ this -> getIterator ( ) ; $ max = 0 ; $ valueToReturn = 0 ; foreach ( $ collection as $ result ) { if ( $ key && isset ( $ result -> $ key ) ) { if ( $ result -> $ key > $ max ) { $ max = $ result -> $ key ; $ valueToReturn = $ result ; } } else if ( $ key && isset ( $ result [ $ key ] ) ) { if ( $ result [ $ key ] > $ max ) { $ max = $ result [ $ key ] ; $ valueToReturn = $ result ; } } else { if ( $ result > $ max ) { $ max = $ result ; $ valueToReturn = $ result ; } } } return $ valueToReturn ; }
1830	public function refresh ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ res = Database :: getInstance ( ) -> prepare ( "SELECT * FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) ; $ this -> setRow ( $ res -> row ( ) ) ; }
12919	public function setFilters ( ) { $ this -> activeQueryLog ( ) -> setFields ( ) -> setCriteriaByQueryString ( ) -> setCriteria ( ) -> setIncludes ( ) -> setLimit ( ) -> setOrder ( ) -> setGroup ( ) ; }
12944	function setDefaultQueues ( array $ defaultQueues ) { $ this -> _defaults = $ defaultQueues ; $ queues = StdArray :: of ( $ this -> queues ) -> withMergeRecursive ( $ defaultQueues , true ) ; $ this -> queues = $ queues -> value ; return $ this ; }
11002	public function setRedirect ( $ hostname ) { if ( ! empty ( $ hostname ) ) { $ this -> redirect = new URL ( $ hostname ) ; $ this -> redirect -> set ( 'path' , rtrim ( $ this -> redirect -> path , '/' ) ) ; } else $ this -> redirect = false ; return $ this ; }
11790	public function clear ( $ name = null ) { if ( ! is_null ( $ name ) ) { $ name = strtolower ( $ name ) ; if ( array_key_exists ( $ name , self :: $ clearings ) ) { $ this -> { $ name } = self :: $ clearings [ $ self :: $ clearings ] ; } } else { foreach ( self :: $ clearings as $ n => $ v ) { $ this -> { $ n } = $ v ; } } return $ this ; }
11412	public function batchTagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_TAG , $ params ] ) ; }
5252	public static function findOrNew ( $ id ) { $ model = static :: find ( $ id ) ; if ( is_null ( $ model ) ) { $ model = static :: createInstance ( ) ; $ model -> setId ( $ id ) ; } return $ model ; }
745	public function unsigned ( ) { switch ( $ this -> type ) { case Schema :: TYPE_PK : $ this -> type = Schema :: TYPE_UPK ; break ; case Schema :: TYPE_BIGPK : $ this -> type = Schema :: TYPE_UBIGPK ; break ; } $ this -> isUnsigned = true ; return $ this ; }
2101	public static function getNumericDatimFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> datimFormat != '' && static :: isNumericFormat ( $ objPage -> datimFormat ) ) { return $ objPage -> datimFormat ; } } return Config :: get ( 'datimFormat' ) ; }
10602	public function addQuery ( $ name , $ value ) { $ part = $ name . '=' . $ value ; $ this -> _urlParts [ 'query' ] .= empty ( $ this -> _urlParts [ 'query' ] ) ? $ part : '&' . $ part ; return $ this ; }
9840	public function createSymmetricEncryptedJsonResponse ( int $ status , array $ arrayToJsonify , SharedEncryptionKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricEncryptedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
9702	public function addFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { $ fontHashCode = $ font -> getHashCode ( ) ; if ( isset ( $ this -> addedFonts [ $ fontHashCode ] ) ) { $ fontIndex = $ this -> addedFonts [ $ fontHashCode ] ; } else { $ countFonts = count ( $ this -> fontWriters ) ; $ fontIndex = ( $ countFonts < 4 ) ? $ countFonts : $ countFonts + 1 ; $ fontWriter = new Font ( $ font ) ; $ fontWriter -> setColorIndex ( $ this -> addColor ( $ font -> getColor ( ) -> getRGB ( ) ) ) ; $ this -> fontWriters [ ] = $ fontWriter ; $ this -> addedFonts [ $ fontHashCode ] = $ fontIndex ; } return $ fontIndex ; }
9828	public function getCreateAssociationName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s.create' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
11877	public static function getDumpQueryResult ( $ var ) { $ header = true ; $ dump = '<table cellpadding=5 cellspacing=0>' ; $ i = 1 ; foreach ( $ var as $ ligne ) { if ( $ header ) { $ dump .= '<tr>' ; foreach ( $ ligne as $ key => $ value ) { if ( ! is_numeric ( $ key ) ) { $ dump .= '<th>' . $ key . '</th>' ; } } $ dump .= '</tr>' ; $ header = false ; } $ class = '' ; if ( ! ( $ i % 2 ) ) { $ class = 'highlight' ; } $ dump .= '<tr class="' . $ class . '">' ; foreach ( $ ligne as $ key => $ value ) { if ( ! is_numeric ( $ key ) ) { if ( $ value != '' ) { $ dump .= '<td>' . $ value . '</td>' ; } else { $ dump .= '<td>&nbsp;</td>' ; } } } $ dump .= '</tr>' ; $ i ++ ; } $ dump .= '</table>' ; return $ dump ; }
3967	protected function getMetaModelByModelPid ( ModelInterface $ model ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; if ( $ metaModel === null ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ model -> getProperty ( 'pid' ) ) ; } return $ metaModel ; }
7893	public function add ( $ property_name , $ value ) { $ this -> validateProperty ( $ property_name , $ value ) ; $ this -> data [ $ property_name ] [ ] = & $ value ; return $ this ; }
11351	public function submit ( Request $ request ) { $ this -> isConfirmed = false ; if ( $ this -> formTags [ 'method' ] == 'post' && $ request -> getType ( ) == 'POST' ) { $ this -> isConfirmed = true ; } $ query = $ request -> getQuery ( ) ; if ( count ( $ this -> fields ) > 0 && $ this -> formTags [ 'method' ] == 'get' && isset ( $ query [ $ this -> fields [ 0 ] -> getName ( ) ] ) ) { $ this -> isConfirmed = true ; } if ( ! $ this -> isConfirmed ) return ; if ( $ this -> formTags [ 'method' ] == 'post' ) { $ storage = $ request -> getData ( ) ; } else { $ storage = $ request -> getQuery ( ) ; } $ result = [ ] ; foreach ( $ this -> fields as $ field ) { if ( isset ( $ storage [ $ field -> getName ( ) ] ) ) { $ field -> setData ( $ storage [ $ field -> getName ( ) ] ) ; } else if ( $ field instanceof FileField ) { try { $ field -> setData ( $ request -> getFile ( $ field -> getName ( ) ) ) ; } catch ( FileNotUploadedException $ e ) { $ field -> setData ( '' ) ; } } else if ( preg_match ( '/^(.*?)(\[.*\])$/' , $ field -> getName ( ) , $ result ) && isset ( $ storage [ $ result [ 1 ] ] ) ) { if ( ! preg_match_all ( "/\[(.*?)\]/" , $ result [ 2 ] , $ resultDeep ) ) { throw new \ Exception ( 'Invalid field name.' ) ; } $ value = $ storage [ $ result [ 1 ] ] ; foreach ( $ resultDeep [ 1 ] as $ deep ) { if ( ! isset ( $ value [ $ deep ] ) ) { $ value = null ; break ; } $ value = $ value [ $ deep ] ; } if ( $ result [ 2 ] == '' ) { } else { $ field -> setData ( $ value ) ; } } else { $ field -> setData ( null ) ; } } if ( $ request -> isFullUploadedData ( ) ) { foreach ( $ this -> fields as $ field ) { if ( $ field -> getValidator ( ) ) { if ( $ error = $ field -> getValidator ( ) -> validate ( $ field -> getData ( ) ) ) { $ field -> setError ( $ error ) ; } } } } else { foreach ( $ this -> fields as $ field ) { $ field -> setError ( 'Request data is too large.' ) ; } } }
5066	public function init ( string $ url = null ) : void { $ this -> ch = curl_init ( $ url ) ; CurlObjectLookup :: add ( $ this ) ; }
5367	public function paintException ( $ message ) { parent :: paintException ( $ message ) ; $ this -> results [ ] = new SimpleResultOfException ( parent :: getTestList ( ) , $ message ) ; }
12620	public function createModel ( $ id , $ attributes ) { return Yii :: createObject ( [ 'class' => $ this -> foreignModelClass , 'tableName' => $ this -> fileSource -> id , 'interface' => $ this -> module , 'id' => $ id , 'attributes' => $ attributes ] ) ; }
6799	public function installCountries ( $ code = 'US' ) { $ countryNames = Intl :: getRegionBundle ( ) -> getCountryNames ( ) ; if ( ! isset ( $ countryNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default country code '$code'." ) ; } asort ( $ countryNames ) ; $ this -> generate ( Country :: class , $ countryNames , $ code ) ; }
7335	private function addMappings ( ClassMetadata $ metadata , array $ mappings ) { foreach ( $ mappings as $ mapping ) { if ( ! $ metadata -> hasField ( $ mapping [ 'fieldName' ] ) ) { $ metadata -> mapField ( $ mapping ) ; } } }
10296	public function writeChart ( \ PhpOffice \ PhpSpreadsheet \ Chart \ Chart $ pChart , $ calculateCellValues = true ) { $ this -> calculateCellValues = $ calculateCellValues ; $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } if ( $ this -> calculateCellValues ) { $ pChart -> refresh ( ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'c:chartSpace' ) ; $ objWriter -> writeAttribute ( 'xmlns:c' , 'http://schemas.openxmlformats.org/drawingml/2006/chart' ) ; $ objWriter -> writeAttribute ( 'xmlns:a' , 'http://schemas.openxmlformats.org/drawingml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ objWriter -> startElement ( 'c:date1904' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:lang' ) ; $ objWriter -> writeAttribute ( 'val' , 'en-GB' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:roundedCorners' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writeAlternateContent ( $ objWriter ) ; $ objWriter -> startElement ( 'c:chart' ) ; $ this -> writeTitle ( $ objWriter , $ pChart -> getTitle ( ) ) ; $ objWriter -> startElement ( 'c:autoTitleDeleted' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writePlotArea ( $ objWriter , $ pChart -> getWorksheet ( ) , $ pChart -> getPlotArea ( ) , $ pChart -> getXAxisLabel ( ) , $ pChart -> getYAxisLabel ( ) , $ pChart -> getChartAxisX ( ) , $ pChart -> getChartAxisY ( ) , $ pChart -> getMajorGridlines ( ) , $ pChart -> getMinorGridlines ( ) ) ; $ this -> writeLegend ( $ objWriter , $ pChart -> getLegend ( ) ) ; $ objWriter -> startElement ( 'c:plotVisOnly' ) ; $ objWriter -> writeAttribute ( 'val' , 1 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:dispBlanksAs' ) ; $ objWriter -> writeAttribute ( 'val' , 'gap' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showDLblsOverMax' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writePrintSettings ( $ objWriter ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
11104	protected function registerClientScript ( ) { $ view = $ this -> getView ( ) ; DateTimePickerAssets :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; $ options = Json :: encode ( $ this -> clientOptions ) ; $ view -> registerJs ( "jQuery('#$id').datetimepicker($options);" ) ; }
11500	protected function _setupDatabaseAdapter ( ) { if ( Zend_Registry :: isRegistered ( 'multidb' ) ) { return $ this -> _setAdapter ( Zend_Registry :: get ( 'multidb' ) -> getDb ( $ this -> _connection ) ) ; } return parent :: _setupDatabaseAdapter ( ) ; }
3510	public static function dbValue ( $ value , $ nullValue = 'NULL' ) { if ( $ value === null ) { return $ nullValue ; } if ( is_string ( $ value ) ) { return '\'' . str_replace ( '\'' , '\'\'' , $ value ) . '\'' ; } if ( is_bool ( $ value ) ) { return $ value ? '1' : '0' ; } return $ value ; }
9461	public function appendValueFilter ( $ key , $ value ) { if ( ! empty ( $ value ) ) { if ( $ this -> getValues ( $ key ) ) { return $ this -> append ( $ key , $ value ) ; } else { return $ this -> addValuesFilter ( $ key , [ $ value ] ) ; } } else { return $ this ; } }
9859	public function getStream ( $ stream ) { if ( $ stream === null ) { return null ; } $ streamData = '' ; if ( $ this -> props [ $ stream ] [ 'size' ] < self :: SMALL_BLOCK_THRESHOLD ) { $ rootdata = $ this -> _readData ( $ this -> props [ $ this -> rootentry ] [ 'startBlock' ] ) ; $ block = $ this -> props [ $ stream ] [ 'startBlock' ] ; while ( $ block != - 2 ) { $ pos = $ block * self :: SMALL_BLOCK_SIZE ; $ streamData .= substr ( $ rootdata , $ pos , self :: SMALL_BLOCK_SIZE ) ; $ block = self :: getInt4d ( $ this -> smallBlockChain , $ block * 4 ) ; } return $ streamData ; } $ numBlocks = $ this -> props [ $ stream ] [ 'size' ] / self :: BIG_BLOCK_SIZE ; if ( $ this -> props [ $ stream ] [ 'size' ] % self :: BIG_BLOCK_SIZE != 0 ) { ++ $ numBlocks ; } if ( $ numBlocks == 0 ) { return '' ; } $ block = $ this -> props [ $ stream ] [ 'startBlock' ] ; while ( $ block != - 2 ) { $ pos = ( $ block + 1 ) * self :: BIG_BLOCK_SIZE ; $ streamData .= substr ( $ this -> data , $ pos , self :: BIG_BLOCK_SIZE ) ; $ block = self :: getInt4d ( $ this -> bigBlockChain , $ block * 4 ) ; } return $ streamData ; }
8399	public function display ( Environment $ environment , $ template , $ type = null , $ size = 'md' , $ object = null ) { $ tools = $ environment -> render ( $ template , array ( 'type' => $ type , 'object' => $ object , ) ) ; return $ environment -> render ( '@c975LToolbar/toolbar.html.twig' , array ( 'tools' => $ tools , 'size' => $ size , ) ) ; }
8760	public function setLinePrefixMap ( array $ prefixMap ) { foreach ( $ prefixMap as $ status => $ prefix ) { $ this -> setLinePrefix ( $ status , $ prefix ) ; } }
3992	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values ) ) ; }
7001	public function method ( $ method = null ) { if ( $ method ) $ this -> method = trim ( $ method ) ; return $ this -> method ; }
258	public function render ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; return $ this -> renderFile ( $ viewFile , $ params , $ context ) ; }
8622	public function setGetLowestOfferListingsForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetLowestOfferListingsForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8647	private function configureCurlOptions ( $ action , array $ converted , $ streamHandle = null , $ contentMd5 = null ) { $ curlOptions = $ this -> getDefaultCurlOptions ( ) ; if ( ! is_null ( $ this -> config [ 'ProxyHost' ] ) ) { $ proxy = $ this -> config [ 'ProxyHost' ] ; $ proxy .= ':' . ( $ this -> config [ 'ProxyPort' ] == - 1 ? '80' : $ this -> config [ 'ProxyPort' ] ) ; $ curlOptions [ CURLOPT_PROXY ] = $ proxy ; } if ( array_key_exists ( 'CURLOPT_VERBOSE' , $ this -> config ) && ! is_null ( $ this -> config [ 'CURLOPT_VERBOSE' ] ) ) { $ curlOptions [ CURLOPT_VERBOSE ] = $ this -> config [ 'CURLOPT_VERBOSE' ] ; } $ serviceUrl = $ this -> config [ 'ServiceURL' ] ; if ( ! ( substr ( $ serviceUrl , strlen ( $ serviceUrl ) - 1 ) === '/' ) ) { $ serviceUrl .= '/' ; } $ requestType = MarketplaceWebService_RequestType :: getRequestType ( $ action ) ; if ( $ requestType == MarketplaceWebService_RequestType :: POST_UPLOAD ) { if ( is_null ( $ streamHandle ) || ! is_resource ( $ streamHandle ) ) { throw new MarketplaceWebService_Exception ( array ( 'Message' => 'Missing stream resource.' ) ) ; } $ serviceUrl .= '?' . $ this -> getParametersAsString ( $ converted [ CONVERTED_PARAMETERS_KEY ] ) ; $ curlOptions [ CURLOPT_URL ] = $ serviceUrl ; $ header [ ] = 'Expect: ' ; $ header [ ] = 'Accept: ' ; $ header [ ] = 'Transfer-Encoding: chunked' ; $ header [ ] = 'Content-MD5: ' . $ contentMd5 ; $ curlOptions [ CURLOPT_HTTPHEADER ] = array_merge ( $ header , $ converted [ CONVERTED_HEADERS_KEY ] ) ; rewind ( $ streamHandle ) ; $ curlOptions [ CURLOPT_INFILE ] = $ streamHandle ; $ curlOptions [ CURLOPT_UPLOAD ] = true ; $ curlOptions [ CURLOPT_CUSTOMREQUEST ] = self :: REQUEST_TYPE ; } else if ( ! ( $ requestType === MarketplaceWebService_RequestType :: UNKNOWN ) ) { $ curlOptions [ CURLOPT_URL ] = $ this -> config [ 'ServiceURL' ] ; $ curlOptions [ CURLOPT_POSTFIELDS ] = $ this -> getParametersAsString ( $ converted [ CONVERTED_PARAMETERS_KEY ] ) ; if ( $ requestType == MarketplaceWebService_RequestType :: POST_DOWNLOAD ) { $ this -> responseBodyContents = $ streamHandle ; $ curlOptions [ CURLOPT_WRITEFUNCTION ] = array ( $ this , 'responseCallback' ) ; } } else { throw new InvalidArgumentException ( "$action is not a valid request type." ) ; } return $ curlOptions ; }
9871	private function writeBreaks ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ aRowBreaks = [ ] ; $ aColumnBreaks = [ ] ; foreach ( $ pSheet -> getBreaks ( ) as $ cell => $ breakType ) { if ( $ breakType == PhpspreadsheetWorksheet :: BREAK_ROW ) { $ aRowBreaks [ ] = $ cell ; } elseif ( $ breakType == PhpspreadsheetWorksheet :: BREAK_COLUMN ) { $ aColumnBreaks [ ] = $ cell ; } } if ( ! empty ( $ aRowBreaks ) ) { $ objWriter -> startElement ( 'rowBreaks' ) ; $ objWriter -> writeAttribute ( 'count' , count ( $ aRowBreaks ) ) ; $ objWriter -> writeAttribute ( 'manualBreakCount' , count ( $ aRowBreaks ) ) ; foreach ( $ aRowBreaks as $ cell ) { $ coords = Coordinate :: coordinateFromString ( $ cell ) ; $ objWriter -> startElement ( 'brk' ) ; $ objWriter -> writeAttribute ( 'id' , $ coords [ 1 ] ) ; $ objWriter -> writeAttribute ( 'man' , '1' ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } if ( ! empty ( $ aColumnBreaks ) ) { $ objWriter -> startElement ( 'colBreaks' ) ; $ objWriter -> writeAttribute ( 'count' , count ( $ aColumnBreaks ) ) ; $ objWriter -> writeAttribute ( 'manualBreakCount' , count ( $ aColumnBreaks ) ) ; foreach ( $ aColumnBreaks as $ cell ) { $ coords = Coordinate :: coordinateFromString ( $ cell ) ; $ objWriter -> startElement ( 'brk' ) ; $ objWriter -> writeAttribute ( 'id' , Coordinate :: columnIndexFromString ( $ coords [ 0 ] ) - 1 ) ; $ objWriter -> writeAttribute ( 'man' , '1' ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
3623	public function temperatureInCelsius ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature - 32 ) / 1.8 ; } return $ temperature ; }
11496	public static function end ( ) { if ( self :: $ startTime ) { $ time = round ( ( microtime ( true ) - self :: $ startTime ) , 4 ) ; self :: $ startTime = false ; } return ( isset ( $ time ) ) ? $ time : false ; }
2399	public static function notifyCommentsSubscribers ( CommentsModel $ objComment ) { if ( $ objComment -> notified ) { return ; } $ objNotify = CommentsNotifyModel :: findActiveBySourceAndParent ( $ objComment -> source , $ objComment -> parent ) ; if ( $ objNotify !== null ) { while ( $ objNotify -> next ( ) ) { if ( $ objNotify -> email == $ objComment -> email ) { continue ; } $ strUrl = Idna :: decode ( Environment :: get ( 'base' ) ) . $ objNotify -> url ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifySubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifyMessage' ] , $ objNotify -> name , $ strUrl . '#c' . $ objComment -> id , $ strUrl . '?token=' . $ objNotify -> tokenRemove ) ; $ objEmail -> sendTo ( $ objNotify -> email ) ; } } $ objComment -> notified = '1' ; $ objComment -> save ( ) ; }
7035	protected function createMigrationTable ( ) { $ migrations = new Table ( "migrations" , true ) ; $ migrations -> string ( "host" ) -> notNullable ( ) -> primaryComposite ( ) ; $ migrations -> timestamp ( "created_at" ) -> notNullable ( ) -> primaryComposite ( true ) ; $ migrations -> blob ( "tables" ) ; try { return $ migrations -> create ( $ this -> dbName ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
12010	public function addLink ( string $ name , string $ link = null , array $ arguments = [ ] ) : Link { $ name = $ this -> translator !== null ? $ this -> translator -> translate ( $ name ) : $ name ; return $ this -> addLinkUntranslated ( $ name , $ link , $ arguments ) ; }
4303	public function profile ( $ name = null ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } if ( ! $ this -> cfg [ 'enableProfiling' ] ) { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ this -> appendLog ( __FUNCTION__ , array ( 'Profile: Unable to start - enableProfiling opt not set. ' . $ callerInfo [ 'file' ] . ' on line ' . $ callerInfo [ 'line' ] . '.' ) ) ; return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) ) ; if ( $ meta [ 'name' ] === null ) { $ meta [ 'name' ] = 'Profile ' . $ this -> data [ 'profileAutoInc' ] ; $ this -> data [ 'profileAutoInc' ] ++ ; } $ name = $ meta [ 'name' ] ; $ message = '' ; if ( isset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ) { $ instance = $ this -> data [ 'profileInstances' ] [ $ name ] ; $ instance -> end ( ) ; $ instance -> start ( ) ; unset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ; $ this -> data [ 'profileInstances' ] [ $ name ] = $ instance ; $ message = 'Profile \'' . $ name . '\' restarted' ; } else { $ this -> data [ 'profileInstances' ] [ $ name ] = $ this -> methodProfile ; $ message = 'Profile \'' . $ name . '\' started' ; } $ this -> appendLog ( __FUNCTION__ , array ( $ message , ) , $ meta ) ; }
12729	public function optionsMap ( ) : array { $ routes_list = $ this -> router -> getRoutes ( ) ; $ final_routes = $ modified_routes = [ ] ; foreach ( $ routes_list as $ route ) { if ( isset ( $ modified_routes [ $ route [ 1 ] ] ) === false ) { $ modified_routes [ $ route [ 1 ] ] = [ ] ; } $ modified_routes [ $ route [ 1 ] ] [ ] = $ route [ 0 ] ; } foreach ( $ modified_routes as $ route => $ method ) { $ final_routes [ ] = [ 'OPTIONS' , $ route , function ( ) use ( $ method ) { return [ "headers" => [ [ 'X-PHP-Response-Code: 200' , true , 200 ] , [ 'Allow: ' . implode ( ',' , $ method ) ] ] , "response" => '' ] ; } ] ; } return $ final_routes ; }
4307	public function timeEnd ( $ label = null , $ returnOrTemplate = false , $ precision = 4 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'label' => null , 'returnOrTemplate' => false , 'precision' => 4 , ) ) ; \ extract ( $ args ) ; if ( \ is_bool ( $ label ) || \ strpos ( $ label , '%time' ) !== false ) { if ( \ is_numeric ( $ returnOrTemplate ) ) { $ precision = $ returnOrTemplate ; } $ returnOrTemplate = $ label ; $ label = null ; } $ ret = $ this -> timeGet ( $ label , true , null ) ; if ( isset ( $ label ) ) { if ( isset ( $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] ) ) { $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] = array ( $ ret , null , ) ; } } else { $ label = 'time' ; \ array_pop ( $ this -> data [ 'timers' ] [ 'stack' ] ) ; } if ( \ is_int ( $ precision ) ) { $ ret = \ number_format ( $ ret , $ precision , '.' , '' ) ; } $ this -> doTime ( $ ret , $ returnOrTemplate , $ label , $ meta ) ; return $ ret ; }
9196	public function config ( ) { if ( ! $ this -> config ) { $ config = array ( ) ; $ configFile = $ this -> getThemesPath ( ) . DIRECTORY_SEPARATOR . $ this -> getName ( ) . DIRECTORY_SEPARATOR . 'theme.config.php' ; if ( file_exists ( $ configFile ) ) { ob_start ( ) ; set_error_handler ( function ( $ errno , $ errstr ) { throw new \ ErrorException ( $ errstr , $ errno ) ; } , E_ALL ) ; $ config = include $ configFile ; restore_error_handler ( ) ; ob_get_clean ( ) ; if ( ! is_array ( $ config ) ) throw new \ Exception ( 'Invalid "' . $ this -> getName ( ) . '" Theme Config File. It must return array.' ) ; } $ this -> config = new Entity ( $ config ) ; } return $ this -> config ; }
6438	public function completeLogin ( $ extrainputs = array ( ) ) { $ request_token = [ ] ; $ request_token [ 'oauth_token' ] = $ this -> request_token [ 'oauth_token' ] ; $ request_token [ 'oauth_token_secret' ] = $ this -> request_token [ 'oauth_token_secret' ] ; $ this -> logQ ( 'session token ' . print_r ( $ request_token , true ) , 'twitter' ) ; $ this -> logQ ( 'extra options ' . print_r ( $ extrainputs , true ) , 'twitter' ) ; if ( isset ( $ extrainputs [ 'oauth_token' ] ) && $ request_token [ 'oauth_token' ] !== $ extrainputs [ 'oauth_token' ] ) { throw new \ Exception ( 'Twitter oauth. Somethign went wrong. No token in the session' ) ; } $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] , $ request_token [ 'oauth_token' ] , $ request_token [ 'oauth_token_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ access_token = $ connection -> oauth ( "oauth/access_token" , array ( "oauth_verifier" => $ extrainputs [ 'oauth_verifier' ] ) ) ; $ this -> access_token = $ access_token ; return $ this -> getUserProfile ( ) ; }
10439	protected function nextBufferLine ( ) { $ query = $ this -> parseQuery ( ) ; if ( ! empty ( $ query ) ) { $ this -> buffer [ $ this -> key ] [ self :: PARAM_QUERY ] = $ query ; } else { $ this -> buffer [ $ this -> key ] = false ; } }
11167	protected function generateApi ( ) { $ api = array ( ) ; $ api [ "url" ] = $ this -> getUrl ( ) ; $ api [ "type" ] = "remoting" ; $ actionsArray = array ( ) ; $ actions = $ this -> getActions ( ) ; foreach ( $ actions as $ class ) { $ methodArray = array ( ) ; foreach ( $ class -> getMethods ( ) as $ method ) { $ methodArray [ ] = array ( "name" => $ method -> getAnnotatedName ( ) , "len" => $ method -> getLen ( ) ) ; } $ actionsArray [ $ class -> getAnnotatedName ( ) ] = $ methodArray ; } $ api [ "actions" ] = $ actionsArray ; return $ api ; }
12686	public function inferType ( $ value ) { if ( is_string ( $ value ) ) { return new StringType ( ) ; } elseif ( is_array ( $ value ) ) { return new ArrayType ( ) ; } elseif ( is_object ( $ value ) ) { return $ this -> inferObjectType ( $ value ) ; } elseif ( is_integer ( $ value ) ) { return new IntegerType ( ) ; } elseif ( is_bool ( $ value ) ) { return new BooleanType ( ) ; } elseif ( is_null ( $ value ) ) { return new MixedType ( ) ; } $ e = new InferException ( 'Typ konnte nicht geraten werden: ' . Util :: varInfo ( $ value ) ) ; $ e -> value = $ value ; throw $ e ; }
11775	protected function getIsEnabled ( ) : \ Illuminate \ Database \ Eloquent \ Model { $ result = Model \ Setting :: find ( 1 ) ; $ result -> value = ( bool ) $ result -> value ; return $ result ; }
3325	public function renderOption ( Option $ opt ) { $ c1 = '' ; if ( $ opt -> short && $ opt -> long ) { $ c1 = sprintf ( '-%s, --%s' , $ opt -> short , $ opt -> long ) ; } else if ( $ opt -> short ) { $ c1 = sprintf ( '-%s' , $ opt -> short ) ; } else if ( $ opt -> long ) { $ c1 = sprintf ( '--%s' , $ opt -> long ) ; } $ c1 .= $ opt -> renderValueHint ( ) ; return $ c1 ; }
289	protected function isLanguageSupported ( $ requested , $ supported ) { $ supported = str_replace ( '_' , '-' , strtolower ( $ supported ) ) ; $ requested = str_replace ( '_' , '-' , strtolower ( $ requested ) ) ; return strpos ( $ requested . '-' , $ supported . '-' ) === 0 ; }
7048	protected function formatPhoneNumber ( PhoneNumber $ number = null ) { if ( $ number ) { return $ this -> phoneNumberUtil -> format ( $ number , PhoneNumberFormat :: INTERNATIONAL ) ; } return null ; }
947	protected function scripttagExists ( array $ shopScripttags , array $ scripttag ) { foreach ( $ shopScripttags as $ shopScripttag ) { if ( $ shopScripttag -> src === $ scripttag [ 'src' ] ) { return true ; } } return false ; }
8289	protected function authRoutes ( ) { switch ( $ this -> requestUrl ) { case 'login' : if ( $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToPage ( $ this -> config [ "afterLogin" ] ) ; } break ; case 'logout' : if ( ! $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToLogin ( ) ; } $ this -> checkLogoutSubmission ( ) ; break ; } }
2502	protected function mapData ( array $ data ) { $ values = array ( ) ; reset ( $ data ) ; while ( $ key = current ( $ data ) ) { $ values [ $ key ] = next ( $ data ) ; next ( $ data ) ; } return $ values ; }
1388	protected function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotSupportClientIds ( $ type , $ path ) ) ; }
8741	protected function i18nDeleteQuery ( $ withGlobalScopes = true ) { $ subQuery = $ withGlobalScopes ? $ this -> toBase ( ) : $ this -> getQuery ( ) ; $ subQuery -> select ( $ this -> model -> getQualifiedKeyName ( ) ) ; return $ this -> i18nQuery ( ) -> whereIn ( $ this -> model -> getForeignKey ( ) , $ subQuery -> pluck ( $ this -> model -> getKeyName ( ) ) ) ; }
5057	private function getClassName ( $ requestedName ) { $ exp = explode ( '/' , $ requestedName ) ; $ className = array_shift ( $ exp ) . '\\Controller\\' . implode ( '\\' , $ exp ) . 'Controller' ; if ( ! class_exists ( $ className ) ) { throw new ServiceNotCreatedException ( sprintf ( 'Can\'t find correct controller class for "%s"' , $ requestedName ) ) ; } return $ className ; }
9239	private function isInheritanceRelationship ( ForeignKeyConstraint $ fk ) { if ( ! $ fk -> getLocalTable ( ) -> hasPrimaryKey ( ) ) { return false ; } $ fkColumnNames = $ fk -> getLocalColumns ( ) ; $ pkColumnNames = $ fk -> getLocalTable ( ) -> getPrimaryKeyColumns ( ) ; sort ( $ fkColumnNames ) ; sort ( $ pkColumnNames ) ; return $ fkColumnNames == $ pkColumnNames ; }
9675	public function allFills ( Spreadsheet $ spreadsheet ) { $ aFills = [ ] ; $ fill0 = new Fill ( ) ; $ fill0 -> setFillType ( Fill :: FILL_NONE ) ; $ aFills [ ] = $ fill0 ; $ fill1 = new Fill ( ) ; $ fill1 -> setFillType ( Fill :: FILL_PATTERN_GRAY125 ) ; $ aFills [ ] = $ fill1 ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFills [ $ style -> getFill ( ) -> getHashCode ( ) ] ) ) { $ aFills [ $ style -> getFill ( ) -> getHashCode ( ) ] = $ style -> getFill ( ) ; } } return $ aFills ; }
6959	protected function updateExpiresAt ( CartInterface $ cart ) { $ date = new \ DateTime ( ) ; $ date -> modify ( $ this -> expirationDelay ) ; $ cart -> setExpiresAt ( $ date ) ; return true ; }
9869	private function writePageMargins ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'pageMargins' ) ; $ objWriter -> writeAttribute ( 'left' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getLeft ( ) ) ) ; $ objWriter -> writeAttribute ( 'right' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getRight ( ) ) ) ; $ objWriter -> writeAttribute ( 'top' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getTop ( ) ) ) ; $ objWriter -> writeAttribute ( 'bottom' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getBottom ( ) ) ) ; $ objWriter -> writeAttribute ( 'header' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getHeader ( ) ) ) ; $ objWriter -> writeAttribute ( 'footer' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getFooter ( ) ) ) ; $ objWriter -> endElement ( ) ; }
10929	public function getCountOf ( string $ strSQL , ? array $ parans = null ) : int { $ r = $ this -> getDataColumn ( $ strSQL , $ parans , "int" ) ; return ( ( $ r === null ) ? 0 : $ r ) ; }
9709	private function writeCodepage ( ) { $ record = 0x0042 ; $ length = 0x0002 ; $ cv = $ this -> codepage ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cv ) ; $ this -> append ( $ header . $ data ) ; }
1920	private function getSqlDefinitions ( ) : array { $ this -> framework -> initialize ( ) ; $ installer = $ this -> framework -> createInstance ( Installer :: class ) ; $ sqlTarget = $ installer -> getFromDca ( ) ; $ sqlLegacy = $ installer -> getFromFile ( ) ; if ( ! empty ( $ sqlLegacy ) ) { foreach ( $ sqlLegacy as $ table => $ categories ) { foreach ( $ categories as $ category => $ fields ) { if ( \ is_array ( $ fields ) ) { foreach ( $ fields as $ name => $ sql ) { $ sqlTarget [ $ table ] [ $ category ] [ $ name ] = $ sql ; } } else { $ sqlTarget [ $ table ] [ $ category ] = $ fields ; } } } } if ( $ filter = $ this -> doctrine -> getConnection ( ) -> getConfiguration ( ) -> getFilterSchemaAssetsExpression ( ) ) { foreach ( array_keys ( $ sqlTarget ) as $ key ) { if ( ! preg_match ( $ filter , $ key ) ) { unset ( $ sqlTarget [ $ key ] ) ; } } } return $ sqlTarget ; }
1610	private function _isRedirectRegex ( $ uri ) { if ( preg_match ( '/\/(.*)\/([g|m|i|x|X|s|u|U|A|J|D]+)/m' , $ uri ) === 0 ) { $ i = preg_match_all ( '/(?<!\\\\)\?(?![^(]*\))/' , $ uri , $ matches , PREG_OFFSET_CAPTURE ) ; while ( $ i -- ) { $ x = $ matches [ 0 ] [ $ i ] [ 1 ] ; $ uri = substr_replace ( $ uri , '\?' , $ x , 1 ) ; } $ i = preg_match_all ( '/(?<!\\\\)\/(?![^(]*\))/' , $ uri , $ matches , PREG_OFFSET_CAPTURE ) ; while ( $ i -- ) { $ x = $ matches [ 0 ] [ $ i ] [ 1 ] ; $ uri = substr_replace ( $ uri , '\/' , $ x , 1 ) ; } } if ( @ preg_match ( $ uri , null ) === false ) $ uri = '/^' . $ uri . '$/i' ; if ( @ preg_match ( $ uri , null ) !== false ) return $ uri ; return false ; }
8401	public function render ( RenderInterface $ render , $ status = 200 ) { $ this -> renderInst = $ render ; $ this -> status = $ status ; }
3545	protected function write ( $ file , $ file_path ) { if ( ! is_dir ( dirname ( $ file_path ) ) ) { mkdir ( dirname ( $ file_path ) , 0755 , true ) ; } file_put_contents ( $ file_path , file_get_contents ( dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'templates' . DIRECTORY_SEPARATOR . $ file . '.txt' ) ) ; }
3816	protected function render ( $ table , $ metaModel , Request $ request ) { $ fields = $ this -> generateForm ( $ table , $ metaModel , $ request ) ; return [ 'action' => '' , 'requestToken' => REQUEST_TOKEN , 'href' => $ this -> getReferer ( $ request , $ table , true ) , 'backBt' => $ this -> translator -> trans ( 'MSC.backBT' , [ ] , 'contao_default' ) , 'add' => $ this -> translator -> trans ( 'MSC.continue' , [ ] , 'contao_default' ) , 'saveNclose' => $ this -> translator -> trans ( 'MSC.saveNclose' , [ ] , 'contao_default' ) , 'activate' => $ this -> translator -> trans ( $ table . '.addAll_activate' , [ ] , 'contao_' . $ table ) , 'headline' => $ this -> translator -> trans ( $ table . '.addall.1' , [ ] , 'contao_' . $ table ) , 'selectAll' => $ this -> translator -> trans ( 'MSC.selectAll' , [ ] , 'contao_default' ) , 'cacheMessage' => '' , 'updateMessage' => '' , 'hasCheckbox' => count ( $ fields ) > 0 , 'fields' => $ fields , ] ; }
2886	public function onActionPreDispatch ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ action = $ observer -> getData ( 'controller_action' ) ; $ this -> getRequestInfo ( ) -> initController ( $ action ) ; }
2928	public function getKeys ( $ keys = [ ] ) { $ allKeys = $ this -> reader -> keys ( ) ; return array_filter ( $ allKeys , function ( $ key ) use ( $ keys ) { if ( ! empty ( $ keys ) ) { return in_array ( $ key , $ keys ) ; } return true ; } , ARRAY_FILTER_USE_KEY ) ; }
640	public function dropPrimaryKey ( $ name , $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropPrimaryKey ( $ name , $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
928	public function delete ( $ path ) { if ( isset ( $ this -> files [ $ path ] ) ) { unset ( $ this -> files [ $ path ] ) ; } $ this -> unlink ( $ path ) ; }
5642	public function paintCaseEnd ( $ test_name ) { $ this -> progress ++ ; array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
5536	public function addFrame ( $ page , $ name = false ) { $ this -> frames [ ] = $ page ; if ( $ name ) { $ this -> names [ $ name ] = count ( $ this -> frames ) - 1 ; } }
8248	public function checkPasswordPolicy ( Password $ password ) { $ result = true ; $ policy = $ this -> picoAuth -> getContainer ( ) -> get ( "PasswordPolicy" ) ; $ maxAllowedLen = $ this -> getPasswordEncoder ( ) -> getMaxAllowedLen ( ) ; if ( is_int ( $ maxAllowedLen ) && strlen ( $ password ) > $ maxAllowedLen ) { $ this -> session -> addFlash ( "error" , "Maximum length is {$maxAllowedLen}." ) ; $ result = false ; } if ( ! $ policy -> check ( $ password ) ) { $ errors = $ policy -> getErrors ( ) ; foreach ( $ errors as $ error ) { $ this -> session -> addFlash ( "error" , $ error ) ; } return false ; } return $ result ; }
10942	private function reset ( ) { $ time = new \ DateTime ( ) ; $ this -> driver -> set ( self :: LAST_UPDATE_KEY , $ time ) ; return $ time ; }
9315	public function checkAcceptHeader ( Request $ request ) { $ headers = $ request -> getAcceptableContentTypes ( ) ; if ( array_intersect ( $ headers , [ 'application/json' , 'text/json' ] ) ) { return 'json' ; } elseif ( array_intersect ( $ headers , [ 'application/xml' , 'text/xml' ] ) ) { return 'xml' ; } return $ this -> defaultAcceptType ; }
3909	public function addPathById ( $ strId ) { if ( empty ( $ strId ) ) { return $ this ; } if ( ! Validator :: isBinaryUuid ( $ strId ) ) { $ this -> pendingIds [ ] = StringUtil :: uuidToBin ( $ strId ) ; return $ this ; } $ this -> pendingIds [ ] = $ strId ; return $ this ; }
6844	public function callInClass ( $ class_name , $ action , $ params = array ( ) ) { $ ref = new ReflectionMethod ( $ class_name , $ action ) ; if ( ! $ ref -> isPublic ( ) && ! $ ref -> isStatic ( ) ) throw new InjectorException ( "$class_name->$action is not public or static" ) ; $ params_need = $ ref -> getParameters ( ) ; $ args = $ this -> apply ( $ params_need , $ params ) ; $ obj = $ this -> produce ( $ class_name , $ params ) ; return call_user_func_array ( [ $ obj , $ action ] , $ args ) ; }
11594	public function postAction ( ) { $ request = $ this -> environment -> getRequestHelper ( ) ; $ id = $ request -> getIdentifierParam ( 'name' ) ; try { $ this -> pageList -> getPage ( $ id ) ; } catch ( InvalidParameterException $ e ) { $ page = $ this -> pageList -> addPageFromRequest ( $ id , $ request ) ; $ this -> environment -> sendJSONResult ( $ page -> getJSON ( ) ) ; return ; } throw new InvalidParameterException ( "Page already exists" ) ; }
11582	private function getPublicRequireDefinition ( ContainerBuilder $ container , $ id , $ type ) { $ serviceDefinition = $ container -> getDefinition ( $ id ) ; if ( ! $ serviceDefinition -> isPublic ( ) ) { throw new InvalidArgumentException ( sprintf ( 'The service "%s" must be public as block %s are lazy-loaded.' , $ id , $ type ) ) ; } return $ serviceDefinition ; }
751	protected function validateSlug ( $ slug ) { $ validator = Yii :: createObject ( array_merge ( [ 'class' => UniqueValidator :: className ( ) , ] , $ this -> uniqueValidator ) ) ; $ model = clone $ this -> owner ; $ model -> clearErrors ( ) ; $ model -> { $ this -> slugAttribute } = $ slug ; $ validator -> validateAttribute ( $ model , $ this -> slugAttribute ) ; return ! $ model -> hasErrors ( ) ; }
1618	public function scalar ( $ attribute , $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } $ record = $ this -> one ( $ db ) ; if ( $ record !== null ) { return $ record -> hasAttribute ( $ attribute ) ? $ record -> $ attribute : null ; } else { return null ; } }
1884	public static function count ( array $ arrOptions ) { $ strQuery = "SELECT COUNT(*) AS count FROM " . $ arrOptions [ 'table' ] ; if ( $ arrOptions [ 'column' ] !== null ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } return $ strQuery ; }
9976	public static function builtInFormatCode ( $ pIndex ) { $ pIndex = ( int ) $ pIndex ; self :: fillBuiltInFormatCodes ( ) ; if ( isset ( self :: $ builtInFormats [ $ pIndex ] ) ) { return self :: $ builtInFormats [ $ pIndex ] ; } return '' ; }
817	private function fixFunction ( Tokens $ tokens , $ startFunctionIndex ) { $ endFunctionIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ startFunctionIndex ) ; $ isMultiline = false ; $ firstWhitespaceIndex = $ this -> findWhitespaceIndexAfterParenthesis ( $ tokens , $ startFunctionIndex , $ endFunctionIndex ) ; $ lastWhitespaceIndex = $ this -> findWhitespaceIndexAfterParenthesis ( $ tokens , $ endFunctionIndex , $ startFunctionIndex ) ; foreach ( [ $ firstWhitespaceIndex , $ lastWhitespaceIndex ] as $ index ) { if ( null === $ index || ! Preg :: match ( '/\R/' , $ tokens [ $ index ] -> getContent ( ) ) ) { continue ; } if ( 'ensure_single_line' !== $ this -> configuration [ 'on_multiline' ] ) { $ isMultiline = true ; continue ; } $ newLinesRemoved = $ this -> ensureSingleLine ( $ tokens , $ index ) ; if ( ! $ newLinesRemoved ) { $ isMultiline = true ; } } for ( $ index = $ endFunctionIndex - 1 ; $ index > $ startFunctionIndex ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> equals ( ')' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; continue ; } if ( $ token -> isGivenKind ( CT :: T_ARRAY_SQUARE_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( '}' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( ',' ) ) { $ this -> fixSpace2 ( $ tokens , $ index ) ; if ( ! $ isMultiline && $ this -> isNewline ( $ tokens [ $ index + 1 ] ) ) { $ isMultiline = true ; break ; } } } return $ isMultiline ; }
3947	private function handleNonMetaModelTable ( $ tableName ) { if ( substr ( $ tableName , 0 , 3 ) === 'mm_' ) { return ; } static $ map ; if ( ! isset ( $ map ) ) { $ map = $ this -> buildMap ( ) ; } if ( ! isset ( $ map [ $ tableName ] ) ) { return ; } $ parentDCA = & $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] ; $ this -> controller -> loadLanguageFile ( 'default' ) ; foreach ( $ map [ $ tableName ] as $ metaModelTable => $ inputScreen ) { $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelTable ) ; $ caption = $ this -> buildCaption ( $ metaModel , $ inputScreen ) ; $ operationName = 'edit_' . $ metaModel -> getTableName ( ) ; $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] = array ( 'label' => & $ caption , 'href' => 'table=' . $ metaModelTable , 'icon' => $ this -> iconBuilder -> getBackendIcon ( $ inputScreen [ 'meta' ] [ 'backendicon' ] ) , 'attributes' => 'onclick="Backend.getScrollOffset()"' , ) ; if ( $ metaModel -> hasVariants ( ) ) { $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'idparam' ] = 'id_' . $ tableName ; } else { $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'idparam' ] = 'pid' ; } if ( $ parentDCA [ 'config' ] [ 'dataContainer' ] !== 'General' ) { $ idParameter = $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'idparam' ] ; $ parentDCA [ 'list' ] [ 'operations' ] [ $ operationName ] [ 'button_callback' ] = function ( $ row , $ href , $ label , $ name , $ icon , $ attributes , $ table ) use ( $ idParameter ) { return $ this -> buildChildOperationButton ( $ idParameter , $ row [ 'id' ] , $ href , $ label , $ name , $ icon , $ attributes , $ table ) ; } ; } } }
8001	public function calculateChallengeResponseData ( HashCredentialInterface $ hash_credential , $ data ) { $ padded_hash = str_pad ( $ hash_credential -> getValue ( ) , static :: DESL_FULL_KEY_LENGTH , static :: NULL_PAD_CHARACTER ) ; $ key_blocks = str_split ( $ padded_hash , static :: DESL_KEY_BLOCK_SEGMENT_LENGTH ) ; $ binary_data = array_reduce ( $ key_blocks , function ( $ result , $ key_block ) use ( $ data ) { return $ result . $ this -> des_encrypter -> encrypt ( $ key_block , $ data , CipherMode :: ECB , '' ) ; } , '' ) ; return $ binary_data ; }
3641	public function get ( string $ key , $ default = null , bool $ trim = true , bool $ clean = true ) { $ value = $ this -> request -> input ( $ key , $ default ) ; return $ this -> clean ( $ value , $ trim , $ clean ) ; }
11123	public function getUp ( $ time = NOW ) { foreach ( $ this -> movements as $ v ) { if ( $ v -> isActive ( $ time ) ) { $ up = $ v -> getCurrentUp ( $ time ) ; if ( isset ( $ up ) ) { return $ v -> getCurrentUp ( $ time ) ; } } } return new Neuron_GameServer_Map_Vector3 ( 0 , 1 , 0 ) ; }
1838	public static function findBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ blnModel = false ; $ arrColumn = ( array ) $ strColumn ; if ( \ count ( $ arrColumn ) == 1 && ( $ arrColumn [ 0 ] === static :: getPk ( ) || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) ) { $ blnModel = true ; } $ arrOptions = array_merge ( array ( 'column' => $ strColumn , 'value' => $ varValue , 'return' => $ blnModel ? 'Model' : 'Collection' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
7178	public function isValidType ( $ type ) { return in_array ( $ type , array ( self :: ANY , self :: FIXED_LINE , self :: MOBILE , self :: PAGER , self :: PERSONAL_NUMBER , self :: PREMIUM_RATE , self :: SHARED_COST , self :: TOLL_FREE , self :: UAN , self :: VOIP , self :: VOICEMAIL , ) , true ) ; }
3069	protected function endItemTimer ( $ timestamp = null ) { if ( $ this -> getRequestParameter ( 'itemDuration' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemDuration = $ this -> getRequestParameter ( 'itemDuration' ) ; return $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ timestamp ) ; } return false ; }
8283	protected function resolveRealUrl ( $ fileName ) { $ fileNameClean = str_replace ( "\0" , '' , $ fileName ) ; $ realPath = realpath ( $ fileNameClean ) ; if ( $ realPath === false ) { return $ this -> requestUrl ; } $ contentPath = realpath ( $ this -> pico -> getConfig ( 'content_dir' ) ) ; $ contentExt = $ this -> pico -> getConfig ( 'content_ext' ) ; if ( strpos ( $ realPath , $ contentPath ) !== 0 ) { throw new \ RuntimeException ( "The plugin cannot be used with " . "symbolic links inside the content directory." ) ; } $ name = substr ( $ realPath , strlen ( $ contentPath ) + 1 , - strlen ( $ contentExt ) ) ; if ( DIRECTORY_SEPARATOR !== '/' ) { $ name = str_replace ( DIRECTORY_SEPARATOR , '/' , $ name ) ; } if ( strlen ( $ name ) >= 5 && 0 === substr_compare ( $ name , "index" , - 5 ) ) { $ name = rtrim ( substr ( $ name , 0 , - 5 ) , '/' ) ; } return $ name ; }
10540	protected function typeModification ( $ type , array $ args ) { if ( is_int ( $ args [ 1 ] ) ) { $ type .= '(' . $ args [ 1 ] ; if ( isset ( $ args [ 2 ] ) ) { $ type .= ',' . $ args [ 2 ] ; } $ type .= ')' ; } elseif ( is_array ( $ args [ 1 ] ) ) { if ( isset ( $ args [ 1 ] [ 'size' ] ) ) { $ type .= '(' . $ args [ 1 ] [ 'size' ] . ')' ; } foreach ( $ args [ 1 ] as $ key => $ val ) { if ( 'size' === $ key ) { continue ; } $ type .= ' ' . strtoupper ( $ key ) ; } } else { $ type .= $ args [ 1 ] ; } return $ type ; }
2501	private function getFacetParams ( array $ facetBuilders ) { $ facetSets = array_map ( function ( $ facetBuilder ) { return $ this -> facetBuilderVisitor -> visitBuilder ( $ facetBuilder , spl_object_hash ( $ facetBuilder ) ) ; } , $ facetBuilders ) ; $ facetParams = array ( ) ; foreach ( $ facetSets as $ facetSet ) { foreach ( $ facetSet as $ key => $ value ) { if ( isset ( $ facetParams [ $ key ] ) ) { if ( ! is_array ( $ facetParams [ $ key ] ) ) { $ facetParams [ $ key ] = array ( $ facetParams [ $ key ] ) ; } $ facetParams [ $ key ] [ ] = $ value ; } else { $ facetParams [ $ key ] = $ value ; } } } return $ facetParams ; }
3125	protected function cloneTimePoint ( TimePoint $ point , $ type , $ timestamp = null ) { if ( is_null ( $ timestamp ) ) { $ timestamp = $ point -> getTimestamp ( ) ; } \ common_Logger :: d ( "Create missing TimePoint at " . $ timestamp ) ; return new TimePoint ( $ point -> getTags ( ) , $ timestamp , $ type , $ point -> getTarget ( ) ) ; }
5774	public function isDeletable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } $ id = $ this -> getId ( ) ; if ( $ this -> isLoggedIn ( ) ) { $ this -> notDeletableReason = "Administrator cannot delete own account: id $id" ; return false ; } if ( ! $ this -> getAuthorization ( ) -> hasTopRole ( ) && $ this -> hasTopRole ( ) ) { $ this -> notDeletableReason = "Not authorized to delete administrator: id $id" ; return false ; } if ( ( EventsTableMapper :: getInstance ( ) ) -> existForAdministrator ( $ id ) ) { $ this -> notDeletableReason = "Events exist for administrator: id $id" ; return false ; } return true ; }
4357	protected function processLog ( ) { $ str = '' ; foreach ( $ this -> data [ 'log' ] as $ entry ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; if ( $ this -> channelTest ( $ channel ) ) { $ str .= $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } } return $ str ; }
10446	protected function detectQueryType ( $ type ) { switch ( $ type ) { case 'INSERT INTO' : return ActionTypes :: CREATE ; case 'UPDATE' : return ActionTypes :: UPDATE ; case 'DELETE FROM' : return ActionTypes :: DELETE ; default : throw new \ UnexpectedValueException ( "Unknown statement of type {$type}" ) ; } }
2161	public function run33Update ( ) { $ objLayout = $ this -> Database -> query ( "SELECT id, framework FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ strFramework = '' ; $ tmp = StringUtil :: deserialize ( $ objLayout -> framework ) ; if ( ! empty ( $ tmp ) && \ is_array ( $ tmp ) ) { if ( ( $ key = array_search ( 'layout.css' , $ tmp ) ) !== false ) { array_insert ( $ tmp , $ key + 1 , 'responsive.css' ) ; } $ strFramework = serialize ( array_values ( array_unique ( $ tmp ) ) ) ; } $ this -> Database -> prepare ( "UPDATE tl_layout SET framework=? WHERE id=?" ) -> execute ( $ strFramework , $ objLayout -> id ) ; } $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `viewport` varchar(64) NOT NULL default ''" ) ; }
5115	public function submitArticle ( Article $ article ) : \ One \ Model \ Article { $ responseArticle = $ this -> post ( self :: ARTICLE_ENDPOINT , $ this -> normalizePayload ( $ article -> getCollection ( ) ) ) ; $ responseArticle = json_decode ( $ responseArticle , true ) ; $ article -> setId ( ( string ) $ responseArticle [ 'data' ] [ 'id' ] ) ; foreach ( $ article -> getPossibleAttachment ( ) as $ field ) { if ( $ article -> hasAttachment ( $ field ) ) { foreach ( $ article -> getAttachmentByField ( $ field ) as $ attachment ) { $ this -> submitAttachment ( $ article -> getId ( ) , $ attachment , $ field ) ; } } } return $ article ; }
5302	public static function unicodeToHex ( $ char ) { if ( ! is_string ( $ char ) || mb_strlen ( $ char , 'utf-8' ) !== 1 ) { throw new \ InvalidArgumentException ( '$char must be one single character' ) ; } $ unicode = unpack ( 'N' , mb_convert_encoding ( $ char , 'UCS-4BE' , 'UTF-8' ) ) ; return dechex ( $ unicode [ 1 ] ) ; }
2137	protected function escape ( $ varValue ) { if ( is_numeric ( $ varValue ) && ! preg_match ( '/e|^[+-]?0[^.]/' , $ varValue ) && $ varValue < PHP_INT_MAX ) { return $ varValue ; } if ( \ is_bool ( $ varValue ) ) { return $ varValue ? 'true' : 'false' ; } if ( $ varValue == 'true' ) { return 'true' ; } if ( $ varValue == 'false' ) { return 'false' ; } return "'" . str_replace ( '\\"' , '"' , preg_replace ( '/[\n\r\t ]+/' , ' ' , addslashes ( $ varValue ) ) ) . "'" ; }
8086	private function cleanConsole ( ) { $ channel = $ this -> namespaceChannel ( $ this -> currentChannel ) ; if ( empty ( $ this -> console [ 'errors' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'errors' ] [ $ channel ] ) ; } if ( empty ( $ this -> console [ 'form' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'form' ] [ $ channel ] ) ; } if ( empty ( $ this -> console [ 'reports' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'reports' ] [ $ channel ] ) ; } }
12032	function addDispatchMethod ( ) { $ methodGenerator = new MethodGenerator ( 'dispatch' ) ; $ body = '' ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= $ this -> generateResponseFragment ( ) ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response. Allows you to modify the request before it is sent.' ) ; $ parameter = new ParameterGenerator ( 'request' , 'Amp\Artax\Request' ) ; $ methodGenerator -> setParameter ( $ parameter ) ; $ tag = createParamTag ( $ parameter , 'The request to be processed' ) ; $ docBlock -> setTag ( $ tag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
4055	private function convertLegends ( array $ properties , IMetaModel $ metaModel , array $ conditions ) : array { $ result = [ ] ; $ label = [ ] ; if ( $ trans = $ metaModel -> isTranslated ( ) ) { foreach ( $ metaModel -> getAvailableLanguages ( ) as $ availableLanguage ) { $ label [ $ availableLanguage ] = $ metaModel -> getName ( ) ; } } else { $ label [ $ metaModel -> getActiveLanguage ( ) ] = $ metaModel -> getName ( ) ; } $ legend = [ 'label' => $ label , 'hide' => false , 'properties' => [ ] ] ; $ condition = function ( $ property ) use ( $ conditions ) { if ( ! isset ( $ conditions [ $ property [ 'id' ] ] ) ) { return null ; } return [ 'type' => 'conditionand' , 'children' => $ conditions [ $ property [ 'id' ] ] ] ; } ; foreach ( $ properties as $ property ) { switch ( $ property [ 'dcatype' ] ) { case 'legend' : $ this -> convertLegend ( $ property , $ trans , $ condition , $ legend , $ result ) ; break ; case 'attribute' : $ this -> convertAttribute ( $ property , $ condition , $ legend ) ; break ; default : break ; } } if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } return $ result ; }
8031	public function getProcessDetails ( $ pid ) { if ( $ this -> hasProcess ( $ pid ) === FALSE ) { return NULL ; } return $ this -> processDetails [ $ pid ] ; }
8854	public function getArchiveYear ( ) { $ year = $ this -> request -> param ( "Year" ) ; if ( preg_match ( "/^[0-9]{4}$/" , $ year ) ) { return ( int ) $ year ; } return null ; }
9292	public function getEndpointNode ( ) { $ builder = new TreeBuilder ( ) ; $ node = $ builder -> root ( 'endpoints' ) ; $ node -> info ( 'Defines version endpoints.' ) -> useAttributeAsKey ( 'endpoint' ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'endpoint' ) -> info ( 'Endpoint name (will be included in url (e.g. products))' ) -> example ( 'products' ) -> end ( ) -> scalarNode ( 'repository' ) -> isRequired ( ) -> info ( 'Document service from Elasticsearch bundle which will be used for data fetching' ) -> example ( 'es.manager.default.products' ) -> end ( ) -> arrayNode ( 'methods' ) -> defaultValue ( [ Request :: METHOD_POST , Request :: METHOD_GET , Request :: METHOD_PUT , Request :: METHOD_DELETE ] ) -> prototype ( 'scalar' ) -> validate ( ) -> ifNotInArray ( [ Request :: METHOD_HEAD , Request :: METHOD_POST , Request :: METHOD_PATCH , Request :: METHOD_GET , Request :: METHOD_PUT , Request :: METHOD_DELETE ] ) -> thenInvalid ( 'Invalid HTTP method used! Please check your ongr_api endpoint configuration.' ) -> end ( ) -> end ( ) -> end ( ) -> booleanNode ( 'allow_extra_fields' ) -> defaultFalse ( ) -> info ( 'Allows to pass unknown fields to an api. ' . 'Make sure you have configured elasticsearch respectively.' ) -> end ( ) -> arrayNode ( 'allow_fields' ) -> defaultValue ( [ ] ) -> info ( 'A list off a allowed fields to operate through api for a document.' ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> booleanNode ( 'allow_get_all' ) -> defaultTrue ( ) -> info ( 'Allows to use `_all` elasticsearch api to get all documents from a type.' ) -> end ( ) -> booleanNode ( 'allow_batch' ) -> defaultTrue ( ) -> info ( 'Allows to use `_batch` elasticsearch api to pass multiple documents in single API request.' ) -> end ( ) -> booleanNode ( 'variants' ) -> defaultFalse ( ) -> info ( 'If set to true user can manipulate document variants over API.' ) -> end ( ) -> booleanNode ( 'batch' ) -> defaultTrue ( ) -> info ( 'If set to true user can sent documents in batch\'s.' ) -> end ( ) -> end ( ) -> end ( ) ; return $ node ; }
6394	public function andFinally ( callable $ finallyBlock ) : TryTo { return TryTo :: run ( $ this -> tryBlock , $ this -> exceptions , $ finallyBlock ) ; }
6707	public function afterFind ( $ event ) { if ( is_array ( $ this -> fields ) ) { foreach ( $ this -> fields as $ field ) { if ( $ event -> sender -> { $ field } ) { $ event -> sender -> { $ field } = explode ( ';' , $ event -> sender -> { $ field } ) ; } } } }
3961	private function variantCssClass ( ) { if ( $ this -> isVariant ( ) ) { return 'variant' ; } if ( $ this -> isVariantBase ( ) ) { $ result = 'varbase' ; if ( 0 !== $ this -> getVariants ( null ) -> getCount ( ) ) { $ result .= ' varbase-with-variants' ; } return $ result ; } return '' ; }
5980	public function socialmedia ( ) { if ( ! $ this -> socialmedia instanceof SocialmediaController ) { $ this -> socialmedia = new SocialmediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> socialmedia -> setLogger ( $ this -> logger ) ; } return $ this -> socialmedia ; }
4291	private function publishMeta ( ) { $ debugClass = \ get_class ( $ this -> debug ) ; $ metaVals = array ( 'debug_version' => $ debugClass :: VERSION , ) ; $ keys = array ( 'HTTP_HOST' , 'HTTPS' , 'REMOTE_ADDR' , 'REQUEST_METHOD' , 'REQUEST_TIME' , 'REQUEST_URI' , 'SERVER_ADDR' , 'SERVER_NAME' , ) ; foreach ( $ keys as $ k ) { $ metaVals [ $ k ] = isset ( $ _SERVER [ $ k ] ) ? $ _SERVER [ $ k ] : null ; } if ( ! isset ( $ metaVals [ 'REQUEST_URI' ] ) && ! empty ( $ _SERVER [ 'argv' ] ) ) { $ metaVals [ 'REQUEST_URI' ] = '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; } $ this -> processLogEntry ( 'meta' , array ( $ metaVals , ) , array ( 'channel' => $ this -> debug -> getCfg ( 'channel' ) , ) ) ; }
2482	protected function generateQueryString ( array $ parameters ) { $ removedArrayCharacters = preg_replace ( '/%5B[0-9]+%5D=/' , '=' , http_build_query ( $ parameters ) ) ; $ removedDuplicatedEscapingForUrlPath = str_replace ( '%5C%5C%2F' , '%5C%2F' , $ removedArrayCharacters ) ; return $ removedDuplicatedEscapingForUrlPath ; }
8369	public function archiveAction ( string $ production_slug , AuthorizationCheckerInterface $ auth , PaginatorInterface $ paginator , Request $ request ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_EDITOR' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ query = $ this -> em -> getRepository ( Post :: class ) -> getAllInactiveQuery ( $ production ) ; $ posts = $ paginator -> paginate ( $ query , $ request -> query -> getInt ( 'page' , 1 ) ) ; return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Board/archive.html.twig' , [ 'production' => $ production , 'posts' => $ posts , ] ) ) ; }
9089	public function viewBody ( ) { $ sticky_values = hypePrototyper ( ) -> prototype -> getStickyValues ( $ this -> action ) ; hypePrototyper ( ) -> prototype -> clearStickyValues ( $ this -> action ) ; $ validation_status = hypePrototyper ( ) -> prototype -> getValidationStatus ( $ this -> action ) ; hypePrototyper ( ) -> prototype -> clearValidationStatus ( $ this -> action ) ; $ i = 0 ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getInputView ( ) === false ) { continue ; } $ shortname = $ field -> getShortname ( ) ; if ( isset ( $ sticky_values [ $ shortname ] ) ) { $ field -> setStickyValue ( $ sticky_values [ $ shortname ] ) ; } if ( isset ( $ validation_status [ $ shortname ] ) ) { $ field -> setValidation ( $ validation_status [ $ shortname ] [ 'status' ] , $ validation_status [ $ shortname ] [ 'messages' ] ) ; } $ output .= $ field -> viewInput ( array ( 'index' => $ i , 'entity' => $ this -> entity , ) ) ; $ i ++ ; } $ submit = elgg_view ( 'prototyper/input/submit' , array ( 'entity' => $ this -> entity , 'action' => $ this -> action , ) ) ; $ output .= elgg_format_element ( 'div' , array ( 'class' => 'elgg-foot' , ) , $ submit ) ; return $ output ; }
4391	public function getConfigBE ( ) { $ list = [ ] ; foreach ( $ this -> beConfig as $ key => $ config ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( $ config ) ; } return $ list ; }
577	protected static function normalizeRoute ( $ route ) { $ route = Yii :: getAlias ( ( string ) $ route ) ; if ( strncmp ( $ route , '/' , 1 ) === 0 ) { return ltrim ( $ route , '/' ) ; } if ( Yii :: $ app -> controller === null ) { throw new InvalidArgumentException ( "Unable to resolve the relative route: $route. No active controller is available." ) ; } if ( strpos ( $ route , '/' ) === false ) { return $ route === '' ? Yii :: $ app -> controller -> getRoute ( ) : Yii :: $ app -> controller -> getUniqueId ( ) . '/' . $ route ; } return ltrim ( Yii :: $ app -> controller -> module -> getUniqueId ( ) . '/' . $ route , '/' ) ; }
9652	protected function initFormField ( ) { $ options = $ this -> Options ( ) -> map ( 'EscapedTitle' , 'Title' ) ; return new OptionsetField ( $ this -> Name , $ this -> Title , $ options ) ; }
3613	public function setTargetTemperature ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
11283	protected function _populateAttributes ( $ record ) { foreach ( $ this -> model_attributes as $ key => $ def ) { if ( isset ( $ record [ $ this -> getFieldName ( $ key ) ] ) ) { $ fieldName = $ this -> getFieldName ( $ key ) ; if ( \ Cora \ Gateway :: is_serialized ( $ record [ $ fieldName ] ) ) { $ value = unserialize ( $ record [ $ fieldName ] ) ; } else if ( isset ( $ def [ 'type' ] ) && ( $ def [ 'type' ] == 'date' || $ def [ 'type' ] == 'datetime' ) ) { $ value = new \ DateTime ( $ record [ $ fieldName ] ) ; } else { $ value = $ record [ $ fieldName ] ; } $ this -> beforeSet ( $ key , $ value ) ; $ this -> model_data [ $ key ] = $ value ; $ this -> afterSet ( $ key , $ value ) ; } else if ( isset ( $ def [ 'models' ] ) || ( isset ( $ def [ 'model' ] ) && isset ( $ def [ 'usesRefTable' ] ) ) ) { if ( ! isset ( $ this -> model_data [ $ key ] ) ) $ this -> model_data [ $ key ] = 1 ; } } }
642	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
11242	protected function _call ( $ fieldData , $ controller , $ method , $ passing , $ arguments ) { $ fieldData = array ( $ fieldData , $ arguments ) ; $ result = call_user_func_array ( array ( $ controller , $ method ) , $ fieldData ) ; return $ result == $ passing ? true : false ; }
4932	public function renderJSON ( MvcEvent $ event ) { if ( ! $ this -> hasRunned ) { $ valueToPlainStati = array ( 1 => 'error' , 2 => 'error' , 3 => 'error' , 4 => 'error' , 5 => 'success' , 6 => 'info' , 7 => 'info' ) ; $ viewModel = $ event -> getViewModel ( ) ; if ( $ viewModel instanceof JsonModel ) { if ( ! empty ( $ this -> notifications ) ) { $ jsonNotifications = $ viewModel -> getVariable ( 'notifications' , array ( ) ) ; foreach ( $ this -> notifications as $ notification ) { $ status = 'info' ; if ( array_key_exists ( $ notification -> getPriority ( ) , $ valueToPlainStati ) ) { $ status = $ valueToPlainStati [ $ notification -> getPriority ( ) ] ; } $ jsonNotifications [ ] = array ( 'text' => $ notification -> getNotification ( ) , 'status' => $ status ) ; } $ viewModel -> setVariable ( 'notifications' , $ jsonNotifications ) ; } $ this -> hasRunned = true ; } } return ; }
3599	public function handleHttpRequest ( HttpRequest $ httpRequest ) { $ event = $ this -> dispatch ( Event \ HttpRequestEvent :: EVENT , new Event \ HttpRequestEvent ( $ httpRequest ) ) ; $ httpRequest = $ event -> getHttpRequest ( ) ; try { $ jsonRequests = $ this -> parserHttpRequest ( $ httpRequest ) ; } catch ( Exceptions \ ParseException $ e ) { return $ this -> createHttpResponseFromException ( $ e ) ; } $ jsonResponses = $ this -> jsonHandler -> handleJsonRequest ( $ jsonRequests ) ; $ httpResponse = HttpResponse :: create ( ) ; if ( $ this -> profiler ) { $ collect = function ( $ jsonResponse ) use ( & $ collect , $ httpRequest , $ httpResponse ) { if ( \ is_array ( $ jsonResponse ) ) { foreach ( $ jsonResponse as $ value ) { $ collect ( $ value ) ; } } else { if ( $ jsonResponse -> isError ( ) ) { $ this -> collectException ( $ httpRequest , $ httpResponse , new Exceptions \ ErrorException ( $ jsonResponse -> getErrorMessage ( ) , $ jsonResponse -> getErrorCode ( ) , $ jsonResponse -> getErrorData ( ) , $ jsonResponse -> getId ( ) ) ) ; } } } ; $ collect ( $ jsonResponses ) ; } if ( \ is_array ( $ jsonResponses ) ) { $ results = [ ] ; foreach ( $ jsonResponses as $ jsonResponse ) { if ( $ jsonResponse -> isError ( ) || $ jsonResponse -> getId ( ) ) { $ results [ ] = $ jsonResponse ; } if ( $ jsonResponse -> isError ( ) ) { $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; } } $ httpResponse -> setContent ( \ json_encode ( $ results ) ) ; } else { if ( $ jsonResponses -> isError ( ) || $ jsonResponses -> getId ( ) ) { $ httpResponse -> setContent ( \ json_encode ( $ jsonResponses ) ) ; } if ( $ jsonResponses -> isError ( ) ) { $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; } } if ( \ is_array ( $ jsonResponses ) ) { foreach ( $ jsonResponses as $ jsonResponse ) { if ( $ jsonResponse -> isError ( ) || $ jsonResponse -> getId ( ) ) { $ httpResponse -> headers -> add ( $ jsonResponse -> headers ( ) -> all ( ) ) ; } } } else { $ httpResponse -> headers -> add ( $ jsonResponses -> headers ( ) -> all ( ) ) ; } $ httpResponse -> headers -> set ( 'Content-Type' , 'application/json' ) ; $ this -> dispatch ( Event \ HttpResponseEvent :: EVENT , new Event \ HttpResponseEvent ( $ httpResponse ) ) ; return $ httpResponse ; }
2055	protected function validator ( $ varInput ) { $ arrTitles = array ( ) ; $ arrIds = array ( ) ; $ arrSections = array ( ) ; foreach ( $ varInput as $ arrSection ) { if ( ( ! empty ( $ arrSection [ 'title' ] ) && empty ( $ arrSection [ 'id' ] ) ) || ( empty ( $ arrSection [ 'title' ] ) && ! empty ( $ arrSection [ 'id' ] ) ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'emptyTitleOrId' ] ) ; } if ( \ in_array ( $ arrSection [ 'title' ] , $ arrTitles ) ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'duplicateSectionTitle' ] , $ arrSection [ 'title' ] ) ) ; } $ arrSection [ 'id' ] = StringUtil :: standardize ( $ arrSection [ 'id' ] , true ) ; if ( \ in_array ( $ arrSection [ 'id' ] , array ( 'top' , 'wrapper' , 'header' , 'container' , 'main' , 'left' , 'right' , 'footer' ) ) ) { $ arrSection [ 'id' ] .= '-custom' ; } if ( \ in_array ( $ arrSection [ 'id' ] , $ arrIds ) ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'duplicateSectionId' ] , $ arrSection [ 'id' ] ) ) ; } $ arrTitles [ ] = $ arrSection [ 'title' ] ; $ arrIds [ ] = $ arrSection [ 'id' ] ; $ arrSections [ ] = $ arrSection ; } return $ arrSections ; }
5746	public function getForm ( string $ csrfNameKey , string $ csrfNameValue , string $ csrfValueKey , string $ csrfValueValue , string $ action , ? string $ usernameValue = null ) { $ administratorsTableMapper = AdministratorsTableMapper :: getInstance ( ) ; $ fields = [ ] ; $ fields [ ] = DatabaseTableForm :: getFieldFromDatabaseColumn ( $ administratorsTableMapper -> getColumnByName ( self :: USERNAME_FIELD ) , null , $ usernameValue ) ; $ fields [ ] = DatabaseTableForm :: getFieldFromDatabaseColumn ( $ administratorsTableMapper -> getColumnByName ( self :: PASSWORD_FIELD ) , null , null , 'Password' , 'password' ) ; $ fields [ ] = FormHelper :: getCsrfNameField ( $ csrfNameKey , $ csrfNameValue ) ; $ fields [ ] = FormHelper :: getCsrfValueField ( $ csrfValueKey , $ csrfValueValue ) ; $ fields [ ] = FormHelper :: getSubmitField ( ) ; return new Form ( $ fields , [ 'method' => 'post' , 'action' => $ action , 'novalidate' => 'novalidate' ] , FormHelper :: getGeneralError ( ) ) ; }
3686	protected function getAndOrFilter ( IFilter $ filter , $ operation ) { if ( ! $ operation [ 'children' ] ) { return ; } if ( $ operation [ 'operation' ] == 'AND' ) { $ filterRule = new ConditionAnd ( ) ; } else { $ filterRule = new ConditionOr ( ) ; } $ filter -> addFilterRule ( $ filterRule ) ; $ children = $ this -> optimizedFilter ( $ filterRule , $ operation [ 'children' ] , $ operation [ 'operation' ] ) ; foreach ( $ children as $ child ) { $ subFilter = $ this -> getMetaModel ( ) -> getEmptyFilter ( ) ; $ filterRule -> addChild ( $ subFilter ) ; $ this -> calculateSubfilter ( $ child , $ subFilter ) ; } }
5462	public function stretch ( $ url ) { $ this -> root = $ this -> getCommonPath ( $ this -> root , $ url -> getPath ( ) ) ; }
1831	public function detach ( $ blnKeepClone = true ) { $ registry = Registry :: getInstance ( ) ; if ( ! $ registry -> isRegistered ( $ this ) ) { return ; } $ registry -> unregister ( $ this ) ; if ( $ blnKeepClone ) { $ this -> cloneOriginal ( ) -> attach ( ) ; } }
3592	protected function loadMetaAttributes ( ) { if ( ! array_key_exists ( 'metaAttributes' , $ this -> relations ) ) { $ this -> reloadMetaAttributes ( ) ; } $ attributes = $ this -> getRelation ( 'metaAttributes' ) ; if ( ! $ attributes instanceof AttributeBag ) { $ this -> setRelation ( 'metaAttributes' , ( new Attribute ) -> newBag ( $ attributes -> all ( ) ) ) ; } }
9358	public function getModulePath ( $ moduleName ) { if ( array_key_exists ( $ moduleName , $ this -> loadedModules ) ) { $ module = $ this -> loadedModules [ $ moduleName ] ; $ moduleConfig = $ module -> getAutoloaderConfig ( ) ; return $ moduleConfig [ self :: STANDARD_AUTOLOLOADER ] [ self :: NAMESPACE_KEY ] [ $ moduleName ] ; } return null ; }
2521	public function pnrIgnore ( RequestOptions \ PnrIgnoreOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Ignore' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
9492	private function getApplicationSize ( ) { $ size = cache ( ) -> remember ( 'foundation.app.size' , 5 , function ( ) { return $ this -> getFolderSize ( base_path ( ) ) ; } ) ; return $ this -> formatSize ( $ size ) ; }
11209	public function login ( $ subject ) { $ caller = $ this -> identifier -> identify ( $ subject ) ; if ( $ this -> authenticator -> authenticate ( $ subject , $ caller ) ) { $ this -> driver -> setLoginToken ( $ caller -> getLoginToken ( ) ) ; $ this -> currentCaller = $ caller ; return true ; } return false ; }
4692	public function andHaving ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> having = $ this -> having ? '(' . $ this -> having . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'having' , $ args ) ; return $ this ; }
9785	public function parseFor ( ) { $ for_open_token = $ this -> pop ( 'FOR_OPEN' ) ; $ this -> currLine ++ ; $ output = '$for_index = 0; foreach(' . $ for_open_token [ 1 ] [ 1 ] . ' as ' . $ for_open_token [ 1 ] [ 0 ] . ') {' . "\n" ; while ( true ) { list ( $ type , $ value ) = $ this -> peek ( ) ; if ( $ type == 'FOR_CLOSE' ) { $ this -> pop ( ) ; $ output .= '$for_index++; }' . "\n" ; $ this -> currLine ++ ; break ; } else { $ output .= $ this -> parseExpression ( ) ; } } return $ output ; }
9353	public function inverse ( ) { $ det = $ this -> det ( ) ; if ( $ det == 0 ) { throw new \ RuntimeException ( 'Cannot get inverse matrix: determinant is nul!' ) ; } return $ this -> adjugate ( ) -> multiply ( 1 / $ det ) ; }
7008	private function format_l ( & $ str ) { if ( strstr ( $ str , '%l' ) ) $ str = str_replace ( '%l' , $ this -> dayName ( true ) , $ str ) ; }
1074	public function toArray ( $ debug = false ) { $ result = [ ] ; if ( ! empty ( $ this -> errors ) ) { $ errorsHandler = $ this -> errorsHandler ? : static function ( array $ errors , callable $ formatter ) { return array_map ( $ formatter , $ errors ) ; } ; $ result [ 'errors' ] = $ errorsHandler ( $ this -> errors , FormattedError :: prepareFormatter ( $ this -> errorFormatter , $ debug ) ) ; } if ( $ this -> data !== null ) { $ result [ 'data' ] = $ this -> data ; } if ( ! empty ( $ this -> extensions ) ) { $ result [ 'extensions' ] = $ this -> extensions ; } return $ result ; }
7882	public function getIndex ( ) { $ today = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; if ( Session :: has ( 'success' ) || Session :: has ( 'error' ) ) { Session :: reflash ( ) ; } return Redirect :: to ( 'logviewer/' . $ today . '/all' ) ; }
4977	public function send ( \ Zend \ Mail \ Message $ message ) { $ options = $ this -> options ; $ filename = call_user_func ( $ options -> getCallback ( ) , $ this ) ; $ file = $ options -> getPath ( ) . DIRECTORY_SEPARATOR . $ filename ; $ contents = $ message -> toString ( ) ; $ umask = umask ( ) ; umask ( 022 ) ; if ( false === file_put_contents ( $ file , $ contents , LOCK_EX ) ) { throw new RuntimeException ( sprintf ( 'Unable to write mail to file (directory "%s")' , $ options -> getPath ( ) ) ) ; } umask ( $ umask ) ; $ this -> lastFile = $ file ; }
3609	public function getUserLocations ( ) { $ this -> prepareForGet ( ) ; $ structures = ( array ) $ this -> last_status -> structure ; $ user_structures = array ( ) ; $ class_name = get_class ( $ this ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ structures as $ struct_id => $ structure ) { $ protects = array ( ) ; foreach ( $ topaz as $ protect ) { if ( $ protect -> structure_id == $ struct_id ) { $ protects [ ] = $ protect -> serial_number ; } } $ weather_data = $ this -> getWeather ( $ structure -> postal_code , $ structure -> country_code ) ; $ user_structures [ ] = ( object ) array ( 'name' => isset ( $ structure -> name ) ? $ structure -> name : '' , 'address' => ! empty ( $ structure -> street_address ) ? $ structure -> street_address : NULL , 'city' => $ structure -> location , 'postal_code' => $ structure -> postal_code , 'country' => $ structure -> country_code , 'outside_temperature' => $ weather_data -> outside_temperature , 'outside_humidity' => $ weather_data -> outside_humidity , 'away' => $ structure -> away , 'away_last_changed' => date ( DATETIME_FORMAT , $ structure -> away_timestamp ) , 'thermostats' => array_map ( array ( $ class_name , 'cleanDevices' ) , $ structure -> devices ) , 'protects' => $ protects , ) ; } return $ user_structures ; }
1906	protected function replaceWildcards ( $ arrValues ) { $ arrValues = $ this -> escapeParams ( $ arrValues ) ; $ this -> strQuery = preg_replace ( '/(?<!%)%([^bcdufosxX%])/' , '%%$1' , $ this -> strQuery ) ; if ( ! $ this -> strQuery = @ vsprintf ( $ this -> strQuery , $ arrValues ) ) { throw new \ Exception ( 'Too few arguments to build the query string' ) ; } }
3886	public function collectRules ( $ filterSettings ) { $ information = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'fid=:fid' ) -> andWhere ( 'pid=0' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'fid' , $ filterSettings -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ information -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ newSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ newSetting ) { $ filterSettings -> addSetting ( $ newSetting ) ; } } }
5250	public function save ( $ columns = [ '*' ] ) { $ columns = $ columns ? ( array ) $ columns : [ '*' ] ; if ( $ this -> saving ( ) === false ) { return false ; } $ this -> fillTimestamp ( ) ; $ this -> _dal -> put ( $ columns ) ; $ this -> _exist = true ; if ( $ this -> saved ( ) === false ) { return false ; } return true ; }
8885	private function send ( ) { $ ch = curl_init ( $ this -> url ) ; curl_setopt ( $ ch , CURLOPT_HEADER , 1 ) ; curl_setopt ( $ ch , CURLOPT_POST , 1 ) ; curl_setopt ( $ ch , CURLOPT_TIMEOUT , 60 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , 0 ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , 0 ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ this -> xml ) ; $ result = curl_exec ( $ ch ) ; $ this -> xml = strstr ( $ result , '<?' ) ; $ this -> xml_result = new \ SimpleXMLElement ( $ this -> xml ) ; return $ this -> parseResult ( ) ; }
11109	public function getExtensions ( Container $ app ) { $ directories = $ this -> findExtensionsDirectories ( $ app ) ; foreach ( $ directories as $ directory ) { $ extensionName = $ directory -> getRelativePathname ( ) ; $ this -> extensions [ $ extensionName ] [ 'name' ] = $ extensionName ; $ this -> extensions [ $ extensionName ] [ 'pathName' ] = $ directory -> getPathName ( ) ; } return $ this -> extensions ; }
12354	public function setFilePath ( string $ viewFilePath ) : void { if ( ! is_readable ( $ viewFilePath ) ) { throw new Exception ( "The View file {$viewFilePath} isn't readable." ) ; } $ this -> filePath = $ viewFilePath ; }
11696	protected function normaliseSrcInput ( $ input ) : array { $ output = [ ] ; if ( $ input instanceof Finder ) { foreach ( $ input as $ fileInfo ) { $ output [ ] = $ fileInfo -> getRealpath ( ) ; } } else { if ( ! is_array ( $ input ) ) $ input = [ $ input ] ; if ( count ( $ input ) === 0 ) throw new \ UnexpectedValueException ; if ( ! is_string ( $ input [ 0 ] ) ) throw new \ UnexpectedValueException ; $ output = $ input ; } return $ output ; }
2504	protected static function getMessagesAndVersionsFromImportedWsdl ( $ import , $ wsdlPath , $ wsdlIdentifier ) { $ msgAndVer = [ ] ; $ domXpath = null ; $ importPath = realpath ( dirname ( $ wsdlPath ) ) . DIRECTORY_SEPARATOR . $ import ; $ wsdlContent = file_get_contents ( $ importPath ) ; if ( $ wsdlContent !== false ) { $ domDoc = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ ok = $ domDoc -> loadXML ( $ wsdlContent ) ; if ( $ ok === true ) { $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; $ domXpath -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ importPath . ' import could not be loaded' ) ; } if ( $ domXpath instanceof \ DOMXPath ) { $ nodeList = $ domXpath -> query ( self :: XPATH_ALL_OPERATIONS ) ; $ msgAndVer = array_merge ( $ msgAndVer , self :: loopOperationsWithQuery ( $ nodeList , self :: XPATH_ALT_VERSION_FOR_OPERATION , $ wsdlIdentifier , $ domXpath ) ) ; } return $ msgAndVer ; }
10437	public function inject_template ( midgardmvc_core_request $ request ) { $ route = $ request -> get_route ( ) ; $ route -> template_aliases [ 'content-sidebar' ] = 'cmp-show-sidebar' ; $ route -> template_aliases [ 'main-menu' ] = 'cmp-show-main_menu' ; midgardmvc_core :: get_instance ( ) -> head -> add_link ( array ( 'rel' => 'stylesheet' , 'type' => 'text/css' , 'href' => MIDGARDMVC_STATIC_URL . '/com_meego_planet/planet.css' ) ) ; }
8104	public function query ( $ sql , $ arguments = false ) { if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } else { return $ stmt ; } }
6889	protected function getAssignments ( $ item ) { if ( $ item instanceof ShipmentItemInterface ) { $ item = $ item -> getSaleItem ( ) ; } elseif ( $ item instanceof InvoiceLineInterface ) { if ( ! $ item = $ item -> getSaleItem ( ) ) { return null ; } } if ( ! $ this -> supportsAssignment ( $ item ) ) { return null ; } return $ item -> getStockAssignments ( ) -> toArray ( ) ; }
2989	public function setLogger ( LoggerInterface $ logger ) { if ( $ this -> transport instanceof LoggerAwareInterface ) { $ this -> transport -> setLogger ( $ logger ) ; } }
4345	public function getCfgLazy ( $ name ) { if ( ! isset ( $ this -> cfgLazy [ $ name ] ) ) { return array ( ) ; } $ return = $ this -> cfgLazy [ $ name ] ; unset ( $ this -> cfgLazy [ $ name ] ) ; return $ return ; }
6003	public function addVideoTemplate ( $ item ) { if ( ! ( $ item instanceof VideoTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new VideoTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate VideoTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "VideoTemplate"!' , E_USER_WARNING ) ; } } $ this -> videotemplates [ ] = $ item ; return $ this ; }
10354	protected function getEventName ( ) { $ chunks = explode ( '\\' , get_class ( $ this ) ) ; $ name = $ chunks [ count ( $ chunks ) - 2 ] ; return strtolower ( $ name ) ; }
8714	public function whereSubQuery ( $ column , $ query , $ boolean = 'and' ) { list ( $ type , $ operator ) = [ 'Sub' , 'in' ] ; $ this -> wheres [ ] = compact ( 'type' , 'column' , 'operator' , 'query' , 'boolean' ) ; $ this -> addBinding ( $ query -> getBindings ( ) , 'where' ) ; return $ this ; }
3903	public function renameColumn ( $ strNewColumnName ) { $ this -> tableManipulator -> checkColumnName ( $ strNewColumnName ) ; $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; $ columns = $ schemaManager -> listTableIndexes ( $ this -> getMetaModel ( ) -> getTableName ( ) ) ; if ( $ this -> getColName ( ) && isset ( $ columns [ $ this -> getColName ( ) ] ) ) { $ this -> tableManipulator -> renameColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) , $ strNewColumnName , $ this -> getSQLDataType ( ) ) ; } else { $ strBackupColName = $ this -> getColName ( ) ; $ this -> set ( 'colname' , $ strNewColumnName ) ; $ this -> createColumn ( ) ; $ this -> set ( 'colname' , $ strBackupColName ) ; } }
12923	public function getLocalDataItems ( ) { if ( ! isset ( $ this -> _localDataItems ) ) { $ this -> trigger ( self :: EVENT_LOAD_LOCAL_DATA_ITEMS ) ; } return $ this -> _localDataItems ; }
10435	public function post ( $ request ) { if ( $ request instanceof Request ) { $ request = $ request -> xml ( ) ; } $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> url ) ; if ( $ this -> user_agent != null ) { curl_setopt ( $ ch , CURLOPT_USERAGENT , $ this -> user_agent ) ; } curl_setopt ( $ ch , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_POST , 1 ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ request ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-type: application/xml; charset=utf-8' , ) ) ; $ response = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; if ( empty ( $ response ) ) { return null ; } return $ response ; }
12405	public function approveAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "page_manager" => $ app [ "red_kite_cms.page_manager" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: approve ( $ options ) ; }
11931	protected function generateField ( $ fieldType , $ fieldId , array $ labels ) { $ field = new FieldType ( ) ; $ field -> setType ( $ fieldType ) ; $ field -> setFieldId ( $ fieldId ) ; $ field -> setDefaultValue ( null ) ; $ field -> setSearchable ( true ) ; $ field -> setLabels ( $ labels ) ; return $ field ; }
1935	public function generate ( $ objPage ) { $ this -> redirect ( $ this -> getForwardUrl ( $ objPage ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; }
6760	static public function buildCacheKey ( $ columns = '*' , array $ conditionsAndOptions = [ ] ) { foreach ( $ conditionsAndOptions as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$conditionsAndOptions argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; if ( is_array ( $ columns ) ) { foreach ( $ columns as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$columns argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; } else if ( $ columns instanceof DbExpr ) { $ columns = $ columns -> get ( ) ; } return hash ( 'sha256' , json_encode ( array ( $ columns , $ conditionsAndOptions ) ) ) ; }
7301	static public function getTargetsForSale ( SaleInterface $ sale ) { if ( $ sale instanceof CartInterface ) { return [ static :: TARGET_ORDER , static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof OrderInterface ) { if ( $ sale -> getState ( ) !== OrderStates :: STATE_NEW ) { return [ ] ; } return [ static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof QuoteInterface ) { return [ static :: TARGET_ORDER ] ; } throw new InvalidArgumentException ( "Unexpected sale type." ) ; }
2774	public function setPrivateKey ( string $ privateKey , int $ port = 22 , ? string $ wrapper = null ) : void { if ( $ wrapper === null ) { $ wrapper = __DIR__ . '/../bin/git-ssh-wrapper.sh' ; } if ( ! $ wrapperPath = realpath ( $ wrapper ) ) { throw new GitException ( 'Path to GIT_SSH wrapper script could not be resolved: ' . $ wrapper ) ; } if ( ! $ privateKeyPath = realpath ( $ privateKey ) ) { throw new GitException ( 'Path private key could not be resolved: ' . $ privateKey ) ; } $ this -> setEnvVar ( 'GIT_SSH' , $ wrapperPath ) ; $ this -> setEnvVar ( 'GIT_SSH_KEY' , $ privateKeyPath ) ; $ this -> setEnvVar ( 'GIT_SSH_PORT' , $ port ) ; }
6912	public function addInvoice ( InvoiceInterface $ invoice ) { if ( ! $ this -> invoices -> contains ( $ invoice ) ) { $ this -> invoices -> add ( $ invoice ) ; } return $ this ; }
244	public function export ( ) { openlog ( $ this -> identity , $ this -> options , $ this -> facility ) ; foreach ( $ this -> messages as $ message ) { if ( syslog ( $ this -> _syslogLevels [ $ message [ 1 ] ] , $ this -> formatMessage ( $ message ) ) === false ) { throw new LogRuntimeException ( 'Unable to export log through system log!' ) ; } } closelog ( ) ; }
12966	public function getObjectTypeDescriptor ( ) { if ( is_null ( $ this -> _objectTypeDescriptor ) && isset ( $ this -> object ) ) { $ this -> _objectTypeDescriptor = $ this -> object -> objectType -> title -> upperSingular ; } return $ this -> _objectTypeDescriptor ; }
2748	private function extractMapping ( $ mapping , $ countryCode ) { $ final = null ; $ extractMapping = json_decode ( $ mapping , true ) ; if ( ! $ extractMapping ) { try { $ extractMapping = unserialize ( $ mapping ) ; } catch ( \ Exception $ e ) { $ extractMapping = [ ] ; } } if ( is_array ( $ extractMapping ) ) { $ countryId = 'country_id' ; $ key = 'store_id' ; foreach ( $ extractMapping as $ map ) { if ( is_array ( $ map ) && isset ( $ map [ $ countryId ] ) && strtolower ( str_replace ( ' ' , '' , $ map [ $ countryId ] ) ) == strtolower ( $ countryCode ) ) { if ( isset ( $ map [ $ key ] ) ) { return ( int ) $ map [ $ key ] ; } } elseif ( is_array ( $ map ) && isset ( $ map [ $ countryId ] ) && $ map [ $ countryId ] == '*' && isset ( $ map [ $ key ] ) && $ final === null ) { $ final = ( int ) $ map [ $ key ] ; } } } return $ final ; }
6962	public static function B ( $ year ) { $ jd = static :: B1900 ( ) -> jd + ( $ year - 1900 ) * static :: DaysBesselianYear ; $ epoch = new static ( $ jd ) ; $ epoch -> type = YearType :: Besselian ( ) ; return $ epoch ; }
1540	public function withQualifiedColumn ( $ column ) { $ parts = explode ( '.' , $ column ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withColumn ( $ parts [ 1 ] ) ; return $ this ; }
12038	public function drop ( $ key ) { if ( $ this -> has ( $ key ) ) { unset ( $ _SESSION [ $ this -> root ] [ $ key ] ) ; return true ; } return false ; }
10363	public function __isset ( $ childName ) { foreach ( $ this -> nodes as $ node ) { if ( isset ( $ node -> $ childName ) ) { return true ; } } return false ; }
3922	private function resizeImage ( $ fileName ) { list ( $ width , $ height , $ mode ) = $ this -> getResizeImages ( ) ; if ( $ this -> getShowImages ( ) && ( $ width || $ height || $ mode ) ) { if ( $ this -> imageFactory ) { $ image = $ this -> imageFactory -> create ( $ this -> rootDir . '/' . $ fileName , [ $ width , $ height , $ mode ] ) ; return $ image -> getUrl ( $ this -> rootDir ) ; } $ event = new ResizeImageEvent ( $ fileName , $ width , $ height , $ mode ) ; $ this -> dispatcher -> dispatch ( ContaoEvents :: IMAGE_RESIZE , $ event ) ; return $ event -> getResultImage ( ) ; } return $ fileName ; }
9909	public function setPositionXL ( $ positionXL ) { if ( ! isset ( self :: $ positionXLref [ $ positionXL ] ) ) { return false ; } $ this -> position = self :: $ positionXLref [ $ positionXL ] ; return true ; }
11825	public function add ( $ encoding = 'UTF-8' ) { $ str = file_get_contents ( $ this -> uri ) ; return file_put_contents ( $ this -> uri , $ this -> getBom ( $ encoding ) . $ str ) ; }
11799	public function setReplyTo ( $ mail = '' , $ name = null ) { if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { if ( ! empty ( $ name ) ) { $ _m = Helper :: mailTagger ( $ mail , $ name ) ; } else { $ _m = $ mail ; } $ this -> getMailer ( ) -> setRegistry ( 'Reply-To' , $ _m , 'headers' ) ; } return $ this ; }
495	public function getProfiling ( $ categories = [ ] , $ excludeCategories = [ ] ) { $ timings = $ this -> calculateTimings ( $ this -> messages ) ; if ( empty ( $ categories ) && empty ( $ excludeCategories ) ) { return $ timings ; } foreach ( $ timings as $ i => $ timing ) { $ matched = empty ( $ categories ) ; foreach ( $ categories as $ category ) { $ prefix = rtrim ( $ category , '*' ) ; if ( ( $ timing [ 'category' ] === $ category || $ prefix !== $ category ) && strpos ( $ timing [ 'category' ] , $ prefix ) === 0 ) { $ matched = true ; break ; } } if ( $ matched ) { foreach ( $ excludeCategories as $ category ) { $ prefix = rtrim ( $ category , '*' ) ; foreach ( $ timings as $ i => $ timing ) { if ( ( $ timing [ 'category' ] === $ category || $ prefix !== $ category ) && strpos ( $ timing [ 'category' ] , $ prefix ) === 0 ) { $ matched = false ; break ; } } } } if ( ! $ matched ) { unset ( $ timings [ $ i ] ) ; } } return array_values ( $ timings ) ; }
12861	private function buildCache ( ) : array { $ dispatchData = $ this -> routeCollector -> getData ( ) ; file_put_contents ( $ this -> cacheFile , '<?php return ' . var_export ( $ dispatchData , true ) . ';' ) ; return $ dispatchData ; }
10634	public function getArrayFromJsonFile ( $ strFilePath , $ strFileName ) { $ jSonContent = $ this -> getFileJsonContent ( $ strFilePath , $ strFileName ) ; $ arrayToReturn = json_decode ( $ jSonContent , true ) ; if ( json_last_error ( ) != JSON_ERROR_NONE ) { $ fName = $ this -> gluePathWithFileName ( $ strFilePath , $ strFileName ) ; throw new \ RuntimeException ( sprintf ( 'Unable to interpret JSON from %s file...' , $ fName ) ) ; } return $ arrayToReturn ; }
8553	public function setDebtRecoveryEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DebtRecoveryEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9438	public function reset ( ) { $ this -> rho = null ; $ this -> theta = null ; $ this -> r = null ; $ this -> i = null ; return $ this ; }
3713	public function isNestedType ( ) { if ( ! isset ( $ this -> isNestedType ) ) { $ this -> isNestedType = in_array ( 'MetaModels\Filter\Setting\IWithChildren' , class_implements ( $ this -> typeClass , true ) ) ; } return $ this -> isNestedType ; }
4838	public function new_limit_url ( $ type , $ params ) { $ request = array ( ) ; $ params [ 'merchant_id' ] = $ this -> account_details [ 'merchant_id' ] ; $ opt_params = array ( 'redirect_uri' , 'cancel_uri' , 'state' ) ; foreach ( $ opt_params as $ opt_param ) { if ( isset ( $ params [ $ opt_param ] ) ) { $ request [ $ opt_param ] = $ params [ $ opt_param ] ; unset ( $ params [ $ opt_param ] ) ; } } if ( ! isset ( $ request [ 'redirect_uri' ] ) && isset ( $ this -> redirect_uri ) ) { $ request [ 'redirect_uri' ] = $ this -> redirect_uri ; } $ payment_params = array ( $ type => $ params ) ; $ request = array_merge ( $ request , $ payment_params , $ this -> generate_mandatory_params ( ) ) ; $ request [ 'signature' ] = GoCardless_Utils :: generate_signature ( $ request , $ this -> account_details [ 'app_secret' ] ) ; $ query_string = GoCardless_Utils :: generate_query_string ( $ request ) ; return $ this -> base_url . '/connect/' . $ type . 's/new?' . $ query_string ; }
9657	public function mount ( $ prefix = null ) { if ( $ prefix ) { $ this -> router -> group ( [ 'prefix' => $ prefix ] , function ( ) { $ this -> registerRoutes ( ) ; } ) ; } else { $ this -> registerRoutes ( ) ; } }
8442	public function render ( array $ args , bool $ prettyPrint = null ) { header ( 'Content-type: application/json' ) ; if ( ( constant ( 'STRAY_ENV' ) === 'development' && $ prettyPrint !== false ) || $ prettyPrint === true ) { return ( string ) json_encode ( $ args , JSON_PRETTY_PRINT ) ; } return ( string ) json_encode ( $ args ) ; }
8771	public function registerConfiguredProviders ( ) { $ providers = Collection :: make ( $ this -> config [ 'app.providers' ] ) -> partition ( function ( $ provider ) { return Str :: startsWith ( $ provider , 'Nur\\' ) ; } ) ; $ providers -> splice ( 1 , 0 , [ $ this -> make ( PackageManifest :: class ) -> providers ( ) ] ) ; ( new ProviderRepository ( $ this , new Filesystem , $ this -> getCachedServicesPath ( ) ) ) -> load ( $ providers -> collapse ( ) -> toArray ( ) ) ; }
4883	public function generatePublicAlias ( $ subject , $ currentAlias = '' ) { $ alias = $ this -> strategyWrapper -> generatePublicAlias ( $ subject , $ currentAlias ) ; if ( $ alias !== null && method_exists ( $ subject , 'getLanguage' ) ) { if ( in_array ( $ subject -> getLanguage ( ) , $ this -> localesToPrefix ) ) { $ alias = sprintf ( '%s%s%s' , $ this -> basePath , $ subject -> getLanguage ( ) , $ alias ) ; } } return $ alias ; }
6108	public function clientPermRemove ( $ cldbid , $ permid ) { return $ this -> getParent ( ) -> channelClientPermRemove ( $ this -> getId ( ) , $ cldbid , $ permid ) ; }
5381	public function getValue ( ) { if ( $ this -> choice === false ) { return $ this -> getDefault ( ) ; } return $ this -> options [ $ this -> choice ] -> getValue ( ) ; }
2449	public function editComment ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> isAllowedToEditComment ( $ row [ 'parent' ] , $ row [ 'source' ] ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg/i' , '_.svg' , $ icon ) ) . ' ' ; }
4963	public function addViewTemplate ( $ name , $ template , $ vars = [ ] , $ priority = 0 ) { if ( is_int ( $ vars ) ) { $ priority = $ vars ; $ vars = [ ] ; } $ model = new ViewModel ( $ vars ) ; $ model -> setTemplate ( $ template ) ; return $ this -> addViewModel ( $ name , $ model , $ priority ) ; }
11183	public function getActions ( ) { if ( $ this -> useCache ( ) ) { if ( $ this -> getExtCache ( ) -> isCached ( ) ) { return $ this -> getExtCache ( ) -> getActions ( ) ; } } $ actions = $ this -> generateActions ( ) ; if ( $ this -> useCache ( ) ) { $ this -> getExtCache ( ) -> cacheActions ( $ actions ) ; } return $ actions ; }
5332	public static function haikunate ( array $ params = [ ] ) { $ defaults = [ "delimiter" => "-" , "tokenLength" => 4 , "tokenHex" => false , "tokenChars" => "0123456789" , ] ; $ params = array_merge ( $ defaults , $ params ) ; if ( $ params [ "tokenHex" ] == true ) { $ params [ "tokenChars" ] = "0123456789abcdef" ; } $ adjective = self :: $ ADJECTIVES [ mt_rand ( 0 , count ( self :: $ ADJECTIVES ) - 1 ) ] ; $ noun = self :: $ NOUNS [ mt_rand ( 0 , count ( self :: $ NOUNS ) - 1 ) ] ; $ token = "" ; for ( $ i = 0 ; $ i < $ params [ "tokenLength" ] ; $ i ++ ) { $ token .= $ params [ "tokenChars" ] [ mt_rand ( 0 , strlen ( $ params [ "tokenChars" ] ) - 1 ) ] ; } $ sections = [ $ adjective , $ noun , $ token ] ; return implode ( $ params [ "delimiter" ] , array_filter ( $ sections ) ) ; }
12277	public function update ( $ groupId , $ name ) { $ params = [ 'group' => [ 'id' => $ groupId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
117	protected function getCommand ( $ cmd , $ url , $ path = null ) { $ cmd = sprintf ( '%s %s%s %s' , $ cmd , '--non-interactive ' , $ this -> getCredentialString ( ) , ProcessExecutor :: escape ( $ url ) ) ; if ( $ path ) { $ cmd .= ' ' . ProcessExecutor :: escape ( $ path ) ; } return $ cmd ; }
11298	public function getModelsFromCustomRelationship ( $ attributeName , $ objName , $ query = false , $ loadMap = false ) { $ repo = \ Cora \ RepositoryFactory :: make ( $ objName , false , false , false , $ this -> model_db ) ; if ( ! $ query ) $ query = $ this -> _getQueryObjectForRelation ( $ attributeName ) ; $ definingFunctionName = $ this -> model_attributes [ $ attributeName ] [ 'using' ] ; $ query = $ this -> $ definingFunctionName ( $ query ) ; return $ repo -> findAll ( $ query , false , $ loadMap ) ; }
2199	public static function findPublishedByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
6855	private function transform ( SaleInterface $ sale ) { $ order = $ this -> newOrder ( ) ; $ this -> saleTransformer -> initialize ( $ sale , $ order ) ; if ( null === $ event = $ this -> saleTransformer -> transform ( ) ) { return $ order ; } return null ; }
591	protected function compressCssFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing CSS files...\n" ) ; if ( is_string ( $ this -> cssCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineCssFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> cssCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> cssCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress CSS files into '{$outputFile}'." ) ; } $ this -> stdout ( " CSS files compressed into '{$outputFile}'.\n" ) ; }
1989	public static function addToUrl ( $ strRequest , $ blnIgnoreParams = false , $ arrUnset = array ( ) ) { $ arrGet = $ blnIgnoreParams ? array ( ) : $ _GET ; foreach ( array_keys ( $ arrGet ) as $ key ) { $ arrGet [ $ key ] = Input :: get ( $ key , true , true ) ; } $ arrFragments = preg_split ( '/&(amp;)?/i' , $ strRequest ) ; foreach ( $ arrFragments as $ strFragment ) { list ( $ key , $ value ) = explode ( '=' , $ strFragment ) ; if ( $ value == '' ) { unset ( $ arrGet [ $ key ] ) ; } else { $ arrGet [ $ key ] = $ value ; } } if ( Config :: get ( 'addLanguageToUrl' ) ) { unset ( $ arrGet [ 'language' ] ) ; } $ strParams = '' ; $ strConnector = '/' ; $ strSeparator = '/' ; foreach ( $ arrGet as $ k => $ v ) { if ( Config :: get ( 'useAutoItem' ) && ( $ k == 'auto_item' || \ in_array ( $ k , $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) ) { $ strParams = $ strConnector . urlencode ( $ v ) . $ strParams ; } else { $ strParams .= $ strConnector . urlencode ( $ k ) . $ strSeparator . urlencode ( $ v ) ; } } global $ objPage ; $ pageId = $ objPage -> alias ? : $ objPage -> id ; if ( empty ( $ pageId ) ) { $ pageId = static :: getPageIdFromUrl ( ) ; } $ arrParams = array ( ) ; $ arrParams [ 'alias' ] = $ pageId . $ strParams ; if ( Config :: get ( 'addLanguageToUrl' ) ) { $ arrParams [ '_locale' ] = $ objPage -> rootLanguage ; } $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_frontend' , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; return $ strUrl ; }
8539	public function setGetMyPriceForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMyPriceForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9385	public function getGroupedIcons ( ) { if ( $ icons = self :: cache ( ) -> get ( $ this -> getCacheKey ( ) ) ) { return $ icons ; } $ icons = [ ] ; $ data = Yaml :: parse ( $ this -> getSourceData ( ) ) ; if ( isset ( $ data [ 'icons' ] ) ) { foreach ( $ data [ 'icons' ] as $ icon ) { foreach ( $ icon [ 'categories' ] as $ category ) { if ( ! isset ( $ icons [ $ category ] ) ) { $ icons [ $ category ] = [ ] ; } $ icons [ $ category ] [ $ icon [ 'id' ] ] = [ 'name' => $ icon [ 'name' ] , 'unicode' => $ icon [ 'unicode' ] ] ; } } } ksort ( $ icons ) ; foreach ( $ icons as & $ group ) { uasort ( $ group , function ( $ a , $ b ) { return strcasecmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; } self :: cache ( ) -> set ( $ this -> getCacheKey ( ) , $ icons ) ; return $ icons ; }
11099	public static function maxCount ( ) { $ array = \ func_get_args ( ) ; if ( ! \ is_array ( $ array ) ) { return 0 ; } $ maxCnt = 0 ; foreach ( $ array as $ item ) { if ( ! \ is_array ( $ item ) ) { continue ; } $ cnt = \ count ( $ item ) ; $ maxCnt = $ cnt > $ maxCnt ? $ cnt : $ maxCnt ; } return $ maxCnt ; }
6801	public function installTaxes ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_taxes.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Taxes data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } $ country = $ this -> manager -> getRepository ( Country :: class ) -> findOneBy ( [ 'code' => $ code ] ) ; if ( null === $ country ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( null === $ taxRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ tax = new Tax ( ) ; $ tax -> setName ( $ name ) -> setRate ( $ datum [ 'rate' ] ) -> setCountry ( $ country ) ; $ this -> manager -> persist ( $ tax ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
3780	protected function getFilteredAttribute ( ) { if ( ! ( $ attributeId = $ this -> get ( 'attr_id' ) ) ) { return null ; } if ( $ attribute = $ this -> getMetaModel ( ) -> getAttributeById ( $ attributeId ) ) { return $ attribute ; } return null ; }
8696	public function handle ( ) { $ config = $ this -> option ( 'config' ) ; if ( ! $ config ) { throw new Exception ( 'Config option is required.' ) ; } $ configPath = realpath ( $ config ) ; if ( ! file_exists ( $ configPath ) ) { throw new Exception ( 'Configuration file not found.' ) ; } $ config = require ( $ configPath ) ; $ this -> info ( sprintf ( 'Configuring with file "%s".' , $ configPath ) ) ; $ this -> getRbacService ( ) -> configure ( $ config ) ; $ this -> info ( 'Configuration done.' ) ; }
7414	public function read ( ) { $ data = '' ; $ fileObj = $ this -> openFile ( ) ; while ( ! $ fileObj -> eof ( ) ) { $ data .= $ fileObj -> fread ( 4096 ) ; } $ fileObj = null ; return $ data ; }
3245	public function onCharge ( $ order ) { $ this -> statusCode = 'pending' ; $ this -> detail = 'pending response, token:' . $ this -> token ; return parent :: onCharge ( $ order ) ; }
4731	public static function unicode_to_utf16 ( $ str ) { if ( \ extension_loaded ( 'mbstring' ) ) { return preg_replace_callback ( '/\\\\u([0-9a-fA-F]{4})/' , function ( $ match ) { return mb_convert_encoding ( pack ( 'H*' , $ match [ 1 ] ) , 'UTF-8' , 'UTF-16BE' ) ; } , $ str ) ; } return $ str ; }
2784	private function indent ( $ output , $ asArray = false ) { $ lines = explode ( "\n" , $ output ) ; $ out = [ ] ; foreach ( $ lines as $ line ) { $ out [ ] = ' > ' . $ line ; } if ( $ asArray ) { return $ out ; } $ return = implode ( "\n" , $ out ) ; return $ return ; }
12678	public function toJSON ( $ pretty = false ) { if ( $ pretty ) { return json_encode ( $ this -> scope -> results , JSON_PRETTY_PRINT ) ; } return json_encode ( $ this -> scope -> results ) ; }
4820	public function addField ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> row [ $ name ] = $ value ; } elseif ( is_array ( $ this -> row [ $ name ] ) ) { $ this -> row [ $ name ] [ ] = $ value ; } else { $ this -> row [ $ name ] = array ( $ this -> row [ $ name ] , $ value ) ; } $ this -> informChanges ( ) ; }
5063	public function outputJson ( int $ depth = 512 , int $ options = 0 ) { $ json = json_decode ( $ this -> output ( ) , false , $ depth , $ options ) ; if ( is_null ( $ json ) ) { $ errorMessage = json_last_error_msg ( ) ; throw new JsonDecodeException ( $ errorMessage ) ; } return $ json ; }
2929	public function keyExists ( $ key ) { $ allKeys = $ this -> getKeys ( ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return true ; } return false ; }
9066	public function persist ( MessageInterface $ message ) { if ( $ message -> getMessageId ( ) > 0 ) { $ this -> update ( $ message , null , null , new MessageHydrator ) ; } else { $ this -> insert ( $ message , null , new MessageHydrator ) ; } return $ message ; }
8739	private function updateBase ( array $ values , array $ ids ) { $ query = $ this -> model -> newQuery ( ) -> whereIn ( $ this -> model -> getKeyName ( ) , $ ids ) -> getQuery ( ) ; return $ query -> update ( $ values ) ; }
1877	public function delete ( $ source = null ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ blnDoNotRedirect = ( $ source !== null ) ; if ( $ source === null ) { $ source = $ this -> intId ; } $ this -> isValid ( $ source ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ source ) || ! $ this -> isMounted ( $ source ) ) { throw new AccessDeniedException ( 'File or folder "' . $ source . '" is not mounted or cannot be found.' ) ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ondelete_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'ondelete_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ source , $ this ) ; } elseif ( \ is_callable ( $ callback ) ) { $ callback ( $ source , $ this ) ; } } } $ this -> import ( Files :: class , 'Files' ) ; if ( is_dir ( $ this -> strRootDir . '/' . $ source ) ) { $ this -> Files -> rrdir ( $ source ) ; $ strWebDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.web_dir' ) ) ; if ( is_link ( $ this -> strRootDir . '/' . $ strWebDir . '/' . $ source ) ) { $ this -> Files -> delete ( $ strWebDir . '/' . $ source ) ; } } else { $ this -> Files -> delete ( $ source ) ; } if ( $ this -> blnIsDbAssisted && Dbafs :: shouldBeSynchronized ( $ source ) ) { Dbafs :: deleteResource ( $ source ) ; } $ this -> log ( 'File or folder "' . $ source . '" has been deleted' , __METHOD__ , TL_FILES ) ; if ( ! $ blnDoNotRedirect ) { $ this -> redirect ( $ this -> getReferer ( ) ) ; } }
10069	public function addDecorator ( TagDecoratorInterface $ decorator , $ priority = 0 ) { $ this -> decorators -> add ( $ decorator , $ priority ) ; return $ this ; }
5041	public function onBootstrap ( MvcEvent $ e ) { if ( ! DoctrineType :: hasType ( 'tz_date' ) ) { DoctrineType :: addType ( 'tz_date' , '\Core\Repository\DoctrineMongoODM\Types\TimezoneAwareDate' ) ; } $ sm = $ e -> getApplication ( ) -> getServiceManager ( ) ; $ translator = $ sm -> get ( 'translator' ) ; \ Zend \ Validator \ AbstractValidator :: setDefaultTranslator ( $ translator ) ; $ eventManager = $ e -> getApplication ( ) -> getEventManager ( ) ; $ sharedManager = $ eventManager -> getSharedManager ( ) ; if ( ! \ Zend \ Console \ Console :: isConsole ( ) ) { ( new ErrorHandlerListener ( ) ) -> attach ( $ eventManager ) ; $ languageRouteListener = new LanguageRouteListener ( $ sm -> get ( 'Core/Locale' ) , $ sm -> get ( 'Core/Options' ) ) ; $ languageRouteListener -> attach ( $ eventManager ) ; $ ajaxRenderListener = new AjaxRenderListener ( ) ; $ ajaxRenderListener -> attach ( $ eventManager ) ; $ ajaxRouteListener = $ sm -> get ( AjaxRouteListener :: class ) ; $ ajaxRouteListener -> attach ( $ eventManager ) ; $ xmlRenderListener = new XmlRenderListener ( ) ; $ xmlRenderListener -> attach ( $ eventManager ) ; $ enforceJsonResponseListener = new EnforceJsonResponseListener ( ) ; $ enforceJsonResponseListener -> attach ( $ eventManager ) ; $ stringListener = new StringListener ( ) ; $ stringListener -> attach ( $ eventManager ) ; } $ notificationListener = $ sm -> get ( 'Core/Listener/Notification' ) ; $ notificationListener -> attachShared ( $ sharedManager ) ; $ notificationAjaxHandler = new NotificationAjaxHandler ( ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH , array ( $ notificationAjaxHandler , 'injectView' ) , - 20 ) ; $ notificationListener -> attach ( NotificationEvent :: EVENT_NOTIFICATION_HTML , array ( $ notificationAjaxHandler , 'render' ) , - 20 ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH_ERROR , function ( $ event ) { if ( $ event instanceof MvcEvent ) { $ application = $ event -> getApplication ( ) ; if ( $ application :: ERROR_EXCEPTION == $ event -> getError ( ) ) { $ ex = $ event -> getParam ( 'exception' ) ; if ( 404 == $ ex -> getCode ( ) ) { $ event -> setError ( $ application :: ERROR_CONTROLLER_NOT_FOUND ) ; } } } } , 500 ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH , function ( $ event ) use ( $ eventManager ) { $ eventManager -> trigger ( 'postDispatch' , $ event ) ; } , - 150 ) ; $ sm -> get ( 'Tracy' ) -> startDebug ( ) ; }
2671	public function deleteDictionaryItem ( $ dictionaryId , $ itemKey ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/item/' . urlencode ( $ itemKey ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; }
10034	function unsubscribeContactById ( $ id , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( 'id' => $ id ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } return $ this -> delete ( "contacts/contact/unsubscribe" , $ queryParameters ) ; }
5952	public function setTransition ( $ transition ) { if ( $ transition instanceof SlideTransition ) { $ this -> transition = $ transition ; } elseif ( is_array ( $ transition ) ) { $ this -> transition = new SlideTransition ( $ transition ) ; } else { $ this -> transition = null ; trigger_error ( 'Argument must be an object of class SlideTransition. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
5485	public function hasImage ( SelectorInterface $ selector ) { foreach ( $ this -> images as $ image ) { if ( $ selector -> isMatch ( $ image ) ) { return true ; } } return false ; }
6053	public function retrieveParents ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders/' . $ id . '/parents' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderParent ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5757	private function selectArray ( ? string $ selectColumns = null , array $ whereColumnsInfo = null , string $ orderBy = null ) : array { $ columns = $ selectColumns ?? $ this -> defaultSelectColumnsString ; $ permissionsArray = [ ] ; if ( null !== $ records = $ this -> select ( $ columns , $ whereColumnsInfo , $ orderBy ) ) { $ rolesTableMapper = RolesTableMapper :: getInstance ( ) ; foreach ( $ records as $ record ) { if ( null === $ key = $ this -> getPermissionsArrayKeyForId ( $ permissionsArray , ( int ) $ record [ 'id' ] ) ) { $ permissionsArray [ ] = [ 'id' => ( int ) $ record [ 'id' ] , 'title' => $ record [ 'title' ] , 'description' => $ record [ 'description' ] , 'roles' => [ $ rolesTableMapper -> getObjectById ( ( int ) $ record [ 'role_id' ] ) ] , 'active' => Postgres :: convertPostgresBoolToBool ( $ record [ 'active' ] ) , 'created' => new \ DateTimeImmutable ( $ record [ 'created' ] ) , ] ; } else { array_push ( $ permissionsArray [ $ key ] [ 'roles' ] , $ rolesTableMapper -> getObjectById ( ( int ) $ record [ 'role_id' ] ) ) ; } } } return $ permissionsArray ; }
8129	public function actionIndex ( ) { $ profile = Profile :: findOne ( [ 'uid' => Yii :: $ app -> user -> id ] ) ; if ( $ profile == NULL ) throw new NotFoundHttpException ; return $ this -> render ( 'index' , [ 'profile' => $ profile ] ) ; }
4049	public function fetchInputScreens ( $ idList ) : array { $ idList = array_filter ( $ idList ) ; $ builder = $ this -> connection -> createQueryBuilder ( ) ; $ screens = $ builder -> select ( 'd.*' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel' , 'm' , 'm.id=d.pid' ) -> where ( $ builder -> expr ( ) -> in ( 'd.id' , ':idList' ) ) -> setParameter ( 'idList' , $ idList , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'm.sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; $ keys = array_flip ( $ idList ) ; foreach ( $ screens as $ screen ) { $ metaModelName = $ keys [ $ screen [ 'id' ] ] ; $ result [ $ metaModelName ] = $ this -> prepareInputScreen ( $ metaModelName , $ screen ) ; } return $ result ; }
8824	protected function errorMessage ( $ filter , $ field , $ params = null ) { $ text = ( isset ( $ this -> texts [ $ field ] [ $ filter ] ) && ! is_null ( $ this -> texts [ $ field ] [ $ filter ] ) ? $ this -> texts [ $ field ] [ $ filter ] : $ this -> msg ) ; $ text = str_replace ( [ ':label:' , ':value:' ] , '%s' , $ text ) ; if ( ! isset ( $ this -> data [ $ field ] ) ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } elseif ( ! is_null ( $ params ) ) { if ( $ filter == 'matches' ) { if ( $ this -> matches ( $ this -> data [ $ field ] , $ this -> data [ $ params ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] , $ params ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } }
3742	public function delete ( $ varItem ) { if ( is_object ( $ varItem ) && ( $ varItem instanceof Model ) ) { $ objModelItem = $ varItem -> getItem ( ) ; } else { $ objModelItem = $ this -> getMetaModel ( ) -> findById ( $ varItem ) ; } if ( $ objModelItem ) { $ this -> getMetaModel ( ) -> delete ( $ objModelItem ) ; } }
12654	public function getText ( $ name , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { return $ allTexts [ $ name ] ; } else { return null ; } }
3344	public function __batchProcessFiles ( $ filesUuidArr , $ request_type ) { $ filesChunkedArr = array_chunk ( $ filesUuidArr , $ this -> batchFilesChunkSize ) ; $ filesArr = array ( ) ; $ problemsArr = array ( ) ; $ lastStatus = '' ; foreach ( $ filesChunkedArr as $ chunk ) { $ res = $ this -> __batchProcessFilesChunk ( $ chunk , $ request_type ) ; $ lastStatus = $ res [ 'status' ] ; if ( $ lastStatus == "ok" ) { $ problemsObj = $ res [ 'problems' ] ; if ( count ( get_object_vars ( $ problemsObj ) ) > 0 ) { $ problemsArr [ ] = $ problemsObj ; } $ filesArr = array_merge ( $ filesArr , $ res [ 'files' ] ) ; } else { throw new \ Exception ( 'Error process multiple files' , $ res ) ; } } return array ( 'status' => $ lastStatus , 'files' => $ filesArr , 'problems' => $ problemsArr , ) ; }
5245	private function replace ( string $ pattern , string $ replacement , string $ targetFile ) { $ this -> filesystem -> put ( $ targetFile , preg_replace ( $ pattern , $ replacement , $ this -> filesystem -> get ( $ targetFile ) ) ) ; }
3718	protected function getMetaModelFromModel ( ModelInterface $ model ) { if ( ! ( ( $ model -> getProviderName ( ) == 'tl_metamodel_dca_sortgroup' ) && $ model -> getProperty ( 'pid' ) ) ) { throw new DcGeneralInvalidArgumentException ( sprintf ( 'Model must originate from tl_metamodel_dca_sortgroup and be saved, this one originates from %s ' . 'and has pid %s' , $ model -> getProviderName ( ) , $ model -> getProperty ( 'pid' ) ) ) ; } $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'pid' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchColumn ( ) ; $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; return $ this -> factory -> getMetaModel ( $ tableName ) ; }
11170	private function refreshSession ( ) { $ mapper = Neuron_GameServer_Mappers_UpdateMapper :: getInstance ( ) ; if ( ! isset ( $ _SESSION [ 'ngpu_lastlog' ] ) ) { $ _SESSION [ 'ngpu_lastlog' ] = $ mapper -> getLastLogId ( $ this -> objProfile ) ; $ _SESSION [ 'ngpu_data' ] = array ( ) ; } else { $ lastLogId = $ _SESSION [ 'ngpu_lastlog' ] ; $ updates = $ mapper -> getUpdates ( $ this -> objProfile , $ lastLogId ) ; foreach ( $ updates as $ v ) { $ _SESSION [ 'ngpu_data' ] [ $ v [ 'key' ] ] = $ v [ 'value' ] ; $ lastLogId = max ( $ v [ 'id' ] , $ lastLogId ) ; } $ _SESSION [ 'ngpu_lastlog' ] = $ lastLogId ; } }
3587	protected function getMetaWhereConstraint ( $ method , ArgumentBag $ args ) { $ column = $ args -> get ( 'column' ) ; $ args -> set ( 'column' , 'meta_value' ) ; if ( $ method === 'whereBetween' ) { return $ this -> getMetaBetweenConstraint ( $ column , $ args -> get ( 'values' ) ) ; } return function ( $ query ) use ( $ column , $ method , $ args ) { $ query -> where ( 'meta_key' , $ column ) ; if ( $ args -> get ( 'value' ) || $ args -> get ( 'values' ) ) { call_user_func_array ( [ $ query , $ method ] , $ args -> all ( ) ) ; } } ; }
4995	public function getActiveFormNext ( ) { $ key = null ; $ actualKey = $ this -> getActiveFormActual ( ) ; if ( isset ( $ actualKey ) ) { $ forms = array_keys ( $ this -> forms ) ; $ formsFlip = array_flip ( $ forms ) ; $ index = $ formsFlip [ $ actualKey ] ; if ( $ index < count ( $ forms ) - 1 ) { $ key = $ forms [ $ index + 1 ] ; } } return $ key ; }
12033	function addDispatchAsyncMethod ( ) { $ methodGenerator = new MethodGenerator ( 'dispatchAsync' ) ; $ body = 'return $this->api->executeAsync($request, $this, $callable);' ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response asynchronously. Allows you to modify the request before it is sent.' ) ; $ requestParameter = new ParameterGenerator ( 'request' , 'Amp\Artax\Request' ) ; $ methodGenerator -> setParameter ( $ requestParameter ) ; $ tag = createParamTag ( $ requestParameter , 'The request to be processed' ) ; $ docBlock -> setTag ( $ tag ) ; $ callableParameter = new ParameterGenerator ( 'callable' , 'callable' ) ; $ methodGenerator -> setParameter ( $ callableParameter ) ; $ callableTag = createParamTag ( $ callableParameter , 'The callable that processes the response' ) ; $ docBlock -> setTag ( $ callableTag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
6461	public function shouldSeeThumbnail ( ) { $ thumb = false ; foreach ( [ '.upload-preview' , '.media-thumbnail img' , '.image-preview img' ] as $ selector ) { if ( $ thumb ) { break ; } $ thumb = $ this -> findByCss ( $ selector ) ; } if ( null === $ thumb ) { throw new \ Exception ( 'An expected image tag was not found.' ) ; } $ file = explode ( '?' , $ thumb -> getAttribute ( 'src' ) ) ; $ file = reset ( $ file ) ; $ curl = new CurlService ( ) ; list ( , $ info ) = $ curl -> execute ( 'GET' , $ file ) ; if ( empty ( $ info ) || strpos ( $ info [ 'content_type' ] , 'image/' ) === false ) { throw new FileNotFoundException ( sprintf ( '%s did not return an image' , $ file ) ) ; } }
8844	private function log ( string $ message , array $ context = [ ] ) : void { $ this -> logger -> log ( $ this -> logLevel , $ message , $ context ) ; }
5172	public function setEncoder ( callable $ encoder ) : Yaml { if ( ! is_callable ( $ encoder ) ) { throw new \ InvalidArgumentException ( 'The provided encoder must be callable.' ) ; } $ this -> encoder = $ encoder ; return $ this ; }
11828	public function setUri ( $ uri ) { if ( ! empty ( $ uri ) && ! is_file ( $ uri ) ) { throw new \ Exception ( sprintf ( 'File %s not found.' , $ uri ) ) ; } $ this -> uri = $ uri ; return $ this ; }
6918	public function hasAdjustments ( $ type = null ) { if ( null !== $ type ) { AdjustmentTypes :: isValidType ( $ type ) ; return $ this -> getAdjustments ( $ type ) -> count ( ) ; } return 0 < $ this -> adjustments -> count ( ) ; }
12498	public static function insertOne ( $ document , $ connection ) { $ connection -> query = self :: singleDocument ( $ document ) ; return self :: insert ( $ connection ) ; }
4074	protected function resolve ( ) { $ factory = $ this -> container -> getFactory ( ) ; $ names = $ factory -> collectNames ( ) ; foreach ( $ names as $ name ) { $ this -> information [ $ name ] = array ( self :: COMBINATION => null , self :: INPUTSCREEN => null , self :: RENDERSETTING => null , self :: MODELID => null , ) ; } $ found = $ this -> getPaletteCombinationRows ( ) ; if ( ! $ found ) { $ found = array ( ) ; } foreach ( array_keys ( $ this -> information ) as $ tableName ) { if ( empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] ) || empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] [ 'dca_id' ] ) || empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] [ 'view_id' ] ) ) { unset ( $ this -> information [ $ tableName ] ) ; } } $ this -> fetchInputScreenDetails ( ) ; }
4118	public static function getType ( $ name ) { if ( ! isset ( self :: $ _typeObjects [ $ name ] ) ) { if ( ! isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: unknownType ( $ name ) ; } self :: $ _typeObjects [ $ name ] = new self :: $ _typesMap [ $ name ] ( ) ; } return self :: $ _typeObjects [ $ name ] ; }
11047	function get_value ( $ parent , $ varname ) { if ( isset ( $ parent -> $ varname ) ) { return $ parent -> $ varname ; } else { $ elements = explode ( '[' , $ varname ) ; if ( count ( $ elements ) == 1 ) { return NULL ; } else { $ vartest = $ parent ; foreach ( $ elements as $ elementid => $ element ) { if ( $ elementid == 0 ) { $ vartest = $ parent -> $ element ; if ( ! isset ( $ vartest ) ) { return NULL ; } } else { $ index = substr ( $ element , 0 , - 1 ) ; if ( $ index == '_first' ) { $ keys = array_keys ( $ vartest ) ; $ index = $ keys [ 0 ] ; } elseif ( $ index == '_last' ) { $ keys = array_keys ( $ vartest ) ; $ index = $ keys [ count ( $ keys ) - 2 ] ; } if ( ! isset ( $ vartest [ $ index ] ) ) { return NULL ; } else { $ vartest = $ vartest [ $ index ] ; } } } } return $ vartest ; } }
11072	public function setFloat ( string $ key , $ value , float $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( float ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
2498	private function getLanguageFilter ( array $ languageCodes ) { $ languageFilters = array ( ) ; foreach ( $ languageCodes as $ languageCode ) { $ condition = new CustomField ( self :: FIELD_LANGUAGE , Operator :: EQ , $ languageCode ) ; $ excluded = $ this -> getExcludedLanguageCodes ( $ languageCodes , $ languageCode ) ; if ( ! empty ( $ excluded ) ) { $ condition = new LogicalAnd ( array ( $ condition , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ excluded ) ) , ) ) ; } $ languageFilters [ ] = $ condition ; } if ( count ( $ languageFilters ) > 1 ) { $ languageFilters = array ( new LogicalOr ( $ languageFilters ) ) ; } if ( $ this -> hasMainLanguagesEndpoint ) { $ languageFilters [ ] = new LogicalNot ( new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ) ; } if ( count ( $ languageFilters ) > 1 ) { return new LogicalAnd ( $ languageFilters ) ; } return reset ( $ languageFilters ) ; }
8601	private function _convertDeleteSubscription ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'DeleteSubscription' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetNotificationType ( ) ) { $ parameters [ 'NotificationType' ] = $ request -> getNotificationType ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationDeleteSubscriptionInput = $ request -> getDestination ( ) ; foreach ( $ DestinationDeleteSubscriptionInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
11450	public function getParentUri ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; if ( ! is_string ( $ func ) ) { return ; } $ relat = $ this -> $ func ( ) ; $ parentResourceName = $ relat -> getRelated ( ) -> getResourceName ( ) ; $ field = $ relat -> getForeignKey ( ) ; if ( ! $ this -> $ field ) { return Api :: url ( ) ; } return Api :: url ( ) . '/' . $ parentResourceName . '/' . Api :: encodeHashId ( $ this -> $ field ) ; } return Api :: url ( ) ; }
3558	public function setValue ( $ value ) { $ this -> setType ( $ value ) ; if ( $ this -> hasMutator ( $ value , 'setter' ) ) { $ value = $ this -> mutateValue ( $ value , 'setter' ) ; } elseif ( ! $ this -> isStringable ( $ value ) && ! is_null ( $ value ) ) { throw new InvalidTypeException ( "Unsupported meta value type [{$this->getValueType($value)}]." ) ; } $ this -> attributes [ 'meta_value' ] = $ value ; }
11390	public function getStatus ( ) { if ( isset ( $ this -> _log ) ) { $ this -> _status = $ this -> log -> statusLog ; } elseif ( ! isset ( $ this -> _status ) ) { $ this -> _status = new Status ( $ this -> log ) ; } return $ this -> _status ; }
6161	public function addPropertyRequest ( $ item ) { if ( ! ( $ item instanceof PropertyRequest ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertyRequest ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertyRequest. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertyRequest"!' , E_USER_WARNING ) ; } } $ this -> properties [ ] = $ item ; return $ this ; }
10314	function getClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ linkIdFilter = null , $ linkUrlFilter = null , $ linkTagFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_id" , $ linkIdFilter ) ; if ( isset ( $ linkUrlFilter ) ) $ params [ 'link_url' ] = $ linkUrlFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_tag" , $ linkTagFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/clicks/count' , $ params ) ; }
7296	private function get_mail_to_chunk ( $ to , $ send_next_group = array ( ) ) { $ object_id = $ this -> options [ 'static_options' ] [ 'object' ] [ 'id' ] ; $ object_type = $ this -> options [ 'static_options' ] [ 'object' ] [ 'type' ] ; if ( empty ( $ send_next_group ) ) { $ chunk_size = $ this -> options [ 'static_options' ] [ 'mail_to_chunking' ] [ 'chunksize' ] ; $ send_next_group = array_chunk ( $ to , $ chunk_size ) ; } $ to = apply_filters ( 'iac_email_address_chunk' , array_shift ( $ send_next_group ) , $ object_id , $ object_type ) ; $ to = implode ( ',' , $ to ) ; if ( ! empty ( $ send_next_group ) ) { wp_schedule_single_event ( time ( ) + $ this -> options [ 'static_options' ] [ 'schedule_interval' ] , 'iac_schedule_send_chunks' , array ( $ object_id , $ object_type , $ send_next_group ) ) ; } return $ to ; }
5866	protected function getIndexer ( \ TYPO3 \ CMS \ Core \ Resource \ ResourceStorage $ storage ) { return GeneralUtility :: makeInstance ( Indexer :: class , $ storage ) ; }
7821	public function update ( $ pipeline , array $ attachments , array $ detachments ) { $ this -> detach ( $ this -> pipelines [ $ pipeline ] , $ detachments ) ; $ this -> attach ( $ this -> pipelines [ $ pipeline ] , $ attachments ) ; $ this -> refreshPipelines ( ) ; }
2608	public function getCurrentVersion ( array $ versions ) { if ( ! empty ( $ versions ) ) { foreach ( $ versions as $ version ) { if ( $ version -> active ) { return $ activeVersion = $ version -> number ; } } } throw new LocalizedException ( __ ( 'Error fetching current version.' ) ) ; }
4235	private static function trimDesc ( $ desc ) { $ lines = \ explode ( "\n" , $ desc ) ; $ leadingSpaces = array ( ) ; foreach ( $ lines as $ line ) { if ( \ strlen ( $ line ) ) { $ leadingSpaces [ ] = \ strspn ( $ line , ' ' ) ; } } \ array_shift ( $ leadingSpaces ) ; $ trimLen = $ leadingSpaces ? \ min ( $ leadingSpaces ) : 0 ; if ( ! $ trimLen ) { return $ desc ; } foreach ( $ lines as $ i => $ line ) { $ lines [ $ i ] = $ i > 0 && \ strlen ( $ line ) ? \ substr ( $ line , $ trimLen ) : $ line ; } $ desc = \ implode ( "\n" , $ lines ) ; return $ desc ; }
5147	protected function getOpenedEmail ( $ fetchNextUnread = FALSE ) { if ( $ fetchNextUnread || $ this -> openedEmail == NULL ) { $ this -> openNextUnreadEmail ( ) ; } return $ this -> openedEmail ; }
2337	private function setLegacyOptions ( Table $ table ) : void { if ( ! $ table -> hasOption ( 'engine' ) ) { $ table -> addOption ( 'engine' , 'MyISAM' ) ; } if ( ! $ table -> hasOption ( 'charset' ) ) { $ table -> addOption ( 'charset' , 'utf8' ) ; } if ( ! $ table -> hasOption ( 'collate' ) ) { $ table -> addOption ( 'collate' , 'utf8_general_ci' ) ; } }
3273	public function get ( string $ key ) { Validation :: validateKey ( $ key ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { if ( $ cache -> contains ( $ key ) ) { return $ cache -> get ( $ key ) ; } } $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; $ data = false ; foreach ( $ file as $ line ) { if ( $ line -> getKey ( ) == $ key ) { $ data = $ this -> decodeData ( $ line -> getData ( ) ) ; break ; } } if ( $ cache && $ data !== false ) { $ cache -> set ( $ key , $ data ) ; } return $ data ; }
7209	public static function createFinalFromGross ( Amount $ gross ) : Amount { $ final = new Amount ( $ gross -> getCurrency ( ) , $ gross -> getBase ( ) , $ gross -> getBase ( ) , 0 , $ gross -> getBase ( ) , $ gross -> getTax ( ) , $ gross -> getTotal ( ) ) ; foreach ( $ gross -> getTaxAdjustments ( ) as $ t ) { $ final -> addTaxAdjustment ( $ t ) ; } return $ final ; }
9011	public function tinytext ( string $ charset = null ) : self { $ this -> type = 'tinytext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
1821	protected function getQuicknavPages ( $ pid , $ level = 1 , $ host = null ) { global $ objPage ; $ groups = array ( ) ; $ arrPages = array ( ) ; if ( FE_USER_LOGGED_IN ) { $ this -> import ( FrontendUser :: class , 'User' ) ; $ groups = $ this -> User -> groups ; } $ objSubpages = PageModel :: findPublishedRegularWithoutGuestsByPid ( $ pid ) ; if ( $ objSubpages === null ) { return array ( ) ; } ++ $ level ; foreach ( $ objSubpages as $ objSubpage ) { $ _groups = StringUtil :: deserialize ( $ objSubpage -> groups ) ; if ( $ host !== null ) { $ objSubpage -> domain = $ host ; } if ( ! $ objSubpage -> protected || $ this -> showProtected || ( \ is_array ( $ _groups ) && \ is_array ( $ groups ) && array_intersect ( $ _groups , $ groups ) ) ) { if ( ! $ objSubpage -> hide || $ this -> showHidden ) { $ arrPages [ ] = array ( 'level' => ( $ level - 2 ) , 'title' => StringUtil :: specialchars ( StringUtil :: stripInsertTags ( $ objSubpage -> pageTitle ? : $ objSubpage -> title ) ) , 'href' => $ objSubpage -> getFrontendUrl ( ) , 'link' => StringUtil :: stripInsertTags ( $ objSubpage -> title ) , 'active' => ( $ objPage -> id == $ objSubpage -> id || ( $ objSubpage -> type == 'forward' && $ objPage -> id == $ objSubpage -> jumpTo ) ) ) ; if ( ! $ this -> showLevel || $ this -> showLevel >= $ level || ( ! $ this -> hardLimit && ( $ objPage -> id == $ objSubpage -> id || \ in_array ( $ objPage -> id , $ this -> Database -> getChildRecords ( $ objSubpage -> id , 'tl_page' ) ) ) ) ) { $ subpages = $ this -> getQuicknavPages ( $ objSubpage -> id , $ level ) ; if ( \ is_array ( $ subpages ) ) { $ arrPages = array_merge ( $ arrPages , $ subpages ) ; } } } } } return $ arrPages ; }
5805	public function increment ( ) { $ this -> counter ++ ; if ( 1 === $ this -> counter ) { $ this -> expiresAt = $ this -> now ( ) + $ this -> expiresIn ; } }
12736	public function mapModelToLangName ( $ modelName , $ langName ) { $ modelName = $ this -> getClassName ( $ modelName ) ; $ this -> modelToLangName [ $ modelName ] = $ langName ; }
10018	public function removeNamedRange ( $ namedRange , Worksheet $ pSheet = null ) { if ( $ pSheet === null ) { if ( isset ( $ this -> namedRanges [ $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ namedRange ] ) ; } } else { if ( isset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ; } } return $ this ; }
5974	public function filters ( ) { if ( ! $ this -> filters instanceof FiltersController ) { $ this -> filters = new FiltersController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> filters -> setLogger ( $ this -> logger ) ; } return $ this -> filters ; }
8195	protected function checkConstantExpression ( Twig_NodeInterface $ node ) { if ( ! ( $ node instanceof Twig_Node_Expression_Constant || $ node instanceof Twig_Node_Expression_Array || $ node instanceof Twig_Node_Expression_Unary_Neg || $ node instanceof Twig_Node_Expression_Unary_Pos ) ) { return false ; } foreach ( $ node as $ n ) { if ( ! $ this -> checkConstantExpression ( $ n ) ) { return false ; } } return true ; }
11371	public function destroy ( $ menuId = null ) { if ( $ menuId !== null ) { return $ this -> parseJSON ( 'json' , [ self :: API_CONDITIONAL_DELETE , [ 'menuid' => $ menuId ] ] ) ; } return $ this -> parseJSON ( 'get' , [ self :: API_DELETE ] ) ; }
8070	private function getDomainControllerStrategy ( array $ domain_controller ) { $ protocol = $ this -> ssl ? $ this :: PROTOCOL_SSL : $ this :: PROTOCOL ; if ( count ( $ domain_controller ) === 1 ) { return new SingleDomainController ( $ protocol , $ domain_controller ) ; } if ( $ this -> backup === true ) { return new RebindDomainController ( $ protocol , $ domain_controller ) ; } else { return new LoadBalancingDomainController ( $ protocol , $ domain_controller ) ; } }
97	private function selectRestVersion ( $ channelXml , $ supportedVersions ) { $ channelXml -> registerXPathNamespace ( 'ns' , self :: CHANNEL_NS ) ; foreach ( $ supportedVersions as $ version ) { $ xpathTest = "ns:servers/ns:*/ns:rest/ns:baseurl[@type='{$version}']" ; $ testResult = $ channelXml -> xpath ( $ xpathTest ) ; foreach ( $ testResult as $ result ) { $ result = ( string ) $ result ; if ( preg_match ( '{^https://}i' , $ result ) ) { return array ( 'version' => $ version , 'baseUrl' => $ result ) ; } } if ( count ( $ testResult ) > 0 ) { return array ( 'version' => $ version , 'baseUrl' => ( string ) $ testResult [ 0 ] ) ; } } return null ; }
3744	protected function getMetaModel ( ) { if ( ! $ this -> metaModel ) { if ( $ this -> metaModel === null ) { throw new \ RuntimeException ( 'No MetaModel instance set for ' . $ this -> strTable ) ; } } return $ this -> metaModel ; }
9967	public function getHyperlink ( $ pCellCoordinate ) { if ( isset ( $ this -> hyperlinkCollection [ $ pCellCoordinate ] ) ) { return $ this -> hyperlinkCollection [ $ pCellCoordinate ] ; } $ this -> hyperlinkCollection [ $ pCellCoordinate ] = new Hyperlink ( ) ; return $ this -> hyperlinkCollection [ $ pCellCoordinate ] ; }
12301	public function getChilds ( $ id , $ relation , $ filters = null ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } if ( count ( $ filters -> request -> all ( ) ) > 0 ) { $ child = $ parent -> $ relation ( ) -> getRelated ( ) ; $ search = new Search ( $ child , $ filters , $ parent -> $ relation ( ) ) ; $ this -> builder = $ search -> getBuilder ( ) ; $ this -> builder -> select ( "{$child->getTable()}.*" ) ; return $ this -> builder -> get ( ) ; } $ resource = $ parent -> $ relation ; return $ resource ; }
771	public function actionConfig ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; $ dir = dirname ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } $ array = VarDumper :: export ( $ this -> getOptionValues ( $ this -> action -> id ) ) ; $ content = <<<EOD<?php/** * Configuration file for 'yii {$this->id}/{$this->defaultAction}' command. * * This file is automatically generated by 'yii {$this->id}/{$this->action->id}' command. * It contains parameters for source code messages extraction. * You may modify this file to suit your needs. * * You can use 'yii {$this->id}/{$this->action->id}-template' command to create * template configuration file with detailed description for each parameter. */return $array;EOD ; if ( FileHelper :: createDirectory ( $ dir ) === false || file_put_contents ( $ filePath , $ content , LOCK_EX ) === false ) { $ this -> stdout ( "Configuration file was NOT created: '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file created: '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; }
11208	protected function getValue ( $ data , $ key = false ) { $ returnValue = $ data ; if ( $ key && is_object ( $ data ) ) { $ returnValue = $ data -> $ key ; } else if ( $ key && is_array ( $ data ) ) { $ returnValue = $ data [ $ key ] ; } return $ returnValue ; }
10356	public function lockOut ( ) { $ this -> resetAttempts ( ) ; $ this -> cache -> add ( $ this -> lockOutKey , $ this -> getDelay ( ) + time ( ) , $ this -> getExpiry ( ) ) ; }
3872	protected function getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage = null ) { $ entries = array ( ) ; $ items = $ metaModels -> findByFilter ( $ filter ) ; foreach ( $ items as $ item ) { $ jumpTo = $ item -> buildJumpToLink ( $ view ) ; $ event = new GetPageDetailsEvent ( $ jumpTo [ 'page' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null || ( $ rootPage !== null && $ pageDetails [ 'rootId' ] != $ rootPage ) ) { continue ; } $ url = $ this -> getBaseUrl ( $ pageDetails , $ jumpTo [ 'url' ] ) ; $ entries [ ] = $ url -> getUrl ( ) ; } return $ entries ; }
9790	public function getFormattedValue ( ) { return ( string ) NumberFormat :: toFormattedString ( $ this -> getCalculatedValue ( ) , $ this -> getStyle ( ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; }
11563	public function LineBreaks ( $ text , $ lang = "" ) { $ this -> text = $ text ; $ word = "" ; $ lang = $ lang ? $ lang : $ this -> lang ; list ( $ weekWords , $ units , $ shortcuts ) = $ this -> getWeekWordsUnitsAndShortcuts ( $ lang ) ; $ this -> text = preg_replace ( "#\t+#mu" , " " , $ this -> text ) ; $ this -> text = preg_replace ( "#[ ]{2,}#mu" , " " , $ this -> text ) ; for ( $ i = 0 , $ l = count ( $ weekWords ) ; $ i < $ l ; $ i += 1 ) { $ word = $ weekWords [ $ i ] ; $ this -> processWeakWord ( $ word ) ; $ word = mb_strtoupper ( mb_substr ( $ word , 0 , 1 ) ) . mb_substr ( $ word , 1 ) ; $ this -> processWeakWord ( $ word ) ; } for ( $ i = 0 , $ l = count ( $ units ) ; $ i < $ l ; $ i += 1 ) { $ word = $ units [ $ i ] ; $ regExp = "#([0-9])\\s(" . $ word . ")#mu" ; $ this -> text = preg_replace ( $ regExp , "$1&nbsp;$2" , $ this -> text ) ; } foreach ( $ shortcuts as $ sourceShortcut => $ targetShortcut ) { $ this -> text = str_replace ( $ sourceShortcut , $ targetShortcut , $ this -> text ) ; } $ this -> text = preg_replace ( "#([0-9])\s([0-9])#" , "$1&nbsp;$2" , $ this -> text ) ; return $ this -> text ; }
10099	private function writeString ( $ row , $ col , $ str , $ xfIndex ) { $ this -> writeLabelSst ( $ row , $ col , $ str , $ xfIndex ) ; }
1686	public function updateCurrentUser ( Contao \ DataContainer $ dc ) { if ( $ this -> User -> id == $ dc -> id ) { $ this -> User -> findBy ( 'id' , $ this -> User -> id ) ; } }
2998	public function setReply ( $ email , $ title = null ) { $ this -> set ( 'Reply-To' , $ this -> buildMail ( $ email , $ title ) ) ; }
11487	protected function callResolvingCallbacks ( $ key , $ object ) { foreach ( $ this -> resolvingAnyCallbacks as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } if ( isset ( $ this -> resolvingCallbacks [ $ key ] ) ) { foreach ( $ this -> resolvingCallbacks [ $ key ] as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } } }
10732	public function getSecond ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'second' ] ; } }
1059	public static function findValuesRemovedFromEnums ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ valuesRemovedFromEnums = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof EnumType ) || ! ( $ newType instanceof EnumType ) ) { continue ; } $ valuesInNewEnum = [ ] ; foreach ( $ newType -> getValues ( ) as $ value ) { $ valuesInNewEnum [ $ value -> name ] = true ; } foreach ( $ oldType -> getValues ( ) as $ value ) { if ( isset ( $ valuesInNewEnum [ $ value -> name ] ) ) { continue ; } $ valuesRemovedFromEnums [ ] = [ 'type' => self :: BREAKING_CHANGE_VALUE_REMOVED_FROM_ENUM , 'description' => sprintf ( '%s was removed from enum type %s.' , $ value -> name , $ typeName ) , ] ; } } return $ valuesRemovedFromEnums ; }
11579	private function config ( ) { $ handler = new RotatingFileHandler ( $ this -> getFullPath ( ) , 0 , MonoLogger :: INFO ) ; $ handler -> setFormatter ( $ this -> getLineFormater ( ) ) ; $ this -> logger -> pushHandler ( $ handler ) ; $ this -> logger -> pushProcessor ( new WebProcessor ( ) ) ; $ this -> logger -> pushProcessor ( new MemoryUsageProcessor ( ) ) ; }
803	private function hasVoidReturnAnnotation ( Tokens $ tokens , $ index ) { foreach ( $ this -> findReturnAnnotations ( $ tokens , $ index ) as $ return ) { if ( [ 'void' ] === $ return -> getTypes ( ) ) { return true ; } } return false ; }
3683	private function getFilterUrlBuilder ( ) : FilterUrlBuilder { if ( null === $ this -> filterUrlBuilder ) { return $ this -> filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; } return $ this -> filterUrlBuilder ; }
6109	public function permAssign ( $ permid , $ permvalue ) { return $ this -> getParent ( ) -> channelPermAssign ( $ this -> getId ( ) , $ permid , $ permvalue ) ; }
9483	public function toArray ( $ changedOnly = false , $ extraData = null ) { $ vars = get_object_vars ( $ this ) ; $ object = array ( ) ; if ( ! is_array ( $ this -> _changes ) ) { $ this -> _changes = array ( ) ; } if ( is_array ( $ extraData ) ) { $ vars = array_merge ( $ vars , $ extraData ) ; } foreach ( $ vars as $ k => $ v ) { if ( strpos ( $ k , '_' ) !== 0 && $ v !== null && ( ! $ changedOnly || array_key_exists ( $ k , $ this -> _changes ) || array_key_exists ( $ k , $ extraData ) ) ) { if ( is_array ( $ v ) ) { $ subV = array ( ) ; foreach ( $ v as $ sub ) { if ( is_a ( $ sub , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ subV [ ] = $ sub -> toArray ( ) ; } else { $ subV [ ] = $ sub ; } } $ object [ $ k ] = $ subV ; } else if ( is_a ( $ v , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ object [ $ k ] = $ v -> toArray ( ) ; } else { $ object [ $ k ] = $ v ; } } } return $ object ; }
1024	private function getOperationRootType ( Schema $ schema , OperationDefinitionNode $ operation ) { switch ( $ operation -> operation ) { case 'query' : $ queryType = $ schema -> getQueryType ( ) ; if ( ! $ queryType ) { throw new Error ( 'Schema does not define the required query root type.' , [ $ operation ] ) ; } return $ queryType ; case 'mutation' : $ mutationType = $ schema -> getMutationType ( ) ; if ( ! $ mutationType ) { throw new Error ( 'Schema is not configured for mutations.' , [ $ operation ] ) ; } return $ mutationType ; case 'subscription' : $ subscriptionType = $ schema -> getSubscriptionType ( ) ; if ( ! $ subscriptionType ) { throw new Error ( 'Schema is not configured for subscriptions.' , [ $ operation ] ) ; } return $ subscriptionType ; default : throw new Error ( 'Can only execute queries, mutations and subscriptions.' , [ $ operation ] ) ; } }
5444	protected function reduce ( $ raw ) { if ( $ action = $ this -> regexes [ $ this -> mode -> getCurrent ( ) ] -> match ( $ raw , $ match ) ) { $ unparsed_character_count = strpos ( $ raw , $ match ) ; $ unparsed = substr ( $ raw , 0 , $ unparsed_character_count ) ; $ raw = substr ( $ raw , $ unparsed_character_count + strlen ( $ match ) ) ; return array ( $ raw , $ unparsed , $ match , $ action ) ; } return true ; }
9906	public static function map ( $ color , $ palette , $ version ) { if ( $ color <= 0x07 || $ color >= 0x40 ) { return Color \ BuiltIn :: lookup ( $ color ) ; } elseif ( isset ( $ palette , $ palette [ $ color - 8 ] ) ) { return $ palette [ $ color - 8 ] ; } if ( $ version == Xls :: XLS_BIFF8 ) { return Color \ BIFF8 :: lookup ( $ color ) ; } return Color \ BIFF5 :: lookup ( $ color ) ; }
471	public function down ( ) { $ transaction = $ this -> db -> beginTransaction ( ) ; try { if ( $ this -> safeDown ( ) === false ) { $ transaction -> rollBack ( ) ; return false ; } $ transaction -> commit ( ) ; } catch ( \ Exception $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } catch ( \ Throwable $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } return null ; }
7062	protected function updateCustomerBalance ( PaymentInterface $ payment , $ amount = null ) { if ( null === $ customer = $ payment -> getSale ( ) -> getCustomer ( ) ) { return false ; } $ amount = $ amount ? : $ payment -> getAmount ( ) ; if ( $ this -> isAcceptedPayment ( $ payment ) ) { $ amount = - $ amount ; } if ( $ payment -> getMethod ( ) -> isCredit ( ) ) { return $ this -> updateCreditBalance ( $ customer , $ amount , true ) ; } elseif ( $ payment -> getMethod ( ) -> isOutstanding ( ) ) { return $ this -> updateOutstandingBalance ( $ customer , $ amount , true ) ; } return false ; }
2834	public function startRendering ( Mage_Core_Block_Abstract $ block ) { if ( $ this -> isRendering ) { $ this -> renderedCount ++ ; Mage :: log ( "Recursive block rendering {$this->getName()}" , Zend_Log :: DEBUG ) ; return ; } $ this -> init ( $ block ) ; $ this -> isRendering = true ; $ this -> renderedCount ++ ; $ this -> renderedAt = microtime ( true ) ; if ( self :: $ startRenderingTime === null ) { self :: $ startRenderingTime = $ this -> renderedAt ; } }
66	public function isSymlinkedDirectory ( $ directory ) { if ( ! is_dir ( $ directory ) ) { return false ; } $ resolved = $ this -> resolveSymlinkedDirectorySymlink ( $ directory ) ; return is_link ( $ resolved ) ; }
4857	public function getParams ( $ namespace , $ defaults , $ params = null ) { $ session = new Container ( $ namespace ) ; $ sessionParams = $ session -> params ? : array ( ) ; $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; if ( $ params -> get ( 'clear' ) ) { $ sessionParams = array ( ) ; unset ( $ params [ 'clear' ] ) ; } $ changed = false ; foreach ( $ defaults as $ key => $ default ) { if ( is_numeric ( $ key ) ) { $ key = $ default ; $ default = null ; } $ value = $ params -> get ( $ key ) ; if ( null === $ value ) { if ( isset ( $ sessionParams [ $ key ] ) ) { $ params -> set ( $ key , $ sessionParams [ $ key ] ) ; } elseif ( null !== $ default ) { $ params -> set ( $ key , $ default ) ; $ sessionParams [ $ key ] = $ default ; $ changed = true ; } } else { if ( ! isset ( $ sessionParams [ $ key ] ) || $ sessionParams [ $ key ] != $ value ) { $ changed = true ; $ sessionParams [ $ key ] = $ value ; } } } if ( $ changed ) { unset ( $ session -> list ) ; $ session -> params = $ sessionParams ; } return $ params ; }
12170	public function createTables ( Database $ database ) { $ this -> database = $ database ; $ this -> database -> startTransaction ( ) ; $ this -> createAuthorityTable ( ) ; $ this -> createAuthorityPermissionsTable ( ) ; $ this -> createMenutable ( ) ; $ this -> createMenuGroupTable ( ) ; $ this -> createOptionsTable ( ) ; $ this -> createSessionTable ( ) ; $ this -> createTaxonomyTable ( ) ; $ this -> createObjectsTable ( ) ; $ this -> createGroupsTable ( ) ; $ this -> createObjectsAuthorityTable ( ) ; $ this -> createObjectsGroupTable ( ) ; $ this -> createObjectsEdgesTable ( ) ; $ this -> createPropertiesTable ( ) ; $ this -> createPropertyDatatypeTable ( ) ; $ this -> createPropertyValuesTable ( ) ; $ this -> createIndices ( ) ; $ this -> insertPropertyDatatypes ( ) ; $ this -> createObjectsRatingTable ( ) ; $ this -> createPropertyValuesProxyTable ( "attachment" ) ; $ this -> createPropertyValuesProxyTable ( "media" ) ; $ this -> createPropertyValuesProxyTable ( "user" ) ; $ this -> createPropertyValuesProxyTable ( "page" ) ; if ( ! $ this -> database -> commitTransaction ( ) ) { return false ; } return true ; }
519	private function findMigrationPath ( $ namespace ) { if ( empty ( $ namespace ) ) { return is_array ( $ this -> migrationPath ) ? reset ( $ this -> migrationPath ) : $ this -> migrationPath ; } if ( ! in_array ( $ namespace , $ this -> migrationNamespaces , true ) ) { throw new Exception ( "Namespace '{$namespace}' not found in `migrationNamespaces`" ) ; } return $ this -> getNamespacePath ( $ namespace ) ; }
11260	public static function snake2pascal ( string $ snake ) : string { $ nameParts = explode ( "_" , $ snake ) ; $ nameParts = array_map ( "ucfirst" , $ nameParts ) ; return implode ( "" , $ nameParts ) ; }
3032	public function getSessionState ( AssessmentTestSession $ session ) { $ deliveryExecution = $ this -> getDeliveryExecution ( $ session ) ; return $ deliveryExecution -> getState ( ) -> getUri ( ) ; }
4426	protected function askForData ( $ optionIdentifier , $ optionName , $ defaultValue , $ validator = null ) { $ optionValue = $ this -> input -> getOption ( $ optionIdentifier ) ; $ optionValue = ! empty ( $ optionValue ) ? $ optionValue : $ defaultValue ; $ question = $ this -> getQuestion ( $ optionName , $ optionValue , $ validator ) ; $ optionValue = $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ question ) ; $ this -> input -> setOption ( $ optionIdentifier , $ optionValue ) ; return $ optionValue ; }
7331	private function configureStockSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Stock \ StockSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> stockClassCache ) ) { return ; } $ this -> addMappings ( $ metadata , $ this -> getStockSubjectMappings ( ) ) ; $ this -> stockClassCache [ ] = $ class ; }
3322	public function anyOfOptions ( OptionCollection $ options ) { $ name = $ this -> getOptionName ( ) ; $ keys = $ options -> keys ( ) ; return in_array ( $ name , $ keys ) ; }
9918	public function getTableName ( Model $ model , ModelConfig $ config = null ) { if ( empty ( $ this -> models ) ) { throw new \ LogicException ( 'AujaConfigurator not configured yet! Call configure first.' ) ; } if ( ! isset ( $ this -> configs [ $ model -> getName ( ) ] ) ) { throw new \ LogicException ( sprintf ( 'AujaConfigurator not configured for model %s' , $ model -> getName ( ) ) ) ; } $ result = null ; if ( $ config != null && $ config -> getTableName ( ) != null ) { $ result = $ config -> getTableName ( ) ; } else { $ modelConfig = $ this -> configs [ $ model -> getName ( ) ] ; $ result = $ modelConfig -> getTableName ( ) ; } return $ result ; }
7946	public function getLineProperties ( $ id , $ line ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ line ) throw new BadMethodCallException ( 'Missing parameter $line.' ) ; try { $ r = $ this -> get ( 'xdsl/' . $ id . '/lines/' . $ line ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
3575	public function forget ( $ key ) { if ( $ attribute = $ this -> get ( $ key ) ) { $ attribute -> setValue ( null ) ; } return $ this ; }
4753	private function getContactFormMethod ( ) { $ method = self :: CONTACT_FORM_METHOD_DEFAULT ; if ( $ configMethod = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'OeGdprOptinContactFormMethod' ) ) { $ method = $ configMethod ; } return $ method ; }
9744	public function setState ( $ state ) { if ( ! $ state ) { return $ this ; } if ( ! ( $ state instanceof State ) ) { $ state = new State ( $ state ) ; } if ( $ state -> isEmpty ( ) ) { $ this -> invalidArguments ( '10002' ) ; } return $ this -> setParameter ( 'state' , $ state ) ; }
5022	protected function copyArrayValues ( array $ source , array $ keys ) { $ target = [ ] ; foreach ( $ keys as $ key => $ spec ) { if ( is_int ( $ key ) ) { $ key = $ spec ; $ spec = null ; } if ( ! array_key_exists ( $ key , $ source ) ) { continue ; } if ( null === $ spec ) { $ target [ $ key ] = $ source [ $ key ] ; continue ; } if ( is_string ( $ spec ) ) { $ target [ $ spec ] [ $ key ] = $ source [ $ key ] ; continue ; } if ( isset ( $ spec [ 'if' ] ) && $ source [ $ key ] !== $ spec [ 'if' ] ) { continue ; } if ( isset ( $ spec [ 'key' ] ) ) { $ targetKeys = is_array ( $ spec [ 'key' ] ) ? $ spec [ 'key' ] : [ $ spec [ 'key' ] ] ; $ value = isset ( $ spec [ 'value' ] ) ? $ spec [ 'value' ] : $ source [ $ key ] ; } else { $ targetKeys = $ spec ; $ value = $ source [ $ key ] ; } $ tmpTarget = & $ target ; foreach ( $ targetKeys as $ targetKey ) { if ( '*' == $ targetKey ) { $ targetKey = $ key ; } if ( ! isset ( $ tmpTarget [ $ targetKey ] ) ) { $ tmpTarget [ $ targetKey ] = [ ] ; } $ tmpTarget = & $ tmpTarget [ $ targetKey ] ; } $ tmpTarget = $ value ; } return $ target ; }
12388	public function logout ( AdapterChainEvent $ e ) { $ session = new Container ( $ this -> getStorage ( ) -> getNameSpace ( ) ) ; $ session -> getManager ( ) -> forgetMe ( ) ; $ session -> getManager ( ) -> destroy ( ) ; }
8241	protected function getDirFiles ( $ searchDir ) { $ files = @ scandir ( $ searchDir , SCANDIR_SORT_NONE ) ; if ( $ files === false ) { throw new \ RuntimeException ( "Cannot list directory contents: {$searchDir}." ) ; } return array_diff ( $ files , array ( '..' , '.' ) ) ; }
11384	protected function resolve ( ) { if ( $ this -> resolved ) { return ; } $ this -> resolved = [ ] ; foreach ( $ this -> stages as $ stage ) { $ this -> resolved [ ] = $ this -> build ( $ stage ) ; } }
11402	public function getAppCode ( $ path , $ width = 430 , $ autoColor = false , $ lineColor = [ 'r' => 0 , 'g' => 0 , 'b' => 0 ] ) { $ params = [ 'path' => $ path , 'width' => $ width , 'auto_color' => $ autoColor , 'line_color' => $ lineColor , ] ; return $ this -> getStream ( self :: API_GET_WXACODE , $ params ) ; }
9760	function containOnly ( string $ type ) : self { return $ this -> expect ( $ this -> target , containsOnly ( $ type ) ) ; }
1462	protected function getColumnValue ( $ id ) { $ value = $ this -> getQuery ( ) -> where ( $ this -> key , $ id ) -> value ( $ this -> column ) ; if ( is_null ( $ value ) ) { throw new \ OutOfRangeException ( "Cursor key {$id} does not exist or has a null value." ) ; } return $ value ; }
341	public static function validate ( $ model , $ attributes = null ) { $ result = [ ] ; if ( $ attributes instanceof Model ) { $ models = func_get_args ( ) ; $ attributes = null ; } else { $ models = [ $ model ] ; } foreach ( $ models as $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , $ attribute ) ] = $ errors ; } } return $ result ; }
9095	public function validate ( ) { hypePrototyper ( ) -> prototype -> saveStickyValues ( $ this -> action ) ; $ valid = true ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } $ validation = $ field -> validate ( $ this -> entity ) ; hypePrototyper ( ) -> prototype -> setFieldValidationStatus ( $ this -> action , $ field -> getShortname ( ) , $ validation ) ; if ( ! $ validation -> isValid ( ) ) { $ valid = false ; } } if ( ! $ valid ) { throw new \ hypeJunction \ Exceptions \ ActionValidationException ( "Invalid input" ) ; } hypePrototyper ( ) -> prototype -> clearStickyValues ( $ this -> action ) ; return true ; }
11101	public static function countryCodeTwoToThree ( $ code ) { $ codes = array_flip ( self :: $ _countryCodes ) ; if ( ! array_key_exists ( $ code , $ codes ) ) { return false ; } return $ codes [ $ code ] ; }
11622	public function api ( string $ link = null , string $ method = null ) : \ TheCMSThread \ Classes \ API { static $ api ; if ( $ api === null ) { $ api = $ this -> container -> get ( "TheCMSThread\\Core\\API" ) ; } return $ api -> set ( $ link , $ method ) ; }
4441	public function fromSubscriptions ( string $ topic ) : array { $ response = [ ] ; if ( empty ( $ topic ) ) { return $ response ; } $ subscriptions = $ this -> client -> call ( 'subscription' , 'default' , 'all' , $ topic ) ; $ subscriptions = json_decode ( $ subscriptions , true ) ? : [ ] ; foreach ( $ subscriptions as $ subscription => $ queues ) { $ topicPattern = str_replace ( [ '.' , '*' , '#' ] , [ '\.' , '[a-zA-z0-9^.]{1,}' , '.*' ] , $ subscription ) ; if ( preg_match ( "/^$topicPattern$/" , $ topic ) ) { $ response = array_merge ( $ response , $ queues ) ; } } return array_unique ( $ response ) ; }
10799	public function renderPageHistoricAction ( ) { $ idPage = $ this -> params ( ) -> fromRoute ( 'idPage' , $ this -> params ( ) -> fromQuery ( 'idPage' , '' ) ) ; $ melisKey = $ this -> params ( ) -> fromRoute ( 'melisKey' , '' ) ; $ view = new ViewModel ( ) ; $ view -> idPage = $ idPage ; $ view -> melisKey = $ melisKey ; return $ view ; }
12220	public function exceptionHandler ( $ exception ) { $ request = ( isset ( $ this -> container [ 'latestRequest' ] ) ? $ this -> container [ 'latestRequest' ] : $ this -> container [ 'request' ] ) ; $ response = ( isset ( $ this -> container [ 'latestResponse' ] ) ? $ this -> container [ 'latestResponse' ] : $ this -> container [ 'response' ] ) ; if ( ! ( $ exception instanceof Exception ) ) { $ exception = new InternalServerError ( $ exception -> getMessage ( ) , $ exception -> getCode ( ) , $ exception -> getPrevious ( ) ) ; } $ this -> logException ( $ exception ) ; $ response = $ response -> withBody ( new Stream ( 'php://memory' , 'w+' ) ) ; $ response = $ response -> withStatus ( $ exception -> getStatusCode ( ) ) ; $ body = $ this -> prepareErrorBody ( $ exception ) ; $ response = $ response -> withUnserializedBody ( $ body ) ; $ this -> container [ 'pipeline' ] -> prepareErrorQueue ( ) ; $ this -> container [ 'pipeline' ] ( $ request , $ response ) ; }
12965	public function getIcon ( ) { if ( is_null ( $ this -> _icon ) && isset ( $ this -> object ) ) { $ this -> _icon = [ 'class' => $ this -> object -> objectType -> icon , 'title' => $ this -> objectTypeDescriptor ] ; } return $ this -> _icon ; }
6942	protected function scheduleSubjectStockUnitChangeEvent ( StockUnitInterface $ stockUnit ) { $ this -> persistenceHelper -> scheduleEvent ( $ this -> getSubjectStockUnitChangeEventName ( ) , new SubjectStockUnitEvent ( $ stockUnit ) ) ; }
4242	public function onOutput ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ vals = $ this -> runtimeVals ( ) ; $ this -> debug -> groupSummary ( 1 ) ; $ this -> debug -> info ( 'Built In ' . $ vals [ 'runtime' ] . ' sec' ) ; $ this -> debug -> info ( 'Peak Memory Usage' . ( $ this -> debug -> getCfg ( 'output/outputAs' ) == 'html' ? ' <span title="Includes debug overhead">?&#x20dd;</span>' : '' ) . ': ' . $ this -> debug -> utilities -> getBytes ( $ vals [ 'memoryPeakUsage' ] ) . ' / ' . $ this -> debug -> utilities -> getBytes ( $ vals [ 'memoryLimit' ] ) ) ; $ this -> debug -> groupEnd ( ) ; }
7809	public static function toDebugReport ( ) { $ report = 'PHP SDK (zipMoney) Debug Report:' . PHP_EOL ; $ report .= ' OS: ' . php_uname ( ) . PHP_EOL ; $ report .= ' PHP Version: ' . phpversion ( ) . PHP_EOL ; $ report .= ' OpenAPI Spec Version: 2017-03-01' . PHP_EOL ; $ report .= ' Temp Folder Path: ' . self :: getDefaultConfiguration ( ) -> getTempFolderPath ( ) . PHP_EOL ; return $ report ; }
10223	public function menuFor ( $ model , $ modelId = 0 , ModelConfig $ config = null ) { if ( is_null ( $ this -> aujaConfigurator ) ) { throw new \ LogicException ( 'Auja not initialized. Call Auja::init first.' ) ; } $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ modelId == 0 ) { $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; } else { $ menu = $ this -> buildComplexIndexMenu ( $ modelName , $ modelId , $ config ) ; } return $ menu ; }
11989	public function sort ( $ entityName , $ values ) { $ values = json_decode ( $ values ) ; for ( $ i = 0 ; $ i < count ( $ values ) ; $ i ++ ) { $ this -> entityManager -> getRepository ( $ entityName ) -> createQueryBuilder ( 'e' ) -> update ( ) -> set ( 'e.order' , $ i ) -> where ( 'e.id = :id' ) -> setParameter ( 'id' , $ values [ $ i ] -> id ) -> getQuery ( ) -> execute ( ) ; } }
601	public function orOnCondition ( $ condition , $ params = [ ] ) { if ( $ this -> on === null ) { $ this -> on = $ condition ; } else { $ this -> on = [ 'or' , $ this -> on , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
7380	public function fetchEscape ( string $ key , \ mysqli $ db , string $ default = '' ) : string { return $ db -> real_escape_string ( $ this -> fetch ( $ key , $ default ) ) ; }
4188	public function boot ( Factory $ validator ) { $ passwordStrength = app ( 'passwordStrength' ) ; $ translator = app ( 'passwordStrength.translationProvider' ) -> get ( $ validator ) ; foreach ( [ 'letters' , 'numbers' , 'caseDiff' , 'symbols' ] as $ rule ) { $ snakeCasedRule = snake_case ( $ rule ) ; $ validator -> extend ( $ rule , function ( $ _ , $ value , $ __ ) use ( $ passwordStrength , $ rule ) { $ capitalizedRule = ucfirst ( $ rule ) ; return call_user_func ( [ $ passwordStrength , "validate{$capitalizedRule}" ] , $ value ) ; } , $ translator -> get ( "password-strength::validation.{$snakeCasedRule}" ) ) ; } }
5968	protected static function sortGroupList ( AbstractNode $ a , AbstractNode $ b ) { if ( get_class ( $ a ) != get_class ( $ b ) ) { return 0 ; throw new Ts3Exception ( "invalid parameter" , 0x602 ) ; } if ( ! $ a instanceof Servergroup && ! $ a instanceof Channelgroup ) { return 0 ; throw new Ts3Exception ( "convert error" , 0x604 ) ; } if ( $ a -> getProperty ( "sortid" , 0 ) != $ b -> getProperty ( "sortid" , 0 ) && $ a -> getProperty ( "sortid" , 0 ) != 0 && $ b -> getProperty ( "sortid" , 0 ) != 0 ) { return ( $ a -> getProperty ( "sortid" , 0 ) < $ b -> getProperty ( "sortid" , 0 ) ) ? - 1 : 1 ; } return ( $ a -> getId ( ) < $ b -> getId ( ) ) ? - 1 : 1 ; }
5583	public function clickLinkById ( $ id ) { if ( ! ( $ url = $ this -> getLinkById ( $ id ) ) ) { return false ; } $ this -> load ( $ url , new SimpleGetEncoding ( ) ) ; return $ this -> getContent ( ) ; }
11231	public function post ( $ section , $ body = null , array $ headers = [ ] ) { if ( is_array ( $ body ) ) { $ body = array_merge ( $ this -> parameters , $ body , $ this -> defaultParameters ) ; $ body = http_build_query ( $ body ) ; } return $ this -> client -> post ( $ this -> getUrl ( $ section ) , $ headers , $ body ) ; }
11540	protected function resolveAddOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'page' , 'language' , 'country' , 'slot' , 'blockname' , 'type' , 'position' , 'direction' , ) ) ; $ this -> optionsResolver -> resolve ( $ options ) ; $ this -> optionsResolved = true ; }
5430	public function hasFinal ( ) { $ reflection = new ReflectionClass ( $ this -> interface ) ; $ methods = $ reflection -> getMethods ( ) ; foreach ( $ methods as $ method ) { if ( $ method -> isFinal ( ) ) { return true ; } } return false ; }
9733	public function setARGB ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: COLOR_BLACK ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'argb' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> argb = $ pValue ; } return $ this ; }
337	protected function extractColumnType ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> dbType = $ dbType ; if ( strpos ( $ dbType , 'FLOAT' ) !== false || strpos ( $ dbType , 'DOUBLE' ) !== false ) { $ column -> type = 'double' ; } elseif ( strpos ( $ dbType , 'NUMBER' ) !== false ) { if ( $ scale === null || $ scale > 0 ) { $ column -> type = 'decimal' ; } else { $ column -> type = 'integer' ; } } elseif ( strpos ( $ dbType , 'INTEGER' ) !== false ) { $ column -> type = 'integer' ; } elseif ( strpos ( $ dbType , 'BLOB' ) !== false ) { $ column -> type = 'binary' ; } elseif ( strpos ( $ dbType , 'CLOB' ) !== false ) { $ column -> type = 'text' ; } elseif ( strpos ( $ dbType , 'TIMESTAMP' ) !== false ) { $ column -> type = 'timestamp' ; } else { $ column -> type = 'string' ; } }
5175	public function set ( string $ key , $ value ) : self { if ( ! isset ( $ this -> props [ $ key ] ) ) { throw new \ Exception ( 'Cannot add new property from set. Use add()' ) ; } $ this -> props [ $ key ] = $ value ; return $ this ; }
6294	private function findPath ( $ directory ) { $ path = [ ] ; $ path [ ] = $ this -> basePath ; $ path [ ] = $ directory ; $ path [ ] = 'views' ; return implode ( DIRECTORY_SEPARATOR , $ path ) ; }
7116	public function watch ( Repository \ PaymentRepositoryInterface $ paymentRepository ) { if ( null === $ term = $ this -> termRepository -> findLongest ( ) ) { return false ; } $ today = new \ DateTime ( ) ; $ today -> setTime ( 0 , 0 , 0 ) ; $ fromDate = clone $ today ; $ fromDate -> modify ( '-1 year' ) ; $ states = [ Model \ PaymentStates :: STATE_AUTHORIZED , Model \ PaymentStates :: STATE_CAPTURED ] ; $ method = $ this -> methodRepository -> findOneBy ( [ 'factoryName' => Constants :: FACTORY_NAME , ] ) ; if ( ! $ method || ! $ method -> isOutstanding ( ) ) { return false ; } $ result = false ; $ payments = $ paymentRepository -> findByMethodAndStates ( $ method , $ states , $ fromDate ) ; foreach ( $ payments as $ payment ) { $ sale = $ payment -> getSale ( ) ; if ( null === $ date = $ sale -> getOutstandingDate ( ) ) { continue ; } $ diff = $ date -> diff ( $ today ) ; if ( 0 < $ diff -> days && ! $ diff -> invert ) { $ payment -> setState ( Model \ PaymentStates :: STATE_EXPIRED ) ; $ this -> persist ( $ payment ) ; $ result = true ; } } return $ result ; }
11544	public function confirmPasswordReset ( $ token ) { $ user = $ this -> getMapper ( ) -> findOneBy ( [ 'registrationToken' => $ token ] ) ; if ( ! $ user instanceof UserInterface ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setRegistrationToken ( $ this -> getRegistrationToken ( ) ) ; $ user -> setEmailConfirmed ( true ) ; $ password = $ this -> getPasswordGenerator ( ) -> generate ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ viewModel = new ViewModel ( compact ( 'user' , 'password' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-change-password-success' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Your password has been changed!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
1559	protected function fillAttributes ( $ record , Collection $ attributes ) { $ record -> fill ( $ this -> deserializeAttributes ( $ attributes , $ record ) ) ; }
9047	public function getType ( $ data_type = 'metadata' , $ type = 'text' ) { if ( isset ( $ this -> types [ $ data_type ] [ $ type ] ) ) { return $ this -> types [ $ data_type ] [ $ type ] ; } return false ; }
7927	public function registerNamespace ( $ ns , $ def ) { list ( $ ns , $ def ) = $ this -> fireEvent ( 'namespace.register' , [ $ ns , $ def ] ) ; $ this -> namespaces [ $ ns ] = $ def ; return $ this ; }
9742	public function addPrintAreaByColumnAndRow ( $ column1 , $ row1 , $ column2 , $ row2 , $ index = - 1 ) { return $ this -> setPrintArea ( Coordinate :: stringFromColumnIndex ( $ column1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ column2 ) . $ row2 , $ index , self :: SETPRINTRANGE_INSERT ) ; }
4621	public function buildJsonObject ( $ data ) { $ this -> object = new RObject ( ) ; $ this -> object -> setData ( $ data ) ; $ this -> object -> setContentType ( Http :: CONTENT_TYPE_JSON ) ; return $ this ; }
8436	public static function fetchArray ( array $ conditions , array $ orderBy = null , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( $ entity -> getAllFieldsRealNames ( ) ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( is_array ( $ orderBy ) && count ( $ orderBy ) > 0 ) { $ orders = array ( ) ; foreach ( $ orderBy as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ orders [ $ realName ] = strtoupper ( ucfirst ( $ value ) ) ; } $ selectQuery -> orderBy ( $ orders ) ; } $ selectQuery -> limit ( 1 ) ; if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( is_array ( $ data ) === false ) { return false ; } return $ data ; }
9345	public function getRow ( $ int = 0 ) { if ( ! isset ( $ this -> arr [ $ int ] ) ) { throw new \ OutOfRangeException ( 'There is no line having this index.' ) ; } return $ this -> arr [ $ int ] ; }
2851	public function searchConfig ( $ query ) { $ configArray = array ( ) ; $ configArray = Mage :: helper ( 'sheep_debug' ) -> xml2array ( $ this -> getConfig ( ) -> getNode ( ) , $ configArray ) ; $ results = array ( ) ; $ configKeys = array_keys ( $ configArray ) ; foreach ( $ configKeys as $ configKey ) { if ( strpos ( $ configKey , $ query ) !== FALSE ) { $ results [ $ configKey ] = $ configArray [ $ configKey ] ; } } return $ results ; }
1513	public function create ( StoreInterface $ store , CreateResource $ request ) { $ record = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doCreate ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ record ) ) { return $ record ; } return $ this -> reply ( ) -> created ( $ record ) ; }
10444	protected function handleStatement ( $ line , $ type ) { if ( ! preg_match ( "/^{$type}$/" , $ line ) ) { throw new \ UnexpectedValueException ( "Expected a {$type} statement, got {$line}" ) ; } $ params = [ ] ; $ param = $ this -> handleParam ( ) ; while ( $ param !== null ) { $ params = $ params + $ param ; $ param = $ this -> handleParam ( ) ; } return $ params ; }
430	public function getBasePath ( ) { if ( $ this -> _basePath === null ) { $ class = new \ ReflectionClass ( $ this ) ; $ this -> _basePath = dirname ( $ class -> getFileName ( ) ) ; } return $ this -> _basePath ; }
4475	public function fail ( string $ group , string $ message ) { if ( $ this -> completed || $ this -> failed ) { throw new JobAlreadyFinishedException ( ) ; } $ jsonData = json_encode ( $ this -> data , JSON_UNESCAPED_SLASHES ) ? : '{}' ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ OnFailure ( $ this , $ this , $ group , $ message ) ) ; $ this -> failed = true ; return $ this -> client -> fail ( $ this -> jid , $ this -> worker , $ group , $ message , $ jsonData ) ; }
1901	public function validate ( ) { $ mandatory = $ this -> mandatory ; $ options = $ this -> getPost ( $ this -> strName ) ; if ( $ mandatory && \ is_array ( $ options ) ) { foreach ( $ options as $ option ) { if ( \ strlen ( $ option ) ) { $ this -> mandatory = false ; break ; } } } $ varInput = $ this -> validator ( $ options ) ; if ( ! empty ( $ varInput ) && ! $ this -> isValidOption ( $ varInput ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalid' ] ) ; } if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } else { $ this -> varValue = $ varInput ; } if ( $ mandatory ) { $ this -> mandatory = true ; } }
6744	public function handleServerRequest ( ServerRequestInterface $ request ) : array { $ messages = [ ] ; try { $ body = $ request -> getBody ( ) -> getContents ( ) ; $ uriPath = $ request -> getUri ( ) -> getPath ( ) ; if ( '/favicon.ico' === $ uriPath ) { return [ $ this -> createFaviconResponse ( ) , [ ] ] ; } $ from = microtime ( true ) ; $ method = $ request -> getMethod ( ) ; $ headers = $ request -> getHeaders ( ) ; $ symfonyRequest = new Request ( $ request -> getQueryParams ( ) , $ request -> getParsedBody ( ) ?? [ ] , $ request -> getAttributes ( ) , $ request -> getCookieParams ( ) , $ request -> getUploadedFiles ( ) , [ ] , $ body ) ; $ symfonyRequest -> setMethod ( $ method ) ; $ symfonyRequest -> headers -> replace ( $ headers ) ; $ symfonyRequest -> server -> set ( 'REQUEST_URI' , $ uriPath ) ; if ( isset ( $ headers [ 'Host' ] ) ) { $ symfonyRequest -> server -> set ( 'SERVER_NAME' , explode ( ':' , $ headers [ 'Host' ] [ 0 ] ) ) ; } $ symfonyResponse = $ this -> kernel -> handle ( $ symfonyRequest ) ; $ this -> kernel -> terminate ( $ symfonyRequest , $ symfonyResponse ) ; $ to = microtime ( true ) ; $ messages [ ] = new ConsoleMessage ( $ request -> getUri ( ) -> getPath ( ) , $ method , $ symfonyResponse -> getStatusCode ( ) , $ symfonyResponse -> getContent ( ) , \ intval ( ( $ to - $ from ) * 1000 ) ) ; $ this -> applyResponseEncoding ( $ symfonyRequest , $ symfonyResponse ) ; $ httpResponse = new \ React \ Http \ Response ( $ symfonyResponse -> getStatusCode ( ) , $ symfonyResponse -> headers -> all ( ) , $ symfonyResponse -> getContent ( ) ) ; $ symfonyRequest = null ; $ symfonyResponse = null ; } catch ( \ Throwable $ exception ) { $ messages [ ] = new ConsoleException ( $ exception ) ; $ httpResponse = new \ React \ Http \ Response ( 400 , [ 'Content-Type' => 'text/plain' ] , $ exception -> getMessage ( ) ) ; } return [ $ httpResponse , $ messages ] ; }
1333	protected function applyFilters ( $ query , Collection $ filters ) { if ( $ this -> isFindMany ( $ filters ) ) { $ this -> filterByIds ( $ query , $ filters ) ; } $ this -> filter ( $ query , $ filters ) ; }
3984	private function addMenu ( & $ modules , $ section , $ name , $ module , Request $ request ) { if ( ! isset ( $ modules [ $ section ] ) ) { $ modules [ $ section ] = $ this -> buildBackendMenuSection ( $ section , $ request ) ; } $ active = $ this -> isActive ( $ module [ 'route' ] , $ module [ 'param' ] , $ request ) ; $ class = 'navigation ' . $ name ; if ( isset ( $ module [ 'class' ] ) ) { $ class .= ' ' . $ module [ 'class' ] ; } if ( $ active ) { $ class .= ' active' ; } if ( $ request -> query -> has ( 'ref' ) ) { $ module [ 'param' ] [ 'ref' ] = $ request -> query -> get ( 'ref' ) ; } $ modules [ $ section ] [ 'modules' ] [ $ name ] = [ 'label' => $ module [ 'label' ] , 'title' => $ module [ 'title' ] , 'class' => $ class , 'isActive' => $ active , 'href' => $ this -> urlGenerator -> generate ( $ module [ 'route' ] , $ module [ 'param' ] ) , ] ; }
7003	public function match ( $ test ) { $ isArray = [ ] ; $ pattern = preg_replace_callback ( "~/\{(?<arg>\w+)(?<arr>\[\])?\}(?<num>\?|\+|\*|\{[0-9,]+\})?~" , function ( $ matches ) use ( & $ isArray ) { $ name = $ matches [ "arg" ] ; $ num = $ matches [ "num" ] ?? "" ; $ isArray [ $ name ] = ! empty ( $ matches [ 2 ] ) ; return "(?<$name>(?:/[^\\s/?]+)$num)" ; } , $ this -> url ) ; if ( ! $ pattern || empty ( $ pattern ) ) { error_log ( "pattern error: found in route with pattern: {$this->url}" ) ; return false ; } $ pattern = "^$pattern/?(?:\?.*)?$" ; if ( preg_match ( "~$pattern~" , $ test , $ matches ) ) { foreach ( $ matches as $ name => $ val ) { $ val = urldecode ( $ val ) ; if ( is_int ( $ name ) ) { if ( $ name === 0 ) $ this -> args [ $ name ] = $ val ; } else { $ val = ltrim ( $ val , "/" ) ; $ this -> args [ $ name ] = $ isArray [ $ name ] ? explode ( "/" , $ val ) : $ val ; } } return true ; } return false ; }
8333	private function getSelectSql ( ) { if ( self :: LOCK_TRANSACTIONAL === $ this -> lockMode ) { $ this -> beginTransaction ( ) ; switch ( $ this -> driver ) { case 'mysql' : case 'oci' : case 'pgsql' : return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WHERE $this->idCol = :id FOR UPDATE" ; case 'sqlsrv' : return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WITH (UPDLOCK, ROWLOCK) WHERE $this->idCol = :id" ; case 'sqlite' : break ; default : throw new \ DomainException ( sprintf ( 'Transactional locks are currently not implemented for PDO driver "%s".' , $ this -> driver ) ) ; } } return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WHERE $this->idCol = :id" ; }
9356	public function withUri ( UriInterface $ uri , $ preserve = false ) { $ static = clone $ this ; $ static -> uri = $ uri ; if ( ! $ preserve && $ host = $ uri -> getHost ( ) ) { $ port = $ host . ':' . $ uri -> getPort ( ) ; $ host = $ uri -> getPort ( ) ? $ port : $ host ; $ static -> headers [ 'Host' ] = ( array ) $ host ; } return $ static ; }
12875	public static function getJSON ( $ src ) { $ src = file_get_contents ( $ src ) ; $ out = json_decode ( $ src , true ) ; return $ out ; }
3494	public function withCertificatePassPhrase ( string $ passPhrase ) : Request { $ cloned = clone $ this ; $ cloned -> certificatePassPhrase = $ passPhrase ; return $ cloned ; }
1311	public function checkSignature ( Request $ request , Consumer $ consumer , Token $ token , $ signature ) { $ built = $ this -> buildSignature ( $ request , $ consumer , $ token ) ; if ( strlen ( $ built ) == 0 || strlen ( $ signature ) == 0 ) { return false ; } if ( strlen ( $ built ) != strlen ( $ signature ) ) { return false ; } $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ signature ) ; $ i ++ ) { $ result |= ord ( $ built { $ i } ) ^ ord ( $ signature { $ i } ) ; } return $ result == 0 ; }
10730	public function getHour ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'hour' ] ; } }
9153	public function getUrlString ( ) : string { $ query = "" ; if ( strlen ( $ this -> queryString ) > 0 ) { $ query = sprintf ( "?%s" , $ this -> queryString ) ; } if ( ( $ this -> scheme == 'http' && $ this -> getPort ( ) == 80 ) || ( $ this -> scheme == 'ftp' && $ this -> getPort ( ) == 21 ) || ( $ this -> scheme == 'https' && $ this -> getPort ( ) == 443 ) ) { return sprintf ( "%s://%s%s%s" , $ this -> scheme , $ this -> getAddress ( ) , $ this -> path , $ query ) ; } return sprintf ( "%s://%s:%d%s%s" , $ this -> scheme , $ this -> getAddress ( ) , $ this -> getPort ( ) , $ this -> path , $ query ) ; }
5209	public function convert ( array $ stmts , ClassMetadata $ metadata , ClassCollector $ classCollector , Logger $ logger ) { $ this -> metadata = $ metadata ; $ this -> classCollector = $ classCollector ; $ this -> logger = $ logger ; return ltrim ( str_replace ( "\n" . self :: noIndentToken , "\n" , $ this -> pStmts ( $ stmts , false ) ) ) ; }
4153	public function invalidateBearerToken ( ) { $ url = $ this -> getInvalidateBearerTokenUrl ( ) ; $ bearerToken = $ this -> bearerToken ; if ( $ bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } $ params = array ( 'post' => array ( 'access_token' => $ bearerToken ) , 'headers' => $ this -> buildBearerTokenHeader ( ) , ) ; $ response = $ this -> curl -> send ( $ url , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> access_token ) || $ obj -> access_token != $ bearerToken ) { $ this -> findExceptions ( $ response ) ; } unset ( $ url , $ bearerToken , $ params , $ response , $ obj ) ; return true ; }
10751	public function init ( UserEntity $ user , ServiceManager $ sm ) { $ main = $ sm -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; $ this -> hashId = $ userRepository -> getEncryptedId ( $ user -> getUserId ( ) ) ; $ this -> name = $ user -> getName ( ) ; $ this -> surname = $ user -> getSurname ( ) ; $ this -> email = $ user -> getEmail ( ) ; $ this -> gender = $ user -> getGender ( ) ; $ this -> dateBorn = $ this -> getDateBorn ( $ user , $ sm ) ; $ this -> nicename = $ user -> getNicename ( ) ; $ this -> mobile = $ this -> getMobile ( $ user ) ; $ this -> isAdmin = 'god' == $ user -> getRole ( ) ; $ this -> fullname = $ this -> getFullname ( $ user ) ; $ this -> role = $ user -> getRole ( ) ; $ this -> state = $ user -> getState ( ) ; $ this -> stateFormatted = $ this -> getStateFormatted ( $ user ) ; $ this -> editAddress = '/#/edituseerrr' ; $ this -> isActive = $ user -> getState ( ) == UserEntity :: USER_STATE_ACTIVE ; $ this -> isDeactive = $ user -> getState ( ) == UserEntity :: USER_STATE_DEACTIVE ; $ this -> isDeleted = $ user -> getState ( ) == UserEntity :: USER_STATE_DELETED ; $ this -> isBanned = $ user -> getState ( ) == UserEntity :: USER_STATE_BANNED ; $ this -> count = 'disabled' ; return $ this ; }
12278	public function moveUser ( $ openId , $ groupId ) { $ params = [ 'openid' => $ openId , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_UPDATE , $ params ] ) ; }
1275	private function sendRequest ( $ request , $ endpoint , $ operation , $ wsdl ) { $ endpointurl = $ this -> compileEndpointUrl ( $ endpoint ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ endpointurl , $ operation , $ wsdl ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } return $ this -> formatResponse ( $ response ) ; }
5101	public function valuesExp ( $ expression , $ bind = false ) { return $ this -> appendPart ( CmdInsert :: PART_VALUES , $ expression , $ bind ) ; }
11548	public function getGroup ( $ name ) { if ( array_key_exists ( $ name , $ this -> groups ) ) { return $ this -> groups [ $ name ] ; } throw new KeyNotFoundInSetException ( $ name , array_keys ( $ this -> groups ) , 'groups' ) ; }
11380	public function deleteAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/..\/(\w+)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ containerName ) = $ matches ; $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ pageTexts -> deleteTextContainer ( $ containerName ) ; $ this -> environment -> sendJSONResult ( 'ok' ) ; }
12765	public function addByHttpCode ( int $ code ) : self { $ serverProtocol = filter_input ( \ INPUT_SERVER , 'SERVER_PROTOCOL' , \ FILTER_SANITIZE_STRING ) ; $ protocol = ! empty ( $ serverProtocol ) ? $ serverProtocol : 'HTTP/1.1' ; $ sHeader = "{$protocol} {$code} " . self :: getHTTPExplanationByCode ( $ code ) ; return $ this -> add ( $ sHeader ) ; }
3060	public function getCurrentAssessmentItemRef ( ) { if ( $ this -> isAdaptive ( ) ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAssessmentItemRefByIdentifier ( $ this -> getCompilationDirectory ( ) [ 'private' ] , $ this -> getCurrentCatItemId ( ) ) ; } else { return $ this -> getTestSession ( ) -> getCurrentAssessmentItemRef ( ) ; } }
10443	protected function handleStart ( $ line ) { if ( preg_match ( '/^(INSERT INTO|UPDATE|DELETE FROM)\s+`?(.*?)`?\.`?(.*?)`?$/' , $ line , $ part ) ) { return [ 'type' => $ this -> detectQueryType ( $ part [ 1 ] ) , 'table' => $ part [ 3 ] , ] ; } throw new \ UnexpectedValueException ( "Expected a statement, got {$line}" ) ; }
2077	public function purgeScriptCache ( ) { foreach ( array ( 'assets/js' , 'assets/css' ) as $ dir ) { $ objFolder = new Folder ( $ dir ) ; $ objFolder -> purge ( ) ; } $ this -> import ( StyleSheets :: class , 'StyleSheets' ) ; $ this -> StyleSheets -> updateStyleSheets ( ) ; $ this -> purgePageCache ( ) ; $ this -> log ( 'Purged the script cache' , __METHOD__ , TL_CRON ) ; }
11591	private function upload ( $ path , $ payload ) { return Storage :: disk ( 's3' ) -> put ( $ path , $ payload , $ this -> visibility ) ; }
4913	public function add ( $ name , $ entities = null , array $ options = null ) { if ( $ name instanceof DependencyResult ) { return $ this -> addResult ( $ name ) ; } if ( $ name instanceof \ Traversable ) { return $ this -> addTraversable ( $ name ) ; } if ( is_array ( $ name ) ) { return $ this -> addArray ( $ name ) ; } if ( null === $ entities ) { throw new \ UnexpectedValueException ( '$entities must not be null.' ) ; } return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ entities , 'options' => $ options , ] ) ; }
10829	public static function dir ( string $ path ) : fs \ entity \ DirEntity { return ( new fs \ entity \ DirEntity ( $ path ) ) -> normalize ( ) ; }
3764	private function getVisibleCondition ( $ property ) { $ condition = $ property -> getVisibleCondition ( ) ; if ( $ condition instanceof PropertyConditionChain ) { return $ condition ; } $ conditionChain = new PropertyConditionChain ( ) ; $ property -> setVisibleCondition ( $ conditionChain ) ; if ( $ condition ) { $ conditionChain -> addCondition ( $ condition ) ; } return $ conditionChain ; }
8458	public function updateDb ( ) { $ this -> printTaskInfo ( 'Do database updates' ) ; $ this -> drush ( 'updb' ) ; $ drushVersion = $ this -> getVersion ( ) ; if ( - 1 === version_compare ( $ drushVersion , '6.0' ) ) { $ this -> printTaskInfo ( 'Will clear cache after db updates for drush ' . $ drushVersion ) ; $ this -> clearCache ( ) ; } else { $ this -> printTaskInfo ( 'Will not clear cache after db updates, since drush ' . $ drushVersion . ' should do it automatically' ) ; } return $ this ; }
6411	public static function any ( IteratorAggregate $ iterable , callable $ predicate ) : bool { return Iterators :: any ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ predicate ) ; }
2638	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItems = $ this -> api -> aclItemsList ( $ aclId ) ; if ( is_array ( $ aclItems ) && empty ( $ aclItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'aclItems' => [ ] ] ) ; } if ( ! $ aclItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch acl items.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'aclItems' => $ aclItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
802	public static function shouldBeTogether ( Tag $ first , Tag $ second ) { $ firstName = $ first -> getName ( ) ; $ secondName = $ second -> getName ( ) ; if ( $ firstName === $ secondName ) { return true ; } foreach ( self :: $ groups as $ group ) { if ( \ in_array ( $ firstName , $ group , true ) && \ in_array ( $ secondName , $ group , true ) ) { return true ; } } return false ; }
8521	public function setListingQualityRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ListingQualityRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2403	public function trans ( $ strId , array $ arrParams = array ( ) , $ strDomain = 'contao_default' ) { return System :: getContainer ( ) -> get ( 'translator' ) -> trans ( $ strId , $ arrParams , $ strDomain ) ; }
10182	public function unsetWorksheetCells ( ) { if ( $ this -> currentCell !== null ) { $ this -> currentCell -> detach ( ) ; $ this -> currentCell = null ; $ this -> currentCoordinate = null ; } $ this -> __destruct ( ) ; $ this -> index = [ ] ; $ this -> parent = null ; }
3889	public function getFilterSettings ( \ DC_Table $ objDC ) { $ filterSettings = $ this -> connection -> createQueryBuilder ( ) -> select ( 'f.id' , 'f.name' ) -> from ( 'tl_metamodel_filter' , 'f' ) -> where ( 'f.pid=:id' ) -> setParameter ( 'id' , $ objDC -> activeRecord -> metamodel ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; foreach ( $ filterSettings as $ filterSetting ) { $ result [ $ filterSetting [ 'id' ] ] = $ filterSetting [ 'name' ] ; } asort ( $ result ) ; return $ result ; }
8305	public function assertGreaterThan ( $ config , $ keyGreater , $ keyLower ) { if ( ! isset ( $ config [ $ keyLower ] ) || ! isset ( $ config [ $ keyGreater ] ) || $ config [ $ keyLower ] >= $ config [ $ keyGreater ] ) { throw new ConfigurationException ( $ keyGreater . " must be greater than " . $ keyLower ) ; } return $ this ; }
285	public function setDefault ( $ name , $ value ) { $ name = strtolower ( $ name ) ; if ( empty ( $ this -> _headers [ $ name ] ) ) { $ this -> _headers [ $ name ] [ ] = $ value ; } return $ this ; }
5056	public function attachEvents ( EventManagerInterface $ events , array $ eventsSpec = null ) { if ( null === $ eventsSpec ) { $ eventsSpec = $ this -> eventsProvider ( ) ; } foreach ( $ eventsSpec as $ spec ) { if ( ! is_array ( $ spec ) || 2 > count ( $ spec ) ) { throw new \ UnexpectedValueException ( 'Event specification must be an array with at least two entries: event name and method name.' ) ; } $ event = $ spec [ 0 ] ; $ method = $ spec [ 1 ] ; $ priority = isset ( $ spec [ 2 ] ) ? $ spec [ 2 ] : 0 ; $ this -> listeners [ ] = $ events -> attach ( $ event , [ $ this , $ method ] , $ priority ) ; } return $ this ; }
11578	public function actionResend ( ) { if ( $ this -> module -> enableConfirmation == false ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( ResendForm :: className ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> resend ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'A new confirmation link has been sent' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'resend' , [ 'model' => $ model ] ) ; }
94	protected function hasVendorIgnore ( $ ignoreFile , $ vendor = 'vendor' ) { if ( ! file_exists ( $ ignoreFile ) ) { return false ; } $ pattern = sprintf ( '{^/?%s(/\*?)?$}' , preg_quote ( $ vendor ) ) ; $ lines = file ( $ ignoreFile , FILE_IGNORE_NEW_LINES ) ; foreach ( $ lines as $ line ) { if ( preg_match ( $ pattern , $ line ) ) { return true ; } } return false ; }
5188	private function createPage ( string $ title , string $ body , string $ source , int $ order , string $ cover , string $ lead ) : \ One \ Model \ Page { return new Page ( $ title , $ body , $ source , $ order , $ cover , $ lead ) ; }
8662	private function convertGetFeedSubmissionList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionIdList ( ) ) { $ feedSubmissionIdList = $ request -> getFeedSubmissionIdList ( ) ; foreach ( $ feedSubmissionIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'FeedSubmissionIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
4690	public function addGroupBy ( $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group [ ] = $ expression ; $ this -> pushArgs ( 'group' , $ args ) ; return $ this ; }
8604	public function getSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_GetSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_GetSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_GetSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11874	protected function renewAccessToken ( ) { $ token = $ this -> authorizer -> getApi ( ) -> getAuthorizerToken ( $ this -> authorizer -> getAppId ( ) , $ this -> authorizer -> getRefreshToken ( ) ) ; $ this -> authorizer -> setAccessToken ( $ token [ 'authorizer_access_token' ] , $ token [ 'expires_in' ] - 1500 ) ; return $ token [ 'authorizer_access_token' ] ; }
8663	private function convertGetReportRequestList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportRequestList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportRequestIdList ( ) ) { $ reportRequestIdList = $ request -> getReportRequestIdList ( ) ; foreach ( $ reportRequestIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportRequestIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetReportProcessingStatusList ( ) ) { $ reportProcessingStatusList = $ request -> getReportProcessingStatusList ( ) ; foreach ( $ reportProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'ReportProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetRequestedFromDate ( ) ) { $ parameters [ 'RequestedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedFromDate ( ) ) ; } if ( $ request -> isSetRequestedToDate ( ) ) { $ parameters [ 'RequestedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
10872	public function existEmail ( string $ email ) : int { return ( int ) $ this -> connection -> select ( self :: COLUMN_ID ) -> from ( $ this -> tableIdentity ) -> where ( [ 'email' => $ email ] ) -> fetchSingle ( ) ; }
2136	protected static function loadParameters ( ) { $ container = System :: getContainer ( ) ; if ( $ container === null ) { return ; } if ( $ container -> hasParameter ( 'contao.localconfig' ) && \ is_array ( $ params = $ container -> getParameter ( 'contao.localconfig' ) ) ) { foreach ( $ params as $ key => $ value ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ key ] = $ value ; } } $ arrMap = array ( 'dbHost' => 'database_host' , 'dbPort' => 'database_port' , 'dbUser' => 'database_user' , 'dbPass' => 'database_password' , 'dbDatabase' => 'database_name' , 'smtpHost' => 'mailer_host' , 'smtpUser' => 'mailer_user' , 'smtpPass' => 'mailer_password' , 'smtpPort' => 'mailer_port' , 'smtpEnc' => 'mailer_encryption' , 'addLanguageToUrl' => 'contao.prepend_locale' , 'encryptionKey' => 'contao.encryption_key' , 'urlSuffix' => 'contao.url_suffix' , 'uploadPath' => 'contao.upload_path' , 'debugMode' => 'kernel.debug' , ) ; foreach ( $ arrMap as $ strKey => $ strParam ) { if ( $ container -> hasParameter ( $ strParam ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ strKey ] = $ container -> getParameter ( $ strParam ) ; } } if ( $ container -> hasParameter ( 'contao.image.valid_extensions' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'validImageTypes' ] = implode ( ',' , $ container -> getParameter ( 'contao.image.valid_extensions' ) ) ; } if ( $ container -> hasParameter ( 'contao.image.imagine_options' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'jpgQuality' ] = $ container -> getParameter ( 'contao.image.imagine_options' ) [ 'jpeg_quality' ] ; } }
7282	public static function current ( ) { $ url = $ _SERVER [ "REQUEST_URI" ] ; $ method = $ _SERVER [ "REQUEST_METHOD" ] ; $ time = $ _SERVER [ "REQUEST_TIME_FLOAT" ] ; $ headers = getallheaders ( ) ? : [ ] ; $ inputs = [ ] ; $ files = [ ] ; $ raw = [ ] ; switch ( $ method ) { case "GET" : $ raw = $ _GET ; break ; case "POST" : $ raw = $ _POST ; break ; default : parse_str ( file_get_contents ( "php://input" ) , $ raw ) ; } foreach ( $ raw as $ input => $ val ) $ inputs [ $ input ] = parse_string ( $ val ) ; foreach ( $ _FILES as $ name => $ file ) $ files [ $ name ] = $ file ; return new static ( $ url , $ method , $ time , $ headers , $ inputs , $ files ) ; }
252	public function removeAllFlashes ( ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; foreach ( array_keys ( $ counters ) as $ key ) { unset ( $ _SESSION [ $ key ] ) ; } unset ( $ _SESSION [ $ this -> flashParam ] ) ; }
10609	public function classifiedAnswerAction ( ) { $ request = $ this -> getRequest ( ) ; $ response = $ this -> getResponse ( ) ; if ( ! $ request -> isPost ( ) ) { $ response -> setStatusCode ( Response :: STATUS_CODE_500 ) ; return new JsonModel ( array ( 'status' => 'danger' , 'message' => 'Invalid method call' ) ) ; } $ userService = $ this -> getServiceLocator ( ) -> get ( 'user.service.user' ) ; $ data = array_merge_recursive ( $ this -> params ( ) -> fromPost ( ) , Json :: decode ( $ request -> getContent ( ) , Json :: TYPE_ARRAY ) ) ; try { $ response -> setStatusCode ( Response :: STATUS_CODE_200 ) ; $ userService -> classifiedAnswer ( $ data ) ; $ returnData = array ( 'status' => 'success' , 'message' => 'La tua risposta è stata inviata!' ) ; } catch ( \ Exception $ e ) { $ response -> setStatusCode ( Response :: STATUS_CODE_500 ) ; $ returnData = @ unserialize ( $ e -> getMessage ( ) ) ; if ( ! is_array ( $ returnData ) ) { $ returnData = array ( 'status' => 'danger' , 'message' => $ e -> getMessage ( ) ) ; } } return new JsonModel ( $ returnData ) ; }
5268	public function esc_like ( $ value , $ start = '%' , $ end = '%' ) { global $ wpdb ; return $ start . $ wpdb -> esc_like ( $ value ) . $ end ; }
1018	private function arrayMergeDeep ( array $ array1 , array $ array2 ) : array { $ merged = $ array1 ; foreach ( $ array2 as $ key => & $ value ) { if ( is_numeric ( $ key ) ) { if ( ! in_array ( $ value , $ merged , true ) ) { $ merged [ ] = $ value ; } } elseif ( is_array ( $ value ) && isset ( $ merged [ $ key ] ) && is_array ( $ merged [ $ key ] ) ) { $ merged [ $ key ] = $ this -> arrayMergeDeep ( $ merged [ $ key ] , $ value ) ; } else { $ merged [ $ key ] = $ value ; } } return $ merged ; }
1351	protected function allowed ( string $ resourceType , string $ fields ) : bool { return $ this -> notAllowed ( $ resourceType , $ fields ) -> isEmpty ( ) ; }
11091	public static function gpsDistance ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) { $ lat1 = deg2rad ( $ lat1 ) ; $ lon1 = deg2rad ( $ lon1 ) ; $ lat2 = deg2rad ( $ lat2 ) ; $ lon2 = deg2rad ( $ lon2 ) ; $ lonDelta = $ lon2 - $ lon1 ; $ a = ( ( cos ( $ lat2 ) * sin ( $ lonDelta ) ) ** 2 ) + ( ( cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lonDelta ) ) ** 2 ) ; $ b = sin ( $ lat1 ) * sin ( $ lat2 ) + cos ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lonDelta ) ; return atan2 ( sqrt ( $ a ) , $ b ) * 6371.0088 ; }
420	public function run ( ) { $ block = ob_get_clean ( ) ; if ( $ this -> renderInPlace ) { echo $ block ; } $ this -> view -> blocks [ $ this -> getId ( ) ] = $ block ; }
2863	public function getLogging ( ) { $ logging = array ( ) ; foreach ( $ this -> files as $ logFile ) { $ logging [ $ logFile ] = $ this -> getLoggedContent ( $ logFile ) ; } return $ logging ; }
168	protected static function loadMimeAliases ( $ aliasesFile ) { if ( $ aliasesFile === null ) { $ aliasesFile = static :: $ mimeAliasesFile ; } $ aliasesFile = Yii :: getAlias ( $ aliasesFile ) ; if ( ! isset ( self :: $ _mimeAliases [ $ aliasesFile ] ) ) { self :: $ _mimeAliases [ $ aliasesFile ] = require $ aliasesFile ; } return self :: $ _mimeAliases [ $ aliasesFile ] ; }
2326	public static function createFromDbResult ( Result $ objResult , $ strTable ) { $ arrModels = array ( ) ; $ strClass = Model :: getClassFromTable ( $ strTable ) ; while ( $ objResult -> next ( ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( $ strTable , $ objResult -> { $ strClass :: getPk ( ) } ) ; if ( $ objModel !== null ) { $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; $ arrModels [ ] = $ objModel ; } else { $ arrModels [ ] = new $ strClass ( $ objResult ) ; } } return new static ( $ arrModels , $ strTable ) ; }
10804	public function getBackOfficeUsersAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ users = $ melisPageHistoricTable -> getUsers ( ) -> toArray ( ) ; return new JsonModel ( array ( 'users' => $ users , ) ) ; }
3516	public function setLocale ( $ locale ) { if ( $ this -> useCookies ) { Cookie :: queue ( $ this -> cookiePrefix . 'lang_locale' , $ locale ) ; } parent :: setLocale ( $ locale ) ; }
8029	public function registerFreeProcessId ( $ pid ) { $ processDetails = $ this -> getProcessDetails ( $ pid ) ; if ( $ processDetails !== NULL ) { $ this -> registerFreeProcess ( $ processDetails ) ; } return $ this ; }
5238	private function methodBindingName ( \ ReflectionMethod $ method ) { $ annotations = annotationsOf ( $ method ) ; if ( $ annotations -> contain ( 'List' ) ) { return $ annotations -> firstNamed ( 'List' ) -> getValue ( ) ; } if ( $ annotations -> contain ( 'Map' ) ) { return $ annotations -> firstNamed ( 'Map' ) -> getValue ( ) ; } if ( $ annotations -> contain ( 'Named' ) ) { return $ annotations -> firstNamed ( 'Named' ) -> getName ( ) ; } if ( $ annotations -> contain ( 'Property' ) ) { return $ annotations -> firstNamed ( 'Property' ) -> getValue ( ) ; } return null ; }
3601	private function collectException ( $ httpRequest , $ httpResponse , $ exception ) { if ( $ this -> profiler ) { $ collector = new ExceptionDataCollector ( ) ; $ collector -> collect ( $ httpRequest , $ httpResponse , $ exception ) ; $ this -> profiler -> add ( $ collector ) ; } }
12450	static function run_check_templates ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( array ( '*.tpl' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) ) { $ php = self :: getTool ( 'php' , $ opts ) ; if ( strpos ( pake_sh ( $ php . " -v" ) , 'PHP' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$php does not seem to be a valid php executable" ) ; } $ ezp = @ $ opts [ 'ezublish' ] [ 'install_dir_LS' ] ; if ( $ ezp == '' ) { $ ezp = '../..' ; } if ( ! file_exists ( $ ezp . '/bin/php/eztemplatecheck.php' ) ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$ezp does not seem to be a valid eZ Publish install" ) ; } $ rootpath = pakeFinder :: type ( 'directory' ) -> name ( $ opts [ 'extension' ] [ 'name' ] ) -> in ( self :: getBuildDir ( $ opts ) ) ; $ rootpath = dirname ( $ rootpath [ 0 ] ) ; $ out = pake_sh ( "cd " . escapeshellarg ( $ ezp ) . " && " . escapeshellarg ( $ php ) . " bin/php/eztemplatecheck.php " . escapeshellarg ( $ rootpath ) ) ; if ( strpos ( $ out , 'Some templates did not validate' ) !== false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( $ out ) ; } } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
8954	public function createWay ( $ changeset , $ tags , $ nds ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'way/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ ndList = '' ; if ( ! empty ( $ nds ) ) { foreach ( $ nds as $ value ) { $ ndList .= '<nd ref="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <way changeset="' . $ changeset . '">' . $ tagList . $ ndList . '</way> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
4752	public function send ( ) { $ optInValue = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'c_oegdproptin' ) ; if ( $ this -> isOptInValidationRequired ( ) && ! $ optInValue ) { \ OxidEsales \ Eshop \ Core \ Registry :: get ( \ OxidEsales \ Eshop \ Core \ UtilsView :: class ) -> addErrorToDisplay ( 'OEGDPROPTIN_CONTACT_FORM_ERROR_MESSAGE' ) ; $ this -> optInError = true ; return false ; } return parent :: send ( ) ; }
9662	private static function getReaderTypeFromExtension ( $ filename ) { $ pathinfo = pathinfo ( $ filename ) ; if ( ! isset ( $ pathinfo [ 'extension' ] ) ) { return null ; } switch ( strtolower ( $ pathinfo [ 'extension' ] ) ) { case 'xlsx' : case 'xlsm' : case 'xltx' : case 'xltm' : return 'Xlsx' ; case 'xls' : case 'xlt' : return 'Xls' ; case 'ods' : case 'ots' : return 'Ods' ; case 'slk' : return 'Slk' ; case 'xml' : return 'Xml' ; case 'gnumeric' : return 'Gnumeric' ; case 'htm' : case 'html' : return 'Html' ; case 'csv' : return null ; default : return null ; } }
6998	protected function prepareRelatedRecord ( $ relationName , array $ relationRecordData , $ index = null ) { $ recordWithBackup = $ relationRecordData ; $ valueViewers = $ this -> getViewersForRelations ( ) ; foreach ( $ relationRecordData as $ columnName => $ value ) { $ viewerName = $ relationName . '.' . ( $ index === null ? '' : $ index . '.' ) . $ columnName ; if ( array_key_exists ( $ viewerName , $ valueViewers ) && $ valueViewers [ $ viewerName ] -> getRelation ( ) -> getName ( ) === $ relationName ) { $ recordWithBackup [ $ columnName ] = $ recordWithBackup [ '__' . $ columnName ] = $ value ; $ valueViewer = $ valueViewers [ $ viewerName ] ; if ( is_object ( $ valueViewer ) && method_exists ( $ valueViewer , 'convertValue' ) && ( ! method_exists ( $ valueViewer , 'isVisible' ) || $ valueViewer -> isVisible ( ) ) ) { $ recordWithBackup [ $ columnName ] = $ valueViewer -> convertValue ( $ recordWithBackup [ $ columnName ] , $ relationRecordData ) ; } } } return $ recordWithBackup ; }
9448	public function getPackPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) ; } return $ paths [ $ me ] ; }
4012	private function calculatePaginated ( ) { $ this -> calculatedTotal = $ this -> getTotalAmount ( ) ; if ( ( $ this -> calculatedLimit !== null ) && ( $ this -> calculatedTotal > $ this -> calculatedLimit ) ) { $ this -> calculatedTotal -= $ this -> calculatedLimit ; } $ this -> calculatedTotal -= $ this -> calculatedOffset ; $ page = $ this -> getCurrentPage ( ) ; if ( $ page > ( $ this -> calculatedTotal / $ this -> getPerPage ( ) ) ) { $ page = ( int ) ceil ( $ this -> calculatedTotal / $ this -> getPerPage ( ) ) ; } $ pageOffset = ( ( max ( $ page , 1 ) - 1 ) * $ this -> getPerPage ( ) ) ; $ this -> calculatedOffset += $ pageOffset ; if ( $ this -> calculatedLimit === null ) { $ this -> calculatedLimit = $ this -> getPerPage ( ) ; } else { $ this -> calculatedLimit = min ( ( $ this -> calculatedLimit - $ this -> calculatedOffset ) , $ this -> getPerPage ( ) ) ; } }
584	protected function loadConfiguration ( $ configFile ) { $ this -> stdout ( "Loading configuration from '{$configFile}'...\n" ) ; $ config = require $ configFile ; foreach ( $ config as $ name => $ value ) { if ( property_exists ( $ this , $ name ) || $ this -> canSetProperty ( $ name ) ) { $ this -> $ name = $ value ; } else { throw new Exception ( "Unknown configuration option: $name" ) ; } } $ this -> getAssetManager ( ) ; }
1247	public static function ini ( $ profile = null , $ filename = null ) { $ filename = $ filename ? : ( self :: getHomeDir ( ) . '/.ebay_sdk/credentials' ) ; $ profile = $ profile ? : ( getenv ( self :: ENV_PROFILE ) ? : 'default' ) ; return function ( ) use ( $ filename , $ profile ) { if ( ! is_readable ( $ filename ) ) { return new \ InvalidArgumentException ( "Cannot read credentials from $filename" ) ; } $ data = parse_ini_file ( $ filename , true ) ; if ( $ data === false ) { return new \ InvalidArgumentException ( "Invalid credentials file $filename" ) ; } if ( ! isset ( $ data [ $ profile ] ) ) { return new \ InvalidArgumentException ( "'$profile' not found in credentials file" ) ; } if ( ! isset ( $ data [ $ profile ] [ 'ebay_app_id' ] ) || ! isset ( $ data [ $ profile ] [ 'ebay_cert_id' ] ) || ! isset ( $ data [ $ profile ] [ 'ebay_dev_id' ] ) ) { return new \ InvalidArgumentException ( "No credentials present in INI profile '$profile' ($filename)" ) ; } return new Credentials ( $ data [ $ profile ] [ 'ebay_app_id' ] , $ data [ $ profile ] [ 'ebay_cert_id' ] , $ data [ $ profile ] [ 'ebay_dev_id' ] ) ; } ; }
5292	public function buildGravatarURL ( $ email , $ hash_email = true ) { if ( $ this -> usingSecureImages ( ) ) { $ url = static :: HTTPS_URL ; } else { $ url = static :: HTTP_URL ; } if ( $ hash_email == true && ! empty ( $ email ) ) { $ url .= $ this -> getEmailHash ( $ email ) ; } elseif ( ! empty ( $ email ) ) { $ url .= $ email ; } else { $ url .= str_repeat ( '0' , 32 ) ; } if ( $ this -> param_cache === NULL ) { $ params = array ( ) ; $ params [ ] = 's=' . $ this -> getAvatarSize ( ) ; $ params [ ] = 'r=' . $ this -> getMaxRating ( ) ; if ( $ this -> getDefaultImage ( ) ) { $ params [ ] = 'd=' . $ this -> getDefaultImage ( ) ; } $ this -> params_cache = ( ! empty ( $ params ) ) ? '?' . implode ( '&' , $ params ) : '' ; } $ tail = '' ; if ( empty ( $ email ) ) { $ tail = ! empty ( $ this -> params_cache ) ? '&f=y' : '?f=y' ; } return $ url . $ this -> params_cache . $ tail ; }
6312	public function getTables ( $ schemaName = null ) { $ getTablesCommand = $ this -> container -> get ( 'rentgen.get_tables' ) ; if ( null !== $ schemaName ) { $ getTablesCommand -> setSchemaName ( $ schemaName ) ; } return $ getTablesCommand -> execute ( ) ; }
483	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ time = $ this -> beginCommand ( 'create' . ( $ unique ? ' unique' : '' ) . " index $name on $table (" . implode ( ',' , ( array ) $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
1794	private function getAutoItems ( array $ parameters ) : array { if ( isset ( $ parameters [ 'auto_item' ] ) ) { return [ $ parameters [ 'auto_item' ] ] ; } if ( isset ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) && \ is_array ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) { return $ GLOBALS [ 'TL_AUTO_ITEM' ] ; } return [ ] ; }
9883	private function writeDefinedNames ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ objWriter -> startElement ( 'definedNames' ) ; if ( count ( $ spreadsheet -> getNamedRanges ( ) ) > 0 ) { $ this -> writeNamedRanges ( $ objWriter , $ spreadsheet ) ; } $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ this -> writeDefinedNameForAutofilter ( $ objWriter , $ spreadsheet -> getSheet ( $ i ) , $ i ) ; $ this -> writeDefinedNameForPrintTitles ( $ objWriter , $ spreadsheet -> getSheet ( $ i ) , $ i ) ; $ this -> writeDefinedNameForPrintArea ( $ objWriter , $ spreadsheet -> getSheet ( $ i ) , $ i ) ; } $ objWriter -> endElement ( ) ; }
5689	public function getFormById ( $ id ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> getId ( ) == $ id ) { return $ this -> forms [ $ i ] ; } } return ; }
4873	public function init ( ) { $ this -> setName ( 'buttons' ) ; if ( ! isset ( $ this -> options [ 'render_summary' ] ) ) { $ this -> options [ 'render_summary' ] = false ; } $ this -> setAttribute ( 'class' , 'text-right' ) ; $ this -> add ( array ( 'type' => 'Core/Spinner-Submit' , 'name' => 'submit' , 'options' => array ( 'label' => 'Save' , ) , 'attributes' => array ( 'id' => 'submit' , 'type' => 'submit' , 'value' => 'Save' , 'class' => 'sf-submit btn btn-primary btn-xs' ) , ) ) ; $ this -> add ( array ( 'type' => 'Button' , 'name' => 'cancel' , 'options' => array ( 'label' => 'Cancel' , ) , 'attributes' => array ( 'id' => 'cancel' , 'type' => 'reset' , 'value' => 'Cancel' , 'class' => 'sf-cancel btn btn-default btn-xs' ) , ) ) ; }
10137	private function writeMsoDrawing ( ) { if ( isset ( $ this -> escher ) ) { $ writer = new Escher ( $ this -> escher ) ; $ data = $ writer -> close ( ) ; $ spOffsets = $ writer -> getSpOffsets ( ) ; $ spTypes = $ writer -> getSpTypes ( ) ; $ spOffsets [ 0 ] = 0 ; $ nm = count ( $ spOffsets ) - 1 ; for ( $ i = 1 ; $ i <= $ nm ; ++ $ i ) { $ record = 0x00EC ; $ dataChunk = substr ( $ data , $ spOffsets [ $ i - 1 ] , $ spOffsets [ $ i ] - $ spOffsets [ $ i - 1 ] ) ; $ length = strlen ( $ dataChunk ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ dataChunk ) ; $ record = 0x005D ; $ objData = '' ; if ( $ spTypes [ $ i ] == 0x00C9 ) { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0014 , $ i , 0x2101 , 0 , 0 , 0 ) ; $ objData .= pack ( 'vv' , 0x00C , 0x0014 ) ; $ objData .= pack ( 'H*' , '0000000000000000640001000A00000010000100' ) ; $ objData .= pack ( 'vv' , 0x0013 , 0x1FEE ) ; $ objData .= pack ( 'H*' , '00000000010001030000020008005700' ) ; } else { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0008 , $ i , 0x6011 , 0 , 0 , 0 ) ; } $ objData .= pack ( 'vv' , 0x0000 , 0x0000 ) ; $ length = strlen ( $ objData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ objData ) ; } } }
6272	public static function open ( $ fileName ) { return self :: haveExtension ( ) ? new Reader \ DBA ( $ fileName ) : new Reader \ PHP ( $ fileName ) ; }
1522	public function process ( StoreInterface $ store , FetchProcess $ request ) { $ record = $ store -> readRecord ( $ request -> getProcess ( ) , $ request -> getEncodingParameters ( ) ) ; return $ this -> reply ( ) -> process ( $ record ) ; }
10955	protected function redirect ( Response $ response , int $ code , string $ url ) : Response { return $ response -> withStatus ( $ code ) -> withHeader ( 'Location' , $ url ) ; }
11778	public function startAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , ) ; return parent :: start ( $ options ) ; }
5841	public function addRole ( $ role ) { if ( is_string ( $ role ) ) { $ role = new Role ( $ role ) ; } elseif ( ! $ role instanceof RoleInterface ) { throw new \ InvalidArgumentException ( sprintf ( 'Role must be a string or RoleInterface instance, but got %s.' , gettype ( $ role ) ) ) ; } if ( ! \ in_array ( $ role , $ this -> roles ) ) { $ this -> roles [ ] = $ role ; } }
5515	public function expectAtLeastOnce ( $ method , $ args = false , $ message = '%s' ) { $ this -> expectMinimumCallCount ( $ method , 1 , $ message ) ; if ( $ args !== false ) { $ this -> expect ( $ method , $ args , $ message ) ; } }
1409	public function memberRequired ( string $ path , string $ member ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'member_required' , 'code' ) , $ this -> trans ( 'member_required' , 'title' ) , $ this -> trans ( 'member_required' , 'detail' , compact ( 'member' ) ) , $ this -> pointer ( $ path ) ) ; }
2061	public function generateAlias ( $ varValue , Contao \ DataContainer $ dc ) { $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> id ) ; $ aliasExists = function ( string $ alias ) use ( $ dc , $ objPage ) : bool { $ objAliasIds = $ this -> Database -> prepare ( "SELECT id FROM tl_page WHERE alias=? AND id!=?" ) -> execute ( $ alias , $ dc -> id ) ; if ( ! $ objAliasIds -> numRows ) { return false ; } $ strCurrentDomain = $ objPage -> domain ; $ strCurrentLanguage = $ objPage -> rootLanguage ; if ( $ objPage -> type == 'root' ) { $ strCurrentDomain = Contao \ Input :: post ( 'dns' ) ; $ strCurrentLanguage = Contao \ Input :: post ( 'language' ) ; } while ( $ objAliasIds -> next ( ) ) { $ objAliasPage = Contao \ PageModel :: findWithDetails ( $ objAliasIds -> id ) ; if ( $ objAliasPage -> domain != $ strCurrentDomain ) { continue ; } if ( Contao \ Config :: get ( 'addLanguageToUrl' ) && $ objAliasPage -> rootLanguage != $ strCurrentLanguage ) { continue ; } return true ; } return false ; } ; if ( $ varValue == '' ) { $ varValue = Contao \ System :: getContainer ( ) -> get ( 'contao.slug' ) -> generate ( $ dc -> activeRecord -> title , $ dc -> activeRecord -> id , function ( $ alias ) use ( $ objPage , $ aliasExists ) { return $ aliasExists ( ( Contao \ Config :: get ( 'folderUrl' ) ? $ objPage -> folderUrl : '' ) . $ alias ) ; } ) ; if ( Contao \ Config :: get ( 'folderUrl' ) && $ objPage -> folderUrl != '' ) { $ varValue = $ objPage -> folderUrl . $ varValue ; } } elseif ( $ aliasExists ( $ varValue ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
11932	protected function generateOption ( $ key , $ value ) { $ option = new FieldOption ( ) ; $ option -> setKey ( $ key ) ; $ option -> setValue ( $ value ) ; return $ option ; }
1872	protected function convertValuesToPaths ( ) { if ( empty ( $ this -> varValue ) ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } elseif ( empty ( $ this -> varValue [ 0 ] ) ) { $ this -> varValue = array ( ) ; } if ( empty ( $ this -> varValue ) ) { return ; } if ( strpos ( $ this -> varValue [ 0 ] , Config :: get ( 'uploadPath' ) . '/' ) === 0 ) { return ; } if ( Input :: get ( 'switch' ) ) { return ; } if ( $ this -> path != '' && strpos ( $ this -> path , Config :: get ( 'uploadPath' ) . '/' ) !== 0 ) { return ; } $ objFiles = FilesModel :: findMultipleByIds ( $ this -> varValue ) ; if ( $ objFiles !== null ) { $ this -> varValue = array_values ( $ objFiles -> fetchEach ( 'path' ) ) ; } }
4912	public function setVariables ( $ variables , $ overwrite = false ) { if ( ! is_array ( $ variables ) && ! $ variables instanceof \ Traversable ) { throw new \ InvalidArgumentException ( sprintf ( '%s: expects an array, or Traversable argument; received "%s"' , __METHOD__ , ( is_object ( $ variables ) ? get_class ( $ variables ) : gettype ( $ variables ) ) ) ) ; } if ( $ overwrite ) { if ( is_object ( $ variables ) && ! $ variables instanceof \ ArrayAccess ) { $ variables = ArrayUtils :: iteratorToArray ( $ variables ) ; } $ this -> variables = $ variables ; return $ this ; } foreach ( $ variables as $ key => $ value ) { $ this -> setVariable ( $ key , $ value ) ; } return $ this ; }
3557	protected function setType ( $ value ) { $ this -> attributes [ 'meta_type' ] = $ this -> hasMutator ( $ value , 'setter' ) ? $ this -> getMutatedType ( $ value , 'setter' ) : $ this -> getValueType ( $ value ) ; }
5196	public function addSearchResult ( $ index , $ type , array $ documents ) { $ result = [ 'took' => 5 , 'timed_out' => false , '_shards' => [ 'total' => 5 , 'successful' => 5 , 'failed' => 0 ] , 'hits' => [ 'total' => count ( $ documents ) , 'max_score' => 1 , 'hits' => [ ] ] ] ; foreach ( $ documents as $ document ) { $ result [ 'hits' ] [ 'hits' ] [ ] = [ '_index' => $ index , '_type' => $ type , '_id' => $ document [ 'id' ] , '_score' => 1 , '_source' => $ document ] ; } return $ this -> addResult ( 'search' , $ result ) ; }
3665	private function convertParameterAggregate ( $ var , $ arguments ) { $ var = ( array ) $ var ; if ( ! empty ( $ arguments [ 'recursive' ] ) ) { $ var = iterator_to_array ( new \ RecursiveIteratorIterator ( new \ RecursiveArrayIterator ( $ var ) ) ) ; } if ( ! $ var ) { return 'NULL' ; } if ( ! empty ( $ arguments [ 'key' ] ) ) { $ var = array_keys ( $ var ) ; } else { $ var = array_values ( $ var ) ; } if ( $ arguments [ 'aggregate' ] == 'set' ) { $ this -> addParameter ( implode ( ',' , $ var ) ) ; return '?' ; } $ this -> addParameters ( $ var ) ; return rtrim ( str_repeat ( '?,' , count ( $ var ) ) , ',' ) ; }
9671	private function writeCellStyleDxf ( XMLWriter $ objWriter , \ PhpOffice \ PhpSpreadsheet \ Style \ Style $ pStyle ) { $ objWriter -> startElement ( 'dxf' ) ; $ this -> writeFont ( $ objWriter , $ pStyle -> getFont ( ) ) ; $ this -> writeNumFmt ( $ objWriter , $ pStyle -> getNumberFormat ( ) ) ; $ this -> writeFill ( $ objWriter , $ pStyle -> getFill ( ) ) ; $ objWriter -> startElement ( 'alignment' ) ; if ( $ pStyle -> getAlignment ( ) -> getHorizontal ( ) !== null ) { $ objWriter -> writeAttribute ( 'horizontal' , $ pStyle -> getAlignment ( ) -> getHorizontal ( ) ) ; } if ( $ pStyle -> getAlignment ( ) -> getVertical ( ) !== null ) { $ objWriter -> writeAttribute ( 'vertical' , $ pStyle -> getAlignment ( ) -> getVertical ( ) ) ; } if ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) !== null ) { $ textRotation = 0 ; if ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) >= 0 ) { $ textRotation = $ pStyle -> getAlignment ( ) -> getTextRotation ( ) ; } elseif ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) < 0 ) { $ textRotation = 90 - $ pStyle -> getAlignment ( ) -> getTextRotation ( ) ; } $ objWriter -> writeAttribute ( 'textRotation' , $ textRotation ) ; } $ objWriter -> endElement ( ) ; $ this -> writeBorder ( $ objWriter , $ pStyle -> getBorders ( ) ) ; if ( ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== null ) || ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== null ) ) { if ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== Protection :: PROTECTION_INHERIT || $ pStyle -> getProtection ( ) -> getHidden ( ) !== Protection :: PROTECTION_INHERIT ) { $ objWriter -> startElement ( 'protection' ) ; if ( ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== null ) && ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== Protection :: PROTECTION_INHERIT ) ) { $ objWriter -> writeAttribute ( 'locked' , ( $ pStyle -> getProtection ( ) -> getLocked ( ) == Protection :: PROTECTION_PROTECTED ? 'true' : 'false' ) ) ; } if ( ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== null ) && ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== Protection :: PROTECTION_INHERIT ) ) { $ objWriter -> writeAttribute ( 'hidden' , ( $ pStyle -> getProtection ( ) -> getHidden ( ) == Protection :: PROTECTION_PROTECTED ? 'true' : 'false' ) ) ; } $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; }
8536	public function setRentalChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3006	static public function jump ( \ Base $ f3 , $ params ) { $ target = $ f3 -> get ( 'GET.target' ) ; if ( $ f3 -> exists ( 'mailer.on.jump' , $ jump_handler ) ) $ f3 -> call ( $ jump_handler , array ( $ target , $ params ) ) ; $ f3 -> reroute ( urldecode ( $ target ) ) ; }
1672	public function protect ( ) { if ( ! $ this -> isUnprotected ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.public' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot protect folder "%s" because one of its parent folders is public' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.public' ) ) -> delete ( ) ; }
8540	public function setmember ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'member' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4964	public function addViewVariables ( $ name , $ data = [ ] , $ priority = 0 ) { if ( is_array ( $ name ) ) { if ( ! isset ( $ name [ 'name' ] ) ) { throw new \ DomainException ( 'Key "name" must be specified, if array is passed as first parameter.' ) ; } if ( is_int ( $ data ) ) { $ priority = $ data ; } $ data = $ name ; $ name = $ data [ 'name' ] ; } elseif ( is_int ( $ data ) ) { $ priority = $ data ; $ data = [ ] ; } if ( ! isset ( $ data [ 'name' ] ) ) { $ data [ 'name' ] = $ name ; } return $ this -> addViewTemplate ( $ name , "core/admin/dashboard-widget" , $ data , $ priority ) ; }
12868	public function resetPassword ( Token $ token ) { if ( ! $ this -> validate ( ) || $ token -> user === null ) { return false ; } if ( $ token -> user -> resetPassword ( $ this -> password ) ) { \ Yii :: $ app -> session -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Your password has been changed successfully.' ) ) ; $ token -> delete ( ) ; } else { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'An error occurred and your password has not been changed. Please try again later.' ) ) ; } return true ; }
889	private function shouldClearToken ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; return ! $ token -> isComment ( ) && ! ( $ token -> isWhitespace ( ) && $ tokens [ $ index + 1 ] -> isComment ( ) ) ; }
7842	public function handle ( $ job , Closure $ next ) { $ this -> callBefore ( $ job ) ; $ handled = $ next ( $ job ) ; $ this -> callAfter ( $ handled , $ job ) ; return $ handled ; }
8976	public static function typeOf ( $ arg ) { if ( null === $ arg ) { return 'NULL' ; } if ( is_object ( $ arg ) ) { return get_class ( $ arg ) ; } return gettype ( $ arg ) ; }
2405	public function minifyHtml ( $ strHtml ) { if ( Config :: get ( 'debugMode' ) ) { return $ strHtml ; } $ arrChunks = preg_split ( '@(</?pre[^>]*>)|(</?script[^>]*>)|(</?style[^>]*>)|( ?</?textarea[^>]*>)@i' , $ strHtml , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; $ strHtml = '' ; $ blnPreserveNext = false ; $ blnOptimizeNext = false ; $ strType = null ; $ isJavaScript = function ( $ strChunk ) { $ typeMatch = array ( ) ; if ( preg_match ( '/\stype\s*=\s*(?:(?J)(["\'])\s*(?<type>.*?)\s*\1|(?<type>[^\s>]+))/i' , $ strChunk , $ typeMatch ) && ! \ in_array ( strtolower ( $ typeMatch [ 'type' ] ) , static :: $ validJavaScriptTypes ) ) { return false ; } if ( preg_match ( '/\slanguage\s*=\s*(?:(?J)(["\'])\s*(?<type>.*?)\s*\1|(?<type>[^\s>]+))/i' , $ strChunk , $ typeMatch ) && ! \ in_array ( 'text/' . strtolower ( $ typeMatch [ 'type' ] ) , static :: $ validJavaScriptTypes ) ) { return false ; } return true ; } ; foreach ( $ arrChunks as $ strChunk ) { if ( strncasecmp ( $ strChunk , '<pre' , 4 ) === 0 || strncasecmp ( ltrim ( $ strChunk ) , '<textarea' , 9 ) === 0 ) { $ blnPreserveNext = true ; } elseif ( strncasecmp ( $ strChunk , '<script' , 7 ) === 0 ) { if ( $ isJavaScript ( $ strChunk ) ) { $ blnOptimizeNext = true ; $ strType = 'js' ; } else { $ blnPreserveNext = true ; } } elseif ( strncasecmp ( $ strChunk , '<style' , 6 ) === 0 ) { $ blnOptimizeNext = true ; $ strType = 'css' ; } elseif ( $ blnPreserveNext ) { $ blnPreserveNext = false ; } elseif ( $ blnOptimizeNext ) { $ blnOptimizeNext = false ; if ( $ strType == 'js' ) { $ objMinify = new Minify \ JS ( ) ; $ objMinify -> add ( $ strChunk ) ; $ strChunk = $ objMinify -> minify ( ) ; } elseif ( $ strType == 'css' ) { $ objMinify = new Minify \ CSS ( ) ; $ objMinify -> add ( $ strChunk ) ; $ strChunk = $ objMinify -> minify ( ) ; } } else { $ strChunk = str_replace ( "\r" , '' , $ strChunk ) ; $ strChunk = preg_replace ( array ( '/^[\t ]+/m' , '/[\t ]+$/m' , '/\n\n+/' ) , array ( '' , '' , "\n" ) , $ strChunk ) ; } $ strHtml .= $ strChunk ; } return trim ( $ strHtml ) ; }
3464	public function get ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: get ( $ route ) ) ; }
4800	function via ( $ column ) { $ this -> column = $ column ; $ this -> conditions [ 0 ] = "$this->table.$column AND" ; $ this -> where [ 0 ] = "(" . $ this -> whereIn ( "$this->table.$column" , array_keys ( ( array ) $ this -> result -> rows ) ) . ")" ; return $ this ; }
10190	public function getAllSpContainers ( ) { $ allSpContainers = [ ] ; foreach ( $ this -> children as $ child ) { if ( $ child instanceof self ) { $ allSpContainers = array_merge ( $ allSpContainers , $ child -> getAllSpContainers ( ) ) ; } else { $ allSpContainers [ ] = $ child ; } } return $ allSpContainers ; }
3473	public function set ( string $ key , $ value ) : void { $ key = explode ( '.' , $ key ) ; $ last = array_pop ( $ key ) ; $ result = & $ this -> config ; foreach ( $ key as $ part ) { if ( ! isset ( $ result [ $ part ] ) || ! is_array ( $ result [ $ part ] ) ) { $ result [ $ part ] = [ ] ; } $ result = & $ result [ $ part ] ; } $ result [ $ last ] = $ value ; }
3163	public function startTimer ( RunnerServiceContext $ context , $ timestamp = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INTERACTING ) { $ session -> startItemTimer ( $ timestamp ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'startTimer' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
3411	public function format ( ) : string { foreach ( $ this -> times as $ unit => $ value ) { if ( $ this -> time >= $ value ) { $ time = floor ( $ this -> time / $ value * 100 ) / 100 ; return "{$time} {$unit}" ; } } return round ( $ this -> time * 1000 ) . " ms" ; }
6857	protected static function equinoxSeptember ( $ year , $ vsop = true ) { $ month = 9 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
4512	public function kernelView ( GetResponseForControllerResultEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( ! $ request -> query -> has ( 'locale' ) ) { return ; } $ controllerResult = $ event -> getControllerResult ( ) ; $ locale = $ request -> query -> get ( 'locale' ) ; if ( $ controllerResult instanceof Paginator || is_array ( $ controllerResult ) ) { foreach ( $ controllerResult as $ model ) { if ( $ model instanceof Localizable ) { $ this -> localeService -> localize ( $ model , $ locale ) ; } } } elseif ( $ controllerResult instanceof Localizable ) { $ this -> localeService -> localize ( $ controllerResult , $ locale ) ; } $ event -> setControllerResult ( $ controllerResult ) ; }
10650	private function getValidator ( $ scope = 'create' ) { $ rules = $ this -> buildValidationRules ( $ scope ) ; $ custom_messages = $ this -> buildMessages ( $ scope ) ; $ validation_values = $ this -> buildValidationValues ( ) ; return Validator :: make ( $ validation_values , $ rules , $ custom_messages ) ; }
4534	public function setCandidateGroup ( ? string $ candidateGroup ) { $ this -> candidateGroup = $ candidateGroup ; $ this -> _candidateGroup = null !== $ candidateGroup ; return $ this ; }
8869	public function attach ( Runner $ runner ) { if ( $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t attach already attached runner.' ) ; } $ this -> runners -> attach ( $ runner ) ; return $ this ; }
12803	public function getADORecordSet ( ) { if ( ! $ this -> sql ) { throw new Exception ( 'Web2All_Table_Collection_SimpleDataProvider::getADORecordSet: no SQL query set' ) ; } return $ this -> db -> SelectLimit ( $ this -> sql , $ this -> limit , $ this -> offset , $ this -> params ) ; }
10712	public function create ( array $ attributes = [ ] ) { $ model = $ this -> newModel ( ) ; $ model -> fill ( $ attributes ) ; $ this -> save ( $ model ) ; return $ model ; }
588	protected function adjustDependency ( $ targets , $ bundles ) { $ this -> stdout ( "Creating new bundle configuration...\n" ) ; $ map = [ ] ; foreach ( $ targets as $ name => $ target ) { foreach ( $ target -> depends as $ bundle ) { $ map [ $ bundle ] = $ name ; } } foreach ( $ targets as $ name => $ target ) { $ depends = [ ] ; foreach ( $ target -> depends as $ bn ) { foreach ( $ bundles [ $ bn ] -> depends as $ bundle ) { $ depends [ $ map [ $ bundle ] ] = true ; } } unset ( $ depends [ $ name ] ) ; $ target -> depends = array_keys ( $ depends ) ; } foreach ( $ targets as $ name => $ target ) { $ registered = [ ] ; $ this -> registerBundle ( $ targets , $ name , $ registered ) ; } foreach ( $ map as $ bundle => $ target ) { $ sourceBundle = $ bundles [ $ bundle ] ; $ depends = $ sourceBundle -> depends ; if ( ! $ this -> isBundleExternal ( $ sourceBundle ) ) { $ depends [ ] = $ target ; } $ targetBundle = clone $ sourceBundle ; $ targetBundle -> depends = $ depends ; $ targets [ $ bundle ] = $ targetBundle ; } return $ targets ; }
4456	protected function fetchQueue ( string $ eventName ) : SplPriorityQueue { if ( isset ( $ this -> events [ $ eventName ] ) == false ) { $ this -> events [ $ eventName ] = $ this -> createQueue ( ) ; } return $ this -> events [ $ eventName ] ; }
65	public function normalizePath ( $ path ) { $ parts = array ( ) ; $ path = strtr ( $ path , '\\' , '/' ) ; $ prefix = '' ; $ absolute = false ; if ( preg_match ( '{^( [0-9a-z]{2,}+: (?: // (?: [a-z]: )? )? | [a-z]: )}ix' , $ path , $ match ) ) { $ prefix = $ match [ 1 ] ; $ path = substr ( $ path , strlen ( $ prefix ) ) ; } if ( substr ( $ path , 0 , 1 ) === '/' ) { $ absolute = true ; $ path = substr ( $ path , 1 ) ; } $ up = false ; foreach ( explode ( '/' , $ path ) as $ chunk ) { if ( '..' === $ chunk && ( $ absolute || $ up ) ) { array_pop ( $ parts ) ; $ up = ! ( empty ( $ parts ) || '..' === end ( $ parts ) ) ; } elseif ( '.' !== $ chunk && '' !== $ chunk ) { $ parts [ ] = $ chunk ; $ up = '..' !== $ chunk ; } } return $ prefix . ( $ absolute ? '/' : '' ) . implode ( '/' , $ parts ) ; }
7479	public function getContent ( ) { $ this -> absolute ( ) ; if ( ! is_file ( $ this -> data ) ) { Exception :: i ( ) -> setMessage ( self :: ERROR_PATH_IS_NOT_FILE ) -> addVariable ( $ this -> data ) -> trigger ( ) ; } return file_get_contents ( $ this -> data ) ; }
368	public function renderTableBody ( ) { $ models = array_values ( $ this -> dataProvider -> getModels ( ) ) ; $ keys = $ this -> dataProvider -> getKeys ( ) ; $ rows = [ ] ; foreach ( $ models as $ index => $ model ) { $ key = $ keys [ $ index ] ; if ( $ this -> beforeRow !== null ) { $ row = call_user_func ( $ this -> beforeRow , $ model , $ key , $ index , $ this ) ; if ( ! empty ( $ row ) ) { $ rows [ ] = $ row ; } } $ rows [ ] = $ this -> renderTableRow ( $ model , $ key , $ index ) ; if ( $ this -> afterRow !== null ) { $ row = call_user_func ( $ this -> afterRow , $ model , $ key , $ index , $ this ) ; if ( ! empty ( $ row ) ) { $ rows [ ] = $ row ; } } } if ( empty ( $ rows ) && $ this -> emptyText !== false ) { $ colspan = count ( $ this -> columns ) ; return "<tbody>\n<tr><td colspan=\"$colspan\">" . $ this -> renderEmpty ( ) . "</td></tr>\n</tbody>" ; } return "<tbody>\n" . implode ( "\n" , $ rows ) . "\n</tbody>" ; }
9215	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { $ post [ 'StaticPage' ] [ 'tags' ] = implode ( "," , $ post [ 'StaticPage' ] [ 'tags' ] ) ; } } if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; } }
3124	protected function fixRange ( $ range , $ lastTimestamp = null ) { $ fixedRange = [ ] ; $ last = null ; $ open = false ; foreach ( $ range as $ point ) { if ( $ this -> isStartPoint ( $ point ) ) { if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ point , TimePoint :: TYPE_END ) ; } $ open = true ; } else if ( $ this -> isEndPoint ( $ point ) ) { if ( ! $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last ? $ last : $ point , TimePoint :: TYPE_START ) ; } $ open = false ; } $ fixedRange [ ] = $ point ; $ last = $ point ; } if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last , TimePoint :: TYPE_END , $ lastTimestamp ) ; } return $ fixedRange ; }
4452	public function stats ( ? int $ date = null ) : array { $ date = $ date ? : time ( ) ; return json_decode ( $ this -> client -> stats ( $ this -> name , $ date ) , true ) ; }
8968	protected function load ( ) { $ this -> rates = array ( ) ; $ this -> latest = array ( ) ; $ handle = fopen ( $ this -> pathToFile , 'rb' ) ; if ( ! $ handle ) { throw new RuntimeException ( sprintf ( 'Error opening file on path "%s".' , $ this -> pathToFile ) ) ; } while ( ( $ line = fgets ( $ handle ) ) !== false ) { $ rate = $ this -> fromJson ( $ line ) ; $ this -> rates [ $ this -> getRateKey ( $ rate -> getCurrencyCode ( ) , $ rate -> getDate ( ) , $ rate -> getRateType ( ) , $ rate -> getSourceName ( ) ) ] = $ rate ; $ latestKey = sprintf ( '%s_%s_%s' , $ rate -> getCurrencyCode ( ) , $ rate -> getRateType ( ) , $ rate -> getSourceName ( ) ) ; if ( ! isset ( $ this -> latest [ $ latestKey ] ) || ( $ this -> latest [ $ latestKey ] -> getDate ( ) < $ rate -> getDate ( ) ) ) { $ this -> latest [ $ latestKey ] = $ rate ; } } fclose ( $ handle ) ; return $ this -> rates ; }
9150	public function fetchAll ( $ columns = null , \ Closure $ Closure = null ) { $ select = $ this -> getSelect ( ) ; if ( $ columns ) { $ select -> columns ( $ columns ) ; } if ( $ Closure ) { $ Closure ( $ select ) ; } return $ this -> select ( $ select ) ; }
2494	protected function escapeExpressions ( $ string , $ allowWildcard = false ) { if ( $ allowWildcard ) { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~?:\\ ' ) ; } else { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~*?:\\ ' ) ; } return preg_replace_callback ( '/([' . $ reservedCharacters . '])/' , function ( $ matches ) { return '\\' . $ matches [ 0 ] ; } , $ string ) ; }
6034	public function setMimeType ( $ mimeType ) { if ( $ mimeType instanceof MimeType ) { $ this -> mimeType = $ mimeType ; } elseif ( is_array ( $ mimeType ) ) { $ this -> mimeType = new MimeType ( $ mimeType ) ; } else { $ this -> mimeType = null ; trigger_error ( 'Argument must be an object of class MimeType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
4380	protected function visualWhiteSpace ( $ str ) { $ str = \ preg_replace_callback ( '/(\r\n|\r|\n)/' , array ( $ this , 'visualWhiteSpaceCallback' ) , $ str ) ; $ str = \ preg_replace ( '#(<br />)?\n$#' , '' , $ str ) ; $ str = \ str_replace ( "\t" , '<span class="ws_t">' . "\t" . '</span>' , $ str ) ; return $ str ; }
11416	private function saveLog ( $ operId , $ calcId ) { $ entity = new ELogOper ( ) ; $ entity -> setOperId ( $ operId ) ; $ entity -> setCalcId ( $ calcId ) ; $ this -> daoLogOper -> create ( $ entity ) ; }
4264	protected function doPublish ( $ eventName , $ subscribers , Event $ event ) { foreach ( $ subscribers as $ callable ) { if ( $ event -> isPropagationStopped ( ) ) { break ; } \ call_user_func ( $ callable , $ event , $ eventName , $ this ) ; } }
10926	private function renderCell ( $ columnNumber , $ value , $ filler , $ style = '' ) { $ output = [ ] ; $ width = $ this -> getWidth ( $ columnNumber ) ; $ output [ ] = $ filler ; while ( $ this -> length ( $ value ) < $ width ) { $ value .= $ filler ; } $ output [ ] = Style :: applyStyle ( $ value , $ style ) ; $ output [ ] = $ filler ; return implode ( '' , $ output ) ; }
3287	public function plugin ( $ name , array $ options = null ) { $ helper = $ this -> getTwigHelpers ( ) -> setRenderer ( $ this ) ; if ( $ helper -> has ( $ name ) ) { return $ helper -> get ( $ name , $ options ) ; } return $ this -> getHelperPluginManager ( ) -> get ( $ name , $ options ) ; }
6173	public function read ( $ path , $ file ) { return $ this -> driver -> read ( $ this -> root . $ path , $ file ) ; }
1511	public function getRelationshipUri ( string $ type , $ id , string $ field , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id , 'relationships' , $ field ] , $ params ) ; }
6548	public function current ( ) { $ sheet = $ this -> iterator -> current ( ) ; return new \ Aimeos \ MW \ Container \ Content \ PHPExcel ( $ sheet , $ sheet -> getTitle ( ) , $ this -> getOptions ( ) ) ; }
7152	public function copy ( SubjectIdentity $ identity ) { $ this -> provider = $ identity -> getProvider ( ) ; $ this -> identifier = $ identity -> getIdentifier ( ) ; }
8115	public function advanceReviewDate ( ) { $ nextDateTimestamp = false ; $ options = $ this -> getOptions ( ) ; if ( $ options && $ options -> ReviewPeriodDays ) { $ nextDateTimestamp = strtotime ( ' + ' . $ options -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ this -> owner -> NextReviewDate = DBDate :: create ( ) -> setValue ( $ nextDateTimestamp ) -> Format ( DBDate :: ISO_DATE ) ; $ this -> owner -> write ( ) ; } return ( bool ) $ nextDateTimestamp ; }
6878	private function getRevenueQuery ( ) { if ( null !== $ this -> revenueQuery ) { return $ this -> revenueQuery ; } $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ expr = $ qb -> expr ( ) ; return $ this -> revenueQuery = $ qb -> select ( [ 'o.date' , 'o.revenue' , 'o.details' ] ) -> andWhere ( $ expr -> eq ( 'o.type' , ':type' ) ) -> andWhere ( $ expr -> gte ( 'o.date' , ':from' ) ) -> andWhere ( $ expr -> lte ( 'o.date' , ':to' ) ) -> addOrderBy ( 'o.date' ) -> getQuery ( ) ; }
11303	protected static function checkPath ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new NotFoundException ( Message :: get ( Message :: MSG_PATH_NOTFOUND , $ path ) , Message :: MSG_PATH_NOTFOUND ) ; } if ( ! is_readable ( $ path ) ) { throw new RuntimeException ( Message :: get ( Message :: MSG_PATH_NONREADABLE , $ path ) , Message :: MSG_PATH_NONREADABLE ) ; } }
1556	protected function queryRulesWithoutSearch ( ) { return collect ( $ this -> queryRules ( ) ) -> reject ( function ( $ value , $ key ) { return Str :: startsWith ( $ key , [ 'filter.' , 'sort.' , 'page.' ] ) ; } ) -> all ( ) ; }
12302	public function getChild ( $ id , $ relation , $ idChild , $ filters = null ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } if ( count ( $ filters -> request -> all ( ) ) > 0 ) { $ child = $ parent -> $ relation ( ) -> getRelated ( ) ; $ search = new Search ( $ child , $ filters , $ parent -> $ relation ( ) ) ; $ this -> builder = $ search -> getBuilder ( ) ; $ this -> builder -> select ( "{$child->getTable()}.*" ) ; if ( $ parent -> $ relation ( ) instanceof \ Illuminate \ Database \ Eloquent \ Relations \ BelongsToMany ) { $ this -> builder -> where ( $ parent -> $ relation ( ) -> getOtherKey ( ) , $ idChild ) ; } $ resource = $ this -> builder -> get ( ) ; } else { $ resource = $ parent -> $ relation ( ) -> find ( $ idChild ) ; } return $ resource ; }
12932	protected function generateContentAttribute ( $ name , $ value , $ type = 'text' ) { $ attribute = new ContentAttribute ( ) ; $ attribute -> setName ( $ name ) ; $ attribute -> setValue ( $ value ) ; if ( is_array ( $ value ) ) { $ value = '' ; } $ attribute -> setStringValue ( $ value ) ; $ attribute -> setType ( $ type ) ; return $ attribute ; }
10102	public function writeUrlInternal ( $ row1 , $ col1 , $ row2 , $ col2 , $ url ) { $ record = 0x01B8 ; $ length = 0x00000 ; $ url = preg_replace ( '/^internal:/' , '' , $ url ) ; $ unknown1 = pack ( 'H*' , 'D0C9EA79F9BACE118C8200AA004BA90B02000000' ) ; $ options = pack ( 'V' , 0x08 ) ; $ url .= "\0" ; $ url_len = StringHelper :: countCharacters ( $ url ) ; $ url_len = pack ( 'V' , $ url_len ) ; $ url = StringHelper :: convertEncoding ( $ url , 'UTF-16LE' , 'UTF-8' ) ; $ length = 0x24 + strlen ( $ url ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ row1 , $ row2 , $ col1 , $ col2 ) ; $ this -> append ( $ header . $ data . $ unknown1 . $ options . $ url_len . $ url ) ; return 0 ; }
7040	protected function hasDifferentCurrencies ( PaymentSubjectInterface $ subject ) { $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getCurrency ( ) -> getCode ( ) !== $ currency ) { return true ; } } return false ; }
2792	public function get ( $ option ) { if ( ! array_key_exists ( $ option , $ this -> inputOptions ) ) { throw new \ InvalidArgumentException ( 'Option "' . $ option . ' not exists' ) ; } return $ this -> inputOptions [ $ option ] ; }
1446	protected function dataForUpdate ( $ record , array $ document ) : array { $ resource = $ document [ 'data' ] ?? [ ] ; if ( $ this -> mustValidateExisting ( $ record , $ document ) ) { $ resource [ 'attributes' ] = $ this -> extractAttributes ( $ record , $ resource [ 'attributes' ] ?? [ ] ) ; $ resource [ 'relationships' ] = $ this -> extractRelationships ( $ record , $ resource [ 'relationships' ] ?? [ ] ) ; } return $ resource ; }
7049	protected function buildGoodsLines ( Document \ DocumentInterface $ document ) { foreach ( $ document -> getSale ( ) -> getItems ( ) as $ item ) { $ this -> buildGoodLine ( $ item , $ document ) ; } }
10908	public function instance ( object $ object ) : Binding { if ( ! $ object instanceof $ this -> definition -> typeName ) { throw new \ InvalidArgumentException ( \ sprintf ( '%s is not an instance of %s' , \ get_class ( $ object ) , $ this -> definition -> typeName ) ) ; } $ this -> definition -> instantiator = new Instance ( $ object ) ; return $ this ; }
10909	public function inject ( string ... $ methods ) : Binding { if ( $ this -> definition -> injects === null ) { $ this -> definition -> injects = \ array_fill_keys ( $ methods , true ) ; } else { foreach ( $ methods as $ f ) { $ this -> definition -> injects [ $ f ] = true ; } } return $ this ; }
731	protected function getUniqueIndexInformation ( $ table ) { $ sql = <<<'SQL'SELECT i.relname as indexname, pg_get_indexdef(idx.indexrelid, k + 1, TRUE) AS columnnameFROM ( SELECT *, generate_subscripts(indkey, 1) AS k FROM pg_index) idxINNER JOIN pg_class i ON i.oid = idx.indexrelidINNER JOIN pg_class c ON c.oid = idx.indrelidINNER JOIN pg_namespace ns ON c.relnamespace = ns.oidWHERE idx.indisprimary = FALSE AND idx.indisunique = TRUEAND c.relname = :tableName AND ns.nspname = :schemaNameORDER BY i.relname, kSQL ; return $ this -> db -> createCommand ( $ sql , [ ':schemaName' => $ table -> schemaName , ':tableName' => $ table -> name , ] ) -> queryAll ( ) ; }
6019	public function removeSite ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/deployment/' . $ id . '' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
2781	public function getCommandLine ( ) { if ( $ this -> executeRaw ) { return $ this -> getCommand ( ) ; } $ command = array_merge ( [ $ this -> getCommand ( ) ] , $ this -> buildOptions ( ) , $ this -> args ) ; return array_filter ( $ command , 'strlen' ) ; }
8121	public function ReviewContentForm ( HTTPRequest $ request ) { $ id = $ request -> param ( 'ID' ) ? : $ request -> postVar ( 'ID' ) ; return $ this -> getReviewContentForm ( $ id ) ; }
7108	static public function getPrecision ( $ currency ) { if ( isset ( static :: $ precisions [ $ currency ] ) ) { return static :: $ precisions [ $ currency ] ; } return static :: $ precisions [ $ currency ] = static :: getCurrencyBundle ( ) -> getFractionDigits ( $ currency ) ; }
10767	public static function normalizeAccountNumber ( $ account ) { $ account = str_replace ( ' ' , '' , $ account ) ; if ( false === strpos ( $ account , '-' ) ) { $ account = '000000-' . $ account ; } $ parts = explode ( '-' , $ account ) ; $ parts [ 0 ] = str_pad ( $ parts [ 0 ] , 6 , '0' , STR_PAD_LEFT ) ; $ parts2 = explode ( '/' , $ parts [ 1 ] ) ; $ parts2 [ 0 ] = str_pad ( $ parts2 [ 0 ] , 10 , '0' , STR_PAD_LEFT ) ; $ parts2 [ 1 ] = str_pad ( $ parts2 [ 1 ] , 4 , '0' , STR_PAD_LEFT ) ; $ parts [ 1 ] = implode ( '/' , $ parts2 ) ; return implode ( '-' , $ parts ) ; }
9293	protected function getAssetsUrl ( ) { if ( ! isset ( $ this -> _assetsUrl ) ) { $ path = dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'assets' ; $ this -> _assetsUrl = Yii :: app ( ) -> assetManager -> publish ( $ path , false , - 1 , $ this -> forceCopyAssets ) ; } return $ this -> _assetsUrl ; }
11254	public function drop ( ) : array { $ touched = [ ] ; $ this -> pdo -> beginTransaction ( ) ; foreach ( $ this -> getViews ( ) as $ view ) { $ this -> pdo -> exec ( "drop view if exists {$view} cascade" ) ; $ touched [ ] = [ 'view' , $ view ] ; } foreach ( $ this -> getTables ( ) as $ table ) { $ this -> pdo -> exec ( "drop table if exists {$table} cascade" ) ; $ touched [ ] = [ 'table' , $ table ] ; } $ this -> pdo -> commit ( ) ; return $ touched ; }
1042	private function printBlockString ( $ value , $ isDescription ) { $ escaped = str_replace ( '"""' , '\\"""' , $ value ) ; return ( $ value [ 0 ] === ' ' || $ value [ 0 ] === "\t" ) && strpos ( $ value , "\n" ) === false ? ( '"""' . preg_replace ( '/"$/' , "\"\n" , $ escaped ) . '"""' ) : ( '"""' . "\n" . ( $ isDescription ? $ escaped : $ this -> indent ( $ escaped ) ) . "\n" . '"""' ) ; }
3924	public function getValueOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ options = $ this -> getOptionsViaDcGeneral ( $ metaModel , $ event -> getEnvironment ( ) , $ attribute ) ; $ mangled = [ ] ; foreach ( ( array ) $ options as $ key => $ option ) { $ mangled [ 'value_' . $ key ] = $ option ; } $ event -> setOptions ( $ mangled ) ; } }
2987	public function addResource ( $ bundle , $ format , $ prefix = '/' , $ path = 'routing' ) { $ current = '' ; $ code = sprintf ( "%s:\n" , $ this -> getImportedResourceYamlKey ( $ bundle , $ prefix ) ) ; if ( file_exists ( $ this -> file ) ) { $ current = file_get_contents ( $ this -> file ) ; if ( false !== strpos ( $ current , '@' . $ bundle ) ) { throw new \ RuntimeException ( sprintf ( 'Bundle "%s" is already imported.' , $ bundle ) ) ; } } elseif ( ! is_dir ( $ dir = dirname ( $ this -> file ) ) ) { Generator :: mkdir ( $ dir ) ; } if ( 'annotation' == $ format ) { $ code .= sprintf ( " resource: \"@%s/Controller/\"\n type: annotation\n" , $ bundle ) ; } else { $ code .= sprintf ( " resource: \"@%s/Resources/config/%s.%s\"\n" , $ bundle , $ path , $ format ) ; } $ code .= sprintf ( " prefix: %s\n" , $ prefix ) ; $ code .= "\n" ; $ code .= $ current ; if ( false === Generator :: dump ( $ this -> file , $ code ) ) { return false ; } return true ; }
12746	protected function onMovedResponse ( CommandInterface $ command , $ details ) { list ( $ slot , $ connectionID ) = explode ( ' ' , $ details , 2 ) ; if ( ! $ connection = $ this -> getConnectionById ( $ connectionID ) ) { $ connection = $ this -> createConnection ( $ connectionID ) ; } if ( $ this -> useClusterSlots ) { $ this -> askSlotMap ( $ connection ) ; } $ this -> move ( $ connection , $ slot ) ; $ response = $ this -> executeCommand ( $ command ) ; return $ response ; }
12333	private function _checkBlackListIps ( ) : bool { $ oSecurity = Config :: get ( 'security' ) ; if ( isset ( $ oSecurity -> blacklist_ips ) ) { foreach ( $ oSecurity -> blacklist_ips as $ sIp ) { if ( $ _SERVER [ 'REMOTE_ADDR' ] == $ sIp ) { return false ; } } } return true ; }
8683	public static function from ( $ iterable ) { if ( is_array ( $ iterable ) ) { return $ iterable ; } if ( $ iterable instanceof ImmutableBag ) { return $ iterable -> toArray ( ) ; } if ( $ iterable instanceof Traversable ) { return iterator_to_array ( $ iterable ) ; } if ( $ iterable === null ) { return [ ] ; } if ( $ iterable instanceof \ stdClass ) { return ( array ) $ iterable ; } Assert :: nullOrIsIterable ( $ iterable ) ; }
2568	protected function checkAllIntegers ( ) { $ foundNonInt = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! is_int ( $ arg ) ) { $ foundNonInt = true ; break ; } } return ! $ foundNonInt ; }
7940	public function setBackupFTPaccessBlock ( $ domain , $ ipBlock , $ ftp , $ nfs , $ cifs ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; if ( ! $ ftp ) throw new BadMethodCallException ( 'Parameter $ftp is missing.' ) ; if ( ! $ nfs ) throw new BadMethodCallException ( 'Parameter $nfs is missing.' ) ; if ( ! $ cifs ) throw new BadMethodCallException ( 'Parameter $cifs is missing.' ) ; $ payload = array ( 'ftp' => ( $ ftp == 'on' ) , 'nfs' => ( $ nfs == 'on' ) , 'cifs' => ( $ cifs == 'on' ) ) ; try { $ r = $ this -> put ( 'dedicated/server/' . $ domain . '/features/backupFTP/access/' . urlencode ( $ ipBlock ) , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
10900	public function validate ( string $ method = 'save' ) : array { $ errors = [ ] ; foreach ( $ this -> getValidators ( ) [ $ method ] ?? [ ] as $ field => $ validator ) { try { $ validator -> setName ( $ field ) -> assert ( $ this -> get ( $ field ) ) ; } catch ( NestedValidationException $ e ) { $ errors [ $ field ] = $ e -> getMessages ( ) ; } } return $ errors ; }
2017	protected function resizeUploadedImage ( $ strImage ) { if ( Config :: get ( 'imageWidth' ) < 1 && Config :: get ( 'imageHeight' ) < 1 ) { return false ; } $ objFile = new File ( $ strImage ) ; if ( ! $ objFile -> isSvgImage && ! $ objFile -> isGdImage ) { return false ; } $ arrImageSize = $ objFile -> imageSize ; if ( $ objFile -> isGdImage && ( $ arrImageSize [ 0 ] > Config :: get ( 'gdMaxImgWidth' ) || $ arrImageSize [ 1 ] > Config :: get ( 'gdMaxImgHeight' ) ) ) { Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileExceeds' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" is too big to be resized automatically' , __METHOD__ , TL_FILES ) ; return false ; } $ blnResize = false ; if ( $ arrImageSize [ 0 ] > Config :: get ( 'imageWidth' ) ) { $ blnResize = true ; $ intWidth = Config :: get ( 'imageWidth' ) ; $ intHeight = round ( Config :: get ( 'imageWidth' ) * $ arrImageSize [ 1 ] / $ arrImageSize [ 0 ] ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ arrImageSize [ 1 ] > Config :: get ( 'imageHeight' ) ) { $ blnResize = true ; $ intWidth = round ( Config :: get ( 'imageHeight' ) * $ arrImageSize [ 0 ] / $ arrImageSize [ 1 ] ) ; $ intHeight = Config :: get ( 'imageHeight' ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ blnResize ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; $ container -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ strImage , array ( $ arrImageSize [ 0 ] , $ arrImageSize [ 1 ] ) , $ rootDir . '/' . $ strImage ) ; Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileResized' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" was scaled down to the maximum dimensions' , __METHOD__ , TL_FILES ) ; $ this -> blnHasResized = true ; return true ; } return false ; }
57	public function remove ( PackageInterface $ package , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> remove ( $ package , $ targetDir ) ; } }
2441	public static function urlDecode ( string $ data ) : self { $ decoded = base64_decode ( strtr ( $ data , '-_,' , '+/=' ) , true ) ; if ( \ function_exists ( 'gzdecode' ) && false !== ( $ uncompressed = @ gzdecode ( $ decoded ) ) ) { $ decoded = $ uncompressed ; } $ json = @ json_decode ( $ decoded , true ) ; if ( null === $ json ) { throw new \ InvalidArgumentException ( 'Invalid JSON data' ) ; } return new self ( $ json [ 'context' ] , $ json [ 'extras' ] , $ json [ 'value' ] , $ json [ 'current' ] ) ; }
1005	public function toPsrResponse ( $ result , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { if ( $ result instanceof Promise ) { return $ result -> then ( function ( $ actualResult ) use ( $ response , $ writableBodyStream ) { return $ this -> doConvertToPsrResponse ( $ actualResult , $ response , $ writableBodyStream ) ; } ) ; } return $ this -> doConvertToPsrResponse ( $ result , $ response , $ writableBodyStream ) ; }
9193	public function init ( ) { if ( $ this -> isInitialized ( ) ) return $ this ; if ( ! $ this -> getThemesPath ( ) || ! $ this -> getName ( ) ) throw new \ Exception ( 'Theme Cant initialize because theme name or theme paths not present.' ) ; $ themePathname = $ this -> getThemesPath ( ) . DS . $ this -> getName ( ) ; if ( ! is_dir ( $ themePathname ) ) throw new \ Exception ( sprintf ( 'Theme "%s" not found in "%s".' , $ this -> getName ( ) , $ themePathname ) ) ; $ bootstrap = $ themePathname . DS . 'theme.bootstrap.php' ; if ( file_exists ( $ bootstrap ) ) { ob_start ( ) ; set_error_handler ( function ( $ errno , $ errstr ) { throw new \ ErrorException ( $ errstr , $ errno ) ; } , E_ALL ) ; include $ bootstrap ; restore_error_handler ( ) ; ob_get_clean ( ) ; } $ this -> initialized = true ; return $ this ; }
8224	protected function logRateLimitReached ( $ actionName , $ blockType , $ entityId , $ config ) { $ this -> getLogger ( ) -> notice ( "Rate limit of {cnt} reached: {action} for {entity} ({type})." , array ( 'cnt' => $ config [ "count" ] , 'action' => $ actionName , 'entity' => $ entityId , 'type' => $ blockType ) ) ; }
4140	protected function getRequestString ( ) { $ params = array_merge ( $ this -> getParams , $ this -> postParams , $ this -> getOauthParameters ( ) ) ; $ params = $ this -> curl -> getParams ( $ params ) ; return rawurlencode ( $ params ) ; }
9560	protected function renderCloseButton ( ) { if ( ( $ closeButton = $ this -> closeButton ) !== false ) { $ tag = ArrayHelper :: remove ( $ closeButton , 'tag' , 'button' ) ; $ label = ArrayHelper :: remove ( $ closeButton , 'label' , 'Close' ) ; if ( $ tag === 'button' && ! isset ( $ closeButton [ 'type' ] ) ) { $ closeButton [ 'type' ] = 'button' ; } return Html :: tag ( $ tag , $ label , $ closeButton ) ; } else { return null ; } }
4739	public static function clearTmp ( $ clearFolderPath = '' ) { $ folderPath = self :: _getFolderToClear ( $ clearFolderPath ) ; $ directoryHandler = opendir ( $ folderPath ) ; if ( ! empty ( $ directoryHandler ) ) { while ( false !== ( $ fileName = readdir ( $ directoryHandler ) ) ) { $ filePath = $ folderPath . DIRECTORY_SEPARATOR . $ fileName ; self :: _clear ( $ fileName , $ filePath ) ; } closedir ( $ directoryHandler ) ; } return true ; }
6535	protected function hydrate ( $ propertyName ) { if ( isset ( $ this -> yuccaMappingManager ) && ( false === isset ( $ this -> yuccaInitialized [ $ propertyName ] ) ) && ( false === empty ( $ this -> yuccaIdentifier ) ) ) { $ values = $ this -> yuccaMappingManager -> getMapper ( get_class ( $ this ) ) -> load ( $ this -> yuccaIdentifier , $ propertyName , $ this -> yuccaShardingKey ) ; foreach ( $ values as $ property => $ value ) { if ( false === isset ( $ this -> yuccaInitialized [ $ property ] ) ) { $ this -> $ property = $ value ; $ this -> yuccaInitialized [ $ property ] = true ; } } } $ this -> yuccaInitialized [ $ propertyName ] = true ; return $ this ; }
9629	protected function getRouteIdentifier ( Route $ route ) : string { return empty ( $ route -> getName ( ) ) ? $ route -> getTarget ( ) : $ route -> getName ( ) ; }
2489	public function hasMultipleEndpoints ( ) { if ( $ this -> hasMultiple !== null ) { return $ this -> hasMultiple ; } $ endpointSet = array_flip ( $ this -> endpointMap ) ; if ( isset ( $ this -> defaultEndpoint ) ) { $ endpointSet [ $ this -> defaultEndpoint ] = true ; } if ( isset ( $ this -> mainLanguagesEndpoint ) ) { $ endpointSet [ $ this -> mainLanguagesEndpoint ] = true ; } return $ this -> hasMultiple = count ( $ endpointSet ) > 1 ; }
9904	private function updateCellRange ( $ pCellRange = 'A1:A1' , $ pBefore = 'A1' , $ pNumCols = 0 , $ pNumRows = 0 ) { if ( ! Coordinate :: coordinateIsRange ( $ pCellRange ) ) { throw new Exception ( 'Only cell ranges may be passed to this method.' ) ; } $ range = Coordinate :: splitRange ( $ pCellRange ) ; $ ic = count ( $ range ) ; for ( $ i = 0 ; $ i < $ ic ; ++ $ i ) { $ jc = count ( $ range [ $ i ] ) ; for ( $ j = 0 ; $ j < $ jc ; ++ $ j ) { if ( ctype_alpha ( $ range [ $ i ] [ $ j ] ) ) { $ r = Coordinate :: coordinateFromString ( $ this -> updateSingleCellReference ( $ range [ $ i ] [ $ j ] . '1' , $ pBefore , $ pNumCols , $ pNumRows ) ) ; $ range [ $ i ] [ $ j ] = $ r [ 0 ] ; } elseif ( ctype_digit ( $ range [ $ i ] [ $ j ] ) ) { $ r = Coordinate :: coordinateFromString ( $ this -> updateSingleCellReference ( 'A' . $ range [ $ i ] [ $ j ] , $ pBefore , $ pNumCols , $ pNumRows ) ) ; $ range [ $ i ] [ $ j ] = $ r [ 1 ] ; } else { $ range [ $ i ] [ $ j ] = $ this -> updateSingleCellReference ( $ range [ $ i ] [ $ j ] , $ pBefore , $ pNumCols , $ pNumRows ) ; } } } return Coordinate :: buildRange ( $ range ) ; }
2997	public function setFrom ( $ email , $ title = null ) { $ this -> set ( 'From' , $ this -> buildMail ( $ email , $ title ) ) ; }
10763	public function setPaymentType ( $ paymentType ) { if ( self :: PAYMENT_PEER_TO_PEER !== $ paymentType ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid payment type.' ) ) ; } return $ this -> add ( 'PT' , $ paymentType ) ; }
6016	public function createSite ( DeploymentSite $ deploymentSite ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'deploymentSite' => $ deploymentSite ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
5846	public function syslog ( $ message , $ severity = \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK ) { switch ( $ severity ) { case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: NOTICE : $ severity = GeneralUtility :: SYSLOG_SEVERITY_NOTICE ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: INFO : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: WARNING : $ severity = GeneralUtility :: SYSLOG_SEVERITY_WARNING ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR : $ severity = GeneralUtility :: SYSLOG_SEVERITY_ERROR ; break ; } GeneralUtility :: sysLog ( $ message , 'image_autoresize' , $ severity ) ; }
11293	protected function _getAttributeData ( $ name , $ query = false , $ loadMap = false , $ record = false ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { return $ this -> _getAttributeDataWhenSet ( $ name , $ query , $ loadMap , $ record ) ; } if ( isset ( $ this -> model_attributes [ $ name ] ) && ! isset ( $ this -> model_dynamicOff ) ) { return $ this -> _getAttributeDataWhenUnset ( $ name , $ query , $ loadMap , $ record ) ; } if ( isset ( $ this -> data -> { $ name } ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> data -> { $ name } ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } $ class = get_class ( $ this ) ; if ( property_exists ( $ class , $ name ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> { $ name } ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } if ( $ name == 'id' && property_exists ( $ class , 'id_name' ) ) { $ this -> beforeGet ( $ this -> id_name ) ; if ( isset ( $ this -> model_data [ $ this -> id_name ] ) ) { $ returnValue = $ this -> model_data [ $ this -> id_name ] ; } else { $ returnValue = $ this -> { $ this -> id_name } ; } $ this -> afterGet ( $ this -> id_name , $ returnValue ) ; return $ returnValue ; } if ( substr ( $ name , 0 , 6 ) != "model_" && $ this -> issetExtended ( $ name ) ) { $ this -> beforeGet ( $ name ) ; $ returnValue = $ this -> getExtendedAttribute ( $ name ) ; $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; } $ this -> beforeGet ( $ name ) ; if ( isset ( $ this -> { $ name } ) ) { $ returnValue = $ this -> { $ name } ; } else { $ returnValue = null ; } $ this -> afterGet ( $ name , $ returnValue ) ; return $ returnValue ; }
8571	public function listRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7992	public function setPassword ( $ pp , $ pca , $ passwd ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ passwd ) throw new BadMethodCallException ( 'Missing parameter $passwd (Password for this pca).' ) ; $ payload = array ( 'password' => $ passwd ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
12009	public function setTitle ( string $ title ) : void { $ this -> title = $ this -> translator !== null ? $ this -> translator -> translate ( $ title ) : $ title ; }
12276	private function buildTemplatesMap ( ) { if ( ! empty ( $ this -> templatesMap ) ) { return $ this -> templatesMap ; } $ this -> templatesMap = [ ] ; foreach ( $ this -> templatesPaths as $ templatesPath => $ templatesNamespace ) { if ( ! is_readable ( $ templatesPath ) ) { throw new \ RuntimeException ( "Templates path '$templatesPath' does not exist or is not readable." ) ; } foreach ( glob ( $ templatesPath . '/*.phtml' ) as $ templatePath ) { $ template = pathinfo ( $ templatePath , PATHINFO_FILENAME ) ; if ( $ templatesNamespace !== null ) { $ template .= '@' . $ templatesNamespace ; } if ( array_key_exists ( $ template , $ this -> templatesMap ) ) { throw new \ OverflowException ( "Can't import template '$template' from '$templatePath' as a template with the same name already exists at '{$this->templatesMap[$template]}'. You may want to use namespaces." ) ; } $ this -> templatesMap [ $ template ] = $ templatePath ; } } return $ this -> templatesMap ; }
3766	private function addInputScreenTranslations ( StaticTranslator $ translator , $ inputScreen , $ containerName ) { $ currentLocale = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ inputScreen [ 'legends' ] as $ legendName => $ legendInfo ) { foreach ( $ legendInfo [ 'label' ] as $ langCode => $ label ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName , $ langCode ) ; if ( $ currentLocale === $ langCode ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName ) ; } } } }
10566	protected function formatJsonp ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/javascript; charset=UTF-8' ) ; if ( is_array ( $ response -> data ) && isset ( $ response -> data [ 'data' ] , $ response -> data [ 'callback' ] ) ) { $ response -> content = sprintf ( '%s(%s);' , $ response -> data [ 'callback' ] , Json :: htmlEncode ( $ response -> data [ 'data' ] ) ) ; } elseif ( $ response -> data !== null ) { $ response -> content = '' ; Yii :: warning ( "The 'jsonp' response requires that the data be an array consisting of both 'data' and 'callback' elements." , __METHOD__ ) ; } }
8428	public function getFileIcon ( $ fileType , $ iconLib = 'cmti' ) { switch ( $ iconLib ) { case 'cmti' : { return $ this -> getCmtiFileIcon ( $ fileType ) ; } case 'fa' : { return $ this -> getFaFileIcon ( $ fileType ) ; } } }
141	public function markAliasUninstalled ( RepositoryInterface $ repo , MarkAliasUninstalledOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ repo -> removePackage ( $ package ) ; }
4330	public static function serializeLog ( $ data ) { $ str = \ serialize ( $ data ) ; if ( \ function_exists ( 'gzdeflate' ) ) { $ str = \ gzdeflate ( $ str ) ; } $ str = \ chunk_split ( \ base64_encode ( $ str ) , 124 ) ; return "START DEBUG\n" . $ str . 'END DEBUG' ; }
3186	public function start ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'start() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { \ common_Logger :: t ( 'Missing END TimePoint in QtiTimer, auto add an arbitrary value' ) ; $ point = new TimePoint ( $ tags , $ timestamp - ( 1 / TimePoint :: PRECISION ) , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; $ range [ ] = $ point ; } $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_START , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; return $ this ; }
10401	private function countSourceItems ( $ sources ) { $ count = 0 ; foreach ( $ sources as $ source ) { $ count += count ( $ source ) ; } return $ count ; }
12289	private function make ( string $ block , array $ vars = null ) : string { $ commonVars = static :: COMMON_NAME . static :: VARS_PROPERTY_SUFFIX ; $ blockVars = $ block . static :: VARS_PROPERTY_SUFFIX ; $ allVars = [ ] ; if ( isset ( $ this -> $ commonVars ) && is_array ( $ this -> $ commonVars ) ) { $ allVars = $ this -> $ commonVars ; } if ( isset ( $ this -> $ blockVars ) && is_array ( $ this -> $ blockVars ) ) { $ allVars += $ this -> $ blockVars ; } if ( isset ( $ vars ) ) { $ allVars += $ vars ; } $ file = $ this -> path . $ this -> { $ block . static :: BLOCK_PROPERTY_SUFFIX } . '.' . static :: FILE_EXTENSION ; $ localScope = function ( $ vars , $ file ) { ob_start ( ) ; extract ( $ vars ) ; try { require $ file ; } catch ( \ Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } $ _ = isset ( $ _ ) ? str_pad ( '' , $ _ ) : '' ; return str_replace ( PHP_EOL , PHP_EOL . $ _ , PHP_EOL . ob_get_clean ( ) ) ; } ; return $ localScope ( $ allVars , $ file ) ; }
3709	protected function getFrontendFilterOptions ( ) { $ objFrontendFilterOptions = new FrontendFilterOptions ( ) ; $ objFrontendFilterOptions -> setAutoSubmit ( $ this -> objFilterConfig -> metamodel_fef_autosubmit ? true : false ) ; $ objFrontendFilterOptions -> setHideClearFilter ( $ this -> objFilterConfig -> metamodel_fef_hideclearfilter ? true : false ) ; $ objFrontendFilterOptions -> setShowCountValues ( $ this -> objFilterConfig -> metamodel_available_values ? true : false ) ; return $ objFrontendFilterOptions ; }
9891	protected function createHint ( ) { if ( $ this -> getElement ( ) -> getHint ( ) ) { $ this -> hint = $ this -> builder -> make ( 'hint' , $ this -> getElement ( ) -> getHintAttributes ( ) , $ this -> getElement ( ) -> getHint ( ) ) ; } }
11240	public function def ( $ checkName , $ class , $ method , $ errorMessage , $ passing = true , $ arguments = false ) { $ this -> customChecks -> $ checkName = [ '_call' , $ class , $ method , $ passing , $ arguments ] ; $ this -> lang -> $ checkName = $ errorMessage ; }
1768	public function listNewsArticles ( $ arrRow ) { return '<div class="tl_content_left">' . $ arrRow [ 'headline' ] . ' <span style="color:#999;padding-left:3px">[' . Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ arrRow [ 'date' ] ) . ']</span></div>' ; }
8409	public static function clear ( ) { $ keys = array_keys ( $ _COOKIE ) ; foreach ( $ keys as $ key ) { setcookie ( $ key , '' , time ( ) - 1 ) ; } }
10825	public static function choice ( $ question , array $ choices , $ defaultValue = null ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( ( string ) $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( count ( $ choices ) > 0 ) { foreach ( $ choices as $ index => $ choice ) { self :: write ( ' [' ) ; self :: write ( ( string ) ( $ index + 1 ) , 'comment' ) ; self :: writeln ( '] ' . $ choice ) ; } } if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( ! isset ( $ choices [ intval ( $ value ) - 1 ] ) ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] Value "' . $ value . '" is invalid' , 'error' ) ; $ value = '' ; } elseif ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
3517	public function getShowUnpublished ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'show_unpublished' ; $ queuedCookie = \ Cookie :: queued ( $ key , null ) ; $ showUnpublished = $ queuedCookie != null ? $ queuedCookie -> getValue ( ) : \ Cookie :: get ( $ key , false ) ; $ this -> useDB = $ showUnpublished ? 2 : 1 ; $ this -> cookiesLoaded = true ; } return $ this -> useDB === 2 ; }
4494	private function getApnsJsonInner ( ? string $ text ) : array { $ apns = [ 'aps' => [ ] , ] ; if ( null !== $ this -> localizedKey ) { $ apns [ 'aps' ] [ 'alert' ] = [ 'loc-key' => $ this -> localizedKey , ] ; if ( $ this -> localizedArguments ) { $ apns [ 'aps' ] [ 'alert' ] [ 'loc-args' ] = $ this -> localizedArguments ; } } elseif ( null !== $ text ) { $ apns [ 'aps' ] [ 'alert' ] = $ text ; } if ( $ this -> isContentAvailable ( ) ) { $ apns [ 'aps' ] [ 'content-available' ] = 1 ; } if ( null !== $ this -> badge ) { $ apns [ 'aps' ] [ 'badge' ] = $ this -> badge ; } if ( null !== $ this -> sound ) { $ apns [ 'aps' ] [ 'sound' ] = $ this -> sound ; } $ merged = $ this -> arrayMergeDeep ( $ apns , $ this -> custom , $ this -> apnsData ? $ this -> apnsData : [ ] ) ; if ( ! \ count ( $ merged [ 'aps' ] ) ) { $ merged [ 'aps' ] = new \ stdClass ( ) ; } return $ merged ; }
3235	public function getCountAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> itemCount , 2 ) ; }
1272	public function isValid ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { return $ this -> response -> AddressClassification -> Code > 0 ; } return isset ( $ this -> response -> ValidAddressIndicator ) ; }
2642	public function cleanAll ( ) { if ( $ this -> purged == true ) { return true ; } $ this -> purged = true ; $ type = 'clean/purge all' ; $ uri = $ this -> _getApiServiceUri ( ) . 'purge_all' ; $ result = $ this -> _purge ( $ uri , null ) ; if ( $ result [ 'status' ] ) { $ this -> logger -> execute ( 'clean all items' ) ; } $ canPublishPurgeAllChanges = $ this -> config -> canPublishPurgeAllChanges ( ) ; $ canPublishPurgeChanges = $ this -> config -> canPublishPurgeChanges ( ) ; if ( $ this -> config -> areWebHooksEnabled ( ) && ( $ canPublishPurgeAllChanges || $ canPublishPurgeChanges ) ) { $ this -> sendWebHook ( '*initiated clean/purge all*' ) ; $ canPublishPurgeAllDebugBacktrace = $ this -> config -> canPublishPurgeAllDebugBacktrace ( ) ; $ canPublishPurgeDebugBacktrace = $ this -> config -> canPublishPurgeDebugBacktrace ( ) ; if ( $ canPublishPurgeAllDebugBacktrace == false && $ canPublishPurgeDebugBacktrace == false ) { return $ result [ 'status' ] ; } $ this -> stackTrace ( $ type ) ; } return $ result [ 'status' ] ; }
9489	public function getFileData ( $ sFieldName ) { if ( empty ( $ sFieldName ) ) { return null ; } $ obFile = $ this -> $ sFieldName ; if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } return $ this -> getFileDataValue ( $ obFile ) ; }
7078	static public function isSaleSupportsDocumentType ( SaleInterface $ sale , $ type ) { if ( ! DocumentTypes :: isValidType ( $ type ) ) { return false ; } if ( empty ( $ classes = DocumentTypes :: getClasses ( $ type ) ) ) { return false ; } foreach ( $ classes as $ class ) { if ( is_subclass_of ( $ sale , $ class ) ) { return true ; } } return false ; }
106	public function moveWatch ( $ from , $ to ) { if ( $ this -> watch1 == $ from ) { $ this -> watch1 = $ to ; } else { $ this -> watch2 = $ to ; } }
634	public function createTable ( $ table , $ columns , $ options = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createTable ( $ table , $ columns , $ options ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
5125	public function serve ( ) { foreach ( $ this -> dispatchers as $ dispatcher ) { if ( $ dispatcher -> canServe ( ) ) { ContainerScope :: runScope ( $ this -> container , [ $ dispatcher , 'serve' ] ) ; return ; } } throw new BootException ( "Unable to locate active dispatcher." ) ; }
639	public function renameColumn ( $ table , $ oldName , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameColumn ( $ table , $ oldName , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
7030	public function toArray ( ) { return [ 'o_msg' => $ this -> overflowMessage , 'min_qty' => $ this -> minimumQuantity , 'min_msg' => $ this -> minimumMessage , 'max_qty' => INF === $ this -> maximumQuantity ? 'INF' : $ this -> maximumQuantity , 'max_msg' => $ this -> maximumMessage , 'a_qty' => INF === $ this -> availableQuantity ? 'INF' : $ this -> availableQuantity , 'a_msg' => $ this -> availableMessage , 'r_qty' => $ this -> resupplyQuantity , 'r_msg' => $ this -> resupplyMessage , ] ; }
7472	public function resetPasswordAction ( Request $ request , $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( ChangePasswordType :: class , null , array ( 'require_current' => false ) ) ; if ( $ request -> isMethod ( 'POST' ) ) { $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ data = $ form -> getData ( ) ; $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ user -> setPassword ( $ encoder -> encodePassword ( $ data [ 'password' ] , $ user -> getSalt ( ) ) ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The password has been changed.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ id ) ) ) ; } } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
10343	protected function extractRange ( $ definition , $ min = null , $ max = null ) { $ resultSet = array ( ) ; if ( substr ( $ definition , 0 , 1 ) === '*' ) { if ( $ min === null || $ max === null ) { return false ; } for ( $ i = $ min ; $ i <= $ max ; ++ $ i ) { $ resultSet [ ] = $ i ; } return $ resultSet ; } if ( ( $ position = strpos ( $ definition , '/' ) ) !== false ) { $ definition = substr ( $ definition , 0 , $ position ) ; } $ ranges = explode ( ',' , $ definition ) ; foreach ( $ ranges as $ range ) { $ entries = explode ( '-' , $ range ) ; if ( count ( $ entries ) === 1 ) { $ resultSet [ ] = ( int ) $ entries [ 0 ] ; } else { $ high = ( int ) max ( $ entries ) ; $ low = ( int ) min ( $ entries ) ; for ( $ i = $ low ; $ i <= $ high ; ++ $ i ) { $ resultSet [ ] = $ i ; } } } return $ resultSet ; }
9194	public function addChild ( ModelInterface $ child , $ captureTo = null , $ append = null ) { parent :: addChild ( $ child , $ captureTo , $ append ) ; if ( $ child instanceof ThemeDefaultInterface ) { $ child -> parent = $ this ; } return $ this ; }
12235	public function insertXML ( $ xml , $ mode = 'append' ) { $ tmp = dom_import_simplexml ( $ this ) ; $ fragment = $ tmp -> ownerDocument -> createDocumentFragment ( ) ; $ use_errors = libxml_use_internal_errors ( true ) ; if ( ! $ fragment -> appendXML ( $ xml ) ) { libxml_use_internal_errors ( $ use_errors ) ; throw new InvalidArgumentException ( libxml_get_last_error ( ) -> message ) ; } libxml_use_internal_errors ( $ use_errors ) ; $ this -> insertNode ( $ tmp , $ fragment , $ mode ) ; return $ this ; }
2516	public function pnrCreatePnr ( RequestOptions \ PnrCreatePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
7351	public function isPaid ( ) { return 0 <= Money :: compare ( $ this -> paidTotal , $ this -> grandTotal , $ this -> getCurrency ( ) -> getCode ( ) ) ; }
2414	protected function addTableTlModule ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_module' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_module' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_module' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ objModule = $ this -> Database -> prepare ( "SELECT * FROM tl_module WHERE pid=? ORDER BY name" ) -> execute ( $ objTheme -> id ) ; while ( $ objModule -> next ( ) ) { $ this -> addDataRow ( $ xml , $ table , $ objModule -> row ( ) , $ arrOrder ) ; } }
7630	public function getContainerMetadata ( $ containerName = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; return $ this -> getContainer ( $ containerName ) -> Metadata ; }
9849	public function createSignedResponse ( int $ status , string $ body , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { $ signature = \ ParagonIE_Sodium_Compat :: crypto_sign_detached ( $ body , $ key -> getString ( true ) ) ; if ( isset ( $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] ) ) { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] [ ] = Base64UrlSafe :: encode ( $ signature ) ; } else { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] = Base64UrlSafe :: encode ( $ signature ) ; } return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( $ body ) ) ; }
560	protected function buildOperatorCondition ( $ operator , $ condition , $ attribute ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } return [ $ operator , $ attribute , $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; }
7091	protected function match ( Request $ request ) { foreach ( $ this -> routes as $ route ) { if ( $ route -> method ( ) === $ request -> method ( ) && $ route -> match ( $ request -> url ( ) ) ) { if ( $ action = $ route -> action ( ) ) { try { $ response = $ action ( $ request , $ route -> args ( ) ) ; if ( $ response !== false ) return $ response ; } catch ( AbortRouteException $ abort ) { return $ abort -> response ( ) ; } } else return null ; } } return false ; }
3202	protected function process_css_style ( $ stackPtr ) { if ( ! isset ( $ this -> target_css_properties [ $ this -> tokens [ $ stackPtr ] [ 'content' ] ] ) ) { return ; } $ css_property = $ this -> target_css_properties [ $ this -> tokens [ $ stackPtr ] [ 'content' ] ] ; $ opener = $ this -> phpcsFile -> findPrevious ( \ T_OPEN_CURLY_BRACKET , $ stackPtr ) ; if ( false !== $ opener ) { for ( $ i = ( $ opener - 1 ) ; $ i >= 0 ; $ i -- ) { if ( isset ( Tokens :: $ commentTokens [ $ this -> tokens [ $ i ] [ 'code' ] ] ) || \ T_CLOSE_CURLY_BRACKET === $ this -> tokens [ $ i ] [ 'code' ] ) { break ; } } $ start = ( $ i + 1 ) ; $ selector = trim ( $ this -> phpcsFile -> getTokensAsString ( $ start , ( $ opener - $ start ) ) ) ; unset ( $ i ) ; foreach ( $ this -> target_css_selectors as $ target_selector ) { if ( false !== strpos ( $ selector , $ target_selector ) ) { $ error = true ; if ( true === $ this -> remove_only ) { $ valuePtr = $ this -> phpcsFile -> findNext ( array ( \ T_COLON , \ T_WHITESPACE ) , ( $ stackPtr + 1 ) , null , true ) ; $ value = $ this -> tokens [ $ valuePtr ] [ 'content' ] ; $ valid = $ this -> validate_css_property_value ( $ value , $ css_property [ 'type' ] , $ css_property [ 'value' ] ) ; if ( true === $ valid ) { $ error = false ; } } if ( true === $ error ) { $ this -> phpcsFile -> addError ( 'Hiding of the admin bar is not allowed.' , $ stackPtr , 'HidingDetected' ) ; } } } } }
10138	private function writePageLayoutView ( ) { $ record = 0x088B ; $ length = 0x0010 ; $ rt = 0x088B ; $ grbitFrt = 0x0000 ; $ reserved = 0x0000000000000000 ; $ wScalvePLV = $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) ; if ( $ this -> phpSheet -> getSheetView ( ) -> getView ( ) == SheetView :: SHEETVIEW_PAGE_LAYOUT ) { $ fPageLayoutView = 1 ; } else { $ fPageLayoutView = 0 ; } $ fRulerVisible = 0 ; $ fWhitespaceHidden = 0 ; $ grbit = $ fPageLayoutView ; $ grbit |= $ fRulerVisible << 1 ; $ grbit |= $ fWhitespaceHidden << 3 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvVVvv' , $ rt , $ grbitFrt , 0x00000000 , 0x00000000 , $ wScalvePLV , $ grbit ) ; $ this -> append ( $ header . $ data ) ; }
10307	public function setGlowProperties ( $ size , $ color_value = null , $ color_alpha = null , $ color_type = null ) { $ this -> setGlowSize ( $ size ) -> setGlowColor ( $ color_value === null ? $ this -> glowProperties [ 'color' ] [ 'value' ] : $ color_value , $ color_alpha === null ? ( int ) $ this -> glowProperties [ 'color' ] [ 'alpha' ] : $ color_alpha , $ color_type === null ? $ this -> glowProperties [ 'color' ] [ 'type' ] : $ color_type ) ; }
2209	public function fetchRow ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = array_values ( $ this -> resultSet [ ++ $ this -> intIndex ] ) ; return $ this -> arrCache ; }
10285	public static function columnIndexFromString ( $ pString ) { static $ indexCache = [ ] ; if ( isset ( $ indexCache [ $ pString ] ) ) { return $ indexCache [ $ pString ] ; } static $ columnLookup = [ 'A' => 1 , 'B' => 2 , 'C' => 3 , 'D' => 4 , 'E' => 5 , 'F' => 6 , 'G' => 7 , 'H' => 8 , 'I' => 9 , 'J' => 10 , 'K' => 11 , 'L' => 12 , 'M' => 13 , 'N' => 14 , 'O' => 15 , 'P' => 16 , 'Q' => 17 , 'R' => 18 , 'S' => 19 , 'T' => 20 , 'U' => 21 , 'V' => 22 , 'W' => 23 , 'X' => 24 , 'Y' => 25 , 'Z' => 26 , 'a' => 1 , 'b' => 2 , 'c' => 3 , 'd' => 4 , 'e' => 5 , 'f' => 6 , 'g' => 7 , 'h' => 8 , 'i' => 9 , 'j' => 10 , 'k' => 11 , 'l' => 12 , 'm' => 13 , 'n' => 14 , 'o' => 15 , 'p' => 16 , 'q' => 17 , 'r' => 18 , 's' => 19 , 't' => 20 , 'u' => 21 , 'v' => 22 , 'w' => 23 , 'x' => 24 , 'y' => 25 , 'z' => 26 , ] ; if ( isset ( $ pString [ 0 ] ) ) { if ( ! isset ( $ pString [ 1 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString ] ; return $ indexCache [ $ pString ] ; } elseif ( ! isset ( $ pString [ 2 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString [ 0 ] ] * 26 + $ columnLookup [ $ pString [ 1 ] ] ; return $ indexCache [ $ pString ] ; } elseif ( ! isset ( $ pString [ 3 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString [ 0 ] ] * 676 + $ columnLookup [ $ pString [ 1 ] ] * 26 + $ columnLookup [ $ pString [ 2 ] ] ; return $ indexCache [ $ pString ] ; } } throw new Exception ( 'Column string index can not be ' . ( ( isset ( $ pString [ 0 ] ) ) ? 'longer than 3 characters' : 'empty' ) ) ; }
4355	protected function checkTimestamp ( $ val ) { $ secs = 86400 * 90 ; $ tsNow = \ time ( ) ; if ( $ val > $ tsNow - $ secs && $ val < $ tsNow + $ secs ) { return \ date ( 'Y-m-d H:i:s' , $ val ) ; } return false ; }
1473	public function createValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , \ Closure $ callback = null ) : ValidatorInterface { $ translator = $ this -> createErrorTranslator ( ) ; return new Validation \ Validator ( $ this -> makeValidator ( $ data , $ rules , $ messages , $ customAttributes ) , $ translator , $ callback ) ; }
3174	private function getTimeConstraint ( TestSession $ session , QtiComponent $ source , $ navigationMode ) { $ constraint = new QtiTimeConstraint ( $ source , $ session -> getTimerDuration ( $ source -> getIdentifier ( ) ) , $ navigationMode , true , true , $ session -> getTimerTarget ( ) ) ; $ constraint -> setTimer ( $ session -> getTimer ( ) ) ; return $ constraint ; }
143	private static function fixHttpHeaderField ( $ header ) { if ( ! is_array ( $ header ) ) { $ header = explode ( "\r\n" , $ header ) ; } uasort ( $ header , function ( $ el ) { return stripos ( $ el , 'content-type' ) === 0 ? 1 : - 1 ; } ) ; return $ header ; }
1590	protected function invokeMany ( iterable $ hooks , ... $ arguments ) { foreach ( $ hooks as $ hook ) { $ result = $ this -> invoke ( $ hook , ... $ arguments ) ; if ( ! is_null ( $ result ) ) { return $ result ; } } return null ; }
2907	public function getPartDecodedContent ( Zend_Mime_Part $ mimePart ) { if ( method_exists ( $ mimePart , 'getRawContent' ) ) { return $ mimePart -> getRawContent ( ) ; } $ content = '' ; if ( method_exists ( $ mimePart , 'getContent' ) ) { $ encoding = $ mimePart -> encoding ; $ mimePart -> encoding = 'none' ; $ content = $ mimePart -> getContent ( ) ; $ mimePart -> encoding = $ encoding ; } return $ content ; }
8645	private function parseHttpHeader ( $ header ) { $ parsedHeader = array ( ) ; foreach ( explode ( "\n" , $ header ) as $ line ) { $ splitLine = preg_split ( '/:\s/' , $ line , 2 , PREG_SPLIT_NO_EMPTY ) ; if ( sizeof ( $ splitLine ) == 2 ) { $ k = strtolower ( trim ( $ splitLine [ 0 ] ) ) ; $ v = trim ( $ splitLine [ 1 ] ) ; if ( array_key_exists ( $ k , $ parsedHeader ) ) { $ parsedHeader [ $ k ] = $ parsedHeader [ $ k ] . "," . $ v ; } else { $ parsedHeader [ $ k ] = $ v ; } } } return $ parsedHeader ; }
806	private function findReturnAnnotations ( Tokens $ tokens , $ index ) { do { $ index = $ tokens -> getPrevNonWhitespace ( $ index ) ; } while ( $ tokens [ $ index ] -> isGivenKind ( [ T_ABSTRACT , T_FINAL , T_PRIVATE , T_PROTECTED , T_PUBLIC , T_STATIC , ] ) ) ; if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DOC_COMMENT ) ) { return [ ] ; } $ doc = new DocBlock ( $ tokens [ $ index ] -> getContent ( ) ) ; return $ doc -> getAnnotationsOfType ( 'return' ) ; }
11316	public function handleUseRequest ( $ data , $ transactionId , $ transactionKey ) { if ( ! $ this -> objCredits ) { return null ; } if ( isset ( $ _POST [ 'transaction_id' ] ) && isset ( $ _POST [ 'transaction_secret' ] ) ) { $ valid = $ this -> objCredits -> isRequestValid ( $ _POST [ 'transaction_id' ] , $ _POST [ 'transaction_secret' ] ) ; if ( $ valid ) { $ amount = $ _POST [ 'transaction_amount' ] ; $ this -> objUser -> useCredit ( $ amount , $ data ) ; return true ; } else { $ this -> error = 'This request was not valid or already executed. Ignore.' ; } } else { $ this -> error = 'No post data received.' ; } return false ; }
12516	public static function delete ( $ path ) { if ( ! Folder :: exists ( $ path ) ) { return true ; } $ path = Path :: clean ( $ path ) ; if ( trim ( $ path ) === '' ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' : Cannot delete root path' ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
8481	public static function getNameById ( $ id , $ attributeName = 'name' ) { $ model = static :: loadModel ( $ id ) ; return empty ( $ model [ $ attributeName ] ) === false ? $ model [ $ attributeName ] : \ Yii :: t ( 'app' , 'Unknown' ) ; }
10881	public function checkPaths ( ) { if ( $ this -> path_checked ) return true ; foreach ( array ( 'root' , 'webroot' ) as $ type ) { $ path = $ this -> $ type ; if ( ! file_exists ( $ path ) || ! is_dir ( $ path ) ) throw new IOException ( "Path '$type' does not exist: " . $ path ) ; if ( ! is_readable ( $ path ) ) throw new PermissionError ( $ path , "Path '$type' cannot be read" ) ; } if ( ! is_dir ( $ this -> config ) || is_readable ( $ this -> config ) ) $ this -> config = null ; foreach ( array ( 'var' , 'cache' , 'log' , 'uploads' ) as $ write_dir ) { $ path = $ this -> $ write_dir ; if ( ! is_dir ( $ path ) ) { $ dn = dirname ( $ path ) ; if ( ! file_exists ( $ path ) && $ dn === $ this -> var ) { Path :: mkdir ( $ path ) ; } else { if ( file_exists ( $ path ) ) throw new IOException ( "Path '$write_dir' exists but is not a directory: " . $ path ) ; $ this -> $ write_dir = null ; continue ; } } if ( ! is_writable ( $ path ) ) { try { Path :: makeWritable ( $ path ) ; } catch ( PermissionError $ e ) { $ this -> $ write_dir = null ; if ( $ this -> cli ) WF :: debug ( "Failed to get write access to: %s" , $ e -> getMessage ( ) ) ; } } } $ this -> path_checked = true ; return true ; }
6507	public function deserializeReturnValue ( $ type , $ data ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> deserialize ( $ data , $ jobType -> getReturnType ( ) , 'json' , $ this -> getResponseDeserializationContext ( $ jobType ) ) ; }
8610	public function updateSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_UpdateSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/UpdateSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_UpdateSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/UpdateSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_UpdateSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1234	private function toXml ( $ elementName , $ rootElement = false ) { return sprintf ( '%s<%s%s%s>%s</%s>' , $ rootElement ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" : '' , $ elementName , $ this -> attributesToXml ( ) , array_key_exists ( get_class ( $ this ) , self :: $ xmlNamespaces ) ? sprintf ( ' %s' , self :: $ xmlNamespaces [ get_class ( $ this ) ] ) : '' , $ this -> propertiesToXml ( ) , $ elementName ) ; }
8320	public function getCaptchaResultBulk ( array $ captchaIds ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , '/res.php?' . http_build_query ( [ 'key' => $ this -> apiKey , 'action' => 'get' , 'ids' => join ( ',' , $ captchaIds ) ] ) ) ; $ captchaTexts = $ response -> getBody ( ) -> __toString ( ) ; $ this -> getLogger ( ) -> info ( "Got bulk response: `{$captchaTexts}`." ) ; $ captchaTexts = explode ( "|" , $ captchaTexts ) ; $ result = [ ] ; foreach ( $ captchaTexts as $ index => $ captchaText ) { $ captchaText = html_entity_decode ( trim ( $ captchaText ) ) ; $ result [ $ captchaIds [ $ index ] ] = ( $ captchaText == self :: STATUS_CAPTCHA_NOT_READY ) ? false : $ captchaText ; } return $ result ; }
9304	public function setFailureLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`failureLogLifetime` expects integer value!' ) ; } $ this -> options [ 'failureLogLifetime' ] = ( int ) $ time ; return $ this ; }
10402	public function createApplication ( string $ app_type , FileSystemInterface $ filesystem ) : ApplicationInterface { switch ( $ app_type ) { case ApplicationType :: SHELL : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( CalgamoShellRequestModule :: class ) ; case ApplicationType :: CRON : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( CalgamoShellRequestModule :: class ) ; break ; case ApplicationType :: HTTP : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( 'zend.request' ) ; break ; case ApplicationType :: REST : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( ZendRequestModule :: class ) -> requireModule ( CalgamoRestApiModule :: class ) ; break ; } return new NullApplication ( ) ; }
8244	public function login ( $ id , $ userData ) { $ this -> abortIfExpired ( $ id , $ userData ) ; $ u = new User ( ) ; $ u -> setAuthenticated ( true ) ; $ u -> setAuthenticator ( $ this -> getName ( ) ) ; $ u -> setId ( $ id ) ; if ( isset ( $ userData [ 'groups' ] ) ) { $ u -> setGroups ( $ userData [ 'groups' ] ) ; } if ( isset ( $ userData [ 'displayName' ] ) ) { $ u -> setDisplayName ( $ userData [ 'displayName' ] ) ; } if ( isset ( $ userData [ 'attributes' ] ) ) { foreach ( $ userData [ 'attributes' ] as $ key => $ value ) { $ u -> setAttribute ( $ key , $ value ) ; } } $ this -> picoAuth -> setUser ( $ u ) ; }
9889	public static function json ( $ response ) { $ body = self :: toString ( $ response ) ; $ data = json_decode ( $ body , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new RuntimeException ( 'Unable to parse response body into JSON: ' . json_last_error ( ) ) ; } return $ data === null ? [ ] : $ data ; }
12667	public function getInputSpecification ( ) { $ datetimeElement = $ this ; return array ( 'name' => $ this -> getName ( ) , 'required' => true , 'filters' => array ( array ( 'name' => 'Zend\Filter\StringTrim' ) , array ( 'name' => 'Callback' , 'options' => array ( 'callback' => function ( $ value ) use ( $ datetimeElement ) { if ( ! empty ( $ value ) && is_string ( $ value ) ) { return DateTime :: createFromFormat ( $ datetimeElement -> getFormat ( ) , $ value ) ; } return $ value ; } ) ) ) , 'validators' => $ this -> getValidators ( ) , ) ; }
11004	public function getPath ( $ url ) { $ url = new URL ( $ url ) ; $ to_replace = $ this -> url -> path ; $ path = $ url -> path ; if ( strpos ( $ path , $ to_replace ) === 0 ) $ path = substr ( $ path , strlen ( $ to_replace ) ) ; $ path = '/' . urldecode ( $ path ) ; return $ path ; }
2342	protected function getUserId ( ) { if ( $ this -> intUserId !== null ) { return $ this -> intUserId ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> id ; }
2060	public function scheduleUpdate ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord || ! $ dc -> activeRecord -> id || Contao \ Input :: get ( 'act' ) == 'copy' ) { return ; } $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; $ session [ ] = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> id ) -> rootId ; $ objSession -> set ( 'sitemap_updater' , array_unique ( $ session ) ) ; }
7385	public function uploadAction ( ) { if ( $ this -> request -> hasFiles ( ) == true ) { $ this -> initializeScaffolding ( ) ; $ form = $ this -> scaffolding -> getForm ( ) ; $ name = key ( $ _FILES ) ; $ uploadElement = $ form -> get ( $ name ) ; $ model = $ uploadElement -> getModel ( ) ; $ path = $ uploadElement -> getPath ( ) ; $ maxFileSize = $ uploadElement -> getMaxFileSize ( ) ; $ minFileSize = $ uploadElement -> getMinFileSize ( ) ; foreach ( $ this -> request -> getUploadedFiles ( ) as $ file ) { $ fileName = $ file -> getName ( ) ; $ fileSize = $ file -> getSize ( ) ; $ fileType = $ file -> getRealType ( ) ; $ fileExtensions = pathinfo ( $ fileName , PATHINFO_EXTENSION ) ; $ allowed = $ uploadElement -> getAllowedExtensions ( ) ; if ( ! empty ( $ allowed ) ) { if ( ! in_array ( $ fileExtensions , $ allowed ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ forbidden = $ uploadElement -> getForbiddenExtensions ( ) ; if ( ! empty ( $ forbidden ) ) { if ( in_array ( $ fileExtensions , $ forbidden ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ allowedMime = $ uploadElement -> getAllowedMimeTypes ( ) ; if ( ! empty ( $ allowedMime ) ) { if ( ! in_array ( $ fileType , $ allowedMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } $ forbiddenMime = $ uploadElement -> getForbiddenMimeTypes ( ) ; if ( ! empty ( $ forbiddenMime ) ) { if ( in_array ( $ fileType , $ forbiddenMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } if ( ! empty ( $ maxFileSize ) ) { if ( $ fileSize > $ this -> convertFileSizeToBytes ( $ maxFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( ! empty ( $ minFileSize ) ) { if ( $ fileSize < $ this -> convertFileSizeToBytes ( $ minFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( empty ( $ path ) ) { $ path = 'files/' ; } $ model -> name = $ fileName ; $ model -> mime_type = $ fileType ; $ model -> path = $ path ; $ model -> save ( ) ; $ file -> moveTo ( $ path . $ model -> _id ) ; return $ this -> response -> setJsonContent ( ( string ) $ model -> _id ) ; } } $ this -> view -> setRenderLevel ( View :: LEVEL_NO_RENDER ) ; }
12296	public function filter ( FilterRequest $ filters ) { $ search = new Search ( $ this -> model , $ filters ) ; $ this -> builder = $ search -> getBuilder ( ) ; return $ this ; }
3040	public function del ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ this -> putInCache ( $ key , $ userId , $ callId , null , self :: STATE_PENDING_DELETE ) ; return true ; }
5933	public function setStartDate ( $ startDate ) { if ( $ startDate instanceof DateTime ) { $ this -> startDate = $ startDate ; } else { try { $ this -> startDate = new DateTime ( $ startDate ) ; } catch ( \ Exception $ e ) { $ this -> startDate = null ; } } return $ this ; }
2941	public static function getUnit ( $ unit ) { if ( ! is_array ( static :: $ unitDefinitions ) ) { static :: $ unitDefinitions = [ ] ; static :: initialize ( ) ; } $ key = static :: buildUnitCacheKey ( $ unit ) ; if ( isset ( self :: $ unitCache [ $ key ] ) ) { return self :: $ unitCache [ $ key ] ; } foreach ( static :: $ unitDefinitions as $ unitOfMeasure ) { if ( $ unit === $ unitOfMeasure -> getName ( ) || $ unitOfMeasure -> isAliasOf ( $ unit ) ) { return self :: $ unitCache [ $ key ] = $ unitOfMeasure ; } } throw new Exception \ UnknownUnitOfMeasure ( [ ':unit' => $ unit ] ) ; }
4962	public function addViewModel ( $ name , $ model , $ priority = 0 ) { $ this -> models -> insert ( $ name , $ model , $ priority ) ; return $ this ; }
338	protected function extractColumnSize ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> size = trim ( $ length ) === '' ? null : ( int ) $ length ; $ column -> precision = trim ( $ precision ) === '' ? null : ( int ) $ precision ; $ column -> scale = trim ( $ scale ) === '' ? null : ( int ) $ scale ; }
2737	private function setServiceID ( $ serviceId ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_SERVICE_ID , $ serviceId ) ; $ this -> output -> writeln ( '<info>Service ID updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
6351	public static function size ( Iterator $ iterator ) { $ result = 0 ; Iterators :: each ( $ iterator , function ( ) use ( & $ result ) { $ result ++ ; } ) ; return $ result ; }
3269	public function readFromFile ( ) : \ Generator { $ file = $ this -> openFile ( static :: FILE_READ ) ; try { foreach ( $ file as $ line ) { yield new Line ( $ line ) ; } } finally { $ this -> closeFile ( $ file ) ; } }
12508	public function msgType ( $ msgType ) { if ( ! in_array ( $ msgType , $ this -> msgTypes , true ) ) { throw new InvalidArgumentException ( 'This message type not exist.' ) ; } $ this -> msgType = $ msgType ; return $ this ; }
246	public function fixPrimaryKey ( $ keys ) { $ keys = ( array ) $ keys ; $ this -> primaryKey = $ keys ; foreach ( $ this -> columns as $ column ) { $ column -> isPrimaryKey = false ; } foreach ( $ keys as $ key ) { if ( isset ( $ this -> columns [ $ key ] ) ) { $ this -> columns [ $ key ] -> isPrimaryKey = true ; } else { throw new InvalidArgumentException ( "Primary key '$key' cannot be found in table '{$this->name}'." ) ; } } }
2356	public function hasBackendUser ( ) : bool { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof BackendUser ; }
2553	public static function loadPricingOptionsFromRequestOptions ( $ options ) { $ priceOptions = [ ] ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makePricingOptionForValidatingCarrier ( $ options -> validatingCarrier ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makePricingOptionForCurrencyOverride ( $ options -> currencyOverride ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makePricingOptionFareBasisOverride ( $ options -> pricingsFareBasis ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makePricingOptionFareFamilyOverride ( $ options -> fareFamily ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadCorpNegoFare ( $ options -> corporateNegoFare ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadCorpUniFares ( $ options -> corporateUniFares , $ options -> awardPricing ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadObFees ( $ options -> obFees , $ options -> obFeeRefs ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadPaxDiscount ( $ options -> paxDiscountCodes , $ options -> paxDiscountCodeRefs ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadPointOverrides ( $ options -> pointOfSaleOverride , $ options -> pointOfTicketingOverride ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadPricingLogic ( $ options -> pricingLogic ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadTicketType ( $ options -> ticketType ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadTaxes ( $ options -> taxes ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadExemptTaxes ( $ options -> exemptTaxes ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadPastDate ( $ options -> pastDatePricing ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadFormOfPayment ( $ options -> formOfPayment ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: loadReferences ( $ options -> references ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makeOverrideOptions ( $ options -> overrideOptions , $ priceOptions ) ) ; $ priceOptions = self :: mergeOptions ( $ priceOptions , self :: makeOverrideOptionsWithCriteria ( $ options -> overrideOptionsWithCriteria , $ priceOptions ) ) ; if ( empty ( $ priceOptions ) ) { $ priceOptions [ ] = new PricingOptionGroup ( PricingOptionKey :: OPTION_NO_OPTION ) ; } return $ priceOptions ; }
9886	private function writeDefinedNameForAutofilter ( XMLWriter $ objWriter , Worksheet $ pSheet , $ pSheetId = 0 ) { $ autoFilterRange = $ pSheet -> getAutoFilter ( ) -> getRange ( ) ; if ( ! empty ( $ autoFilterRange ) ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , '_xlnm._FilterDatabase' ) ; $ objWriter -> writeAttribute ( 'localSheetId' , $ pSheetId ) ; $ objWriter -> writeAttribute ( 'hidden' , '1' ) ; $ range = Coordinate :: splitRange ( $ autoFilterRange ) ; $ range = $ range [ 0 ] ; if ( strpos ( $ range [ 0 ] , '!' ) !== false ) { list ( $ ws , $ range [ 0 ] ) = explode ( '!' , $ range [ 0 ] ) ; } $ range [ 0 ] = Coordinate :: absoluteCoordinate ( $ range [ 0 ] ) ; $ range [ 1 ] = Coordinate :: absoluteCoordinate ( $ range [ 1 ] ) ; $ range = implode ( ':' , $ range ) ; $ objWriter -> writeRawData ( '\'' . str_replace ( "'" , "''" , $ pSheet -> getTitle ( ) ) . '\'!' . $ range ) ; $ objWriter -> endElement ( ) ; } }
5670	protected function describeGenericDifference ( $ first , $ second ) { return sprintf ( 'as [%s] does not match [%s]' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) ) ; }
8972	protected function paginate ( array $ rates , $ criteria ) { if ( ! array_key_exists ( 'offset' , $ criteria ) && ! array_key_exists ( 'limit' , $ criteria ) ) { return $ rates ; } $ range = array ( ) ; $ offset = array_key_exists ( 'offset' , $ criteria ) ? $ criteria [ 'offset' ] : 0 ; $ limit = min ( ( array_key_exists ( 'limit' , $ criteria ) ? $ criteria [ 'limit' ] : count ( $ rates ) ) + $ offset , count ( $ rates ) ) ; for ( $ i = $ offset ; $ i < $ limit ; $ i ++ ) { $ range [ ] = $ rates [ $ i ] ; } return $ range ; }
12228	public function removeSelf ( ) { $ tmp = dom_import_simplexml ( $ this ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { throw new BadMethodCallException ( 'removeSelf() cannot be used to remove the root node' ) ; } $ node = $ tmp -> parentNode -> removeChild ( $ tmp ) ; return simplexml_import_dom ( $ node , get_class ( $ this ) ) ; }
10451	public function getTtl ( $ key ) { $ getResult = $ this -> getValue ( $ key ) ; $ unserialized = @ unserialize ( $ getResult ) ; if ( ! Util :: hasInternalExpireTime ( $ unserialized ) ) { throw new \ Exception ( 'Cannot retrieve ttl' ) ; } return $ this -> handleTtl ( $ key , $ unserialized [ 'ts' ] , $ unserialized [ 's' ] ) ; }
10157	private function readBoolErr ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ column = self :: getUInt2d ( $ recordData , 2 ) ; $ columnString = Coordinate :: stringFromColumnIndex ( $ column + 1 ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , 4 ) ; $ boolErr = ord ( $ recordData [ 6 ] ) ; $ isError = ord ( $ recordData [ 7 ] ) ; $ cell = $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) ; switch ( $ isError ) { case 0 : $ value = ( bool ) $ boolErr ; $ cell -> setValueExplicit ( $ value , DataType :: TYPE_BOOL ) ; break ; case 1 : $ value = Xls \ ErrorCode :: lookup ( $ boolErr ) ; $ cell -> setValueExplicit ( $ value , DataType :: TYPE_ERROR ) ; break ; } if ( ! $ this -> readDataOnly ) { $ cell -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } } }
6298	public function addToMain ( array $ item , $ name = 'default' , $ first = false ) { if ( ! array_key_exists ( $ name , $ this -> main ) ) { $ this -> main [ $ name ] = [ ] ; } if ( $ first ) { $ this -> main [ $ name ] = array_merge ( [ $ item ] , $ this -> main [ $ name ] ) ; } else { $ this -> main [ $ name ] [ ] = $ item ; } return $ this ; }
87	private function getDefaultNormalizer ( ) { $ default = $ this -> getDefault ( ) ; $ trueRegex = $ this -> trueAnswerRegex ; $ falseRegex = $ this -> falseAnswerRegex ; return function ( $ answer ) use ( $ default , $ trueRegex , $ falseRegex ) { if ( is_bool ( $ answer ) ) { return $ answer ; } if ( empty ( $ answer ) && ! empty ( $ default ) ) { return $ default ; } if ( preg_match ( $ trueRegex , $ answer ) ) { return true ; } if ( preg_match ( $ falseRegex , $ answer ) ) { return false ; } return null ; } ; }
7410	public function offsetSet ( $ k , $ v ) { if ( null === $ k || ! array_key_exists ( $ k , $ this -> _container ) ) { $ v = ( is_object ( $ v ) && get_class ( $ v ) === $ this -> _type ) ? $ v : new $ this -> _type ( $ v ) ; if ( null === $ k ) { $ this -> _container [ ] = $ v ; } else { $ this -> _container [ $ k ] = $ v ; } return ; } if ( is_a ( $ this -> _type , AtomicInterface :: class , true ) ) { $ this -> _container [ $ k ] -> set ( $ v ) ; return ; } if ( is_a ( $ this -> _type , TypedAbstract :: class , true ) ) { $ this -> _container [ $ k ] -> replace ( $ v ) ; return ; } $ this -> _container [ $ k ] = new $ this -> _type ( $ v ) ; }
11077	public function getHttpAdapter ( ) { if ( null === $ this -> httpAdapter ) { $ this -> httpAdapter = new Curl ( ) ; $ this -> httpAdapter -> setOptions ( array ( 'sslverifypeer' => false , ) ) ; } return $ this -> httpAdapter ; }
10417	public function startPipeline ( $ prefix , $ target ) { if ( $ target === null ) { $ target = 'default' ; } $ this -> getPipelineFactory ( ) -> create ( $ prefix . $ target ) -> start ( ) ; }
1992	public static function getMetaData ( $ strData , $ strLanguage ) { if ( empty ( $ strLanguage ) ) { return array ( ) ; } $ arrData = StringUtil :: deserialize ( $ strData ) ; $ strLanguage = str_replace ( '-' , '_' , $ strLanguage ) ; if ( ! \ is_array ( $ arrData ) || ! isset ( $ arrData [ $ strLanguage ] ) ) { return array ( ) ; } return $ arrData [ $ strLanguage ] ; }
7526	public static function parseFile ( $ path , $ context = null ) { $ html_str = file_get_contents ( $ path , false , $ context ) ; return static :: parseStr ( $ html_str ) ; }
12396	public function where ( $ field , $ operator = null , $ value = null , $ logical = '&&' ) { if ( $ field instanceof Closure ) { $ this -> scope -> where .= $ this -> scope -> where == '' ? ' (' : $ logical . ' (' ; call_user_func ( $ field , $ this ) ; $ this -> scope -> where .= ') ' ; } else { $ logical = ( strlen ( $ this -> scope -> where ) <= 1 || substr ( $ this -> scope -> where , - 1 ) == '(' ) ? '' : $ logical ; $ this -> scope -> where .= Parser :: where ( $ field , $ operator , $ value , $ logical ) ; } return $ this ; }
4298	public function count ( $ label = null , $ flags = 0 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; if ( \ count ( $ args ) == 1 && \ is_int ( $ args [ 0 ] ) ) { $ label = null ; $ flags = $ args [ 0 ] ; } else { $ args = \ array_combine ( array ( 'label' , 'flags' ) , \ array_replace ( array ( null , 0 ) , $ args ) ) ; \ extract ( $ args ) ; } if ( isset ( $ label ) ) { $ dataLabel = ( string ) $ label ; } else { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ meta = \ array_merge ( array ( 'file' => $ callerInfo [ 'file' ] , 'line' => $ callerInfo [ 'line' ] , ) , $ meta ) ; $ label = 'count' ; $ dataLabel = $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] ; } if ( ! isset ( $ this -> data [ 'counts' ] [ $ dataLabel ] ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] = 0 ; } if ( ! ( $ flags & self :: COUNT_NO_INC ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] ++ ; } $ count = $ this -> data [ 'counts' ] [ $ dataLabel ] ; if ( ! ( $ flags & self :: COUNT_NO_OUT ) ) { $ this -> appendLog ( 'count' , array ( ( string ) $ label , $ count , ) , $ meta ) ; } return $ count ; }
2567	protected function checkAllNotEmpty ( ) { $ foundEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( empty ( $ arg ) ) { $ foundEmpty = true ; break ; } } return ! $ foundEmpty ; }
10822	public static function block ( $ messages , $ style ) { if ( is_string ( $ messages ) ) { $ messages = [ $ messages ] ; } if ( count ( $ messages ) > 0 ) { self :: writeln ( str_repeat ( ' ' , self :: $ lineLength ) , $ style ) ; foreach ( $ messages as $ message ) { $ message = ' ' . $ message ; while ( strlen ( $ message ) < self :: $ lineLength ) { $ message .= ' ' ; } self :: writeln ( $ message , $ style ) ; } self :: writeln ( str_repeat ( ' ' , self :: $ lineLength ) , $ style ) ; } }
9013	public function mediumtext ( string $ charset = null ) : self { $ this -> type = 'mediumtext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
4232	private static function getCommentContent ( $ what ) { $ reflector = null ; if ( \ is_object ( $ what ) ) { $ reflector = $ what instanceof \ Reflector ? $ what : new \ ReflectionObject ( $ what ) ; $ docComment = $ reflector -> getDocComment ( ) ; } else { $ docComment = $ what ; } $ docComment = \ preg_replace ( '#^/\*\*(.+)\*/$#s' , '$1' , $ docComment ) ; $ docComment = \ preg_replace ( '#^[ \t]*\*[ ]?#m' , '' , $ docComment ) ; $ docComment = \ trim ( $ docComment ) ; if ( $ reflector ) { if ( \ strtolower ( $ docComment ) == '{@inheritdoc}' ) { return self :: findInheritedDoc ( $ reflector ) ; } else { $ docComment = \ preg_replace_callback ( '/{@inheritdoc}/i' , function ( ) use ( $ reflector ) { $ phpDoc = self :: findInheritedDoc ( $ reflector ) ; return $ phpDoc [ 'description' ] ; } , $ docComment ) ; } } return $ docComment ; }
1443	protected function replaceApplicationNamespace ( & $ stub ) { $ namespace = rtrim ( $ this -> laravel -> getNamespace ( ) , '\\' ) ; $ stub = str_replace ( 'DummyApplicationNamespace' , $ namespace , $ stub ) ; return $ this ; }
9437	public function getMany ( $ n ) { if ( ! is_integer ( $ n ) || $ n < 2 ) { throw new \ InvalidArgumentException ( 'You must take 2 or more items in this case.' ) ; } $ arr_out = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr_out [ ] = $ this -> get ( ) ; } return $ arr_out ; }
12535	public function fetchByApplyId ( $ applyId , $ lastSeen , $ count ) { $ params = [ 'type' => 3 , 'apply_id' => intval ( $ applyId ) , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
10700	public static function isMobilePhoneNumber ( $ phone ) { $ phoneNumber = substr ( Tools :: removeSpace ( $ phone ) , - 9 , 1 ) ; return ( ! self :: isCzechPhoneNumber ( $ phoneNumber ) || ( $ phoneNumber === '6' || $ phoneNumber === '7' ) ) ; }
5406	protected function findFirstMatch ( $ cookie ) { for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { $ is_match = $ this -> isMatch ( $ cookie , $ this -> cookies [ $ i ] -> getHost ( ) , $ this -> cookies [ $ i ] -> getPath ( ) , $ this -> cookies [ $ i ] -> getName ( ) ) ; if ( $ is_match ) { return $ i ; } } return count ( $ this -> cookies ) ; }
6064	public function listMoodboards ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/moodboards' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new MoodboardResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
1143	protected function bootstrapViews ( ) { $ viewPath = realpath ( __DIR__ . '/../resources/views' ) ; $ this -> loadViewsFrom ( $ viewPath , 'jsvalidation' ) ; $ this -> publishes ( [ $ viewPath => $ this -> app [ 'path.base' ] . '/resources/views/vendor/jsvalidation' , ] , 'views' ) ; }
7375	public function clear ( ) { while ( ! $ this -> queue -> isEmpty ( ) ) { $ this -> queue -> pop ( ) ; } $ this -> queue = null ; }
12900	public function offsetGet ( $ offset ) { if ( $ offset === 'headers' ) { $ headers = [ 'HTTP/' . $ this -> getResponse ( ) -> getProtocolVersion ( ) . ' ' . $ this -> getResponse ( ) -> getStatusCode ( ) . ' ' . $ this -> getResponse ( ) -> getReasonPhrase ( ) ] ; foreach ( $ this -> getResponse ( ) -> getHeaders ( ) as $ header => $ values ) { foreach ( $ values as $ value ) { $ headers [ ] = $ header . ': ' . $ value ; } } return $ headers ; } }
8379	public function getNested ( $ keyString , $ default = null , $ separator = '.' ) { $ keys = explode ( $ separator , $ keyString ) ; $ data = $ this -> array ; foreach ( $ keys as $ key ) { if ( ! is_array ( $ data ) or ! array_key_exists ( $ key , $ data ) ) { return $ default ; } $ data = $ data [ $ key ] ; } return $ data ; }
7476	public function getEntitiesByIds ( $ identifier , array $ values ) { $ accessor = PropertyAccess :: createPropertyAccessor ( ) ; return array_filter ( is_array ( $ this -> entities ) ? $ this -> entities : $ this -> entities -> toArray ( ) , function ( $ entity ) use ( $ identifier , $ values , $ accessor ) { return in_array ( $ accessor -> getValue ( $ entity , $ identifier ) , $ values ) ; } ) ; }
2352	public function sendToBrowser ( $ filename = '' , $ inline = false ) { $ response = new BinaryFileResponse ( $ this -> strRootDir . '/' . $ this -> strFile ) ; $ response -> setContentDisposition ( $ inline ? ResponseHeaderBag :: DISPOSITION_INLINE : ResponseHeaderBag :: DISPOSITION_ATTACHMENT , $ filename , Utf8 :: toAscii ( $ this -> basename ) ) ; $ response -> headers -> addCacheControlDirective ( 'must-revalidate' ) ; $ response -> headers -> addCacheControlDirective ( 'post-check' , 0 ) ; $ response -> headers -> addCacheControlDirective ( 'pre-check' , 0 ) ; $ response -> headers -> set ( 'Connection' , 'close' ) ; throw new ResponseException ( $ response ) ; }
8582	public function setAny ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Any' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8465	public static function getUriMethods ( ) { $ root = str_replace ( $ _SERVER [ 'DOCUMENT_ROOT' ] , '' , getcwd ( ) ) ; $ subfolder = trim ( $ root , '/' ) ; return trim ( str_replace ( $ subfolder , '' , self :: getUri ( ) ) , '/' ) ; }
4090	public function delete ( $ id = false , $ index , $ type , array $ options = array ( ) ) { $ params = array ( '_id' => $ id , '_index' => $ index , '_type' => $ type ) ; foreach ( $ options as $ key => $ value ) { $ params [ '_' . $ key ] = $ value ; } $ operation = array ( array ( 'delete' => $ params ) ) ; $ this -> operations [ ] = $ operation ; return $ this ; }
11762	public static function get ( $ property , $ default = NULL ) { $ object = new \ ReflectionClass ( Collection :: class ) ; $ value = $ object -> getStaticPropertyValue ( $ property ) ; return ( empty ( $ value ) ) ? $ default : $ value ; }
11344	public function removeField ( $ name ) { for ( $ i = 0 ; $ i < count ( $ this -> fields ) ; $ i ++ ) { if ( $ this -> fields [ $ i ] -> getName ( ) == $ name ) { array_splice ( $ this -> fields , $ i , 1 ) ; break ; } } }
9207	public function importTable ( Table $ Table , $ records , array $ options = [ ] ) { $ defaultOptions = [ 'checkRules' => true , 'checkExisting' => true , ] ; $ options = $ options + $ defaultOptions ; foreach ( $ records as $ record ) { $ action = ( $ record -> isNew ( ) ? 'Create' : 'Update' ) ; $ result = $ Table -> save ( $ record , $ options ) ; $ key = $ this -> findKey ( $ Table , $ record ) ; if ( $ result ) { $ this -> verbose ( "<success>{$Table->alias()} ({$key}): {$action} successful.</success>" ) ; } else { $ this -> quiet ( "<warning>{$Table->alias()} ({$key}): {$action} failed.</warning>" ) ; $ this -> printValidationErrors ( $ Table -> alias ( ) , $ this -> findKey ( $ Table , $ record ) , $ record -> errors ( ) ) ; } } }
945	private function setOption ( $ name , $ value ) { if ( ! \ array_key_exists ( $ name , $ this -> options ) ) { throw new InvalidConfigurationException ( sprintf ( 'Unknown option name: "%s".' , $ name ) ) ; } $ this -> options [ $ name ] = $ value ; }
306	public function getSizeLimit ( ) { $ limit = $ this -> sizeToBytes ( ini_get ( 'upload_max_filesize' ) ) ; $ postLimit = $ this -> sizeToBytes ( ini_get ( 'post_max_size' ) ) ; if ( $ postLimit > 0 && $ postLimit < $ limit ) { Yii :: warning ( 'PHP.ini\'s \'post_max_size\' is less than \'upload_max_filesize\'.' , __METHOD__ ) ; $ limit = $ postLimit ; } if ( $ this -> maxSize !== null && $ limit > 0 && $ this -> maxSize < $ limit ) { $ limit = $ this -> maxSize ; } if ( isset ( $ _POST [ 'MAX_FILE_SIZE' ] ) && $ _POST [ 'MAX_FILE_SIZE' ] > 0 && $ _POST [ 'MAX_FILE_SIZE' ] < $ limit ) { $ limit = ( int ) $ _POST [ 'MAX_FILE_SIZE' ] ; } return $ limit ; }
8554	public function setLoanServicingEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LoanServicingEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7911	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; SemanticUiPluginAsset :: register ( $ view ) ; $ selector = $ this -> selector ? : '#' . $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('$selector').$name($options);" ; $ view -> registerJs ( $ js ) ; } if ( ! empty ( $ this -> clientEvents ) ) { $ js = [ ] ; foreach ( $ this -> clientEvents as $ event => $ handler ) { $ handler = $ handler instanceof JsExpression ? $ handler : new JsExpression ( $ handler ) ; $ js [ ] = "jQuery('$selector').$name('setting', '$event', $handler);" ; } $ view -> registerJs ( implode ( "\n" , $ js ) ) ; } }
12031	function addCreateAndExecuteMethod ( ) { $ methodGenerator = new MethodGenerator ( 'createAndExecute' ) ; $ body = '' ; $ body .= $ this -> generateCreateFragment ( ) ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= PHP_EOL ; $ body .= 'return $response;' . PHP_EOL ; ; $ docBlock = new DocBlockGenerator ( 'Create and execute the operation, returning the raw response from the server.' , null ) ; $ tags [ ] = new GenericTag ( 'return' , '\Amp\Artax\Response' ) ; $ docBlock -> setTags ( $ tags ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
8060	private function createWorker ( $ i ) { $ sockets = array ( ) ; if ( socket_create_pair ( AF_UNIX , SOCK_STREAM , 0 , $ sockets ) === FALSE ) { throw new \ RuntimeException ( 'socket_create_pair failed.' ) ; return ; } $ processId = pcntl_fork ( ) ; if ( $ processId < 0 ) { throw new \ RuntimeException ( 'pcntl_fork failed.' ) ; return ; } elseif ( $ processId === 0 ) { $ this -> workerProcesses = new ProcessDetailsCollection ( ) ; $ this -> workerPoolSize = 0 ; socket_close ( $ sockets [ 1 ] ) ; $ this -> runWorkerProcess ( $ this -> worker , new SimpleSocket ( $ sockets [ 0 ] ) , $ i ) ; } else { socket_close ( $ sockets [ 0 ] ) ; $ this -> workerProcesses -> addFree ( new ProcessDetails ( $ processId , new SimpleSocket ( $ sockets [ 1 ] ) ) ) ; } }
1933	protected function getLocaleString ( ) { $ container = System :: getContainer ( ) ; return 'var Contao={' . 'theme:"' . Backend :: getTheme ( ) . '",' . 'lang:{' . 'close:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'close' ] . '",' . 'collapse:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] . '",' . 'expand:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] . '",' . 'loading:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'loadingData' ] . '",' . 'apply:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'apply' ] . '"' . '},' . 'script_url:"' . $ container -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) . '",' . 'path:"' . Environment :: get ( 'path' ) . '",' . 'request_token:"' . REQUEST_TOKEN . '",' . 'referer_id:"' . $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) . '"' . '};' ; }
7504	public function getTf ( string $ key , array $ args = null , array $ replacements = null , string ... $ namespaces ) { if ( empty ( $ namespaces ) ) { $ namespaces = $ this -> meta -> getNamespaces ( ) ; } $ translatedText = $ this -> textService -> tf ( $ namespaces , $ key , $ args , ... $ this -> meta -> getN2nLocales ( ) ) ; $ replacedText = HtmlBuilderMeta :: replace ( $ translatedText , $ replacements , $ this -> view ) ; return new Raw ( $ replacedText ) ; }
6780	protected function updateExchangeRate ( SaleInterface $ sale ) { if ( null !== $ sale -> getExchangeRate ( ) ) { return false ; } $ date = $ sale -> getExchangeDate ( ) ?? new \ DateTime ( ) ; $ rate = $ this -> currencyConverter -> getRate ( $ this -> currencyConverter -> getDefaultCurrency ( ) , $ sale -> getCurrency ( ) -> getCode ( ) , $ date ) ; $ sale -> setExchangeRate ( $ rate ) -> setExchangeDate ( $ date ) ; return true ; }
11083	public static function passwdGen ( $ length = 8 , $ flag = 'ALPHANUMERIC' ) { switch ( $ flag ) { case 'NUMERIC' : $ str = '0123456789' ; break ; case 'ALPHA' : $ str = 'abcdefghijkmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; case 'ALPHA_LOWER' : $ str = 'abcdefghijkmnopqrstuvwxyz' ; break ; default : $ str = 'abcdefghijkmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; } for ( $ i = 0 , $ passwd = '' ; $ i < $ length ; $ i ++ ) { $ passwd .= substr ( $ str , mt_rand ( 0 , \ strlen ( $ str ) - 1 ) , 1 ) ; } return $ passwd ; }
6735	public function getMiddleware ( $ name ) : Middleware { if ( ! array_key_exists ( $ name , $ this -> namedMiddleware ) ) { throw new \ UnexpectedValueException ( "No middleware registered under name '{$name}'" ) ; } return $ this -> namedMiddleware [ $ name ] ; }
10565	protected function formatJson ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/json; charset=UTF-8' ) ; if ( $ response -> data !== null ) { $ options = $ this -> encodeOptions ; if ( $ this -> prettyPrint ) { $ options |= JSON_PRETTY_PRINT ; } $ response -> content = Json :: encode ( $ response -> data , $ options ) ; } }
6420	public function stop ( ) : Stopwatch { $ tick = $ this -> ticker -> read ( ) ; Preconditions :: checkState ( $ this -> isRunning , 'This stopwatch is already stopped.' ) ; $ this -> isRunning = false ; $ this -> elapsedMicros += ( $ tick - $ this -> startTick ) ; return $ this ; }
1765	public function colorize ( $ row , $ label ) { switch ( $ row [ 'action' ] ) { case 'CONFIGURATION' : case 'REPOSITORY' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_blue">$2</span>' , $ label ) ; break ; case 'CRON' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_green">$2</span>' , $ label ) ; break ; case 'ERROR' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_red">$2</span>' , $ label ) ; break ; default : if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ label = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ row , $ label ) ; } } break ; } return '<div class="ellipsis">' . $ label . '</div>' ; }
2914	public function formatStacktrace ( array $ trace , $ stripFilepath = '' , $ trimPath = '' ) { $ out = '' ; foreach ( $ trace as $ index => $ row ) { if ( $ stripFilepath && isset ( $ row [ 'file' ] ) && strpos ( $ row [ 'file' ] , $ stripFilepath ) !== false ) { continue ; } if ( $ trimPath && isset ( $ row [ 'file' ] ) ) { $ row [ 'file' ] = str_replace ( $ trimPath , '' , $ row [ 'file' ] ) ; } if ( isset ( $ row [ 'file' ] ) ) { $ out .= "[$index] {$row['file']}:{$row['line']}\n" ; } else { $ out .= "[$index] (?) {$row['class']}:{$row['function']}\n" ; } } return $ out ; }
11783	public function add ( $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_ADD , $ params ] ) ; }
2695	public function execute ( Observer $ observer ) { if ( $ this -> fastlyConfig -> isFastlyEnabled ( ) != true ) { return ; } $ this -> response -> setHeader ( "x-esi" , "1" ) ; }
11081	public static function GUIDv4 ( ) { return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x' , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0x0fff ) | 0x4000 , mt_rand ( 0 , 0x3fff ) | 0x8000 , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) ) ; }
5531	protected function chainThrowMethods ( ) { $ code = " function throwOn(\$method, \$exception = false, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->throwOn(\$method, \$exception, \$args);\n" ; $ code .= " }\n" ; $ code .= " function throwAt(\$timing, \$method, \$exception = false, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->throwAt(\$timing, \$method, \$exception, \$args);\n" ; $ code .= " }\n" ; $ code .= " function errorOn(\$method, \$error = 'A mock error', \$args = false, \$severity = E_USER_ERROR) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->errorOn(\$method, \$error, \$args, \$severity);\n" ; $ code .= " }\n" ; $ code .= " function errorAt(\$timing, \$method, \$error = 'A mock error', \$args = false, \$severity = E_USER_ERROR) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->errorAt(\$timing, \$method, \$error, \$args, \$severity);\n" ; $ code .= " }\n" ; return $ code ; }
3103	public function load ( ) { $ storage = $ this -> getStorage ( ) ; if ( $ storage ) { $ data = $ storage -> get ( $ this -> userId , $ this -> getStorageKey ( ) ) ; if ( $ data ) { $ this -> state = json_decode ( $ data , true ) ; } else { $ this -> state = [ ] ; } $ success = is_array ( $ this -> state ) ; } else { $ success = false ; } return $ success ; }
7132	protected function updateExchangeRate ( SupplierOrderInterface $ order ) { if ( null !== $ order -> getExchangeRate ( ) ) { return false ; } if ( ! SupplierOrderStates :: isStockableState ( $ order -> getState ( ) ) ) { return false ; } $ date = new \ DateTime ( ) ; $ rate = $ this -> currencyConverter -> getRate ( $ this -> currencyConverter -> getDefaultCurrency ( ) , $ order -> getCurrency ( ) -> getCode ( ) , $ date ) ; $ order -> setExchangeRate ( $ rate ) -> setExchangeDate ( $ date ) ; return true ; }
2197	public function onAuthenticationSuccess ( Request $ request , TokenInterface $ token ) : RedirectResponse { $ this -> user = $ token -> getUser ( ) ; if ( ! $ this -> user instanceof User ) { return $ this -> getRedirectResponse ( $ request ) ; } $ this -> user -> lastLogin = $ this -> user -> currentLogin ; $ this -> user -> currentLogin = time ( ) ; $ this -> user -> save ( ) ; if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has logged in' , $ this -> user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ this -> user -> username ) ] ) ; } $ this -> triggerPostLoginHook ( ) ; return $ this -> getRedirectResponse ( $ request ) ; }
3888	public function getAttributeNames ( \ DC_Table $ objDc ) { $ attributeNames = [ 'sorting' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodels_sorting' ] , 'random' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'random' ] , 'id' => $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'id' ] [ 0 ] ] ; $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ objDc -> activeRecord -> metamodel ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( $ metaModel ) { foreach ( $ metaModel -> getAttributes ( ) as $ objAttribute ) { $ attributeNames [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; } } return $ attributeNames ; }
6936	private function findBySubjectAndStates ( StockSubjectInterface $ subject , array $ states = [ ] ) { $ units = [ ] ; $ oid = spl_object_hash ( $ subject ) ; if ( isset ( $ this -> addedUnits [ $ oid ] ) ) { $ units = $ this -> addedUnits [ $ oid ] ; } if ( ! empty ( $ units ) && ! empty ( $ states ) ) { $ units = array_filter ( $ units , function ( StockUnitInterface $ unit ) use ( $ states ) { return in_array ( $ unit -> getState ( ) , $ states ) ; } ) ; } return $ units ; }
4432	protected function getRunner ( & $ errors ) { $ output = $ this -> output ; $ runner = function ( $ err ) use ( $ output , & $ errors ) { if ( ! empty ( $ err ) ) { $ output -> writeln ( '<fg=red>FAILED</>' ) ; $ errors = array_merge ( $ errors , $ err ) ; } else { $ output -> writeln ( '<info>OK</info>' ) ; } } ; return $ runner ; }
1536	protected function fillRelationships ( $ record , Collection $ relationships , EncodingParametersInterface $ parameters ) { $ relationships -> filter ( function ( $ value , $ field ) use ( $ record ) { return $ this -> isFillableRelation ( $ field , $ record ) ; } ) -> each ( function ( $ value , $ field ) use ( $ record , $ parameters ) { $ this -> fillRelationship ( $ record , $ field , $ value , $ parameters ) ; } ) ; }
12221	private function logException ( Exception $ exception ) { if ( in_array ( $ exception -> getStatusCode ( ) , $ this -> doNotLog ) ) { return ; } $ message = sprintf ( 'Uncaught exception of type %s thrown in file %s at line %s%s.' , get_class ( $ exception ) , $ exception -> getFile ( ) , $ exception -> getLine ( ) , $ exception -> getMessage ( ) ? sprintf ( ' with message "%s"' , $ exception -> getMessage ( ) ) : '' ) ; $ this -> container [ 'log' ] -> error ( $ message , array ( 'exception' => $ exception , 'Exception message' => $ message , 'Exception line' => $ exception -> getLine ( ) , 'Exception trace' => $ exception -> getTraceAsString ( ) , ) ) ; }
12316	public function editAction ( Request $ request , Category $ category ) { $ deleteForm = $ this -> createDeleteForm ( $ category ) ; $ editForm = $ this -> createForm ( 'BlogBundle\Form\CategoryType' , $ category ) ; $ editForm -> handleRequest ( $ request ) ; if ( $ editForm -> isSubmitted ( ) && $ editForm -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ category ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'category.edited' ) ; return $ this -> redirectToRoute ( 'blog_category_index' ) ; } return array ( 'entity' => $ category , 'edit_form' => $ editForm -> createView ( ) , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
4709	public function initialize ( Text $ text ) { $ text -> replaceString ( "\r\n" , "\n" ) ; $ text -> replaceString ( "\r" , "\n" ) ; $ text -> append ( "\n\n" ) ; $ this -> markdown -> emit ( 'detab' , array ( $ text ) ) ; $ text -> replace ( '/^[ \t]+$/m' , '' ) ; }
8626	public function setTermsAndConditionsNotAcceptedCarrierList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'TermsAndConditionsNotAcceptedCarrierList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2839	public function getFilteredRequestListUrl ( $ filters = array ( ) ) { $ currentFilters = Mage :: helper ( 'sheep_debug/filter' ) -> getRequestFilters ( $ this -> getRequest ( ) ) ; $ filters = array_merge ( $ currentFilters , $ filters ) ; return $ this -> getRequestListUrl ( $ filters ) ; }
5877	protected static function findExistingFile ( $ fileName ) { $ file = null ; $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( isset ( $ storageConfiguration [ 'basePath' ] ) ) { $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ row = GeneralUtility :: makeInstance ( ConnectionPool :: class ) -> getConnectionForTable ( 'sys_file' ) -> select ( [ 'uid' ] , 'sys_file' , [ 'storage' => $ targetFolder -> getStorage ( ) -> getUid ( ) , 'identifier' => $ identifier , ] ) -> fetch ( ) ; if ( ! empty ( $ row [ 'uid' ] ) ) { $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ file = $ fileRepository -> findByUid ( $ row [ 'uid' ] ) ; } } return $ file ; }
3736	protected function updateVariants ( $ item , $ activeLanguage , $ allIds , $ baseAttributes = false ) { foreach ( $ this -> getAttributes ( ) as $ strAttributeId => $ objAttribute ) { if ( ! $ item -> isAttributeSet ( $ objAttribute -> getColName ( ) ) ) { continue ; } if ( ! $ baseAttributes && $ item -> isVariant ( ) && ! ( $ objAttribute -> get ( 'isvariant' ) ) ) { continue ; } if ( $ item -> isVariantBase ( ) && ! ( $ objAttribute -> get ( 'isvariant' ) ) ) { $ arrIds = $ allIds ; } else { $ arrIds = array ( $ item -> get ( 'id' ) ) ; } $ this -> saveAttribute ( $ objAttribute , $ arrIds , $ item -> get ( $ strAttributeId ) , $ activeLanguage ) ; } }
9613	public function register ( Container $ app ) { $ app [ 'guzzle.handler_stack' ] = function ( ) { $ stack = HandlerStack :: create ( ) ; return $ stack ; } ; $ app [ 'guzzle' ] = function ( ) use ( $ app ) { $ client = new HttpClient ( [ 'handler' => $ app [ 'guzzle.handler_stack' ] ] ) ; return $ client ; } ; }
398	public function delete ( ) { if ( ! $ this -> isTransactional ( self :: OP_DELETE ) ) { return $ this -> deleteInternal ( ) ; } $ transaction = static :: getDb ( ) -> beginTransaction ( ) ; try { $ result = $ this -> deleteInternal ( ) ; if ( $ result === false ) { $ transaction -> rollBack ( ) ; } else { $ transaction -> commit ( ) ; } return $ result ; } catch ( \ Exception $ e ) { $ transaction -> rollBack ( ) ; throw $ e ; } catch ( \ Throwable $ e ) { $ transaction -> rollBack ( ) ; throw $ e ; } }
10664	public function withRequest ( RequestInterface $ request ) { $ object = clone $ this ; $ object -> request = $ request ; $ object -> method = $ request -> getMethod ( ) ; return $ object ; }
6402	public static function register ( ) { set_error_handler ( function ( $ code , $ message , $ file , $ line , $ context ) { if ( error_reporting ( ) == 0 ) { return false ; } ErrorType :: forCode ( $ code ) -> throwException ( $ message , $ file , $ line , $ context ) ; } ) ; }
7838	public function create ( string $ name , array $ numbers ) : ? array { $ body = Body :: json ( [ [ 'name' => $ name , 'phone_numbers' => $ numbers , ] , ] ) ; $ response = Request :: post ( $ this -> baseUrl . 'contact' , [ ] , $ body ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
8113	public function getReviewDate ( SiteTree $ page = null ) { if ( $ page === null ) { $ page = $ this -> owner ; } if ( $ page -> obj ( 'NextReviewDate' ) -> exists ( ) ) { return $ page -> obj ( 'NextReviewDate' ) ; } $ options = $ this -> owner -> getOptions ( ) ; if ( ! $ options ) { return false ; } if ( ! $ options -> ReviewPeriodDays ) { return false ; } $ nextReviewUnixSec = strtotime ( ' + ' . $ options -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ date = DBDate :: create ( 'NextReviewDate' ) ; $ date -> setValue ( $ nextReviewUnixSec ) ; return $ date ; }
139	public function uninstall ( RepositoryInterface $ repo , UninstallOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; $ installer -> uninstall ( $ repo , $ package ) ; }
4044	private function removeInvariantAttributes ( IItem $ nativeItem , ICollection $ renderSetting ) { $ model = $ nativeItem -> getMetaModel ( ) ; if ( $ model -> hasVariants ( ) && ! $ nativeItem -> isVariantBase ( ) ) { $ renderSetting = clone $ renderSetting ; foreach ( array_keys ( $ model -> getInVariantAttributes ( ) ) as $ strAttrName ) { $ renderSetting -> setSetting ( $ strAttrName , null ) ; } } return $ renderSetting ; }
12389	protected function updateCredentialHash ( PasswordableInterface $ identityObject , $ password ) { $ cryptoService = $ this -> getMapper ( ) -> getPasswordService ( ) ; if ( ! $ cryptoService instanceof Bcrypt ) { return $ this ; } $ hash = explode ( '$' , $ identityObject -> getPassword ( ) ) ; if ( $ hash [ 2 ] === $ cryptoService -> getCost ( ) ) { return $ this ; } $ identityObject -> setPassword ( $ cryptoService -> create ( $ password ) ) ; return $ this ; }
6540	public function load ( array $ identifier , $ propertyName , $ shardingKey = null ) { if ( isset ( $ identifier [ $ propertyName ] ) ) { return array ( $ propertyName => $ identifier [ $ propertyName ] ) ; } $ field = $ this -> getFieldNameFromProperty ( $ propertyName ) ; $ sources = $ this -> getSourcesFromPropertyName ( $ propertyName ) ; foreach ( $ sources as $ sourceName ) { $ source = $ this -> sourceManager -> getSource ( $ sourceName ) ; if ( $ source -> canHandle ( $ field ) ) { $ mappedIdentifiers = array ( ) ; foreach ( $ identifier as $ id => $ value ) { $ fieldName = $ this -> getFieldNameFromProperty ( $ id ) ; if ( $ source -> canHandle ( $ fieldName ) ) { $ mappedIdentifiers [ $ fieldName ] = $ value ; } } $ datas = $ source -> load ( $ mappedIdentifiers , false , $ shardingKey ) ; $ mappedDatas = $ this -> mapFieldsToProperties ( $ datas , $ sourceName ) ; return $ mappedDatas ; } } throw new \ Exception ( "No source support field $field from property $propertyName in {$this->name}" ) ; }
7140	protected function handleQuantityChange ( SupplierDeliveryItemInterface $ item ) { $ changeSet = $ this -> persistenceHelper -> getChangeSet ( $ item ) ; if ( null === $ orderItem = $ item -> getOrderItem ( ) ) { throw new RuntimeException ( "Failed to retrieve order item." ) ; } if ( null !== $ stockUnit = $ orderItem -> getStockUnit ( ) ) { if ( 0 != $ deltaQuantity = floatval ( $ changeSet [ 'quantity' ] [ 1 ] ) - floatval ( $ changeSet [ 'quantity' ] [ 0 ] ) ) { $ this -> stockUnitUpdater -> updateReceived ( $ stockUnit , $ deltaQuantity , true ) ; } } elseif ( $ orderItem -> hasSubjectIdentity ( ) ) { throw new RuntimeException ( "Failed to retrieve stock unit." ) ; } if ( null === $ order = $ orderItem -> getOrder ( ) ) { throw new RuntimeException ( "Failed to retrieve order." ) ; } $ this -> scheduleSupplierOrderContentChangeEvent ( $ order ) ; }
7485	public function charAt ( $ index ) { $ index = ( int ) $ index ; if ( $ index < 0 || $ index >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_substr ( $ this -> string , $ index , 1 , $ this -> encoding ) ; }
6820	protected function writeInvoiceTaxesLine ( ) { $ sale = $ this -> invoice -> getSale ( ) ; $ date = $ sale -> getCreatedAt ( ) ; $ credit = $ this -> invoice -> getType ( ) === InvoiceTypes :: TYPE_CREDIT ; foreach ( $ this -> invoice -> getTaxesDetails ( ) as $ detail ) { $ amount = $ this -> round ( $ detail [ 'amount' ] ) ; if ( 0 === $ this -> compare ( $ amount , 0 ) ) { continue ; } $ account = $ this -> getTaxAccountNumber ( $ detail [ 'rate' ] , $ this -> invoice -> getNumber ( ) ) ; if ( $ credit ) { $ this -> writer -> credit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance -= $ amount ; } else { $ this -> writer -> debit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance += $ amount ; } } }
1598	protected function validateAllFields ( ) : bool { $ duplicates = collect ( ( array ) $ this -> dataGet ( 'attributes' , [ ] ) ) -> intersectByKeys ( ( array ) $ this -> dataGet ( 'relationships' , [ ] ) ) -> keys ( ) ; $ this -> resourceFieldsExistInAttributesAndRelationships ( $ duplicates ) ; return $ duplicates -> isEmpty ( ) ; }
7211	public function validateLoginToken ( string $ token ) : ? array { $ token = base64_decode ( $ token ) ; $ serializedData = Security :: decrypt ( $ token , $ this -> getKey ( ) , $ this -> getSalt ( ) ) ; if ( $ serializedData === false ) { return null ; } $ data = unserialize ( $ serializedData ) ; if ( ! empty ( $ data [ 'expireInterval' ] ) && ! empty ( $ data [ 'timestamp' ] ) ) { $ tokenCreated = new Time ( $ data [ 'timestamp' ] ) ; if ( ! $ tokenCreated -> wasWithinLast ( $ data [ 'expireInterval' ] ) ) { return null ; } } return $ data ; }
6072	public function updateMedia ( $ id , Media $ media ) { if ( $ media instanceof MediaResponse ) { $ media = new Media ( json_decode ( json_encode ( $ media ) , true ) ) ; } $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'media' => $ media ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
6043	public function addUsage ( $ sessionId , MediaUsage $ mediaUsage ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaUsage' => $ mediaUsage ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/usage' , $ parameters ) ; $ result = new MediaUsageResponse ( $ result ) ; return $ result ; }
2560	private function checkAndCreateMopDetailedData ( $ fopType ) { if ( is_null ( $ this -> paymentModule -> mopDetailedData ) ) { $ this -> paymentModule -> mopDetailedData = new MopDetailedData ( $ fopType ) ; } }
10248	public function getGuid ( ) { return sprintf ( '%04x%04x-%04x-%03x4-%04x-%04x%04x%04x' , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 4095 ) , bindec ( substr_replace ( sprintf ( '%016b' , mt_rand ( 0 , 65535 ) ) , '01' , 6 , 2 ) ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) ) ; }
3205	protected function get_docblock_tags ( $ comment_opener ) { $ tags = array ( ) ; $ opener = $ this -> tokens [ $ comment_opener ] ; if ( ! isset ( $ opener [ 'comment_tags' ] ) ) { return $ tags ; } $ closer = null ; if ( isset ( $ opener [ 'comment_closer' ] ) ) { $ closer = $ opener [ 'comment_closer' ] ; } $ tag_count = count ( $ opener [ 'comment_tags' ] ) ; for ( $ i = 0 ; $ i < $ tag_count ; $ i ++ ) { $ tag_token = $ opener [ 'comment_tags' ] [ $ i ] ; $ tag = trim ( $ this -> tokens [ $ tag_token ] [ 'content' ] , '@' ) ; $ search_end = $ closer ; if ( ( $ i + 1 ) < $ tag_count ) { $ search_end = $ opener [ 'comment_tags' ] [ ( $ i + 1 ) ] ; } $ value_token = $ this -> phpcsFile -> findNext ( T_DOC_COMMENT_STRING , ( $ tag_token + 1 ) , $ search_end ) ; $ tags [ $ tag ] = trim ( $ this -> tokens [ $ value_token ] [ 'content' ] ) ; unset ( $ tag_token , $ tag , $ search_end , $ value ) ; } return $ tags ; }
9074	protected function getRouteInformation ( Route $ route ) { return $ this -> filterRoute ( [ 'name' => $ route -> getName ( ) , 'isAuthorized' => $ this -> isAuthorized ( $ route ) , ] ) ; }
11272	protected function handleResponseContent ( ResponseInterface $ response , $ contentType = null ) { $ contents = $ response -> getBody ( ) -> getContents ( ) ; if ( ! $ contentType ) { $ contentTypeHeaderLine = $ response -> getHeaderLine ( 'Content-Type' ) ; if ( stripos ( $ contentTypeHeaderLine , 'application/json' ) !== false ) { $ contentType = 'json' ; } elseif ( stripos ( $ contentTypeHeaderLine , 'application/xml' ) !== false ) { $ contentType = 'xml' ; } } if ( $ contentType ) { return Parser :: data ( $ contents ) -> from ( $ contentType ) -> toArray ( ) ; } return $ contents ; }
7584	protected function extractResponse ( $ curlResponse ) { $ this -> headers = substr ( $ curlResponse , 0 , $ this -> info [ 'header_size' ] ) ; $ this -> body = substr ( $ curlResponse , $ this -> info [ 'header_size' ] ) ; }
3230	static function loadFromJson ( $ jsonObj ) { $ authHost = null ; if ( array_key_exists ( 'auth_host' , $ jsonObj ) ) { $ authHost = $ jsonObj [ "auth_host" ] ; if ( ! is_string ( $ authHost ) ) { throw new HostLoadException ( "Optional field \"auth_host\" must be a string" ) ; } } $ hostSuffix = null ; if ( array_key_exists ( 'host_suffix' , $ jsonObj ) ) { $ hostSuffix = $ jsonObj [ "host_suffix" ] ; if ( ! is_string ( $ hostSuffix ) ) { throw new HostLoadException ( "Optional field \"host_suffix\" must be a string" ) ; } } if ( $ authHost === null && $ hostSuffix === null ) return null ; if ( $ authHost === null ) { throw new HostLoadException ( "Can't provide \"host_suffix\" without providing \"auth_host\"." ) ; } if ( $ hostSuffix === null ) { throw new HostLoadException ( "Can't provide \"auth_host\" without providing \"host_suffix\"." ) ; } $ api = "api" . $ hostSuffix ; $ content = "content" . $ hostSuffix ; $ web = $ authHost ; return new Host ( $ api , $ content , $ web ) ; }
11968	public static function GetAuthClass ( ) { if ( self :: $ authClass === NULL ) { if ( class_exists ( self :: AUTH_CLASS_FULL ) ) { self :: $ authClass = self :: AUTH_CLASS_FULL ; } else { self :: $ authClass = self :: AUTH_CLASS_BASIC ; } } return self :: $ authClass ; }
5441	public function parse ( $ raw ) { if ( ! isset ( $ this -> parser ) ) { return false ; } $ length = strlen ( $ raw ) ; while ( is_array ( $ parsed = $ this -> reduce ( $ raw ) ) ) { list ( $ raw , $ unmatched , $ matched , $ mode ) = $ parsed ; if ( ! $ this -> dispatchTokens ( $ unmatched , $ matched , $ mode ) ) { return false ; } if ( $ raw === '' ) { return true ; } if ( strlen ( $ raw ) == $ length ) { return false ; } $ length = strlen ( $ raw ) ; } if ( ! $ parsed ) { return false ; } return $ this -> invokeParser ( $ raw , LEXER_UNMATCHED ) ; }
11374	private function getInjectHint ( \ ReflectionMethod $ method , \ ReflectionParameter $ parameter ) { $ hint = Psi :: it ( $ this -> reader -> getMethodAnnotations ( $ method ) ) -> filter ( new IsInstanceOf ( Di \ DiInjectHintAnnotation :: class ) ) -> filter ( function ( Di \ DiInjectHintAnnotation $ i ) use ( $ parameter ) { return $ i -> getParameter ( ) === $ parameter -> getName ( ) ; } ) -> getFirst ( ) ; if ( $ hint !== null ) { return $ hint ; } try { if ( $ parameter -> getClass ( ) === null ) { throw new \ InvalidArgumentException ( "Cannot inject constructor-param '{$parameter->getName()}' into {$method->getDeclaringClass()->getName()}. " . 'The parameter does not have a an @Inject hint and it has no type-hint.' ) ; } } catch ( \ ReflectionException $ e ) { } return Di \ Inject \ ByType :: create ( $ parameter -> getName ( ) , Util :: normalizeFqcn ( ( string ) $ parameter -> getType ( ) ) ) ; }
10570	protected function parseSort ( string $ sort , array & $ sorts ) { if ( strlen ( trim ( $ sort ) ) === 0 ) { return ; } if ( substr ( $ sort , 0 , 1 ) == "[" ) { $ json = json_decode ( $ sort ) ; if ( is_array ( $ json ) ) { foreach ( $ json as $ s ) { if ( is_object ( $ s ) ) { $ sorts [ $ s -> property ] = strcasecmp ( self :: DESC , $ s -> direction ) !== 0 ; } } return ; } } if ( substr ( $ sort , - 4 ) == ",asc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 4 ) ] = true ; } elseif ( substr ( $ sort , - 5 ) == ",desc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 5 ) ] = false ; } elseif ( substr ( $ sort , - 10 ) == ":ascending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 10 ) ] = true ; } elseif ( substr ( $ sort , - 11 ) == ":descending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 11 ) ] = false ; } else { foreach ( explode ( ',' , $ sort ) as $ s ) { if ( substr ( $ s , 0 , 1 ) === '-' ) { $ sorts [ substr ( $ s , 1 ) ] = false ; } elseif ( substr ( $ s , 0 , 1 ) === '+' ) { $ sorts [ substr ( $ s , 1 ) ] = true ; } else { $ sorts [ $ s ] = true ; } } } }
2315	protected function prepareImportantPart ( ) { $ importantPart = $ this -> getImportantPart ( ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ importantPart = array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight , ) ; $ mode = explode ( '_' , $ this -> resizeMode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } } if ( ! $ importantPart [ 'width' ] || ! $ importantPart [ 'height' ] ) { return null ; } return new ImportantPart ( new Point ( $ importantPart [ 'x' ] , $ importantPart [ 'y' ] ) , new Box ( $ importantPart [ 'width' ] , $ importantPart [ 'height' ] ) ) ; }
3441	protected function normalizePropertyFormat ( ) { if ( empty ( $ this -> fields [ 'PROPERTIES' ] ) ) { return ; } foreach ( $ this -> fields [ 'PROPERTIES' ] as $ code => $ prop ) { $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE' ] = $ prop [ 'VALUE' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_VALUE' ] = $ prop [ '~VALUE' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ 'DESCRIPTION' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ '~DESCRIPTION' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE_ID' ] = $ prop [ 'PROPERTY_VALUE_ID' ] ; } }
4284	public function url_stat ( $ path , $ flags ) { self :: restorePrev ( ) ; if ( ! \ file_exists ( $ path ) ) { $ info = false ; } elseif ( $ flags & STREAM_URL_STAT_LINK ) { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ lstat ( $ path ) : \ lstat ( $ path ) ; } else { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ stat ( $ path ) : \ stat ( $ path ) ; } self :: register ( ) ; return $ info ; }
5987	public function setCreatedRange ( $ createdRange ) { if ( $ createdRange instanceof DateTimeRange ) { $ this -> createdRange = $ createdRange ; } elseif ( is_array ( $ createdRange ) ) { $ this -> createdRange = new DateTimeRange ( $ createdRange ) ; } else { $ this -> createdRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
986	public function confirmationUrl ( ) { $ charge = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}.json" , [ "{$this->plan->typeAsString()}" => $ this -> chargeParams ( ) ] ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ charge -> confirmation_url ; }
12481	public function registerServices ( ServicesFactory $ servicesFactory , array $ entityManagers ) { foreach ( $ entityManagers as $ name => $ entityManager ) { $ emConfig = Setup :: createAnnotationMetadataConfiguration ( ( array ) $ entityManager -> getEntities ( ) , true , null , null , true ) ; $ emConfig -> setNamingStrategy ( new UnderscoreNamingStrategy ( ) ) ; $ em = $ this -> createEntityManager ( $ entityManager -> toArray ( ) , $ emConfig ) ; $ emServiceId = 'doctrine.em.' . Str :: cast ( $ name ) -> lower ( ) ; $ servicesFactory -> registerService ( [ 'id' => $ emServiceId , 'instance' => $ em ] ) ; $ servicesFactory -> registerService ( [ 'id' => 'db.connection.' . $ name , 'instance' => $ em -> getConnection ( ) -> getWrappedConnection ( ) ] ) ; } }
7289	protected function watch ( OrderInterface $ order ) { if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( $ order -> hasNotifications ( NotificationTypes :: ORDER_ACCEPTED ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ order , OrderStates :: STATE_ACCEPTED ) ) { return ; } $ this -> notify ( NotificationTypes :: ORDER_ACCEPTED , $ order ) ; }
11537	public function get ( $ name , $ default = "" ) { $ param = Arr :: get ( $ _REQUEST , $ name , $ default ) ; if ( $ _SERVER [ "REQUEST_METHOD" ] == "GET" && is_string ( $ param ) ) { $ param = urldecode ( $ param ) ; } return $ param ; }
8593	public function listOrders ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceOrders_Model_ListOrdersRequest ) ) { $ request = new MarketplaceWebServiceOrders_Model_ListOrdersRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListOrders' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceOrders_Model_ListOrdersResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
860	public function clearRange ( $ indexStart , $ indexEnd ) { for ( $ i = $ indexStart ; $ i <= $ indexEnd ; ++ $ i ) { $ this -> clearAt ( $ i ) ; } }
9032	public function loadClassMetadata ( LoadClassMetadataEventArgs $ eventArgs ) { $ this -> classMetadata = $ eventArgs -> getClassMetadata ( ) ; $ reflectionClass = $ this -> classMetadata -> getReflectionClass ( ) ; if ( null === $ reflectionClass ) { return ; } if ( $ this -> hasMethod ( $ reflectionClass , 'updateTimestamps' ) ) { $ this -> addLifecycleCallbacks ( ) ; $ this -> mapFields ( ) ; } }
7136	public function merge ( Margin $ margin ) : void { $ this -> purchaseCost += $ margin -> getPurchaseCost ( ) ; $ this -> sellingPrice += $ margin -> getSellingPrice ( ) ; $ this -> average = $ this -> average || $ margin -> isAverage ( ) ; }
10304	public function resolve ( $ key ) { if ( ! ( $ this -> getAdapter ( ) instanceof ResolverInterface ) ) { throw new \ LogicException ( 'This adapter can not resolve keys' ) ; } return $ this -> getAdapter ( ) -> resolve ( $ key ) ; }
2285	protected static function server ( ) { $ strServer = ! empty ( $ _SERVER [ 'SERVER_ADDR' ] ) ? $ _SERVER [ 'SERVER_ADDR' ] : $ _SERVER [ 'LOCAL_ADDR' ] ; if ( empty ( $ strServer ) ) { $ strServer = @ gethostbyname ( $ _SERVER [ 'SERVER_NAME' ] ) ; } return $ strServer ; }
3911	protected function fetchAdditionalData ( ) { $ this -> modifiedTime = array ( ) ; $ this -> outputBuffer = array ( ) ; if ( ! $ this -> foundFiles ) { return ; } foreach ( $ this -> foundFiles as $ strFile ) { $ this -> processFile ( $ strFile ) ; } }
2733	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ html = $ this -> getRequest ( ) -> getParam ( 'html' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_ERROR_SNIPPET_PATH , Config :: VCL_ERROR_SNIPPET ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_' . $ key , 'type' => $ key , 'dynamic' => '0' , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_condition' , 'statement' => 'req.http.ResponseObject == "970"' , 'type' => 'REQUEST' , 'priority' => '9' ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ response = [ 'name' => Config :: ERROR_PAGE_RESPONSE_OBJECT , 'request_condition' => $ createCondition -> name , 'content' => $ html , 'status' => "503" , 'content_type' => "text/html; charset=utf-8" , 'response' => "Service Temporarily Unavailable" ] ; $ createResponse = $ this -> api -> createResponse ( $ clone -> number , $ response ) ; if ( ! $ createResponse ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create a RESPONSE object.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*New Error/Maintenance page has updated and activated under config version ' . $ clone -> number . '*' ) ; } $ comment = [ 'comment' => 'Magento Module updated Error Page html' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1808	public function getContentElements ( ) { $ groups = array ( ) ; foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { $ groups [ $ k ] [ ] = $ kk ; } } return $ groups ; }
4252	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ errorStats = $ this -> debug -> internal -> errorStats ( ) ; $ errorStr = '' ; if ( $ errorStats [ 'inConsole' ] ) { $ errorStr = 'Errors: ' ; foreach ( $ errorStats [ 'counts' ] as $ category => $ vals ) { $ errorStr .= $ vals [ 'inConsole' ] . ' ' . $ category . ', ' ; } $ errorStr = \ substr ( $ errorStr , 0 , - 2 ) ; } $ str = '' ; $ str .= '<script type="text/javascript">' . "\n" ; $ str .= $ this -> processLogEntryWEvent ( 'groupCollapsed' , array ( 'PHP' , ( isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) && isset ( $ _SERVER [ 'REQUEST_URI' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '' ) , $ errorStr , ) ) ; $ str .= $ this -> processAlerts ( ) ; $ str .= $ this -> processSummary ( ) ; $ str .= $ this -> processLog ( ) ; $ str .= $ this -> processLogEntryWEvent ( 'groupEnd' ) ; $ str .= '</script>' . "\n" ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
9915	public function render ( $ action = null , $ layout = null ) { $ this -> viewPath .= DS . 'Spreadsheet' ; $ content = parent :: render ( $ action , false ) ; if ( $ this -> response -> type ( ) == 'text/html' ) { return $ content ; } ob_start ( ) ; $ writer = IOFactory :: createWriter ( $ this -> Spreadsheet , CAKE_SPREADSHEET_PHPSPREADSHEET_WRITER ) ; $ writer -> setPreCalculateFormulas ( false ) ; $ writer -> save ( 'php://output' ) ; $ content = ob_get_clean ( ) ; $ this -> Blocks -> set ( 'content' , $ content ) ; $ fileName = $ this -> getFileName ( ) ; $ fileName .= '.' . CAKE_SPREADSHEET_FILE_EXTENSION ; $ this -> response -> download ( $ fileName ) ; return $ this -> Blocks -> get ( 'content' ) ; }
7837	public function register ( ) { $ className = studly_case ( strtolower ( config ( 'message.vendor' , 'smsgatewayme' ) ) ) ; $ classPath = '\Yugo\SMSGateway\Vendors\\' . $ className ; if ( ! class_exists ( $ classPath ) ) { abort ( 500 , sprintf ( 'SMS vendor %s is not available.' , $ className ) ) ; } app ( ) -> bind ( SMS :: class , $ classPath ) ; }
10503	private function setParameter ( $ subject , string $ key , $ value ) { $ setter = 'set' . $ this -> snakeToCamelCase ( $ key ) ; if ( is_callable ( [ $ subject , $ setter ] ) ) { call_user_func ( [ $ subject , $ setter ] , $ value ) ; } }
11333	public function setFormat ( $ value ) { if ( is_array ( $ value ) ) { if ( ! isset ( $ value [ 'class' ] ) ) { $ value [ 'class' ] = $ this -> determineFormatClass ( ) ; } $ value [ 'field' ] = $ this ; $ value = Yii :: createObject ( $ value ) ; } $ this -> _format = $ value ; }
1277	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'TrackRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'Track' ) ) ; if ( null !== $ this -> requestOption ) { $ request -> appendChild ( $ xml -> createElement ( 'RequestOption' , $ this -> requestOption ) ) ; } if ( null !== $ this -> trackingNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ this -> trackingNumber ) ) ; } if ( $ this -> isMailInnovations ( ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'IncludeMailInnovationIndicator' ) ) ; } if ( null !== $ this -> referenceNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) -> appendChild ( $ xml -> createElement ( 'Value' , $ this -> referenceNumber ) ) ; } if ( null !== $ this -> shipperNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ this -> shipperNumber ) ) ; } if ( null !== $ this -> beginDate || null !== $ this -> endDate ) { $ DateRange = $ xml -> createElement ( 'PickupDateRange' ) ; if ( null !== $ this -> beginDate ) { $ beginDate = $ this -> beginDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'BeginDate' , $ beginDate ) ) ; } if ( null !== $ this -> endDate ) { $ endDate = $ this -> endDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'EndDate' , $ endDate ) ) ; } $ trackRequest -> appendChild ( $ DateRange ) ; } return $ xml -> saveXML ( ) ; }
4340	private function uncollapseErrors ( & $ log ) { $ groupStack = array ( ) ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ groupStack [ ] = $ i ; } elseif ( $ method == 'groupEnd' ) { \ array_pop ( $ groupStack ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { foreach ( $ groupStack as $ i2 ) { $ log [ $ i2 ] [ 0 ] = 'group' ; } } } }
11054	public static function printts ( $ datatree , $ containers , $ entry = 'main' ) { $ this -> printt ( $ datatree , $ containers , $ entry , _ETS_STRING_READ , '' , '' ) ; }
8644	public function getReportRequestCount ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestCountRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestCountRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestCount ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestCountResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3455	public static function fromAggregateRootClass ( string $ aggregateRootClass ) : AggregateType { if ( ! \ class_exists ( $ aggregateRootClass ) ) { throw new Exception \ InvalidArgumentException ( \ sprintf ( 'Aggregate root class %s can not be found' , $ aggregateRootClass ) ) ; } $ self = new static ( ) ; $ self -> aggregateType = $ aggregateRootClass ; return $ self ; }
7312	public static function equinoxAutumn ( $ year ) { $ jd = static :: equinoxSeptember ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
10465	public function isShopValid ( $ shopId ) { $ shops = $ this -> getContainer ( ) -> getParameter ( 'ongr_connections.shops' ) ; foreach ( $ shops as $ meta ) { if ( $ meta [ 'shop_id' ] === $ shopId ) { return true ; } } return false ; }
2195	protected function resendActivationMail ( MemberModel $ objMember ) { if ( $ objMember -> disable == '' ) { return ; } $ this -> strTemplate = 'mod_message' ; $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = null ; $ models = OptInModel :: findByRelatedTableAndIds ( 'tl_member' , array ( $ objMember -> id ) ) ; foreach ( $ models as $ model ) { if ( ( $ token = $ optIn -> find ( $ model -> token ) ) && $ token -> isValid ( ) && ! $ token -> isConfirmed ( ) ) { $ optInToken = $ token ; break ; } } if ( $ optInToken === null ) { return ; } $ optInToken -> send ( ) ; $ this -> Template -> type = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resendActivation' ] ; }
6164	public function setData ( $ data ) { if ( is_array ( $ data ) ) { $ this -> data = $ data ; return $ this ; } $ this -> data = json_decode ( $ data , true ) ; if ( null === $ this -> data ) { $ this -> data = $ data ; } return $ this ; }
8091	static public function examine ( $ hash ) { if ( strlen ( $ hash ) == 40 && preg_match ( "/^[0-9]{4}/" , $ hash ) ) { $ e_uid_pos = substr ( $ hash , 0 , 2 ) ; $ e_uid_length = substr ( $ hash , 2 , 2 ) ; $ e_uid = substr ( $ hash , $ e_uid_pos , $ e_uid_length ) ; $ uid = self :: decode ( $ e_uid ) ; preg_match ( '/^([0-9]{4})(.{2,' . ( $ e_uid_pos - 4 ) . '})(' . $ e_uid . ')/' , $ hash , $ excerpt ) ; $ partial = $ excerpt [ 2 ] ; return array ( $ uid , $ partial ) ; } else { return array ( false , false ) ; } }
2435	public function remove ( $ strKey ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { $ this -> session -> remove ( $ strKey ) ; } else { $ this -> sessionBag -> remove ( $ strKey ) ; } }
6852	static public function isValidTrigger ( $ trigger , $ throwException = true ) { if ( in_array ( $ trigger , static :: getTriggers ( ) , true ) ) { return true ; } if ( $ throwException ) { throw new InvalidArgumentException ( "Invalid payment term trigger '$trigger'." ) ; } return false ; }
5663	private function dequote ( $ quoted ) { if ( preg_match ( '/^(\'([^\']*)\'|"([^"]*)")$/' , $ quoted , $ matches ) ) { return isset ( $ matches [ 3 ] ) ? $ matches [ 3 ] : $ matches [ 2 ] ; } return $ quoted ; }
1704	public function purgeOldFeeds ( ) { $ arrFeeds = array ( ) ; $ objFeeds = NewsFeedModel :: findAll ( ) ; if ( $ objFeeds !== null ) { while ( $ objFeeds -> next ( ) ) { $ arrFeeds [ ] = $ objFeeds -> alias ? : 'news' . $ objFeeds -> id ; } } return $ arrFeeds ; }
12721	public function isShared ( $ abstract ) { if ( ! isset ( $ this -> bindings [ $ abstract ] ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be valid keys in binding container stack." , __METHOD__ ) ) ; } return ( $ this -> bindings [ $ abstract ] [ 'shared' ] ? true : false ) ; }
2932	public function setKey ( $ key , $ value = null , $ comment = null , $ export = false ) { $ data = [ compact ( 'key' , 'value' , 'comment' , 'export' ) ] ; return $ this -> setKeys ( $ data ) ; }
1454	protected function validateRelationship ( RelationshipInterface $ relationship , $ key = null ) { if ( ! $ relationship -> has ( RelationshipInterface :: DATA ) ) { $ this -> addError ( $ this -> errorFactory -> memberRequired ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ relationship -> isHasOne ( ) && ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> memberRelationshipExpected ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ this -> validateEmpty ( $ relationship , $ key ) ) { return false ; } return true ; }
250	public function setUseCookies ( $ value ) { $ this -> freeze ( ) ; if ( $ value === false ) { ini_set ( 'session.use_cookies' , '0' ) ; ini_set ( 'session.use_only_cookies' , '0' ) ; } elseif ( $ value === true ) { ini_set ( 'session.use_cookies' , '1' ) ; ini_set ( 'session.use_only_cookies' , '1' ) ; } else { ini_set ( 'session.use_cookies' , '1' ) ; ini_set ( 'session.use_only_cookies' , '0' ) ; } $ this -> unfreeze ( ) ; }
7372	public function updateAction ( Request $ request ) { $ user = $ this -> getUser ( ) ; $ form = $ this -> createForm ( ProfileType :: class , $ user ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; try { $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return new JsonReloadResponse ( ) ; } catch ( \ Exception $ e ) { $ form -> addError ( new FormError ( 'Could not save changes. If the problem persists, please contact support.' ) ) ; } } return new JsonErrorResponse ( $ form ) ; }
11875	final public function getModuleDir ( ) { if ( ! $ this -> moduleDir ) { $ reflection = new ReflectionClass ( static :: class ) ; $ this -> moduleDir = dirname ( $ reflection -> getFileName ( ) ) ; } return $ this -> moduleDir ; }
9964	public function getComment ( $ pCellCoordinate ) { $ pCellCoordinate = strtoupper ( $ pCellCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCellCoordinate ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells.' ) ; } elseif ( strpos ( $ pCellCoordinate , '$' ) !== false ) { throw new Exception ( 'Cell coordinate string must not be absolute.' ) ; } elseif ( $ pCellCoordinate == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string.' ) ; } if ( isset ( $ this -> comments [ $ pCellCoordinate ] ) ) { return $ this -> comments [ $ pCellCoordinate ] ; } $ newComment = new Comment ( ) ; $ this -> comments [ $ pCellCoordinate ] = $ newComment ; return $ newComment ; }
2592	public static function createRequestCreator ( $ params , $ libIdentifier ) { $ params -> receivedFrom = self :: makeReceivedFrom ( $ params -> receivedFrom , $ libIdentifier ) ; $ theRequestCreator = new Base ( $ params ) ; return $ theRequestCreator ; }
1328	public function get ( $ key , $ default = null ) { if ( $ option = self :: where ( 'key' , $ key ) -> first ( ) ) { return $ option -> value ; } return $ default ; }
11715	protected function getCachedToken ( array $ options ) { $ authOptions = array_intersect_key ( $ options , $ this -> api -> postTokens ( ) [ 'params' ] ) ; $ optionsToHash = array_merge ( $ authOptions , array_intersect_key ( $ options , [ 'authUrl' => true , ] ) ) ; if ( isset ( $ optionsToHash [ 'user' ] ) ) { unset ( $ optionsToHash [ 'user' ] [ 'password' ] ) ; } $ key = 'openstack-token-' . md5 ( json_encode ( $ optionsToHash ) ) ; if ( $ this -> cache -> has ( $ key ) ) { return $ this -> cache -> get ( $ key ) ; } $ token = $ this -> generateToken ( $ authOptions ) ; $ cachedToken = $ token -> export ( ) ; $ expiresAt = new DateTime ( $ cachedToken [ 'expires_at' ] ) ; $ this -> cache -> put ( $ key , $ cachedToken , $ expiresAt -> sub ( new DateInterval ( 'PT1M' ) ) ) ; return $ cachedToken ; }
234	public function unquoteSimpleTableName ( $ name ) { if ( is_string ( $ this -> tableQuoteCharacter ) ) { $ startingCharacter = $ this -> tableQuoteCharacter ; } else { $ startingCharacter = $ this -> tableQuoteCharacter [ 0 ] ; } return strpos ( $ name , $ startingCharacter ) === false ? $ name : substr ( $ name , 1 , - 1 ) ; }
4556	public function setOrganizationUuid ( ? string $ organizationUuid ) { $ this -> organizationUuid = $ organizationUuid ; $ this -> _organizationUuid = true ; return $ this ; }
8377	public static function init ( ) { if ( self :: $ isInit === false ) { if ( session_id ( ) == null ) { $ settings = Config :: getSettings ( ) ; session_name ( isset ( $ settings [ 'session_name' ] ) === true ? $ settings [ 'session_name' ] : 'stray_session' ) ; if ( isset ( $ settings [ 'session_cookie_domain' ] ) === true ) { session_set_cookie_params ( 0 , '/' , $ settings [ 'session_cookie_domain' ] ) ; } session_start ( ) ; } self :: $ isInit = true ; } }
10072	function fromXML ( $ xmlElement ) { $ this -> id = $ xmlElement -> id ; $ this -> name = $ xmlElement -> name ; $ this -> author = $ xmlElement -> author ; $ this -> state = $ xmlElement -> state ; $ this -> type = $ xmlElement -> type ; $ this -> contactFilterName = $ xmlElement -> contact_filter_name ; $ this -> contactFilterId = $ xmlElement -> contact_filter_id ; $ this -> evaluated = $ xmlElement -> evaluated ; $ this -> created = $ xmlElement -> created ; $ this -> updated = $ xmlElement -> updated ; $ this -> countActiveContacts = $ xmlElement -> count_active_contacts ; $ this -> countContacts = $ xmlElement -> count_contacts ; }
9152	public function view ( $ vars = array ( ) ) { $ output = '' ; $ vars [ 'entity' ] = $ this -> entity ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getOutputView ( ) === false ) { continue ; } if ( $ field -> getType ( ) == 'hidden' || $ field -> getValueType ( ) == 'hidden' ) { continue ; } if ( $ field -> isHiddenOnProfile ( ) ) { continue ; } $ field_view = $ field -> viewOutput ( $ vars ) ; if ( $ field_view ) { $ output .= elgg_format_element ( 'div' , array ( 'class' => 'prototyper-output' , ) , $ field_view ) ; } } return $ output ; }
12936	private function moveArchiveDir ( $ archiveSourceFile , $ archiveTargetFile , $ blockName , $ slotName ) { if ( ! is_dir ( $ archiveSourceFile ) ) { return ; } $ this -> filesystem -> mirror ( $ archiveSourceFile , $ archiveTargetFile ) ; $ this -> filesystem -> remove ( $ archiveSourceFile ) ; $ historyChanged = array ( ) ; $ historyFile = $ archiveTargetFile . '/history.json' ; $ history = json_decode ( file_get_contents ( $ historyFile ) , true ) ; foreach ( $ history as $ key => $ values ) { $ values [ "name" ] = $ blockName ; $ values [ "slot_name" ] = $ slotName ; $ historyChanged [ $ key ] = $ values ; } file_put_contents ( $ historyFile , json_encode ( $ historyChanged ) ) ; }
9739	public function setFitToWidth ( $ pValue , $ pUpdate = true ) { $ this -> fitToWidth = $ pValue ; if ( $ pUpdate ) { $ this -> fitToPage = true ; } return $ this ; }
6794	public function getTagCount ( $ ids ) { $ tableName = $ this -> getTagSource ( ) ; $ colNameId = $ this -> getIdColumn ( ) ; $ return = [ ] ; if ( $ tableName && $ colNameId ) { $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'item_id' , 'count(*) as count' ) -> from ( 'tl_metamodel_tag_relation' ) -> where ( 'att_id=:att' ) -> andWhere ( 'item_id IN (:items)' ) -> groupBy ( 'item_id' ) -> setParameter ( 'att' , $ this -> get ( 'id' ) ) -> setParameter ( 'items' , $ ids , Connection :: PARAM_INT_ARRAY ) -> execute ( ) ; while ( $ row = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ itemId = $ row -> item_id ; $ return [ $ itemId ] = ( int ) $ row -> count ; } } return $ return ; }
2376	public static function sanitizeFileName ( $ strName ) { $ strName = preg_replace ( '/[\pC]/u' , '' , $ strName ) ; if ( $ strName === null ) { throw new \ InvalidArgumentException ( 'The file name could not be sanitzied' ) ; } $ strName = str_replace ( array ( '\\' , '/' , ':' , '*' , '?' , '"' , '<' , '>' , '|' ) , '-' , $ strName ) ; return $ strName ; }
852	public function getMeaningfulTokenSibling ( $ index , $ direction ) { return $ this -> getTokenNotOfKindSibling ( $ index , $ direction , [ [ T_WHITESPACE ] , [ T_COMMENT ] , [ T_DOC_COMMENT ] ] ) ; }
7450	public function useQueue ( int $ msgkey = 0 , int $ mode = 2 ) { $ this -> process -> useQueue ( $ msgkey , $ mode ) ; }
10933	protected function resolveParams ( UriInfo $ info , array $ params ) { $ uri = $ info -> getUri ( ) ; if ( false === strpos ( $ uri , '{' ) ) { return $ info ; } $ ctx = NULL ; $ result = '' ; foreach ( preg_split ( "'(\\{[^\\}]+\\})'" , $ uri , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) as $ part ) { if ( '{' != substr ( $ part , 0 , 1 ) ) { $ result .= $ part ; continue ; } $ placeholder = substr ( $ part , 1 , - 1 ) ; if ( '*' == substr ( $ placeholder , - 1 ) ) { $ placeholder = substr ( $ placeholder , 0 , - 1 ) ; $ multi = true ; } else { $ multi = false ; } switch ( substr ( $ placeholder , 0 , 1 ) ) { case '.' : $ placeholder = substr ( $ placeholder , 1 ) ; $ prefix = '.' ; $ join = $ multi ? '.' : ',' ; break ; case '/' : $ placeholder = substr ( $ placeholder , 1 ) ; $ prefix = '/' ; $ join = $ multi ? '/' : ',' ; break ; default : $ prefix = '' ; $ join = ',' ; } if ( false === strpos ( $ placeholder , '.' ) ) { $ value = array_key_exists ( $ placeholder , $ params ) ? $ params [ $ placeholder ] : $ this ; } else { if ( $ ctx === NULL ) { $ ctx = $ this -> factory -> createContext ( $ params ) ; } $ value = $ ctx -> resolveValue ( explode ( '.' , $ placeholder ) , $ this ) ; } if ( $ value === $ this ) { $ result .= $ part ; } elseif ( is_array ( $ value ) || $ value instanceof \ Traversable ) { $ i = 0 ; foreach ( $ value as $ val ) { $ result .= ( ( $ i ++ == 0 ) ? $ prefix : $ join ) . Uri :: encode ( $ val , true ) ; } } else { $ result .= $ prefix . Uri :: encode ( $ value , true ) ; } } return new UriInfo ( $ result , $ info -> getRouteName ( ) , $ info -> getMethods ( ) , $ info -> getHandler ( ) ) ; }
1210	public function split ( ItemInterface $ item , $ length ) { return array ( 'primary' => $ this -> slice ( $ item , 0 , $ length ) , 'secondary' => $ this -> slice ( $ item , $ length ) , ) ; }
9999	private function setShadowColor ( $ color , $ alpha , $ type ) { if ( $ color !== null ) { $ this -> shadowProperties [ 'color' ] [ 'value' ] = ( string ) $ color ; } if ( $ alpha !== null ) { $ this -> shadowProperties [ 'color' ] [ 'alpha' ] = $ this -> getTrueAlpha ( ( int ) $ alpha ) ; } if ( $ type !== null ) { $ this -> shadowProperties [ 'color' ] [ 'type' ] = ( string ) $ type ; } return $ this ; }
4826	public function getAsDom ( ) { if ( is_null ( $ this -> node ) ) { $ this -> node = XmlUtil :: createXmlDocumentFromStr ( "<row></row>" ) ; $ root = $ this -> node -> getElementsByTagName ( "row" ) -> item ( 0 ) ; foreach ( $ this -> row as $ key => $ value ) { if ( ! is_array ( $ value ) ) { $ field = XmlUtil :: createChild ( $ root , "field" , $ value ) ; XmlUtil :: addAttribute ( $ field , "name" , $ key ) ; } else { foreach ( $ value as $ valueItem ) { $ field = XmlUtil :: createChild ( $ root , "field" , $ valueItem ) ; XmlUtil :: addAttribute ( $ field , "name" , $ key ) ; } } } } return $ this -> node ; }
10793	public function delete ( $ idOrUser , $ forceLogout = true ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ em = $ main -> getEntityManager ( ) ; $ user = $ this -> getEntity ( $ idOrUser ) ; $ classifiedService = $ this -> getServiceLocator ( ) -> get ( 'document.service.classified' ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ , $ this , array ( 'user' => $ user ) ) ; $ user -> setState ( UserEntity :: USER_STATE_DELETED ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ documents = $ user -> getDocument ( ) ; foreach ( $ documents as $ document ) { try { $ classifiedService -> delete ( $ document ) ; } catch ( \ Exception $ e ) { } } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , array ( 'user' => $ user ) ) ; if ( $ forceLogout ) { $ this -> logout ( ) ; } return $ user ; }
6374	public function transformAndConcat ( callable $ transformer ) : FluentIterable { return self :: from ( Iterables :: concatIterables ( $ this -> transform ( $ transformer ) ) ) ; }
4269	public function dir_readdir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ readdir ( $ this -> handle ) ; self :: register ( ) ; return $ success ; }
6649	public function uploadFile ( $ event ) { if ( ! array_key_exists ( $ this -> attribute , $ event -> sender -> attributes ) ) { throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Attribute {attribute} not found in model {model}' , [ 'attribute' => $ this -> attribute , 'model' => $ event -> sender -> className ( ) ] ) ) ; } $ oldFile = false ; if ( isset ( $ event -> sender -> oldAttributes [ $ this -> attribute ] ) ) { $ oldFile = $ event -> sender -> oldAttributes [ $ this -> attribute ] ; } $ uploadedFile = UploadedFile :: getInstance ( $ event -> sender , $ this -> attribute ) ; if ( null !== $ uploadedFile && $ uploadedFile -> size !== 0 ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ oldFile ) { $ this -> unlinkFiles ( $ oldFile ) ; } $ baseName = $ uploadedFile -> baseName ; $ fileName = $ baseName . '.' . $ uploadedFile -> extension ; while ( @ file_exists ( $ folder . '/' . $ fileName ) ) { $ baseName .= '_' ; $ fileName = $ baseName . '.' . $ uploadedFile -> extension ; } FileHelper :: createDirectory ( $ folder , 0777 ) ; $ uploadedFile -> saveAs ( $ folder . '/' . $ fileName ) ; $ event -> sender -> { $ this -> attribute } = $ fileName ; } else { if ( Yii :: $ app -> request -> post ( $ this -> attribute . '_file_delete' ) ) { $ this -> unlinkFiles ( $ oldFile ) ; $ event -> sender -> { $ this -> attribute } = null ; } else { $ event -> sender -> { $ this -> attribute } = $ oldFile ; } } }
1100	protected function guardAgainstImpossibleMove ( ) { if ( ! $ this -> node -> exists ) throw new MoveNotPossibleException ( 'A new node cannot be moved.' ) ; if ( array_search ( $ this -> position , array ( 'child' , 'left' , 'right' , 'root' ) ) === FALSE ) throw new MoveNotPossibleException ( "Position should be one of ['child', 'left', 'right'] but is {$this->position}." ) ; if ( ! $ this -> promotingToRoot ( ) ) { if ( is_null ( $ this -> target ) ) { if ( $ this -> position === 'left' || $ this -> position === 'right' ) throw new MoveNotPossibleException ( "Could not resolve target node. This node cannot move any further to the {$this->position}." ) ; else throw new MoveNotPossibleException ( 'Could not resolve target node.' ) ; } if ( $ this -> node -> equals ( $ this -> target ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to itself.' ) ; if ( $ this -> target -> insideSubtree ( $ this -> node ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to a descendant of itself (inside moved tree).' ) ; if ( ! $ this -> node -> inSameScope ( $ this -> target ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to a different scope.' ) ; } }
8034	private function buildAttributesFromLdap ( $ entry ) { $ this -> attributes [ 'dn' ] = $ entry [ 'dn' ] ; foreach ( $ entry as $ index => $ key ) { if ( array_key_exists ( $ index , config ( 'ldap.search_fields' ) ) ) { $ this -> attributes [ $ key ] = isset ( $ entry [ $ key ] [ 1 ] ) ? $ entry [ $ key ] : $ entry [ $ key ] [ 0 ] ; } } ; }
10504	private function registerLogLevels ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogLevels :: class , function ( $ app ) { $ translator = $ app [ 'translator' ] ; return new Utilities \ LogLevels ( $ translator , 'en' ) ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.levels' , Contracts \ Utilities \ LogLevels :: class ) ; }
63	public function rmdir ( $ path ) { $ deleted = @ rmdir ( $ path ) ; if ( ! $ deleted ) { if ( Platform :: isWindows ( ) ) { usleep ( 350000 ) ; $ deleted = @ rmdir ( $ path ) ; } if ( ! $ deleted ) { $ error = error_get_last ( ) ; $ message = 'Could not delete ' . $ path . ': ' . @ $ error [ 'message' ] ; if ( Platform :: isWindows ( ) ) { $ message .= "\nThis can be due to an antivirus or the Windows Search Indexer locking the file while they are analyzed" ; } throw new \ RuntimeException ( $ message ) ; } } return true ; }
5305	protected function getPathPart ( SimpleXMLElement $ xmlElement , $ onlyFilled ) { $ path = '' ; if ( $ xmlElement === null ) { $ xmlElement = $ this -> xmlDocument ; } foreach ( $ xmlElement -> children ( ) as $ child ) { $ childName = $ child -> getName ( ) ; if ( ! empty ( $ child [ 'transform' ] ) ) { throw new \ Exception ( 'Transforms are currently not supported!' ) ; } if ( $ childName === 'g' ) { $ path .= ' ' . $ this -> getPathPart ( $ child , $ onlyFilled ) ; } else { if ( $ onlyFilled && ( string ) $ child [ 'fill' ] === 'none' ) { continue ; } if ( $ childName === 'polygon' ) { $ path .= ' ' . $ this -> getPathFromPolygon ( $ child ) ; } elseif ( $ childName === 'rect' ) { $ path .= ' ' . $ this -> getPathFromRect ( $ child ) ; } elseif ( $ childName === 'circle' ) { $ path .= ' ' . $ this -> getPathFromCircle ( $ child ) ; } elseif ( $ childName === 'ellipse' ) { $ path .= ' ' . $ this -> getPathFromEllipse ( $ child ) ; } elseif ( $ childName === 'path' ) { $ pathPart = trim ( $ child [ 'd' ] ) ; if ( substr ( $ pathPart , 0 , 1 ) === 'm' ) { $ pathPart = 'M' . substr ( $ pathPart , 1 ) ; } $ path .= ' ' . $ pathPart ; } } } return trim ( $ path ) ; }
11871	public function buildForm ( FormBuilderInterface $ builder , CustomField $ customField ) { $ options = $ customField -> getOptions ( ) ; $ type = ( $ options [ self :: MAX_LENGTH ] < 256 ) ? 'text' : 'textarea' ; $ attrArray = array ( ) ; if ( array_key_exists ( self :: MULTIPLE_CF_INLINE , $ options ) and $ options [ self :: MULTIPLE_CF_INLINE ] ) { $ attrArray [ 'class' ] = 'multiple-cf-inline' ; } $ builder -> add ( $ customField -> getSlug ( ) , $ type , array ( 'label' => $ this -> translatableStringHelper -> localize ( $ customField -> getName ( ) ) , 'required' => false , 'attr' => $ attrArray ) ) ; }
1316	public function post ( $ path , array $ parameters = [ ] , $ json = false ) { return $ this -> http ( 'POST' , self :: API_HOST , $ path , $ parameters , $ json ) ; }
11304	public static function name ( $ string = null ) { if ( ! $ string ) return null ; return trim ( ucwords ( mb_strtolower ( trim ( $ string ) , "UTF-8" ) ) ) ; }
7067	protected function getAccountingFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof AccountingInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . AccountingInterface :: class ) ; } return $ resource ; }
7810	public function getPackageVersion ( ) { $ package_config = file_get_contents ( dirname ( __FILE__ ) . "./../composer.json" ) ; if ( $ package_config ) { $ package_config_object = json_decode ( $ package_config ) ; if ( is_object ( $ package_config_object ) && isset ( $ package_config_object -> version ) ) { return $ package_config_object -> version ; } } return null ; }
3485	public static function resolve ( ) : SignatureGeneratorInterface { self :: addDefaultResolvers ( ) ; foreach ( self :: $ resolvers as $ resolver ) { if ( $ generator = $ resolver ( ) ) { return $ generator ; } } throw new \ LogicException ( 'Cannot resolve available JWT Signature Generator.' ) ; }
1152	public function selector ( $ selector ) { $ this -> selector = is_null ( $ selector ) ? $ this -> selector : $ selector ; return $ this ; }
6661	protected function getControllerMethod ( $ methodName ) { $ reflectionMethod = $ this -> reflectedController -> getMethod ( $ methodName ) ; $ reflectionMethod -> setAccessible ( true ) ; return function ( ) use ( $ reflectionMethod ) { return $ reflectionMethod -> invokeArgs ( $ this -> controller , func_get_args ( ) ) ; } ; }
6715	protected function getFormatFromUri ( $ requestedUri ) { $ uriParts = explode ( '?' , $ requestedUri , 2 ) ; $ uriWithoutGet = reset ( $ uriParts ) ; $ uriAndFormat = explode ( '.' , $ uriWithoutGet ) ; if ( count ( $ uriAndFormat ) >= 2 ) { return end ( $ uriAndFormat ) ; } return null ; }
6444	protected function getClient ( $ redirecturl = '' ) { if ( is_object ( $ this -> linkedin ) ) { return $ this -> linkedin ; } if ( $ redirecturl == '' ) { $ redirecturl = $ this -> redirecturl ; } else { $ this -> redirecturl = $ redirecturl ; } $ this -> logQ ( 'redirect ' . $ redirecturl , 'linkedin' ) ; $ API_CONFIG = array ( 'api_key' => $ this -> options [ 'api_key' ] , 'api_secret' => $ this -> options [ 'api_secret' ] , 'callback_url' => $ redirecturl ) ; $ this -> linkedin = $ linkedin = new \ LinkedIn \ LinkedIn ( $ API_CONFIG ) ; return $ this -> linkedin ; }
6429	public function getLoginStartUrl ( $ redirecturl ) { $ facebook = $ this -> getFacebookObject ( ) ; $ helper = $ facebook -> getRedirectLoginHelper ( ) ; $ permissions = [ 'email' ] ; $ loginUrl = $ helper -> getLoginUrl ( $ redirecturl , $ permissions ) ; return $ loginUrl ; }
2239	private function addDefaultServerVersion ( array $ extensionConfigs , ContainerBuilder $ container ) : array { $ params = [ ] ; foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'dbal' ] [ 'connections' ] [ 'default' ] ) ) { $ params [ ] = $ extensionConfig [ 'dbal' ] [ 'connections' ] [ 'default' ] ; } } if ( ! empty ( $ params ) ) { $ params = array_merge ( ... $ params ) ; } $ parameterBag = $ container -> getParameterBag ( ) ; foreach ( $ params as $ key => $ value ) { $ params [ $ key ] = $ parameterBag -> resolveValue ( $ value ) ; } try { $ connection = DriverManager :: getConnection ( $ params ) ; $ connection -> connect ( ) ; $ connection -> close ( ) ; } catch ( DriverException $ e ) { $ extensionConfigs [ ] = [ 'dbal' => [ 'connections' => [ 'default' => [ 'server_version' => '5.5' , ] , ] , ] , ] ; } return $ extensionConfigs ; }
3925	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( is_array ( $ event -> getValue ( ) ) ) { $ values = [ ] ; foreach ( $ event -> getValue ( ) as $ value ) { $ values [ ] = 'value_' . $ value ; } $ event -> setValue ( $ values ) ; } else { $ event -> setValue ( 'value_' . $ event -> getValue ( ) ) ; } }
11348	public function getField ( $ name ) { foreach ( $ this -> fields as $ field ) { if ( $ field -> getName ( ) == $ name ) return $ field ; } throw new FieldNotFoundException ( $ name ) ; }
10025	function getContact ( $ contactId , $ checksum , $ standard_fields = array ( ) , $ custom_fields = array ( ) , $ ignoreChecksum = false ) { $ queryParameters = array ( 'id' => $ contactId , 'checksum' => $ checksum , 'standard_field' => $ standard_fields , 'ignore_checksum' => $ ignoreChecksum ? "true" : "false" ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/contact' , $ queryParameters ) ; }
7729	public function quickReplie ( $ text , $ title , $ postback , $ image = null ) { $ this -> setText ( $ text ) ; $ payload = [ 'title' => $ title , 'payload' => $ postback , ] ; if ( ! empty ( $ image ) ) { $ payload [ 'image' ] = $ image ; } $ this -> setQuickReplies ( $ payload ) ; return $ this ; }
161	public function orHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'or' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
10912	public function convertDateTimeToUtcTimeZone ( $ inStrictIso8601DtTm ) { $ tmpDateTimeIn = $ this -> convertTimeFromFormatSafely ( $ inStrictIso8601DtTm ) ; $ tmpDateTimeIn -> setTimezone ( new \ DateTimeZone ( 'UTC' ) ) ; return $ tmpDateTimeIn -> format ( 'Y-m-d H:i:s' ) ; }
10859	protected function cacheMarkers ( string $ marker ) : void { $ this -> marked [ $ marker ] = [ ] ; foreach ( $ this -> definitions as $ definition ) { foreach ( ( array ) $ definition -> markers as $ m ) { if ( $ m instanceof $ marker ) { $ this -> marked [ $ marker ] [ ] = [ $ definition , $ m ] ; } } } }
2276	public function getActivationDefault ( $ varValue ) { if ( ! trim ( $ varValue ) ) { $ varValue = ( \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] [ 1 ] : $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] ) ; } return $ varValue ; }
2383	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isBackendMasterRequest ( $ event ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( null === $ this -> token ) { $ this -> token = $ this -> tokenManager -> refreshToken ( 'contao_referer_id' ) ; } $ request -> attributes -> set ( '_contao_referer_id' , $ this -> token -> getValue ( ) ) ; }
9547	public function rank ( $ info , $ weights ) { if ( ! empty ( $ weights ) ) { $ weights = explode ( ',' , $ weights ) ; } $ score = ( float ) 0.0 ; $ isize = 4 ; $ phrases = ( int ) ord ( substr ( $ info , 0 , $ isize ) ) ; $ columns = ( int ) ord ( substr ( $ info , $ isize , $ isize ) ) ; $ string = $ phrases . ' ' . $ columns . ' ' ; for ( $ p = 0 ; $ p < $ phrases ; ++ $ p ) { $ term = substr ( $ info , ( 2 + $ p * $ columns * 3 ) * $ isize ) ; for ( $ c = 0 ; $ c < $ columns ; ++ $ c ) { $ here = ( float ) ord ( substr ( $ term , ( 3 * $ c * $ isize ) , 1 ) ) ; $ total = ( float ) ord ( substr ( $ term , ( 3 * $ c + 1 ) * $ isize , 1 ) ) ; $ rows = ( float ) ord ( substr ( $ term , ( 3 * $ c + 2 ) * $ isize , 1 ) ) ; $ relevance = ( ! empty ( $ total ) ) ? ( $ rows / $ total ) * $ here : 0 ; $ weight = ( isset ( $ weights [ $ c ] ) ) ? ( float ) $ weights [ $ c ] : 1 ; $ score += $ relevance * $ weight ; $ string .= $ here . $ total . $ rows . ' (' . round ( $ relevance , 2 ) . '*' . $ weight . ') ' ; } } return $ score ; }
2827	public function formatNumber ( $ number , $ precision = 2 ) { return $ this -> helper -> useStoreLocale ( ) ? $ this -> helper -> formatNumber ( $ number , $ precision ) : number_format ( $ number , $ precision ) ; }
9447	public function getSymlinks ( Container $ app ) { $ symlinks = [ ] ; if ( $ this -> getPublicPath ( $ app ) ) { $ symlinks [ $ this -> getPublicPath ( $ app ) ] = 'packs/' . $ this -> _ns ( ) ; } return $ symlinks ; }
12055	public function get ( $ name ) { if ( ! isset ( $ this -> container [ $ name ] ) ) { throw new RuntimeException ( sprintf ( 'Module "%s" is not found' , $ name ) ) ; } return $ this -> container [ $ name ] ; }
4440	public static function sigName ( int $ signal ) : string { $ signals = [ 'SIGHUP' , 'SIGINT' , 'SIGQUIT' , 'SIGILL' , 'SIGTRAP' , 'SIGABRT' , 'SIGIOT' , 'SIGBUS' , 'SIGFPE' , 'SIGKILL' , 'SIGUSR1' , 'SIGSEGV' , 'SIGUSR2' , 'SIGPIPE' , 'SIGALRM' , 'SIGTERM' , 'SIGSTKFLT' , 'SIGCLD' , 'SIGCHLD' , 'SIGCONT' , 'SIGSTOP' , 'SIGTSTP' , 'SIGTTIN' , 'SIGTTOU' , 'SIGURG' , 'SIGXCPU' , 'SIGXFSZ' , 'SIGVTALRM' , 'SIGPROF' , 'SIGWINCH' , 'SIGPOLL' , 'SIGIO' , 'SIGPWR' , 'SIGSYS' , 'SIGBABY' , ] ; foreach ( $ signals as $ name ) { if ( defined ( $ name ) && constant ( $ name ) === $ signal ) { return $ name ; } } return 'UNKNOWN' ; }
8784	protected function log ( $ level , $ message ) { if ( is_array ( $ message ) || is_object ( $ message ) ) { $ message = print_r ( $ message , true ) ; } $ text = '[' . date ( $ this -> timeFormat , time ( ) ) . '] - [' . strtoupper ( $ level ) . '] - [' . http ( ) -> getClientIP ( ) . '] . $ message ; $ this -> save ( $ text ) ; }
6511	public function onPreDeserialize ( PreDeserializeEvent $ event ) { $ type = $ event -> getType ( ) ; if ( isset ( $ type [ 'name' ] ) && ( $ type [ 'name' ] == Job :: class || is_subclass_of ( $ type [ 'name' ] , Job :: class ) ) ) { $ data = $ event -> getData ( ) ; if ( isset ( $ data [ 'type' ] ) && isset ( $ data [ 'parameters' ] ) && is_array ( $ data [ 'parameters' ] ) && count ( $ data [ 'parameters' ] ) > 0 ) { array_push ( $ data [ 'parameters' ] , [ 'abc.job.type' => $ data [ 'type' ] ] ) ; $ event -> setData ( $ data ) ; } } }
7625	public function blobExists ( $ containerName = '' , $ blobName = '' , $ snapshotId = null ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; try { $ this -> getBlobInstance ( $ containerName , $ blobName , $ snapshotId ) ; } catch ( BlobException $ e ) { return false ; } return true ; }
12797	public function mb_str_pad ( $ input , $ length , $ string = ' ' , $ type = STR_PAD_LEFT ) { return str_pad ( $ input , $ length + strlen ( $ input ) - mb_strlen ( $ input ) , $ string , $ type ) ; }
12954	public static function priceStringToInt ( string $ str , string $ propertyPath = '' ) : int { $ str = trim ( $ str ) ; if ( ! preg_match ( '/(\.|,)[0-9]{2}$/' , $ str ) ) { throw new \ InvalidArgumentException ( ( $ propertyPath ? $ propertyPath . ' (value: "' . $ str . '")' : $ str ) . ' does not match the currency string format' ) ; } $ str = preg_replace ( '/[^0-9]+/' , '' , $ str ) ; return intval ( $ str ) ; }
7105	public function onParse ( $ finalText ) { $ func = $ this -> getParam ( 'postParseFunction' ) ; if ( isset ( $ func ) ) $ finalText = $ func ( $ finalText ) ; if ( $ this -> getParam ( 'addFootnotes' ) ) { $ footnotes = $ this -> getFootnotes ( ) ; if ( ! empty ( $ footnotes ) ) $ finalText .= "\n" . $ footnotes ; } $ finalText .= str_repeat ( '</section>' , count ( $ this -> _sectionLevel ) ) ; return ( $ finalText ) ; }
4021	protected function validator ( $ varInput ) { $ blnHasError = false ; foreach ( $ this -> arrSubFields as $ strFieldName => & $ arrSubField ) { if ( ! $ this -> validateWidget ( $ arrSubField , $ strFieldName , 'value' , $ varInput ) ) { $ blnHasError = true ; } foreach ( $ this -> arrFlagFields as $ strFlag => $ arrFlagField ) { if ( ! $ this -> validateWidget ( $ arrFlagField , $ strFieldName , $ strFlag , $ varInput ) ) { $ blnHasError = true ; } } } unset ( $ arrSubField ) ; if ( $ blnHasError ) { $ this -> blnSubmitInput = false ; $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] ) ; } return $ varInput ; }
9612	public function getRootUrl ( ) { $ request = $ this -> requests -> getCurrentRequest ( ) ; $ host = $ request -> getHttpHost ( ) ; $ base = $ request -> getBaseUrl ( ) ; return rtrim ( "//$host/$base" , '/' ) ; }
11145	protected function scanDir ( $ dir ) { $ result = array ( ) ; $ list = $ this -> scanDirExec ( $ dir ) ; foreach ( $ list as $ element ) { $ elementPath = $ dir . DIRECTORY_SEPARATOR . $ element ; if ( is_file ( $ elementPath ) ) { $ fileInfo = pathinfo ( $ element ) ; if ( in_array ( $ fileInfo [ 'extension' ] , $ this -> getAllowedFileExtensions ( ) ) ) { $ result [ ] = $ this -> getNameSpace ( ) . "\\" . $ fileInfo [ 'filename' ] ; } } } return $ result ; }
7867	protected function drawBorder ( $ left , $ middle , $ right ) { $ width = $ this -> geometry -> getWidthButBorders ( ) ; $ border = str_repeat ( static :: BORDER_Y , $ width ) ; $ this -> replaceUtf8 ( $ border , $ left , 0 ) ; $ this -> replaceUtf8 ( $ border , $ middle , floor ( $ width / 2 ) ) ; $ this -> replaceUtf8 ( $ border , $ right , $ width - 1 ) ; $ this -> drawBordered ( $ border ) ; }
2666	public function dictionaryItemsList ( $ dictionaryId ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/items' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
9619	public function checkAnswer ( $ extraParams = array ( ) ) { $ remoteIp = $ _SERVER [ "REMOTE_ADDR" ] ; $ challenge = $ _POST [ "recaptcha_challenge_field" ] ; $ response = $ _POST [ "recaptcha_response_field" ] ; if ( ! $ this -> getPrivateKey ( ) ) { throw new \ Exception ( "To use reCAPTCHA you must get an API key from <a href='https://www.google.com/recaptcha/admin/create'>https://www.google.com/recaptcha/admin/create</a>" ) ; } if ( ! $ remoteIp ) { throw new \ Exception ( "For security reasons, you must pass the remote ip to reCAPTCHA" ) ; } if ( ! $ challenge ) { $ this -> valid = false ; $ this -> error = 'incorrect-captcha-sol' ; } else { $ response = $ this -> httpPost ( self :: RECAPTCHA_VERIFY_SERVER , '/recaptcha/api/verify' , array ( 'privatekey' => $ this -> getPrivateKey ( ) , 'remoteip' => $ remoteIp , 'challenge' => $ challenge , 'response' => $ response , ) + $ extraParams ) ; $ answers = explode ( "\n" , $ response [ 1 ] ) ; if ( trim ( $ answers [ 0 ] ) == 'true' ) { $ this -> valid = true ; } else { $ this -> valid = false ; $ this -> error = $ answers [ 1 ] ; } } return $ this ; }
10247	public function getString ( $ type = 'letter' , $ desired_length = null ) { if ( empty ( $ desired_length ) ) { $ desired_length = $ this -> getInteger ( 1 , 50 ) ; } $ result = '' ; while ( strlen ( $ result ) < $ desired_length ) { if ( $ type == 'letter' ) { $ result .= $ this -> getLetter ( ) ; } elseif ( $ type == 'number' ) { $ result .= $ this -> getInteger ( 1 , 10 ) ; } else { $ result .= $ this -> getUniqueHash ( ) ; } } return substr ( $ result , 0 , $ desired_length ) ; }
1149	protected function setDefaults ( $ options ) { $ this -> selector = empty ( $ options [ 'selector' ] ) ? 'form' : $ options [ 'selector' ] ; $ this -> view = empty ( $ options [ 'view' ] ) ? 'jsvalidation::bootstrap' : $ options [ 'view' ] ; $ this -> remote = isset ( $ options [ 'remote' ] ) ? $ options [ 'remote' ] : true ; }
10234	public function main ( ) { $ config = $ this -> app [ 'config' ] [ 'auja' ] ? : $ this -> app [ 'config' ] [ 'auja-laravel::config' ] ; $ authenticationForm = $ this -> app [ 'auja' ] -> authenticationForm ( $ config [ 'title' ] , $ this -> app [ 'url' ] -> route ( 'auja.support.login' , [ ] , false ) ) ; $ username = ( $ this -> app [ 'auth' ] -> user ( ) == null ) ? null : $ this -> app [ 'auth' ] -> user ( ) -> name ; $ main = $ this -> app [ 'auja' ] -> main ( $ config [ 'title' ] , $ this -> app [ 'auth' ] -> check ( ) , $ username , $ this -> app [ 'url' ] -> route ( 'auja.support.logout' , [ ] , false ) , $ authenticationForm ) ; $ main -> setColor ( Main :: COLOR_MAIN , $ config [ 'color' ] [ 'main' ] ) ; $ main -> setColor ( Main :: COLOR_ALERT , $ config [ 'color' ] [ 'alert' ] ) ; $ main -> setColor ( Main :: COLOR_SECONDARY , $ config [ 'color' ] [ 'secondary' ] ) ; return new JsonResponse ( $ main ) ; }
4453	public function isPaused ( ) : bool { $ stat = json_decode ( $ this -> client -> queues ( $ this -> name ) , true ) ; return isset ( $ stat [ 'name' ] ) && $ stat [ 'name' ] === $ this -> name && $ stat [ 'paused' ] == true ; }
10887	public function getSession ( $ sessionId ) { return tap ( $ this -> manager -> driver ( ) , function ( $ session ) use ( $ sessionId ) { $ session -> setId ( $ sessionId ) ; } ) ; }
1699	public function getFile ( $ strName ) { foreach ( $ this -> arrFiles as $ k => $ v ) { if ( $ strName == $ v [ 'file_name' ] ) { $ this -> intIndex = $ k ; return true ; } } return false ; }
4832	public function payout ( ) { if ( ! $ this -> payout_id ) { throw new GoCardless_ClientException ( "Cannot fetch payout for a bill that has not been paid out" ) ; } return GoCardless_Payout :: find_with_client ( $ this -> client , $ this -> payout_id ) ; }
5020	public function getFieldFlags ( $ field ) { if ( ! $ this -> hasField ( $ field ) ) { return [ ] ; } if ( ! isset ( $ this -> fields [ $ field ] [ '__flags__' ] ) ) { $ this -> fields [ $ field ] [ '__flags__' ] = $ this -> copyArrayValues ( $ this -> fields [ $ field ] , [ 'flags' => [ ] , 'order' => [ 'priority' ] , 'priority' ] ) ; } return $ this -> fields [ $ field ] [ '__flags__' ] ; }
5317	public function run ( ) { $ signalHandler = $ this -> getSignalHandler ( ) ; $ signalHandler -> registerHandler ( SIGTERM , function ( ) { $ this -> shouldShutdown = true ; } ) ; $ this -> sharedMemory [ self :: STARTED_MARKER ] = true ; $ callable = $ this -> callable ; $ callable ( $ this ) ; }
6066	public function listSocialMedia ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/socialmedia/sites' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new SocialMedia ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12393	public function onSiteSaved ( SiteSavedEvent $ event ) { $ fs = new Filesystem ( ) ; $ fs -> mirror ( $ this -> configurationHandler -> uploadAssetsDir ( ) , $ this -> configurationHandler -> uploadAssetsDirProduction ( ) ) ; }
9697	function findTransactionTypeByName ( $ type_name ) { $ types = $ this -> getTransactionTypes ( 1 , 1000 ) -> getResult ( ) ; $ type_name = mb_strtolower ( $ type_name ) ; foreach ( $ types as $ type ) { if ( strcmp ( mb_strtolower ( $ type -> name ) , $ type_name ) == 0 ) { return ( int ) $ type -> id ; } } return null ; }
1357	public function field ( string $ field , string $ inverse = null ) : self { $ this -> defaults = array_merge ( $ this -> defaults , [ ResourceRegistrar :: PARAM_RELATIONSHIP_NAME => $ field , ResourceRegistrar :: PARAM_RELATIONSHIP_INVERSE_TYPE => $ inverse ? : Str :: plural ( $ field ) , ] ) ; return $ this ; }
6381	public function readQuestionAttempts ( $ id ) { $ questionAttempts = $ this -> readStoreRecords ( 'question_attempts' , [ 'questionusageid' => $ id ] ) ; foreach ( $ questionAttempts as $ questionIndex => $ questionAttempt ) { $ questionAttemptSteps = $ this -> readStoreRecords ( 'question_attempt_steps' , [ 'questionattemptid' => $ questionAttempt -> id ] ) ; foreach ( $ questionAttemptSteps as $ stepIndex => $ questionAttemptStep ) { $ questionAttemptStep -> data = $ this -> readStoreRecords ( 'question_attempt_step_data' , [ 'attemptstepid' => $ questionAttemptStep -> id ] ) ; } $ questionAttempt -> steps = $ questionAttemptSteps ; } return $ questionAttempts ; }
2233	public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } $ objSteps = $ this -> Database -> prepare ( "SELECT id FROM tl_undo WHERE pid=?" ) -> execute ( $ this -> User -> id ) ; $ GLOBALS [ 'TL_DCA' ] [ 'tl_undo' ] [ 'list' ] [ 'sorting' ] [ 'root' ] = $ objSteps -> numRows ? $ objSteps -> fetchEach ( 'id' ) : array ( 0 ) ; if ( Contao \ Input :: get ( 'act' ) && ! \ in_array ( Contao \ Input :: get ( 'id' ) , $ GLOBALS [ 'TL_DCA' ] [ 'tl_undo' ] [ 'list' ] [ 'sorting' ] [ 'root' ] ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to ' . Contao \ Input :: get ( 'act' ) . ' undo step ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } }
11732	protected function generateBlocks ( array $ blocks , $ blocksDir , $ targetDir ) { $ c = 1 ; $ generatedBlocks = array ( ) ; foreach ( $ blocks as $ block ) { $ blockName = 'block' . $ c ; $ fileName = sprintf ( '%s/%s.json' , $ blocksDir , $ blockName ) ; $ generatedBlocks [ ] = $ blockName ; $ value = $ block ; if ( is_array ( $ value ) ) { $ value = json_encode ( $ block ) ; } FilesystemTools :: writeFile ( $ fileName , $ value ) ; $ c ++ ; } $ slotDefinition = array ( 'next' => $ c , 'blocks' => $ generatedBlocks , 'revision' => 1 , ) ; FilesystemTools :: writeFile ( $ targetDir . '/slot.json' , json_encode ( $ slotDefinition ) ) ; }
10152	private function readHcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isHorizontalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setHorizontalCentered ( $ isHorizontalCentered ) ; } }
5823	private function resolveOptions ( array $ options = array ( ) ) { $ this -> options [ 'alertPublisher' ] = $ this -> alertPublisher ; return array_merge ( $ this -> options , $ options ) ; }
5160	public function getAttachmentByField ( string $ field ) : array { if ( isset ( $ this -> attachment [ $ field ] ) ) { return $ this -> attachment [ $ field ] ; } return [ ] ; }
952	public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } $ planCharge = $ this -> shop -> planCharge ( ) ; $ charge = new Charge ( ) ; $ charge -> type = Charge :: CHARGE_USAGE ; $ charge -> reference_charge = $ planCharge -> charge_id ; $ charge -> shop_id = $ this -> shop -> id ; $ charge -> charge_id = $ this -> response -> id ; $ charge -> price = $ this -> response -> price ; $ charge -> description = $ this -> response -> description ; $ charge -> billing_on = $ this -> response -> billing_on ; return $ charge -> save ( ) ; }
7283	public function updateCustomerGroupAndCurrency ( ) { if ( ! $ this -> hasCart ( ) || $ this -> cart -> isLocked ( ) ) { return $ this ; } if ( null !== $ customer = $ this -> cart -> getCustomer ( ) ) { if ( $ this -> cart -> getCustomerGroup ( ) !== $ customer -> getCustomerGroup ( ) ) { $ this -> cart -> setCustomerGroup ( $ customer -> getCustomerGroup ( ) ) ; } } if ( null === $ this -> cart -> getCustomerGroup ( ) ) { $ this -> cart -> setCustomerGroup ( $ this -> customerProvider -> getCustomerGroup ( ) ) ; } if ( null === $ this -> cart -> getCurrency ( ) ) { $ this -> cart -> setCurrency ( $ this -> currencyProvider -> getCurrency ( ) ) ; } return $ this ; }
3973	public function encodeAttributeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ value = substr ( $ value , \ strlen ( $ metaModel -> getTableName ( ) . '_' ) ) ; $ attribute = $ metaModel -> getAttribute ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ attribute -> get ( 'id' ) ) ; } }
7281	public function forward ( $ host , array $ headers = [ ] ) { return Curl :: create ( $ this -> method , $ host . $ this -> url , $ this -> inputs , array_merge ( $ this -> headers , $ headers ) ) ; }
3959	public function parseValue ( $ strOutputFormat = 'text' , $ objSettings = null ) { $ this -> registerAssets ( $ objSettings ) ; $ arrResult = [ 'raw' => $ this -> arrData , 'text' => [ ] , 'attributes' => [ ] , $ strOutputFormat => [ ] , 'class' => '' , 'actions' => [ ] ] ; if ( ! $ objSettings ) { foreach ( $ this -> getMetaModel ( ) -> getAttributes ( ) as $ objAttribute ) { $ arrResult [ 'attributes' ] [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; foreach ( $ this -> internalParseAttribute ( $ objAttribute , $ strOutputFormat , null ) as $ strKey => $ varValue ) { $ arrResult [ $ strKey ] [ $ objAttribute -> getColName ( ) ] = $ varValue ; } } return $ arrResult ; } $ jumpTo = $ this -> buildJumpToLink ( $ objSettings ) ; if ( true === $ jumpTo [ 'deep' ] ) { $ arrResult [ 'actions' ] [ 'jumpTo' ] = [ 'href' => $ jumpTo [ 'url' ] , 'label' => $ this -> getCaptionText ( 'details' ) , 'class' => 'details' ] ; } $ arrResult [ 'jumpTo' ] = $ jumpTo ; foreach ( $ objSettings -> getSettingNames ( ) as $ strAttrName ) { $ objAttribute = $ this -> getMetaModel ( ) -> getAttribute ( $ strAttrName ) ; if ( $ objAttribute ) { $ arrResult [ 'attributes' ] [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; foreach ( $ this -> internalParseAttribute ( $ objAttribute , $ strOutputFormat , $ objSettings ) as $ strKey => $ varValue ) { $ arrResult [ $ strKey ] [ $ objAttribute -> getColName ( ) ] = $ varValue ; } } } if ( $ this -> getMetaModel ( ) -> hasVariants ( ) ) { $ arrResult [ 'class' ] = $ this -> variantCssClass ( ) ; } $ event = new ParseItemEvent ( $ objSettings , $ this , $ strOutputFormat , $ arrResult ) ; $ this -> getEventDispatcher ( ) -> dispatch ( MetaModelsEvents :: PARSE_ITEM , $ event ) ; return $ event -> getResult ( ) ; }
759	public function setChildren ( $ children ) { $ this -> _children = [ ] ; foreach ( $ children as $ child ) { $ child -> parent = $ this ; $ this -> _children [ ] = $ child ; } $ this -> updateCollectionOffsets ( ) ; }
12418	static function run_php_loc_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phploc = self :: getTool ( 'phploc' , $ opts , true ) ; $ out = pake_sh ( "$phploc -n " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phploc.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
8466	public static function setUrlParams ( $ url = false ) { $ url = $ url !== false ? $ url : self :: getCurrentPage ( ) ; if ( strpos ( $ url , '?' ) == false && strpos ( $ url , '&' ) != false ) { $ url = preg_replace ( '/&/' , '?' , $ url , 1 ) ; $ parts = parse_url ( $ url ) ; $ query = isset ( $ parts [ 'query' ] ) ? $ parts [ 'query' ] : '' ; parse_str ( $ query , $ query ) ; } foreach ( isset ( $ query ) ? $ query : [ ] as $ key => $ value ) { $ _GET [ $ key ] = $ value ; } return explode ( '?' , $ url ) [ 0 ] ; }
7071	protected function updateMessage ( TicketMessageInterface $ message ) { $ message -> setUpdatedAt ( new \ DateTime ( ) ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ message , true ) ; }
4650	private function parseEnvironmentLine ( $ environmentLine ) { $ variables = array ( ) ; @ $ variableLines = explode ( ' ' , $ environmentLine ? : '' ) ; foreach ( $ variableLines as $ variableLine ) { if ( ! empty ( $ variableLine ) ) { list ( $ key , $ value ) = $ this -> parseEnvironementVariable ( $ variableLine ) ; $ variables [ $ key ] = $ value ; } } return $ variables ; }
8125	protected function getSchemaRequested ( ) { $ parts = $ this -> owner -> getRequest ( ) -> getHeader ( LeftAndMain :: SCHEMA_HEADER ) ; return ! empty ( $ parts ) ; }
7638	public function generateSharedAccessUrl ( $ containerName = '' , $ blobName = '' , $ resource = 'b' , $ permissions = 'r' , $ start = '' , $ expiry = '' , $ identifier = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; return $ this -> getBaseUrl ( ) . '/' . $ resourceName . '?' . $ this -> sharedAccessSignatureCredentials -> createSignedQueryString ( $ resourceName , '' , $ resource , $ permissions , $ start , $ expiry , $ identifier ) ; }
9250	public function boot ( ) { if ( $ this -> booted ) { return ; } $ this -> container = $ this -> initializeContainer ( ) ; $ this -> kernel = $ this -> container -> get ( 'http_kernel' ) ; $ this -> booted = true ; }
3646	public function clean ( $ value , bool $ trim = true , bool $ clean = true ) { if ( is_bool ( $ value ) || is_int ( $ value ) || is_float ( $ value ) ) { return $ value ; } $ final = null ; if ( $ value !== null ) { if ( is_array ( $ value ) ) { $ all = $ value ; $ final = [ ] ; foreach ( $ all as $ key => $ value ) { if ( $ value !== null ) { $ final [ $ key ] = $ this -> clean ( $ value , $ trim , $ clean ) ; } } } else { if ( $ value !== null ) { $ final = $ this -> process ( ( string ) $ value , $ trim , $ clean ) ; } } } return $ final ; }
8664	private function convertManageReportSchedule ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ManageReportSchedule' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportType ( ) ) { $ parameters [ 'ReportType' ] = $ request -> getReportType ( ) ; } if ( $ request -> isSetSchedule ( ) ) { $ parameters [ 'Schedule' ] = $ request -> getSchedule ( ) ; } if ( $ request -> isSetScheduleDate ( ) ) { $ parameters [ 'ScheduleDate' ] = $ this -> getFormattedTimestamp ( $ request -> getScheduleDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
3201	public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ result = $ this -> getListResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; array_map ( function ( $ item ) { return array_merge ( $ item , [ 'categories' => $ this -> getCategoryService ( ) -> getItemCategories ( $ this -> getResource ( $ item [ 'uri' ] ) ) ] ) ; } , $ result [ 'nodes' ] ) ; return $ result ; }
6157	public function redirectSelf ( ) : object { $ url = $ this -> di -> get ( "request" ) -> getCurrentUrl ( ) ; return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
876	private function isCommentWithFixableIndentation ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isComment ( ) ) { return false ; } if ( 0 === strpos ( $ tokens [ $ index ] -> getContent ( ) , '/*' ) ) { return true ; } $ firstCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ firstCommentIndex , false ) ; if ( null === $ i ) { break ; } $ firstCommentIndex = $ i ; } $ lastCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ lastCommentIndex , true ) ; if ( null === $ i ) { break ; } $ lastCommentIndex = $ i ; } if ( $ firstCommentIndex === $ lastCommentIndex ) { return true ; } for ( $ i = $ firstCommentIndex + 1 ; $ i < $ lastCommentIndex ; ++ $ i ) { if ( ! $ tokens [ $ i ] -> isWhitespace ( ) && ! $ tokens [ $ i ] -> isComment ( ) ) { return false ; } } return true ; }
11603	public function align ( PagesCollectionParser $ pagesCollectionParser ) { $ themeSlots = $ this -> findSlotsInTemplates ( ) ; $ slots = $ this -> mergeSlotsByStatus ( $ themeSlots ) ; if ( ! array_key_exists ( "page" , $ slots ) ) { return ; } $ pageSlots = $ slots [ "page" ] ; unset ( $ slots [ "page" ] ) ; $ files = $ this -> removeCommonSlots ( $ slots ) ; $ files = array_merge ( $ files , $ this -> removePageSlots ( $ pagesCollectionParser , $ pageSlots ) ) ; if ( ! empty ( $ files ) ) { $ fs = new Filesystem ( ) ; $ fs -> remove ( $ files ) ; } }
810	private function toComparableNames ( array $ types , array $ symbolShortNames ) { $ normalized = array_map ( function ( $ type ) use ( $ symbolShortNames ) { $ type = strtolower ( $ type ) ; if ( isset ( $ symbolShortNames [ $ type ] ) ) { return $ symbolShortNames [ $ type ] ; } return $ type ; } , $ types ) ; sort ( $ normalized ) ; return $ normalized ; }
2613	private function prepareGAReqData ( ) { if ( ! empty ( $ this -> GAReqData ) ) { return $ this -> GAReqData ; } $ mandatoryReqData = [ ] ; $ mandatoryReqData [ 'v' ] = 1 ; $ mandatoryReqData [ 'tid' ] = $ this -> getGATrackingId ( ) ; $ cid = $ this -> config -> getCID ( ) ; $ mandatoryReqData [ 'cid' ] = $ cid ; $ mandatoryReqData [ 'uid' ] = $ cid ; $ mandatoryReqData [ 'ua' ] = $ this -> metaData -> getVersion ( ) ; $ mandatoryReqData [ 'geoid' ] = $ this -> getCountry ( ) ; $ mandatoryReqData [ 'ds' ] = 'Fastly' ; $ customVars = $ this -> prepareCustomVariables ( ) ; $ this -> GAReqData = array_merge ( $ mandatoryReqData , $ customVars ) ; return $ this -> GAReqData ; }
5540	public function setFrameFocusByIndex ( $ choice ) { if ( is_integer ( $ this -> focus ) ) { if ( $ this -> frames [ $ this -> focus ] -> hasFrames ( ) ) { return $ this -> frames [ $ this -> focus ] -> setFrameFocusByIndex ( $ choice ) ; } } if ( ( $ choice < 1 ) || ( $ choice > count ( $ this -> frames ) ) ) { return false ; } $ this -> focus = $ choice - 1 ; return true ; }
7484	public function endsWith ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; return $ string === $ this -> substring ( $ this -> length ( ) - mb_strlen ( $ string , $ this -> encoding ) ) -> __toString ( ) ; }
3391	public function confirm ( $ confirmation_code ) { $ model = $ this -> guard ( ) -> getProvider ( ) -> createModel ( ) ; $ user = $ model -> where ( 'confirmation_code' , $ confirmation_code ) -> firstOrFail ( ) ; $ user -> confirmation_code = null ; $ user -> confirmed_at = now ( ) ; $ user -> save ( ) ; event ( new Confirmed ( $ user ) ) ; return $ this -> confirmed ( $ user ) ? : redirect ( $ this -> redirectAfterConfirmationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_successful' ) ) ; }
11647	function parseAndAddServiceFromFile ( $ serviceFilename ) { $ service = require $ serviceFilename ; if ( $ service == false ) { throw new APIBuilderException ( "Failed to open service file `$serviceFilename`." ) ; } if ( is_array ( $ service ) == false ) { throw new APIBuilderException ( "File `$serviceFilename` did not return a service array. Cannot build API from it." ) ; } $ this -> parseAndAddService ( $ service ) ; }
8122	public function getReviewContentForm ( $ id ) { $ page = $ this -> findRecord ( [ 'ID' => $ id ] ) ; $ user = Security :: getCurrentUser ( ) ; if ( ! $ page -> canEdit ( ) || ( $ page -> hasMethod ( 'canBeReviewedBy' ) && ! $ page -> canBeReviewedBy ( $ user ) ) ) { $ this -> owner -> httpError ( 403 , _t ( __CLASS__ . '.ErrorItemPermissionDenied' , 'It seems you don\'t have the necessary permissions to review this content' ) ) ; return null ; } $ form = $ this -> getReviewContentHandler ( ) -> Form ( $ page ) ; $ form -> setValidationResponseCallback ( function ( ValidationResult $ errors ) use ( $ form , $ id ) { $ schemaId = $ this -> owner -> join_links ( $ this -> owner -> Link ( 'schema/ReviewContentForm' ) , $ id ) ; return $ this -> getSchemaResponse ( $ schemaId , $ form , $ errors ) ; } ) ; return $ form ; }
9940	public function calculateColumnWidths ( ) { $ autoSizes = [ ] ; foreach ( $ this -> getColumnDimensions ( ) as $ colDimension ) { if ( $ colDimension -> getAutoSize ( ) ) { $ autoSizes [ $ colDimension -> getColumnIndex ( ) ] = - 1 ; } } if ( ! empty ( $ autoSizes ) ) { $ isMergeCell = [ ] ; foreach ( $ this -> getMergeCells ( ) as $ cells ) { foreach ( Coordinate :: extractAllCellReferencesInRange ( $ cells ) as $ cellReference ) { $ isMergeCell [ $ cellReference ] = true ; } } foreach ( $ this -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ this -> getCell ( $ coordinate , false ) ; if ( $ cell !== null && isset ( $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] ) ) { $ isMerged = isset ( $ isMergeCell [ $ this -> cellCollection -> getCurrentCoordinate ( ) ] ) ; $ isMergedButProceed = false ; if ( $ isMerged && $ cell -> isMergeRangeValueCell ( ) ) { $ range = $ cell -> getMergeRange ( ) ; $ rangeBoundaries = Coordinate :: rangeDimension ( $ range ) ; if ( $ rangeBoundaries [ 0 ] == 1 ) { $ isMergedButProceed = true ; } } if ( ! $ isMerged || $ isMergedButProceed ) { $ cellValue = NumberFormat :: toFormattedString ( $ cell -> getCalculatedValue ( ) , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] = max ( ( float ) $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] , ( float ) Shared \ Font :: calculateColumnWidth ( $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getFont ( ) , $ cellValue , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getAlignment ( ) -> getTextRotation ( ) , $ this -> getParent ( ) -> getDefaultStyle ( ) -> getFont ( ) ) ) ; } } } foreach ( $ autoSizes as $ columnIndex => $ width ) { if ( $ width == - 1 ) { $ width = $ this -> getDefaultColumnDimension ( ) -> getWidth ( ) ; } $ this -> getColumnDimension ( $ columnIndex ) -> setWidth ( $ width ) ; } } return $ this ; }
3218	function chunkedUploadFinish ( $ uploadId , $ path , $ writeMode ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Path :: checkArgNonRoot ( "path" , $ path ) ; WriteMode :: checkArg ( "writeMode" , $ writeMode ) ; $ params = array_merge ( array ( "upload_id" => $ uploadId ) , $ writeMode -> getExtraParams ( ) ) ; $ response = $ this -> doPost ( $ this -> contentHost , $ this -> appendFilePath ( "1/commit_chunked_upload" , $ path ) , $ params ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
11361	public function isClicked ( string $ sType ) : bool { if ( $ this -> getType ( ) === 'submit' || $ this -> getType ( ) === 'button' ) { if ( isset ( $ _POST [ $ this -> getName ( ) ] ) ) { return true ; } } return false ; }
473	public function batchInsert ( $ table , $ columns , $ rows ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> batchInsert ( $ table , $ columns , $ rows ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
11202	public function toArray ( ) { $ collection = $ this -> getIterator ( ) ; $ plainArray = [ ] ; foreach ( $ collection as $ prop => $ result ) { if ( is_object ( $ result ) && method_exists ( $ result , 'toArray' ) ) { $ plainArray [ ] = $ result -> toArray ( ) ; } else { $ plainArray [ ] = $ result ; } } return $ plainArray ; }
7054	public function message_id_header ( $ headers , $ iac_options , $ item_ID ) { $ type = ( 'iac_comment_headers' == current_filter ( ) ) ? 'comment' : 'post' ; $ item = ( 'post' == $ type ) ? get_post ( $ item_ID ) : get_comment ( $ item_ID ) ; $ headers [ 'Message-ID' ] = '<' . Iac_Mail_ID :: generate_ID ( $ type , $ item ) . '>' ; return $ headers ; }
6521	public function boot ( ) { $ this -> app -> when ( SmsGatewayChannel :: class ) -> needs ( SmsGatewayClient :: class ) -> give ( function ( ) { $ config = $ this -> app [ 'config' ] [ 'services.smsgateway' ] ; return new SmsGatewayClient ( new HttpClient , $ config [ 'email' ] , $ config [ 'password' ] , $ config [ 'device' ] ) ; } ) ; }
7764	private function documentOperations ( $ operations ) { if ( null === $ operations ) { return null ; } $ result = array ( ) ; foreach ( $ operations as $ operation ) { $ statusCodes = array ( ) ; foreach ( $ operation -> getStatusCodes ( ) as $ code => $ description ) { $ statusCodes [ ] = array ( 'code' => $ code , 'description' => $ description ) ; } $ result [ ] = array ( '@id' => '_:' . $ operation -> getName ( ) , '@type' => $ operation -> getType ( ) ? : 'hydra:Operation' , 'method' => $ operation -> getMethod ( ) , 'label' => ( $ operation -> getTitle ( ) ) ? : $ operation -> getDescription ( ) , 'description' => ( null === $ operation -> getTitle ( ) ) ? null : $ operation -> getDescription ( ) , 'expects' => $ this -> getTypeReferenceIri ( $ operation -> getExpects ( ) ) , 'returns' => $ this -> getTypeReferenceIri ( $ operation -> getReturns ( ) ) , 'statusCodes' => $ statusCodes ) ; } return $ result ; }
7098	private function findStockUnits ( StockSubjectInterface $ subject ) { $ repository = $ this -> entityManager -> getRepository ( $ subject :: getStockUnitClass ( ) ) ; $ stockUnits = array_merge ( $ repository -> findNotClosedBySubject ( $ subject ) , $ repository -> findLatestClosedBySubject ( $ subject ) ) ; usort ( $ stockUnits , function ( StockUnitInterface $ a , StockUnitInterface $ b ) { if ( $ a -> getState ( ) === StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) !== StockUnitStates :: STATE_CLOSED ) { return 1 ; } if ( $ a -> getState ( ) !== StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) === StockUnitStates :: STATE_CLOSED ) { return - 1 ; } if ( $ a -> getState ( ) === StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) === StockUnitStates :: STATE_CLOSED ) { $ aDate = $ a -> getClosedAt ( ) -> getTimestamp ( ) ; $ bDate = $ b -> getClosedAt ( ) -> getTimestamp ( ) ; if ( $ aDate > $ bDate ) { return - 1 ; } if ( $ aDate < $ bDate ) { return 1 ; } } $ aDate = $ a -> getCreatedAt ( ) -> getTimestamp ( ) ; $ bDate = $ b -> getCreatedAt ( ) -> getTimestamp ( ) ; if ( $ aDate > $ bDate ) { return - 1 ; } if ( $ aDate < $ bDate ) { return 1 ; } return 0 ; } ) ; return $ stockUnits ; }
8353	private function shutdown ( $ signal = 9 ) { foreach ( $ this -> dispatcher -> getProcesses ( ) as $ pid => $ process ) { $ this -> logger -> debug ( 'Sending signal to process' , [ 'signal' => $ signal , 'pid' => $ pid , 'jobId' => $ process [ 'id' ] , 'queue' => $ this -> queue -> getName ( ) ] ) ; \ posix_kill ( $ pid , $ signal ) ; if ( $ signal !== 9 ) { if ( $ this -> config [ 'deadline_timeout' ] !== null ) { Loop :: delay ( ( ( int ) $ this -> config [ 'deadline_timeout' ] * 1000 ) , function ( $ watcherId , $ callback ) use ( $ process , $ pid ) { if ( $ process [ 'process' ] -> isRunning ( ) ) { $ this -> logger -> info ( 'Process has exceeded deadline timeout. Killing' , [ 'pid' => $ pid , 'jobId' => $ process [ 'id' ] , 'queue' => $ this -> queue -> getName ( ) ] ) ; \ posix_kill ( $ pid , SIGKILL ) ; } } ) ; } } } }
10623	public static function synchronizeMigrations ( CommandEvent $ event ) { $ packages = $ event -> getComposer ( ) -> getRepositoryManager ( ) -> getLocalRepository ( ) -> getPackages ( ) ; $ installer = $ event -> getComposer ( ) -> getInstallationManager ( ) ; $ appMigrationDir = self :: getDestinationDir ( $ event -> getComposer ( ) ) ; $ io = $ event -> getIO ( ) ; $ areFileMigrated = array ( ) ; $ areFileMigrated [ ] = self :: handlePackage ( '.' , $ event -> getComposer ( ) -> getPackage ( ) , $ io , $ appMigrationDir ) ; foreach ( $ packages as $ package ) { $ areFileMigrated [ ] = self :: handlePackage ( $ installer -> getInstallPath ( $ package ) , $ package , $ io , $ appMigrationDir ) ; } if ( in_array ( true , $ areFileMigrated ) ) { $ io -> write ( "<warning>Some migration files have been imported. " . "You should run `php app/console doctrine:migrations:status` and/or " . "`php app/console doctrine:migrations:migrate` to apply them to your DB." ) ; } }
5992	public function setSortFields ( array $ sortFields ) { $ this -> sortFields = [ ] ; foreach ( $ sortFields as $ item ) { $ this -> addSearchSort ( $ item ) ; } return $ this ; }
191	public function setStatusCodeByException ( $ e ) { if ( $ e instanceof HttpException ) { $ this -> setStatusCode ( $ e -> statusCode ) ; } else { $ this -> setStatusCode ( 500 ) ; } return $ this ; }
5719	public function cancel ( ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return Controller :: curr ( ) -> redirect ( $ this -> getBackLink ( ) ) ; }
5294	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing CSS file to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getCss ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created CSS file successfully</success>' ) ; }
3905	protected function getPropertyNames ( ) { $ propertyNames = array ( 'id' , 'pid' , 'tstamp' , 'sorting' ) ; if ( $ this -> getItem ( ) -> getMetaModel ( ) -> hasVariants ( ) ) { $ propertyNames [ ] = 'varbase' ; $ propertyNames [ ] = 'vargroup' ; } return array_merge ( $ propertyNames , array_keys ( $ this -> getItem ( ) -> getMetaModel ( ) -> getAttributes ( ) ) ) ; }
7801	protected function splitTransactions ( $ text ) { $ offset = 0 ; $ length = 0 ; $ position = 0 ; $ transactions = array ( ) ; while ( $ line = $ this -> getLine ( '61' , $ text , $ offset , $ offset , $ length ) ) { $ offset += 4 + $ length + 2 ; $ transaction = array ( $ line ) ; $ description = array ( ) ; while ( $ line = $ this -> getLine ( '86' , $ text , $ offset , $ position , $ length ) ) { if ( $ position == $ offset ) { $ offset += 4 + $ length + 2 ; $ description [ ] = $ line ; } else { break ; } } if ( $ description ) { $ transaction [ ] = implode ( "\r\n" , $ description ) ; } $ transactions [ ] = $ transaction ; } return $ transactions ; }
1293	private function getTokenFromResponse ( array $ data ) : string { $ url = $ data [ 'nextSyncUrl' ] ?? $ data [ 'nextPageUrl' ] ; $ queryValues = [ ] ; \ parse_str ( \ parse_url ( $ url , \ PHP_URL_QUERY ) , $ queryValues ) ; return $ queryValues [ 'sync_token' ] ; }
1055	public static function findBreakingChanges ( Schema $ oldSchema , Schema $ newSchema ) { return array_merge ( self :: findRemovedTypes ( $ oldSchema , $ newSchema ) , self :: findTypesThatChangedKind ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnObjectOrInterfaceTypes ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnInputObjectTypes ( $ oldSchema , $ newSchema ) [ 'breakingChanges' ] , self :: findTypesRemovedFromUnions ( $ oldSchema , $ newSchema ) , self :: findValuesRemovedFromEnums ( $ oldSchema , $ newSchema ) , self :: findArgChanges ( $ oldSchema , $ newSchema ) [ 'breakingChanges' ] , self :: findInterfacesRemovedFromObjectTypes ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectives ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectiveArgs ( $ oldSchema , $ newSchema ) , self :: findAddedNonNullDirectiveArgs ( $ oldSchema , $ newSchema ) , self :: findRemovedDirectiveLocations ( $ oldSchema , $ newSchema ) ) ; }
2145	public function replace ( $ strBuffer , $ blnCache = true ) { $ strBuffer = $ this -> doReplace ( $ strBuffer , $ blnCache ) ; while ( strpos ( $ strBuffer , '{{' ) !== false && ( $ strTmp = $ this -> doReplace ( $ strBuffer , $ blnCache ) ) != $ strBuffer ) { $ strBuffer = $ strTmp ; } return $ strBuffer ; }
1146	public function addConditionalRules ( $ attribute , $ rules = [ ] ) { foreach ( ( array ) $ attribute as $ key ) { $ current = isset ( $ this -> conditional [ $ key ] ) ? $ this -> conditional [ $ key ] : [ ] ; $ merge = head ( $ this -> validator -> explodeRules ( ( array ) $ rules ) ) ; $ this -> conditional [ $ key ] = array_merge ( $ current , $ merge ) ; } }
10176	public function getHighestRow ( $ column = null ) { if ( $ column == null ) { $ colRow = $ this -> getHighestRowAndColumn ( ) ; return $ colRow [ 'row' ] ; } $ rowList = [ 0 ] ; foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ c != $ column ) { continue ; } $ rowList [ ] = $ r ; } return max ( $ rowList ) ; }
3556	public function setMetaGroup ( $ group = null ) { if ( ! preg_match ( '/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/' , $ group ) && $ group !== null ) { throw new InvalidArgumentException ( "Provided group [{$group}] is not valid variable name." ) ; } $ this -> attributes [ 'meta_group' ] = $ group ; }
11782	protected function generateSourceFromChildren ( ) { $ i = 1 ; $ children = array ( ) ; foreach ( $ this -> children as $ child ) { $ childValue = Yaml :: parse ( $ child -> getSource ( ) ) ; if ( is_array ( $ childValue ) && array_key_exists ( "type" , $ childValue ) ) { $ childValue [ "type" ] = $ child -> getType ( ) ; } $ children [ 'item' . $ i ] = $ childValue ; $ i ++ ; } $ source = array ( "children" => $ children , ) ; if ( ! empty ( $ this -> tags ) ) { $ source [ "tags" ] = $ this -> tags ; } $ source [ "type" ] = $ this -> type ; return $ source ; }
6303	protected function active ( array $ nav ) { foreach ( $ nav as $ key => $ value ) { if ( isset ( $ value [ 'slug' ] ) ) { if ( $ this -> request -> is ( $ value [ 'slug' ] ) || $ this -> request -> is ( $ value [ 'slug' ] . '/*' ) ) { $ nav [ $ key ] [ 'active' ] = true ; } else { $ nav [ $ key ] [ 'active' ] = false ; } } else { $ nav [ $ key ] [ 'active' ] = false ; } } return $ nav ; }
10319	function getBlocksCount ( $ fromDate = null , $ toDate = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ reasons = null , $ oldStatus = null , $ newStatus = null , $ excludeAnonymousBlocks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , null , null ) ; if ( isset ( $ excludeAnonymousBlocks ) ) $ params [ 'exclude_anonymous_blocks' ] = ( $ excludeAnonymousBlocks == true ) ? "true" : "false" ; $ params = $ this -> appendArrayFields ( $ params , "reasons" , $ reasons ) ; if ( isset ( $ oldStatus ) ) $ params [ 'old_status' ] = $ oldStatus ; if ( isset ( $ newStatus ) ) $ params [ 'new_status' ] = $ newStatus ; return $ this -> get ( 'reports/blocks/count' , $ params ) ; }
2141	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof User ) { return ; } $ sessionBag = $ this -> getSessionBag ( $ event -> getRequest ( ) ) ; $ data = $ sessionBag -> all ( ) ; $ this -> connection -> update ( $ user -> getTable ( ) , [ 'session' => serialize ( $ data ) ] , [ 'id' => $ user -> id ] ) ; }
8148	public function compile ( Twig_NodeInterface $ node ) { if ( null === $ this -> compiler ) { $ this -> compiler = new Twig_Compiler ( $ this ) ; } return $ this -> compiler -> compile ( $ node ) -> getSource ( ) ; }
8179	public function login ( ) { return $ this -> validate ( ) ? Yii :: $ app -> user -> login ( $ this -> getUser ( ) , $ this -> rememberMe ? UserModule :: $ rememberMeDuration : 0 ) : FALSE ; }
3118	public function removeCatValue ( $ testSessionId , $ assessmentSectionId , $ key ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> removeCatValue ( $ assessmentSectionId , $ key ) ; $ extendedState -> save ( ) ; }
1406	protected function getDefaultAttributes ( Model $ model ) { $ defaults = [ ] ; if ( $ this -> hasCreatedAtAttribute ( $ model ) ) { $ createdAt = $ model -> getCreatedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ createdAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ createdAt , $ field ) ; } if ( $ this -> hasUpdatedAtAttribute ( $ model ) ) { $ updatedAt = $ model -> getUpdatedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ updatedAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ updatedAt , $ field ) ; } if ( $ this -> hasDeletedAtAttribute ( $ model ) ) { $ deletedAt = $ model -> getDeletedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ deletedAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ deletedAt , $ field ) ; } return $ defaults ; }
4274	public function stream_flush ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ fflush ( $ this -> handle ) ; self :: register ( ) ; return $ success ; }
6642	public static function encodeId ( $ id , $ salt , $ hashLength = self :: MIN_HASH_LENGTH ) { $ hashIds = new Hashids ( $ salt , $ hashLength ) ; return $ hashIds -> encode ( $ id ) ; }
10039	public function trySimpleXMLLoadString ( $ pFilename ) { try { $ xml = simplexml_load_string ( $ this -> securityScan ( file_get_contents ( $ pFilename ) ) , 'SimpleXMLElement' , Settings :: getLibXmlLoaderOptions ( ) ) ; } catch ( \ Exception $ e ) { throw new Exception ( 'Cannot load invalid XML file: ' . $ pFilename , 0 , $ e ) ; } return $ xml ; }
1092	public function reload ( ) { if ( $ this -> exists || ( $ this -> areSoftDeletesEnabled ( ) && $ this -> trashed ( ) ) ) { $ fresh = $ this -> getFreshInstance ( ) ; if ( is_null ( $ fresh ) ) throw with ( new ModelNotFoundException ) -> setModel ( get_called_class ( ) ) ; $ this -> setRawAttributes ( $ fresh -> getAttributes ( ) , true ) ; $ this -> setRelations ( $ fresh -> getRelations ( ) ) ; $ this -> exists = $ fresh -> exists ; } else { $ this -> attributes = $ this -> original ; } return $ this ; }
968	protected function cancelCharge ( ) { $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } }
9390	public function getSortValBeforeAll ( $ groupingId = null ) { if ( $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( [ $ this -> pkColumn , $ this -> srtColumn ] ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( [ $ this -> srtColumn => SORT_ASC ] ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result && $ result [ $ this -> srtColumn ] == 1 ) { $ this -> rebuildSortAfter ( $ result [ $ this -> pkColumn ] , true ) ; $ sortVal = $ this -> getIniSortVal ( ) ; } else if ( $ result ) { $ sortVal = ceil ( $ result [ $ this -> srtColumn ] / 2 ) ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
9528	private function parseSingle ( & $ i , $ parameter , & $ results ) { if ( $ this -> prefixExists ( $ parameter ) ) { $ closure = $ this -> getClosure ( $ parameter ) ; if ( $ closure != null ) { $ prefix = $ this -> getPrefix ( $ parameter ) ; $ closure_arguments = [ ] ; $ rFunction = new ReflectionFunction ( $ closure ) ; if ( $ rFunction -> isVariadic ( ) ) { $ this -> parseVariadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter ) ; } else { $ this -> parseUniadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter , $ rFunction ) ; } $ result_key = $ this -> getRealName ( $ parameter ) ; $ result = $ results [ $ result_key ] ; if ( ! $ result instanceof ParameterResult ) { if ( $ result == self :: HALT_PARSE ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; unset ( $ results [ $ result_key ] ) ; return false ; } } else { if ( $ result -> shouldHalt ( ) ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; if ( $ result -> isHaltOnly ( ) ) { unset ( $ results [ $ result_key ] ) ; } else { $ results [ $ result_key ] = $ result -> getValue ( ) ; } return false ; } } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } return true ; }
7135	public function getPercent ( ) : float { $ amount = $ this -> getAmount ( ) ; if ( 0 < $ this -> sellingPrice ) { return round ( $ amount * 100 / $ this -> sellingPrice , 2 ) ; } return 0 ; }
7142	private function registerActions ( ContainerBuilder $ container ) { if ( class_exists ( 'Ekyna\Component\Payum\Payzen\PayzenGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.convert_payment' , $ definition ) ; $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\FraudLevelAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.fraud_level' , $ definition ) ; } if ( class_exists ( 'Ekyna\Component\Payum\Sips\SipsGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Sips\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'atos_sips' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.sips.convert_payment' , $ definition ) ; } if ( class_exists ( 'Payum\Paypal\ExpressCheckout\Nvp\PaypalExpressCheckoutGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Paypal\Action\EcNvpConvertAction' ) ; $ definition -> setArgument ( 0 , new Reference ( 'ekyna_commerce.common.amount_calculator' ) ) ; if ( $ container -> has ( 'ekyna_setting.manager' ) && class_exists ( 'Ekyna\Bundle\AdminBundle\Settings\GeneralSettingsSchema' ) ) { $ definition -> setArgument ( 1 , new Expression ( "service('ekyna_setting.manager').getParameter('general.site_name')" ) ) ; } $ definition -> addTag ( 'payum.action' , [ 'factory' => 'paypal_express_checkout' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.paypal_ec_nvp.convert_payment' , $ definition ) ; } $ actions = [ 'capture_payment' => Action \ CaptureAction :: class , 'notify_payment' => Action \ NotifyAction :: class , 'status_payment' => Action \ StatusAction :: class , ] ; foreach ( $ actions as $ name => $ class ) { $ definition = new Definition ( $ class ) ; $ definition -> addTag ( 'payum.action' , [ 'all' => true , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.' . $ name , $ definition ) ; } }
2097	public static function getRegexp ( $ strFormat = null ) { if ( $ strFormat === null ) { $ strFormat = static :: getNumericDateFormat ( ) ; } if ( ! static :: isNumericFormat ( $ strFormat ) ) { throw new \ Exception ( sprintf ( 'Invalid date format "%s"' , $ strFormat ) ) ; } return preg_replace_callback ( '/[a-zA-Z]/' , function ( $ matches ) { $ arrRegexp = array ( 'a' => '(?P<a>am|pm)' , 'A' => '(?P<A>AM|PM)' , 'd' => '(?P<d>0[1-9]|[12][0-9]|3[01])' , 'g' => '(?P<g>[1-9]|1[0-2])' , 'G' => '(?P<G>[0-9]|1[0-9]|2[0-3])' , 'h' => '(?P<h>0[1-9]|1[0-2])' , 'H' => '(?P<H>[01][0-9]|2[0-3])' , 'i' => '(?P<i>[0-5][0-9])' , 'j' => '(?P<j>[1-9]|[12][0-9]|3[01])' , 'm' => '(?P<m>0[1-9]|1[0-2])' , 'n' => '(?P<n>[1-9]|1[0-2])' , 's' => '(?P<s>[0-5][0-9])' , 'Y' => '(?P<Y>[0-9]{4})' , 'y' => '(?P<y>[0-9]{2})' , ) ; return $ arrRegexp [ $ matches [ 0 ] ] ?? $ matches [ 0 ] ; } , preg_quote ( $ strFormat ) ) ; }
499	protected function writeInteger ( $ fileHandle , $ integer ) { return $ this -> writeBytes ( $ fileHandle , pack ( $ this -> useBigEndian ? 'N' : 'V' , ( int ) $ integer ) ) ; }
12683	public function process ( ) { $ orderedTasks = $ this -> _tasks ; usort ( $ orderedTasks , function ( $ a , $ b ) { return $ a -> duration ( ) > $ b -> duration ( ) ? 1 : - 1 ; } ) ; $ this -> _ranking = $ orderedTasks ; $ matrix = [ ] ; foreach ( $ this -> _ranking as $ task1 ) { $ name1 = $ task1 -> name ( ) ; $ matrix [ $ name1 ] = [ ] ; foreach ( $ this -> _ranking as $ task2 ) { $ name2 = $ task2 -> name ( ) ; $ percent = intval ( round ( $ task1 -> duration ( ) / $ task2 -> duration ( ) * 100 ) ) ; $ matrix [ $ name1 ] [ $ name2 ] = $ percent ; } } $ this -> _matrix = $ matrix ; return $ this ; }
3012	public function unfollow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/unfollow' , $ options , false ) ; }
11175	public static function verify ( $ real , $ hash ) { $ hash = base64_decode ( $ hash ) ; return crypt ( $ real , $ hash ) == $ hash ; }
6471	public function parseContentTypeHeader ( HttpHeaders $ headers ) : ? ContentTypeHeaderValue { if ( ! $ headers -> containsKey ( 'Content-Type' ) ) { return null ; } $ contentTypeHeaderParameters = $ this -> parseParameters ( $ headers , 'Content-Type' ) ; $ contentType = $ contentTypeHeaderParameters -> getKeys ( ) [ 0 ] ; return new ContentTypeHeaderValue ( $ contentType , $ contentTypeHeaderParameters ) ; }
10882	protected function aggregateTernaryValues ( array $ values ) { if ( in_array ( false , $ values , true ) ) { return false ; } elseif ( in_array ( true , $ values , true ) ) { return true ; } else { return null ; } }
4386	protected function dumpMethods ( $ methods ) { $ str = '' ; if ( ! empty ( $ methods ) ) { $ counts = array ( 'public' => 0 , 'protected' => 0 , 'private' => 0 , 'magic' => 0 , ) ; foreach ( $ methods as $ info ) { $ counts [ $ info [ 'visibility' ] ] ++ ; } $ str .= ' Methods:' . "\n" ; foreach ( $ counts as $ vis => $ count ) { if ( $ count ) { $ str .= ' ' . $ vis . ': ' . $ count . "\n" ; } } } else { $ str .= ' Methods: none!' . "\n" ; } return $ str ; }
2730	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , Config :: AUTH_DICTIONARY_NAME ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; if ( ( $ status == true && is_array ( $ authItems ) && count ( $ authItems ) < 2 ) || $ authItems == false ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'While Basic Authentication is enabled, at least one user must exist.' , ] ) ; } $ itemKey = $ this -> getRequest ( ) -> getParam ( 'item_key_id' ) ; $ deleteItem = $ this -> api -> deleteDictionaryItem ( $ dictionary -> id , $ itemKey ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Dictionary item.' ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4772	public function configs ( Request $ request , WidgetInterface $ widget , CacheInterface $ cache , string $ widgetId ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; if ( $ request -> get ( 'remove' ) ) { $ widgetConfig -> removeWidgetConfig ( $ widgetId , $ widgets [ $ widgetId ] -> getConfigProcess ( $ request ) ?? [ ] ) ; } else { $ widgetConfig -> addWidgetConfig ( $ widgetId , $ widgets [ $ widgetId ] -> getConfigProcess ( $ request ) ?? [ ] ) ; } $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; $ cache -> delete ( $ widgetId . $ this -> getUser ( ) -> getId ( ) ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
11844	private function addAPerson ( array $ person , ObjectManager $ manager ) { $ p = new Person ( ) ; foreach ( $ person as $ key => $ value ) { switch ( $ key ) { case 'CountryOfBirth' : case 'Nationality' : $ value = $ this -> getCountry ( $ value ) ; break ; case 'Birthdate' : $ value = new \ DateTime ( $ value ) ; break ; case 'center' : case 'maritalStatus' : $ value = $ this -> getReference ( $ value ) ; break ; } if ( method_exists ( $ p , 'set' . $ key ) ) { call_user_func ( array ( $ p , 'set' . $ key ) , $ value ) ; } elseif ( method_exists ( $ p , 'add' . $ key ) ) { if ( ! is_array ( $ value ) ) { $ value = array ( $ value ) ; } foreach ( $ value as $ v ) { if ( $ v !== NULL ) { call_user_func ( array ( $ p , 'add' . $ key ) , $ v ) ; } } } } $ manager -> persist ( $ p ) ; echo "add person'" . $ p -> __toString ( ) . "'\n" ; }
11617	public function records ( $ startTime , $ endTime , $ page = 1 , $ pageSize = 10 ) { $ params = [ 'starttime' => is_numeric ( $ startTime ) ? $ startTime : strtotime ( $ startTime ) , 'endtime' => is_numeric ( $ endTime ) ? $ endTime : strtotime ( $ endTime ) , 'pageindex' => $ page , 'pagesize' => $ pageSize , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RECORDS , $ params ] ) ; }
5854	protected function persistFlexForm ( array & $ valueArray ) { foreach ( $ valueArray as $ key => $ value ) { if ( $ key === 'el' ) { foreach ( $ value as $ idx => $ v ) { if ( $ v && substr ( $ idx , 0 , 3 ) === 'ID-' ) { $ valueArray [ $ key ] [ substr ( $ idx , 3 ) ] = $ v ; unset ( $ valueArray [ $ key ] [ $ idx ] ) ; } } } elseif ( isset ( $ valueArray [ $ key ] ) ) { $ this -> persistFlexForm ( $ valueArray [ $ key ] ) ; } } }
2819	public function initQueries ( ) { $ this -> queries = array ( ) ; $ profiler = Mage :: helper ( 'sheep_debug' ) -> getSqlProfiler ( ) ; if ( $ profiler -> getEnabled ( ) && $ profiler instanceof Sheep_Debug_Model_Db_Profiler ) { $ this -> queries = $ profiler -> getQueryModels ( ) ? : array ( ) ; $ this -> setQueryCount ( $ profiler -> getTotalNumQueries ( ) ) ; $ this -> setQueryTime ( $ profiler -> getTotalElapsedSecs ( ) ) ; } }
1157	protected function ruleConfirmed ( $ attribute , array $ parameters ) { $ parameters [ 0 ] = $ this -> getAttributeName ( $ attribute ) ; $ attribute = "{$attribute}_confirmation" ; return [ $ attribute , $ parameters ] ; }
10311	function getRecipients ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeDeletedRecipients = false , $ standardFields = null , $ customFields = null , $ embedFieldBackups = false , $ pageIndex = 1 , $ pageSize = 100 ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null , $ embedFieldBackups ) ; $ params = $ this -> appendArrayFields ( $ params , "standard_field" , $ standardFields ) ; $ params = $ this -> appendArrayFields ( $ params , "custom_field" , $ customFields ) ; if ( isset ( $ excludeDeletedRecipients ) ) $ params [ 'exclude_deleted_recipients' ] = ( $ excludeDeletedRecipients == true ) ? "true" : "false" ; return $ this -> get ( 'reports/recipients' , $ params ) ; }
5032	public function getLoadedPage ( $ default = null ) { if ( ! $ this -> loadedPage ) { if ( is_callable ( $ default ) ) { $ page = call_user_func ( $ default , $ this ) ; if ( $ page !== null ) { $ this -> setLoadedPage ( $ page ) ; } } if ( ! $ this -> loadedPage ) { throw new NotFoundHttpException ( "There is no page currently loaded, but it was expected" ) ; } } return $ this -> loadedPage ; }
2968	protected function pickMetadata ( $ data ) { $ metadata = [ ] ; if ( ArrayUtils :: has ( $ data , 'rows' ) ) { $ metadata = ArrayUtils :: omit ( $ data , 'rows' ) ; } else if ( ArrayUtils :: has ( $ data , 'meta' ) ) { $ metadata = ArrayUtils :: get ( $ data , 'meta' ) ; } return new Entry ( $ metadata ) ; }
9555	public function getHandler ( ) { if ( $ this -> namer === null ) { $ this -> namer = new GenericNamer ( ) ; } if ( $ this -> filesystem === null ) { throw new \ LogicException ( sprintf ( 'You should set a filesystem for the builder.' ) ) ; } $ handler = new UploadHandler ( $ this -> filesystem , $ this -> namer , $ this -> overwrite ) ; $ validator = $ handler -> getValidator ( ) ; foreach ( $ this -> constraints as $ constraint ) { $ validator -> addConstraint ( $ constraint ) ; } return $ handler ; }
828	private function isValidVariable ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_VARIABLE ) ) { return false ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; return $ tokens [ $ nextIndex ] -> equals ( '=' ) ; }
9465	public function getSummary ( ) { $ string = "---\n" ; foreach ( $ this -> getWords ( ) as $ k => $ v ) { $ string .= '[' . $ k . ']: Docs:' . $ v [ 'docs' ] . ' | Hits:' . $ v [ 'hits' ] . "\n" ; } return $ string ; }
11358	public function removeBlock ( $ blockFile ) { foreach ( $ this -> permalinks as $ permalink => $ associatedBlocks ) { $ tmp = array_flip ( $ associatedBlocks ) ; unset ( $ tmp [ $ blockFile ] ) ; if ( empty ( $ tmp ) ) { unset ( $ this -> permalinks [ $ permalink ] ) ; continue ; } $ this -> permalinks [ $ permalink ] = array_flip ( $ tmp ) ; } return $ this ; }
5953	public function channelList ( array $ filter = array ( ) ) { if ( $ this -> channelList === null ) { $ channels = $ this -> request ( "channellist -topic -flags -voice -limits -icon" ) -> toAssocArray ( "cid" ) ; $ this -> channelList = array ( ) ; foreach ( $ channels as $ cid => $ channel ) { $ this -> channelList [ $ cid ] = new Channel ( $ this , $ channel ) ; } $ this -> resetNodeList ( ) ; } return $ this -> filterList ( $ this -> channelList , $ filter ) ; }
4786	function offsetGet ( $ key ) { $ this -> access ( $ key ) ; if ( ! array_key_exists ( $ key , $ this -> row ) ) { $ this -> access ( $ key , true ) ; } return $ this -> row [ $ key ] ; }
2201	public static function initialize ( ) { $ _GET = static :: cleanKey ( $ _GET ) ; $ _POST = static :: cleanKey ( $ _POST ) ; $ _COOKIE = static :: cleanKey ( $ _COOKIE ) ; }
508	protected function composeFields ( $ id = null , $ data = null ) { $ fields = $ this -> writeCallback ? call_user_func ( $ this -> writeCallback , $ this ) : [ ] ; if ( $ id !== null ) { $ fields [ 'id' ] = $ id ; } if ( $ data !== null ) { $ fields [ 'data' ] = $ data ; } return $ fields ; }
1873	private function addBundles ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; if ( $ container -> hasDefinition ( 'assets._version_default' ) ) { $ version = new Reference ( 'assets._version_default' ) ; } else { $ version = new Reference ( 'assets.empty_version_strategy' ) ; } $ bundles = $ container -> getParameter ( 'kernel.bundles' ) ; $ meta = $ container -> getParameter ( 'kernel.bundles_metadata' ) ; foreach ( $ bundles as $ name => $ class ) { if ( ! is_dir ( $ meta [ $ name ] [ 'path' ] . '/Resources/public' ) ) { continue ; } $ packageVersion = $ version ; $ packageName = $ this -> getBundlePackageName ( $ name ) ; $ serviceId = 'assets._package_' . $ packageName ; $ basePath = 'bundles/' . preg_replace ( '/bundle$/' , '' , strtolower ( $ name ) ) ; if ( is_file ( $ meta [ $ name ] [ 'path' ] . '/Resources/public/manifest.json' ) ) { $ def = new ChildDefinition ( 'assets.json_manifest_version_strategy' ) ; $ def -> replaceArgument ( 0 , $ meta [ $ name ] [ 'path' ] . '/Resources/public/manifest.json' ) ; $ container -> setDefinition ( 'assets._version_' . $ packageName , $ def ) ; $ packageVersion = new Reference ( 'assets._version_' . $ packageName ) ; } $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ packageVersion , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ packageName , new Reference ( $ serviceId ) ] ) ; } }
4458	public function fire ( AbstractUserEvent $ event ) { $ status = null ; $ type = $ event :: getEntityName ( ) ; if ( isset ( $ this -> events [ $ type ] ) ) { $ queue = $ this -> events [ $ type ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } $ eventName = $ event -> getName ( ) ; if ( isset ( $ this -> events [ $ eventName ] ) ) { $ queue = $ this -> events [ $ eventName ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } return $ status ; }
5174	public function get ( string $ key ) { return isset ( $ this -> props [ $ key ] ) ? $ this -> props [ $ key ] : null ; }
2660	public function getRequest ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET , '' , false , null , false ) ; return $ result ; }
4346	private function doSetCfg ( $ cfg ) { $ return = array ( ) ; foreach ( $ cfg as $ k => $ v ) { if ( $ k == 'debug' ) { $ return [ $ k ] = \ array_intersect_key ( $ this -> cfg , $ v ) ; $ this -> setDebugCfg ( $ v ) ; } elseif ( isset ( $ this -> debug -> { $ k } ) && \ is_object ( $ this -> debug -> { $ k } ) ) { $ return [ $ k ] = \ array_intersect_key ( $ this -> getCfg ( $ k . '/*' ) , $ v ) ; $ this -> debug -> { $ k } -> setCfg ( $ v ) ; } elseif ( isset ( $ this -> cfgLazy [ $ k ] ) ) { $ return [ $ k ] = \ array_intersect_key ( $ this -> cfgLazy [ $ k ] , $ v ) ; $ this -> cfgLazy [ $ k ] = \ array_merge ( $ this -> cfgLazy [ $ k ] , $ v ) ; } else { $ return [ $ k ] = array ( ) ; $ this -> cfgLazy [ $ k ] = $ v ; } } return $ return ; }
7722	function meth_Misc_Alert ( $ Src , $ Msg , $ NoErrMsg = false , $ SrcType = false ) { $ this -> ErrCount ++ ; if ( $ this -> NoErr || ( php_sapi_name === 'cli' ) ) { $ t = array ( '' , '' , '' , '' , '' ) ; } else { $ t = array ( '<br /><b>' , '</b>' , '<em>' , '</em>' , '<br />' ) ; $ Msg = htmlentities ( $ Msg ) ; } if ( ! is_string ( $ Src ) ) { if ( $ SrcType === false ) $ SrcType = 'in field' ; if ( isset ( $ Src -> PrmLst [ 'tbstype' ] ) ) { $ Msg = 'Column \'' . $ Src -> SubName . '\' is expected but missing in the current record.' ; $ Src = 'Parameter \'' . $ Src -> PrmLst [ 'tbstype' ] . '=' . $ Src -> SubName . '\'' ; $ NoErrMsg = false ; } else { $ Src = $ SrcType . ' ' . $ this -> _ChrOpen . $ Src -> FullName . '...' . $ this -> _ChrClose ; } } $ x = $ t [ 0 ] . 'TinyButStrong Error' . $ t [ 1 ] . ' ' . $ Src . ': ' . $ Msg ; if ( $ NoErrMsg ) $ x = $ x . ' ' . $ t [ 2 ] . 'This message can be cancelled using parameter \'noerr\'.' . $ t [ 3 ] ; $ x = $ x . $ t [ 4 ] . "\n" ; if ( $ this -> NoErr ) { $ this -> ErrMsg .= $ x ; } else { if ( php_sapi_name !== 'cli' ) { $ x = str_replace ( $ this -> _ChrOpen , $ this -> _ChrProtect , $ x ) ; } echo $ x ; } return false ; }
4276	public function stream_metadata ( $ path , $ option , $ value ) { self :: restorePrev ( ) ; switch ( $ option ) { case STREAM_META_TOUCH : if ( ! empty ( $ value ) ) { $ success = \ touch ( $ path , $ value [ 0 ] , $ value [ 1 ] ) ; } else { $ success = \ touch ( $ path ) ; } break ; case STREAM_META_OWNER_NAME : case STREAM_META_OWNER : $ success = \ chown ( $ path , $ value ) ; break ; case STREAM_META_GROUP_NAME : case STREAM_META_GROUP : $ success = \ chgrp ( $ path , $ value ) ; break ; case STREAM_META_ACCESS : $ success = \ chmod ( $ path , $ value ) ; break ; default : $ success = false ; } self :: register ( ) ; return $ success ; }
3796	private function checkForRoot ( $ containedModel , $ action ) { if ( $ this -> hasVariants ( ) && $ action == 'cut' && $ containedModel -> getProperty ( 'varbase' ) == 0 ) { $ this -> disablePI = true ; } }
4094	public function query ( array $ options = array ( ) ) { if ( ! ( $ this -> query instanceof Query ) ) $ this -> query = new Query ( $ options ) ; return $ this -> query ; }
7401	private function getErrors ( Form $ form ) { $ errors = array ( ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { return $ errors ; } $ id = $ form -> createView ( ) -> vars [ 'id' ] ; foreach ( $ form -> getErrors ( ) as $ error ) { if ( ! isset ( $ errors [ $ id ] ) ) { $ errors [ $ id ] = array ( ) ; } $ errors [ $ id ] [ ] = $ error -> getMessage ( ) ; } foreach ( $ form -> all ( ) as $ child ) { $ errors = array_merge ( $ this -> getErrors ( $ child ) , $ errors ) ; } return $ errors ; }
3179	public function getQtiItems ( \ core_kernel_classes_Class $ itemClass , $ format = 'list' , $ search = '' , $ offset = 0 , $ limit = 30 ) { $ propertyFilters = [ ] ; if ( $ this -> hasOption ( self :: ITEM_MODEL_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_MODEL_URI ] = $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) ; } if ( $ this -> hasOption ( self :: ITEM_CONTENT_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_CONTENT_URI ] = '*' ; } if ( is_string ( $ search ) && strlen ( trim ( $ search ) ) > 0 ) { $ propertyFilters [ self :: LABEL_URI ] = $ search ; } if ( is_array ( $ search ) ) { foreach ( $ search as $ uri => $ value ) { if ( is_string ( $ uri ) && ( is_string ( $ value ) && strlen ( trim ( $ value ) ) > 0 ) || ( is_array ( $ value ) && count ( $ value ) > 0 ) ) { $ propertyFilters [ $ uri ] = $ value ; } } } $ result = [ ] ; if ( in_array ( $ format , self :: $ formats ) ) { $ itemLookup = $ this -> getServiceLocator ( ) -> get ( self :: SERVICE_ID . '/' . $ format ) ; if ( ! is_null ( $ itemLookup ) && $ itemLookup instanceof ItemLookup ) { $ result = $ itemLookup -> getItems ( $ itemClass , $ propertyFilters , $ offset , $ limit ) ; } } return $ result ; }
11849	protected function getSettingsFromRealSource ( $ namespace ) { $ arraySettings = $ this -> getSettingsArray ( $ namespace ) ; $ namespaceOptions = $ this -> options -> getNamespaceOptions ( $ namespace ) ; $ entity = clone ( $ namespaceOptions -> getEntityPrototype ( ) ) ; if ( ! empty ( $ arraySettings ) ) { $ hydrator = $ this -> namespaceHydratorProvider -> getHydrator ( $ namespace ) ; $ entity = $ hydrator -> hydrate ( $ arraySettings , $ entity ) ; } return $ entity ; }
6487	protected function createHeadersFromSuperglobals ( array $ server ) : HttpHeaders { $ headers = new HttpHeaders ( ) ; foreach ( $ server as $ name => $ values ) { $ containsMultipleValues = isset ( self :: $ headersThatPermitMultipleValues [ $ name ] ) && count ( $ explodedValues = preg_split ( '/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/' , $ values ) ) > 1 ; if ( $ containsMultipleValues ) { foreach ( $ explodedValues as $ value ) { $ this -> addHeaderValue ( $ headers , $ name , $ value , true ) ; } } else { $ this -> addHeaderValue ( $ headers , $ name , $ values , false ) ; } } return $ headers ; }
9824	public function writeWorksheetRelationships ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet , $ pWorksheetId = 1 , $ includeCharts = false ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ d = 0 ; if ( $ includeCharts ) { $ charts = $ pWorksheet -> getChartCollection ( ) ; } else { $ charts = [ ] ; } if ( ( $ pWorksheet -> getDrawingCollection ( ) -> count ( ) > 0 ) || ( count ( $ charts ) > 0 ) ) { $ this -> writeRelationship ( $ objWriter , ++ $ d , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing' , '../drawings/drawing' . $ pWorksheetId . '.xml' ) ; } $ i = 1 ; foreach ( $ pWorksheet -> getHyperlinkCollection ( ) as $ hyperlink ) { if ( ! $ hyperlink -> isInternal ( ) ) { $ this -> writeRelationship ( $ objWriter , '_hyperlink_' . $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink' , $ hyperlink -> getUrl ( ) , 'External' ) ; ++ $ i ; } } $ i = 1 ; if ( count ( $ pWorksheet -> getComments ( ) ) > 0 ) { $ this -> writeRelationship ( $ objWriter , '_comments_vml' . $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing' , '../drawings/vmlDrawing' . $ pWorksheetId . '.vml' ) ; $ this -> writeRelationship ( $ objWriter , '_comments' . $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments' , '../comments' . $ pWorksheetId . '.xml' ) ; } $ i = 1 ; if ( count ( $ pWorksheet -> getHeaderFooter ( ) -> getImages ( ) ) > 0 ) { $ this -> writeRelationship ( $ objWriter , '_headerfooter_vml' . $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing' , '../drawings/vmlDrawingHF' . $ pWorksheetId . '.vml' ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
10967	public static function isSsl ( ) { $ isSecure = false ; if ( isset ( $ _SERVER [ 'HTTPS' ] ) && in_array ( $ _SERVER [ 'HTTPS' ] , [ 'on' , '1' ] ) ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] == 'https' ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] == 'on' ) { $ isSecure = true ; } return $ isSecure ; }
4711	public function wrap ( $ start , $ end ) { $ this -> text = $ start . $ this -> text . $ end ; return $ this ; }
7433	public function export ( Defender $ defender ) { $ content = json_encode ( $ defender -> dangerFiles ) ; $ name = 'defender/defender-' . $ this -> date . '.json' ; if ( $ this -> storage -> exists ( $ name ) ) { $ this -> storage -> delete ( $ name ) ; } $ this -> storage -> put ( $ name , $ content ) ; }
12824	protected function addBlockToSlot ( $ dir , array $ options ) { $ slot = $ this -> getSlotDefinition ( $ dir ) ; $ blocks = $ slot [ "blocks" ] ; $ blockName = $ options [ "blockname" ] ; $ position = $ options [ "position" ] ; array_splice ( $ blocks , $ position , 0 , $ blockName ) ; $ slot [ "next" ] = str_replace ( 'block' , '' , $ blockName ) + 1 ; $ slot [ "blocks" ] = $ blocks ; $ this -> saveSlotDefinition ( $ dir , $ slot ) ; return $ blockName ; }
7544	function getNextSibling ( $ skip_text_comments = true ) { $ offset = 1 ; while ( ( $ n = $ this -> getSibling ( $ offset ) ) !== null ) { if ( $ skip_text_comments && ( $ n -> tag [ 0 ] === '~' ) ) { ++ $ offset ; } else { break ; } } return $ n ; }
2377	public static function convertEncoding ( $ str , $ to , $ from = null ) { if ( $ str == '' ) { return '' ; } if ( ! $ from ) { $ from = mb_detect_encoding ( $ str , 'ASCII,ISO-2022-JP,UTF-8,EUC-JP,ISO-8859-1' ) ; } if ( $ from == $ to ) { return $ str ; } if ( $ from == 'UTF-8' && $ to == 'ISO-8859-1' ) { return utf8_decode ( $ str ) ; } if ( $ from == 'ISO-8859-1' && $ to == 'UTF-8' ) { return utf8_encode ( $ str ) ; } return mb_convert_encoding ( $ str , $ to , $ from ) ; }
11036	function elt_label ( $ eltid ) { switch ( $ eltid ) { case _ETS_ROOT : return 'root element' ; case _ETS_TEXT : return 'text element' ; case _ETS_TAG : return 'simple tag element' ; case _ETS_ALT_TAG : return 'alternate tag element' ; case _ETS_TEMPLATE : return 'template element' ; case _ETS_SET : return 'set element' ; case _ETS_SETVAL : return 'set-value element' ; case _ETS_MIS : return 'missing element' ; case _ETS_MISVAL : return 'missing-value element' ; case _ETS_PHP : return 'PHP element' ; case _ETS_CONST : return 'constant element' ; case _ETS_IF : return 'if element' ; case _ETS_CODE : return 'PHP code or test' ; case _ETS_CHOOSE : return 'choose element' ; case _ETS_WHENTEST : return 'when-test element' ; case _ETS_ELSE : return 'else element' ; case _ETS_CHOOSEVAR : return 'choose-variable element' ; case _ETS_WHENVAL : return 'when-value element' ; case _ETS_CALL : return 'call element' ; case _ETS_ARG : return 'argument element' ; case _ETS_MIS_TEMPLATE : return 'missing template element' ; case _ETS_REDUCE : return 'reduce element' ; case _ETS_REPEAT : return 'repeat element' ; case _ETS_RSS : return 'rss element' ; case _ETS_INCLUDE : return 'include element' ; case _ETS_INSERT : return 'insert element' ; case _ETS_EVAL : return 'eval element' ; case _ETS_SAFE : return 'safe eval element' ; case _ETS_ROOT_EVAL : return 'eval or safe element' ; case _ETS_PLACE : return 'place element' ; } }
7530	protected function toString_attributes ( ) { $ s = '' ; foreach ( $ this -> attributes as $ a => $ v ) { $ s .= ' ' . $ a ; if ( ( ! $ this -> attribute_shorttag ) || ( $ v !== $ a ) ) { $ quote = ( strpos ( $ v , '"' ) === false ) ? '"' : "'" ; $ s .= '=' . $ quote . $ v . $ quote ; } } return $ s ; }
7857	public function register ( ) { $ this -> registerPipelineRepository ( ) ; $ this -> registerInflector ( ) ; $ this -> registerDispatcher ( ) ; $ this -> registerWorkflow ( ) ; $ this -> registerWorkflowRunnersHook ( ) ; $ this -> registerCommands ( ) ; }
12648	public function get ( ) { $ arResult = [ 'status' => $ this -> status ( ) , 'data' => $ this -> data ( ) , 'message' => $ this -> message ( ) , 'code' => $ this -> code ( ) , ] ; return $ arResult ; }
4835	public function merchant ( $ id = null ) { if ( $ id == null ) { $ id = $ this -> account_details [ 'merchant_id' ] ; } return GoCardless_Merchant :: find_with_client ( $ this , $ id ) ; }
6158	protected function renderItem ( $ link , $ template ) { if ( isset ( $ link [ 'label' ] ) ) { $ label = $ this -> encodeLabels ? Html :: encode ( $ link [ 'label' ] ) : $ link [ 'label' ] ; } else { throw new InvalidConfigException ( 'The "label" element is required for each link.' ) ; } if ( $ link [ 'options' ] [ 'class' ] ) { $ label = Html :: tag ( 'i' , '' , $ link [ 'options' ] ) . $ label ; } if ( isset ( $ link [ 'url' ] ) ) { return strtr ( $ template , [ '{link}' => Html :: a ( $ label , $ link [ 'url' ] ) ] ) ; } else { return strtr ( $ template , [ '{link}' => $ label ] ) ; } }
8345	public static function prefix ( string $ namespace , $ subdomain = null , string $ uri = null ) { self :: $ namespace = $ namespace ; self :: $ subdomain = is_array ( $ subdomain ) ? $ subdomain : [ $ subdomain ] ; self :: $ uri = $ uri ; }
12074	public function childIndex ( FilterRequest $ filters , $ id , $ relation ) { $ id = $ this -> getRealId ( $ id ) ; $ resource = $ this -> repository -> getChilds ( $ id , $ relation , $ filters ) ; if ( ! $ resource || count ( $ resource ) < 1 ) { } return $ this -> success ( $ resource ) ; }
12156	public function getOwner ( ) { if ( ! $ this -> isOwnable ) { return ; } $ ownerObject = $ this -> getOwnerObject ( ) ; if ( is_object ( $ ownerObject ) ) { return $ ownerObject -> primaryKey ; } return $ ownerObject ; }
10531	public function count ( ) { if ( is_array ( $ this -> items ) && $ this -> items !== null ) { return count ( $ this -> items ) ; } return 0 ; }
12068	public function fetchProject ( Project $ project ) { $ response = $ this -> getResponse ( 'get' , sprintf ( 'v2/projects/%s' , $ project -> getProjectKey ( ) ) ) ; return $ this -> hydrator -> hydrate ( $ project , $ response ) ; }
11795	public function setAttachment ( $ file = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } if ( is_array ( $ file ) ) { foreach ( $ file as $ _f ) { if ( file_exists ( $ _f ) ) { $ this -> attachment [ ] = $ _f ; } } } else { if ( file_exists ( $ file ) ) { $ this -> attachment [ ] = $ file ; } } return $ this ; }
9676	public function allFonts ( Spreadsheet $ spreadsheet ) { $ aFonts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] ) ) { $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] = $ style -> getFont ( ) ; } } return $ aFonts ; }
2586	protected function loadBare ( PnrAddMultiElementsOptions $ params ) { $ tattooCounter = 0 ; if ( ! is_null ( $ params -> actionCode ) ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; } if ( ! is_null ( $ params -> recordLocator ) ) { $ this -> reservationInfo = new AddMultiElements \ ReservationInfo ( $ params -> recordLocator ) ; } if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; if ( ! empty ( $ params -> elements ) ) { $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; } else { $ this -> addReceivedFrom ( $ params -> receivedFrom , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ tattooCounter ) ; } }
237	protected function setTableMetadata ( $ name , $ type , $ data ) { $ this -> _tableMetadata [ $ this -> getRawTableName ( $ name ) ] [ $ type ] = $ data ; }
11517	protected function GenerateIOSPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ IOSPinicon ) { $ metadata .= $ this -> owner -> MarkupComment ( 'iOS Pinned Icon' ) ; if ( $ config -> fetchPiniconTitle ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'apple-mobile-web-app-title' , $ config -> fetchPiniconTitle ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 57 , 57 ) -> getAbsoluteURL ( ) , 'image/png' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 60 , 60 ) -> getAbsoluteURL ( ) , 'image/png' , '60x60' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'image/png' , '72x72' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 76 , 76 ) -> getAbsoluteURL ( ) , 'image/png' , '76x76' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 114 , 114 ) -> getAbsoluteURL ( ) , 'image/png' , '114x114' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 120 , 120 ) -> getAbsoluteURL ( ) , 'image/png' , '120x120' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'image/png' , '144x144' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 152 , 152 ) -> getAbsoluteURL ( ) , 'image/png' , '152x152' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 180 , 180 ) -> getAbsoluteURL ( ) , 'image/png' , '180x180' ) ; }
6339	private function getDocumentStream ( $ xmlDocument ) { foreach ( $ this -> streamAdapters as $ streamAdapter ) { if ( $ streamAdapter -> supports ( $ xmlDocument ) ) { return $ streamAdapter -> convert ( $ xmlDocument ) ; } } throw new RuntimeException ( sprintf ( 'Suitable XML document stream adapter is not registered for XML document of type "%s".' , is_object ( $ xmlDocument ) ? get_class ( $ xmlDocument ) : gettype ( $ xmlDocument ) ) ) ; }
3229	public static function q ( $ string ) { $ special_escape_out = self :: SPECIAL_ESCAPE_OUT ; $ r = "\"" ; $ len = \ strlen ( $ string ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ c = $ string [ $ i ] ; $ escape_i = \ strpos ( self :: SPECIAL_ESCAPE_IN , $ c ) ; if ( $ escape_i !== false ) { $ r .= "\\" ; $ r .= $ special_escape_out [ $ escape_i ] ; } else if ( $ c >= "\x20" and $ c <= "\x7e" ) { $ r .= $ c ; } else { $ r .= "\\x" ; $ r .= \ bin2hex ( $ c ) ; } } $ r .= "\"" ; return $ r ; }
4657	public function run ( Job $ job , $ command ) { if ( is_string ( $ command ) ) { $ command = [ '/bin/bash' , '-c' , $ command ] ; } $ image = $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; $ hostConfig = new HostConfig ( ) ; $ config = new ContainerConfig ( ) ; $ config -> setCmd ( $ command ) ; $ config -> setImage ( $ image -> getId ( ) ) ; $ config -> setHostConfig ( $ hostConfig ) ; $ config -> setLabels ( new \ ArrayObject ( [ 'com.jolici.container=true' ] ) ) ; $ config -> setAttachStderr ( true ) ; $ config -> setAttachStdout ( true ) ; $ links = [ ] ; foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { $ serviceContainer = $ this -> docker -> getContainerManager ( ) -> find ( $ service -> getContainer ( ) ) ; $ links [ ] = sprintf ( '%s:%s' , $ serviceContainer -> getName ( ) , $ service -> getName ( ) ) ; } } $ hostConfig -> setLinks ( $ links ) ; $ containerCreateResult = $ this -> docker -> getContainerManager ( ) -> create ( $ config ) ; $ attachStream = $ this -> docker -> getContainerManager ( ) -> attach ( $ containerCreateResult -> getId ( ) , [ 'stream' => true , 'stdout' => true , 'stderr' => true , ] , ContainerManager :: FETCH_STREAM ) ; $ attachStream -> onStdout ( $ this -> logger -> getRunStdoutCallback ( ) ) ; $ attachStream -> onStderr ( $ this -> logger -> getRunStderrCallback ( ) ) ; $ this -> docker -> getContainerManager ( ) -> start ( $ containerCreateResult -> getId ( ) ) ; $ attachStream -> wait ( ) ; $ containerWait = $ this -> docker -> getContainerManager ( ) -> wait ( $ containerCreateResult -> getId ( ) ) ; return $ containerWait -> getStatusCode ( ) ; }
9060	public function setPrimaryKey ( string ... $ key ) : self { $ this -> primaryKey = new PrimaryKey ( $ this , ... $ key ) ; return $ this ; }
9444	public function getName ( ) { static $ names = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ names [ $ me ] ) ) { $ names [ $ me ] = $ this -> getReflector ( ) -> getShortName ( ) ; $ suffix = defined ( 'static::PACK_SUFFIX' ) ? static :: PACK_SUFFIX : 'Pack' ; if ( strrpos ( $ names [ $ me ] , $ suffix ) == ( strlen ( $ names [ $ me ] ) - strlen ( $ suffix ) ) ) { $ names [ $ me ] = substr ( $ names [ $ me ] , 0 , strlen ( $ names [ $ me ] ) - strlen ( $ suffix ) ) ; } } return $ names [ $ me ] ; }
6749	public function transformCollection ( $ collection ) { if ( is_object ( $ collection ) ) $ collection = $ collection -> toArray ( ) [ "data" ] ; return array_map ( [ $ this , "transform" ] , $ collection ) ; }
7790	public function setOpeningBalanceClass ( $ openingBalanceClass ) { if ( ! is_callable ( $ openingBalanceClass ) && ! class_exists ( $ openingBalanceClass ) ) { throw new \ InvalidArgumentException ( '$openingBalanceClass must be a valid classname or a PHP callable' ) ; } $ this -> openingBalanceClass = $ openingBalanceClass ; return $ this ; }
9085	public function getAlias ( string $ abstract ) : string { if ( ! isset ( $ this -> aliases [ $ abstract ] ) ) { return $ abstract ; } if ( $ this -> aliases [ $ abstract ] === $ abstract ) { throw new ContainerException ( "[{$abstract}] is aliased to itself." ) ; } return $ this -> getAlias ( $ this -> aliases [ $ abstract ] ) ; }
1121	public function ancestorsAndSelf ( ) { return $ this -> newNestedSetQuery ( ) -> where ( $ this -> getLeftColumnName ( ) , '<=' , $ this -> getLeft ( ) ) -> where ( $ this -> getRightColumnName ( ) , '>=' , $ this -> getRight ( ) ) ; }
9996	protected function checkSeparator ( ) { $ line = fgets ( $ this -> fileHandle ) ; if ( $ line === false ) { return ; } if ( ( strlen ( trim ( $ line , "\r\n" ) ) == 5 ) && ( stripos ( $ line , 'sep=' ) === 0 ) ) { $ this -> delimiter = substr ( $ line , 4 , 1 ) ; return ; } return $ this -> skipBOM ( ) ; }
11315	public static function getNormalizedParameters ( array $ data ) { $ params = array ( ) ; $ keys = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_keys ( $ data ) ) ; $ values = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_values ( $ data ) ) ; $ data = array_combine ( $ keys , $ values ) ; uksort ( $ data , 'strnatcmp' ) ; foreach ( $ data as $ k => $ v ) { if ( $ k != 'oauth_signature' ) { $ params [ ] = $ k . '=' . $ v ; } } return implode ( '&' , $ params ) ; }
5255	public function makePagination ( QueryBuilder $ query = null ) { if ( is_null ( $ this -> _position ) ) { throw new Exception ( 'To use Paginationable trait you must fill _position property in your model' ) ; } $ model = static :: createInstance ( ) ; $ query = $ query ? : new QueryBuilder ( ) ; $ prevDoc = null ; $ nextDoc = null ; $ query -> fields ( ) ; $ prevPos = $ this -> _position - 1 ; if ( $ prevPos >= 0 ) { $ items = $ model -> search ( $ query -> from ( $ prevPos ) -> size ( 3 ) ) ; $ prevDoc = $ items -> first ( ) ; $ items = array_values ( $ items -> toArray ( ) ) ; if ( array_key_exists ( 2 , $ items ) ) { $ nextDoc = $ items [ 2 ] ; } } else { $ items = $ model -> search ( $ query -> from ( $ this -> _position ) -> size ( 2 ) ) ; $ total = $ items -> getTotal ( ) ; $ nextDoc = $ items -> last ( ) ; $ last = $ total - 1 ; $ items = $ model -> search ( $ query -> from ( $ last ) -> size ( 1 ) ) ; $ prevDoc = $ items -> first ( ) ; } if ( ! $ nextDoc ) { $ items = $ model -> search ( $ query -> from ( 0 ) -> size ( 1 ) ) ; $ nextDoc = $ items -> first ( ) ; } $ this -> _previous = $ prevDoc ; $ this -> _next = $ nextDoc ; }
7776	protected function getRuleArgs ( $ rule ) { if ( ! $ this -> ruleHasArgs ( $ rule ) ) { return [ ] ; } list ( $ ruleName , $ argsWithBracketAtTheEnd ) = explode ( '(' , $ rule ) ; $ args = rtrim ( $ argsWithBracketAtTheEnd , ')' ) ; $ args = preg_replace ( '/\s+/' , '' , $ args ) ; $ args = explode ( ',' , $ args ) ; return $ args ; }
7432	public function guess ( string $ path ) : string { if ( ! is_file ( $ path ) ) { throw new FileNotFoundException ( $ path ) ; } if ( ! is_readable ( $ path ) ) { throw new AccessDeniedException ( $ path ) ; } if ( 0 == count ( $ this -> guesserList ) ) { $ msg = 'Unable to guess the mime type as no guessers are available' ; if ( ! FileInfoMimeType :: isSupported ( ) ) { $ msg .= ' (Did you enable the php_fileinfo extension?)' ; } throw new \ LogicException ( $ msg ) ; } foreach ( $ this -> guesserList as $ guesser ) { if ( '' != $ mimeType = $ guesser -> guess ( $ path ) ) { return $ mimeType ; } } return '' ; }
11567	public function set ( string $ sNameOfDi , callable $ cFunction , bool $ bShared = false ) : Di { if ( $ bShared === true ) { self :: $ _aSharedDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } else { $ this -> _aDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } return $ this ; }
12208	public function getSingleWidget ( ) { if ( is_null ( $ this -> _singleWidget ) ) { $ this -> _singleWidget = false ; $ widgets = $ this -> collectorItem -> getAll ( ) ; if ( ! empty ( $ widgets ) ) { $ widget = array_shift ( $ widgets ) ; $ this -> _singleWidget = Yii :: $ app -> collectors [ 'widgets' ] -> build ( $ this , $ widget -> object ) ; } } return $ this -> _singleWidget ; }
3730	protected function getMatchingIds ( $ objFilter ) { if ( $ objFilter ) { $ arrFilteredIds = $ objFilter -> getMatchingIds ( ) ; if ( $ arrFilteredIds !== null ) { return $ arrFilteredIds ; } } return $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'id' ) -> from ( $ this -> getTableName ( ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; }
11744	public function register ( $ name , $ tel , $ email , $ industryId , array $ certUrls , $ reason = '' ) { $ params = [ 'name' => $ name , 'phone_number' => strval ( $ tel ) , 'email' => $ email , 'industry_id' => $ industryId , 'qualification_cert_urls' => $ certUrls , ] ; if ( $ reason !== '' ) { $ params [ 'apply_reason' ] = $ reason ; } return $ this -> parseJSON ( 'json' , [ self :: API_ACCOUNT_REGISTER , $ params ] ) ; }
2483	protected function getSearchTargets ( $ languageSettings ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = array ( ) ; $ endpoints = $ this -> endpointResolver -> getSearchTargets ( $ languageSettings ) ; if ( ! empty ( $ endpoints ) ) { foreach ( $ endpoints as $ endpoint ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpoint ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
7981	public function getSessionFilesProperties ( $ sessId , $ fileId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionFilesProperties ( $ this -> pp , $ this -> sn , $ sessId , $ fileId ) ) ; }
366	public function renderTableFooter ( ) { $ cells = [ ] ; foreach ( $ this -> columns as $ column ) { $ cells [ ] = $ column -> renderFooterCell ( ) ; } $ content = Html :: tag ( 'tr' , implode ( '' , $ cells ) , $ this -> footerRowOptions ) ; if ( $ this -> filterPosition === self :: FILTER_POS_FOOTER ) { $ content .= $ this -> renderFilters ( ) ; } return "<tfoot>\n" . $ content . "\n</tfoot>" ; }
12618	public function setFileSource ( $ value ) { if ( isset ( $ this -> module -> sourceFiles [ $ value ] ) ) { $ this -> _fileSource = $ this -> module -> sourceFiles [ $ value ] ; } else { $ this -> _fileSource = false ; } }
5324	public function dispatch ( ) { pcntl_signal_dispatch ( ) ; foreach ( $ this -> signalQueue as $ signal ) { foreach ( $ this -> handlers [ $ signal ] as & $ callable ) { call_user_func ( $ callable , $ signal ) ; } } return $ this ; }
10153	private function readVcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isVerticalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setVerticalCentered ( $ isVerticalCentered ) ; } }
10560	public function init ( array $ config = [ ] ) { foreach ( $ config as $ key => $ value ) { switch ( $ key ) { case 'default_controller' : $ this -> defaultController = $ value ; break ; case 'default_action' : $ this -> defaultAction = $ value ; break ; case 'namespaces' : $ this -> namespaces = $ value ; break ; default : break ; } } }
883	private function isUseForLambda ( Tokens $ tokens , $ index ) { $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; return $ nextToken -> equals ( '(' ) ; }
12269	protected function generateEventNames ( $ baseEventName , Page $ page ) { $ pageName = $ page -> getPageName ( ) ; $ language = $ page -> getCurrentLanguage ( ) ; return array ( $ baseEventName , $ baseEventName . '.' . $ language , $ baseEventName . '.' . $ pageName , $ baseEventName . '.' . $ language . '.' . $ pageName , ) ; }
6712	protected function stringToArray ( $ string ) { if ( ! $ string || ! is_string ( $ string ) ) { return [ ] ; } $ result = $ this -> getReaderFactory ( ) -> read ( $ string ) ; if ( $ result ) { return $ result ; } $ array = [ ] ; $ array [ 'text' ] = $ string ; return $ array ; }
10999	public function matchLocale ( $ locale ) { $ locale = Locale :: create ( $ locale ) ; if ( ! empty ( $ this -> redirect ) ) return false ; if ( $ locale === null ) return true ; foreach ( $ this -> locales as $ l ) if ( $ l -> getLocale ( ) == $ locale -> getLocale ( ) ) return true ; return false ; }
34	protected function jobToText ( $ job ) { $ packageName = $ job [ 'packageName' ] ; $ constraint = $ job [ 'constraint' ] ; switch ( $ job [ 'cmd' ] ) { case 'install' : $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; if ( ! $ packages ) { return 'No package found to satisfy install request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) ; } return 'Installation request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . ' -> satisfiable by ' . $ this -> getPackageList ( $ packages ) . '.' ; case 'update' : return 'Update request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '.' ; case 'remove' : return 'Removal request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '' ; } if ( isset ( $ constraint ) ) { $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; } else { $ packages = array ( ) ; } return 'Job(cmd=' . $ job [ 'cmd' ] . ', target=' . $ packageName . ', packages=[' . $ this -> getPackageList ( $ packages ) . '])' ; }
3451	protected function recordThat ( AggregateChanged $ event ) : void { $ this -> version += 1 ; $ this -> recordedEvents [ ] = $ event -> withVersion ( $ this -> version ) ; $ this -> apply ( $ event ) ; }
11214	public function count ( $ coraDbQuery = false ) { if ( ! $ coraDbQuery ) { $ coraDbQuery = $ this -> gateway -> getDb ( ) ; } $ coraDbQuery = $ this -> model :: model_constraints ( $ coraDbQuery ) ; return $ this -> gateway -> count ( $ coraDbQuery ) ; }
131	protected function updateLocalRepo ( ) { $ fs = new Filesystem ( ) ; $ fs -> ensureDirectoryExists ( $ this -> checkoutDir ) ; if ( ! is_writable ( dirname ( $ this -> checkoutDir ) ) ) { throw new \ RuntimeException ( 'Can not clone ' . $ this -> url . ' to access package information. The "' . $ this -> checkoutDir . '" directory is not writable by the current user.' ) ; } if ( is_file ( $ this -> repoFile ) && is_dir ( $ this -> checkoutDir ) && 0 === $ this -> process -> execute ( 'fossil info' , $ output , $ this -> checkoutDir ) ) { if ( 0 !== $ this -> process -> execute ( 'fossil pull' , $ output , $ this -> checkoutDir ) ) { $ this -> io -> writeError ( '<error>Failed to update ' . $ this -> url . ', package information from this repository may be outdated (' . $ this -> process -> getErrorOutput ( ) . ')</error>' ) ; } } else { $ fs -> removeDirectory ( $ this -> checkoutDir ) ; $ fs -> remove ( $ this -> repoFile ) ; $ fs -> ensureDirectoryExists ( $ this -> checkoutDir ) ; if ( 0 !== $ this -> process -> execute ( sprintf ( 'fossil clone %s %s' , ProcessExecutor :: escape ( $ this -> url ) , ProcessExecutor :: escape ( $ this -> repoFile ) ) , $ output ) ) { $ output = $ this -> process -> getErrorOutput ( ) ; throw new \ RuntimeException ( 'Failed to clone ' . $ this -> url . ' to repository ' . $ this -> repoFile . "\n\n" . $ output ) ; } if ( 0 !== $ this -> process -> execute ( sprintf ( 'fossil open %s --nested' , ProcessExecutor :: escape ( $ this -> repoFile ) ) , $ output , $ this -> checkoutDir ) ) { $ output = $ this -> process -> getErrorOutput ( ) ; throw new \ RuntimeException ( 'Failed to open repository ' . $ this -> repoFile . ' in ' . $ this -> checkoutDir . "\n\n" . $ output ) ; } } }
7926	public function fireEvent ( $ event , array $ args = [ ] ) { if ( isset ( $ this -> eventListeners [ $ event ] ) === false ) return $ args ; foreach ( $ this -> eventListeners [ $ event ] as $ listener ) call_user_func_array ( $ listener , $ args ) ; return $ args ; }
8612	public function setMarketplace ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Marketplace' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8201	protected function exportJob ( $ job ) { $ stats = $ this -> getJobStats ( $ job ) ; $ contents = $ this -> renderForExport ( $ job , $ stats ) ; $ filename = trim ( $ this -> path , '/' ) . '/' . $ this -> buildJobFileName ( $ job , $ stats ) ; if ( file_exists ( $ filename ) ) { throw new \ RuntimeException ( 'File already exists.' ) ; } if ( ! file_put_contents ( $ filename , $ contents ) ) { throw new \ RuntimeException ( 'Error saving the file.' ) ; } }
11751	public function stats ( ) { if ( is_null ( $ this -> stats ) ) { $ this -> stats = new Stats ( $ this -> accessToken ) ; } return $ this -> stats ; }
2158	public function run292Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `startTime` `startTime` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `endTime` `endTime` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `startDate` `startDate` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `endDate` `endDate` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "UPDATE tl_calendar_events SET endDate=null WHERE endDate=0" ) ; }
9589	public function dropDownListDefault ( $ items , $ options = [ ] ) { Html :: addCssClass ( $ options , 'browser-default' ) ; return parent :: dropDownList ( $ items , $ options ) ; }
3319	public function isa ( $ type , $ option = null ) { if ( $ type === 'bool' ) { $ type = 'boolean' ; } $ this -> isa = $ type ; $ this -> isaOption = $ option ; return $ this ; }
1851	public function generate ( $ rootPageId , $ blnReturn = false , $ blnPreferAlias = false ) { if ( ! $ blnReturn ) { $ this -> redirect ( $ this -> getRedirectUrl ( $ rootPageId ) , 302 ) ; } $ objNextPage = $ this -> getNextPage ( $ rootPageId ) ; return ( $ blnPreferAlias && $ objNextPage -> alias != '' ) ? $ objNextPage -> alias : $ objNextPage -> id ; }
6726	public function get_movie_votes ( $ post_id ) { $ votes = get_post_meta ( $ post_id , 'imdbTotalVotes' , true ) ; if ( ! empty ( $ votes ) ) { return json_decode ( $ votes , true ) ; } return false ; }
2715	public function render ( ) { return [ 'id' => $ this -> getId ( ) , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => 1 , 'label' => $ this -> label , 'comment' => $ this -> comment , '_elementType' => 'group' , 'path' => self :: BASE_CONFIG_PATH , 'children' => $ this -> children ] ; }
1687	public function loginAction ( ) : Response { $ this -> get ( 'contao.framework' ) -> initialize ( ) ; if ( ! isset ( $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ) || ! class_exists ( $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ) ) { throw new UnauthorizedHttpException ( '' , 'Not authorized' ) ; } $ pageHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ( ) ; try { return $ pageHandler -> getResponse ( ) ; } catch ( ResponseException $ e ) { return $ e -> getResponse ( ) ; } catch ( InsufficientAuthenticationException $ e ) { throw new UnauthorizedHttpException ( '' , $ e -> getMessage ( ) ) ; } }
11089	public static function isCzechHoliday ( $ date ) { if ( ! $ date instanceof DateTime ) { if ( \ is_int ( $ date ) ) { $ date = new DateTime ( '@' . $ date ) ; } elseif ( \ is_string ( $ date ) ) { $ date = new DateTime ( $ date ) ; } else { throw new RuntimeException ( self :: poorManTranslate ( 'fts-shared' , 'Invalid date format' ) ) ; } } $ holidays = [ '01-01' , '05-01' , '05-08' , '07-05' , '07-06' , '09-28' , '10-28' , '11-17' , '12-24' , '12-25' , '12-26' ] ; if ( \ in_array ( $ date -> format ( 'm-d' ) , $ holidays , true ) ) { return true ; } $ easterDays = easter_days ( $ date -> format ( 'Y' ) ) ; $ easter = new DateTime ( $ date -> format ( 'Y' ) . '-03-21' ) ; $ easter -> add ( new \ DateInterval ( 'P' . $ easterDays . 'D' ) ) ; $ easter -> sub ( new \ DateInterval ( 'P2D' ) ) ; if ( $ date -> format ( 'Y-m-d' ) === $ easter -> format ( 'Y-m-d' ) ) { return true ; } $ easter -> add ( new \ DateInterval ( 'P3D' ) ) ; return ( $ easter -> format ( 'Y-m-d' ) === $ date -> format ( 'Y-m-d' ) ) ; }
312	public function run ( ) { try { $ this -> state = self :: STATE_BEFORE_REQUEST ; $ this -> trigger ( self :: EVENT_BEFORE_REQUEST ) ; $ this -> state = self :: STATE_HANDLING_REQUEST ; $ response = $ this -> handleRequest ( $ this -> getRequest ( ) ) ; $ this -> state = self :: STATE_AFTER_REQUEST ; $ this -> trigger ( self :: EVENT_AFTER_REQUEST ) ; $ this -> state = self :: STATE_SENDING_RESPONSE ; $ response -> send ( ) ; $ this -> state = self :: STATE_END ; return $ response -> exitStatus ; } catch ( ExitException $ e ) { $ this -> end ( $ e -> statusCode , isset ( $ response ) ? $ response : null ) ; return $ e -> statusCode ; } }
10921	public function setHeaders ( array $ headers ) { $ columnNumber = 0 ; foreach ( $ headers as $ header ) { $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ header ) ) ; if ( ! in_array ( $ header , $ this -> headers ) ) { $ this -> headers [ ] = $ header ; } $ columnNumber ++ ; } }
10432	protected function createServices ( ContainerBuilder $ container , $ classes , $ config , $ tag , $ method ) { if ( ! is_array ( $ tag ) ) { $ tag = [ $ tag ] ; } foreach ( $ classes as $ class ) { $ methods = $ this -> getMethods ( $ class ) ; $ definition = new Definition ( $ class ) ; $ this -> setProperties ( $ definition , $ config , $ methods ) ; $ this -> setTags ( $ definition , $ tag , $ method ) ; $ container -> setDefinition ( $ this -> getServiceName ( $ tag [ 0 ] ) , $ definition ) ; } }
10396	public function loadClassMetadata ( LoadClassMetadataEventArgs $ eventArgs ) { if ( empty ( $ this -> replacements ) ) { return ; } $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ tableName = $ metadata -> getTableName ( ) ; if ( $ tableName ) { $ metadata -> setPrimaryTable ( [ 'name' => $ this -> doReplacement ( $ tableName ) , ] ) ; } foreach ( $ metadata -> getFieldNames ( ) as $ fieldName ) { $ mapping = $ metadata -> getFieldMapping ( $ fieldName ) ; foreach ( $ mapping as $ key => $ value ) { if ( is_string ( $ value ) ) { $ mapping [ $ key ] = $ this -> doReplacement ( $ value ) ; } } $ metadata -> setAttributeOverride ( $ fieldName , $ mapping ) ; } $ associationMappings = $ metadata -> getAssociationMappings ( ) ; foreach ( $ metadata -> getAssociationNames ( ) as $ fieldName ) { if ( isset ( $ associationMappings [ $ fieldName ] ) ) { $ associationMapping = $ associationMappings [ $ fieldName ] ; if ( isset ( $ associationMapping [ 'joinColumns' ] ) ) { foreach ( $ associationMapping [ 'joinColumns' ] as $ key => $ joinColumn ) { $ associationMapping [ 'joinColumns' ] [ $ key ] [ 'name' ] = $ this -> doReplacement ( $ joinColumn [ 'name' ] ) ; $ associationMapping [ 'joinColumns' ] [ $ key ] [ 'referencedColumnName' ] = $ this -> doReplacement ( $ joinColumn [ 'referencedColumnName' ] ) ; } $ metadata -> setAssociationOverride ( $ fieldName , $ associationMapping ) ; } } } if ( count ( $ metadata -> discriminatorMap ) ) { $ this -> processDiscriminatorMap ( $ metadata ) ; } }
546	protected function getCreateTableSql ( $ table ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> quoteTableName ( $ table -> fullName ) ) -> queryOne ( ) ; if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } return $ sql ; }
11611	public function move ( $ path , $ filename = null ) { $ newFilename = ( $ filename != null ) ? $ filename : $ this -> filename ; $ lastSlash = substr ( $ path , strlen ( $ path ) , 1 ) ; if ( $ lastSlash !== '/' ) { $ path .= '/' ; } $ result = move_uploaded_file ( $ this -> realPath , $ path . $ newFilename ) ; return $ result ; }
5903	public function retrieveCurrentUser ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/me' , $ parameters , $ cachePolicy ) ; $ result = new User ( $ result ) ; return $ result ; }
1629	public function getMonolog ( ) { foreach ( $ this -> loggers as $ logger ) { if ( is_callable ( [ $ logger , 'getMonolog' ] ) ) { $ monolog = $ logger -> getMonolog ( ) ; if ( $ monolog === null ) { continue ; } return $ monolog ; } } }
9214	public function actionCreate ( ) { $ model = new StaticPage ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> isdel = 0 ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { $ post [ 'StaticPage' ] [ 'tags' ] = implode ( "," , $ post [ 'StaticPage' ] [ 'tags' ] ) ; } } if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; } }
7387	public static final function generateThumbnailsFrom ( $ files , array $ size ) { foreach ( $ files as $ file ) { self :: generateThumbnail ( $ file -> getRecord ( ) , $ size ) ; } }
9783	public function parseExpression ( ) { $ token = $ this -> peek ( ) ; $ type = $ token [ 0 ] ; switch ( $ type ) { case 'IF_OPEN' : return $ this -> parseIf ( ) ; case 'FOR_OPEN' : return $ this -> parseFor ( ) ; case 'FILTERED_VALUE' : return $ this -> parseFilteredValue ( ) ; case 'VALUE' : return $ this -> parseValue ( ) ; case 'HTML' : return $ this -> parseHTML ( ) ; case 'ESCAPE' : return $ this -> parseEscape ( ) ; case 'INCLUDE' : return $ this -> parseInclude ( ) ; default : throw new SyntaxErrorException ( "Could not parse expression, invalid token '$type'" ) ; } }
1734	public function validateCode ( User $ user , string $ code ) : bool { $ totp = TOTP :: create ( $ this -> getUpperUnpaddedSecretForUser ( $ user ) ) ; return $ totp -> verify ( $ code ) ; }
1413	public function resourceDoesNotExist ( string $ path ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_NOT_FOUND , $ this -> trans ( 'resource_not_found' , 'code' ) , $ this -> trans ( 'resource_not_found' , 'title' ) , $ this -> trans ( 'resource_not_found' , 'detail' ) , $ this -> pointer ( $ path ) ) ; }
2961	public function readPort ( $ count = 0 ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { trigger_error ( "Device must be opened to read it" , E_USER_WARNING ) ; return false ; } if ( $ this -> _os === "linux" || $ this -> _os === "osx" ) { $ content = "" ; $ i = 0 ; if ( $ count !== 0 ) { do { if ( $ i > $ count ) { $ content .= fread ( $ this -> _dHandle , ( $ count - $ i ) ) ; } else { $ content .= fread ( $ this -> _dHandle , 128 ) ; } } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } else { do { $ content .= fread ( $ this -> _dHandle , 128 ) ; } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } return $ content ; } elseif ( $ this -> _os === "windows" ) { $ content = "" ; $ i = 0 ; if ( $ count !== 0 ) { do { if ( $ i > $ count ) { $ content .= fread ( $ this -> _dHandle , ( $ count - $ i ) ) ; } else { $ content .= fread ( $ this -> _dHandle , 128 ) ; } } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } else { do { $ content .= fread ( $ this -> _dHandle , 128 ) ; } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } return $ content ; } return false ; }
6544	public function currentShardingKey ( ) { return isset ( $ this -> options [ SelectorSourceInterface :: SHARDING_KEY ] ) ? $ this -> options [ SelectorSourceInterface :: SHARDING_KEY ] : null ; }
4102	public function request ( $ path , $ method = 'GET' , $ payload = false , $ verbose = false ) { $ response = $ this -> transport -> request ( $ this -> expandPath ( $ path ) , $ method , $ payload ) ; return ( $ verbose || ! isset ( $ response [ '_source' ] ) ) ? $ response : $ response [ '_source' ] ; }
2621	public function sendValidationRequest ( $ validatedFlag , $ serviceId = null ) { if ( $ serviceId != null ) { $ this -> validationServiceId = $ serviceId ; } if ( $ validatedFlag ) { $ validationState = self :: FASTLY_VALIDATED_FLAG ; } else { $ validationState = self :: FASTLY_NON_VALIDATED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ validationState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ validationState , 'dt' => ucfirst ( $ validationState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ validationState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
3614	public function setTargetTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
11923	public function getPerUnitAmount ( ) { $ amount = $ this -> getProduct ( ) -> getPrice ( ) ; foreach ( $ this -> getOptions ( ) as $ cartOption ) { $ amount = bcadd ( $ amount , $ cartOption -> getOption ( ) -> getPrice ( ) , 2 ) ; } foreach ( $ this -> getExtras ( ) as $ cartExtra ) { $ amount = bcadd ( $ amount , $ cartExtra -> getExtra ( ) -> getPrice ( ) , 2 ) ; } return floatval ( $ amount ) ; }
4975	private function findOrCreateChild ( $ tree , $ id ) { foreach ( $ tree -> getChildren ( ) as $ node ) { if ( $ id && $ node -> getId ( ) == $ id ) { return $ node ; } } $ nodeClass = get_class ( $ tree ) ; $ node = new $ nodeClass ( ) ; $ tree -> addChild ( $ node ) ; return $ node ; }
2719	private function isHostInDomainList ( $ host ) { $ urlTypes = [ UrlInterface :: URL_TYPE_LINK , UrlInterface :: URL_TYPE_DIRECT_LINK , UrlInterface :: URL_TYPE_WEB , UrlInterface :: URL_TYPE_MEDIA , UrlInterface :: URL_TYPE_STATIC ] ; $ secureScheme = [ true , false ] ; foreach ( $ this -> storeManager -> getStores ( ) as $ store ) { foreach ( $ urlTypes as $ urlType ) { foreach ( $ secureScheme as $ scheme ) { $ shopHost = \ Zend_Uri :: factory ( $ store -> getBaseUrl ( $ urlType , $ scheme ) ) -> getHost ( ) ; if ( $ host === $ shopHost ) { return true ; } } } } return false ; }
9922	private function defineManyToManyRelation ( Model $ model1 , Model $ model2 ) { $ this -> relations [ $ model1 -> getName ( ) ] [ ] = new Relation ( $ model1 , $ model2 , Relation :: HAS_AND_BELONGS_TO ) ; $ this -> relations [ $ model2 -> getName ( ) ] [ ] = new Relation ( $ model2 , $ model1 , Relation :: HAS_AND_BELONGS_TO ) ; }
1482	public function encoder ( $ options = 0 , $ depth = 512 ) { if ( $ options instanceof Encoding ) { $ options = $ options -> getOptions ( ) ; } if ( ! $ options instanceof EncoderOptions ) { $ options = new EncoderOptions ( $ options , $ this -> getUrl ( ) -> toString ( ) , $ depth ) ; } return $ this -> factory -> createEncoder ( $ this -> getContainer ( ) , $ options ) ; }
12565	public function sendImage ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_IMAGE , $ message , $ to ) ; }
12048	public function render ( ElementInterface $ element ) { $ renderer = $ this -> getView ( ) ; if ( $ element instanceof CkEditor ) { $ plugin = $ renderer -> plugin ( 'form_ckeditor' ) ; return $ plugin ( $ element ) ; } return parent :: render ( $ element ) ; }
5421	protected function parse ( $ raw ) { if ( ! $ raw ) { $ this -> setError ( 'Nothing fetched' ) ; $ this -> headers = new SimpleHttpHeaders ( '' ) ; } elseif ( 'file' === $ this -> url -> getScheme ( ) ) { $ this -> headers = new SimpleHttpHeaders ( '' ) ; $ this -> content = $ raw ; } elseif ( ! strstr ( $ raw , "\r\n\r\n" ) ) { $ this -> setError ( 'Could not split headers from content' ) ; $ this -> headers = new SimpleHttpHeaders ( $ raw ) ; } else { list ( $ headers , $ this -> content ) = explode ( "\r\n\r\n" , $ raw , 2 ) ; $ this -> headers = new SimpleHttpHeaders ( $ headers ) ; } }
1120	public function getRoot ( ) { if ( $ this -> exists ) { return $ this -> ancestorsAndSelf ( ) -> whereNull ( $ this -> getParentColumnName ( ) ) -> first ( ) ; } else { $ parentId = $ this -> getParentId ( ) ; if ( ! is_null ( $ parentId ) && $ currentParent = static :: find ( $ parentId ) ) { return $ currentParent -> getRoot ( ) ; } else { return $ this ; } } }
491	public function via ( $ relationName , callable $ callable = null ) { $ relation = $ this -> primaryModel -> getRelation ( $ relationName ) ; $ callableUsed = $ callable !== null ; $ this -> via = [ $ relationName , $ relation , $ callableUsed ] ; if ( $ callable !== null ) { call_user_func ( $ callable , $ relation ) ; } return $ this ; }
11946	protected function getCurrentUser ( ) { try { return JWTAuth :: parseToken ( ) -> authenticate ( ) ; } catch ( \ Tymon \ JWTAuth \ Exceptions \ JWTException $ ex ) { return null ; } }
49	protected function getScriptListeners ( Event $ event ) { $ package = $ this -> composer -> getPackage ( ) ; $ scripts = $ package -> getScripts ( ) ; if ( empty ( $ scripts [ $ event -> getName ( ) ] ) ) { return array ( ) ; } if ( $ this -> loader ) { $ this -> loader -> unregister ( ) ; } $ generator = $ this -> composer -> getAutoloadGenerator ( ) ; if ( $ event instanceof ScriptEvent ) { $ generator -> setDevMode ( $ event -> isDevMode ( ) ) ; } $ packages = $ this -> composer -> getRepositoryManager ( ) -> getLocalRepository ( ) -> getCanonicalPackages ( ) ; $ packageMap = $ generator -> buildPackageMap ( $ this -> composer -> getInstallationManager ( ) , $ package , $ packages ) ; $ map = $ generator -> parseAutoloads ( $ packageMap , $ package ) ; $ this -> loader = $ generator -> createLoader ( $ map ) ; $ this -> loader -> register ( ) ; return $ scripts [ $ event -> getName ( ) ] ; }
3725	private function buildPickerService ( ContainerBuilder $ container ) { $ pickerService = $ container -> getDefinition ( 'metamodels.controller.picker' ) ; $ configs = $ pickerService -> getArgument ( 2 ) ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'w50' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'w50x' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'clr' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'clx' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'long' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'wizard' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'm12' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'search' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'sort' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'filter' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'limit' ] ; $ pickerService -> setArgument ( 2 , $ configs ) ; }
11656	public function getShortName ( ) { preg_match ( '/Widget([A-Za-z]+)\\\Module/' , get_class ( $ this ) , $ matches ) ; if ( ! isset ( $ matches [ 1 ] ) ) { throw new Exception ( get_class ( $ this ) . " is not set up correctly!" ) ; } return $ matches [ 1 ] ; }
6315	public function setUpdateAction ( $ updateAction ) { $ updateAction = strtoupper ( $ updateAction ) ; if ( ! in_array ( $ updateAction , $ this -> getAvailableActions ( ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Action %s does not exist.' , $ updateAction ) ) ; } $ this -> updateAction = $ updateAction ; }
1218	public function setConfig ( array $ configuration ) { $ this -> config = Functions \ arrayMergeDeep ( $ this -> config , $ this -> resolver -> resolveOptions ( $ configuration ) ) ; }
11632	private function groupPvTrans ( $ transData ) { $ result = [ ] ; foreach ( $ transData as $ one ) { $ debitAccId = $ one -> get ( DTrans :: A_ACC_ID_DEBIT ) ; $ creditAccId = $ one -> get ( DTrans :: A_ACC_ID_CREDIT ) ; $ value = $ one -> get ( DTrans :: A_AMOUNT ) ; if ( isset ( $ result [ $ debitAccId ] ) ) { $ result [ $ debitAccId ] -= $ value ; } else { $ result [ $ debitAccId ] = - $ value ; } if ( isset ( $ result [ $ creditAccId ] ) ) { $ result [ $ creditAccId ] += $ value ; } else { $ result [ $ creditAccId ] = $ value ; } } return $ result ; }
10771	public function registerMediaType ( $ mediaType ) { if ( $ this -> check ( $ mediaType ) ) { $ this -> mediaTypes [ ( new \ ReflectionClass ( $ mediaType ) ) -> getConstant ( 'NAME' ) ] = $ mediaType ; return $ this ; } else { throw new \ Exception ( 'registered MediaType must implement \MandarinMedien\MMMediaBundle\Model\MediaTypeInterface' ) ; } }
9753	public static function sysGetTempDir ( ) { if ( self :: $ useUploadTempDirectory ) { if ( ini_get ( 'upload_tmp_dir' ) !== false ) { if ( $ temp = ini_get ( 'upload_tmp_dir' ) ) { if ( file_exists ( $ temp ) ) { return realpath ( $ temp ) ; } } } } return realpath ( sys_get_temp_dir ( ) ) ; }
3038	public function get ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { $ data = $ this -> getStorage ( ) -> get ( $ userId , $ callId ) ; $ state = is_null ( $ data ) ? self :: STATE_NOT_FOUND : self :: STATE_ALIGNED ; $ this -> putInCache ( $ key , $ userId , $ callId , $ data , $ state ) ; } return $ this -> getFromCache ( $ key ) ; }
7725	public function url ( $ text , $ title , $ url ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'title' => $ title , 'url' => $ url ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
6861	public function doDefaultValueConversionByType ( $ value , $ type , array $ record ) { switch ( $ type ) { case static :: TYPE_DATETIME : return date ( static :: FORMAT_DATETIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_DATE : return date ( static :: FORMAT_DATE , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_TIME : return date ( static :: FORMAT_TIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_MULTILINE : return '<pre class="multiline-text">' . $ value . '</pre>' ; case static :: TYPE_JSON : case static :: TYPE_JSONB : if ( ! is_array ( $ value ) && $ value !== null ) { if ( is_string ( $ value ) || is_numeric ( $ value ) || is_bool ( $ value ) ) { $ value = json_decode ( $ value , true ) ; if ( $ value === null && strtolower ( $ value ) !== 'null' ) { $ value = 'Failed to decode JSON: ' . print_r ( $ value , true ) ; } } else { $ value = 'Invalid value for JSON: ' . print_r ( $ value , true ) ; } } return '<pre class="json-text">' . htmlentities ( stripslashes ( json_encode ( $ value , JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE ) ) ) . '</pre>' ; break ; } return $ value ; }
12552	private function addHeaders ( ) { self :: response ( ) -> addHeader ( 'Cache-Control' , 'no-cache, no-store, must-revalidate' ) ; self :: response ( ) -> addHeader ( 'Pragma' , 'no-cache' ) ; self :: response ( ) -> addHeader ( 'Expires' , '-1' ) ; }
6658	public function jsonSerialize ( ) { $ serialized = [ 'message' => $ this -> getPublicMessage ( ) , 'code' => $ this -> getCode ( ) , ] ; if ( $ this -> getPrevious ( ) instanceof $ this ) { $ previous = $ this -> getPrevious ( ) ; $ serialized [ 'previous' ] = $ previous -> jsonSerialize ( ) ; } return $ serialized ; }
966	public function dispatchAfterAuthenticate ( ) { $ jobsConfig = Config :: get ( 'shopify-app.after_authenticate_job' ) ; $ fireJob = function ( $ config ) { $ job = $ config [ 'job' ] ; if ( isset ( $ config [ 'inline' ] ) && $ config [ 'inline' ] === true ) { $ job :: dispatchNow ( $ this -> shop ) ; } else { $ job :: dispatch ( $ this -> shop ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.after_authenticate' ) ) ; } return true ; } ; if ( isset ( $ jobsConfig [ 0 ] ) ) { foreach ( $ jobsConfig as $ jobConfig ) { $ fireJob ( $ jobConfig ) ; } return true ; } if ( isset ( $ jobsConfig [ 'job' ] ) ) { return $ fireJob ( $ jobsConfig ) ; } return false ; }
5358	protected function createParameters ( Operation $ operation , $ queryParamDocumentation , Context $ context ) { $ documentationParams = [ ] ; $ methodParameters = [ ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof PathParameterSubSchema ) { $ methodParameters [ ] = $ this -> pathParameterGenerator -> generateMethodParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ; $ documentationParams [ ] = sprintf ( ' * @param %s' , $ this -> pathParameterGenerator -> generateDocParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ) ; } } foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof BodyParameter ) { $ methodParameters [ ] = $ this -> bodyParameterGenerator -> generateMethodParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ; $ documentationParams [ ] = sprintf ( ' * @param %s' , $ this -> bodyParameterGenerator -> generateDocParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ) ; } } } if ( ! empty ( $ queryParamDocumentation ) ) { $ documentationParams [ ] = " * @param array \$parameters {" ; $ documentationParams = array_merge ( $ documentationParams , array_map ( function ( $ doc ) { return " * " . $ doc ; } , $ queryParamDocumentation ) ) ; $ documentationParams [ ] = " * }" ; } else { $ documentationParams [ ] = " * @param array \$parameters List of parameters" ; } $ documentationParams [ ] = " * @param string \$fetch Fetch mode (object or response)" ; $ methodParameters [ ] = new Param ( 'parameters' , new Expr \ Array_ ( ) ) ; $ methodParameters [ ] = new Param ( 'fetch' , new Expr \ ConstFetch ( new Name ( 'self::FETCH_OBJECT' ) ) ) ; return [ $ documentationParams , $ methodParameters ] ; }
5791	public function isDeletable ( ) : bool { if ( in_array ( $ this -> title , self :: UNDELETABLE ) ) { return false ; } return ( PermissionsTableMapper :: getInstance ( ) ) -> isDeletable ( ) ; }
9531	private function respondDefault ( & $ i , & $ results , $ parameter ) { $ defaultResult = $ this -> parameterCluster -> default -> call ( $ this , $ parameter ) ; if ( $ defaultResult === - 1 ) { $ this -> valid = false ; } $ results [ $ parameter ] = $ defaultResult ; $ i ++ ; }
9236	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'Banner' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'Banner' ] [ 'tags' ] ) ) { $ post [ 'Banner' ] [ 'tags' ] = implode ( "," , $ post [ 'Banner' ] [ 'tags' ] ) ; } } $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { $ model -> updatePosition ( $ model -> position ) ; $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; }
11220	private static function cleanResources ( ) { self :: $ callbacks = [ ] ; self :: $ methods = [ ] ; self :: $ halts = false ; self :: $ response = false ; }
305	private function setRelationDependencies ( $ name , $ relation , $ viaRelationName = null ) { if ( empty ( $ relation -> via ) && $ relation -> link ) { foreach ( $ relation -> link as $ attribute ) { $ this -> _relationsDependencies [ $ attribute ] [ $ name ] = $ name ; if ( $ viaRelationName !== null ) { $ this -> _relationsDependencies [ $ attribute ] [ ] = $ viaRelationName ; } } } elseif ( $ relation -> via instanceof ActiveQueryInterface ) { $ this -> setRelationDependencies ( $ name , $ relation -> via ) ; } elseif ( is_array ( $ relation -> via ) ) { list ( $ viaRelationName , $ viaQuery ) = $ relation -> via ; $ this -> setRelationDependencies ( $ name , $ viaQuery , $ viaRelationName ) ; } }
11841	private function extractInput ( ) { $ params = $ this -> request -> getParams ( ) ; $ period = $ params [ self :: REQ_PERIOD ] ?? '' ; if ( empty ( $ period ) ) { $ period = $ this -> hlpPeriod -> getPeriodCurrent ( null , 0 , HPeriod :: TYPE_MONTH ) ; } else { $ period = $ this -> hlpPeriod -> normalizePeriod ( $ period , HPeriod :: TYPE_MONTH ) ; } $ dsBegin = $ this -> hlpPeriod -> getPeriodFirstDate ( $ period ) ; $ treeType = $ params [ self :: REQ_TREE_TYPE ] ?? '' ; if ( $ treeType != OptionTreeType :: VAL_PLAIN ) { $ treeType = OptionTreeType :: VAL_COMPRESS ; } return [ $ dsBegin , $ treeType ] ; }
2572	protected function loadSessionHandler ( $ params ) { if ( isset ( $ params [ 'sessionHandler' ] ) && $ params [ 'sessionHandler' ] instanceof Session \ Handler \ HandlerInterface ) { $ this -> sessionHandler = $ params [ 'sessionHandler' ] ; } }
9049	private function renderButtons ( $ rendered , $ buttons ) { foreach ( $ buttons as $ button ) { if ( ! isset ( $ button [ 'name' ] ) ) { throw new ControlException ( "Button must have at least a name!" ) ; } $ buttonType = isset ( $ button [ 'type' ] ) ? $ button [ 'type' ] : "submit" ; $ id = isset ( $ button [ 'id' ] ) ? $ button [ 'id' ] : $ button [ 'name' ] ; $ class = isset ( $ button [ 'class' ] ) ? $ button [ 'class' ] : $ button [ 'name' ] ; $ label = isset ( $ button [ 'label' ] ) ? $ button [ 'label' ] : $ button [ 'name' ] ; $ rendered .= sprintf ( '<button type="%s" id="%s" class="%s" name="%s">%s</button>' , $ buttonType , $ id , $ class , $ button [ 'name' ] , $ label ) ; } return $ rendered ; }
11614	public function update ( $ account , $ nickname ) { $ params = [ 'kf_account' => $ account , 'nickname' => $ nickname , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
10488	public function run ( \ de \ codenamephp \ platform \ cli \ command \ iCommand $ command ) { if ( $ this -> getDirectory ( ) !== '' && is_dir ( $ this -> getDirectory ( ) ) ) { $ currentDir = getcwd ( ) ; chdir ( $ this -> getDirectory ( ) ) ; } $ returnValue = $ this -> getActualPassthru ( ) -> run ( $ command ) ; if ( isset ( $ currentDir ) ) { chdir ( $ currentDir ) ; } return $ returnValue ; }
1257	public static function createRuntime ( ) { switch ( $ compileDir = getenv ( self :: COMPILE_DIR ) ) { case false : return new AstRuntime ( ) ; case 'on' : return new CompilerRuntime ( ) ; default : return new CompilerRuntime ( $ compileDir ) ; } }
3526	private function parseStatItem ( $ stat ) : array { $ result = [ ] ; $ pieces = explode ( "_" , $ stat -> name ) ; $ result [ $ pieces [ 2 ] ] [ $ pieces [ 4 ] ] [ $ pieces [ 1 ] ] = $ stat -> value ; return $ result ; }
539	protected function serializePagination ( $ pagination ) { return [ $ this -> linksEnvelope => Link :: serialize ( $ pagination -> getLinks ( true ) ) , $ this -> metaEnvelope => [ 'totalCount' => $ pagination -> totalCount , 'pageCount' => $ pagination -> getPageCount ( ) , 'currentPage' => $ pagination -> getPage ( ) + 1 , 'perPage' => $ pagination -> getPageSize ( ) , ] , ] ; }
3869	protected function getMetaModel ( $ identifier , $ ignoreError ) { $ factory = $ this -> getMetaModelsFactory ( ) ; if ( is_numeric ( $ identifier ) ) { $ identifier = $ factory -> translateIdToMetaModelName ( $ identifier ) ; } $ metaModels = $ factory -> getMetaModel ( $ identifier ) ; if ( ! $ ignoreError && $ metaModels == null ) { throw new \ RuntimeException ( 'Could not find the MetaModels with the name ' . $ identifier ) ; } return $ metaModels ; }
608	private function addTokenFromBuffer ( ) { if ( $ this -> _buffer === '' ) { return ; } $ isKeyword = $ this -> isKeyword ( $ this -> _buffer , $ content ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => $ isKeyword ? SqlToken :: TYPE_KEYWORD : SqlToken :: TYPE_TOKEN , 'content' => is_string ( $ content ) ? $ content : $ this -> _buffer , 'startOffset' => $ this -> offset - mb_strlen ( $ this -> _buffer , 'UTF-8' ) , 'endOffset' => $ this -> offset , ] ) ; $ this -> _buffer = '' ; }
6026	public function setMimetype ( $ mimetype ) { if ( $ mimetype instanceof MimeType ) { $ this -> mimetype = $ mimetype ; } elseif ( is_array ( $ mimetype ) ) { $ this -> mimetype = new MimeType ( $ mimetype ) ; } else { $ this -> mimetype = null ; trigger_error ( 'Argument must be an object of class MimeType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
12453	static function run_generate_sample_package_xml ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { pake_copy ( self :: getResourceDir ( ) . '/package_master.xml' , 'package.xml' ) ; $ tokens = array ( '$summary' => '[Summary]' , '$description' => '[Description]' , '$vendor' => '' , '$maintainers' => '' , '$documents' => '' , '$changelog' => '' , '$simple-files' => '' , '$state' => '[State]' , '$requires' => '' ) ; pake_replace_tokens ( 'package.xml' , '.' , '{' , '}' , $ tokens ) ; pake_echo ( "File package.xml generated. Please replace all tokens in square brackets in it (but do not replace values in curly brackets) then commit it to sources in the top dir of the extension" ) ; }
4606	public function createApp ( string $ client_name , string $ redirect_uris , string $ scopes , string $ website = '' ) : array { $ params = compact ( 'client_name' , 'redirect_uris' , 'scopes' , 'website' ) ; return $ this -> post ( '/apps' , $ params ) ; }
1980	public static function generateUnwrapped ( $ strScope = TL_MODE , $ blnRaw = false ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return '' ; } $ strMessages = '' ; $ flashBag = $ session -> getFlashBag ( ) ; foreach ( static :: getTypes ( ) as $ strType ) { $ strClass = strtolower ( $ strType ) ; $ arrMessages = $ flashBag -> get ( static :: getFlashBagKey ( $ strType , $ strScope ) ) ; foreach ( array_unique ( $ arrMessages ) as $ strMessage ) { if ( $ strType == 'TL_RAW' || $ blnRaw ) { $ strMessages .= $ strMessage ; } else { $ strMessages .= '<p class="' . $ strClass . '">' . $ strMessage . '</p>' ; } } } return trim ( $ strMessages ) ; }
8178	protected function sendMail ( $ to , $ subject , $ view , $ params = [ ] ) { $ mailer = Yii :: $ app -> mailer ; $ mailer -> viewPath = '@abhimanyu/user/views/mail' ; return $ mailer -> compose ( [ 'html' => $ view , 'text' => 'text/' . $ view ] , $ params ) -> setTo ( $ to ) -> setFrom ( Yii :: $ app -> config -> get ( 'mail.username' ) , 'no@reply.com' ) -> setSubject ( $ subject ) -> send ( ) ; }
152	public function batch ( $ batchSize = 100 , $ db = null ) { return Yii :: createObject ( [ 'class' => BatchQueryResult :: className ( ) , 'query' => $ this , 'batchSize' => $ batchSize , 'db' => $ db , 'each' => false , ] ) ; }
6518	public static function fromDateTime ( \ DateTimeInterface $ date ) { $ str = $ date -> format ( 'U' ) . str_pad ( $ date -> format ( 'u' ) , 6 , '0' ) ; $ m = new self ( ) ; $ m -> int = ( int ) $ str ; $ m -> sec = ( int ) substr ( $ str , 0 , 10 ) ; $ m -> usec = ( int ) substr ( $ str , - 6 ) ; return $ m ; }
10883	public function reportException ( \ Exception $ ex ) { $ report = new ErrorStreamReport ( ) ; $ report -> error_group = $ ex -> getMessage ( ) . ':' . $ ex -> getLine ( ) ; $ report -> line_number = $ ex -> getLine ( ) ; $ report -> file_name = $ ex -> getFile ( ) ; $ report -> message = $ ex -> getMessage ( ) ; $ report -> stack_trace = $ ex -> getTraceAsString ( ) ; $ report -> severity = 3 ; return $ this -> report ( $ report ) ; }
10482	public function getBucket ( string $ name ) : SessionBucketInterface { $ segment = $ this -> session -> getSegment ( $ name ) ; if ( ! $ segment ) { return null ; } return new AuraSessionBucketAdapter ( $ segment ) ; }
11182	public function cacheActions ( DirectCollection $ collection ) { $ serializedCollection = serialize ( $ collection ) ; $ this -> set ( Keys :: EXT_ACTION , $ serializedCollection ) ; }
6961	public static function J ( $ year ) { $ jd = static :: J2000 ( ) -> jd + ( $ year - 2000 ) * static :: DaysJulianYear ; $ epoch = new static ( $ jd ) ; $ epoch -> type = YearType :: Julian ( ) ; return $ epoch ; }
7757	public function processData ( $ data = array ( ) ) { if ( is_array ( $ data ) && 0 === count ( $ data ) ) { $ data = new \ stdClass ( ) ; } if ( ! is_string ( $ data ) ) { $ options = 0 ; if ( PHP_VERSION_ID >= 50400 ) { $ options |= JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ; if ( self :: $ pretty ) { $ options |= JSON_PRETTY_PRINT ; } $ data = json_encode ( $ data , $ options ) ; } else { $ data = json_encode ( $ data ) ; $ data = str_replace ( '\\/' , '/' , $ data ) ; $ data = preg_replace_callback ( '/\\\\u([a-f0-9]{4})/' , function ( $ match ) { return iconv ( 'UCS-4LE' , 'UTF-8' , pack ( 'V' , hexdec ( $ match [ 1 ] ) ) ) ; } , $ data ) ; } } return $ this -> setContent ( $ data ) ; }
3457	protected function replay ( Iterator $ historyEvents ) : void { foreach ( $ historyEvents as $ pastEvent ) { $ this -> version = $ pastEvent -> version ( ) ; $ this -> apply ( $ pastEvent ) ; } }
4066	public function handle ( BuildWidgetEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ( $ environment -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_dcasetting' ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'mandatory' ) || ( null === $ event -> getModel ( ) -> getId ( ) ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( null === $ attribute ) { return ; } if ( $ attribute -> get ( 'isunique' ) ) { Message :: addInfo ( $ this -> translator -> trans ( 'tl_metamodel_dcasetting.mandatory_for_unique_attr' , [ ] , 'contao_tl_metamodel_dcasetting' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'disabled' ] = true ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; $ model -> setProperty ( 'mandatory' , true ) ; } }
5450	public function acceptAttributeToken ( $ token , $ event ) { if ( $ this -> current_attribute ) { if ( $ event == LEXER_UNMATCHED ) { $ this -> attributes [ $ this -> current_attribute ] .= html_entity_decode ( $ token , ENT_QUOTES ) ; } if ( $ event == LEXER_SPECIAL ) { $ this -> attributes [ $ this -> current_attribute ] .= preg_replace ( '/^=\s*/' , '' , html_entity_decode ( $ token , ENT_QUOTES ) ) ; } } return true ; }
482	public function addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete = null , $ update = null ) { $ time = $ this -> beginCommand ( "add foreign key $name: $table (" . implode ( ',' , ( array ) $ columns ) . ") references $refTable (" . implode ( ',' , ( array ) $ refColumns ) . ')' ) ; $ this -> db -> createCommand ( ) -> addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete , $ update ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
4173	public function hasMigrationFile ( ) { $ this -> count = $ this -> fileHas ( '/class [A-Z]\w+ extends Migration/i' ) -> getClasses ( ) -> count ( ) ; return $ this -> hasMigrationFile = $ this -> count > 0 ; }
10452	public function format ( string $ question , string $ default = null ) : string { if ( $ default != '' ) { $ default = sprintf ( '[%s]' , $ default ) ; } return trim ( $ question . $ default ) . sprintf ( '%s ' , $ this -> getDelimiter ( ) ) ; }
12417	static function run_copy_paste_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcpd = self :: getTool ( 'phpcpd' , $ opts , true ) ; try { $ out = pake_sh ( "$phpcpd " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcpd.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
4322	public static function buildAttribString ( $ attribs ) { if ( \ is_string ( $ attribs ) ) { return \ rtrim ( ' ' . \ trim ( $ attribs ) ) ; } $ attribPairs = array ( ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_int ( $ k ) ) { $ k = $ v ; $ v = true ; } $ k = \ strtolower ( $ k ) ; if ( \ strpos ( $ k , 'data-' ) === 0 ) { $ v = \ json_encode ( $ v ) ; $ v = \ trim ( $ v , '"' ) ; } elseif ( \ is_bool ( $ v ) ) { $ v = self :: buildAttribBoolVal ( $ k , $ v ) ; } elseif ( \ is_array ( $ v ) || $ k === 'class' ) { $ v = self :: buildAttribArrayVal ( $ k , $ v ) ; } if ( \ array_filter ( array ( $ v === null , $ v === '' && \ in_array ( $ k , array ( 'class' , 'style' ) ) ) ) ) { continue ; } $ v = \ trim ( $ v ) ; $ attribPairs [ ] = $ k . '="' . \ htmlspecialchars ( $ v ) . '"' ; } \ sort ( $ attribPairs ) ; return \ rtrim ( ' ' . \ implode ( ' ' , $ attribPairs ) ) ; }
2348	public static function putContent ( $ strFile , $ strContent ) { $ objFile = new static ( $ strFile ) ; $ objFile -> write ( $ strContent ) ; $ objFile -> close ( ) ; }
2439	public function cloneForCurrent ( string $ current ) : self { return new self ( $ this -> context , $ this -> extras , $ this -> value , $ current ) ; }
6353	public static function tryFind ( Iterator $ iterator , callable $ predicate ) : Optional { return Optional :: ofNullable ( self :: find ( $ iterator , $ predicate ) ) ; }
2599	public function skipUntil ( $ type ) { while ( $ this -> lookahead !== null && $ this -> lookahead [ 'type' ] !== $ type ) { $ this -> moveNext ( ) ; } }
10151	private function readFooter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { if ( $ recordData ) { if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( $ recordData ) ; } else { $ string = $ this -> readByteStringShort ( $ recordData ) ; } $ this -> phpSheet -> getHeaderFooter ( ) -> setOddFooter ( $ string [ 'value' ] ) ; $ this -> phpSheet -> getHeaderFooter ( ) -> setEvenFooter ( $ string [ 'value' ] ) ; } } }
3644	public function map ( array $ keys , bool $ trim = true , bool $ clean = true ) { $ values = $ this -> only ( array_keys ( $ keys ) , $ trim , $ clean ) ; $ new = [ ] ; foreach ( $ keys as $ key => $ value ) { $ new [ $ value ] = array_get ( $ values , $ key ) ; } return $ new ; }
8262	protected function isValidCallback ( Request $ httpRequest ) { return $ this -> session -> has ( "provider" ) && $ httpRequest -> query -> has ( "state" ) && $ this -> session -> has ( "oauth2state" ) && is_string ( $ this -> session -> get ( "oauth2state" ) ) && ( strlen ( $ this -> session -> get ( "oauth2state" ) ) > 0 ) ; }
7815	public static function uploadImgFile ( $ path ) { try { if ( Request :: hasFile ( 'image' ) ) { $ pic = Request :: file ( 'image' ) ; if ( $ pic -> isValid ( ) ) { $ newName = md5 ( rand ( 1 , 1000 ) . $ pic -> getClientOriginalName ( ) ) . "." . $ pic -> getClientOriginalExtension ( ) ; $ pic -> move ( $ path , $ newName ) ; $ url = asset ( $ path . '/' . $ newName ) ; } else { self :: addError ( 'The file is invalid' ) ; } } else { self :: addError ( 'Not File' ) ; } } catch ( \ Exception $ e ) { self :: addError ( $ e -> getMessage ( ) ) ; } $ data = array ( 'status' => empty ( $ message ) ? 0 : 1 , 'message' => self :: getLastError ( ) , 'url' => ! empty ( $ url ) ? $ url : '' ) ; return $ data ; }
7175	public static function set_path ( & $ array , $ path , $ value , $ delimiter = null ) : void { if ( ! $ delimiter ) { $ delimiter = static :: $ delimiter ; } $ keys = $ path ; if ( ! is_array ( $ path ) ) { $ keys = explode ( $ delimiter , $ path ) ; } while ( count ( $ keys ) > 1 ) { $ key = array_shift ( $ keys ) ; if ( is_string ( $ key ) && ctype_digit ( $ key ) ) { $ key = ( int ) $ key ; } if ( ! isset ( $ array [ $ key ] ) ) { $ array [ $ key ] = array ( ) ; } $ array = & $ array [ $ key ] ; } $ array [ array_shift ( $ keys ) ] = $ value ; }
7393	public function unserialize ( $ serialized ) : void { $ this -> _initMetaData ( ) ; $ data = unserialize ( $ serialized ) ; foreach ( $ data as $ k => $ v ) { $ this -> { $ k } = $ v ; } }
4793	function order ( $ columns ) { $ this -> rows = null ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { if ( $ this -> union ) { $ this -> unionOrder [ ] = $ columns ; } else { $ this -> order [ ] = $ columns ; } } } elseif ( $ this -> union ) { $ this -> unionOrder = array ( ) ; } else { $ this -> order = array ( ) ; } return $ this ; }
12975	public function registerMapping ( Configuration $ config ) { $ driverChain = new DriverChain ; $ aliasMap = array ( ) ; $ drivers = array ( ) ; $ this -> parseMappingInfo ( ) ; foreach ( $ this -> getMappings ( ) as $ mappingName => $ mappingConfig ) { if ( empty ( $ mappingConfig [ 'prefix' ] ) ) { $ mappingConfig [ 'prefix' ] = '__DEFAULT__' ; } $ drivers [ $ mappingConfig [ 'type' ] ] [ $ mappingConfig [ 'prefix' ] ] = $ mappingConfig [ 'dir' ] ; if ( isset ( $ mappingConfig [ 'alias' ] ) ) { $ aliasMap [ $ mappingConfig [ 'alias' ] ] = $ mappingConfig [ 'prefix' ] ; } } foreach ( $ drivers as $ driverType => $ driverPaths ) { if ( $ driverType === 'annotation' ) { $ driver = $ config -> newDefaultAnnotationDriver ( $ driverPaths , false ) ; } else { $ paths = $ driverPaths ; if ( strpos ( $ driverType , 'simplified' ) === 0 ) { $ paths = array_flip ( $ driverPaths ) ; } $ driver = DiC :: resolve ( $ driverType , [ $ paths ] ) ; } foreach ( $ driverPaths as $ prefix => $ driverPath ) { if ( $ prefix === '__DEFAULT__' or count ( $ this -> config [ 'mappings' ] ) === 1 ) { $ driverChain -> setDefaultDriver ( $ driver ) ; } else { $ driverChain -> addDriver ( $ driver , $ prefix ) ; } } } $ config -> setMetadataDriverImpl ( $ driverChain ) ; $ config -> setEntityNamespaces ( $ aliasMap ) ; }
12317	public function load ( $ name ) { foreach ( $ this -> sourceDirs as $ dir ) { if ( 0 === strpos ( $ name , DIRECTORY_SEPARATOR ) ) { $ yamlFile = $ name ; } else { $ yamlFile = $ dir . '/' . $ name ; } if ( false === strstr ( $ yamlFile , self :: EXT_YML ) ) { $ yamlFile .= self :: EXT_YML ; } if ( is_file ( $ yamlFile ) ) { return new ArrayCollection ( Yaml :: parse ( $ yamlFile ) ) ; } } throw new \ Exception ( sprintf ( 'No Yaml file found for {%s}' , $ name ) ) ; }
3337	public function getInputTag ( $ name , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<input type="hidden" role="uploadcare-uploader" name="%s" data-upload-url-base="" data-integration="%s" %s />' , $ name , $ this -> getIntegrationData ( ) , join ( ' ' , $ to_compile ) ) ; }
8234	protected function isExpired ( array $ tokenData , $ tokenValidity = null ) { return time ( ) > $ tokenData [ 'time' ] + ( ( $ tokenValidity !== null ) ? $ tokenValidity : self :: TOKEN_VALIDITY ) ; }
6331	private function registerPostProcessor ( string $ type , string $ class ) : void { if ( \ class_exists ( $ class ) ) { $ interfaces = \ class_implements ( $ class ) ; if ( \ in_array ( PostProcessor :: class , $ interfaces , true ) ) { $ this -> postProcessorsMap [ $ type ] = $ class ; } else { throw new ConfigException ( "Class {$class} don't implement interface " . PostProcessor :: class ) ; } } else { throw new ConfigException ( "Class {$class} not found" ) ; } }
3597	protected function createIndexes ( ) { $ this -> createIndex ( $ this -> db -> getIndexName ( '{{%dolphiq_sitemap_entries}}' , [ 'type' , 'linkId' ] , true ) , '{{%dolphiq_sitemap_entries}}' , [ 'type' , 'linkId' ] , true ) ; switch ( $ this -> driver ) { case DbConfig :: DRIVER_MYSQL : break ; case DbConfig :: DRIVER_PGSQL : break ; } }
9040	public function getMax ( string $ column ) : int { return $ this -> connection -> query ( 'SELECT IFNULL(MAX(%column), 0) position FROM %table' , $ column , $ this -> getTableName ( ) ) -> fetch ( ) -> position ; }
9314	public function storageClearAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ dbAdapter = $ this -> getDbAdapter ( ) ; $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; try { $ table = new JobTable ( $ dbAdapter ) ; $ table -> truncate ( ) ; } catch ( \ Exception $ exception ) { $ console -> writeLine ( 'Truncating database table failed!' , ConsoleColor :: LIGHT_RED ) ; return ; } $ console -> writeLine ( 'Storage was successfully cleared!' , ConsoleColor :: LIGHT_GREEN ) ; }
5641	public function paintCaseStart ( $ test_name ) { if ( ! isset ( $ this -> size ) ) { $ this -> size = 1 ; } if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintHeader ( $ test_name ) ; } $ this -> test_stack [ ] = $ test_name ; }
4116	public function getBlockPath ( Mage_Core_Block_Abstract $ block ) { $ blockPath = array ( ) ; $ step = $ block -> getParentBlock ( ) ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { $ blockPath [ ] = $ this -> getBlockInfo ( $ step , false ) ; $ step = $ step -> getParentBlock ( ) ; } return $ blockPath ; }
7217	public function getDocumentationClassesList ( ) : array { $ classNames = $ this -> getCmfConfig ( ) -> config ( 'api_documentation.classes' , [ ] ) ; if ( empty ( $ classNames ) ) { $ classNames = $ this -> loadClassesFromFileSystem ( ) ; } return $ classNames ; }
10221	public static function getConversionGroupUnits ( $ group = null ) { $ conversionGroups = [ ] ; foreach ( self :: $ conversionUnits as $ conversionUnit => $ conversionGroup ) { if ( ( $ group === null ) || ( $ conversionGroup [ 'Group' ] == $ group ) ) { $ conversionGroups [ $ conversionGroup [ 'Group' ] ] [ ] = $ conversionUnit ; } } return $ conversionGroups ; }
1034	private function completeListValue ( ListOfType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ itemType = $ returnType -> getWrappedType ( ) ; Utils :: invariant ( is_array ( $ result ) || $ result instanceof Traversable , 'User Error: expected iterable, but did not find one for field ' . $ info -> parentType . '.' . $ info -> fieldName . '.' ) ; $ containsPromise = false ; $ i = 0 ; $ completedItems = [ ] ; foreach ( $ result as $ item ) { $ fieldPath = $ path ; $ fieldPath [ ] = $ i ++ ; $ completedItem = $ this -> completeValueCatchingError ( $ itemType , $ fieldNodes , $ info , $ fieldPath , $ item ) ; if ( ! $ containsPromise && $ this -> getPromise ( $ completedItem ) ) { $ containsPromise = true ; } $ completedItems [ ] = $ completedItem ; } return $ containsPromise ? $ this -> exeContext -> promises -> all ( $ completedItems ) : $ completedItems ; }
4531	public function process ( ContainerBuilder $ container ) { $ definition = $ container -> findDefinition ( LoaderCollection :: class ) ; $ services = $ container -> findTaggedServiceIds ( 'ds_tenant.loader' ) ; $ items = [ ] ; foreach ( $ services as $ id => $ tags ) { foreach ( $ tags as $ tag ) { $ items [ ] = [ 'id' => $ id , 'priority' => array_key_exists ( 'priority' , $ tag ) ? $ tag [ 'priority' ] : 0 , 'alias' => array_key_exists ( 'alias' , $ tag ) ? $ tag [ 'alias' ] : null ] ; } } usort ( $ items , function ( $ a , $ b ) { return $ a [ 'priority' ] === $ b [ 'priority' ] ? 0 : $ a [ 'priority' ] < $ b [ 'priority' ] ? - 1 : 1 ; } ) ; foreach ( $ items as $ item ) { if ( null !== $ item [ 'alias' ] ) { $ definition -> addMethodCall ( 'set' , [ $ item [ 'alias' ] , new Reference ( $ item [ 'id' ] ) ] ) ; } else { $ definition -> addMethodCall ( 'add' , [ new Reference ( $ item [ 'id' ] ) ] ) ; } } }
4695	public function limitBy ( ? int $ limit , int $ offset = null ) : self { $ this -> dirty ( ) ; $ this -> limit = $ limit || $ offset ? [ $ limit , $ offset ] : null ; return $ this ; }
651	public function dropView ( $ viewName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropView ( $ viewName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ viewName ) ; }
10012	public function getSheet ( $ pIndex ) { if ( ! isset ( $ this -> workSheetCollection [ $ pIndex ] ) ) { $ numSheets = $ this -> getSheetCount ( ) ; throw new Exception ( "Your requested sheet index: {$pIndex} is out of bounds. The actual number of sheets is {$numSheets}." ) ; } return $ this -> workSheetCollection [ $ pIndex ] ; }
7547	function getEncoding ( ) { $ root = $ this -> getRoot ( ) ; if ( $ root !== null ) { if ( $ enc = $ root -> select ( 'meta[charset]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "charset" ) ; } elseif ( $ enc = $ root -> select ( '"?xml"[encoding]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "encoding" ) ; } elseif ( $ enc = $ root -> select ( 'meta[content*="charset="]' , 0 , true , true ) ) { $ enc = $ enc -> getAttribute ( "content" ) ; return substr ( $ enc , strpos ( $ enc , "charset=" ) + 8 ) ; } } return false ; }
6862	protected function registerFactory ( ) { $ this -> app -> singleton ( 'notifyme.factory' , function ( ) { return new NotifyMeFactory ( ) ; } ) ; $ this -> app -> alias ( 'notifyme.factory' , NotifyMeFactory :: class ) ; $ this -> app -> alias ( 'notifyme.factory' , FactoryInterface :: class ) ; }
663	public function getMaster ( ) { if ( $ this -> _master === false ) { $ this -> _master = $ this -> shuffleMasters ? $ this -> openFromPool ( $ this -> masters , $ this -> masterConfig ) : $ this -> openFromPoolSequentially ( $ this -> masters , $ this -> masterConfig ) ; } return $ this -> _master ; }
6532	protected function buildParams ( SmsGatewayMessage $ message , $ to ) { $ optionalFields = array_filter ( [ 'expires_at' => data_get ( $ message , 'expiresAt' ) , 'send_at' => data_get ( $ message , 'sendAt' ) , ] ) ; return array_merge ( [ 'number' => $ to , 'message' => trim ( $ message -> content ) , ] , $ optionalFields ) ; }
1016	public static function isBuiltInType ( Type $ type ) { return in_array ( $ type -> name , array_keys ( self :: getAllBuiltInTypes ( ) ) , true ) ; }
7960	public function canChangeDslamProfile ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canChangeDslamProfile ; }
11683	protected function _pushMessage ( $ message , $ type = 'error' , array $ interpolateParams = [ ] ) { $ this -> _messages [ ] = [ 'message' => vsprintf ( $ message , $ interpolateParams ) , 'type' => $ type , ] ; return $ this ; }
2177	private function getRedirectResponse ( ) : RedirectResponse { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } return new RedirectResponse ( $ request -> getRequestUri ( ) ) ; }
1730	public function isMemberOf ( $ id ) { if ( ! is_numeric ( $ id ) ) { return false ; } $ groups = StringUtil :: deserialize ( $ this -> groups ) ; if ( empty ( $ groups ) || ! \ is_array ( $ groups ) ) { return false ; } if ( \ in_array ( $ id , $ groups ) ) { return true ; } return false ; }
8146	public function parse ( Twig_TokenStream $ stream ) { if ( null === $ this -> parser ) { $ this -> parser = new Twig_Parser ( $ this ) ; } return $ this -> parser -> parse ( $ stream ) ; }
2484	protected function getAllSearchTargets ( ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = [ ] ; $ searchTargets = $ this -> endpointResolver -> getEndpoints ( ) ; if ( ! empty ( $ searchTargets ) ) { foreach ( $ searchTargets as $ endpointName ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
232	public function quoteValue ( $ str ) { if ( ! is_string ( $ str ) ) { return $ str ; } if ( ( $ value = $ this -> db -> getSlavePdo ( ) -> quote ( $ str ) ) !== false ) { return $ value ; } return "'" . addcslashes ( str_replace ( "'" , "''" , $ str ) , "\000\n\r\\\032" ) . "'" ; }
5346	public function requestRemoteHands ( $ colocationName , $ contactName , $ phoneNumber , $ expectedDuration , $ instructions ) { return $ this -> call ( self :: SERVICE , 'requestRemoteHands' , [ $ colocationName , $ contactName , $ phoneNumber , $ expectedDuration , $ instructions ] ) ; }
3691	public function presetVariantBase ( PreEditModelEvent $ event ) { $ model = $ event -> getModel ( ) ; if ( ! $ model instanceof Model ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; if ( $ metaModel -> hasVariants ( ) && ( ! $ nativeItem -> get ( 'vargroup' ) ) ) { $ nativeItem -> set ( 'varbase' , '1' ) ; } }
9488	public function getPages ( ) { if ( $ this -> getPageRange ( ) > $ this -> getPagesCount ( ) ) { $ this -> setPageRange ( $ this -> getPagesCount ( ) ) ; } $ delta = ceil ( $ this -> getPageRange ( ) / 2 ) ; if ( $ this -> getCurrentPageNumber ( ) - $ delta > $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) ) { $ pages = range ( $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) + 1 , $ this -> getPagesCount ( ) ) ; } else { if ( $ this -> getCurrentPageNumber ( ) - $ delta < 0 ) { $ delta = $ this -> getCurrentPageNumber ( ) ; } $ offset = $ this -> getCurrentPageNumber ( ) - $ delta ; $ pages = range ( $ offset + 1 , $ offset + $ this -> getPageRange ( ) ) ; } return $ pages ; }
1424	protected function load ( $ record , EncodingParametersInterface $ parameters ) { $ relationshipPaths = $ this -> getRelationshipPaths ( $ parameters -> getIncludePaths ( ) ) ; $ record -> loadMissing ( $ relationshipPaths ) ; }
1963	public static function encodeUrl ( $ strUrl ) { if ( $ strUrl == '' ) { return '' ; } if ( $ strUrl == '#' || strncmp ( $ strUrl , '{{' , 2 ) === 0 ) { return $ strUrl ; } if ( strncmp ( $ strUrl , 'mailto:' , 7 ) === 0 ) { return static :: encodeEmail ( $ strUrl ) ; } $ arrUrl = parse_url ( $ strUrl ) ; if ( ! isset ( $ arrUrl [ 'scheme' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Expected a FQDN, got "%s"' , $ strUrl ) ) ; } if ( isset ( $ arrUrl [ 'scheme' ] ) ) { $ arrUrl [ 'scheme' ] .= ( ( substr ( $ strUrl , \ strlen ( $ arrUrl [ 'scheme' ] ) , 3 ) == '://' ) ? '://' : ':' ) ; } if ( isset ( $ arrUrl [ 'user' ] ) ) { $ arrUrl [ 'user' ] .= isset ( $ arrUrl [ 'pass' ] ) ? ':' : '@' ; } if ( isset ( $ arrUrl [ 'pass' ] ) ) { $ arrUrl [ 'pass' ] .= '@' ; } if ( isset ( $ arrUrl [ 'host' ] ) ) { $ arrUrl [ 'host' ] = static :: encode ( $ arrUrl [ 'host' ] ) ; } if ( isset ( $ arrUrl [ 'port' ] ) ) { $ arrUrl [ 'port' ] = ':' . $ arrUrl [ 'port' ] ; } if ( isset ( $ arrUrl [ 'query' ] ) ) { $ arrUrl [ 'query' ] = '?' . $ arrUrl [ 'query' ] ; } if ( isset ( $ arrUrl [ 'fragment' ] ) ) { $ arrUrl [ 'fragment' ] = '#' . $ arrUrl [ 'fragment' ] ; } $ strReturn = '' ; foreach ( array ( 'scheme' , 'user' , 'pass' , 'host' , 'port' , 'path' , 'query' , 'fragment' ) as $ key ) { if ( isset ( $ arrUrl [ $ key ] ) ) { $ strReturn .= $ arrUrl [ $ key ] ; } } return $ strReturn ; }
9453	public function getCollection ( $ index , array $ filters = null , array $ queries = null , array $ fieldWeights = null , $ limit = 20 , $ offset = 0 , $ countableAttributes = null ) { $ result = $ this -> query ( $ index , $ filters , $ queries , $ fieldWeights , $ limit , $ offset ) ; if ( is_array ( $ result ) ) { $ i = 0 ; if ( $ countableAttributes ) { foreach ( $ countableAttributes as $ attributeName ) { $ i ++ ; $ result [ 0 ] [ 'attributes' ] [ 'countable' ] [ $ attributeName ] = new CountableCollection ( $ result [ $ i ] , $ attributeName ) ; } } for ( $ l = 1 ; $ l <= $ i ; $ l ++ ) { unset ( $ result [ $ l ] ) ; } $ collection = $ this -> factoryCollection ( $ result ) ; return $ collection ; } }
8227	protected function logSuccessfulRegistration ( array $ reg ) { $ this -> getLogger ( ) -> info ( "New registration: {name} ({email}) from {addr}" , array ( "name" => $ reg [ "username" ] , "email" => $ reg [ "email" ] , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] ) ) ; $ max = $ this -> config [ "maxUsers" ] ; $ count = $ this -> storage -> getUsersCount ( ) + 1 ; if ( $ count % ceil ( $ max / 10 ) === 0 ) { $ percent = intval ( $ count / ceil ( $ max / 100 ) ) ; $ this -> getLogger ( ) -> warning ( "The amount of users has reached {percent} of the maximum capacity {max}." , array ( "percent" => $ percent , "max" => $ max ) ) ; } }
2933	public function deleteKeys ( $ keys = [ ] ) { foreach ( $ keys as $ key ) { $ this -> writer -> deleteSetter ( $ key ) ; } return $ this ; }
4670	protected function afterGeneration ( ) { $ this -> mapTemplate -> writeToFile ( ) ; $ this -> autoloadMap -> writeToFile ( ) ; $ responseParserTemplate = new ResponseParserTemplate ( $ this -> config ) ; $ this -> autoloadMap -> addEntry ( $ responseParserTemplate -> getClassName ( ) , $ responseParserTemplate -> getClassPath ( ) ) ; $ responseParserTemplate -> writeToFile ( ) ; }
11925	public function generate ( string $ outputDir ) : array { $ generatedFiles = [ ] ; foreach ( $ this -> generators as $ generator ) { $ this -> logger -> info ( 'Running generator ' . get_class ( $ generator ) ) ; $ result = $ generator -> generate ( ) ; foreach ( $ result -> all ( ) as $ phpFile ) { $ path = str_replace ( [ '/' , "\\" ] , DIRECTORY_SEPARATOR , $ outputDir . '/' . $ phpFile -> getFqcn ( ) -> getNamespace ( ) ) ; BaseUtil :: ensureDirectory ( $ path , 0711 ) ; $ filePath = $ path . DIRECTORY_SEPARATOR . $ phpFile -> getFqcn ( ) -> getName ( ) . '.php' ; $ this -> logger -> info ( 'Writing to file ' . $ filePath ) ; file_put_contents ( $ filePath , $ phpFile -> getText ( ) ) ; $ generatedFiles [ ] = new GeneratedFile ( $ filePath , $ phpFile ) ; } } return $ generatedFiles ; }
4414	public function onKernelRequest ( GetResponseEvent $ event ) { if ( ! $ event -> isMasterRequest ( ) ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( mb_stripos ( $ currentRoute , 'netgen_information_collection' ) !== 0 ) { return ; } $ this -> globalVariable -> setPageLayoutTemplate ( $ this -> pageLayoutTemplate ) ; }
129	protected function requestContent ( $ origin , $ path ) { $ url = rtrim ( $ origin , '/' ) . '/' . ltrim ( $ path , '/' ) ; $ content = $ this -> rfs -> getContents ( $ origin , $ url , false ) ; if ( ! $ content ) { throw new \ UnexpectedValueException ( 'The PEAR channel at ' . $ url . ' did not respond.' ) ; } return str_replace ( 'http://pear.php.net/rest/' , 'https://pear.php.net/rest/' , $ content ) ; }
6277	protected function readInt32 ( $ pos = 0 ) { static $ lookups ; if ( ! $ lookups ) { $ lookups = [ ] ; for ( $ i = 1 ; $ i < 256 ; $ i ++ ) { $ lookups [ chr ( $ i ) ] = $ i ; } } $ buf = $ this -> read ( $ pos , 4 ) ; $ rv = 0 ; if ( $ buf [ 0 ] !== "\x0" ) { $ rv = $ lookups [ $ buf [ 0 ] ] ; } if ( $ buf [ 1 ] !== "\x0" ) { $ rv |= ( $ lookups [ $ buf [ 1 ] ] << 8 ) ; } if ( $ buf [ 2 ] !== "\x0" ) { $ rv |= ( $ lookups [ $ buf [ 2 ] ] << 16 ) ; } if ( $ buf [ 3 ] !== "\x0" ) { $ rv |= ( $ lookups [ $ buf [ 3 ] ] << 24 ) ; } return $ rv ; }
6139	public static function check ( $ uri ) { try { $ uri = new self ( strval ( $ uri ) ) ; } catch ( Ts3Exception $ e ) { return false ; } return $ uri -> valid ( ) ; }
10764	public function generateText ( ) { $ result = 'SPD' . self :: DELIMITER . $ this -> version . self :: DELIMITER . $ this -> implodeContent ( ) ; if ( $ this -> appendCRC32 ) { $ result .= self :: DELIMITER . 'CRC32:' . sprintf ( '%x' , crc32 ( $ result ) ) ; } return $ result ; }
2186	public function fetch ( $ strTable , $ varKey , $ strAlias = null ) { $ strClass = Model :: getClassFromTable ( $ strTable ) ; $ strPk = $ strClass :: getPk ( ) ; if ( $ strAlias === null || $ strAlias == $ strPk ) { if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ varKey ] ) ) { return $ this -> arrRegistry [ $ strTable ] [ $ varKey ] ; } return null ; } return $ this -> fetchByAlias ( $ strTable , $ strAlias , $ varKey ) ; }
4182	public static function instance ( ) { switch ( func_num_args ( ) ) { case func_num_args ( ) == 0 : return new static ( ) ; case func_num_args ( ) == 1 : return new static ( func_get_arg ( 0 ) ) ; case func_num_args ( ) == 2 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) ) ; case func_num_args ( ) == 3 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) ) ; case func_num_args ( ) == 4 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) ) ; case func_num_args ( ) == 5 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) , func_get_arg ( 4 ) ) ; default : throw new Exception ( 'Unable to instantiate class with given arguments' ) ; } }
9830	public function getAssociationMenuName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s.menu' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
8932	public function loadDependencies ( ) { $ config = ConfigService :: fetch ( dirname ( __DIR__ ) ) ; $ config = array_merge ( $ config , ConfigService :: fetch ( ) ) ; $ moduleService = new ModuleService ; if ( ! array_key_exists ( 'slim-api' , $ config ) ) { $ config [ 'slim-api' ] = [ 'modules' => [ 'SlimApi\Phinx' , 'SlimApi\Mvc' ] ] ; } else { require 'vendor/autoload.php' ; } foreach ( $ config [ 'slim-api' ] [ 'modules' ] as $ moduleNamespace ) { $ config = array_merge ( $ config , $ moduleService -> load ( $ moduleNamespace ) ) ; } return $ config ; }
3159	public function storeVariables ( QtiRunnerServiceContext $ context , $ itemUri , $ metaVariables , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariables ( $ testUri , $ itemUri , $ metaVariables , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariables ( $ testUri , $ metaVariables , $ sessionId ) ; } return true ; }
755	public function validate ( $ input , $ caseSensitive ) { $ code = $ this -> getVerifyCode ( ) ; $ valid = $ caseSensitive ? ( $ input === $ code ) : strcasecmp ( $ input , $ code ) === 0 ; $ session = Yii :: $ app -> getSession ( ) ; $ session -> open ( ) ; $ name = $ this -> getSessionKey ( ) . 'count' ; $ session [ $ name ] += 1 ; if ( $ valid || $ session [ $ name ] > $ this -> testLimit && $ this -> testLimit > 0 ) { $ this -> getVerifyCode ( true ) ; } return $ valid ; }
10686	private function showPermissionError ( PermissionError $ e ) { if ( PHP_SAPI !== "cli" ) { http_response_code ( 500 ) ; header ( "Content-type: text/plain" ) ; } if ( $ this -> dev ) { $ file = $ e -> path ; echo "{$e->getMessage()}\n" ; echo "\n" ; echo WF :: str ( $ e , false ) ; } else { echo "A permission error is preventing this page from displaying properly." ; } die ( ) ; }
371	public function isColorEnabled ( $ stream = \ STDOUT ) { return $ this -> color === null ? Console :: streamSupportsAnsiColors ( $ stream ) : $ this -> color ; }
4466	private function normalizeCommandArgs ( string $ command , array $ args ) : array { $ arguments = array_merge ( [ $ command , microtime ( true ) ] , $ args ) ; array_unshift ( $ arguments , 0 ) ; array_unshift ( $ arguments , $ this -> sha ) ; return $ arguments ; }
7424	public function render ( $ menu = 'Default' , $ debug = false , $ class = null ) { $ response = $ this -> initiateSubRequest ( ) ; return $ response -> getContent ( ) ; }
9021	public function getWordsByComplexity ( $ string ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ sortedWords = $ analysis -> getKeyValuesByFrequency ( ) ; $ wordsByFrequency = array_unique ( array_keys ( $ sortedWords ) ) ; usort ( $ wordsByFrequency , function ( $ a , $ b ) { return strlen ( $ b ) - strlen ( $ a ) ; } ) ; return $ wordsByFrequency ; }
12304	public function adminIndex ( ) { $ config = [ 'title' => trans ( 'HCLanguages::languages.page_title' ) , 'listURL' => route ( 'admin.api.languages' ) , 'newFormUrl' => route ( 'admin.api.form-manager' , [ 'languages-new' ] ) , 'editFormUrl' => route ( 'admin.api.form-manager' , [ 'languages-edit' ] ) , 'imagesUrl' => route ( 'resource.get' , [ '/' ] ) , 'headers' => $ this -> getAdminListHeader ( ) , ] ; $ config [ 'actions' ] [ ] = 'search' ; return hcview ( 'HCCoreUI::admin.content.list' , [ 'config' => $ config ] ) ; }
2258	protected function prepareForWidget ( $ arrData , $ strName , $ varValue = null , $ strField = '' , $ strTable = '' ) { @ trigger_error ( 'Using Controller::prepareForWidget() has been deprecated and will no longer work in Contao 5.0. Use Widget::getAttributesFromDca() instead.' , E_USER_DEPRECATED ) ; return Widget :: getAttributesFromDca ( $ arrData , $ strName , $ varValue , $ strField , $ strTable ) ; }
7208	public function round ( ) : void { $ this -> unit = Money :: round ( $ this -> unit , $ this -> currency ) ; $ this -> gross = Money :: round ( $ this -> gross , $ this -> currency ) ; $ this -> discount = Money :: round ( $ this -> discount , $ this -> currency ) ; $ this -> base = Money :: round ( $ this -> base , $ this -> currency ) ; $ this -> total = Money :: round ( $ this -> total , $ this -> currency ) ; $ this -> tax = Money :: round ( $ this -> total - $ this -> base , $ this -> currency ) ; }
3794	private function checkForAction ( $ clipboard , $ action ) { $ filter = new Filter ( ) ; $ filter -> andActionIs ( $ action ) ; $ items = $ clipboard -> fetch ( $ filter ) ; if ( $ items === null ) { return ; } foreach ( $ items as $ item ) { $ itemProviderName = $ item -> getDataProviderName ( ) ; $ modelId = $ item -> getModelId ( ) ; if ( $ this -> providerName !== $ itemProviderName ) { continue ; } if ( ! $ modelId ) { $ this -> checkEmpty ( $ action ) ; continue ; } $ containedModel = $ this -> getModelById ( $ modelId -> getId ( ) ) ; if ( $ this -> currentModel == null ) { $ this -> checkForRoot ( $ containedModel , $ action ) ; } elseif ( $ containedModel ) { $ this -> checkForModel ( $ containedModel , $ action ) ; } else { $ this -> checkEmpty ( $ action ) ; } } }
12059	public function setTarget ( $ value ) { if ( in_array ( $ value , $ this -> possibleTargets ) ) { $ this -> _target = $ value ; } else { throw new Exception ( 'Unknown deletion target ' . $ value ) ; } }
600	public function andOnCondition ( $ condition , $ params = [ ] ) { if ( $ this -> on === null ) { $ this -> on = $ condition ; } else { $ this -> on = [ 'and' , $ this -> on , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
2596	public static function decodeProcessingLevel ( $ level ) { $ decoded = null ; $ map = [ 0 => 'system' , 1 => 'application' ] ; if ( array_key_exists ( $ level , $ map ) ) { $ decoded = $ map [ $ level ] ; } return $ decoded ; }
8214	protected function getTubeStats ( $ tube ) { try { $ stats = $ this -> getPheanstalk ( ) -> statsTube ( $ tube ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { throw new \ RuntimeException ( "Tube '$tube' doesn't exist." ) ; } throw $ e ; } return $ stats ; }
5724	protected function getToplevelController ( ) { $ c = $ this -> owner -> getController ( ) ; while ( $ c && $ c instanceof GridFieldDetailForm_ItemRequest ) { $ c = $ c -> getController ( ) ; } return $ c ; }
3607	protected function getTableNames ( ) { $ schemas = DB :: getConfig ( 'used_schemas' ) ? : [ DB :: getConfig ( 'schema' ) ] ; $ schemaCount = count ( $ schemas ) ; $ binds = implode ( ',' , array_fill ( 0 , $ schemaCount , '?' ) ) ; return collect ( DB :: select ( "SELECT schemaname || '.' || tablename AS table FROM pg_catalog.pg_tables WHERE schemaname IN (" . $ binds . ')' , $ schemas ) ) -> pluck ( 'table' ) -> reject ( function ( $ value , $ key ) { $ tableName = explode ( '.' , $ value ) [ 1 ] ; return $ tableName === 'spatial_ref_sys' ; } ) ; }
656	public function init ( ) { if ( $ this -> autoRelease ) { $ locks = & $ this -> _locks ; register_shutdown_function ( function ( ) use ( & $ locks ) { foreach ( $ locks as $ lock ) { $ this -> release ( $ lock ) ; } } ) ; } }
9357	public function withoutHeader ( $ name ) { $ instance = clone $ this ; if ( $ this -> hasHeader ( $ name ) ) { $ static = clone $ this ; unset ( $ static -> headers [ $ name ] ) ; $ instance = $ static ; } return $ instance ; }
10706	public function getUserAddForm ( ) { if ( null === $ this -> userAddForm ) { $ this -> userAddForm = $ this -> getServiceLocator ( ) -> get ( 'user.form.useradd' ) ; } return $ this -> userAddForm ; }
3522	public static function refresh ( $ refresh_token ) { $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , [ 'grant_type' => 'refresh_token' , 'refresh_token' => $ refresh_token , 'includePerms' => "false" , 'token_type' => 'eg1' , ] , FortniteClient :: FORTNITE_AUTHORIZATION ) ; if ( ! $ data -> access_token ) { throw new \ Exception ( $ data -> errorMessage ) ; } return new self ( $ data -> access_token , $ data -> in_app_id , $ data -> refresh_token , $ data -> account_id , $ data -> expires_in ) ; }
6692	public function addGroup ( $ prefix , array $ middleware , callable $ callback ) { $ previousMiddlewareStack = $ this -> middlewareStack ; $ previousGroupPrefix = $ this -> currentGroupPrefix ; $ this -> currentGroupPrefix = $ previousGroupPrefix . $ prefix ; $ this -> middlewareStack = array_merge ( $ previousMiddlewareStack , $ middleware ) ; $ callback ( $ this ) ; $ this -> currentGroupPrefix = $ previousGroupPrefix ; $ this -> middlewareStack = $ previousMiddlewareStack ; }
8810	public function destroy ( ) { foreach ( $ _COOKIE as $ key => $ value ) { setcookie ( $ key , null , - 1 , '/' ) ; unset ( $ _COOKIE [ $ key ] ) ; } return ; }
12129	public function failed ( $ fail = true ) { if ( ! func_num_args ( ) ) { return $ this -> _failed ; } $ this -> _failed = $ fail ; return $ this ; }
2182	public function listImageSizeItem ( $ row ) { $ html = '<div class="tl_content_left">' ; $ html .= $ row [ 'media' ] ; if ( $ row [ 'width' ] || $ row [ 'height' ] ) { $ html .= ' <span style="padding-left:3px">' . $ row [ 'width' ] . 'x' . $ row [ 'height' ] . '</span>' ; } if ( $ row [ 'zoom' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">(' . $ row [ 'zoom' ] . '%)</span>' ; } $ html .= "</div>\n" ; return $ html ; }
5690	public static function normalise ( $ html ) { $ rules = array ( '#<!--.*? , '#<(script|option|textarea)[^>]*>.*?</\1>#si' , '#<img[^>]*alt\s*=\s*("([^"]*)"|\'([^\']*)\'|([a-zA-Z_]+))[^>]*>#' , '#<[^>]*>#' , ) ; $ replace = array ( '' , '' , ' \2\3\4 ' , '' , ) ; $ text = preg_replace ( $ rules , $ replace , $ html ) ; $ text = html_entity_decode ( $ text , ENT_QUOTES ) ; $ text = preg_replace ( '#\s+#' , ' ' , $ text ) ; return trim ( trim ( $ text ) , "\xA0" ) ; }
11328	public function setFormField ( $ value ) { if ( is_array ( $ value ) ) { if ( is_null ( $ this -> formFieldClass ) ) { throw new Exception ( "DB Field incorrectly set up. What is the form class?" ) ; } if ( is_null ( $ this -> _formField ) ) { $ config = $ value ; $ config [ 'class' ] = $ this -> formFieldClass ; $ config [ 'modelField' ] = $ this ; $ value = Yii :: createObject ( $ config ) ; } else { $ settings = $ value ; $ value = $ this -> _formField ; unset ( $ settings [ 'class' ] ) ; Yii :: configure ( $ value , $ settings ) ; } } $ this -> _formField = $ value ; return true ; }
12529	public function getForeignDataSource ( $ foreignModelClass ) { foreach ( $ this -> dataSources as $ dataSource ) { if ( $ dataSource -> foreignModel -> modelName === $ foreignModelClass ) { return $ dataSource ; } } return false ; }
8288	protected function loadModules ( ) { foreach ( $ this -> config [ "authModules" ] as $ name ) { try { $ instance = $ this -> container -> get ( $ name ) ; } catch ( \ League \ Container \ Exception \ NotFoundException $ e ) { if ( ! class_exists ( $ name ) ) { throw new \ RuntimeException ( "PicoAuth module not found: " . $ name ) ; } $ instance = new $ name ; } if ( ! is_subclass_of ( $ instance , Module \ AbstractAuthModule :: class , false ) ) { throw new \ RuntimeException ( "PicoAuth module class must inherit from AbstractAuthModule." ) ; } $ name = $ instance -> getName ( ) ; $ this -> modules [ $ name ] = $ instance ; } }
3244	public function getWasPurchasedAttribute ( ) { if ( Auth :: guest ( ) ) return false ; return Auth :: user ( ) -> orders ( ) -> whereSKU ( $ this -> attributes [ 'sku' ] ) -> whereStatusIn ( config ( 'shop.order_status_purchase' ) ) -> count ( ) > 0 ; }
7885	public function getData ( $ date , $ level = null ) { if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ data = LogViewer :: data ( $ date , $ level ) ; $ paginator = new Paginator ( $ data , $ this -> perPage ) ; $ path = ( new \ ReflectionClass ( $ paginator ) ) -> getProperty ( 'path' ) ; $ path -> setAccessible ( true ) ; $ path -> setValue ( $ paginator , URL :: route ( 'logviewer.index' ) . '/' . $ date . '/' . $ level ) ; if ( count ( $ data ) > $ paginator -> perPage ( ) ) { $ log = array_slice ( $ data , $ paginator -> firstItem ( ) - 1 , $ paginator -> perPage ( ) ) ; } else { $ log = $ data ; } return View :: make ( 'logviewer::data' , compact ( 'paginator' , 'log' ) ) ; }
4720	public function register ( Text $ text ) { $ hash = $ this -> generateHash ( $ text ) ; $ this -> set ( $ hash , $ text ) ; return new Text ( $ hash ) ; }
1644	public function simplify ( Polyline $ polyline ) : Polyline { $ counterPoints = $ polyline -> getNumberOfPoints ( ) ; if ( $ counterPoints < 3 ) { return clone $ polyline ; } $ result = new Polyline ( ) ; $ bearingCalc = new BearingEllipsoidal ( ) ; $ points = $ polyline -> getPoints ( ) ; $ index = 0 ; $ result -> addPoint ( $ points [ $ index ] ) ; do { $ index ++ ; if ( $ index === ( $ counterPoints - 1 ) ) { $ result -> addPoint ( $ points [ $ index ] ) ; break ; } $ bearing1 = $ bearingCalc -> calculateBearing ( $ points [ $ index - 1 ] , $ points [ $ index ] ) ; $ bearing2 = $ bearingCalc -> calculateBearing ( $ points [ $ index ] , $ points [ $ index + 1 ] ) ; $ bearingDifference = min ( fmod ( $ bearing1 - $ bearing2 + 360 , 360 ) , fmod ( $ bearing2 - $ bearing1 + 360 , 360 ) ) ; if ( $ bearingDifference > $ this -> bearingAngle ) { $ result -> addPoint ( $ points [ $ index ] ) ; } } while ( $ index < $ counterPoints ) ; return $ result ; }
1538	public function willSeeOne ( $ request ) : bool { if ( $ this -> route -> isRelationship ( ) ) { return false ; } if ( $ this -> route -> isResource ( ) ) { return true ; } return $ request -> isMethod ( 'POST' ) ; }
5946	public function property ( $ systemName , $ preloadNames = false , $ categoryIds = null , $ deploymentSiteIds = null , $ isHierarchical = false , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'preloadNames' => $ preloadNames , 'categoryIds' => $ categoryIds , 'deploymentSiteIds' => $ deploymentSiteIds , 'isHierarchical' => $ isHierarchical , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/property/' . $ systemName . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11936	public function getPrimaryKey ( ) { $ pk = $ this -> meta -> schema -> primaryKey ; if ( is_array ( $ pk ) ) { $ ppk = [ ] ; foreach ( $ pk as $ key ) { if ( ! isset ( $ this -> attributes [ $ key ] ) ) { $ ppk [ ] = null ; } else { $ ppk [ ] = $ this -> attributes [ $ key ] ; } } return implode ( '.' , $ ppk ) ; } if ( ! isset ( $ this -> attributes [ $ pk ] ) ) { return ; } return $ this -> attributes [ $ pk ] ; }
11427	public function toObject ( ) { $ groups = $ this -> groups ; foreach ( $ groups as & $ group ) { $ group = $ group -> toObject ( ) ; } $ items = $ this -> items ; foreach ( $ items as & $ item ) { $ item = $ item -> toObject ( ) ; } return ( object ) [ 'type' => $ this -> type , 'value' => $ this -> value , 'text' => $ this -> text , 'groups' => $ groups , 'items' => $ items , ] ; }
9466	private function getServerModules ( array $ requirements ) { if ( ! function_exists ( 'apache_get_modules' ) ) { return collect ( [ ] ) ; } $ modules = apache_get_modules ( ) ; $ requirements = array_combine ( $ requirements , $ requirements ) ; return collect ( $ requirements ) -> transform ( function ( $ requirement ) use ( $ modules ) { return in_array ( $ requirement , $ modules ) ; } ) ; }
1703	protected function getLink ( $ objItem , $ strUrl , $ strBase = '' ) { switch ( $ objItem -> source ) { case 'external' : return $ objItem -> url ; break ; case 'internal' : if ( ( $ objTarget = $ objItem -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { return $ objTarget -> getAbsoluteUrl ( ) ; } break ; case 'article' : if ( ( $ objArticle = ArticleModel :: findByPk ( $ objItem -> articleId ) ) instanceof ArticleModel && ( $ objPid = $ objArticle -> getRelated ( 'pid' ) ) instanceof PageModel ) { return ampersand ( $ objPid -> getAbsoluteUrl ( '/articles/' . ( $ objArticle -> alias ? : $ objArticle -> id ) ) ) ; } break ; } if ( $ strBase != '' && ! preg_match ( '#^https?://#' , $ strUrl ) ) { $ strUrl = $ strBase . $ strUrl ; } return sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItem -> alias ? : $ objItem -> id ) ) ; }
11255	public function call ( string $ class ) : void { $ files = $ this -> all ( $ class ) ; if ( count ( $ files ) < 1 ) { throw InvalidArgumentException :: forNotFoundSeeder ( ) ; } foreach ( $ files as [ $ file , $ content ] ) { $ this -> load ( $ content ) ; $ this -> resolve ( $ file [ 'filename' ] ) -> run ( ) ; } }
2406	public static function generateStyleTag ( $ href , $ media = null , $ mtime = false ) { if ( $ mtime === null && ! preg_match ( '@^https?://@' , $ href ) ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ href ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ href ) ; } else { $ webDir = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.web_dir' ) ) ; if ( file_exists ( $ rootDir . '/' . $ webDir . '/' . $ href ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ webDir . '/' . $ href ) ; } } } if ( $ mtime ) { $ href .= '?v=' . substr ( md5 ( $ mtime ) , 0 , 8 ) ; } return '<link rel="stylesheet" href="' . $ href . '"' . ( ( $ media && $ media != 'all' ) ? ' media="' . $ media . '"' : '' ) . '>' ; }
12925	public function setSearch ( $ value ) { if ( ! is_object ( $ value ) ) { if ( ! isset ( $ value [ 'class' ] ) ) { $ value [ 'class' ] = $ this -> searchClass ; } $ value = Yii :: createObject ( $ value ) ; } $ value -> dataSource = $ this ; $ this -> _search = $ value ; }
10549	public function setApplication ( Application $ app ) { $ this -> setVariable ( 'app' , $ app ) -> setVariable ( 'path_config' , $ app -> pathConfig ) -> setVariable ( 'i18n' , $ app -> i18n ) ; try { $ this -> setVariable ( 'db' , $ app -> db ) ; } catch ( \ Wedeto \ DB \ Exception \ ConfigurationException $ db ) { } return $ this ; }
3895	protected function getMetaModel ( $ metaModelId ) { if ( null === $ this -> factory ) { throw new \ RuntimeException ( 'No factory set.' ) ; } $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; return $ metaModel ; }
2785	private function extractFail ( $ output ) { if ( preg_match ( '%##teamcity\[testFailed.*\]%' , $ output , $ matches ) ) { preg_match ( "/##teamcity\\[testFailed.*name='(.*)' message='(.*)' details='\\s*(.*)' flowId=.*/" , $ output , $ matches ) ; $ matches = $ this -> replaceEscapedChars ( $ matches ) ; $ fail = sprintf ( 'Test Name: %s' . PHP_EOL . 'Failure Message: %s' . PHP_EOL . 'Trace:' . PHP_EOL . '%s' , $ matches [ 1 ] , $ matches [ 2 ] , $ matches [ 3 ] ) ; return $ fail ; } return 'No failure output was detected by Humbug, but a failure was reported by PHPUnit.' ; }
7106	protected function calculateTotalByState ( PaymentSubjectInterface $ subject , $ state ) { PaymentStates :: isValidState ( $ state , true ) ; $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; $ total = 0 ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getState ( ) === $ state ) { $ total += $ this -> convertPaymentAmount ( $ payment , $ currency ) ; } } return $ total ; }
3855	public function setMetaTags ( $ strTitleAttribute , $ strDescriptionAttribute ) { $ this -> strDescriptionAttribute = $ strDescriptionAttribute ; $ this -> strTitleAttribute = $ strTitleAttribute ; return $ this ; }
7735	private function documentRouteAndOperations ( $ metadata , Reflector $ element ) { if ( ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Id' ) ) ) || ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Route' ) ) ) ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Operations' ) ; if ( null !== $ annotation ) { $ operations = array_unique ( $ annotation -> operations ) ; $ operationsMetadata = array_map ( array ( $ this , 'getRouteMetadata' ) , $ operations ) ; $ metadata -> setOperations ( $ operationsMetadata ) ; } if ( null !== ( $ route = $ metadata -> getRoute ( ) ) ) { $ metadata -> addOperation ( $ this -> getRouteMetadata ( $ route -> getName ( ) ) ) ; } elseif ( null !== $ annotation ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( reset ( $ annotation -> operations ) ) ) ; } if ( ( $ metadata instanceof PropertyDefinition ) && ( count ( $ operations = $ metadata -> getOperations ( ) ) > 0 ) ) { foreach ( $ operations as $ operation ) { if ( ( 'GET' === $ operation -> getMethod ( ) ) && ( null !== $ operation -> getReturns ( ) ) ) { $ metadata -> setType ( $ operation -> getReturns ( ) ) ; return ; } } $ metadata -> setType ( 'ML\HydraBundle\Entity\Resource' ) ; } }
8035	public function isMemberOf ( $ group ) { foreach ( $ this -> attributes [ 'member_of' ] as $ groups ) { if ( preg_match ( '/^CN=' . $ group . '/' , $ groups ) ) { return true ; } } return false ; }
11139	protected function getSetItem ( $ dataMember , $ offset , $ quote = true ) { $ item = $ this -> { $ dataMember } [ $ offset ] ; switch ( $ item [ 1 ] ) { case 'varchar' : $ type = 'varchar(255)' ; break ; default : $ type = $ item [ 1 ] ; } $ this -> { $ dataMember } [ $ offset ] [ 1 ] = $ type ; return $ this -> getArrayItem ( $ dataMember , $ offset , $ quote ) ; }
5593	protected function fetch ( $ url , $ encoding ) { $ request = $ this -> createRequest ( $ url , $ encoding ) ; return $ request -> fetch ( $ this -> connection_timeout ) ; }
7425	public function setSource ( $ source = '' ) { if ( ! $ this -> isValid ( $ source ) ) { throw new InvalidSourceExtensionException ( ) ; } $ this -> source = $ source ; return $ this ; }
1597	protected function validateRelationships ( ) : bool { if ( ! $ this -> dataHas ( 'relationships' ) ) { return true ; } $ relationships = $ this -> dataGet ( 'relationships' ) ; if ( ! is_object ( $ relationships ) ) { $ this -> memberNotObject ( '/data' , 'relationships' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ relationships ) { return property_exists ( $ relationships , $ field ) ; } ) ; $ valid = $ disallowed -> isEmpty ( ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'relationships' , $ disallowed ) ; foreach ( $ relationships as $ field => $ relation ) { if ( ! $ this -> validateRelationship ( $ relation , $ field ) ) { $ valid = false ; } } return $ valid ; }
3954	public function getVariants ( $ objFilter ) { if ( $ this -> isVariantBase ( ) ) { return $ this -> getMetaModel ( ) -> findVariants ( array ( $ this -> get ( 'id' ) ) , $ objFilter ) ; } return null ; }
10794	public function passwordRecovery ( array $ data ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.passwordrecovery' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ data = $ form -> getData ( ) ; $ email = isset ( $ data [ 'email' ] ) ? $ data [ 'email' ] : null ; $ user = $ userRepository -> findOneBy ( array ( 'email' => $ email ) ) ; if ( null === $ user ) { throw new \ Exception ( 'No user found' ) ; } $ userModel = $ this -> getServiceLocator ( ) -> get ( 'user.model.user' ) ; $ userModel -> init ( $ user , $ this -> getServiceLocator ( ) ) ; $ hash = $ userModel -> hashId . sha1 ( $ user -> getPassword ( ) ) ; $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ event = new PasswordRecoveryEvent ( __FUNCTION__ , null , array ( 'user' => $ user , 'form' => $ form , 'hash' => $ hash , 'email' => $ email , 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) ) ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; return $ user ; }
4591	public function setOwnerUuid ( ? string $ ownerUuid ) { if ( null !== $ ownerUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ ownerUuid ) ) { throw new InvalidArgumentException ( 'Owner uuid is not valid.' ) ; } } $ this -> ownerUuid = $ ownerUuid ; return $ this ; }
4624	public function pickNewNode ( ) { $ this -> getActiveNode ( ) -> setInactive ( true ) ; $ this -> attempts ++ ; $ this -> inactiveNodes [ $ this -> getActiveNodeIndex ( ) ] = $ this -> getActiveNode ( ) ; unset ( $ this -> nodes [ $ this -> getActiveNodeIndex ( ) ] ) ; $ this -> setActiveNodeIndex ( $ this -> pickNode ( ) ) ; return $ this ; }
3316	protected function initFromSpecString ( $ specString ) { $ pattern = '/ ( (?:[a-zA-Z0-9-]+) (?: \| (?:[a-zA-Z0-9-]+) )? ) # option attribute operators ([:+?])? # value types (?:=(boolean|string|number|date|file|dir|url|email|ip|ipv6|ipv4))? /x' ; $ ret = preg_match ( $ pattern , $ specString , $ regs ) ; if ( $ ret === false || $ ret === 0 ) { throw new Exception ( 'Incorrect spec string' ) ; } $ orig = $ regs [ 0 ] ; $ name = $ regs [ 1 ] ; $ attributes = isset ( $ regs [ 2 ] ) ? $ regs [ 2 ] : null ; $ type = isset ( $ regs [ 3 ] ) ? $ regs [ 3 ] : null ; $ short = null ; $ long = null ; if ( strpos ( $ name , '|' ) !== false ) { list ( $ short , $ long ) = explode ( '|' , $ name ) ; } else if ( strlen ( $ name ) === 1 ) { $ short = $ name ; } else if ( strlen ( $ name ) > 1 ) { $ long = $ name ; } $ this -> short = $ short ; $ this -> long = $ long ; if ( strpos ( $ attributes , ':' ) !== false ) { $ this -> required ( ) ; } else if ( strpos ( $ attributes , '+' ) !== false ) { $ this -> multiple ( ) ; } else if ( strpos ( $ attributes , '?' ) !== false ) { $ this -> optional ( ) ; } else { $ this -> flag ( ) ; } if ( $ type ) { $ this -> isa ( $ type ) ; } }
11154	public function getArrayKeyByPowers ( array $ powers ) { if ( empty ( $ powers ) ) { throw new InvalidArgumentException ( 'Empty powers set' ) ; } $ powersSum = 0 ; foreach ( $ powers as $ power ) { if ( $ power < 0 ) { throw new InvalidArgumentException ( 'Negative power found' ) ; } $ powersSum += $ power ; } if ( $ powersSum <= 0 ) { throw new InvalidArgumentException ( 'The sum of powers must be positive' ) ; } $ randomValue = $ this -> generator -> getFloat ( 0 , $ powersSum ) ; $ currentSum = 0 ; $ result = null ; foreach ( $ powers as $ key => $ power ) { $ currentSum += $ power ; if ( $ currentSum >= $ randomValue ) { $ result = $ key ; break ; } } return $ key ; }
9997	protected function inferSeparator ( ) { if ( $ this -> delimiter !== null ) { return ; } $ potentialDelimiters = [ ',' , ';' , "\t" , '|' , ':' , ' ' ] ; $ counts = [ ] ; foreach ( $ potentialDelimiters as $ delimiter ) { $ counts [ $ delimiter ] = [ ] ; } $ numberLines = 0 ; while ( ( $ line = fgets ( $ this -> fileHandle ) ) !== false && ( ++ $ numberLines < 1000 ) ) { $ enclosure = preg_quote ( $ this -> enclosure , '/' ) ; $ line = preg_replace ( '/(' . $ enclosure . '.*' . $ enclosure . ')/U' , '' , $ line ) ; $ countLine = [ ] ; for ( $ i = strlen ( $ line ) - 1 ; $ i >= 0 ; -- $ i ) { $ char = $ line [ $ i ] ; if ( isset ( $ counts [ $ char ] ) ) { if ( ! isset ( $ countLine [ $ char ] ) ) { $ countLine [ $ char ] = 0 ; } ++ $ countLine [ $ char ] ; } } foreach ( $ potentialDelimiters as $ delimiter ) { $ counts [ $ delimiter ] [ ] = isset ( $ countLine [ $ delimiter ] ) ? $ countLine [ $ delimiter ] : 0 ; } } $ meanSquareDeviations = [ ] ; $ middleIdx = floor ( ( $ numberLines - 1 ) / 2 ) ; foreach ( $ potentialDelimiters as $ delimiter ) { $ series = $ counts [ $ delimiter ] ; sort ( $ series ) ; $ median = ( $ numberLines % 2 ) ? $ series [ $ middleIdx ] : ( $ series [ $ middleIdx ] + $ series [ $ middleIdx + 1 ] ) / 2 ; if ( $ median === 0 ) { continue ; } $ meanSquareDeviations [ $ delimiter ] = array_reduce ( $ series , function ( $ sum , $ value ) use ( $ median ) { return $ sum + pow ( $ value - $ median , 2 ) ; } ) / count ( $ series ) ; } $ min = INF ; foreach ( $ potentialDelimiters as $ delimiter ) { if ( ! isset ( $ meanSquareDeviations [ $ delimiter ] ) ) { continue ; } if ( $ meanSquareDeviations [ $ delimiter ] < $ min ) { $ min = $ meanSquareDeviations [ $ delimiter ] ; $ this -> delimiter = $ delimiter ; } } if ( $ this -> delimiter === null ) { $ this -> delimiter = reset ( $ potentialDelimiters ) ; } return $ this -> skipBOM ( ) ; }
7259	protected function getRealGrossBase ( Model \ SaleInterface $ sale ) : float { $ cache = $ this -> cache ; $ this -> cache = false ; $ base = $ this -> calculateSaleItems ( $ sale ) -> getBase ( ) ; $ this -> cache = $ cache ; return $ base ; }
8130	public function addSuggestions ( $ name , array $ items ) { if ( ! $ alternatives = self :: computeAlternatives ( $ name , $ items ) ) { return ; } $ this -> appendMessage ( sprintf ( ' Did you mean "%s"?' , implode ( '", "' , $ alternatives ) ) ) ; }
9283	private function needsCompilation ( $ lessPath , $ cssPath ) { $ isNewer = function ( $ subject , $ reference ) { return filemtime ( $ subject ) > filemtime ( $ reference ) ; } ; if ( $ this -> forceCompile || ! file_exists ( $ lessPath ) || ! file_exists ( $ cssPath ) || $ isNewer ( $ lessPath , $ cssPath ) ) { return true ; } return $ this -> checkImports ( $ lessPath , $ cssPath , $ isNewer ) ; }
2570	protected static function loadNonceBase ( $ handlerParams ) { if ( empty ( $ handlerParams -> authParams -> nonceBase ) ) { $ handlerParams -> authParams -> nonceBase = SomewhatRandomGenerator :: generateSomewhatRandomString ( ) ; } return $ handlerParams ; }
6392	public static function reverseOrder ( Comparator $ comparator = null ) : Comparator { if ( $ comparator === null ) { $ comparator = ComparableComparator :: instance ( ) ; } return new ReverseComparator ( $ comparator ) ; }
7851	protected function grabParameter ( ReflectionParameter $ parameter ) { if ( isset ( $ this -> values [ $ parameter -> name ] ) ) { return $ this -> values [ $ parameter -> name ] ; } if ( $ parameter -> isDefaultValueAvailable ( ) ) { return $ parameter -> getDefaultValue ( ) ; } throw new Exception ( "Unable to map parameter [{$parameter->name}] to command [{$this->command}]" ) ; }
5138	public static function handleException ( \ Throwable $ e ) { if ( php_sapi_name ( ) == 'cli' ) { $ handler = new ConsoleHandler ( self :: $ output ) ; } else { $ handler = new HtmlHandler ( HtmlHandler :: INVERTED ) ; } fwrite ( self :: $ output , $ handler -> renderException ( $ e , AbstractHandler :: VERBOSITY_VERBOSE ) ) ; }
1232	public function offsetSet ( $ offset , $ value ) { self :: ensurePropertyType ( $ value ) ; if ( is_null ( $ offset ) ) { $ this -> data [ ] = $ value ; } else { $ this -> data [ $ offset ] = $ value ; } }
9081	private static function parseParameters ( Request & $ req , $ serverVars ) { self :: parseElement ( $ req , $ serverVars , 'HTTP_ACCEPT' , 'Accept' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_ACCEPT_LANGUAGE' , 'Accept-Language' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_ACCEPT_ENCODING' , 'Accept-Encoding' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_UA_CPU' , 'User-Agent-CPU' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_USER_AGENT' , 'User-Agent' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_HOST' , 'Host' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_CACHE_COTROL' , 'Cache-Control' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_CONNECTION' , 'Connection' ) ; self :: parseElement ( $ req , $ serverVars , 'HTTP_X_FORWARDED_FOR' , 'X-Forwarded-For' ) ; if ( isset ( $ req -> params [ 'Accept-Language' ] ) ) { $ accepted = explode ( ',' , $ req -> params [ 'Accept-Language' ] ) ; $ req -> params [ 'Accept-Language-Best' ] = $ accepted [ 0 ] ; foreach ( $ accepted as $ acceptedLang ) { $ matches = array ( ) ; if ( preg_match ( "/^((?i)[a-z]{2}[-_](?:[a-z]{2}){1,2}(?:_[a-z]{2})?).*/" , $ acceptedLang , $ matches ) ) { $ req -> params [ 'Accept-Language-Best' ] = $ matches [ 1 ] ; break ; } } } }
5521	public static function generate ( $ class , $ mock_class = false , $ methods = false ) { $ generator = new MockGenerator ( $ class , $ mock_class ) ; return $ generator -> generateSubclass ( $ methods ) ; }
9484	public function fromArray ( array $ array ) { foreach ( $ array as $ k => $ v ) { if ( ! is_null ( $ v ) && property_exists ( get_class ( $ this ) , $ k ) ) { $ meta = new \ ReflectionProperty ( get_class ( $ this ) , $ k ) ; $ info = $ this -> parsePropertyDocComment ( $ meta -> getDocComment ( ) ) ; $ type = $ info [ 'type' ] ; if ( strtolower ( $ type ) == "array" && $ elementType = $ info [ 'array_element' ] ) { if ( class_exists ( $ elementType ) ) { $ children = array ( ) ; foreach ( $ v as $ subV ) { $ newElement = new $ elementType ( ) ; $ children [ ] = $ newElement -> fromArray ( $ subV ) ; } $ this -> $ k = $ children ; } else { throw new \ Exception ( '@element Class Not Found:' . $ elementType ) ; } } else if ( class_exists ( $ type ) ) { $ typeObject = new $ type ( ) ; $ this -> $ k = $ typeObject -> fromArray ( $ v ) ; } else { $ this -> $ k = $ v ; } } } return $ this ; }
3687	protected function getAttributeFromFilterOperation ( $ operation ) { $ attribute = null ; if ( ! empty ( $ operation [ 'property' ] ) ) { $ attribute = $ this -> getMetaModel ( ) -> getAttribute ( $ operation [ 'property' ] ) ; } if ( $ attribute === null ) { throw new \ InvalidArgumentException ( 'Attribute ' . $ operation [ 'property' ] . ' not found.' ) ; } return $ attribute ; }
12236	public function insertPI ( $ target , $ data = null , $ mode = 'before' ) { $ tmp = dom_import_simplexml ( $ this ) ; $ doc = $ tmp -> ownerDocument ; if ( isset ( $ data ) ) { if ( is_array ( $ data ) ) { $ str = '' ; foreach ( $ data as $ k => $ v ) { $ str .= $ k . '="' . htmlspecialchars ( $ v ) . '" ' ; } $ data = substr ( $ str , 0 , - 1 ) ; } else { $ data = ( string ) $ data ; } $ pi = $ doc -> createProcessingInstruction ( $ target , $ data ) ; } else { $ pi = $ doc -> createProcessingInstruction ( $ target ) ; } if ( $ pi !== false ) { $ this -> insertNode ( $ tmp , $ pi , $ mode ) ; } return $ this ; }
12850	private function _checkCache ( \ stdClass $ oCache ) { $ sHearderValidity = false ; $ sHeader = "Cache-Control:" ; if ( isset ( $ oCache -> visibility ) && ( $ oCache -> visibility = 'public' || $ oCache -> visibility = 'private' ) ) { $ sHearderValidity = true ; $ sHeader .= " " . $ oCache -> visibility . "," ; } if ( isset ( $ oCache -> max_age ) ) { $ sHearderValidity = true ; $ sHeader .= " maxage=" . $ oCache -> max_age . "," ; } if ( isset ( $ oCache -> must_revalidate ) && $ oCache -> must_revalidate === true ) { $ sHearderValidity = true ; $ sHeader .= " must-revalidate," ; } if ( $ sHearderValidity === true ) { $ sHeader = substr ( $ sHeader , 0 , - 1 ) ; if ( ! headers_sent ( ) ) { header ( $ sHeader ) ; } } if ( isset ( $ oCache -> ETag ) ) { header ( "ETag: \"" . $ oCache -> ETag . "\"" ) ; } if ( isset ( $ oCache -> max_age ) ) { if ( ! headers_sent ( ) ) { header ( 'Expires: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> max_age ) . ' GMT' ) ; } } if ( isset ( $ oCache -> last_modified ) ) { if ( ! headers_sent ( ) ) { header ( 'Last-Modified: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> last_modified ) . ' GMT' ) ; } } if ( isset ( $ oCache -> vary ) ) { header ( 'Vary: ' . $ oCache -> vary ) ; } }
8395	public static function get ( ) : Logger { if ( self :: $ log == null ) { self :: $ log = new Logger ( ) ; } return self :: $ log ; }
9518	public function getUsage ( $ withEncapsulation = true , $ withAliases = true ) { $ usage = '' ; if ( $ withEncapsulation ) { $ usage = ( $ this -> required ? '' : '[' ) ; } $ aliases = ( $ withAliases ? $ this -> getAliasUsage ( ) : '' ) ; $ usage .= $ this -> prefix . $ this -> parameterName . $ aliases . ' ' ; $ usage .= $ this -> getPropertiesAsString ( ) ; return $ usage . ( $ withEncapsulation ? ( $ this -> required ? '' : ']' ) : '' ) ; }
6495	public function visitPage ( $ path , $ code = 200 ) { if ( ! $ this -> assertStatusCode ( $ path , $ code ) ) { throw new \ Exception ( sprintf ( 'The page "%s" is not accessible!' , $ path ) ) ; } self :: debug ( [ 'Visited page: %s' ] , [ $ path ] ) ; $ this -> visitPath ( $ path ) ; }
8934	public function fetch ( $ name ) { $ template = false ; if ( array_key_exists ( $ name , $ this -> templates ) ) { $ template = $ this -> templates [ $ name ] ; } return $ template ; }
2969	protected function getTableGateway ( $ tableName ) { if ( ! array_key_exists ( $ tableName , $ this -> tableGateways ) ) { $ acl = TableSchema :: getAclInstance ( ) ; $ this -> tableGateways [ $ tableName ] = new RelationalTableGateway ( $ tableName , $ this -> connection , $ acl ) ; } return $ this -> tableGateways [ $ tableName ] ; }
9477	protected function getTopDownloads ( $ limit = 20 ) { $ arrTopDownloads = array ( ) ; $ objTopDownloads = \ Database :: getInstance ( ) -> prepare ( "SELECT `tstamp`, `filename`, `downloads`, `id` FROM `tl_dlstats` ORDER BY `downloads` DESC" ) -> limit ( $ limit ) -> execute ( ) ; $ intRows = $ objTopDownloads -> numRows ; if ( $ intRows > 0 ) { while ( $ objTopDownloads -> next ( ) ) { $ c4d = $ this -> check4details ( $ objTopDownloads -> id ) ; $ arrTopDownloads [ ] = array ( $ objTopDownloads -> filename , $ this -> getFormattedNumber ( $ objTopDownloads -> downloads , 0 ) , $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'datimFormat' ] , $ objTopDownloads -> tstamp ) , $ objTopDownloads -> id , $ c4d , $ objTopDownloads -> downloads , $ objTopDownloads -> tstamp ) ; } } return $ arrTopDownloads ; }
12288	public function loop ( array $ collection , string $ block , string $ emptyBlock = null ) : string { if ( empty ( $ collection ) ) { return isset ( $ emptyBlock ) ? trim ( $ this -> make ( $ emptyBlock ) ) . PHP_EOL : PHP_EOL ; } else { $ items = '' ; foreach ( $ collection as $ key => $ item ) { $ items .= rtrim ( $ this -> make ( $ block , [ 'key' => $ key , 'item' => $ item ] ) ) ; } return ltrim ( $ items ) . PHP_EOL ; } }
7225	public function content ( $ decodeJson = false ) { return $ decodeJson && preg_match ( "~^application/json.*~" , $ this -> lastResultType ) && $ this -> lastResult ? from_json ( $ this -> lastResult ) : $ this -> lastResult ; }
10711	public function getManyByIds ( array $ ids , $ columns = [ '*' ] ) { $ results = $ this -> getQuery ( ) -> findMany ( $ ids , $ columns ) ; return $ this -> returnResults ( $ results ) ; }
496	public function getDbProfiling ( ) { $ timings = $ this -> getProfiling ( [ 'yii\db\Command::query' , 'yii\db\Command::execute' ] ) ; $ count = count ( $ timings ) ; $ time = 0 ; foreach ( $ timings as $ timing ) { $ time += $ timing [ 'duration' ] ; } return [ $ count , $ time ] ; }
8846	public function getBlogPosts ( ) { $ blogPosts = BlogPost :: get ( ) -> filter ( "ParentID" , $ this -> ID ) ; $ this -> extend ( 'updateGetBlogPosts' , $ blogPosts ) ; return $ blogPosts ; }
847	public function getNextTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , 1 , $ tokens , $ caseSensitive ) ; }
1009	public static function defaultFieldResolver ( $ source , $ args , $ context , ResolveInfo $ info ) { $ fieldName = $ info -> fieldName ; $ property = null ; if ( is_array ( $ source ) || $ source instanceof ArrayAccess ) { if ( isset ( $ source [ $ fieldName ] ) ) { $ property = $ source [ $ fieldName ] ; } } elseif ( is_object ( $ source ) ) { if ( isset ( $ source -> { $ fieldName } ) ) { $ property = $ source -> { $ fieldName } ; } } return $ property instanceof Closure ? $ property ( $ source , $ args , $ context , $ info ) : $ property ; }
532	protected function resortChangelog ( $ changelog ) { foreach ( $ changelog as $ i => $ line ) { $ changelog [ $ i ] = rtrim ( $ line ) ; } $ changelog = array_filter ( $ changelog ) ; $ i = 0 ; ArrayHelper :: multisort ( $ changelog , function ( $ line ) use ( & $ i ) { if ( preg_match ( '/^- (Chg|Enh|Bug|New)( #\d+(, #\d+)*)?: .+/' , $ line , $ m ) ) { $ o = [ 'Bug' => 'C' , 'Enh' => 'D' , 'Chg' => 'E' , 'New' => 'F' ] ; return $ o [ $ m [ 1 ] ] . ' ' . ( ! empty ( $ m [ 2 ] ) ? $ m [ 2 ] : 'AAAA' . $ i ++ ) ; } return 'B' . $ i ++ ; } , SORT_ASC , SORT_NATURAL ) ; array_unshift ( $ changelog , '' ) ; $ changelog [ ] = '' ; $ changelog [ ] = '' ; return $ changelog ; }
12819	public static function setPermission ( array $ paths ) { foreach ( $ paths as $ path => $ permission ) { echo "chmod('$path', $permission)..." ; if ( is_dir ( $ path ) || is_file ( $ path ) ) { chmod ( $ path , octdec ( $ permission ) ) ; echo "done.\n" ; } else { echo "file not found.\n" ; } } }
5609	public function paintGroupStart ( $ message , $ size ) { parent :: paintGroupStart ( $ message , $ size ) ; $ node = new TreemapNode ( 'Group' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
749	public function load ( $ filePath , $ context ) { $ pattern = '/(msgctxt\s+"(.*?(?<!\\\\))")?\s+' . 'msgid\s+((?:".*(?<!\\\\)"\s*)+)\s+' . 'msgstr\s+((?:".*(?<!\\\\)"\s*)+)/' ; $ content = file_get_contents ( $ filePath ) ; $ matches = [ ] ; $ matchCount = preg_match_all ( $ pattern , $ content , $ matches ) ; $ messages = [ ] ; for ( $ i = 0 ; $ i < $ matchCount ; ++ $ i ) { if ( $ matches [ 2 ] [ $ i ] === $ context ) { $ id = $ this -> decode ( $ matches [ 3 ] [ $ i ] ) ; $ message = $ this -> decode ( $ matches [ 4 ] [ $ i ] ) ; $ messages [ $ id ] = $ message ; } } return $ messages ; }
7805	protected function openingBalance ( $ text ) { if ( $ line = $ this -> getLine ( '60F|60M' , $ text ) ) { return $ this -> balance ( $ this -> reader -> createOpeningBalance ( ) , $ line ) ; } }
6340	public function SearchForm ( ) { if ( count ( Searchable :: config ( ) -> objects ) ) { $ searchText = "" ; if ( $ this -> owner -> request && $ this -> owner -> request -> getVar ( 'Search' ) ) { $ searchText = $ this -> owner -> request -> getVar ( 'Search' ) ; } $ fields = FieldList :: create ( TextField :: create ( 'Search' , false , $ searchText ) -> setAttribute ( "placeholder" , _t ( 'Searchable.Search' , 'Search' ) ) ) ; $ actions = FieldList :: create ( FormAction :: create ( 'results' , _t ( 'Searchable.Go' , 'Go' ) ) ) ; $ template_class = Searchable :: config ( ) -> template_class ; $ results_page = Injector :: inst ( ) -> create ( $ template_class ) ; $ form = Form :: create ( $ this -> owner , 'SearchForm' , $ fields , $ actions ) -> setFormMethod ( 'get' ) -> setFormAction ( $ results_page -> Link ( ) ) -> setTemplate ( 'ilateral\SilverStripe\Searchable\Includes\SearchForm' ) -> disableSecurityToken ( ) ; $ this -> owner -> extend ( "updateSearchForm" , $ form ) ; return $ form ; } }
4828	public function create_bill ( $ attrs ) { if ( ! isset ( $ attrs [ 'amount' ] ) ) { throw new GoCardless_ArgumentsException ( 'Amount required' ) ; } $ params = array ( 'bill' => array ( 'amount' => $ attrs [ 'amount' ] , 'pre_authorization_id' => $ this -> id ) ) ; if ( isset ( $ attrs [ 'name' ] ) ) { $ params [ 'bill' ] [ 'name' ] = $ attrs [ 'name' ] ; } if ( isset ( $ attrs [ 'description' ] ) ) { $ params [ 'bill' ] [ 'description' ] = $ attrs [ 'description' ] ; } if ( isset ( $ attrs [ 'charge_customer_at' ] ) ) { $ params [ 'bill' ] [ 'charge_customer_at' ] = $ attrs [ 'charge_customer_at' ] ; } $ endpoint = GoCardless_Bill :: $ endpoint ; return new GoCardless_Bill ( $ this -> client , $ this -> client -> request ( 'post' , $ endpoint , $ params ) ) ; }
6614	protected function validateSettings ( $ settings ) { if ( ! is_array ( $ settings ) ) { throw new InvalidProviderSettingsException ( ) ; } $ intersection = array_intersect ( array_keys ( $ settings ) , $ this -> mandatory ) ; return count ( $ intersection ) === count ( $ this -> mandatory ) ; }
12490	public static function select ( $ select ) { if ( gettype ( $ select ) == "array" ) { foreach ( $ select as $ key => $ field ) { if ( $ field instanceof Key ) { $ alias = '"' . $ field . '"' ; $ field = self :: field ( $ field ) ; $ select [ $ key ] = "{$field} as {$alias}" ; } } $ select = implode ( ", " , $ select ) ; } elseif ( gettype ( $ select ) != "string" ) { throw new ClusterpointException ( "\"->select()\" function: passed parametr is not in valid format." , 9002 ) ; } return $ select ; }
5369	protected function isOnlyAscii ( $ ascii ) { for ( $ i = 0 , $ length = strlen ( $ ascii ) ; $ i < $ length ; $ i ++ ) { if ( ord ( $ ascii [ $ i ] ) > 127 ) { return false ; } } return true ; }
7538	function getRoot ( ) { $ r = $ this -> parent ; $ n = ( $ r === null ) ? null : $ r -> parent ; while ( $ n !== null ) { $ r = $ n ; $ n = $ r -> parent ; } return $ r ; }
4146	protected function getUrl ( ) { $ domain = $ this -> urls [ 'domain' ] ; $ apiVersion = $ this -> urls [ 'api' ] ; $ jsonExt = '.json' ; if ( isset ( $ this -> withMedia ) && $ this -> withMedia === true ) { $ domain = $ this -> urls [ 'upload' ] ; } if ( $ this -> call === 'oauth/request_token' || $ this -> call === 'oauth/access_token' ) { $ apiVersion = '' ; $ jsonExt = '' ; } return $ domain . $ apiVersion . $ this -> call . $ jsonExt ; }
12786	public function getConfig ( ) { return [ 'form_elements' => [ 'aliases' => [ 'checkbox' => Element \ Checkbox :: class , 'Checkbox' => Element \ Checkbox :: class , 'ckeditor' => Element \ CkEditor :: class , 'ckEditor' => Element \ CkEditor :: class , 'CkEditor' => Element \ CkEditor :: class , 'csrf' => Element \ Csrf :: class , 'Csrf' => Element \ Csrf :: class , 'date' => Element \ Date :: class , 'Date' => Element \ Date :: class , 'datetime' => Element \ DateTime :: class , 'dateTime' => Element \ DateTime :: class , 'DateTime' => Element \ DateTime :: class , 'email' => Element \ Email :: class , 'Email' => Element \ Email :: class , 'multipleinput' => Element \ MultipleInput :: class , 'multipleInput' => Element \ MultipleInput :: class , 'MultipleInput' => Element \ MultipleInput :: class , 'password' => Element \ Password :: class , 'Password' => Element \ Password :: class , 'rangefilter' => Element \ RangeFilter :: class , 'rangeFilter' => Element \ RangeFilter :: class , 'RangeFilter' => Element \ RangeFilter :: class , 'time' => Element \ Time :: class , 'Time' => Element \ Time :: class , 'timezoneselect' => Element \ TimeZoneSelect :: class , 'timezoneSelect' => Element \ TimeZoneSelect :: class , 'TimezoneSelect' => Element \ TimeZoneSelect :: class , 'username' => Element \ Username :: class , 'Username' => Element \ Username :: class , 'yesnoselect' => Element \ YesNoSelect :: class , 'yesNoSelect' => Element \ YesNoSelect :: class , 'YesNoSelect' => Element \ YesNoSelect :: class ] , 'factories' => [ Element \ Checkbox :: class => ElementFactory :: class , Element \ CkEditor :: class => ElementFactory :: class , Element \ Csrf :: class => ElementFactory :: class , Element \ Date :: class => ElementFactory :: class , Element \ DateTime :: class => ElementFactory :: class , Element \ Email :: class => ElementFactory :: class , Element \ MultipleInput :: class => ElementFactory :: class , Element \ Password :: class => ElementFactory :: class , Element \ RangeFilter :: class => ElementFactory :: class , Element \ Time :: class => ElementFactory :: class , Element \ TimeZoneSelect :: class => ElementFactory :: class , Element \ Username :: class => ElementFactory :: class , Element \ YesNoSelect :: class => ElementFactory :: class ] ] ] ; }
5820	protected function transformFiles ( $ files ) { $ result = [ ] ; foreach ( $ files as $ file ) { $ result [ ] = [ 'type' => $ file [ 'content_type' ] === 'application/directory' ? 'dir' : 'file' , 'path' => $ file [ 'name' ] , 'size' => intval ( $ file [ 'bytes' ] ) , 'timestamp' => strtotime ( $ file [ 'last_modified' ] ) , 'mimetype' => $ file [ 'content_type' ] , ] ; } return $ result ; }
10522	protected function quoteIndex ( array $ cols ) { $ q = [ ] ; foreach ( $ cols as $ col ) { $ q [ ] = $ this -> quoteLeading ( $ col ) ; } return $ q ; }
9381	public function set ( $ id , $ concrete , $ share = false ) { return $ this -> add ( $ id , $ concrete , $ share ) ; }
3843	private function parsePanelSearch ( PanelRowInterface $ row ) { if ( $ row -> hasElement ( 'search' ) ) { $ element = $ row -> getElement ( 'search' ) ; } else { $ element = new DefaultSearchElementInformation ( ) ; } if ( ! $ element instanceof SearchElementInformationInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'search' ] ) ) { $ element -> addProperty ( $ value [ 'col_name' ] ) ; } } if ( $ element -> getPropertyNames ( ) && ! $ row -> hasElement ( 'search' ) ) { $ row -> addElement ( $ element ) ; } }
10251	public function getFirstName ( $ gender = null ) { if ( empty ( $ gender ) ) { $ gender = $ this -> getGender ( ) ; } return FirstName :: where ( 'gender' , $ gender ) -> where ( 'rank' , '<=' , 250 ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; }
407	public function getBodyParams ( ) { if ( $ this -> _bodyParams === null ) { if ( isset ( $ _POST [ $ this -> methodParam ] ) ) { $ this -> _bodyParams = $ _POST ; unset ( $ this -> _bodyParams [ $ this -> methodParam ] ) ; return $ this -> _bodyParams ; } $ rawContentType = $ this -> getContentType ( ) ; if ( ( $ pos = strpos ( $ rawContentType , ';' ) ) !== false ) { $ contentType = substr ( $ rawContentType , 0 , $ pos ) ; } else { $ contentType = $ rawContentType ; } if ( isset ( $ this -> parsers [ $ contentType ] ) ) { $ parser = Yii :: createObject ( $ this -> parsers [ $ contentType ] ) ; if ( ! ( $ parser instanceof RequestParserInterface ) ) { throw new InvalidConfigException ( "The '$contentType' request parser is invalid. It must implement the yii\\web\\RequestParserInterface." ) ; } $ this -> _bodyParams = $ parser -> parse ( $ this -> getRawBody ( ) , $ rawContentType ) ; } elseif ( isset ( $ this -> parsers [ '*' ] ) ) { $ parser = Yii :: createObject ( $ this -> parsers [ '*' ] ) ; if ( ! ( $ parser instanceof RequestParserInterface ) ) { throw new InvalidConfigException ( 'The fallback request parser is invalid. It must implement the yii\\web\\RequestParserInterface.' ) ; } $ this -> _bodyParams = $ parser -> parse ( $ this -> getRawBody ( ) , $ rawContentType ) ; } elseif ( $ this -> getMethod ( ) === 'POST' ) { $ this -> _bodyParams = $ _POST ; } else { $ this -> _bodyParams = [ ] ; mb_parse_str ( $ this -> getRawBody ( ) , $ this -> _bodyParams ) ; } } return $ this -> _bodyParams ; }
11273	public function sendRequest ( RequestInterface $ request ) { $ this -> lastOperation = new Operation ( $ request ) ; $ response = parent :: sendRequest ( $ request ) ; $ this -> lastOperation -> setResponse ( $ response ) ; return $ response ; }
3314	protected function request ( $ url , $ images , array $ options = [ ] , $ requestType = false ) { $ http = ( new Http ) -> setHeaders ( [ 'Authorization' => $ this -> authorization -> getAuthorization ( ) ] ) ; $ image = is_array ( $ images ) ? $ images [ 0 ] : $ images ; $ urlName = $ requestType ? 'url_list' : 'url' ; if ( FileConverter :: isUrl ( $ image ) ) { $ isurl = true ; } else { $ isurl = false ; $ multiparts [ 'image' ] [ ] = $ image ; } $ options = $ this -> appendAppIdAndBucketIfEmpty ( $ options ) ; try { if ( $ isurl ) { $ response = $ http -> json ( $ url , array_merge ( $ options , [ $ urlName => $ image ] ) ) ; } else { $ response = $ http -> upload ( $ url , $ multiparts , $ options ) ; } } catch ( \ GuzzleHttp \ Exception \ ClientException $ e ) { if ( $ e -> hasResponse ( ) ) { $ response = $ e -> getResponse ( ) ; } } return $ http -> parseJson ( $ response ) ; }
8095	public function add ( ) { if ( ! headers_sent ( ) ) { $ added = setcookie ( $ this -> name , $ this -> value , round ( time ( ) + 60 * 60 * 24 * $ this -> lifetime ) , $ this -> path , $ this -> host ) ; } else { echo "<script>" ; echo ' function setCookie(c_name,value,expiredays){ var exdate=new Date(); exdate.setDate(exdate.getDate()+expiredays); document.cookie=c_name+ "=" +escape(value)+((expiredays==null) ? "" : "; expires="+exdate.toUTCString()) + "; domain="+ escape("' . $ this -> host . '") + "; path=" + escape("' . $ this -> path . '"); } ' ; echo "setCookie('{$this->name}','{$this->value}',{$this->lifetime})" ; echo "</script>" ; $ added = true ; } return $ added ; }
5124	private function castToArray ( $ input ) : array { $ result = array ( ) ; foreach ( $ input as $ key => $ value ) { $ result [ $ key ] = $ this -> castValue ( $ value ) ; } return $ result ; }
2402	public function previewRoute ( $ strName , $ arrParams = array ( ) ) { $ objRouter = System :: getContainer ( ) -> get ( 'router' ) ; $ objContext = $ objRouter -> getContext ( ) ; $ objPreviewContext = clone $ objContext ; $ objPreviewContext -> setBaseUrl ( '/preview.php' ) ; $ objRouter -> setContext ( $ objPreviewContext ) ; $ strUrl = $ objRouter -> generate ( $ strName , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; $ objRouter -> setContext ( $ objContext ) ; return ampersand ( $ strUrl ) ; }
11261	public function add ( MethodInterface $ method ) { if ( $ this -> isUnique ( $ method ) ) { $ this -> collection [ ] = $ method ; } else { throw new ExtDirectException ( "Remotable methodname {$method->getAnnotatedName()} already exists, but have to be unique" ) ; } }
9410	protected function collect ( ) { $ collector = new RouteCollector ; foreach ( $ this -> router -> routes ( ) as $ route ) { $ collector -> addRoute ( $ route [ 0 ] , $ route [ 1 ] , $ route [ 2 ] ) ; } return $ collector -> getData ( ) ; }
10177	public function cloneCellCollection ( Worksheet $ parent ) { $ this -> storeCurrentCell ( ) ; $ newCollection = clone $ this ; $ newCollection -> parent = $ parent ; if ( ( $ newCollection -> currentCell !== null ) && ( is_object ( $ newCollection -> currentCell ) ) ) { $ newCollection -> currentCell -> attach ( $ this ) ; } $ oldKeys = $ newCollection -> getAllCacheKeys ( ) ; $ oldValues = $ newCollection -> cache -> getMultiple ( $ oldKeys ) ; $ newValues = [ ] ; $ oldCachePrefix = $ newCollection -> cachePrefix ; $ newCollection -> cachePrefix = $ newCollection -> getUniqueID ( ) ; foreach ( $ oldValues as $ oldKey => $ value ) { $ newValues [ str_replace ( $ oldCachePrefix , $ newCollection -> cachePrefix , $ oldKey ) ] = clone $ value ; } $ stored = $ newCollection -> cache -> setMultiple ( $ newValues ) ; if ( ! $ stored ) { $ newCollection -> __destruct ( ) ; throw new PhpSpreadsheetException ( 'Failed to copy cells in cache' ) ; } return $ newCollection ; }
9508	public function showByLevel ( Log $ log , $ level ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_SHOW ) ; if ( $ level == 'all' ) return redirect ( ) -> route ( 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ this -> logViewer -> entries ( $ log -> date , $ level ) -> paginate ( $ this -> perPage ) ; $ this -> addBreadcrumbRoute ( trans ( 'foundation::log-viewer.titles.logs-list' ) , 'admin::foundation.system.log-viewer.logs.list' ) ; $ this -> setTitle ( $ log -> date . ' | ' . ucfirst ( $ level ) ) ; $ this -> addBreadcrumbRoute ( $ log -> date , 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ this -> addBreadcrumb ( ucfirst ( $ level ) ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'entries' , 'level' ) ) ; }
8652	private function convertGetReportScheduleCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportScheduleCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
1068	private function collectConflictsBetween ( ValidationContext $ context , array & $ conflicts , $ parentFieldsAreMutuallyExclusive , array $ fieldMap1 , array $ fieldMap2 ) { foreach ( $ fieldMap1 as $ responseName => $ fields1 ) { if ( ! isset ( $ fieldMap2 [ $ responseName ] ) ) { continue ; } $ fields2 = $ fieldMap2 [ $ responseName ] ; $ fields1Length = count ( $ fields1 ) ; $ fields2Length = count ( $ fields2 ) ; for ( $ i = 0 ; $ i < $ fields1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fields2Length ; $ j ++ ) { $ conflict = $ this -> findConflict ( $ context , $ parentFieldsAreMutuallyExclusive , $ responseName , $ fields1 [ $ i ] , $ fields2 [ $ j ] ) ; if ( ! $ conflict ) { continue ; } $ conflicts [ ] = $ conflict ; } } } }
437	protected function compareValues ( $ operator , $ type , $ value , $ compareValue ) { if ( $ type === self :: TYPE_NUMBER ) { $ value = ( float ) $ value ; $ compareValue = ( float ) $ compareValue ; } else { $ value = ( string ) $ value ; $ compareValue = ( string ) $ compareValue ; } switch ( $ operator ) { case '==' : return $ value == $ compareValue ; case '===' : return $ value === $ compareValue ; case '!=' : return $ value != $ compareValue ; case '!==' : return $ value !== $ compareValue ; case '>' : return $ value > $ compareValue ; case '>=' : return $ value >= $ compareValue ; case '<' : return $ value < $ compareValue ; case '<=' : return $ value <= $ compareValue ; default : return false ; } }
7384	private function generateString ( ) { $ this -> generateNumbers ( ) ; $ this -> adjective = $ this -> adjectives [ $ this -> first ] ; $ this -> animal = $ this -> animals [ $ this -> second ] ; switch ( $ this -> case ) { case 'ucfirst' : $ this -> string = ucfirst ( $ this -> adjective . $ this -> animal . $ this -> number ) ; break ; case 'ucwords' : case 'sentence' : $ this -> string = ucfirst ( $ this -> adjective ) . ucfirst ( $ this -> animal ) . ucfirst ( $ this -> number ) ; break ; case 'camel' : $ this -> string = $ this -> adjective . ucfirst ( $ this -> animal ) . $ this -> number ; break ; default : $ this -> string = $ this -> adjective . $ this -> animal . $ this -> number ; break ; } }
5449	public function acceptEndToken ( $ token , $ event ) { if ( ! preg_match ( '/<\/(.*)>/' , $ token , $ matches ) ) { return false ; } return $ this -> listener -> endElement ( strtolower ( $ matches [ 1 ] ) ) ; }
11009	public function addPluginType ( string $ mediaType ) : bool { if ( ! preg_match ( '#^[-\w]+/[-\w]+$#ui' , $ mediaType ) ) { throw new MiddlewareException ( $ this , sprintf ( "'%s' is not a valid media type and can not be used as a CSP plugin type" , $ mediaType ) ) ; } if ( ! in_array ( $ mediaType , $ this -> tags [ 'plugin-types' ] ) ) { $ this -> tags [ 'plugin-types' ] [ ] = $ mediaType ; return true ; } return false ; }
2493	protected function getRange ( $ operator , $ start , $ end ) { $ startBrace = '[' ; $ startValue = '*' ; $ endValue = '*' ; $ endBrace = ']' ; $ start = '"' . $ this -> escapeQuote ( $ this -> toString ( $ start ) , true ) . '"' ; $ end = '"' . $ this -> escapeQuote ( $ this -> toString ( $ end ) , true ) . '"' ; switch ( $ operator ) { case Operator :: GT : $ startBrace = '{' ; $ endBrace = '}' ; case Operator :: GTE : $ startValue = $ start ; break ; case Operator :: LT : $ startBrace = '{' ; $ endBrace = '}' ; case Operator :: LTE : $ endValue = $ end ; break ; case Operator :: BETWEEN : $ startValue = $ start ; $ endValue = $ end ; break ; default : throw new \ RuntimeException ( "Unknown operator: $operator" ) ; } return "$startBrace$startValue TO $endValue$endBrace" ; }
3400	protected function makeRequest ( $ arguments = [ ] ) { $ defaults = $ this -> getDefaultOptions ( ) ; $ arguments = array_merge ( $ defaults , $ arguments ) ; $ client = $ this -> resource -> getGuzzle ( ) ; $ request = $ client -> createRequest ( $ this -> getMethod ( ) , $ this -> url , $ arguments ) ; $ response = $ client -> send ( $ request ) ; $ this -> setResponse ( $ response ) ; $ this -> setContent ( ( string ) $ response -> getBody ( ) ) ; }
1420	protected function pointer ( string $ path , ? string $ member = null ) : array { $ withoutMember = is_null ( $ member ) || '' === $ member ; $ pointer = ! $ withoutMember ? sprintf ( '%s/%s' , rtrim ( $ path , '/' ) , $ member ) : $ path ; return [ Error :: SOURCE_POINTER => $ pointer ] ; }
3640	public function all ( bool $ trim = true , bool $ clean = true ) { $ values = $ this -> request -> all ( ) ; return $ this -> clean ( $ values , $ trim , $ clean ) ; }
7840	public function addNumber ( int $ id , string $ number ) : ? array { $ response = Request :: put ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
6192	protected function loadRoutes ( $ path ) { $ this -> app -> config [ 'router' ] [ 'routes' ] = array_merge ( $ this -> app -> config [ 'router' ] [ 'routes' ] ?? [ ] , ( require $ path ) [ 'routes' ] ) ; }
10297	private function writeTitle ( XMLWriter $ objWriter , Title $ title = null ) { if ( $ title === null ) { return ; } $ objWriter -> startElement ( 'c:title' ) ; $ objWriter -> startElement ( 'c:tx' ) ; $ objWriter -> startElement ( 'c:rich' ) ; $ objWriter -> startElement ( 'a:bodyPr' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:lstStyle' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:p' ) ; $ caption = $ title -> getCaption ( ) ; if ( ( is_array ( $ caption ) ) && ( count ( $ caption ) > 0 ) ) { $ caption = $ caption [ 0 ] ; } $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichTextForCharts ( $ objWriter , $ caption , 'a' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writeLayout ( $ objWriter , $ title -> getLayout ( ) ) ; $ objWriter -> startElement ( 'c:overlay' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
6141	public function checkPass ( $ password = null ) { if ( $ password === null ) { $ password = $ this -> pass ; } if ( strlen ( $ password ) == 0 ) { return true ; } $ pattern = "/^(" . $ this -> regex [ "alphanum" ] . "|" . $ this -> regex [ "mark" ] . "|" . $ this -> regex [ "escaped" ] . "|[;:&=+$,])+$/" ; $ status = @ preg_match ( $ pattern , $ password ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI password validation failed" ) ; } return ( $ status == 1 ) ; }
5161	public function attach ( string $ field , Model $ item ) : self { $ this -> attachment [ $ field ] [ ] = $ item ; return $ this ; }
12116	public static function getShortName ( $ fqn ) { $ fqn_parts = explode ( '\\' , $ fqn ) ; $ final = array_pop ( $ fqn_parts ) ; if ( empty ( $ fqn_parts ) ) { return $ final ; } $ fqn_caps = preg_replace ( '/[a-z]+/' , '' , $ fqn_parts ) ; return implode ( '\\' , $ fqn_caps ) . '\\' . $ final ; }
324	public static function camel2words ( $ name , $ ucwords = true ) { $ label = mb_strtolower ( trim ( str_replace ( [ '-' , '_' , '.' , ] , ' ' , preg_replace ( '/(?<!\p{Lu})(\p{Lu})|(\p{Lu})(?=\p{Ll})/u' , ' \0' , $ name ) ) ) , self :: encoding ( ) ) ; return $ ucwords ? StringHelper :: mb_ucwords ( $ label , self :: encoding ( ) ) : $ label ; }
5488	public function submit ( $ additional = false ) { $ encoding = $ this -> encode ( ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; }
11472	public function update ( ResponseRequest $ request , Response $ response ) { try { $ attributes = $ request -> all ( ) ; $ id = $ attributes [ 'question_id' ] ; $ question = $ this -> question -> selectquestion ( $ id ) ; $ response -> update ( $ attributes ) ; return redirect ( '/discussion/' . $ question [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/response/' . $ response -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
5870	protected static function getBasicMetadata ( $ fileName ) { $ extension = strtolower ( substr ( $ fileName , strrpos ( $ fileName , '.' ) + 1 ) ) ; $ metadata = [ ] ; if ( GeneralUtility :: inList ( 'jpg,jpeg,tif,tiff' , $ extension ) && function_exists ( 'exif_read_data' ) ) { $ exif = @ exif_read_data ( $ fileName ) ; if ( $ exif ) { $ metadata = $ exif ; $ metadata [ 'ImageDescription' ] = static :: safeUtf8Encode ( $ metadata [ 'ImageDescription' ] ) ; if ( isset ( $ metadata [ 'GPSLatitude' ] ) && is_array ( $ metadata [ 'GPSLatitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLatitudeRef' ] ) ? $ metadata [ 'GPSLatitudeRef' ] : 'N' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLatitude' ] ) ; $ decimal *= $ reference === 'N' ? 1 : - 1 ; $ metadata [ 'GPSLatitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSLongitude' ] ) && is_array ( $ metadata [ 'GPSLongitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLongitudeRef' ] ) ? $ metadata [ 'GPSLongitudeRef' ] : 'E' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLongitude' ] ) ; $ decimal *= $ reference === 'E' ? 1 : - 1 ; $ metadata [ 'GPSLongitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSAltitude' ] ) ) { $ rationalParts = explode ( '/' , $ metadata [ 'GPSAltitude' ] ) ; if ( ! empty ( $ rationalParts [ 1 ] ) ) { $ metadata [ 'GPSAltitudeDecimal' ] = $ rationalParts [ 0 ] / $ rationalParts [ 1 ] ; } else { $ metadata [ 'GPSAltitudeDecimal' ] = 0 ; } } } $ imageinfo = [ ] ; if ( function_exists ( 'iptcparse' ) && getimagesize ( $ fileName , $ imageinfo ) ) { if ( isset ( $ imageinfo [ 'APP13' ] ) ) { $ data = iptcparse ( $ imageinfo [ 'APP13' ] ) ; $ mapping = [ '2#005' => 'Title' , '2#025' => 'Keywords' , '2#040' => 'Instructions' , '2#080' => 'Creator' , '2#085' => 'CreatorFunction' , '2#090' => 'City' , '2#092' => 'Location' , '2#095' => 'Region' , '2#100' => 'CountryCode' , '2#101' => 'Country' , '2#103' => 'IdentifierWork' , '2#105' => 'CreatorTitle' , '2#110' => 'Credit' , '2#115' => 'Source' , '2#116' => 'Copyright' , '2#120' => 'Description' , '2#122' => 'DescriptionAuthor' , ] ; foreach ( $ mapping as $ iptcKey => $ metadataKey ) { if ( isset ( $ data [ $ iptcKey ] ) ) { $ metadata [ 'IPTC' . $ metadataKey ] = static :: safeUtf8Encode ( $ data [ $ iptcKey ] [ 0 ] ) ; } } } } } return $ metadata ; }
1711	public function setEmptyEndTime ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue === null ) { $ varValue = $ dc -> activeRecord -> startTime ; } return $ varValue ; }
12928	public function update ( $ poiId , array $ data ) { $ data = array_merge ( $ data , [ 'poi_id' => $ poiId ] ) ; $ params = [ 'business' => [ 'base_info' => $ data ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
11425	public function remark ( $ openId , $ remark ) { $ params = [ 'openid' => $ openId , 'remark' => $ remark , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_REMARK , $ params ] ) ; }
9383	public function getClassName ( $ identifier , $ args = [ ] ) { if ( isset ( $ this -> classes [ $ identifier ] ) ) { return $ args ? vsprintf ( $ this -> classes [ $ identifier ] , $ args ) : $ this -> classes [ $ identifier ] ; } }
8485	public static function getCpuModel ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT Name FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> Name ; } return 'Unknown' ; }
11671	public function executeRaw ( array $ arguments , & $ error = null ) { $ error = false ; $ commandID = array_shift ( $ arguments ) ; $ response = $ this -> connection -> executeCommand ( new RawCommand ( $ commandID , $ arguments ) ) ; if ( $ response instanceof ResponseInterface ) { if ( $ response instanceof ErrorResponseInterface ) { $ error = true ; } return ( string ) $ response ; } return $ response ; }
8484	public static function getHostname ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Name FROM Win32_ComputerSystem" ) as $ cs ) { return $ cs -> Name ; } return "Unknown" ; }
12083	public function getAllMedia ( $ objectType = 'media' , $ objectURI = NULL , $ objectId = NULL ) { $ objects = $ this -> getMediaObjectsList ( $ objectType , $ objectURI , $ objectId ) -> fetchAll ( ) ; $ items = array ( ) ; foreach ( $ objects as $ i => $ object ) { $ object = $ this -> getOwner ( $ object , $ object [ 'media_owner' ] ) ; if ( $ object [ 'object_type' ] === "attachment" ) : $ object [ 'media_object' ] = $ object [ 'object_uri' ] ; if ( empty ( $ object [ 'media_title' ] ) ) : $ object [ 'media_title' ] = $ object [ 'attachment_name' ] ; endif ; endif ; $ object [ 'media_comment_target' ] = $ object [ 'object_uri' ] ; $ object [ 'media_published' ] = $ object [ 'object_created_on' ] ; $ items [ ] = $ object ; } $ mediacollections = new Collection ( ) ; $ mediacollections :: set ( "items" , $ items ) ; $ mediacollections :: set ( "totalItems" , count ( $ items ) ) ; $ collection = $ mediacollections :: getArray ( ) ; return $ collection ; }
5528	protected function createCodeForMethods ( $ methods ) { $ code = '' ; $ methods = array_merge ( $ methods , $ this -> reflection -> getMethods ( ) ) ; foreach ( $ methods as $ method ) { if ( $ this -> isConstructorOrDeconstructor ( $ method ) ) { continue ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_base ) ; if ( in_array ( $ method , $ mock_reflection -> getMethods ( ) ) ) { continue ; } $ code .= ' ' . $ this -> reflection -> getSignature ( $ method ) ; if ( $ mock_reflection -> isAbstract ( ) ) { $ code .= ";\n" ; } else { $ code .= " {\n" ; $ code .= " return \$this->invoke(\"$method\", func_get_args());\n" ; $ code .= " }\n" ; } } return $ code ; }
3589	protected function saveMeta ( ) { foreach ( $ this -> getMetaAttributes ( ) as $ attribute ) { if ( is_null ( $ attribute -> getValue ( ) ) ) { $ attribute -> delete ( ) ; } else { $ this -> metaAttributes ( ) -> save ( $ attribute ) ; } } }
11340	public function generateRules ( $ table ) { $ types = [ ] ; $ lengths = [ ] ; foreach ( $ table -> columns as $ column ) { if ( $ column -> autoIncrement ) { continue ; } if ( ! $ column -> allowNull && $ column -> defaultValue === null && ! $ column -> isPrimaryKey ) { $ types [ 'required' ] [ ] = $ column -> name ; } switch ( $ column -> type ) { case Schema :: TYPE_SMALLINT : case Schema :: TYPE_INTEGER : case Schema :: TYPE_BIGINT : $ types [ 'integer' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_BOOLEAN : $ types [ 'boolean' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_FLOAT : case Schema :: TYPE_DECIMAL : case Schema :: TYPE_MONEY : $ types [ 'number' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_DATE : case Schema :: TYPE_TIME : case Schema :: TYPE_DATETIME : case Schema :: TYPE_TIMESTAMP : if ( ! in_array ( $ column -> name , [ 'created' , 'deleted' , 'modified' ] ) ) { $ types [ 'safe' ] [ ] = $ column -> name ; } break ; default : if ( $ column -> size > 0 ) { $ lengths [ $ column -> size ] [ ] = $ column -> name ; } else { $ types [ 'string' ] [ ] = $ column -> name ; } } } $ rules = [ ] ; foreach ( $ types as $ type => $ columns ) { $ rules [ ] = "[['" . implode ( "', '" , $ columns ) . "'], '$type']" ; } foreach ( $ lengths as $ length => $ columns ) { $ rules [ ] = "[['" . implode ( "', '" , $ columns ) . "'], 'string', 'max' => $length]" ; } return $ rules ; }
4241	public function onError ( Event $ error ) { if ( $ this -> debug -> getCfg ( 'collect' ) ) { $ this -> error = $ error ; $ errInfo = $ error [ 'typeStr' ] . ': ' . $ error [ 'file' ] . ' (line ' . $ error [ 'line' ] . ')' ; $ errMsg = $ error [ 'message' ] ; if ( $ error [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ) { $ this -> debug -> error ( $ errInfo . ': ' , $ errMsg ) ; } else { $ this -> debug -> warn ( $ errInfo . ': ' , $ errMsg ) ; } $ error [ 'continueToNormal' ] = false ; $ error [ 'inConsole' ] = true ; $ error [ 'email' ] = false ; $ this -> error = null ; } elseif ( $ this -> debug -> getCfg ( 'output' ) ) { $ error [ 'email' ] = false ; $ error [ 'inConsole' ] = false ; } else { $ error [ 'inConsole' ] = false ; } }
12049	public static function showImageInSize ( int $ iImageUri , int $ iWidth , int $ iHeight , bool $ bKeepDimension = false ) { $ aSize = getimagesize ( $ iImageUri ) ; $ rActualImage = imagecreatefromjpeg ( $ iImageUri ) ; $ ImageChoisie = imagecreatefromjpeg ( $ _FILES [ 'ImageNews' ] [ 'tmp_name' ] ) ; $ TailleImageChoisie = getimagesize ( $ _FILES [ 'ImageNews' ] [ 'tmp_name' ] ) ; $ rNewImage = imagecreatetruecolor ( $ iWidth , $ iHeight ) ; if ( $ bKeepDimension === false ) { imagecopyresampled ( $ rNewImage , $ rActualImage , 0 , 0 , 0 , 0 , $ iWidth , $ iHeight , $ aSize [ 0 ] , $ aSize [ 1 ] ) ; } else { if ( $ aSize [ 0 ] > $ aSize [ 1 ] ) { $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; $ fCoef = $ aSize [ 1 ] / $ aSize [ 0 ] ; $ iHeight = round ( $ iWidth * $ fCoef ) ; $ iDestY = round ( ( $ iWidth - $ iHeight ) / 2 ) ; $ iDestX = 0 ; } else { $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; $ fCoef = $ aSize [ 0 ] / $ aSize [ 1 ] ; $ iWidth = round ( $ iHeight * $ fCoef ) ; $ iDestX = round ( ( $ iHeight - $ iWidth ) / 2 ) ; $ iDestY = 0 ; } $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; imagecopyresampled ( $ rNewImage , $ rActualImage , $ iDestX , $ iDestY , 0 , 0 , $ iWidth , $ iHeight , $ aSize [ 0 ] , $ aSize [ 1 ] ) ; } imagedestroy ( $ rActualImage ) ; $ NomImageChoisie = explode ( '.' , $ rNewImage ) ; $ NomImageExploitable = time ( ) ; header ( 'Content-Type: image/jpeg' ) ; imagejpeg ( $ rNewImage , null , 100 ) ; }
12357	public function updateEntryName ( ContentfulEntry $ entry ) { $ displayField = $ this -> getDisplayField ( ) ; $ values = array_values ( ( array ) $ entry -> { $ displayField } ) ; $ entry -> setName ( isset ( $ values [ 0 ] ) ? $ values [ 0 ] : 'Untitled' ) ; }
1771	public function generateWithError ( $ blnSwitchOrder = false ) { $ strWidget = $ this -> generate ( ) ; $ strError = $ this -> getErrorAsHTML ( ) ; return $ blnSwitchOrder ? $ strWidget . $ strError : $ strError . $ strWidget ; }
1450	protected function validatorForResource ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> factory -> createResourceValidator ( ResourceObject :: create ( $ data ) , $ rules , $ messages , $ customAttributes ) ; }
4942	public function fileCountValidationCallback ( ) { if ( $ this -> form && ( $ object = $ this -> form -> getObject ( ) ) ) { if ( $ this -> getMaxFileCount ( ) - 1 < count ( $ object ) ) { return false ; } } return true ; }
2820	public function getSerializedInfo ( ) { return serialize ( array ( 'logging' => $ this -> getLogging ( ) , 'action' => $ this -> getController ( ) , 'design' => $ this -> getDesign ( ) , 'blocks' => $ this -> getBlocks ( ) , 'models' => $ this -> getModels ( ) , 'collections' => $ this -> getCollections ( ) , 'queries' => $ this -> getQueries ( ) , 'timers' => $ this -> getTimers ( ) , 'emails' => $ this -> getEmails ( ) ) ) ; }
7975	public function createSender ( $ domain , $ sender ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ sender ) throw new BadMethodCallException ( 'Parameter $sender is missing.' ) ; if ( ! is_array ( $ sender ) ) throw new BadMethodCallException ( 'Parameter $sender must be a array. ' . gettype ( $ sender ) . ' given.' ) ; if ( ! array_key_exists ( 'sender' , $ sender ) ) throw new BadMethodCallException ( 'Parameter $sender have key sender (string).' ) ; $ t = array ( ) ; $ t [ 'sender' ] = $ sender [ 'sender' ] ; ( $ sender [ 'relaunch' ] ) ? $ t [ 'relaunch' ] = $ sender [ 'relaunch' ] : $ t [ 'relaunch' ] = '' ; ( $ sender [ 'reason' ] ) ? $ t [ 'reason' ] = $ sender [ 'reason' ] : $ t [ 'reason' ] = '' ; unset ( $ sender ) ; try { $ r = $ this -> post ( 'sms/' . $ domain . '/senders' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ t ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
12776	protected function write ( $ namespace , array $ data ) { $ file = $ this -> adapter -> getFileName ( $ namespace ) ; $ contents = $ this -> adapter -> prepareForWriting ( $ data ) ; if ( ! $ this -> fileSystem -> has ( $ file ) ) { $ this -> fileSystem -> write ( $ file , $ contents ) ; } $ this -> fileSystem -> update ( $ file , $ contents ) ; }
8236	protected function checkServerConfiguration ( ) { $ pico = $ this -> picoAuth -> getPico ( ) ; $ configDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfigDir ( ) ) ; $ configFile = $ configDir . "/config.yml" ; $ contentDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfig ( 'content_dir' ) ) ; $ indexFile = $ contentDir . "/index" . $ pico -> getConfig ( 'content_ext' ) ; $ urls = array ( 'dir_listing' => $ configDir , 'config_file' => $ configFile , 'content_file' => $ indexFile ) ; $ this -> httpsTest ( ) ; $ this -> webRootDirsTest ( ) ; $ this -> picoAuth -> addOutput ( "installer_urltest" , $ urls ) ; }
7495	private static function convertString ( $ string , $ outputEncoding ) { if ( $ string instanceof StringBuilder ) { $ inputEncoding = $ string -> getEncoding ( ) ; } else { $ inputEncoding = mb_detect_encoding ( ( string ) $ string ) ; } $ string = ( string ) $ string ; if ( $ inputEncoding != $ outputEncoding ) { $ string = iconv ( $ inputEncoding , $ outputEncoding , $ string ) ; } return $ string ; }
1769	public function __isset ( $ strKey ) { switch ( $ strKey ) { case 'id' : return isset ( $ this -> strId ) ; break ; case 'name' : return isset ( $ this -> strName ) ; break ; case 'label' : return isset ( $ this -> strLabel ) ; break ; case 'value' : return isset ( $ this -> varValue ) ; break ; case 'class' : return isset ( $ this -> strClass ) ; break ; case 'template' : return isset ( $ this -> strTemplate ) ; break ; case 'wizard' : return isset ( $ this -> strWizard ) ; break ; case 'required' : return isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; case 'forAttribute' : return isset ( $ this -> blnForAttribute ) ; break ; case 'dataContainer' : return isset ( $ this -> objDca ) ; break ; case 'activeRecord' : return isset ( $ this -> objDca -> activeRecord ) ; break ; default : return isset ( $ this -> arrAttributes [ $ strKey ] ) || isset ( $ this -> arrConfiguration [ $ strKey ] ) ; break ; } }
4433	public function createSubscriber ( array $ channels ) : WatchdogSubscriber { $ redis = clone $ this -> redis ; $ redis -> disconnect ( ) ; $ redis -> connect ( ) ; return new WatchdogSubscriber ( $ redis , $ channels ) ; }
4732	protected function set_expiration ( ) { $ this -> exp_variant = time ( ) + ( int ) apply_filters ( 'wp_session_expiration_variant' , 24 * 60 ) ; $ this -> expires = time ( ) + ( int ) apply_filters ( 'wp_session_expiration' , 30 * 60 ) ; }
972	public function forget ( ) { $ keys = [ self :: DOMAIN , self :: USER , self :: TOKEN ] ; foreach ( $ keys as $ key ) { Session :: forget ( $ key ) ; } }
10726	public function getUsers ( ) { $ select = $ this -> tableGateway -> getSql ( ) -> select ( ) ; $ select -> columns ( [ "fullname" => new Expression ( "DISTINCT(CONCAT(usr_firstname, ' ', usr_lastname))" ) ] ) ; $ select -> join ( 'melis_core_user' , 'melis_core_user.usr_id = melis_hist_page_historic.hist_user_id' , [ ] , $ select :: JOIN_INNER ) ; $ resultSet = $ this -> tableGateway -> selectWith ( $ select ) ; return $ resultSet ; }
8864	public function augmentSQL ( SQLQuery & $ query ) { $ stage = Versioned :: current_stage ( ) ; if ( $ stage == 'Live' || ! Permission :: check ( "VIEW_DRAFT_CONTENT" ) ) { $ query -> addWhere ( "PublishDate < '" . Convert :: raw2sql ( SS_Datetime :: now ( ) ) . "'" ) ; } }
11037	function store_reduce ( & $ elts , $ value ) { switch ( strtoupper ( $ value ) ) { case 'OFF' : case 'NOTHING' : $ elts [ '0reduce' ] = _ETS_REDUCE_OFF ; return TRUE ; case 'SPACE' : case 'SPACES' : $ elts [ '0reduce' ] = _ETS_REDUCE_SPACES ; return TRUE ; case 'CRLF' : case 'ON' : case 'ALL' : $ elts [ '0reduce' ] = _ETS_REDUCE_ALL ; return TRUE ; default : return FALSE ; } }
2189	public function unregister ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; if ( ! isset ( $ this -> arrIdentities [ $ intObjectId ] ) ) { return ; } $ strTable = $ objModel -> getTable ( ) ; $ strPk = $ objModel -> getPk ( ) ; $ intPk = $ objModel -> $ strPk ; unset ( $ this -> arrIdentities [ $ intObjectId ] ) ; unset ( $ this -> arrRegistry [ $ strTable ] [ $ intPk ] ) ; $ objModel -> onUnregister ( $ this ) ; }
2762	public function log ( GitEvent $ gitEvent , string $ message , array $ context = [ ] , ? string $ eventName = null ) : void { if ( $ eventName === null && method_exists ( $ gitEvent , 'getName' ) ) { $ eventName = $ gitEvent -> getName ( ) ; } $ method = $ this -> getLogLevelMapping ( $ eventName ) ; $ context += [ 'command' => $ gitEvent -> getProcess ( ) -> getCommandLine ( ) ] ; $ this -> logger -> { $ method } ( $ message , $ context ) ; }
11977	public function getInterfaceObject ( ) { if ( is_null ( $ this -> _interfaceObject ) ) { $ this -> _interfaceObject = DataInterface :: find ( ) -> where ( [ 'system_id' => $ this -> object -> systemId ] ) -> one ( ) ; if ( empty ( $ this -> _interfaceObject ) ) { $ this -> _interfaceObject = new DataInterface ( ) ; $ this -> _interfaceObject -> name = $ this -> object -> name ; $ this -> _interfaceObject -> system_id = $ this -> object -> systemId ; if ( ! $ this -> _interfaceObject -> save ( ) ) { var_dump ( $ this -> _interfaceObject -> errors ) ; throw new Exception ( "Unable to save interface object!" ) ; } } } return $ this -> _interfaceObject ; }
1910	protected function createTemplate ( Model $ model , string $ templateName ) : Template { if ( isset ( $ this -> options [ 'template' ] ) ) { $ templateName = $ this -> options [ 'template' ] ; } if ( $ model -> customTpl ) { $ templateName = $ model -> customTpl ; } $ template = $ this -> get ( 'contao.framework' ) -> createInstance ( FrontendTemplate :: class , [ $ templateName ] ) ; $ template -> setData ( $ model -> row ( ) ) ; return $ template ; }
11066	public function addMethods ( $ mixin , array $ methods ) { foreach ( $ methods as $ method ) { $ this -> method_map [ $ method ] = $ mixin ; } return $ this ; }
3297	public function doAutoRunEnhancements ( LeadEvent $ event ) { $ lead = $ event -> getLead ( ) ; if ( $ lead && ( null !== $ lead -> getDateIdentified ( ) || ! $ lead -> isAnonymous ( ) ) ) { $ leadKey = strtolower ( implode ( '|' , [ $ lead -> getFirstname ( ) , ( $ lead -> getLastActive ( ) ? $ lead -> getLastActive ( ) -> format ( 'c' ) : '' ) , $ lead -> getEmail ( ) , $ lead -> getPhone ( ) , $ lead -> getMobile ( ) , ] ) ) ; if ( strlen ( $ leadKey ) > 3 ) { if ( isset ( $ this -> leadsEnhanced [ $ leadKey ] ) ) { return ; } else { $ this -> leadsEnhanced [ $ leadKey ] = true ; } } $ integrations = $ this -> enhancerHelper -> getEnhancerIntegrations ( ) ; foreach ( $ integrations as $ integration ) { $ settings = $ integration -> getIntegrationSettings ( ) ; if ( $ settings -> getIsPublished ( ) ) { $ features = $ settings -> getFeatureSettings ( ) ; if ( isset ( $ features [ 'autorun_enabled' ] ) && $ features [ 'autorun_enabled' ] ) { try { $ integration -> doEnhancement ( $ lead ) ; } catch ( \ Exception $ exception ) { $ e = new ApiErrorException ( 'There was an issue using enhancer: ' . $ integration -> getName ( ) , 0 , $ exception ) ; if ( ! empty ( $ lead ) ) { $ e -> setContact ( $ lead ) ; } throw $ e ; } } } } $ this -> logger -> info ( 'doAutoRunEnhancements complete' ) ; } }
11840	public static function size ( $ inputImg ) { if ( is_string ( $ inputImg ) ) $ img = self :: imgCreate ( $ inputImg ) ; else $ img = $ inputImg ; $ imgW = imagesx ( $ img ) ; $ imgH = imagesy ( $ img ) ; if ( is_string ( $ inputImg ) ) imagedestroy ( $ img ) ; return array ( $ imgW , $ imgH ) ; }
7636	public function getBlobInstance ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ query = array ( ) ; if ( ! is_null ( $ snapshotId ) ) { $ query [ 'snapshot' ] = $ snapshotId ; } $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , $ query , 'HEAD' , $ headers , false , null , self :: RESOURCE_BLOB , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } $ metadata = $ this -> parseMetadataHeaders ( $ response -> getHeaders ( ) ) ; return new BlobInstance ( $ containerName , $ blobName , $ snapshotId , $ response -> getHeader ( 'Etag' ) , $ response -> getHeader ( 'Last-modified' ) , $ this -> getBaseUrl ( ) . '/' . $ containerName . '/' . $ blobName , $ response -> getHeader ( 'Content-Length' ) , $ response -> getHeader ( 'Content-Type' ) , $ response -> getHeader ( 'Content-Encoding' ) , $ response -> getHeader ( 'Content-Language' ) , $ response -> getHeader ( 'Cache-Control' ) , $ response -> getHeader ( 'x-ms-blob-type' ) , $ response -> getHeader ( 'x-ms-lease-status' ) , false , $ metadata ) ; }
2945	public function removeRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> detach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> detach ( $ role ) ; }
7264	private function validateItem ( SaleItemInterface $ item ) { foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> validateItem ( $ child ) ; } if ( $ item -> isCompound ( ) ) { return ; } if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ item , false ) ) { return ; } if ( ! $ subject instanceof StockSubjectInterface ) { return ; } $ quantity = $ item -> getTotalQuantity ( ) ; $ availability = $ this -> availabilityHelper -> getAvailability ( $ subject , is_null ( $ item -> getParent ( ) ) ) ; if ( $ quantity < $ availability -> getMinimumQuantity ( ) ) { $ message = $ availability -> getMinimumMessage ( ) ; } elseif ( $ quantity > $ availability -> getMaximumQuantity ( ) ) { $ message = $ availability -> getMaximumMessage ( ) ; } else { return ; } if ( null !== $ item -> getParent ( ) ) { $ message = $ item -> getDesignation ( ) . ' : ' . $ message ; } throw new ValidationFailedException ( $ message ) ; }
10460	public static function create ( $ type ) { switch ( $ type ) { case ActionTypes :: CREATE : return new CreateDiffItem ( ) ; case ActionTypes :: UPDATE : return new UpdateDiffItem ( ) ; case ActionTypes :: DELETE : return new DeleteDiffItem ( ) ; default : throw new \ InvalidArgumentException ( "Invalid type {$type}" ) ; } }
12766	public function run ( ) : void { $ this -> isRan = true ; foreach ( $ this -> getAll ( ) as $ header ) { header ( $ header ) ; } }
1757	public static function getReadableSize ( $ intSize , $ intDecimals = 1 ) { for ( $ i = 0 ; $ intSize >= 1024 ; $ i ++ ) { $ intSize /= 1024 ; } return static :: getFormattedNumber ( $ intSize , $ intDecimals ) . ' ' . $ GLOBALS [ 'TL_LANG' ] [ 'UNITS' ] [ $ i ] ; }
3504	private function createByReason ( string $ reason , array $ json ) : SendNotificationException { $ reason = strtolower ( $ reason ) ; switch ( $ reason ) { case 'badcollapseid' : return new BadCollapseIdException ( ) ; case 'baddevicetoken' : return new BadDeviceTokenException ( ) ; case 'badexpirationdate' : return new BadExpirationDateException ( ) ; case 'badmessageid' : return new BadMessageIdException ( ) ; case 'badpriority' : return new BadPriorityException ( ) ; case 'badtopic' : return new BadTopicException ( ) ; case 'devicetokennotfortopic' : return new DeviceTokenNotForTopicException ( ) ; case 'duplicateheaders' : return new DuplicateHeadersException ( ) ; case 'idletimeout' : return new IdleTimeoutException ( ) ; case 'missingdevicetoken' : return new MissingDeviceTokenException ( ) ; case 'missingtopic' : return new MissingTopicException ( ) ; case 'payloadempty' : return new PayloadEmptyException ( ) ; case 'topicdisallowed' : return new TopicDisallowedException ( ) ; case 'badcertificate' : return new BadCertificateException ( ) ; case 'badcertificateenvironment' : return new BadCertificateEnvironmentException ( ) ; case 'expiredprovidertoken' : return new ExpiredProviderTokenException ( ) ; case 'forbidden' : return new ForbiddenException ( ) ; case 'invalidprovidertoken' : return new InvalidProviderTokenException ( ) ; case 'missingprovidertoken' : return new MissingProviderTokenException ( ) ; case 'badpath' : return new BadPathException ( ) ; case 'methodnotallowed' : return new MethodNotAllowedException ( ) ; case 'unregistered' : $ timestamp = array_key_exists ( 'timestamp' , $ json ) ? $ json [ 'timestamp' ] : 0 ; $ lastConfirmed = new \ DateTime ( 'now' , new \ DateTimeZone ( 'UTC' ) ) ; $ lastConfirmed -> setTimestamp ( $ timestamp ) ; return new UnregisteredException ( $ lastConfirmed ) ; case 'payloadtoolarge' : return new PayloadTooLargeException ( ) ; case 'toomanyprovidertokenupdates' : return new TooManyProviderTokenUpdatesException ( ) ; case 'toomanyrequests' : return new TooManyRequestsException ( ) ; case 'internalservererror' : return new InternalServerErrorException ( ) ; case 'serviceunavailable' : return new ServiceUnavailableException ( ) ; case 'shutdown' : return new ShutdownException ( ) ; default : return new UndefinedErrorException ( ) ; } }
10659	protected function normalizeHeaderName ( $ keyName ) { if ( ! is_string ( $ keyName ) ) { return null ; } return ucwords ( trim ( strtolower ( $ keyName ) ) , '-' ) ? : null ; }
7284	public function status ( $ status = NULL ) { if ( $ status === NULL ) { return $ this -> status ; } elseif ( array_key_exists ( $ status , Response :: $ messages ) ) { $ this -> status = ( int ) $ status ; $ this -> status_message = Response :: $ messages [ $ this -> status ] ; return $ this ; } else { throw new Exception ( __METHOD__ . ' unknown status value : :value' , array ( ':value' => $ status ) ) ; } }
4170	public function prettify ( Collection $ packages ) { $ summary = [ ] ; foreach ( $ packages as $ key => $ package ) { $ summary [ ] = [ 'id' => $ key + 1 , 'name' => $ this -> prettifyPackageInfo ( $ package ) , ] ; } return $ packages [ $ this -> askPackageKey ( $ summary ) ] [ 'name' ] ; }
2910	public function runSql ( $ query , $ queryParams = array ( ) ) { $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ statement = $ connection -> query ( $ query , $ queryParams ) ; return $ statement -> fetchAll ( PDO :: FETCH_ASSOC ) ; }
7844	public function device ( ? int $ id = null ) : ? array { if ( is_null ( $ id ) ) { $ id = $ this -> device ; } $ key = sprintf ( 'smsgatewayme.device.%s' , $ id ) ; $ device = Cache :: remember ( $ key , 3600 * 24 * 7 , function ( ) use ( & $ response , $ id ) { $ response = Request :: get ( $ this -> baseUrl . 'device/' . $ id ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return $ response -> body ; } ) ; return [ 'code' => $ response -> code ?? 200 , 'message' => 'OK' , 'data' => $ device , ] ; }
5839	protected function trim ( Builder $ url , $ args ) { $ args = ( is_string ( $ args ) ) ? $ args : null ; $ url -> trim ( $ args ) ; }
4727	private function getCachedSingular ( $ plural ) { $ plural = StringHelper :: strtolower ( $ plural ) ; return array_search ( $ plural , $ this -> cache ) ; }
6133	protected function getImage ( $ name , $ text = "" , $ class = null , $ iconpath = true , $ flagpath = false ) { $ src = "" ; if ( $ iconpath ) { $ src = $ this -> iconpath ; } if ( $ flagpath ) { $ src = $ this -> flagpath ; } return "<img src='" . $ src . $ name . "' title='" . $ text . "' alt='' align='top' />" ; }
509	public function actionIndex ( $ command = null ) { if ( $ command !== null ) { $ result = Yii :: $ app -> createController ( $ command ) ; if ( $ result === false ) { $ name = $ this -> ansiFormat ( $ command , Console :: FG_YELLOW ) ; throw new Exception ( "No help for unknown command \"$name\"." ) ; } list ( $ controller , $ actionID ) = $ result ; $ actions = $ this -> getActions ( $ controller ) ; if ( $ actionID !== '' || count ( $ actions ) === 1 && $ actions [ 0 ] === $ controller -> defaultAction ) { $ this -> getSubCommandHelp ( $ controller , $ actionID ) ; } else { $ this -> getCommandHelp ( $ controller ) ; } } else { $ this -> getDefaultHelp ( ) ; } }
3778	protected function getLabel ( ) { if ( null === ( $ attribute = $ this -> getFilteredAttribute ( ) ) ) { return null ; } if ( $ label = $ this -> get ( 'label' ) ) { return $ label ; } return $ attribute -> getName ( ) ; }
8327	public function recognizeRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra = [ ] ) { $ captchaId = $ this -> sendRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra ) ; $ startTime = time ( ) ; while ( true ) { $ this -> getLogger ( ) -> info ( "Waiting {$this->rTimeout} sec." ) ; sleep ( $ this -> recaptchaRTimeout ) ; if ( time ( ) - $ startTime >= $ this -> mTimeout ) { throw new RuntimeException ( "Captcha waiting timeout." ) ; } $ result = $ this -> getCaptchaResult ( $ captchaId ) ; if ( $ result === false ) { continue ; } $ this -> getLogger ( ) -> info ( "Elapsed " . ( time ( ) - $ startTime ) . " second(s)." ) ; return $ result ; } throw new RuntimeException ( 'Unknown recognition logic error.' ) ; }
2183	public function create ( ) : ItemInterface { $ tree = $ this -> factory -> createItem ( 'root' ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: BACKEND_MENU_BUILD , new MenuEvent ( $ this -> factory , $ tree ) ) ; return $ tree ; }
5904	public function listRoles ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/roles' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Role ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
9939	public function addChart ( Chart $ pChart , $ iChartIndex = null ) { $ pChart -> setWorksheet ( $ this ) ; if ( $ iChartIndex === null ) { $ this -> chartCollection [ ] = $ pChart ; } else { array_splice ( $ this -> chartCollection , $ iChartIndex , 0 , [ $ pChart ] ) ; } return $ pChart ; }
1545	public function decodes ( string ... $ mediaTypes ) : bool { if ( ! $ decoding = $ this -> getDecodingMediaType ( ) ) { return false ; } return collect ( $ mediaTypes ) -> contains ( function ( $ mediaType , $ index ) use ( $ decoding ) { return $ decoding -> equalsTo ( MediaType :: parse ( $ index , $ mediaType ) ) ; } ) ; }
9960	public function setAutoFilterByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { return $ this -> setAutoFilter ( Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ) ; }
7352	public function getRemainingAmount ( ) { $ amount = 0 ; $ currency = $ this -> getCurrency ( ) -> getCode ( ) ; $ hasDeposit = 1 === Money :: compare ( $ this -> depositTotal , 0 , $ currency ) ; if ( $ hasDeposit && ( - 1 === Money :: compare ( $ this -> paidTotal , $ this -> depositTotal , $ currency ) ) ) { $ total = $ this -> depositTotal ; } else { $ total = $ this -> grandTotal ; } $ c = Money :: compare ( $ total , $ this -> paidTotal + $ this -> outstandingAccepted + $ this -> pendingTotal , $ currency ) ; if ( 1 === $ c ) { $ amount = $ total - $ this -> paidTotal - $ this -> outstandingAccepted - $ this -> pendingTotal ; } else if ( 0 === $ c && 0 < $ this -> outstandingAccepted ) { $ amount = $ this -> outstandingAccepted ; } if ( 0 < $ amount ) { return $ amount ; } return 0 ; }
9672	private function writeBorderPr ( XMLWriter $ objWriter , $ pName , Border $ pBorder ) { if ( $ pBorder -> getBorderStyle ( ) != Border :: BORDER_NONE ) { $ objWriter -> startElement ( $ pName ) ; $ objWriter -> writeAttribute ( 'style' , $ pBorder -> getBorderStyle ( ) ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pBorder -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; } }
10812	protected function callAPI ( $ data ) { $ apiUtility = new PipedriveApi ( $ this -> apiEndpoint ) ; $ apiUtility -> setData ( $ data ) ; $ formState = $ this -> finisherContext -> getFormRuntime ( ) -> getFormState ( ) ; $ response = $ apiUtility -> execute ( ) ; if ( $ response -> data -> id ) { $ formState -> setFormValue ( $ this -> getIdentifier ( ) . ".ID" , $ response -> data -> id ) ; return true ; } else { throw new FinisherException ( "Something went wrong while calling the API!" ) ; } }
665	protected function openFromPoolSequentially ( array $ pool , array $ sharedConfig ) { if ( empty ( $ pool ) ) { return null ; } if ( ! isset ( $ sharedConfig [ 'class' ] ) ) { $ sharedConfig [ 'class' ] = get_class ( $ this ) ; } $ cache = is_string ( $ this -> serverStatusCache ) ? Yii :: $ app -> get ( $ this -> serverStatusCache , false ) : $ this -> serverStatusCache ; foreach ( $ pool as $ config ) { $ config = array_merge ( $ sharedConfig , $ config ) ; if ( empty ( $ config [ 'dsn' ] ) ) { throw new InvalidConfigException ( 'The "dsn" option must be specified.' ) ; } $ key = [ __METHOD__ , $ config [ 'dsn' ] ] ; if ( $ cache instanceof CacheInterface && $ cache -> get ( $ key ) ) { continue ; } $ db = Yii :: createObject ( $ config ) ; try { $ db -> open ( ) ; return $ db ; } catch ( \ Exception $ e ) { Yii :: warning ( "Connection ({$config['dsn']}) failed: " . $ e -> getMessage ( ) , __METHOD__ ) ; if ( $ cache instanceof CacheInterface ) { $ cache -> set ( $ key , 1 , $ this -> serverRetryInterval ) ; } } } return null ; }
2412	protected function addTableTlTheme ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_theme' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_theme' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_theme' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ this -> addDataRow ( $ xml , $ table , $ objTheme -> row ( ) , $ arrOrder ) ; }
9643	public static function getDriver ( MappingDriver $ originalDriver , $ namespace ) { if ( $ originalDriver instanceof MappingDriverChain ) { $ driver = new Driver \ Chain ( ) ; foreach ( $ originalDriver -> getDrivers ( ) as $ nestedNamespace => $ nestedDriver ) { $ driver -> addDriver ( static :: getDriver ( $ nestedDriver , $ namespace ) , $ nestedNamespace ) ; } if ( $ originalDriver -> getDefaultDriver ( ) !== null ) { $ driver -> setDefaultDriver ( static :: getDriver ( $ originalDriver -> getDefaultDriver ( ) , $ namespace ) ) ; } return $ driver ; } preg_match ( '/(?P<type>Xml|Yaml|Annotation)Driver$/' , get_class ( $ originalDriver ) , $ m ) ; $ type = isset ( $ m [ 'type' ] ) ? $ m [ 'type' ] : null ; $ driverClass = sprintf ( '%s\Mapping\Driver\%s' , $ namespace , $ type ) ; if ( ! $ type || ! class_exists ( $ driverClass ) ) { $ driverClass = sprintf ( '%s\Mapping\Driver\Annotation' , $ namespace ) ; if ( ! class_exists ( $ driverClass ) ) { throw new \ RuntimeException ( sprintf ( 'Failed to fallback to annotation driver: (%s), extension driver was not found.' , $ driverClass ) ) ; } } $ driver = new $ driverClass ( ) ; $ driver -> setOriginalDriver ( $ originalDriver ) ; if ( $ driver instanceof Driver \ File ) { $ driver -> setLocator ( $ originalDriver -> getLocator ( ) ) ; } elseif ( $ driver instanceof AnnotationDriverInterface ) { $ reader = static :: getAnnotationReader ( ) ; $ driver -> setAnnotationReader ( $ reader ) ; } return $ driver ; }
456	public function dropForeignKey ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
7938	public function getBackupFTPaccessBlock ( $ domain , $ ipBlock ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; try { $ r = $ this -> get ( 'dedicated/server/' . $ domain . '/features/backupFTP/access/' . urlencode ( $ ipBlock ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
7575	public function getCustomFields ( $ parameters = array ( ) ) { $ this -> _harvest = $ this -> _harvestHelper -> parse ( 'getCustomFields' , $ parameters ) ; if ( ! array_key_exists ( 'id' , $ parameters ) ) $ this -> _harvest [ 'url' ] = $ this -> _harvest [ 'url' ] . '/' ; $ this -> sendRequest ( ) ; }
9908	public function setPosition ( $ position ) { if ( ! in_array ( $ position , self :: $ positionXLref ) ) { return false ; } $ this -> position = $ position ; return true ; }
8117	public function onBeforeWrite ( ) { $ changedFields = $ this -> owner -> getChangedFields ( true , 2 ) ; if ( $ changedFields ) { $ this -> owner -> LastEditedByName = $ this -> owner -> getEditorName ( ) ; $ this -> owner -> OwnerNames = $ this -> owner -> getOwnerNames ( ) ; } if ( $ this -> owner -> isChanged ( "ContentReviewType" , 2 ) ) { if ( $ this -> owner -> ContentReviewType == "Disabled" ) { $ this -> setDefaultReviewDateForDisabled ( ) ; } elseif ( $ this -> owner -> ContentReviewType == "Custom" ) { $ this -> setDefaultReviewDateForCustom ( ) ; } else { $ this -> setDefaultReviewDateForInherited ( ) ; } } if ( $ this -> owner -> ContentReviewType == "Inherit" && ! $ this -> owner -> NextReviewDate ) { $ this -> setDefaultReviewDateForInherited ( ) ; } if ( ! $ this -> owner -> exists ( ) ) { return ; } if ( $ this -> owner -> isChanged ( 'ReviewPeriodDays' , 2 ) ) { $ nextReviewUnixSec = strtotime ( ' + ' . $ this -> owner -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ this -> owner -> NextReviewDate = DBDate :: create ( ) -> setValue ( $ nextReviewUnixSec ) -> Format ( 'y-MM-dd' ) ; } }
3834	public function hookAdditionalFormatters ( $ arrBaseFormatted , $ arrRowData , $ strOutputFormat , $ objSettings ) { $ arrResult = $ arrBaseFormatted ; if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ arrResult = $ objCallback -> $ strMethod ( $ this , $ arrResult , $ arrRowData , $ strOutputFormat , $ objSettings ) ; } } return $ arrResult ; }
3756	public function createVariant ( ConfigInterface $ objConfig ) { $ objItem = $ this -> getMetaModel ( ) -> findById ( $ objConfig -> getId ( ) ) -> varCopy ( ) ; if ( ! $ objItem ) { return null ; } $ model = new Model ( $ objItem ) ; $ model -> setMeta ( $ model :: IS_CHANGED , true ) ; return $ model ; }
3025	public function postRequest ( $ path , $ options , $ addApiKey ) { if ( isset ( $ options [ 'source' ] ) && is_array ( $ options [ 'source' ] ) ) { $ sources = $ options [ 'source' ] ; unset ( $ options [ 'source' ] ) ; foreach ( $ sources as $ i => $ source ) { $ options [ "source[$i]" ] = $ source ; } } $ response = $ this -> makeRequest ( 'POST' , $ path , $ options , $ addApiKey ) ; return $ this -> parseResponse ( $ response ) ; }
11821	function prepare_items ( ) { $ this -> columns = array ( $ this -> get_columns ( ) , $ this -> get_hidden_columns ( ) , $ this -> get_sortable_columns ( ) ) ; $ this -> items = $ this -> get_items ( ) ; usort ( $ this -> example_data , array ( $ this , 'usort_reorder' ) ) ; }
10616	protected function setLifetime ( Response $ response , $ lifetime ) { if ( $ lifetime >= 0 ) { $ date = clone $ response -> getDate ( ) ; $ response -> setMaxAge ( $ lifetime ) -> setExpires ( $ date -> modify ( sprintf ( '+%s seconds' , $ lifetime ) ) ) ; if ( ! $ response -> headers -> hasCacheControlDirective ( 'private' ) ) { $ response -> setPublic ( ) -> setSharedMaxAge ( $ lifetime ) ; } } return $ this ; }
1193	private function addCustomElements ( array $ elements , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ elements as $ element ) { $ name = $ element [ 0 ] ; $ contentSet = $ element [ 1 ] ; $ allowedChildren = $ element [ 2 ] ; $ attributeCollection = $ element [ 3 ] ; $ attributes = isset ( $ element [ 4 ] ) ? $ element [ 4 ] : null ; if ( ! empty ( $ attributes ) ) { $ definition -> addElement ( $ name , $ contentSet , $ allowedChildren , $ attributeCollection , $ attributes ) ; } else { $ definition -> addElement ( $ name , $ contentSet , $ allowedChildren , $ attributeCollection ) ; } } }
7183	protected function updateExchangeRate ( PaymentInterface $ payment ) { if ( null !== $ payment -> getExchangeRate ( ) ) { return false ; } $ date = new \ DateTime ( ) ; $ rate = $ this -> currencyConverter -> getRate ( $ this -> currencyConverter -> getDefaultCurrency ( ) , $ payment -> getCurrency ( ) -> getCode ( ) , $ date ) ; $ payment -> setExchangeRate ( $ rate ) -> setExchangeDate ( $ date ) ; return true ; }
1560	protected function modelKeyForField ( $ field , $ model ) { if ( isset ( $ this -> attributes [ $ field ] ) ) { return $ this -> attributes [ $ field ] ; } $ key = $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; return $ this -> attributes [ $ field ] = $ key ; }
4746	public function isReviewOptInError ( ) { $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; return $ review -> isReviewOptInError ( ) ; }
340	public function field ( $ model , $ attribute , $ options = [ ] ) { $ config = $ this -> fieldConfig ; if ( $ config instanceof \ Closure ) { $ config = call_user_func ( $ config , $ model , $ attribute ) ; } if ( ! isset ( $ config [ 'class' ] ) ) { $ config [ 'class' ] = $ this -> fieldClass ; } return Yii :: createObject ( ArrayHelper :: merge ( $ config , $ options , [ 'model' => $ model , 'attribute' => $ attribute , 'form' => $ this , ] ) ) ; }
7338	public function createEvent ( Request $ request ) : Event { if ( empty ( $ request -> input ( ) ) ) { return new Unknown ( ) ; } $ update = new Update ( $ request -> input ( ) ) ; $ this -> update = $ update ; if ( $ message = $ update -> message ) { $ chat = new Chat ( ( string ) $ message -> chat -> id , $ message -> chat -> title , $ message -> chat -> type ) ; $ from = new User ( ( string ) $ message -> from -> id , $ message -> from -> first_name , $ message -> from -> username ) ; return new MessageReceived ( $ chat , $ from , $ message -> text , $ message -> location , null , optional ( $ update -> callback_query ) -> data , $ update ) ; } if ( $ callbackQuery = $ update -> callback_query ) { $ message = $ callbackQuery -> message ; $ chat = new Chat ( ( string ) $ message -> chat -> id , $ message -> chat -> title , $ message -> chat -> type ) ; $ from = new User ( ( string ) $ message -> chat -> id , $ message -> from -> first_name , $ message -> from -> username ) ; return new MessageReceived ( $ chat , $ from , $ message -> text , $ message -> location , null , $ callbackQuery -> data , $ update ) ; } return new Unknown ( ) ; }
10757	public function totals ( $ locale = null ) { $ this -> setLocale ( $ locale ) ; $ totals = Collection :: make ( ) ; foreach ( Arr :: except ( $ this -> footer ( ) , 'all' ) as $ level => $ count ) { $ totals -> put ( $ level , [ 'label' => trans ( 'dashboard::logs.' . $ level ) , 'value' => $ count , 'color' => $ this -> color ( $ level ) , 'highlight' => $ this -> color ( $ level ) , ] ) ; } return $ totals ; }
12942	public function create ( $ className , $ username ) { $ reflectionClass = new \ ReflectionClass ( $ className ) ; $ permalinks = $ this -> pagesParser -> contributor ( $ username ) -> parse ( ) -> permalinksByLanguage ( $ this -> configurationHandler -> language ( ) . '_' . $ this -> configurationHandler -> country ( ) ) ; $ permalinksForSelect = ( ! empty ( $ permalinks ) ) ? array_combine ( $ permalinks , $ permalinks ) : array ( ) ; $ params = array ( $ permalinksForSelect ) ; $ form = $ this -> formFactory -> create ( $ reflectionClass -> newInstanceArgs ( $ params ) ) ; return $ form -> createView ( ) ; }
9247	public function from ( Contract $ contract , string $ string , callable $ callback = null ) : string { $ string = ucwords ( $ contract -> recipe ( $ string , 'upperCaseFirst' , function ( $ string ) use ( $ contract ) { if ( $ contract instanceof Camel ) { return $ string ; } return strtolower ( $ string ) ; } ) ) ; return $ this -> callback ( $ string , $ callback ) ; }
2324	public static function validate ( $ strToken ) { if ( Config :: get ( 'disableRefererCheck' ) || \ defined ( 'BYPASS_TOKEN_CHECK' ) ) { return true ; } if ( Config :: get ( 'requestTokenWhitelist' ) ) { $ strHostname = gethostbyaddr ( $ _SERVER [ 'REMOTE_ADDR' ] ) ; foreach ( Config :: get ( 'requestTokenWhitelist' ) as $ strDomain ) { if ( $ strDomain == $ strHostname || preg_match ( '/\.' . preg_quote ( $ strDomain , '/' ) . '$/' , $ strHostname ) ) { return true ; } } } $ container = System :: getContainer ( ) ; return $ container -> get ( 'contao.csrf.token_manager' ) -> isTokenValid ( new CsrfToken ( $ container -> getParameter ( 'contao.csrf_token_name' ) , $ strToken ) ) ; }
3468	public function delete ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: delete ( $ route ) ) ; }
10080	public static function getCurrencyCode ( ) { if ( ! empty ( self :: $ currencyCode ) ) { return self :: $ currencyCode ; } self :: $ currencyCode = '$' ; $ localeconv = localeconv ( ) ; if ( ! empty ( $ localeconv [ 'currency_symbol' ] ) ) { self :: $ currencyCode = $ localeconv [ 'currency_symbol' ] ; return self :: $ currencyCode ; } if ( ! empty ( $ localeconv [ 'int_curr_symbol' ] ) ) { self :: $ currencyCode = $ localeconv [ 'int_curr_symbol' ] ; return self :: $ currencyCode ; } return self :: $ currencyCode ; }
7023	private function formatZ ( & $ str ) { if ( strstr ( $ str , '%Z' ) ) $ str = str_replace ( '%Z' , $ this -> timezone -> offset * 3600 , $ str ) ; }
9734	public function setRGB ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = '000000' ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'argb' => 'FF' . $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> argb = 'FF' . $ pValue ; } return $ this ; }
2574	protected function loadSessionHandlerParams ( $ params ) { if ( isset ( $ params [ 'sessionHandlerParams' ] ) ) { if ( $ params [ 'sessionHandlerParams' ] instanceof SessionHandlerParams ) { $ this -> sessionHandlerParams = $ params [ 'sessionHandlerParams' ] ; } elseif ( is_array ( $ params [ 'sessionHandlerParams' ] ) ) { $ this -> sessionHandlerParams = new SessionHandlerParams ( $ params [ 'sessionHandlerParams' ] ) ; } } }
2618	public function getSiteLocation ( ) { $ countryId = $ this -> scopeConfig -> getValue ( 'general/store_information/country_id' ) ; if ( $ countryId ) { $ country = $ this -> countryFactory -> create ( ) -> loadByCode ( $ countryId ) ; $ countryName = $ country -> getName ( ) ; } else { $ countryName = 'Unknown country' ; } $ regionId = $ this -> scopeConfig -> getValue ( 'general/store_information/region_id' ) ; $ regionName = 'Unknown region' ; if ( $ regionId ) { $ region = $ this -> regionFactory -> create ( ) ; $ region = $ region -> load ( $ regionId ) ; if ( $ region -> getId ( ) ) { $ regionName = $ region -> getName ( ) ; } } $ postCode = $ this -> scopeConfig -> getValue ( 'general/store_information/postcode' ) ; if ( ! $ postCode ) { $ postCode = 'Unknown zip code' ; } return $ countryName . ' | ' . $ regionName . ' | ' . $ postCode ; }
9189	public function present ( ) { $ presenterClass = $ this -> getPresenterClass ( ) ; if ( ! class_exists ( $ presenterClass ) ) { throw new Exceptions \ PresenterException ( 'The specified presenter does not exist.' ) ; } if ( ! $ this -> presenterInstance ) { $ this -> presenterInstance = new $ presenterClass ( $ this ) ; } return $ this -> presenterInstance ; }
4980	public function convertToDatabaseValue ( $ value ) { if ( ! $ value instanceof \ DateTime ) { return null ; } $ timezone = $ value -> getTimezone ( ) -> getName ( ) ; $ timestamp = $ value -> getTimestamp ( ) ; $ date = new \ MongoDate ( $ timestamp ) ; return array ( 'date' => $ date , 'tz' => $ timezone , ) ; }
505	public function init ( ) { parent :: init ( ) ; if ( ! isset ( $ this -> translations [ 'yii' ] ) && ! isset ( $ this -> translations [ 'yii*' ] ) ) { $ this -> translations [ 'yii' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => 'en-US' , 'basePath' => '@yii/messages' , ] ; } if ( ! isset ( $ this -> translations [ 'app' ] ) && ! isset ( $ this -> translations [ 'app*' ] ) ) { $ this -> translations [ 'app' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => Yii :: $ app -> sourceLanguage , 'basePath' => '@app/messages' , ] ; } }
5387	public function setValue ( $ values ) { $ values = $ this -> makeArray ( $ values ) ; if ( ! $ this -> valuesArePossible ( $ values ) ) { return false ; } $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { $ possible = $ widgets [ $ i ] -> getAttribute ( 'value' ) ; if ( in_array ( $ widgets [ $ i ] -> getAttribute ( 'value' ) , $ values ) ) { $ widgets [ $ i ] -> setValue ( $ possible ) ; } else { $ widgets [ $ i ] -> setValue ( false ) ; } } return true ; }
2087	public static function getDefaultPath ( $ template , $ format ) { $ file = $ template . '.' . $ format ; $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ files [ $ template ] ) ) { return $ rootDir . '/' . self :: $ files [ $ template ] . '/' . $ file ; } $ strPath = null ; try { foreach ( $ container -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> name ( $ file ) as $ file ) { $ strPath = $ file -> getPathname ( ) ; } } catch ( \ InvalidArgumentException $ e ) { } if ( $ strPath !== null ) { return $ strPath ; } throw new \ Exception ( 'Could not find template "' . $ template . '"' ) ; }
3347	public function __preparedRequest ( $ type , $ request_type = 'GET' , $ params = array ( ) , $ data = array ( ) , $ retry_throttled = null ) { $ retry_throttled = $ retry_throttled ? : $ this -> retry_throttled ; $ path = $ this -> __getPath ( $ type , $ params ) ; while ( true ) { try { return $ this -> request ( $ request_type , $ path , $ data ) ; } catch ( ThrottledRequestException $ exception ) { if ( $ retry_throttled > 0 ) { sleep ( $ exception -> getTimeout ( ) ) ; $ retry_throttled -- ; continue ; } else { throw $ exception ; } } } return null ; }
1627	public function useFiles ( $ path , $ level = 'debug' ) { foreach ( $ this -> loggers as $ logger ) { if ( $ logger instanceof Log ) { $ logger -> useFiles ( $ path , $ level ) ; } } }
7231	public function loadResult ( array $ result ) { $ changed = false ; foreach ( [ 'revenue' , 'shipping' , 'margin' , 'orders' , 'items' , 'average' , 'details' ] as $ property ) { if ( $ this -> { $ property } != $ result [ $ property ] ) { $ this -> { $ property } = $ result [ $ property ] ; $ changed = true ; } } return $ changed ; }
10365	public function login ( LoginRequest $ request ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'login' ) ) -> dispatchFrom ( LoginJob :: class , $ request ) ; return redirect ( ) -> route ( config ( '_auth.login.redirect' ) ) ; }
8255	protected function handlePasswordReset ( Request $ httpRequest ) { $ passwordReset = $ this -> picoAuth -> getContainer ( ) -> get ( 'PasswordReset' ) ; $ passwordReset -> setConfig ( $ this -> config ) -> handlePasswordReset ( $ httpRequest ) ; }
362	protected function getClientOptions ( ) { $ filterUrl = isset ( $ this -> filterUrl ) ? $ this -> filterUrl : Yii :: $ app -> request -> url ; $ id = $ this -> filterRowOptions [ 'id' ] ; $ filterSelector = "#$id input, #$id select" ; if ( isset ( $ this -> filterSelector ) ) { $ filterSelector .= ', ' . $ this -> filterSelector ; } return [ 'filterUrl' => Url :: to ( $ filterUrl ) , 'filterSelector' => $ filterSelector , ] ; }
5279	protected function generateWhere ( $ column , $ param1 = null , $ param2 = null , $ type = 'and' ) { if ( is_null ( $ param2 ) ) { $ param2 = $ param1 ; $ param1 = '=' ; } if ( is_array ( $ param2 ) ) { $ param2 = $ this -> esc_array ( array_unique ( $ param2 ) ) ; if ( in_array ( $ param1 , array ( 'between' , 'not between' ) ) ) { $ param2 = join ( ' and ' , $ param2 ) ; } else { $ param2 = '(' . join ( ', ' , $ param2 ) . ')' ; } } elseif ( is_scalar ( $ param2 ) ) { $ param2 = $ this -> esc_value ( $ param2 ) ; } return join ( ' ' , array ( $ type , $ column , $ param1 , $ param2 ) ) ; }
1262	protected function compileEndpointUrl ( $ segment ) { $ base = ( $ this -> useIntegration ? $ this -> integrationBaseUrl : $ this -> productionBaseUrl ) ; return $ base . $ segment ; }
6379	protected function readStoreRecords ( $ type , array $ query ) { $ model = $ this -> store -> get_records ( $ type , $ query ) ; return $ model ; }
3061	public function getCurrentPosition ( ) { $ route = $ this -> getTestSession ( ) -> getRoute ( ) ; $ routeCount = $ route -> count ( ) ; $ routeItemPosition = $ route -> getPosition ( ) ; $ currentRouteItem = $ route -> getRouteItemAt ( $ routeItemPosition ) ; $ finalPosition = 0 ; for ( $ i = 0 ; $ i < $ routeCount ; $ i ++ ) { $ routeItem = $ route -> getRouteItemAt ( $ i ) ; if ( $ routeItem !== $ currentRouteItem ) { if ( ! $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition ++ ; } else { $ finalPosition += count ( $ this -> getShadowTest ( $ routeItem ) ) ; } } else { if ( $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition += array_search ( $ this -> getCurrentCatItemId ( $ routeItem ) , $ this -> getShadowTest ( $ routeItem ) ) ; } break ; } } return $ finalPosition ; }
5349	public function installOperatingSystemUnattended ( $ vpsName , $ operatingSystemName , $ base64InstallText ) { return $ this -> call ( self :: SERVICE , 'installOperatingSystemUnattended' , [ $ vpsName , $ operatingSystemName , $ base64InstallText ] ) ; }
4881	public function getContent ( ) { if ( $ this -> file instanceof \ Doctrine \ MongoDB \ GridFSFile ) { return $ this -> file -> getMongoGridFSFile ( ) -> getBytes ( ) ; } return null ; }
11759	public function deleteReply ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_REPLY , $ params ] ) ; }
11300	protected function _fetchData ( $ name ) { $ gateway = new \ Cora \ Gateway ( $ this -> getDbAdaptor ( ) , $ this -> getTableName ( ) , $ this -> getPrimaryKey ( ) ) ; return $ gateway -> fetchData ( $ this -> getFieldName ( $ name ) , $ this ) ; }
9693	public function getToken ( $ pId = 0 ) { if ( isset ( $ this -> tokens [ $ pId ] ) ) { return $ this -> tokens [ $ pId ] ; } throw new Exception ( "Token with id $pId does not exist." ) ; }
786	public function scenarios ( ) { $ scenarios = [ self :: SCENARIO_DEFAULT => [ ] ] ; foreach ( $ this -> getValidators ( ) as $ validator ) { foreach ( $ validator -> on as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } foreach ( $ validator -> except as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } } $ names = array_keys ( $ scenarios ) ; foreach ( $ this -> getValidators ( ) as $ validator ) { if ( empty ( $ validator -> on ) && empty ( $ validator -> except ) ) { foreach ( $ names as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } elseif ( empty ( $ validator -> on ) ) { foreach ( $ names as $ name ) { if ( ! in_array ( $ name , $ validator -> except , true ) ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } else { foreach ( $ validator -> on as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } foreach ( $ scenarios as $ scenario => $ attributes ) { if ( ! empty ( $ attributes ) ) { $ scenarios [ $ scenario ] = array_keys ( $ attributes ) ; } } return $ scenarios ; }
9177	public function mapBoolean ( $ value ) { if ( isset ( $ this -> booleanMapping [ $ value ] ) ) { return $ this -> booleanMapping [ $ value ] ; } throw new \ Exception ( sprintf ( 'Can\'t convert %s to boolean' , $ value ) ) ; }
3828	protected function addUrlParameter ( $ url , $ name , $ value ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ value = str_replace ( '%' , '%%' , urlencode ( $ value ) ) ; if ( empty ( $ value ) ) { return $ url ; } if ( $ name !== 'auto_item' ) { $ url .= '/' . $ name . '/' . $ value ; } else { $ url = '/' . $ value . $ url ; } return $ url ; }
1608	public function bulk ( $ redirects , $ separator , $ type , $ siteId ) { $ rawRedirects = array_map ( function ( $ line ) use ( $ separator ) { return str_getcsv ( $ line , $ separator ) ; } , explode ( PHP_EOL , $ redirects ) ) ; $ newFormatted = [ ] ; foreach ( $ rawRedirects as $ redirect ) { $ record = new RedirectRecord ( ) ; $ record -> uri = $ redirect [ 0 ] ; $ record -> to = $ redirect [ 1 ] ; $ record -> type = array_key_exists ( 2 , $ redirect ) ? $ redirect [ 2 ] : $ type ; $ record -> siteId = $ siteId ; $ record -> save ( ) ; $ newFormatted [ ] = [ 'id' => $ record -> id , 'uri' => $ record -> uri , 'to' => $ record -> to , 'type' => $ record -> type , 'siteId' => $ record -> siteId , ] ; } return [ $ newFormatted , false ] ; }
9513	public function setMatchModeByModeName ( $ modeName ) { $ modes = [ 'all' => 0 , 'any' => 1 , 'phrase' => 2 , 'boolean' => 3 , 'extended' => 4 , 'fullscan' => 5 , ] ; if ( array_key_exists ( $ modeName , $ modes ) ) { $ mode = $ modes [ $ modeName ] ; $ this -> SetMatchMode ( $ mode ) ; } else { throw new \ LogicException ( 'Wrong Mode' ) ; } }
8821	public function filter ( $ data = null , $ filter = false ) { if ( is_null ( $ data ) ) { return null ; } if ( is_array ( $ data ) ) { return array_map ( function ( $ value ) use ( $ filter ) { return $ this -> filter ( $ value , $ filter ) ; } , $ data ) ; } return ( $ filter == true ? $ this -> xssClean ( $ data ) : trim ( $ data ) ) ; }
5090	public function execute ( $ path ) { if ( ! file_exists ( $ path ) || ! is_readable ( $ path ) ) throw new SquidException ( "The file at [$path] is unreadable or doesn't exists" ) ; $ data = file_get_contents ( $ path ) ; $ result = $ this -> connector -> bulk ( ) -> add ( $ data ) -> executeAll ( ) ; return ( bool ) $ result ; }
10358	public static function error ( int $ code , string $ message , string $ file , int $ line ) : bool { if ( ( error_reporting ( ) & $ code ) !== 0 ) { if ( DEVELOPMENT == false && $ code == 8 ) { $ error [ 'code' ] = $ code ; $ error [ 'message' ] = $ message ; $ error [ 'file' ] = $ file ; $ error [ 'line' ] = $ line ; $ error [ 'type' ] = 'ErrorException: ' ; $ codes = array ( E_USER_NOTICE => 'Notice' , ) ; $ error [ 'type' ] .= in_array ( $ error [ 'code' ] , array_keys ( $ codes ) ) ? $ codes [ $ error [ 'code' ] ] : 'Unknown Error' ; ErrorHandler :: writeLogs ( "{$error['type']}: {$error['message']} in {$error['file']} at line {$error['line']}" ) ; } else { throw new \ ErrorException ( $ message , $ code , 0 , $ file , $ line ) ; } } return true ; }
10306	public function setLineStyleProperties ( $ line_width = null , $ compound_type = null , $ dash_type = null , $ cap_type = null , $ join_type = null , $ head_arrow_type = null , $ head_arrow_size = null , $ end_arrow_type = null , $ end_arrow_size = null ) { ( $ line_width !== null ) ? $ this -> lineStyleProperties [ 'width' ] = $ this -> getExcelPointsWidth ( ( float ) $ line_width ) : null ; ( $ compound_type !== null ) ? $ this -> lineStyleProperties [ 'compound' ] = ( string ) $ compound_type : null ; ( $ dash_type !== null ) ? $ this -> lineStyleProperties [ 'dash' ] = ( string ) $ dash_type : null ; ( $ cap_type !== null ) ? $ this -> lineStyleProperties [ 'cap' ] = ( string ) $ cap_type : null ; ( $ join_type !== null ) ? $ this -> lineStyleProperties [ 'join' ] = ( string ) $ join_type : null ; ( $ head_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'type' ] = ( string ) $ head_arrow_type : null ; ( $ head_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'size' ] = ( string ) $ head_arrow_size : null ; ( $ end_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'type' ] = ( string ) $ end_arrow_type : null ; ( $ end_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'size' ] = ( string ) $ end_arrow_size : null ; }
4741	private function createProfilerProbes ( $ name , ContainerBuilder $ container ) { $ key = sprintf ( "socloz_monitoring.profiler.probe.definition.%s" , $ name ) ; if ( $ container -> hasParameter ( $ key ) ) { $ definition = $ container -> getParameter ( $ key ) ; return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS | Probe :: TRACKER_TIMING , $ definition , $ container ) ) ; } else { return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS , $ container -> getParameter ( $ key . '.calls' ) , $ container ) , $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_TIMING , $ container -> getParameter ( $ key . '.timing' ) , $ container ) , ) ; } }
8493	public function setFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3048	public function init ( ) { $ sessionStateService = $ this -> getServiceManager ( ) -> get ( SessionStateService :: SERVICE_ID ) ; $ sessionStateService -> resumeSession ( $ this -> getTestSession ( ) ) ; $ this -> retrieveItemIndex ( ) ; }
767	public function login ( IdentityInterface $ identity , $ duration = 0 ) { if ( $ this -> beforeLogin ( $ identity , false , $ duration ) ) { $ this -> switchIdentity ( $ identity , $ duration ) ; $ id = $ identity -> getId ( ) ; $ ip = Yii :: $ app -> getRequest ( ) -> getUserIP ( ) ; if ( $ this -> enableSession ) { $ log = "User '$id' logged in from $ip with duration $duration." ; } else { $ log = "User '$id' logged in from $ip. Session not enabled." ; } $ this -> regenerateCsrfToken ( ) ; Yii :: info ( $ log , __METHOD__ ) ; $ this -> afterLogin ( $ identity , false , $ duration ) ; } return ! $ this -> getIsGuest ( ) ; }
2283	protected static function url ( ) { $ host = static :: get ( 'httpHost' ) ; $ xhost = static :: get ( 'httpXForwardedHost' ) ; if ( $ xhost != '' && $ xhost == Config :: get ( 'sslProxyDomain' ) ) { return 'https://' . $ xhost . '/' . $ host ; } return ( static :: get ( 'ssl' ) ? 'https://' : 'http://' ) . $ host ; }
7542	function typeIndex ( ) { if ( ! $ this -> parent ) { return - 1 ; } else { $ index = - 1 ; foreach ( array_keys ( $ this -> parent -> children ) as $ k ) { if ( strcasecmp ( $ this -> tag , $ this -> parent -> children [ $ k ] -> tag ) === 0 ) { ++ $ index ; } if ( $ this -> parent -> children [ $ k ] === $ this ) { return $ index ; } } return - 1 ; } }
127	public function ensureBinariesPresence ( PackageInterface $ package ) { $ this -> binaryInstaller -> installBinaries ( $ package , $ this -> getInstallPath ( $ package ) , false ) ; }
11204	public function where ( $ key = false , $ desiredValue , $ op = "==" ) { $ collection = $ this -> getIterator ( ) ; $ subset = new Collection ( ) ; foreach ( $ collection as $ prop => $ result ) { $ realValue = $ result ; if ( is_object ( $ result ) ) { $ realValue = $ result -> $ key ; } else if ( is_array ( $ result ) ) { $ realValue = $ result [ $ key ] ; } $ add = false ; if ( $ op == '==' && $ realValue == $ desiredValue ) { $ add = true ; } else if ( $ op == '>=' && $ realValue >= $ desiredValue ) { $ add = true ; } else if ( $ op == '<=' && $ realValue <= $ desiredValue ) { $ add = true ; } else if ( $ op == '>' && $ realValue > $ desiredValue ) { $ add = true ; } else if ( $ op == '<' && $ realValue < $ desiredValue ) { $ add = true ; } else if ( $ op == '===' && $ realValue === $ desiredValue ) { $ add = true ; } else if ( $ op == '!=' && $ realValue != $ desiredValue ) { $ add = true ; } if ( $ add ) { $ subset -> add ( $ result , $ prop ) ; } } return $ subset ; }
2213	public function first ( ) { $ this -> intIndex = 0 ; $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ $ this -> intIndex ] ; return $ this ; }
8960	public function sendRequest ( $ path , $ method = 'GET' , $ headers = array ( ) , $ data = '' ) { switch ( $ method ) { case 'GET' : $ response = $ this -> client -> get ( $ path , $ headers ) ; break ; case 'POST' : $ response = $ this -> client -> post ( $ path , $ data , $ headers ) ; break ; } if ( $ response -> code != 200 ) { $ error = htmlspecialchars ( $ response -> body ) ; throw new \ DomainException ( $ error , $ response -> code ) ; } return simplexml_load_string ( $ response -> body ) ; }
373	public function getOptionValues ( $ actionID ) { $ properties = [ ] ; foreach ( $ this -> options ( $ this -> action -> id ) as $ property ) { $ properties [ $ property ] = $ this -> $ property ; } return $ properties ; }
8659	private function convertGetFeedSubmissionCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
5760	public function getObjects ( array $ whereColumnsInfo = null , string $ orderBy = null ) : array { $ permissions = [ ] ; foreach ( $ this -> selectArray ( null , $ whereColumnsInfo , $ orderBy ) as $ permissionArray ) { $ permissions [ ] = $ this -> buildPermission ( $ permissionArray [ 'id' ] , $ permissionArray [ 'title' ] , $ permissionArray [ 'description' ] , $ permissionArray [ 'active' ] , $ permissionArray [ 'created' ] , $ permissionArray [ 'roles' ] ) ; } return $ permissions ; }
446	public function detachBehaviors ( ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ name => $ behavior ) { $ this -> detachBehavior ( $ name ) ; } }
1507	public function didCreate ( $ resource ) : void { if ( $ this -> wasClientDispatched ( ) ) { $ this -> clientJob -> setResource ( $ resource ) -> save ( ) ; } }
8668	public function setSelf ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Self' ] [ 'FieldValue' ] = $ value ; return $ this ; }
564	public function renderSorter ( ) { $ sort = $ this -> dataProvider -> getSort ( ) ; if ( $ sort === false || empty ( $ sort -> attributes ) || $ this -> dataProvider -> getCount ( ) <= 0 ) { return '' ; } $ sorter = $ this -> sorter ; $ class = ArrayHelper :: remove ( $ sorter , 'class' , LinkSorter :: className ( ) ) ; $ sorter [ 'sort' ] = $ sort ; $ sorter [ 'view' ] = $ this -> getView ( ) ; return $ class :: widget ( $ sorter ) ; }
4105	public function beginBulk ( ) { if ( ! $ this -> bulk ) { $ this -> bulk = $ this -> createBulk ( $ this ) ; } return $ this -> bulk ; }
1790	private function prepareAlias ( string $ alias , array & $ parameters ) : void { if ( 'index' === $ alias ) { return ; } $ hasAutoItem = false ; $ autoItems = $ this -> getAutoItems ( $ parameters ) ; $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ parameters [ 'alias' ] = preg_replace_callback ( '/\{([^\}]+)\}/' , static function ( array $ matches ) use ( $ alias , & $ parameters , $ autoItems , & $ hasAutoItem , $ config ) : string { $ param = $ matches [ 1 ] ; if ( ! isset ( $ parameters [ $ param ] ) ) { throw new MissingMandatoryParametersException ( sprintf ( 'Parameters "%s" is missing to generate a URL for "%s"' , $ param , $ alias ) ) ; } $ value = $ parameters [ $ param ] ; unset ( $ parameters [ $ param ] ) ; if ( $ hasAutoItem || ! $ config -> get ( 'useAutoItem' ) || ! \ in_array ( $ param , $ autoItems , true ) ) { return $ param . '/' . $ value ; } $ hasAutoItem = true ; return $ value ; } , $ alias ) ; }
3126	protected function isStartPoint ( TimePoint $ point ) { return $ point -> match ( null , TimePoint :: TARGET_ALL , TimePoint :: TYPE_START ) ; }
8981	private static function matchesDateCriteria ( $ key , RateInterface $ rate , array $ criteria ) { $ date = self :: extractDateCriteria ( $ key , $ criteria ) ; if ( $ date === null ) { return true ; } if ( $ key === 'dateFrom' ) { $ rateDate = new \ DateTime ( $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) ) ; $ rateDate -> setTime ( 23 , 59 , 59 ) ; return $ date <= $ rateDate ; } if ( $ key === 'dateTo' ) { $ rateDate = new \ DateTime ( $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) ) ; $ rateDate -> setTime ( 0 , 0 , 0 ) ; return $ date >= $ rateDate ; } return $ date -> format ( 'Y-m-d' ) === $ rate -> getDate ( ) -> format ( 'Y-m-d' ) ; }
10789	protected function setSearchFacets ( SessionInterface $ session , $ facets ) { $ session -> set ( $ this -> getSessionPrefix ( ) . '_facets' , \ json_encode ( $ facets ) ) ; }
2591	public function loadPaymentData ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> payMerchant , $ options -> transactionDate , $ options -> payments , $ options -> installmentsInfo , $ options -> fraudScreening , $ options -> payIds ) ) { $ this -> paymentData = new PaymentData ( $ options -> payMerchant , $ options -> transactionDate , $ options -> payments , $ options -> installmentsInfo , $ options -> fraudScreening , $ options -> payIds ) ; } }
455	public function dropColumn ( $ table , $ column ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP COLUMN ' . $ this -> db -> quoteColumnName ( $ column ) ; }
7280	public function validateInput ( array $ rules ) { foreach ( $ rules as $ rule ) if ( empty ( $ this -> inputs [ $ rule ] ) ) return false ; return true ; }
10803	public function deletePageHistoricAction ( ) { $ responseData = $ this -> params ( ) -> fromRoute ( 'datas' , $ this -> params ( ) -> fromQuery ( 'datas' , '' ) ) ; $ idPage = $ responseData [ 0 ] [ 'idPage' ] ; $ response = array ( 'idPage' => $ idPage ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_delete_start' , $ this , $ response ) ; $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ melisCoreAuth = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreAuth' ) ; $ userId = ( int ) null ; $ userAuthDatas = $ melisCoreAuth -> getStorage ( ) -> read ( ) ; if ( $ userAuthDatas ) $ userId = $ userAuthDatas -> usr_id ; $ histDatas = array ( 'hist_page_id' => $ idPage , 'hist_action' => 'Delete' , 'hist_date' => date ( 'Y-m-d H:i:s' ) , 'hist_user_id' => $ userId , 'hist_description' => 'tr_melispagehistoric_action_text_Delete' ) ; $ melisPageHistoricTable -> save ( $ histDatas ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_delete_end' , $ this , $ responseData ) ; }
3823	public function setPageValue ( string $ name , $ value ) : self { if ( empty ( $ value ) ) { unset ( $ this -> page [ $ name ] ) ; return $ this ; } $ this -> page [ $ name ] = $ value ; return $ this ; }
7521	function parse_asp ( ) { $ start = $ this -> pos ; if ( $ this -> next_pos ( '%>' , false ) !== self :: TOK_UNKNOWN ) { $ this -> pos -= 2 ; } $ len = $ this -> pos - 1 - $ start ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ start + 1 , $ len ) : '' ) ; $ this -> status [ 'last_pos' ] = ++ $ this -> pos ; return true ; }
712	public function integer ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_INTEGER , $ length ) ; }
6887	private function httpGet ( $ path , array $ query = array ( ) ) { $ url = new Uri ( $ this -> baseUrl . $ path ) ; foreach ( $ query as $ name => $ value ) { $ url = Uri :: withQueryValue ( $ url , $ name , $ value ) ; } $ request = new Request ( 'GET' , $ url , $ this -> buildHeaders ( ) ) ; try { $ response = $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; } catch ( \ RuntimeException $ e ) { throw new Exception \ PostcodeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } if ( $ response -> getStatusCode ( ) != 200 ) { throw $ this -> createErrorException ( $ response ) ; } return $ response ; }
12659	private function setExtraLanguagesOutdated ( $ name , $ content ) { foreach ( $ this -> extraLangs as $ lang ) { $ this -> getPageTexts ( $ lang ) ; $ this -> contents [ $ lang ] [ $ name ] [ 'outdated' ] = true ; if ( ! isset ( $ this -> contents [ $ lang ] [ $ name ] [ 'content' ] ) ) { $ this -> contents [ $ lang ] [ $ name ] [ 'content' ] = $ content ; } $ this -> writeTextsToFile ( $ lang ) ; } }
12360	public static function encodeHashId ( $ id ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ id ; } $ hashids = App :: make ( 'Hashids' ) ; return $ hashids -> encode ( $ id , date ( 'd' ) ) ; }
5179	private function addNew ( string $ key , $ value ) : self { $ this -> props [ $ key ] = $ value ; return $ this ; }
7573	public function validateRequiredFields ( $ postVars ) { $ requiredFields = $ this -> getRequiredFields ( $ postVars [ 'id' ] ) ; $ missingKeys = array ( ) ; foreach ( $ requiredFields as $ human => $ keys ) { if ( ! $ this -> hasRequiredValue ( $ postVars , $ keys ) ) { $ missingKeys [ ] = $ human ; } } if ( ! empty ( $ missingKeys ) ) { throw new GreenhouseApplicationException ( 'Submission missing required answers for: ' . implode ( ', ' , $ missingKeys ) ) ; } return true ; }
12792	public static function createSnippet ( string $ snptName ) : ? Snippet { $ snptRoot = AppHelper :: getInstance ( ) -> getComponentRoot ( 'snippets' ) ; $ snptFile = $ snptRoot . \ DIRECTORY_SEPARATOR . strtolower ( $ snptName ) . '.php' ; if ( is_readable ( $ snptFile ) ) { return new Snippet ( $ snptFile ) ; } return null ; }
5330	public function getEmojiPattern ( ) { if ( null === self :: $ emojiPattern ) { $ codeString = '' ; foreach ( $ this -> getEmojiCodeList ( ) as $ code ) { if ( is_array ( $ code ) ) { $ first = dechex ( array_shift ( $ code ) ) ; $ last = dechex ( array_pop ( $ code ) ) ; $ codeString .= '\x{' . $ first . '}-\x{' . $ last . '}' ; } else { $ codeString .= '\x{' . dechex ( $ code ) . '}' ; } } self :: $ emojiPattern = "/[$codeString]/u" ; } return self :: $ emojiPattern ; }
3579	protected function metaJoinQuery ( Builder $ query , $ method , ArgumentBag $ args ) { $ alias = $ this -> joinMeta ( $ query , $ args -> get ( 'column' ) ) ; $ method = $ args -> get ( 'function' ) ? : $ method ; return ( in_array ( $ method , [ 'orderBy' , 'lists' , 'pluck' ] ) ) ? $ this -> { "{$method}Meta" } ( $ query , $ args , $ alias ) : $ this -> metaSingleResult ( $ query , $ method , $ alias ) ; }
268	protected function getContextMessage ( ) { $ context = ArrayHelper :: filter ( $ GLOBALS , $ this -> logVars ) ; foreach ( $ this -> maskVars as $ var ) { if ( ArrayHelper :: getValue ( $ context , $ var ) !== null ) { ArrayHelper :: setValue ( $ context , $ var , '***' ) ; } } $ result = [ ] ; foreach ( $ context as $ key => $ value ) { $ result [ ] = "\${$key} = " . VarDumper :: dumpAsString ( $ value ) ; } return implode ( "\n\n" , $ result ) ; }
11193	protected function setPath ( $ url ) { $ cleanURI = str_replace ( '?' . $ _SERVER [ 'QUERY_STRING' ] , '' , $ url ) ; $ this -> pathString = explode ( $ this -> config [ 'site_url' ] , $ cleanURI , 2 ) [ 1 ] ; if ( $ this -> config [ 'lowercase_url' ] ) { $ this -> pathString = strtolower ( $ this -> pathString ) ; } $ this -> path = explode ( '/' , $ this -> pathString ) ; }
8474	public function notice ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'notice' , $ scope , $ message , $ context , $ config ) ; }
3484	public function withThreadId ( string $ threadId ) : Aps { $ cloned = clone $ this ; $ cloned -> threadId = $ threadId ; return $ cloned ; }
9192	public function init ( ) { if ( $ this -> isInitialized ( ) ) return true ; $ sm = $ this -> getServiceManager ( ) ; $ defaultListeners = $ sm -> get ( 'yimaTheme.Manager.ListenerAggregate' ) ; if ( $ defaultListeners instanceof self ) $ defaultListeners -> manager = $ this ; $ sharedEvents = $ this -> getEventManager ( ) -> getSharedManager ( ) ; $ sharedEvents -> attachAggregate ( $ defaultListeners ) ; $ this -> isInitialized = true ; return $ this ; }
6863	protected function registerManager ( ) { $ this -> app -> singleton ( 'notifyme' , function ( $ app ) { $ config = $ app [ 'config' ] ; $ factory = $ app [ 'notifyme.factory' ] ; return new NotifyMeManager ( $ config , $ factory ) ; } ) ; $ this -> app -> alias ( 'notifyme' , NotifyMeManager :: class ) ; $ this -> app -> alias ( 'notifyme' , ManagerInterface :: class ) ; }
11012	protected function importSchemaFile ( string $ schemaFile , string $ controlTableName = null ) : void { if ( $ controlTableName !== null ) { if ( $ this -> db -> getSchemaManager ( ) -> tablesExist ( [ $ controlTableName ] ) ) { $ this -> output -> writeln ( '<comment>Schema already exists in the database, skipping schema import for file <info>' . $ schemaFile . '</info></comment>' ) ; return ; } } $ this -> runQueriesFromFile ( $ schemaFile ) ; }
11695	protected function bustCacheBalls ( string $ asset_contents ) { $ asset_ext = $ this -> destination -> getExtension ( ) ; $ asset_name = $ this -> destination -> getBasename ( '.' . $ asset_ext ) ; $ asset_name_quoted = preg_quote ( $ asset_name , '/' ) ; $ search_for = '/' . $ asset_name_quoted . '\..*?\.' . $ asset_ext . '|' . $ asset_name_quoted . '\..*?\.min\.' . $ asset_ext . '|' . $ asset_name_quoted . '\.min\.' . $ asset_ext . '|' . $ asset_name_quoted . '\.' . $ asset_ext . '/' ; $ replace_with = $ asset_name . '.' . md5 ( $ asset_contents ) . '.' . $ asset_ext ; foreach ( $ this -> template as $ templateFile ) { $ this -> printTaskInfo ( 'Updating template file - <info>' . $ templateFile . '</info>' ) ; $ this -> collectionBuilder ( ) -> taskReplaceInFile ( $ templateFile ) -> regex ( $ search_for ) -> to ( $ replace_with ) -> run ( ) ; } $ asset_base_dir = $ this -> destination -> getPath ( ) ; $ this -> destination = new SplFileInfo ( $ asset_base_dir . '/' . $ replace_with ) ; $ files_to_delete = new Finder ( ) ; $ files_to_delete -> files ( ) ; $ files_to_delete -> name ( $ asset_name . '.' . $ asset_ext ) ; $ files_to_delete -> name ( $ asset_name . '.*.' . $ asset_ext ) ; $ files_to_delete -> name ( $ asset_name . '.*.' . $ asset_ext . '.gz' ) ; $ files_to_delete -> in ( $ asset_base_dir ) ; $ files_to_delete -> depth ( '== 0' ) ; foreach ( $ files_to_delete as $ file_to_delete ) { unlink ( $ file_to_delete -> getPathname ( ) ) ; } }
443	public function off ( $ name , $ handler = null ) { $ this -> ensureBehaviors ( ) ; if ( empty ( $ this -> _events [ $ name ] ) && empty ( $ this -> _eventWildcards [ $ name ] ) ) { return false ; } if ( $ handler === null ) { unset ( $ this -> _events [ $ name ] , $ this -> _eventWildcards [ $ name ] ) ; return true ; } $ removed = false ; if ( isset ( $ this -> _events [ $ name ] ) ) { foreach ( $ this -> _events [ $ name ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( $ this -> _events [ $ name ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { $ this -> _events [ $ name ] = array_values ( $ this -> _events [ $ name ] ) ; return $ removed ; } } if ( isset ( $ this -> _eventWildcards [ $ name ] ) ) { foreach ( $ this -> _eventWildcards [ $ name ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( $ this -> _eventWildcards [ $ name ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { $ this -> _eventWildcards [ $ name ] = array_values ( $ this -> _eventWildcards [ $ name ] ) ; if ( empty ( $ this -> _eventWildcards [ $ name ] ) ) { unset ( $ this -> _eventWildcards [ $ name ] ) ; } } } return $ removed ; }
5276	public function orderBy ( $ columns , $ direction = 'asc' ) { if ( is_string ( $ columns ) ) { $ columns = $ this -> argument_to_array ( $ columns ) ; } foreach ( $ columns as $ key => $ column ) { if ( is_numeric ( $ key ) ) { $ this -> statements [ 'orders' ] [ $ column ] = $ direction ; } else { $ this -> statements [ 'orders' ] [ $ key ] = $ column ; } } return $ this ; }
6036	public function addCommand ( $ item ) { if ( ! ( $ item instanceof Command ) ) { if ( is_array ( $ item ) ) { try { $ item = new Command ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Command. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Command"!' , E_USER_WARNING ) ; } } $ this -> commands [ ] = $ item ; return $ this ; }
6975	private function throwIllegalOperationIfAdjustmentIsImmutable ( ResourceEventInterface $ event ) { if ( $ event -> getHard ( ) ) { return ; } $ adjustment = $ this -> getAdjustmentFromEvent ( $ event ) ; if ( $ adjustment -> isImmutable ( ) ) { throw new IllegalOperationException ( 'ekyna_commerce.sale.message.immutable_element' ) ; } }
1161	private function fakeRequiredIfData ( $ data , $ rule , $ parameters ) { if ( $ rule !== 'RequiredIf' ) { return ; } $ newData = $ data ; $ newData [ $ parameters [ 0 ] ] = $ parameters [ 1 ] ; $ this -> validator -> setData ( $ newData ) ; }
800	private function findStart ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ $ index ] -> equalsAny ( [ '$' , [ T_VARIABLE ] ] ) ) { if ( $ tokens [ $ index ] -> equals ( ']' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_INDEX_SQUARE_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_PROP_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_PROP_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_VAR_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_VAR_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_INDEX_CURLY_BRACE , $ index ) ; } else { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } } while ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> equals ( '$' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } if ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return $ this -> findStart ( $ tokens , $ tokens -> getPrevMeaningfulToken ( $ index ) ) ; } return $ index ; }
1006	public function resolveType ( $ objectValue , $ context , ResolveInfo $ info ) { if ( isset ( $ this -> config [ 'resolveType' ] ) ) { $ fn = $ this -> config [ 'resolveType' ] ; return $ fn ( $ objectValue , $ context , $ info ) ; } return null ; }
12254	public function addCompiler ( $ compiler ) { if ( $ compiler instanceof CompilerFactoryInterface || $ compiler instanceof CompilerInterface ) { $ this -> compilers [ ] = $ compiler ; $ this -> orderedCompilers = NULL ; } else throw new CompilerException ( "Can only add objects that implement CompilerInterface or CompilerFactoryInterface to context" ) ; }
12124	public function getLanguages ( ) { $ languages = array ( ) ; foreach ( $ this -> getAliases ( ) as $ siteAlias ) { $ language = $ siteAlias -> getLanguage ( ) ; if ( ! in_array ( $ language , $ languages ) ) { $ languages [ ] = $ language ; } } return $ languages ; }
3376	private function createInstance ( $ file , $ w = null , $ h = null ) { $ container = $ this -> container ; $ webDir = $ container -> getParameter ( 'gregwar_image.web_dir' ) ; $ handlerClass = $ this -> handlerClass ; $ image = new $ handlerClass ( $ file , $ w , $ h , $ this -> throwException , $ this -> fallbackImage ) ; $ image -> setCacheDir ( $ this -> cacheDirectory ) ; $ image -> setCacheDirMode ( $ this -> cacheDirMode ) ; $ image -> setActualCacheDir ( $ webDir . '/' . $ this -> cacheDirectory ) ; if ( $ container -> has ( 'templating.helper.assets' ) ) { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ container -> get ( 'templating.helper.assets' ) -> getUrl ( $ file ) ; } ) ; } else { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ this -> assetsPackages -> getUrl ( $ file ) ; } ) ; } return $ image ; }
4734	public function write_data ( ) { $ option_key = "_wp_session_{$this->session_id}" ; if ( $ this -> dirty ) { if ( false === get_option ( $ option_key ) ) { add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; add_option ( "_wp_session_expires_{$this->session_id}" , $ this -> expires , '' , 'no' ) ; } else { delete_option ( "_wp_session_{$this->session_id}" ) ; add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; } } }
9701	public function addXfWriter ( Style $ style , $ isStyleXf = false ) { $ xfWriter = new Xf ( $ style ) ; $ xfWriter -> setIsStyleXf ( $ isStyleXf ) ; $ fontIndex = $ this -> addFont ( $ style -> getFont ( ) ) ; $ xfWriter -> setFontIndex ( $ fontIndex ) ; $ xfWriter -> setFgColor ( $ this -> addColor ( $ style -> getFill ( ) -> getStartColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setBgColor ( $ this -> addColor ( $ style -> getFill ( ) -> getEndColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setBottomColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getBottom ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setTopColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getTop ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setRightColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getRight ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setLeftColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getLeft ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setDiagColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getDiagonal ( ) -> getColor ( ) -> getRGB ( ) ) ) ; if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false ) { $ numberFormatHashCode = $ style -> getNumberFormat ( ) -> getHashCode ( ) ; if ( isset ( $ this -> addedNumberFormats [ $ numberFormatHashCode ] ) ) { $ numberFormatIndex = $ this -> addedNumberFormats [ $ numberFormatHashCode ] ; } else { $ numberFormatIndex = 164 + count ( $ this -> numberFormats ) ; $ this -> numberFormats [ $ numberFormatIndex ] = $ style -> getNumberFormat ( ) ; $ this -> addedNumberFormats [ $ numberFormatHashCode ] = $ numberFormatIndex ; } } else { $ numberFormatIndex = ( int ) $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) ; } $ xfWriter -> setNumberFormatIndex ( $ numberFormatIndex ) ; $ this -> xfWriters [ ] = $ xfWriter ; $ xfIndex = count ( $ this -> xfWriters ) - 1 ; return $ xfIndex ; }
12610	public function getParents ( ) { $ parents = [ ] ; foreach ( $ this -> _parents as $ key => $ parent ) { if ( ! $ parent -> active ) { continue ; } $ parents [ $ key ] = $ parent ; } return $ parents ; }
10533	public function last ( ) { if ( is_array ( $ this -> items ) && count ( $ this -> items ) > 0 ) { return end ( $ this -> items ) ; } return null ; }
4802	protected function locateDirectory ( string $ name ) : ? string { $ parts = [ $ name ] ; foreach ( Database :: COLLECTION_SEPARATOR_CHARACTERS as $ char ) { if ( ! strstr ( $ name , $ char ) ) { continue ; } $ parts = explode ( $ char , $ name ) ; break ; } return $ this -> recurseLocateDirectory ( $ parts ) ; }
6766	public function onAddressChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } if ( $ this -> handleAddressChange ( $ sale ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ sale , false ) ; $ this -> scheduleContentChangeEvent ( $ sale ) ; } }
7826	protected function getLongestPipeLength ( ) { if ( empty ( $ this -> pipes ) ) return 0 ; return array_reduce ( $ this -> pipes , function ( $ carry , $ pipe ) { return strlen ( $ pipe ) > $ carry ? strlen ( $ pipe ) : $ carry ; } , static :: MIN_PIPE_LENGTH ) ; }
12410	public function delete ( $ groupId ) { $ params = [ 'group_id' => intval ( $ groupId ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE , $ params ] ) ; }
7421	protected function initializeProductMediaGalleryValueToEntity ( array $ attr ) { $ rowId = $ attr [ MemberNames :: ROW_ID ] ; $ valueId = $ attr [ MemberNames :: VALUE_ID ] ; if ( $ this -> loadProductMediaGalleryValueToEntityByValueIdAndRowId ( $ valueId , $ rowId ) ) { return ; } return $ attr ; }
12547	public function getBlockPlugin ( $ name ) { if ( ! array_key_exists ( $ name , $ this -> blocks ) ) { return null ; } return $ this -> blocks [ $ name ] ; }
7114	static public function isBetterMode ( $ modeA , $ modeB ) { if ( $ modeA === static :: MODE_DISABLED ) { return $ modeB !== static :: MODE_DISABLED ; } elseif ( $ modeA === static :: MODE_JUST_IN_TIME ) { return in_array ( $ modeB , [ static :: MODE_MANUAL , static :: MODE_AUTO ] , true ) ; } return false ; }
9031	public function execute ( Closure $ callback ) { foreach ( $ this -> getServices ( ) as $ service ) { try { return $ callback ( $ this -> container -> make ( $ service ) ) ; } catch ( Exception $ e ) { } } throw new RuntimeException ( 'Could not execute any service.' ) ; }
3809	protected function applyLegendConditions ( $ attributeId , $ activeLegendId ) { if ( ! isset ( $ this -> conditions [ $ activeLegendId ] ) ) { return ; } if ( ! isset ( $ this -> conditions [ $ attributeId ] ) ) { $ this -> conditions [ $ attributeId ] = new PropertyConditionChain ( ) ; } $ this -> conditions [ $ attributeId ] -> addCondition ( $ this -> conditions [ $ activeLegendId ] ) ; }
7279	public function file ( $ name = null ) { return ! $ name ? $ this -> files : ( $ this -> files [ $ name ] ?? null ) ; }
4768	public static function convertPhpObjToDom ( $ arr , $ node , $ dom ) { if ( is_array ( $ arr ) ) { $ arrayParam = array ( ) ; foreach ( $ arr as $ k => $ v ) { if ( is_integer ( $ k ) ) { $ arrayParam [ ] = $ v ; } } if ( 0 < count ( $ arrayParam ) ) { $ node -> appendChild ( $ arrayDom = $ dom -> createElement ( "array" ) ) ; foreach ( $ arrayParam as $ key => $ val ) { $ new = $ arrayDom -> appendChild ( $ dom -> createElement ( 'item' ) ) ; self :: convertPhpObjToDom ( $ val , $ new , $ dom ) ; } } else { foreach ( $ arr as $ key => $ val ) { $ new = $ node -> appendChild ( $ dom -> createElement ( self :: encode ( $ key ) ) ) ; self :: convertPhpObjToDom ( $ val , $ new , $ dom ) ; } } } elseif ( ! is_object ( $ arr ) ) { $ node -> appendChild ( $ dom -> createTextNode ( self :: encode ( $ arr ) ) ) ; } }
4569	protected function cast ( $ element ) { if ( $ element instanceof Permission ) { return $ element ; } if ( ! is_array ( $ element ) ) { throw new InvalidArgumentException ( 'Element is not an array.' ) ; } foreach ( [ 'attributes' , 'type' , 'value' , 'title' ] as $ key ) { if ( ! array_key_exists ( $ key , $ element ) ) { throw new InvalidArgumentException ( 'Element is missing key "' . $ key . '".' ) ; } } $ permission = new Permission ( $ element [ 'key' ] , $ element [ 'attributes' ] , $ element [ 'type' ] , $ element [ 'value' ] , $ element [ 'title' ] ) ; return $ permission ; }
6134	public function setMetadata ( $ metadata ) { if ( is_array ( $ metadata ) ) { $ this -> metadata = $ metadata ; return $ this ; } $ this -> metadata = json_decode ( $ metadata , true ) ; if ( null === $ this -> metadata ) { $ this -> metadata = $ metadata ; } return $ this ; }
1773	public function validate ( ) { $ varValue = $ this -> validator ( $ this -> getPost ( $ this -> strName ) ) ; if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } $ this -> varValue = $ varValue ; }
10108	private function writeSelection ( ) { $ selectedCells = Coordinate :: splitRange ( $ this -> phpSheet -> getSelectedCells ( ) ) ; $ selectedCells = $ selectedCells [ 0 ] ; if ( count ( $ selectedCells ) == 2 ) { list ( $ first , $ last ) = $ selectedCells ; } else { $ first = $ selectedCells [ 0 ] ; $ last = $ selectedCells [ 0 ] ; } list ( $ colFirst , $ rwFirst ) = Coordinate :: coordinateFromString ( $ first ) ; $ colFirst = Coordinate :: columnIndexFromString ( $ colFirst ) - 1 ; -- $ rwFirst ; list ( $ colLast , $ rwLast ) = Coordinate :: coordinateFromString ( $ last ) ; $ colLast = Coordinate :: columnIndexFromString ( $ colLast ) - 1 ; -- $ rwLast ; $ colFirst = min ( $ colFirst , 255 ) ; $ colLast = min ( $ colLast , 255 ) ; $ rwFirst = min ( $ rwFirst , 65535 ) ; $ rwLast = min ( $ rwLast , 65535 ) ; $ record = 0x001D ; $ length = 0x000F ; $ pnn = $ this -> activePane ; $ rwAct = $ rwFirst ; $ colAct = $ colFirst ; $ irefAct = 0 ; $ cref = 1 ; if ( ! isset ( $ rwLast ) ) { $ rwLast = $ rwFirst ; } if ( ! isset ( $ colLast ) ) { $ colLast = $ colFirst ; } if ( $ rwFirst > $ rwLast ) { list ( $ rwFirst , $ rwLast ) = [ $ rwLast , $ rwFirst ] ; } if ( $ colFirst > $ colLast ) { list ( $ colFirst , $ colLast ) = [ $ colLast , $ colFirst ] ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'CvvvvvvCC' , $ pnn , $ rwAct , $ colAct , $ irefAct , $ cref , $ rwFirst , $ rwLast , $ colFirst , $ colLast ) ; $ this -> append ( $ header . $ data ) ; }
10646	public function execute ( ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> getURI ( ) ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_POST , true ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ this -> data ) ; $ response = curl_exec ( $ ch ) ; $ result = json_decode ( $ response ) ; curl_close ( $ ch ) ; if ( empty ( $ result ) || ! $ result -> success ) { throw new \ Exception ( "Pipedrive API error!" ) ; } return $ result ; }
6175	public function rightJoin ( $ table , $ column , $ operator = null , $ value = null ) { if ( $ column instanceof \ Closure ) { $ where = new Where ( ) ; call_user_func_array ( $ column , [ & $ where ] ) ; } else { $ where = ( new Where ( ) ) -> where ( $ column , $ operator , $ value ) ; } $ this -> request [ 'rightJoin' ] [ $ table ] [ 'table' ] = $ table ; $ this -> request [ 'rightJoin' ] [ $ table ] [ 'where' ] = $ where ; return $ this ; }
1781	public static function isInsecurePath ( $ strPath ) { $ strPath = strtr ( $ strPath , '\\' , '/' ) ; $ strPath = preg_replace ( '#//+#' , '/' , $ strPath ) ; if ( $ strPath == '..' ) { return true ; } if ( substr ( $ strPath , 0 , 2 ) == './' ) { return true ; } if ( substr ( $ strPath , 0 , 3 ) == '../' ) { return true ; } if ( substr ( $ strPath , - 2 ) == '/.' ) { return true ; } if ( substr ( $ strPath , - 3 ) == '/..' ) { return true ; } if ( strpos ( $ strPath , '/../' ) !== false ) { return true ; } return false ; }
11976	public function handleCommandHelp ( Event $ event , Queue $ queue ) { $ this -> sendIrcResponse ( $ event , $ queue , $ this -> getHelpLines ( ) ) ; }
1602	private function _getSocialFallback ( ) { $ image = null ; $ assets = \ Craft :: $ app -> assets ; $ fieldFallback = $ this -> _fieldSettings [ 'socialImage' ] ; if ( ! empty ( $ fieldFallback ) ) $ image = $ assets -> getAssetById ( ( int ) $ fieldFallback [ 0 ] ) ; else { $ seoFallback = $ this -> _seoSettings [ 'socialImage' ] ; if ( ! empty ( $ seoFallback ) ) $ image = $ assets -> getAssetById ( ( int ) $ seoFallback [ 0 ] ) ; } return [ 'title' => $ this -> title , 'description' => $ this -> description , 'image' => $ image , ] ; }
6810	public function rates ( Adjustment ... $ adjustments ) : string { return implode ( ', ' , array_map ( function ( Adjustment $ adjustment ) { return $ this -> percent ( $ adjustment -> getRate ( ) ) ; } , $ adjustments ) ) ; }
11564	protected function processWeakWord ( $ word ) { $ index = 0 ; $ text = ' ' . $ this -> text . ' ' ; while ( TRUE ) { $ index = mb_strpos ( $ text , ' ' . $ word . ' ' ) ; if ( $ index !== FALSE ) { $ text = mb_substr ( $ text , 0 , $ index + 1 ) . $ word . '&nbsp;' . mb_substr ( $ text , $ index + 1 + mb_strlen ( $ word ) + 1 ) ; $ index += 1 + mb_strlen ( $ word ) + 6 ; } else { break ; } } $ this -> text = mb_substr ( $ text , 1 , mb_strlen ( $ text ) - 2 ) ; }
1850	private function preHandleFragment ( FragmentReference $ uri , FragmentConfig $ config ) : void { if ( ! isset ( $ uri -> attributes [ 'pageModel' ] ) && $ this -> hasGlobalPageObject ( ) ) { $ uri -> attributes [ 'pageModel' ] = $ GLOBALS [ 'objPage' ] -> id ; } if ( $ this -> preHandlers -> has ( $ uri -> controller ) ) { $ preHandler = $ this -> preHandlers -> get ( $ uri -> controller ) ; $ preHandler -> preHandleFragment ( $ uri , $ config ) ; } }
8356	public function generateModels ( ) { $ definition = $ this -> getDefinition ( ) ; foreach ( $ definition as $ modelName => $ modelDefinition ) { $ type = 'model' ; if ( isset ( $ modelDefinition [ 'type' ] ) === true && in_array ( $ modelDefinition [ 'type' ] , [ 'enum' , 'model' ] ) === true ) { $ type = $ modelDefinition [ 'type' ] ; } if ( $ type == 'enum' ) { $ this -> generateEnum ( $ modelName , $ modelDefinition ) ; } else { $ this -> generateModel ( $ modelName , $ modelDefinition ) ; } } }
10038	function renameCustomField ( $ oldName , $ newName ) { $ encodedOldName = urlencode ( mb_convert_encoding ( $ oldName , "UTF-8" ) ) ; $ encodedNewName = urlencode ( mb_convert_encoding ( $ newName , "UTF-8" ) ) ; return $ this -> put ( "contacts/fields/custom/${encodedOldName}/${encodedNewName}" ) ; }
128	protected function getPackageBasePath ( PackageInterface $ package ) { $ installPath = $ this -> getInstallPath ( $ package ) ; $ targetDir = $ package -> getTargetDir ( ) ; if ( $ targetDir ) { return preg_replace ( '{/*' . str_replace ( '/' , '/+' , preg_quote ( $ targetDir ) ) . '/?$}' , '' , $ installPath ) ; } return $ installPath ; }
9203	public function get ( $ endpoint , $ params = null ) { $ endpoint = $ this -> prependVersionToEndpoint ( $ endpoint , Config :: get ( 'api_version' ) ) ; $ options = $ this -> constructRequestOptions ( $ params ) ; $ response = $ this -> guzzleClient -> get ( $ endpoint , $ options ) ; return $ response ; }
10061	public function create ( $ key , $ value ) { $ exists = $ this -> metaModel :: where ( 'key' , $ key ) -> exists ( ) ; if ( $ exists ) { $ message = "Can't create meta (key: $key). " ; $ message .= "Meta already exists" ; throw new \ Exception ( $ message ) ; } $ meta = new $ this -> metaModel ; $ meta -> key = $ key ; $ meta -> value = $ value ; $ meta -> save ( ) ; }
4522	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Config ) { return ; } $ key = $ entity -> getKey ( ) ; $ encrypt = $ this -> configCollection -> get ( $ key ) [ 'encrypt' ] ; $ entity -> setEncrypt ( $ encrypt ) ; }
1312	public function setTimeouts ( $ connectionTimeout , $ timeout ) { $ this -> connectionTimeout = ( int ) $ connectionTimeout ; $ this -> timeout = ( int ) $ timeout ; }
1363	public static function create ( array $ parameters , $ beforeKey = 'before' , $ afterKey = 'after' , $ limitKey = 'limit' ) { return new self ( array_get ( $ parameters , $ beforeKey ) , array_get ( $ parameters , $ afterKey ) , array_get ( $ parameters , $ limitKey , 15 ) ) ; }
357	function checkPhpExtensionVersion ( $ extensionName , $ version , $ compare = '>=' ) { if ( ! extension_loaded ( $ extensionName ) ) { return false ; } $ extensionVersion = phpversion ( $ extensionName ) ; if ( empty ( $ extensionVersion ) ) { return false ; } if ( strncasecmp ( $ extensionVersion , 'PECL-' , 5 ) === 0 ) { $ extensionVersion = substr ( $ extensionVersion , 5 ) ; } return version_compare ( $ extensionVersion , $ version , $ compare ) ; }
12719	public function bind ( $ abstract , $ concrete = null , $ shared = false ) { if ( is_null ( $ concrete ) ) { $ concrete = $ abstract ; } if ( ! ( $ concrete instanceof \ Closure ) ) { $ concrete = $ this -> turnIntoResolvableClosure ( $ abstract , $ concrete ) ; } $ this -> bindings [ $ abstract ] = compact ( 'concrete' , 'shared' ) ; }
5142	public function process ( ServerRequestInterface $ request ) : ResponseInterface { $ filteredMiddleware = $ this -> middleware ; try { $ request = $ this -> router -> dispatch ( $ request ) ; $ route = $ request -> getAttribute ( 'route' ) ; $ filteredMiddleware = array_filter ( $ filteredMiddleware , function ( Middleware $ middleware ) use ( $ route ) { return $ middleware -> executeFor ( $ route ) ; } ) ; $ requestHandler = $ route -> getHandler ( ) ; } catch ( HttpException $ e ) { $ requestHandler = new NextHandler ( function ( ) use ( $ e ) { throw $ e ; } ) ; } $ filteredMiddleware = array_map ( function ( Middleware $ middleware ) { return $ middleware -> getMiddleware ( ) ; } , $ filteredMiddleware ) ; $ dispatcher = new Stack ( $ filteredMiddleware , $ requestHandler ) ; return $ dispatcher -> dispatch ( $ request ) ; }
658	public function cache ( callable $ callable , $ duration = null , $ dependency = null ) { $ this -> _queryCacheInfo [ ] = [ $ duration === null ? $ this -> queryCacheDuration : $ duration , $ dependency ] ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
11768	public function updateSentinels ( ) { SENTINEL_QUERY : { $ sentinel = $ this -> getSentinelConnection ( ) ; try { $ payload = $ sentinel -> executeCommand ( RawCommand :: create ( 'SENTINEL' , 'sentinels' , $ this -> service ) ) ; $ this -> sentinels = array ( ) ; $ this -> sentinels [ ] = $ sentinel -> getParameters ( ) -> toArray ( ) ; foreach ( $ payload as $ sentinel ) { $ this -> sentinels [ ] = array ( 'host' => $ sentinel [ 3 ] , 'port' => $ sentinel [ 5 ] , 'role' => 'sentinel' , ) ; } } catch ( ConnectionException $ exception ) { $ this -> sentinelConnection = null ; goto SENTINEL_QUERY ; } } }
12804	private static function buildColumnPropertiesCache ( ) { $ class = self :: getStaticChildClass ( ) ; $ annotations = new AnnotationReader ( $ class ) ; $ properties = $ annotations -> getPropertyAnnotations ( ) ; self :: $ columnPropertiesCache [ $ class ] = [ ] ; foreach ( $ properties as $ property ) { if ( $ property === [ ] ) continue ; if ( array_key_exists ( "ColumnName" , $ property ) ) self :: $ columnPropertiesCache [ $ class ] [ $ property [ "ColumnName" ] ] [ ] = $ property [ "var" ] [ "name" ] ; else self :: $ columnPropertiesCache [ $ class ] [ $ property [ "var" ] [ "name" ] ] [ ] = $ property [ "var" ] [ "name" ] ; } }
4360	public static function dump ( $ str , $ useHtml = false , $ sanitizeNonBinary = false ) { self :: $ useHtml = $ useHtml ; self :: $ sanitizeNonBinary = $ sanitizeNonBinary ; self :: setStr ( $ str ) ; $ controlCharAs = 'other' ; $ curBlockType = 'utf8' ; $ newBlockType = null ; $ curBlockStart = 0 ; $ strNew = '' ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ curI = self :: $ curI ; $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial , true ) ; if ( $ isUtf8 && $ isSpecial && $ controlCharAs !== 'utf8special' && \ ord ( $ str [ $ curI ] ) < 0x80 ) { if ( $ controlCharAs == 'other' ) { $ isUtf8 = false ; } elseif ( $ controlCharAs == 'utf8' ) { $ isSpecial = false ; } } if ( $ isUtf8 ) { if ( $ isSpecial ) { if ( $ curBlockType !== 'utf8special' ) { $ newBlockType = 'utf8special' ; } } else { if ( $ curBlockType !== 'utf8' ) { $ newBlockType = 'utf8' ; } } } else { if ( $ curBlockType !== 'other' ) { $ newBlockType = 'other' ; } } if ( $ newBlockType ) { $ len = $ curI - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; $ curBlockStart = $ curI ; $ curBlockType = $ newBlockType ; $ newBlockType = null ; } } $ len = self :: $ stats [ 'strLen' ] - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; if ( self :: $ stats [ 'strLen' ] ) { $ percentOther = ( self :: $ stats [ 'bytesOther' ] ) / self :: $ stats [ 'strLen' ] * 100 ; if ( $ percentOther > 33 ) { $ strNew = self :: dumpBlock ( $ str , 'other' , array ( 'prefix' => false ) ) ; } else { $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; } } return $ strNew ; }
7491	public function setLength ( $ newLength , $ padding = ' ' ) { $ newLength = ( int ) $ newLength ; $ currentLength = $ this -> length ( ) ; if ( $ newLength != $ currentLength ) { while ( $ newLength > $ this -> length ( ) ) { $ this -> string .= $ padding ; } if ( $ newLength < $ this -> length ( ) ) { $ this -> string = mb_substr ( $ this -> string , 0 , $ newLength , $ this -> encoding ) ; } } return $ this ; }
3533	public static function findByAttribute ( $ attribute , $ searchValue ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> select ( 'samaccountname' ) -> where ( $ attribute , '=' , $ searchValue ) -> get ( ) ; $ userObjectReturn = null ; if ( count ( $ userObjectsFound ) == 1 ) { $ userObjectReturn = static :: findByUsername ( $ userObjectsFound [ 0 ] [ 'samaccountname' ] [ 0 ] ) ; } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } return $ userObjectReturn ; }
6308	public function setA ( StringType $ name , Attribute $ attribute ) { if ( $ this -> hasA ( $ name ) ) { $ this -> attributes = $ this -> attributes -> kDiff ( new AttributeMap ( [ $ name ( ) => $ attribute ] ) ) ; } $ this -> attributes = $ this -> attributes -> append ( [ $ name ( ) => $ attribute ] ) ; return $ this ; }
6982	public function validate ( $ dataOrRequest , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ errors = $ this -> validateAndReturnErrors ( $ dataOrRequest , $ rules , $ messages , $ customAttributes ) ; if ( ! empty ( $ errors ) ) { $ this -> throwValidationErrorsResponse ( $ errors ) ; } return $ this -> extractInputFromRules ( $ dataOrRequest , $ rules ) ; }
7179	public function getType ( ) { if ( is_string ( $ this -> type ) ) { $ type = $ this -> type ; } elseif ( is_array ( $ this -> type ) ) { $ type = reset ( $ this -> type ) ; } else { $ type = null ; } return $ this -> isValidType ( $ type ) ? $ type : self :: ANY ; }
1622	private function addColumn ( $ column , & $ columns ) { if ( isset ( $ columns [ $ column ] ) ) { return $ columns [ $ column ] ; } $ name = 'c' . preg_replace ( "/[^a-z]+/i" , "" , $ column ) . count ( $ columns ) ; return $ columns [ $ column ] = $ name ; }
7976	public function addSecondaryDnsDomains ( $ domain2add , $ ip ) { self :: getClient ( ) -> addSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2add , $ ip ) ; return true ; }
8507	public function getPackageLabels ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPackageLabelsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPackageLabelsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPackageLabels' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPackageLabelsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11996	static public function doctrine ( $ tableName , $ field , $ length = 16 ) { do { $ generate = self :: generate ( $ length ) ; } while ( self :: doctrineQuery ( $ tableName , $ field , $ generate ) ) ; return $ generate ; }
12392	public function getPages ( $ startPage , $ endPage , $ urlStub ) { $ pages = [ ] ; for ( $ x = $ startPage ; $ x <= $ endPage ; $ x ++ ) { $ pages [ ] = $ urlStub . $ x ; } return $ pages ; }
4053	private function fetchConditions ( $ inputScreenId ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return $ builder -> select ( 'cond.*' , 'setting.attr_id AS setting_attr_id' ) -> from ( 'tl_metamodel_dcasetting_condition' , 'cond' ) -> leftJoin ( 'cond' , 'tl_metamodel_dcasetting' , 'setting' , 'cond.settingId=setting.id' ) -> leftJoin ( 'setting' , 'tl_metamodel_dca' , 'dca' , 'setting.pid=dca.id' ) -> where ( 'cond.enabled=1' ) -> andWhere ( 'setting.published=1' ) -> andWhere ( 'dca.id=:screenId' ) -> setParameter ( 'screenId' , $ inputScreenId ) -> orderBy ( 'pid' ) -> addOrderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
11862	public function setPairedDataItem ( DataItem $ value ) { $ this -> _pairedDataItem = $ value ; if ( ! isset ( $ this -> _localObject ) && isset ( $ value -> localObject ) ) { $ this -> localObject = $ value -> localObject ; } if ( ! isset ( $ this -> _foreignObject ) && isset ( $ value -> foreignObject ) ) { $ this -> foreignObject = $ value -> foreignObject ; } if ( $ value -> handledDataItem ) { $ this -> handledDataItem = $ value -> handledDataItem ; } }
11151	public function getApi ( ) { if ( $ this -> api === null ) { $ this -> api = new ExtDirectApi ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; } return $ this -> api ; }
309	public function export ( ) { if ( empty ( $ this -> message [ 'subject' ] ) ) { $ this -> message [ 'subject' ] = 'Application Log' ; } $ messages = array_map ( [ $ this , 'formatMessage' ] , $ this -> messages ) ; $ body = wordwrap ( implode ( "\n" , $ messages ) , 70 ) ; $ message = $ this -> composeMessage ( $ body ) ; if ( ! $ message -> send ( $ this -> mailer ) ) { throw new LogRuntimeException ( 'Unable to export log through email!' ) ; } }
8097	private function validate ( ) { $ server = new Collection ( $ _SERVER ) ; $ ip = $ server -> HTTP_X_FORWARDED_FOR ; if ( is_null ( $ ip ) && $ server -> REMOTE_ADDR ) { $ ip = $ server -> REMOTE_ADDR ; } if ( ! is_null ( $ this -> _ip ) ) { if ( $ this -> _ip != $ ip ) { $ this -> destroy ( ) ; } } else { $ this -> _ip = $ ip ; } }
8763	public function delete ( $ server_filename ) { $ upload_path = config ( 'dropzoner.upload-path' ) ; $ full_path = $ upload_path . $ server_filename ; if ( \ File :: exists ( $ full_path ) ) { \ File :: delete ( $ full_path ) ; } event ( new ImageWasDeleted ( $ server_filename ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 ] , 200 ) ; }
2361	public static function findAllActive ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; return static :: findBy ( array ( "$t.disable='' AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "')" ) , null , $ arrOptions ) ; }
12952	public function getForeignParents ( ) { $ parents = [ ] ; foreach ( $ this -> dataSource -> foreignParentKeys as $ keySet ) { $ model = $ keySet [ 'foreignModel' ] ; unset ( $ keySet [ 'foreignModel' ] ) ; if ( ! empty ( $ this -> foreignObject -> { $ keySet [ 'foreignId' ] } ) ) { $ keySet [ 'foreignId' ] = $ this -> foreignObject -> { $ keySet [ 'foreignId' ] } ; if ( ! isset ( $ parents [ $ model ] ) ) { $ parents [ $ model ] = [ ] ; } $ parents [ $ model ] [ ] = $ keySet ; } } return $ parents ; }
10725	public function getPageHistoricListOfActions ( $ order = 'ASC' ) { $ select = $ this -> tableGateway -> getSql ( ) -> select ( ) ; $ select -> columns ( [ "action" => new Expression ( 'DISTINCT(hist_action)' ) ] ) ; $ select -> order ( 'hist_action' . ' ' . $ order ) ; $ resultSet = $ this -> tableGateway -> selectWith ( $ select ) ; return $ resultSet ; }
5221	public function sourcePathes ( ) { $ vendorPathes = [ ] ; foreach ( array_merge ( $ this -> loadPsr0Pathes ( ) , $ this -> loadPsr4Pathes ( ) ) as $ pathes ) { if ( is_array ( $ pathes ) ) { $ vendorPathes = array_merge ( $ vendorPathes , $ pathes ) ; } else { $ vendorPathes [ ] = $ pathes ; } } return $ vendorPathes ; }
8654	private function convertSubmitFeed ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'SubmitFeed' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMarketplaceIdList ( ) ) { $ marketplaceIdList = $ request -> getMarketplaceIdList ( ) ; foreach ( $ marketplaceIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'MarketplaceIdList.Id.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetFeedType ( ) ) { $ parameters [ 'FeedType' ] = $ request -> getFeedType ( ) ; } if ( $ request -> isSetPurgeAndReplace ( ) ) { $ parameters [ 'PurgeAndReplace' ] = $ request -> getPurgeAndReplace ( ) ? "true" : "false" ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } $ headers = array ( ) ; array_push ( $ headers , "Content-Type: " . $ request -> getContentType ( ) -> toString ( ) ) ; return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ headers ) ; }
9404	protected static function prepare ( Collection & $ collection , $ component ) { $ instance = new $ component ; $ type = $ instance -> type ( ) ; if ( empty ( $ type ) === false ) { $ parameters = array ( $ instance -> get ( ) ) ; $ type === 'http' && $ parameters = $ instance -> get ( ) ; $ class = array ( $ collection , 'set' . ucfirst ( $ type ) ) ; call_user_func_array ( $ class , $ parameters ) ; } return $ instance ; }
6596	protected function getSummary ( array $ lines ) { $ summary = '' ; foreach ( $ lines as $ line ) { if ( ! $ line ) { if ( $ summary ) { break ; } continue ; } if ( $ line [ 0 ] == '@' ) { break ; } $ summary .= $ line . "\n" ; if ( substr ( $ line , - 1 ) == '.' ) { break ; } } return trim ( $ summary ) ; }
914	public static function calculateBitmask ( array $ options ) { $ bitmask = 0 ; foreach ( $ options as $ optionName ) { if ( \ defined ( $ optionName ) ) { $ bitmask |= \ constant ( $ optionName ) ; } } return $ bitmask ; }
6547	public function close ( ) { $ writer = \ PHPExcel_IOFactory :: createWriter ( $ this -> container , $ this -> format ) ; $ writer -> save ( $ this -> resourcepath ) ; }
7853	protected function resolveRequest ( ) { if ( class_exists ( $ request = $ this -> inflector -> getRequest ( ) ) ) { return $ this -> container -> make ( $ request ) ; } return $ this -> container -> make ( 'Illuminate\Http\Request' ) ; }
9686	public function implode ( $ value , $ glue = null ) { $ new_collection = new Collection ( $ this -> toArray ( ) ) ; $ first = $ new_collection -> first ( ) ; if ( is_array ( $ first ) || is_object ( $ first ) ) { return implode ( $ glue , $ new_collection -> pluck ( $ value ) -> all ( ) ) ; } return implode ( $ value , $ new_collection -> all ( ) ) ; }
3958	protected function registerAssets ( $ objSettings ) { if ( ! $ objSettings ) { return ; } $ arrCss = $ objSettings -> get ( 'additionalCss' ) ; foreach ( ( array ) $ arrCss as $ arrFile ) { if ( $ arrFile [ 'published' ] ) { $ GLOBALS [ 'TL_CSS' ] [ md5 ( $ arrFile [ 'file' ] ) ] = $ arrFile [ 'file' ] ; } } $ arrJs = $ objSettings -> get ( 'additionalJs' ) ; foreach ( ( array ) $ arrJs as $ arrFile ) { if ( $ arrFile [ 'published' ] ) { $ GLOBALS [ 'TL_JAVASCRIPT' ] [ md5 ( $ arrFile [ 'file' ] ) ] = $ arrFile [ 'file' ] ; } } }
4680	public function render ( ContainerInterface $ di = null ) { switch ( $ this -> type ) { case "file" : if ( $ di -> has ( "viewRenderFile" ) ) { $ viewRender = $ di -> get ( "viewRenderFile" ) ; } else { $ viewRender = new ViewRenderFile ( $ di ) ; $ viewRender -> setDI ( $ di ) ; } $ viewRender -> render ( $ this -> template , $ this -> templateData ) ; break ; case "callback" : if ( ! is_callable ( $ this -> template ) ) { throw new Exception ( "View is expecting a valid callback, provided callback seems to not be a callable." ) ; } echo call_user_func ( $ this -> template , $ this -> templateData ) ; break ; case "string" : echo $ this -> template ; break ; case "empty" : break ; default : throw new Exception ( "Not a valid template type: '{$this->type}'." ) ; } }
6322	private function parseConfiguration ( array $ config ) { $ this -> currentEnvironment = 'dev' ; foreach ( $ config as $ environment => $ connection ) { if ( isset ( $ connection [ 'dsn' ] ) ) { $ this -> dsn [ $ environment ] = $ connection [ 'dsn' ] ; } else { $ this -> dsn [ $ environment ] = sprintf ( 'pgsql:host=%s; port=%s; dbname=%s;' , $ connection [ 'host' ] , $ connection [ 'port' ] , $ connection [ 'database' ] ) ; } $ this -> username [ $ environment ] = $ connection [ 'username' ] ; $ this -> password [ $ environment ] = $ connection [ 'password' ] ; } }
6010	public function setDateRange ( $ dateRange ) { if ( $ dateRange instanceof DateTimeRange ) { $ this -> dateRange = $ dateRange ; } elseif ( is_array ( $ dateRange ) ) { $ this -> dateRange = new DateTimeRange ( $ dateRange ) ; } else { $ this -> dateRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
5616	public function compareChildren ( $ a , $ b ) { if ( $ this -> _children [ $ a ] -> getTotalSize ( ) > $ this -> _children [ $ b ] -> getTotalSize ( ) ) { $ node_a = $ this -> _children [ $ a ] ; $ node_b = $ this -> _children [ $ b ] ; $ this -> _children [ $ a ] = $ node_b ; $ this -> _children [ $ b ] = $ node_a ; } }
12532	public function update ( array $ deviceIdentifier , $ comment ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'comment' => $ comment , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_UPDATE , $ params ] ) ; }
11653	protected function _initDbResource ( ) { $ registry = $ this -> getPluginResource ( 'db' ) ; if ( ! $ registry ) { return ; } $ options = $ registry -> getOptions ( ) ; if ( array_key_exists ( 'dsn' , $ options ) && '' !== $ options [ 'dsn' ] ) { $ options [ 'params' ] = array_replace ( $ options [ 'params' ] , $ this -> _parseDsn ( $ options [ 'dsn' ] ) ) ; } $ registry -> setOptions ( $ options ) ; }
3562	protected function hasMutator ( $ value , $ dir = 'setter' , $ type = null ) { return ( bool ) $ this -> getMutator ( $ value , $ dir , $ type ) ; }
2658	public function getResponse ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/response_object/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
2368	public static function extractEmail ( $ strString , $ strAllowedTags = '' ) { $ arrEmails = array ( ) ; if ( strpos ( $ strString , '@' ) === false ) { return $ arrEmails ; } preg_match_all ( '/mailto:(?:[^\x00-\x20\x22\x40\x7F]{1,64}+|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , $ strString , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( 'mailto:' , '' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } unset ( $ strEmail ) ; $ strString = preg_replace_callback ( '@</?([^\s<>/]*)@' , function ( $ matches ) use ( $ strAllowedTags ) { if ( $ matches [ 1 ] == '' || stripos ( $ strAllowedTags , '<' . strtolower ( $ matches [ 1 ] ) . '>' ) === false ) { $ matches [ 0 ] = str_replace ( '<' , '&lt;' , $ matches [ 0 ] ) ; } return $ matches [ 0 ] ; } , $ strString ) ; preg_match_all ( '/(?:[^\x00-\x20\x22\x40\x7F]{1,64}|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , strip_tags ( $ strString ) , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( '&lt;' , '<' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } return array_unique ( $ arrEmails ) ; }
11693	public function run ( ) : Robo \ Result { $ result = $ this -> collectionBuilder ( ) -> taskFilesystemStack ( ) -> mkdir ( $ this -> destination -> getPath ( ) ) -> touch ( $ this -> destination -> getPathname ( ) ) -> run ( ) -> wasSuccessful ( ) ; if ( ! $ result ) { throw new RuntimeException ( 'We can not write to the destination file: ' . $ this -> destination -> getPathname ( ) ) ; } $ asset_contents = '' ; foreach ( $ this -> source as $ file ) { $ this -> printTaskInfo ( 'Compiling - <info>' . $ file . '</info>' ) ; $ asset_contents .= $ this -> getCompiler ( new SplFileInfo ( $ file ) ) -> compile ( ) ; } if ( $ this -> cachebust === true ) { $ this -> bustCacheBalls ( $ asset_contents ) ; } $ this -> writeAsset ( $ asset_contents ) ; return \ Robo \ Result :: success ( $ this ) ; }
8020	public function set ( string $ content ) { $ parsed = $ this -> parseContent ( $ content ) ; $ this -> id = $ parsed -> id ; $ this -> infoUri = $ parsed -> infoUri ; $ this -> partialCancelUri = $ parsed -> partialCancelUri ?? null ; $ this -> nextUri = $ parsed -> nextUri ?? null ; $ this -> columns = [ ] ; if ( isset ( $ parsed -> columns ) ) { $ this -> columnTransfer ( $ parsed -> columns ) ; } $ this -> data = $ parsed -> data ?? [ ] ; $ this -> stats = isset ( $ parsed -> stats ) ? $ this -> statsTransfer ( $ parsed -> stats ) : null ; $ this -> error = isset ( $ parsed -> error ) ? $ this -> errorTransfer ( $ parsed -> error ) : null ; }
8767	protected function registerBaseBindings ( ) { static :: setInstance ( $ this ) ; $ this -> instance ( 'app' , $ this ) ; $ this -> instance ( Container :: class , $ this ) ; $ this -> singleton ( 'config' , function ( ) { return new \ Nur \ Config \ Config ( $ this -> config ) ; } ) ; $ this -> singleton ( 'files' , function ( ) { return new Filesystem ; } ) ; $ this -> instance ( PackageManifest :: class , new PackageManifest ( new Filesystem , $ this -> basePath ( ) , $ this -> getCachedPackagesPath ( ) ) ) ; }
10327	function fromXML ( $ xmlElement ) { $ this -> author = $ xmlElement -> author ; $ this -> countContacts = $ xmlElement -> count_contacts ; $ this -> countRules = $ xmlElement -> count_rules ; $ this -> created = $ xmlElement -> created ; $ this -> id = $ xmlElement -> id ; $ this -> name = $ xmlElement -> name ; $ this -> state = $ xmlElement -> state ; if ( $ xmlElement -> rules ) { $ rules = $ xmlElement -> rules ; foreach ( $ rules as $ rule ) { array_push ( $ this -> rules , new Rule ( $ rule -> is_customfield , $ rule -> field , $ rule -> operator , $ rule -> value , $ rule -> type ) ) ; } } }
12096	public function generateSignCode ( array $ params , $ secret ) { ksort ( $ params ) ; if ( isset ( $ params [ self :: SIGN_NAMESPACE ] ) ) { unset ( $ params [ self :: SIGN_NAMESPACE ] ) ; } return md5 ( implode ( '' , $ params ) . $ secret ) ; }
3180	public function useClientContainer ( ) { if ( $ this -> hasOption ( self :: OPTION_CLIENT_TESTRUNNER ) ) { return $ this -> getOption ( self :: OPTION_CLIENT_TESTRUNNER ) ; } else { $ itemModel = $ this -> getServiceLocator ( ) -> get ( ItemModel :: SERVICE_ID ) ; return $ itemModel -> getCompilerClass ( ) == QtiJsonItemCompiler :: class ; } }
93	public function filter ( $ relativePath , $ exclude ) { foreach ( $ this -> excludePatterns as $ patternData ) { list ( $ pattern , $ negate , $ stripLeadingSlash ) = $ patternData ; if ( $ stripLeadingSlash ) { $ path = substr ( $ relativePath , 1 ) ; } else { $ path = $ relativePath ; } if ( preg_match ( $ pattern , $ path ) ) { $ exclude = ! $ negate ; } } return $ exclude ; }
5949	public function setResults ( array $ results ) { $ this -> results = [ ] ; foreach ( $ results as $ item ) { switch ( $ item [ 'discriminatorId' ] ) { case ObjectResponse :: DISCRIMINATOR_FOLDER : $ this -> addFolderResponse ( $ item ) ; break ; case ObjectResponse :: DISCRIMINATOR_MEDIA : default : $ this -> addMediaResponse ( $ item ) ; break ; } } return $ this ; }
11826	public function remove ( $ encoding ) { $ str = file_get_contents ( $ this -> uri ) ; return file_put_contents ( $ this -> uri , substr ( $ str , ( strlen ( $ this -> getBom ( $ encoding ) ) ) ) ) ; }
2790	public static function getMutation ( array & $ tokens , $ index ) { $ num = ( float ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1.0 ; } elseif ( $ num == 1 ) { $ replace = 0.0 ; } elseif ( $ num < 2 ) { $ replace = $ num + 1 ; } else { $ replace = 1.0 ; } $ tokens [ $ index ] = [ T_DNUMBER , sprintf ( "%.2f" , $ replace ) ] ; }
356	public function init ( ) { parent :: init ( ) ; if ( $ this -> enableCoreCommands ) { foreach ( $ this -> coreCommands ( ) as $ id => $ command ) { if ( ! isset ( $ this -> controllerMap [ $ id ] ) ) { $ this -> controllerMap [ $ id ] = $ command ; } } } if ( ! isset ( $ this -> controllerMap [ 'help' ] ) ) { $ this -> controllerMap [ 'help' ] = 'yii\console\controllers\HelpController' ; } }
822	private function fixSemicolonAfterCurlyBraceClose ( Tokens $ tokens , $ index , $ curlyCloseIndex ) { static $ beforeCurlyOpeningKinds = null ; if ( null === $ beforeCurlyOpeningKinds ) { $ beforeCurlyOpeningKinds = [ T_ELSE , T_FINALLY , T_NAMESPACE , T_OPEN_TAG ] ; } $ curlyOpeningIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ curlyCloseIndex ) ; $ beforeCurlyOpening = $ tokens -> getPrevMeaningfulToken ( $ curlyOpeningIndex ) ; if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( $ beforeCurlyOpeningKinds ) || $ tokens [ $ beforeCurlyOpening ] -> equalsAny ( [ ';' , '{' , '}' ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( T_STRING ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ beforeCurlyOpening ) ; while ( $ tokens [ $ classyTest ] -> equals ( ',' ) || $ tokens [ $ classyTest ] -> isGivenKind ( [ T_STRING , T_NS_SEPARATOR , T_EXTENDS , T_IMPLEMENTS ] ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ classyTest ) ; } $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; if ( $ tokens [ $ classyTest ] -> isGivenKind ( T_NAMESPACE ) || ( $ tokens [ $ classyTest ] -> isClassy ( ) && ! $ tokensAnalyzer -> isAnonymousClass ( $ classyTest ) ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } return ; } if ( ! $ tokens [ $ beforeCurlyOpening ] -> equals ( ')' ) ) { return ; } $ openingBrace = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ beforeCurlyOpening ) ; $ beforeOpeningBrace = $ tokens -> getPrevMeaningfulToken ( $ openingBrace ) ; if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( [ T_IF , T_ELSEIF , T_FOR , T_FOREACH , T_WHILE , T_SWITCH , T_CATCH , T_DECLARE ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( T_STRING ) ) { $ beforeString = $ tokens -> getPrevMeaningfulToken ( $ beforeOpeningBrace ) ; if ( $ tokens [ $ beforeString ] -> isGivenKind ( T_FUNCTION ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } } }
1271	public function noCandidates ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> NoCandidatesIndicator ) ; }
10145	private function makeKey ( $ block , $ valContext ) { $ pwarray = str_repeat ( "\0" , 64 ) ; for ( $ i = 0 ; $ i < 5 ; ++ $ i ) { $ pwarray [ $ i ] = $ valContext [ $ i ] ; } $ pwarray [ 5 ] = chr ( $ block & 0xff ) ; $ pwarray [ 6 ] = chr ( ( $ block >> 8 ) & 0xff ) ; $ pwarray [ 7 ] = chr ( ( $ block >> 16 ) & 0xff ) ; $ pwarray [ 8 ] = chr ( ( $ block >> 24 ) & 0xff ) ; $ pwarray [ 9 ] = "\x80" ; $ pwarray [ 56 ] = "\x48" ; $ md5 = new Xls \ MD5 ( ) ; $ md5 -> add ( $ pwarray ) ; $ s = $ md5 -> getContext ( ) ; return new Xls \ RC4 ( $ s ) ; }
10390	public static function loadString ( $ xmlString ) { $ xmlFile = tempnam ( self :: getSysTempDir ( ) , 'xml_' ) ; file_put_contents ( $ xmlFile , $ xmlString ) ; $ xml = self :: parseXml ( $ xmlFile ) ; unlink ( $ xmlFile ) ; return $ xml ; }
11833	public function doRestore ( ModulesEvent $ event ) { $ cache = $ this -> getCache ( ) ; $ data = $ cache -> get ( 'config' ) ; if ( $ data ) { $ services = $ this -> getServices ( ) ; $ services -> set ( 'Config' , $ data ) ; $ event -> stopPropagation ( true ) ; } }
9334	public function deg ( ) { if ( $ this -> original -> type == self :: TYPE_DEG ) { return $ this -> original -> value ; } return rad2deg ( $ this -> float_rad ) ; }
11575	public function actionRegister ( ) { if ( ! $ this -> module -> enableRegistration ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( RegistrationForm :: className ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> register ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Your account has been created' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'register' , [ 'model' => $ model , 'module' => $ this -> module , ] ) ; }
7292	public function get_users_by_meta ( $ meta_key , $ meta_value = '' , $ meta_compare = '' , $ include_empty = FALSE ) { if ( $ include_empty ) { if ( in_array ( $ meta_compare , array ( '<>' , '!=' ) ) ) { $ meta_compare = '=' ; } else { $ meta_compare = '!=' ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'ID' ) ) ; $ exclude_users = $ query -> get_results ( ) ; $ query = new WP_User_Query ( array ( 'fields' => 'all_with_meta' , 'exclude' => $ exclude_users ) ) ; return $ query -> get_results ( ) ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'all_with_meta' ) ) ; return $ query -> get_results ( ) ; }
7247	protected function purge ( ShipmentInterface $ shipment ) { foreach ( $ shipment -> getItems ( ) as $ item ) { if ( 0 == $ item -> getAvailable ( ) ) { $ shipment -> removeItem ( $ item ) ; } } }
8311	public function applyDefaults ( $ config , array $ defaults , $ depth = 1 ) { if ( ! is_int ( $ depth ) || $ depth < 0 ) { throw new \ InvalidArgumentException ( "Depth must be non-negative integer." ) ; } if ( ! is_array ( $ config ) ) { return $ defaults ; } if ( $ depth === 0 ) { $ config += $ defaults ; return $ config ; } foreach ( $ defaults as $ key => $ defaultValue ) { if ( ! isset ( $ config [ $ key ] ) ) { $ config [ $ key ] = $ defaultValue ; continue ; } if ( is_array ( $ defaultValue ) ) { if ( is_array ( $ config [ $ key ] ) ) { $ config [ $ key ] = $ this -> applyDefaults ( $ config [ $ key ] , $ defaultValue , $ depth - 1 ) ; } else { throw new ConfigurationException ( "Configuration key " . $ key . " expects an array, a scalar value found." ) ; } } else { if ( is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( "Configuration key " . $ key . " expects scalar, an array found." ) ; } } } return $ config ; }
5291	public static function simpleDetect ( $ text ) { $ detections = self :: detect ( $ text ) ; if ( count ( $ detections ) > 0 ) return $ detections [ 0 ] -> language ; else return null ; }
11459	public function attachFile ( string $ sFileName , string $ sContent , string $ sType ) : bool { $ this -> _aAttachments [ ] = array ( "name" => $ sFileName , "content" => $ sContent , "type" => $ sType ) ; return true ; }
9137	public function call ( callable $ callable , array $ args = [ ] ) { $ args = $ this -> resolveArguments ( $ args ) ; $ reflection = $ this -> reflectCallable ( $ callable ) ; return call_user_func_array ( $ callable , $ this -> getParameters ( $ reflection , $ args ) ) ; }
6854	private function findPaymentTokens ( PaymentInterface $ payment ) { $ identity = $ this -> getPaymentIdentity ( $ payment ) ; $ tokens = $ this -> payum -> getTokenStorage ( ) -> findBy ( [ 'details' => $ identity , ] ) ; return $ tokens ; }
2343	protected function implodeRecursive ( $ var , $ binary = false ) { if ( ! \ is_array ( $ var ) ) { return $ binary ? StringUtil :: binToUuid ( $ var ) : $ var ; } elseif ( ! \ is_array ( current ( $ var ) ) ) { if ( $ binary ) { $ var = array_map ( function ( $ v ) { return $ v ? StringUtil :: binToUuid ( $ v ) : '' ; } , $ var ) ; } return implode ( ', ' , $ var ) ; } else { $ buffer = '' ; foreach ( $ var as $ k => $ v ) { $ buffer .= $ k . ": " . $ this -> implodeRecursive ( $ v ) . "\n" ; } return trim ( $ buffer ) ; } }
9473	public function deleteFaild ( $ message = null ) { if ( is_null ( $ message ) ) $ message = $ this -> config [ 'fail' ] [ 'delete' ] ; return $ this -> setStatusCode ( 447 ) -> setStatusText ( 'fail' ) -> setErrorCode ( 5447 ) -> respondWithMessage ( $ message ) ; }
4328	public static function parseAttribString ( $ str , $ dataDecode = true ) { $ attribs = array ( ) ; $ regexAttribs = '/\b([\w\-]+)\b(?: \s*=\s*(["\'])(.*?)\\2 | \s*=\s*(\S+) )?/xs' ; \ preg_match_all ( $ regexAttribs , $ str , $ matches ) ; $ keys = \ array_map ( 'strtolower' , $ matches [ 1 ] ) ; $ values = \ array_replace ( $ matches [ 3 ] , \ array_filter ( $ matches [ 4 ] , 'strlen' ) ) ; foreach ( $ keys as $ i => $ k ) { $ attribs [ $ k ] = $ values [ $ i ] ; if ( \ in_array ( $ k , self :: $ htmlBoolAttr ) ) { $ attribs [ $ k ] = true ; } } \ ksort ( $ attribs ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_string ( $ v ) ) { $ attribs [ $ k ] = \ htmlspecialchars_decode ( $ v ) ; } $ isDataAttrib = \ strpos ( $ k , 'data-' ) === 0 ; if ( $ isDataAttrib && $ dataDecode ) { $ val = $ attribs [ $ k ] ; $ attribs [ $ k ] = \ json_decode ( $ attribs [ $ k ] , true ) ; if ( $ attribs [ $ k ] === null && $ val !== 'null' ) { $ attribs [ $ k ] = \ json_decode ( '"' . $ val . '"' , true ) ; } } } return $ attribs ; }
11794	public function setBcc ( $ mail = '' , $ name = null ) { $ this -> bcc = Helper :: deduplicate ( array_merge ( $ this -> bcc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
10680	protected function generateURLSegment ( $ title ) { $ filter = URLSegmentFilter :: create ( ) ; $ t = $ filter -> filter ( $ title ) ; if ( ! $ t || $ t == '-' || $ t == '-1' ) { $ t = "{$this->owner->ClassName}-{$this->owner->ID}" ; } else { $ class = $ this -> owner -> ClassName ; $ obj = $ class :: get ( ) -> filter ( array ( "URLSegment" => $ t ) ) -> exclude ( array ( "ID" => $ this -> owner -> ID ) ) -> first ( ) ; if ( $ obj ) { $ t .= "-{$this->owner->ID}" ; } } return $ t ; }
9590	public function radioWithGap ( $ options = [ ] , $ enclosedByLabel = true ) { Html :: addCssClass ( $ options , $ this -> radioGapCssClass ) ; return self :: radio ( $ options , $ enclosedByLabel ) ; }
5775	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ roles = $ this -> mapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) ) ; } catch ( QueryFailureException $ e ) { $ roles = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ roles ) ; }
5086	public function startTransaction ( ) : bool { if ( $ this -> isInTransaction ) throw new AlreadyInTransactionException ( ) ; $ this -> isInTransaction = $ this -> executeDirect ( 'START TRANSACTION' ) ; return $ this -> isInTransaction ; }
5963	public function serverGroupGetProfiles ( ) { $ profiles = array ( ) ; foreach ( $ this -> serverGroupList ( ) as $ sgid => $ sgroup ) { if ( $ sgroup [ "type" ] != TeamSpeak3 :: GROUP_DBTYPE_REGULAR ) { continue ; } $ profiles [ $ sgid ] = array ( "b_permission_modify_power_ignore" => 0 , "i_group_needed_member_add_power" => 0 , "i_group_member_add_power" => 0 , "i_group_needed_member_remove_power" => 0 , "i_group_member_remove_power" => 0 , "i_needed_modify_power_count" => 0 , "i_needed_modify_power_total" => 0 , "i_permission_modify_power" => 0 , "i_group_needed_modify_power" => 0 , "i_group_modify_power" => 0 , "i_client_needed_modify_power" => 0 , "i_client_modify_power" => 0 , "b_virtualserver_servergroup_create" => 0 , "b_virtualserver_servergroup_delete" => 0 , "b_client_ignore_bans" => 0 , "b_client_ignore_antiflood" => 0 , "b_group_is_permanent" => 0 , "i_client_needed_ban_power" => 0 , "i_client_needed_kick_power" => 0 , "i_client_needed_move_power" => 0 , "i_client_talk_power" => 0 , "__sgid" => $ sgid , "__name" => $ sgroup -> toString ( ) , "__node" => $ sgroup , ) ; try { $ perms = $ this -> serverGroupPermList ( $ sgid , true ) ; $ grant = isset ( $ perms [ "i_permission_modify_power" ] ) ? $ perms [ "i_permission_modify_power" ] [ "permvalue" ] : null ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0x501 ) { throw $ e ; } $ perms = array ( ) ; $ grant = null ; } foreach ( $ perms as $ permsid => $ perm ) { if ( in_array ( $ permsid , array_keys ( $ profiles [ $ sgid ] ) ) ) { $ profiles [ $ sgid ] [ $ permsid ] = $ perm [ "permvalue" ] ; } elseif ( StringHelper :: factory ( $ permsid ) -> startsWith ( "i_needed_modify_power_" ) ) { if ( ! $ grant || $ perm [ "permvalue" ] > $ grant ) { continue ; } $ profiles [ $ sgid ] [ "i_needed_modify_power_total" ] = $ profiles [ $ sgid ] [ "i_needed_modify_power_total" ] + $ perm [ "permvalue" ] ; $ profiles [ $ sgid ] [ "i_needed_modify_power_count" ] ++ ; } } } array_multisort ( $ profiles , SORT_DESC ) ; return $ profiles ; }
2556	protected static function loadObFees ( $ obFees , $ obFeeRefs ) { $ opt = [ ] ; if ( ! empty ( $ obFees ) ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_OB_FEES ) ; $ po -> penDisInformation = new PenDisInformation ( PenDisInformation :: QUAL_OB_FEES , $ obFees ) ; if ( ! empty ( $ obFeeRefs ) ) { $ po -> paxSegTstReference = new PaxSegTstReference ( $ obFeeRefs ) ; } $ opt [ ] = $ po ; } return $ opt ; }
652	public function execute ( ) { $ sql = $ this -> getSql ( ) ; list ( $ profile , $ rawSql ) = $ this -> logQuery ( __METHOD__ ) ; if ( $ sql == '' ) { return 0 ; } $ this -> prepare ( false ) ; try { $ profile and Yii :: beginProfile ( $ rawSql , __METHOD__ ) ; $ this -> internalExecute ( $ rawSql ) ; $ n = $ this -> pdoStatement -> rowCount ( ) ; $ profile and Yii :: endProfile ( $ rawSql , __METHOD__ ) ; $ this -> refreshTableSchema ( ) ; return $ n ; } catch ( Exception $ e ) { $ profile and Yii :: endProfile ( $ rawSql , __METHOD__ ) ; throw $ e ; } }
9905	private function updateSingleCellReference ( $ pCellReference = 'A1' , $ pBefore = 'A1' , $ pNumCols = 0 , $ pNumRows = 0 ) { if ( Coordinate :: coordinateIsRange ( $ pCellReference ) ) { throw new Exception ( 'Only single cell references may be passed to this method.' ) ; } list ( $ beforeColumn , $ beforeRow ) = Coordinate :: coordinateFromString ( $ pBefore ) ; list ( $ newColumn , $ newRow ) = Coordinate :: coordinateFromString ( $ pCellReference ) ; $ updateColumn = ( ( $ newColumn [ 0 ] != '$' ) && ( $ beforeColumn [ 0 ] != '$' ) && ( Coordinate :: columnIndexFromString ( $ newColumn ) >= Coordinate :: columnIndexFromString ( $ beforeColumn ) ) ) ; $ updateRow = ( ( $ newRow [ 0 ] != '$' ) && ( $ beforeRow [ 0 ] != '$' ) && $ newRow >= $ beforeRow ) ; if ( $ updateColumn ) { $ newColumn = Coordinate :: stringFromColumnIndex ( Coordinate :: columnIndexFromString ( $ newColumn ) + $ pNumCols ) ; } if ( $ updateRow ) { $ newRow = $ newRow + $ pNumRows ; } return $ newColumn . $ newRow ; }
6439	public function getUserProfile ( ) { $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] , $ this -> access_token [ 'oauth_token' ] , $ this -> access_token [ 'oauth_token_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ user = $ connection -> get ( "account/verify_credentials" ) ; return array ( 'userid' => $ user -> id , 'name' => $ user -> screen_name , 'imageurl' => $ user -> profile_image_url ) ; }
4863	public function retry ( JobInterface $ job , array $ options = [ ] ) { $ tried = $ job -> getMetadata ( 'mongoqueue.tries' , 0 ) + 1 ; $ job -> setMetaData ( 'mongoqueue.tries' , $ tried ) ; $ options [ 'tried' ] = $ tried ; $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectID ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
10160	private function readMsoDrawing ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingData .= $ recordData ; }
10866	protected function createNewInst ( ) { $ classReflection = new \ ReflectionClass ( $ this -> instClass ) ; if ( $ this -> constructorArgs === null ) { return $ classReflection -> newInstance ( ) ; } else { return $ classReflection -> newInstanceArgs ( $ this -> concstructorArgs ) ; } }
3800	public function getMetaModel ( EnvironmentInterface $ interface ) { $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'd.pid' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel_dcasetting' , 's' , '(d.id=s.pid)' ) -> where ( '(s.id=:id)' ) -> setParameter ( 'id' , ModelId :: fromSerialized ( $ interface -> getInputProvider ( ) -> getParameter ( 'pid' ) ) -> getId ( ) ) -> execute ( ) ; if ( $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId = $ metaModelId -> fetchColumn ( ) ) ) { return $ this -> factory -> getMetaModel ( $ tableName ) ; } throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelId ) ; }
11234	protected function checkValue ( $ value , $ subject , $ reference ) { if ( is_null ( $ value ) ) { return $ subject ; } elseif ( $ subject != $ reference ) { throw new RuntimeException ( Message :: get ( Message :: MSG_REF_MALFORMED , $ reference ) , Message :: MSG_REF_MALFORMED ) ; } else { return $ value ; } }
2559	protected function loadPaymentSupplementaryData ( MopInfo $ options ) { foreach ( $ options -> paySupData as $ paySupData ) { $ this -> paymentModule -> paymentSupplementaryData [ ] = new PaymentSupplementaryData ( $ paySupData -> function , $ paySupData -> data ) ; } }
3832	protected function validateWidget ( $ widget , $ value ) { if ( null === $ value ) { return ; } $ widget -> setInputCallback ( function ( ) use ( $ value ) { return $ value ; } ) ; $ widget -> validate ( ) ; }
4743	public function validateOptIn ( ) { $ optInValue = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'rvw_oegdproptin' ) ; if ( $ this -> isReviewOptInValidationRequired ( ) && ! $ optInValue ) { return false ; } return true ; }
4501	public function getElementsByClassName ( string $ names ) : HTMLCollection { $ namesArray = explode ( " " , $ names ) ; $ dots = "." . implode ( "." , $ namesArray ) ; return $ this -> css ( $ dots ) ; }
322	public static function pluralize ( $ word ) { if ( isset ( static :: $ specials [ $ word ] ) ) { return static :: $ specials [ $ word ] ; } foreach ( static :: $ plurals as $ rule => $ replacement ) { if ( preg_match ( $ rule , $ word ) ) { return preg_replace ( $ rule , $ replacement , $ word ) ; } } return $ word ; }
11738	protected function normalize ( $ scheme = true , $ www = true ) { $ address = $ this -> address ; if ( $ scheme && null === $ this -> get ( self :: PARSE_SCHEME ) ) { $ address = sprintf ( 'http://%s' , $ this -> address ) ; } elseif ( ! $ scheme && $ this -> get ( self :: PARSE_SCHEME ) ) { $ address = str_replace ( $ this -> get ( self :: PARSE_SCHEME ) . '://' , '' , $ this -> address ) ; } if ( false === $ www && 0 === strpos ( $ this -> get ( self :: PARSE_HOST ) , 'www.' ) ) { $ address = substr ( $ address , 4 ) ; } return $ address ; }
3239	private function resetCalculations ( ) { $ this -> shopCalculations = null ; if ( Config :: get ( 'shop.cache_calculations' ) ) { Cache :: forget ( $ this -> calculationsCacheKey ) ; } }
6156	public function redirect ( string $ url ) : object { return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
105	public function watch2OnHighest ( Decisions $ decisions ) { $ literals = $ this -> rule -> getLiterals ( ) ; if ( count ( $ literals ) < 3 ) { return ; } $ watchLevel = 0 ; foreach ( $ literals as $ literal ) { $ level = $ decisions -> decisionLevel ( $ literal ) ; if ( $ level > $ watchLevel ) { $ this -> watch2 = $ literal ; $ watchLevel = $ level ; } } }
3783	private function getConditionAttribute ( $ settingId ) { $ setting = $ this -> getRow ( $ settingId , 'tl_metamodel_dcasetting' ) ; if ( $ setting -> dcatype == 'attribute' ) { $ attribute = ( object ) $ this -> getRow ( $ setting -> attr_id , 'tl_metamodel_attribute' ) ; $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ attribute -> pid ) ; $ attribute = $ this -> factory -> getMetaModel ( $ metaModelName ) -> getAttributeById ( $ attribute -> id ) ; if ( $ attribute ) { return $ attribute -> getName ( ) ; } } else { $ title = StringUtil :: deserialize ( $ setting -> legendtitle , true ) ; return isset ( $ title [ $ GLOBALS [ 'TL_LANGUAGE' ] ] ) ? $ title [ $ GLOBALS [ 'TL_LANGUAGE' ] ] : current ( $ title ) ; } return 'unknown ' . $ setting -> dcatype ; }
3463	public function handle ( ServerRequestInterface $ request ) : ResponseInterface { $ response = $ this -> getMiddlewarePipe ( ) -> handle ( $ request ) ; return $ response ; }
8911	protected function apply_soft_delete_filter ( ) { if ( $ this -> soft_delete && $ this -> _temporary_with_deleted !== TRUE ) { if ( $ this -> _temporary_only_deleted ) { $ where = "`{$this->deleted_at_key}` <= NOW()" ; } else { $ where = sprintf ( '(%1$s > NOW() OR %1$s IS NULL OR %1$s = \'0000-00-00 00:00:00\')' , $ this -> deleted_at_key ) ; } $ this -> _database -> where ( $ where ) ; } }
6688	public function isPostCheck ( $ redirectUrl = null ) { if ( $ this -> getRequest ( ) -> isPost ) { return true ; } if ( is_null ( $ redirectUrl ) ) { return false ; } $ this -> sendTerminalResponse ( $ redirectUrl ) ; }
12884	public function getKeyTranslation ( Model $ foreignObject , $ key = null ) { if ( isset ( $ key ) ) { return $ this -> internalGetKeyTranslation ( $ foreignObject , $ key ) ; } foreach ( $ this -> keys as $ keyName => $ keyField ) { if ( ! empty ( $ foreignObject -> { $ keyField } ) ) { $ key = $ this -> generateKey ( $ foreignObject , $ keyName , $ foreignObject -> { $ keyField } ) ; $ result = $ this -> internalGetKeyTranslation ( $ foreignObject , $ key ) ; if ( ! empty ( $ result ) ) { return $ result ; } } } return false ; }
4285	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; if ( $ this -> json [ 'rows' ] ) { \ array_unshift ( $ this -> json [ 'rows' ] , array ( array ( 'PHP' , isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ) , null , 'groupCollapsed' , ) ) ; \ array_push ( $ this -> json [ 'rows' ] , array ( array ( ) , null , 'groupEnd' , ) ) ; $ encoded = $ this -> encode ( $ this -> json ) ; if ( \ strlen ( $ encoded ) > 250000 ) { $ this -> debug -> warn ( 'chromeLogger: output limit exceeded' ) ; } else { $ event [ 'headers' ] [ ] = array ( self :: HEADER_NAME , $ encoded ) ; } } $ this -> data = array ( ) ; $ this -> json [ 'rows' ] = array ( ) ; }
11	private function mockLocalRepositories ( RepositoryManager $ rm ) { $ packages = array ( ) ; foreach ( $ rm -> getLocalRepository ( ) -> getPackages ( ) as $ package ) { $ packages [ ( string ) $ package ] = clone $ package ; } foreach ( $ packages as $ key => $ package ) { if ( $ package instanceof AliasPackage ) { $ alias = ( string ) $ package -> getAliasOf ( ) ; $ packages [ $ key ] = new AliasPackage ( $ packages [ $ alias ] , $ package -> getVersion ( ) , $ package -> getPrettyVersion ( ) ) ; } } $ rm -> setLocalRepository ( new InstalledArrayRepository ( $ packages ) ) ; }
2561	public function loadSpecificChanges ( $ changeTicketing , $ changeQueueing , $ changeOptQueueEl ) { if ( $ changeTicketing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_TICKETING_OFFICE ) ; } if ( $ changeQueueing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_QUEUEING_OFFICE ) ; } if ( $ changeOptQueueEl ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_OPT_QUEUE_ELEMENT ) ; } }
3443	public function offsetExists ( $ offset ) { return $ this -> getAccessor ( $ offset ) || $ this -> getAccessorForLanguageField ( $ offset ) ? true : isset ( $ this -> fields [ $ offset ] ) ; }
603	protected function startsWithAnyLongest ( array & $ with , $ caseSensitive , & $ length = null , & $ content = null ) { if ( empty ( $ with ) ) { return false ; } if ( ! is_array ( reset ( $ with ) ) ) { usort ( $ with , function ( $ string1 , $ string2 ) { return mb_strlen ( $ string2 , 'UTF-8' ) - mb_strlen ( $ string1 , 'UTF-8' ) ; } ) ; $ map = [ ] ; foreach ( $ with as $ string ) { $ map [ mb_strlen ( $ string , 'UTF-8' ) ] [ $ caseSensitive ? $ string : mb_strtoupper ( $ string , 'UTF-8' ) ] = true ; } $ with = $ map ; } foreach ( $ with as $ testLength => $ testValues ) { $ content = $ this -> substring ( $ testLength , $ caseSensitive ) ; if ( isset ( $ testValues [ $ content ] ) ) { $ length = $ testLength ; return true ; } } return false ; }
4123	public function generateProxyClasses ( array $ classes , $ toDir = null ) { $ proxyDir = $ toDir ? : $ this -> proxyDir ; $ proxyDir = rtrim ( $ proxyDir , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; foreach ( $ classes as $ class ) { if ( $ class -> isMappedSuperclass ) { continue ; } $ proxyFileName = $ this -> getProxyFileName ( $ class -> name , $ toDir ) ; $ this -> generateProxyClass ( $ class , $ proxyFileName , self :: $ proxyClassTemplate ) ; } }
8900	public function update_by ( ) { $ args = func_get_args ( ) ; $ data = array_pop ( $ args ) ; $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ this -> _set_where ( $ args ) ; return $ this -> _update ( $ data ) ; } return FALSE ; }
3081	protected function buildOptions ( RunnerServiceContext $ context ) { $ session = $ context -> getTestSession ( ) ; $ options = [ 'allowComment' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowComment ( $ session ) , 'allowSkipping' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowSkipping ( $ session ) , 'exitButton' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowExit ( $ session , $ context ) , 'logoutButton' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowLogout ( $ session ) , 'validateResponses' => \ taoQtiTest_helpers_TestRunnerUtils :: doesValidateResponses ( $ session ) , 'sectionPause' => $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> couldBePaused ( $ session ) ] ; $ categories = $ this -> getCategories ( $ context ) ; $ prefixCategory = 'x-tao-option-' ; $ prefixCategoryLen = strlen ( $ prefixCategory ) ; foreach ( $ categories as $ category ) { if ( ! strncmp ( $ category , $ prefixCategory , $ prefixCategoryLen ) ) { $ optionName = lcfirst ( str_replace ( ' ' , '' , ucwords ( strtr ( substr ( $ category , $ prefixCategoryLen ) , [ '-' => ' ' , '_' => ' ' ] ) ) ) ) ; $ options [ $ optionName ] = true ; } } return $ options ; }
6519	private function unFreeze ( ) { $ this -> isFrozen = false ; $ this -> isReplay = null ; foreach ( static :: schema ( ) -> getFields ( ) as $ field ) { if ( $ field -> getType ( ) -> isMessage ( ) ) { $ value = $ this -> get ( $ field -> getName ( ) ) ; if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof Message ) { $ value -> unFreeze ( ) ; continue ; } foreach ( $ value as $ v ) { $ v -> unFreeze ( ) ; } } } }
1946	public function getCustomSections ( $ strKey = null ) { @ trigger_error ( 'Using FrontendTemplate::getCustomSections() has been deprecated and will no longer work in Contao 5.0. Use FrontendTemplate::sections() instead.' , E_USER_DEPRECATED ) ; if ( $ strKey != '' && ! isset ( $ this -> positions [ $ strKey ] ) ) { return '' ; } $ tag = 'div' ; if ( $ strKey == 'main' ) { $ tag = 'section' ; } $ sections = '' ; foreach ( $ this -> positions [ $ strKey ] as $ sect ) { if ( isset ( $ this -> sections [ $ sect [ 'id' ] ] ) ) { $ sections .= "\n" . '<' . $ tag . ' id="' . StringUtil :: standardize ( $ sect [ 'id' ] , true ) . '">' . "\n" . '<div class="inside">' . "\n" . $ this -> sections [ $ sect [ 'id' ] ] . "\n" . '</div>' . "\n" . '</' . $ tag . '>' . "\n" ; } } if ( $ sections == '' ) { return '' ; } return '<div class="custom">' . "\n" . $ sections . "\n" . '</div>' . "\n" ; }
3820	private function perform ( $ table , Request $ request , $ metaModel , $ parentId ) { $ activate = ( bool ) $ request -> request -> get ( 'activate' ) ; $ query = $ this -> connection -> createQueryBuilder ( ) -> insert ( $ table ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( $ this -> knowsAttribute ( $ attribute ) || ! ( $ this -> accepts ( $ attribute ) && $ this -> isAttributeSubmitted ( $ attribute -> get ( 'id' ) , $ request ) ) ) { continue ; } $ data = [ ] ; foreach ( $ this -> createEmptyDataFor ( $ attribute , $ parentId , $ activate , $ this -> startSort ) as $ key => $ value ) { $ data [ $ key ] = ':' . $ key ; $ query -> setParameter ( $ key , $ value ) ; } $ query -> values ( $ data ) -> execute ( ) ; $ this -> startSort += 128 ; } $ this -> purger -> purge ( ) ; }
10042	public function validatePlugin ( $ plugin ) { if ( $ plugin instanceof Storage \ StorageInterface ) { return ; } throw new Storage \ Exception \ RuntimeException ( sprintf ( 'Plugin of type %s is invalid; must implement %s\Storage\StorageInterfaceInterface' , ( is_object ( $ plugin ) ? get_class ( $ plugin ) : gettype ( $ plugin ) ) , __NAMESPACE__ ) ) ; }
2269	public function lockTables ( $ arrTables ) { $ arrLocks = array ( ) ; foreach ( $ arrTables as $ table => $ mode ) { $ arrLocks [ ] = $ this -> resConnection -> quoteIdentifier ( $ table ) . ' ' . $ mode ; } $ this -> resConnection -> exec ( 'LOCK TABLES ' . implode ( ', ' , $ arrLocks ) . ';' ) ; }
11530	public static function setPermissions ( $ path , $ mode = 0777 , $ recursive = true ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> chmod ( $ path , $ mode , 0000 , $ recursive ) ; } catch ( IOExceptionInterface $ e ) { return false ; } return true ; }
5679	protected function noResponse ( ) { $ this -> transport_error = 'No page fetched yet' ; $ this -> raw = false ; $ this -> sent = false ; $ this -> headers = false ; $ this -> method = 'GET' ; $ this -> url = false ; $ this -> request_data = false ; }
8917	public function message ( $ messageId ) { $ params = [ 'query' => [ 'apikey' => $ this -> apikey , ] ] ; $ response = $ this -> client -> get ( 'messages/' . $ messageId , $ params ) ; return $ response -> getBody ( ) ; }
3797	private function checkForModel ( $ containedModel , $ action ) { if ( ! $ this -> circularReference ) { if ( $ this -> hasVariants ( ) ) { $ this -> checkModelWithVariants ( $ containedModel ) ; } $ this -> checkModelWithoutVariants ( $ containedModel ) ; } elseif ( $ this -> currentModel == null && $ containedModel -> getProperty ( 'varbase' ) == 0 ) { $ this -> disablePA = true ; } else { $ this -> disablePA = false ; $ this -> disablePI = ( $ this -> hasVariants ( ) && $ containedModel -> getProperty ( 'varbase' ) == 1 ) || ( $ action != 'create' && $ containedModel -> getId ( ) == $ this -> currentModel -> getId ( ) ) ; } }
1996	protected function adjustPublicationDate ( ) { if ( ! empty ( $ this -> arrItems ) && $ this -> arrItems [ 0 ] -> published > $ this -> published ) { $ this -> published = $ this -> arrItems [ 0 ] -> published ; } }
12085	public function store ( $ objectURI = null ) { $ this -> setPropertyValue ( "media_owner" , $ this -> user -> getPropertyValue ( "user_name_id" ) ) ; if ( ! $ this -> saveObject ( $ objectURI , $ this -> getObjectType ( ) ) ) { return false ; } return true ; }
7461	public function sendPasswordResetEmail ( UserInterface $ user , $ subject = 'Password reset request' ) { $ hashedEntity = $ this -> createHash ( $ user ) ; $ this -> emailHelper -> createAndSendMessageFromTemplate ( 'OrkestraApplicationBundle:Email:setPassword.html.twig' , array ( 'user' => $ user , 'hash' => $ hashedEntity -> getHash ( ) ) , $ subject , $ user -> getEmail ( ) ) ; return $ hashedEntity ; }
5786	private function databaseRecordNotFound ( Response $ response , $ primaryKey , TableMapper $ tableMapper , string $ routeAction , ? string $ title = null ) { if ( $ routeAction != 'update' && $ routeAction != 'delete' ) { throw new \ Exception ( "routeAction $routeAction must be update or delete" ) ; } $ this -> events -> insertWarning ( EVENT_QUERY_NO_RESULTS , [ $ tableMapper -> getPrimaryKeyColumnName ( ) => $ primaryKey , 'table' => $ tableMapper -> getTableName ( ) ] ) ; $ noticeTitle = ( $ title != null ) ? $ title : 'Record' ; SlimPostgres :: setAdminNotice ( "$noticeTitle $primaryKey Not Found" , 'failure' ) ; return $ response -> withRedirect ( $ this -> router -> pathFor ( SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ) ) ; }
4114	public function getRemoteCallEnabled ( ) { if ( is_null ( $ this -> remoteCallEnabled ) ) { $ this -> remoteCallEnabled = Mage :: getStoreConfigFlag ( 'dev/aoe_templatehints/enablePhpstormRemoteCall' ) ; } return $ this -> remoteCallEnabled ; }
11210	protected function addRegistry ( $ registry ) { $ this -> removeFromLookup ( $ registry ) ; if ( $ registry instanceof DelegatorAwareInterface ) { $ registry -> setDelegator ( $ this ) ; } $ this -> lookup_pool [ ] = $ registry ; return $ this ; }
12593	public function setOperator ( $ operator ) { $ this -> checkParams ( $ this -> operation , $ operator ) ; $ this -> operator = $ operator ; }
834	private function getFunctionyTokenKinds ( ) { static $ tokens = [ T_ARRAY , T_ECHO , T_EMPTY , T_EVAL , T_EXIT , T_INCLUDE , T_INCLUDE_ONCE , T_ISSET , T_LIST , T_PRINT , T_REQUIRE , T_REQUIRE_ONCE , T_UNSET , T_VARIABLE , ] ; return $ tokens ; }
10854	protected function buildCol ( ) { $ result = [ ] ; foreach ( $ this -> col_defs as $ col ) { $ res = [ ] ; $ res [ ] = $ this -> quote ( $ col [ 'name' ] ) ; $ res [ ] = $ col [ 'type' ] ; if ( isset ( $ col [ 'notNull' ] ) ) { $ res [ ] = 'NOT NULL' . ( $ col [ 'notNull' ] ? ( ' ' . $ col [ 'notNull' ] ) : '' ) ; } if ( isset ( $ col [ 'default' ] ) ) { $ res [ ] = 'DEFAULT ' . ( $ col [ 'default' ] [ 1 ] ? $ col [ 'default' ] [ 0 ] : $ this -> processValue ( $ col [ 'default' ] [ 0 ] ) ) ; } if ( isset ( $ col [ 'autoincrement' ] ) ) { $ res [ ] = 'AUTO_INCREMENT' ; } if ( isset ( $ col [ 'unique' ] ) ) { $ res [ ] = 'UNIQUE' . ( $ col [ 'unique' ] ? ( ' ' . $ col [ 'unique' ] ) : '' ) ; } if ( isset ( $ col [ 'primary' ] ) ) { $ res [ ] = 'PRIMARY KEY' . ( $ col [ 'primary' ] ? ( ' ' . $ col [ 'primary' ] ) : '' ) ; } if ( isset ( $ col [ 'constraint' ] ) ) { $ res [ ] = join ( ' ' , $ col [ 'constraint' ] ) ; } array_walk ( $ res , function ( $ m ) { return trim ( $ m ) ; } ) ; $ result [ ] = join ( ' ' , $ res ) ; } return $ result ; }
11508	public function validate ( $ token ) { $ params = [ $ token , $ this -> request -> get ( 'timestamp' ) , $ this -> request -> get ( 'nonce' ) , ] ; if ( ! $ this -> debug && $ this -> request -> get ( 'signature' ) !== $ this -> signature ( $ params ) ) { throw new FaultException ( 'Invalid request signature.' , 400 ) ; } }
7004	public function format ( $ format ) { $ this -> format = $ format ; $ format = preg_replace ( '/([a-zA-Z])/' , '%$1' , $ format ) ; $ format = preg_replace ( '/\\\\%(.)/' , '\\\\$1' , $ format ) ; $ this -> format_d ( $ format ) ; $ this -> formatD ( $ format ) ; $ this -> format_j ( $ format ) ; $ this -> format_l ( $ format ) ; $ this -> formatL ( $ format ) ; $ this -> formatN ( $ format ) ; $ this -> formatS ( $ format ) ; $ this -> format_w ( $ format ) ; $ this -> format_z ( $ format ) ; $ this -> formatW ( $ format ) ; $ this -> formatF ( $ format ) ; $ this -> format_m ( $ format ) ; $ this -> formatM ( $ format ) ; $ this -> format_n ( $ format ) ; $ this -> format_t ( $ format ) ; $ this -> formatY ( $ format ) ; $ this -> format_y ( $ format ) ; $ this -> format_a ( $ format ) ; $ this -> formatA ( $ format ) ; $ this -> format_g ( $ format ) ; $ this -> formatG ( $ format ) ; $ this -> format_h ( $ format ) ; $ this -> formatH ( $ format ) ; $ this -> format_i ( $ format ) ; $ this -> format_s ( $ format ) ; $ this -> format_u ( $ format ) ; $ this -> format_e ( $ format ) ; $ this -> formatO ( $ format ) ; $ this -> formatP ( $ format ) ; $ this -> formatZ ( $ format ) ; $ this -> format_r ( $ format ) ; $ this -> format_c ( $ format ) ; $ this -> formatC ( $ format ) ; return str_replace ( '\\' , '' , $ format ) ; }
9346	public function getCol ( $ int = 0 ) { if ( $ int >= $ this -> size -> cols ) { throw new \ OutOfRangeException ( 'There is not column having this index.' ) ; } $ arr_out = array ( ) ; foreach ( $ this -> arr as $ row ) { $ arr_out [ ] = $ row [ $ int ] ; } return $ arr_out ; }
1523	protected function doSearch ( StoreInterface $ store , FetchResources $ request ) { if ( $ result = $ this -> invoke ( 'searching' , $ request ) ) { return $ result ; } $ found = $ store -> queryRecords ( $ request -> getResourceType ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ found instanceof PageInterface ) ? $ found -> getData ( ) : $ found ; if ( $ result = $ this -> invoke ( 'searched' , $ records , $ request ) ) { return $ result ; } return $ found ; }
6967	protected function calculateGoodLines ( Model \ DocumentInterface $ document ) : Amount { $ gross = new Amount ( $ document -> getCurrency ( ) ) ; foreach ( $ document -> getLinesByType ( Model \ DocumentLineTypes :: TYPE_GOOD ) as $ line ) { if ( null !== $ result = $ this -> calculateGoodLine ( $ line ) ) { $ gross -> merge ( $ result ) ; } } $ gross -> copyGrossToUnit ( ) ; return $ gross ; }
10264	public function getBank ( ) { $ bank_account = new Entities \ BankAccount ; $ bank_account -> type = $ this -> fromArray ( [ 'Checking' , 'Savings' ] ) ; $ bank_account -> name = $ this -> fromArray ( [ 'First National' , 'Arvest' , 'Regions' , 'Metropolitan' , 'Wells Fargo' ] ) ; $ bank_account -> account = $ this -> getInteger ( '1000' , '999999999' ) ; $ bank_account -> routing = $ this -> getBankNumber ( 'Routing' ) ; return $ bank_account ; }
4416	public function onKernelResponse ( FilterResponseEvent $ event ) { $ routeName = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( $ routeName !== FallbackRouter :: ROUTE_NAME ) { return ; } $ response = $ event -> getResponse ( ) ; if ( ! $ response instanceof LegacyResponse ) { return ; } if ( ! $ this -> legacyMode && ( int ) $ response -> getStatusCode ( ) === Response :: HTTP_NOT_FOUND ) { $ moduleResult = $ response -> getModuleResult ( ) ; $ exception = new NotFoundHttpException ( isset ( $ moduleResult [ 'errorMessage' ] ) ? $ moduleResult [ 'errorMessage' ] : 'Not Found' ) ; $ exception -> setOriginalResponse ( $ response ) ; throw $ exception ; } }
933	public function equals ( $ other , $ caseSensitive = true ) { if ( $ other instanceof self ) { if ( ! $ other -> isArray ) { $ otherPrototype = $ other -> content ; } else { $ otherPrototype = [ $ other -> id , $ other -> content , ] ; } } else { $ otherPrototype = $ other ; } if ( $ this -> isArray !== \ is_array ( $ otherPrototype ) ) { return false ; } if ( ! $ this -> isArray ) { return $ this -> content === $ otherPrototype ; } if ( $ this -> id !== $ otherPrototype [ 0 ] ) { return false ; } if ( isset ( $ otherPrototype [ 1 ] ) ) { if ( $ caseSensitive ) { if ( $ this -> content !== $ otherPrototype [ 1 ] ) { return false ; } } elseif ( 0 !== strcasecmp ( $ this -> content , $ otherPrototype [ 1 ] ) ) { return false ; } } unset ( $ otherPrototype [ 0 ] , $ otherPrototype [ 1 ] ) ; return empty ( $ otherPrototype ) ; }
3802	private function getOrCreatePaletteDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasDefinition ( PalettesDefinitionInterface :: NAME ) ) { return $ container -> getDefinition ( PalettesDefinitionInterface :: NAME ) ; } $ container -> setDefinition ( PalettesDefinitionInterface :: NAME , $ palettesDefinition = new DefaultPalettesDefinition ( ) ) ; return $ palettesDefinition ; }
10411	public function invalidate ( ) { $ script = escapeshellcmd ( $ this -> rootDir . "/../{$this->cacheScript}" ) ; $ urlsFile = escapeshellarg ( $ this -> createUrlsTempFile ( ) ) ; $ curlTimeout = escapeshellarg ( $ this -> curlTimeout ) ; $ process = new Process ( sprintf ( '%s %s %s' , $ script , $ urlsFile , $ curlTimeout ) ) ; $ process -> start ( ) ; $ this -> resetCache ( ) ; return $ urlsFile ; }
8570	public function getLastUpdatedTimeForRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetLastUpdatedTimeForRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetLastUpdatedTimeForRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetLastUpdatedTimeForRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6763	public function append ( Collection $ collection ) { if ( ! $ collection ) return $ this ; $ this -> models = array_merge ( $ this -> array ( ) , $ collection -> array ( ) ) ; return $ this ; }
8297	protected function createBkFile ( ) { if ( ! is_writable ( dirname ( $ this -> filePath ) ) ) { return ; } $ this -> bkFilePath = $ this -> filePath . '.' . date ( "y-m-d-H-i-s" ) . '.bak' ; $ bkHandle = @ fopen ( $ this -> bkFilePath , 'x+' ) ; if ( $ bkHandle === false ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a temporary file " . $ this -> bkFilePath ) ; } $ stat = fstat ( $ this -> handle ) ; if ( stream_copy_to_stream ( $ this -> handle , $ bkHandle ) !== $ stat [ 'size' ] ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a copy of " . $ this -> filePath ) ; } if ( ! fclose ( $ bkHandle ) ) { throw new \ RuntimeException ( "Could not close a backup file " . $ this -> bkFilePath ) ; } fseek ( $ this -> handle , 0 ) ; }
3481	private static function includeConfigurationFile ( ) { static $ included = false ; if ( $ included ) { return ; } $ file = __DIR__ . '/config.php' ; if ( ! file_exists ( $ file ) ) { print sprintf ( 'The configuration file "%s" was not found.%sPlease copy %s/config.php.dist to %s/config.php and modify new file for set own parameters.%s' , $ file , PHP_EOL , __DIR__ , __DIR__ , PHP_EOL ) ; exit ( 1 ) ; } $ included = true ; include_once $ file ; }
3762	private function getConditionChain ( LegendInterface $ legend , $ propertyName , array & $ conditions ) { if ( isset ( $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] ) ) { return $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] ; } $ property = $ this -> getLegendProperty ( $ legend , $ propertyName ) ; $ condition = $ this -> getVisibleCondition ( $ property ) ; $ orCondition = new PropertyConditionChain ( ) ; $ orCondition -> setConjunction ( PropertyConditionChain :: OR_CONJUNCTION ) ; $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] = $ orCondition ; $ condition -> addCondition ( $ orCondition ) ; return $ orCondition ; }
3280	protected function normalizeConfig ( array $ config ) : array { $ defaultConfig = [ 'dir' => getcwd ( ) , 'ext' => '.dat' , 'gzip' => false , 'cache' => true , 'formatter' => null , 'swap_memory_limit' => 2097152 , ] ; return array_replace ( $ defaultConfig , $ config ) ; }
1352	protected function notAllowed ( string $ resourceType , string $ fields ) : Collection { $ fields = collect ( explode ( ',' , $ fields ) ) ; if ( ! $ this -> allowed -> has ( $ resourceType ) ) { return $ fields ; } $ allowed = $ this -> allowed -> get ( $ resourceType ) ; if ( is_null ( $ allowed ) ) { return collect ( ) ; } $ allowed = collect ( ( array ) $ allowed ) ; return $ fields -> reject ( function ( $ value ) use ( $ allowed ) { return $ allowed -> contains ( $ value ) ; } ) ; }
2481	protected function internalFind ( array $ parameters , array $ languageSettings = array ( ) ) { $ searchTargets = $ this -> getSearchTargets ( $ languageSettings ) ; if ( ! empty ( $ searchTargets ) ) { $ parameters [ 'shards' ] = $ searchTargets ; } return $ this -> search ( $ parameters ) ; }
12890	public function createView ( ) : \ stdClass { $ oView = new \ stdClass ; $ oView -> form = $ this -> _sView ; $ oView -> form_start = $ this -> _oForm -> getFormInObject ( ) -> start ; $ oView -> form_end = $ this -> _oForm -> getFormInObject ( ) -> end ; $ oView -> form_row = array ( ) ; foreach ( $ this -> _oForm -> getFormInObject ( ) -> form as $ sKey => $ mValue ) { if ( $ mValue instanceof Container ) { $ oNewForm = $ mValue -> createView ( ) ; $ oView -> form_row [ $ sKey ] = $ oNewForm -> form_row ; } else { $ oView -> form_row [ $ sKey ] = $ mValue ; } } return $ oView ; }
6606	public function validateAccessTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'access token' ) ; } return true ; }
7775	protected function handleError ( $ field , $ value , $ rule , array $ args ) { $ this -> errors [ $ rule ] [ ] = [ 'field' => $ field , 'value' => $ value , 'args' => $ args , ] ; }
3068	protected function initServiceContext ( ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> getRunnerService ( ) -> check ( $ serviceContext ) ; return $ serviceContext -> init ( ) ; }
6667	public function prepareResponse ( ) { if ( ! $ this -> writer ) { $ this -> writer = $ this -> writerFactory -> getWriterFor ( $ this -> request -> getFormats ( ) ) ; } $ this -> preparedResponse = $ this -> writer -> format ( $ this -> getBody ( ) , $ this -> responseName ) ; return $ this ; }
9631	public function setSetting ( $ key , $ value ) { $ settings = $ this -> getSettings ( ) ; $ settings [ $ key ] = $ value ; $ this -> setSettings ( $ settings ) ; }
6332	public function createResponse ( $ status , $ errorCode , $ errorDescription ) { $ document = new \ DOMDocument ( '1.0' , 'utf-8' ) ; $ document -> formatOutput = false ; $ response = $ document -> appendChild ( $ document -> createElement ( 'SVSPurchaseStatusNotificationResponse' ) ) ; $ result = $ response -> appendChild ( $ document -> createElement ( 'TransactionResult' ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Description' , $ errorDescription ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Code' , $ errorCode ) ) ; $ response -> appendChild ( $ document -> createElement ( 'Status' , $ status ) ) ; $ authentication = $ response -> appendChild ( $ document -> createElement ( 'Authentication' ) ) ; $ checksum = $ authentication -> appendChild ( $ document -> createElement ( 'Checksum' , $ this -> getMerchantPassword ( ) ) ) ; $ checksum -> nodeValue = $ this -> calculateXmlChecksum ( $ document -> saveXML ( ) ) ; return $ document -> saveXML ( ) ; }
336	protected function findConstraints ( $ table ) { $ sql = <<<'SQL'SELECT /*+ PUSH_PRED(C) PUSH_PRED(D) PUSH_PRED(E) */ D.CONSTRAINT_NAME, D.CONSTRAINT_TYPE, C.COLUMN_NAME, C.POSITION, D.R_CONSTRAINT_NAME, E.TABLE_NAME AS TABLE_REF, F.COLUMN_NAME AS COLUMN_REF, C.TABLE_NAMEFROM ALL_CONS_COLUMNS C INNER JOIN ALL_CONSTRAINTS D ON D.OWNER = C.OWNER AND D.CONSTRAINT_NAME = C.CONSTRAINT_NAME LEFT JOIN ALL_CONSTRAINTS E ON E.OWNER = D.R_OWNER AND E.CONSTRAINT_NAME = D.R_CONSTRAINT_NAME LEFT JOIN ALL_CONS_COLUMNS F ON F.OWNER = E.OWNER AND F.CONSTRAINT_NAME = E.CONSTRAINT_NAME AND F.POSITION = C.POSITIONWHERE C.OWNER = :schemaName AND C.TABLE_NAME = :tableNameORDER BY D.CONSTRAINT_NAME, C.POSITIONSQL ; $ command = $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ] ) ; $ constraints = [ ] ; foreach ( $ command -> queryAll ( ) as $ row ) { if ( $ this -> db -> slavePdo -> getAttribute ( \ PDO :: ATTR_CASE ) === \ PDO :: CASE_LOWER ) { $ row = array_change_key_case ( $ row , CASE_UPPER ) ; } if ( $ row [ 'CONSTRAINT_TYPE' ] === 'P' ) { $ table -> columns [ $ row [ 'COLUMN_NAME' ] ] -> isPrimaryKey = true ; $ table -> primaryKey [ ] = $ row [ 'COLUMN_NAME' ] ; if ( empty ( $ table -> sequenceName ) ) { $ table -> sequenceName = $ this -> getTableSequenceName ( $ table -> name ) ; } } if ( $ row [ 'CONSTRAINT_TYPE' ] !== 'R' ) { continue ; } $ name = $ row [ 'CONSTRAINT_NAME' ] ; if ( ! isset ( $ constraints [ $ name ] ) ) { $ constraints [ $ name ] = [ 'tableName' => $ row [ 'TABLE_REF' ] , 'columns' => [ ] , ] ; } $ constraints [ $ name ] [ 'columns' ] [ $ row [ 'COLUMN_NAME' ] ] = $ row [ 'COLUMN_REF' ] ; } foreach ( $ constraints as $ constraint ) { $ name = current ( array_keys ( $ constraint ) ) ; $ table -> foreignKeys [ $ name ] = array_merge ( [ $ constraint [ 'tableName' ] ] , $ constraint [ 'columns' ] ) ; } }
3102	public function getStorage ( ) { if ( ! $ this -> storage ) { $ this -> storage = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storage ; }
8729	protected function updateFolderName ( HTTPRequest $ request ) { if ( ! $ this -> getCanSelectFolder ( ) ) { return ; } $ folderID = $ request -> requestVar ( "{$this->Name}/folder" ) ; $ path = $ this -> folderPathFromID ( $ folderID ) ; if ( $ path !== false ) { $ this -> setFolderName ( $ path ) ; $ this -> selectField -> setValue ( $ folderID ) ; } }
8971	protected function fromJson ( $ json ) { $ data = json_decode ( $ json , true ) ; return new Rate ( $ data [ 'sourceName' ] , ( float ) $ data [ 'value' ] , $ data [ 'currencyCode' ] , $ data [ 'rateType' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'date' ] ) , $ data [ 'baseCurrencyCode' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'createdAt' ] ) , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'modifiedAt' ] ) ) ; }
5995	public function addFolderResponse ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FolderResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "FolderResponse"!' , E_USER_WARNING ) ; } } $ this -> subFolders [ ] = $ item ; return $ this ; }
5253	public static function findOrFail ( $ id , array $ columns = [ '*' ] , $ parent = null ) { $ model = static :: find ( $ id , $ columns , [ 'parent' => $ parent ] ) ; if ( is_null ( $ model ) ) { throw new ModelNotFoundException ( get_called_class ( ) , $ id ) ; } return $ model ; }
5799	public function selectArrayWithRolesString ( string $ columns = "*" , array $ whereColumnsInfo = null ) : array { $ administrators = [ ] ; $ results = $ this -> selectArray ( $ columns , $ whereColumnsInfo ) ; foreach ( $ results as $ index => $ administrator ) { $ administrators [ $ index ] = $ administrator ; $ administrators [ $ index ] [ 'roles' ] = implode ( ", " , $ administrators [ $ index ] [ 'roles' ] ) ; } return $ administrators ; }
6964	protected function getYear ( ) { $ year = 0 ; if ( $ this -> type == YearType :: Besselian ( ) ) $ year = 1900 + ( $ this -> jd - Epoch :: B1900 ( ) -> jd ) / static :: DaysBesselianYear ; else $ year = 2000 + ( $ this -> jd - Epoch :: J2000 ( ) -> jd ) / static :: DaysJulianYear ; return round ( $ year , 6 ) ; }
9769	function match ( string $ pattern ) : self { return $ this -> expect ( $ this -> target , matchesRegularExpression ( $ pattern ) ) ; }
2739	private function uploadVcl ( $ activate ) { try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'priority' => 50 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_pass' , 'statement' => 'req.http.x-pass' , 'type' => 'REQUEST' , 'priority' => 90 ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ request = [ 'action' => 'pass' , 'max_stale_age' => 3600 , 'name' => Config :: FASTLY_MAGENTO_MODULE . '_request' , 'request_condition' => $ createCondition -> name , 'service_id' => $ service -> id , 'version' => $ currActiveVersion ] ; $ this -> api -> createRequest ( $ clone -> number , $ request ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; $ msg = 'Successfully uploaded VCL. ' ; if ( $ activate ) { $ this -> api -> activateVersion ( $ clone -> number ) ; $ msg .= 'Activated Version ' . $ clone -> number ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Upload VCL has been initiated and activated in version ' . $ clone -> number . '*' ) ; } $ this -> output -> writeln ( '<info>' . $ msg . '</info>' , OutputInterface :: OUTPUT_NORMAL ) ; } catch ( \ Exception $ e ) { $ msg = $ e -> getMessage ( ) ; $ this -> output -> writeln ( "<error>$msg</error>" , OutputInterface :: OUTPUT_NORMAL ) ; return ; } }
4649	protected function getServices ( $ config ) { $ services = array ( ) ; $ travisServices = isset ( $ config [ 'services' ] ) && is_array ( $ config [ 'services' ] ) ? $ config [ 'services' ] : array ( ) ; foreach ( $ travisServices as $ service ) { if ( isset ( $ this -> servicesMapping [ $ service ] ) ) { $ services [ ] = new Service ( $ service , $ this -> servicesMapping [ $ service ] [ 'repository' ] , $ this -> servicesMapping [ $ service ] [ 'tag' ] , $ this -> servicesMapping [ $ service ] [ 'config' ] ) ; } } return $ services ; }
3176	public static function getNavigator ( $ direction , $ scope ) { $ className = __NAMESPACE__ . '\QtiRunnerNavigation' . ucfirst ( $ direction ) . ucfirst ( $ scope ) ; if ( class_exists ( $ className ) ) { $ navigator = new $ className ( ) ; if ( $ navigator instanceof RunnerNavigation ) { return $ navigator ; } else { throw new \ common_exception_InconsistentData ( 'Navigator must be an instance of RunnerNavigation' ) ; } } else { throw new \ common_exception_NotImplemented ( 'The action is invalid!' ) ; } }
7919	protected function renderInput ( $ options = [ ] , $ resultsOptions = [ ] ) { Html :: addCssClass ( $ options , 'prompt' ) ; $ lines = [ ] ; $ input = $ this -> hasModel ( ) ? Html :: activeTextInput ( $ this -> model , $ this -> attribute , $ options ) : Html :: textInput ( $ this -> name , $ this -> value , $ options ) ; if ( ! empty ( $ this -> displayIcon ) ) { $ lines [ ] = Html :: beginTag ( 'div' , [ 'class' => 'ui icon input' ] ) ; $ lines [ ] = $ input ; $ lines [ ] = Html :: tag ( 'i' , '' , [ 'class' => 'icon search' ] ) ; $ lines [ ] = Html :: endTag ( 'div' ) ; } else { $ lines [ ] = $ input ; } $ lines [ ] = Html :: tag ( 'div' , '' , $ resultsOptions ) ; return implode ( "\n" , $ lines ) ; }
3298	public static function isImage ( $ file ) { try { $ level = error_reporting ( E_ERROR | E_PARSE ) ; $ isImage = self :: isFile ( $ file ) && getimagesize ( $ file ) !== false ; error_reporting ( $ level ) ; return $ isImage ; } catch ( Exception $ e ) { return false ; } }
4395	public function isImplemented ( $ what ) { $ provider = $ this -> getProvider ( ) ; switch ( $ what ) { case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_CAPTURE : return $ provider -> supportsCapture ( ) ; case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_CANCEL : return $ provider -> supportsVoid ( ) ; case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_REFUND : return $ provider -> supportsRefund ( ) ; case \ Aimeos \ MShop \ Service \ Provider \ Payment \ Base :: FEAT_REPAY : return method_exists ( $ provider , 'createCard' ) ; } return false ; }
476	public function createTable ( $ table , $ columns , $ options = null ) { $ time = $ this -> beginCommand ( "create table $table" ) ; $ this -> db -> createCommand ( ) -> createTable ( $ table , $ columns , $ options ) -> execute ( ) ; foreach ( $ columns as $ column => $ type ) { if ( $ type instanceof ColumnSchemaBuilder && $ type -> comment !== null ) { $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ type -> comment ) -> execute ( ) ; } } $ this -> endCommand ( $ time ) ; }
6773	protected function isTaxationUpdateNeeded ( SaleInterface $ sale ) { if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'taxExempt' , 'customer' , 'vatValid' ] ) ) { return true ; } return $ this -> didDeliveryCountryChanged ( $ sale ) ; }
3921	private function processFile ( $ fileName ) { $ file = new File ( $ fileName ) ; $ meta = $ this -> metaInformation [ dirname ( $ fileName ) ] [ $ file -> basename ] ; $ title = strlen ( $ meta [ 'title' ] ) ? $ meta [ 'title' ] : StringUtil :: specialchars ( $ file -> basename ) ; if ( strlen ( $ meta [ 'caption' ] ) ) { $ altText = $ meta [ 'caption' ] ; } else { $ altText = ucfirst ( str_replace ( '_' , ' ' , preg_replace ( '/^[0-9]+_/' , '' , $ file -> filename ) ) ) ; } $ information = [ 'file' => $ fileName , 'mtime' => $ file -> mtime , 'alt' => $ altText , 'caption' => ( ! empty ( $ meta [ 'caption' ] ) ? $ meta [ 'caption' ] : '' ) , 'title' => $ title , 'metafile' => $ meta , 'icon' => 'assets/contao/images/' . $ file -> icon , 'extension' => $ file -> extension , 'size' => $ file -> filesize , 'sizetext' => sprintf ( '(%s)' , Controller :: getReadableSize ( $ file -> filesize , 2 ) ) , 'url' => StringUtil :: specialchars ( $ this -> getDownloadLink ( $ fileName ) ) ] ; if ( $ information [ 'isGdImage' ] = $ file -> isGdImage ) { $ information [ 'src' ] = urldecode ( $ this -> resizeImage ( $ fileName ) ) ; if ( file_exists ( TL_ROOT . '/' . $ information [ 'src' ] ) ) { $ size = getimagesize ( TL_ROOT . '/' . $ information [ 'src' ] ) ; $ information [ 'lb' ] = 'lb' . $ this -> getLightboxId ( ) ; $ information [ 'w' ] = $ size [ 0 ] ; $ information [ 'h' ] = $ size [ 1 ] ; $ information [ 'wh' ] = $ size [ 3 ] ; } } if ( $ information [ 'isSvgImage' ] = $ file -> isSvgImage ) { $ information [ 'src' ] = $ fileName ; } if ( $ information [ 'isPicture' ] = ( int ) $ this -> resizeImages [ 2 ] ) { $ picture = Picture :: create ( $ file , $ this -> getResizeImages ( ) ) -> getTemplateData ( ) ; $ picture [ 'alt' ] = $ altText ; $ picture [ 'title' ] = $ title ; $ information [ 'picture' ] = $ picture ; } $ this -> modifiedTime [ ] = $ file -> mtime ; $ this -> outputBuffer [ ] = $ information ; }
9233	public function actionCreate ( ) { $ model = new Post ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> author_id = Yii :: $ app -> user -> id ; $ model -> isdel = 0 ; if ( Yii :: $ app -> request -> post ( ) ) { $ post = Yii :: $ app -> request -> post ( ) ; $ category = [ ] ; if ( isset ( $ post [ 'Post' ] [ 'category' ] ) ) { $ category = $ post [ 'Post' ] [ 'category' ] ; } if ( is_array ( $ post [ 'Post' ] [ 'tags' ] ) ) { $ post [ 'Post' ] [ 'tags' ] = implode ( "," , $ post [ 'Post' ] [ 'tags' ] ) ; } $ model -> load ( $ post ) ; $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> save ( ) ) { $ cs = BlogCatPos :: deleteAll ( "post_id = :id" , [ "id" => $ model -> id ] ) ; foreach ( $ category as $ d ) { $ c = new BlogCatPos ( ) ; $ c -> post_id = $ model -> id ; $ c -> category_id = $ d ; $ c -> isdel = 0 ; $ c -> save ( ) ; } $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ model -> id = array_merge ( $ category , [ ] ) ; $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } } return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; }
2	private function buildDependency10Info ( $ depArray ) { static $ dep10toOperatorMap = array ( 'has' => '==' , 'eq' => '==' , 'ge' => '>=' , 'gt' => '>' , 'le' => '<=' , 'lt' => '<' , 'not' => '!=' ) ; $ result = array ( ) ; foreach ( $ depArray as $ depItem ) { if ( empty ( $ depItem [ 'rel' ] ) || ! array_key_exists ( $ depItem [ 'rel' ] , $ dep10toOperatorMap ) ) { continue ; } $ depType = ! empty ( $ depItem [ 'optional' ] ) && 'yes' == $ depItem [ 'optional' ] ? 'optional' : 'required' ; $ depType = 'not' == $ depItem [ 'rel' ] ? 'conflicts' : $ depType ; $ depVersion = ! empty ( $ depItem [ 'version' ] ) ? $ this -> parseVersion ( $ depItem [ 'version' ] ) : '*' ; $ depVersionConstraint = ( 'has' == $ depItem [ 'rel' ] || 'not' == $ depItem [ 'rel' ] ) && '*' == $ depVersion ? '*' : $ dep10toOperatorMap [ $ depItem [ 'rel' ] ] . $ depVersion ; switch ( $ depItem [ 'type' ] ) { case 'php' : $ depChannelName = 'php' ; $ depPackageName = '' ; break ; case 'pkg' : $ depChannelName = ! empty ( $ depItem [ 'channel' ] ) ? $ depItem [ 'channel' ] : 'pear.php.net' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'ext' : $ depChannelName = 'ext' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'os' : case 'sapi' : $ depChannelName = '' ; $ depPackageName = '' ; break ; default : $ depChannelName = '' ; $ depPackageName = '' ; break ; } if ( '' != $ depChannelName ) { $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } } return $ result ; }
0	public static function supports ( IOInterface $ io , Config $ config , $ url , $ deep = false ) { if ( ! preg_match ( self :: URL_REGEX , $ url , $ match ) ) { return false ; } $ scheme = ! empty ( $ match [ 'scheme' ] ) ? $ match [ 'scheme' ] : null ; $ guessedDomain = ! empty ( $ match [ 'domain' ] ) ? $ match [ 'domain' ] : $ match [ 'domain2' ] ; $ urlParts = explode ( '/' , $ match [ 'parts' ] ) ; if ( false === self :: determineOrigin ( ( array ) $ config -> get ( 'gitlab-domains' ) , $ guessedDomain , $ urlParts ) ) { return false ; } if ( 'https' === $ scheme && ! extension_loaded ( 'openssl' ) ) { $ io -> writeError ( 'Skipping GitLab driver for ' . $ url . ' because the OpenSSL PHP extension is missing.' , true , IOInterface :: VERBOSE ) ; return false ; } return true ; }
8343	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ rawRequest = null ; self :: $ routes = array ( ) ; self :: $ isInit = true ; if ( defined ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_IS_HTTP' ) === true ) { self :: $ rawRequest = new RawRequest ( ) ; Session :: init ( ) ; Locale :: init ( self :: $ rawRequest ) ; } } }
12087	public static function create ( $ validator , $ command ) { static $ cache = [ ] ; $ cacheKey = $ validator ; if ( isset ( $ cache [ $ cacheKey ] ) ) { $ class = $ cache [ $ cacheKey ] [ 'class' ] ; $ validator = $ cache [ $ cacheKey ] [ 'validator' ] ; } else { if ( false === strpos ( $ validator , '.' ) ) { $ class = __NAMESPACE__ . '\\' . String :: convertToCamelCase ( $ validator ) ; } else { $ class = explode ( '.' , $ validator ) ; $ class = array_map ( array ( 'In2pire\\Component\\Utility\\Text' , 'convertToCamelCase' ) , $ class ) ; $ class = implode ( '\\' , $ class ) ; $ validator = substr ( $ validator , strrpos ( $ validator , '.' ) + 1 ) ; } $ cache [ $ cacheKey ] = [ 'class' => $ class , 'validator' => $ validator ] ; } if ( ! class_exists ( $ class ) ) { throw new \ RuntimeException ( 'Unknow validator ' . $ cacheKey ) ; } return new $ class ( $ command ) ; }
3835	protected function prepareTemplate ( Template $ objTemplate , $ arrRowData , $ objSettings ) { $ objTemplate -> setData ( array ( 'attribute' => $ this , 'settings' => $ objSettings , 'row' => $ arrRowData , 'raw' => $ arrRowData [ $ this -> getColName ( ) ] , 'additional_class' => $ objSettings -> get ( 'additional_class' ) ? ' ' . $ objSettings -> get ( 'additional_class' ) : '' ) ) ; }
7565	protected function parse_callback ( $ conditions , $ recursive = true , $ check_root = false ) { return ( $ this -> result = $ this -> root -> getChildrenByMatch ( $ conditions , $ recursive , $ check_root , $ this -> custom_filter_map ) ) ; }
8275	public function handleEvent ( $ eventName , array $ params ) { if ( method_exists ( $ this , $ eventName ) ) { call_user_func_array ( array ( $ this , $ eventName ) , $ params ) ; } }
7999	public function identifyTargetName ( $ username , $ nt_domain , ServerChallenge $ server_challenge ) { $ target_name = $ nt_domain ? : $ server_challenge -> getTargetName ( ) ; if ( false !== strpos ( $ username , static :: USER_PRINCIPAL_NAME_SEPARATOR ) ) { $ target_name = '' ; } return $ target_name ; }
7011	private function formatS ( & $ str ) { if ( strstr ( $ str , '%S' ) ) $ str = str_replace ( '%S' , static :: ordinal ( $ this -> day ) , $ str ) ; }
8655	private function convertGetReportCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
12897	public function to ( string $ path , int $ status = 301 , array $ headers = array ( ) ) { return $ this -> makeRedirect ( $ path , $ status , $ headers ) ; }
890	public function getTypes ( ) { if ( null === $ this -> types ) { $ this -> types = [ ] ; $ content = $ this -> getTypesContent ( ) ; while ( '' !== $ content && false !== $ content ) { Preg :: match ( '{^' . self :: REGEX_TYPES . '$}x' , $ content , $ matches ) ; $ this -> types [ ] = $ matches [ 'type' ] ; $ content = substr ( $ content , \ strlen ( $ matches [ 'type' ] ) + 1 ) ; } } return $ this -> types ; }
4525	protected function createZoneMemberCountryFromDefinition ( array $ definition ) { $ zoneMember = new ZoneMemberCountry ( ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; $ this -> name = $ definition [ 'name' ] ; $ this -> countryCode = $ definition [ 'country_code' ] ; if ( isset ( $ definition [ 'administrative_area' ] ) ) { $ this -> administrativeArea = $ definition [ 'administrative_area' ] ; } if ( isset ( $ definition [ 'locality' ] ) ) { $ this -> locality = $ definition [ 'locality' ] ; } if ( isset ( $ definition [ 'dependent_locality' ] ) ) { $ this -> dependentLocality = $ definition [ 'dependent_locality' ] ; } if ( isset ( $ definition [ 'included_postal_codes' ] ) ) { $ this -> includedPostalCodes = $ definition [ 'included_postal_codes' ] ; } if ( isset ( $ definition [ 'excluded_postal_codes' ] ) ) { $ this -> excludedPostalCodes = $ definition [ 'excluded_postal_codes' ] ; } } , $ zoneMember , '\CommerceGuys\Zone\Model\ZoneMemberCountry' ) ; $ setValues ( $ definition ) ; return $ zoneMember ; }
1892	public function accept ( ) { if ( strncmp ( $ this -> current ( ) -> getFilename ( ) , '.' , 1 ) === 0 ) { return false ; } $ strPath = $ this -> current ( ) -> getPathname ( ) ; if ( is_file ( $ strPath ) ) { $ strPath = \ dirname ( $ strPath ) ; } $ objFolder = new Folder ( StringUtil :: stripRootDir ( $ strPath ) ) ; return ! $ objFolder -> isUnsynchronized ( ) ; }
3722	public function handleUpdate ( PostPersistModelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ old = $ event -> getOriginalModel ( ) ; $ new = $ event -> getModel ( ) ; $ oldTable = $ old ? $ old -> getProperty ( 'tableName' ) : null ; $ newTable = $ new -> getProperty ( 'tableName' ) ; if ( $ oldTable !== $ newTable ) { if ( ! empty ( $ oldTable ) ) { $ this -> tableManipulator -> renameTable ( $ oldTable , $ newTable ) ; } else { $ this -> tableManipulator -> createTable ( $ newTable ) ; } } $ this -> tableManipulator -> setVariantSupport ( $ newTable , $ new -> getProperty ( 'varsupport' ) ) ; }
9305	public function setEmitEvents ( $ emitEvents ) { if ( ! is_bool ( $ emitEvents ) ) { throw new \ InvalidArgumentException ( '`emitEvents` expects boolean value!' ) ; } $ this -> options [ 'emitEvents' ] = ( bool ) $ emitEvents ; return $ this ; }
7441	protected function hasAccessToAction ( $ packageKey , $ subpackageKey , $ controllerName , $ actionName ) { $ actionControllerName = $ this -> router -> getControllerObjectName ( $ packageKey , $ subpackageKey , $ controllerName ) ; try { return $ this -> privilegeManager -> isGranted ( 'Neos\Flow\Security\Authorization\Privilege\Method\MethodPrivilege' , new MethodPrivilegeSubject ( new JoinPoint ( NULL , $ actionControllerName , $ actionName . 'Action' , array ( ) ) ) ) ; } catch ( AccessDeniedException $ e ) { return FALSE ; } }
8955	public function createRelation ( $ changeset , $ tags , $ members ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'relation/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ memberList = '' ; if ( ! empty ( $ members ) ) { foreach ( $ members as $ member ) { if ( $ member [ 'type' ] == 'node' ) { $ memberList .= '<member type="' . $ member [ 'type' ] . '" role="' . $ member [ 'role' ] . '" ref="' . $ member [ 'ref' ] . '"/>' ; } elseif ( $ member [ 'type' ] == 'way' ) { $ memberList .= '<member type="' . $ member [ 'type' ] . '" ref="' . $ member [ 'ref' ] . '"/>' ; } } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <relation relation="' . $ changeset . '" >' . $ tagList . $ memberList . '</relation> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
8740	public function i18nQuery ( ) { $ query = $ this -> getModel ( ) -> newQueryWithoutScopes ( ) -> getQuery ( ) ; $ query -> from ( $ this -> model -> getI18nTable ( ) ) ; return $ query ; }
2716	public function addTextInput ( $ id , $ label , $ comment , $ required = true ) { $ this -> children [ $ id ] = [ 'id' => $ id , 'type' => 'text' , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => count ( $ this -> children ) , 'label' => $ label , 'comment' => $ comment , 'validate' => ( $ required == true ) ? 'required-entry' : '' , '_elementType' => 'field' , 'path' => self :: BASE_CONFIG_PATH . '/' . $ this -> id ] ; }
9856	private function addContinue ( $ data ) { $ limit = $ this -> limit ; $ record = 0x003C ; $ tmp = substr ( $ data , 0 , 2 ) . pack ( 'v' , $ limit ) . substr ( $ data , 4 , $ limit ) ; $ header = pack ( 'vv' , $ record , $ limit ) ; $ data_length = strlen ( $ data ) ; for ( $ i = $ limit + 4 ; $ i < ( $ data_length - $ limit ) ; $ i += $ limit ) { $ tmp .= $ header ; $ tmp .= substr ( $ data , $ i , $ limit ) ; } $ header = pack ( 'vv' , $ record , strlen ( $ data ) - $ i ) ; $ tmp .= $ header ; $ tmp .= substr ( $ data , $ i ) ; return $ tmp ; }
2973	public static function wrapClosures ( & $ data , SerializerInterface $ serializer ) { if ( $ data instanceof \ Closure ) { $ reflection = new \ ReflectionFunction ( $ data ) ; if ( $ binding = $ reflection -> getClosureThis ( ) ) { self :: wrapClosures ( $ binding , $ serializer ) ; $ scope = $ reflection -> getClosureScopeClass ( ) ; $ scope = $ scope ? $ scope -> getName ( ) : 'static' ; $ data = $ data -> bindTo ( $ binding , $ scope ) ; } $ data = new SerializableClosure ( $ data , $ serializer ) ; } elseif ( is_array ( $ data ) || $ data instanceof \ stdClass || $ data instanceof \ Traversable ) { foreach ( $ data as & $ value ) { self :: wrapClosures ( $ value , $ serializer ) ; } } elseif ( is_object ( $ data ) && ! $ data instanceof \ Serializable ) { $ reflection = new \ ReflectionObject ( $ data ) ; if ( ! $ reflection -> hasMethod ( '__sleep' ) ) { foreach ( $ reflection -> getProperties ( ) as $ property ) { if ( $ property -> isPrivate ( ) || $ property -> isProtected ( ) ) { $ property -> setAccessible ( true ) ; } $ value = $ property -> getValue ( $ data ) ; self :: wrapClosures ( $ value , $ serializer ) ; $ property -> setValue ( $ data , $ value ) ; } } } }
12308	public function showAction ( Request $ request , Application $ app ) { $ options = $ this -> options ( $ request , $ app ) ; return parent :: show ( $ options ) ; }
7845	public function send ( array $ destinations , string $ text ) : ? array { $ this -> checkConfig ( ) ; $ messages = [ ] ; foreach ( $ destinations as $ destination ) { $ messages [ ] = [ 'phone_number' => $ destination , 'message' => $ text , 'device_id' => $ this -> device , ] ; } $ body = Body :: json ( $ messages ) ; $ response = Request :: post ( $ this -> baseUrl . 'message/send' , [ ] , $ body ) ; if ( $ response -> code == 200 ) { return [ 'code' => $ response -> code , 'message' => 'OK' , 'data' => $ response -> body , ] ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } return [ 'code' => $ response -> code , 'message' => $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } }
8298	protected function removeBkFile ( ) { if ( ! $ this -> options [ "backup" ] ) { return ; } if ( ! $ this -> writeErrors && $ this -> bkFilePath ) { unlink ( $ this -> bkFilePath ) ; } }
12080	public function updateChild ( $ idParent , FilterRequest $ filters , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> updateChild ( $ idParent , $ relation , $ idChild , $ filters -> all ( ) ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
10232	private function writeLine ( $ pFileHandle , array $ pValues ) { $ writeDelimiter = false ; $ line = '' ; foreach ( $ pValues as $ element ) { $ element = str_replace ( $ this -> enclosure , $ this -> enclosure . $ this -> enclosure , $ element ) ; if ( $ writeDelimiter ) { $ line .= $ this -> delimiter ; } else { $ writeDelimiter = true ; } $ line .= $ this -> enclosure . $ element . $ this -> enclosure ; } $ line .= $ this -> lineEnding ; fwrite ( $ pFileHandle , $ line ) ; }
11419	protected function getValues ( $ fields , $ preCalculatedResult = false ) { if ( $ preCalculatedResult ) { return $ preCalculatedResult ; } $ app = App :: getInstance ( ) ; $ sql = $ this -> constructSelectSQL ( $ fields ) ; $ item = $ this -> getCache ( $ fields [ $ this -> pk ] ) ; $ results = $ item -> get ( \ Stash \ Invalidation :: PRECOMPUTE , 300 ) ; if ( $ item -> isMiss ( ) ) { $ results = $ this -> runGetRow ( $ sql ) ; if ( $ app [ 'db' ] -> last_error ) { throw new SQLException ( $ app [ 'db' ] -> last_error , $ app [ 'db' ] -> captured_errors ) ; } if ( is_null ( $ results ) ) { throw new ModelNotFoundException ( 'No model in database' , $ this -> dbtable , $ this -> constructorId ) ; } $ app [ 'cache' ] -> save ( $ item -> set ( $ results ) ) ; } return $ results ; }
2766	public function isAhead ( ) : bool { if ( ! $ this -> isTracking ( ) ) { throw new GitException ( 'Error: HEAD does not have a remote tracking branch. Cannot check if it is ahead.' ) ; } $ mergeBase = $ this -> run ( 'merge-base' , [ '@' , '@{u}' ] ) ; $ localSha = $ this -> run ( 'rev-parse' , [ '@' ] ) ; $ remoteSha = $ this -> run ( 'rev-parse' , [ '@{u}' ] ) ; return $ mergeBase === $ remoteSha && $ localSha !== $ remoteSha ; }
3554	public function getValue ( ) { if ( $ this -> hasMutator ( $ this -> attributes [ 'meta_value' ] , 'getter' , $ this -> attributes [ 'meta_type' ] ) ) { return $ this -> mutateValue ( $ this -> attributes [ 'meta_value' ] , 'getter' ) ; } return $ this -> castValue ( ) ; }
12158	public function getObjectLevel ( ) { if ( $ this -> isPrimaryType ) { return 1 ; } $ parents = $ this -> collectorItem -> parents ; if ( ! empty ( $ parents ) ) { $ maxLevel = 1 ; foreach ( $ parents as $ rel ) { if ( get_class ( $ rel -> parent ) === get_class ( $ this ) ) { continue ; } $ newLevel = $ rel -> parent -> objectLevel + 1 ; if ( $ newLevel > $ maxLevel ) { $ maxLevel = $ newLevel ; } } return $ maxLevel ; } return 1 ; }
2882	protected function _initEmail ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ index = $ this -> getRequest ( ) -> getParam ( 'index' ) ; if ( $ token === null || $ index === null ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return null ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return null ; } $ emails = $ requestProfile -> getEmails ( ) ; if ( ! $ emails || ! ( $ index < count ( $ emails ) ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'E-mail not found' ) ; return null ; } return $ emails [ ( int ) $ index ] ; }
9276	public function validateFields ( Request $ request , Repository $ repository , $ data ) { $ config = [ ] ; $ validation = [ ] ; foreach ( $ this -> versions as $ version ) { foreach ( $ version [ 'endpoints' ] as $ endpoint ) { if ( $ endpoint [ 'repository' ] == $ request -> attributes -> get ( 'repository' ) ) { $ config = $ endpoint ; break ; } } if ( $ config != [ ] ) { break ; } } if ( ! $ config [ 'allow_extra_fields' ] || $ config [ 'allow_fields' ] ) { $ mapping = $ this -> manager -> getMetadataCollector ( ) -> getMapping ( $ repository -> getClassName ( ) ) ; $ forbiddenFields = $ mapping [ 'properties' ] ; if ( $ config [ 'allow_fields' ] ) { foreach ( $ config [ 'allow_fields' ] as $ field ) { unset ( $ forbiddenFields [ $ field ] ) ; } } foreach ( $ data as $ parameter => $ value ) { if ( ! array_key_exists ( $ parameter , $ mapping [ 'properties' ] ) && $ parameter != '_id' ) { $ validation [ 'message' ] = sprintf ( 'Property `%s` does not exist in the mapping of `%s`.' , $ parameter , $ repository -> getType ( ) ) ; return $ validation ; } if ( $ config [ 'allow_fields' ] && array_key_exists ( $ parameter , $ forbiddenFields ) ) { $ validation [ 'message' ] = sprintf ( 'You are not allowed to insert or modify the field `%s` in `%s`' , $ parameter , $ repository -> getType ( ) ) ; return $ validation ; } } } return $ validation ; }
4389	public function repay ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; if ( ( $ cfg = $ this -> getCustomerData ( $ base -> getCustomerId ( ) , 'repay' ) ) === null ) { $ msg = sprintf ( 'No reoccurring payment data available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } if ( ! isset ( $ cfg [ 'token' ] ) ) { $ msg = sprintf ( 'No payment token available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } $ data = array ( 'transactionId' => $ order -> getId ( ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'cardReference' => $ cfg [ 'token' ] , 'paymentPage' => false , ) ; if ( isset ( $ cfg [ 'month' ] ) && isset ( $ cfg [ 'year' ] ) ) { $ data [ 'card' ] = new \ Omnipay \ Common \ CreditCard ( [ 'expiryMonth' => $ cfg [ 'month' ] , 'expiryYear' => $ cfg [ 'year' ] , ] ) ; } $ response = $ this -> getXmlProvider ( ) -> purchase ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ this -> saveTransationRef ( $ base , $ response -> getTransactionReference ( ) ) ; $ order -> setPaymentStatus ( \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ) ; $ this -> saveOrder ( $ order ) ; } else { $ msg = ( method_exists ( $ response , 'getMessage' ) ? $ response -> getMessage ( ) : '' ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( sprintf ( 'Token based payment failed: %1$s' , $ msg ) ) ; } }
7362	protected function updateAmountsTotal ( SaleInterface $ sale ) { $ changed = false ; $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ sale -> clearResults ( ) ; $ result = $ this -> amountCalculator -> calculateSale ( $ sale ) ; if ( 0 != Money :: compare ( $ result -> getBase ( ) , $ sale -> getNetTotal ( ) , $ currency ) ) { $ sale -> setNetTotal ( $ result -> getBase ( ) ) ; $ changed = true ; } if ( 0 != Money :: compare ( $ result -> getTotal ( ) , $ sale -> getGrandTotal ( ) , $ currency ) ) { $ sale -> setGrandTotal ( $ result -> getTotal ( ) ) ; $ changed = true ; } return $ changed ; }
5438	public function match ( $ subject , & $ match ) { if ( count ( $ this -> patterns ) === 0 ) { return false ; } if ( ! preg_match ( $ this -> getCompoundedRegex ( ) , $ subject , $ matches ) ) { $ match = '' ; return false ; } $ match = $ matches [ 0 ] ; for ( $ i = 1 ; $ i < count ( $ matches ) ; $ i ++ ) { if ( $ matches [ $ i ] ) { return $ this -> labels [ $ i - 1 ] ; } } return true ; }
3915	protected function sortByDate ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; $ arrDates = $ this -> modifiedTime ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } if ( $ blnAscending ) { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_ASC ) ; } else { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_DESC ) ; } return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; }
1010	private function readName ( $ line , $ col , Token $ prev ) { $ value = '' ; $ start = $ this -> position ; [ $ char , $ code ] = $ this -> readChar ( ) ; while ( $ code && ( $ code === 95 || $ code >= 48 && $ code <= 57 || $ code >= 65 && $ code <= 90 || $ code >= 97 && $ code <= 122 ) ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } return new Token ( Token :: NAME , $ start , $ this -> position , $ line , $ col , $ prev , $ value ) ; }
4642	public function getProjectName ( $ projectPath ) { $ project = basename ( realpath ( $ projectPath ) ) ; $ project = Transliterator :: transliterate ( $ project , '-' ) ; return $ project ; }
1749	protected function import ( $ strClass , $ strKey = null , $ blnForce = false ) { $ strKey = $ strKey ? : $ strClass ; if ( \ is_object ( $ strKey ) ) { $ strKey = \ get_class ( $ strClass ) ; } if ( $ blnForce || ! isset ( $ this -> arrObjects [ $ strKey ] ) ) { $ container = static :: getContainer ( ) ; if ( \ is_object ( $ strClass ) ) { $ this -> arrObjects [ $ strKey ] = $ strClass ; } elseif ( $ container -> has ( $ strClass ) && ( strpos ( $ strClass , '\\' ) !== false || ! class_exists ( $ strClass ) ) ) { $ this -> arrObjects [ $ strKey ] = $ container -> get ( $ strClass ) ; } elseif ( $ container instanceof Container && isset ( $ container -> getRemovedIds ( ) [ $ strClass ] ) ) { throw new ServiceNotFoundException ( $ strClass , null , null , array ( ) , sprintf ( 'The "%s" service or alias has been removed or inlined when the container was compiled. You should either make it public, or stop using the container directly and use dependency injection instead.' , $ strClass ) ) ; } elseif ( \ in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) { $ this -> arrObjects [ $ strKey ] = \ call_user_func ( array ( $ strClass , 'getInstance' ) ) ; } else { $ this -> arrObjects [ $ strKey ] = new $ strClass ( ) ; } } }
4799	function exec ( $ query ) { $ conn = $ this -> getConn ( ) ; $ sql = $ conn -> quote ( $ query ) ; return $ conn -> exec ( $ sql ) ; }
2178	private function addDefaultsToContext ( array $ context ) : array { $ context = array_merge ( $ this -> context , $ context ) ; if ( ! isset ( $ context [ 'request_token' ] ) ) { $ context [ 'request_token' ] = $ this -> getRequestToken ( ) ; } if ( ! isset ( $ context [ 'language' ] ) ) { $ context [ 'language' ] = $ this -> container -> get ( 'translator' ) -> getLocale ( ) ; } if ( ! isset ( $ context [ 'ua' ] ) ) { $ context [ 'ua' ] = $ this -> getUserAgentString ( ) ; } if ( ! isset ( $ context [ 'path' ] ) ) { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ context [ 'host' ] = $ request -> getHost ( ) ; $ context [ 'path' ] = $ request -> getBasePath ( ) ; } return $ context ; }
10875	public function getDecodeHash ( string $ hash ) : array { $ decode = base64_decode ( $ hash ) ; list ( $ part1 , $ part2 ) = explode ( self :: PART_SEPARATOR , $ decode ) ; $ p1 = explode ( self :: TIME_SEPARATOR , $ part1 ) ; list ( $ linkValidate , ) = $ p1 ; $ id = null ; $ verifyHash = null ; $ dateNow = new DateTime ( ) ; $ dateValidate = $ dateNow ; if ( $ linkValidate == self :: NO_TIME ) { $ linkValidate = $ dateNow -> getTimestamp ( ) ; } $ dateValidate -> setTimestamp ( ( int ) $ linkValidate ) ; if ( $ dateValidate >= $ dateNow ) { $ p2 = explode ( self :: ID_SEPARATOR , $ part2 ) ; $ verifyHash = implode ( '.' , array_slice ( $ p2 , 0 , - 1 ) ) ; $ id = $ p2 [ count ( $ p2 ) - 1 ] ; } else { throw new IdentityException ( 'Activate link is expired!' ) ; } return [ 'id' => $ id , 'verifyHash' => $ verifyHash , 'expired' => ( int ) $ linkValidate ] ; }
7953	public function getSpam ( $ ipblock , $ spamstate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ spamstate ) throw new BadMethodCallException ( 'Parameter $spamstate is missing.' ) ; switch ( $ spamstate ) { case "blockedForSpam" : case "unblocked" : case "unblocking" : break ; default : throw new BadMethodCallException ( 'Parameter $spamstate is invalid.' ) ; } try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/?state=' . $ spamstate ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
4145	protected function validateCredentials ( $ credentials ) { $ credentials = array_filter ( $ credentials ) ; $ keys = array_keys ( $ credentials ) ; $ diff = array_diff ( $ this -> requiredCredentials , $ keys ) ; if ( ! empty ( $ diff ) ) { throw new MissingCredentialsException ( 'Missing Credentials: ' . implode ( $ diff , ', ' ) ) ; } unset ( $ credentials , $ keys , $ diff ) ; }
11389	public function getLog ( ) { if ( ! isset ( $ this -> _log ) ) { $ this -> _log = new DataInterfaceLog ( ) ; if ( ! empty ( $ this -> interface ) ) { $ this -> _log -> data_interface_id = $ this -> interface -> interfaceObject -> id ; } $ this -> _log -> status = 'running' ; $ this -> _log -> started = date ( "Y-m-d G:i:s" ) ; $ this -> _log -> peak_memory = memory_get_usage ( ) ; } return $ this -> _log ; }
3342	public function getGroupList ( $ options = array ( ) ) { $ options = array_replace ( array ( 'from' => null , 'to' => null , 'limit' => null , 'request_limit' => null , 'reversed' => false , ) , $ options ) ; if ( ! empty ( $ options [ 'from' ] ) && ! empty ( $ options [ 'to' ] ) ) { throw new \ Exception ( 'Only one of "from" and "to" arguments is allowed' ) ; } $ options [ 'from' ] = self :: dateTimeString ( $ options [ 'from' ] ) ; $ options [ 'to' ] = self :: dateTimeString ( $ options [ 'to' ] ) ; return new GroupIterator ( $ this , $ options ) ; }
257	public function init ( ) { parent :: init ( ) ; if ( is_array ( $ this -> theme ) ) { if ( ! isset ( $ this -> theme [ 'class' ] ) ) { $ this -> theme [ 'class' ] = 'yii\base\Theme' ; } $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } elseif ( is_string ( $ this -> theme ) ) { $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } }
9226	public function get ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: get ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
5177	public function map ( \ Closure $ callback , $ context = [ ] ) : self { $ collection = new static ( ) ; foreach ( $ this -> props as $ key => $ value ) { $ collection -> add ( $ key , $ callback ( $ value , $ key , $ context ) ) ; } return $ collection ; }
220	private function formatNumber ( $ value , $ decimals , $ maxPosition , $ formatBase , $ options , $ textOptions ) { $ value = $ this -> normalizeNumericValue ( $ value ) ; $ position = 0 ; if ( is_array ( $ formatBase ) ) { $ maxPosition = count ( $ formatBase ) - 1 ; } do { if ( is_array ( $ formatBase ) ) { if ( ! isset ( $ formatBase [ $ position + 1 ] ) ) { break ; } if ( abs ( $ value ) < $ formatBase [ $ position + 1 ] ) { break ; } } else { if ( abs ( $ value ) < $ formatBase ) { break ; } $ value /= $ formatBase ; } $ position ++ ; } while ( $ position < $ maxPosition + 1 ) ; if ( is_array ( $ formatBase ) && $ position !== 0 ) { $ value /= $ formatBase [ $ position ] ; } if ( $ position === 0 ) { $ decimals = 0 ; } elseif ( $ decimals !== null ) { $ value = round ( $ value , $ decimals ) ; } $ oldThousandSeparator = $ this -> thousandSeparator ; $ this -> thousandSeparator = '' ; if ( $ this -> _intlLoaded && ! isset ( $ options [ NumberFormatter :: GROUPING_USED ] ) ) { $ options [ NumberFormatter :: GROUPING_USED ] = false ; } $ params = [ 'n' => abs ( $ value ) , 'nFormatted' => $ this -> asDecimal ( $ value , $ decimals , $ options , $ textOptions ) , ] ; $ this -> thousandSeparator = $ oldThousandSeparator ; return [ $ params , $ position ] ; }
4304	public function profileEnd ( $ name = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) ) ; if ( $ meta [ 'name' ] === null ) { \ end ( $ this -> data [ 'profileInstances' ] ) ; $ meta [ 'name' ] = \ key ( $ this -> data [ 'profileInstances' ] ) ; } $ name = $ meta [ 'name' ] ; if ( isset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ) { $ instance = $ this -> data [ 'profileInstances' ] [ $ name ] ; $ data = $ instance -> end ( ) ; $ caption = 'Profile \'' . $ name . '\' Results' ; if ( $ data ) { $ args = array ( $ data ) ; $ meta [ 'sortable' ] = true ; $ meta [ 'caption' ] = $ caption ; $ meta [ 'totalCols' ] = array ( 'ownTime' ) ; $ meta [ 'columns' ] = array ( ) ; } else { $ args = array ( $ caption , 'no data' ) ; } unset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ; } else { $ args = array ( $ name !== null ? 'profileEnd: No such Profile: ' . $ name : 'profileEnd: Not currently profiling' ) ; } $ this -> appendLog ( __FUNCTION__ , $ args , $ meta ) ; }
5564	protected function loadFrame ( $ frames , $ url , $ parameters ) { $ page = $ this -> fetch ( $ url , $ parameters ) ; $ this -> page -> setFrame ( $ frames , $ page ) ; return $ page -> getRaw ( ) ; }
3584	protected function metaHasQuery ( Builder $ query , $ method , ArgumentBag $ args ) { $ boolean = $ this -> getMetaBoolean ( $ args ) ; $ operator = $ this -> getMetaOperator ( $ method , $ args ) ; if ( in_array ( $ method , [ 'whereBetween' , 'where' ] ) ) { $ this -> unbindNumerics ( $ args ) ; } return $ query -> has ( 'metaAttributes' , $ operator , 1 , $ boolean , $ this -> getMetaWhereConstraint ( $ method , $ args ) ) -> with ( 'metaAttributes' ) ; }
5552	public function getResponseCode ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getResponseCode ( ) ; } return $ this -> frameset -> getResponseCode ( ) ; }
1822	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> imageSizes ) || ! \ is_array ( $ this -> User -> imageSizes ) ) { $ imageSizes = array ( ) ; } else { $ imageSizes = $ this -> User -> imageSizes ; } if ( \ in_array ( $ insertId , $ imageSizes ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_image_size' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_image_size' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, themes, imageSizes FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrThemes = Contao \ StringUtil :: deserialize ( $ objGroup -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objGroup -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT themes, imageSizes FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrThemes = Contao \ StringUtil :: deserialize ( $ objUser -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objUser -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ this -> User -> id ) ; } } $ imageSizes [ ] = $ insertId ; $ this -> User -> imageSizes = $ imageSizes ; } }
1204	protected function renderChildren ( ItemInterface $ item , array $ options ) { if ( null !== $ options [ 'depth' ] ) { $ options [ 'depth' ] = $ options [ 'depth' ] - 1 ; } if ( null !== $ options [ 'matchingDepth' ] && $ options [ 'matchingDepth' ] > 0 ) { $ options [ 'matchingDepth' ] = $ options [ 'matchingDepth' ] - 1 ; } $ html = '' ; foreach ( $ item -> getChildren ( ) as $ child ) { $ html .= $ this -> renderItem ( $ child , $ options ) ; } return $ html ; }
8082	public function report ( $ message ) { $ channel = $ this -> currentChannel ; if ( $ message ) { $ reports = & $ this -> getReports ( $ channel ) ; $ reports [ ] = $ message ; } return $ this ; }
11861	public function getCompanionId ( ) { if ( $ this -> isForeign && isset ( $ this -> foreignPrimaryKey ) ) { return $ this -> foreignPrimaryKey ; } elseif ( ! $ this -> isForeign && isset ( $ this -> localPrimaryKey ) ) { return $ this -> localPrimaryKey ; } if ( isset ( $ this -> companionObject ) ) { return $ this -> companionObject -> primaryKey ; } return ; }
3790	private function determineLanguages ( ) { $ languages = $ this -> getMetaModel ( ) -> getAvailableLanguages ( ) ; if ( $ languages === null ) { throw new \ RuntimeException ( 'MetaModel ' . $ this -> getMetaModel ( ) -> getName ( ) . ' does not seem to be translated.' ) ; } return $ languages ; }
12671	public static function getEmulatorInstance ( $ scheme , $ path , $ context ) { if ( ! isset ( static :: $ emulators [ $ scheme ] ) ) { throw new \ InvalidArgumentException ( 'No emulator found for scheme \'' . $ scheme . '\'' ) ; } $ emulator = static :: $ emulators [ $ scheme ] ; return new $ emulator ( $ path , $ context ) ; }
12485	public function adapterHasBehavior ( Adapter $ adapter , $ behavior ) { if ( $ adapter instanceof KnowsItsBehaviors ) { return in_array ( $ behavior , $ adapter -> getBehaviors ( ) ) ; } return true === is_a ( $ adapter , $ behavior ) ; }
9818	private function polynomialRegression ( $ order , $ yValues , $ xValues ) { $ x_sum = array_sum ( $ xValues ) ; $ y_sum = array_sum ( $ yValues ) ; $ xx_sum = $ xy_sum = 0 ; for ( $ i = 0 ; $ i < $ this -> valueCount ; ++ $ i ) { $ xy_sum += $ xValues [ $ i ] * $ yValues [ $ i ] ; $ xx_sum += $ xValues [ $ i ] * $ xValues [ $ i ] ; $ yy_sum += $ yValues [ $ i ] * $ yValues [ $ i ] ; } for ( $ i = 0 ; $ i < $ this -> valueCount ; ++ $ i ) { for ( $ j = 0 ; $ j <= $ order ; ++ $ j ) { $ A [ $ i ] [ $ j ] = pow ( $ xValues [ $ i ] , $ j ) ; } } for ( $ i = 0 ; $ i < $ this -> valueCount ; ++ $ i ) { $ B [ $ i ] = [ $ yValues [ $ i ] ] ; } $ matrixA = new Matrix ( $ A ) ; $ matrixB = new Matrix ( $ B ) ; $ C = $ matrixA -> solve ( $ matrixB ) ; $ coefficients = [ ] ; for ( $ i = 0 ; $ i < $ C -> getRowDimension ( ) ; ++ $ i ) { $ r = $ C -> get ( $ i , 0 ) ; if ( abs ( $ r ) <= pow ( 10 , - 9 ) ) { $ r = 0 ; } $ coefficients [ ] = $ r ; } $ this -> intersect = array_shift ( $ coefficients ) ; $ this -> slope = $ coefficients ; $ this -> calculateGoodnessOfFit ( $ x_sum , $ y_sum , $ xx_sum , $ yy_sum , $ xy_sum ) ; foreach ( $ this -> xValues as $ xKey => $ xValue ) { $ this -> yBestFitValues [ $ xKey ] = $ this -> getValueOfYForX ( $ xValue ) ; } }
72	public function authorizeOAuth ( $ originUrl ) { if ( $ originUrl !== 'bitbucket.org' ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config bitbucket.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , 'x-token-auth' , trim ( $ output ) ) ; return true ; } return false ; }
4725	private function addRule ( $ data , $ ruleType ) { if ( \ is_string ( $ data ) ) { $ data = array ( $ data ) ; } elseif ( ! \ is_array ( $ data ) ) { throw new InvalidArgumentException ( 'Invalid inflector rule data.' ) ; } foreach ( $ data as $ rule ) { array_push ( $ this -> rules [ $ ruleType ] , ( string ) $ rule ) ; } }
6634	public function parseProfileResponse ( Response $ response , AccessTokenInterface $ access_token ) { $ profile = $ response -> json ( ) ; if ( gettype ( $ profile ) !== 'object' ) { throw new InvalidProfileException ( ) ; } if ( isset ( $ profile -> error ) ) { $ error = $ profile -> error ; throw new InvalidProfileException ( $ error -> type . ': ' . $ error -> message , $ error -> code ) ; } $ profile -> access_token = $ access_token -> token ( ) ; return $ this -> profile -> instantiate ( $ profile , $ this -> name ) ; }
2815	public function addCollection ( Varien_Data_Collection_Db $ collection ) { $ info = Mage :: getModel ( 'sheep_debug/collection' ) ; $ info -> init ( $ collection ) ; $ key = $ info -> getClass ( ) ; if ( ! array_key_exists ( $ key , $ this -> collections ) ) { $ this -> collections [ $ key ] = $ info ; } $ this -> collections [ $ key ] -> incrementCount ( ) ; }
1805	public function getActiveGroups ( ) { $ arrGroups = array ( ) ; $ objGroup = Contao \ MemberGroupModel :: findAllActive ( ) ; if ( $ objGroup !== null ) { while ( $ objGroup -> next ( ) ) { $ arrGroups [ $ objGroup -> id ] = $ objGroup -> name ; } } return $ arrGroups ; }
9029	public function error ( Request $ request ) { $ this -> response -> setCode ( 404 ) ; printf ( "<h2>%s</h2>" , HttpStatus :: getStatus ( 404 ) ) ; printf ( "Requested document %s on %s could not be found!" , $ request -> getAction ( ) , $ request -> getController ( ) ) ; }
12283	public function render ( array $ data = null ) : string { $ this -> init ( $ data ?? [ ] ) ; return trim ( $ this -> make ( static :: LAYOUT_NAME ) ) . PHP_EOL ; }
2780	public function buildOptions ( ) : array { $ options = [ ] ; foreach ( $ this -> options as $ option => $ values ) { foreach ( ( array ) $ values as $ value ) { $ prefix = strlen ( $ option ) !== 1 ? '--' : '-' ; $ options [ ] = $ prefix . $ option ; if ( $ value !== true ) { $ options [ ] = $ value ; } } } return $ options ; }
3374	protected function getFilename ( $ filename ) { $ callback = $ this -> fileCallback ; if ( null === $ callback || substr ( $ filename , 0 , 1 ) == '/' ) { return $ filename ; } return $ callback ( $ filename ) ; }
1292	private function buildResult ( array $ data ) : Result { $ token = $ this -> getTokenFromResponse ( $ data ) ; $ done = isset ( $ data [ 'nextSyncUrl' ] ) ; $ items = \ array_map ( function ( array $ item ) : ResourceInterface { return $ this -> builder -> build ( $ item ) ; } , $ data [ 'items' ] ) ; return new Result ( $ items , $ token , $ done ) ; }
5513	public function expectMinimumCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set minimum call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_counts [ strtolower ( $ method ) ] = new MinimumCallCountExpectation ( $ method , $ count , $ message ) ; }
8490	public static function getUpTime ( ) { $ wmi = Windows :: getInstance ( ) ; $ booted_str = '' ; foreach ( $ wmi -> ExecQuery ( "SELECT LastBootUpTime FROM Win32_OperatingSystem" ) as $ os ) { $ booted_str = $ os -> LastBootUpTime ; } $ booted = [ 'year' => substr ( $ booted_str , 0 , 4 ) , 'month' => substr ( $ booted_str , 4 , 2 ) , 'day' => substr ( $ booted_str , 6 , 2 ) , 'hour' => substr ( $ booted_str , 8 , 2 ) , 'minute' => substr ( $ booted_str , 10 , 2 ) , 'second' => substr ( $ booted_str , 12 , 2 ) ] ; $ booted_ts = mktime ( $ booted [ 'hour' ] , $ booted [ 'minute' ] , $ booted [ 'second' ] , $ booted [ 'month' ] , $ booted [ 'day' ] , $ booted [ 'year' ] ) ; return date ( 'm/d/y h:i A (T)' , $ booted_ts ) ; }
3351	private function __setRequestType ( $ ch , $ type = 'GET' ) { $ this -> current_method = strtoupper ( $ type ) ; switch ( $ type ) { case 'GET' : break ; case 'POST' : curl_setopt ( $ ch , CURLOPT_POST , true ) ; break ; case 'PUT' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'PUT' ) ; break ; case 'DELETE' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'DELETE' ) ; break ; case 'HEAD' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'HEAD' ) ; curl_setopt ( $ ch , CURLOPT_NOBODY , true ) ; break ; case 'OPTIONS' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'OPTIONS' ) ; break ; default : throw new \ Exception ( 'No request type is provided for request. Use post, put, delete, get or appropriate constants.' ) ; } }
9210	protected function printValidationErrors ( $ table , $ id , $ errors ) { foreach ( $ errors as $ field => $ messages ) { foreach ( ( array ) $ messages as $ message ) { $ this -> quiet ( "<warning>{$table} ({$id}): {$field}: {$message}</warning>" ) ; } } }
8424	public function generate ( Request $ request ) { if ( count ( $ request -> getArgs ( ) ) != 1 ) { echo 'Wrong arguments.' . PHP_EOL . 'Usage : db/generate mapping_name' . PHP_EOL ; } else { $ mapping = $ request -> getArgs ( ) [ 0 ] ; $ schema = Schema :: getSchema ( $ mapping ) ; $ schema -> generateModels ( ) ; } }
3942	private static function buildLanguageArray ( IMetaModel $ metaModel , TranslatorInterface $ translator ) { $ languages = array ( ) ; foreach ( ( array ) $ metaModel -> getAvailableLanguages ( ) as $ langCode ) { $ languages [ $ langCode ] = $ translator -> translate ( 'LNG.' . $ langCode , 'languages' ) ; } asort ( $ languages ) ; return $ languages ; }
4920	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( ! $ spec instanceof Container ) { throw new \ InvalidArgumentException ( 'Tab container must be of the type \Core\Form\Container' ) ; } if ( ! $ spec -> getLabel ( ) ) { throw new \ InvalidArgumentException ( 'Container instances must have a label.' ) ; } } if ( is_array ( $ spec ) ) { if ( ! isset ( $ spec [ 'type' ] ) ) { $ spec [ 'type' ] = 'Core/Container' ; } if ( ! isset ( $ spec [ 'options' ] [ 'forms' ] ) && isset ( $ spec [ 'forms' ] ) ) { $ spec [ 'options' ] [ 'forms' ] = $ spec [ 'forms' ] ; unset ( $ spec [ 'forms' ] ) ; } } return parent :: setForm ( $ key , $ spec , $ enabled ) ; }
6183	public function add ( $ type , $ message , $ redirect = null ) { if ( ! isset ( $ type ) or ! isset ( $ message [ 0 ] ) ) { return false ; } if ( strlen ( trim ( $ type ) ) === 1 ) { $ type = str_replace ( [ 'h' , 'i' , 'w' , 'e' , 's' ] , [ 'help' , 'info' , 'warning' , 'error' , 'success' ] , $ type ) ; } $ router = new Router ( ) ; try { if ( ! in_array ( $ type , $ this -> msgTypes ) ) { throw new BaseException ( '"' . strip_tags ( $ type ) . '" is not a valid message type!' , 501 ) ; } } catch ( BaseException $ e ) { $ msg = null ; if ( ini_get ( 'display_errors' ) === "on" ) { $ msg .= '<pre>' ; $ msg .= 'Message: <b>' . $ e -> getMessage ( ) . '</b><br><br>' ; $ msg .= 'Accept: ' . $ _SERVER [ 'HTTP_ACCEPT' ] . '<br>' ; if ( isset ( $ _SERVER [ 'HTTP_REFERER' ] ) ) { $ msg .= 'Referer: ' . $ _SERVER [ 'HTTP_REFERER' ] . '<br><br>' ; } $ msg .= 'Request Method: ' . $ _SERVER [ 'REQUEST_METHOD' ] . '<br><br>' ; $ msg .= 'Current file Path: <b>' . $ this -> router -> currentPath ( ) . '</b><br>' ; $ msg .= 'File Exception: ' . $ e -> getFile ( ) . ':' . $ e -> getLine ( ) . '<br><br>' ; $ msg .= 'Trace: <br>' . $ e -> getTraceAsString ( ) . '<br>' ; $ msg .= '</pre>' ; return Response :: create ( $ msg ) -> display ( ) ; } return Response :: create ( $ e -> getMessage ( ) ) -> status ( 501 ) -> display ( ) ; } $ get = $ this -> driver -> get ( 'flash_messages' ) ; $ get [ $ type ] [ ] = $ message ; $ this -> driver -> set ( 'flash_messages' , $ get ) ; if ( ! is_null ( $ redirect ) ) { return $ router -> redirect ( $ redirect , 301 ) ; } return true ; }
1949	public function showRelatedRecords ( $ data , $ row ) { Contao \ System :: loadLanguageFile ( 'tl_opt_in_related' ) ; Contao \ Controller :: loadDataContainer ( 'tl_opt_in_related' ) ; $ objRelated = $ this -> Database -> prepare ( "SELECT * FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ row [ 'id' ] ) ; while ( $ objRelated -> next ( ) ) { $ arrAdd = array ( ) ; $ arrRow = $ objRelated -> row ( ) ; foreach ( $ arrRow as $ k => $ v ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] ; $ arrAdd [ $ label ] = $ v ; } $ data [ 'tl_opt_in_related' ] [ ] = $ arrAdd ; } return $ data ; }
352	public static function getInputId ( $ model , $ attribute ) { $ charset = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; $ name = mb_strtolower ( static :: getInputName ( $ model , $ attribute ) , $ charset ) ; return str_replace ( [ '[]' , '][' , '[' , ']' , ' ' , '.' ] , [ '' , '-' , '-' , '' , '-' , '-' ] , $ name ) ; }
5476	protected function encode ( ) { $ class = $ this -> encoding ; $ encoding = new $ class ( ) ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { $ this -> widgets [ $ i ] -> write ( $ encoding ) ; } return $ encoding ; }
4673	public function getTemplateFile ( $ template ) { $ file = $ template . $ this -> suffix ; if ( is_file ( $ file ) ) { return $ file ; } foreach ( $ this -> paths as $ path ) { $ file = $ path . "/" . $ template . $ this -> suffix ; if ( is_file ( $ file ) ) { return $ file ; } } throw new Exception ( "Could not find template file '$template'." ) ; }
5964	public function channelGroupGetById ( $ cgid ) { if ( ! array_key_exists ( ( string ) $ cgid , $ this -> channelGroupList ( ) ) ) { throw new Ts3Exception ( "invalid groupID" , 0xA00 ) ; } return $ this -> cgroupList [ intval ( ( string ) $ cgid ) ] ; }
5667	public function getType ( $ value ) { if ( ! isset ( $ value ) ) { return 'Null' ; } elseif ( is_bool ( $ value ) ) { return 'Boolean' ; } elseif ( is_string ( $ value ) ) { return 'String' ; } elseif ( is_integer ( $ value ) ) { return 'Integer' ; } elseif ( is_float ( $ value ) ) { return 'Float' ; } elseif ( is_array ( $ value ) ) { return 'Array' ; } elseif ( is_resource ( $ value ) ) { return 'Resource' ; } elseif ( is_object ( $ value ) ) { return 'Object' ; } return 'Unknown' ; }
8574	public function setGetMyPriceForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMyPriceForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12974	protected function autoLoadMappingInfo ( ) { $ mappings = array ( ) ; foreach ( \ Package :: loaded ( ) as $ package => $ path ) { $ mappings [ ] = $ package . '::package' ; } foreach ( \ Module :: loaded ( ) as $ module => $ path ) { $ mappings [ ] = $ module . '::module' ; } $ mappings [ ] = 'app' ; $ mappings = array_fill_keys ( $ mappings , array ( 'is_component' => true ) ) ; $ this -> setMappings ( $ mappings ) ; }
433	public function setModules ( $ modules ) { foreach ( $ modules as $ id => $ module ) { $ this -> _modules [ $ id ] = $ module ; } }
10981	public function tree ( $ trans = false ) { $ tree = [ ] ; foreach ( $ this -> items as $ date => $ log ) { $ tree [ $ date ] = $ log -> tree ( $ trans ) ; } return $ tree ; }
1855	public static function findUpcomingByPids ( $ arrIds , $ intLimit = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "($t.endTime>=$time OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$time))) AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ") AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ) ; if ( $ intLimit > 0 ) { $ arrOptions [ 'limit' ] = $ intLimit ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
10495	public function mod ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ value == 0 ) { throw new InvalidArgumentException ( 'Division by zero' ) ; } if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value % $ value ) ; }
7718	function meth_Conv_Prepare ( & $ Loc , $ StrConv ) { $ x = strtolower ( $ StrConv ) ; $ x = '+' . str_replace ( ' ' , '' , $ x ) . '+' ; if ( strpos ( $ x , '+esc+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvEsc = true ; } if ( strpos ( $ x , '+wsp+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvWS = true ; } if ( strpos ( $ x , '+js+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvJS = true ; } if ( strpos ( $ x , '+url+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUrl = true ; } if ( strpos ( $ x , '+utf8+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUtf8 = true ; } if ( strpos ( $ x , '+no+' ) !== false ) $ Loc -> ConvStr = false ; if ( strpos ( $ x , '+yes+' ) !== false ) $ Loc -> ConvStr = true ; if ( strpos ( $ x , '+nobr+' ) !== false ) { $ Loc -> ConvStr = true ; $ Loc -> ConvBr = false ; } }
6489	private function addHeaderValue ( HttpHeaders $ headers , string $ name , $ value , bool $ append ) : void { $ decodedValue = trim ( ( string ) ( isset ( self :: $ headersToUrlDecode [ $ name ] ) ? urldecode ( $ value ) : $ value ) ) ; if ( isset ( self :: $ specialCaseHeaders [ $ name ] ) ) { $ headers -> add ( $ name , $ decodedValue , $ append ) ; } elseif ( strpos ( $ name , 'HTTP_' ) === 0 ) { $ normalizedName = substr ( $ name , 5 ) ; $ headers -> add ( $ normalizedName , $ decodedValue , $ append ) ; } }
2589	protected function addReceivedFrom ( $ explicitRf , $ doAutoAdd , $ defaultRf , & $ tattooCounter ) { if ( $ this -> dataElementsMaster === null ) { $ this -> dataElementsMaster = new DataElementsMaster ( ) ; } if ( ! empty ( $ explicitRf ) || ( $ doAutoAdd && ! empty ( $ defaultRf ) ) ) { $ tattooCounter ++ ; $ rfToAdd = ( ! empty ( $ explicitRf ) ) ? $ explicitRf : $ defaultRf ; $ this -> dataElementsMaster -> dataElementsIndiv [ ] = $ this -> createElement ( new ReceivedFrom ( [ 'receivedFrom' => $ rfToAdd ] ) , $ tattooCounter ) ; } }
8374	public function set ( $ set ) { if ( is_array ( $ set ) === true ) { $ this -> set = '' ; foreach ( $ set as $ name => $ value ) { $ pos = stripos ( $ name , '.' ) ; if ( $ pos !== false ) { $ this -> set .= substr ( $ name , $ pos + 1 ) ; } else { $ this -> set .= $ name ; } $ this -> set .= ' = ' . $ value . ', ' ; } $ this -> set = substr ( $ this -> set , 0 , - 2 ) ; } else { $ this -> set = $ set ; } return $ this ; }
3571	public function queryHook ( ) { return function ( $ next , $ query , $ bag ) { $ method = $ bag -> get ( 'method' ) ; $ args = $ bag -> get ( 'args' ) ; $ column = $ args -> get ( 'column' ) ; if ( ! $ this -> hasColumn ( $ column ) && $ this -> allowsMeta ( $ column ) && $ this -> isMetaQueryable ( $ method ) ) { return call_user_func_array ( [ $ this , 'metaQuery' ] , [ $ query , $ method , $ args ] ) ; } if ( in_array ( $ method , [ 'select' , 'addSelect' ] ) ) { call_user_func_array ( [ $ this , 'metaSelect' ] , [ $ query , $ args ] ) ; } return $ next ( $ query , $ bag ) ; } ; }
12154	public function getRequiredRoles ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = false ; switch ( $ roleItem -> systemId ) { case 'owner' : $ test = $ this -> isOwnable ; break ; } if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
4893	protected function array_compare ( $ array1 , $ array2 , $ maxDepth = 2 ) { $ result = array ( ) ; $ arraykeys = array_unique ( array_merge ( array_keys ( $ array1 ) , array_keys ( $ array2 ) ) ) ; foreach ( $ arraykeys as $ key ) { if ( ! empty ( $ key ) && is_string ( $ key ) && $ key [ 0 ] != "\0" && substr ( $ key , 0 , 8 ) != 'Doctrine' ) { if ( array_key_exists ( $ key , $ array1 ) && ! array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , '' ) ; } if ( ! array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( '' , $ array2 [ $ key ] ) ; } if ( array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ subResult = null ; if ( is_array ( $ array1 [ $ key ] ) && is_array ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ subResult = $ this -> array_compare ( $ array1 [ $ key ] , $ array2 [ $ key ] , $ maxDepth - 1 ) ; } } elseif ( is_object ( $ array1 [ $ key ] ) && is_object ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ hydrator = new EntityHydrator ( ) ; $ a1 = $ hydrator -> extract ( $ array1 [ $ key ] ) ; $ a2 = $ hydrator -> extract ( $ array2 [ $ key ] ) ; $ subResult = $ this -> array_compare ( $ a1 , $ a2 , $ maxDepth - 1 ) ; } } else { if ( $ array1 [ $ key ] != $ array2 [ $ key ] ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , $ array2 [ $ key ] ) ; } } if ( ! empty ( $ subResult ) ) { foreach ( $ subResult as $ subKey => $ subValue ) { if ( ! empty ( $ subKey ) && is_string ( $ subKey ) ) { $ result [ $ key . '.' . $ subKey ] = $ subValue ; } } } } } } return $ result ; }
12252	public function addMissing ( $ objStructure , & $ objElement ) { foreach ( $ objStructure -> attributes ( ) as $ strName => $ objAttribute ) { if ( ! isset ( $ objElement -> attributes ( ) -> $ strName ) ) { $ objElement -> addAttribute ( $ strName , ( string ) $ objAttribute ) ; } } foreach ( $ objStructure -> children ( ) as $ strName => $ varNode ) { if ( count ( $ varNode ) > 0 ) { $ objNode = $ objElement -> addChild ( $ strName ) ; $ this -> addMissing ( $ varNode , $ objNode ) ; } else { $ objElement -> addChild ( $ strName , ( string ) $ varNode ) ; } } }
1075	public static function fromArray ( array $ node ) : Node { if ( ! isset ( $ node [ 'kind' ] ) || ! isset ( NodeKind :: $ classMap [ $ node [ 'kind' ] ] ) ) { throw new InvariantViolation ( 'Unexpected node structure: ' . Utils :: printSafeJson ( $ node ) ) ; } $ kind = $ node [ 'kind' ] ?? null ; $ class = NodeKind :: $ classMap [ $ kind ] ; $ instance = new $ class ( [ ] ) ; if ( isset ( $ node [ 'loc' ] , $ node [ 'loc' ] [ 'start' ] , $ node [ 'loc' ] [ 'end' ] ) ) { $ instance -> loc = Location :: create ( $ node [ 'loc' ] [ 'start' ] , $ node [ 'loc' ] [ 'end' ] ) ; } foreach ( $ node as $ key => $ value ) { if ( $ key === 'loc' || $ key === 'kind' ) { continue ; } if ( is_array ( $ value ) ) { if ( isset ( $ value [ 0 ] ) || empty ( $ value ) ) { $ value = new NodeList ( $ value ) ; } else { $ value = self :: fromArray ( $ value ) ; } } $ instance -> { $ key } = $ value ; } return $ instance ; }
5600	public static function getSeverityAsString ( $ severity ) { static $ map = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_WARNING => 'E_USER_WARNING' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , E_DEPRECATED => 'E_DEPRECATED' , E_USER_DEPRECATED => 'E_USER_DEPRECATED' , E_ALL => 'E_ALL' ) ; return $ map [ $ severity ] ; }
10500	public function lte ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value !== null && $ this -> value <= $ value ) { return true ; } return false ; }
11400	public function fromData ( $ data ) { $ this -> fromdata = $ data ; $ resource = fopen ( 'php://memory' , 'r+' ) ; fwrite ( $ resource , $ data ) ; rewind ( $ resource ) ; $ this -> setResource ( $ resource ) ; return $ this ; }
3076	public function processInput ( QtiRunnerServiceContext $ context , array $ input ) { $ responses = [ ] ; foreach ( $ input as $ data ) { if ( ! is_array ( $ data ) || ! isset ( $ data [ 'channel' ] ) || ! isset ( $ data [ 'message' ] ) ) { throw new \ common_exception_InconsistentData ( 'Wrong message chunk received by the bidirectional communication service: either channel or message content is missing!' ) ; } if ( $ this -> hasChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ) { $ channel = $ this -> getChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ; $ responses [ ] = $ this -> processChannel ( $ channel , $ context , $ data [ 'message' ] ) ; } else { $ responses [ ] = $ this -> fallback ( $ data [ 'channel' ] , $ context , $ data [ 'message' ] ) ; } } return $ responses ; }
547	protected function addServers ( $ cache , $ servers ) { if ( empty ( $ servers ) ) { $ servers = [ new MemCacheServer ( [ 'host' => '127.0.0.1' , 'port' => 11211 , ] ) ] ; } else { foreach ( $ servers as $ server ) { if ( $ server -> host === null ) { throw new InvalidConfigException ( "The 'host' property must be specified for every memcache server." ) ; } } } if ( $ this -> useMemcached ) { $ this -> addMemcachedServers ( $ cache , $ servers ) ; } else { $ this -> addMemcacheServers ( $ cache , $ servers ) ; } }
7465	public static function createFromUploadedFile ( UploadedFile $ upload , $ uploadPath , $ filename = null ) { if ( ! $ upload -> isValid ( ) ) { throw new UploadException ( sprintf ( 'An error occurred during file upload. Error code: %s' , $ upload -> getError ( ) ) ) ; } elseif ( ( $ uploadPath = realpath ( $ uploadPath . '/' ) ) === false ) { throw new UploadException ( 'An error occurred during file upload. The specified upload path is invalid.' ) ; } if ( ! $ filename ) { $ fullPath = sprintf ( '%s%s%s.%s' , rtrim ( $ uploadPath , DIRECTORY_SEPARATOR ) , DIRECTORY_SEPARATOR , uniqid ( ) , ( $ upload -> getExtension ( ) ? : ( $ upload -> guessExtension ( ) ? : 'file' ) ) ) ; } else { $ fullPath = rtrim ( $ uploadPath , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . $ filename ; } $ file = new self ( $ fullPath , $ upload -> getClientOriginalName ( ) , $ upload -> getMimeType ( ) , $ upload -> getClientSize ( ) , md5_file ( $ upload -> getRealPath ( ) ) ) ; $ file -> _uploadedFile = $ upload ; return $ file ; }
2471	public function findContent ( Query $ query , array $ languageFilter = array ( ) ) { $ query = clone $ query ; $ query -> filter = $ query -> filter ? : new Criterion \ MatchAll ( ) ; $ query -> query = $ query -> query ? : new Criterion \ MatchAll ( ) ; $ this -> coreFilter -> apply ( $ query , $ languageFilter , DocumentMapper :: DOCUMENT_TYPE_IDENTIFIER_CONTENT ) ; return $ this -> resultExtractor -> extract ( $ this -> gateway -> findContent ( $ query , $ languageFilter ) , $ query -> facetBuilders ) ; }
1982	public static function hasError ( $ strScope = TL_MODE ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return false ; } return $ session -> getFlashBag ( ) -> has ( static :: getFlashBagKey ( 'error' , $ strScope ) ) ; }
6687	protected function mergeFlashMessages ( $ messageArray ) { $ messages = array_values ( $ messageArray ) ; $ flashMessage = '' ; $ flashMessageArr = [ ] ; foreach ( $ messages as $ message ) { if ( is_array ( $ message ) ) { if ( strlen ( $ flashMessage ) > 0 ) { $ flashMessage .= '<br/>' ; } $ flashMessage .= $ this -> mergeFlashMessages ( $ message ) ; } else { $ flashMessageArr [ ] = $ message ; } } return $ flashMessage . implode ( '<br/>' , $ flashMessageArr ) ; }
11497	public static function all ( $ pageNumber = 0 , $ pageSize = 10 , $ order = null ) { return ( new static ( ) ) -> fetchAll ( null , $ order , $ pageSize , $ pageNumber ) ; }
6386	public function readUser ( $ id ) { $ model = $ this -> readObject ( $ id , 'user' ) ; $ model -> url = $ this -> cfg -> wwwroot ; $ model -> fullname = $ this -> fullname ( $ model ) ; if ( isset ( $ model -> password ) ) { unset ( $ model -> password ) ; } if ( isset ( $ model -> secret ) ) { unset ( $ model -> secret ) ; } if ( isset ( $ model -> lastip ) ) { unset ( $ model -> lastip ) ; } return $ model ; }
5479	protected function addRadioButton ( $ tag ) { if ( ! isset ( $ this -> radios [ $ tag -> getName ( ) ] ) ) { $ this -> widgets [ ] = new SimpleRadioGroup ( ) ; $ this -> radios [ $ tag -> getName ( ) ] = count ( $ this -> widgets ) - 1 ; } $ this -> widgets [ $ this -> radios [ $ tag -> getName ( ) ] ] -> addWidget ( $ tag ) ; }
2926	public function load ( $ filePath = null , $ restoreIfNotFound = false , $ restorePath = null ) { $ this -> resetContent ( ) ; if ( ! is_null ( $ filePath ) ) { $ this -> filePath = $ filePath ; } else { if ( method_exists ( $ this -> app , 'environmentPath' ) && method_exists ( $ this -> app , 'environmentFile' ) ) { $ this -> filePath = $ this -> app -> environmentPath ( ) . '/' . $ this -> app -> environmentFile ( ) ; } else { $ this -> filePath = __DIR__ . '/../../../../../../.env' ; } } $ this -> reader -> load ( $ this -> filePath ) ; if ( file_exists ( $ this -> filePath ) ) { $ this -> writer -> setBuffer ( $ this -> getContent ( ) ) ; return $ this ; } elseif ( $ restoreIfNotFound ) { return $ this -> restore ( $ restorePath ) ; } else { return $ this ; } }
2037	public function getSlugOptions ( ) { $ slugOptions = array ( 'locale' => $ this -> language ) ; if ( $ this -> validAliasCharacters ) { $ slugOptions [ 'validChars' ] = $ this -> validAliasCharacters ; } return $ slugOptions ; }
1529	public function route ( ) : RouteRegistration { $ route = new RouteRegistration ( $ this -> router , $ this , $ this -> defaults ) ; $ route -> controller ( $ this -> options [ 'controller' ] ?? '' ) ; return $ route ; }
5529	protected function chainMockReturns ( ) { $ code = " function returns(\$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returns(\$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsAt(\$timing, \$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsAt(\$timing, \$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByValue(\$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returns(\$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByValueAt(\$timing, \$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByValueAt(\$timing, \$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByReference(\$method, &\$ref, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByReference(\$method, \$ref, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByReferenceAt(\$timing, \$method, &\$ref, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByReferenceAt(\$timing, \$method, \$ref, \$args);\n" ; $ code .= " }\n" ; return $ code ; }
5915	public function sendPasswordReset ( $ id , $ link = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'link' => $ link ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/resetpassword' , $ parameters ) ; return $ result ; }
1492	public function current ( $ meta = null , array $ queryParams = [ ] ) { $ url = $ this -> generator -> current ( ) ; if ( $ queryParams ) { $ url .= '?' . http_build_query ( $ queryParams ) ; } return $ this -> factory -> createLink ( $ url , $ meta , true ) ; }
1780	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'calendar' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } $ this -> cal_calendar = $ this -> sortOutProtected ( StringUtil :: deserialize ( $ this -> cal_calendar , true ) ) ; if ( empty ( $ this -> cal_calendar ) || ! \ is_array ( $ this -> cal_calendar ) ) { return '' ; } $ this -> strUrl = preg_replace ( '/\?.*$/' , '' , Environment :: get ( 'request' ) ) ; $ this -> strLink = $ this -> strUrl ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> strLink = $ objTarget -> getFrontendUrl ( ) ; } return parent :: generate ( ) ; }
10561	public function createController ( $ route , $ params ) { $ control = NULL ; $ route = ltrim ( $ route , '/' ) ; $ route = rtrim ( $ route , '/' ) ; $ vars = explode ( '/' , $ route ) ; if ( 1 === count ( $ vars ) && '' == $ vars [ 0 ] ) { $ control = $ this -> _buildControllerName ( $ this -> defaultController . 'Controller' ) ; $ aName = $ this -> _buildActionName ( $ control , $ this -> defaultAction ) ; } else if ( 1 === count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ this -> defaultAction ) ; } else if ( 2 === count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ vars [ 0 ] ) ; } else if ( 2 < count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ vars [ 0 ] ) ; array_shift ( $ vars ) ; } else { $ control = $ this -> _buildControllerName ( $ this -> defaultController . 'Controller' ) ; $ aName = $ this -> defaultAction . 'Action' ; } $ action = new Action ( $ aName , $ params ) ; $ controller = new $ control ( $ this -> config ) ; $ controller -> setAction ( $ action ) ; $ controller -> setDispatcher ( $ this -> dispatcher ) ; $ controller -> addDefaultListeners ( ) ; return $ controller ; }
11288	protected function _getRelation ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = false ; if ( isset ( $ def [ 'models' ] ) ) { $ result = $ this -> _getModels ( $ attributeName , $ def [ 'models' ] , $ query , $ loadMap , $ record ) ; } else if ( isset ( $ def [ 'model' ] ) ) { $ result = $ this -> _getModel ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap , $ record ) ; } return $ result ; }
12384	public static function perDay ( $ days = 1 , $ date_format = "m-d" ) { $ hits_per_day = [ ] ; for ( $ i = 1 ; $ i <= $ days ; $ i ++ ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subDays ( $ i ) , Carbon :: now ( ) -> subDays ( $ i - 1 ) ) ; $ hits_per_day [ Carbon :: now ( ) -> subDays ( $ i ) -> format ( $ date_format ) ] = $ hits_count ; } return $ hits_per_day ; }
538	protected function serializeDataProvider ( $ dataProvider ) { if ( $ this -> preserveKeys ) { $ models = $ dataProvider -> getModels ( ) ; } else { $ models = array_values ( $ dataProvider -> getModels ( ) ) ; } $ models = $ this -> serializeModels ( $ models ) ; if ( ( $ pagination = $ dataProvider -> getPagination ( ) ) !== false ) { $ this -> addPaginationHeaders ( $ pagination ) ; } if ( $ this -> request -> getIsHead ( ) ) { return null ; } elseif ( $ this -> collectionEnvelope === null ) { return $ models ; } $ result = [ $ this -> collectionEnvelope => $ models , ] ; if ( $ pagination !== false ) { return array_merge ( $ result , $ this -> serializePagination ( $ pagination ) ) ; } return $ result ; }
8518	public function setSelectionRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SelectionRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1820	public function extractVimeoId ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> vimeo != $ varValue ) { $ matches = array ( ) ; if ( preg_match ( '%vimeo\.com/(?:channels/(?:\w+/)?|groups/(?:[^/]+)/videos/|album/(?:\d+)/video/)?(\d+)(?:$|/|\?)%i' , $ varValue , $ matches ) ) { $ varValue = $ matches [ 1 ] ; } } return $ varValue ; }
1347	public function isReadProcesses ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isProcesses ( ) && $ this -> getRoute ( ) -> isNotProcess ( ) ; }
12214	public function run ( $ route ) { if ( ! is_array ( $ route ) ) { $ this -> makeResponse ( $ route ) ; } $ viewSegments = explode ( '.' , $ route [ 'view' ] ) ; $ method = $ route [ 'method' ] ; Setup :: toDefine ( 'TEMPLATES_PATH' , APPS_ROOT . DS . $ this -> appName . DS . 'Templates' . DS ) ; Setup :: toDefine ( 'STATIC_PATH' , APPS_ROOT . DS . 'static' . DS ) ; $ viewPath = '' ; $ view = $ viewSegments [ 0 ] ; if ( count ( $ viewSegments ) > 1 ) { $ view = $ viewSegments [ count ( $ viewSegments ) - 1 ] ; array_pop ( $ viewSegments ) ; $ viewPath = implode ( '\\' , $ viewSegments ) ; $ viewPath .= '\\' ; } if ( $ view instanceof \ ForeverPHP \ View \ View ) { throw new ViewException ( "La vista ($view) no hereda de View." ) ; } if ( Settings :: getInstance ( ) -> get ( 'usingNamespaces' ) ) { $ view = '\\Apps\\' . $ this -> appName . '\\Views\\' . $ viewPath . $ view ; } $ v = new $ view ( ) ; $ returnValue = $ v -> $ method ( ) ; $ this -> makeResponse ( $ returnValue ) ; }
3000	public function reset ( $ key = null ) { if ( $ key ) { $ key = ucfirst ( $ key ) ; $ this -> smtp -> clear ( $ key ) ; if ( isset ( $ this -> recipients [ $ key ] ) ) unset ( $ this -> recipients [ $ key ] ) ; } else { $ this -> recipients = array ( ) ; $ this -> initSMTP ( ) ; } }
5603	public function paintException ( $ exception ) { if ( ! $ this -> fail && ! $ this -> error ) { $ this -> error = true ; $ message = 'Unexpected exception of type[' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; $ this -> message = self :: escapeVal ( $ message ) ; $ this -> listener -> write ( '{status:"error",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
1731	public static function triggerImportUserHook ( $ username , $ password , $ strTable ) { $ self = new static ( ) ; if ( empty ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] ) || ! \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] ) ) { return false ; } @ trigger_error ( 'Using the "importUser" hook has been deprecated and will no longer work in Contao 5.0. Use the contao.import_user event instead.' , E_USER_DEPRECATED ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] as $ callback ) { $ self -> import ( $ callback [ 0 ] , 'objImport' , true ) ; $ blnLoaded = $ self -> objImport -> { $ callback [ 1 ] } ( $ username , $ password , $ strTable ) ; if ( $ blnLoaded === true ) { return true ; } } return false ; }
11095	public static function generatePin ( $ salt , $ length = 6 , $ useMinutes = false ) { $ seed = sha1 ( $ salt . ( new \ DateTime ( 'now' , new \ DateTimeZone ( 'Europe/Prague' ) ) ) -> format ( 'Ymd' . ( $ useMinutes ? 'i' : '' ) ) , true ) ; for ( $ i = 0 ; $ i <= ( new \ DateTime ( 'now' , new \ DateTimeZone ( 'Europe/Prague' ) ) ) -> format ( 'G' ) ; $ i ++ ) { $ seed = sha1 ( $ seed . $ i ) ; } $ data = unpack ( 'V1/V2' , $ seed ) ; $ data [ 1 ] = $ data [ 1 ] < 0 ? $ data [ 1 ] * - 1 : $ data [ 1 ] ; $ data [ 2 ] = $ data [ 2 ] < 0 ? $ data [ 2 ] * - 1 : $ data [ 2 ] ; $ mask = $ data [ 1 ] ^ $ data [ 2 ] ; if ( $ mask % 1000000 === 0 || $ mask % 1000000 === 999999 ) { return self :: generatePin ( $ salt . $ seed , $ length , $ useMinutes ) ; } return round ( ( ( ( float ) ( $ mask % 1000000 ) - 0.5 + ( ( float ) ( $ mask % 200 ) / 199 ) ) / 999999 ) * ( ( ( 10 ** $ length ) - 1 ) - ( 10 ** ( $ length - 1 ) ) ) + ( 10 ** ( $ length - 1 ) ) ) ; }
7928	public function unregisterNamespace ( $ ns ) { list ( $ ns ) = $ this -> fireEvent ( 'namespace.unregister' , [ $ ns ] ) ; unset ( $ this -> namespaces [ $ ns ] ) ; return $ this ; }
12551	public function isSerialized ( ) { if ( ! is_string ( $ this -> serialized ) ) { return false ; } $ this -> serialized = trim ( $ this -> serialized ) ; if ( 'N;' == $ this -> serialized ) { return true ; } $ length = strlen ( $ this -> serialized ) ; if ( $ length < 4 ) { return false ; } if ( ':' !== $ this -> serialized [ 1 ] ) { return false ; } $ lastc = $ this -> serialized [ $ length - 1 ] ; if ( ';' !== $ lastc && '}' !== $ lastc ) { return false ; } $ token = $ this -> serialized [ 0 ] ; switch ( $ token ) { case 's' : if ( '"' !== $ this -> serialized [ $ length - 2 ] ) { return false ; } case 'a' : case 'O' : return ( bool ) preg_match ( "/^{$token}:[0-9]+:/s" , $ this -> serialized ) ; case 'b' : case 'i' : case 'd' : return ( bool ) preg_match ( "/^{$token}:[0-9.E-]+;\$/" , $ this -> serialized ) ; } return false ; }
10303	public function setUseDiskCaching ( $ pValue , $ pDirectory = null ) { $ this -> useDiskCaching = $ pValue ; if ( $ pDirectory !== null ) { if ( is_dir ( $ pDirectory ) ) { $ this -> diskCachingDirectory = $ pDirectory ; } else { throw new Exception ( "Directory does not exist: $pDirectory" ) ; } } return $ this ; }
10295	public static function dayStringToNumber ( $ day ) { $ strippedDayValue = ( str_replace ( self :: $ numberSuffixes , '' , $ day ) ) ; if ( is_numeric ( $ strippedDayValue ) ) { return ( int ) $ strippedDayValue ; } return $ day ; }
5875	public function containerAdd ( ServerRequestInterface $ request , ResponseInterface $ response ) : ResponseInterface { $ GLOBALS [ 'TCA' ] [ 'tx_imageautoresize' ] = include ( ExtensionManagementUtility :: extPath ( 'image_autoresize' ) . 'Configuration/TCA/Module/Options.php' ) ; $ GLOBALS [ 'TCA' ] [ 'tx_imageautoresize' ] [ 'ajax' ] = true ; $ dataProviders = & $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'formEngine' ] [ 'formDataGroup' ] [ 'tcaDatabaseRecord' ] ; $ dataProviders [ \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: class ] = [ 'before' => [ \ TYPO3 \ CMS \ Backend \ Form \ FormDataProvider \ DatabaseEditRow :: class , ] ] ; $ record = [ 'uid' => \ Causal \ ImageAutoresize \ Controller \ ConfigurationController :: virtualRecordId , 'pid' => 0 , ] ; \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: initialize ( $ record ) ; $ response = parent :: containerAdd ( $ request , $ response ) ; return $ response -> withHeader ( 'Content-Type' , 'application/json; charset=utf-8' ) ; }
9525	public function parse ( $ argv = null , ParameterCluster $ parameterCluster = null ) { $ this -> initialize ( $ argv , $ parameterCluster ) ; return $ this -> checkValidityAndContinueParse ( ) ; }
12600	public static function copy ( $ src , $ dest , $ force = true ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; if ( ! Folder :: exists ( dirname ( $ dest ) ) ) { Folder :: create ( dirname ( $ dest ) ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> copy ( $ src , $ dest , $ force ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
12306	protected function __apiUpdateStrict ( string $ id ) { HCLanguages :: where ( 'id' , $ id ) -> update ( $ this -> getStrictRequestParameters ( ) ) ; return $ this -> apiShow ( $ id ) ; }
11028	protected function address ( ) { $ this -> parts [ '{address}' ] = $ this -> form -> field ( $ this -> model , 'address' ) -> textInput ( [ 'name' => $ this -> getSubmitModelName ( 'address' ) , 'id' => $ this -> fieldIds [ 'address' ] ] ) ; }
5686	public function expandUrl ( $ url ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } $ location = $ this -> getBaseUrl ( ) ? $ this -> getBaseUrl ( ) : new SimpleUrl ( ) ; return $ url -> makeAbsolute ( $ location -> makeAbsolute ( $ this -> getUrl ( ) ) ) ; }
1131	public function inSameScope ( $ other ) { foreach ( $ this -> getScopedColumns ( ) as $ fld ) { if ( $ this -> $ fld != $ other -> $ fld ) return false ; } return true ; }
7313	public function setDate ( $ year , $ month , $ day ) { $ status = IAU :: Cal2jd ( ( int ) $ year , ( int ) $ month , ( int ) $ day , $ djm0 , $ djm ) ; $ this -> checkDate ( $ status ) ; $ this -> jd = $ djm0 + $ djm ; return $ this ; }
8694	public static function parse ( $ size , $ fallbackUnits = null ) { preg_match ( '/^(\d+)[.,]?(\d*)\s*(\w*)$/' , $ size , $ matches ) ; if ( empty ( $ matches [ 1 ] ) || ( empty ( $ matches [ 3 ] ) && null === $ fallbackUnits ) ) { throw new \ UnexpectedValueException ( "Unable to parse : '{$size}'" ) ; } $ oSize = $ matches [ 1 ] ; if ( ! empty ( $ matches [ 2 ] ) ) { $ oSize .= '.' . $ matches [ 2 ] ; } $ oSize = ( float ) $ oSize ; $ unit = strtolower ( empty ( $ matches [ 3 ] ) ? $ fallbackUnits : $ matches [ 3 ] ) ; $ byteMultiplier = 1 ; if ( 'b' === substr ( $ unit , - 1 ) ) { $ byteMultiplier = 8 ; $ unit = substr ( $ unit , 0 , - 1 ) . 'o' ; } if ( ! array_key_exists ( $ unit , self :: getBinarySizes ( ) ) ) { throw new \ UnexpectedValueException ( "Unexpected unit {$unit}" ) ; } return ( int ) ( $ oSize * self :: getBinarySizes ( ) [ $ unit ] * $ byteMultiplier ) ; }
6148	public function setBody ( $ body ) { if ( is_string ( $ body ) ) { $ this -> body = $ body ; } elseif ( is_array ( $ body ) ) { $ this -> setJsonBody ( $ body ) ; } elseif ( is_callable ( $ body ) ) { ob_start ( ) ; $ res1 = call_user_func ( $ body ) ; $ res2 = ob_get_contents ( ) ; $ this -> body = $ res2 . $ res1 ; ob_end_clean ( ) ; } return $ this ; }
8230	public static function writeFile ( $ fileName , $ data , $ options = [ ] ) { $ writer = new File \ FileWriter ( $ fileName , $ options ) ; $ isSuccess = true ; $ written = 0 ; try { $ writer -> open ( ) ; $ written = $ writer -> write ( $ data ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ isSuccess = false ; } try { $ writer -> close ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ isSuccess = false ; } return $ isSuccess ; }
11177	public function create ( ? string $ name = null ) { Whois :: print ( $ this -> getNotify ( ) ) ; $ this -> creator -> create ( $ this -> filesystem , $ name ) ; }
8161	public function block ( ) { $ this -> status = User :: STATUS_BLOCKED ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
11561	public function SetUnits ( $ units ) { if ( is_array ( $ units ) ) { $ this -> units = $ units ; } else { $ this -> units = explode ( ',' , ( string ) $ units ) ; } return $ this ; }
8635	public function setShipmentFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2538	protected function initSoapClient ( $ wsdlId ) { $ wsdlPath = WsdlAnalyser :: $ wsdlIds [ $ wsdlId ] ; $ client = new Client \ SoapClient ( $ wsdlPath , $ this -> makeSoapClientOptions ( ) , $ this -> params -> logger ) ; return $ client ; }
12499	public static function insertMany ( $ document , $ connection ) { if ( gettype ( $ document ) != "array" && gettype ( $ document ) != "object" ) { throw new ClusterpointException ( "\"->insert()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid document format." , 9002 ) ; } if ( gettype ( $ document ) == "object" ) { $ document_array = array ( ) ; foreach ( $ document as $ value ) { $ document_array [ ] = $ value ; } $ document = $ document_array ; } $ connection -> query = json_encode ( array_values ( $ document ) ) ; $ connection -> multiple = true ; return self :: insert ( $ connection ) ; }
5435	public function getSignature ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; $ method = $ interface -> getMethod ( $ name ) ; $ abstract = ( $ method -> isAbstract ( ) && ! $ interface -> isInterface ( ) && ! $ this -> isAbstractMethodInParents ( $ name ) ) ? 'abstract ' : '' ; if ( $ method -> isPublic ( ) ) { $ visibility = 'public' ; } elseif ( $ method -> isProtected ( ) ) { $ visibility = 'protected' ; } else { $ visibility = 'private' ; } $ static = $ method -> isStatic ( ) ? 'static ' : '' ; $ reference = $ method -> returnsReference ( ) ? '&' : '' ; $ params = $ this -> getParameterSignatures ( $ method ) ; $ returnType = $ this -> getReturnType ( $ method ) ; return "{$abstract}$visibility {$static}function $reference$name($params){$returnType}" ; }
3372	private function getFormFactory ( ContainerInterface $ services ) { $ elements = null ; if ( $ services -> has ( 'FormElementManager' ) ) { $ elements = $ services -> get ( 'FormElementManager' ) ; } return new Factory ( $ elements ) ; }
11321	function getRow ( $ sql , $ params = array ( ) ) { $ data = $ this -> query ( $ sql , $ params ) ; $ row = false ; if ( count ( $ data ) > 0 ) { $ row = $ data [ 0 ] ; } return $ row ; }
1360	public static function custom ( $ mediaType ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , null ) ; }
8586	public function setCompetitivePrice ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'CompetitivePrice' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11000	public function selectLocaleFromAcceptHeader ( Accept $ header ) { $ my_locales = [ ] ; foreach ( $ this -> locales as $ supported_locale ) { $ list = $ supported_locale -> getFallbackList ( ) ; foreach ( $ list as $ locale ) $ my_locales [ $ locale -> getLocale ( ) ] = $ supported_locale -> getLocale ( ) ; } $ best = $ header -> getBestResponseType ( array_keys ( $ my_locales ) ) ; return empty ( $ best ) ? null : ( $ my_locales [ $ best ] ?? null ) ; }
8936	public function createChangeset ( $ changesets = array ( ) ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , 'oauth_token_secret' => $ token [ 'secret' ] , ) ; $ base = 'changeset/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap">' ; if ( ! empty ( $ changesets ) ) { foreach ( $ changesets as $ tags ) { $ xml .= '<changeset>' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ xml .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml .= '</changeset>' ; } } $ xml .= '</osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
4155	protected function buildRequestHeader ( ) { $ bearerToken = $ this -> bearerToken ; if ( $ this -> bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } return array ( 'Authorization: Bearer ' . rawurlencode ( $ bearerToken ) , 'Expect:' ) ; }
11482	public function saveAllPages ( BlockManagerApprover $ approver , array $ languages , $ saveCommonSlots = true ) { $ this -> contributorDefined ( ) ; $ finder = new Finder ( ) ; $ pages = $ finder -> directories ( ) -> depth ( 0 ) -> in ( $ this -> pagesDir ) ; foreach ( $ pages as $ page ) { $ page = ( string ) $ page ; $ pageName = basename ( $ page ) ; foreach ( $ languages as $ language ) { $ tokens = explode ( "_" , $ language ) ; $ options = array ( 'page' => $ pageName , 'language' => $ tokens [ 0 ] , 'country' => $ tokens [ 1 ] , ) ; $ this -> save ( $ approver , $ options , $ saveCommonSlots ) ; } $ saveCommonSlots = false ; } Dispatcher :: dispatch ( PageCollectionEvents :: SITE_SAVED , new SiteSavedEvent ( ) ) ; DataLogger :: log ( 'The whole website\'s pages were successfully saved in production' ) ; }
7758	protected function loadMappingInformation ( array $ config , ContainerBuilder $ container ) { $ this -> drivers = array ( ) ; if ( $ config [ 'auto_mapping' ] ) { foreach ( array_keys ( $ container -> getParameter ( 'kernel.bundles' ) ) as $ bundle ) { if ( ! isset ( $ config [ 'mappings' ] [ $ bundle ] ) ) { $ config [ 'mappings' ] [ $ bundle ] = array ( 'mapping' => true , 'is_bundle' => true , ) ; } } } $ container -> setAlias ( 'hydra.naming_strategy' , new Alias ( $ config [ 'naming_strategy' ] , false ) ) ; foreach ( $ config [ 'mappings' ] as $ mappingName => $ mappingConfig ) { if ( null !== $ mappingConfig && false === $ mappingConfig [ 'mapping' ] ) { continue ; } $ mappingConfig = array_replace ( array ( 'dir' => false , 'type' => false , 'prefix' => false , ) , ( array ) $ mappingConfig ) ; $ mappingConfig [ 'dir' ] = $ container -> getParameterBag ( ) -> resolveValue ( $ mappingConfig [ 'dir' ] ) ; if ( ! isset ( $ mappingConfig [ 'is_bundle' ] ) ) { $ mappingConfig [ 'is_bundle' ] = ! is_dir ( $ mappingConfig [ 'dir' ] ) ; } if ( $ mappingConfig [ 'is_bundle' ] ) { $ bundle = null ; foreach ( $ container -> getParameter ( 'kernel.bundles' ) as $ name => $ class ) { if ( $ mappingName === $ name ) { $ bundle = new \ ReflectionClass ( $ class ) ; break ; } } if ( null === $ bundle ) { throw new \ InvalidArgumentException ( sprintf ( 'Bundle "%s" does not exist or it is not enabled.' , $ mappingName ) ) ; } $ mappingConfig = $ this -> getMappingDriverBundleConfigDefaults ( $ mappingConfig , $ bundle , $ container ) ; if ( ! $ mappingConfig ) { continue ; } } $ this -> validateMappingConfiguration ( $ mappingConfig , $ mappingName ) ; $ this -> setMappingDriverConfig ( $ mappingConfig , $ mappingName ) ; } $ this -> registerMappingDrivers ( $ config , $ container ) ; }
8411	public function disconnect ( ) { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { unset ( $ this -> servers [ 'all' ] [ 'link' ] ) ; } else { unset ( $ this -> servers [ 'read' ] [ 'link' ] ) ; unset ( $ this -> servers [ 'write' ] [ 'link' ] ) ; } }
2046	private function getTempDir ( ) : string { $ container = $ this -> getContainer ( ) ; $ tmpDir = sys_get_temp_dir ( ) . '/' . md5 ( $ container -> getParameter ( 'kernel.project_dir' ) ) ; if ( ! is_dir ( $ tmpDir ) ) { $ container -> get ( 'filesystem' ) -> mkdir ( $ tmpDir ) ; } return $ tmpDir ; }
6405	public function consume ( $ remaining_taf ) { $ chunk_regexp = $ this -> getRegexp ( ) ; if ( preg_match ( $ chunk_regexp , $ remaining_taf , $ matches ) ) { $ found = $ matches ; } else { $ found = null ; } $ new_remaining_taf = preg_replace ( $ chunk_regexp , '' , $ remaining_taf , 1 ) ; return array ( 'found' => $ found , 'remaining' => $ new_remaining_taf , ) ; }
2082	public function generateXmlFiles ( ) { $ this -> generateSitemap ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( ) ; } } $ this -> purgePageCache ( ) ; $ this -> log ( 'Regenerated the XML files' , __METHOD__ , TL_CRON ) ; }
6099	protected function put ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_PUT , null , $ fireAndForget ) ; }
8888	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ requestHandler ) : ResponseInterface { $ this -> container -> set ( ServerRequestInterface :: class , $ request ) ; $ result = $ this -> dispatch ( $ this -> route ( $ request ) ) ; if ( $ result instanceof ResponseInterface ) { return $ result ; } return $ response = ( new Response ( ) ) -> withProtocolVersion ( '1.1' ) -> withBody ( \ GuzzleHttp \ Psr7 \ stream_for ( $ result ) ) ; }
9176	public function getPlugins ( ) { foreach ( $ this -> getOperations ( ) as $ operation ) { if ( $ this -> getOperation ( ) -> equals ( $ operation ) ) { return $ operation -> getPlugins ( ) ; } } throw new \ Exception ( sprintf ( 'Can\'t find any plugins for operation %s' , $ this -> getOperation ( ) ) ) ; }
9923	public function requireParam ( $ key ) { $ param = $ this -> fetch ( $ key , function ( $ key ) { throw new ParameterMissingException ( "Missing param '$key'" ) ; } ) ; if ( $ this -> valueIsEmpty ( $ param ) ) { throw new ParameterMissingException ( "Missing param '$key'" ) ; } return $ param ; }
6536	protected function retrieve ( ) { if ( false === $ this -> retrieved ) { $ this -> updatedDatas = $ this -> getArray ( ) ; $ this -> retrieved = true ; } }
9731	public function canRead ( $ pFilename ) { try { $ this -> openFile ( $ pFilename ) ; } catch ( Exception $ e ) { return false ; } $ data = fread ( $ this -> fileHandle , 2048 ) ; $ delimiterCount = substr_count ( $ data , ';' ) ; $ hasDelimiter = $ delimiterCount > 0 ; $ lines = explode ( "\n" , $ data ) ; $ hasId = substr ( $ lines [ 0 ] , 0 , 4 ) === 'ID;P' ; fclose ( $ this -> fileHandle ) ; return $ hasDelimiter && $ hasId ; }
12222	private function prepareErrorBody ( Exception $ exception ) { $ body = [ 'errors' => [ ] ] ; if ( ! empty ( $ statusCode = $ exception -> getStatusCode ( ) ) ) { $ body [ 'errors' ] [ 'statusCode' ] = $ statusCode ; } if ( ! empty ( $ description = $ exception -> getDescription ( ) ) ) { $ body [ 'errors' ] [ 'description' ] = $ description ; } if ( ! empty ( $ message = $ exception -> getMessage ( ) ) ) { $ body [ 'errors' ] [ 'message' ] = $ message ; } if ( ! empty ( $ code = $ exception -> getCode ( ) ) ) { $ body [ 'errors' ] [ 'code' ] = $ code ; } if ( ! empty ( $ link = $ exception -> getLink ( ) ) ) { $ body [ 'errors' ] [ 'link' ] = $ link ; } return $ body ; }
5628	public function makeAbsolute ( $ base ) { if ( ! is_object ( $ base ) ) { $ base = new self ( $ base ) ; } if ( $ this -> getHost ( ) ) { $ scheme = $ this -> getScheme ( ) ; $ host = $ this -> getHost ( ) ; $ port = $ this -> getPort ( ) ? ':' . $ this -> getPort ( ) : '' ; $ identity = $ this -> getIdentity ( ) ? $ this -> getIdentity ( ) . '@' : '' ; if ( ! $ identity ) { $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } } else { $ scheme = $ base -> getScheme ( ) ; $ host = $ base -> getHost ( ) ; $ port = $ base -> getPort ( ) ? ':' . $ base -> getPort ( ) : '' ; $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } $ path = $ this -> normalisePath ( $ this -> extractAbsolutePath ( $ base ) ) ; $ encoded = $ this -> getEncodedRequest ( ) ; $ fragment = $ this -> getFragment ( ) ? '#' . $ this -> getFragment ( ) : '' ; $ coords = $ this -> getX ( ) === false ? '' : '?' . $ this -> getX ( ) . ',' . $ this -> getY ( ) ; return new self ( "$scheme://$identity$host$port$path$encoded$fragment$coords" ) ; }
8541	public function compile ( ) { if ( ! count ( $ this -> msgid ) ) return "" ; $ str = "" ; if ( $ this -> comments ) $ str .= implode ( self :: NEWLINE , $ this -> comments ) . self :: NEWLINE ; if ( $ this -> msgctxt ) $ str .= 'msgctxt "' . $ this -> msgctxt . '"' . self :: NEWLINE ; $ included_blocks = [ 'msgid' ] ; if ( $ this -> msgstr_plural ) $ included_blocks [ ] = 'msgid_plural' ; else $ included_blocks [ ] = 'msgstr' ; foreach ( $ included_blocks as $ key ) { if ( is_array ( $ this -> $ key ) ) { $ str .= "$key " ; $ str .= implode ( self :: NEWLINE , array_map ( [ $ this , 'quoteWrap' ] , $ this -> $ key ) ) . self :: NEWLINE ; } } if ( $ this -> msgid_plural && $ this -> msgstr_plural ) { foreach ( $ this -> msgstr_plural as $ plural_key => $ plural_message ) { $ str .= 'msgstr[' . $ plural_key . '] ' ; $ str .= implode ( self :: NEWLINE , array_map ( [ $ this , 'quoteWrap' ] , $ plural_message ) ) . self :: NEWLINE ; } } return trim ( $ str ) ; }
9876	public function writeWorkbook ( Spreadsheet $ spreadsheet , $ recalcRequired = false ) { if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'workbook' ) ; $ objWriter -> writeAttribute ( 'xml:space' , 'preserve' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ this -> writeFileVersion ( $ objWriter ) ; $ this -> writeWorkbookPr ( $ objWriter ) ; $ this -> writeWorkbookProtection ( $ objWriter , $ spreadsheet ) ; if ( $ this -> getParentWriter ( ) -> getOffice2003Compatibility ( ) === false ) { $ this -> writeBookViews ( $ objWriter , $ spreadsheet ) ; } $ this -> writeSheets ( $ objWriter , $ spreadsheet ) ; $ this -> writeDefinedNames ( $ objWriter , $ spreadsheet ) ; $ this -> writeCalcPr ( $ objWriter , $ recalcRequired ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
1723	protected function getPreviewImage ( File $ objFile , $ strInfo , $ strClass = 'gimage' ) { if ( ( $ objFile -> isSvgImage || ( $ objFile -> height <= Config :: get ( 'gdMaxImgHeight' ) && $ objFile -> width <= Config :: get ( 'gdMaxImgWidth' ) ) ) && $ objFile -> viewWidth && $ objFile -> viewHeight ) { if ( $ objFile -> height !== null && $ objFile -> height <= 75 && $ objFile -> width !== null && $ objFile -> width <= 100 ) { $ image = $ objFile -> dataUri ; } else { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ image = System :: getContainer ( ) -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ objFile -> path , array ( 100 , 75 , ResizeConfiguration :: MODE_BOX ) ) -> getUrl ( $ rootDir ) ; } } else { $ image = Image :: getPath ( 'placeholder.svg' ) ; } if ( strncmp ( $ image , 'data:' , 5 ) === 0 ) { return '<img src="' . $ objFile -> dataUri . '" width="' . $ objFile -> width . '" height="' . $ objFile -> height . '" alt="" class="' . $ strClass . '" title="' . StringUtil :: specialchars ( $ strInfo ) . '">' ; } return Image :: getHtml ( $ image , '' , 'class="' . $ strClass . '" title="' . StringUtil :: specialchars ( $ strInfo ) . '"' ) ; }
8519	public function setPricingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PricingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1241	private static function encodeValueXml ( $ value ) { if ( $ value instanceof \ DateTime ) { return $ value -> format ( 'Y-m-d\TH:i:s.000\Z' ) ; } elseif ( is_bool ( $ value ) ) { return $ value ? 'true' : 'false' ; } else { return htmlspecialchars ( $ value , ENT_QUOTES , 'UTF-8' , true ) ; } }
6550	public function current ( ) { if ( $ this -> iterator -> valid ( ) === false ) { return null ; } $ iterator = $ this -> iterator -> current ( ) -> getCellIterator ( ) ; $ iterator -> setIterateOnlyExistingCells ( false ) ; $ result = [ ] ; foreach ( $ iterator as $ cell ) { $ result [ ] = $ cell -> getValue ( ) ; } return $ result ; }
11190	public function getData ( ) { $ reference = new FluidXml ( false ) ; $ reference -> add ( $ this -> getTransactionReference ( ) ) ; return [ 'password' => $ this -> getPassword ( ) , 'userId' => $ this -> getUserId ( ) , 'merchantId' => $ this -> getMerchantId ( ) , 'transactionReference' => $ reference ] ; }
3276	public function flush ( ) { $ this -> getDatabase ( ) -> flushFile ( ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> flush ( ) ; } }
12110	public function deletePage ( $ id ) { $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
4633	protected function getHeader ( $ key ) { return isset ( $ this -> headers [ $ key ] ) ? $ this -> headers [ $ key ] : NULL ; }
1302	public function getDefaultLocale ( ) : Locale { foreach ( $ this -> locales as $ locale ) { if ( $ locale -> isDefault ( ) ) { return $ locale ; } } throw new \ RuntimeException ( 'No locale marked as default exists in this environment.' ) ; }
3979	private function createCommand ( CommandCollectionInterface $ collection , $ operationName , $ queryParameters , $ icon , $ extraValues = [ ] ) { $ command = $ this -> getCommandInstance ( $ collection , $ operationName ) ; $ parameters = $ command -> getParameters ( ) ; foreach ( $ queryParameters as $ name => $ value ) { if ( ! isset ( $ parameters [ $ name ] ) ) { $ parameters [ $ name ] = $ value ; } } if ( ! $ command -> getLabel ( ) ) { $ command -> setLabel ( $ operationName . '.0' ) ; if ( isset ( $ extraValues [ 'label' ] ) ) { $ command -> setLabel ( $ extraValues [ 'label' ] ) ; } } if ( ! $ command -> getDescription ( ) ) { $ command -> setDescription ( $ operationName . '.1' ) ; if ( isset ( $ extraValues [ 'description' ] ) ) { $ command -> setDescription ( $ extraValues [ 'description' ] ) ; } } $ extra = $ command -> getExtra ( ) ; $ extra [ 'icon' ] = $ icon ; foreach ( $ extraValues as $ name => $ value ) { if ( ! isset ( $ extra [ $ name ] ) ) { $ extra [ $ name ] = $ value ; } } }
1137	public function setDepthWithSubtree ( ) { $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ self -> descendantsAndSelf ( ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ oldDepth = ! is_null ( $ self -> getDepth ( ) ) ? $ self -> getDepth ( ) : 0 ; $ newDepth = $ self -> getLevel ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ self -> getKeyName ( ) , '=' , $ self -> getKey ( ) ) -> update ( array ( $ self -> getDepthColumnName ( ) => $ newDepth ) ) ; $ self -> setAttribute ( $ self -> getDepthColumnName ( ) , $ newDepth ) ; $ diff = $ newDepth - $ oldDepth ; if ( ! $ self -> isLeaf ( ) && $ diff != 0 ) $ self -> descendants ( ) -> increment ( $ self -> getDepthColumnName ( ) , $ diff ) ; } ) ; return $ this ; }
2956	public function deviceClose ( ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { return true ; } if ( fclose ( $ this -> _dHandle ) ) { $ this -> _dHandle = null ; $ this -> _dState = SERIAL_DEVICE_SET ; return true ; } trigger_error ( "Unable to close the device" , E_USER_ERROR ) ; return false ; }
2755	public function onImport ( ImportEvent $ event ) { $ uuids = [ '0bd5c257-2231-450f-b4c2-ab156af7b78d' , '36b2e2b2-3df0-43eb-a282-d792b0999c07' , '94ad928b-3ec8-4bcb-b617-ab1607bf69cb' , 'bbb1ee17-15f8-46bd-9df5-21c58040d741' , ] ; foreach ( $ event -> getImportedEntities ( ) as $ entity ) { if ( in_array ( $ entity -> uuid ( ) , $ uuids ) ) { $ entity -> moderation_state -> value = 'published' ; $ entity -> save ( ) ; } } }
5620	protected function chompCoordinates ( & $ url ) { if ( preg_match ( '/(.*)\?(\d+),(\d+)$/' , $ url , $ matches ) ) { $ url = $ matches [ 1 ] ; return array ( ( integer ) $ matches [ 2 ] , ( integer ) $ matches [ 3 ] ) ; } return array ( false , false ) ; }
7151	public function equals ( SubjectIdentity $ identity ) { return $ this -> provider === $ identity -> getProvider ( ) && $ this -> identifier === $ identity -> getIdentifier ( ) ; }
5331	public function getEmojiCodeList ( ) { return [ 0x203c , 0x2049 , 0x2122 , 0x2139 , range ( 0x2194 , 0x2199 ) , range ( 0x21a9 , 0x21aa ) , range ( 0x231a , 0x231b ) , 0x2328 , range ( 0x23ce , 0x23cf ) , range ( 0x23e9 , 0x23f3 ) , range ( 0x23f8 , 0x23fa ) , 0x24c2 , range ( 0x25aa , 0x25ab ) , 0x25b6 , 0x25c0 , range ( 0x25fb , 0x25fe ) , range ( 0x2600 , 0x2604 ) , 0x260e , 0x2611 , range ( 0x2614 , 0x2615 ) , 0x2618 , 0x261d , 0x2620 , range ( 0x2622 , 0x2623 ) , 0x2626 , 0x262a , range ( 0x262e , 0x262f ) , range ( 0x2638 , 0x263a ) , 0x2640 , 0x2642 , range ( 0x2648 , 0x2653 ) , 0x2660 , 0x2663 , range ( 0x2665 , 0x2666 ) , 0x2668 , 0x267b , 0x267f , range ( 0x2692 , 0x2697 ) , 0x2699 , range ( 0x269b , 0x269c ) , range ( 0x26a0 , 0x26a1 ) , range ( 0x26aa , 0x26ab ) , range ( 0x26b0 , 0x26b1 ) , range ( 0x26bd , 0x26be ) , range ( 0x26c4 , 0x26c5 ) , 0x26c8 , range ( 0x26ce , 0x26cf ) , 0x26d1 , range ( 0x26d3 , 0x26d4 ) , range ( 0x26e9 , 0x26ea ) , range ( 0x26f0 , 0x26f5 ) , range ( 0x26f7 , 0x26fa ) , 0x26fd , 0x2702 , 0x2705 , range ( 0x2708 , 0x270d ) , 0x270f , 0x2712 , 0x2714 , 0x2716 , 0x271d , 0x2721 , 0x2728 , range ( 0x2733 , 0x2734 ) , 0x2744 , 0x2747 , 0x274c , 0x274e , range ( 0x2753 , 0x2755 ) , 0x2757 , range ( 0x2763 , 0x2764 ) , range ( 0x2795 , 0x2797 ) , 0x27a1 , 0x27b0 , 0x27bf , range ( 0x2934 , 0x2935 ) , range ( 0x2b05 , 0x2b07 ) , range ( 0x2b1b , 0x2b1c ) , 0x2b50 , 0x2b55 , 0x3030 , 0x303d , 0x3297 , 0x3299 , 0x200d , 0x20e3 , 0xfe0f , range ( 0x1f000 , 0x1f9cf ) ] ; }
77	protected function configure ( ) { $ this -> setDefinition ( array ( new InputArgument ( self :: ARGUMENT_PACKAGE , InputArgument :: REQUIRED , 'Package to inspect' ) , new InputArgument ( self :: ARGUMENT_CONSTRAINT , InputArgument :: OPTIONAL , 'Optional version constraint' , '*' ) , new InputOption ( self :: OPTION_RECURSIVE , 'r' , InputOption :: VALUE_NONE , 'Recursively resolves up to the root package' ) , new InputOption ( self :: OPTION_TREE , 't' , InputOption :: VALUE_NONE , 'Prints the results as a nested tree' ) , ) ) ; }
4287	public function getSubscriptions ( ) { if ( ! $ this -> isConnected ( ) ) { $ this -> debug -> alert ( 'WAMP publisher not connected to WAMP router' ) ; return array ( ) ; } $ this -> publishMeta ( ) ; $ this -> processExistingData ( ) ; return array ( 'debug.log' => array ( 'onLog' , PHP_INT_MAX * - 1 ) , 'errorHandler.error' => 'onError' , 'php.shutdown' => array ( 'onShutdown' , PHP_INT_MAX * - 1 ) , ) ; }
7173	protected function resolveCustomerTargetCountry ( CustomerInterface $ customer ) : ? CountryInterface { if ( null !== $ address = $ customer -> getDefaultDeliveryAddress ( ) ) { return $ address -> getCountry ( ) ; } return null ; }
12247	public function getNodeByName ( $ strXpath , $ strName ) { $ varResult = $ this -> xpath ( $ strXpath . "[@name='" . $ strName . "']" ) ; if ( $ varResult !== false ) { return reset ( $ varResult ) ; } else { return false ; } }
12073	public function getForcedQualificationCustomers ( ) { if ( is_null ( $ this -> cacheForcedRanks ) ) { $ custIds = $ this -> getForcedCustomersIds ( ) ; $ ranks = $ this -> getCfgParamsByRanks ( ) ; $ this -> cacheForcedRanks = [ ] ; foreach ( $ custIds as $ item ) { $ custId = $ item [ Customer :: A_CUSTOMER_REF ] ; $ ref = $ item [ Customer :: A_MLM_ID ] ; $ rankCode = $ this -> QUALIFIED_CUSTOMERS [ $ ref ] [ 1 ] ; $ cfgParamsWithSchemes = $ ranks [ $ rankCode ] ; $ this -> cacheForcedRanks [ $ custId ] = $ cfgParamsWithSchemes ; } $ this -> cacheForcedCustomerIds = array_keys ( $ this -> cacheForcedRanks ) ; } return $ this -> cacheForcedRanks ; }
6361	public function toDateInterval ( float $ duration ) : DateInterval { Preconditions :: checkState ( $ this -> dateIntervalFormat !== null , '[%s] does not support toDateInterval()' , $ this ) ; return new DateInterval ( sprintf ( $ this -> dateIntervalFormat , $ duration ) ) ; }
7786	public function createStatement ( AccountInterface $ account , $ number ) { return $ this -> createObject ( $ this -> statementClass , 'Jejik\MT940\StatementInterface' , array ( $ account , $ number ) ) ; }
4907	public function onRoute ( MvcEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ ajax = $ request -> getQuery ( ) -> get ( 'ajax' ) ; if ( ! $ request -> isXmlHttpRequest ( ) || ! $ ajax ) { return ; } $ response = $ event -> getResponse ( ) ; $ ajaxEvent = $ this -> ajaxEventManager -> getEvent ( $ ajax , $ this ) ; $ ajaxEvent -> setRequest ( $ request ) ; $ ajaxEvent -> setResponse ( $ response ) ; $ results = $ this -> ajaxEventManager -> triggerEventUntil ( function ( $ r ) { return null !== $ r ; } , $ ajaxEvent ) ; $ result = $ results -> last ( ) ? : $ ajaxEvent -> getResult ( ) ; if ( ! $ result ) { throw new \ UnexpectedValueException ( 'No listener returned anything. Do not know what to do...' ) ; } if ( is_array ( $ result ) || $ result instanceof \ Traversable ) { $ result = Json :: encode ( $ result , true , [ 'enableJsonExprFinder' => true ] ) ; } $ contentType = $ ajaxEvent -> getContentType ( ) ; $ response -> getHeaders ( ) -> addHeaderLine ( 'Content-Type' , $ contentType ) ; $ response -> setContent ( $ result ) ; return $ response ; }
808	private function sortAlphabetically ( array $ first , array $ second ) { $ firstNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ first [ 'namespace' ] ) ) ; $ secondNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ second [ 'namespace' ] ) ) ; return strcasecmp ( $ firstNamespace , $ secondNamespace ) ; }
10934	protected function is_php ( $ version ) { static $ _is_php ; $ version = ( string ) $ version ; if ( ! isset ( $ _is_php [ $ version ] ) ) { $ _is_php [ $ version ] = version_compare ( PHP_VERSION , $ version , '>=' ) ; } return $ _is_php [ $ version ] ; }
10538	public static function allowFrom ( string $ allowFromUrl ) : self { $ middleware = new self ( sprintf ( self :: VALUE_ALLOW_FROM , $ allowFromUrl ) ) ; if ( ! filter_var ( $ allowFromUrl , FILTER_VALIDATE_URL ) ) { throw new MiddlewareException ( $ middleware , sprintf ( "'%s' is not a valid URL" , $ allowFromUrl ) ) ; } return $ middleware ; }
10468	public static function getConversionFactor ( Uom $ from , Uom $ to ) { if ( $ from -> isSameValueAs ( $ to ) ) { return new Fraction ( 1 ) ; } if ( ! isset ( static :: $ conversions ) ) { static :: $ conversions = json_decode ( utf8_encode ( file_get_contents ( __DIR__ . '/conversions.json' ) ) , true ) ; } if ( isset ( static :: $ conversions [ $ from -> getName ( ) ] [ $ to -> getName ( ) ] ) ) { $ numeratorDenominatorPair = static :: $ conversions [ $ from -> getName ( ) ] [ $ to -> getName ( ) ] ; } elseif ( isset ( static :: $ conversions [ $ to -> getName ( ) ] [ $ from -> getName ( ) ] ) ) { $ numeratorDenominatorPair = array_reverse ( static :: $ conversions [ $ to -> getName ( ) ] [ $ from -> getName ( ) ] ) ; } else { throw new ConversionNotSetException ( $ from -> getName ( ) , $ to -> getName ( ) ) ; } if ( count ( $ numeratorDenominatorPair ) == 2 ) { return new Fraction ( $ numeratorDenominatorPair [ 0 ] , $ numeratorDenominatorPair [ 1 ] ) ; } else { throw new BadConversionException ( ) ; } }
6076	public function uploadPreview ( $ fileData , $ id ) { $ parameters = [ 'query' => [ ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => 'preview-file' , ] , ] , 'headers' => null , ] ; $ this -> post ( 'v1/media.json/' . $ id . '/uploadpreview' , $ parameters ) ; }
4435	public static function fromErrorMessage ( string $ error ) : QlessException { $ area = null ; $ message = $ error ; if ( preg_match ( self :: ERROR_MESSAGE_RE , $ error , $ matches ) > 0 ) { $ area = $ matches [ 'area' ] ; $ message = $ matches [ 'message' ] ; } switch ( true ) { case ( $ area === 'Requeue' && stripos ( $ message , 'does not exist' ) !== false ) : case ( stripos ( $ message , 'Job does not exist' ) !== false ) : return new InvalidJobException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job given out to another worker' ) !== false ) : return new JobLostException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job not currently running' ) !== false ) : default : return new QlessException ( $ message , $ area ) ; } }
3432	protected function normalizeSelect ( ) { if ( $ this -> fieldsMustBeSelected ( ) ) { $ this -> select = array_merge ( $ this -> standardFields , $ this -> select ) ; } if ( $ this -> propsMustBeSelected ( ) ) { $ this -> select [ ] = 'IBLOCK_ID' ; $ this -> select [ ] = 'UF_*' ; } $ this -> select [ ] = 'ID' ; return $ this -> clearSelectArray ( ) ; }
8872	private function buildAttachmentPart ( ) { if ( count ( $ this -> attachments ) > 0 ) { $ attachment_part = '' ; foreach ( $ this -> attachments as $ attachment ) { $ file_str = chunk_split ( base64_encode ( file_get_contents ( $ attachment ) ) ) ; $ attachment_part .= "--MIME_BOUNDRY\nContent-Type: " . $ this -> getMimeType ( $ attachment ) . "; name=" . basename ( $ attachment ) . "\nContent-disposition: attachment\nContent-Transfer-Encoding: base64\n\n{$file_str}\n\n" ; } return $ attachment_part ; } }
3923	protected function getConnection ( ) { if ( null === $ this -> connection ) { @ trigger_error ( 'Connection is missing in class ' . static :: class . '. The automatic fallback will be dropped in MetaModels 3.0. Please use dependency injection' , E_USER_DEPRECATED ) ; return $ this -> connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; } return $ this -> connection ; }
10651	public function validateCreate ( ) { $ validator = $ this -> getValidator ( 'create' ) ; if ( $ validator -> fails ( ) ) { $ this -> errors = $ validator -> messages ( ) ; return false ; } return true ; }
11701	public function get ( $ component ) { $ parts = explode ( '.' , $ component ) ; if ( count ( $ parts ) == 1 ) { return $ this -> getService ( $ parts [ 0 ] ) ; } elseif ( count ( $ parts ) == 2 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) ; } elseif ( count ( $ parts ) == 3 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) -> getAction ( $ parts [ 2 ] ) ; } throw new \ LogicException ( 'Malformed component path. Please use a dot-notated path (e.g. service.group.action)' ) ; }
9025	public function hasUrl ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( preg_match ( "/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&@#\/%?=~_|!:,.;]*[-a-z0-9+&@#\/%=~_|]/i" , $ word ) ) { $ result = true ; } } return $ result ; }
9582	public function getFieldValidationOptions ( ) { $ min = ( $ this -> getSetting ( 'MinValue' ) ) ? $ this -> getSetting ( 'MinValue' ) : '' ; $ max = ( $ this -> getSetting ( 'MaxValue' ) ) ? $ this -> getSetting ( 'MaxValue' ) : '' ; return [ new NumericField ( $ this -> getSettingName ( 'MinValue' ) , _t ( 'Moo_EditableField.MINVALUE' , 'Min Value' ) , $ min ) , new NumericField ( $ this -> getSettingName ( 'MaxValue' ) , _t ( 'Moo_EditableField.MAXVALUE' , 'Max Value' ) , $ max ) , ] ; }
7164	private function buildSaleDiscountsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) ) { return ; } foreach ( $ sale -> getAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ adjustment ) { $ this -> view -> addDiscount ( $ this -> buildDiscountLine ( $ adjustment ) ) ; } }
12334	private function _checkPasswordIsGood ( ) : bool { $ sLogin = self :: $ _sLogin ; $ sPassword = Config :: get ( 'security' ) -> users -> $ sLogin -> password ; if ( $ sPassword == self :: $ _sPassword ) { return true ; } else if ( $ sPassword == md5 ( self :: $ _sPassword ) ) { return true ; } else { return false ; } }
9027	public function isQuestion ( $ string ) { $ probability = 0 ; if ( strpos ( $ string , '?' ) ) { $ probability += 1 ; } $ words = $ this -> getWords ( $ string ) ; foreach ( $ this -> inquiryWords as $ queryWord ) { if ( ! strncmp ( strtolower ( $ string ) , $ queryWord , strlen ( $ queryWord ) ) ) { $ probability += 1 ; } elseif ( stristr ( strtolower ( $ string ) , $ queryWord ) ) { $ probability += 0.5 ; } } if ( $ probability >= 2 ) { return true ; } return false ; }
5148	protected function getMostRecentUnreadEmail ( ) { if ( empty ( $ this -> unreadInbox ) ) { $ this -> fail ( 'Unread Inbox is Empty' ) ; } $ email = array_shift ( $ this -> unreadInbox ) ; $ content = $ this -> getFullEmail ( $ email -> id ) ; $ content -> Headers = $ this -> getHeaders ( $ email -> id ) -> headers ; return $ content ; }
1733	protected function getBookPages ( $ intParentId , $ groups , $ time ) { $ objPages = PageModel :: findPublishedSubpagesWithoutGuestsByPid ( $ intParentId , $ this -> showHidden ) ; if ( $ objPages === null ) { return ; } foreach ( $ objPages as $ objPage ) { $ _groups = StringUtil :: deserialize ( $ objPage -> groups ) ; if ( ! $ objPage -> protected || $ this -> showProtected || ( \ is_array ( $ groups ) && \ is_array ( $ _groups ) && \ count ( array_intersect ( $ groups , $ _groups ) ) ) ) { $ this -> arrPages [ $ objPage -> id ] = $ objPage ; if ( $ objPage -> subpages > 0 ) { $ this -> getBookPages ( $ objPage -> id , $ groups , $ time ) ; } } } }
2206	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'logout' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> redirectBack ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ this -> getReferer ( ) ; } $ strLogoutUrl = System :: getContainer ( ) -> get ( 'security.logout_url_generator' ) -> getLogoutUrl ( ) ; $ strRedirect = Environment :: get ( 'base' ) ; if ( $ this -> redirectBack && ! empty ( $ _SESSION [ 'LAST_PAGE_VISITED' ] ) ) { $ strRedirect = $ _SESSION [ 'LAST_PAGE_VISITED' ] ; } elseif ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ strRedirect = $ objTarget -> getAbsoluteUrl ( ) ; } $ uri = Http :: createFromString ( $ strLogoutUrl ) ; $ query = new Query ( $ uri -> getQuery ( ) ) ; $ query = $ query -> merge ( 'redirect=' . $ strRedirect ) ; $ this -> redirect ( ( string ) $ uri -> withQuery ( ( string ) $ query ) ) ; return '' ; }
10493	public function mul ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value * $ value ) ; }
5200	public function setOptions ( array $ options ) { $ this -> validateOptions ( $ options ) ; foreach ( $ options as $ option => $ value ) $ this -> $ option = $ value ; return $ this ; }
12534	public function pagination ( $ lastSeen , $ count ) { $ params = [ 'type' => 2 , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
7009	private function formatL ( & $ str ) { if ( strstr ( $ str , '%L' ) ) $ str = str_replace ( '%L' , strtolower ( $ this -> dayName ( true ) ) , $ str ) ; }
4925	public function getTypes ( $ region = null ) { if ( null === $ region ) { $ ret = [ ] ; foreach ( $ this -> matrix as $ types ) { $ ret = array_merge ( $ ret , $ types ) ; } return array_values ( array_unique ( $ ret ) ) ; } return $ this -> matrix [ $ region ] ; }
10583	public static function dumpResponse ( ResponseInterface $ response ) { $ statusLine = sprintf ( "HTTP/%s %d %s" , $ response -> getProtocolVersion ( ) , $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) ; header ( $ statusLine , true , $ response -> getStatusCode ( ) ) ; foreach ( $ response -> getHeaders ( ) as $ name => $ values ) { foreach ( $ values as $ value ) { header ( sprintf ( '%s: %s' , $ name , $ value ) , false ) ; } } $ body = $ response -> getBody ( ) ; while ( ! $ body -> eof ( ) ) { echo $ body -> read ( 1024 ) ; } }
3471	public function merge ( Config $ config ) : Config { $ this -> config = array_merge_recursive ( $ this -> config , $ config -> config ) ; return $ this ; }
6994	public function prePersist ( UploadableInterface $ uploadable ) { if ( ! $ this -> enabled ) { return ; } $ uploadable -> setCreatedAt ( new \ DateTime ( ) ) -> setUpdatedAt ( new \ DateTime ( ) ) ; $ this -> uploader -> prepare ( $ uploadable ) ; }
4989	public function enableForm ( $ key = null ) { if ( null === $ key ) { $ this -> activeForms = array_keys ( $ this -> forms ) ; return $ this ; } if ( ! is_array ( $ key ) ) { $ key = array ( $ key ) ; } foreach ( $ key as $ k ) { if ( false !== strpos ( $ k , '.' ) ) { list ( $ childKey , $ childForm ) = explode ( '.' , $ k , 2 ) ; $ child = $ this -> getForm ( $ childKey ) ; $ child -> enableForm ( $ childForm ) ; } else { if ( isset ( $ this -> forms [ $ k ] ) && ! in_array ( $ k , $ this -> activeForms ) ) { $ this -> activeForms [ ] = $ k ; } } } return $ this ; }
441	public function hasMethod ( $ name , $ checkBehaviors = true ) { if ( method_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> hasMethod ( $ name ) ) { return true ; } } } return false ; }
10612	public function confirmedAction ( ) { $ user = $ this -> getUser ( ) ; if ( ! is_object ( $ user ) || ! $ user instanceof UserInterface ) { throw $ this -> createAccessDeniedException ( 'This user does not have access to this section.' ) ; } return $ this -> render ( "@MikyUser/Frontend/Registration/confirmed.html.twig" , array ( 'user' => $ user , ) ) ; }
2972	protected function determineContext ( array & $ data ) { $ refs = 0 ; $ vars = array_map ( function ( $ node ) use ( & $ refs ) { if ( $ node -> byRef ) { $ refs ++ ; } if ( $ node -> var instanceof VariableNode ) { return $ node -> var -> name ; } else { return $ node -> var ; } } , $ data [ 'ast' ] -> uses ) ; $ data [ 'hasRefs' ] = ( $ refs > 0 ) ; $ values = $ data [ 'reflection' ] -> getStaticVariables ( ) ; foreach ( $ vars as $ name ) { if ( isset ( $ values [ $ name ] ) ) { $ data [ 'context' ] [ $ name ] = $ values [ $ name ] ; } } }
7947	public function lineResetDslamPort ( $ id , $ line ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ line ) throw new BadMethodCallException ( 'Missing parameter $line.' ) ; try { $ r = $ this -> post ( 'xdsl/' . $ id . '/lines/' . $ line . '/resetDslamPort' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
10325	protected function setOptions ( array $ options ) { if ( ! array_key_exists ( 'adapter' , $ options ) || ! array_key_exists ( 'table' , $ options ) || ! array_key_exists ( 'column_key' , $ options ) || ! array_key_exists ( 'column_value' , $ options ) ) { throw new Exception \ InvalidArgumentException ( 'Db adapter options must be defined "adapter", "table", "column_key" and "column_value" keys.' ) ; } if ( ! $ options [ 'adapter' ] instanceof Adapter ) { throw new Exception \ InvalidArgumentException ( 'Db adapter must be an instance of Zend\Db\Adapter\Adapter.' ) ; } $ this -> adapter = $ options [ 'adapter' ] ; $ options [ 'table' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'table' ] ) ; $ options [ 'column_key' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'column_key' ] ) ; $ options [ 'column_value' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'column_value' ] ) ; $ this -> options = $ options ; return $ this ; }
4096	public function build ( ) { $ built = array ( ) ; if ( $ this -> fieldname ) { $ built [ $ this -> fieldname ] = array ( ) ; foreach ( array ( "from" , "to" , "includeLower" , "includeUpper" , "boost" ) as $ opt ) { if ( $ this -> $ opt !== null ) $ built [ $ this -> fieldname ] [ $ opt ] = $ this -> $ opt ; } if ( count ( $ built [ $ this -> fieldname ] ) == 0 ) throw new \ ElasticSearch \ Exception ( "Empty RangeQuery cant be created" ) ; } return $ built ; }
3633	public function pools ( Request $ request ) : array { if ( $ name = $ request -> query ( 'name' ) ) { if ( ! App :: hasPool ( $ name ) ) { return [ ] ; } $ poolConfig = App :: getPool ( $ name ) -> getPoolConfig ( ) ; return $ poolConfig -> toArray ( ) ; } return PoolCollector :: getCollector ( ) ; }
2089	public static function findPublishedBySourceAndParent ( $ strSource , $ intParent , $ blnDesc = false , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.source=? AND $t.parent=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = ( $ blnDesc ? "$t.date DESC" : "$t.date" ) ; } return static :: findBy ( $ arrColumns , array ( $ strSource , ( int ) $ intParent ) , $ arrOptions ) ; }
2904	public function send ( $ email , $ name = null , array $ variables = array ( ) ) { $ zendMail = $ this -> getMail ( ) ; $ result = $ this -> parentSend ( $ email , $ name , $ variables ) ; try { $ this -> addEmailToProfile ( $ email , $ name , $ variables , $ result , $ zendMail ) ; } catch ( Exception $ e ) { Mage :: logException ( $ e ) ; } return $ result ; }
4392	public function checkConfigBE ( array $ attributes ) { return array_merge ( parent :: checkConfigBE ( $ attributes ) , $ this -> checkConfig ( $ this -> beConfig , $ attributes ) ) ; }
6505	public function deserializeParameters ( $ type , $ data ) { $ jobType = $ this -> registry -> get ( $ type ) ; $ indices = $ jobType -> getIndicesOfSerializableParameters ( ) ; $ serializedParameters = json_decode ( $ data , 1 ) ; if ( false === $ serializedParameters ) { throw new \ RuntimeException ( sprintf ( 'Deserialization failed with error "%s"' , json_last_error_msg ( ) ) ) ; } if ( count ( $ indices ) < count ( $ serializedParameters ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The serialized data contains more parameters than defined for job "%s"' , $ type ) ) ; } $ parameters = array ( ) ; foreach ( $ serializedParameters as $ index => $ data ) { if ( null === $ data ) { $ parameters [ ] = null ; } else { $ parameters [ ] = $ this -> serializer -> deserialize ( $ data , $ jobType -> getParameterType ( $ indices [ $ index ] ) , 'json' , $ this -> getParamDeserializationContext ( $ jobType , $ indices [ $ index ] ) ) ; } } return $ parameters ; }
12238	public function innerHTML ( ) { $ dom = dom_import_simplexml ( $ this ) ; $ doc = $ dom -> ownerDocument ; $ html = '' ; foreach ( $ dom -> childNodes as $ child ) { $ html .= ( $ child instanceof DOMText ) ? $ child -> textContent : $ doc -> saveXML ( $ child ) ; } return $ html ; }
12548	public function getThemePlugin ( $ name ) { if ( ! array_key_exists ( $ name , $ this -> themes ) ) { return null ; } return $ this -> themes [ $ name ] ; }
3064	protected function storeResult ( array $ results ) { $ runnerService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerService :: SERVICE_ID ) ; $ success = true ; try { foreach ( $ results as $ result ) { if ( ! $ result instanceof AbstractResult ) { throw new \ common_Exception ( __FUNCTION__ . ' requires a CAT result to store it.' ) ; } $ variables = $ this -> convertCatVariables ( $ result -> getVariables ( ) ) ; if ( empty ( $ variables ) ) { \ common_Logger :: t ( 'No Cat result variables to store.' ) ; continue ; } if ( $ result instanceof ItemResult ) { $ itemId = $ result -> getItemRefId ( ) ; $ itemUri = $ this -> getItemUriFromRefId ( $ itemId ) ; } else { $ itemUri = $ itemId = null ; $ sectionId = $ this -> getTestSession ( ) -> getRoute ( ) -> current ( ) -> getAssessmentSection ( ) -> getIdentifier ( ) ; foreach ( $ variables as $ variable ) { $ variable -> setIdentifier ( $ sectionId . '-' . $ variable -> getIdentifier ( ) ) ; } } if ( ! $ runnerService -> storeVariables ( $ this , $ itemUri , $ variables , $ itemId ) ) { $ success = false ; } } } catch ( \ Exception $ e ) { \ common_Logger :: w ( 'An error has occurred during CAT result storing: ' . $ e -> getMessage ( ) ) ; $ success = false ; } return $ success ; }
5782	public function routeGetDelete ( Request $ request , Response $ response , $ args ) { if ( ! $ this -> authorization -> isAuthorized ( ROLES_DELETE_RESOURCE ) ) { throw new \ Exception ( 'No permission.' ) ; } $ primaryKey = $ args [ ROUTEARG_PRIMARY_KEY ] ; $ tableName = $ this -> tableMapper -> getFormalTableName ( false ) ; $ primaryKeyColumnName = $ this -> tableMapper -> getPrimaryKeyColumnName ( ) ; try { $ this -> tableMapper -> deleteByPrimaryKey ( $ primaryKey ) ; $ this -> events -> insertInfo ( EVENT_ROLE_DELETE , [ $ primaryKeyColumnName => $ primaryKey ] ) ; SlimPostgres :: setAdminNotice ( "Deleted $tableName $primaryKey" ) ; } catch ( Exceptions \ UnallowedActionException $ e ) { $ this -> events -> insertWarning ( EVENT_UNALLOWED_ACTION , [ 'error' => $ e -> getMessage ( ) ] ) ; SlimPostgres :: setAdminNotice ( $ e -> getMessage ( ) , 'failure' ) ; } catch ( Exceptions \ QueryResultsNotFoundException $ e ) { define ( 'EVENT_QUERY_NO_RESULTS' , 'Query Results Not Found' ) ; $ this -> events -> insertWarning ( EVENT_QUERY_NO_RESULTS , $ e -> getMessage ( ) ) ; SlimPostgres :: setAdminNotice ( $ e -> getMessage ( ) , 'failure' ) ; } catch ( Exceptions \ QueryFailureException $ e ) { $ this -> events -> insertError ( EVENT_QUERY_FAIL , [ 'error' => $ e -> getMessage ( ) ] ) ; SlimPostgres :: setAdminNotice ( 'Delete Failed' , 'failure' ) ; } return $ response -> withRedirect ( $ this -> router -> pathFor ( SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ) ) ; }
8581	public function setPrepInstruction ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PrepInstruction' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10578	public function multipleToAPIResponseData ( ? array $ resources ) : APIResponseData { if ( is_null ( $ resources ) ) { return $ this -> toAPIResponseData ( null ) ; } return new APIResponseData ( array_map ( function ( Resource $ resource ) { return $ this -> toAPIResponseData ( $ resource ) -> getData ( ) ; } , $ resources ) ) ; }
1080	public static function parse ( $ source , array $ options = [ ] ) { $ sourceObj = $ source instanceof Source ? $ source : new Source ( $ source ) ; $ parser = new self ( $ sourceObj , $ options ) ; return $ parser -> parseDocument ( ) ; }
5482	public function setField ( SelectorInterface $ selector , $ value , $ position = false ) { $ success = false ; $ _position = 0 ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { $ _position ++ ; if ( $ position === false or $ _position === ( int ) $ position ) { if ( $ this -> widgets [ $ i ] -> setValue ( $ value ) ) { $ success = true ; } } } } return $ success ; }
12627	public function format ( $ format = null ) { if ( null === $ format ) { $ format = $ this -> _format ; } return parent :: format ( $ format ) ; }
7234	protected function assertItemClass ( Common \ SaleItemInterface $ child ) { if ( ! $ child instanceof Model \ CartItemInterface ) { throw new InvalidArgumentException ( "Expected instance of " . Model \ CartItemInterface :: class ) ; } }
11519	protected function GenerateAndroidPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata ) { $ metadata .= $ owner -> MarkupComment ( 'Android Pinned Icon' ) ; if ( $ config -> fetchAndroidPiniconThemeColor ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'theme-color' , $ config -> fetchAndroidPiniconThemeColor ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'manifest' , '/manifest.json' ) ; }
6783	public function setHeaderParameters ( $ optionNames ) { foreach ( ( array ) $ optionNames as $ option ) { $ this -> headerParameters [ $ option ] = true ; } return $ this ; }
8257	protected function startAuthentication ( ) { $ authorizationUrl = $ this -> provider -> getAuthorizationUrl ( ) ; $ this -> session -> migrate ( true ) ; $ this -> session -> set ( "oauth2state" , $ this -> provider -> getState ( ) ) ; $ this -> picoAuth -> redirectToPage ( $ authorizationUrl , null , false ) ; }
31	public function parseHgIgnoreLine ( $ line ) { if ( preg_match ( '#^syntax\s*:\s*(glob|regexp)$#' , $ line , $ matches ) ) { if ( $ matches [ 1 ] === 'glob' ) { $ this -> patternMode = self :: HG_IGNORE_GLOB ; } else { $ this -> patternMode = self :: HG_IGNORE_REGEX ; } return null ; } if ( $ this -> patternMode == self :: HG_IGNORE_GLOB ) { return $ this -> patternFromGlob ( $ line ) ; } return $ this -> patternFromRegex ( $ line ) ; }
5026	protected function getCustomizationOptions ( ContainerInterface $ container , $ requestedName , array $ options = null ) { if ( ! static :: OPTIONS_NAME ) { throw new \ RuntimeException ( 'The class constants "OPTIONS_NAME" must be non empty.' ) ; } return $ container -> get ( static :: OPTIONS_NAME ) ; }
5800	public function delete ( int $ id , AuthenticationService $ authentication , AuthorizationService $ authorization ) : string { if ( null === $ administrator = $ this -> getObjectById ( $ id ) ) { throw new Exceptions \ QueryResultsNotFoundException ( ) ; } $ administrator -> setAuth ( $ authentication , $ authorization ) ; if ( ! $ administrator -> isDeletable ( ) ) { throw new Exceptions \ UnallowedActionException ( $ administrator -> getNotDeletableReason ( ) ) ; } $ this -> doDeleteTransaction ( $ id ) ; $ username = $ administrator -> getUsername ( ) ; unset ( $ administrator ) ; return $ username ; }
7733	public function onKernelView ( GetResponseForControllerResultEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ result = $ event -> getControllerResult ( ) ; if ( ! $ request -> attributes -> get ( '__hydra_serialize' ) ) { return ; } if ( is_array ( $ result ) || ( $ result instanceof \ ArrayAccess ) || ( $ result instanceof \ Traversable ) ) { $ result = new Collection ( $ request -> getUri ( ) , $ result ) ; } elseif ( null === $ result ) { $ event -> setResponse ( new JsonLdResponse ( '' , 200 ) ) ; return ; } elseif ( ! is_object ( $ result ) ) { throw new \ Exception ( "A Hydra controller must return either an array or an object, got a(n) " . gettype ( $ result ) ) ; } $ serialized = $ this -> serializer -> serialize ( $ result , 'jsonld' ) ; $ event -> setResponse ( new JsonLdResponse ( $ serialized ) ) ; }
6553	public function unlock ( ) { try { if ( $ this -> pid === $ this -> getSerial ( ) && is_resource ( $ this -> fh ) ) { $ this -> removeLineFromFile ( $ this -> pid , $ this -> fh ) ; flock ( $ this -> fh , LOCK_UN ) ; fclose ( $ this -> fh ) ; if ( filesize ( $ filename = $ this -> getPidFilename ( ) ) === 0 ) { unlink ( $ filename ) ; } } } catch ( FileNotFoundException $ fnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID file %s doesn\'t exist' , $ this -> getPidFilename ( ) ) ) ; } catch ( LineNotFoundException $ lnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID %s is can not be found in PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( sprintf ( 'Can\'t remove PID %s from PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) , null , $ e ) ; } }
4413	public function onException ( GetResponseForExceptionEvent $ event ) { if ( ! $ this -> isAdminSiteAccess ) { return ; } $ routeName = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( $ routeName !== FallbackRouter :: ROUTE_NAME ) { return ; } $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof NotFoundHttpException ) { return ; } if ( method_exists ( $ exception , 'getOriginalResponse' ) ) { $ event -> setResponse ( $ exception -> getOriginalResponse ( ) ) ; } }
5453	public function endElement ( $ name ) { if ( $ name === 'label' ) { $ this -> acceptLabelEnd ( ) ; return true ; } if ( $ name === 'form' ) { $ this -> acceptFormEnd ( ) ; return true ; } if ( $ name === 'frameset' ) { $ this -> acceptFramesetEnd ( ) ; return true ; } if ( $ this -> hasNamedTagOnOpenTagStack ( $ name ) ) { $ tag = array_pop ( $ this -> tags [ $ name ] ) ; if ( $ tag -> isPrivateContent ( ) && $ this -> private_content_tag -> getTagName ( ) == $ name ) { unset ( $ this -> private_content_tag ) ; } $ this -> addContentTagToOpenTags ( $ tag ) ; $ this -> acceptTag ( $ tag ) ; return true ; } return true ; }
12341	protected function printError ( \ Throwable $ error , bool $ withTime = true , ? string $ fontColor = null , ? string $ bgColor = self :: BG_COLOR_MAP [ 'red' ] ) : void { $ shift = $ withTime ? "\t\t" : '' ; $ this -> print ( $ this -> getColoredMsg ( 'Error: ' . $ error -> getMessage ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'File: ' . $ error -> getFile ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'Line: ' . $ error -> getLine ( ) , $ fontColor , $ bgColor ) , $ withTime ) ; }
2100	public static function getNumericTimeFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> timeFormat != '' && static :: isNumericFormat ( $ objPage -> timeFormat ) ) { return $ objPage -> timeFormat ; } } return Config :: get ( 'timeFormat' ) ; }
3757	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values , [ 'allowed_classes' => false ] ) ) ; }
688	protected function removeAllItems ( $ type ) { if ( ! $ this -> supportsCascadeUpdate ( ) ) { $ names = ( new Query ( ) ) -> select ( [ 'name' ] ) -> from ( $ this -> itemTable ) -> where ( [ 'type' => $ type ] ) -> column ( $ this -> db ) ; if ( empty ( $ names ) ) { return ; } $ key = $ type == Item :: TYPE_PERMISSION ? 'child' : 'parent' ; $ this -> db -> createCommand ( ) -> delete ( $ this -> itemChildTable , [ $ key => $ names ] ) -> execute ( ) ; $ this -> db -> createCommand ( ) -> delete ( $ this -> assignmentTable , [ 'item_name' => $ names ] ) -> execute ( ) ; } $ this -> db -> createCommand ( ) -> delete ( $ this -> itemTable , [ 'type' => $ type ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; }
12652	public function getPageTexts ( $ language ) { if ( ! isset ( $ this -> contents [ $ language ] ) ) { $ this -> contents [ $ language ] = $ this -> readFileContents ( $ language ) ; } return $ this -> contents [ $ language ] ; }
6907	public function removeExtraRecipient ( Recipient $ recipient ) { if ( $ this -> extraRecipients -> contains ( $ recipient ) ) { $ this -> extraRecipients -> removeElement ( $ recipient ) ; } return $ this ; }
11791	public function setFrom ( $ mail = '' , $ name = null , $ reply = true ) { $ mail = trim ( $ mail ) ; if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { $ this -> from = ! empty ( $ name ) ? array ( $ name => $ mail ) : array ( $ mail ) ; $ this -> getMailer ( ) -> setRegistry ( 'Return-Path' , '<' . $ mail . '>' , 'headers' ) ; $ this -> getMailer ( ) -> setRegistry ( 'X-Sender' , $ mail , 'headers' ) ; if ( $ reply ) { $ this -> setReplyTo ( $ mail , $ name ) ; } } return $ this ; }
202	private function queryValueExists ( $ query , $ value ) { if ( is_array ( $ value ) ) { return $ query -> count ( "DISTINCT [[$this->targetAttribute]]" ) == count ( $ value ) ; } return $ query -> exists ( ) ; }
7678	function TbsSheetCheck ( ) { if ( count ( $ this -> OtbsSheetSlidesDelete ) > 0 ) $ this -> RaiseError ( "Unable to delete the following sheets because they are not found in the workbook: " . ( str_replace ( array ( 'i:' , 'n:' ) , '' , implode ( ', ' , $ this -> OtbsSheetSlidesDelete ) ) ) . '.' ) ; if ( count ( $ this -> OtbsSheetSlidesVisible ) > 0 ) $ this -> RaiseError ( "Unable to change visibility of the following sheets because they are not found in the workbook: " . ( str_replace ( array ( 'i:' , 'n:' ) , '' , implode ( ', ' , array_keys ( $ this -> OtbsSheetSlidesVisible ) ) ) ) . '.' ) ; }
5806	public function validate ( ValidationResult $ result ) { $ validate = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ validate = $ field ; } } if ( $ result -> valid ( ) && ! $ this -> owner -> $ validate ) { $ result -> error ( "\"{$validate}\" required!" ) ; } $ this -> owner -> extend ( 'validateFusionExtension' , $ result ) ; return $ result ; }
3034	public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ data = $ this -> getTreeResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; return $ this -> formatTreeData ( $ data ) ; }
4950	public function createDraft ( array $ data = null , $ persist = false ) { $ data [ 'isDraft' ] = true ; return $ this -> create ( $ data , $ persist ) ; }
3421	protected function loadModels ( ) { $ queryType = 'UserQuery::getList' ; $ sort = $ this -> sort ; $ filter = $ this -> normalizeFilter ( ) ; $ params = [ 'SELECT' => $ this -> propsMustBeSelected ( ) ? [ 'UF_*' ] : ( $ this -> normalizeUfSelect ( ) ? : false ) , 'NAV_PARAMS' => $ this -> navigation , 'FIELDS' => $ this -> normalizeSelect ( ) , ] ; $ selectGroups = $ this -> groupsMustBeSelected ( ) ; $ keyBy = $ this -> keyBy ; $ callback = function ( ) use ( $ sort , $ filter , $ params , $ selectGroups ) { $ users = [ ] ; $ rsUsers = $ this -> bxObject -> getList ( $ sort , $ sortOrder = false , $ filter , $ params ) ; while ( $ arUser = $ this -> performFetchUsingSelectedMethod ( $ rsUsers ) ) { if ( $ selectGroups ) { $ arUser [ 'GROUP_ID' ] = $ this -> bxObject -> getUserGroup ( $ arUser [ 'ID' ] ) ; } $ this -> addItemToResultsUsingKeyBy ( $ users , new $ this -> modelName ( $ arUser [ 'ID' ] , $ arUser ) ) ; } return new Collection ( $ users ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'sort' , 'filter' , 'params' , 'selectGroups' , 'keyBy' ) , $ callback ) ; }
7118	protected function getGetAvailableSumBySubjectQuery ( ) { if ( null !== $ this -> getAvailableSumBySubjectQuery ) { return $ this -> getAvailableSumBySubjectQuery ; } $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; $ qb -> andWhere ( $ qb -> expr ( ) -> gte ( $ as . '.availableStock' , 0 ) ) -> select ( 'SUM(' . $ as . '.availableStock) as available' ) ; return $ this -> getAvailableSumBySubjectQuery = $ qb -> getQuery ( ) ; }
11122	public function getEndLocation ( ) { $ lastLocation = $ this -> getLocation ( ) ; $ lastDate = NOW ; foreach ( $ this -> movements as $ v ) { if ( $ v -> getEndTime ( ) > $ lastDate ) { $ lastDate = $ v -> getEndTime ( ) ; $ lastLocation = $ v -> getEndLocation ( ) ; } } return $ lastLocation ; }
10419	public static function parse ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new Exception ( 'The give file ' . $ path . ' doesn\'t exist.' ) ; } return Yaml :: parse ( file_get_contents ( $ path ) ) ; }
6866	protected function preventForbiddenChange ( InvoiceInterface $ invoice ) { if ( $ this -> persistenceHelper -> isChanged ( $ invoice , 'type' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'type' ) ; if ( $ old != $ new ) { throw new Exception \ IllegalOperationException ( "Changing the invoice type is not yet supported." ) ; } } }
11980	protected function query ( $ api , $ from , $ to ) { $ params = [ 'begin_date' => $ from , 'end_date' => $ to , ] ; return $ this -> parseJSON ( 'json' , [ $ api , $ params ] ) ; }
5408	protected function isMatch ( $ cookie , $ host , $ path , $ name ) { if ( $ cookie -> getName ( ) != $ name ) { return false ; } if ( $ host && $ cookie -> getHost ( ) && ! $ cookie -> isValidHost ( $ host ) ) { return false ; } if ( ! $ cookie -> isValidPath ( $ path ) ) { return false ; } return true ; }
11191	public function routeProcess ( $ uri = false , $ httpMethod = false ) { if ( ! $ httpMethod ) $ httpMethod = $ _SERVER [ 'REQUEST_METHOD' ] ; $ this -> httpMethod = $ httpMethod ; if ( ! $ uri ) $ uri = $ _SERVER [ 'REQUEST_URI' ] ; $ this -> setPath ( $ uri ) ; $ customPathSearch = $ this -> customFind ( ) ; if ( $ customPathSearch || ( ! $ customPathSearch && $ this -> config [ 'automatic_routing' ] ) ) { $ this -> routeFind ( ) ; } else if ( $ customPathSearch == - 1 ) { $ this -> error ( '403' ) ; } }
7345	public function modifySubmitedValueBeforeValidation ( $ value , array $ data ) { if ( $ this -> hasSubmittedValueModifier ( ) ) { return call_user_func ( $ this -> getSubmittedValueModifier ( ) , $ value , $ data ) ; } else { return $ value ; } }
3544	protected function writeable ( $ file_path ) { if ( $ this -> option ( 'force' ) ) { return true ; } return ( ! file_exists ( $ file_path ) || $ this -> confirmable ( $ file_path ) ) ; }
12095	public function shortText ( $ text , $ length ) { $ text = trim ( $ text ) ; $ charset = mb_detect_encoding ( $ text ) ; if ( mb_strlen ( $ text , $ charset ) > $ length ) { $ text = mb_substr ( $ text , 0 , $ length , $ charset ) . '...' ; } else { $ text = $ text ; } return $ text ; }
5352	public function getSupportedNamespaces ( ) { if ( empty ( $ this -> data -> namespaces ) || ! is_array ( $ this -> data -> namespaces ) ) { return array ( ) ; } return $ this -> data -> namespaces ; }
8732	public function challenge ( string $ hydroAddressId ) : ChallengeResponse { try { $ response = $ this -> callHydroApi ( 'post' , 'challenge' , [ 'json' => [ 'hydro_address_id' => $ hydroAddressId ] ] ) ; $ data = \ GuzzleHttp \ json_decode ( $ response -> getBody ( ) -> getContents ( ) , true , 512 , JSON_BIGINT_AS_STRING ) ; } catch ( RuntimeException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( InvalidArgumentException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( GuzzleException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( ApiRequestFailed $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } return new ChallengeResponse ( $ data [ 'amount' ] , ( int ) $ data [ 'challenge' ] , ( int ) $ data [ 'partner_id' ] , $ data [ 'transaction_hash' ] ) ; }
69	public function removeJunction ( $ junction ) { if ( ! Platform :: isWindows ( ) ) { return false ; } $ junction = rtrim ( str_replace ( '/' , DIRECTORY_SEPARATOR , $ junction ) , DIRECTORY_SEPARATOR ) ; if ( ! $ this -> isJunction ( $ junction ) ) { throw new IOException ( sprintf ( '%s is not a junction and thus cannot be removed as one' , $ junction ) ) ; } return $ this -> rmdir ( $ junction ) ; }
4918	public function setParam ( $ key , $ value ) { if ( $ this -> has ( $ key ) ) { $ this -> get ( $ key ) -> setValue ( $ value ) ; } else { $ this -> add ( [ 'type' => 'hidden' , 'name' => $ key , 'attributes' => [ 'value' => $ value ] ] ) ; } return $ this ; }
1789	public function pasteArticle ( Contao \ DataContainer $ dc , $ row , $ table , $ cr , $ arrClipboard = null ) { $ imagePasteAfter = Contao \ Image :: getHtml ( 'pasteafter.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) ; $ imagePasteInto = Contao \ Image :: getHtml ( 'pasteinto.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) ; if ( $ table == $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'ptable' ] ) { return ( $ row [ 'type' ] == 'root' || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ row ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteinto_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=2&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteInto . '</a> ' ; } $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return ( ( $ arrClipboard [ 'mode' ] == 'cut' && $ arrClipboard [ 'id' ] == $ row [ 'id' ] ) || ( $ arrClipboard [ 'mode' ] == 'cutAll' && \ in_array ( $ row [ 'id' ] , $ arrClipboard [ 'id' ] ) ) || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ objPage -> row ( ) ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteafter_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=1&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteAfter . '</a> ' ; }
447	private function attachBehaviorInternal ( $ name , $ behavior ) { if ( ! ( $ behavior instanceof Behavior ) ) { $ behavior = Yii :: createObject ( $ behavior ) ; } if ( is_int ( $ name ) ) { $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ ] = $ behavior ; } else { if ( isset ( $ this -> _behaviors [ $ name ] ) ) { $ this -> _behaviors [ $ name ] -> detach ( ) ; } $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ $ name ] = $ behavior ; } return $ behavior ; }
4944	public function grant ( $ resource , $ permission = null , $ build = true ) { if ( is_array ( $ resource ) ) { foreach ( $ resource as $ r ) { $ this -> grant ( $ r , $ permission , false ) ; } if ( $ build ) { $ this -> build ( ) ; } return $ this ; } true === $ permission || ( null === $ permission && $ resource instanceof PermissionsResourceInterface ) || $ this -> checkPermission ( $ permission ) ; $ resourceId = $ this -> getResourceId ( $ resource ) ; if ( true === $ permission ) { $ permission = $ this -> getFrom ( $ resource ) ; } if ( self :: PERMISSION_NONE == $ permission ) { if ( $ resource instanceof PermissionsResourceInterface ) { $ refs = $ this -> getResources ( ) ; if ( $ refs -> contains ( $ resource ) ) { $ refs -> removeElement ( $ resource ) ; } } unset ( $ this -> assigned [ $ resourceId ] ) ; } else { if ( $ resource instanceof PermissionsResourceInterface ) { $ spec = $ resource -> getPermissionsUserIds ( $ this -> type ) ; if ( ! is_array ( $ spec ) || ! count ( $ spec ) ) { $ spec = array ( ) ; } elseif ( is_numeric ( key ( $ spec ) ) ) { $ spec = array ( $ permission => $ spec ) ; } } else { $ spec = array ( $ permission => $ resource instanceof UserInterface ? array ( $ resource -> getId ( ) ) : array ( $ resource ) ) ; } $ this -> assigned [ $ resourceId ] = $ spec ; if ( $ resource instanceof PermissionsResourceInterface ) { try { $ refs = $ this -> getResources ( ) ; if ( ! $ refs -> contains ( $ resource ) ) { $ refs -> add ( $ resource ) ; } } catch ( \ Exception $ e ) { } ; } } if ( $ build ) { $ this -> build ( ) ; } $ this -> hasChanged = true ; return $ this ; }
1111	public function map ( $ nodeList ) { $ self = $ this ; return $ this -> wrapInTransaction ( function ( ) use ( $ self , $ nodeList ) { forward_static_call ( array ( get_class ( $ self -> node ) , 'unguard' ) ) ; $ result = $ self -> mapTree ( $ nodeList ) ; forward_static_call ( array ( get_class ( $ self -> node ) , 'reguard' ) ) ; return $ result ; } ) ; }
9471	public function paginate ( $ numTotal , $ page , $ limit = 10 ) { $ this -> setTotalItemCount ( $ numTotal ) ; $ this -> setCurrentPageNumber ( $ page ) ; $ this -> setItemNumberPerPage ( $ limit ) ; }
3656	public function boot ( ) { $ environment = System :: getContainer ( ) -> get ( 'contao.framework' ) -> getAdapter ( Environment :: class ) ; $ script = explode ( '?' , $ environment -> get ( 'relativeRequest' ) , 2 ) [ 0 ] ; if ( ( 'contao/login' === $ script ) || ( 'contao/install' === $ script ) ) { return ; } $ connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; if ( ! $ connection -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' , 'tl_metamodel_dca' , 'tl_metamodel_dca_sortgroup' , 'tl_metamodel_dcasetting' , 'tl_metamodel_dcasetting_condition' , 'tl_metamodel_attribute' , 'tl_metamodel_filter' , 'tl_metamodel_filtersetting' , 'tl_metamodel_rendersettings' , 'tl_metamodel_rendersetting' , 'tl_metamodel_dca_combine' , ] ) ) { System :: getContainer ( ) -> get ( 'logger' ) -> error ( 'MetaModels startup interrupted. Not all MetaModels tables have been created.' ) ; return ; } $ event = new MetaModelsBootEvent ( ) ; $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT , $ event ) ; $ determinator = System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) ; switch ( true ) { case $ determinator -> currentScopeIsFrontend ( ) : $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT_FRONTEND , $ event ) ; break ; case $ determinator -> currentScopeIsBackend ( ) : $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT_BACKEND , $ event ) ; break ; default : } }
4715	public function split ( $ pattern , $ flags = PREG_SPLIT_DELIM_CAPTURE ) { return new Collection ( array_map ( function ( $ item ) { return new static ( $ item ) ; } , preg_split ( $ pattern , $ this -> text , - 1 , $ flags ) ) ) ; }
4436	public function get ( string $ name , $ default = null ) { $ res = $ this -> client -> call ( 'config.get' , $ name ) ; return $ res === null ? $ default : $ res ; }
3773	private function buildMetaPaletteConditions ( $ palette , $ metaPalettes ) { foreach ( $ metaPalettes as $ typeName => $ paletteInfo ) { if ( 'default' === $ typeName ) { continue ; } if ( preg_match ( '#^(\w+) extends (\w+)$#' , $ typeName , $ matches ) ) { $ typeName = $ matches [ 1 ] ; } foreach ( $ paletteInfo as $ legendName => $ properties ) { foreach ( $ properties as $ propertyName ) { $ condition = new AttributeByIdIsOfType ( $ typeName , $ this -> connection , 'attr_id' ) ; $ legend = $ this -> getLegend ( $ legendName , $ palette ) ; $ property = $ this -> getProperty ( $ propertyName , $ legend ) ; $ this -> addCondition ( $ property , $ condition ) ; } } } }
4204	private function addPropertiesPhpDoc ( Event $ abs ) { $ tags = array ( 'property' => 'magic' , 'property-read' => 'magic-read' , 'property-write' => 'magic-write' , ) ; $ inheritedFrom = null ; if ( ! \ array_intersect_key ( $ abs [ 'phpDoc' ] , $ tags ) ) { $ found = false ; $ obj = $ abs -> getSubject ( ) ; if ( ! \ method_exists ( $ obj , '__get' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ parsed = $ this -> phpDoc -> getParsed ( $ reflector ) ; $ tagIntersect = \ array_intersect_key ( $ parsed , $ tags ) ; if ( ! $ tagIntersect ) { continue ; } $ found = true ; $ inheritedFrom = $ reflector -> getName ( ) ; $ abs [ 'phpDoc' ] = \ array_merge ( $ abs [ 'phpDoc' ] , $ tagIntersect ) ; break ; } if ( ! $ found ) { return ; } } $ properties = $ abs [ 'properties' ] ; foreach ( $ tags as $ tag => $ vis ) { if ( ! isset ( $ abs [ 'phpDoc' ] [ $ tag ] ) ) { continue ; } foreach ( $ abs [ 'phpDoc' ] [ $ tag ] as $ phpDocProp ) { $ exists = isset ( $ properties [ $ phpDocProp [ 'name' ] ] ) ; $ properties [ $ phpDocProp [ 'name' ] ] = \ array_merge ( $ exists ? $ properties [ $ phpDocProp [ 'name' ] ] : self :: $ basePropInfo , array ( 'desc' => $ phpDocProp [ 'desc' ] , 'type' => $ phpDocProp [ 'type' ] , 'inheritedFrom' => $ inheritedFrom , 'visibility' => $ exists ? array ( $ properties [ $ phpDocProp [ 'name' ] ] [ 'visibility' ] , $ vis ) : $ vis , ) ) ; if ( ! $ exists ) { $ properties [ $ phpDocProp [ 'name' ] ] [ 'value' ] = $ this -> abstracter -> UNDEFINED ; } } unset ( $ abs [ 'phpDoc' ] [ $ tag ] ) ; } $ abs [ 'properties' ] = $ properties ; return ; }
5109	public function orderBy ( $ column , $ type = OrderBy :: ASC ) : IWithLimit { if ( $ type == OrderBy :: DESC ) { $ this -> appendDesc ( $ column ) ; } else if ( ! is_array ( $ column ) ) { $ column = [ $ column ] ; } return $ this -> _orderBy ( $ column ) ; }
1566	public function substituteBindings ( StoreInterface $ store ) : void { $ this -> resourceId = $ this -> getResourceId ( ) ? : false ; $ this -> processId = $ this -> getProcessId ( ) ? : false ; if ( $ this -> resourceId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_RESOURCE_ID , $ store -> findOrFail ( $ this -> getResourceType ( ) , $ this -> resourceId ) ) ; } if ( $ this -> processId ) { $ this -> route -> setParameter ( ResourceRegistrar :: PARAM_PROCESS_ID , $ store -> findOrFail ( $ this -> getProcessType ( ) , $ this -> processId ) ) ; } }
2335	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ this -> tokenStorage -> initialize ( $ this -> getTokensFromCookies ( $ event -> getRequest ( ) -> cookies ) ) ; }
8670	public static function fromRecursive ( $ collection ) { $ arr = Arr :: from ( $ collection ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return new static ( $ arr ) ; }
8256	protected function initProvider ( $ providerConfig ) { $ providerClass = $ providerConfig [ 'provider' ] ; $ options = $ providerConfig [ 'options' ] ; if ( ! isset ( $ options [ 'redirectUri' ] ) ) { $ options [ 'redirectUri' ] = $ this -> picoAuth -> getPico ( ) -> getPageUrl ( $ this -> config [ "callbackPage" ] ) ; } if ( ! class_exists ( $ providerClass ) ) { throw new \ RuntimeException ( "Provider class $providerClass does not exist." ) ; } if ( ! is_subclass_of ( $ providerClass , AbstractProvider :: class , true ) ) { throw new \ RuntimeException ( "Class $providerClass is not a League\OAuth2 provider." ) ; } $ this -> provider = new $ providerClass ( $ options ) ; $ this -> providerConfig = $ providerConfig ; }
1252	private function normalizeElementName ( $ name ) { $ nsElement = explode ( '@' , $ name ) ; if ( count ( $ nsElement ) > 1 ) { array_shift ( $ nsElement ) ; return $ nsElement [ 0 ] ; } else { return $ name ; } }
5295	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputDirectory = realpath ( $ input -> getArgument ( 'output-directory' ) ) ; if ( $ outputDirectory === false || ! file_exists ( $ outputDirectory ) || ! is_dir ( $ outputDirectory ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'output-directory' ) . '" is no directory' ) ; } $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing SVG files to "' . $ outputDirectory . '" ...' ) ; $ generator -> saveGlyphsToDir ( $ outputDirectory ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created SVG files successfully</success>' ) ; }
186	protected function renderStrike ( $ element ) { return Console :: ansiFormat ( $ this -> parseInline ( $ this -> renderAbsy ( $ element [ 1 ] ) ) , [ Console :: CROSSED_OUT ] ) ; }
6363	public function start ( $ name ) : Profiler { if ( ! $ this -> globalStopwatch -> isRunning ( ) ) { $ this -> globalStopwatch -> start ( ) ; } if ( $ this -> entryStopwatch -> isRunning ( ) ) { $ this -> recordEntry ( ) ; } $ this -> currentName = $ name ; $ this -> entryStopwatch -> start ( ) ; return $ this ; }
1684	public function checkAdminStatus ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == '' && $ this -> User -> id == $ dc -> id ) { $ varValue = 1 ; } return $ varValue ; }
9059	public function addUnique ( string ... $ name ) : self { $ key = new Index ( ... $ name ) ; $ key -> setUnique ( ) ; $ this -> keys [ $ key -> name ] = $ key ; return $ this ; }
9123	private function retrieveAndParseResponse ( $ requestType ) { $ this -> payload = new MemoryStream ( ) ; $ this -> headers = array ( ) ; $ delimiterFound = false ; $ tmp = "" ; $ numBytes = 1 ; $ start = time ( ) ; while ( true ) { if ( ! $ this -> checkConnection ( $ start ) ) { continue ; } $ c = $ this -> read ( $ numBytes ) ; if ( $ c == null ) { break ; } $ start = time ( ) ; $ tmp .= $ c ; if ( ! $ delimiterFound ) { $ this -> handleHeader ( $ delimiterFound , $ numBytes , $ tmp ) ; } if ( $ delimiterFound ) { if ( $ requestType == 'HEAD' ) { break ; } $ this -> payload -> write ( $ tmp ) ; $ tmp = "" ; if ( $ this -> checkContentLengthExceeded ( ) ) { break ; } } } $ size = $ this -> payload -> count ( ) ; if ( $ size == 0 ) { return ; } $ this -> payload -> reset ( ) ; $ mayCompressed = $ this -> payload -> read ( $ size ) ; switch ( $ this -> getContentEncoding ( ) ) { case 'gzip' : $ uncompressed = gzdecode ( strstr ( $ mayCompressed , "\x1f\x8b" ) ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; case 'deflate' : $ uncompressed = gzuncompress ( $ mayCompressed ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; default : break ; } $ this -> payload -> reset ( ) ; }
12739	public function removeClass ( $ name ) { $ classParts = explode ( ' ' , $ this -> tags [ 'class' ] ) ; $ className = '' ; foreach ( $ classParts as $ part ) { if ( $ name != $ part ) { $ className .= ' ' . $ part ; } } $ this -> tags [ 'class' ] = trim ( $ className ) ; }
3194	public function getExtraTime ( $ maxTime = 0 ) { if ( $ maxTime && $ this -> getExtendedTime ( ) ) { $ secondsNew = $ maxTime * $ this -> getExtendedTime ( ) ; $ extraTime = $ secondsNew - $ maxTime ; $ this -> setExtraTime ( $ extraTime ) ; return $ extraTime ; } return $ this -> extraTime ; }
3521	public static function login ( $ email , $ password , $ challenge = '' , $ code = '' ) { $ requestParams = [ 'includePerms' => 'false' , 'token_type' => 'eg1' ] ; if ( empty ( $ challenge ) && empty ( $ code ) ) { $ requestParams = array_merge ( $ requestParams , [ 'grant_type' => 'password' , 'username' => $ email , 'password' => $ password , ] ) ; } else { $ requestParams = array_merge ( $ requestParams , [ 'grant_type' => 'otp' , 'otp' => $ code , 'challenge' => $ challenge , ] ) ; } $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , $ requestParams ) ; if ( ! isset ( $ data -> access_token ) ) { if ( $ data -> errorCode === 'errors.com.epicgames.common.two_factor_authentication.required' ) { throw new TwoFactorAuthRequiredException ( $ data -> challenge ) ; } throw new \ Exception ( $ data -> errorMessage ) ; } $ data = FortniteClient :: sendUnrealClientGetRequest ( FortniteClient :: EPIC_OAUTH_EXCHANGE_ENDPOINT , $ data -> access_token , true ) ; if ( ! isset ( $ data -> code ) ) { throw new \ Exception ( $ data -> errorMessage ) ; } $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , [ 'grant_type' => 'exchange_code' , 'exchange_code' => $ data -> code , 'includePerms' => false , 'token_type' => 'eg1' ] , FortniteClient :: FORTNITE_AUTHORIZATION ) ; if ( ! isset ( $ data -> access_token ) ) { throw new \ Exception ( $ data -> errorMessage ) ; } return new self ( $ data -> access_token , $ data -> in_app_id , $ data -> refresh_token , $ data -> account_id , $ data -> expires_in ) ; }
2883	public function getRequestInfo ( ) { if ( $ this -> requestInfo === null ) { $ this -> requestInfo = Mage :: getModel ( 'sheep_debug/requestInfo' ) ; } return $ this -> requestInfo ; }
8347	public function canEdit ( GroupableInterface $ post , TokenInterface $ token ) : bool { $ user = $ token -> getUser ( ) ; if ( $ post -> getAuthor ( ) == $ user -> getUsername ( ) ) { return true ; } foreach ( $ post -> getGroups ( ) as $ group ) { if ( $ this -> decision_manager -> decide ( $ token , [ 'GROUP_ROLE_ADMIN' ] , $ group ) ) { return true ; } } return false ; }
7861	public function draw ( $ workflow ) { $ this -> geometry -> setCore ( $ workflow ) ; $ this -> setPipesOfWorkflow ( $ workflow ) ; $ this -> drawCenteredChar ( static :: NOCK ) ; $ this -> drawPipesBeginning ( ) ; $ this -> drawCore ( ) ; $ this -> drawPipesEnd ( ) ; $ this -> drawCenteredChar ( static :: PILE ) ; return $ this -> drawing ; }
9610	public function getRouteUrl ( $ name , array $ params = array ( ) , $ relative = false ) { $ route = $ this -> router -> getRoute ( $ name ) ; $ routeParams = [ ] ; $ query = [ ] ; foreach ( $ params as $ key => $ value ) { if ( is_int ( $ key ) ) { $ routeParams [ ] = $ value ; } else { $ query [ $ key ] = $ value ; } } $ path = $ this -> routePathGenerator -> getRoutePath ( $ route , $ routeParams ) ; if ( $ query ) { $ path .= '?' . http_build_query ( $ query ) ; } if ( $ relative ) { $ root = $ this -> requests -> getCurrentRequest ( ) -> getBaseUrl ( ) ; } else { $ root = $ this -> getRootUrl ( ) ; } return $ root . $ path ; }
328	public static function instance ( $ refresh = false ) { $ className = get_called_class ( ) ; if ( $ refresh || ! isset ( self :: $ _instances [ $ className ] ) ) { self :: $ _instances [ $ className ] = Yii :: createObject ( $ className ) ; } return self :: $ _instances [ $ className ] ; }
11816	protected function step3 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/database" ) ; $ this -> view -> setData ( "step" , "3" ) ; $ this -> view -> setData ( "randomstring" , getRandomString ( '5' ) . "_" ) ; $ this -> view -> setData ( "title" , t ( "Installation | Database Settings" ) ) ; return ; }
612	public function setSingleton ( $ class , $ definition = [ ] , array $ params = [ ] ) { $ this -> _definitions [ $ class ] = $ this -> normalizeDefinition ( $ class , $ definition ) ; $ this -> _params [ $ class ] = $ params ; $ this -> _singletons [ $ class ] = null ; return $ this ; }
5083	protected function lookUpResource ( $ aData = [ ] , $ iSegment = 4 ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sIdentifier = $ oUri -> segment ( $ iSegment ) ; $ oInput = Factory :: service ( 'Input' ) ; $ aData = array_merge ( static :: CONFIG_LOOKUP_DATA , $ aData ) ; $ aExpansions = array_filter ( ( array ) $ oInput -> get ( 'expand' ) ) ; if ( $ aExpansions ) { if ( ! array_key_exists ( 'expand' , $ aData ) ) { $ aData [ 'expand' ] = [ ] ; } $ aData [ 'expand' ] = array_merge ( $ aData [ 'expand' ] , $ aExpansions ) ; } switch ( static :: CONFIG_LOOKUP_METHOD ) { case 'ID' : return $ this -> oModel -> getById ( $ sIdentifier , $ aData ) ; break ; case 'SLUG' : return $ this -> oModel -> getBySlug ( $ sIdentifier , $ aData ) ; break ; case 'TOKEN' : return $ this -> oModel -> getByToken ( $ sIdentifier , $ aData ) ; break ; } }
6346	public static function concat ( Iterator $ a , Iterator $ b ) : Iterator { return self :: concatIterators ( new ArrayIterator ( [ $ a , $ b ] ) ) ; }
7860	private function registerCommands ( ) { foreach ( $ this -> commands as $ command ) { $ name = ucfirst ( last ( explode ( '.' , $ command ) ) ) ; $ this -> app -> singleton ( $ command , function ( $ app ) use ( $ name ) { return $ app [ "Cerbero\Workflow\Console\Commands\\{$name}WorkflowCommand" ] ; } ) ; } }
9942	public function setProtection ( Protection $ pValue ) { $ this -> protection = $ pValue ; $ this -> dirty = true ; return $ this ; }
1739	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'login' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( ! $ _POST && $ this -> redirectBack && ( $ strReferer = $ this -> getReferer ( ) ) != Environment :: get ( 'request' ) ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ strReferer ; } return parent :: generate ( ) ; }
7460	public function lookup ( $ hash , $ className = 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) { try { return $ this -> hashedEntityHelper -> lookup ( $ hash , $ className ) ; } catch ( \ RuntimeException $ e ) { return null ; } }
6132	protected function getSuffixFlag ( ) { if ( ! $ this -> currObj instanceof Client ) { return "" ; } if ( $ this -> flagpath && $ this -> currObj [ "client_country" ] ) { return $ this -> getImage ( $ this -> currObj [ "client_country" ] -> toLower ( ) . ".png" , $ this -> currObj [ "client_country" ] , null , false , true ) ; } return "" ; }
7000	public function url ( $ url = null ) { if ( $ url ) $ this -> url = trim ( $ url ) ; return $ this -> url ; }
8243	public function loginAttempt ( $ username , Password $ password ) { $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; $ dummy = bin2hex ( \ random_bytes ( 32 ) ) ; $ dummyHash = $ encoder -> encode ( $ dummy ) ; if ( ! $ userData ) { $ encoder -> isValid ( $ dummyHash , $ password ) ; return false ; } return $ encoder -> isValid ( $ userData [ 'pwhash' ] , $ password -> get ( ) ) ; }
3635	public function httpMiddles ( Request $ request ) : array { $ dispatcher = \ bean ( 'serverDispatcher' ) ; $ middleType = ( int ) $ request -> query ( 'type' ) ; if ( $ middleType === 1 ) { return $ dispatcher -> getMiddlewares ( ) ; } return $ dispatcher -> requestMiddleware ( ) ; }
7814	private function _processRequest ( ) { $ this -> _isAjaxRequest = $ this -> request -> is ( 'ajax' ) ; if ( isset ( $ this -> request -> query [ 'length' ] ) && ! empty ( $ this -> request -> query [ 'length' ] ) ) { $ this -> config ( 'length' , $ this -> request -> query [ 'length' ] ) ; } if ( isset ( $ this -> request -> query [ 'start' ] ) && ! empty ( $ this -> request -> query [ 'start' ] ) ) { $ this -> config ( 'start' , ( int ) $ this -> request -> query [ 'start' ] ) ; } if ( isset ( $ this -> request -> query [ 'order' ] ) && ! empty ( $ this -> request -> query [ 'order' ] ) ) { $ order = $ this -> config ( 'order' ) ; foreach ( $ this -> request -> query [ 'order' ] as $ item ) { $ order [ $ this -> request -> query [ 'columns' ] [ $ item [ 'column' ] ] [ 'name' ] ] = $ item [ 'dir' ] ; } $ this -> config ( 'order' , $ order ) ; } if ( isset ( $ this -> request -> query [ 'draw' ] ) && ! empty ( $ this -> request -> query [ 'draw' ] ) ) { $ this -> _viewVars [ 'draw' ] = ( int ) $ this -> request -> query [ 'draw' ] ; } if ( ! isset ( $ this -> request -> query [ 'columns' ] ) || empty ( $ this -> request -> query [ 'columns' ] ) ) { return ; } $ globalSearch = ( isset ( $ this -> request -> query [ 'search' ] [ 'value' ] ) ? $ this -> request -> query [ 'search' ] [ 'value' ] : false ) ; foreach ( $ this -> request -> query [ 'columns' ] as $ column ) { if ( $ globalSearch && $ column [ 'searchable' ] == 'true' ) { $ this -> _addCondition ( $ column [ 'name' ] , $ globalSearch , 'or' ) ; } $ localSearch = $ column [ 'search' ] [ 'value' ] ; if ( ! empty ( $ localSearch ) && ( $ localSearch !== $ globalSearch ) ) { $ this -> _addCondition ( $ column [ 'name' ] , $ column [ 'search' ] [ 'value' ] ) ; } } }
10783	public function orHaving ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "OR" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
12922	public function getForeignDataItems ( ) { if ( ! isset ( $ this -> _foreignDataItems ) ) { $ this -> _foreignDataItems = [ ] ; $ this -> trigger ( self :: EVENT_LOAD_FOREIGN_DATA_ITEMS ) ; } return $ this -> _foreignDataItems ; }
9398	protected function selectBuilder ( ) { if ( PHP_OS === 'Darwin' ) { if ( exec ( 'which growlnotify' ) ) { return new GrowlNotifyBuilder ; } if ( exec ( 'which terminal-notifier' ) ) { return new TerminalNotifierBuilder ; } } if ( PHP_OS === 'Linux' ) { if ( exec ( 'which notify-send' ) ) { return new NotifySendBuilder ; } } if ( PHP_OS === 'WINNT' ) { if ( exec ( 'where growlnotify' ) ) { return new GrowlNotifyWindowsBuilder ; } } }
1479	public function removeRelationship ( $ resourceType , $ id , $ relationshipKey , array $ queryParams = [ ] ) { $ name = RouteName :: removeRelationship ( $ resourceType , $ relationshipKey ) ; return $ this -> resource ( $ name , $ id , $ queryParams ) ; }
2003	public static function getNormalizedVersion ( string $ packageName ) : string { $ chunks = explode ( '.' , static :: getVersion ( $ packageName ) ) ; $ chunks += [ 0 , 0 , 0 ] ; if ( \ count ( $ chunks ) > 3 ) { $ chunks = \ array_slice ( $ chunks , 0 , 3 ) ; } return implode ( '.' , $ chunks ) ; }
10821	public static function title ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'title' , $ length , $ separator ) ; }
2242	public static function getContentElement ( $ intId , $ strColumn = 'main' ) { if ( \ is_object ( $ intId ) ) { $ objRow = $ intId ; } else { if ( ! \ strlen ( $ intId ) || $ intId < 1 ) { return '' ; } $ objRow = ContentModel :: findByPk ( $ intId ) ; if ( $ objRow === null ) { return '' ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } $ strClass = ContentElement :: findClass ( $ objRow -> type ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Content element class "' . $ strClass . '" (content element "' . $ objRow -> type . '") does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = 'ce_' ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } if ( $ objElement -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
2654	public function hasSnippet ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/snippet/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET , '' , false , null , false ) ; if ( $ result == false ) { return false ; } return true ; }
1145	public function getRule ( $ attribute , $ rule , $ parameters , $ rawRule ) { $ isConditional = $ this -> isConditionalRule ( $ attribute , $ rawRule ) ; $ isRemote = $ this -> isRemoteRule ( $ rule ) ; if ( $ isConditional || $ isRemote ) { list ( $ attribute , $ parameters ) = $ this -> remoteRule ( $ attribute , $ isConditional ) ; $ jsRule = self :: REMOTE_RULE ; } else { list ( $ jsRule , $ attribute , $ parameters ) = $ this -> clientRule ( $ attribute , $ rule , $ parameters ) ; } $ attribute = $ this -> getAttributeName ( $ attribute ) ; return [ $ attribute , $ jsRule , $ parameters ] ; }
1156	public function sometimes ( $ attribute , $ rules , callable $ callback ) { $ this -> validator -> sometimes ( $ attribute , $ rules , $ callback ) ; }
8909	public function serialize_row ( $ row ) { foreach ( $ this -> callback_parameters as $ column ) { $ row [ $ column ] = serialize ( $ row [ $ column ] ) ; } return $ row ; }
12042	public function update ( $ usernameId , $ data = array ( ) ) { if ( empty ( $ usernameId ) ) return false ; $ existing = ( array ) $ this -> getPropertyData ( ) ; $ data = empty ( $ data ) ? $ existing : array_merge ( $ data , $ existing ) ; $ profile = $ this -> loadObjectByURI ( $ usernameId , array_keys ( $ this -> getPropertyModel ( ) ) ) ; $ this -> setObjectId ( $ profile -> getObjectId ( ) ) ; $ this -> setObjectURI ( $ profile -> getObjectURI ( ) ) ; $ profileData = $ profile -> getPropertyData ( ) ; $ updatedProfile = array_merge ( $ profileData , $ data ) ; foreach ( $ updatedProfile as $ property => $ value ) : $ this -> setPropertyValue ( $ property , $ value ) ; endforeach ; $ this -> defineValueGroup ( "user" ) ; if ( ! $ this -> saveObject ( $ this -> getPropertyValue ( "user_name_id" ) , "user" , $ this -> getObjectId ( ) ) ) { $ profile -> setError ( "Could not save the profile data" ) ; return false ; } return true ; }
3965	protected function authenticateUser ( ) { if ( \ System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) -> currentScopeIsUnknown ( ) ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'contao/login' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'request' ) , 'install' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'system/bin' ) !== false ) { return false ; } $ authResult = $ this -> getUser ( ) -> authenticate ( ) ; return ( $ authResult === true || $ authResult === null ) ? true : false ; }
2180	private function findIn ( string $ path ) : Finder { return Finder :: create ( ) -> ignoreDotFiles ( false ) -> sort ( static function ( SplFileInfo $ a , SplFileInfo $ b ) : int { $ countA = substr_count ( strtr ( $ a -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; $ countB = substr_count ( strtr ( $ b -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; return $ countA <=> $ countB ; } ) -> followLinks ( ) -> in ( $ path ) ; }
8361	public static function init ( RawRequest $ request = null ) { if ( self :: $ isInit === false ) { self :: $ translations = array ( ) ; $ settings = Config :: getSettings ( ) ; if ( isset ( $ settings [ 'locale' ] ) === false || isset ( $ settings [ 'locale' ] [ 'default' ] ) === false ) { throw new BadUse ( 'locale.default isn\'t defined in settings' ) ; } self :: $ currentLanguage = $ settings [ 'locale' ] [ 'default' ] ; if ( $ request != null ) { if ( Session :: has ( '_stray_language' ) === true ) { self :: $ currentLanguage = Session :: get ( '_stray_language' ) ; } else { $ domain = HttpHelper :: extractDomain ( $ request ) ; if ( isset ( $ settings [ 'locale' ] [ 'hosts' ] ) === true && isset ( $ settings [ 'locale' ] [ 'hosts' ] [ $ domain ] ) === true ) { self :: $ currentLanguage = $ settings [ 'locale' ] [ 'hosts' ] [ $ domain ] ; } Session :: set ( '_stray_language' , self :: $ currentLanguage ) ; } } self :: $ isInit = true ; } }
12327	protected function getParam ( $ param ) { if ( isset ( $ _POST [ $ param ] ) ) { return $ _POST [ $ param ] ; } elseif ( isset ( $ _GET [ $ param ] ) ) { return $ _GET [ $ param ] ; } return ; }
4023	protected function buildOptions ( ) { $ options = array ( ) ; foreach ( $ this -> arrWidgets as $ widgetRow ) { $ columns = array ( ) ; foreach ( $ widgetRow as $ widget ) { $ valign = ( $ widget -> valign != '' ? ' valign="' . $ widget -> valign . '"' : '' ) ; $ class = ( $ widget -> tl_class != '' ? ' class="' . $ widget -> tl_class . '"' : '' ) ; $ style = ( $ widget -> style != '' ? ' style="' . $ widget -> style . '"' : '' ) ; $ help = $ this -> getHelpForWidget ( $ widget ) ; $ columns [ ] = sprintf ( '<td %1$s%2$s%3$s>%4$s%5$s</td>' , $ valign , $ class , $ style , $ widget -> parse ( ) , $ help ) ; } $ options [ ] = implode ( '' , $ columns ) ; } return $ options ; }
6116	public function serverGetByName ( $ name ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_name" ] == $ name ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
6136	public function folderSearch ( FolderSearch $ search ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/search/folder' , $ parameters ) ; $ result = new SearchResult ( $ result ) ; return $ result ; }
2612	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getAuthDictionary ( $ activeVersion ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ user = $ this -> getRequest ( ) -> getParam ( 'auth_user' ) ; $ pass = $ this -> getRequest ( ) -> getParam ( 'auth_pass' ) ; $ key = base64_encode ( $ user . ':' . $ pass ) ; $ this -> api -> upsertDictionaryItem ( $ dictionary -> id , $ key , true ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
10463	private function bindParams ( $ statement , $ params ) { foreach ( $ params as $ param ) { $ statement -> bindValue ( $ param [ 0 ] , $ param [ 1 ] , $ param [ 2 ] ) ; } }
12183	public static function getOne ( Item $ parent , Item $ child , $ options = [ ] ) { $ key = md5 ( $ parent -> systemId . "." . $ child -> systemId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { self :: $ _relationships [ $ key ] -> mergeOptions ( $ options ) ; } else { self :: $ _relationships [ $ key ] = new Relationship ( $ parent , $ child , $ options ) ; } return self :: $ _relationships [ $ key ] ; }
6273	public static function haveExtension ( ) { if ( ! function_exists ( 'dba_handlers' ) ) { return false ; } $ handlers = dba_handlers ( ) ; if ( ! in_array ( 'cdb' , $ handlers ) || ! in_array ( 'cdb_make' , $ handlers ) ) { return false ; } return true ; }
12318	protected function searchQuery ( Builder $ query , string $ phrase ) { return $ query -> where ( function ( Builder $ query ) use ( $ phrase ) { $ query -> where ( 'url' , 'LIKE' , '%' . $ phrase . '%' ) -> orWhere ( 'short_url_key' , 'LIKE' , '%' . $ phrase . '%' ) -> orWhere ( 'clicks' , 'LIKE' , '%' . $ phrase . '%' ) -> orWhere ( 'url' , 'LIKE' , '%' . $ phrase . '%' ) ; } ) ; }
3997	protected function getItem ( $ metaModelIdOrName , $ mixDataId , $ intIdRenderSetting , $ strOutput = null ) { $ objMetaModel = $ this -> loadMetaModel ( $ metaModelIdOrName ) ; if ( $ objMetaModel == null ) { return false ; } if ( empty ( $ strOutput ) ) { $ strOutput = 'html5' ; } $ objMetaModelList = new ItemList ( ) ; $ objMetaModelList -> setServiceContainer ( $ this -> getServiceContainer ( ) ) -> setMetaModel ( $ objMetaModel -> get ( 'id' ) , $ intIdRenderSetting ) -> overrideOutputFormat ( $ strOutput ) ; $ arrIds = StringUtil :: trimsplit ( ',' , $ mixDataId ) ; foreach ( $ arrIds as $ intKey => $ intId ) { if ( ! $ this -> isPublishedItem ( $ objMetaModel , $ intId ) ) { unset ( $ arrIds [ $ intKey ] ) ; } } if ( count ( $ arrIds ) < 1 ) { return '' ; } $ objMetaModelList -> addFilterRule ( new StaticIdList ( $ arrIds ) ) ; return $ objMetaModelList -> render ( false , $ this ) ; }
6267	public static function open ( $ fileName ) { return Reader :: haveExtension ( ) ? new Writer \ DBA ( $ fileName ) : new Writer \ PHP ( $ fileName ) ; }
472	public function insert ( $ table , $ columns ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> insert ( $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
11674	public function setConfigurationOptions ( array $ options = array ( ) ) { $ resolver = new OptionsResolver ( ) ; $ resolver -> setDefined ( array ( 'web_dir' , 'uploads_dir' , ) ) ; $ resolver -> resolve ( $ options ) ; if ( array_key_exists ( 'web_dir' , $ options ) ) { $ this -> webDirname = $ options [ 'web_dir' ] ; } if ( array_key_exists ( 'uploads_dir' , $ options ) ) { $ this -> absoluteUploadAssetsDir = $ options [ 'uploads_dir' ] ; } }
12510	public function buildPreview ( $ by ) { if ( ! in_array ( $ by , $ this -> previewBys , true ) ) { throw new InvalidArgumentException ( 'This preview by not exist.' ) ; } if ( empty ( $ this -> msgType ) ) { throw new RuntimeException ( 'Message type not exist.' ) ; } elseif ( $ this -> msgType === Broadcast :: MSG_TYPE_VIDEO ) { if ( is_array ( $ this -> message ) ) { $ this -> message = array_shift ( $ this -> message ) ; } $ this -> msgType = 'mpvideo' ; } if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message content to send.' ) ; } if ( empty ( $ this -> to ) ) { throw new RuntimeException ( 'No to.' ) ; } $ content = ( new Transformer ( $ this -> msgType , $ this -> message ) ) -> transform ( ) ; $ message = array_merge ( $ this -> buildTo ( $ this -> to , $ by ) , $ content ) ; return $ message ; }
6745	private function applyResponseEncoding ( Request $ request , Response $ response ) { $ allowedCompressionAsString = $ request -> headers -> get ( 'Accept-Encoding' ) ; if ( ! $ allowedCompressionAsString ) { return ; } $ allowedCompression = explode ( ',' , $ allowedCompressionAsString ) ; $ allowedCompression = array_map ( 'trim' , $ allowedCompression ) ; if ( in_array ( 'gzip' , $ allowedCompression ) ) { $ response -> setContent ( gzencode ( $ response -> getContent ( ) ) ) ; $ response -> headers -> set ( 'Content-Encoding' , 'gzip' ) ; return ; } if ( in_array ( 'deflate' , $ allowedCompression ) ) { $ response -> setContent ( gzdeflate ( $ response -> getContent ( ) ) ) ; $ response -> headers -> set ( 'Content-Encoding' , 'deflate' ) ; return ; } }
4249	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ value = null ; $ firePhpMeta = $ this -> getMeta ( $ method , $ meta ) ; if ( $ method == 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; $ value = $ args [ 0 ] ; } elseif ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ firePhpMeta [ 'Label' ] = $ args [ 0 ] ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ firePhpMeta [ 'Type' ] = \ is_array ( $ args [ 0 ] ) ? $ this -> firephpMethods [ 'table' ] : $ this -> firephpMethods [ 'log' ] ; $ value = $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ; if ( $ meta [ 'caption' ] ) { $ firePhpMeta [ 'Label' ] = $ meta [ 'caption' ] ; } } elseif ( $ method == 'trace' ) { $ firePhpMeta [ 'Type' ] = $ this -> firephpMethods [ 'table' ] ; $ value = $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ; $ firePhpMeta [ 'Label' ] = 'trace' ; } elseif ( \ count ( $ args ) ) { if ( \ count ( $ args ) == 1 ) { $ value = $ args [ 0 ] ; } else { $ firePhpMeta [ 'Label' ] = \ array_shift ( $ args ) ; $ value = \ count ( $ args ) > 1 ? $ args : $ args [ 0 ] ; } } $ value = $ this -> dump ( $ value ) ; if ( $ this -> messageIndex < self :: MESSAGE_LIMIT ) { $ this -> setFirephpHeader ( $ firePhpMeta , $ value ) ; } elseif ( $ this -> messageIndex === self :: MESSAGE_LIMIT ) { $ this -> setFirephpHeader ( array ( 'Type' => $ this -> firephpMethods [ 'warn' ] ) , 'FirePhp\'s limit of ' . \ number_format ( self :: MESSAGE_LIMIT ) . ' messages reached!' ) ; } return ; }
10091	protected function checkOptionsArray ( $ options ) { if ( isset ( $ options [ 's' ] ) ) { $ options [ 'size' ] = $ options [ 's' ] ; unset ( $ options [ 's' ] ) ; } if ( isset ( $ options [ 'd' ] ) ) { $ options [ 'default' ] = $ options [ 'd' ] ; unset ( $ options [ 'd' ] ) ; } $ allowedOptions = array ( 'algorithm' => true , 'default' => true , 'https' => true , 'size' => true , ) ; foreach ( $ options as $ key => $ value ) { if ( ! isset ( $ allowedOptions [ $ key ] ) ) { throw new InvalidArgumentException ( 'Invalid option in array: ' . $ key ) ; } } return $ options ; }
1084	private function expectKeyword ( $ value ) { $ token = $ this -> lexer -> token ; if ( $ token -> kind === Token :: NAME && $ token -> value === $ value ) { $ this -> lexer -> advance ( ) ; return $ token ; } throw new SyntaxError ( $ this -> lexer -> source , $ token -> start , 'Expected "' . $ value . '", found ' . $ token -> getDescription ( ) ) ; }
614	protected function getDependencies ( $ class ) { if ( isset ( $ this -> _reflections [ $ class ] ) ) { return [ $ this -> _reflections [ $ class ] , $ this -> _dependencies [ $ class ] ] ; } $ dependencies = [ ] ; try { $ reflection = new ReflectionClass ( $ class ) ; } catch ( \ ReflectionException $ e ) { throw new InvalidConfigException ( 'Failed to instantiate component or class "' . $ class . '".' , 0 , $ e ) ; } $ constructor = $ reflection -> getConstructor ( ) ; if ( $ constructor !== null ) { foreach ( $ constructor -> getParameters ( ) as $ param ) { if ( version_compare ( PHP_VERSION , '5.6.0' , '>=' ) && $ param -> isVariadic ( ) ) { break ; } elseif ( $ param -> isDefaultValueAvailable ( ) ) { $ dependencies [ ] = $ param -> getDefaultValue ( ) ; } else { $ c = $ param -> getClass ( ) ; $ dependencies [ ] = Instance :: of ( $ c === null ? null : $ c -> getName ( ) ) ; } } } $ this -> _reflections [ $ class ] = $ reflection ; $ this -> _dependencies [ $ class ] = $ dependencies ; return [ $ reflection , $ dependencies ] ; }
5577	public function clickImage ( $ label , $ x = 1 , $ y = 1 , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormByImage ( new SelectByLabel ( $ label ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitImage ( new SelectByLabel ( $ label ) , $ x , $ y , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
6525	public function createMessage ( array $ data = [ ] ) { $ className = $ this -> className ; if ( empty ( $ data ) ) { return $ className :: create ( ) ; } return $ className :: fromArray ( $ data ) ; }
4162	public function searchMedia ( $ lat , $ lng , $ distance = 1000 , $ minTimestamp = NULL , $ maxTimestamp = NULL ) { return $ this -> _makeCall ( 'media/search' , array ( 'lat' => $ lat , 'lng' => $ lng , 'distance' => $ distance , 'min_timestamp' => $ minTimestamp , 'max_timestamp' => $ maxTimestamp ) ) ; }
12051	protected function _createRendererException ( $ message = null , $ code = null , RootException $ previous = null , RendererInterface $ renderer = null ) { return new RendererException ( $ message , $ code , $ previous , $ renderer ) ; }
11941	public function onExecuteAction ( ExecuteActionEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ position = 1 ; foreach ( $ request -> getConfig ( ) -> getArray ( 'argument' ) as $ argument ) { $ this -> validateArgument ( $ request , $ argument , $ position ++ ) ; } }
5487	public function submitImage ( SelectorInterface $ selector , $ x , $ y , $ additional = false ) { $ additional = $ additional ? $ additional : array ( ) ; foreach ( $ this -> images as $ image ) { if ( $ selector -> isMatch ( $ image ) ) { $ encoding = $ this -> encode ( ) ; $ image -> write ( $ encoding , $ x , $ y ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; } } return false ; }
2456	public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( \ is_array ( $ ids ) && \ strlen ( $ ids [ 0 ] ) ) { foreach ( $ ids as $ id ) { $ this -> intId = $ id ; $ this -> delete ( true ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
8168	public function outdent ( $ step = 1 ) { if ( $ this -> indentation < $ step ) { throw new LogicException ( 'Unable to call outdent() as the indentation would become negative.' ) ; } $ this -> indentation -= $ step ; return $ this ; }
2392	public function getAllowedCalendars ( ) { if ( $ this -> User -> isAdmin ) { $ objCalendar = Contao \ CalendarModel :: findAll ( ) ; } else { $ objCalendar = Contao \ CalendarModel :: findMultipleByIds ( $ this -> User -> calendars ) ; } $ return = array ( ) ; if ( $ objCalendar !== null ) { while ( $ objCalendar -> next ( ) ) { $ return [ $ objCalendar -> id ] = $ objCalendar -> title ; } } return $ return ; }
5042	public function setListener ( $ listener ) { $ listener -> getSharedManager ( ) -> attach ( '*' , NotificationEvent :: EVENT_NOTIFICATION_HTML , array ( $ this , 'createOutput' ) , 1 ) ; $ this -> notificationListener = $ listener ; }
12793	public function create ( $ params = array ( ) ) { $ serverConfig = array_merge ( $ this -> defaults , $ params ) ; try { $ response = $ this -> client -> request -> post ( $ this -> apiEndpoint . "/droplets" , [ 'json' => $ serverConfig ] ) ; if ( 202 != $ this -> client -> getStatus ( $ response ) ) { throw new Exception ( 'Unable to create server.' ) ; } } catch ( Exception $ e ) { echo 'Unable to create server because ' . $ e -> getMessage ( ) ; } return $ this -> client -> getBody ( $ response ) ; }
8329	public function whereExists ( Closure $ callback , $ boolean = 'and' , $ not = false ) { $ type = $ not ? 'NotExists' : 'Exists' ; $ this -> wheres [ ] = compact ( 'type' , 'callback' , 'boolean' ) ; return $ this ; }
6451	public function isLoggedIn ( ) { $ cookieName = session_name ( ) ; $ cookie = $ this -> getSession ( ) -> getCookie ( $ cookieName ) ; if ( null !== $ cookie ) { $ this -> getSession ( 'goutte' ) -> setCookie ( $ cookieName , $ cookie ) ; return true ; } return false ; }
3908	public function setAcceptedExtensions ( $ acceptedExtensions ) { $ allowedDownload = StringUtil :: trimsplit ( ',' , $ GLOBALS [ 'TL_CONFIG' ] [ 'allowedDownload' ] ) ; if ( ! is_array ( $ acceptedExtensions ) ) { $ acceptedExtensions = StringUtil :: trimsplit ( ',' , $ acceptedExtensions ) ; } $ this -> acceptedExtensions = array_map ( 'strtolower' , array_intersect ( $ allowedDownload , $ acceptedExtensions ) ) ; }
4060	public static function compare ( $ expected , $ actual , $ strict = true ) { try { self :: calculateDiff ( $ expected , $ actual , $ strict ) ; } catch ( \ Exception $ exception ) { $ instance = new DifferentValuesException ( $ expected , $ actual , $ strict , 'The values differ.' , 0 , $ exception ) ; throw $ instance ; } }
9715	private function writeNumberFormat ( $ format , $ ifmt ) { $ record = 0x041E ; $ numberFormatString = StringHelper :: UTF8toBIFF8UnicodeLong ( $ format ) ; $ length = 2 + strlen ( $ numberFormatString ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ ifmt ) . $ numberFormatString ; $ this -> append ( $ header . $ data ) ; }
11557	protected function detectNamespace ( $ settings ) { foreach ( $ this -> options -> getNamespaces ( ) as $ namespaceOptions ) { $ namespaceEntityClass = $ namespaceOptions -> getEntityClass ( ) ; if ( $ settings instanceof $ namespaceEntityClass ) { return $ namespaceOptions -> getName ( ) ; } } throw new Exception \ InvalidArgumentException ( 'Unknown Settings namespace' ) ; }
1927	public function isSemitransparent ( ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return false ; } $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ alpha = ( imagecolorat ( $ this -> gdResource , $ x , $ y ) >> 24 ) & 0x7F ; if ( $ alpha > 0 && $ alpha < 127 ) { return true ; } } } return false ; }
9707	private function writeDefinedNameBiff8 ( $ name , $ formulaData , $ sheetIndex = 0 , $ isBuiltIn = false ) { $ record = 0x0018 ; $ options = $ isBuiltIn ? 0x20 : 0x00 ; $ nlen = StringHelper :: countCharacters ( $ name ) ; $ name = substr ( StringHelper :: UTF8toBIFF8UnicodeLong ( $ name ) , 2 ) ; $ sz = strlen ( $ formulaData ) ; $ data = pack ( 'vCCvvvCCCC' , $ options , 0 , $ nlen , $ sz , 0 , $ sheetIndex , 0 , 0 , 0 , 0 ) . $ name . $ formulaData ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
7266	public static function find ( $ id , $ idColumn = null ) { $ tableName = static :: tableName ( ) ; $ idColumn = $ idColumn ? : static :: $ idColumn ; $ rows = Db :: query ( " select * from $tableName where $idColumn = :id " , [ "id" => $ id ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ model = new static ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ model -> $ col = $ model -> decodeValue ( $ val , $ col ) ; return $ model ; }
1753	public static function getCountries ( ) { $ return = array ( ) ; $ countries = array ( ) ; $ arrAux = array ( ) ; static :: loadLanguageFile ( 'countries' ) ; include __DIR__ . '/../../config/countries.php' ; foreach ( $ countries as $ strKey => $ strName ) { $ arrAux [ $ strKey ] = isset ( $ GLOBALS [ 'TL_LANG' ] [ 'CNT' ] [ $ strKey ] ) ? Utf8 :: toAscii ( $ GLOBALS [ 'TL_LANG' ] [ 'CNT' ] [ $ strKey ] ) : $ strName ; } asort ( $ arrAux ) ; foreach ( array_keys ( $ arrAux ) as $ strKey ) { $ return [ $ strKey ] = $ GLOBALS [ 'TL_LANG' ] [ 'CNT' ] [ $ strKey ] ?? $ countries [ $ strKey ] ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getCountries' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getCountries' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getCountries' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ return , $ countries ) ; } } return $ return ; }
6370	public static function forMap ( array $ map ) : callable { return function ( $ index ) use ( $ map ) { Preconditions :: checkArgument ( array_key_exists ( $ index , $ map ) , "The given key '%s' does not exist in the map" , $ index ) ; return $ map [ $ index ] ; } ; }
1478	public function delete ( $ resourceType , $ id , array $ queryParams = [ ] ) { return $ this -> resource ( RouteName :: delete ( $ resourceType ) , $ id , $ queryParams ) ; }
9286	public function create ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ CreateTable ( ) ; $ ddl -> setTable ( self :: TABLE_NAME ) -> addColumn ( new Column \ Integer ( 'id' , false , null , array ( 'autoincrement' => true ) ) ) -> addColumn ( new Column \ Varchar ( 'code' , 55 ) ) -> addColumn ( new Column \ Varchar ( 'status' , 55 ) ) -> addColumn ( new Column \ Text ( 'error_msg' ) ) -> addColumn ( new Column \ Text ( 'stack_trace' ) ) -> addColumn ( new Column \ Varchar ( 'created' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'scheduled' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'executed' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'finished' , 255 ) ) -> addConstraint ( new Constraint \ PrimaryKey ( 'id' ) ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
4971	public static function convert ( ContentItemInterface $ from , ContentItemInterface $ to ) { $ reflectionFrom = new \ ReflectionClass ( $ from ) ; $ reflectionTo = new \ ReflectionClass ( $ to ) ; foreach ( $ reflectionFrom -> getProperties ( ) as $ property ) { $ property -> setAccessible ( true ) ; $ method = 'set' . ucfirst ( $ property -> getName ( ) ) ; if ( $ reflectionTo -> hasMethod ( $ method ) ) { $ to -> $ method ( $ property -> getValue ( $ from ) ) ; } } return $ to ; }
9392	protected function skipRowsClause ( ) { $ skipClause = [ ] ; foreach ( $ this -> skipRows as $ cl => $ val ) { $ skipClause [ ] = [ '<>' , $ cl , $ val ] ; } if ( count ( $ skipClause ) > 1 ) array_unshift ( $ skipClause , 'and' ) ; return $ skipClause ; }
11560	public function SetShortcuts ( array $ shortcuts , $ lang = '' ) { if ( ! $ lang ) $ lang = $ this -> lang ; $ this -> shortcuts [ $ lang ] = $ shortcuts ; return $ this ; }
12674	public function getForeignModelConfig ( $ sourceFile , $ modelName ) { $ config = [ 'class' => Model :: className ( ) ] ; if ( isset ( $ this -> foreignModelsConfig [ $ modelName ] ) ) { $ config = array_merge ( $ config , $ this -> foreignModelsConfig [ $ modelName ] ) ; } $ config [ 'modelName' ] = $ modelName ; $ config [ 'sourceFile' ] = $ sourceFile ; $ config [ 'interface' ] = $ this ; return $ config ; }
4077	protected function getPaletteCombinationRows ( ) { $ combinations = $ this -> getCombinationsFromDatabase ( ) ; $ success = array ( ) ; if ( ! $ combinations ) { return array_keys ( $ this -> information ) ; } foreach ( $ combinations as $ combination ) { $ modelId = $ combination -> pid ; $ modelName = $ this -> tableNameFromId ( $ modelId ) ; if ( ! empty ( $ this -> information [ $ modelName ] [ self :: COMBINATION ] ) ) { continue ; } $ this -> information [ $ modelName ] [ self :: MODELID ] = $ modelId ; $ this -> information [ $ modelName ] [ self :: COMBINATION ] = array ( 'dca_id' => $ combination -> dca_id , 'view_id' => $ combination -> view_id ) ; $ this -> setTableMapping ( $ modelId , $ modelName ) ; $ success [ ] = $ modelId ; } return $ success ; }
3200	protected function binaryPopCount ( $ value ) { $ value -= ( ( $ value >> 1 ) & 0x55555555 ) ; $ value = ( ( ( $ value >> 2 ) & 0x33333333 ) + ( $ value & 0x33333333 ) ) ; $ value = ( ( ( $ value >> 4 ) + $ value ) & 0x0f0f0f0f ) ; $ value += ( $ value >> 8 ) ; $ value += ( $ value >> 16 ) ; return $ value & 0x0000003f ; }
4851	protected function applyId ( & $ row , $ id , $ identifierField ) { $ ids = ( array ) $ id ; $ findId = function ( $ row ) use ( $ ids , $ identifierField ) { foreach ( $ ids as $ id ) { $ bool = true ; $ identifierField = $ this -> flatten ( $ identifierField ) ; foreach ( $ identifierField as $ identifier ) { $ bool = $ bool && ( mb_strtolower ( $ id [ $ identifier ] ) === mb_strtolower ( $ row [ $ identifier ] ) ) ; } if ( $ bool ) { return $ id [ 'id' ] ; } } return 0 ; } ; $ isDeep = $ this -> isDeep ( $ row ) ; if ( $ isDeep ) { foreach ( $ row as $ i => & $ r ) { $ r [ 'id' ] = $ findId ( $ r ) ; } } else { $ row [ 'id' ] = $ findId ( $ row ) ; } }
5439	public function addPattern ( $ pattern , $ mode = 'accept' ) { if ( ! isset ( $ this -> regexes [ $ mode ] ) ) { $ this -> regexes [ $ mode ] = new ParallelRegex ( $ this -> case ) ; } $ this -> regexes [ $ mode ] -> addPattern ( $ pattern ) ; if ( ! isset ( $ this -> mode_handlers [ $ mode ] ) ) { $ this -> mode_handlers [ $ mode ] = $ mode ; } }
9133	public function route ( string $ name , Request $ request ) { $ parts = \ explode ( '/' , $ request -> getOrigin ( ) ) ; $ found = false ; for ( $ i = 0 ; $ i < count ( $ parts ) ; $ i ++ ) { if ( $ parts [ $ i ] === $ name && isset ( $ parts [ $ i + 1 ] ) ) { $ action = $ parts [ $ i + 1 ] ; if ( strpos ( $ action , "?" ) ) { $ action = strstr ( $ action , "?" , true ) ; } $ request -> setAction ( $ action ) ; $ found = true ; } } if ( ! $ found ) { $ request -> setAction ( "index" ) ; } $ controller = $ this -> getRoute ( $ name ) ; $ request -> setController ( $ controller -> getControllerSimpleName ( ) ) ; return $ controller ; }
12574	public function previewCard ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_CARD , $ message , $ to , $ by ) ; }
7888	public function logs ( ) { $ logs = array_reverse ( $ this -> filesystem -> files ( ) ) ; foreach ( $ logs as $ index => $ file ) { $ logs [ $ index ] = preg_replace ( '/.*(\d{4}-\d{2}-\d{2}).*/' , '$1' , basename ( $ file ) ) ; } return $ logs ; }
8535	public function setId ( $ id ) { if ( ! $ this -> isNumericArray ( $ id ) ) { $ id = array ( $ id ) ; } $ this -> fields [ 'Id' ] [ 'FieldValue' ] = $ id ; return $ this ; }
1976	public static function findMultipleFoldersByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='folder' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; }
10973	public static function getAuthPassword ( ) { $ result = null ; if ( isset ( $ _SERVER [ 'PHP_AUTH_PW' ] ) ) { $ result = $ _SERVER [ 'PHP_AUTH_PW' ] ; } if ( trim ( $ result ) == '' ) { $ result = null ; } return $ result ; }
5004	protected function createEventManager ( $ services , $ config ) { if ( $ services -> has ( $ config [ 'service' ] ) ) { $ events = $ services -> get ( $ config [ 'service' ] ) ; } else { if ( ! class_exists ( $ config [ 'service' ] , true ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Class or service %s does not exists. Cannot create event manager instance.' , $ config [ 'service' ] ) ) ; } $ events = new $ config [ 'service' ] ( ) ; } if ( false === $ config [ 'configure' ] ) { return $ events ; } $ events -> setIdentifiers ( $ config [ 'identifiers' ] ) ; $ event = $ services -> has ( $ config [ 'event' ] ) ? $ services -> get ( $ config [ 'event' ] ) : new $ config [ 'event' ] ( ) ; $ events -> setEventPrototype ( $ event ) ; if ( 'EventManager' != $ config [ 'service' ] && method_exists ( $ events , 'setSharedManager' ) && $ services -> has ( 'SharedEventManager' ) ) { $ sharedEvents = $ services -> get ( 'SharedEventManager' ) ; $ events -> setSharedManager ( $ sharedEvents ) ; } return $ events ; }
5058	public function generate ( $ subject , $ status , $ color , $ format ) { $ badge = new Badge ( $ subject , $ status , $ color , $ format ) ; return $ this -> getRenderFor ( $ badge -> getFormat ( ) ) -> render ( $ badge ) ; }
6229	public function available ( ) { return $ this -> core -> api ( ) -> response ( $ this -> makeContainer ( $ this -> core -> modules ( ) -> getAllPermissions ( ) ) ) ; }
2243	public static function getForm ( $ varId , $ strColumn = 'main' , $ blnModule = false ) { if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( $ varId == '' ) { return '' ; } $ objRow = FormModel :: findByIdOrAlias ( $ varId ) ; if ( $ objRow === null ) { return '' ; } } $ strClass = $ blnModule ? Module :: findClass ( 'form' ) : ContentElement :: findClass ( 'form' ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Form class "' . $ strClass . '" does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = $ blnModule ? 'mod_' : 'ce_' ; $ objRow -> form = $ objRow -> id ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } return $ strBuffer ; }
50	protected function pushEvent ( Event $ event ) { $ eventName = $ event -> getName ( ) ; if ( in_array ( $ eventName , $ this -> eventStack ) ) { throw new \ RuntimeException ( sprintf ( "Circular call to script handler '%s' detected" , $ eventName ) ) ; } return array_push ( $ this -> eventStack , $ eventName ) ; }
1107	protected function writeModel ( $ name ) { $ output = pathinfo ( $ this -> modeler -> create ( $ name , $ this -> getModelsPath ( ) ) , PATHINFO_FILENAME ) ; $ this -> line ( " <fg=green;options=bold>create</fg=green;options=bold> $output" ) ; }
11334	public function getFormattedValue ( ) { if ( $ this -> format instanceof BaseFormat ) { $ formattedValue = $ this -> format -> get ( ) ; } elseif ( is_callable ( $ this -> format ) || ( is_array ( $ this -> format ) && ! empty ( $ this -> format [ 0 ] ) && is_object ( $ this -> format [ 0 ] ) ) ) { $ formattedValue = $ this -> evaluateExpression ( $ this -> format , [ $ this -> value ] ) ; } else { $ formattedValue = $ this -> value ; } if ( is_object ( $ formattedValue ) ) { $ formattedValue = $ formattedValue -> viewLink ; } return $ formattedValue ; }
11679	protected function log ( $ message , $ priority = Logger :: DEBUG , array $ extra = [ ] ) { if ( $ this -> getLogger ( ) === null ) { return $ this ; } $ this -> getLogger ( ) -> log ( $ priority , $ message , $ extra ) ; return $ this ; }
4210	private function phpDocParam ( $ param , $ className ) { $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( \ array_key_exists ( 'defaultValue' , $ param ) ) { $ defaultValue = $ param [ 'defaultValue' ] ; if ( \ in_array ( $ defaultValue , array ( 'true' , 'false' , 'null' ) ) ) { $ defaultValue = \ json_decode ( $ defaultValue ) ; } elseif ( \ is_numeric ( $ defaultValue ) ) { $ defaultValue = $ defaultValue * 1 ; } elseif ( \ preg_match ( '/^array\(\s*\)|\[\s*\]$/i' , $ defaultValue ) ) { $ defaultValue = array ( ) ; } elseif ( \ preg_match ( '/^(self::)?([^\(\)\[\]]+)$/i' , $ defaultValue , $ matches ) ) { if ( $ matches [ 1 ] ) { if ( \ defined ( $ className . '::' . $ matches [ 2 ] ) ) { $ constantName = $ matches [ 0 ] ; $ defaultValue = \ constant ( $ className . '::' . $ matches [ 2 ] ) ; } } elseif ( \ defined ( $ defaultValue ) ) { $ constantName = $ defaultValue ; $ defaultValue = \ constant ( $ defaultValue ) ; } } else { $ defaultValue = \ trim ( $ defaultValue , '\'"' ) ; } } return array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , ) ; }
6263	public function nextkey ( ) { if ( $ this -> keys === null ) { return $ this -> firstkey ( ) ; } return empty ( $ this -> keys ) ? false : array_shift ( $ this -> keys ) ; }
7446	public function updateAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } $ form = $ this -> createForm ( GroupType :: class , $ group ) ; $ form -> bindRequest ( $ this -> getRequest ( ) ) ; if ( $ form -> isValid ( ) ) { $ em -> persist ( $ group ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_group_show' , array ( 'id' => $ id ) ) ) ; } return array ( 'group' => $ group , 'form' => $ form -> createView ( ) , ) ; }
1429	protected function fillSoftDelete ( Model $ record , $ field , $ value ) { $ value = $ this -> deserializeSoftDelete ( $ value , $ field , $ record ) ; $ record -> forceFill ( [ $ this -> getSoftDeleteKey ( $ record ) => $ value , ] ) ; }
536	protected function cleanDocComment ( $ doc ) { $ lines = explode ( "\n" , $ doc ) ; $ n = \ count ( $ lines ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ lines [ $ i ] = rtrim ( $ lines [ $ i ] ) ; if ( trim ( $ lines [ $ i ] ) == '*' && trim ( $ lines [ $ i + 1 ] ) == '*' ) { unset ( $ lines [ $ i ] ) ; } } return implode ( "\n" , $ lines ) ; }
5618	public function paintHeader ( $ test_name ) { $ this -> sendNoCacheHeaders ( ) ; echo sprintf ( SIMPLETEST_WEBUNIT_HEAD , $ test_name , $ this -> path . 'js/' , $ this -> path . 'js/' , $ this -> path . 'css/' , $ this -> _getCss ( ) , $ test_name , $ this -> path . 'img/' ) ; flush ( ) ; }
6867	protected function getSaleFromInvoice ( InvoiceInterface $ invoice ) { if ( null === $ sale = $ invoice -> getSale ( ) ) { $ cs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , $ this -> getSalePropertyPath ( ) ) ; if ( ! empty ( $ cs ) ) { $ sale = $ cs [ 0 ] ; } } if ( ! $ sale instanceof SaleInterface ) { throw new Exception \ RuntimeException ( "Failed to retrieve invoice's sale." ) ; } return $ sale ; }
1267	private function createRequest ( $ labelRecoveryRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LabelRecoveryRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LabelRecovery' ) ) ; $ labelSpecificationNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'LabelSpecification' ) ) ; if ( isset ( $ labelRecoveryRequest -> LabelSpecification ) ) { $ labelSpecificationNode -> appendChild ( $ xml -> createElement ( 'HTTPUserAgent' , $ labelRecoveryRequest -> LabelSpecification -> HTTPUserAgent ) ) ; $ labelImageFormatNode = $ labelSpecificationNode -> appendChild ( $ xml -> createElement ( 'LabelImageFormat' ) ) ; $ labelImageFormatNode -> appendChild ( $ xml -> createElement ( 'Code' , $ labelRecoveryRequest -> LabelSpecification -> LabelImageFormat -> Code ) ) ; } if ( isset ( $ labelRecoveryRequest -> Translate ) ) { $ translateNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Translate' ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'LanguageCode' , $ labelRecoveryRequest -> Translate -> LanguageCode ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'DialectCode' , $ labelRecoveryRequest -> Translate -> DialectCode ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'Code' , $ labelRecoveryRequest -> Translate -> Code ) ) ; } if ( isset ( $ labelRecoveryRequest -> LabelLinkIndicator ) ) { $ labelLinkIndicatorNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' ) ) ; $ labelLinkIndicatorNode -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' ) ) ; } if ( isset ( $ labelRecoveryRequest -> TrackingNumber ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ labelRecoveryRequest -> TrackingNumber ) ) ; } if ( isset ( $ labelRecoveryRequest -> ReferenceNumber ) ) { $ referenceNumberNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) ; $ referenceNumberNode -> appendChild ( $ xml -> createElement ( 'Value' , $ labelRecoveryRequest -> ReferenceNumber -> getValue ( ) ) ) ; } if ( isset ( $ labelRecoveryRequest -> ShipperNumber ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ labelRecoveryRequest -> ShipperNumber ) ) ; } return $ xml -> saveXML ( ) ; }
10858	public function eachMarked ( callable $ callback , $ result = null ) { $ ref = new \ ReflectionFunction ( $ callback ) ; $ params = $ ref -> getParameters ( ) ; if ( \ count ( $ params ) < 2 ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Callback for marker processing must declare at least 2 arguments (object and marker)' ) ) ; } try { $ markerType = $ params [ 1 ] -> getClass ( ) ; } catch ( \ ReflectionException $ e ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker class not found: %s' , $ params [ 1 ] -> getType ( ) ) , 0 , $ e ) ; } if ( $ markerType === null ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Argument #2 of marker callback needs to declare a type-hint for the marker' ) ) ; } $ marker = $ markerType -> getName ( ) ; if ( ! $ markerType -> isSubclassOf ( Marker :: class ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker implementation %s must extend %s' , $ marker , Marker :: class ) ) ; } if ( ! isset ( $ this -> marked [ $ marker ] ) ) { $ this -> cacheMarkers ( $ marker ) ; } foreach ( $ this -> marked [ $ marker ] as list ( $ definition , $ registration ) ) { $ result = $ callback ( $ this -> shared [ $ definition -> typeName ] ?? $ this -> get ( $ definition -> typeName ) , clone $ registration , $ result ) ; } return $ result ; }
6672	public function restart_all_ratings ( ) { $ nonce = isset ( $ _POST [ 'nonce' ] ) ? $ _POST [ 'nonce' ] : '' ; if ( ! wp_verify_nonce ( $ nonce , 'eliasis' ) && ! wp_verify_nonce ( $ nonce , 'customRatingGrifusAdmin' ) ) { die ( 'Busted!' ) ; } $ response [ 'ratings_restarted' ] = 0 ; $ posts = $ this -> model -> get_posts ( ) ; foreach ( $ posts as $ post ) { if ( isset ( $ post -> ID ) && ! $ this -> model -> get_movie_votes ( $ post -> ID ) ) { $ this -> set_rating_and_votes ( $ post -> ID , $ this -> get_default_votes ( $ post -> ID ) ) ; $ response [ 'ratings_restarted' ] ++ ; } } echo json_encode ( $ response ) ; die ( ) ; }
850	public function getTokenOfKindSibling ( $ index , $ direction , array $ tokens = [ ] , $ caseSensitive = true ) { if ( ! self :: isLegacyMode ( ) ) { $ tokens = array_filter ( $ tokens , function ( $ token ) { return $ this -> isTokenKindFound ( $ this -> extractTokenKind ( $ token ) ) ; } ) ; } if ( ! \ count ( $ tokens ) ) { return null ; } while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( $ token -> equalsAny ( $ tokens , $ caseSensitive ) ) { return $ index ; } } }
1502	public function acceptable ( AcceptHeaderInterface $ accept ) : ? Encoding { foreach ( $ accept -> getMediaTypes ( ) as $ mediaType ) { if ( $ encoding = $ this -> matchesTo ( $ mediaType ) ) { return $ encoding ; } } return null ; }
1674	public function synchronize ( ) { if ( ! $ this -> isUnsynchronized ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot synchronize the folder "%s" because one of its parent folders is unsynchronized' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.nosync' ) ) -> delete ( ) ; }
4954	public function initialize ( $ instance , ServiceLocatorInterface $ serviceLocator ) { if ( ! $ instance instanceof HeadscriptProviderInterface ) { return ; } $ scripts = $ instance -> getHeadscripts ( ) ; if ( ! is_array ( $ scripts ) || empty ( $ scripts ) ) { return ; } $ services = $ serviceLocator ; $ helpers = $ services -> get ( 'ViewHelperManager' ) ; $ basepath = $ helpers -> get ( 'basepath' ) ; $ headscript = $ helpers -> get ( 'headscript' ) ; foreach ( $ scripts as $ script ) { $ headscript -> appendFile ( $ basepath ( $ script ) ) ; } }
12248	public function xpathSingle ( $ strXpathQuery ) { $ arrResults = $ this -> xpath ( $ strXpathQuery ) ; if ( $ arrResults === false ) { return null ; } if ( is_array ( $ arrResults ) && count ( $ arrResults ) == 0 ) { return null ; } else { if ( count ( $ arrResults ) > 1 ) { throw new Exception ( 'xpathSingle expects a single element as result, got ' . count ( $ arrResults ) . ' elements instead.' ) ; } else { return current ( $ arrResults ) ; } } }
2192	public function isRegisteredAlias ( Model $ objModel , $ strAlias , $ varValue ) { $ strTable = $ objModel -> getTable ( ) ; return isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ; }
6009	public function setDeleted ( $ deleted ) { if ( $ deleted instanceof DateTime ) { $ this -> deleted = $ deleted ; } else { try { $ this -> deleted = new DateTime ( $ deleted ) ; } catch ( \ Exception $ e ) { $ this -> deleted = null ; } } return $ this ; }
1521	public function processes ( StoreInterface $ store , FetchProcesses $ request ) { $ result = $ store -> queryRecords ( $ request -> getProcessType ( ) , $ request -> getEncodingParameters ( ) ) ; return $ this -> reply ( ) -> content ( $ result ) ; }
3191	public function timeout ( $ timeLimit , $ tags , $ target ) { $ duration = $ this -> compute ( $ tags , $ target ) ; return $ duration >= $ timeLimit ; }
10618	public function steptwo ( ) { $ input = Input :: only ( array ( 'name' , 'email' , 'comment' , 'to_email' , 'to_name' ) ) ; $ input [ 'name' ] = $ this -> quickSanitize ( $ input [ 'name' ] ) ; $ input [ 'email' ] = $ this -> quickSanitize ( $ input [ 'email' ] ) ; $ input [ 'comment' ] = $ this -> quickSanitize ( $ input [ 'comment' ] ) ; return view ( 'lasallecmscontact::step_two_form' , [ 'input' => $ input , 'message' => false , ] ) ; }
989	public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } $ charge = Charge :: firstOrNew ( [ 'charge_id' => $ this -> chargeId , 'shop_id' => $ this -> shop -> id , ] ) ; $ charge -> plan_id = $ this -> plan -> id ; $ charge -> type = $ this -> plan -> type ; $ charge -> status = $ this -> response -> status ; if ( $ this -> plan -> isType ( Plan :: PLAN_RECURRING ) ) { $ charge -> billing_on = $ this -> response -> billing_on ; $ charge -> trial_ends_on = $ this -> response -> trial_ends_on ; } $ charge -> activated_on = $ this -> response -> activated_on ?? Carbon :: today ( ) -> format ( 'Y-m-d' ) ; $ planDetails = $ this -> chargeParams ( ) ; unset ( $ planDetails [ 'return_url' ] ) ; foreach ( $ planDetails as $ key => $ value ) { $ charge -> { $ key } = $ value ; } return $ charge -> save ( ) ; }
6833	public function userHasRight ( array $ user , $ right ) { $ hasRight = false ; if ( isset ( $ user [ 'role' ] ) && ! empty ( $ right ) && isset ( $ this -> _rightsConfig [ $ right ] ) ) { if ( in_array ( $ user [ 'role' ] , $ this -> _rightsConfig [ $ right ] ) ) { $ hasRight = true ; } } return $ hasRight ; }
8069	public function bind ( $ username , $ password ) { if ( $ this -> tls ) { if ( ! ldap_start_tls ( $ this -> connection ) ) { throw new ConnectionException ( 'Unable to Connect to LDAP using TLS.' ) ; } } try { $ this -> bound = ldap_bind ( $ this -> connection , $ username , $ password ) ; } catch ( ErrorException $ e ) { $ this -> bound = false ; } return $ this -> bound ; }
5070	protected function determineHeaderTags ( $ topLevel , $ depth ) { $ desired = range ( ( int ) $ topLevel , ( int ) $ topLevel + ( ( int ) $ depth - 1 ) ) ; $ allowed = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; return array_map ( function ( $ val ) { return 'h' . $ val ; } , array_intersect ( $ desired , $ allowed ) ) ; }
7260	protected function createPercentAdjustment ( Model \ AdjustmentInterface $ data , float $ base , string $ currency ) : Adjustment { $ this -> assertAdjustmentMode ( $ data , Model \ AdjustmentModes :: MODE_PERCENT ) ; $ rate = ( float ) $ data -> getAmount ( ) ; if ( $ data -> getType ( ) === Model \ AdjustmentTypes :: TYPE_TAXATION ) { $ amount = Money :: round ( $ base * ( 1 + $ rate / 100 ) , $ currency ) - Money :: round ( $ base , $ currency ) ; } else { $ amount = Money :: round ( $ base * $ rate / 100 , $ currency ) ; } return new Adjustment ( ( string ) $ data -> getDesignation ( ) , $ amount , $ rate ) ; }
7934	public function alreadyLoaded ( $ name ) { foreach ( $ this -> loaded as $ item ) { if ( $ item [ 'name' ] === $ name ) { return true ; } } return false ; }
872	private static function wordwrap ( $ string , $ width ) { $ result = [ ] ; $ currentLine = 0 ; $ lineLength = 0 ; foreach ( explode ( ' ' , $ string ) as $ word ) { $ wordLength = \ strlen ( Preg :: replace ( '~</?(\w+)>~' , '' , $ word ) ) ; if ( 0 !== $ lineLength ) { ++ $ wordLength ; } if ( $ lineLength + $ wordLength > $ width ) { ++ $ currentLine ; $ lineLength = 0 ; } $ result [ $ currentLine ] [ ] = $ word ; $ lineLength += $ wordLength ; } return array_map ( static function ( $ line ) { return implode ( ' ' , $ line ) ; } , $ result ) ; }
9379	protected function parse ( $ httpMethod , $ uri , $ route ) { $ matched = preg_match ( $ route [ 4 ] , $ uri , $ parameters ) ; if ( $ matched && ( $ httpMethod == $ route [ 0 ] || $ httpMethod == 'OPTIONS' ) ) { $ this -> allowed ( $ route [ 0 ] ) ; array_shift ( $ parameters ) ; return array ( $ route [ 2 ] , $ parameters , $ route [ 3 ] , $ route [ 5 ] ) ; } return null ; }
6005	public function addCategoryResponse ( $ item ) { if ( ! ( $ item instanceof CategoryResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new CategoryResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate CategoryResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "CategoryResponse"!' , E_USER_WARNING ) ; } } $ this -> categories [ ] = $ item ; return $ this ; }
6327	private function getConstraintsSql ( ) { $ sql = '' ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { $ sql .= ',' ; if ( $ constraint instanceof PrimaryKey ) { $ sql .= ( string ) $ constraint ; } elseif ( $ constraint instanceof ForeignKey ) { $ sql .= sprintf ( 'CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s (%s) MATCH SIMPLE ON UPDATE %s ON DELETE %s' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) , $ constraint -> getReferencedTable ( ) -> getQualifiedName ( ) , implode ( ',' , $ constraint -> getReferencedColumns ( ) ) , $ constraint -> getUpdateAction ( ) , $ constraint -> getDeleteAction ( ) ) ; } elseif ( $ constraint instanceof Unique ) { $ sql .= sprintf ( 'CONSTRAINT %s UNIQUE (%s)' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) ) ; } } return rtrim ( $ sql , ',' ) ; }
5393	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'fail>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "fail>\n" ; }
1633	protected function fireLogEvent ( $ level , $ message , array $ context = [ ] ) { if ( ! isset ( $ this -> dispatcher ) ) { return ; } if ( class_exists ( MessageLogged :: class ) ) { $ this -> dispatcher -> dispatch ( new MessageLogged ( $ level , $ message , $ context ) ) ; } else { $ this -> dispatcher -> fire ( 'illuminate.log' , compact ( 'level' , 'message' , 'context' ) ) ; } }
9587	protected function getAttribute ( SimpleXmlElement $ node , $ name ) { $ attributes = $ node -> attributes ( ) ; return ( string ) $ attributes [ $ name ] ; }
1442	protected function replaceRecord ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'DummyRecord' , Str :: classify ( str_singular ( $ resource ) ) , $ stub ) ; return $ this ; }
11277	protected function getStubs ( ? string $ table = null , bool $ create = false ) : iterable { if ( is_null ( $ table ) ) { yield M :: TYPE_UP => $ this -> stubs -> read ( 'blank.sql.stub' ) ; yield M :: TYPE_DOWN => $ this -> stubs -> read ( 'blank.sql.stub' ) ; return ; } $ first = [ M :: TYPE_UP => 'create.sql.stub' , M :: TYPE_DOWN => 'down.sql.stub' ] ; $ second = [ M :: TYPE_UP => 'update.sql.stub' , M :: TYPE_DOWN => 'update.sql.stub' ] ; $ stubs = $ create ? $ first : $ second ; foreach ( $ stubs as $ type => $ stub ) { yield $ type => $ this -> stubs -> read ( $ stub ) ; } }
1710	public function onReplaceInsertTags ( string $ tag , bool $ useCache , $ cacheValue , array $ flags ) { static $ supportedTags = [ 'faq' , 'faq_open' , 'faq_url' , 'faq_title' , ] ; $ elements = explode ( '::' , $ tag ) ; $ key = strtolower ( $ elements [ 0 ] ) ; if ( ! \ in_array ( $ key , $ supportedTags , true ) ) { return false ; } $ this -> framework -> initialize ( ) ; $ adapter = $ this -> framework -> getAdapter ( FaqModel :: class ) ; $ faq = $ adapter -> findByIdOrAlias ( $ elements [ 1 ] ) ; if ( null === $ faq || false === ( $ url = $ this -> generateUrl ( $ faq , \ in_array ( 'absolute' , $ flags , true ) ) ) ) { return '' ; } return $ this -> generateReplacement ( $ faq , $ key , $ url ) ; }
10466	public function onModify ( ItemPipelineEvent $ event ) { $ item = $ event -> getItem ( ) ; if ( $ item instanceof ImportItem ) { $ this -> modify ( $ item , $ event ) ; } elseif ( $ item instanceof SyncExecuteItem ) { $ syncStorageData = $ item -> getSyncStorageData ( ) ; if ( $ syncStorageData [ 'type' ] !== ActionTypes :: DELETE ) { $ this -> modify ( $ item , $ event ) ; } else { ItemSkipper :: skip ( $ event , 'Delete item with id = ' . $ syncStorageData [ 'id' ] ) ; } } else { $ this -> log ( 'The type of provided item is not ImportItem or SyncExecuteItem.' , LogLevel :: ERROR ) ; } }
1555	protected function queryValidatorWithoutSearch ( ) { return $ this -> validatorFactory ( ) -> queryParameters ( $ this -> queryRulesWithoutSearch ( ) , $ this -> queryMessages ( ) , $ this -> queryCustomAttributes ( ) , function ( Validator $ validator ) { return $ this -> conditionalQuery ( $ validator ) ; } ) ; }
598	public function joinWith ( $ with , $ eagerLoading = true , $ joinType = 'LEFT JOIN' ) { $ relations = [ ] ; foreach ( ( array ) $ with as $ name => $ callback ) { if ( is_int ( $ name ) ) { $ name = $ callback ; $ callback = null ; } if ( preg_match ( '/^(.*?)(?:\s+AS\s+|\s+)(\w+)$/i' , $ name , $ matches ) ) { list ( , $ relation , $ alias ) = $ matches ; $ name = $ relation ; $ callback = function ( $ query ) use ( $ callback , $ alias ) { $ query -> alias ( $ alias ) ; if ( $ callback !== null ) { call_user_func ( $ callback , $ query ) ; } } ; } if ( $ callback === null ) { $ relations [ ] = $ name ; } else { $ relations [ $ name ] = $ callback ; } } $ this -> joinWith [ ] = [ $ relations , $ eagerLoading , $ joinType ] ; return $ this ; }
2681	public function configureImageOptimizationDefaultConfigOptions ( $ params , $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/io_settings' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , $ params ) ; return $ result ; }
2543	public function analyzeWithErrCodeAndMsgQueryFixedCat ( SendResult $ response , $ qErr , $ qMsg , $ category ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; $ errorMsgNodeList = $ domXpath -> query ( $ qMsg ) ; if ( $ errorCodeNodeList -> length > 0 || $ errorMsgNodeList -> length > 0 ) { $ analyzeResponse -> status = $ category ; $ errorCode = ( $ errorCodeNodeList -> length > 0 ) ? $ errorCodeNodeList -> item ( 0 ) -> nodeValue : null ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorMsgNodeList ) ) ; } return $ analyzeResponse ; }
2149	public function createNewUser ( $ intUser , $ arrData ) { $ arrNewsletters = StringUtil :: deserialize ( $ arrData [ 'newsletter' ] , true ) ; if ( ! \ is_array ( $ arrNewsletters ) ) { return ; } $ time = time ( ) ; foreach ( $ arrNewsletters as $ intNewsletter ) { $ intNewsletter = ( int ) $ intNewsletter ; if ( $ intNewsletter < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intNewsletter , $ arrData [ 'email' ] ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, addedOn=$time" ) -> execute ( $ intNewsletter , $ arrData [ 'email' ] ) ; } } }
702	protected function findDirs ( $ dir ) { $ list = [ ] ; $ handle = @ opendir ( $ dir ) ; if ( $ handle === false ) { return [ ] ; } while ( ( $ file = readdir ( $ handle ) ) !== false ) { if ( $ file === '.' || $ file === '..' ) { continue ; } $ path = $ dir . DIRECTORY_SEPARATOR . $ file ; if ( is_dir ( $ path ) && preg_match ( '/^yii2-(.*)$/' , $ file , $ matches ) ) { $ list [ ] = $ matches [ 1 ] ; } } closedir ( $ handle ) ; foreach ( $ list as $ i => $ e ) { if ( $ e === 'composer' ) { unset ( $ list [ $ i ] ) ; } } return $ list ; }
8766	protected function loadConfigFiles ( ) { try { if ( file_exists ( $ this -> cachePath ( 'config.php' ) ) ) { $ this -> config = require $ this -> cachePath ( 'config.php' ) ; } else { $ dotenv = new \ Dotenv \ Dotenv ( $ this -> root ) ; $ dotenv -> load ( ) ; foreach ( glob ( $ this -> root . '/config/*.php' ) as $ file ) { $ keyName = strtolower ( str_replace ( [ $ this -> root . '/config/' , '.php' ] , '' , $ file ) ) ; $ this -> config [ $ keyName ] = require $ file ; } } } catch ( Exception $ e ) { die ( printf ( "Configuration information could not be retrieved properly.\nError Message: %s" , $ e -> getMessage ( ) ) ) ; } }
5722	public function save ( $ data , $ form ) { $ origStage = Versioned :: get_stage ( ) ; Versioned :: set_stage ( 'Stage' ) ; $ action = $ this -> owner -> doSave ( $ data , $ form ) ; Versioned :: set_stage ( $ origStage ) ; return $ action ; }
12415	public static function init ( $ options = array ( ) ) { Flight :: map ( "render" , function ( $ template , $ data , $ toVar = false ) { Flight :: view ( ) -> render ( $ template , $ data , $ toVar ) ; } ) ; Flight :: register ( 'view' , get_called_class ( ) , $ options ) ; }
11433	public function query ( $ keyword , $ categories , array $ other = [ ] ) { $ params = [ 'query' => $ keyword , 'category' => implode ( ',' , ( array ) $ categories ) , 'appid' => $ this -> getAccessToken ( ) -> getAppId ( ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , array_merge ( $ params , $ other ) ] ) ; }
1071	private function subfieldConflicts ( array $ conflicts , $ responseName , FieldNode $ ast1 , FieldNode $ ast2 ) { if ( count ( $ conflicts ) === 0 ) { return null ; } return [ [ $ responseName , array_map ( static function ( $ conflict ) { return $ conflict [ 0 ] ; } , $ conflicts ) , ] , array_reduce ( $ conflicts , static function ( $ allFields , $ conflict ) { return array_merge ( $ allFields , $ conflict [ 1 ] ) ; } , [ $ ast1 ] ) , array_reduce ( $ conflicts , static function ( $ allFields , $ conflict ) { return array_merge ( $ allFields , $ conflict [ 2 ] ) ; } , [ $ ast2 ] ) , ] ; }
6956	private function calculatePaymentBase ( SupplierOrderInterface $ order ) { $ base = $ this -> calculateItemsTotal ( $ order ) + $ order -> getShippingCost ( ) - $ order -> getDiscountTotal ( ) ; $ currency = $ order -> getCurrency ( ) -> getCode ( ) ; return Money :: round ( $ base , $ currency ) ; }
5524	public function generatePartial ( $ methods ) { if ( ! $ this -> reflection -> classExists ( $ this -> class ) ) { return false ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { trigger_error ( 'Partial mock class [' . $ this -> mock_class . '] already exists' ) ; return false ; } $ code = $ this -> extendClassCode ( $ methods ) ; return eval ( "$code return \$code;" ) ; }
462	public function buildCondition ( $ condition , & $ params ) { if ( is_array ( $ condition ) ) { if ( empty ( $ condition ) ) { return '' ; } $ condition = $ this -> createConditionFromArray ( $ condition ) ; } if ( $ condition instanceof ExpressionInterface ) { return $ this -> buildExpression ( $ condition , $ params ) ; } return ( string ) $ condition ; }
10373	public static function unify ( $ id , $ params , $ minify = '' ) { self :: $ id = $ id ; self :: $ unify = $ params ; self :: $ minify = $ minify ; return true ; }
10579	private function codesEqual ( string $ known , string $ given ) : bool { if ( strlen ( $ given ) !== strlen ( $ known ) ) { return false ; } $ res = 0 ; $ knownLen = strlen ( $ known ) ; for ( $ i = 0 ; $ i < $ knownLen ; ++ $ i ) { $ res |= ( ord ( $ known [ $ i ] ) ^ ord ( $ given [ $ i ] ) ) ; } return $ res === 0 ; }
7094	private function loadItem ( Model \ SaleItemInterface $ item ) { $ item -> getAdjustments ( ) -> toArray ( ) ; $ children = $ item -> getChildren ( ) -> toArray ( ) ; foreach ( $ children as $ child ) { $ this -> loadItem ( $ child ) ; } }
708	public function char ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_CHAR , $ length ) ; }
9310	protected function doPostAction ( $ uri , array $ data = [ ] ) { $ this -> setActionUri ( $ uri ) ; try { $ response = $ this -> client -> post ( $ this -> uri , [ 'json' => $ data ] ) ; } catch ( ClientException $ e ) { $ response = $ e -> getResponse ( ) ; } catch ( ServerException $ e ) { $ response = $ e -> getResponse ( ) ; } return $ this -> responseToJson ( $ response ) ; }
1135	public function moveToNewParent ( ) { $ pid = static :: $ moveToNewParentId ; if ( is_null ( $ pid ) ) $ this -> makeRoot ( ) ; else if ( $ pid !== FALSE ) $ this -> makeChildOf ( $ pid ) ; }
9126	private function requestImpl ( string $ requestType ) { if ( $ requestType == 'HEAD' ) { $ this -> setTimeout ( 1 ) ; } $ ms = $ this -> prepareRequest ( $ requestType ) ; $ ms = $ this -> appendPayloadToRequest ( $ ms ) ; if ( ! $ this -> isConnected ( ) ) { $ this -> connect ( ) ; } while ( $ ms -> ready ( ) ) { $ this -> write ( $ ms -> read ( 1024 ) ) ; } $ this -> retrieveAndParseResponse ( $ requestType ) ; if ( $ this -> getHeader ( 'Connection' ) == 'close' ) { $ this -> disconnect ( ) ; } }
5668	public function describeDifference ( $ first , $ second , $ identical = false ) { if ( $ identical ) { if ( ! $ this -> isTypeMatch ( $ first , $ second ) ) { return sprintf ( 'with type mismatch as [%s] does not match [%s]' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) ) ; } } $ type = $ this -> getType ( $ first ) ; if ( $ type === 'Unknown' ) { return 'with unknown type' ; } $ method = 'describe' . $ type . 'Difference' ; return $ this -> $ method ( $ first , $ second , $ identical ) ; }
6314	public function setReferencedColumns ( $ columns ) { if ( ! is_array ( $ columns ) ) { $ columns = array ( $ columns ) ; } $ this -> referencedColumns = $ columns ; return $ this ; }
9603	public function crossProduct ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; if ( $ this -> dimension ( ) !== 3 ) { throw new Exception ( 'Both vectors must be 3-dimensional' ) ; } $ tc = $ this -> components ( ) ; $ bc = $ b -> components ( ) ; list ( $ k0 , $ k1 , $ k2 ) = array_keys ( $ tc ) ; $ product = [ $ k0 => $ tc [ $ k1 ] * $ bc [ $ k2 ] - $ tc [ $ k2 ] * $ bc [ $ k1 ] , $ k1 => $ tc [ $ k2 ] * $ bc [ $ k0 ] - $ tc [ $ k0 ] * $ bc [ $ k2 ] , $ k2 => $ tc [ $ k0 ] * $ bc [ $ k1 ] - $ tc [ $ k1 ] * $ bc [ $ k0 ] , ] ; return new static ( $ product ) ; }
2513	protected function isWorseStatus ( $ newStatus , $ currentStatus ) { $ levels = [ self :: STATUS_UNKNOWN => - 1 , self :: STATUS_OK => 0 , self :: STATUS_INFO => 2 , self :: STATUS_WARN => 5 , self :: STATUS_ERROR => 10 , self :: STATUS_FATAL => 20 , ] ; return ( $ currentStatus === null || $ levels [ $ newStatus ] > $ levels [ $ currentStatus ] ) ; }
4676	public function render ( $ region = "main" ) { if ( ! isset ( $ this -> views [ $ region ] ) ) { return $ this ; } mergesort ( $ this -> views [ $ region ] , function ( $ viewA , $ viewB ) { $ sortA = $ viewA -> sortOrder ( ) ; $ sortB = $ viewB -> sortOrder ( ) ; if ( $ sortA == $ sortB ) { return 0 ; } return $ sortA < $ sortB ? - 1 : 1 ; } ) ; foreach ( $ this -> views [ $ region ] as $ view ) { $ view -> render ( $ this -> di ) ; } }
6128	protected function getCorpusClass ( ) { $ extras = "" ; if ( $ this -> currObj instanceof Channel && $ this -> currObj -> isSpacer ( ) ) { switch ( $ this -> currObj -> spacerGetType ( ) ) { case ( string ) TeamSpeak3 :: SPACER_SOLIDLINE : $ extras .= " solidline" ; break ; case ( string ) TeamSpeak3 :: SPACER_DASHLINE : $ extras .= " dashline" ; break ; case ( string ) TeamSpeak3 :: SPACER_DASHDOTLINE : $ extras .= " dashdotline" ; break ; case ( string ) TeamSpeak3 :: SPACER_DASHDOTDOTLINE : $ extras .= " dashdotdotline" ; break ; case ( string ) TeamSpeak3 :: SPACER_DOTLINE : $ extras .= " dotline" ; break ; } switch ( $ this -> currObj -> spacerGetAlign ( ) ) { case TeamSpeak3 :: SPACER_ALIGN_CENTER : $ extras .= " center" ; break ; case TeamSpeak3 :: SPACER_ALIGN_RIGHT : $ extras .= " right" ; break ; case TeamSpeak3 :: SPACER_ALIGN_LEFT : $ extras .= " left" ; break ; } } return "corpus " . $ this -> currObj -> getClass ( null ) . $ extras ; }
10408	public function addDocumentParameter ( $ field , $ value ) { $ this -> documentParamCache [ md5 ( $ value . $ field ) ] = [ $ field , $ value ] ; }
11584	public function exec ( $ calcId ) { $ result = [ ] ; $ bonusPercent = Cfg :: TEAM_BONUS_EU_PERCENT ; $ dwnlCompress = $ this -> daoBonDwnl -> getByCalcId ( $ calcId ) ; $ dwnlCurrent = $ this -> daoDwnl -> get ( ) ; $ mapDwnlById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCompress , EBonDwnl :: A_CUST_REF ) ; $ mapCustById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCurrent , ECustomer :: A_CUSTOMER_REF ) ; foreach ( $ mapDwnlById as $ custId => $ custDwnl ) { $ custData = $ mapCustById [ $ custId ] ; $ custMlmId = $ custData -> getMlmId ( ) ; $ pv = $ custDwnl -> getPv ( ) ; $ parentId = $ custDwnl -> getParentRef ( ) ; $ parentDwnl = $ mapDwnlById [ $ parentId ] ; $ parentData = $ mapCustById [ $ parentId ] ; $ parentMlmId = $ parentData -> getMlmId ( ) ; $ scheme = $ this -> hlpScheme -> getSchemeByCustomer ( $ parentData ) ; if ( $ scheme == Cfg :: SCHEMA_EU ) { $ pvParent = $ parentDwnl -> getPv ( ) ; if ( $ pvParent > ( Cfg :: PV_QUALIFICATION_LEVEL_EU - Cfg :: DEF_ZERO ) ) { $ bonus = $ this -> hlpFormat -> roundBonus ( $ pv * $ bonusPercent ) ; if ( $ bonus > Cfg :: DEF_ZERO ) { $ entry = new DBonus ( ) ; $ entry -> setCustomerRef ( $ parentId ) ; $ entry -> setDonatorRef ( $ custId ) ; $ entry -> setValue ( $ bonus ) ; $ result [ ] = $ entry ; } $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) has '$bonus' as EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } else { $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) does not qualified t oget EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } } else { $ this -> logger -> debug ( "Parent #$parentId (ref. #$parentMlmId) has incompatible scheme '$scheme' for EU Team Bonus." ) ; } } unset ( $ mapCustById ) ; unset ( $ mapDwnlById ) ; return $ result ; }
11719	public function saveAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , 'security' => $ app [ "security" ] , "queue_manager" => $ app [ "red_kite_cms.queue_manager" ] , ) ; $ response = parent :: save ( $ options ) ; if ( $ app [ "red_kite_cms.queue_manager" ] -> hasQueue ( ) && $ response -> getContent ( ) == "Queue saved" ) { $ lastRoute = $ request -> getSession ( ) -> get ( 'last_uri' ) ; return $ app -> redirect ( $ lastRoute ) ; } return $ response ; }
9418	public function f ( $ x ) { if ( ! is_numeric ( $ x ) ) { throw new \ InvalidArgumentException ( 'x variable must be numeric value.' ) ; } $ float_fx = exp ( - 0.5 * pow ( ( $ x - $ this -> float_mu ) / $ this -> float_sigma , 2 ) ) / ( $ this -> float_sigma * sqrt ( 2 * pi ( ) ) ) ; if ( $ this -> int_precision ) { return round ( $ float_fx , $ this -> int_precision ) ; } return $ float_fx ; }
8528	public function listFinancialEventGroupsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroupsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6797	private function convertRows ( Statement $ dbResult , $ idColumn , $ valueColumn ) { $ result = [ ] ; while ( $ row = $ dbResult -> fetch ( \ PDO :: FETCH_ASSOC ) ) { if ( ! isset ( $ result [ $ row [ $ idColumn ] ] ) ) { $ result [ $ row [ $ idColumn ] ] = [ ] ; } $ data = $ row ; unset ( $ data [ $ idColumn ] ) ; $ result [ $ row [ $ idColumn ] ] [ $ row [ $ valueColumn ] ] = $ data ; } return $ result ; }
9403	public static function get ( ContainerInterface $ container , array $ components = array ( ) , & $ globals = null ) { $ configuration = new Configuration ; $ collection = new Collection ; foreach ( ( array ) $ components as $ component ) { $ instance = self :: prepare ( $ collection , $ component ) ; $ container = $ instance -> define ( $ container , $ configuration ) ; } $ collection -> setContainer ( $ container ) ; $ globals === null || $ globals [ 'container' ] = $ container ; return $ collection ; }
171	public static function createDirectory ( $ path , $ mode = 0775 , $ recursive = true ) { if ( is_dir ( $ path ) ) { return true ; } $ parentDir = dirname ( $ path ) ; if ( $ recursive && ! is_dir ( $ parentDir ) && $ parentDir !== $ path ) { static :: createDirectory ( $ parentDir , $ mode , true ) ; } try { if ( ! mkdir ( $ path , $ mode ) ) { return false ; } } catch ( \ Exception $ e ) { if ( ! is_dir ( $ path ) ) { throw new \ yii \ base \ Exception ( "Failed to create directory \"$path\": " . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } } try { return chmod ( $ path , $ mode ) ; } catch ( \ Exception $ e ) { throw new \ yii \ base \ Exception ( "Failed to change permissions for directory \"$path\": " . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
2057	public function checkRootType ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue != 'root' && $ dc -> activeRecord -> pid == 0 ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'topLevelRoot' ] ) ; } return $ varValue ; }
6235	public function mkdir ( ) : self { if ( ! $ this -> storage -> isDir ( ) ) { if ( ! $ this -> storage -> mkdir ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to create directory at: "%s"' , $ this -> storage -> path ( ) -> raw ) , 500 ) ; } } return $ this ; }
1994	public static function indexPageIfApplicable ( Response $ objResponse ) { global $ objPage ; if ( $ objPage === null ) { return ; } if ( Config :: get ( 'enableSearch' ) && $ objResponse -> getStatusCode ( ) == 200 && ! BE_USER_LOGGED_IN && ! $ objPage -> noSearch ) { if ( Config :: get ( 'indexProtected' ) || ( ! FE_USER_LOGGED_IN && ! $ objPage -> protected ) ) { $ blnIndex = true ; foreach ( array_keys ( $ _GET ) as $ key ) { if ( \ in_array ( $ key , $ GLOBALS [ 'TL_NOINDEX_KEYS' ] ) || strncmp ( $ key , 'page_' , 5 ) === 0 ) { $ blnIndex = false ; break ; } } if ( $ blnIndex ) { $ arrData = array ( 'url' => Environment :: get ( 'base' ) . Environment :: get ( 'relativeRequest' ) , 'content' => $ objResponse -> getContent ( ) , 'title' => $ objPage -> pageTitle ? : $ objPage -> title , 'protected' => ( $ objPage -> protected ? '1' : '' ) , 'groups' => $ objPage -> groups , 'pid' => $ objPage -> id , 'language' => $ objPage -> language ) ; Search :: indexPage ( $ arrData ) ; } } } }
8525	public function setSellerSKU ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SellerSKU' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12940	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a monitor consumer over aggregate connections.' ) ; } if ( $ client -> getCommandFactory ( ) -> supportsCommand ( 'MONITOR' ) === false ) { throw new NotSupportedException ( "'MONITOR' is not supported by the current command factory." ) ; } }
5135	public function extract ( Collection $ resources , Closure $ callback ) { foreach ( $ resources as $ resource ) { $ callback ( $ resource , [ 'record' => $ resource ] ) ; } }
302	public function getAttributeLabel ( $ attribute ) { $ labels = $ this -> attributeLabels ( ) ; if ( isset ( $ labels [ $ attribute ] ) ) { return $ labels [ $ attribute ] ; } elseif ( strpos ( $ attribute , '.' ) ) { $ attributeParts = explode ( '.' , $ attribute ) ; $ neededAttribute = array_pop ( $ attributeParts ) ; $ relatedModel = $ this ; foreach ( $ attributeParts as $ relationName ) { if ( $ relatedModel -> isRelationPopulated ( $ relationName ) && $ relatedModel -> $ relationName instanceof self ) { $ relatedModel = $ relatedModel -> $ relationName ; } else { try { $ relation = $ relatedModel -> getRelation ( $ relationName ) ; } catch ( InvalidParamException $ e ) { return $ this -> generateAttributeLabel ( $ attribute ) ; } $ modelClass = $ relation -> modelClass ; $ relatedModel = $ modelClass :: instance ( ) ; } } $ labels = $ relatedModel -> attributeLabels ( ) ; if ( isset ( $ labels [ $ neededAttribute ] ) ) { return $ labels [ $ neededAttribute ] ; } } return $ this -> generateAttributeLabel ( $ attribute ) ; }
7359	public static function getDefaultPriceMapLoader ( ) { if ( null === self :: $ defaultPriceMapLoader ) { $ currencyDir = realpath ( __DIR__ . '/../../../data/prices' ) ; self :: $ defaultPriceMapLoader = new PhpFileLoader ( array ( $ currencyDir ) ) ; } return self :: $ defaultPriceMapLoader ; }
8615	public function setSalesRank ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SalesRank' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2229	public function dragFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return '<button type="button" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" ' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</button> ' ; }
3378	private function showLink ( $ link ) { if ( ! $ link [ 'show_menu' ] ) return false ; $ user = \ Auth :: guard ( 'panel' ) -> user ( ) ; return $ user -> hasRole ( 'super' ) || $ user -> hasPermission ( '/' . $ link [ 'url' ] . '/all' ) ; }
1874	private function addComponents ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; foreach ( Versions :: VERSIONS as $ name => $ version ) { if ( 0 !== strncmp ( 'contao-components/' , $ name , 18 ) ) { continue ; } $ serviceId = 'assets._package_' . $ name ; $ basePath = 'assets/' . substr ( $ name , 18 ) ; $ version = $ this -> createVersionStrategy ( $ container , $ version , $ name ) ; $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ version , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ name , new Reference ( $ serviceId ) ] ) ; } }
10233	public function edit ( $ id ) { $ user = User :: findOrFail ( $ id ) ; $ roles = Role :: lists ( 'name' , 'id' ) ; return view ( 'intothesource.usersmanager.users.edit' , compact ( 'user' , 'roles' ) ) ; }
1321	private function request ( $ url , $ method , $ authorization , array $ postfields , $ json = false ) { $ options = $ this -> curlOptions ( ) ; $ options [ CURLOPT_URL ] = $ url ; $ options [ CURLOPT_HTTPHEADER ] = [ 'Accept: application/json' , $ authorization , 'Expect:' ] ; switch ( $ method ) { case 'GET' : break ; case 'POST' : $ options [ CURLOPT_POST ] = true ; if ( $ json ) { $ options [ CURLOPT_HTTPHEADER ] [ ] = 'Content-type: application/json' ; $ options [ CURLOPT_POSTFIELDS ] = json_encode ( $ postfields ) ; } else { $ options [ CURLOPT_POSTFIELDS ] = Util :: buildHttpQuery ( $ postfields ) ; } break ; case 'DELETE' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case 'PUT' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; } if ( in_array ( $ method , [ 'GET' , 'PUT' , 'DELETE' ] ) && ! empty ( $ postfields ) ) { $ options [ CURLOPT_URL ] .= '?' . Util :: buildHttpQuery ( $ postfields ) ; } $ curlHandle = curl_init ( ) ; curl_setopt_array ( $ curlHandle , $ options ) ; $ response = curl_exec ( $ curlHandle ) ; if ( curl_errno ( $ curlHandle ) > 0 ) { throw new TwitterOAuthException ( curl_error ( $ curlHandle ) , curl_errno ( $ curlHandle ) ) ; } $ this -> response -> setHttpCode ( curl_getinfo ( $ curlHandle , CURLINFO_HTTP_CODE ) ) ; $ parts = explode ( "\r\n\r\n" , $ response ) ; $ responseBody = array_pop ( $ parts ) ; $ responseHeader = array_pop ( $ parts ) ; $ this -> response -> setHeaders ( $ this -> parseHeaders ( $ responseHeader ) ) ; curl_close ( $ curlHandle ) ; return $ responseBody ; }
4222	public function get ( $ key = null ) { if ( $ key == 'lastError' ) { return isset ( $ this -> data [ 'lastError' ] ) ? $ this -> data [ 'lastError' ] -> getValues ( ) : null ; } if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } if ( isset ( $ this -> { $ key } ) ) { return $ this -> { $ key } ; } return null ; }
11142	public function getAttributes ( $ props ) { $ attr = '' ; if ( isset ( $ props [ 'primaryKey' ] ) ) { $ attr .= 'NOT NULL AUTO_INCREMENT ' ; } if ( isset ( $ props [ 'defaultValue' ] ) ) { $ attr .= "DEFAULT '" . $ props [ 'defaultValue' ] . "'" ; } return $ attr ; }
1390	protected function resourceDoesNotExist ( string $ path ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotExist ( $ path ) ) ; }
1212	public static function isTruthy ( $ value ) { if ( ! $ value ) { return $ value === 0 || $ value === '0' ; } elseif ( $ value instanceof \ stdClass ) { return ( bool ) get_object_vars ( $ value ) ; } elseif ( $ value instanceof JmesPathableArrayInterface ) { return Utils :: isTruthy ( iterator_to_array ( $ value ) ) ; } elseif ( $ value instanceof JmesPathableObjectInterface ) { return ( bool ) $ value -> toArray ( ) ; } else { return true ; } }
2686	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ req = $ this -> api -> checkImageOptimizationStatus ( ) ; if ( ! $ req ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check image optimization status.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
319	public function registerJsFile ( $ url , $ options = [ ] , $ key = null ) { $ url = Yii :: getAlias ( $ url ) ; $ key = $ key ? : $ url ; $ depends = ArrayHelper :: remove ( $ options , 'depends' , [ ] ) ; if ( empty ( $ depends ) ) { $ position = ArrayHelper :: remove ( $ options , 'position' , self :: POS_END ) ; $ this -> jsFiles [ $ position ] [ $ key ] = Html :: jsFile ( $ url , $ options ) ; } else { $ this -> getAssetManager ( ) -> bundles [ $ key ] = Yii :: createObject ( [ 'class' => AssetBundle :: className ( ) , 'baseUrl' => '' , 'js' => [ strncmp ( $ url , '//' , 2 ) === 0 ? $ url : ltrim ( $ url , '/' ) ] , 'jsOptions' => $ options , 'depends' => ( array ) $ depends , ] ) ; $ this -> registerAssetBundle ( $ key ) ; } }
2363	public static function decodeEntities ( $ strString , $ strQuoteStyle = ENT_COMPAT , $ strCharset = null ) { if ( $ strString == '' ) { return '' ; } if ( $ strCharset === null ) { $ strCharset = Config :: get ( 'characterSet' ) ; } $ strString = preg_replace ( '/(&#*\w+)[\x00-\x20]+;/i' , '$1;' , $ strString ) ; $ strString = preg_replace ( '/(&#x*)([0-9a-f]+);/i' , '$1$2;' , $ strString ) ; return html_entity_decode ( $ strString , $ strQuoteStyle , $ strCharset ) ; }
1942	public function listRecipient ( $ row ) { $ label = Contao \ Idna :: decodeEmail ( $ row [ 'email' ] ) ; if ( $ row [ 'addedOn' ] ) { $ label .= ' <span style="color:#999;padding-left:3px">(' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'subscribed' ] , Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ row [ 'addedOn' ] ) ) . ')</span>' ; } else { $ label .= ' <span style="color:#999;padding-left:3px">(' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'manually' ] . ')</span>' ; } return sprintf ( '<div class="tl_content_left"><div class="list_icon" style="background-image:url(\'%ssystem/themes/%s/icons/%s.svg\')" data-icon="member.svg" data-icon-disabled="member_.svg">%s</div></div>' , Contao \ System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) , Contao \ Backend :: getTheme ( ) , ( $ row [ 'active' ] ? 'member' : 'member_' ) , $ label ) . "\n" ; }
12895	public function setPerson ( \ Chill \ PersonBundle \ Entity \ Person $ person = null ) { $ this -> person = $ person ; return $ this ; }
12563	public function sendNews ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_NEWS , $ message , $ to ) ; }
415	public function getAcceptableContentTypes ( ) { if ( $ this -> _contentTypes === null ) { if ( $ this -> headers -> get ( 'Accept' ) !== null ) { $ this -> _contentTypes = $ this -> parseAcceptHeader ( $ this -> headers -> get ( 'Accept' ) ) ; } else { $ this -> _contentTypes = [ ] ; } } return $ this -> _contentTypes ; }
11749	public function material ( ) { if ( is_null ( $ this -> material ) ) { $ this -> material = new Material ( $ this -> accessToken ) ; } return $ this -> material ; }
7708	function ReplaceSrc ( $ new ) { $ len = $ this -> GetLen ( ) ; $ this -> Txt = substr_replace ( $ this -> Txt , $ new , $ this -> PosBeg , $ len ) ; $ diff = strlen ( $ new ) - $ len ; $ this -> PosEnd += $ diff ; $ this -> pST_Src = false ; if ( $ new === '' ) { $ this -> pST_PosBeg = false ; $ this -> pST_PosEnd = false ; $ this -> pET_PosBeg = false ; } else { $ this -> pST_PosEnd += $ diff ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ diff ; } }
5231	public static function valuesOf ( ) { $ enum = new \ ReflectionClass ( get_called_class ( ) ) ; $ values = [ ] ; foreach ( $ enum -> getStaticProperties ( ) as $ name => $ instance ) { $ values [ $ name ] = $ instance -> value ; } return $ values ; }
11532	public static function cascade ( array $ folders ) { $ result = null ; foreach ( $ folders as $ folder ) { if ( is_dir ( $ folder ) ) { $ result = $ folder ; break ; } } return $ result ; }
6640	private function getContainerRoute ( array $ routes , $ name ) { foreach ( $ routes as $ route => $ names ) { if ( in_array ( $ name , $ names , false ) ) { return $ route ; } } throw new Exception ( "Unknown configuration class name '{$name}'" ) ; }
12822	protected function resolveOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'blockname' , ) ) ; parent :: resolveOptions ( $ options ) ; $ this -> optionsResolved = true ; }
10144	private function readBof ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ substreamType = self :: getUInt2d ( $ recordData , 2 ) ; switch ( $ substreamType ) { case self :: XLS_WORKBOOKGLOBALS : $ version = self :: getUInt2d ( $ recordData , 0 ) ; if ( ( $ version != self :: XLS_BIFF8 ) && ( $ version != self :: XLS_BIFF7 ) ) { throw new Exception ( 'Cannot read this Excel file. Version is too old.' ) ; } $ this -> version = $ version ; break ; case self :: XLS_WORKSHEET : break ; default : do { $ code = self :: getUInt2d ( $ this -> data , $ this -> pos ) ; $ this -> readDefault ( ) ; } while ( $ code != self :: XLS_TYPE_EOF && $ this -> pos < $ this -> dataSize ) ; break ; } }
7505	public function assignNamespace ( string $ namespace , $ prepend = false ) { if ( $ prepend ) { array_unshift ( $ this -> namespaces , $ namespace ) ; return ; } array_push ( $ this -> namespaces , $ namespace ) ; }
11397	public static function parseFault ( \ SimpleXMLElement $ fault ) { $ faultData = static :: parseStruct ( $ fault -> value -> struct ) ; return new \ Devedge \ XmlRpc \ Client \ RemoteException ( $ faultData [ 'faultString' ] , $ faultData [ 'faultCode' ] ) ; }
6341	final public static function init ( ) : void { $ className = static :: class ; self :: $ cache [ $ className ] = [ ] ; $ reflectionClass = self :: objectClass ( ) ; $ constructorParams = static :: constructorArgs ( ) ; $ ordinal = 0 ; foreach ( $ reflectionClass -> getProperties ( ReflectionProperty :: IS_STATIC ) as $ property ) { if ( $ property -> isPublic ( ) ) { $ name = $ property -> getName ( ) ; $ instance = self :: newInstance ( $ name , $ constructorParams ) ; $ property -> setValue ( $ instance ) ; self :: $ cache [ $ className ] [ $ name ] = $ instance ; self :: $ ordinals [ $ className ] [ $ name ] = $ ordinal ++ ; } } }
2823	public function deleteExpiredRequests ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( ! $ helper -> isEnabled ( ) ) { return 'skipped: module is disabled.' ; } if ( $ helper -> getPersistLifetime ( ) == 0 ) { return 'skipped: lifetime is set to 0' ; } $ expirationDate = $ this -> getExpirationDate ( date ( self :: DATE_FORMAT ) ) ; $ table = $ this -> getRequestsTable ( ) ; $ deleteSql = "DELETE FROM {$table} WHERE date <= '{$expirationDate}'" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return "{$result->rowCount()} requests deleted" ; }
10506	private function registerLogMenu ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogMenu :: class , Utilities \ LogMenu :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.menu' , Contracts \ Utilities \ LogMenu :: class ) ; }
10015	public function setActiveSheetIndexByName ( $ pValue ) { if ( ( $ worksheet = $ this -> getSheetByName ( $ pValue ) ) instanceof Worksheet ) { $ this -> setActiveSheetIndex ( $ this -> getIndex ( $ worksheet ) ) ; return $ worksheet ; } throw new Exception ( 'Workbook does not contain sheet:' . $ pValue ) ; }
8073	public function post ( $ endpoint , $ data , $ headers = [ ] ) { $ request = new Request ( 'POST' , $ endpoint , $ headers , $ data ) ; $ response = $ this -> guzzle -> send ( $ request ) ; return $ this -> handle ( $ response ) ; }
3791	protected function fetchExistingIdsFor ( $ idList , $ langCode ) { $ queryBuilder = $ this -> connection -> createQueryBuilder ( ) -> select ( 'item_id' ) -> from ( $ this -> getValueTable ( ) ) ; $ this -> buildWhere ( $ queryBuilder , $ idList , $ langCode ) ; $ statement = $ queryBuilder -> execute ( ) ; return $ statement -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; }
451	protected function prepareInsertSelectSubQuery ( $ columns , $ schema , $ params = [ ] ) { if ( ! is_array ( $ columns -> select ) || empty ( $ columns -> select ) || in_array ( '*' , $ columns -> select ) ) { throw new InvalidArgumentException ( 'Expected select query object with enumerated (named) parameters' ) ; } list ( $ values , $ params ) = $ this -> build ( $ columns , $ params ) ; $ names = [ ] ; $ values = ' ' . $ values ; foreach ( $ columns -> select as $ title => $ field ) { if ( is_string ( $ title ) ) { $ names [ ] = $ schema -> quoteColumnName ( $ title ) ; } elseif ( preg_match ( '/^(.*?)(?i:\s+as\s+|\s+)([\w\-_\.]+)$/' , $ field , $ matches ) ) { $ names [ ] = $ schema -> quoteColumnName ( $ matches [ 2 ] ) ; } else { $ names [ ] = $ schema -> quoteColumnName ( $ field ) ; } } return [ $ names , $ values , $ params ] ; }
4858	public function getList ( $ namespace , $ callback ) { $ session = new Container ( $ namespace ) ; $ params = $ session -> params ? : array ( ) ; if ( ! $ session -> list ) { $ session -> list = is_array ( $ callback ) ? call_user_func ( $ callback , $ session -> params ) : $ callback -> getPaginationList ( $ session -> params ) ; } return $ session -> list ; }
537	protected function updateDocComment ( $ doc , $ properties ) { $ lines = explode ( "\n" , $ doc ) ; $ propertyPart = false ; $ propertyPosition = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( strncmp ( $ line , '* @property ' , 12 ) === 0 ) { $ propertyPart = true ; } elseif ( $ propertyPart && $ line == '*' ) { $ propertyPosition = $ i ; $ propertyPart = false ; } if ( strncmp ( $ line , '* @author ' , 10 ) === 0 && $ propertyPosition === false ) { $ propertyPosition = $ i - 1 ; $ propertyPart = false ; } if ( $ propertyPart ) { unset ( $ lines [ $ i ] ) ; } } if ( $ propertyPosition === false ) { $ propertyPosition = \ count ( $ lines ) - 2 ; } $ finalDoc = '' ; foreach ( $ lines as $ i => $ line ) { $ finalDoc .= $ line . "\n" ; if ( $ i == $ propertyPosition ) { $ finalDoc .= $ properties ; } } return $ finalDoc ; }
9730	public function setMaxParcelDimensions ( $ value = null ) { if ( is_array ( $ value ) ) { $ value = new ParcelDimensions ( $ value ) ; } elseif ( ! ( $ value instanceof ParcelDimensions ) ) { $ value = null ; } return $ this -> setParameter ( 'max_parcel_dimensions' , $ value ) ; }
8957	public function redaction ( $ element , $ id , $ version , $ redactionId ) { if ( $ element != 'node' && $ element != 'way' && $ element != 'relation' ) { throw new \ DomainException ( 'Element should be a node, a way or a relation' ) ; } $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = $ element . '/' . $ id . '/' . $ version . '/redact?redaction=' . $ redactionId ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters ) ; return simplexml_load_string ( $ response -> body ) ; }
11830	protected function expand ( ) { foreach ( $ this as $ key => $ item ) { $ item [ 'slug' ] = $ key ; if ( isset ( $ item [ 'date' ] ) ) { $ item [ 'formatted_date' ] = date ( self :: DATE_FORMAT , $ item [ 'date' ] ) ; } $ this -> set ( $ key , $ item ) ; } }
3919	public static function convertUuidsOrPathsToMetaModels ( $ values ) { $ values = array_filter ( ( array ) $ values ) ; if ( empty ( $ values ) ) { return array ( 'bin' => array ( ) , 'value' => array ( ) , 'path' => array ( ) , 'meta' => array ( ) ) ; } foreach ( $ values as $ key => $ value ) { if ( ! ( Validator :: isUuid ( $ value ) ) ) { $ file = FilesModel :: findByPath ( $ value ) ? : Dbafs :: addResource ( $ value ) ; if ( ! $ file ) { throw new InvalidArgumentException ( 'Invalid value.' ) ; } $ values [ $ key ] = $ file -> uuid ; } } return self :: convertValuesToMetaModels ( $ values ) ; }
7154	protected function match ( $ role , $ action ) : bool { $ roles = $ actions = [ '*' ] ; $ allow = false ; if ( $ role != '*' ) array_unshift ( $ roles , $ role ) ; if ( $ action != '*' ) array_unshift ( $ actions , $ action ) ; foreach ( $ roles as $ _role ) { foreach ( $ actions as $ _action ) { if ( isset ( $ this -> _rules [ $ _role ] [ $ _action ] ) ) { $ allow = $ this -> _rules [ $ _role ] [ $ _action ] ; break 2 ; } } } return $ allow === true ; }
575	protected function getDefaultValue ( $ event ) { if ( $ this -> defaultValue instanceof \ Closure || ( is_array ( $ this -> defaultValue ) && is_callable ( $ this -> defaultValue ) ) ) { return call_user_func ( $ this -> defaultValue , $ event ) ; } return $ this -> defaultValue ; }
10134	public function positionImage ( $ col_start , $ row_start , $ x1 , $ y1 , $ width , $ height ) { $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) ) { $ x1 = 0 ; } if ( $ y1 >= Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ) { $ width -= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ; ++ $ col_end ; } while ( $ height >= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ) { $ height -= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) * 1024 ; $ y1 = $ y1 / Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) * 256 ; $ x2 = $ width / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) * 1024 ; $ y2 = $ height / Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) * 256 ; $ this -> writeObjPicture ( $ col_start , $ x1 , $ row_start , $ y1 , $ col_end , $ x2 , $ row_end , $ y2 ) ; }
9950	public function duplicateStyle ( Style $ pCellStyle , $ pRange ) { $ workbook = $ this -> parent ; if ( $ existingStyle = $ this -> parent -> getCellXfByHashCode ( $ pCellStyle -> getHashCode ( ) ) ) { $ xfIndex = $ existingStyle -> getIndex ( ) ; } else { $ workbook -> addCellXf ( $ pCellStyle ) ; $ xfIndex = $ pCellStyle -> getIndex ( ) ; } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> getCell ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row ) -> setXfIndex ( $ xfIndex ) ; } } return $ this ; }
8921	protected function parseRelationship ( $ node ) { $ rel = array ( ) ; $ x = preg_replace ( '/\(.*?\)/' , '' , $ node -> text ( 'marc:subfield[@code="w"]' ) ) ; if ( ! empty ( $ x ) ) { $ rel [ 'id' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="t"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'title' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="g"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'parts' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="x"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'issn' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="z"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'isbn' ] = $ x ; } return $ rel ; }
6872	private function initializeRelayPoint ( ShipmentInterface $ shipment ) { if ( null === $ method = $ shipment -> getMethod ( ) ) { if ( null !== $ shipment -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( null ) ; } return ; } $ gateway = $ this -> registry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( ! $ gateway -> supports ( GatewayInterface :: CAPABILITY_RELAY ) ) { if ( null !== $ shipment -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( null ) ; } return ; } if ( null !== $ relayPoint = $ shipment -> getSale ( ) -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( $ relayPoint ) ; } }
3502	private function initializeCurlResource ( ) : void { if ( ! $ this -> resource ) { $ this -> resource = curl_init ( ) ; curl_setopt ( $ this -> resource , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_POST , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_HTTP_VERSION , 3 ) ; } }
8935	public function add ( $ name , $ template ) { if ( array_key_exists ( $ name , $ this -> templates ) ) { throw new \ InvalidArgumentException ( 'Template already exists.' ) ; } $ this -> templates [ $ name ] = $ template ; }
8126	protected function getSchemaResponse ( $ schemaID , $ form = null , ValidationResult $ errors = null , $ extraData = [ ] ) { $ parts = $ this -> owner -> getRequest ( ) -> getHeader ( LeftAndMain :: SCHEMA_HEADER ) ; $ data = $ this -> owner -> getFormSchema ( ) -> getMultipartSchema ( $ parts , $ schemaID , $ form , $ errors ) ; if ( $ extraData ) { $ data = array_merge ( $ data , $ extraData ) ; } $ response = HTTPResponse :: create ( Convert :: raw2json ( $ data ) ) ; $ response -> addHeader ( 'Content-Type' , 'application/json' ) ; return $ response ; }
10115	private function writeFooter ( ) { $ record = 0x0015 ; $ recordData = StringHelper :: UTF8toBIFF8UnicodeLong ( $ this -> phpSheet -> getHeaderFooter ( ) -> getOddFooter ( ) ) ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
12760	public static function dispatch ( $ eventName , Event $ event ) { if ( null === self :: $ dispatcher ) { return $ event ; } self :: $ dispatcher -> dispatch ( $ eventName , $ event ) ; DataLogger :: log ( sprintf ( 'The "%s" event was dispatched' , $ eventName ) ) ; if ( $ event -> getAbort ( ) ) { DataLogger :: log ( sprintf ( 'The "%s" event was aborted' , $ eventName ) , DataLogger :: ERROR ) ; throw new EventAbortedException ( $ event -> getAbortMessage ( ) ) ; } return $ event ; }
10811	protected function bindValues ( $ sql , array $ settings ) { $ bindings = & $ this -> bindings ; $ escape = $ this -> getEscapeCallable ( $ settings [ 'escapeFunction' ] ) ; $ params = $ this -> getBuilder ( ) -> getPlaceholderMapping ( ) ; $ function = function ( $ v ) use ( $ settings , & $ bindings , $ escape ) { if ( $ settings [ 'positionedParam' ] ) { $ bindings [ ] = $ v ; return '?' ; } elseif ( $ settings [ 'namedParam' ] && isset ( $ v [ 0 ] ) && ':' == $ v [ 0 ] ) { return $ v ; } elseif ( is_numeric ( $ v ) && ! is_string ( $ v ) ) { return $ v ; } else { return $ escape ( $ v ) ; } } ; return preg_replace_callback ( '/\b__PH_[0-9]++__\b/' , function ( $ m ) use ( & $ params , $ function ) { return $ function ( $ params [ $ m [ 0 ] ] ) ; } , $ sql ) ; }
8056	public function setChildProcessTitleFormat ( $ string ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Parent\'s Process Title Format for a created pool.' ) ; } $ this -> childProcessTitleFormat = ProcessDetails :: sanitizeProcessTitleFormat ( $ string ) ; return $ this ; }
1779	public function getEmptyStringOrNull ( ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ) { return '' ; } return static :: getEmptyStringOrNullByFieldType ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ; }
3137	public function parsesItemResponse ( RunnerServiceContext $ context , $ itemRef , $ response ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ currentItem = $ context -> getCurrentAssessmentItemRef ( ) ; $ responses = new State ( ) ; if ( $ currentItem === false ) { $ msg = "Trying to store item variables but the state of the test session is INITIAL or CLOSED.\n" ; $ msg .= "Session state value: " . $ session -> getState ( ) . "\n" ; $ msg .= "Session ID: " . $ session -> getSessionId ( ) . "\n" ; $ msg .= "JSON Payload: " . mb_substr ( json_encode ( $ response ) , 0 , 1000 ) ; \ common_Logger :: e ( $ msg ) ; } $ filler = new \ taoQtiCommon_helpers_PciVariableFiller ( $ currentItem , $ this -> getServiceManager ( ) -> get ( QtiFlysystemFileManager :: SERVICE_ID ) ) ; if ( is_array ( $ response ) ) { foreach ( $ response as $ id => $ responseData ) { try { $ var = $ filler -> fill ( $ id , $ responseData ) ; if ( \ taoQtiCommon_helpers_Utils :: isQtiFilePlaceHolder ( $ var ) === false ) { $ responses -> setVariable ( $ var ) ; } } catch ( \ OutOfRangeException $ e ) { \ common_Logger :: d ( "Could not convert client-side value for variable '${id}'." ) ; } catch ( \ OutOfBoundsException $ e ) { \ common_Logger :: d ( "Could not find variable with identifier '${id}' in current item." ) ; } } } else { \ common_Logger :: e ( 'Invalid json payload' ) ; } return $ responses ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
8397	public function getDefinition ( ) : array { if ( $ this -> definition == null ) { $ data = Mapping :: get ( $ this -> mapping ) ; $ this -> definition = Config :: get ( $ data [ 'config' ] [ 'schema' ] ) ; } return $ this -> definition ; }
4497	private function getAndroidJsonInner ( ? string $ text ) : array { $ data = [ ] ; if ( null !== $ text ) { $ data [ 'message' ] = $ text ; } if ( null !== $ this -> localizedKey ) { $ data [ 'message-loc-key' ] = $ this -> localizedKey ; if ( $ this -> localizedArguments ) { $ data [ 'message-loc-args' ] = $ this -> localizedArguments ; } } return $ data ; }
9703	private function addColor ( $ rgb ) { if ( ! isset ( $ this -> colors [ $ rgb ] ) ) { $ color = [ hexdec ( substr ( $ rgb , 0 , 2 ) ) , hexdec ( substr ( $ rgb , 2 , 2 ) ) , hexdec ( substr ( $ rgb , 4 ) ) , 0 , ] ; $ colorIndex = array_search ( $ color , $ this -> palette ) ; if ( $ colorIndex ) { $ this -> colors [ $ rgb ] = $ colorIndex ; } else { if ( count ( $ this -> colors ) == 0 ) { $ lastColor = 7 ; } else { $ lastColor = end ( $ this -> colors ) ; } if ( $ lastColor < 57 ) { $ colorIndex = $ lastColor + 1 ; $ this -> palette [ $ colorIndex ] = $ color ; $ this -> colors [ $ rgb ] = $ colorIndex ; } else { $ colorIndex = 0 ; } } } else { $ colorIndex = $ this -> colors [ $ rgb ] ; } return $ colorIndex ; }
5659	private function indexWidgetById ( $ widget ) { $ id = $ widget -> getAttribute ( 'id' ) ; if ( ! $ id ) { return ; } if ( ! isset ( $ this -> widgets_by_id [ $ id ] ) ) { $ this -> widgets_by_id [ $ id ] = array ( ) ; } $ this -> widgets_by_id [ $ id ] [ ] = $ widget ; }
6464	public function isJson ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/application\/json/i" , $ contentType ) === 1 ; }
5908	public function listUsers ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/users' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new User ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11881	public function run ( ) { if ( false === $ this -> boot ( ) ) { exit ( 1 ) ; } $ this -> runner -> run ( $ this -> request , $ this -> response ) ; return $ this ; }
5337	public function api ( $ name ) { switch ( $ name ) { case 'domain' : case 'domain_service' : case 'domainService' : return new Api \ Domain ( $ this ) ; case 'colocation' : case 'colocation_service' : case 'colocationService' : return new Api \ Colocation ( $ this ) ; case 'forward' : case 'forward_service' : case 'forwardService' : return new Api \ Forward ( $ this ) ; case 'vps' : case 'vps_service' : case 'vpsService' : return new Api \ Vps ( $ this ) ; case 'hosting' : case 'web_hosting' : case 'webHosting' : case 'web_hosting_service' : case 'webHostingService' : return new Api \ WebHosting ( $ this ) ; case 'haip' : case 'ha_ip' : case 'ha_ip_service' : case 'haip_service' : case 'haipService' : return new Api \ Haip ( $ this ) ; default : throw new \ InvalidArgumentException ( sprintf ( 'Undefined api instance called: [%s]' , $ name ) ) ; } }
1534	protected function methodForRelation ( $ field ) { if ( method_exists ( $ this , $ field ) ) { return $ field ; } $ method = Str :: camelize ( $ field ) ; return method_exists ( $ this , $ method ) ? $ method : null ; }
10395	protected function getShopIds ( ) { $ shopIds = [ ] ; try { $ shops = $ this -> container -> getParameter ( 'ongr_connections.shops' ) ; } catch ( InvalidArgumentException $ e ) { $ shops = [ ] ; } foreach ( $ shops as $ shop ) { $ shopIds [ ] = $ shop [ 'shop_id' ] ; } return $ shopIds ; }
11267	public function view ( $ pathname = '' , $ data = false , $ return = false ) { if ( is_array ( $ data ) || is_object ( $ data ) ) { foreach ( $ data as $ key => $ value ) { $ $ key = $ value ; } } if ( $ pathname == '' ) { $ pathname = $ this -> config [ 'template' ] ; } $ fullPath = $ this -> config [ 'pathToViews' ] . $ this -> getPath ( $ pathname ) ; $ path = $ this -> getPath ( $ pathname ) ; $ this -> debug ( 'Full Path: ' . $ fullPath ) ; $ fileName = $ this -> config [ 'viewsPrefix' ] . $ this -> getName ( $ pathname ) . $ this -> config [ 'viewsPostfix' ] . '.php' ; $ filePath = $ this -> _getFilePath ( $ pathname , $ fileName ) ; $ this -> debug ( '' ) ; $ this -> debug ( 'Searching for View: ' ) ; $ this -> debug ( 'View Name: ' . $ this -> getName ( $ pathname ) ) ; $ this -> debug ( 'View Path: ' . $ this -> getPath ( $ pathname ) ) ; $ this -> debug ( 'File Path: ' . $ filePath ) ; $ this -> debug ( '' ) ; if ( $ return || $ this -> neverOutput ) { ob_start ( ) ; $ inc = include ( $ filePath ) ; if ( $ inc == false && $ this -> config [ 'mode' ] == 'development' ) { throw new \ Exception ( "Can't find file '$fileName' using path '$filePath'" ) ; } return ob_get_clean ( ) ; } else { $ inc = include ( $ filePath ) ; if ( $ inc == false && $ this -> config [ 'mode' ] == 'development' ) { throw new \ Exception ( "Can't find file '$fileName' using path '$filePath'" ) ; } } }
5266	public static function merge ( Model $ model1 , Model $ model2 , array $ attributes ) { foreach ( $ attributes as $ attribute ) { $ model1 -> $ attribute = $ model2 -> $ attribute ; } return $ model1 ; }
2000	private function fetchData ( FileUpload $ uploader , string $ separator , callable $ callback ) : array { $ data = [ ] ; $ files = $ this -> getFiles ( $ uploader ) ; $ delimiter = $ this -> getDelimiter ( $ separator ) ; foreach ( $ files as $ file ) { $ fp = fopen ( $ file , 'r' ) ; while ( false !== ( $ row = fgetcsv ( $ fp , 0 , $ delimiter ) ) ) { $ data = $ callback ( $ data , $ row ) ; } } return $ data ; }
11750	public function relation ( ) { if ( is_null ( $ this -> relation ) ) { $ this -> relation = new Relation ( $ this -> accessToken ) ; } return $ this -> relation ; }
2098	public static function formatToJs ( $ strFormat ) { $ chunks = str_split ( $ strFormat ) ; foreach ( $ chunks as $ k => $ v ) { switch ( $ v ) { case 'D' : $ chunks [ $ k ] = 'a' ; break ; case 'j' : $ chunks [ $ k ] = 'e' ; break ; case 'l' : $ chunks [ $ k ] = 'A' ; break ; case 'S' : $ chunks [ $ k ] = 'o' ; break ; case 'F' : $ chunks [ $ k ] = 'B' ; break ; case 'M' : $ chunks [ $ k ] = 'b' ; break ; case 'a' : $ chunks [ $ k ] = 'p' ; break ; case 'A' : $ chunks [ $ k ] = 'p' ; break ; case 'g' : $ chunks [ $ k ] = 'l' ; break ; case 'G' : $ chunks [ $ k ] = 'k' ; break ; case 'h' : $ chunks [ $ k ] = 'I' ; break ; case 'i' : $ chunks [ $ k ] = 'M' ; break ; case 's' : $ chunks [ $ k ] = 'S' ; break ; case 'U' : $ chunks [ $ k ] = 's' ; break ; } } return preg_replace ( '/([a-zA-Z])/' , '%$1' , implode ( '' , $ chunks ) ) ; }
11491	public function getAll ( ) : array { $ res = [ ] ; foreach ( $ this -> getKeys ( ) as $ key ) { $ res [ $ key ] = $ this -> get ( $ key ) ; } return $ res ; }
4106	public function commitBulk ( ) { if ( $ this -> bulk && $ this -> bulk -> count ( ) ) { $ result = $ this -> bulk -> commit ( ) ; $ this -> bulk = null ; return $ result ; } }
6762	public function expand ( $ edges = [ ] , $ force = false ) { if ( $ force ) foreach ( $ this -> models as $ i => $ model ) $ this -> models [ $ i ] -> expand ( $ edges ) ; else foreach ( $ this -> models as $ i => $ model ) if ( is_a ( $ model , "SnooPHP\Model\Node" ) ) $ this -> models [ $ i ] -> expand ( $ edges ) ; return $ this ; }
3313	protected function appendAppIdAndBucketIfEmpty ( array $ options = [ ] ) { $ options [ 'appid' ] = empty ( $ options [ 'appid' ] ) ? $ this -> authorization -> getAppId ( ) : $ options [ 'appid' ] ; $ options [ 'bucket' ] = empty ( $ options [ 'bucket' ] ) ? $ this -> authorization -> getBucket ( ) : $ options [ 'bucket' ] ; return $ options ; }
11218	public static function dispatch ( ) { self :: routeValidator ( ) ; self :: $ routes = str_replace ( '//' , '/' , self :: $ routes ) ; if ( in_array ( self :: $ uri , self :: $ routes , true ) ) { return self :: checkRoutes ( ) ; } if ( self :: checkRegexRoutes ( ) !== false ) { return self :: checkRegexRoutes ( ) ; } return self :: getErrorCallback ( ) ; }
9787	public function parseFilteredValue ( ) { list ( $ type , $ filters ) = $ this -> pop ( 'FILTERED_VALUE' ) ; $ value = array_shift ( $ filters ) ; $ opening = '' ; $ closing = '' ; foreach ( $ filters as $ filter ) { if ( function_exists ( $ filter ) ) { $ opening .= $ filter . '(' ; $ closing .= ')' ; } else { $ opening .= '\Katar\Katar::getInstance()->filter(\'' . $ filter . '\', ' ; $ closing .= ')' ; } } return '$output .= ' . $ opening . $ value . $ closing . ";\n" ; }
9691	private function compile ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } if ( ! file_exists ( $ this -> views_cache ) && ! mkdir ( $ this -> views_cache ) ) { throw new \ Exception ( "Could no create cache directory." . " Make sure you have write permissions." ) ; } $ hash = md5 ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; $ compiled = null ; if ( $ this -> debug || ( ! file_exists ( $ compiled_file ) || filemtime ( $ compiled_file ) < filemtime ( $ file ) ) ) { $ source = file_get_contents ( $ file ) ; $ compiled = $ this -> compileString ( $ source ) ; $ compiled = "<?php\nfunction katar_" . $ hash . "(\$args) {\nextract(\$args);\n\$output = null;\n" . $ compiled . "\nreturn \$output;\n}\n" ; file_put_contents ( $ compiled_file , $ compiled ) ; } else { $ compiled = file_get_contents ( $ cache_file ) ; } return $ compiled ; }
11108	public function logRequest ( APIRequest $ request ) : void { $ item = $ this -> cacheItemPool -> getItem ( $ this -> deriveCacheKey ( $ request ) ) ; if ( $ requestCount = $ item -> get ( ) ) { $ item -> set ( $ requestCount + 1 ) ; } else { $ item -> set ( 1 ) -> expiresAfter ( $ this -> perXSeconds ) ; } $ this -> cacheItemPool -> save ( $ item ) ; }
8870	public function detach ( Runner $ runner ) { if ( ! $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t detach not attached runner.' ) ; } $ this -> runners -> detach ( $ runner ) ; return $ this ; }
3700	private function handleSorting ( $ information , GroupAndSortingDefinitionInterface $ definition ) { if ( $ information [ 'ismanualsort' ] ) { $ definition -> add ( ) -> setManualSorting ( ) -> setProperty ( 'sorting' ) -> setSortingMode ( GroupAndSortingInformationInterface :: SORT_ASC ) ; return ; } if ( $ information [ 'col_name' ] ) { $ definition -> add ( ) -> setProperty ( $ information [ 'col_name' ] ) -> setSortingMode ( $ information [ 'rendersort' ] ) ; } }
2200	public static function findPublishedByPidAndColumn ( $ intPid , $ strColumn , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.inColumn=?" ) ; $ arrValues = array ( $ intPid , $ strColumn ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
2070	public function deletePage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ root = func_get_arg ( 7 ) ; return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_DELETE_PAGE , $ row ) && ( $ this -> User -> isAdmin || ! \ in_array ( $ row [ 'id' ] , $ root ) ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
3492	public function withHeaders ( array $ headers ) : Request { $ cloned = clone $ this ; foreach ( $ headers as $ name => $ value ) { $ cloned = $ cloned -> withHeader ( $ name , $ value ) ; } return $ cloned ; }
8309	public function assertIntOrFalse ( $ config , $ key , $ lowest = null , $ highest = null ) { try { $ this -> assertInteger ( $ config , $ key , $ lowest , $ highest ) ; } catch ( ConfigurationException $ e ) { if ( $ config [ $ key ] !== false ) { throw new ConfigurationException ( "Key `{$key}` can be either false or a non-negative integer." ) ; } } return $ this ; }
10212	function toCsvString ( ) { $ standard_fields = "{" ; if ( isset ( $ this -> standard_fields ) ) { foreach ( $ this -> standard_fields as $ index => $ value ) { $ standard_fields .= $ index . "=" . $ value . "," ; } $ standard_fields = rtrim ( $ standard_fields , ',' ) ; } $ standard_fields .= "}" ; $ customfields = "{" ; if ( isset ( $ this -> custom_fields ) ) { foreach ( $ this -> custom_fields as $ index => $ value ) { $ customfields .= $ index . "=" . $ value . "," ; } $ customfields = rtrim ( $ customfields , ',' ) ; } $ customfields .= "}" ; $ permission = "" ; if ( isset ( $ this -> permission ) ) { $ permission = $ this -> permission -> getCode ( ) ; } return $ this -> id . ";" . $ this -> email . ";" . $ permission . ";" . $ this -> external_id . ";" . ( ( $ this -> anonymous == true ) ? "true" : "false" ) . ";" . $ this -> created . ";" . $ this -> updated . ";\"" . $ standard_fields . "\"" . ";\"" . $ customfields . "\"" ; }
12943	public function authenticate ( AdapterInterface $ adapter = null ) { $ event = clone $ this -> getEvent ( ) ; $ event -> setName ( AuthenticationEvent :: EVENT_AUTH ) ; if ( ! $ adapter ) { $ adapter = $ this -> getAdapter ( ) ; } if ( $ adapter ) { $ event -> setAdapter ( $ adapter ) ; } $ this -> getEventManager ( ) -> trigger ( $ event ) ; return $ event -> getResult ( ) ; }
6565	public static function register ( $ prepend = true , $ callback = null , $ app = null ) { if ( ! static :: $ registered ) { static :: $ registered = spl_autoload_register ( array ( '\\Sbp\\Laravel\\ClassLoader' , 'load' ) , true , $ prepend ) ; if ( is_null ( $ app ) ) { $ app = __DIR__ . '/../../../../../../app' ; } if ( ! file_exists ( $ app . '/storage' ) || ! is_writable ( $ app . '/storage' ) ) { throw new SbpException ( "Laravel app and/or writable storage directory not found at $app, please specify the path with the following code:\nSbp\\Laravel\\ClassLoader::register(true, 'sha1', \$laravelAppPath)" ) ; } Sbp :: writeIn ( Sbp :: SAME_DIR ) ; Sbp :: fileExists ( $ app . '/routes' ) ; $ storage = $ app . '/storage/sbp' ; if ( ! file_exists ( $ storage ) ) { if ( mkdir ( $ storage , 0777 ) ) { file_put_contents ( $ storage . '/.gitignore' , "*\n!.gitignore" ) ; } } Sbp :: writeIn ( $ storage , $ callback ) ; } }
416	public function getAcceptableLanguages ( ) { if ( $ this -> _languages === null ) { if ( $ this -> headers -> has ( 'Accept-Language' ) ) { $ this -> _languages = array_keys ( $ this -> parseAcceptHeader ( $ this -> headers -> get ( 'Accept-Language' ) ) ) ; } else { $ this -> _languages = [ ] ; } } return $ this -> _languages ; }
637	public function truncateTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> truncateTable ( $ table ) ; return $ this -> setSql ( $ sql ) ; }
10718	public function paginate ( $ page = 1 , $ perPage = null , $ columns = [ '*' ] ) { $ perPage = $ perPage ? : $ this -> defaultPageSize ; $ query = $ this -> getQuery ( ) ; $ total = $ query -> getQuery ( ) -> getCountForPagination ( $ columns ) ; $ query -> getQuery ( ) -> forPage ( $ page , $ perPage ) ; $ results = $ query -> get ( $ columns ) ; $ results = new LengthAwarePaginator ( $ results , $ total , $ perPage , $ page ) ; return $ this -> returnResults ( $ results ) ; }
9651	public function duplicate ( $ doWrite = true ) { $ clonedNode = parent :: duplicate ( $ doWrite ) ; if ( $ this -> Options ( ) ) { foreach ( $ this -> Options ( ) as $ field ) { $ newField = $ field -> duplicate ( ) ; $ newField -> ParentID = $ clonedNode -> ID ; $ newField -> write ( ) ; } } return $ clonedNode ; }
1332	protected function readWithFilters ( $ record , EncodingParametersInterface $ parameters ) { $ query = $ this -> newQuery ( ) -> whereKey ( $ record -> getKey ( ) ) ; $ this -> applyFilters ( $ query , collect ( $ parameters -> getFilteringParameters ( ) ) ) ; return $ query -> exists ( ) ? $ record : null ; }
12211	public function addSnippet ( string $ snptName ) : void { $ this -> snippets [ $ snptName ] = ViewFactory :: createSnippet ( $ snptName ) ; }
6671	public function restart_rating ( $ post_id , $ post , $ update ) { App :: setCurrentID ( 'EFG' ) ; if ( Module :: CustomRatingGrifus ( ) -> getOption ( 'restart-when-add' ) ) { unset ( $ _POST [ 'imdbRating' ] , $ _POST [ 'imdbVotes' ] ) ; if ( App :: main ( ) -> is_after_insert_post ( $ post , $ update ) ) { if ( ! $ this -> model -> get_movie_votes ( $ post_id ) ) { $ votes = $ this -> get_default_votes ( $ post_id ) ; $ this -> set_rating_and_votes ( $ post_id , $ votes ) ; return true ; } } } return false ; }
4946	public function build ( ) { $ view = $ change = array ( ) ; foreach ( $ this -> assigned as $ resourceId => $ spec ) { if ( isset ( $ spec [ 'permission' ] ) ) { $ spec = array ( $ spec [ 'permission' ] => $ spec [ 'users' ] ) ; $ this -> assigned [ $ resourceId ] = $ spec ; } foreach ( $ spec as $ perm => $ userIds ) { if ( self :: PERMISSION_ALL == $ perm || self :: PERMISSION_CHANGE == $ perm ) { $ change = array_merge ( $ change , $ userIds ) ; } $ view = array_merge ( $ view , $ userIds ) ; } } $ this -> change = array_unique ( $ change ) ; $ this -> view = array_unique ( $ view ) ; return $ this ; }
2323	public static function get ( ) { $ container = System :: getContainer ( ) ; return $ container -> get ( 'contao.csrf.token_manager' ) -> getToken ( $ container -> getParameter ( 'contao.csrf_token_name' ) ) -> getValue ( ) ; }
9460	public function deleteTickets ( array $ tickets ) { $ ids = array ( ) ; foreach ( $ tickets as $ ticket ) { $ ids [ ] = $ ticket -> getId ( ) ; } return parent :: deleteByIds ( $ ids , 'tickets/destroy_many.json' ) ; }
6677	public static function toRelativeTime ( $ fromTime , $ toTime = 'now' , $ format = 'days' ) { $ startTime = new DateTime ( $ fromTime ) ; $ endTime = new DateTime ( $ toTime ) ; return $ startTime -> diff ( $ endTime ) -> $ format ; }
11606	public function getPHPHint ( $ namespaceContext = NULL ) { if ( ! isset ( $ this -> class ) ) { return '\stdClass' ; } if ( isset ( $ namespaceContext ) && trim ( $ this -> class -> getNamespace ( ) , '\\' ) === trim ( $ namespaceContext , '\\' ) ) { return $ this -> class -> getName ( ) ; } return '\\' . $ this -> class -> getFQN ( ) ; }
11752	public function open ( $ msgId , $ index ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_OPEN_COMMENT , $ params ] ) ; }
7258	protected function mergeItemsResults ( Model \ SaleItemInterface $ item , Amount $ result ) : void { foreach ( $ item -> getChildren ( ) as $ child ) { if ( $ child -> isPrivate ( ) ) { continue ; } if ( ! ( $ child -> isCompound ( ) && ! $ child -> hasPrivateChildren ( ) ) ) { $ result -> merge ( $ child -> getResult ( ) ) ; } if ( $ child -> hasChildren ( ) ) { $ this -> mergeItemsResults ( $ child , $ result ) ; } } }
3956	public function getSiblings ( $ objFilter ) { if ( ! $ this -> getMetaModel ( ) -> hasVariants ( ) ) { return null ; } return $ this -> getMetaModel ( ) -> findVariantsWithBase ( array ( $ this -> get ( 'id' ) ) , $ objFilter ) ; }
2220	public static function findPublishedDefaultByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.source='default'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
11994	public function pipe ( $ data , $ index , $ isHeader = false ) { $ this -> lastIndex ++ ; $ this -> data [ $ this -> lastIndex ] = $ data ; }
9096	public function update ( ) { hypePrototyper ( ) -> prototype -> saveStickyValues ( $ this -> action ) ; foreach ( $ this -> fields as $ field ) { if ( $ field -> getDataType ( ) == 'attribute' ) { $ this -> entity = $ field -> handle ( $ this -> entity ) ; } } if ( ! $ this -> entity -> save ( ) ) { return false ; } foreach ( $ this -> fields as $ field ) { if ( $ field -> getDataType ( ) !== 'attribute' ) { $ this -> entity = $ field -> handle ( $ this -> entity ) ; } } if ( ! $ this -> entity -> save ( ) ) { return false ; } hypePrototyper ( ) -> prototype -> clearStickyValues ( $ this -> action ) ; return $ this -> entity ; }
4326	public static function getInterface ( ) { $ return = 'http' ; $ isCliOrCron = \ count ( \ array_filter ( array ( \ defined ( 'STDIN' ) , isset ( $ _SERVER [ 'argv' ] ) , ! \ array_key_exists ( 'REQUEST_METHOD' , $ _SERVER ) , ) ) ) > 0 ; if ( $ isCliOrCron ) { $ return = isset ( $ _SERVER [ 'TERM' ] ) || \ array_key_exists ( 'PATH' , $ _SERVER ) ? 'cli' : 'cron' ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] ) && $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] == 'XMLHttpRequest' ) { $ return = 'ajax' ; } return $ return ; }
9819	public function setSegmentSize ( $ size ) { if ( null !== $ this -> memory ) { throw new Exception \ RuntimeException ( 'You can not change the segment size because memory is already allocated.' . ' Use realloc() function to create new memory segment.' ) ; } $ this -> segmentSize = ( integer ) $ size ; return $ this ; }
8017	public function fileExists ( $ name ) { $ http = new \ Guzzle \ Http \ Client ( ) ; try { $ response = $ http -> get ( $ this -> getUrl ( $ name ) ) -> send ( ) ; } catch ( ClientErrorResponseException $ e ) { return false ; } return $ response -> isSuccessful ( ) ; }
9197	public function getTag ( ) { if ( null !== $ this -> tag ) { return $ this -> tag ; } $ categoryId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'categoryid' ) ; if ( is_numeric ( $ categoryId ) ) { return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ categoryId ) ; } $ topicId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'topicid' ) ; if ( is_numeric ( $ topicId ) ) { $ topic = $ this -> getDiscussService ( ) -> getTopicById ( $ topicId ) ; return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ topic -> getforumCategoryId ( ) ) ; } return false ; }
6723	protected function validateAuthParams ( ) { if ( empty ( $ this -> authUrl ) || filter_var ( $ this -> authUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_AUTH_URL , $ this -> authUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
142	public function getInstallPath ( PackageInterface $ package ) { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; return $ installer -> getInstallPath ( $ package ) ; }
6232	public function setPickupPoint ( $ pickup_point_id ) { $ service = new AdditionalService ( ) ; $ service -> setServiceCode ( 2106 ) ; $ service -> addSpecifier ( 'pickup_point_id' , $ pickup_point_id ) ; $ this -> addAdditionalService ( $ service ) ; }
2286	protected static function agent ( ) { $ ua = static :: get ( 'httpUserAgent' ) ; $ return = new \ stdClass ( ) ; $ return -> string = $ ua ; $ os = 'unknown' ; $ mobile = false ; $ browser = 'other' ; $ shorty = '' ; $ version = '' ; $ engine = '' ; foreach ( Config :: get ( 'os' ) as $ k => $ v ) { if ( stripos ( $ ua , $ k ) !== false ) { $ os = $ v [ 'os' ] ; $ mobile = $ v [ 'mobile' ] ; break ; } } $ return -> os = $ os ; foreach ( Config :: get ( 'browser' ) as $ k => $ v ) { if ( stripos ( $ ua , $ k ) !== false ) { $ browser = $ v [ 'browser' ] ; $ shorty = $ v [ 'shorty' ] ; $ version = preg_replace ( $ v [ 'version' ] , '$1' , $ ua ) ; $ engine = $ v [ 'engine' ] ; break ; } } $ versions = explode ( '.' , $ version ) ; $ version = $ versions [ 0 ] ; $ return -> class = $ os . ' ' . $ browser . ' ' . $ engine ; if ( $ version != '' ) { $ return -> class .= ' ' . $ shorty . $ version ; } if ( $ os == 'android' && $ engine != 'presto' && stripos ( $ ua , 'mobile' ) === false ) { $ mobile = false ; } if ( $ mobile ) { $ return -> class .= ' mobile' ; } $ return -> browser = $ browser ; $ return -> shorty = $ shorty ; $ return -> version = $ version ; $ return -> engine = $ engine ; $ return -> versions = $ versions ; $ return -> mobile = $ mobile ; return $ return ; }
9874	private function writeLegacyDrawing ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getComments ( ) ) > 0 ) { $ objWriter -> startElement ( 'legacyDrawing' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId_comments_vml1' ) ; $ objWriter -> endElement ( ) ; } }
9478	protected function getCalendarDayDownloads ( $ limit = 30 ) { $ arrCalendarDayDownloads = array ( ) ; $ CalendarDays = date ( 'Y-m-d' , mktime ( 0 , 0 , 0 , date ( "m" ) , date ( "d" ) - $ limit , date ( "Y" ) ) ) ; $ objCalendarDayDownloads = \ Database :: getInstance ( ) -> prepare ( "SELECT dl.`id` , FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) as datum , count(dl.`filename`) as downloads , dl.`filename` FROM `tl_dlstats` dl INNER JOIN `tl_dlstatdets` det on dl.id = det.pid WHERE FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) >=? GROUP BY dl.`id`, datum ORDER BY datum DESC, `filename`" ) -> execute ( $ CalendarDays ) ; while ( $ objCalendarDayDownloads -> next ( ) ) { $ viewDate = $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'dateFormat' ] , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; $ c4d = $ this -> check4details ( $ objCalendarDayDownloads -> id ) ; $ arrCalendarDayDownloads [ ] = array ( $ viewDate , $ objCalendarDayDownloads -> filename , $ this -> getFormattedNumber ( $ objCalendarDayDownloads -> downloads , 0 ) , $ objCalendarDayDownloads -> id , $ c4d , $ objCalendarDayDownloads -> downloads , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; } return $ arrCalendarDayDownloads ; }
3247	public function add ( $ item , $ quantity = 1 , $ quantityReset = false ) { if ( ! is_array ( $ item ) && ! $ item -> isShoppable ) return ; $ cartItem = $ this -> getItem ( is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku ) ; if ( empty ( $ cartItem ) ) { $ reflection = null ; if ( is_object ( $ item ) ) { $ reflection = new \ ReflectionClass ( $ item ) ; } $ cartItem = call_user_func ( Config :: get ( 'shop.item' ) . '::create' , [ 'user_id' => $ this -> user -> shopId , 'cart_id' => $ this -> attributes [ 'id' ] , 'sku' => is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku , 'price' => is_array ( $ item ) ? $ item [ 'price' ] : $ item -> price , 'tax' => is_array ( $ item ) ? ( array_key_exists ( 'tax' , $ item ) ? $ item [ 'tax' ] : 0 ) : ( isset ( $ item -> tax ) && ! empty ( $ item -> tax ) ? $ item -> tax : 0 ) , 'shipping' => is_array ( $ item ) ? ( array_key_exists ( 'shipping' , $ item ) ? $ item [ 'shipping' ] : 0 ) : ( isset ( $ item -> shipping ) && ! empty ( $ item -> shipping ) ? $ item -> shipping : 0 ) , 'currency' => Config :: get ( 'shop.currency' ) , 'quantity' => $ quantity , 'class' => is_array ( $ item ) ? null : $ reflection -> getName ( ) , 'reference_id' => is_array ( $ item ) ? null : $ item -> shopId , ] ) ; } else { $ cartItem -> quantity = $ quantityReset ? $ quantity : $ cartItem -> quantity + $ quantity ; $ cartItem -> save ( ) ; } $ this -> resetCalculations ( ) ; return $ this ; }
11424	public function lists ( $ nextOpenId = null ) { $ params = [ 'next_openid' => $ nextOpenId ] ; return $ this -> parseJSON ( 'get' , [ self :: API_LIST , $ params ] ) ; }
2503	public static function loadMessagesAndVersions ( $ wsdls ) { $ msgAndVer = [ ] ; foreach ( $ wsdls as $ wsdl ) { $ wsdlIdentifier = self :: makeWsdlIdentifier ( $ wsdl ) ; self :: $ wsdlIds [ $ wsdlIdentifier ] = $ wsdl ; self :: loadWsdlXpath ( $ wsdl , $ wsdlIdentifier ) ; $ operations = self :: $ wsdlDomXpath [ $ wsdlIdentifier ] -> query ( self :: XPATH_ALL_OPERATIONS ) ; if ( $ operations -> length === 0 ) { $ imports = self :: $ wsdlDomXpath [ $ wsdlIdentifier ] -> query ( self :: XPATH_IMPORTS ) ; $ operations = [ ] ; foreach ( $ imports as $ import ) { if ( ! empty ( $ import -> value ) ) { $ tmpMsg = self :: getMessagesAndVersionsFromImportedWsdl ( $ import -> value , $ wsdl , $ wsdlIdentifier ) ; foreach ( $ tmpMsg as $ msgName => $ msgInfo ) { $ msgAndVer [ $ msgName ] = $ msgInfo ; } } } } $ msgAndVer = array_merge ( $ msgAndVer , self :: loopOperationsWithQuery ( $ operations , self :: XPATH_VERSION_FOR_OPERATION , $ wsdlIdentifier , self :: $ wsdlDomXpath [ $ wsdlIdentifier ] ) ) ; } return $ msgAndVer ; }
9579	public function setChannel ( $ channel , LoggerInterface $ logger ) { if ( isset ( $ this -> channels [ $ channel ] ) ) { throw new InvalidArgumentException ( "Channel $channel is already defined" ) ; } $ this -> channels [ $ channel ] = $ logger ; }
3284	public function setFormatter ( $ formatter ) { if ( $ formatter === null ) { $ formatter = new SerializeFormatter ( ) ; } if ( ! $ formatter instanceof FormatterInterface ) { throw new Exception ( 'Formatter must be an instance of Flintstone\Formatter\FormatterInterface' ) ; } $ this -> config [ 'formatter' ] = $ formatter ; }
7706	function _ApplyDiffFromStart ( $ Diff ) { $ this -> pST_PosEnd += $ Diff ; $ this -> pST_Src = false ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; }
2636	public function getLastVersion ( ) { try { $ url = self :: CHECK_VERSION_URL ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> write ( \ Zend_Http_Client :: GET , $ url , '1.1' ) ; $ responseBody = $ client -> read ( ) ; $ client -> close ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; if ( $ responseCode !== 200 ) { return false ; } $ body = \ Zend_Http_Response :: extractBody ( $ responseBody ) ; $ json = json_decode ( $ body ) ; $ version = ! empty ( $ json -> version ) ? $ json -> version : false ; return $ version ; } catch ( \ Exception $ e ) { $ this -> _logger -> log ( 100 , $ e -> getMessage ( ) . $ url ) ; return false ; } }
6954	private function getGridForCountry ( CountryInterface $ country ) { if ( isset ( $ this -> grids [ $ country -> getId ( ) ] ) ) { return $ this -> grids [ $ country -> getId ( ) ] ; } $ grid = [ ] ; $ prices = $ this -> priceRepository -> findByCountry ( $ country ) ; foreach ( $ prices as $ price ) { $ method = $ price -> getMethod ( ) ; if ( ! isset ( $ grid [ $ method -> getId ( ) ] ) ) { $ gateway = $ this -> gatewayRegistry -> getGateway ( $ method -> getGatewayName ( ) ) ; $ grid [ $ method -> getId ( ) ] = [ 'method' => $ method , 'max_weight' => $ gateway -> getMaxWeight ( ) , 'prices' => [ ] , ] ; } $ grid [ $ method -> getId ( ) ] [ 'prices' ] [ ] = [ 'weight' => $ price -> getWeight ( ) , 'price' => $ price -> getNetPrice ( ) , ] ; } foreach ( $ grid as & $ method ) { usort ( $ method [ 'prices' ] , function ( $ a , $ b ) { if ( 0 === bccomp ( $ a [ 'weight' ] , $ b [ 'weight' ] , 3 ) ) { return 0 ; } return $ a [ 'weight' ] > $ b [ 'weight' ] ? 1 : - 1 ; } ) ; $ max = end ( $ method [ 'prices' ] ) [ 'weight' ] ; if ( 0 == $ method [ 'max_weight' ] || $ method [ 'max_weight' ] > $ max ) { $ method [ 'max_weight' ] = $ max ; } unset ( $ method ) ; } return $ this -> grids [ $ country -> getId ( ) ] = $ grid ; }
12491	public static function where ( $ field , $ operator , $ value , $ logical ) { if ( gettype ( $ field ) == "array" ) { throw new ClusterpointException ( "\"->where()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ operator === null ) { return "{$logical} {$field} " ; } elseif ( $ value === null ) { $ value = $ operator ; $ operator = '==' ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } if ( ! ( $ value instanceof Raw ) ) { if ( is_string ( $ value ) ) { $ value = '"' . Client :: escape ( $ value ) . '"' ; } else { $ value = json_encode ( $ value ) ; } } return "{$logical} {$field}{$operator}{$value} " ; }
6561	public static function getRelativePath ( $ path , $ start = null ) { if ( $ start === null ) { $ start = getcwd ( ) ; } if ( substr ( $ path , 0 , 1 ) !== '/' || substr ( $ start , 0 , 1 ) !== '/' ) { return false ; } $ pathParts = self :: splitPath ( $ path ) ; $ countPathParts = count ( $ pathParts ) ; $ startParts = self :: splitPath ( $ start ) ; $ countStartParts = count ( $ startParts ) ; $ commonLength = min ( $ countPathParts , $ countStartParts ) ; for ( $ i = 0 ; $ i < $ commonLength ; $ i ++ ) { if ( $ startParts [ $ i ] !== $ pathParts [ $ i ] ) { break ; } } $ relList = ( $ countStartParts > $ i ) ? array_fill ( 0 , $ countStartParts - $ i , '..' ) : [ ] ; $ relList = array_merge ( $ relList , array_slice ( $ pathParts , $ i ) ) ; return implode ( '/' , $ relList ) ? : '.' ; }
5428	public function getInterfaceMethods ( ) { $ methods = array ( ) ; $ interfaces = $ this -> getInterfaces ( ) ; foreach ( $ interfaces as $ interface ) { $ methods = array_merge ( $ methods , get_class_methods ( $ interface ) ) ; } return array_unique ( $ methods ) ; }
464	public function buildNotCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
6367	public function min ( Traversable $ traversable ) { $ array = iterator_to_array ( $ traversable , false ) ; Arrays :: sort ( $ array , $ this ) ; return Preconditions :: checkElementExists ( $ array , 0 ) ; }
8182	public function getDuration ( ) { if ( $ this -> isRoot ( ) && $ this -> profiles ) { $ duration = 0 ; foreach ( $ this -> profiles as $ profile ) { $ duration += $ profile -> getDuration ( ) ; } return $ duration ; } return isset ( $ this -> ends [ 'wt' ] ) && isset ( $ this -> starts [ 'wt' ] ) ? $ this -> ends [ 'wt' ] - $ this -> starts [ 'wt' ] : 0 ; }
12948	public function removeTagValues ( $ tags ) { $ this -> _tagsList = array_diff ( $ this -> getTagValues ( ) , $ this -> parseTags ( $ tags ) ) ; $ this -> updateOwnerTags ( ) ; }
4498	private function getTrimmedJson ( callable $ inner , int $ limit , string $ error ) : array { $ gcmInner = $ inner ( $ this -> text ) ; $ gcmInnerJson = json_encode ( $ gcmInner , JSON_UNESCAPED_UNICODE ) ; if ( ( $ gcmInnerJsonLength = \ strlen ( $ gcmInnerJson ) ) > $ limit ) { $ cut = $ gcmInnerJsonLength - $ limit ; if ( $ this -> text && ( $ textLength = \ strlen ( $ this -> text ) ) > $ cut && $ this -> allowTrimming ) { $ gcmInner = $ inner ( mb_strcut ( $ this -> text , 0 , $ textLength - $ cut - 3 , 'utf8' ) . '...' ) ; } else { throw new MessageTooLongException ( "$error $gcmInnerJson" ) ; } } return $ gcmInner ; }
2298	public static function findSearchablePages ( $ pid = 0 , $ domain = '' , $ blnIsSitemap = false ) { $ objPages = PageModel :: findPublishedByPid ( $ pid , array ( 'ignoreFePreview' => true ) ) ; if ( $ objPages === null ) { return array ( ) ; } $ arrPages = array ( ) ; foreach ( $ objPages as $ objPage ) { if ( $ objPage -> type == 'regular' ) { if ( ( ! $ objPage -> noSearch || $ blnIsSitemap ) && ( ! $ objPage -> protected || ( Config :: get ( 'indexProtected' ) && ( ! $ blnIsSitemap || $ objPage -> sitemap == 'map_always' ) ) ) && ( ! $ blnIsSitemap || $ objPage -> sitemap != 'map_never' ) && ! $ objPage -> requireItem ) { $ arrPages [ ] = $ objPage -> getAbsoluteUrl ( ) ; if ( ( $ objArticles = ArticleModel :: findPublishedWithTeaserByPid ( $ objPage -> id , array ( 'ignoreFePreview' => true ) ) ) !== null ) { foreach ( $ objArticles as $ objArticle ) { $ arrPages [ ] = $ objPage -> getAbsoluteUrl ( '/articles/' . ( $ objArticle -> alias ? : $ objArticle -> id ) ) ; } } } } if ( ( ! $ objPage -> protected || Config :: get ( 'indexProtected' ) ) && ( $ arrSubpages = static :: findSearchablePages ( $ objPage -> id , $ domain , $ blnIsSitemap ) ) ) { $ arrPages = array_merge ( $ arrPages , $ arrSubpages ) ; } } return $ arrPages ; }
4984	public function setParams ( array $ params ) { $ this -> params = array_merge ( $ this -> params , $ params ) ; foreach ( $ this -> forms as $ form ) { if ( isset ( $ form [ '__instance__' ] ) && is_object ( $ form [ '__instance__' ] ) && method_exists ( $ form [ '__instance__' ] , 'setParams' ) ) { $ form [ '__instance__' ] -> setParams ( $ params ) ; } } return $ this ; }
7018	private function format_h ( & $ str ) { if ( strstr ( $ str , '%h' ) ) { $ h = $ this -> hour > 12 ? $ this -> hour - 12 : $ this -> hour ; $ str = str_replace ( '%h' , sprintf ( '%02d' , $ h ) , $ str ) ; } }
12105	public function exception ( Exception $ exception ) { if ( $ this -> stopPropagation ) { return false ; } $ this -> fireHandlers ( $ exception ) ; $ this -> stopPropagation = true ; return false ; }
1066	private function doTypesConflict ( OutputType $ type1 , OutputType $ type2 ) { if ( $ type1 instanceof ListOfType ) { return $ type2 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof ListOfType ) { return $ type1 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type1 instanceof NonNull ) { return $ type2 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof NonNull ) { return $ type1 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( Type :: isLeafType ( $ type1 ) || Type :: isLeafType ( $ type2 ) ) { return $ type1 !== $ type2 ; } return false ; }
8093	public function get ( $ keyPath ) { $ stops = explode ( '.' , $ keyPath ) ; $ value = $ this ; foreach ( $ stops as $ key ) { if ( $ value instanceof Collection ) { $ value = $ value -> $ key ; } else { $ value = null ; break ; } } return $ value ; }
7084	public function delete_cookie ( $ name ) { unset ( $ _COOKIE [ $ name ] ) ; return setcookie ( $ name , null , - 86400 , $ this -> cookie_path , $ this -> cookie_domain , $ this -> cookie_secure , $ this -> cookie_httponly ) ; }
5625	public function getEncodedRequest ( ) { if ( $ this -> raw ) { $ encoded = $ this -> raw ; } else { $ encoded = $ this -> request -> asUrlRequest ( ) ; } if ( $ encoded ) { return '?' . preg_replace ( '/^\?/' , '' , $ encoded ) ; } return '' ; }
12691	protected function outputError ( $ errorNumber , $ test , $ exception ) { $ feature = null ; $ scenario = null ; $ testDescription = null ; $ node = $ test ; while ( $ node !== null ) { $ class = get_class ( $ node ) ; $ description = str_replace ( "\n " , "\n " , $ node -> getDescription ( ) ) ; if ( $ description === '' ) { $ node = $ node -> getParent ( ) ; continue ; } if ( $ class === 'Peridot\Core\Test' ) { $ testDescription = $ description ; } elseif ( $ class === 'Peridot\Core\Suite' ) { if ( strpos ( $ description , 'Feature:' ) === 0 ) { $ feature = $ description ; } else { $ scenario = trim ( $ description ) ; } } $ node = $ node -> getParent ( ) ; } if ( $ this -> lastFeature !== $ feature ) { $ this -> output -> writeln ( " " . $ feature . "\n" ) ; $ this -> lastFeature = $ feature ; $ this -> lastScenario = null ; } if ( $ this -> lastScenario !== $ scenario ) { $ this -> output -> writeln ( " " . $ scenario . "\n" ) ; $ this -> lastScenario = $ scenario ; } $ this -> output -> writeln ( $ this -> color ( 'error' , sprintf ( " %d) %s" , $ errorNumber , $ testDescription ) ) ) ; $ message = sprintf ( " %s" , str_replace ( "\n" , "\n " , $ exception -> getMessage ( ) ) ) ; $ this -> output -> writeln ( $ this -> color ( 'pending' , $ message ) ) ; $ class = method_exists ( $ exception , 'getClass' ) ? $ exception -> getClass ( ) : get_class ( $ exception ) ; $ trace = method_exists ( $ exception , 'getTrueTrace' ) ? $ exception -> getTrueTrace ( ) : $ exception -> getTrace ( ) ; array_unshift ( $ trace , [ 'function' => $ class . ' thrown' , 'file' => $ exception -> getFile ( ) , 'line' => $ exception -> getLine ( ) ] ) ; $ this -> outputTrace ( $ trace ) ; }
6422	public function getMenu ( $ level = 1 ) { if ( class_exists ( ContentController :: class ) ) { $ controller = ContentController :: singleton ( ) ; return $ controller -> getMenu ( $ level ) ; } }
7715	static function FindStartTagByPrefix ( & $ Txt , $ TagPrefix , $ PosBeg , $ Forward = true ) { $ x = '<' . $ TagPrefix ; $ xl = strlen ( $ x ) ; if ( $ Forward ) { $ PosBeg = strpos ( $ Txt , $ x , $ PosBeg ) ; } else { $ PosBeg = strrpos ( substr ( $ Txt , 0 , $ PosBeg + 2 ) , $ x ) ; } if ( $ PosBeg === false ) return false ; $ Tag = $ TagPrefix ; $ p = $ PosBeg + $ xl ; do { $ z = substr ( $ Txt , $ p , 1 ) ; if ( ( $ z !== ' ' ) && ( $ z !== "\r" ) && ( $ z !== "\n" ) && ( $ z !== '>' ) && ( $ z !== '/' ) ) { $ Tag .= $ z ; $ p ++ ; } else { $ p = false ; } } while ( $ p !== false ) ; return new clsTbsXmlLoc ( $ Txt , $ Tag , $ PosBeg ) ; }
6269	private function nameFromAcademicDomain ( $ domain ) { $ path = $ this -> getPath ( $ domain ) ; if ( ! file_exists ( $ path ) ) { return null ; } return trim ( file_get_contents ( $ path ) ) ; }
8314	protected function finishPasswordReset ( array $ resetData ) { if ( time ( ) > $ resetData [ 'validity' ] ) { $ this -> session -> remove ( "pwreset" ) ; $ this -> session -> addFlash ( "error" , "Page validity expired, please try again." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; } $ this -> picoAuth -> addOutput ( "isReset" , true ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/pwreset.md' ) ; $ post = $ this -> httpRequest -> request ; if ( $ post -> has ( "new_password" ) && $ post -> has ( "new_password_repeat" ) ) { $ newPassword = new Password ( $ post -> get ( "new_password" ) ) ; $ newPasswordRepeat = new Password ( $ post -> get ( "new_password_repeat" ) ) ; $ username = $ resetData [ 'user' ] ; if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( $ newPassword -> get ( ) !== $ newPasswordRepeat -> get ( ) ) { $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ newPassword ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ this -> session -> remove ( "pwreset" ) ; $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ newPassword ) ; $ this -> storage -> saveUser ( $ username , $ userData ) ; $ this -> logPasswordReset ( $ username ) ; $ localAuth -> login ( $ username , $ userData ) ; $ this -> picoAuth -> afterLogin ( ) ; } }
3591	public function setMeta ( $ key , $ value , $ group = null ) { $ this -> getMetaAttributes ( ) -> set ( $ key , $ value , $ group ) ; }
5473	public function isMatch ( $ widget ) { if ( method_exists ( $ widget , 'isLabel' ) ) { if ( $ widget -> isLabel ( $ this -> label ) ) { return true ; } } return ( $ widget -> getName ( ) == $ this -> label ) ; }
5648	public function paintMethodEnd ( $ test_name ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> paintMethodEnd ( $ test_name ) ; } }
12414	public function removeDevice ( $ groupId , array $ deviceIdentifiers ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'device_identifiers' => $ deviceIdentifiers , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_DEVICE , $ params ] ) ; }
12728	public function expectsOutcome ( IOutcomeRule $ rule , IOutcomeRule $ rule2 = null , IOutcomeRule $ rule3 = null , IOutcomeRule $ rule4 = null , IOutcomeRule $ rule5 = null , IOutcomeRule $ rule6 = null , IOutcomeRule $ rule7 = null , IOutcomeRule $ rule8 = null , IOutcomeRule $ rule9 = null , IOutcomeRule $ rule10 = null ) { foreach ( func_get_args ( ) as $ arg ) { if ( $ arg instanceof IInputRule ) { $ this -> outcomeRules [ ] = $ arg ; } } return $ this ; }
7428	public function renderObject ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> objectDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
3964	private function getJsonFile ( $ filename ) { if ( ! is_readable ( $ filename ) ) { return [ ] ; } $ contents = json_decode ( file_get_contents ( $ filename ) , true ) ; return $ contents ? : [ ] ; }
8631	public function setReportInfoList ( $ reportInfo ) { if ( ! $ this -> _isNumericArray ( $ reportInfo ) ) { $ reportInfo = array ( $ reportInfo ) ; } $ this -> fields [ 'ReportInfo' ] [ 'FieldValue' ] = $ reportInfo ; return $ this ; }
9982	private function writeVMLComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ pCellReference ) ; $ column = Coordinate :: columnIndexFromString ( $ column ) ; $ id = 1024 + $ column + $ row ; $ id = substr ( $ id , 0 , 4 ) ; $ objWriter -> startElement ( 'v:shape' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_s' . $ id ) ; $ objWriter -> writeAttribute ( 'type' , '#_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'style' , 'position:absolute;margin-left:' . $ pComment -> getMarginLeft ( ) . ';margin-top:' . $ pComment -> getMarginTop ( ) . ';width:' . $ pComment -> getWidth ( ) . ';height:' . $ pComment -> getHeight ( ) . ';z-index:1;visibility:' . ( $ pComment -> getVisible ( ) ? 'visible' : 'hidden' ) ) ; $ objWriter -> writeAttribute ( 'fillcolor' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> writeAttribute ( 'o:insetmode' , 'auto' ) ; $ objWriter -> startElement ( 'v:fill' ) ; $ objWriter -> writeAttribute ( 'color2' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shadow' ) ; $ objWriter -> writeAttribute ( 'on' , 't' ) ; $ objWriter -> writeAttribute ( 'color' , 'black' ) ; $ objWriter -> writeAttribute ( 'obscured' , 't' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'none' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:textbox' ) ; $ objWriter -> writeAttribute ( 'style' , 'mso-direction-alt:auto' ) ; $ objWriter -> startElement ( 'div' ) ; $ objWriter -> writeAttribute ( 'style' , 'text-align:left' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'x:ClientData' ) ; $ objWriter -> writeAttribute ( 'ObjectType' , 'Note' ) ; $ objWriter -> writeElement ( 'x:MoveWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:SizeWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:AutoFill' , 'False' ) ; $ objWriter -> writeElement ( 'x:Row' , ( $ row - 1 ) ) ; $ objWriter -> writeElement ( 'x:Column' , ( $ column - 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
6617	protected function mapRequestToArguments ( \ ReflectionMethod $ method , Request $ request ) { $ map = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { $ value = $ request -> getParameter ( $ parameter -> getName ( ) , $ parameter -> isDefaultValueAvailable ( ) ? $ parameter -> getDefaultValue ( ) : null ) ; if ( $ parameter -> getClass ( ) && $ parameter -> getClass ( ) -> implementsInterface ( Deserializable :: class ) ) { $ value = $ parameter -> getClass ( ) -> newInstanceWithoutConstructor ( ) -> ayeAyeDeserialize ( $ value ) ; $ className = $ parameter -> getClass ( ) -> getName ( ) ; if ( ! is_object ( $ value ) || get_class ( $ value ) !== $ className ) { throw new \ RuntimeException ( "$className::ayeAyeDeserialize did not return an instance of itself" ) ; } } $ map [ $ parameter -> getName ( ) ] = $ value ; } return $ map ; }
5764	public function routeIndexResetFilter ( Request $ request , Response $ response , $ args ) { return $ this -> indexViewObjects ( $ response , true ) ; }
4212	private static function filterConstantsByLevel ( $ constants , $ level ) { foreach ( $ constants as $ constantName => $ value ) { if ( ! self :: inBitmask ( $ value , $ level ) ) { unset ( $ constants [ $ constantName ] ) ; } } unset ( $ constants [ 'E_ALL' ] ) ; return $ constants ; }
9727	public function logRead ( $ format , $ path , $ callStartTime ) { $ callEndTime = microtime ( true ) ; $ callTime = $ callEndTime - $ callStartTime ; $ message = "Read {$format} format from <code>{$path}</code> in " . sprintf ( '%.4f' , $ callTime ) . ' seconds' ; $ this -> log ( $ message ) ; }
1381	protected function validateToMany ( array $ value , ? string $ field = null ) : bool { $ path = $ field ? "/data/relationships/{$field}/data" : "/data" ; $ valid = true ; foreach ( $ value as $ index => $ item ) { if ( ! $ this -> validateIdentifier ( $ item , $ path , $ index ) ) { $ valid = false ; continue ; } if ( $ this -> isNotFound ( $ item -> type , $ item -> id ) ) { $ this -> resourceDoesNotExist ( "{$path}/{$index}" ) ; $ valid = false ; } } return $ valid ; }
4193	protected function dumpProperties ( $ abs ) { $ label = \ count ( $ abs [ 'properties' ] ) ? 'properties' : 'no properties' ; if ( $ abs [ 'viaDebugInfo' ] ) { $ label .= ' <span class="text-muted">(via __debugInfo)</span>' ; } $ str = '<dt class="properties">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__get' , '__set' ) , \ array_keys ( $ abs [ 'methods' ] ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ abs [ 'properties' ] as $ k => $ info ) { $ vis = ( array ) $ info [ 'visibility' ] ; $ isPrivateAncestor = \ in_array ( 'private' , $ vis ) && $ info [ 'inheritedFrom' ] ; $ classes = \ array_keys ( \ array_filter ( array ( 'debuginfo-value' => $ info [ 'valueFrom' ] == 'debugInfo' , 'excluded' => $ info [ 'isExcluded' ] , 'forceShow' => $ info [ 'forceShow' ] , 'debug-value' => $ info [ 'valueFrom' ] == 'debug' , 'private-ancestor' => $ isPrivateAncestor , 'property' => true , \ implode ( ' ' , $ vis ) => $ info [ 'visibility' ] !== 'debug' , ) ) ) ; $ modifiers = $ vis ; if ( $ info [ 'isStatic' ] ) { $ modifiers [ ] = 'static' ; } $ str .= '<dd class="' . \ implode ( ' ' , $ classes ) . '">' . \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ( $ isPrivateAncestor ? ' (<i>' . $ info [ 'inheritedFrom' ] . '</i>)' : '' ) . ( $ info [ 'type' ] ? ' <span class="t_type">' . $ info [ 'type' ] . '</span>' : '' ) . ' <span class="property-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . $ k . '</span>' . ( $ info [ 'value' ] !== $ this -> debug -> abstracter -> UNDEFINED ? ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ info [ 'value' ] ) : '' ) . '</dd>' . "\n" ; } return $ str ; }
4573	public function getProperties ( Auditable $ entity ) { $ reflection = new ReflectionObject ( $ entity ) ; $ properties = [ ] ; foreach ( $ reflection -> getProperties ( ) as $ key => $ property ) { if ( ! $ this -> annotationReader -> getPropertyAnnotation ( $ property , AuditAnnotation :: class ) ) { continue ; } $ properties [ ] = $ property -> name ; } return $ properties ; }
4620	public function buildObject ( $ data = NULL , $ headers = NULL ) { $ this -> object = new RObject ( $ data , $ headers ) ; return $ this ; }
1568	public function getResourceId ( ) : ? string { if ( is_null ( $ this -> resourceId ) ) { return $ this -> parameter ( ResourceRegistrar :: PARAM_RESOURCE_ID ) ; } return $ this -> resourceId ? : null ; }
4778	public function addWidget ( ItemInterface $ item ) { if ( $ this -> checkRole ) { if ( $ item -> getRole ( ) && ! $ this -> security -> isGranted ( $ item -> getRole ( ) ) ) { return $ this ; } } $ this -> widgets [ $ item -> getId ( ) ] = $ item ; return $ this ; }
7109	static public function getRoundingIncrement ( $ currency ) { if ( isset ( static :: $ increments [ $ currency ] ) ) { return static :: $ increments [ $ currency ] ; } return static :: $ increments [ $ currency ] = static :: getCurrencyBundle ( ) -> getRoundingIncrement ( $ currency ) ; }
3930	private function buildProperty ( PropertiesDefinitionInterface $ definition , IAttribute $ attribute , array $ propInfo ) { if ( ! $ attribute ) { return ; } $ property = $ this -> getOrCreateProperty ( $ definition , $ attribute -> getColName ( ) ) ; $ this -> setLabel ( $ property , $ propInfo , $ attribute ) ; $ this -> setDescription ( $ property , $ propInfo ) ; $ this -> setDefaultValue ( $ property , $ propInfo ) ; $ this -> setExcluded ( $ property , $ propInfo ) ; $ this -> setSearchable ( $ property , $ propInfo ) ; $ this -> setFilterable ( $ property , $ propInfo ) ; $ this -> setWidgetType ( $ property , $ propInfo ) ; $ this -> setOptions ( $ property , $ propInfo ) ; $ this -> setExplanation ( $ property , $ propInfo ) ; $ this -> setEval ( $ property , $ propInfo , ( $ attribute instanceof ITranslated ) ) ; $ this -> setEmptyValue ( $ property , $ propInfo ) ; }
4702	protected function runHelp ( InputInterface $ input , OutputInterface $ output ) { $ help = $ this -> getApplication ( ) -> find ( 'help' ) ; $ help -> setCommand ( $ this ) ; $ help -> run ( $ input , $ output ) ; }
4334	public function getCfg ( $ path = null ) { if ( $ path == 'outputAs' ) { $ ret = $ this -> cfg [ 'outputAs' ] ; if ( ! $ ret ) { $ ret = $ this -> getDefaultOutputAs ( ) ; } } elseif ( $ path == 'css' ) { $ ret = $ this -> getCss ( ) ; } else { $ ret = $ this -> debug -> utilities -> arrayPathGet ( $ this -> cfg , $ path ) ; } return $ ret ; }
1926	public function countColors ( $ max = null ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return imagecolorstotal ( $ this -> gdResource ) ; } $ colors = array ( ) ; $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ colors [ imagecolorat ( $ this -> gdResource , $ x , $ y ) ] = true ; if ( $ max !== null && \ count ( $ colors ) > $ max ) { break 2 ; } } } return \ count ( $ colors ) ; }
1715	public function hasAccess ( $ field , $ array ) { if ( $ this -> isAdmin ) { return true ; } if ( ! \ is_array ( $ field ) ) { $ field = array ( $ field ) ; } if ( \ is_array ( $ this -> $ array ) && array_intersect ( $ field , $ this -> $ array ) ) { return true ; } elseif ( $ array == 'filemounts' ) { foreach ( $ this -> filemounts as $ folder ) { if ( preg_match ( '/^' . preg_quote ( $ folder , '/' ) . '(\/|$)/i' , $ field [ 0 ] ) ) { return true ; } } } return false ; }
10366	public function logout ( ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'logout' ) ) -> dispatchNow ( new LogoutJob ) ; return redirect ( ) -> route ( config ( '_auth.logout.redirect' ) ) ; }
1537	protected function fillRelationship ( $ record , $ field , array $ relationship , EncodingParametersInterface $ parameters ) { $ relation = $ this -> getRelated ( $ field ) ; $ relation -> update ( $ record , $ relationship , $ parameters ) ; }
616	public function setDefinitions ( array $ definitions ) { foreach ( $ definitions as $ class => $ definition ) { if ( is_array ( $ definition ) && count ( $ definition ) === 2 && array_values ( $ definition ) === $ definition ) { $ this -> set ( $ class , $ definition [ 0 ] , $ definition [ 1 ] ) ; continue ; } $ this -> set ( $ class , $ definition ) ; } }
7159	protected function compileKeyboard ( Keyboard $ keyboard ) { $ firstButton = collect ( $ keyboard -> getButtons ( ) ) -> first ( ) ; if ( $ firstButton instanceof PayloadButton || $ firstButton instanceof UrlButton ) { return $ this -> compileInlineKeyboard ( $ keyboard ) ; } return $ this -> compileReplyKeyboard ( $ keyboard ) ; }
10816	public static function write ( $ messages , $ style = '' , $ length = 0 , $ suffix = '' ) { if ( self :: $ silent ) { return ; } if ( ! is_array ( $ messages ) ) { $ messages = [ ( string ) $ messages ] ; } if ( count ( $ messages ) > 0 ) { foreach ( $ messages as $ message ) { if ( $ length > 0 ) { $ message = str_pad ( $ message , $ length , ' ' , STR_PAD_RIGHT ) ; } print ( Style :: applyStyle ( $ message , $ style ) ) ; if ( $ suffix != '' ) { print ( $ suffix ) ; } } } }
11602	public function getComponentRoot ( string $ name ) : ? string { $ rootMap = $ this -> getConfig ( 'componentsRootMap' ) ; return isset ( $ rootMap [ $ name ] ) ? $ this -> getAppRoot ( ) . $ rootMap [ $ name ] : null ; }
10418	public static function extract ( $ yamlArray , $ key , $ needed = false ) { if ( ! empty ( $ yamlArray ) && array_key_exists ( $ key , $ yamlArray ) ) return $ yamlArray [ $ key ] ; if ( $ needed ) { throw new \ Deployer \ Exception \ Exception ( 'Cannot find the setting: ' . $ key . '. This key needs to be given!' ) ; } return null ; }
8718	public static function forceCreateInLocale ( $ locale , array $ attributes , $ translations = [ ] ) { $ model = new static ; return static :: unguarded ( function ( ) use ( $ locale , $ model , $ attributes , $ translations ) { return $ model -> createInLocale ( $ locale , $ attributes , $ translations ) ; } ) ; }
2332	public function validator ( $ varInput ) { if ( ! \ is_array ( $ varInput ) ) { return null ; } foreach ( $ varInput as $ k => $ v ) { if ( $ k != 'language' ) { $ varInput [ $ k ] = array_map ( 'trim' , $ v ) ; } else { if ( $ v != '' ) { $ varInput [ $ v ] = array_combine ( array_keys ( $ this -> metaFields ) , array_fill ( 0 , \ count ( $ this -> metaFields ) , '' ) ) ; } unset ( $ varInput [ $ k ] ) ; } } return $ varInput ; }
7777	protected function extractFieldAliases ( array $ data ) { foreach ( $ data as $ field => $ fieldRules ) { $ extraction = explode ( '|' , $ field ) ; if ( isset ( $ extraction [ 1 ] ) ) { $ updatedField = $ extraction [ 0 ] ; $ alias = $ extraction [ 1 ] ; $ this -> fieldAliases [ $ updatedField ] = $ alias ; $ data [ $ updatedField ] = $ data [ $ field ] ; unset ( $ data [ $ field ] ) ; } } return $ data ; }
4627	protected function prepareRequestData ( ) { if ( in_array ( $ this -> command -> getMethod ( ) , [ 'POST' , 'PUT' ] ) ) { $ this -> requestBody = $ this -> command -> getEncodedData ( ) ; $ this -> options [ CURLOPT_POSTFIELDS ] = $ this -> requestBody ; } return $ this ; }
1095	public function children ( $ node ) { $ query = $ this -> node -> newQuery ( ) ; $ query -> where ( $ this -> node -> getQualifiedParentColumnName ( ) , '=' , $ node -> getKey ( ) ) ; foreach ( $ this -> scopedAttributes ( $ node ) as $ fld => $ value ) $ query -> where ( $ this -> qualify ( $ fld ) , '=' , $ value ) ; $ query -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) ; return $ query -> get ( ) ; }
3299	public function setHeaders ( array $ headers = [ ] ) { $ originHeaders = empty ( $ this -> headers ) ? [ ] : $ this -> headers ; $ this -> headers = array_merge ( $ originHeaders , $ headers ) ; return $ this ; }
9187	public static function embedCampaigns ( $ html , $ campaign = [ ] , $ additionalCampaigns = [ ] ) { $ pattern = '/<a(\s[^>]*)href="([^"]*)"([^>]*)>/si' ; $ html = preg_replace_callback ( $ pattern , function ( $ matches ) use ( $ campaign , $ additionalCampaigns ) { $ href = GoogleCampaignPlugin :: replaceLink ( $ matches [ 2 ] , $ campaign , $ additionalCampaigns ) ; return "<a{$matches[1]}href=\"{$href}\"{$matches[3]}>" ; } , $ html ) ; return $ html ; }
7639	public static function createResourceName ( $ containerName = '' , $ blobName = '' ) { $ resourceName = $ containerName . '/' . $ blobName ; if ( $ containerName === '' || $ containerName === '$root' ) { $ resourceName = $ blobName ; } if ( $ blobName === '' ) { $ resourceName = $ containerName ; } return $ resourceName ; }
1670	public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new self ( $ strParent ) ; } $ return = $ this -> Files -> rename ( $ this -> strFolder , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { $ this -> objModel = Dbafs :: moveResource ( $ this -> strFolder , $ strNewName ) ; } elseif ( $ syncSource ) { $ this -> objModel = Dbafs :: deleteResource ( $ this -> strFolder ) ; } elseif ( $ syncTarget ) { $ this -> objModel = Dbafs :: addResource ( $ strNewName ) ; } if ( $ return != false ) { $ this -> strFolder = $ strNewName ; } return $ return ; }
8295	public function open ( ) { if ( $ this -> isOpened ( ) ) { return ; } $ this -> handle = @ fopen ( $ this -> filePath , self :: OPEN_MODE ) ; if ( $ this -> handle === false ) { throw new \ RuntimeException ( "Could not open file for writing: " . $ this -> filePath ) ; } if ( ! $ this -> lock ( LOCK_EX ) ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not aquire an exclusive lock for " . $ this -> filePath ) ; } if ( $ this -> options [ "backup" ] ) { $ this -> createBkFile ( ) ; } $ this -> writeErrors = false ; }
1659	public static function create ( $ reply = null ) { $ suggestion = new self ( ) ; if ( $ reply ) { $ suggestion -> reply ( $ reply ) ; } return $ suggestion ; }
8497	public function getPackageTrackingDetails ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPackageTrackingDetails' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3655	private function getLabelText ( $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc.' . $ type , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc.' . $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc._default_' , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc._default_' ) { return $ type ; } } return $ label ; }
9659	public static function createReader ( $ readerType ) { if ( ! isset ( self :: $ readers [ $ readerType ] ) ) { throw new Reader \ Exception ( "No reader found for type $readerType" ) ; } $ className = self :: $ readers [ $ readerType ] ; $ reader = new $ className ( ) ; return $ reader ; }
6288	private function buildResponse ( ReactResponse $ response , StreamInterface $ body ) { $ body -> rewind ( ) ; return $ this -> responseFactory -> createResponse ( $ response -> getCode ( ) , $ response -> getReasonPhrase ( ) , $ response -> getHeaders ( ) , $ body , $ response -> getVersion ( ) ) ; }
12662	protected function contributorDefined ( ) { if ( null === $ this -> username && ! $ this -> configurationHandler -> isTheme ( ) ) { $ exception = array ( "message" => 'exception_contributor_not_defined' , "show_exception" => true , ) ; throw new LogicException ( json_encode ( $ exception ) ) ; } }
1698	private function loadFrontendUser ( string $ username , BackendUser $ backendUser ) : ? FrontendUser { try { $ frontendUser = $ this -> userProvider -> loadUserByUsername ( $ username ) ; if ( ! $ frontendUser instanceof FrontendUser ) { throw new UsernameNotFoundException ( 'User is not a front end user' ) ; } } catch ( UsernameNotFoundException $ e ) { if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'Could not find a front end user with the username "%s"' , $ username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , '' ) ] ) ; } return null ; } $ allowedGroups = StringUtil :: deserialize ( $ backendUser -> amg , true ) ; $ frontendGroups = StringUtil :: deserialize ( $ frontendUser -> groups , true ) ; if ( ! $ backendUser -> isAdmin && ! \ count ( array_intersect ( $ frontendGroups , $ allowedGroups ) ) ) { return null ; } return $ frontendUser ; }
2133	public static function persist ( $ strKey , $ varValue ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> add ( $ strKey , $ varValue ) ; }
7194	public static function get_thumbnail_file ( $ meta , $ size = 'medium' ) { if ( ! isset ( $ meta [ 'sizes' ] [ $ size ] ) ) { $ file = FALSE ; } else { $ dir = wp_upload_dir ( ) ; $ file_parts = array ( $ dir [ 'basedir' ] , dirname ( $ meta [ 'file' ] ) , $ meta [ 'sizes' ] [ $ size ] [ 'file' ] ) ; $ file = implode ( DIRECTORY_SEPARATOR , $ file_parts ) ; } return apply_filters ( 'iac_attach_media_thumbnail_file' , $ file , $ meta , $ size ) ; }
7066	public function getUserRights ( ) { if ( ! $ this -> _UserRights ) { if ( Configure :: load ( 'user_rights' ) === false ) { trigger_error ( 'UserRights: Could not load config/user_rights.php' , E_USER_WARNING ) ; } $ rightsConfig = Configure :: read ( 'user_rights' ) ; if ( ! is_array ( $ rightsConfig ) ) { $ rightsConfig = [ ] ; } $ this -> _UserRights = new UserRights ( $ rightsConfig ) ; } return $ this -> _UserRights ; }
9154	private function parseParameters ( \ ReflectionMethod $ action ) { $ params = $ action -> getParameters ( ) ; if ( count ( $ params ) < 1 ) { return false ; } $ param = $ params [ 0 ] ; assert ( $ param instanceof \ ReflectionParameter ) ; if ( ! ( $ class = $ param -> getClass ( ) ) || $ class -> getName ( ) != 'Nkey\Caribu\Mvc\Controller\Request' ) { return false ; } return true ; }
7833	protected function generatePipes ( ) { foreach ( $ this -> getPipesByOption ( 'attach' ) as $ pipe ) { $ this -> currentPipe = $ pipe ; parent :: fire ( ) ; } }
488	public static function getInstances ( $ model , $ attribute ) { $ name = Html :: getInputName ( $ model , $ attribute ) ; return static :: getInstancesByName ( $ name ) ; }
9647	public function whateverMatches ( string $ param ) : RouteBuilder { if ( array_key_exists ( $ param , $ this -> matchers ) ) { unset ( $ this -> matchers [ $ param ] ) ; } return $ this ; }
10398	protected function doReplacement ( $ inputString ) { if ( is_string ( $ inputString ) ) { $ inputString = str_replace ( array_keys ( $ this -> replacements ) , array_values ( $ this -> replacements ) , $ inputString ) ; } return $ inputString ; }
6368	private function parseWithMode ( $ raw_taf , $ strict ) { $ clean_taf = trim ( $ raw_taf ) ; $ clean_taf = preg_replace ( "#\n+#" , ' ' , $ clean_taf ) ; $ clean_taf = preg_replace ( "#\r+#" , ' ' , $ clean_taf ) ; $ clean_taf = preg_replace ( '#[ ]{2,}#' , ' ' , $ clean_taf ) . ' ' ; $ clean_taf = strtoupper ( $ clean_taf ) ; if ( strpos ( $ clean_taf , 'CNL' ) === false ) { $ remaining_taf = trim ( $ clean_taf ) . ' END' ; } else { $ remaining_taf = $ clean_taf ; } $ decoded_taf = new DecodedTaf ( $ clean_taf ) ; $ with_cavok = false ; foreach ( $ this -> decoder_chain as $ chunk_decoder ) { try { $ decoded = $ chunk_decoder -> parse ( $ remaining_taf , $ with_cavok ) ; $ result = $ decoded [ 'result' ] ; if ( $ result != null ) { foreach ( $ result as $ key => $ value ) { if ( $ value !== null ) { $ setter_name = 'set' . ucfirst ( $ key ) ; $ decoded_taf -> $ setter_name ( $ value ) ; } } } $ remaining_taf = $ decoded [ 'remaining_taf' ] ; } catch ( ChunkDecoderException $ cde ) { $ decoded_taf -> addDecodingException ( $ cde ) ; if ( $ strict ) { break ; } $ remaining_taf = $ cde -> getRemainingTaf ( ) ; } if ( $ chunk_decoder instanceof VisibilityChunkDecoder ) { $ with_cavok = $ decoded_taf -> getCavok ( ) ; } } $ evolutionDecoder = new EvolutionChunkDecoder ( $ strict , $ with_cavok ) ; while ( $ remaining_taf != null && trim ( $ remaining_taf ) != 'END' ) { $ evolutionDecoder -> parse ( $ remaining_taf , $ decoded_taf ) ; $ remaining_taf = $ evolutionDecoder -> getRemaining ( ) ; } return $ decoded_taf ; }
4869	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ helper = new DateFormat ( ) ; $ helper -> setLocale ( Locale :: DEFAULT_LOCALE ) ; return $ helper ; }
5040	public function setPermissions ( PermissionsInterface $ permissions ) { foreach ( $ this -> getImages ( ) as $ file ) { $ filePermissions = $ file -> getPermissions ( ) ; $ filePermissions -> clear ( ) ; $ filePermissions -> inherit ( $ permissions ) ; } return $ this ; }
12528	public function getLocalDataSource ( $ localModelClass ) { foreach ( $ this -> dataSources as $ dataSource ) { if ( $ dataSource -> localModel === $ localModelClass ) { return $ dataSource ; } } return false ; }
10838	protected function setRaw ( $ Key , $ Val , $ expire = 0 ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; return file_put_contents ( $ CacheFile , serialize ( $ Val ) ) > 0 ; }
5869	protected static function getVirtualFileObject ( $ fileName , array $ metadata ) { $ resourceFactory = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: class ) ; $ recordData = [ 'uid' => 0 , 'pid' => 0 , 'name' => 'Temporary Upload Storage' , 'description' => 'Internal storage, mounting the temporary PHP upload directory.' , 'driver' => 'Local' , 'processingfolder' => '' , 'configuration' => '' , 'is_online' => true , 'is_browsable' => false , 'is_public' => false , 'is_writable' => false , 'is_default' => false , ] ; $ storageConfiguration = [ 'basePath' => PathUtility :: dirname ( $ fileName ) , 'pathType' => 'absolute' ] ; $ virtualStorage = $ resourceFactory -> createStorageObject ( $ recordData , $ storageConfiguration ) ; $ name = PathUtility :: basename ( $ fileName ) ; $ extension = strtolower ( substr ( $ name , strrpos ( $ name , '.' ) + 1 ) ) ; $ virtualFileObject = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ File :: class , [ 'identifier' => '/' . $ name , 'name' => $ name , 'extension' => $ extension , ] , $ virtualStorage , $ metadata ) ; return $ virtualFileObject ; }
6348	public static function indexOf ( Iterator $ iterator , callable $ predicate ) : int { $ i = 0 ; while ( $ iterator -> valid ( ) ) { if ( Predicates :: call ( $ predicate , $ iterator -> current ( ) ) ) { return $ i ; } $ i ++ ; $ iterator -> next ( ) ; } return - 1 ; }
3024	public function getBlogPosts ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/posts' ) ; if ( $ options && isset ( $ options [ 'type' ] ) ) { $ path .= '/' . $ options [ 'type' ] ; unset ( $ options [ 'type' ] ) ; } return $ this -> getRequest ( $ path , $ options , true ) ; }
1119	public function scopeLimitDepth ( $ query , $ limit ) { $ depth = $ this -> exists ? $ this -> getDepth ( ) : $ this -> getLevel ( ) ; $ max = $ depth + $ limit ; $ scopes = array ( $ depth , $ max ) ; return $ query -> whereBetween ( $ this -> getDepthColumnName ( ) , array ( min ( $ scopes ) , max ( $ scopes ) ) ) ; }
10742	public function get ( $ keys , $ default = null ) { $ result = $ this -> data ; foreach ( is_array ( $ keys ) ? $ keys : [ $ keys ] as $ key ) { if ( is_array ( $ result ) && isset ( $ result [ $ key ] ) ) { $ result = $ result [ $ key ] ; } else { $ result = $ default ; break ; } } return $ result ; }
5860	public function getAllFileTypes ( ) { $ fileTypes = [ ] ; foreach ( $ this -> rulesets as $ ruleset ) { if ( is_array ( $ ruleset [ 'file_types' ] ) ) { $ fileTypes = array_merge ( $ fileTypes , $ ruleset [ 'file_types' ] ) ; } } $ fileTypes = array_unique ( $ fileTypes ) ; return $ fileTypes ; }
317	public function registerAssetBundle ( $ name , $ position = null ) { if ( ! isset ( $ this -> assetBundles [ $ name ] ) ) { $ am = $ this -> getAssetManager ( ) ; $ bundle = $ am -> getBundle ( $ name ) ; $ this -> assetBundles [ $ name ] = false ; $ pos = isset ( $ bundle -> jsOptions [ 'position' ] ) ? $ bundle -> jsOptions [ 'position' ] : null ; foreach ( $ bundle -> depends as $ dep ) { $ this -> registerAssetBundle ( $ dep , $ pos ) ; } $ this -> assetBundles [ $ name ] = $ bundle ; } elseif ( $ this -> assetBundles [ $ name ] === false ) { throw new InvalidConfigException ( "A circular dependency is detected for bundle '$name'." ) ; } else { $ bundle = $ this -> assetBundles [ $ name ] ; } if ( $ position !== null ) { $ pos = isset ( $ bundle -> jsOptions [ 'position' ] ) ? $ bundle -> jsOptions [ 'position' ] : null ; if ( $ pos === null ) { $ bundle -> jsOptions [ 'position' ] = $ pos = $ position ; } elseif ( $ pos > $ position ) { throw new InvalidConfigException ( "An asset bundle that depends on '$name' has a higher javascript file position configured than '$name'." ) ; } foreach ( $ bundle -> depends as $ dep ) { $ this -> registerAssetBundle ( $ dep , $ pos ) ; } } return $ bundle ; }
1594	protected function validateType ( ) : bool { if ( ! $ this -> dataHas ( 'type' ) ) { $ this -> memberRequired ( '/data' , 'type' ) ; return false ; } $ value = $ this -> dataGet ( 'type' ) ; if ( ! $ this -> validateTypeMember ( $ value , '/data' ) ) { return false ; } if ( $ this -> expectedType !== $ value ) { $ this -> resourceTypeNotSupported ( $ value ) ; return false ; } return true ; }
9119	public function registerController ( $ controller , $ applicationName = 'default' ) { if ( ! $ controller instanceof \ Nkey \ Caribu \ Mvc \ Controller \ AbstractController ) { if ( ! class_exists ( $ controller ) ) { throw new ControllerException ( "No such controller class {controller} found" , array ( 'controller' => $ controller ) ) ; } $ c = new $ controller ( ) ; if ( ! ( $ c instanceof AbstractController ) ) { throw new ControllerException ( "Controller {controller} is not in application scope" , array ( 'controller' => $ controller ) ) ; } } else { $ c = $ controller ; } $ settings = $ c -> getControllerSettings ( ) ; $ this -> controllers [ $ applicationName ] [ $ settings -> getControllerSimpleName ( ) ] = $ settings ; return $ this ; }
8085	public function addPredefinedError ( $ id , $ message = '' ) { if ( is_array ( $ id ) ) { $ this -> errorList = array_diff_key ( $ this -> errorList , $ id ) + $ id ; } else { $ this -> errorList [ $ id ] = $ message ; } }
1856	protected function getPageLayout ( $ objPage ) { $ objLayout = LayoutModel :: findByPk ( $ objPage -> layout ) ; if ( null === $ objLayout ) { $ this -> log ( 'Could not find layout ID "' . $ objPage -> layout . '"' , __METHOD__ , TL_ERROR ) ; throw new NoLayoutSpecifiedException ( 'No layout specified' ) ; } $ objPage -> hasJQuery = $ objLayout -> addJQuery ; $ objPage -> hasMooTools = $ objLayout -> addMooTools ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objPage , $ objLayout , $ this ) ; } } return $ objLayout ; }
6101	public function listPropertySets ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/propertysets' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new PropertySet ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
8503	public function setGetCompetitivePricingForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetCompetitivePricingForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8045	public static function select ( array $ readSockets = array ( ) , array $ writeSockets = array ( ) , array $ exceptSockets = array ( ) , $ sec = 0 , $ usec = 0 ) { $ out = array ( ) ; $ out [ 'read' ] = array ( ) ; $ out [ 'write' ] = array ( ) ; $ out [ 'except' ] = array ( ) ; if ( count ( $ readSockets ) === 0 ) { return $ out ; } $ readSocketsResources = array ( ) ; $ writeSocketsResources = array ( ) ; $ exceptSocketsResources = array ( ) ; $ readSockets = self :: createSocketsIndex ( $ readSockets , $ readSocketsResources ) ; $ writeSockets = self :: createSocketsIndex ( $ writeSockets , $ writeSocketsResources ) ; $ exceptSockets = self :: createSocketsIndex ( $ exceptSockets , $ exceptSocketsResources ) ; $ socketsSelected = @ socket_select ( $ readSocketsResources , $ writeSocketsResources , $ exceptSocketsResources , $ sec , $ usec ) ; if ( $ socketsSelected === FALSE ) { $ socketError = socket_last_error ( ) ; if ( $ socketError === SOCKET_EINTR ) { socket_clear_error ( ) ; $ socketsSelected = socket_select ( $ readSocketsResources , $ writeSocketsResources , $ exceptSocketsResources , $ sec , $ usec ) ; if ( $ socketsSelected === FALSE ) { return $ out ; } } else { trigger_error ( sprintf ( 'socket_select(): unable to select [%d]: %s' , $ socketError , socket_strerror ( $ socketError ) ) , E_USER_WARNING ) ; return $ out ; } } foreach ( $ readSocketsResources as $ socketResource ) { $ out [ 'read' ] [ ] = $ readSockets [ intval ( $ socketResource ) ] ; } foreach ( $ writeSocketsResources as $ socketResource ) { $ out [ 'write' ] [ ] = $ writeSockets [ intval ( $ socketResource ) ] ; } foreach ( $ exceptSocketsResources as $ socketResource ) { $ out [ 'except' ] [ ] = $ exceptSockets [ intval ( $ socketResource ) ] ; } return $ out ; }
2653	public function updateSnippet ( array $ snippet ) { $ url = $ this -> _getApiServiceUri ( ) . 'snippet' . '/' . $ snippet [ 'name' ] ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ snippet ) ; return $ result ; }
1643	public function getCenter ( ) : Coordinate { $ centerLat = ( $ this -> getNorth ( ) + $ this -> getSouth ( ) ) / 2 ; return new Coordinate ( $ centerLat , $ this -> getCenterLng ( ) ) ; }
4613	public function withScalarValue ( $ value ) { $ this -> match = $ value ; $ this -> lowerBound = null ; $ this -> upperBound = null ; return $ this ; }
8154	public function addFunction ( $ name , $ function = null ) { if ( ! $ name instanceof Twig_SimpleFunction && ! ( $ function instanceof Twig_SimpleFunction || $ function instanceof Twig_FunctionInterface ) ) { throw new LogicException ( 'A function must be an instance of Twig_FunctionInterface or Twig_SimpleFunction.' ) ; } if ( $ name instanceof Twig_SimpleFunction ) { $ function = $ name ; $ name = $ function -> getName ( ) ; } else { @ trigger_error ( sprintf ( 'Passing a name as a first argument to the %s method is deprecated since version 1.21. Pass an instance of "Twig_SimpleFunction" instead when defining function "%s".' , __METHOD__ , $ name ) , E_USER_DEPRECATED ) ; } if ( $ this -> extensionInitialized ) { throw new LogicException ( sprintf ( 'Unable to add function "%s" as extensions have already been initialized.' , $ name ) ) ; } $ this -> staging -> addFunction ( $ name , $ function ) ; }
4430	protected function writeInstallerSummary ( $ errors ) { if ( ! $ errors ) { $ this -> writeSection ( 'You can now continue installation as per instructions in the README.md file!' ) ; return ; } $ this -> writeSection ( array ( 'The command was not able to install everything automatically.' , 'You must do the following changes manually.' , ) , 'error' ) ; $ this -> output -> writeln ( $ errors ) ; }
478	public function dropColumn ( $ table , $ column ) { $ time = $ this -> beginCommand ( "drop column $column from table $table" ) ; $ this -> db -> createCommand ( ) -> dropColumn ( $ table , $ column ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
8469	public function emergency ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'emergency' , $ scope , $ message , $ context , $ config ) ; }
4419	protected function checkPermissions ( ) { if ( $ this -> isGranted ( 'ROLE_NGBM_EDITOR' ) ) { return ; } if ( $ this -> isGranted ( 'nglayouts:ui:access' ) ) { return ; } $ exception = $ this -> createAccessDeniedException ( ) ; $ exception -> setAttributes ( 'nglayouts:ui:access' ) ; throw $ exception ; }
2144	public function onBadCredentials ( User $ user , AuthenticationException $ exception ) : AuthenticationException { -- $ user -> loginCount ; if ( $ user -> loginCount > 0 ) { $ user -> save ( ) ; return new BadCredentialsException ( sprintf ( 'Invalid password submitted for username "%s"' , $ user -> username ) , $ exception -> getCode ( ) , $ exception ) ; } $ user -> locked = time ( ) + $ this -> options [ 'lock_period' ] ; $ user -> loginCount = $ this -> options [ 'login_attempts' ] ; $ user -> save ( ) ; $ lockedSeconds = $ user -> locked - time ( ) ; $ lockedMinutes = ( int ) ceil ( $ lockedSeconds / 60 ) ; $ exception = new LockedException ( $ lockedSeconds , sprintf ( 'User "%s" has been locked for %s minutes' , $ user -> username , $ lockedMinutes ) , 0 , $ exception ) ; $ exception -> setUser ( $ user ) ; return $ exception ; }
8794	protected function writeNewEnvironmentFileWith ( $ key ) { file_put_contents ( base_path ( '.env' ) , preg_replace ( $ this -> keyReplacementPattern ( ) , 'APP_KEY=' . $ key , file_get_contents ( base_path ( '.env' ) ) ) ) ; }
2035	public function onUnregister ( Registry $ registry ) { parent :: onUnregister ( $ registry ) ; if ( $ this -> fallback && $ this -> type == 'root' && $ registry -> isRegisteredAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ) { $ registry -> unregisterAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ; } }
7101	static public function getClasses ( $ type ) { switch ( $ type ) { case static :: TYPE_FORM : return [ CartInterface :: class ] ; case static :: TYPE_QUOTE : return [ QuoteInterface :: class ] ; case static :: TYPE_PROFORMA : return [ QuoteInterface :: class , OrderInterface :: class ] ; case static :: TYPE_CONFIRMATION : return [ OrderInterface :: class ] ; case static :: TYPE_VOUCHER : return [ ] ; default : throw new InvalidArgumentException ( "Unexpected type '$type'." ) ; } }
1541	public function withQualifiedKeyName ( $ keyName ) { $ parts = explode ( '.' , $ keyName ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withIdentifierColumn ( $ parts [ 1 ] ) ; return $ this ; }
9237	private function getAmbiguityExceptionMessage ( array $ paths , Vertex $ startVertex , Vertex $ endVertex ) { $ textPaths = [ ] ; $ i = 1 ; foreach ( $ paths as $ path ) { $ textPaths [ ] = 'Path ' . $ i . ': ' . $ this -> getTextualPath ( $ path , $ startVertex ) ; ++ $ i ; } $ msg = sprintf ( "There are many possible shortest paths between table '%s' and table '%s'\n\n" , $ startVertex -> getId ( ) , $ endVertex -> getId ( ) ) ; $ msg .= implode ( "\n\n" , $ textPaths ) ; return $ msg ; }
8734	public function increment ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> increment ( $ column , $ amount , $ extra ) ; }
7873	public function credit ( ) : ? array { $ this -> checkConfig ( ) ; $ query = http_build_query ( [ 'userkey' => $ this -> userkey , 'passkey' => $ this -> passkey , ] ) ; $ response = Request :: get ( $ this -> baseUrl . '/smsapibalance.php?' . $ query ) ; $ xml = simplexml_load_string ( $ response -> body ) ; $ body = json_decode ( json_encode ( $ xml ) , true ) ; return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ body [ 'message' ] [ 'text' ] ?? '' , 'data' => $ body , ] ; }
8135	public function displayBlock ( $ name , $ context = array ( ) ) { $ this -> template -> displayBlock ( $ name , $ this -> env -> mergeGlobals ( $ context ) ) ; }
2075	public function purgeVersionTable ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_version" ) ; $ this -> log ( 'Purged the version table' , __METHOD__ , TL_CRON ) ; }
2865	public function getLoggedContent ( $ logFile ) { if ( ! array_key_exists ( $ logFile , $ this -> ranges ) ) { throw new Exception ( 'Invalid log file' ) ; } return $ this -> getContent ( $ this -> getLogFilePath ( $ logFile ) , $ this -> ranges [ $ logFile ] [ 'start' ] , $ this -> ranges [ $ logFile ] [ 'end' ] ) ; }
10112	private function writeRangeProtection ( ) { foreach ( $ this -> phpSheet -> getProtectedCells ( ) as $ range => $ password ) { $ cellRanges = explode ( ' ' , $ range ) ; $ cref = count ( $ cellRanges ) ; $ recordData = pack ( 'vvVVvCVvVv' , 0x0868 , 0x00 , 0x0000 , 0x0000 , 0x02 , 0x0 , 0x0000 , $ cref , 0x0000 , 0x00 ) ; foreach ( $ cellRanges as $ cellRange ) { $ recordData .= $ this -> writeBIFF8CellRangeAddressFixed ( $ cellRange ) ; } $ recordData .= pack ( 'VV' , 0x0000 , hexdec ( $ password ) ) ; $ recordData .= StringHelper :: UTF8toBIFF8UnicodeLong ( 'p' . md5 ( $ recordData ) ) ; $ length = strlen ( $ recordData ) ; $ record = 0x0868 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; } }
11609	public function actionDisconnect ( $ id ) { $ account = $ this -> finder -> findAccountById ( $ id ) ; if ( $ account === null ) { throw new NotFoundHttpException ; } if ( $ account -> user_id != \ Yii :: $ app -> user -> id ) { throw new ForbiddenHttpException ; } $ account -> delete ( ) ; return $ this -> redirect ( [ 'networks' ] ) ; }
10349	public function validateArgSet ( $ set ) { if ( isset ( $ set ) ) { foreach ( $ set as $ arg ) { if ( ! isset ( $ this -> { $ arg } ) ) { throw new \ Exception ( 'Response not valid: ' . $ arg . ' has not been set!' ) ; } } } }
3116	public function setCatValue ( $ testSessionId , $ assessmentSectionId , $ key , $ value ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setCatValue ( $ assessmentSectionId , $ key , $ value ) ; $ extendedState -> save ( ) ; }
10001	public function add ( callable $ decorator , $ priority = 0 ) { $ this -> stack [ ] = array ( 'decorator' => $ decorator , 'priority' => $ priority , 'index' => $ this -> index ) ; $ this -> index -- ; uasort ( $ this -> stack , array ( $ this , 'compareStackItems' ) ) ; return $ this ; }
1792	private function addHostToContext ( RequestContext $ context , array $ parameters , int & $ referenceType ) : void { [ $ host , $ port ] = $ this -> getHostAndPort ( $ parameters [ '_domain' ] ) ; if ( $ context -> getHost ( ) === $ host ) { return ; } $ context -> setHost ( $ host ) ; $ referenceType = UrlGeneratorInterface :: ABSOLUTE_URL ; if ( ! $ port ) { return ; } if ( isset ( $ parameters [ '_ssl' ] ) && true === $ parameters [ '_ssl' ] ) { $ context -> setHttpsPort ( $ port ) ; } else { $ context -> setHttpPort ( $ port ) ; } }
6389	public function readFacetofaceSession ( $ id ) { $ model = $ this -> readObject ( $ id , 'facetoface_sessions' ) ; $ model -> dates = $ this -> readStoreRecords ( 'facetoface_sessions_dates' , [ 'sessionid' => $ id ] ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/facetoface/signup.php?s=' . $ id ; return $ model ; }
4663	public function smtp ( array $ params ) { if ( ! array_key_exists ( 'username' , $ params ) ) { throw new Exception ( 'We need a username' ) ; } if ( ! array_key_exists ( 'password' , $ params ) ) { throw new Exception ( 'We need a password' ) ; } $ this -> smtp = $ params ; $ this -> auth = true ; return $ this ; }
5543	public function getFrames ( ) { $ report = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ report [ $ this -> getPublicNameFromIndex ( $ i ) ] = $ this -> frames [ $ i ] -> getFrames ( ) ; } return $ report ; }
9190	public function render ( array $ classes = [ ] , $ autoEscape = null ) { $ divOpen = '<div class="' . $ this -> divClass . '">' ; $ divClose = '</div>' ; $ hasMessages = false ; foreach ( $ this -> classes as $ namespace => $ namespaceClasses ) { $ namespaceClasses = ArrayUtils :: merge ( $ namespaceClasses , $ classes ) ; if ( $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> hasCurrentMessages ( $ namespace ) ) { $ hasMessages = true ; $ divOpen .= $ this -> getFlashMessengerHelper ( ) -> renderCurrent ( $ namespace , $ namespaceClasses , $ autoEscape ) ; $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> clearCurrentMessagesFromNamespace ( $ namespace ) ; } elseif ( $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> hasMessages ( $ namespace ) ) { $ hasMessages = true ; $ divOpen .= $ this -> getFlashMessengerHelper ( ) -> render ( $ namespace , $ namespaceClasses , $ autoEscape ) ; } } return $ hasMessages ? $ divOpen . $ divClose : '' ; }
9361	public function norm ( ) { if ( $ this -> original ) { return $ this -> original -> rho ; } return sqrt ( pow ( $ this -> float_r , 2 ) + pow ( $ this -> float_i , 2 ) ) ; }
2248	public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ query = new Query ( Environment :: get ( 'queryString' ) ) ; $ query = $ query -> withoutPairs ( array_merge ( array ( 'rt' , 'ref' ) , $ arrUnset ) ) ; $ query = $ query -> merge ( str_replace ( '&amp;' , '&' , $ strRequest ) ) ; if ( isset ( $ _GET [ 'ref' ] ) || ( $ strRequest != '' && $ blnAddRef ) ) { $ query = $ query -> merge ( 'ref=' . System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) ) ; } $ uri = $ query -> getUriComponent ( ) ; if ( strpos ( $ strRequest , '%2B' ) !== false ) { $ uri = str_replace ( '+' , '%2B' , $ uri ) ; } return TL_SCRIPT . ampersand ( $ uri ) ; }
8590	public function setGetMatchingProductResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMatchingProductResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12561	public function send ( $ msgType , $ message , $ to = null ) { $ message = ( new MessageBuilder ( ) ) -> msgType ( $ msgType ) -> message ( $ message ) -> to ( $ to ) -> build ( ) ; $ api = is_array ( $ to ) ? self :: API_SEND_BY_OPENID : self :: API_SEND_BY_GROUP ; return $ this -> post ( $ api , $ message ) ; }
5136	public static function handleShutdown ( ) { if ( ! empty ( $ error = error_get_last ( ) ) ) { self :: handleException ( new FatalException ( $ error [ 'message' ] , $ error [ 'type' ] , 0 , $ error [ 'file' ] , $ error [ 'line' ] ) ) ; } }
10697	public function send ( ResponseInterface $ response ) : ResponseInterface { $ response -> getBody ( ) -> write ( json_encode ( $ this -> toArray ( ) ) ) ; return $ response -> withHeader ( 'Content-Type' , self :: MIME_TYPE_JSON ) ; }
9543	public function getMessages ( ) { $ messages = array ( ) ; if ( ! empty ( $ this -> error ) ) { $ messages [ ] = $ this -> error ; } if ( ! empty ( $ this -> warning ) ) { $ messages [ ] = $ this -> warning ; } return $ messages ; }
11174	public static function hash ( $ string , $ algorithm = 'blowfish' ) { switch ( strtolower ( $ algorithm ) ) : case ( 'md5' ) : $ salt = '$1$' . ( static :: rand ( 12 ) ) . '$' ; break ; case ( 'sha256' ) : $ salt = '$5$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'sha512' ) : $ salt = '$6$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'blowfish' ) : default : $ salt = '$2a$09$' . ( static :: rand ( 22 ) ) . '$' ; break ; endswitch ; return base64_encode ( crypt ( $ string , $ salt ) ) ; }
4777	public function getOutput ( ItemInterface $ item , $ userId ) { if ( $ item -> getCacheTime ( ) ) { $ cache = $ this -> cache -> getItem ( $ item -> getId ( ) . $ userId ) ; $ cache -> expiresAfter ( $ item -> getCacheTime ( ) ) ; if ( false === $ cache -> isHit ( ) ) { $ cache -> set ( $ item -> getTemplate ( ) ? $ this -> engine -> render ( $ item -> getTemplate ( ) , [ 'widget' => $ item ] ) : $ item -> getContent ( ) ) ; $ this -> cache -> save ( $ cache ) ; } return $ cache -> get ( ) ; } return $ item -> getTemplate ( ) ? $ this -> engine -> render ( $ item -> getTemplate ( ) , [ 'widget' => $ item ] ) : $ item -> getContent ( ) ; }
8961	public static function fromMinkResponse ( \ Behat \ Mink \ Session $ session ) { return self :: newInstance ( ) -> makeMinkResponseCSVTableParser ( ) -> parse ( $ session ) ; }
1037	private function completeObjectValue ( ObjectType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ isTypeOf = $ returnType -> isTypeOf ( $ result , $ this -> exeContext -> contextValue , $ info ) ; if ( $ isTypeOf !== null ) { $ promise = $ this -> getPromise ( $ isTypeOf ) ; if ( $ promise ) { return $ promise -> then ( function ( $ isTypeOfResult ) use ( $ returnType , $ fieldNodes , $ path , & $ result ) { if ( ! $ isTypeOfResult ) { throw $ this -> invalidReturnTypeError ( $ returnType , $ result , $ fieldNodes ) ; } return $ this -> collectAndExecuteSubfields ( $ returnType , $ fieldNodes , $ path , $ result ) ; } ) ; } if ( ! $ isTypeOf ) { throw $ this -> invalidReturnTypeError ( $ returnType , $ result , $ fieldNodes ) ; } } return $ this -> collectAndExecuteSubfields ( $ returnType , $ fieldNodes , $ path , $ result ) ; }
9658	public static function createWriter ( Spreadsheet $ spreadsheet , $ writerType ) { if ( ! isset ( self :: $ writers [ $ writerType ] ) ) { throw new Writer \ Exception ( "No writer found for type $writerType" ) ; } $ className = self :: $ writers [ $ writerType ] ; $ writer = new $ className ( $ spreadsheet ) ; return $ writer ; }
10397	protected function processDiscriminatorMap ( ClassMetadataInfo $ metadata ) { $ newMap = [ ] ; foreach ( $ metadata -> discriminatorMap as $ mapId => $ mappedEntityName ) { $ newKey = $ this -> doReplacement ( $ mapId ) ; $ newMap [ $ newKey ] = $ mappedEntityName ; } $ metadata -> discriminatorMap = $ newMap ; }
7347	static public function calculateDeliveryRemainingQuantity ( $ item ) { if ( $ item instanceof SupplierOrderItemInterface ) { return $ item -> getQuantity ( ) - static :: calculateReceivedQuantity ( $ item ) ; } if ( ! $ item instanceof SupplierDeliveryItemInterface ) { throw new InvalidArgumentException ( "Expected instance of " . SupplierOrderItemInterface :: class . " or " . SupplierDeliveryItemInterface :: class ) ; } $ orderItem = $ item -> getOrderItem ( ) ; $ result = $ orderItem -> getQuantity ( ) - static :: calculateReceivedQuantity ( $ orderItem ) ; if ( 0 < $ item -> getQuantity ( ) ) { $ result += $ item -> getQuantity ( ) ; } return $ result ; }
9882	private function writeSheet ( XMLWriter $ objWriter , $ pSheetname , $ pSheetId = 1 , $ pRelId = 1 , $ sheetState = 'visible' ) { if ( $ pSheetname != '' ) { $ objWriter -> startElement ( 'sheet' ) ; $ objWriter -> writeAttribute ( 'name' , $ pSheetname ) ; $ objWriter -> writeAttribute ( 'sheetId' , $ pSheetId ) ; if ( $ sheetState != 'visible' && $ sheetState != '' ) { $ objWriter -> writeAttribute ( 'state' , $ sheetState ) ; } $ objWriter -> writeAttribute ( 'r:id' , 'rId' . $ pRelId ) ; $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
1968	public static function findByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; if ( Validator :: isStringUuid ( $ intPid ) ) { $ intPid = StringUtil :: uuidToBin ( $ intPid ) ; } return static :: findBy ( array ( "$t.pid=UNHEX(?)" ) , bin2hex ( $ intPid ) , $ arrOptions ) ; }
12430	public function sort ( $ key , $ order = Sortable :: ASC ) { $ this -> criteria -> sort ( $ key , $ order ) ; return $ this ; }
6842	public function produce ( $ key , $ params = array ( ) , $ enable_reflect = true ) { if ( isset ( $ this -> data [ $ key ] ) ) return $ this -> data [ $ key ] ; if ( isset ( $ this -> caches [ $ key ] ) ) return $ this -> caches [ $ key ] ; if ( isset ( $ this -> objects [ $ key ] ) ) { $ obj = $ this -> get ( $ key ) ; $ concrete = $ obj [ self :: INDEX_CONCRETE ] ; } else { if ( $ this -> MUST_REG || ! $ enable_reflect ) { throw new InjectorException ( "$key not registered" ) ; } else { $ concrete = $ key ; $ not_reg = true ; } } $ result = $ this -> build ( $ concrete , $ params ) ; if ( $ not_reg === true || $ obj [ self :: INDEX_CACHED ] === true ) { $ this -> caches [ $ key ] = $ result ; } return $ result ; }
1260	protected function createAccess ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ accessRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AccessRequest' ) ) ; $ accessRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'AccessLicenseNumber' , $ this -> accessKey ) ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'UserId' , $ this -> userId ) ) ; $ p = $ accessRequest -> appendChild ( $ xml -> createElement ( 'Password' ) ) ; $ p -> appendChild ( $ xml -> createTextNode ( $ this -> password ) ) ; return $ xml -> saveXML ( ) ; }
3815	protected function process ( $ table , $ metaModelName , $ parentId , Request $ request ) { $ this -> knownAttributes = $ this -> fetchExisting ( $ table , $ parentId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; if ( ! $ metaModel ) { throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelName ) ; } if ( $ request -> request -> has ( 'add' ) || $ request -> request -> has ( 'saveNclose' ) ) { $ this -> perform ( $ table , $ request , $ metaModel , $ parentId ) ; if ( $ request -> request -> has ( 'saveNclose' ) ) { return new RedirectResponse ( $ this -> getReferer ( $ request , $ table , false ) ) ; } } return new Response ( $ this -> templating -> render ( 'MetaModelsCoreBundle::Backend/add-all.html.twig' , $ this -> render ( $ table , $ metaModel , $ request ) ) ) ; }
4933	public function loadEntities ( $ entity , $ id = null ) { $ params = $ this -> options ; $ params [ 'id' ] = $ id ; $ params [ 'repositories' ] = $ this -> repositories ; $ event = $ this -> loadEntitiesEvents -> getEvent ( $ entity , $ this , $ params ) ; $ responses = $ this -> loadEntitiesEvents -> triggerEventUntil ( function ( $ response ) { return ( is_array ( $ response ) || $ response instanceof \ Traversable ) && count ( $ response ) ; } , $ event ) ; $ entities = $ responses -> last ( ) ; return $ entities ; }
387	public function setAttributeOrders ( $ attributeOrders , $ validate = true ) { if ( $ attributeOrders === null || ! $ validate ) { $ this -> _attributeOrders = $ attributeOrders ; } else { $ this -> _attributeOrders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ order ) { if ( isset ( $ this -> attributes [ $ attribute ] ) ) { $ this -> _attributeOrders [ $ attribute ] = $ order ; if ( ! $ this -> enableMultiSort ) { break ; } } } } }
10520	public function constraint ( $ string ) { if ( ! isset ( $ this -> tbl_constraint [ 'other' ] ) ) { $ this -> tbl_constraint [ 'other' ] = [ ] ; } $ this -> tbl_constraint [ 'other' ] [ ] = $ string ; return $ this ; }
4385	protected function dumpObject ( $ abs ) { $ isNested = $ this -> valueDepth > 0 ; $ this -> valueDepth ++ ; if ( $ abs [ 'isRecursion' ] ) { $ str = '(object) ' . $ abs [ 'className' ] . ' *RECURSION*' ; } elseif ( $ abs [ 'isExcluded' ] ) { $ str = '(object) ' . $ abs [ 'className' ] . ' (not inspected)' ; } else { $ str = '(object) ' . $ abs [ 'className' ] . "\n" ; $ str .= $ this -> dumpProperties ( $ abs ) ; if ( $ abs [ 'collectMethods' ] && $ this -> debug -> output -> getCfg ( 'outputMethods' ) ) { $ str .= $ this -> dumpMethods ( $ abs [ 'methods' ] ) ; } } $ str = \ trim ( $ str ) ; if ( $ isNested ) { $ str = \ str_replace ( "\n" , "\n " , $ str ) ; } return $ str ; }
11914	public function addDynamic ( $ name , $ factory , $ createDefault = 0 , $ forceDefault = false ) { $ control = new RContainer ( $ factory , $ createDefault , $ forceDefault ) ; $ control -> currentGroup = $ this -> currentGroup ; return $ this [ $ name ] = $ control ; }
10800	public function renderPageHistoricTableAction ( ) { $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ melisKey = $ this -> params ( ) -> fromRoute ( 'melisKey' , '' ) ; $ melisTool = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreTool' ) ; $ melisTool -> setMelisToolKey ( self :: PLUGIN_INDEX , self :: TOOL_KEY ) ; $ columns = $ melisTool -> getColumns ( ) ; $ idPage = $ this -> params ( ) -> fromRoute ( 'idPage' , $ this -> params ( ) -> fromQuery ( 'idPage' , '' ) ) ; $ container = new Container ( 'meliscore' ) ; $ locale = $ container [ 'melis-lang-locale' ] ; $ view = new ViewModel ( ) ; $ view -> melisKey = $ melisKey ; $ view -> tableColumns = $ columns ; $ view -> getToolDataTableConfig = $ melisTool -> getDataTableConfiguration ( '#tableHistoricPageId' . $ idPage , true ) ; $ view -> idPage = $ idPage ; $ view -> tableId = 'tableHistoricPageId' . $ idPage ; return $ view ; }
9757	function below ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , lessThan ( $ value ) ) ; }
6632	public function requestAccessToken ( $ code ) { if ( ! $ code || empty ( $ code ) ) { throw new InvalidFacebookCodeException ( ) ; } $ request = [ 'url' => $ this -> settings [ 'token_url' ] , 'params' => [ 'client_id' => $ this -> settings [ 'api_key' ] , 'redirect_uri' => $ this -> settings [ 'redirect_uri' ] , 'client_secret' => $ this -> settings [ 'secret' ] , 'code' => $ code , 'format' => 'json' , ] , ] ; return $ this -> access_token -> make ( $ this -> http -> get ( $ request ) ) ; }
10017	public function addNamedRange ( NamedRange $ namedRange ) { if ( $ namedRange -> getScope ( ) == null ) { $ this -> namedRanges [ $ namedRange -> getName ( ) ] = $ namedRange ; } else { $ this -> namedRanges [ $ namedRange -> getScope ( ) -> getTitle ( ) . '!' . $ namedRange -> getName ( ) ] = $ namedRange ; } return true ; }
1480	private function flip ( array $ resources ) { $ all = [ ] ; foreach ( $ resources as $ resourceType => $ types ) { foreach ( ( array ) $ types as $ type ) { $ all [ $ type ] = $ resourceType ; } } return $ all ; }
5442	protected function dispatchTokens ( $ unmatched , $ matched , $ mode = false ) { if ( ! $ this -> invokeParser ( $ unmatched , LEXER_UNMATCHED ) ) { return false ; } if ( is_bool ( $ mode ) ) { return $ this -> invokeParser ( $ matched , LEXER_MATCHED ) ; } if ( $ this -> isModeEnd ( $ mode ) ) { if ( ! $ this -> invokeParser ( $ matched , LEXER_EXIT ) ) { return false ; } return $ this -> mode -> leave ( ) ; } if ( $ this -> isSpecialMode ( $ mode ) ) { $ this -> mode -> enter ( $ this -> decodeSpecial ( $ mode ) ) ; if ( ! $ this -> invokeParser ( $ matched , LEXER_SPECIAL ) ) { return false ; } return $ this -> mode -> leave ( ) ; } $ this -> mode -> enter ( $ mode ) ; return $ this -> invokeParser ( $ matched , LEXER_ENTER ) ; }
7334	private function getSubjectIdentityMapper ( EntityManagerInterface $ em ) { if ( null === $ this -> subjectIdentityMapper ) { $ this -> subjectIdentityMapper = new EmbeddableMapper ( $ em , SubjectIdentity :: class ) ; } return $ this -> subjectIdentityMapper ; }
10166	private function readBIFF8CellAddressB ( $ cellAddressStructure , $ baseCell = 'A1' ) { list ( $ baseCol , $ baseRow ) = Coordinate :: coordinateFromString ( $ baseCell ) ; $ baseCol = Coordinate :: columnIndexFromString ( $ baseCol ) - 1 ; $ rowIndex = self :: getUInt2d ( $ cellAddressStructure , 0 ) ; $ row = self :: getUInt2d ( $ cellAddressStructure , 0 ) + 1 ; if ( ! ( 0x4000 & self :: getUInt2d ( $ cellAddressStructure , 2 ) ) ) { $ colIndex = 0x00FF & self :: getUInt2d ( $ cellAddressStructure , 2 ) ; $ column = Coordinate :: stringFromColumnIndex ( $ colIndex + 1 ) ; $ column = '$' . $ column ; } else { $ relativeColIndex = 0x00FF & self :: getInt2d ( $ cellAddressStructure , 2 ) ; $ colIndex = $ baseCol + $ relativeColIndex ; $ colIndex = ( $ colIndex < 256 ) ? $ colIndex : $ colIndex - 256 ; $ colIndex = ( $ colIndex >= 0 ) ? $ colIndex : $ colIndex + 256 ; $ column = Coordinate :: stringFromColumnIndex ( $ colIndex + 1 ) ; } if ( ! ( 0x8000 & self :: getUInt2d ( $ cellAddressStructure , 2 ) ) ) { $ row = '$' . $ row ; } else { $ rowIndex = ( $ rowIndex <= 32767 ) ? $ rowIndex : $ rowIndex - 65536 ; $ row = $ baseRow + $ rowIndex ; } return $ column . $ row ; }
682	protected function validateOperatorCondition ( $ operator , $ condition , $ attribute = null ) { if ( $ attribute === null ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireAttribute' , [ 'operator' => $ operator ] ) ) ; return ; } $ internalOperator = $ this -> filterControls [ $ operator ] ; $ operatorTypes = $ this -> operatorTypes [ $ internalOperator ] ; if ( $ operatorTypes !== '*' ) { $ attributeTypes = $ this -> getSearchAttributeTypes ( ) ; $ attributeType = $ attributeTypes [ $ attribute ] ; if ( ! in_array ( $ attributeType , $ operatorTypes , true ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'unsupportedOperatorType' , [ 'attribute' => $ attribute , 'operator' => $ operator ] ) ) ; return ; } } if ( in_array ( $ internalOperator , $ this -> multiValueOperators , true ) ) { if ( ! is_array ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; } else { foreach ( $ condition as $ v ) { $ this -> validateAttributeValue ( $ attribute , $ v ) ; } } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } }
8577	public function setItemFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5733	public function getLeagueTeams ( int $ leagueID , array $ filter = [ 'stage' => '' ] ) { $ leagueTeams = $ this -> run ( "v2/competitions/{$leagueID}/teams" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagueTeams -> teams ) ; }
6441	public static function getSocialLoginObject ( $ network , $ options = array ( ) , $ logger = null ) { $ network = preg_replace ( '![^a-z0-9]!i' , '' , $ network ) ; if ( $ network == '' ) { throw new \ Exception ( 'Social Login Network can not be empty' ) ; } $ class = '\\Gelembjuk\\Auth\\SocialLogin\\' . ucfirst ( $ network ) ; if ( ! class_exists ( $ class ) ) { throw new \ Exception ( sprintf ( 'Integration with a class name %s not found' , $ class ) ) ; } $ object = new $ class ( $ options ) ; $ object -> setLogger ( $ logger ) ; return $ object ; }
4566	public function getForms ( $ id ) { $ forms = [ ] ; $ form = $ this -> getForm ( $ id ) ; $ form -> setMethod ( 'POST' ) -> setPrimary ( true ) ; $ forms [ ] = $ form ; switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ extract = function ( & $ container , $ key , & $ component ) use ( & $ extract , & $ forms , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as $ key => & $ subComponent ) { $ extract ( $ component -> components , $ key , $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as $ key => & $ subComponent ) { $ extract ( $ column -> components , $ key , $ subComponent ) ; } } break ; case property_exists ( $ component , 'properties' ) && is_object ( $ component -> properties ) && property_exists ( $ component -> properties , 'ds_form' ) : $ form = $ this -> getForm ( $ component -> properties -> ds_form ) ; $ data = [ ] ; if ( property_exists ( $ component , 'defaultValue' ) ) { try { $ data = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ data = [ ] ; } catch ( UnmatchedException $ exception ) { } } $ form -> setData ( $ data ) ; $ forms [ ] = $ form ; unset ( $ container [ $ key ] ) ; break ; } } ; foreach ( $ components as $ key => & $ component ) { $ extract ( $ components , $ key , $ component ) ; } $ form -> setSchema ( array_values ( $ components ) ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ forms ; }
7288	public function setColumnForLinksLabels ( $ columnNameOrClosure ) { if ( ! is_string ( $ columnNameOrClosure ) && ! ( $ columnNameOrClosure instanceof DbExpr ) ) { throw new \ InvalidArgumentException ( '$columnNameOrClosure argument must be a string or a closure' ) ; } $ this -> columnForLinksLabels = $ columnNameOrClosure ; return $ this ; }
6254	public function fetchShippingLabels ( $ trackingCodes ) { $ id = str_replace ( '.' , '' , microtime ( true ) ) ; $ xml = new \ SimpleXMLElement ( '<eChannel/>' ) ; $ routing = $ xml -> addChild ( 'ROUTING' ) ; $ routing -> addChild ( 'Routing.Account' , $ this -> api_key ) ; $ routing -> addChild ( 'Routing.Id' , $ id ) ; $ routing -> addChild ( 'Routing.Key' , md5 ( "{$this->api_key}{$id}{$this->secret}" ) ) ; $ label = $ xml -> addChild ( 'PrintLabel' ) ; $ label [ 'responseFormat' ] = 'File' ; foreach ( $ trackingCodes as $ trackingCode ) { $ label -> addChild ( 'TrackingCode' , $ trackingCode ) ; } $ response = $ this -> doPost ( '/prinetti/get-shipping-label' , null , $ xml -> asXML ( ) ) ; $ response_xml = @ simplexml_load_string ( $ response ) ; if ( ! $ response_xml ) { throw new \ Exception ( "Failed to load response xml" ) ; } $ this -> response = $ response_xml ; if ( $ response_xml -> { 'response.status' } != 0 ) { throw new \ Exception ( "Error: {$response_xml->{'response.status'}}, {$response_xml->{'response.message'}}" ) ; } return $ response_xml ; }
11525	private function getDom ( $ url ) { $ ch = curl_init ( ) ; $ timeout = 5 ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , $ timeout ) ; $ dom = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ dom ; }
5975	public function folders ( ) { if ( ! $ this -> folders instanceof FoldersController ) { $ this -> folders = new FoldersController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> folders -> setLogger ( $ this -> logger ) ; } return $ this -> folders ; }
8779	public function segment ( $ num = null ) { if ( is_null ( http ( ) -> server ( 'REQUEST_URI' ) ) || is_null ( http ( ) -> server ( 'SCRIPT_NAME' ) ) ) { return null ; } if ( ! is_null ( $ num ) ) { $ uri = $ this -> replace ( str_replace ( $ this -> base , '' , http ( ) -> server ( 'REQUEST_URI' ) ) ) ; $ uriA = explode ( '/' , $ uri ) ; return ( isset ( $ uriA [ $ num ] ) ? reset ( explode ( '?' , $ uriA [ $ num ] ) ) : null ) ; } return null ; }
9565	public function addBeforeHook ( $ hook ) { if ( ! isset ( $ this -> options [ 'before' ] ) ) { $ this -> options [ 'before' ] = [ ] ; } $ this -> options [ 'before' ] [ ] = $ hook ; }
10948	public function getCsrfToken ( $ regenerate = false ) { if ( $ this -> _csrfToken === null || $ regenerate ) { if ( $ regenerate || ( $ token = $ this -> loadCsrfToken ( ) ) === null ) { $ token = $ this -> generateCsrfToken ( ) ; } $ chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-.' ; $ mask = substr ( str_shuffle ( str_repeat ( $ chars , 5 ) ) , 0 , static :: CSRF_MASK_LENGTH ) ; $ this -> _csrfToken = str_replace ( '+' , '.' , base64_encode ( $ mask . $ this -> xorTokens ( $ token , $ mask ) ) ) ; } return $ this -> _csrfToken ; }
2770	public function getRemoteUrl ( string $ remote , string $ operation = 'fetch' ) : string { $ argsAndOptions = [ 'get-url' , $ remote ] ; if ( $ operation === 'push' ) { $ argsAndOptions [ ] = '--push' ; } return rtrim ( $ this -> remote ( ... $ argsAndOptions ) ) ; }
739	protected function saveAssignments ( ) { $ assignmentData = [ ] ; foreach ( $ this -> assignments as $ userId => $ assignments ) { foreach ( $ assignments as $ name => $ assignment ) { $ assignmentData [ $ userId ] [ ] = $ assignment -> roleName ; } } $ this -> saveToFile ( $ assignmentData , $ this -> assignmentFile ) ; }
4221	public function getAbstraction ( & $ array , $ method = null , & $ hist = array ( ) ) { if ( \ in_array ( $ array , $ hist , true ) ) { return $ this -> abstracter -> RECURSION ; } if ( self :: isCallable ( $ array ) ) { return array ( 'debug' => $ this -> abstracter -> ABSTRACTION , 'type' => 'callable' , 'values' => array ( \ get_class ( $ array [ 0 ] ) , $ array [ 1 ] ) , ) ; } $ return = array ( ) ; $ hist [ ] = $ array ; foreach ( $ array as $ k => $ v ) { if ( $ this -> abstracter -> needsAbstraction ( $ v ) ) { $ v = $ this -> abstracter -> getAbstraction ( $ array [ $ k ] , $ method , $ hist ) ; } $ return [ $ k ] = $ v ; } return $ return ; }
10055	public function push ( $ type , $ value , $ reference = null ) { $ this -> stack [ $ this -> count ++ ] = [ 'type' => $ type , 'value' => $ value , 'reference' => $ reference , ] ; if ( $ type == 'Function' ) { $ localeFunction = Calculation :: localeFunc ( $ value ) ; if ( $ localeFunction != $ value ) { $ this -> stack [ ( $ this -> count - 1 ) ] [ 'localeValue' ] = $ localeFunction ; } } }
9684	public function getStorage ( ) { if ( null === $ this -> storage ) { $ this -> setStorage ( new Storage \ File ( array ( 'dir' => DATA_PATH ) ) ) ; } return $ this -> storage ; }
3701	private function convertRenderGroupType ( $ type ) { $ lookup = [ 'char' => GroupAndSortingInformationInterface :: GROUP_CHAR , 'digit' => GroupAndSortingInformationInterface :: GROUP_DIGIT , 'day' => GroupAndSortingInformationInterface :: GROUP_DAY , 'weekday' => GroupAndSortingInformationInterface :: GROUP_WEEKDAY , 'week' => GroupAndSortingInformationInterface :: GROUP_WEEK , 'month' => GroupAndSortingInformationInterface :: GROUP_MONTH , 'year' => GroupAndSortingInformationInterface :: GROUP_YEAR , ] ; if ( array_key_exists ( $ type , $ lookup ) ) { return $ lookup [ $ type ] ; } return GroupAndSortingInformationInterface :: GROUP_NONE ; }
725	public function render ( $ view , $ params = [ ] ) { $ content = $ this -> getView ( ) -> render ( $ view , $ params , $ this ) ; return $ this -> renderContent ( $ content ) ; }
8661	private function convertGetFeedSubmissionResult ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionResult' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionId ( ) ) { $ parameters [ 'FeedSubmissionId' ] = $ request -> getFeedSubmissionId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
8699	private function factoryElement ( $ type ) { switch ( $ type ) { case \ SVGCreator \ Element :: CIRCLE : return new \ SVGCreator \ Elements \ Circle ( ) ; break ; case \ SVGCreator \ Element :: DEFS : return new \ SVGCreator \ Elements \ Defs ( ) ; break ; case \ SVGCreator \ Element :: GROUP : return new \ SVGCreator \ Elements \ Group ( ) ; break ; case \ SVGCreator \ Element :: LINE : return new \ SVGCreator \ Elements \ Line ( ) ; break ; case \ SVGCreator \ Element :: MARKER : return new \ SVGCreator \ Elements \ Marker ( ) ; break ; case \ SVGCreator \ Element :: PATH : return new \ SVGCreator \ Elements \ Path ( ) ; break ; case \ SVGCreator \ Element :: RECT : return new \ SVGCreator \ Elements \ Rect ( ) ; break ; case \ SVGCreator \ Element :: SVG : return new \ SVGCreator \ Elements \ Svg ( ) ; break ; case \ SVGCreator \ Element :: TEXT : return new \ SVGCreator \ Elements \ Text ( ) ; break ; case \ SVGCreator \ Element :: POLYGON : return new \ SVGCreator \ Elements \ Polygon ( ) ; break ; default : throw new \ SVGCreator \ SVGException ( "The tag " . $ type . " is not implemented yet" , 1 ) ; break ; } }
3268	protected function closeFile ( SplFileObject & $ file ) { if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( LOCK_UN ) ) { $ file = null ; throw new Exception ( 'Could not unlock file' ) ; } $ file = null ; }
4078	protected function fetchInputScreenDetails ( ) { $ inputScreenIds = array ( ) ; foreach ( $ this -> information as $ info ) { $ inputScreenIds [ ] = $ info [ self :: COMBINATION ] [ 'dca_id' ] ; } if ( ! $ inputScreenIds ) { return ; } $ statement = $ this -> connection -> query ( sprintf ( 'SELECT * FROM tl_metamodel_dca WHERE id IN (%s)' , implode ( ',' , $ inputScreenIds ) ) ) ; while ( $ inputScreens = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ screenId = $ inputScreens -> id ; $ metaModelId = $ inputScreens -> pid ; $ metaModelName = $ this -> tableNameFromId ( $ metaModelId ) ; $ propertyRows = $ this -> connection -> prepare ( 'SELECT * FROM tl_metamodel_dcasetting WHERE pid=? AND published=1 ORDER BY sorting ASC' ) ; $ propertyRows -> bindValue ( 1 , $ screenId ) ; $ propertyRows -> execute ( ) ; $ conditions = $ this -> connection -> prepare ( ' SELECT cond.*, setting.attr_id AS setting_attr_id FROM tl_metamodel_dcasetting_condition AS cond LEFT JOIN tl_metamodel_dcasetting AS setting ON (cond.settingId=setting.id) LEFT JOIN tl_metamodel_dca AS dca ON (setting.pid=dca.id) WHERE dca.id=? AND setting.published=1 AND cond.enabled=1 ORDER BY sorting ASC ' ) ; $ conditions -> bindValue ( 1 , $ screenId ) ; $ conditions -> execute ( ) ; $ groupSort = $ this -> connection -> prepare ( ' SELECT * FROM tl_metamodel_dca_sortgroup WHERE pid=? ORDER BY sorting ASC ' ) ; $ groupSort -> bindValue ( 1 , $ screenId ) ; $ groupSort -> execute ( ) ; $ inputScreen = array ( 'row' => $ inputScreens -> row ( ) , 'properties' => $ propertyRows -> fetchAll ( \ PDO :: FETCH_ASSOC ) , 'conditions' => $ conditions -> fetchAll ( \ PDO :: FETCH_ASSOC ) , 'groupSort' => $ groupSort -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] = $ inputScreen ; $ this -> information [ $ metaModelName ] [ self :: MODELID ] = $ metaModelId ; $ parentTable = $ inputScreen [ 'row' ] [ 'ptable' ] ; if ( $ parentTable && ! $ this -> isInputScreenStandalone ( $ metaModelName ) ) { $ this -> parentMap [ $ parentTable ] [ ] = $ this -> information [ $ metaModelName ] [ self :: MODELID ] ; $ this -> childMap [ $ metaModelName ] = $ parentTable ; } } }
10876	public function processApprove ( string $ hash ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { if ( ! $ item [ 'active' ] ) { if ( $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ) { return $ this -> update ( $ item [ 'id' ] , [ 'active' => true ] ) ; } else { throw new IdentityException ( 'Invalid hash!' ) ; } } else { throw new IdentityException ( 'User is already approve!' ) ; } } else { throw new IdentityException ( 'User does not exist!' ) ; } }
8950	private function addRouters ( ) { $ builder = $ this -> getContainerBuilder ( ) ; $ router = $ builder -> getDefinition ( 'router' ) ; $ routerFactories = array ( ) ; foreach ( $ builder -> findByTag ( self :: TAG_ROUTER ) as $ serviceName => $ priority ) { if ( is_bool ( $ priority ) ) { $ priority = 100 ; } $ routerFactories [ $ priority ] [ $ serviceName ] = $ serviceName ; } if ( ! empty ( $ routerFactories ) ) { krsort ( $ routerFactories , SORT_NUMERIC ) ; foreach ( $ routerFactories as $ priority => $ items ) { $ routerFactories [ $ priority ] = $ items ; } foreach ( $ routerFactories as $ priority => $ items ) { foreach ( $ items as $ serviceName ) { $ factory = new Nette \ DI \ Statement ( array ( '@' . $ serviceName , 'createRouter' ) ) ; $ router -> addSetup ( 'offsetSet' , array ( NULL , $ factory ) ) ; } } } }
8703	protected function registerViewComposers ( ) { $ core = $ this -> getCore ( ) ; view ( ) -> composer ( $ core -> config ( 'views.menu' ) , MenuComposer :: class ) ; view ( ) -> composer ( $ core -> config ( 'views.top' ) , TopComposer :: class ) ; return $ this ; }
5084	protected function validateUserInput ( $ aData , $ oItem = null ) { $ aOut = [ ] ; $ aFields = $ this -> oModel -> describeFields ( ) ; $ aKeys = array_unique ( array_merge ( array_keys ( $ aFields ) , arrayExtractProperty ( $ this -> oModel -> getExpandableFields ( ) , 'trigger' ) ) ) ; $ aValidKeys = array_diff ( $ aKeys , static :: IGNORE_FIELDS_WRITE ) ; foreach ( $ aValidKeys as $ sValidKey ) { $ oField = getFromArray ( $ sValidKey , $ aFields ) ; if ( array_key_exists ( $ sValidKey , $ aData ) ) { $ aOut [ $ sValidKey ] = getFromArray ( $ sValidKey , $ aData ) ; } } return $ aOut ; }
7019	private function formatH ( & $ str ) { if ( strstr ( $ str , '%H' ) ) $ str = str_replace ( '%H' , sprintf ( '%02d' , $ this -> hour ) , $ str ) ; }
6886	public function lookupPostcodeMetadata ( $ postcode ) { $ path = sprintf ( self :: PATH_LOOKUP_METADATA , $ postcode ) ; $ response = $ this -> httpGet ( $ path ) ; return Response \ PostcodeInfo :: buildFromResponse ( $ response ) ; }
7161	private function initialize ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> lineNumber = 1 ; $ this -> view = new SaleView ( ) ; $ this -> types = $ this -> registry -> getTypesForSale ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> configureOptions ( $ sale , $ this -> view , $ options ) ; } $ this -> options = $ this -> getOptionsResolver ( ) -> resolve ( $ options ) ; $ this -> view -> setTemplate ( $ this -> options [ 'template' ] ) ; if ( ! is_null ( $ this -> options [ 'ati' ] ) ) { $ this -> view -> setAti ( $ this -> options [ 'ati' ] ) ; } else { $ this -> view -> setAti ( $ sale -> isAtiDisplayMode ( ) ) ; } $ this -> formatter = $ this -> formatterFactory -> create ( $ this -> options [ 'locale' ] , $ sale -> getCurrency ( ) -> getCode ( ) ) ; foreach ( $ this -> types as $ type ) { $ type -> setFormatter ( $ this -> formatter ) ; } }
5998	public function setMax ( $ max ) { if ( $ max instanceof DateTime ) { $ this -> max = $ max ; } else { try { $ this -> max = new DateTime ( $ max ) ; } catch ( \ Exception $ e ) { $ this -> max = null ; } } return $ this ; }
2713	public function getValues ( ) { $ values = [ ] ; $ ratios = $ this -> pixelRatios -> toOptionArray ( ) ; foreach ( $ ratios as $ value ) { $ values [ $ value [ 'value' ] ] = $ value [ 'label' ] ; } return $ values ; }
4994	public function getActiveFormPrevious ( ) { $ key = null ; $ actualKey = $ this -> getActiveFormActual ( ) ; if ( isset ( $ actualKey ) ) { $ forms = array_keys ( $ this -> forms ) ; $ formsFlip = array_flip ( $ forms ) ; $ index = $ formsFlip [ $ actualKey ] ; if ( 0 < $ index ) { $ key = $ forms [ $ index - 1 ] ; } } return $ key ; }
12298	public function onlyFillablePivot ( $ pivotRelation , $ data ) { $ fillable = $ this -> getPivotFields ( $ pivotRelation , 'pivotColumns' ) ; return array_only ( $ data , $ fillable ) ; }
4597	public function setDeserializeValues ( ? bool $ deserializeValues ) { $ this -> deserializeValues = $ deserializeValues ; $ this -> _deserializeValues = null !== $ deserializeValues ; return $ this ; }
5585	public function isClickable ( $ label ) { return $ this -> isSubmit ( $ label ) || ( $ this -> getLink ( $ label ) !== false ) || $ this -> isImage ( $ label ) ; }
1459	protected function whereId ( $ id , $ operator ) { if ( $ this -> isPagingOnKey ( ) ) { $ this -> query -> where ( $ this -> key , $ operator , $ id ) ; return $ this ; } $ value = $ this -> getColumnValue ( $ id ) ; $ this -> query -> where ( $ this -> column , $ operator . '=' , $ value ) -> where ( function ( $ query ) use ( $ id , $ value , $ operator ) { $ query -> where ( $ this -> column , $ operator , $ value ) -> orWhere ( $ this -> key , $ operator , $ id ) ; } ) ; return $ this ; }
10214	public function setColor ( Color $ pValue ) { $ color = $ pValue -> getIsSupervisor ( ) ? $ pValue -> getSharedComponent ( ) : $ pValue ; if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getColor ( ) -> getStyleArray ( [ 'argb' => $ color -> getARGB ( ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> color = $ color ; } return $ this ; }
5741	protected static function prefixData ( $ data ) { $ prefixedData = array ( ) ; foreach ( $ data as $ stat => $ value ) { $ prefixedKey = self :: prefix ( $ stat ) ; $ prefixedData [ $ prefixedKey ] = $ value ; } return $ prefixedData ; }
11179	protected function get ( $ key ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; if ( ! is_array ( $ cache ) ) { return false ; } else { if ( isset ( $ cache [ $ key ] ) ) { return $ cache [ $ key ] ; } return false ; } }
4166	public function run ( $ command ) { $ process = new Process ( $ command , null , null , null , ini_get ( 'max_execution_time' ) ) ; $ process -> run ( function ( $ type , $ buffer ) { if ( Process :: ERR === $ type ) { $ this -> console -> warn ( trim ( $ buffer ) ) ; } else { $ this -> console -> info ( trim ( $ buffer ) ) ; } } ) ; if ( ! $ process -> isSuccessful ( ) ) { throw new ProcessFailedException ( $ process ) ; } return true ; }
6575	public function getSessionCookie ( ) : ? SetCookie { try { if ( $ this -> isStarted ( ) ) { return new SetCookie ( $ this -> getName ( ) , $ this -> getDataHolder ( ) -> getId ( ) , ( time ( ) + $ this -> getExpire ( ) * 60 ) , $ this -> getCookiePath ( ) ?? '/' , $ this -> getCookieHost ( ) ?? '' , $ this -> getCookieSecure ( ) , $ this -> isCookieHttpOnly ( ) ) ; } else { return SetCookie :: thatDeletesCookie ( $ this -> getName ( ) ) ; } } catch ( \ Throwable $ exception ) { throw new SessionManagerException ( "Error while preparing the session cookie" , $ this , null , $ exception ) ; } }
7993	public function getDiskUsage ( $ diskId , $ type ) { return json_decode ( self :: getClient ( ) -> getDiskUsage ( $ this -> getDomain ( ) , $ diskId , $ type ) ) ; }
5967	public function tempPasswordList ( $ resolve = false ) { $ passwords = $ this -> request ( "servertemppasswordlist" ) -> toAssocArray ( "pw_clear" ) ; if ( $ resolve ) { foreach ( $ passwords as $ password => $ array ) { try { $ channel = $ this -> channelGetById ( $ array [ "tcid" ] ) ; $ passwords [ $ password ] [ "tcname" ] = $ channel -> toString ( ) ; $ passwords [ $ password ] [ "tcpath" ] = $ channel -> getPathway ( ) ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0xA00 ) { throw $ e ; } } } } return $ passwords ; }
4144	public function get ( $ call , array $ getParams = null ) { $ this -> resetCallState ( ) ; $ this -> call = $ call ; $ this -> method = 'GET' ; if ( $ getParams !== null && is_array ( $ getParams ) ) { $ this -> getParams = $ getParams ; } $ response = $ this -> getResponse ( ) ; $ response [ 'body' ] = $ this -> findExceptions ( $ response ) ; $ this -> headers = $ response [ 'headers' ] ; unset ( $ call , $ getParams ) ; return $ this -> serializer -> format ( $ response [ 'body' ] ) ; }
11928	public function getDataInterface ( ) { if ( ! $ this -> started ) { return $ this -> _interface ; } if ( is_null ( $ this -> _interface ) ) { $ interfaces = ArrayHelper :: map ( Yii :: $ app -> collectors [ 'dataInterfaces' ] -> getAll ( ) , 'systemId' , 'object.name' ) ; $ this -> dataInterface = $ this -> select ( "Choose interface" , $ interfaces ) ; } return $ this -> _interface ; }
12789	protected function loadForeignObject ( ) { if ( $ this -> _isLoadingForeignObject ) { throw new RecursionException ( 'Ran into recursion while loading foreign object' ) ; } $ this -> _isLoadingForeignObject = true ; if ( isset ( $ this -> foreignPrimaryKey ) ) { $ foreignObject = $ this -> dataSource -> getForeignDataModel ( $ this -> foreignPrimaryKey ) ; if ( $ foreignObject ) { $ this -> foreignObject = $ foreignObject ; } } if ( empty ( $ this -> _foreignObject ) ) { \ d ( $ this -> foreignPrimaryKey ) ; \ d ( $ this -> dataSource -> name ) ; throw new MissingItemException ( 'Foreign item could not be found: ' . $ this -> foreignPrimaryKey ) ; } $ this -> _isLoadingForeignObject = false ; }
8492	public static function getTotalMemory ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT TotalPhysicalMemory FROM Win32_ComputerSystem" ) as $ mem ) { return $ mem -> TotalPhysicalMemory ; } return NULL ; }
6517	public function setParameterType ( $ method , $ name , $ type ) { if ( ! isset ( $ this -> parameterTypes [ $ method ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'A method with name "%s" is not defined' , $ name , $ method ) ) ; } if ( ! array_key_exists ( $ name , $ this -> parameterTypes [ $ method ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'A parameter with name "%s" for method "%s" is not defined' , $ name , $ method ) ) ; } $ this -> parameterTypes [ $ method ] [ $ name ] = $ type ; }
3121	public function filter ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ subset = new static ( ) ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ subset -> add ( $ point ) ; } } return $ subset ; }
1384	protected function isNotFound ( string $ type , string $ id ) : bool { return ! $ this -> store -> exists ( ResourceIdentifier :: create ( $ type , $ id ) ) ; }
12305	public function getAdminListHeader ( ) { return [ 'language_family' => [ "type" => "text" , "label" => trans ( 'HCLanguages::languages.language_family' ) , ] , 'language' => [ "type" => "text" , "label" => trans ( 'HCLanguages::languages.language' ) , ] , 'native_name' => [ "type" => "text" , "label" => trans ( 'HCLanguages::languages.native_name' ) , ] , 'iso_639_1' => [ "type" => "text" , "label" => trans ( 'HCLanguages::languages.iso_639_1' ) , ] , 'iso_639_2' => [ "type" => "text" , "label" => trans ( 'HCLanguages::languages.iso_639_2' ) , ] , 'front_end' => [ "type" => "checkbox" , "label" => trans ( 'HCLanguages::languages.front_end' ) , "url" => route ( 'admin.api.languages.update.strict' , 'id' ) ] , 'back_end' => [ "type" => "checkbox" , "label" => trans ( 'HCLanguages::languages.back_end' ) , "url" => route ( 'admin.api.languages.update.strict' , 'id' ) ] , 'content' => [ "type" => "checkbox" , "label" => trans ( 'HCLanguages::languages.content' ) , "url" => route ( 'admin.api.languages.update.strict' , 'id' ) ] , ] ; }
6380	public function readAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'quiz_attempts' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/quiz/attempt.php?attempt=' . $ id ; $ model -> name = 'Attempt ' . $ id ; return $ model ; }
5643	public function makeDry ( $ is_dry = true ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> makeDry ( $ is_dry ) ; } }
4787	function offsetSet ( $ key , $ value ) { $ this -> row [ $ key ] = $ value ; $ this -> modified [ $ key ] = $ value ; }
12906	public function show ( $ id , FilterRequest $ request ) { $ id = $ this -> getRealId ( $ id ) ; $ request -> criteria [ ] = 'id,=,' . $ id ; $ resource = $ this -> repository -> filter ( $ request ) -> first ( ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
3747	protected function extractSorting ( $ config ) { $ sorting = $ config -> getSorting ( ) ; $ sortBy = key ( $ sorting ) ; $ sortDir = current ( $ sorting ) ? : DCGE :: MODEL_SORTING_ASC ; return array ( $ sortBy , $ sortDir ) ; }
7875	protected function settleRepositoryIfNotExists ( ) { $ source = $ this -> pipelines -> getSource ( ) ; if ( ! $ this -> files -> exists ( $ source ) ) { $ this -> pipelines -> settle ( ) ; } }
5062	public function output ( ) : string { if ( is_null ( $ this -> buffer ) ) { $ this -> exec ( ) ; } curl_close ( $ this -> ch ) ; if ( strlen ( $ this -> buffer ) === 0 ) { throw new NoOutputException ( ) ; } return $ this -> buffer ; }
438	public function __isset ( $ name ) { $ getter = 'get' . $ name ; if ( method_exists ( $ this , $ getter ) ) { return $ this -> $ getter ( ) !== null ; } $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name ) ) { return $ behavior -> $ name !== null ; } } return false ; }
8623	public function setOfferListingCount ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OfferListingCount' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10341	protected function validateColumns ( $ columns ) { $ patterns = array ( '((?P<minute>(?:\*|(?:(?:[0-9]|[1-5][0-9])(?:-(?:[0-9]|[1-5][0-9]))?)(?:,(?:[0-9]|[1-5][0-9])(?:-(?:[0-9]|[1-5][0-9]))?)*)(?:/(?:[1-9]|[1-5][0-9]))?)$)AD' , '((?P<hour>(?:\*|(?:(?:[0-9]|1[0-9]|2[0-3])(?:-(?:[0-9]|1[0-9]|2[0-3]))?)(?:,(?:[0-9]|1[0-9]|2[0-3])(?:-(?:[0-9]|1[0-9]|2[0-3]))?)*)(?:/(?:[1-9]|1[0-9]|2[0-3]))?)$)AD' , '((?P<dayOfMonth>(?:\*|(?:(?:[1-9]|[1-2][0-9]|3[0-1])(?:-(?:[1-9]|[1-2][0-9]|3[0-1]))?)(?:,(?:[1-9]|[1-2][0-9]|3[0-1])(?:-(?:[1-9]|[1-2][0-9]|3[0-1]))?)*)(?:/(?:[1-9]|[1-2][0-9]|3[0-1]))?)$)AD' , '((?P<month>(?:\*|(?:(?:[1-9]|1[0-2])(?:-(?:[1-9]|1[1-2]))?)(?:,(?:[1-9]|1[1-2])(?:-(?:[1-9]|1[1-2]))?)*)(?:/(?:[1-9]|1[1-2]))?)$)AD' , '((?P<dayOfWeek>(?:\*|(?:(?:[0-7])(?:-(?:[0-7]))?)(?:,(?:[0-7])(?:-(?:[0-7]))?)*)(?:/(?:[1-7]))?)$)AD' , ) ; if ( count ( $ columns ) !== 5 ) { return false ; } foreach ( $ columns as $ key => $ column ) { if ( preg_match ( $ patterns [ $ key ] , $ column ) !== 1 ) { return ( int ) $ key ; } } return true ; }
5254	public static function destroy ( $ id ) { $ ids = is_array ( $ id ) ? $ id : [ $ id ] ; foreach ( $ ids as $ id ) { $ model = static :: find ( $ id ) ; if ( ! is_null ( $ model ) ) { $ model -> delete ( ) ; } } }
12976	public function parseMappingInfo ( ) { $ mappings = array ( ) ; foreach ( $ this -> getMappings ( ) as $ mappingName => $ mappingConfig ) { if ( is_array ( $ mappingConfig ) === false or \ Arr :: get ( $ mappingConfig , 'mapping' , true ) === false ) { continue ; } $ mappingConfig = array_replace ( array ( 'dir' => false , 'type' => false , 'prefix' => false , ) , $ mappingConfig ) ; if ( isset ( $ mappingConfig [ 'is_component' ] ) === false ) { $ mappingConfig [ 'is_component' ] = false ; if ( is_dir ( $ mappingConfig [ 'dir' ] ) === false ) { $ mappingConfig [ 'is_component' ] = ( \ Package :: loaded ( $ mappingName ) or \ Module :: loaded ( $ mappingName ) ) ; } } if ( $ mappingConfig [ 'is_component' ] ) { $ mappingConfig = $ this -> getComponentDefaults ( $ mappingName , $ mappingConfig ) ; } if ( empty ( $ mappingConfig ) ) { continue ; } $ mappings [ $ mappingName ] = $ mappingConfig ; } $ this -> config [ 'mappings' ] = $ mappings ; }
5240	public function log ( \ Exception $ exception ) { $ logData = date ( 'Y-m-d H:i:s' ) ; $ logData .= $ this -> exceptionFields ( $ exception ) ; $ logData .= $ this -> fieldsForPrevious ( $ exception -> getPrevious ( ) ) ; error_log ( $ logData . "\n" , 3 , $ this -> getLogDir ( ) . DIRECTORY_SEPARATOR . 'exceptions-' . date ( 'Y-m-d' ) . '.log' ) ; }
12381	public static function interval ( $ startDate , $ endDate ) { $ hits = DB :: table ( 'views' ) -> select ( 'id' , 'ip' , 'created_at' ) -> whereBetween ( 'created_at' , [ $ startDate , $ endDate ] ) -> groupBy ( 'ip' ) -> get ( ) ; return count ( $ hits ) ; }
6809	public function currency ( float $ number , string $ currency = null ) : string { return $ this -> getCurrencyFormatter ( ) -> formatCurrency ( $ number , $ currency ? $ currency : $ this -> currency ) ; }
7612	public function getIsSuperAdmin ( ) { if ( $ this -> _isSuperAdmin !== null ) { return $ this -> _isSuperAdmin ; } $ this -> _isSuperAdmin = in_array ( $ this -> username , Yii :: $ app -> getModule ( 'auth' ) -> superAdmins ) ; return $ this -> _isSuperAdmin ; }
8746	public function getListenerInstance ( EventDispatcher $ eventDispatcher = null , StreamableInterface $ stream = null ) { $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Matcher' ) ; $ matcher = $ reflection -> newInstance ( ) ; $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Listener' ) ; if ( null === $ eventDispatcher ) { $ eventDispatcher = new EventDispatcher ( ) ; } if ( null === $ stream ) { $ stream = new Stream ( ) ; } $ listener = $ reflection -> newInstance ( $ matcher , $ eventDispatcher , $ stream ) ; return $ listener ; }
10530	public function toJson ( $ prettyPrint = false ) { $ options = 0 ; if ( $ prettyPrint ) { $ options += JSON_PRETTY_PRINT ; } return json_encode ( $ this -> items , $ options ) ; }
12757	public function routeStartup ( Zend_Controller_Request_Abstract $ request ) { if ( ! $ request -> getHeader ( 'User-Agent' ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 403 ) -> setHeader ( 'Content-Type' , 'text/plain; charset=utf-8' ) -> setBody ( implode ( "\n" , self :: $ _errMessage ) ) -> sendResponse ( ) ; exit ( 403 ) ; } }
1045	public static function createFromException ( $ e , $ debug = false , $ internalErrorMessage = null ) { Utils :: invariant ( $ e instanceof Exception || $ e instanceof Throwable , 'Expected exception, got %s' , Utils :: getVariableType ( $ e ) ) ; $ internalErrorMessage = $ internalErrorMessage ? : self :: $ internalErrorMessage ; if ( $ e instanceof ClientAware ) { $ formattedError = [ 'message' => $ e -> isClientSafe ( ) ? $ e -> getMessage ( ) : $ internalErrorMessage , 'extensions' => [ 'category' => $ e -> getCategory ( ) , ] , ] ; } else { $ formattedError = [ 'message' => $ internalErrorMessage , 'extensions' => [ 'category' => Error :: CATEGORY_INTERNAL , ] , ] ; } if ( $ e instanceof Error ) { $ locations = Utils :: map ( $ e -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ formattedError [ 'locations' ] = $ locations ; } if ( ! empty ( $ e -> path ) ) { $ formattedError [ 'path' ] = $ e -> path ; } if ( ! empty ( $ e -> getExtensions ( ) ) ) { $ formattedError [ 'extensions' ] = $ e -> getExtensions ( ) + $ formattedError [ 'extensions' ] ; } } if ( $ debug ) { $ formattedError = self :: addDebugEntries ( $ formattedError , $ e , $ debug ) ; } return $ formattedError ; }
5738	public function setDefaultSuffix ( $ defaultSuffix ) { $ this -> defaultSuffix = ( string ) $ defaultSuffix ; $ this -> defaultSuffix = ltrim ( $ this -> defaultSuffix , '.' ) ; return $ this ; }
7684	function XML_DeleteElements ( & $ Txt , $ TagLst , $ OnlyInner = false ) { $ nbr_del = 0 ; foreach ( $ TagLst as $ tag ) { $ t_open = '<' . $ tag ; $ t_close = '</' . $ tag ; $ p1 = 0 ; while ( ( $ p1 = $ this -> XML_FoundTagStart ( $ Txt , $ t_open , $ p1 ) ) !== false ) { $ pe1 = strpos ( $ Txt , '>' , $ p1 ) ; if ( $ pe1 === false ) return false ; $ p2 = false ; if ( substr ( $ Txt , $ pe1 - 1 , 1 ) == '/' ) { $ pe2 = $ pe1 ; } else { $ p2 = $ this -> XML_FoundTagStart ( $ Txt , $ t_close , $ pe1 ) ; if ( $ p2 === false ) return false ; $ pe2 = strpos ( $ Txt , '>' , $ p2 ) ; } if ( $ pe2 === false ) return false ; if ( $ OnlyInner ) { if ( $ p2 !== false ) $ Txt = substr_replace ( $ Txt , '' , $ pe1 + 1 , $ p2 - $ pe1 - 1 ) ; $ p1 = $ pe1 ; } else { $ Txt = substr_replace ( $ Txt , '' , $ p1 , $ pe2 - $ p1 + 1 ) ; } } } return $ nbr_del ; }
551	public function actionFlush ( ) { $ cachesInput = func_get_args ( ) ; if ( empty ( $ cachesInput ) ) { throw new Exception ( 'You should specify cache components names' ) ; } $ caches = $ this -> findCaches ( $ cachesInput ) ; $ cachesInfo = [ ] ; $ foundCaches = array_keys ( $ caches ) ; $ notFoundCaches = array_diff ( $ cachesInput , array_keys ( $ caches ) ) ; if ( $ notFoundCaches ) { $ this -> notifyNotFoundCaches ( $ notFoundCaches ) ; } if ( ! $ foundCaches ) { $ this -> notifyNoCachesFound ( ) ; return ExitCode :: OK ; } if ( ! $ this -> confirmFlush ( $ foundCaches ) ) { return ExitCode :: OK ; } foreach ( $ caches as $ name => $ class ) { $ cachesInfo [ ] = [ 'name' => $ name , 'class' => $ class , 'is_flushed' => $ this -> canBeFlushed ( $ class ) ? Yii :: $ app -> get ( $ name ) -> flush ( ) : false , ] ; } $ this -> notifyFlushed ( $ cachesInfo ) ; }
2732	public function execute ( ) { $ types = $ this -> cacheManager -> getAvailableTypes ( ) ; $ types = array_diff ( $ types , [ 'full_page' ] ) ; $ this -> cacheManager -> clean ( $ types ) ; $ result = $ this -> api -> cleanAll ( ) ; if ( $ result === true ) { $ this -> messageManager -> addSuccessMessage ( __ ( 'Full Magento & Fastly Cache has been cleaned.' ) ) ; } else { $ this -> getMessageManager ( ) -> addErrorMessage ( __ ( 'Full Magento & Fastly Cache was not cleaned successfully.' ) ) ; } return $ this -> _redirect ( '*/cache/index' ) ; }
11302	public function loadAll ( ) { $ this -> data -> id = $ this -> id ; foreach ( $ this -> model_attributes as $ key => $ value ) { $ temp = $ this -> $ key ; } }
5170	public static function getNameByType ( $ type ) { static $ map = array ( self :: TYPE_BOOL => 'Bool' , self :: TYPE_INT => 'Int' , self :: TYPE_UINT => 'UInt' , self :: TYPE_QCHAR => 'QChar' , self :: TYPE_QVARIANT_MAP => 'QVariantMap' , self :: TYPE_QVARIANT_LIST => 'QVariantList' , self :: TYPE_QSTRING => 'QString' , self :: TYPE_QSTRING_LIST => 'QStringList' , self :: TYPE_QBYTE_ARRAY => 'QByteArray' , self :: TYPE_QTIME => 'QTime' , self :: TYPE_QDATETIME => 'QDateTime' , self :: TYPE_QUSER_TYPE => 'QUserType' , self :: TYPE_SHORT => 'Short' , self :: TYPE_CHAR => 'Char' , self :: TYPE_USHORT => 'UShort' , self :: TYPE_UCHAR => 'UChar' , ) ; if ( ! isset ( $ map [ $ type ] ) ) { throw new \ InvalidArgumentException ( 'Invalid/unknown variant type (' . $ type . ')' ) ; } return $ map [ $ type ] ; }
6467	private function createStreamFromString ( string $ string ) : Stream { $ stream = new Stream ( fopen ( 'php://temp' , 'r+b' ) ) ; $ stream -> write ( $ string ) ; $ stream -> rewind ( ) ; return $ stream ; }
12242	public function asPrettyXML ( $ filepath = null ) { $ xml = dom_import_simplexml ( new SimpleXMLElement ( $ this -> asXML ( ) ) ) ; $ xsl = new DOMDocument ; $ xsl -> loadXML ( '<?xml version="1.0" encoding="utf-8"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="xml" indent="yes" /> <xsl:template match="text()"> <!-- remove everything that contains only whitespace, with at least one LF ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; $ result = trim ( $ xslt -> transformToXML ( $ xml ) ) ; if ( isset ( $ filepath ) ) { return ( bool ) file_put_contents ( $ filepath , $ result ) ; } return $ result ; }
3397	public function urlDecodeUnreservedChars ( $ string ) { $ string = rawurldecode ( $ string ) ; $ string = rawurlencode ( $ string ) ; $ string = str_replace ( array ( '%2F' , '%3A' , '%40' ) , array ( '/' , ':' , '@' ) , $ string ) ; return $ string ; }
8958	public function validateResponse ( $ url , $ response ) { if ( $ response -> code != 200 ) { $ error = htmlspecialchars ( $ response -> body ) ; throw new \ DomainException ( $ error , $ response -> code ) ; } }
7942	public function addSecondaryDnsDomains ( $ domain , $ domain2add , $ ip ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ domain2add = ( string ) $ domain2add ; if ( ! $ domain2add ) throw new BadMethodCallException ( 'Parameter $domain2add is missing.' ) ; $ ip = ( string ) $ ip ; if ( ! $ ip ) throw new BadMethodCallException ( 'Parameter $ip is missing.' ) ; $ payload = array ( "domain" => $ domain2add , "ip" => $ ip ) ; try { $ r = $ this -> post ( 'dedicated/server/' . $ domain . '/secondaryDnsDomains' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
6092	public function removeMediaFromMoodboard ( $ moodboardId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/moodboards/' . $ moodboardId . '/media/' . $ mediaId . '' , $ parameters ) ; return $ result ; }
6811	private function getDateFormatter ( ) { if ( $ this -> dateFormatter ) { return $ this -> dateFormatter ; } return $ this -> dateFormatter = IntlDateFormatter :: create ( $ this -> locale , IntlDateFormatter :: SHORT , IntlDateFormatter :: NONE , ini_get ( 'date.timezone' ) , IntlDateFormatter :: GREGORIAN ) ; }
8819	public function server ( $ key = null ) { if ( is_null ( $ key ) ) { return $ _SERVER ; } $ key = strtoupper ( $ key ) ; return ( isset ( $ _SERVER [ $ key ] ) ? $ _SERVER [ $ key ] : null ) ; }
10534	public function allows ( $ action , $ user , $ request ) { if ( $ this -> matchAction ( $ action ) && $ this -> matchRole ( $ user ) && $ this -> matchIP ( $ request -> getUserIP ( ) ) && $ this -> matchVerb ( $ request -> getMethod ( ) ) && $ this -> matchController ( $ action -> controller ) && $ this -> matchCustom ( $ action ) ) { return $ this -> allow ? true : false ; } else { return null ; } }
6897	public function bind ( $ key , & $ value ) { $ this -> open ( ) ; $ this -> _data [ $ key ] = & $ value ; return $ this ; }
8346	public static function route ( $ method , $ path , $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'route' , 'method' => $ method , 'path' => $ path , 'action' => $ action , 'namespace' => self :: $ namespace , 'subdomain' => self :: $ subdomain , 'uri' => self :: $ uri ) ; } }
235	protected function getColumnPhpType ( $ column ) { static $ typeMap = [ self :: TYPE_TINYINT => 'integer' , self :: TYPE_SMALLINT => 'integer' , self :: TYPE_INTEGER => 'integer' , self :: TYPE_BIGINT => 'integer' , self :: TYPE_BOOLEAN => 'boolean' , self :: TYPE_FLOAT => 'double' , self :: TYPE_DOUBLE => 'double' , self :: TYPE_BINARY => 'resource' , self :: TYPE_JSON => 'array' , ] ; if ( isset ( $ typeMap [ $ column -> type ] ) ) { if ( $ column -> type === 'bigint' ) { return PHP_INT_SIZE === 8 && ! $ column -> unsigned ? 'integer' : 'string' ; } elseif ( $ column -> type === 'integer' ) { return PHP_INT_SIZE === 4 && $ column -> unsigned ? 'string' : 'integer' ; } return $ typeMap [ $ column -> type ] ; } return 'string' ; }
9559	public function resolve ( $ handler ) { if ( ! is_string ( $ handler ) ) { return $ handler ; } $ handler = $ this -> container -> resolve ( $ handler ) ; if ( ! is_callable ( $ handler ) && ! $ handler instanceof ErrorHandlerInterface ) { $ type = is_object ( $ handler ) ? get_class ( $ handler ) : gettype ( $ handler ) ; throw new \ UnexpectedValueException ( "Resolved error handler is not a valid handler - must be callable or an instance of Autarky\Errors\ErrorHandlerInterface, $type given" ) ; } return $ handler ; }
744	private function getFragmentCacheConfiguration ( ) { $ cache = $ this -> getCacheInstance ( ) ; $ fragmentCacheConfiguration = [ 'cache' => $ cache , 'duration' => $ this -> cacheDuration , 'dependency' => $ this -> cacheDependency , 'enabled' => $ this -> cacheEnabled , ] ; return $ fragmentCacheConfiguration ; }
5766	private function clear ( ) { if ( ! isset ( $ this -> phpMailer ) ) { return ; } $ this -> phpMailer -> clearAddresses ( ) ; $ this -> phpMailer -> clearCCs ( ) ; $ this -> phpMailer -> clearBCCs ( ) ; $ this -> phpMailer -> clearReplyTos ( ) ; $ this -> phpMailer -> clearAllRecipients ( ) ; $ this -> phpMailer -> clearAttachments ( ) ; $ this -> phpMailer -> clearCustomHeaders ( ) ; }
11688	public function setCenter ( \ Chill \ MainBundle \ Entity \ Center $ center ) { $ this -> center = $ center ; return $ this ; }
3004	public function save ( $ filename ) { $ f3 = \ Base :: instance ( ) ; $ lines = explode ( "\n" , $ this -> smtp -> log ( ) ) ; $ start = false ; $ out = '' ; for ( $ i = 0 , $ max = count ( $ lines ) ; $ i < $ max ; $ i ++ ) { if ( ! $ start && preg_match ( '/^354.*?$/' , $ lines [ $ i ] , $ matches ) ) { $ start = true ; continue ; } elseif ( preg_match ( '/^250.*?$\s^QUIT/m' , $ lines [ $ i ] . ( $ i + 1 < $ max ? "\n" . $ lines [ $ i + 1 ] : '' ) , $ matches ) ) break ; if ( $ start ) $ out .= $ lines [ $ i ] . "\n" ; } if ( $ out ) { $ path = $ f3 -> get ( 'mailer.storage_path' ) ; if ( ! is_dir ( $ path ) ) mkdir ( $ path , 0777 , true ) ; $ f3 -> write ( $ path . $ filename , $ out ) ; } }
12818	public function transformCommandToMessage ( $ command ) { if ( ! is_object ( $ command ) ) { throw CommandTransformationException :: expectedObject ( $ command ) ; } if ( ! isset ( $ this -> commands [ get_class ( $ command ) ] ) ) { throw CommandTransformationException :: unknownCommand ( $ command , array_keys ( $ this -> commands ) ) ; } if ( $ this -> serializer instanceof EncoderInterface && ! $ this -> serializer -> supportsEncoding ( $ this -> format ) ) { throw CommandTransformationException :: unsupportedFormat ( $ command , $ this -> format ) ; } $ info = $ this -> commands [ get_class ( $ command ) ] ; return new CommandMessage ( $ info -> getVhost ( ) , $ info -> getExchange ( ) , $ this -> serializer -> serialize ( $ command , $ this -> format ) , $ info -> getRoutingKey ( ) , $ info -> getFlags ( ) , $ this -> resolveMessageAttributes ( $ command , $ info ) ) ; }
11370	public static function charAscii ( $ char ) { if ( self :: isAscii ( $ char ) ) { return $ char ; } $ char = htmlentities ( $ char ) ; return $ char ; }
5466	public function setIdentityForRealm ( $ host , $ realm , $ username , $ password ) { if ( isset ( $ this -> realms [ $ host ] [ $ realm ] ) ) { $ this -> realms [ $ host ] [ $ realm ] -> setIdentity ( $ username , $ password ) ; } }
7549	function deleteChild ( $ child , $ soft_delete = false ) { if ( is_object ( $ child ) ) { $ child = $ this -> findChild ( $ child ) ; } elseif ( $ child < 0 ) { $ child += count ( $ this -> children ) ; } if ( ! $ soft_delete ) { $ this -> children [ $ child ] -> delete ( ) ; } unset ( $ this -> children [ $ child ] ) ; $ tmp = array ( ) ; foreach ( array_keys ( $ this -> children ) as $ k ) { $ tmp [ ] = & $ this -> children [ $ k ] ; } $ this -> children = $ tmp ; }
10590	public static function isTypeOf ( FormInterface $ form , $ typeName ) { $ typeNames = ( array ) $ typeName ; $ type = $ form -> getConfig ( ) -> getType ( ) ; while ( $ type ) { $ actualTypeName = $ type -> getName ( ) ; if ( in_array ( $ actualTypeName , $ typeNames , true ) ) { return true ; } $ type = $ type -> getParent ( ) ; } return false ; }
2019	private function overwriteImageTargetDir ( array $ config , ContainerBuilder $ container ) : void { if ( ! isset ( $ config [ 'image' ] [ 'target_path' ] ) ) { return ; } $ container -> setParameter ( 'contao.image.target_dir' , $ container -> getParameter ( 'kernel.project_dir' ) . '/' . $ config [ 'image' ] [ 'target_path' ] ) ; @ trigger_error ( 'Using the contao.image.target_path parameter has been deprecated and will no longer work in Contao 5.0. Use the contao.image.target_dir parameter instead.' , E_USER_DEPRECATED ) ; }
3566	public function setAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ this -> hasColumn ( $ key ) && $ this -> allowsMeta ( $ key ) && ! $ this -> hasSetMutator ( $ key ) ) { return $ this -> setMeta ( $ key , $ value ) ; } return $ next ( $ value , $ args ) ; } ; }
9592	public function checkboxFilled ( $ options = [ ] , $ enclosedByLabel = true ) { Html :: addCssClass ( $ options , $ this -> checkboxFilledCssClass ) ; return parent :: checkbox ( $ options , $ enclosedByLabel ) ; }
4080	protected function isInputScreenStandalone ( $ metaModel ) { $ information = $ this -> information [ $ metaModel ] ; $ inputScreen = isset ( $ information [ self :: INPUTSCREEN ] ) ? $ information [ self :: INPUTSCREEN ] : null ; if ( ! is_object ( $ inputScreen ) ) { return ( $ inputScreen [ 'row' ] [ 'rendertype' ] == 'standalone' ) ; } return $ inputScreen -> isStandalone ( ) ; }
5930	public function removeCategory ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/categories/' . $ id . '' , $ parameters ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
1481	public function getDefaultCodec ( ) : Codec { return $ this -> factory -> createCodec ( $ this -> getContainer ( ) , $ this -> encodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ? : Encoding :: jsonApi ( ) , $ this -> decodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ) ; }
4961	public function setForm ( $ form ) { if ( ! $ form instanceof FormInterface && ! $ form instanceof Container ) { throw new \ InvalidArgumentException ( 'Form must either implement \Zend\Form\FormInterface or extend from \Core\Form\Container' ) ; } $ this -> form = $ form ; return $ this ; }
593	public function combineCssFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; $ outputFilePath = dirname ( $ this -> findRealPath ( $ outputFile ) ) ; foreach ( $ inputFiles as $ file ) { $ content .= "/*** BEGIN FILE: $file ***/\n" . $ this -> adjustCssUrl ( file_get_contents ( $ file ) , dirname ( $ this -> findRealPath ( $ file ) ) , $ outputFilePath ) . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output CSS file '{$outputFile}'." ) ; } }
1012	private function readDigits ( ) { [ $ char , $ code ] = $ this -> readChar ( ) ; if ( $ code >= 48 && $ code <= 57 ) { $ value = '' ; do { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } while ( $ code >= 48 && $ code <= 57 ) ; return $ value ; } if ( $ this -> position > $ this -> source -> length - 1 ) { $ code = null ; } throw new SyntaxError ( $ this -> source , $ this -> position , 'Invalid number, expected digit but got: ' . Utils :: printCharCode ( $ code ) ) ; }
4444	public function failedForGroup ( $ group , int $ start = 0 , int $ limit = 25 ) : array { $ results = json_decode ( $ this -> client -> failed ( $ group , $ start , $ limit ) , true ) ; if ( isset ( $ results [ 'jobs' ] ) && ! empty ( $ results [ 'jobs' ] ) ) { $ results [ 'jobs' ] = $ this -> multiget ( $ results [ 'jobs' ] ) ; } return is_array ( $ results ) ? $ results : [ ] ; }
12034	function addProcessResponseMethod ( ) { $ methodGenerator = new MethodGenerator ( 'processResponse' ) ; $ body = '' ; $ body .= $ this -> generateResponseFragment ( ) ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response. Allows you to modify the request before it is sent.' ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ parameters = [ ] ; $ parameters [ ] = new ParameterGenerator ( 'response' , 'Amp\Artax\Response' ) ; $ methodGenerator -> setParameters ( $ parameters ) ; $ tag = createParamTag ( $ parameters [ 0 ] , 'The HTTP response.' ) ; $ docBlock -> setTag ( $ tag ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
10755	protected function buildTblOpt ( ) { $ result = [ ] ; foreach ( $ this -> tbl_option as $ opt ) { $ result [ ] = $ opt ; } if ( empty ( $ result ) ) { $ result [ ] = '' ; } return $ result ; }
5454	protected function hasNamedTagOnOpenTagStack ( $ name ) { return isset ( $ this -> tags [ $ name ] ) && ( count ( $ this -> tags [ $ name ] ) > 0 ) ; }
2169	private function acceptLicense ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_license' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'license.html.twig' ) ; } $ this -> container -> get ( 'contao.install_tool' ) -> persistConfig ( 'licenseAccepted' , true ) ; return $ this -> getRedirectResponse ( ) ; }
12969	public function transformFromFront ( array $ array ) { $ transformation = $ this -> getTransformation ( ) ; $ fillables = $ this -> getFillable ( ) ; $ transformed = [ ] ; foreach ( $ fillables as $ name ) { if ( ! key_exists ( $ name , $ array ) ) { continue ; } $ transformed [ $ name ] = $ array [ $ name ] ; } foreach ( $ transformation as $ name => $ new_name ) { if ( ! key_exists ( $ new_name , $ array ) ) { continue ; } $ transformed [ $ name ] = $ array [ $ new_name ] ; } return $ transformed ; }
8880	private function isValidFullPath ( string $ path ) : bool { $ valid = false ; if ( '/' === substr ( $ path , 0 , 1 ) && is_executable ( $ path ) ) { $ valid = true ; } return $ valid ; }
11893	private function createEditForm ( CustomField $ entity , $ type ) { $ form = $ this -> createForm ( 'custom_field_choice' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfield_update' , array ( 'id' => $ entity -> getId ( ) ) ) , 'method' => 'PUT' , 'type' => $ type , 'group_widget' => 'hidden' ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Update' ) ) ; return $ form ; }
8247	public function userDataEncodePassword ( & $ userData , Password $ newPassword ) { $ encoderName = $ this -> config [ "encoder" ] ; $ encoder = $ this -> picoAuth -> getContainer ( ) -> get ( $ encoderName ) ; $ userData [ 'pwhash' ] = $ encoder -> encode ( $ newPassword -> get ( ) ) ; $ userData [ 'encoder' ] = $ encoderName ; if ( isset ( $ userData [ 'pwreset' ] ) ) { unset ( $ userData [ 'pwreset' ] ) ; } }
12159	public function getTitle ( ) { if ( ! is_object ( $ this -> _title ) ) { $ this -> _title = new Noun ( $ this -> _title ) ; } return $ this -> _title ; }
7303	public function onParentChange ( ResourceEventInterface $ event ) { $ customer = $ this -> getCustomerFromEvent ( $ event ) ; if ( $ this -> updateFromParent ( $ customer ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ customer , true ) ; } }
5647	public function paintCaseEnd ( $ test_name ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> paintCaseEnd ( $ test_name ) ; } }
6387	public function readDiscussion ( $ id ) { $ model = $ this -> readObject ( $ id , 'forum_discussions' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/forum/discuss.php?d=' . $ id ; return $ model ; }
8939	public function closeChangeset ( $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/close' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'format' ] = 'text/xml' ; $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ header ) ; }
9917	public function getRelationsForModel ( Model $ model ) { if ( empty ( $ this -> models ) ) { throw new \ LogicException ( 'AujaConfigurator not configured yet! Call configure first.' ) ; } return ! is_null ( $ model ) && isset ( $ this -> relations [ $ model -> getName ( ) ] ) ? $ this -> relations [ $ model -> getName ( ) ] : [ ] ; }
