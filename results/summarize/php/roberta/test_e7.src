10156	private function readSharedFmla ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ cellRange = substr ( $ recordData , 0 , 6 ) ; $ cellRange = $ this -> readBIFF5CellRangeAddressFixed ( $ cellRange ) ; $ no = ord ( $ recordData [ 7 ] ) ; $ formula = substr ( $ recordData , 8 ) ; $ this -> sharedFormulas [ $ this -> baseCell ] = $ formula ; }
4750	public function filterPlans ( array $ plans , array $ filters ) : array { foreach ( $ filters as $ key => $ filter ) { if ( array_key_exists ( $ key , current ( $ plans ) ) ) { $ plans = array_filter ( $ plans , function ( $ element ) use ( $ key , $ filter ) { return $ element [ $ key ] == $ filter ; } ) ; } } return $ plans ; }
661	public function beginTransaction ( $ isolationLevel = null ) { $ this -> open ( ) ; if ( ( $ transaction = $ this -> getTransaction ( ) ) === null ) { $ transaction = $ this -> _transaction = new Transaction ( [ 'db' => $ this ] ) ; } $ transaction -> begin ( $ isolationLevel ) ; return $ transaction ; }
2723	public function execute ( Observer $ observer ) { if ( $ this -> fastlyConfig -> isFastlyEnabled ( ) != true ) { return ; } $ event = $ observer -> getEvent ( ) ; $ name = $ event -> getElementName ( ) ; $ layout = $ event -> getLayout ( ) ; $ block = $ layout -> getBlock ( $ name ) ; if ( $ block instanceof AbstractBlock ) { $ blockTtl = $ block -> getTtl ( ) ; if ( isset ( $ blockTtl ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } } }
9849	public function createSignedResponse ( int $ status , string $ body , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { $ signature = \ ParagonIE_Sodium_Compat :: crypto_sign_detached ( $ body , $ key -> getString ( true ) ) ; if ( isset ( $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] ) ) { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] [ ] = Base64UrlSafe :: encode ( $ signature ) ; } else { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] = Base64UrlSafe :: encode ( $ signature ) ; } return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( $ body ) ) ; }
10838	protected function setRaw ( $ Key , $ Val , $ expire = 0 ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; return file_put_contents ( $ CacheFile , serialize ( $ Val ) ) > 0 ; }
10872	public function existEmail ( string $ email ) : int { return ( int ) $ this -> connection -> select ( self :: COLUMN_ID ) -> from ( $ this -> tableIdentity ) -> where ( [ 'email' => $ email ] ) -> fetchSingle ( ) ; }
6643	public static function decodeId ( $ hash , $ salt , $ hashLength = self :: MIN_HASH_LENGTH ) { $ hashIds = new Hashids ( $ salt , $ hashLength ) ; return ArrayHelper :: getValue ( $ hashIds -> decode ( $ hash ) , '0' ) ; }
8131	protected function removeNodeFilter ( Twig_Node $ node ) { if ( $ node instanceof Twig_Node_Expression_Filter ) { return $ this -> removeNodeFilter ( $ node -> getNode ( 'node' ) ) ; } return $ node ; }
11489	public function start ( ? string $ name = null , ? string $ sessionId = null ) : string { if ( ! $ this -> isStarted ( ) ) { if ( ! is_null ( $ name ) ) { $ this -> setName ( $ name ) ; } @ session_start ( $ sessionId ) ; } ; return $ this -> getId ( ) ; }
1916	public function generateQuestion ( ) { return sprintf ( '<span id="captcha_text_%s" class="captcha_text%s">%s</span>' , $ this -> strId , ( ( $ this -> strClass != '' ) ? ' ' . $ this -> strClass : '' ) , $ this -> getQuestion ( ) ) ; }
6456	public function selectable ( ) { $ this -> restrictElements ( [ 'select' => [ ] ] ) ; $ data = [ $ this -> value , $ this -> element -> find ( 'xpath' , "//option[@value='$this->value']" ) -> getText ( ) ] ; self :: debug ( [ 'Expected: %s' , 'Value: %s' , 'Tag: %s' , ] , [ $ this -> expected , implode ( ' => ' , $ data ) , $ this -> tag , ] ) ; $ this -> assert ( in_array ( $ this -> expected , $ data ) , 'selected' ) ; }
1905	public function query ( $ strQuery = '' ) { if ( ! empty ( $ strQuery ) ) { $ this -> strQuery = trim ( $ strQuery ) ; } if ( $ this -> strQuery == '' ) { throw new \ Exception ( 'Empty query string' ) ; } $ this -> statement = $ this -> resConnection -> executeQuery ( $ this -> strQuery ) ; if ( $ this -> statement -> columnCount ( ) < 1 ) { return $ this ; } return new Result ( $ this -> statement , $ this -> strQuery ) ; }
5767	private function create ( ) { $ m = new \ PHPMailer ( ) ; switch ( $ this -> protocol ) { case 'sendmail' : $ m -> isSendmail ( ) ; break ; case 'smtp' : $ m -> isSMTP ( ) ; $ m -> Host = $ this -> smtpHost ; $ m -> SMTPAuth = false ; $ m -> SMTPAutoTLS = false ; $ m -> Port = $ this -> smtpPort ; break ; case 'mail' : $ m -> isMail ( ) ; break ; case 'qmail' : $ m -> isQmail ( ) ; break ; default : throw new \ Exception ( 'bad phpmailerType: ' . $ this -> protocol ) ; } return $ m ; }
9496	public function getCollection ( $ end_point , $ collectionName , $ page = 1 , $ per_page = 100 , $ sort_by = null , $ sort_order = 'asc' ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ query = $ request -> getQuery ( ) -> set ( 'page' , $ page ) -> set ( 'per_page' , $ per_page ) ; if ( $ sort_by ) { $ query -> set ( 'sort_by' , $ sort_by ) -> set ( 'sort_order' , $ sort_order == 'asc' ? 'asc' : 'desc' ) ; } $ response = $ this -> processRequest ( $ request ) ; $ values = $ response -> json ( ) ; $ result = new PaginatedResult ( ) ; $ result -> setClient ( $ this ) ; if ( array_key_exists ( 'count' , $ values ) ) { $ result -> setCount ( $ values [ 'count' ] ) ; } $ result -> setCurrentPage ( $ page ) ; $ result -> setPerPage ( $ per_page ) ; $ result -> setEndPoint ( $ end_point ) ; $ type = $ this -> getType ( ) ; if ( array_key_exists ( $ collectionName , $ values ) && is_array ( $ values [ $ collectionName ] ) ) { foreach ( $ values [ $ collectionName ] as $ value ) { $ entity = new $ type ( ) ; $ this -> manage ( $ entity ) ; $ result [ ] = $ entity -> fromArray ( $ value ) ; } } return $ result ; }
1598	protected function validateAllFields ( ) : bool { $ duplicates = collect ( ( array ) $ this -> dataGet ( 'attributes' , [ ] ) ) -> intersectByKeys ( ( array ) $ this -> dataGet ( 'relationships' , [ ] ) ) -> keys ( ) ; $ this -> resourceFieldsExistInAttributesAndRelationships ( $ duplicates ) ; return $ duplicates -> isEmpty ( ) ; }
7530	protected function toString_attributes ( ) { $ s = '' ; foreach ( $ this -> attributes as $ a => $ v ) { $ s .= ' ' . $ a ; if ( ( ! $ this -> attribute_shorttag ) || ( $ v !== $ a ) ) { $ quote = ( strpos ( $ v , '"' ) === false ) ? '"' : "'" ; $ s .= '=' . $ quote . $ v . $ quote ; } } return $ s ; }
2969	protected function getTableGateway ( $ tableName ) { if ( ! array_key_exists ( $ tableName , $ this -> tableGateways ) ) { $ acl = TableSchema :: getAclInstance ( ) ; $ this -> tableGateways [ $ tableName ] = new RelationalTableGateway ( $ tableName , $ this -> connection , $ acl ) ; } return $ this -> tableGateways [ $ tableName ] ; }
4325	public static function getCallerInfo ( $ offset = 0 ) { $ return = array ( 'file' => null , 'line' => null , 'function' => null , 'class' => null , 'type' => null , ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS | DEBUG_BACKTRACE_PROVIDE_OBJECT , 8 ) ; $ numFrames = \ count ( $ backtrace ) ; $ regexInternal = '/^' . \ preg_quote ( __NAMESPACE__ ) . '\b/' ; if ( isset ( $ backtrace [ 1 ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ 1 ] [ 'class' ] ) ) { for ( $ i = $ numFrames - 1 ; $ i >= 0 ; $ i -- ) { if ( isset ( $ backtrace [ $ i ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ $ i ] [ 'class' ] ) ) { break ; } } } else { $ i = 1 ; } $ i += $ offset ; $ iLine = $ i ; $ iFunc = $ i + 1 ; if ( isset ( $ backtrace [ $ iFunc ] ) && \ in_array ( $ backtrace [ $ iFunc ] [ 'function' ] , array ( 'call_user_func' , 'call_user_func_array' ) ) ) { $ iLine ++ ; $ iFunc ++ ; } elseif ( isset ( $ backtrace [ $ iFunc ] [ 'class' ] ) && $ backtrace [ $ iFunc ] [ 'class' ] == 'ReflectionMethod' && $ backtrace [ $ iFunc ] [ 'function' ] == 'invoke' ) { $ iLine ++ ; $ iFunc -- ; } if ( isset ( $ backtrace [ $ iFunc ] ) ) { $ return = \ array_merge ( $ return , \ array_intersect_key ( $ backtrace [ $ iFunc ] , $ return ) ) ; if ( $ return [ 'type' ] == '->' ) { $ return [ 'class' ] = \ get_class ( $ backtrace [ $ iFunc ] [ 'object' ] ) ; } } if ( isset ( $ backtrace [ $ iLine ] ) ) { $ return [ 'file' ] = $ backtrace [ $ iLine ] [ 'file' ] ; $ return [ 'line' ] = $ backtrace [ $ iLine ] [ 'line' ] ; } else { $ return [ 'file' ] = $ backtrace [ $ numFrames - 1 ] [ 'file' ] ; $ return [ 'line' ] = 0 ; } return $ return ; }
1160	protected function fakeValidationData ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> validator -> getData ( ) ; $ this -> fakeFileData ( $ data , $ attribute ) ; $ this -> fakeRequiredIfData ( $ data , $ rule , $ parameters ) ; return $ data ; }
6868	protected function buildInvoicePayments ( SaleInterface $ sale ) { $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ payments = $ this -> buildPaymentList ( $ sale ) ; $ invoices = $ this -> buildInvoiceList ( $ sale ) ; foreach ( $ invoices as $ x => & $ i ) { $ oid = spl_object_id ( $ i [ 'invoice' ] ) ; $ this -> cache [ $ oid ] = [ ] ; foreach ( $ payments as $ y => & $ p ) { $ r = new IM \ InvoicePayment ( ) ; $ r -> setPayment ( $ p [ 'payment' ] ) ; $ c = Money :: compare ( $ i [ 'total' ] , $ p [ 'amount' ] , $ currency ) ; if ( 0 === $ c ) { $ r -> setAmount ( $ p [ 'amount' ] ) ; $ i [ 'total' ] = 0 ; $ p [ 'amount' ] = 0 ; unset ( $ payments [ $ y ] ) ; } elseif ( 1 === $ c ) { $ r -> setAmount ( $ p [ 'amount' ] ) ; $ i [ 'total' ] -= $ p [ 'amount' ] ; $ p [ 'amount' ] = 0 ; unset ( $ payments [ $ y ] ) ; } else { $ r -> setAmount ( $ i [ 'total' ] ) ; $ p [ 'amount' ] -= $ i [ 'total' ] ; $ i [ 'total' ] = 0 ; } $ this -> cache [ $ oid ] [ ] = $ r ; unset ( $ p ) ; } unset ( $ i ) ; } }
9973	public function setFormatCode ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: FORMAT_GENERAL ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'formatCode' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> formatCode = $ pValue ; $ this -> builtInFormatCode = self :: builtInFormatCodeIndex ( $ pValue ) ; } return $ this ; }
12278	public function moveUser ( $ openId , $ groupId ) { $ params = [ 'openid' => $ openId , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_UPDATE , $ params ] ) ; }
8836	public function setMaxRetries ( $ retries ) { switch ( gettype ( $ retries ) ) { case 'integer' : $ this -> maxRetries = new Retries ( $ retries ) ; break ; case 'object' : $ this -> maxRetries = $ retries ; break ; default : throw new InvalidArgumentException ( 'Invalid type for max retries given.' ) ; break ; } }
2992	private function parse ( $ content ) { if ( $ this -> method == 'downloadFile' ) { return $ this -> parseResponseDownloadFile ( $ content ) ; } $ xml = new SimpleXMLElement ( $ content ) ; if ( isset ( $ xml -> error ) ) { throw new Exception \ ZohoErrorException ( new ZohoError ( ( string ) $ xml -> error -> code , ( string ) $ xml -> error -> message ) ) ; } if ( isset ( $ xml -> nodata ) ) { throw new Exception \ NoDataException ( new ZohoError ( ( string ) $ xml -> nodata -> code , ( string ) $ xml -> nodata -> message ) ) ; } if ( $ this -> method == 'getFields' ) { return $ this -> parseResponseGetFields ( $ xml ) ; } if ( $ this -> method == 'deleteRecords' ) { return $ this -> parseResponseDeleteRecords ( $ xml ) ; } if ( $ this -> method == 'uploadFile' ) { return $ this -> parseResponseUploadFile ( $ xml ) ; } if ( $ this -> method == 'deleteFile' ) { return $ this -> parseResponseDeleteFile ( $ xml ) ; } if ( $ this -> method == 'getDeletedRecordIds' ) { return $ this -> parseResponseGetDeletedRecordIds ( $ xml ) ; } if ( $ this -> method == 'convertLead' ) { return $ this -> parseResponseConvertLead ( $ xml ) ; } if ( $ this -> method == 'updateRelatedRecords' ) { return $ this -> parseUpdateRelatedRecords ( $ xml ) ; } if ( isset ( $ xml -> result -> { $ this -> module } ) ) { return $ this -> parseResponseGetRecords ( $ xml ) ; } if ( isset ( $ xml -> result -> row -> success ) || isset ( $ xml -> result -> row -> error ) ) { return $ this -> parseResponsePostRecordsMultiple ( $ xml ) ; } throw new Exception \ UnexpectedValueException ( 'Xml doesn\'t contain expected fields' ) ; }
3943	public static function prepareLanguageAwareWidget ( EnvironmentInterface $ environment , PropertyInterface $ property , IMetaModel $ metaModel , $ languageLabel , $ valueLabel , $ isTextArea , $ arrValues ) { if ( ! $ metaModel -> isTranslated ( ) ) { $ extra = $ property -> getExtra ( ) ; $ extra [ 'tl_class' ] .= empty ( $ extra [ 'tl_class' ] ) ? 'w50' : ' w50' ; $ property -> setWidgetType ( 'text' ) -> setExtra ( $ extra ) ; return ; } $ fallback = $ metaModel -> getFallbackLanguage ( ) ; $ languages = self :: buildLanguageArray ( $ metaModel , $ environment -> getTranslator ( ) ) ; $ neededKeys = array_keys ( $ languages ) ; if ( array_diff_key ( array_keys ( $ arrValues ) , $ neededKeys ) ) { foreach ( $ neededKeys as $ langCode ) { $ arrValues [ $ langCode ] = '' ; } } $ rowClasses = array ( ) ; foreach ( array_keys ( $ arrValues ) as $ langCode ) { $ rowClasses [ ] = ( $ langCode == $ fallback ) ? 'fallback_language' : 'normal_language' ; } $ extra = $ property -> getExtra ( ) ; $ extra [ 'minCount' ] = $ extra [ 'maxCount' ] = count ( $ languages ) ; $ extra [ 'disableSorting' ] = true ; $ extra [ 'tl_class' ] = 'clr' ; $ extra [ 'columnFields' ] = array ( 'langcode' => array ( 'label' => $ languageLabel , 'exclude' => true , 'inputType' => 'justtextoption' , 'options' => $ languages , 'eval' => array ( 'rowClasses' => $ rowClasses , 'valign' => 'center' , 'style' => 'min-width:75px;display:block;' ) ) , 'value' => array ( 'label' => $ valueLabel , 'exclude' => true , 'inputType' => $ isTextArea ? 'textarea' : 'text' , 'eval' => array ( 'rowClasses' => $ rowClasses , 'style' => 'width:400px;' , 'rows' => 3 ) ) , ) ; $ property -> setWidgetType ( 'multiColumnWizard' ) -> setExtra ( $ extra ) ; }
2790	public static function getMutation ( array & $ tokens , $ index ) { $ num = ( float ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1.0 ; } elseif ( $ num == 1 ) { $ replace = 0.0 ; } elseif ( $ num < 2 ) { $ replace = $ num + 1 ; } else { $ replace = 1.0 ; } $ tokens [ $ index ] = [ T_DNUMBER , sprintf ( "%.2f" , $ replace ) ] ; }
3576	public function replicate ( $ except = null ) { $ except = $ except ? array_combine ( $ except , $ except ) : [ ] ; $ attributes = [ ] ; foreach ( array_diff_key ( $ this -> items , $ except ) as $ attribute ) { $ attributes [ ] = $ attribute -> replicate ( ) ; } return new static ( $ attributes ) ; }
8188	public function getBlockNames ( array $ context = null , array $ blocks = array ( ) ) { if ( null === $ context ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is internal and should never be called; calling it directly is deprecated since version 1.28 and won\'t be possible anymore in 2.0.' , E_USER_DEPRECATED ) ; return array_keys ( $ this -> blocks ) ; } $ names = array_merge ( array_keys ( $ blocks ) , array_keys ( $ this -> blocks ) ) ; if ( false !== $ parent = $ this -> getParent ( $ context ) ) { $ names = array_merge ( $ names , $ parent -> getBlockNames ( $ context ) ) ; } return array_unique ( $ names ) ; }
7602	public function render ( FormInterface $ oForm , $ sMessage , $ bDismissable = false ) { $ errorHtml = sprintf ( $ this -> messageOpenFormat , $ sMessage ) ; $ sMessagesArray = array ( ) ; foreach ( $ oForm -> getMessages ( ) as $ fieldName => $ sMessages ) { foreach ( $ sMessages as $ sMessage ) { if ( $ oForm -> get ( $ fieldName ) -> getAttribute ( 'id' ) ) { $ sMessagesArray [ ] = sprintf ( '<a href="#%s">%s</a>' , $ oForm -> get ( $ fieldName ) -> getAttribute ( 'id' ) , $ oForm -> get ( $ fieldName ) -> getLabel ( ) . ': ' . $ sMessage ) ; } else { $ sMessagesArray [ ] = $ oForm -> get ( $ fieldName ) -> getLabel ( ) . ': ' . $ sMessage ; } } } return $ this -> dangerAlert ( $ errorHtml . implode ( $ this -> messageSeparatorString , $ sMessagesArray ) . $ this -> messageCloseString , $ bDismissable ) ; }
9497	protected function getOne ( $ end_point ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ t = new $ type ( ) ; $ t -> setManagingClient ( $ this ) ; return $ t -> fromArray ( $ result [ $ baseName ] ) ; } return null ; }
8399	public function display ( Environment $ environment , $ template , $ type = null , $ size = 'md' , $ object = null ) { $ tools = $ environment -> render ( $ template , array ( 'type' => $ type , 'object' => $ object , ) ) ; return $ environment -> render ( '@c975LToolbar/toolbar.html.twig' , array ( 'tools' => $ tools , 'size' => $ size , ) ) ; }
1677	protected function getHash ( ) { @ trigger_error ( 'Using Folder::getHash() has been deprecated and will no longer work in Contao 5.0. Use Dbafs::getFolderHash() instead.' , E_USER_DEPRECATED ) ; $ arrFiles = array ( ) ; $ it = new \ RecursiveIteratorIterator ( new \ RecursiveDirectoryIterator ( $ this -> strRootDir . '/' . $ this -> strFolder , \ FilesystemIterator :: UNIX_PATHS | \ FilesystemIterator :: FOLLOW_SYMLINKS | \ FilesystemIterator :: SKIP_DOTS ) , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ it as $ i ) { if ( strncmp ( $ i -> getFilename ( ) , '.' , 1 ) !== 0 ) { $ arrFiles [ ] = substr ( $ i -> getPathname ( ) , \ strlen ( $ this -> strRootDir . '/' . $ this -> strFolder . '/' ) ) ; } } return md5 ( implode ( '-' , $ arrFiles ) ) ; }
180	protected function loadDummyBundle ( $ name ) { if ( ! isset ( $ this -> _dummyBundles [ $ name ] ) ) { $ this -> _dummyBundles [ $ name ] = $ this -> loadBundle ( $ name , [ 'sourcePath' => null , 'js' => [ ] , 'css' => [ ] , 'depends' => [ ] , ] ) ; } return $ this -> _dummyBundles [ $ name ] ; }
11305	public static function email ( $ email = null , $ errorMsg = null ) { if ( ! $ email ) return null ; $ email = trim ( mb_strtolower ( trim ( $ email ) , "UTF-8" ) ) ; if ( ! filter_var ( $ email , FILTER_VALIDATE_EMAIL ) ) { return null ; } return $ email ; }
309	public function export ( ) { if ( empty ( $ this -> message [ 'subject' ] ) ) { $ this -> message [ 'subject' ] = 'Application Log' ; } $ messages = array_map ( [ $ this , 'formatMessage' ] , $ this -> messages ) ; $ body = wordwrap ( implode ( "\n" , $ messages ) , 70 ) ; $ message = $ this -> composeMessage ( $ body ) ; if ( ! $ message -> send ( $ this -> mailer ) ) { throw new LogRuntimeException ( 'Unable to export log through email!' ) ; } }
12767	public function set ( string $ key , $ value ) : self { $ this -> store [ $ key ] = $ value ; return self :: $ instance ; }
8289	protected function authRoutes ( ) { switch ( $ this -> requestUrl ) { case 'login' : if ( $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToPage ( $ this -> config [ "afterLogin" ] ) ; } break ; case 'logout' : if ( ! $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToLogin ( ) ; } $ this -> checkLogoutSubmission ( ) ; break ; } }
3032	public function getSessionState ( AssessmentTestSession $ session ) { $ deliveryExecution = $ this -> getDeliveryExecution ( $ session ) ; return $ deliveryExecution -> getState ( ) -> getUri ( ) ; }
6915	public function addAttachment ( AttachmentInterface $ attachment ) { if ( ! $ this -> attachments -> contains ( $ attachment ) ) { $ this -> attachments -> add ( $ attachment ) ; } return $ this ; }
4151	protected function resetCallState ( ) { $ this -> call = null ; $ this -> method = null ; $ this -> withMedia = null ; $ this -> getParams = array ( ) ; $ this -> postParams = array ( ) ; $ this -> headers = null ; }
150	public function addError ( $ model , $ attribute , $ message , $ params = [ ] ) { $ params [ 'attribute' ] = $ model -> getAttributeLabel ( $ attribute ) ; if ( ! isset ( $ params [ 'value' ] ) ) { $ value = $ model -> $ attribute ; if ( is_array ( $ value ) ) { $ params [ 'value' ] = 'array()' ; } elseif ( is_object ( $ value ) && ! method_exists ( $ value , '__toString' ) ) { $ params [ 'value' ] = '(object)' ; } else { $ params [ 'value' ] = $ value ; } } $ model -> addError ( $ attribute , $ this -> formatMessage ( $ message , $ params ) ) ; }
1242	private static function determineActualValueToAssign ( $ class , $ property , $ value ) { if ( ! array_key_exists ( $ property , self :: $ properties [ $ class ] ) ) { return $ value ; } $ info = self :: propertyInfo ( $ class , $ property ) ; if ( $ info [ 'repeatable' ] && is_array ( $ value ) ) { $ values = [ ] ; foreach ( $ value as $ val ) { $ values [ ] = self :: actualValue ( $ info , $ val ) ; } return $ values ; } return self :: actualValue ( $ info , $ value ) ; }
4786	function offsetGet ( $ key ) { $ this -> access ( $ key ) ; if ( ! array_key_exists ( $ key , $ this -> row ) ) { $ this -> access ( $ key , true ) ; } return $ this -> row [ $ key ] ; }
10579	private function codesEqual ( string $ known , string $ given ) : bool { if ( strlen ( $ given ) !== strlen ( $ known ) ) { return false ; } $ res = 0 ; $ knownLen = strlen ( $ known ) ; for ( $ i = 0 ; $ i < $ knownLen ; ++ $ i ) { $ res |= ( ord ( $ known [ $ i ] ) ^ ord ( $ given [ $ i ] ) ) ; } return $ res === 0 ; }
4559	protected function execute ( LifecycleEventArgs $ args , $ action ) { $ this -> tokenStorage = $ this -> container -> get ( 'security.token_storage' ) ; $ this -> configService = $ this -> container -> get ( 'ds_config.service.config' ) ; $ this -> auditService = $ this -> container -> get ( 'ds_audit.service.audit' ) ; $ entity = $ args -> getEntity ( ) ; if ( $ entity instanceof Audit ) { return ; } if ( ! $ entity instanceof Auditable ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( ! $ token ) { return ; } $ user = $ token -> getUser ( ) ; $ edits = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getEntityChangeSet ( $ entity ) ; $ properties = $ this -> auditService -> getProperties ( $ entity ) ; foreach ( array_keys ( $ edits ) as $ key ) { if ( ! in_array ( $ key , $ properties ) ) { unset ( $ edits [ $ key ] ) ; } } $ audit = $ this -> auditService -> createInstance ( ) ; $ audit -> setOwner ( $ this -> configService -> get ( 'ds_audit.audit.owner' ) ) -> setOwnerUuid ( $ this -> configService -> get ( 'ds_audit.audit.owner_uuid' ) ) -> setUserUuid ( $ user -> getUuid ( ) ) -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) -> setAction ( $ action ) -> setData ( [ 'entity' => basename ( str_replace ( '\\' , '/' , get_class ( $ entity ) ) ) , 'entityUuid' => $ entity -> getUuid ( ) , 'edits' => $ edits ] ) ; $ manager = $ this -> auditService -> getManager ( ) ; $ manager -> persist ( $ audit ) ; $ manager -> flush ( ) ; }
122	private function createAuthFromUrl ( ) { $ uri = parse_url ( $ this -> url ) ; if ( empty ( $ uri [ 'user' ] ) ) { return $ this -> hasAuth = false ; } $ this -> credentials [ 'username' ] = $ uri [ 'user' ] ; if ( ! empty ( $ uri [ 'pass' ] ) ) { $ this -> credentials [ 'password' ] = $ uri [ 'pass' ] ; } return $ this -> hasAuth = true ; }
5984	public function updateCredentials ( $ user , $ password ) { $ oldUser = $ this -> credentials -> getUsername ( ) ; $ this -> credentials = new Credentials ( $ this -> credentials -> getClientId ( ) , $ user , $ password ) ; unset ( $ password ) ; if ( $ this -> client instanceof Client ) { $ this -> client = $ this -> oauth2Middleware = null ; $ this -> client = $ this -> getClient ( ) ; } if ( $ this -> cache instanceof CacheProvider ) { $ this -> cache -> setNamespace ( md5 ( $ this -> basepath . $ this -> credentials -> getUsername ( ) . $ this -> credentials -> getPassword ( ) ) ) ; } $ this -> logger -> notice ( 'Updated user!' , [ 'old' => $ oldUser , 'new' => $ user ] ) ; }
11342	public function setDesigner ( Designer $ designer ) { $ this -> designer = $ designer ; $ this -> designer -> build ( $ this ) ; }
9252	protected function initializeContainer ( ) { $ this -> registerDefaultExtensions ( ) ; $ initializer = $ this -> getContainerInitializer ( ) ; $ this -> container = $ initializer -> initializeContainer ( $ this , $ this -> extensions , $ this -> compilerPasses ) ; $ this -> container -> set ( 'app' , $ this ) ; return $ this -> container ; }
9626	public function getAll ( array $ filterAttributes = [ ] ) { $ filters = [ 'query' => [ $ filterAttributes ] ] ; try { $ result = $ this -> client -> get ( $ this -> slug , $ filters ) ; } catch ( RequestException $ e ) { $ return [ 'request' ] = $ e -> getRequest ( ) . "\n" ; if ( $ e -> hasResponse ( ) ) { return $ return [ 'response' ] = $ e -> getResponse ( ) . "\n" ; } } return $ result -> json ( ) ; }
2475	public function deleteContent ( $ contentId , $ versionId = null ) { $ idPrefix = $ this -> mapper -> generateContentDocumentId ( $ contentId ) ; $ this -> gateway -> deleteByQuery ( "_root_:{$idPrefix}*" ) ; }
10112	private function writeRangeProtection ( ) { foreach ( $ this -> phpSheet -> getProtectedCells ( ) as $ range => $ password ) { $ cellRanges = explode ( ' ' , $ range ) ; $ cref = count ( $ cellRanges ) ; $ recordData = pack ( 'vvVVvCVvVv' , 0x0868 , 0x00 , 0x0000 , 0x0000 , 0x02 , 0x0 , 0x0000 , $ cref , 0x0000 , 0x00 ) ; foreach ( $ cellRanges as $ cellRange ) { $ recordData .= $ this -> writeBIFF8CellRangeAddressFixed ( $ cellRange ) ; } $ recordData .= pack ( 'VV' , 0x0000 , hexdec ( $ password ) ) ; $ recordData .= StringHelper :: UTF8toBIFF8UnicodeLong ( 'p' . md5 ( $ recordData ) ) ; $ length = strlen ( $ recordData ) ; $ record = 0x0868 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; } }
1044	private static function highlightSourceAtLocation ( Source $ source , SourceLocation $ location ) { $ line = $ location -> line ; $ lineOffset = $ source -> locationOffset -> line - 1 ; $ columnOffset = self :: getColumnOffset ( $ source , $ location ) ; $ contextLine = $ line + $ lineOffset ; $ contextColumn = $ location -> column + $ columnOffset ; $ prevLineNum = ( string ) ( $ contextLine - 1 ) ; $ lineNum = ( string ) $ contextLine ; $ nextLineNum = ( string ) ( $ contextLine + 1 ) ; $ padLen = strlen ( $ nextLineNum ) ; $ lines = preg_split ( '/\r\n|[\n\r]/' , $ source -> body ) ; $ lines [ 0 ] = self :: whitespace ( $ source -> locationOffset -> column - 1 ) . $ lines [ 0 ] ; $ outputLines = [ sprintf ( '%s (%s:%s)' , $ source -> name , $ contextLine , $ contextColumn ) , $ line >= 2 ? ( self :: lpad ( $ padLen , $ prevLineNum ) . ': ' . $ lines [ $ line - 2 ] ) : null , self :: lpad ( $ padLen , $ lineNum ) . ': ' . $ lines [ $ line - 1 ] , self :: whitespace ( 2 + $ padLen + $ contextColumn - 1 ) . '^' , $ line < count ( $ lines ) ? self :: lpad ( $ padLen , $ nextLineNum ) . ': ' . $ lines [ $ line ] : null , ] ; return implode ( "\n" , array_filter ( $ outputLines ) ) ; }
7690	function OpenXML_ChartGetInfoFromFile ( $ idx , $ Txt = false ) { if ( $ idx === false ) return false ; $ file = $ this -> CdFileLst [ $ idx ] [ 'v_name' ] ; $ relative = ( substr_count ( $ file , '/' ) == 1 ) ? '' : '../' ; $ o = $ this -> OpenXML_Rels_GetObj ( $ file , $ relative . 'charts/' ) ; if ( $ o -> ChartLst === false ) { if ( $ Txt === false ) $ Txt = $ this -> TbsStoreGet ( $ idx , 'OpenXML_ChartGetInfoFromFile' ) ; $ o -> ChartLst = array ( ) ; $ p = 0 ; while ( $ t = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'c:chart' , $ p ) ) { $ rid = $ t -> GetAttLazy ( 'r:id' ) ; $ name = false ; $ title = false ; $ descr = false ; $ parent = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'wp:inline' , $ t -> PosBeg , false ) ; if ( $ parent === false ) $ parent = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'p:nvGraphicFramePr' , $ t -> PosBeg , false ) ; if ( $ parent !== false ) { $ parent -> FindEndTag ( ) ; $ src = $ parent -> GetInnerSrc ( ) ; $ el = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ src , 'title' , 0 ) ; if ( $ el !== false ) $ title = $ el -> GetAttLazy ( 'title' ) ; $ el = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ src , 'descr' , 0 ) ; if ( $ el !== false ) $ descr = $ el -> GetAttLazy ( 'descr' ) ; } if ( isset ( $ o -> TargetLst [ $ rid ] ) ) { $ name = basename ( $ o -> TargetLst [ $ rid ] ) ; if ( substr ( $ name , - 4 ) === '.xml' ) $ name = substr ( $ name , 0 , strlen ( $ name ) - 4 ) ; } $ o -> ChartLst [ ] = array ( 'rid' => $ rid , 'title' => $ title , 'descr' => $ descr , 'name' => $ name ) ; $ p = $ t -> PosEnd ; } } return $ o -> ChartLst ; }
8408	public static function set ( $ name , $ value , $ expire = 0 , $ path = null ) { if ( $ path === null ) { setcookie ( $ name , $ value , $ expire ) ; } else { setcookie ( $ name , $ value , $ expire , $ path ) ; } }
2381	public static function stripRootDir ( $ path ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ length = \ strlen ( $ rootDir ) ; if ( strncmp ( $ path , $ rootDir , $ length ) !== 0 || \ strlen ( $ path ) <= $ length || ( $ path [ $ length ] !== '/' && $ path [ $ length ] !== '\\' ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Path "%s" is not inside the Contao root dir "%s"' , $ path , $ rootDir ) ) ; } return ( string ) substr ( $ path , $ length + 1 ) ; }
8163	static public function register ( ) { if ( static :: $ registered === true ) { return true ; } $ kirby = kirby ( ) ; if ( ! class_exists ( 'Kirby\Component\Template' ) ) { throw new Exception ( 'The Kirby Twig plugin requires Kirby 2.3 or higher. Current version: ' . $ kirby -> version ( ) ) ; } if ( ! class_exists ( 'Twig_Environment' ) ) { require_once __DIR__ . '/../lib/Twig/lib/Twig/Autoloader.php' ; \ Twig_Autoloader :: register ( ) ; } $ kirby -> set ( 'component' , 'template' , 'Kirby\Twig\TwigComponent' ) ; if ( is_executable ( 'twig' ) === false ) { require_once __DIR__ . '/helpers.php' ; } return static :: $ registered = true ; }
10186	private static function fromArray ( $ object , $ type = null , $ innerType = null ) { if ( $ type == 'array' ) { foreach ( $ object as $ element ) { $ result [ ] = self :: fromArray ( $ element , $ innerType ) ; } return $ result ; } else if ( class_exists ( $ type ) ) { $ class = new $ type ( ) ; if ( is_subclass_of ( $ class , 'AbstractJSONWrapper' ) ) { $ class -> fromArray ( $ object ) ; return $ class ; } else { trigger_error ( __CLASS__ . ": Trying to deserialize " . get_class ( $ class ) ) ; return $ object ; } } else { return $ object ; } }
5365	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; $ this -> results [ ] = new SimpleResultOfPass ( parent :: getTestList ( ) , $ message ) ; }
8821	public function filter ( $ data = null , $ filter = false ) { if ( is_null ( $ data ) ) { return null ; } if ( is_array ( $ data ) ) { return array_map ( function ( $ value ) use ( $ filter ) { return $ this -> filter ( $ value , $ filter ) ; } , $ data ) ; } return ( $ filter == true ? $ this -> xssClean ( $ data ) : trim ( $ data ) ) ; }
9763	function endWith ( string $ value ) : self { return $ this -> expect ( $ this -> target , stringEndsWith ( $ value ) ) ; }
3667	private function getRow ( $ rowId , $ table ) { return ( object ) $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( $ table ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ rowId ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; }
48	protected function getListeners ( Event $ event ) { $ scriptListeners = $ this -> getScriptListeners ( $ event ) ; if ( ! isset ( $ this -> listeners [ $ event -> getName ( ) ] [ 0 ] ) ) { $ this -> listeners [ $ event -> getName ( ) ] [ 0 ] = array ( ) ; } krsort ( $ this -> listeners [ $ event -> getName ( ) ] ) ; $ listeners = $ this -> listeners ; $ listeners [ $ event -> getName ( ) ] [ 0 ] = array_merge ( $ listeners [ $ event -> getName ( ) ] [ 0 ] , $ scriptListeners ) ; return call_user_func_array ( 'array_merge' , $ listeners [ $ event -> getName ( ) ] ) ; }
5290	protected static function requestCurl ( $ url , $ params ) { $ ch = curl_init ( ) ; $ options = array ( CURLOPT_URL => $ url , CURLOPT_HTTPHEADER => self :: getHeaders ( ) , CURLOPT_POSTFIELDS => json_encode ( $ params ) , CURLOPT_CONNECTTIMEOUT => self :: $ connectTimeout , CURLOPT_TIMEOUT => self :: $ requestTimeout , CURLOPT_USERAGENT => self :: getUserAgent ( ) , CURLOPT_RETURNTRANSFER => true ) ; curl_setopt_array ( $ ch , $ options ) ; $ result = curl_exec ( $ ch ) ; if ( $ result === false ) { $ e = new Error ( curl_error ( $ ch ) ) ; curl_close ( $ ch ) ; throw $ e ; } curl_close ( $ ch ) ; return $ result ; }
9338	public function isSupplementary ( Angle $ angle ) { $ out = new self ( $ this -> float_rad + $ angle -> rad ) ; return $ out -> isStraight ( ) ; }
7568	protected function parse ( ) { $ p = & $ this -> parser ; $ p -> setPos ( 0 ) ; $ this -> result = array ( ) ; if ( ! $ this -> parse_single ( ) ) { return false ; } while ( count ( $ this -> result ) > 0 ) { switch ( $ p -> token ) { case CSSQueryTokenizer :: TOK_CHILD : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( false , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_SIBLING : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( true , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_PLUS : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_adjacent ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_ALL : case CSSQueryTokenizer :: TOK_IDENTIFIER : case CSSQueryTokenizer :: TOK_STRING : case CSSQueryTokenizer :: TOK_BRACE_OPEN : case CSSQueryTokenizer :: TOK_BRACKET_OPEN : case CSSQueryTokenizer :: TOK_ID : case CSSQueryTokenizer :: TOK_CLASS : case CSSQueryTokenizer :: TOK_COLON : if ( ! $ this -> parse_result ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_NULL : break 2 ; default : $ this -> error ( 'Invalid search pattern(3): No result modifier found!' ) ; return false ; } } return true ; }
9490	protected function getFileDataValue ( $ obFile ) { if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } $ sUploadFolder = Config :: get ( 'cms.storage.uploads.path' , '/storage/app/uploads' ) ; return [ 'full_path' => $ obFile -> getPath ( ) , 'path' => $ sUploadFolder . str_replace ( 'uploads' , '' , $ obFile -> getDiskPath ( ) ) , 'title' => $ obFile -> getAttribute ( 'title' ) , 'alt' => $ obFile -> getAttribute ( 'description' ) , ] ; }
12002	static public function generate ( $ length = 16 , $ algorithm = 'sha256' ) { if ( ! in_array ( $ algorithm , self :: $ allowedAlgorithm ) ) { throw new Exception ( "Hash algorithm $algorithm doesn't exists!" ) ; } $ salt = hash ( $ algorithm , time ( ) ) ; return substr ( hash ( $ algorithm , ( mt_rand ( self :: RAND_MIN , self :: RAND_MAX ) % $ length ) . $ salt . mt_rand ( self :: RAND_MIN , self :: RAND_MAX ) ) , self :: CUT_LEN , $ length ) ; }
12170	public function createTables ( Database $ database ) { $ this -> database = $ database ; $ this -> database -> startTransaction ( ) ; $ this -> createAuthorityTable ( ) ; $ this -> createAuthorityPermissionsTable ( ) ; $ this -> createMenutable ( ) ; $ this -> createMenuGroupTable ( ) ; $ this -> createOptionsTable ( ) ; $ this -> createSessionTable ( ) ; $ this -> createTaxonomyTable ( ) ; $ this -> createObjectsTable ( ) ; $ this -> createGroupsTable ( ) ; $ this -> createObjectsAuthorityTable ( ) ; $ this -> createObjectsGroupTable ( ) ; $ this -> createObjectsEdgesTable ( ) ; $ this -> createPropertiesTable ( ) ; $ this -> createPropertyDatatypeTable ( ) ; $ this -> createPropertyValuesTable ( ) ; $ this -> createIndices ( ) ; $ this -> insertPropertyDatatypes ( ) ; $ this -> createObjectsRatingTable ( ) ; $ this -> createPropertyValuesProxyTable ( "attachment" ) ; $ this -> createPropertyValuesProxyTable ( "media" ) ; $ this -> createPropertyValuesProxyTable ( "user" ) ; $ this -> createPropertyValuesProxyTable ( "page" ) ; if ( ! $ this -> database -> commitTransaction ( ) ) { return false ; } return true ; }
11435	public function delete ( string $ sName ) { return unlink ( $ this -> _sFolder . $ this -> _getSubDirectory ( $ sName ) . md5 ( $ sName ) . '.fil.cac' ) ; }
10426	private function body ( ResponseInterface $ response ) : ResponseInterface { if ( ! in_array ( $ response -> getStatusCode ( ) , $ this -> responseIsEmpty ) ) { $ stream = $ response -> getBody ( ) ; if ( $ stream -> isSeekable ( ) ) { $ stream -> rewind ( ) ; } $ bufferLenght = ( ! $ response -> getHeaderLine ( 'Content-Length' ) ) ? $ stream -> getSize ( ) : $ response -> getHeaderLine ( 'Content-Length' ) ; if ( isset ( $ bufferLenght ) ) { $ lengthToRead = $ bufferLenght ; while ( $ lengthToRead > 0 && ! $ stream -> eof ( ) ) { $ data = $ stream -> read ( min ( $ this -> sizeLimit , $ lengthToRead ) ) ; echo $ data ; $ lengthToRead -= strlen ( $ data ) ; } } else { while ( ! $ stream -> eof ( ) ) { echo $ stream -> read ( $ this -> size ) ; } } } return $ response ; }
11976	public function handleCommandHelp ( Event $ event , Queue $ queue ) { $ this -> sendIrcResponse ( $ event , $ queue , $ this -> getHelpLines ( ) ) ; }
11179	protected function get ( $ key ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; if ( ! is_array ( $ cache ) ) { return false ; } else { if ( isset ( $ cache [ $ key ] ) ) { return $ cache [ $ key ] ; } return false ; } }
7873	public function credit ( ) : ? array { $ this -> checkConfig ( ) ; $ query = http_build_query ( [ 'userkey' => $ this -> userkey , 'passkey' => $ this -> passkey , ] ) ; $ response = Request :: get ( $ this -> baseUrl . '/smsapibalance.php?' . $ query ) ; $ xml = simplexml_load_string ( $ response -> body ) ; $ body = json_decode ( json_encode ( $ xml ) , true ) ; return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ body [ 'message' ] [ 'text' ] ?? '' , 'data' => $ body , ] ; }
4910	public function renderSummary ( SummaryFormInterface $ form ) { $ form -> prepare ( ) ; $ baseFieldset = $ form -> getBaseFieldset ( ) ; if ( ! isset ( $ baseFieldset ) ) { throw new \ InvalidArgumentException ( 'For the Form ' . get_class ( $ form ) . ' there is no Basefieldset' ) ; } $ dataAttributesMarkup = '' ; foreach ( $ form -> getAttributes ( ) as $ dataKey => $ dataValue ) { if ( preg_match ( '/^data-/' , $ dataKey ) ) { $ dataAttributesMarkup .= sprintf ( ' %s="%s"' , $ dataKey , $ dataValue ) ; } } $ markup = '<div class="panel panel-default" style="min-height: 100px;"' . $ dataAttributesMarkup . '> <div class="panel-body"><div class="sf-controls">%s</div>%s</div></div>' ; $ view = $ this -> getView ( ) ; $ buttonMarkup = false === $ form -> getOption ( 'editable' ) ? '' : '<button type="button" class="btn btn-default btn-xs sf-edit">' . '<span class="yk-icon yk-icon-edit"></span> ' . $ view -> translate ( 'Edit' ) . '</button>' ; if ( ( $ controlButtons = $ form -> getOption ( 'control_buttons' ) ) !== null ) { $ buttonMarkup .= PHP_EOL . implode ( PHP_EOL , array_map ( function ( array $ buttonSpec ) use ( $ view ) { return '<button type="button" class="btn btn-default btn-xs' . ( isset ( $ buttonSpec [ 'class' ] ) ? ' ' . $ buttonSpec [ 'class' ] : '' ) . '">' . ( isset ( $ buttonSpec [ 'icon' ] ) ? '<span class="yk-icon yk-icon-' . $ buttonSpec [ 'icon' ] . '"></span> ' : '' ) . $ view -> translate ( $ buttonSpec [ 'label' ] ) . '</button>' ; } , $ controlButtons ) ) ; } $ elementMarkup = $ this -> renderSummaryElement ( $ baseFieldset ) ; return sprintf ( $ markup , $ buttonMarkup , $ elementMarkup ) ; }
6098	protected function post ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_POST , null , $ fireAndForget ) ; }
7625	public function blobExists ( $ containerName = '' , $ blobName = '' , $ snapshotId = null ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; try { $ this -> getBlobInstance ( $ containerName , $ blobName , $ snapshotId ) ; } catch ( BlobException $ e ) { return false ; } return true ; }
8274	public function assertUsername ( $ username , $ config ) { if ( ! is_string ( $ username ) ) { throw new ConfigurationException ( "Username $username must be a string." ) ; } $ len = strlen ( $ username ) ; $ minLen = $ config [ "registration" ] [ "nameLenMin" ] ; $ maxLen = $ config [ "registration" ] [ "nameLenMax" ] ; if ( $ len < $ minLen || $ len > $ maxLen ) { throw new ConfigurationException ( sprintf ( "Length of a username $username must be between %d-%d characters." , $ minLen , $ maxLen ) ) ; } if ( ! $ this -> checkValidNameFormat ( $ username ) ) { throw new ConfigurationException ( "Username $username contains invalid character/s." ) ; } }
84	public static function expandPath ( $ path ) { if ( preg_match ( '#^~[\\/]#' , $ path ) ) { return self :: getUserDirectory ( ) . substr ( $ path , 1 ) ; } return preg_replace_callback ( '#^(\$|(?P<percent>%))(?P<var>\w++)(?(percent)%)(?P<path>.*)#' , function ( $ matches ) { if ( Platform :: isWindows ( ) && $ matches [ 'var' ] == 'HOME' ) { return ( getenv ( 'HOME' ) ? : getenv ( 'USERPROFILE' ) ) . $ matches [ 'path' ] ; } return getenv ( $ matches [ 'var' ] ) . $ matches [ 'path' ] ; } , $ path ) ; }
4714	public function replaceString ( $ search , $ replace ) { $ this -> text = str_replace ( $ search , $ replace , $ this -> text ) ; return $ this ; }
2043	public static function findByEmailAndPids ( $ strEmail , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.email=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) , $ strEmail , $ arrOptions ) ; }
10127	private function writeWsbool ( ) { $ record = 0x0081 ; $ length = 0x0002 ; $ grbit = 0x0000 ; $ grbit |= 0x0001 ; if ( $ this -> outlineStyle ) { $ grbit |= 0x0020 ; } if ( $ this -> phpSheet -> getShowSummaryBelow ( ) ) { $ grbit |= 0x0040 ; } if ( $ this -> phpSheet -> getShowSummaryRight ( ) ) { $ grbit |= 0x0080 ; } if ( $ this -> phpSheet -> getPageSetup ( ) -> getFitToPage ( ) ) { $ grbit |= 0x0100 ; } if ( $ this -> outlineOn ) { $ grbit |= 0x0400 ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ grbit ) ; $ this -> append ( $ header . $ data ) ; }
8290	protected function checkLogoutSubmission ( ) { $ post = $ this -> request -> request ; if ( $ post -> has ( "logout" ) ) { if ( ! $ this -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: LOGOUT_CSRF_ACTION ) ) { $ this -> redirectToPage ( "logout" ) ; } $ this -> logout ( ) ; } }
1968	public static function findByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; if ( Validator :: isStringUuid ( $ intPid ) ) { $ intPid = StringUtil :: uuidToBin ( $ intPid ) ; } return static :: findBy ( array ( "$t.pid=UNHEX(?)" ) , bin2hex ( $ intPid ) , $ arrOptions ) ; }
6965	public function isIdentityEmpty ( ) { return empty ( $ this -> gender ) && empty ( $ this -> firstName ) && empty ( $ this -> lastName ) ; }
12636	protected function getSandboxSignKey ( ) { if ( $ this -> sandboxSignKey ) { return $ this -> sandboxSignKey ; } $ cacheKey = 'sandbox_signkey.' . $ this -> merchant -> merchant_id . $ this -> merchant -> sub_merchant_id ; $ cache = $ this -> getCache ( ) ; $ this -> sandboxSignKey = $ cache -> fetch ( $ cacheKey ) ; if ( ! $ this -> sandboxSignKey ) { $ result = $ this -> request ( self :: API_SANDBOX_SIGN_KEY , [ ] ) ; if ( $ result -> return_code === 'SUCCESS' ) { $ cache -> save ( $ cacheKey , $ result -> sandbox_signkey , 24 * 3600 ) ; return $ this -> sandboxSignKey = $ result -> sandbox_signkey ; } throw new Exception ( $ result -> return_msg ) ; } return $ this -> sandboxSignKey ; }
4506	public function create ( OrganizationPersona $ persona , Parameters $ parameters = null ) : OrganizationPersona { $ options = [ ] ; $ options [ 'json' ] = ( array ) static :: toObject ( $ persona ) ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; } $ object = $ this -> execute ( 'POST' , static :: RESOURCE_LIST , $ options ) ; $ persona = static :: toModel ( $ object ) ; return $ persona ; }
7457	public function persist ( ObjectManager $ manager ) { foreach ( $ this -> entities as $ entity ) { $ manager -> persist ( $ entity ) ; } if ( $ this -> root ) { $ manager -> persist ( $ this -> root ) ; } }
462	public function buildCondition ( $ condition , & $ params ) { if ( is_array ( $ condition ) ) { if ( empty ( $ condition ) ) { return '' ; } $ condition = $ this -> createConditionFromArray ( $ condition ) ; } if ( $ condition instanceof ExpressionInterface ) { return $ this -> buildExpression ( $ condition , $ params ) ; } return ( string ) $ condition ; }
3945	public function onLoadDataContainer ( $ tableName ) { static $ tableExists ; if ( null === $ tableExists ) { $ tableExists = \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' ] ) ; } if ( false === $ tableExists ) { return ; } $ this -> handleMetaModelTable ( $ tableName ) ; $ this -> handleNonMetaModelTable ( $ tableName ) ; }
6502	public function parseQueryString ( Uri $ uri ) : IImmutableDictionary { if ( ( $ queryString = $ uri -> getQueryString ( ) ) === null ) { return new ImmutableHashTable ( [ ] ) ; } if ( ! isset ( $ this -> parsedQueryStringCache [ $ queryString ] ) ) { $ parsedQueryString = [ ] ; parse_str ( $ queryString , $ parsedQueryString ) ; $ kvps = [ ] ; foreach ( $ parsedQueryString as $ key => $ value ) { $ kvps [ ] = new KeyValuePair ( $ key , $ value ) ; } $ this -> parsedQueryStringCache [ $ queryString ] = new ImmutableHashTable ( $ kvps ) ; } return $ this -> parsedQueryStringCache [ $ queryString ] ; }
7785	public function setStatementClass ( $ statementClass ) { if ( ! is_callable ( $ statementClass ) && ! class_exists ( $ statementClass ) ) { throw new \ InvalidArgumentException ( '$statementClass must be a valid classname or a PHP callable' ) ; } $ this -> statementClass = $ statementClass ; return $ this ; }
8736	public function insert ( array $ values ) { list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; if ( $ this -> query -> insert ( $ values ) ) { return $ this -> insertI18n ( $ i18nValues , $ values [ $ this -> model -> getKeyName ( ) ] ) ; } }
1760	public static function anonymizeIp ( $ strIp ) { if ( $ strIp == '127.0.0.1' || $ strIp == '::1' ) { return $ strIp ; } if ( strpos ( $ strIp , ':' ) !== false ) { return substr_replace ( $ strIp , ':0000' , strrpos ( $ strIp , ':' ) ) ; } else { return substr_replace ( $ strIp , '.0' , strrpos ( $ strIp , '.' ) ) ; } }
3832	protected function validateWidget ( $ widget , $ value ) { if ( null === $ value ) { return ; } $ widget -> setInputCallback ( function ( ) use ( $ value ) { return $ value ; } ) ; $ widget -> validate ( ) ; }
11779	protected function buildClass ( $ name ) { $ stub = $ this -> files -> get ( $ this -> getStub ( ) ) ; return str_replace ( 'DummyHelper' , $ this -> getNameInput ( ) , $ stub ) ; }
4849	protected function createDriver ( $ driverClass ) : Driver \ DriverInterface { return isset ( $ this -> container ) ? $ this -> container -> get ( $ driverClass ) : new $ driverClass ( ) ; }
1531	public static function create ( ValidatorInterface $ validator ) : self { $ ex = new self ( $ validator -> getErrors ( ) ) ; $ ex -> validator = $ validator ; return $ ex ; }
10057	public function hasItem ( $ key ) { if ( isset ( $ this -> data [ $ key ] ) ) { $ item = $ this -> data [ $ key ] ; if ( $ item -> isHit ( ) === true && ( $ item -> getExpires ( ) === null || $ item -> getExpires ( ) > new DateTime ( ) ) ) { return true ; } } return false ; }
4366	protected function backtraceStr ( Event $ error ) { $ backtrace = $ error [ 'backtrace' ] ? $ error [ 'backtrace' ] : $ error -> getSubject ( ) -> backtrace ( ) ; if ( \ count ( $ backtrace ) < 2 ) { return '' ; } if ( $ backtrace && $ error [ 'vars' ] ) { $ backtrace [ 0 ] [ 'vars' ] = $ error [ 'vars' ] ; } if ( $ this -> cfg [ 'emailBacktraceDumper' ] ) { $ str = \ call_user_func ( $ this -> cfg [ 'emailBacktraceDumper' ] , $ backtrace ) ; } else { $ search = array ( ")\n\n" , ) ; $ replace = array ( ")\n" , ) ; $ str = \ print_r ( $ backtrace , true ) ; $ str = \ preg_replace ( '#\bArray\n\(#' , 'array(' , $ str ) ; $ str = \ preg_replace ( '/\barray\s+\(\s+\)/s' , 'array()' , $ str ) ; $ str = \ str_replace ( $ search , $ replace , $ str ) ; $ str = \ substr ( $ str , 0 , - 1 ) ; } return $ str ; }
8358	public static function niceUrl ( string $ url ) { $ nice = null ; if ( ( $ pos = stripos ( $ url , '.' ) ) !== false ) { list ( $ subDomain , $ url ) = explode ( '.' , $ url ) ; $ request = Http :: getRequest ( ) ; $ nice = $ request -> getRawRequest ( ) -> getScheme ( ) . '://' ; if ( $ subDomain != null ) { $ nice .= $ subDomain . '.' ; } $ nice .= self :: extractDomain ( $ request -> getRawRequest ( ) ) ; } return $ nice . '/' . ltrim ( ( string ) preg_replace ( '/\/+/' , '/' , $ url ) , '/' ) ; }
314	public function getVendorPath ( ) { if ( $ this -> _vendorPath === null ) { $ this -> setVendorPath ( $ this -> getBasePath ( ) . DIRECTORY_SEPARATOR . 'vendor' ) ; } return $ this -> _vendorPath ; }
2147	protected function sendNewsletter ( Email $ objEmail , Result $ objNewsletter , $ arrRecipient , $ text , $ html , $ css = null ) { $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ text , $ arrRecipient ) ; if ( ! $ objNewsletter -> sendText ) { if ( $ objNewsletter -> template == '' ) { $ objNewsletter -> template = 'mail_default' ; } $ objTemplate = new BackendTemplate ( $ objNewsletter -> template ) ; $ objTemplate -> setData ( $ objNewsletter -> row ( ) ) ; $ objTemplate -> title = $ objNewsletter -> subject ; $ objTemplate -> body = StringUtil :: parseSimpleTokens ( $ html , $ arrRecipient ) ; $ objTemplate -> charset = Config :: get ( 'characterSet' ) ; $ objTemplate -> recipient = $ arrRecipient [ 'email' ] ; $ objTemplate -> css = $ css ; $ objEmail -> html = $ objTemplate -> parse ( ) ; $ objEmail -> imageDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' ; } try { $ objEmail -> sendTo ( $ arrRecipient [ 'email' ] ) ; } catch ( \ Swift_RfcComplianceException $ e ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( $ objEmail -> hasFailures ( ) ) { $ _SESSION [ 'REJECTED_RECIPIENTS' ] [ ] = $ arrRecipient [ 'email' ] ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sendNewsletter' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objEmail , $ objNewsletter , $ arrRecipient , $ text , $ html ) ; } } }
10776	public function fromArray ( array $ array ) { $ root = new Node ( null ) ; $ map = array ( ) ; $ map [ 0 ] = $ root ; foreach ( $ array as $ element ) { if ( 3 !== count ( $ element ) ) { throw new Exception ( 'Each array must have 3 elements.' ) ; } $ map [ $ element [ 0 ] ] = new Node ( $ element [ 2 ] ) ; } foreach ( $ array as $ element ) { if ( empty ( $ element [ 1 ] ) ) { $ element [ 1 ] = 0 ; } $ found = false ; $ i = 0 ; $ keys = array_keys ( $ map ) ; $ cnt = count ( $ keys ) ; while ( ! $ found && $ i < $ cnt ) { if ( $ keys [ $ i ] === $ element [ 1 ] ) { $ map [ $ keys [ $ i ] ] -> addChild ( $ map [ $ element [ 0 ] ] ) ; $ found = true ; } else { $ i ++ ; } } if ( ! $ found ) { throw new Exception ( 'Data structure does not seem to be consistent. ' . 'Key "' . $ element [ 1 ] . '" could not be found.' ) ; } } return $ root ; }
10000	public function setSoftEdgesSize ( $ size ) { if ( $ size !== null ) { $ this -> activateObject ( ) ; $ softEdges [ 'size' ] = ( string ) $ this -> getExcelPointsWidth ( $ size ) ; } }
6526	public static function resolveId ( SchemaId $ id ) : string { $ curieMajor = $ id -> getCurieMajor ( ) ; if ( isset ( self :: $ curies [ $ curieMajor ] ) ) { return self :: $ classes [ self :: $ curies [ $ curieMajor ] ] ; } $ curie = $ id -> getCurie ( ) -> toString ( ) ; if ( isset ( self :: $ curies [ $ curie ] ) ) { return self :: $ classes [ self :: $ curies [ $ curie ] ] ; } throw new NoMessageForSchemaId ( $ id ) ; }
2699	private function upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) { foreach ( $ oldConfigPaths as $ key => $ value ) { $ oldValue = $ this -> scopeConfig -> getValue ( $ value ) ; if ( $ oldValue != null ) { $ this -> configWriter -> save ( $ newConfigPaths [ $ key ] , $ oldValue ) ; } } }
11886	public function addChild ( $ structureName , $ prefix = '' , $ suffix = '' ) { if ( isset ( $ this -> children [ $ structureName ] ) ) { throw new DefinitionDuplicateException ( sprintf ( 'Child structure with same name "%s" already exists' , $ structureName ) ) ; } $ this -> children [ $ structureName ] = array ( 'name' => $ structureName , 'prefix' => ( string ) $ prefix , 'suffix' => ( string ) $ suffix ) ; }
11382	public function pipe ( $ stage ) { $ pipeline = new self ( $ this -> container , $ this -> stages ) ; $ this -> handleStage ( $ pipeline -> stages , $ stage ) ; return $ pipeline ; }
10359	protected static function formatBacktrace ( array $ backtrace ) : array { if ( is_array ( $ backtrace ) === false || count ( $ backtrace ) === 0 ) { return $ backtrace ; } if ( $ backtrace [ 0 ] [ 'function' ] == '{closure}' ) { unset ( $ backtrace [ 0 ] ) ; } $ trace = [ ] ; foreach ( $ backtrace as $ entry ) { $ function = '' ; if ( isset ( $ entry [ 'class' ] ) ) { $ function .= $ entry [ 'class' ] . $ entry [ 'type' ] ; } $ function .= $ entry [ 'function' ] . '()' ; $ arguments = [ ] ; if ( isset ( $ entry [ 'args' ] ) && count ( $ entry [ 'args' ] ) > 0 ) { foreach ( $ entry [ 'args' ] as $ arg ) { ob_start ( ) ; var_dump ( $ arg ) ; $ arg = htmlspecialchars ( ob_get_contents ( ) ) ; ob_end_clean ( ) ; $ arguments [ ] = $ arg ; } } $ location = [ ] ; if ( isset ( $ entry [ 'file' ] ) ) { $ location [ 'file' ] = $ entry [ 'file' ] ; $ location [ 'line' ] = $ entry [ 'line' ] ; $ location [ 'code' ] = self :: highlightCode ( $ entry [ 'file' ] , $ entry [ 'line' ] ) ; } $ trace [ ] = array ( 'function' => $ function , 'arguments' => $ arguments , 'location' => $ location , ) ; } return $ trace ; }
1098	public function updateStructure ( ) { list ( $ a , $ b , $ c , $ d ) = $ this -> boundaries ( ) ; $ this -> applyLockBetween ( $ a , $ d ) ; $ connection = $ this -> node -> getConnection ( ) ; $ grammar = $ connection -> getQueryGrammar ( ) ; $ currentId = $ this -> quoteIdentifier ( $ this -> node -> getKey ( ) ) ; $ parentId = $ this -> quoteIdentifier ( $ this -> parentId ( ) ) ; $ leftColumn = $ this -> node -> getLeftColumnName ( ) ; $ rightColumn = $ this -> node -> getRightColumnName ( ) ; $ parentColumn = $ this -> node -> getParentColumnName ( ) ; $ wrappedLeft = $ grammar -> wrap ( $ leftColumn ) ; $ wrappedRight = $ grammar -> wrap ( $ rightColumn ) ; $ wrappedParent = $ grammar -> wrap ( $ parentColumn ) ; $ wrappedId = $ grammar -> wrap ( $ this -> node -> getKeyName ( ) ) ; $ lftSql = "CASE WHEN $wrappedLeft BETWEEN $a AND $b THEN $wrappedLeft + $d - $b WHEN $wrappedLeft BETWEEN $c AND $d THEN $wrappedLeft + $a - $c ELSE $wrappedLeft END" ; $ rgtSql = "CASE WHEN $wrappedRight BETWEEN $a AND $b THEN $wrappedRight + $d - $b WHEN $wrappedRight BETWEEN $c AND $d THEN $wrappedRight + $a - $c ELSE $wrappedRight END" ; $ parentSql = "CASE WHEN $wrappedId = $currentId THEN $parentId ELSE $wrappedParent END" ; $ updateConditions = array ( $ leftColumn => $ connection -> raw ( $ lftSql ) , $ rightColumn => $ connection -> raw ( $ rgtSql ) , $ parentColumn => $ connection -> raw ( $ parentSql ) ) ; if ( $ this -> node -> timestamps ) $ updateConditions [ $ this -> node -> getUpdatedAtColumn ( ) ] = $ this -> node -> freshTimestamp ( ) ; return $ this -> node -> newNestedSetQuery ( ) -> where ( function ( $ query ) use ( $ leftColumn , $ rightColumn , $ a , $ d ) { $ query -> whereBetween ( $ leftColumn , array ( $ a , $ d ) ) -> orWhereBetween ( $ rightColumn , array ( $ a , $ d ) ) ; } ) -> update ( $ updateConditions ) ; }
9478	protected function getCalendarDayDownloads ( $ limit = 30 ) { $ arrCalendarDayDownloads = array ( ) ; $ CalendarDays = date ( 'Y-m-d' , mktime ( 0 , 0 , 0 , date ( "m" ) , date ( "d" ) - $ limit , date ( "Y" ) ) ) ; $ objCalendarDayDownloads = \ Database :: getInstance ( ) -> prepare ( "SELECT dl.`id` , FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) as datum , count(dl.`filename`) as downloads , dl.`filename` FROM `tl_dlstats` dl INNER JOIN `tl_dlstatdets` det on dl.id = det.pid WHERE FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) >=? GROUP BY dl.`id`, datum ORDER BY datum DESC, `filename`" ) -> execute ( $ CalendarDays ) ; while ( $ objCalendarDayDownloads -> next ( ) ) { $ viewDate = $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'dateFormat' ] , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; $ c4d = $ this -> check4details ( $ objCalendarDayDownloads -> id ) ; $ arrCalendarDayDownloads [ ] = array ( $ viewDate , $ objCalendarDayDownloads -> filename , $ this -> getFormattedNumber ( $ objCalendarDayDownloads -> downloads , 0 ) , $ objCalendarDayDownloads -> id , $ c4d , $ objCalendarDayDownloads -> downloads , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; } return $ arrCalendarDayDownloads ; }
12679	public static function boot ( ConfigurationHandler $ configurationHandler ) { $ pluginDirs = $ configurationHandler -> pluginFolders ( ) ; foreach ( $ pluginDirs as $ pluginDir ) { self :: $ blocks += self :: parse ( $ pluginDir ) ; } }
8462	public static function getBaseUrl ( ) { $ uri = self :: addBackSlash ( self :: getUriMethods ( ) , 'both' ) ; $ url = self :: addBackSlash ( self :: getCurrentPage ( ) ) ; if ( $ uri !== '/' ) { $ url = trim ( str_replace ( $ uri , '' , $ url ) , '/' ) ; } return self :: addBackSlash ( $ url ) ; }
3405	public function timeout ( int $ timeout ) : bool { $ application = $ this -> getApplication ( ) ; if ( ! $ application instanceof Application ) { return false ; } if ( ! $ application -> timeLimit ( ) ) { return false ; } $ endTime = $ this -> startTime + $ timeout ; return ( time ( ) > $ endTime ) ; }
11784	public function update ( $ pageId , $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'page_id' => intval ( $ pageId ) , 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
3403	protected function loadFromYml ( $ file ) { $ this -> parser = new Parser ( $ file ) ; $ this -> parser -> load ( $ this ) ; }
12555	public function showAction ( Tag $ tag ) { $ deleteForm = $ this -> createDeleteForm ( $ tag ) ; return array ( 'entity' => $ tag , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
989	public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } $ charge = Charge :: firstOrNew ( [ 'charge_id' => $ this -> chargeId , 'shop_id' => $ this -> shop -> id , ] ) ; $ charge -> plan_id = $ this -> plan -> id ; $ charge -> type = $ this -> plan -> type ; $ charge -> status = $ this -> response -> status ; if ( $ this -> plan -> isType ( Plan :: PLAN_RECURRING ) ) { $ charge -> billing_on = $ this -> response -> billing_on ; $ charge -> trial_ends_on = $ this -> response -> trial_ends_on ; } $ charge -> activated_on = $ this -> response -> activated_on ?? Carbon :: today ( ) -> format ( 'Y-m-d' ) ; $ planDetails = $ this -> chargeParams ( ) ; unset ( $ planDetails [ 'return_url' ] ) ; foreach ( $ planDetails as $ key => $ value ) { $ charge -> { $ key } = $ value ; } return $ charge -> save ( ) ; }
7674	function TbsStoreLoad ( $ idx , $ file = false ) { $ this -> TBS -> Source = $ this -> TbsStoreGet ( $ idx , false ) ; $ this -> TbsCurrIdx = $ idx ; if ( $ file === false ) $ file = $ this -> TbsGetFileName ( $ idx ) ; $ this -> TBS -> OtbsCurrFile = $ file ; }
360	function normalizeRequirement ( $ requirement , $ requirementKey = 0 ) { if ( ! is_array ( $ requirement ) ) { $ this -> usageError ( 'Requirement must be an array!' ) ; } if ( ! array_key_exists ( 'condition' , $ requirement ) ) { $ this -> usageError ( "Requirement '{$requirementKey}' has no condition!" ) ; } else { $ evalPrefix = 'eval:' ; if ( is_string ( $ requirement [ 'condition' ] ) && strpos ( $ requirement [ 'condition' ] , $ evalPrefix ) === 0 ) { $ expression = substr ( $ requirement [ 'condition' ] , strlen ( $ evalPrefix ) ) ; $ requirement [ 'condition' ] = $ this -> evaluateExpression ( $ expression ) ; } } if ( ! array_key_exists ( 'name' , $ requirement ) ) { $ requirement [ 'name' ] = is_numeric ( $ requirementKey ) ? 'Requirement #' . $ requirementKey : $ requirementKey ; } if ( ! array_key_exists ( 'mandatory' , $ requirement ) ) { if ( array_key_exists ( 'required' , $ requirement ) ) { $ requirement [ 'mandatory' ] = $ requirement [ 'required' ] ; } else { $ requirement [ 'mandatory' ] = false ; } } if ( ! array_key_exists ( 'by' , $ requirement ) ) { $ requirement [ 'by' ] = 'Unknown' ; } if ( ! array_key_exists ( 'memo' , $ requirement ) ) { $ requirement [ 'memo' ] = '' ; } return $ requirement ; }
9529	private function validateRequiredParameters ( ) { $ ret = true ; foreach ( $ this -> parameterCluster -> prefixes as $ prefix => $ parameters ) { foreach ( $ parameters as $ parameterClosure ) { if ( $ parameterClosure -> required ) { if ( ! in_array ( $ parameterClosure -> prefix . $ parameterClosure -> parameterName , $ this -> argv ) ) { $ aliasFound = false ; foreach ( $ parameterClosure -> aliases as $ prefix => $ alias ) { if ( in_array ( $ prefix . $ alias , $ this -> argv ) ) { $ aliasFound = true ; break ; } } if ( ! $ aliasFound ) { $ ret = $ parameterClosure ; break 2 ; } } } } } return $ ret ; }
6554	public function removeLineFromFile ( $ line , $ fh ) { $ lines = array ( ) ; $ found = false ; rewind ( $ fh ) ; while ( ( $ buffer = fgets ( $ fh , 4096 ) ) !== false ) { $ buffer = trim ( $ buffer ) ; if ( $ line === $ buffer ) { $ found = true ; continue ; } $ lines [ ] = $ buffer ; } if ( ! $ found ) { throw new LineNotFoundException ( sprintf ( 'Line %s can not be found' , $ line ) ) ; } ftruncate ( $ fh , 0 ) ; rewind ( $ fh ) ; foreach ( $ lines as $ ln ) { if ( fwrite ( $ fh , $ ln . PHP_EOL ) === false ) { throw new \ Exception ( sprintf ( 'Can\'t write %s to file' , $ ln ) ) ; } } }
12702	public function get ( $ id ) { if ( isset ( $ this -> singletons [ $ id ] ) ) { return $ this -> singletons [ $ id ] ; } $ methodName = 'get' . Util :: mapIdToCamelCase ( $ id ) ; if ( method_exists ( $ this , $ methodName ) ) { return $ this -> $ methodName ( ) ; } throw new \ InvalidArgumentException ( "Unknown service '$id' in container '" . get_called_class ( ) . "'" ) ; }
10249	public function getDate ( $ params = [ ] , $ format = 'Y-m-d' ) { foreach ( $ params as $ k => $ v ) { $ $ k = $ v ; } if ( ! isset ( $ min_year ) ) { $ min_year = date ( 'Y' ) - 2 ; } if ( ! isset ( $ max_year ) ) { $ max_year = date ( 'Y' ) ; } if ( ! isset ( $ min_month ) ) { $ min_month = 1 ; } if ( ! isset ( $ max_month ) ) { $ max_month = 12 ; } $ rand_year = rand ( $ min_year , $ max_year ) ; $ rand_month = rand ( $ min_month , $ max_month ) ; $ date = DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , '01' ] ) ) ; $ days_in_month = $ date -> format ( 't' ) ; $ rand_day = rand ( 1 , $ days_in_month ) ; return DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , $ rand_day ] ) ) -> format ( $ format ) ; }
12496	public static function delete ( $ id = null , $ connection ) { if ( gettype ( $ id ) != "string" && ! is_numeric ( $ id ) ) { throw new ClusterpointException ( "\"->delete()\" function: \"_id\" is not in valid format." , 9002 ) ; } $ connection -> method = 'DELETE' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; return self :: sendQuery ( $ connection ) ; }
10891	public function syntax ( $ error = "Please specify valid options" ) { $ ostr = ( ! $ error ) ? STDOUT : STDERR ; if ( is_string ( $ error ) ) fprintf ( $ ostr , "Error: %s\n" , $ error ) ; fprintf ( $ ostr , "Syntax: php " . $ _SERVER [ 'argv' ] [ 0 ] . " <options> <action>\n\n" ) ; fprintf ( $ ostr , "Options: \n" ) ; $ max_opt_length = 0 ; $ max_arg_length = 0 ; $ params = $ this -> parameters ; usort ( $ params , function ( $ a , $ b ) { $ lo = ! empty ( $ a [ 0 ] ) ? $ a [ 0 ] : $ a [ 1 ] ; $ ro = ! empty ( $ b [ 0 ] ) ? $ b [ 0 ] : $ b [ 1 ] ; return strcmp ( $ lo , $ ro ) ; } ) ; foreach ( $ params as $ param ) { $ max_opt_length = max ( strlen ( $ param [ 1 ] ) + 3 , $ max_opt_length ) ; $ max_arg_length = max ( strlen ( $ param [ 2 ] ) + 3 , $ max_arg_length ) ; } foreach ( $ this -> parameters as $ param ) { fprintf ( $ ostr , " " ) ; $ so = $ param [ 0 ] ? "-" . $ param [ 0 ] : "" ; $ lo = $ param [ 1 ] ? "--" . $ param [ 1 ] : "" ; $ arg = $ param [ 2 ] ? '<' . $ param [ 2 ] . '>' : "" ; $ pstr = sprintf ( "%-2s %-" . $ max_opt_length . "s %-" . $ max_arg_length . "s " , $ so , $ lo , $ arg ) ; $ indent = strlen ( $ pstr ) + 4 ; fprintf ( $ ostr , $ pstr ) ; self :: formatText ( $ indent , self :: MAX_LINE_LENGTH , $ param [ 3 ] , $ ostr ) ; } exit ( $ error === false ? 0 : 1 ) ; }
679	protected function validateCondition ( $ condition ) { if ( ! is_array ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidFilter' ) ) ; return ; } if ( empty ( $ condition ) ) { return ; } foreach ( $ condition as $ key => $ value ) { $ method = 'validateAttributeCondition' ; if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ controlKey = $ this -> filterControls [ $ key ] ; if ( isset ( $ this -> conditionValidators [ $ controlKey ] ) ) { $ method = $ this -> conditionValidators [ $ controlKey ] ; } } $ this -> $ method ( $ key , $ value ) ; } }
7101	static public function getClasses ( $ type ) { switch ( $ type ) { case static :: TYPE_FORM : return [ CartInterface :: class ] ; case static :: TYPE_QUOTE : return [ QuoteInterface :: class ] ; case static :: TYPE_PROFORMA : return [ QuoteInterface :: class , OrderInterface :: class ] ; case static :: TYPE_CONFIRMATION : return [ OrderInterface :: class ] ; case static :: TYPE_VOUCHER : return [ ] ; default : throw new InvalidArgumentException ( "Unexpected type '$type'." ) ; } }
8377	public static function init ( ) { if ( self :: $ isInit === false ) { if ( session_id ( ) == null ) { $ settings = Config :: getSettings ( ) ; session_name ( isset ( $ settings [ 'session_name' ] ) === true ? $ settings [ 'session_name' ] : 'stray_session' ) ; if ( isset ( $ settings [ 'session_cookie_domain' ] ) === true ) { session_set_cookie_params ( 0 , '/' , $ settings [ 'session_cookie_domain' ] ) ; } session_start ( ) ; } self :: $ isInit = true ; } }
10591	protected function findProduct ( int $ id ) : ProductInterface { $ product = $ this -> repository -> find ( $ id ) ; if ( ! $ product instanceof ProductInterface ) { throw new ProductNotFoundException ( $ id ) ; } return $ product ; }
12017	public function calculateRequestFilename ( Request $ request ) { $ string = $ request -> getUri ( ) ; $ filename = parse_url ( $ string , PHP_URL_HOST ) ; $ filename .= '_' . parse_url ( $ string , PHP_URL_PATH ) ; $ headers = $ request -> getAllHeaders ( ) ; ksort ( $ headers ) ; foreach ( $ headers as $ header => $ values ) { $ string .= $ header ; foreach ( $ values as $ value ) { $ string .= $ value ; } } $ filename .= '_' . sha1 ( $ string ) ; if ( strpos ( $ filename , '_' ) === 0 ) { $ filename = substr ( $ filename , 1 ) ; } return $ this -> cacheDirectory . '/' . $ filename . '.cache' ; }
4305	public function table ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ event = $ this -> methodTable -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => $ args , 'meta' => $ meta , ) ) ) ; $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; }
8638	public function setOrderFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1315	public function get ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'GET' , self :: API_HOST , $ path , $ parameters , false ) ; }
12614	public function have_required_properties ( ) { return ( ! empty ( $ this -> handle ) && ! empty ( $ this -> relative_path ) && ! empty ( $ this -> filename ) ) ; }
6038	protected function initTransport ( $ options , $ transport = "TCP" ) { if ( ! is_array ( $ options ) ) { throw new Ts3Exception ( "transport parameters must provided in an array" ) ; } if ( $ transport == "TCP" ) $ this -> transport = new TCP ( $ options ) ; else $ this -> transport = new UDP ( $ options ) ; }
10247	public function getString ( $ type = 'letter' , $ desired_length = null ) { if ( empty ( $ desired_length ) ) { $ desired_length = $ this -> getInteger ( 1 , 50 ) ; } $ result = '' ; while ( strlen ( $ result ) < $ desired_length ) { if ( $ type == 'letter' ) { $ result .= $ this -> getLetter ( ) ; } elseif ( $ type == 'number' ) { $ result .= $ this -> getInteger ( 1 , 10 ) ; } else { $ result .= $ this -> getUniqueHash ( ) ; } } return substr ( $ result , 0 , $ desired_length ) ; }
7839	public function info ( int $ id ) : ? array { $ response = Request :: get ( $ this -> baseUrl . 'contact/' . $ id ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
9603	public function crossProduct ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; if ( $ this -> dimension ( ) !== 3 ) { throw new Exception ( 'Both vectors must be 3-dimensional' ) ; } $ tc = $ this -> components ( ) ; $ bc = $ b -> components ( ) ; list ( $ k0 , $ k1 , $ k2 ) = array_keys ( $ tc ) ; $ product = [ $ k0 => $ tc [ $ k1 ] * $ bc [ $ k2 ] - $ tc [ $ k2 ] * $ bc [ $ k1 ] , $ k1 => $ tc [ $ k2 ] * $ bc [ $ k0 ] - $ tc [ $ k0 ] * $ bc [ $ k2 ] , $ k2 => $ tc [ $ k0 ] * $ bc [ $ k1 ] - $ tc [ $ k1 ] * $ bc [ $ k0 ] , ] ; return new static ( $ product ) ; }
3852	public function setSorting ( $ strSortBy , $ strDirection = 'ASC' ) { $ this -> strSortBy = $ strSortBy ; $ this -> strSortDirection = ( $ strDirection == 'DESC' ) ? 'DESC' : 'ASC' ; return $ this ; }
8508	public function getPrepInstructionsForASIN ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForASINRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForASINRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForASIN' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForASINResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3272	public function setConfig ( Config $ config ) { $ this -> config = $ config ; $ this -> getDatabase ( ) -> setConfig ( $ config ) ; }
4358	protected function processSubstitutions ( $ args , & $ hasSubs ) { $ subRegex = '/%' . '(?:' . '[coO]|' . '[+-]?' . '(?:[ 0]|\'.{1})?' . '-?' . '\d*' . '(?:\.\d+)?' . '[difs]' . ')' . '/' ; if ( ! \ is_string ( $ args [ 0 ] ) ) { return $ args ; } $ index = 0 ; $ indexes = array ( 'c' => array ( ) , ) ; $ hasSubs = false ; $ args [ 0 ] = \ preg_replace_callback ( $ subRegex , function ( $ matches ) use ( & $ args , & $ hasSubs , & $ index , & $ indexes ) { $ hasSubs = true ; $ index ++ ; $ replacement = $ matches [ 0 ] ; $ type = \ substr ( $ matches [ 0 ] , - 1 ) ; if ( \ strpos ( 'difs' , $ type ) !== false ) { $ format = $ matches [ 0 ] ; $ sub = $ args [ $ index ] ; if ( $ type == 'i' ) { $ format = \ substr_replace ( $ format , 'd' , - 1 , 1 ) ; } elseif ( $ type === 's' ) { $ sub = $ this -> substitutionAsString ( $ sub ) ; } $ replacement = \ sprintf ( $ format , $ sub ) ; } elseif ( $ type === 'c' ) { $ asHtml = \ get_called_class ( ) == __NAMESPACE__ . '\\Html' ; if ( ! $ asHtml ) { return '' ; } $ replacement = '' ; if ( $ indexes [ 'c' ] ) { $ replacement = '</span>' ; } $ replacement .= '<span' . $ this -> debug -> utilities -> buildAttribString ( array ( 'style' => $ args [ $ index ] , ) ) . '>' ; $ indexes [ 'c' ] [ ] = $ index ; } elseif ( \ strpos ( 'oO' , $ type ) !== false ) { $ replacement = $ this -> dump ( $ args [ $ index ] ) ; } return $ replacement ; } , $ args [ 0 ] ) ; if ( $ indexes [ 'c' ] ) { $ args [ 0 ] .= '</span>' ; } if ( $ hasSubs ) { $ args = array ( $ args [ 0 ] ) ; } return $ args ; }
8341	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ prettyPageHandler = new PrettyPageHandler ( ) ; self :: $ prettyPageHandler -> setPageTitle ( 'I just broke a string... - strayFw' ) ; $ whoops = new Run ( ) ; $ whoops -> pushHandler ( new JsonResponseHandler ( ) ) ; $ whoops -> pushHandler ( self :: $ prettyPageHandler ) ; $ whoops -> register ( ) ; self :: $ isInit = true ; } }
4144	public function get ( $ call , array $ getParams = null ) { $ this -> resetCallState ( ) ; $ this -> call = $ call ; $ this -> method = 'GET' ; if ( $ getParams !== null && is_array ( $ getParams ) ) { $ this -> getParams = $ getParams ; } $ response = $ this -> getResponse ( ) ; $ response [ 'body' ] = $ this -> findExceptions ( $ response ) ; $ this -> headers = $ response [ 'headers' ] ; unset ( $ call , $ getParams ) ; return $ this -> serializer -> format ( $ response [ 'body' ] ) ; }
10663	public function setParamType ( $ type ) { if ( ! is_string ( $ type ) || ! in_array ( $ type , [ self :: PARAM_MULTIPART , self :: PARAM_FORM ] ) ) { throw new InvalidArgumentException ( sprintf ( "Invalid parameter form type, form type only allowed $1s and $2s" , self :: PARAM_FORM , self :: PARAM_MULTIPART ) , E_USER_ERROR ) ; } $ this -> currentParamType = $ type ; $ reverse_params = $ type == self :: PARAM_FORM ? self :: PARAM_MULTIPART : self :: PARAM_FORM ; $ reverse_params_value = isset ( $ this -> configs [ $ reverse_params ] ) ? $ this -> configs [ $ reverse_params ] : null ; $ params_value = isset ( $ this -> configs [ $ type ] ) ? $ this -> configs [ $ type ] : null ; unset ( $ this -> configs [ self :: PARAM_FORM ] , $ this -> configs [ self :: PARAM_MULTIPART ] ) ; $ this -> configs [ $ type ] = is_array ( $ reverse_params_value ) ? $ reverse_params_value : ( is_array ( $ params_value ) ? $ params_value : [ ] ) ; return $ this -> buildConfigClient ( ) ; }
11488	public function setName ( string $ name ) : void { if ( ! empty ( $ name ) ) { if ( ! is_numeric ( $ name ) ) { @ session_name ( $ name ) ; } else { throw new Exception ( 'The session name can\'t consist only of digits, ' . 'at least one letter must be presented.' ) ; } } else { throw new Exception ( 'Empty session name value was passed.' ) ; } }
10940	public function getResponse ( $ params = [ ] , $ lifetime = - 1 , Response $ response = null ) { if ( ! $ response ) { $ response = new Response ( ) ; } if ( ! $ this -> enable ) { return $ response ; } return $ this -> configurator -> configure ( $ response , $ this -> getMax ( $ params ) , $ lifetime ) ; }
3477	public function withLocalizedTitle ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> title = '' ; $ cloned -> titleLocalized = $ localized ; return $ cloned ; }
3989	public function getScreen ( $ tableName ) { $ inputScreens = $ this -> getInputScreens ( ) ; if ( isset ( $ inputScreens [ $ tableName ] ) ) { return $ inputScreens [ $ tableName ] ; } return null ; }
1563	protected function isDateAttribute ( $ field , $ record ) { if ( empty ( $ this -> dates ) ) { return in_array ( $ this -> modelKeyForField ( $ field , $ record ) , $ record -> getDates ( ) , true ) ; } return in_array ( $ field , $ this -> dates , true ) ; }
10603	public function checkQuery ( $ name ) { $ parts = explode ( '&' , $ this -> _urlParts [ 'query' ] ) ; foreach ( $ parts as $ p ) { $ paramData = explode ( '=' , $ p ) ; if ( $ paramData [ 0 ] === $ name ) { return true ; } } return false ; }
8414	public function getMasterLink ( ) { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return $ this -> servers [ 'all' ] [ 'link' ] ; } return $ this -> servers [ 'write' ] [ 'link' ] ; }
4765	protected function validateRegistrationOptin ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_userregistration' ) ; $ registrationOption = ( int ) $ this -> getRequestParameter ( 'option' ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinUserRegistration' ) && ( 3 == $ registrationOption ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
11106	public function having ( $ column , $ op , $ value , $ isParam = true ) { $ this -> having -> andHaving ( $ column , $ op , $ value , $ isParam ) ; return $ this ; }
10564	public function variant ( array $ attrs ) { return new self ( $ this -> id , $ attrs , null , $ this -> info -> all ( ) ) ; }
817	private function fixFunction ( Tokens $ tokens , $ startFunctionIndex ) { $ endFunctionIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ startFunctionIndex ) ; $ isMultiline = false ; $ firstWhitespaceIndex = $ this -> findWhitespaceIndexAfterParenthesis ( $ tokens , $ startFunctionIndex , $ endFunctionIndex ) ; $ lastWhitespaceIndex = $ this -> findWhitespaceIndexAfterParenthesis ( $ tokens , $ endFunctionIndex , $ startFunctionIndex ) ; foreach ( [ $ firstWhitespaceIndex , $ lastWhitespaceIndex ] as $ index ) { if ( null === $ index || ! Preg :: match ( '/\R/' , $ tokens [ $ index ] -> getContent ( ) ) ) { continue ; } if ( 'ensure_single_line' !== $ this -> configuration [ 'on_multiline' ] ) { $ isMultiline = true ; continue ; } $ newLinesRemoved = $ this -> ensureSingleLine ( $ tokens , $ index ) ; if ( ! $ newLinesRemoved ) { $ isMultiline = true ; } } for ( $ index = $ endFunctionIndex - 1 ; $ index > $ startFunctionIndex ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> equals ( ')' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; continue ; } if ( $ token -> isGivenKind ( CT :: T_ARRAY_SQUARE_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( '}' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( ',' ) ) { $ this -> fixSpace2 ( $ tokens , $ index ) ; if ( ! $ isMultiline && $ this -> isNewline ( $ tokens [ $ index + 1 ] ) ) { $ isMultiline = true ; break ; } } } return $ isMultiline ; }
10241	public function calculateFormula ( $ formula , $ cellID = null , Cell $ pCell = null ) { $ this -> formulaError = null ; $ this -> debugLog -> clearLog ( ) ; $ this -> cyclicReferenceStack -> clear ( ) ; if ( $ this -> spreadsheet !== null && $ cellID === null && $ pCell === null ) { $ cellID = 'A1' ; $ pCell = $ this -> spreadsheet -> getActiveSheet ( ) -> getCell ( $ cellID ) ; } else { $ resetCache = $ this -> getCalculationCacheEnabled ( ) ; $ this -> calculationCacheEnabled = false ; } try { $ result = self :: unwrapResult ( $ this -> _calculateFormulaValue ( $ formula , $ cellID , $ pCell ) ) ; } catch ( \ Exception $ e ) { throw new Exception ( $ e -> getMessage ( ) ) ; } if ( $ this -> spreadsheet === null ) { $ this -> calculationCacheEnabled = $ resetCache ; } return $ result ; }
1229	private function expr ( $ rbp = 0 ) { $ left = $ this -> { "nud_{$this->token['type']}" } ( ) ; while ( $ rbp < self :: $ bp [ $ this -> token [ 'type' ] ] ) { $ left = $ this -> { "led_{$this->token['type']}" } ( $ left ) ; } return $ left ; }
10496	public function exp ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( pow ( $ this -> value , $ value ) ) ; }
8206	protected function buryJob ( $ job , $ priority = null ) { if ( is_null ( $ priority ) ) { $ priority = Pheanstalk :: DEFAULT_PRIORITY ; } $ this -> getPheanstalk ( ) -> bury ( $ job , $ priority ) ; }
1183	protected function getSessionToken ( ) { $ token = null ; if ( $ session = $ this -> app -> __get ( 'session' ) ) { $ token = $ session -> token ( ) ; } if ( $ encrypter = $ this -> app -> __get ( 'encrypter' ) ) { $ token = $ encrypter -> encrypt ( $ token ) ; } return $ token ; }
8651	private function convertGetReport ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReport' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportId ( ) ) { $ parameters [ 'ReportId' ] = $ request -> getReportId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
10043	public function offsetSet ( $ key , $ value ) { if ( ! ( $ value instanceof PieceInterface ) ) { $ value = new Piece ( $ value ) ; } parent :: offsetSet ( $ key , $ value ) ; }
8691	public static function symlinkJQueryFileUpload ( Event $ event ) { $ IO = $ event -> getIO ( ) ; $ composer = $ event -> getComposer ( ) ; $ cmanager = new ComposerPathFinder ( $ composer ) ; $ ds = DIRECTORY_SEPARATOR ; $ options = [ 'targetSuffix' => self :: getTargetSuffix ( 'jquery-file-upload' ) , 'sourcePrefix' => "..{$ds}..{$ds}..{$ds}" , ] ; list ( $ symlinkTarget , $ symlinkName ) = $ cmanager -> getSymlinkFromComposer ( 'sidus/file-upload-bundle' , 'blueimp/jquery-file-upload' , $ options ) ; $ IO -> write ( 'Checking Symlink' , false ) ; if ( false === self :: checkSymlink ( $ symlinkTarget , $ symlinkName , true ) ) { $ IO -> write ( 'Creating Symlink: ' . $ symlinkName , false ) ; self :: createSymlink ( $ symlinkTarget , $ symlinkName ) ; } $ IO -> write ( '<info>OK</info>' ) ; }
12175	public function addOptionalScalarArgument ( $ name , $ type , $ default ) { return $ this -> addArgument ( new ScalarArgument ( $ this -> argumentPosition ++ , $ name , $ type , false , $ default ) ) ; }
10245	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; if ( isset ( $ xmlElement -> last_type ) ) $ this -> lastType = $ xmlElement -> last_type ; if ( isset ( $ xmlElement -> count ) ) $ this -> count = $ xmlElement -> count ; if ( isset ( $ xmlElement -> count_hard ) ) $ this -> countHard = $ xmlElement -> count_hard ; if ( isset ( $ xmlElement -> count_soft ) ) $ this -> countSoft = $ xmlElement -> count_soft ; }
9568	protected function invokeConfigurator ( $ configurator ) { if ( is_callable ( $ configurator ) ) { call_user_func ( $ configurator , $ this ) ; return ; } if ( is_string ( $ configurator ) ) { $ configurator = $ this -> container -> resolve ( $ configurator ) ; } if ( $ configurator instanceof ConfiguratorInterface ) { $ configurator -> configure ( ) ; } else { throw new \ UnexpectedValueException ( 'Invalid configurator' ) ; } }
509	public function actionIndex ( $ command = null ) { if ( $ command !== null ) { $ result = Yii :: $ app -> createController ( $ command ) ; if ( $ result === false ) { $ name = $ this -> ansiFormat ( $ command , Console :: FG_YELLOW ) ; throw new Exception ( "No help for unknown command \"$name\"." ) ; } list ( $ controller , $ actionID ) = $ result ; $ actions = $ this -> getActions ( $ controller ) ; if ( $ actionID !== '' || count ( $ actions ) === 1 && $ actions [ 0 ] === $ controller -> defaultAction ) { $ this -> getSubCommandHelp ( $ controller , $ actionID ) ; } else { $ this -> getCommandHelp ( $ controller ) ; } } else { $ this -> getDefaultHelp ( ) ; } }
6042	public function session ( $ sourceId , $ sessionHash , $ remoteIp , $ userAgent , $ userId = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sourceId' => $ sourceId , 'sessionHash' => $ sessionHash , 'remoteIp' => $ remoteIp , 'userAgent' => $ userAgent , 'userId' => $ userId ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/session' , $ parameters ) ; return $ result ; }
12878	public function setValue ( $ value ) { $ this -> value = $ value ; if ( is_array ( $ value ) && array_key_exists ( 'start' , $ value ) && array_key_exists ( 'end' , $ value ) ) { $ start = ( float ) $ value [ 'start' ] ; $ end = ( float ) $ value [ 'end' ] ; if ( $ start <= $ end ) { $ this -> startElement -> setValue ( $ start ) ; $ this -> endElement -> setValue ( $ end ) ; } } return $ this ; }
1275	private function sendRequest ( $ request , $ endpoint , $ operation , $ wsdl ) { $ endpointurl = $ this -> compileEndpointUrl ( $ endpoint ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ endpointurl , $ operation , $ wsdl ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } return $ this -> formatResponse ( $ response ) ; }
11636	public function getDeviceByPageId ( $ pageId , $ begin , $ count ) { $ params = [ 'type' => 2 , 'page_id' => intval ( $ pageId ) , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RELATION_SEARCH , $ params ] ) ; }
4254	public function build ( $ stats ) { $ this -> stats = $ stats ; return '' . $ this -> buildFatal ( ) . $ this -> buildInConsole ( ) . $ this -> buildNotInConsole ( ) ; }
231	public function insert ( $ table , $ columns ) { $ command = $ this -> db -> createCommand ( ) -> insert ( $ table , $ columns ) ; if ( ! $ command -> execute ( ) ) { return false ; } $ tableSchema = $ this -> getTableSchema ( $ table ) ; $ result = [ ] ; foreach ( $ tableSchema -> primaryKey as $ name ) { if ( $ tableSchema -> columns [ $ name ] -> autoIncrement ) { $ result [ $ name ] = $ this -> getLastInsertID ( $ tableSchema -> sequenceName ) ; break ; } $ result [ $ name ] = isset ( $ columns [ $ name ] ) ? $ columns [ $ name ] : $ tableSchema -> columns [ $ name ] -> defaultValue ; } return $ result ; }
10766	private function implodeContent ( ) { ksort ( $ this -> content ) ; $ output = '' ; foreach ( $ this -> content as $ key => $ value ) { $ output .= $ key . self :: KV_DELIMITER . $ value . self :: DELIMITER ; } return rtrim ( $ output , self :: DELIMITER ) ; }
3068	protected function initServiceContext ( ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> getRunnerService ( ) -> check ( $ serviceContext ) ; return $ serviceContext -> init ( ) ; }
3125	protected function cloneTimePoint ( TimePoint $ point , $ type , $ timestamp = null ) { if ( is_null ( $ timestamp ) ) { $ timestamp = $ point -> getTimestamp ( ) ; } \ common_Logger :: d ( "Create missing TimePoint at " . $ timestamp ) ; return new TimePoint ( $ point -> getTags ( ) , $ timestamp , $ type , $ point -> getTarget ( ) ) ; }
6108	public function clientPermRemove ( $ cldbid , $ permid ) { return $ this -> getParent ( ) -> channelClientPermRemove ( $ this -> getId ( ) , $ cldbid , $ permid ) ; }
517	public function actionFresh ( ) { if ( YII_ENV_PROD ) { $ this -> stdout ( "YII_ENV is set to 'prod'.\nRefreshing migrations is not possible on production systems.\n" ) ; return ExitCode :: OK ; } if ( $ this -> confirm ( "Are you sure you want to reset the database and start the migration from the beginning?\nAll data will be lost irreversibly!" ) ) { $ this -> truncateDatabase ( ) ; $ this -> actionUp ( ) ; } else { $ this -> stdout ( 'Action was cancelled by user. Nothing has been performed.' ) ; } }
7810	public function getPackageVersion ( ) { $ package_config = file_get_contents ( dirname ( __FILE__ ) . "./../composer.json" ) ; if ( $ package_config ) { $ package_config_object = json_decode ( $ package_config ) ; if ( is_object ( $ package_config_object ) && isset ( $ package_config_object -> version ) ) { return $ package_config_object -> version ; } } return null ; }
10535	protected function _getData ( $ key ) { $ store = $ this -> _getDataStore ( ) ; try { $ result = $ this -> _containerGet ( $ store , $ key ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ key ) ; } return $ result ; }
3201	public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ result = $ this -> getListResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; array_map ( function ( $ item ) { return array_merge ( $ item , [ 'categories' => $ this -> getCategoryService ( ) -> getItemCategories ( $ this -> getResource ( $ item [ 'uri' ] ) ) ] ) ; } , $ result [ 'nodes' ] ) ; return $ result ; }
5680	public function getText ( ) { if ( ! $ this -> text ) { $ this -> text = self :: normalise ( $ this -> raw ) ; } return $ this -> text ; }
10791	public function register ( SilexApp $ app ) { $ app [ 'twig' ] = $ app -> share ( $ app -> extend ( 'twig' , function ( \ Twig_Environment $ twig , SilexApp $ app ) { $ class = $ this -> getServiceConfig ( ) -> getProviderClass ( ) ; $ twig -> addExtension ( new $ class ) ; return $ twig ; } ) ) ; }
3075	public function process ( ) { $ this -> validate ( ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> pause ( $ serviceContext ) ; $ response = [ 'success' => $ result ] ; } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
4996	public function getColumnMap ( ) { $ map = $ this -> getOption ( 'column_map' ) ; if ( null === $ map ) { $ map = [ ] ; foreach ( $ this as $ element ) { $ col = $ element -> getOption ( 'span' ) ; if ( null !== $ col ) { $ map [ $ element -> getName ( ) ] = $ col ; } } $ this -> setOption ( 'column_map' , $ map ) ; } return $ map ; }
8396	public static function ensureTable ( array $ mapping ) : bool { $ database = Database :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ statement = 'CREATE TABLE IF NOT EXISTS _stray_migration (' ; $ statement .= 'date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL, ' ; $ statement .= 'migration VARCHAR(255)' ; $ statement .= ')' ; $ statement = $ database -> getMasterLink ( ) -> prepare ( $ statement ) ; if ( $ statement -> execute ( ) === false ) { echo 'Can\'t create _stray_migration (' . $ statement -> errorInfo ( ) [ 2 ] . ')' . PHP_EOL ; return false ; } $ select = new Select ( $ mapping [ 'config' ] [ 'database' ] , true ) ; $ select -> select ( 'COUNT(*) as count' ) -> from ( '_stray_migration' ) ; if ( $ select -> execute ( ) === false ) { echo 'Can\'t fetch from _stray_migration (' . $ select -> getErrorMessage ( ) . ')' . PHP_EOL ; return false ; } if ( $ select -> fetch ( ) [ 'count' ] == 0 ) { $ insert = new Insert ( $ mapping [ 'config' ] [ 'database' ] ) ; $ insert -> into ( '_stray_migration' ) ; if ( $ insert -> execute ( ) === false ) { echo 'Can\'t insert into _stray_migration (' . $ insert -> getErrorMessage ( ) . ')' . PHP_EOL ; return false ; } } return true ; }
3397	public function urlDecodeUnreservedChars ( $ string ) { $ string = rawurldecode ( $ string ) ; $ string = rawurlencode ( $ string ) ; $ string = str_replace ( array ( '%2F' , '%3A' , '%40' ) , array ( '/' , ':' , '@' ) , $ string ) ; return $ string ; }
10768	public static function accountToIBAN ( $ account , $ country = 'CZ' ) { $ allowedCountries = [ 'AT' , 'BE' , 'BG' , 'CZ' , 'CY' , 'DK' , 'EE' , 'FI' , 'FR' , 'DE' , 'GI' , 'GR' , 'HU' , 'IE' , 'IS' , 'IT' , 'LI' , 'LT' , 'LU' , 'LV' , 'MC' , 'MT' , 'NL' , 'NO' , 'PL' , 'PT' , 'RO' , 'SE' , 'CH' , 'SI' , 'SK' , 'ES' , 'GB' ] ; $ account = self :: normalizeAccountNumber ( $ account ) ; $ accountArray = explode ( '/' , str_replace ( '-' , '' , $ account ) ) ; if ( 2 !== \ count ( $ accountArray ) ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Wrong bank account (some part missing).' ) ) ; } $ country = strtoupper ( $ country ) ; if ( ! \ in_array ( $ country , $ allowedCountries , true ) ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid country code.' ) ) ; } $ accountStr = str_pad ( $ accountArray [ 1 ] , 4 , '0' , STR_PAD_LEFT ) . str_pad ( $ accountArray [ 0 ] , 16 , '0' , STR_PAD_LEFT ) . ( \ ord ( $ country [ 0 ] ) - 55 ) . ( \ ord ( $ country [ 1 ] ) - 55 ) . '00' ; $ crc = '' ; $ pos = 0 ; while ( \ strlen ( $ accountStr ) > 0 ) { $ len = 9 - \ strlen ( $ crc ) ; $ crc = ( int ) ( $ crc . substr ( $ accountStr , $ pos , $ len ) ) % 97 ; $ accountStr = substr ( $ accountStr , $ len ) ; } return ( $ country . str_pad ( 98 - $ crc , 2 , '0' , STR_PAD_LEFT ) . $ accountArray [ 1 ] . $ accountArray [ 0 ] ) ; }
10629	public static function hdd ( ) { $ hdd = new \ StdClass ( ) ; $ hdd -> total = @ disk_total_space ( "." ) ; $ hdd -> free = @ disk_free_space ( "." ) ; return $ hdd ; }
1272	public function isValid ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { return $ this -> response -> AddressClassification -> Code > 0 ; } return isset ( $ this -> response -> ValidAddressIndicator ) ; }
10990	public function hasExtension ( string $ extension ) : bool { $ test = $ this -> getExtension ( ) ; return ( strcasecmp ( $ extension , $ test ) === 0 ) ; }
4647	public function copy ( $ originFile , $ targetFile , $ override = false ) { parent :: copy ( $ originFile , $ targetFile , $ override ) ; $ this -> chmod ( $ targetFile , fileperms ( $ originFile ) ) ; }
5992	public function setSortFields ( array $ sortFields ) { $ this -> sortFields = [ ] ; foreach ( $ sortFields as $ item ) { $ this -> addSearchSort ( $ item ) ; } return $ this ; }
12307	public function getDatePeriod ( ) { $ intervaloDiario = DateInterval :: createFromDateString ( '1 day' ) ; $ dataFim = clone $ this -> endDate ; $ dataFim -> add ( $ intervaloDiario ) ; return new DatePeriod ( $ this -> startDate , $ intervaloDiario , $ dataFim ) ; }
9854	protected function append ( $ data ) { if ( strlen ( $ data ) - 4 > $ this -> limit ) { $ data = $ this -> addContinue ( $ data ) ; } $ this -> _data .= $ data ; $ this -> _datasize += strlen ( $ data ) ; }
12176	public function addClassArgument ( $ name , $ class , $ required = true ) { return $ this -> addArgument ( new ClassArgument ( $ this -> argumentPosition ++ , $ name , $ class , $ required ) ) ; }
5537	public function setFrame ( $ path , $ page ) { $ name = array_shift ( $ path ) ; if ( isset ( $ this -> names [ $ name ] ) ) { $ index = $ this -> names [ $ name ] ; } else { $ index = $ name - 1 ; } if ( count ( $ path ) === 0 ) { $ this -> frames [ $ index ] = $ page ; return ; } $ this -> frames [ $ index ] -> setFrame ( $ path , $ page ) ; }
5084	protected function validateUserInput ( $ aData , $ oItem = null ) { $ aOut = [ ] ; $ aFields = $ this -> oModel -> describeFields ( ) ; $ aKeys = array_unique ( array_merge ( array_keys ( $ aFields ) , arrayExtractProperty ( $ this -> oModel -> getExpandableFields ( ) , 'trigger' ) ) ) ; $ aValidKeys = array_diff ( $ aKeys , static :: IGNORE_FIELDS_WRITE ) ; foreach ( $ aValidKeys as $ sValidKey ) { $ oField = getFromArray ( $ sValidKey , $ aFields ) ; if ( array_key_exists ( $ sValidKey , $ aData ) ) { $ aOut [ $ sValidKey ] = getFromArray ( $ sValidKey , $ aData ) ; } } return $ aOut ; }
1305	public function index ( ) { $ discussions = Discussion :: limit ( 20 ) -> orderBy ( 'created_at' , 'DESC' ) -> get ( ) ; $ discussions -> load ( [ 'user' , 'posts' ] ) ; $ xml = new SimpleXMLElement ( '<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" xml:lang="en-US"/>' ) ; $ xml -> addChild ( 'id' , route ( 'chatter.home' ) ) ; $ link = $ xml -> addChild ( 'link' ) ; $ link -> addAttribute ( 'type' , 'text/html' ) ; $ link -> addAttribute ( 'href' , route ( 'chatter.home' ) ) ; $ link = $ xml -> addChild ( 'link' ) ; $ link -> addAttribute ( 'type' , 'application/atom+xml' ) ; $ link -> addAttribute ( 'rel' , 'self' ) ; $ link -> addAttribute ( 'href' , route ( 'chatter.atom' ) ) ; $ xml -> addChild ( 'title' , config ( 'app.name' ) . ' Discussions' ) ; $ updated = count ( $ discussions ) ? Carbon :: parse ( $ discussions [ 0 ] -> created_at ) : Carbon :: now ( ) ; $ xml -> addChild ( 'updated' , $ updated -> toAtomString ( ) ) ; foreach ( $ discussions as $ discussion ) { $ child = $ xml -> addChild ( 'entry' ) ; $ child -> addChild ( 'id' , route ( 'chatter.discussion.show' , [ 'discussion' => $ discussion -> slug ] ) ) ; $ child -> addChild ( 'title' , $ discussion -> title ) ; $ link = $ child -> addChild ( 'link' ) ; $ link -> addAttribute ( 'type' , 'text/html' ) ; $ link -> addAttribute ( 'rel' , 'alternate' ) ; $ link -> addAttribute ( 'href' , route ( 'chatter.discussion.show' , [ 'discussion' => $ discussion -> slug ] ) ) ; $ child -> addChild ( 'updated' , Carbon :: parse ( $ discussion -> created_at ) -> toAtomString ( ) ) ; $ author = $ child -> addChild ( 'author' ) ; $ author -> addChild ( 'name' , $ discussion -> user -> name ) ; $ content = $ child -> addChild ( 'content' , htmlentities ( count ( $ discussion -> posts ) ? $ discussion -> posts [ 0 ] -> body : '' ) ) ; $ content -> addAttribute ( 'type' , 'html' ) ; } return response ( $ xml -> asXML ( ) , 200 , [ 'Content-Type' => 'application/atom+xml' , ] ) ; }
5125	public function serve ( ) { foreach ( $ this -> dispatchers as $ dispatcher ) { if ( $ dispatcher -> canServe ( ) ) { ContainerScope :: runScope ( $ this -> container , [ $ dispatcher , 'serve' ] ) ; return ; } } throw new BootException ( "Unable to locate active dispatcher." ) ; }
359	function checkUploadMaxFileSize ( $ min = null , $ max = null ) { $ postMaxSize = ini_get ( 'post_max_size' ) ; $ uploadMaxFileSize = ini_get ( 'upload_max_filesize' ) ; if ( $ min !== null ) { $ minCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ min , '>=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ min , '>=' ) ; } else { $ minCheckResult = true ; } if ( $ max !== null ) { $ maxCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ max , '<=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ max , '<=' ) ; } else { $ maxCheckResult = true ; } return ( $ minCheckResult && $ maxCheckResult ) ; }
10104	private function writeWindow2 ( ) { $ record = 0x023E ; $ length = 0x0012 ; $ grbit = 0x00B6 ; $ rwTop = 0x0000 ; $ colLeft = 0x0000 ; $ fDspFmla = 0 ; $ fDspGrid = $ this -> phpSheet -> getShowGridlines ( ) ? 1 : 0 ; $ fDspRwCol = $ this -> phpSheet -> getShowRowColHeaders ( ) ? 1 : 0 ; $ fFrozen = $ this -> phpSheet -> getFreezePane ( ) ? 1 : 0 ; $ fDspZeros = 1 ; $ fDefaultHdr = 1 ; $ fArabic = $ this -> phpSheet -> getRightToLeft ( ) ? 1 : 0 ; $ fDspGuts = $ this -> outlineOn ; $ fFrozenNoSplit = 0 ; $ fSelected = ( $ this -> phpSheet === $ this -> phpSheet -> getParent ( ) -> getActiveSheet ( ) ) ? 1 : 0 ; $ fPaged = 1 ; $ fPageBreakPreview = $ this -> phpSheet -> getSheetView ( ) -> getView ( ) === SheetView :: SHEETVIEW_PAGE_BREAK_PREVIEW ; $ grbit = $ fDspFmla ; $ grbit |= $ fDspGrid << 1 ; $ grbit |= $ fDspRwCol << 2 ; $ grbit |= $ fFrozen << 3 ; $ grbit |= $ fDspZeros << 4 ; $ grbit |= $ fDefaultHdr << 5 ; $ grbit |= $ fArabic << 6 ; $ grbit |= $ fDspGuts << 7 ; $ grbit |= $ fFrozenNoSplit << 8 ; $ grbit |= $ fSelected << 9 ; $ grbit |= $ fPaged << 10 ; $ grbit |= $ fPageBreakPreview << 11 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvv' , $ grbit , $ rwTop , $ colLeft ) ; $ rgbHdr = 0x0040 ; $ zoom_factor_page_break = ( $ fPageBreakPreview ? $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) : 0x0000 ) ; $ zoom_factor_normal = $ this -> phpSheet -> getSheetView ( ) -> getZoomScaleNormal ( ) ; $ data .= pack ( 'vvvvV' , $ rgbHdr , 0x0000 , $ zoom_factor_page_break , $ zoom_factor_normal , 0x00000000 ) ; $ this -> append ( $ header . $ data ) ; }
3637	public function initApp ( ) : void { $ tmpDir = \ Swoft :: getAlias ( '@runtime' ) ; $ names = [ 'logs' , 'uploadfiles' ] ; \ output ( ) -> writeln ( 'Create runtime directories: ' . \ implode ( ',' , $ names ) ) ; foreach ( $ names as $ name ) { DirHelper :: make ( $ tmpDir . '/' . $ name ) ; } \ output ( ) -> writeln ( '<success>OK</success>' ) ; }
4510	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getUuid ( ) ) ; $ event -> setData ( $ data ) ; }
10255	public function getApartment ( ) { $ types = [ 'Apt.' , 'Apartment' , 'Ste.' , 'Suite' , 'Box' ] ; if ( $ this -> getBool ( true , false ) ) { $ extra = $ this -> getLetter ( ) ; } else { $ extra = $ this -> getInteger ( 1 , 9999 ) ; } $ type = $ this -> fromArray ( $ types ) ; return $ type . ' ' . $ extra ; }
8934	public function fetch ( $ name ) { $ template = false ; if ( array_key_exists ( $ name , $ this -> templates ) ) { $ template = $ this -> templates [ $ name ] ; } return $ template ; }
10616	protected function setLifetime ( Response $ response , $ lifetime ) { if ( $ lifetime >= 0 ) { $ date = clone $ response -> getDate ( ) ; $ response -> setMaxAge ( $ lifetime ) -> setExpires ( $ date -> modify ( sprintf ( '+%s seconds' , $ lifetime ) ) ) ; if ( ! $ response -> headers -> hasCacheControlDirective ( 'private' ) ) { $ response -> setPublic ( ) -> setSharedMaxAge ( $ lifetime ) ; } } return $ this ; }
3128	protected function getRangeDuration ( $ start , $ end ) { if ( $ start -> getTarget ( ) != $ end -> getTarget ( ) ) { throw new InconsistentRangeException ( 'A time range must be defined by two TimePoint with the same target' ) ; } $ rangeDuration = $ end -> getTimestamp ( ) - $ start -> getTimestamp ( ) ; if ( $ rangeDuration < 0 ) { throw new InconsistentRangeException ( 'A START TimePoint cannot take place after the END!' ) ; } return $ rangeDuration ; }
3310	public function getAccessToken ( $ forceRefresh = false ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ cached = $ this -> getCache ( ) -> fetch ( $ cacheKey ) ; if ( empty ( $ cached ) || $ forceRefresh ) { $ token = $ this -> getTokenFormApi ( ) ; $ this -> getCache ( ) -> save ( $ cacheKey , $ token [ $ this -> tokenSucessKey ] , $ token [ 'expires_in' ] ) ; return $ token [ $ this -> tokenSucessKey ] ; } return $ cached ; }
12477	private function getTransformation ( ) { $ transforms = [ ] ; foreach ( $ this -> fields as $ field => $ extra ) { if ( is_int ( $ field ) ) { $ transforms [ $ extra ] = $ extra ; continue ; } $ transform = ( key_exists ( 'transform' , $ extra ) ) ? $ extra [ 'transform' ] : $ field ; if ( $ transform === false ) { continue ; } $ transforms [ $ field ] = $ transform ; } return $ transforms ; }
7814	private function _processRequest ( ) { $ this -> _isAjaxRequest = $ this -> request -> is ( 'ajax' ) ; if ( isset ( $ this -> request -> query [ 'length' ] ) && ! empty ( $ this -> request -> query [ 'length' ] ) ) { $ this -> config ( 'length' , $ this -> request -> query [ 'length' ] ) ; } if ( isset ( $ this -> request -> query [ 'start' ] ) && ! empty ( $ this -> request -> query [ 'start' ] ) ) { $ this -> config ( 'start' , ( int ) $ this -> request -> query [ 'start' ] ) ; } if ( isset ( $ this -> request -> query [ 'order' ] ) && ! empty ( $ this -> request -> query [ 'order' ] ) ) { $ order = $ this -> config ( 'order' ) ; foreach ( $ this -> request -> query [ 'order' ] as $ item ) { $ order [ $ this -> request -> query [ 'columns' ] [ $ item [ 'column' ] ] [ 'name' ] ] = $ item [ 'dir' ] ; } $ this -> config ( 'order' , $ order ) ; } if ( isset ( $ this -> request -> query [ 'draw' ] ) && ! empty ( $ this -> request -> query [ 'draw' ] ) ) { $ this -> _viewVars [ 'draw' ] = ( int ) $ this -> request -> query [ 'draw' ] ; } if ( ! isset ( $ this -> request -> query [ 'columns' ] ) || empty ( $ this -> request -> query [ 'columns' ] ) ) { return ; } $ globalSearch = ( isset ( $ this -> request -> query [ 'search' ] [ 'value' ] ) ? $ this -> request -> query [ 'search' ] [ 'value' ] : false ) ; foreach ( $ this -> request -> query [ 'columns' ] as $ column ) { if ( $ globalSearch && $ column [ 'searchable' ] == 'true' ) { $ this -> _addCondition ( $ column [ 'name' ] , $ globalSearch , 'or' ) ; } $ localSearch = $ column [ 'search' ] [ 'value' ] ; if ( ! empty ( $ localSearch ) && ( $ localSearch !== $ globalSearch ) ) { $ this -> _addCondition ( $ column [ 'name' ] , $ column [ 'search' ] [ 'value' ] ) ; } } }
8142	public function clearCacheFiles ( ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( is_string ( $ this -> originalCache ) ) { foreach ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ this -> originalCache ) , RecursiveIteratorIterator :: LEAVES_ONLY ) as $ file ) { if ( $ file -> isFile ( ) ) { @ unlink ( $ file -> getPathname ( ) ) ; } } } }
8230	public static function writeFile ( $ fileName , $ data , $ options = [ ] ) { $ writer = new File \ FileWriter ( $ fileName , $ options ) ; $ isSuccess = true ; $ written = 0 ; try { $ writer -> open ( ) ; $ written = $ writer -> write ( $ data ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ isSuccess = false ; } try { $ writer -> close ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ isSuccess = false ; } return $ isSuccess ; }
6908	public function addCopy ( Recipient $ copy ) { if ( ! $ this -> copies -> contains ( $ copy ) ) { $ this -> copies -> add ( $ copy ) ; } return $ this ; }
6047	public function listObjectTypes ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/objecttypes' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new ObjectType ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
1840	public static function countBy ( $ strColumn = null , $ varValue = null , array $ arrOptions = array ( ) ) { if ( static :: $ strTable == '' ) { return 0 ; } $ arrOptions = array_merge ( array ( 'table' => static :: $ strTable , 'column' => $ strColumn , 'value' => $ varValue ) , $ arrOptions ) ; $ strQuery = static :: buildCountQuery ( $ arrOptions ) ; return ( int ) Database :: getInstance ( ) -> prepare ( $ strQuery ) -> execute ( $ arrOptions [ 'value' ] ) -> count ; }
7980	public function getSessionFiles ( $ sessId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionFiles ( $ this -> pp , $ this -> sn , $ sessId ) ) ; }
7598	public function render ( $ sGlyphicon , array $ aGlyphiconAttributes = null ) { if ( ! is_scalar ( $ sGlyphicon ) ) { throw new InvalidArgumentException ( 'Glyphicon expects a scalar value, "' . gettype ( $ sGlyphicon ) . '" given' ) ; } if ( empty ( $ aGlyphiconAttributes ) ) { $ aGlyphiconAttributes = array ( 'class' => 'glyphicon' ) ; } else { if ( empty ( $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] = 'glyphicon' ; } elseif ( ! preg_match ( '/(\s|^)glyphicon(\s|$)/' , $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] .= ' glyphicon' ; } } if ( strpos ( 'glyphicon-' , $ sGlyphicon ) !== 0 ) { $ sGlyphicon = 'glyphicon-' . $ sGlyphicon ; } if ( ! preg_match ( '/(\s|^)' . preg_quote ( $ sGlyphicon , '/' ) . '(\s|$)/' , $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] .= ' ' . $ sGlyphicon ; } return sprintf ( static :: $ glyphiconFormat , $ this -> createAttributesString ( $ aGlyphiconAttributes ) ) ; }
11464	public static function error ( $ severity , $ message , $ file , $ line ) { if ( error_reporting ( ) == 0 ) return ; elseif ( error_reporting ( ) && $ severity ) { $ ErrorException = new PHPErrorException ( $ message , 0 , $ severity , $ file , $ line ) ; if ( assert_options ( ASSERT_ACTIVE ) ) { foreach ( $ ErrorException -> getStackTrace ( ) as $ element ) { if ( isset ( $ element [ 'function' ] ) && $ element [ 'function' ] == 'assert' ) { self :: exception ( $ ErrorException ) ; } } } $ recoverable = [ E_WARNING , E_NOTICE , E_USER_WARNING , E_USER_NOTICE , E_STRICT , E_DEPRECATED , E_USER_DEPRECATED ] ; if ( in_array ( $ severity , $ recoverable ) ) { return ; } throw $ ErrorException ; } }
4963	public function addViewTemplate ( $ name , $ template , $ vars = [ ] , $ priority = 0 ) { if ( is_int ( $ vars ) ) { $ priority = $ vars ; $ vars = [ ] ; } $ model = new ViewModel ( $ vars ) ; $ model -> setTemplate ( $ template ) ; return $ this -> addViewModel ( $ name , $ model , $ priority ) ; }
9069	public function purge ( $ days_older_than = 60 , \ wpdb $ wpdb ) { $ days_older_than = absint ( $ days_older_than ) ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ sql = "DELETE FROM {$tn} WHERE time < DATE_SUB(NOW(), INTERVAL $days_older_than DAY)" ; $ wpdb -> query ( $ sql ) ; }
6524	public function getHandlerMethodName ( $ withMajor = true ) { if ( true === $ withMajor ) { return lcfirst ( $ this -> classShortName ) ; } return lcfirst ( str_replace ( 'V' . $ this -> id -> getVersion ( ) -> getMajor ( ) , '' , $ this -> classShortName ) ) ; }
4034	public function getLabel ( $ table ) : string { if ( strpos ( $ table , 'tl_' ) !== 0 ) { return $ table ; } $ shortTable = str_replace ( 'tl_' , '' , $ table ) ; $ label = $ this -> translator -> trans ( 'BRD.' . $ shortTable , [ ] , 'contao_default' ) ; if ( $ label === $ shortTable ) { $ shortTable = str_replace ( 'tl_metamodel_' , '' , $ table ) ; return ucfirst ( $ shortTable ) . ' %s' ; } return StringUtil :: specialchars ( $ label ) ; }
3349	private function __getQueryString ( $ queryAr = array ( ) , $ prefixIfNotEmpty = '' ) { $ queryAr = array_filter ( $ queryAr ) ; array_walk ( $ queryAr , function ( & $ val , $ key ) { $ val = urlencode ( $ key ) . '=' . urlencode ( $ val ) ; } ) ; return $ queryAr ? $ prefixIfNotEmpty . join ( '&' , $ queryAr ) : '' ; }
41	public static function checkCertificateHost ( $ certificate , $ hostname , & $ cn = null ) { $ names = self :: getCertificateNames ( $ certificate ) ; if ( empty ( $ names ) ) { return false ; } $ combinedNames = array_merge ( $ names [ 'san' ] , array ( $ names [ 'cn' ] ) ) ; $ hostname = strtolower ( $ hostname ) ; foreach ( $ combinedNames as $ certName ) { $ matcher = self :: certNameMatcher ( $ certName ) ; if ( $ matcher && $ matcher ( $ hostname ) ) { $ cn = $ names [ 'cn' ] ; return true ; } } return false ; }
1321	private function request ( $ url , $ method , $ authorization , array $ postfields , $ json = false ) { $ options = $ this -> curlOptions ( ) ; $ options [ CURLOPT_URL ] = $ url ; $ options [ CURLOPT_HTTPHEADER ] = [ 'Accept: application/json' , $ authorization , 'Expect:' ] ; switch ( $ method ) { case 'GET' : break ; case 'POST' : $ options [ CURLOPT_POST ] = true ; if ( $ json ) { $ options [ CURLOPT_HTTPHEADER ] [ ] = 'Content-type: application/json' ; $ options [ CURLOPT_POSTFIELDS ] = json_encode ( $ postfields ) ; } else { $ options [ CURLOPT_POSTFIELDS ] = Util :: buildHttpQuery ( $ postfields ) ; } break ; case 'DELETE' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case 'PUT' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; } if ( in_array ( $ method , [ 'GET' , 'PUT' , 'DELETE' ] ) && ! empty ( $ postfields ) ) { $ options [ CURLOPT_URL ] .= '?' . Util :: buildHttpQuery ( $ postfields ) ; } $ curlHandle = curl_init ( ) ; curl_setopt_array ( $ curlHandle , $ options ) ; $ response = curl_exec ( $ curlHandle ) ; if ( curl_errno ( $ curlHandle ) > 0 ) { throw new TwitterOAuthException ( curl_error ( $ curlHandle ) , curl_errno ( $ curlHandle ) ) ; } $ this -> response -> setHttpCode ( curl_getinfo ( $ curlHandle , CURLINFO_HTTP_CODE ) ) ; $ parts = explode ( "\r\n\r\n" , $ response ) ; $ responseBody = array_pop ( $ parts ) ; $ responseHeader = array_pop ( $ parts ) ; $ this -> response -> setHeaders ( $ this -> parseHeaders ( $ responseHeader ) ) ; curl_close ( $ curlHandle ) ; return $ responseBody ; }
11539	public function add ( $ sourceDir , array $ options , $ username ) { $ this -> resolveAddOptions ( $ options ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ this -> addBlockToSlot ( $ dir , $ options ) ; $ blockContent = $ this -> addBlock ( $ dir , $ options , $ blockName ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been added to the "%s" slot on page "%s" for the "%s_%s" language' , $ blockName , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; return $ blockContent ; }
9872	private function writeSheetData ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet , array $ pStringTable ) { $ aFlippedStringTable = $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> flipStringTable ( $ pStringTable ) ; $ objWriter -> startElement ( 'sheetData' ) ; $ colCount = Coordinate :: columnIndexFromString ( $ pSheet -> getHighestColumn ( ) ) ; $ highestRow = $ pSheet -> getHighestRow ( ) ; $ cellsByRow = [ ] ; foreach ( $ pSheet -> getCoordinates ( ) as $ coordinate ) { $ cellAddress = Coordinate :: coordinateFromString ( $ coordinate ) ; $ cellsByRow [ $ cellAddress [ 1 ] ] [ ] = $ coordinate ; } $ currentRow = 0 ; while ( $ currentRow ++ < $ highestRow ) { $ rowDimension = $ pSheet -> getRowDimension ( $ currentRow ) ; $ writeCurrentRow = isset ( $ cellsByRow [ $ currentRow ] ) || $ rowDimension -> getRowHeight ( ) >= 0 || $ rowDimension -> getVisible ( ) == false || $ rowDimension -> getCollapsed ( ) == true || $ rowDimension -> getOutlineLevel ( ) > 0 || $ rowDimension -> getXfIndex ( ) !== null ; if ( $ writeCurrentRow ) { $ objWriter -> startElement ( 'row' ) ; $ objWriter -> writeAttribute ( 'r' , $ currentRow ) ; $ objWriter -> writeAttribute ( 'spans' , '1:' . $ colCount ) ; if ( $ rowDimension -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , '1' ) ; $ objWriter -> writeAttribute ( 'ht' , StringHelper :: formatNumber ( $ rowDimension -> getRowHeight ( ) ) ) ; } if ( $ rowDimension -> getVisible ( ) == false ) { $ objWriter -> writeAttribute ( 'hidden' , 'true' ) ; } if ( $ rowDimension -> getCollapsed ( ) == true ) { $ objWriter -> writeAttribute ( 'collapsed' , 'true' ) ; } if ( $ rowDimension -> getOutlineLevel ( ) > 0 ) { $ objWriter -> writeAttribute ( 'outlineLevel' , $ rowDimension -> getOutlineLevel ( ) ) ; } if ( $ rowDimension -> getXfIndex ( ) !== null ) { $ objWriter -> writeAttribute ( 's' , $ rowDimension -> getXfIndex ( ) ) ; $ objWriter -> writeAttribute ( 'customFormat' , '1' ) ; } if ( isset ( $ cellsByRow [ $ currentRow ] ) ) { foreach ( $ cellsByRow [ $ currentRow ] as $ cellAddress ) { $ this -> writeCell ( $ objWriter , $ pSheet , $ cellAddress , $ aFlippedStringTable ) ; } } $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; }
11627	public function lock ( ) { $ lock_file = $ this -> getLockFile ( ) ; if ( file_exists ( $ lock_file ) ) { $ this -> pid = file_get_contents ( $ lock_file ) ; if ( $ this -> isrunning ( ) ) { error_log ( "==" . $ this -> pid . "== Already in progress..." ) ; return false ; } else error_log ( "==" . $ this -> pid . "== Previous job died abruptly..." ) ; } $ this -> pid = getmypid ( ) ; $ s = file_put_contents ( $ lock_file , $ this -> pid ) ; error_log ( "==" . $ this -> pid . "== Lock acquired, processing the job..." ) ; return $ this -> pid ; }
9429	public function getFontIconClassNames ( ) { $ classes = [ ] ; if ( $ this -> owner -> FontIcon ) { if ( $ this -> owner -> FontIconListItem ) { $ classes [ ] = $ this -> backend -> getClassName ( 'list-item' ) ; } if ( $ this -> owner -> FontIconFixedWidth ) { $ classes [ ] = $ this -> backend -> getClassName ( 'fixed-width' ) ; } $ classes [ ] = $ this -> backend -> getClassName ( 'icon' , [ $ this -> owner -> FontIcon ] ) ; } return $ classes ; }
6553	public function unlock ( ) { try { if ( $ this -> pid === $ this -> getSerial ( ) && is_resource ( $ this -> fh ) ) { $ this -> removeLineFromFile ( $ this -> pid , $ this -> fh ) ; flock ( $ this -> fh , LOCK_UN ) ; fclose ( $ this -> fh ) ; if ( filesize ( $ filename = $ this -> getPidFilename ( ) ) === 0 ) { unlink ( $ filename ) ; } } } catch ( FileNotFoundException $ fnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID file %s doesn\'t exist' , $ this -> getPidFilename ( ) ) ) ; } catch ( LineNotFoundException $ lnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID %s is can not be found in PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( sprintf ( 'Can\'t remove PID %s from PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) , null , $ e ) ; } }
3712	public function generateClearAll ( $ strContent , $ strTemplate ) { if ( substr ( $ strTemplate , 0 , 3 ) === 'fe_' ) { if ( preg_match_all ( '#\[\[\[metamodelfrontendfilterclearall::(ce|mod)::([^\]]*)\]\]\]#' , $ strContent , $ arrMatches , PREG_SET_ORDER ) ) { foreach ( $ arrMatches as $ arrMatch ) { switch ( $ arrMatch [ 1 ] ) { case 'ce' : $ strContent = $ this -> generateContentElement ( $ strContent , $ arrMatch [ 0 ] , $ arrMatch [ 2 ] ) ; break ; case 'mod' : $ strContent = $ this -> generateModule ( $ strContent , $ arrMatch [ 0 ] , $ arrMatch [ 2 ] ) ; break ; default : throw new \ RuntimeException ( 'Unexpected element determinator encountered: ' . $ arrMatch [ 1 ] ) ; } } } } return $ strContent ; }
4622	protected function pickNode ( ) { $ nodes = $ this -> getNodes ( ) ; $ index = mt_rand ( 0 , count ( $ nodes ) - 1 ) ; return array_keys ( $ nodes ) [ $ index ] ; }
6469	public function parseAcceptHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept' , $ i ) ; $ mediaType = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptMediaTypeHeaderValue ( $ mediaType , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
4740	protected static function _clear ( $ fileName , $ filePath ) { if ( ! in_array ( $ fileName , [ '.' , '..' , '.gitkeep' , '.htaccess' ] ) ) { if ( is_file ( $ filePath ) ) { @ unlink ( $ filePath ) ; } else { self :: clearTmp ( $ filePath ) ; } } }
1198	protected function escape ( $ value ) { return $ this -> fixDoubleEscape ( htmlspecialchars ( ( string ) $ value , ENT_QUOTES | ENT_SUBSTITUTE , $ this -> charset ) ) ; }
4028	protected function getLabelImage ( ModelInterface $ model ) { $ typeFactory = $ this -> factory -> getTypeFactory ( $ model -> getProperty ( 'type' ) ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> updateImageWithDisabled ( $ model , $ typeFactory -> getTypeIcon ( ) ) , '' , '' , $ this -> updateImageWithDisabled ( $ model , 'bundles/metamodelscore/images/icons/filter_default.png' ) ) ; $ urlEvent = $ this -> dispatcher -> dispatch ( ContaoEvents :: BACKEND_ADD_TO_URL , new AddToUrlEvent ( 'act=edit&amp;id=' . $ model -> getId ( ) ) ) ; return sprintf ( '<a href="%s">%s</a>' , $ urlEvent -> getUrl ( ) , $ image ) ; }
9900	private function advance ( ) { $ i = $ this -> currentCharacter ; $ formula_length = strlen ( $ this -> formula ) ; if ( $ i < $ formula_length ) { while ( $ this -> formula [ $ i ] == ' ' ) { ++ $ i ; } if ( $ i < ( $ formula_length - 1 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 1 ] ; } $ token = '' ; } while ( $ i < $ formula_length ) { $ token .= $ this -> formula [ $ i ] ; if ( $ i < ( $ formula_length - 1 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 1 ] ; } else { $ this -> lookAhead = '' ; } if ( $ this -> match ( $ token ) != '' ) { $ this -> currentCharacter = $ i + 1 ; $ this -> currentToken = $ token ; return 1 ; } if ( $ i < ( $ formula_length - 2 ) ) { $ this -> lookAhead = $ this -> formula [ $ i + 2 ] ; } else { $ this -> lookAhead = '' ; } ++ $ i ; } }
6706	public function beforeUpdate ( $ event ) { if ( is_array ( $ this -> fields ) ) { foreach ( $ this -> fields as $ field ) { if ( is_array ( $ event -> sender -> { $ field } ) ) { $ event -> sender -> { $ field } = implode ( ';' , $ event -> sender -> { $ field } ) ; } } } }
3568	public function replicate ( ) { return function ( $ next , $ copy , $ args ) { $ metaAttributes = $ args -> get ( 'original' ) -> getMetaAttributes ( ) -> replicate ( $ args -> get ( 'except' ) ) ; $ copy -> setRelation ( 'metaAttributes' , $ metaAttributes ) ; return $ next ( $ copy , $ args ) ; } ; }
4909	public function renderForm ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ formHelper = $ renderer -> plugin ( 'form' ) ; $ fieldset = $ form -> getBaseFieldset ( ) ; $ resetPartial = false ; if ( $ fieldset instanceof ViewPartialProviderInterface ) { $ origPartial = $ fieldset -> getViewPartial ( ) ; $ partial = "$origPartial.form" ; if ( $ renderer -> resolver ( $ partial ) ) { $ fieldset -> setViewPartial ( $ partial ) ; $ resetPartial = true ; } } $ markup = $ formHelper -> renderBare ( $ form , $ layout , $ parameter ) ; if ( $ resetPartial ) { $ fieldset -> setViewPartial ( $ origPartial ) ; } return $ markup ; }
6546	public function get ( $ name ) { if ( ( $ sheet = $ this -> container -> getSheetByName ( $ name ) ) === null ) { throw new \ Aimeos \ MW \ Container \ Exception ( sprintf ( 'No sheet "%1$s" available' , $ name ) ) ; } return new \ Aimeos \ MW \ Container \ Content \ PHPExcel ( $ sheet , $ sheet -> getTitle ( ) , $ this -> getOptions ( ) ) ; }
7747	private function findAdderAndRemover ( ) { $ reflClass = new \ ReflectionClass ( $ this -> class ) ; $ singulars = ( array ) StringUtil :: singularify ( $ this -> camelize ( $ this -> name ) ) ; foreach ( $ singulars as $ singular ) { $ addMethod = 'add' . $ singular ; $ removeMethod = 'remove' . $ singular ; $ addMethodFound = $ this -> isAccessible ( $ reflClass , $ addMethod , 1 ) ; $ removeMethodFound = $ this -> isAccessible ( $ reflClass , $ removeMethod , 1 ) ; if ( $ addMethodFound && $ removeMethodFound ) { $ this -> adderRemover = $ singular ; return ; } } }
4654	protected function getJobs ( $ projectPath ) { $ jobs = array ( ) ; $ project = $ this -> naming -> getProjectName ( $ projectPath ) ; $ repositoryRegex = sprintf ( '#^%s_([a-z]+?)/%s:\d+-\d+$#' , Job :: BASE_NAME , $ project ) ; foreach ( $ this -> docker -> getImageManager ( ) -> findAll ( ) as $ image ) { foreach ( $ image -> getRepoTags ( ) as $ name ) { if ( preg_match ( $ repositoryRegex , $ name , $ matches ) ) { $ jobs [ ] = $ this -> getJobFromImage ( $ image , $ name , $ matches [ 1 ] , $ project ) ; } } } return $ jobs ; }
2867	public function getContent ( $ filePath , $ startPosition , $ endPosition ) { if ( ! file_exists ( $ filePath ) ) { return '' ; } if ( ! $ endPosition ) { return trim ( file_get_contents ( $ filePath , null , null , $ startPosition ) ) ; } if ( $ endPosition <= $ startPosition ) { return '' ; } return trim ( file_get_contents ( $ filePath , null , null , $ startPosition , $ endPosition - $ startPosition ) ) ; }
5844	public function saveAdditionalFields ( array $ submittedData , \ TYPO3 \ CMS \ Scheduler \ Task \ AbstractTask $ task ) { $ task -> directories = trim ( $ submittedData [ 'scheduler_batchResize_directories' ] ) ; $ task -> excludeDirectories = trim ( $ submittedData [ 'scheduler_batchResize_excludeDirectories' ] ) ; }
10227	public function pageFor ( $ model , $ itemId = 0 , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ item = $ this -> findItem ( $ modelName , $ itemId ) ; $ pageFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\PageFactory' ) ; return $ pageFactory -> create ( $ modelName , $ item , $ config ) ; }
4878	public function setUser ( UserInterface $ user ) { if ( $ this -> user ) { $ this -> getPermissions ( ) -> revoke ( $ this -> user , Permissions :: PERMISSION_ALL , false ) ; } $ this -> user = $ user ; $ this -> getPermissions ( ) -> grant ( $ user , Permissions :: PERMISSION_ALL ) ; return $ this ; }
7396	public function execute ( ) { $ addresses = $ this -> addressRepository -> createQueryBuilder ( 'a' ) -> where ( 'a.latitude IS NULL' ) -> orWhere ( 'a.longitude IS NULL' ) -> setMaxResults ( 500 ) -> getQuery ( ) -> getResult ( ) ; foreach ( $ addresses as $ address ) { try { $ this -> updateLatLong ( $ address ) ; } catch ( \ RuntimeException $ e ) { echo "Stopping work -- over the API query limit.\n" ; break ; } $ this -> entityManager -> persist ( $ address ) ; usleep ( self :: MILLISECONDS_PAUSE_BETWEEN_QUERIES ) ; } $ this -> entityManager -> flush ( ) ; }
12269	protected function generateEventNames ( $ baseEventName , Page $ page ) { $ pageName = $ page -> getPageName ( ) ; $ language = $ page -> getCurrentLanguage ( ) ; return array ( $ baseEventName , $ baseEventName . '.' . $ language , $ baseEventName . '.' . $ pageName , $ baseEventName . '.' . $ language . '.' . $ pageName , ) ; }
11245	public function getRan ( ) : array { $ stmt = $ this -> pdo -> query ( "select migration from {$this->table} order by batch, migration" ) ; $ stmt -> execute ( ) ; $ results = $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; return $ results ; }
9087	public function attach ( ResolverInterface $ detector , $ priority = 1 ) { $ this -> queue -> insert ( $ detector , $ priority ) ; return $ this ; }
5536	public function addFrame ( $ page , $ name = false ) { $ this -> frames [ ] = $ page ; if ( $ name ) { $ this -> names [ $ name ] = count ( $ this -> frames ) - 1 ; } }
7208	public function round ( ) : void { $ this -> unit = Money :: round ( $ this -> unit , $ this -> currency ) ; $ this -> gross = Money :: round ( $ this -> gross , $ this -> currency ) ; $ this -> discount = Money :: round ( $ this -> discount , $ this -> currency ) ; $ this -> base = Money :: round ( $ this -> base , $ this -> currency ) ; $ this -> total = Money :: round ( $ this -> total , $ this -> currency ) ; $ this -> tax = Money :: round ( $ this -> total - $ this -> base , $ this -> currency ) ; }
6478	protected function encodingIsSupported ( string $ encoding ) : bool { $ lowercaseSupportedEncodings = array_map ( 'strtolower' , $ this -> getSupportedEncodings ( ) ) ; $ lowercaseEncoding = strtolower ( $ encoding ) ; return in_array ( $ lowercaseEncoding , $ lowercaseSupportedEncodings , true ) ; }
8804	public function getFlash ( $ key = null ) { if ( ! is_null ( $ key ) ) { $ value = null ; if ( $ this -> hasFlash ( $ key ) ) { $ value = $ this -> get ( '_nur_flash' ) [ $ key ] ; unset ( $ _SESSION [ '_nur_flash' ] [ $ key ] ) ; } return $ value ; } return $ key ; }
10832	public function actionIndex ( ) { $ searchModel = new SearchState ( Yii :: $ app -> request -> get ( ) ) ; $ dataProvider = $ searchModel -> search ( Yii :: $ app -> request -> queryParams ) ; return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider ] ) ; }
12411	public function lists ( $ begin , $ count ) { $ params = [ 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_LIST , $ params ] ) ; }
10955	protected function redirect ( Response $ response , int $ code , string $ url ) : Response { return $ response -> withStatus ( $ code ) -> withHeader ( 'Location' , $ url ) ; }
5069	public function infoRead ( int & $ msgsInQueue = null ) : ? CurlMultiInfoInterface { $ info = curl_multi_info_read ( $ this -> mh , $ msgsInQueue ) ; if ( ! $ info ) { return null ; } return new CurlMultiInfo ( $ info ) ; }
4997	public function setSearchParams ( $ params ) { if ( $ params instanceof \ Traversable ) { $ params = ArrayUtils :: iteratorToArray ( $ params ) ; } $ params = Json :: encode ( $ params ) ; $ this -> setAttribute ( 'data-search-params' , $ params ) ; return $ this ; }
94	protected function hasVendorIgnore ( $ ignoreFile , $ vendor = 'vendor' ) { if ( ! file_exists ( $ ignoreFile ) ) { return false ; } $ pattern = sprintf ( '{^/?%s(/\*?)?$}' , preg_quote ( $ vendor ) ) ; $ lines = file ( $ ignoreFile , FILE_IGNORE_NEW_LINES ) ; foreach ( $ lines as $ line ) { if ( preg_match ( $ pattern , $ line ) ) { return true ; } } return false ; }
550	public function actionIndex ( ) { $ caches = $ this -> findCaches ( ) ; if ( ! empty ( $ caches ) ) { $ this -> notifyCachesCanBeFlushed ( $ caches ) ; } else { $ this -> notifyNoCachesFound ( ) ; } }
9701	public function addXfWriter ( Style $ style , $ isStyleXf = false ) { $ xfWriter = new Xf ( $ style ) ; $ xfWriter -> setIsStyleXf ( $ isStyleXf ) ; $ fontIndex = $ this -> addFont ( $ style -> getFont ( ) ) ; $ xfWriter -> setFontIndex ( $ fontIndex ) ; $ xfWriter -> setFgColor ( $ this -> addColor ( $ style -> getFill ( ) -> getStartColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setBgColor ( $ this -> addColor ( $ style -> getFill ( ) -> getEndColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setBottomColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getBottom ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setTopColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getTop ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setRightColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getRight ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setLeftColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getLeft ( ) -> getColor ( ) -> getRGB ( ) ) ) ; $ xfWriter -> setDiagColor ( $ this -> addColor ( $ style -> getBorders ( ) -> getDiagonal ( ) -> getColor ( ) -> getRGB ( ) ) ) ; if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false ) { $ numberFormatHashCode = $ style -> getNumberFormat ( ) -> getHashCode ( ) ; if ( isset ( $ this -> addedNumberFormats [ $ numberFormatHashCode ] ) ) { $ numberFormatIndex = $ this -> addedNumberFormats [ $ numberFormatHashCode ] ; } else { $ numberFormatIndex = 164 + count ( $ this -> numberFormats ) ; $ this -> numberFormats [ $ numberFormatIndex ] = $ style -> getNumberFormat ( ) ; $ this -> addedNumberFormats [ $ numberFormatHashCode ] = $ numberFormatIndex ; } } else { $ numberFormatIndex = ( int ) $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) ; } $ xfWriter -> setNumberFormatIndex ( $ numberFormatIndex ) ; $ this -> xfWriters [ ] = $ xfWriter ; $ xfIndex = count ( $ this -> xfWriters ) - 1 ; return $ xfIndex ; }
5067	public function setOpt ( int $ option , $ value ) : bool { return curl_setopt ( $ this -> ch , $ option , $ value ) ; }
12183	public static function getOne ( Item $ parent , Item $ child , $ options = [ ] ) { $ key = md5 ( $ parent -> systemId . "." . $ child -> systemId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { self :: $ _relationships [ $ key ] -> mergeOptions ( $ options ) ; } else { self :: $ _relationships [ $ key ] = new Relationship ( $ parent , $ child , $ options ) ; } return self :: $ _relationships [ $ key ] ; }
4513	public function toObject ( ) : stdClass { $ object = new stdClass ; $ object -> timestamp = $ this -> timestamp ; $ object -> collection = $ this -> collection -> toArray ( ) ; foreach ( $ object -> collection as $ alias => $ status ) { $ object -> collection [ $ alias ] = $ status -> toObject ( ) ; } return $ object ; }
1131	public function inSameScope ( $ other ) { foreach ( $ this -> getScopedColumns ( ) as $ fld ) { if ( $ this -> $ fld != $ other -> $ fld ) return false ; } return true ; }
2085	public static function addFiles ( $ files ) { foreach ( $ files as $ name => $ file ) { self :: addFile ( $ name , $ file ) ; } }
5423	public function invoke ( $ method ) { $ trap = SimpleTest :: getContext ( ) -> get ( 'SimpleExceptionTrap' ) ; $ trap -> clear ( ) ; try { $ has_thrown = false ; parent :: invoke ( $ method ) ; } catch ( Exception $ exception ) { $ has_thrown = true ; if ( ! $ trap -> isExpected ( $ this -> getTestCase ( ) , $ exception ) ) { $ this -> getTestCase ( ) -> exception ( $ exception ) ; } $ trap -> clear ( ) ; } if ( $ message = $ trap -> getOutstanding ( ) ) { $ this -> getTestCase ( ) -> fail ( $ message ) ; } if ( $ has_thrown ) { try { parent :: getTestCase ( ) -> tearDown ( ) ; } catch ( Exception $ e ) { } } }
3158	public function getResponseVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_ResponseVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setValue ( $ variableValue ) ; return $ metaVariable ; }
4187	public function publish ( $ provider ) { $ class = last ( explode ( '\\' , $ provider ) ) ; $ this -> console -> info ( "Searching {$provider} to publish vendor file." ) ; if ( ! $ this -> finder -> contains ( $ class ) -> contains ( '/\$this->publishes/i' ) -> count ( ) ) { $ this -> console -> warn ( 'Nothing to publish.' ) ; return true ; } $ tag = $ this -> console -> ask ( "If the \"{$this->console->tokenizePackageInfo()['name']}\" has specify vendor publish tag in installation guide then please add it here or press enter to skip adding tag." , false ) ; $ this -> console -> call ( 'vendor:publish' , [ '--provider' => $ provider , '--tag' => $ tag , ] ) ; return $ this -> registered = true ; }
5463	protected function getCommonPath ( $ first , $ second ) { $ first = explode ( '/' , $ first ) ; $ second = explode ( '/' , $ second ) ; for ( $ i = 0 ; $ i < min ( count ( $ first ) , count ( $ second ) ) ; $ i ++ ) { if ( $ first [ $ i ] != $ second [ $ i ] ) { return implode ( '/' , array_slice ( $ first , 0 , $ i ) ) . '/' ; } } return implode ( '/' , $ first ) . '/' ; }
11056	public function urlFunction ( $ route , array $ params = [ ] ) { return $ this -> container [ 'url_generator' ] -> generate ( $ route , $ params , UrlGeneratorInterface :: ABSOLUTE_URL ) ; }
8080	public function & getReports ( $ channel = null ) { $ channel = $ this -> namespaceChannel ( $ channel ) ; if ( ! isset ( $ this -> console [ 'reports' ] [ $ channel ] ) ) { $ this -> console [ 'reports' ] [ $ channel ] = array ( ) ; } return $ this -> console [ 'reports' ] [ $ channel ] ; }
10914	public function execute ( ) { try { $ this -> output_buffer_level = ob_get_level ( ) ; ob_start ( ) ; $ response = $ this -> doExecute ( ) ; if ( ( is_object ( $ response ) && ! ( $ response instanceof Response ) ) || ( is_string ( $ response ) && class_exists ( $ response ) ) ) { $ response = $ this -> reflect ( $ response ) ; } if ( $ response instanceof Response ) throw $ response ; throw new HTTPError ( 500 , "App did not produce any response" ) ; } catch ( Response $ response ) { self :: $ logger -> debug ( "Response type {0} returned from controller: {1}" , [ get_class ( $ response ) , $ this -> app ] ) ; throw $ response ; } catch ( Throwable $ e ) { self :: $ logger -> debug ( "While executing controller: {0}" , [ $ this -> app ] ) ; self :: $ logger -> notice ( "Unexpected exception of type {0} thrown while processing request: {1}" , [ get_class ( $ e ) , $ e ] ) ; throw $ e ; } finally { $ this -> logScriptOutput ( ) ; } }
3625	public function getDevices ( $ type = DEVICE_TYPE_THERMOSTAT ) { $ this -> prepareForGet ( ) ; if ( $ type == DEVICE_TYPE_PROTECT ) { $ protects = array ( ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ topaz as $ protect ) { $ protects [ ] = $ protect -> serial_number ; } return $ protects ; } $ devices_serials = array ( ) ; foreach ( $ this -> last_status -> user -> { $ this -> userid } -> structures as $ structure ) { list ( , $ structure_id ) = explode ( '.' , $ structure ) ; foreach ( $ this -> last_status -> structure -> { $ structure_id } -> devices as $ device ) { list ( , $ device_serial ) = explode ( '.' , $ device ) ; $ devices_serials [ ] = $ device_serial ; } } return $ devices_serials ; }
8831	protected function getCheckboxCheckedState ( $ name , $ value , $ checked ) { $ posted = $ this -> getValueAttribute ( $ name , $ checked ) ; if ( is_array ( $ posted ) ) { return in_array ( $ value , $ posted ) ; } else { return ( bool ) $ posted ; } }
7834	protected function getPipesByOption ( $ option ) { $ pipes = $ this -> option ( $ option ) ; preg_match_all ( '/\w+/' , $ pipes , $ matches ) ; return array_map ( 'ucfirst' , $ matches [ 0 ] ) ; }
159	public function having ( $ condition , $ params = [ ] ) { $ this -> having = $ condition ; $ this -> addParams ( $ params ) ; return $ this ; }
11927	public function actionRunOne ( ) { $ this -> out ( "Run Interface " . $ this -> dataInterface -> object -> name , Console :: UNDERLINE , Console :: FG_GREEN ) ; $ this -> hr ( ) ; $ this -> dataInterface -> run ( null , new ConsoleAction ( ) ) ; }
8889	public function set ( $ key , $ value ) { if ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value , false ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } }
7355	public static function isValidSize ( $ size , $ throw = false ) { if ( in_array ( $ size , static :: getSizes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Unknown size '$size'." ) ; } return false ; }
10191	public function validate ( ) { foreach ( func_get_args ( ) as $ key ) { $ value = $ this -> parameters -> get ( $ key ) ; if ( ! isset ( $ value ) ) { throw new InvalidRequestException ( "The $key parameter is required" ) ; } } }
1355	protected function defaultSort ( ) { return collect ( $ this -> defaultSort ) -> map ( function ( $ param ) { $ desc = ( $ param [ 0 ] === '-' ) ; $ field = ltrim ( $ param , '-' ) ; return new SortParameter ( $ field , ! $ desc ) ; } ) -> all ( ) ; }
11623	public function close ( ) { if ( $ this -> id == null ) { throw new InternalException ( 'Session not loaded' ) ; } if ( ! $ this -> cli ) { session_write_close ( ) ; } $ this -> id = null ; }
11096	public static function sendHipChatMessage ( $ room , $ token , $ text , $ notify = true , $ format = 'text' ) { $ session = curl_init ( ) ; curl_setopt ( $ session , CURLOPT_URL , 'https://api.hipchat.com/v2/room/' . $ room . '/notification?auth_token=' . $ token ) ; curl_setopt ( $ session , CURLOPT_POST , 1 ) ; curl_setopt ( $ session , CURLOPT_POSTFIELDS , http_build_query ( [ 'message' => $ text , 'message_format' => $ format , 'notify' => $ notify , ] ) ) ; curl_setopt ( $ session , CURLOPT_RETURNTRANSFER , true ) ; curl_exec ( $ session ) ; curl_close ( $ session ) ; }
12145	public function set ( $ name , $ value = null ) { if ( $ value == null ) { return false ; } $ this -> settings [ $ name ] = $ value ; }
11474	public function setObject ( $ object ) { if ( is_null ( $ this -> _objectType ) ) { $ this -> objectType = $ object -> objectType ; } $ this -> _object = $ object ; }
3740	public function getCombinationsForUser ( $ userGroups , $ userType ) { $ userType = strtolower ( $ userType ) ; if ( 'fe' !== $ userType && 'be' !== $ userType ) { throw new \ InvalidArgumentException ( 'Unknown user type: ' . $ userType ) ; } return $ this -> getCombinationsFromDatabase ( $ userGroups , $ userType ) ; }
1961	public static function encodeEmail ( $ strEmail ) { if ( $ strEmail == '' ) { return '' ; } if ( strpos ( $ strEmail , '@' ) === false ) { return $ strEmail ; } $ arrChunks = explode ( '@' , $ strEmail ) ; $ strHost = static :: encode ( array_pop ( $ arrChunks ) ) ; if ( $ strHost == '' ) { return '' ; } return implode ( '@' , $ arrChunks ) . '@' . $ strHost ; }
2191	public function registerAlias ( Model $ objModel , $ strAlias , $ varValue ) { $ strTable = $ objModel -> getTable ( ) ; $ strPk = $ objModel -> getPk ( ) ; $ varPk = $ objModel -> $ strPk ; if ( isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ) { throw new \ RuntimeException ( "The registry already contains an alias for $strTable::$strPk($varPk) ($strAlias/$varValue)" ) ; } $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] = $ varPk ; }
1556	protected function queryRulesWithoutSearch ( ) { return collect ( $ this -> queryRules ( ) ) -> reject ( function ( $ value , $ key ) { return Str :: startsWith ( $ key , [ 'filter.' , 'sort.' , 'page.' ] ) ; } ) -> all ( ) ; }
8187	public function hasBlock ( $ name , array $ context = null , array $ blocks = array ( ) ) { if ( null === $ context ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is internal and should never be called; calling it directly is deprecated since version 1.28 and won\'t be possible anymore in 2.0.' , E_USER_DEPRECATED ) ; return isset ( $ this -> blocks [ ( string ) $ name ] ) ; } if ( isset ( $ blocks [ $ name ] ) ) { return $ blocks [ $ name ] [ 0 ] instanceof self ; } if ( isset ( $ this -> blocks [ $ name ] ) ) { return true ; } if ( false !== $ parent = $ this -> getParent ( $ context ) ) { return $ parent -> hasBlock ( $ name , $ context ) ; } return false ; }
1844	public function generateFeedsByCalendar ( $ intId ) { $ objFeed = CalendarFeedModel :: findByCalendar ( $ intId ) ; if ( $ objFeed !== null ) { while ( $ objFeed -> next ( ) ) { $ objFeed -> feedName = $ objFeed -> alias ? : 'calendar' . $ objFeed -> id ; $ this -> generateFiles ( $ objFeed -> row ( ) ) ; $ this -> log ( 'Generated calendar feed "' . $ objFeed -> feedName . '.xml"' , __METHOD__ , TL_CRON ) ; } } }
5579	public function clickImageById ( $ id , $ x = 1 , $ y = 1 , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormByImage ( new SelectById ( $ id ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitImage ( new SelectById ( $ id ) , $ x , $ y , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
1666	protected function enableTwoFactor ( BackendUser $ user , $ return ) { if ( $ user -> useTwoFactor ) { return ; } $ container = System :: getContainer ( ) ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerificationHelp' ] ; $ authenticator = $ container -> get ( 'contao.security.two_factor.authenticator' ) ; if ( Input :: post ( 'FORM_SUBMIT' ) == 'tl_two_factor' ) { if ( $ authenticator -> validateCode ( $ user , Input :: post ( 'verify' ) ) ) { $ user -> useTwoFactor = '1' ; $ user -> save ( ) ; throw new RedirectResponseException ( $ return ) ; } $ this -> Template -> error = true ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidTwoFactor' ] ; } if ( ! $ user -> secret ) { $ user -> secret = random_bytes ( 128 ) ; $ user -> save ( ) ; } $ request = $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; $ this -> Template -> enable = true ; $ this -> Template -> secret = Base32 :: encodeUpperUnpadded ( $ user -> secret ) ; $ this -> Template -> textCode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorTextCode' ] ; $ this -> Template -> qrCode = base64_encode ( $ authenticator -> getQrCode ( $ user , $ request ) ) ; $ this -> Template -> scan = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorScan' ] ; $ this -> Template -> verify = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerification' ] ; $ this -> Template -> verifyHelp = $ verifyHelp ; }
4475	public function fail ( string $ group , string $ message ) { if ( $ this -> completed || $ this -> failed ) { throw new JobAlreadyFinishedException ( ) ; } $ jsonData = json_encode ( $ this -> data , JSON_UNESCAPED_SLASHES ) ? : '{}' ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ OnFailure ( $ this , $ this , $ group , $ message ) ) ; $ this -> failed = true ; return $ this -> client -> fail ( $ this -> jid , $ this -> worker , $ group , $ message , $ jsonData ) ; }
2283	protected static function url ( ) { $ host = static :: get ( 'httpHost' ) ; $ xhost = static :: get ( 'httpXForwardedHost' ) ; if ( $ xhost != '' && $ xhost == Config :: get ( 'sslProxyDomain' ) ) { return 'https://' . $ xhost . '/' . $ host ; } return ( static :: get ( 'ssl' ) ? 'https://' : 'http://' ) . $ host ; }
2656	public function createHeader ( $ version , array $ condition ) { $ checkIfExists = $ this -> getHeader ( $ version , $ condition [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/header' ; if ( $ checkIfExists === false ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ condition [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ condition ) ; return $ result ; }
9153	public function getUrlString ( ) : string { $ query = "" ; if ( strlen ( $ this -> queryString ) > 0 ) { $ query = sprintf ( "?%s" , $ this -> queryString ) ; } if ( ( $ this -> scheme == 'http' && $ this -> getPort ( ) == 80 ) || ( $ this -> scheme == 'ftp' && $ this -> getPort ( ) == 21 ) || ( $ this -> scheme == 'https' && $ this -> getPort ( ) == 443 ) ) { return sprintf ( "%s://%s%s%s" , $ this -> scheme , $ this -> getAddress ( ) , $ this -> path , $ query ) ; } return sprintf ( "%s://%s:%d%s%s" , $ this -> scheme , $ this -> getAddress ( ) , $ this -> getPort ( ) , $ this -> path , $ query ) ; }
11354	private function generateProxy ( $ className ) { if ( isset ( $ this -> checkedClasses [ $ className ] ) ) { return $ this -> checkedClasses [ $ className ] ; } $ proxyParameters = array ( 'className' => $ className , 'factory' => get_class ( $ this ) , 'proxyManagerVersion' => Version :: VERSION ) ; $ proxyClassName = $ this -> configuration -> getClassNameInflector ( ) -> getProxyClassName ( $ className , $ proxyParameters ) ; $ this -> generateProxyClass ( $ proxyClassName , $ className , $ proxyParameters ) ; $ this -> configuration -> getSignatureChecker ( ) -> checkSignature ( new ReflectionClass ( $ proxyClassName ) , $ proxyParameters ) ; return $ this -> checkedClasses [ $ className ] = $ proxyClassName ; }
1506	protected function buildParams ( EncodingParametersInterface $ parameters ) { return array_filter ( [ QueryParametersParserInterface :: PARAM_FILTER => $ parameters -> getFilteringParameters ( ) , QueryParametersParserInterface :: PARAM_SORT => $ this -> buildSortParams ( ( array ) $ parameters -> getSortParameters ( ) ) ] ) ; }
12809	private static function isPrimaryKey ( string $ table , string $ column ) : bool { return self :: getPrimaryKey ( $ table ) [ "column_name" ] === $ column ; }
10748	protected function sendCreated ( Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { return $ this -> sendVerb ( 'created' , $ response , $ type , $ ids , $ extra ) -> withStatus ( 201 , "Created" ) ; }
12668	public function setCacheOptions ( $ cacheOptions ) { if ( $ cacheOptions instanceof CacheOptionsInterface ) { $ this -> cacheOptions = $ cacheOptions ; } elseif ( is_array ( $ cacheOptions ) ) { $ this -> cacheOptions = new CacheOptions ( $ cacheOptions ) ; } else { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be array or an instance of HtSettingsModule\Options\CacheOptionsInterface, %s provided instead' , __METHOD__ , is_object ( $ cacheOptions ) ? get_class ( $ cacheOptions ) : gettype ( $ cacheOptions ) ) ) ; } return $ this ; }
4747	public function listPlans ( array $ filters = [ ] , bool $ withAddons = true , string $ addonType = null ) : array { $ cacheKey = 'plans' ; $ hit = $ this -> getFromCache ( $ cacheKey ) ; if ( false === $ hit ) { $ response = $ this -> sendRequest ( 'GET' , 'plans' ) ; $ plans = $ this -> processResponse ( $ response ) ; $ hit = $ plans [ 'plans' ] ; $ this -> saveToCache ( $ cacheKey , $ hit ) ; } $ hit = $ this -> filterPlans ( $ hit , $ filters ) ; if ( $ withAddons ) { $ hit = $ this -> getAddonsForPlan ( $ hit , $ addonType ) ; } return $ hit ; }
5429	public function getParent ( ) { $ reflection = new ReflectionClass ( $ this -> interface ) ; $ parent = $ reflection -> getParentClass ( ) ; if ( $ parent ) { return $ parent -> getName ( ) ; } return false ; }
1540	public function withQualifiedColumn ( $ column ) { $ parts = explode ( '.' , $ column ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withColumn ( $ parts [ 1 ] ) ; return $ this ; }
554	private function notifyCachesCanBeFlushed ( $ caches ) { $ this -> stdout ( "The following caches were found in the system:\n\n" , Console :: FG_YELLOW ) ; foreach ( $ caches as $ name => $ class ) { if ( $ this -> canBeFlushed ( $ class ) ) { $ this -> stdout ( "\t* $name ($class)\n" , Console :: FG_GREEN ) ; } else { $ this -> stdout ( "\t* $name ($class) - can not be flushed via console\n" , Console :: FG_YELLOW ) ; } } $ this -> stdout ( "\n" ) ; }
5843	public function validateAdditionalFields ( array & $ submittedData , \ TYPO3 \ CMS \ Scheduler \ Controller \ SchedulerModuleController $ parentObject ) { $ result = true ; $ directories = GeneralUtility :: trimExplode ( LF , $ submittedData [ 'scheduler_batchResize_directories' ] , true ) ; foreach ( $ directories as $ directory ) { $ absoluteDirectory = GeneralUtility :: getFileAbsFileName ( $ directory ) ; if ( ! @ is_dir ( $ absoluteDirectory ) ) { $ result = false ; $ parentObject -> addMessage ( sprintf ( $ GLOBALS [ 'LANG' ] -> sL ( 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:msg.invalidDirectories' ) , $ directory ) , \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR ) ; } } $ directories = GeneralUtility :: trimExplode ( LF , $ submittedData [ 'scheduler_batchResize_excludeDirectories' ] , true ) ; foreach ( $ directories as $ directory ) { $ absoluteDirectory = GeneralUtility :: getFileAbsFileName ( $ directory ) ; if ( ! @ is_dir ( $ absoluteDirectory ) ) { $ result = false ; $ parentObject -> addMessage ( sprintf ( $ GLOBALS [ 'LANG' ] -> sL ( 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:msg.invalidExcludeDirectories' ) , $ directory ) , \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR ) ; } } return $ result ; }
1596	protected function validateAttributes ( ) : bool { if ( ! $ this -> dataHas ( 'attributes' ) ) { return true ; } $ attrs = $ this -> dataGet ( 'attributes' ) ; if ( ! is_object ( $ attrs ) ) { $ this -> memberNotObject ( '/data' , 'attributes' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ attrs ) { return property_exists ( $ attrs , $ field ) ; } ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'attributes' , $ disallowed ) ; return $ disallowed -> isEmpty ( ) ; }
623	protected function createModels ( $ rows ) { if ( $ this -> asArray ) { return $ rows ; } else { $ models = [ ] ; $ class = $ this -> modelClass ; foreach ( $ rows as $ row ) { $ model = $ class :: instantiate ( $ row ) ; $ modelClass = get_class ( $ model ) ; $ modelClass :: populateRecord ( $ model , $ row ) ; $ models [ ] = $ model ; } return $ models ; } }
11752	public function open ( $ msgId , $ index ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_OPEN_COMMENT , $ params ] ) ; }
3491	public function withHeader ( string $ name , string $ value ) : Request { $ cloned = clone $ this ; $ cloned -> headers [ $ name ] = $ value ; return $ cloned ; }
3398	private function parseStr ( $ string ) { $ params = array ( ) ; $ pairs = explode ( '&' , $ string ) ; foreach ( $ pairs as $ pair ) { if ( ! $ pair ) { continue ; } $ var = explode ( '=' , $ pair , 2 ) ; $ val = ( isset ( $ var [ 1 ] ) ? $ var [ 1 ] : '' ) ; if ( isset ( $ params [ $ var [ 0 ] ] ) ) { if ( is_array ( $ params [ $ var [ 0 ] ] ) ) { $ params [ $ var [ 0 ] ] [ ] = $ val ; } else { $ params [ $ var [ 0 ] ] = array ( $ params [ $ var [ 0 ] ] , $ val ) ; } } else { $ params [ $ var [ 0 ] ] = $ val ; } } return $ params ; }
897	private function fixTokensCompare ( Tokens $ tokens , $ startLeft , $ endLeft , $ compareOperatorIndex , $ startRight , $ endRight ) { $ type = $ tokens [ $ compareOperatorIndex ] -> getId ( ) ; $ content = $ tokens [ $ compareOperatorIndex ] -> getContent ( ) ; if ( \ array_key_exists ( $ type , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ type ] ; } elseif ( \ array_key_exists ( $ content , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ content ] ; } $ right = $ this -> fixTokensComparePart ( $ tokens , $ startRight , $ endRight ) ; $ left = $ this -> fixTokensComparePart ( $ tokens , $ startLeft , $ endLeft ) ; for ( $ i = $ startRight ; $ i <= $ endRight ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } for ( $ i = $ startLeft ; $ i <= $ endLeft ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens -> insertAt ( $ startRight , $ left ) ; $ tokens -> insertAt ( $ startLeft , $ right ) ; return $ startLeft ; }
4699	public function errorInfo ( ) { static $ statusStrings = array ( \ ZipArchive :: ER_OK => 'No error' , \ ZipArchive :: ER_MULTIDISK => 'Multi-disk zip archives not supported' , \ ZipArchive :: ER_RENAME => 'Renaming temporary file failed' , \ ZipArchive :: ER_CLOSE => 'Closing zip archive failed' , \ ZipArchive :: ER_SEEK => 'Seek error' , \ ZipArchive :: ER_READ => 'Read error' , \ ZipArchive :: ER_WRITE => 'Write error' , \ ZipArchive :: ER_CRC => 'CRC error' , \ ZipArchive :: ER_ZIPCLOSED => 'Containing zip archive was closed' , \ ZipArchive :: ER_NOENT => 'No such file' , \ ZipArchive :: ER_EXISTS => 'File already exists' , \ ZipArchive :: ER_OPEN => 'Can\'t open file' , \ ZipArchive :: ER_TMPOPEN => 'Failure to create temporary file' , \ ZipArchive :: ER_ZLIB => 'Zlib error' , \ ZipArchive :: ER_MEMORY => 'Malloc failure' , \ ZipArchive :: ER_CHANGED => 'Entry has been changed' , \ ZipArchive :: ER_COMPNOTSUPP => 'Compression method not supported' , \ ZipArchive :: ER_EOF => 'Premature EOF' , \ ZipArchive :: ER_INVAL => 'Invalid argument' , \ ZipArchive :: ER_NOZIP => 'Not a zip archive' , \ ZipArchive :: ER_INTERNAL => 'Internal error' , \ ZipArchive :: ER_INCONS => 'Zip archive inconsistent' , \ ZipArchive :: ER_REMOVE => 'Can\'t remove file' , \ ZipArchive :: ER_DELETED => 'Entry has been deleted' , ) ; if ( isset ( $ statusStrings [ $ this -> ziparchive -> status ] ) ) { $ statusString = $ statusStrings [ $ this -> ziparchive -> status ] ; } else { $ statusString = 'Unknown status' ; } return $ statusString . '(' . $ this -> ziparchive -> status . ')' ; }
7141	private function registerFactories ( ContainerBuilder $ container ) { $ defaultConfig = [ ] ; $ builder = $ container -> getDefinition ( 'payum.builder' ) ; $ builder -> addMethodCall ( 'addGatewayFactoryConfig' , [ Offline \ Constants :: FACTORY_NAME , $ defaultConfig , ] ) ; $ builder -> addMethodCall ( 'addGatewayFactory' , [ Offline \ Constants :: FACTORY_NAME , [ Offline \ OfflineGatewayFactory :: class , 'build' ] , ] ) ; $ builder -> addMethodCall ( 'addGatewayFactoryConfig' , [ Outstanding \ Constants :: FACTORY_NAME , $ defaultConfig , ] ) ; $ builder -> addMethodCall ( 'addGatewayFactory' , [ Outstanding \ Constants :: FACTORY_NAME , [ Outstanding \ OutstandingGatewayFactory :: class , 'build' ] , ] ) ; $ builder -> addMethodCall ( 'addGatewayFactoryConfig' , [ Credit \ Constants :: FACTORY_NAME , $ defaultConfig , ] ) ; $ builder -> addMethodCall ( 'addGatewayFactory' , [ Credit \ Constants :: FACTORY_NAME , [ Credit \ CreditGatewayFactory :: class , 'build' ] , ] ) ; }
3860	protected function getAttributeNames ( ) { $ arrAttributes = $ this -> objView -> getSettingNames ( ) ; $ strDesiredLanguage = $ this -> getMetaModel ( ) -> getActiveLanguage ( ) ; $ strFallbackLanguage = $ this -> getMetaModel ( ) -> getFallbackLanguage ( ) ; $ intFilterSettings = 0 ; foreach ( ( array ) $ this -> getView ( ) -> get ( 'jumpTo' ) as $ arrJumpTo ) { if ( ! $ this -> getMetaModel ( ) -> isTranslated ( ) || $ arrJumpTo [ 'langcode' ] == $ strDesiredLanguage || $ arrJumpTo [ 'langcode' ] == $ strFallbackLanguage ) { $ intFilterSettings = $ arrJumpTo [ 'filter' ] ; if ( $ strDesiredLanguage == $ arrJumpTo [ 'langcode' ] ) { break ; } } } if ( $ intFilterSettings ) { $ objFilterSettings = $ this -> getFilterFactory ( ) -> createCollection ( $ intFilterSettings ) ; $ arrAttributes = array_merge ( $ objFilterSettings -> getReferencedAttributes ( ) , $ arrAttributes ) ; } return $ arrAttributes ; }
10530	public function toJson ( $ prettyPrint = false ) { $ options = 0 ; if ( $ prettyPrint ) { $ options += JSON_PRETTY_PRINT ; } return json_encode ( $ this -> items , $ options ) ; }
6198	public function parseGets ( ) { $ request = preg_replace ( '!' . $ this -> uri . '(.*)$!i' , '$1' , $ _SERVER [ 'REQUEST_URI' ] ) ; if ( defined ( 'MOD_REWRITE' ) and MOD_REWRITE === true ) { if ( substr ( $ request , - 1 ) != '/' ) { $ request .= '/' ; } $ parseUrl = $ this -> parseUrl ( $ request ) ; $ this -> namespace = $ parseUrl [ 'v' ] [ 'namespace' ] ?? '' ; parse_str ( $ parseUrl [ 'sVars' ] , $ gets ) ; $ this -> controller = ! empty ( $ gets [ 'task' ] ) ? $ gets [ 'task' ] : $ this -> routeMap [ 'NAME_CONTROLLER' ] ; unset ( $ gets [ 'task' ] ) ; $ this -> action = ! empty ( $ gets [ 'action' ] ) ? $ gets [ 'action' ] : $ this -> routeMap [ 'NAME_METHOD' ] ; unset ( $ gets [ 'action' ] ) ; $ _GET = array_merge ( $ _GET , $ gets ) ; } else { $ this -> controller = ! empty ( $ _GET [ 'task' ] ) ? $ _GET [ 'task' ] : $ this -> routeMap [ 'NAME_CONTROLLER' ] ; $ this -> action = ! empty ( $ _GET [ 'action' ] ) ? $ _GET [ 'action' ] : $ this -> routeMap [ 'NAME_METHOD' ] ; } $ _GET [ 'task' ] = $ this -> controller ; $ _GET [ 'action' ] = $ this -> action ; }
9633	public function onBeforeWrite ( ) { $ return = parent :: onBeforeWrite ( ) ; $ exists = self :: get ( ) -> filter ( 'Name' , $ this -> Name ) -> exclude ( 'ID' , $ this -> ID ) ; if ( $ exists -> count ( ) ) { throw new ValidationException ( _t ( 'Moo_EditableField.UNIQUENAME' , 'Field name "{name}" must be unique' , '' , [ 'name' => $ this -> Name ] ) ) ; } $ this -> Name = preg_replace ( '/[^a-zA-Z0-9_]+/' , '' , $ this -> Name ) ; $ customSettings = $ this -> getSettings ( ) ; if ( empty ( $ customSettings ) ) { $ customSettings = ( array ) Controller :: curr ( ) -> getRequest ( ) -> postVar ( 'CustomSettings' ) ; } if ( ! empty ( $ this -> customSettingsFields ) ) { $ customSettings = array_intersect_key ( $ customSettings , array_flip ( ( array ) $ this -> customSettingsFields ) ) ; } $ this -> setSettings ( $ customSettings ) ; return $ return ; }
506	public function getMessageFormatter ( ) { if ( $ this -> _messageFormatter === null ) { $ this -> _messageFormatter = new MessageFormatter ( ) ; } elseif ( is_array ( $ this -> _messageFormatter ) || is_string ( $ this -> _messageFormatter ) ) { $ this -> _messageFormatter = Yii :: createObject ( $ this -> _messageFormatter ) ; } return $ this -> _messageFormatter ; }
1205	protected function renderItem ( ItemInterface $ item , array $ options ) { if ( ! $ item -> isDisplayed ( ) ) { return '' ; } $ class = ( array ) $ item -> getAttribute ( 'class' ) ; if ( $ this -> matcher -> isCurrent ( $ item ) ) { $ class [ ] = $ options [ 'currentClass' ] ; } elseif ( $ this -> matcher -> isAncestor ( $ item , $ options [ 'matchingDepth' ] ) ) { $ class [ ] = $ options [ 'ancestorClass' ] ; } if ( $ item -> actsLikeFirst ( ) ) { $ class [ ] = $ options [ 'firstClass' ] ; } if ( $ item -> actsLikeLast ( ) ) { $ class [ ] = $ options [ 'lastClass' ] ; } if ( $ item -> hasChildren ( ) && $ options [ 'depth' ] !== 0 ) { if ( null !== $ options [ 'branch_class' ] && $ item -> getDisplayChildren ( ) ) { $ class [ ] = $ options [ 'branch_class' ] ; } } elseif ( null !== $ options [ 'leaf_class' ] ) { $ class [ ] = $ options [ 'leaf_class' ] ; } $ attributes = $ item -> getAttributes ( ) ; if ( ! empty ( $ class ) ) { $ attributes [ 'class' ] = implode ( ' ' , $ class ) ; } $ html = $ this -> format ( '<li' . $ this -> renderHtmlAttributes ( $ attributes ) . '>' , 'li' , $ item -> getLevel ( ) , $ options ) ; $ html .= $ this -> renderLink ( $ item , $ options ) ; $ childrenClass = ( array ) $ item -> getChildrenAttribute ( 'class' ) ; $ childrenClass [ ] = 'menu_level_' . $ item -> getLevel ( ) ; $ childrenAttributes = $ item -> getChildrenAttributes ( ) ; $ childrenAttributes [ 'class' ] = implode ( ' ' , $ childrenClass ) ; $ html .= $ this -> renderList ( $ item , $ childrenAttributes , $ options ) ; $ html .= $ this -> format ( '</li>' , 'li' , $ item -> getLevel ( ) , $ options ) ; return $ html ; }
441	public function hasMethod ( $ name , $ checkBehaviors = true ) { if ( method_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> hasMethod ( $ name ) ) { return true ; } } } return false ; }
10399	protected function start ( InputInterface $ input , OutputInterface $ output , $ serviceClass , $ prefix ) { $ benchmark = new CommandBenchmark ( $ output ) ; $ benchmark -> start ( ) ; $ service = $ this -> getContainer ( ) -> get ( $ serviceClass ) ; $ factory = $ service -> getPipelineFactory ( ) ; $ factory -> setProgressBar ( new ProgressBar ( $ output ) ) ; $ service -> startPipeline ( $ prefix , $ input -> getArgument ( 'target' ) ) ; $ benchmark -> finish ( ) ; }
9945	private function createNewCell ( $ pCoordinate ) { $ cell = new Cell ( null , DataType :: TYPE_NULL , $ this ) ; $ this -> cellCollection -> add ( $ pCoordinate , $ cell ) ; $ this -> cellCollectionIsSorted = false ; $ aCoordinates = Coordinate :: coordinateFromString ( $ pCoordinate ) ; if ( Coordinate :: columnIndexFromString ( $ this -> cachedHighestColumn ) < Coordinate :: columnIndexFromString ( $ aCoordinates [ 0 ] ) ) { $ this -> cachedHighestColumn = $ aCoordinates [ 0 ] ; } $ this -> cachedHighestRow = max ( $ this -> cachedHighestRow , $ aCoordinates [ 1 ] ) ; $ rowDimension = $ this -> getRowDimension ( $ aCoordinates [ 1 ] , false ) ; $ columnDimension = $ this -> getColumnDimension ( $ aCoordinates [ 0 ] , false ) ; if ( $ rowDimension !== null && $ rowDimension -> getXfIndex ( ) > 0 ) { $ cell -> setXfIndex ( $ rowDimension -> getXfIndex ( ) ) ; } elseif ( $ columnDimension !== null && $ columnDimension -> getXfIndex ( ) > 0 ) { $ cell -> setXfIndex ( $ columnDimension -> getXfIndex ( ) ) ; } return $ cell ; }
3330	public function fromPath ( $ path , $ mime_type = false ) { if ( function_exists ( 'curl_file_create' ) ) { if ( $ mime_type ) { $ f = curl_file_create ( $ path , $ mime_type ) ; } else { $ f = curl_file_create ( $ path ) ; } } else { if ( $ mime_type ) { $ f = '@' . $ path . ';type=' . $ mime_type ; } else { $ f = '@' . $ path ; } } $ data = array ( 'UPLOADCARE_PUB_KEY' => $ this -> api -> getPublicKey ( ) , 'file' => $ f , ) ; $ ch = $ this -> __initRequest ( 'base' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ data = $ this -> __runRequest ( $ ch ) ; $ uuid = $ data -> file ; return new File ( $ uuid , $ this -> api ) ; }
11232	public function getLocation ( $ ip = '' , $ baseCurrency = '' , $ renameArrayKeys = false ) { $ params = [ 'ip' => ! $ ip ? $ _SERVER [ 'REMOTE_ADDR' ] : $ ip , 'base_currency' => $ baseCurrency , ] ; $ response = $ this -> client -> get ( 'json.gp' , $ params ) ; $ data = $ this -> handleResponseContent ( $ response , 'json' ) ; if ( $ renameArrayKeys ) { $ tmpData = [ ] ; foreach ( $ data as $ key => $ value ) { $ tmpData [ str_replace ( 'geoplugin_' , '' , $ key ) ] = $ value ; } $ data = $ tmpData ; } return $ data ; }
12380	public static function fromReflectionParam ( ReflectionParameter $ param , ReflectionFunctionAbstract $ func = null , Exception $ previous = null , $ afterMessage = null ) { $ message = static :: makeMessage ( $ param , $ func ) ; if ( $ previous ) { $ message .= ' - ' . $ previous -> getMessage ( ) ; } if ( $ afterMessage ) { $ message .= ' - ' . $ afterMessage ; } return new static ( $ message , 0 , $ previous ) ; }
4884	public function addDependencies ( $ name , $ entities = null , array $ options = null ) { return $ this -> dependencyResultCollection -> add ( $ name , $ entities , $ options ) ; }
9646	public function build ( ) : Route { return new $ this -> routeClass ( $ this -> methods , $ this -> path , $ this -> target , $ this -> matchers , $ this -> name ) ; }
9037	protected function update ( $ entity , $ where = null , $ tableName = null , HydratorInterface $ hydrator = null ) { if ( ! $ where ) { $ where = 'id = ' . $ entity -> getId ( ) ; } return parent :: update ( $ entity , $ where , $ tableName , $ hydrator ) ; }
4245	private function logPhpInfo ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.phpInfo' ) ) { return ; } $ this -> debug -> log ( 'PHP Version' , PHP_VERSION ) ; $ this -> debug -> log ( 'ini location' , \ php_ini_loaded_file ( ) ) ; $ this -> debug -> log ( 'memory_limit' , $ this -> debug -> utilities -> getBytes ( $ this -> debug -> utilities -> memoryLimit ( ) ) ) ; $ this -> debug -> log ( 'session.cache_limiter' , \ ini_get ( 'session.cache_limiter' ) ) ; if ( \ session_module_name ( ) === 'files' ) { $ this -> debug -> log ( 'session_save_path' , \ session_save_path ( ) ? : \ sys_get_temp_dir ( ) ) ; } $ extensionsCheck = array ( 'curl' , 'mbstring' ) ; $ extensionsCheck = \ array_filter ( $ extensionsCheck , function ( $ extension ) { return ! \ extension_loaded ( $ extension ) ; } ) ; if ( $ extensionsCheck ) { $ this -> debug -> warn ( 'These common extensions are not loaded:' , $ extensionsCheck ) ; } $ this -> logPhpInfoEr ( ) ; }
11255	public function call ( string $ class ) : void { $ files = $ this -> all ( $ class ) ; if ( count ( $ files ) < 1 ) { throw InvalidArgumentException :: forNotFoundSeeder ( ) ; } foreach ( $ files as [ $ file , $ content ] ) { $ this -> load ( $ content ) ; $ this -> resolve ( $ file [ 'filename' ] ) -> run ( ) ; } }
10486	protected function retrieveMapping ( $ table ) { $ result = $ this -> connection -> fetchAll ( 'SELECT COLUMN_NAME, ORDINAL_POSITION FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ?' , [ $ table ] ) ; if ( empty ( $ result ) ) { return false ; } $ columns = [ ] ; foreach ( $ result as $ column ) { $ columns [ $ column [ 'ORDINAL_POSITION' ] ] = $ column [ 'COLUMN_NAME' ] ; } return $ columns ; }
10851	public function executeProcess ( $ command , $ beforeNotice = false , $ afterNotice = false ) : void { $ this -> echo ( 'info' , $ beforeNotice ? ' ' . $ beforeNotice : $ command ) ; $ process = new Process ( $ command , null , null , null , $ this -> option ( 'timeout' ) , null ) ; $ process -> run ( function ( $ type , $ buffer ) { if ( Process :: ERR === $ type ) { $ this -> echo ( 'comment' , $ buffer ) ; } else { $ this -> echo ( 'line' , $ buffer ) ; } } ) ; if ( ! $ process -> isSuccessful ( ) ) { throw new ProcessFailedException ( $ process ) ; } if ( $ this -> progressBar ) { $ this -> progressBar -> advance ( ) ; } if ( $ afterNotice ) { $ this -> echo ( 'info' , $ afterNotice ) ; } }
4182	public static function instance ( ) { switch ( func_num_args ( ) ) { case func_num_args ( ) == 0 : return new static ( ) ; case func_num_args ( ) == 1 : return new static ( func_get_arg ( 0 ) ) ; case func_num_args ( ) == 2 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) ) ; case func_num_args ( ) == 3 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) ) ; case func_num_args ( ) == 4 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) ) ; case func_num_args ( ) == 5 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) , func_get_arg ( 4 ) ) ; default : throw new Exception ( 'Unable to instantiate class with given arguments' ) ; } }
1258	private function makeVar ( $ prefix ) { if ( ! isset ( $ this -> vars [ $ prefix ] ) ) { $ this -> vars [ $ prefix ] = 0 ; return '$' . $ prefix ; } return '$' . $ prefix . ++ $ this -> vars [ $ prefix ] ; }
6132	protected function getSuffixFlag ( ) { if ( ! $ this -> currObj instanceof Client ) { return "" ; } if ( $ this -> flagpath && $ this -> currObj [ "client_country" ] ) { return $ this -> getImage ( $ this -> currObj [ "client_country" ] -> toLower ( ) . ".png" , $ this -> currObj [ "client_country" ] , null , false , true ) ; } return "" ; }
11309	protected function populateStub ( string $ stub , ? string $ class = null ) : string { return str_replace ( '{class}' , $ this -> getName ( $ class ) , $ stub ) ; }
4474	public function perform ( ) : bool { try { $ instance = $ this -> getInstance ( ) ; if ( method_exists ( $ instance , 'setUp' ) ) { $ instance -> setUp ( ) ; } $ this -> getEventsManager ( ) -> fire ( new JobEvent \ BeforePerform ( $ this , $ this ) ) ; $ performMethod = $ this -> getPerformMethod ( ) ; $ instance -> $ performMethod ( $ this ) ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ AfterPerform ( $ this , $ this ) ) ; if ( method_exists ( $ instance , 'tearDown' ) ) { $ instance -> tearDown ( ) ; } } catch ( \ Throwable $ e ) { $ this -> fail ( 'system:fatal' , sprintf ( '%s: %s in %s on line %d' , get_class ( $ e ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) ) ) ; return false ; } return true ; }
6144	public function hasQueryVar ( $ key ) { if ( ! $ this -> hasQuery ( ) ) { return false ; } parse_str ( $ this -> query , $ queryArray ) ; return array_key_exists ( $ key , $ queryArray ) ? true : false ; }
6888	protected function createErrorException ( ResponseInterface $ response ) { $ body = json_decode ( $ response -> getBody ( ) , true ) ; $ message = "HTTP:{$response->getStatusCode()} - " ; $ message .= ( is_array ( $ body ) ) ? print_r ( $ body , true ) : 'Unexpected response from server' ; return new Exception \ ApiException ( $ message , $ response -> getStatusCode ( ) , $ response ) ; }
9242	private function __next ( ServerRequestInterface $ request , ResponseInterface $ response , $ next ) { $ this -> __loadConfigFiles ( ) ; return $ next ( $ request , $ response ) ; }
6271	protected function throwException ( $ msg ) { if ( $ this -> handle ) { fclose ( $ this -> handle ) ; unlink ( $ this -> tmpFileName ) ; } throw new Exception ( $ msg ) ; }
7289	protected function watch ( OrderInterface $ order ) { if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( $ order -> hasNotifications ( NotificationTypes :: ORDER_ACCEPTED ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ order , OrderStates :: STATE_ACCEPTED ) ) { return ; } $ this -> notify ( NotificationTypes :: ORDER_ACCEPTED , $ order ) ; }
12861	private function buildCache ( ) : array { $ dispatchData = $ this -> routeCollector -> getData ( ) ; file_put_contents ( $ this -> cacheFile , '<?php return ' . var_export ( $ dispatchData , true ) . ';' ) ; return $ dispatchData ; }
602	public function tokenize ( ) { $ this -> length = mb_strlen ( $ this -> sql , 'UTF-8' ) ; $ this -> offset = 0 ; $ this -> _substrings = [ ] ; $ this -> _buffer = '' ; $ this -> _token = new SqlToken ( [ 'type' => SqlToken :: TYPE_CODE , 'content' => $ this -> sql , ] ) ; $ this -> _tokenStack = new \ SplStack ( ) ; $ this -> _tokenStack -> push ( $ this -> _token ) ; $ this -> _token [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_STATEMENT ] ) ; $ this -> _tokenStack -> push ( $ this -> _token [ 0 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; while ( ! $ this -> isEof ( ) ) { if ( $ this -> isWhitespace ( $ length ) || $ this -> isComment ( $ length ) ) { $ this -> addTokenFromBuffer ( ) ; $ this -> advance ( $ length ) ; continue ; } if ( $ this -> tokenizeOperator ( $ length ) || $ this -> tokenizeDelimitedString ( $ length ) ) { $ this -> advance ( $ length ) ; continue ; } $ this -> _buffer .= $ this -> substring ( 1 ) ; $ this -> advance ( 1 ) ; } $ this -> addTokenFromBuffer ( ) ; if ( $ this -> _token -> getHasChildren ( ) && ! $ this -> _token [ - 1 ] -> getHasChildren ( ) ) { unset ( $ this -> _token [ - 1 ] ) ; } return $ this -> _token ; }
5584	public function click ( $ label ) { $ raw = $ this -> clickSubmit ( $ label ) ; if ( ! $ raw ) { $ raw = $ this -> clickLink ( $ label ) ; } if ( ! $ raw ) { $ raw = $ this -> clickImage ( $ label ) ; } return $ raw ; }
710	public function tinyInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TINYINT , $ length ) ; }
9265	public function setProviders ( ) { $ services = $ this -> container [ 'services' ] ?? null ; if ( is_array ( $ services ) ) { foreach ( $ services as $ service ) { $ service :: register ( $ this -> container ) ; $ service :: boot ( $ this -> container ) ; } } }
9826	private function writeRelationship ( XMLWriter $ objWriter , $ pId , $ pType , $ pTarget , $ pTargetMode = '' ) { if ( $ pType != '' && $ pTarget != '' ) { $ objWriter -> startElement ( 'Relationship' ) ; $ objWriter -> writeAttribute ( 'Id' , 'rId' . $ pId ) ; $ objWriter -> writeAttribute ( 'Type' , $ pType ) ; $ objWriter -> writeAttribute ( 'Target' , $ pTarget ) ; if ( $ pTargetMode != '' ) { $ objWriter -> writeAttribute ( 'TargetMode' , $ pTargetMode ) ; } $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
6561	public static function getRelativePath ( $ path , $ start = null ) { if ( $ start === null ) { $ start = getcwd ( ) ; } if ( substr ( $ path , 0 , 1 ) !== '/' || substr ( $ start , 0 , 1 ) !== '/' ) { return false ; } $ pathParts = self :: splitPath ( $ path ) ; $ countPathParts = count ( $ pathParts ) ; $ startParts = self :: splitPath ( $ start ) ; $ countStartParts = count ( $ startParts ) ; $ commonLength = min ( $ countPathParts , $ countStartParts ) ; for ( $ i = 0 ; $ i < $ commonLength ; $ i ++ ) { if ( $ startParts [ $ i ] !== $ pathParts [ $ i ] ) { break ; } } $ relList = ( $ countStartParts > $ i ) ? array_fill ( 0 , $ countStartParts - $ i , '..' ) : [ ] ; $ relList = array_merge ( $ relList , array_slice ( $ pathParts , $ i ) ) ; return implode ( '/' , $ relList ) ? : '.' ; }
8842	private function stringToArray ( string $ string ) : array { $ lines = preg_split ( '/\R/' , $ string ) ; if ( 1 === count ( $ lines ) && '' === $ lines [ 0 ] ) { $ lines = [ ] ; } return $ lines ; }
3687	protected function getAttributeFromFilterOperation ( $ operation ) { $ attribute = null ; if ( ! empty ( $ operation [ 'property' ] ) ) { $ attribute = $ this -> getMetaModel ( ) -> getAttribute ( $ operation [ 'property' ] ) ; } if ( $ attribute === null ) { throw new \ InvalidArgumentException ( 'Attribute ' . $ operation [ 'property' ] . ' not found.' ) ; } return $ attribute ; }
7537	function clear ( ) { foreach ( $ this -> children as $ c ) { $ c -> parent = null ; $ c -> delete ( ) ; } $ this -> children = array ( ) ; }
12141	public function SignupUser ( $ moniker , $ mailer_id = null ) { $ endpoint = '/user/signup' ; $ postdata = array ( "moniker" => $ moniker , "mailer_id" => $ mailer_id ) ; return $ this -> executePostRequest ( $ endpoint , $ postdata ) ; }
6939	private function push ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( ! $ this -> has ( $ list , $ oid , $ unit ) ) { $ list [ $ oid ] [ ] = $ unit ; } }
12673	public function setSourceFiles ( $ value ) { foreach ( $ value as $ key => $ settings ) { if ( $ settings === false ) { $ this -> _sourceFiles [ $ key ] = false ; continue ; } if ( ! isset ( $ settings [ 'class' ] ) ) { $ settings [ 'class' ] = $ this -> sourceFileClass ; } $ settings [ 'id' ] = $ key ; $ this -> _sourceFiles [ $ key ] = Yii :: createObject ( $ settings ) ; } }
11343	public function addField ( FormField $ field ) { $ this -> fields [ ] = $ field ; if ( $ field -> getName ( ) == null ) { $ field -> setName ( 'name_' . count ( $ this -> fields ) ) ; } if ( $ field -> getId ( ) == null ) { $ field -> setId ( 'id_' . count ( $ this -> fields ) ) ; } if ( $ field instanceof FileField ) { $ this -> formTags [ 'enctype' ] = 'multipart/form-data' ; } }
9989	public function generateNavigation ( ) { if ( $ this -> spreadsheet === null ) { throw new WriterException ( 'Internal Spreadsheet object not set to an instance of an object.' ) ; } $ sheets = [ ] ; if ( $ this -> sheetIndex === null ) { $ sheets = $ this -> spreadsheet -> getAllSheets ( ) ; } else { $ sheets [ ] = $ this -> spreadsheet -> getSheet ( $ this -> sheetIndex ) ; } $ html = '' ; if ( count ( $ sheets ) > 1 ) { $ sheetId = 0 ; $ html .= '<ul class="navigation">' . PHP_EOL ; foreach ( $ sheets as $ sheet ) { $ html .= ' <li class="sheet' . $ sheetId . '"><a href="#sheet' . $ sheetId . '">' . $ sheet -> getTitle ( ) . '</a></li>' . PHP_EOL ; ++ $ sheetId ; } $ html .= '</ul>' . PHP_EOL ; } return $ html ; }
9814	public function addEntriesToBlacklist ( $ id , $ entries , $ importName = null ) { if ( $ importName == null ) { $ importName = "phpclient_import_" . uniqid ( ) ; } $ action = new AddEntriesAction ( ) ; $ action -> importName = $ importName ; $ action -> entries = $ entries ; return $ this -> post ( "blacklists/" . $ id . "/actions" , $ action -> toXMLString ( ) ) ; }
899	public function getImportUseIndexes ( $ perNamespace = false ) { $ tokens = $ this -> tokens ; $ tokens -> rewind ( ) ; $ uses = [ ] ; $ namespaceIndex = 0 ; for ( $ index = 0 , $ limit = $ tokens -> count ( ) ; $ index < $ limit ; ++ $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( T_NAMESPACE ) ) { $ nextTokenIndex = $ tokens -> getNextTokenOfKind ( $ index , [ ';' , '{' ] ) ; $ nextToken = $ tokens [ $ nextTokenIndex ] ; if ( $ nextToken -> equals ( '{' ) ) { $ index = $ nextTokenIndex ; } if ( $ perNamespace ) { ++ $ namespaceIndex ; } continue ; } if ( $ token -> isGivenKind ( T_USE ) ) { $ uses [ $ namespaceIndex ] [ ] = $ index ; } } if ( ! $ perNamespace && isset ( $ uses [ $ namespaceIndex ] ) ) { return $ uses [ $ namespaceIndex ] ; } return $ uses ; }
2408	public function flushAllData ( ) { @ trigger_error ( 'Using Template::flushAllData() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ function_exists ( 'fastcgi_finish_request' ) ) { fastcgi_finish_request ( ) ; } elseif ( PHP_SAPI !== 'cli' ) { $ status = ob_get_status ( true ) ; $ level = \ count ( $ status ) ; while ( $ level -- > 0 && ( ! empty ( $ status [ $ level ] [ 'del' ] ) || ( isset ( $ status [ $ level ] [ 'flags' ] ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_REMOVABLE ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_FLUSHABLE ) ) ) ) { ob_end_flush ( ) ; } flush ( ) ; } }
1848	protected function getMetaFields ( $ objArticle ) { $ meta = StringUtil :: deserialize ( $ this -> news_metaFields ) ; if ( ! \ is_array ( $ meta ) ) { return array ( ) ; } global $ objPage ; $ return = array ( ) ; foreach ( $ meta as $ field ) { switch ( $ field ) { case 'date' : $ return [ 'date' ] = Date :: parse ( $ objPage -> datimFormat , $ objArticle -> date ) ; break ; case 'author' : if ( ( $ objAuthor = $ objArticle -> getRelated ( 'author' ) ) instanceof UserModel ) { $ return [ 'author' ] = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'by' ] . ' <span itemprop="author">' . $ objAuthor -> name . '</span>' ; } break ; case 'comments' : if ( $ objArticle -> noComments || $ objArticle -> source != 'default' ) { break ; } $ bundles = System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( ! isset ( $ bundles [ 'ContaoCommentsBundle' ] ) ) { break ; } $ intTotal = CommentsModel :: countPublishedBySourceAndParent ( 'tl_news' , $ objArticle -> id ) ; $ return [ 'ccount' ] = $ intTotal ; $ return [ 'comments' ] = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'commentCount' ] , $ intTotal ) ; break ; } } return $ return ; }
4780	public function clearWidgetCache ( ) { $ widgets = $ this -> getWidgets ( false ) ; $ userId = $ this -> token -> getToken ( ) -> getUser ( ) -> getId ( ) ; foreach ( $ widgets as $ widget ) { $ this -> cache -> deleteItem ( $ widget -> getId ( ) . $ userId ) ; } }
4530	public function setUserUuid ( ? string $ userUuid ) { if ( null !== $ userUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ userUuid ) ) { throw new InvalidArgumentException ( 'Uuid is not valid.' ) ; } } $ this -> userUuid = $ userUuid ; return $ this ; }
7066	public function getUserRights ( ) { if ( ! $ this -> _UserRights ) { if ( Configure :: load ( 'user_rights' ) === false ) { trigger_error ( 'UserRights: Could not load config/user_rights.php' , E_USER_WARNING ) ; } $ rightsConfig = Configure :: read ( 'user_rights' ) ; if ( ! is_array ( $ rightsConfig ) ) { $ rightsConfig = [ ] ; } $ this -> _UserRights = new UserRights ( $ rightsConfig ) ; } return $ this -> _UserRights ; }
694	public function sendMultiple ( array $ messages ) { $ successCount = 0 ; foreach ( $ messages as $ message ) { if ( $ this -> send ( $ message ) ) { $ successCount ++ ; } } return $ successCount ; }
699	public function actionApp ( $ app , $ repo = null ) { $ base = \ dirname ( \ dirname ( __DIR__ ) ) ; $ appDir = "$base/apps/$app" ; if ( ! file_exists ( $ appDir ) ) { if ( empty ( $ repo ) ) { if ( isset ( $ this -> apps [ $ app ] ) ) { $ repo = $ this -> apps [ $ app ] ; if ( $ this -> useHttp ) { $ repo = str_replace ( 'git@github.com:' , 'https://github.com/' , $ repo ) ; } } else { $ this -> stderr ( "Repo argument is required for app '$app'.\n" , Console :: FG_RED ) ; return 1 ; } } $ this -> stdout ( "cloning application repo '$app' from '$repo'...\n" , Console :: BOLD ) ; passthru ( 'git clone ' . escapeshellarg ( $ repo ) . ' ' . $ appDir ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } $ this -> stdout ( "cleaning up application '$app' vendor directory...\n" , Console :: BOLD ) ; $ this -> cleanupVendorDir ( $ appDir ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; $ this -> stdout ( "updating composer for app '$app'...\n" , Console :: BOLD ) ; chdir ( $ appDir ) ; $ command = 'composer update --prefer-dist' ; if ( $ this -> composerNoProgress ) { $ command .= ' --no-progress' ; } passthru ( $ command ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; $ this -> stdout ( "linking framework and extensions to '$app' app vendor dir...\n" , Console :: BOLD ) ; $ this -> linkFrameworkAndExtensions ( $ appDir , $ base ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; return 0 ; }
3824	protected function getFilterParameters ( $ objItemRenderer ) { $ filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; $ filterUrl = $ filterUrlBuilder -> getCurrentFilterUrl ( ) ; $ result = [ ] ; foreach ( $ objItemRenderer -> getFilterSettings ( ) -> getParameters ( ) as $ name ) { if ( $ filterUrl -> hasSlug ( $ name ) ) { $ result [ $ name ] = $ filterUrl -> getSlug ( $ name ) ; } Input :: get ( $ name ) ; } return $ filterUrl -> getSlugParameters ( ) ; }
9817	public function setView ( $ pValue ) { if ( $ pValue === null ) { $ pValue = self :: SHEETVIEW_NORMAL ; } if ( in_array ( $ pValue , self :: $ sheetViewTypes ) ) { $ this -> sheetviewType = $ pValue ; } else { throw new PhpSpreadsheetException ( 'Invalid sheetview layout type.' ) ; } return $ this ; }
10606	public function addHeader ( string $ header , $ value ) : void { if ( is_iterable ( $ value ) || is_array ( $ value ) ) { $ iterable = $ value ; $ value = [ ] ; foreach ( $ iterable as $ key => $ entry ) { $ value [ $ key ] = ( string ) $ entry ; } } else { $ value = ( string ) $ value ; } $ this -> headers [ ] = [ $ header , $ value ] ; }
3908	public function setAcceptedExtensions ( $ acceptedExtensions ) { $ allowedDownload = StringUtil :: trimsplit ( ',' , $ GLOBALS [ 'TL_CONFIG' ] [ 'allowedDownload' ] ) ; if ( ! is_array ( $ acceptedExtensions ) ) { $ acceptedExtensions = StringUtil :: trimsplit ( ',' , $ acceptedExtensions ) ; } $ this -> acceptedExtensions = array_map ( 'strtolower' , array_intersect ( $ allowedDownload , $ acceptedExtensions ) ) ; }
1331	public function queryToOne ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; }
5924	public function setFilterItems ( array $ filterItems ) { $ this -> filterItems = [ ] ; foreach ( $ filterItems as $ item ) { $ this -> addFilterItem ( $ item ) ; } return $ this ; }
6695	public static function applyVisible ( & $ Nav ) { if ( $ Nav ) { foreach ( $ Nav as & $ one ) { if ( ! isset ( $ one [ 'visible' ] ) ) { if ( isset ( $ one [ 'permission' ] ) ) { $ authItemModel = Yii :: createObject ( AuthItem :: class ) ; $ one [ 'visible' ] = Yii :: $ app -> user -> can ( $ authItemModel :: SUPER_ADMIN ) || Yii :: $ app -> user -> can ( $ one [ 'permission' ] ) ; } else { if ( is_array ( $ one [ 'url' ] ) ) { $ url = explode ( '/' , trim ( $ one [ 'url' ] [ 0 ] , '/' ) ) ; if ( isset ( $ url [ '0' ] ) && isset ( $ url [ '1' ] ) ) { $ one [ 'visible' ] = Yii :: $ app -> user -> can ( 'Super admin' ) || Yii :: $ app -> user -> can ( $ url [ 0 ] . '/' . $ url [ 1 ] ) ; } } } } if ( isset ( $ one [ 'items' ] ) ) { self :: applyVisible ( $ one [ 'items' ] ) ; } } } }
6266	public function reject ( Exception $ exception ) { if ( HttpPromise :: PENDING !== $ this -> state ) { throw new \ RuntimeException ( 'Promise is already resolved' ) ; } $ this -> state = HttpPromise :: REJECTED ; $ this -> exception = $ exception ; $ this -> doReject ( $ exception ) ; }
2976	public function serialize ( ) { try { $ this -> data = $ this -> data ? : $ this -> serializer -> getData ( $ this -> closure , true ) ; return serialize ( $ this -> data ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Serialization of closure failed: ' . $ e -> getMessage ( ) , E_USER_NOTICE ) ; return null ; } }
2320	public static function create ( $ image , $ size = null ) { @ trigger_error ( 'Using Image::create() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; if ( \ is_string ( $ image ) ) { $ image = new File ( rawurldecode ( $ image ) ) ; } $ imageObj = new static ( $ image ) ; if ( \ is_array ( $ size ) && ! empty ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ size = ( int ) $ size [ 2 ] ; } if ( \ is_array ( $ size ) ) { $ size += array ( 0 , 0 , 'crop' ) ; $ imageObj -> setTargetWidth ( $ size [ 0 ] ) -> setTargetHeight ( $ size [ 1 ] ) -> setResizeMode ( $ size [ 2 ] ) ; } elseif ( ( $ imageSize = ImageSizeModel :: findByPk ( $ size ) ) !== null ) { $ imageObj -> setTargetWidth ( $ imageSize -> width ) -> setTargetHeight ( $ imageSize -> height ) -> setResizeMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; } $ fileRecord = FilesModel :: findByPath ( $ image -> path ) ; if ( $ fileRecord !== null && $ fileRecord -> importantPartWidth && $ fileRecord -> importantPartHeight ) { $ imageObj -> setImportantPart ( array ( 'x' => ( int ) $ fileRecord -> importantPartX , 'y' => ( int ) $ fileRecord -> importantPartY , 'width' => ( int ) $ fileRecord -> importantPartWidth , 'height' => ( int ) $ fileRecord -> importantPartHeight , ) ) ; } return $ imageObj ; }
7232	public static function createFromCurrency ( $ currency , $ code = 0 , \ Exception $ prev = null ) { $ message = sprintf ( 'Not found prices by currency "%s".' , $ currency ) ; return new static ( $ message , $ code , $ prev ) ; }
8108	public function getReviewFrom ( ) { $ from = $ this -> owner -> getField ( 'ReviewFrom' ) ; if ( $ from ) { return $ from ; } return Config :: inst ( ) -> get ( Email :: class , 'admin_email' ) ; }
4683	public static function stop ( $ key = 'default' ) : void { if ( isset ( self :: $ timers [ $ key ] ) ) { self :: $ timers [ $ key ] -> stop ( ) ; } else { throw new \ LogicException ( 'Stopping timer when the given key timer was not initialized.' ) ; } }
9275	public function onBootstrap ( MvcEvent $ event ) { $ eventManager = $ event -> getApplication ( ) -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; }
12139	public function renderWidget ( array $ fields , $ customFielsGroup , $ documentType = 'html' , array $ params = array ( ) ) { $ resolvedParams = array_merge ( $ this -> defaultParams , $ params ) ; return $ this -> container -> get ( 'templating' ) -> render ( $ resolvedParams [ 'layout' ] , array ( 'cFGroup' => $ customFielsGroup , 'cFData' => $ fields , 'show_empty' => $ resolvedParams [ 'show_empty' ] ) ) ; }
542	protected function serializeModels ( array $ models ) { list ( $ fields , $ expand ) = $ this -> getRequestedFields ( ) ; foreach ( $ models as $ i => $ model ) { if ( $ model instanceof Arrayable ) { $ models [ $ i ] = $ model -> toArray ( $ fields , $ expand ) ; } elseif ( is_array ( $ model ) ) { $ models [ $ i ] = ArrayHelper :: toArray ( $ model ) ; } } return $ models ; }
1291	public function continueSync ( $ token ) : Result { if ( $ token instanceof Result ) { if ( ! $ this -> isDeliveryApi && $ token -> isDone ( ) ) { throw new \ RuntimeException ( 'Can not continue syncing when using the Content Preview API.' ) ; } $ token = $ token -> getToken ( ) ; } $ response = $ this -> client -> syncRequest ( [ 'sync_token' => $ token ] ) ; return $ this -> buildResult ( $ response ) ; }
4476	public function track ( ) : void { if ( $ this -> client -> call ( 'track' , 'track' , $ this -> jid ) ) { $ this -> tracked = true ; } }
6497	public function iSwitchToWindow ( ) { $ windows = $ this -> getWindowNames ( ) ; if ( empty ( $ this -> mainWindow ) ) { $ this -> mainWindow [ 'name' ] = array_shift ( $ windows ) ; $ this -> mainWindow [ 'element' ] = $ this -> getWorkingElement ( ) ; $ window = reset ( $ windows ) ; } else { $ window = $ this -> mainWindow [ 'name' ] ; $ element = $ this -> mainWindow [ 'element' ] ; $ this -> mainWindow = [ ] ; } $ this -> getSession ( ) -> switchToWindow ( $ window ) ; $ this -> setWorkingElement ( isset ( $ element ) ? $ element : $ this -> getBodyElement ( ) ) ; }
10279	public static function coordinateFromString ( $ pCoordinateString ) { if ( preg_match ( '/^([$]?[A-Z]{1,3})([$]?\\d{1,7})$/' , $ pCoordinateString , $ matches ) ) { return [ $ matches [ 1 ] , $ matches [ 2 ] ] ; } elseif ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } elseif ( $ pCoordinateString == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string' ) ; } throw new Exception ( 'Invalid cell coordinate ' . $ pCoordinateString ) ; }
12168	public function createPropertyValuesProxyTable ( $ group , $ dropExisting = true ) { $ group = strtolower ( $ group ) ; if ( ! empty ( $ group ) ) : $ this -> database -> query ( "DROP TABLE IF EXISTS `?{$group}_property_values`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?{$group}_property_values` ( `value_id` mediumint(11) NOT NULL AUTO_INCREMENT, `value_data` text NOT NULL, `value_updated_on` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `property_id` int(11) NOT NULL, `object_id` int(11) NOT NULL, PRIMARY KEY (`value_id`), UNIQUE KEY `object_property_uid` (`object_id`,`property_id`), KEY `property_id_idxfk` (`property_id`), KEY `object_id_idxfk` (`object_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?{$group}_property_value_validate_insert`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?{$group}_property_value_validate_insert` BEFORE INSERT ON `?{$group}_property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?{$group}_property_value_validate_update`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?{$group}_property_value_validate_update` BEFORE UPDATE ON `?{$group}_property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "ALTER TABLE `?{$group}_property_values` ADD CONSTRAINT `{$group}_property_values_ibfk_1` FOREIGN KEY (`object_id`) REFERENCES `?objects` (`object_id`), ADD CONSTRAINT `{$group}_property_values_ibfk_2` FOREIGN KEY (`property_id`) REFERENCES `?properties` (`property_id`) ON DELETE CASCADE;" ) ; endif ; }
7519	function parse_doctype ( ) { $ start = $ this -> pos ; if ( $ this -> next_search ( '[>' , false ) === self :: TOK_UNKNOWN ) { if ( $ this -> doc [ $ this -> pos ] === '[' ) { if ( ( $ this -> next_pos ( ']' , false ) !== self :: TOK_UNKNOWN ) || ( $ this -> next_pos ( '>' , false ) !== self :: TOK_UNKNOWN ) ) { $ this -> addError ( 'Invalid doctype' ) ; return false ; } } $ this -> token_start = $ start ; $ this -> status [ 'dtd' ] = $ this -> getTokenString ( 2 , - 1 ) ; $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; } else { $ this -> addError ( 'Invalid doctype' ) ; return false ; } }
4861	public function pushLazy ( $ service , $ payload = null , array $ options = [ ] ) { $ manager = $ this -> getJobPluginManager ( ) ; $ serviceOptions = [ ] ; if ( is_array ( $ service ) ) { $ serviceOptions = $ service [ 'options' ] ?? $ service [ 1 ] ?? [ ] ; $ service = $ service [ 'name' ] ?? $ service [ 0 ] ?? null ; } if ( ! $ manager -> has ( $ service ) && ! class_exists ( $ service ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Service name "%s" is not a known job service or existent class' , $ service ) ) ; } $ lazyOptions = [ 'name' => $ service , 'options' => $ serviceOptions , 'content' => $ payload , ] ; $ job = $ this -> getJobPluginManager ( ) -> build ( 'lazy' , $ lazyOptions ) ; $ this -> push ( $ job , $ options ) ; }
7229	public static function create ( $ method , $ url , $ data = "" , array $ headers = [ ] , array $ options = [ ] , $ initOnly = false ) { $ curl = null ; if ( ! strcasecmp ( $ method , "GET" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "GET" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "POST" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "POST" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "PUT" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "PUT" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "DELETE" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "DELETE" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; return $ curl ; }
6955	private function getTaxesRates ( ShipmentMethodInterface $ method , CountryInterface $ country ) { return array_map ( function ( TaxInterface $ tax ) { return $ tax -> getRate ( ) ; } , $ this -> taxResolver -> resolveTaxes ( $ method , $ country ) ) ; }
659	public function noCache ( callable $ callable ) { $ this -> _queryCacheInfo [ ] = false ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
874	public function getAnnotationsOfType ( $ types ) { $ annotations = [ ] ; $ types = ( array ) $ types ; foreach ( $ this -> getAnnotations ( ) as $ annotation ) { $ tag = $ annotation -> getTag ( ) -> getName ( ) ; foreach ( $ types as $ type ) { if ( $ type === $ tag ) { $ annotations [ ] = $ annotation ; } } } return $ annotations ; }
7137	private function readNumber ( ) { if ( false === $ this -> handle = fopen ( $ this -> filePath , 'c+' ) ) { throw new RuntimeException ( "Failed to open file {$this->filePath}." ) ; } if ( ! flock ( $ this -> handle , LOCK_EX ) ) { throw new RuntimeException ( "Failed to lock file {$this->filePath}." ) ; } return fread ( $ this -> handle , $ this -> length ) ; }
12977	protected function getComponentDefaults ( $ mappingName , array $ mappingConfig ) { if ( strpos ( $ mappingName , '::' ) ) { list ( $ componentName , $ componentType ) = explode ( '::' , $ mappingName ) ; } else { $ componentName = $ mappingName ; $ componentType = $ this -> detectComponentType ( $ componentName ) ; if ( $ componentType === false and $ componentName === 'app' ) { $ componentType = 'app' ; } } if ( ( $ componentPath = $ this -> getComponentPath ( $ componentName , $ componentType ) ) === false ) { return false ; } $ configPath = $ mappingConfig [ 'dir' ] ; if ( $ configPath === false ) { $ configPath = $ this -> getConfigPath ( ) ; } if ( $ mappingConfig [ 'type' ] === false ) { $ mappingConfig [ 'type' ] = $ this -> detectMetadataDriver ( $ componentPath , $ configPath ) ; } if ( $ mappingConfig [ 'type' ] === false ) { return false ; } if ( $ mappingConfig [ 'dir' ] === false ) { if ( in_array ( $ mappingConfig [ 'type' ] , array ( 'annotation' , 'staticphp' ) ) ) { $ mappingConfig [ 'dir' ] = $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ; } else { $ mappingConfig [ 'dir' ] = $ configPath ; } } if ( is_array ( $ mappingConfig [ 'dir' ] ) ) { foreach ( $ mappingConfig [ 'dir' ] as & $ path ) { $ path = $ componentPath . $ path ; } } else { $ mappingConfig [ 'dir' ] = $ componentPath . $ mappingConfig [ 'dir' ] ; } if ( $ mappingConfig [ 'prefix' ] === false ) { $ mappingConfig [ 'prefix' ] = $ this -> detectComponentNamespace ( $ componentName , $ componentType ) ; } $ mappingConfig [ 'is_component' ] = false ; return $ mappingConfig ; }
1854	public static function findCurrentByPid ( $ intPid , $ intStart , $ intEnd , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ intStart = ( int ) $ intStart ; $ intEnd = ( int ) $ intEnd ; $ arrColumns = array ( "$t.pid=? AND (($t.startTime>=$intStart AND $t.startTime<=$intEnd) OR ($t.endTime>=$intStart AND $t.endTime<=$intEnd) OR ($t.startTime<=$intStart AND $t.endTime>=$intEnd) OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$intStart) AND $t.startTime<=$intEnd))" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
8709	protected function qualifyColumns ( $ columns ) { foreach ( $ columns as & $ column ) { if ( ! in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { continue ; } $ primary = $ this -> qualifyTranslationColumn ( $ column ) ; $ fallback = $ this -> qualifyTranslationColumn ( $ column , true ) ; if ( $ this -> model -> shouldFallback ( ) ) { $ column = new Expression ( $ this -> compileIfNull ( $ primary , $ fallback , $ column ) ) ; } else { $ column = $ primary ; } } return $ columns ; }
10018	public function removeNamedRange ( $ namedRange , Worksheet $ pSheet = null ) { if ( $ pSheet === null ) { if ( isset ( $ this -> namedRanges [ $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ namedRange ] ) ; } } else { if ( isset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ; } } return $ this ; }
7217	public function getDocumentationClassesList ( ) : array { $ classNames = $ this -> getCmfConfig ( ) -> config ( 'api_documentation.classes' , [ ] ) ; if ( empty ( $ classNames ) ) { $ classNames = $ this -> loadClassesFromFileSystem ( ) ; } return $ classNames ; }
917	public static function stableSort ( array $ elements , callable $ getComparedValue , callable $ compareValues ) { array_walk ( $ elements , static function ( & $ element , $ index ) use ( $ getComparedValue ) { $ element = [ $ element , $ index , $ getComparedValue ( $ element ) ] ; } ) ; usort ( $ elements , static function ( $ a , $ b ) use ( $ compareValues ) { $ comparison = $ compareValues ( $ a [ 2 ] , $ b [ 2 ] ) ; if ( 0 !== $ comparison ) { return $ comparison ; } return self :: cmpInt ( $ a [ 1 ] , $ b [ 1 ] ) ; } ) ; return array_map ( static function ( array $ item ) { return $ item [ 0 ] ; } , $ elements ) ; }
11588	public function duration ( ) { $ duration = 0 ; foreach ( $ this -> _tasks as $ task ) { $ duration += $ task -> duration ( ) ; } return $ duration ; }
4590	public function exists ( $ form , Parameters $ parameters = null ) : bool { $ object = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c6f7311000029066df850' ) ; if ( $ object && property_exists ( $ object , '_id' ) && $ object -> _id ) { return true ; } return false ; }
8115	public function advanceReviewDate ( ) { $ nextDateTimestamp = false ; $ options = $ this -> getOptions ( ) ; if ( $ options && $ options -> ReviewPeriodDays ) { $ nextDateTimestamp = strtotime ( ' + ' . $ options -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ this -> owner -> NextReviewDate = DBDate :: create ( ) -> setValue ( $ nextDateTimestamp ) -> Format ( DBDate :: ISO_DATE ) ; $ this -> owner -> write ( ) ; } return ( bool ) $ nextDateTimestamp ; }
7966	public function getProperties ( $ billingAccount ) { if ( ! $ billingAccount ) throw new BadMethodCallException ( 'Parameter $billingAccount is missing.' ) ; try { $ r = $ this -> get ( 'telephony/' . $ billingAccount ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new TelephonyException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
9553	public function allowExtensions ( $ extensions ) { if ( ! is_array ( $ extensions ) ) { $ extensions = [ $ extensions ] ; } $ this -> constraints [ ] = new ExtensionConstraint ( $ extensions ) ; return $ this ; }
9901	public function parse ( $ formula ) { $ this -> currentCharacter = 0 ; $ this -> formula = $ formula ; $ this -> lookAhead = isset ( $ formula [ 1 ] ) ? $ formula [ 1 ] : '' ; $ this -> advance ( ) ; $ this -> parseTree = $ this -> condition ( ) ; return true ; }
9321	protected function compileMarkdownEchos ( $ value ) { $ pattern = sprintf ( '/(@)?%s\s*(.+?)\s*%s(\r?\n)?/s' , $ this -> markdownTags [ 0 ] , $ this -> markdownTags [ 1 ] ) ; $ callback = function ( $ matches ) { $ wrapper = sprintf ( $ this -> markdownFormat , $ this -> compileEchoDefaults ( $ matches [ 2 ] ) ) ; return $ matches [ 1 ] ? strlen ( stripcslashes ( $ this -> markdownTags [ 0 ] ) ) > 2 ? $ matches [ 0 ] : substr ( $ matches [ 0 ] , 1 ) : '<?php echo ' . $ wrapper . '; ?>' ; } ; return preg_replace_callback ( $ pattern , $ callback , $ value ) ; }
5714	protected function filterFieldList ( Form $ form , FieldList $ actions ) { $ list = FieldList :: create ( ) ; foreach ( $ actions as $ a ) { if ( ! $ a instanceof BetterButtonInterface ) { throw new Exception ( "{$buttonObj->class} must implement BetterButtonInterface" ) ; } $ a -> bindGridField ( $ form , $ this -> owner ) ; if ( ! $ a -> shouldDisplay ( ) ) { continue ; } if ( ( $ a instanceof BetterButton_Versioned ) && ! $ this -> owner -> record -> checkVersioned ( ) ) { continue ; } $ list -> push ( $ a ) ; } return $ list ; }
657	public function release ( $ name ) { if ( $ this -> releaseLock ( $ name ) ) { $ index = array_search ( $ name , $ this -> _locks ) ; if ( $ index !== false ) { unset ( $ this -> _locks [ $ index ] ) ; } return true ; } return false ; }
2798	public function toArray ( ) { return [ 'file' => $ this -> getMutationFileRelativePath ( ) , 'mutator' => $ this -> mutation -> getMutator ( ) , 'class' => $ this -> mutation -> getClass ( ) , 'method' => $ this -> mutation -> getMethod ( ) , 'line' => $ this -> mutation -> getLine ( ) , 'diff' => $ this -> getDiff ( ) , 'tests' => $ this -> testMethods ] ; }
7223	protected function clearParcel ( Shipment \ ShipmentParcelInterface $ parcel ) { if ( empty ( $ parcel -> getTrackingNumber ( ) ) && ! $ parcel -> hasLabels ( ) ) { return false ; } $ parcel -> setTrackingNumber ( null ) ; foreach ( $ parcel -> getLabels ( ) as $ label ) { $ parcel -> removeLabel ( $ label ) ; } return true ; }
3345	public function __batchProcessFilesChunk ( $ filesUuidArr , $ request_type ) { if ( count ( $ filesUuidArr ) > $ this -> batchFilesChunkSize ) { throw new \ Exception ( 'Files number should not exceed ' . $ this -> batchFilesChunkSize . ' items per request.' ) ; } $ data = $ this -> __preparedRequest ( 'files_storage' , $ request_type , array ( ) , $ filesUuidArr ) ; $ files_raw = ( array ) $ data -> result ; $ result = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ result [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return array ( 'status' => ( string ) $ data -> status , 'files' => $ result , 'problems' => $ data -> problems , ) ; }
522	protected function createMigration ( $ class ) { $ this -> includeMigrationFile ( $ class ) ; $ migration = Yii :: createObject ( $ class ) ; if ( $ migration instanceof BaseObject && $ migration -> canSetProperty ( 'compact' ) ) { $ migration -> compact = $ this -> compact ; } return $ migration ; }
38	protected function initStyles ( OutputInterface $ output ) { $ this -> colors = array ( 'green' , 'yellow' , 'cyan' , 'magenta' , 'blue' , ) ; foreach ( $ this -> colors as $ color ) { $ style = new OutputFormatterStyle ( $ color ) ; $ output -> getFormatter ( ) -> setStyle ( $ color , $ style ) ; } }
5568	public function put ( $ url , $ parameters = false , $ content_type = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } return $ this -> load ( $ url , new SimplePutEncoding ( $ parameters , $ content_type ) ) ; }
2735	public function afterGetOutput ( \ Magento \ Framework \ View \ Layout $ subject , $ result ) { if ( $ this -> config -> getType ( ) == Config :: FASTLY ) { $ this -> response -> setHeader ( "Fastly-Module-Enabled" , "1.2.99" , true ) ; } return $ result ; }
5705	public function shouldDisplay ( ) { if ( $ this -> gridFieldRequest -> getRequest ( ) -> param ( 'ID' ) == 'new' ) { return false ; } return $ this -> gridFieldRequest -> record -> canCreate ( ) ; }
7369	private function updatePrice ( StockUnitInterface $ stockUnit ) { $ price = null ; if ( null !== $ item = $ stockUnit -> getSupplierOrderItem ( ) ) { if ( null === $ order = $ item -> getOrder ( ) ) { throw new StockLogicException ( "Supplier order item's order must be set at this point." ) ; } $ currency = $ order -> getCurrency ( ) -> getCode ( ) ; $ date = $ order -> getPaymentDate ( ) ; if ( $ date > new \ DateTime ( ) ) { $ date = null ; } $ price = $ this -> currencyConverter -> convert ( $ item -> getNetPrice ( ) , $ currency , null , $ date ) ; } if ( 0 !== Money :: compare ( $ stockUnit -> getNetPrice ( ) , $ price , $ this -> currencyConverter -> getDefaultCurrency ( ) ) ) { $ stockUnit -> setNetPrice ( $ price ) ; return true ; } return false ; }
8853	public function getCurrentCategory ( ) { $ category = $ this -> request -> param ( "Category" ) ; if ( $ category ) { return $ this -> dataRecord -> Categories ( ) -> filter ( "URLSegment" , $ category ) -> first ( ) ; } return null ; }
6166	protected function writeProgress ( $ progress ) { $ this -> progress = ! $ this -> flawless && $ progress === '.' ? $ this -> formatWithColor ( 'fg-red' , '!' ) : $ progress ; ++ $ this -> numTestsRun ; }
1493	public function index ( $ resourceType , $ meta = null , array $ queryParams = [ ] ) { return $ this -> factory -> createLink ( $ this -> urls -> index ( $ resourceType , $ queryParams ) , $ meta , true ) ; }
11524	public function parseBotUA ( $ botName ) { $ dom = $ this -> getDom ( 'https://udger.com/resources/ua-list/bot-detail?bot=' . $ botName ) ; if ( false === $ dom ) { echo "Can not parse DOM" . PHP_EOL ; return false ; } $ this -> currentBotName = $ botName ; $ crawlerBot = new Crawler ( ) ; $ crawlerBot -> addContent ( $ dom ) ; $ crawlerBot -> filter ( 'body #container table tr td > a' ) -> each ( function ( $ el , $ i ) { if ( strpos ( $ el -> attr ( 'href' ) , '/resources/online-parser' ) !== false ) { $ botUA = $ el -> text ( ) ; $ this -> addBotUA ( $ botUA ) ; } } ) ; return true ; }
12776	protected function write ( $ namespace , array $ data ) { $ file = $ this -> adapter -> getFileName ( $ namespace ) ; $ contents = $ this -> adapter -> prepareForWriting ( $ data ) ; if ( ! $ this -> fileSystem -> has ( $ file ) ) { $ this -> fileSystem -> write ( $ file , $ contents ) ; } $ this -> fileSystem -> update ( $ file , $ contents ) ; }
780	public function getValue ( $ name , $ defaultValue = null ) { return isset ( $ this -> _cookies [ $ name ] ) ? $ this -> _cookies [ $ name ] -> value : $ defaultValue ; }
7167	private function getOptionsResolver ( ) { if ( null !== $ this -> optionsResolver ) { return $ this -> optionsResolver ; } $ resolver = new OptionsResolver ( ) ; $ resolver -> setDefaults ( [ 'private' => false , 'editable' => false , 'taxes_view' => true , 'ati' => null , 'locale' => \ Locale :: getDefault ( ) , 'template' => function ( Options $ options ) { if ( true === $ options [ 'editable' ] ) { return $ this -> editableTemplate ; } return $ this -> defaultTemplate ; } , ] ) -> setAllowedTypes ( 'private' , 'bool' ) -> setAllowedTypes ( 'editable' , 'bool' ) -> setAllowedTypes ( 'taxes_view' , 'bool' ) -> setAllowedTypes ( 'ati' , [ 'null' , 'bool' ] ) -> setAllowedTypes ( 'locale' , 'string' ) -> setAllowedTypes ( 'template' , [ 'null' , 'string' ] ) ; return $ this -> optionsResolver = $ resolver ; }
4701	protected function createCiconia ( InputInterface $ input ) { if ( $ input -> getOption ( 'diagnose' ) ) { $ ciconia = new \ Ciconia \ Diagnose \ Ciconia ( ) ; } else { $ ciconia = new Ciconia ( ) ; } if ( $ input -> getOption ( 'format' ) == 'xhtml' ) { $ ciconia -> setRenderer ( new XhtmlRenderer ( ) ) ; } if ( $ input -> getOption ( 'gfm' ) ) { $ ciconia -> addExtensions ( [ new FencedCodeBlockExtension ( ) , new InlineStyleExtension ( ) , new TaskListExtension ( ) , new WhiteSpaceExtension ( ) , new TableExtension ( ) , new UrlAutoLinkExtension ( ) ] ) ; } return $ ciconia ; }
10848	protected function getTableName ( $ returnAlias = false ) { $ result = '' ; foreach ( $ this -> clause_table as $ k => $ v ) { if ( ! is_int ( $ k ) && $ returnAlias ) { return $ k ; } else { return $ v ; } } return $ result ; }
11944	private function validateGetPost ( $ data , ConfigContainer $ config , $ position ) { $ argumentName = $ config -> getValue ( 'name' ) ; $ default = $ config -> getValue ( 'default' ) ; if ( ! isset ( $ data [ $ argumentName ] ) ) { if ( $ default !== false ) { return $ default ; } else { throw new RequiredArgumentException ( $ position , $ argumentName ) ; } } return $ data [ $ argumentName ] ; }
7110	protected function getTicketFromEvent ( ResourceEventInterface $ event ) { $ ticket = $ event -> getResource ( ) ; if ( ! $ ticket instanceof TicketInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketInterface :: class ) ; } return $ ticket ; }
3854	public function setMetaModel ( $ intMetaModel , $ intView ) { $ this -> intMetaModel = $ intMetaModel ; $ this -> intView = $ intView ; $ this -> prepareMetaModel ( ) ; $ this -> prepareView ( ) ; return $ this ; }
10812	protected function callAPI ( $ data ) { $ apiUtility = new PipedriveApi ( $ this -> apiEndpoint ) ; $ apiUtility -> setData ( $ data ) ; $ formState = $ this -> finisherContext -> getFormRuntime ( ) -> getFormState ( ) ; $ response = $ apiUtility -> execute ( ) ; if ( $ response -> data -> id ) { $ formState -> setFormValue ( $ this -> getIdentifier ( ) . ".ID" , $ response -> data -> id ) ; return true ; } else { throw new FinisherException ( "Something went wrong while calling the API!" ) ; } }
2538	protected function initSoapClient ( $ wsdlId ) { $ wsdlPath = WsdlAnalyser :: $ wsdlIds [ $ wsdlId ] ; $ client = new Client \ SoapClient ( $ wsdlPath , $ this -> makeSoapClientOptions ( ) , $ this -> params -> logger ) ; return $ client ; }
4319	protected function interpolate ( $ message , array & $ context = array ( ) ) { \ preg_match_all ( '/\{([a-z0-9_.]+)\}/' , $ message , $ matches ) ; $ placeholders = \ array_unique ( $ matches [ 1 ] ) ; $ replace = array ( ) ; foreach ( $ placeholders as $ key ) { if ( ! isset ( $ context [ $ key ] ) ) { continue ; } $ val = $ context [ $ key ] ; if ( ! \ is_array ( $ val ) && ( ! \ is_object ( $ val ) || \ method_exists ( $ val , '__toString' ) ) ) { $ replace [ '{' . $ key . '}' ] = $ val ; } } $ context = \ array_diff_key ( $ context , \ array_flip ( $ placeholders ) ) ; if ( ! $ context ) { $ context = $ this -> debug -> meta ( ) ; } return \ strtr ( $ message , $ replace ) ; }
8807	public function set ( $ key , $ value , $ time = 0 ) { if ( is_array ( $ key ) ) { foreach ( $ key as $ k => $ v ) { setcookie ( $ k , $ v , ( $ time == 0 ? 0 : time ( ) + $ time ) , '/' ) ; $ _COOKIE [ $ k ] = $ v ; } } else { setcookie ( $ key , $ value , ( $ time == 0 ? 0 : time ( ) + $ time ) , '/' ) ; $ _COOKIE [ $ key ] = $ value ; } return ; }
7183	protected function updateExchangeRate ( PaymentInterface $ payment ) { if ( null !== $ payment -> getExchangeRate ( ) ) { return false ; } $ date = new \ DateTime ( ) ; $ rate = $ this -> currencyConverter -> getRate ( $ this -> currencyConverter -> getDefaultCurrency ( ) , $ payment -> getCurrency ( ) -> getCode ( ) , $ date ) ; $ payment -> setExchangeRate ( $ rate ) -> setExchangeDate ( $ date ) ; return true ; }
12341	protected function printError ( \ Throwable $ error , bool $ withTime = true , ? string $ fontColor = null , ? string $ bgColor = self :: BG_COLOR_MAP [ 'red' ] ) : void { $ shift = $ withTime ? "\t\t" : '' ; $ this -> print ( $ this -> getColoredMsg ( 'Error: ' . $ error -> getMessage ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'File: ' . $ error -> getFile ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'Line: ' . $ error -> getLine ( ) , $ fontColor , $ bgColor ) , $ withTime ) ; }
3472	public function extract ( string $ namespace ) : Config { $ extracted = $ this -> get ( $ namespace ) ; if ( ! is_array ( $ extracted ) ) { throw ConfigException :: forExtractionFailure ( $ namespace ) ; } return new self ( $ extracted ) ; }
3414	public function fill ( $ fields ) { if ( ! is_array ( $ fields ) ) { return ; } if ( isset ( $ fields [ 'ID' ] ) ) { $ this -> id = $ fields [ 'ID' ] ; } $ this -> fields = $ fields ; $ this -> fieldsAreFetched = true ; if ( method_exists ( $ this , 'afterFill' ) ) { $ this -> afterFill ( ) ; } $ this -> original = $ this -> fields ; }
12485	public function adapterHasBehavior ( Adapter $ adapter , $ behavior ) { if ( $ adapter instanceof KnowsItsBehaviors ) { return in_array ( $ behavior , $ adapter -> getBehaviors ( ) ) ; } return true === is_a ( $ adapter , $ behavior ) ; }
562	public static function debug ( $ message , $ category = 'application' ) { if ( YII_DEBUG ) { static :: getLogger ( ) -> log ( $ message , Logger :: LEVEL_TRACE , $ category ) ; } }
903	public function isLambda ( $ index ) { if ( ! $ this -> tokens [ $ index ] -> isGivenKind ( T_FUNCTION ) ) { throw new \ LogicException ( sprintf ( 'No T_FUNCTION at given index %d, got %s.' , $ index , $ this -> tokens [ $ index ] -> getName ( ) ) ) ; } $ startParenthesisIndex = $ this -> tokens -> getNextMeaningfulToken ( $ index ) ; $ startParenthesisToken = $ this -> tokens [ $ startParenthesisIndex ] ; if ( $ startParenthesisToken -> isGivenKind ( CT :: T_RETURN_REF ) ) { $ startParenthesisIndex = $ this -> tokens -> getNextMeaningfulToken ( $ startParenthesisIndex ) ; $ startParenthesisToken = $ this -> tokens [ $ startParenthesisIndex ] ; } return $ startParenthesisToken -> equals ( '(' ) ; }
3154	public function getTraceVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_TraceVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setTrace ( $ variableValue ) ; return $ metaVariable ; }
934	public function equalsAny ( array $ others , $ caseSensitive = true ) { foreach ( $ others as $ other ) { if ( $ this -> equals ( $ other , $ caseSensitive ) ) { return true ; } } return false ; }
5469	public function overlayMessage ( $ compare , $ dumper ) { $ this -> dumper = $ dumper ; return sprintf ( $ this -> message , $ this -> testMessage ( $ compare ) ) ; }
7881	public function read ( $ date ) { try { return $ this -> files -> get ( $ this -> path ( $ date ) ) ; } catch ( FileNotFoundException $ e ) { throw new FilesystemException ( 'There was an reading the log.' ) ; } }
58	protected function resolvePackageInstallPreference ( PackageInterface $ package ) { foreach ( $ this -> packagePreferences as $ pattern => $ preference ) { $ pattern = '{^' . str_replace ( '\\*' , '.*' , preg_quote ( $ pattern ) ) . '$}i' ; if ( preg_match ( $ pattern , $ package -> getName ( ) ) ) { if ( 'dist' === $ preference || ( ! $ package -> isDev ( ) && 'auto' === $ preference ) ) { return 'dist' ; } return 'source' ; } } return $ package -> isDev ( ) ? 'source' : 'dist' ; }
10021	public function addCellStyleXf ( Style $ pStyle ) { $ this -> cellStyleXfCollection [ ] = $ pStyle ; $ pStyle -> setIndex ( count ( $ this -> cellStyleXfCollection ) - 1 ) ; }
5728	public function Field ( $ properties = array ( ) ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/dropdown_form_action.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/dropdown_form_action.js' ) ; $ this -> setAttribute ( 'data-form-action-dropdown' , '#' . $ this -> DropdownID ( ) ) ; return parent :: Field ( ) ; }
7533	function setInnerText ( $ text , $ parser = null ) { $ this -> clear ( ) ; if ( trim ( $ text ) ) { if ( $ parser === null ) { $ parser = new $ this -> parserClass ( ) ; } $ parser -> root = & $ this ; $ parser -> setDoc ( $ text ) ; $ parser -> parse_all ( ) ; } return ( ( $ parser && $ parser -> errors ) ? $ parser -> errors : true ) ; }
1868	public function maintenanceCheck ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> hasAccess ( 'maintenance' , 'modules' ) ) { return '' ; } try { if ( System :: getContainer ( ) -> get ( 'lexik_maintenance.driver.factory' ) -> getDriver ( ) -> isExists ( ) ) { return '<p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'maintenanceEnabled' ] . '</p>' ; } } catch ( \ Exception $ e ) { } return '' ; }
8626	public function setTermsAndConditionsNotAcceptedCarrierList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'TermsAndConditionsNotAcceptedCarrierList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2586	protected function loadBare ( PnrAddMultiElementsOptions $ params ) { $ tattooCounter = 0 ; if ( ! is_null ( $ params -> actionCode ) ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; } if ( ! is_null ( $ params -> recordLocator ) ) { $ this -> reservationInfo = new AddMultiElements \ ReservationInfo ( $ params -> recordLocator ) ; } if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; if ( ! empty ( $ params -> elements ) ) { $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; } else { $ this -> addReceivedFrom ( $ params -> receivedFrom , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ tattooCounter ) ; } }
1756	public static function setCookie ( $ strName , $ varValue , $ intExpires , $ strPath = null , $ strDomain = null , $ blnSecure = false , $ blnHttpOnly = false ) { if ( $ strPath == '' ) { $ strPath = Environment :: get ( 'path' ) ? : '/' ; } $ objCookie = new \ stdClass ( ) ; $ objCookie -> strName = $ strName ; $ objCookie -> varValue = $ varValue ; $ objCookie -> intExpires = $ intExpires ; $ objCookie -> strPath = $ strPath ; $ objCookie -> strDomain = $ strDomain ; $ objCookie -> blnSecure = $ blnSecure ; $ objCookie -> blnHttpOnly = $ blnHttpOnly ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setCookie' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setCookie' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setCookie' ] as $ callback ) { $ objCookie = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objCookie ) ; } } setcookie ( $ objCookie -> strName , $ objCookie -> varValue , $ objCookie -> intExpires , $ objCookie -> strPath , $ objCookie -> strDomain , $ objCookie -> blnSecure , $ objCookie -> blnHttpOnly ) ; }
1174	protected function generateJavascriptValidations ( ) { $ jsValidations = [ ] ; foreach ( $ this -> validator -> getRules ( ) as $ attribute => $ rules ) { if ( ! $ this -> jsValidationEnabled ( $ attribute ) ) { continue ; } $ newRules = $ this -> jsConvertRules ( $ attribute , $ rules , $ this -> remote ) ; $ jsValidations = array_merge ( $ jsValidations , $ newRules ) ; } return $ jsValidations ; }
4382	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ str = '' ; $ str .= $ this -> processAlerts ( ) ; $ str .= $ this -> processSummary ( ) ; $ str .= $ this -> processLog ( ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
8916	public function parseSubjectAddedEntry ( QuiteSimpleXmlElement & $ node ) { $ out = array ( 'term' => '' , 'vocabulary' => null ) ; $ vocabularies = array ( '0' => 'lcsh' , '1' => 'lccsh' , '2' => 'mesh' , '3' => 'atg' , '5' => 'cash' , '6' => 'rvm' , ) ; $ ind2 = $ node -> attr ( 'ind2' ) ; $ id = $ node -> text ( 'marc:subfield[@code="0"]' ) ; $ out [ 'id' ] = empty ( $ id ) ? null : $ id ; if ( isset ( $ vocabularies [ $ ind2 ] ) ) { $ out [ 'vocabulary' ] = $ vocabularies [ $ ind2 ] ; } elseif ( $ ind2 == '7' ) { $ vocab = $ node -> text ( 'marc:subfield[@code="2"]' ) ; if ( ! empty ( $ vocab ) ) { $ out [ 'vocabulary' ] = $ vocab ; } } elseif ( $ ind2 == '4' ) { $ this -> parseAuthority ( $ node -> text ( 'marc:subfield[@code="0"]' ) , $ out ) ; } $ out [ 'parts' ] = array ( ) ; $ subdivtypes = array ( 'v' => 'form' , 'x' => 'general' , 'y' => 'chronologic' , 'z' => 'geographic' , ) ; foreach ( $ node -> all ( 'marc:subfield' ) as $ subdiv ) { $ code = $ subdiv -> attr ( 'code' ) ; if ( in_array ( $ code , array_keys ( $ subdivtypes ) ) ) { $ subdiv = trim ( $ subdiv , '.' ) ; $ out [ 'parts' ] [ ] = array ( 'value' => $ subdiv , 'type' => $ subdivtypes [ $ code ] ) ; $ out [ 'term' ] .= self :: $ subfieldSeparator . $ subdiv ; } } return $ out ; }
10170	public function setDiagonalDirection ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: DIAGONAL_NONE ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'diagonalDirection' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> diagonalDirection = $ pValue ; } return $ this ; }
10297	private function writeTitle ( XMLWriter $ objWriter , Title $ title = null ) { if ( $ title === null ) { return ; } $ objWriter -> startElement ( 'c:title' ) ; $ objWriter -> startElement ( 'c:tx' ) ; $ objWriter -> startElement ( 'c:rich' ) ; $ objWriter -> startElement ( 'a:bodyPr' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:lstStyle' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:p' ) ; $ caption = $ title -> getCaption ( ) ; if ( ( is_array ( $ caption ) ) && ( count ( $ caption ) > 0 ) ) { $ caption = $ caption [ 0 ] ; } $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichTextForCharts ( $ objWriter , $ caption , 'a' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writeLayout ( $ objWriter , $ title -> getLayout ( ) ) ; $ objWriter -> startElement ( 'c:overlay' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
4350	private function setCopyValues ( $ values ) { if ( isset ( $ values [ 'debug' ] [ 'emailLog' ] ) && $ values [ 'debug' ] [ 'emailLog' ] === true ) { $ values [ 'debug' ] [ 'emailLog' ] = 'onError' ; } foreach ( array ( 'emailFrom' , 'emailFunc' , 'emailTo' ) as $ key ) { if ( isset ( $ values [ 'debug' ] [ $ key ] ) && ! isset ( $ values [ 'errorEmailer' ] [ $ key ] ) ) { $ values [ 'errorEmailer' ] [ $ key ] = $ values [ 'debug' ] [ $ key ] ; } } return $ values ; }
6233	public function addChild ( $ key , $ value = null , $ namespace = null ) { if ( $ value != null ) { $ value = htmlspecialchars ( $ value , ENT_XML1 ) ; } return parent :: addChild ( $ key , $ value , $ namespace ) ; }
397	public static function getTableSchema ( ) { $ tableSchema = static :: getDb ( ) -> getSchema ( ) -> getTableSchema ( static :: tableName ( ) ) ; if ( $ tableSchema === null ) { throw new InvalidConfigException ( 'The table does not exist: ' . static :: tableName ( ) ) ; } return $ tableSchema ; }
3579	protected function metaJoinQuery ( Builder $ query , $ method , ArgumentBag $ args ) { $ alias = $ this -> joinMeta ( $ query , $ args -> get ( 'column' ) ) ; $ method = $ args -> get ( 'function' ) ? : $ method ; return ( in_array ( $ method , [ 'orderBy' , 'lists' , 'pluck' ] ) ) ? $ this -> { "{$method}Meta" } ( $ query , $ args , $ alias ) : $ this -> metaSingleResult ( $ query , $ method , $ alias ) ; }
484	public function dropIndex ( $ name , $ table ) { $ time = $ this -> beginCommand ( "drop index $name on $table" ) ; $ this -> db -> createCommand ( ) -> dropIndex ( $ name , $ table ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
6258	public function authorizeByControllerAndAction ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; extract ( $ this -> getControllerNameAndAction ( $ request ) ) ; $ actionMap = $ this -> getActionMap ( ) ; if ( isset ( $ actionMap [ $ name ] [ '*' ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ '*' ] ) ) { return true ; } } if ( isset ( $ actionMap [ $ name ] [ $ action ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ $ action ] ) ) { return true ; } } if ( $ this -> config ( 'undefinedActionsAreAllowed' ) === true ) { return true ; } return false ; }
245	public function getColumn ( $ name ) { return isset ( $ this -> columns [ $ name ] ) ? $ this -> columns [ $ name ] : null ; }
496	public function getDbProfiling ( ) { $ timings = $ this -> getProfiling ( [ 'yii\db\Command::query' , 'yii\db\Command::execute' ] ) ; $ count = count ( $ timings ) ; $ time = 0 ; foreach ( $ timings as $ timing ) { $ time += $ timing [ 'duration' ] ; } return [ $ count , $ time ] ; }
3402	protected function applyResultCallbackChain ( Crawler $ node , ApistMethod $ method ) { if ( empty ( $ this -> resultMethodChain ) ) { $ this -> addCallback ( 'text' ) ; } $ traceStack = [ ] ; foreach ( $ this -> resultMethodChain as $ resultCallback ) { try { $ traceStack [ ] = $ resultCallback ; $ node = $ resultCallback -> apply ( $ node , $ method ) ; } catch ( InvalidArgumentException $ e ) { if ( $ method -> getResource ( ) -> isSuppressExceptions ( ) ) { return null ; } $ message = $ this -> createExceptionMessage ( $ e , $ traceStack ) ; throw new InvalidArgumentException ( $ message , 0 , $ e ) ; } } return $ node ; }
7327	private function configureIdentityMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , IdentityInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> identityClassCache ) ) { return ; } $ this -> addMappings ( $ metadata , $ this -> getIdentityMappings ( ) ) ; $ this -> identityClassCache [ ] = $ class ; }
4612	public function prepare ( Command $ command , Node $ node ) { $ this -> setCommand ( $ command ) ; $ this -> setNode ( $ node ) ; return $ this ; }
3370	private function getClassByName ( $ className ) { if ( ! isset ( $ this -> classByNames [ $ className ] ) ) { foreach ( $ this -> metadata as $ class ) { if ( $ class -> getName ( ) === $ className ) { $ this -> classByNames [ $ className ] = $ class ; break ; } } } return $ this -> classByNames [ $ className ] ?? null ; }
525	protected function migrateToVersion ( $ version ) { $ originalVersion = $ version ; $ migrations = $ this -> getNewMigrations ( ) ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { $ this -> actionUp ( $ i + 1 ) ; return ExitCode :: OK ; } } $ migrations = array_keys ( $ this -> getMigrationHistory ( null ) ) ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ i === 0 ) { $ this -> stdout ( "Already at '$originalVersion'. Nothing needs to be done.\n" , Console :: FG_YELLOW ) ; } else { $ this -> actionDown ( $ i ) ; } return ExitCode :: OK ; } } throw new Exception ( "Unable to find the version '$originalVersion'." ) ; }
12760	public static function dispatch ( $ eventName , Event $ event ) { if ( null === self :: $ dispatcher ) { return $ event ; } self :: $ dispatcher -> dispatch ( $ eventName , $ event ) ; DataLogger :: log ( sprintf ( 'The "%s" event was dispatched' , $ eventName ) ) ; if ( $ event -> getAbort ( ) ) { DataLogger :: log ( sprintf ( 'The "%s" event was aborted' , $ eventName ) , DataLogger :: ERROR ) ; throw new EventAbortedException ( $ event -> getAbortMessage ( ) ) ; } return $ event ; }
12381	public static function interval ( $ startDate , $ endDate ) { $ hits = DB :: table ( 'views' ) -> select ( 'id' , 'ip' , 'created_at' ) -> whereBetween ( 'created_at' , [ $ startDate , $ endDate ] ) -> groupBy ( 'ip' ) -> get ( ) ; return count ( $ hits ) ; }
5338	public function buildSoapClient ( $ service ) { $ director = new Soap \ SoapClientDirector ( $ this -> username , $ this -> mode , $ this -> endpoint ) ; switch ( $ service ) { case 'DomainService' : return $ director -> build ( new Soap \ Builder \ DomainSoapClientBuilder ) ; case 'ColocationService' : return $ director -> build ( new Soap \ Builder \ ColocationSoapClientBuilder ) ; case 'ForwardService' : return $ director -> build ( new Soap \ Builder \ ForwardSoapClientBuilder ) ; case 'VpsService' : return $ director -> build ( new Soap \ Builder \ VpsSoapClientBuilder ) ; case 'WebhostingService' : return $ director -> build ( new Soap \ Builder \ WebHostingSoapClientBuilder ) ; case 'HaipService' : return $ director -> build ( new Soap \ Builder \ HaipSoapClientBuilder ) ; default : throw new \ InvalidArgumentException ( sprintf ( 'Undefined soap client service builder called: [%s]' , $ service ) ) ; } }
7062	protected function updateCustomerBalance ( PaymentInterface $ payment , $ amount = null ) { if ( null === $ customer = $ payment -> getSale ( ) -> getCustomer ( ) ) { return false ; } $ amount = $ amount ? : $ payment -> getAmount ( ) ; if ( $ this -> isAcceptedPayment ( $ payment ) ) { $ amount = - $ amount ; } if ( $ payment -> getMethod ( ) -> isCredit ( ) ) { return $ this -> updateCreditBalance ( $ customer , $ amount , true ) ; } elseif ( $ payment -> getMethod ( ) -> isOutstanding ( ) ) { return $ this -> updateOutstandingBalance ( $ customer , $ amount , true ) ; } return false ; }
5855	protected function addStatisticsAndSocialLink ( ) { $ fileName = PATH_site . 'typo3temp/.tx_imageautoresize' ; if ( ! is_file ( $ fileName ) ) { return ; } $ data = json_decode ( file_get_contents ( $ fileName ) , true ) ; if ( ! is_array ( $ data ) || ! ( isset ( $ data [ 'images' ] ) && isset ( $ data [ 'bytes' ] ) ) ) { return ; } $ resourcesPath = '../' . ExtensionManagementUtility :: siteRelPath ( $ this -> extKey ) . 'Resources/Public/' ; $ pageRenderer = $ this -> moduleTemplate -> getPageRenderer ( ) ; $ pageRenderer -> addCssFile ( $ resourcesPath . 'Css/twitter.css' ) ; $ pageRenderer -> addJsFile ( $ resourcesPath . 'JavaScript/popup.js' ) ; $ totalSpaceClaimed = GeneralUtility :: formatSize ( ( int ) $ data [ 'bytes' ] ) ; $ messagePattern = $ this -> languageService -> getLL ( 'storage.claimed' ) ; $ message = sprintf ( $ messagePattern , $ totalSpaceClaimed , ( int ) $ data [ 'images' ] ) ; $ flashMessage = htmlspecialchars ( $ message ) ; $ twitterMessagePattern = $ this -> languageService -> getLL ( 'social.twitter' ) ; $ message = sprintf ( $ twitterMessagePattern , $ totalSpaceClaimed ) ; $ url = 'https://extensions.typo3.org/extension/image_autoresize/' ; $ twitterLink = 'https://twitter.com/intent/tweet?text=' . urlencode ( $ message ) . '&url=' . urlencode ( $ url ) ; $ twitterLink = GeneralUtility :: quoteJSvalue ( $ twitterLink ) ; $ flashMessage .= ' <div class="custom-tweet-button"> <a href="#" onclick="popitup(' . $ twitterLink . ',\'twitter\')" title="' . htmlspecialchars ( $ this -> languageService -> getLL ( 'social.share' ) ) . '"> <i class="btn-icon"></i> <span class="btn-text">Tweet</span> </a> </div>' ; $ this -> content .= ' <div class="alert alert-info"> <div class="media"> <div class="media-left"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-info fa-stack-1x"></i> </span> </div> <div class="media-body"> ' . $ flashMessage . ' </div> </div> </div> ' ; }
6421	public static function ands ( callable ... $ predicates ) : callable { return function ( $ element ) use ( $ predicates ) { foreach ( $ predicates as $ predicate ) { if ( ! self :: call ( $ predicate , $ element ) ) { return false ; } } return true ; } ; }
2375	public static function insertTagToSrc ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]*)\{\{file::([^"\}]+)\}\}")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 5 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByUuid ( $ paths [ $ i + 4 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . $ file -> path . '"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . $ paths [ $ i + 4 ] . '"' ; } } return $ return ; }
4133	public function initializeObject ( $ obj ) { if ( $ obj instanceof PersistentCollection ) { $ obj -> initialize ( ) ; } else if ( $ obj instanceof Proxy \ Proxy ) { $ obj -> __doctrineLoad__ ( ) ; } }
2495	protected function addEndpointsSection ( ArrayNodeDefinition $ node ) { $ node -> children ( ) -> arrayNode ( 'endpoints' ) -> info ( 'Solr Search Engine endpoint configuration' ) -> useAttributeAsKey ( 'endpoint_name' ) -> performNoDeepMerging ( ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'dsn' ) -> defaultNull ( ) -> end ( ) -> scalarNode ( 'scheme' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'scheme' ] ) -> end ( ) -> scalarNode ( 'host' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'host' ] ) -> end ( ) -> scalarNode ( 'port' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'port' ] ) -> end ( ) -> scalarNode ( 'user' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'user' ] ) -> end ( ) -> scalarNode ( 'pass' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'pass' ] ) -> end ( ) -> scalarNode ( 'path' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'path' ] ) -> end ( ) -> scalarNode ( 'core' ) -> isRequired ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; }
5385	public function isId ( $ id ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> widgets [ $ i ] -> isId ( $ id ) ) { return true ; } } return false ; }
8083	public function & getFormErrors ( $ channel = '' ) { $ channel = $ this -> namespaceChannel ( $ channel ) ; if ( ! isset ( $ this -> console [ 'form' ] [ $ channel ] ) ) { $ this -> console [ 'form' ] [ $ channel ] = array ( ) ; } return $ this -> console [ 'form' ] [ $ channel ] ; }
8549	public function setRetrochargeEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RetrochargeEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8348	public function setValue ( string $ v ) : string { if ( static :: isValid ( $ v ) === false ) { throw new BadUse ( '"' . $ v . '" is not recognized as a possible value' ) ; } $ this -> value = $ v ; }
9981	public function writeVMLComments ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ comments = $ pWorksheet -> getComments ( ) ; $ objWriter -> startElement ( 'xml' ) ; $ objWriter -> writeAttribute ( 'xmlns:v' , 'urn:schemas-microsoft-com:vml' ) ; $ objWriter -> writeAttribute ( 'xmlns:o' , 'urn:schemas-microsoft-com:office:office' ) ; $ objWriter -> writeAttribute ( 'xmlns:x' , 'urn:schemas-microsoft-com:office:excel' ) ; $ objWriter -> startElement ( 'o:shapelayout' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> startElement ( 'o:idmap' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> writeAttribute ( 'data' , '1' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shapetype' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'coordsize' , '21600,21600' ) ; $ objWriter -> writeAttribute ( 'o:spt' , '202' ) ; $ objWriter -> writeAttribute ( 'path' , 'm,l,21600r21600,l21600,xe' ) ; $ objWriter -> startElement ( 'v:stroke' ) ; $ objWriter -> writeAttribute ( 'joinstyle' , 'miter' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'gradientshapeok' , 't' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'rect' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; foreach ( $ comments as $ key => $ value ) { $ this -> writeVMLComment ( $ objWriter , $ key , $ value ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
3439	public function section ( $ load = false ) { $ fields = $ this -> getFields ( ) ; $ sectionModel = static :: sectionModel ( ) ; return $ load ? $ sectionModel :: query ( ) -> getById ( $ fields [ 'IBLOCK_SECTION_ID' ] ) : new $ sectionModel ( $ fields [ 'IBLOCK_SECTION_ID' ] ) ; }
1701	protected function decToUnix ( $ intTime , $ intDate ) { return mktime ( ( $ intTime & 0xf800 ) >> 11 , ( $ intTime & 0x07e0 ) >> 5 , ( $ intTime & 0x001f ) << 1 , ( $ intDate & 0x01e0 ) >> 5 , ( $ intDate & 0x001f ) , ( ( $ intDate & 0xfe00 ) >> 9 ) + 1980 ) ; }
12712	public function getResolvedConcreteFlag ( $ abstract ) { if ( ! $ this -> hasResolvedConcrete ( $ abstract ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be an abstract class name which exists in resolved concrete stack." , __METHOD__ ) ) ; } return explode ( '|' , $ this -> resolved [ $ abstract ] [ 'flag' ] ) ; }
7072	protected function getAttachmentFromEvent ( ResourceEventInterface $ event ) { $ attachment = $ event -> getResource ( ) ; if ( ! $ attachment instanceof TicketAttachmentInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketAttachmentInterface :: class ) ; } return $ attachment ; }
8216	private function getNextJob ( $ tube , $ state ) { if ( 'ready' == $ this -> state ) { return $ this -> reserveJob ( $ tube ) ; } return $ this -> peekJob ( $ tube , $ state ) ; }
11313	public static function buildBasestring ( $ method , Url $ url , array $ data ) { $ base = array ( ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedMethod ( $ method ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedUrl ( $ url ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedParameters ( $ data ) ) ; return implode ( '&' , $ base ) ; }
5839	protected function trim ( Builder $ url , $ args ) { $ args = ( is_string ( $ args ) ) ? $ args : null ; $ url -> trim ( $ args ) ; }
9684	public function getStorage ( ) { if ( null === $ this -> storage ) { $ this -> setStorage ( new Storage \ File ( array ( 'dir' => DATA_PATH ) ) ) ; } return $ this -> storage ; }
9866	private function writeProtectedRanges ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getProtectedCells ( ) ) > 0 ) { $ objWriter -> startElement ( 'protectedRanges' ) ; foreach ( $ pSheet -> getProtectedCells ( ) as $ protectedCell => $ passwordHash ) { $ objWriter -> startElement ( 'protectedRange' ) ; $ objWriter -> writeAttribute ( 'name' , 'p' . md5 ( $ protectedCell ) ) ; $ objWriter -> writeAttribute ( 'sqref' , $ protectedCell ) ; if ( ! empty ( $ passwordHash ) ) { $ objWriter -> writeAttribute ( 'password' , $ passwordHash ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
885	public static function getName ( $ value ) { if ( ! self :: has ( $ value ) ) { throw new \ InvalidArgumentException ( sprintf ( 'No custom token was found for "%s".' , $ value ) ) ; } $ tokens = self :: getMapById ( ) ; return 'CT::' . $ tokens [ $ value ] ; }
9985	private function mapVAlign ( $ vAlign ) { switch ( $ vAlign ) { case Alignment :: VERTICAL_BOTTOM : return 'bottom' ; case Alignment :: VERTICAL_TOP : return 'top' ; case Alignment :: VERTICAL_CENTER : case Alignment :: VERTICAL_JUSTIFY : return 'middle' ; default : return 'baseline' ; } }
6714	public function getRequestChain ( ) { if ( is_null ( $ this -> requestChain ) ) { $ this -> requestChain = $ this -> getRequestChainFromUri ( $ this -> requestedUri ) ; } return $ this -> requestChain ; }
1201	public function isCurrent ( ItemInterface $ item ) { if ( null === $ this -> matcher ) { throw new \ BadMethodCallException ( 'The matcher must be set to get the breadcrumbs array' ) ; } return $ this -> matcher -> isCurrent ( $ item ) ; }
6926	protected function didStateChangeTo ( $ resource , $ state ) { if ( empty ( $ stateCs = $ this -> tracker -> getChangeSet ( $ resource , 'state' ) ) ) { return false ; } if ( $ stateCs [ 1 ] === $ state && $ stateCs [ 0 ] !== $ state ) { return true ; } return false ; }
6341	final public static function init ( ) : void { $ className = static :: class ; self :: $ cache [ $ className ] = [ ] ; $ reflectionClass = self :: objectClass ( ) ; $ constructorParams = static :: constructorArgs ( ) ; $ ordinal = 0 ; foreach ( $ reflectionClass -> getProperties ( ReflectionProperty :: IS_STATIC ) as $ property ) { if ( $ property -> isPublic ( ) ) { $ name = $ property -> getName ( ) ; $ instance = self :: newInstance ( $ name , $ constructorParams ) ; $ property -> setValue ( $ instance ) ; self :: $ cache [ $ className ] [ $ name ] = $ instance ; self :: $ ordinals [ $ className ] [ $ name ] = $ ordinal ++ ; } } }
530	public function actionSortChangelog ( array $ what ) { if ( \ count ( $ what ) > 1 ) { $ this -> stdout ( "Currently only one simultaneous release is supported.\n" ) ; return 1 ; } $ this -> validateWhat ( $ what , [ 'framework' , 'ext' ] , false ) ; $ version = $ this -> version ? : array_values ( $ this -> getNextVersions ( $ this -> getCurrentVersions ( $ what ) , self :: PATCH ) ) [ 0 ] ; $ this -> stdout ( 'sorting CHANGELOG of ' ) ; $ this -> stdout ( reset ( $ what ) , Console :: BOLD ) ; $ this -> stdout ( ' for version ' ) ; $ this -> stdout ( $ version , Console :: BOLD ) ; $ this -> stdout ( '...' ) ; $ this -> resortChangelogs ( $ what , $ version ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; }
875	private function convertToNowdoc ( Token $ token ) { return new Token ( [ $ token -> getId ( ) , Preg :: replace ( '/^([Bb]?<<<)([ \t]*)"?([^\s"]+)"?/' , '$1$2\'$3\'' , $ token -> getContent ( ) ) , ] ) ; }
11748	public function page ( ) { if ( is_null ( $ this -> page ) ) { $ this -> page = new Page ( $ this -> accessToken ) ; } return $ this -> page ; }
7131	protected function updateTotals ( SupplierOrderInterface $ order ) { $ changed = false ; $ tax = $ this -> calculator -> calculatePaymentTax ( $ order ) ; if ( $ tax != $ order -> getTaxTotal ( ) ) { $ order -> setTaxTotal ( $ tax ) ; $ changed = true ; } $ payment = $ this -> calculator -> calculatePaymentTotal ( $ order ) ; if ( $ payment != $ order -> getPaymentTotal ( ) ) { $ order -> setPaymentTotal ( $ payment ) ; $ changed = true ; } if ( null !== $ order -> getCarrier ( ) ) { $ forwarder = $ this -> calculator -> calculateForwarderTotal ( $ order ) ; if ( $ forwarder != $ order -> getForwarderTotal ( ) ) { $ order -> setForwarderTotal ( $ forwarder ) ; $ changed = true ; } } else { if ( 0 != $ order -> getForwarderFee ( ) ) { $ order -> setForwarderFee ( 0 ) ; $ changed = true ; } if ( 0 != $ order -> getCustomsTax ( ) ) { $ order -> setCustomsTax ( 0 ) ; $ changed = true ; } if ( 0 != $ order -> getCustomsVat ( ) ) { $ order -> setCustomsVat ( 0 ) ; $ changed = true ; } if ( 0 != $ order -> getForwarderTotal ( ) ) { $ order -> setForwarderTotal ( 0 ) ; $ changed = true ; } if ( null !== $ order -> getForwarderDate ( ) ) { $ order -> setForwarderDate ( null ) ; $ changed = true ; } if ( null !== $ order -> getForwarderDueDate ( ) ) { $ order -> setForwarderDueDate ( null ) ; $ changed = true ; } } return $ changed ; }
9554	public function naming ( $ namer ) { if ( $ namer instanceof \ Closure ) { $ namer = new ClosureNamer ( $ namer ) ; } $ this -> namer = $ namer ; return $ this ; }
8013	protected function getBasicOptions ( ) { $ options = array ( ) ; $ options [ ] = '-encoding UTF-8' ; if ( $ this -> _asHtml ) { $ options [ ] = '-html' ; } if ( $ this -> _toConsole ) { $ options [ ] = '-console' ; } return join ( ' ' , $ options ) ; }
11321	function getRow ( $ sql , $ params = array ( ) ) { $ data = $ this -> query ( $ sql , $ params ) ; $ row = false ; if ( count ( $ data ) > 0 ) { $ row = $ data [ 0 ] ; } return $ row ; }
8726	public function shouldFallback ( $ locale = null ) { if ( ! $ this -> getWithFallback ( ) || ! $ this -> getFallbackLocale ( ) ) { return false ; } $ locale = $ locale ? : $ this -> getLocale ( ) ; return $ locale != $ this -> getFallbackLocale ( ) ; }
1576	public function register ( $ apiName , $ options = [ ] , Closure $ routes = null ) : ApiRegistration { $ registrar = $ this -> container -> make ( 'json-api.registrar' ) ; return $ registrar -> api ( $ apiName , $ options , $ routes ) ; }
4067	public function get ( $ strName ) { return isset ( $ this -> arrBase [ $ strName ] ) ? $ this -> arrBase [ $ strName ] : null ; }
3335	private function __runRequest ( $ ch ) { $ data = curl_exec ( $ ch ) ; $ ch_info = curl_getinfo ( $ ch ) ; if ( $ data === false ) { throw new \ Exception ( curl_error ( $ ch ) ) ; } elseif ( $ ch_info [ 'http_code' ] != 200 ) { throw new \ Exception ( 'Unexpected HTTP status code ' . $ ch_info [ 'http_code' ] . '.' . curl_error ( $ ch ) ) ; } curl_close ( $ ch ) ; return json_decode ( $ data ) ; }
9995	private function writeComment ( Worksheet $ pSheet , $ coordinate ) { $ result = '' ; if ( ! $ this -> isPdf && isset ( $ pSheet -> getComments ( ) [ $ coordinate ] ) ) { $ result .= '<a class="comment-indicator"></a>' ; $ result .= '<div class="comment">' . nl2br ( $ pSheet -> getComment ( $ coordinate ) -> getText ( ) -> getPlainText ( ) ) . '</div>' ; $ result .= PHP_EOL ; } return $ result ; }
12940	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a monitor consumer over aggregate connections.' ) ; } if ( $ client -> getCommandFactory ( ) -> supportsCommand ( 'MONITOR' ) === false ) { throw new NotSupportedException ( "'MONITOR' is not supported by the current command factory." ) ; } }
10082	protected function registerConfigurator ( ) { $ this -> app -> singleton ( 'auja.database' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; switch ( $ config [ 'database' ] ) { case 'mysql' : return new MySQLDatabaseHelper ( ) ; break ; default : throw new NoDatabaseHelperException ( 'No Auja database helper for ' . $ config [ 'database' ] ) ; break ; } } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Database\DatabaseHelper' , 'auja.database' ) ; $ this -> app -> singleton ( 'auja.configurator' , function ( $ app ) { return new AujaConfigurator ( $ app , $ app [ 'auja.database' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Config\AujaConfigurator' , 'auja.configurator' ) ; }
9123	private function retrieveAndParseResponse ( $ requestType ) { $ this -> payload = new MemoryStream ( ) ; $ this -> headers = array ( ) ; $ delimiterFound = false ; $ tmp = "" ; $ numBytes = 1 ; $ start = time ( ) ; while ( true ) { if ( ! $ this -> checkConnection ( $ start ) ) { continue ; } $ c = $ this -> read ( $ numBytes ) ; if ( $ c == null ) { break ; } $ start = time ( ) ; $ tmp .= $ c ; if ( ! $ delimiterFound ) { $ this -> handleHeader ( $ delimiterFound , $ numBytes , $ tmp ) ; } if ( $ delimiterFound ) { if ( $ requestType == 'HEAD' ) { break ; } $ this -> payload -> write ( $ tmp ) ; $ tmp = "" ; if ( $ this -> checkContentLengthExceeded ( ) ) { break ; } } } $ size = $ this -> payload -> count ( ) ; if ( $ size == 0 ) { return ; } $ this -> payload -> reset ( ) ; $ mayCompressed = $ this -> payload -> read ( $ size ) ; switch ( $ this -> getContentEncoding ( ) ) { case 'gzip' : $ uncompressed = gzdecode ( strstr ( $ mayCompressed , "\x1f\x8b" ) ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; case 'deflate' : $ uncompressed = gzuncompress ( $ mayCompressed ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; default : break ; } $ this -> payload -> reset ( ) ; }
4723	public function setAttribute ( $ attribute , $ value = null ) { $ this -> attributes -> set ( $ attribute , $ value ) ; return $ this ; }
9745	public function setCity ( $ city ) { if ( ! ( $ city instanceof City ) ) { $ city = new City ( $ city ) ; } if ( $ city -> isEmpty ( ) ) { $ this -> invalidArguments ( '10003' ) ; } return $ this -> setParameter ( 'city' , $ city ) ; }
8458	public function updateDb ( ) { $ this -> printTaskInfo ( 'Do database updates' ) ; $ this -> drush ( 'updb' ) ; $ drushVersion = $ this -> getVersion ( ) ; if ( - 1 === version_compare ( $ drushVersion , '6.0' ) ) { $ this -> printTaskInfo ( 'Will clear cache after db updates for drush ' . $ drushVersion ) ; $ this -> clearCache ( ) ; } else { $ this -> printTaskInfo ( 'Will not clear cache after db updates, since drush ' . $ drushVersion . ' should do it automatically' ) ; } return $ this ; }
5097	private function appendByField ( $ values ) { $ fixed = array ( ) ; foreach ( $ this -> fields as $ field ) { $ fixed [ ] = $ values [ $ field ] ; } return $ this -> appendByPosition ( $ fixed ) ; }
5911	public function createUser ( User $ user , $ password = null , $ redirectTo = null , $ sendNotificationEmail = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'user' => $ user , 'password' => $ password , 'redirectTo' => $ redirectTo , 'sendNotificationEmail' => $ sendNotificationEmail ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
10316	function getBouncesCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ statusCodeFilter = null , $ typeFilter = null , $ sourceFilter = null , $ excludeAnonymousBounces = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousBounces ) ) $ params [ 'exclude_anonymous_bounces' ] = ( $ excludeAnonymousBounces == true ) ? "true" : "false" ; if ( isset ( $ typeFilter ) ) $ params [ 'type' ] = $ typeFilter ; if ( isset ( $ sourceFilter ) ) $ params [ 'source_filter' ] = $ sourceFilter ; return $ this -> get ( 'reports/bounces/count' , $ params ) ; }
111	public function addPlugin ( PluginInterface $ plugin ) { $ this -> io -> writeError ( 'Loading plugin ' . get_class ( $ plugin ) , true , IOInterface :: DEBUG ) ; $ this -> plugins [ ] = $ plugin ; $ plugin -> activate ( $ this -> composer , $ this -> io ) ; if ( $ plugin instanceof EventSubscriberInterface ) { $ this -> composer -> getEventDispatcher ( ) -> addSubscriber ( $ plugin ) ; } }
449	public function init ( ) { parent :: init ( ) ; $ this -> cachePath = Yii :: getAlias ( $ this -> cachePath ) ; if ( ! is_dir ( $ this -> cachePath ) ) { FileHelper :: createDirectory ( $ this -> cachePath , $ this -> dirMode , true ) ; } }
6347	public static function all ( Iterator $ iterator , callable $ predicate ) : bool { while ( $ iterator -> valid ( ) ) { if ( ! Predicates :: call ( $ predicate , $ iterator -> current ( ) ) ) { return false ; } $ iterator -> next ( ) ; } return true ; }
3599	public function handleHttpRequest ( HttpRequest $ httpRequest ) { $ event = $ this -> dispatch ( Event \ HttpRequestEvent :: EVENT , new Event \ HttpRequestEvent ( $ httpRequest ) ) ; $ httpRequest = $ event -> getHttpRequest ( ) ; try { $ jsonRequests = $ this -> parserHttpRequest ( $ httpRequest ) ; } catch ( Exceptions \ ParseException $ e ) { return $ this -> createHttpResponseFromException ( $ e ) ; } $ jsonResponses = $ this -> jsonHandler -> handleJsonRequest ( $ jsonRequests ) ; $ httpResponse = HttpResponse :: create ( ) ; if ( $ this -> profiler ) { $ collect = function ( $ jsonResponse ) use ( & $ collect , $ httpRequest , $ httpResponse ) { if ( \ is_array ( $ jsonResponse ) ) { foreach ( $ jsonResponse as $ value ) { $ collect ( $ value ) ; } } else { if ( $ jsonResponse -> isError ( ) ) { $ this -> collectException ( $ httpRequest , $ httpResponse , new Exceptions \ ErrorException ( $ jsonResponse -> getErrorMessage ( ) , $ jsonResponse -> getErrorCode ( ) , $ jsonResponse -> getErrorData ( ) , $ jsonResponse -> getId ( ) ) ) ; } } } ; $ collect ( $ jsonResponses ) ; } if ( \ is_array ( $ jsonResponses ) ) { $ results = [ ] ; foreach ( $ jsonResponses as $ jsonResponse ) { if ( $ jsonResponse -> isError ( ) || $ jsonResponse -> getId ( ) ) { $ results [ ] = $ jsonResponse ; } if ( $ jsonResponse -> isError ( ) ) { $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; } } $ httpResponse -> setContent ( \ json_encode ( $ results ) ) ; } else { if ( $ jsonResponses -> isError ( ) || $ jsonResponses -> getId ( ) ) { $ httpResponse -> setContent ( \ json_encode ( $ jsonResponses ) ) ; } if ( $ jsonResponses -> isError ( ) ) { $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; } } if ( \ is_array ( $ jsonResponses ) ) { foreach ( $ jsonResponses as $ jsonResponse ) { if ( $ jsonResponse -> isError ( ) || $ jsonResponse -> getId ( ) ) { $ httpResponse -> headers -> add ( $ jsonResponse -> headers ( ) -> all ( ) ) ; } } } else { $ httpResponse -> headers -> add ( $ jsonResponses -> headers ( ) -> all ( ) ) ; } $ httpResponse -> headers -> set ( 'Content-Type' , 'application/json' ) ; $ this -> dispatch ( Event \ HttpResponseEvent :: EVENT , new Event \ HttpResponseEvent ( $ httpResponse ) ) ; return $ httpResponse ; }
9138	public static function formatCamelCaseWithAcronyms ( array $ parts ) { $ camelCase = array_map ( function ( $ p ) { return static :: ucfirstAndLowerNonAcronym ( $ p ) ; } , $ parts ) ; if ( static :: isAcronym ( $ camelCase [ 0 ] ) ) { return implode ( '' , $ camelCase ) ; } return lcfirst ( implode ( '' , $ camelCase ) ) ; }
1891	private function hasRequireGranted ( string $ line ) : bool { if ( $ this -> isComment ( $ line ) ) { return false ; } return ( false !== stripos ( $ line , 'Allow from all' ) ) || ( false !== stripos ( $ line , 'Require all granted' ) ) ; }
7659	function AddrAppend ( $ type , $ addr ) { $ addr_str = $ type . ": " ; $ addr_str .= $ this -> AddrFormat ( $ addr [ 0 ] ) ; if ( count ( $ addr ) > 1 ) { for ( $ i = 1 ; $ i < count ( $ addr ) ; $ i ++ ) $ addr_str .= ", " . $ this -> AddrFormat ( $ addr [ $ i ] ) ; } $ addr_str .= $ this -> LE ; return $ addr_str ; }
12248	public function xpathSingle ( $ strXpathQuery ) { $ arrResults = $ this -> xpath ( $ strXpathQuery ) ; if ( $ arrResults === false ) { return null ; } if ( is_array ( $ arrResults ) && count ( $ arrResults ) == 0 ) { return null ; } else { if ( count ( $ arrResults ) > 1 ) { throw new Exception ( 'xpathSingle expects a single element as result, got ' . count ( $ arrResults ) . ' elements instead.' ) ; } else { return current ( $ arrResults ) ; } } }
1615	public function readSession ( $ id ) { $ data = $ this -> redis -> executeCommand ( 'GET' , [ $ this -> calculateKey ( $ id ) ] ) ; return $ data === false || $ data === null ? '' : $ data ; }
6122	public function permissionGetNameById ( $ permid ) { foreach ( $ this -> permissionList ( ) as $ name => $ perm ) { if ( $ perm [ "permid" ] == $ permid ) { return new Ts3Exception ( $ name ) ; } } throw new Ts3Exception ( "invalid permission ID" , 0xA02 ) ; }
8208	public function getPheanstalk ( ) { if ( ! $ this -> pheanstalk ) { $ this -> pheanstalk = new Pheanstalk ( $ this -> host , $ this -> port ) ; } return $ this -> pheanstalk ; }
2142	private function getSessionBag ( Request $ request ) : SessionBagInterface { if ( ! $ request -> hasSession ( ) || null === ( $ session = $ request -> getSession ( ) ) ) { throw new \ RuntimeException ( 'The request did not contain a session.' ) ; } $ name = 'contao_frontend' ; if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ name = 'contao_backend' ; } return $ session -> getBag ( $ name ) ; }
7256	public function user ( $ key = null ) { if ( $ this -> sessionKey && $ this -> request -> session ( ) -> check ( $ this -> sessionKey ) ) { $ user = $ this -> request -> session ( ) -> read ( $ this -> sessionKey ) ; } else { return null ; } if ( $ key === null ) { return $ user ; } return Hash :: get ( $ user , $ key ) ; }
177	public static function htmlDecode ( $ data , $ valuesOnly = true ) { $ d = [ ] ; foreach ( $ data as $ key => $ value ) { if ( ! $ valuesOnly && is_string ( $ key ) ) { $ key = htmlspecialchars_decode ( $ key , ENT_QUOTES ) ; } if ( is_string ( $ value ) ) { $ d [ $ key ] = htmlspecialchars_decode ( $ value , ENT_QUOTES ) ; } elseif ( is_array ( $ value ) ) { $ d [ $ key ] = static :: htmlDecode ( $ value ) ; } else { $ d [ $ key ] = $ value ; } } return $ d ; }
6359	public function limit ( int $ limit ) : BufferedIterable { Preconditions :: checkArgument ( 0 < $ limit , 'Limit must be a positive integer!' ) ; return new BufferedIterable ( $ this -> chunkProvider , $ this -> filter , $ limit , $ this -> providerCallLimit ) ; }
3299	public function setHeaders ( array $ headers = [ ] ) { $ originHeaders = empty ( $ this -> headers ) ? [ ] : $ this -> headers ; $ this -> headers = array_merge ( $ originHeaders , $ headers ) ; return $ this ; }
5628	public function makeAbsolute ( $ base ) { if ( ! is_object ( $ base ) ) { $ base = new self ( $ base ) ; } if ( $ this -> getHost ( ) ) { $ scheme = $ this -> getScheme ( ) ; $ host = $ this -> getHost ( ) ; $ port = $ this -> getPort ( ) ? ':' . $ this -> getPort ( ) : '' ; $ identity = $ this -> getIdentity ( ) ? $ this -> getIdentity ( ) . '@' : '' ; if ( ! $ identity ) { $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } } else { $ scheme = $ base -> getScheme ( ) ; $ host = $ base -> getHost ( ) ; $ port = $ base -> getPort ( ) ? ':' . $ base -> getPort ( ) : '' ; $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } $ path = $ this -> normalisePath ( $ this -> extractAbsolutePath ( $ base ) ) ; $ encoded = $ this -> getEncodedRequest ( ) ; $ fragment = $ this -> getFragment ( ) ? '#' . $ this -> getFragment ( ) : '' ; $ coords = $ this -> getX ( ) === false ? '' : '?' . $ this -> getX ( ) . ',' . $ this -> getY ( ) ; return new self ( "$scheme://$identity$host$port$path$encoded$fragment$coords" ) ; }
2392	public function getAllowedCalendars ( ) { if ( $ this -> User -> isAdmin ) { $ objCalendar = Contao \ CalendarModel :: findAll ( ) ; } else { $ objCalendar = Contao \ CalendarModel :: findMultipleByIds ( $ this -> User -> calendars ) ; } $ return = array ( ) ; if ( $ objCalendar !== null ) { while ( $ objCalendar -> next ( ) ) { $ return [ $ objCalendar -> id ] = $ objCalendar -> title ; } } return $ return ; }
12556	private function createDeleteForm ( Tag $ tag ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_tag_delete' , array ( 'id' => $ tag -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
10943	public function encode ( $ rawString ) { $ bytes = unpack ( 'C*' , $ rawString ) ; $ byteCount = count ( $ bytes ) ; $ encodedString = '' ; $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; $ chars = $ this -> chars ; $ bitsPerCharacter = $ this -> bitsPerCharacter ; $ rightPadFinalBits = $ this -> rightPadFinalBits ; $ padFinalGroup = $ this -> padFinalGroup ; $ padCharacter = $ this -> padCharacter ; for ( $ c = 0 ; $ c < $ byteCount * 8 / $ bitsPerCharacter ; ++ $ c ) { if ( $ bitsRead + $ bitsPerCharacter > 8 ) { $ oldBitCount = 8 - $ bitsRead ; $ oldBits = $ byte ^ ( $ byte >> $ oldBitCount << $ oldBitCount ) ; $ newBitCount = $ bitsPerCharacter - $ oldBitCount ; if ( ! $ bytes ) { if ( $ rightPadFinalBits ) { $ oldBits <<= $ newBitCount ; } $ encodedString .= $ chars [ $ oldBits ] ; if ( $ padFinalGroup ) { $ lcmMap = array ( 1 => 1 , 2 => 1 , 3 => 3 , 4 => 1 , 5 => 5 , 6 => 3 , 7 => 7 , 8 => 1 ) ; $ bytesPerGroup = $ lcmMap [ $ bitsPerCharacter ] ; $ pads = $ bytesPerGroup * 8 / $ bitsPerCharacter - ceil ( ( strlen ( $ rawString ) % $ bytesPerGroup ) * 8 / $ bitsPerCharacter ) ; $ encodedString .= str_repeat ( $ padCharacter [ 0 ] , $ pads ) ; } break ; } $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; } else { $ oldBitCount = 0 ; $ newBitCount = $ bitsPerCharacter ; } $ bits = $ byte >> 8 - ( $ bitsRead + ( $ newBitCount ) ) ; $ bits ^= $ bits >> $ newBitCount << $ newBitCount ; $ bitsRead += $ newBitCount ; if ( $ oldBitCount ) { $ bits = ( $ oldBits << $ newBitCount ) | $ bits ; } $ encodedString .= $ chars [ $ bits ] ; } return $ encodedString ; }
6807	public function createFromContext ( ContextInterface $ context ) { return $ this -> create ( $ context -> getLocale ( ) , $ context -> getCurrency ( ) -> getCode ( ) ) ; }
1418	public function failedValidatorException ( ValidatorContract $ validator , \ Closure $ closure = null ) : JsonApiException { return new ValidationException ( $ this -> failedValidator ( $ validator , $ closure ) ) ; }
4787	function offsetSet ( $ key , $ value ) { $ this -> row [ $ key ] = $ value ; $ this -> modified [ $ key ] = $ value ; }
5152	static function sortEmailsByCreationDatePredicate ( $ emailA , $ emailB ) { $ sortKeyA = $ emailA -> sent_at ; $ sortKeyB = $ emailB -> sent_at ; return ( $ sortKeyA > $ sortKeyB ) ? - 1 : 1 ; }
11210	protected function addRegistry ( $ registry ) { $ this -> removeFromLookup ( $ registry ) ; if ( $ registry instanceof DelegatorAwareInterface ) { $ registry -> setDelegator ( $ this ) ; } $ this -> lookup_pool [ ] = $ registry ; return $ this ; }
7077	static public function getSaleEditableDocumentTypes ( SaleInterface $ sale ) { $ types = [ ] ; foreach ( DocumentTypes :: getTypes ( ) as $ type ) { if ( ! static :: isSaleSupportsDocumentType ( $ sale , $ type ) ) { continue ; } foreach ( $ sale -> getAttachments ( ) as $ attachment ) { if ( $ attachment -> getType ( ) === $ type ) { continue 2 ; } } $ types [ ] = $ type ; } return $ types ; }
11966	public function renderSlots ( Page $ page , array $ slots , array $ options = array ( ) ) { $ renderedSlots = array ( ) ; $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERING , $ page , $ slots ) ; foreach ( $ slots as $ slotName => $ slot ) { if ( is_string ( $ slot ) ) { $ renderedSlots [ $ slotName ] = $ slot ; continue ; } if ( ! $ slot instanceof Slot ) { continue ; } $ renderedSlots [ $ slotName ] = implode ( "" , $ this -> renderSlot ( $ slot ) ) ; } $ this -> mediaFiles = array_unique ( $ this -> mediaFiles ) ; return $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERED , $ page , $ renderedSlots ) ; }
7905	public function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , Html :: tag ( 'i' , '' , [ 'class' => 'content icon' ] ) ) ; Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'launch-sidebar icon' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; Html :: addCssClass ( $ this -> toggleButton , 'fixed' ) ; Html :: addCssClass ( $ this -> toggleButton , 'attached' ) ; if ( $ this -> position === static :: POS_LEFT ) { $ position = static :: POS_RIGHT ; } else { $ position = static :: POS_LEFT ; } Html :: addCssClass ( $ this -> toggleButton , $ position ) ; $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
9935	public function setOperator ( $ pOperator ) { if ( empty ( $ pOperator ) ) { $ pOperator = self :: AUTOFILTER_COLUMN_RULE_EQUAL ; } if ( ( ! in_array ( $ pOperator , self :: $ operators ) ) && ( ! in_array ( $ pOperator , self :: $ topTenValue ) ) ) { throw new PhpSpreadsheetException ( 'Invalid operator for column AutoFilter Rule.' ) ; } $ this -> operator = $ pOperator ; return $ this ; }
687	protected function getChildrenRecursive ( $ name , $ childrenList , & $ result ) { if ( isset ( $ childrenList [ $ name ] ) ) { foreach ( $ childrenList [ $ name ] as $ child ) { $ result [ $ child ] = true ; $ this -> getChildrenRecursive ( $ child , $ childrenList , $ result ) ; } } }
10207	public function get ( $ resourcePath , $ queryParameters = array ( ) , $ mimeType = 'application/vnd.maileon.api+xml' , $ deserializationType = null ) { $ curlSession = $ this -> prepareSession ( $ resourcePath , $ queryParameters , $ mimeType ) ; return $ this -> performRequest ( $ curlSession , $ deserializationType ) ; }
11442	public function getRegistry ( $ var = null , $ section = false , $ default = false ) { if ( is_null ( $ var ) ) { return ; } if ( $ section && isset ( $ this -> registry [ $ section ] ) ) { if ( isset ( $ this -> registry [ $ section ] [ $ var ] ) ) { return $ this -> registry [ $ section ] [ $ var ] ; } else { return $ default ; } } if ( isset ( $ this -> registry [ $ var ] ) ) { return $ this -> registry [ $ var ] ; } return $ default ; }
3857	protected function prepareView ( ) { if ( $ this -> renderSettingFactory ) { $ this -> objView = $ this -> renderSettingFactory -> createCollection ( $ this -> objMetaModel , $ this -> intView ) ; } else { $ this -> objView = $ this -> objMetaModel -> getView ( $ this -> intView ) ; } if ( $ this -> objView ) { $ this -> objTemplate = new Template ( $ this -> objView -> get ( 'template' ) ) ; $ this -> objTemplate -> view = $ this -> objView ; } else { $ this -> objTemplate = new Template ( 'metamodel_full' ) ; } }
4359	public static function addSpecial ( $ special ) { $ special = ( array ) $ special ; foreach ( $ special as $ char ) { self :: $ special [ ] = $ char ; } }
4260	public function hasSubscribers ( $ eventName = null ) { if ( $ eventName !== null ) { return ! empty ( $ this -> subscribers [ $ eventName ] ) ; } foreach ( $ this -> subscribers as $ subscribers ) { if ( $ subscribers ) { return true ; } } return false ; }
3087	public function validateAdaptiveAssessmentSection ( SectionPartCollection $ sectionsParts , $ ref , $ testAdminId ) { $ engine = $ this -> getEngine ( $ ref ) ; $ adaptSection = $ engine -> setupSection ( $ testAdminId ) ; if ( method_exists ( $ adaptSection , 'getItemReferences' ) ) { $ itemReferences = $ adaptSection -> getItemReferences ( ) ; $ dependencies = $ sectionsParts -> getKeys ( ) ; if ( $ catDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some CAT service items: ' . implode ( ', ' , $ catDiff ) , $ catDiff ) ; } if ( $ packageDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some package items: ' . implode ( ', ' , $ packageDiff ) , $ packageDiff ) ; } } }
8456	public function drush ( $ command , $ assumeYes = true ) { if ( is_array ( $ command ) ) { $ command = implode ( ' ' , array_filter ( $ command ) ) ; } return $ this -> exec ( $ this -> injectArguments ( $ command , $ assumeYes ) ) ; }
10415	public function updateTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( ! $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return false ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ oldTable = $ schemaManager -> listTableDetails ( $ this -> tableName ) ; $ comparator = new Comparator ( ) ; $ diff = $ comparator -> diffTable ( $ oldTable , $ table ) ; if ( ! $ diff ) { return null ; } $ schemaManager -> alterTable ( $ diff ) ; return true ; }
310	protected function composeMessage ( $ body ) { $ message = $ this -> mailer -> compose ( ) ; Yii :: configure ( $ message , $ this -> message ) ; $ message -> setTextBody ( $ body ) ; return $ message ; }
6879	public function finish ( ) { parent :: finish ( ) ; if ( $ this -> isRowActionsEnabled ( ) && ! $ this -> hasValueViewer ( static :: ROW_ACTIONS_COLUMN_NAME ) ) { $ this -> addValueViewer ( static :: ROW_ACTIONS_COLUMN_NAME , null ) ; } if ( $ this -> isNestedViewEnabled ( ) && ! $ this -> hasValueViewer ( $ this -> getColumnNameForNestedView ( ) ) ) { $ this -> addValueViewer ( $ this -> getColumnNameForNestedView ( ) , DataGridColumn :: create ( ) -> setIsVisible ( false ) ) ; } if ( $ this -> isRowsReorderingEnabled ( ) ) { $ reorderingColumns = $ this -> getRowsPositioningColumns ( ) ; $ allowedColumnTypes = [ Column :: TYPE_INT , Column :: TYPE_FLOAT , Column :: TYPE_UNIX_TIMESTAMP ] ; foreach ( $ reorderingColumns as $ columnName ) { if ( ! $ this -> hasValueViewer ( $ columnName ) ) { throw new NotFoundException ( "Column '$columnName' provided for reordering was not found within declared data grid columns" ) ; } $ valueViewer = $ this -> getValueViewer ( $ columnName ) ; if ( ! $ valueViewer -> isLinkedToDbColumn ( ) && $ valueViewer -> getTableColumn ( ) -> isItExistsInDb ( ) ) { throw new \ UnexpectedValueException ( "Column '$columnName' provided for reordering must be linked to a column that exists in database" ) ; } $ colType = $ valueViewer -> getTableColumn ( ) -> getType ( ) ; if ( ! in_array ( $ colType , $ allowedColumnTypes , true ) ) { throw new \ UnexpectedValueException ( "Column '$columnName' provided for reordering should be of a numeric type (int, float, unix ts)." . "'{$colType}' type is not acceptable'" ) ; } $ valueViewer -> setIsSortable ( true ) ; } } }
2409	public static function getInstance ( $ strTable ) { if ( ! isset ( static :: $ arrInstances [ $ strTable ] ) ) { static :: $ arrInstances [ $ strTable ] = new static ( $ strTable ) ; } return static :: $ arrInstances [ $ strTable ] ; }
8887	private function checkDefaults ( $ options ) { if ( ! isset ( $ options [ 'request_option' ] ) ) { $ options [ 'request_option' ] = 'Shop' ; } if ( ! isset ( $ options [ 'from_country' ] ) ) { $ options [ 'from_country' ] = 'US' ; } if ( ! isset ( $ options [ 'to_country' ] ) ) { $ options [ 'to_country' ] = 'US' ; } if ( ! isset ( $ options [ 'service_type' ] ) ) { $ options [ 'service_type' ] = '03' ; } if ( ! isset ( $ options [ 'from_state' ] ) ) { $ options [ 'from_state' ] = '' ; } if ( ! isset ( $ options [ 'to_state' ] ) ) { $ options [ 'to_state' ] = '' ; } $ this -> commercial_rates = ( isset ( $ options [ 'commercial' ] ) && $ options [ 'commercial' ] ) ? true : false ; $ this -> negotiated_rates = ( isset ( $ options [ 'negotiated_rates' ] ) && $ options [ 'negotiated_rates' ] ) ? true : false ; return $ options ; }
3733	protected function getAttributeByNames ( $ attrNames = array ( ) ) { if ( empty ( $ attrNames ) ) { return $ this -> arrAttributes ; } $ result = array ( ) ; foreach ( $ attrNames as $ attributeName ) { $ result [ $ attributeName ] = $ this -> arrAttributes [ $ attributeName ] ; } return $ result ; }
8510	public function getTransportContent ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetTransportContentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetTransportContentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetTransportContent' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetTransportContentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6485	private function isUsingStandardPort ( ) : bool { return $ this -> port === null || ( ( $ this -> scheme === 'http' && $ this -> port === 80 ) || ( $ this -> scheme === 'https' && $ this -> port === 443 ) ) ; }
9850	public function stringToStream ( string $ input ) : StreamInterface { $ stream = \ fopen ( 'php://temp' , 'w+' ) ; if ( ! \ is_resource ( $ stream ) ) { throw new \ Error ( 'Could not create stream' ) ; } \ fwrite ( $ stream , $ input ) ; \ rewind ( $ stream ) ; return new Stream ( $ stream ) ; }
6608	public static function getAllProvider ( $ relatedRecords = [ ] , $ sort = [ ] , $ limit = null ) { $ query = self :: find ( ) -> with ( $ relatedRecords ) -> orderBy ( $ sort ) ; return self :: convertToProvider ( $ query , [ ] , $ limit ) ; }
12552	private function addHeaders ( ) { self :: response ( ) -> addHeader ( 'Cache-Control' , 'no-cache, no-store, must-revalidate' ) ; self :: response ( ) -> addHeader ( 'Pragma' , 'no-cache' ) ; self :: response ( ) -> addHeader ( 'Expires' , '-1' ) ; }
8357	public static function extractDomain ( RawRequest $ rawRequest ) { $ domain = null ; if ( preg_match ( "/(?P<domain>[a-z0-9][a-z0-9\-]{1,63}\.[a-z\.]{2,6})$/i" , $ rawRequest -> getHost ( ) , $ matches ) ) { $ domain = $ matches [ 'domain' ] ; } return $ domain ; }
6891	protected function createAssignmentsForQuantity ( SaleItemInterface $ item , $ quantity ) { if ( 0 >= $ quantity ) { return ; } $ stockUnits = $ this -> sortStockUnits ( $ this -> unitResolver -> findAssignable ( $ item ) ) ; foreach ( $ stockUnits as $ stockUnit ) { $ assignment = $ this -> saleFactory -> createStockAssignmentForItem ( $ item ) ; $ assignment -> setSaleItem ( $ item ) -> setStockUnit ( $ stockUnit ) ; $ quantity -= $ this -> assignmentUpdater -> updateSold ( $ assignment , $ quantity ) ; if ( 0 == $ quantity ) { return ; } } if ( 0 < $ quantity ) { $ stockUnit = $ this -> unitResolver -> createBySubjectRelative ( $ item ) ; $ assignment = $ this -> saleFactory -> createStockAssignmentForItem ( $ item ) ; $ assignment -> setSaleItem ( $ item ) -> setStockUnit ( $ stockUnit ) ; $ quantity -= $ this -> assignmentUpdater -> updateSold ( $ assignment , $ quantity ) ; } if ( 0 < $ quantity ) { throw new StockLogicException ( sprintf ( 'Failed to create assignments for item "%s".' , $ item -> getDesignation ( ) ) ) ; } }
9145	private static function resetLocaleTo ( $ localeSaved ) { $ localeData = explode ( ';' , $ localeSaved ) ; foreach ( $ localeData as $ identifier ) { if ( ! strchr ( $ identifier , '=' ) ) { continue ; } $ type = $ value = null ; sscanf ( $ identifier , "%s=%s" , $ type , $ value ) ; switch ( $ type ) { case 'LC_ALL' : setlocale ( LC_ALL , $ value ) ; break ; case 'LC_COLLATE' : setlocale ( LC_COLLATE , $ value ) ; break ; case 'LC_CTYPE' : setlocale ( LC_CTYPE , $ value ) ; break ; case 'LC_MONETARY' : setlocale ( LC_MONETARY , $ value ) ; break ; case 'LC_NUMERIC' : setlocale ( LC_NUMERIC , $ value ) ; break ; case 'LC_TIME' : setlocale ( LC_TIME , $ value ) ; break ; case 'LC_MESSAGES' : setlocale ( LC_MESSAGES , $ value ) ; break ; default : ; break ; } } }
704	public function setDefaultRoles ( $ roles ) { if ( is_array ( $ roles ) ) { $ this -> defaultRoles = $ roles ; } elseif ( $ roles instanceof \ Closure ) { $ roles = call_user_func ( $ roles ) ; if ( ! is_array ( $ roles ) ) { throw new InvalidValueException ( 'Default roles closure must return an array' ) ; } $ this -> defaultRoles = $ roles ; } else { throw new InvalidArgumentException ( 'Default roles must be either an array or a callable' ) ; } }
559	protected function buildAttributeCondition ( $ attribute , $ condition ) { if ( is_array ( $ condition ) ) { $ parts = [ ] ; foreach ( $ condition as $ operator => $ value ) { if ( isset ( $ this -> operatorTypes [ $ operator ] ) ) { if ( isset ( $ this -> conditionBuilders [ $ operator ] ) ) { $ method = $ this -> conditionBuilders [ $ operator ] ; if ( is_string ( $ method ) ) { $ callback = [ $ this , $ method ] ; } else { $ callback = $ method ; } $ parts [ ] = $ callback ( $ operator , $ value , $ attribute ) ; } else { $ parts [ ] = $ this -> buildOperatorCondition ( $ operator , $ value , $ attribute ) ; } } } if ( ! empty ( $ parts ) ) { if ( count ( $ parts ) > 1 ) { return array_merge ( [ 'AND' ] , $ parts ) ; } return array_shift ( $ parts ) ; } } return [ $ attribute => $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; }
4834	public function fetch_access_token ( $ params ) { if ( ! isset ( $ params [ 'redirect_uri' ] ) ) { throw new GoCardless_ArgumentsException ( 'redirect_uri required' ) ; } $ params [ 'http_authorization' ] = $ this -> account_details [ 'app_id' ] . ':' . $ this -> account_details [ 'app_secret' ] ; $ response = $ this -> request ( 'post' , '/oauth/access_token' , $ params ) ; $ merchant = explode ( ':' , $ response [ 'scope' ] ) ; $ merchant_id = isset ( $ merchant [ 1 ] ) ? $ merchant [ 1 ] : null ; $ access_token = $ response [ 'access_token' ] ; return array ( 'merchant_id' => $ merchant_id , 'access_token' => $ access_token ) ; }
1572	public function getProcess ( ) : ? AsynchronousProcess { $ process = $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; return ( $ process instanceof AsynchronousProcess ) ? $ process : null ; }
5039	public function set ( $ key , ImageInterface $ image , $ check = true ) { $ images = $ this -> getImages ( ) ; if ( $ check && ( $ img = $ this -> get ( $ key ) ) ) { $ images -> removeElement ( $ img ) ; } $ image -> setBelongsTo ( $ this -> id ) ; $ image -> setKey ( $ key ) ; $ images -> add ( $ image ) ; return $ this ; }
1027	private function executeFieldsSerially ( ObjectType $ parentType , $ sourceValue , $ path , $ fields ) { $ result = $ this -> promiseReduce ( array_keys ( $ fields -> getArrayCopy ( ) ) , function ( $ results , $ responseName ) use ( $ path , $ parentType , $ sourceValue , $ fields ) { $ fieldNodes = $ fields [ $ responseName ] ; $ fieldPath = $ path ; $ fieldPath [ ] = $ responseName ; $ result = $ this -> resolveField ( $ parentType , $ sourceValue , $ fieldNodes , $ fieldPath ) ; if ( $ result === self :: $ UNDEFINED ) { return $ results ; } $ promise = $ this -> getPromise ( $ result ) ; if ( $ promise ) { return $ promise -> then ( static function ( $ resolvedResult ) use ( $ responseName , $ results ) { $ results [ $ responseName ] = $ resolvedResult ; return $ results ; } ) ; } $ results [ $ responseName ] = $ result ; return $ results ; } , [ ] ) ; if ( $ this -> isPromise ( $ result ) ) { return $ result -> then ( static function ( $ resolvedResults ) { return self :: fixResultsIfEmptyArray ( $ resolvedResults ) ; } ) ; } return self :: fixResultsIfEmptyArray ( $ result ) ; }
12889	public function getIdentity ( $ view ) { if ( ! isset ( $ view -> assetBundles [ $ this -> identityAssetBundle ] ) ) { return false ; } return Yii :: $ app -> assetManager -> getBundle ( $ this -> identityAssetBundle ) ; }
4856	public function setParams ( $ namespace , $ params ) { $ session = new Container ( $ namespace ) ; $ session -> params = $ params ; unset ( $ session -> list ) ; return $ this ; }
10322	function getSubscribersCount ( $ fromDate = null , $ toDate = null , $ mailingIds = array ( ) , $ contactIds = array ( ) , $ contactEmails = array ( ) , $ contactExternalIds = array ( ) , $ excludeAnonymousContacts = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousContacts ) ) $ params [ 'exclude_anonymous_contacts' ] = ( $ excludeAnonymousContacts == true ) ? "true" : "false" ; return $ this -> get ( 'reports/subscribers/count' , $ params ) ; }
4863	public function retry ( JobInterface $ job , array $ options = [ ] ) { $ tried = $ job -> getMetadata ( 'mongoqueue.tries' , 0 ) + 1 ; $ job -> setMetaData ( 'mongoqueue.tries' , $ tried ) ; $ options [ 'tried' ] = $ tried ; $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectID ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
2003	public static function getNormalizedVersion ( string $ packageName ) : string { $ chunks = explode ( '.' , static :: getVersion ( $ packageName ) ) ; $ chunks += [ 0 , 0 , 0 ] ; if ( \ count ( $ chunks ) > 3 ) { $ chunks = \ array_slice ( $ chunks , 0 , 3 ) ; } return implode ( '.' , $ chunks ) ; }
7779	protected function extractRules ( array $ data ) { $ rules = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ rules [ $ field ] = $ fieldData [ 1 ] ; } return $ rules ; }
11549	public function onExecuteAction ( ExecuteActionEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ authenticate = $ request -> getConfig ( ) -> getObject ( 'authenticate' ) ; if ( $ authenticate ) { $ this -> execute ( $ event , $ authenticate ) ; } }
5732	public function getLeague ( int $ leagueID , array $ filter = [ 'areas' => '' ] ) { $ league = $ this -> run ( "v2/competitions/{$leagueID}" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ league ) ; }
12310	private function findFile ( $ uriPath ) { return array_reduce ( $ this -> paths , function ( $ file , $ path ) use ( $ uriPath ) { if ( false !== $ file ) { return $ file ; } $ file = $ path . $ uriPath ; if ( is_file ( $ file ) && is_readable ( $ file ) ) { return $ file ; } return false ; } , false ) ; }
1923	public static function fromDimensions ( $ width , $ height ) { $ image = imagecreatetruecolor ( $ width , $ height ) ; $ arrGdInfo = gd_info ( ) ; $ strGdVersion = preg_replace ( '/[^0-9.]+/' , '' , $ arrGdInfo [ 'GD Version' ] ) ; if ( version_compare ( $ strGdVersion , '2.0' , '>=' ) ) { imagealphablending ( $ image , false ) ; imagefill ( $ image , 0 , 0 , imagecolorallocatealpha ( $ image , 0 , 0 , 0 , 127 ) ) ; imagesavealpha ( $ image , true ) ; } return new static ( $ image ) ; }
5352	public function getSupportedNamespaces ( ) { if ( empty ( $ this -> data -> namespaces ) || ! is_array ( $ this -> data -> namespaces ) ) { return array ( ) ; } return $ this -> data -> namespaces ; }
7050	protected function buildDiscountsLines ( Document \ DocumentInterface $ document ) { $ sale = $ document -> getSale ( ) ; if ( ! $ sale -> hasAdjustments ( Common \ AdjustmentTypes :: TYPE_DISCOUNT ) ) { return ; } $ adjustments = $ sale -> getAdjustments ( ) ; foreach ( $ adjustments as $ adjustment ) { if ( $ adjustment -> getType ( ) === Common \ AdjustmentTypes :: TYPE_DISCOUNT ) { $ this -> buildDiscountLine ( $ adjustment , $ document ) ; } } }
5025	protected function renderMarkup ( FileUpload $ element ) { $ markup = '<div class="%s" id="%s-dropzone"> %s __input__</div>' ; return sprintf ( $ markup , $ this -> getDropZoneClass ( $ element ) , $ element -> getAttribute ( 'id' ) , $ this -> renderFileList ( $ element ) ) ; }
1013	private function readComment ( $ line , $ col , Token $ prev ) { $ start = $ this -> position ; $ value = '' ; $ bytes = 1 ; do { [ $ char , $ code , $ bytes ] = $ this -> moveStringCursor ( 1 , $ bytes ) -> readChar ( ) ; $ value .= $ char ; } while ( $ code && ( $ code > 0x001F || $ code === 0x0009 ) ) ; return new Token ( Token :: COMMENT , $ start , $ this -> position , $ line , $ col , $ prev , $ value ) ; }
8952	public function retrieveMapData ( $ left , $ bottom , $ right , $ top ) { $ base = 'map?bbox=' . $ left . ',' . $ bottom . ',' . $ right . ',' . $ top ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'GET' , array ( ) ) ; return simplexml_load_string ( $ response -> body ) ; }
8528	public function listFinancialEventGroupsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroupsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1170	protected function createProtectedCaller ( $ instance ) { $ closure = function ( $ method , $ args ) { $ callable = [ $ this , $ method ] ; return call_user_func_array ( $ callable , $ args ) ; } ; return $ closure -> bindTo ( $ instance , $ instance ) ; }
3375	public function open ( $ file ) { if ( strlen ( $ file ) >= 1 && $ file [ 0 ] == '@' ) { try { if ( $ this -> fileLocator instanceof FileLocatorInterface ) { $ file = $ this -> fileLocator -> locate ( $ file ) ; } else { $ this -> fileLocator -> locateResource ( $ file ) ; } } catch ( \ InvalidArgumentException $ exception ) { if ( $ this -> throwException || false == $ this -> fallbackImage ) { throw $ exception ; } $ file = $ this -> fallbackImage ; } } return $ this -> createInstance ( $ file ) ; }
7685	function XML_DeleteColumnElements ( & $ Txt , $ Tag , $ SpanAtt , $ ColLst , $ ColMax ) { $ ColNum = 0 ; $ ColPos = 0 ; $ ColQty = 1 ; $ Continue = true ; $ ModifNbr = 0 ; while ( $ Continue && ( $ Loc = clsTbsXmlLoc :: FindElement ( $ Txt , $ Tag , $ ColPos , true ) ) ) { if ( $ SpanAtt !== false ) { $ ColQty = $ Loc -> GetAttLazy ( $ SpanAtt ) ; $ ColQty = ( $ ColQty === false ) ? 1 : intval ( $ ColQty ) ; } $ KeepQty = 0 ; for ( $ i = 1 ; $ i <= $ ColQty ; $ i ++ ) { if ( array_search ( $ ColNum + $ i , $ ColLst ) === false ) $ KeepQty ++ ; } if ( $ KeepQty == 0 ) { $ Loc -> ReplaceSrc ( '' ) ; $ ModifNbr ++ ; } else { if ( $ KeepQty != $ ColQty ) { $ Loc -> ReplaceAtt ( $ SpanAtt , $ KeepQty ) ; $ ModifNbr ++ ; } $ ColPos = $ Loc -> PosEnd + 1 ; } $ ColNum += $ ColQty ; if ( $ ColNum > $ ColMax ) $ Continue = false ; } return $ ModifNbr ; }
11668	public static function getRemoteClient ( array $ params ) { return new m62Sftp ( [ 'host' => $ params [ 'sftp_host' ] , 'username' => $ params [ 'sftp_username' ] , 'password' => $ params [ 'sftp_password' ] , 'port' => $ params [ 'sftp_port' ] , 'privateKey' => ( isset ( $ params [ 'sftp_private_key' ] ) ? $ params [ 'sftp_private_key' ] : '' ) , 'timeout' => ( ! empty ( $ params [ 'sftp_timeout' ] ) ? $ params [ 'sftp_timeout' ] : '30' ) , 'root' => $ params [ 'sftp_root' ] ] ) ; }
3548	public function create ( $ request ) { $ model = $ this -> repository -> create ( $ request -> all ( ) ) ; $ model -> { $ this -> getShortRelationName ( ) } ( ) -> sync ( $ request -> get ( $ this -> getRelationName ( ) , [ ] ) ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ model ) ) ; return $ model ; }
4503	public function replaceWith ( DOMNode $ replacement ) : void { $ this -> parentNode -> insertBefore ( $ replacement , $ this ) ; $ this -> remove ( ) ; }
4791	function delete ( ) { if ( $ this -> notORM -> freeze ) { return false ; } $ where = $ this -> whereString ( ) ; if ( empty ( $ where ) ) { throw new Exception ( 'sorry, you can not delete the whole table --dogstar' ) ; } $ return = $ this -> query ( "DELETE" . $ this -> topString ( $ this -> limit ) . " FROM $this->table" . $ where , $ this -> parameters ) ; if ( ! $ return ) { return false ; } return $ return -> rowCount ( ) ; }
11618	private function compressPhase2 ( $ calcIdWriteOff , $ calcIdPhase1 , $ calcIdPhase2 , $ scheme ) { $ pv = $ this -> rouGetPv -> exec ( $ calcIdWriteOff ) ; $ dwnlPlain = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdWriteOff ) ; $ dwnlPhase1 = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdPhase1 ) ; $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_CALC_ID_PHASE2 , $ calcIdPhase2 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_SCHEME , $ scheme ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PLAIN , $ dwnlPlain ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PHASE1 , $ dwnlPhase1 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_MAP_PV , $ pv ) ; $ out = $ this -> procCmprsPhase2 -> exec ( $ ctx ) ; $ dwnlPhase2 = $ out -> get ( PCpmrsPhase2 :: OUT_DWNL_PHASE2 ) ; $ legs = $ out -> get ( PCpmrsPhase2 :: OUT_LEGS ) ; $ result = [ $ dwnlPhase2 , $ legs ] ; return $ result ; }
11855	public function getUrlPath ( ) : ? string { $ uri = $ this -> getServerParam ( 'REQUEST_URI' , \ FILTER_SANITIZE_URL ) ; if ( ! is_null ( $ uri ) ) { return parse_url ( $ uri , \ PHP_URL_PATH ) ; } return null ; }
1141	public function setValue ( $ value ) { if ( \ is_bool ( $ value ) ) { if ( 'checkbox' !== $ this -> type ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Invalid argument of type "%s"' , \ gettype ( $ value ) ) ) ; } if ( $ value ) { if ( ! $ this -> element -> isSelected ( ) ) { $ this -> element -> click ( ) ; } } elseif ( $ this -> element -> isSelected ( ) ) { $ this -> element -> click ( ) ; } return ; } foreach ( ( array ) $ value as $ v ) { $ this -> selector -> selectByValue ( $ v ) ; } }
4523	protected function loadDefinition ( $ id ) { $ filename = $ this -> definitionPath . $ id . '.json' ; $ definition = @ file_get_contents ( $ filename ) ; if ( empty ( $ definition ) ) { throw new UnknownZoneException ( $ id ) ; } $ definition = json_decode ( $ definition , true ) ; $ definition [ 'id' ] = $ id ; return $ definition ; }
10409	protected function getUrlsByDocumentParameter ( ) { if ( count ( $ this -> documentParamCache ) < 1 ) { return [ ] ; } $ urls = [ ] ; $ query = new Query ( ) ; $ queryTerms = [ ] ; foreach ( $ this -> documentParamCache as $ param ) { $ queryTerms [ $ param [ 0 ] ] [ ] = $ param [ 1 ] ; } foreach ( $ queryTerms as $ field => $ values ) { $ termQuery = new TermQuery ( $ field , $ values ) ; $ query -> addQuery ( $ termQuery , 'should' ) ; } $ limitFilter = new LimitFilter ( count ( $ this -> documentParamCache ) ) ; $ repository = $ this -> manager -> getRepository ( 'MultiModel' ) ; $ search = $ repository -> createSearch ( ) -> addQuery ( $ query ) -> addFilter ( $ limitFilter ) ; $ documents = $ repository -> execute ( $ search ) ; foreach ( $ documents as $ document ) { if ( is_array ( $ document -> url ) ) { foreach ( $ document -> url as $ url ) { $ urls [ ] = $ url [ 'url' ] ; } } } array_walk ( $ urls , [ $ this , 'addWildcard' ] ) ; $ this -> addUrls ( $ urls ) ; return $ urls ; }
1231	public function resolveOptions ( array $ configuration ) { foreach ( $ configuration as $ key => $ value ) { if ( isset ( $ this -> definitions [ $ key ] ) ) { $ def = $ this -> definitions [ $ key ] ; $ this -> checkType ( $ def [ 'valid' ] , $ key , $ value ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ configuration [ $ key ] , $ configuration ) ; } } } return $ configuration ; }
8005	public static function calculatePayloadOffset ( $ negotiate_flags ) { $ offset = 0 ; $ offset += strlen ( static :: SIGNATURE ) ; $ offset += 4 ; $ offset += 4 ; $ offset += 8 ; $ offset += 8 ; return $ offset ; }
10680	protected function generateURLSegment ( $ title ) { $ filter = URLSegmentFilter :: create ( ) ; $ t = $ filter -> filter ( $ title ) ; if ( ! $ t || $ t == '-' || $ t == '-1' ) { $ t = "{$this->owner->ClassName}-{$this->owner->ID}" ; } else { $ class = $ this -> owner -> ClassName ; $ obj = $ class :: get ( ) -> filter ( array ( "URLSegment" => $ t ) ) -> exclude ( array ( "ID" => $ this -> owner -> ID ) ) -> first ( ) ; if ( $ obj ) { $ t .= "-{$this->owner->ID}" ; } } return $ t ; }
6281	public static function buildDnsResolver ( LoopInterface $ loop , $ dns = '8.8.8.8' ) { $ factory = new DnsResolverFactory ( ) ; return $ factory -> createCached ( $ dns , $ loop ) ; }
11110	private function findExtensionsDirectories ( Container $ app ) { $ directories = $ app [ 'config.finder' ] -> ignoreUnreadableDirs ( ) -> directories ( ) -> name ( '*Extension' ) -> in ( $ app [ 'app.extensions.dir' ] ) -> depth ( '< 3' ) -> sortByName ( ) ; return $ directories ; }
5327	public function end ( string $ profile ) { Craft :: endProfile ( $ profile , Craft :: t ( 'twig-profiler' , self :: CATEGORY_PREFIX ) . TwigProfiler :: $ renderingTemplate ) ; }
8199	public function expect ( $ type , $ value = null , $ message = null ) { $ token = $ this -> tokens [ $ this -> current ] ; if ( ! $ token -> test ( $ type , $ value ) ) { $ line = $ token -> getLine ( ) ; throw new Twig_Error_Syntax ( sprintf ( '%sUnexpected token "%s" of value "%s" ("%s" expected%s).' , $ message ? $ message . '. ' : '' , Twig_Token :: typeToEnglish ( $ token -> getType ( ) ) , $ token -> getValue ( ) , Twig_Token :: typeToEnglish ( $ type ) , $ value ? sprintf ( ' with value "%s"' , $ value ) : '' ) , $ line , $ this -> source ) ; } $ this -> next ( ) ; return $ token ; }
5910	public function createSetting ( $ key , $ value ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'key' => $ key , 'value' => $ value ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/settings' , $ parameters ) ; return $ result ; }
1257	public static function createRuntime ( ) { switch ( $ compileDir = getenv ( self :: COMPILE_DIR ) ) { case false : return new AstRuntime ( ) ; case 'on' : return new CompilerRuntime ( ) ; default : return new CompilerRuntime ( $ compileDir ) ; } }
5920	public function setUpdated ( $ updated ) { if ( $ updated instanceof DateTime ) { $ this -> updated = $ updated ; } else { try { $ this -> updated = new DateTime ( $ updated ) ; } catch ( \ Exception $ e ) { $ this -> updated = null ; } } return $ this ; }
436	public function afterAction ( $ action , $ result ) { $ event = new ActionEvent ( $ action ) ; $ event -> result = $ result ; $ this -> trigger ( self :: EVENT_AFTER_ACTION , $ event ) ; return $ event -> result ; }
5040	public function setPermissions ( PermissionsInterface $ permissions ) { foreach ( $ this -> getImages ( ) as $ file ) { $ filePermissions = $ file -> getPermissions ( ) ; $ filePermissions -> clear ( ) ; $ filePermissions -> inherit ( $ permissions ) ; } return $ this ; }
125	public function whatProvides ( $ name , ConstraintInterface $ constraint = null , $ mustMatchName = false , $ bypassFilters = false ) { if ( $ bypassFilters ) { return $ this -> computeWhatProvides ( $ name , $ constraint , $ mustMatchName , true ) ; } $ key = ( ( int ) $ mustMatchName ) . $ constraint ; if ( isset ( $ this -> providerCache [ $ name ] [ $ key ] ) ) { return $ this -> providerCache [ $ name ] [ $ key ] ; } return $ this -> providerCache [ $ name ] [ $ key ] = $ this -> computeWhatProvides ( $ name , $ constraint , $ mustMatchName , $ bypassFilters ) ; }
5954	public function channelCreate ( array $ properties ) { $ cid = $ this -> execute ( "channelcreate" , $ properties ) -> toList ( ) ; $ this -> channelListReset ( ) ; if ( ! isset ( $ properties [ "client_flag_permanent" ] ) && ! isset ( $ properties [ "client_flag_semi_permanent" ] ) ) { $ this -> getParent ( ) -> whoamiSet ( "client_channel_id" , $ cid [ "cid" ] ) ; } return $ cid [ "cid" ] ; }
7511	protected function parse_linebreak ( ) { if ( $ this -> doc [ $ this -> pos ] === "\r" ) { ++ $ this -> line_pos [ 0 ] ; if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === "\n" ) ) { ++ $ this -> pos ; } $ this -> line_pos [ 1 ] = $ this -> pos ; } elseif ( $ this -> doc [ $ this -> pos ] === "\n" ) { ++ $ this -> line_pos [ 0 ] ; $ this -> line_pos [ 1 ] = $ this -> pos ; } }
2019	private function overwriteImageTargetDir ( array $ config , ContainerBuilder $ container ) : void { if ( ! isset ( $ config [ 'image' ] [ 'target_path' ] ) ) { return ; } $ container -> setParameter ( 'contao.image.target_dir' , $ container -> getParameter ( 'kernel.project_dir' ) . '/' . $ config [ 'image' ] [ 'target_path' ] ) ; @ trigger_error ( 'Using the contao.image.target_path parameter has been deprecated and will no longer work in Contao 5.0. Use the contao.image.target_dir parameter instead.' , E_USER_DEPRECATED ) ; }
3240	public function setCallbacks ( $ order ) { $ this -> callbackSuccess = route ( config ( 'shop.callback_route' ) , [ 'status' => 'success' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; $ this -> callbackFail = route ( config ( 'shop.callback_route' ) , [ 'status' => 'fail' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; }
11058	protected function _getDataStore ( ) { return $ this -> dataStore === null ? $ this -> dataStore = $ this -> _createDataStore ( ) : $ this -> dataStore ; }
8805	protected function driver ( ) { if ( $ this -> getDefaultDriver ( ) === 'argon' ) { return $ this -> createArgonDriver ( ) ; } elseif ( $ this -> getDefaultDriver ( ) === 'argon2id' ) { return $ this -> createArgon2IdDriver ( ) ; } return $ this -> createBcryptDriver ( ) ; }
800	private function findStart ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ $ index ] -> equalsAny ( [ '$' , [ T_VARIABLE ] ] ) ) { if ( $ tokens [ $ index ] -> equals ( ']' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_INDEX_SQUARE_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_PROP_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_PROP_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_VAR_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_VAR_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_INDEX_CURLY_BRACE , $ index ) ; } else { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } } while ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> equals ( '$' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } if ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return $ this -> findStart ( $ tokens , $ tokens -> getPrevMeaningfulToken ( $ index ) ) ; } return $ index ; }
1582	public function withRelationships ( $ relationships ) : self { $ copy = clone $ this ; $ copy -> relationships = collect ( $ relationships ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; }
12865	public function clearQuota ( ) { $ appid = $ this -> getAccessToken ( ) -> getAppId ( ) ; return $ this -> parseJSON ( 'json' , [ self :: API_CLEAR_QUOTA , compact ( 'appid' ) ] ) ; }
3424	protected function normalizeFilter ( ) { $ this -> substituteField ( $ this -> filter , 'GROUPS' , 'GROUPS_ID' ) ; $ this -> substituteField ( $ this -> filter , 'GROUP_ID' , 'GROUPS_ID' ) ; return $ this -> filter ; }
2535	public function getMessagesAndVersions ( ) { if ( empty ( $ this -> messagesAndVersions ) ) { $ this -> messagesAndVersions = WsdlAnalyser :: loadMessagesAndVersions ( $ this -> params -> wsdl ) ; } return $ this -> messagesAndVersions ; }
3553	protected function set ( $ key , $ value , $ group = 'default' ) { $ this -> setMetaKey ( $ key ) ; $ this -> setValue ( $ value ) ; $ this -> setMetaGroup ( $ group ) ; }
9502	public function runPeridot ( InputInterface $ input , OutputInterface $ output ) { global $ argv ; $ command = $ this -> joinCommand ( $ argv ) ; $ process = new Process ( $ command ) ; $ process -> run ( function ( $ type , $ buffer ) use ( $ output ) { $ buffer = preg_replace ( '/\[([\d]{1,2})m/' , "\033[$1m" , $ buffer ) ; $ output -> write ( $ buffer ) ; } ) ; }
4650	private function parseEnvironmentLine ( $ environmentLine ) { $ variables = array ( ) ; @ $ variableLines = explode ( ' ' , $ environmentLine ? : '' ) ; foreach ( $ variableLines as $ variableLine ) { if ( ! empty ( $ variableLine ) ) { list ( $ key , $ value ) = $ this -> parseEnvironementVariable ( $ variableLine ) ; $ variables [ $ key ] = $ value ; } } return $ variables ; }
12388	public function logout ( AdapterChainEvent $ e ) { $ session = new Container ( $ this -> getStorage ( ) -> getNameSpace ( ) ) ; $ session -> getManager ( ) -> forgetMe ( ) ; $ session -> getManager ( ) -> destroy ( ) ; }
4174	public function build ( ) { $ providers = $ this -> getProviders ( ) -> search ( ) ; $ facades = $ this -> getFacades ( ) -> search ( ) ; if ( ! ConfigFile :: instance ( $ providers , $ facades ) -> make ( ) ) { throw new ErrorException ( 'Unable to register providers and facades. Please report this incident at Qafeen/Manager' ) ; } $ this -> getResources ( ) -> publish ( $ providers [ 0 ] ) ; return $ this ; }
834	private function getFunctionyTokenKinds ( ) { static $ tokens = [ T_ARRAY , T_ECHO , T_EMPTY , T_EVAL , T_EXIT , T_INCLUDE , T_INCLUDE_ONCE , T_ISSET , T_LIST , T_PRINT , T_REQUIRE , T_REQUIRE_ONCE , T_UNSET , T_VARIABLE , ] ; return $ tokens ; }
7979	public function getSessionProperties ( $ sessId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionProperties ( $ this -> pp , $ this -> sn , $ sessId ) ) ; }
2255	protected function eliminateNestedPages ( $ arrPages , $ strTable = null , $ blnSorting = false ) { if ( empty ( $ arrPages ) || ! \ is_array ( $ arrPages ) ) { return array ( ) ; } if ( ! $ strTable ) { $ strTable = 'tl_page' ; } $ arrPages = array_intersect ( $ arrPages , $ this -> Database -> getChildRecords ( 0 , $ strTable , $ blnSorting ) ) ; $ arrPages = array_values ( array_diff ( $ arrPages , $ this -> Database -> getChildRecords ( $ arrPages , $ strTable , $ blnSorting ) ) ) ; return $ arrPages ; }
1218	public function setConfig ( array $ configuration ) { $ this -> config = Functions \ arrayMergeDeep ( $ this -> config , $ this -> resolver -> resolveOptions ( $ configuration ) ) ; }
7029	public function getMessagesForQuantity ( float $ quantity ) { $ messages = [ ] ; if ( $ quantity < $ this -> minimumQuantity ) { $ messages [ ] = $ this -> minimumMessage ; } elseif ( 0 < $ this -> maximumQuantity && $ quantity > $ this -> maximumQuantity ) { $ messages [ ] = $ this -> maximumMessage ; } else { if ( null !== $ this -> availableMessage ) { $ messages [ ] = $ this -> availableMessage ; } if ( $ quantity > $ this -> availableQuantity ) { if ( null !== $ this -> resupplyMessage ) { $ messages [ ] = $ this -> resupplyMessage ; if ( $ quantity > $ this -> availableQuantity + $ this -> resupplyQuantity ) { $ messages [ ] = $ this -> overflowMessage ; } } else { $ messages [ ] = $ this -> overflowMessage ; } } } if ( empty ( $ messages ) ) { $ messages [ ] = $ this -> overflowMessage ; } return $ messages ; }
7115	protected function getOneQueryBuilder ( $ alias = null , $ indexBy = null ) { return $ this -> createQueryBuilder ( $ alias , $ indexBy ) -> select ( $ alias , 'customer' , 'customer_group' , 'invoice_address' , 'delivery_address' , 'shipment_method' , 'currency' ) -> leftJoin ( $ alias . '.customer' , 'customer' ) -> leftJoin ( $ alias . '.customerGroup' , 'customer_group' ) -> leftJoin ( $ alias . '.invoiceAddress' , 'invoice_address' ) -> leftJoin ( $ alias . '.deliveryAddress' , 'delivery_address' ) -> leftJoin ( $ alias . '.shipmentMethod' , 'shipment_method' ) -> leftJoin ( $ alias . '.currency' , 'currency' ) -> setMaxResults ( 1 ) ; }
3018	public function createPost ( $ blogName , $ data ) { $ path = $ this -> blogPath ( $ blogName , '/post' ) ; return $ this -> postRequest ( $ path , $ data , false ) ; }
1439	protected function getStub ( ) { if ( $ this -> isIndependent ) { return $ this -> getStubFor ( 'independent' ) ; } if ( $ this -> isEloquent ( ) ) { return $ this -> getStubFor ( 'eloquent' ) ; } return $ this -> getStubFor ( 'abstract' ) ; }
7829	public function getLeftBordersWith ( $ border ) { $ border = str_repeat ( $ border , static :: BORDER_WIDTH ) ; $ space = str_repeat ( ' ' , static :: MIN_SPACE_FROM_BORDER_X ) ; return str_repeat ( "{$border}{$space}" , $ this -> nesting ) ; }
12129	public function failed ( $ fail = true ) { if ( ! func_num_args ( ) ) { return $ this -> _failed ; } $ this -> _failed = $ fail ; return $ this ; }
6323	public function getA ( StringType $ name ) { if ( ! $ this -> hasA ( $ name ) ) { throw new AttributesException ( "Attribute: {$name} does not exist" ) ; } return $ this -> attributes [ $ name ( ) ] ; }
11188	public static function set ( array $ arr , $ k , $ v ) { $ nested = ! is_array ( $ k ) ? explode ( '.' , $ k ) : $ k ; $ count = count ( $ nested ) ; if ( $ count == 1 ) { return $ arr [ $ k ] = $ v ; } elseif ( $ count > 1 ) { $ prev = '' ; $ loop = 1 ; $ unshift = $ nested ; foreach ( $ nested as $ part ) { if ( isset ( $ arr [ $ part ] ) && $ count > $ loop ) { $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; continue ; } else { if ( $ loop > 1 && $ loop < $ count ) { if ( ! isset ( $ arr [ $ prev ] [ $ part ] ) ) $ arr [ $ prev ] [ $ part ] = [ ] ; $ arr [ $ prev ] = static :: set ( $ arr [ $ prev ] , $ unshift , $ v ) ; $ loop ++ ; break ; } elseif ( $ loop >= 1 && $ loop == $ count ) { if ( ! is_array ( $ arr [ $ prev ] ) ) $ arr [ $ prev ] = [ ] ; if ( $ part == '' ) $ arr [ $ prev ] [ ] = $ v ; else $ arr [ $ prev ] [ $ part ] = $ v ; } else { $ arr [ $ part ] = [ ] ; $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; } } } } return $ arr ; }
2649	public function setVclAsMain ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/vcl/' . $ name . '/main' ; $ result = $ this -> _fetch ( $ url , 'PUT' ) ; return $ result ; }
845	public function ensureWhitespaceAtIndex ( $ index , $ indexOffset , $ whitespace ) { $ removeLastCommentLine = static function ( self $ tokens , $ index , $ indexOffset , $ whitespace ) { $ token = $ tokens [ $ index ] ; if ( 1 === $ indexOffset && $ token -> isGivenKind ( T_OPEN_TAG ) ) { if ( 0 === strpos ( $ whitespace , "\r\n" ) ) { $ tokens [ $ index ] = new Token ( [ T_OPEN_TAG , rtrim ( $ token -> getContent ( ) ) . "\r\n" ] ) ; return \ strlen ( $ whitespace ) > 2 ? substr ( $ whitespace , 2 ) : '' ; } $ tokens [ $ index ] = new Token ( [ T_OPEN_TAG , rtrim ( $ token -> getContent ( ) ) . $ whitespace [ 0 ] ] ) ; return \ strlen ( $ whitespace ) > 1 ? substr ( $ whitespace , 1 ) : '' ; } return $ whitespace ; } ; if ( $ this [ $ index ] -> isWhitespace ( ) ) { $ whitespace = $ removeLastCommentLine ( $ this , $ index - 1 , $ indexOffset , $ whitespace ) ; if ( '' === $ whitespace ) { $ this -> clearAt ( $ index ) ; } else { $ this [ $ index ] = new Token ( [ T_WHITESPACE , $ whitespace ] ) ; } return false ; } $ whitespace = $ removeLastCommentLine ( $ this , $ index , $ indexOffset , $ whitespace ) ; if ( '' === $ whitespace ) { return false ; } $ this -> insertAt ( $ index + $ indexOffset , [ new Token ( [ T_WHITESPACE , $ whitespace ] ) , ] ) ; return true ; }
8308	public function assertArrayOfStrings ( $ config , $ key ) { if ( ! array_key_exists ( $ key , $ config ) ) { return $ this ; } if ( ! is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " section must be an array." ) ; } foreach ( $ config [ $ key ] as $ value ) { if ( ! is_string ( $ value ) ) { throw new ConfigurationException ( "Values in the `{$key}` must be strings" . gettype ( $ value ) . " found." ) ; } elseif ( $ value === "" ) { throw new ConfigurationException ( "Empty string not allowed in `{$key}` array." ) ; } } return $ this ; }
12699	static function pake_antpattern ( $ files , $ rootdir ) { $ results = array ( ) ; foreach ( $ files as $ file ) { $ file = str_replace ( '/**/**/' , '/**/' , $ file ) ; $ type = 'any' ; if ( substr ( $ file , - 1 ) == '/' ) { $ type = 'dir' ; $ file = substr ( $ file , 0 , - 1 ) ; } if ( strlen ( $ file ) >= 3 && substr ( $ file , - 3 ) == '/**' ) { $ file .= '/*' ; } $ dir = dirname ( $ file ) ; $ file = basename ( $ file ) ; if ( strpos ( $ dir , '**' ) !== false ) { $ split = explode ( '/' , $ dir ) ; $ path = '' ; foreach ( $ split as $ i => $ part ) { if ( $ part != '**' ) { $ path .= "/$part" ; } else { $ newfile = implode ( '/' , array_slice ( $ split , $ i + 1 ) ) . "/$file" . ( $ type == 'dir' ? '/' : '' ) ; $ dirs = pakeFinder :: type ( 'dir' ) -> in ( $ rootdir . $ path ) ; $ dirs [ ] = $ rootdir . $ path ; foreach ( $ dirs as $ newdir ) { $ found = self :: pake_antpattern ( array ( $ newfile ) , $ newdir ) ; $ results = array_merge ( $ results , $ found ) ; } break ; } } } else { $ found = pakeFinder :: type ( $ type ) -> name ( $ file ) -> maxdepth ( 0 ) -> in ( $ rootdir . '/' . $ dir ) ; $ results = array_merge ( $ results , $ found ) ; } } return $ results ; }
8333	private function getSelectSql ( ) { if ( self :: LOCK_TRANSACTIONAL === $ this -> lockMode ) { $ this -> beginTransaction ( ) ; switch ( $ this -> driver ) { case 'mysql' : case 'oci' : case 'pgsql' : return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WHERE $this->idCol = :id FOR UPDATE" ; case 'sqlsrv' : return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WITH (UPDLOCK, ROWLOCK) WHERE $this->idCol = :id" ; case 'sqlite' : break ; default : throw new \ DomainException ( sprintf ( 'Transactional locks are currently not implemented for PDO driver "%s".' , $ this -> driver ) ) ; } } return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WHERE $this->idCol = :id" ; }
12084	public function getObject ( Entity $ subject ) { $ object = NULL ; $ mediaObjectURI = $ subject -> getObjectURI ( ) ; if ( ! empty ( $ mediaObjectURI ) ) : $ mediaSubject = new Object ( ) ; $ mediaObjectType = $ subject -> getObjectType ( ) ; if ( is_object ( $ mediaSubject ) && method_exists ( $ mediaSubject , "getArray" ) ) : $ object = $ mediaSubject :: getArray ( ) ; endif ; else : endif ; return $ object ; }
6147	public function sendHeaders ( ) { if ( php_sapi_name ( ) !== "cli" && headers_sent ( $ file , $ line ) ) { throw new Exception ( "Try to send headers but headers already sent, output started at $file line $line." ) ; } http_response_code ( $ this -> statusCode ) ; foreach ( $ this -> headers as $ header ) { if ( php_sapi_name ( ) !== "cli" ) { header ( $ header ) ; } } return $ this ; }
3251	public function scopeFindByUser ( $ query , $ userId ) { if ( empty ( $ userId ) ) return ; $ cart = $ query -> whereUser ( $ userId ) -> first ( ) ; if ( empty ( $ cart ) ) { $ cart = call_user_func ( Config :: get ( 'shop.cart' ) . '::create' , [ 'user_id' => $ userId ] ) ; } return $ cart ; }
1725	private static function canGenerateSecret ( array $ config ) : bool { if ( isset ( $ config [ 'file' ] ) ) { return ! is_file ( $ config [ 'file' ] ) ; } foreach ( $ config as $ v ) { if ( \ is_array ( $ v ) && isset ( $ v [ 'file' ] ) && is_file ( $ v [ 'file' ] ) ) { return false ; } } return ! empty ( $ config ) ; }
4550	public function setAssigneeLike ( ? string $ assigneeLike ) { $ this -> assigneeLike = $ assigneeLike ; $ this -> _assigneeLike = null !== $ assigneeLike ; return $ this ; }
12198	public static function toJson ( Serializer $ serializer , \ RedKiteCms \ Content \ Block \ BaseBlock $ block ) { return $ serializer -> serialize ( $ block , 'json' ) ; }
6541	public function fetchOne ( $ tableName , array $ identifier , $ shardingKey = null , $ forceFromMaster = true ) { return $ this -> fetch ( $ tableName , $ identifier , $ shardingKey , array ( '*' ) , false , $ forceFromMaster ) ; }
6666	public function setBodyData ( $ data ) { if ( ! $ data instanceof \ Generator ) { $ this -> body [ static :: DEFAULT_DATA_NAME ] = $ data ; return $ this ; } foreach ( $ data as $ key => $ value ) { $ actualKey = $ key ? : static :: DEFAULT_DATA_NAME ; $ this -> body [ $ actualKey ] = $ value ; } return $ this ; }
8251	protected function isValidUsername ( $ name ) { if ( ! is_string ( $ name ) || ! $ this -> storage -> checkValidName ( $ name ) || strlen ( $ name ) < $ this -> config [ "registration" ] [ "nameLenMin" ] || strlen ( $ name ) > $ this -> config [ "registration" ] [ "nameLenMax" ] ) { return false ; } return true ; }
4462	private function readErrorFromSocket ( $ socket ) : ? string { $ error = '' ; while ( ! empty ( $ res = socket_read ( $ socket , 8192 ) ) ) { $ error .= $ res ; } $ error = unserialize ( $ error ) ; if ( is_array ( $ error ) ) { $ handler = new ErrorFormatter ( ) ; return sprintf ( '%s: %s in %s on line %d' , $ handler -> constant ( $ error [ 'type' ] ) ? : 'Unknown' , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } return null ; }
2028	public static function findPublishedRegularWithoutGuestsByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.type!='root' AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( FE_USER_LOGGED_IN ) { $ arrColumns [ ] = "$t.guests=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
11204	public function where ( $ key = false , $ desiredValue , $ op = "==" ) { $ collection = $ this -> getIterator ( ) ; $ subset = new Collection ( ) ; foreach ( $ collection as $ prop => $ result ) { $ realValue = $ result ; if ( is_object ( $ result ) ) { $ realValue = $ result -> $ key ; } else if ( is_array ( $ result ) ) { $ realValue = $ result [ $ key ] ; } $ add = false ; if ( $ op == '==' && $ realValue == $ desiredValue ) { $ add = true ; } else if ( $ op == '>=' && $ realValue >= $ desiredValue ) { $ add = true ; } else if ( $ op == '<=' && $ realValue <= $ desiredValue ) { $ add = true ; } else if ( $ op == '>' && $ realValue > $ desiredValue ) { $ add = true ; } else if ( $ op == '<' && $ realValue < $ desiredValue ) { $ add = true ; } else if ( $ op == '===' && $ realValue === $ desiredValue ) { $ add = true ; } else if ( $ op == '!=' && $ realValue != $ desiredValue ) { $ add = true ; } if ( $ add ) { $ subset -> add ( $ result , $ prop ) ; } } return $ subset ; }
6667	public function prepareResponse ( ) { if ( ! $ this -> writer ) { $ this -> writer = $ this -> writerFactory -> getWriterFor ( $ this -> request -> getFormats ( ) ) ; } $ this -> preparedResponse = $ this -> writer -> format ( $ this -> getBody ( ) , $ this -> responseName ) ; return $ this ; }
390	public function loadDefaultValues ( $ skipIfSet = true ) { foreach ( static :: getTableSchema ( ) -> columns as $ column ) { if ( $ column -> defaultValue !== null && ( ! $ skipIfSet || $ this -> { $ column -> name } === null ) ) { $ this -> { $ column -> name } = $ column -> defaultValue ; } } return $ this ; }
7161	private function initialize ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> lineNumber = 1 ; $ this -> view = new SaleView ( ) ; $ this -> types = $ this -> registry -> getTypesForSale ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> configureOptions ( $ sale , $ this -> view , $ options ) ; } $ this -> options = $ this -> getOptionsResolver ( ) -> resolve ( $ options ) ; $ this -> view -> setTemplate ( $ this -> options [ 'template' ] ) ; if ( ! is_null ( $ this -> options [ 'ati' ] ) ) { $ this -> view -> setAti ( $ this -> options [ 'ati' ] ) ; } else { $ this -> view -> setAti ( $ sale -> isAtiDisplayMode ( ) ) ; } $ this -> formatter = $ this -> formatterFactory -> create ( $ this -> options [ 'locale' ] , $ sale -> getCurrency ( ) -> getCode ( ) ) ; foreach ( $ this -> types as $ type ) { $ type -> setFormatter ( $ this -> formatter ) ; } }
3988	public function getChildrenOf ( $ parentTable ) { $ inputScreens = array_filter ( $ this -> getInputScreens ( ) , function ( $ inputScreen ) use ( $ parentTable ) { return ( $ inputScreen [ 'meta' ] [ 'rendertype' ] === 'ctable' ) && ( $ inputScreen [ 'meta' ] [ 'ptable' ] === $ parentTable ) ; } ) ; return $ inputScreens ; }
7945	public function ipDeleteMonitoringNotification ( $ id , $ ip , $ notificationId ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Missing parameter $ip.' ) ; if ( ! $ notificationId ) throw new BadMethodCallException ( 'Missing parameter $notificationId.' ) ; try { $ r = $ this -> delete ( 'xdsl/' . $ id . '/ips/' . $ ip . '/monitoringNotifications/' . $ notificationId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
555	private function notifyNotFoundCaches ( $ cachesNames ) { $ this -> stdout ( "The following cache components were NOT found:\n\n" , Console :: FG_RED ) ; foreach ( $ cachesNames as $ name ) { $ this -> stdout ( "\t* $name \n" , Console :: FG_GREEN ) ; } $ this -> stdout ( "\n" ) ; }
5369	protected function isOnlyAscii ( $ ascii ) { for ( $ i = 0 , $ length = strlen ( $ ascii ) ; $ i < $ length ; $ i ++ ) { if ( ord ( $ ascii [ $ i ] ) > 127 ) { return false ; } } return true ; }
646	public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> checkIntegrity ( $ check , $ schema , $ table ) ; return $ this -> setSql ( $ sql ) ; }
5479	protected function addRadioButton ( $ tag ) { if ( ! isset ( $ this -> radios [ $ tag -> getName ( ) ] ) ) { $ this -> widgets [ ] = new SimpleRadioGroup ( ) ; $ this -> radios [ $ tag -> getName ( ) ] = count ( $ this -> widgets ) - 1 ; } $ this -> widgets [ $ this -> radios [ $ tag -> getName ( ) ] ] -> addWidget ( $ tag ) ; }
680	protected function validateConjunctionCondition ( $ operator , $ condition ) { if ( ! is_array ( $ condition ) || ! ArrayHelper :: isIndexed ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; return ; } foreach ( $ condition as $ part ) { $ this -> validateCondition ( $ part ) ; } }
3430	protected function rememberInCache ( $ key , $ minutes , Closure $ callback ) { $ minutes = ( double ) $ minutes ; if ( $ minutes <= 0 ) { return $ callback ( ) ; } $ cache = Cache :: createInstance ( ) ; if ( $ cache -> initCache ( $ minutes * 60 , $ key , '/bitrix-models' ) ) { $ vars = $ cache -> getVars ( ) ; return ! empty ( $ vars [ 'isCollection' ] ) ? new Collection ( $ vars [ 'cache' ] ) : $ vars [ 'cache' ] ; } $ cache -> startDataCache ( ) ; $ result = $ callback ( ) ; $ isCollection = $ result instanceof Collection ; if ( $ isCollection ) { $ result = $ result -> all ( ) ; } $ cache -> endDataCache ( [ 'cache' => $ result , 'isCollection' => $ isCollection ] ) ; return $ isCollection ? new Collection ( $ result ) : $ result ; }
499	protected function writeInteger ( $ fileHandle , $ integer ) { return $ this -> writeBytes ( $ fileHandle , pack ( $ this -> useBigEndian ? 'N' : 'V' , ( int ) $ integer ) ) ; }
9870	private function writePageSetup ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'pageSetup' ) ; $ objWriter -> writeAttribute ( 'paperSize' , $ pSheet -> getPageSetup ( ) -> getPaperSize ( ) ) ; $ objWriter -> writeAttribute ( 'orientation' , $ pSheet -> getPageSetup ( ) -> getOrientation ( ) ) ; if ( $ pSheet -> getPageSetup ( ) -> getScale ( ) !== null ) { $ objWriter -> writeAttribute ( 'scale' , $ pSheet -> getPageSetup ( ) -> getScale ( ) ) ; } if ( $ pSheet -> getPageSetup ( ) -> getFitToHeight ( ) !== null ) { $ objWriter -> writeAttribute ( 'fitToHeight' , $ pSheet -> getPageSetup ( ) -> getFitToHeight ( ) ) ; } else { $ objWriter -> writeAttribute ( 'fitToHeight' , '0' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getFitToWidth ( ) !== null ) { $ objWriter -> writeAttribute ( 'fitToWidth' , $ pSheet -> getPageSetup ( ) -> getFitToWidth ( ) ) ; } else { $ objWriter -> writeAttribute ( 'fitToWidth' , '0' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getFirstPageNumber ( ) !== null ) { $ objWriter -> writeAttribute ( 'firstPageNumber' , $ pSheet -> getPageSetup ( ) -> getFirstPageNumber ( ) ) ; $ objWriter -> writeAttribute ( 'useFirstPageNumber' , '1' ) ; } $ objWriter -> endElement ( ) ; }
2131	public function save ( ) { if ( $ this -> strTop == '' ) { $ this -> strTop = '<?php' ; } $ strFile = trim ( $ this -> strTop ) . "\n\n" ; $ strFile .= "### INSTALL SCRIPT START ###\n" ; foreach ( $ this -> arrData as $ k => $ v ) { $ strFile .= "$k = $v\n" ; } $ strFile .= "### INSTALL SCRIPT STOP ###\n" ; $ this -> strBottom = trim ( $ this -> strBottom ) ; if ( $ this -> strBottom != '' ) { $ strFile .= "\n" . $ this -> strBottom . "\n" ; } $ strTemp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objFile = fopen ( $ this -> strRootDir . '/system/tmp/' . $ strTemp , 'wb' ) ; fwrite ( $ objFile , $ strFile ) ; fclose ( $ objFile ) ; if ( ! filesize ( $ this -> strRootDir . '/system/tmp/' . $ strTemp ) ) { System :: log ( 'The local configuration file could not be written. Have your reached your quota limit?' , __METHOD__ , TL_ERROR ) ; return ; } $ this -> Files -> chmod ( 'system/tmp/' . $ strTemp , 0666 & ~ umask ( ) ) ; $ this -> Files -> rename ( 'system/tmp/' . $ strTemp , 'system/config/localconfig.php' ) ; if ( \ function_exists ( 'opcache_invalidate' ) ) { opcache_invalidate ( $ this -> strRootDir . '/system/config/localconfig.php' , true ) ; } if ( \ function_exists ( 'apc_compile_file' ) && ! ini_get ( 'apc.stat' ) ) { apc_compile_file ( $ this -> strRootDir . '/system/config/localconfig.php' ) ; } $ this -> blnIsModified = false ; }
4074	protected function resolve ( ) { $ factory = $ this -> container -> getFactory ( ) ; $ names = $ factory -> collectNames ( ) ; foreach ( $ names as $ name ) { $ this -> information [ $ name ] = array ( self :: COMBINATION => null , self :: INPUTSCREEN => null , self :: RENDERSETTING => null , self :: MODELID => null , ) ; } $ found = $ this -> getPaletteCombinationRows ( ) ; if ( ! $ found ) { $ found = array ( ) ; } foreach ( array_keys ( $ this -> information ) as $ tableName ) { if ( empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] ) || empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] [ 'dca_id' ] ) || empty ( $ this -> information [ $ tableName ] [ self :: COMBINATION ] [ 'view_id' ] ) ) { unset ( $ this -> information [ $ tableName ] ) ; } } $ this -> fetchInputScreenDetails ( ) ; }
5922	public function setPropertySets ( array $ propertySets ) { $ this -> propertySets = [ ] ; foreach ( $ propertySets as $ item ) { $ this -> addPropertySet ( $ item ) ; } return $ this ; }
475	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "delete from $table" ) ; $ this -> db -> createCommand ( ) -> delete ( $ table , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
2587	protected function loadCreatePnr ( PnrCreatePnrOptions $ params ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; $ tattooCounter = 0 ; if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; }
2650	public function validateServiceVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/validate' ; $ result = $ this -> _fetch ( $ url , 'GET' ) ; if ( $ result -> status == 'error' ) { throw new LocalizedException ( __ ( 'Failed to validate service version: ' . $ result -> msg ) ) ; } }
7771	protected function fetchMessage ( $ field , $ rule ) { if ( isset ( $ this -> fieldMessages [ $ field ] [ $ rule ] ) ) { return $ this -> fieldMessages [ $ field ] [ $ rule ] ; } if ( isset ( $ this -> ruleMessages [ $ rule ] ) ) { return $ this -> ruleMessages [ $ rule ] ; } return $ this -> usedRules [ $ rule ] -> error ( ) ; }
1616	public function count ( $ q = '*' , $ db = null ) { if ( $ this -> emulateExecution ) { return 0 ; } if ( $ this -> where === null ) { $ modelClass = $ this -> modelClass ; if ( $ db === null ) { $ db = $ modelClass :: getDb ( ) ; } return $ db -> executeCommand ( 'LLEN' , [ $ modelClass :: keyPrefix ( ) ] ) ; } else { return $ this -> executeScript ( $ db , 'Count' ) ; } }
11611	public function move ( $ path , $ filename = null ) { $ newFilename = ( $ filename != null ) ? $ filename : $ this -> filename ; $ lastSlash = substr ( $ path , strlen ( $ path ) , 1 ) ; if ( $ lastSlash !== '/' ) { $ path .= '/' ; } $ result = move_uploaded_file ( $ this -> realPath , $ path . $ newFilename ) ; return $ result ; }
8056	public function setChildProcessTitleFormat ( $ string ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Parent\'s Process Title Format for a created pool.' ) ; } $ this -> childProcessTitleFormat = ProcessDetails :: sanitizeProcessTitleFormat ( $ string ) ; return $ this ; }
7704	function OpenDoc_MsExcelCompatibility ( & $ Txt ) { $ el_tbl = 'table:table' ; $ el_col = 'table:table-column' ; $ el_row = 'table:table-row' ; $ el_cell = 'table:table-cell' ; $ att_rep_col = 'table:number-columns-repeated' ; $ att_rep_row = 'table:number-rows-repeated' ; $ loop = array ( $ att_rep_col , $ att_rep_row ) ; foreach ( $ loop as $ att_rep ) { $ p = 0 ; while ( $ xml = clsTbsXmlLoc :: FindElementHavingAtt ( $ Txt , $ att_rep , $ p ) ) { $ xml -> FindName ( ) ; $ p = $ xml -> PosEnd ; $ next = clsTbsXmlLoc :: FindStartTagByPrefix ( $ Txt , '' , $ p ) ; $ next_name = $ next -> Name ; if ( $ next_name == '' ) { $ next_name = $ next -> GetSrc ( ) ; $ next_name = substr ( $ next_name , 1 , strlen ( $ next_name ) - 2 ) ; } ; $ z_src = $ next -> GetSrc ( ) ; $ delete = false ; if ( ( $ xml -> Name == $ el_col ) && ( $ xml -> SelfClosing ) ) { if ( ( $ next_name == $ el_row ) || ( $ next_name == '/' . $ el_tbl ) ) { $ delete = true ; } } elseif ( ( $ xml -> Name == $ el_cell ) && ( $ xml -> SelfClosing ) ) { if ( $ next_name == '/' . $ el_row ) { $ delete = true ; } } elseif ( $ xml -> Name == $ el_row ) { if ( $ next_name == '/' . $ el_tbl ) { $ inner_src = '' . $ xml -> GetInnerSrc ( ) ; if ( strpos ( $ inner_src , '<' ) === false ) { $ delete = true ; } } } if ( $ delete ) { $ p = $ xml -> PosBeg ; $ xml -> Delete ( ) ; } } } }
2247	public static function generateMargin ( $ arrValues , $ strType = 'margin' ) { if ( ! \ is_array ( $ arrValues ) ) { $ arrValues = array ( 'top' => '' , 'right' => '' , 'bottom' => '' , 'left' => '' , 'unit' => '' ) ; } $ top = $ arrValues [ 'top' ] ; $ right = $ arrValues [ 'right' ] ; $ bottom = $ arrValues [ 'bottom' ] ; $ left = $ arrValues [ 'left' ] ; if ( $ top != '' && $ right != '' && $ bottom != '' && $ left != '' ) { if ( $ top == $ right && $ top == $ bottom && $ top == $ left ) { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ';' ; } elseif ( $ top == $ bottom && $ right == $ left ) { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ' ' . $ left . $ arrValues [ 'unit' ] . ';' ; } elseif ( $ top != $ bottom && $ right == $ left ) { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ' ' . $ right . $ arrValues [ 'unit' ] . ' ' . $ bottom . $ arrValues [ 'unit' ] . ';' ; } else { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ' ' . $ right . $ arrValues [ 'unit' ] . ' ' . $ bottom . $ arrValues [ 'unit' ] . ' ' . $ left . $ arrValues [ 'unit' ] . ';' ; } } $ return = array ( ) ; $ arrDir = compact ( 'top' , 'right' , 'bottom' , 'left' ) ; foreach ( $ arrDir as $ k => $ v ) { if ( $ v != '' ) { $ return [ ] = $ strType . '-' . $ k . ':' . $ v . $ arrValues [ 'unit' ] . ';' ; } } return implode ( $ return ) ; }
11763	public function replace ( $ needle , $ replacement ) : Pipeline { $ stages = [ ] ; $ found = false ; foreach ( $ this -> stages as $ stage ) { if ( $ this -> matches ( $ stage , $ needle ) ) { $ stages [ ] = $ replacement ; $ found = true ; continue ; } $ stages [ ] = $ stage ; } if ( $ found ) { $ pipeline = clone $ this ; $ pipeline -> stages = $ stages ; return $ pipeline ; } unset ( $ stages ) ; return $ this ; }
8957	public function redaction ( $ element , $ id , $ version , $ redactionId ) { if ( $ element != 'node' && $ element != 'way' && $ element != 'relation' ) { throw new \ DomainException ( 'Element should be a node, a way or a relation' ) ; } $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = $ element . '/' . $ id . '/' . $ version . '/redact?redaction=' . $ redactionId ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters ) ; return simplexml_load_string ( $ response -> body ) ; }
7637	public function getBlobProperties ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; return $ this -> getBlobInstance ( $ containerName , $ blobName , $ snapshotId , $ leaseId ) ; }
3389	public function redirectAfterRegistrationPath ( ) { if ( method_exists ( $ this , 'redirectAfterRegistrationTo' ) ) { return $ this -> redirectAfterRegistrationTo ( ) ; } return property_exists ( $ this , 'redirectAfterRegistrationTo' ) ? $ this -> redirectAfterRegistrationTo : route ( 'login' ) ; }
369	public function getViewNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _viewNames [ $ schema ] ) || $ refresh ) { $ this -> _viewNames [ $ schema ] = $ this -> findViewNames ( $ schema ) ; } return $ this -> _viewNames [ $ schema ] ; }
6099	protected function put ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_PUT , null , $ fireAndForget ) ; }
1809	public function getContentElementGroup ( $ element ) { foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { if ( $ kk == $ element ) { return $ k ; } } } return null ; }
10163	private function readSheetLayout ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ offset = 0 ; if ( ! $ this -> readDataOnly ) { $ sz = self :: getInt4d ( $ recordData , 12 ) ; switch ( $ sz ) { case 0x14 : $ colorIndex = self :: getUInt2d ( $ recordData , 16 ) ; $ color = Xls \ Color :: map ( $ colorIndex , $ this -> palette , $ this -> version ) ; $ this -> phpSheet -> getTabColor ( ) -> setRGB ( $ color [ 'rgb' ] ) ; break ; case 0x28 : return ; break ; } } }
12008	public function getMessages ( $ domain = 'default' , $ locale = null ) { if ( $ locale === null ) { $ locale = $ this -> getLocale ( ) ; } if ( ! isset ( $ this -> messages [ $ domain ] [ $ locale ] ) ) { $ this -> loadMessages ( $ domain , $ locale ) ; } return $ this -> messages [ $ domain ] [ $ locale ] ; }
6336	public function overlay ( $ title , $ message , $ level = 'info' , $ key = 'flash_message' ) { return $ this -> create ( $ title , $ message , $ level , $ key . '_overlay' ) ; }
6008	protected function init ( $ ftkey ) { if ( strlen ( $ ftkey ) != 32 ) { throw new Ts3Exception ( "invalid file transfer key format" ) ; } $ this -> getProfiler ( ) -> start ( ) ; $ this -> getTransport ( ) -> send ( $ ftkey ) ; Signal :: getInstance ( ) -> emit ( "filetransferHandshake" , $ this ) ; }
2275	public function getLayoutSections ( ) { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; $ objLayout = $ this -> Database -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = Contao \ StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ arrSections [ ] = $ v [ 'id' ] ; } } } } return Contao \ Backend :: convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) ; }
10723	public function raw ( $ sql , array $ params ) { $ stmt = $ this -> connect ( ) -> prepare ( $ sql ) ; $ stmt -> execute ( $ params ) ; if ( stripos ( $ sql , 'select' ) === 0 ) { return $ stmt -> fetchAll ( PDO :: FETCH_ASSOC ) ; } if ( stripos ( $ sql , 'insert' ) === 0 ) { return $ this -> connect ( ) -> lastInsertId ( ) ; } return $ stmt -> execute ( ) ; }
4805	public function getLowestFreeIndexNumber ( ) { $ query = $ this -> createQuery ( ) ; $ query -> statement ( 'SELECT index_number from ' . strtolower ( $ this -> objectType ) . ' WHERE deleted=0' ) ; $ index = 1 ; $ results = $ query -> execute ( true ) ; if ( false === is_array ( $ results ) || sizeof ( $ results ) < 1 ) { return $ index ; } $ indexes = array ( ) ; foreach ( $ results as $ result ) { $ indexes [ ] = ( integer ) $ result [ 'index_number' ] ; } for ( $ index = 1 ; $ index <= sizeof ( $ indexes ) + 1 ; $ index ++ ) { if ( false === in_array ( $ index , $ indexes ) ) { break ; } } return $ index ; }
5202	public function open ( ) { try { $ additionalConnectionOptions = array ( ) ; foreach ( array ( 'connection_timeout' , 'read_write_timeout' , 'keepalive' , 'heartbeat' ) as $ option ) { if ( isset ( $ this -> $ option ) ) { $ additionalConnectionOptions [ $ option ] = $ this -> $ option ; } } $ this -> AMQPConnection = new AMQPSSLConnection ( $ this -> host , $ this -> port , $ this -> username , $ this -> password , $ this -> vhost , $ this -> ssl_context_options , $ additionalConnectionOptions ) ; $ this -> channel = $ this -> AMQPConnection -> channel ( ) ; $ this -> channel -> queue_declare ( $ this -> queue_name , false , false , false , false ) ; $ this -> channel -> exchange_declare ( $ this -> exchange , $ this -> exchange_type , false , true , false ) ; $ this -> channel -> queue_bind ( $ this -> queue_name , $ this -> exchange ) ; } catch ( Exception $ e ) { throw new Exception ( $ e ) ; } }
6900	public function close ( ) : void { if ( $ this -> is_active ( ) ) { $ this -> _data [ 'last_active' ] = time ( ) ; config ( 'debug' ) ? session_write_close ( ) : @ session_write_close ( ) ; } }
12644	public function getSystemId ( ) { if ( ! isset ( $ this -> _systemId ) ) { if ( isset ( $ this -> collectorItem ) && isset ( $ this -> collectorItem -> systemId ) ) { $ this -> _systemId = $ this -> collectorItem -> systemId ; } } return $ this -> _systemId ; }
9991	private function writeChartInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getChartCollection ( ) as $ chart ) { if ( $ chart instanceof Chart ) { $ chartCoordinates = $ chart -> getTopLeftPosition ( ) ; if ( $ chartCoordinates [ 'cell' ] == $ coordinates ) { $ chartFileName = File :: sysGetTempDir ( ) . '/' . uniqid ( '' , true ) . '.png' ; if ( ! $ chart -> render ( $ chartFileName ) ) { return ; } $ html .= PHP_EOL ; $ imageDetails = getimagesize ( $ chartFileName ) ; if ( $ fp = fopen ( $ chartFileName , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ chartFileName ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ chartCoordinates [ 'xOffset' ] . 'px; top: ' . $ chartCoordinates [ 'yOffset' ] . 'px; width: ' . $ imageDetails [ 0 ] . 'px; height: ' . $ imageDetails [ 1 ] . 'px;" src="' . $ imageData . '" border="0" />' . PHP_EOL ; $ html .= '</div>' ; unlink ( $ chartFileName ) ; } } } } return $ html ; }
11348	public function getField ( $ name ) { foreach ( $ this -> fields as $ field ) { if ( $ field -> getName ( ) == $ name ) return $ field ; } throw new FieldNotFoundException ( $ name ) ; }
3923	protected function getConnection ( ) { if ( null === $ this -> connection ) { @ trigger_error ( 'Connection is missing in class ' . static :: class . '. The automatic fallback will be dropped in MetaModels 3.0. Please use dependency injection' , E_USER_DEPRECATED ) ; return $ this -> connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; } return $ this -> connection ; }
4900	public static function loadDotEnv ( ) { $ dotenv = new Dotenv ( ) ; if ( is_file ( getcwd ( ) . '/.env.dist' ) ) { $ dotenv -> load ( getcwd ( ) . '/.env.dist' ) ; } if ( is_file ( $ file = getcwd ( ) . '/.env' ) ) { $ dotenv -> load ( $ file ) ; } if ( false === getenv ( 'TIMEZONE' ) ) { putenv ( 'TIMEZONE=Europe/Berlin' ) ; } date_default_timezone_set ( getenv ( 'TIMEZONE' ) ) ; }
3882	private function determineJumpToInformation ( ) { $ translated = $ this -> metaModel -> isTranslated ( ) ; $ desiredLanguage = $ this -> metaModel -> getActiveLanguage ( ) ; $ fallbackLanguage = $ this -> metaModel -> getFallbackLanguage ( ) ; $ jumpToPageId = '' ; $ filterSettingId = '' ; if ( ! isset ( $ this -> jumpToCache [ $ desiredLanguage . '.' . $ fallbackLanguage ] ) ) { foreach ( ( array ) $ this -> get ( 'jumpTo' ) as $ jumpTo ) { $ langCode = $ jumpTo [ 'langcode' ] ; if ( ! $ translated || ( $ langCode == $ desiredLanguage ) || ( $ langCode == $ fallbackLanguage ) ) { $ jumpToPageId = $ jumpTo [ 'value' ] ; $ filterSettingId = $ jumpTo [ 'filter' ] ; if ( $ desiredLanguage == $ jumpTo [ 'langcode' ] ) { break ; } } } $ pageDetails = $ this -> getPageDetails ( $ jumpToPageId ) ; $ filterSetting = $ filterSettingId ? $ this -> getFilterFactory ( ) -> createCollection ( $ filterSettingId ) : null ; $ this -> jumpToCache [ $ desiredLanguage . '.' . $ fallbackLanguage ] = array ( 'page' => $ jumpToPageId , 'pageDetails' => $ pageDetails , 'filter' => $ filterSettingId , 'filterSetting' => $ filterSetting , 'language' => $ pageDetails [ 'language' ] , 'label' => $ this -> getJumpToLabel ( ) ) ; } return $ this -> jumpToCache [ $ desiredLanguage . '.' . $ fallbackLanguage ] ; }
107	public function prohibitUrlByConfig ( $ url , IOInterface $ io = null ) { if ( false === filter_var ( $ url , FILTER_VALIDATE_URL ) ) { return ; } $ scheme = parse_url ( $ url , PHP_URL_SCHEME ) ; if ( in_array ( $ scheme , array ( 'http' , 'git' , 'ftp' , 'svn' ) ) ) { if ( $ this -> get ( 'secure-http' ) ) { throw new TransportException ( "Your configuration does not allow connections to $url. See https://getcomposer.org/doc/06-config.md#secure-http for details." ) ; } elseif ( $ io ) { $ host = parse_url ( $ url , PHP_URL_HOST ) ; if ( ! isset ( $ this -> warnedHosts [ $ host ] ) ) { $ io -> writeError ( "<warning>Warning: Accessing $host over $scheme which is an insecure protocol.</warning>" ) ; } $ this -> warnedHosts [ $ host ] = true ; } } }
11043	function is_space ( $ char ) { $ asc = ord ( $ char ) ; if ( $ asc == 32 ) { return TRUE ; } elseif ( $ asc > 8 && $ asc < 14 ) { return TRUE ; } return FALSE ; }
2027	public static function findPublishedRegularWithoutGuestsByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ") AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( empty ( $ arrOptions [ 'includeRoot' ] ) ) { $ arrColumns [ ] = "$t.type!='root'" ; } if ( FE_USER_LOGGED_IN ) { $ arrColumns [ ] = "$t.guests=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.id" , $ arrIds ) ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
3708	protected function checkRedirect ( $ widgets , $ wantedParameter , $ allParameter ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the new "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( Input :: post ( 'FORM_SUBMIT' ) != $ this -> formId ) { return ; } $ redirectParameters = $ allParameter [ 'other' ] ; foreach ( $ wantedParameter as $ widgetName ) { $ filter = $ widgets [ $ widgetName ] ; if ( $ filter [ 'urlvalue' ] !== null ) { $ redirectParameters [ $ widgetName ] = $ filter [ 'urlvalue' ] ; } } $ filterUrl = new FilterUrl ( $ this -> objFilterConfig -> getJumpTo ( ) , [ ] , $ redirectParameters ) ; $ dispatcher = $ this -> getDispatcher ( ) ; $ dispatcher -> dispatch ( ContaoEvents :: CONTROLLER_REDIRECT , new RedirectEvent ( $ this -> filterUrlBuilder -> generate ( $ filterUrl ) ) ) ; }
1864	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( $ request -> isMethod ( 'POST' ) ) { return ; } if ( null === ( $ session = $ request -> getSession ( ) ) || ! $ session -> isStarted ( ) ) { return ; } $ this -> clearLegacyAttributeBags ( 'FE_DATA' ) ; $ this -> clearLegacyAttributeBags ( 'BE_DATA' ) ; $ this -> clearLegacyFormData ( ) ; }
8201	protected function exportJob ( $ job ) { $ stats = $ this -> getJobStats ( $ job ) ; $ contents = $ this -> renderForExport ( $ job , $ stats ) ; $ filename = trim ( $ this -> path , '/' ) . '/' . $ this -> buildJobFileName ( $ job , $ stats ) ; if ( file_exists ( $ filename ) ) { throw new \ RuntimeException ( 'File already exists.' ) ; } if ( ! file_put_contents ( $ filename , $ contents ) ) { throw new \ RuntimeException ( 'Error saving the file.' ) ; } }
1839	protected static function find ( array $ arrOptions ) { if ( static :: $ strTable == '' ) { return null ; } if ( $ arrOptions [ 'return' ] == 'Model' ) { $ arrColumn = ( array ) $ arrOptions [ 'column' ] ; if ( \ count ( $ arrColumn ) == 1 ) { $ arrColumn [ 0 ] = preg_replace ( '/^' . preg_quote ( static :: getTable ( ) , '/' ) . '\./' , '' , $ arrColumn [ 0 ] ) ; if ( $ arrColumn [ 0 ] == static :: $ strPk || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) { $ varKey = \ is_array ( $ arrOptions [ 'value' ] ) ? $ arrOptions [ 'value' ] [ 0 ] : $ arrOptions [ 'value' ] ; $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varKey , $ arrColumn [ 0 ] ) ; if ( $ objModel !== null ) { return $ objModel ; } } } } $ arrOptions [ 'table' ] = static :: $ strTable ; $ strQuery = static :: buildFindQuery ( $ arrOptions ) ; $ objStatement = Database :: getInstance ( ) -> prepare ( $ strQuery ) ; if ( ! isset ( $ arrOptions [ 'limit' ] ) ) { $ arrOptions [ 'limit' ] = 0 ; } if ( ! isset ( $ arrOptions [ 'offset' ] ) ) { $ arrOptions [ 'offset' ] = 0 ; } if ( $ arrOptions [ 'limit' ] > 0 || $ arrOptions [ 'offset' ] > 0 ) { $ objStatement -> limit ( $ arrOptions [ 'limit' ] , $ arrOptions [ 'offset' ] ) ; } $ objStatement = static :: preFind ( $ objStatement ) ; $ objResult = $ objStatement -> execute ( $ arrOptions [ 'value' ] ) ; if ( $ objResult -> numRows < 1 ) { return $ arrOptions [ 'return' ] == 'Array' ? array ( ) : null ; } $ objResult = static :: postFind ( $ objResult ) ; if ( $ arrOptions [ 'return' ] == 'Model' ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ objResult -> { static :: $ strPk } ) ; if ( $ objModel !== null ) { return $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; } return static :: createModelFromDbResult ( $ objResult ) ; } elseif ( $ arrOptions [ 'return' ] == 'Array' ) { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) -> getModels ( ) ; } else { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) ; } }
85	public function getPackageFilename ( PackageInterface $ package ) { $ nameParts = array ( preg_replace ( '#[^a-z0-9-_]#i' , '-' , $ package -> getName ( ) ) ) ; if ( preg_match ( '{^[a-f0-9]{40}$}' , $ package -> getDistReference ( ) ) ) { array_push ( $ nameParts , $ package -> getDistReference ( ) , $ package -> getDistType ( ) ) ; } else { array_push ( $ nameParts , $ package -> getPrettyVersion ( ) , $ package -> getDistReference ( ) ) ; } if ( $ package -> getSourceReference ( ) ) { $ nameParts [ ] = substr ( sha1 ( $ package -> getSourceReference ( ) ) , 0 , 6 ) ; } $ name = implode ( '-' , array_filter ( $ nameParts , function ( $ p ) { return ! empty ( $ p ) ; } ) ) ; return str_replace ( '/' , '-' , $ name ) ; }
6285	public static function unsignedShiftRight ( $ a , $ b ) { if ( $ b == 0 ) { return $ a ; } if ( $ a & 0x80000000 ) { return ( ( $ a & 0x7fffffff ) >> $ b ) | ( 0x40000000 >> ( $ b - 1 ) ) ; } else { return $ a >> $ b ; } }
12660	public function removeAll ( ) { $ fs = $ this -> env -> getFileSystem ( ) ; $ fs -> deleteFile ( $ this -> baseDir . $ this -> pageName . '.js' ) ; $ fs -> deleteFile ( $ this -> outdatedDir . $ this -> baseLang . '/' . $ this -> pageName . '.json' ) ; foreach ( $ this -> extraLangs as $ language ) { $ fs -> deleteFile ( $ this -> baseDir . $ language . '/' . $ this -> pageName . '.js' ) ; $ fs -> deleteFile ( $ this -> outdatedDir . $ language . '/' . $ this -> pageName . '.json' ) ; } }
4681	public static function start ( string $ key = 'default' ) : void { if ( isset ( self :: $ timers [ $ key ] ) ) { self :: $ timers [ $ key ] -> start ( ) ; } else { self :: $ timers [ $ key ] = new Stopwatch ( ) ; } }
9822	public function writeRelationships ( Spreadsheet $ spreadsheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ customPropertyList = $ spreadsheet -> getProperties ( ) -> getCustomProperties ( ) ; if ( ! empty ( $ customPropertyList ) ) { $ this -> writeRelationship ( $ objWriter , 4 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties' , 'docProps/custom.xml' ) ; } $ this -> writeRelationship ( $ objWriter , 3 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties' , 'docProps/app.xml' ) ; $ this -> writeRelationship ( $ objWriter , 2 , 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties' , 'docProps/core.xml' ) ; $ this -> writeRelationship ( $ objWriter , 1 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' , 'xl/workbook.xml' ) ; if ( $ spreadsheet -> hasRibbon ( ) ) { $ this -> writeRelationShip ( $ objWriter , 5 , 'http://schemas.microsoft.com/office/2006/relationships/ui/extensibility' , $ spreadsheet -> getRibbonXMLData ( 'target' ) ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
7135	public function getPercent ( ) : float { $ amount = $ this -> getAmount ( ) ; if ( 0 < $ this -> sellingPrice ) { return round ( $ amount * 100 / $ this -> sellingPrice , 2 ) ; } return 0 ; }
9748	public function checkOrderStatus ( $ orderId ) { $ function = 'CheckOrderStatus' ; $ parameters = [ 'entityCode' => $ this -> connector -> getEntityCode ( ) , 'pedidoIDCliente' => $ orderId ] ; $ response = $ this -> connector -> doRequest ( $ function , $ parameters ) ; $ packageStatusResponse = new PackageStatus ( $ response -> CheckOrderStatusResult ) ; $ this -> connector -> log ( 'Integration@checkOrderStatus' , compact ( 'packageStatusResponse' ) ) ; return $ packageStatusResponse ; }
2779	public function git ( string $ commandLine , ? string $ cwd = null ) : string { $ command = new GitCommand ( $ commandLine ) ; $ command -> executeRaw ( is_string ( $ commandLine ) ) ; $ command -> setDirectory ( $ cwd ) ; return $ this -> run ( $ command ) ; }
7242	public function validate ( $ request ) { if ( ! empty ( $ request [ 'send_by_bcc' ] ) && '1' === $ request [ 'send_by_bcc' ] ) $ request [ 'send_by_bcc' ] = '1' ; else $ request [ 'send_by_bcc' ] = '0' ; if ( ! empty ( $ request [ 'send_attachments' ] ) && '1' === $ request [ 'send_attachments' ] ) $ request [ 'send_attachments' ] = '1' ; else $ request [ 'send_attachments' ] = '0' ; return $ request ; }
8492	public static function getTotalMemory ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT TotalPhysicalMemory FROM Win32_ComputerSystem" ) as $ mem ) { return $ mem -> TotalPhysicalMemory ; } return NULL ; }
902	public function isAnonymousClass ( $ index ) { $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isClassy ( ) ) { throw new \ LogicException ( sprintf ( 'No classy token at given index %d.' , $ index ) ) ; } if ( ! $ token -> isGivenKind ( T_CLASS ) ) { return false ; } return $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_NEW ) ; }
4879	public function getPrettySize ( ) { $ size = $ this -> getLength ( ) ; if ( $ size >= 1073741824 ) { return round ( $ size / 1073741824 , 2 ) . ' GB' ; } if ( $ size >= 1048576 ) { return round ( $ size / 1048576 , 2 ) . ' MB' ; } if ( $ size >= 1024 ) { return round ( $ size / 1024 , 2 ) . ' kB' ; } return ( string ) $ size ; }
8314	protected function finishPasswordReset ( array $ resetData ) { if ( time ( ) > $ resetData [ 'validity' ] ) { $ this -> session -> remove ( "pwreset" ) ; $ this -> session -> addFlash ( "error" , "Page validity expired, please try again." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; } $ this -> picoAuth -> addOutput ( "isReset" , true ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/pwreset.md' ) ; $ post = $ this -> httpRequest -> request ; if ( $ post -> has ( "new_password" ) && $ post -> has ( "new_password_repeat" ) ) { $ newPassword = new Password ( $ post -> get ( "new_password" ) ) ; $ newPasswordRepeat = new Password ( $ post -> get ( "new_password_repeat" ) ) ; $ username = $ resetData [ 'user' ] ; if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( $ newPassword -> get ( ) !== $ newPasswordRepeat -> get ( ) ) { $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ newPassword ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ this -> session -> remove ( "pwreset" ) ; $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ newPassword ) ; $ this -> storage -> saveUser ( $ username , $ userData ) ; $ this -> logPasswordReset ( $ username ) ; $ localAuth -> login ( $ username , $ userData ) ; $ this -> picoAuth -> afterLogin ( ) ; } }
2732	public function execute ( ) { $ types = $ this -> cacheManager -> getAvailableTypes ( ) ; $ types = array_diff ( $ types , [ 'full_page' ] ) ; $ this -> cacheManager -> clean ( $ types ) ; $ result = $ this -> api -> cleanAll ( ) ; if ( $ result === true ) { $ this -> messageManager -> addSuccessMessage ( __ ( 'Full Magento & Fastly Cache has been cleaned.' ) ) ; } else { $ this -> getMessageManager ( ) -> addErrorMessage ( __ ( 'Full Magento & Fastly Cache was not cleaned successfully.' ) ) ; } return $ this -> _redirect ( '*/cache/index' ) ; }
8732	public function challenge ( string $ hydroAddressId ) : ChallengeResponse { try { $ response = $ this -> callHydroApi ( 'post' , 'challenge' , [ 'json' => [ 'hydro_address_id' => $ hydroAddressId ] ] ) ; $ data = \ GuzzleHttp \ json_decode ( $ response -> getBody ( ) -> getContents ( ) , true , 512 , JSON_BIGINT_AS_STRING ) ; } catch ( RuntimeException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( InvalidArgumentException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( GuzzleException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( ApiRequestFailed $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } return new ChallengeResponse ( $ data [ 'amount' ] , ( int ) $ data [ 'challenge' ] , ( int ) $ data [ 'partner_id' ] , $ data [ 'transaction_hash' ] ) ; }
11146	public function move ( Neuron_GameServer_Map_MapObject $ object , Neuron_GameServer_Map_Location $ location , Neuron_GameServer_Map_Date $ start , Neuron_GameServer_Map_Date $ end ) { throw new Neuron_Exceptions_NotImplemented ( "The move method is not implemented in this map." ) ; }
3866	private function getOrCreateBasicDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasBasicDefinition ( ) ) { return $ container -> getBasicDefinition ( ) ; } $ config = new DefaultBasicDefinition ( ) ; $ container -> setBasicDefinition ( $ config ) ; return $ config ; }
9214	public function actionCreate ( ) { $ model = new StaticPage ( ) ; $ model -> time = date ( "Y-m-d H:i:s" ) ; $ model -> isdel = 0 ; $ post = Yii :: $ app -> request -> post ( ) ; if ( isset ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { if ( is_array ( $ post [ 'StaticPage' ] [ 'tags' ] ) ) { $ post [ 'StaticPage' ] [ 'tags' ] = implode ( "," , $ post [ 'StaticPage' ] [ 'tags' ] ) ; } } if ( $ model -> load ( $ post ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; } }
11584	public function exec ( $ calcId ) { $ result = [ ] ; $ bonusPercent = Cfg :: TEAM_BONUS_EU_PERCENT ; $ dwnlCompress = $ this -> daoBonDwnl -> getByCalcId ( $ calcId ) ; $ dwnlCurrent = $ this -> daoDwnl -> get ( ) ; $ mapDwnlById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCompress , EBonDwnl :: A_CUST_REF ) ; $ mapCustById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCurrent , ECustomer :: A_CUSTOMER_REF ) ; foreach ( $ mapDwnlById as $ custId => $ custDwnl ) { $ custData = $ mapCustById [ $ custId ] ; $ custMlmId = $ custData -> getMlmId ( ) ; $ pv = $ custDwnl -> getPv ( ) ; $ parentId = $ custDwnl -> getParentRef ( ) ; $ parentDwnl = $ mapDwnlById [ $ parentId ] ; $ parentData = $ mapCustById [ $ parentId ] ; $ parentMlmId = $ parentData -> getMlmId ( ) ; $ scheme = $ this -> hlpScheme -> getSchemeByCustomer ( $ parentData ) ; if ( $ scheme == Cfg :: SCHEMA_EU ) { $ pvParent = $ parentDwnl -> getPv ( ) ; if ( $ pvParent > ( Cfg :: PV_QUALIFICATION_LEVEL_EU - Cfg :: DEF_ZERO ) ) { $ bonus = $ this -> hlpFormat -> roundBonus ( $ pv * $ bonusPercent ) ; if ( $ bonus > Cfg :: DEF_ZERO ) { $ entry = new DBonus ( ) ; $ entry -> setCustomerRef ( $ parentId ) ; $ entry -> setDonatorRef ( $ custId ) ; $ entry -> setValue ( $ bonus ) ; $ result [ ] = $ entry ; } $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) has '$bonus' as EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } else { $ this -> logger -> debug ( "parent #$parentId (ref. #$parentMlmId) does not qualified t oget EU Team Bonus from downline customer #$custId (ref. #$custMlmId )." ) ; } } else { $ this -> logger -> debug ( "Parent #$parentId (ref. #$parentMlmId) has incompatible scheme '$scheme' for EU Team Bonus." ) ; } } unset ( $ mapCustById ) ; unset ( $ mapDwnlById ) ; return $ result ; }
7055	public function offset ( $ jd ) { if ( $ this -> dst == false ) return $ this -> offset ; IAU :: Jd2cal ( $ jd , 0 , $ y , $ m , $ d , $ fd ) ; $ dayN = static :: dayOfYear ( $ y , $ m , $ d ) + $ fd ; IAU :: Cal2jd ( $ y , 3 , 1 , $ djm0 , $ djm ) ; $ dayB = static :: dayOfYear ( $ y , 2 , 1 ) + 14 - static :: weekDayNum ( $ djm0 + $ djm ) + ( 2 / 24 ) ; IAU :: Cal2jd ( $ y , 11 , 1 , $ djm0 , $ djm ) ; $ dayE = static :: dayOfYear ( $ y , 11 , 1 ) + 14 - static :: weekDayNum ( $ djm0 + $ djm ) + ( 2 / 24 ) ; if ( $ dayN >= $ dayB && $ dayN < $ dayE ) return $ this -> offset + 1 ; else return $ this -> offset ; }
12680	public function hasFlag ( $ name ) { $ option = $ this -> definition -> getOption ( $ name ) ; if ( ! $ option -> isFlag ( ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "--%s" option is not a flag.' , $ name ) ) ; } return ! empty ( $ this -> options [ $ name ] ) ; }
6	private function parse20VersionConstraint ( array $ data ) { static $ dep20toOperatorMap = array ( 'has' => '==' , 'min' => '>=' , 'max' => '<=' , 'exclude' => '!=' ) ; $ versions = array ( ) ; $ values = array_intersect_key ( $ data , $ dep20toOperatorMap ) ; if ( 0 == count ( $ values ) ) { return '*' ; } if ( isset ( $ values [ 'min' ] ) && isset ( $ values [ 'exclude' ] ) && $ data [ 'min' ] == $ data [ 'exclude' ] ) { $ versions [ ] = '>' . $ this -> parseVersion ( $ values [ 'min' ] ) ; } elseif ( isset ( $ values [ 'max' ] ) && isset ( $ values [ 'exclude' ] ) && $ data [ 'max' ] == $ data [ 'exclude' ] ) { $ versions [ ] = '<' . $ this -> parseVersion ( $ values [ 'max' ] ) ; } else { foreach ( $ values as $ op => $ version ) { if ( 'exclude' == $ op && is_array ( $ version ) ) { foreach ( $ version as $ versionPart ) { $ versions [ ] = $ dep20toOperatorMap [ $ op ] . $ this -> parseVersion ( $ versionPart ) ; } } else { $ versions [ ] = $ dep20toOperatorMap [ $ op ] . $ this -> parseVersion ( $ version ) ; } } } return implode ( ',' , $ versions ) ; }
10900	public function validate ( string $ method = 'save' ) : array { $ errors = [ ] ; foreach ( $ this -> getValidators ( ) [ $ method ] ?? [ ] as $ field => $ validator ) { try { $ validator -> setName ( $ field ) -> assert ( $ this -> get ( $ field ) ) ; } catch ( NestedValidationException $ e ) { $ errors [ $ field ] = $ e -> getMessages ( ) ; } } return $ errors ; }
8001	public function calculateChallengeResponseData ( HashCredentialInterface $ hash_credential , $ data ) { $ padded_hash = str_pad ( $ hash_credential -> getValue ( ) , static :: DESL_FULL_KEY_LENGTH , static :: NULL_PAD_CHARACTER ) ; $ key_blocks = str_split ( $ padded_hash , static :: DESL_KEY_BLOCK_SEGMENT_LENGTH ) ; $ binary_data = array_reduce ( $ key_blocks , function ( $ result , $ key_block ) use ( $ data ) { return $ result . $ this -> des_encrypter -> encrypt ( $ key_block , $ data , CipherMode :: ECB , '' ) ; } , '' ) ; return $ binary_data ; }
5784	public function routePutUpdate ( Request $ request , Response $ response , $ args ) { if ( ! $ this -> authorization -> isAuthorized ( constant ( strtoupper ( $ this -> routePrefix ) . "_UPDATE_RESOURCE" ) ) ) { throw new \ Exception ( 'No permission.' ) ; } $ primaryKeyValue = $ args [ ROUTEARG_PRIMARY_KEY ] ; $ this -> setRequestInput ( $ request , DatabaseTableForm :: getFieldNames ( $ this -> tableMapper ) , $ this -> tableMapper -> getBooleanColumnNames ( ) ) ; $ redirectRoute = SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ; if ( null === $ record = $ this -> tableMapper -> selectForPrimaryKey ( $ primaryKeyValue ) ) { return $ this -> databaseRecordNotFound ( $ response , $ primaryKeyValue , $ this -> tableMapper , 'update' ) ; } $ changedColumnsValues = $ this -> getMapper ( ) -> getChangedColumnsValues ( $ this -> requestInput , $ record ) ; if ( count ( $ changedColumnsValues ) == 0 ) { SlimPostgres :: setAdminNotice ( "No changes made" , 'failure' ) ; return $ this -> view -> updateView ( $ request , $ response , $ args ) ; } $ validator = new DatabaseTableUpdateFormValidator ( $ this -> requestInput , $ this -> tableMapper , $ record ) ; if ( ! $ validator -> validate ( ) ) { FormHelper :: setFieldErrors ( $ validator -> getFirstErrors ( ) ) ; $ args [ SlimPostgres :: USER_INPUT_KEY ] = $ this -> requestInput ; return $ this -> view -> updateView ( $ request , $ response , $ args ) ; } $ this -> tableMapper -> updateByPrimaryKey ( $ changedColumnsValues , $ primaryKeyValue ) ; $ this -> enterEventAndNotice ( 'update' , $ primaryKeyValue ) ; return $ response -> withRedirect ( $ this -> router -> pathFor ( $ redirectRoute ) ) ; }
8275	public function handleEvent ( $ eventName , array $ params ) { if ( method_exists ( $ this , $ eventName ) ) { call_user_func_array ( array ( $ this , $ eventName ) , $ params ) ; } }
5960	public function clientGetByDbid ( $ dbid ) { foreach ( $ this -> clientList ( ) as $ client ) { if ( $ client [ "client_database_id" ] == $ dbid ) { return $ client ; } } throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; }
12737	protected function translate ( ) { $ translatorOptions = $ this -> getTranslatorOptions ( ) ; if ( empty ( $ translatorOptions ) && ! array_key_exists ( "fields" , $ translatorOptions ) ) { return ; } $ params = array ( ) ; if ( array_key_exists ( "params" , $ translatorOptions ) ) { $ params = $ translatorOptions [ "params" ] ; } $ domain = "RedKiteCms" ; if ( array_key_exists ( "domain" , $ translatorOptions ) ) { $ domain = $ translatorOptions [ "domain" ] ; } foreach ( $ translatorOptions [ "fields" ] as $ field ) { $ field = ucfirst ( $ field ) ; $ method = 'get' . $ field ; $ value = Translator :: translate ( $ this -> $ method ( ) , $ params , $ domain ) ; $ method = 'set' . $ field ; $ this -> $ method ( $ value ) ; } }
9334	public function deg ( ) { if ( $ this -> original -> type == self :: TYPE_DEG ) { return $ this -> original -> value ; } return rad2deg ( $ this -> float_rad ) ; }
10558	public function createI18n ( array $ args ) { $ i18n = new I18n ; I18nShortcut :: setInstance ( $ i18n ) ; $ modules = $ this -> app -> resolver -> getResolver ( "language" ) ; $ log = \ Wedeto \ Log \ Logger :: getLogger ( I18nPlugin :: class ) ; $ search_path = $ modules -> getSearchPath ( ) ; foreach ( $ search_path as $ name => $ path ) { $ i18n -> registerTextDomain ( $ name , $ path ) ; } $ site_language = $ this -> app -> config -> dget ( 'site' , 'default_language' , 'en' ) ; $ locale = $ args [ 'locale' ] ?? $ site_language ; $ i18n -> setLocale ( $ locale ) ; $ this -> setupTranslateLog ( ) ; return $ i18n ; }
7348	protected function watch ( OrderShipmentInterface $ shipment ) { $ order = $ shipment -> getOrder ( ) ; if ( ! $ order -> isAutoNotify ( ) ) { return ; } if ( $ shipment -> isReturn ( ) ) { if ( $ shipment -> getState ( ) === ShipmentStates :: STATE_PENDING ) { if ( ! $ this -> didStateChangeTo ( $ shipment , ShipmentStates :: STATE_PENDING ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: RETURN_PENDING , $ shipment -> getNumber ( ) ) ) { return ; } $ this -> notify ( NotificationTypes :: RETURN_PENDING , $ shipment ) ; return ; } if ( $ shipment -> getState ( ) === ShipmentStates :: STATE_RETURNED ) { if ( ! $ this -> didStateChangeTo ( $ shipment , ShipmentStates :: STATE_RETURNED ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: RETURN_RECEIVED , $ shipment -> getNumber ( ) ) ) { return ; } $ this -> notify ( NotificationTypes :: RETURN_RECEIVED , $ shipment ) ; } return ; } if ( ! $ this -> didStateChangeTo ( $ shipment , ShipmentStates :: STATE_SHIPPED ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: SHIPMENT_SHIPPED , $ shipment -> getNumber ( ) ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: SHIPMENT_SHIPPED , $ shipment -> getNumber ( ) ) ) { return ; } $ type = NotificationTypes :: SHIPMENT_SHIPPED ; if ( $ order -> getShipmentState ( ) !== ShipmentStates :: STATE_COMPLETED ) { $ type = NotificationTypes :: SHIPMENT_PARTIAL ; } $ this -> notify ( $ type , $ shipment ) ; }
7414	public function read ( ) { $ data = '' ; $ fileObj = $ this -> openFile ( ) ; while ( ! $ fileObj -> eof ( ) ) { $ data .= $ fileObj -> fread ( 4096 ) ; } $ fileObj = null ; return $ data ; }
9492	private function getApplicationSize ( ) { $ size = cache ( ) -> remember ( 'foundation.app.size' , 5 , function ( ) { return $ this -> getFolderSize ( base_path ( ) ) ; } ) ; return $ this -> formatSize ( $ size ) ; }
8851	public function PaginatedList ( ) { $ posts = new PaginatedList ( $ this -> blogPosts ) ; if ( $ this -> PostsPerPage > 0 ) $ posts -> setPageLength ( $ this -> PostsPerPage ) ; else $ posts -> setPageLength ( $ this -> getBlogPosts ( ) -> count ( ) ) ; $ start = $ this -> request -> getVar ( $ posts -> getPaginationGetVar ( ) ) ; $ posts -> setPageStart ( $ start ) ; return $ posts ; }
7838	public function create ( string $ name , array $ numbers ) : ? array { $ body = Body :: json ( [ [ 'name' => $ name , 'phone_numbers' => $ numbers , ] , ] ) ; $ response = Request :: post ( $ this -> baseUrl . 'contact' , [ ] , $ body ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
628	public function bindValue ( $ name , $ value , $ dataType = null ) { if ( $ dataType === null ) { $ dataType = $ this -> db -> getSchema ( ) -> getPdoType ( $ value ) ; } $ this -> _pendingParams [ $ name ] = [ $ value , $ dataType ] ; $ this -> params [ $ name ] = $ value ; return $ this ; }
9560	protected function renderCloseButton ( ) { if ( ( $ closeButton = $ this -> closeButton ) !== false ) { $ tag = ArrayHelper :: remove ( $ closeButton , 'tag' , 'button' ) ; $ label = ArrayHelper :: remove ( $ closeButton , 'label' , 'Close' ) ; if ( $ tag === 'button' && ! isset ( $ closeButton [ 'type' ] ) ) { $ closeButton [ 'type' ] = 'button' ; } return Html :: tag ( $ tag , $ label , $ closeButton ) ; } else { return null ; } }
12376	public function equals ( ) { foreach ( $ this -> comparisonList as $ valuePair ) { $ a = $ valuePair [ 0 ] ; $ b = $ valuePair [ 1 ] ; $ callback = $ valuePair [ 2 ] ; if ( ! is_null ( $ callback ) ) { if ( ! is_callable ( $ callback ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Provided callback of type %s is not callable!' , is_object ( $ callback ) ? get_class ( $ callback ) : gettype ( $ callback ) ) ) ; } if ( is_array ( $ a ) && is_array ( $ b ) && $ this -> isList ( $ a ) && $ this -> isList ( $ b ) ) { $ result = $ this -> compareListsWithCallback ( $ a , $ b , $ callback ) ; } else { $ result = call_user_func ( $ callback , $ a , $ b ) ; } if ( ! is_bool ( $ result ) ) { throw new \ RuntimeException ( sprintf ( 'Provided callback of type %s does not return a boolean value!' , is_object ( $ callback ) ? get_class ( $ callback ) : gettype ( $ callback ) ) ) ; } return $ result ; } if ( ! ( ( $ this -> strict ) ? $ a === $ b : $ a == $ b ) ) { return false ; } } return true ; }
9276	public function validateFields ( Request $ request , Repository $ repository , $ data ) { $ config = [ ] ; $ validation = [ ] ; foreach ( $ this -> versions as $ version ) { foreach ( $ version [ 'endpoints' ] as $ endpoint ) { if ( $ endpoint [ 'repository' ] == $ request -> attributes -> get ( 'repository' ) ) { $ config = $ endpoint ; break ; } } if ( $ config != [ ] ) { break ; } } if ( ! $ config [ 'allow_extra_fields' ] || $ config [ 'allow_fields' ] ) { $ mapping = $ this -> manager -> getMetadataCollector ( ) -> getMapping ( $ repository -> getClassName ( ) ) ; $ forbiddenFields = $ mapping [ 'properties' ] ; if ( $ config [ 'allow_fields' ] ) { foreach ( $ config [ 'allow_fields' ] as $ field ) { unset ( $ forbiddenFields [ $ field ] ) ; } } foreach ( $ data as $ parameter => $ value ) { if ( ! array_key_exists ( $ parameter , $ mapping [ 'properties' ] ) && $ parameter != '_id' ) { $ validation [ 'message' ] = sprintf ( 'Property `%s` does not exist in the mapping of `%s`.' , $ parameter , $ repository -> getType ( ) ) ; return $ validation ; } if ( $ config [ 'allow_fields' ] && array_key_exists ( $ parameter , $ forbiddenFields ) ) { $ validation [ 'message' ] = sprintf ( 'You are not allowed to insert or modify the field `%s` in `%s`' , $ parameter , $ repository -> getType ( ) ) ; return $ validation ; } } } return $ validation ; }
8795	public function view ( $ name , array $ data = [ ] ) { $ file = app_path ( 'Views' . DIRECTORY_SEPARATOR . $ name . '.php' ) ; if ( file_exists ( $ file ) ) { extract ( $ data ) ; require $ file ; return ob_get_clean ( ) ; } throw new ExceptionHandler ( 'Oppss! File not found.' , 'View::' . $ name . ' not found.' ) ; }
11088	public static function getUserBrowser ( ) { $ user_agent = $ _SERVER [ 'HTTP_USER_AGENT' ] ; $ user_browser = 'unknown' ; if ( false !== stripos ( $ user_agent , 'MSIE' ) && false === stripos ( $ user_agent , 'Opera' ) ) { $ user_browser = 'Internet Explorer' ; } elseif ( false !== stripos ( $ user_agent , 'Firefox' ) ) { $ user_browser = 'Mozilla Firefox' ; } elseif ( false !== stripos ( $ user_agent , 'Chrome' ) ) { $ user_browser = 'Google Chrome' ; } elseif ( false !== stripos ( $ user_agent , 'Safari' ) ) { $ user_browser = 'Apple Safari' ; } elseif ( false !== stripos ( $ user_agent , 'Opera' ) ) { $ user_browser = 'Opera' ; } elseif ( false !== stripos ( $ user_agent , 'Netscape' ) ) { $ user_browser = 'Netscape' ; } return $ user_browser ; }
4835	public function merchant ( $ id = null ) { if ( $ id == null ) { $ id = $ this -> account_details [ 'merchant_id' ] ; } return GoCardless_Merchant :: find_with_client ( $ this , $ id ) ; }
9895	private function convert ( $ token ) { if ( preg_match ( '/"([^"]|""){0,255}"/' , $ token ) ) { return $ this -> convertString ( $ token ) ; } elseif ( is_numeric ( $ token ) ) { return $ this -> convertNumber ( $ token ) ; } elseif ( preg_match ( '/^\$?([A-Ia-i]?[A-Za-z])\$?(\d+)$/' , $ token ) ) { return $ this -> convertRef2d ( $ token ) ; } elseif ( preg_match ( '/^' . self :: REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self :: REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?[A-Ia-i]?[A-Za-z]\$?(\\d+)$/u' , $ token ) ) { return $ this -> convertRef3d ( $ token ) ; } elseif ( preg_match ( "/^'" . self :: REGEX_SHEET_TITLE_QUOTED . '(\\:' . self :: REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?[A-Ia-i]?[A-Za-z]\\$?(\\d+)$/u" , $ token ) ) { return $ this -> convertRef3d ( $ token ) ; } elseif ( preg_match ( '/^(\$)?[A-Ia-i]?[A-Za-z](\$)?(\d+)\:(\$)?[A-Ia-i]?[A-Za-z](\$)?(\d+)$/' , $ token ) ) { return $ this -> convertRange2d ( $ token ) ; } elseif ( preg_match ( '/^' . self :: REGEX_SHEET_TITLE_UNQUOTED . '(\\:' . self :: REGEX_SHEET_TITLE_UNQUOTED . ')?\\!\$?([A-Ia-i]?[A-Za-z])?\$?(\\d+)\\:\$?([A-Ia-i]?[A-Za-z])?\$?(\\d+)$/u' , $ token ) ) { return $ this -> convertRange3d ( $ token ) ; } elseif ( preg_match ( "/^'" . self :: REGEX_SHEET_TITLE_QUOTED . '(\\:' . self :: REGEX_SHEET_TITLE_QUOTED . ")?'\\!\\$?([A-Ia-i]?[A-Za-z])?\\$?(\\d+)\\:\\$?([A-Ia-i]?[A-Za-z])?\\$?(\\d+)$/u" , $ token ) ) { return $ this -> convertRange3d ( $ token ) ; } elseif ( isset ( $ this -> ptg [ $ token ] ) ) { return pack ( 'C' , $ this -> ptg [ $ token ] ) ; } elseif ( preg_match ( '/^#[A-Z0\\/]{3,5}[!?]{1}$/' , $ token ) or $ token == '#N/A' ) { return $ this -> convertError ( $ token ) ; } elseif ( $ token == 'arg' ) { return '' ; } throw new WriterException ( "Unknown token $token" ) ; }
9937	private static function checkSheetCodeName ( $ pValue ) { $ CharCount = Shared \ StringHelper :: countCharacters ( $ pValue ) ; if ( $ CharCount == 0 ) { throw new Exception ( 'Sheet code name cannot be empty.' ) ; } if ( ( str_replace ( self :: $ invalidCharacters , '' , $ pValue ) !== $ pValue ) || ( Shared \ StringHelper :: substring ( $ pValue , - 1 , 1 ) == '\'' ) || ( Shared \ StringHelper :: substring ( $ pValue , 0 , 1 ) == '\'' ) ) { throw new Exception ( 'Invalid character found in sheet code name' ) ; } if ( $ CharCount > 31 ) { throw new Exception ( 'Maximum 31 characters allowed in sheet code name.' ) ; } return $ pValue ; }
8454	protected function downloadMediaFileFromURL ( $ fileUri , $ tempFileName ) { $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , "$fileUri" ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11" ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_HEADER , false ) ; curl_setopt ( $ curl , CURLOPT_NOBODY , false ) ; curl_setopt ( $ curl , CURLOPT_BUFFERSIZE , 1024 ) ; curl_setopt ( $ curl , CURLOPT_FILE , $ tempFileName ) ; curl_exec ( $ curl ) ; curl_close ( $ curl ) ; }
8105	public function runQuery ( $ sql , $ arguments = false ) { if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } if ( ! $ arguments ) { $ stmt -> execute ( ) ; } $ rows = $ stmt -> rowCount ( ) ; if ( $ rows > 0 ) { $ this -> log -> report ( "$rows row(s) where Affected" ) ; return true ; } else { $ this -> log -> report ( 'No rows were Affected' ) ; return false ; } }
3684	protected function buildNativeSqlProcedure ( FilterBuilderSql $ procedure , $ children ) { $ skipped = array ( ) ; $ metaModel = $ this -> getMetaModel ( ) ; $ tableName = $ metaModel -> getTableName ( ) ; foreach ( $ children as $ child ) { if ( isset ( $ child [ 'property' ] ) && $ metaModel -> hasAttribute ( $ child [ 'property' ] ) ) { $ skipped [ ] = $ child ; continue ; } if ( ( 'AND' === $ child [ 'operation' ] ) || ( 'OR' === $ child [ 'operation' ] ) ) { if ( null === $ child [ 'children' ] ) { continue ; } $ subProcedure = new FilterBuilderSql ( $ tableName , $ child [ 'operation' ] , $ this -> connection ) ; $ subSkipped = $ this -> buildNativeSqlProcedure ( $ subProcedure , $ child [ 'children' ] ) ; if ( count ( $ subSkipped ) !== count ( $ child [ 'children' ] ) ) { $ procedure -> addSubProcedure ( $ subProcedure ) ; } if ( ! empty ( $ subSkipped ) ) { $ skipped += $ subSkipped ; } continue ; } $ procedure -> addChild ( $ child ) ; } return $ skipped ; }
10379	protected static function is_modified_file ( $ filepath ) { $ actual = filemtime ( $ filepath ) ; $ last = isset ( self :: $ files [ $ filepath ] ) ? self :: $ files [ $ filepath ] : 0 ; if ( $ actual !== $ last ) { self :: $ files [ $ filepath ] = $ actual ; self :: $ changes = true ; return self :: $ changes ; } return false ; }
11333	public function setFormat ( $ value ) { if ( is_array ( $ value ) ) { if ( ! isset ( $ value [ 'class' ] ) ) { $ value [ 'class' ] = $ this -> determineFormatClass ( ) ; } $ value [ 'field' ] = $ this ; $ value = Yii :: createObject ( $ value ) ; } $ this -> _format = $ value ; }
3651	protected function callParseTemplateHook ( ) { if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ objCallback -> $ strMethod ( $ this ) ; } } }
3160	protected function storeVariable ( QtiRunnerServiceContext $ context , $ itemUri , \ taoResultServer_models_classes_Variable $ metaVariable , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariable ( $ testUri , $ itemUri , $ metaVariable , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariable ( $ testUri , $ metaVariable , $ sessionId ) ; } return true ; }
8293	protected function errorHandler ( \ Exception $ e , $ url = "" ) { $ this -> errorOccurred = true ; $ this -> requestFile = $ this -> pluginDir . '/content/error.md' ; if ( $ this -> config [ "debug" ] === true ) { $ this -> addOutput ( "_exception" , ( string ) $ e ) ; } $ this -> logger -> critical ( "Exception on url '{url}': {e}" , array ( "url" => $ url , "e" => $ e ) ) ; header ( $ _SERVER [ 'SERVER_PROTOCOL' ] . ' 500 Internal Server Error' , true , 500 ) ; $ this -> requestUrl = "500" ; }
740	protected function saveRules ( ) { $ rules = [ ] ; foreach ( $ this -> rules as $ name => $ rule ) { $ rules [ $ name ] = serialize ( $ rule ) ; } $ this -> saveToFile ( $ rules , $ this -> ruleFile ) ; }
9011	public function tinytext ( string $ charset = null ) : self { $ this -> type = 'tinytext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
3801	public function getCache ( ) { @ trigger_error ( '"' . __METHOD__ . '" is deprecated as the service container will get removed.' , E_USER_DEPRECATED ) ; if ( \ is_callable ( $ this -> cache ) ) { $ this -> cache = \ call_user_func ( $ this -> cache ) ; } return $ this -> cache ; }
4059	private function drawLegend ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; if ( is_array ( $ legend = StringUtil :: deserialize ( $ model -> getProperty ( 'legendtitle' ) ) ) ) { foreach ( [ $ metaModel -> getActiveLanguage ( ) , $ metaModel -> getFallbackLanguage ( ) ] as $ language ) { if ( array_key_exists ( $ language , $ legend ) && ! empty ( $ legend [ $ language ] ) ) { $ legend = $ legend [ $ language ] ; break ; } } } if ( empty ( $ legend ) ) { $ legend = 'legend' ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong></div> <div class="dca_palette">%s%s</div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ this -> trans ( 'dcatypes.legend' ) , $ legend , $ model -> getProperty ( 'legendhide' ) ? ':hide' : '' ] ) ; }
695	public function beforeSend ( $ message ) { $ event = new MailEvent ( [ 'message' => $ message ] ) ; $ this -> trigger ( self :: EVENT_BEFORE_SEND , $ event ) ; return $ event -> isValid ; }
2366	public static function censor ( $ strString , $ varWords , $ strReplace = '' ) { foreach ( ( array ) $ varWords as $ strWord ) { $ strString = preg_replace ( '/\b(' . str_replace ( '\*' , '\w*?' , preg_quote ( $ strWord , '/' ) ) . ')\b/i' , $ strReplace , $ strString ) ; } return $ strString ; }
12577	public function previewNewsByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_NEWS , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
12134	public function index ( QuestionRequest $ request ) { $ view = $ this -> response -> theme -> listView ( ) ; if ( $ this -> response -> typeIs ( 'json' ) ) { $ function = camel_case ( 'get-' . $ view ) ; return $ this -> repository -> setPresenter ( \ Litecms \ Forum \ Repositories \ Presenter \ QuestionPresenter :: class ) -> $ function ( ) ; } $ user_id = user_id ( ) ; $ questions = $ this -> repository -> questions ( $ user_id ) ; return $ this -> response -> title ( trans ( 'forum::question.names' ) ) -> view ( 'forum::question.index' , true ) -> data ( compact ( 'questions' , 'view' ) ) -> output ( ) ; }
5940	public function addExtraData ( $ item ) { if ( ! ( $ item instanceof ExtraData ) ) { if ( is_array ( $ item ) ) { try { $ item = new ExtraData ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate ExtraData. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "ExtraData"!' , E_USER_WARNING ) ; } } $ this -> extraData [ ] = $ item ; return $ this ; }
6911	public function removeExtraCopy ( Recipient $ copy ) { if ( $ this -> extraCopies -> contains ( $ copy ) ) { $ this -> extraCopies -> removeElement ( $ copy ) ; } return $ this ; }
9199	public function getAccessToken ( $ oauthToken , $ oauthVerifier ) { $ oauth = new Oauth1 ( array ( 'consumer_key' => $ this -> credentials -> getConsumerKey ( ) , 'consumer_secret' => $ this -> credentials -> getConsumerSecret ( ) , 'token' => $ oauthToken , 'verifier' => $ oauthVerifier ) ) ; $ this -> guzzleClient -> getEmitter ( ) -> attach ( $ oauth ) ; $ accessTokenResponse = $ this -> guzzleClient -> post ( Config :: get ( 'oauth_access_token' ) , array ( 'auth' => 'oauth' ) ) ; $ response = array ( ) ; parse_str ( $ accessTokenResponse -> getBody ( ) , $ response ) ; $ this -> credentials -> setAccessToken ( $ response [ 'oauth_token' ] ) -> setAccessTokenSecret ( $ response [ 'oauth_token_secret' ] ) ; return $ response ; }
11444	public function setTransporter ( TransportInterface $ transporter ) { if ( $ transporter -> validate ( ) ) { $ this -> transporter = $ transporter ; } else { throw new \ Exception ( sprintf ( 'Transporter "%s" is not valid for current environment!' , get_class ( $ transporter ) ) ) ; } return $ this ; }
11024	protected function buildGroupBy ( ) { $ result = [ ] ; foreach ( $ this -> clause_groupby as $ grp ) { $ result [ ] = $ grp [ 0 ] ? $ grp [ 1 ] : $ this -> quote ( $ grp [ 1 ] ) ; } return $ result ; }
12004	public static function objectToArray ( $ mObject ) : array { if ( is_object ( $ mObject ) ) { $ mObject = ( array ) $ mObject ; } if ( is_array ( $ mObject ) ) { $ aNew = array ( ) ; foreach ( $ mObject as $ sKey => $ mValues ) { $ sKey = preg_replace ( "/^\\0(.*)\\0/" , "" , $ sKey ) ; $ aNew [ $ sKey ] = self :: objectToArray ( $ mValues ) ; } } else { $ aNew = $ mObject ; } return $ aNew ; }
7522	function parse_style ( ) { if ( $ this -> parse_attributes ( ) && ( $ this -> token === self :: TOK_TAG_CLOSE ) && ( $ start = $ this -> pos ) && ( $ this -> next_pos ( '</style>' , false ) === self :: TOK_UNKNOWN ) ) { $ len = $ this -> pos - 1 - $ start ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ start + 1 , $ len ) : '' ) ; $ this -> pos += 7 ; $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; } else { $ this -> addError ( 'No end for style tag found' ) ; return false ; } }
3889	public function getFilterSettings ( \ DC_Table $ objDC ) { $ filterSettings = $ this -> connection -> createQueryBuilder ( ) -> select ( 'f.id' , 'f.name' ) -> from ( 'tl_metamodel_filter' , 'f' ) -> where ( 'f.pid=:id' ) -> setParameter ( 'id' , $ objDC -> activeRecord -> metamodel ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; foreach ( $ filterSettings as $ filterSetting ) { $ result [ $ filterSetting [ 'id' ] ] = $ filterSetting [ 'name' ] ; } asort ( $ result ) ; return $ result ; }
7280	public function validateInput ( array $ rules ) { foreach ( $ rules as $ rule ) if ( empty ( $ this -> inputs [ $ rule ] ) ) return false ; return true ; }
8521	public function setListingQualityRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ListingQualityRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10370	public static function add ( $ type , $ data = [ ] ) { $ is_admin = is_admin ( ) ; if ( self :: validate ( $ type , $ data , $ is_admin ) ) { $ hook = $ is_admin ? 'admin_enqueue_scripts' : 'wp_enqueue_scripts' ; $ method = __CLASS__ . "::add_{$type}s" ; if ( has_action ( $ hook , $ method ) === false ) { add_action ( $ hook , $ method ) ; } return true ; } return false ; }
2080	public function purgeRegistrations ( ) { $ objMember = MemberModel :: findExpiredRegistrations ( ) ; if ( $ objMember === null ) { return ; } while ( $ objMember -> next ( ) ) { $ objMember -> delete ( ) ; } $ this -> log ( 'Purged the unactivated member registrations' , __METHOD__ , TL_CRON ) ; }
10035	function unsubscribeContactByExternalId ( $ externalId , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } $ encodedExternalId = utf8_encode ( $ externalId ) ; return $ this -> delete ( "contacts/externalid/${encodedExternalId}/unsubscribe" , $ queryParameters ) ; }
5950	public function addMediaResponse ( $ item ) { if ( ! ( $ item instanceof MediaResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new MediaResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate MediaResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } elseif ( ! is_numeric ( $ item ) ) { trigger_error ( 'Array parameter item is not of expected type "MediaResponse"!' , E_USER_WARNING ) ; } } $ this -> results [ ] = $ item ; return $ this ; }
7616	public function authenticateApp ( $ consumer_key , $ consumer_secret ) { $ bearer_token = $ this -> encodeBearer ( $ consumer_key , $ consumer_secret ) ; $ headers = array ( 'Authorization' => 'Basic ' . $ bearer_token , 'Content-Type' => 'application/x-www-form-urlencoded;charset=UTF-8' ) ; $ body = 'grant_type=client_credentials' ; $ response = $ this -> client -> post ( '/oauth2/token' , $ headers , $ body ) -> send ( ) ; $ data = $ response -> json ( ) ; $ this -> bearer = $ data [ 'access_token' ] ; return $ this -> bearer ; }
10131	private function writeObjectProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } if ( ! $ this -> phpSheet -> getProtection ( ) -> getObjects ( ) ) { return ; } $ record = 0x0063 ; $ length = 0x0002 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , 1 ) ; $ this -> append ( $ header . $ data ) ; }
3248	public function remove ( $ item , $ quantity = 0 ) { $ cartItem = $ this -> getItem ( is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku ) ; if ( ! empty ( $ cartItem ) ) { if ( ! empty ( $ quantity ) ) { $ cartItem -> quantity -= $ quantity ; $ cartItem -> save ( ) ; if ( $ cartItem -> quantity > 0 ) return true ; } $ cartItem -> delete ( ) ; } $ this -> resetCalculations ( ) ; return $ this ; }
4372	public function onOutput ( Event $ event ) { $ this -> data = $ this -> debug -> getData ( ) ; $ this -> channels = array ( ) ; $ str = '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => 'debug' , 'data-channels' => '{{channels}}' , 'data-channel-root' => $ this -> channelNameRoot , ) ) . ">\n" ; if ( $ this -> debug -> getCfg ( 'output.outputCss' ) ) { $ str .= '<style type="text/css">' . "\n" . $ this -> debug -> output -> getCss ( ) . "\n" . '</style>' . "\n" ; } if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<script type="text/javascript">' . \ file_get_contents ( $ this -> debug -> getCfg ( 'filepathScript' ) ) . '</script>' . "\n" ; } $ str .= '<div class="debug-bar"><h3>Debug Log</h3></div>' . "\n" ; $ str .= $ this -> processAlerts ( ) ; if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<div class="loading">Loading <i class="fa fa-spinner fa-pulse fa-2x fa-fw" aria-hidden="true"></i></div>' . "\n" ; } $ str .= '<div class="debug-header m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processSummary ( ) ; $ str .= '</div>' . "\n" ; $ str .= '<div class="debug-content m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processLog ( ) ; $ str .= '</div>' . "\n" ; $ str .= '</div>' . "\n" ; $ str = \ strtr ( $ str , array ( '{{channels}}' => \ htmlspecialchars ( \ json_encode ( $ this -> buildChannelTree ( ) , JSON_FORCE_OBJECT ) ) , ) ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
7882	public function getIndex ( ) { $ today = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; if ( Session :: has ( 'success' ) || Session :: has ( 'error' ) ) { Session :: reflash ( ) ; } return Redirect :: to ( 'logviewer/' . $ today . '/all' ) ; }
11688	public function setCenter ( \ Chill \ MainBundle \ Entity \ Center $ center ) { $ this -> center = $ center ; return $ this ; }
12938	public function setMin ( $ value ) { $ this -> setTag ( 'min' , $ value ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'min' , $ value ) ; } }
8092	static public function decode ( $ number ) { $ k = self :: $ encoder ; preg_match_all ( '/[1][a-zA-Z]|[2-9]|[a-zA-Z]|[0]/' , $ number , $ a ) ; $ n = '' ; $ o = count ( $ k ) ; foreach ( $ a [ 0 ] as $ i ) { $ f = preg_match ( '/1([a-zA-Z])/' , $ i , $ v ) ; if ( $ f == true ) { $ i = $ o + array_search ( $ v [ 1 ] , $ k ) ; } else { $ i = array_search ( $ i , $ k ) ; } $ n .= $ i ; } return $ n ; }
9844	public function createSignedJsonResponse ( int $ status , array $ arrayToJsonify , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSignedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
10288	protected function getJobsSince ( $ time ) { $ now = time ( ) ; $ jobs = array ( ) ; foreach ( $ this -> rescheduled as $ scheduled => $ cronjob ) { if ( $ scheduled <= $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; unset ( $ this -> rescheduled [ $ scheduled ] ) ; } } foreach ( $ this -> crontab as $ cronjob ) { $ cronjob -> iterator -> startTime = $ time ; if ( ( $ scheduled = $ cronjob -> iterator -> current ( ) ) < $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; } } ksort ( $ jobs ) ; return $ jobs ; }
4079	protected function buildInputScreen ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; $ inputScreen = $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] ; if ( ! is_object ( $ inputScreen ) ) { $ inputScreen = $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] = new InputScreen ( $ this -> container , $ inputScreen [ 'row' ] , $ inputScreen [ 'properties' ] , $ inputScreen [ 'conditions' ] , $ inputScreen [ 'groupSort' ] ) ; } return $ inputScreen ; }
6488	protected function getClientIPAddress ( array $ server ) : ? string { $ serverRemoteAddress = $ server [ 'REMOTE_ADDR' ] ?? null ; if ( $ this -> isUsingTrustedProxy ( $ server ) ) { return $ serverRemoteAddress ?? null ; } $ ipAddresses = [ ] ; if ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ) ) { $ header = $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ; preg_match_all ( "/for=(?:\"?\[?)([a-z0-9:\.\-\/_]*)/" , $ header , $ matches ) ; $ ipAddresses = $ matches [ 1 ] ; } elseif ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ) { $ ipAddresses = explode ( ',' , $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ; $ ipAddresses = array_map ( 'trim' , $ ipAddresses ) ; } if ( $ serverRemoteAddress !== null ) { $ ipAddresses [ ] = $ serverRemoteAddress ; } $ fallbackIPAddresses = count ( $ ipAddresses ) === 0 ? [ ] : [ $ ipAddresses [ 0 ] ] ; foreach ( $ ipAddresses as $ index => $ ipAddress ) { if ( filter_var ( $ ipAddress , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) === false ) { unset ( $ ipAddresses [ $ index ] ) ; } if ( in_array ( $ ipAddress , $ this -> trustedProxyIPAddresses , true ) ) { unset ( $ ipAddresses [ $ index ] ) ; } } $ clientIPAddresses = count ( $ ipAddresses ) === 0 ? $ fallbackIPAddresses : array_reverse ( $ ipAddresses ) ; return $ clientIPAddresses [ 0 ] ?? null ; }
5870	protected static function getBasicMetadata ( $ fileName ) { $ extension = strtolower ( substr ( $ fileName , strrpos ( $ fileName , '.' ) + 1 ) ) ; $ metadata = [ ] ; if ( GeneralUtility :: inList ( 'jpg,jpeg,tif,tiff' , $ extension ) && function_exists ( 'exif_read_data' ) ) { $ exif = @ exif_read_data ( $ fileName ) ; if ( $ exif ) { $ metadata = $ exif ; $ metadata [ 'ImageDescription' ] = static :: safeUtf8Encode ( $ metadata [ 'ImageDescription' ] ) ; if ( isset ( $ metadata [ 'GPSLatitude' ] ) && is_array ( $ metadata [ 'GPSLatitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLatitudeRef' ] ) ? $ metadata [ 'GPSLatitudeRef' ] : 'N' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLatitude' ] ) ; $ decimal *= $ reference === 'N' ? 1 : - 1 ; $ metadata [ 'GPSLatitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSLongitude' ] ) && is_array ( $ metadata [ 'GPSLongitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLongitudeRef' ] ) ? $ metadata [ 'GPSLongitudeRef' ] : 'E' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLongitude' ] ) ; $ decimal *= $ reference === 'E' ? 1 : - 1 ; $ metadata [ 'GPSLongitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSAltitude' ] ) ) { $ rationalParts = explode ( '/' , $ metadata [ 'GPSAltitude' ] ) ; if ( ! empty ( $ rationalParts [ 1 ] ) ) { $ metadata [ 'GPSAltitudeDecimal' ] = $ rationalParts [ 0 ] / $ rationalParts [ 1 ] ; } else { $ metadata [ 'GPSAltitudeDecimal' ] = 0 ; } } } $ imageinfo = [ ] ; if ( function_exists ( 'iptcparse' ) && getimagesize ( $ fileName , $ imageinfo ) ) { if ( isset ( $ imageinfo [ 'APP13' ] ) ) { $ data = iptcparse ( $ imageinfo [ 'APP13' ] ) ; $ mapping = [ '2#005' => 'Title' , '2#025' => 'Keywords' , '2#040' => 'Instructions' , '2#080' => 'Creator' , '2#085' => 'CreatorFunction' , '2#090' => 'City' , '2#092' => 'Location' , '2#095' => 'Region' , '2#100' => 'CountryCode' , '2#101' => 'Country' , '2#103' => 'IdentifierWork' , '2#105' => 'CreatorTitle' , '2#110' => 'Credit' , '2#115' => 'Source' , '2#116' => 'Copyright' , '2#120' => 'Description' , '2#122' => 'DescriptionAuthor' , ] ; foreach ( $ mapping as $ iptcKey => $ metadataKey ) { if ( isset ( $ data [ $ iptcKey ] ) ) { $ metadata [ 'IPTC' . $ metadataKey ] = static :: safeUtf8Encode ( $ data [ $ iptcKey ] [ 0 ] ) ; } } } } } return $ metadata ; }
2978	public function getLicenseByIdentifier ( $ identifier ) { $ key = strtolower ( $ identifier ) ; if ( ! isset ( $ this -> licenses [ $ key ] ) ) { return ; } list ( $ identifier , $ name , $ isOsiApproved , $ isDeprecatedLicenseId ) = $ this -> licenses [ $ key ] ; return array ( $ name , $ isOsiApproved , 'https://spdx.org/licenses/' . $ identifier . '.html#licenseText' , $ isDeprecatedLicenseId , ) ; }
3366	private static function apache_modules ( ) { $ mods = WP_CLI :: get_config ( 'apache_modules' ) ; if ( ! empty ( $ mods ) && ! function_exists ( 'apache_get_modules' ) ) { global $ is_apache ; $ is_apache = true ; $ _SERVER [ 'SCRIPT_FILENAME' ] = ABSPATH ; function apache_get_modules ( ) { return WP_CLI :: get_config ( 'apache_modules' ) ; } } }
5817	public function getFusionTagTypes ( ) { $ types = array ( ) ; $ configuration = Config :: inst ( ) ; $ exclusions = $ configuration -> get ( 'FusionService' , 'tag_type_exclusions' ) ; $ classes = ClassInfo :: subclassesFor ( 'DataObject' ) ; unset ( $ classes [ 'FusionTag' ] ) ; foreach ( $ classes as $ class ) { if ( ( strpos ( strrev ( $ class ) , strrev ( 'Tag' ) ) === 0 ) && ! in_array ( $ class , $ exclusions ) && ! ClassInfo :: classImplements ( $ class , 'TestOnly' ) ) { $ types [ $ class ] = 'Title' ; } } foreach ( $ configuration -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( in_array ( $ type , $ classes ) && ! in_array ( $ type , $ exclusions ) ) { $ types [ $ type ] = $ field ; } } return $ types ; }
10991	public function getName ( bool $ includeExtension = false ) : string { $ filename = basename ( $ this -> path ) ; if ( $ includeExtension ) { return $ filename ; } return $ this -> splitName ( ) [ 0 ] ; }
5399	public function setHost ( $ host ) { if ( $ host = $ this -> truncateHost ( $ host ) ) { $ this -> host = $ host ; return true ; } return false ; }
8482	public static function getOS ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Caption FROM Win32_OperatingSystem" ) as $ os ) { return $ os -> Caption ; } return "Windows" ; }
11742	public function add ( Theme $ theme , array $ pageValues ) { $ pageName = $ pageValues [ "name" ] ; $ pageDir = $ this -> pagesDir . '/' . $ pageName ; $ this -> pageExists ( $ pageDir ) ; if ( ! @ mkdir ( $ pageDir ) ) { $ this -> folderNotCreated ( $ pageDir ) ; } $ seoValues = $ pageValues [ "seo" ] ; unset ( $ pageValues [ "seo" ] ) ; $ encodedPage = json_encode ( $ pageValues ) ; $ pageFile = $ pageDir . '/' . $ this -> pageFile ; $ event = Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDING , new PageCollectionAddingEvent ( $ pageFile , $ encodedPage ) ) ; $ encodedPage = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ pageFile , $ encodedPage ) ; if ( $ this -> pageFile != 'page.json' ) { FilesystemTools :: writeFile ( $ pageDir . '/page.json' , $ encodedPage ) ; } foreach ( $ seoValues as $ seoValue ) { $ languageName = $ seoValue [ "language" ] ; unset ( $ seoValue [ "language" ] ) ; $ languageDir = $ pageDir . '/' . $ languageName ; @ mkdir ( $ languageDir ) ; FilesystemTools :: writeFile ( $ languageDir . '/' . $ this -> seoFile , json_encode ( $ seoValue ) ) ; $ theme -> addTemplateSlots ( $ pageValues [ "template" ] , $ this -> username ) ; } Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDED , new PageCollectionAddedEvent ( $ pageFile , $ encodedPage ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully added to the website' , $ pageName ) ) ; return $ pageValues ; }
6450	private function getLanguageValuesFromHeaders ( array $ headers ) : array { $ languages = [ ] ; foreach ( $ headers as $ header ) { $ languages [ ] = $ header -> getLanguage ( ) ; } return $ languages ; }
10550	public function dispatch ( ) { $ response = null ; try { $ this -> resolveApp ( ) ; $ this -> getTemplate ( ) ; $ this -> request -> startSession ( $ this -> vhost -> getHost ( ) , $ this -> config ) ; FlashMessage :: setStorage ( $ this -> request -> session ) ; $ this -> setupLocale ( ) ; if ( $ this -> route === null ) throw new HTTPError ( 404 , 'Could not resolve ' . $ this -> url ) ; $ app = new AppRunner ( $ this -> app , $ this -> arguments ) ; $ app -> setVariables ( $ this -> variables ) ; $ app -> setVariable ( 'dispatcher' , $ this ) ; $ app -> execute ( ) ; } catch ( Throwable $ e ) { if ( ! ( $ e instanceof Response ) ) $ e = new HTTPError ( 500 , "Exception of type " . get_class ( $ e ) . " thrown: " . $ e -> getMessage ( ) , null , $ e ) ; if ( $ e instanceof HTTPError ) $ this -> prepareErrorResponse ( $ e ) ; $ response = $ e ; } return $ response ; }
11683	protected function _pushMessage ( $ message , $ type = 'error' , array $ interpolateParams = [ ] ) { $ this -> _messages [ ] = [ 'message' => vsprintf ( $ message , $ interpolateParams ) , 'type' => $ type , ] ; return $ this ; }
5512	public function expectMaximumCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set maximum call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> max_counts [ strtolower ( $ method ) ] = new MaximumCallCountExpectation ( $ method , $ count , $ message ) ; }
3796	private function checkForRoot ( $ containedModel , $ action ) { if ( $ this -> hasVariants ( ) && $ action == 'cut' && $ containedModel -> getProperty ( 'varbase' ) == 0 ) { $ this -> disablePI = true ; } }
6477	public function readAsMultipart ( ? IHttpBody $ body , string $ boundary ) : ? MultipartBody { if ( $ body === null ) { return null ; } $ rawBodyParts = explode ( "--$boundary" , $ body -> readAsString ( ) ) ; array_shift ( $ rawBodyParts ) ; array_pop ( $ rawBodyParts ) ; $ parsedBodyParts = [ ] ; foreach ( $ rawBodyParts as $ rawBodyPart ) { $ headerStartIndex = strlen ( "\r\n" ) ; $ headerEndIndex = strpos ( $ rawBodyPart , "\r\n\r\n" ) ; $ bodyStartIndex = $ headerEndIndex + strlen ( "\r\n\r\n" ) ; $ bodyEndIndex = strlen ( $ rawBodyPart ) - strlen ( "\r\n" ) ; $ rawHeaders = explode ( "\r\n" , substr ( $ rawBodyPart , $ headerStartIndex , $ headerEndIndex - $ headerStartIndex ) ) ; $ parsedHeaders = new HttpHeaders ( ) ; foreach ( $ rawHeaders as $ headerLine ) { [ $ headerName , $ headerValue ] = explode ( ':' , $ headerLine , 2 ) ; $ parsedHeaders -> add ( trim ( $ headerName ) , trim ( $ headerValue ) ) ; } $ body = new StringBody ( substr ( $ rawBodyPart , $ bodyStartIndex , $ bodyEndIndex - $ bodyStartIndex ) ) ; $ parsedBodyParts [ ] = new MultipartBodyPart ( $ parsedHeaders , $ body ) ; } return new MultipartBody ( $ parsedBodyParts , $ boundary ) ; }
12531	public function getStatus ( $ applyId ) { $ params = [ 'apply_id' => intval ( $ applyId ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_APPLYSTATUS , $ params ] ) ; }
6237	private static function getOptions ( ) { return [ '1/6' => Craft :: t ( 'width-fieldtype' , '1/6' ) , '1/5' => Craft :: t ( 'width-fieldtype' , '1/5' ) , '1/4' => Craft :: t ( 'width-fieldtype' , '1/4' ) , '1/3' => Craft :: t ( 'width-fieldtype' , '1/3' ) , '2/5' => Craft :: t ( 'width-fieldtype' , '2/5' ) , '1/2' => Craft :: t ( 'width-fieldtype' , '1/2' ) , '3/5' => Craft :: t ( 'width-fieldtype' , '3/5' ) , '2/3' => Craft :: t ( 'width-fieldtype' , '2/3' ) , '3/4' => Craft :: t ( 'width-fieldtype' , '3/4' ) , '4/5' => Craft :: t ( 'width-fieldtype' , '4/5' ) , '5/6' => Craft :: t ( 'width-fieldtype' , '5/6' ) , 'full' => Craft :: t ( 'width-fieldtype' , 'Full' ) , ] ; }
2839	public function getFilteredRequestListUrl ( $ filters = array ( ) ) { $ currentFilters = Mage :: helper ( 'sheep_debug/filter' ) -> getRequestFilters ( $ this -> getRequest ( ) ) ; $ filters = array_merge ( $ currentFilters , $ filters ) ; return $ this -> getRequestListUrl ( $ filters ) ; }
10576	public static function applyStyle ( $ text , $ style ) { $ foreground = self :: getForeground ( $ style ) ; $ background = self :: getBackground ( $ style ) ; return self :: apply ( $ text , $ foreground , $ background ) ; }
10087	private function createZip ( $ pFilename ) { $ zip = new ZipArchive ( ) ; if ( file_exists ( $ pFilename ) ) { unlink ( $ pFilename ) ; } if ( $ zip -> open ( $ pFilename , ZipArchive :: OVERWRITE ) !== true ) { if ( $ zip -> open ( $ pFilename , ZipArchive :: CREATE ) !== true ) { throw new WriterException ( "Could not open $pFilename for writing." ) ; } } return $ zip ; }
8090	static public function generate ( $ uid = 0 , $ hash = false ) { if ( $ uid ) { $ e_uid = self :: encode ( $ uid ) ; $ e_uid_length = strlen ( $ e_uid ) ; $ e_uid_length = str_pad ( $ e_uid_length , 2 , 0 , STR_PAD_LEFT ) ; $ e_uid_pos = rand ( 10 , 32 - $ e_uid_length - 1 ) ; if ( ! $ hash ) { $ hash = sha1 ( uniqid ( rand ( ) , true ) ) ; } $ code = $ e_uid_pos . $ e_uid_length ; $ code .= substr ( $ hash , 0 , $ e_uid_pos - strlen ( $ code ) ) ; $ code .= $ e_uid ; $ code .= substr ( $ hash , strlen ( $ code ) ) ; return $ code ; } else { return sha1 ( uniqid ( rand ( ) , true ) ) ; } }
11010	public function addDefaultSrc ( string $ source ) : bool { if ( ! in_array ( $ source , $ this -> tags [ 'default-src' ] ) ) { $ this -> tags [ 'default-src' ] [ ] = $ source ; return true ; } return false ; }
1463	private function guessColumn ( ) { if ( $ this -> query instanceof EloquentBuilder || $ this -> query instanceof Relation ) { return $ this -> query -> getModel ( ) -> getCreatedAtColumn ( ) ; } return Model :: CREATED_AT ; }
11469	public function show ( ResponseRequest $ request , Response $ response ) { if ( $ response -> exists ) { $ view = 'forum::response.show' ; } else { $ view = 'forum::response.new' ; } return $ this -> response -> title ( trans ( 'app.view' ) . ' ' . trans ( 'forum::response.name' ) ) -> data ( compact ( 'response' ) ) -> view ( $ view , true ) -> output ( ) ; }
12233	public function moveTo ( SimpleXMLElement $ dst ) { return simplexml_import_dom ( dom_import_simplexml ( $ dst ) , get_class ( $ this ) ) -> appendChild ( $ this -> removeSelf ( ) ) ; }
3929	protected function build ( IMetaModelDataDefinition $ container ) { $ inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( ! $ inputScreen ) { return ; } if ( $ container -> hasPropertiesDefinition ( ) ) { $ definition = $ container -> getPropertiesDefinition ( ) ; } else { $ definition = new DefaultPropertiesDefinition ( ) ; $ container -> setPropertiesDefinition ( $ definition ) ; } $ metaModel = $ this -> factory -> getMetaModel ( $ container -> getName ( ) ) ; if ( $ metaModel -> hasVariants ( ) ) { $ this -> getOrCreateProperty ( $ definition , 'varbase' ) ; $ this -> getOrCreateProperty ( $ definition , 'vargroup' ) ; } $ properties = [ ] ; foreach ( $ inputScreen [ 'properties' ] as $ property ) { if ( 'attribute' !== $ property [ 'dcatype' ] ) { continue ; } $ properties [ $ property [ 'attr_id' ] ] = $ property ; } foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( ! isset ( $ properties [ $ attribute -> get ( 'id' ) ] ) ) { continue ; } $ this -> buildProperty ( $ definition , $ attribute , $ attribute -> getFieldDefinition ( $ properties [ $ attribute -> get ( 'id' ) ] ) ) ; $ event = new BuildAttributeEvent ( $ metaModel , $ attribute , $ container ) ; $ this -> dispatcher -> dispatch ( $ event :: NAME , $ event ) ; } }
11366	public static function formatText ( $ txt = '' , $ type = 'plain' , $ spaces = false ) { switch ( $ type ) { case 'ascii' : $ _txt = '' ; if ( $ spaces == true ) { $ txt = str_replace ( ' ' , '_' , $ txt ) ; } for ( $ i = 0 ; $ i < strlen ( $ txt ) ; $ i ++ ) { $ _txt .= self :: charAscii ( $ txt [ $ i ] ) ; } $ txt = $ _txt ; break ; default : break ; } $ mailer = Mailer :: getInstance ( ) ; $ limit = $ mailer -> getOption ( 'wordwrap_limit' ) ; $ formated = '' ; foreach ( explode ( "\n" , $ txt ) as $ _line ) { $ _line = trim ( $ _line ) ; if ( strlen ( $ _line ) > $ limit ) { $ _line = wordwrap ( $ _line , $ limit , Mailer :: $ LINE_ENDING ) ; } if ( strlen ( $ _line ) ) { $ formated .= $ _line . Mailer :: $ LINE_ENDING ; } } return $ formated ; }
8464	public static function getDomain ( $ url = false ) { if ( $ url ) { preg_match ( '/([\w]+[.]){1,}[a-z]+/' , $ url , $ matches ) ; return isset ( $ matches [ 0 ] ) ? $ matches [ 0 ] : false ; } return $ _SERVER [ 'SERVER_NAME' ] ; }
5906	public function listSettings ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/settings' , $ parameters , $ cachePolicy ) ; return $ result ; }
11027	protected function city ( ) { $ pluginOptions = [ 'url' => Url :: to ( [ "/{$this->module->id}/city/list" ] ) , 'depends' => [ $ this -> fieldIds [ 'country' ] ] ] ; if ( isset ( $ this -> fieldIds [ 'state' ] ) ) { $ pluginOptions [ 'depends' ] [ ] = $ this -> fieldIds [ 'state' ] ; $ pluginOptions [ 'initDepends' ] = [ $ this -> fieldIds [ 'country' ] ] ; } else { $ pluginOptions [ 'depends' ] [ ] = null ; } if ( isset ( $ this -> fieldIds [ 'region' ] ) ) { $ pluginOptions [ 'depends' ] [ ] = $ this -> fieldIds [ 'region' ] ; if ( isset ( $ this -> fieldIds [ 'state' ] ) ) { $ pluginOptions [ 'initDepends' ] [ ] = $ this -> fieldIds [ 'state' ] ; } } else { $ pluginOptions [ 'depends' ] [ ] = null ; } $ this -> parts [ '{city}' ] = $ this -> form -> field ( $ this -> model , $ this -> model -> getCityPropertyName ( ) ) -> widget ( DepDrop :: className ( ) , [ 'options' => [ 'id' => $ this -> fieldIds [ 'city' ] , 'cityholder' => Yii :: t ( 'jlorente/location' , 'Select city' ) , 'name' => $ this -> getSubmitModelName ( $ this -> model -> getCityPropertyName ( ) ) ] , 'data' => ArrayHelper :: map ( City :: find ( ) -> where ( [ 'region_id' => $ this -> model -> region_id ] ) -> orderBy ( [ 'name' => SORT_ASC ] ) -> all ( ) , 'id' , 'name' ) , 'pluginOptions' => $ pluginOptions ] ) ; }
3522	public static function refresh ( $ refresh_token ) { $ data = FortniteClient :: sendUnrealClientPostRequest ( FortniteClient :: EPIC_OAUTH_TOKEN_ENDPOINT , [ 'grant_type' => 'refresh_token' , 'refresh_token' => $ refresh_token , 'includePerms' => "false" , 'token_type' => 'eg1' , ] , FortniteClient :: FORTNITE_AUTHORIZATION ) ; if ( ! $ data -> access_token ) { throw new \ Exception ( $ data -> errorMessage ) ; } return new self ( $ data -> access_token , $ data -> in_app_id , $ data -> refresh_token , $ data -> account_id , $ data -> expires_in ) ; }
3515	public function getLocale ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'lang_locale' ; $ queuedCookieLocale = \ Cookie :: queued ( $ key , null ) ; $ locale = getSupportedLocale ( $ queuedCookieLocale != null ? $ queuedCookieLocale -> getValue ( ) : \ Cookie :: get ( $ key , '' ) ) ; parent :: setLocale ( $ locale ) ; $ this -> getShowUnpublished ( ) ; $ this -> cookiesLoaded = true ; } return parent :: getLocale ( ) ; }
1033	private function getPromise ( $ value ) { if ( $ value === null || $ value instanceof Promise ) { return $ value ; } if ( $ this -> exeContext -> promises -> isThenable ( $ value ) ) { $ promise = $ this -> exeContext -> promises -> convertThenable ( $ value ) ; if ( ! $ promise instanceof Promise ) { throw new InvariantViolation ( sprintf ( '%s::convertThenable is expected to return instance of GraphQL\Executor\Promise\Promise, got: %s' , get_class ( $ this -> exeContext -> promises ) , Utils :: printSafe ( $ promise ) ) ) ; } return $ promise ; } return null ; }
990	public static function validate ( Schema $ schema , DocumentNode $ ast , ? array $ rules = null , ? TypeInfo $ typeInfo = null ) { if ( $ rules === null ) { $ rules = static :: allRules ( ) ; } if ( is_array ( $ rules ) === true && count ( $ rules ) === 0 ) { return [ ] ; } $ typeInfo = $ typeInfo ? : new TypeInfo ( $ schema ) ; return static :: visitUsingRules ( $ schema , $ typeInfo , $ ast , $ rules ) ; }
11371	public function destroy ( $ menuId = null ) { if ( $ menuId !== null ) { return $ this -> parseJSON ( 'json' , [ self :: API_CONDITIONAL_DELETE , [ 'menuid' => $ menuId ] ] ) ; } return $ this -> parseJSON ( 'get' , [ self :: API_DELETE ] ) ; }
12437	public function addFormField ( IFormField $ field , $ isExtra = false ) { $ fieldId = $ field -> getId ( ) ; if ( empty ( $ fieldId ) ) { throw new \ LogicException ( 'The access path of a form field must not be empty' ) ; } $ field -> setParent ( $ this ) ; $ this -> children [ $ fieldId ] = $ field ; if ( $ isExtra === false ) { $ mappingContext = new MappingContext ( $ this , $ field , $ this -> accessorChain ) ; $ this -> mappingContexts [ $ fieldId ] = $ mappingContext ; } return $ field ; }
5269	private function translateSelect ( ) { $ build = array ( 'select' ) ; if ( $ this -> found_rows ) { $ build [ ] = 'SQL_CALC_FOUND_ROWS' ; } if ( $ this -> distinct ) { $ build [ ] = 'distinct' ; } $ build [ ] = ! empty ( $ this -> statements [ 'select' ] ) && is_array ( $ this -> statements [ 'select' ] ) ? join ( ', ' , $ this -> statements [ 'select' ] ) : '*' ; $ build [ ] = 'from ' . $ this -> table ; if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> statements [ 'groups' ] ) ) { $ build [ ] = 'group by ' . join ( ', ' , $ this -> statements [ 'groups' ] ) ; if ( ! empty ( $ this -> statements [ 'having' ] ) ) { $ build [ ] = $ this -> statements [ 'having' ] ; } } if ( ! empty ( $ this -> statements [ 'orders' ] ) ) { $ build [ ] = $ this -> translateOrderBy ( ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
12488	public static function write ( $ output ) { if ( self :: $ enabled ) { $ d = new \ DateTime ( ) ; $ f = new File ( self :: $ logFilePath , true ) ; $ f -> write ( $ d -> format ( 'd/m/Y H:i:s' ) . ' - ' . $ output . "\n" , true ) ; } }
1077	public static function typeFromAST ( Schema $ schema , $ inputTypeNode ) { if ( $ inputTypeNode instanceof ListTypeNode ) { $ innerType = self :: typeFromAST ( $ schema , $ inputTypeNode -> type ) ; return $ innerType ? new ListOfType ( $ innerType ) : null ; } if ( $ inputTypeNode instanceof NonNullTypeNode ) { $ innerType = self :: typeFromAST ( $ schema , $ inputTypeNode -> type ) ; return $ innerType ? new NonNull ( $ innerType ) : null ; } if ( $ inputTypeNode instanceof NamedTypeNode ) { return $ schema -> getType ( $ inputTypeNode -> name -> value ) ; } throw new Error ( 'Unexpected type kind: ' . $ inputTypeNode -> kind . '.' ) ; }
5315	protected function generateBlocks ( ) { $ blocks = [ ] ; foreach ( range ( 1 , $ this -> getBlocks ( ) ) as $ counter ) { $ blocks [ ] = $ this -> generateChars ( ) ; } return implode ( $ this -> blockSeparator , $ blocks ) ; }
5490	public static function addItemAsArray ( & $ array , $ key , $ item ) { $ array_key = $ key . '[]' ; if ( array_key_exists ( $ array_key , $ array ) ) { $ array [ $ array_key ] [ ] = $ item ; } else { $ array [ $ array_key ] = array ( $ item ) ; } }
7848	private function checkConfig ( ) : void { if ( empty ( $ this -> device ) ) { Log :: warning ( 'Config "message.smsgatewayme.device" is not defined.' ) ; } if ( empty ( $ this -> token ) ) { Log :: warning ( 'Config "message.smsgatewayme.token" is not defined.' ) ; } }
991	public static function allRules ( ) { if ( ! self :: $ initRules ) { static :: $ rules = array_merge ( static :: defaultRules ( ) , self :: securityRules ( ) , self :: $ rules ) ; static :: $ initRules = true ; } return self :: $ rules ; }
1686	public function updateCurrentUser ( Contao \ DataContainer $ dc ) { if ( $ this -> User -> id == $ dc -> id ) { $ this -> User -> findBy ( 'id' , $ this -> User -> id ) ; } }
11967	public function getPidByProgramName ( $ name ) { $ process = new Process ( sprintf ( 'supervisorctl pid %s' , $ name ) ) ; $ process -> run ( ) ; return $ process -> getOutput ( ) ; }
856	public function overrideAt ( $ index , $ token ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0, use offsetSet instead.' , E_USER_DEPRECATED ) ; self :: $ isLegacyMode = true ; $ this [ $ index ] -> override ( $ token ) ; $ this -> registerFoundToken ( $ token ) ; }
10183	private function getAllCacheKeys ( ) { $ keys = [ ] ; foreach ( $ this -> getCoordinates ( ) as $ coordinate ) { $ keys [ ] = $ this -> cachePrefix . $ coordinate ; } return $ keys ; }
2719	private function isHostInDomainList ( $ host ) { $ urlTypes = [ UrlInterface :: URL_TYPE_LINK , UrlInterface :: URL_TYPE_DIRECT_LINK , UrlInterface :: URL_TYPE_WEB , UrlInterface :: URL_TYPE_MEDIA , UrlInterface :: URL_TYPE_STATIC ] ; $ secureScheme = [ true , false ] ; foreach ( $ this -> storeManager -> getStores ( ) as $ store ) { foreach ( $ urlTypes as $ urlType ) { foreach ( $ secureScheme as $ scheme ) { $ shopHost = \ Zend_Uri :: factory ( $ store -> getBaseUrl ( $ urlType , $ scheme ) ) -> getHost ( ) ; if ( $ host === $ shopHost ) { return true ; } } } } return false ; }
12046	public function getThumbnails ( $ videoId , $ format = null ) { $ listResponse = $ this -> videos -> listVideos ( 'snippet' , array ( 'id' => $ videoId ) ) ; if ( empty ( $ listResponse ) ) { throw new \ RuntimeException ( sprintf ( 'Could not find video with id %s' , $ videoId ) ) ; } $ video = $ listResponse [ 0 ] ; $ videoSnippet = $ video [ 'snippet' ] ; if ( is_null ( $ format ) ) { return $ videoSnippet [ 'thumbnails' ] [ 'data' ] ; } if ( ! in_array ( $ format , array ( 'default' , 'medium' , 'high' ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid format "%s"' , $ format ) ) ; } return $ videoSnippet [ 'thumbnails' ] [ 'data' ] [ $ format ] ; }
3664	private function getValueFromSource ( $ source , $ valueName , $ arguments ) { switch ( strtolower ( $ source ) ) { case 'get' : return $ this -> container -> get ( Input :: class ) -> get ( $ valueName ) ; case 'post' : return $ this -> container -> get ( Input :: class ) -> post ( $ valueName ) ; case 'cookie' : return $ this -> container -> get ( Input :: class ) -> cookie ( $ valueName ) ; case 'session' : return $ this -> container -> get ( Session :: class ) -> get ( $ valueName ) ; case 'filter' : if ( is_array ( $ this -> filterParameters ) ) { if ( array_key_exists ( $ valueName , $ this -> filterParameters ) ) { return $ this -> filterParameters [ $ valueName ] ; } return null ; } break ; case 'container' : @ trigger_error ( 'Getting filter values from the service container is deprecated, the container will get removed.' , E_USER_DEPRECATED ) ; return $ this -> getValueFromServiceContainer ( $ valueName , $ arguments ) ; default : } return null ; }
10946	public function post ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getBodyParams ( ) ; } else { return $ this -> getBodyParam ( $ name , $ defaultValue ) ; } }
642	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
5613	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , false ) ; $ current = $ this -> _stack -> peek ( ) ; $ current -> putChild ( $ node ) ; $ current -> fail ( ) ; }
7684	function XML_DeleteElements ( & $ Txt , $ TagLst , $ OnlyInner = false ) { $ nbr_del = 0 ; foreach ( $ TagLst as $ tag ) { $ t_open = '<' . $ tag ; $ t_close = '</' . $ tag ; $ p1 = 0 ; while ( ( $ p1 = $ this -> XML_FoundTagStart ( $ Txt , $ t_open , $ p1 ) ) !== false ) { $ pe1 = strpos ( $ Txt , '>' , $ p1 ) ; if ( $ pe1 === false ) return false ; $ p2 = false ; if ( substr ( $ Txt , $ pe1 - 1 , 1 ) == '/' ) { $ pe2 = $ pe1 ; } else { $ p2 = $ this -> XML_FoundTagStart ( $ Txt , $ t_close , $ pe1 ) ; if ( $ p2 === false ) return false ; $ pe2 = strpos ( $ Txt , '>' , $ p2 ) ; } if ( $ pe2 === false ) return false ; if ( $ OnlyInner ) { if ( $ p2 !== false ) $ Txt = substr_replace ( $ Txt , '' , $ pe1 + 1 , $ p2 - $ pe1 - 1 ) ; $ p1 = $ pe1 ; } else { $ Txt = substr_replace ( $ Txt , '' , $ p1 , $ pe2 - $ p1 + 1 ) ; } } } return $ nbr_del ; }
6863	protected function registerManager ( ) { $ this -> app -> singleton ( 'notifyme' , function ( $ app ) { $ config = $ app [ 'config' ] ; $ factory = $ app [ 'notifyme.factory' ] ; return new NotifyMeManager ( $ config , $ factory ) ; } ) ; $ this -> app -> alias ( 'notifyme' , NotifyMeManager :: class ) ; $ this -> app -> alias ( 'notifyme' , ManagerInterface :: class ) ; }
6439	public function getUserProfile ( ) { $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] , $ this -> access_token [ 'oauth_token' ] , $ this -> access_token [ 'oauth_token_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ user = $ connection -> get ( "account/verify_credentials" ) ; return array ( 'userid' => $ user -> id , 'name' => $ user -> screen_name , 'imageurl' => $ user -> profile_image_url ) ; }
9395	public function buildCommand ( ) { if ( $ this -> escape !== false ) { $ this -> options = $ this -> escape ( $ this -> options ) ; } if ( $ this -> builder !== null ) { $ this -> command = $ this -> builder -> build ( $ this -> options ) ; } return $ this ; }
12259	public function compile ( callable $ validator = NULL ) { if ( ! ( $ project = $ this -> getProject ( ) ) ) { $ project = CC :: get ( $ this -> getConfiguration ( ) , CC :: COMPILER_PROJECT ) ; if ( ! $ project ) throw new CompilerException ( "Compilation without project settings is not possible" ) ; } $ this -> project = $ project ; try { set_error_handler ( function ( $ code , $ msg , $ file , $ line ) { switch ( AbstractErrorHandlerService :: detectErrorLevel ( $ code ) ) { case AbstractErrorHandlerService :: NOTICE_ERROR_LEVEL : return $ this -> getLogger ( ) -> logNotice ( $ msg , [ $ file , $ line ] ) ; case AbstractErrorHandlerService :: DEPRECATED_ERROR_LEVEL : case AbstractErrorHandlerService :: WARNING_ERROR_LEVEL : return $ this -> getLogger ( ) -> logWarning ( $ msg , [ $ file , $ line ] ) ; default : return $ this -> getLogger ( ) -> logError ( $ msg , [ $ file , $ line ] ) ; } } ) ; foreach ( $ this -> getOrganizedCompilers ( ) as $ compiler ) { if ( ! $ validator || $ validator ( $ compiler ) ) $ compiler -> compile ( $ this ) ; } } catch ( Throwable $ throwable ) { $ this -> getLogger ( ) -> logException ( $ throwable ) ; } finally { restore_error_handler ( ) ; } }
2634	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippet = $ this -> getRequest ( ) -> getParam ( 'snippet_id' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ write = $ this -> filesystem -> getDirectoryWrite ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ write -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ snippet ) ; $ snippetName = explode ( '_' , $ snippet ) ; $ snippetName = explode ( '.' , $ snippetName [ 2 ] ) ; $ reqName = Config :: FASTLY_MAGENTO_MODULE . '_' . $ snippetName [ 0 ] ; $ checkIfSnippetExist = $ this -> api -> hasSnippet ( $ activeVersion , $ reqName ) ; if ( $ checkIfSnippetExist ) { $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ this -> api -> removeSnippet ( $ clone -> number , $ reqName ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ comment = [ 'comment' => 'Magento Module deleted the ' . $ reqName . ' custom snippet.' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; } if ( $ write -> isExist ( $ snippetPath ) ) { $ write -> delete ( $ snippetPath ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
551	public function actionFlush ( ) { $ cachesInput = func_get_args ( ) ; if ( empty ( $ cachesInput ) ) { throw new Exception ( 'You should specify cache components names' ) ; } $ caches = $ this -> findCaches ( $ cachesInput ) ; $ cachesInfo = [ ] ; $ foundCaches = array_keys ( $ caches ) ; $ notFoundCaches = array_diff ( $ cachesInput , array_keys ( $ caches ) ) ; if ( $ notFoundCaches ) { $ this -> notifyNotFoundCaches ( $ notFoundCaches ) ; } if ( ! $ foundCaches ) { $ this -> notifyNoCachesFound ( ) ; return ExitCode :: OK ; } if ( ! $ this -> confirmFlush ( $ foundCaches ) ) { return ExitCode :: OK ; } foreach ( $ caches as $ name => $ class ) { $ cachesInfo [ ] = [ 'name' => $ name , 'class' => $ class , 'is_flushed' => $ this -> canBeFlushed ( $ class ) ? Yii :: $ app -> get ( $ name ) -> flush ( ) : false , ] ; } $ this -> notifyFlushed ( $ cachesInfo ) ; }
6871	private function initializeMethod ( ShipmentInterface $ shipment ) { if ( null !== $ shipment -> getMethod ( ) ) { return ; } $ sale = $ shipment -> getSale ( ) ; if ( null === $ method = $ sale -> getShipmentMethod ( ) ) { return ; } $ gateway = $ this -> registry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( ! $ shipment -> isReturn ( ) && $ gateway -> supports ( GatewayInterface :: CAPABILITY_SHIPMENT ) ) { $ shipment -> setMethod ( $ method ) ; return ; } if ( $ shipment -> isReturn ( ) && $ gateway -> supports ( GatewayInterface :: CAPABILITY_RETURN ) ) { $ shipment -> setMethod ( $ method ) ; return ; } }
2308	public function setImportantPart ( array $ importantPart = null ) { if ( $ importantPart !== null ) { if ( ! isset ( $ importantPart [ 'x' ] ) || ! isset ( $ importantPart [ 'y' ] ) || ! isset ( $ importantPart [ 'width' ] ) || ! isset ( $ importantPart [ 'height' ] ) ) { throw new \ InvalidArgumentException ( 'Malformed array for setting the important part!' ) ; } $ this -> importantPart = array ( 'x' => max ( 0 , min ( $ this -> fileObj -> viewWidth - 1 , ( int ) $ importantPart [ 'x' ] ) ) , 'y' => max ( 0 , min ( $ this -> fileObj -> viewHeight - 1 , ( int ) $ importantPart [ 'y' ] ) ) , ) ; $ this -> importantPart [ 'width' ] = max ( 1 , min ( $ this -> fileObj -> viewWidth - $ this -> importantPart [ 'x' ] , ( int ) $ importantPart [ 'width' ] ) ) ; $ this -> importantPart [ 'height' ] = max ( 1 , min ( $ this -> fileObj -> viewHeight - $ this -> importantPart [ 'y' ] , ( int ) $ importantPart [ 'height' ] ) ) ; } else { $ this -> importantPart = null ; } return $ this ; }
8310	public function standardizeUrlFormat ( & $ rules , $ pageUrl ) { if ( ! is_string ( $ pageUrl ) || $ pageUrl === "" || ! is_array ( $ rules ) || ! array_key_exists ( $ pageUrl , $ rules ) ) { return ; } $ oldIndex = $ pageUrl ; if ( $ pageUrl [ 0 ] !== '/' ) { $ pageUrl = '/' . $ pageUrl ; } $ len = strlen ( $ pageUrl ) ; if ( $ len > 1 && $ pageUrl [ $ len - 1 ] === '/' ) { $ pageUrl = rtrim ( $ pageUrl , '/' ) ; } if ( $ oldIndex !== $ pageUrl ) { $ rules [ $ pageUrl ] = $ rules [ $ oldIndex ] ; unset ( $ rules [ $ oldIndex ] ) ; } }
3133	public function getRubrics ( RunnerServiceContext $ context , AssessmentItemRef $ itemRef = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ rubricHelper = $ this -> getServiceLocator ( ) -> get ( QtiRunnerRubric :: SERVICE_ID ) ; return $ rubricHelper -> getRubrics ( $ context , $ itemRef ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getRubrics' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
1894	public function generate ( ) { if ( $ this -> singleSRC == '' ) { return '' ; } $ objFile = FilesModel :: findByUuid ( $ this -> singleSRC ) ; if ( $ objFile === null || ! is_file ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ objFile -> path ) ) { return '' ; } $ this -> singleSRC = $ objFile -> path ; $ this -> objFilesModel = $ objFile ; return parent :: generate ( ) ; }
4018	protected function initializeWidget ( & $ arrField , $ strRow , $ strKey , $ varValue ) { $ xlabel = $ this -> getHelpWizard ( $ strKey , $ arrField ) ; if ( isset ( $ arrField [ 'input_field_callback' ] ) && is_array ( $ arrField [ 'input_field_callback' ] ) ) { if ( ! is_object ( $ this -> $ arrField [ 'input_field_callback' ] [ 0 ] ) ) { $ this -> import ( $ arrField [ 'input_field_callback' ] [ 0 ] ) ; } return $ this -> { $ arrField [ 'input_field_callback' ] [ 0 ] } -> $ arrField [ 'input_field_callback' ] [ 1 ] ( $ this , $ xlabel ) ; } $ strClass = $ this -> getWidgetClass ( $ arrField ) ; if ( empty ( $ strClass ) ) { return null ; } $ varValue = $ this -> handleLoadCallback ( $ arrField , $ varValue ) ; $ arrField = $ this -> makeMandatory ( $ arrField , $ strRow , $ strKey ) ; $ arrField [ 'name' ] = $ this -> strName . '[' . $ strRow . '][' . $ strKey . ']' ; $ arrField [ 'id' ] = $ this -> strId . '_' . $ strRow . '_' . $ strKey ; $ arrField [ 'value' ] = ( $ varValue !== '' ) ? $ varValue : $ arrField [ 'default' ] ; $ arrField [ 'eval' ] [ 'tableless' ] = true ; $ event = new GetAttributesFromDcaEvent ( $ arrField , $ arrField [ 'name' ] , $ arrField [ 'value' ] , null , $ this -> strTable , $ this -> objDca ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: WIDGET_GET_ATTRIBUTES_FROM_DCA , $ event ) ; $ objWidget = new $ strClass ( $ event -> getResult ( ) ) ; $ objWidget -> strId = $ arrField [ 'id' ] ; $ objWidget -> storeValues = true ; $ objWidget -> xlabel = $ xlabel ; return $ objWidget ; }
4871	public function setEventPrototype ( EventInterface $ prototype ) { if ( ! $ prototype instanceof DependencyResultEvent ) { throw new \ InvalidArgumentException ( 'This event manager only accepts events of the type ' . DependencyResultEvent :: class ) ; } parent :: setEventPrototype ( $ prototype ) ; }
3933	private function setDescription ( PropertyInterface $ property , $ propInfo ) { if ( $ property -> getDescription ( ) || ! isset ( $ propInfo [ 'description' ] ) ) { return ; } $ property -> setDescription ( $ propInfo [ 'description' ] ) ; }
3179	public function getQtiItems ( \ core_kernel_classes_Class $ itemClass , $ format = 'list' , $ search = '' , $ offset = 0 , $ limit = 30 ) { $ propertyFilters = [ ] ; if ( $ this -> hasOption ( self :: ITEM_MODEL_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_MODEL_URI ] = $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) ; } if ( $ this -> hasOption ( self :: ITEM_CONTENT_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_CONTENT_URI ] = '*' ; } if ( is_string ( $ search ) && strlen ( trim ( $ search ) ) > 0 ) { $ propertyFilters [ self :: LABEL_URI ] = $ search ; } if ( is_array ( $ search ) ) { foreach ( $ search as $ uri => $ value ) { if ( is_string ( $ uri ) && ( is_string ( $ value ) && strlen ( trim ( $ value ) ) > 0 ) || ( is_array ( $ value ) && count ( $ value ) > 0 ) ) { $ propertyFilters [ $ uri ] = $ value ; } } } $ result = [ ] ; if ( in_array ( $ format , self :: $ formats ) ) { $ itemLookup = $ this -> getServiceLocator ( ) -> get ( self :: SERVICE_ID . '/' . $ format ) ; if ( ! is_null ( $ itemLookup ) && $ itemLookup instanceof ItemLookup ) { $ result = $ itemLookup -> getItems ( $ itemClass , $ propertyFilters , $ offset , $ limit ) ; } } return $ result ; }
9331	private function region ( $ filter , $ resource , $ region , $ colorspace = null , $ value = null ) { $ dest = imagecreatetruecolor ( $ region [ "w" ] , $ region [ "h" ] ) ; if ( ! imagecopy ( $ dest , $ resource , 0 , 0 , $ region [ "x" ] , $ region [ "y" ] , $ region [ "w" ] , $ region [ "h" ] ) ) { throw new ezcImageFilterFailedException ( "1/ {$function} applied on region {$region['x']}x{$region['y']}" ) ; } if ( ! $ colorspace ) { if ( $ filter == "pixelateImg" ) { $ result = $ this -> $ filter ( $ dest , imagesx ( $ resource ) , imagesy ( $ resource ) ) ; } else $ result = $ this -> $ filter ( $ dest , $ value ) ; } else { $ this -> setActiveResource ( $ dest ) ; parent :: colorspace ( $ colorspace ) ; $ result = $ dest ; } if ( ! imagecopy ( $ resource , $ result , $ region [ "x" ] , $ region [ "y" ] , 0 , 0 , $ region [ "w" ] , $ region [ "h" ] ) ) { throw new ezcImageFilterFailedException ( "2/ {$function} applied on region {$region['x']}x{$region['y']}" ) ; } return $ resource ; }
12040	public function getCurrentUser ( ) { $ this -> authenticated = false ; $ authenticate = $ this -> session -> get ( "handler" , "auth" ) ; if ( is_a ( $ authenticate , Authenticate :: class ) ) { if ( $ authenticate -> authenticated ) { $ this -> authenticated = true ; $ this -> authority = $ this -> session -> getAuthority ( ) ; return $ this -> loadObjectByURI ( $ authenticate -> get ( "user_name_id" ) , [ ] , true ) ; } } return $ this ; }
4189	protected function dumpConstants ( $ constants ) { $ str = '' ; if ( $ constants && $ this -> debug -> output -> getCfg ( 'outputConstants' ) ) { $ str = '<dt class="constants">constants</dt>' . "\n" ; foreach ( $ constants as $ k => $ value ) { $ str .= '<dd class="constant">' . '<span class="constant-name">' . $ k . '</span>' . ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ value ) . '</dd>' . "\n" ; } } return $ str ; }
5996	public function setSavedSearch ( $ savedSearch ) { if ( $ savedSearch instanceof SavedSearch ) { $ this -> savedSearch = $ savedSearch ; } elseif ( is_array ( $ savedSearch ) ) { $ this -> savedSearch = new SavedSearch ( $ savedSearch ) ; } else { $ this -> savedSearch = null ; trigger_error ( 'Argument must be an object of class SavedSearch. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
1407	protected function getModelAttributes ( Model $ model ) { $ attributes = [ ] ; foreach ( $ this -> attributeKeys ( $ model ) as $ modelKey => $ field ) { if ( is_numeric ( $ modelKey ) ) { $ modelKey = $ field ; $ field = $ this -> fieldForAttribute ( $ field ) ; } $ attributes [ $ field ] = $ this -> extractAttribute ( $ model , $ modelKey , $ field ) ; } return $ attributes ; }
11201	public function fetchOffset ( $ num ) { if ( $ this -> contentModified ) { $ this -> generateContent ( ) ; } $ key = $ this -> fetchOffsetKey ( $ num ) ; if ( $ key != null ) { return $ this -> content [ $ key ] ; } return null ; }
12773	public function __async_authorize ( $ hashEmail = null , $ hashPassword = null ) { $ result = array ( 'status' => '0' ) ; if ( ! isset ( $ hashEmail ) ) { if ( isset ( $ _POST ) && isset ( $ _POST [ $ this -> dbHashEmailField ] ) ) { $ hashEmail = $ _POST [ $ this -> dbHashEmailField ] ; } elseif ( isset ( $ _GET ) && isset ( $ _GET [ $ this -> dbHashEmailField ] ) ) { $ hashEmail = $ _GET [ $ this -> dbHashEmailField ] ; } else { $ result [ 'email_error' ] = "\n" . '[' . $ this -> dbHashEmailField . '] field is not passed' ; } } if ( ! isset ( $ hashPassword ) ) { if ( isset ( $ _POST ) && isset ( $ _POST [ $ this -> dbHashPasswordField ] ) ) { $ hashPassword = $ _POST [ $ this -> dbHashPasswordField ] ; } elseif ( isset ( $ _GET ) && isset ( $ _GET [ $ this -> dbHashPasswordField ] ) ) { $ hashPassword = $ _GET [ $ this -> dbHashPasswordField ] ; } else { $ result [ 'email_error' ] = "\n" . '[' . $ this -> dbHashPasswordField . '] field is not passed' ; } } if ( isset ( $ hashEmail ) && isset ( $ hashPassword ) ) { $ hashEmail = $ this -> hash ( $ hashEmail ) ; $ hashPassword = $ this -> hash ( $ hashPassword ) ; $ authorizeResult = $ this -> authorizeWithEmail ( $ hashEmail , $ hashPassword ) ; if ( $ authorizeResult -> code == EmailStatus :: SUCCESS_EMAIL_AUTHORIZE ) { $ result [ 'status' ] = '1' ; } $ result [ self :: RESPONSE_STATUS_TEXTFIELD ] = $ authorizeResult -> text ; $ result [ self :: RESPONSE_STATUS_FIELD ] = $ authorizeResult -> code ; $ result = array_merge ( $ result , $ authorizeResult -> response ) ; } return $ result ; }
10487	public function applyMapping ( $ params , $ mapping ) { $ newParams = [ ] ; foreach ( $ params as $ key => $ value ) { $ newParams [ $ mapping [ $ key ] ] = $ value ; } return $ newParams ; }
561	public static function autoload ( $ className ) { if ( isset ( static :: $ classMap [ $ className ] ) ) { $ classFile = static :: $ classMap [ $ className ] ; if ( $ classFile [ 0 ] === '@' ) { $ classFile = static :: getAlias ( $ classFile ) ; } } elseif ( strpos ( $ className , '\\' ) !== false ) { $ classFile = static :: getAlias ( '@' . str_replace ( '\\' , '/' , $ className ) . '.php' , false ) ; if ( $ classFile === false || ! is_file ( $ classFile ) ) { return ; } } else { return ; } include $ classFile ; if ( YII_DEBUG && ! class_exists ( $ className , false ) && ! interface_exists ( $ className , false ) && ! trait_exists ( $ className , false ) ) { throw new UnknownClassException ( "Unable to find '$className' in file: $classFile. Namespace missing?" ) ; } }
12049	public static function showImageInSize ( int $ iImageUri , int $ iWidth , int $ iHeight , bool $ bKeepDimension = false ) { $ aSize = getimagesize ( $ iImageUri ) ; $ rActualImage = imagecreatefromjpeg ( $ iImageUri ) ; $ ImageChoisie = imagecreatefromjpeg ( $ _FILES [ 'ImageNews' ] [ 'tmp_name' ] ) ; $ TailleImageChoisie = getimagesize ( $ _FILES [ 'ImageNews' ] [ 'tmp_name' ] ) ; $ rNewImage = imagecreatetruecolor ( $ iWidth , $ iHeight ) ; if ( $ bKeepDimension === false ) { imagecopyresampled ( $ rNewImage , $ rActualImage , 0 , 0 , 0 , 0 , $ iWidth , $ iHeight , $ aSize [ 0 ] , $ aSize [ 1 ] ) ; } else { if ( $ aSize [ 0 ] > $ aSize [ 1 ] ) { $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; $ fCoef = $ aSize [ 1 ] / $ aSize [ 0 ] ; $ iHeight = round ( $ iWidth * $ fCoef ) ; $ iDestY = round ( ( $ iWidth - $ iHeight ) / 2 ) ; $ iDestX = 0 ; } else { $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; $ fCoef = $ aSize [ 0 ] / $ aSize [ 1 ] ; $ iWidth = round ( $ iHeight * $ fCoef ) ; $ iDestX = round ( ( $ iHeight - $ iWidth ) / 2 ) ; $ iDestY = 0 ; } $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; imagecopyresampled ( $ rNewImage , $ rActualImage , $ iDestX , $ iDestY , 0 , 0 , $ iWidth , $ iHeight , $ aSize [ 0 ] , $ aSize [ 1 ] ) ; } imagedestroy ( $ rActualImage ) ; $ NomImageChoisie = explode ( '.' , $ rNewImage ) ; $ NomImageExploitable = time ( ) ; header ( 'Content-Type: image/jpeg' ) ; imagejpeg ( $ rNewImage , null , 100 ) ; }
10387	public function newApp ( ) : ApplicationInterface { $ app = new CalgamoApplication ( $ this -> filesystem ) ; $ app -> requireModule ( CalgamoLogExceptionHandlerModule :: class ) ; $ app -> requireModule ( CalgamoRouterModule :: class ) ; $ app -> requireModule ( CalgamoDiModule :: class ) ; $ app -> requireModule ( Wa72SimpleLoggerModule :: class ) ; return $ app ; }
10761	public function encodeString ( $ string ) { $ string = strtolower ( $ string ) ; $ src = "abcdefghijklmnopqrstuvwxyz0123456789 " ; $ dst = "jklmnopqrstuvwxyz0123456789abcdefghi " ; for ( $ i = 0 ; $ i < strlen ( $ string ) ; $ i ++ ) { $ pos = strpos ( $ src , $ string [ $ i ] ) ; if ( $ pos === false ) { throw new \ Exception ( "Please provide only numbers and alphanumerical characters" ) ; } $ string [ $ i ] = $ dst [ $ pos ] ; } return $ string ; }
8445	public function getUser ( IncomingMessage $ matchingMessage ) { $ sender_id = $ matchingMessage -> getRecipient ( ) ; $ user = Collection :: make ( $ this -> payload -> get ( 'users' ) ) -> first ( function ( $ user ) use ( $ sender_id ) { return $ user [ 'id' ] === $ sender_id ; } ) ; return new User ( $ user [ 'id' ] , null , null , $ user [ 'name' ] , $ user ) ; }
12201	public function mediaAction ( Request $ request , Application $ app ) { $ options = array ( "connector" => $ app [ "red_kite_cms.elfinder_media_connector" ] , ) ; return parent :: show ( $ options ) ; }
3122	public function find ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ points = [ ] ; foreach ( $ this -> points as $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ points [ ] = $ point ; } } return $ points ; }
7991	public function setSshKey ( $ pp , $ pca , $ key ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ key ) throw new BadMethodCallException ( 'Missing parameter $key (Public key for this pca).' ) ; $ payload = array ( 'sshkey' => $ key ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
3008	public function getAttribute ( $ key ) { if ( ! isset ( $ this -> attributes [ $ key ] ) ) { return false ; } return $ this -> attributes [ $ key ] ; }
12189	public function getPrimaryRelation ( $ baseObject , $ baseRole , $ relationOptions = [ ] ) { $ companionRole = $ this -> companionRole ( $ baseRole ) ; $ companionType = $ this -> companionRoleType ( $ baseRole ) ; $ companionModel = $ companionType -> primaryModel ; if ( ! isset ( $ relationOptions [ 'order' ] ) ) { $ relationOptions [ 'order' ] = [ ] ; } if ( $ companionRole === 'child' ) { array_unshift ( $ relationOptions [ 'order' ] , [ 'primary_child' , SORT_DESC ] ) ; $ relation = $ baseObject -> queryParentRelations ( $ companionModel , $ relationOptions ) -> one ( ) ; } else { array_unshift ( $ relationOptions [ 'order' ] , [ 'primary_parent' , SORT_DESC ] ) ; $ relation = $ baseObject -> queryParentRelations ( $ companionModel , $ relationOptions ) -> one ( ) ; } if ( empty ( $ relation ) ) { return false ; } else { return $ relation ; } }
1811	public function addCteType ( $ arrRow ) { $ key = $ arrRow [ 'invisible' ] ? 'unpublished' : 'published' ; $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ arrRow [ 'type' ] ] [ 0 ] ? : '&nbsp;' ; $ class = 'limit_height' ; if ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'start' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'separator' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'stop' ] ) ) { $ class = '' ; if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } elseif ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'single' ] ) ) { if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } if ( $ arrRow [ 'type' ] == 'alias' ) { $ type .= ' ID ' . $ arrRow [ 'cteAlias' ] ; } if ( $ arrRow [ 'protected' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'protected' ] . ')' ; } elseif ( $ arrRow [ 'guests' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'guests' ] . ')' ; } if ( $ arrRow [ 'type' ] == 'headline' ) { if ( \ is_array ( $ headline = Contao \ StringUtil :: deserialize ( $ arrRow [ 'headline' ] ) ) ) { $ type .= ' (' . $ headline [ 'unit' ] . ')' ; } } if ( ! Contao \ Config :: get ( 'doNotCollapse' ) ) { $ class .= ' h40' ; } $ objModel = new Contao \ ContentModel ( ) ; $ objModel -> setRow ( $ arrRow ) ; return '<div class="cte_type ' . $ key . '">' . $ type . '</div><div class="' . trim ( $ class ) . '">' . Contao \ StringUtil :: insertTagToSrc ( $ this -> getContentElement ( $ objModel ) ) . '</div>' . "\n" ; }
575	protected function getDefaultValue ( $ event ) { if ( $ this -> defaultValue instanceof \ Closure || ( is_array ( $ this -> defaultValue ) && is_callable ( $ this -> defaultValue ) ) ) { return call_user_func ( $ this -> defaultValue , $ event ) ; } return $ this -> defaultValue ; }
4478	public function getInstance ( ) { if ( $ this -> instance === null ) { $ this -> instance = $ this -> jobFactory -> create ( $ this -> klass , $ this -> getPerformMethod ( ) ) ; } return $ this -> instance ; }
8577	public function setItemFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2957	public function confCharacterLength ( $ int ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set length of a character : the device " . "is either not set or opened" , E_USER_WARNING ) ; return false ; } $ int = ( int ) $ int ; if ( $ int < 5 ) { $ int = 5 ; } elseif ( $ int > 8 ) { $ int = 8 ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " cs" . $ int , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " cs" . $ int , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " DATA=" . $ int , $ out ) ; } if ( $ ret === 0 ) { return true ; } trigger_error ( "Unable to set character length : " . $ out [ 1 ] , E_USER_WARNING ) ; return false ; }
10479	protected function inlineContext ( $ selectQuery , $ itemRow ) { $ selectQuery = str_replace ( [ 'OLD.' , 'NEW.' ] , '__ctx__' , $ selectQuery ) ; $ prefixedKeys = array_map ( function ( $ key ) { return '__ctx__' . $ key ; } , array_keys ( $ itemRow ) ) ; $ connection = $ this -> getConnection ( ) ; $ escapedValues = array_map ( function ( $ value ) use ( $ connection ) { return $ connection -> quote ( $ value ) ; } , array_values ( $ itemRow ) ) ; $ sql = str_replace ( $ prefixedKeys , $ escapedValues , $ selectQuery ) ; return $ sql ; }
6829	protected function prioritizeAssignment ( Stock \ StockAssignmentInterface $ assignment ) { if ( $ assignment -> isFullyShipped ( ) || $ assignment -> isFullyShippable ( ) ) { return false ; } if ( 0 >= $ quantity = $ assignment -> getSoldQuantity ( ) - $ assignment -> getShippableQuantity ( ) ) { return false ; } $ changed = false ; $ helper = new PrioritizeHelper ( $ this -> unitResolver ) ; $ sourceUnit = $ assignment -> getStockUnit ( ) ; $ candidates = $ helper -> getUnitCandidates ( $ assignment , $ quantity ) ; foreach ( $ candidates as $ candidate ) { $ targetUnit = $ candidate -> unit ; if ( ( 0 < $ quantity - $ targetUnit -> getReservableQuantity ( ) ) && ( $ combination = $ candidate -> combination ) ) { foreach ( $ combination -> map as $ id => $ qty ) { if ( null === $ a = $ candidate -> getAssignmentById ( $ id ) ) { throw new StockLogicException ( "Assignment not found." ) ; } $ this -> moveAssignment ( $ a , $ sourceUnit , min ( $ qty , $ quantity ) ) ; } } $ delta = min ( $ quantity , $ targetUnit -> getReservableQuantity ( ) ) ; $ quantity -= $ this -> moveAssignment ( $ assignment , $ targetUnit , $ delta ) ; $ changed = true ; if ( 0 >= $ quantity ) { break ; } } return $ changed ; }
9369	protected function resolve ( ContainerInterface $ container , ServerRequestInterface $ request , ResponseInterface $ response ) { if ( class_exists ( 'Zend\Diactoros\ServerRequestFactory' ) ) { $ response = new ZendResponse ; $ request = ServerRequestFactory :: fromGlobals ( ) ; } $ container -> set ( 'Psr\Http\Message\ServerRequestInterface' , $ request ) ; return $ container -> set ( 'Psr\Http\Message\ResponseInterface' , $ response ) ; }
3567	public function toArray ( ) { return function ( $ next , $ attributes ) { unset ( $ attributes [ 'meta_attributes' ] , $ attributes [ 'metaAttributes' ] ) ; $ attributes = array_merge ( $ attributes , $ this -> getMetaAttributesArray ( ) ) ; return $ next ( $ attributes ) ; } ; }
10464	private function deductionForDeletion ( $ connection , $ tableName , $ documentType , $ documentId , $ shopId ) { $ sql = sprintf ( "SELECT `id` FROM {$tableName} WHERE `type` != 'D' AND `document_type` = :documentType AND `document_id` = :documentId AND `status` = :status AND `id` < :id" ) ; $ statement = $ connection -> prepare ( $ sql ) ; $ statement -> execute ( [ 'documentType' => $ documentType , 'documentId' => $ documentId , 'status' => self :: STATUS_NEW , 'id' => $ connection -> lastInsertId ( ) , ] ) ; $ entries = $ statement -> fetchAll ( ) ; foreach ( $ entries as $ entry ) { $ this -> removeRecord ( $ entry [ 'id' ] , [ $ shopId ] ) ; } }
44	public function dispatchScript ( $ eventName , $ devMode = false , $ additionalArgs = array ( ) , $ flags = array ( ) ) { return $ this -> doDispatch ( new Script \ Event ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ additionalArgs , $ flags ) ) ; }
4371	public function markupClassname ( $ str , $ tagName = 'span' , $ attribs = array ( ) ) { if ( \ preg_match ( '/^(.+)(::|->)(.+)$/' , $ str , $ matches ) ) { $ classname = $ matches [ 1 ] ; $ opMethod = '<span class="t_operator">' . \ htmlspecialchars ( $ matches [ 2 ] ) . '</span>' . '<span class="method-name">' . $ matches [ 3 ] . '</span>' ; } else { $ classname = $ str ; $ opMethod = '' ; } $ idx = \ strrpos ( $ classname , '\\' ) ; if ( $ idx ) { $ classname = '<span class="namespace">' . \ substr ( $ classname , 0 , $ idx + 1 ) . '</span>' . \ substr ( $ classname , $ idx + 1 ) ; } $ attribs = \ array_merge ( array ( 'class' => 't_classname' , ) , $ attribs ) ; return $ this -> debug -> utilities -> buildTag ( $ tagName , $ attribs , $ classname ) . $ opMethod ; }
1402	public function getErrors ( ) { if ( ! is_null ( $ this -> errors ) ) { return collect ( $ this -> errors ) ; } try { $ this -> errors = $ this -> parse ( ) ; } catch ( \ Exception $ ex ) { $ this -> errors = [ ] ; } return collect ( $ this -> errors ) ; }
6168	protected function writeAssertionFailure ( $ assertionFailure ) { $ this -> writeNewLine ( ) ; foreach ( explode ( "\n" , $ assertionFailure ) as $ line ) { $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
2785	private function extractFail ( $ output ) { if ( preg_match ( '%##teamcity\[testFailed.*\]%' , $ output , $ matches ) ) { preg_match ( "/##teamcity\\[testFailed.*name='(.*)' message='(.*)' details='\\s*(.*)' flowId=.*/" , $ output , $ matches ) ; $ matches = $ this -> replaceEscapedChars ( $ matches ) ; $ fail = sprintf ( 'Test Name: %s' . PHP_EOL . 'Failure Message: %s' . PHP_EOL . 'Trace:' . PHP_EOL . '%s' , $ matches [ 1 ] , $ matches [ 2 ] , $ matches [ 3 ] ) ; return $ fail ; } return 'No failure output was detected by Humbug, but a failure was reported by PHPUnit.' ; }
5091	private function asScalarSubQuery ( $ callback , $ default = false ) { $ sql = $ this -> sql ; $ this -> sql = $ callback ( $ sql ) ; $ result = $ this -> queryScalar ( null ) ; $ this -> sql = $ sql ; return ( is_null ( $ result ) ? $ default : $ result ) ; }
2	private function buildDependency10Info ( $ depArray ) { static $ dep10toOperatorMap = array ( 'has' => '==' , 'eq' => '==' , 'ge' => '>=' , 'gt' => '>' , 'le' => '<=' , 'lt' => '<' , 'not' => '!=' ) ; $ result = array ( ) ; foreach ( $ depArray as $ depItem ) { if ( empty ( $ depItem [ 'rel' ] ) || ! array_key_exists ( $ depItem [ 'rel' ] , $ dep10toOperatorMap ) ) { continue ; } $ depType = ! empty ( $ depItem [ 'optional' ] ) && 'yes' == $ depItem [ 'optional' ] ? 'optional' : 'required' ; $ depType = 'not' == $ depItem [ 'rel' ] ? 'conflicts' : $ depType ; $ depVersion = ! empty ( $ depItem [ 'version' ] ) ? $ this -> parseVersion ( $ depItem [ 'version' ] ) : '*' ; $ depVersionConstraint = ( 'has' == $ depItem [ 'rel' ] || 'not' == $ depItem [ 'rel' ] ) && '*' == $ depVersion ? '*' : $ dep10toOperatorMap [ $ depItem [ 'rel' ] ] . $ depVersion ; switch ( $ depItem [ 'type' ] ) { case 'php' : $ depChannelName = 'php' ; $ depPackageName = '' ; break ; case 'pkg' : $ depChannelName = ! empty ( $ depItem [ 'channel' ] ) ? $ depItem [ 'channel' ] : 'pear.php.net' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'ext' : $ depChannelName = 'ext' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'os' : case 'sapi' : $ depChannelName = '' ; $ depPackageName = '' ; break ; default : $ depChannelName = '' ; $ depPackageName = '' ; break ; } if ( '' != $ depChannelName ) { $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } } return $ result ; }
10860	protected function createObject ( string $ typeName , ? bool $ nullable = false , ? bool $ checkCycles = true , ? bool $ treatAsNotFound = true ) : ? object { if ( $ checkCycles ) { $ this -> underConstruction [ $ typeName ] = true ; } try { if ( ! isset ( $ this -> typeCache [ $ typeName ] ) ) { if ( \ class_exists ( $ typeName ) || \ interface_exists ( $ typeName , false ) ) { $ this -> typeCache [ $ typeName ] = new \ ReflectionClass ( $ typeName ) ; } else { $ this -> typeCache [ $ typeName ] = false ; } } if ( $ this -> typeCache [ $ typeName ] === false ) { if ( $ nullable ) { return null ; } if ( $ treatAsNotFound ) { throw new NotFoundException ( \ sprintf ( 'Cannot load type: %s' , $ typeName ) ) ; } throw new ContainerException ( \ sprintf ( 'Cannot load type: %s' , $ typeName ) ) ; } if ( ! $ this -> typeCache [ $ typeName ] -> isInstantiable ( ) ) { if ( $ nullable ) { return null ; } throw new NotFoundException ( \ sprintf ( 'Type is not instantiable: %s' , $ typeName ) ) ; } if ( isset ( $ this -> constructorCache [ $ typeName ] ) ) { $ con = $ this -> constructorCache [ $ typeName ] ; } else { $ con = $ this -> constructorCache [ $ typeName ] = $ this -> typeCache [ $ typeName ] -> getConstructor ( ) ? : false ; } return ( $ con === false ) ? new $ typeName ( ) : new $ typeName ( ... $ this -> populateArguments ( $ con , null , $ typeName ) ) ; } finally { if ( $ checkCycles ) { unset ( $ this -> underConstruction [ $ typeName ] ) ; } } }
10032	function unsubscribeContactByEmail ( $ email , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } $ encodedEmail = utf8_encode ( $ email ) ; return $ this -> delete ( "contacts/email/${encodedEmail}/unsubscribe" , $ queryParameters ) ; }
1850	private function preHandleFragment ( FragmentReference $ uri , FragmentConfig $ config ) : void { if ( ! isset ( $ uri -> attributes [ 'pageModel' ] ) && $ this -> hasGlobalPageObject ( ) ) { $ uri -> attributes [ 'pageModel' ] = $ GLOBALS [ 'objPage' ] -> id ; } if ( $ this -> preHandlers -> has ( $ uri -> controller ) ) { $ preHandler = $ this -> preHandlers -> get ( $ uri -> controller ) ; $ preHandler -> preHandleFragment ( $ uri , $ config ) ; } }
9117	public function unregisterView ( $ view , $ order , $ applicationName = 'default' ) { if ( isset ( $ this -> views [ $ applicationName ] [ $ order ] [ $ view ] ) ) { unset ( $ this -> views [ $ applicationName ] [ $ order ] [ $ view ] ) ; } return $ this ; }
11238	public function getRedirect ( $ url = null ) { if ( $ url ) { if ( is_numeric ( $ url ) ) { $ steps = $ url ; $ offset = count ( $ _SESSION [ 'redirect' ] [ 'history' ] ) + $ steps ; if ( isset ( $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ) ) { $ redirect = $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ; if ( ! empty ( $ redirect ) ) { return $ redirect ; } else { return BASE_URL ; } } else { return $ this -> config [ 'site_url' ] ; } } else { if ( substr ( $ url , 0 , 1 ) == '/' ) { return $ this -> config [ 'site_url' ] . substr ( $ url , 1 ) ; } else { return $ url ; } } } else { return $ this -> config [ 'site_url' ] ; } }
6880	public function transform ( $ data ) { $ address = new ShipmentAddress ( ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { return $ address ; } foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field ] ) ) { $ value = $ data [ $ field ] ; if ( $ field === 'country' ) { if ( 0 >= $ value ) { throw new InvalidArgumentException ( "Invalid country id." ) ; } $ value = $ this -> countryRepository -> find ( $ value ) ; if ( null === $ value ) { throw new InvalidArgumentException ( "Country not found." ) ; } } elseif ( $ field === 'phone' || $ field === 'mobile' ) { $ value = unserialize ( $ value ) ; if ( ! $ value instanceof PhoneNumber ) { throw new InvalidArgumentException ( "Invalid phone number." ) ; } } $ this -> accessor -> setValue ( $ address , $ field , $ value ) ; } } return $ address ; }
2922	protected function ensureFileIsReadable ( ) { if ( ! is_readable ( $ this -> filePath ) || ! is_file ( $ this -> filePath ) ) { throw new UnableReadFileException ( sprintf ( 'Unable to read the file at %s.' , $ this -> filePath ) ) ; } }
3975	private function getDataProviderDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasDataProviderDefinition ( ) ) { return $ container -> getDataProviderDefinition ( ) ; } $ config = new DefaultDataProviderDefinition ( ) ; $ container -> setDataProviderDefinition ( $ config ) ; return $ config ; }
9880	private function writeWorkbookProtection ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { if ( $ spreadsheet -> getSecurity ( ) -> isSecurityEnabled ( ) ) { $ objWriter -> startElement ( 'workbookProtection' ) ; $ objWriter -> writeAttribute ( 'lockRevision' , ( $ spreadsheet -> getSecurity ( ) -> getLockRevision ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'lockStructure' , ( $ spreadsheet -> getSecurity ( ) -> getLockStructure ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'lockWindows' , ( $ spreadsheet -> getSecurity ( ) -> getLockWindows ( ) ? 'true' : 'false' ) ) ; if ( $ spreadsheet -> getSecurity ( ) -> getRevisionsPassword ( ) != '' ) { $ objWriter -> writeAttribute ( 'revisionsPassword' , $ spreadsheet -> getSecurity ( ) -> getRevisionsPassword ( ) ) ; } if ( $ spreadsheet -> getSecurity ( ) -> getWorkbookPassword ( ) != '' ) { $ objWriter -> writeAttribute ( 'workbookPassword' , $ spreadsheet -> getSecurity ( ) -> getWorkbookPassword ( ) ) ; } $ objWriter -> endElement ( ) ; } }
12379	public function handle ( ) : void { $ help = " -----------------------------------------------------------------\n" ; $ help .= " | Command Line Interface\n" ; $ help .= " | See more in https://github.com/senhungwong/command-line-interface\n" ; $ help .= " -------------------------------------------------------------------\n" ; $ commands = CommandEntry :: getCommands ( ) ; if ( $ command = $ this -> getArgument ( 'function-name' ) ) { $ command = new $ commands [ $ command ] ; $ help .= " - " . $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } else { foreach ( $ commands as $ command ) { $ command = new $ command ; $ help .= " - " ; $ help .= $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } } echo $ help ; }
10719	public function addThumbnail ( \ TYPO3 \ CMS \ Extbase \ Domain \ Model \ FileReference $ thumbnail ) { $ this -> thumbnails -> attach ( $ thumbnail ) ; }
12246	static public function sort ( array & $ nodes ) { $ args = func_get_args ( ) ; unset ( $ args [ 0 ] ) ; $ sort = array ( ) ; $ tmp = array ( ) ; foreach ( $ args as $ k => $ arg ) { if ( is_string ( $ arg ) ) { $ tmp [ $ k ] = array ( ) ; if ( preg_match ( '#^@?[a-z_0-9]+$#Di' , $ arg ) ) { if ( $ arg [ 0 ] === '@' ) { $ name = substr ( $ arg , 1 ) ; foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = ( string ) $ node [ $ name ] ; } } else { foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = ( string ) $ node -> $ arg ; } } } elseif ( preg_match ( '#^current\\(\\)|text\\(\\)|\\.$#i' , $ arg ) ) { foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = dom_import_simplexml ( $ node ) -> textContent ; } } else { foreach ( $ nodes as $ node ) { $ _nodes = $ node -> xpath ( $ arg ) ; $ tmp [ $ k ] [ ] = ( empty ( $ _nodes ) ) ? '' : ( string ) $ _nodes [ 0 ] ; } } } else { $ tmp [ $ k ] = $ arg ; } $ sort [ ] = & $ tmp [ $ k ] ; } $ sort [ ] = & $ nodes ; call_user_func_array ( 'array_multisort' , $ sort ) ; }
677	public function getLinks ( $ absolute = false ) { $ currentPage = $ this -> getPage ( ) ; $ pageCount = $ this -> getPageCount ( ) ; $ links = [ Link :: REL_SELF => $ this -> createUrl ( $ currentPage , null , $ absolute ) , ] ; if ( $ currentPage > 0 ) { $ links [ self :: LINK_FIRST ] = $ this -> createUrl ( 0 , null , $ absolute ) ; $ links [ self :: LINK_PREV ] = $ this -> createUrl ( $ currentPage - 1 , null , $ absolute ) ; } if ( $ currentPage < $ pageCount - 1 ) { $ links [ self :: LINK_NEXT ] = $ this -> createUrl ( $ currentPage + 1 , null , $ absolute ) ; $ links [ self :: LINK_LAST ] = $ this -> createUrl ( $ pageCount - 1 , null , $ absolute ) ; } return $ links ; }
6893	protected function sortAssignments ( array $ assignments ) { usort ( $ assignments , function ( StockAssignmentInterface $ a1 , StockAssignmentInterface $ a2 ) { $ u1 = $ a1 -> getStockUnit ( ) ; $ u2 = $ a2 -> getStockUnit ( ) ; return $ this -> compareStockUnit ( $ u1 , $ u2 ) ; } ) ; return $ assignments ; }
325	public static function variablize ( $ word ) { $ word = static :: camelize ( $ word ) ; return mb_strtolower ( mb_substr ( $ word , 0 , 1 , self :: encoding ( ) ) ) . mb_substr ( $ word , 1 , null , self :: encoding ( ) ) ; }
11890	final protected function addRequiredAttributeToFields ( array $ specifications ) { foreach ( $ specifications as $ field => $ data ) { if ( ! $ this -> has ( $ field ) ) { continue ; } $ validators = ArrayUtils :: get ( $ data , 'validators' , [ ] ) ; $ isRequired = ( bool ) ArrayUtils :: get ( $ data , 'required' , ArrayUtils :: get ( $ validators , NotEmpty :: class , ArrayUtils :: get ( $ validators , 'NotEmpty' ) ) ) ; if ( $ isRequired ) { $ this -> get ( $ field ) -> setAttribute ( 'required' , 'required' ) ; } } return $ this ; }
2766	public function isAhead ( ) : bool { if ( ! $ this -> isTracking ( ) ) { throw new GitException ( 'Error: HEAD does not have a remote tracking branch. Cannot check if it is ahead.' ) ; } $ mergeBase = $ this -> run ( 'merge-base' , [ '@' , '@{u}' ] ) ; $ localSha = $ this -> run ( 'rev-parse' , [ '@' ] ) ; $ remoteSha = $ this -> run ( 'rev-parse' , [ '@{u}' ] ) ; return $ mergeBase === $ remoteSha && $ localSha !== $ remoteSha ; }
11809	protected function fillRelationConfig ( & $ config , $ otherObject ) { if ( isset ( $ config [ 'parent_object_id' ] ) ) { $ config [ 'child_object_id' ] = $ otherObject ; } elseif ( isset ( $ config [ 'child_object_id' ] ) ) { $ config [ 'parent_object_id' ] = $ otherObject ; } }
12362	public function database ( $ db ) { $ connection = $ this -> connection ; $ connection -> db = $ db ; $ this -> constructConnections = $ connection ; $ connection = class_exists ( "Clusterpoint\Connection" ) ? new Connection ( $ this -> constructConnections ) : new StandartConnection ( $ this -> constructConnections ) ; return new Service ( $ connection ) ; }
12587	public function init ( ) { parent :: init ( ) ; $ db = $ this -> getDbConnection ( ) ; $ db -> setActive ( true ) ; if ( $ this -> autoCreateTokenTable ) { $ sql = "DELETE FROM {$this->tokenTableName} WHERE (expires>0 AND expires<" . time ( ) . ") OR (uses_allowed>0 AND uses_remaining<1)" ; try { $ db -> createCommand ( $ sql ) -> execute ( ) ; } catch ( Exception $ e ) { $ this -> createTokenTable ( $ db , $ this -> tokenTableName ) ; } } }
3226	function move ( $ fromPath , $ toPath ) { Path :: checkArgNonRoot ( "fromPath" , $ fromPath ) ; Path :: checkArgNonRoot ( "toPath" , $ toPath ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/move" , array ( "root" => "auto" , "from_path" => $ fromPath , "to_path" => $ toPath , ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
5053	public function setResponse ( Response $ response ) { $ this -> setParam ( 'response' , $ response ) ; $ this -> response = $ response ; return $ this ; }
1110	protected function keyForScope ( $ node ) { return implode ( '-' , array_map ( function ( $ column ) use ( $ node ) { $ value = $ node -> getAttribute ( $ column ) ; if ( is_null ( $ value ) ) return 'NULL' ; return $ value ; } , $ node -> getScopedColumns ( ) ) ) ; }
213	public function registerClientScript ( ) { $ js = '' ; $ view = $ this -> getView ( ) ; $ this -> initClientOptions ( ) ; if ( ! empty ( $ this -> mask ) ) { $ this -> clientOptions [ 'mask' ] = $ this -> mask ; } $ this -> hashPluginOptions ( $ view ) ; if ( is_array ( $ this -> definitions ) && ! empty ( $ this -> definitions ) ) { $ js .= ucfirst ( self :: PLUGIN_NAME ) . '.extendDefinitions(' . Json :: htmlEncode ( $ this -> definitions ) . ');' ; } if ( is_array ( $ this -> aliases ) && ! empty ( $ this -> aliases ) ) { $ js .= ucfirst ( self :: PLUGIN_NAME ) . '.extendAliases(' . Json :: htmlEncode ( $ this -> aliases ) . ');' ; } $ id = $ this -> options [ 'id' ] ; $ js .= 'jQuery("#' . $ id . '").' . self :: PLUGIN_NAME . '(' . $ this -> _hashVar . ');' ; MaskedInputAsset :: register ( $ view ) ; $ view -> registerJs ( $ js ) ; }
9333	public function scaffoldFormField ( $ title = null , $ params = null ) { return FontIconField :: create ( $ this -> name , $ title ) ; }
11170	private function refreshSession ( ) { $ mapper = Neuron_GameServer_Mappers_UpdateMapper :: getInstance ( ) ; if ( ! isset ( $ _SESSION [ 'ngpu_lastlog' ] ) ) { $ _SESSION [ 'ngpu_lastlog' ] = $ mapper -> getLastLogId ( $ this -> objProfile ) ; $ _SESSION [ 'ngpu_data' ] = array ( ) ; } else { $ lastLogId = $ _SESSION [ 'ngpu_lastlog' ] ; $ updates = $ mapper -> getUpdates ( $ this -> objProfile , $ lastLogId ) ; foreach ( $ updates as $ v ) { $ _SESSION [ 'ngpu_data' ] [ $ v [ 'key' ] ] = $ v [ 'value' ] ; $ lastLogId = max ( $ v [ 'id' ] , $ lastLogId ) ; } $ _SESSION [ 'ngpu_lastlog' ] = $ lastLogId ; } }
5866	protected function getIndexer ( \ TYPO3 \ CMS \ Core \ Resource \ ResourceStorage $ storage ) { return GeneralUtility :: makeInstance ( Indexer :: class , $ storage ) ; }
1336	protected function queryAllOrOne ( $ query , EncodingParametersInterface $ parameters ) { $ filters = collect ( $ parameters -> getFilteringParameters ( ) ) ; if ( $ this -> isSearchOne ( $ filters ) ) { return $ this -> queryOne ( $ query , $ parameters ) ; } return $ this -> queryAll ( $ query , $ parameters ) ; }
6375	public function first ( ) : Optional { try { return Optional :: ofNullable ( $ this -> get ( 0 ) ) ; } catch ( OutOfBoundsException $ e ) { return Optional :: absent ( ) ; } }
6245	public function storages ( ) : \ Generator { foreach ( $ this -> storage -> list ( $ this -> recursive ) as $ storage ) { foreach ( $ this -> storageFilters as $ filter ) { if ( ! call_user_func ( $ filter , $ storage ) ) { continue 2 ; } } yield $ storage ; } }
5593	protected function fetch ( $ url , $ encoding ) { $ request = $ this -> createRequest ( $ url , $ encoding ) ; return $ request -> fetch ( $ this -> connection_timeout ) ; }
5528	protected function createCodeForMethods ( $ methods ) { $ code = '' ; $ methods = array_merge ( $ methods , $ this -> reflection -> getMethods ( ) ) ; foreach ( $ methods as $ method ) { if ( $ this -> isConstructorOrDeconstructor ( $ method ) ) { continue ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_base ) ; if ( in_array ( $ method , $ mock_reflection -> getMethods ( ) ) ) { continue ; } $ code .= ' ' . $ this -> reflection -> getSignature ( $ method ) ; if ( $ mock_reflection -> isAbstract ( ) ) { $ code .= ";\n" ; } else { $ code .= " {\n" ; $ code .= " return \$this->invoke(\"$method\", func_get_args());\n" ; $ code .= " }\n" ; } } return $ code ; }
3834	public function hookAdditionalFormatters ( $ arrBaseFormatted , $ arrRowData , $ strOutputFormat , $ objSettings ) { $ arrResult = $ arrBaseFormatted ; if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ arrResult = $ objCallback -> $ strMethod ( $ this , $ arrResult , $ arrRowData , $ strOutputFormat , $ objSettings ) ; } } return $ arrResult ; }
11985	function scanf ( $ format ) { $ spec_pattern = "/%[+-]?('.)?[-]?(\d)*(\..\d)?[%bcdeEfFgGosuxX]/" ; $ source = substr ( $ this -> data , $ this -> pos ) ; $ result = sscanf ( $ source , $ format ) ; if ( $ result == - 1 ) return ; else { $ l = 0 ; foreach ( $ result as $ v ) { $ l += strlen ( "" . $ v ) ; } } $ no_patterns_format = preg_replace ( $ spec_pattern , "" , $ format ) ; $ l += strlen ( $ no_patterns_format ) ; $ this -> pos += $ l ; return $ result ; }
8699	private function factoryElement ( $ type ) { switch ( $ type ) { case \ SVGCreator \ Element :: CIRCLE : return new \ SVGCreator \ Elements \ Circle ( ) ; break ; case \ SVGCreator \ Element :: DEFS : return new \ SVGCreator \ Elements \ Defs ( ) ; break ; case \ SVGCreator \ Element :: GROUP : return new \ SVGCreator \ Elements \ Group ( ) ; break ; case \ SVGCreator \ Element :: LINE : return new \ SVGCreator \ Elements \ Line ( ) ; break ; case \ SVGCreator \ Element :: MARKER : return new \ SVGCreator \ Elements \ Marker ( ) ; break ; case \ SVGCreator \ Element :: PATH : return new \ SVGCreator \ Elements \ Path ( ) ; break ; case \ SVGCreator \ Element :: RECT : return new \ SVGCreator \ Elements \ Rect ( ) ; break ; case \ SVGCreator \ Element :: SVG : return new \ SVGCreator \ Elements \ Svg ( ) ; break ; case \ SVGCreator \ Element :: TEXT : return new \ SVGCreator \ Elements \ Text ( ) ; break ; case \ SVGCreator \ Element :: POLYGON : return new \ SVGCreator \ Elements \ Polygon ( ) ; break ; default : throw new \ SVGCreator \ SVGException ( "The tag " . $ type . " is not implemented yet" , 1 ) ; break ; } }
10257	public function getAddress ( $ state_code = null , $ zip = null ) { $ address = new Entities \ Address ; if ( ! empty ( $ zip ) && ! empty ( $ state_code ) ) { $ result = Zipcode :: where ( 'zip' , $ zip ) -> where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } elseif ( ! empty ( $ zip ) ) { $ result = Zipcode :: where ( 'zip' , $ zip ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } elseif ( ! empty ( $ state_code ) ) { $ result = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } else { $ result = Zipcode :: orderByRaw ( Database :: random ( ) ) -> first ( ) ; } $ address -> line_1 = $ this -> getStreet ( ) ; if ( $ this -> getBool ( true , false ) ) { $ address -> line_2 = $ this -> getApartment ( ) ; } else { $ address -> line_2 = null ; } $ address -> city = $ result -> city ; $ address -> zip = $ result -> zip ; $ address -> county = $ result -> county ; $ address -> state = new Entities \ State ; $ address -> state -> code = $ result -> state_code ; $ address -> state -> name = $ result -> state ; return $ address ; }
9915	public function render ( $ action = null , $ layout = null ) { $ this -> viewPath .= DS . 'Spreadsheet' ; $ content = parent :: render ( $ action , false ) ; if ( $ this -> response -> type ( ) == 'text/html' ) { return $ content ; } ob_start ( ) ; $ writer = IOFactory :: createWriter ( $ this -> Spreadsheet , CAKE_SPREADSHEET_PHPSPREADSHEET_WRITER ) ; $ writer -> setPreCalculateFormulas ( false ) ; $ writer -> save ( 'php://output' ) ; $ content = ob_get_clean ( ) ; $ this -> Blocks -> set ( 'content' , $ content ) ; $ fileName = $ this -> getFileName ( ) ; $ fileName .= '.' . CAKE_SPREADSHEET_FILE_EXTENSION ; $ this -> response -> download ( $ fileName ) ; return $ this -> Blocks -> get ( 'content' ) ; }
11052	public static function sprintt ( $ datatree , $ containers , $ entry = 'main' , $ hsr = _ETS_SOURCE_READ , $ hcr = _ETS_CACHE_READ , $ hcw = _ETS_CACHE_WRITE ) { $ ets = new _ets ( $ containers , $ hsr , $ hcr , $ hcw ) ; return $ ets -> build_all ( $ datatree , $ entry ) ; }
2674	public function deleteAcl ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/acl/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; }
12314	public function newAction ( Request $ request ) { $ category = new Category ( ) ; $ form = $ this -> createForm ( 'BlogBundle\Form\CategoryType' , $ category ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ category ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'category.created' ) ; return $ this -> redirectToRoute ( 'blog_category_index' ) ; } return array ( 'category' => $ category , 'form' => $ form -> createView ( ) , ) ; }
7823	protected function updateWorkflow ( $ workflow ) { $ attachments = $ this -> getNamespacedPipesByOption ( 'attach' ) ; $ detachments = $ this -> getNamespacedPipesByOption ( 'detach' ) ; $ this -> pipelines -> update ( $ workflow , $ attachments , $ detachments ) ; }
10337	public static function oneAnchor2twoAnchor ( $ sheet , $ coordinates , $ offsetX , $ offsetY , $ width , $ height ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ coordinates ) ; $ col_start = Coordinate :: columnIndexFromString ( $ column ) ; $ row_start = $ row - 1 ; $ x1 = $ offsetX ; $ y1 = $ offsetY ; $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) ) { $ x1 = 0 ; } if ( $ y1 >= self :: sizeRow ( $ sheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) ) { $ width -= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) ; ++ $ col_end ; } while ( $ height >= self :: sizeRow ( $ sheet , $ row_end + 1 ) ) { $ height -= self :: sizeRow ( $ sheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) == 0 ) { return ; } if ( self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) == 0 ) { return ; } if ( self :: sizeRow ( $ sheet , $ row_start + 1 ) == 0 ) { return ; } if ( self :: sizeRow ( $ sheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) * 1024 ; $ y1 = $ y1 / self :: sizeRow ( $ sheet , $ row_start + 1 ) * 256 ; $ x2 = ( $ width + 1 ) / self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) * 1024 ; $ y2 = ( $ height + 1 ) / self :: sizeRow ( $ sheet , $ row_end + 1 ) * 256 ; $ startCoordinates = Coordinate :: stringFromColumnIndex ( $ col_start ) . ( $ row_start + 1 ) ; $ endCoordinates = Coordinate :: stringFromColumnIndex ( $ col_end ) . ( $ row_end + 1 ) ; $ twoAnchor = [ 'startCoordinates' => $ startCoordinates , 'startOffsetX' => $ x1 , 'startOffsetY' => $ y1 , 'endCoordinates' => $ endCoordinates , 'endOffsetX' => $ x2 , 'endOffsetY' => $ y2 , ] ; return $ twoAnchor ; }
349	public static function cssStyleToArray ( $ style ) { $ result = [ ] ; foreach ( explode ( ';' , $ style ) as $ property ) { $ property = explode ( ':' , $ property ) ; if ( count ( $ property ) > 1 ) { $ result [ trim ( $ property [ 0 ] ) ] = trim ( $ property [ 1 ] ) ; } } return $ result ; }
10238	public static function wrapResult ( $ value ) { if ( is_string ( $ value ) ) { if ( preg_match ( '/^' . self :: CALCULATION_REGEXP_ERROR . '$/i' , $ value , $ match ) ) { return $ value ; } return '"' . $ value . '"' ; } elseif ( ( is_float ( $ value ) ) && ( ( is_nan ( $ value ) ) || ( is_infinite ( $ value ) ) ) ) { return Functions :: NAN ( ) ; } return $ value ; }
7249	protected function validateShipmentMethodRequirements ( SaleInterface $ sale , Constraint $ constraint ) { if ( null === $ method = $ sale -> getShipmentMethod ( ) ) { return ; } if ( $ sale -> isSameAddress ( ) ) { $ address = $ sale -> getInvoiceAddress ( ) ; $ path = 'invoiceAddress' ; } else { $ address = $ sale -> getDeliveryAddress ( ) ; $ path = 'deliveryAddress' ; } if ( null === $ address ) { return ; } $ gateway = $ this -> gatewayRegistry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( $ gateway -> requires ( Gateway \ GatewayInterface :: REQUIREMENT_MOBILE ) ) { if ( is_null ( $ address -> getMobile ( ) ) ) { $ this -> context -> buildViolation ( $ constraint -> shipment_method_require_mobile ) -> atPath ( $ path . '.mobile' ) -> addViolation ( ) ; } } }
9741	public function isPrintAreaSet ( $ index = 0 ) { if ( $ index == 0 ) { return $ this -> printArea !== null ; } $ printAreas = explode ( ',' , $ this -> printArea ) ; return isset ( $ printAreas [ $ index - 1 ] ) ; }
10893	public function add ( $ name , UriInterface $ uri ) { unset ( $ this -> uris [ $ name ] ) ; $ this -> uris [ $ name ] = $ uri ; }
7969	public function getVoiceConsumptions ( $ params = null ) { $ consumptionList = json_decode ( self :: getClient ( ) -> getVoiceConsumptions ( $ this -> service , $ this -> billingAccount , $ params ) ) ; $ consumptions = array ( ) ; foreach ( $ consumptionList as $ consumption ) { $ consumptions [ ] = new VoiceConsumption ( $ consumption , $ this ) ; } return $ consumptions ; }
5199	public function validateOptions ( array $ options ) { foreach ( $ options as $ option => $ value ) { if ( ! in_array ( $ option , $ this -> allowedOptions ) ) throw new InvalidOptionException ( "Option [$option] is not valid" ) ; } return $ this ; }
5043	public function addMessage ( $ message , $ namespace = self :: NAMESPACE_INFO ) { if ( ! $ message instanceof NotificationEntityInterface ) { $ messageText = $ this -> isTranslatorEnabled ( ) ? $ this -> getTranslator ( ) -> translate ( $ message , $ this -> getTranslatorTextDomain ( ) ) : $ message ; $ message = new NotificationEntity ( ) ; $ message -> setNotification ( $ messageText ) ; $ message -> setPriority ( $ this -> namespace2priority [ $ namespace ] ) ; } $ nEvent = new NotificationEvent ( ) ; $ nEvent -> setNotification ( $ message ) ; $ this -> notificationListener -> trigger ( NotificationEvent :: EVENT_NOTIFICATION_ADD , $ nEvent ) ; return $ this ; }
1365	protected function bootMiddleware ( Router $ router ) { $ router -> aliasMiddleware ( 'json-api' , BootJsonApi :: class ) ; $ router -> aliasMiddleware ( 'json-api.content' , NegotiateContent :: class ) ; $ router -> aliasMiddleware ( 'json-api.auth' , Authorize :: class ) ; }
1437	public static function classify ( $ value ) { if ( isset ( self :: $ classified [ $ value ] ) ) { return self :: $ classified [ $ value ] ; } $ converted = ucwords ( str_replace ( [ '-' , '_' ] , ' ' , $ value ) ) ; return self :: $ classified [ $ value ] = str_replace ( ' ' , '' , $ converted ) ; }
12225	protected function retryMiddleware ( ) { return Middleware :: retry ( function ( $ retries , RequestInterface $ request , ResponseInterface $ response = null ) { if ( $ retries <= self :: $ maxRetries && $ response && $ body = $ response -> getBody ( ) ) { if ( stripos ( $ body , 'errcode' ) && ( stripos ( $ body , '40001' ) || stripos ( $ body , '42001' ) ) ) { $ field = $ this -> accessToken -> getQueryName ( ) ; $ token = $ this -> accessToken -> getToken ( true ) ; $ request = $ request -> withUri ( $ newUri = Uri :: withQueryValue ( $ request -> getUri ( ) , $ field , $ token ) ) ; Log :: debug ( "Retry with Request Token: {$token}" ) ; Log :: debug ( "Retry with Request Uri: {$newUri}" ) ; return true ; } } return false ; } ) ; }
4298	public function count ( $ label = null , $ flags = 0 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; if ( \ count ( $ args ) == 1 && \ is_int ( $ args [ 0 ] ) ) { $ label = null ; $ flags = $ args [ 0 ] ; } else { $ args = \ array_combine ( array ( 'label' , 'flags' ) , \ array_replace ( array ( null , 0 ) , $ args ) ) ; \ extract ( $ args ) ; } if ( isset ( $ label ) ) { $ dataLabel = ( string ) $ label ; } else { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ meta = \ array_merge ( array ( 'file' => $ callerInfo [ 'file' ] , 'line' => $ callerInfo [ 'line' ] , ) , $ meta ) ; $ label = 'count' ; $ dataLabel = $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] ; } if ( ! isset ( $ this -> data [ 'counts' ] [ $ dataLabel ] ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] = 0 ; } if ( ! ( $ flags & self :: COUNT_NO_INC ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] ++ ; } $ count = $ this -> data [ 'counts' ] [ $ dataLabel ] ; if ( ! ( $ flags & self :: COUNT_NO_OUT ) ) { $ this -> appendLog ( 'count' , array ( ( string ) $ label , $ count , ) , $ meta ) ; } return $ count ; }
10642	public function orWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "OR" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
10882	protected function aggregateTernaryValues ( array $ values ) { if ( in_array ( false , $ values , true ) ) { return false ; } elseif ( in_array ( true , $ values , true ) ) { return true ; } else { return null ; } }
10619	public function send ( ) { $ input = Input :: only ( array ( 'name' , 'email' , 'comment' , 'to_email' , 'to_name' , 'security-code' ) ) ; $ input [ 'security-code' ] = $ this -> quickSanitize ( $ input [ 'security-code' ] ) ; if ( strlen ( $ input [ 'security-code' ] ) < 2 ) { $ message = "Please enter the security code again. Thank you!" ; return view ( 'lasallecmscontact::step_two_form' , [ 'input' => $ input , 'message' => $ message , ] ) ; } $ input [ 'name' ] = $ this -> quickSanitize ( $ input [ 'name' ] ) ; $ input [ 'email' ] = $ this -> quickSanitize ( $ input [ 'email' ] ) ; $ input [ 'comment' ] = $ this -> quickSanitize ( $ input [ 'comment' ] ) ; $ to_email = Config :: get ( 'lasallecmscontact.to_email' ) ; $ to_name = Config :: get ( 'lasallecmscontact.to_name' ) ; if ( $ input [ 'to_email' ] != "" ) { $ to_email = $ input [ 'to_email' ] ; $ to_name = $ input [ 'to_name' ] ; } Mail :: send ( 'lasallecmscontact::email' , $ input , function ( $ message ) use ( $ to_email , $ to_name ) { $ message -> from ( Config :: get ( 'lasallecmscontact.from_email' ) , Config :: get ( 'lasallecmscontact.from_name' ) ) ; $ message -> to ( $ to_email , $ to_name ) -> subject ( Config :: get ( 'lasallecmscontact.subject_email' ) ) ; } ) ; return Redirect :: route ( 'contact-processing.thankyou' ) ; }
9876	public function writeWorkbook ( Spreadsheet $ spreadsheet , $ recalcRequired = false ) { if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'workbook' ) ; $ objWriter -> writeAttribute ( 'xml:space' , 'preserve' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ this -> writeFileVersion ( $ objWriter ) ; $ this -> writeWorkbookPr ( $ objWriter ) ; $ this -> writeWorkbookProtection ( $ objWriter , $ spreadsheet ) ; if ( $ this -> getParentWriter ( ) -> getOffice2003Compatibility ( ) === false ) { $ this -> writeBookViews ( $ objWriter , $ spreadsheet ) ; } $ this -> writeSheets ( $ objWriter , $ spreadsheet ) ; $ this -> writeDefinedNames ( $ objWriter , $ spreadsheet ) ; $ this -> writeCalcPr ( $ objWriter , $ recalcRequired ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
12349	public function getTaxonomy ( $ system_id ) { foreach ( $ this -> getTaxonomies ( ) as $ taxonomy ) { if ( $ taxonomy -> system_id === $ system_id ) { return $ taxonomy ; } } return false ; }
10224	private function buildComplexIndexMenu ( $ modelName , $ modelId , ModelConfig $ config = null ) { $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; $ relations = $ this -> aujaConfigurator -> getRelationsForModel ( $ model ) ; $ associationRelations = array ( ) ; foreach ( $ relations as $ relation ) { if ( $ relation -> getType ( ) == Relation :: HAS_MANY || $ relation -> getType ( ) == Relation :: HAS_AND_BELONGS_TO ) { $ associationRelations [ ] = $ relation ; } } switch ( count ( $ associationRelations ) ) { case 0 : $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; break ; case 1 : $ menu = $ this -> singleAssociationMenuFor ( $ modelName , $ modelId , $ associationRelations [ 0 ] , $ config ) ; break ; default : $ menu = $ this -> multipleAssociationsMenuFor ( $ modelName , $ modelId , $ associationRelations , $ config ) ; break ; } return $ menu ; }
12584	static function run_generate_extension_config ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ overwrite = @ $ cliopts [ 'overwrite-existing' ] ; if ( count ( $ args ) == 0 ) { throw new pakeException ( "Missing extension name" ) ; } $ extname = $ args [ 0 ] ; $ configfile = self :: getOptionsDir ( ) . "/options-$extname.yaml" ; if ( file_exists ( $ configfile ) && ! $ overwrite ) { pake_echo ( "File $configfile already exists. Must overwrite it to continue" ) ; $ ok = pake_input ( "Do you want to overwrite it? [y/n]" , 'n' ) ; if ( $ ok != 'y' ) { return ; } } pake_mkdirs ( self :: getOptionsDir ( ) ) ; pake_copy ( self :: getResourceDir ( ) . '/options-sample.yaml' , $ configfile , array ( 'override' => true ) ) ; pake_echo ( "Created file $configfile, now go and edit it" ) ; }
9266	public function from ( Contract $ contract , string $ string , callable $ callback = null ) : string { return $ this -> callback ( trim ( $ contract -> recipe ( $ string , 'space' ) ) , $ callback ) ; }
1293	private function getTokenFromResponse ( array $ data ) : string { $ url = $ data [ 'nextSyncUrl' ] ?? $ data [ 'nextPageUrl' ] ; $ queryValues = [ ] ; \ parse_str ( \ parse_url ( $ url , \ PHP_URL_QUERY ) , $ queryValues ) ; return $ queryValues [ 'sync_token' ] ; }
10744	public function getArray ( $ keys , array $ default = [ ] ) : array { $ result = $ this -> get ( $ keys , $ default ) ; if ( ! is_array ( $ result ) ) { $ result = $ default ; } return $ result ; }
223	protected function normalizeNumericStringValue ( $ value ) { $ powerPosition = strrpos ( $ value , 'E' ) ; if ( $ powerPosition !== false ) { $ valuePart = substr ( $ value , 0 , $ powerPosition ) ; $ powerPart = substr ( $ value , $ powerPosition + 1 ) ; } else { $ powerPart = null ; $ valuePart = $ value ; } $ separatorPosition = strrpos ( $ valuePart , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ valuePart , 0 , $ separatorPosition ) ; $ fractionalPart = substr ( $ valuePart , $ separatorPosition + 1 ) ; } else { $ integerPart = $ valuePart ; $ fractionalPart = null ; } $ integerPart = preg_replace ( '/^\+?(-?)0*(\d+)$/' , '$1$2' , $ integerPart ) ; $ integerPart = preg_replace ( '/^\+?(-?)0*$/' , '${1}0' , $ integerPart ) ; if ( $ fractionalPart !== null ) { $ fractionalPart = rtrim ( $ fractionalPart , '0' ) ; if ( empty ( $ fractionalPart ) ) { $ fractionalPart = $ powerPart !== null ? '0' : null ; } } $ normalizedValue = $ integerPart ; if ( $ fractionalPart !== null ) { $ normalizedValue .= '.' . $ fractionalPart ; } elseif ( $ normalizedValue === '-0' ) { $ normalizedValue = '0' ; } if ( $ powerPart !== null ) { $ normalizedValue .= 'E' . $ powerPart ; } return $ normalizedValue ; }
3669	public function getCurrentFilterUrl ( $ options = null ) : FilterUrl { $ this -> addFromCurrentRequest ( $ filterUrl = new FilterUrl ( ) , $ options ) ; return $ filterUrl ; }
9292	public function getEndpointNode ( ) { $ builder = new TreeBuilder ( ) ; $ node = $ builder -> root ( 'endpoints' ) ; $ node -> info ( 'Defines version endpoints.' ) -> useAttributeAsKey ( 'endpoint' ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'endpoint' ) -> info ( 'Endpoint name (will be included in url (e.g. products))' ) -> example ( 'products' ) -> end ( ) -> scalarNode ( 'repository' ) -> isRequired ( ) -> info ( 'Document service from Elasticsearch bundle which will be used for data fetching' ) -> example ( 'es.manager.default.products' ) -> end ( ) -> arrayNode ( 'methods' ) -> defaultValue ( [ Request :: METHOD_POST , Request :: METHOD_GET , Request :: METHOD_PUT , Request :: METHOD_DELETE ] ) -> prototype ( 'scalar' ) -> validate ( ) -> ifNotInArray ( [ Request :: METHOD_HEAD , Request :: METHOD_POST , Request :: METHOD_PATCH , Request :: METHOD_GET , Request :: METHOD_PUT , Request :: METHOD_DELETE ] ) -> thenInvalid ( 'Invalid HTTP method used! Please check your ongr_api endpoint configuration.' ) -> end ( ) -> end ( ) -> end ( ) -> booleanNode ( 'allow_extra_fields' ) -> defaultFalse ( ) -> info ( 'Allows to pass unknown fields to an api. ' . 'Make sure you have configured elasticsearch respectively.' ) -> end ( ) -> arrayNode ( 'allow_fields' ) -> defaultValue ( [ ] ) -> info ( 'A list off a allowed fields to operate through api for a document.' ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> booleanNode ( 'allow_get_all' ) -> defaultTrue ( ) -> info ( 'Allows to use `_all` elasticsearch api to get all documents from a type.' ) -> end ( ) -> booleanNode ( 'allow_batch' ) -> defaultTrue ( ) -> info ( 'Allows to use `_batch` elasticsearch api to pass multiple documents in single API request.' ) -> end ( ) -> booleanNode ( 'variants' ) -> defaultFalse ( ) -> info ( 'If set to true user can manipulate document variants over API.' ) -> end ( ) -> booleanNode ( 'batch' ) -> defaultTrue ( ) -> info ( 'If set to true user can sent documents in batch\'s.' ) -> end ( ) -> end ( ) -> end ( ) ; return $ node ; }
5792	private function setConstraints ( ) { $ q = new QueryBuilder ( "SELECT ccu.column_name, tc.constraint_type FROM INFORMATION_SCHEMA.constraint_column_usage ccu JOIN information_schema.table_constraints tc ON ccu.constraint_name = tc.constraint_name WHERE tc.table_name = ccu.table_name AND ccu.table_name = $1" , $ this -> tableName ) ; $ qResult = $ q -> execute ( ) ; while ( $ qRow = pg_fetch_assoc ( $ qResult ) ) { switch ( $ qRow [ 'constraint_type' ] ) { case 'PRIMARY KEY' : $ this -> primaryKeyColumnName = $ qRow [ 'column_name' ] ; break ; case 'UNIQUE' : $ this -> uniqueColumnNames [ ] = $ qRow [ 'column_name' ] ; } } }
3898	public function handleMetaChange ( $ strMetaName , $ varNewValue ) { if ( $ strMetaName == 'colname' ) { if ( $ this -> get ( $ strMetaName ) != $ varNewValue ) { $ this -> renameColumn ( $ varNewValue ) ; } return $ this ; } return parent :: handleMetaChange ( $ strMetaName , $ varNewValue ) ; }
1255	private function getValueToAssignToValue ( \ stdClass $ meta ) { if ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\Base64BinaryType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\BooleanType' , false ) ) { return strtolower ( $ meta -> strData ) === 'true' ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DecimalType' , false ) ) { return is_int ( 0 + $ meta -> strData ) ? ( integer ) $ meta -> strData : ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\DoubleType' , false ) ) { return ( double ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\IntegerType' , false ) ) { return ( integer ) $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\StringType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\TokenType' , false ) ) { return $ meta -> strData ; } elseif ( is_subclass_of ( $ meta -> phpObject , '\DTS\eBaySDK\Types\URIType' , false ) ) { return $ meta -> strData ; } return $ meta -> strData ; }
8715	public function getAccessToken ( ) : ApiAccessToken { try { $ accessToken = $ this -> tokenStorage -> getAccessToken ( ) ; } catch ( UnableToAcquireAccessToken $ e ) { $ accessToken = null ; } if ( $ accessToken && $ accessToken -> isExpired ( ) ) { $ this -> tokenStorage -> unsetAccessToken ( ) ; $ accessToken = null ; } return $ accessToken ? : $ this -> refreshToken ( ) ; }
459	public function getColumnType ( $ type ) { if ( $ type instanceof ColumnSchemaBuilder ) { $ type = $ type -> __toString ( ) ; } if ( isset ( $ this -> typeMap [ $ type ] ) ) { return $ this -> typeMap [ $ type ] ; } elseif ( preg_match ( '/^(\w+)\((.+?)\)(.*)$/' , $ type , $ matches ) ) { if ( isset ( $ this -> typeMap [ $ matches [ 1 ] ] ) ) { return preg_replace ( '/\(.+\)/' , '(' . $ matches [ 2 ] . ')' , $ this -> typeMap [ $ matches [ 1 ] ] ) . $ matches [ 3 ] ; } } elseif ( preg_match ( '/^(\w+)\s+/' , $ type , $ matches ) ) { if ( isset ( $ this -> typeMap [ $ matches [ 1 ] ] ) ) { return preg_replace ( '/^\w+/' , $ this -> typeMap [ $ matches [ 1 ] ] , $ type ) ; } } return $ type ; }
10962	private function isInvalidLogDate ( $ file ) { $ pattern = '/laravel-(\d){4}-(\d){2}-(\d){2}.log/' ; if ( ( bool ) preg_match ( $ pattern , $ file , $ matches ) === false ) { return true ; } return false ; }
6654	public function getRequestToken ( $ settings , OAuthConsumerInterface $ consumer , OAuthTokenInterface $ token ) { $ url = $ settings [ 'auth_api_url' ] . $ settings [ 'request_token_uri' ] ; $ options = [ 'oauth_callback' => $ settings [ 'callback_url' ] ] ; $ headers = $ this -> headers ( $ settings , 'POST' , $ url , $ consumer , $ token , $ options ) ; $ request = [ 'url' => $ url , 'headers' => $ headers ] ; return $ this -> token -> makeRequestToken ( $ this -> http -> post ( $ request ) ) ; }
2505	public static function loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) { if ( ! isset ( self :: $ wsdlDomXpath [ $ wsdlId ] ) || is_null ( self :: $ wsdlDomXpath [ $ wsdlId ] ) ) { $ wsdlContent = file_get_contents ( $ wsdlFilePath ) ; if ( $ wsdlContent !== false ) { self :: $ wsdlDomDoc [ $ wsdlId ] = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; self :: $ wsdlDomDoc [ $ wsdlId ] -> loadXML ( $ wsdlContent ) ; self :: $ wsdlDomXpath [ $ wsdlId ] = new \ DOMXPath ( self :: $ wsdlDomDoc [ $ wsdlId ] ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ wsdlFilePath . ' could not be loaded' ) ; } } }
2884	public function startProfiling ( ) { $ this -> canCapture = Mage :: helper ( 'sheep_debug' ) -> canCapture ( ) ; if ( ! $ this -> canCapture ) { return ; } $ requestInfo = $ this -> getRequestInfo ( ) ; $ requestInfo -> setIsStarted ( true ) ; $ this -> registerShutdown ( ) ; $ requestInfo -> setStoreId ( $ this -> getCurrentStore ( ) -> getId ( ) ) ; $ requestInfo -> setDate ( date ( 'Y-m-d H:i:s' ) ) ; $ requestInfo -> initController ( ) ; $ requestInfo -> initLogging ( ) ; if ( Mage :: helper ( 'sheep_debug' ) -> canEnableVarienProfiler ( ) ) { Varien_Profiler :: enable ( ) ; } $ stackTraceProfiler = Mage :: getModel ( 'sheep_debug/db_profiler' ) ; $ stackTraceProfiler -> setCaptureStacktraces ( Mage :: helper ( 'sheep_debug' ) -> canEnableSqlStacktrace ( ) ) ; $ stackTraceProfiler -> replaceProfiler ( ) ; }
11005	public function setSandbox ( string $ sandbox ) : void { if ( ! in_array ( $ sandbox , self :: SANDBOX_VALUES ) ) { throw new MiddlewareException ( $ this , sprintf ( "%s is not a correct value for the CSP sandbox, correct values are: %s (see %s)" , $ sandbox , implode ( ', ' , self :: SANDBOX_VALUES ) , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/sandbox' ) ) ; } $ this -> tags [ 'sandbox' ] = $ sandbox ; }
10281	public static function absoluteCoordinate ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } list ( $ column , $ row ) = self :: coordinateFromString ( $ pCoordinateString ) ; $ column = ltrim ( $ column , '$' ) ; $ row = ltrim ( $ row , '$' ) ; return $ worksheet . '$' . $ column . '$' . $ row ; }
8089	static protected function encode ( $ number ) { $ k = self :: $ encoder ; preg_match_all ( "/[1-9][0-9]|[0-9]/" , $ number , $ a ) ; $ n = '' ; $ o = count ( $ k ) ; foreach ( $ a [ 0 ] as $ i ) { if ( $ i < $ o ) { $ n .= $ k [ $ i ] ; } else { $ n .= '1' . $ k [ $ i - $ o ] ; } } return $ n ; }
9442	public function getManyWithoutReplacement ( $ n ) { if ( ! is_integer ( $ n ) || $ n < 2 ) { throw new \ InvalidArgumentException ( 'You must take 2 or more items in this case.' ) ; } if ( $ this -> range -> as_integer ) { $ arr_range = range ( $ this -> range -> min , $ this -> range -> max ) ; $ max_takable = count ( $ arr_range ) ; shuffle ( $ arr_range ) ; if ( $ n > $ max_takable ) { throw new \ OutOfRangeException ( sprintf ( 'Cannot take without replacement more than available items into range [%d;%d]' , $ this -> range -> min , $ this -> range -> max ) ) ; } elseif ( $ n == $ max_takable ) { return array_values ( $ arr_range ) ; } else { return array_slice ( $ arr_range , 0 , $ n ) ; } } else { $ arr_out = array ( ) ; while ( count ( $ arr_out ) < $ n ) { $ r = $ this -> get ( ) ; if ( ! in_array ( $ r , $ arr_out ) ) { $ arr_out [ ] = $ r ; } } return $ arr_out ; } }
2249	public static function redirect ( $ strLocation , $ intStatus = 303 ) { $ strLocation = str_replace ( '&amp;' , '&' , $ strLocation ) ; $ strLocation = static :: replaceOldBePaths ( $ strLocation ) ; if ( ! preg_match ( '@^https?://@i' , $ strLocation ) ) { $ strLocation = Environment :: get ( 'base' ) . ltrim ( $ strLocation , '/' ) ; } if ( Environment :: get ( 'isAjaxRequest' ) ) { throw new AjaxRedirectResponseException ( $ strLocation ) ; } throw new RedirectResponseException ( $ strLocation , $ intStatus ) ; }
5339	public function setMode ( $ mode ) { if ( ! in_array ( $ mode , $ this -> acceptedModes ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid mode: [%s]' , $ mode ) ) ; } $ this -> mode = $ mode ; }
4210	private function phpDocParam ( $ param , $ className ) { $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( \ array_key_exists ( 'defaultValue' , $ param ) ) { $ defaultValue = $ param [ 'defaultValue' ] ; if ( \ in_array ( $ defaultValue , array ( 'true' , 'false' , 'null' ) ) ) { $ defaultValue = \ json_decode ( $ defaultValue ) ; } elseif ( \ is_numeric ( $ defaultValue ) ) { $ defaultValue = $ defaultValue * 1 ; } elseif ( \ preg_match ( '/^array\(\s*\)|\[\s*\]$/i' , $ defaultValue ) ) { $ defaultValue = array ( ) ; } elseif ( \ preg_match ( '/^(self::)?([^\(\)\[\]]+)$/i' , $ defaultValue , $ matches ) ) { if ( $ matches [ 1 ] ) { if ( \ defined ( $ className . '::' . $ matches [ 2 ] ) ) { $ constantName = $ matches [ 0 ] ; $ defaultValue = \ constant ( $ className . '::' . $ matches [ 2 ] ) ; } } elseif ( \ defined ( $ defaultValue ) ) { $ constantName = $ defaultValue ; $ defaultValue = \ constant ( $ defaultValue ) ; } } else { $ defaultValue = \ trim ( $ defaultValue , '\'"' ) ; } } return array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , ) ; }
8594	public function listOrdersByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListOrdersByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7635	public function getBlockList ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null , $ type = 0 ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; if ( $ type < 0 || $ type > 2 ) { throw new BlobException ( 'Invalid type of block list to retrieve.' ) ; } $ blockListType = 'all' ; if ( $ type == 1 ) { $ blockListType = 'committed' ; } if ( $ type == 2 ) { $ blockListType = 'uncommitted' ; } $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ query = array ( 'comp' => 'blocklist' , 'blocklisttype' => $ blockListType ) ; if ( ! is_null ( $ snapshotId ) ) { $ query [ 'snapshot' ] = $ snapshotId ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , $ query , 'GET' , $ headers , false , null , self :: RESOURCE_BLOB , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } $ blockList = $ this -> parseResponse ( $ response ) ; $ returnValue = array ( ) ; if ( $ blockList -> CommittedBlocks ) { foreach ( $ blockList -> CommittedBlocks -> Block as $ block ) { $ returnValue [ 'CommittedBlocks' ] [ ] = ( object ) array ( 'Name' => ( string ) $ block -> Name , 'Size' => ( string ) $ block -> Size ) ; } } if ( $ blockList -> UncommittedBlocks ) { foreach ( $ blockList -> UncommittedBlocks -> Block as $ block ) { $ returnValue [ 'UncommittedBlocks' ] [ ] = ( object ) array ( 'Name' => ( string ) $ block -> Name , 'Size' => ( string ) $ block -> Size ) ; } } return $ returnValue ; }
3070	protected function saveItemState ( ) { if ( $ this -> getRequestParameter ( 'itemDefinition' ) && $ this -> getRequestParameter ( 'itemState' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemIdentifier = $ this -> getRequestParameter ( 'itemDefinition' ) ; $ state = $ this -> getRequestParameter ( 'itemState' ) ? json_decode ( $ this -> getRequestParameter ( 'itemState' ) , true ) : new \ stdClass ( ) ; return $ this -> getRunnerService ( ) -> setItemState ( $ serviceContext , $ itemIdentifier , $ state ) ; } return false ; }
5908	public function listUsers ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/users' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new User ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5835	private function clearExpiredCacheEntries ( int $ now ) { $ this -> now = $ now ; foreach ( $ this -> cacheTimeouts as $ path => $ timeout ) { if ( $ now <= $ timeout ) { break ; } $ fileInfo = $ this -> cache [ $ path ] ; unset ( $ this -> cache [ $ path ] , $ this -> cacheTimeouts [ $ path ] ) ; $ this -> bufferedFileCount -= isset ( $ fileInfo -> buffer ) ; $ this -> cacheEntryCount -- ; } }
6741	public function to ( $ target ) { if ( is_null ( $ this -> request ) ) { throw new \ LogicException ( 'Missing request instance.' ) ; } $ target = new Uri ( $ target ) ; $ uri = $ this -> request -> getUri ( ) -> withScheme ( $ target -> getScheme ( ) ) -> withHost ( $ target -> getHost ( ) ) ; if ( $ port = $ target -> getPort ( ) ) { $ uri = $ uri -> withPort ( $ port ) ; } if ( $ path = $ target -> getPath ( ) ) { $ uri = $ uri -> withPath ( rtrim ( $ path , '/' ) . '/' . ltrim ( $ uri -> getPath ( ) , '/' ) ) ; } if ( ! empty ( $ this -> request -> getQueryParams ( ) ) ) { $ queryParams = $ this -> request -> getQueryParams ( ) ; if ( count ( $ queryParams ) == 1 && empty ( array_shift ( $ queryParams ) ) ) { $ queryKeys = array_keys ( $ this -> request -> getQueryParams ( ) ) ; $ uri = $ uri -> withQuery ( $ queryKeys [ 0 ] ) ; } else { $ uri = $ uri -> withQuery ( http_build_query ( $ this -> request -> getQueryParams ( ) ) ) ; } } $ request = $ this -> request -> withUri ( $ uri ) ; foreach ( $ request -> getHeaders ( ) as $ headerName => $ headerValue ) { if ( empty ( $ headerValue [ 0 ] ) ) { $ request = $ request -> withoutHeader ( $ headerName ) ; } } return $ this -> client -> send ( $ request ) ; }
3378	private function showLink ( $ link ) { if ( ! $ link [ 'show_menu' ] ) return false ; $ user = \ Auth :: guard ( 'panel' ) -> user ( ) ; return $ user -> hasRole ( 'super' ) || $ user -> hasPermission ( '/' . $ link [ 'url' ] . '/all' ) ; }
6967	protected function calculateGoodLines ( Model \ DocumentInterface $ document ) : Amount { $ gross = new Amount ( $ document -> getCurrency ( ) ) ; foreach ( $ document -> getLinesByType ( Model \ DocumentLineTypes :: TYPE_GOOD ) as $ line ) { if ( null !== $ result = $ this -> calculateGoodLine ( $ line ) ) { $ gross -> merge ( $ result ) ; } } $ gross -> copyGrossToUnit ( ) ; return $ gross ; }
8945	public function replacePreferences ( $ preferences ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ preferenceList = '' ; if ( ! empty ( $ preferences ) ) { foreach ( $ preferences as $ key => $ value ) { $ preferenceList .= '<preference k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <preferences>' . $ preferenceList . '</preferences> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
4330	public static function serializeLog ( $ data ) { $ str = \ serialize ( $ data ) ; if ( \ function_exists ( 'gzdeflate' ) ) { $ str = \ gzdeflate ( $ str ) ; } $ str = \ chunk_split ( \ base64_encode ( $ str ) , 124 ) ; return "START DEBUG\n" . $ str . 'END DEBUG' ; }
7335	private function addMappings ( ClassMetadata $ metadata , array $ mappings ) { foreach ( $ mappings as $ mapping ) { if ( ! $ metadata -> hasField ( $ mapping [ 'fieldName' ] ) ) { $ metadata -> mapField ( $ mapping ) ; } } }
2530	protected function makeSoapClientOptions ( ) { $ options = $ this -> soapClientOptions ; $ options [ 'classmap' ] = array_merge ( Classmap :: $ soapheader4map , Classmap :: $ map ) ; if ( ! empty ( $ this -> params -> soapClientOptions ) ) { $ options = array_merge ( $ options , $ this -> params -> soapClientOptions ) ; } return $ options ; }
1526	protected function doUpdate ( StoreInterface $ store , UpdateResource $ request ) { if ( $ response = $ this -> beforeCommit ( $ request ) ) { return $ response ; } $ record = $ store -> updateRecord ( $ request -> getRecord ( ) , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> afterCommit ( $ request , $ record , true ) ? : $ record ; }
10690	public static function handleException ( \ Throwable $ e ) { $ app = self :: getInstance ( ) ; if ( $ app -> request === null ) $ app -> request = Request :: createFromGlobals ( ) ; $ req = $ app -> request ; try { if ( ! Request :: cli ( ) ) { $ mgr = $ app -> resolver ; $ res = $ mgr -> getResolver ( 'template' ) ; $ assets = $ mgr -> getResolver ( 'assets' ) ; $ amgr = new AssetManager ( $ assets ) ; $ tpl = new Template ( $ res , $ amgr , $ req ) ; $ tpl -> setExceptionTemplate ( $ e ) ; $ tpl -> assign ( 'exception' , $ e ) ; $ tpl -> assign ( 'request' , $ req ) ; $ tpl -> assign ( 'dev' , $ app -> dev ) ; $ app -> i18n ; $ response = $ tpl -> renderReturn ( ) ; $ responder = new \ Wedeto \ HTTP \ Responder ( ) ; $ result = new \ Wedeto \ HTTP \ Result ( ) ; $ result -> setResponse ( $ response ) ; $ responder -> setRequest ( $ req ) ; $ responder -> setResult ( $ result ) ; $ params = new Dictionary ( [ 'responder' => $ responder , 'mime' => 'text/html' ] ) ; $ amgr -> executeHook ( $ params ) ; $ responder -> respond ( ) ; } } catch ( \ Throwable $ e2 ) { echo "<h1>Error while showing error template:</h1>\n\n" ; echo "<pre>" . WF :: html ( $ e2 ) . "</pre>\n" ; } if ( Request :: cli ( ) ) { fprintf ( STDERR , \ Wedeto \ Application \ CLI \ ANSI :: bright ( "An uncaught exception has occurred:" ) . "\n\n" ) ; WF :: debug ( WF :: str ( $ e ) ) ; } else { echo "<h2>Original error:</h2>\n\n" ; echo "<pre>" . WF :: html ( $ e ) . "</pre>\n" ; } }
1754	public static function getLanguages ( $ blnInstalledOnly = false ) { $ return = array ( ) ; $ languages = array ( ) ; $ arrAux = array ( ) ; $ langsNative = array ( ) ; static :: loadLanguageFile ( 'languages' ) ; include __DIR__ . '/../../config/languages.php' ; foreach ( $ languages as $ strKey => $ strName ) { $ arrAux [ $ strKey ] = isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) ? Utf8 :: toAscii ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) : $ strName ; } asort ( $ arrAux ) ; $ arrBackendLanguages = self :: getContainer ( ) -> getParameter ( 'contao.locales' ) ; foreach ( array_keys ( $ arrAux ) as $ strKey ) { if ( $ blnInstalledOnly && ! \ in_array ( $ strKey , $ arrBackendLanguages ) ) { continue ; } $ return [ $ strKey ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ?? $ languages [ $ strKey ] ; if ( isset ( $ langsNative [ $ strKey ] ) && $ langsNative [ $ strKey ] != $ return [ $ strKey ] ) { $ return [ $ strKey ] .= ' - ' . $ langsNative [ $ strKey ] ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ return , $ languages , $ langsNative , $ blnInstalledOnly ) ; } } return $ return ; }
3949	private function buildCaption ( $ metaModel , $ inputScreen ) : array { $ caption = [ sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) , '' ] ; foreach ( $ inputScreen [ 'label' ] as $ langCode => $ label ) { if ( $ label !== '' && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ label , $ inputScreen [ 'description' ] [ $ langCode ] ] ; } } return $ caption ; }
4066	public function handle ( BuildWidgetEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ( $ environment -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_dcasetting' ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'mandatory' ) || ( null === $ event -> getModel ( ) -> getId ( ) ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( null === $ attribute ) { return ; } if ( $ attribute -> get ( 'isunique' ) ) { Message :: addInfo ( $ this -> translator -> trans ( 'tl_metamodel_dcasetting.mandatory_for_unique_attr' , [ ] , 'contao_tl_metamodel_dcasetting' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'disabled' ] = true ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; $ model -> setProperty ( 'mandatory' , true ) ; } }
3379	protected function getDefaultNamespace ( $ rootNamespace ) { $ controllersPath = \ Config :: get ( 'panel.controllers' ) ; if ( isset ( $ controllersPath ) && $ controllersPath != NULL ) { return $ controllersPath ; } else { return $ rootNamespace . '\Http\Controllers' ; } }
57	public function remove ( PackageInterface $ package , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> remove ( $ package , $ targetDir ) ; } }
4722	public function setText ( $ text ) { $ this -> text = $ text ; if ( ! $ this -> text instanceof Text ) { $ this -> text = new Text ( $ this -> text ) ; } return $ this ; }
5471	private function getProperty ( $ name , $ object ) { $ reflection = new ReflectionObject ( $ object ) ; $ property = $ reflection -> getProperty ( $ name ) ; if ( method_exists ( $ property , 'setAccessible' ) ) { $ property -> setAccessible ( true ) ; } try { return $ property -> getValue ( $ object ) ; } catch ( ReflectionException $ e ) { return $ this -> getPrivatePropertyNoMatterWhat ( $ name , $ object ) ; } }
2332	public function validator ( $ varInput ) { if ( ! \ is_array ( $ varInput ) ) { return null ; } foreach ( $ varInput as $ k => $ v ) { if ( $ k != 'language' ) { $ varInput [ $ k ] = array_map ( 'trim' , $ v ) ; } else { if ( $ v != '' ) { $ varInput [ $ v ] = array_combine ( array_keys ( $ this -> metaFields ) , array_fill ( 0 , \ count ( $ this -> metaFields ) , '' ) ) ; } unset ( $ varInput [ $ k ] ) ; } } return $ varInput ; }
5833	protected function headerToArray ( $ header ) { $ tmp = explode ( "\r\n" , $ header ) ; $ headers = array ( ) ; foreach ( $ tmp as $ singleHeader ) { $ delimiter = strpos ( $ singleHeader , ': ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 2 ) ; $ headers [ $ key ] = $ val ; } else { $ delimiter = strpos ( $ singleHeader , ' ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 1 ) ; $ headers [ $ key ] = $ val ; } } } return $ headers ; }
10708	public function getMany ( $ columns = [ '*' ] , $ paginated = false , $ perPage = null ) { $ results = $ paginated ? $ this -> getManyPaginated ( $ perPage , $ columns ) : $ this -> getQuery ( ) -> get ( $ columns ) ; return $ this -> returnResults ( $ results ) ; }
6463	public function tryGetFirst ( $ name , & $ value ) : bool { try { $ value = $ this -> get ( $ name ) [ 0 ] ; return true ; } catch ( OutOfBoundsException $ ex ) { return false ; } }
10068	protected function registerDecorators ( ) { $ decorators = array ( 'AutoId' ) ; foreach ( $ decorators as $ decoratorClass ) { $ decoratorClass = '\\Sirius\FormRenderer\\Decorator\\' . $ decoratorClass ; $ this -> addDecorator ( new $ decoratorClass ) ; } }
2202	public static function stripTags ( $ varValue , $ strAllowedTags = '' ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: stripTags ( $ v , $ strAllowedTags ) ; } return $ varValue ; } $ varValue = preg_replace_callback ( '@</?([^\s<>/]*)@' , function ( $ matches ) use ( $ strAllowedTags ) { if ( $ matches [ 1 ] == '' || stripos ( $ strAllowedTags , '<' . strtolower ( $ matches [ 1 ] ) . '>' ) === false ) { $ matches [ 0 ] = str_replace ( '<' , '&lt;' , $ matches [ 0 ] ) ; } return $ matches [ 0 ] ; } , $ varValue ) ; $ varValue = strip_tags ( $ varValue , $ strAllowedTags ) ; $ varValue = str_replace ( array ( '&lt;!--' , '&lt;![' ) , array ( '<!--' , '<![' ) , $ varValue ) ; while ( strpos ( $ varValue , '\\0' ) !== false ) { $ varValue = str_replace ( '\\0' , '' , $ varValue ) ; } return $ varValue ; }
11231	public function post ( $ section , $ body = null , array $ headers = [ ] ) { if ( is_array ( $ body ) ) { $ body = array_merge ( $ this -> parameters , $ body , $ this -> defaultParameters ) ; $ body = http_build_query ( $ body ) ; } return $ this -> client -> post ( $ this -> getUrl ( $ section ) , $ headers , $ body ) ; }
9596	public function makeSession ( ) { $ session = new Session ( $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Storage\SessionStorageInterface' ) , $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Attribute\AttributeBagInterface' ) , $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Flash\FlashBagInterface' ) ) ; $ session -> setName ( $ this -> config -> get ( 'session.cookie.name' , 'autarky_session' ) ) ; return $ session ; }
6727	public function set_movie_votes ( $ post_id , $ total_votes ) { $ total_votes = $ total_votes ? : 'N/B' ; if ( ! add_post_meta ( $ post_id , 'imdbVotes' , $ total_votes , true ) ) { update_post_meta ( $ post_id , 'imdbVotes' , $ total_votes ) ; } }
1873	private function addBundles ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; if ( $ container -> hasDefinition ( 'assets._version_default' ) ) { $ version = new Reference ( 'assets._version_default' ) ; } else { $ version = new Reference ( 'assets.empty_version_strategy' ) ; } $ bundles = $ container -> getParameter ( 'kernel.bundles' ) ; $ meta = $ container -> getParameter ( 'kernel.bundles_metadata' ) ; foreach ( $ bundles as $ name => $ class ) { if ( ! is_dir ( $ meta [ $ name ] [ 'path' ] . '/Resources/public' ) ) { continue ; } $ packageVersion = $ version ; $ packageName = $ this -> getBundlePackageName ( $ name ) ; $ serviceId = 'assets._package_' . $ packageName ; $ basePath = 'bundles/' . preg_replace ( '/bundle$/' , '' , strtolower ( $ name ) ) ; if ( is_file ( $ meta [ $ name ] [ 'path' ] . '/Resources/public/manifest.json' ) ) { $ def = new ChildDefinition ( 'assets.json_manifest_version_strategy' ) ; $ def -> replaceArgument ( 0 , $ meta [ $ name ] [ 'path' ] . '/Resources/public/manifest.json' ) ; $ container -> setDefinition ( 'assets._version_' . $ packageName , $ def ) ; $ packageVersion = new Reference ( 'assets._version_' . $ packageName ) ; } $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ packageVersion , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ packageName , new Reference ( $ serviceId ) ] ) ; } }
6601	protected function buildUrl ( $ url , $ params = [ ] ) { if ( $ this -> useOauth ) { $ params [ 'access_token' ] = $ this -> getAccessToken ( ) ; } $ params = http_build_query ( $ params ) ; return $ this -> baseUrl . $ url . '?' . $ params ; }
2897	public function replaceProfiler ( ) { $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ currentProfile = $ connection -> getProfiler ( ) ; if ( $ currentProfile ) { $ this -> _queryProfiles = $ currentProfile -> _queryProfiles ; } $ this -> setEnabled ( $ currentProfile -> getEnabled ( ) ) ; $ connection -> setProfiler ( $ this ) ; }
388	public function getAttributeOrder ( $ attribute ) { $ orders = $ this -> getAttributeOrders ( ) ; return isset ( $ orders [ $ attribute ] ) ? $ orders [ $ attribute ] : null ; }
11794	public function setBcc ( $ mail = '' , $ name = null ) { $ this -> bcc = Helper :: deduplicate ( array_merge ( $ this -> bcc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
217	public function asImage ( $ value , $ options = [ ] ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return Html :: img ( $ value , $ options ) ; }
12200	public function getData ( $ object ) { if ( ! $ this -> validateObject ( $ object ) ) { throw new InvalidArgumentException ( "Given object isn't instance of {$this->localName}" ) ; } $ reflection = new ReflectionObject ( $ object ) ; $ data = [ ] ; foreach ( array_keys ( $ this -> properties ) as $ localProperty ) { $ property = $ reflection -> getProperty ( $ localProperty ) ; $ property -> setAccessible ( true ) ; $ data [ $ localProperty ] = $ property -> getValue ( $ object ) ; } return $ data ; }
4194	private function magicMethodInfo ( $ methods ) { if ( ! $ methods ) { return '' ; } foreach ( $ methods as $ i => $ method ) { $ methods [ $ i ] = '<code>' . $ method . '</code>' ; } $ methods = $ i == 0 ? 'a ' . $ methods [ 0 ] . ' method' : \ implode ( ' and ' , $ methods ) . ' methods' ; return '<dd class="magic info">This object has ' . $ methods . '</dd>' . "\n" ; }
9067	public static function bootUuidForKey ( ) { static :: creating ( function ( $ model ) { $ model -> incrementing = false ; $ model -> attributes [ $ model -> getKeyName ( ) ] = ( string ) Str :: orderedUuid ( ) ; } ) ; }
8180	public function setDefaultStrategy ( $ defaultStrategy ) { if ( true === $ defaultStrategy ) { @ trigger_error ( 'Using "true" as the default strategy is deprecated since version 1.21. Use "html" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'html' ; } if ( 'filename' === $ defaultStrategy ) { @ trigger_error ( 'Using "filename" as the default strategy is deprecated since version 1.27. Use "name" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'name' ; } if ( 'name' === $ defaultStrategy ) { $ defaultStrategy = array ( 'Twig_FileExtensionEscapingStrategy' , 'guess' ) ; } $ this -> defaultStrategy = $ defaultStrategy ; }
5915	public function sendPasswordReset ( $ id , $ link = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'link' => $ link ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/resetpassword' , $ parameters ) ; return $ result ; }
206	public static function stdin ( $ raw = false ) { return $ raw ? fgets ( \ STDIN ) : rtrim ( fgets ( \ STDIN ) , PHP_EOL ) ; }
5076	public function getIndex ( $ aData = [ ] , $ iPage = null , $ iPerPage = null ) { $ oInput = Factory :: service ( 'Input' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; if ( is_null ( $ iPage ) ) { $ iPage = ( int ) $ oInput -> get ( 'page' ) ? : 1 ; } if ( is_null ( $ iPerPage ) ) { $ iPerPage = static :: CONFIG_MAX_ITEMS_PER_PAGE ; } $ aResults = $ oItemModel -> getAll ( $ iPage , $ iPerPage , $ aData ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( array_map ( [ $ this , 'formatObject' ] , $ aResults ) ) ; return $ oResponse ; }
2327	public function setRow ( array $ arrData ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ this -> arrModels [ $ this -> intIndex ] -> setRow ( $ arrData ) ; return $ this ; }
12619	protected function loadForeignDataItems ( ) { if ( ! $ this -> fileSource ) { \ d ( "boom" ) ; return false ; } $ foreignModelClass = $ this -> foreignModelClass ; $ lines = $ this -> fileSource -> getLines ( $ this -> lazyForeign ) ; $ lineCount = 0 ; foreach ( $ lines as $ id => $ line ) { if ( $ this -> lazyForeign ) { $ this -> createForeignDataItem ( null , [ 'deferredModel' => $ line ] ) ; } else { $ model = $ this -> createModel ( $ line -> id , $ line -> attributes ) ; $ this -> createForeignDataItem ( $ model , [ 'deferredModel' => $ line ] ) ; } $ lineCount ++ ; } $ this -> task -> addInfo ( "Processed {$lineCount} lines from {$this->fileSource->id}" ) ; }
9856	private function addContinue ( $ data ) { $ limit = $ this -> limit ; $ record = 0x003C ; $ tmp = substr ( $ data , 0 , 2 ) . pack ( 'v' , $ limit ) . substr ( $ data , 4 , $ limit ) ; $ header = pack ( 'vv' , $ record , $ limit ) ; $ data_length = strlen ( $ data ) ; for ( $ i = $ limit + 4 ; $ i < ( $ data_length - $ limit ) ; $ i += $ limit ) { $ tmp .= $ header ; $ tmp .= substr ( $ data , $ i , $ limit ) ; } $ header = pack ( 'vv' , $ record , strlen ( $ data ) - $ i ) ; $ tmp .= $ header ; $ tmp .= substr ( $ data , $ i ) ; return $ tmp ; }
11227	final public function setProperties ( array $ properties = [ ] ) { foreach ( $ properties as $ name => $ value ) { if ( property_exists ( $ this , $ name ) ) { $ this -> $ name = $ value ; } else { trigger_error ( Message :: get ( Message :: MSG_PROPERTY_UNKNOWN , $ name , get_class ( $ this ) ) , E_USER_WARNING ) ; } } }
4257	protected function getErrorsInCategory ( $ category ) { $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ errorsInCat = array ( ) ; foreach ( $ errors as $ err ) { if ( $ err [ 'category' ] == $ category && $ err [ 'inConsole' ] ) { $ errorsInCat [ ] = $ err ; } } return $ errorsInCat ; }
5892	public static function logEntry ( $ entry ) { $ parts = explode ( "|" , $ entry , 5 ) ; $ array = array ( ) ; if ( count ( $ parts ) != 5 ) { $ array [ "timestamp" ] = 0 ; $ array [ "level" ] = TeamSpeak3 :: LOGLEVEL_ERROR ; $ array [ "channel" ] = "ParamParser" ; $ array [ "server_id" ] = "" ; $ array [ "msg" ] = StringHelper :: factory ( "convert error (" . trim ( $ entry ) . ")" ) ; $ array [ "msg_plain" ] = $ entry ; $ array [ "malformed" ] = true ; } else { $ array [ "timestamp" ] = strtotime ( trim ( $ parts [ 0 ] ) ) ; $ array [ "level" ] = self :: logLevel ( trim ( $ parts [ 1 ] ) ) ; $ array [ "channel" ] = trim ( $ parts [ 2 ] ) ; $ array [ "server_id" ] = trim ( $ parts [ 3 ] ) ; $ array [ "msg" ] = StringHelper :: factory ( trim ( $ parts [ 4 ] ) ) ; $ array [ "msg_plain" ] = $ entry ; $ array [ "malformed" ] = false ; } return $ array ; }
10700	public static function isMobilePhoneNumber ( $ phone ) { $ phoneNumber = substr ( Tools :: removeSpace ( $ phone ) , - 9 , 1 ) ; return ( ! self :: isCzechPhoneNumber ( $ phoneNumber ) || ( $ phoneNumber === '6' || $ phoneNumber === '7' ) ) ; }
5527	protected function extendClassCode ( $ methods ) { $ code = 'class ' . $ this -> mock_class . ' extends ' . $ this -> class . " {\n" ; $ code .= " protected \$mock;\n" ; $ code .= $ this -> addMethodList ( $ methods ) ; $ code .= "\n" ; $ code .= " function __construct() {\n" ; $ code .= ' $this->mock = new ' . $ this -> mock_base . "();\n" ; $ code .= " \$this->mock->disableExpectationNameChecks();\n" ; $ code .= " }\n" ; $ code .= $ this -> createCodeForConstructor ( ) ; $ code .= $ this -> chainMockReturns ( ) ; $ code .= $ this -> chainMockExpectations ( ) ; $ code .= $ this -> chainThrowMethods ( ) ; $ code .= $ this -> createCodeForOverridenMethods ( $ methods ) ; $ code .= "}\n" ; return $ code ; }
88	public function equals ( Rule $ rule ) { if ( $ rule instanceof self ) { if ( $ this -> literal1 !== $ rule -> literal1 ) { return false ; } if ( $ this -> literal2 !== $ rule -> literal2 ) { return false ; } return true ; } $ literals = $ rule -> getLiterals ( ) ; if ( 2 != count ( $ literals ) ) { return false ; } if ( $ this -> literal1 !== $ literals [ 0 ] ) { return false ; } if ( $ this -> literal2 !== $ literals [ 1 ] ) { return false ; } return true ; }
4598	public function generateIdentity ( Identitiable $ model , bool $ overwrite = false ) { if ( null === $ model -> getIdentity ( ) || $ overwrite ) { $ user = $ this -> tokenStorage -> getToken ( ) -> getUser ( ) ; $ model -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) ; } return $ this ; }
12570	public function previewNews ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_NEWS , $ message , $ to , $ by ) ; }
5346	public function requestRemoteHands ( $ colocationName , $ contactName , $ phoneNumber , $ expectedDuration , $ instructions ) { return $ this -> call ( self :: SERVICE , 'requestRemoteHands' , [ $ colocationName , $ contactName , $ phoneNumber , $ expectedDuration , $ instructions ] ) ; }
2928	public function getKeys ( $ keys = [ ] ) { $ allKeys = $ this -> reader -> keys ( ) ; return array_filter ( $ allKeys , function ( $ key ) use ( $ keys ) { if ( ! empty ( $ keys ) ) { return in_array ( $ key , $ keys ) ; } return true ; } , ARRAY_FILTER_USE_KEY ) ; }
1474	public function createResourceValidator ( ResourceObject $ resource , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ resource -> all ( ) , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) use ( $ resource ) { return $ this -> invalidResource ( $ resource -> pointer ( $ key , '/data' ) , $ detail , $ failed ) ; } ) ; }
376	protected function parseDocCommentDetail ( $ reflection ) { $ comment = strtr ( trim ( preg_replace ( '/^\s*\**( |\t)?/m' , '' , trim ( $ reflection -> getDocComment ( ) , '/' ) ) ) , "\r" , '' ) ; if ( preg_match ( '/^\s*@\w+/m' , $ comment , $ matches , PREG_OFFSET_CAPTURE ) ) { $ comment = trim ( substr ( $ comment , 0 , $ matches [ 0 ] [ 1 ] ) ) ; } if ( $ comment !== '' ) { return rtrim ( Console :: renderColoredString ( Console :: markdownToAnsi ( $ comment ) ) ) ; } return '' ; }
2823	public function deleteExpiredRequests ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( ! $ helper -> isEnabled ( ) ) { return 'skipped: module is disabled.' ; } if ( $ helper -> getPersistLifetime ( ) == 0 ) { return 'skipped: lifetime is set to 0' ; } $ expirationDate = $ this -> getExpirationDate ( date ( self :: DATE_FORMAT ) ) ; $ table = $ this -> getRequestsTable ( ) ; $ deleteSql = "DELETE FROM {$table} WHERE date <= '{$expirationDate}'" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return "{$result->rowCount()} requests deleted" ; }
11040	function leaf_path_walk ( $ elements , $ rank , $ ptype , & $ i , $ cvalue ) { if ( count ( $ elements ) == 1 ) { $ elt [ $ ptype . ':' . $ i . ':' . $ elements [ 0 ] . ':' . $ cvalue ] = '' ; } else { $ element1 = array_shift ( $ elements ) ; $ elt [ _ETS_TEMPLATE . ':' . $ i . '.' . $ rank . ':' . $ element1 ] = $ this -> leaf_path_walk ( $ elements , $ rank + 1 , $ ptype , $ i , $ cvalue ) ; } return $ elt ; }
5098	private function appendByPosition ( $ values ) { $ this -> setPart ( CmdInsert :: PART_AS , false ) ; if ( ! $ this -> placeholder ) $ this -> placeholder = Assembly :: placeholder ( count ( $ values ) , true ) ; return $ this -> appendPart ( CmdInsert :: PART_VALUES , $ this -> placeholder , $ values ) ; }
2173	private function warmUpSymfonyCache ( ) : void { $ cacheDir = $ this -> getContainerParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ cacheDir . '/contao/config/config.php' ) ) { return ; } $ warmer = $ this -> container -> get ( 'cache_warmer' ) ; if ( ! $ this -> getContainerParameter ( 'kernel.debug' ) ) { $ warmer -> enableOptionalWarmers ( ) ; } $ warmer -> warmUp ( $ cacheDir ) ; if ( \ function_exists ( 'opcache_reset' ) ) { opcache_reset ( ) ; } if ( \ function_exists ( 'apc_clear_cache' ) && ! ini_get ( 'apc.stat' ) ) { apc_clear_cache ( ) ; } }
11864	public function save ( string $ sessionIdentifier , string $ sessionData ) : void { self :: $ files [ $ sessionIdentifier ] = [ 'data' => $ sessionData , 'time' => microtime ( true ) ] ; }
1119	public function scopeLimitDepth ( $ query , $ limit ) { $ depth = $ this -> exists ? $ this -> getDepth ( ) : $ this -> getLevel ( ) ; $ max = $ depth + $ limit ; $ scopes = array ( $ depth , $ max ) ; return $ query -> whereBetween ( $ this -> getDepthColumnName ( ) , array ( min ( $ scopes ) , max ( $ scopes ) ) ) ; }
9423	public function getSize ( ) { if ( is_null ( $ this -> size ) === true ) { $ stats = fstat ( $ this -> stream ) ; $ this -> size = $ stats [ 'size' ] ; } return $ this -> size ; }
2232	protected function getDatalistOptions ( ) { $ strGroups = '' ; if ( ! $ this -> User -> isAdmin ) { if ( empty ( $ this -> User -> amg ) || ! \ is_array ( $ this -> User -> amg ) ) { header ( 'Content-type: application/json' ) ; die ( json_encode ( array ( ) ) ) ; } $ arrGroups = array ( ) ; foreach ( $ this -> User -> amg as $ intGroup ) { $ arrGroups [ ] = '%"' . ( int ) $ intGroup . '"%' ; } $ strGroups = " AND (groups LIKE '" . implode ( "' OR GROUPS LIKE '" , $ arrGroups ) . "')" ; } $ arrUsers = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objUsers = $ this -> Database -> prepare ( "SELECT username FROM tl_member WHERE username LIKE ?$strGroups AND login='1' AND disable!='1' AND (start='' OR start<='$time') AND (stop='' OR stop>'" . ( $ time + 60 ) . "') ORDER BY username" ) -> limit ( 10 ) -> execute ( str_replace ( '%' , '' , Input :: post ( 'value' ) ) . '%' ) ; if ( $ objUsers -> numRows ) { $ arrUsers = $ objUsers -> fetchEach ( 'username' ) ; } header ( 'Content-type: application/json' ) ; die ( json_encode ( $ arrUsers ) ) ; }
10933	protected function resolveParams ( UriInfo $ info , array $ params ) { $ uri = $ info -> getUri ( ) ; if ( false === strpos ( $ uri , '{' ) ) { return $ info ; } $ ctx = NULL ; $ result = '' ; foreach ( preg_split ( "'(\\{[^\\}]+\\})'" , $ uri , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) as $ part ) { if ( '{' != substr ( $ part , 0 , 1 ) ) { $ result .= $ part ; continue ; } $ placeholder = substr ( $ part , 1 , - 1 ) ; if ( '*' == substr ( $ placeholder , - 1 ) ) { $ placeholder = substr ( $ placeholder , 0 , - 1 ) ; $ multi = true ; } else { $ multi = false ; } switch ( substr ( $ placeholder , 0 , 1 ) ) { case '.' : $ placeholder = substr ( $ placeholder , 1 ) ; $ prefix = '.' ; $ join = $ multi ? '.' : ',' ; break ; case '/' : $ placeholder = substr ( $ placeholder , 1 ) ; $ prefix = '/' ; $ join = $ multi ? '/' : ',' ; break ; default : $ prefix = '' ; $ join = ',' ; } if ( false === strpos ( $ placeholder , '.' ) ) { $ value = array_key_exists ( $ placeholder , $ params ) ? $ params [ $ placeholder ] : $ this ; } else { if ( $ ctx === NULL ) { $ ctx = $ this -> factory -> createContext ( $ params ) ; } $ value = $ ctx -> resolveValue ( explode ( '.' , $ placeholder ) , $ this ) ; } if ( $ value === $ this ) { $ result .= $ part ; } elseif ( is_array ( $ value ) || $ value instanceof \ Traversable ) { $ i = 0 ; foreach ( $ value as $ val ) { $ result .= ( ( $ i ++ == 0 ) ? $ prefix : $ join ) . Uri :: encode ( $ val , true ) ; } } else { $ result .= $ prefix . Uri :: encode ( $ value , true ) ; } } return new UriInfo ( $ result , $ info -> getRouteName ( ) , $ info -> getMethods ( ) , $ info -> getHandler ( ) ) ; }
6404	public static function propagateIfInstanceOf ( Exception $ exception , string $ exceptionClass ) : void { if ( is_a ( $ exception , $ exceptionClass ) ) { throw $ exception ; } }
366	public function renderTableFooter ( ) { $ cells = [ ] ; foreach ( $ this -> columns as $ column ) { $ cells [ ] = $ column -> renderFooterCell ( ) ; } $ content = Html :: tag ( 'tr' , implode ( '' , $ cells ) , $ this -> footerRowOptions ) ; if ( $ this -> filterPosition === self :: FILTER_POS_FOOTER ) { $ content .= $ this -> renderFilters ( ) ; } return "<tfoot>\n" . $ content . "\n</tfoot>" ; }
11981	public function isAccessible ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ resource -> isLocked ( ) ) { return true ; } $ lock = $ resource -> getLock ( ) ; if ( $ lock instanceof ExpiringLockInterface and $ this -> isLockExpired ( $ lock ) ) { $ this -> release ( $ lock ) ; return true ; } return $ lock -> getAcquirer ( ) -> getIdentifier ( ) === $ acquirer -> getIdentifier ( ) ; }
2593	protected function loadFeeIds ( $ feeIds ) { if ( is_null ( $ this -> feeIdDescription ) ) { $ this -> feeIdDescription = new FeeIdDescription ( ) ; } foreach ( $ feeIds as $ feeId ) { $ this -> feeIdDescription -> feeId [ ] = new FeeId ( $ feeId -> type , $ feeId -> number ) ; } }
4976	public static function factory ( ContainerInterface $ container ) { $ manager = $ container -> get ( 'ModuleManager' ) ; $ modules = $ manager -> getLoadedModules ( ) ; return new static ( $ modules ) ; }
4022	protected function getHelpForWidget ( $ widget ) { if ( $ GLOBALS [ 'TL_CONFIG' ] [ 'showHelp' ] && $ widget -> description ) { return sprintf ( '<p class="tl_help tl_tip%s">%s</p>' , $ widget -> tl_class , $ widget -> description ) ; } return '' ; }
9997	protected function inferSeparator ( ) { if ( $ this -> delimiter !== null ) { return ; } $ potentialDelimiters = [ ',' , ';' , "\t" , '|' , ':' , ' ' ] ; $ counts = [ ] ; foreach ( $ potentialDelimiters as $ delimiter ) { $ counts [ $ delimiter ] = [ ] ; } $ numberLines = 0 ; while ( ( $ line = fgets ( $ this -> fileHandle ) ) !== false && ( ++ $ numberLines < 1000 ) ) { $ enclosure = preg_quote ( $ this -> enclosure , '/' ) ; $ line = preg_replace ( '/(' . $ enclosure . '.*' . $ enclosure . ')/U' , '' , $ line ) ; $ countLine = [ ] ; for ( $ i = strlen ( $ line ) - 1 ; $ i >= 0 ; -- $ i ) { $ char = $ line [ $ i ] ; if ( isset ( $ counts [ $ char ] ) ) { if ( ! isset ( $ countLine [ $ char ] ) ) { $ countLine [ $ char ] = 0 ; } ++ $ countLine [ $ char ] ; } } foreach ( $ potentialDelimiters as $ delimiter ) { $ counts [ $ delimiter ] [ ] = isset ( $ countLine [ $ delimiter ] ) ? $ countLine [ $ delimiter ] : 0 ; } } $ meanSquareDeviations = [ ] ; $ middleIdx = floor ( ( $ numberLines - 1 ) / 2 ) ; foreach ( $ potentialDelimiters as $ delimiter ) { $ series = $ counts [ $ delimiter ] ; sort ( $ series ) ; $ median = ( $ numberLines % 2 ) ? $ series [ $ middleIdx ] : ( $ series [ $ middleIdx ] + $ series [ $ middleIdx + 1 ] ) / 2 ; if ( $ median === 0 ) { continue ; } $ meanSquareDeviations [ $ delimiter ] = array_reduce ( $ series , function ( $ sum , $ value ) use ( $ median ) { return $ sum + pow ( $ value - $ median , 2 ) ; } ) / count ( $ series ) ; } $ min = INF ; foreach ( $ potentialDelimiters as $ delimiter ) { if ( ! isset ( $ meanSquareDeviations [ $ delimiter ] ) ) { continue ; } if ( $ meanSquareDeviations [ $ delimiter ] < $ min ) { $ min = $ meanSquareDeviations [ $ delimiter ] ; $ this -> delimiter = $ delimiter ; } } if ( $ this -> delimiter === null ) { $ this -> delimiter = reset ( $ potentialDelimiters ) ; } return $ this -> skipBOM ( ) ; }
5685	protected function getUrlFromLink ( $ link ) { $ url = $ this -> expandUrl ( $ link -> getHref ( ) ) ; if ( $ link -> getAttribute ( 'target' ) ) { $ url -> setTarget ( $ link -> getAttribute ( 'target' ) ) ; } return $ url ; }
10881	public function checkPaths ( ) { if ( $ this -> path_checked ) return true ; foreach ( array ( 'root' , 'webroot' ) as $ type ) { $ path = $ this -> $ type ; if ( ! file_exists ( $ path ) || ! is_dir ( $ path ) ) throw new IOException ( "Path '$type' does not exist: " . $ path ) ; if ( ! is_readable ( $ path ) ) throw new PermissionError ( $ path , "Path '$type' cannot be read" ) ; } if ( ! is_dir ( $ this -> config ) || is_readable ( $ this -> config ) ) $ this -> config = null ; foreach ( array ( 'var' , 'cache' , 'log' , 'uploads' ) as $ write_dir ) { $ path = $ this -> $ write_dir ; if ( ! is_dir ( $ path ) ) { $ dn = dirname ( $ path ) ; if ( ! file_exists ( $ path ) && $ dn === $ this -> var ) { Path :: mkdir ( $ path ) ; } else { if ( file_exists ( $ path ) ) throw new IOException ( "Path '$write_dir' exists but is not a directory: " . $ path ) ; $ this -> $ write_dir = null ; continue ; } } if ( ! is_writable ( $ path ) ) { try { Path :: makeWritable ( $ path ) ; } catch ( PermissionError $ e ) { $ this -> $ write_dir = null ; if ( $ this -> cli ) WF :: debug ( "Failed to get write access to: %s" , $ e -> getMessage ( ) ) ; } } } $ this -> path_checked = true ; return true ; }
12632	public function query ( $ orderNo , $ type = self :: OUT_TRADE_NO ) { $ params = [ $ type => $ orderNo , ] ; return $ this -> request ( $ this -> wrapApi ( self :: API_QUERY ) , $ params ) ; }
7382	public static function toInsert ( $ input , array $ include = [ ] ) { if ( is_object ( $ input ) ) { if ( method_exists ( $ input , 'toArray' ) ) { $ input = $ input -> toArray ( ) ; } elseif ( $ input instanceof \ Traversable ) { $ input = iterator_to_array ( $ input ) ; } else { $ input = ( array ) $ input ; } } elseif ( ! is_array ( $ input ) ) { throw new InvalidArgumentException ( 'input must be an associative array or traversable object' ) ; } if ( count ( $ include ) ) { $ arr = [ ] ; foreach ( $ include as $ i ) { if ( isset ( $ input [ $ i ] ) ) { $ arr [ $ i ] &= $ input [ $ i ] ; } } } else { $ arr = & $ input ; } $ sqlStrs = [ ] ; foreach ( $ arr as $ k => & $ v ) { $ kEq = '`' . $ k . '` = ' ; switch ( gettype ( $ v ) ) { case 'bool' : case 'boolean' : $ sqlStrs [ ] = $ kEq . ( $ v ? '1' : '0' ) ; break ; case 'int' : case 'integer' : case 'float' : case 'double' : $ sqlStrs [ ] = $ kEq . $ v ; break ; case 'string' : if ( $ v === 'NULL' ) { $ sqlStrs [ ] = $ kEq . 'NULL' ; } else { $ sqlStrs [ ] = $ kEq . '"' . addslashes ( $ v ) . '"' ; } break ; case 'null' : case 'NULL' : $ sqlStrs [ ] = $ kEq . 'NULL' ; break ; case 'object' : if ( $ v instanceof DateTime ) { $ sqlStrs [ ] = $ kEq . '"' . $ v . '"' ; break ; } case 'array' : $ sqlStrs [ ] = $ kEq . '"' . addslashes ( json_encode ( $ v ) ) . '"' ; $ jsonLastErr = json_last_error ( ) ; if ( $ jsonLastErr !== JSON_ERROR_NONE ) { throw new UnexpectedValueException ( json_last_error_msg ( ) , $ jsonLastErr ) ; } break ; default : break ; } } return implode ( ",\n" , $ sqlStrs ) ; }
4119	public static function addType ( $ name , $ className ) { if ( isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeExists ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
2140	private function fetchHttpHeaders ( ) : void { $ this -> headers = array_merge ( $ this -> headers , $ this -> headerStorage -> all ( ) ) ; $ this -> headerStorage -> clear ( ) ; }
9201	private function createBearerCredentials ( ) { $ consumerKey = rawurlencode ( $ this -> credentials -> getConsumerKey ( ) ) ; $ consumerSecret = rawurlencode ( $ this -> credentials -> getConsumerSecret ( ) ) ; $ bearerTokenCredentials = $ consumerKey . ':' . $ consumerSecret ; return base64_encode ( $ bearerTokenCredentials ) ; }
11220	private static function cleanResources ( ) { self :: $ callbacks = [ ] ; self :: $ methods = [ ] ; self :: $ halts = false ; self :: $ response = false ; }
10231	public function write ( Spreadsheet $ spreadsheet = null ) { if ( ! $ spreadsheet ) { $ spreadsheet = $ this -> getParentWriter ( ) -> getSpreadsheet ( ) ; } $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-meta' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:dc' , 'http://purl.org/dc/elements/1.1/' ) ; $ objWriter -> writeAttribute ( 'xmlns:meta' , 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'xmlns:grddl' , 'http://www.w3.org/2003/g/data-view#' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:meta' ) ; $ objWriter -> writeElement ( 'meta:initial-creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'dc:creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'meta:creation-date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:title' , $ spreadsheet -> getProperties ( ) -> getTitle ( ) ) ; $ objWriter -> writeElement ( 'dc:description' , $ spreadsheet -> getProperties ( ) -> getDescription ( ) ) ; $ objWriter -> writeElement ( 'dc:subject' , $ spreadsheet -> getProperties ( ) -> getSubject ( ) ) ; $ keywords = explode ( ' ' , $ spreadsheet -> getProperties ( ) -> getKeywords ( ) ) ; foreach ( $ keywords as $ keyword ) { $ objWriter -> writeElement ( 'meta:keyword' , $ keyword ) ; } $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'Company' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCompany ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'category' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCategory ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
317	public function registerAssetBundle ( $ name , $ position = null ) { if ( ! isset ( $ this -> assetBundles [ $ name ] ) ) { $ am = $ this -> getAssetManager ( ) ; $ bundle = $ am -> getBundle ( $ name ) ; $ this -> assetBundles [ $ name ] = false ; $ pos = isset ( $ bundle -> jsOptions [ 'position' ] ) ? $ bundle -> jsOptions [ 'position' ] : null ; foreach ( $ bundle -> depends as $ dep ) { $ this -> registerAssetBundle ( $ dep , $ pos ) ; } $ this -> assetBundles [ $ name ] = $ bundle ; } elseif ( $ this -> assetBundles [ $ name ] === false ) { throw new InvalidConfigException ( "A circular dependency is detected for bundle '$name'." ) ; } else { $ bundle = $ this -> assetBundles [ $ name ] ; } if ( $ position !== null ) { $ pos = isset ( $ bundle -> jsOptions [ 'position' ] ) ? $ bundle -> jsOptions [ 'position' ] : null ; if ( $ pos === null ) { $ bundle -> jsOptions [ 'position' ] = $ pos = $ position ; } elseif ( $ pos > $ position ) { throw new InvalidConfigException ( "An asset bundle that depends on '$name' has a higher javascript file position configured than '$name'." ) ; } foreach ( $ bundle -> depends as $ dep ) { $ this -> registerAssetBundle ( $ dep , $ pos ) ; } } return $ bundle ; }
8041	public function formatEventsToJson ( array $ calendarEvents ) { $ array = [ ] ; foreach ( $ calendarEvents as $ event ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ event -> start ) ) -> toIso8601String ( ) ; $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ event -> end ) ) -> toIso8601String ( ) ; $ allDay = $ event -> all_day == 1 ; $ data = [ 'title' => $ event -> title , 'description' => $ event -> description , 'start' => $ start , 'end' => $ end , 'allDay' => $ allDay , 'borderColor' => $ event -> border_color , 'textColor' => $ event -> text_color , 'backgroundColor' => $ event -> background_color , ] ; $ array [ ] = $ data ; if ( $ event -> calendarEventRepeatDates ( ) -> count ( ) > 0 ) { foreach ( $ event -> calendarEventRepeatDates ( ) -> get ( ) as $ repeatDate ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ repeatDate -> start ) ) -> toIso8601String ( ) ; $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ repeatDate -> end ) ) -> toIso8601String ( ) ; $ data [ 'start' ] = $ start ; $ data [ 'end' ] = $ end ; $ array [ ] = $ data ; } } } return $ array ; }
3091	public function store ( $ data ) { $ this -> cache [ $ this -> testSessionId ] = & $ data ; $ encodedData = $ this -> getStorageFormat ( ) -> encode ( $ data ) ; $ this -> getStorageService ( ) -> set ( $ this -> getUserKey ( ) , $ this -> getStorageKey ( ) , $ encodedData ) ; \ common_Logger :: d ( sprintf ( 'QtiTimer: Stored %d bytes into state storage' , strlen ( $ encodedData ) ) ) ; return $ this ; }
12114	protected function loadForeignDataItems ( ) { $ this -> _foreignDataItems = [ ] ; if ( $ this -> lazyForeign ) { $ primaryKeys = $ this -> foreignModel -> findPrimaryKeys ( $ this -> settings [ 'foreignPullParams' ] ) ; foreach ( $ primaryKeys as $ primaryKey ) { $ this -> createForeignDataItem ( null , [ 'foreignPrimaryKey' => $ primaryKey ] ) ; } } else { $ foreignModels = $ this -> foreignModel -> findAll ( $ this -> settings [ 'foreignPullParams' ] ) ; foreach ( $ foreignModels as $ key => $ model ) { $ this -> createForeignDataItem ( $ model , [ ] ) ; } } }
7509	function setIdentifiers ( $ ident ) { if ( is_array ( $ ident ) ) { $ this -> identifiers = array_fill_keys ( array_values ( $ ident ) , true ) ; $ this -> buildCharMap ( ) ; } else { $ this -> setIdentifiers ( str_split ( $ ident ) ) ; } }
2339	public function renderDropdown ( ) { $ objVersion = $ this -> Database -> prepare ( "SELECT tstamp, version, username, active FROM tl_version WHERE fromTable=? AND pid=? ORDER BY version DESC" ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> numRows < 2 ) { return '' ; } $ versions = '' ; while ( $ objVersion -> next ( ) ) { $ versions .= ' <option value="' . $ objVersion -> version . '"' . ( $ objVersion -> active ? ' selected="selected"' : '' ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'version' ] . ' ' . $ objVersion -> version . ' (' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ objVersion -> tstamp ) . ') ' . $ objVersion -> username . '</option>' ; } return '<div class="tl_version_panel"><form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_version" class="tl_form" method="post" aria-label="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versioning' ] ) . '"><div class="tl_formbody"><input type="hidden" name="FORM_SUBMIT" value="tl_version"><input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"><select name="version" class="tl_select">' . $ versions . '</select><button type="submit" name="showVersion" id="showVersion" class="tl_submit">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'restore' ] . '</button><a href="' . Backend :: addToUrl ( 'versions=1&amp;popup=1' ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . StringUtil :: specialchars ( str_replace ( "'" , "\\'" , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] , $ this -> intPid , $ this -> strTable ) ) ) . '\',\'url\':this.href});return false">' . Image :: getHtml ( 'diff.svg' ) . '</a></div></form></div>' ; }
11597	public static function setCacheType ( string $ sCacheName ) { if ( $ sCacheName === 'file' ) { self :: $ _sTypeOfCache = 'file' ; } else if ( $ sCacheName === 'memcache' ) { self :: $ _sTypeOfCache = 'memcache' ; } else if ( $ sCacheName === 'apc' ) { self :: $ _sTypeOfCache = 'apc' ; } else if ( $ sCacheName === 'redis' ) { self :: $ _sTypeOfCache = 'redis' ; } else { self :: $ _sTypeOfCache = 'mock' ; } }
1424	protected function load ( $ record , EncodingParametersInterface $ parameters ) { $ relationshipPaths = $ this -> getRelationshipPaths ( $ parameters -> getIncludePaths ( ) ) ; $ record -> loadMissing ( $ relationshipPaths ) ; }
12544	public function setLink ( string $ link = null ) : \ TheCMSThread \ Core \ Main \ View { $ this -> link = $ link ; return $ this ; }
2759	protected function getStorageKey ( $ key , $ limit , $ milliseconds ) { $ window = $ milliseconds * ( floor ( ( microtime ( 1 ) * 1000 ) / $ milliseconds ) ) ; $ date = date ( 'YmdHis' , $ window / 1000 ) ; return $ date . '::' . $ key . '::' . $ limit . '::' . $ milliseconds . '::COUNT' ; }
1700	public function unzip ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ strName = $ this -> arrFiles [ $ this -> intIndex ] [ 'file_name' ] ; if ( $ this -> arrFiles [ $ this -> intIndex ] [ 'general_purpose_bit_flag' ] & 0x0001 ) { throw new \ Exception ( "File $strName is encrypted" ) ; } if ( @ fseek ( $ this -> resFile , $ this -> arrFiles [ $ this -> intIndex ] [ 'offset_of_local_header' ] ) !== 0 ) { throw new \ Exception ( "Cannot reposition pointer" ) ; } $ strSignature = @ fread ( $ this -> resFile , 4 ) ; if ( $ strSignature != self :: FILE_SIGNATURE ) { throw new \ Exception ( "$strName is not a compressed file" ) ; } fseek ( $ this -> resFile , 24 , SEEK_CUR ) ; $ arrEFL = unpack ( 'v' , @ fread ( $ this -> resFile , 2 ) ) ; fseek ( $ this -> resFile , ( $ this -> arrFiles [ $ this -> intIndex ] [ 'file_name_length' ] + $ arrEFL [ 1 ] ) , SEEK_CUR ) ; if ( $ this -> arrFiles [ $ this -> intIndex ] [ 'compressed_size' ] < 1 ) { return '' ; } $ strBuffer = @ fread ( $ this -> resFile , $ this -> arrFiles [ $ this -> intIndex ] [ 'compressed_size' ] ) ; switch ( $ this -> arrFiles [ $ this -> intIndex ] [ 'compression_method' ] ) { case 0 : break ; case 8 : $ strBuffer = gzinflate ( $ strBuffer ) ; break ; case 12 : if ( ! \ extension_loaded ( 'bz2' ) ) { throw new \ Exception ( 'PHP extension "bz2" required to decompress BZIP2 files' ) ; } $ strBuffer = bzdecompress ( $ strBuffer ) ; break ; default : throw new \ Exception ( 'Unknown compression method' ) ; break ; } if ( $ strBuffer === false ) { throw new \ Exception ( 'Could not decompress data' ) ; } if ( \ strlen ( $ strBuffer ) != $ this -> arrFiles [ $ this -> intIndex ] [ 'uncompressed_size' ] ) { throw new \ Exception ( 'Size of the uncompressed file does not match header value' ) ; } return $ strBuffer ; }
7196	public function handleReleasedChange ( OrderInterface $ order ) { if ( $ this -> persistenceHelper -> isChanged ( $ order , 'sample' ) ) { if ( $ order -> isReleased ( ) && ! $ order -> isSample ( ) ) { throw new IllegalOperationException ( "Can't turn 'sample' into false if order is released." ) ; } } if ( ! $ this -> persistenceHelper -> isChanged ( $ order , 'released' ) ) { return false ; } if ( ! $ order -> isSample ( ) && $ order -> isReleased ( ) ) { $ order -> setReleased ( false ) ; return true ; } if ( ! OrderStates :: isStockableState ( $ order -> getState ( ) ) ) { return false ; } foreach ( $ order -> getItems ( ) as $ item ) { $ this -> applySaleItemRecursively ( $ item ) ; } return false ; }
3731	protected function fetchRows ( $ arrIds , $ arrAttrOnly = array ( ) ) { $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ query = $ builder -> select ( '*' ) -> from ( $ this -> getTableName ( ) ) -> where ( $ builder -> expr ( ) -> in ( 'id' , ':values' ) ) -> setParameter ( 'values' , $ arrIds , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'FIELD(id, :values)' ) -> execute ( ) ; if ( $ arrAttrOnly ) { $ arrAttrOnly = array_merge ( $ this -> systemColumns , $ arrAttrOnly ) ; } $ result = [ ] ; while ( $ row = $ query -> fetch ( \ PDO :: FETCH_ASSOC ) ) { $ data = [ ] ; foreach ( $ row as $ attribute => $ value ) { if ( ( ! $ arrAttrOnly ) || ( in_array ( $ attribute , $ arrAttrOnly , true ) ) ) { $ data [ $ attribute ] = $ value ; } } $ result [ $ row [ 'id' ] ] = $ data ; } return $ result ; }
783	public function actionReport ( $ sourcePath , $ translationPath , $ title = 'Translation report' ) { $ sourcePath = trim ( $ sourcePath , '/\\' ) ; $ translationPath = trim ( $ translationPath , '/\\' ) ; $ results = [ ] ; $ dir = new DirectoryIterator ( $ sourcePath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ sourceFilePath = $ sourcePath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( $ translatedFilePath ) ; $ diff = empty ( $ errors ) ? $ this -> getDiff ( $ translatedFilePath , $ sourceFilePath ) : '' ; if ( ! empty ( $ diff ) ) { $ errors [ ] = 'Translation outdated.' ; } $ result = [ 'errors' => $ errors , 'diff' => $ diff , ] ; $ results [ $ fileinfo -> getFilename ( ) ] = $ result ; } } $ dir = new DirectoryIterator ( $ translationPath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( null , $ translatedFilePath ) ; if ( ! empty ( $ errors ) ) { $ results [ $ fileinfo -> getFilename ( ) ] [ 'errors' ] = $ errors ; } } } echo $ this -> renderFile ( __DIR__ . '/views/translation/report_html.php' , [ 'results' => $ results , 'sourcePath' => $ sourcePath , 'translationPath' => $ translationPath , 'title' => $ title , ] ) ; }
1717	public function canEditFieldsOf ( $ table ) { if ( $ this -> isAdmin ) { return true ; } return \ count ( preg_grep ( '/^' . preg_quote ( $ table , '/' ) . '::/' , $ this -> alexf ) ) > 0 ; }
10406	public function remove ( $ key ) { $ pair = $ this -> repository -> find ( $ key ) ; if ( $ pair !== null ) { $ this -> repository -> remove ( $ pair -> getId ( ) ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> refresh ( ) ; } }
7111	static public function isValidReason ( $ reason , $ throw = true ) { if ( in_array ( $ reason , static :: getReasons ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Invalid stock adjustment reason." ) ; } return false ; }
4902	private static function getDockerEnv ( $ configuration ) { $ cacheDir = $ configuration [ 'module_listener_options' ] [ 'cache_dir' ] . '/docker' ; $ configDir = static :: getConfigDir ( ) ; $ hydratorDir = $ cacheDir . '/Doctrine/Hydrator' ; $ proxyDir = $ cacheDir . '/Doctrine/Proxy' ; if ( ! is_dir ( $ hydratorDir ) ) { mkdir ( $ hydratorDir , 0777 , true ) ; } if ( ! is_dir ( $ proxyDir ) ) { mkdir ( $ proxyDir , 0777 , true ) ; } return [ 'module_listener_options' => [ 'cache_dir' => $ cacheDir , 'config_glob_paths' => [ $ configDir . '/autoload/*.docker.php' , ] ] , 'doctrine' => [ 'configuration' => [ 'odm_default' => [ 'hydrator_dir' => $ hydratorDir , 'proxy_dir' => $ proxyDir , ] ] ] ] ; }
9075	public function add ( $ name , Rule $ rule ) { unset ( $ this -> rules [ $ name ] ) ; $ this -> rules [ $ name ] = $ rule ; }
2906	public function getContent ( Zend_Mail $ mail ) { $ hasQueue = $ this -> hasQueue ( ) ; if ( $ hasQueue && $ queue = $ this -> getQueue ( ) ) { return $ queue -> getMessageBody ( ) ; } $ mimePart = $ this -> isPlain ( ) ? $ mail -> getBodyText ( ) : $ mail -> getBodyHtml ( ) ; return $ mimePart ? $ this -> getPartDecodedContent ( $ mimePart ) : '' ; }
7058	protected function getStockAdjustmentFromEvent ( ResourceEventInterface $ event ) { $ stockAdjustment = $ event -> getResource ( ) ; if ( ! $ stockAdjustment instanceof StockAdjustmentInterface ) { throw new InvalidArgumentException ( "Expected instance of " . StockAdjustmentInterface :: class ) ; } return $ stockAdjustment ; }
8569	public function setSKUPrepInstructions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SKUPrepInstructions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8099	protected function validateAll ( $ includeAllRules = false ) { if ( $ includeAllRules ) { $ fieldData = new Collection ( array_fill_keys ( array_keys ( $ this -> _validations -> toArray ( ) ) , null ) ) ; $ fieldData -> update ( $ this -> _updates -> toArray ( ) ) ; } else { $ fieldData = clone $ this -> _updates ; } foreach ( $ fieldData -> toArray ( ) as $ field => $ val ) { $ field2 = $ field . '2' ; if ( ! is_null ( $ fieldData -> $ field2 ) ) { if ( $ val != $ fieldData -> $ field2 ) { $ this -> log -> formError ( $ field , ucfirst ( $ field ) . 's did not match' ) ; } else { $ this -> log -> report ( ucfirst ( $ field ) . 's matched' ) ; } } if ( $ this -> _updates -> $ field ) { $ this -> _updates -> $ field = trim ( $ val ) ; } if ( $ validation = $ this -> _validations -> $ field ) { $ this -> validate ( $ field , $ validation -> limit , $ validation -> regEx ) ; } } return ! $ this -> log -> hasError ( ) ; }
106	public function moveWatch ( $ from , $ to ) { if ( $ this -> watch1 == $ from ) { $ this -> watch1 = $ to ; } else { $ this -> watch2 = $ to ; } }
12409	protected function save ( ) { $ yaml = Yaml :: dump ( $ this -> config , 2 ) ; file_put_contents ( $ this -> filePath , $ yaml ) ; }
1843	protected function getControllerName ( Reference $ reference , array $ attributes ) : string { $ controller = ( string ) $ reference ; if ( isset ( $ attributes [ 'method' ] ) ) { $ controller .= ':' . $ attributes [ 'method' ] ; } return $ controller ; }
7158	public function compile ( Database $ db = NULL ) : string { if ( $ db === null ) { $ db = \ Mii :: $ app -> db ; } $ value = $ this -> value ( ) ; if ( ! empty ( $ this -> _parameters ) ) { $ params = array_map ( [ $ db , 'quote' ] , $ this -> _parameters ) ; $ value = strtr ( $ value , $ params ) ; } return $ value ; }
283	private function findFixtures ( array $ fixtures = [ ] ) { $ fixturesPath = $ this -> getFixturePath ( ) ; $ filesToSearch = [ '*Fixture.php' ] ; $ findAll = ( $ fixtures === [ ] ) ; if ( ! $ findAll ) { $ filesToSearch = [ ] ; foreach ( $ fixtures as $ fileName ) { $ filesToSearch [ ] = $ fileName . 'Fixture.php' ; } } $ files = FileHelper :: findFiles ( $ fixturesPath , [ 'only' => $ filesToSearch ] ) ; $ foundFixtures = [ ] ; foreach ( $ files as $ fixture ) { $ foundFixtures [ ] = $ this -> getFixtureRelativeName ( $ fixture ) ; } return $ foundFixtures ; }
2625	protected function _toHtml ( ) { if ( $ this -> config -> isGeoIpEnabled ( ) == false || $ this -> config -> isFastlyEnabled ( ) == false ) { return parent :: _toHtml ( ) ; } $ actionUrl = $ this -> getUrl ( 'fastlyCdn/geoip/getaction' ) ; $ header = $ this -> response -> getHeader ( 'x-esi' ) ; if ( empty ( $ header ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } return sprintf ( '<esi:include src=\'%s\' />' , preg_replace ( "/^https/" , "http" , $ actionUrl ) ) ; }
2794	public function setTempDirectory ( $ dir ) { $ dir = rtrim ( $ dir , ' \\/' ) ; if ( ! is_dir ( $ dir ) || ! is_readable ( $ dir ) ) { throw new InvalidArgumentException ( 'Invalid cache directory: "' . $ dir . '"' ) ; } $ this -> tempDirectory = $ dir ; return $ this ; }
10829	public static function dir ( string $ path ) : fs \ entity \ DirEntity { return ( new fs \ entity \ DirEntity ( $ path ) ) -> normalize ( ) ; }
4342	public function start ( ) { if ( $ this -> isProfiling ) { return false ; } $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS ) ; $ backtrace = $ this -> backtraceRemoveInternal ( $ backtrace ) ; foreach ( $ backtrace as $ frame ) { $ class = isset ( $ frame [ 'class' ] ) ? $ frame [ 'class' ] . '::' : '' ; $ this -> rootStack [ ] = $ class . $ frame [ 'function' ] ; } \ register_tick_function ( array ( $ this , 'tickFunction' ) ) ; $ this -> isProfiling = true ; $ this -> timeLastTick = \ microtime ( true ) ; return true ; }
5852	protected function processData ( ) { $ close = GeneralUtility :: _GP ( 'closeDoc' ) ; $ save = GeneralUtility :: _GP ( '_savedok' ) ; $ saveAndClose = GeneralUtility :: _GP ( '_saveandclosedok' ) ; if ( $ save || $ saveAndClose ) { $ table = static :: virtualTable ; $ id = static :: virtualRecordId ; $ field = 'rulesets' ; $ inputData_tmp = GeneralUtility :: _GP ( 'data' ) ; $ data = $ inputData_tmp [ $ table ] [ $ id ] ; if ( count ( $ inputData_tmp [ $ table ] ) > 1 ) { foreach ( $ inputData_tmp [ $ table ] as $ key => $ values ) { if ( $ key === $ id ) continue ; ArrayUtility :: mergeRecursiveWithOverrule ( $ data , $ values ) ; } } $ newConfig = $ this -> config ; ArrayUtility :: mergeRecursiveWithOverrule ( $ newConfig , $ data ) ; $ ffValue = & $ data [ $ field ] ; if ( $ ffValue ) { $ actionCMDs = GeneralUtility :: _GP ( '_ACTION_FLEX_FORMdata' ) ; if ( is_array ( $ actionCMDs [ $ table ] [ $ id ] [ $ field ] [ 'data' ] ) ) { $ dataHandler = new CustomDataHandler ( ) ; $ dataHandler -> _ACTION_FLEX_FORMdata ( $ ffValue [ 'data' ] , $ actionCMDs [ $ table ] [ $ id ] [ $ field ] [ 'data' ] ) ; } $ this -> persistFlexForm ( $ ffValue [ 'data' ] ) ; $ newConfig [ $ field ] = $ ffValue ; } $ localconfConfig = $ newConfig ; $ localconfConfig [ 'conversion_mapping' ] = implode ( ',' , GeneralUtility :: trimExplode ( LF , $ localconfConfig [ 'conversion_mapping' ] , true ) ) ; if ( $ this -> persistConfiguration ( $ localconfConfig ) ) { $ this -> config = $ newConfig ; } } if ( $ close || $ saveAndClose ) { $ closeUrl = BackendUtility :: getModuleUrl ( 'tools_ExtensionmanagerExtensionmanager' ) ; \ TYPO3 \ CMS \ Core \ Utility \ HttpUtility :: redirect ( $ closeUrl ) ; } }
8159	public function getIsStatus ( ) { switch ( $ this -> status ) { case User :: STATUS_PENDING : return '<div class="text-center"><span class="text-primary">Pending</span></div>' ; case User :: STATUS_ACTIVE : return '<div class="text-center"><span class="text-success">Active</span></div>' ; case User :: STATUS_BLOCKED : return '<div class="text-center"><span class="text-danger">Blocked</span></div>' ; } return NULL ; }
8797	public function trigger ( $ event , array $ params = [ ] , $ method = 'handle' ) { $ listeners = config ( 'services.listeners' ) ; foreach ( $ listeners [ $ event ] as $ listener ) { if ( ! class_exists ( $ listener ) ) { throw new ExceptionHandler ( 'Event class not found.' , $ listener ) ; } if ( ! method_exists ( $ listener , $ method ) ) { throw new ExceptionHandler ( 'Method not found in Event class.' , $ listener . '::' . $ method . '()' ) ; } call_user_func_array ( [ new $ listener , $ method ] , $ params ) ; } }
9862	private function writeSheetFormatPr ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'sheetFormatPr' ) ; if ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , 'true' ) ; $ objWriter -> writeAttribute ( 'defaultRowHeight' , StringHelper :: formatNumber ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) ) ) ; } else { $ objWriter -> writeAttribute ( 'defaultRowHeight' , '14.4' ) ; } if ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) == '1' || strtolower ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) ) == 'true' ) { $ objWriter -> writeAttribute ( 'zeroHeight' , '1' ) ; } if ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'defaultColWidth' , StringHelper :: formatNumber ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) ) ) ; } $ outlineLevelRow = 0 ; foreach ( $ pSheet -> getRowDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelRow ) { $ outlineLevelRow = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelRow' , ( int ) $ outlineLevelRow ) ; $ outlineLevelCol = 0 ; foreach ( $ pSheet -> getColumnDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelCol ) { $ outlineLevelCol = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelCol' , ( int ) $ outlineLevelCol ) ; $ objWriter -> endElement ( ) ; }
5653	private function longestFlag ( $ flag_sets ) { $ longest = 0 ; foreach ( $ flag_sets as $ flags ) { foreach ( $ flags as $ flag ) { $ longest = max ( $ longest , strlen ( $ this -> renderFlag ( $ flag ) ) ) ; } } return $ longest ; }
11192	public function exists ( $ uri = false , $ httpMethod = false ) { if ( $ uri && $ httpMethod ) { $ this -> routeProcess ( $ uri , $ httpMethod ) ; } if ( ! isset ( $ this -> controllerPath ) ) { return false ; } return true ; }
11273	public function sendRequest ( RequestInterface $ request ) { $ this -> lastOperation = new Operation ( $ request ) ; $ response = parent :: sendRequest ( $ request ) ; $ this -> lastOperation -> setResponse ( $ response ) ; return $ response ; }
8460	public function exec ( $ command ) { fwrite ( $ this -> _fp , str_replace ( "\n" , '\n' , $ command ) . PHP_EOL ) ; $ answer = fgets ( $ this -> _fp ) ; if ( is_string ( $ answer ) ) { if ( substr ( $ answer , 0 , 7 ) === 'ANSWER ' ) { $ bytes = ( int ) substr ( $ answer , 7 ) ; if ( $ bytes > 0 ) { $ jsonObj = json_decode ( trim ( fread ( $ this -> _fp , $ bytes + 1 ) ) ) ; if ( is_null ( $ jsonObj ) ) { return 'You must enable the json flag on the telegram daemon to get proper response messages here.' ; } return $ jsonObj ; } } else { return $ answer ; } } return false ; }
1101	protected function parentId ( ) { switch ( $ this -> position ) { case 'root' : return NULL ; case 'child' : return $ this -> target -> getKey ( ) ; default : return $ this -> target -> getParentId ( ) ; } }
11280	public static function getErrorString ( int $ errno ) { $ errno = intval ( $ errno ) ; $ errors = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , ) ; $ errors [ 8192 ] = 'E_DEPRECATED' ; $ errors [ 16384 ] = 'E_USER_DEPRECATED' ; $ errors_desc = array ( ) ; foreach ( $ errors as $ key => $ value ) { if ( ( $ errno & $ key ) != 0 ) { $ errors_desc [ ] = $ value ; } } return implode ( '|' , $ errors_desc ) ; }
4539	public function setIndividualUuid ( ? string $ individualUuid ) { $ this -> individualUuid = $ individualUuid ; $ this -> _individualUuid = true ; return $ this ; }
6603	public function makeRequestToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateRequestTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'callback_confirmed' ] = ( isset ( $ params [ 'oauth_callback_confirmed' ] ) ) ? ( boolean ) $ params [ 'oauth_callback_confirmed' ] : null ; return $ this ; }
6220	public function authorize ( $ appId , $ appKey = null , $ credentials_or_service_id , $ usage = null ) { $ url = $ this -> getHost ( ) . "/transactions/authorize.xml" ; $ params = array ( 'app_id' => $ appId ) ; if ( $ credentials_or_service_id instanceof ThreeScaleClientCredentials ) { $ params [ 'service_token' ] = $ credentials_or_service_id -> service_token ; $ params [ 'service_id' ] = $ credentials_or_service_id -> service_id ; } else { $ params [ 'provider_key' ] = $ this -> getProviderKey ( ) ; $ params [ 'service_id' ] = $ credentials_or_service_id ; } if ( $ appKey ) { $ params [ 'app_key' ] = $ appKey ; } if ( $ usage ) { $ params [ 'usage' ] = $ usage ; } $ httpResponse = $ this -> httpClient -> get ( $ url , $ params ) ; if ( self :: isHttpSuccess ( $ httpResponse ) ) { return $ this -> buildAuthorizeResponse ( $ httpResponse -> body ) ; } else { return $ this -> processError ( $ httpResponse ) ; } }
2170	private function setPassword ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_password' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'password.html.twig' ) ; } $ password = $ request -> request -> get ( 'password' ) ; $ confirmation = $ request -> request -> get ( 'confirmation' ) ; if ( $ password !== $ confirmation ) { return $ this -> render ( 'password.html.twig' , [ 'error' => $ this -> trans ( 'password_confirmation_mismatch' ) , ] ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ minlength = $ installTool -> getConfig ( 'minPasswordLength' ) ; if ( Utf8 :: strlen ( $ password ) < $ minlength ) { return $ this -> render ( 'password.html.twig' , [ 'error' => sprintf ( $ this -> trans ( 'password_too_short' ) , $ minlength ) , ] ) ; } $ installTool -> persistConfig ( 'installPassword' , password_hash ( $ password , PASSWORD_DEFAULT ) ) ; $ this -> container -> get ( 'contao.install_tool_user' ) -> setAuthenticated ( true ) ; return $ this -> getRedirectResponse ( ) ; }
9301	public function setScheduleAhead ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`scheduleAhead` expects integer value!' ) ; } $ this -> options [ 'scheduleAhead' ] = ( int ) $ time ; return $ this ; }
6428	protected function getFacebookObject ( ) { if ( is_object ( $ this -> fb ) ) { return $ this -> fb ; } $ fb = new \ Facebook \ Facebook ( [ 'app_id' => $ this -> options [ 'api_key' ] , 'app_secret' => $ this -> options [ 'secret_key' ] , 'default_graph_version' => 'v3.0' , ] ) ; $ this -> fb = $ fb ; return $ fb ; }
5963	public function serverGroupGetProfiles ( ) { $ profiles = array ( ) ; foreach ( $ this -> serverGroupList ( ) as $ sgid => $ sgroup ) { if ( $ sgroup [ "type" ] != TeamSpeak3 :: GROUP_DBTYPE_REGULAR ) { continue ; } $ profiles [ $ sgid ] = array ( "b_permission_modify_power_ignore" => 0 , "i_group_needed_member_add_power" => 0 , "i_group_member_add_power" => 0 , "i_group_needed_member_remove_power" => 0 , "i_group_member_remove_power" => 0 , "i_needed_modify_power_count" => 0 , "i_needed_modify_power_total" => 0 , "i_permission_modify_power" => 0 , "i_group_needed_modify_power" => 0 , "i_group_modify_power" => 0 , "i_client_needed_modify_power" => 0 , "i_client_modify_power" => 0 , "b_virtualserver_servergroup_create" => 0 , "b_virtualserver_servergroup_delete" => 0 , "b_client_ignore_bans" => 0 , "b_client_ignore_antiflood" => 0 , "b_group_is_permanent" => 0 , "i_client_needed_ban_power" => 0 , "i_client_needed_kick_power" => 0 , "i_client_needed_move_power" => 0 , "i_client_talk_power" => 0 , "__sgid" => $ sgid , "__name" => $ sgroup -> toString ( ) , "__node" => $ sgroup , ) ; try { $ perms = $ this -> serverGroupPermList ( $ sgid , true ) ; $ grant = isset ( $ perms [ "i_permission_modify_power" ] ) ? $ perms [ "i_permission_modify_power" ] [ "permvalue" ] : null ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0x501 ) { throw $ e ; } $ perms = array ( ) ; $ grant = null ; } foreach ( $ perms as $ permsid => $ perm ) { if ( in_array ( $ permsid , array_keys ( $ profiles [ $ sgid ] ) ) ) { $ profiles [ $ sgid ] [ $ permsid ] = $ perm [ "permvalue" ] ; } elseif ( StringHelper :: factory ( $ permsid ) -> startsWith ( "i_needed_modify_power_" ) ) { if ( ! $ grant || $ perm [ "permvalue" ] > $ grant ) { continue ; } $ profiles [ $ sgid ] [ "i_needed_modify_power_total" ] = $ profiles [ $ sgid ] [ "i_needed_modify_power_total" ] + $ perm [ "permvalue" ] ; $ profiles [ $ sgid ] [ "i_needed_modify_power_count" ] ++ ; } } } array_multisort ( $ profiles , SORT_DESC ) ; return $ profiles ; }
184	public function init ( ) { parent :: init ( ) ; $ this -> cache = $ this -> enabled ? Instance :: ensure ( $ this -> cache , 'yii\caching\CacheInterface' ) : null ; if ( $ this -> cache instanceof CacheInterface && $ this -> getCachedContent ( ) === false ) { $ this -> getView ( ) -> pushDynamicContent ( $ this ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; } }
4608	public function createStatus ( string $ status , array $ options = null ) : array { $ url = '/statuses' ; if ( empty ( $ options ) ) { $ options = [ ] ; } $ params = array_merge ( [ 'status' => $ status , ] , $ options ) ; return $ this -> post ( $ url , $ params ) ; }
10625	protected function beforeBuild ( ) { $ this -> type = 'CREATE' ; if ( $ this -> temporary ) { $ this -> type .= ' TEMPORARY' ; } $ this -> type .= ' TABLE' ; if ( $ this -> if_not_exists ) { $ this -> type .= ' IF NOT EXISTS' ; } $ this -> type .= ' ' . $ this -> quote ( $ this -> tbl_name ) ; return ; }
10242	public static function getMatrixDimensions ( array & $ matrix ) { $ matrixRows = count ( $ matrix ) ; $ matrixColumns = 0 ; foreach ( $ matrix as $ rowKey => $ rowValue ) { if ( ! is_array ( $ rowValue ) ) { $ matrix [ $ rowKey ] = [ $ rowValue ] ; $ matrixColumns = max ( 1 , $ matrixColumns ) ; } else { $ matrix [ $ rowKey ] = array_values ( $ rowValue ) ; $ matrixColumns = max ( count ( $ rowValue ) , $ matrixColumns ) ; } } $ matrix = array_values ( $ matrix ) ; return [ $ matrixRows , $ matrixColumns ] ; }
182	protected function publishFile ( $ src ) { $ dir = $ this -> hash ( $ src ) ; $ fileName = basename ( $ src ) ; $ dstDir = $ this -> basePath . DIRECTORY_SEPARATOR . $ dir ; $ dstFile = $ dstDir . DIRECTORY_SEPARATOR . $ fileName ; if ( ! is_dir ( $ dstDir ) ) { FileHelper :: createDirectory ( $ dstDir , $ this -> dirMode , true ) ; } if ( $ this -> linkAssets ) { if ( ! is_file ( $ dstFile ) ) { try { symlink ( $ src , $ dstFile ) ; } catch ( \ Exception $ e ) { if ( ! is_file ( $ dstFile ) ) { throw $ e ; } } } } elseif ( @ filemtime ( $ dstFile ) < @ filemtime ( $ src ) ) { copy ( $ src , $ dstFile ) ; if ( $ this -> fileMode !== null ) { @ chmod ( $ dstFile , $ this -> fileMode ) ; } } if ( $ this -> appendTimestamp && ( $ timestamp = @ filemtime ( $ dstFile ) ) > 0 ) { $ fileName = $ fileName . "?v=$timestamp" ; } return [ $ dstFile , $ this -> baseUrl . "/$dir/$fileName" ] ; }
12131	public function handle ( ) { $ view = $ this -> application -> createInstance ( "view" , [ $ this -> application -> response , $ this -> application -> createInstance ( "viewengine" , [ $ this -> application -> response ] ) , $ this -> application ] ) ; $ view -> setData ( "title" , "An Error Occured" ) ; $ this -> application -> response -> send ( $ view -> render ( "errors/error" ) ) ; return Handler :: LAST_HANDLER ; }
7875	protected function settleRepositoryIfNotExists ( ) { $ source = $ this -> pipelines -> getSource ( ) ; if ( ! $ this -> files -> exists ( $ source ) ) { $ this -> pipelines -> settle ( ) ; } }
12343	public function newAction ( Request $ request ) { $ post = new Post ( ) ; $ form = $ this -> createForm ( 'BlogBundle\Form\PostType' , $ post , array ( 'translator' => $ this -> get ( 'translator' ) ) ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ user = $ this -> container -> get ( 'security.token_storage' ) -> getToken ( ) -> getUser ( ) ; $ post -> setActor ( $ user ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ post ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'post.created' ) ; return $ this -> redirectToRoute ( 'blog_post_index' ) ; } return array ( 'category' => $ post , 'form' => $ form -> createView ( ) , ) ; }
2279	public static function get ( $ strKey ) { if ( isset ( static :: $ arrCache [ $ strKey ] ) ) { return static :: $ arrCache [ $ strKey ] ; } if ( \ in_array ( $ strKey , get_class_methods ( __CLASS__ ) ) ) { static :: $ arrCache [ $ strKey ] = static :: $ strKey ( ) ; } else { $ arrChunks = preg_split ( '/([A-Z][a-z]*)/' , $ strKey , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; $ strServerKey = strtoupper ( implode ( '_' , $ arrChunks ) ) ; static :: $ arrCache [ $ strKey ] = $ _SERVER [ $ strServerKey ] ; } return static :: $ arrCache [ $ strKey ] ; }
2566	protected function checkAnyNotEmpty ( ) { $ foundNotEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! empty ( $ arg ) ) { $ foundNotEmpty = true ; break ; } } return $ foundNotEmpty ; }
3320	public function getValidValues ( ) { if ( $ this -> validValues ) { if ( is_callable ( $ this -> validValues ) ) { return call_user_func ( $ this -> validValues ) ; } return $ this -> validValues ; } return ; }
2940	public static function addUnit ( UnitOfMeasureInterface $ unit ) { if ( static :: unitNameOrAliasesAlreadyRegistered ( $ unit ) ) { throw new Exception \ DuplicateUnitNameOrAlias ( [ ':labels' => implode ( ', ' , array_merge ( [ $ unit -> getName ( ) ] , $ unit -> getAliases ( ) ) ) ] ) ; } static :: $ unitDefinitions [ ] = $ unit ; }
7531	function toString ( $ attributes = true , $ recursive = true , $ content_only = false ) { if ( $ content_only ) { if ( is_int ( $ content_only ) ) { -- $ content_only ; } return $ this -> toString_content ( $ attributes , $ recursive , $ content_only ) ; } $ s = '<' . $ this -> tag ; if ( $ attributes ) { $ s .= $ this -> toString_attributes ( ) ; } if ( $ this -> self_close ) { $ s .= $ this -> self_close_str . '>' ; } else { $ s .= '>' ; if ( $ recursive ) { $ s .= $ this -> toString_content ( $ attributes ) ; } $ s .= '</' . $ this -> tag . '>' ; } return $ s ; }
5658	private function addWidgetToForm ( $ node , $ form , $ enclosing_label ) { $ widget = $ this -> tags ( ) -> createTag ( $ node -> name , $ this -> attributes ( $ node ) ) ; if ( ! $ widget ) { return ; } $ widget -> setLabel ( $ enclosing_label ) -> addContent ( $ this -> innerHtml ( $ node ) ) ; if ( $ node -> name == 'select' ) { $ widget -> addTags ( $ this -> collectSelectOptions ( $ node ) ) ; } $ form -> addWidget ( $ widget ) ; $ this -> indexWidgetById ( $ widget ) ; }
1822	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> imageSizes ) || ! \ is_array ( $ this -> User -> imageSizes ) ) { $ imageSizes = array ( ) ; } else { $ imageSizes = $ this -> User -> imageSizes ; } if ( \ in_array ( $ insertId , $ imageSizes ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_image_size' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_image_size' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, themes, imageSizes FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrThemes = Contao \ StringUtil :: deserialize ( $ objGroup -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objGroup -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT themes, imageSizes FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrThemes = Contao \ StringUtil :: deserialize ( $ objUser -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objUser -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ this -> User -> id ) ; } } $ imageSizes [ ] = $ insertId ; $ this -> User -> imageSizes = $ imageSizes ; } }
3480	public function withLaunchImage ( string $ launchImage ) : Alert { $ cloned = clone $ this ; $ cloned -> launchImage = $ launchImage ; return $ cloned ; }
1530	public function resource ( string $ resourceType , array $ options = [ ] ) : ResourceRegistration { return new ResourceRegistration ( $ this -> router , $ resourceType , array_merge ( $ this -> options , $ options ) ) ; }
3089	protected function alterTimeoutCallValue ( array $ options ) { $ timeoutValue = null ; if ( $ this -> isInitialCall === true ) { if ( $ this -> hasOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ; } } else { if ( $ this -> hasOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ; } } if ( ! is_null ( $ timeoutValue ) ) { $ options [ self :: OPTION_ENGINE_CLIENT ] [ 'options' ] [ 'http_client_options' ] [ 'timeout' ] = $ timeoutValue ; } return $ options ; }
1007	public static function isValidNameError ( $ name , $ node = null ) { self :: invariant ( is_string ( $ name ) , 'Expected string' ) ; if ( isset ( $ name [ 1 ] ) && $ name [ 0 ] === '_' && $ name [ 1 ] === '_' ) { return new Error ( sprintf ( 'Name "%s" must not begin with "__", which is reserved by ' , $ name ) . 'GraphQL introspection.' , $ node ) ; } if ( ! preg_match ( '/^[_a-zA-Z][_a-zA-Z0-9]*$/' , $ name ) ) { return new Error ( sprintf ( 'Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "%s" does not.' , $ name ) , $ node ) ; } return null ; }
5115	public function submitArticle ( Article $ article ) : \ One \ Model \ Article { $ responseArticle = $ this -> post ( self :: ARTICLE_ENDPOINT , $ this -> normalizePayload ( $ article -> getCollection ( ) ) ) ; $ responseArticle = json_decode ( $ responseArticle , true ) ; $ article -> setId ( ( string ) $ responseArticle [ 'data' ] [ 'id' ] ) ; foreach ( $ article -> getPossibleAttachment ( ) as $ field ) { if ( $ article -> hasAttachment ( $ field ) ) { foreach ( $ article -> getAttachmentByField ( $ field ) as $ attachment ) { $ this -> submitAttachment ( $ article -> getId ( ) , $ attachment , $ field ) ; } } } return $ article ; }
10203	public function setVertical ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: VERTICAL_BOTTOM ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'vertical' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> vertical = $ pValue ; } return $ this ; }
11895	public function decrypt ( $ data ) { if ( ! is_string ( $ data ) || ! preg_match ( '/^[0-9A-Fa-f]*$/' , $ data ) ) { throw new \ InvalidArgumentException ( 'blowfishDecryptCBC require hex input' , 1502 ) ; } $ data = pack ( 'H*' , $ data ) ; if ( $ this -> iv === null ) { $ return = mcrypt_decrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode ) ; } else { $ return = mcrypt_decrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode , $ this -> iv ) ; } return rtrim ( $ return , "\0" ) ; }
110	public function loadInstalledPlugins ( ) { if ( $ this -> disablePlugins ) { return ; } $ repo = $ this -> composer -> getRepositoryManager ( ) -> getLocalRepository ( ) ; $ globalRepo = $ this -> globalComposer ? $ this -> globalComposer -> getRepositoryManager ( ) -> getLocalRepository ( ) : null ; if ( $ repo ) { $ this -> loadRepository ( $ repo ) ; } if ( $ globalRepo ) { $ this -> loadRepository ( $ globalRepo ) ; } }
11329	public function getHuman ( ) { if ( is_null ( $ this -> _human ) ) { $ this -> _human = HumanFieldDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _human ; }
12553	public function save ( $ path , $ name = null ) { if ( ! file_exists ( $ path ) ) { mkdir ( $ path , 0777 , true ) ; } $ destinationPath = rtrim ( $ path , '/' ) ; if ( $ name ) { $ destinationPath .= '/' . $ name ; } else { $ destinationPath .= '/' . $ this -> name ; } if ( ! copy ( $ this -> tmpName , $ destinationPath ) ) { $ reason = 'Unknown' ; if ( ! file_exists ( $ path ) ) { $ reason = 'Path "' . $ path . '" not exists.' ; } else if ( ! is_writeable ( $ path ) ) $ reason = 'Path "' . $ path . '" required permission to write.' ; throw new FileFailSavedException ( $ reason ) ; } }
6131	protected function getSuffixIconServer ( ) { $ html = "" ; if ( $ this -> currObj [ "virtualserver_icon_id" ] ) { if ( ! $ this -> currObj -> iconIsLocal ( "virtualserver_icon_id" ) && $ this -> ftclient ) { if ( ! isset ( $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] ) ) { $ download = $ this -> currObj -> transferInitDownload ( rand ( 0x0000 , 0xFFFF ) , 0 , $ this -> currObj -> iconGetName ( "virtualserver_icon_id" ) ) ; if ( $ this -> ftclient == "data:image" ) { $ download = TeamSpeak3 :: factory ( "filetransfer://" . $ download [ "host" ] . ":" . $ download [ "port" ] ) -> download ( $ download [ "ftkey" ] , $ download [ "size" ] ) ; } $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] = $ download ; } else { $ download = $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] ; } if ( $ this -> ftclient == "data:image" ) { $ html .= $ this -> getImage ( "data:" . Convert :: imageMimeType ( $ download ) . ";base64," . base64_encode ( $ download ) , "Server Icon" , null , false ) ; } else { $ html .= $ this -> getImage ( $ this -> ftclient . "?ftdata=" . base64_encode ( serialize ( $ download ) ) , "Server Icon" , null , false ) ; } } elseif ( in_array ( $ this -> currObj [ "virtualserver_icon_id" ] , $ this -> cachedIcons ) ) { $ html .= $ this -> getImage ( "group_icon_" . $ this -> currObj [ "virtualserver_icon_id" ] . ".png" , "Server Icon" ) ; } } return $ html ; }
9757	function below ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , lessThan ( $ value ) ) ; }
1372	protected function isFillable ( $ field , $ record ) { if ( in_array ( $ field , $ fillable = $ this -> getFillable ( $ record ) ) ) { return true ; } if ( $ this -> isGuarded ( $ field , $ record ) ) { return false ; } return empty ( $ fillable ) ; }
3266	public function getPath ( ) : string { return $ this -> config -> getDir ( ) . $ this -> getName ( ) . $ this -> config -> getExt ( ) ; }
7123	protected function updateTicket ( TicketMessageInterface $ message ) { $ ticket = $ message -> getTicket ( ) -> setUpdatedAt ( new \ DateTime ( ) ) ; if ( $ message -> isLatest ( ) && ( $ ticket -> getState ( ) !== TicketStates :: STATE_CLOSED ) ) { if ( $ message -> isCustomer ( ) ) { if ( $ ticket -> getState ( ) === TicketStates :: STATE_PENDING ) { $ ticket -> setState ( TicketStates :: STATE_OPENED ) ; } } elseif ( $ ticket -> getState ( ) === TicketStates :: STATE_OPENED ) { $ ticket -> setState ( TicketStates :: STATE_PENDING ) ; } } $ this -> persistenceHelper -> persistAndRecompute ( $ ticket , false ) ; }
6606	public function validateAccessTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'access token' ) ; } return true ; }
9847	public function createSealedResponse ( int $ status , string $ body , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: seal ( $ body , $ key ) ) ) ) ; }
8500	protected function setSSLCurlOptions ( $ ch ) { curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , $ this -> _config [ 'SSL_VerifyPeer' ] ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , $ this -> _config [ 'SSL_VerifyHost' ] ) ; }
8541	public function compile ( ) { if ( ! count ( $ this -> msgid ) ) return "" ; $ str = "" ; if ( $ this -> comments ) $ str .= implode ( self :: NEWLINE , $ this -> comments ) . self :: NEWLINE ; if ( $ this -> msgctxt ) $ str .= 'msgctxt "' . $ this -> msgctxt . '"' . self :: NEWLINE ; $ included_blocks = [ 'msgid' ] ; if ( $ this -> msgstr_plural ) $ included_blocks [ ] = 'msgid_plural' ; else $ included_blocks [ ] = 'msgstr' ; foreach ( $ included_blocks as $ key ) { if ( is_array ( $ this -> $ key ) ) { $ str .= "$key " ; $ str .= implode ( self :: NEWLINE , array_map ( [ $ this , 'quoteWrap' ] , $ this -> $ key ) ) . self :: NEWLINE ; } } if ( $ this -> msgid_plural && $ this -> msgstr_plural ) { foreach ( $ this -> msgstr_plural as $ plural_key => $ plural_message ) { $ str .= 'msgstr[' . $ plural_key . '] ' ; $ str .= implode ( self :: NEWLINE , array_map ( [ $ this , 'quoteWrap' ] , $ plural_message ) ) . self :: NEWLINE ; } } return trim ( $ str ) ; }
953	public function authenticate ( AuthShop $ request ) { $ validated = $ request -> validated ( ) ; $ shopDomain = ShopifyApp :: sanitizeShopDomain ( $ validated [ 'shop' ] ) ; $ shop = ShopifyApp :: shop ( $ shopDomain ) ; $ auth = new AuthShopHandler ( $ shop ) ; $ session = new ShopSession ( $ shop ) ; if ( ! $ request -> has ( 'code' ) ) { $ authUrl = $ auth -> buildAuthUrl ( $ shop -> hasOfflineAccess ( ) ? Config :: get ( 'shopify-app.api_grant_mode' ) : ShopSession :: GRANT_OFFLINE ) ; return View :: make ( 'shopify-app::auth.fullpage_redirect' , compact ( 'authUrl' , 'shopDomain' ) ) ; } $ access = $ auth -> getAccess ( $ validated [ 'code' ] ) ; $ session -> setDomain ( $ shopDomain ) ; $ session -> setAccess ( $ access ) ; $ auth -> postProcess ( ) ; $ auth -> dispatchJobs ( $ session ) ; return $ this -> returnTo ( ) ; }
6709	protected function useActualParameters ( ) { $ this -> setParameters ( $ this -> urlToParameters ( $ this -> getRequestedUri ( ) ) ) ; $ this -> setParameters ( $ _REQUEST ) ; $ this -> setParameters ( $ this -> parseHeader ( $ _SERVER ) ) ; $ this -> setParameters ( $ this -> stringToArray ( $ this -> readBody ( ) ) ) ; return $ this -> getParameters ( ) ; }
12585	static function run_convert_configuration ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ extname = @ $ args [ 0 ] ; if ( $ extname == '' ) { $ extname = dirname ( __FILE__ ) ; } while ( ! is_file ( "ant/$extname.properties" ) ) { $ extname = pake_input ( 'What is the name of the current extension?' ) ; if ( ! is_file ( "ant/$extname.properties" ) ) { pake_echo ( "File ant/$extname.properties not found" ) ; } } self :: convertPropertyFileToYamlFile ( "ant/$extname.properties" , self :: getConfigDir ( ) . "/options-$extname.yaml" , array ( $ extname => '' , 'external' => 'dependencies' , 'dependency' => 'extensions' , 'repository' => array ( 'svn' , 'url' ) ) , "extension:\n name: $extname\n\n" ) ; foreach ( array ( 'files.to.parse.txt' => 'to_parse' , 'files.to.exclude.txt' => 'to_exclude' ) as $ file => $ option ) { $ src = "ant/$file" ; if ( file_exists ( $ src ) ) { if ( count ( $ in = file ( $ src , FILE_SKIP_EMPTY_LINES | FILE_IGNORE_NEW_LINES ) ) ) { $ in = "\n\nfiles:\n $option: [" . implode ( ', ' , $ in ) . "]\n" ; file_put_contents ( self :: getConfigDir ( ) . "options-$extname.yaml" , $ in , FILE_APPEND ) ; } } } }
9418	public function f ( $ x ) { if ( ! is_numeric ( $ x ) ) { throw new \ InvalidArgumentException ( 'x variable must be numeric value.' ) ; } $ float_fx = exp ( - 0.5 * pow ( ( $ x - $ this -> float_mu ) / $ this -> float_sigma , 2 ) ) / ( $ this -> float_sigma * sqrt ( 2 * pi ( ) ) ) ; if ( $ this -> int_precision ) { return round ( $ float_fx , $ this -> int_precision ) ; } return $ float_fx ; }
7967	public function setProperties ( $ billingAccount , $ properties ) { if ( ! $ billingAccount ) throw new BadMethodCallException ( 'Parameter $billingAccount is missing.' ) ; if ( ! $ properties ) throw new BadMethodCallException ( 'Parameter $properties is missing.' ) ; if ( ! is_array ( $ properties ) ) throw new BadMethodCallException ( 'Parameter $properties must be a array.' ) ; $ t = array ( ) ; if ( array_key_exists ( 'description' , $ properties ) ) $ t [ 'description' ] = $ properties [ 'description' ] ; $ properties = $ t ; unset ( $ t ) ; if ( count ( $ properties ) == 0 ) throw new BadMethodCallException ( 'Parameter $properties does not contain valid key. valid key is "description"' ) ; try { $ r = $ this -> put ( 'telephony/' . $ billingAccount , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ properties ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new TelephonyException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return true ; }
5229	public static function forName ( $ name ) { $ enum = new \ ReflectionClass ( get_called_class ( ) ) ; try { return $ enum -> getStaticPropertyValue ( $ name ) ; } catch ( \ ReflectionException $ re ) { throw new \ InvalidArgumentException ( $ re -> getMessage ( ) ) ; } }
5470	protected function describePatternMatch ( $ pattern , $ subject ) { preg_match ( $ pattern , $ subject , $ matches ) ; $ position = strpos ( $ subject , $ matches [ 0 ] ) ; $ dumper = $ this -> getDumper ( ) ; return "Pattern [$pattern] detected at character [$position] in [" . $ dumper -> describeValue ( $ subject ) . '] as [' . $ matches [ 0 ] . '] in region [' . $ dumper -> clipString ( $ subject , 100 , $ position ) . ']' ; }
2516	public function pnrCreatePnr ( RequestOptions \ PnrCreatePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
5582	public function clickLink ( $ label , $ index = 0 ) { $ url = $ this -> getLink ( $ label , $ index ) ; if ( $ url === false ) { return false ; } $ this -> load ( $ url , new SimpleGetEncoding ( ) ) ; return ( bool ) $ this -> getContent ( ) ; }
12883	public function getUnmappedLocalKeys ( ) { $ u = array_diff ( array_keys ( $ this -> localModel -> getMetaData ( ) -> columns ) , array_keys ( $ this -> _map ) ) ; unset ( $ u [ $ this -> localPrimaryKeyName ] ) ; return $ u ; }
2118	public function generateSqlForm ( ) { @ trigger_error ( 'Using the Installer::generateSqlForm() method has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ count = 0 ; $ return = '' ; $ sql_command = $ this -> compileCommands ( ) ; if ( empty ( $ sql_command ) ) { return '' ; } $ _SESSION [ 'sql_commands' ] = array ( ) ; $ arrOperations = array ( 'CREATE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'CREATE' ] , 'ALTER_ADD' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_ADD' ] , 'ALTER_CHANGE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_CHANGE' ] , 'ALTER_DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_DROP' ] , 'DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'DROP' ] ) ; foreach ( $ arrOperations as $ command => $ label ) { if ( \ is_array ( $ sql_command [ $ command ] ) ) { $ return .= ' <tr> <td colspan="2" class="tl_col_0">' . $ label . '</td> </tr>' ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" id="check_all_' . $ count . '" class="tl_checkbox" onclick="Backend.toggleCheckboxElements(this, \'' . strtolower ( $ command ) . '\')"></td> <td class="tl_col_2"><label for="check_all_' . $ count . '" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label></td> </tr>' ; foreach ( $ sql_command [ $ command ] as $ vv ) { $ key = md5 ( $ vv ) ; $ _SESSION [ 'sql_commands' ] [ $ key ] = $ vv ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" name="sql[]" id="sql_' . $ count . '" class="tl_checkbox ' . strtolower ( $ command ) . '" value="' . $ key . '"' . ( ( stripos ( $ command , 'DROP' ) === false ) ? ' checked="checked"' : '' ) . '></td> <td class="tl_col_2"><pre><label for="sql_' . $ count ++ . '">' . $ vv . '</label></pre></td> </tr>' ; } } } return '<div id="sql_wrapper"> <table id="sql_table">' . $ return . ' </table></div>' ; }
10887	public function getSession ( $ sessionId ) { return tap ( $ this -> manager -> driver ( ) , function ( $ session ) use ( $ sessionId ) { $ session -> setId ( $ sessionId ) ; } ) ; }
6904	public function runWild ( ) { foreach ( $ this -> handlers as $ handler ) { $ rtn = $ handler instanceof Closure ? $ this -> context -> call ( $ handler , $ this -> req ) : $ this -> context -> callInClass ( $ handler , $ this -> action , $ this -> req ) ; if ( ! is_null ( $ rtn ) ) return $ rtn ; } return null ; }
12493	public static function groupBy ( $ field ) { if ( ! ( gettype ( $ field ) == "string" || $ field instanceof Key || $ field instanceof Raw ) ) { throw new ClusterpointException ( "\"->group()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } return "{$field}" ; }
11953	public function deleteFromDB ( ) { if ( ! $ this -> isValid ( ) ) { return false ; } if ( count ( $ this -> key_properties ) == 0 ) { return false ; } $ where_part = '' ; foreach ( $ this -> key_properties as $ key ) { if ( $ where_part ) { $ where_part .= ' AND ' ; } if ( $ this -> { $ key } instanceof Web2All_Table_SQLOperation ) { trigger_error ( 'Web2All_Table_SaveObjectTrait->deleteFromDB(): using Web2All_Table_SQLOperation object for key value ' . $ key , E_USER_NOTICE ) ; $ where_part .= $ this -> obj_to_db_trans [ $ key ] . '=' . $ this -> { $ key } -> toSQLString ( ) ; } else if ( $ this -> { $ key } instanceof Web2All_Table_SQLOperationList ) { throw new Exception ( "Web2All_Table_SaveObjectTrait: can't delete using a Web2All_Table_SQLOperationList for key value " . $ key ) ; } else { $ where_part .= $ this -> obj_to_db_trans [ $ key ] . '=' . $ this -> db -> Quote ( $ this -> { $ key } ) ; } } $ this -> db -> Execute ( 'DELETE FROM ' . $ this -> quote ( $ this -> tablename ) . ' WHERE ' . $ where_part . ' ' ) ; return true ; }
10551	public function determineVirtualHost ( ) { $ cfg = $ this -> config -> getSection ( 'site' ) ; $ vhost = self :: findVirtualHost ( $ this -> request -> webroot , $ this -> sites ) ; if ( $ vhost === null ) { $ result = $ this -> handleUnknownHost ( $ this -> request -> webroot , $ this -> request -> url , $ this -> sites , $ cfg ) ; if ( $ result === null ) throw new HTTPError ( 404 , "Not found: " . $ this -> url ) ; if ( $ result instanceof URL ) throw new RedirectRequest ( $ result , 301 ) ; if ( $ result instanceof VirtualHost ) { $ vhost = $ result ; $ site = $ vhost -> getSite ( ) ; if ( isset ( $ this -> sites [ $ site -> getName ( ) ] ) ) $ this -> sites [ $ site -> getName ( ) ] = $ site ; } else throw \ RuntimeException ( "Unexpected response from handleUnknownWebsite" ) ; } else { $ target = $ vhost -> getRedirect ( $ this -> request -> url ) ; if ( $ target ) throw new RedirectRequest ( $ target , 301 ) ; } $ this -> setVirtualHost ( $ vhost ) ; return $ this ; }
8354	private function buildEnum ( string $ enumName , array $ enumDefinition ) { $ mapping = Mapping :: get ( $ this -> mapping ) ; $ definition = $ this -> getDefinition ( ) ; $ database = GlobalDatabase :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ enumRealName = null ; if ( isset ( $ enumDefinition [ 'name' ] ) === true ) { $ enumRealName = $ enumDefinition [ 'name' ] ; } else { $ enumRealName = Helper :: codifyName ( $ this -> mapping ) . '_' . Helper :: codifyName ( $ enumName ) ; } if ( isset ( $ enumDefinition [ 'values' ] ) === false ) { throw new InvalidSchemaDefinition ( 'enum "' . $ enumName . '" has no value' ) ; } $ values = array ( ) ; foreach ( $ enumDefinition [ 'values' ] as $ valueName => $ valueAlias ) { $ valueRealName = null ; if ( is_string ( $ valueName ) === true ) { $ valueRealName = $ valueName ; } else { $ valueRealName = Helper :: codifyName ( $ enumName ) . '_' . Helper :: codifyName ( $ valueAlias ) ; } $ values [ ] = $ valueRealName ; } $ statement = Mutation \ AddEnum :: statement ( $ database , $ enumRealName , $ values ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } echo $ enumName . ' - Done' . PHP_EOL ; }
5466	public function setIdentityForRealm ( $ host , $ realm , $ username , $ password ) { if ( isset ( $ this -> realms [ $ host ] [ $ realm ] ) ) { $ this -> realms [ $ host ] [ $ realm ] -> setIdentity ( $ username , $ password ) ; } }
9135	public static function parseUrl ( $ url ) : Url { $ parts = parse_url ( $ url ) ; if ( false === $ parts || false === Arrays :: hasElement ( $ parts , 'host' ) || false === Arrays :: hasElement ( $ parts , 'scheme' ) ) { throw new InvalidUrlException ( 'The URL {url} does not contain necessary parts' , array ( 'url' => $ url ) ) ; } $ address = $ parts [ 'host' ] ; $ scheme = $ parts [ 'scheme' ] ; $ query = ( isset ( $ parts [ 'query' ] ) ? $ parts [ 'query' ] : '' ) ; $ port = 0 ; $ path = "/" ; if ( isset ( $ parts [ 'port' ] ) ) { $ port = intval ( $ parts [ 'port' ] ) ; } if ( $ port == 0 ) { $ port = self :: getPortByScheme ( $ scheme ) ; } if ( isset ( $ parts [ 'path' ] ) ) { $ path = $ parts [ 'path' ] ; } return new Url ( $ address , $ port , $ path , $ scheme , $ query ) ; }
11612	protected function _resolveContainer ( BaseContainerInterface $ container ) { $ parent = null ; while ( $ container instanceof ContainerAwareInterface ) { $ parent = $ container -> getContainer ( ) ; if ( ! ( $ parent instanceof BaseContainerInterface ) ) { break ; } $ container = $ parent ; } return $ container ; }
10062	public function update ( $ key , $ value ) { try { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> firstOrFail ( ) ; } catch ( \ Exception $ e ) { $ message = "Can't update meta (key: $key). " ; $ message .= "Meta doesn't exist" ; throw new \ Exception ( $ message ) ; } $ meta -> value = $ value ; $ meta -> save ( ) ; }
5035	public function setFrom ( $ email , $ name = null ) { if ( is_array ( $ email ) ) { $ this -> from = [ $ email [ 'email' ] => $ email [ 'name' ] ] ; } else { $ this -> from = is_object ( $ email ) || null === $ name ? $ email : array ( $ email => $ name ) ; } return $ this ; }
1182	protected function jsValidator ( Validator $ validator , $ selector = null ) { $ remote = ! $ this -> options [ 'disable_remote_validation' ] ; $ view = $ this -> options [ 'view' ] ; $ selector = is_null ( $ selector ) ? $ this -> options [ 'form_selector' ] : $ selector ; $ delegated = new DelegatedValidator ( $ validator , new ValidationRuleParserProxy ( ) ) ; $ rules = new RuleParser ( $ delegated , $ this -> getSessionToken ( ) ) ; $ messages = new MessageParser ( $ delegated ) ; $ jsValidator = new ValidatorHandler ( $ rules , $ messages ) ; $ manager = new JavascriptValidator ( $ jsValidator , compact ( 'view' , 'selector' , 'remote' ) ) ; return $ manager ; }
12527	public function getDataSources ( ) { if ( is_null ( $ this -> _dataSources ) ) { $ this -> _dataSources = [ ] ; foreach ( $ this -> dataSources ( ) as $ foreignModel => $ dataSource ) { if ( is_numeric ( $ foreignModel ) || isset ( $ dataSources [ 'foreignModel' ] ) ) { if ( ! isset ( $ dataSources [ 'foreignModel' ] ) ) { continue ; } $ foreignModel = $ dataSources [ 'foreignModel' ] ; unset ( $ dataSources [ 'foreignModel' ] ) ; } if ( ! isset ( $ dataSource [ 'class' ] ) ) { $ dataSource [ 'class' ] = $ this -> dataSourceClass ; } $ dataSource [ 'name' ] = $ foreignModel ; $ dataSource [ 'foreignModel' ] = $ this -> getForeignModel ( $ foreignModel ) ; if ( empty ( $ dataSource [ 'foreignModel' ] ) ) { continue ; } $ this -> _dataSources [ $ foreignModel ] = Yii :: createObject ( array_merge ( [ 'module' => $ this ] , $ dataSource ) ) ; } } return $ this -> _dataSources ; }
837	public static function detectBlockType ( Token $ token ) { foreach ( self :: getBlockEdgeDefinitions ( ) as $ type => $ definition ) { if ( $ token -> equals ( $ definition [ 'start' ] ) ) { return [ 'type' => $ type , 'isStart' => true ] ; } if ( $ token -> equals ( $ definition [ 'end' ] ) ) { return [ 'type' => $ type , 'isStart' => false ] ; } } }
2054	protected function getConfigurationItem ( $ imageSize ) { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; $ mode = $ imageSize -> resizeMode ; if ( substr_count ( $ mode , '_' ) === 1 ) { $ importantPart = $ this -> image -> setImportantPart ( null ) -> getImportantPart ( ) ; $ mode = explode ( '_' , $ mode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } $ this -> image -> setImportantPart ( $ importantPart ) ; $ mode = ResizeConfiguration :: MODE_CROP ; } $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setZoomLevel ( $ imageSize -> zoom ) ; if ( $ mode ) { $ resizeConfig -> setMode ( $ mode ) ; } $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( isset ( $ imageSize -> sizes ) ) { $ configItem -> setSizes ( $ imageSize -> sizes ) ; } if ( isset ( $ imageSize -> densities ) ) { $ configItem -> setDensities ( $ imageSize -> densities ) ; } if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } return $ configItem ; }
12115	public static function getExceptionTree ( \ Throwable $ Throwable ) { $ exception = get_class ( $ Throwable ) ; for ( $ exception_tree [ ] = $ exception ; $ exception = get_parent_class ( $ exception ) ; $ exception_tree [ ] = $ exception ) { ; } $ exception_tree = array_reverse ( $ exception_tree ) ; if ( count ( $ exception_tree ) > 1 ) { array_shift ( $ exception_tree ) ; } return $ exception_tree ; }
9488	public function getPages ( ) { if ( $ this -> getPageRange ( ) > $ this -> getPagesCount ( ) ) { $ this -> setPageRange ( $ this -> getPagesCount ( ) ) ; } $ delta = ceil ( $ this -> getPageRange ( ) / 2 ) ; if ( $ this -> getCurrentPageNumber ( ) - $ delta > $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) ) { $ pages = range ( $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) + 1 , $ this -> getPagesCount ( ) ) ; } else { if ( $ this -> getCurrentPageNumber ( ) - $ delta < 0 ) { $ delta = $ this -> getCurrentPageNumber ( ) ; } $ offset = $ this -> getCurrentPageNumber ( ) - $ delta ; $ pages = range ( $ offset + 1 , $ offset + $ this -> getPageRange ( ) ) ; } return $ pages ; }
402	public static function process ( $ content , $ config = null ) { $ configInstance = \ HTMLPurifier_Config :: create ( $ config instanceof \ Closure ? null : $ config ) ; $ configInstance -> autoFinalize = false ; $ purifier = \ HTMLPurifier :: instance ( $ configInstance ) ; $ purifier -> config -> set ( 'Cache.SerializerPath' , \ Yii :: $ app -> getRuntimePath ( ) ) ; $ purifier -> config -> set ( 'Cache.SerializerPermissions' , 0775 ) ; static :: configure ( $ configInstance ) ; if ( $ config instanceof \ Closure ) { call_user_func ( $ config , $ configInstance ) ; } return $ purifier -> purify ( $ content ) ; }
3549	protected function registerRepository ( ) { $ this -> app -> singleton ( CachingRepository :: class , function ( Container $ app ) { $ repo = new GitHubRepository ( GuzzleFactory :: make ( ) , $ app -> config -> get ( 'emoji.token' ) ) ; $ cache = $ app -> cache -> store ( $ app -> config -> get ( 'emoji.connection' ) ) ; $ key = $ app -> config -> get ( 'emoji.key' , 'emoji' ) ; $ life = ( int ) $ app -> config -> get ( 'emoji.life' , 10080 ) ; return new CachingRepository ( $ repo , $ cache , $ key , $ life ) ; } ) ; $ this -> app -> alias ( CachingRepository :: class , RepositoryInterface :: class ) ; }
99	public function addPsr4 ( $ prefix , $ paths , $ prepend = false ) { if ( ! $ prefix ) { if ( $ prepend ) { $ this -> fallbackDirsPsr4 = array_merge ( ( array ) $ paths , $ this -> fallbackDirsPsr4 ) ; } else { $ this -> fallbackDirsPsr4 = array_merge ( $ this -> fallbackDirsPsr4 , ( array ) $ paths ) ; } } elseif ( ! isset ( $ this -> prefixDirsPsr4 [ $ prefix ] ) ) { $ length = strlen ( $ prefix ) ; if ( '\\' !== $ prefix [ $ length - 1 ] ) { throw new \ InvalidArgumentException ( "A non-empty PSR-4 prefix must end with a namespace separator." ) ; } $ this -> prefixLengthsPsr4 [ $ prefix [ 0 ] ] [ $ prefix ] = $ length ; $ this -> prefixDirsPsr4 [ $ prefix ] = ( array ) $ paths ; } elseif ( $ prepend ) { $ this -> prefixDirsPsr4 [ $ prefix ] = array_merge ( ( array ) $ paths , $ this -> prefixDirsPsr4 [ $ prefix ] ) ; } else { $ this -> prefixDirsPsr4 [ $ prefix ] = array_merge ( $ this -> prefixDirsPsr4 [ $ prefix ] , ( array ) $ paths ) ; } }
6634	public function parseProfileResponse ( Response $ response , AccessTokenInterface $ access_token ) { $ profile = $ response -> json ( ) ; if ( gettype ( $ profile ) !== 'object' ) { throw new InvalidProfileException ( ) ; } if ( isset ( $ profile -> error ) ) { $ error = $ profile -> error ; throw new InvalidProfileException ( $ error -> type . ': ' . $ error -> message , $ error -> code ) ; } $ profile -> access_token = $ access_token -> token ( ) ; return $ this -> profile -> instantiate ( $ profile , $ this -> name ) ; }
9618	public function registerStackMiddleware ( $ class ) { if ( func_num_args ( ) === 0 ) { throw new \ InvalidArgumentException ( "Missing argument(s) when calling registerStackMiddlerware" ) ; } if ( ! class_exists ( $ class ) && ! is_callable ( $ class ) ) { throw new \ InvalidArgumentException ( "{$class} not found or not callable" ) ; } call_user_func_array ( [ $ this -> builder , "push" ] , func_get_args ( ) ) ; }
384	protected function validateImage ( $ image ) { if ( false === ( $ imageInfo = getimagesize ( $ image -> tempName ) ) ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } list ( $ width , $ height ) = $ imageInfo ; if ( $ width == 0 || $ height == 0 ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } if ( $ this -> minWidth !== null && $ width < $ this -> minWidth ) { return [ $ this -> underWidth , [ 'file' => $ image -> name , 'limit' => $ this -> minWidth ] ] ; } if ( $ this -> minHeight !== null && $ height < $ this -> minHeight ) { return [ $ this -> underHeight , [ 'file' => $ image -> name , 'limit' => $ this -> minHeight ] ] ; } if ( $ this -> maxWidth !== null && $ width > $ this -> maxWidth ) { return [ $ this -> overWidth , [ 'file' => $ image -> name , 'limit' => $ this -> maxWidth ] ] ; } if ( $ this -> maxHeight !== null && $ height > $ this -> maxHeight ) { return [ $ this -> overHeight , [ 'file' => $ image -> name , 'limit' => $ this -> maxHeight ] ] ; } return null ; }
7689	function OpenXML_CTypesPrepareExt ( $ FileOrExt , $ ct = '' ) { $ ext = $ this -> Misc_FileExt ( $ FileOrExt ) ; $ this -> OpenXML_CTypesInit ( ) ; $ lst = & $ this -> OpenXmlCTypes [ 'Extension' ] ; if ( isset ( $ lst [ $ ext ] ) && ( $ lst [ $ ext ] !== '' ) ) return ; if ( ( $ ct === '' ) && isset ( $ this -> ExtInfo [ 'pic_ext' ] [ $ ext ] ) ) $ ct = 'image/' . $ this -> ExtInfo [ 'pic_ext' ] [ $ ext ] ; $ lst [ $ ext ] = $ ct ; }
12092	public function generate ( $ name , array $ parameters = array ( ) , $ updateTrackerName = 'global' , $ referenceType = RouterInterface :: ABSOLUTE_PATH , $ timestampParameterName = null ) { if ( ! $ timestampParameterName ) { $ timestampParameterName = $ this -> timestampParameterName ; } $ parameters [ $ timestampParameterName ] = $ this -> updateManager -> getLastUpdate ( $ updateTrackerName ) -> format ( 'U' ) ; return $ this -> router -> generate ( $ name , $ parameters , $ referenceType ) ; }
6861	public function doDefaultValueConversionByType ( $ value , $ type , array $ record ) { switch ( $ type ) { case static :: TYPE_DATETIME : return date ( static :: FORMAT_DATETIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_DATE : return date ( static :: FORMAT_DATE , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_TIME : return date ( static :: FORMAT_TIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_MULTILINE : return '<pre class="multiline-text">' . $ value . '</pre>' ; case static :: TYPE_JSON : case static :: TYPE_JSONB : if ( ! is_array ( $ value ) && $ value !== null ) { if ( is_string ( $ value ) || is_numeric ( $ value ) || is_bool ( $ value ) ) { $ value = json_decode ( $ value , true ) ; if ( $ value === null && strtolower ( $ value ) !== 'null' ) { $ value = 'Failed to decode JSON: ' . print_r ( $ value , true ) ; } } else { $ value = 'Invalid value for JSON: ' . print_r ( $ value , true ) ; } } return '<pre class="json-text">' . htmlentities ( stripslashes ( json_encode ( $ value , JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE ) ) ) . '</pre>' ; break ; } return $ value ; }
5708	public function transformToButton ( ) { parent :: transformToButton ( ) ; if ( $ this -> gridFieldRequest -> recordIsPublished ( ) ) { $ this -> setTitle ( _t ( 'SiteTree.BUTTONPUBLISHED' , 'Published' ) ) ; } if ( $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsDeletedFromStage ( ) ) { $ this -> addExtraClass ( 'ss-ui-alternate' ) ; } return $ this ; }
1512	public function read ( StoreInterface $ store , FetchResource $ request ) { $ result = $ this -> doRead ( $ store , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ result ) ; }
6816	public function isSameAs ( Adjustment $ adjustment ) : bool { return $ this -> name === $ adjustment -> getName ( ) && $ this -> rate === $ adjustment -> getRate ( ) ; }
6395	public function init ( ) { parent :: init ( ) ; $ this -> path = Yii :: getAlias ( $ this -> path ) ; FileHelper :: createDirectory ( $ this -> path , $ this -> dirMode , true ) ; }
2333	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> tokenChecker -> hasBackendUser ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( $ this -> requestAttribute , true ) ; }
3413	public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; $ this -> original = $ this -> fields ; $ this -> fieldsAreFetched = true ; return $ this -> fields ; }
7587	protected function extractFileName ( ) { foreach ( explode ( "\r\n" , $ this -> headers ) as $ header ) { if ( strpos ( $ header , 'filename' ) !== false && strpos ( $ header , 'Content-Disposition' ) !== false ) { $ fileName = substr ( $ header , ( strpos ( $ header , "=" ) + 1 ) ) ; $ this -> setFileName ( $ fileName ) ; break ; } } }
6065	public function listSocialMediaFiles ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/socialmedia/files' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new DeploymentFile ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12261	private function _cacheCustomFieldsGroup ( CustomFieldsGroup $ group ) { foreach ( $ group -> getCustomFields ( ) as $ field ) { $ this -> cache [ $ group -> getEntity ( ) ] [ $ field -> getSlug ( ) ] = $ field ; } }
6508	public function doStop ( ) { if ( $ this -> controller -> doStop ( ) ) { $ this -> job -> setStatus ( Status :: CANCELLED ( ) ) ; return true ; } return false ; }
7612	public function getIsSuperAdmin ( ) { if ( $ this -> _isSuperAdmin !== null ) { return $ this -> _isSuperAdmin ; } $ this -> _isSuperAdmin = in_array ( $ this -> username , Yii :: $ app -> getModule ( 'auth' ) -> superAdmins ) ; return $ this -> _isSuperAdmin ; }
109	public function getVersion ( ) { if ( isset ( self :: $ version ) ) { return self :: $ version ; } if ( 0 !== $ this -> process -> execute ( 'git --version' , $ output ) ) { return ; } if ( preg_match ( '/^git version (\d+(?:\.\d+)+)/m' , $ output , $ matches ) ) { return self :: $ version = $ matches [ 1 ] ; } }
6940	private function pop ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( false !== $ index = $ this -> find ( $ list , $ oid , $ unit ) ) { unset ( $ list [ $ oid ] [ $ index ] ) ; if ( empty ( $ list [ $ oid ] ) ) { unset ( $ list [ $ oid ] ) ; } } }
10662	public function withoutParam ( $ paramName = null ) { $ object = clone $ this ; if ( is_null ( $ paramName ) ) { unset ( $ object -> configs [ $ this -> currentParamType ] ) ; } else { if ( isset ( $ object -> configs [ $ this -> currentParamType ] ) ) { if ( ! is_array ( $ object -> configs [ $ this -> currentParamType ] ) ) { unset ( $ object -> configs [ $ this -> currentParamType ] ) ; } else { if ( is_array ( $ paramName ) ) { $ paramName = [ $ paramName ] ; } foreach ( $ paramName as $ paramKey ) { if ( is_string ( $ paramKey ) || is_numeric ( $ paramKey ) ) { unset ( $ object -> configs [ $ this -> currentParamType ] [ $ paramName ] ) ; } } } } } return $ object -> buildConfigClient ( ) ; }
3415	public function update ( array $ fields = [ ] ) { $ keys = [ ] ; foreach ( $ fields as $ key => $ value ) { array_set ( $ this -> fields , $ key , $ value ) ; $ keys [ ] = $ key ; } return $ this -> save ( $ keys ) ; }
7855	public function boot ( ) { $ this -> publishConfig ( ) ; $ this -> commands ( $ this -> commands ) ; $ facade = 'Cerbero\Workflow\Facades\Workflow' ; AliasLoader :: getInstance ( ) -> alias ( 'Workflow' , $ facade ) ; }
5278	public function orWhere ( $ column , $ param1 = null , $ param2 = null ) { return $ this -> where ( $ column , $ param1 , $ param2 , 'or' ) ; }
3554	public function getValue ( ) { if ( $ this -> hasMutator ( $ this -> attributes [ 'meta_value' ] , 'getter' , $ this -> attributes [ 'meta_type' ] ) ) { return $ this -> mutateValue ( $ this -> attributes [ 'meta_value' ] , 'getter' ) ; } return $ this -> castValue ( ) ; }
12695	static function getVendorDir ( $ vendorPrefix = 'vendor' ) { if ( is_dir ( __DIR__ . '/../../../composer' ) && is_file ( __DIR__ . '/../../../autoload.php' ) ) { return realpath ( __DIR__ . '/../../..' ) ; } if ( is_dir ( __DIR__ . "/../$vendorPrefix/composer" ) && is_file ( __DIR__ . "/../$vendorPrefix/autoload.php" ) ) { return realpath ( __DIR__ . "/../$vendorPrefix" ) ; } return false ; }
194	public function sendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( ! isset ( $ options [ 'mimeType' ] ) ) { $ options [ 'mimeType' ] = FileHelper :: getMimeTypeByExtension ( $ filePath ) ; } if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } $ handle = fopen ( $ filePath , 'rb' ) ; $ this -> sendStreamAsFile ( $ handle , $ attachmentName , $ options ) ; return $ this ; }
8185	public function getParent ( array $ context ) { if ( null !== $ this -> parent ) { return $ this -> parent ; } try { $ parent = $ this -> doGetParent ( $ context ) ; if ( false === $ parent ) { return false ; } if ( $ parent instanceof self ) { return $ this -> parents [ $ parent -> getTemplateName ( ) ] = $ parent ; } if ( ! isset ( $ this -> parents [ $ parent ] ) ) { $ this -> parents [ $ parent ] = $ this -> loadTemplate ( $ parent ) ; } } catch ( Twig_Error_Loader $ e ) { $ e -> setSourceContext ( null ) ; $ e -> guess ( ) ; throw $ e ; } return $ this -> parents [ $ parent ] ; }
5284	public function limit ( $ limit , $ offset = 0 ) { global $ wpdb ; $ limit = \ absint ( $ limit ) ; $ offset = \ absint ( $ offset ) ; $ this -> limit = $ wpdb -> prepare ( 'limit %d, %d' , $ offset , $ limit ) ; return $ this ; }
11857	private function removeCookie ( $ cookie , \ Psr \ Http \ Message \ ResponseInterface $ response ) { return \ Dflydev \ FigCookies \ FigResponseCookies :: remove ( $ response , $ cookie ) ; }
2199	public static function findPublishedByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
7410	public function offsetSet ( $ k , $ v ) { if ( null === $ k || ! array_key_exists ( $ k , $ this -> _container ) ) { $ v = ( is_object ( $ v ) && get_class ( $ v ) === $ this -> _type ) ? $ v : new $ this -> _type ( $ v ) ; if ( null === $ k ) { $ this -> _container [ ] = $ v ; } else { $ this -> _container [ $ k ] = $ v ; } return ; } if ( is_a ( $ this -> _type , AtomicInterface :: class , true ) ) { $ this -> _container [ $ k ] -> set ( $ v ) ; return ; } if ( is_a ( $ this -> _type , TypedAbstract :: class , true ) ) { $ this -> _container [ $ k ] -> replace ( $ v ) ; return ; } $ this -> _container [ $ k ] = new $ this -> _type ( $ v ) ; }
1234	private function toXml ( $ elementName , $ rootElement = false ) { return sprintf ( '%s<%s%s%s>%s</%s>' , $ rootElement ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" : '' , $ elementName , $ this -> attributesToXml ( ) , array_key_exists ( get_class ( $ this ) , self :: $ xmlNamespaces ) ? sprintf ( ' %s' , self :: $ xmlNamespaces [ get_class ( $ this ) ] ) : '' , $ this -> propertiesToXml ( ) , $ elementName ) ; }
11617	public function records ( $ startTime , $ endTime , $ page = 1 , $ pageSize = 10 ) { $ params = [ 'starttime' => is_numeric ( $ startTime ) ? $ startTime : strtotime ( $ startTime ) , 'endtime' => is_numeric ( $ endTime ) ? $ endTime : strtotime ( $ endTime ) , 'pageindex' => $ page , 'pagesize' => $ pageSize , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RECORDS , $ params ] ) ; }
8237	protected function configGenerationAction ( ParameterBag $ post ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> addOutput ( "installer_step" , 1 ) ; return ; } $ this -> picoAuth -> addOutput ( "installer_step" , 2 ) ; $ this -> outputModulesConfiguration ( $ post ) ; }
10624	private static function checkAndMoveFile ( $ sourceMigrationFile , $ appMigrationDir , IOInterface $ io ) { $ explodedPath = explode ( '/' , $ sourceMigrationFile ) ; $ filename = array_pop ( $ explodedPath ) ; if ( file_exists ( $ appMigrationDir . '/' . $ filename ) ) { if ( md5_file ( $ appMigrationDir . '/' . $ filename ) === md5_file ( $ sourceMigrationFile ) ) { if ( $ io -> isVeryVerbose ( ) ) { $ io -> write ( "<info>found that $sourceMigrationFile is equal" . " to $appMigrationDir/$filename</info>" ) ; } $ doTheMove = false ; } else { $ doTheMove = $ io -> askConfirmation ( "<question>The file \n" . " \t$sourceMigrationFile\n has the same name than the previous " . "migrated file located at \n\t$appMigrationDir/$filename\n " . "but the content is not equal.\n Overwrite the file ?[y,N]" , false ) ; } } else { $ doTheMove = true ; } if ( $ doTheMove ) { $ fs = new Filesystem ( ) ; $ fs -> copy ( $ sourceMigrationFile , $ appMigrationDir . '/' . $ filename ) ; $ io -> write ( "<info>Importing '$filename' migration file</info>" ) ; return true ; } return false ; }
6284	protected static function buildHttpClient05 ( LoopInterface $ loop , $ connector = null ) { if ( $ connector instanceof DnsResolver ) { @ trigger_error ( sprintf ( 'Passing a %s to buildHttpClient is deprecated since version 2.1.0 and will be removed in 3.0. If you need no specific behaviour, omit the $dns argument, otherwise pass a %s' , DnsResolver :: class , ConnectorInterface :: class ) , E_USER_DEPRECATED ) ; $ connector = static :: buildConnector ( $ loop , $ connector ) ; } if ( null !== $ connector && ! $ connector instanceof ConnectorInterface ) { throw new \ InvalidArgumentException ( '$connector must be an instance of DnsResolver or ConnectorInterface' ) ; } return new HttpClient ( $ loop , $ connector ) ; }
9390	public function getSortValBeforeAll ( $ groupingId = null ) { if ( $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( [ $ this -> pkColumn , $ this -> srtColumn ] ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( [ $ this -> srtColumn => SORT_ASC ] ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result && $ result [ $ this -> srtColumn ] == 1 ) { $ this -> rebuildSortAfter ( $ result [ $ this -> pkColumn ] , true ) ; $ sortVal = $ this -> getIniSortVal ( ) ; } else if ( $ result ) { $ sortVal = ceil ( $ result [ $ this -> srtColumn ] / 2 ) ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
1062	public static function findTypesAddedToUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesAddedToUnion = [ ] ; foreach ( $ newTypeMap as $ typeName => $ newType ) { $ oldType = $ oldTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInOldUnion = [ ] ; foreach ( $ oldType -> getTypes ( ) as $ type ) { $ typeNamesInOldUnion [ $ type -> name ] = true ; } foreach ( $ newType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInOldUnion [ $ type -> name ] ) ) { continue ; } $ typesAddedToUnion [ ] = [ 'type' => self :: DANGEROUS_CHANGE_TYPE_ADDED_TO_UNION , 'description' => sprintf ( '%s was added to union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesAddedToUnion ; }
7441	protected function hasAccessToAction ( $ packageKey , $ subpackageKey , $ controllerName , $ actionName ) { $ actionControllerName = $ this -> router -> getControllerObjectName ( $ packageKey , $ subpackageKey , $ controllerName ) ; try { return $ this -> privilegeManager -> isGranted ( 'Neos\Flow\Security\Authorization\Privilege\Method\MethodPrivilege' , new MethodPrivilegeSubject ( new JoinPoint ( NULL , $ actionControllerName , $ actionName . 'Action' , array ( ) ) ) ) ; } catch ( AccessDeniedException $ e ) { return FALSE ; } }
7866	protected function drawBorderTop ( $ isCore = false ) { $ crossroads = $ isCore ? static :: CROSSROADS_UP : static :: CROSSROADS ; $ this -> drawBorder ( static :: BORDER_NW , $ crossroads , static :: BORDER_NE ) ; $ this -> geometry -> increaseNesting ( ) ; }
7805	protected function openingBalance ( $ text ) { if ( $ line = $ this -> getLine ( '60F|60M' , $ text ) ) { return $ this -> balance ( $ this -> reader -> createOpeningBalance ( ) , $ line ) ; } }
2749	public function getVclFile ( $ vclTemplatePath ) { $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) ; $ configFilePath = $ moduleEtcPath . '/' . $ this -> _scopeConfig -> getValue ( self :: FASTLY_CONFIGURATION_PATH ) ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; $ configFilePath = $ directoryRead -> getRelativePath ( $ configFilePath ) ; $ data = $ directoryRead -> readFile ( $ configFilePath ) ; return strtr ( $ data , $ this -> getReplacements ( ) ) ; }
894	public function getArguments ( Tokens $ tokens , $ openParenthesis , $ closeParenthesis ) { $ arguments = [ ] ; $ firstSensibleToken = $ tokens -> getNextMeaningfulToken ( $ openParenthesis ) ; if ( $ tokens [ $ firstSensibleToken ] -> equals ( ')' ) ) { return $ arguments ; } $ paramContentIndex = $ openParenthesis + 1 ; $ argumentsStart = $ paramContentIndex ; for ( ; $ paramContentIndex < $ closeParenthesis ; ++ $ paramContentIndex ) { $ token = $ tokens [ $ paramContentIndex ] ; $ blockDefinitionProbe = Tokens :: detectBlockType ( $ token ) ; if ( null !== $ blockDefinitionProbe && true === $ blockDefinitionProbe [ 'isStart' ] ) { $ paramContentIndex = $ tokens -> findBlockEnd ( $ blockDefinitionProbe [ 'type' ] , $ paramContentIndex ) ; continue ; } if ( $ token -> equals ( ',' ) ) { if ( $ tokens -> getNextMeaningfulToken ( $ paramContentIndex ) === $ closeParenthesis ) { break ; } $ arguments [ $ argumentsStart ] = $ paramContentIndex - 1 ; $ argumentsStart = $ paramContentIndex + 1 ; } } $ arguments [ $ argumentsStart ] = $ paramContentIndex - 1 ; return $ arguments ; }
6287	private function buildReactRequest ( RequestInterface $ request ) { $ headers = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ headers [ $ name ] = ( is_array ( $ value ) ? $ value [ 0 ] : $ value ) ; } $ reactRequest = $ this -> client -> request ( $ request -> getMethod ( ) , ( string ) $ request -> getUri ( ) , $ headers , $ request -> getProtocolVersion ( ) ) ; return $ reactRequest ; }
11751	public function stats ( ) { if ( is_null ( $ this -> stats ) ) { $ this -> stats = new Stats ( $ this -> accessToken ) ; } return $ this -> stats ; }
3662	private function parseTable ( ) { $ this -> queryString = str_replace ( '{{table}}' , $ this -> collection -> getMetaModel ( ) -> getTableName ( ) , $ this -> queryString ) ; }
8295	public function open ( ) { if ( $ this -> isOpened ( ) ) { return ; } $ this -> handle = @ fopen ( $ this -> filePath , self :: OPEN_MODE ) ; if ( $ this -> handle === false ) { throw new \ RuntimeException ( "Could not open file for writing: " . $ this -> filePath ) ; } if ( ! $ this -> lock ( LOCK_EX ) ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not aquire an exclusive lock for " . $ this -> filePath ) ; } if ( $ this -> options [ "backup" ] ) { $ this -> createBkFile ( ) ; } $ this -> writeErrors = false ; }
10398	protected function doReplacement ( $ inputString ) { if ( is_string ( $ inputString ) ) { $ inputString = str_replace ( array_keys ( $ this -> replacements ) , array_values ( $ this -> replacements ) , $ inputString ) ; } return $ inputString ; }
12257	public function getProjectSearchPaths ( string $ name ) : array { $ srcPaths = $ this -> getProject ( ) -> getAttribute ( AttributeInterface :: SEARCH_PATHS_ATTR_NAME ) ; if ( $ srcPaths instanceof SearchPathCollection ) { return $ srcPaths -> getSearchPaths ( $ name ) ?? [ ] ; } return [ ] ; }
6988	protected function finalize ( ContextInterface $ context ) : ContextInterface { if ( null === $ context -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ this -> customerGroupRepository -> findDefault ( ) ) ; } if ( null === $ context -> getInvoiceCountry ( ) ) { $ context -> setInvoiceCountry ( $ this -> countryProvider -> getCountry ( ) ) ; } if ( null === $ context -> getDeliveryCountry ( ) ) { $ context -> setDeliveryCountry ( $ this -> countryProvider -> getCountry ( ) ) ; } if ( null === $ context -> getCurrency ( ) ) { $ context -> setCurrency ( $ this -> currencyProvider -> getCurrency ( ) ) ; } if ( null === $ context -> getLocale ( ) ) { $ context -> setLocale ( $ this -> localProvider -> getCurrentLocale ( ) ) ; } if ( null === $ context -> getVatDisplayMode ( ) ) { if ( null !== $ mode = $ context -> getCustomerGroup ( ) -> getVatDisplayMode ( ) ) { $ context -> setVatDisplayMode ( $ mode ) ; } else { $ context -> setVatDisplayMode ( $ this -> defaultVatDisplayMode ) ; } } $ this -> eventDispatcher -> dispatch ( ContextEvents :: BUILD , new ContextEvent ( $ context ) ) ; return $ context ; }
7570	public function getApplicationApiService ( ) { $ applicationService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ ApplicationService ( $ this -> _apiKey , $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: APPLICATION_URL ) ) ; $ applicationService -> setClient ( $ apiClient ) ; return $ applicationService ; }
11888	public function getFamiliarity ( $ user = null ) { if ( is_null ( $ user ) ) { $ user = $ this -> getUser ( false ) ; } if ( is_object ( $ user ) ) { $ user = $ user -> primaryKey ; } $ familarityKey = md5 ( $ user ) ; if ( ! isset ( $ this -> _familiarity [ $ familarityKey ] ) ) { $ this -> _familiarity [ $ familarityKey ] = false ; $ familiarityClass = Yii :: $ app -> classes [ 'ObjectFamiliarity' ] ; if ( ! empty ( $ user ) ) { $ attributes = [ ] ; $ attributes [ $ this -> objectField ] = $ this -> owner -> primaryKey ; $ attributes [ $ this -> userField ] = $ user ; $ this -> _familiarity [ $ familarityKey ] = $ familiarityClass :: find ( ) -> where ( $ attributes ) -> one ( ) ; if ( empty ( $ this -> _familiarity [ $ familarityKey ] ) ) { $ this -> _familiarity [ $ familarityKey ] = new $ familiarityClass ( ) ; $ this -> _familiarity [ $ familarityKey ] -> attributes = $ attributes ; } } } return $ this -> _familiarity [ $ familarityKey ] ; }
855	public function insertAt ( $ index , $ items ) { $ items = \ is_array ( $ items ) || $ items instanceof self ? $ items : [ $ items ] ; $ itemsCnt = \ count ( $ items ) ; if ( 0 === $ itemsCnt ) { return ; } $ oldSize = \ count ( $ this ) ; $ this -> changed = true ; $ this -> blockEndCache = [ ] ; $ this -> setSize ( $ oldSize + $ itemsCnt ) ; for ( $ i = $ oldSize + $ itemsCnt - 1 ; $ i >= $ index ; -- $ i ) { $ oldItem = parent :: offsetExists ( $ i - $ itemsCnt ) ? parent :: offsetGet ( $ i - $ itemsCnt ) : new Token ( '' ) ; parent :: offsetSet ( $ i , $ oldItem ) ; } for ( $ i = 0 ; $ i < $ itemsCnt ; ++ $ i ) { if ( '' === $ items [ $ i ] -> getContent ( ) ) { throw new \ InvalidArgumentException ( 'Must not add empty token to collection.' ) ; } $ this -> registerFoundToken ( $ items [ $ i ] ) ; parent :: offsetSet ( $ i + $ index , $ items [ $ i ] ) ; } }
10572	protected function sendCacheControlHeader ( ) { if ( $ this -> sessionCacheLimiter !== null ) { if ( $ this -> sessionCacheLimiter === '' && ! headers_sent ( ) && Yii :: $ app -> getSession ( ) -> getIsActive ( ) ) { header_remove ( 'Expires' ) ; header_remove ( 'Cache-Control' ) ; header_remove ( 'Last-Modified' ) ; header_remove ( 'Pragma' ) ; } session_cache_limiter ( $ this -> sessionCacheLimiter ) ; } $ headers = Yii :: $ app -> getResponse ( ) -> getHeaders ( ) ; $ headers -> set ( 'Pragma' ) ; if ( $ this -> cacheControlHeader !== null ) { $ headers -> set ( 'Cache-Control' , $ this -> cacheControlHeader ) ; } }
5110	private function appendBind ( $ part , $ bind ) { if ( $ bind === false ) return $ this ; if ( ! is_array ( $ bind ) ) $ bind = [ $ bind ] ; if ( ! $ this -> bind [ $ part ] ) { $ this -> bind [ $ part ] = $ bind ; } else { $ this -> bind [ $ part ] = array_merge ( $ this -> bind [ $ part ] , $ bind ) ; } return $ this ; }
12766	public function run ( ) : void { $ this -> isRan = true ; foreach ( $ this -> getAll ( ) as $ header ) { header ( $ header ) ; } }
3541	public static function getGroupAssigmentOptions ( $ optionName , $ individualGroupAssignmentOptions = null ) { if ( $ individualGroupAssignmentOptions != null && is_array ( $ individualGroupAssignmentOptions ) && array_key_exists ( $ optionName , $ individualGroupAssignmentOptions ) ) { return $ individualGroupAssignmentOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX ) ) { return static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Group-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
8745	protected function resetListener ( ) { $ this -> currentKey = null ; $ this -> escapePressedAt = null ; $ this -> charSequenceEnabled = false ; $ this -> isListening = true ; return $ this ; }
5154	public function configure ( ) { $ configuration = $ this -> getConfiguration ( ) ; if ( $ configuration instanceof ConfigurationInterface ) { $ this -> configuration -> configure ( $ this ) ; } }
335	protected function createColumn ( $ column ) { $ c = $ this -> createColumnSchema ( ) ; $ c -> name = $ column [ 'COLUMN_NAME' ] ; $ c -> allowNull = $ column [ 'NULLABLE' ] === 'Y' ; $ c -> comment = $ column [ 'COLUMN_COMMENT' ] === null ? '' : $ column [ 'COLUMN_COMMENT' ] ; $ c -> isPrimaryKey = false ; $ this -> extractColumnType ( $ c , $ column [ 'DATA_TYPE' ] , $ column [ 'DATA_PRECISION' ] , $ column [ 'DATA_SCALE' ] , $ column [ 'DATA_LENGTH' ] ) ; $ this -> extractColumnSize ( $ c , $ column [ 'DATA_TYPE' ] , $ column [ 'DATA_PRECISION' ] , $ column [ 'DATA_SCALE' ] , $ column [ 'DATA_LENGTH' ] ) ; $ c -> phpType = $ this -> getColumnPhpType ( $ c ) ; if ( ! $ c -> isPrimaryKey ) { if ( stripos ( $ column [ 'DATA_DEFAULT' ] , 'timestamp' ) !== false ) { $ c -> defaultValue = null ; } else { $ defaultValue = $ column [ 'DATA_DEFAULT' ] ; if ( $ c -> type === 'timestamp' && $ defaultValue === 'CURRENT_TIMESTAMP' ) { $ c -> defaultValue = new Expression ( 'CURRENT_TIMESTAMP' ) ; } else { if ( $ defaultValue !== null ) { if ( ( $ len = strlen ( $ defaultValue ) ) > 2 && $ defaultValue [ 0 ] === "'" && $ defaultValue [ $ len - 1 ] === "'" ) { $ defaultValue = substr ( $ column [ 'DATA_DEFAULT' ] , 1 , - 1 ) ; } else { $ defaultValue = trim ( $ defaultValue ) ; } } $ c -> defaultValue = $ c -> phpTypecast ( $ defaultValue ) ; } } } return $ c ; }
4013	protected function calculate ( ) { if ( ! $ this -> isDirty ( ) ) { return ; } $ this -> isDirty = false ; $ this -> calculatedOffset = null ; $ this -> calculatedLimit = null ; if ( $ this -> isLimited ( ) ) { if ( $ this -> getLimit ( ) ) { $ this -> calculatedLimit = $ this -> getLimit ( ) ; } if ( $ this -> getOffset ( ) ) { $ this -> calculatedOffset = $ this -> getOffset ( ) ; } } if ( $ this -> getPerPage ( ) > 0 ) { $ this -> calculatePaginated ( ) ; return ; } if ( $ this -> calculatedLimit === null ) { $ this -> calculatedLimit = 0 ; } if ( $ this -> calculatedOffset === null ) { $ this -> calculatedOffset = 0 ; } }
8581	public function setPrepInstruction ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PrepInstruction' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10884	public function report ( ErrorStreamReport $ report ) { $ report -> tags = $ this -> tags ; $ report -> context = $ this -> context ; return $ this -> makeRequest ( $ report ) ; }
8203	protected function peekJob ( $ tube , $ state ) { $ peekMethod = 'peek' . ucfirst ( $ state ) ; try { return $ this -> getPheanstalk ( ) -> $ peekMethod ( $ tube ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
582	public function setAssetManager ( $ assetManager ) { if ( is_scalar ( $ assetManager ) ) { throw new Exception ( '"' . get_class ( $ this ) . '::assetManager" should be either object or array - "' . gettype ( $ assetManager ) . '" given.' ) ; } $ this -> _assetManager = $ assetManager ; }
164	public static function create ( $ from ) { return new self ( [ 'where' => $ from -> where , 'limit' => $ from -> limit , 'offset' => $ from -> offset , 'orderBy' => $ from -> orderBy , 'indexBy' => $ from -> indexBy , 'select' => $ from -> select , 'selectOption' => $ from -> selectOption , 'distinct' => $ from -> distinct , 'from' => $ from -> from , 'groupBy' => $ from -> groupBy , 'join' => $ from -> join , 'having' => $ from -> having , 'union' => $ from -> union , 'params' => $ from -> params , ] ) ; }
2917	protected function ensureFileIsWritable ( $ filePath ) { if ( ( is_file ( $ filePath ) && ! is_writable ( $ filePath ) ) || ( ! is_file ( $ filePath ) && ! is_writable ( dirname ( $ filePath ) ) ) ) { throw new UnableWriteToFileException ( sprintf ( 'Unable to write to the file at %s.' , $ filePath ) ) ; } }
5700	protected function getDefaultButtonList ( $ config ) { $ new = ( $ this -> owner -> ID == 0 ) ; $ list = $ new ? Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_create" : "create" ) : Config :: inst ( ) -> get ( $ config , $ this -> checkVersioned ( ) ? "versioned_edit" : "edit" ) ; return $ list ? : array ( ) ; }
9332	public function requireField ( ) { $ charset = MySQLDatabase :: config ( ) -> charset ; $ collation = MySQLDatabase :: config ( ) -> collation ; $ spec = [ 'type' => 'varchar' , 'parts' => [ 'datatype' => 'varchar' , 'precision' => 64 , 'collate' => $ collation , 'character set' => $ charset , 'arrayValue' => $ this -> arrayValue ] ] ; DB :: require_field ( $ this -> tableName , $ this -> name , $ spec ) ; }
6513	public function copyJob ( JobInterface $ from , \ Abc \ Bundle \ JobBundle \ Model \ JobInterface $ to ) { $ to -> setType ( $ from -> getType ( ) ) ; $ to -> setResponse ( $ from -> getResponse ( ) ) ; $ to -> setParameters ( $ from -> getParameters ( ) ) ; if ( null != $ from -> getStatus ( ) ) { $ to -> setStatus ( $ from -> getStatus ( ) ) ; } foreach ( $ from -> getSchedules ( ) as $ schedule ) { $ to -> addSchedule ( $ schedule ) ; } return $ to ; }
9873	private function writeDrawings ( XMLWriter $ objWriter = null , PhpspreadsheetWorksheet $ pSheet = null , $ includeCharts = false ) { $ chartCount = ( $ includeCharts ) ? $ pSheet -> getChartCollection ( ) -> count ( ) : 0 ; if ( ( $ pSheet -> getDrawingCollection ( ) -> count ( ) > 0 ) || ( $ chartCount > 0 ) ) { $ objWriter -> startElement ( 'drawing' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId1' ) ; $ objWriter -> endElement ( ) ; } }
3494	public function withCertificatePassPhrase ( string $ passPhrase ) : Request { $ cloned = clone $ this ; $ cloned -> certificatePassPhrase = $ passPhrase ; return $ cloned ; }
10214	public function setColor ( Color $ pValue ) { $ color = $ pValue -> getIsSupervisor ( ) ? $ pValue -> getSharedComponent ( ) : $ pValue ; if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getColor ( ) -> getStyleArray ( [ 'argb' => $ color -> getARGB ( ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> color = $ color ; } return $ this ; }
1318	public function put ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'PUT' , self :: API_HOST , $ path , $ parameters , false ) ; }
363	public function renderItems ( ) { $ caption = $ this -> renderCaption ( ) ; $ columnGroup = $ this -> renderColumnGroup ( ) ; $ tableHeader = $ this -> showHeader ? $ this -> renderTableHeader ( ) : false ; $ tableBody = $ this -> renderTableBody ( ) ; $ tableFooter = false ; $ tableFooterAfterBody = false ; if ( $ this -> showFooter ) { if ( $ this -> placeFooterAfterBody ) { $ tableFooterAfterBody = $ this -> renderTableFooter ( ) ; } else { $ tableFooter = $ this -> renderTableFooter ( ) ; } } $ content = array_filter ( [ $ caption , $ columnGroup , $ tableHeader , $ tableFooter , $ tableBody , $ tableFooterAfterBody , ] ) ; return Html :: tag ( 'table' , implode ( "\n" , $ content ) , $ this -> tableOptions ) ; }
7477	public function downloadAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ file = $ em -> find ( 'Orkestra\Bundle\ApplicationBundle\Entity\File' , $ id ) ; if ( ! $ file ) { throw $ this -> createNotFoundException ( 'Unable to locate File' ) ; } $ securityContext = $ this -> get ( 'security.authorization_checker' ) ; foreach ( $ file -> getGroups ( ) as $ group ) { if ( ! $ securityContext -> isGranted ( $ group -> getRole ( ) ) ) { throw $ this -> createNotFoundException ( 'Unable to locate File' ) ; } } return new Response ( $ file -> getContent ( ) , 200 , array ( 'Content-Type' => $ file -> getMimeType ( ) , 'Content-Disposition' => sprintf ( 'attachment; filename="%s"' , $ file -> getFilename ( ) ) ) ) ; }
11552	public function removeConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_REMOVE , $ event ) ; if ( $ consignment -> getStatus ( ) != ConsignmentStatusList :: STATUS_NEW ) { throw new OperationNotPermittedException ( sprintf ( 'Can not remove Consignment "%s" with status "%s"' , $ consignment -> getId ( ) , $ consignment -> getStatus ( ) ) ) ; } try { $ adapter -> removeConsignment ( $ consignment ) ; $ this -> consignmentRepository -> removeConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment removing.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_REMOVE , $ event ) ; }
5347	public function revertSnapshotToOtherVps ( $ sourceVpsName , $ snapshotName , $ destinationVpsName ) { return $ this -> call ( self :: SERVICE , 'revertSnapshotToOtherVps' , [ $ sourceVpsName , $ snapshotName , $ destinationVpsName ] ) ; }
1742	public function syncFiles ( $ href , $ label , $ title , $ class , $ attributes ) { return $ this -> User -> hasAccess ( 'f6' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" class="' . $ class . '"' . $ attributes . '>' . $ label . '</a> ' : '' ; }
5459	protected function acceptTag ( $ tag ) { if ( $ tag -> getTagName ( ) === 'a' ) { $ this -> page -> addLink ( $ tag ) ; } elseif ( $ tag -> getTagName ( ) === 'base' ) { $ this -> page -> setBase ( $ tag -> getAttribute ( 'href' ) ) ; } elseif ( $ tag -> getTagName ( ) === 'title' ) { $ this -> page -> setTitle ( $ tag ) ; } elseif ( $ this -> isFormElement ( $ tag -> getTagName ( ) ) ) { for ( $ i = 0 ; $ i < count ( $ this -> open_forms ) ; $ i ++ ) { $ this -> open_forms [ $ i ] -> addWidget ( $ tag ) ; } $ this -> last_widget = $ tag ; } }
373	public function getOptionValues ( $ actionID ) { $ properties = [ ] ; foreach ( $ this -> options ( $ this -> action -> id ) as $ property ) { $ properties [ $ property ] = $ this -> $ property ; } return $ properties ; }
7799	protected function getLine ( $ id , $ text , $ offset = 0 , & $ position = null , & $ length = null ) { $ pcre = '/(?:^|\r?\n)\:(' . $ id . ')\:' . '(.+)' . '(:?$|\r?\n\:[[:alnum:]]{2,3}\:)' . '/Us' ; if ( preg_match ( $ pcre , substr ( $ text , $ offset ) , $ match , PREG_OFFSET_CAPTURE ) ) { $ position = $ offset + $ match [ 1 ] [ 1 ] - 1 ; $ length = strlen ( $ match [ 2 ] [ 0 ] ) ; return rtrim ( $ match [ 2 ] [ 0 ] ) ; } return '' ; }
11222	private static function checkRoutes ( ) { $ method = $ _SERVER [ 'REQUEST_METHOD' ] ; $ route_pos = array_keys ( self :: $ routes , self :: $ uri , true ) ; foreach ( $ route_pos as $ route ) { $ methodRoute = self :: $ methods [ $ route ] ; if ( $ methodRoute == $ method || $ methodRoute == 'ANY' ) { if ( ! is_object ( $ callback = self :: $ callbacks [ $ route ] ) ) { self :: $ response = self :: invokeObject ( $ callback ) ; } else { self :: $ response = call_user_func ( $ callback ) ; } if ( ! self :: $ halts ) { return self :: $ response ; } self :: $ halts -- ; } } return self :: $ response ; }
7393	public function unserialize ( $ serialized ) : void { $ this -> _initMetaData ( ) ; $ data = unserialize ( $ serialized ) ; foreach ( $ data as $ k => $ v ) { $ this -> { $ k } = $ v ; } }
8494	public function createFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_CreateFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_CreateFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_CreateFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8347	public function canEdit ( GroupableInterface $ post , TokenInterface $ token ) : bool { $ user = $ token -> getUser ( ) ; if ( $ post -> getAuthor ( ) == $ user -> getUsername ( ) ) { return true ; } foreach ( $ post -> getGroups ( ) as $ group ) { if ( $ this -> decision_manager -> decide ( $ token , [ 'GROUP_ROLE_ADMIN' ] , $ group ) ) { return true ; } } return false ; }
10168	public static function getInt4d ( $ data , $ pos ) { $ _or_24 = ord ( $ data [ $ pos + 3 ] ) ; if ( $ _or_24 >= 128 ) { $ _ord_24 = - abs ( ( 256 - $ _or_24 ) << 24 ) ; } else { $ _ord_24 = ( $ _or_24 & 127 ) << 24 ; } return ord ( $ data [ $ pos ] ) | ( ord ( $ data [ $ pos + 1 ] ) << 8 ) | ( ord ( $ data [ $ pos + 2 ] ) << 16 ) | $ _ord_24 ; }
12058	public function getPossibleTargets ( ) { if ( is_null ( $ this -> _possibleTargets ) ) { $ this -> _possibleTargets = [ ] ; if ( $ this -> canEndRelation ( ) ) { $ this -> _possibleTargets [ ] = 'end_relationship' ; } if ( $ this -> canDeleteRelation ( ) ) { $ this -> _possibleTargets [ ] = 'delete_relationship' ; } if ( $ this -> canArchiveObject ( ) ) { if ( $ this -> object -> archived ) { $ this -> _possibleTargets [ ] = 'unarchive_object' ; } else { $ this -> _possibleTargets [ ] = 'archive_object' ; } } if ( $ this -> canDeleteObject ( ) ) { $ this -> _possibleTargets [ ] = 'delete_object' ; } } return $ this -> _possibleTargets ; }
3072	protected function getItemRef ( $ itemIdentifier ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ mapService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerMap :: SERVICE_ID ) ; return $ mapService -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; }
1393	protected function prepareJsonApiException ( JsonApiException $ ex ) { $ error = collect ( $ ex -> getErrors ( ) ) -> map ( function ( ErrorInterface $ err ) { return $ err -> getDetail ( ) ? : $ err -> getTitle ( ) ; } ) -> filter ( ) -> first ( ) ; return new HttpException ( $ ex -> getHttpCode ( ) , $ error , $ ex ) ; }
6104	public function wait ( ) { if ( $ this -> getTransport ( ) -> getConfig ( "blocking" ) ) { throw new Ts3Exception ( "only available in non-blocking mode" ) ; } do { $ evt = $ this -> getTransport ( ) -> readLine ( ) ; var_dump ( $ evt ) ; } while ( $ evt instanceof StringHelper && ! $ evt -> section ( TeamSpeak3 :: SEPARATOR_CELL ) -> startsWith ( TeamSpeak3 :: EVENT ) ) ; return new Event ( $ evt , $ this -> getHost ( ) ) ; }
258	public function render ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; return $ this -> renderFile ( $ viewFile , $ params , $ context ) ; }
5783	private function enterEventAndNotice ( string $ action , $ primaryKeyValue = null ) { if ( $ action != 'insert' && $ action != 'update' ) { throw new \ InvalidArgumentException ( "Action must be either insert or update" ) ; } $ actionPastTense = ( $ action == 'insert' ) ? 'inserted' : 'updated' ; $ tableNameSingular = $ this -> tableMapper -> getFormalTableName ( false ) ; $ noteStart = "$actionPastTense $tableNameSingular" ; $ eventTitle = @ constant ( "EVENT_" . strtoupper ( $ tableNameSingular ) . "_" . strtoupper ( $ action ) ) ?? $ noteStart ; $ adminNotification = $ noteStart ; $ eventPayload = [ ] ; if ( null !== $ primaryKeyColumnName = $ this -> tableMapper -> getPrimaryKeyColumnName ( ) ) { $ adminNotification .= " $primaryKeyValue" ; $ eventPayload = [ $ primaryKeyColumnName => $ primaryKeyValue ] ; } $ eventPayload = array_merge ( $ eventPayload , $ this -> requestInput ) ; $ this -> events -> insertInfo ( $ eventTitle , $ eventPayload ) ; SlimPostgres :: setAdminNotice ( $ adminNotification ) ; }
5149	protected function getFullEmail ( $ id ) { try { $ response = $ this -> sendRequest ( 'GET' , "/api/v1/inboxes/{$this->config['inbox_id']}/messages/{$id}" ) ; } catch ( Exception $ e ) { $ this -> fail ( 'Exception: ' . $ e -> getMessage ( ) ) ; } $ fullEmail = json_decode ( $ response -> getBody ( ) ) ; return $ fullEmail ; }
6873	protected function buildItem ( SaleItemInterface $ saleItem , ShipmentInterface $ shipment ) { if ( $ saleItem -> isCompound ( ) ) { $ available = $ expected = null ; foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { if ( null !== $ child = $ this -> buildItem ( $ childSaleItem , $ shipment ) ) { $ saleItemQty = $ childSaleItem -> getQuantity ( ) ; $ e = $ child -> getExpected ( ) / $ saleItemQty ; if ( null === $ expected || $ expected > $ e ) { $ expected = $ e ; } $ a = $ child -> getAvailable ( ) / $ saleItemQty ; if ( null === $ available || $ available > $ a ) { $ available = $ a ; } } } if ( 0 < $ expected ) { return $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected , $ available ) ; } return null ; } $ item = null ; if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ expected = $ shipment -> isReturn ( ) ? $ this -> calculator -> calculateReturnableQuantity ( $ saleItem , $ shipment ) : $ this -> calculator -> calculateShippableQuantity ( $ saleItem , $ shipment ) ; if ( 0 < $ expected ) { $ item = $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected ) ; } } if ( $ saleItem -> hasChildren ( ) ) { foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { $ this -> buildItem ( $ childSaleItem , $ shipment ) ; } } return $ item ; }
8829	protected function option ( $ display , $ value , $ selected , array $ attributes = [ ] ) { $ selected = $ this -> getSelectedValue ( $ value , $ selected ) ; $ options = array_merge ( [ 'value' => $ value , 'selected' => $ selected ] , $ attributes ) ; return $ this -> toHtmlString ( '<option' . $ this -> html -> attributes ( $ options ) . '>' . e ( $ display ) . '</option>' ) ; }
6444	protected function getClient ( $ redirecturl = '' ) { if ( is_object ( $ this -> linkedin ) ) { return $ this -> linkedin ; } if ( $ redirecturl == '' ) { $ redirecturl = $ this -> redirecturl ; } else { $ this -> redirecturl = $ redirecturl ; } $ this -> logQ ( 'redirect ' . $ redirecturl , 'linkedin' ) ; $ API_CONFIG = array ( 'api_key' => $ this -> options [ 'api_key' ] , 'api_secret' => $ this -> options [ 'api_secret' ] , 'callback_url' => $ redirecturl ) ; $ this -> linkedin = $ linkedin = new \ LinkedIn \ LinkedIn ( $ API_CONFIG ) ; return $ this -> linkedin ; }
3790	private function determineLanguages ( ) { $ languages = $ this -> getMetaModel ( ) -> getAvailableLanguages ( ) ; if ( $ languages === null ) { throw new \ RuntimeException ( 'MetaModel ' . $ this -> getMetaModel ( ) -> getName ( ) . ' does not seem to be translated.' ) ; } return $ languages ; }
919	public function getEnd ( ) { $ reachedContent = false ; foreach ( $ this -> doc -> getLines ( ) as $ index => $ line ) { if ( $ reachedContent && ( $ line -> containsATag ( ) || ! $ line -> containsUsefulContent ( ) ) ) { return $ index - 1 ; } if ( $ line -> containsATag ( ) ) { return null ; } if ( $ line -> containsUsefulContent ( ) ) { $ reachedContent = true ; } } }
4069	public function handle ( GetOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ event -> setOptions ( array_flip ( array_filter ( array_flip ( System :: getLanguages ( ) ) , function ( $ langCode ) { return ( strlen ( $ langCode ) == 2 ) ; } ) ) ) ; }
8596	public function listMarketplaceParticipations ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5139	public function add ( $ middleware , string $ pathConstraint = null ) : void { if ( is_string ( $ middleware ) ) { $ middleware = $ this -> getContainer ( ) -> get ( $ middleware ) ; } if ( ! $ middleware instanceof MiddlewareInterface ) { throw new InvalidArgumentException ( 'Middleware must be an instance of ' . MiddlewareInterface :: class ) ; } $ this -> middleware [ ] = new Middleware ( $ middleware , $ pathConstraint ) ; }
5344	public function make ( $ wsdl , array $ classMap = [ ] ) { return new SoapClient ( $ wsdl , [ 'trace' => true , 'exceptions' => true , 'encoding' => 'utf-8' , 'features' => SOAP_SINGLE_ELEMENT_ARRAYS , 'classmap' => $ classMap , 'cache_wsdl' => WSDL_CACHE_MEMORY , ] ) ; }
1999	private function getAcceptedLocales ( ) : array { $ accepted = [ ] ; $ locales = [ ] ; preg_match_all ( '/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.\d+))?/i' , $ this -> requestStack -> getCurrentRequest ( ) -> headers -> get ( 'accept-language' ) , $ accepted ) ; foreach ( $ accepted [ 1 ] as $ v ) { $ chunks = explode ( '-' , $ v ) ; if ( isset ( $ chunks [ 1 ] ) ) { $ locale = $ chunks [ 0 ] . '-' . strtoupper ( $ chunks [ 1 ] ) ; if ( preg_match ( '/^[a-z]{2}(\-[A-Z]{2})?$/' , $ locale ) ) { $ locales [ ] = $ locale ; } } if ( preg_match ( '/^[a-z]{2}$/' , $ chunks [ 0 ] ) ) { $ locales [ ] = $ chunks [ 0 ] ; } } return \ array_slice ( array_unique ( $ locales ) , 0 , 8 ) ; }
11718	protected function basicFetchQuery ( $ context , array $ args ) { if ( $ context !== 'person' ) { throw new \ LogicException ( 'TimelineAccompanyingPeriod is not able ' . 'to render context ' . $ context ) ; } $ metadata = $ this -> em -> getClassMetadata ( 'ChillPersonBundle:AccompanyingPeriod' ) ; return array ( 'id' => $ metadata -> getColumnName ( 'id' ) , 'date' => $ metadata -> getColumnName ( 'openingDate' ) , 'FROM' => $ metadata -> getTableName ( ) , ) ; }
9625	public function getById ( $ characterId ) { try { $ result = $ this -> client -> get ( $ this -> slug . '/' . $ characterId ) ; } catch ( RequestException $ e ) { $ return [ 'request' ] = $ e -> getRequest ( ) . "\n" ; if ( $ e -> hasResponse ( ) ) { return $ return [ 'response' ] = $ e -> getResponse ( ) . "\n" ; } } return $ result -> json ( ) ; }
4175	public function getProviders ( ) { return $ this -> providers ? : $ this -> providers = new ServiceProvider ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
9949	public function getStyleByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 = null , $ row2 = null ) { if ( $ columnIndex2 !== null && $ row2 !== null ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> getStyle ( $ cellRange ) ; } return $ this -> getStyle ( Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 ) ; }
8439	protected static function completeFilesCountsAndEditorLinks ( ) { if ( ! static :: $ files ) { $ rawList = get_included_files ( ) ; $ list = [ ] ; $ docRoot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; $ docRootLength = mb_strlen ( $ docRoot ) ; $ tracyFileDetectionSubstr = '/tracy' ; foreach ( $ rawList as & $ file ) { $ file = str_replace ( '\\' , '/' , $ file ) ; $ text = mb_substr ( $ file , $ docRootLength ) ; $ tracyFile = mb_stripos ( $ text , $ tracyFileDetectionSubstr ) !== FALSE ; if ( ! $ tracyFile ) static :: $ appFilesCount += 1 ; static :: $ allFilesCount += 1 ; $ href = \ Tracy \ Helpers :: editorUri ( $ file , 1 ) ; $ list [ ] = '<a ' . ( $ tracyFile ? 'class="tracy" ' : '' ) . 'href="' . $ href . '"><nobr>' . $ text . '</nobr></a><br />' ; } static :: $ files = & $ list ; } }
6997	public function getViewersForRelations ( ) { $ ret = [ ] ; foreach ( $ this -> getValueViewers ( ) as $ key => $ viewer ) { if ( $ viewer -> isLinkedToDbColumn ( ) && $ viewer -> hasRelation ( ) ) { $ ret [ $ key ] = $ viewer ; } } return $ ret ; }
635	public function renameTable ( $ table , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameTable ( $ table , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
8873	private function buildHeaders ( $ required_headers = [ ] ) { $ build_headers = array_merge ( $ this -> headers , $ required_headers ) ; $ headers = [ ] ; foreach ( $ build_headers as $ name => $ value ) { $ headers [ ] = "{$name}: {$value}" ; } return implode ( "\r\n" , $ headers ) . "\nThis is a multi-part message in MIME format.\n" ; }
5216	public static function createInstance ( $ className , $ projectPath ) { Runtime :: reset ( ) ; self :: $ projectPath = $ projectPath ; $ binder = new Binder ( ) ; foreach ( static :: getBindingsForApp ( $ className ) as $ bindingModule ) { if ( is_string ( $ bindingModule ) ) { $ bindingModule = new $ bindingModule ( ) ; } if ( $ bindingModule instanceof BindingModule ) { $ bindingModule -> configure ( $ binder , $ projectPath ) ; } elseif ( $ bindingModule instanceof \ Closure ) { $ bindingModule ( $ binder , $ projectPath ) ; } else { throw new \ InvalidArgumentException ( 'Given module class ' . get_class ( $ bindingModule ) . ' is not an instance of stubbles\ioc\module\BindingModule' ) ; } } return $ binder -> getInjector ( ) -> getInstance ( $ className ) ; }
2314	protected function prepareImage ( ) { if ( $ this -> fileObj -> isSvgImage ) { $ imagine = System :: getContainer ( ) -> get ( 'contao.image.imagine_svg' ) ; } else { $ imagine = System :: getContainer ( ) -> get ( 'contao.image.imagine' ) ; } $ image = new NewImage ( $ this -> strRootDir . '/' . $ this -> fileObj -> path , $ imagine , System :: getContainer ( ) -> get ( 'filesystem' ) ) ; $ image -> setImportantPart ( $ this -> prepareImportantPart ( ) ) ; return $ image ; }
2181	private function filterNestedPaths ( Finder $ finder , string $ prepend ) : array { $ parents = [ ] ; $ files = iterator_to_array ( $ finder ) ; foreach ( $ files as $ key => $ file ) { $ path = rtrim ( strtr ( $ prepend . '/' . $ file -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; if ( ! empty ( $ parents ) ) { $ parent = \ dirname ( $ path ) ; while ( false !== strpos ( $ parent , '/' ) ) { if ( \ in_array ( $ parent , $ parents , true ) ) { $ this -> rows [ ] = [ sprintf ( '<fg=yellow;options=bold>%s</>' , '\\' === \ DIRECTORY_SEPARATOR ? 'WARNING' : '!' ) , $ this -> webDir . '/' . $ path , sprintf ( '<comment>Skipped because %s will be symlinked.</comment>' , $ parent ) , ] ; unset ( $ files [ $ key ] ) ; break ; } $ parent = \ dirname ( $ parent ) ; } } $ parents [ ] = $ path ; } return array_values ( $ files ) ; }
10749	protected function sendDeleted ( Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { return $ this -> sendVerb ( 'deleted' , $ response , $ type , $ ids , $ extra ) ; }
3879	public function addSubProcedure ( FilterBuilderSql $ subProcedure ) { $ this -> procedures [ ] = $ subProcedure -> getProcedure ( ) ; $ this -> parameter = array_merge ( $ this -> parameter , $ subProcedure -> getParameters ( ) ) ; return $ this ; }
1303	public function get ( string $ path , array $ headers = [ ] , $ cache = true ) : Response { if ( null === $ this -> endpoint ) { return new Response ( [ ] ) ; } $ headers [ ] = 'Package-Session: ' . $ this -> sess ; $ url = $ this -> endpoint . '/' . ltrim ( $ path , '/' ) ; $ cacheKey = $ cache ? ltrim ( $ path , '/' ) : '' ; if ( $ cacheKey && $ contents = $ this -> cache -> read ( $ cacheKey ) ) { $ cachedResponse = Response :: fromJson ( json_decode ( $ contents , true ) ) ; if ( $ lastModified = $ cachedResponse -> getHeader ( 'last-modified' ) ) { $ response = $ this -> fetchFileIfLastModified ( $ url , $ cacheKey , $ lastModified , $ headers ) ; if ( 304 === $ response -> getStatusCode ( ) ) { $ response = new Response ( $ cachedResponse -> getBody ( ) , $ response -> getOrigHeaders ( ) , 304 ) ; } return $ response ; } } return $ this -> fetchFile ( $ url , $ cacheKey , $ headers ) ; }
11659	public static function removeEntriesFromFile ( $ file , $ entries ) { $ properties = self :: readFromFile ( $ file ) ; if ( is_string ( $ entries ) ) { unset ( $ properties [ $ entries ] ) ; } else { foreach ( $ entries as $ i => $ key ) { unset ( $ properties [ $ key ] ) ; } } self :: saveToFile ( $ file , $ properties ) ; }
4632	public function responseHeaderCallback ( $ ch , $ header ) { if ( strpos ( $ header , ':' ) ) { list ( $ key , $ value ) = explode ( ':' , $ header , 2 ) ; $ value = trim ( $ value ) ; if ( ! empty ( $ value ) ) { if ( ! isset ( $ this -> responseHeaders [ $ key ] ) ) { $ this -> responseHeaders [ $ key ] = $ value ; } elseif ( is_array ( $ this -> responseHeaders [ $ key ] ) ) { $ this -> responseHeaders [ $ key ] = array_merge ( $ this -> responseHeaders [ $ key ] , [ $ value ] ) ; } else { $ this -> responseHeaders [ $ key ] = array_merge ( [ $ this -> responseHeaders [ $ key ] ] , [ $ value ] ) ; } } } return strlen ( $ header ) ; }
5011	public function getLogger ( ) : LoggerInterface { if ( ! $ this -> logger ) { $ logger = new class implements LoggerInterface { public function emerg ( $ message , $ extra = [ ] ) : void { } public function alert ( $ message , $ extra = [ ] ) : void { } public function crit ( $ message , $ extra = [ ] ) : void { } public function err ( $ message , $ extra = [ ] ) : void { } public function warn ( $ message , $ extra = [ ] ) : void { } public function notice ( $ message , $ extra = [ ] ) : void { } public function info ( $ message , $ extra = [ ] ) : void { } public function debug ( $ message , $ extra = [ ] ) : void { } } ; $ this -> setLogger ( $ logger ) ; } return $ this -> logger ; }
5242	public function getAutoloads ( ) : array { if ( empty ( $ this -> autoloads ) ) { $ this -> autoloads = $ this -> configCollection -> getAutoloads ( ) ; } return $ this -> autoloads ; }
6399	public function createEvents ( array $ events ) { $ results = [ ] ; foreach ( $ events as $ index => $ opts ) { $ route = isset ( $ opts [ 'eventname' ] ) ? $ opts [ 'eventname' ] : '' ; if ( isset ( static :: $ routes [ $ route ] ) && ( $ opts [ 'userid' ] > 0 || $ opts [ 'relateduserid' ] > 0 ) ) { try { $ event = '\LogExpander\Events\\' . static :: $ routes [ $ route ] ; array_push ( $ results , ( new $ event ( $ this -> repo ) ) -> read ( $ opts ) ) ; } catch ( \ Exception $ e ) { } } } return $ results ; }
5771	public function hasOneRole ( array $ roleIds ) : bool { foreach ( $ roleIds as $ roleId ) { if ( $ this -> hasRole ( ( int ) $ roleId ) ) { return true ; } } return false ; }
12054	public function remove ( $ name ) { if ( isset ( $ this -> container [ $ name ] ) ) { unset ( $ this -> container [ $ name ] ) ; } return $ this ; }
1008	public static function suggestionList ( $ input , array $ options ) { $ optionsByDistance = [ ] ; $ inputThreshold = mb_strlen ( $ input ) / 2 ; foreach ( $ options as $ option ) { if ( $ input === $ option ) { $ distance = 0 ; } else { $ distance = ( strtolower ( $ input ) === strtolower ( $ option ) ? 1 : levenshtein ( $ input , $ option ) ) ; } $ threshold = max ( $ inputThreshold , mb_strlen ( $ option ) / 2 , 1 ) ; if ( $ distance > $ threshold ) { continue ; } $ optionsByDistance [ $ option ] = $ distance ; } asort ( $ optionsByDistance ) ; return array_keys ( $ optionsByDistance ) ; }
12864	public function postDispatch ( Zend_Controller_Request_Abstract $ request ) { $ methods = implode ( ', ' , array_unique ( $ this -> _methods ) ) ; $ headers = implode ( ', ' , array_unique ( $ this -> _headers ) ) ; if ( $ this -> _credentials ) { header ( 'Access-Control-Allow-Credentials: true' , true ) ; } header ( "Access-Control-Allow-Origin: {$this->_origin}" , true ) ; header ( "Access-Control-Allow-Methods: {$methods}" , true ) ; header ( "Access-Control-Allow-Headers: {$headers}" , true ) ; header ( "Access-Control-Max-Age: {$this->_maxAge}" , true ) ; header ( 'X-XSS-Protection: 1; mode=block' , true ) ; header ( 'X-Frame-Options: SAMEORIGIN' , true ) ; }
4335	public function onOutput ( Event $ event ) { if ( ! $ event [ 'isTarget' ] ) { return ; } $ this -> data = $ this -> debug -> getData ( ) ; $ this -> closeOpenGroups ( ) ; foreach ( $ this -> data [ 'logSummary' ] as & $ log ) { $ this -> removeHideIfEmptyGroups ( $ log ) ; $ this -> uncollapseErrors ( $ log ) ; } $ this -> removeHideIfEmptyGroups ( $ this -> data [ 'log' ] ) ; $ this -> uncollapseErrors ( $ this -> data [ 'log' ] ) ; $ this -> debug -> setData ( $ this -> data ) ; }
6417	public static function size ( IteratorAggregate $ iterable ) : int { if ( $ iterable instanceof Countable ) { return $ iterable -> count ( ) ; } return Iterators :: size ( Iterators :: from ( $ iterable -> getIterator ( ) ) ) ; }
10806	protected function getConfig ( ) { $ config = array_replace ( $ this -> config , $ this -> dialect_config ) ; ksort ( $ config ) ; return $ config ; }
8065	protected function getNextFreeWorker ( ) { $ sec = 0 ; while ( TRUE ) { $ this -> collectWorkerResults ( $ sec ) ; $ freeProcess = $ this -> workerProcesses -> takeFreeProcess ( ) ; if ( $ freeProcess !== NULL ) { return $ freeProcess ; } $ sec = $ this -> child_timeout_sec ; if ( $ this -> workerPoolSize <= 0 ) { throw new WorkerPoolException ( 'All workers were gone.' ) ; } } return NULL ; }
5421	protected function parse ( $ raw ) { if ( ! $ raw ) { $ this -> setError ( 'Nothing fetched' ) ; $ this -> headers = new SimpleHttpHeaders ( '' ) ; } elseif ( 'file' === $ this -> url -> getScheme ( ) ) { $ this -> headers = new SimpleHttpHeaders ( '' ) ; $ this -> content = $ raw ; } elseif ( ! strstr ( $ raw , "\r\n\r\n" ) ) { $ this -> setError ( 'Could not split headers from content' ) ; $ this -> headers = new SimpleHttpHeaders ( $ raw ) ; } else { list ( $ headers , $ this -> content ) = explode ( "\r\n\r\n" , $ raw , 2 ) ; $ this -> headers = new SimpleHttpHeaders ( $ headers ) ; } }
1602	private function _getSocialFallback ( ) { $ image = null ; $ assets = \ Craft :: $ app -> assets ; $ fieldFallback = $ this -> _fieldSettings [ 'socialImage' ] ; if ( ! empty ( $ fieldFallback ) ) $ image = $ assets -> getAssetById ( ( int ) $ fieldFallback [ 0 ] ) ; else { $ seoFallback = $ this -> _seoSettings [ 'socialImage' ] ; if ( ! empty ( $ seoFallback ) ) $ image = $ assets -> getAssetById ( ( int ) $ seoFallback [ 0 ] ) ; } return [ 'title' => $ this -> title , 'description' => $ this -> description , 'image' => $ image , ] ; }
8711	public function whereOriginal ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { return parent :: where ( $ column , $ operator , $ value , $ boolean ) ; }
7447	function decrypt ( $ data , $ password ) { $ data = base64_decode ( $ data ) ; $ salt = substr ( $ data , 0 , 16 ) ; $ ct = substr ( $ data , 16 ) ; $ rounds = 3 ; $ data00 = $ password . $ salt ; $ hash = array ( ) ; $ hash [ 0 ] = hash ( 'sha256' , $ data00 , true ) ; $ result = $ hash [ 0 ] ; for ( $ i = 1 ; $ i < $ rounds ; $ i ++ ) { $ hash [ $ i ] = hash ( 'sha256' , $ hash [ $ i - 1 ] . $ data00 , true ) ; $ result .= $ hash [ $ i ] ; } $ key = substr ( $ result , 0 , 32 ) ; $ iv = substr ( $ result , 32 , 16 ) ; return openssl_decrypt ( $ ct , 'AES-256-CBC' , $ key , true , $ iv ) ; }
4670	protected function afterGeneration ( ) { $ this -> mapTemplate -> writeToFile ( ) ; $ this -> autoloadMap -> writeToFile ( ) ; $ responseParserTemplate = new ResponseParserTemplate ( $ this -> config ) ; $ this -> autoloadMap -> addEntry ( $ responseParserTemplate -> getClassName ( ) , $ responseParserTemplate -> getClassPath ( ) ) ; $ responseParserTemplate -> writeToFile ( ) ; }
8018	public function getUrl ( $ name , $ expires = NULL ) { return $ this -> getClient ( ) -> getObjectUrl ( $ this -> bucket , $ name , $ expires ) ; }
8010	private static function expand56BitKeyTo64BitKey ( $ string_key , $ set_parity = true ) { $ byte_array_56 = new SplFixedArray ( 7 ) ; $ byte_array_64 = new SplFixedArray ( 8 ) ; $ key_64bit = '' ; for ( $ i = 0 ; $ i < $ byte_array_56 -> getSize ( ) ; $ i ++ ) { $ byte_array_56 [ $ i ] = isset ( $ string_key [ $ i ] ) ? ord ( $ string_key [ $ i ] ) : 0 ; } $ byte_array_64 [ 0 ] = $ byte_array_56 [ 0 ] & 254 ; $ byte_array_64 [ 1 ] = ( $ byte_array_56 [ 0 ] << 7 ) | ( $ byte_array_56 [ 1 ] >> 1 ) ; $ byte_array_64 [ 2 ] = ( $ byte_array_56 [ 1 ] << 6 ) | ( $ byte_array_56 [ 2 ] >> 2 ) ; $ byte_array_64 [ 3 ] = ( $ byte_array_56 [ 2 ] << 5 ) | ( $ byte_array_56 [ 3 ] >> 3 ) ; $ byte_array_64 [ 4 ] = ( $ byte_array_56 [ 3 ] << 4 ) | ( $ byte_array_56 [ 4 ] >> 4 ) ; $ byte_array_64 [ 5 ] = ( $ byte_array_56 [ 4 ] << 3 ) | ( $ byte_array_56 [ 5 ] >> 5 ) ; $ byte_array_64 [ 6 ] = ( $ byte_array_56 [ 5 ] << 2 ) | ( $ byte_array_56 [ 6 ] >> 6 ) ; $ byte_array_64 [ 7 ] = $ byte_array_56 [ 6 ] << 1 ; foreach ( $ byte_array_64 as $ byte_val ) { $ byte_val = $ set_parity ? self :: setParityBit ( $ byte_val ) : $ byte_val ; $ key_64bit .= chr ( $ byte_val ) ; } return $ key_64bit ; }
1436	public static function camelize ( $ value ) { if ( isset ( self :: $ camelized [ $ value ] ) ) { return self :: $ camelized [ $ value ] ; } return self :: $ camelized [ $ value ] = lcfirst ( self :: classify ( $ value ) ) ; }
986	public function confirmationUrl ( ) { $ charge = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}.json" , [ "{$this->plan->typeAsString()}" => $ this -> chargeParams ( ) ] ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ charge -> confirmation_url ; }
7146	public function save_custom_profile_fields ( $ user_id ) { if ( 'POST' !== $ _SERVER [ 'REQUEST_METHOD' ] || ! isset ( $ _POST [ 'iac_nonce' ] ) ) { return ; } if ( ! wp_verify_nonce ( $ _POST [ 'iac_nonce' ] , 'iac_user_settings' ) ) { return ; } do_action ( 'iac_save_user_settings' , $ user_id , isset ( $ _POST [ 'post_subscription' ] ) ? $ _POST [ 'post_subscription' ] : NULL , isset ( $ _POST [ 'comment_subscription' ] ) ? $ _POST [ 'comment_subscription' ] : NULL ) ; }
3182	public function getMinimumRemainingTime ( ) { if ( ( $ timeLimits = $ this -> getSource ( ) -> getTimeLimits ( ) ) !== null && ( $ minTime = $ timeLimits -> getMinTime ( ) ) !== null ) { return $ this -> getRemainingTimeFrom ( $ minTime ) ; } return false ; }
10714	public function updateById ( $ id , array $ newAttributes ) { $ model = $ this -> getById ( $ id ) ; $ results = $ model -> update ( $ newAttributes ) ; if ( ! $ results ) { throw new UpdateFailedRepositoryException ( ) ; } return $ model ; }
9146	public function get ( $ key ) { if ( ! isset ( $ this -> sessionContainer [ $ key ] ) ) { return null ; } return $ this -> sessionContainer [ $ key ] ; }
5879	protected static function createIndex ( $ fileName , $ width , $ height ) { $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ targetFilename = PathUtility :: basename ( $ fileName ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( ! isset ( $ storageConfiguration [ 'basePath' ] ) ) { return ; } $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ driver = static :: accessProtectedProperty ( $ targetFolder -> getStorage ( ) , 'driver' ) ; $ fileInfo = $ driver -> getFileInfoByIdentifier ( $ identifier ) ; $ file = $ resourceFactory -> createFileObject ( $ fileInfo ) ; $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ fileRepository -> addToIndex ( $ file ) ; }
8407	private function getIcon ( ) { if ( isset ( $ this -> model ) ) { $ icon = $ this -> attribute ; if ( isset ( $ this -> model -> $ icon ) ) { return $ this -> model -> $ icon ; } } if ( isset ( $ this -> icon ) ) { return $ this -> icon ; } return $ this -> default ; }
8624	public function setShippingServiceList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShippingServiceList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2087	public static function getDefaultPath ( $ template , $ format ) { $ file = $ template . '.' . $ format ; $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ files [ $ template ] ) ) { return $ rootDir . '/' . self :: $ files [ $ template ] . '/' . $ file ; } $ strPath = null ; try { foreach ( $ container -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> name ( $ file ) as $ file ) { $ strPath = $ file -> getPathname ( ) ; } } catch ( \ InvalidArgumentException $ e ) { } if ( $ strPath !== null ) { return $ strPath ; } throw new \ Exception ( 'Could not find template "' . $ template . '"' ) ; }
9983	public static function dataTypeForValue ( $ pValue ) { if ( $ pValue === null ) { return DataType :: TYPE_NULL ; } elseif ( $ pValue === '' ) { return DataType :: TYPE_STRING ; } elseif ( $ pValue instanceof RichText ) { return DataType :: TYPE_INLINE ; } elseif ( $ pValue [ 0 ] === '=' && strlen ( $ pValue ) > 1 ) { return DataType :: TYPE_FORMULA ; } elseif ( is_bool ( $ pValue ) ) { return DataType :: TYPE_BOOL ; } elseif ( is_float ( $ pValue ) || is_int ( $ pValue ) ) { return DataType :: TYPE_NUMERIC ; } elseif ( preg_match ( '/^[\+\-]?(\d+\\.?\d*|\d*\\.?\d+)([Ee][\-\+]?[0-2]?\d{1,3})?$/' , $ pValue ) ) { $ tValue = ltrim ( $ pValue , '+-' ) ; if ( is_string ( $ pValue ) && $ tValue [ 0 ] === '0' && strlen ( $ tValue ) > 1 && $ tValue [ 1 ] !== '.' ) { return DataType :: TYPE_STRING ; } elseif ( ( strpos ( $ pValue , '.' ) === false ) && ( $ pValue > PHP_INT_MAX ) ) { return DataType :: TYPE_STRING ; } return DataType :: TYPE_NUMERIC ; } elseif ( is_string ( $ pValue ) ) { $ errorCodes = DataType :: getErrorCodes ( ) ; if ( isset ( $ errorCodes [ $ pValue ] ) ) { return DataType :: TYPE_ERROR ; } } return DataType :: TYPE_STRING ; }
11512	public function actionRequest ( ) { if ( ! $ this -> module -> enablePasswordRecovery ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( [ 'class' => RecoveryForm :: className ( ) , 'scenario' => 'request' , ] ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> sendRecoveryMessage ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Recovery message sent' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'request' , [ 'model' => $ model , ] ) ; }
940	public function override ( $ other ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ prototype = $ other instanceof self ? $ other -> getPrototype ( ) : $ other ; if ( $ this -> equals ( $ prototype ) ) { return ; } $ this -> changed = true ; if ( \ is_array ( $ prototype ) ) { $ this -> isArray = true ; $ this -> id = $ prototype [ 0 ] ; $ this -> content = $ prototype [ 1 ] ; return ; } $ this -> isArray = false ; $ this -> id = null ; $ this -> content = $ prototype ; }
8360	private function startProcessQueue ( ) { $ this -> logger -> info ( 'Starting queue in process mode' ) ; $ dispatcher = new ProcessDispatcher ( $ this -> client , $ this -> logger , $ this -> queue , \ array_merge ( $ this -> queueConfig , [ 'process' => $ this -> config [ 'process' ] ] ) , [ 'configFile' => $ this -> configName ] ) ; $ dispatcher -> start ( ) ; }
7876	protected function generateRequestIfGuarded ( ) { if ( ! $ this -> option ( 'unguard' ) ) { $ name = $ this -> inflector -> getRequest ( ) ; $ this -> call ( 'make:request' , compact ( 'name' ) ) ; } }
7869	protected function drawCore ( ) { $ this -> drawBorderTop ( true ) ; $ this -> drawBordered ( $ this -> geometry -> getSpacedCore ( ) ) ; $ this -> drawBorderBottom ( true ) ; }
5539	protected function getPublicNameFromIndex ( $ subject ) { foreach ( $ this -> names as $ name => $ index ) { if ( $ subject == $ index ) { return $ name ; } } return $ subject + 1 ; }
9692	private function compileString ( $ str ) { $ result = null ; try { $ result = $ this -> parser -> compile ( $ str ) ; } catch ( \ Exception $ e ) { throw new SyntaxErrorException ( "Syntax error in $this->currFile: " . $ e -> getMessage ( ) ) ; } return $ result ; }
7044	private function getMetaModelTableNames ( $ keyTranslated , $ keyUntranslated ) { $ result = [ ] ; foreach ( $ this -> factory -> collectNames ( ) as $ table ) { $ metaModel = $ this -> factory -> getMetaModel ( $ table ) ; if ( null === $ metaModel ) { continue ; } if ( $ metaModel -> isTranslated ( ) ) { $ result [ $ keyTranslated ] [ $ table ] = \ sprintf ( '%s (%s)' , $ metaModel -> get ( 'name' ) , $ table ) ; } else { $ result [ $ keyUntranslated ] [ $ table ] = \ sprintf ( '%s (%s)' , $ metaModel -> get ( 'name' ) , $ table ) ; } } return $ result ; }
332	public function madd ( $ items , $ duration = 0 , $ dependency = null ) { return $ this -> multiAdd ( $ items , $ duration , $ dependency ) ; }
9540	private function getParameterClosure ( $ parameter ) { $ parameterClosure = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { @ $ parameterClosure = $ this -> parameterCluster -> prefixes [ $ prefix ] [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] ; } } return $ parameterClosure ; }
698	public function actionRun ( $ command ) { $ command = implode ( ' ' , \ func_get_args ( ) ) ; $ base = \ dirname ( \ dirname ( __DIR__ ) ) ; $ dirs = $ this -> listSubDirs ( "$base/extensions" ) ; $ dirs = array_merge ( $ dirs , $ this -> listSubDirs ( "$base/apps" ) ) ; asort ( $ dirs ) ; $ oldcwd = getcwd ( ) ; foreach ( $ dirs as $ dir ) { $ displayDir = substr ( $ dir , \ strlen ( $ base ) ) ; $ this -> stdout ( "Running '$command' in $displayDir...\n" , Console :: BOLD ) ; chdir ( $ dir ) ; passthru ( $ command ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } chdir ( $ oldcwd ) ; }
6533	protected function getConnectionFactory ( $ type ) { if ( false === isset ( $ this -> connectionFactories [ $ type ] ) ) { throw new \ InvalidArgumentException ( "Missing connection factory \"$type\"" ) ; } return $ this -> connectionFactories [ $ type ] ; }
5538	public function getFrameFocus ( ) { if ( $ this -> focus === false ) { return array ( ) ; } return array_merge ( array ( $ this -> getPublicNameFromIndex ( $ this -> focus ) ) , $ this -> frames [ $ this -> focus ] -> getFrameFocus ( ) ) ; }
4569	protected function cast ( $ element ) { if ( $ element instanceof Permission ) { return $ element ; } if ( ! is_array ( $ element ) ) { throw new InvalidArgumentException ( 'Element is not an array.' ) ; } foreach ( [ 'attributes' , 'type' , 'value' , 'title' ] as $ key ) { if ( ! array_key_exists ( $ key , $ element ) ) { throw new InvalidArgumentException ( 'Element is missing key "' . $ key . '".' ) ; } } $ permission = new Permission ( $ element [ 'key' ] , $ element [ 'attributes' ] , $ element [ 'type' ] , $ element [ 'value' ] , $ element [ 'title' ] ) ; return $ permission ; }
1400	public function exception ( \ Exception $ ex ) { if ( $ this -> getCodec ( ) -> willNotEncode ( ) ) { $ this -> codec = $ this -> api -> getDefaultCodec ( ) ; } return $ this -> getErrorResponse ( $ this -> exceptions -> parse ( $ ex ) ) ; }
3356	public function getPath ( $ postfix = null ) { $ url = sprintf ( '/%s/' , $ this -> uuid ) ; if ( $ this -> default_effects ) { $ url = sprintf ( '%s-/%s' , $ url , $ this -> default_effects ) ; } if ( $ this -> filename && $ postfix === null ) { $ postfix = $ this -> filename ; } $ operations = array ( ) ; foreach ( $ this -> operations as $ i => $ operation_item ) { $ part = array ( ) ; foreach ( array_keys ( $ operation_item ) as $ operation_type ) { $ operation_params = $ operation_item [ $ operation_type ] ; $ part [ ] = $ operation_type ; switch ( $ operation_type ) { case 'crop' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; $ part = $ this -> __addPartCenter ( $ part , $ operation_params ) ; $ part = $ this -> __addPartFillColor ( $ part , $ operation_params ) ; break ; case 'resize' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; break ; case 'scale_crop' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; $ part = $ this -> __addPartCenter ( $ part , $ operation_params ) ; break ; case 'effect' : $ part = $ this -> __addPartEffect ( $ part , $ operation_params ) ; break ; case 'preview' : $ part = $ this -> __addPartSize ( $ part , $ operation_params ) ; break ; case 'custom' : $ part = array ( $ operation_params ) ; break ; } $ part_str = join ( '/' , $ part ) ; $ operations [ ] = $ part_str ; } } if ( count ( $ operations ) ) { $ operations_part = join ( '/-/' , $ operations ) ; return $ url . '-/' . $ operations_part . '/' . $ postfix ; } else { return $ url . $ postfix ; } }
7982	public function addDeleteTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaDeleteTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
2739	private function uploadVcl ( $ activate ) { try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'priority' => 50 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_pass' , 'statement' => 'req.http.x-pass' , 'type' => 'REQUEST' , 'priority' => 90 ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ request = [ 'action' => 'pass' , 'max_stale_age' => 3600 , 'name' => Config :: FASTLY_MAGENTO_MODULE . '_request' , 'request_condition' => $ createCondition -> name , 'service_id' => $ service -> id , 'version' => $ currActiveVersion ] ; $ this -> api -> createRequest ( $ clone -> number , $ request ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; $ msg = 'Successfully uploaded VCL. ' ; if ( $ activate ) { $ this -> api -> activateVersion ( $ clone -> number ) ; $ msg .= 'Activated Version ' . $ clone -> number ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Upload VCL has been initiated and activated in version ' . $ clone -> number . '*' ) ; } $ this -> output -> writeln ( '<info>' . $ msg . '</info>' , OutputInterface :: OUTPUT_NORMAL ) ; } catch ( \ Exception $ e ) { $ msg = $ e -> getMessage ( ) ; $ this -> output -> writeln ( "<error>$msg</error>" , OutputInterface :: OUTPUT_NORMAL ) ; return ; } }
7639	public static function createResourceName ( $ containerName = '' , $ blobName = '' ) { $ resourceName = $ containerName . '/' . $ blobName ; if ( $ containerName === '' || $ containerName === '$root' ) { $ resourceName = $ blobName ; } if ( $ blobName === '' ) { $ resourceName = $ containerName ; } return $ resourceName ; }
2201	public static function initialize ( ) { $ _GET = static :: cleanKey ( $ _GET ) ; $ _POST = static :: cleanKey ( $ _POST ) ; $ _COOKIE = static :: cleanKey ( $ _COOKIE ) ; }
12215	protected function compileConfiguration ( Traversable $ source , string $ target , CompilerContext $ context ) { $ compiler = new StandardCompiler ( ) ; $ compiler -> setSource ( $ source ) ; $ compiler -> setTarget ( $ target ) ; $ compiler -> compile ( ) ; }
7744	public function getValue ( $ entity ) { if ( null === $ this -> getter ) { throw new \ Exception ( "Can't get the entity's {$this->name} property as no getter has been found." ) ; } elseif ( false === ( $ entity instanceof $ this -> class ) ) { throw new \ Exception ( "Can't get the entity's {$this->name} property as the entity is not an instance of {$this->class}." ) ; } if ( self :: GETTER_SETTER_METHOD === $ this -> getterType ) { return $ entity -> { $ this -> getter } ( ) ; } else { return $ entity -> { $ this -> getter } ; } }
5283	public function insert ( $ data , $ format = null ) { global $ wpdb ; $ wpdb -> insert ( $ this -> table , $ data , $ format ) ; return $ wpdb -> insert_id ; }
3745	public function fetch ( ConfigInterface $ objConfig ) { $ backupLanguage = $ this -> setLanguage ( $ this -> getCurrentLanguage ( ) ) ; if ( $ objConfig -> getId ( ) !== null ) { $ modelId = $ objConfig -> getId ( ) ; } else { $ filter = $ this -> prepareFilter ( $ objConfig ) ; $ ids = $ this -> getIdsFromFilter ( $ filter , $ objConfig ) ; $ modelId = reset ( $ ids ) ; } $ objItem = $ modelId ? $ this -> getMetaModel ( ) -> findById ( $ modelId , $ objConfig -> getFields ( ) ? : array ( ) ) : null ; $ this -> setLanguage ( $ backupLanguage ) ; if ( ! $ objItem ) { return null ; } return new Model ( $ objItem ) ; }
8606	public function listSubscriptions ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_ListSubscriptionsInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListSubscriptionsInput.php' ) ; $ request = new MWSSubscriptionsService_Model_ListSubscriptionsInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListSubscriptions' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListSubscriptionsResponse.php' ) ; $ response = MWSSubscriptionsService_Model_ListSubscriptionsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8085	public function addPredefinedError ( $ id , $ message = '' ) { if ( is_array ( $ id ) ) { $ this -> errorList = array_diff_key ( $ this -> errorList , $ id ) + $ id ; } else { $ this -> errorList [ $ id ] = $ message ; } }
9570	public function addMiddleware ( $ middleware , $ priority = null ) { $ this -> middlewares -> insert ( $ middleware , ( int ) $ priority ) ; }
11725	public function assign ( string $ key , $ value , bool $ global = false ) { if ( $ global === false ) { $ this -> vars [ $ key ] = $ value ; } else { View :: $ global_vars [ $ key ] = $ value ; } return $ this ; }
10639	protected function processUrls ( Request $ request ) { $ externalRawMediaUrls = array ( ) ; if ( $ request -> get ( 'urls' ) ) { foreach ( $ request -> get ( 'urls' ) as $ url ) { $ externalRawMediaUrls [ ] = $ url ; } } return $ externalRawMediaUrls ; }
1446	protected function dataForUpdate ( $ record , array $ document ) : array { $ resource = $ document [ 'data' ] ?? [ ] ; if ( $ this -> mustValidateExisting ( $ record , $ document ) ) { $ resource [ 'attributes' ] = $ this -> extractAttributes ( $ record , $ resource [ 'attributes' ] ?? [ ] ) ; $ resource [ 'relationships' ] = $ this -> extractRelationships ( $ record , $ resource [ 'relationships' ] ?? [ ] ) ; } return $ resource ; }
10556	public function make ( Log $ log , $ trans = true ) { $ items = [ ] ; $ route = 'dashboard.systems.logs.show' ; foreach ( $ log -> tree ( $ trans ) as $ level => $ item ) { $ items [ $ level ] = array_merge ( $ item , [ 'url' => route ( $ route , [ $ log -> date , $ level ] ) , 'icon' => $ this -> styler -> icon ( $ level ) ? : '' , ] ) ; } return $ items ; }
7379	public function fetchFilter ( string $ key , $ default = null , $ filter = FILTER_DEFAULT , $ options = [ ] ) { $ value = $ this -> fetch ( $ key , $ default ) ; if ( ! is_array ( $ options ) && $ options ) { $ options = [ 'flags' => $ options ] ; } if ( is_array ( $ value ) && ! isset ( $ options [ 'flags' ] ) ) { $ options [ 'flags' ] = FILTER_REQUIRE_ARRAY ; } return filter_var ( $ value , $ filter , $ options ) ; }
10678	public function inflect ( $ text , $ zivotne = false , $ preferovanyRod = '' ) { $ aTxt = $ this -> _txtSplit ( $ text ) ; $ this -> PrefRod = '0' ; $ out = [ ] ; for ( $ i = \ count ( $ aTxt ) - 1 ; $ i >= 0 ; $ i -- ) { $ this -> _skl2 ( $ aTxt [ $ i ] , $ preferovanyRod , $ zivotne ) ; if ( $ i === \ count ( $ aTxt ) - 1 ) { $ this -> PrefRod = $ this -> astrTvar [ 0 ] ; } if ( $ i < \ count ( $ aTxt ) - 1 && mb_substr ( $ this -> PrefRod , 0 , 1 , 'UTF-8' ) !== '?' && mb_substr ( $ this -> astrTvar [ 0 ] , 0 , 1 , 'UTF-8' ) === '?' ) { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { $ this -> astrTvar [ $ j ] = $ aTxt [ $ i ] ; } } if ( mb_substr ( $ this -> astrTvar [ 0 ] , 0 , 1 , 'UTF-8' ) === '?' ) { $ this -> astrTvar [ 0 ] = '' ; } if ( $ i < \ count ( $ aTxt ) ) { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { @ $ out [ $ j ] = $ this -> astrTvar [ $ j ] . ' ' . @ $ out [ $ j ] ; } } else { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { @ $ out [ $ j ] = $ this -> astrTvar [ $ j ] ; } } } return $ out ; }
3546	public function create ( $ request ) { $ data = $ request -> all ( ) ; $ user = $ this -> repository -> create ( $ data ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ user ) ) ; return $ user ; }
2176	private function importExampleWebsite ( ) : ? RedirectResponse { $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ templates = $ installTool -> getTemplates ( ) ; $ this -> context [ 'templates' ] = $ templates ; if ( $ installTool -> getConfig ( 'exampleWebsite' ) ) { $ this -> context [ 'import_date' ] = date ( 'Y-m-d H:i' , $ installTool -> getConfig ( 'exampleWebsite' ) ) ; } $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_template_import' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return null ; } $ template = $ request -> request -> get ( 'template' ) ; if ( '' === $ template || ! \ in_array ( $ template , $ templates , true ) ) { $ this -> context [ 'import_error' ] = $ this -> trans ( 'import_empty_source' ) ; return null ; } try { $ installTool -> importTemplate ( $ template , '1' === $ request -> request -> get ( 'preserve' ) ) ; } catch ( DBALException $ e ) { $ installTool -> persistConfig ( 'exampleWebsite' , null ) ; $ installTool -> logException ( $ e ) ; $ this -> context [ 'import_error' ] = $ this -> trans ( 'import_exception' ) ; return null ; } $ installTool -> persistConfig ( 'exampleWebsite' , time ( ) ) ; return $ this -> getRedirectResponse ( ) ; }
5814	public function validate ( ) { $ result = parent :: validate ( ) ; $ this -> Title = strtolower ( $ this -> Title ) ; if ( $ result -> valid ( ) && ! $ this -> Title ) { $ result -> error ( '"Title" required!' ) ; } else if ( $ result -> valid ( ) && FusionTag :: get_one ( 'FusionTag' , array ( 'ID != ?' => $ this -> ID , 'Title = ?' => $ this -> Title ) ) ) { $ result -> error ( 'Tag already exists!' ) ; } $ this -> extend ( 'validateFusionTag' , $ result ) ; return $ result ; }
2968	protected function pickMetadata ( $ data ) { $ metadata = [ ] ; if ( ArrayUtils :: has ( $ data , 'rows' ) ) { $ metadata = ArrayUtils :: omit ( $ data , 'rows' ) ; } else if ( ArrayUtils :: has ( $ data , 'meta' ) ) { $ metadata = ArrayUtils :: get ( $ data , 'meta' ) ; } return new Entry ( $ metadata ) ; }
6505	public function deserializeParameters ( $ type , $ data ) { $ jobType = $ this -> registry -> get ( $ type ) ; $ indices = $ jobType -> getIndicesOfSerializableParameters ( ) ; $ serializedParameters = json_decode ( $ data , 1 ) ; if ( false === $ serializedParameters ) { throw new \ RuntimeException ( sprintf ( 'Deserialization failed with error "%s"' , json_last_error_msg ( ) ) ) ; } if ( count ( $ indices ) < count ( $ serializedParameters ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The serialized data contains more parameters than defined for job "%s"' , $ type ) ) ; } $ parameters = array ( ) ; foreach ( $ serializedParameters as $ index => $ data ) { if ( null === $ data ) { $ parameters [ ] = null ; } else { $ parameters [ ] = $ this -> serializer -> deserialize ( $ data , $ jobType -> getParameterType ( $ indices [ $ index ] ) , 'json' , $ this -> getParamDeserializationContext ( $ jobType , $ indices [ $ index ] ) ) ; } } return $ parameters ; }
6515	public function consumeJob ( PlainMessage $ message ) { $ ticket = $ message -> ticket ; $ type = $ message -> type ; $ this -> logger -> debug ( 'Consume message from bernard backend' , [ 'message' => $ message ] ) ; $ this -> manager -> onMessage ( new Message ( $ type , $ ticket ) ) ; }
12839	static public function generateFilename ( $ directory , $ extension , $ length = 16 ) { do { $ name = \ Extlib \ Generator :: generate ( $ length ) ; $ filepath = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . sprintf ( '%s.%s' , $ name , $ extension ) ; } while ( file_exists ( $ filepath ) ) ; return $ name ; }
2782	public function renderShadowMark ( $ count , $ current , $ eolInterval = 60 ) { $ this -> progressCount ++ ; $ this -> write ( '<fg=blue;options=bold>S</fg=blue;options=bold>' , false ) ; if ( ( $ this -> progressCount % $ eolInterval ) == 0 ) { $ counter = str_pad ( $ this -> progressCount , 5 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( ' |' . $ counter . ' (' . str_pad ( $ current , strlen ( $ count ) , ' ' , STR_PAD_LEFT ) . '/' . $ count . ')' . PHP_EOL , false ) ; } }
7152	public function copy ( SubjectIdentity $ identity ) { $ this -> provider = $ identity -> getProvider ( ) ; $ this -> identifier = $ identity -> getIdentifier ( ) ; }
2484	protected function getAllSearchTargets ( ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = [ ] ; $ searchTargets = $ this -> endpointResolver -> getEndpoints ( ) ; if ( ! empty ( $ searchTargets ) ) { foreach ( $ searchTargets as $ endpointName ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
5741	protected static function prefixData ( $ data ) { $ prefixedData = array ( ) ; foreach ( $ data as $ stat => $ value ) { $ prefixedKey = self :: prefix ( $ stat ) ; $ prefixedData [ $ prefixedKey ] = $ value ; } return $ prefixedData ; }
8837	private function hasExceededTimeout ( ) : bool { return - 1 !== $ this -> timeout && ( microtime ( true ) - $ this -> startTime ) * 1000000 > $ this -> timeout ; }
11476	public function authenticate ( Zend_Auth_Adapter_Interface $ adapter ) { $ result = $ adapter -> authenticate ( ) ; if ( $ this -> hasIdentity ( ) ) { $ this -> clearIdentity ( ) ; } if ( $ result -> isValid ( ) ) { $ this -> getStorage ( ) -> write ( $ adapter -> getResultRowObject ( ) ) ; } return $ result ; }
1672	public function protect ( ) { if ( ! $ this -> isUnprotected ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.public' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot protect folder "%s" because one of its parent folders is public' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.public' ) ) -> delete ( ) ; }
12533	public function bindLocation ( array $ deviceIdentifier , $ poiId , $ type = 1 , $ poiAppid = null ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'poi_id' => intval ( $ poiId ) , ] ; if ( $ type === 2 ) { if ( is_null ( $ poiAppid ) ) { throw new InvalidArgumentException ( 'If value of argument #3 is 2, argument #4 is required.' ) ; } $ params [ 'type' ] = 2 ; $ params [ 'poi_appid' ] = $ poiAppid ; } return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_BINDLOCATION , $ params ] ) ; }
3164	public function endTimer ( RunnerServiceContext $ context , $ duration = null , $ timestamp = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ session -> endItemTimer ( $ duration , $ timestamp ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'endTimer' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
9012	public function text ( string $ charset = null ) : self { $ this -> type = 'text' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
4665	public function createMessage ( ) { $ eventsManager = $ this -> getEventsManager ( ) ; if ( $ eventsManager ) { $ eventsManager -> fire ( 'mailer:beforeCreateMessage' , $ this ) ; } $ message = $ this -> getDI ( ) -> get ( '\Baka\Mail\Message' , [ $ this ] ) ; if ( ( $ from = $ this -> getConfig ( 'from' ) ) ) { $ message -> from ( $ from [ 'email' ] , isset ( $ from [ 'name' ] ) ? $ from [ 'name' ] : null ) ; } if ( $ eventsManager ) { $ eventsManager -> fire ( 'mailer:afterCreateMessage' , $ this , $ message ) ; } return $ message ; }
11459	public function attachFile ( string $ sFileName , string $ sContent , string $ sType ) : bool { $ this -> _aAttachments [ ] = array ( "name" => $ sFileName , "content" => $ sContent , "type" => $ sType ) ; return true ; }
1127	public function isAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) < $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; }
3763	private function getLegendProperty ( LegendInterface $ legend , $ propertyName ) { if ( $ legend -> hasProperty ( $ propertyName ) ) { $ property = $ legend -> getProperty ( $ propertyName ) ; } else { $ property = new Property ( $ propertyName ) ; $ legend -> addProperty ( $ property ) ; } return $ property ; }
8955	public function createRelation ( $ changeset , $ tags , $ members ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'relation/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ memberList = '' ; if ( ! empty ( $ members ) ) { foreach ( $ members as $ member ) { if ( $ member [ 'type' ] == 'node' ) { $ memberList .= '<member type="' . $ member [ 'type' ] . '" role="' . $ member [ 'role' ] . '" ref="' . $ member [ 'ref' ] . '"/>' ; } elseif ( $ member [ 'type' ] == 'way' ) { $ memberList .= '<member type="' . $ member [ 'type' ] . '" ref="' . $ member [ 'ref' ] . '"/>' ; } } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <relation relation="' . $ changeset . '" >' . $ tagList . $ memberList . '</relation> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
2265	public function fieldExists ( $ strField , $ strTable , $ blnNoCache = false ) { if ( $ strField == '' || $ strTable == '' ) { return false ; } foreach ( $ this -> listFields ( $ strTable , $ blnNoCache ) as $ arrField ) { if ( $ arrField [ 'name' ] == $ strField && $ arrField [ 'type' ] != 'index' ) { return true ; } } return false ; }
8752	public function addDefinition ( $ identifier , DefinitionInterface $ definition ) { $ this -> definitions [ $ identifier ] = $ definition ; unset ( $ this -> dumpableDefinitions [ $ identifier ] ) ; }
8169	public static function register ( $ prepend = false ) { @ trigger_error ( 'Using Twig_Autoloader is deprecated since version 1.21. Use Composer instead.' , E_USER_DEPRECATED ) ; if ( PHP_VERSION_ID < 50300 ) { spl_autoload_register ( array ( __CLASS__ , 'autoload' ) ) ; } else { spl_autoload_register ( array ( __CLASS__ , 'autoload' ) , true , $ prepend ) ; } }
11882	private function prepareFieldOptions ( CustomField $ customField , $ type ) { $ options = $ customField -> getOptions ( ) ; $ fieldOptions = array ( ) ; $ fieldOptions [ 'required' ] = False ; $ fieldOptions [ 'label' ] = $ this -> translatableStringHelper -> localize ( $ customField -> getName ( ) ) ; if ( $ options [ self :: MIN ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new GreaterThanOrEqual ( array ( 'value' => $ options [ self :: MIN ] ) ) ; } if ( $ options [ self :: MAX ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new LessThanOrEqual ( array ( 'value' => $ options [ self :: MAX ] ) ) ; } if ( $ type === 'number' ) { $ fieldOptions [ 'scale' ] = $ options [ self :: SCALE ] ; } if ( ! empty ( $ options [ self :: POST_TEXT ] ) ) { $ fieldOptions [ 'post_text' ] = $ options [ self :: POST_TEXT ] ; } return $ fieldOptions ; }
12283	public function render ( array $ data = null ) : string { $ this -> init ( $ data ?? [ ] ) ; return trim ( $ this -> make ( static :: LAYOUT_NAME ) ) . PHP_EOL ; }
10763	public function setPaymentType ( $ paymentType ) { if ( self :: PAYMENT_PEER_TO_PEER !== $ paymentType ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid payment type.' ) ) ; } return $ this -> add ( 'PT' , $ paymentType ) ; }
2060	public function scheduleUpdate ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord || ! $ dc -> activeRecord -> id || Contao \ Input :: get ( 'act' ) == 'copy' ) { return ; } $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; $ session [ ] = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> id ) -> rootId ; $ objSession -> set ( 'sitemap_updater' , array_unique ( $ session ) ) ; }
11592	public function getFullPath ( $ file = '' ) { $ this -> name = ( $ file ) ? $ file : $ this -> name ; return config ( 'odin.assetsUrl' ) . $ this -> getPath ( ) . $ this -> name ; }
9344	public function addCol ( $ arr_col ) { if ( isset ( $ this -> arr [ 0 ] ) && ( count ( $ this -> arr [ 0 ] ) == $ this -> size -> cols ) ) { throw new \ OutOfRangeException ( sprintf ( 'You cannot add another column! Max number of columns is %d' , $ this -> size -> cols ) ) ; } if ( count ( $ arr_col ) != $ this -> size -> rows ) { throw new \ InvalidArgumentException ( 'New column must have same amout of rows than previous columns.' ) ; } $ arr_col = array_values ( $ arr_col ) ; foreach ( $ arr_col as $ k => $ v ) { $ this -> arr [ $ k ] [ ] = $ arr_col [ $ k ] ; } return $ this ; }
3496	private function doSend ( Receiver $ receiver , Notification $ notification , bool $ sandbox ) : void { $ payloadEncoded = $ this -> payloadEncoder -> encode ( $ notification -> getPayload ( ) ) ; $ uri = $ this -> uriFactory -> create ( $ receiver -> getToken ( ) , $ sandbox ) ; $ request = new Request ( $ uri , $ payloadEncoded ) ; $ headers = [ 'content-type' => 'application/json' , 'accept' => 'application/json' , 'apns-topic' => $ receiver -> getTopic ( ) , ] ; $ request = $ request -> withHeaders ( $ headers ) ; $ request = $ this -> authenticator -> authenticate ( $ request ) ; $ request = $ this -> visitor -> visit ( $ notification , $ request ) ; $ response = $ this -> httpSender -> send ( $ request ) ; if ( $ response -> getStatusCode ( ) !== 200 ) { throw $ this -> exceptionFactory -> create ( $ response ) ; } }
6243	public function isInOpenBasedir ( ) : bool { if ( ! $ this -> loaded ) { $ this -> resolvePath ( ) ; } static $ openBaseDirs = null ; if ( $ openBaseDirs === null ) { $ openBaseDirs = array_filter ( explode ( ':' , trim ( ini_get ( 'open_basedir' ) ) ) , function ( $ dir ) : bool { return ! empty ( $ dir ) ; } ) ; } if ( empty ( $ openBaseDirs ) ) { return true ; } foreach ( ( array ) $ openBaseDirs as $ dir ) { $ dir = realpath ( $ dir ) ; if ( stripos ( $ this -> raw , $ dir ) === 0 ) { return true ; } } return false ; }
10669	public static function fromArray ( $ input , array $ options = [ ] ) { if ( ! \ is_array ( $ input ) || \ count ( $ input ) !== 1 ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid input.' ) ) ; } $ key = key ( $ input ) ; if ( \ is_int ( $ key ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'The key of input must be alphanumeric.' ) ) ; } if ( ! \ is_array ( $ options ) ) { $ options = [ 'format' => ( string ) $ options ] ; } $ defaults = [ 'format' => 'tags' , 'version' => '1.0' , 'encoding' => 'utf-8' , 'return' => 'simplexml' , ] ; $ options = array_merge ( $ defaults , $ options ) ; $ dom = new \ DOMDocument ( $ options [ 'version' ] , $ options [ 'encoding' ] ) ; self :: _fromArray ( $ dom , $ dom , $ input , $ options [ 'format' ] ) ; $ options [ 'return' ] = strtolower ( $ options [ 'return' ] ) ; if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ dom -> saveXML ( ) ) ; } return $ dom ; }
9677	public function allBorders ( Spreadsheet $ spreadsheet ) { $ aBorders = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aBorders [ $ style -> getBorders ( ) -> getHashCode ( ) ] ) ) { $ aBorders [ $ style -> getBorders ( ) -> getHashCode ( ) ] = $ style -> getBorders ( ) ; } } return $ aBorders ; }
2211	public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ arrReturn = array ( ) ; while ( ( $ arrRow = $ this -> fetchAssoc ( ) ) !== false ) { if ( $ strKey != 'id' && isset ( $ arrRow [ 'id' ] ) ) { $ arrReturn [ $ arrRow [ 'id' ] ] = $ arrRow [ $ strKey ] ; } else { $ arrReturn [ ] = $ arrRow [ $ strKey ] ; } } return $ arrReturn ; }
10213	public function getSharedComponent ( ) { switch ( $ this -> parentPropertyName ) { case 'allBorders' : case 'horizontal' : case 'inside' : case 'outline' : case 'vertical' : throw new PhpSpreadsheetException ( 'Cannot get shared component for a pseudo-border.' ) ; break ; case 'bottom' : return $ this -> parent -> getSharedComponent ( ) -> getBottom ( ) ; case 'diagonal' : return $ this -> parent -> getSharedComponent ( ) -> getDiagonal ( ) ; case 'left' : return $ this -> parent -> getSharedComponent ( ) -> getLeft ( ) ; case 'right' : return $ this -> parent -> getSharedComponent ( ) -> getRight ( ) ; case 'top' : return $ this -> parent -> getSharedComponent ( ) -> getTop ( ) ; } }
8855	public function getArchiveDate ( ) { $ year = $ this -> getArchiveYear ( ) ; $ month = $ this -> getArchiveMonth ( ) ; $ day = $ this -> getArchiveDay ( ) ; if ( $ year ) { if ( $ month ) { $ date = $ year . '-' . $ month . '-01' ; if ( $ day ) { $ date = $ year . '-' . $ month . '-' . $ day ; } } else { $ date = $ year . '-01-01' ; } return DBField :: create_field ( "Date" , $ date ) ; } }
3782	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ image = '<img src="' . $ this -> attributeFactory -> getIconForType ( $ type ) . '" />' ; $ metaModel = $ this -> getMetaModelByModelPid ( $ model ) ; $ attribute = $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ metaModel ) ; if ( ! $ attribute ) { $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> <strong>%s</strong><br /> </div>' ) -> setArgs ( array ( $ translator -> translate ( 'error_unknown_attribute.0' , 'tl_metamodel_attribute' ) , $ type , $ translator -> translate ( 'error_unknown_attribute.1' , 'tl_metamodel_attribute' , array ( $ type ) ) , ) ) ; return ; } $ colName = $ attribute -> getColName ( ) ; $ name = $ attribute -> getName ( ) ; $ arrDescription = StringUtil :: deserialize ( $ attribute -> get ( 'description' ) ) ; if ( is_array ( $ arrDescription ) ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getActiveLanguage ( ) ] ; if ( ! $ description ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; } } else { $ description = $ arrDescription ? : $ attribute -> getName ( ) ; } $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong> - %s </div>' ) -> setArgs ( array ( $ colName , $ type , $ image , $ name , $ description ) ) ; }
5755	public function select ( ? string $ columns = "*" , ? array $ whereColumnsInfo = null , ? string $ orderBy = null ) : ? array { if ( $ whereColumnsInfo != null ) { $ this -> validateWhere ( $ whereColumnsInfo ) ; } if ( is_array ( $ whereColumnsInfo ) && array_key_exists ( 'roles.role' , $ whereColumnsInfo ) ) { return $ this -> selectWithRoleSubquery ( $ columns , $ whereColumnsInfo , $ orderBy ) ; } $ columns = $ columns ?? $ this -> defaultSelectColumnsString ; $ orderBy = $ orderBy ?? $ this -> getOrderBy ( ) ; $ q = new SelectBuilder ( "SELECT $columns" , $ this -> getFromClause ( ) , $ whereColumnsInfo , $ orderBy ) ; $ pgResult = $ q -> execute ( ) ; if ( ! $ results = pg_fetch_all ( $ pgResult ) ) { $ results = null ; } pg_free_result ( $ pgResult ) ; return $ results ; }
1962	public static function decodeEmail ( $ strEmail ) { if ( $ strEmail == '' ) { return '' ; } if ( strpos ( $ strEmail , '@' ) === false ) { return $ strEmail ; } $ arrChunks = explode ( '@' , $ strEmail ) ; $ strHost = static :: decode ( array_pop ( $ arrChunks ) ) ; if ( $ strHost == '' ) { return '' ; } return implode ( '@' , $ arrChunks ) . '@' . $ strHost ; }
5622	protected function chompPath ( & $ url ) { if ( preg_match ( '/(.*?)(\?|#|$)(.*)/' , $ url , $ matches ) ) { $ url = $ matches [ 2 ] . $ matches [ 3 ] ; return ( $ matches [ 1 ] ? $ matches [ 1 ] : '' ) ; } return '' ; }
12481	public function registerServices ( ServicesFactory $ servicesFactory , array $ entityManagers ) { foreach ( $ entityManagers as $ name => $ entityManager ) { $ emConfig = Setup :: createAnnotationMetadataConfiguration ( ( array ) $ entityManager -> getEntities ( ) , true , null , null , true ) ; $ emConfig -> setNamingStrategy ( new UnderscoreNamingStrategy ( ) ) ; $ em = $ this -> createEntityManager ( $ entityManager -> toArray ( ) , $ emConfig ) ; $ emServiceId = 'doctrine.em.' . Str :: cast ( $ name ) -> lower ( ) ; $ servicesFactory -> registerService ( [ 'id' => $ emServiceId , 'instance' => $ em ] ) ; $ servicesFactory -> registerService ( [ 'id' => 'db.connection.' . $ name , 'instance' => $ em -> getConnection ( ) -> getWrappedConnection ( ) ] ) ; } }
8912	protected function _fetch_primary_key ( ) { if ( $ this -> is_base_model_instance ( ) ) { return ; } if ( $ this -> primary_key == NULL && $ this -> _database ) { $ this -> primary_key = $ this -> execute_query ( "SHOW KEYS FROM `" . $ this -> _database -> dbprefix ( $ this -> _table ) . "` WHERE Key_name = 'PRIMARY'" ) -> row ( ) -> Column_name ; } }
10594	public function getViewData ( ) { if ( $ this -> view !== NULL ) return $ this -> view ; $ this -> view = new \ stdClass ; try { $ this -> initMainApplicationProperties ( ) ; if ( $ this -> router === NULL ) return $ this -> view ; $ this -> initViewPanelTitle ( ) ; $ this -> initViewPanelTableData ( ) ; $ this -> initViewPanelRequestedUrlData ( ) ; } catch ( \ Exception $ e ) { $ this -> _debug ( $ e ) ; $ this -> _debug ( $ e -> getTrace ( ) ) ; } $ this -> view -> _debugCode = $ this -> _debugCode ; return $ this -> view ; }
6821	protected function compare ( float $ a , float $ b ) { return Money :: compare ( $ a , $ b , $ this -> currency ) ; }
8268	public function open ( ) { if ( $ this -> isOpened ( ) ) { return ; } if ( ! file_exists ( $ this -> filePath ) ) { throw new \ RuntimeException ( $ this -> filePath . " does not exist" ) ; } $ this -> handle = @ fopen ( $ this -> filePath , self :: OPEN_MODE ) ; if ( $ this -> handle === false ) { throw new \ RuntimeException ( "Could not open file for reading: " . $ this -> filePath ) ; } if ( ! $ this -> lock ( LOCK_SH ) ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not aquire a shared lock for " . $ this -> filePath ) ; } }
7579	protected function configureDefaultData ( array $ data ) { foreach ( $ this -> _REQUIRED_DATA as $ property => $ value ) { if ( ! isset ( $ data [ $ property ] ) && $ value !== null ) { $ data [ $ property ] = $ value ; } } return $ data ; }
2476	private function logWarning ( OutputInterface $ output , ProgressBar $ progress , $ message ) { $ progress -> clear ( ) ; $ this -> logger -> warning ( $ message ) ; $ progress -> display ( ) ; }
10734	public function setLower ( $ lower ) : self { if ( ! is_numeric ( $ lower ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, lower, to be a number" ) ; } $ this -> lower = + $ lower ; return $ this ; }
4486	public function broadcast ( Message $ message , ? string $ platform = null ) { if ( null !== $ platform && ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } if ( $ platform ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } else { foreach ( $ this -> arns as $ platform => $ arn ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } } }
9150	public function fetchAll ( $ columns = null , \ Closure $ Closure = null ) { $ select = $ this -> getSelect ( ) ; if ( $ columns ) { $ select -> columns ( $ columns ) ; } if ( $ Closure ) { $ Closure ( $ select ) ; } return $ this -> select ( $ select ) ; }
8033	public function loadView ( $ viewName , $ data = array ( ) , $ mergeData = array ( ) ) { $ this -> htmlContent = View :: make ( $ viewName , $ data , $ mergeData ) ; return $ this ; }
4208	private function isObjExcluded ( $ obj ) { if ( \ in_array ( \ get_class ( $ obj ) , $ this -> abstracter -> getCfg ( 'objectsExclude' ) ) ) { return true ; } foreach ( $ this -> abstracter -> getCfg ( 'objectsExclude' ) as $ exclude ) { if ( \ is_subclass_of ( $ obj , $ exclude ) ) { return true ; } } return false ; }
6000	public function setImagetemplates ( array $ imagetemplates ) { $ this -> imagetemplates = [ ] ; foreach ( $ imagetemplates as $ item ) { $ this -> addImageTemplate ( $ item ) ; } return $ this ; }
1914	protected function generateHashes ( $ sum ) { $ time = ( int ) round ( time ( ) / 60 / 30 ) ; return array_map ( function ( $ hashTime ) use ( $ sum ) { return hash_hmac ( 'sha256' , $ sum . "\0" . $ hashTime , System :: getContainer ( ) -> getParameter ( 'kernel.secret' ) ) ; } , array ( $ time , $ time - 1 ) ) ; }
1521	public function processes ( StoreInterface $ store , FetchProcesses $ request ) { $ result = $ store -> queryRecords ( $ request -> getProcessType ( ) , $ request -> getEncodingParameters ( ) ) ; return $ this -> reply ( ) -> content ( $ result ) ; }
10782	public function andHaving ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
7342	protected function scheduleSupplierOrderContentChangeEvent ( Model \ SupplierOrderInterface $ order ) { $ this -> persistenceHelper -> scheduleEvent ( SupplierOrderEvents :: CONTENT_CHANGE , $ order ) ; }
2521	public function pnrIgnore ( RequestOptions \ PnrIgnoreOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Ignore' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
2565	public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ queryAllErrorCodes = "//m:generalErrorGroup//m:errorNumber/m:errorDetails/m:errorCode" ; $ queryAllErrorMsg = "//m:generalErrorGroup/m:genrealErrorText/m:freeText" ; $ errorCodeNodeList = $ domXpath -> query ( $ queryAllErrorCodes ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( $ queryAllErrorMsg ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) ) ; } return $ analyzeResponse ; }
8845	public function build ( ContainerBuilder $ container ) { $ container -> addCompilerPass ( new ThemeCompilerPass ( ) , PassConfig :: TYPE_BEFORE_OPTIMIZATION , - 10 ) ; $ container -> addCompilerPass ( new ThemeProviderPass ( ) ) ; }
5213	private function getBinding ( $ type , $ name = null ) { $ binding = $ this -> findBinding ( $ type , $ name ) ; if ( null === $ binding ) { throw new BindingException ( 'No binding for ' . $ type . ' defined' ) ; } return $ binding ; }
2576	protected function mergeOptions ( $ existingOptions , $ newOptions ) { if ( ! empty ( $ newOptions ) ) { $ existingOptions = array_merge ( $ existingOptions , $ newOptions ) ; } return $ existingOptions ; }
6710	protected function parseHeader ( array $ headers = [ ] ) { $ processedHeaders = array ( ) ; foreach ( $ headers as $ key => $ value ) { if ( substr ( $ key , 0 , 5 ) == 'HTTP_' ) { $ name = str_replace ( ' ' , '-' , ucwords ( strtolower ( str_replace ( '_' , ' ' , substr ( $ key , 5 ) ) ) ) ) ; $ processedHeaders [ $ name ] = $ value ; } elseif ( $ key == 'CONTENT_TYPE' ) { $ processedHeaders [ 'Content-Type' ] = $ value ; } elseif ( $ key == 'CONTENT_LENGTH' ) { $ processedHeaders [ 'Content-Length' ] = $ value ; } } return $ processedHeaders ; }
11745	public function getShakeInfo ( $ ticket , $ needPoi = null ) { $ params = [ 'ticket' => $ ticket , ] ; if ( $ needPoi !== null ) { $ params [ 'need_poi' ] = intval ( $ needPoi ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_GET_SHAKE_INFO , $ params ] ) ; }
43	private function parsePackage ( $ packageInfo ) { $ packageInfo -> registerXPathNamespace ( 'ns' , self :: CATEGORY_PACKAGES_INFO_NS ) ; $ channelName = ( string ) $ packageInfo -> p -> c ; $ packageName = ( string ) $ packageInfo -> p -> n ; $ license = ( string ) $ packageInfo -> p -> l ; $ shortDescription = ( string ) $ packageInfo -> p -> s ; $ description = ( string ) $ packageInfo -> p -> d ; $ dependencies = array ( ) ; foreach ( $ packageInfo -> xpath ( 'ns:deps' ) as $ node ) { $ dependencyVersion = ( string ) $ node -> v ; $ dependencyArray = unserialize ( ( string ) $ node -> d ) ; $ dependencyInfo = $ this -> dependencyReader -> buildDependencyInfo ( $ dependencyArray ) ; $ dependencies [ $ dependencyVersion ] = $ dependencyInfo ; } $ releases = array ( ) ; $ releasesInfo = $ packageInfo -> xpath ( 'ns:a/ns:r' ) ; if ( $ releasesInfo ) { foreach ( $ releasesInfo as $ node ) { $ releaseVersion = ( string ) $ node -> v ; $ releaseStability = ( string ) $ node -> s ; $ releases [ $ releaseVersion ] = new ReleaseInfo ( $ releaseStability , isset ( $ dependencies [ $ releaseVersion ] ) ? $ dependencies [ $ releaseVersion ] : new DependencyInfo ( array ( ) , array ( ) ) ) ; } } return new PackageInfo ( $ channelName , $ packageName , $ license , $ shortDescription , $ description , $ releases ) ; }
9381	public function set ( $ id , $ concrete , $ share = false ) { return $ this -> add ( $ id , $ concrete , $ share ) ; }
1399	public function errors ( $ errors , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( $ errors instanceof ErrorResponseInterface ) { return $ this -> getErrorResponse ( $ errors ) ; } if ( is_array ( $ errors ) ) { $ errors = $ this -> api -> getErrors ( ) -> errors ( ... $ errors ) ; } return $ this -> errors ( $ this -> factory -> createErrorResponse ( $ errors , $ defaultStatusCode , $ headers ) ) ; }
7462	public function getContent ( string $ name , array $ data = [ ] ) : string { $ cacheName = $ name ; if ( '' == $ name ) { $ this -> isRouteView = true ; $ stack = debug_backtrace ( ) ; foreach ( $ stack as $ item ) { if ( false !== stripos ( $ item [ 'file' ] , DIRECTORY_SEPARATOR . 'Route' . DIRECTORY_SEPARATOR ) ) { $ cacheName = pathinfo ( $ item [ 'file' ] , PATHINFO_DIRNAME ) . '/' . $ name ; $ cacheName = explode ( 'Route' . DIRECTORY_SEPARATOR , $ cacheName ) [ 1 ] ; $ cacheName = 'route_' . str_replace ( [ '/' , '\\' ] , '_' , $ cacheName ) ; break ; } } } $ cacheName .= '_' . $ this -> language . '.html.php' ; $ path = $ this -> packageRoot . '/view/_cache/' . str_replace ( '/' , '_' , $ cacheName ) ; $ exist = file_exists ( $ path ) ; if ( ! $ this -> cache || ! $ exist ) { $ code = $ this -> compile ( $ name . '/view.html.php' , true , true , true ) ; $ code = preg_replace ( [ '/\>[^\S ]+/s' , '/[^\S ]+\</s' , '/(\s)+/s' ] , [ '>' , '<' , '\\1' ] , $ code ) ; if ( $ exist ) { $ fh = fopen ( $ path , 'r+b' ) ; } else { $ fh = fopen ( $ path , 'wb' ) ; } if ( flock ( $ fh , LOCK_EX ) ) { ftruncate ( $ fh , 0 ) ; fwrite ( $ fh , $ code ) ; flock ( $ fh , LOCK_UN ) ; } fclose ( $ fh ) ; } $ fh = fopen ( $ path , 'rb' ) ; if ( flock ( $ fh , LOCK_SH ) ) { $ html = self :: renderTemplate ( $ path , $ data ) ; flock ( $ fh , LOCK_UN ) ; fclose ( $ fh ) ; return $ html ; } throw new \ RuntimeException ( 'Can\'t render template' ) ; }
996	public function offsetExists ( $ offset ) { if ( $ offset === false ) { return $ this -> falseValueIsSet ; } if ( $ offset === true ) { return $ this -> trueValueIsSet ; } if ( is_int ( $ offset ) || is_string ( $ offset ) ) { return array_key_exists ( $ offset , $ this -> standardStore ) ; } if ( is_float ( $ offset ) ) { return array_key_exists ( ( string ) $ offset , $ this -> floatStore ) ; } if ( is_object ( $ offset ) ) { return $ this -> objectStore -> offsetExists ( $ offset ) ; } if ( is_array ( $ offset ) ) { foreach ( $ this -> arrayKeys as $ index => $ entry ) { if ( $ entry === $ offset ) { $ this -> lastArrayKey = $ offset ; $ this -> lastArrayValue = $ this -> arrayValues [ $ index ] ; return true ; } } } if ( $ offset === null ) { return $ this -> nullValueIsSet ; } return false ; }
9514	public function addFacetedQuery ( $ query , $ index , array $ keys ) { $ this -> AddQuery ( $ query , $ index ) ; $ currentOffset = $ this -> _offset ; $ mode = $ this -> _sort ; $ sortby = $ this -> _sortby ; $ limit = $ this -> _limit ; $ this -> _offset = 0 ; $ this -> _sort = 0 ; $ this -> _sortby = '' ; $ this -> SetLimits ( 0 , 999 ) ; foreach ( $ keys as $ key ) { $ this -> setGroupByAttr ( $ key ) ; $ this -> AddQuery ( $ query , $ index ) ; } $ this -> _offset = $ currentOffset ; $ this -> _sort = $ mode ; $ this -> _sortby = $ sortby ; $ this -> SetLimits ( $ currentOffset , $ limit ) ; }
8800	public function needsRehash ( $ hashedValue , array $ options = [ ] ) { return password_needs_rehash ( $ hashedValue , PASSWORD_ARGON2I , [ 'memory_cost' => $ this -> memory ( $ options ) , 'time_cost' => $ this -> time ( $ options ) , 'threads' => $ this -> threads ( $ options ) , ] ) ; }
1931	public function attachFileFromString ( $ strContent , $ strFilename , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( new \ Swift_Attachment ( $ strContent , $ strFilename , $ strMime ) ) ; }
6082	public function removeComment ( $ mediaId , $ commentId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/media/' . $ mediaId . '/comments/' . $ commentId . '' , $ parameters ) ; $ result = new Comment ( $ result ) ; return $ result ; }
1987	private function filterOptions ( array $ allowedSizes ) : array { if ( empty ( $ allowedSizes ) ) { return [ ] ; } $ filteredSizes = [ ] ; foreach ( $ this -> options as $ group => $ sizes ) { if ( 'image_sizes' === $ group ) { $ this -> filterImageSizes ( $ sizes , $ allowedSizes , $ filteredSizes , $ group ) ; } else { $ this -> filterResizeModes ( $ sizes , $ allowedSizes , $ filteredSizes , $ group ) ; } } return $ filteredSizes ; }
6773	protected function isTaxationUpdateNeeded ( SaleInterface $ sale ) { if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'taxExempt' , 'customer' , 'vatValid' ] ) ) { return true ; } return $ this -> didDeliveryCountryChanged ( $ sale ) ; }
6663	public function post ( $ url , $ params ) { if ( is_array ( $ params ) ) { $ params = $ this -> filterParams ( $ params ) ; } $ this -> lastRequestParams = $ params ; $ this -> lastRequestUrl = $ this -> buildUrl ( $ url ) ; return $ this -> curlAgent -> setOption ( CURLOPT_POSTFIELDS , $ params ) -> post ( $ this -> lastRequestUrl , $ this -> rawResponse ) ; }
12808	private static function getPrimaryKey ( string $ table ) : array { if ( self :: $ primaryKeyCache !== null && array_key_exists ( $ table , self :: $ primaryKeyCache ) ) return self :: $ primaryKeyCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'PRIMARY KEY' AND tc.table_name = '$table' " ; $ results = $ pdo -> query ( $ query ) ; self :: $ primaryKeyCache [ $ table ] = $ results -> fetch ( ) ; return self :: $ primaryKeyCache [ $ table ] ; }
4234	private static function splitParams ( $ paramStr ) { $ depth = 0 ; $ startPos = 0 ; $ chars = \ str_split ( $ paramStr ) ; $ params = array ( ) ; foreach ( $ chars as $ pos => $ char ) { switch ( $ char ) { case ',' : if ( $ depth === 0 ) { $ params [ ] = \ trim ( \ substr ( $ paramStr , $ startPos , $ pos - $ startPos ) ) ; $ startPos = $ pos + 1 ; } break ; case '[' : case '(' : $ depth ++ ; break ; case ']' : case ')' : $ depth -- ; break ; } } $ params [ ] = \ trim ( \ substr ( $ paramStr , $ startPos , $ pos + 1 - $ startPos ) ) ; return $ params ; }
9958	public function unprotectCells ( $ pRange ) { $ pRange = strtoupper ( $ pRange ) ; if ( isset ( $ this -> protectedCells [ $ pRange ] ) ) { unset ( $ this -> protectedCells [ $ pRange ] ) ; } else { throw new Exception ( 'Cell range ' . $ pRange . ' not known as protected.' ) ; } return $ this ; }
11914	public function addDynamic ( $ name , $ factory , $ createDefault = 0 , $ forceDefault = false ) { $ control = new RContainer ( $ factory , $ createDefault , $ forceDefault ) ; $ control -> currentGroup = $ this -> currentGroup ; return $ this [ $ name ] = $ control ; }
10885	protected function makeRequest ( $ data ) { $ url = 'https://www.errorstream.com/api/1.0/errors/create?' . http_build_query ( [ 'api_token' => $ this -> api_token , 'project_token' => $ this -> project_token ] ) ; try { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_POST , true ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , json_encode ( $ data ) ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-Type:application/json' ) ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; $ result = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ result ; } catch ( \ Exception $ ex ) { return $ ex -> getMessage ( ) ; } }
9523	private function getConfig ( ) { $ yaml = new Parser ( ) ; $ configFile = getenv ( 'TRAVIS_BUILD_DIR' ) . '/.travis.yml' ; $ config = $ yaml -> parse ( file_get_contents ( $ configFile ) ) ; $ config = $ config [ 'travisdeployer' ] ; $ this -> branches = $ config [ 'branches' ] ; if ( count ( $ this -> branches ) === 0 ) { die ( 'No branches are configured to deploy to.' . PHP_EOL ) ; } $ this -> verbose = filter_input ( FILTER_VALIDATE_BOOLEAN , $ config [ 'verbose' ] ) ; }
1250	public function parse ( $ xml ) { $ parser = xml_parser_create_ns ( 'UTF-8' , '@' ) ; xml_parser_set_option ( $ parser , XML_OPTION_CASE_FOLDING , 0 ) ; xml_parser_set_option ( $ parser , XML_OPTION_SKIP_WHITE , 1 ) ; xml_set_object ( $ parser , $ this ) ; xml_set_element_handler ( $ parser , 'startElement' , 'endElement' ) ; xml_set_character_data_handler ( $ parser , 'cdata' ) ; xml_parse ( $ parser , $ xml , true ) ; xml_parser_free ( $ parser ) ; return $ this -> rootObject ; }
9359	protected function finalize ( $ function ) { $ response = $ this -> container -> get ( self :: RESPONSE ) ; if ( is_string ( $ function ) === true ) { $ stream = $ response -> getBody ( ) ; $ stream -> write ( ( string ) $ function ) ; } $ instanceof = $ function instanceof ResponseInterface ; return $ instanceof ? $ function : $ response ; }
5500	protected function replaceWildcards ( $ args ) { if ( $ args === false ) { return false ; } for ( $ i = 0 ; $ i < count ( $ args ) ; $ i ++ ) { if ( $ args [ $ i ] === $ this -> wildcard ) { $ args [ $ i ] = new AnythingExpectation ( ) ; } } return $ args ; }
3505	private function convertApsToArray ( Aps $ aps ) : array { $ data = [ 'alert' => $ this -> convertAlertToArray ( $ aps -> getAlert ( ) ) , ] ; if ( $ aps -> getSound ( ) ) { $ data [ 'sound' ] = $ aps -> getSound ( ) ; } if ( $ aps -> getBadge ( ) !== null ) { $ data [ 'badge' ] = $ aps -> getBadge ( ) ; } if ( $ aps -> getCategory ( ) ) { $ data [ 'category' ] = $ aps -> getCategory ( ) ; } if ( $ aps -> isContentAvailable ( ) ) { $ data [ 'content-available' ] = 1 ; } if ( $ aps -> isMutableContent ( ) ) { $ data [ 'mutable-content' ] = 1 ; } if ( $ aps -> getThreadId ( ) ) { $ data [ 'thread-id' ] = $ aps -> getThreadId ( ) ; } return $ data ; }
9690	public function render ( $ file , $ env = array ( ) ) { $ file = $ this -> views_path . '/' . $ file ; if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } $ cacheHash = md5 ( $ file . serialize ( $ env ) ) ; $ cache_file = $ this -> views_cache . "/$cacheHash.cache" ; if ( ! $ this -> debug && ( file_exists ( $ cache_file ) && filemtime ( $ cache_file ) > filemtime ( $ file ) ) ) { return file_get_contents ( $ cache_file ) ; } $ this -> currFile = $ file ; $ hash = md5 ( $ file ) ; $ this -> compile ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; set_error_handler ( array ( $ this , 'onTemplateError' ) ) ; require_once ( $ compiled_file ) ; $ output = call_user_func ( 'katar_' . $ hash , $ env ) ; restore_error_handler ( ) ; file_put_contents ( $ cache_file , $ output ) ; return $ output ; }
1296	private function getUnresolvedField ( Field $ field , string $ locale = null ) { if ( ! isset ( $ this -> fields [ $ field -> getId ( ) ] ) ) { return 'Array' === $ field -> getType ( ) ? [ ] : null ; } $ value = $ this -> fields [ $ field -> getId ( ) ] ; $ locale = $ this -> getLocaleFromInput ( $ locale ) ; if ( \ array_key_exists ( $ locale , $ value ) ) { return $ value [ $ locale ] ; } if ( ! $ field -> isLocalized ( ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to access the non-localized field "%s" on content type "%s" using the non-default locale "%s".' , $ field -> getName ( ) , $ this -> sys -> getContentType ( ) -> getName ( ) , $ locale ) ) ; } $ locale = $ this -> walkFallbackChain ( $ value , $ locale , $ this -> sys -> getEnvironment ( ) ) ; if ( $ locale ) { return $ value [ $ locale ] ; } return 'Array' === $ field -> getType ( ) ? [ ] : null ; }
5564	protected function loadFrame ( $ frames , $ url , $ parameters ) { $ page = $ this -> fetch ( $ url , $ parameters ) ; $ this -> page -> setFrame ( $ frames , $ page ) ; return $ page -> getRaw ( ) ; }
1053	public static function buildAST ( DocumentNode $ ast , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ builder = new self ( $ ast , $ typeConfigDecorator , $ options ) ; return $ builder -> buildSchema ( ) ; }
12006	final public function getAuthorityTree ( ) { $ database = $ this -> database ; $ statement = $ database -> select ( ) -> from ( '?authority' ) -> between ( "lft" , '1' , '6' ) -> prepare ( ) ; $ results = $ statement -> execute ( ) ; $ right = array ( ) ; }
10250	public function getDln ( $ state_code = null , $ min = 900000001 , $ max = 999999999 ) { $ dln = new Entities \ DriverLicense ( ) ; $ dln -> number = rand ( $ min , $ max ) ; $ dln -> state = ! empty ( $ state_code ) ? $ state_code : $ this -> getState ( ) ; $ dln -> expiration = $ this -> getExpiration ( ) ; return $ dln ; }
9865	private function writeHyperlinks ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ hyperlinkCollection = $ pSheet -> getHyperlinkCollection ( ) ; $ relationId = 1 ; if ( ! empty ( $ hyperlinkCollection ) ) { $ objWriter -> startElement ( 'hyperlinks' ) ; foreach ( $ hyperlinkCollection as $ coordinate => $ hyperlink ) { $ objWriter -> startElement ( 'hyperlink' ) ; $ objWriter -> writeAttribute ( 'ref' , $ coordinate ) ; if ( ! $ hyperlink -> isInternal ( ) ) { $ objWriter -> writeAttribute ( 'r:id' , 'rId_hyperlink_' . $ relationId ) ; ++ $ relationId ; } else { $ objWriter -> writeAttribute ( 'location' , str_replace ( 'sheet://' , '' , $ hyperlink -> getUrl ( ) ) ) ; } if ( $ hyperlink -> getTooltip ( ) != '' ) { $ objWriter -> writeAttribute ( 'tooltip' , $ hyperlink -> getTooltip ( ) ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
9328	protected function registerMarkdownPhpEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.php.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownPhpCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown.php' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.php.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md.php' , 'markdown.php' ) ; }
1577	protected function validateDocumentCompliance ( $ document , ? ValidatorFactoryInterface $ validators ) : void { $ this -> passes ( $ this -> factory -> createNewResourceDocumentValidator ( $ document , $ this -> getResourceType ( ) , $ validators && $ validators -> supportsClientIds ( ) ) ) ; }
2755	public function onImport ( ImportEvent $ event ) { $ uuids = [ '0bd5c257-2231-450f-b4c2-ab156af7b78d' , '36b2e2b2-3df0-43eb-a282-d792b0999c07' , '94ad928b-3ec8-4bcb-b617-ab1607bf69cb' , 'bbb1ee17-15f8-46bd-9df5-21c58040d741' , ] ; foreach ( $ event -> getImportedEntities ( ) as $ entity ) { if ( in_array ( $ entity -> uuid ( ) , $ uuids ) ) { $ entity -> moderation_state -> value = 'published' ; $ entity -> save ( ) ; } } }
7667	function InlineImageExists ( ) { $ result = false ; for ( $ i = 0 ; $ i < count ( $ this -> attachment ) ; $ i ++ ) { if ( $ this -> attachment [ $ i ] [ 6 ] == "inline" ) { $ result = true ; break ; } } return $ result ; }
5335	protected function sha512Asn1 ( $ data ) { $ digest = hash ( 'sha512' , $ data , true ) ; $ asn1 = chr ( 0x30 ) . chr ( 0x51 ) ; $ asn1 .= chr ( 0x30 ) . chr ( 0x0d ) ; $ asn1 .= chr ( 0x06 ) . chr ( 0x09 ) ; $ asn1 .= chr ( 0x60 ) . chr ( 0x86 ) . chr ( 0x48 ) . chr ( 0x01 ) . chr ( 0x65 ) ; $ asn1 .= chr ( 0x03 ) . chr ( 0x04 ) ; $ asn1 .= chr ( 0x02 ) . chr ( 0x03 ) ; $ asn1 .= chr ( 0x05 ) . chr ( 0x00 ) ; $ asn1 .= chr ( 0x04 ) . chr ( 0x40 ) ; $ asn1 .= $ digest ; return $ asn1 ; }
12725	public function format ( $ event ) { $ output = $ this -> format ; if ( array_key_exists ( 'extra' , $ event ) === true ) { $ this -> formatExtra ( $ event , $ event [ 'extra' ] ) ; $ event [ 'message' ] = 'Missing Key:' ; } else { $ event [ 'extra' ] = [ ] ; } foreach ( $ event as $ name => $ value ) { if ( is_array ( $ value ) === true && count ( $ value ) === 0 ) { $ value = '' ; } else { $ value = $ this -> normalize ( $ value ) ; } $ output = str_replace ( '%' . $ name . '%' , $ value , $ output ) ; } return trim ( $ output ) ; }
2709	public function beforeSave ( \ Magento \ Config \ Model \ Config $ subject ) { $ data = $ subject -> getData ( ) ; if ( ! empty ( $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ) ) { $ currentCacheConfig = $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ; $ oldCacheConfig = $ this -> scopeConfig -> getValue ( \ Magento \ PageCache \ Model \ Config :: XML_PAGECACHE_TYPE ) ; if ( $ oldCacheConfig == \ Fastly \ Cdn \ Model \ Config :: FASTLY && $ currentCacheConfig != $ oldCacheConfig ) { $ this -> purge = true ; } } }
4992	protected function mapEntity ( $ form , $ entity , $ property ) { if ( false === $ property ) { return ; } if ( true === $ property ) { $ mapEntity = $ entity ; } elseif ( $ entity -> hasProperty ( $ property ) || is_callable ( [ $ entity , "get$property" ] ) ) { $ getter = "get$property" ; $ mapEntity = $ entity -> $ getter ( ) ; } else { return ; } if ( $ form instanceof Container ) { $ form -> setEntity ( $ mapEntity ) ; } else { $ form -> bind ( $ mapEntity ) ; } }
9364	public function substract ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return $ this -> add ( $ z -> negative ( ) ) ; }
2205	public static function findPost ( $ strKey ) { if ( isset ( $ _POST [ $ strKey ] ) ) { return $ _POST [ $ strKey ] ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getMasterRequest ( ) ; if ( $ request === null || ! $ request -> hasPreviousSession ( ) ) { return null ; } if ( isset ( $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ) ) { return ( $ strKey == 'FORM_SUBMIT' ) ? preg_replace ( '/^auto_/i' , '' , $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ) : $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ; } return null ; }
1035	private function completeLeafValue ( LeafType $ returnType , & $ result ) { try { return $ returnType -> serialize ( $ result ) ; } catch ( Exception $ error ) { throw new InvariantViolation ( 'Expected a value of type "' . Utils :: printSafe ( $ returnType ) . '" but received: ' . Utils :: printSafe ( $ result ) , 0 , $ error ) ; } catch ( Throwable $ error ) { throw new InvariantViolation ( 'Expected a value of type "' . Utils :: printSafe ( $ returnType ) . '" but received: ' . Utils :: printSafe ( $ result ) , 0 , $ error ) ; } }
3199	protected function getRange ( $ tags ) { $ range = $ this -> timeLine -> find ( $ tags , TimePoint :: TARGET_SERVER ) ; TimePoint :: sort ( $ range ) ; return $ range ; }
10323	private function createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source , $ embedFieldBackups ) { $ queryParameters = array ( 'page_index' => $ pageIndex , 'page_size' => $ pageSize ) ; if ( isset ( $ fromDate ) ) $ queryParameters [ 'from_date' ] = $ fromDate ; if ( isset ( $ toDate ) ) $ queryParameters [ 'to_date' ] = $ toDate ; if ( isset ( $ source ) ) $ queryParameters [ 'source' ] = $ source ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "ids" , $ contactIds ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "emails" , $ contactEmails ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "eids" , $ contactExternalIds ) ; if ( isset ( $ embedFieldBackups ) ) $ queryParameters [ 'embed_field_backups' ] = ( $ embedFieldBackups == true ) ? "true" : "false" ; if ( isset ( $ mailingIds ) ) { $ queryParameters [ 'mailing_id' ] = array ( ) ; foreach ( $ mailingIds as $ mailingId ) { $ queryParameters [ 'mailing_id' ] [ ] = $ mailingId ; } } return $ queryParameters ; }
10308	private function setGlowSize ( $ size ) { if ( $ size !== null ) { $ this -> glowProperties [ 'size' ] = $ this -> getExcelPointsWidth ( $ size ) ; } return $ this ; }
7274	protected function decodeValue ( $ val , $ column = "" ) { if ( $ column === static :: $ idColumn ) $ val = ( int ) $ val ; else if ( isset ( static :: $ casts [ $ column ] ) ) { switch ( static :: $ casts [ $ column ] ) { case "object" : $ val = from_json ( $ val , false ) ; break ; case "array" : $ val = from_json ( $ val , true ) ; break ; default : settype ( $ val , static :: $ casts [ $ column ] ) ; } } else if ( in_array ( $ column , static :: $ jsons ) && is_string ( $ val ) ) $ val = from_json ( $ val ) ; return $ val ; }
11714	public function getTokenFromServer ( ) { $ params = [ 'appid' => $ this -> appId , 'secret' => $ this -> secret , 'grant_type' => 'client_credential' , ] ; $ http = $ this -> getHttp ( ) ; $ token = $ http -> parseJSON ( $ http -> get ( self :: API_TOKEN_GET , $ params ) ) ; if ( empty ( $ token [ $ this -> tokenJsonKey ] ) ) { throw new HttpException ( 'Request AccessToken fail. response: ' . json_encode ( $ token , JSON_UNESCAPED_UNICODE ) ) ; } return $ token ; }
9776	function throw ( string $ className = '' ) : self { if ( ! is_callable ( $ this -> target ) ) throw new \ BadMethodCallException ( 'The function target is not callable.' ) ; $ exception = null ; try { call_user_func ( $ this -> target ) ; } catch ( \ Throwable $ e ) { $ exception = $ e ; } $ constraint = logicalNot ( isNull ( ) ) ; return $ this -> expect ( $ exception , mb_strlen ( $ className ) ? logicalAnd ( $ constraint , isInstanceOf ( $ className ) ) : $ constraint ) ; }
8532	private function _convertListFinancialEventsByNextToken ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventsByNextToken' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetNextToken ( ) ) { $ parameters [ 'NextToken' ] = $ request -> getNextToken ( ) ; } return $ parameters ; }
3196	public function getConsumedExtraTime ( $ tags = null , $ maxTime = 0 , $ target = TimePoint :: TARGET_SERVER ) { if ( $ maxTime ) { $ totalConsumed = $ this -> compute ( $ tags , $ target ) ; $ consumedExtraTime = $ totalConsumed - $ maxTime < 0 ? 0 : $ totalConsumed - $ maxTime ; $ this -> setConsumedExtraTime ( $ consumedExtraTime ) -> save ( ) ; } return $ this -> consumedExtraTime ; }
10954	protected function ifNoneMatch ( Request $ request , Response $ response , string $ etag ) : Response { $ ifNoneMatch = $ request -> getHeaderLine ( 'If-None-Match' ) ; if ( $ ifNoneMatch && $ etag === $ ifNoneMatch ) { return $ response -> withStatus ( 304 , "Not Modified" ) ; } return $ response ; }
9096	public function update ( ) { hypePrototyper ( ) -> prototype -> saveStickyValues ( $ this -> action ) ; foreach ( $ this -> fields as $ field ) { if ( $ field -> getDataType ( ) == 'attribute' ) { $ this -> entity = $ field -> handle ( $ this -> entity ) ; } } if ( ! $ this -> entity -> save ( ) ) { return false ; } foreach ( $ this -> fields as $ field ) { if ( $ field -> getDataType ( ) !== 'attribute' ) { $ this -> entity = $ field -> handle ( $ this -> entity ) ; } } if ( ! $ this -> entity -> save ( ) ) { return false ; } hypePrototyper ( ) -> prototype -> clearStickyValues ( $ this -> action ) ; return $ this -> entity ; }
12593	public function setOperator ( $ operator ) { $ this -> checkParams ( $ this -> operation , $ operator ) ; $ this -> operator = $ operator ; }
2253	protected function getParentEntries ( $ strTable , $ intId ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ) ) { return '' ; } $ arrParent = array ( ) ; do { $ objParent = $ this -> Database -> prepare ( "SELECT pid FROM " . $ strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intId ) ; if ( $ objParent -> numRows < 1 ) { break ; } $ strTable = $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ; $ intId = $ objParent -> pid ; $ arrParent [ ] = $ strTable . '.id=' . $ intId ; $ this -> loadDataContainer ( $ strTable ) ; } while ( $ intId && isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ) ) ; if ( empty ( $ arrParent ) ) { return '' ; } return ' (parent records: ' . implode ( ', ' , $ arrParent ) . ')' ; }
9223	public function unserialize ( $ data ) { $ _data = unserialize ( $ data ) ; $ this -> page = $ _data [ 'page' ] ; $ this -> key = $ _data [ 'key' ] ; $ this -> data = $ _data [ 'data' ] ; $ this -> api = null ; $ this -> endpoint = null ; $ this -> pagination = array ( ) ; }
12693	public function generate ( ) { $ templates = array_merge ( array_keys ( $ this -> templates [ "base" ] ) , array_keys ( $ this -> templates [ "template" ] ) ) ; foreach ( $ templates as $ template ) { $ templateDir = $ this -> themeDir . '/' . $ template ; if ( ! is_dir ( $ templateDir ) ) { continue ; } $ finder = new Finder ( ) ; $ files = $ finder -> files ( ) -> depth ( 0 ) -> in ( $ templateDir ) ; foreach ( $ files as $ file ) { $ file = ( string ) $ file ; $ slotName = basename ( $ file , '.json' ) ; $ json = FilesystemTools :: readFile ( $ file ) ; $ slot = json_decode ( $ json , true ) ; $ blocks = array ( ) ; if ( array_key_exists ( "blocks" , $ slot ) ) { $ blocks = $ slot [ "blocks" ] ; } $ slotManager = $ this -> slotsManagerFactory -> createSlotManager ( $ slot [ "repeat" ] ) ; $ slotManager -> addSlot ( $ slotName , $ blocks ) ; } } }
10031	function synchronizeContacts ( $ contacts , $ permission = null , $ syncMode = null , $ useExternalId = false , $ ignoreInvalidContacts = false , $ reimportUnsubscribedContacts = true , $ overridePermission = true , $ updateOnly = false , $ preferMaileonId = false ) { $ queryParameters = array ( 'permission' => ( $ permission == null ) ? 1 : $ permission -> getCode ( ) , 'sync_mode' => ( $ syncMode == null ) ? 2 : $ syncMode -> getCode ( ) , 'use_external_id' => ( $ useExternalId == TRUE ) ? "true" : "false" , 'ignore_invalid_contacts' => ( $ ignoreInvalidContacts == TRUE ) ? "true" : "false" , 'reimport_unsubscribed_contacts' => ( $ reimportUnsubscribedContacts == TRUE ) ? "true" : "false" , 'override_permission' => ( $ overridePermission == TRUE ) ? "true" : "false" , 'update_only' => ( $ updateOnly == TRUE ) ? "true" : "false" , 'prefer_maileon_id' => ( $ preferMaileonId == TRUE ) ? "true" : "false" ) ; $ cleanedContacts = new Contacts ( ) ; foreach ( $ contacts as $ contact ) { $ cleanedContact = new Contact ( $ contact -> id , $ contact -> email , null , $ contact -> external_id , null , $ contact -> standard_fields , $ contact -> custom_fields ) ; $ cleanedContacts -> addContact ( $ cleanedContact ) ; } return $ this -> post ( "contacts" , $ cleanedContacts -> toXMLString ( ) , $ queryParameters ) ; }
1801	protected function switchToEdit ( $ id ) { $ arrKeys = array ( ) ; $ arrUnset = array ( 'act' , 'id' , 'table' ) ; foreach ( array_keys ( $ _GET ) as $ strKey ) { if ( ! \ in_array ( $ strKey , $ arrUnset ) ) { $ arrKeys [ $ strKey ] = $ strKey . '=' . Input :: get ( $ strKey ) ; } } $ strUrl = TL_SCRIPT . '?' . implode ( '&' , $ arrKeys ) ; return $ strUrl . ( ! empty ( $ arrKeys ) ? '&' : '' ) . ( Input :: get ( 'table' ) ? 'table=' . Input :: get ( 'table' ) . '&amp;' : '' ) . 'act=edit&amp;id=' . rawurlencode ( $ id ) ; }
7962	public function canChangeLns ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canChangeLns ; }
8546	public function setChargebackEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ChargebackEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2448	public function sendNotifications ( $ varValue ) { if ( $ varValue ) { Contao \ Comments :: notifyCommentsSubscribers ( Contao \ CommentsModel :: findByPk ( Contao \ Input :: get ( 'id' ) ) ) ; } return $ varValue ; }
3071	protected function saveItemResponses ( $ emptyAllowed = true ) { if ( $ this -> getRequestParameter ( 'itemDefinition' ) && $ this -> getRequestParameter ( 'itemResponse' ) ) { $ itemDefinition = $ this -> getRequestParameter ( 'itemDefinition' ) ; $ serviceContext = $ this -> getServiceContext ( ) ; $ itemResponse = $ this -> getRequestParameter ( 'itemResponse' ) ? json_decode ( $ this -> getRequestParameter ( 'itemResponse' ) , true ) : null ; if ( ! is_null ( $ itemResponse ) && ! empty ( $ itemDefinition ) ) { $ responses = $ this -> getRunnerService ( ) -> parsesItemResponse ( $ serviceContext , $ itemDefinition , $ itemResponse ) ; if ( ! $ emptyAllowed && $ this -> getRunnerService ( ) -> getTestConfig ( ) -> getConfigValue ( 'enableAllowSkipping' ) && ! TestRunnerUtils :: doesAllowSkipping ( $ serviceContext -> getTestSession ( ) ) ) { if ( $ this -> getRunnerService ( ) -> emptyResponse ( $ serviceContext , $ responses ) ) { throw new QtiRunnerEmptyResponsesException ( ) ; } } return $ this -> getRunnerService ( ) -> storeItemResponse ( $ serviceContext , $ itemDefinition , $ responses ) ; } } return false ; }
8702	public function saveElementAsFile ( $ fileName ) { $ this -> getString ( ) ; if ( false === file_put_contents ( $ fileName , $ this -> elementString ) ) { return false ; } else { return $ fileName ; } }
2972	protected function determineContext ( array & $ data ) { $ refs = 0 ; $ vars = array_map ( function ( $ node ) use ( & $ refs ) { if ( $ node -> byRef ) { $ refs ++ ; } if ( $ node -> var instanceof VariableNode ) { return $ node -> var -> name ; } else { return $ node -> var ; } } , $ data [ 'ast' ] -> uses ) ; $ data [ 'hasRefs' ] = ( $ refs > 0 ) ; $ values = $ data [ 'reflection' ] -> getStaticVariables ( ) ; foreach ( $ vars as $ name ) { if ( isset ( $ values [ $ name ] ) ) { $ data [ 'context' ] [ $ name ] = $ values [ $ name ] ; } } }
10172	function toString ( ) { $ customfields = "" ; if ( isset ( $ this -> custom_fields ) ) { foreach ( $ this -> custom_fields as $ index => $ type ) { $ customfields .= $ index . "=" . $ type . ", " ; } $ customfields = rtrim ( $ customfields , ', ' ) ; } return "CustomFields = {" . $ customfields . "}" ; }
338	protected function extractColumnSize ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> size = trim ( $ length ) === '' ? null : ( int ) $ length ; $ column -> precision = trim ( $ precision ) === '' ? null : ( int ) $ precision ; $ column -> scale = trim ( $ scale ) === '' ? null : ( int ) $ scale ; }
5859	public function getAllDirectories ( ) { $ directories = [ ] ; foreach ( $ this -> rulesets as $ ruleset ) { $ dirs = GeneralUtility :: trimExplode ( ',' , $ ruleset [ 'directories_config' ] , true ) ; $ directories = array_merge ( $ directories , $ dirs ) ; } $ directories = array_unique ( $ directories ) ; asort ( $ directories ) ; return $ directories ; }
3506	private function convertAlertToArray ( Alert $ alert ) : array { $ data = [ ] ; if ( $ alert -> getBodyLocalized ( ) -> getKey ( ) ) { $ data [ 'loc-key' ] = $ alert -> getBodyLocalized ( ) -> getKey ( ) ; $ data [ 'loc-args' ] = $ alert -> getBodyLocalized ( ) -> getArgs ( ) ; } else { $ data [ 'body' ] = $ alert -> getBody ( ) ; } if ( $ alert -> getTitleLocalized ( ) -> getKey ( ) ) { $ data [ 'title-loc-key' ] = $ alert -> getTitleLocalized ( ) -> getKey ( ) ; $ data [ 'title-loc-args' ] = $ alert -> getTitleLocalized ( ) -> getArgs ( ) ; } elseif ( $ alert -> getTitle ( ) ) { $ data [ 'title' ] = $ alert -> getTitle ( ) ; } if ( $ alert -> getActionLocalized ( ) -> getKey ( ) ) { $ data [ 'action-loc-key' ] = $ alert -> getActionLocalized ( ) -> getKey ( ) ; } if ( $ alert -> getLaunchImage ( ) ) { $ data [ 'launch-image' ] = $ alert -> getLaunchImage ( ) ; } return $ data ; }
9286	public function create ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ CreateTable ( ) ; $ ddl -> setTable ( self :: TABLE_NAME ) -> addColumn ( new Column \ Integer ( 'id' , false , null , array ( 'autoincrement' => true ) ) ) -> addColumn ( new Column \ Varchar ( 'code' , 55 ) ) -> addColumn ( new Column \ Varchar ( 'status' , 55 ) ) -> addColumn ( new Column \ Text ( 'error_msg' ) ) -> addColumn ( new Column \ Text ( 'stack_trace' ) ) -> addColumn ( new Column \ Varchar ( 'created' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'scheduled' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'executed' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'finished' , 255 ) ) -> addConstraint ( new Constraint \ PrimaryKey ( 'id' ) ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
8903	public function delete_by_at ( $ condition , $ time ) { $ this -> prevent_if_not_soft_deletable ( ) ; $ this -> _set_where ( $ condition ) ; return $ this -> _delete ( $ condition , $ time ) ; }
12935	protected function resolveMoveOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'page' , 'language' , 'country' , 'sourceSlot' , 'position' , ) ) ; $ this -> optionsResolver -> setDefined ( array ( 'targetSlot' , 'blockname' , 'oldName' , 'newName' , 'slot' , ) ) ; $ this -> optionsResolver -> resolve ( $ options ) ; $ this -> optionsResolved = true ; }
1594	protected function validateType ( ) : bool { if ( ! $ this -> dataHas ( 'type' ) ) { $ this -> memberRequired ( '/data' , 'type' ) ; return false ; } $ value = $ this -> dataGet ( 'type' ) ; if ( ! $ this -> validateTypeMember ( $ value , '/data' ) ) { return false ; } if ( $ this -> expectedType !== $ value ) { $ this -> resourceTypeNotSupported ( $ value ) ; return false ; } return true ; }
11666	public function addFunction ( $ functionName , $ callback ) { if ( is_string ( $ functionName ) && is_callable ( $ callback ) ) { $ functions = [ 'name' => $ functionName , 'callable' => $ callback , ] ; array_push ( $ this -> functionList , $ functions ) ; } }
8902	public function delete ( $ id , $ time = 'NOW()' ) { $ this -> _database -> where ( $ this -> primary_key , $ id ) ; return $ this -> _delete ( $ id , $ time ) ; }
1335	protected function paginate ( $ query , EncodingParametersInterface $ parameters ) { if ( ! $ this -> paging ) { throw new RuntimeException ( 'Paging is not supported on adapter: ' . get_class ( $ this ) ) ; } if ( method_exists ( $ this -> paging , 'withQualifiedKeyName' ) ) { $ this -> paging -> withQualifiedKeyName ( $ this -> getQualifiedKeyName ( ) ) ; } return $ this -> paging -> paginate ( $ query , $ parameters ) ; }
10185	static function json_decode ( $ jsonString , $ deserializationType = null ) { if ( is_array ( $ deserializationType ) && count ( $ deserializationType ) > 1 ) { $ type = $ deserializationType [ 0 ] ; $ innerType = $ deserializationType [ 1 ] ; } else { $ type = $ deserializationType ; $ innerType = null ; } return self :: fromArray ( json_decode ( $ jsonString ) , $ type , $ innerType ) ; }
1490	public function equalsTo ( MediaTypeInterface $ mediaType ) : ? Decoding { return collect ( $ this -> stack ) -> first ( function ( Decoding $ decoding ) use ( $ mediaType ) { return $ decoding -> equalsTo ( $ mediaType ) ; } ) ; }
7313	public function setDate ( $ year , $ month , $ day ) { $ status = IAU :: Cal2jd ( ( int ) $ year , ( int ) $ month , ( int ) $ day , $ djm0 , $ djm ) ; $ this -> checkDate ( $ status ) ; $ this -> jd = $ djm0 + $ djm ; return $ this ; }
10673	protected function _getCached ( $ key , $ default = null , $ ttl = null ) { try { return $ this -> _get ( $ key ) ; } catch ( NotFoundExceptionInterface $ e ) { if ( is_callable ( $ default ) ) { try { $ args = $ this -> _normalizeArray ( $ this -> _getGeneratorArgs ( $ key , $ default , $ ttl ) ) ; $ default = $ this -> _invokeCallable ( $ default , $ args ) ; } catch ( RootException $ e ) { throw $ this -> _createRuntimeException ( $ this -> __ ( 'Could not generate value' ) , null , $ e ) ; } } $ this -> _set ( $ key , $ default , $ ttl ) ; return $ default ; } }
8225	public function handleRegistration ( Request $ httpRequest ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ user = $ this -> picoAuth -> getUser ( ) ; if ( $ user -> getAuthenticated ( ) ) { $ this -> picoAuth -> redirectToPage ( "index" ) ; } $ this -> picoAuth -> addAllowed ( "register" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/register.md' ) ; $ post = $ httpRequest -> request ; if ( $ post -> has ( "username" ) && $ post -> has ( "email" ) && $ post -> has ( "password" ) && $ post -> has ( "password_repeat" ) ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: REGISTER_CSRF_ACTION ) ) { $ this -> picoAuth -> redirectToPage ( "register" ) ; } $ this -> assertLimits ( ) ; $ reg = array ( "username" => strtolower ( trim ( $ post -> get ( "username" ) ) ) , "email" => trim ( $ post -> get ( "email" ) ) , "password" => new Password ( $ post -> get ( "password" ) ) , "passwordRepeat" => new Password ( $ post -> get ( "password_repeat" ) ) , ) ; $ isValid = $ this -> validateRegistration ( $ reg ) ; if ( $ isValid ) { if ( ! $ this -> limit -> action ( "registration" ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } $ this -> logSuccessfulRegistration ( $ reg ) ; $ userData = array ( 'email' => $ reg [ "email" ] ) ; $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ reg [ "password" ] ) ; $ this -> storage -> saveUser ( $ reg [ "username" ] , $ userData ) ; $ this -> session -> addFlash ( "success" , "Registration completed successfully, you can now log in." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; } else { $ this -> session -> addFlash ( "old" , array ( 'username' => $ reg [ "username" ] , 'email' => $ reg [ "email" ] ) ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } } }
2488	protected function getSortFieldName ( SortClause $ sortClause , $ contentTypeIdentifier , $ fieldDefinitionIdentifier ) { return $ this -> fieldNameResolver -> getSortFieldName ( $ sortClause , $ contentTypeIdentifier , $ fieldDefinitionIdentifier ) ; }
4007	public function createMetaModel ( CreateMetaModelEvent $ event ) { if ( $ event -> getMetaModel ( ) !== null ) { return ; } if ( isset ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ) { $ event -> setMetaModel ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ; return ; } $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'tableName=:tableName' ) -> setParameter ( 'tableName' , $ event -> getMetaModelName ( ) ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ table [ 'system_columns' ] = $ this -> systemColumns ; $ this -> createInstance ( $ event , $ table ) ; } }
10630	public static function memory ( ) { $ memory = new \ StdClass ( ) ; $ memory -> real = new \ StdClass ( ) ; $ memory -> swap = new \ StdClass ( ) ; if ( false !== ( $ data = @ file ( '/proc/meminfo' ) ) ) { $ data = implode ( "" , $ data ) ; preg_match_all ( "/MemTotal\s{0,}\:+\s{0,}([\d\.]+).+?MemFree\s{0,}\:+\s{0,}([\d\.]+).+?Cached\s{0,}\:+\s{0,}([\d\.]+).+?SwapTotal\s{0,}\:+\s{0,}([\d\.]+).+?SwapFree\s{0,}\:+\s{0,}([\d\.]+)/s" , $ data , $ meminfo ) ; preg_match_all ( "/Buffers\s{0,}\:+\s{0,}([\d\.]+)/s" , $ data , $ buffers ) ; $ memory -> total = $ meminfo [ 1 ] [ 0 ] * 1024 ; $ memory -> free = $ meminfo [ 2 ] [ 0 ] * 1024 ; $ memory -> used = $ memory -> total - $ memory -> free ; $ memory -> cached = $ meminfo [ 3 ] [ 0 ] * 1024 ; $ memory -> buffers = $ buffers [ 1 ] [ 0 ] * 1024 ; $ memory -> real -> used = $ memory -> total - $ memory -> free - $ memory -> cached - $ memory -> buffers ; $ memory -> real -> free = $ memory -> total - $ memory -> real -> used ; $ memory -> swap -> free = $ meminfo [ 5 ] [ 0 ] * 1024 ; $ memory -> swap -> used = $ meminfo [ 4 ] [ 0 ] * 1024 - $ memory -> swap -> free ; } return $ memory ; }
5111	protected function appendPart ( $ part , $ sql , $ bind = false ) { if ( ! is_array ( $ sql ) ) $ sql = [ $ sql ] ; if ( ! $ this -> parts [ $ part ] ) { $ this -> parts [ $ part ] = $ sql ; } else { $ this -> parts [ $ part ] = array_merge ( $ this -> parts [ $ part ] , $ sql ) ; } return $ this -> appendBind ( $ part , $ bind ) ; }
7741	public function addOperation ( OperationDefinition $ operation ) { if ( false === $ this -> supportsOperation ( $ operation -> getName ( ) ) ) { $ this -> operations [ ] = $ operation ; } return $ this ; }
819	private function isCommentLastLineToken ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isComment ( ) || ! $ tokens [ $ index + 1 ] -> isWhitespace ( ) ) { return false ; } $ content = $ tokens [ $ index + 1 ] -> getContent ( ) ; return $ content !== ltrim ( $ content , "\r\n" ) ; }
10196	public function createStringTable ( Worksheet $ pSheet , $ pExistingTable = null ) { $ aStringTable = [ ] ; $ cellCollection = null ; $ aFlippedStringTable = null ; if ( ( $ pExistingTable !== null ) && is_array ( $ pExistingTable ) ) { $ aStringTable = $ pExistingTable ; } $ aFlippedStringTable = $ this -> flipStringTable ( $ aStringTable ) ; foreach ( $ pSheet -> getCoordinates ( ) as $ coordinate ) { $ cell = $ pSheet -> getCell ( $ coordinate ) ; $ cellValue = $ cell -> getValue ( ) ; if ( ! is_object ( $ cellValue ) && ( $ cellValue !== null ) && $ cellValue !== '' && ! isset ( $ aFlippedStringTable [ $ cellValue ] ) && ( $ cell -> getDataType ( ) == DataType :: TYPE_STRING || $ cell -> getDataType ( ) == DataType :: TYPE_STRING2 || $ cell -> getDataType ( ) == DataType :: TYPE_NULL ) ) { $ aStringTable [ ] = $ cellValue ; $ aFlippedStringTable [ $ cellValue ] = true ; } elseif ( $ cellValue instanceof RichText && ( $ cellValue !== null ) && ! isset ( $ aFlippedStringTable [ $ cellValue -> getHashCode ( ) ] ) ) { $ aStringTable [ ] = $ cellValue ; $ aFlippedStringTable [ $ cellValue -> getHashCode ( ) ] = true ; } } return $ aStringTable ; }
5320	public function waitReady ( ) { $ x = 0 ; while ( $ x ++ < 100 ) { usleep ( self :: WAIT_IDLE ) ; if ( $ this [ self :: STARTED_MARKER ] === true ) { return $ this ; } } throw new \ RuntimeException ( 'Wait process running timeout for child pid ' . $ this -> getPid ( ) ) ; }
7059	public function addClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( ! in_array ( $ class , $ classes ) ) { $ classes [ ] = $ class ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
5114	private function conv ( $ str ) { if ( $ this -> supportsExtMbstring ) { return mb_convert_encoding ( $ str , 'UTF-16BE' , 'UTF-8' ) ; } return preg_replace_callback ( '/./su' , function ( $ m ) { if ( ! isset ( $ m [ 0 ] [ 1 ] ) ) { return "\x00" . $ m [ 0 ] ; } if ( isset ( $ m [ 0 ] [ 3 ] ) ) { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x07 ) << 18 ) + ( ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) << 12 ) + ( ( ord ( $ m [ 0 ] [ 2 ] ) & 0x3F ) << 6 ) + ( ord ( $ m [ 0 ] [ 3 ] ) & 0x3F ) ; return pack ( 'nn' , ( $ code - 0x10000 >> 10 ) | 0xD800 , ( $ code & 0x03FF ) | 0xDC00 ) ; } if ( isset ( $ m [ 0 ] [ 2 ] ) ) { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x0F ) << 12 ) + ( ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) << 6 ) + ( ord ( $ m [ 0 ] [ 2 ] ) & 0x3F ) ; } else { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x1F ) << 6 ) + ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) ; } return chr ( $ code >> 8 ) . chr ( $ code & 0xFF ) ; } , $ str ) ; }
11865	public function get ( string $ sessionIdentifier ) : string { if ( ! $ this -> sessionExists ( $ sessionIdentifier ) ) { throw new SessionNotFoundException ( ) ; } return self :: $ files [ $ sessionIdentifier ] [ 'data' ] ; }
7153	public function add_rule ( $ access , $ role , $ action ) : void { $ roles = ( array ) $ role ; foreach ( $ roles as $ r ) { $ action = ( array ) $ action ; foreach ( $ action as $ a ) { $ this -> _rules [ $ r ] [ $ a ] = $ access ; } } }
6057	public function removeMediaFromFolder ( $ folderId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/folders/' . $ folderId . '/media/' . $ mediaId . '' , $ parameters ) ; return $ result ; }
12432	public function listPermalinksAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "pages_collection_parser" => $ app [ "red_kite_cms.pages_collection_parser" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: listPermalinks ( $ options ) ; }
5176	public function add ( string $ key , $ value ) : self { if ( ! array_key_exists ( $ key , $ this -> props ) ) { return $ this -> addNew ( $ key , $ value ) ; } if ( is_array ( $ this -> props [ $ key ] ) ) { return $ this -> addArray ( $ key , $ value ) ; } return $ this -> appendToArray ( $ key , $ value ) ; }
6969	protected function calculateDiscountLine ( Model \ DocumentLineInterface $ line , Amount $ gross , Amount $ final ) { if ( $ line -> getType ( ) !== Model \ DocumentLineTypes :: TYPE_DISCOUNT ) { throw new LogicException ( sprintf ( "Expected document line with type '%s'." , Model \ DocumentLineTypes :: TYPE_DISCOUNT ) ) ; } if ( null === $ adjustment = $ line -> getSaleAdjustment ( ) ) { throw new LogicException ( "Document can't be recalculated." ) ; } $ result = $ this -> calculator -> calculateSaleDiscount ( $ adjustment , $ gross , $ final ) ; $ this -> syncLineWithResult ( $ line , $ result ) ; }
12804	private static function buildColumnPropertiesCache ( ) { $ class = self :: getStaticChildClass ( ) ; $ annotations = new AnnotationReader ( $ class ) ; $ properties = $ annotations -> getPropertyAnnotations ( ) ; self :: $ columnPropertiesCache [ $ class ] = [ ] ; foreach ( $ properties as $ property ) { if ( $ property === [ ] ) continue ; if ( array_key_exists ( "ColumnName" , $ property ) ) self :: $ columnPropertiesCache [ $ class ] [ $ property [ "ColumnName" ] ] [ ] = $ property [ "var" ] [ "name" ] ; else self :: $ columnPropertiesCache [ $ class ] [ $ property [ "var" ] [ "name" ] ] [ ] = $ property [ "var" ] [ "name" ] ; } }
9322	protected function registerMarkdownEnvironment ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.environment' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'markdown' ] ; $ environment = Environment :: createCommonMarkEnvironment ( ) ; if ( $ config [ 'configurations' ] ) { $ environment -> mergeConfig ( $ config [ 'configurations' ] ) ; } foreach ( $ config [ 'extensions' ] as $ extension ) { if ( class_exists ( $ extension ) ) { $ environment -> addExtension ( new $ extension ( ) ) ; } } return $ environment ; } ) ; $ app -> alias ( 'commonmark.environment' , Environment :: class ) ; }
5674	protected function isMatchingKeys ( $ first , $ second , $ identical ) { $ first_keys = array_keys ( $ first ) ; $ second_keys = array_keys ( $ second ) ; if ( $ identical ) { return ( $ first_keys === $ second_keys ) ; } sort ( $ first_keys ) ; sort ( $ second_keys ) ; return ( $ first_keys == $ second_keys ) ; }
1872	protected function convertValuesToPaths ( ) { if ( empty ( $ this -> varValue ) ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } elseif ( empty ( $ this -> varValue [ 0 ] ) ) { $ this -> varValue = array ( ) ; } if ( empty ( $ this -> varValue ) ) { return ; } if ( strpos ( $ this -> varValue [ 0 ] , Config :: get ( 'uploadPath' ) . '/' ) === 0 ) { return ; } if ( Input :: get ( 'switch' ) ) { return ; } if ( $ this -> path != '' && strpos ( $ this -> path , Config :: get ( 'uploadPath' ) . '/' ) !== 0 ) { return ; } $ objFiles = FilesModel :: findMultipleByIds ( $ this -> varValue ) ; if ( $ objFiles !== null ) { $ this -> varValue = array_values ( $ objFiles -> fetchEach ( 'path' ) ) ; } }
3788	public static function calculateConditions ( IMetaModelDataDefinition $ container , array $ inputScreen ) { if ( $ container -> hasDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ) { $ definition = $ container -> getDefinition ( ModelRelationshipDefinitionInterface :: NAME ) ; } else { $ definition = new DefaultModelRelationshipDefinition ( ) ; $ container -> setDefinition ( ModelRelationshipDefinitionInterface :: NAME , $ definition ) ; } if ( ! $ definition instanceof ModelRelationshipDefinitionInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } $ instance = new static ( ) ; $ instance -> container = $ container ; $ instance -> inputScreen = $ inputScreen ; $ instance -> definition = $ definition ; $ instance -> calculate ( ) ; }
9253	protected function getContainerInitializer ( ) { $ initializer = new DefaultInitializer ( $ this -> getConfigurationProvider ( ) ) ; if ( $ this -> cache ) { $ initializer = new CachedInitializer ( $ initializer , $ this -> getCacheDir ( ) ) ; } return $ initializer ; }
7695	function MsPowerpoint_InitSlideLst ( $ Master = false ) { if ( $ Master ) { $ RefLst = & $ this -> OpenXmlSlideMasterLst ; } else { $ RefLst = & $ this -> OpenXmlSlideLst ; } if ( $ RefLst !== false ) return $ RefLst ; $ PresFile = 'ppt/presentation.xml' ; $ prefix = ( $ Master ) ? 'slideMasters/' : 'slides/' ; $ o = $ this -> OpenXML_Rels_GetObj ( 'ppt/presentation.xml' , $ prefix ) ; $ Txt = $ this -> FileRead ( $ PresFile ) ; if ( $ Txt === false ) return false ; $ p = 0 ; $ i = 0 ; $ lst = array ( ) ; $ tag = ( $ Master ) ? 'p:sldMasterId' : 'p:sldId' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ tag , $ p ) ) { $ i ++ ; $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( $ rid === false ) { $ this -> RaiseError ( "(Init Slide List) attribute 'r:id' is missing for slide #$i in '$PresFile'." ) ; } elseif ( isset ( $ o -> TargetLst [ $ rid ] ) ) { $ f = 'ppt/' . $ o -> TargetLst [ $ rid ] ; $ lst [ ] = array ( 'file' => $ f , 'idx' => $ this -> FileGetIdx ( $ f ) , 'rid' => $ rid ) ; } else { $ this -> RaiseError ( "(Init Slide List) Slide corresponding to rid=$rid is not found in the Rels file of '$PresFile'." ) ; } $ p = $ loc -> PosEnd ; } $ RefLst = $ lst ; return $ RefLst ; }
9374	protected function dispatcher ( ResponseInterface $ response , $ stack ) { $ dispatcher = new Dispatcher ( $ stack , $ response ) ; if ( class_exists ( 'Zend\Stratigility\MiddlewarePipe' ) ) { $ pipe = new MiddlewarePipe ; $ dispatcher = new StratigilityDispatcher ( $ pipe , $ stack , $ response ) ; } return $ dispatcher ; }
4032	private function preCreateInverseImage ( ModelInterface $ model , string $ image ) : void { if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return ; } if ( $ model -> getProperty ( 'enabled' ) ) { $ this -> iconBuilder -> getBackendIcon ( substr_replace ( $ image , '_1' , $ intPos , 0 ) ) ; return ; } $ this -> iconBuilder -> getBackendIcon ( $ image ) ; }
9944	public function getCellByColumnAndRow ( $ columnIndex , $ row , $ createIfNotExists = true ) { $ columnLetter = Coordinate :: stringFromColumnIndex ( $ columnIndex ) ; $ coordinate = $ columnLetter . $ row ; if ( $ this -> cellCollection -> has ( $ coordinate ) ) { return $ this -> cellCollection -> get ( $ coordinate ) ; } return $ createIfNotExists ? $ this -> createNewCell ( $ coordinate ) : null ; }
10215	protected function scanElementForText ( \ DOMNode $ element ) { $ str = '' ; foreach ( $ element -> childNodes as $ child ) { if ( $ child -> nodeType == XML_TEXT_NODE ) { $ str .= $ child -> nodeValue ; } elseif ( $ child -> nodeType == XML_ELEMENT_NODE && $ child -> nodeName == 'text:s' ) { $ cAttr = $ child -> attributes -> getNamedItem ( 'c' ) ; if ( $ cAttr ) { $ multiplier = ( int ) $ cAttr -> nodeValue ; } else { $ multiplier = 1 ; } $ str .= str_repeat ( ' ' , $ multiplier ) ; } if ( $ child -> hasChildNodes ( ) ) { $ str .= $ this -> scanElementForText ( $ child ) ; } } return $ str ; }
9467	protected function initializer ( string $ key , array $ storage ) : void { $ this -> _name = $ key ; $ this -> attached ( $ storage ) ; }
9566	public function addAfterHook ( $ hook ) { if ( ! isset ( $ this -> options [ 'after' ] ) ) { $ this -> options [ 'after' ] = [ ] ; } $ this -> options [ 'after' ] [ ] = $ hook ; }
9929	protected function handleUnpermittedParam ( $ key , $ params ) { if ( $ this -> getThrowExceptions ( ) ) { $ message = "Parameter '$key' is not allowed" ; throw new UnpermittedParameterException ( $ message ) ; } $ params -> delete ( $ key ) ; }
7646	protected function getFileName ( $ path ) { $ url = parse_url ( $ path ) ; if ( $ url [ 'host' ] ) { $ fileName = isset ( $ url [ 'path' ] ) ? $ url [ 'path' ] : $ url [ 'host' ] ; if ( strpos ( $ fileName , '/' ) === 0 ) { $ fileName = substr ( $ fileName , 1 ) ; } return $ fileName ; } return '' ; }
2948	public function release ( $ version ) { $ package = 'upyun/sdk' ; $ name = 'php-sdk' ; $ collection = $ this -> collectionBuilder ( ) ; $ workingPath = __DIR__ . DIRECTORY_SEPARATOR . $ collection -> workDir ( "release" ) ; $ collection -> taskExec ( "composer create-project {$package} {$name} {$version}" ) -> dir ( $ workingPath ) -> arg ( '--prefer-dist' ) -> arg ( '--no-dev' ) -> arg ( '-vvv' ) -> taskExec ( 'composer dump-autoload --optimize' ) -> dir ( $ workingPath . DIRECTORY_SEPARATOR . $ name ) -> arg ( '-vvv' ) ; $ collection -> run ( ) ; $ zipFile = "release/{$name}-{$version}.zip" ; $ this -> _remove ( $ zipFile ) ; $ this -> taskPack ( $ zipFile ) -> addDir ( "php-sdk" , __DIR__ . "/release/php-sdk" ) -> run ( ) ; $ this -> _deleteDir ( "release/$name" ) ; }
4896	public function start ( $ type = self :: TYPE_INFO , array $ options = array ( ) ) { if ( $ this -> captureLock ) { throw new \ RuntimeException ( 'Cannot start capture, there is already a capture running.' ) ; } $ this -> captureLock = true ; $ this -> captureType = $ type ; $ this -> captureOptions = $ options ; ob_start ( ) ; return $ this ; }
5642	public function paintCaseEnd ( $ test_name ) { $ this -> progress ++ ; array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
2571	public static function isValidFopType ( $ fopType ) { return ( $ fopType == self :: IDENT_CASH || $ fopType == self :: IDENT_CHECK || $ fopType == self :: IDENT_CREDITCARD || $ fopType == self :: IDENT_MISC ) ; }
2148	public function removeSubscriptions ( $ intUser , $ strMode ) { if ( ! $ intUser ) { return ; } if ( $ strMode == 'close_delete' ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } else { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active='' WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } }
7726	public function postback ( $ text , $ title , $ postback ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'type' => 'postback' , 'title' => $ title , 'payload' => $ postback ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
12915	protected function getColumnReference ( $ column , $ tableless ) { if ( $ tableless ) { return $ column ; } if ( count ( explode ( "." , $ column ) ) > 1 ) { return $ column ; } return "`" . $ this -> table . "`.`" . $ column . "`" ; }
5057	private function getClassName ( $ requestedName ) { $ exp = explode ( '/' , $ requestedName ) ; $ className = array_shift ( $ exp ) . '\\Controller\\' . implode ( '\\' , $ exp ) . 'Controller' ; if ( ! class_exists ( $ className ) ) { throw new ServiceNotCreatedException ( sprintf ( 'Can\'t find correct controller class for "%s"' , $ requestedName ) ) ; } return $ className ; }
1636	protected function formatQuery ( $ sql , array $ bindings , $ time , $ connection ) { $ data = [ 'sql' => $ sql ] ; foreach ( $ bindings as $ index => $ binding ) { $ data [ "binding {$index}" ] = $ binding ; } $ data [ 'time' ] = "{$time}ms" ; $ data [ 'connection' ] = $ connection ; return $ data ; }
4273	public function stream_eof ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ feof ( $ this -> handle ) ; self :: register ( ) ; return $ result ; }
9504	private function listen ( ) { $ this -> emitter -> on ( 'peridot.configure' , [ $ this , 'onPeridotConfigure' ] ) ; $ this -> emitter -> on ( 'peridot.start' , [ $ this , 'onPeridotStart' ] ) ; $ this -> emitter -> on ( 'peridot.end' , [ $ this , 'onPeridotEnd' ] ) ; }
12292	public function findOneLastPost ( $ site ) { $ qb = $ this -> getQueryBuilder ( ) -> select ( 'p.id, p.title, p.description, p.slug, p.published, i.path as image_path' ) -> leftJoin ( 'p.images' , 'i' ) -> andWhere ( 'p.highlighted=1' ) -> setMaxResults ( 1 ) -> orderBy ( 'p.published' , 'DESC' ) ; return $ qb -> getQuery ( ) -> getOneOrNullResult ( \ Doctrine \ ORM \ Query :: HYDRATE_ARRAY ) ; }
12685	public function removeFromDB ( ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( count ( $ this -> result ) > 0 ) { if ( ! $ this -> result [ 0 ] instanceof Web2All_Table_SaveObject ) { throw new Exception ( "Web2All_Table_ObjectList->removeFromDB: Not a saveobject, you can't delete a non saveobject." ) ; } foreach ( $ this -> result as $ row ) { $ row -> deleteFromDB ( ) ; } } }
6331	private function registerPostProcessor ( string $ type , string $ class ) : void { if ( \ class_exists ( $ class ) ) { $ interfaces = \ class_implements ( $ class ) ; if ( \ in_array ( PostProcessor :: class , $ interfaces , true ) ) { $ this -> postProcessorsMap [ $ type ] = $ class ; } else { throw new ConfigException ( "Class {$class} don't implement interface " . PostProcessor :: class ) ; } } else { throw new ConfigException ( "Class {$class} not found" ) ; } }
8907	public function get_next_id ( ) { return ( int ) $ this -> _database -> select ( 'AUTO_INCREMENT' ) -> from ( 'information_schema.TABLES' ) -> where ( 'TABLE_NAME' , $ this -> _database -> dbprefix ( $ this -> get_table ( ) ) ) -> where ( 'TABLE_SCHEMA' , $ this -> _database -> database ) -> get ( ) -> row ( ) -> AUTO_INCREMENT ; }
7623	public function signRequestHeaders ( $ httpVerb = 'GET' , $ path = '/' , $ query = array ( ) , $ headers = null , $ forTableStorage = false , $ resourceType = Storage :: RESOURCE_UNKNOWN , $ requiredPermission = CredentialsAbstract :: PERMISSION_READ , $ rawData = null ) { return $ headers ; }
11229	public function init ( ) { $ this -> pluginClient = new PluginClient ( $ this -> httpClient ? : HttpClientDiscovery :: find ( ) , $ this -> plugins ) ; $ this -> client = new HttpMethodsClient ( $ this -> pluginClient , $ this -> messageFactory ? : MessageFactoryDiscovery :: find ( ) ) ; }
7378	public function fetchBool ( string $ key , bool $ default = false ) : bool { return $ this -> fetchFilter ( $ key , $ default , FILTER_VALIDATE_BOOLEAN ) ; }
3486	private static function addDefaultResolvers ( ) : void { static $ added = false ; if ( $ added ) { return ; } $ added = true ; self :: addResolver ( [ __CLASS__ , 'tryResolveByWebTokenJwtSystem' ] ) ; self :: addResolver ( [ __CLASS__ , 'tryResolveBySpomkyLabsJoseSystem' ] ) ; }
133	public function getInstaller ( $ type ) { $ type = strtolower ( $ type ) ; if ( isset ( $ this -> cache [ $ type ] ) ) { return $ this -> cache [ $ type ] ; } foreach ( $ this -> installers as $ installer ) { if ( $ installer -> supports ( $ type ) ) { return $ this -> cache [ $ type ] = $ installer ; } } throw new \ InvalidArgumentException ( 'Unknown installer type: ' . $ type ) ; }
12419	static function run_php_pdepend_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ pdepend = self :: getTool ( 'pdepend' , $ opts , true ) ; pake_mkdirs ( $ destdir ) ; $ out = pake_sh ( $ pdepend . " --jdepend-chart=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/jdependchart.svg' ) . " --overview-pyramid=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/overview-pyramid.svg' ) . " --summary-xml=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/summary.xml' ) . " " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
9911	function fromArray ( $ object_vars ) { foreach ( $ object_vars as $ key => $ value ) { if ( class_exists ( 'AbstractJSONWrapper' ) && is_subclass_of ( $ this -> { $ key } , 'AbstractJSONWrapper' ) ) { $ this -> { $ key } -> fromArray ( $ value ) ; } else { $ this -> { $ key } = $ value ; } } }
6100	protected function delete ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_DELETE , null , $ fireAndForget ) ; }
4491	public function registerDeviceOnTopic ( string $ deviceArn , string $ topicArn ) { $ this -> sns -> subscribe ( [ 'TopicArn' => $ topicArn , 'Protocol' => 'application' , 'Endpoint' => $ deviceArn , ] ) ; }
785	protected function generateEtag ( $ seed ) { $ etag = '"' . rtrim ( base64_encode ( sha1 ( $ seed , true ) ) , '=' ) . '"' ; return $ this -> weakEtag ? 'W/' . $ etag : $ etag ; }
6544	public function currentShardingKey ( ) { return isset ( $ this -> options [ SelectorSourceInterface :: SHARDING_KEY ] ) ? $ this -> options [ SelectorSourceInterface :: SHARDING_KEY ] : null ; }
12961	public function getDb ( ) { if ( is_null ( $ this -> db ) ) { if ( $ this -> getAccessType ( ) == 'mysqli' && function_exists ( 'mysqli_select_db' ) ) { $ this -> db = new Db \ Mysqli ( ) ; } else { if ( $ this -> getAccessType ( ) == 'pdo' && class_exists ( 'PDO' ) ) { $ this -> db = new Db \ Pdo ( ) ; } } if ( is_null ( $ this -> db ) ) { if ( class_exists ( 'PDO' ) ) { $ this -> db = new Db \ Pdo ( ) ; } elseif ( function_exists ( 'mysqli_select_db' ) ) { $ this -> db = new Db \ Mysqli ( ) ; } else { throw new DbException ( 'Database engine not available! Must be either PDO or mysqli' ) ; } } $ this -> db -> setCredentials ( $ this -> credentials ) ; } return $ this -> db ; }
11409	public function showAction ( Request $ request , Application $ app ) { $ options = array ( 'twig' => $ app [ "twig" ] , 'template_assets' => $ app [ "red_kite_cms.template_assets" ] , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "plugin_manager" => $ app [ "red_kite_cms.plugin_manager" ] , ) ; return parent :: show ( $ options ) ; }
61	public function isDirEmpty ( $ dir ) { $ finder = Finder :: create ( ) -> ignoreVCS ( false ) -> ignoreDotFiles ( false ) -> depth ( 0 ) -> in ( $ dir ) ; return count ( $ finder ) === 0 ; }
5562	protected function parse ( $ response , $ depth = 0 ) { $ page = $ this -> buildPage ( $ response ) ; if ( $ this -> ignore_frames || ! $ page -> hasFrames ( ) || ( $ depth > $ this -> maximum_nested_frames ) ) { return $ page ; } $ frameset = new SimpleFrameset ( $ page ) ; foreach ( $ page -> getFrameset ( ) as $ key => $ url ) { $ frame = $ this -> fetch ( $ url , new SimpleGetEncoding ( ) , $ depth + 1 ) ; $ frameset -> addFrame ( $ frame , $ key ) ; } return $ frameset ; }
8127	public static function findByUsernameOrEmail ( $ emailOrUsername ) { if ( filter_var ( $ emailOrUsername , FILTER_VALIDATE_EMAIL ) ) { return UserIdentity :: findByEmail ( $ emailOrUsername ) ; } return UserIdentity :: findByUsername ( $ emailOrUsername ) ; }
1323	private function encodeAppAuthorization ( Consumer $ consumer ) { $ key = rawurlencode ( $ consumer -> key ) ; $ secret = rawurlencode ( $ consumer -> secret ) ; return base64_encode ( $ key . ':' . $ secret ) ; }
12174	public function addScalarArgument ( $ name , $ type , $ required = true , $ default = null ) { return $ this -> addArgument ( new ScalarArgument ( $ this -> argumentPosition ++ , $ name , $ type , $ required , $ default ) ) ; }
73	public function authorizeOAuthInteractively ( $ originUrl , $ message = null ) { if ( $ message ) { $ this -> io -> writeError ( $ message ) ; } $ url = 'https://confluence.atlassian.com/bitbucket/oauth-on-bitbucket-cloud-238027431.html' ; $ this -> io -> writeError ( sprintf ( 'Follow the instructions on %s' , $ url ) ) ; $ this -> io -> writeError ( sprintf ( 'to create a consumer. It will be stored in "%s" for future use by Composer.' , $ this -> config -> getAuthConfigSource ( ) -> getName ( ) ) ) ; $ this -> io -> writeError ( 'Ensure you enter a "Callback URL" (http://example.com is fine) or it will not be possible to create an Access Token (this callback url will not be used by composer)' ) ; $ consumerKey = trim ( $ this -> io -> askAndHideAnswer ( 'Consumer Key (hidden): ' ) ) ; if ( ! $ consumerKey ) { $ this -> io -> writeError ( '<warning>No consumer key given, aborting.</warning>' ) ; $ this -> io -> writeError ( 'You can also add it manually later by using "composer config --global --auth bitbucket-oauth.bitbucket.org <consumer-key> <consumer-secret>"' ) ; return false ; } $ consumerSecret = trim ( $ this -> io -> askAndHideAnswer ( 'Consumer Secret (hidden): ' ) ) ; if ( ! $ consumerSecret ) { $ this -> io -> writeError ( '<warning>No consumer secret given, aborting.</warning>' ) ; $ this -> io -> writeError ( 'You can also add it manually later by using "composer config --global --auth bitbucket-oauth.bitbucket.org <consumer-key> <consumer-secret>"' ) ; return false ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return false ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; $ this -> config -> getAuthConfigSource ( ) -> removeConfigSetting ( 'http-basic.' . $ originUrl ) ; $ this -> io -> writeError ( '<info>Consumer stored successfully.</info>' ) ; return true ; }
10472	public function checkInItem ( $ item_id ) { $ request = new CheckInRequest ( $ this -> connector -> agency_id , $ item_id ) ; $ this -> emit ( 'request.checkin' , array ( $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new CheckInResponse ( $ response ) ; }
10002	public function apply ( Tag $ tag , Renderer $ renderer ) { foreach ( $ this -> stack as $ item ) { $ result = $ item [ 'decorator' ] ( $ tag , $ renderer ) ; if ( $ result instanceof Tag ) { $ tag = $ result ; } else { trigger_error ( sprintf ( '%s does not return an instance of Sirius\\Html\\Tag' , get_class ( $ item [ 'decorator' ] ) ) , E_USER_WARNING ) ; } } return $ tag ; }
12181	public function getPrimaryObject ( $ primaryObject , $ relatedObject , $ role ) { if ( ! $ this -> handlePrimary ) { return false ; } if ( $ role === 'child' ) { $ primaryField = 'primary_child' ; if ( ! $ relatedObject -> objectType -> getPrimaryAsChild ( $ this -> parent ) ) { return false ; } $ primaryParent = $ primaryObject ; } else { $ primaryField = 'primary_parent' ; if ( ! $ relatedObject -> objectType -> getPrimaryAsParent ( $ this -> child ) ) { return false ; } $ primaryParent = $ relatedObject ; } $ key = json_encode ( [ __FUNCTION__ , $ this -> systemId , $ primaryObject -> primaryKey ] ) ; if ( ! isset ( self :: $ _cache [ $ key ] ) ) { self :: $ _cache [ $ key ] = null ; $ relationClass = Yii :: $ app -> classes [ 'Relation' ] ; $ childClass = $ this -> child -> primaryModel ; $ relation = $ relationClass :: find ( ) ; $ alias = $ relationClass :: tableName ( ) ; $ relation -> andWhere ( [ '`' . $ alias . '`.`parent_object_id`' => $ primaryParent -> primaryKey , '`' . $ alias . '`.`' . $ primaryField . '`' => 1 ] ) ; $ relation -> andWhere ( [ 'or' , '`' . $ alias . '`.`child_object_id` LIKE :prefix' ] ) ; $ relation -> params [ ':prefix' ] = $ childClass :: modelPrefix ( ) . '-%' ; $ primaryObject -> addActiveConditions ( $ relation , $ alias ) ; $ relation = $ relation -> one ( ) ; if ( ! empty ( $ relation ) ) { self :: $ _cache [ $ key ] = $ relation ; } } return self :: $ _cache [ $ key ] ; }
4102	public function request ( $ path , $ method = 'GET' , $ payload = false , $ verbose = false ) { $ response = $ this -> transport -> request ( $ this -> expandPath ( $ path ) , $ method , $ payload ) ; return ( $ verbose || ! isset ( $ response [ '_source' ] ) ) ? $ response : $ response [ '_source' ] ; }
12479	private function generateOptions ( $ folder , $ rootAlias ) { $ assetsPath = $ this -> configurationHandler -> uploadAssetsDir ( ) . '/' . $ folder ; if ( ! is_dir ( $ assetsPath ) ) { @ mkdir ( $ assetsPath ) ; } $ options = array ( 'locale' => '' , 'roots' => array ( array ( 'driver' => 'LocalFileSystem' , 'path' => $ assetsPath , 'URL' => $ this -> configurationHandler -> absoluteUploadAssetsDir ( ) . '/' . $ folder , 'accessControl' => 'access' , 'rootAlias' => $ rootAlias ) ) ) ; return $ options ; }
3265	protected function preserveLines ( $ data , bool $ reverse ) { $ search = [ "\n" , "\r" ] ; $ replace = [ '\\n' , '\\r' ] ; if ( $ reverse ) { $ search = [ '\\n' , '\\r' ] ; $ replace = [ "\n" , "\r" ] ; } if ( is_string ( $ data ) ) { $ data = str_replace ( $ search , $ replace , $ data ) ; } elseif ( is_array ( $ data ) ) { foreach ( $ data as & $ value ) { $ value = $ this -> preserveLines ( $ value , $ reverse ) ; } unset ( $ value ) ; } return $ data ; }
11836	public function addAction ( AbstractAction $ action ) { $ action -> setGroup ( $ this ) ; $ this -> actions [ $ action -> getName ( ) ] = $ action ; return $ this ; }
12942	public function create ( $ className , $ username ) { $ reflectionClass = new \ ReflectionClass ( $ className ) ; $ permalinks = $ this -> pagesParser -> contributor ( $ username ) -> parse ( ) -> permalinksByLanguage ( $ this -> configurationHandler -> language ( ) . '_' . $ this -> configurationHandler -> country ( ) ) ; $ permalinksForSelect = ( ! empty ( $ permalinks ) ) ? array_combine ( $ permalinks , $ permalinks ) : array ( ) ; $ params = array ( $ permalinksForSelect ) ; $ form = $ this -> formFactory -> create ( $ reflectionClass -> newInstanceArgs ( $ params ) ) ; return $ form -> createView ( ) ; }
4532	public function setFirstResult ( ? int $ firstResult ) { $ this -> firstResult = $ firstResult ; $ this -> _firstResult = null !== $ firstResult ; return $ this ; }
1584	public function withMeta ( $ meta ) : self { $ copy = clone $ this ; $ copy -> meta = collect ( $ meta ) -> all ( ) ; return $ copy ; }
9907	public function setBlocSize ( $ size ) { if ( null !== $ this -> memory ) { throw new Exception \ RuntimeException ( 'You can not change the segment size because memory is already allocated.' . ' Use realloc() function to create new memory segment.' ) ; } $ this -> blocSize = ( integer ) $ size ; return $ this ; }
3212	static function loadFromJsonFileWithRaw ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new AppInfoLoadException ( "File doesn't exist: \"$path\"" ) ; } $ str = Util :: stripUtf8Bom ( file_get_contents ( $ path ) ) ; $ jsonArr = json_decode ( $ str , true , 10 ) ; if ( is_null ( $ jsonArr ) ) { throw new AppInfoLoadException ( "JSON parse error: \"$path\"" ) ; } $ appInfo = self :: loadFromJson ( $ jsonArr ) ; return array ( $ jsonArr , $ appInfo ) ; }
2927	protected function resetContent ( ) { $ this -> filePath = null ; $ this -> reader -> load ( null ) ; $ this -> writer -> setBuffer ( null ) ; }
3811	protected function transformCondition ( $ condition ) { $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ event = new CreatePropertyConditionEvent ( $ condition , $ this -> getMetaModel ( ) ) ; $ dispatcher -> dispatch ( CreatePropertyConditionEvent :: NAME , $ event ) ; if ( $ event -> getInstance ( ) === null ) { throw new \ RuntimeException ( sprintf ( 'Condition of type %s could not be transformed to an instance.' , $ condition [ 'type' ] ) ) ; } return $ event -> getInstance ( ) ; }
12384	public static function perDay ( $ days = 1 , $ date_format = "m-d" ) { $ hits_per_day = [ ] ; for ( $ i = 1 ; $ i <= $ days ; $ i ++ ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subDays ( $ i ) , Carbon :: now ( ) -> subDays ( $ i - 1 ) ) ; $ hits_per_day [ Carbon :: now ( ) -> subDays ( $ i ) -> format ( $ date_format ) ] = $ hits_count ; } return $ hits_per_day ; }
8941	public function expandBBoxChangeset ( $ id , $ nodes ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/expand_bbox' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ nodeList = '' ; if ( ! empty ( $ nodes ) ) { foreach ( $ nodes as $ node ) { $ nodeList .= '<node lat="' . $ node [ 0 ] . '" lon="' . $ node [ 1 ] . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <changeset>' . $ nodeList . '</changeset> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'POST' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> changeset ; }
4793	function order ( $ columns ) { $ this -> rows = null ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { if ( $ this -> union ) { $ this -> unionOrder [ ] = $ columns ; } else { $ this -> order [ ] = $ columns ; } } } elseif ( $ this -> union ) { $ this -> unionOrder = array ( ) ; } else { $ this -> order = array ( ) ; } return $ this ; }
1973	public static function findMultipleByPaths ( $ arrPaths , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPaths ) || ! \ is_array ( $ arrPaths ) ) { return null ; } $ t = static :: $ strTable ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.path" , $ arrPaths ) ; } return static :: findBy ( array ( "$t.path IN(" . implode ( ',' , array_fill ( 0 , \ count ( $ arrPaths ) , '?' ) ) . ")" ) , $ arrPaths , $ arrOptions ) ; }
2561	public function loadSpecificChanges ( $ changeTicketing , $ changeQueueing , $ changeOptQueueEl ) { if ( $ changeTicketing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_TICKETING_OFFICE ) ; } if ( $ changeQueueing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_QUEUEING_OFFICE ) ; } if ( $ changeOptQueueEl ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_OPT_QUEUE_ELEMENT ) ; } }
1459	protected function whereId ( $ id , $ operator ) { if ( $ this -> isPagingOnKey ( ) ) { $ this -> query -> where ( $ this -> key , $ operator , $ id ) ; return $ this ; } $ value = $ this -> getColumnValue ( $ id ) ; $ this -> query -> where ( $ this -> column , $ operator . '=' , $ value ) -> where ( function ( $ query ) use ( $ id , $ value , $ operator ) { $ query -> where ( $ this -> column , $ operator , $ value ) -> orWhere ( $ this -> key , $ operator , $ id ) ; } ) ; return $ this ; }
4165	private function mergeScope ( array $ scope ) { if ( empty ( $ scope ) ) return $ this -> _scope ; $ scope = array_merge ( $ scope , $ this -> _defaulScope ) ; $ scope = array_unique ( $ scope ) ; $ intersectingScope = array_intersect ( $ scope , $ this -> _availableScope ) ; if ( count ( $ intersectingScope ) !== count ( $ scope ) ) { throw new InvalidParameterException ( 'Error: mergeScope() - Invalid permission scope parameter used.' ) ; } return $ intersectingScope ; }
2509	protected function findBuilderForMessage ( $ messageName ) { $ builder = null ; if ( array_key_exists ( $ messageName , $ this -> messageBuilders ) && $ this -> messageBuilders [ $ messageName ] instanceof ConvertInterface ) { $ builder = $ this -> messageBuilders [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ builderClass = __NAMESPACE__ . '\\Converter\\' . $ section . '\\' . $ message . "Conv" ; if ( class_exists ( $ builderClass ) ) { $ builder = new $ builderClass ( ) ; $ builder -> setParams ( $ this -> params ) ; $ this -> messageBuilders [ $ messageName ] = $ builder ; } } return $ builder ; }
3363	private function loadChunk ( ) { $ portion = $ this -> pdGetDataChunk ( $ this -> api , $ this -> options , $ this -> reverse ) ; $ this -> options = $ portion [ 'params' ] ; $ this -> nextPageParams = $ portion [ 'nextParams' ] ; $ this -> prevPageParams = $ portion [ 'prevParams' ] ; if ( $ portion [ 'data' ] ) { $ this -> container = array_merge ( $ this -> container , $ portion [ 'data' ] ) ; } if ( ! count ( $ portion [ 'params' ] ) ) { $ this -> fullyLoaded = true ; } }
12661	public function createAuthorizerApplication ( $ appId , $ refreshToken ) { $ this -> fetch ( 'authorizer' , function ( $ authorizer ) use ( $ appId , $ refreshToken ) { $ authorizer -> setAppId ( $ appId ) ; $ authorizer -> setRefreshToken ( $ refreshToken ) ; } ) ; return $ this -> fetch ( 'app' , function ( $ app ) { $ app [ 'access_token' ] = $ this -> fetch ( 'authorizer_access_token' ) ; $ app [ 'oauth' ] = $ this -> fetch ( 'oauth' ) ; $ app [ 'server' ] = $ this -> fetch ( 'server' ) ; } ) ; }
2503	public static function loadMessagesAndVersions ( $ wsdls ) { $ msgAndVer = [ ] ; foreach ( $ wsdls as $ wsdl ) { $ wsdlIdentifier = self :: makeWsdlIdentifier ( $ wsdl ) ; self :: $ wsdlIds [ $ wsdlIdentifier ] = $ wsdl ; self :: loadWsdlXpath ( $ wsdl , $ wsdlIdentifier ) ; $ operations = self :: $ wsdlDomXpath [ $ wsdlIdentifier ] -> query ( self :: XPATH_ALL_OPERATIONS ) ; if ( $ operations -> length === 0 ) { $ imports = self :: $ wsdlDomXpath [ $ wsdlIdentifier ] -> query ( self :: XPATH_IMPORTS ) ; $ operations = [ ] ; foreach ( $ imports as $ import ) { if ( ! empty ( $ import -> value ) ) { $ tmpMsg = self :: getMessagesAndVersionsFromImportedWsdl ( $ import -> value , $ wsdl , $ wsdlIdentifier ) ; foreach ( $ tmpMsg as $ msgName => $ msgInfo ) { $ msgAndVer [ $ msgName ] = $ msgInfo ; } } } } $ msgAndVer = array_merge ( $ msgAndVer , self :: loopOperationsWithQuery ( $ operations , self :: XPATH_VERSION_FOR_OPERATION , $ wsdlIdentifier , self :: $ wsdlDomXpath [ $ wsdlIdentifier ] ) ) ; } return $ msgAndVer ; }
8352	public function handle ( int $ signal ) { if ( isset ( $ this -> handlers [ $ signal ] ) && $ this -> handlers [ $ signal ] === true ) { return new Failure ( new Exception ( 'Signal is already being processed.' ) ) ; } $ this -> handlers [ $ signal ] = true ; $ this -> dispatcher -> setIsRunning ( false ) ; $ fn = $ this -> signals [ $ signal ] ; $ result = $ this -> $ fn ( ) ; if ( $ result === true ) { unset ( $ this -> handlers [ $ signal ] ) ; return new Success ( $ result ) ; } $ deferred = new Deferred ; Loop :: repeat ( 1000 , function ( $ watcherId , $ callback ) use ( $ deferred , $ signal , $ result ) { if ( count ( $ this -> dispatcher -> getProcesses ( ) ) === 0 ) { Loop :: cancel ( $ watcherId ) ; unset ( $ this -> handlers [ $ signal ] ) ; return $ deferred -> resolve ( $ result ) ; } } ) ; return $ deferred -> promise ( ) ; }
7890	protected function getDefaultProjectHook ( ) { $ default = $ this -> config -> get ( self :: CONFIG_DEFAULT ) ; return $ this -> config -> get ( sprintf ( self :: CONFIG_PROJECT , $ default ) ) ; }
8830	protected function getSelectedValue ( $ value , $ selected ) { if ( is_array ( $ selected ) ) { return in_array ( $ value , $ selected , true ) ? 'selected' : null ; } return ( ( string ) $ value == ( string ) $ selected ) ? 'selected' : null ; }
7049	protected function buildGoodsLines ( Document \ DocumentInterface $ document ) { foreach ( $ document -> getSale ( ) -> getItems ( ) as $ item ) { $ this -> buildGoodLine ( $ item , $ document ) ; } }
6073	public function group ( $ id , array $ children ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'children' => $ children ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/group' , $ parameters ) ; return $ result ; }
8221	protected function getEntityId ( $ blockType , $ config , $ params = array ( ) ) { $ entityId = null ; if ( $ blockType === "account" && isset ( $ params [ "name" ] ) ) { $ entityId = md5 ( $ params [ "name" ] ) ; } elseif ( $ blockType === "email" && isset ( $ params [ "email" ] ) ) { $ entityId = md5 ( $ params [ "email" ] ) ; } elseif ( $ blockType === "ip" ) { $ entityId = $ this -> getIp ( $ config ) ; } return $ entityId ; }
1207	public function moveToPosition ( ItemInterface $ item , $ position ) { $ this -> moveChildToPosition ( $ item -> getParent ( ) , $ item , $ position ) ; }
12125	public function getAliasIdForLanguage ( $ language ) { foreach ( $ this -> aliases as $ key => $ alias ) { if ( $ alias -> getLanguage ( ) == $ language ) { return $ key ; } } return null ; }
5807	public function onAfterWrite ( ) { parent :: onAfterWrite ( ) ; $ write = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ write = $ field ; } } $ changed = $ this -> owner -> getChangedFields ( ) ; $ existing = FusionTag :: get ( ) -> filter ( 'Title' , $ this -> owner -> $ write ) -> first ( ) ; if ( is_null ( $ this -> owner -> FusionTagID ) && ! $ existing ) { $ fusion = FusionTag :: create ( ) ; $ fusion -> Title = $ this -> owner -> $ write ; $ fusion -> TagTypes = serialize ( array ( $ class => $ class ) ) ; $ fusion -> write ( ) ; $ this -> owner -> FusionTagID = $ fusion -> ID ; $ this -> owner -> write ( ) ; } else if ( is_null ( $ this -> owner -> FusionTagID ) && $ existing ) { $ types = unserialize ( $ existing -> TagTypes ) ; $ types [ $ class ] = $ class ; $ existing -> TagTypes = serialize ( $ types ) ; $ existing -> write ( ) ; $ this -> owner -> FusionTagID = $ existing -> ID ; $ this -> owner -> write ( ) ; } else if ( isset ( $ changed [ $ write ] ) && ! isset ( $ changed [ 'FusionTagID' ] ) && $ existing && ( $ existing -> ID != $ this -> owner -> FusionTagID ) ) { $ fusion = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ; $ types = unserialize ( $ fusion -> TagTypes ) ; unset ( $ types [ $ this -> owner -> ClassName ] ) ; $ fusion -> TagTypes = ! empty ( $ types ) ? serialize ( $ types ) : null ; $ fusion -> write ( ) ; $ types = unserialize ( $ existing -> TagTypes ) ; $ types [ $ class ] = $ class ; $ existing -> TagTypes = serialize ( $ types ) ; $ existing -> write ( ) ; $ this -> owner -> FusionTagID = $ existing -> ID ; $ this -> owner -> write ( ) ; } else if ( isset ( $ changed [ $ write ] ) && ! isset ( $ changed [ 'FusionTagID' ] ) && ( $ existing = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ) ) { $ existing -> Title = $ changed [ $ write ] [ 'after' ] ; $ existing -> write ( ) ; } }
3786	public function addListener ( $ eventName , $ listener , $ priority = 200 ) { $ dispatcher = $ this -> getServiceContainer ( ) -> getEventDispatcher ( ) ; $ dispatcher -> addListener ( $ eventName , $ listener , $ priority ) ; return $ this ; }
3287	public function plugin ( $ name , array $ options = null ) { $ helper = $ this -> getTwigHelpers ( ) -> setRenderer ( $ this ) ; if ( $ helper -> has ( $ name ) ) { return $ helper -> get ( $ name , $ options ) ; } return $ this -> getHelperPluginManager ( ) -> get ( $ name , $ options ) ; }
864	private function registerFoundToken ( $ token ) { $ tokenKind = $ token instanceof Token ? ( $ token -> isArray ( ) ? $ token -> getId ( ) : $ token -> getContent ( ) ) : ( \ is_array ( $ token ) ? $ token [ 0 ] : $ token ) ; if ( ! isset ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { $ this -> foundTokenKinds [ $ tokenKind ] = 0 ; } ++ $ this -> foundTokenKinds [ $ tokenKind ] ; }
3919	public static function convertUuidsOrPathsToMetaModels ( $ values ) { $ values = array_filter ( ( array ) $ values ) ; if ( empty ( $ values ) ) { return array ( 'bin' => array ( ) , 'value' => array ( ) , 'path' => array ( ) , 'meta' => array ( ) ) ; } foreach ( $ values as $ key => $ value ) { if ( ! ( Validator :: isUuid ( $ value ) ) ) { $ file = FilesModel :: findByPath ( $ value ) ? : Dbafs :: addResource ( $ value ) ; if ( ! $ file ) { throw new InvalidArgumentException ( 'Invalid value.' ) ; } $ values [ $ key ] = $ file -> uuid ; } } return self :: convertValuesToMetaModels ( $ values ) ; }
5525	protected function createCodeForClass ( $ methods ) { $ implements = '' ; $ interfaces = $ this -> reflection -> getInterfaces ( ) ; $ interfaces = array_diff ( $ interfaces , [ 'Traversable' , 'Throwable' ] ) ; if ( count ( $ interfaces ) > 0 ) { $ implements = 'implements ' . implode ( ', ' , $ interfaces ) ; } $ code = 'class ' . $ this -> mock_class . ' extends ' . $ this -> mock_base . ' ' . $ implements . " {\n" ; $ code .= " function __construct() {\n" ; $ code .= " parent::__construct();\n" ; $ code .= " }\n" ; $ code .= $ this -> createCodeForConstructor ( ) ; $ code .= $ this -> createCodeForMethods ( $ methods ) ; $ code .= "}\n" ; return $ code ; }
849	public function getPrevTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , - 1 , $ tokens , $ caseSensitive ) ; }
3423	protected function groupsMustBeSelected ( ) { return in_array ( 'GROUPS' , $ this -> select ) || in_array ( 'GROUP_ID' , $ this -> select ) || in_array ( 'GROUPS_ID' , $ this -> select ) ; }
6623	public function parseResponse ( Response $ response ) { $ json = $ response -> json ( ) ; if ( ! is_null ( $ json ) ) { if ( isset ( $ json -> error ) ) { $ error = $ json -> error ; throw new AccessTokenException ( $ error -> type . ': ' . $ error -> message , $ error -> code ) ; } } $ token = $ response -> content ( ) ; return $ this -> parseToken ( $ token ) ; }
6889	protected function getAssignments ( $ item ) { if ( $ item instanceof ShipmentItemInterface ) { $ item = $ item -> getSaleItem ( ) ; } elseif ( $ item instanceof InvoiceLineInterface ) { if ( ! $ item = $ item -> getSaleItem ( ) ) { return null ; } } if ( ! $ this -> supportsAssignment ( $ item ) ) { return null ; } return $ item -> getStockAssignments ( ) -> toArray ( ) ; }
9908	public function setPosition ( $ position ) { if ( ! in_array ( $ position , self :: $ positionXLref ) ) { return false ; } $ this -> position = $ position ; return true ; }
11692	private function buildParsedRequests ( ApiParseResult $ parseResult ) : array { $ requests = [ ] ; foreach ( $ parseResult -> getApi ( ) -> getResourceGroups ( ) as $ apiResourceGroup ) { foreach ( $ apiResourceGroup -> getResources ( ) as $ apiResource ) { foreach ( $ apiResource -> getTransitions ( ) as $ apiStateTransition ) { foreach ( $ apiStateTransition -> getHttpTransactions ( ) as $ apiHttpTransaction ) { $ this -> processApiHttpTransactions ( $ apiHttpTransaction , $ apiResourceGroup , $ apiResource , $ apiStateTransition , $ requests ) ; } } } } return $ requests ; }
1938	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> newsletters ) || ! \ is_array ( $ this -> User -> newsletters ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> newsletters ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_newsletter_channel' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_newsletter_channel' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, newsletters, newsletterp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrNewsletterp = Contao \ StringUtil :: deserialize ( $ objGroup -> newsletterp ) ; if ( \ is_array ( $ arrNewsletterp ) && \ in_array ( 'create' , $ arrNewsletterp ) ) { $ arrNewsletters = Contao \ StringUtil :: deserialize ( $ objGroup -> newsletters , true ) ; $ arrNewsletters [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET newsletters=? WHERE id=?" ) -> execute ( serialize ( $ arrNewsletters ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT newsletters, newsletterp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrNewsletterp = Contao \ StringUtil :: deserialize ( $ objUser -> newsletterp ) ; if ( \ is_array ( $ arrNewsletterp ) && \ in_array ( 'create' , $ arrNewsletterp ) ) { $ arrNewsletters = Contao \ StringUtil :: deserialize ( $ objUser -> newsletters , true ) ; $ arrNewsletters [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET newsletters=? WHERE id=?" ) -> execute ( serialize ( $ arrNewsletters ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> newsletter = $ root ; } }
3822	public function purge ( ) { $ fileSystem = new Filesystem ( ) ; $ fileSystem -> remove ( $ this -> cacheDir ) ; $ this -> logger -> log ( LogLevel :: INFO , 'Purged the MetaModels cache' , [ 'contao' => new ContaoContext ( __METHOD__ , TL_CRON ) ] ) ; }
5802	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ permissions = $ this -> permissionsEntityMapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) ) ; } catch ( QueryFailureException $ e ) { $ permissions = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ permissions ) ; }
3216	function chunkedUploadStart ( $ data ) { Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( ) , $ data ) ; if ( $ response -> statusCode === 404 ) { throw new Exception_BadResponse ( "Got a 404, but we didn't send up an 'upload_id'" ) ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) throw new Exception_BadResponse ( "Got an offset-correcting 400 response, but we didn't send an offset" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ uploadId , $ byteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ len = strlen ( $ data ) ; if ( $ byteOffset !== $ len ) throw new Exception_BadResponse ( "We sent $len bytes, but server returned an offset of $byteOffset" ) ; return $ uploadId ; }
4177	public function getMigration ( ) { return $ this -> migration ? : $ this -> migration = new Migration ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
5949	public function setResults ( array $ results ) { $ this -> results = [ ] ; foreach ( $ results as $ item ) { switch ( $ item [ 'discriminatorId' ] ) { case ObjectResponse :: DISCRIMINATOR_FOLDER : $ this -> addFolderResponse ( $ item ) ; break ; case ObjectResponse :: DISCRIMINATOR_MEDIA : default : $ this -> addMediaResponse ( $ item ) ; break ; } } return $ this ; }
10441	protected function getLineType ( $ line ) { if ( preg_match ( '/^###\s+@[0-9]+=.*$/' , $ line ) ) { return self :: LINE_TYPE_PARAM ; } elseif ( preg_match ( '/^###/' , $ line ) ) { return self :: LINE_TYPE_QUERY ; } elseif ( preg_match ( '/^#[0-9]/' , $ line ) ) { return self :: LINE_TYPE_META ; } elseif ( preg_match ( '/Errcode|ERROR/' , $ line ) ) { return self :: LINE_TYPE_ERROR ; } return self :: LINE_TYPE_UNKNOWN ; }
8209	protected function parseArguments ( ) { $ this -> parseConnection ( $ this -> option ( 'connection' ) ) ; if ( $ this -> option ( 'host' ) ) { $ this -> host = $ this -> option ( 'host' ) ; } if ( $ this -> option ( 'port' ) ) { $ this -> port = ( int ) $ this -> option ( 'port' ) ; } $ this -> parseCommandArguments ( ) ; }
5837	public function transform ( $ orig , $ transformation = null , $ overrides = array ( ) ) { return $ this -> transformer -> transform ( $ orig , $ transformation , $ overrides ) ; }
2152	public function synchronize ( $ varValue , $ objUser , $ objModule = null ) { if ( $ objUser === null ) { return $ varValue ; } $ blnIsFrontend = true ; if ( $ objUser instanceof DataContainer ) { $ objUser = $ this -> Database -> prepare ( "SELECT * FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ objUser -> id ) ; if ( $ objUser -> numRows < 1 ) { return $ varValue ; } $ blnIsFrontend = false ; } if ( $ varValue == $ objUser -> newsletter || $ objUser -> email == '' ) { return $ varValue ; } $ time = time ( ) ; $ varValue = StringUtil :: deserialize ( $ varValue , true ) ; if ( $ blnIsFrontend && $ objModule instanceof Module ) { $ arrChannel = StringUtil :: deserialize ( $ objModule -> newsletters , true ) ; } else { $ arrChannel = $ this -> Database -> query ( "SELECT id FROM tl_newsletter_channel" ) -> fetchEach ( 'id' ) ; } $ arrDelete = array_values ( array_diff ( $ arrChannel , $ varValue ) ) ; if ( ! empty ( $ arrDelete ) && \ is_array ( $ arrDelete ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrDelete ) ) . ") AND email=?" ) -> execute ( $ objUser -> email ) ; } foreach ( $ varValue as $ intId ) { $ intId = ( int ) $ intId ; if ( $ intId < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intId , $ objUser -> email ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, active=?, addedOn=?" ) -> execute ( $ intId , $ objUser -> email , ( $ objUser -> disable ? '' : 1 ) , ( $ blnIsFrontend ? $ time : '' ) ) ; } } return serialize ( $ varValue ) ; }
8991	public function build ( $ attributes = null ) { if ( $ attributes instanceof \ ElggEntity ) { return $ attributes ; } if ( is_numeric ( $ attributes ) ) { return $ this -> get ( $ attributes ) ; } $ attributes = ( array ) $ attributes ; if ( ! empty ( $ attributes [ 'guid' ] ) ) { return $ this -> get ( $ attributes [ 'guid' ] ) ; } $ type = elgg_extract ( 'type' , $ attributes , 'object' ) ; $ subtype = elgg_extract ( 'subtype' , $ attributes , ELGG_ENTITIES_ANY_VALUE ) ; unset ( $ attributes [ 'type' ] ) ; unset ( $ attributes [ 'subtype' ] ) ; $ class = get_subtype_class ( $ type , $ subtype ) ; if ( class_exists ( $ class ) ) { $ entity = new $ class ( ) ; } else { switch ( $ type ) { case 'object' : $ entity = new \ ElggObject ( ) ; $ entity -> subtype = $ subtype ; break ; case 'user' : $ entity = new \ ElggUser ( ) ; $ entity -> subtype = $ subtype ; break ; case 'group' : $ entity = new \ ElggGroup ( ) ; $ entity -> subtype = $ subtype ; break ; } } foreach ( $ attributes as $ key => $ value ) { if ( in_array ( $ key , $ this -> getAttributeNames ( $ entity ) ) ) { $ entity -> $ key = $ value ; } } return $ entity ; }
6866	protected function preventForbiddenChange ( InvoiceInterface $ invoice ) { if ( $ this -> persistenceHelper -> isChanged ( $ invoice , 'type' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'type' ) ; if ( $ old != $ new ) { throw new Exception \ IllegalOperationException ( "Changing the invoice type is not yet supported." ) ; } } }
5117	public function deleteArticle ( string $ idArticle ) : ? string { $ articleOnRest = $ this -> getArticle ( $ idArticle ) ; if ( ! empty ( $ articleOnRest ) ) { $ articleOnRest = json_decode ( $ articleOnRest , true ) ; if ( isset ( $ articleOnRest [ 'data' ] ) ) { foreach ( Article :: getDeleteableAttachment ( ) as $ field ) { if ( isset ( $ articleOnRest [ 'data' ] [ $ field ] ) ) { foreach ( $ articleOnRest [ 'data' ] [ $ field ] as $ attachment ) { if ( isset ( $ attachment [ $ field . '_order' ] ) ) { $ this -> deleteAttachment ( $ idArticle , $ field , $ attachment [ $ field . '_order' ] ) ; } } } } } return $ this -> delete ( $ this -> getArticleWithIdEndPoint ( $ idArticle ) ) ; } }
12444	public static function run ( $ source , $ destination , $ width , $ height = "" ) { $ mime = exif_imagetype ( $ source ) ; switch ( $ mime ) { case IMAGETYPE_JPEG : $ source = imagecreatefromjpeg ( $ source ) ; break ; case IMAGETYPE_PNG : $ source = imagecreatefrompng ( $ source ) ; break ; case IMAGETYPE_GIF : $ source = imagecreatefromgif ( $ source ) ; break ; default : return ; } $ width_src = imagesx ( $ source ) ; $ height_src = imagesy ( $ source ) ; $ width_dest = 0 ; $ height_dest = 0 ; if ( ! $ height ) { $ ratio = ( $ width * 100 ) / $ width_src ; if ( $ ratio > 100 ) { imagejpeg ( $ source , $ destination , 70 ) ; imagedestroy ( $ source ) ; return ; } $ width_dest = $ width ; $ height_dest = $ height_src * $ ratio / 100 ; } else { if ( $ height_src >= $ width_src ) { $ height_dest = ( $ height_src * $ width ) / $ width_src ; $ width_dest = $ width ; } elseif ( $ height_src < $ width_src ) { $ width_dest = ( $ width_src * $ height ) / $ height_src ; $ height_dest = $ height ; } } $ emptyPicture = imagecreatetruecolor ( $ width , ( $ height ) ? $ height : $ height_dest ) ; imagecopyresampled ( $ emptyPicture , $ source , 0 , 0 , 0 , 0 , $ width_dest , $ height_dest , $ width_src , $ height_src ) ; imagejpeg ( $ emptyPicture , $ destination , 70 ) ; imagedestroy ( $ source ) ; imagedestroy ( $ emptyPicture ) ; return ; }
3765	private function mapTranslations ( $ array , $ domain , StaticTranslator $ translator , $ baseKey = '' ) { foreach ( $ array as $ key => $ value ) { $ newKey = ( $ baseKey ? $ baseKey . '.' : '' ) . $ key ; if ( is_array ( $ value ) ) { $ this -> mapTranslations ( $ value , $ domain , $ translator , $ newKey ) ; } else { $ translator -> setValue ( $ newKey , $ value , $ domain ) ; } } }
9170	public function updateCompany ( \ Unite \ Contacts \ Http \ Requests \ UpdateRequest $ request ) { $ this -> service -> saveCompanyProfile ( $ request -> all ( ) ) ; return $ this -> successJsonResponse ( ) ; }
6858	protected static function solsticeJune ( $ year , $ vsop = true ) { $ month = 6 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
3044	public function encode ( $ data ) { if ( is_array ( $ data ) ) { $ encodedData = [ self :: STORAGE_KEY_FORMAT => $ this -> getFormat ( ) , self :: STORAGE_KEY_VERSION => $ this -> getVersion ( ) , ] ; foreach ( $ data as $ key => & $ value ) { if ( $ value instanceof TimeLine ) { $ encodedData [ $ key ] = $ this -> packTimeLine ( $ value ) ; } else { $ encodedData [ $ key ] = & $ value ; } } return json_encode ( $ encodedData ) ; } return json_encode ( $ data ) ; }
10809	protected function __templates ( $ customTemplate = null , $ customTemplateSuffix = null ) { $ templates = SSViewer :: get_templates_by_class ( $ this -> class , $ customTemplateSuffix , \ FormField :: class ) ; if ( ! $ templates ) { throw new \ Exception ( "No template found for {$this->class}" ) ; } if ( $ customTemplate ) { array_unshift ( $ templates , $ customTemplate ) ; } return $ templates ; }
6001	public function addImageTemplate ( $ item ) { if ( ! ( $ item instanceof ImageTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new ImageTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate ImageTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "ImageTemplate"!' , E_USER_WARNING ) ; } } $ this -> imagetemplates [ ] = $ item ; return $ this ; }
7261	protected function assertAdjustmentType ( Model \ AdjustmentInterface $ adjustment , string $ expected ) : void { if ( $ expected !== $ type = $ adjustment -> getType ( ) ) { throw new Exception \ InvalidArgumentException ( "Unexpected adjustment type '$type'." ) ; } }
731	protected function getUniqueIndexInformation ( $ table ) { $ sql = <<<'SQL'SELECT i.relname as indexname, pg_get_indexdef(idx.indexrelid, k + 1, TRUE) AS columnnameFROM ( SELECT *, generate_subscripts(indkey, 1) AS k FROM pg_index) idxINNER JOIN pg_class i ON i.oid = idx.indexrelidINNER JOIN pg_class c ON c.oid = idx.indrelidINNER JOIN pg_namespace ns ON c.relnamespace = ns.oidWHERE idx.indisprimary = FALSE AND idx.indisunique = TRUEAND c.relname = :tableName AND ns.nspname = :schemaNameORDER BY i.relname, kSQL ; return $ this -> db -> createCommand ( $ sql , [ ':schemaName' => $ table -> schemaName , ':tableName' => $ table -> name , ] ) -> queryAll ( ) ; }
792	public function clearErrors ( $ attribute = null ) { if ( $ attribute === null ) { $ this -> _errors = [ ] ; } else { unset ( $ this -> _errors [ $ attribute ] ) ; } }
4280	public function stream_stat ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ array = \ fstat ( $ this -> handle ) ; self :: register ( ) ; return $ array ; }
9892	protected function createError ( ) { $ error = $ this -> getForm ( ) -> getValidator ( ) -> getMessages ( $ this -> getElement ( ) -> getName ( ) ) ; if ( $ error ) { $ this -> error = $ this -> builder -> make ( 'error' , [ ] , $ error ) ; } }
2163	public function run40Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `scripts` text NULL" ) ; $ objLayout = $ this -> Database -> query ( "SELECT id, addJQuery, jquery, addMooTools, mootools FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrScripts = array ( ) ; if ( $ objLayout -> addJQuery ) { $ jquery = StringUtil :: deserialize ( $ objLayout -> jquery ) ; if ( ! empty ( $ jquery ) && \ is_array ( $ jquery ) ) { if ( ( $ key = array_search ( 'j_slider' , $ jquery ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ jquery [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET jquery=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ jquery ) ) , $ objLayout -> id ) ; } } } if ( $ objLayout -> addMooTools ) { $ mootools = StringUtil :: deserialize ( $ objLayout -> mootools ) ; if ( ! empty ( $ mootools ) && \ is_array ( $ mootools ) ) { if ( ( $ key = array_search ( 'moo_slider' , $ mootools ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ mootools [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET mootools=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ mootools ) ) , $ objLayout -> id ) ; } } } if ( ! empty ( $ arrScripts ) ) { $ this -> Database -> prepare ( "UPDATE tl_layout SET scripts=? WHERE id=?" ) -> execute ( serialize ( array_values ( array_unique ( $ arrScripts ) ) ) , $ objLayout -> id ) ; } } }
11270	public function display ( $ template , array $ vars = array ( ) ) { if ( null === ( $ path = $ this -> locator -> locate ( $ template ) ) ) { throw TemplateNotFoundException :: format ( 'The template "%s" does not exist.' , $ template ) ; } $ this -> renderInScope ( $ path , array_replace ( $ this -> getArrayCopy ( ) , $ vars ) ) ; }
1278	public static function addLocationInformation ( stdClass $ location , DOMNode $ locationNode ) { self :: appendChild ( $ location , 'CompanyName' , $ locationNode ) ; self :: appendChild ( $ location , 'AttentionName' , $ locationNode ) ; if ( isset ( $ location -> Address ) ) { self :: addAddressNode ( $ location -> Address , $ locationNode ) ; } }
7661	function SetWordWrap ( ) { if ( $ this -> WordWrap < 1 ) return ; switch ( $ this -> message_type ) { case "alt" : case "alt_attachments" : $ this -> AltBody = $ this -> WrapText ( $ this -> AltBody , $ this -> WordWrap ) ; break ; default : $ this -> Body = $ this -> WrapText ( $ this -> Body , $ this -> WordWrap ) ; break ; } }
5588	public function setCookies ( array $ lstCookies ) { foreach ( $ lstCookies as $ aCookies ) { $ this -> cookie_jar -> setCookie ( $ aCookies [ 'name' ] , $ aCookies [ 'value' ] , $ aCookies [ 'host' ] , $ aCookies [ 'path' ] , $ aCookies [ 'expiry' ] ) ; } }
1612	private function _setCriteriaIdByType ( $ criteria , Element $ type , $ id ) { switch ( $ type :: className ( ) ) { case 'Entry' : $ criteria -> sectionId = $ id ; break ; case 'Category' : $ criteria -> groupId = $ id ; break ; } }
5772	public function getRolesString ( ) : string { $ rolesString = "" ; foreach ( $ this -> roleNames as $ role ) { $ rolesString .= "$role, " ; } return Functions :: removeLastCharsFromString ( $ rolesString , 2 ) ; }
5494	public function findFirstAction ( $ parameters ) { $ slot = $ this -> findFirstSlot ( $ parameters ) ; if ( isset ( $ slot ) && isset ( $ slot [ 'content' ] ) ) { return $ slot [ 'content' ] ; } return ; }
4500	public function matches ( string $ selectors ) : bool { $ matches = $ this -> getRootDocument ( ) -> querySelectorAll ( $ selectors ) ; $ i = $ matches -> length ; while ( -- $ i >= 0 && $ matches -> item ( $ i ) !== $ this ) { ; } return ( $ i >= 0 ) ; }
5118	public function deleteAttachment ( string $ idArticle , string $ field , string $ order ) : string { return $ this -> delete ( $ this -> getAttachmentEndPoint ( $ idArticle , $ field ) . "/${order}" ) ; }
11624	public function getContent ( Location $ location = null , Operation $ operation ) { if ( $ operation ) { $ status = $ this -> contentService -> getSocialMediaScheduleByOperation ( $ operation ) ; return $ status ; } return null ; }
8082	public function report ( $ message ) { $ channel = $ this -> currentChannel ; if ( $ message ) { $ reports = & $ this -> getReports ( $ channel ) ; $ reports [ ] = $ message ; } return $ this ; }
8481	public static function getNameById ( $ id , $ attributeName = 'name' ) { $ model = static :: loadModel ( $ id ) ; return empty ( $ model [ $ attributeName ] ) === false ? $ model [ $ attributeName ] : \ Yii :: t ( 'app' , 'Unknown' ) ; }
2100	public static function getNumericTimeFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> timeFormat != '' && static :: isNumericFormat ( $ objPage -> timeFormat ) ) { return $ objPage -> timeFormat ; } } return Config :: get ( 'timeFormat' ) ; }
5738	public function setDefaultSuffix ( $ defaultSuffix ) { $ this -> defaultSuffix = ( string ) $ defaultSuffix ; $ this -> defaultSuffix = ltrim ( $ this -> defaultSuffix , '.' ) ; return $ this ; }
11736	public function setAddress ( $ address ) { $ address = trim ( $ address , self :: SEPARATOR ) ; if ( ! filter_var ( $ address , FILTER_VALIDATE_URL ) ) { throw new \ InvalidArgumentException ( "$address is not valid format of url address." ) ; } $ this -> address = $ address ; $ this -> parse = parse_url ( $ address ) ; return $ this ; }
5672	protected function describeFloatDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } return sprintf ( 'because [%s] differs from [%s] by %s' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) , abs ( $ first - $ second ) ) ; }
12707	public static function parseSignature ( string $ signature ) : array { $ signature = explode ( ' ' , trim ( $ signature ) ) ; $ command = trim ( $ signature [ 0 ] ) ; $ arguments = [ ] ; $ options = [ ] ; foreach ( $ signature as $ word ) { $ type = self :: determineTypeOfWord ( $ word ) ; if ( $ type == self :: OPTION_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ options [ $ key ] = $ defaultValue ; } elseif ( $ type == self :: ARGUMENT_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ arguments [ $ key ] = $ defaultValue ; } } return [ $ command , $ arguments , $ options ] ; }
3061	public function getCurrentPosition ( ) { $ route = $ this -> getTestSession ( ) -> getRoute ( ) ; $ routeCount = $ route -> count ( ) ; $ routeItemPosition = $ route -> getPosition ( ) ; $ currentRouteItem = $ route -> getRouteItemAt ( $ routeItemPosition ) ; $ finalPosition = 0 ; for ( $ i = 0 ; $ i < $ routeCount ; $ i ++ ) { $ routeItem = $ route -> getRouteItemAt ( $ i ) ; if ( $ routeItem !== $ currentRouteItem ) { if ( ! $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition ++ ; } else { $ finalPosition += count ( $ this -> getShadowTest ( $ routeItem ) ) ; } } else { if ( $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition += array_search ( $ this -> getCurrentCatItemId ( $ routeItem ) , $ this -> getShadowTest ( $ routeItem ) ) ; } break ; } } return $ finalPosition ; }
3817	private function fetchExisting ( $ table , $ parentId ) { $ this -> startSort = 0 ; $ this -> knownAttributes = [ ] ; $ alreadyExisting = $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( $ table ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ parentId ) -> orderBy ( 'sorting' ) -> execute ( ) ; foreach ( $ alreadyExisting -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ this -> knownAttributes [ $ item [ 'attr_id' ] ] = $ item ; $ this -> startSort = $ item [ 'sorting' ] ; } return $ this -> knownAttributes ; }
1456	protected function validateHasMany ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasManyExpected ( $ key ) ) ; return false ; } $ identifiers = $ relationship -> getIdentifiers ( ) ; if ( ! $ this -> validateIdentifiers ( $ identifiers , $ record , $ key , $ resource ) ) { return false ; } return true ; }
10295	public static function dayStringToNumber ( $ day ) { $ strippedDayValue = ( str_replace ( self :: $ numberSuffixes , '' , $ day ) ) ; if ( is_numeric ( $ strippedDayValue ) ) { return ( int ) $ strippedDayValue ; } return $ day ; }
6201	public function addRoute ( $ newRoute ) { $ this -> routeMap [ 'routes' ] = array_merge ( $ this -> routeMap [ 'routes' ] , $ newRoute ) ; $ this -> routeMapParse = array_merge ( $ this -> routeMapParse , $ newRoute ) ; }
7257	public function urlAllowed ( $ url ) { if ( $ this -> _viewAuth ) { return $ this -> _viewAuth [ 'AuthActions' ] -> urlAllowed ( $ this -> user ( ) , $ url ) ; } return false ; }
12153	public function getPossibleRoles ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = true ; switch ( $ roleItem -> systemId ) { case 'owner' : $ test = $ this -> isOwnable ; break ; } if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
9027	public function isQuestion ( $ string ) { $ probability = 0 ; if ( strpos ( $ string , '?' ) ) { $ probability += 1 ; } $ words = $ this -> getWords ( $ string ) ; foreach ( $ this -> inquiryWords as $ queryWord ) { if ( ! strncmp ( strtolower ( $ string ) , $ queryWord , strlen ( $ queryWord ) ) ) { $ probability += 1 ; } elseif ( stristr ( strtolower ( $ string ) , $ queryWord ) ) { $ probability += 0.5 ; } } if ( $ probability >= 2 ) { return true ; } return false ; }
1780	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'calendar' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } $ this -> cal_calendar = $ this -> sortOutProtected ( StringUtil :: deserialize ( $ this -> cal_calendar , true ) ) ; if ( empty ( $ this -> cal_calendar ) || ! \ is_array ( $ this -> cal_calendar ) ) { return '' ; } $ this -> strUrl = preg_replace ( '/\?.*$/' , '' , Environment :: get ( 'request' ) ) ; $ this -> strLink = $ this -> strUrl ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> strLink = $ objTarget -> getFrontendUrl ( ) ; } return parent :: generate ( ) ; }
7656	function AddReplyTo ( $ address , $ name = "" ) { $ cur = count ( $ this -> ReplyTo ) ; $ this -> ReplyTo [ $ cur ] [ 0 ] = trim ( $ address ) ; $ this -> ReplyTo [ $ cur ] [ 1 ] = $ name ; }
2583	protected function prepareForNextMessage ( $ messageName , $ messageOptions ) { if ( ! $ this -> isAuthenticated && $ messageName !== 'Security_Authenticate' ) { throw new InvalidSessionException ( 'No active session' ) ; } $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( null ) ; if ( $ this -> isAuthenticated === true && is_int ( $ this -> sessionData [ 'sequenceNumber' ] ) ) { $ this -> sessionData [ 'sequenceNumber' ] ++ ; $ session = new Client \ Struct \ HeaderV2 \ Session ( $ this -> sessionData [ 'sessionId' ] , $ this -> sessionData [ 'sequenceNumber' ] , $ this -> sessionData [ 'securityToken' ] ) ; $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( new \ SoapHeader ( self :: CORE_WS_V2_SESSION_NS , self :: NODENAME_SESSION , $ session ) ) ; } }
5635	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print '<span class="fail">Exception</span>: ' ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print implode ( ' -&gt; ' , $ breadcrumb ) ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print ' -&gt; <strong>' . $ this -> htmlEntities ( $ message ) . "</strong><br />\n" ; }
9448	public function getPackPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) ; } return $ paths [ $ me ] ; }
11032	protected function supports ( $ attribute , $ subject ) { if ( ! in_array ( $ attribute , array ( self :: MENU , self :: PERMISO ) ) ) { return false ; } if ( $ attribute == self :: MENU && ! is_null ( $ subject ) && ! $ subject instanceof Menu ) { return false ; } return true ; }
8937	public function readChangeset ( $ id ) { $ base = 'changeset/' . $ id ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> changeset ; }
6849	public static function months ( $ format = null ) { $ months = array ( ) ; if ( $ format === static :: MONTHS_LONG || $ format === static :: MONTHS_SHORT ) { for ( $ i = 1 ; $ i <= 12 ; ++ $ i ) { $ months [ $ i ] = strftime ( $ format , mktime ( 0 , 0 , 0 , $ i , 1 ) ) ; } } else { $ months = static :: hours ( ) ; } return $ months ; }
3111	public function getStorageService ( ) { if ( ! $ this -> storageService ) { $ this -> storageService = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storageService ; }
10482	public function getBucket ( string $ name ) : SessionBucketInterface { $ segment = $ this -> session -> getSegment ( $ name ) ; if ( ! $ segment ) { return null ; } return new AuraSessionBucketAdapter ( $ segment ) ; }
12616	public function setAttributes ( array $ attributes ) { foreach ( $ attributes as $ key => $ attribute ) { if ( ! ( $ attribute instanceof AttributeInterface ) ) { if ( is_array ( $ attribute ) ) { $ attr = new AttributeCollection ( $ key ) ; $ attr -> setAttributes ( $ attribute ) ; $ attribute = $ attr ; } else { $ attribute = new Attribute ( $ key , $ attribute ) ; } } $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; } }
8130	public function addSuggestions ( $ name , array $ items ) { if ( ! $ alternatives = self :: computeAlternatives ( $ name , $ items ) ) { return ; } $ this -> appendMessage ( sprintf ( ' Did you mean "%s"?' , implode ( '", "' , $ alternatives ) ) ) ; }
4995	public function getActiveFormNext ( ) { $ key = null ; $ actualKey = $ this -> getActiveFormActual ( ) ; if ( isset ( $ actualKey ) ) { $ forms = array_keys ( $ this -> forms ) ; $ formsFlip = array_flip ( $ forms ) ; $ index = $ formsFlip [ $ actualKey ] ; if ( $ index < count ( $ forms ) - 1 ) { $ key = $ forms [ $ index + 1 ] ; } } return $ key ; }
8644	public function getReportRequestCount ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestCountRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestCountRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestCount ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestCountResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
138	public function update ( RepositoryInterface $ repo , UpdateOperation $ operation ) { $ initial = $ operation -> getInitialPackage ( ) ; $ target = $ operation -> getTargetPackage ( ) ; $ initialType = $ initial -> getType ( ) ; $ targetType = $ target -> getType ( ) ; if ( $ initialType === $ targetType ) { $ installer = $ this -> getInstaller ( $ initialType ) ; $ installer -> update ( $ repo , $ initial , $ target ) ; $ this -> markForNotification ( $ target ) ; } else { $ this -> getInstaller ( $ initialType ) -> uninstall ( $ repo , $ initial ) ; $ this -> getInstaller ( $ targetType ) -> install ( $ repo , $ target ) ; } }
5090	public function execute ( $ path ) { if ( ! file_exists ( $ path ) || ! is_readable ( $ path ) ) throw new SquidException ( "The file at [$path] is unreadable or doesn't exists" ) ; $ data = file_get_contents ( $ path ) ; $ result = $ this -> connector -> bulk ( ) -> add ( $ data ) -> executeAll ( ) ; return ( bool ) $ result ; }
1766	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } $ response = $ event -> getResponse ( ) ; if ( 200 !== $ response -> getStatusCode ( ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ this -> storeBackendReferer ( $ request ) ; } else { $ this -> storeFrontendReferer ( $ request ) ; } }
6328	private function getColumnsSql ( ) { $ columnTypeMapper = new ColumnTypeMapper ( ) ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { if ( $ constraint instanceof PrimaryKey ) { $ primaryKey = $ constraint ; } } if ( ! isset ( $ primaryKey ) ) { $ primaryKey = new PrimaryKey ( ) ; $ primaryKey -> setTable ( $ this -> table ) ; $ this -> table -> addConstraint ( $ primaryKey ) ; } $ sql = '' ; if ( ! $ primaryKey -> isMulti ( ) && $ primaryKey -> isAutoCreateColumn ( ) ) { $ sql = sprintf ( '%s %s NOT NULL,' , $ primaryKey -> getColumns ( ) , $ primaryKey -> isAutoIncrement ( ) ? 'serial' : 'integer' ) ; } foreach ( $ this -> table -> getColumns ( ) as $ column ) { if ( $ column instanceof CustomColumn ) { $ columnType = $ column -> getType ( ) ; } else { $ columnType = $ columnTypeMapper -> getNative ( $ column -> getType ( ) ) ; } $ sql .= sprintf ( '%s %s%s %s %s,' , $ column -> getName ( ) , $ columnType , $ this -> getTypeConstraints ( $ column ) , $ column -> isNotNull ( ) ? 'NOT NULL' : '' , null === $ column -> getDefault ( ) ? '' : 'DEFAULT' . ' ' . $ this -> addQuotesIfNeeded ( $ column , $ column -> getDefault ( ) ) ) ; } return rtrim ( $ sql , ',' ) ; }
12663	static public function getMessage ( $ code = self :: CODE_INTERNAL_SERVER_ERROR ) { if ( isset ( self :: $ messages [ $ code ] ) ) { return self :: $ messages [ $ code ] ; } return self :: $ messages [ self :: CODE_INTERNAL_SERVER_ERROR ] ; }
10073	public function allDrawings ( Spreadsheet $ spreadsheet ) { $ aDrawings = [ ] ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ iterator = $ spreadsheet -> getSheet ( $ i ) -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { $ aDrawings [ ] = $ iterator -> current ( ) ; $ iterator -> next ( ) ; } } return $ aDrawings ; }
8820	public function getClientIP ( ) { $ ip = null ; $ client = $ this -> server ( 'HTTP_CLIENT_IP' ) ; $ forward = $ this -> server ( 'HTTP_X_FORWARDED_FOR' ) ; $ remote = $ this -> server ( 'REMOTE_ADDR' ) ; if ( filter_var ( $ client , FILTER_VALIDATE_IP ) ) { $ ip = $ client ; } elseif ( filter_var ( $ forward , FILTER_VALIDATE_IP ) ) { $ ip = $ forward ; } else { $ ip = $ remote ; } return $ ip ; }
3099	public function getItems ( RunnerServiceContext $ serviceContext ) { $ this -> getRunnerService ( ) -> assertQtiRunnerServiceContext ( $ serviceContext ) ; $ runnerService = $ this -> getRunnerService ( ) ; $ testMap = $ runnerService -> getTestMap ( $ serviceContext ) ; $ items = [ ] ; foreach ( $ this -> getItemIdentifiersFromTestMap ( $ testMap ) as $ itemIdentifier ) { $ itemRef = $ runnerService -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; $ items [ $ itemIdentifier ] = [ 'baseUrl' => $ runnerService -> getItemPublicUrl ( $ serviceContext , $ itemRef ) , 'itemData' => $ this -> getItemData ( $ serviceContext , $ itemRef ) , 'itemState' => $ runnerService -> getItemState ( $ serviceContext , $ itemIdentifier ) , 'itemIdentifier' => $ itemIdentifier , 'portableElements' => $ runnerService -> getItemPortableElements ( $ serviceContext , $ itemRef ) , ] ; } return $ items ; }
5028	public function decorateClassMetaData ( ClassMetadata $ c ) { $ parentClassName = $ c -> getName ( ) ; if ( isset ( $ this -> mappings [ $ parentClassName ] ) ) { $ c -> discriminatorMap = array ( ) ; $ c -> discriminatorMap [ strtolower ( Str :: classname ( $ parentClassName ) ) ] = $ parentClassName ; foreach ( $ this -> mappings [ $ parentClassName ] as $ className ) { $ bundlePrefix = Str :: infix ( $ this -> getBundleName ( $ className ) , '-' ) ; $ name = Str :: infix ( Str :: classname ( Str :: rstrip ( $ className , Str :: classname ( $ parentClassName ) ) ) , '-' ) ; $ combinedDiscriminator = sprintf ( '%s-%s' , $ bundlePrefix , $ name ) ; $ c -> discriminatorMap [ $ combinedDiscriminator ] = $ className ; $ c -> subClasses [ ] = $ className ; } $ c -> subClasses = array_unique ( $ c -> subClasses ) ; } }
9793	public function hasDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for data validation when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> dataValidationExists ( $ this -> getCoordinate ( ) ) ; }
6468	public function parseAcceptCharsetHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept-Charset' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept-Charset' , $ i ) ; $ charset = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptCharsetHeaderValue ( $ charset , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
12917	public function sumValor ( ) { $ tableGateway = new TableGateway ( $ this -> tableName , $ this -> dbAdapter ) ; $ sql = $ tableGateway -> getSql ( ) ; $ select = $ sql -> select ( ) -> columns ( array ( 'sum' => new Expression ( 'SUM(valor)' ) ) ) ; return $ tableGateway -> selectWith ( $ select ) -> current ( ) ; }
2302	public static function getDcaPickerWizard ( $ extras , $ table , $ field , $ inputName ) { $ context = 'link' ; $ extras = \ is_array ( $ extras ) ? $ extras : array ( ) ; $ providers = ( isset ( $ extras [ 'providers' ] ) && \ is_array ( $ extras [ 'providers' ] ) ) ? $ extras [ 'providers' ] : null ; if ( isset ( $ extras [ 'context' ] ) ) { $ context = $ extras [ 'context' ] ; unset ( $ extras [ 'context' ] ) ; } $ factory = System :: getContainer ( ) -> get ( 'contao.picker.builder' ) ; if ( ! $ factory -> supportsContext ( $ context , $ providers ) ) { return '' ; } return ' <a href="' . ampersand ( $ factory -> getUrl ( $ context , $ extras ) ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'pagepicker' ] ) . '" id="pp_' . $ inputName . '">' . Image :: getHtml ( ( \ is_array ( $ extras ) && isset ( $ extras [ 'icon' ] ) ? $ extras [ 'icon' ] : 'pickpage.svg' ) , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'pagepicker' ] ) . '</a> <script> $("pp_' . $ inputName . '").addEvent("click", function(e) { e.preventDefault(); Backend.openModalSelector({ "id": "tl_listing", "title": ' . json_encode ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ field ] [ 'label' ] [ 0 ] ) . ', "url": this.href + "&value=" + document.getElementById("ctrl_' . $ inputName . '").value, "callback": function(picker, value) { $("ctrl_' . $ inputName . '").value = value.join(","); }.bind(this) }); }); </script>' ; }
4269	public function dir_readdir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ readdir ( $ this -> handle ) ; self :: register ( ) ; return $ success ; }
5279	protected function generateWhere ( $ column , $ param1 = null , $ param2 = null , $ type = 'and' ) { if ( is_null ( $ param2 ) ) { $ param2 = $ param1 ; $ param1 = '=' ; } if ( is_array ( $ param2 ) ) { $ param2 = $ this -> esc_array ( array_unique ( $ param2 ) ) ; if ( in_array ( $ param1 , array ( 'between' , 'not between' ) ) ) { $ param2 = join ( ' and ' , $ param2 ) ; } else { $ param2 = '(' . join ( ', ' , $ param2 ) . ')' ; } } elseif ( is_scalar ( $ param2 ) ) { $ param2 = $ this -> esc_value ( $ param2 ) ; } return join ( ' ' , array ( $ type , $ column , $ param1 , $ param2 ) ) ; }
12876	private function setNamespace ( $ serviceName = null ) { if ( $ serviceName === null ) { $ this -> storage -> getOptions ( ) -> setNamespace ( $ this -> defaultNamespace ) ; } else { $ this -> storage -> getOptions ( ) -> setNamespace ( $ serviceName ) ; } }
11709	public function actionUpdate ( $ id ) { $ user = $ this -> findModel ( $ id ) ; $ user -> scenario = 'update' ; $ profile = $ this -> finder -> findProfileById ( $ id ) ; $ r = \ Yii :: $ app -> request ; $ this -> performAjaxValidation ( [ $ user , $ profile ] ) ; if ( $ user -> load ( $ r -> post ( ) ) && $ profile -> load ( $ r -> post ( ) ) && $ user -> save ( ) && $ profile -> save ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been updated' ) ) ; return $ this -> refresh ( ) ; } return $ this -> render ( 'update' , [ 'user' => $ user , 'profile' => $ profile , 'module' => $ this -> module , ] ) ; }
1971	public static function findMultipleByUuids ( $ arrUuids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || ! \ is_array ( $ arrUuids ) ) { return null ; } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { if ( Validator :: isStringUuid ( $ v ) ) { $ v = StringUtil :: uuidToBin ( $ v ) ; } $ arrUuids [ $ k ] = "UNHEX('" . bin2hex ( $ v ) . "')" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.uuid!=" . implode ( ", $t.uuid!=" , $ arrUuids ) ; } return static :: findBy ( array ( "$t.uuid IN(" . implode ( "," , $ arrUuids ) . ")" ) , null , $ arrOptions ) ; }
6029	public function addDeploymentFile ( $ item ) { if ( ! ( $ item instanceof DeploymentFile ) ) { if ( is_array ( $ item ) ) { try { $ item = new DeploymentFile ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate DeploymentFile. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "DeploymentFile"!' , E_USER_WARNING ) ; } } $ this -> deployedFiles [ ] = $ item ; return $ this ; }
9510	public function download ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DOWNLOAD ) ; return $ this -> logViewer -> download ( $ log -> date ) ; }
8121	public function ReviewContentForm ( HTTPRequest $ request ) { $ id = $ request -> param ( 'ID' ) ? : $ request -> postVar ( 'ID' ) ; return $ this -> getReviewContentForm ( $ id ) ; }
6030	public function setChildMedias ( array $ childMedias ) { $ this -> childMedias = [ ] ; foreach ( $ childMedias as $ item ) { $ this -> addself ( $ item ) ; } return $ this ; }
11133	protected function calculate ( ) { $ action = false ; $ actions = 0 ; if ( $ this -> delete ) { $ actions += 1 ; $ action = 'DELETE' ; } if ( ! empty ( $ this -> inserts ) ) { $ actions += 1 ; $ action = 'INSERT' ; } if ( ! empty ( $ this -> updates ) ) { $ actions += 1 ; $ action = 'UPDATE' ; } if ( ! empty ( $ this -> selects ) ) { $ actions += 1 ; $ action = 'SELECT' ; } if ( ! empty ( $ this -> create ) ) { $ actions += 1 ; $ action = 'CREATE' ; } if ( $ actions > 1 ) { throw new \ Exception ( "More than one query action specified! When using Cora's query builder class, only one type of query (select, update, delete, insert) can be done at a time." ) ; } else { $ calcMethod = 'calculate' . $ action ; $ this -> $ calcMethod ( ) ; } }
12303	protected function generateSiteMap ( ) { $ urls = array ( ) ; $ siteName = $ this -> configurationHandler -> siteName ( ) ; foreach ( $ this -> pagesCollectionParser -> pages ( ) as $ page ) { foreach ( $ page [ "seo" ] as $ seo ) { $ urls [ ] = array ( 'href' => $ siteName . '/' . $ seo [ "permalink" ] , 'frequency' => $ seo [ "sitemap_frequency" ] , 'priority' => $ seo [ "sitemap_priority" ] , ) ; } } return $ this -> twig -> render ( 'RedKiteCms/Resources/views/Sitemap/sitemap.html.twig' , array ( 'urls' => $ urls ) ) ; }
1184	protected function wrapValidator ( ) { $ resolver = new Resolver ( $ this -> factory ) ; $ this -> factory -> resolver ( $ resolver -> resolver ( $ this -> field ) ) ; $ this -> factory -> extend ( RemoteValidator :: EXTENSION_NAME , $ resolver -> validatorClosure ( ) ) ; }
7791	public function setClosingBalanceClass ( $ closingBalanceClass ) { if ( ! is_callable ( $ closingBalanceClass ) && ! class_exists ( $ closingBalanceClass ) ) { throw new \ InvalidArgumentException ( '$closingBalanceClass must be a valid classname or a PHP callable' ) ; } $ this -> closingBalanceClass = $ closingBalanceClass ; return $ this ; }
3512	public function getInsertTranslationsElement ( $ translation , $ timeStamp ) { return '(' . self :: dbValue ( $ translation -> status , Translation :: STATUS_SAVED ) . ',' . self :: dbValue ( $ translation -> locale ) . ',' . self :: dbValue ( $ translation -> group ) . ',' . self :: dbValue ( $ translation -> key ) . ',' . self :: dbValue ( $ translation -> value ) . ',' . self :: dbValue ( $ translation -> created_at , $ timeStamp ) . ',' . self :: dbValue ( $ translation -> updated_at , $ timeStamp ) . ',' . self :: dbValue ( $ translation -> source ) . ',' . self :: dbValue ( $ translation -> saved_value ) . ',' . self :: dbValue ( $ translation -> is_deleted , 0 ) . ',' . self :: dbValue ( $ translation -> was_used , 0 ) . ')' ; }
1580	public function withId ( ? string $ id ) : self { $ copy = clone $ this ; $ copy -> id = $ id ? : null ; $ copy -> normalize ( ) ; return $ copy ; }
11550	private function preencherLista ( $ pagamentos ) { $ resultado = array ( ) ; foreach ( $ pagamentos as $ pagamento ) { $ resultado [ ] = $ pagamento -> setAutenticacao ( $ this -> getAutenticacaoManager ( ) -> obterAutenticacaoBasica ( $ pagamento -> getAutenticacaoId ( ) ) ) ; } return $ resultado ; }
7749	public function getAllMetadata ( ) { $ metadata = array ( ) ; foreach ( $ this -> driver -> getAllClassNames ( ) as $ className ) { $ metadata [ ] = $ this -> getMetadataFor ( $ className ) ; } $ this -> validate ( $ metadata ) ; return $ metadata ; }
8055	public static function get ( $ length = 8 , $ outputFormat = Code :: FORMAT_ALNUM ) { static :: throwUnlessAcceptable ( $ outputFormat , $ length ) ; $ number = rand ( 100 , 900 ) . str_replace ( '.' , '' , microtime ( true ) ) ; $ output = self :: convertBase ( $ number , self :: FORMAT_NUMBER , $ outputFormat ) ; if ( strlen ( $ output ) < $ length ) { $ output .= substr ( str_shuffle ( $ outputFormat . $ outputFormat ) , 0 , ( $ length - strlen ( $ output ) ) ) ; } if ( strlen ( $ output ) > $ length ) { $ output = substr ( $ output , 0 , $ length ) ; } return $ output ; }
8708	public function select ( $ columns = [ '*' ] ) { parent :: select ( $ columns ) ; $ this -> columns = $ this -> qualifyColumns ( $ this -> columns ) ; return $ this ; }
2097	public static function getRegexp ( $ strFormat = null ) { if ( $ strFormat === null ) { $ strFormat = static :: getNumericDateFormat ( ) ; } if ( ! static :: isNumericFormat ( $ strFormat ) ) { throw new \ Exception ( sprintf ( 'Invalid date format "%s"' , $ strFormat ) ) ; } return preg_replace_callback ( '/[a-zA-Z]/' , function ( $ matches ) { $ arrRegexp = array ( 'a' => '(?P<a>am|pm)' , 'A' => '(?P<A>AM|PM)' , 'd' => '(?P<d>0[1-9]|[12][0-9]|3[01])' , 'g' => '(?P<g>[1-9]|1[0-2])' , 'G' => '(?P<G>[0-9]|1[0-9]|2[0-3])' , 'h' => '(?P<h>0[1-9]|1[0-2])' , 'H' => '(?P<H>[01][0-9]|2[0-3])' , 'i' => '(?P<i>[0-5][0-9])' , 'j' => '(?P<j>[1-9]|[12][0-9]|3[01])' , 'm' => '(?P<m>0[1-9]|1[0-2])' , 'n' => '(?P<n>[1-9]|1[0-2])' , 's' => '(?P<s>[0-5][0-9])' , 'Y' => '(?P<Y>[0-9]{4})' , 'y' => '(?P<y>[0-9]{2})' , ) ; return $ arrRegexp [ $ matches [ 0 ] ] ?? $ matches [ 0 ] ; } , preg_quote ( $ strFormat ) ) ; }
2616	private function prepareCustomVariables ( ) { if ( $ this -> validationServiceId != null ) { $ serviceId = $ this -> validationServiceId ; } else { $ serviceId = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_SERVICE_ID ) ; } $ customVars = [ 'cd1' => $ serviceId , 'cd2' => ( $ this -> isApiKeyValid ( ) ) ? 'yes' : 'no' , 'cd3' => $ this -> getWebsiteName ( ) , 'cd4' => $ this -> request -> getServer ( 'HTTP_HOST' ) , 'cd5' => $ this -> getSiteLocation ( ) , 'cd6' => $ this -> helper -> getModuleVersion ( ) , 'cd7' => $ this -> config -> getCID ( ) , 'cd8' => 'fastlyext' ] ; return $ customVars ; }
3694	public function getBreadcrumb ( GetBreadcrumbEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ elements = $ this -> storeFactory -> createStore ( ) ; $ this -> getBreadcrumbElements ( $ environment , $ elements ) ; $ event -> setElements ( $ elements -> getElements ( ) ) ; $ event -> stopPropagation ( ) ; }
3209	function createOAuth2AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/oauth2/token_from_oauth1" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ parts = RequestUtil :: parseResponseJson ( $ response -> body ) ; if ( ! array_key_exists ( 'token_type' , $ parts ) || ! is_string ( $ parts [ 'token_type' ] ) ) { throw new Exception_BadResponse ( "Missing \"token_type\" field." ) ; } $ tokenType = $ parts [ 'token_type' ] ; if ( ! array_key_exists ( 'access_token' , $ parts ) || ! is_string ( $ parts [ 'access_token' ] ) ) { throw new Exception_BadResponse ( "Missing \"access_token\" field." ) ; } $ accessToken = $ parts [ 'access_token' ] ; if ( $ tokenType !== "Bearer" && $ tokenType !== "bearer" ) { throw new Exception_BadResponse ( "Unknown \"token_type\"; expecting \"Bearer\", got " . Util :: q ( $ tokenType ) ) ; } return $ accessToken ; }
5036	public function indexAction ( ) { $ events = $ this -> adminControllerEvents ; $ event = $ events -> getEvent ( AdminControllerEvent :: EVENT_DASHBOARD , $ this ) ; $ events -> trigger ( $ event , $ this ) ; $ model = new ViewModel ( ) ; $ widgets = [ ] ; foreach ( $ event -> getViewModels ( ) as $ name => $ child ) { $ model -> addChild ( $ child , $ name ) ; $ widgets [ ] = $ name ; } $ model -> setVariable ( 'widgets' , $ widgets ) ; return $ model ; }
1911	protected function getType ( ) : string { if ( isset ( $ this -> options [ 'type' ] ) ) { return $ this -> options [ 'type' ] ; } $ className = ltrim ( strrchr ( static :: class , '\\' ) , '\\' ) ; if ( 'Controller' === substr ( $ className , - 10 ) ) { $ className = substr ( $ className , 0 , - 10 ) ; } return Container :: underscore ( $ className ) ; }
4044	private function removeInvariantAttributes ( IItem $ nativeItem , ICollection $ renderSetting ) { $ model = $ nativeItem -> getMetaModel ( ) ; if ( $ model -> hasVariants ( ) && ! $ nativeItem -> isVariantBase ( ) ) { $ renderSetting = clone $ renderSetting ; foreach ( array_keys ( $ model -> getInVariantAttributes ( ) ) as $ strAttrName ) { $ renderSetting -> setSetting ( $ strAttrName , null ) ; } } return $ renderSetting ; }
2601	public function getLiteral ( $ token ) { $ className = get_class ( $ this ) ; $ reflClass = new \ ReflectionClass ( $ className ) ; $ constants = $ reflClass -> getConstants ( ) ; foreach ( $ constants as $ name => $ value ) { if ( $ value === $ token ) { return $ className . '::' . $ name ; } } return $ token ; }
7010	private function formatN ( & $ str ) { if ( strstr ( $ str , '%N' ) ) { $ wdn = $ this -> weekDayNum ( ) ; $ str = str_replace ( '%N' , $ wdn == 0 ? 7 : $ wdn , $ str ) ; } }
1890	public function grantsAccess ( ) : bool { $ content = array_filter ( file ( ( string ) $ this -> file ) ) ; foreach ( $ content as $ line ) { if ( $ this -> hasRequireGranted ( $ line ) ) { return true ; } } return false ; }
11059	public static function files ( $ path , array $ extensions = array ( ) ) { $ files = array ( ) ; $ it = new \ RecursiveDirectoryIterator ( $ path ) ; $ filter = false ; if ( ! empty ( $ extensions ) && is_array ( $ extensions ) ) { $ filter = true ; } foreach ( new \ RecursiveIteratorIterator ( $ it ) as $ file ) { if ( $ filter ) { $ f = explode ( '.' , $ file ) ; $ ext = strtolower ( array_pop ( $ f ) ) ; if ( in_array ( $ ext , $ extensions ) ) { $ files [ ] = $ file ; } } else { $ files [ ] = $ file ; } } return $ files ; }
12212	public function getSnippet ( string $ snptName = '' ) { if ( empty ( $ snptName ) ) { return $ this -> snippets ; } else { return isset ( $ this -> snippets [ $ snptName ] ) ? $ this -> snippets [ $ snptName ] : null ; } }
5515	public function expectAtLeastOnce ( $ method , $ args = false , $ message = '%s' ) { $ this -> expectMinimumCallCount ( $ method , 1 , $ message ) ; if ( $ args !== false ) { $ this -> expect ( $ method , $ args , $ message ) ; } }
1179	protected function getValidationData ( array $ rules , array $ customAttributes = [ ] ) { $ attributes = array_filter ( array_keys ( $ rules ) , function ( $ attribute ) { return $ attribute !== '' && mb_strpos ( $ attribute , '*' ) !== false ; } ) ; $ attributes = array_merge ( array_keys ( $ customAttributes ) , $ attributes ) ; $ data = array_reduce ( $ attributes , function ( $ data , $ attribute ) { Arr :: set ( $ data , $ attribute , true ) ; return $ data ; } , [ ] ) ; return $ data ; }
10611	public function confirmAction ( $ token ) { $ user = $ this -> get ( 'fos_user.user_manager' ) -> findUserByConfirmationToken ( $ token ) ; if ( null === $ user ) { throw new NotFoundHttpException ( sprintf ( 'The user with confirmation token "%s" does not exist' , $ token ) ) ; } $ user -> setConfirmationToken ( null ) ; $ user -> setEnabled ( true ) ; $ user -> setLastLogin ( new \ DateTime ( ) ) ; $ this -> get ( 'fos_user.user_manager' ) -> updateUser ( $ user ) ; $ response = $ this -> redirect ( $ this -> generateUrl ( 'miky_app_customer_registration_confirmed' ) ) ; $ this -> authenticateUser ( $ user , $ response ) ; return $ response ; }
5882	protected static function read_1_byte ( $ handle ) { $ c = fgetc ( $ handle ) ; if ( $ c === false ) { throw new \ RuntimeException ( 'Premature EOF in JPEG file' , 1363533326 ) ; } return ord ( $ c ) ; }
6581	public function translate ( $ shift , $ y = null , $ z = null ) { if ( $ shift instanceof self ) return new static ( $ this -> gps [ 'x' ] + $ shift -> gps [ 'x' ] , $ this -> gps [ 'y' ] + $ shift -> gps [ 'y' ] , $ this -> gps [ 'z' ] + $ shift -> gps [ 'z' ] ) ; else return new static ( $ this -> gps [ 'x' ] + $ shift , $ this -> gps [ 'y' ] + $ y , $ this -> gps [ 'z' ] + $ z ) ; }
8542	public function setPluralForm ( $ key , $ plural ) { if ( ! is_array ( $ plural ) ) $ plural = [ $ plural ] ; if ( ! $ this -> msgstr_plural ) $ this -> msgstr_plural = [ ] ; $ this -> msgstr_plural [ $ key ] = $ plural ; }
7325	protected function cachingIsPossible ( ) { if ( static :: $ _cachingIsPossible === null ) { $ storeClass = '\AlternativeLaravelCache\Core\AlternativeCacheStore' ; $ poolInterface = '\Cache\Taggable\TaggablePoolInterface' ; $ cache = app ( 'cache.store' ) -> getStore ( ) ; static :: $ _cachingIsPossible = ( $ cache instanceof $ storeClass && $ cache -> getWrappedConnection ( ) instanceof $ poolInterface ) ; } return static :: $ _cachingIsPossible ; }
3965	protected function authenticateUser ( ) { if ( \ System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) -> currentScopeIsUnknown ( ) ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'contao/login' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'request' ) , 'install' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'system/bin' ) !== false ) { return false ; } $ authResult = $ this -> getUser ( ) -> authenticate ( ) ; return ( $ authResult === true || $ authResult === null ) ? true : false ; }
6563	public function carrier_data ( $ carrier = '' , $ field_output = '' ) { $ inputParams = array ( 'carrier' => $ carrier , 'field_output' => $ field_output ) ; $ field_output = strtolower ( $ field_output ) ; $ this -> debug -> info ( __FUNCTION__ , 'Input Params: ' , $ inputParams ) ; try { $ vnCarrierData = DataRepository :: getData ( 'vn_carrier_data' ) ; $ this -> debug -> debug ( __FUNCTION__ , 'VN Carrier All Data: ' , $ vnCarrierData ) ; if ( array_key_exists ( $ carrier , $ vnCarrierData ) ) { $ isCarrier = $ vnCarrierData [ $ carrier ] ; $ this -> debug -> debug ( __FUNCTION__ , 'Is Carrier Data: ' , $ isCarrier ) ; if ( array_key_exists ( $ field_output , $ isCarrier ) ) { $ result = $ isCarrier [ $ field_output ] ; $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ result ) ; return $ result ; } if ( $ field_output = 'full' ) { $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ isCarrier ) ; return $ isCarrier ; } } } catch ( \ Exception $ e ) { $ message = 'Error File: ' . $ e -> getFile ( ) . ' - Line: ' . $ e -> getLine ( ) . ' - Code: ' . $ e -> getCode ( ) . ' - Message: ' . $ e -> getMessage ( ) ; $ this -> debug -> error ( __FUNCTION__ , $ message ) ; return NULL ; } return NULL ; }
10834	public function using ( $ column ) { if ( $ this -> active_join === null ) { throw new \ Peyote \ Exception ( "You need to start a join before calling \Peyote\Join::using()" ) ; } list ( $ table , $ type ) = $ this -> active_join ; $ this -> active_join = null ; $ this -> joins [ ] = array ( "USING" , $ table , $ type , $ column ) ; return $ this ; }
12439	public function render ( $ template , $ data ) { $ tplReady = '' ; $ this -> template = $ template ; $ this -> data = $ data ; if ( $ this -> loadTemplate ( ) ) { $ tplReady = $ this -> dataRender ; } if ( Settings :: getInstance ( ) -> get ( 'minifyTemplate' ) && ! Settings :: getInstance ( ) -> inDebug ( ) ) { $ tplReady = $ this -> minify ( $ tplReady ) ; } $ this -> release ( ) ; return $ tplReady ; }
5142	public function process ( ServerRequestInterface $ request ) : ResponseInterface { $ filteredMiddleware = $ this -> middleware ; try { $ request = $ this -> router -> dispatch ( $ request ) ; $ route = $ request -> getAttribute ( 'route' ) ; $ filteredMiddleware = array_filter ( $ filteredMiddleware , function ( Middleware $ middleware ) use ( $ route ) { return $ middleware -> executeFor ( $ route ) ; } ) ; $ requestHandler = $ route -> getHandler ( ) ; } catch ( HttpException $ e ) { $ requestHandler = new NextHandler ( function ( ) use ( $ e ) { throw $ e ; } ) ; } $ filteredMiddleware = array_map ( function ( Middleware $ middleware ) { return $ middleware -> getMiddleware ( ) ; } , $ filteredMiddleware ) ; $ dispatcher = new Stack ( $ filteredMiddleware , $ requestHandler ) ; return $ dispatcher -> dispatch ( $ request ) ; }
10158	private function readMulBlank ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ fc = self :: getUInt2d ( $ recordData , 2 ) ; if ( ! $ this -> readDataOnly && $ this -> readEmptyCells ) { for ( $ i = 0 ; $ i < $ length / 2 - 3 ; ++ $ i ) { $ columnString = Coordinate :: stringFromColumnIndex ( $ fc + $ i + 1 ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , 4 + 2 * $ i ) ; $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } } } }
1011	private function readNumber ( $ line , $ col , Token $ prev ) { $ value = '' ; $ start = $ this -> position ; [ $ char , $ code ] = $ this -> readChar ( ) ; $ isFloat = false ; if ( $ code === 45 ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } if ( $ code === 48 ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; if ( $ code >= 48 && $ code <= 57 ) { throw new SyntaxError ( $ this -> source , $ this -> position , 'Invalid number, unexpected digit after 0: ' . Utils :: printCharCode ( $ code ) ) ; } } else { $ value .= $ this -> readDigits ( ) ; [ $ char , $ code ] = $ this -> readChar ( ) ; } if ( $ code === 46 ) { $ isFloat = true ; $ this -> moveStringCursor ( 1 , 1 ) ; $ value .= $ char ; $ value .= $ this -> readDigits ( ) ; [ $ char , $ code ] = $ this -> readChar ( ) ; } if ( $ code === 69 || $ code === 101 ) { $ isFloat = true ; $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; if ( $ code === 43 || $ code === 45 ) { $ value .= $ char ; $ this -> moveStringCursor ( 1 , 1 ) ; } $ value .= $ this -> readDigits ( ) ; } return new Token ( $ isFloat ? Token :: FLOAT : Token :: INT , $ start , $ this -> position , $ line , $ col , $ prev , $ value ) ; }
2018	private function setImagineService ( array $ config , ContainerBuilder $ container ) : void { $ imagineServiceId = $ config [ 'image' ] [ 'imagine_service' ] ; if ( null === $ imagineServiceId ) { $ class = $ this -> getImagineImplementation ( ) ; $ imagineServiceId = 'contao.image.imagine.' . ContainerBuilder :: hash ( $ class ) ; $ container -> setDefinition ( $ imagineServiceId , new Definition ( $ class ) ) ; } $ container -> setAlias ( 'contao.image.imagine' , $ imagineServiceId ) -> setPublic ( true ) ; }
4116	public function getBlockPath ( Mage_Core_Block_Abstract $ block ) { $ blockPath = array ( ) ; $ step = $ block -> getParentBlock ( ) ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { $ blockPath [ ] = $ this -> getBlockInfo ( $ step , false ) ; $ step = $ step -> getParentBlock ( ) ; } return $ blockPath ; }
3489	private function createTemporaryFile ( ) : string { $ tmpDir = $ this -> tmpDir ; $ tmpFileName = md5 ( uniqid ( ( string ) mt_rand ( ) , true ) ) . '.p8' ; $ tmpFilePath = $ tmpDir . '/' . $ tmpFileName ; $ errorCode = $ errorMessage = null ; set_error_handler ( function ( $ errCode , $ errMessage ) use ( & $ errorCode , & $ errorMessage ) { $ errorCode = $ errCode ; $ errorMessage = $ errMessage ; } ) ; if ( ! file_exists ( $ tmpDir ) ) { mkdir ( $ tmpDir , 0600 , true ) ; if ( $ errorCode || $ errorMessage ) { restore_error_handler ( ) ; throw new \ RuntimeException ( sprintf ( 'Can not create temporary directory "%s". Error: %s [%d].' , $ tmpDir , $ errorMessage ? : 'Undefined' , $ errorCode ? : '0' ) ) ; } } touch ( $ tmpFilePath ) ; if ( $ errorCode || $ errorMessage ) { restore_error_handler ( ) ; throw new \ RuntimeException ( sprintf ( 'Can not create temporary certificate file "%s". Error: %s [%d].' , $ tmpFilePath , $ errorMessage ? : 'Undefined' , $ errorCode ? : '0' ) ) ; } restore_error_handler ( ) ; return $ tmpFilePath ; }
11092	public static function poorManTranslate ( $ category , $ text , array $ params = [ ] ) { if ( class_exists ( 'Yii' ) ) { return \ Yii :: t ( $ category , $ text , $ params ) ; } $ pos = strrpos ( $ category , '/' ) ; $ category = $ pos === false ? $ category : substr ( $ category , $ pos + 1 ) ; $ translation = @ include 'messages/cs/' . $ category . '.php' ; if ( $ translation !== null && \ is_array ( $ translation ) && array_key_exists ( $ text , $ translation ) ) { $ keys = array_keys ( $ params ) ; array_walk ( $ keys , function ( & $ v ) { $ v = '{' . $ v . '}' ; } ) ; return str_replace ( array_values ( $ params ) , $ keys , $ translation [ $ text ] ) ; } return $ text ; }
2026	public static function findPublishedSubpagesWithoutGuestsByPid ( $ intPid , $ blnShowHidden = false , $ blnIsSitemap = false ) { $ time = Date :: floorToMinute ( ) ; $ objSubpages = Database :: getInstance ( ) -> prepare ( "SELECT p1.*, (SELECT COUNT(*) FROM tl_page p2 WHERE p2.pid=p1.id AND p2.type!='root' AND p2.type!='error_401' AND p2.type!='error_403' AND p2.type!='error_404'" . ( ! $ blnShowHidden ? ( $ blnIsSitemap ? " AND (p2.hide='' OR sitemap='map_always')" : " AND p2.hide=''" ) : "" ) . ( FE_USER_LOGGED_IN ? " AND p2.guests=''" : "" ) . ( ! BE_USER_LOGGED_IN ? " AND (p2.start='' OR p2.start<='$time') AND (p2.stop='' OR p2.stop>'" . ( $ time + 60 ) . "') AND p2.published='1'" : "" ) . ") AS subpages FROM tl_page p1 WHERE p1.pid=? AND p1.type!='root' AND p1.type!='error_401' AND p1.type!='error_403' AND p1.type!='error_404'" . ( ! $ blnShowHidden ? ( $ blnIsSitemap ? " AND (p1.hide='' OR sitemap='map_always')" : " AND p1.hide=''" ) : "" ) . ( FE_USER_LOGGED_IN ? " AND p1.guests=''" : "" ) . ( ! BE_USER_LOGGED_IN ? " AND (p1.start='' OR p1.start<='$time') AND (p1.stop='' OR p1.stop>'" . ( $ time + 60 ) . "') AND p1.published='1'" : "" ) . " ORDER BY p1.sorting" ) -> execute ( $ intPid ) ; if ( $ objSubpages -> numRows < 1 ) { return null ; } return static :: createCollectionFromDbResult ( $ objSubpages , 'tl_page' ) ; }
1511	public function getRelationshipUri ( string $ type , $ id , string $ field , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id , 'relationships' , $ field ] , $ params ) ; }
10742	public function get ( $ keys , $ default = null ) { $ result = $ this -> data ; foreach ( is_array ( $ keys ) ? $ keys : [ $ keys ] as $ key ) { if ( is_array ( $ result ) && isset ( $ result [ $ key ] ) ) { $ result = $ result [ $ key ] ; } else { $ result = $ default ; break ; } } return $ result ; }
12645	public function render ( ElementInterface $ element ) { $ label = $ element -> getLabel ( ) ; if ( isset ( $ label ) && '' !== $ label ) { if ( null !== ( $ translator = $ this -> getTranslator ( ) ) ) { $ label = $ translator -> translate ( $ label , $ this -> getTranslatorTextDomain ( ) ) ; $ element -> setLabel ( $ label ) ; } } return parent :: render ( $ element ) ; }
7045	private function getColumnNamesFromTable ( $ tableName , $ typeFilter = null ) { if ( ! $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ tableName ] ) ) { return [ ] ; } $ result = [ ] ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ tableName ) as $ column ) { if ( ( $ typeFilter === null ) || \ in_array ( $ column -> getType ( ) -> getName ( ) , $ typeFilter , true ) ) { $ result [ $ column -> getName ( ) ] = $ column -> getName ( ) ; } } if ( ! empty ( $ result ) ) { \ asort ( $ result ) ; return $ result ; } return $ result ; }
2551	protected function loadRequestCreator ( $ requestCreator , $ params , $ libIdentifier , $ originatorOffice , $ mesVer ) { if ( $ requestCreator instanceof RequestCreatorInterface ) { $ newRequestCreator = $ requestCreator ; } else { $ params -> originatorOfficeId = $ originatorOffice ; $ params -> messagesAndVersions = $ mesVer ; $ newRequestCreator = RequestCreatorFactory :: createRequestCreator ( $ params , $ libIdentifier ) ; } return $ newRequestCreator ; }
6175	public function rightJoin ( $ table , $ column , $ operator = null , $ value = null ) { if ( $ column instanceof \ Closure ) { $ where = new Where ( ) ; call_user_func_array ( $ column , [ & $ where ] ) ; } else { $ where = ( new Where ( ) ) -> where ( $ column , $ operator , $ value ) ; } $ this -> request [ 'rightJoin' ] [ $ table ] [ 'table' ] = $ table ; $ this -> request [ 'rightJoin' ] [ $ table ] [ 'where' ] = $ where ; return $ this ; }
6182	public static function redirect ( $ url = '' , $ status = 301 , $ headers = [ ] ) { $ Response = new Response ( ) ; $ Response -> status ( $ status ) ; if ( ! empty ( $ headers ) ) { $ Response -> headers ( $ headers ) ; } $ Response -> headers ( [ 'Location' => ( new Router ( ) ) -> makeUrl ( $ url ) , ] ) ; return $ Response ; }
11717	public static function load ( string $ dir ) : void { self :: initialize ( ) ; $ commandDir = $ _SERVER [ 'DOCUMENT_ROOT' ] . $ dir ; $ files = scandir ( $ commandDir ) ; foreach ( $ files as $ file ) { if ( $ file == '.' || $ file == '..' ) { continue ; } require_once $ _SERVER [ 'DOCUMENT_ROOT' ] . $ dir . '/' . $ file ; } }
7977	public function deleteSecondaryDnsDomains ( $ domain2delete ) { json_decode ( self :: getClient ( ) -> deleteSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2delete ) ) ; return true ; }
10017	public function addNamedRange ( NamedRange $ namedRange ) { if ( $ namedRange -> getScope ( ) == null ) { $ this -> namedRanges [ $ namedRange -> getName ( ) ] = $ namedRange ; } else { $ this -> namedRanges [ $ namedRange -> getScope ( ) -> getTitle ( ) . '!' . $ namedRange -> getName ( ) ] = $ namedRange ; } return true ; }
10318	function getBlocks ( $ fromDate = null , $ toDate = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ reasons = null , $ oldStatus = null , $ newStatus = null , $ excludeAnonymousBlocks = false , $ standardFields = null , $ customFields = null , $ pageIndex = 1 , $ pageSize = 100 ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , null , null , null ) ; $ params = $ this -> appendArrayFields ( $ params , "standard_field" , $ standardFields ) ; $ params = $ this -> appendArrayFields ( $ params , "custom_field" , $ customFields ) ; if ( isset ( $ embedEmailClientInfos ) ) $ params [ 'embed_email_client_infos' ] = ( $ embedEmailClientInfos == true ) ? "true" : "false" ; if ( isset ( $ excludeAnonymousBlocks ) ) $ params [ 'exclude_anonymous_blocks' ] = ( $ excludeAnonymousBlocks == true ) ? "true" : "false" ; $ params = $ this -> appendArrayFields ( $ params , "reasons" , $ reasons ) ; if ( isset ( $ oldStatus ) ) $ params [ 'old_status' ] = $ oldStatus ; if ( isset ( $ newStatus ) ) $ params [ 'new_status' ] = $ newStatus ; return $ this -> get ( 'reports/blocks' , $ params ) ; }
9193	public function init ( ) { if ( $ this -> isInitialized ( ) ) return $ this ; if ( ! $ this -> getThemesPath ( ) || ! $ this -> getName ( ) ) throw new \ Exception ( 'Theme Cant initialize because theme name or theme paths not present.' ) ; $ themePathname = $ this -> getThemesPath ( ) . DS . $ this -> getName ( ) ; if ( ! is_dir ( $ themePathname ) ) throw new \ Exception ( sprintf ( 'Theme "%s" not found in "%s".' , $ this -> getName ( ) , $ themePathname ) ) ; $ bootstrap = $ themePathname . DS . 'theme.bootstrap.php' ; if ( file_exists ( $ bootstrap ) ) { ob_start ( ) ; set_error_handler ( function ( $ errno , $ errstr ) { throw new \ ErrorException ( $ errstr , $ errno ) ; } , E_ALL ) ; include $ bootstrap ; restore_error_handler ( ) ; ob_get_clean ( ) ; } $ this -> initialized = true ; return $ this ; }
6582	public static function getSession ( ServerRequestInterface $ request ) : SessionDataHolder { $ session = $ request -> getAttribute ( static :: REQ_ATTR ) ; if ( ! $ session instanceof SessionDataHolder ) { throw new SessionMiddlewareException ( "No session object is available in the request attributes" ) ; } return $ session ; }
4495	private function getAdmJson ( ) : string { $ adm = [ 'data' => $ this -> getTrimmedJson ( [ $ this , 'getAdmJsonInner' ] , static :: ADM_MAX_LENGTH , 'You message for ADM is too long' ) , 'expiresAfter' => $ this -> ttl , ] ; foreach ( $ adm [ 'data' ] as $ key => $ value ) { if ( ! \ is_string ( $ value ) ) { $ adm [ 'data' ] [ "{$key}_json" ] = json_encode ( $ value ) ; unset ( $ adm [ 'data' ] [ $ key ] ) ; } } if ( $ this -> collapseKey != static :: NO_COLLAPSE ) { $ adm [ 'consolidationKey' ] = $ this -> collapseKey ; } return json_encode ( $ adm , JSON_UNESCAPED_UNICODE ) ; }
5600	public static function getSeverityAsString ( $ severity ) { static $ map = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_WARNING => 'E_USER_WARNING' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , E_DEPRECATED => 'E_DEPRECATED' , E_USER_DEPRECATED => 'E_USER_DEPRECATED' , E_ALL => 'E_ALL' ) ; return $ map [ $ severity ] ; }
3291	public function signal ( int $ signo ) { if ( ! $ this -> isRunning ( ) ) { throw new StatusError ( "Process is not running." ) ; } $ this -> processRunner -> signal ( $ this -> handle , $ signo ) ; }
5902	public function retrieveGroup ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/groups/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Group ( $ result ) ; return $ result ; }
6760	static public function buildCacheKey ( $ columns = '*' , array $ conditionsAndOptions = [ ] ) { foreach ( $ conditionsAndOptions as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$conditionsAndOptions argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; if ( is_array ( $ columns ) ) { foreach ( $ columns as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$columns argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; } else if ( $ columns instanceof DbExpr ) { $ columns = $ columns -> get ( ) ; } return hash ( 'sha256' , json_encode ( array ( $ columns , $ conditionsAndOptions ) ) ) ; }
8580	public function setPromotionAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PromotionAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11157	public function handleUrl ( $ url , Event $ event , Queue $ queue ) { $ logger = $ this -> getLogger ( ) ; $ logger -> info ( 'handleUrl' , array ( 'url' => $ url ) ) ; $ v = $ this -> getVideoId ( $ url ) ; $ logger -> info ( 'getVideoId' , array ( 'url' => $ url , 'v' => $ v ) ) ; if ( ! $ v ) { return ; } $ apiUrl = $ this -> getApiUrl ( $ v ) ; $ request = $ this -> getApiRequest ( $ apiUrl , $ event , $ queue ) ; $ this -> getEventEmitter ( ) -> emit ( 'http.request' , array ( $ request ) ) ; }
5186	private function makeAttachmentObject ( string $ attachmentType , array $ attrReferences , array $ item ) { $ attrValues = [ ] ; foreach ( $ attrReferences as $ attrReference ) { $ attrValues [ $ attrReference ] = $ this -> getValue ( $ attrReference , $ item ) ; } switch ( $ attachmentType ) { case self :: JSON_PHOTO_FIELD : return $ this -> createPhoto ( $ attrValues [ 'photo_url' ] , $ attrValues [ 'photo_ratio' ] , '' , '' ) ; case self :: JSON_PAGE_FIELD : return $ this -> createPage ( $ attrValues [ 'page_title' ] , $ attrValues [ 'page_body' ] , $ attrValues [ 'page_source' ] , $ attrValues [ 'page_order' ] , $ attrValues [ 'page_cover' ] , $ attrValues [ 'page_lead' ] ) ; case self :: JSON_GALLERY_FIELD : return $ this -> createGallery ( $ attrValues [ 'gallery_body' ] , $ attrValues [ 'gallery_order' ] , $ attrValues [ 'gallery_photo' ] , $ attrValues [ 'gallery_source' ] , $ attrValues [ 'gallery_lead' ] ) ; case self :: JSON_VIDEO_FIELD : return $ this -> createVideo ( $ attrValues [ 'video_body' ] , $ attrValues [ 'video_source' ] , $ attrValues [ 'video_order' ] , $ attrValues [ 'video_cover' ] , $ attrValues [ 'video_lead' ] ) ; default : return null ; } }
6782	public function setFormParameters ( $ optionNames ) { foreach ( ( array ) $ optionNames as $ option ) { $ this -> formParameters [ $ option ] = true ; } return $ this ; }
10540	protected function typeModification ( $ type , array $ args ) { if ( is_int ( $ args [ 1 ] ) ) { $ type .= '(' . $ args [ 1 ] ; if ( isset ( $ args [ 2 ] ) ) { $ type .= ',' . $ args [ 2 ] ; } $ type .= ')' ; } elseif ( is_array ( $ args [ 1 ] ) ) { if ( isset ( $ args [ 1 ] [ 'size' ] ) ) { $ type .= '(' . $ args [ 1 ] [ 'size' ] . ')' ; } foreach ( $ args [ 1 ] as $ key => $ val ) { if ( 'size' === $ key ) { continue ; } $ type .= ' ' . strtoupper ( $ key ) ; } } else { $ type .= $ args [ 1 ] ; } return $ type ; }
2761	public function getLogLevelMapping ( string $ eventName ) : string { if ( ! isset ( $ this -> logLevelMappings [ $ eventName ] ) ) { throw new GitException ( sprintf ( 'Unknown event "%s"' , $ eventName ) ) ; } return $ this -> logLevelMappings [ $ eventName ] ; }
277	public function notifyNothingToUnload ( $ foundFixtures , $ except ) { $ this -> stdout ( "Fixtures to unload could not be found according to given conditions:\n\n" , Console :: FG_RED ) ; $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n" , Console :: FG_GREEN ) ; if ( count ( $ foundFixtures ) ) { $ this -> stdout ( "\nFixtures found under the namespace:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ foundFixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be unloaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } }
1812	public function getForms ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> forms ) ) { return array ( ) ; } $ arrForms = array ( ) ; $ objForms = $ this -> Database -> execute ( "SELECT id, title FROM tl_form ORDER BY title" ) ; while ( $ objForms -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objForms -> id , 'forms' ) ) { $ arrForms [ $ objForms -> id ] = $ objForms -> title . ' (ID ' . $ objForms -> id . ')' ; } } return $ arrForms ; }
5952	public function setTransition ( $ transition ) { if ( $ transition instanceof SlideTransition ) { $ this -> transition = $ transition ; } elseif ( is_array ( $ transition ) ) { $ this -> transition = new SlideTransition ( $ transition ) ; } else { $ this -> transition = null ; trigger_error ( 'Argument must be an object of class SlideTransition. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
2267	public function getFieldNames ( $ strTable , $ blnNoCache = false ) { $ arrNames = array ( ) ; $ arrFields = $ this -> listFields ( $ strTable , $ blnNoCache ) ; foreach ( $ arrFields as $ arrField ) { if ( $ arrField [ 'type' ] != 'index' ) { $ arrNames [ ] = $ arrField [ 'name' ] ; } } return $ arrNames ; }
760	public function getIsCollection ( ) { return in_array ( $ this -> type , [ self :: TYPE_CODE , self :: TYPE_STATEMENT , self :: TYPE_PARENTHESIS , ] , true ) ; }
1565	public function getResource ( ) { if ( ! $ this -> resource_type || ! $ this -> resource_id ) { return null ; } return $ this -> getApi ( ) -> getStore ( ) -> find ( ResourceIdentifier :: create ( $ this -> resource_type , ( string ) $ this -> resource_id ) ) ; }
8226	protected function validateRegistration ( array $ reg ) { $ isValid = true ; try { $ this -> storage -> checkValidName ( $ reg [ "username" ] ) ; } catch ( \ RuntimeException $ e ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , $ e -> getMessage ( ) ) ; } $ min = $ this -> config [ "nameLenMin" ] ; $ max = $ this -> config [ "nameLenMax" ] ; if ( strlen ( $ reg [ "username" ] ) < $ min || strlen ( $ reg [ "username" ] ) > $ max ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , sprintf ( "Length of a username must be between %d-%d characters." , $ min , $ max ) ) ; } if ( ! filter_var ( $ reg [ "email" ] , FILTER_VALIDATE_EMAIL ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "Email address does not have a valid format." ) ; } if ( null !== $ this -> storage -> getUserByEmail ( $ reg [ "email" ] ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "This email is already in use." ) ; } if ( $ reg [ "password" ] -> get ( ) !== $ reg [ "passwordRepeat" ] -> get ( ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ reg [ "password" ] ) ) { $ isValid = false ; } if ( $ this -> storage -> getUserByName ( $ reg [ "username" ] ) !== null ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The username is already taken." ) ; } return $ isValid ; }
5443	protected function invokeParser ( $ content , $ is_match ) { if ( ( $ content === '' ) || ( $ content === false ) ) { return true ; } $ handler = $ this -> mode_handlers [ $ this -> mode -> getCurrent ( ) ] ; return $ this -> parser -> $ handler ( $ content , $ is_match ) ; }
10179	public function removeColumn ( $ column ) { foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ c == $ column ) { $ this -> delete ( $ coord ) ; } } }
7356	public static function isValidFormat ( $ format , $ throw = false ) { if ( in_array ( $ format , static :: getFormats ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Unknown format '$format'." ) ; } return false ; }
8940	public function downloadChangeset ( $ id ) { $ base = 'changeset/' . $ id . '/download' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> create ; }
7576	protected function configureData ( $ data ) { if ( is_string ( $ data ) ) { if ( ! empty ( $ this -> Options ) ) { $ fileField = end ( $ this -> Options ) ; $ data = array ( $ fileField => $ data ) ; } else { throw new RequiredOptionsException ( get_called_class ( ) , "Options are required, when passing String for data." ) ; } } if ( is_array ( $ data ) ) { foreach ( $ data as $ key => $ value ) { if ( ! array_key_exists ( $ key , $ this -> _REQUIRED_DATA ) ) { $ data [ $ key ] = $ this -> setFileFieldValue ( $ value ) ; } } } parent :: configureData ( $ data ) ; }
3400	protected function makeRequest ( $ arguments = [ ] ) { $ defaults = $ this -> getDefaultOptions ( ) ; $ arguments = array_merge ( $ defaults , $ arguments ) ; $ client = $ this -> resource -> getGuzzle ( ) ; $ request = $ client -> createRequest ( $ this -> getMethod ( ) , $ this -> url , $ arguments ) ; $ response = $ client -> send ( $ request ) ; $ this -> setResponse ( $ response ) ; $ this -> setContent ( ( string ) $ response -> getBody ( ) ) ; }
4605	public function setEntityUuid ( ? string $ entityUuid ) { if ( null !== $ entityUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ entityUuid ) ) { throw new InvalidArgumentException ( 'Entity uuid is not valid.' ) ; } } $ this -> entityUuid = $ entityUuid ; return $ this ; }
12818	public function transformCommandToMessage ( $ command ) { if ( ! is_object ( $ command ) ) { throw CommandTransformationException :: expectedObject ( $ command ) ; } if ( ! isset ( $ this -> commands [ get_class ( $ command ) ] ) ) { throw CommandTransformationException :: unknownCommand ( $ command , array_keys ( $ this -> commands ) ) ; } if ( $ this -> serializer instanceof EncoderInterface && ! $ this -> serializer -> supportsEncoding ( $ this -> format ) ) { throw CommandTransformationException :: unsupportedFormat ( $ command , $ this -> format ) ; } $ info = $ this -> commands [ get_class ( $ command ) ] ; return new CommandMessage ( $ info -> getVhost ( ) , $ info -> getExchange ( ) , $ this -> serializer -> serialize ( $ command , $ this -> format ) , $ info -> getRoutingKey ( ) , $ info -> getFlags ( ) , $ this -> resolveMessageAttributes ( $ command , $ info ) ) ; }
10833	public function on ( $ column1 , $ op , $ column2 ) { if ( $ this -> active_join === null ) { throw new \ Peyote \ Exception ( "You need to start a join before calling \Peyote\Join::on()" ) ; } list ( $ table , $ type ) = $ this -> active_join ; $ this -> active_join = null ; $ this -> joins [ ] = array ( "ON" , $ table , $ type , $ column1 , $ op , $ column2 ) ; return $ this ; }
7270	public function save ( $ create = false ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; $ isModel = false ; $ into = "" ; $ values = "" ; $ updates = "" ; $ condition = "" ; $ params = [ ] ; $ primaries = [ ] ; $ updateCondition = "" ; foreach ( $ columns as $ i => $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) { $ into .= "$name, " ; $ values .= ":$name, " ; $ updates .= "$name = :$name, " ; $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } if ( strcasecmp ( $ key , "PRI" ) === 0 ) { $ updateCondition .= "$name = :$name and " ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) $ primaries [ $ name ] = $ this -> encodeValue ( $ name ) ; if ( $ name === $ idColumn ) $ isModel = true ; } } $ into = substr ( $ into , 0 , - 2 ) ; $ values = substr ( $ values , 0 , - 2 ) ; $ updates = substr ( $ updates , 0 , - 2 ) ; $ condition = substr ( $ condition , 0 , - 5 ) ; $ updateCondition = substr ( $ updateCondition , 0 , - 5 ) ; try { $ status = Db :: query ( " insert into $tableName ($into) values ($values) " , $ params , static :: getDbName ( ) , false ) !== false ; } catch ( PDOException $ e ) { if ( $ create ) throw $ e ; if ( $ e -> getCode ( ) === "23000" && preg_match ( "/.*'PRIMARY'$/" , $ e -> getMessage ( ) ) ) { $ status = Db :: query ( " update $tableName set $updates where $updateCondition " , $ params , static :: getDbName ( ) , false ) !== false ; } else throw $ e ; } if ( $ status ) { $ lastInsertId = Db :: instance ( static :: getDbName ( ) ) -> lastInsertId ( ) ; if ( $ lastInsertId > 0 ) return static :: find ( $ lastInsertId ) ; else return static :: select ( "where $updateCondition" , $ primaries , static :: getDbName ( ) ) -> first ( ) ; } else return false ; }
10091	protected function checkOptionsArray ( $ options ) { if ( isset ( $ options [ 's' ] ) ) { $ options [ 'size' ] = $ options [ 's' ] ; unset ( $ options [ 's' ] ) ; } if ( isset ( $ options [ 'd' ] ) ) { $ options [ 'default' ] = $ options [ 'd' ] ; unset ( $ options [ 'd' ] ) ; } $ allowedOptions = array ( 'algorithm' => true , 'default' => true , 'https' => true , 'size' => true , ) ; foreach ( $ options as $ key => $ value ) { if ( ! isset ( $ allowedOptions [ $ key ] ) ) { throw new InvalidArgumentException ( 'Invalid option in array: ' . $ key ) ; } } return $ options ; }
10276	public static function getTextWidthPixelsApprox ( $ columnText , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font , $ rotation = 0 ) { $ fontName = $ font -> getName ( ) ; $ fontSize = $ font -> getSize ( ) ; switch ( $ fontName ) { case 'Calibri' : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; case 'Arial' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; case 'Verdana' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; default : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; } if ( $ rotation !== 0 ) { if ( $ rotation == - 165 ) { $ columnWidth = 4 ; } else { $ columnWidth = $ columnWidth * cos ( deg2rad ( $ rotation ) ) + $ fontSize * abs ( sin ( deg2rad ( $ rotation ) ) ) / 5 ; } } return ( int ) $ columnWidth ; }
4078	protected function fetchInputScreenDetails ( ) { $ inputScreenIds = array ( ) ; foreach ( $ this -> information as $ info ) { $ inputScreenIds [ ] = $ info [ self :: COMBINATION ] [ 'dca_id' ] ; } if ( ! $ inputScreenIds ) { return ; } $ statement = $ this -> connection -> query ( sprintf ( 'SELECT * FROM tl_metamodel_dca WHERE id IN (%s)' , implode ( ',' , $ inputScreenIds ) ) ) ; while ( $ inputScreens = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ screenId = $ inputScreens -> id ; $ metaModelId = $ inputScreens -> pid ; $ metaModelName = $ this -> tableNameFromId ( $ metaModelId ) ; $ propertyRows = $ this -> connection -> prepare ( 'SELECT * FROM tl_metamodel_dcasetting WHERE pid=? AND published=1 ORDER BY sorting ASC' ) ; $ propertyRows -> bindValue ( 1 , $ screenId ) ; $ propertyRows -> execute ( ) ; $ conditions = $ this -> connection -> prepare ( ' SELECT cond.*, setting.attr_id AS setting_attr_id FROM tl_metamodel_dcasetting_condition AS cond LEFT JOIN tl_metamodel_dcasetting AS setting ON (cond.settingId=setting.id) LEFT JOIN tl_metamodel_dca AS dca ON (setting.pid=dca.id) WHERE dca.id=? AND setting.published=1 AND cond.enabled=1 ORDER BY sorting ASC ' ) ; $ conditions -> bindValue ( 1 , $ screenId ) ; $ conditions -> execute ( ) ; $ groupSort = $ this -> connection -> prepare ( ' SELECT * FROM tl_metamodel_dca_sortgroup WHERE pid=? ORDER BY sorting ASC ' ) ; $ groupSort -> bindValue ( 1 , $ screenId ) ; $ groupSort -> execute ( ) ; $ inputScreen = array ( 'row' => $ inputScreens -> row ( ) , 'properties' => $ propertyRows -> fetchAll ( \ PDO :: FETCH_ASSOC ) , 'conditions' => $ conditions -> fetchAll ( \ PDO :: FETCH_ASSOC ) , 'groupSort' => $ groupSort -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] = $ inputScreen ; $ this -> information [ $ metaModelName ] [ self :: MODELID ] = $ metaModelId ; $ parentTable = $ inputScreen [ 'row' ] [ 'ptable' ] ; if ( $ parentTable && ! $ this -> isInputScreenStandalone ( $ metaModelName ) ) { $ this -> parentMap [ $ parentTable ] [ ] = $ this -> information [ $ metaModelName ] [ self :: MODELID ] ; $ this -> childMap [ $ metaModelName ] = $ parentTable ; } } }
8771	public function registerConfiguredProviders ( ) { $ providers = Collection :: make ( $ this -> config [ 'app.providers' ] ) -> partition ( function ( $ provider ) { return Str :: startsWith ( $ provider , 'Nur\\' ) ; } ) ; $ providers -> splice ( 1 , 0 , [ $ this -> make ( PackageManifest :: class ) -> providers ( ) ] ) ; ( new ProviderRepository ( $ this , new Filesystem , $ this -> getCachedServicesPath ( ) ) ) -> load ( $ providers -> collapse ( ) -> toArray ( ) ) ; }
3035	protected function exists ( $ key ) { return isset ( $ this -> cache [ $ key ] ) && in_array ( $ this -> cache [ $ key ] [ 'state' ] , [ self :: STATE_ALIGNED , self :: STATE_PENDING_WRITE ] ) ; }
8827	public function token ( ) { $ token = ! empty ( $ this -> csrfToken ) ? $ this -> csrfToken : csrfToken ( ) ; return $ this -> hidden ( '_token' , $ token ) ; }
4111	public function findFileAndLine ( $ className ) { $ result = false ; $ fullPath = $ this -> searchFullPath ( $ this -> getFileFromClassName ( $ className ) ) ; if ( $ fullPath ) { $ result = array ( 'file' => $ fullPath , 'line' => 0 ) ; $ lineNumber = $ this -> getLineNumber ( $ fullPath , '/class\s+' . $ className . '/' ) ; if ( $ lineNumber ) { $ result [ 'line' ] = $ lineNumber ; } } return $ result ; }
8073	public function post ( $ endpoint , $ data , $ headers = [ ] ) { $ request = new Request ( 'POST' , $ endpoint , $ headers , $ data ) ; $ response = $ this -> guzzle -> send ( $ request ) ; return $ this -> handle ( $ response ) ; }
6856	protected static function equinoxMarch ( $ year , $ vsop = true ) { $ month = 3 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
6232	public function setPickupPoint ( $ pickup_point_id ) { $ service = new AdditionalService ( ) ; $ service -> setServiceCode ( 2106 ) ; $ service -> addSpecifier ( 'pickup_point_id' , $ pickup_point_id ) ; $ this -> addAdditionalService ( $ service ) ; }
8138	public function getTemplateClass ( $ name , $ index = null ) { $ key = $ this -> getLoader ( ) -> getCacheKey ( $ name ) . $ this -> optionsHash ; return $ this -> templateClassPrefix . hash ( 'sha256' , $ key ) . ( null === $ index ? '' : '_' . $ index ) ; }
5384	public function setValue ( $ value ) { if ( $ value === false ) { return parent :: setValue ( $ value ) ; } if ( $ value != $ this -> getAttribute ( 'value' ) ) { return false ; } return parent :: setValue ( $ value ) ; }
10362	public static function exception ( $ exception ) { try { while ( ob_get_level ( ) > 0 ) ob_end_clean ( ) ; $ error [ 'code' ] = $ exception -> getCode ( ) ; $ error [ 'message' ] = $ exception -> getMessage ( ) ; $ error [ 'file' ] = $ exception -> getFile ( ) ; $ error [ 'line' ] = $ exception -> getLine ( ) ; if ( $ exception instanceof \ ErrorException ) { $ error [ 'type' ] = 'ErrorException: ' ; $ error [ 'type' ] .= in_array ( $ error [ 'code' ] , array_keys ( ErrorHandler :: $ levels ) ) ? ErrorHandler :: $ levels [ $ error [ 'code' ] ] : 'Unknown Error' ; } else { $ error [ 'type' ] = get_class ( $ exception ) ; } ErrorHandler :: writeLogs ( "{$error['type']}: {$error['message']} in {$error['file']} at line {$error['line']}" ) ; @ header ( 'Content-Type: text/html; charset=UTF-8' ) ; if ( DEVELOPMENT ) { $ error [ 'backtrace' ] = $ exception -> getTrace ( ) ; if ( $ exception instanceof \ ErrorException ) { $ error [ 'backtrace' ] = array_slice ( $ error [ 'backtrace' ] , 1 ) ; } $ error [ 'backtrace' ] = self :: formatBacktrace ( $ error [ 'backtrace' ] ) ; $ error [ 'highlighted' ] = self :: highlightCode ( $ error [ 'file' ] , $ error [ 'line' ] ) ; @ header ( 'HTTP/1.1 500 Internal Server Error' ) ; include 'views/exception.php' ; } else { @ header ( 'HTTP/1.1 500 Internal Server Error' ) ; include 'views/production.php' ; } } catch ( Exception $ e ) { while ( ob_get_level ( ) > 0 ) ob_end_clean ( ) ; echo $ e -> getMessage ( ) . ' in ' . $ e -> getFile ( ) . ' (line ' . $ e -> getLine ( ) . ').' ; } exit ( 1 ) ; }
1970	public static function findByUuid ( $ strUuid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; if ( Validator :: isStringUuid ( $ strUuid ) ) { $ strUuid = StringUtil :: uuidToBin ( $ strUuid ) ; } if ( empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ strUuid , 'uuid' ) ; if ( $ objModel !== null ) { return $ objModel ; } } return static :: findOneBy ( array ( "$t.uuid=UNHEX(?)" ) , bin2hex ( $ strUuid ) , $ arrOptions ) ; }
8558	public function setFinancialEventGroupList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FinancialEventGroupList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5575	public function clickSubmitByName ( $ name , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectByName ( $ name ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectByName ( $ name ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
11093	public static function linkRewrite ( $ str , $ allowUnicodeChars = false ) { if ( ! \ is_string ( $ str ) ) { return false ; } $ str = trim ( $ str ) ; if ( \ function_exists ( 'mb_strtolower' ) ) { $ str = mb_strtolower ( $ str , 'utf-8' ) ; } if ( ! $ allowUnicodeChars ) { $ str = self :: replaceAccentedChars ( $ str ) ; } if ( $ allowUnicodeChars ) { $ str = preg_replace ( '/[^a-zA-Z0-9\s\'\:\/\[\]\-\pL]/u' , '' , $ str ) ; } else { $ str = preg_replace ( '/[^a-zA-Z0-9\s\'\:\/\[\]\-]/' , '' , $ str ) ; } $ str = preg_replace ( '/[\s\'\:\/\[\]\-]+/' , ' ' , $ str ) ; $ str = str_replace ( [ ' ' , '/' ] , '-' , $ str ) ; if ( ! \ function_exists ( 'mb_strtolower' ) ) { $ str = strtolower ( $ str ) ; } return $ str ; }
9471	public function paginate ( $ numTotal , $ page , $ limit = 10 ) { $ this -> setTotalItemCount ( $ numTotal ) ; $ this -> setCurrentPageNumber ( $ page ) ; $ this -> setItemNumberPerPage ( $ limit ) ; }
7427	public function renderEmbed ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> embedDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
4338	private function removeHideIfEmptyGroups ( & $ log ) { $ groupStack = array ( ) ; $ groupStackCount = 0 ; $ removed = false ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ entry = $ log [ $ i ] ; $ groupStack [ ] = array ( 'i' => $ i , 'meta' => ! empty ( $ entry [ 2 ] ) ? $ entry [ 2 ] : array ( ) , 'hasEntries' => false , ) ; $ groupStackCount ++ ; } elseif ( $ method == 'groupEnd' ) { $ group = \ end ( $ groupStack ) ; if ( ! $ group [ 'hasEntries' ] && ! empty ( $ group [ 'meta' ] [ 'hideIfEmpty' ] ) ) { unset ( $ log [ $ group [ 'i' ] ] ) ; unset ( $ log [ $ i ] ) ; $ removed = true ; } \ array_pop ( $ groupStack ) ; $ groupStackCount -- ; } elseif ( $ groupStack ) { $ groupStack [ $ groupStackCount - 1 ] [ 'hasEntries' ] = true ; } } if ( $ removed ) { $ log = \ array_values ( $ log ) ; } }
11016	public function addDefaultListeners ( ) { $ this -> dispatcher -> addListener ( Events :: EVENT_BEFORE_CONTROLLER_RUN , $ this ) ; $ this -> dispatcher -> addListener ( Events :: EVENT_AFTER_CONTROLLER_RUN , $ this ) ; }
11402	public function getAppCode ( $ path , $ width = 430 , $ autoColor = false , $ lineColor = [ 'r' => 0 , 'g' => 0 , 'b' => 0 ] ) { $ params = [ 'path' => $ path , 'width' => $ width , 'auto_color' => $ autoColor , 'line_color' => $ lineColor , ] ; return $ this -> getStream ( self :: API_GET_WXACODE , $ params ) ; }
8793	protected function setKeyInEnvironmentFile ( $ key , $ input , $ output ) { $ currentKey = config ( 'app.key' ) ; $ helper = $ this -> getHelper ( 'question' ) ; $ question = new ConfirmationQuestion ( 'Application key will re-generate. Are you sure?: ' , false ) ; if ( strlen ( $ currentKey ) !== 0 && ( ! $ helper -> ask ( $ input , $ output , $ question ) ) ) { return false ; } $ this -> writeNewEnvironmentFileWith ( $ key ) ; return true ; }
3401	public function getValue ( ApistMethod $ method , Crawler $ rootNode = null ) { if ( is_null ( $ rootNode ) ) { $ rootNode = $ method -> getCrawler ( ) ; } $ result = $ rootNode -> filter ( $ this -> selector ) ; return $ this -> applyResultCallbackChain ( $ result , $ method ) ; }
6235	public function mkdir ( ) : self { if ( ! $ this -> storage -> isDir ( ) ) { if ( ! $ this -> storage -> mkdir ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to create directory at: "%s"' , $ this -> storage -> path ( ) -> raw ) , 500 ) ; } } return $ this ; }
7818	public function create ( ) : ? array { $ body = Body :: json ( [ 'name' => $ this -> name , 'event' => $ this -> event , 'device_id' => $ this -> device , 'filter_type' => '' , 'filter' => '' , 'method' => 'http' , 'action' => $ this -> url , 'secret' => $ this -> secret , ] ) ; $ response = Request :: post ( $ this -> baseUrl . 'callback' , [ ] , $ body ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
7760	protected function detectMetadataDriver ( $ dir , ContainerBuilder $ container ) { $ configPath = $ this -> getMappingResourceConfigDirectory ( ) ; $ resource = $ dir . '/' . $ configPath ; while ( ! is_dir ( $ resource ) ) { $ resource = dirname ( $ resource ) ; } $ container -> addResource ( new FileResource ( $ resource ) ) ; $ extension = $ this -> getMappingResourceExtension ( ) ; if ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.php' ) ) && count ( $ files ) ) { return 'php' ; } $ container -> addResource ( new FileResource ( $ dir ) ) ; if ( is_dir ( $ dir . '/' . $ this -> getMappingObjectDefaultName ( ) ) ) { return 'annotation' ; } return null ; }
12287	public function insetIf ( bool $ condition , string $ block , array $ vars = null ) : string { return $ condition ? trim ( $ this -> make ( $ block , $ vars ) ) . PHP_EOL : PHP_EOL ; }
10438	public function offsetSet ( $ attributeName , $ attribute ) { if ( ! is_string ( $ attributeName ) || ! is_string ( $ attribute ) ) { throw new ValueException ( $ attribute , 'string' ) ; } $ this -> attributes [ $ attributeName ] = $ attribute ; }
12946	protected function parseTags ( $ tags ) { return array_unique ( is_array ( $ tags ) ? array_filter ( $ tags ) : preg_split ( '/\s*,\s*/' , $ tags , - 1 , PREG_SPLIT_NO_EMPTY ) ) ; }
4272	public function stream_close ( ) { if ( ! $ this -> handle ) { return ; } self :: restorePrev ( ) ; \ fclose ( $ this -> handle ) ; $ this -> handle = null ; self :: register ( ) ; }
9294	public function themeDefaults ( ) { view ( ) -> composer ( "*" , function ( $ view ) { $ theme = config ( "dash.theme" , null ) ; if ( ! $ theme ) : if ( view ( ) -> exists ( "theme.dash.index" ) ) : $ theme = "theme.dash." ; else : $ theme = "dash::" ; endif ; endif ; view ( ) -> share ( 'dashTheme' , $ theme ) ; } ) ; }
10100	private function writeRichTextString ( $ row , $ col , $ str , $ xfIndex , $ arrcRun ) { $ record = 0x00FD ; $ length = 0x000A ; $ str = StringHelper :: UTF8toBIFF8UnicodeShort ( $ str , $ arrcRun ) ; if ( ! isset ( $ this -> stringTable [ $ str ] ) ) { $ this -> stringTable [ $ str ] = $ this -> stringUnique ++ ; } ++ $ this -> stringTotal ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvV' , $ row , $ col , $ xfIndex , $ this -> stringTable [ $ str ] ) ; $ this -> append ( $ header . $ data ) ; }
7879	protected function registerLogViewer ( ) { $ this -> app -> singleton ( 'logviewer' , function ( $ app ) { $ factory = $ app [ 'logviewer.factory' ] ; $ filesystem = $ app [ 'logviewer.filesystem' ] ; $ data = $ app [ 'logviewer.data' ] ; return new LogViewer ( $ factory , $ filesystem , $ data ) ; } ) ; $ this -> app -> alias ( 'logviewer' , LogViewer :: class ) ; }
7271	public function delete ( ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; if ( isset ( $ this -> $ idColumn ) ) { $ status = Db :: query ( " delete from $tableName where $idColumn = :id " , [ "id" => $ this -> $ idColumn ] , static :: getDbName ( ) , false ) ; } else { $ condition = "" ; $ params = [ ] ; foreach ( $ columns as $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( isset ( $ this -> $ name ) ) { $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } } $ condition = substr ( $ condition , 0 , - 5 ) ; var_dump ( " delete from $tableName where $condition " ) ; var_dump ( $ params ) ; $ status = Db :: query ( " delete from $tableName where $condition " , $ params , static :: getDbName ( ) , false ) ; } return $ status !== false && $ status > 0 ; }
2829	public function enableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( true ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was enabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to enable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
11640	public function getData ( ) { if ( is_null ( $ this -> _currentData ) ) { $ this -> _currentDataRaw = $ this -> dataProvider -> getData ( ) ; $ this -> _currentData = [ ] ; $ itemNumber = $ this -> dataProvider -> pagination -> offset ; $ row = 0 ; foreach ( $ this -> _currentDataRaw as $ r ) { $ p = [ 'itemNumber' => $ itemNumber , 'id' => $ r -> primaryKey , 'values' => [ ] ] ; foreach ( $ this -> columns as $ key => $ c ) { $ p [ 'values' ] [ $ key ] = $ c -> getDataValue ( $ row , $ r , false ) ; } $ p [ 'acl' ] = [ ] ; if ( $ this -> owner -> instanceSettings [ 'whoAmI' ] === 'parent' and isset ( $ r -> childObject ) and $ r -> childObject -> hasBehavior ( 'Access' ) ) { $ p [ 'acl' ] = $ r -> childObject -> aclSummary ( ) ; } elseif ( $ this -> owner -> instanceSettings [ 'whoAmI' ] === 'child' and isset ( $ r -> parentObject ) and $ r -> parentObject -> hasBehavior ( 'Access' ) ) { $ p [ 'acl' ] = $ r -> parentObject -> aclSummary ( ) ; } elseif ( $ r -> hasBehavior ( 'Access' ) ) { $ p [ 'acl' ] = $ r -> aclSummary ( ) ; } $ this -> _currentData [ 'item-' . $ itemNumber ] = $ p ; $ row ++ ; $ itemNumber ++ ; } } return $ this -> _currentData ; }
5271	private function translateDelete ( ) { $ build = array ( "delete from {$this->table}" ) ; if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
8171	public function renderString ( $ tplString = '' , $ tplData = [ ] ) { try { return $ this -> twig -> createTemplate ( $ tplString ) -> render ( $ tplData ) ; } catch ( Twig_Error $ err ) { return $ this -> error ( $ err , false , $ tplString ) ; } }
11558	public function save ( ) { $ this -> modifiedTime = new \ DateTime ( 'now' ) ; self :: set ( $ this -> namespace , base64_encode ( serialize ( $ this -> instance ) ) , $ this -> modifiedTime -> getTimestamp ( ) + $ this -> lifetime , $ this -> path , $ this -> domain , $ this -> secure ) ; return $ this ; }
1382	protected function dataHas ( $ key ) : bool { if ( ! isset ( $ this -> document -> data ) ) { return false ; } return property_exists ( $ this -> document -> data , $ key ) ; }
12186	public function getCompanionNiceId ( $ queryRole ) { $ companionRoleType = $ this -> companionRoleType ( $ queryRole ) ; if ( empty ( $ companionRoleType ) ) { return false ; } return implode ( ':' , [ $ this -> companionRole ( $ queryRole ) , $ companionRoleType -> systemId ] ) ; }
11446	public function getSpooler ( ) { if ( empty ( $ this -> spooler ) ) { $ spool_class = $ this -> getDefault ( 'spooler' ) ; if ( class_exists ( $ spool_class ) ) { $ this -> setSpooler ( new $ spool_class ) ; } else { throw new \ Exception ( sprintf ( 'Default spool class "%s" not found!' , $ spool_class ) ) ; } } return $ this -> spooler ; }
493	private function indexBuckets ( $ buckets , $ indexBy ) { $ result = [ ] ; foreach ( $ buckets as $ key => $ models ) { $ result [ $ key ] = [ ] ; foreach ( $ models as $ model ) { $ index = is_string ( $ indexBy ) ? $ model [ $ indexBy ] : call_user_func ( $ indexBy , $ model ) ; $ result [ $ key ] [ $ index ] = $ model ; } } return $ result ; }
8196	public function collectDir ( $ dir , $ ext = '.twig' ) { $ iterator = new RegexIterator ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ dir ) , RecursiveIteratorIterator :: LEAVES_ONLY ) , '{' . preg_quote ( $ ext ) . '$}' ) ; return $ this -> collect ( new Twig_Util_TemplateDirIterator ( $ iterator ) ) ; }
1583	public function getRelations ( ) : Collection { return $ this -> getRelationships ( ) -> filter ( function ( array $ relation ) { return array_key_exists ( 'data' , $ relation ) ; } ) -> map ( function ( array $ relation ) { return $ relation [ 'data' ] ; } ) ; }
2219	public static function countPublishedByPids ( $ arrPids , $ blnFeatured = null , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return 0 ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( $ blnFeatured === true ) { $ arrColumns [ ] = "$t.featured='1'" ; } elseif ( $ blnFeatured === false ) { $ arrColumns [ ] = "$t.featured=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , null , $ arrOptions ) ; }
8155	public function addGlobal ( $ name , $ value ) { if ( $ this -> extensionInitialized || $ this -> runtimeInitialized ) { if ( null === $ this -> globals ) { $ this -> globals = $ this -> initGlobals ( ) ; } if ( ! array_key_exists ( $ name , $ this -> globals ) ) { @ trigger_error ( sprintf ( 'Registering global variable "%s" at runtime or when the extensions have already been initialized is deprecated since version 1.21.' , $ name ) , E_USER_DEPRECATED ) ; } } if ( $ this -> extensionInitialized || $ this -> runtimeInitialized ) { $ this -> globals [ $ name ] = $ value ; } else { $ this -> staging -> addGlobal ( $ name , $ value ) ; } }
6596	protected function getSummary ( array $ lines ) { $ summary = '' ; foreach ( $ lines as $ line ) { if ( ! $ line ) { if ( $ summary ) { break ; } continue ; } if ( $ line [ 0 ] == '@' ) { break ; } $ summary .= $ line . "\n" ; if ( substr ( $ line , - 1 ) == '.' ) { break ; } } return trim ( $ summary ) ; }
3772	private function buildLanguageString ( $ name , $ screen , $ locale ) { if ( isset ( $ screen [ 'label' ] [ $ locale ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ $ locale ] ; return ; } $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ '' ] ; }
5483	public function attachLabelBySelector ( SelectorInterface $ selector , $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { if ( method_exists ( $ this -> widgets [ $ i ] , 'setLabel' ) ) { $ this -> widgets [ $ i ] -> setLabel ( $ label ) ; return ; } } } }
11416	private function saveLog ( $ operId , $ calcId ) { $ entity = new ELogOper ( ) ; $ entity -> setOperId ( $ operId ) ; $ entity -> setCalcId ( $ calcId ) ; $ this -> daoLogOper -> create ( $ entity ) ; }
3721	public function handleDelete ( PreDeleteModelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } try { $ this -> tableManipulator -> checkTableExists ( $ tableName = $ event -> getModel ( ) -> getProperty ( 'tableName' ) ) ; } catch ( \ Exception $ exception ) { return ; } $ this -> tableManipulator -> deleteTable ( $ tableName ) ; }
781	public function has ( $ name ) { return isset ( $ this -> _cookies [ $ name ] ) && $ this -> _cookies [ $ name ] -> value !== '' && ( $ this -> _cookies [ $ name ] -> expire === null || $ this -> _cookies [ $ name ] -> expire === 0 || $ this -> _cookies [ $ name ] -> expire >= time ( ) ) ; }
11694	protected function getCompiler ( SplFileInfo $ file ) : Compiler { $ source_type = $ this -> getSourceType ( $ file ) ; $ compiler_type = '\Gears\Asset\Compilers\\' ; $ compiler_type .= ucfirst ( $ source_type ) ; if ( ! class_exists ( $ compiler_type ) ) { throw new RuntimeException ( 'The source file type is not supported! - (' . $ file . ')' ) ; } return new $ compiler_type ( $ file , $ this -> destination , $ this -> debug , $ this -> autoprefix ) ; }
8249	protected function needsPasswordRehash ( array $ userData ) { if ( $ this -> config [ "login" ] [ "passwordRehash" ] !== true ) { return false ; } if ( isset ( $ userData [ 'encoder' ] ) && $ userData [ 'encoder' ] !== $ this -> config [ "encoder" ] ) { return true ; } $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; return $ encoder -> needsRehash ( $ userData [ 'pwhash' ] ) ; }
10701	public static function isBirthNumber ( $ no ) { if ( ! preg_match ( '#^\s*(\d\d)(\d\d)(\d\d)[ /]*(\d\d\d)(\d?)\s*$#' , $ no , $ matches ) ) { return false ; } list ( , $ year , $ month , $ day , $ ext , $ c ) = $ matches ; if ( $ c === '' ) { $ year += $ year < 54 ? 1900 : 1800 ; } else { $ mod = ( $ year . $ month . $ day . $ ext ) % 11 ; if ( $ mod === 10 ) { $ mod = 0 ; } if ( $ mod !== ( int ) $ c ) { return false ; } $ year += $ year < 54 ? 2000 : 1900 ; } if ( $ year > 2003 ) { if ( $ month > 70 ) { $ month -= 70 ; } if ( $ month > 20 && $ month < 50 ) { $ month -= 20 ; } } if ( $ month > 50 ) { $ month -= 50 ; } return checkdate ( $ month , $ day , $ year ) ; }
2394	public function addString ( $ strData , $ strName , $ intTime = 0 ) { ++ $ this -> intCount ; $ strName = strtr ( $ strName , '\\' , '/' ) ; $ arrFile [ 'file_signature' ] = self :: FILE_SIGNATURE ; $ arrFile [ 'version_needed_to_extract' ] = "\x14\x00" ; $ arrFile [ 'general_purpose_bit_flag' ] = "\x00\x00" ; $ arrFile [ 'compression_method' ] = "\x08\x00" ; $ arrFile [ 'last_mod_file_hex' ] = $ this -> unixToHex ( $ intTime ) ; $ arrFile [ 'crc-32' ] = pack ( 'V' , crc32 ( $ strData ) ) ; $ intUncompressed = \ strlen ( $ strData ) ; $ strData = gzcompress ( $ strData ) ; $ strData = substr ( substr ( $ strData , 0 , - 4 ) , 2 ) ; $ intCompressed = \ strlen ( $ strData ) ; $ arrFile [ 'compressed_size' ] = pack ( 'V' , $ intCompressed ) ; $ arrFile [ 'uncompressed_size' ] = pack ( 'V' , $ intUncompressed ) ; $ arrFile [ 'file_name_length' ] = pack ( 'v' , \ strlen ( $ strName ) ) ; $ arrFile [ 'extra_field_length' ] = "\x00\x00" ; $ arrFile [ 'file_name' ] = $ strName ; $ arrFile [ 'extra_field' ] = '' ; $ intOffset = @ ftell ( $ this -> resFile ) ; fwrite ( $ this -> resFile , implode ( '' , $ arrFile ) ) ; fwrite ( $ this -> resFile , $ strData ) ; $ arrHeader [ 'header_signature' ] = self :: CENTRAL_DIR_START ; $ arrHeader [ 'version_made_by' ] = "\x00\x00" ; $ arrHeader [ 'version_needed_to_extract' ] = $ arrFile [ 'version_needed_to_extract' ] ; $ arrHeader [ 'general_purpose_bit_flag' ] = $ arrFile [ 'general_purpose_bit_flag' ] ; $ arrHeader [ 'compression_method' ] = $ arrFile [ 'compression_method' ] ; $ arrHeader [ 'last_mod_file_hex' ] = $ arrFile [ 'last_mod_file_hex' ] ; $ arrHeader [ 'crc-32' ] = $ arrFile [ 'crc-32' ] ; $ arrHeader [ 'compressed_size' ] = $ arrFile [ 'compressed_size' ] ; $ arrHeader [ 'uncompressed_size' ] = $ arrFile [ 'uncompressed_size' ] ; $ arrHeader [ 'file_name_length' ] = $ arrFile [ 'file_name_length' ] ; $ arrHeader [ 'extra_field_length' ] = $ arrFile [ 'extra_field_length' ] ; $ arrHeader [ 'file_comment_length' ] = "\x00\x00" ; $ arrHeader [ 'disk_number_start' ] = "\x00\x00" ; $ arrHeader [ 'internal_file_attributes' ] = "\x00\x00" ; $ arrHeader [ 'external_file_attributes' ] = pack ( 'V' , 32 ) ; $ arrHeader [ 'offset_of_local_header' ] = pack ( 'V' , $ intOffset ) ; $ arrHeader [ 'file_name' ] = $ arrFile [ 'file_name' ] ; $ arrHeader [ 'extra_field' ] = $ arrFile [ 'extra_field' ] ; $ arrHeader [ 'file_comment' ] = '' ; $ this -> strCentralDir .= implode ( '' , $ arrHeader ) ; }
11691	public function getData ( $ origin ) { return array_reduce ( $ this -> structure -> getChildren ( ) , function ( $ acc , $ childDef ) { return array_merge ( $ acc , array ( $ childDef [ 'name' ] => $ childDef [ 'name' ] ) ) ; } , $ this -> getMetadataValues ( ) ) ; }
10980	public function preRemove ( LifecycleEventArgs $ args ) : void { if ( ! $ this -> enableIndexing ) { return ; } $ this -> removeEntity ( $ args -> getObject ( ) , $ args -> getObjectManager ( ) ) ; }
10801	public function renderPageHistoricContentFiltersActionsAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPagehistoricTable' ) ; $ actions = $ melisPageHistoricTable -> getPageHistoricListOfActions ( ) -> toArray ( ) ; $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ options = '<option value="">' . $ translator -> translate ( 'tr_melispagehistoric_filter_action_select' ) . '</option>' ; foreach ( $ actions as $ action ) { $ options .= '<option value="' . $ action [ 'action' ] . '">' . $ action [ 'action' ] . '</option>' ; } $ view = new ViewModel ( ) ; $ view -> options = $ options ; return $ view ; }
7990	public function getPcaServices ( $ pp ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (passport).' ) ; try { $ r = $ this -> get ( 'cloud/' . $ pp . '/pca' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
3926	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( is_array ( $ event -> getValue ( ) ) ) { $ values = [ ] ; foreach ( $ event -> getValue ( ) as $ value ) { $ values [ ] = substr ( $ value , 6 ) ; } $ event -> setValue ( $ values ) ; } else { $ event -> setValue ( substr ( $ event -> getValue ( ) , 6 ) ) ; } }
426	public static function getInstance ( ) { $ class = get_called_class ( ) ; return isset ( Yii :: $ app -> loadedModules [ $ class ] ) ? Yii :: $ app -> loadedModules [ $ class ] : null ; }
12947	protected function ownerHasTagAttribute ( ) { if ( $ this -> _hasTagAttribute === null ) { $ this -> _hasTagAttribute = $ this -> owner -> hasAttribute ( 'tags' ) ; } return $ this -> _hasTagAttribute ; }
4097	public function field ( $ field , $ config = array ( ) ) { if ( is_string ( $ config ) ) $ config = array ( 'type' => $ config ) ; $ this -> properties [ $ field ] = $ config ; return $ this ; }
777	private function defaultTimeTypeMap ( ) { $ map = [ Schema :: TYPE_DATETIME => 'datetime' , Schema :: TYPE_TIMESTAMP => 'timestamp' , Schema :: TYPE_TIME => 'time' , ] ; if ( $ this -> supportsFractionalSeconds ( ) ) { $ map = [ Schema :: TYPE_DATETIME => 'datetime(0)' , Schema :: TYPE_TIMESTAMP => 'timestamp(0)' , Schema :: TYPE_TIME => 'time(0)' , ] ; } return $ map ; }
11163	protected function getResponseFormat ( array $ config ) { if ( isset ( $ config [ 'responseFormat' ] ) ) { if ( ! is_string ( $ config [ 'responseFormat' ] ) ) { throw new \ DomainException ( 'responseFormat must reference a string' , self :: ERR_INVALID_RESPONSEFORMAT ) ; } return $ config [ 'responseFormat' ] ; } return '[ %link% ] "%title%" by %author%' . '; Length %duration%' . '; Published %published%' . '; Views %views%' . '; Likes %likes%' ; }
8050	public function getCalendarEvent ( $ id ) { $ calendarEvent = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: CACHE_KEY . $ id ) ) { return $ cache :: get ( self :: CACHE_KEY . $ id ) ; } $ calendarEvent = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> where ( 'id' , $ id ) -> firstOrFail ( ) ; $ cache :: put ( self :: CACHE_KEY . $ id , $ calendarEvent , $ this -> cacheTimeToLive ) ; return $ calendarEvent ; }
7215	protected function fixDefault ( TaxGroupInterface $ taxGroup ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ taxGroup , [ 'default' ] ) ) { return ; } if ( $ taxGroup -> isDefault ( ) ) { try { $ previousTaxGroup = $ this -> taxGroupRepository -> findDefault ( ) ; } catch ( RuntimeException $ e ) { return ; } if ( null === $ previousTaxGroup || $ previousTaxGroup === $ taxGroup ) { return ; } $ previousTaxGroup -> setDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ previousTaxGroup , false ) ; } }
6471	public function parseContentTypeHeader ( HttpHeaders $ headers ) : ? ContentTypeHeaderValue { if ( ! $ headers -> containsKey ( 'Content-Type' ) ) { return null ; } $ contentTypeHeaderParameters = $ this -> parseParameters ( $ headers , 'Content-Type' ) ; $ contentType = $ contentTypeHeaderParameters -> getKeys ( ) [ 0 ] ; return new ContentTypeHeaderValue ( $ contentType , $ contentTypeHeaderParameters ) ; }
9407	protected function callback ( $ middleware , ResponseInterface $ response ) { $ middleware = is_string ( $ middleware ) ? new $ middleware : $ middleware ; $ callback = function ( $ request , $ next = null ) use ( $ middleware ) { return $ middleware ( $ request , $ next ) ; } ; if ( $ this -> approach ( $ middleware ) == self :: SINGLE_PASS ) { $ callback = function ( $ request , $ next = null ) use ( $ middleware , $ response ) { return $ middleware ( $ request , $ response , $ next ) ; } ; } return $ callback ; }
3816	protected function render ( $ table , $ metaModel , Request $ request ) { $ fields = $ this -> generateForm ( $ table , $ metaModel , $ request ) ; return [ 'action' => '' , 'requestToken' => REQUEST_TOKEN , 'href' => $ this -> getReferer ( $ request , $ table , true ) , 'backBt' => $ this -> translator -> trans ( 'MSC.backBT' , [ ] , 'contao_default' ) , 'add' => $ this -> translator -> trans ( 'MSC.continue' , [ ] , 'contao_default' ) , 'saveNclose' => $ this -> translator -> trans ( 'MSC.saveNclose' , [ ] , 'contao_default' ) , 'activate' => $ this -> translator -> trans ( $ table . '.addAll_activate' , [ ] , 'contao_' . $ table ) , 'headline' => $ this -> translator -> trans ( $ table . '.addall.1' , [ ] , 'contao_' . $ table ) , 'selectAll' => $ this -> translator -> trans ( 'MSC.selectAll' , [ ] , 'contao_default' ) , 'cacheMessage' => '' , 'updateMessage' => '' , 'hasCheckbox' => count ( $ fields ) > 0 , 'fields' => $ fields , ] ; }
1876	public function create ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCreatable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not creatable.' ) ; } $ this -> import ( Files :: class , 'Files' ) ; $ strFolder = Input :: get ( 'pid' , true ) ; if ( $ strFolder == '' || ! file_exists ( $ this -> strRootDir . '/' . $ strFolder ) || ! $ this -> isMounted ( $ strFolder ) ) { throw new AccessDeniedException ( 'Folder "' . $ strFolder . '" is not mounted or is not a directory.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; $ arrClipboard [ $ this -> strTable ] = array ( ) ; $ objSession -> set ( 'CLIPBOARD' , $ arrClipboard ) ; $ this -> Files -> mkdir ( $ strFolder . '/__new__' ) ; $ this -> redirect ( html_entity_decode ( $ this -> switchToEdit ( $ strFolder . '/__new__' ) ) ) ; }
984	public function usageCharge ( StoreUsageCharge $ request ) { $ validated = $ request -> validated ( ) ; $ uc = new UsageCharge ( ShopifyApp :: shop ( ) , $ validated ) ; $ uc -> activate ( ) ; $ uc -> save ( ) ; return isset ( $ validated [ 'redirect' ] ) ? Redirect :: to ( $ validated [ 'redirect' ] ) -> with ( 'success' , 'usage_charge' ) : Redirect :: back ( ) -> with ( 'success' , 'usage_charge' ) ; }
3332	public function fromContent ( $ content , $ mime_type ) { $ tmpfile = tempnam ( sys_get_temp_dir ( ) , 'ucr' ) ; $ temp = fopen ( $ tmpfile , 'w' ) ; fwrite ( $ temp , $ content ) ; fclose ( $ temp ) ; return $ this -> fromPath ( $ tmpfile , $ mime_type ) ; }
10199	private function writeCellSpan ( XMLWriter $ objWriter , $ curColumn , $ prevColumn ) { $ diff = $ curColumn - $ prevColumn - 1 ; if ( 1 === $ diff ) { $ objWriter -> writeElement ( 'table:table-cell' ) ; } elseif ( $ diff > 1 ) { $ objWriter -> startElement ( 'table:table-cell' ) ; $ objWriter -> writeAttribute ( 'table:number-columns-repeated' , $ diff ) ; $ objWriter -> endElement ( ) ; } }
12742	public function removeById ( $ connectionID ) { if ( isset ( $ this -> pool [ $ connectionID ] ) ) { $ this -> slotmap -> reset ( ) ; $ this -> slots = array_diff ( $ this -> slots , array ( $ connectionID ) ) ; unset ( $ this -> pool [ $ connectionID ] ) ; return true ; } return false ; }
444	public function trigger ( $ name , Event $ event = null ) { $ this -> ensureBehaviors ( ) ; $ eventHandlers = [ ] ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ handlers ) ; } } if ( ! empty ( $ this -> _events [ $ name ] ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ this -> _events [ $ name ] ) ; } if ( ! empty ( $ eventHandlers ) ) { if ( $ event === null ) { $ event = new Event ( ) ; } if ( $ event -> sender === null ) { $ event -> sender = $ this ; } $ event -> handled = false ; $ event -> name = $ name ; foreach ( $ eventHandlers as $ handler ) { $ event -> data = $ handler [ 1 ] ; call_user_func ( $ handler [ 0 ] , $ event ) ; if ( $ event -> handled ) { return ; } } } Event :: trigger ( $ this , $ name , $ event ) ; }
5616	public function compareChildren ( $ a , $ b ) { if ( $ this -> _children [ $ a ] -> getTotalSize ( ) > $ this -> _children [ $ b ] -> getTotalSize ( ) ) { $ node_a = $ this -> _children [ $ a ] ; $ node_b = $ this -> _children [ $ b ] ; $ this -> _children [ $ a ] = $ node_b ; $ this -> _children [ $ b ] = $ node_a ; } }
5393	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'fail>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "fail>\n" ; }
2334	public function onSwitchUser ( SwitchUserEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'The token storage did not contain a token.' ) ; } $ sourceUser = $ token -> getUser ( ) ; if ( $ sourceUser instanceof UserInterface ) { $ sourceUser = $ sourceUser -> getUsername ( ) ; } $ targetUser = $ event -> getTargetUser ( ) ; if ( $ targetUser instanceof UserInterface ) { $ targetUser = $ targetUser -> getUsername ( ) ; } $ this -> logger -> info ( sprintf ( 'User "%s" has switched to user "%s"' , $ sourceUser , $ targetUser ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ sourceUser ) ] ) ; }
9024	public function hasDenial ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( in_array ( $ word , $ this -> denialWords ) ) { $ result = true ; } } return $ result ; }
3709	protected function getFrontendFilterOptions ( ) { $ objFrontendFilterOptions = new FrontendFilterOptions ( ) ; $ objFrontendFilterOptions -> setAutoSubmit ( $ this -> objFilterConfig -> metamodel_fef_autosubmit ? true : false ) ; $ objFrontendFilterOptions -> setHideClearFilter ( $ this -> objFilterConfig -> metamodel_fef_hideclearfilter ? true : false ) ; $ objFrontendFilterOptions -> setShowCountValues ( $ this -> objFilterConfig -> metamodel_available_values ? true : false ) ; return $ objFrontendFilterOptions ; }
7252	protected function validatePaymentTermAndOutstandingLimit ( SaleInterface $ sale , Constraint $ constraint ) { if ( 0 >= $ sale -> getOutstandingLimit ( ) ) { return ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( $ customer -> hasParent ( ) ) { $ term = $ customer -> getParent ( ) -> getPaymentTerm ( ) ; } else { $ term = $ customer -> getPaymentTerm ( ) ; } } } if ( null === $ term ) { $ this -> context -> buildViolation ( $ constraint -> outstanding_limit_require_term ) -> atPath ( 'outstandingLimit' ) -> addViolation ( ) ; } }
9203	public function get ( $ endpoint , $ params = null ) { $ endpoint = $ this -> prependVersionToEndpoint ( $ endpoint , Config :: get ( 'api_version' ) ) ; $ options = $ this -> constructRequestOptions ( $ params ) ; $ response = $ this -> guzzleClient -> get ( $ endpoint , $ options ) ; return $ response ; }
4222	public function get ( $ key = null ) { if ( $ key == 'lastError' ) { return isset ( $ this -> data [ 'lastError' ] ) ? $ this -> data [ 'lastError' ] -> getValues ( ) : null ; } if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } if ( isset ( $ this -> { $ key } ) ) { return $ this -> { $ key } ; } return null ; }
5740	protected static function logDuration ( Request $ request , Response $ response , $ startTime ) { $ duration = microtime ( true ) - $ startTime ; $ tags = [ "status_code" => $ response -> getStatusCode ( ) ] ; if ( ! config ( 'datadog-helper.middleware_disable_url_tag' , false ) ) { $ tags [ "url" ] = $ request -> getSchemeAndHttpHost ( ) . $ request -> getRequestUri ( ) ; } Datadog :: timing ( 'request_time' , $ duration , 1 , $ tags ) ; }
4456	protected function fetchQueue ( string $ eventName ) : SplPriorityQueue { if ( isset ( $ this -> events [ $ eventName ] ) == false ) { $ this -> events [ $ eventName ] = $ this -> createQueue ( ) ; } return $ this -> events [ $ eventName ] ; }
3601	private function collectException ( $ httpRequest , $ httpResponse , $ exception ) { if ( $ this -> profiler ) { $ collector = new ExceptionDataCollector ( ) ; $ collector -> collect ( $ httpRequest , $ httpResponse , $ exception ) ; $ this -> profiler -> add ( $ collector ) ; } }
6711	protected function urlToParameters ( $ url ) { $ urlParameters = [ ] ; $ url = parse_url ( $ url , PHP_URL_PATH ) ; $ urlParts = explode ( '/' , $ url ) ; reset ( $ urlParts ) ; $ key = next ( $ urlParts ) ; while ( ( $ value = next ( $ urlParts ) ) !== false ) { $ urlParameters [ $ key ] = $ value ; $ key = $ value ; } return $ urlParameters ; }
7428	public function renderObject ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> objectDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
7723	public function objectToArray ( $ object , $ array = [ ] ) { $ reflectionClass = new \ ReflectionClass ( get_class ( $ object ) ) ; foreach ( $ reflectionClass -> getProperties ( ) as $ property ) { $ property -> setAccessible ( true ) ; $ name = trim ( strtolower ( preg_replace ( '/[A-Z]([A-Z](?![a-z]))*/' , '_$0' , $ property -> getName ( ) ) ) , '_' ) ; if ( empty ( $ property -> getValue ( $ object ) ) ) { continue ; } else if ( is_object ( $ property -> getValue ( $ object ) ) ) { $ array [ $ name ] = $ this -> objectToArray ( $ property -> getValue ( $ object ) ) ; } else if ( is_array ( $ property -> getValue ( $ object ) ) ) { foreach ( $ property -> getValue ( $ object ) as $ key => $ value ) { if ( is_object ( $ value ) ) { $ array [ $ name ] [ ] = $ this -> objectToArray ( $ value ) ; } } } else { $ array [ $ name ] = $ property -> getValue ( $ object ) ; } $ property -> setAccessible ( false ) ; } return $ array ; }
2396	protected function unixToHex ( $ intTime = 0 ) { $ arrTime = $ intTime ? getdate ( $ intTime ) : getdate ( ) ; $ hexTime = dechex ( ( ( $ arrTime [ 'year' ] - 1980 ) << 25 ) | ( $ arrTime [ 'mon' ] << 21 ) | ( $ arrTime [ 'mday' ] << 16 ) | ( $ arrTime [ 'hours' ] << 11 ) | ( $ arrTime [ 'minutes' ] << 5 ) | ( $ arrTime [ 'seconds' ] >> 1 ) ) ; return pack ( "H*" , $ hexTime [ 6 ] . $ hexTime [ 7 ] . $ hexTime [ 4 ] . $ hexTime [ 5 ] . $ hexTime [ 2 ] . $ hexTime [ 3 ] . $ hexTime [ 0 ] . $ hexTime [ 1 ] ) ; }
2041	public static function symlink ( string $ target , string $ link , string $ rootDir ) : void { static :: validateSymlink ( $ target , $ link , $ rootDir ) ; $ fs = new Filesystem ( ) ; if ( ! $ fs -> isAbsolutePath ( $ target ) ) { $ target = $ rootDir . '/' . $ target ; } if ( ! $ fs -> isAbsolutePath ( $ link ) ) { $ link = $ rootDir . '/' . $ link ; } if ( '\\' === \ DIRECTORY_SEPARATOR ) { $ fs -> symlink ( $ target , $ link ) ; } else { $ fs -> symlink ( rtrim ( $ fs -> makePathRelative ( $ target , \ dirname ( $ link ) ) , '/' ) , $ link ) ; } }
5095	protected function getDefaultParts ( ) { if ( ! isset ( CmdUpsert :: $ DEFAULT ) ) { CmdUpsert :: $ DEFAULT = parent :: getDefaultParts ( ) ; CmdUpsert :: $ PART_SET = count ( CmdUpsert :: $ DEFAULT ) ; CmdUpsert :: $ DEFAULT [ CmdUpsert :: $ PART_SET ] = false ; } return CmdUpsert :: $ DEFAULT ; }
6704	public function baseURL ( $ httpverb , $ url , $ params ) { uksort ( $ params , 'strcmp' ) ; return strtoupper ( $ httpverb ) . '&' . rawurlencode ( $ url ) . '&' . rawurlencode ( http_build_query ( $ params ) ) ; }
11657	public function make ( ) { if ( count ( $ this -> headers ) > 0 ) { if ( ! $ this -> session -> exists ( 'headersInRedirect' , 'redirect' ) || ! $ this -> session -> get ( 'headersInRedirect' , 'redirect' ) ) { $ this -> session -> set ( 'redirectPath' , $ this -> path , 'redirect' ) ; $ this -> session -> set ( 'headersInRedirect' , $ this -> headers , 'redirect' ) ; } } header ( "Location: $this->path" ) ; exit ( ) ; }
4974	private function hydrateTree ( NodeInterface $ object , \ ArrayObject $ currentData = null ) { if ( null === $ currentData ) { $ currentData = $ this -> hydrateData [ '__root__' ] ; } if ( 'set' == $ currentData [ 'do' ] ) { $ object -> setName ( $ currentData [ 'name' ] ) -> setValue ( $ currentData [ 'value' ] ) -> setPriority ( $ currentData [ 'priority' ] ) ; } if ( isset ( $ this -> hydrateData [ $ currentData [ 'current' ] ] ) ) { foreach ( $ this -> hydrateData [ $ currentData [ 'current' ] ] as $ childData ) { $ child = $ this -> findOrCreateChild ( $ object , $ childData [ 'id' ] ) ; if ( 'remove' == $ childData [ 'do' ] ) { $ object -> removeChild ( $ child ) ; } else { $ this -> hydrateTree ( $ child , $ childData ) ; } } } return $ object ; }
10142	private function readDefault ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ this -> pos += 4 + $ length ; }
6792	public function build ( Notify $ notify ) { $ event = new NotifyEvent ( $ notify ) ; $ this -> eventDispatcher -> dispatch ( NotifyEvents :: BUILD , $ event ) ; return ! $ event -> isAbort ( ) ; }
1567	public function getType ( ) : string { if ( $ resource = $ this -> getResource ( ) ) { return get_class ( $ resource ) ; } $ resourceType = $ this -> getResourceType ( ) ; if ( ! $ type = $ this -> resolver -> getType ( $ resourceType ) ) { throw new RuntimeException ( "JSON API resource type {$resourceType} is not registered." ) ; } return $ type ; }
3931	private function getOrCreateProperty ( PropertiesDefinitionInterface $ definition , $ propName ) { if ( $ definition -> hasProperty ( $ propName ) ) { return $ definition -> getProperty ( $ propName ) ; } $ property = new DefaultProperty ( $ propName ) ; $ definition -> addProperty ( $ property ) ; return $ property ; }
12769	public function getDb ( ) { if ( is_null ( $ this -> _db ) ) { if ( ! isset ( $ this -> dbConfig [ 'class' ] ) ) { $ this -> dbConfig [ 'class' ] = 'cascade\components\dataInterface\connectors\db\Connection' ; } $ this -> _db = Yii :: createObject ( $ this -> dbConfig ) ; $ this -> _db -> open ( ) ; } if ( empty ( $ this -> _db ) || ! $ this -> _db -> isActive ) { throw new Exception ( "Unable to connect to foreign database." ) ; } return $ this -> _db ; }
5060	public static function fromURI ( $ URI ) { $ regex = '/^(([^-]|--)+)-(([^-]|--)+)-(([^-]|--)+)\.(svg|png|gif|jpg)$/' ; $ match = array ( ) ; if ( 1 != preg_match ( $ regex , $ URI , $ match ) && ( 7 != count ( $ match ) ) ) { throw new \ InvalidArgumentException ( 'The URI given is not a valid URI' . $ URI ) ; } $ subject = $ match [ 1 ] ; $ status = $ match [ 3 ] ; $ color = $ match [ 5 ] ; $ format = $ match [ 7 ] ; return new self ( $ subject , $ status , $ color , $ format ) ; }
3105	public function getStoreId ( ) { return isset ( $ this -> state [ self :: VAR_STORE_ID ] ) ? $ this -> state [ self :: VAR_STORE_ID ] : false ; }
1614	private function sendCommandInternal ( $ command , $ params ) { $ written = @ fwrite ( $ this -> _socket , $ command ) ; if ( $ written === false ) { throw new SocketException ( "Failed to write to socket.\nRedis command was: " . $ command ) ; } if ( $ written !== ( $ len = mb_strlen ( $ command , '8bit' ) ) ) { throw new SocketException ( "Failed to write to socket. $written of $len bytes written.\nRedis command was: " . $ command ) ; } return $ this -> parseResponse ( implode ( ' ' , $ params ) ) ; }
4661	public function send ( ) { $ eventManager = $ this -> getManager ( ) -> getEventsManager ( ) ; if ( $ eventManager ) { $ result = $ eventManager -> fire ( 'mailer:beforeSend' , $ this ) ; } else { $ result = true ; } if ( $ result === false ) { return false ; } $ this -> failedRecipients = [ ] ; $ queue = $ this -> getManager ( ) -> getQueue ( ) ; if ( $ this -> auth ) { $ queue -> putInTube ( $ this -> queueName , [ 'message' => $ this -> getMessage ( ) , 'auth' => $ this -> smtp , ] ) ; } else { $ queue -> putInTube ( $ this -> queueName , $ this -> getMessage ( ) ) ; } }
4113	public function getBlockInfo ( Mage_Core_Block_Abstract $ block , $ fullInfo = true ) { $ info = array ( 'name' => $ block -> getNameInLayout ( ) , 'alias' => $ block -> getBlockAlias ( ) , ) ; if ( ! $ fullInfo ) { return $ info ; } $ info [ 'class' ] = get_class ( $ block ) ; if ( $ this -> getRemoteCallEnabled ( ) ) { $ fileAndLine = Mage :: helper ( 'aoe_templatehints/classInfo' ) -> findFileAndLine ( $ info [ 'class' ] ) ; if ( $ fileAndLine ) { $ url = sprintf ( $ this -> getRemoteCallUrlTemplate ( ) , $ fileAndLine [ 'file' ] , $ fileAndLine [ 'line' ] ) ; $ info [ 'class' ] = sprintf ( $ this -> getRemoteCallLinkTemplate ( ) , $ url , $ info [ 'class' ] ) ; } } $ info [ 'module' ] = $ block -> getModuleName ( ) ; if ( $ block instanceof Mage_Cms_Block_Block ) { $ info [ 'cms-blockId' ] = $ block -> getBlockId ( ) ; } if ( $ block instanceof Mage_Cms_Block_Page ) { $ info [ 'cms-pageId' ] = $ block -> getPage ( ) -> getIdentifier ( ) ; } $ templateFile = $ block -> getTemplateFile ( ) ; if ( $ templateFile ) { $ info [ 'template' ] = $ templateFile ; if ( $ this -> getRemoteCallEnabled ( ) ) { $ url = sprintf ( $ this -> getRemoteCallUrlTemplate ( ) , Mage :: getBaseDir ( 'design' ) . DS . $ templateFile , 0 ) ; $ info [ 'template' ] = sprintf ( $ this -> getRemoteCallLinkTemplate ( ) , $ url , $ templateFile ) ; } } $ info [ 'cache-status' ] = self :: TYPE_NOTCACHED ; $ cacheLifeTime = $ block -> getCacheLifetime ( ) ; if ( ! is_null ( $ cacheLifeTime ) ) { $ info [ 'cache-lifetime' ] = ( intval ( $ cacheLifeTime ) == 0 ) ? 'forever' : intval ( $ cacheLifeTime ) . ' sec' ; $ info [ 'cache-key' ] = $ block -> getCacheKey ( ) ; $ info [ 'cache-key-info' ] = is_array ( $ block -> getCacheKeyInfo ( ) ) ? implode ( ', ' , $ block -> getCacheKeyInfo ( ) ) : $ block -> getCacheKeyInfo ( ) ; $ info [ 'tags' ] = implode ( ',' , $ block -> getCacheTags ( ) ) ; $ info [ 'cache-status' ] = self :: TYPE_CACHED ; } elseif ( $ this -> isWithinCachedBlock ( $ block ) ) { $ info [ 'cache-status' ] = self :: TYPE_IMPLICITLYCACHED ; } $ info [ 'methods' ] = $ this -> getClassMethods ( get_class ( $ block ) ) ; return $ info ; }
954	protected function returnTo ( ) { $ return_to = Session :: get ( 'return_to' ) ; if ( $ return_to ) { Session :: forget ( 'return_to' ) ; return Redirect :: to ( $ return_to ) ; } return Redirect :: route ( 'home' ) ; }
1263	private function createAcceptRequest ( $ shipmentDigest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'ShipmentAcceptRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'ShipAccept' ) ) ; $ container -> appendChild ( $ xml -> createElement ( 'ShipmentDigest' , $ shipmentDigest ) ) ; return $ xml -> saveXML ( ) ; }
11330	public function getMultiline ( ) { if ( is_null ( $ this -> _multiline ) ) { $ this -> _multiline = MultilineDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _multiline ; }
9650	public function delete ( ) { $ options = $ this -> Options ( ) ; if ( $ options ) { foreach ( $ options as $ option ) { $ option -> delete ( ) ; } } parent :: delete ( ) ; }
343	protected function renderSortLinks ( ) { $ attributes = empty ( $ this -> attributes ) ? array_keys ( $ this -> sort -> attributes ) : $ this -> attributes ; $ links = [ ] ; foreach ( $ attributes as $ name ) { $ links [ ] = $ this -> sort -> link ( $ name , $ this -> linkOptions ) ; } return Html :: ul ( $ links , array_merge ( $ this -> options , [ 'encode' => false ] ) ) ; }
7421	protected function initializeProductMediaGalleryValueToEntity ( array $ attr ) { $ rowId = $ attr [ MemberNames :: ROW_ID ] ; $ valueId = $ attr [ MemberNames :: VALUE_ID ] ; if ( $ this -> loadProductMediaGalleryValueToEntityByValueIdAndRowId ( $ valueId , $ rowId ) ) { return ; } return $ attr ; }
5411	public function write ( $ message ) { if ( $ this -> isError ( ) || ! $ this -> isOpen ( ) ) { return false ; } $ count = fwrite ( $ this -> handle , $ message ) ; if ( ! $ count ) { if ( $ count === false ) { $ this -> setError ( 'Cannot write to socket' ) ; $ this -> close ( ) ; } return false ; } fflush ( $ this -> handle ) ; $ this -> sent .= $ message ; return true ; }
9999	private function setShadowColor ( $ color , $ alpha , $ type ) { if ( $ color !== null ) { $ this -> shadowProperties [ 'color' ] [ 'value' ] = ( string ) $ color ; } if ( $ alpha !== null ) { $ this -> shadowProperties [ 'color' ] [ 'alpha' ] = $ this -> getTrueAlpha ( ( int ) $ alpha ) ; } if ( $ type !== null ) { $ this -> shadowProperties [ 'color' ] [ 'type' ] = ( string ) $ type ; } return $ this ; }
857	public function overrideRange ( $ indexStart , $ indexEnd , $ items ) { $ oldCode = $ this -> generatePartialCode ( $ indexStart , $ indexEnd ) ; $ newCode = '' ; foreach ( $ items as $ item ) { $ newCode .= $ item -> getContent ( ) ; } if ( $ oldCode === $ newCode ) { return ; } $ indexToChange = $ indexEnd - $ indexStart + 1 ; $ itemsCount = \ count ( $ items ) ; if ( $ itemsCount > $ indexToChange ) { $ placeholders = [ ] ; while ( $ itemsCount > $ indexToChange ) { $ placeholders [ ] = new Token ( '__PLACEHOLDER__' ) ; ++ $ indexToChange ; } $ this -> insertAt ( $ indexEnd + 1 , $ placeholders ) ; } foreach ( $ items as $ itemIndex => $ item ) { $ this [ $ indexStart + $ itemIndex ] = $ item ; } if ( $ itemsCount < $ indexToChange ) { $ this -> clearRange ( $ indexStart + $ itemsCount , $ indexEnd ) ; } }
12916	protected function resultToModels ( $ result ) { $ models = array ( ) ; foreach ( $ result as $ r ) { $ pk = $ r -> { $ this -> pk } ; try { $ models [ ] = new $ this -> class ( $ pk , $ r ) ; } catch ( \ Exception $ e ) { } } return $ models ; }
11324	public static function convertCase ( $ string , $ toCase ) { $ str = strtolower ( ltrim ( preg_replace ( [ '/[A-Z]/' , '/[_]/' ] , [ ' $0' , ' ' ] , $ string ) ) ) ; switch ( strtoupper ( $ toCase ) ) { case 'PASCAL' : return str_replace ( ' ' , '' , ucwords ( $ str ) ) ; case 'CAMEL' : return lcfirst ( str_replace ( ' ' , '' , ucwords ( $ str ) ) ) ; default : return str_replace ( ' ' , '_' , $ str ) ; } }
1345	public function isUpdateResource ( ) : bool { return $ this -> isMethod ( 'patch' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
6589	public function post ( $ url , $ data = null , $ method = "POST" ) { return $ this -> request ( [ CURLOPT_POST => true , CURLOPT_CUSTOMREQUEST => $ method ? : "POST" , CURLOPT_URL => "$url" , CURLOPT_POSTFIELDS => $ data ? : '' , ] ) ; }
4204	private function addPropertiesPhpDoc ( Event $ abs ) { $ tags = array ( 'property' => 'magic' , 'property-read' => 'magic-read' , 'property-write' => 'magic-write' , ) ; $ inheritedFrom = null ; if ( ! \ array_intersect_key ( $ abs [ 'phpDoc' ] , $ tags ) ) { $ found = false ; $ obj = $ abs -> getSubject ( ) ; if ( ! \ method_exists ( $ obj , '__get' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ parsed = $ this -> phpDoc -> getParsed ( $ reflector ) ; $ tagIntersect = \ array_intersect_key ( $ parsed , $ tags ) ; if ( ! $ tagIntersect ) { continue ; } $ found = true ; $ inheritedFrom = $ reflector -> getName ( ) ; $ abs [ 'phpDoc' ] = \ array_merge ( $ abs [ 'phpDoc' ] , $ tagIntersect ) ; break ; } if ( ! $ found ) { return ; } } $ properties = $ abs [ 'properties' ] ; foreach ( $ tags as $ tag => $ vis ) { if ( ! isset ( $ abs [ 'phpDoc' ] [ $ tag ] ) ) { continue ; } foreach ( $ abs [ 'phpDoc' ] [ $ tag ] as $ phpDocProp ) { $ exists = isset ( $ properties [ $ phpDocProp [ 'name' ] ] ) ; $ properties [ $ phpDocProp [ 'name' ] ] = \ array_merge ( $ exists ? $ properties [ $ phpDocProp [ 'name' ] ] : self :: $ basePropInfo , array ( 'desc' => $ phpDocProp [ 'desc' ] , 'type' => $ phpDocProp [ 'type' ] , 'inheritedFrom' => $ inheritedFrom , 'visibility' => $ exists ? array ( $ properties [ $ phpDocProp [ 'name' ] ] [ 'visibility' ] , $ vis ) : $ vis , ) ) ; if ( ! $ exists ) { $ properties [ $ phpDocProp [ 'name' ] ] [ 'value' ] = $ this -> abstracter -> UNDEFINED ; } } unset ( $ abs [ 'phpDoc' ] [ $ tag ] ) ; } $ abs [ 'properties' ] = $ properties ; return ; }
4511	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } }
3744	protected function getMetaModel ( ) { if ( ! $ this -> metaModel ) { if ( $ this -> metaModel === null ) { throw new \ RuntimeException ( 'No MetaModel instance set for ' . $ this -> strTable ) ; } } return $ this -> metaModel ; }
9113	public function setUp ( ) { $ this -> controllers = array ( ) ; $ this -> views = array ( ) ; $ this -> viewControls = array ( ) ; $ this -> setDefaults ( ) ; $ this -> init ( ) ; $ this -> setLogger ( new NullLogger ( ) ) ; return $ this ; }
6836	private function isIdentityValid ( SaleInterface $ cart ) { return 0 < strlen ( $ cart -> getEmail ( ) ) && 0 < strlen ( $ cart -> getGender ( ) ) && 0 < strlen ( $ cart -> getFirstName ( ) ) && 0 < strlen ( $ cart -> getLastName ( ) ) ; }
5863	protected function expandConversionMapping ( array $ mapping ) { $ ret = [ ] ; $ matches = [ ] ; foreach ( $ mapping as $ m ) { if ( preg_match ( '/^(.*)\s*=>\s*(.*)/' , $ m , $ matches ) ) { $ ret [ trim ( $ matches [ 1 ] ) ] = trim ( $ matches [ 2 ] ) ; } } return $ ret ; }
1067	private function findConflictsBetweenSubSelectionSets ( ValidationContext $ context , $ areMutuallyExclusive , $ parentType1 , SelectionSetNode $ selectionSet1 , $ parentType2 , SelectionSetNode $ selectionSet2 ) { $ conflicts = [ ] ; [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType1 , $ selectionSet1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType2 , $ selectionSet2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; if ( $ fragmentNames2Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap1 , $ fragmentNames2 [ $ j ] ) ; } } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; if ( $ fragmentNames1Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap2 , $ fragmentNames1 [ $ i ] ) ; } } for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentNames2 [ $ j ] ) ; } } return $ conflicts ; }
8886	private function parseResult ( ) { if ( $ this -> xml_result -> Response -> ResponseStatusCode != '1' ) { return array ( 'Error' => array ( 'ErrorSeverity' => "{$this->xml_result->Response->Error->ErrorSeverity}" , 'ErrorCode' => "{$this->xml_result->Response->Error->ErrorCode}" , 'ErrorDescription' => "{$this->xml_result->Response->Error->ErrorDescription}" ) ) ; return $ this -> xml_result ; } $ simplified = array ( ) ; $ shipping_choices = array ( ) ; foreach ( $ this -> xml_result -> RatedShipment as $ service ) { $ simplified [ ] = '{' . $ service -> TotalCharges -> MonetaryValue . '}' ; } foreach ( $ simplified as $ key => $ value ) { $ service = $ this -> xml_result -> RatedShipment [ $ key ] -> children ( ) ; if ( $ this -> negotiated_rates && $ service -> NegotiatedRates -> NetSummaryCharges -> GrandTotal -> MonetaryValue ) { $ rate = number_format ( ( double ) ( $ service -> NegotiatedRates -> NetSummaryCharges -> GrandTotal -> MonetaryValue ) , 2 ) ; } else { $ rate = number_format ( ( double ) ( $ service -> TransportationCharges -> MonetaryValue ) , 2 ) ; } $ shipping_choices [ "{$service->Service->Code}" ] = array ( 'service' => $ this -> shipperCodes ( "{$service->Service->Code}" ) , 'rate' => "{$rate}" ) ; } return $ shipping_choices ; }
3347	public function __preparedRequest ( $ type , $ request_type = 'GET' , $ params = array ( ) , $ data = array ( ) , $ retry_throttled = null ) { $ retry_throttled = $ retry_throttled ? : $ this -> retry_throttled ; $ path = $ this -> __getPath ( $ type , $ params ) ; while ( true ) { try { return $ this -> request ( $ request_type , $ path , $ data ) ; } catch ( ThrottledRequestException $ exception ) { if ( $ retry_throttled > 0 ) { sleep ( $ exception -> getTimeout ( ) ) ; $ retry_throttled -- ; continue ; } else { throw $ exception ; } } } return null ; }
1277	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'TrackRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'Track' ) ) ; if ( null !== $ this -> requestOption ) { $ request -> appendChild ( $ xml -> createElement ( 'RequestOption' , $ this -> requestOption ) ) ; } if ( null !== $ this -> trackingNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ this -> trackingNumber ) ) ; } if ( $ this -> isMailInnovations ( ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'IncludeMailInnovationIndicator' ) ) ; } if ( null !== $ this -> referenceNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) -> appendChild ( $ xml -> createElement ( 'Value' , $ this -> referenceNumber ) ) ; } if ( null !== $ this -> shipperNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ this -> shipperNumber ) ) ; } if ( null !== $ this -> beginDate || null !== $ this -> endDate ) { $ DateRange = $ xml -> createElement ( 'PickupDateRange' ) ; if ( null !== $ this -> beginDate ) { $ beginDate = $ this -> beginDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'BeginDate' , $ beginDate ) ) ; } if ( null !== $ this -> endDate ) { $ endDate = $ this -> endDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'EndDate' , $ endDate ) ) ; } $ trackRequest -> appendChild ( $ DateRange ) ; } return $ xml -> saveXML ( ) ; }
7668	function RFCDate ( ) { $ tz = date ( "Z" ) ; $ tzs = ( $ tz < 0 ) ? "-" : "+" ; $ tz = abs ( $ tz ) ; $ tz = ( $ tz / 3600 ) * 100 + ( $ tz % 3600 ) / 60 ; $ result = sprintf ( "%s %s%04d" , date ( "D, j M Y H:i:s" ) , $ tzs , $ tz ) ; return $ result ; }
528	public function actionInfo ( ) { $ items = [ 'framework' , 'app-basic' , 'app-advanced' , ] ; $ extensionPath = "{$this->basePath}/extensions" ; foreach ( scandir ( $ extensionPath ) as $ extension ) { if ( ctype_alpha ( $ extension ) && is_dir ( $ extensionPath . '/' . $ extension ) ) { $ items [ ] = $ extension ; } } if ( $ this -> update ) { foreach ( $ items as $ item ) { $ this -> stdout ( "fetching tags for $item..." ) ; if ( $ item === 'framework' ) { $ this -> gitFetchTags ( ( string ) $ this -> basePath ) ; } elseif ( strncmp ( 'app-' , $ item , 4 ) === 0 ) { $ this -> gitFetchTags ( "{$this->basePath}/apps/" . substr ( $ item , 4 ) ) ; } else { $ this -> gitFetchTags ( "{$this->basePath}/extensions/$item" ) ; } $ this -> stdout ( "done.\n" , Console :: FG_GREEN , Console :: BOLD ) ; } } else { $ this -> stdout ( "\nInformation may be outdated, re-run with `--update` to fetch latest tags.\n\n" ) ; } $ versions = $ this -> getCurrentVersions ( $ items ) ; $ nextVersions = $ this -> getNextVersions ( $ versions , self :: PATCH ) ; $ w = $ this -> minWidth ( array_keys ( $ versions ) ) ; $ this -> stdout ( str_repeat ( ' ' , $ w + 2 ) . "Current Version Next Version\n" , Console :: BOLD ) ; foreach ( $ versions as $ ext => $ version ) { $ this -> stdout ( $ ext . str_repeat ( ' ' , $ w + 3 - mb_strlen ( $ ext ) ) . $ version . '' ) ; $ this -> stdout ( str_repeat ( ' ' , 17 - mb_strlen ( $ version ) ) . $ nextVersions [ $ ext ] . "\n" ) ; } }
8178	protected function sendMail ( $ to , $ subject , $ view , $ params = [ ] ) { $ mailer = Yii :: $ app -> mailer ; $ mailer -> viewPath = '@abhimanyu/user/views/mail' ; return $ mailer -> compose ( [ 'html' => $ view , 'text' => 'text/' . $ view ] , $ params ) -> setTo ( $ to ) -> setFrom ( Yii :: $ app -> config -> get ( 'mail.username' ) , 'no@reply.com' ) -> setSubject ( $ subject ) -> send ( ) ; }
8253	protected function handleAccountPage ( Request $ httpRequest ) { $ user = $ this -> picoAuth -> getUser ( ) ; if ( ! $ user -> getAuthenticated ( ) ) { $ this -> session -> addFlash ( "error" , "Login to access this page." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; return ; } if ( $ user -> getAuthenticator ( ) !== $ this -> getName ( ) ) { $ this -> picoAuth -> redirectToPage ( "index" ) ; return ; } $ editAccount = $ this -> picoAuth -> getContainer ( ) -> get ( 'EditAccount' ) ; $ editAccount -> setConfig ( $ this -> config ) -> handleAccountPage ( $ httpRequest ) ; }
9177	public function mapBoolean ( $ value ) { if ( isset ( $ this -> booleanMapping [ $ value ] ) ) { return $ this -> booleanMapping [ $ value ] ; } throw new \ Exception ( sprintf ( 'Can\'t convert %s to boolean' , $ value ) ) ; }
9563	protected function callHandler ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return $ handler -> handle ( $ exception ) ; } return call_user_func ( $ handler , $ exception ) ; }
8064	public function getFreeAndBusyWorkers ( ) { $ free = $ this -> getFreeWorkers ( ) ; return array ( 'free' => $ free , 'busy' => $ this -> workerPoolSize - $ free , 'total' => $ this -> workerPoolSize ) ; }
3503	private function prepareCurlResourceByRequest ( Request $ request ) : void { curl_setopt ( $ this -> resource , CURLOPT_URL , $ request -> getUrl ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_POSTFIELDS , $ request -> getContent ( ) ) ; if ( $ request -> getCertificate ( ) ) { curl_setopt ( $ this -> resource , CURLOPT_SSLCERT , $ request -> getCertificate ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_SSLCERTPASSWD , $ request -> getCertificatePassPhrase ( ) ) ; } $ inlineHeaders = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ inlineHeaders [ ] = sprintf ( '%s: %s' , $ name , $ value ) ; } curl_setopt ( $ this -> resource , CURLOPT_HTTPHEADER , $ inlineHeaders ) ; }
4457	public function detach ( string $ eventName , $ handler ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } if ( isset ( $ this -> events [ $ eventName ] ) == false ) { return ; } $ priorityQueue = $ this -> events [ $ eventName ] ; $ priorityQueue -> setExtractFlags ( SplPriorityQueue :: EXTR_BOTH ) ; $ priorityQueue -> top ( ) ; $ newPriorityQueue = $ this -> createQueue ( ) ; while ( $ priorityQueue -> valid ( ) ) { $ data = $ priorityQueue -> current ( ) ; $ priorityQueue -> next ( ) ; if ( $ data [ 'data' ] !== $ handler ) { $ newPriorityQueue -> insert ( $ data [ 'data' ] , $ data [ 'priority' ] ) ; } } $ this -> events [ $ eventName ] = $ newPriorityQueue ; }
3627	protected function getDeviceNetworkInfo ( $ serial_number = NULL ) { $ this -> prepareForGet ( ) ; $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ connection_info = $ this -> last_status -> track -> { $ serial_number } ; return ( object ) array ( 'online' => $ connection_info -> online , 'last_connection' => date ( DATETIME_FORMAT , $ connection_info -> last_connection / 1000 ) , 'last_connection_UTC' => gmdate ( DATETIME_FORMAT , $ connection_info -> last_connection / 1000 ) , 'wan_ip' => @ $ connection_info -> last_ip , 'local_ip' => $ this -> last_status -> device -> { $ serial_number } -> local_ip , 'mac_address' => $ this -> last_status -> device -> { $ serial_number } -> mac_address ) ; }
3315	public function set ( $ key , $ value ) { Arr :: set ( $ this -> configs , $ key , $ value ) ; return $ this ; }
10447	public function post ( Payload $ payload , $ endpoint ) { if ( ! Type :: isValidWebhookType ( $ payload -> getAction ( ) ) ) { throw new \ Exception ( sprintf ( 'Webhook "%s" isn\'t valid' , $ payload -> getAction ( ) ) ) ; } $ requestContent = [ 'headers' => [ 'Content-Type' => 'application/json' ] , 'body' => json_encode ( $ payload ) , 'timeout' => self :: DEFAULT_REQUEST_TIMEOUT ] ; return $ this -> guzzleClient -> post ( $ endpoint , $ requestContent ) ; }
10161	private function readPane ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ px = self :: getUInt2d ( $ recordData , 0 ) ; $ py = self :: getUInt2d ( $ recordData , 2 ) ; $ rwTop = self :: getUInt2d ( $ recordData , 4 ) ; $ colLeft = self :: getUInt2d ( $ recordData , 6 ) ; if ( $ this -> frozen ) { $ cell = Coordinate :: stringFromColumnIndex ( $ px + 1 ) . ( $ py + 1 ) ; $ topLeftCell = Coordinate :: stringFromColumnIndex ( $ colLeft + 1 ) . ( $ rwTop + 1 ) ; $ this -> phpSheet -> freezePane ( $ cell , $ topLeftCell ) ; } } }
8021	public function payload ( array $ payload ) { $ client = new GuzzleClient ( [ 'base_uri' => $ this -> server ] ) ; $ client -> request ( 'POST' , $ this -> getUri ( ) , [ 'form_params' => [ 'payload' => json_encode ( $ payload ) ] ] ) ; }
10713	public function saveMany ( ArrayAccess $ models ) { if ( ! $ models instanceof Collection ) { $ models = collect ( $ models ) ; } foreach ( $ models as $ model ) { $ this -> save ( $ model ) ; } return $ models ; }
5167	protected function filterDateInstance ( $ date ) : string { if ( empty ( $ date ) ) { $ date = new \ DateTime ( 'now' , new \ DateTimeZone ( 'Asia/Jakarta' ) ) ; } if ( is_string ( $ date ) || is_int ( $ date ) ) { $ date = new \ DateTime ( $ date , new \ DateTimeZone ( 'Asia/Jakarta' ) ) ; } return $ this -> formatDate ( $ date ) ; }
385	public function getOrders ( $ recalculate = false ) { $ attributeOrders = $ this -> getAttributeOrders ( $ recalculate ) ; $ orders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ direction ) { $ definition = $ this -> attributes [ $ attribute ] ; $ columns = $ definition [ $ direction === SORT_ASC ? 'asc' : 'desc' ] ; if ( is_array ( $ columns ) || $ columns instanceof \ Traversable ) { foreach ( $ columns as $ name => $ dir ) { $ orders [ $ name ] = $ dir ; } } else { $ orders [ ] = $ columns ; } } return $ orders ; }
4707	public function processMultipleUnderScore ( Text $ text ) { $ text -> replace ( '{<pre>.*?</pre>}m' , function ( Text $ w ) { $ md5 = md5 ( $ w ) ; $ this -> hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '/^(?! {4}|\t)(\[?\w+_\w+_\w[\w_]*\]?)/' , function ( Text $ w , Text $ word ) { $ underscores = $ word -> split ( '//' ) -> filter ( function ( Text $ item ) { return $ item == '_' ; } ) ; if ( count ( $ underscores ) >= 2 ) { $ word -> replaceString ( '_' , '\\_' ) ; } return $ word ; } ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) { return "\n\n" . $ this -> hashes [ ( string ) $ md5 ] ; } ) ; }
10707	public function applyCriteria ( $ criteria ) { $ query = $ this -> getQuery ( ) ; if ( $ criteria instanceof Criteria ) { $ criteria -> apply ( $ query ) ; return $ this ; } if ( $ criteria instanceof Closure ) { $ criteria ( $ query ) ; return $ this ; } throw new RepositoryException ( "Must be an instance of " . Criteria :: class . " or \\Closure" ) ; }
6324	public function start ( ) { if ( ! isset ( $ this -> _dir ) ) { return false ; } $ this -> _page = $ this -> url ; $ this -> _file = $ this -> _dir . md5 ( $ this -> _page ) . '.' . $ this -> _ext ; $ ignore_page = false ; for ( $ i = 0 ; $ i < count ( $ this -> _ignoreList ) ; $ i ++ ) { $ ignore_page = ( strpos ( $ this -> _page , $ this -> _ignoreList [ $ i ] ) !== false ) ? true : $ ignore_page ; } $ cachefile_created = ( file_exists ( $ this -> _file ) && ( $ ignore_page === false ) ) ? filemtime ( $ this -> _file ) : 0 ; clearstatcache ( ) ; if ( time ( ) - $ this -> _time < $ cachefile_created ) { ob_start ( 'ob_gzhandler' ) ; readfile ( $ this -> _file ) ; ob_end_flush ( ) ; exit ( ) ; } ob_start ( 'ob_gzhandler' ) ; }
4135	public static function decryptWithAppendedTag ( $ K , $ IV , $ Ciphertext = null , $ A = null , $ tag_length = 128 ) { $ tag_length_in_bits = $ tag_length / 8 ; $ C = mb_substr ( $ Ciphertext , 0 , - $ tag_length_in_bits , '8bit' ) ; $ T = mb_substr ( $ Ciphertext , - $ tag_length_in_bits , null , '8bit' ) ; return self :: decrypt ( $ K , $ IV , $ C , $ A , $ T ) ; }
12309	public function resetPasswordAction ( ) { if ( $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getDefaultUserRoute ( ) ) ; } if ( $ token = $ this -> params ( ) -> fromRoute ( 'token' ) ) { $ identity = $ this -> getUserService ( ) -> confirmPasswordReset ( $ token ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-success' ) ; return $ viewModel ; } return $ this -> redirect ( ) -> toRoute ( ) ; } $ url = $ this -> url ( ) -> fromRoute ( ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getResetPasswordForm ( ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ identity = $ this -> getUserService ( ) -> resetPassword ( $ form -> get ( 'identity' ) -> getValue ( ) ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-warning' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
10150	private function readHeader ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { if ( $ recordData ) { if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( $ recordData ) ; } else { $ string = $ this -> readByteStringShort ( $ recordData ) ; } $ this -> phpSheet -> getHeaderFooter ( ) -> setOddHeader ( $ string [ 'value' ] ) ; $ this -> phpSheet -> getHeaderFooter ( ) -> setEvenHeader ( $ string [ 'value' ] ) ; } } }
2533	protected function loadInventory ( $ inventory ) { if ( is_array ( $ inventory ) && count ( $ inventory ) > 0 ) { $ this -> inventory = new Inventory ( ) ; foreach ( $ inventory as $ bookingClass => $ availabilityAmount ) { $ this -> inventory -> bookingClassDetails [ ] = new BookingClassDetails ( $ bookingClass , $ availabilityAmount ) ; } } }
6172	public function setConfig ( $ host , $ name = 'schema' , DriverInterface $ driver = null ) { $ this -> driver = \ is_null ( $ driver ) ? new Driver \ Json ( ) : $ driver ; $ this -> path = $ host ; $ this -> name = $ name ; $ this -> file = $ host . DIRECTORY_SEPARATOR . $ name . '.' . $ this -> driver -> getExtension ( ) ; return $ this ; }
1350	public function none ( string ... $ resourceTypes ) : self { foreach ( $ resourceTypes as $ resourceType ) { $ this -> allow ( $ resourceType , [ ] ) ; } return $ this ; }
3646	public function clean ( $ value , bool $ trim = true , bool $ clean = true ) { if ( is_bool ( $ value ) || is_int ( $ value ) || is_float ( $ value ) ) { return $ value ; } $ final = null ; if ( $ value !== null ) { if ( is_array ( $ value ) ) { $ all = $ value ; $ final = [ ] ; foreach ( $ all as $ key => $ value ) { if ( $ value !== null ) { $ final [ $ key ] = $ this -> clean ( $ value , $ trim , $ clean ) ; } } } else { if ( $ value !== null ) { $ final = $ this -> process ( ( string ) $ value , $ trim , $ clean ) ; } } } return $ final ; }
12185	public function getNiceId ( $ queryRole ) { $ roleType = $ this -> roleType ( $ queryRole ) ; if ( empty ( $ roleType ) ) { return false ; } return implode ( ':' , [ $ this -> role ( $ queryRole ) , $ roleType -> systemId ] ) ; }
8935	public function add ( $ name , $ template ) { if ( array_key_exists ( $ name , $ this -> templates ) ) { throw new \ InvalidArgumentException ( 'Template already exists.' ) ; } $ this -> templates [ $ name ] = $ template ; }
1884	public static function count ( array $ arrOptions ) { $ strQuery = "SELECT COUNT(*) AS count FROM " . $ arrOptions [ 'table' ] ; if ( $ arrOptions [ 'column' ] !== null ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } return $ strQuery ; }
10621	public static function percentage ( $ value , $ from ) { $ value = floatval ( $ value ) ; $ from = floatval ( $ from ) ; return floatval ( $ value / $ from * 100 ) ; }
10368	public function recover ( RecoverRequest $ request ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'recover' ) ) -> dispatchFrom ( RecoverJob :: class , $ request ) ; return back ( ) -> withSuccess ( trans ( 'auth::recover.success' ) ) ; }
3776	public function run ( ) { $ template = new BackendTemplate ( 'be_dcastylepicker' ) ; $ template -> main = '' ; $ template -> headline = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodelspicker' ] ; $ inputName = Input :: get ( 'inputName' ) ; if ( ! preg_match ( '~^[a-z\-_0-9]+$~i' , $ inputName ) ) { throw new RuntimeException ( 'Field-Parameter ERROR!' ) ; } $ template -> field = $ inputName ; $ template -> items = $ GLOBALS [ Input :: get ( 'item' ) ] ; if ( ! strlen ( $ template -> headline ) ) { $ template -> headline = $ GLOBALS [ 'TL_CONFIG' ] [ 'websiteTitle' ] ; } $ template -> theme = Backend :: getTheme ( ) ; $ template -> base = Environment :: get ( 'base' ) ; $ template -> language = $ GLOBALS [ 'TL_LANGUAGE' ] ; $ template -> title = $ GLOBALS [ 'TL_CONFIG' ] [ 'websiteTitle' ] ; $ template -> charset = $ GLOBALS [ 'TL_CONFIG' ] [ 'characterSet' ] ; $ template -> pageOffset = Input :: cookie ( 'BE_PAGE_OFFSET' ) ; $ template -> error = ( Input :: get ( 'act' ) == 'error' ) ? $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] : '' ; $ template -> skipNavigation = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'skipNavigation' ] ; $ template -> request = ampersand ( Environment :: get ( 'request' ) ) ; $ template -> top = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'backToTop' ] ; $ template -> be27 = ! $ GLOBALS [ 'TL_CONFIG' ] [ 'oldBeTheme' ] ; $ template -> expandNode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] ; $ template -> collapseNode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] ; $ template -> strField = Input :: get ( 'fld' ) ; $ template -> output ( ) ; }
246	public function fixPrimaryKey ( $ keys ) { $ keys = ( array ) $ keys ; $ this -> primaryKey = $ keys ; foreach ( $ this -> columns as $ column ) { $ column -> isPrimaryKey = false ; } foreach ( $ keys as $ key ) { if ( isset ( $ this -> columns [ $ key ] ) ) { $ this -> columns [ $ key ] -> isPrimaryKey = true ; } else { throw new InvalidArgumentException ( "Primary key '$key' cannot be found in table '{$this->name}'." ) ; } } }
9655	public function override ( $ name , array $ routeData ) { if ( ! isset ( $ this -> routes [ $ name ] ) ) { throw new \ InvalidArgumentException ( "No route for name $name defined" ) ; } $ this -> routes [ $ name ] = $ routeData + $ this -> routes [ $ name ] ; }
7721	public function actionIndex ( ) { $ searchModel = new MahasiswaSearch ( ) ; $ dataProvider = $ searchModel -> search ( Yii :: $ app -> request -> queryParams ) ; $ field = [ 'fileImport' => 'File Import' , ] ; $ modelImport = DynamicModel :: validateData ( $ field , [ [ [ 'fileImport' ] , 'required' ] , [ [ 'fileImport' ] , 'file' , 'extensions' => 'xls,xlsx' , 'maxSize' => 1024 * 1024 ] , ] ) ; return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , 'modelImport' => $ modelImport , ] ) ; }
5181	private function appendToArray ( string $ key , $ value ) : self { $ this -> props [ $ key ] = [ $ this -> props [ $ key ] , $ value ] ; return $ this ; }
691	protected function isActive ( $ action ) { $ id = $ this -> getActionId ( $ action ) ; if ( empty ( $ this -> only ) ) { $ onlyMatch = true ; } else { $ onlyMatch = false ; foreach ( $ this -> only as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ onlyMatch = true ; break ; } } } $ exceptMatch = false ; foreach ( $ this -> except as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ exceptMatch = true ; break ; } } return ! $ exceptMatch && $ onlyMatch ; }
9784	public function parseHTML ( ) { $ token = $ this -> pop ( 'HTML' ) ; $ value = $ this -> stripQuotes ( $ token [ 1 ] ) ; $ this -> currLine += substr_count ( $ value , "\n" ) ; return '$output .= \'' . $ value . "';\n" ; }
3425	public function getById ( $ id ) { if ( ! $ id || $ this -> queryShouldBeStopped ) { return false ; } $ this -> sort = [ ] ; $ this -> filter [ 'ID' ] = $ id ; return $ this -> getList ( ) -> first ( null , false ) ; }
1457	protected function next ( Cursor $ cursor , $ columns ) { if ( $ cursor -> isAfter ( ) ) { $ this -> whereId ( $ cursor -> getAfter ( ) , $ this -> descending ? '<' : '>' ) ; } $ items = $ this -> orderForNext ( ) -> get ( $ cursor -> getLimit ( ) + 1 , $ columns ) ; $ more = $ items -> count ( ) > $ cursor -> getLimit ( ) ; return new CursorPaginator ( $ items -> slice ( 0 , $ cursor -> getLimit ( ) ) , $ more , $ cursor , $ this -> key ) ; }
11203	public function max ( $ key = false ) { $ collection = $ this -> getIterator ( ) ; $ max = 0 ; $ valueToReturn = 0 ; foreach ( $ collection as $ result ) { if ( $ key && isset ( $ result -> $ key ) ) { if ( $ result -> $ key > $ max ) { $ max = $ result -> $ key ; $ valueToReturn = $ result ; } } else if ( $ key && isset ( $ result [ $ key ] ) ) { if ( $ result [ $ key ] > $ max ) { $ max = $ result [ $ key ] ; $ valueToReturn = $ result ; } } else { if ( $ result > $ max ) { $ max = $ result ; $ valueToReturn = $ result ; } } } return $ valueToReturn ; }
278	private function notifyUnloaded ( $ fixtures ) { $ this -> stdout ( "\nFixtures were successfully unloaded from namespace: " , Console :: FG_YELLOW ) ; $ this -> stdout ( Yii :: getAlias ( $ this -> namespace ) . "\"\n\n" , Console :: FG_GREEN ) ; $ this -> outputList ( $ fixtures ) ; }
8698	public function attr ( $ attrKey , $ attrValue = null ) { if ( ! is_null ( $ attrValue ) ) { if ( ! is_array ( $ this -> attributes ) ) { $ this -> attributes = array ( ) ; } $ this -> attributes [ $ attrKey ] = $ attrValue ; return $ this ; } else { if ( array_key_exists ( $ attrKey , $ this -> attributes ) ) { return $ this -> attributes [ $ attrKey ] ; } else { return null ; } } }
2354	public function getResponse ( $ objPage ) { if ( $ objPage -> redirectBack ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ this -> getReferer ( ) ; } $ strLogoutUrl = System :: getContainer ( ) -> get ( 'security.logout_url_generator' ) -> getLogoutUrl ( ) ; $ strRedirect = Environment :: get ( 'base' ) ; if ( $ objPage -> redirectBack && ! empty ( $ _SESSION [ 'LAST_PAGE_VISITED' ] ) ) { $ strRedirect = $ _SESSION [ 'LAST_PAGE_VISITED' ] ; } elseif ( ( $ objTarget = $ objPage -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ strRedirect = $ objTarget -> getAbsoluteUrl ( ) ; } $ uri = Http :: createFromString ( $ strLogoutUrl ) ; $ query = new Query ( $ uri -> getQuery ( ) ) ; $ query = $ query -> merge ( 'redirect=' . $ strRedirect ) ; return new RedirectResponse ( ( string ) $ uri -> withQuery ( ( string ) $ query ) ) ; }
10106	private function writeDefcol ( ) { $ defaultColWidth = 8 ; $ record = 0x0055 ; $ length = 0x0002 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ defaultColWidth ) ; $ this -> append ( $ header . $ data ) ; }
9428	public function updateCMSFields ( FieldList $ fields ) { $ fields -> insertAfter ( Tab :: create ( 'Icon' , $ this -> owner -> fieldLabel ( 'Icon' ) ) , 'Main' ) ; $ fields -> addFieldsToTab ( 'Root.Icon' , [ FontIconField :: create ( 'FontIcon' , $ this -> owner -> fieldLabel ( 'FontIcon' ) ) , ColorField :: create ( 'FontIconColor' , $ this -> owner -> fieldLabel ( 'FontIconColor' ) ) ] ) ; }
229	public function getPdoType ( $ data ) { static $ typeMap = [ 'boolean' => \ PDO :: PARAM_BOOL , 'integer' => \ PDO :: PARAM_INT , 'string' => \ PDO :: PARAM_STR , 'resource' => \ PDO :: PARAM_LOB , 'NULL' => \ PDO :: PARAM_NULL , ] ; $ type = gettype ( $ data ) ; return isset ( $ typeMap [ $ type ] ) ? $ typeMap [ $ type ] : \ PDO :: PARAM_STR ; }
12582	public function setTranslator ( $ translator , $ translatorDomain = null , $ translatorLocale = null ) { $ this -> translator = $ translator ; $ this -> setTranslatorDomain ( $ translatorDomain ) ; $ this -> setTranslatorLocale ( $ translatorLocale ) ; $ this -> setCaption ( $ this -> translate ( $ this -> getCaption ( ) ) ) ; }
199	public function redirect ( $ url , $ statusCode = 302 , $ checkAjax = true ) { if ( is_array ( $ url ) && isset ( $ url [ 0 ] ) ) { $ url [ 0 ] = '/' . ltrim ( $ url [ 0 ] , '/' ) ; } $ url = Url :: to ( $ url ) ; if ( strncmp ( $ url , '/' , 1 ) === 0 && strncmp ( $ url , '//' , 2 ) !== 0 ) { $ url = Yii :: $ app -> getRequest ( ) -> getHostInfo ( ) . $ url ; } if ( $ checkAjax ) { if ( Yii :: $ app -> getRequest ( ) -> getIsAjax ( ) ) { if ( Yii :: $ app -> getRequest ( ) -> getHeaders ( ) -> get ( 'X-Ie-Redirect-Compatibility' ) !== null && $ statusCode === 302 ) { $ statusCode = 200 ; } if ( Yii :: $ app -> getRequest ( ) -> getIsPjax ( ) ) { $ this -> getHeaders ( ) -> set ( 'X-Pjax-Url' , $ url ) ; } else { $ this -> getHeaders ( ) -> set ( 'X-Redirect' , $ url ) ; } } else { $ this -> getHeaders ( ) -> set ( 'Location' , $ url ) ; } } else { $ this -> getHeaders ( ) -> set ( 'Location' , $ url ) ; } $ this -> setStatusCode ( $ statusCode ) ; return $ this ; }
4071	public function getJavascripts ( GetOptionsEvent $ event ) { if ( ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_rendersettings' ) || ( $ event -> getPropertyName ( ) !== 'additionalJs' ) || ( $ event -> getSubPropertyName ( ) !== 'file' ) ) { return ; } $ event -> setOptions ( $ this -> scanFiles ( 'js' ) ) ; }
5513	public function expectMinimumCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set minimum call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_counts [ strtolower ( $ method ) ] = new MinimumCallCountExpectation ( $ method , $ count , $ message ) ; }
10740	private function _init ( $ params ) { if ( NULL !== $ params && 0 < count ( $ params ) ) { foreach ( $ params as $ key => $ value ) { $ this -> _params [ ] = $ value ; } } }
6688	public function isPostCheck ( $ redirectUrl = null ) { if ( $ this -> getRequest ( ) -> isPost ) { return true ; } if ( is_null ( $ redirectUrl ) ) { return false ; } $ this -> sendTerminalResponse ( $ redirectUrl ) ; }
12374	public function run ( ) : void { if ( ! $ this -> isRan ) { $ this -> isRan = true ; foreach ( $ this -> items as $ item ) { $ options = $ item [ 2 ] ?? [ ] ; $ ruleName = $ item [ 1 ] ; foreach ( is_array ( $ item [ 0 ] ) ? $ item [ 0 ] : [ $ item [ 0 ] ] as $ fieldName ) { self :: applyRuleToField ( $ fieldName , $ ruleName , $ options ) ; } } } }
3294	protected function buildLink ( $ provider , $ url ) { $ fontAwesomeVersion = config ( 'laravel-share.fontAwesomeVersion' , 4 ) ; $ this -> html .= trans ( "laravel-share::laravel-share-fa$fontAwesomeVersion.$provider" , [ 'url' => $ url , 'class' => key_exists ( 'class' , $ this -> options ) ? $ this -> options [ 'class' ] : '' , 'id' => key_exists ( 'id' , $ this -> options ) ? $ this -> options [ 'id' ] : '' , ] ) ; }
9787	public function parseFilteredValue ( ) { list ( $ type , $ filters ) = $ this -> pop ( 'FILTERED_VALUE' ) ; $ value = array_shift ( $ filters ) ; $ opening = '' ; $ closing = '' ; foreach ( $ filters as $ filter ) { if ( function_exists ( $ filter ) ) { $ opening .= $ filter . '(' ; $ closing .= ')' ; } else { $ opening .= '\Katar\Katar::getInstance()->filter(\'' . $ filter . '\', ' ; $ closing .= ')' ; } } return '$output .= ' . $ opening . $ value . $ closing . ";\n" ; }
9925	private function handleCollections ( Parameters $ params , array $ permitted = array ( ) ) { if ( empty ( $ permitted ) ) { return ; } $ keys = $ params -> keys ( ) ; $ intKeys = $ keys -> select ( function ( $ value ) { return is_int ( $ value ) ; } ) ; if ( $ keys -> count ( ) === $ intKeys -> count ( ) ) { foreach ( $ keys as $ key ) { $ value = $ params [ $ key ] ; if ( $ value instanceof Parameters ) { $ this -> filter ( $ value , $ permitted ) ; } } } }
5265	public function getNotCachedAttributes ( $ key , array $ attributes = [ '*' ] ) { if ( ! $ this -> has ( $ key ) ) { return $ attributes ; } $ cachedAttributes = $ this -> cache [ $ key ] [ 'attributes' ] ; return $ cachedAttributes == [ '*' ] ? [ ] : array_diff ( $ attributes , $ cachedAttributes ) ; }
8956	public function waysForNode ( $ id ) { $ base = 'node/' . $ id . '/ways' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> way ; }
2061	public function generateAlias ( $ varValue , Contao \ DataContainer $ dc ) { $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> id ) ; $ aliasExists = function ( string $ alias ) use ( $ dc , $ objPage ) : bool { $ objAliasIds = $ this -> Database -> prepare ( "SELECT id FROM tl_page WHERE alias=? AND id!=?" ) -> execute ( $ alias , $ dc -> id ) ; if ( ! $ objAliasIds -> numRows ) { return false ; } $ strCurrentDomain = $ objPage -> domain ; $ strCurrentLanguage = $ objPage -> rootLanguage ; if ( $ objPage -> type == 'root' ) { $ strCurrentDomain = Contao \ Input :: post ( 'dns' ) ; $ strCurrentLanguage = Contao \ Input :: post ( 'language' ) ; } while ( $ objAliasIds -> next ( ) ) { $ objAliasPage = Contao \ PageModel :: findWithDetails ( $ objAliasIds -> id ) ; if ( $ objAliasPage -> domain != $ strCurrentDomain ) { continue ; } if ( Contao \ Config :: get ( 'addLanguageToUrl' ) && $ objAliasPage -> rootLanguage != $ strCurrentLanguage ) { continue ; } return true ; } return false ; } ; if ( $ varValue == '' ) { $ varValue = Contao \ System :: getContainer ( ) -> get ( 'contao.slug' ) -> generate ( $ dc -> activeRecord -> title , $ dc -> activeRecord -> id , function ( $ alias ) use ( $ objPage , $ aliasExists ) { return $ aliasExists ( ( Contao \ Config :: get ( 'folderUrl' ) ? $ objPage -> folderUrl : '' ) . $ alias ) ; } ) ; if ( Contao \ Config :: get ( 'folderUrl' ) && $ objPage -> folderUrl != '' ) { $ varValue = $ objPage -> folderUrl . $ varValue ; } } elseif ( $ aliasExists ( $ varValue ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
8863	public function getHTMLFragments ( $ gridField ) { $ dataClass = $ gridField -> getList ( ) -> dataClass ( ) ; $ obj = singleton ( $ dataClass ) ; if ( ! $ obj -> canCreate ( ) ) return "" ; $ dbField = $ this -> getDataObjectField ( ) ; $ textField = TextField :: create ( "gridfieldaddbydbfield[" . $ obj -> ClassName . "][" . Convert :: raw2htmlatt ( $ dbField ) . "]" ) -> setAttribute ( "placeholder" , $ obj -> fieldLabel ( $ dbField ) ) -> addExtraClass ( "no-change-track" ) ; $ addAction = new GridField_FormAction ( $ gridField , 'add' , _t ( 'GridFieldAddByDBField.Add' , "Add {name}" , "Add button text" , array ( "name" => $ obj -> i18n_singular_name ( ) ) ) , 'add' , 'add' ) ; $ addAction -> setAttribute ( 'data-icon' , 'add' ) ; $ forTemplate = new ArrayData ( array ( ) ) ; $ forTemplate -> Fields = new ArrayList ( ) ; $ forTemplate -> Fields -> push ( $ textField ) ; $ forTemplate -> Fields -> push ( $ addAction ) ; return array ( $ this -> targetFragment => $ forTemplate -> renderWith ( "GridFieldAddByDBField" ) ) ; }
500	protected function readString ( $ fileHandle , $ length , $ offset = null ) { if ( $ offset !== null ) { fseek ( $ fileHandle , $ offset ) ; } return $ this -> readBytes ( $ fileHandle , $ length ) ; }
6362	public function convert ( float $ duration , TimeUnit $ timeUnit ) : float { return $ duration * ( $ timeUnit -> inMicros / $ this -> inMicros ) ; }
8735	public function decrement ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> decrement ( $ column , $ amount , $ extra ) ; }
10187	protected static function buildAuthorizationHeader ( string $ method , string $ token , string $ password = null ) { switch ( $ method ) { case Client :: AUTH_HTTP_PASSWORD : return 'Basic ' . base64_encode ( "$token:$password" ) ; case Client :: AUTH_OAUTH_TOKEN : return "Bearer $token" ; } throw new RuntimeException ( sprintf ( 'Authentication method "%s" not implemented.' , $ method ) ) ; }
5407	public function getCookieValue ( $ host , $ path , $ name ) { $ longest_path = '' ; foreach ( $ this -> cookies as $ cookie ) { if ( $ this -> isMatch ( $ cookie , $ host , $ path , $ name ) ) { if ( strlen ( $ cookie -> getPath ( ) ) > strlen ( $ longest_path ) ) { $ value = $ cookie -> getValue ( ) ; $ longest_path = $ cookie -> getPath ( ) ; } } } return ( isset ( $ value ) ? $ value : false ) ; }
5919	public function setCreated ( $ created ) { if ( $ created instanceof DateTime ) { $ this -> created = $ created ; } else { try { $ this -> created = new DateTime ( $ created ) ; } catch ( \ Exception $ e ) { $ this -> created = null ; } } return $ this ; }
12622	public function register ( $ event , $ obj , $ methodName ) { $ this -> events += [ $ event => [ ] ] ; $ this -> events [ $ event ] [ ] = [ 'object' => $ obj , 'methodName' => $ methodName , ] ; }
7007	private function format_j ( & $ str ) { if ( strstr ( $ str , '%j' ) ) $ str = str_replace ( '%j' , sprintf ( '%01d' , $ this -> day ) , $ str ) ; }
11207	public function getIterator ( ) { if ( ! $ this -> content || $ this -> contentModified ) { $ this -> generateContent ( ) ; } return new \ ArrayIterator ( $ this -> content ) ; }
4117	public function isWithinCachedBlock ( Mage_Core_Block_Abstract $ block ) { $ step = $ block ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { if ( ! is_null ( $ step -> getCacheLifetime ( ) ) ) { return true ; } $ step = $ step -> getParentBlock ( ) ; } return false ; }
9218	protected function pageNumberToKey ( $ pageNumber ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { return ( $ pageNumber - 1 ) * $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getPerPage ( ) ; } return false ; }
4039	protected function getClassForOption ( $ index ) { $ intSub = ( $ this -> arrConfiguration [ 'includeBlankOption' ] ? - 1 : 1 ) ; $ strClass = $ this -> strName ; if ( $ index == 0 ) { $ strClass .= ' first' ; } elseif ( $ index === ( count ( $ this -> options ) - $ intSub ) ) { $ strClass .= ' last' ; } if ( ( $ index % 2 ) == 1 ) { $ strClass .= ' even' ; } else { $ strClass .= ' odd' ; } return ( ( strlen ( $ this -> strClass ) ) ? ' ' . $ this -> strClass : '' ) . $ strClass ; }
196	public function sendStreamAsFile ( $ handle , $ attachmentName , $ options = [ ] ) { $ headers = $ this -> getHeaders ( ) ; if ( isset ( $ options [ 'fileSize' ] ) ) { $ fileSize = $ options [ 'fileSize' ] ; } else { fseek ( $ handle , 0 , SEEK_END ) ; $ fileSize = ftell ( $ handle ) ; } $ range = $ this -> getHttpRange ( $ fileSize ) ; if ( $ range === false ) { $ headers -> set ( 'Content-Range' , "bytes */$fileSize" ) ; throw new RangeNotSatisfiableHttpException ( ) ; } list ( $ begin , $ end ) = $ range ; if ( $ begin != 0 || $ end != $ fileSize - 1 ) { $ this -> setStatusCode ( 206 ) ; $ headers -> set ( 'Content-Range' , "bytes $begin-$end/$fileSize" ) ; } else { $ this -> setStatusCode ( 200 ) ; } $ mimeType = isset ( $ options [ 'mimeType' ] ) ? $ options [ 'mimeType' ] : 'application/octet-stream' ; $ this -> setDownloadHeaders ( $ attachmentName , $ mimeType , ! empty ( $ options [ 'inline' ] ) , $ end - $ begin + 1 ) ; $ this -> format = self :: FORMAT_RAW ; $ this -> stream = [ $ handle , $ begin , $ end ] ; return $ this ; }
10209	private function performRequest ( $ curlSession , $ deserializationType = null ) { $ response = curl_exec ( $ curlSession ) ; $ response = $ response ? $ response : null ; try { $ result = new MaileonAPIResult ( $ response , $ curlSession , $ this -> throwException , $ deserializationType ) ; $ this -> printDebugInformation ( $ curlSession , $ result ) ; curl_close ( $ curlSession ) ; return $ result ; } catch ( MaileonAPIException $ e ) { if ( $ this -> debug ) { $ this -> printDebugInformation ( $ curlSession , null , $ this -> throwException ? null : $ e ) ; } curl_close ( $ curlSession ) ; if ( $ this -> throwException ) { throw $ e ; } return null ; } }
8423	public function mappings ( Request $ request ) { $ table = new \ cli \ Table ( ) ; $ table -> setHeaders ( [ 'Mapping' , 'Database' , 'Models path' ] ) ; $ rows = [ ] ; $ mappings = Mapping :: getMappings ( ) ; usort ( $ mappings , function ( array $ a , array $ b ) { return strcmp ( $ a [ 'config' ] [ 'name' ] , $ b [ 'config' ] [ 'name' ] ) ; } ) ; foreach ( $ mappings as $ mapping ) { $ rows [ ] = [ $ mapping [ 'config' ] [ 'name' ] , $ mapping [ 'config' ] [ 'database' ] , $ mapping [ 'config' ] [ 'models' ] [ 'path' ] , ] ; } $ table -> setRows ( $ rows ) ; $ table -> display ( ) ; }
3648	protected function registerBinput ( ) { $ this -> app -> singleton ( 'binput' , function ( Container $ app ) { $ request = $ app [ 'request' ] ; $ security = $ app [ 'security' ] ; $ binput = new Binput ( $ request , $ security ) ; $ app -> refresh ( 'request' , $ binput , 'setRequest' ) ; return $ binput ; } ) ; $ this -> app -> alias ( 'binput' , Binput :: class ) ; }
315	public function setVendorPath ( $ path ) { $ this -> _vendorPath = Yii :: getAlias ( $ path ) ; Yii :: setAlias ( '@vendor' , $ this -> _vendorPath ) ; Yii :: setAlias ( '@bower' , $ this -> _vendorPath . DIRECTORY_SEPARATOR . 'bower' ) ; Yii :: setAlias ( '@npm' , $ this -> _vendorPath . DIRECTORY_SEPARATOR . 'npm' ) ; }
2166	public static function convertOrderField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field LIKE '%,%'" ) ; while ( $ objRow -> next ( ) ) { $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( serialize ( explode ( ',' , $ objRow -> $ field ) ) , $ objRow -> id ) ; } static :: convertMultiField ( $ table , $ field ) ; }
5414	public function getRequestLine ( $ method ) { $ url = $ this -> getUrl ( ) ; $ scheme = $ url -> getScheme ( ) ? $ url -> getScheme ( ) : 'http' ; $ port = $ url -> getPort ( ) ? ':' . $ url -> getPort ( ) : '' ; return $ method . ' ' . $ scheme . '://' . $ url -> getHost ( ) . $ port . $ url -> getPath ( ) . $ url -> getEncodedRequest ( ) . ' HTTP/1.0' ; }
4719	public function processBlockTags ( Tag $ tag ) { if ( $ tag -> isInline ( ) ) { return ; } $ text = null ; $ tag -> getText ( ) -> replace ( '/(^{([^:\(\)]+)}[ \t]*\n?|(?:[ \t]*|\n?){([^:\(\)]+)}\n*$)/' , function ( Text $ w ) use ( & $ text ) { $ text = $ w -> trim ( ) -> trim ( '{}' ) ; return '' ; } ) ; if ( $ text ) { $ tag -> setAttributes ( $ this -> parseAttributes ( $ text ) ) ; } }
11849	protected function getSettingsFromRealSource ( $ namespace ) { $ arraySettings = $ this -> getSettingsArray ( $ namespace ) ; $ namespaceOptions = $ this -> options -> getNamespaceOptions ( $ namespace ) ; $ entity = clone ( $ namespaceOptions -> getEntityPrototype ( ) ) ; if ( ! empty ( $ arraySettings ) ) { $ hydrator = $ this -> namespaceHydratorProvider -> getHydrator ( $ namespace ) ; $ entity = $ hydrator -> hydrate ( $ arraySettings , $ entity ) ; } return $ entity ; }
8210	protected function parseConnection ( $ connectionName ) { $ connection = null ; if ( $ connectionName ) { if ( ! $ connection = config ( "queue.connections.$connectionName" ) ) { throw new \ InvalidArgumentException ( "Connection '$connectionName' doesn't exist." ) ; } } if ( ! $ connection ) { $ defaultConnection = config ( 'queue.default' ) ; if ( 'beanstalkd' == config ( "queue.connections.$defaultConnection.driver" ) ) { $ connection = config ( "queue.connections.$defaultConnection" ) ; } } if ( ! $ connection ) { foreach ( config ( 'queue.connections' ) as $ connection ) { if ( 'beanstalkd' == $ connection [ 'driver' ] ) { break ; } } } if ( ! empty ( $ connection [ 'host' ] ) ) { $ parsedConfigHost = explode ( ':' , $ connection [ 'host' ] ) ; $ this -> host = $ parsedConfigHost [ 0 ] ; if ( isset ( $ parsedConfigHost [ 1 ] ) ) { $ this -> port = $ parsedConfigHost [ 1 ] ; } } if ( ! empty ( $ connection [ 'queue' ] ) ) { $ this -> defaultTube = $ connection [ 'queue' ] ; } }
4671	public function addBlockToBody ( $ block ) { $ this -> body = array_merge ( $ this -> body , explode ( PHP_EOL , $ block ) ) ; }
2568	protected function checkAllIntegers ( ) { $ foundNonInt = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! is_int ( $ arg ) ) { $ foundNonInt = true ; break ; } } return ! $ foundNonInt ; }
2653	public function updateSnippet ( array $ snippet ) { $ url = $ this -> _getApiServiceUri ( ) . 'snippet' . '/' . $ snippet [ 'name' ] ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ snippet ) ; return $ result ; }
896	private function findComparisonStart ( Tokens $ tokens , $ index ) { -- $ index ; $ nonBlockFound = false ; while ( 0 <= $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { -- $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { -- $ index ; $ nonBlockFound = true ; continue ; } if ( $ block [ 'isStart' ] || ( $ nonBlockFound && Tokens :: BLOCK_TYPE_CURLY_BRACE === $ block [ 'type' ] ) ) { break ; } $ index = $ tokens -> findBlockStart ( $ block [ 'type' ] , $ index ) - 1 ; } return $ tokens -> getNextMeaningfulToken ( $ index ) ; }
4312	public function setErrorCaller ( $ caller = null ) { if ( $ caller === null ) { $ caller = $ this -> utilities -> getCallerInfo ( 1 ) ; $ caller = array ( 'file' => $ caller [ 'file' ] , 'line' => $ caller [ 'line' ] , ) ; } if ( $ caller ) { $ caller [ 'groupDepth' ] = $ this -> getGroupDepth ( ) ; } $ this -> errorHandler -> setErrorCaller ( $ caller ) ; }
12858	public function onPageSaved ( PageSavedEvent $ event ) { $ blocks = $ event -> getApprovedBlocks ( ) ; foreach ( $ blocks as $ blockk ) { foreach ( $ blockk as $ block ) { $ this -> pageProductionRenderer -> renderBlock ( json_encode ( $ block ) ) ; } } $ mediaFiles = array_unique ( $ this -> pageProductionRenderer -> getMediaFiles ( ) ) ; $ webDir = $ this -> configurationHandler -> webDir ( ) ; $ fs = new Filesystem ( ) ; foreach ( $ mediaFiles as $ mediaFile ) { $ targetMediaFile = str_replace ( '/backend/' , '/production/' , $ mediaFile ) ; $ fs -> copy ( $ webDir . $ mediaFile , $ webDir . $ targetMediaFile ) ; } }
1972	public static function findByPath ( $ path , array $ arrOptions = array ( ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ path , $ rootDir . '/' , \ strlen ( $ rootDir ) + 1 ) === 0 ) { $ path = substr ( $ path , \ strlen ( $ rootDir ) + 1 ) ; } return static :: findOneBy ( 'path' , $ path , $ arrOptions ) ; }
4796	protected function execute ( ) { if ( ! isset ( $ this -> rows ) ) { $ result = false ; $ exception = null ; $ parameters = array ( ) ; foreach ( array_merge ( $ this -> select , array ( $ this , $ this -> group , $ this -> having ) , $ this -> order , $ this -> unionOrder ) as $ val ) { if ( ( $ val instanceof NotORM_Literal || $ val instanceof self ) && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } try { $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } catch ( PDOException $ exception ) { } if ( ! $ result ) { if ( ! $ this -> select && $ this -> accessed ) { $ this -> accessed = '' ; $ this -> access = array ( ) ; $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } elseif ( $ exception ) { throw $ exception ; } } $ this -> rows = array ( ) ; if ( $ result ) { $ result -> setFetchMode ( PDO :: FETCH_ASSOC ) ; foreach ( $ result as $ key => $ row ) { if ( isset ( $ row [ $ this -> primary ] ) ) { $ key = $ row [ $ this -> primary ] ; if ( ! is_string ( $ this -> access ) ) { $ this -> access [ $ this -> primary ] = true ; } } if ( $ this -> notORM -> isKeepPrimaryKeyIndex ) { $ this -> rows [ $ key ] = $ row ; } else { $ this -> rows [ ] = $ row ; } } } $ this -> data = $ this -> rows ; } }
371	public function isColorEnabled ( $ stream = \ STDOUT ) { return $ this -> color === null ? Console :: streamSupportsAnsiColors ( $ stream ) : $ this -> color ; }
10009	public function createSheet ( $ sheetIndex = null ) { $ newSheet = new Worksheet ( $ this ) ; $ this -> addSheet ( $ newSheet , $ sheetIndex ) ; return $ newSheet ; }
3391	public function confirm ( $ confirmation_code ) { $ model = $ this -> guard ( ) -> getProvider ( ) -> createModel ( ) ; $ user = $ model -> where ( 'confirmation_code' , $ confirmation_code ) -> firstOrFail ( ) ; $ user -> confirmation_code = null ; $ user -> confirmed_at = now ( ) ; $ user -> save ( ) ; event ( new Confirmed ( $ user ) ) ; return $ this -> confirmed ( $ user ) ? : redirect ( $ this -> redirectAfterConfirmationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_successful' ) ) ; }
7601	protected function renderButtons ( array $ aButtons , $ bJustified = false ) { $ sMarkup = '' ; foreach ( $ aButtons as $ oButton ) { if ( is_array ( $ oButton ) || ( $ oButton instanceof Traversable && ! ( $ oButton instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ oButton = $ oFactory -> create ( $ oButton ) ; } elseif ( ! ( $ oButton instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( 'Button expects an instanceof Zend\Form\ElementInterface or an array / Traversable, "%s" given' , is_object ( $ oButton ) ? get_class ( $ oButton ) : gettype ( $ oButton ) ) ) ; } $ sButtonMarkup = $ this -> getFormElementHelper ( ) -> __invoke ( $ oButton ) ; $ sMarkup .= $ bJustified ? sprintf ( static :: $ buttonGroupJustifiedFormat , $ sButtonMarkup ) : $ sButtonMarkup ; } return $ sMarkup ; }
324	public static function camel2words ( $ name , $ ucwords = true ) { $ label = mb_strtolower ( trim ( str_replace ( [ '-' , '_' , '.' , ] , ' ' , preg_replace ( '/(?<!\p{Lu})(\p{Lu})|(\p{Lu})(?=\p{Ll})/u' , ' \0' , $ name ) ) ) , self :: encoding ( ) ) ; return $ ucwords ? StringHelper :: mb_ucwords ( $ label , self :: encoding ( ) ) : $ label ; }
8700	public function append ( $ element ) { if ( true === $ element instanceof \ SVGCreator \ Element ) { $ this -> childElements [ ] = $ element ; return $ element ; } else { $ elementCreated = $ this -> factoryElement ( $ element ) ; $ this -> childElements [ ] = $ elementCreated ; return $ elementCreated ; } }
2353	protected function fputs ( $ varData , $ strMode ) { if ( ! \ is_resource ( $ this -> resFile ) ) { $ this -> strTmp = 'system/tmp/' . md5 ( uniqid ( mt_rand ( ) , true ) ) ; if ( strncmp ( $ strMode , 'a' , 1 ) === 0 && file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { $ this -> Files -> copy ( $ this -> strFile , $ this -> strTmp ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strTmp , $ strMode ) ) { return false ; } } fwrite ( $ this -> resFile , $ varData ) ; return true ; }
4369	public function buildTable ( $ rows , $ options = array ( ) ) { $ options = \ array_merge ( array ( 'attribs' => array ( ) , 'caption' => null , 'columns' => array ( ) , 'totalCols' => array ( ) , ) , $ options ) ; if ( \ is_string ( $ options [ 'attribs' ] ) ) { $ options [ 'attribs' ] = array ( 'class' => $ options [ 'attribs' ] , ) ; } if ( $ this -> debug -> abstracter -> isAbstraction ( $ rows ) && $ rows [ 'traverseValues' ] ) { $ options [ 'caption' ] .= ' (' . $ this -> markupClassname ( $ rows [ 'className' ] , 'span' , array ( 'title' => $ rows [ 'phpDoc' ] [ 'summary' ] ? : null , ) ) . ')' ; $ options [ 'caption' ] = \ trim ( $ options [ 'caption' ] ) ; $ rows = $ rows [ 'traverseValues' ] ; } $ keys = $ options [ 'columns' ] ? : $ this -> debug -> methodTable -> colKeys ( $ rows ) ; $ this -> tableInfo = array ( 'colClasses' => \ array_fill_keys ( $ keys , null ) , 'haveObjRow' => false , 'totals' => \ array_fill_keys ( $ options [ 'totalCols' ] , null ) , ) ; $ tBody = '' ; foreach ( $ rows as $ k => $ row ) { $ tBody .= $ this -> buildTableRow ( $ row , $ keys , $ k ) ; } if ( ! $ this -> tableInfo [ 'haveObjRow' ] ) { $ tBody = \ str_replace ( '<td class="t_classname"></td>' , '' , $ tBody ) ; } return $ this -> debug -> utilities -> buildTag ( 'table' , $ options [ 'attribs' ] , "\n" . ( $ options [ 'caption' ] ? '<caption>' . $ options [ 'caption' ] . '</caption>' . "\n" : '' ) . $ this -> buildTableHeader ( $ keys ) . '<tbody>' . "\n" . $ tBody . '</tbody>' . "\n" . $ this -> buildTableFooter ( $ keys ) ) ; }
4688	public function andWhere ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ this -> where ? '(' . $ this -> where . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'where' , $ args ) ; return $ this ; }
10339	public static function checkString ( $ pValue ) { if ( $ pValue instanceof RichText ) { return $ pValue ; } $ pValue = StringHelper :: substring ( $ pValue , 0 , 32767 ) ; $ pValue = str_replace ( [ "\r\n" , "\r" ] , "\n" , $ pValue ) ; return $ pValue ; }
9182	public function remember ( $ value , $ memoryDuration = null ) { if ( is_null ( $ memoryDuration ) ) { $ memoryDuration = $ this -> memoryDuration ; } $ key = $ this -> getRememberKey ( ) ; if ( Cache :: has ( $ key ) ) { $ value = Cache :: get ( $ key ) ; } else { $ expiresAt = Carbon :: now ( ) -> addMinutes ( $ memoryDuration ) ; if ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } Cache :: put ( $ key , $ value , $ expiresAt ) ; } return $ value ; }
11741	private function _getPerson ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ person = $ em -> getRepository ( 'ChillPersonBundle:Person' ) -> find ( $ id ) ; return $ person ; }
2012	public static function addNamespace ( $ name ) { @ trigger_error ( 'Using ClassLoader::addNamespace() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ in_array ( $ name , self :: $ namespaces ) ) { return ; } array_unshift ( self :: $ namespaces , $ name ) ; }
4907	public function onRoute ( MvcEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ ajax = $ request -> getQuery ( ) -> get ( 'ajax' ) ; if ( ! $ request -> isXmlHttpRequest ( ) || ! $ ajax ) { return ; } $ response = $ event -> getResponse ( ) ; $ ajaxEvent = $ this -> ajaxEventManager -> getEvent ( $ ajax , $ this ) ; $ ajaxEvent -> setRequest ( $ request ) ; $ ajaxEvent -> setResponse ( $ response ) ; $ results = $ this -> ajaxEventManager -> triggerEventUntil ( function ( $ r ) { return null !== $ r ; } , $ ajaxEvent ) ; $ result = $ results -> last ( ) ? : $ ajaxEvent -> getResult ( ) ; if ( ! $ result ) { throw new \ UnexpectedValueException ( 'No listener returned anything. Do not know what to do...' ) ; } if ( is_array ( $ result ) || $ result instanceof \ Traversable ) { $ result = Json :: encode ( $ result , true , [ 'enableJsonExprFinder' => true ] ) ; } $ contentType = $ ajaxEvent -> getContentType ( ) ; $ response -> getHeaders ( ) -> addHeaderLine ( 'Content-Type' , $ contentType ) ; $ response -> setContent ( $ result ) ; return $ response ; }
105	public function watch2OnHighest ( Decisions $ decisions ) { $ literals = $ this -> rule -> getLiterals ( ) ; if ( count ( $ literals ) < 3 ) { return ; } $ watchLevel = 0 ; foreach ( $ literals as $ literal ) { $ level = $ decisions -> decisionLevel ( $ literal ) ; if ( $ level > $ watchLevel ) { $ this -> watch2 = $ literal ; $ watchLevel = $ level ; } } }
9116	public function registerView ( $ view , $ order = null , $ applicationName = 'default' ) { if ( ! class_exists ( $ view ) ) { throw new ViewException ( "No such view class {view} found" , array ( 'view' => $ view ) ) ; } $ v = new $ view ( ) ; if ( ! $ v instanceof View ) { throw new ViewException ( "View {view} is not in application scope" , array ( 'view' => $ view ) ) ; } $ viewOrder = $ v -> getOrder ( ) ; if ( null !== $ order ) { $ viewOrder = intval ( $ order ) ; } $ settings = $ v -> getViewSettings ( ) ; $ this -> views [ $ applicationName ] [ $ viewOrder ] [ $ settings -> getViewSimpleName ( ) ] = $ settings ; return $ this ; }
6203	public static function start ( $ apiKey , $ notifyOnWarning = false , array $ options = array ( ) ) { if ( ! isset ( self :: $ instance ) ) { $ config = new Configuration ( $ apiKey , $ options ) ; $ client = new Client ( $ config ) ; self :: $ instance = new self ( $ client , $ notifyOnWarning ) ; if ( null !== $ config -> get ( 'errorReportingLevel' ) ) { self :: $ instance -> addErrorFilter ( new ErrorReporting ( $ config ) ) ; } self :: $ instance -> addExceptionFilter ( new AirbrakeExceptionFilter ( ) ) ; set_error_handler ( array ( self :: $ instance , 'onError' ) ) ; set_exception_handler ( array ( self :: $ instance , 'onException' ) ) ; register_shutdown_function ( array ( self :: $ instance , 'onShutdown' ) ) ; } return self :: $ instance ; }
2592	public static function createRequestCreator ( $ params , $ libIdentifier ) { $ params -> receivedFrom = self :: makeReceivedFrom ( $ params -> receivedFrom , $ libIdentifier ) ; $ theRequestCreator = new Base ( $ params ) ; return $ theRequestCreator ; }
6794	public function getTagCount ( $ ids ) { $ tableName = $ this -> getTagSource ( ) ; $ colNameId = $ this -> getIdColumn ( ) ; $ return = [ ] ; if ( $ tableName && $ colNameId ) { $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'item_id' , 'count(*) as count' ) -> from ( 'tl_metamodel_tag_relation' ) -> where ( 'att_id=:att' ) -> andWhere ( 'item_id IN (:items)' ) -> groupBy ( 'item_id' ) -> setParameter ( 'att' , $ this -> get ( 'id' ) ) -> setParameter ( 'items' , $ ids , Connection :: PARAM_INT_ARRAY ) -> execute ( ) ; while ( $ row = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ itemId = $ row -> item_id ; $ return [ $ itemId ] = ( int ) $ row -> count ; } } return $ return ; }
2776	public static function parseRepositoryName ( string $ repositoryUrl ) : string { $ scheme = parse_url ( $ repositoryUrl , PHP_URL_SCHEME ) ; if ( $ scheme === null ) { $ parts = explode ( '/' , $ repositoryUrl ) ; $ path = end ( $ parts ) ; } else { $ strpos = strpos ( $ repositoryUrl , ':' ) ; $ path = substr ( $ repositoryUrl , $ strpos + 1 ) ; } return basename ( $ path , '.git' ) ; }
3185	public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ itemDuration = null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = $ this -> getRequestParameter ( 'start' ) !== false ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ this -> getTime ( ) ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> skip ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } if ( $ start == true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
7291	private function getByMethodAndStatesFromDateQuery ( ) { if ( null !== $ this -> byMethodAndStatesFromDateQuery ) { return $ this -> byMethodAndStatesFromDateQuery ; } $ qb = $ this -> createQueryBuilder ( 'p' ) ; $ query = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.method' , ':method' ) ) -> andWhere ( $ qb -> expr ( ) -> in ( 'p.state' , ':states' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'p.createdAt' , ':date' ) ) -> addOrderBy ( 'p.createdAt' , 'ASC' ) -> getQuery ( ) -> useQueryCache ( true ) ; return $ this -> byMethodAndStatesFromDateQuery = $ query ; }
12331	public function get ( $ key ) { if ( ! $ this -> repository -> containsKey ( $ key ) ) throw new ReferenceDoesNotExistException ( ) ; return $ this -> repository -> get ( $ key ) ; }
7525	function select ( $ query = '*' , $ index = false , $ recursive = true , $ check_self = false ) { return $ this -> root -> select ( $ query , $ index , $ recursive , $ check_self ) ; }
10963	public static function getUri ( ) { $ parts = [ $ uri = self :: getScheme ( ) , '://' ] ; $ authUsername = self :: getAuthUsername ( ) ; $ authPassword = self :: getAuthPassword ( ) ; if ( $ authUsername !== null && $ authPassword !== null ) { $ parts [ ] = $ authUsername . ':' . $ authPassword . '@' ; } $ parts [ ] = self :: getHost ( ) ; $ port = self :: getPort ( ) ; if ( $ port != self :: getStandardPort ( self :: getScheme ( ) ) ) { $ parts [ ] = ':' . $ port ; } $ path = self :: getPath ( ) ; if ( $ path !== null && $ path != '' ) { $ parts [ ] = '/' . $ path ; } $ query = Input :: getQuery ( ) ; if ( is_array ( $ query ) && count ( $ query ) > 0 ) { $ queryString = [ ] ; foreach ( $ query as $ key => $ value ) { $ queryKeyValue = $ key . '=' ; if ( $ value !== null ) { if ( is_string ( $ value ) ) { $ value = urlencode ( $ value ) ; } $ queryKeyValue .= $ value ; } $ queryString [ ] = $ queryKeyValue ; } if ( count ( $ queryString ) > 0 ) { $ parts [ ] = '?' . implode ( '&' , $ queryString ) ; } } return implode ( '' , $ parts ) ; }
300	protected function refreshInternal ( $ record ) { if ( $ record === null ) { return false ; } foreach ( $ this -> attributes ( ) as $ name ) { $ this -> _attributes [ $ name ] = isset ( $ record -> _attributes [ $ name ] ) ? $ record -> _attributes [ $ name ] : null ; } $ this -> _oldAttributes = $ record -> _oldAttributes ; $ this -> _related = [ ] ; $ this -> _relationsDependencies = [ ] ; $ this -> afterRefresh ( ) ; return true ; }
12770	public function authorize ( RecordInterface & $ user , $ remember = false ) { if ( parent :: authorize ( $ user , $ remember ) ) { if ( $ remember ) { $ token = $ user [ $ this -> dbHashEmailField ] . ( time ( ) + ( $ this -> cookieTime ) ) . $ user [ $ this -> dbHashPasswordField ] ; $ user [ $ this -> dbAccessToken ] = $ token ; $ user -> save ( ) ; $ expiry = time ( ) + ( $ this -> cookieTime ) ; $ cookieData = array ( "token" => $ token , "expiry" => $ expiry ) ; setcookie ( '_cookie_accessToken' , serialize ( $ cookieData ) , $ expiry ) ; } } }
5078	public function getSearch ( $ aData = [ ] ) { $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ sKeywords = $ oInput -> get ( 'search' ) ? : $ oInput -> get ( 'keywords' ) ; $ iPage = ( int ) $ oInput -> get ( 'page' ) ; if ( strlen ( $ sKeywords ) < static :: CONFIG_MIN_SEARCH_LENGTH ) { throw new ApiException ( 'Search term must be ' . static :: CONFIG_MIN_SEARCH_LENGTH . ' characters or longer.' , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ oResult = $ oItemModel -> search ( $ sKeywords , $ iPage , static :: CONFIG_MAX_ITEMS_PER_PAGE , $ aData ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( array_map ( [ $ this , 'formatObject' ] , $ oResult -> data ) ) ; return $ oResponse ; }
5248	public function find ( $ id ) { $ child = $ this -> childClassName ; $ model = $ child :: findWithParentId ( $ id , $ this -> parent -> getId ( ) ) ; if ( $ model ) { $ model -> setParent ( $ this -> parent ) ; } return $ model ; }
9449	protected function allowed ( $ method ) { if ( in_array ( $ method , $ this -> allowed ) === false ) { $ message = 'Used method is not allowed' ; throw new \ UnexpectedValueException ( $ message ) ; } return true ; }
5873	public static function isTransparentPng ( $ fileName ) { $ bytes = file_get_contents ( $ fileName , false , null , 24 , 2 ) ; $ byte24 = ord ( $ bytes { 0 } ) ; $ byte25 = ord ( $ bytes { 1 } ) ; if ( $ byte24 === 16 || $ byte25 === 6 || $ byte25 === 4 ) { return true ; } else { $ content = file_get_contents ( $ fileName ) ; return strpos ( $ content , 'tRNS' ) !== false ; } }
11501	protected function loadContainer ( array $ config = [ ] , $ environment = null ) { $ containerConfigs = $ this -> provideContainerConfigs ( $ config , $ environment ) ; array_unshift ( $ containerConfigs , new WeaveConfig ( function ( $ pipelineName ) { return $ this -> provideMiddlewarePipeline ( $ pipelineName ) ; } , function ( $ router ) { return $ this -> provideRouteConfiguration ( $ router ) ; } ) ) ; $ this -> container = ( new ContainerBuilder ) -> newConfiguredInstance ( $ containerConfigs , ContainerBuilder :: AUTO_RESOLVE ) ; return $ this -> container -> get ( 'instantiator' ) ; }
2435	public function remove ( $ strKey ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { $ this -> session -> remove ( $ strKey ) ; } else { $ this -> sessionBag -> remove ( $ strKey ) ; } }
10352	private function getSourceByJob ( $ job ) { $ login = head ( array_except ( $ job -> credentials , 'password' ) ) ; return $ login . app ( 'request' ) -> ip ( ) ; }
4640	private function createHelperPluginManager ( ContainerInterface $ container ) : HelperPluginManager { $ factory = new ViewHelperManagerFactory ( ) ; $ helperManager = $ factory ( $ container , ViewHelperManagerFactory :: PLUGIN_MANAGER_CLASS ) ; $ config = new Config ( $ this -> getSpecificConfig ( $ container , 'view_helpers' ) ) ; $ config -> configureServiceManager ( $ helperManager ) ; return $ helperManager ; }
2864	public function getLastFilePosition ( $ filePath ) { if ( ! file_exists ( $ filePath ) ) { return 0 ; } $ f = fopen ( $ filePath , 'r' ) ; fseek ( $ f , - 1 , SEEK_END ) ; return ftell ( $ f ) ; }
1934	protected function getDateString ( ) { return 'Locale.define("en-US","Date",{' . 'months:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] ) . '"],' . 'days:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] ) . '"],' . 'months_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS_SHORT' ] ) . '"],' . 'days_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS_SHORT' ] ) . '"]' . '});' . 'Locale.define("en-US","DatePicker",{' . 'select_a_time:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'select_a_time' ] . '",' . 'use_mouse_wheel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'use_mouse_wheel' ] . '",' . 'time_confirm_button:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'time_confirm_button' ] . '",' . 'apply_range:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'apply_range' ] . '",' . 'cancel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'cancel' ] . '",' . 'week:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'week' ] . '"' . '});' ; }
1494	public static function fromArray ( iterable $ config , string $ urlPrefix = null ) : self { return new self ( ... collect ( $ config ) -> map ( function ( $ value , $ key ) use ( $ urlPrefix ) { return Encoding :: fromArray ( $ key , $ value , $ urlPrefix ) ; } ) -> values ( ) ) ; }
2882	protected function _initEmail ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ index = $ this -> getRequest ( ) -> getParam ( 'index' ) ; if ( $ token === null || $ index === null ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return null ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return null ; } $ emails = $ requestProfile -> getEmails ( ) ; if ( ! $ emails || ! ( $ index < count ( $ emails ) ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'E-mail not found' ) ; return null ; } return $ emails [ ( int ) $ index ] ; }
404	public function prepareHeaders ( $ requestHeaders ) { $ responseHeaders = [ ] ; if ( isset ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { if ( in_array ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] , true ) ) { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = $ requestHeaders [ 'Origin' ] ; } if ( in_array ( '*' , $ this -> cors [ 'Origin' ] , true ) ) { if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) && $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) { if ( YII_DEBUG ) { throw new InvalidConfigException ( "Allowing credentials for wildcard origins is insecure. Please specify more restrictive origins or set 'credentials' to false in your CORS configuration." ) ; } else { Yii :: error ( "Allowing credentials for wildcard origins is insecure. Please specify more restrictive origins or set 'credentials' to false in your CORS configuration." , __METHOD__ ) ; } } else { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = '*' ; } } } $ this -> prepareAllowHeaders ( 'Headers' , $ requestHeaders , $ responseHeaders ) ; if ( isset ( $ requestHeaders [ 'Access-Control-Request-Method' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Methods' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Request-Method' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Credentials' ] = $ this -> cors [ 'Access-Control-Allow-Credentials' ] ? 'true' : 'false' ; } if ( isset ( $ this -> cors [ 'Access-Control-Max-Age' ] ) && $ this -> request -> getIsOptions ( ) ) { $ responseHeaders [ 'Access-Control-Max-Age' ] = $ this -> cors [ 'Access-Control-Max-Age' ] ; } if ( isset ( $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Expose-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Allow-Headers' ] ) ; } return $ responseHeaders ; }
7717	function FileGetState ( $ NameOrIdx ) { $ idx = $ this -> FileGetIdx ( $ NameOrIdx ) ; if ( $ idx === false ) { $ idx = $ this -> FileGetIdxAdd ( $ NameOrIdx ) ; if ( $ idx === false ) { return false ; } else { return 'a' ; } } elseif ( isset ( $ this -> ReplInfo [ $ idx ] ) ) { if ( $ this -> ReplInfo [ $ idx ] === false ) { return 'd' ; } else { return 'm' ; } } else { return 'u' ; } }
6116	public function serverGetByName ( $ name ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_name" ] == $ name ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
4176	public function getFacades ( ) { return $ this -> facades ? : $ this -> facades = new Facade ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
6193	protected function loadModels ( $ path ) { $ this -> app -> config [ 'model' ] = array_unique ( array_merge ( $ this -> app -> config [ 'model' ] ?? [ ] , $ path ) ) ; }
12449	static function run_check_gnu_files ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; if ( $ opts [ 'files' ] [ 'gnu_dir' ] ) { $ destdir .= '/' . $ opts [ 'files' ] [ 'gnu_dir' ] ; } $ files = pakeFinder :: type ( 'file' ) -> name ( array ( 'README' , 'LICENSE' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) != 2 ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "README and/or LICENSE files missing. Please fix" ) ; } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
2760	public function fetchBranches ( bool $ onlyRemote = false ) : array { $ options = $ onlyRemote ? [ 'r' => true ] : [ 'a' => true ] ; $ output = $ this -> gitWorkingCopy -> branch ( $ options ) ; $ branches = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimBranch' ] , $ branches ) ; }
6189	public function renderJSONP ( $ data ) { $ callback = null ; if ( isset ( $ _GET [ 'callback' ] ) ) { $ callback = $ _GET [ 'callback' ] ; } exit ( Response :: Create ( $ callback . '(' . json_encode ( $ data ) . ')' ) -> headers ( [ 'Content-Type' => 'application/jsonp' ] ) -> display ( ) ) ; }
1371	protected function make ( array $ data ) { $ validator = $ this -> validatorFactory -> make ( $ data , $ this -> getRules ( ) , $ this -> getMessages ( ) , $ this -> getAttributes ( ) ) ; $ this -> configureValidator ( $ validator ) ; return $ validator ; }
5218	protected static function hostname ( ) { return function ( Binder $ binder ) { if ( DIRECTORY_SEPARATOR === '\\' ) { $ fq = php_uname ( 'n' ) ; if ( isset ( $ _SERVER [ 'USERDNSDOMAIN' ] ) ) { $ fq .= '.' . $ _SERVER [ 'USERDNSDOMAIN' ] ; } } else { $ fq = exec ( 'hostname -f' ) ; } $ binder -> bindConstant ( 'stubbles.hostname.nq' ) -> to ( php_uname ( 'n' ) ) ; $ binder -> bindConstant ( 'stubbles.hostname.fq' ) -> to ( $ fq ) ; } ; }
4404	public function getPath ( $ locationId ) { $ pathArray = array ( ) ; $ startingLocation = $ this -> locationService -> loadLocation ( $ locationId ) ; $ path = $ startingLocation -> path ; array_shift ( $ path ) ; $ rootLocationFound = false ; foreach ( $ path as $ index => $ pathItem ) { if ( ( int ) $ pathItem === $ this -> rootLocationId ) { $ rootLocationFound = true ; } if ( ! $ rootLocationFound ) { continue ; } try { $ location = $ this -> locationService -> loadLocation ( $ pathItem ) ; } catch ( UnauthorizedException $ e ) { return array ( ) ; } $ pathArray [ ] = array ( 'text' => $ this -> translationHelper -> getTranslatedContentNameByContentInfo ( $ location -> contentInfo ) , 'url' => $ location -> id !== $ startingLocation -> id ? $ this -> router -> generate ( $ location ) : false , 'locationId' => $ location -> id , 'contentId' => $ location -> contentId , ) ; } return $ pathArray ; }
9178	public function getDatabaseById ( $ id ) { foreach ( $ this -> databases as $ database ) { if ( $ database -> getId ( ) === $ id ) { return $ database ; } } throw new \ Exception ( sprintf ( 'Database with ID %s can not be found' , $ id ) ) ; }
2652	public function uploadSnippet ( $ version , array $ snippet ) { if ( isset ( $ snippet [ 'content' ] ) ) { $ adminUrl = $ this -> vcl -> getAdminFrontName ( ) ; $ adminPathTimeout = $ this -> config -> getAdminPathTimeout ( ) ; $ ignoredUrlParameters = $ this -> config -> getIgnoredUrlParameters ( ) ; $ ignoredUrlParameterPieces = explode ( "," , $ ignoredUrlParameters ) ; $ filterIgnoredUrlParameterPieces = array_filter ( array_map ( 'trim' , $ ignoredUrlParameterPieces ) ) ; $ queryParameters = implode ( '|' , $ filterIgnoredUrlParameterPieces ) ; $ snippet [ 'content' ] = str_replace ( '####ADMIN_PATH####' , $ adminUrl , $ snippet [ 'content' ] ) ; $ snippet [ 'content' ] = str_replace ( '####ADMIN_PATH_TIMEOUT####' , $ adminPathTimeout , $ snippet [ 'content' ] ) ; $ snippet [ 'content' ] = str_replace ( '####QUERY_PARAMETERS####' , $ queryParameters , $ snippet [ 'content' ] ) ; } $ checkIfExists = $ this -> hasSnippet ( $ version , $ snippet [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/snippet' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ snippet [ 'name' ] ; unset ( $ snippet [ 'name' ] , $ snippet [ 'type' ] , $ snippet [ 'dynamic' ] , $ snippet [ 'priority' ] ) ; } $ result = $ this -> _fetch ( $ url , $ verb , $ snippet ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to upload the Snippet file.' ) ) ; } }
11573	public function SendHeaders ( ) { if ( headers_sent ( ) ) { return $ this ; } header ( 'HTTP/' . $ this -> Version . ' ' . $ this -> StatusCode . ' ' . $ this -> StatusText , true , $ this -> StatusCode ) ; foreach ( $ this -> Headers -> GetCookies ( ) as $ cookie ) { } return $ this ; }
3234	static function stringEquals ( $ a , $ b ) { if ( func_num_args ( ) !== 2 ) { throw new \ InvalidArgumentException ( "Expecting 2 args, got " . func_num_args ( ) . "." ) ; } Checker :: argString ( "a" , $ a ) ; Checker :: argString ( "b" , $ b ) ; $ len = strlen ( $ a ) ; if ( strlen ( $ b ) !== $ len ) return false ; $ result = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ result |= ord ( $ a [ $ i ] ) ^ ord ( $ b [ $ i ] ) ; } return $ result === 0 ; }
4725	private function addRule ( $ data , $ ruleType ) { if ( \ is_string ( $ data ) ) { $ data = array ( $ data ) ; } elseif ( ! \ is_array ( $ data ) ) { throw new InvalidArgumentException ( 'Invalid inflector rule data.' ) ; } foreach ( $ data as $ rule ) { array_push ( $ this -> rules [ $ ruleType ] , ( string ) $ rule ) ; } }
8102	public function getStatement ( $ sql , $ args = false ) { $ query = $ this -> buildQuery ( $ sql , $ args ) ; if ( $ connection = $ this -> db -> getConnection ( ) ) { if ( $ stmt = $ connection -> prepare ( $ query ) ) { $ this -> log -> report ( "SQL Statement: {$query}" ) ; $ stmt -> setFetchMode ( \ PDO :: FETCH_INTO , new Collection ( ) ) ; if ( $ args ) { $ this -> log -> report ( "SQL Data Sent: [" . implode ( ', ' , $ args ) . "]" ) ; $ stmt -> execute ( $ args ) ; } if ( $ stmt -> errorCode ( ) > 0 ) { $ error = $ stmt -> errorInfo ( ) ; $ this -> log -> error ( "PDO({$error[0]})[{$error[1]}] {$error[2]}" ) ; return false ; } return $ stmt ; } else { $ this -> log -> error ( 'Failed to create a PDO statement with: ' . $ query ) ; return false ; } } else { return false ; } }
1460	protected function orderDesc ( ) { $ this -> query -> orderByDesc ( $ this -> column ) ; if ( $ this -> isNotPagingOnKey ( ) ) { $ this -> query -> orderByDesc ( $ this -> key ) ; } return $ this ; }
640	public function dropPrimaryKey ( $ name , $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropPrimaryKey ( $ name , $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
9628	protected function validateParams ( Route $ route , array $ params , array $ requiredParams ) { $ identifier = $ this -> getRouteIdentifier ( $ route ) ; $ givenParams = array_keys ( $ params ) ; $ missingParams = array_diff ( $ requiredParams , $ givenParams ) ; if ( count ( $ missingParams ) > 0 ) { throw new \ InvalidArgumentException ( sprintf ( 'Error while validating params "%s": Required parameters "%s" are missing' , $ identifier , implode ( ', ' , $ missingParams ) ) ) ; } if ( ! $ this -> matchParams ( $ route , $ params ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Error while validing params for target "%s": Params don\'t fulfill their matcher\'s criteria' , $ identifier ) ) ; } }
4415	public static function modify ( $ tpl , $ operatorName , $ operatorParameters , $ rootNamespace , $ currentNamespace , & $ operatorValue , $ namedParameters , $ placement ) { if ( $ operatorName === 'has_tags_bundle' ) { $ operatorValue = class_exists ( 'Netgen\TagsBundle\Version' ) && TagsBundleVersion :: VERSION_ID >= 30000 ; } }
7097	public function normalizeStock ( StockSubjectInterface $ subject , $ format = null , array $ context = [ ] ) { $ translator = $ this -> constantHelper -> getTranslator ( ) ; $ formatter = $ this -> getFormatter ( ) ; if ( null !== $ eda = $ subject -> getEstimatedDateOfArrival ( ) ) { $ eda = $ formatter -> date ( $ eda ) ; } else { $ eda = $ translator -> trans ( 'ekyna_core.value.undefined' ) ; } $ stockUnits = $ this -> findStockUnits ( $ subject ) ; return [ 'mode_label' => $ this -> constantHelper -> renderStockSubjectModeLabel ( $ subject ) , 'mode_badge' => $ this -> constantHelper -> renderStockSubjectModeBadge ( $ subject ) , 'state_label' => $ this -> constantHelper -> renderStockSubjectStateLabel ( $ subject ) , 'state_badge' => $ this -> constantHelper -> renderStockSubjectStateBadge ( $ subject ) , 'in' => $ formatter -> number ( $ subject -> getInStock ( ) ) , 'available' => $ formatter -> number ( $ subject -> getAvailableStock ( ) ) , 'virtual' => $ formatter -> number ( $ subject -> getVirtualStock ( ) ) , 'floor' => $ formatter -> number ( $ subject -> getStockFloor ( ) ) , 'geocode' => $ subject -> getGeocode ( ) , 'replenishment' => $ formatter -> number ( $ subject -> getReplenishmentTime ( ) ) , 'eda' => $ eda , 'moq' => $ formatter -> number ( $ subject -> getMinimumOrderQuantity ( ) ) , 'quote_only' => $ subject -> isQuoteOnly ( ) ? $ translator -> trans ( 'ekyna_core.value.yes' ) : $ translator -> trans ( 'ekyna_core.value.no' ) , 'end_of_life' => $ subject -> isEndOfLife ( ) ? $ translator -> trans ( 'ekyna_core.value.yes' ) : $ translator -> trans ( 'ekyna_core.value.no' ) , 'stock_units' => $ this -> normalizer -> normalize ( $ stockUnits , $ format , $ context ) , ] ; }
1167	protected function validateJsRemoteRequest ( $ attribute , $ parameters ) { $ this -> setRemoteValidation ( $ attribute , $ parameters [ 'validate_all' ] ) ; $ validator = $ this -> validator ; if ( $ validator -> passes ( ) ) { return true ; } return $ validator -> messages ( ) -> get ( $ attribute ) ; }
7950	public function orderBackend ( $ nbBackend , $ duration ) { return json_decode ( self :: getClient ( ) -> orderBackend ( $ this -> sn , $ nbBackend , $ duration ) ) ; }
12281	public function getCode ( ) { $ data = [ 'component_appid' => $ this -> getAppId ( ) , ] ; $ result = $ this -> parseJSON ( 'json' , [ self :: CREATE_PRE_AUTH_CODE , $ data ] ) ; if ( empty ( $ result [ 'pre_auth_code' ] ) ) { throw new InvalidArgumentException ( 'Invalid response.' ) ; } return $ result [ 'pre_auth_code' ] ; }
8591	public function setStatus ( $ status ) { if ( ! $ this -> isNumericArray ( $ status ) ) { $ status = array ( $ status ) ; } $ this -> fields [ 'Status' ] [ 'FieldValue' ] = $ status ; return $ this ; }
11620	public function auth ( ) : \ TheCMSThread \ Core \ Main \ Auth { static $ auth ; if ( $ auth === null ) { $ auth = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\Auth" ) ; } $ auth -> __construct ( ) ; return $ auth ; }
3484	public function withThreadId ( string $ threadId ) : Aps { $ cloned = clone $ this ; $ cloned -> threadId = $ threadId ; return $ cloned ; }
4537	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Uuidentifiable ) { return ; } $ this -> idService -> generateUuid ( $ entity ) ; }
3992	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values ) ) ; }
5065	public function getInfo ( int $ opt ) : string { if ( $ opt <= 0 ) { throw new CurlException ( "Option must be greater than zero, " . $ opt . " given." ) ; } return curl_getinfo ( $ this -> ch , $ opt ) ; }
11289	protected function _getModel ( $ attributeName , $ relatedObjName = false , $ query = false , $ loadMap = false , $ record = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = null ; if ( $ relatedObjName ) { if ( $ loadMap instanceof \ Cora \ Adm \ LoadMap && ! $ loadMap -> fetchData ( ) && $ record !== false ) { $ relatedObj = $ this -> fetchRelatedObj ( $ def [ 'model' ] ) ; $ result = $ relatedObj -> _populate ( $ record , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'via' ] ) ) { $ result = $ this -> _getModelFromTableColumn ( $ attributeName , $ def [ 'model' ] , $ def [ 'via' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'using' ] ) ) { $ result = $ this -> getModelFromCustomRelationship ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'usesRefTable' ] ) ) { $ result = $ this -> _getModelFromRelationTable ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap ) ; } else { $ relatedObj = $ this -> fetchRelatedObj ( $ def [ 'model' ] ) ; if ( $ query && $ query -> isCustom ( ) ) { $ data = $ query -> fetch ( ) ; $ result = $ relatedObj -> _populate ( $ data ) ; } else { if ( ! isset ( $ this -> model_data [ $ attributeName ] ) ) { $ this -> model_data [ $ attributeName ] = $ this -> _fetchData ( $ attributeName ) ; } if ( ! is_object ( $ this -> model_data [ $ attributeName ] ) ) { $ relObjRepo = $ relatedObj -> getRepository ( true ) ; $ result = $ relObjRepo -> find ( $ this -> model_data [ $ attributeName ] ) ; } else { $ result = $ this -> model_data [ $ attributeName ] ; } if ( $ result ) { $ result -> _populate ( [ ] , false , $ loadMap ) ; } } } } return $ result ; }
4250	private function getMeta ( $ method , $ meta ) { $ firePhpMeta = array ( 'Type' => isset ( $ this -> firephpMethods [ $ method ] ) ? $ this -> firephpMethods [ $ method ] : $ this -> firephpMethods [ 'log' ] , ) ; if ( isset ( $ meta [ 'file' ] ) ) { $ firePhpMeta [ 'File' ] = $ meta [ 'file' ] ; $ firePhpMeta [ 'Line' ] = $ meta [ 'line' ] ; } if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ firePhpMeta [ 'Collapsed' ] = $ method == 'groupCollapsed' ? 'true' : 'false' ; } return $ firePhpMeta ; }
8184	public function getPeakMemoryUsage ( ) { return isset ( $ this -> ends [ 'pmu' ] ) && isset ( $ this -> starts [ 'pmu' ] ) ? $ this -> ends [ 'pmu' ] - $ this -> starts [ 'pmu' ] : 0 ; }
5050	public function trigger ( $ eventName , $ target = null , $ argv = [ ] ) { $ event = $ eventName instanceof EventInterface ? $ eventName : $ this -> getEvent ( $ eventName , $ target , $ argv ) ; return $ this -> triggerListeners ( $ event ) ; }
12301	public function getChilds ( $ id , $ relation , $ filters = null ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } if ( count ( $ filters -> request -> all ( ) ) > 0 ) { $ child = $ parent -> $ relation ( ) -> getRelated ( ) ; $ search = new Search ( $ child , $ filters , $ parent -> $ relation ( ) ) ; $ this -> builder = $ search -> getBuilder ( ) ; $ this -> builder -> select ( "{$child->getTable()}.*" ) ; return $ this -> builder -> get ( ) ; } $ resource = $ parent -> $ relation ; return $ resource ; }
1846	public static function unixToJd ( $ tstamp ) { list ( $ year , $ month , $ day ) = explode ( ',' , date ( 'Y,m,d' , $ tstamp ) ) ; $ year += ( $ year < 0 ? 4801 : 4800 ) ; if ( $ month > 2 ) { $ month -= 3 ; } else { $ month += 9 ; -- $ year ; } $ sdn = floor ( ( floor ( $ year / 100 ) * 146097 ) / 4 ) ; $ sdn += floor ( ( ( $ year % 100 ) * 1461 ) / 4 ) ; $ sdn += floor ( ( $ month * 153 + 2 ) / 5 ) ; $ sdn += $ day - 32045 ; return $ sdn ; }
12352	public function allow ( array $ level_select = [ "min" => 4 , "max" => 4 ] ) : bool { if ( $ this -> details !== false ) { if ( is_array ( $ level_select ) === true && isset ( $ level_select [ "min" ] ) === true && isset ( $ level_select [ "max" ] ) === true ) { $ level_select [ "min" ] = Model \ Role :: find ( $ level_select [ "min" ] ) -> priority ; $ level_select [ "max" ] = Model \ Role :: find ( $ level_select [ "max" ] ) -> priority ; $ level_select = [ "min" => $ level_select [ "min" ] , "max" => $ level_select [ "max" ] ] ; } else { return false ; } $ current_priority = $ this -> details -> role -> priority ; if ( is_numeric ( $ level_select [ "min" ] ) === true && is_numeric ( $ level_select [ "max" ] ) === true ) { if ( $ level_select [ "min" ] >= $ current_priority && $ level_select [ "max" ] <= $ current_priority ) { return true ; } else { return false ; } } else { return false ; } } else { return false ; } }
12893	public function create ( $ account , $ openId ) { $ params = [ 'kf_account' => $ account , 'openid' => $ openId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CREATE , $ params ] ) ; }
9439	public function alias ( $ id , $ original ) { $ this -> instances [ $ id ] = $ this -> get ( $ original ) ; return $ this ; }
6455	public function textual ( ) { $ this -> restrictElements ( [ 'textarea' => [ ] , 'input' => [ ] , ] ) ; self :: debug ( [ 'Expected: %s' , 'Value: %s' , 'Tag: %s' , ] , [ $ this -> expected , $ this -> value , $ this -> tag , ] ) ; $ this -> assert ( trim ( $ this -> expected ) === $ this -> value ) ; }
8834	private function getObserver ( ) : ProcessObserverInterface { if ( 1 === count ( $ this -> observerList ) ) { $ observer = $ this -> observerList [ 0 ] ; } elseif ( count ( $ this -> observerList ) ) { $ observer = new AggregateLogger ( $ this -> observerList ) ; } else { $ observer = new NullProcessObserver ( ) ; } return $ observer ; }
4828	public function create_bill ( $ attrs ) { if ( ! isset ( $ attrs [ 'amount' ] ) ) { throw new GoCardless_ArgumentsException ( 'Amount required' ) ; } $ params = array ( 'bill' => array ( 'amount' => $ attrs [ 'amount' ] , 'pre_authorization_id' => $ this -> id ) ) ; if ( isset ( $ attrs [ 'name' ] ) ) { $ params [ 'bill' ] [ 'name' ] = $ attrs [ 'name' ] ; } if ( isset ( $ attrs [ 'description' ] ) ) { $ params [ 'bill' ] [ 'description' ] = $ attrs [ 'description' ] ; } if ( isset ( $ attrs [ 'charge_customer_at' ] ) ) { $ params [ 'bill' ] [ 'charge_customer_at' ] = $ attrs [ 'charge_customer_at' ] ; } $ endpoint = GoCardless_Bill :: $ endpoint ; return new GoCardless_Bill ( $ this -> client , $ this -> client -> request ( 'post' , $ endpoint , $ params ) ) ; }
1536	protected function fillRelationships ( $ record , Collection $ relationships , EncodingParametersInterface $ parameters ) { $ relationships -> filter ( function ( $ value , $ field ) use ( $ record ) { return $ this -> isFillableRelation ( $ field , $ record ) ; } ) -> each ( function ( $ value , $ field ) use ( $ record , $ parameters ) { $ this -> fillRelationship ( $ record , $ field , $ value , $ parameters ) ; } ) ; }
8405	public static function run ( ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'bootstrap doesn\'t seem to have been initialized' ) ; } foreach ( self :: $ namespaces as $ name => $ path ) { if ( is_readable ( $ path . DIRECTORY_SEPARATOR . 'init.php' ) === true ) { require $ path . DIRECTORY_SEPARATOR . 'init.php' ; } elseif ( stripos ( $ path , 'vendor' ) === false || stripos ( $ path , 'vendor' ) == strlen ( $ path ) - strlen ( 'vendor' ) ) { Logger :: get ( ) -> error ( 'namespace "' . $ name . '" doesn\'t have an init.php' ) ; } } if ( defined ( 'STRAY_IS_CLI' ) === true && constant ( 'STRAY_IS_CLI' ) === true ) { Console :: run ( ) ; } elseif ( defined ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_IS_HTTP' ) === true ) { if ( count ( self :: $ applications ) == 0 ) { throw new BadUse ( 'no application has been registered' ) ; } Http :: run ( ) ; } else { throw new BadUse ( 'unknown mode, not CLI_IS_CLI nor STRAY_IS_HTTP' ) ; } }
3932	private function setLabel ( PropertyInterface $ property , $ propInfo , IAttribute $ attribute ) { if ( $ property -> getLabel ( ) ) { return ; } if ( ! isset ( $ propInfo [ 'label' ] ) ) { $ property -> setLabel ( $ attribute -> getName ( ) ) ; return ; } $ lang = $ propInfo [ 'label' ] ; if ( is_array ( $ lang ) ) { $ property -> setLabel ( reset ( $ lang ) ) ; $ property -> setDescription ( next ( $ lang ) ) ; return ; } $ property -> setLabel ( $ lang ) ; }
10141	private function loadOLE ( $ pFilename ) { $ ole = new OLERead ( ) ; $ ole -> read ( $ pFilename ) ; $ this -> data = $ ole -> getStream ( $ ole -> wrkbook ) ; $ this -> summaryInformation = $ ole -> getStream ( $ ole -> summaryInformation ) ; $ this -> documentSummaryInformation = $ ole -> getStream ( $ ole -> documentSummaryInformation ) ; }
12330	public function get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug = null ) { $ source_file = $ filename ; if ( defined ( 'SCRIPT_DEBUG' ) && true === SCRIPT_DEBUG && ! empty ( $ filename_debug ) ) { $ source_file = $ filename_debug ; } $ path = realpath ( trailingslashit ( $ relative_path ) . $ source_file ) ; return WP_Url_Util :: get_instance ( ) -> convert_absolute_path_to_url ( $ path ) ; }
242	public function run ( ) { $ rows = [ ] ; $ i = 0 ; foreach ( $ this -> attributes as $ attribute ) { $ rows [ ] = $ this -> renderAttribute ( $ attribute , $ i ++ ) ; } $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'table' ) ; echo Html :: tag ( $ tag , implode ( "\n" , $ rows ) , $ options ) ; }
1478	public function delete ( $ resourceType , $ id , array $ queryParams = [ ] ) { return $ this -> resource ( RouteName :: delete ( $ resourceType ) , $ id , $ queryParams ) ; }
8710	public function where ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( is_array ( $ column ) ) { return $ this -> addArrayOfWheres ( $ column , $ boolean ) ; } if ( in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { return $ this -> whereTranslated ( $ column , $ operator , $ value , $ boolean ) ; } return parent :: where ( $ column , $ operator , $ value , $ boolean ) ; }
6588	public function get ( $ url , $ method = "GET" ) { return $ this -> request ( [ CURLOPT_HTTPGET => true , CURLOPT_CUSTOMREQUEST => $ method ? : "GET" , CURLOPT_URL => "$url" , ] ) ; }
12745	protected function move ( NodeConnectionInterface $ connection , $ slot ) { $ this -> pool [ ( string ) $ connection ] = $ connection ; $ this -> slots [ ( int ) $ slot ] = $ connection ; $ this -> slotmap [ ( int ) $ slot ] = $ connection ; }
5707	public function getButtonLink ( ) { $ link = Controller :: join_links ( 'customaction' , $ this -> actionName ) ; return $ this -> gridFieldRequest -> Link ( $ link ) ; }
2273	public function getModules ( ) { $ groups = array ( ) ; foreach ( $ GLOBALS [ 'FE_MOD' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { $ groups [ $ k ] [ ] = $ kk ; } } return $ groups ; }
2578	protected function loadArnk ( Segment \ ArrivalUnknown $ segment ) { $ this -> travelProduct = new TravelProduct ( ) ; $ this -> travelProduct -> productDetails = new ProductDetails ( $ segment -> identification ) ; $ this -> messageAction = new MessageAction ( Business :: FUNC_ARNK ) ; }
569	protected function encrypt ( $ data , $ passwordBased , $ secret , $ info ) { if ( ! extension_loaded ( 'openssl' ) ) { throw new InvalidConfigException ( 'Encryption requires the OpenSSL PHP extension' ) ; } if ( ! isset ( $ this -> allowedCiphers [ $ this -> cipher ] [ 0 ] , $ this -> allowedCiphers [ $ this -> cipher ] [ 1 ] ) ) { throw new InvalidConfigException ( $ this -> cipher . ' is not an allowed cipher' ) ; } list ( $ blockSize , $ keySize ) = $ this -> allowedCiphers [ $ this -> cipher ] ; $ keySalt = $ this -> generateRandomKey ( $ keySize ) ; if ( $ passwordBased ) { $ key = $ this -> pbkdf2 ( $ this -> kdfHash , $ secret , $ keySalt , $ this -> derivationIterations , $ keySize ) ; } else { $ key = $ this -> hkdf ( $ this -> kdfHash , $ secret , $ keySalt , $ info , $ keySize ) ; } $ iv = $ this -> generateRandomKey ( $ blockSize ) ; $ encrypted = openssl_encrypt ( $ data , $ this -> cipher , $ key , OPENSSL_RAW_DATA , $ iv ) ; if ( $ encrypted === false ) { throw new \ yii \ base \ Exception ( 'OpenSSL failure on encryption: ' . openssl_error_string ( ) ) ; } $ authKey = $ this -> hkdf ( $ this -> kdfHash , $ key , null , $ this -> authKeyInfo , $ keySize ) ; $ hashed = $ this -> hashData ( $ iv . $ encrypted , $ authKey ) ; return $ keySalt . $ hashed ; }
4820	public function addField ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> row [ $ name ] = $ value ; } elseif ( is_array ( $ this -> row [ $ name ] ) ) { $ this -> row [ $ name ] [ ] = $ value ; } else { $ this -> row [ $ name ] = array ( $ this -> row [ $ name ] , $ value ) ; } $ this -> informChanges ( ) ; }
8533	public function setDebtRecoveryItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DebtRecoveryItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3760	private function createConditionsForPalette ( PaletteInterface $ palette , array $ typeLegends ) { $ conditions = [ ] ; foreach ( $ typeLegends as $ value => $ legends ) { $ valueCondition = new FilterSettingTypeSubPaletteCondition ( $ this -> filterFactory , $ value ) ; foreach ( $ legends as $ legendName => $ legendProperties ) { $ legend = $ this -> getLegend ( $ palette , $ legendName ) ; foreach ( $ legendProperties as $ propertyName ) { $ this -> getConditionChain ( $ legend , $ propertyName , $ conditions ) -> addCondition ( $ valueCondition ) ; } } } }
2264	public function tableExists ( $ strTable , $ strDatabase = null , $ blnNoCache = false ) { if ( $ strTable == '' ) { return false ; } return \ in_array ( $ strTable , $ this -> listTables ( $ strDatabase , $ blnNoCache ) ) ; }
11340	public function generateRules ( $ table ) { $ types = [ ] ; $ lengths = [ ] ; foreach ( $ table -> columns as $ column ) { if ( $ column -> autoIncrement ) { continue ; } if ( ! $ column -> allowNull && $ column -> defaultValue === null && ! $ column -> isPrimaryKey ) { $ types [ 'required' ] [ ] = $ column -> name ; } switch ( $ column -> type ) { case Schema :: TYPE_SMALLINT : case Schema :: TYPE_INTEGER : case Schema :: TYPE_BIGINT : $ types [ 'integer' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_BOOLEAN : $ types [ 'boolean' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_FLOAT : case Schema :: TYPE_DECIMAL : case Schema :: TYPE_MONEY : $ types [ 'number' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_DATE : case Schema :: TYPE_TIME : case Schema :: TYPE_DATETIME : case Schema :: TYPE_TIMESTAMP : if ( ! in_array ( $ column -> name , [ 'created' , 'deleted' , 'modified' ] ) ) { $ types [ 'safe' ] [ ] = $ column -> name ; } break ; default : if ( $ column -> size > 0 ) { $ lengths [ $ column -> size ] [ ] = $ column -> name ; } else { $ types [ 'string' ] [ ] = $ column -> name ; } } } $ rules = [ ] ; foreach ( $ types as $ type => $ columns ) { $ rules [ ] = "[['" . implode ( "', '" , $ columns ) . "'], '$type']" ; } foreach ( $ lengths as $ length => $ columns ) { $ rules [ ] = "[['" . implode ( "', '" , $ columns ) . "'], 'string', 'max' => $length]" ; } return $ rules ; }
5088	public function queryMap ( $ key = 0 , $ value = 1 ) { $ fetchMode = $ this -> resolveFetchMode ( is_string ( $ key ) || is_string ( $ value ) ) ; $ result = $ this -> execute ( ) ; $ map = [ ] ; try { while ( $ row = $ result -> fetch ( $ fetchMode ) ) { if ( ! isset ( $ row [ $ key ] ) || ! key_exists ( $ value , $ row ) ) throw new MySqlException ( "Key '$key' or Value '$value' columns not found in the query result: " . implode ( array_keys ( $ row ) ) ) ; $ map [ $ row [ $ key ] ] = $ row [ $ value ] ; } } finally { $ result -> closeCursor ( ) ; } return $ map ; }
10953	protected function ifModSince ( Request $ request , Response $ response , int $ timestamp ) : Response { $ ifModSince = $ request -> getHeaderLine ( 'If-Modified-Since' ) ; if ( $ ifModSince && $ timestamp <= strtotime ( $ ifModSince ) ) { return $ response -> withStatus ( 304 , "Not Modified" ) ; } return $ response ; }
4567	public function resolve ( Form $ form ) { switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ resolve = function ( & $ component ) use ( & $ resolve , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as & $ subComponent ) { $ resolve ( $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as & $ subComponent ) { $ resolve ( $ subComponent ) ; } } break ; case property_exists ( $ component , 'defaultValue' ) : if ( null !== $ component -> defaultValue ) { try { $ component -> defaultValue = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ component -> defaultValue = null ; } catch ( UnmatchedException $ exception ) { } } break ; } } ; foreach ( $ components as & $ component ) { $ resolve ( $ component ) ; } $ form -> setSchema ( $ components ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ form ; }
12951	public function afterDelete ( ) { if ( ! empty ( $ this -> _tagsForDelete ) ) { $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ class = $ relation -> modelClass ; $ class :: updateAllCounters ( [ 'count' => - 1 ] , [ 'in' , $ class :: primaryKey ( ) , $ this -> _tagsForDelete ] ) ; $ this -> owner -> getDb ( ) -> createCommand ( ) -> delete ( $ relation -> via -> from [ 0 ] , [ key ( $ relation -> via -> link ) => $ this -> owner -> getPrimaryKey ( ) ] ) -> execute ( ) ; } $ this -> _tagsForDelete = [ ] ; } }
11264	public function repeat ( & $ property , $ repeatTag , $ classes = '' , $ outerTag = false , $ outerClasses = '' ) { if ( isset ( $ property ) ) { $ output = '' ; if ( $ outerTag ) { $ output .= '<' . $ outerTag . ' class="' . $ outerClasses . '">' ; } if ( is_array ( $ property ) ) { foreach ( $ property as $ value ) { $ output .= '<' . $ repeatTag . ' class="' . $ classes . '">' ; $ output .= $ value ; $ output .= '</' . $ repeatTag . '>' ; } } else { $ output .= '<' . $ repeatTag . ' class="' . $ classes . '">' ; $ output .= $ property ; $ output .= '</' . $ repeatTag . '>' ; } if ( $ outerTag ) { $ output .= '</' . $ outerTag . '>' ; } echo $ output ; } else echo '' ; }
6586	protected function request ( array $ options ) { $ this -> info = null ; $ this -> setOpt ( $ options ) ; $ result = $ this -> perform ( 'curl_exec' ) ; $ this -> info = $ this -> perform ( 'curl_getinfo' ) ; return $ result ; }
190	private function loadTableColumnsInfo ( $ tableName ) { $ tableColumns = $ this -> db -> createCommand ( 'PRAGMA TABLE_INFO (' . $ this -> quoteValue ( $ tableName ) . ')' ) -> queryAll ( ) ; $ tableColumns = $ this -> normalizePdoRowKeyCase ( $ tableColumns , true ) ; return ArrayHelper :: index ( $ tableColumns , 'cid' ) ; }
2630	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ comment = $ this -> getRequest ( ) -> getParam ( 'comment_value' ) ; $ negated = 0 ; if ( $ value [ 0 ] == '!' ) { $ negated = 1 ; $ value = ltrim ( $ value , '!' ) ; } $ ipParts = explode ( '/' , $ value ) ; $ subnet = false ; if ( ! empty ( $ ipParts [ 1 ] ) ) { if ( is_numeric ( $ ipParts [ 1 ] ) && ( int ) $ ipParts [ 1 ] < 129 ) { $ subnet = $ ipParts [ 1 ] ; } else { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP subnet format.' ] ) ; } } if ( ! filter_var ( $ ipParts [ 0 ] , FILTER_VALIDATE_IP ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP address format.' ] ) ; } $ createAclItem = $ this -> api -> upsertAclItem ( $ aclId , $ ipParts [ 0 ] , $ negated , $ comment , $ subnet ) ; if ( ! $ createAclItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Acl entry.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'id' => $ createAclItem -> id , 'comment' => $ createAclItem -> comment , 'created_at' => $ createAclItem -> created_at ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
726	public function getAttribute ( $ attribute ) { try { return parent :: getAttribute ( $ attribute ) ; } catch ( \ PDOException $ e ) { switch ( $ attribute ) { case self :: ATTR_SERVER_VERSION : return $ this -> query ( "SELECT CAST(SERVERPROPERTY('productversion') AS VARCHAR)" ) -> fetchColumn ( ) ; default : throw $ e ; } } }
3324	public function advance ( ) { if ( $ this -> index >= $ this -> length ) { throw new LogicException ( "Argument index out of bounds." ) ; } return $ this -> argv [ $ this -> index ++ ] ; }
1347	public function isReadProcesses ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isProcesses ( ) && $ this -> getRoute ( ) -> isNotProcess ( ) ; }
8627	public function setGetCompetitivePricingForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetCompetitivePricingForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3476	protected function request ( $ verb , $ endpoint , array $ data ) { $ url = rtrim ( $ this -> baseUrl , '/' ) . '/' . ltrim ( $ endpoint , '/' ) ; try { $ response = $ this -> httpClient -> request ( $ verb , $ url , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , 'json' => $ data , ] ) ; } catch ( RequestException $ exception ) { if ( $ response = $ exception -> getResponse ( ) ) { throw CouldNotSendNotification :: serviceRespondedWithAnHttpError ( $ response ) ; } throw CouldNotSendNotification :: serviceCommunicationError ( $ exception ) ; } catch ( Exception $ exception ) { throw CouldNotSendNotification :: serviceCommunicationError ( $ exception ) ; } $ body = json_decode ( $ response -> getBody ( ) , true ) ; if ( Arr :: get ( $ body , 'code' , 0 ) > 0 ) { throw CouldNotSendNotification :: serviceRespondedWithAnApiError ( $ body ) ; } return $ body ; }
8486	public static function getCpuVendor ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT Manufacturer FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> Manufacturer ; } return 'Unknown' ; }
3304	public function appendSignature ( array $ params = [ ] , $ timestamp = '' , $ noncestr = '' ) { $ params += [ 'app_id' => $ this -> appId , 'time_stamp' => $ timestamp ? : time ( ) , 'nonce_str' => $ noncestr ? : md5 ( uniqid ( ) ) ] ; if ( isset ( $ params [ 'app_key' ] ) ) { unset ( $ params [ 'app_key' ] ) ; } ksort ( $ params ) ; $ params [ 'sign' ] = strtoupper ( md5 ( http_build_query ( $ params + [ 'app_key' => $ this -> appKey ] ) ) ) ; return $ params ; }
1879	public function protect ( ) { @ trigger_error ( 'Using DC_Folder::protect() has been deprecated and will no longer work in Contao 5.0. Use Contao\Folder::protect() and Contao\Folder::unprotect() instead.' , E_USER_DEPRECATED ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ this -> intId ) ) { throw new InternalServerErrorException ( 'Resource "' . $ this -> intId . '" is not a directory.' ) ; } if ( file_exists ( $ this -> strRootDir . '/' . $ this -> intId . '/.public' ) ) { $ objFolder = new Folder ( $ this -> intId ) ; $ objFolder -> protect ( ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> generateSymlinks ( ) ; $ this -> log ( 'Folder "' . $ this -> intId . '" has been protected' , __METHOD__ , TL_FILES ) ; } else { $ objFolder = new Folder ( $ this -> intId ) ; $ objFolder -> unprotect ( ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> generateSymlinks ( ) ; $ this -> log ( 'The protection from folder "' . $ this -> intId . '" has been removed' , __METHOD__ , TL_FILES ) ; } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
3471	public function merge ( Config $ config ) : Config { $ this -> config = array_merge_recursive ( $ this -> config , $ config -> config ) ; return $ this ; }
3770	protected function internalCreateRenderSetting ( IMetaModel $ metaModel , $ settingId ) { $ row = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_rendersettings' ) -> where ( 'pid=:pid' ) -> andWhere ( 'id=:id' ) -> setParameter ( 'pid' , $ metaModel -> get ( 'id' ) ) -> setParameter ( 'id' , $ settingId ? : 0 ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( ! $ row ) { $ row = [ ] ; } $ renderSetting = new Collection ( $ metaModel , $ row , $ this -> eventDispatcher , $ this -> filterFactory , $ this -> filterUrlBuilder ) ; if ( $ renderSetting -> get ( 'id' ) ) { $ this -> collectAttributeSettings ( $ metaModel , $ renderSetting ) ; } return $ renderSetting ; }
7176	public static function extract ( $ array , array $ paths , $ default = null ) { $ found = array ( ) ; foreach ( $ paths as $ path ) { static :: set_path ( $ found , $ path , static :: path ( $ array , $ path , $ default ) ) ; } return $ found ; }
5453	public function endElement ( $ name ) { if ( $ name === 'label' ) { $ this -> acceptLabelEnd ( ) ; return true ; } if ( $ name === 'form' ) { $ this -> acceptFormEnd ( ) ; return true ; } if ( $ name === 'frameset' ) { $ this -> acceptFramesetEnd ( ) ; return true ; } if ( $ this -> hasNamedTagOnOpenTagStack ( $ name ) ) { $ tag = array_pop ( $ this -> tags [ $ name ] ) ; if ( $ tag -> isPrivateContent ( ) && $ this -> private_content_tag -> getTagName ( ) == $ name ) { unset ( $ this -> private_content_tag ) ; } $ this -> addContentTagToOpenTags ( $ tag ) ; $ this -> acceptTag ( $ tag ) ; return true ; } return true ; }
10111	private function writeSheetProtection ( ) { $ record = 0x0867 ; $ options = ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getObjects ( ) | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getScenarios ( ) << 1 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatCells ( ) << 2 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatColumns ( ) << 3 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatRows ( ) << 4 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertColumns ( ) << 5 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertRows ( ) << 6 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertHyperlinks ( ) << 7 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getDeleteColumns ( ) << 8 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getDeleteRows ( ) << 9 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSelectLockedCells ( ) << 10 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSort ( ) << 11 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getAutoFilter ( ) << 12 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getPivotTables ( ) << 13 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSelectUnlockedCells ( ) << 14 ; $ recordData = pack ( 'vVVCVVvv' , 0x0867 , 0x0000 , 0x0000 , 0x00 , 0x01000200 , 0xFFFFFFFF , $ options , 0x0000 ) ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
6178	private function keySort ( $ a , $ b , $ c = null ) { $ d = $ c !== null ? $ c : 1 ; if ( $ a == $ b ) { return 0 ; } return ( $ a > $ b ) ? 1 * $ d : - 1 * $ d ; }
3655	private function getLabelText ( $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc.' . $ type , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc.' . $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc._default_' , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc._default_' ) { return $ type ; } } return $ label ; }
4847	public static function unregister ( ) { if ( isset ( self :: $ autoloadFn ) ) { spl_autoload_unregister ( self :: $ autoloadFn ) ; self :: $ autoloadFn = null ; } self :: $ aliases = [ ] ; }
7149	private function calculateAdjustment ( AdjustmentDataInterface $ adjustment , $ base ) { if ( $ adjustment -> getMode ( ) === AdjustmentModes :: MODE_PERCENT ) { return Money :: round ( $ base * $ adjustment -> getAmount ( ) / 100 , $ this -> currency ) ; } if ( $ adjustment -> getMode ( ) === AdjustmentModes :: MODE_FLAT ) { return $ adjustment -> getAmount ( ) ; } throw new InvalidArgumentException ( "Unexpected adjustment mode." ) ; }
9425	public function f ( ) { if ( is_null ( $ this -> arr_f ) ) { $ arr = $ this -> frequency ( ) ; array_walk ( $ arr , function ( & $ v , $ k , $ n ) { $ v = $ v / $ n ; } , count ( $ this ) ) ; $ this -> arr_f = $ arr ; } return $ this -> arr_f ; }
9124	private function appendPayloadToRequest ( MemoryStream $ ms ) : MemoryStream { $ this -> payload -> reset ( ) ; while ( $ this -> payload -> ready ( ) ) { $ ms -> write ( $ this -> payload -> read ( 1024 ) ) ; } $ ms -> reset ( ) ; return $ ms ; }
6840	public function getData ( $ key ) { if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } throw new InjectorException ( "data $key not found" ) ; }
8004	public static function forString ( $ string , $ code = self :: CODE_FOR_STRING , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . sprintf ( self :: MESSAGE_EXTENSION_FOR_STRING_FORMAT , $ string ) ; return new static ( $ message , $ code , $ previous ) ; }
1477	public function update ( $ resourceType , $ id , array $ queryParams = [ ] ) { return $ this -> resource ( RouteName :: update ( $ resourceType ) , $ id , $ queryParams ) ; }
1398	public function error ( $ error , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( is_string ( $ error ) ) { $ error = $ this -> api -> getErrors ( ) -> error ( $ error ) ; } else if ( is_array ( $ error ) ) { $ error = Error :: create ( $ error ) ; } if ( ! $ error instanceof ErrorInterface ) { throw new \ InvalidArgumentException ( 'Expecting a string, array or error object.' ) ; } return $ this -> errors ( $ error , $ defaultStatusCode , $ headers ) ; }
6282	public static function buildHttpClient ( LoopInterface $ loop , $ connector = null ) { if ( class_exists ( HttpClientFactory :: class ) ) { return static :: buildHttpClient04 ( $ loop , $ connector ) ; } else { return static :: buildHttpClient05 ( $ loop , $ connector ) ; } }
9580	public function setDeferredChannel ( $ channel , callable $ callback ) { if ( isset ( $ this -> channels [ $ channel ] ) ) { throw new InvalidArgumentException ( "Channel $channel is already defined" ) ; } $ this -> deferredChannels [ $ channel ] = $ callback ; }
5810	public function updateSearchableFields ( & $ fields ) { $ fields = array_merge ( array ( 'Tagging' => array ( 'title' => 'Tags' , 'field' => ListboxField :: create ( 'Tagging' , 'Tags' , FusionTag :: get ( ) -> map ( 'Title' , 'Title' ) -> toArray ( ) , ( Controller :: has_curr ( ) && ( $ filtering = Controller :: curr ( ) -> getRequest ( ) -> getVar ( 'q' ) ) && isset ( $ filtering [ 'Tagging' ] ) ) ? $ filtering [ 'Tagging' ] : array ( ) , null , true ) , 'filter' => $ this -> owner -> dbObject ( 'Tagging' ) -> stat ( 'default_search_filter_class' ) ) ) , $ fields ) ; $ this -> owner -> extend ( 'updateTaggingExtensionSearchableFields' , $ fields ) ; }
9666	private function writeFill ( XMLWriter $ objWriter , Fill $ pFill ) { if ( $ pFill -> getFillType ( ) === Fill :: FILL_GRADIENT_LINEAR || $ pFill -> getFillType ( ) === Fill :: FILL_GRADIENT_PATH ) { $ this -> writeGradientFill ( $ objWriter , $ pFill ) ; } elseif ( $ pFill -> getFillType ( ) !== null ) { $ this -> writePatternFill ( $ objWriter , $ pFill ) ; } }
6777	protected function updateVatData ( SaleInterface $ sale ) { $ changed = false ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( 0 == strlen ( $ sale -> getVatNumber ( ) ) && 0 < strlen ( $ customer -> getVatNumber ( ) ) ) { $ sale -> setVatNumber ( $ customer -> getVatNumber ( ) ) ; $ changed = true ; } if ( empty ( $ sale -> getVatDetails ( ) ) && ! empty ( $ customer -> getVatDetails ( ) ) ) { $ sale -> setVatDetails ( $ customer -> getVatDetails ( ) ) ; $ changed = true ; } if ( ! $ sale -> isVatValid ( ) && $ customer -> isVatValid ( ) ) { $ sale -> setVatValid ( true ) ; $ changed = true ; } } return $ changed ; }
9034	protected function init ( $ key ) { if ( ! isset ( $ this -> files [ $ key ] ) ) { $ this -> files [ $ key ] = fopen ( $ this -> dir . $ key . '.lockfile' , 'w+' ) ; $ this -> owns [ $ key ] = false ; } }
5336	protected function encodeParameters ( $ parameters , $ keyPrefix = null ) { if ( ! is_array ( $ parameters ) && ! is_object ( $ parameters ) ) { return rawurlencode ( $ parameters ) ; } $ encodedData = [ ] ; foreach ( $ parameters as $ key => $ value ) { $ encodedKey = is_null ( $ keyPrefix ) ? rawurlencode ( $ key ) : $ keyPrefix . '[' . rawurlencode ( $ key ) . ']' ; if ( is_array ( $ value ) || is_object ( $ value ) ) { $ encodedData [ ] = $ this -> encodeParameters ( $ value , $ encodedKey ) ; } else { $ encodedData [ ] = $ encodedKey . '=' . rawurlencode ( $ value ) ; } } return implode ( '&' , $ encodedData ) ; }
2180	private function findIn ( string $ path ) : Finder { return Finder :: create ( ) -> ignoreDotFiles ( false ) -> sort ( static function ( SplFileInfo $ a , SplFileInfo $ b ) : int { $ countA = substr_count ( strtr ( $ a -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; $ countB = substr_count ( strtr ( $ b -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; return $ countA <=> $ countB ; } ) -> followLinks ( ) -> in ( $ path ) ; }
7214	public function debit ( $ account , $ amount , \ DateTime $ date ) { $ data = [ $ this -> date , $ account , $ this -> identity , null , $ amount , $ this -> number , $ date -> format ( 'Y-m-d' ) , ] ; if ( false === fputcsv ( $ this -> handle , $ data , ';' , '"' ) ) { throw new RuntimeException ( "Failed to write line." ) ; } }
2763	public function isCloned ( ) : bool { if ( $ this -> cloned === null ) { $ gitDir = $ this -> directory ; if ( is_dir ( $ gitDir . '/.git' ) ) { $ gitDir .= '/.git' ; } $ this -> cloned = is_dir ( $ gitDir . '/objects' ) && is_dir ( $ gitDir . '/refs' ) && is_file ( $ gitDir . '/HEAD' ) ; } return $ this -> cloned ; }
429	public function getUniqueId ( ) { return $ this -> module ? ltrim ( $ this -> module -> getUniqueId ( ) . '/' . $ this -> id , '/' ) : $ this -> id ; }
1391	protected function resourceFieldsExistInAttributesAndRelationships ( iterable $ fields ) : void { foreach ( $ fields as $ field ) { $ this -> errors -> add ( $ this -> translator -> resourceFieldExistsInAttributesAndRelationships ( $ field ) ) ; } }
11142	public function getAttributes ( $ props ) { $ attr = '' ; if ( isset ( $ props [ 'primaryKey' ] ) ) { $ attr .= 'NOT NULL AUTO_INCREMENT ' ; } if ( isset ( $ props [ 'defaultValue' ] ) ) { $ attr .= "DEFAULT '" . $ props [ 'defaultValue' ] . "'" ; } return $ attr ; }
11221	private static function routeValidator ( ) { self :: $ uri = Url :: getUriMethods ( ) ; self :: $ uri = Url :: setUrlParams ( self :: $ uri ) ; self :: $ uri = Url :: addBackSlash ( self :: $ uri ) ; self :: cleanResources ( ) ; if ( self :: getMethod ( self :: $ uri ) ) { self :: any ( self :: $ uri , self :: $ routes [ self :: $ uri ] ) ; } }
5806	public function validate ( ValidationResult $ result ) { $ validate = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ validate = $ field ; } } if ( $ result -> valid ( ) && ! $ this -> owner -> $ validate ) { $ result -> error ( "\"{$validate}\" required!" ) ; } $ this -> owner -> extend ( 'validateFusionExtension' , $ result ) ; return $ result ; }
5604	public function paintMethodStart ( $ method ) { $ this -> pass = false ; $ this -> fail = false ; $ this -> error = false ; $ this -> method = self :: escapeVal ( $ method ) ; }
12597	public function getCacheAdapter ( $ namespace ) { if ( ! $ this -> isCacheable ( $ namespace ) ) { return null ; } if ( is_array ( $ this -> cacheOptions -> getAdapter ( ) ) ) { if ( ! isset ( $ this -> cacheOptions -> getAdapter ( ) [ $ namespace ] ) ) { return null ; } $ adapter = $ this -> cacheOptions -> getAdapter ( ) [ $ namespace ] ; } else { $ adapter = $ this -> cacheOptions -> getAdapter ( ) ; } if ( is_object ( $ adapter ) ) { return $ adapter ; } if ( $ this -> getServiceLocator ( ) -> has ( $ adapter ) ) { return $ this -> getServiceLocator ( ) -> get ( $ adapter ) ; } return new $ adapter ; }
8183	public function getMemoryUsage ( ) { return isset ( $ this -> ends [ 'mu' ] ) && isset ( $ this -> starts [ 'mu' ] ) ? $ this -> ends [ 'mu' ] - $ this -> starts [ 'mu' ] : 0 ; }
3820	private function perform ( $ table , Request $ request , $ metaModel , $ parentId ) { $ activate = ( bool ) $ request -> request -> get ( 'activate' ) ; $ query = $ this -> connection -> createQueryBuilder ( ) -> insert ( $ table ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( $ this -> knowsAttribute ( $ attribute ) || ! ( $ this -> accepts ( $ attribute ) && $ this -> isAttributeSubmitted ( $ attribute -> get ( 'id' ) , $ request ) ) ) { continue ; } $ data = [ ] ; foreach ( $ this -> createEmptyDataFor ( $ attribute , $ parentId , $ activate , $ this -> startSort ) as $ key => $ value ) { $ data [ $ key ] = ':' . $ key ; $ query -> setParameter ( $ key , $ value ) ; } $ query -> values ( $ data ) -> execute ( ) ; $ this -> startSort += 128 ; } $ this -> purger -> purge ( ) ; }
1097	public static function to ( $ node , $ target , $ position ) { $ instance = new static ( $ node , $ target , $ position ) ; return $ instance -> perform ( ) ; }
3881	private function getPageDetails ( $ pageId ) { if ( empty ( $ pageId ) ) { return array ( ) ; } $ event = new GetPageDetailsEvent ( $ pageId ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; return $ event -> getPageDetails ( ) ; }
5841	public function addRole ( $ role ) { if ( is_string ( $ role ) ) { $ role = new Role ( $ role ) ; } elseif ( ! $ role instanceof RoleInterface ) { throw new \ InvalidArgumentException ( sprintf ( 'Role must be a string or RoleInterface instance, but got %s.' , gettype ( $ role ) ) ) ; } if ( ! \ in_array ( $ role , $ this -> roles ) ) { $ this -> roles [ ] = $ role ; } }
6482	public function assertNoErrorMessages ( ) { foreach ( $ this -> getMessagesContainers ( 'error' ) as $ element ) { $ text = trim ( $ element -> getText ( ) ) ; if ( '' !== $ text ) { throw new \ RuntimeException ( sprintf ( 'The page "%s" contains following error messages: "%s".' , self :: $ pageUrl , $ text ) ) ; } } foreach ( $ this -> getSession ( ) -> getPage ( ) -> findAll ( 'css' , 'input, select, textarea' ) as $ formElement ) { if ( $ formElement -> hasClass ( 'error' ) ) { throw new \ Exception ( sprintf ( 'Element "#%s" has an error class.' , $ formElement -> getAttribute ( 'id' ) ) ) ; } } }
1989	public static function addToUrl ( $ strRequest , $ blnIgnoreParams = false , $ arrUnset = array ( ) ) { $ arrGet = $ blnIgnoreParams ? array ( ) : $ _GET ; foreach ( array_keys ( $ arrGet ) as $ key ) { $ arrGet [ $ key ] = Input :: get ( $ key , true , true ) ; } $ arrFragments = preg_split ( '/&(amp;)?/i' , $ strRequest ) ; foreach ( $ arrFragments as $ strFragment ) { list ( $ key , $ value ) = explode ( '=' , $ strFragment ) ; if ( $ value == '' ) { unset ( $ arrGet [ $ key ] ) ; } else { $ arrGet [ $ key ] = $ value ; } } if ( Config :: get ( 'addLanguageToUrl' ) ) { unset ( $ arrGet [ 'language' ] ) ; } $ strParams = '' ; $ strConnector = '/' ; $ strSeparator = '/' ; foreach ( $ arrGet as $ k => $ v ) { if ( Config :: get ( 'useAutoItem' ) && ( $ k == 'auto_item' || \ in_array ( $ k , $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) ) { $ strParams = $ strConnector . urlencode ( $ v ) . $ strParams ; } else { $ strParams .= $ strConnector . urlencode ( $ k ) . $ strSeparator . urlencode ( $ v ) ; } } global $ objPage ; $ pageId = $ objPage -> alias ? : $ objPage -> id ; if ( empty ( $ pageId ) ) { $ pageId = static :: getPageIdFromUrl ( ) ; } $ arrParams = array ( ) ; $ arrParams [ 'alias' ] = $ pageId . $ strParams ; if ( Config :: get ( 'addLanguageToUrl' ) ) { $ arrParams [ '_locale' ] = $ objPage -> rootLanguage ; } $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_frontend' , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; return $ strUrl ; }
6169	protected function writeException ( $ exception ) { $ this -> writeNewLine ( ) ; do { $ exceptionStack [ ] = $ exception ; } while ( $ exception = $ exception -> getPreviousWrapped ( ) ) ; foreach ( explode ( "\n" , $ exception = array_shift ( $ exceptionStack ) ) as $ line ) { if ( $ exception && false !== $ pos = strpos ( $ line , $ exception -> getClassName ( ) . ': ' ) ) { $ whitespace = str_repeat ( ' ' , ( $ pos += strlen ( $ exception -> getClassName ( ) ) ) + 2 ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , sprintf ( ' %s ' , substr ( $ line , 0 , $ pos ) ) , false ) ; $ this -> writeWithColor ( 'fg-red' , substr ( $ line , $ pos + 1 ) ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ exception = array_shift ( $ exceptionStack ) ; continue ; } $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
5072	public function getHtmlMenu ( $ markup , $ topLevel = 1 , $ depth = 6 , RendererInterface $ renderer = null ) { if ( ! $ renderer ) { $ renderer = new ListRenderer ( new Matcher ( ) , [ 'currentClass' => 'active' , 'ancestorClass' => 'active_ancestor' ] ) ; } return $ renderer -> render ( $ this -> getMenu ( $ markup , $ topLevel , $ depth ) ) ; }
12037	function generate ( ) { if ( $ this -> namespace ) { $ fqcn = $ this -> namespace . '\\' . $ this -> className ; } else { $ fqcn = $ this -> className ; } $ this -> addProperties ( ) ; $ this -> addConstructorMethod ( ) ; $ this -> addSetAPIMethod ( ) ; $ this -> addSetParameterMethod ( ) ; $ this -> addCheckScopeMethod ( ) ; $ this -> addAccessorMethods ( ) ; $ this -> addFilteredParameterMethod ( ) ; $ this -> addCreateRequestMethod ( ) ; $ this -> addCreateAndExecuteMethod ( ) ; $ this -> addCallMethod ( ) ; $ this -> addExecuteMethod ( ) ; $ this -> addExecuteAsyncMethod ( ) ; $ this -> addDispatchMethod ( ) ; $ this -> addDispatchAsyncMethod ( ) ; $ this -> addProcessResponseMethod ( ) ; $ this -> addShouldResponseBeProcessedMethod ( ) ; $ this -> addTranslateResponseToExceptionMethod ( ) ; $ this -> addShouldUseCachedResponseMethod ( ) ; $ this -> addShouldResponseBeCachedMethod ( ) ; $ this -> addSetOriginalResponseMethod ( ) ; $ this -> addGetOriginalResponseMethod ( ) ; $ this -> addGetResultInstantiationInfoMethod ( ) ; $ this -> classGenerator -> setImplementedInterfaces ( [ 'ArtaxServiceBuilder\Operation' ] ) ; $ this -> classGenerator -> setFQCN ( $ fqcn ) ; $ text = $ this -> classGenerator -> generate ( ) ; saveFile ( $ this -> outputPath , $ fqcn , $ text ) ; }
4850	public function prepare ( $ value ) { $ importer = $ this -> getVariably ( ) -> get ( 'importer' ) ; $ table = $ importer -> getCurrentTable ( ) ; if ( ! isset ( $ this -> counter [ $ table ] ) ) { $ db = $ importer -> getDb ( ) ; $ counter = $ db -> fetchOne ( 'SELECT MAX(DISTINCT counter) AS counter FROM ' . $ table ) ; $ this -> counter [ $ table ] = $ counter [ 'counter' ] + 1 ; } return $ this -> counter [ $ table ] ; }
7732	public function denormalize ( $ data , $ class , $ format = null , array $ context = array ( ) ) { $ value = $ data ; if ( is_array ( $ data ) ) { if ( ! isset ( $ data [ '@value' ] ) || ! isset ( $ data [ '@type' ] ) ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a valid JSON-LD typed value: " . var_export ( $ data , true ) ) ; } if ( self :: XSD_DATETIME_IRI !== $ data [ '@type' ] ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a XSD dateTime value: " . var_export ( $ data , true ) ) ; } $ value = $ data [ '@value' ] ; } elseif ( ! is_string ( $ data ) ) { throw new RuntimeException ( "Cannot denormalize the data into a DateTime object: " . var_export ( $ data , true ) ) ; } try { $ date = new \ DateTime ( $ value ) ; return $ date ; } catch ( Exception $ e ) { throw new RuntimeException ( "Cannot denormalize the data as the value is invalid: " . var_export ( $ data , true ) , 0 , $ e ) ; } }
6044	public function view ( $ sessionId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaId' => $ mediaId ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/view' , $ parameters , true ) ; return $ result ; }
666	public function renderItems ( ) { $ models = $ this -> dataProvider -> getModels ( ) ; $ keys = $ this -> dataProvider -> getKeys ( ) ; $ rows = [ ] ; foreach ( array_values ( $ models ) as $ index => $ model ) { $ key = $ keys [ $ index ] ; if ( ( $ before = $ this -> renderBeforeItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ before ; } $ rows [ ] = $ this -> renderItem ( $ model , $ key , $ index ) ; if ( ( $ after = $ this -> renderAfterItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ after ; } } return implode ( $ this -> separator , $ rows ) ; }
10226	public function noAssociationsMenuFor ( $ model , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ menuFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\NoAssociationsIndexMenuFactory' ) ; return $ menuFactory -> create ( $ modelName , $ config ) ; }
10081	protected function registerManager ( ) { $ this -> app -> singleton ( 'auja' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new Auja ( $ app , $ app [ 'auja.configurator' ] , $ config [ 'models' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Auja' , 'auja' ) ; }
12179	public function getPhotoEmail ( ) { if ( ! empty ( $ this -> email ) && substr ( $ this -> email , - 6 ) !== ".local" ) { return $ this -> email ; } return false ; }
3762	private function getConditionChain ( LegendInterface $ legend , $ propertyName , array & $ conditions ) { if ( isset ( $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] ) ) { return $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] ; } $ property = $ this -> getLegendProperty ( $ legend , $ propertyName ) ; $ condition = $ this -> getVisibleCondition ( $ property ) ; $ orCondition = new PropertyConditionChain ( ) ; $ orCondition -> setConjunction ( PropertyConditionChain :: OR_CONJUNCTION ) ; $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] = $ orCondition ; $ condition -> addCondition ( $ orCondition ) ; return $ orCondition ; }
11723	public function collectActivity ( PostActionEvent $ event ) { $ this -> activity [ ] = array ( 'action_name' => $ event -> getAction ( ) -> getName ( ) , 'group_name' => $ event -> getAction ( ) -> getGroup ( ) -> getName ( ) , 'service_name' => $ event -> getAction ( ) -> getGroup ( ) -> getService ( ) -> getName ( ) , 'execution_time' => round ( $ event -> getExecutionTime ( ) * 1000 , 2 ) , 'arguments' => $ event -> getArguments ( ) , 'extra_data' => $ event -> getExtraData ( ) , ) ; $ this -> totalExecutionTime += $ event -> getExecutionTime ( ) ; $ this -> totalCallCount += 1 ; }
2631	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ read -> getRelativePath ( 'vcl_snippets_custom' ) ; $ customSnippets = $ read -> read ( $ snippetPath ) ; if ( ! $ customSnippets ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'No snippets found.' ] ) ; } $ snippets = [ ] ; foreach ( $ customSnippets as $ snippet ) { $ snippets [ ] = explode ( '/' , $ snippet ) [ 1 ] ; } return $ result -> setData ( [ 'status' => true , 'snippets' => $ snippets ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
305	private function setRelationDependencies ( $ name , $ relation , $ viaRelationName = null ) { if ( empty ( $ relation -> via ) && $ relation -> link ) { foreach ( $ relation -> link as $ attribute ) { $ this -> _relationsDependencies [ $ attribute ] [ $ name ] = $ name ; if ( $ viaRelationName !== null ) { $ this -> _relationsDependencies [ $ attribute ] [ ] = $ viaRelationName ; } } } elseif ( $ relation -> via instanceof ActiveQueryInterface ) { $ this -> setRelationDependencies ( $ name , $ relation -> via ) ; } elseif ( is_array ( $ relation -> via ) ) { list ( $ viaRelationName , $ viaQuery ) = $ relation -> via ; $ this -> setRelationDependencies ( $ name , $ viaQuery , $ viaRelationName ) ; } }
2959	public function confFlowControl ( $ mode ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set flow control mode : the device is " . "either not set or opened" , E_USER_WARNING ) ; return false ; } $ linuxModes = array ( "none" => "clocal -crtscts -ixon -ixoff" , "rts/cts" => "-clocal crtscts -ixon -ixoff" , "xon/xoff" => "-clocal -crtscts ixon ixoff" ) ; $ windowsModes = array ( "none" => "xon=off octs=off rts=on" , "rts/cts" => "xon=off octs=on rts=hs" , "xon/xoff" => "xon=on octs=off rts=on" , ) ; if ( $ mode !== "none" and $ mode !== "rts/cts" and $ mode !== "xon/xoff" ) { trigger_error ( "Invalid flow control mode specified" , E_USER_ERROR ) ; return false ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " " . $ windowsModes [ $ mode ] , $ out ) ; } if ( $ ret === 0 ) { return true ; } else { trigger_error ( "Unable to set flow control : " . $ out [ 1 ] , E_USER_ERROR ) ; return false ; } }
3300	public function post ( $ url , $ params = [ ] ) { $ key = is_array ( $ params ) ? 'form_params' : 'body' ; return $ this -> request ( 'POST' , $ url , [ $ key => $ params ] ) ; }
3434	public function refreshGroups ( ) { if ( $ this -> id === null ) { return [ ] ; } global $ USER ; $ this -> fields [ 'GROUP_ID' ] = $ this -> isCurrent ( ) ? $ USER -> getUserGroupArray ( ) : static :: $ bxObject -> getUserGroup ( $ this -> id ) ; $ this -> groupsAreFetched = true ; return $ this -> fields [ 'GROUP_ID' ] ; }
10040	public function load ( $ pFilename ) { $ spreadsheet = new Spreadsheet ( ) ; $ spreadsheet -> removeSheetByIndex ( 0 ) ; return $ this -> loadIntoExisting ( $ pFilename , $ spreadsheet ) ; }
4282	public function stream_truncate ( $ size ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ ftruncate ( $ this -> handle , $ size ) ; self :: register ( ) ; return $ success ; }
4287	public function getSubscriptions ( ) { if ( ! $ this -> isConnected ( ) ) { $ this -> debug -> alert ( 'WAMP publisher not connected to WAMP router' ) ; return array ( ) ; } $ this -> publishMeta ( ) ; $ this -> processExistingData ( ) ; return array ( 'debug.log' => array ( 'onLog' , PHP_INT_MAX * - 1 ) , 'errorHandler.error' => 'onError' , 'php.shutdown' => array ( 'onShutdown' , PHP_INT_MAX * - 1 ) , ) ; }
12591	protected function checkParams ( $ params , $ operator ) { if ( ! is_array ( $ params ) ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: first param must be an array' ) ; } if ( $ operator == 'IN' ) { if ( count ( $ params ) < 1 ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: IN operator requires at least one param' ) ; } } elseif ( $ operator == 'BETWEEN' ) { if ( count ( $ params ) != 2 ) { throw new Exception ( 'Web2All_Table_MultiValueOperator: BETWEEN operator requires exactly two params' ) ; } } else { throw new Exception ( 'Web2All_Table_MultiValueOperator: unsupported operator "' . $ operator . '"' ) ; } }
7138	protected function getConstraintsForStep ( $ step ) { $ constraints = [ new Valid ( ) ] ; if ( $ step === static :: SHIPMENT_STEP ) { $ constraints [ ] = new Constraints \ SaleShipmentStep ( ) ; } if ( $ step === static :: PAYMENT_STEP ) { $ constraints [ ] = new Constraints \ SaleShipmentStep ( ) ; $ constraints [ ] = new Constraints \ RelayPoint ( ) ; $ constraints [ ] = new Constraints \ SalePaymentStep ( ) ; } return $ constraints ; }
9707	private function writeDefinedNameBiff8 ( $ name , $ formulaData , $ sheetIndex = 0 , $ isBuiltIn = false ) { $ record = 0x0018 ; $ options = $ isBuiltIn ? 0x20 : 0x00 ; $ nlen = StringHelper :: countCharacters ( $ name ) ; $ name = substr ( StringHelper :: UTF8toBIFF8UnicodeLong ( $ name ) , 2 ) ; $ sz = strlen ( $ formulaData ) ; $ data = pack ( 'vCCvvvCCCC' , $ options , 0 , $ nlen , $ sz , 0 , $ sheetIndex , 0 , 0 , 0 , 0 ) . $ name . $ formulaData ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
3500	public function withApnId ( ApnId $ apnId = null ) : Notification { $ cloned = clone $ this ; $ cloned -> apnId = $ apnId ; return $ cloned ; }
132	public function disablePlugins ( ) { foreach ( $ this -> installers as $ i => $ installer ) { if ( ! $ installer instanceof PluginInstaller ) { continue ; } unset ( $ this -> installers [ $ i ] ) ; } }
9	public function authorizeOAuth ( $ originUrl ) { if ( ! in_array ( $ originUrl , $ this -> config -> get ( 'gitlab-domains' ) , true ) ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config gitlab.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , trim ( $ output ) , 'oauth2' ) ; return true ; } $ authTokens = $ this -> config -> get ( 'gitlab-token' ) ; if ( isset ( $ authTokens [ $ originUrl ] ) ) { $ this -> io -> setAuthentication ( $ originUrl , $ authTokens [ $ originUrl ] , 'private-token' ) ; return true ; } return false ; }
8265	protected function onOauthResourceError ( IdentityProviderException $ e ) { $ this -> logger -> critical ( "OAuth2 IdentityProviderException: {e}, provider {provider}" , array ( "e" => $ e -> getMessage ( ) , "provider" => get_class ( $ this -> provider ) , ) ) ; $ this -> session -> addFlash ( "error" , "Failed to get an access token or user details." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
5506	public function returnsAt ( $ timing , $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return value sequence' ) ; $ this -> actions -> registerAt ( $ timing , $ method , $ args , new SimpleReturn ( $ value ) ) ; }
11819	public function addAppDependencies ( ) { $ container = $ this -> getContainer ( ) ; $ container [ 'person' ] = $ container -> protect ( function ( $ name ) { return 'Person name: ' . $ name ; } ) ; return $ this ; }
4742	public function isReviewOptInValidationRequired ( ) { return ( bool ) \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( self :: REVIEW_OPTIN_PARAM ) ; }
9952	public function setBreak ( $ pCoordinate , $ pBreak ) { $ pCoordinate = strtoupper ( $ pCoordinate ) ; if ( $ pCoordinate != '' ) { if ( $ pBreak == self :: BREAK_NONE ) { if ( isset ( $ this -> breaks [ $ pCoordinate ] ) ) { unset ( $ this -> breaks [ $ pCoordinate ] ) ; } } else { $ this -> breaks [ $ pCoordinate ] = $ pBreak ; } } else { throw new Exception ( 'No cell coordinate specified.' ) ; } return $ this ; }
7510	function addError ( $ error ) { $ this -> errors [ ] = htmlentities ( $ error . ' at ' . ( $ this -> line_pos [ 0 ] + 1 ) . ', ' . ( $ this -> pos - $ this -> line_pos [ 1 ] + 1 ) . '!' ) ; }
11299	function getFullClassName ( $ class = false ) { if ( $ class == false ) { $ class = $ this ; } $ className = get_class ( $ class ) ; if ( $ pos = strpos ( $ className , '\\' ) ) return substr ( $ className , $ pos + 1 ) ; return $ className ; }
10967	public static function isSsl ( ) { $ isSecure = false ; if ( isset ( $ _SERVER [ 'HTTPS' ] ) && in_array ( $ _SERVER [ 'HTTPS' ] , [ 'on' , '1' ] ) ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] == 'https' ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] == 'on' ) { $ isSecure = true ; } return $ isSecure ; }
12806	public static function select ( ) : Collection { $ pdo = Database :: connect ( ) ; $ class = self :: getStaticChildClass ( ) ; $ tableName = self :: getTableName ( ) ; $ sql = "SELECT * FROM \"$tableName\"" ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; $ collection = new Collection ( $ class , [ ] ) ; foreach ( $ results as $ result ) { $ object = new $ class ( $ result ) ; $ collection -> push ( $ object ) ; } return $ collection ; }
5182	private function fillSource ( $ source , $ photo ) : string { if ( ! empty ( $ source ) ) { return $ this -> filterUriInstance ( $ source ) ; } return ( string ) $ photo ; }
12032	function addDispatchMethod ( ) { $ methodGenerator = new MethodGenerator ( 'dispatch' ) ; $ body = '' ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= $ this -> generateResponseFragment ( ) ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response. Allows you to modify the request before it is sent.' ) ; $ parameter = new ParameterGenerator ( 'request' , 'Amp\Artax\Request' ) ; $ methodGenerator -> setParameter ( $ parameter ) ; $ tag = createParamTag ( $ parameter , 'The request to be processed' ) ; $ docBlock -> setTag ( $ tag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
8325	public function deletePingback ( $ uri ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=del_pingback&addr={$uri}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
9842	public function createSealedJsonResponse ( int $ status , array $ arrayToJsonify , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSealedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
10942	private function reset ( ) { $ time = new \ DateTime ( ) ; $ this -> driver -> set ( self :: LAST_UPDATE_KEY , $ time ) ; return $ time ; }
590	protected function compressJsFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing JavaScript files...\n" ) ; if ( is_string ( $ this -> jsCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineJsFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> jsCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> jsCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress JavaScript files into '{$outputFile}'." ) ; } $ this -> stdout ( " JavaScript files compressed into '{$outputFile}'.\n" ) ; }
9171	public function getControllerPluginConfig ( ) { return [ 'aliases' => [ 'email' => Controller \ Plugin \ Email :: class , 'mutex' => Controller \ Plugin \ Mutex :: class , 'referer' => Controller \ Plugin \ Referer :: class , 'settings' => Controller \ Plugin \ Settings :: class , 'thumbnail' => Controller \ Plugin \ Thumbnail :: class , 'zettaUrl' => Controller \ Plugin \ Url :: class , ] , 'factories' => [ Controller \ Plugin \ Email :: class => Controller \ Plugin \ Factory \ EmailFactory :: class , Controller \ Plugin \ Mutex :: class => Controller \ Plugin \ Factory \ MutexFactory :: class , Controller \ Plugin \ Referer :: class => InvokableFactory :: class , Controller \ Plugin \ Settings :: class => Factory \ WithSettingsFactory :: class , Controller \ Plugin \ Thumbnail :: class => Factory \ WithThumbnailFactory :: class , Controller \ Plugin \ Url :: class => Factory \ WithUrlConfigFactory :: class , ] , ] ; }
1021	public function toSerializableArray ( ) { $ arr = [ 'message' => $ this -> getMessage ( ) , ] ; $ locations = Utils :: map ( $ this -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ arr [ 'locations' ] = $ locations ; } if ( ! empty ( $ this -> path ) ) { $ arr [ 'path' ] = $ this -> path ; } if ( ! empty ( $ this -> extensions ) ) { $ arr [ 'extensions' ] = $ this -> extensions ; } return $ arr ; }
3499	public function create ( DeviceToken $ deviceToken , bool $ sandbox ) : string { $ uri = 'https://api.push.apple.com/3/device/%s' ; if ( $ sandbox ) { $ uri = 'https://api.development.push.apple.com/3/device/%s' ; } return sprintf ( $ uri , $ deviceToken ) ; }
6138	protected function parseUri ( $ uriString = '' ) { $ status = @ preg_match ( "~^((//)([^/?#]*))([^?#]*)(\?([^#]*))?(#(.*))?$~" , $ uriString , $ matches ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI scheme-specific decomposition failed" ) ; } if ( ! $ status ) { return ; } $ this -> path = ( isset ( $ matches [ 4 ] ) ) ? $ matches [ 4 ] : '' ; $ this -> query = ( isset ( $ matches [ 6 ] ) ) ? $ matches [ 6 ] : '' ; $ this -> fragment = ( isset ( $ matches [ 8 ] ) ) ? $ matches [ 8 ] : '' ; $ status = @ preg_match ( "~^(([^:@]*)(:([^@]*))?@)?([^:]+)(:(.*))?$~" , ( isset ( $ matches [ 3 ] ) ) ? $ matches [ 3 ] : "" , $ matches ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI scheme-specific authority decomposition failed" ) ; } if ( ! $ status ) { return ; } $ this -> user = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : "" ; $ this -> pass = isset ( $ matches [ 4 ] ) ? $ matches [ 4 ] : "" ; $ this -> host = isset ( $ matches [ 5 ] ) ? $ matches [ 5 ] : "" ; $ this -> port = isset ( $ matches [ 7 ] ) ? $ matches [ 7 ] : "" ; }
4596	public function getList ( ) : array { $ objects = $ this -> execute ( 'GET' , static :: RESOURCE_LIST ) ; $ list = [ ] ; foreach ( $ objects as $ name => $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
7012	private function formatF ( & $ str ) { if ( strstr ( $ str , '%F' ) ) $ str = str_replace ( '%F' , $ this -> monthName ( true ) , $ str ) ; }
12656	public function modifyTextContainer ( $ oldName , $ newName , $ content , $ language ) { foreach ( $ this -> languages as $ lang ) { $ modified = false ; $ allTexts = $ this -> getPageTexts ( $ lang ) ; if ( ! isset ( $ allTexts [ $ oldName ] ) ) { throw new \ Exception ( "Text container unknown." ) ; } if ( $ oldName !== $ newName ) { if ( isset ( $ allTexts [ $ newName ] ) ) { throw new \ Exception ( "Text container already exists" ) ; } $ this -> contents [ $ lang ] [ $ newName ] = $ this -> contents [ $ lang ] [ $ oldName ] ; $ this -> contents [ $ lang ] [ $ newName ] [ 'id' ] = $ newName ; $ this -> contents [ $ lang ] [ $ newName ] [ 'name' ] = $ newName ; unset ( $ this -> contents [ $ lang ] [ $ oldName ] ) ; $ modified = true ; } if ( $ language === $ lang ) { $ this -> contents [ $ lang ] [ $ newName ] [ 'content' ] = $ content ; $ this -> contents [ $ lang ] [ $ newName ] [ 'outdated' ] = false ; $ modified = true ; } elseif ( $ language === $ this -> baseLang ) { $ this -> contents [ $ lang ] [ $ newName ] [ 'outdated' ] = true ; $ modified = true ; } if ( $ modified ) { $ this -> writeTextsToFile ( $ lang ) ; } } return $ this -> contents [ $ language ] [ $ newName ] ; }
1533	protected function isFillableRelation ( $ field , $ record ) { return $ this -> isRelation ( $ field ) && $ this -> isFillable ( $ field , $ record ) ; }
5109	public function orderBy ( $ column , $ type = OrderBy :: ASC ) : IWithLimit { if ( $ type == OrderBy :: DESC ) { $ this -> appendDesc ( $ column ) ; } else if ( ! is_array ( $ column ) ) { $ column = [ $ column ] ; } return $ this -> _orderBy ( $ column ) ; }
1312	public function setTimeouts ( $ connectionTimeout , $ timeout ) { $ this -> connectionTimeout = ( int ) $ connectionTimeout ; $ this -> timeout = ( int ) $ timeout ; }
9229	public function delete ( $ path , $ data = array ( ) , $ headers = array ( ) ) { if ( ! empty ( $ data ) ) { $ pathData = [ ] ; $ pos = strpos ( $ path , '?' ) ; if ( $ pos !== false ) { parse_str ( substr ( $ path , $ pos + 1 ) , $ pathData ) ; $ path = substr ( $ path , 0 , $ pos ) ; } $ path .= '?' . $ this -> http_build_query ( array_merge ( $ pathData , $ data ) ) ; } return $ this -> postprocessResponse ( parent :: delete ( $ path , $ headers ) ) ; }
9454	protected function doParse ( StringReader $ string ) { $ val = null ; $ type = substr ( $ string -> read ( 2 ) , 0 , 1 ) ; switch ( $ type ) { case 'a' : $ count = ( int ) $ string -> readUntil ( ':' ) ; $ string -> read ( 1 ) ; $ val = [ ] ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ array_key = $ this -> doParse ( $ string ) ; $ array_value = $ this -> doParse ( $ string ) ; $ val [ $ array_key ] = $ array_value ; } $ string -> read ( 1 ) ; break ; case 'O' : $ len = ( int ) $ string -> readUntil ( ':' ) ; $ class = $ string -> read ( 2 + $ len ) ; $ string -> read ( 1 ) ; $ properties = [ '__class_name' => $ class ] ; $ len = ( int ) $ string -> readUntil ( ':' ) ; $ string -> read ( 1 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ prop_key = $ this -> doParse ( $ string ) ; $ prop_value = $ this -> doParse ( $ string ) ; if ( substr ( $ prop_key , 0 , strlen ( self :: PROTECTED_PREFIX ) ) == self :: PROTECTED_PREFIX ) { $ prop_key = substr ( $ prop_key , strlen ( self :: PROTECTED_PREFIX ) ) ; } if ( substr ( $ prop_key , 0 , 1 ) == "\0" ) { list ( , $ private_class , $ private_property_name ) = explode ( "\0" , $ prop_key ) ; $ prop_key = $ private_property_name ; } $ properties [ $ prop_key ] = $ prop_value ; } $ string -> read ( 1 ) ; $ val = ( object ) $ properties ; break ; case 's' : $ len = ( int ) $ string -> readUntil ( ':' ) ; $ val = $ string -> read ( $ len + 2 ) ; $ string -> read ( 1 ) ; break ; case 'i' : $ val = ( int ) $ string -> readUntil ( ';' ) ; break ; case 'd' : $ val = ( float ) $ string -> readUntil ( ';' ) ; break ; case 'b' : $ bool = $ string -> read ( 2 ) ; $ val = substr ( $ bool , 0 , 1 ) == '1' ; break ; case 'N' : $ val = null ; break ; default : throw new \ Exception ( sprintf ( 'Unable to unserialize type "%s"' , $ type ) ) ; } return $ val ; }
3595	public function registerCpUrlRules ( RegisterUrlRulesEvent $ event ) { if ( ! \ Craft :: $ app -> user -> identity ) return ; $ rules = [ 'settings/sitemap' => [ 'route' => 'sitemap/settings' , 'params' => [ 'source' => 'CpSettings' ] ] , 'settings/sitemap/save-sitemap' => [ 'route' => 'sitemap/settings/save-sitemap' , 'params' => [ 'source' => 'CpSettings' ] ] , ] ; $ event -> rules = array_merge ( $ event -> rules , $ rules ) ; }
8502	public function setMarketplaceIdList ( $ value ) { $ marketplaceIdList = new MarketplaceWebService_Model_IdList ( ) ; $ marketplaceIdList -> setId ( $ value [ 'Id' ] ) ; $ this -> fields [ 'MarketplaceIdList' ] [ 'FieldValue' ] = $ marketplaceIdList ; return ; }
5832	protected function createResponseObject ( $ response ) { $ info = curl_getinfo ( $ this -> ch ) ; $ headerSize = curl_getinfo ( $ this -> ch , CURLINFO_HEADER_SIZE ) ; $ headerText = substr ( $ response , 0 , $ headerSize ) ; $ headers = $ this -> headerToArray ( $ headerText ) ; $ body = substr ( $ response , $ headerSize ) ; $ class = $ this -> responseClass ; $ obj = new $ class ( $ body , $ headers , $ info ) ; return $ obj ; }
2218	public function getFields ( ) { $ arrFields = $ GLOBALS [ 'TL_FFL' ] ; foreach ( array_keys ( $ arrFields ) as $ key ) { $ arrFields [ $ key ] = $ GLOBALS [ 'TL_LANG' ] [ 'FFL' ] [ $ key ] [ 0 ] ; } return $ arrFields ; }
4362	public static function ordUtf8 ( $ str , & $ offset = 0 , & $ char = null ) { $ code = \ ord ( $ str [ $ offset ] ) ; $ numBytes = 1 ; if ( $ code >= 0x80 ) { if ( $ code < 0xe0 ) { $ numBytes = 2 ; $ code -= 0xC0 ; } elseif ( $ code < 0xf0 ) { $ numBytes = 3 ; $ code -= 0xE0 ; } elseif ( $ code < 0xf8 ) { $ numBytes = 4 ; $ code -= 0xF0 ; } for ( $ i = 1 ; $ i < $ numBytes ; $ i ++ ) { $ code2 = \ ord ( $ str [ $ offset + $ i ] ) - 0x80 ; $ code = $ code * 64 + $ code2 ; } } $ char = \ substr ( $ str , $ offset , $ numBytes ) ; $ offset = $ offset + $ numBytes ; return $ code ; }
9372	public function run ( ) { if ( static :: $ container -> has ( self :: ERROR_HANDLER ) ) { $ debugger = static :: $ container -> get ( self :: ERROR_HANDLER ) ; $ debugger -> display ( ) ; } $ request = static :: $ container -> get ( self :: SERVER_REQUEST ) ; echo ( string ) $ this -> emit ( $ request ) -> getBody ( ) ; }
4291	private function publishMeta ( ) { $ debugClass = \ get_class ( $ this -> debug ) ; $ metaVals = array ( 'debug_version' => $ debugClass :: VERSION , ) ; $ keys = array ( 'HTTP_HOST' , 'HTTPS' , 'REMOTE_ADDR' , 'REQUEST_METHOD' , 'REQUEST_TIME' , 'REQUEST_URI' , 'SERVER_ADDR' , 'SERVER_NAME' , ) ; foreach ( $ keys as $ k ) { $ metaVals [ $ k ] = isset ( $ _SERVER [ $ k ] ) ? $ _SERVER [ $ k ] : null ; } if ( ! isset ( $ metaVals [ 'REQUEST_URI' ] ) && ! empty ( $ _SERVER [ 'argv' ] ) ) { $ metaVals [ 'REQUEST_URI' ] = '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; } $ this -> processLogEntry ( 'meta' , array ( $ metaVals , ) , array ( 'channel' => $ this -> debug -> getCfg ( 'channel' ) , ) ) ; }
11031	protected function ensureFieldIds ( ) { if ( $ this -> submitModelName ) { $ formName = Inflector :: slug ( $ this -> submitModelName , '_' ) ; } else { $ model = new \ ReflectionClass ( $ this -> model ) ; $ formName = $ model -> getShortName ( ) ; } $ parts = [ ] ; preg_match_all ( '/{([^}]+)}/' , $ this -> template , $ parts ) ; $ keys = array_flip ( $ parts [ 1 ] ) ; $ fieldIds = [ ] ; if ( isset ( $ keys [ 'country' ] ) ) { $ fieldIds [ 'country' ] = $ formName . '_country_id' ; } if ( isset ( $ keys [ 'state' ] ) ) { $ fieldIds [ 'state' ] = $ formName . '_state_id' ; } if ( isset ( $ keys [ 'region' ] ) ) { $ fieldIds [ 'region' ] = $ formName . '_region_id' ; } if ( isset ( $ keys [ 'city' ] ) ) { $ fieldIds [ 'city' ] = $ formName . '_city_id' ; } if ( isset ( $ keys [ 'address' ] ) ) { $ fieldIds [ 'address' ] = $ formName . '_address' ; } if ( isset ( $ keys [ 'postalCode' ] ) ) { $ fieldIds [ 'postal_code' ] = $ formName . '_postal_code' ; } if ( isset ( $ keys [ 'geolocation' ] ) ) { $ fieldIds [ 'latitude' ] = $ formName . '_latitude' ; $ fieldIds [ 'longitude' ] = $ formName . '_longitude' ; } $ this -> fieldIds = $ fieldIds ; }
521	protected function migrateDown ( $ class ) { if ( $ class === self :: BASE_MIGRATION ) { return true ; } $ this -> stdout ( "*** reverting $class\n" , Console :: FG_YELLOW ) ; $ start = microtime ( true ) ; $ migration = $ this -> createMigration ( $ class ) ; if ( $ migration -> down ( ) !== false ) { $ this -> removeMigrationHistory ( $ class ) ; $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** reverted $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_GREEN ) ; return true ; } $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** failed to revert $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_RED ) ; return false ; }
5773	public function isUpdatable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } if ( $ this -> authorization -> hasTopRole ( ) ) { return true ; } if ( ! $ this -> hasTopRole ( ) ) { return true ; } return false ; }
10722	public function count ( $ col , $ alias , $ distinct = false ) { $ this -> counts [ ] = [ $ col , $ alias , $ distinct ] ; return $ this ; }
5872	public static function getTransformation ( $ orientation ) { $ transformation = '' ; if ( ( isset ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'processor' ] ) && $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'processor' ] === 'ImageMagick' ) || ( isset ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'im_version_5' ] ) && $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'im_version_5' ] !== 'gm' ) ) { if ( $ orientation >= 2 && $ orientation <= 8 ) { $ transformation = '-auto-orient' ; } } else { switch ( $ orientation ) { case 2 : $ transformation = '-flip horizontal' ; break ; case 3 : $ transformation = '-rotate 180' ; break ; case 4 : $ transformation = '-flip vertical' ; break ; case 5 : $ transformation = '-transpose' ; break ; case 6 : $ transformation = '-rotate 90' ; break ; case 7 : $ transformation = '-transverse' ; break ; case 8 : $ transformation = '-rotate 270' ; break ; } } return $ transformation ; }
12851	public function beforeDeleteById ( \ Magento \ Customer \ Api \ CustomerRepositoryInterface $ subject , $ customerId ) { $ this -> deleteDwnl ( $ customerId ) ; $ result = [ $ customerId ] ; return $ result ; }
10524	protected function _unsetData ( $ key ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerUnset ( $ store , $ key ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ key ) ; } }
10903	public function delete ( ) : bool { return ( bool ) $ this -> medoo -> delete ( $ this -> getTable ( ) , [ 'id' => $ this -> getId ( ) ] ) ; }
12036	public function addTranslateResponseToExceptionMethod ( ) { $ body = 'return $this->api->translateResponseToException($response);' ; $ docBlock = new DocBlockGenerator ( 'Determine whether the response is an error. Override this method to have a per-operation decision, otherwise the function from the API class will be used.' , null ) ; $ methodGenerator = $ this -> createMethodGenerator ( 'translateResponseToException' , $ body , $ docBlock , [ [ 'response' , 'Amp\Artax\Response' ] ] , [ 'null' , '\ArtaxServiceBuilder\BadResponseException' ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
5356	public function parseSchema ( $ openApiSpec ) { $ openApiSpecContents = file_get_contents ( $ openApiSpec ) ; $ schemaClass = self :: OPEN_API_MODEL ; $ schema = null ; $ jsonException = null ; $ yamlException = null ; try { return $ this -> serializer -> deserialize ( $ openApiSpecContents , $ schemaClass , self :: CONTENT_TYPE_JSON , [ 'document-origin' => $ openApiSpec ] ) ; } catch ( \ Exception $ exception ) { $ jsonException = $ exception ; } $ content = Yaml :: parse ( $ openApiSpecContents , Yaml :: PARSE_OBJECT | Yaml :: PARSE_OBJECT_FOR_MAP | Yaml :: PARSE_DATETIME | Yaml :: PARSE_EXCEPTION_ON_INVALID_TYPE ) ; $ openApiSpecContents = json_encode ( $ content ) ; return $ this -> serializer -> deserialize ( $ openApiSpecContents , $ schemaClass , self :: CONTENT_TYPE_JSON , [ 'document-origin' => $ openApiSpec ] ) ; }
7056	protected static function dayOfYear ( $ y , $ m , $ d ) { $ l = ( ( int ) $ y % 4 == 0 && ( int ) $ y % 100 != 0 ) || ( int ) $ y % 400 == 0 ; $ k = $ l ? 1 : 2 ; $ n = intval ( 275 * ( int ) $ m / 9 ) - $ k * intval ( ( ( int ) $ m + 9 ) / 12 ) + ( int ) $ d - 30 ; return ( int ) $ n ; }
2744	public function execute ( \ Magento \ Framework \ Event \ Observer $ observer ) { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { $ this -> purgeCache -> sendPurgeRequest ( ) ; } }
7038	public function getShipments ( $ filter = null ) { if ( null === $ filter ) { return $ this -> shipments ; } return $ this -> shipments -> filter ( function ( ShipmentInterface $ shipment ) use ( $ filter ) { return $ filter xor $ shipment -> isReturn ( ) ; } ) ; }
7500	public function requestJson ( $ method , $ url , $ options = array ( ) ) { $ options [ 'headers' ] [ ] = 'Content-Type: application/json' ; $ options [ 'headers' ] [ ] = 'Content-Length: ' . strlen ( $ options [ 'body' ] ) ; $ this -> request ( $ method , $ url , $ options ) ; }
9282	public function getRunning ( array $ options = array ( ) ) { $ where = new Where ( ) ; $ where -> equalTo ( "{$this->tableName}.status" , JobEntity :: STATUS_RUNNING ) ; return $ this -> fetchByWhere ( $ where , $ options ) ; }
11658	public static function addEntriesToFile ( $ file , $ entries ) { $ properties = self :: readFromFile ( $ file ) ; foreach ( $ entries as $ key => $ value ) { $ properties [ $ key ] = $ value ; } self :: saveToFile ( $ file , $ properties ) ; }
1326	public function getSignableParameters ( ) { $ params = $ this -> parameters ; if ( isset ( $ params [ 'oauth_signature' ] ) ) { unset ( $ params [ 'oauth_signature' ] ) ; } return Util :: buildHttpQuery ( $ params ) ; }
391	protected static function filterValidAliases ( Query $ query ) { $ tables = $ query -> getTablesUsedInFrom ( ) ; $ aliases = array_diff ( array_keys ( $ tables ) , $ tables ) ; return array_map ( function ( $ alias ) { return preg_replace ( '/{{([\w]+)}}/' , '$1' , $ alias ) ; } , array_values ( $ aliases ) ) ; }
12805	private static function getColumnName ( string $ name ) : ? string { $ class = self :: getStaticChildClass ( ) ; if ( self :: $ columnPropertiesCache === null || ! array_key_exists ( $ class , self :: $ columnPropertiesCache ) || self :: $ columnPropertiesCache [ $ class ] === null ) self :: buildColumnPropertiesCache ( ) ; if ( array_key_exists ( $ name , self :: $ columnPropertiesCache [ $ class ] ) ) return $ name ; foreach ( self :: $ columnPropertiesCache [ $ class ] as $ column => $ properties ) { if ( in_array ( $ name , $ properties ) ) return $ column ; } return null ; }
5786	private function databaseRecordNotFound ( Response $ response , $ primaryKey , TableMapper $ tableMapper , string $ routeAction , ? string $ title = null ) { if ( $ routeAction != 'update' && $ routeAction != 'delete' ) { throw new \ Exception ( "routeAction $routeAction must be update or delete" ) ; } $ this -> events -> insertWarning ( EVENT_QUERY_NO_RESULTS , [ $ tableMapper -> getPrimaryKeyColumnName ( ) => $ primaryKey , 'table' => $ tableMapper -> getTableName ( ) ] ) ; $ noticeTitle = ( $ title != null ) ? $ title : 'Record' ; SlimPostgres :: setAdminNotice ( "$noticeTitle $primaryKey Not Found" , 'failure' ) ; return $ response -> withRedirect ( $ this -> router -> pathFor ( SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ) ) ; }
8319	public function matches ( $ regexp , $ message ) { if ( ! is_string ( $ regexp ) || ! is_string ( $ message ) ) { throw new \ InvalidArgumentException ( "Both arguments must be string." ) ; } $ this -> constraints [ ] = ( function ( Password $ str ) use ( $ regexp , $ message ) { if ( ! preg_match ( $ regexp , $ str ) ) { return $ message ; } else { return true ; } } ) ; return $ this ; }
7841	public function removeNumber ( int $ id , string $ number ) : ? array { $ response = Request :: delete ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
5993	public function addSearchSort ( $ item ) { if ( ! ( $ item instanceof SearchSort ) ) { if ( is_array ( $ item ) ) { try { $ item = new SearchSort ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate SearchSort. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "SearchSort"!' , E_USER_WARNING ) ; } } $ this -> sortFields [ ] = $ item ; return $ this ; }
11937	protected function find ( $ params ) { $ debug = false ; $ q = new Query ( ) ; $ q -> select ( '*' ) ; $ q -> from ( $ this -> _tableName ) ; foreach ( $ params as $ k => $ v ) { if ( $ k === 'join' ) { foreach ( $ v as $ join ) { if ( ! isset ( $ join [ 'type' ] ) ) { $ join [ 'type' ] = 'INNER JOIN' ; } if ( ! isset ( $ join [ 'params' ] ) ) { $ join [ 'params' ] = [ ] ; } $ q -> join ( $ join [ 'type' ] , $ join [ 'table' ] , $ join [ 'on' ] , $ join [ 'params' ] ) ; } $ debug = true ; } elseif ( in_array ( $ k , [ 'where' ] ) ) { $ q -> { $ k } ( $ v ) ; } else { $ q -> { $ k } = $ v ; } } if ( $ debug ) { } return $ q ; }
6670	public function get_movie_rating ( $ votes ) { $ votations = [ ] ; foreach ( $ votes as $ key => $ value ) { for ( $ i = 0 ; $ i < $ value ; $ i ++ ) { $ votations [ ] = $ key ; } } if ( count ( $ votations ) ) { $ rating = array_sum ( $ votations ) / count ( $ votations ) ; return round ( $ rating , 1 ) ; } return 'N/A' ; }
9712	private function writeSupbookInternal ( ) { $ record = 0x01AE ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> spreadsheet -> getSheetCount ( ) , 0x0401 ) ; return $ this -> writeData ( $ header . $ data ) ; }
8383	public function fetchAll ( ) { if ( $ this -> statement == null || $ this -> getErrorState ( ) != '00000' ) { return false ; } return $ this -> statement -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
1072	private function getSuggestedTypeNames ( Schema $ schema , $ type , $ fieldName ) { if ( Type :: isAbstractType ( $ type ) ) { $ suggestedObjectTypes = [ ] ; $ interfaceUsageCount = [ ] ; foreach ( $ schema -> getPossibleTypes ( $ type ) as $ possibleType ) { $ fields = $ possibleType -> getFields ( ) ; if ( ! isset ( $ fields [ $ fieldName ] ) ) { continue ; } $ suggestedObjectTypes [ ] = $ possibleType -> name ; foreach ( $ possibleType -> getInterfaces ( ) as $ possibleInterface ) { $ fields = $ possibleInterface -> getFields ( ) ; if ( ! isset ( $ fields [ $ fieldName ] ) ) { continue ; } $ interfaceUsageCount [ $ possibleInterface -> name ] = ! isset ( $ interfaceUsageCount [ $ possibleInterface -> name ] ) ? 0 : $ interfaceUsageCount [ $ possibleInterface -> name ] + 1 ; } } arsort ( $ interfaceUsageCount ) ; $ suggestedInterfaceTypes = array_keys ( $ interfaceUsageCount ) ; return array_merge ( $ suggestedInterfaceTypes , $ suggestedObjectTypes ) ; } return [ ] ; }
1653	public function getArea ( ) : float { $ area = 0 ; if ( $ this -> getNumberOfPoints ( ) <= 2 ) { return $ area ; } $ referencePoint = $ this -> points [ 0 ] ; $ radius = $ referencePoint -> getEllipsoid ( ) -> getArithmeticMeanRadius ( ) ; $ segments = $ this -> getSegments ( ) ; foreach ( $ segments as $ segment ) { $ point1 = $ segment -> getPoint1 ( ) ; $ point2 = $ segment -> getPoint2 ( ) ; $ x1 = deg2rad ( $ point1 -> getLng ( ) - $ referencePoint -> getLng ( ) ) * cos ( deg2rad ( $ point1 -> getLat ( ) ) ) ; $ y1 = deg2rad ( $ point1 -> getLat ( ) - $ referencePoint -> getLat ( ) ) ; $ x2 = deg2rad ( $ point2 -> getLng ( ) - $ referencePoint -> getLng ( ) ) * cos ( deg2rad ( $ point2 -> getLat ( ) ) ) ; $ y2 = deg2rad ( $ point2 -> getLat ( ) - $ referencePoint -> getLat ( ) ) ; $ area += ( $ x2 * $ y1 - $ x1 * $ y2 ) ; } $ area *= 0.5 * $ radius ** 2 ; return ( float ) abs ( $ area ) ; }
10115	private function writeFooter ( ) { $ record = 0x0015 ; $ recordData = StringHelper :: UTF8toBIFF8UnicodeLong ( $ this -> phpSheet -> getHeaderFooter ( ) -> getOddFooter ( ) ) ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
8690	protected function validateElementValues ( ) { foreach ( self :: $ mandatoryFields as $ field ) { if ( array_key_exists ( $ field , $ this -> attributes ) ) { $ value = ( int ) $ this -> attributes [ $ field ] ; if ( $ value < 0 ) { throw new \ SVGCreator \ SVGException ( "The " . $ field . " value is lesser than 0, in element " . self :: TYPE , 1 ) ; } } } }
12950	public function beforeDelete ( ) { $ this -> _tagsForDelete = [ ] ; $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ this -> _tagsForDelete = ( new Query ( ) ) -> select ( current ( $ relation -> link ) ) -> from ( $ relation -> via -> from [ 0 ] ) -> where ( [ key ( $ relation -> via -> link ) => $ this -> owner -> getPrimaryKey ( ) ] ) -> column ( $ this -> owner -> getDb ( ) ) ; } }
11200	public function checkIfSingleton ( $ name , $ item ) { if ( isset ( $ this -> signaturesToSingletons -> $ name ) and $ this -> signaturesToSingletons -> $ name ) { $ this -> $ name = $ item ; $ this -> signaturesToSingletons = false ; } }
12664	public function requirePackage ( string $ package_class ) : ApplicationInterface { if ( ! in_array ( PackageInterface :: class , class_implements ( $ package_class ) ) ) { throw new PackageRequireException ( 'Specified package does not implements PackageInterface: ' . $ package_class , $ package_class ) ; } $ module_list = call_user_func ( [ $ package_class , 'getModuleList' ] ) ; if ( ! is_array ( $ module_list ) ) { throw new PackageRequireException ( 'Failed to call getModuleList: ' . $ package_class , $ package_class ) ; } $ this -> required_modules = array_merge ( $ this -> required_modules , $ module_list ) ; return $ this ; }
9033	protected function mapField ( $ field ) { if ( ! $ this -> classMetadata -> hasField ( $ field ) ) { $ this -> classMetadata -> mapField ( [ 'fieldName' => $ field , 'type' => 'datetime' , 'nullable' => true , ] ) ; } }
1522	public function process ( StoreInterface $ store , FetchProcess $ request ) { $ record = $ store -> readRecord ( $ request -> getProcess ( ) , $ request -> getEncodingParameters ( ) ) ; return $ this -> reply ( ) -> process ( $ record ) ; }
5468	public function addHeaders ( $ request , $ url ) { if ( $ url -> getUsername ( ) && $ url -> getPassword ( ) ) { $ username = $ url -> getUsername ( ) ; $ password = $ url -> getPassword ( ) ; } elseif ( $ realm = $ this -> findRealmFromUrl ( $ url ) ) { $ username = $ realm -> getUsername ( ) ; $ password = $ realm -> getPassword ( ) ; } else { return ; } $ this -> addBasicHeaders ( $ request , $ username , $ password ) ; }
6532	protected function buildParams ( SmsGatewayMessage $ message , $ to ) { $ optionalFields = array_filter ( [ 'expires_at' => data_get ( $ message , 'expiresAt' ) , 'send_at' => data_get ( $ message , 'sendAt' ) , ] ) ; return array_merge ( [ 'number' => $ to , 'message' => trim ( $ message -> content ) , ] , $ optionalFields ) ; }
1814	public function listImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=list' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a>' ; }
5694	public function index ( HTTPRequest $ r ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/betterbuttons_nested_form.css' ) ; return $ this -> customise ( array ( 'Form' => $ this -> Form ( ) ) ) -> renderWith ( BetterButtonNestedForm :: class ) ; }
1416	public function invalidQueryParameter ( string $ param , ? string $ detail = null , array $ failed = [ ] ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'query_invalid' , 'code' ) , $ this -> trans ( 'query_invalid' , 'title' ) , $ detail ? : $ this -> trans ( 'query_invalid' , 'detail' ) , [ Error :: SOURCE_PARAMETER => $ param ] , $ failed ? compact ( 'failed' ) : null ) ; }
2246	public static function isVisibleElement ( Model $ objElement ) { $ blnReturn = true ; if ( TL_MODE == 'FE' ) { if ( $ objElement -> protected ) { if ( ! FE_USER_LOGGED_IN ) { $ blnReturn = false ; } else { $ objUser = FrontendUser :: getInstance ( ) ; if ( ! \ is_array ( $ objUser -> groups ) ) { $ blnReturn = false ; } else { $ groups = StringUtil :: deserialize ( $ objElement -> groups ) ; if ( empty ( $ groups ) || ! \ is_array ( $ groups ) || ! \ count ( array_intersect ( $ groups , $ objUser -> groups ) ) ) { $ blnReturn = false ; } } } } elseif ( $ objElement -> guests && FE_USER_LOGGED_IN ) { $ blnReturn = false ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] as $ callback ) { $ blnReturn = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objElement , $ blnReturn ) ; } } return $ blnReturn ; }
7769	public function passes ( ) { foreach ( $ this -> after as $ after ) { call_user_func_array ( $ after , [ $ this ] ) ; } return empty ( $ this -> errors ) ; }
12624	public function useHeaders ( $ name ) { $ headers = $ this -> httpHeaders -> getHeaders ( $ name ) ; $ this -> mergeOptions ( array ( 'headers' => $ headers ) ) ; }
1419	protected function trans ( string $ key , string $ member , array $ replace = [ ] , ? string $ locale = null ) { return $ this -> translator -> trans ( "jsonapi::errors.{$key}.{$member}" , $ replace , $ locale ) ? : null ; }
9599	protected function redirect ( $ name , array $ params = array ( ) , $ statusCode = 302 ) { return new RedirectResponse ( $ this -> url ( $ name , $ params ) , $ statusCode ) ; }
4563	public function preUpdate ( PreUpdateEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Parameter ) { return ; } $ entity -> setValue ( serialize ( $ entity -> getValue ( ) ) ) ; }
11739	public function getMd5Address ( $ scheme = true , $ www = true ) { return md5 ( $ this -> normalize ( $ scheme , $ www ) ) ; }
9730	public function setMaxParcelDimensions ( $ value = null ) { if ( is_array ( $ value ) ) { $ value = new ParcelDimensions ( $ value ) ; } elseif ( ! ( $ value instanceof ParcelDimensions ) ) { $ value = null ; } return $ this -> setParameter ( 'max_parcel_dimensions' , $ value ) ; }
12155	public function getInitialRole ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = $ roleItem -> level < 400 ; if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
8835	public function getEnvironment ( string $ operatingSystem ) : EnvironmentInterface { $ environmentList = [ new UnixEnvironment ( ) ] ; $ environment = null ; foreach ( $ environmentList as $ possibleEnvironment ) { if ( in_array ( $ operatingSystem , $ possibleEnvironment -> getSupportedList ( ) ) ) { $ environment = $ possibleEnvironment ; } } if ( is_null ( $ environment ) ) { throw new \ RuntimeException ( 'Unable to find Environment for OS "' . $ operatingSystem . '".' . 'Try explicitly providing an Environment when instantiating the builder.' ) ; } return $ environment ; }
7210	public function getAutoLoginUrl ( array $ autoUrl , array $ redirectUrl = null , string $ expireInterval = '1 day' , bool $ addRememberMeCookie = true ) : string { $ autoUrl [ '?' ] [ 't' ] = $ this -> generateLoginToken ( $ redirectUrl , $ expireInterval , $ addRememberMeCookie ) ; $ url = Router :: url ( $ autoUrl , true ) ; $ urlLength = strlen ( $ url ) ; if ( strlen ( $ url ) > 2080 ) { throw new \ Exception ( 'Generated url "' . $ url . '" is too long' ) ; } return $ url ; }
6754	private static function createFolderIfNotExists ( string $ path ) { if ( false === @ mkdir ( $ path , 0777 , true ) && ! is_dir ( $ path ) ) { throw new \ RuntimeException ( sprintf ( "Unable to create the %s directory\n" , $ path ) ) ; } }
8410	public function connect ( ) { if ( $ this -> isConnected ( ) === false ) { try { if ( isset ( $ this -> servers [ 'all' ] ) === true ) { $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'all' ] ) ; $ this -> servers [ 'all' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'all' ] [ 'user' ] , $ this -> servers [ 'all' ] [ 'pass' ] ) ; } else { $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'read' ] ) ; $ this -> servers [ 'read' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'read' ] [ 'user' ] , $ this -> servers [ 'read' ] [ 'pass' ] ) ; $ dsn = $ this -> providerDatabase -> getDsn ( $ this -> servers [ 'write' ] ) ; $ this -> servers [ 'write' ] [ 'link' ] = new \ PDO ( $ dsn , $ this -> servers [ 'write' ] [ 'user' ] , $ this -> servers [ 'write' ] [ 'pass' ] ) ; } } catch ( \ PDOException $ e ) { throw new ExternalLink ( 'can\'t connect to database (' . $ e -> getMessage ( ) . ')' ) ; } } }
7832	protected function getSpacesByCore ( $ up = false ) { $ free = $ this -> getTotalWidth ( ) - $ this -> getBordersLength ( ) - $ this -> getCoreLength ( ) ; return $ free < 1 ? '' : str_repeat ( ' ' , $ this -> roundHalf ( $ free , $ up ) ) ; }
12838	static public function dir ( $ directory , $ date = false ) { if ( $ date ) { $ directory = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . self :: getDateDirectory ( ) ; } if ( ! is_dir ( $ directory ) ) { $ umask = umask ( 0000 ) ; if ( @ mkdir ( $ directory , 0777 , true ) === false ) { throw new Exception ( sprintf ( 'Directory "%s" cannot be created.' , $ directory ) ) ; } umask ( $ umask ) ; } return $ directory ; }
6684	public function sendErrorResponse ( $ message , $ code , $ httpStatusCode , $ data = null ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; \ Yii :: $ app -> response -> setStatusCode ( $ httpStatusCode , $ this -> httpStatuses -> getReasonPhrase ( $ httpStatusCode ) ) ; $ response = [ 'status' => 'error' , 'message' => $ message , 'code' => $ code ] ; if ( ! is_null ( $ data ) ) { $ response [ "data" ] = $ data ; } return $ response ; }
8479	public function bootstrap ( $ app ) { $ app -> i18n -> translations [ 'devgroup.events-system' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => 'en-US' , 'basePath' => '@DevGroup/EventsSystem/messages' , ] ; $ error = [ ] ; try { foreach ( EventHelper :: getActiveHandlersList ( ) as $ handler ) { Event :: on ( $ handler [ 'class' ] , $ handler [ 'name' ] , $ handler [ 'callable' ] , $ handler [ 'data' ] ) ; } } catch ( \ yii \ db \ Exception $ e ) { $ error = [ 'message' => '`DevGroup\EventsSystem` extension is not fully installed yet.' , 'hint' => 'Please run the `./yii migrate --migrationPath=@DevGroup/EventsSystem/migrations` command from your application directory to finish the installation process.' , ] ; } catch ( \ Exception $ e ) { $ error = [ 'message' => $ e -> getCode ( ) , 'hint' => $ e -> getMessage ( ) , ] ; } if ( empty ( $ error ) === false ) { if ( $ app instanceof \ yii \ console \ Application ) { $ app -> on ( Application :: EVENT_BEFORE_ACTION , function ( $ event ) use ( $ app , $ error ) { $ app -> controller -> stdout ( PHP_EOL . str_repeat ( '=' , 80 ) . PHP_EOL . PHP_EOL ) ; $ app -> controller -> stderr ( $ error [ 'message' ] . PHP_EOL ) ; $ app -> controller -> stdout ( $ error [ 'hint' ] . PHP_EOL ) ; $ app -> controller -> stdout ( PHP_EOL . str_repeat ( '=' , 80 ) . PHP_EOL ) ; } ) ; } elseif ( $ app instanceof \ yii \ web \ Application && YII_DEBUG === true ) { $ app -> session -> setFlash ( 'warning' , Html :: tag ( 'h4' , $ error [ 'message' ] ) . Html :: tag ( 'p' , $ error [ 'hint' ] ) ) ; } } }
7306	protected function getCustomerFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerInterface :: class ) ; } return $ resource ; }
8998	public function exists ( ) : bool { if ( ! file_exists ( $ this -> path ) ) { return false ; } if ( ! is_dir ( $ this -> path ) ) { throw new DirectoryException ( "Entry {path} exists, but it is not a directory!" , array ( 'path' => $ this -> path ) ) ; } return true ; }
10965	public static function getStandardPort ( $ scheme = null ) { if ( $ scheme === null ) { $ scheme = self :: getScheme ( ) ; } if ( isset ( self :: $ schemes [ $ scheme ] ) ) { return self :: $ schemes [ $ scheme ] ; } return 0 ; }
69	public function removeJunction ( $ junction ) { if ( ! Platform :: isWindows ( ) ) { return false ; } $ junction = rtrim ( str_replace ( '/' , DIRECTORY_SEPARATOR , $ junction ) , DIRECTORY_SEPARATOR ) ; if ( ! $ this -> isJunction ( $ junction ) ) { throw new IOException ( sprintf ( '%s is not a junction and thus cannot be removed as one' , $ junction ) ) ; } return $ this -> rmdir ( $ junction ) ; }
7491	public function setLength ( $ newLength , $ padding = ' ' ) { $ newLength = ( int ) $ newLength ; $ currentLength = $ this -> length ( ) ; if ( $ newLength != $ currentLength ) { while ( $ newLength > $ this -> length ( ) ) { $ this -> string .= $ padding ; } if ( $ newLength < $ this -> length ( ) ) { $ this -> string = mb_substr ( $ this -> string , 0 , $ newLength , $ this -> encoding ) ; } } return $ this ; }
11384	protected function resolve ( ) { if ( $ this -> resolved ) { return ; } $ this -> resolved = [ ] ; foreach ( $ this -> stages as $ stage ) { $ this -> resolved [ ] = $ this -> build ( $ stage ) ; } }
11171	public function getFilters ( $ columnDescriptions = [ ] , $ activeFieldName = false ) { $ filters = [ ] ; if ( count ( $ this -> filtersArray ) > 0 ) { foreach ( $ this -> filtersArray as $ key => $ value ) { if ( isset ( $ this -> filters [ $ key ] ) ) { $ activeFieldName = $ activeFieldName ? : $ this -> filtersArray [ 'orderBy' ] ; $ friendlyFieldName = isset ( $ columnDescriptions [ $ activeFieldName ] ) ? $ columnDescriptions [ $ activeFieldName ] : $ activeFieldName ; $ filters [ ] = sprintf ( $ this -> filters [ $ key ] , $ friendlyFieldName , $ value ) ; } } } return $ filters ; }
7888	public function logs ( ) { $ logs = array_reverse ( $ this -> filesystem -> files ( ) ) ; foreach ( $ logs as $ index => $ file ) { $ logs [ $ index ] = preg_replace ( '/.*(\d{4}-\d{2}-\d{2}).*/' , '$1' , basename ( $ file ) ) ; } return $ logs ; }
19	protected function getRepoData ( ) { $ resource = sprintf ( 'https://api.bitbucket.org/2.0/repositories/%s/%s?%s' , $ this -> owner , $ this -> repository , http_build_query ( array ( 'fields' => '-project,-owner' ) , null , '&' ) ) ; $ repoData = JsonFile :: parseJson ( $ this -> getContentsWithOAuthCredentials ( $ resource , true ) , $ resource ) ; if ( $ this -> fallbackDriver ) { return false ; } $ this -> parseCloneUrls ( $ repoData [ 'links' ] [ 'clone' ] ) ; $ this -> hasIssues = ! empty ( $ repoData [ 'has_issues' ] ) ; $ this -> branchesUrl = $ repoData [ 'links' ] [ 'branches' ] [ 'href' ] ; $ this -> tagsUrl = $ repoData [ 'links' ] [ 'tags' ] [ 'href' ] ; $ this -> homeUrl = $ repoData [ 'links' ] [ 'html' ] [ 'href' ] ; $ this -> website = $ repoData [ 'website' ] ; $ this -> vcsType = $ repoData [ 'scm' ] ; return true ; }
1966	public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { if ( static :: $ strPk == 'id' ) { return static :: findById ( $ varValue , $ arrOptions ) ; } return parent :: findByPk ( $ varValue , $ arrOptions ) ; }
8239	public function setAuthenticated ( $ v ) { if ( ! $ v ) { $ this -> authenticator = null ; } $ this -> authenticated = $ v ; return $ this ; }
4314	private function doGroup ( $ method , $ args ) { $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ this -> rootInstance -> groupStackRef [ ] = array ( 'channel' => $ meta [ 'channel' ] , 'collect' => $ this -> cfg [ 'collect' ] , ) ; if ( ! $ this -> cfg [ 'collect' ] ) { return ; } if ( empty ( $ args ) ) { $ caller = $ this -> utilities -> getCallerInfo ( ) ; if ( isset ( $ caller [ 'class' ] ) ) { $ args [ ] = $ caller [ 'class' ] . $ caller [ 'type' ] . $ caller [ 'function' ] ; $ meta [ 'isMethodName' ] = true ; } elseif ( isset ( $ caller [ 'function' ] ) ) { $ args [ ] = $ caller [ 'function' ] ; } else { $ args [ ] = 'group' ; } } $ this -> appendLog ( $ method , $ args , $ meta ) ; }
12837	public function build ( ) { $ this -> appDir = $ this -> rootDir . '/app' ; $ siteDir = $ this -> appDir . '/data/' . $ this -> siteName ; $ siteConfigDir = $ siteDir . '/config' ; $ pagesDir = $ siteDir . '/pages/pages' ; $ rolesDir = $ siteDir . '/roles' ; $ slotsDir = $ siteDir . '/slots' ; $ usersDir = $ siteDir . '/users' ; $ folders = array ( $ siteConfigDir , $ pagesDir , $ rolesDir , $ slotsDir , $ usersDir , ) ; $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> createConfiguration ( $ siteDir ) ; $ this -> createSite ( $ siteDir ) ; $ this -> createRoles ( $ rolesDir ) ; $ this -> createUsers ( $ usersDir ) ; $ this -> filesystem -> touch ( $ siteDir . '/incomplete.json' ) ; return $ this ; }
2900	public function initFromAction ( $ action ) { if ( ! $ action ) { return ; } $ request = $ action -> getRequest ( ) ; $ this -> httpMethod = $ request -> getMethod ( ) ; $ this -> requestOriginalPath = $ request -> getOriginalPathInfo ( ) ; $ this -> requestPath = $ request -> getPathInfo ( ) ; $ this -> remoteIp = Mage :: helper ( 'core/http' ) -> getRemoteAddr ( ) ; $ this -> routeName = $ request -> getRouteName ( ) ; $ this -> module = $ request -> getControllerModule ( ) ; $ this -> class = get_class ( $ action ) ; $ this -> action = $ action -> getActionMethodName ( $ request -> getActionName ( ) ) ; }
4264	protected function doPublish ( $ eventName , $ subscribers , Event $ event ) { foreach ( $ subscribers as $ callable ) { if ( $ event -> isPropagationStopped ( ) ) { break ; } \ call_user_func ( $ callable , $ event , $ eventName , $ this ) ; } }
11802	public static function import ( $ name ) { $ importPath = FOREVERPHP_ROOT . DS . $ name . '.php' ; if ( file_exists ( $ importPath ) ) { include_once $ importPath ; } else { throw new SetupException ( "The object to import ($name) not exists." ) ; } }
3436	protected function fetchAllPropsForSelect ( ) { $ props = [ ] ; $ rsProps = static :: $ cIblockObject -> GetProperties ( $ this -> iblockId ) ; while ( $ prop = $ rsProps -> Fetch ( ) ) { $ props [ ] = 'PROPERTY_' . $ prop [ 'CODE' ] ; } return $ props ; }
6686	public function showFlashMessages ( $ sticky = false ) { $ timeout = $ sticky ? 0 : 5000 ; $ flashMessages = [ ] ; $ allMessages = $ this -> getSession ( ) -> getAllFlashes ( ) ; foreach ( $ allMessages as $ key => $ message ) { if ( is_array ( $ message ) ) { $ message = $ this -> mergeFlashMessages ( $ message ) ; } $ flashMessages [ ] = [ 'message' => $ message , 'type' => $ key , 'timeout' => $ timeout ] ; } $ this -> getSession ( ) -> removeAllFlashes ( ) ; return Html :: script ( 'var notifications =' . json_encode ( $ flashMessages ) ) ; }
340	public function field ( $ model , $ attribute , $ options = [ ] ) { $ config = $ this -> fieldConfig ; if ( $ config instanceof \ Closure ) { $ config = call_user_func ( $ config , $ model , $ attribute ) ; } if ( ! isset ( $ config [ 'class' ] ) ) { $ config [ 'class' ] = $ this -> fieldClass ; } return Yii :: createObject ( ArrayHelper :: merge ( $ config , $ options , [ 'model' => $ model , 'attribute' => $ attribute , 'form' => $ this , ] ) ) ; }
2077	public function purgeScriptCache ( ) { foreach ( array ( 'assets/js' , 'assets/css' ) as $ dir ) { $ objFolder = new Folder ( $ dir ) ; $ objFolder -> purge ( ) ; } $ this -> import ( StyleSheets :: class , 'StyleSheets' ) ; $ this -> StyleSheets -> updateStyleSheets ( ) ; $ this -> purgePageCache ( ) ; $ this -> log ( 'Purged the script cache' , __METHOD__ , TL_CRON ) ; }
10899	public function save ( bool $ validate = true ) : self { if ( $ validate && $ this -> validate ( ) ) { throw new Exception ( 'Entity ' . $ this -> __getEntityName ( ) . ' data is not valid' ) ; } $ scheme = \ array_keys ( $ this -> getScheme ( ) ) ; foreach ( $ this -> data as $ key => $ value ) { if ( ! \ in_array ( $ key , $ scheme , true ) ) { unset ( $ this -> data [ $ key ] ) ; } } if ( $ this -> getId ( ) ) { $ this -> medoo -> update ( $ this -> getTable ( ) , $ this -> data , [ 'id' => $ this -> getId ( ) ] ) ; } else { $ this -> medoo -> insert ( $ this -> getTable ( ) , $ this -> data ) ; $ this -> setId ( $ this -> medoo -> id ( ) ) ; } $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::save()' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; return $ this ; }
4461	private function handleChildErrors ( & $ socket ) : Closure { $ reserved = str_repeat ( '*' , 32 * 1024 ) ; return function ( ) use ( & $ reserved , & $ socket ) : void { unset ( $ reserved ) ; $ error = error_get_last ( ) ; if ( $ error === null ) { unset ( $ reserved ) ; return ; } $ handler = new ErrorFormatter ( ) ; if ( $ handler -> constant ( $ error [ 'type' ] ) === null ) { $ this -> logger -> warning ( '{type}: Unable to recognize error type. Skip sending error to master: {message}' , $ this -> logContext + [ 'message' => $ error [ 'message' ] ] ) ; return ; } if ( is_resource ( $ socket ) == false ) { $ this -> logger -> warning ( '{type}: supplied resource is not a valid socket resource. Skip sending error to master: {message}' , $ this -> logContext + [ 'message' => $ error [ 'message' ] ] ) ; return ; } $ this -> logger -> debug ( '{type}: sending error to master' , $ this -> logContext ) ; $ data = serialize ( $ error ) ; do { $ len = socket_write ( $ socket , $ data ) ; if ( $ len === false || $ len === 0 ) { break ; } $ data = substr ( $ data , $ len ) ; } while ( is_numeric ( $ len ) && $ len > 0 && is_resource ( $ socket ) ) ; } ; }
1662	public function reply ( $ message ) { if ( is_string ( $ message ) ) { $ this -> messages [ ] = Text :: create ( ) -> text ( $ message ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message ; } } elseif ( $ message instanceof RichMessage ) { if ( ! $ this -> doesSupportRichMessage ( ) ) { $ this -> text = $ message -> getFallbackText ( ) ; } $ message -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; $ this -> messages [ ] = $ message ; } elseif ( $ message instanceof Conversation ) { $ this -> messages [ ] = Payload :: create ( $ message -> render ( ) ) -> setAgentVersion ( $ this -> agentVersion ) -> setRequestSource ( $ this -> requestSource ) ; } return $ this ; }
8318	public function minLength ( $ n ) { $ this -> constraints [ ] = ( function ( Password $ str ) use ( $ n ) { if ( mb_strlen ( $ str ) < $ n ) { return sprintf ( "Minimum password length is %d characters." , $ n ) ; } else { return true ; } } ) ; return $ this ; }
7014	private function format_n ( & $ str ) { if ( strstr ( $ str , '%n' ) ) $ str = str_replace ( '%n' , sprintf ( '%01d' , $ this -> month ) , $ str ) ; }
8943	public function diffUploadChangeset ( $ xml , $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/upload' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'POST' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> diffResult ; }
11608	public function actionConfirm ( $ id , $ code ) { $ user = $ this -> finder -> findUserById ( $ id ) ; if ( $ user === null || $ this -> module -> emailChangeStrategy == Module :: STRATEGY_INSECURE ) { throw new NotFoundHttpException ; } $ user -> attemptEmailChange ( $ code ) ; return $ this -> redirect ( [ 'account' ] ) ; }
1849	protected function generateLink ( $ strLink , $ objArticle , $ blnAddArchive = false , $ blnIsReadMore = false ) { if ( $ objArticle -> source != 'external' ) { return sprintf ( '<a href="%s" title="%s" itemprop="url"><span itemprop="headline">%s</span>%s</a>' , News :: generateNewsUrl ( $ objArticle , $ blnAddArchive ) , StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'readMore' ] , $ objArticle -> headline ) , true ) , $ strLink , ( $ blnIsReadMore ? '<span class="invisible"> ' . $ objArticle -> headline . '</span>' : '' ) ) ; } if ( substr ( $ objArticle -> url , 0 , 7 ) == 'mailto:' ) { $ strArticleUrl = StringUtil :: encodeEmail ( $ objArticle -> url ) ; } else { $ strArticleUrl = ampersand ( $ objArticle -> url ) ; } return sprintf ( '<a href="%s" title="%s"%s itemprop="url"><span itemprop="headline">%s</span></a>' , $ strArticleUrl , StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'open' ] , $ strArticleUrl ) ) , ( $ objArticle -> target ? ' target="_blank"' : '' ) , $ strLink ) ; }
2835	public function completeRendering ( Mage_Core_Block_Abstract $ block ) { $ this -> isRendering = false ; $ this -> renderedCompletedAt = microtime ( true ) ; $ this -> renderedDuration += ( $ this -> renderedCompletedAt * 1000 - $ this -> renderedAt * 1000 ) ; $ this -> templateFile = $ block instanceof Mage_Core_Block_Template ? $ block -> getTemplateFile ( ) : '' ; self :: $ endRenderingTime = $ this -> renderedCompletedAt ; }
6410	public static function concatIterables ( IteratorAggregate $ iterables ) : IteratorAggregate { return self :: from ( Iterators :: concatIterators ( FluentIterable :: from ( $ iterables ) -> transform ( function ( Traversable $ element ) { return Iterators :: from ( $ element ) ; } ) -> iterator ( ) ) ) ; }
12653	public function getTextsWithBaseTexts ( $ language ) { $ texts = $ this -> getPageTexts ( $ language ) ; if ( $ language !== $ this -> baseLang ) { $ baseTexts = $ this -> getPageTexts ( $ this -> baseLang ) ; $ texts = array_map ( function ( $ text , $ baseText ) { return $ text + array ( "basecontent" => $ baseText [ 'content' ] ) ; } , $ texts , $ baseTexts ) ; } return $ texts ; }
2471	public function findContent ( Query $ query , array $ languageFilter = array ( ) ) { $ query = clone $ query ; $ query -> filter = $ query -> filter ? : new Criterion \ MatchAll ( ) ; $ query -> query = $ query -> query ? : new Criterion \ MatchAll ( ) ; $ this -> coreFilter -> apply ( $ query , $ languageFilter , DocumentMapper :: DOCUMENT_TYPE_IDENTIFIER_CONTENT ) ; return $ this -> resultExtractor -> extract ( $ this -> gateway -> findContent ( $ query , $ languageFilter ) , $ query -> facetBuilders ) ; }
12803	public function getADORecordSet ( ) { if ( ! $ this -> sql ) { throw new Exception ( 'Web2All_Table_Collection_SimpleDataProvider::getADORecordSet: no SQL query set' ) ; } return $ this -> db -> SelectLimit ( $ this -> sql , $ this -> limit , $ this -> offset , $ this -> params ) ; }
1885	public function getItemsAsString ( $ strSeparator = ' ' ) { $ arrLinks = array ( ) ; foreach ( $ this -> getItemsAsArray ( ) as $ arrItem ) { if ( $ arrItem [ 'href' ] === null ) { $ arrLinks [ ] = sprintf ( '<li><strong class="active">%s</strong></li>' , $ arrItem [ 'page' ] ) ; } else { $ arrLinks [ ] = sprintf ( '<li><a href="%s" class="link" title="%s">%s</a></li>' , $ arrItem [ 'href' ] , $ arrItem [ 'title' ] , $ arrItem [ 'page' ] ) ; } } return implode ( $ strSeparator , $ arrLinks ) ; }
12571	public function previewVoice ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_VOICE , $ message , $ to , $ by ) ; }
5179	private function addNew ( string $ key , $ value ) : self { $ this -> props [ $ key ] = $ value ; return $ this ; }
9472	public function deleteSucceeded ( $ message = null ) { if ( is_null ( $ message ) ) $ message = $ this -> config [ 'success' ] [ 'delete' ] ; return $ this -> setStatusCode ( 200 ) -> setStatusText ( 'success' ) -> respondWithMessage ( $ message ) ; }
8488	public static function getLoad ( ) { $ wmi = Windows :: getInstance ( ) ; $ load = [ ] ; foreach ( $ wmi -> ExecQuery ( "SELECT LoadPercentage FROM Win32_Processor" ) as $ cpu ) { $ load [ ] = $ cpu -> LoadPercentage ; } return round ( array_sum ( $ load ) / count ( $ load ) , 2 ) . "%" ; }
8019	public function getClient ( ) { if ( $ this -> _client === null ) { $ settings = [ 'key' => $ this -> key , 'secret' => $ this -> secret ] ; if ( $ this -> enableV4 ) $ settings [ 'signature' ] = 'v4' ; $ this -> _client = S3Client :: factory ( $ settings ) ; } return $ this -> _client ; }
11713	private function getCalcData ( ) { $ req = new AGetPeriodRequest ( ) ; $ req -> setBaseCalcTypeCode ( Cfg :: CODE_TYPE_CALC_PV_WRITE_OFF ) ; $ req -> setDepCalcTypeCode ( Cfg :: CODE_TYPE_CALC_UNQUALIFIED_PROCESS ) ; $ resp = $ this -> servPeriodGet -> exec ( $ req ) ; $ writeOffCalc = $ resp -> getBaseCalcData ( ) ; $ processCalc = $ resp -> getDepCalcData ( ) ; $ result = [ $ writeOffCalc , $ processCalc ] ; return $ result ; }
6786	public function buildHeaders ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ headerOptions = [ ] ; foreach ( $ this -> headerParameters as $ key => $ isHeaderParameter ) { if ( $ isHeaderParameter && isset ( $ options [ $ key ] ) ) { $ headerOptions [ $ key ] = $ options [ $ key ] ; } } return $ headerOptions ; }
10152	private function readHcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isHorizontalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setHorizontalCentered ( $ isHorizontalCentered ) ; } }
4001	protected function getMetaModelDataFrom ( $ strTable , $ intID ) { if ( ! $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ strTable ] ) ) { return null ; } $ statement = $ this -> connection -> prepare ( 'SELECT metamodel, metamodel_filtering FROM ' . $ strTable . ' WHERE id=? LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ intID ) ; $ statement -> execute ( ) ; if ( $ statement -> rowCount ( ) < 1 ) { return null ; } return $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ; }
8910	private function getCallableFunction ( $ method ) { if ( is_callable ( $ method ) ) { return $ method ; } if ( is_string ( $ method ) && is_callable ( array ( $ this , $ method ) ) ) { return array ( $ this , $ method ) ; } return FALSE ; }
10153	private function readVcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isVerticalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setVerticalCentered ( $ isVerticalCentered ) ; } }
843	public function clearChanged ( ) { $ this -> changed = false ; if ( self :: isLegacyMode ( ) ) { foreach ( $ this as $ token ) { $ token -> clearChanged ( ) ; } } }
6677	public static function toRelativeTime ( $ fromTime , $ toTime = 'now' , $ format = 'days' ) { $ startTime = new DateTime ( $ fromTime ) ; $ endTime = new DateTime ( $ toTime ) ; return $ startTime -> diff ( $ endTime ) -> $ format ; }
3130	public function getServiceContext ( $ testDefinitionUri , $ testCompilationUri , $ testExecutionUri , $ userUri = null ) { $ serviceContext = new QtiRunnerServiceContext ( $ testDefinitionUri , $ testCompilationUri , $ testExecutionUri ) ; $ serviceContext -> setServiceManager ( $ this -> getServiceManager ( ) ) ; $ serviceContext -> setTestConfig ( $ this -> getTestConfig ( ) ) ; $ serviceContext -> setUserUri ( $ userUri ) ; $ sessionService = $ this -> getServiceManager ( ) -> get ( TestSessionService :: SERVICE_ID ) ; $ sessionService -> registerTestSession ( $ serviceContext -> getTestSession ( ) , $ serviceContext -> getStorage ( ) , $ serviceContext -> getCompilationDirectory ( ) ) ; return $ serviceContext ; }
6578	public function parse ( $ url ) { $ parts = $ this -> _parse_url ( $ url ) ; foreach ( array ( 'user' , 'pass' , 'fragment' ) as $ part ) if ( isset ( $ parts [ $ part ] ) ) $ parts [ $ part ] = urldecode ( $ parts [ $ part ] ) ; if ( isset ( $ parts [ 'host' ] ) ) $ parts [ 'host' ] = idn_to_utf8 ( $ parts [ 'host' ] ) ; if ( isset ( $ parts [ 'path' ] ) ) $ parts [ 'path' ] = rawurldecode ( str_ireplace ( '%2F' , '%252F' , $ parts [ 'path' ] ) ) ; return $ this -> setParts ( $ parts ) ; }
12371	public function addItem ( array $ item ) : self { if ( count ( $ item ) < 2 ) { throw new Exception ( 'Invalid count of item elements.' ) ; } $ this -> items [ ] = $ item ; return $ this ; }
7649	public function stream_flush ( ) { $ result = fflush ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } return $ result ; }
4716	public function on ( $ event , callable $ callback , $ priority = 10 ) { if ( ! isset ( $ this -> callbacks [ $ event ] ) ) { $ this -> callbacks [ $ event ] = [ true , [ ] ] ; } $ this -> callbacks [ $ event ] [ 0 ] = false ; $ this -> callbacks [ $ event ] [ 1 ] [ ] = array ( $ priority , $ callback ) ; return $ this ; }
6322	private function parseConfiguration ( array $ config ) { $ this -> currentEnvironment = 'dev' ; foreach ( $ config as $ environment => $ connection ) { if ( isset ( $ connection [ 'dsn' ] ) ) { $ this -> dsn [ $ environment ] = $ connection [ 'dsn' ] ; } else { $ this -> dsn [ $ environment ] = sprintf ( 'pgsql:host=%s; port=%s; dbname=%s;' , $ connection [ 'host' ] , $ connection [ 'port' ] , $ connection [ 'database' ] ) ; } $ this -> username [ $ environment ] = $ connection [ 'username' ] ; $ this -> password [ $ environment ] = $ connection [ 'password' ] ; } }
10361	public static function writeLogs ( string $ message ) : bool { return ( bool ) file_put_contents ( rtrim ( LOGS_PATH , '/' ) . '/' . gmdate ( 'Y_m_d' ) . '.log' , '[' . gmdate ( 'd-M-Y H:i:s' ) . '] ' . $ message . PHP_EOL , FILE_APPEND ) ; }
8071	public function retrieveByCredentials ( array $ credentials ) { $ username = $ credentials [ 'username' ] ; $ result = $ this -> ldap -> find ( $ username ) ; if ( ! is_null ( $ result ) ) { $ user = new $ this -> model ; $ user -> build ( $ result ) ; return $ user ; } return null ; }
298	public function updateAttributes ( $ attributes ) { $ attrs = [ ] ; foreach ( $ attributes as $ name => $ value ) { if ( is_int ( $ name ) ) { $ attrs [ ] = $ value ; } else { $ this -> $ name = $ value ; $ attrs [ ] = $ name ; } } $ values = $ this -> getDirtyAttributes ( $ attrs ) ; if ( empty ( $ values ) || $ this -> getIsNewRecord ( ) ) { return 0 ; } $ rows = static :: updateAll ( $ values , $ this -> getOldPrimaryKey ( true ) ) ; foreach ( $ values as $ name => $ value ) { $ this -> _oldAttributes [ $ name ] = $ this -> _attributes [ $ name ] ; } return $ rows ; }
6313	private function loadConstraints ( Table $ table ) { foreach ( $ this -> getConstraints ( ) as $ constraint ) { switch ( $ constraint [ 'constraint_type' ] ) { case 'FOREIGN KEY' : $ foreignKey = new ForeignKey ( new Table ( $ constraint [ 'table_name' ] ) , new Table ( $ constraint [ 'column_name' ] ) ) ; $ foreignKey -> setColumns ( $ constraint [ 'references_table' ] ) ; $ foreignKey -> setReferencedColumns ( $ constraint [ 'references_field' ] ) ; $ table -> addConstraint ( $ foreignKey ) ; break ; case 'PRIMARY KEY' : $ table -> addConstraint ( new PrimaryKey ( $ constraint [ 'column_name' ] , $ table ) ) ; break ; case 'UNIQUE' : $ table -> addConstraint ( new Unique ( $ constraint [ 'column_name' ] , new Table ( $ constraint [ 'table_name' ] ) ) ) ; break ; } } }
7821	public function update ( $ pipeline , array $ attachments , array $ detachments ) { $ this -> detach ( $ this -> pipelines [ $ pipeline ] , $ detachments ) ; $ this -> attach ( $ this -> pipelines [ $ pipeline ] , $ attachments ) ; $ this -> refreshPipelines ( ) ; }
5801	protected function getDeleteCell ( bool $ showDeleteLink , ? string $ primaryKeyValue ) : string { if ( $ showDeleteLink && $ this -> deleteRoute == null ) { throw new \ Exception ( "Must have deleteRoute" ) ; } if ( $ showDeleteLink && $ primaryKeyValue === null ) { throw new \ Exception ( "Must have primaryKeyValue to delete" ) ; } $ cellValue = ( $ showDeleteLink ) ? '<a href="' . $ this -> router -> pathFor ( $ this -> deleteRoute , [ "primaryKey" => $ primaryKeyValue ] ) . '" title="delete" onclick="return confirm(\'Are you sure you want to delete ' . $ primaryKeyValue . '?\');">X</a>' : '&nbsp;' ; return '<td>' . $ cellValue . '</td>' ; }
4345	public function getCfgLazy ( $ name ) { if ( ! isset ( $ this -> cfgLazy [ $ name ] ) ) { return array ( ) ; } $ return = $ this -> cfgLazy [ $ name ] ; unset ( $ this -> cfgLazy [ $ name ] ) ; return $ return ; }
4745	public function isReviewOptInValidationRequired ( ) { $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; return $ review -> isReviewOptInValidationRequired ( ) ; }
3966	public function getInputScreen ( ) { return new InputScreen ( \ System :: getContainer ( ) -> get ( 'cca.legacy_dic' ) -> getService ( 'metamodels-service-container' ) , $ this -> inputScreen [ 'meta' ] , $ this -> inputScreen [ 'properties' ] , $ this -> inputScreen [ 'conditions' ] , $ this -> inputScreen [ 'groupSort' ] ) ; }
10144	private function readBof ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ substreamType = self :: getUInt2d ( $ recordData , 2 ) ; switch ( $ substreamType ) { case self :: XLS_WORKBOOKGLOBALS : $ version = self :: getUInt2d ( $ recordData , 0 ) ; if ( ( $ version != self :: XLS_BIFF8 ) && ( $ version != self :: XLS_BIFF7 ) ) { throw new Exception ( 'Cannot read this Excel file. Version is too old.' ) ; } $ this -> version = $ version ; break ; case self :: XLS_WORKSHEET : break ; default : do { $ code = self :: getUInt2d ( $ this -> data , $ this -> pos ) ; $ this -> readDefault ( ) ; } while ( $ code != self :: XLS_TYPE_EOF && $ this -> pos < $ this -> dataSize ) ; break ; } }
4682	private static function formatTime ( float $ value , $ format ) : string { switch ( $ format ) { case static :: FORMAT_PRECISE : return ( string ) ( $ value * 1000 ) ; case static :: FORMAT_MILLISECONDS : return ( string ) round ( $ value * 1000 , 2 ) ; case static :: FORMAT_SECONDS : return ( string ) round ( $ value , 3 ) ; default : return ( string ) ( $ value * 1000 ) ; } }
11798	public function setHtml ( $ html = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } $ this -> html .= Helper :: formatText ( $ html , 'ascii' ) ; return $ this ; }
2513	protected function isWorseStatus ( $ newStatus , $ currentStatus ) { $ levels = [ self :: STATUS_UNKNOWN => - 1 , self :: STATUS_OK => 0 , self :: STATUS_INFO => 2 , self :: STATUS_WARN => 5 , self :: STATUS_ERROR => 10 , self :: STATUS_FATAL => 20 , ] ; return ( $ currentStatus === null || $ levels [ $ newStatus ] > $ levels [ $ currentStatus ] ) ; }
5559	protected function findFormInFrame ( $ page , $ index , $ method , $ attribute ) { $ form = $ this -> frames [ $ index ] -> $ method ( $ attribute ) ; if ( isset ( $ form ) ) { $ form -> setDefaultTarget ( $ this -> getPublicNameFromIndex ( $ index ) ) ; } return $ form ; }
11391	public function createMainMenu ( Request $ request ) { $ menu = $ this -> factory -> createItem ( 'root' ) ; $ menu -> setCurrentUri ( $ request -> getBaseUrl ( ) . $ request -> getPathInfo ( ) ) ; $ admin_pool = $ this -> container -> get ( 'sonata.admin.pool' ) ; foreach ( $ admin_pool -> getDashboardGroups ( ) as $ group ) { $ menu -> addChild ( $ group [ 'label' ] , array ( 'translationDomain' => $ group [ 'label_catalogue' ] ) ) ; foreach ( $ group [ 'items' ] as $ admin ) { if ( $ admin -> hasRoute ( 'list' ) && $ admin -> isGranted ( 'LIST' ) ) { $ menu [ $ group [ 'label' ] ] -> addChild ( $ admin -> getLabel ( ) , array ( 'admin' => $ admin ) ) ; } } } $ dispatcher = $ this -> container -> get ( 'event_dispatcher' ) ; $ event = new MenuCreateEvent ( $ menu ) ; $ dispatcher -> dispatch ( MenuEvents :: ADMIN_MENU_CREATE , $ event ) ; return $ menu ; }
280	private function confirmLoad ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be loaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be loaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } $ this -> stdout ( "\nBe aware that:\n" , Console :: BOLD ) ; $ this -> stdout ( "Applying leads to purging of certain data in the database!\n" , Console :: FG_RED ) ; return $ this -> confirm ( "\nLoad above fixtures?" ) ; }
4761	public function flush ( ) { if ( $ this -> doNotTrack ) { return ; } if ( empty ( $ this -> queue ) ) { return ; } if ( $ this -> mergePackets ) { $ this -> send ( implode ( "\n" , $ this -> queue ) ) ; } else { foreach ( $ this -> queue as $ data ) { $ this -> send ( $ data ) ; } } $ this -> queue = array ( ) ; $ this -> queueSize = 0 ; }
3676	public function checkColumnDoesNotExist ( $ strTableName , $ strColName , $ blnAllowSystemCol = false ) { $ this -> checkTableExists ( $ strTableName ) ; $ this -> checkColumnName ( $ strColName , $ blnAllowSystemCol ) ; if ( $ this -> fieldExists ( $ strColName , $ strTableName ) ) { throw ColumnExistsException :: withName ( $ strColName , $ strTableName ) ; } }
1898	private function checkIfAccountIsActive ( User $ user ) : void { $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ start = ( int ) $ user -> start ; $ stop = ( int ) $ user -> stop ; $ time = Date :: floorToMinute ( time ( ) ) ; $ notActiveYet = $ start && $ start > $ time ; $ notActiveAnymore = $ stop && $ stop <= ( $ time + 60 ) ; $ logMessage = '' ; if ( $ notActiveYet ) { $ logMessage = sprintf ( 'The account is not active yet (activation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ start ) ) ; } if ( $ notActiveAnymore ) { $ logMessage = sprintf ( 'The account is not active anymore (deactivation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ stop ) ) ; } if ( '' === $ logMessage ) { return ; } $ ex = new DisabledException ( $ logMessage ) ; $ ex -> setUser ( $ user ) ; throw $ ex ; }
2136	protected static function loadParameters ( ) { $ container = System :: getContainer ( ) ; if ( $ container === null ) { return ; } if ( $ container -> hasParameter ( 'contao.localconfig' ) && \ is_array ( $ params = $ container -> getParameter ( 'contao.localconfig' ) ) ) { foreach ( $ params as $ key => $ value ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ key ] = $ value ; } } $ arrMap = array ( 'dbHost' => 'database_host' , 'dbPort' => 'database_port' , 'dbUser' => 'database_user' , 'dbPass' => 'database_password' , 'dbDatabase' => 'database_name' , 'smtpHost' => 'mailer_host' , 'smtpUser' => 'mailer_user' , 'smtpPass' => 'mailer_password' , 'smtpPort' => 'mailer_port' , 'smtpEnc' => 'mailer_encryption' , 'addLanguageToUrl' => 'contao.prepend_locale' , 'encryptionKey' => 'contao.encryption_key' , 'urlSuffix' => 'contao.url_suffix' , 'uploadPath' => 'contao.upload_path' , 'debugMode' => 'kernel.debug' , ) ; foreach ( $ arrMap as $ strKey => $ strParam ) { if ( $ container -> hasParameter ( $ strParam ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ strKey ] = $ container -> getParameter ( $ strParam ) ; } } if ( $ container -> hasParameter ( 'contao.image.valid_extensions' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'validImageTypes' ] = implode ( ',' , $ container -> getParameter ( 'contao.image.valid_extensions' ) ) ; } if ( $ container -> hasParameter ( 'contao.image.imagine_options' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'jpgQuality' ] = $ container -> getParameter ( 'contao.image.imagine_options' ) [ 'jpeg_quality' ] ; } }
46	public function dispatchInstallerEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations = array ( ) ) { return $ this -> doDispatch ( new InstallerEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations ) ) ; }
719	public function time ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TIME , $ precision ) ; }
584	protected function loadConfiguration ( $ configFile ) { $ this -> stdout ( "Loading configuration from '{$configFile}'...\n" ) ; $ config = require $ configFile ; foreach ( $ config as $ name => $ value ) { if ( property_exists ( $ this , $ name ) || $ this -> canSetProperty ( $ name ) ) { $ this -> $ name = $ value ; } else { throw new Exception ( "Unknown configuration option: $name" ) ; } } $ this -> getAssetManager ( ) ; }
12634	public function reverse ( $ orderNo , $ type = self :: OUT_TRADE_NO ) { $ params = [ $ type => $ orderNo , ] ; return $ this -> safeRequest ( $ this -> wrapApi ( self :: API_REVERSE ) , $ params ) ; }
238	protected function normalizePdoRowKeyCase ( array $ row , $ multiple ) { if ( $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_CASE ) !== \ PDO :: CASE_UPPER ) { return $ row ; } if ( $ multiple ) { return array_map ( function ( array $ row ) { return array_change_key_case ( $ row , CASE_LOWER ) ; } , $ row ) ; } return array_change_key_case ( $ row , CASE_LOWER ) ; }
3282	public function setExt ( string $ ext ) { if ( substr ( $ ext , 0 , 1 ) !== '.' ) { $ ext = '.' . $ ext ; } $ this -> config [ 'ext' ] = $ ext ; }
9669	private function writeFont ( XMLWriter $ objWriter , Font $ pFont ) { $ objWriter -> startElement ( 'font' ) ; if ( $ pFont -> getBold ( ) !== null ) { $ objWriter -> startElement ( 'b' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getBold ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getItalic ( ) !== null ) { $ objWriter -> startElement ( 'i' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getItalic ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getStrikethrough ( ) !== null ) { $ objWriter -> startElement ( 'strike' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getStrikethrough ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getUnderline ( ) !== null ) { $ objWriter -> startElement ( 'u' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getUnderline ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSuperscript ( ) === true || $ pFont -> getSubscript ( ) === true ) { $ objWriter -> startElement ( 'vertAlign' ) ; if ( $ pFont -> getSuperscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'superscript' ) ; } elseif ( $ pFont -> getSubscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'subscript' ) ; } $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSize ( ) !== null ) { $ objWriter -> startElement ( 'sz' ) ; $ objWriter -> writeAttribute ( 'val' , StringHelper :: formatNumber ( $ pFont -> getSize ( ) ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getColor ( ) -> getARGB ( ) !== null ) { $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFont -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getName ( ) !== null ) { $ objWriter -> startElement ( 'name' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getName ( ) ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; }
6461	public function shouldSeeThumbnail ( ) { $ thumb = false ; foreach ( [ '.upload-preview' , '.media-thumbnail img' , '.image-preview img' ] as $ selector ) { if ( $ thumb ) { break ; } $ thumb = $ this -> findByCss ( $ selector ) ; } if ( null === $ thumb ) { throw new \ Exception ( 'An expected image tag was not found.' ) ; } $ file = explode ( '?' , $ thumb -> getAttribute ( 'src' ) ) ; $ file = reset ( $ file ) ; $ curl = new CurlService ( ) ; list ( , $ info ) = $ curl -> execute ( 'GET' , $ file ) ; if ( empty ( $ info ) || strpos ( $ info [ 'content_type' ] , 'image/' ) === false ) { throw new FileNotFoundException ( sprintf ( '%s did not return an image' , $ file ) ) ; } }
2832	public function stacktraceSqlAction ( ) { if ( $ query = $ this -> _initQuery ( ) ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ stripZendPath = $ helper -> canStripZendDbTrace ( ) ? 'lib/Zend/Db/Adapter' : '' ; $ trimPath = $ helper -> canTrimMagentoBaseDir ( ) ? Mage :: getBaseDir ( ) . DS : '' ; $ html = '<pre>' . Mage :: helper ( 'sheep_debug' ) -> formatStacktrace ( $ query -> getStackTrace ( ) , $ stripZendPath , $ trimPath ) . '</pre>' ; $ this -> getResponse ( ) -> setBody ( $ html ) ; } }
6628	public function get ( $ key , $ default = null ) { return ArrayHelper :: getValue ( $ this -> parsedResponse , sprintf ( '%s.%s' , self :: RESPONSE_DATA_PARAM , $ key ) , $ default ) ; }
6292	private function findThemeByDirectory ( $ directory ) { if ( isset ( $ this -> themes [ $ directory ] ) ) { return $ this -> themes [ $ directory ] ; } return null ; }
8803	public function setFlash ( $ key , $ value , $ redirect = null ) { $ this -> set ( '_nur_flash' , [ $ key => $ value ] ) ; if ( ! is_null ( $ redirect ) ) { uri ( ) -> redirect ( $ redirect ) ; } return false ; }
8923	public function generate ( $ sourceDocument , $ targetDocument ) { if ( $ sourceDocument === null || $ targetDocument === null ) { return $ targetDocument ; } if ( $ sourceDocument == new \ stdClass ( ) ) { return null ; } if ( is_array ( $ sourceDocument ) ) { if ( $ sourceDocument !== $ targetDocument ) { return $ targetDocument ; } return null ; } $ patchDocument = new \ stdClass ( ) ; $ sourceDocumentVars = get_object_vars ( $ sourceDocument ) ; $ targetDocumentVars = get_object_vars ( $ targetDocument ) ; foreach ( $ targetDocumentVars as $ var => $ value ) { if ( ! in_array ( $ var , array_keys ( $ sourceDocumentVars ) ) || ! in_array ( $ value , array_values ( $ sourceDocumentVars ) ) ) { $ patchDocument -> $ var = $ value ; } } foreach ( $ sourceDocumentVars as $ var => $ value ) { if ( $ targetDocumentVars === [ ] ) { $ patchDocument -> $ var = null ; break ; } if ( is_object ( $ value ) ) { if ( $ sourceDocument -> $ var !== null && is_object ( $ sourceDocument -> $ var ) ) { $ subPatch = $ this -> generate ( $ sourceDocument -> $ var , $ targetDocument -> $ var ) ; if ( $ subPatch !== null ) { $ patchDocument -> $ var = $ subPatch ; } } } elseif ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) || ! in_array ( $ value , array_values ( $ targetDocumentVars ) ) ) { $ sourceDocument -> $ var = null ; if ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) ) { $ patchDocument -> $ var = null ; } } } if ( count ( get_object_vars ( $ patchDocument ) ) > 0 ) { return $ patchDocument ; } return null ; }
342	public static function validateMultiple ( $ models , $ attributes = null ) { $ result = [ ] ; foreach ( $ models as $ i => $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , "[$i]" . $ attribute ) ] = $ errors ; } } return $ result ; }
4120	public static function overrideType ( $ name , $ className ) { if ( ! isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeNotFound ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
2190	public function isRegistered ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; return isset ( $ this -> arrIdentities [ $ intObjectId ] ) ; }
2298	public static function findSearchablePages ( $ pid = 0 , $ domain = '' , $ blnIsSitemap = false ) { $ objPages = PageModel :: findPublishedByPid ( $ pid , array ( 'ignoreFePreview' => true ) ) ; if ( $ objPages === null ) { return array ( ) ; } $ arrPages = array ( ) ; foreach ( $ objPages as $ objPage ) { if ( $ objPage -> type == 'regular' ) { if ( ( ! $ objPage -> noSearch || $ blnIsSitemap ) && ( ! $ objPage -> protected || ( Config :: get ( 'indexProtected' ) && ( ! $ blnIsSitemap || $ objPage -> sitemap == 'map_always' ) ) ) && ( ! $ blnIsSitemap || $ objPage -> sitemap != 'map_never' ) && ! $ objPage -> requireItem ) { $ arrPages [ ] = $ objPage -> getAbsoluteUrl ( ) ; if ( ( $ objArticles = ArticleModel :: findPublishedWithTeaserByPid ( $ objPage -> id , array ( 'ignoreFePreview' => true ) ) ) !== null ) { foreach ( $ objArticles as $ objArticle ) { $ arrPages [ ] = $ objPage -> getAbsoluteUrl ( '/articles/' . ( $ objArticle -> alias ? : $ objArticle -> id ) ) ; } } } } if ( ( ! $ objPage -> protected || Config :: get ( 'indexProtected' ) ) && ( $ arrSubpages = static :: findSearchablePages ( $ objPage -> id , $ domain , $ blnIsSitemap ) ) ) { $ arrPages = array_merge ( $ arrPages , $ arrSubpages ) ; } } return $ arrPages ; }
937	public static function getKeywords ( ) { static $ keywords = null ; if ( null === $ keywords ) { $ keywords = self :: getTokenKindsForNames ( [ 'T_ABSTRACT' , 'T_ARRAY' , 'T_AS' , 'T_BREAK' , 'T_CALLABLE' , 'T_CASE' , 'T_CATCH' , 'T_CLASS' , 'T_CLONE' , 'T_CONST' , 'T_CONTINUE' , 'T_DECLARE' , 'T_DEFAULT' , 'T_DO' , 'T_ECHO' , 'T_ELSE' , 'T_ELSEIF' , 'T_EMPTY' , 'T_ENDDECLARE' , 'T_ENDFOR' , 'T_ENDFOREACH' , 'T_ENDIF' , 'T_ENDSWITCH' , 'T_ENDWHILE' , 'T_EVAL' , 'T_EXIT' , 'T_EXTENDS' , 'T_FINAL' , 'T_FINALLY' , 'T_FOR' , 'T_FOREACH' , 'T_FUNCTION' , 'T_GLOBAL' , 'T_GOTO' , 'T_HALT_COMPILER' , 'T_IF' , 'T_IMPLEMENTS' , 'T_INCLUDE' , 'T_INCLUDE_ONCE' , 'T_INSTANCEOF' , 'T_INSTEADOF' , 'T_INTERFACE' , 'T_ISSET' , 'T_LIST' , 'T_LOGICAL_AND' , 'T_LOGICAL_OR' , 'T_LOGICAL_XOR' , 'T_NAMESPACE' , 'T_NEW' , 'T_PRINT' , 'T_PRIVATE' , 'T_PROTECTED' , 'T_PUBLIC' , 'T_REQUIRE' , 'T_REQUIRE_ONCE' , 'T_RETURN' , 'T_STATIC' , 'T_SWITCH' , 'T_THROW' , 'T_TRAIT' , 'T_TRY' , 'T_UNSET' , 'T_USE' , 'T_VAR' , 'T_WHILE' , 'T_YIELD' , 'T_YIELD_FROM' , ] ) + [ CT :: T_ARRAY_TYPEHINT => CT :: T_ARRAY_TYPEHINT , CT :: T_CLASS_CONSTANT => CT :: T_CLASS_CONSTANT , CT :: T_CONST_IMPORT => CT :: T_CONST_IMPORT , CT :: T_FUNCTION_IMPORT => CT :: T_FUNCTION_IMPORT , CT :: T_NAMESPACE_OPERATOR => CT :: T_NAMESPACE_OPERATOR , CT :: T_USE_TRAIT => CT :: T_USE_TRAIT , CT :: T_USE_LAMBDA => CT :: T_USE_LAMBDA , ] ; } return $ keywords ; }
10909	public function inject ( string ... $ methods ) : Binding { if ( $ this -> definition -> injects === null ) { $ this -> definition -> injects = \ array_fill_keys ( $ methods , true ) ; } else { foreach ( $ methods as $ f ) { $ this -> definition -> injects [ $ f ] = true ; } } return $ this ; }
10248	public function getGuid ( ) { return sprintf ( '%04x%04x-%04x-%03x4-%04x-%04x%04x%04x' , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 4095 ) , bindec ( substr_replace ( sprintf ( '%016b' , mt_rand ( 0 , 65535 ) ) , '01' , 6 , 2 ) ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) ) ; }
8880	private function isValidFullPath ( string $ path ) : bool { $ valid = false ; if ( '/' === substr ( $ path , 0 , 1 ) && is_executable ( $ path ) ) { $ valid = true ; } return $ valid ; }
2139	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) ) { return ; } $ this -> fetchHttpHeaders ( ) ; $ this -> setResponseHeaders ( $ event -> getResponse ( ) ) ; }
8734	public function increment ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> increment ( $ column , $ amount , $ extra ) ; }
12111	private function persist ( ) { $ bootstrap = Bootstrap :: getInstance ( ) ; $ config = $ bootstrap -> getConfiguration ( ) ; $ config [ 'pages' ] = array ( ) ; foreach ( $ this -> pages as $ page ) { $ page -> appendConfig ( $ config [ 'pages' ] ) ; } $ bootstrap -> setConfiguration ( $ config ) ; }
3539	public static function getAdldapProvider ( ) { if ( static :: getExtensionOptions ( 'adldap-providername' ) != '__USE_DEFAULT_PROVIDER__' ) { $ provider = Yii :: $ app -> ad -> getProvider ( static :: getExtensionOptions ( 'adldap-providername' ) ) ; } else { $ provider = Yii :: $ app -> ad -> getDefaultProvider ( ) ; } return $ provider ; }
12476	public function setCurrentTheme ( $ identifier ) { $ theme = $ this -> getTheme ( $ identifier ) ; $ this -> container -> get ( 'session' ) -> set ( '_admin_theme' , $ theme ) ; }
6932	private function isShipmentAmountInvoiced ( Invoice \ InvoiceInterface $ invoice ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getInvoices ( ) as $ i ) { if ( $ i === $ invoice ) { continue ; } if ( $ i -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_SHIPMENT ) ) { return true ; } } return false ; }
11477	public function boot ( Plugin $ theme ) { $ this -> plugin = $ theme ; parent :: boot ( $ theme ) ; $ this -> initTemplates ( ) ; $ this -> initHomepageTemplate ( ) ; return $ this ; }
4087	protected function transformDSLTermToString ( $ dslTerm ) { $ string = "" ; if ( is_array ( $ dslTerm ) ) { $ key = key ( $ dslTerm ) ; $ value = $ dslTerm [ $ key ] ; if ( is_string ( $ key ) ) $ string .= "$key:" ; } else $ value = $ dslTerm ; if ( strpos ( $ value , " " ) !== false ) $ string .= '"' . $ value . '"' ; else $ string .= $ value ; return $ string ; }
1060	public static function findDangerousChanges ( Schema $ oldSchema , Schema $ newSchema ) { return array_merge ( self :: findArgChanges ( $ oldSchema , $ newSchema ) [ 'dangerousChanges' ] , self :: findValuesAddedToEnums ( $ oldSchema , $ newSchema ) , self :: findInterfacesAddedToObjectTypes ( $ oldSchema , $ newSchema ) , self :: findTypesAddedToUnions ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnInputObjectTypes ( $ oldSchema , $ newSchema ) [ 'dangerousChanges' ] ) ; }
647	public function addCommentOnColumn ( $ table , $ column , $ comment ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addCommentOnColumn ( $ table , $ column , $ comment ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
9825	public function writeDrawingRelationships ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet , & $ chartRef , $ includeCharts = false ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ i = 1 ; $ iterator = $ pWorksheet -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { if ( $ iterator -> current ( ) instanceof \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Drawing || $ iterator -> current ( ) instanceof MemoryDrawing ) { $ this -> writeRelationship ( $ objWriter , $ i , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image' , '../media/' . str_replace ( ' ' , '' , $ iterator -> current ( ) -> getIndexedFilename ( ) ) ) ; } $ iterator -> next ( ) ; ++ $ i ; } if ( $ includeCharts ) { $ chartCount = $ pWorksheet -> getChartCount ( ) ; if ( $ chartCount > 0 ) { for ( $ c = 0 ; $ c < $ chartCount ; ++ $ c ) { $ this -> writeRelationship ( $ objWriter , $ i ++ , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart' , '../charts/chart' . ++ $ chartRef . '.xml' ) ; } } } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
1544	public function encodes ( string ... $ mediaTypes ) : bool { $ encoding = $ this -> getEncodingMediaType ( ) ; return collect ( $ mediaTypes ) -> contains ( function ( $ mediaType , $ index ) use ( $ encoding ) { return $ encoding -> equalsTo ( MediaType :: parse ( $ index , $ mediaType ) ) ; } ) ; }
4292	public function getCfg ( $ path = null ) { if ( ! \ strlen ( $ path ) ) { return $ this -> cfg ; } if ( isset ( $ this -> cfg [ $ path ] ) ) { return $ this -> cfg [ $ path ] ; } return null ; }
8340	public static function set ( string $ fileName , array $ content ) { try { $ json = Yaml :: dump ( $ content , 2 ) ; if ( file_put_contents ( $ fileName , $ json ) === false ) { throw new FileNotWritable ( 'can\'t write to "' . $ fileName . '"' ) ; } } catch ( DumpException $ e ) { throw new BadUse ( 'Config::set() content parameter can\'t be dump to YAML' ) ; } self :: $ files [ $ fileName ] = $ content ; }
10862	public function getHashes ( ) { if ( empty ( $ this -> hashes ) ) { $ this -> generateHashes ( ) ; } return json_encode ( $ this -> hashes , \ sndsgd \ Json :: HUMAN ) ; }
10554	public static function handleUnknownHost ( URL $ webroot , URL $ request , array $ sites , Dictionary $ cfg ) { $ on_unknown = strtoupper ( $ cfg -> dget ( 'unknown_host_policy' , "IGNORE" ) ) ; $ best_matching = self :: findBestMatching ( $ webroot , $ sites ) ; if ( $ on_unknown === "ERROR" || ( $ best_matching === null && $ on_unknown === "REDIRECT" ) ) return null ; if ( $ on_unknown === "REDIRECT" ) { $ redir = $ best_matching -> URL ( $ request -> path ) ; return $ redir ; } $ url = new URL ( $ webroot ) ; $ url -> fragment = null ; $ url -> query = null ; $ lang = $ cfg -> dget ( 'default_language' , 'en' ) ; $ vhost = new VirtualHost ( $ url , $ lang ) ; if ( $ best_matching === null ) { $ site = new Site ( ) ; $ site -> addVirtualHost ( $ vhost ) ; } else $ best_matching -> getSite ( ) -> addVirtualHost ( $ vhost ) ; return $ vhost ; }
1730	public function isMemberOf ( $ id ) { if ( ! is_numeric ( $ id ) ) { return false ; } $ groups = StringUtil :: deserialize ( $ this -> groups ) ; if ( empty ( $ groups ) || ! \ is_array ( $ groups ) ) { return false ; } if ( \ in_array ( $ id , $ groups ) ) { return true ; } return false ; }
3183	private function durationToMs ( $ duration ) { if ( ! is_null ( $ duration ) && $ duration instanceof QtiDuration ) { return TestRunnerUtils :: getDurationWithMicroseconds ( $ duration ) ; } return false ; }
607	private function tokenizeOperator ( & $ length ) { if ( ! $ this -> isOperator ( $ length , $ content ) ) { return false ; } $ this -> addTokenFromBuffer ( ) ; switch ( $ this -> substring ( $ length ) ) { case '(' : $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_PARENTHESIS ] ) ; $ this -> _tokenStack -> push ( $ this -> _currentToken [ - 1 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; break ; case ')' : $ this -> _tokenStack -> pop ( ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => ')' , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; break ; case ';' : if ( ! $ this -> _currentToken -> getHasChildren ( ) ) { break ; } $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; $ this -> _tokenStack -> pop ( ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_STATEMENT ] ) ; $ this -> _tokenStack -> push ( $ this -> _currentToken [ - 1 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; break ; default : $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; break ; } return true ; }
7846	public function cancel ( array $ identifiers = [ ] ) : ? array { $ this -> checkConfig ( ) ; if ( empty ( $ identifiers ) ) { return null ; } $ messages = [ ] ; foreach ( $ identifiers as $ id ) { $ messages [ ] = [ 'id' => ( int ) $ id ] ; } $ body = Body :: json ( $ messages ) ; $ response = Request :: post ( $ this -> baseUrl . 'message/cancel' , [ ] , $ body ) ; if ( $ response -> code == 200 ) { return [ 'code' => $ response -> code , 'message' => 'OK' , 'data' => $ response -> body , ] ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } return [ 'code' => $ response -> code , 'message' => $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } }
5485	public function hasImage ( SelectorInterface $ selector ) { foreach ( $ this -> images as $ image ) { if ( $ selector -> isMatch ( $ image ) ) { return true ; } } return false ; }
12681	public function send ( ) { if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message to send.' ) ; } $ transformer = new Transformer ( ) ; if ( $ this -> message instanceof RawMessage ) { $ message = $ this -> message -> get ( 'content' ) ; } else { $ content = $ transformer -> transform ( $ this -> message ) ; $ message = [ 'touser' => $ this -> to , ] ; if ( $ this -> account ) { $ message [ 'customservice' ] = [ 'kf_account' => $ this -> account ] ; } $ message = array_merge ( $ message , $ content ) ; } return $ this -> staff -> send ( $ message ) ; }
6153	public function setPropertyType ( $ propertyType ) { if ( $ propertyType instanceof PropertyType ) { $ this -> propertyType = $ propertyType ; } elseif ( is_array ( $ propertyType ) ) { $ this -> propertyType = new PropertyType ( $ propertyType ) ; } else { $ this -> propertyType = null ; trigger_error ( 'Argument must be an object of class PropertyType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
75	public function seek ( $ offset ) { $ this -> rewind ( ) ; for ( $ i = 0 ; $ i < $ offset ; $ i ++ , $ this -> next ( ) ) ; }
2550	protected function loadSessionHandler ( $ sessionHandler , $ params ) { if ( $ sessionHandler instanceof HandlerInterface ) { $ newSessionHandler = $ sessionHandler ; } else { $ newSessionHandler = HandlerFactory :: createHandler ( $ params ) ; } return $ newSessionHandler ; }
4625	public function prepare ( Command $ command , Node $ node ) { if ( $ this -> connection ) { $ this -> resetConnection ( ) ; } parent :: prepare ( $ command , $ node ) ; $ this -> buildPath ( ) ; $ this -> prepareConnection ( ) ; $ this -> prepareRequest ( ) ; return $ this ; }
12757	public function routeStartup ( Zend_Controller_Request_Abstract $ request ) { if ( ! $ request -> getHeader ( 'User-Agent' ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 403 ) -> setHeader ( 'Content-Type' , 'text/plain; charset=utf-8' ) -> setBody ( implode ( "\n" , self :: $ _errMessage ) ) -> sendResponse ( ) ; exit ( 403 ) ; } }
11823	public function replace ( $ middleware , $ with ) { $ this -> pipeline = $ this -> pipeline -> replace ( $ middleware , $ with ) ; return $ this ; }
10392	protected static function parseXml ( $ xmlFile ) { $ reader = new \ XMLReader ( ) ; $ libXmlErrors = libxml_use_internal_errors ( true ) ; $ errors = array ( ) ; if ( ! $ reader -> open ( $ xmlFile ) ) { throw new XmlParserException ( $ xmlFile , array ( ) ) ; } $ current = $ root = new Document ( ) ; $ parents = array ( $ root ) ; while ( @ $ reader -> read ( ) ) { switch ( $ reader -> nodeType ) { case \ XMLReader :: ELEMENT : $ nodeName = $ reader -> name ; array_push ( $ parents , $ current ) ; $ current = $ current -> $ nodeName = new Node ( ) ; $ emptyElement = $ reader -> isEmptyElement ; if ( $ reader -> hasAttributes ) { while ( $ reader -> moveToNextAttribute ( ) ) { $ current [ $ reader -> name ] = $ reader -> value ; } } if ( ! $ emptyElement ) { break ; } case \ XMLReader :: END_ELEMENT : $ current = array_pop ( $ parents ) ; break ; case \ XMLReader :: TEXT : case \ XMLReader :: CDATA : $ current -> setContent ( ( string ) $ current . $ reader -> value ) ; break ; } } if ( count ( $ errors = libxml_get_errors ( ) ) ) { libxml_use_internal_errors ( $ libXmlErrors ) ; libxml_clear_errors ( ) ; throw new XmlParserException ( $ xmlFile , $ errors ) ; } libxml_use_internal_errors ( $ libXmlErrors ) ; return $ root -> skipRoot ( ) ; }
6598	protected function getParameters ( array $ lines ) { $ comment = implode ( "\n" , $ lines ) ; preg_match_all ( '/@param\s([\s\S]+?(?=@))/' , $ comment , $ paramsDoc ) ; $ params = [ ] ; if ( isset ( $ paramsDoc [ 1 ] ) ) { foreach ( $ paramsDoc [ 1 ] as $ paramDoc ) { $ documentation = [ ] ; preg_match ( '/([^$]+)?\$(\w+)(.+)?/s' , $ paramDoc , $ documentation ) ; list ( , $ type , $ name , $ description ) = $ documentation ; $ lines = preg_split ( "/((\r?\n)|(\r\n?))/" , $ description ) ; foreach ( $ lines as $ key => $ value ) { $ value = preg_replace ( '/\r/' , '' , $ value ) ; $ value = preg_replace ( '/^\s+\*/' , '' , $ value ) ; $ value = trim ( $ value ) ; $ lines [ $ key ] = $ value ; } $ description = implode ( "\n" , $ lines ) ; $ params [ $ name ] = [ 'type' => trim ( $ type ) , 'description' => trim ( $ description ) , ] ; } } return $ params ; }
5518	public function invoke ( $ method , $ args ) { $ method = strtolower ( $ method ) ; $ step = $ this -> getCallCount ( $ method ) ; $ this -> addCall ( $ method , $ args ) ; $ this -> checkExpectations ( $ method , $ args , $ step ) ; $ was = $ this -> disableEStrict ( ) ; try { $ result = $ this -> emulateCall ( $ method , $ args , $ step ) ; } catch ( Exception $ e ) { $ this -> restoreEStrict ( $ was ) ; throw $ e ; } $ this -> restoreEStrict ( $ was ) ; return $ result ; }
10067	protected function registerTags ( ) { $ tags = array ( 'error' , 'hint' , 'label' , 'radioset' , 'checkboxset' ) ; foreach ( $ tags as $ tag ) { $ tagClass = str_replace ( ' ' , '' , ucwords ( str_replace ( '-' , ' ' , $ tag ) ) ) ; $ this -> registerTag ( $ tag , __NAMESPACE__ . '\Tag\\' . $ tagClass ) ; } $ widgets = array ( 'text' , 'file' , 'textarea' , 'radio' , 'checkbox' , 'select' , 'multiselect' , 'checkboxset' , 'radioset' , 'email' , 'password' , 'radioset' , 'checkboxset' , 'button' , 'submit' , 'reset' , 'group' , 'fieldset' , 'collection' , 'form' ) ; foreach ( $ widgets as $ widget ) { $ widgetClass = str_replace ( ' ' , '' , ucwords ( str_replace ( '-' , ' ' , $ widget ) ) ) ; $ this -> registerTag ( 'widget-' . $ widget , __NAMESPACE__ . '\Widget\\' . $ widgetClass ) ; } }
9597	protected function flashMessages ( $ messages ) { $ flashBag = $ this -> getSession ( ) -> getFlashBag ( ) ; foreach ( ( array ) $ messages as $ message ) { $ flashBag -> add ( '_messages' , $ message ) ; } }
5000	public function preRemove ( $ object ) { if ( ! is_null ( $ this -> urlProvider ) && ! is_null ( $ this -> menuManager ) ) { $ url = $ this -> urlProvider -> url ( $ object ) ; $ menuItem = $ this -> menuManager -> getItem ( $ url ) ; if ( $ menuItem instanceof MenuItem ) { $ this -> menuManager -> removeItem ( $ menuItem ) ; $ this -> menuManager -> flush ( ) ; } } }
591	protected function compressCssFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing CSS files...\n" ) ; if ( is_string ( $ this -> cssCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineCssFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> cssCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> cssCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress CSS files into '{$outputFile}'." ) ; } $ this -> stdout ( " CSS files compressed into '{$outputFile}'.\n" ) ; }
973	public function creating ( $ shop ) { if ( ! isset ( $ shop -> namespace ) ) { $ shop -> namespace = Config :: get ( 'shopify-app.namespace' ) ; } if ( Config :: get ( 'shopify-app.billing_freemium_enabled' ) === true && ! isset ( $ shop -> freemium ) ) { $ shop -> freemium = true ; } }
2200	public static function findPublishedByPidAndColumn ( $ intPid , $ strColumn , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.inColumn=?" ) ; $ arrValues = array ( $ intPid , $ strColumn ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
6251	protected function createGroupPresence ( $ id , $ label , array $ children = [ ] ) { return new AclPresence ( [ 'type' => AclPresenceType :: GROUP , 'id' => $ id , 'label' => $ label , 'children' => $ children , ] ) ; }
6315	public function setUpdateAction ( $ updateAction ) { $ updateAction = strtoupper ( $ updateAction ) ; if ( ! in_array ( $ updateAction , $ this -> getAvailableActions ( ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Action %s does not exist.' , $ updateAction ) ) ; } $ this -> updateAction = $ updateAction ; }
4143	public function getHeaders ( $ key = null ) { if ( $ key === null ) { return $ this -> headers ; } if ( isset ( $ this -> headers [ $ key ] ) ) { return $ this -> headers [ $ key ] ; } return false ; }
10428	private function initSyncStorage ( ContainerBuilder $ container , array $ config ) { $ availableStorages = array_keys ( $ config [ 'sync' ] [ 'sync_storage' ] ) ; $ syncStorageStorage = current ( $ availableStorages ) ; if ( empty ( $ syncStorageStorage ) ) { throw new LogicException ( 'Data synchronization storage must be set.' ) ; } $ syncStorageStorageConfig = $ config [ 'sync' ] [ 'sync_storage' ] [ $ syncStorageStorage ] ; switch ( $ syncStorageStorage ) { case SyncStorage :: STORAGE_MYSQL : $ this -> initSyncStorageForMysql ( $ container , $ syncStorageStorageConfig ) ; break ; default : throw new LogicException ( "Unknown storage is set: {$syncStorageStorage}" ) ; } }
178	public static function filter ( $ array , $ filters ) { $ result = [ ] ; $ forbiddenVars = [ ] ; foreach ( $ filters as $ var ) { $ keys = explode ( '.' , $ var ) ; $ globalKey = $ keys [ 0 ] ; $ localKey = isset ( $ keys [ 1 ] ) ? $ keys [ 1 ] : null ; if ( $ globalKey [ 0 ] === '!' ) { $ forbiddenVars [ ] = [ substr ( $ globalKey , 1 ) , $ localKey , ] ; continue ; } if ( ! array_key_exists ( $ globalKey , $ array ) ) { continue ; } if ( $ localKey === null ) { $ result [ $ globalKey ] = $ array [ $ globalKey ] ; continue ; } if ( ! isset ( $ array [ $ globalKey ] [ $ localKey ] ) ) { continue ; } if ( ! array_key_exists ( $ globalKey , $ result ) ) { $ result [ $ globalKey ] = [ ] ; } $ result [ $ globalKey ] [ $ localKey ] = $ array [ $ globalKey ] [ $ localKey ] ; } foreach ( $ forbiddenVars as $ var ) { list ( $ globalKey , $ localKey ) = $ var ; if ( array_key_exists ( $ globalKey , $ result ) ) { unset ( $ result [ $ globalKey ] [ $ localKey ] ) ; } } return $ result ; }
6031	public function addself ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate self. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "self"!' , E_USER_WARNING ) ; } } $ this -> childMedias [ ] = $ item ; return $ this ; }
9238	private function getTextualPath ( array $ path , Vertex $ startVertex ) { $ currentVertex = $ startVertex ; $ currentTable = $ currentVertex -> getId ( ) ; $ textPath = $ currentTable ; foreach ( $ path as $ edge ) { if ( $ fk = $ edge -> getAttribute ( 'fk' ) ) { if ( $ fk -> getForeignTableName ( ) == $ currentTable ) { $ currentTable = $ fk -> getLocalTable ( ) -> getName ( ) ; $ isForward = false ; } else { $ currentTable = $ fk -> getForeignTableName ( ) ; $ isForward = true ; } $ columns = implode ( ',' , $ fk -> getLocalColumns ( ) ) ; $ textPath .= ' ' . ( ! $ isForward ? '<' : '' ) ; $ textPath .= '--(' . $ columns . ')--' ; $ textPath .= ( $ isForward ? '>' : '' ) . ' ' ; $ textPath .= $ currentTable ; } elseif ( $ junctionTable = $ edge -> getAttribute ( 'junction' ) ) { $ junctionFks = array_values ( $ junctionTable -> getForeignKeys ( ) ) ; $ fk = $ junctionFks [ 0 ] ; if ( $ fk -> getForeignTableName ( ) == $ currentTable ) { $ currentTable = $ junctionFks [ 1 ] -> getForeignTableName ( ) ; } else { $ currentTable = $ fk -> getForeignTableName ( ) ; } $ textPath .= ' <=(' . $ junctionTable -> getName ( ) . ')=> ' . $ currentTable ; } else { throw new SchemaAnalyzerException ( 'Unexpected edge. We should have a fk or a junction attribute.' ) ; } } return $ textPath ; }
7494	public function trimRight ( $ characters = null ) { $ this -> string = rtrim ( $ this -> string , $ characters ) ; return $ this ; }
3702	protected function getLegend ( $ name , $ palette , $ prevLegend = null ) { if ( strpos ( $ name , '+' ) === 0 ) { $ name = substr ( $ name , 1 ) ; } if ( ! $ palette -> hasLegend ( $ name ) ) { $ palette -> addLegend ( new Legend ( $ name ) , $ prevLegend ) ; } return $ palette -> getLegend ( $ name ) ; }
750	public function save ( $ filePath , $ messages ) { $ language = str_replace ( '-' , '_' , basename ( dirname ( $ filePath ) ) ) ; $ headers = [ 'msgid ""' , 'msgstr ""' , '"Project-Id-Version: \n"' , '"POT-Creation-Date: \n"' , '"PO-Revision-Date: \n"' , '"Last-Translator: \n"' , '"Language-Team: \n"' , '"Language: ' . $ language . '\n"' , '"MIME-Version: 1.0\n"' , '"Content-Type: text/plain; charset=' . Yii :: $ app -> charset . '\n"' , '"Content-Transfer-Encoding: 8bit\n"' , ] ; $ content = implode ( "\n" , $ headers ) . "\n\n" ; foreach ( $ messages as $ id => $ message ) { $ separatorPosition = strpos ( $ id , chr ( 4 ) ) ; if ( $ separatorPosition !== false ) { $ content .= 'msgctxt "' . substr ( $ id , 0 , $ separatorPosition ) . "\"\n" ; $ id = substr ( $ id , $ separatorPosition + 1 ) ; } $ content .= 'msgid "' . $ this -> encode ( $ id ) . "\"\n" ; $ content .= 'msgstr "' . $ this -> encode ( $ message ) . "\"\n\n" ; } file_put_contents ( $ filePath , $ content ) ; }
11808	public function paginate ( $ perPage = null , $ columns = array ( '*' ) ) { $ columnsPassed = ( func_num_args ( ) > 1 ) && ( $ columns !== null ) ; $ columns = $ columnsPassed ? $ columns : $ this -> getQueryColumns ( ) ; $ query = $ this -> buildQuery ( $ columns ) ; if ( $ columnsPassed ) { return $ query -> paginate ( $ perPage , $ columns ) ; } return $ query -> paginate ( $ perPage , $ this -> getQueryColumns ( ) ) ; }
576	public function run ( $ id = null ) { if ( Yii :: $ app -> getRequest ( ) -> getMethod ( ) !== 'OPTIONS' ) { Yii :: $ app -> getResponse ( ) -> setStatusCode ( 405 ) ; } $ options = $ id === null ? $ this -> collectionOptions : $ this -> resourceOptions ; $ headers = Yii :: $ app -> getResponse ( ) -> getHeaders ( ) ; $ headers -> set ( 'Allow' , implode ( ', ' , $ options ) ) ; $ headers -> set ( 'Access-Control-Allow-Methods' , implode ( ', ' , $ options ) ) ; }
11563	public function LineBreaks ( $ text , $ lang = "" ) { $ this -> text = $ text ; $ word = "" ; $ lang = $ lang ? $ lang : $ this -> lang ; list ( $ weekWords , $ units , $ shortcuts ) = $ this -> getWeekWordsUnitsAndShortcuts ( $ lang ) ; $ this -> text = preg_replace ( "#\t+#mu" , " " , $ this -> text ) ; $ this -> text = preg_replace ( "#[ ]{2,}#mu" , " " , $ this -> text ) ; for ( $ i = 0 , $ l = count ( $ weekWords ) ; $ i < $ l ; $ i += 1 ) { $ word = $ weekWords [ $ i ] ; $ this -> processWeakWord ( $ word ) ; $ word = mb_strtoupper ( mb_substr ( $ word , 0 , 1 ) ) . mb_substr ( $ word , 1 ) ; $ this -> processWeakWord ( $ word ) ; } for ( $ i = 0 , $ l = count ( $ units ) ; $ i < $ l ; $ i += 1 ) { $ word = $ units [ $ i ] ; $ regExp = "#([0-9])\\s(" . $ word . ")#mu" ; $ this -> text = preg_replace ( $ regExp , "$1&nbsp;$2" , $ this -> text ) ; } foreach ( $ shortcuts as $ sourceShortcut => $ targetShortcut ) { $ this -> text = str_replace ( $ sourceShortcut , $ targetShortcut , $ this -> text ) ; } $ this -> text = preg_replace ( "#([0-9])\s([0-9])#" , "$1&nbsp;$2" , $ this -> text ) ; return $ this -> text ; }
723	public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ enable = $ check ? 'CHECK' : 'NOCHECK' ; $ schema = $ schema ? : $ this -> db -> getSchema ( ) -> defaultSchema ; $ tableNames = $ this -> db -> getTableSchema ( $ table ) ? [ $ table ] : $ this -> db -> getSchema ( ) -> getTableNames ( $ schema ) ; $ viewNames = $ this -> db -> getSchema ( ) -> getViewNames ( $ schema ) ; $ tableNames = array_diff ( $ tableNames , $ viewNames ) ; $ command = '' ; foreach ( $ tableNames as $ tableName ) { $ tableName = $ this -> db -> quoteTableName ( "{$schema}.{$tableName}" ) ; $ command .= "ALTER TABLE $tableName $enable CONSTRAINT ALL; " ; } return $ command ; }
1376	protected function validateTypeMember ( $ value , string $ path ) : bool { if ( ! is_string ( $ value ) ) { $ this -> memberNotString ( $ path , 'type' ) ; return false ; } if ( empty ( $ value ) ) { $ this -> memberEmpty ( $ path , 'type' ) ; return false ; } if ( ! $ this -> store -> isType ( $ value ) ) { $ this -> resourceTypeNotRecognised ( $ value , $ path ) ; return false ; } return true ; }
11174	public static function hash ( $ string , $ algorithm = 'blowfish' ) { switch ( strtolower ( $ algorithm ) ) : case ( 'md5' ) : $ salt = '$1$' . ( static :: rand ( 12 ) ) . '$' ; break ; case ( 'sha256' ) : $ salt = '$5$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'sha512' ) : $ salt = '$6$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'blowfish' ) : default : $ salt = '$2a$09$' . ( static :: rand ( 22 ) ) . '$' ; break ; endswitch ; return base64_encode ( crypt ( $ string , $ salt ) ) ; }
824	public function getName ( ) { if ( null === $ this -> name ) { Preg :: matchAll ( '/@[a-zA-Z0-9_-]+(?=\s|$)/' , $ this -> line -> getContent ( ) , $ matches ) ; if ( isset ( $ matches [ 0 ] [ 0 ] ) ) { $ this -> name = ltrim ( $ matches [ 0 ] [ 0 ] , '@' ) ; } else { $ this -> name = 'other' ; } } return $ this -> name ; }
821	private function splitUpDocBlock ( $ lines , Tokens $ tokens , $ docBlockIndex ) { $ lineContent = $ this -> getSingleLineDocBlockEntry ( $ lines ) ; $ lineEnd = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ originalIndent = $ this -> detectIndent ( $ tokens , $ tokens -> getNextNonWhitespace ( $ docBlockIndex ) ) ; return [ new Line ( '/**' . $ lineEnd ) , new Line ( $ originalIndent . ' * ' . $ lineContent . $ lineEnd ) , new Line ( $ originalIndent . ' */' ) , ] ; }
2641	public function cleanBySurrogateKey ( $ keys ) { $ type = 'clean by key on ' ; $ uri = $ this -> _getApiServiceUri ( ) . 'purge' ; $ num = count ( $ keys ) ; $ result = false ; if ( $ num >= self :: FASTLY_MAX_HEADER_KEY_SIZE ) { $ parts = $ num / self :: FASTLY_MAX_HEADER_KEY_SIZE ; $ additional = ( $ parts > ( int ) $ parts ) ? 1 : 0 ; $ parts = ( int ) $ parts + ( int ) $ additional ; $ chunks = ceil ( $ num / $ parts ) ; $ collection = array_chunk ( $ keys , $ chunks ) ; } else { $ collection = [ $ keys ] ; } foreach ( $ collection as $ keys ) { $ payload = json_encode ( [ 'surrogate_keys' => $ keys ] ) ; $ result = $ this -> _purge ( $ uri , null , \ Zend_Http_Client :: POST , $ payload ) ; if ( $ result [ 'status' ] ) { foreach ( $ keys as $ key ) { $ this -> logger -> execute ( 'surrogate key: ' . $ key ) ; } } $ canPublishKeyUrlChanges = $ this -> config -> canPublishKeyUrlChanges ( ) ; $ canPublishPurgeChanges = $ this -> config -> canPublishPurgeChanges ( ) ; if ( $ this -> config -> areWebHooksEnabled ( ) && ( $ canPublishKeyUrlChanges || $ canPublishPurgeChanges ) ) { $ status = $ result [ 'status' ] ? '' : 'FAILED ' ; $ this -> sendWebHook ( $ status . '*clean by key on ' . join ( " " , $ keys ) . '*' ) ; $ canPublishPurgeByKeyDebugBacktrace = $ this -> config -> canPublishPurgeByKeyDebugBacktrace ( ) ; $ canPublishPurgeDebugBacktrace = $ this -> config -> canPublishPurgeDebugBacktrace ( ) ; if ( $ canPublishPurgeByKeyDebugBacktrace == false && $ canPublishPurgeDebugBacktrace == false ) { return $ result [ 'status' ] ; } $ this -> stackTrace ( $ type . join ( " " , $ keys ) ) ; } } return $ result [ 'status' ] ; }
7762	public function getContext ( $ exposedClassName ) { $ classes = $ this -> metadata -> getAllMetadata ( ) ; $ metadata = null ; foreach ( $ classes as $ class ) { if ( $ class -> getExposeAs ( ) === $ exposedClassName ) { $ metadata = $ class ; break ; } } if ( null === $ metadata ) { return null ; } $ context = array ( 'hydra' => 'http://www.w3.org/ns/hydra/core#' , 'vocab' => $ this -> vocabUrl . '#' ) ; $ context [ $ exposedClassName ] = ( $ metadata -> isExternalReference ( ) ) ? $ metadata -> getIri ( ) : 'vocab:' . $ metadata -> getIri ( ) ; foreach ( $ metadata -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( $ property -> getExposeAs ( ) , '@' , 1 ) ) { continue ; } $ termDefinition = ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : 'vocab:' . $ property -> getIri ( ) ; if ( $ property -> getRoute ( ) ) { $ termDefinition = array ( '@id' => $ termDefinition , '@type' => '@id' ) ; } elseif ( $ this -> hasNormalizer ( $ property -> getType ( ) ) ) { $ normalizer = $ this -> getNormalizer ( $ property -> getType ( ) ) ; $ termDefinition = array ( '@id' => $ termDefinition , '@type' => $ normalizer -> getTypeIri ( ) ) ; } $ context [ $ property -> getExposeAs ( ) ] = $ termDefinition ; } return array ( '@context' => $ context ) ; }
1661	public function render ( ) { $ mediaObject = [ ] ; $ mediaObject [ 'contentUrl' ] = $ this -> url ; if ( $ this -> name ) { $ mediaObject [ 'name' ] = $ this -> name ; } if ( $ this -> description ) { $ mediaObject [ 'description' ] = $ this -> description ; } if ( $ this -> icon ) { $ mediaObject [ 'icon' ] = [ 'url' => $ this -> icon ] ; } if ( $ this -> image ) { $ mediaObject [ 'largeImage' ] = [ 'url' => $ this -> image ] ; } return $ mediaObject ; }
8566	public function getShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_GetShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_GetShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_GetShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10528	protected function getIpAddressFromProxy ( ) { if ( ! $ this -> useProxy || ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) && ! in_array ( $ _SERVER [ 'REMOTE_ADDR' ] , $ this -> trustedProxies ) ) ) { return false ; } $ header = $ this -> proxyHeader ; if ( ! isset ( $ _SERVER [ $ header ] ) || empty ( $ _SERVER [ $ header ] ) ) { return false ; } $ ips = explode ( ',' , $ _SERVER [ $ header ] ) ; $ ips = array_map ( 'trim' , $ ips ) ; $ ips = array_diff ( $ ips , $ this -> trustedProxies ) ; if ( empty ( $ ips ) ) { return false ; } $ ip = array_pop ( $ ips ) ; return $ ip ; }
1833	public function onUnregister ( Registry $ registry ) { foreach ( static :: getUniqueFields ( ) as $ strColumn ) { $ varAliasValue = $ this -> { $ strColumn } ; if ( $ registry -> isRegisteredAlias ( $ this , $ strColumn , $ varAliasValue ) ) { $ registry -> unregisterAlias ( $ this , $ strColumn , $ varAliasValue ) ; } } }
12016	public function unwatch ( ) { if ( ! $ this -> client -> getCommandFactory ( ) -> supportsCommand ( 'UNWATCH' ) ) { throw new NotSupportedException ( 'UNWATCH is not supported by the current command factory.' ) ; } $ this -> state -> unflag ( MultiExecState :: WATCH ) ; $ this -> __call ( 'UNWATCH' , array ( ) ) ; return $ this ; }
7534	function getPlainTextUTF8 ( ) { $ txt = $ this -> toString ( true , true , true ) ; $ enc = $ this -> getEncoding ( ) ; if ( $ enc !== false ) { $ txt = mb_convert_encoding ( $ txt , 'UTF-8' , $ enc ) ; } return preg_replace ( '`\s+`' , ' ' , html_entity_decode ( $ txt , ENT_QUOTES , 'UTF-8' ) ) ; }
12498	public static function insertOne ( $ document , $ connection ) { $ connection -> query = self :: singleDocument ( $ document ) ; return self :: insert ( $ connection ) ; }
8868	public function notify ( PayloadInterface $ payload ) { foreach ( $ this -> runners as $ runner ) { $ runner -> run ( $ payload ) ; } return $ this ; }
1745	public function showFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { if ( Contao \ Input :: get ( 'popup' ) ) { return '' ; } else { return '<a href="contao/popup.php?src=' . base64_encode ( $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . ' onclick="Backend.openModalIframe({\'title\':\'' . str_replace ( "'" , "\\'" , Contao \ StringUtil :: specialchars ( $ row [ 'fileNameEncoded' ] ) ) . '\',\'url\':this.href});return false">' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } }
7652	public function url_stat ( $ path , $ flags ) { $ stat = array ( ) ; $ stat [ 'dev' ] = 0 ; $ stat [ 'ino' ] = 0 ; $ stat [ 'mode' ] = 0 ; $ stat [ 'nlink' ] = 0 ; $ stat [ 'uid' ] = 0 ; $ stat [ 'gid' ] = 0 ; $ stat [ 'rdev' ] = 0 ; $ stat [ 'size' ] = 0 ; $ stat [ 'atime' ] = 0 ; $ stat [ 'mtime' ] = 0 ; $ stat [ 'ctime' ] = 0 ; $ stat [ 'blksize' ] = 0 ; $ stat [ 'blocks' ] = 0 ; $ info = null ; try { $ info = $ this -> getStorageClient ( $ path ) -> getBlobInstance ( $ this -> getContainerName ( $ path ) , $ this -> getFileName ( $ path ) ) ; $ stat [ 'size' ] = $ info -> Size ; $ lastmodified = strtotime ( $ info -> LastModified ) ; $ stat [ 'mtime' ] = $ lastmodified ; $ stat [ 'ctime' ] = $ lastmodified ; $ stat [ 'mode' ] = 0100000 ; return array_values ( $ stat ) + $ stat ; } catch ( BlobException $ ex ) { return false ; } }
11557	protected function detectNamespace ( $ settings ) { foreach ( $ this -> options -> getNamespaces ( ) as $ namespaceOptions ) { $ namespaceEntityClass = $ namespaceOptions -> getEntityClass ( ) ; if ( $ settings instanceof $ namespaceEntityClass ) { return $ namespaceOptions -> getName ( ) ; } } throw new Exception \ InvalidArgumentException ( 'Unknown Settings namespace' ) ; }
9396	public function setSafe ( $ options ) { if ( is_string ( $ options ) ) { $ this -> safe [ ] = $ options ; return $ this ; } if ( is_array ( $ options ) ) { foreach ( $ options as $ key => $ value ) { $ this -> safe [ ] = $ value ; } return $ this ; } throw new InvalidArgumentException ( 'This method expects a string or an array argument.' ) ; }
3098	public function getStateMessage ( $ testSession ) { if ( $ testSession instanceof AssessmentTestSession ) { switch ( $ testSession -> getState ( ) ) { case AssessmentTestSessionState :: SUSPENDED : return $ this -> getPausedStateMessage ( $ testSession ) ; case AssessmentTestSessionState :: CLOSED : return $ this -> getTerminatedStateMessage ( $ testSession ) ; case AssessmentTestSessionState :: INITIAL : return $ this -> getInitialStateMessage ( $ testSession ) ; default : return $ this -> getRunningStateMessages ( $ testSession ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerMessageService' , 'getStateMessage' , 0 , 'qtism\runtime\tests\AssessmentTestSession' , $ testSession ) ; } }
3090	public function process ( ) { $ this -> validate ( ) ; $ itemRef = $ this -> hasRequestParameter ( 'itemDefinition' ) ? $ this -> getItemRef ( $ this -> getRequestParameter ( 'itemDefinition' ) ) : null ; $ traceData = json_decode ( html_entity_decode ( $ this -> getRequestParameter ( 'traceData' ) ) , true ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ stored = 0 ; $ size = count ( $ traceData ) ; foreach ( $ traceData as $ variableIdentifier => $ variableValue ) { if ( $ this -> getRunnerService ( ) -> storeTraceVariable ( $ serviceContext , $ itemRef , $ variableIdentifier , $ variableValue ) ) { $ stored ++ ; } } $ response = [ 'success' => $ stored == $ size ] ; common_Logger :: d ( 'Stored "' . $ stored . '/' . $ size . '" trace variables' ) ; $ eventManager = $ this -> getServiceLocator ( ) -> get ( EventManager :: SERVICE_ID ) ; $ event = new TraceVariableStored ( $ serviceContext -> getTestSession ( ) -> getSessionId ( ) , $ traceData ) ; $ eventManager -> trigger ( $ event ) ; } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
6618	protected function parseEndpointName ( $ method , $ endpoint ) { $ endpoint = str_replace ( ' ' , '' , ucwords ( str_replace ( [ '-' , '+' , '%20' ] , ' ' , $ endpoint ) ) ) ; $ method = strtolower ( $ method ) ; return $ method . $ endpoint . 'Endpoint' ; }
10890	public static function input ( $ prompt , $ default = null ) { $ ret = false ; while ( ! $ ret ) { if ( $ prompt ) { echo $ prompt ; if ( $ default ) echo " (" . $ default . ")" ; echo ": " ; } $ ret = trim ( fgets ( STDIN ) ) ; if ( ! $ ret && $ default !== null ) return $ default ; } return trim ( $ ret ) ; }
828	private function isValidVariable ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_VARIABLE ) ) { return false ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; return $ tokens [ $ nextIndex ] -> equals ( '=' ) ; }
5770	public function getLoggedInAdministrator ( ) : Administrator { if ( ! isset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { throw new \ Exception ( "No one is logged in" ) ; } if ( null === $ administrator = ( AdministratorsEntityMapper :: getInstance ( ) ) -> getObjectById ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { unset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ; throw new \ Exception ( "Invalid administrator id " . $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] . " in session" ) ; } return $ administrator ; }
3483	public function withMutableContent ( bool $ mutableContent ) : Aps { $ cloned = clone $ this ; $ cloned -> mutableContent = $ mutableContent ; return $ cloned ; }
13	public function setClassMapAuthoritative ( $ classMapAuthoritative = false ) { $ this -> classMapAuthoritative = ( bool ) $ classMapAuthoritative ; if ( $ this -> classMapAuthoritative ) { $ this -> setOptimizeAutoloader ( true ) ; } return $ this ; }
8761	public function writeLogLine ( Tick $ tick ) { $ lineSegs = array ( ) ; switch ( $ tick -> getStatus ( ) ) { case Tick :: SUCCESS : $ lineSegs [ ] = sprintf ( "<fg=green>%s</fg=green>" , $ this -> linePrefixMap [ Tick :: SUCCESS ] ) ; break ; case Tick :: FAIL : $ lineSegs [ ] = sprintf ( "<fg=red>%s</fg=red>" , $ this -> linePrefixMap [ Tick :: FAIL ] ) ; break ; case Tick :: SKIP : default : $ lineSegs [ ] = $ this -> linePrefixMap [ Tick :: SKIP ] ; } $ lineSegs [ ] = sprintf ( "[%s%s]" , $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , $ tick -> getReport ( ) -> getTotalItemCount ( ) != Tracker :: UNKNOWN ? "/" . $ tick -> getReport ( ) -> getTotalItemCount ( ) : '' ) ; if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERBOSE ) { $ lineSegs [ ] = $ this -> formatSeconds ( $ tick -> getReport ( ) -> getTimeElapsed ( ) ) ; $ lineSegs [ ] = sprintf ( '(<fg=green>%s</fg=green>/%s/<fg=red>%s</fg=red>)' , $ tick -> getReport ( ) -> getNumItemsSuccess ( ) , $ tick -> getReport ( ) -> getNumItemsSkip ( ) , $ tick -> getReport ( ) -> getNumItemsFail ( ) ) ; } if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERY_VERBOSE ) { $ lineSegs [ ] = sprintf ( "{%s/%s}" , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemUsage ( ) ) , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemPeakUsage ( ) ) ) ; } $ lineSegs [ ] = $ tick -> getMessage ( ) ? : sprintf ( "Processing item %s" , number_format ( $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , 0 ) ) ; $ this -> output -> writeln ( implode ( ' ' , $ lineSegs ) ) ; }
4985	public function setParam ( $ key , $ value ) { $ this -> params [ $ key ] = $ value ; foreach ( $ this -> forms as $ form ) { if ( isset ( $ form [ '__instance__' ] ) && is_object ( $ form [ '__instance__' ] ) && method_exists ( $ form [ '__instance__' ] , 'setParam' ) ) { $ form [ '__instance__' ] -> setParam ( $ key , $ value ) ; } } return $ this ; }
4017	protected function handleLoadCallback ( $ field , $ value ) { if ( isset ( $ field [ 'load_callback' ] ) && is_array ( $ field [ 'load_callback' ] ) ) { foreach ( $ field [ 'load_callback' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ value = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ value , $ this ) ; } } return $ value ; }
4109	public function toOptionArray ( ) { $ options = array ( ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_comment' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Comments' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_opentip' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_tipOnly' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups (border initially invisible)' ) ) ; Mage :: dispatchEvent ( 'aoetemplatehints_hintrenderer_options' , array ( 'options' => & $ options ) ) ; return $ options ; }
11337	public function getMigrationClassName ( ) { $ postfix = '_initial_' . $ this -> tableName ; if ( is_dir ( $ this -> migrationDirectory ) ) { $ searchExisting = FileHelper :: findFiles ( $ this -> migrationDirectory , [ 'only' => [ $ postfix . '.php' ] ] ) ; if ( ! empty ( $ searchExisting ) ) { return strstr ( basename ( $ searchExisting [ 0 ] ) , '.php' , true ) ; } } return 'm' . gmdate ( 'ymd_His' , $ this -> migrationTimestamp ) . $ postfix ; }
4302	public function groupUncollapse ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ curDepth = 0 ; foreach ( $ this -> rootInstance -> groupStackRef as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entryKeys = \ array_keys ( $ this -> internal -> getCurrentGroups ( $ this -> rootInstance -> logRef , $ curDepth ) ) ; foreach ( $ entryKeys as $ key ) { $ this -> rootInstance -> logRef [ $ key ] [ 0 ] = 'group' ; } $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; }
11114	public function rollback ( array $ options = [ ] ) : void { $ migrations = $ this -> getMigrationsForRollback ( $ options ) ; if ( count ( $ migrations ) === 0 ) { $ this -> notify -> note ( '<info>Nothing to rollback.</info>' ) ; return ; } $ this -> rollbackMigrations ( $ migrations ) ; }
15	public function replaceVersion ( $ version , $ prettyVersion ) { $ this -> version = $ version ; $ this -> prettyVersion = $ prettyVersion ; $ this -> stability = VersionParser :: parseStability ( $ version ) ; $ this -> dev = $ this -> stability === 'dev' ; }
9058	public function addForeignKey ( string $ name , $ mapperClass , $ onDelete = true , $ onUpdate = false ) : Column { $ table = $ this -> getTableData ( $ mapperClass ) ; $ constrait = new Constrait ( $ name , $ this , $ table , $ onDelete , $ onUpdate ) ; $ this -> constraints [ $ constrait -> name ] = $ constrait ; return $ constrait -> column ; }
4056	private function convertLegend ( array $ property , bool $ trans , $ condition , array & $ legend , array & $ result ) { if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } $ legend = [ 'label' => $ trans ? unserialize ( $ property [ 'legendtitle' ] , [ 'allowed_classes' => false ] ) : [ '' => $ property [ 'legendtitle' ] ] , 'hide' => ( bool ) $ property [ 'legendhide' ] , 'properties' => [ ] , 'condition' => $ condition ( $ property ) ] ; }
1858	public function rename ( $ strOldName , $ strNewName ) { if ( $ strOldName == $ strNewName ) { return true ; } $ this -> validate ( $ strOldName , $ strNewName ) ; if ( \ defined ( 'PHP_WINDOWS_VERSION_BUILD' ) && file_exists ( $ this -> strRootDir . '/' . $ strNewName ) && strcasecmp ( $ strOldName , $ strNewName ) !== 0 ) { $ this -> delete ( $ strNewName ) ; } if ( strcasecmp ( $ strOldName , $ strNewName ) === 0 && strcmp ( $ strOldName , $ strNewName ) !== 0 ) { rename ( $ this -> strRootDir . '/' . $ strOldName , $ this -> strRootDir . '/' . $ strOldName . '__' ) ; $ strOldName .= '__' ; } return rename ( $ this -> strRootDir . '/' . $ strOldName , $ this -> strRootDir . '/' . $ strNewName ) ; }
1429	protected function fillSoftDelete ( Model $ record , $ field , $ value ) { $ value = $ this -> deserializeSoftDelete ( $ value , $ field , $ record ) ; $ record -> forceFill ( [ $ this -> getSoftDeleteKey ( $ record ) => $ value , ] ) ; }
6388	public function readSite ( ) { $ model = $ this -> readCourse ( 1 ) ; $ model -> url = $ this -> cfg -> wwwroot ; $ model -> type = "site" ; return $ model ; }
8554	public function setLoanServicingEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LoanServicingEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8746	public function getListenerInstance ( EventDispatcher $ eventDispatcher = null , StreamableInterface $ stream = null ) { $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Matcher' ) ; $ matcher = $ reflection -> newInstance ( ) ; $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Listener' ) ; if ( null === $ eventDispatcher ) { $ eventDispatcher = new EventDispatcher ( ) ; } if ( null === $ stream ) { $ stream = new Stream ( ) ; } $ listener = $ reflection -> newInstance ( $ matcher , $ eventDispatcher , $ stream ) ; return $ listener ; }
5762	public function indexView ( Response $ response , ? array $ displayItems = null ) { if ( $ displayItems === null ) { $ displayItems = $ this -> getDisplayItems ( ) ; } $ filterErrorMessage = FormHelper :: getFieldError ( $ this -> sessionFilterFieldKey ) ; FormHelper :: unsetSessionFormErrors ( ) ; return $ this -> view -> render ( $ response , $ this -> template , [ 'title' => $ this -> mapper -> getListViewTitle ( ) , 'insertLinkInfo' => $ this -> insertLinkInfo , 'filterOpsList' => QueryBuilder :: getWhereOperatorsText ( ) , 'filterValue' => $ this -> getFilterFieldValue ( ) , 'filterErrorMessage' => $ filterErrorMessage , 'filterFormActionRoute' => $ this -> indexRoute , 'filterFieldName' => $ this -> sessionFilterFieldKey , 'isFiltered' => $ this -> getFilterFieldValue ( ) != '' , 'resetFilterRoute' => $ this -> filterResetRoute , 'updatesPermitted' => $ this -> updatesPermitted , 'updateColumn' => $ this -> updateColumn , 'updateRoute' => $ this -> updateRoute , 'deletesPermitted' => $ this -> deletesPermitted , 'deleteRoute' => $ this -> deleteRoute , 'displayItems' => $ displayItems , 'columnCount' => $ this -> mapper -> getCountSelectColumns ( ) , 'sortColumn' => $ this -> mapper -> getListViewSortColumn ( ) , 'sortAscending' => $ this -> mapper -> getListViewSortAscending ( ) , 'navigationItems' => $ this -> navigationItems ] ) ; }
639	public function renameColumn ( $ table , $ oldName , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameColumn ( $ table , $ oldName , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
2849	public function setSqlProfilerStatus ( $ isEnabled ) { $ filePath = $ this -> getLocalXmlFilePath ( ) ; $ xml = $ this -> loadXmlFile ( $ filePath ) ; if ( $ xml === false ) { throw new Exception ( "Unable to parse local.xml configuration file: {$filePath}" ) ; } $ connectionNode = $ xml -> global -> resources -> default_setup -> connection ; if ( $ isEnabled ) { $ connectionNode -> profiler = '1' ; } else { unset ( $ connectionNode -> profiler ) ; } if ( $ this -> saveXml ( $ xml , $ filePath ) === false ) { throw new Exception ( "Unable to save {$filePath}: check if web server user has write permission" ) ; } }
10457	public function to ( Uom $ uom ) { $ conversionFactor = Uom :: getConversionFactor ( $ this -> getUom ( ) , $ uom ) ; return new static ( $ this -> getAmount ( ) -> multiply ( $ conversionFactor ) , $ uom ) ; }
6121	public function permissionGetIdByName ( $ name ) { if ( ! array_key_exists ( ( string ) $ name , $ this -> permissionList ( ) ) ) { throw new Ts3Exception ( "invalid permission ID" , 0xA02 ) ; } return $ this -> permissionList [ ( string ) $ name ] [ "permid" ] ; }
12367	protected function getOption ( $ name ) { if ( ! isset ( $ this -> options [ $ name ] ) ) { throw new ValueNotFoundException ( $ name ) ; } return $ this -> options [ $ name ] ; }
12698	static function archiveDir ( $ sourcedir , $ archivefile , $ no_top_dir = false ) { $ archivefile = str_replace ( '\\' , '/' , $ archivefile ) ; $ sourcedir = str_replace ( '\\' , '/' , realpath ( $ sourcedir ) ) ; if ( $ no_top_dir ) { $ srcdir = '.' ; $ workdir = $ sourcedir ; } else { $ srcdir = basename ( $ sourcedir ) ; $ workdir = dirname ( $ sourcedir ) ; } $ archivedir = dirname ( $ archivefile ) ; $ extra = '' ; $ tar = self :: getTool ( 'tar' ) ; if ( substr ( $ archivefile , - 7 ) == '.tar.gz' || substr ( $ archivefile , - 4 ) == '.tgz' ) { $ cmd = "$tar -z -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 8 ) == '.tar.bz2' ) { $ cmd = "$tar -j -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 4 ) == '.tar' ) { $ cmd = "$tar -cvf" ; $ extra = "-C " . escapeshellarg ( $ workdir ) ; $ workdir = $ archivedir ; $ archivefile = basename ( $ archivefile ) ; } else if ( substr ( $ archivefile , - 4 ) == '.zip' ) { $ zip = self :: getTool ( 'zip' ) ; $ cmd = "$zip -9 -r" ; } else { throw new pakeException ( "Can not determine archive type from filename: $archivefile" ) ; } pake_sh ( self :: getCdCmd ( $ workdir ) . " && $cmd $archivefile $extra $srcdir" ) ; pake_echo_action ( 'file+' , $ archivefile ) ; }
7395	protected function _getByName ( $ propName ) { if ( array_key_exists ( $ propName , $ this -> _map ) ) { $ propName = $ this -> _map [ $ propName ] ; } if ( $ this -> { $ propName } instanceof AtomicInterface ) { return $ this -> { $ propName } -> get ( ) ; } $ getter = '_get_' . $ propName ; if ( method_exists ( $ this -> _calledClass , $ getter ) ) { return $ this -> { $ getter } ( ) ; } return $ this -> { $ propName } ; }
11894	public function encrypt ( $ data ) { if ( $ this -> iv === null ) { $ dataEncrypted = mcrypt_encrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode ) ; } else { $ dataEncrypted = mcrypt_encrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode , $ this -> iv ) ; } return bin2hex ( $ dataEncrypted ) ; }
11998	static public function generatePhalcon ( $ modelName , $ field , $ length = 16 ) { do { $ generate = self :: generate ( $ length ) ; } while ( self :: phalconQuery ( $ modelName , $ field , $ generate ) ) ; return $ generate ; }
3342	public function getGroupList ( $ options = array ( ) ) { $ options = array_replace ( array ( 'from' => null , 'to' => null , 'limit' => null , 'request_limit' => null , 'reversed' => false , ) , $ options ) ; if ( ! empty ( $ options [ 'from' ] ) && ! empty ( $ options [ 'to' ] ) ) { throw new \ Exception ( 'Only one of "from" and "to" arguments is allowed' ) ; } $ options [ 'from' ] = self :: dateTimeString ( $ options [ 'from' ] ) ; $ options [ 'to' ] = self :: dateTimeString ( $ options [ 'to' ] ) ; return new GroupIterator ( $ this , $ options ) ; }
5395	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'exception>' ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "exception>\n" ; }
5646	public function createInvoker ( $ invoker ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ invoker = $ this -> reporters [ $ i ] -> createInvoker ( $ invoker ) ; } return $ invoker ; }
8457	protected function injectArguments ( $ command , $ assumeYes ) { $ cmd = $ this -> siteAlias . ' ' . $ command . ( $ assumeYes ? ' -y' : '' ) . $ this -> arguments . $ this -> argumentsForNextCommand ; $ this -> argumentsForNextCommand = '' ; return $ cmd ; }
10216	public function addFromSource ( array $ pSource = null ) { if ( $ pSource == null ) { return ; } foreach ( $ pSource as $ item ) { $ this -> add ( $ item ) ; } }
3580	protected function orderByMeta ( Builder $ query , $ args , $ alias ) { $ query -> with ( 'metaAttributes' ) -> getQuery ( ) -> orderBy ( "{$alias}.meta_value" , $ args -> get ( 'direction' ) ) ; return $ query ; }
11511	protected static function unescapeString ( $ matches ) { static $ map = [ 'n' => "\n" , 'r' => "\r" , 't' => "\t" , 'v' => "\v" , 'f' => "\f" ] ; if ( ! empty ( $ matches [ 2 ] ) ) return chr ( octdec ( $ matches [ 2 ] ) ) ; elseif ( ! empty ( $ matches [ 3 ] ) ) return chr ( hexdec ( $ matches [ 3 ] ) ) ; elseif ( isset ( $ map [ $ matches [ 1 ] ] ) ) return $ map [ $ matches [ 1 ] ] ; return $ matches [ 1 ] ; }
938	public function isGivenKind ( $ possibleKind ) { return $ this -> isArray && ( \ is_array ( $ possibleKind ) ? \ in_array ( $ this -> id , $ possibleKind , true ) : $ this -> id === $ possibleKind ) ; }
7487	public function lastIndexOf ( $ string , $ offset = null ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ offset = $ offset !== null ? ( int ) $ offset : null ; if ( $ offset !== null && ( $ offset < 0 || $ offset >= $ this -> length ( ) ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_strrpos ( $ this -> string , $ string , $ offset , $ this -> encoding ) ; }
10867	public function getList ( ) : IDataSource { $ columns = array_map ( function ( $ item ) { return $ this -> tableName [ 0 ] . '.' . $ item ; } , $ this -> columns ) ; return $ this -> connection -> select ( $ columns ) -> from ( $ this -> tableIdentity ) -> as ( $ this -> tableName [ 0 ] ) ; }
6265	public function resolve ( ResponseInterface $ response ) { if ( HttpPromise :: PENDING !== $ this -> state ) { throw new \ RuntimeException ( 'Promise is already resolved' ) ; } $ this -> state = HttpPromise :: FULFILLED ; $ this -> response = $ response ; $ this -> doResolve ( $ response ) ; }
4519	public function get ( string $ key ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ parameter ) ; return $ parameter -> getValue ( ) ; }
6400	public static function init ( ) : void { self :: $ classMap = new CallbackLazyMap ( function ( $ className ) { $ trimmedClassName = trim ( $ className , '\\' ) ; return $ trimmedClassName === $ className ? new ObjectClass ( $ className ) : ObjectClass :: $ classMap -> $ trimmedClassName ; } ) ; }
2525	public function getConsumerId ( $ generate = false ) { if ( is_null ( $ this -> consumerId ) && $ generate ) { $ this -> consumerId = $ this -> generateGuid ( ) ; } return $ this -> consumerId ; }
3205	protected function get_docblock_tags ( $ comment_opener ) { $ tags = array ( ) ; $ opener = $ this -> tokens [ $ comment_opener ] ; if ( ! isset ( $ opener [ 'comment_tags' ] ) ) { return $ tags ; } $ closer = null ; if ( isset ( $ opener [ 'comment_closer' ] ) ) { $ closer = $ opener [ 'comment_closer' ] ; } $ tag_count = count ( $ opener [ 'comment_tags' ] ) ; for ( $ i = 0 ; $ i < $ tag_count ; $ i ++ ) { $ tag_token = $ opener [ 'comment_tags' ] [ $ i ] ; $ tag = trim ( $ this -> tokens [ $ tag_token ] [ 'content' ] , '@' ) ; $ search_end = $ closer ; if ( ( $ i + 1 ) < $ tag_count ) { $ search_end = $ opener [ 'comment_tags' ] [ ( $ i + 1 ) ] ; } $ value_token = $ this -> phpcsFile -> findNext ( T_DOC_COMMENT_STRING , ( $ tag_token + 1 ) , $ search_end ) ; $ tags [ $ tag ] = trim ( $ this -> tokens [ $ value_token ] [ 'content' ] ) ; unset ( $ tag_token , $ tag , $ search_end , $ value ) ; } return $ tags ; }
6823	protected function getShipmentAccountNumber ( TaxRuleInterface $ rule , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_SHIPPING ) { continue ; } if ( $ account -> getTaxRule ( ) !== $ rule ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No shipment account number configured for tax rule '%s' (%s)" , $ rule -> getName ( ) , $ origin ) ) ; }
1343	public function isIndex ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isNotResource ( ) && $ this -> getRoute ( ) -> isNotProcesses ( ) ; }
8104	public function query ( $ sql , $ arguments = false ) { if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } else { return $ stmt ; } }
10408	public function addDocumentParameter ( $ field , $ value ) { $ this -> documentParamCache [ md5 ( $ value . $ field ) ] = [ $ field , $ value ] ; }
5171	private function getAvailableRatios ( ) : array { return [ self :: RATIO_SQUARE , self :: RATIO_RECTANGLE , self :: RATIO_HEADLINE , self :: RATIO_VERTICAL , self :: RATIO_COVER , ] ; }
3172	protected function updateStats ( & $ target , $ itemInfos ) { if ( ! isset ( $ target [ 'stats' ] ) ) { $ target [ 'stats' ] = [ 'questions' => 0 , 'answered' => 0 , 'flagged' => 0 , 'viewed' => 0 , 'total' => 0 , 'questionsViewed' => 0 , ] ; } if ( empty ( $ itemInfos [ 'informational' ] ) ) { $ target [ 'stats' ] [ 'questions' ] ++ ; if ( ! empty ( $ itemInfos [ 'answered' ] ) ) { $ target [ 'stats' ] [ 'answered' ] ++ ; } if ( ! empty ( $ itemInfos [ 'viewed' ] ) ) { $ target [ 'stats' ] [ 'questionsViewed' ] ++ ; } } if ( ! empty ( $ itemInfos [ 'flagged' ] ) ) { $ target [ 'stats' ] [ 'flagged' ] ++ ; } if ( ! empty ( $ itemInfos [ 'viewed' ] ) ) { $ target [ 'stats' ] [ 'viewed' ] ++ ; } $ target [ 'stats' ] [ 'total' ] ++ ; }
11854	public function getHeader ( string $ name ) : ? string { $ name = strtolower ( $ name ) ; foreach ( $ this -> getAllHeaders ( ) as $ key => $ value ) { if ( strtolower ( $ key ) === $ name ) { return $ value ; } } return null ; }
7922	private function isValidPath ( $ path ) { $ pathParts = explode ( '/' , $ path ) ; if ( ! strncmp ( $ path , '/' , 1 ) || array_search ( '..' , $ pathParts ) !== false || strpos ( $ path , ':' ) !== false ) { return false ; } return true ; }
6141	public function checkPass ( $ password = null ) { if ( $ password === null ) { $ password = $ this -> pass ; } if ( strlen ( $ password ) == 0 ) { return true ; } $ pattern = "/^(" . $ this -> regex [ "alphanum" ] . "|" . $ this -> regex [ "mark" ] . "|" . $ this -> regex [ "escaped" ] . "|[;:&=+$,])+$/" ; $ status = @ preg_match ( $ pattern , $ password ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI password validation failed" ) ; } return ( $ status == 1 ) ; }
5397	public function paintMessage ( $ message ) { parent :: paintMessage ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'message>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "message>\n" ; }
8334	public function addScope ( $ scope ) { if ( $ this -> isValidScope ( $ scope ) ) { $ this -> scope [ $ scope ] = $ scope ; } return $ this ; }
10198	private function writeRows ( XMLWriter $ objWriter , Worksheet $ sheet ) { $ numberRowsRepeated = self :: NUMBER_ROWS_REPEATED_MAX ; $ span_row = 0 ; $ rows = $ sheet -> getRowIterator ( ) ; while ( $ rows -> valid ( ) ) { -- $ numberRowsRepeated ; $ row = $ rows -> current ( ) ; if ( $ row -> getCellIterator ( ) -> valid ( ) ) { if ( $ span_row ) { $ objWriter -> startElement ( 'table:table-row' ) ; if ( $ span_row > 1 ) { $ objWriter -> writeAttribute ( 'table:number-rows-repeated' , $ span_row ) ; } $ objWriter -> startElement ( 'table:table-cell' ) ; $ objWriter -> writeAttribute ( 'table:number-columns-repeated' , self :: NUMBER_COLS_REPEATED_MAX ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ span_row = 0 ; } $ objWriter -> startElement ( 'table:table-row' ) ; $ this -> writeCells ( $ objWriter , $ row ) ; $ objWriter -> endElement ( ) ; } else { ++ $ span_row ; } $ rows -> next ( ) ; } }
12796	public function clear ( $ queue ) { $ this -> client -> request -> post ( $ this -> apiEndpoint . '/projects/' . $ this -> params [ 'project' ] . '/queues/' . $ queue . '/clear' ) ; }
205	public static function wrapText ( $ text , $ indent = 0 , $ refresh = false ) { $ size = static :: getScreenSize ( $ refresh ) ; if ( $ size === false || $ size [ 0 ] <= $ indent ) { return $ text ; } $ pad = str_repeat ( ' ' , $ indent ) ; $ lines = explode ( "\n" , wordwrap ( $ text , $ size [ 0 ] - $ indent , "\n" , true ) ) ; $ first = true ; foreach ( $ lines as $ i => $ line ) { if ( $ first ) { $ first = false ; continue ; } $ lines [ $ i ] = $ pad . $ line ; } return implode ( "\n" , $ lines ) ; }
5703	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; return $ this ; }
1256	public static function search ( $ expression , $ data ) { static $ runtime ; if ( ! $ runtime ) { $ runtime = Env :: createRuntime ( ) ; } return $ runtime ( $ expression , $ data ) ; }
10936	protected function authenticateUser ( CustomerInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
4869	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ helper = new DateFormat ( ) ; $ helper -> setLocale ( Locale :: DEFAULT_LOCALE ) ; return $ helper ; }
2132	public function add ( $ strKey , $ varValue ) { $ this -> markModified ( ) ; $ this -> arrData [ $ strKey ] = $ this -> escape ( $ varValue ) . ';' ; }
12050	public function initClient ( $ headers ) { try { $ this -> request = new Client ( $ headers ) ; } catch ( Exception $ e ) { echo 'Unable to initialise http client because ' . $ e -> getMessage ( ) . "\n" ; } }
2372	public static function toXhtml ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*)>/i' => '<$1$2 />' , '/ border="[^"]*"/' => '' ) ; $ arrStrReplace = array ( '/ />' => ' />' , '<b>' => '<strong>' , '</b>' => '</strong>' , '<i>' => '<em>' , '</i>' => '</em>' , '<u>' => '<span style="text-decoration:underline">' , '</u>' => '</span>' , ' target="_self"' => '' , ' target="_blank"' => ' onclick="return !window.open(this.href)"' ) ; $ strString = preg_replace ( array_keys ( $ arrPregReplace ) , $ arrPregReplace , $ strString ) ; $ strString = str_ireplace ( array_keys ( $ arrStrReplace ) , $ arrStrReplace , $ strString ) ; return $ strString ; }
12110	public function deletePage ( $ id ) { $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
3872	protected function getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage = null ) { $ entries = array ( ) ; $ items = $ metaModels -> findByFilter ( $ filter ) ; foreach ( $ items as $ item ) { $ jumpTo = $ item -> buildJumpToLink ( $ view ) ; $ event = new GetPageDetailsEvent ( $ jumpTo [ 'page' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null || ( $ rootPage !== null && $ pageDetails [ 'rootId' ] != $ rootPage ) ) { continue ; } $ url = $ this -> getBaseUrl ( $ pageDetails , $ jumpTo [ 'url' ] ) ; $ entries [ ] = $ url -> getUrl ( ) ; } return $ entries ; }
6090	public function addMediaToMoodboard ( $ moodboardId , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards/' . $ moodboardId . '/media' , $ parameters ) ; return $ result ; }
7891	protected function triggerDeploy ( $ project ) { if ( ! $ project ) { throw new InvalidArgumentException ( 'Incorrect project hook.' ) ; } file_get_contents ( sprintf ( self :: DEPLOY_URL , $ project ) ) ; $ this -> info ( 'Deployment request successful!' ) ; }
6724	protected function validateTokenParams ( ) { if ( empty ( $ this -> tokenUrl ) || filter_var ( $ this -> tokenUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_TOKEN_URL , $ this -> tokenUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
6339	private function getDocumentStream ( $ xmlDocument ) { foreach ( $ this -> streamAdapters as $ streamAdapter ) { if ( $ streamAdapter -> supports ( $ xmlDocument ) ) { return $ streamAdapter -> convert ( $ xmlDocument ) ; } } throw new RuntimeException ( sprintf ( 'Suitable XML document stream adapter is not registered for XML document of type "%s".' , is_object ( $ xmlDocument ) ? get_class ( $ xmlDocument ) : gettype ( $ xmlDocument ) ) ) ; }
3609	public function getUserLocations ( ) { $ this -> prepareForGet ( ) ; $ structures = ( array ) $ this -> last_status -> structure ; $ user_structures = array ( ) ; $ class_name = get_class ( $ this ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ structures as $ struct_id => $ structure ) { $ protects = array ( ) ; foreach ( $ topaz as $ protect ) { if ( $ protect -> structure_id == $ struct_id ) { $ protects [ ] = $ protect -> serial_number ; } } $ weather_data = $ this -> getWeather ( $ structure -> postal_code , $ structure -> country_code ) ; $ user_structures [ ] = ( object ) array ( 'name' => isset ( $ structure -> name ) ? $ structure -> name : '' , 'address' => ! empty ( $ structure -> street_address ) ? $ structure -> street_address : NULL , 'city' => $ structure -> location , 'postal_code' => $ structure -> postal_code , 'country' => $ structure -> country_code , 'outside_temperature' => $ weather_data -> outside_temperature , 'outside_humidity' => $ weather_data -> outside_humidity , 'away' => $ structure -> away , 'away_last_changed' => date ( DATETIME_FORMAT , $ structure -> away_timestamp ) , 'thermostats' => array_map ( array ( $ class_name , 'cleanDevices' ) , $ structure -> devices ) , 'protects' => $ protects , ) ; } return $ user_structures ; }
4886	public function plugin ( $ plugin , $ options = null ) { $ renderer = $ this -> getView ( ) ; if ( ! method_exists ( $ renderer , 'getHelperPluginManager' ) ) { return true === $ options ? false : new HelperProxy ( false ) ; } $ manager = $ renderer -> getHelperPluginManager ( ) ; $ hasPlugin = $ manager -> has ( $ plugin ) ; if ( true === $ options ) { return $ hasPlugin ; } if ( $ hasPlugin ) { $ pluginInstance = $ manager -> get ( $ plugin , $ options ) ; } else { $ pluginInstance = false ; } return new HelperProxy ( $ pluginInstance ) ; }
7456	private function ensureDirectoryExists ( $ path ) { if ( ! is_dir ( $ path ) ) { if ( ! mkdir ( $ path , 0777 , true ) ) { throw new \ RuntimeException ( sprintf ( 'Could not create directory "%s"' , $ path ) ) ; } } return $ path ; }
1634	public function boot ( ) { $ this -> app [ 'auth' ] -> viaRequest ( 'api' , function ( $ request ) { if ( $ request -> input ( 'api_token' ) ) { return User :: where ( 'api_token' , $ request -> input ( 'api_token' ) ) -> first ( ) ; } } ) ; }
10232	private function writeLine ( $ pFileHandle , array $ pValues ) { $ writeDelimiter = false ; $ line = '' ; foreach ( $ pValues as $ element ) { $ element = str_replace ( $ this -> enclosure , $ this -> enclosure . $ this -> enclosure , $ element ) ; if ( $ writeDelimiter ) { $ line .= $ this -> delimiter ; } else { $ writeDelimiter = true ; } $ line .= $ this -> enclosure . $ element . $ this -> enclosure ; } $ line .= $ this -> lineEnding ; fwrite ( $ pFileHandle , $ line ) ; }
7993	public function getDiskUsage ( $ diskId , $ type ) { return json_decode ( self :: getClient ( ) -> getDiskUsage ( $ this -> getDomain ( ) , $ diskId , $ type ) ) ; }
2021	public static function findPublishedByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
4235	private static function trimDesc ( $ desc ) { $ lines = \ explode ( "\n" , $ desc ) ; $ leadingSpaces = array ( ) ; foreach ( $ lines as $ line ) { if ( \ strlen ( $ line ) ) { $ leadingSpaces [ ] = \ strspn ( $ line , ' ' ) ; } } \ array_shift ( $ leadingSpaces ) ; $ trimLen = $ leadingSpaces ? \ min ( $ leadingSpaces ) : 0 ; if ( ! $ trimLen ) { return $ desc ; } foreach ( $ lines as $ i => $ line ) { $ lines [ $ i ] = $ i > 0 && \ strlen ( $ line ) ? \ substr ( $ line , $ trimLen ) : $ line ; } $ desc = \ implode ( "\n" , $ lines ) ; return $ desc ; }
11480	private function getJsonBody ( RequestInterface $ request , ResponseInterface $ response ) : array { $ data = json_decode ( $ response -> getBody ( ) , true ) ; if ( ! $ data || ! is_array ( $ data ) || ! array_key_exists ( "data" , $ data ) ) { throw new ClientException ( "Response body does not contain a valid JSON object." , $ request , $ response ) ; } if ( ! is_array ( $ data ) || ! is_array ( $ data [ "data" ] ) ) { throw new ClientException ( "Not sure what happened. The list jobs endpoint didn't return a list. :worried:" , $ request , $ response ) ; } return $ data [ "data" ] ; }
9686	public function implode ( $ value , $ glue = null ) { $ new_collection = new Collection ( $ this -> toArray ( ) ) ; $ first = $ new_collection -> first ( ) ; if ( is_array ( $ first ) || is_object ( $ first ) ) { return implode ( $ glue , $ new_collection -> pluck ( $ value ) -> all ( ) ) ; } return implode ( $ value , $ new_collection -> all ( ) ) ; }
9587	protected function getAttribute ( SimpleXmlElement $ node , $ name ) { $ attributes = $ node -> attributes ( ) ; return ( string ) $ attributes [ $ name ] ; }
4263	public function unsubscribe ( $ eventName , $ callable ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return ; } if ( $ this -> isClosureFactory ( $ callable ) ) { $ callable [ 0 ] = $ callable [ 0 ] ( ) ; } foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ v ) { if ( $ v !== $ callable && $ this -> isClosureFactory ( $ v ) ) { $ v [ 0 ] = $ v [ 0 ] ( ) ; } if ( $ v === $ callable ) { unset ( $ subscribers [ $ k ] , $ this -> sorted [ $ eventName ] ) ; } else { $ subscribers [ $ k ] = $ v ; } } if ( $ subscribers ) { $ this -> subscribers [ $ eventName ] [ $ priority ] = $ subscribers ; } else { unset ( $ this -> subscribers [ $ eventName ] [ $ priority ] ) ; } } }
306	public function getSizeLimit ( ) { $ limit = $ this -> sizeToBytes ( ini_get ( 'upload_max_filesize' ) ) ; $ postLimit = $ this -> sizeToBytes ( ini_get ( 'post_max_size' ) ) ; if ( $ postLimit > 0 && $ postLimit < $ limit ) { Yii :: warning ( 'PHP.ini\'s \'post_max_size\' is less than \'upload_max_filesize\'.' , __METHOD__ ) ; $ limit = $ postLimit ; } if ( $ this -> maxSize !== null && $ limit > 0 && $ this -> maxSize < $ limit ) { $ limit = $ this -> maxSize ; } if ( isset ( $ _POST [ 'MAX_FILE_SIZE' ] ) && $ _POST [ 'MAX_FILE_SIZE' ] > 0 && $ _POST [ 'MAX_FILE_SIZE' ] < $ limit ) { $ limit = ( int ) $ _POST [ 'MAX_FILE_SIZE' ] ; } return $ limit ; }
6334	private function attachHandlers ( $ parser ) { $ onElementStart = \ Closure :: bind ( function ( $ parser , $ name , $ attributes ) { $ name = $ this -> normalize ( $ name ) ; $ this -> currentElement = $ name ; $ this -> dataBuffer = null ; $ this -> stackSize ++ ; $ this -> onElementStart ( $ parser , $ name , $ attributes ) ; } , $ this ) ; $ onElementEnd = \ Closure :: bind ( function ( $ parser , $ name ) { $ name = $ this -> normalize ( $ name ) ; $ this -> currentElement = null ; $ this -> stackSize -- ; if ( null !== $ this -> dataBuffer ) { $ this -> onElementData ( $ parser , $ this -> dataBuffer ) ; } $ this -> dataBuffer = null ; $ this -> onElementEnd ( $ parser , $ name ) ; } , $ this ) ; $ onElementData = \ Closure :: bind ( function ( $ parser , $ data ) { $ this -> dataBuffer .= $ data ; } , $ this ) ; $ onNamespaceDeclarationStart = \ Closure :: bind ( function ( $ parser , $ prefix , $ uri ) { $ this -> namespaces [ $ prefix ] = rtrim ( $ uri , '/' ) ; $ this -> onNamespaceDeclarationStart ( $ parser , $ prefix , $ uri ) ; } , $ this ) ; $ onNamespaceDeclarationEnd = \ Closure :: bind ( function ( $ parser , $ prefix ) { $ this -> onNamespaceDeclarationEnd ( $ parser , $ prefix ) ; } , $ this ) ; xml_set_element_handler ( $ parser , $ onElementStart , $ onElementEnd ) ; xml_set_character_data_handler ( $ parser , $ onElementData ) ; xml_set_start_namespace_decl_handler ( $ parser , $ onNamespaceDeclarationStart ) ; xml_set_end_namespace_decl_handler ( $ parser , $ onNamespaceDeclarationEnd ) ; return $ this ; }
7284	public function status ( $ status = NULL ) { if ( $ status === NULL ) { return $ this -> status ; } elseif ( array_key_exists ( $ status , Response :: $ messages ) ) { $ this -> status = ( int ) $ status ; $ this -> status_message = Response :: $ messages [ $ this -> status ] ; return $ this ; } else { throw new Exception ( __METHOD__ . ' unknown status value : :value' , array ( ':value' => $ status ) ) ; } }
9120	public function registerRouter ( AbstractRouter $ router ) { $ this -> router = $ router ; $ this -> router -> setApplication ( $ this ) ; return $ this ; }
8742	protected function setKeysForSaveQuery ( EloquentBuilder $ query ) { $ query -> where ( $ this -> getKeyName ( ) , '=' , $ this -> getKeyForSaveQuery ( ) ) ; $ query -> where ( $ this -> localeKey , '=' , $ this -> { $ this -> localeKey } ) ; return $ query ; }
9819	public function setSegmentSize ( $ size ) { if ( null !== $ this -> memory ) { throw new Exception \ RuntimeException ( 'You can not change the segment size because memory is already allocated.' . ' Use realloc() function to create new memory segment.' ) ; } $ this -> segmentSize = ( integer ) $ size ; return $ this ; }
7535	function delete ( ) { if ( ( $ p = $ this -> parent ) !== null ) { $ this -> parent = null ; $ p -> deleteChild ( $ this ) ; } else { $ this -> clear ( ) ; } }
9293	protected function getAssetsUrl ( ) { if ( ! isset ( $ this -> _assetsUrl ) ) { $ path = dirname ( __FILE__ ) . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'assets' ; $ this -> _assetsUrl = Yii :: app ( ) -> assetManager -> publish ( $ path , false , - 1 , $ this -> forceCopyAssets ) ; } return $ this -> _assetsUrl ; }
527	public function registerAssetFiles ( $ view ) { $ manager = $ view -> getAssetManager ( ) ; foreach ( $ this -> js as $ js ) { if ( is_array ( $ js ) ) { $ file = array_shift ( $ js ) ; $ options = ArrayHelper :: merge ( $ this -> jsOptions , $ js ) ; $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ js !== null ) { $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ js ) , $ this -> jsOptions ) ; } } } foreach ( $ this -> css as $ css ) { if ( is_array ( $ css ) ) { $ file = array_shift ( $ css ) ; $ options = ArrayHelper :: merge ( $ this -> cssOptions , $ css ) ; $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ css !== null ) { $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ css ) , $ this -> cssOptions ) ; } } } }
2531	private function getStatefulStatusCode ( $ messageName , array $ messageOptions ) { if ( 'Security_Authenticate' === $ messageName ) { return self :: TRANSACTION_STATUS_CODE_START ; } if ( isset ( $ messageOptions [ 'endSession' ] ) && $ messageOptions [ 'endSession' ] === true ) { return self :: TRANSACTION_STATUS_CODE_END ; } return self :: TRANSACTION_STATUS_CODE_INSERIES ; }
1405	protected function findRelated ( $ record , array $ relationship ) { $ inverse = $ this -> getRelation ( $ record , $ this -> key ) -> getRelated ( ) ; $ related = $ this -> findToMany ( $ relationship ) ; $ related = collect ( $ related ) -> filter ( function ( $ model ) use ( $ inverse ) { return $ model instanceof $ inverse ; } ) ; return new Collection ( $ related ) ; }
702	protected function findDirs ( $ dir ) { $ list = [ ] ; $ handle = @ opendir ( $ dir ) ; if ( $ handle === false ) { return [ ] ; } while ( ( $ file = readdir ( $ handle ) ) !== false ) { if ( $ file === '.' || $ file === '..' ) { continue ; } $ path = $ dir . DIRECTORY_SEPARATOR . $ file ; if ( is_dir ( $ path ) && preg_match ( '/^yii2-(.*)$/' , $ file , $ matches ) ) { $ list [ ] = $ matches [ 1 ] ; } } closedir ( $ handle ) ; foreach ( $ list as $ i => $ e ) { if ( $ e === 'composer' ) { unset ( $ list [ $ i ] ) ; } } return $ list ; }
5477	public function addWidget ( $ tag ) { if ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'submit' ) { $ this -> buttons [ ] = $ tag ; } elseif ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'image' ) { $ this -> images [ ] = $ tag ; } elseif ( $ tag -> getName ( ) ) { $ this -> setWidget ( $ tag ) ; } }
7397	public function header ( string $ name , string $ value ) : bool { if ( ! empty ( $ name ) && ! empty ( $ value ) && ! headers_sent ( ) ) { header ( $ name . ': ' . $ value ) ; return true ; } return false ; }
6523	public function isCompatibleForOverride ( Field $ other ) { if ( ! $ this -> overridable ) { return false ; } if ( $ this -> name !== $ other -> name ) { return false ; } if ( $ this -> type !== $ other -> type ) { return false ; } if ( $ this -> rule !== $ other -> rule ) { return false ; } if ( $ this -> required !== $ other -> required ) { return false ; } return true ; }
8686	public static function remove ( & $ data , $ path , $ default = null ) { if ( ! static :: $ unsetMarker ) { static :: $ unsetMarker = new \ stdClass ( ) ; } $ value = static :: get ( $ data , $ path , static :: $ unsetMarker ) ; if ( $ value === static :: $ unsetMarker ) { return $ default ; } static :: set ( $ data , $ path , static :: $ unsetMarker ) ; return $ value ; }
2345	public function truncate ( ) { if ( \ is_resource ( $ this -> resFile ) ) { ftruncate ( $ this -> resFile , 0 ) ; rewind ( $ this -> resFile ) ; } return $ this -> write ( '' ) ; }
8277	public function onConfigLoaded ( array & $ config ) { $ config [ self :: PLUGIN_NAME ] = $ this -> loadDefaultConfig ( $ config ) ; $ this -> config = $ config [ self :: PLUGIN_NAME ] ; $ this -> createContainer ( ) ; $ this -> initLogger ( ) ; }
8132	public function getSourceContext ( ) { return $ this -> filename ? new Twig_Source ( $ this -> sourceCode , $ this -> filename , $ this -> sourcePath ) : null ; }
54	public function getDownloader ( $ type ) { $ type = strtolower ( $ type ) ; if ( ! isset ( $ this -> downloaders [ $ type ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Unknown downloader type: %s. Available types: %s.' , $ type , implode ( ', ' , array_keys ( $ this -> downloaders ) ) ) ) ; } return $ this -> downloaders [ $ type ] ; }
10765	public function generateImage ( $ filename = false , $ level = Constants :: QR_ECLEVEL_L , $ size = 3 , $ margin = 4 ) { $ result = 'SPD' . self :: DELIMITER . $ this -> version . self :: DELIMITER . $ this -> implodeContent ( ) ; if ( $ this -> appendCRC32 ) { $ result .= self :: DELIMITER . 'CRC32:' . sprintf ( '%x' , crc32 ( $ result ) ) ; } QRcode :: png ( $ result , $ filename , $ level , $ size , $ margin ) ; die ( ) ; }
11397	public static function parseFault ( \ SimpleXMLElement $ fault ) { $ faultData = static :: parseStruct ( $ fault -> value -> struct ) ; return new \ Devedge \ XmlRpc \ Client \ RemoteException ( $ faultData [ 'faultString' ] , $ faultData [ 'faultCode' ] ) ; }
8681	public function set ( $ key , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; $ this -> items [ $ key ] = $ value ; }
2286	protected static function agent ( ) { $ ua = static :: get ( 'httpUserAgent' ) ; $ return = new \ stdClass ( ) ; $ return -> string = $ ua ; $ os = 'unknown' ; $ mobile = false ; $ browser = 'other' ; $ shorty = '' ; $ version = '' ; $ engine = '' ; foreach ( Config :: get ( 'os' ) as $ k => $ v ) { if ( stripos ( $ ua , $ k ) !== false ) { $ os = $ v [ 'os' ] ; $ mobile = $ v [ 'mobile' ] ; break ; } } $ return -> os = $ os ; foreach ( Config :: get ( 'browser' ) as $ k => $ v ) { if ( stripos ( $ ua , $ k ) !== false ) { $ browser = $ v [ 'browser' ] ; $ shorty = $ v [ 'shorty' ] ; $ version = preg_replace ( $ v [ 'version' ] , '$1' , $ ua ) ; $ engine = $ v [ 'engine' ] ; break ; } } $ versions = explode ( '.' , $ version ) ; $ version = $ versions [ 0 ] ; $ return -> class = $ os . ' ' . $ browser . ' ' . $ engine ; if ( $ version != '' ) { $ return -> class .= ' ' . $ shorty . $ version ; } if ( $ os == 'android' && $ engine != 'presto' && stripos ( $ ua , 'mobile' ) === false ) { $ mobile = false ; } if ( $ mobile ) { $ return -> class .= ' mobile' ; } $ return -> browser = $ browser ; $ return -> shorty = $ shorty ; $ return -> version = $ version ; $ return -> engine = $ engine ; $ return -> versions = $ versions ; $ return -> mobile = $ mobile ; return $ return ; }
1527	protected function doReplaceRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ name = Str :: classify ( $ field = $ request -> getRelationshipName ( ) ) ; if ( $ result = $ this -> invokeMany ( [ 'replacing' , "replacing{$name}" ] , $ record , $ request ) ) { return $ result ; } $ record = $ store -> replaceRelationship ( $ record , $ field , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> invokeMany ( [ "replaced{$name}" , "replaced" ] , $ record , $ request ) ? : $ record ; }
6584	public function sum ( $ n , $ m = 0 ) { if ( $ m > 0 ) return $ this -> sum ( $ n + $ m ) - $ this -> sum ( $ m ) ; static :: ensureValid ( $ n ) ; return $ this -> b * ( 1 - pow ( $ this -> q , $ n ) ) / ( 1 - $ this -> q ) ; }
10488	public function run ( \ de \ codenamephp \ platform \ cli \ command \ iCommand $ command ) { if ( $ this -> getDirectory ( ) !== '' && is_dir ( $ this -> getDirectory ( ) ) ) { $ currentDir = getcwd ( ) ; chdir ( $ this -> getDirectory ( ) ) ; } $ returnValue = $ this -> getActualPassthru ( ) -> run ( $ command ) ; if ( isset ( $ currentDir ) ) { chdir ( $ currentDir ) ; } return $ returnValue ; }
1508	public static function fromArray ( array $ url ) : self { return new self ( isset ( $ url [ 'host' ] ) ? $ url [ 'host' ] : '' , isset ( $ url [ 'namespace' ] ) ? $ url [ 'namespace' ] : '' , isset ( $ url [ 'name' ] ) ? $ url [ 'name' ] : '' ) ; }
3475	public function getGateway ( ) { $ gateway = $ this -> gateway ; try { $ response = $ this -> guzzle -> get ( 'https://discordapp.com/api/gateway' , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , ] ) ; $ gateway = Arr :: get ( json_decode ( $ response -> getBody ( ) , true ) , 'url' , $ gateway ) ; } catch ( Exception $ e ) { $ this -> warn ( "Could not get a websocket gateway address, defaulting to '{$gateway}'." ) ; } return $ gateway ; }
4628	protected function prepareRequestUrl ( ) { $ protocol = $ this -> node -> useTls ( ) ? 'https' : 'http' ; $ this -> requestURL = sprintf ( '%s://%s%s?%s' , $ protocol , $ this -> node -> getUri ( ) , $ this -> path , $ this -> query ) ; $ this -> options [ CURLOPT_URL ] = $ this -> requestURL ; return $ this ; }
11759	public function deleteReply ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_REPLY , $ params ] ) ; }
12475	public function getCurrentTheme ( ) { $ theme = $ this -> getDefaultTheme ( ) ; if ( $ this -> container -> get ( 'session' ) -> has ( '_admin_theme' ) ) { $ theme = $ this -> container -> get ( 'session' ) -> get ( '_admin_theme' ) ; } return $ theme ; }
1996	protected function adjustPublicationDate ( ) { if ( ! empty ( $ this -> arrItems ) && $ this -> arrItems [ 0 ] -> published > $ this -> published ) { $ this -> published = $ this -> arrItems [ 0 ] -> published ; } }
7997	public static function getSpecificationString ( $ reversed = false ) { $ reflection = new ReflectionClass ( get_class ( ) ) ; $ constants = $ reflection -> getConstants ( ) ; if ( $ reversed ) { $ constants = array_reverse ( $ constants ) ; } $ string = '' ; foreach ( $ constants as $ name => $ int_val ) { $ binary_val_string = base_convert ( ( string ) $ int_val , '10' , '2' ) ; $ string .= sprintf ( '0b%s : %s' , str_pad ( $ binary_val_string , 32 , '0' , STR_PAD_LEFT ) , $ name ) ; $ string .= PHP_EOL ; } return $ string ; }
11101	public static function countryCodeTwoToThree ( $ code ) { $ codes = array_flip ( self :: $ _countryCodes ) ; if ( ! array_key_exists ( $ code , $ codes ) ) { return false ; } return $ codes [ $ code ] ; }
5777	public function null_eq ( string $ name , $ arg ) { if ( $ arg === null ) { $ this -> sql .= "$name is null" ; } else { $ this -> args [ ] = $ arg ; $ argNum = count ( $ this -> args ) ; $ this -> sql .= "$name = \$$argNum" ; } return $ this ; }
11334	public function getFormattedValue ( ) { if ( $ this -> format instanceof BaseFormat ) { $ formattedValue = $ this -> format -> get ( ) ; } elseif ( is_callable ( $ this -> format ) || ( is_array ( $ this -> format ) && ! empty ( $ this -> format [ 0 ] ) && is_object ( $ this -> format [ 0 ] ) ) ) { $ formattedValue = $ this -> evaluateExpression ( $ this -> format , [ $ this -> value ] ) ; } else { $ formattedValue = $ this -> value ; } if ( is_object ( $ formattedValue ) ) { $ formattedValue = $ formattedValue -> viewLink ; } return $ formattedValue ; }
7698	function MsPowerpoint_SlideIsIt ( $ FileName ) { $ this -> MsPowerpoint_InitSlideLst ( ) ; foreach ( $ this -> OpenXmlSlideLst as $ i => $ s ) { if ( $ FileName == $ s [ 'file' ] ) return true ; } return false ; }
8801	public function set ( $ key , $ value ) { if ( is_array ( $ key ) ) { foreach ( $ key as $ k => $ v ) { $ _SESSION [ $ k ] = $ v ; } } else { $ _SESSION [ $ key ] = $ value ; } return ; }
7715	static function FindStartTagByPrefix ( & $ Txt , $ TagPrefix , $ PosBeg , $ Forward = true ) { $ x = '<' . $ TagPrefix ; $ xl = strlen ( $ x ) ; if ( $ Forward ) { $ PosBeg = strpos ( $ Txt , $ x , $ PosBeg ) ; } else { $ PosBeg = strrpos ( substr ( $ Txt , 0 , $ PosBeg + 2 ) , $ x ) ; } if ( $ PosBeg === false ) return false ; $ Tag = $ TagPrefix ; $ p = $ PosBeg + $ xl ; do { $ z = substr ( $ Txt , $ p , 1 ) ; if ( ( $ z !== ' ' ) && ( $ z !== "\r" ) && ( $ z !== "\n" ) && ( $ z !== '>' ) && ( $ z !== '/' ) ) { $ Tag .= $ z ; $ p ++ ; } else { $ p = false ; } } while ( $ p !== false ) ; return new clsTbsXmlLoc ( $ Txt , $ Tag , $ PosBeg ) ; }
8697	protected function validateMandatoryAttribs ( ) { foreach ( static :: $ mandatoryFields as $ field ) { if ( ! array_key_exists ( $ field , $ this -> attributes ) ) { throw new \ SVGCreator \ SVGException ( "The field " . $ field . " does not exist for " . static :: TYPE . "." , 1 ) ; } } }
149	public function isActive ( $ scenario ) { return ! in_array ( $ scenario , $ this -> except , true ) && ( empty ( $ this -> on ) || in_array ( $ scenario , $ this -> on , true ) ) ; }
3344	public function __batchProcessFiles ( $ filesUuidArr , $ request_type ) { $ filesChunkedArr = array_chunk ( $ filesUuidArr , $ this -> batchFilesChunkSize ) ; $ filesArr = array ( ) ; $ problemsArr = array ( ) ; $ lastStatus = '' ; foreach ( $ filesChunkedArr as $ chunk ) { $ res = $ this -> __batchProcessFilesChunk ( $ chunk , $ request_type ) ; $ lastStatus = $ res [ 'status' ] ; if ( $ lastStatus == "ok" ) { $ problemsObj = $ res [ 'problems' ] ; if ( count ( get_object_vars ( $ problemsObj ) ) > 0 ) { $ problemsArr [ ] = $ problemsObj ; } $ filesArr = array_merge ( $ filesArr , $ res [ 'files' ] ) ; } else { throw new \ Exception ( 'Error process multiple files' , $ res ) ; } } return array ( 'status' => $ lastStatus , 'files' => $ filesArr , 'problems' => $ problemsArr , ) ; }
10240	public function calculateCellValue ( Cell $ pCell = null , $ resetLog = true ) { if ( $ pCell === null ) { return null ; } $ returnArrayAsType = self :: $ returnArrayAsType ; if ( $ resetLog ) { $ this -> formulaError = null ; $ this -> debugLog -> clearLog ( ) ; $ this -> cyclicReferenceStack -> clear ( ) ; $ this -> cyclicFormulaCounter = 1 ; self :: $ returnArrayAsType = self :: RETURN_ARRAY_AS_ARRAY ; } $ this -> cellStack [ ] = [ 'sheet' => $ pCell -> getWorksheet ( ) -> getTitle ( ) , 'cell' => $ pCell -> getCoordinate ( ) , ] ; try { $ result = self :: unwrapResult ( $ this -> _calculateFormulaValue ( $ pCell -> getValue ( ) , $ pCell -> getCoordinate ( ) , $ pCell ) ) ; $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; } catch ( \ Exception $ e ) { $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; throw new Exception ( $ e -> getMessage ( ) ) ; } if ( ( is_array ( $ result ) ) && ( self :: $ returnArrayAsType != self :: RETURN_ARRAY_AS_ARRAY ) ) { self :: $ returnArrayAsType = $ returnArrayAsType ; $ testResult = Functions :: flattenArray ( $ result ) ; if ( self :: $ returnArrayAsType == self :: RETURN_ARRAY_AS_ERROR ) { return Functions :: VALUE ( ) ; } if ( count ( $ testResult ) != 1 ) { $ r = array_keys ( $ result ) ; $ r = array_shift ( $ r ) ; if ( ! is_numeric ( $ r ) ) { return Functions :: VALUE ( ) ; } if ( is_array ( $ result [ $ r ] ) ) { $ c = array_keys ( $ result [ $ r ] ) ; $ c = array_shift ( $ c ) ; if ( ! is_numeric ( $ c ) ) { return Functions :: VALUE ( ) ; } } } $ result = array_shift ( $ testResult ) ; } self :: $ returnArrayAsType = $ returnArrayAsType ; if ( $ result === null ) { return 0 ; } elseif ( ( is_float ( $ result ) ) && ( ( is_nan ( $ result ) ) || ( is_infinite ( $ result ) ) ) ) { return Functions :: NAN ( ) ; } return $ result ; }
11145	protected function scanDir ( $ dir ) { $ result = array ( ) ; $ list = $ this -> scanDirExec ( $ dir ) ; foreach ( $ list as $ element ) { $ elementPath = $ dir . DIRECTORY_SEPARATOR . $ element ; if ( is_file ( $ elementPath ) ) { $ fileInfo = pathinfo ( $ element ) ; if ( in_array ( $ fileInfo [ 'extension' ] , $ this -> getAllowedFileExtensions ( ) ) ) { $ result [ ] = $ this -> getNameSpace ( ) . "\\" . $ fileInfo [ 'filename' ] ; } } } return $ result ; }
936	public static function getNameForId ( $ id ) { if ( CT :: has ( $ id ) ) { return CT :: getName ( $ id ) ; } $ name = token_name ( $ id ) ; return 'UNKNOWN' === $ name ? null : $ name ; }
9157	final public function call ( $ action , Request $ request , View $ view ) { $ this -> request = $ request ; ob_start ( ) ; $ rf = new \ ReflectionMethod ( $ this , $ action ) ; $ anno = $ rf -> getDocComment ( ) ; $ matches = array ( ) ; if ( preg_match ( '#@responseType ([\w\/]+)#' , $ anno , $ matches ) ) { $ this -> response -> setType ( $ matches [ 1 ] ) ; } if ( preg_match ( '#@title ([^\\n]+)#' , $ anno , $ matches ) ) { $ this -> response -> setTitle ( $ matches [ 1 ] ) ; } $ rf -> invoke ( $ this , $ this -> request ) ; $ this -> response -> appendBody ( ob_get_clean ( ) ) ; $ view -> render ( $ this -> response , $ request , $ this -> viewParams ) ; $ this -> addControls ( $ this -> response , $ request , $ view ) ; return $ this -> response ; }
463	public function buildAndCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
5237	private function injectionValuesForMethod ( \ ReflectionMethod $ method ) { $ paramValues = [ ] ; $ defaultName = $ this -> methodBindingName ( $ method ) ; foreach ( $ method -> getParameters ( ) as $ param ) { $ type = $ this -> paramType ( $ method , $ param ) ; $ name = $ this -> detectBindingName ( $ param , $ defaultName ) ; $ hasExplicitBinding = $ this -> injector -> hasExplicitBinding ( $ type , $ name ) ; if ( ! $ hasExplicitBinding && $ param -> isDefaultValueAvailable ( ) ) { $ paramValues [ ] = $ param -> getDefaultValue ( ) ; continue ; } if ( ! $ this -> injector -> hasBinding ( $ type , $ name ) ) { $ typeMsg = $ this -> createTypeMessage ( $ type , $ name ) ; throw new BindingException ( 'Can not inject into ' . $ this -> class -> getName ( ) . '::' . $ method -> getName ( ) . '(' . $ this -> createParamString ( $ param , $ type ) . '). No binding for type ' . $ typeMsg . ' specified. Injection stack: ' . "\n" . join ( "\n" , $ this -> injector -> stack ( ) ) ) ; } $ paramValues [ ] = $ this -> injector -> getInstance ( $ type , $ name ) ; } return $ paramValues ; }
10345	protected function applyStepping ( $ range , $ step ) { if ( $ step === false || $ step === 1 ) { return $ range ; } foreach ( $ range as $ value => $ tmp ) { if ( ( $ value % $ step ) !== 0 ) { unset ( $ range [ $ value ] ) ; } } return array_values ( $ range ) ; }
3960	public function parseAttribute ( $ strAttributeName , $ strOutputFormat = 'text' , $ objSettings = null ) { return $ this -> internalParseAttribute ( $ this -> getAttribute ( $ strAttributeName ) , $ strOutputFormat , $ objSettings ) ; }
10296	public function writeChart ( \ PhpOffice \ PhpSpreadsheet \ Chart \ Chart $ pChart , $ calculateCellValues = true ) { $ this -> calculateCellValues = $ calculateCellValues ; $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } if ( $ this -> calculateCellValues ) { $ pChart -> refresh ( ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'c:chartSpace' ) ; $ objWriter -> writeAttribute ( 'xmlns:c' , 'http://schemas.openxmlformats.org/drawingml/2006/chart' ) ; $ objWriter -> writeAttribute ( 'xmlns:a' , 'http://schemas.openxmlformats.org/drawingml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ objWriter -> startElement ( 'c:date1904' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:lang' ) ; $ objWriter -> writeAttribute ( 'val' , 'en-GB' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:roundedCorners' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writeAlternateContent ( $ objWriter ) ; $ objWriter -> startElement ( 'c:chart' ) ; $ this -> writeTitle ( $ objWriter , $ pChart -> getTitle ( ) ) ; $ objWriter -> startElement ( 'c:autoTitleDeleted' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writePlotArea ( $ objWriter , $ pChart -> getWorksheet ( ) , $ pChart -> getPlotArea ( ) , $ pChart -> getXAxisLabel ( ) , $ pChart -> getYAxisLabel ( ) , $ pChart -> getChartAxisX ( ) , $ pChart -> getChartAxisY ( ) , $ pChart -> getMajorGridlines ( ) , $ pChart -> getMinorGridlines ( ) ) ; $ this -> writeLegend ( $ objWriter , $ pChart -> getLegend ( ) ) ; $ objWriter -> startElement ( 'c:plotVisOnly' ) ; $ objWriter -> writeAttribute ( 'val' , 1 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:dispBlanksAs' ) ; $ objWriter -> writeAttribute ( 'val' , 'gap' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showDLblsOverMax' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writePrintSettings ( $ objWriter ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
7022	private function formatO ( & $ str ) { if ( strstr ( $ str , '%O' ) ) { $ o = $ this -> timezone -> offset ; $ os = $ o >= 0 ? '+' : '-' ; $ oh = sprintf ( '%02d' , abs ( intval ( $ o ) ) ) ; $ om = sprintf ( '%02d' , abs ( $ o - intval ( $ o ) ) * 60 ) ; $ ofs = "{$os}{$oh}{$om}" ; $ str = str_replace ( '%O' , $ ofs , $ str ) ; } }
7020	private function format_i ( & $ str ) { if ( strstr ( $ str , '%i' ) ) $ str = str_replace ( '%i' , sprintf ( '%02d' , $ this -> min ) , $ str ) ; }
1239	private static function getActualType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } return $ actualType ; }
2977	public function unserialize ( $ serialized ) { $ this -> data = unserialize ( $ serialized ) ; $ this -> closure = __reconstruct_closure ( $ this -> data ) ; if ( ! $ this -> closure instanceof Closure ) { throw new ClosureUnserializationException ( 'The closure is corrupted and cannot be unserialized.' ) ; } if ( $ this -> data [ 'binding' ] || $ this -> data [ 'isStatic' ] ) { $ this -> closure = $ this -> closure -> bindTo ( $ this -> data [ 'binding' ] , $ this -> data [ 'scope' ] ) ; } }
1341	public function find ( ResourceIdentifierInterface $ identifier ) { $ record = $ this -> lookup ( $ identifier ) ; if ( false === $ record ) { return false ; } return is_object ( $ record ) ? $ record : null ; }
12408	protected function load ( ) { $ this -> config = array ( ) ; if ( file_exists ( $ this -> filePath ) ) { $ this -> config = Yaml :: parse ( $ this -> filePath ) ; } }
5889	public function getViewer ( IViewer $ viewer ) { $ html = $ viewer -> fetchObject ( $ this ) ; $ iterator = new \ RecursiveIteratorIterator ( $ this , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ iterator as $ node ) { $ siblings = array ( ) ; for ( $ level = 0 ; $ level < $ iterator -> getDepth ( ) ; $ level ++ ) { $ siblings [ ] = ( $ iterator -> getSubIterator ( $ level ) -> hasNext ( ) ) ? 1 : 0 ; } $ siblings [ ] = ( ! $ iterator -> getSubIterator ( $ level ) -> hasNext ( ) ) ? 1 : 0 ; $ html .= $ viewer -> fetchObject ( $ node , $ siblings ) ; } return $ html ; }
501	protected function getHeaderCheckBoxName ( ) { $ name = $ this -> name ; if ( substr_compare ( $ name , '[]' , - 2 , 2 ) === 0 ) { $ name = substr ( $ name , 0 , - 2 ) ; } if ( substr_compare ( $ name , ']' , - 1 , 1 ) === 0 ) { $ name = substr ( $ name , 0 , - 1 ) . '_all]' ; } else { $ name .= '_all' ; } return $ name ; }
7626	public function containerExists ( $ containerName = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ containers = $ this -> listContainers ( $ containerName , 1 ) ; foreach ( $ containers as $ container ) { if ( $ container -> Name == $ containerName ) { return true ; } } return false ; }
10729	public function getDay ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'day' ] ; } }
10033	function addUnsubscriptionReasonsToUnsubscribedContact ( $ id , $ checksum = null , $ reasons = null , $ ignore_checksum = false ) { $ queryParameters = array ( ) ; $ queryParameters [ 'id' ] = $ id ; if ( ! empty ( $ checksum ) ) { $ queryParameters [ 'checksum' ] = $ checksum ; } if ( $ ignore_checksum === true ) $ queryParameters [ 'ignore_checksum' ] = "true" ; if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } return $ this -> put ( "contacts/contact/unsubscribe/reasons" , null , $ queryParameters ) ; }
4270	public function dir_rewinddir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; \ rewinddir ( $ this -> handle ) ; self :: register ( ) ; return true ; }
612	public function setSingleton ( $ class , $ definition = [ ] , array $ params = [ ] ) { $ this -> _definitions [ $ class ] = $ this -> normalizeDefinition ( $ class , $ definition ) ; $ this -> _params [ $ class ] = $ params ; $ this -> _singletons [ $ class ] = null ; return $ this ; }
2215	public function next ( ) { if ( $ this -> blnDone ) { return false ; } if ( $ this -> fetchAssoc ( ) !== false ) { return $ this ; } $ this -> blnDone = true ; return false ; }
5286	private function reset ( ) { $ this -> distinct = false ; $ this -> found_rows = false ; $ this -> limit = null ; $ this -> statements = [ 'select' => [ ] , 'wheres' => [ ] , 'orders' => [ ] , 'values' => [ ] , 'groups' => [ ] , 'having' => '' , ] ; return $ this ; }
1210	public function split ( ItemInterface $ item , $ length ) { return array ( 'primary' => $ this -> slice ( $ item , 0 , $ length ) , 'secondary' => $ this -> slice ( $ item , $ length ) , ) ; }
1154	public function makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'makeReplacements' , [ $ message , $ attribute , $ rule , $ parameters ] ) ; }
8529	public function listFinancialEvents ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
2564	public static function generateSomewhatRandomString ( $ length = 22 ) { $ chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz" ; srand ( ( double ) microtime ( ) * 1000000 ) ; $ i = 0 ; $ somewhatRandom = '' ; while ( $ i < $ length ) { $ num = rand ( ) % 60 ; $ tmp = substr ( $ chars , $ num , 1 ) ; $ somewhatRandom = $ somewhatRandom . $ tmp ; $ i ++ ; } return $ somewhatRandom ; }
2508	public function createRequest ( $ messageName , RequestOptionsInterface $ params ) { $ this -> checkMessageIsInWsdl ( $ messageName ) ; $ builder = $ this -> findBuilderForMessage ( $ messageName ) ; if ( $ builder instanceof ConvertInterface ) { return $ builder -> convert ( $ params , $ this -> getActiveVersionFor ( $ messageName ) ) ; } else { throw new \ RuntimeException ( 'No builder found for message ' . $ messageName ) ; } }
10020	public function removeCellXfByIndex ( $ pIndex ) { if ( $ pIndex > count ( $ this -> cellXfCollection ) - 1 ) { throw new Exception ( 'CellXf index is out of bounds.' ) ; } array_splice ( $ this -> cellXfCollection , $ pIndex , 1 ) ; foreach ( $ this -> workSheetCollection as $ worksheet ) { foreach ( $ worksheet -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ worksheet -> getCell ( $ coordinate ) ; $ xfIndex = $ cell -> getXfIndex ( ) ; if ( $ xfIndex > $ pIndex ) { $ cell -> setXfIndex ( $ xfIndex - 1 ) ; } elseif ( $ xfIndex == $ pIndex ) { $ cell -> setXfIndex ( 0 ) ; } } } }
3761	private function getLegend ( PaletteInterface $ palette , $ legendName ) { if ( $ palette -> hasLegend ( $ legendName ) ) { return $ palette -> getLegend ( $ legendName ) ; } $ legend = new Legend ( $ legendName ) ; $ palette -> addLegend ( $ legend ) ; return $ legend ; }
10274	public function setLocked ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'locked' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> locked = $ pValue ; } return $ this ; }
7826	protected function getLongestPipeLength ( ) { if ( empty ( $ this -> pipes ) ) return 0 ; return array_reduce ( $ this -> pipes , function ( $ carry , $ pipe ) { return strlen ( $ pipe ) > $ carry ? strlen ( $ pipe ) : $ carry ; } , static :: MIN_PIPE_LENGTH ) ; }
2452	private function getLocale ( Request $ request ) : string { if ( null !== $ request -> attributes -> get ( '_locale' ) ) { return $ this -> formatLocaleId ( $ request -> attributes -> get ( '_locale' ) ) ; } return $ request -> getPreferredLanguage ( $ this -> availableLocales ) ; }
2070	public function deletePage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ root = func_get_arg ( 7 ) ; return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_DELETE_PAGE , $ row ) && ( $ this -> User -> isAdmin || ! \ in_array ( $ row [ 'id' ] , $ root ) ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
11818	public function setServiceLocator ( ServiceLocatorInterface $ serviceLocator ) { $ this -> serviceLocator = $ serviceLocator ; $ config = $ serviceLocator -> getServiceLocator ( ) -> get ( 'config' ) ; if ( isset ( $ config [ 'rznviewcomponent' ] ) ) { $ this -> config = $ config [ 'rznviewcomponent' ] ; } return $ this ; }
8049	public function createCalendarEvent ( array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEvent = $ this -> calendarEvent -> create ( $ eventData ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents [ $ calendarEvent -> id ] = $ calendarEvent ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
7573	public function validateRequiredFields ( $ postVars ) { $ requiredFields = $ this -> getRequiredFields ( $ postVars [ 'id' ] ) ; $ missingKeys = array ( ) ; foreach ( $ requiredFields as $ human => $ keys ) { if ( ! $ this -> hasRequiredValue ( $ postVars , $ keys ) ) { $ missingKeys [ ] = $ human ; } } if ( ! empty ( $ missingKeys ) ) { throw new GreenhouseApplicationException ( 'Submission missing required answers for: ' . implode ( ', ' , $ missingKeys ) ) ; } return true ; }
5105	public function limit ( $ from , $ count ) : IWithLimit { return $ this -> setPart ( CmdUpdate :: PART_LIMIT , true , ( $ from ? array ( $ from , $ count ) : $ count ) ) ; }
799	private function removeSpaceAroundToken ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isWhitespace ( ) && false === strpos ( $ token -> getContent ( ) , "\n" ) ) { $ tokens -> clearAt ( $ index ) ; } }
5990	public function addPropertyCriteria ( $ item ) { if ( ! ( $ item instanceof PropertyCriteria ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertyCriteria ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertyCriteria. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertyCriteria"!' , E_USER_WARNING ) ; } } $ this -> properties [ ] = $ item ; return $ this ; }
292	public function hasAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) || in_array ( $ name , $ this -> attributes ( ) , true ) ; }
4361	public static function isUtf8 ( $ str , & $ special = false ) { self :: setStr ( $ str ) ; $ special = false ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial ) ; if ( ! $ isUtf8 ) { return false ; } if ( $ isSpecial ) { $ special = true ; } } $ special = $ special || self :: hasSpecial ( $ str ) ; return true ; }
10830	public static function file ( string $ path ) : fs \ entity \ FileEntity { return ( new fs \ entity \ FileEntity ( $ path ) ) -> normalize ( ) ; }
11633	private function saveLog ( $ operIdWriteOff , $ calcId ) { $ log = new ELogOper ( ) ; $ log -> setCalcId ( $ calcId ) ; $ log -> setOperId ( $ operIdWriteOff ) ; $ this -> daoLogOper -> create ( $ log ) ; }
4858	public function getList ( $ namespace , $ callback ) { $ session = new Container ( $ namespace ) ; $ params = $ session -> params ? : array ( ) ; if ( ! $ session -> list ) { $ session -> list = is_array ( $ callback ) ? call_user_func ( $ callback , $ session -> params ) : $ callback -> getPaginationList ( $ session -> params ) ; } return $ session -> list ; }
95	private function findBestVersionAndNameForPackage ( InputInterface $ input , $ name , $ phpVersion , $ preferredStability = 'stable' , $ requiredVersion = null , $ minimumStability = null ) { $ versionSelector = new VersionSelector ( $ this -> getPool ( $ input , $ minimumStability ) ) ; $ ignorePlatformReqs = $ input -> hasOption ( 'ignore-platform-reqs' ) && $ input -> getOption ( 'ignore-platform-reqs' ) ; if ( $ ignorePlatformReqs ) { $ phpVersion = null ; } $ package = $ versionSelector -> findBestCandidate ( $ name , $ requiredVersion , $ phpVersion , $ preferredStability ) ; if ( ! $ package ) { if ( $ ignorePlatformReqs && preg_match ( PlatformRepository :: PLATFORM_PACKAGE_REGEX , $ name ) ) { return array ( $ name , $ requiredVersion ? : '*' ) ; } if ( $ phpVersion && $ versionSelector -> findBestCandidate ( $ name , $ requiredVersion , null , $ preferredStability ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Package %s at version %s has a PHP requirement incompatible with your PHP version (%s)' , $ name , $ requiredVersion , $ phpVersion ) ) ; } if ( $ requiredVersion && $ versionSelector -> findBestCandidate ( $ name , null , $ phpVersion , $ preferredStability ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not find package %s in a version matching %s' , $ name , $ requiredVersion ) ) ; } if ( $ phpVersion && $ versionSelector -> findBestCandidate ( $ name ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not find package %s in any version matching your PHP version (%s)' , $ name , $ phpVersion ) ) ; } $ similar = $ this -> findSimilar ( $ name ) ; if ( $ similar ) { if ( $ requiredVersion === null && in_array ( $ name , $ similar , true ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not find a version of package %s matching your minimum-stability (%s). Require it with an explicit version constraint allowing its desired stability.' , $ name , $ this -> getMinimumStability ( $ input ) ) ) ; } throw new \ InvalidArgumentException ( sprintf ( "Could not find package %s.\n\nDid you mean " . ( count ( $ similar ) > 1 ? 'one of these' : 'this' ) . "?\n %s" , $ name , implode ( "\n " , $ similar ) ) ) ; } throw new \ InvalidArgumentException ( sprintf ( 'Could not find a matching version of package %s. Check the package spelling, your version constraint and that the package is available in a stability which matches your minimum-stability (%s).' , $ name , $ this -> getMinimumStability ( $ input ) ) ) ; } return array ( $ package -> getPrettyName ( ) , $ versionSelector -> findRecommendedRequireVersion ( $ package ) , ) ; }
7192	private function copyItem ( Model \ SaleItemInterface $ source , Model \ SaleItemInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'designation' , 'description' , 'reference' , 'taxGroup' , 'netPrice' , 'weight' , 'quantity' , 'position' , 'compound' , 'immutable' , 'configurable' , 'private' , 'data' , ] ) ; $ this -> copy ( $ source -> getSubjectIdentity ( ) , $ target -> getSubjectIdentity ( ) , [ 'provider' , 'identifier' , ] ) ; foreach ( $ source -> getAdjustments ( ) as $ sourceAdjustment ) { $ targetAdjustment = $ this -> saleFactory -> createAdjustmentForItem ( $ target ) ; $ target -> addAdjustment ( $ targetAdjustment ) ; $ this -> copyAdjustment ( $ sourceAdjustment , $ targetAdjustment ) ; } foreach ( $ source -> getChildren ( ) as $ sourceChild ) { $ targetChild = $ this -> saleFactory -> createItemForSale ( $ target -> getSale ( ) ) ; $ target -> addChild ( $ targetChild ) ; $ this -> copyItem ( $ sourceChild , $ targetChild ) ; } }
3187	public function end ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'end() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; } else { \ common_Logger :: t ( 'Range already closed, or missing START TimePoint in QtiTimer, continue anyway' ) ; } return $ this ; }
11161	protected function getReplacements ( $ entry ) { $ link = 'https://youtu.be/' . $ entry -> id ; $ title = $ entry -> snippet -> title ; $ author = $ entry -> snippet -> channelTitle ; $ published = date ( $ this -> publishedFormat , strtotime ( $ entry -> snippet -> publishedAt ) ) ; $ views = number_format ( $ entry -> statistics -> viewCount , 0 ) ; $ likes = number_format ( $ entry -> statistics -> likeCount , 0 ) ; $ dislikes = number_format ( $ entry -> statistics -> dislikeCount , 0 ) ; $ favorites = number_format ( $ entry -> statistics -> favoriteCount , 0 ) ; $ comments = number_format ( $ entry -> statistics -> commentCount , 0 ) ; $ durationInterval = new \ DateInterval ( $ entry -> contentDetails -> duration ) ; $ duration = $ durationInterval -> format ( $ this -> durationFormat ) ; return array ( '%link%' => $ link , '%title%' => $ title , '%author%' => $ author , '%published%' => $ published , '%views%' => $ views , '%likes%' => $ likes , '%dislikes%' => $ dislikes , '%favorites%' => $ favorites , '%comments%' => $ comments , '%duration%' => $ duration , ) ; }
6009	public function setDeleted ( $ deleted ) { if ( $ deleted instanceof DateTime ) { $ this -> deleted = $ deleted ; } else { try { $ this -> deleted = new DateTime ( $ deleted ) ; } catch ( \ Exception $ e ) { $ this -> deleted = null ; } } return $ this ; }
4015	protected function makeMandatory ( $ field , $ row , $ key ) { $ field [ 'eval' ] [ 'required' ] = false ; if ( empty ( $ field [ 'eval' ] [ 'mandatory' ] ) ) { return $ field ; } if ( is_array ( $ this -> varValue [ $ row ] [ $ key ] ) ) { if ( empty ( $ this -> varValue [ $ row ] [ $ key ] ) ) { $ field [ 'eval' ] [ 'required' ] = true ; } } else { if ( ! strlen ( $ this -> varValue [ $ row ] [ $ key ] ) ) { $ field [ 'eval' ] [ 'required' ] = true ; } } return $ field ; }
9807	private function readBlipJPEG ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ pos = 0 ; $ rgbUid1 = substr ( $ recordData , 0 , 16 ) ; $ pos += 16 ; if ( in_array ( $ recInstance , [ 0x046B , 0x06E3 ] ) ) { $ rgbUid2 = substr ( $ recordData , 16 , 16 ) ; $ pos += 16 ; } $ tag = ord ( $ recordData [ $ pos ] ) ; $ pos += 1 ; $ data = substr ( $ recordData , $ pos ) ; $ blip = new Blip ( ) ; $ blip -> setData ( $ data ) ; $ this -> object -> setBlip ( $ blip ) ; }
4704	public function get ( $ name ) { if ( ! $ this -> exists ( $ name ) ) { throw new \ OutOfBoundsException ( sprintf ( 'Undefined offset "%s"' , $ name ) ) ; } return $ this -> objects [ ( string ) $ name ] ; }
266	protected function loadMessages ( $ category , $ language ) { if ( $ this -> enableCaching ) { $ key = [ __CLASS__ , $ category , $ language , ] ; $ messages = $ this -> cache -> get ( $ key ) ; if ( $ messages === false ) { $ messages = $ this -> loadMessagesFromDb ( $ category , $ language ) ; $ this -> cache -> set ( $ key , $ messages , $ this -> cachingDuration ) ; } return $ messages ; } return $ this -> loadMessagesFromDb ( $ category , $ language ) ; }
11150	protected function setCacheState ( $ useCache ) { if ( is_bool ( $ useCache ) ) { $ this -> useCache = $ useCache ; } else { $ this -> useCache = true ; } }
6970	protected function calculateShipmentLine ( Model \ DocumentLineInterface $ line , Amount $ final ) : Amount { if ( $ line -> getType ( ) !== Model \ DocumentLineTypes :: TYPE_SHIPMENT ) { throw new LogicException ( sprintf ( "Expected document line with type '%s'." , Model \ DocumentLineTypes :: TYPE_SHIPMENT ) ) ; } $ sale = $ line -> getDocument ( ) -> getSale ( ) ; $ result = $ this -> calculator -> calculateSaleShipment ( $ sale , $ final ) ; if ( null === $ result ) { throw new LogicException ( "Unexpected document shipment line." ) ; } $ this -> syncLineWithResult ( $ line , $ result ) ; return $ result ; }
9197	public function getTag ( ) { if ( null !== $ this -> tag ) { return $ this -> tag ; } $ categoryId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'categoryid' ) ; if ( is_numeric ( $ categoryId ) ) { return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ categoryId ) ; } $ topicId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'topicid' ) ; if ( is_numeric ( $ topicId ) ) { $ topic = $ this -> getDiscussService ( ) -> getTopicById ( $ topicId ) ; return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ topic -> getforumCategoryId ( ) ) ; } return false ; }
1836	public static function findMultipleByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ arrRegistered = array ( ) ; $ arrUnregistered = array ( ) ; foreach ( $ arrIds as $ intId ) { if ( empty ( $ arrOptions ) ) { $ arrRegistered [ $ intId ] = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ intId ) ; } if ( ! isset ( $ arrRegistered [ $ intId ] ) ) { $ arrUnregistered [ ] = $ intId ; } } if ( ! empty ( $ arrUnregistered ) ) { $ t = static :: $ strTable ; $ arrOptions = array_merge ( array ( 'column' => array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrUnregistered ) ) . ")" ) , 'value' => null , 'order' => Database :: getInstance ( ) -> findInSet ( "$t.id" , $ arrIds ) , 'return' => 'Collection' ) , $ arrOptions ) ; $ objMissing = static :: find ( $ arrOptions ) ; if ( $ objMissing !== null ) { while ( $ objMissing -> next ( ) ) { $ intId = $ objMissing -> { static :: $ strPk } ; $ arrRegistered [ $ intId ] = $ objMissing -> current ( ) ; } } } $ arrRegistered = array_filter ( array_values ( $ arrRegistered ) ) ; if ( empty ( $ arrRegistered ) ) { return null ; } return static :: createCollection ( $ arrRegistered , static :: $ strTable ) ; }
3912	protected function remapSorting ( $ arrFiles , $ arrSource ) { $ files = array ( ) ; $ source = array ( ) ; foreach ( array_keys ( $ arrFiles ) as $ k ) { $ files [ ] = $ arrFiles [ $ k ] ; $ source [ ] = $ arrSource [ $ k ] ; } $ this -> addClasses ( $ source ) ; return array ( 'files' => $ files , 'source' => $ source ) ; }
3645	public function old ( string $ key , $ default = null , bool $ trim = true , bool $ clean = true ) { $ value = $ this -> request -> old ( $ key , $ default ) ; return $ this -> clean ( $ value , $ trim , $ clean ) ; }
960	public function handle ( Request $ request , Closure $ next ) { if ( Config :: get ( 'shopify-app.billing_enabled' ) === true ) { $ shop = ShopifyApp :: shop ( ) ; if ( ! $ shop -> isFreemium ( ) && ! $ shop -> isGrandfathered ( ) && ! $ shop -> plan ) { return Redirect :: route ( 'billing' ) ; } } return $ next ( $ request ) ; }
6892	protected function resolveSoldDeltaQuantity ( SaleItemInterface $ item ) { $ old = $ new = $ item -> getQuantity ( ) ; if ( $ this -> persistenceHelper -> isChanged ( $ item , 'quantity' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ item , 'quantity' ) ; } $ parent = $ item ; while ( null !== $ parent = $ parent -> getParent ( ) ) { if ( $ this -> persistenceHelper -> isChanged ( $ parent , 'quantity' ) ) { list ( $ parentOld , $ parentNew ) = $ this -> persistenceHelper -> getChangeSet ( $ parent , 'quantity' ) ; } else { $ parentOld = $ parentNew = $ parent -> getQuantity ( ) ; } $ old *= $ parentOld ; $ new *= $ parentNew ; } $ sale = $ item -> getSale ( ) ; $ shippedOld = $ shippedNew = 0 ; $ f = $ t = false ; if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'released' ) ) { list ( $ f , $ t ) = $ this -> persistenceHelper -> getChangeSet ( $ sale , 'released' ) ; } elseif ( $ item -> getSale ( ) -> isReleased ( ) ) { $ f = $ t = true ; } if ( $ f || $ t ) { foreach ( $ item -> getStockAssignments ( ) as $ assignment ) { if ( $ this -> persistenceHelper -> isChanged ( $ assignment , 'shippedQuantity' ) ) { list ( $ o , $ n ) = $ this -> persistenceHelper -> getChangeSet ( $ assignment , 'shippedQuantity' ) ; } else { $ o = $ n = $ assignment -> getShippedQuantity ( ) ; } if ( $ f ) { $ shippedOld += $ o ; } if ( $ t ) { $ shippedNew += $ n ; } } if ( $ f ) { $ old = min ( $ old , $ shippedOld ) ; } if ( $ t ) { $ new = min ( $ new , $ shippedNew ) ; } } return $ new - $ old ; }
4987	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( $ spec instanceof FormParentInterface ) { $ spec -> setParent ( $ this ) ; } $ spec = [ '__instance__' => $ spec , 'name' => $ key , 'entity' => '*' ] ; } if ( ! is_array ( $ spec ) ) { $ spec = array ( 'type' => $ spec , 'name' => $ key ) ; } if ( ! isset ( $ spec [ 'name' ] ) ) { $ spec [ 'name' ] = $ key ; } if ( ! isset ( $ spec [ 'entity' ] ) ) { $ spec [ 'entity' ] = '*' ; } $ this -> forms [ $ key ] = $ spec ; if ( $ enabled ) { $ this -> enableForm ( $ key ) ; } elseif ( true === $ this -> activeForms ) { $ this -> activeForms = false ; } return $ this ; }
8911	protected function apply_soft_delete_filter ( ) { if ( $ this -> soft_delete && $ this -> _temporary_with_deleted !== TRUE ) { if ( $ this -> _temporary_only_deleted ) { $ where = "`{$this->deleted_at_key}` <= NOW()" ; } else { $ where = sprintf ( '(%1$s > NOW() OR %1$s IS NULL OR %1$s = \'0000-00-00 00:00:00\')' , $ this -> deleted_at_key ) ; } $ this -> _database -> where ( $ where ) ; } }
12019	function addProperties ( ) { $ requiredProperties = [ 'api' => '\\' . $ this -> apiClassname , 'parameters' => 'array' , 'response' => '\Amp\Artax\Response' , 'originalResponse' => '\Amp\Artax\Response' , ] ; foreach ( $ requiredProperties as $ propertyName => $ typehint ) { $ propertyGenerator = new PropertyGenerator ( $ propertyName , null ) ; $ docBlock = new DocBlockGenerator ( '@var ' . $ typehint ) ; $ propertyGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addPropertyFromGenerator ( $ propertyGenerator ) ; } $ docBlock = new DocBlockGenerator ( 'Get the last response.' ) ; $ body = 'return $this->response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'getResponse' , $ body , $ docBlock , [ ] , '\Amp\Artax\Response' ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; $ docBlock = new DocBlockGenerator ( 'Set the last response. This should only be used by the API class when the operation has been dispatched. Storing the response is required as some APIs store out-of-bound information in the headers e.g. rate-limit info, pagination that is not really part of the operation.' ) ; $ body = '$this->response = $response;' ; $ methodGenerator = $ this -> createMethodGenerator ( 'setResponse' , $ body , $ docBlock , [ [ 'response' , 'Amp\Artax\Response' ] ] ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
7859	private function registerWorkflowRunnersHook ( ) { $ this -> app -> afterResolving ( function ( WorkflowRunner $ runner , $ app ) { $ runner -> setWorkflow ( $ app [ 'cerbero.workflow' ] ) ; } ) ; }
9903	public function updateCellReference ( $ pCellRange = 'A1' , $ pBefore = 'A1' , $ pNumCols = 0 , $ pNumRows = 0 ) { if ( strpos ( $ pCellRange , '!' ) !== false ) { return $ pCellRange ; } elseif ( ! Coordinate :: coordinateIsRange ( $ pCellRange ) ) { return $ this -> updateSingleCellReference ( $ pCellRange , $ pBefore , $ pNumCols , $ pNumRows ) ; } elseif ( Coordinate :: coordinateIsRange ( $ pCellRange ) ) { return $ this -> updateCellRange ( $ pCellRange , $ pBefore , $ pNumCols , $ pNumRows ) ; } return $ pCellRange ; }
2993	public function initSMTP ( ) { $ f3 = \ Base :: instance ( ) ; $ this -> smtp = new \ SMTP ( $ f3 -> get ( 'mailer.smtp.host' ) , $ f3 -> get ( 'mailer.smtp.port' ) , $ f3 -> get ( 'mailer.smtp.scheme' ) , $ f3 -> get ( 'mailer.smtp.user' ) , $ f3 -> get ( 'mailer.smtp.pw' ) ) ; if ( ! $ f3 -> devoid ( 'mailer.errors_to' , $ errors_to ) ) $ this -> setErrors ( $ errors_to ) ; if ( ! $ f3 -> devoid ( 'mailer.reply_to' , $ reply_to ) ) $ this -> setReply ( $ reply_to ) ; if ( ! $ f3 -> devoid ( 'mailer.from_mail' , $ from_mail ) ) { if ( $ f3 -> devoid ( 'mailer.from_name' , $ from_name ) ) $ from_name = NULL ; $ this -> setFrom ( $ from_mail , $ from_name ) ; } }
1982	public static function hasError ( $ strScope = TL_MODE ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return false ; } return $ session -> getFlashBag ( ) -> has ( static :: getFlashBagKey ( 'error' , $ strScope ) ) ; }
489	protected function findTableConstraints ( $ table , $ type ) { $ keyColumnUsageTableName = 'INFORMATION_SCHEMA.KEY_COLUMN_USAGE' ; $ tableConstraintsTableName = 'INFORMATION_SCHEMA.TABLE_CONSTRAINTS' ; if ( $ table -> catalogName !== null ) { $ keyColumnUsageTableName = $ table -> catalogName . '.' . $ keyColumnUsageTableName ; $ tableConstraintsTableName = $ table -> catalogName . '.' . $ tableConstraintsTableName ; } $ keyColumnUsageTableName = $ this -> quoteTableName ( $ keyColumnUsageTableName ) ; $ tableConstraintsTableName = $ this -> quoteTableName ( $ tableConstraintsTableName ) ; $ sql = <<<SQLSELECT [kcu].[constraint_name] AS [index_name], [kcu].[column_name] AS [field_name]FROM {$keyColumnUsageTableName} AS [kcu]LEFT JOIN {$tableConstraintsTableName} AS [tc] ON [kcu].[table_schema] = [tc].[table_schema] AND [kcu].[table_name] = [tc].[table_name] AND [kcu].[constraint_name] = [tc].[constraint_name]WHERE [tc].[constraint_type] = :type AND [kcu].[table_name] = :tableName AND [kcu].[table_schema] = :schemaNameSQL ; return $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ':type' => $ type , ] ) -> queryAll ( ) ; }
10151	private function readFooter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { if ( $ recordData ) { if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( $ recordData ) ; } else { $ string = $ this -> readByteStringShort ( $ recordData ) ; } $ this -> phpSheet -> getHeaderFooter ( ) -> setOddFooter ( $ string [ 'value' ] ) ; $ this -> phpSheet -> getHeaderFooter ( ) -> setEvenFooter ( $ string [ 'value' ] ) ; } } }
841	public function offsetUnset ( $ index ) { $ this -> changed = true ; $ this -> unregisterFoundToken ( $ this [ $ index ] ) ; parent :: offsetUnset ( $ index ) ; }
11755	public function markElect ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MARK_ELECT , $ params ] ) ; }
11189	public static function json ( $ jsonStr , $ k = null , $ default = null ) { $ json = json_decode ( $ jsonStr , true ) ; if ( $ k && $ json ) { return self :: get ( $ json , $ k , $ default ) ; } return $ json ; }
40	protected function fetchRootIdentifier ( ) { if ( $ this -> repoData ) { return ; } $ repoDataUrl = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository ; $ this -> repoData = JsonFile :: parseJson ( $ this -> getContents ( $ repoDataUrl , true ) , $ repoDataUrl ) ; if ( null === $ this -> repoData && null !== $ this -> gitDriver ) { return ; } $ this -> owner = $ this -> repoData [ 'owner' ] [ 'login' ] ; $ this -> repository = $ this -> repoData [ 'name' ] ; $ this -> isPrivate = ! empty ( $ this -> repoData [ 'private' ] ) ; if ( isset ( $ this -> repoData [ 'default_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'default_branch' ] ; } elseif ( isset ( $ this -> repoData [ 'master_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'master_branch' ] ; } else { $ this -> rootIdentifier = 'master' ; } $ this -> hasIssues = ! empty ( $ this -> repoData [ 'has_issues' ] ) ; }
9362	public function argument ( ) { if ( $ this -> original ) { return $ this -> original -> theta ; } return atan2 ( $ this -> float_i , $ this -> float_r ) ; }
4795	function aggregation ( $ function ) { $ join = $ this -> createJoins ( implode ( "," , $ this -> conditions ) . ",$function" ) ; $ query = "SELECT $function FROM $this->table" . implode ( $ join ) ; if ( $ this -> where ) { $ query .= " WHERE " . implode ( $ this -> where ) ; } foreach ( $ this -> query ( $ query , $ this -> parameters ) -> fetch ( ) as $ return ) { return $ return ; } }
7495	private static function convertString ( $ string , $ outputEncoding ) { if ( $ string instanceof StringBuilder ) { $ inputEncoding = $ string -> getEncoding ( ) ; } else { $ inputEncoding = mb_detect_encoding ( ( string ) $ string ) ; } $ string = ( string ) $ string ; if ( $ inputEncoding != $ outputEncoding ) { $ string = iconv ( $ inputEncoding , $ outputEncoding , $ string ) ; } return $ string ; }
5192	public function map ( array $ methods , string $ path , RequestHandlerInterface $ handler ) : Route { return $ this -> routes [ ] = new Route ( $ methods , $ path , $ handler ) ; }
3719	protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) ) { return false ; } if ( $ event -> getPropertyName ( ) !== 'type' ) { return false ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ request -> request -> get ( 'act' , null ) === 'select' && ! $ event -> getModel ( ) -> getId ( ) ) { return false ; } return true ; }
6268	public function isAcademic ( $ text ) { if ( empty ( $ text ) ) { return false ; } $ domain = $ this -> getDomain ( $ text ) ; if ( $ domain === null ) { return false ; } foreach ( $ this -> getBlacklistedTopLevelDomains ( ) as $ blacklistedDomain ) { $ name = ( string ) $ domain [ 'host' ] ; if ( preg_match ( '/' . preg_quote ( $ blacklistedDomain ) . '$/' , $ name ) ) { return false ; } } if ( in_array ( $ domain [ 'tld' ] , $ this -> getAcademicTopLevelDomains ( ) ) ) { return true ; } if ( $ this -> matchesAcademicDomain ( $ domain ) ) { return true ; } return false ; }
2552	private function getStringBetween ( $ string , $ start , $ end ) { $ startPos = strpos ( $ string , $ start ) + strlen ( $ start ) ; $ endPos = strlen ( $ string ) - strpos ( $ string , $ end ) ; return substr ( $ string , $ startPos , - $ endPos ) ; }
4912	public function setVariables ( $ variables , $ overwrite = false ) { if ( ! is_array ( $ variables ) && ! $ variables instanceof \ Traversable ) { throw new \ InvalidArgumentException ( sprintf ( '%s: expects an array, or Traversable argument; received "%s"' , __METHOD__ , ( is_object ( $ variables ) ? get_class ( $ variables ) : gettype ( $ variables ) ) ) ) ; } if ( $ overwrite ) { if ( is_object ( $ variables ) && ! $ variables instanceof \ ArrayAccess ) { $ variables = ArrayUtils :: iteratorToArray ( $ variables ) ; } $ this -> variables = $ variables ; return $ this ; } foreach ( $ variables as $ key => $ value ) { $ this -> setVariable ( $ key , $ value ) ; } return $ this ; }
7914	protected function renderLabel ( ) { $ label = $ this -> encodeLabel ? Html :: encode ( $ this -> label ) : $ this -> label ; return $ this -> hasModel ( ) ? Html :: activeLabel ( $ this -> model , $ this -> attribute , $ this -> labelOptions ) : Html :: label ( $ label , $ this -> getId ( ) , $ this -> labelOptions ) ; }
2899	public function getQueryModels ( ) { $ queries = array ( ) ; foreach ( $ this -> _queryProfiles as $ queryId => $ queryProfile ) { $ queryModel = Mage :: getModel ( 'sheep_debug/query' ) ; $ stacktrace = array_key_exists ( $ queryId , $ this -> stackTraces ) ? $ this -> stackTraces [ $ queryId ] : '' ; $ queryModel -> init ( $ queryProfile , $ stacktrace ) ; $ queries [ ] = $ queryModel ; } return $ queries ; }
2915	public function getLayoutUpdatesFiles ( $ storeId , $ designArea ) { $ updatesRoot = $ this -> getConfig ( ) -> getNode ( $ designArea . '/layout/updates' ) ; $ updateFiles = array ( ) ; foreach ( $ updatesRoot -> children ( ) as $ updateNode ) { if ( $ updateNode -> file ) { $ module = $ updateNode -> getAttribute ( 'module' ) ; if ( $ module && Mage :: getStoreConfigFlag ( 'advanced/modules_disable_output/' . $ module , $ storeId ) ) { continue ; } $ updateFiles [ ] = ( string ) $ updateNode -> file ; } } $ updateFiles [ ] = 'local.xml' ; return $ updateFiles ; }
7776	protected function getRuleArgs ( $ rule ) { if ( ! $ this -> ruleHasArgs ( $ rule ) ) { return [ ] ; } list ( $ ruleName , $ argsWithBracketAtTheEnd ) = explode ( '(' , $ rule ) ; $ args = rtrim ( $ argsWithBracketAtTheEnd , ')' ) ; $ args = preg_replace ( '/\s+/' , '' , $ args ) ; $ args = explode ( ',' , $ args ) ; return $ args ; }
10099	private function writeString ( $ row , $ col , $ str , $ xfIndex ) { $ this -> writeLabelSst ( $ row , $ col , $ str , $ xfIndex ) ; }
47	public function addSubscriber ( EventSubscriberInterface $ subscriber ) { foreach ( $ subscriber -> getSubscribedEvents ( ) as $ eventName => $ params ) { if ( is_string ( $ params ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params ) ) ; } elseif ( is_string ( $ params [ 0 ] ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params [ 0 ] ) , isset ( $ params [ 1 ] ) ? $ params [ 1 ] : 0 ) ; } else { foreach ( $ params as $ listener ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ listener [ 0 ] ) , isset ( $ listener [ 1 ] ) ? $ listener [ 1 ] : 0 ) ; } } } }
5565	public function head ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } $ response = $ this -> user_agent -> fetchResponse ( $ url , new SimpleHeadEncoding ( $ parameters ) ) ; $ this -> page = new SimplePage ( $ response ) ; return ! $ response -> isError ( ) ; }
11295	public function getAttributeValue ( $ name , $ convertDates = true ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { $ result = $ this -> model_data [ $ name ] ; if ( $ result instanceof \ DateTime && $ convertDates == true ) { $ result = $ result -> format ( 'Y-m-d H:i:s' ) ; } return $ result ; } if ( isset ( $ this -> data -> { $ name } ) ) { return $ this -> data -> { $ name } ; } return null ; }
12674	public function getForeignModelConfig ( $ sourceFile , $ modelName ) { $ config = [ 'class' => Model :: className ( ) ] ; if ( isset ( $ this -> foreignModelsConfig [ $ modelName ] ) ) { $ config = array_merge ( $ config , $ this -> foreignModelsConfig [ $ modelName ] ) ; } $ config [ 'modelName' ] = $ modelName ; $ config [ 'sourceFile' ] = $ sourceFile ; $ config [ 'interface' ] = $ this ; return $ config ; }
7578	protected function configureData ( $ data ) { if ( ! empty ( $ this -> _REQUIRED_DATA ) && is_array ( $ data ) ) { $ data = $ this -> configureDefaultData ( $ data ) ; } $ this -> setData ( $ data ) ; }
10623	public static function synchronizeMigrations ( CommandEvent $ event ) { $ packages = $ event -> getComposer ( ) -> getRepositoryManager ( ) -> getLocalRepository ( ) -> getPackages ( ) ; $ installer = $ event -> getComposer ( ) -> getInstallationManager ( ) ; $ appMigrationDir = self :: getDestinationDir ( $ event -> getComposer ( ) ) ; $ io = $ event -> getIO ( ) ; $ areFileMigrated = array ( ) ; $ areFileMigrated [ ] = self :: handlePackage ( '.' , $ event -> getComposer ( ) -> getPackage ( ) , $ io , $ appMigrationDir ) ; foreach ( $ packages as $ package ) { $ areFileMigrated [ ] = self :: handlePackage ( $ installer -> getInstallPath ( $ package ) , $ package , $ io , $ appMigrationDir ) ; } if ( in_array ( true , $ areFileMigrated ) ) { $ io -> write ( "<warning>Some migration files have been imported. " . "You should run `php app/console doctrine:migrations:status` and/or " . "`php app/console doctrine:migrations:migrate` to apply them to your DB." ) ; } }
8328	public function getCaptchaResult ( $ captchaId ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get&id={$captchaId}&json=1" ) ; $ responseData = json_decode ( $ response -> getBody ( ) -> __toString ( ) , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new InvalidArgumentException ( 'json_decode error: ' . json_last_error_msg ( ) ) ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_CAPCHA_NOT_READY ) { return false ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_OK ) { $ this -> getLogger ( ) -> info ( "Got OK response: `{$responseData['request']}`." ) ; return $ responseData [ 'request' ] ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseData [ 'request' ] ) ? : $ responseData [ 'request' ] , $ responseData [ 'status' ] ) ; }
1995	public function generateRss ( ) { $ this -> adjustPublicationDate ( ) ; $ xml = '<?xml version="1.0" encoding="' . Config :: get ( 'characterSet' ) . '"?>' ; $ xml .= '<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/" xmlns:atom="http://www.w3.org/2005/Atom">' ; $ xml .= '<channel>' ; $ xml .= '<title>' . StringUtil :: specialchars ( $ this -> title ) . '</title>' ; $ xml .= '<description>' . StringUtil :: specialchars ( $ this -> description ) . '</description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ this -> link ) . '</link>' ; $ xml .= '<language>' . $ this -> language . '</language>' ; $ xml .= '<pubDate>' . date ( 'r' , $ this -> published ) . '</pubDate>' ; $ xml .= '<generator>Contao Open Source CMS</generator>' ; $ xml .= '<atom:link href="' . StringUtil :: specialchars ( Environment :: get ( 'base' ) . 'share/' . $ this -> strName ) . '.xml" rel="self" type="application/rss+xml" />' ; foreach ( $ this -> arrItems as $ objItem ) { $ xml .= '<item>' ; $ xml .= '<title>' . StringUtil :: specialchars ( strip_tags ( StringUtil :: stripInsertTags ( $ objItem -> title ) ) ) . '</title>' ; $ xml .= '<description><![CDATA[' . preg_replace ( '/[\n\r]+/' , ' ' , $ objItem -> description ) . ']]></description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ objItem -> link ) . '</link>' ; $ xml .= '<pubDate>' . date ( 'r' , $ objItem -> published ) . '</pubDate>' ; if ( $ objItem -> guid ) { if ( strncmp ( $ objItem -> guid , 'http://' , 7 ) !== 0 && strncmp ( $ objItem -> guid , 'https://' , 8 ) !== 0 ) { $ xml .= '<guid isPermaLink="false">' . $ objItem -> guid . '</guid>' ; } else { $ xml .= '<guid>' . $ objItem -> guid . '</guid>' ; } } else { $ xml .= '<guid>' . StringUtil :: specialchars ( $ objItem -> link ) . '</guid>' ; } if ( \ is_array ( $ objItem -> enclosure ) ) { foreach ( $ objItem -> enclosure as $ arrEnclosure ) { if ( ! empty ( $ arrEnclosure [ 'media' ] ) && $ arrEnclosure [ 'media' ] == 'media:content' ) { $ xml .= '<media:content url="' . $ arrEnclosure [ 'url' ] . '" type="' . $ arrEnclosure [ 'type' ] . '" />' ; } else { $ xml .= '<enclosure url="' . $ arrEnclosure [ 'url' ] . '" length="' . $ arrEnclosure [ 'length' ] . '" type="' . $ arrEnclosure [ 'type' ] . '" />' ; } } } $ xml .= '</item>' ; } $ xml .= '</channel>' ; $ xml .= '</rss>' ; return $ xml ; }
11374	private function getInjectHint ( \ ReflectionMethod $ method , \ ReflectionParameter $ parameter ) { $ hint = Psi :: it ( $ this -> reader -> getMethodAnnotations ( $ method ) ) -> filter ( new IsInstanceOf ( Di \ DiInjectHintAnnotation :: class ) ) -> filter ( function ( Di \ DiInjectHintAnnotation $ i ) use ( $ parameter ) { return $ i -> getParameter ( ) === $ parameter -> getName ( ) ; } ) -> getFirst ( ) ; if ( $ hint !== null ) { return $ hint ; } try { if ( $ parameter -> getClass ( ) === null ) { throw new \ InvalidArgumentException ( "Cannot inject constructor-param '{$parameter->getName()}' into {$method->getDeclaringClass()->getName()}. " . 'The parameter does not have a an @Inject hint and it has no type-hint.' ) ; } } catch ( \ ReflectionException $ e ) { } return Di \ Inject \ ByType :: create ( $ parameter -> getName ( ) , Util :: normalizeFqcn ( ( string ) $ parameter -> getType ( ) ) ) ; }
3005	static public function ping ( \ Base $ f3 , $ params ) { $ hash = $ params [ 'hash' ] ; if ( $ f3 -> exists ( 'mailer.on.ping' , $ ping_handler ) ) $ f3 -> call ( $ ping_handler , array ( $ hash ) ) ; $ img = new \ Image ( ) ; $ img -> load ( base64_decode ( 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMA' . 'AAAl21bKAAAABGdBTUEAALGPC/xhBQAAAANQTFRFAAAAp3o92gAAAAF0U' . 'k5TAEDm2GYAAAAKSURBVAjXY2AAAAACAAHiIbwzAAAAAElFTkSuQmCC' ) ) ; $ img -> render ( ) ; }
8927	public function fetch ( $ name ) { $ generator = false ; if ( array_key_exists ( $ name , $ this -> generators ) ) { $ generator = $ this -> generators [ $ name ] ; } return $ generator ; }
4744	public function isReviewOptInError ( ) { $ formSent = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'rvw_oegdproptin' ) !== null ; $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; $ result = false ; if ( $ formSent && ! $ review -> validateOptIn ( ) ) { $ result = true ; } return $ result ; }
4706	public function each ( callable $ callable ) { foreach ( $ this -> objects as $ key => $ value ) { if ( false === call_user_func_array ( $ callable , array ( $ value , $ key ) ) ) { break ; } } return $ this ; }
4239	public function onBootstrap ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ collectWas = $ this -> debug -> setCfg ( 'collect' , true ) ; $ this -> debug -> groupSummary ( ) ; $ this -> debug -> group ( 'environment' , $ this -> debug -> meta ( array ( 'hideIfEmpty' => true , 'level' => 'info' , ) ) ) ; $ this -> logPhpInfo ( ) ; $ this -> logServerVals ( ) ; $ this -> logRequest ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> groupEnd ( ) ; $ this -> debug -> setCfg ( 'collect' , $ collectWas ) ; }
11148	public function getMultipleDisplayObjects ( $ areas ) { $ out = array ( ) ; foreach ( $ areas as $ v ) { if ( ! ( $ v instanceof Neuron_GameServer_Map_Area ) ) { throw new Neuron_Exceptions_InvalidParameter ( "Parameters must be an array of area objects." ) ; } foreach ( $ this -> getDisplayObjects ( $ v ) as $ v ) { if ( ! $ v instanceof Neuron_GameServer_Map_MapObject ) { throw new Neuron_Core_Error ( "All map objects MUST implement Neuron_GameServer_Map_MapObject" ) ; } $ out [ ] = $ v ; } } return $ out ; }
3747	protected function extractSorting ( $ config ) { $ sorting = $ config -> getSorting ( ) ; $ sortBy = key ( $ sorting ) ; $ sortDir = current ( $ sorting ) ? : DCGE :: MODEL_SORTING_ASC ; return array ( $ sortBy , $ sortDir ) ; }
6722	public function fetchAccessToken ( $ code ) { $ this -> validateTokenParams ( ) ; $ this -> oauth2 -> tokenUrl = $ this -> tokenUrl ; $ this -> oauth2 -> clientId = $ this -> clientId ; $ this -> oauth2 -> clientSecret = $ this -> clientSecret ; try { $ response = $ this -> oauth2 -> fetchAccessToken ( $ code ) ; } catch ( Exception $ ex ) { throw new Oauth2ClientException ( $ ex -> getMessage ( ) ) ; } return $ this -> handleTokenResponse ( $ response ) ; }
1087	public static function extractTypes ( $ type , ? array $ typeMap = null ) { if ( ! $ typeMap ) { $ typeMap = [ ] ; } if ( ! $ type ) { return $ typeMap ; } if ( $ type instanceof WrappingType ) { return self :: extractTypes ( $ type -> getWrappedType ( true ) , $ typeMap ) ; } if ( ! $ type instanceof Type ) { $ i = 0 ; $ alreadyInMap = false ; while ( isset ( $ typeMap [ $ i ] ) ) { $ alreadyInMap = $ alreadyInMap || $ typeMap [ $ i ] === $ type ; $ i ++ ; } if ( ! $ alreadyInMap ) { $ typeMap [ $ i ] = $ type ; } return $ typeMap ; } if ( ! empty ( $ typeMap [ $ type -> name ] ) ) { Utils :: invariant ( $ typeMap [ $ type -> name ] === $ type , sprintf ( 'Schema must contain unique named types but contains multiple types named "%s" ' , $ type ) . '(see http://webonyx.github.io/graphql-php/type-system/#type-registry).' ) ; return $ typeMap ; } $ typeMap [ $ type -> name ] = $ type ; $ nestedTypes = [ ] ; if ( $ type instanceof UnionType ) { $ nestedTypes = $ type -> getTypes ( ) ; } if ( $ type instanceof ObjectType ) { $ nestedTypes = array_merge ( $ nestedTypes , $ type -> getInterfaces ( ) ) ; } if ( $ type instanceof ObjectType || $ type instanceof InterfaceType ) { foreach ( $ type -> getFields ( ) as $ fieldName => $ field ) { if ( ! empty ( $ field -> args ) ) { $ fieldArgTypes = array_map ( static function ( FieldArgument $ arg ) { return $ arg -> getType ( ) ; } , $ field -> args ) ; $ nestedTypes = array_merge ( $ nestedTypes , $ fieldArgTypes ) ; } $ nestedTypes [ ] = $ field -> getType ( ) ; } } if ( $ type instanceof InputObjectType ) { foreach ( $ type -> getFields ( ) as $ fieldName => $ field ) { $ nestedTypes [ ] = $ field -> getType ( ) ; } } foreach ( $ nestedTypes as $ nestedType ) { $ typeMap = self :: extractTypes ( $ nestedType , $ typeMap ) ; } return $ typeMap ; }
2209	public function fetchRow ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = array_values ( $ this -> resultSet [ ++ $ this -> intIndex ] ) ; return $ this -> arrCache ; }
7611	public function actionCreate ( ) { $ model = new User ; if ( $ model -> load ( $ _POST ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; } }
10217	public function add ( IComparable $ pSource ) { $ hash = $ pSource -> getHashCode ( ) ; if ( ! isset ( $ this -> items [ $ hash ] ) ) { $ this -> items [ $ hash ] = $ pSource ; $ this -> keyMap [ count ( $ this -> items ) - 1 ] = $ hash ; } }
42	public static function getCertificateNames ( $ certificate ) { if ( is_array ( $ certificate ) ) { $ info = $ certificate ; } elseif ( CaBundle :: isOpensslParseSafe ( ) ) { $ info = openssl_x509_parse ( $ certificate , false ) ; } if ( ! isset ( $ info [ 'subject' ] [ 'commonName' ] ) ) { return null ; } $ commonName = strtolower ( $ info [ 'subject' ] [ 'commonName' ] ) ; $ subjectAltNames = array ( ) ; if ( isset ( $ info [ 'extensions' ] [ 'subjectAltName' ] ) ) { $ subjectAltNames = preg_split ( '{\s*,\s*}' , $ info [ 'extensions' ] [ 'subjectAltName' ] ) ; $ subjectAltNames = array_filter ( array_map ( function ( $ name ) { if ( 0 === strpos ( $ name , 'DNS:' ) ) { return strtolower ( ltrim ( substr ( $ name , 4 ) ) ) ; } return null ; } , $ subjectAltNames ) ) ; $ subjectAltNames = array_values ( $ subjectAltNames ) ; } return array ( 'cn' => $ commonName , 'san' => $ subjectAltNames , ) ; }
10325	protected function setOptions ( array $ options ) { if ( ! array_key_exists ( 'adapter' , $ options ) || ! array_key_exists ( 'table' , $ options ) || ! array_key_exists ( 'column_key' , $ options ) || ! array_key_exists ( 'column_value' , $ options ) ) { throw new Exception \ InvalidArgumentException ( 'Db adapter options must be defined "adapter", "table", "column_key" and "column_value" keys.' ) ; } if ( ! $ options [ 'adapter' ] instanceof Adapter ) { throw new Exception \ InvalidArgumentException ( 'Db adapter must be an instance of Zend\Db\Adapter\Adapter.' ) ; } $ this -> adapter = $ options [ 'adapter' ] ; $ options [ 'table' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'table' ] ) ; $ options [ 'column_key' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'column_key' ] ) ; $ options [ 'column_value' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'column_value' ] ) ; $ this -> options = $ options ; return $ this ; }
1532	protected function deserialize ( array $ document , $ record = null ) : ResourceObject { $ data = $ document [ 'data' ] ?? [ ] ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { throw new \ InvalidArgumentException ( 'Expecting a JSON API document with a data member.' ) ; } return ResourceObject :: create ( $ data ) ; }
8872	private function buildAttachmentPart ( ) { if ( count ( $ this -> attachments ) > 0 ) { $ attachment_part = '' ; foreach ( $ this -> attachments as $ attachment ) { $ file_str = chunk_split ( base64_encode ( file_get_contents ( $ attachment ) ) ) ; $ attachment_part .= "--MIME_BOUNDRY\nContent-Type: " . $ this -> getMimeType ( $ attachment ) . "; name=" . basename ( $ attachment ) . "\nContent-disposition: attachment\nContent-Transfer-Encoding: base64\n\n{$file_str}\n\n" ; } return $ attachment_part ; } }
4977	public function send ( \ Zend \ Mail \ Message $ message ) { $ options = $ this -> options ; $ filename = call_user_func ( $ options -> getCallback ( ) , $ this ) ; $ file = $ options -> getPath ( ) . DIRECTORY_SEPARATOR . $ filename ; $ contents = $ message -> toString ( ) ; $ umask = umask ( ) ; umask ( 022 ) ; if ( false === file_put_contents ( $ file , $ contents , LOCK_EX ) ) { throw new RuntimeException ( sprintf ( 'Unable to write mail to file (directory "%s")' , $ options -> getPath ( ) ) ) ; } umask ( $ umask ) ; $ this -> lastFile = $ file ; }
3914	protected function sortByName ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } \ uasort ( $ arrFiles , ( $ blnAscending ) ? '\basename_natcasecmp' : '\basename_natcasercmp' ) ; return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; }
11045	function read_content ( ) { if ( $ this -> external_source_read ) { $ fct = $ this -> source_read_name ; return $ fct ( $ this -> container ) ; } else { $ content = FALSE ; if ( $ handle = @ fopen ( $ this -> container , 'rb' ) ) { $ size = @ filesize ( $ this -> container ) ; $ content = @ fread ( $ handle , $ size ) ; fclose ( $ handle ) ; } return $ content ; } }
7915	public function registerClientScript ( ) { if ( $ this -> closeIcon !== false ) { $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( "dosamigos.semantic.initMessageCloseButtons();" ) ; } }
1139	public function shiftSiblingsForRestore ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> increment ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>=' , $ lft ) -> increment ( $ rgtCol , $ diff ) ; } ) ; }
8296	public function write ( $ data ) { if ( ! is_string ( $ data ) ) { throw new \ InvalidArgumentException ( "The data is not a string." ) ; } $ this -> open ( ) ; if ( ! ftruncate ( $ this -> handle , 0 ) ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not truncate file " . $ this -> filePath ) ; } fseek ( $ this -> handle , 0 ) ; $ res = fwrite ( $ this -> handle , $ data ) ; if ( strlen ( $ data ) !== $ res ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not write to file " . $ this -> filePath ) ; } }
8635	public function setShipmentFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6273	public static function haveExtension ( ) { if ( ! function_exists ( 'dba_handlers' ) ) { return false ; } $ handlers = dba_handlers ( ) ; if ( ! in_array ( 'cdb' , $ handlers ) || ! in_array ( 'cdb_make' , $ handlers ) ) { return false ; } return true ; }
12249	public function xpathByAttribute ( $ strXpathQuery , $ strIndexAttribute = 'name' ) { $ arrOut = array ( ) ; $ objResult = $ this -> xpath ( $ strXpathQuery ) ; foreach ( $ objResult as $ intIndex => $ objNode ) { $ strIndex = ( string ) $ objNode -> attributes ( ) -> $ strIndexAttribute ; $ arrOut [ $ strIndex ] = $ objResult [ $ intIndex ] ; } return $ arrOut ; }
703	public function parse ( $ rawBody , $ contentType ) { try { $ parameters = Json :: decode ( $ rawBody , $ this -> asArray ) ; return $ parameters === null ? [ ] : $ parameters ; } catch ( InvalidArgumentException $ e ) { if ( $ this -> throwException ) { throw new BadRequestHttpException ( 'Invalid JSON data in request body: ' . $ e -> getMessage ( ) ) ; } return [ ] ; } }
3585	protected function getMetaOperator ( $ method , ArgumentBag $ args ) { if ( $ not = $ args -> get ( 'not' ) ) { $ args -> set ( 'not' , false ) ; } return ( $ not ^ $ this -> isWhereNull ( $ method , $ args ) ) ? '<' : '>=' ; }
10811	protected function bindValues ( $ sql , array $ settings ) { $ bindings = & $ this -> bindings ; $ escape = $ this -> getEscapeCallable ( $ settings [ 'escapeFunction' ] ) ; $ params = $ this -> getBuilder ( ) -> getPlaceholderMapping ( ) ; $ function = function ( $ v ) use ( $ settings , & $ bindings , $ escape ) { if ( $ settings [ 'positionedParam' ] ) { $ bindings [ ] = $ v ; return '?' ; } elseif ( $ settings [ 'namedParam' ] && isset ( $ v [ 0 ] ) && ':' == $ v [ 0 ] ) { return $ v ; } elseif ( is_numeric ( $ v ) && ! is_string ( $ v ) ) { return $ v ; } else { return $ escape ( $ v ) ; } } ; return preg_replace_callback ( '/\b__PH_[0-9]++__\b/' , function ( $ m ) use ( & $ params , $ function ) { return $ function ( $ params [ $ m [ 0 ] ] ) ; } , $ sql ) ; }
11963	private function setParam ( $ key , $ value , $ allowed_keys ) { if ( in_array ( $ key , $ allowed_keys ) ) { $ this -> { $ key } = $ value ; } }
4027	protected function getLabelComment ( ModelInterface $ model , TranslatorInterface $ translator ) { if ( $ model -> getProperty ( 'comment' ) ) { return sprintf ( $ translator -> translate ( 'typedesc._comment_' , 'tl_metamodel_filtersetting' ) , StringUtil :: specialchars ( $ model -> getProperty ( 'comment' ) ) ) ; } return '' ; }
2382	public static function findPublishedByParentAndIdOrAlias ( $ varId , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrColumns [ ] = "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ varId , $ arrOptions ) ; }
4403	public function loadRelatedLayouts ( Location $ location ) { $ query = $ this -> databaseConnection -> createQueryBuilder ( ) ; $ valueColumnName = class_exists ( 'Netgen\BlockManager\Version' ) && Version :: VERSION_ID < 1100 ? 'value_id' : 'value' ; $ query -> select ( 'DISTINCT b.layout_id' ) -> from ( 'ngbm_collection_item' , 'ci' ) -> innerJoin ( 'ci' , 'ngbm_block_collection' , 'bc' , $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> eq ( 'bc.collection_id' , 'ci.collection_id' ) , $ query -> expr ( ) -> eq ( 'bc.collection_status' , 'ci.status' ) ) ) -> innerJoin ( 'bc' , 'ngbm_block' , 'b' , $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> eq ( 'b.id' , 'bc.block_id' ) , $ query -> expr ( ) -> eq ( 'b.status' , 'bc.block_status' ) ) ) -> where ( $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> orX ( $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> eq ( 'ci.value_type' , ':content_value_type' ) , $ query -> expr ( ) -> eq ( 'ci.' . $ valueColumnName , ':content_id' ) ) , $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> eq ( 'ci.value_type' , ':location_value_type' ) , $ query -> expr ( ) -> eq ( 'ci.' . $ valueColumnName , ':location_id' ) ) ) , $ query -> expr ( ) -> eq ( 'ci.status' , ':status' ) ) ) -> setParameter ( 'status' , Value :: STATUS_PUBLISHED , Type :: INTEGER ) -> setParameter ( 'content_value_type' , 'ezcontent' , Type :: STRING ) -> setParameter ( 'location_value_type' , 'ezlocation' , Type :: STRING ) -> setParameter ( 'content_id' , $ location -> contentInfo -> id , Type :: INTEGER ) -> setParameter ( 'location_id' , $ location -> id , Type :: INTEGER ) ; $ relatedLayouts = array_map ( function ( array $ dataRow ) { return $ this -> layoutService -> loadLayout ( $ dataRow [ 'layout_id' ] ) ; } , $ query -> execute ( ) -> fetchAll ( PDO :: FETCH_ASSOC ) ) ; usort ( $ relatedLayouts , function ( Layout $ layout1 , Layout $ layout2 ) { if ( $ layout1 -> getName ( ) === $ layout2 -> getName ( ) ) { return 0 ; } return $ layout1 -> getName ( ) > $ layout2 -> getName ( ) ? 1 : - 1 ; } ) ; return $ relatedLayouts ; }
7856	private function publishConfig ( ) { $ config = __DIR__ . '/config/workflow.php' ; $ this -> publishes ( [ $ config => config_path ( 'workflow.php' ) ] ) ; $ this -> mergeConfigFrom ( $ config , 'workflow' ) ; }
1669	public function delete ( ) { $ this -> Files -> rrdir ( $ this -> strFolder ) ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { Dbafs :: deleteResource ( $ this -> strFolder ) ; } }
4173	public function hasMigrationFile ( ) { $ this -> count = $ this -> fileHas ( '/class [A-Z]\w+ extends Migration/i' ) -> getClasses ( ) -> count ( ) ; return $ this -> hasMigrationFile = $ this -> count > 0 ; }
134	public function isPackageInstalled ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( $ package instanceof AliasPackage ) { return $ repo -> hasPackage ( $ package ) && $ this -> isPackageInstalled ( $ repo , $ package -> getAliasOf ( ) ) ; } return $ this -> getInstaller ( $ package -> getType ( ) ) -> isInstalled ( $ repo , $ package ) ; }
313	public function setRuntimePath ( $ path ) { $ this -> _runtimePath = Yii :: getAlias ( $ path ) ; Yii :: setAlias ( '@runtime' , $ this -> _runtimePath ) ; }
4589	public function setWithVariablesInReturn ( ? bool $ withVariablesInReturn ) { $ this -> withVariablesInReturn = $ withVariablesInReturn ; $ this -> _withVariablesInReturn = null !== $ withVariablesInReturn ; return $ this ; }
7041	protected function setState ( PaymentSubjectInterface $ subject , $ state ) { if ( $ state !== $ subject -> getPaymentState ( ) ) { $ subject -> setPaymentState ( $ state ) ; return true ; } return false ; }
6958	public function setForcedRedirect ( $ url ) { $ data = $ this -> getData ( true ) ; $ data [ static :: $ forcedRedirectKey ] = $ url ; return $ this -> setData ( $ data ) ; }
7987	public function setSnapshotProperties ( $ domain , array $ properties ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ properties || ! is_array ( $ properties ) || count ( $ properties ) == 0 ) throw new BadMethodCallException ( 'Parameter $properties must be a non empty array.' ) ; $ qr = '' ; foreach ( $ properties as $ k => $ v ) { $ qr .= $ k . '=' . $ v . '&' ; } $ qr = substr ( $ qr , 0 , strlen ( $ qr ) - 1 ) ; try { $ r = $ this -> put ( 'vps/' . $ domain . '/snapshot/?' . $ qr ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
498	public function applyTo ( $ path ) { $ pathMap = $ this -> pathMap ; if ( empty ( $ pathMap ) ) { if ( ( $ basePath = $ this -> getBasePath ( ) ) === null ) { throw new InvalidConfigException ( 'The "basePath" property must be set.' ) ; } $ pathMap = [ Yii :: $ app -> getBasePath ( ) => [ $ basePath ] ] ; } $ path = FileHelper :: normalizePath ( $ path ) ; foreach ( $ pathMap as $ from => $ tos ) { $ from = FileHelper :: normalizePath ( Yii :: getAlias ( $ from ) ) . DIRECTORY_SEPARATOR ; if ( strpos ( $ path , $ from ) === 0 ) { $ n = strlen ( $ from ) ; foreach ( ( array ) $ tos as $ to ) { $ to = FileHelper :: normalizePath ( Yii :: getAlias ( $ to ) ) . DIRECTORY_SEPARATOR ; $ file = $ to . substr ( $ path , $ n ) ; if ( is_file ( $ file ) ) { return $ file ; } } } } return $ path ; }
7485	public function charAt ( $ index ) { $ index = ( int ) $ index ; if ( $ index < 0 || $ index >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_substr ( $ this -> string , $ index , 1 , $ this -> encoding ) ; }
11355	public function getValue ( $ name = null ) { if ( $ this -> has ( $ name ) ) { return $ this -> get ( $ name ) -> getValue ( ) ; } return parent :: getValue ( ) ; }
12105	public function exception ( Exception $ exception ) { if ( $ this -> stopPropagation ) { return false ; } $ this -> fireHandlers ( $ exception ) ; $ this -> stopPropagation = true ; return false ; }
790	public function getErrorSummary ( $ showAllErrors ) { $ lines = [ ] ; $ errors = $ showAllErrors ? $ this -> getErrors ( ) : $ this -> getFirstErrors ( ) ; foreach ( $ errors as $ es ) { $ lines = array_merge ( ( array ) $ es , $ lines ) ; } return $ lines ; }
6943	protected function localizedDayOfWeek ( $ dayOfWeek ) { if ( class_exists ( '\IntlDateFormatter' ) ) { $ date = new \ DateTime ( '2017-01-01' ) ; $ date -> modify ( '+' . $ dayOfWeek . ' days' ) ; $ formatter = \ IntlDateFormatter :: create ( $ this -> localeProvider -> getCurrentLocale ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , $ date -> getTimezone ( ) , null , 'eeee' ) ; return $ formatter -> format ( $ date -> getTimestamp ( ) ) ; } return [ 1 => 'Monday' , 2 => 'Tuesday' , 3 => 'Wednesday' , 4 => 'Thursday' , 5 => 'Friday' , 6 => 'Saturday' , 7 => 'Sunday' , ] [ $ dayOfWeek ] ; }
8326	public function sendRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra = [ ] ) { $ this -> getLogger ( ) -> info ( "Try send google key (recaptcha) on {$this->serverBaseUri}/in.php" ) ; if ( $ this -> softId && ! isset ( $ extra [ Extra :: SOFT_ID ] ) ) { $ extra [ Extra :: SOFT_ID ] = $ this -> softId ; } $ response = $ this -> getHttpClient ( ) -> request ( 'POST' , "/in.php" , [ RequestOptions :: QUERY => array_merge ( $ extra , [ 'method' => 'userrecaptcha' , 'key' => $ this -> apiKey , 'googlekey' => $ googleKey , 'pageurl' => $ pageUrl ] ) ] ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( strpos ( $ responseText , 'OK|' ) !== false ) { $ this -> lastCaptchaId = explode ( "|" , $ responseText ) [ 1 ] ; $ this -> getLogger ( ) -> info ( "Sending success. Got captcha id `{$this->lastCaptchaId}`." ) ; return $ this -> lastCaptchaId ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : "Unknown error: `{$responseText}`." ) ; }
8545	public function setGuaranteeClaimEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GuaranteeClaimEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2196	protected function sendAdminNotification ( $ intId , $ arrData ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'adminSubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ strData = "\n\n" ; foreach ( $ arrData as $ k => $ v ) { if ( $ k == 'password' || $ k == 'tstamp' || $ k == 'dateAdded' ) { continue ; } $ v = StringUtil :: deserialize ( $ v ) ; if ( $ k == 'dateOfBirth' && \ strlen ( $ v ) ) { $ v = Date :: parse ( Config :: get ( 'dateFormat' ) , $ v ) ; } $ strData .= $ GLOBALS [ 'TL_LANG' ] [ 'tl_member' ] [ $ k ] [ 0 ] . ': ' . ( \ is_array ( $ v ) ? implode ( ', ' , $ v ) : $ v ) . "\n" ; } $ objEmail -> text = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'adminText' ] , $ intId , $ strData . "\n" ) . "\n" ; $ objEmail -> sendTo ( $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ) ; $ this -> log ( 'A new user (ID ' . $ intId . ') has registered on the website' , __METHOD__ , TL_ACCESS ) ; }
5558	protected function findForm ( $ method , $ attribute ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> findFormInFrame ( $ this -> frames [ $ this -> focus ] , $ this -> focus , $ method , $ attribute ) ; } for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ form = $ this -> findFormInFrame ( $ this -> frames [ $ i ] , $ i , $ method , $ attribute ) ; if ( $ form ) { return $ form ; } } return ; }
892	public function getNormalizedTypes ( ) { $ normalized = array_map ( static function ( $ type ) { return strtolower ( $ type ) ; } , $ this -> getTypes ( ) ) ; sort ( $ normalized ) ; return $ normalized ; }
4400	protected function saveTransationRef ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ baseItem , $ ref ) { $ type = \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT ; $ serviceItem = $ this -> getBasketService ( $ baseItem , $ type , $ this -> getServiceItem ( ) -> getCode ( ) ) ; $ attr = array ( 'TRANSACTIONID' => $ ref ) ; $ this -> setAttributes ( $ serviceItem , $ attr , 'payment/omnipay' ) ; $ this -> saveOrderBase ( $ baseItem ) ; }
9008	private function prepareColumn ( Row $ row ) : string { $ nullable = $ row -> Null === 'YES' ; if ( $ row -> Default === null && ! $ nullable ) { $ default = ' NOT null' ; } elseif ( $ row -> Default === null && $ nullable ) { $ default = ' DEFAULT null' ; } else { $ default = ( $ nullable ? '' : ' NOT null' ) . " DEFAULT '{$row->Default}'" ; } if ( ! empty ( $ row -> Collation ) ) { $ collate = ' COLLATE ' . $ row -> Collation ; } else { $ collate = '' ; } if ( $ row -> Extra === 'auto_increment' ) { $ autoIncrement = ' AUTO_INCREMENT' ; } else { $ autoIncrement = '' ; } return "`{$row->Field}` " . $ row -> Type . $ collate . $ default . $ autoIncrement ; }
11910	public function getDefaultParams ( ) { $ defaultParams = [ ] ; foreach ( $ this -> parameters as $ parameter ) { if ( $ parameter -> hasDefault ( ) ) { if ( $ parameter -> getIsAPIParameter ( ) == false ) { $ defaultParams [ ] = $ parameter ; } } } return $ defaultParams ; }
9723	private function getTemporaryFolder ( ) { $ tempFolder = sys_get_temp_dir ( ) . '/phpspreadsheet' ; if ( ! is_dir ( $ tempFolder ) ) { if ( ! mkdir ( $ tempFolder ) && ! is_dir ( $ tempFolder ) ) { throw new \ RuntimeException ( sprintf ( 'Directory "%s" was not created' , $ tempFolder ) ) ; } } return $ tempFolder ; }
8602	public function deregisterDestination ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_DeregisterDestinationInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationInput.php' ) ; $ request = new MWSSubscriptionsService_Model_DeregisterDestinationInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/DeregisterDestinationResponse.php' ) ; $ response = MWSSubscriptionsService_Model_DeregisterDestinationResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
2715	public function render ( ) { return [ 'id' => $ this -> getId ( ) , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => 1 , 'label' => $ this -> label , 'comment' => $ this -> comment , '_elementType' => 'group' , 'path' => self :: BASE_CONFIG_PATH , 'children' => $ this -> children ] ; }
1651	public function containsGeometry ( GeometryInterface $ geometry ) : bool { $ geometryInPolygon = true ; foreach ( $ geometry -> getPoints ( ) as $ point ) { $ geometryInPolygon = $ geometryInPolygon && $ this -> contains ( $ point ) ; } return $ geometryInPolygon ; }
3195	public function setConsumedExtraTime ( $ time ) { $ this -> consumedExtraTime = max ( $ this -> consumedExtraTime , floatval ( $ time ) ) ; return $ this ; }
10608	public function passwordRecoveredAction ( ) { $ this -> getResponse ( ) -> setStatusCode ( Response :: STATUS_CODE_201 ) ; $ userService = $ this -> getServiceLocator ( ) -> get ( 'user.service.user' ) ; $ id = $ this -> params ( ) -> fromRoute ( 'id' ) ; try { $ userService -> passwordRecovered ( $ id ) ; $ returnData = array ( 'status' => 'success' , 'message' => 'Ti abbiamo inviato un\'email con la nuova password per il tuo account. Se vorrai potrai modificarla una volta connesso.' ) ; } catch ( \ Exception $ e ) { $ this -> getResponse ( ) -> setStatusCode ( Response :: STATUS_CODE_500 ) ; $ returnData = @ unserialize ( $ e -> getMessage ( ) ) ; if ( ! is_array ( $ returnData ) ) { $ returnData = array ( 'status' => 'danger' , 'message' => $ e -> getMessage ( ) ) ; } } return new JsonModel ( $ returnData ) ; }
2155	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objNewsletter = NewsletterChannelModel :: findAll ( ) ; if ( $ objNewsletter !== null ) { while ( $ objNewsletter -> next ( ) ) { if ( ! $ objNewsletter -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objNewsletter -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objNewsletter -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objNewsletter -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objNewsletter -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objNewsletter -> jumpTo ] ; $ objItem = NewsletterModel :: findSentByPid ( $ objNewsletter -> id ) ; if ( $ objItem !== null ) { while ( $ objItem -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItem -> alias ? : $ objItem -> id ) ) ; } } } } return $ arrPages ; }
4092	public function term ( $ term , $ field = false ) { $ this -> term = ( $ field ) ? array ( $ field => $ term ) : $ term ; return $ this ; }
5210	public static function getInstance ( OutputInterface $ output ) { $ questionHelper = new QuestionHelper ( ) ; $ application = new Application ( 'PHP to Zephir Command Line Interface' , 'Beta 0.2.1' ) ; $ application -> getHelperSet ( ) -> set ( new FormatterHelper ( ) , 'formatter' ) ; $ application -> getHelperSet ( ) -> set ( $ questionHelper , 'question' ) ; $ application -> add ( ConvertFactory :: getInstance ( $ output ) ) ; return $ application ; }
12557	private static function init ( ) : void { static $ inited = false ; if ( ! $ inited ) { if ( ! isset ( $ _SESSION [ 'Booby' ] ) || ! $ _SESSION [ 'Booby' ] ) { $ _SESSION [ 'Booby' ] = [ ] ; } self :: $ store = & $ _SESSION [ 'Booby' ] ; $ inited = true ; } }
10779	private function addSessionCookie ( ResponseInterface $ response ) : ResponseInterface { $ params = session_get_cookie_params ( ) ; $ cookie = new SetCookie ( session_name ( ) , session_id ( ) , time ( ) + $ params [ "lifetime" ] , $ params [ "path" ] , $ params [ "domain" ] , $ params [ "secure" ] , $ params [ "httponly" ] ) ; return $ cookie -> addToResponse ( $ response ) ; }
7273	public static function tableName ( ) { $ cc = static :: modelName ( ) ; $ cc [ 0 ] = strtolower ( $ cc [ 0 ] ) ; return preg_replace_callback ( "/[A-Z]/" , function ( $ uppercase ) { return "_" . strtolower ( $ uppercase [ 0 ] ) ; } , $ cc ) . "s" ; }
12586	protected function createCtrl ( ) : AbstractCtrl { $ view = ViewFactory :: createView ( str_replace ( 'action' , '' , $ this -> actionName ) , $ this -> ctrlName ) ; $ componentsRootMap = AppHelper :: getInstance ( ) -> getConfig ( 'componentsRootMap' ) ; if ( ! isset ( $ componentsRootMap [ 'controllers' ] ) ) { throw new Exception ( "The field 'componentsRootMap.controllers' must be " . 'presented in the main configuration file.' ) ; } $ ctrlNamespace = str_replace ( \ DIRECTORY_SEPARATOR , '\\' , $ componentsRootMap [ 'controllers' ] ) ; $ ctrlFullName = $ ctrlNamespace . '\\' . $ this -> ctrlName ; if ( ! is_null ( $ view ) ) { $ layoutName = AppHelper :: getInstance ( ) -> getConfig ( 'defaultLayout' ) ; if ( ! is_null ( $ layoutName ) ) { $ layout = ViewFactory :: createLayout ( $ layoutName , $ view ) ; $ ctrl = new $ ctrlFullName ( $ this -> request , $ layout ) ; } else { $ ctrl = new $ ctrlFullName ( $ this -> request , $ view ) ; } } else { $ ctrl = new $ ctrlFullName ( $ this -> request ) ; } return $ ctrl ; }
6920	static public function validateIdentity ( ExecutionContextInterface $ context , IdentityInterface $ identity , array $ config = [ ] , $ pathPrefix = null ) { $ violationList = $ context -> getValidator ( ) -> validate ( $ identity , [ new Identity ( $ config ) ] ) ; if ( ! empty ( $ pathPrefix ) ) { $ pathPrefix = rtrim ( $ pathPrefix , '.' ) . '.' ; } foreach ( $ violationList as $ violation ) { $ context -> buildViolation ( $ violation -> getMessage ( ) ) -> atPath ( $ pathPrefix . $ violation -> getPropertyPath ( ) ) -> addViolation ( ) ; } }
8660	private function convertGetReportList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetReportRequestIdList ( ) ) { $ reportRequestIdList = $ request -> getReportRequestIdList ( ) ; foreach ( $ reportRequestIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportRequestIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
10434	protected function prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) { return array_merge ( $ serviceConfig , $ typeConfig [ 'config' ] , [ 'entity_class' => $ typeConfig [ 'entity_class' ] , 'document_class' => $ typeConfig [ 'document_class' ] , 'document_type' => $ type , ] ) ; }
8578	public function setItemFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6024	public function setMetadata ( array $ metadata ) { $ this -> metadata = [ ] ; foreach ( $ metadata as $ item ) { $ this -> addMetaData ( $ item ) ; } return $ this ; }
6302	protected function getBar ( $ name = 'default' ) { $ this -> events -> fire ( 'navigation.bar' , [ [ 'name' => $ name ] ] ) ; if ( $ name !== 'default' && ! array_key_exists ( $ name , $ this -> bar ) ) { $ name = 'default' ; } if ( ! array_key_exists ( $ name , $ this -> bar ) ) { $ this -> bar [ $ name ] = [ ] ; } $ nav = $ this -> bar [ $ name ] ; return $ this -> process ( $ nav ) ; }
1708	public static function removeEntry ( $ strUrl ) { $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT id FROM tl_search WHERE url=?" ) -> execute ( $ strUrl ) ; while ( $ objResult -> next ( ) ) { $ objDatabase -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ objDatabase -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } }
6241	protected function normalizePathComponents ( ) : array { $ components = [ ] ; $ keys = array_keys ( $ this -> components ) ; $ positionStart = reset ( $ keys ) ; $ positionEnd = end ( $ keys ) ; foreach ( $ this -> components as $ position => $ component ) { $ path = self :: normalize ( $ component , $ position === $ positionStart , $ position === $ positionEnd ) ; $ path = str_replace ( [ '/' , '\\' , DIRECTORY_SEPARATOR . DIRECTORY_SEPARATOR ] , DIRECTORY_SEPARATOR , $ path ) ; if ( $ position === $ positionStart && $ path === DIRECTORY_SEPARATOR ) { $ components [ ] = DIRECTORY_SEPARATOR ; } elseif ( $ position === $ positionStart ) { $ components [ ] = rtrim ( $ path , DIRECTORY_SEPARATOR ) ; } else { $ components [ ] = trim ( $ path , DIRECTORY_SEPARATOR ) ; } } return $ components ; }
2687	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ configPaths = [ 'geoip_country_mapping' => \ Fastly \ Cdn \ Model \ Config :: XML_FASTLY_GEOIP_COUNTRY_MAPPING ] ; foreach ( $ configPaths as $ path ) { $ magVer = $ this -> productMetadata -> getVersion ( ) ; if ( version_compare ( $ magVer , '2.2' , '<' ) ) { $ output -> writeln ( 'Warning : This function is used for converting serialized data to JSON' . ' (recommended for Magento versions above 2.2)' ) ; } $ oldData = $ this -> scopeConfig -> getValue ( $ path ) ; try { $ oldData = unserialize ( $ oldData ) ; } catch ( \ Exception $ e ) { $ oldData = false ; } if ( $ oldData === false ) { $ output -> writeln ( 'Invalid serialization format, unable to unserialize config data : ' . $ path ) ; return ; } $ oldData = ( is_array ( $ oldData ) ) ? $ oldData : [ ] ; $ newData = json_encode ( $ oldData ) ; if ( false === $ newData ) { throw new \ InvalidArgumentException ( 'Unable to encode data.' ) ; } $ this -> configWriter -> save ( $ path , $ newData ) ; $ this -> cacheManager -> clean ( [ \ Magento \ Framework \ App \ Cache \ Type \ Config :: TYPE_IDENTIFIER ] ) ; $ output -> writeln ( 'Config Cache Flushed' ) ; } }
1246	public static function env ( ) { return function ( ) { $ appId = getenv ( self :: ENV_APP_ID ) ; $ certId = getenv ( self :: ENV_CERT_ID ) ; $ devId = getenv ( self :: ENV_DEV_ID ) ; if ( $ appId && $ certId && $ devId ) { return new Credentials ( $ appId , $ certId , $ devId ) ; } else { return new \ InvalidArgumentException ( 'Could not find environment variable ' . 'credentials in ' . self :: ENV_APP_ID . '/' . self :: ENV_CERT_ID . '/' . self :: ENV_DEV_ID ) ; } } ; }
6685	public function sendFailResponse ( $ data , $ httpStatusCode = 500 ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; \ Yii :: $ app -> response -> setStatusCode ( $ httpStatusCode , $ this -> httpStatuses -> getReasonPhrase ( $ httpStatusCode ) ) ; return [ 'status' => 'fail' , 'data' => $ data ] ; }
6118	public function serverCreate ( array $ properties = array ( ) ) { $ this -> serverListReset ( ) ; $ detail = $ this -> execute ( "servercreate" , $ properties ) -> toList ( ) ; $ server = new Server ( $ this , array ( "virtualserver_id" => intval ( $ detail [ "sid" ] ) ) ) ; Signal :: getInstance ( ) -> emit ( "notifyServercreated" , $ this , $ detail [ "sid" ] ) ; Signal :: getInstance ( ) -> emit ( "notifyTokencreated" , $ server , $ detail [ "token" ] ) ; return $ detail ; }
9878	private function writeWorkbookPr ( XMLWriter $ objWriter ) { $ objWriter -> startElement ( 'workbookPr' ) ; if ( Date :: getExcelCalendar ( ) == Date :: CALENDAR_MAC_1904 ) { $ objWriter -> writeAttribute ( 'date1904' , '1' ) ; } $ objWriter -> writeAttribute ( 'codeName' , 'ThisWorkbook' ) ; $ objWriter -> endElement ( ) ; }
2035	public function onUnregister ( Registry $ registry ) { parent :: onUnregister ( $ registry ) ; if ( $ this -> fallback && $ this -> type == 'root' && $ registry -> isRegisteredAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ) { $ registry -> unregisterAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ; } }
5695	public function nestedFormSave ( $ data , $ form , $ request ) { $ formAction = $ this -> getFormActionFromRequest ( $ request ) ; $ actionName = $ formAction -> getButtonName ( ) ; $ this -> record -> $ actionName ( $ data , $ form , $ request ) ; return Controller :: curr ( ) -> redirectBack ( ) ; }
251	public function removeFlash ( $ key ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; $ value = isset ( $ _SESSION [ $ key ] , $ counters [ $ key ] ) ? $ _SESSION [ $ key ] : null ; unset ( $ counters [ $ key ] , $ _SESSION [ $ key ] ) ; $ _SESSION [ $ this -> flashParam ] = $ counters ; return $ value ; }
4094	public function query ( array $ options = array ( ) ) { if ( ! ( $ this -> query instanceof Query ) ) $ this -> query = new Query ( $ options ) ; return $ this -> query ; }
9493	private function getFolderSize ( $ path ) { $ size = 0 ; foreach ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ path ) ) as $ directory ) { $ size += $ directory -> getSize ( ) ; } return $ size ; }
8233	public function getToken ( $ action = null , $ reuse = true ) { $ tokenStorage = $ this -> session -> get ( self :: SESSION_KEY , [ ] ) ; $ index = ( $ action ) ? $ action : self :: DEFAULT_SELECTOR ; if ( ! isset ( $ tokenStorage [ $ index ] ) ) { $ token = bin2hex ( random_bytes ( self :: TOKEN_SIZE ) ) ; $ tokenStorage [ $ index ] = array ( 'time' => time ( ) , 'token' => $ token ) ; } else { $ token = $ tokenStorage [ $ index ] [ 'token' ] ; $ tokenStorage [ $ index ] [ 'time' ] = time ( ) ; } $ tokenStorage [ $ index ] [ 'reuse' ] = $ reuse ; $ key = bin2hex ( random_bytes ( self :: TOKEN_SIZE ) ) ; $ tokenHMAC = $ this -> tokenHMAC ( $ token , $ key ) ; $ this -> session -> set ( self :: SESSION_KEY , $ tokenStorage ) ; return $ key . self :: TOKEN_DELIMTER . $ tokenHMAC ; }
11	private function mockLocalRepositories ( RepositoryManager $ rm ) { $ packages = array ( ) ; foreach ( $ rm -> getLocalRepository ( ) -> getPackages ( ) as $ package ) { $ packages [ ( string ) $ package ] = clone $ package ; } foreach ( $ packages as $ key => $ package ) { if ( $ package instanceof AliasPackage ) { $ alias = ( string ) $ package -> getAliasOf ( ) ; $ packages [ $ key ] = new AliasPackage ( $ packages [ $ alias ] , $ package -> getVersion ( ) , $ package -> getPrettyVersion ( ) ) ; } } $ rm -> setLocalRepository ( new InstalledArrayRepository ( $ packages ) ) ; }
6297	protected function registerNavigation ( ) { $ this -> app -> singleton ( 'navigation' , function ( $ app ) { $ request = $ app [ 'request' ] ; $ events = $ app [ 'events' ] ; $ url = $ app [ 'url' ] ; $ view = $ app [ 'view' ] ; $ name = 'navigation::bootstrap' ; $ navigation = new Navigation ( $ request , $ events , $ url , $ view , $ name ) ; $ app -> refresh ( 'request' , $ navigation , 'setRequest' ) ; return $ navigation ; } ) ; $ this -> app -> alias ( 'navigation' , Navigation :: class ) ; }
12735	public function setKeyTitle ( $ class , $ column , $ title ) { $ class = ltrim ( $ this -> getClassName ( $ class ) , '\\' ) ; $ this -> manualKeyTitles [ $ class . '|' . $ column ] = $ title ; return $ this ; }
2529	protected function generateGuid ( ) { mt_srand ( ( double ) microtime ( ) * 10000 ) ; $ charId = strtoupper ( md5 ( uniqid ( rand ( ) , true ) ) ) ; $ hyphen = chr ( 45 ) ; $ uuid = substr ( $ charId , 0 , 8 ) . $ hyphen . substr ( $ charId , 8 , 4 ) . $ hyphen . substr ( $ charId , 12 , 4 ) . $ hyphen . substr ( $ charId , 16 , 4 ) . $ hyphen . substr ( $ charId , 20 , 12 ) ; return $ uuid ; }
12675	public function getForeignModel ( $ model ) { $ models = $ this -> foreignModels ; if ( isset ( $ models [ $ model ] ) ) { return $ models [ $ model ] ; } return false ; }
8061	protected function runWorkerProcess ( WorkerInterface $ worker , SimpleSocket $ simpleSocket , $ i ) { $ replacements = array ( 'basename' => basename ( $ _SERVER [ 'PHP_SELF' ] ) , 'fullname' => $ _SERVER [ 'PHP_SELF' ] , 'class' => get_class ( $ worker ) , 'i' => $ i , 'state' => 'free' ) ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; $ this -> worker -> onProcessCreate ( $ this -> semaphore ) ; while ( TRUE ) { $ output = array ( 'pid' => getmypid ( ) ) ; try { $ replacements [ 'state' ] = 'free' ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; $ cmd = $ simpleSocket -> receive ( ) ; if ( ! isset ( $ cmd [ 'cmd' ] ) ) { break ; } $ replacements [ 'state' ] = 'busy' ; ProcessDetails :: setProcessTitle ( $ this -> childProcessTitleFormat , $ replacements ) ; if ( $ cmd [ 'cmd' ] == 'run' ) { try { $ output [ 'data' ] = $ this -> worker -> run ( $ cmd [ 'data' ] ) ; } catch ( \ Exception $ e ) { $ output [ 'workerException' ] = array ( 'class' => get_class ( $ e ) , 'message' => $ e -> getMessage ( ) , 'trace' => $ e -> getTraceAsString ( ) ) ; } $ simpleSocket -> send ( $ output ) ; } elseif ( $ cmd [ 'cmd' ] == 'exit' ) { break ; } } catch ( SimpleSocketException $ e ) { break ; } catch ( \ Exception $ e ) { $ output [ 'poolException' ] = array ( 'class' => get_class ( $ e ) , 'message' => $ e -> getMessage ( ) , 'trace' => $ e -> getTraceAsString ( ) ) ; $ simpleSocket -> send ( $ output ) ; } } $ this -> worker -> onProcessDestroy ( ) ; $ this -> exitPhp ( 0 ) ; }
4068	public function configure ( MetaModelsServiceContainer $ serviceContainer ) { $ serviceContainer -> setEventDispatcher ( function ( ) { return $ this -> container -> get ( 'event_dispatcher' ) ; } ) -> setDatabase ( function ( ) { return $ this -> container -> get ( 'cca.legacy_dic.contao_database_connection' ) ; } ) -> setAttributeFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.attribute_factory' ) ; } ) -> setFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.factory' ) ; } ) -> setFilterFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.filter_setting_factory' ) ; } ) -> setRenderSettingFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.render_setting_factory' ) ; } ) -> setCache ( function ( ) { return $ this -> container -> get ( 'metamodels.cache' ) ; } ) ; return $ serviceContainer ; }
9392	protected function skipRowsClause ( ) { $ skipClause = [ ] ; foreach ( $ this -> skipRows as $ cl => $ val ) { $ skipClause [ ] = [ '<>' , $ cl , $ val ] ; } if ( count ( $ skipClause ) > 1 ) array_unshift ( $ skipClause , 'and' ) ; return $ skipClause ; }
1806	public function setNewPassword ( $ strPassword , $ user ) { if ( ! $ user ) { return $ strPassword ; } $ objUser = $ this -> Database -> prepare ( "SELECT * FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ user -> id ) ; if ( $ objUser -> numRows ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setNewPassword' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setNewPassword' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setNewPassword' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objUser , $ strPassword ) ; } } } return $ strPassword ; }
519	private function findMigrationPath ( $ namespace ) { if ( empty ( $ namespace ) ) { return is_array ( $ this -> migrationPath ) ? reset ( $ this -> migrationPath ) : $ this -> migrationPath ; } if ( ! in_array ( $ namespace , $ this -> migrationNamespaces , true ) ) { throw new Exception ( "Namespace '{$namespace}' not found in `migrationNamespaces`" ) ; } return $ this -> getNamespacePath ( $ namespace ) ; }
2107	public static function findOneByRelatedTableAndId ( $ strTable , $ intId , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using the Contao\OptInModel::findOneByRelatedTableAndIds() method has been deprecated and will no longer work in Contao 5.0. Use the Contao\OptInModel::findByRelatedTableAndIds() method instead.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId=?)" ) -> execute ( $ strTable , $ intId ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { return $ objOptIn ; } return new static ( $ objResult ) ; }
5661	private function attributes ( $ node ) { if ( ! preg_match ( '|<[^ ]+\s(.*?)/?>|s' , $ node -> value , $ first_tag_contents ) ) { return array ( ) ; } $ attributes = array ( ) ; preg_match_all ( '/\S+\s*=\s*\'[^\']*\'|(\S+\s*=\s*"[^"]*")|([^ =]+\s*=\s*[^ "\']+?)|[^ "\']+/' , $ first_tag_contents [ 1 ] , $ matches ) ; foreach ( $ matches [ 0 ] as $ unparsed ) { $ attributes = $ this -> mergeAttribute ( $ attributes , $ unparsed ) ; } return $ attributes ; }
7358	private function loadPriceMap ( ) { if ( null === $ this -> pricesMap ) { $ this -> pricesMap = $ this -> getPricesMapLoader ( ) -> load ( $ this -> currency ) ; } }
3334	private function __initRequest ( $ type , $ data = null ) { $ url = sprintf ( 'https://%s/%s/' , $ this -> host , $ type ) ; if ( is_array ( $ data ) ) { $ url = sprintf ( '%s?%s' , $ url , http_build_query ( $ data ) ) ; } $ ch = curl_init ( $ url ) ; return $ ch ; }
2807	public function purgeProfilesAction ( ) { $ count = $ this -> getService ( ) -> purgeAllProfiles ( ) ; $ this -> getSession ( ) -> addSuccess ( $ this -> __ ( '%d request profiles were deleted' , $ count ) ) ; $ this -> _redirect ( '/' ) ; }
7742	public function supportsOperation ( $ operationName ) { foreach ( $ this -> operations as $ operation ) { if ( $ operation -> getName ( ) === $ operationName ) { return true ; } } return false ; }
3957	public function save ( $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } $ objMetaModel = $ this -> getMetaModel ( ) ; $ objMetaModel -> saveItem ( $ this , $ timestamp ) ; }
6514	public function invoke ( JobInterface $ job , ContextInterface $ context ) { $ jobType = $ this -> registry -> get ( $ job -> getType ( ) ) ; $ callableArray = $ jobType -> getCallable ( ) ; $ parameters = static :: resolveParameters ( $ jobType , $ context , $ job -> getParameters ( ) ) ; if ( is_array ( $ callableArray ) && $ callable = $ callableArray [ 0 ] ) { if ( $ callable instanceof JobAwareInterface ) { $ callable -> setJob ( $ job ) ; } if ( $ callable instanceof ManagerAwareInterface ) { $ callable -> setManager ( $ this -> manager ) ; } if ( $ callable instanceof ControllerAwareInterface ) { $ callable -> setController ( $ this -> controllerFactory -> create ( $ job ) ) ; } if ( $ callable instanceof LoggerAwareInterface && $ context -> has ( 'abc.logger' ) ) { $ callable -> setLogger ( $ context -> get ( 'abc.logger' ) ) ; } } return call_user_func_array ( $ callableArray , $ parameters ) ; }
20	protected function propagate ( $ level ) { while ( $ this -> decisions -> validOffset ( $ this -> propagateIndex ) ) { $ decision = $ this -> decisions -> atOffset ( $ this -> propagateIndex ) ; $ conflict = $ this -> watchGraph -> propagateLiteral ( $ decision [ Decisions :: DECISION_LITERAL ] , $ level , $ this -> decisions ) ; $ this -> propagateIndex ++ ; if ( $ conflict ) { return $ conflict ; } } return null ; }
1690	protected function writeStyleSheet ( $ row ) { if ( $ row [ 'id' ] == '' || $ row [ 'name' ] == '' ) { return ; } $ row [ 'name' ] = basename ( $ row [ 'name' ] ) ; if ( file_exists ( $ this -> strRootDir . '/assets/css/' . $ row [ 'name' ] . '.css' ) && ! $ this -> Files -> is_writeable ( 'assets/css/' . $ row [ 'name' ] . '.css' ) ) { Message :: addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'notWriteable' ] , 'assets/css/' . $ row [ 'name' ] . '.css' ) ) ; return ; } $ vars = array ( ) ; $ objTheme = $ this -> Database -> prepare ( "SELECT vars FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ row [ 'pid' ] ) ; if ( $ objTheme -> vars != '' ) { if ( \ is_array ( ( $ tmp = StringUtil :: deserialize ( $ objTheme -> vars ) ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } if ( $ row [ 'vars' ] != '' ) { if ( \ is_array ( $ tmp = StringUtil :: deserialize ( $ row [ 'vars' ] ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } uksort ( $ vars , 'length_sort_desc' ) ; $ objFile = new File ( 'assets/css/' . $ row [ 'name' ] . '.css' ) ; $ objFile -> write ( '/* ' . $ row [ 'name' ] . ".css */\n" ) ; $ objDefinitions = $ this -> Database -> prepare ( "SELECT * FROM tl_style WHERE pid=? AND invisible!='1' ORDER BY sorting" ) -> execute ( $ row [ 'id' ] ) ; while ( $ objDefinitions -> next ( ) ) { $ objFile -> append ( $ this -> compileDefinition ( $ objDefinitions -> row ( ) , true , $ vars , $ row ) , '' ) ; } $ objFile -> close ( ) ; }
871	public static function getDisplayableAllowedValues ( FixerOptionInterface $ option ) { $ allowed = $ option -> getAllowedValues ( ) ; if ( null !== $ allowed ) { $ allowed = array_filter ( $ allowed , static function ( $ value ) { return ! ( $ value instanceof \ Closure ) ; } ) ; usort ( $ allowed , static function ( $ valueA , $ valueB ) { if ( $ valueA instanceof AllowedValueSubset ) { return - 1 ; } if ( $ valueB instanceof AllowedValueSubset ) { return 1 ; } return strcasecmp ( self :: toString ( $ valueA ) , self :: toString ( $ valueB ) ) ; } ) ; if ( 0 === \ count ( $ allowed ) ) { $ allowed = null ; } } return $ allowed ; }
10132	private function writePassword ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) || ! $ this -> phpSheet -> getProtection ( ) -> getPassword ( ) ) { return ; } $ record = 0x0013 ; $ length = 0x0002 ; $ wPassword = hexdec ( $ this -> phpSheet -> getProtection ( ) -> getPassword ( ) ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ wPassword ) ; $ this -> append ( $ header . $ data ) ; }
12339	private function getColoredMsg ( string $ msg , ? string $ fontColor , ? string $ bgColor ) : string { $ res = '' ; if ( ! is_null ( $ fontColor ) ) { $ res .= "\033[{$fontColor}m" ; } if ( ! is_null ( $ bgColor ) ) { $ res .= "\033[{$bgColor}m" ; } if ( ! is_null ( $ fontColor ) || ! is_null ( $ bgColor ) ) { return "{$res}{$msg}\033[0m" ; } return $ msg ; }
356	public function init ( ) { parent :: init ( ) ; if ( $ this -> enableCoreCommands ) { foreach ( $ this -> coreCommands ( ) as $ id => $ command ) { if ( ! isset ( $ this -> controllerMap [ $ id ] ) ) { $ this -> controllerMap [ $ id ] = $ command ; } } } if ( ! isset ( $ this -> controllerMap [ 'help' ] ) ) { $ this -> controllerMap [ 'help' ] = 'yii\console\controllers\HelpController' ; } }
412	public function getPort ( ) { if ( $ this -> _port === null ) { $ serverPort = $ this -> getServerPort ( ) ; $ this -> _port = ! $ this -> getIsSecureConnection ( ) && $ serverPort !== null ? $ serverPort : 80 ; } return $ this -> _port ; }
1364	public function register ( ) { $ this -> bindNeomerx ( ) ; $ this -> bindService ( ) ; $ this -> bindInboundRequest ( ) ; $ this -> bindRouteRegistrar ( ) ; $ this -> bindApiRepository ( ) ; $ this -> bindExceptionParser ( ) ; $ this -> bindRenderer ( ) ; $ this -> mergePackageConfig ( ) ; }
12263	public function renderCustomField ( array $ fields , $ classOrCustomField , $ documentType = 'html' , $ slug = null , $ showIfEmpty = true ) { $ customField = ( $ classOrCustomField instanceof CustomField ) ? $ classOrCustomField : $ this -> getCustomField ( $ classOrCustomField , $ slug ) ; $ slug = $ customField -> getSlug ( ) ; $ rawValue = ( isset ( $ fields [ $ slug ] ) ) ? $ fields [ $ slug ] : null ; $ customFieldType = $ this -> provider -> getCustomFieldByType ( $ customField -> getType ( ) ) ; return $ customFieldType -> render ( $ rawValue , $ customField , $ documentType ) ; }
10385	protected static function unify_params ( $ type , $ field , $ default = '' ) { $ data = array_column ( self :: $ data [ $ type ] , $ field ) ; switch ( $ field ) { case 'media' : case 'footer' : case 'version' : foreach ( $ data as $ key => $ value ) { if ( $ data [ 0 ] !== $ value ) { return $ default ; } } return ( isset ( $ data [ 0 ] ) && $ data [ 0 ] ) ? $ data [ 0 ] : $ default ; default : $ params = [ ] ; foreach ( $ data as $ key => $ value ) { $ params = array_merge ( $ params , $ value ) ; } return array_unique ( $ params ) ; } }
7011	private function formatS ( & $ str ) { if ( strstr ( $ str , '%S' ) ) $ str = str_replace ( '%S' , static :: ordinal ( $ this -> day ) , $ str ) ; }
1247	public static function ini ( $ profile = null , $ filename = null ) { $ filename = $ filename ? : ( self :: getHomeDir ( ) . '/.ebay_sdk/credentials' ) ; $ profile = $ profile ? : ( getenv ( self :: ENV_PROFILE ) ? : 'default' ) ; return function ( ) use ( $ filename , $ profile ) { if ( ! is_readable ( $ filename ) ) { return new \ InvalidArgumentException ( "Cannot read credentials from $filename" ) ; } $ data = parse_ini_file ( $ filename , true ) ; if ( $ data === false ) { return new \ InvalidArgumentException ( "Invalid credentials file $filename" ) ; } if ( ! isset ( $ data [ $ profile ] ) ) { return new \ InvalidArgumentException ( "'$profile' not found in credentials file" ) ; } if ( ! isset ( $ data [ $ profile ] [ 'ebay_app_id' ] ) || ! isset ( $ data [ $ profile ] [ 'ebay_cert_id' ] ) || ! isset ( $ data [ $ profile ] [ 'ebay_dev_id' ] ) ) { return new \ InvalidArgumentException ( "No credentials present in INI profile '$profile' ($filename)" ) ; } return new Credentials ( $ data [ $ profile ] [ 'ebay_app_id' ] , $ data [ $ profile ] [ 'ebay_cert_id' ] , $ data [ $ profile ] [ 'ebay_dev_id' ] ) ; } ; }
7005	private function format_d ( & $ str ) { if ( strstr ( $ str , '%d' ) ) $ str = str_replace ( '%d' , sprintf ( '%02d' , $ this -> day ) , $ str ) ; }
10612	public function confirmedAction ( ) { $ user = $ this -> getUser ( ) ; if ( ! is_object ( $ user ) || ! $ user instanceof UserInterface ) { throw $ this -> createAccessDeniedException ( 'This user does not have access to this section.' ) ; } return $ this -> render ( "@MikyUser/Frontend/Registration/confirmed.html.twig" , array ( 'user' => $ user , ) ) ; }
9092	public function putPagePartial ( $ page , $ partial ) { if ( null === $ partial || is_string ( $ partial ) || is_array ( $ partial ) ) { $ this -> pagePartials [ $ page ] = $ partial ; } return $ this ; }
9543	public function getMessages ( ) { $ messages = array ( ) ; if ( ! empty ( $ this -> error ) ) { $ messages [ ] = $ this -> error ; } if ( ! empty ( $ this -> warning ) ) { $ messages [ ] = $ this -> warning ; } return $ messages ; }
6148	public function setBody ( $ body ) { if ( is_string ( $ body ) ) { $ this -> body = $ body ; } elseif ( is_array ( $ body ) ) { $ this -> setJsonBody ( $ body ) ; } elseif ( is_callable ( $ body ) ) { ob_start ( ) ; $ res1 = call_user_func ( $ body ) ; $ res2 = ob_get_contents ( ) ; $ this -> body = $ res2 . $ res1 ; ob_end_clean ( ) ; } return $ this ; }
3175	private function getItemLabel ( RunnerServiceContext $ context , $ itemUri , $ useTitle = false ) { $ label = '' ; if ( $ useTitle ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'title' ) ; } if ( ! $ label ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'label' ) ; } if ( ! $ label ) { $ item = new \ core_kernel_classes_Resource ( $ itemUri ) ; $ label = $ item -> getLabel ( ) ; } return $ label ; }
778	public static function checkRequirements ( ) { if ( extension_loaded ( 'imagick' ) ) { $ imagickFormats = ( new \ Imagick ( ) ) -> queryFormats ( 'PNG' ) ; if ( in_array ( 'PNG' , $ imagickFormats , true ) ) { return 'imagick' ; } } if ( extension_loaded ( 'gd' ) ) { $ gdInfo = gd_info ( ) ; if ( ! empty ( $ gdInfo [ 'FreeType Support' ] ) ) { return 'gd' ; } } throw new InvalidConfigException ( 'Either GD PHP extension with FreeType support or ImageMagick PHP extension with PNG support is required.' ) ; }
4170	public function prettify ( Collection $ packages ) { $ summary = [ ] ; foreach ( $ packages as $ key => $ package ) { $ summary [ ] = [ 'id' => $ key + 1 , 'name' => $ this -> prettifyPackageInfo ( $ package ) , ] ; } return $ packages [ $ this -> askPackageKey ( $ summary ) ] [ 'name' ] ; }
5391	public function getValue ( ) { $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ widgets [ $ i ] -> getValue ( ) !== false ) { return $ widgets [ $ i ] -> getValue ( ) ; } } return false ; }
11241	public function rule ( $ fieldName , $ checks , $ humanName = false ) { $ checkFailures = 0 ; if ( $ humanName == false ) { $ humanName = ucfirst ( $ fieldName ) ; } $ fieldData = $ this -> getValue ( $ fieldName ) ; if ( ! is_array ( $ checks ) ) { $ checks = explode ( '|' , $ checks ) ; } foreach ( $ checks as $ check ) { $ checkName = $ check ; if ( isset ( $ this -> customChecks -> $ check ) ) { $ customCheckDef = $ this -> customChecks -> $ check ; $ customType = $ customCheckDef [ 0 ] ; $ arguments = array ( $ fieldData , $ customCheckDef [ 1 ] , $ customCheckDef [ 2 ] , $ customCheckDef [ 3 ] , $ customCheckDef [ 4 ] ) ; $ checkResult = call_user_func_array ( array ( $ this , $ customType ) , $ arguments ) ; } else { $ checkArgs = explode ( '[' , $ check , 2 ) ; if ( count ( $ checkArgs ) > 1 ) { $ check = $ checkArgs [ 0 ] ; $ checkName = $ checkArgs [ 0 ] ; $ checkArgs [ 1 ] = '[' . $ checkArgs [ 1 ] ; $ args = array ( ) ; preg_match_all ( "/\[([^\]]*)\]/" , $ checkArgs [ 1 ] , $ args ) ; $ this -> matchedArg = $ args [ 1 ] [ 0 ] ; $ check = '_' . $ checkName ; $ checkResult = $ this -> $ check ( $ fieldData , $ args [ 1 ] ) ; } else { $ check = '_' . $ checkName ; $ checkResult = $ this -> $ check ( $ fieldData ) ; } } if ( $ checkResult == false ) { $ this -> errors [ ] = sprintf ( $ this -> lang -> $ checkName , $ humanName , $ this -> matchedArg ) ; $ this -> matchedArg = false ; $ checkFailures ++ ; } } return $ checkFailures == 0 ? true : false ; }
401	public static function processParagraph ( $ markdown , $ flavor = null ) { $ parser = static :: getParser ( $ flavor ) ; return $ parser -> parseParagraph ( $ markdown ) ; }
2039	private function createConfig ( $ size ) : array { if ( ! \ is_array ( $ size ) ) { $ size = [ 0 , 0 , $ size ] ; } $ config = new PictureConfiguration ( ) ; $ attributes = [ ] ; if ( ! isset ( $ size [ 2 ] ) || ! is_numeric ( $ size [ 2 ] ) ) { $ resizeConfig = new ResizeConfiguration ( ) ; if ( ! empty ( $ size [ 0 ] ) ) { $ resizeConfig -> setWidth ( ( int ) $ size [ 0 ] ) ; } if ( ! empty ( $ size [ 1 ] ) ) { $ resizeConfig -> setHeight ( ( int ) $ size [ 1 ] ) ; } if ( ! empty ( $ size [ 2 ] ) ) { $ resizeConfig -> setMode ( $ size [ 2 ] ) ; } $ configItem = new PictureConfigurationItem ( ) ; $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( $ this -> defaultDensities ) { $ configItem -> setDensities ( $ this -> defaultDensities ) ; } $ config -> setSize ( $ configItem ) ; return [ $ config , $ attributes ] ; } $ imageSizeModel = $ this -> framework -> getAdapter ( ImageSizeModel :: class ) ; $ imageSizes = $ imageSizeModel -> findByPk ( $ size [ 2 ] ) ; $ config -> setSize ( $ this -> createConfigItem ( $ imageSizes ) ) ; if ( $ imageSizes && $ imageSizes -> cssClass ) { $ attributes [ 'class' ] = $ imageSizes -> cssClass ; } $ imageSizeItemModel = $ this -> framework -> getAdapter ( ImageSizeItemModel :: class ) ; $ imageSizeItems = $ imageSizeItemModel -> findVisibleByPid ( $ size [ 2 ] , [ 'order' => 'sorting ASC' ] ) ; if ( null !== $ imageSizeItems ) { $ configItems = [ ] ; foreach ( $ imageSizeItems as $ imageSizeItem ) { $ configItems [ ] = $ this -> createConfigItem ( $ imageSizeItem ) ; } $ config -> setSizeItems ( $ configItems ) ; } return [ $ config , $ attributes ] ; }
2952	protected function prepareTemplate ( $ templateTxt ) { $ patterns = [ '/\\\{%(.*)%\\\}/U' , '/\s+/' , ] ; $ replacements = [ '(?<$1>.*)' , ' ' , ] ; $ templateTxt = preg_replace ( $ patterns , $ replacements , preg_quote ( $ templateTxt , '/' ) ) ; return trim ( $ templateTxt ) ; }
10429	private function initSyncStorageForMysql ( ContainerBuilder $ container , array $ config ) { $ doctrineConnection = sprintf ( 'doctrine.dbal.%s_connection' , $ config [ 'connection' ] ) ; $ definition = $ container -> getDefinition ( 'ongr_connections.sync.storage_manager.mysql_storage_manager' ) ; $ definition -> setArguments ( [ new Reference ( $ doctrineConnection , ContainerInterface :: IGNORE_ON_INVALID_REFERENCE ) , $ config [ 'table_name' ] , ] ) ; $ definition -> addMethodCall ( 'setContainer' , [ new Reference ( 'service_container' ) ] ) ; $ container -> getDefinition ( 'ongr_connections.sync.sync_storage' ) -> setArguments ( [ $ definition ] ) ; }
12958	public function inject ( ... $ injects ) : void { $ container = new Container ; $ requested = [ ] ; foreach ( $ injects as $ inject ) { if ( is_string ( $ inject ) ) { $ requested [ ] = $ inject ; } elseif ( is_callable ( $ inject ) ) { $ reflection = new ReflectionFunction ( $ inject ) ; foreach ( $ reflection -> getParameters ( ) as $ param ) { $ requested [ ] = $ param -> name ; } } } foreach ( $ requested as $ dependency ) { $ this -> $ dependency = $ container -> get ( $ dependency ) ; } }
4200	private function addMethods ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( ! $ abs [ 'collectMethods' ] ) { $ this -> addMethodsMin ( $ abs ) ; return ; } if ( $ this -> abstracter -> getCfg ( 'cacheMethods' ) && isset ( static :: $ methodCache [ $ abs [ 'className' ] ] ) ) { $ abs [ 'methods' ] = static :: $ methodCache [ $ abs [ 'className' ] ] ; } else { $ methodArray = array ( ) ; $ methods = $ abs [ 'reflector' ] -> getMethods ( ) ; $ interfaceMethods = array ( 'ArrayAccess' => array ( 'offsetExists' , 'offsetGet' , 'offsetSet' , 'offsetUnset' ) , 'Countable' => array ( 'count' ) , 'Iterator' => array ( 'current' , 'key' , 'next' , 'rewind' , 'void' ) , 'IteratorAggregate' => array ( 'getIterator' ) , ) ; $ interfacesHide = \ array_intersect ( $ abs [ 'implements' ] , \ array_keys ( $ interfaceMethods ) ) ; foreach ( $ methods as $ reflectionMethod ) { $ info = $ this -> methodInfo ( $ obj , $ reflectionMethod ) ; $ methodName = $ reflectionMethod -> getName ( ) ; if ( $ info [ 'visibility' ] === 'private' && $ info [ 'inheritedFrom' ] ) { continue ; } foreach ( $ interfacesHide as $ interface ) { if ( \ in_array ( $ methodName , $ interfaceMethods [ $ interface ] ) ) { $ info [ 'implements' ] = $ interface ; break ; } } $ methodArray [ $ methodName ] = $ info ; } $ abs [ 'methods' ] = $ methodArray ; $ this -> addMethodsPhpDoc ( $ abs ) ; static :: $ methodCache [ $ abs [ 'className' ] ] = $ abs [ 'methods' ] ; } if ( isset ( $ abs [ 'methods' ] [ '__toString' ] ) ) { $ abs [ 'methods' ] [ '__toString' ] [ 'returnValue' ] = $ obj -> __toString ( ) ; } return ; }
370	protected function isEmpty ( $ value ) { return $ value === '' || $ value === [ ] || $ value === null || is_string ( $ value ) && trim ( $ value ) === '' ; }
3440	public function saveProps ( $ selected = [ ] ) { $ propertyValues = $ this -> constructPropertyValuesForSave ( $ selected ) ; if ( empty ( $ propertyValues ) ) { return false ; } $ bxMethod = empty ( $ selected ) ? 'setPropertyValues' : 'setPropertyValuesEx' ; static :: $ bxObject -> $ bxMethod ( $ this -> id , static :: iblockId ( ) , $ propertyValues ) ; return true ; }
4555	protected function addJoinTranslation ( QueryBuilder $ queryBuilder , string $ resourceClass ) { $ rootAlias = $ queryBuilder -> getRootAliases ( ) [ 0 ] ; $ translationAlias = $ rootAlias . '_t' ; $ translationClass = call_user_func ( $ resourceClass . '::getTranslationEntityClass' ) ; $ parts = $ queryBuilder -> getDQLParts ( ) [ 'join' ] ; foreach ( $ parts as $ joins ) { foreach ( $ joins as $ join ) { if ( $ translationAlias === $ join -> getAlias ( ) ) { return $ translationAlias ; } } } $ queryBuilder -> leftJoin ( $ translationClass , $ translationAlias , Join :: WITH , $ rootAlias . '.id = ' . $ translationAlias . '.translatable' ) ; return $ translationAlias ; }
5136	public static function handleShutdown ( ) { if ( ! empty ( $ error = error_get_last ( ) ) ) { self :: handleException ( new FatalException ( $ error [ 'message' ] , $ error [ 'type' ] , 0 , $ error [ 'file' ] , $ error [ 'line' ] ) ) ; } }
12967	public function getObjectType ( ) { if ( is_null ( $ this -> _objectType ) && isset ( $ this -> object ) ) { $ this -> _objectType = $ this -> object -> objectType -> systemId ; } return $ this -> _objectType ; }
6151	public function redirect ( string $ url ) : object { $ this -> addHeader ( "Location: " . $ url ) ; $ this -> body = null ; return $ this ; }
10774	protected function loginByCookie ( ) { $ value = Yii :: $ app -> getRequest ( ) -> getCookies ( ) -> getValue ( $ this -> identityCookie [ 'name' ] ) ; if ( $ value === null ) { return ; } $ data = json_decode ( $ value , true ) ; if ( count ( $ data ) !== 3 || ! isset ( $ data [ 0 ] , $ data [ 1 ] , $ data [ 2 ] ) ) { return ; } list ( $ id , $ authKey , $ duration ) = $ data ; $ class = $ this -> identityClass ; $ identity = $ class :: findIdentity ( $ id ) ; if ( $ identity === null ) { return ; } elseif ( ! $ identity instanceof IdentityInterface ) { throw new InvalidValueException ( "$class::findIdentity() must return an object implementing IdentityInterface." ) ; } if ( $ identity -> validateAuthKey ( $ authKey ) ) { if ( $ this -> beforeLogin ( $ identity , true , $ duration ) ) { $ this -> switchIdentity ( $ identity , $ this -> autoRenewCookie ? $ duration : 0 ) ; $ ip = Yii :: $ app -> getRequest ( ) -> getUserIP ( ) ; Yii :: info ( "User '$id' logged in from $ip via cookie." , __METHOD__ ) ; $ this -> afterLogin ( $ identity , true , $ duration ) ; } } else { Yii :: warning ( "Invalid auth key attempted for user '$id': $authKey" , __METHOD__ ) ; } }
3766	private function addInputScreenTranslations ( StaticTranslator $ translator , $ inputScreen , $ containerName ) { $ currentLocale = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ inputScreen [ 'legends' ] as $ legendName => $ legendInfo ) { foreach ( $ legendInfo [ 'label' ] as $ langCode => $ label ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName , $ langCode ) ; if ( $ currentLocale === $ langCode ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName ) ; } } } }
12005	public function archive ( $ sourceDir , array $ options , $ username , $ block ) { $ this -> resolveOptions ( $ options ) ; $ block = json_decode ( $ block , true ) ; $ block [ "history" ] = array ( ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ historyDirName = sprintf ( '%s/archive/%s' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ historyFileName = $ historyDirName . '/history.json' ; if ( ! is_dir ( $ historyDirName ) ) { mkdir ( $ historyDirName ) ; } $ history = array ( ) ; if ( file_exists ( $ historyFileName ) ) { $ history = json_decode ( file_get_contents ( $ historyFileName ) , true ) ; } $ history = array_merge ( $ history , array ( $ block [ "history_name" ] => $ block ) ) ; FilesystemTools :: writeFile ( $ historyFileName , json_encode ( $ history ) ) ; }
2930	public function getValue ( $ key ) { $ allKeys = $ this -> getKeys ( [ $ key ] ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return $ allKeys [ $ key ] [ 'value' ] ; } throw new KeyNotFoundException ( 'Requested key not found in your file.' ) ; }
8646	private function getDefaultCurlOptions ( ) { return array ( CURLOPT_POST => true , CURLOPT_USERAGENT => $ this -> config [ 'UserAgent' ] , CURLOPT_VERBOSE => false , CURLOPT_HEADERFUNCTION => array ( $ this , 'headerCallback' ) , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_SSL_VERIFYHOST => 2 ) ; }
553	public function actionFlushSchema ( $ db = 'db' ) { $ connection = Yii :: $ app -> get ( $ db , false ) ; if ( $ connection === null ) { $ this -> stdout ( "Unknown component \"$db\".\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } if ( ! $ connection instanceof \ yii \ db \ Connection ) { $ this -> stdout ( "\"$db\" component doesn't inherit \\yii\\db\\Connection.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } elseif ( ! $ this -> confirm ( "Flush cache schema for \"$db\" connection?" ) ) { return ExitCode :: OK ; } try { $ schema = $ connection -> getSchema ( ) ; $ schema -> refresh ( ) ; $ this -> stdout ( "Schema cache for component \"$db\", was flushed.\n\n" , Console :: FG_GREEN ) ; } catch ( \ Exception $ e ) { $ this -> stdout ( $ e -> getMessage ( ) . "\n\n" , Console :: FG_RED ) ; } }
10029	function getContactsByFilterId ( $ filterId , $ page_index = 1 , $ page_size = 100 , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'page_index' => $ page_index , 'page_size' => $ page_size , 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/filter/' . utf8_encode ( $ filterId ) , $ queryParameters ) ; }
2454	public function showAll ( ) { $ return = '' ; $ this -> limit = '' ; $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ undoPeriod = ( int ) Config :: get ( 'undoPeriod' ) ; $ logPeriod = ( int ) Config :: get ( 'logPeriod' ) ; if ( $ this -> strTable == 'tl_undo' && $ undoPeriod > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_undo WHERE tstamp<?" ) -> execute ( time ( ) - $ undoPeriod ) ; } elseif ( $ this -> strTable == 'tl_log' && $ logPeriod > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_log WHERE tstamp<?" ) -> execute ( time ( ) - $ logPeriod ) ; } $ this -> reviseTable ( ) ; if ( Input :: get ( 'act' ) == 'paste' ) { $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; $ arrClipboard [ $ this -> strTable ] = array ( 'id' => Input :: get ( 'id' ) , 'childs' => Input :: get ( 'childs' ) , 'mode' => Input :: get ( 'mode' ) ) ; $ objSession -> set ( 'CLIPBOARD' , $ arrClipboard ) ; } if ( ! empty ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'filter' ] ) && \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'filter' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'filter' ] as $ filter ) { $ this -> procedure [ ] = $ filter [ 0 ] ; $ this -> values [ ] = $ filter [ 1 ] ; } } if ( $ this -> treeView ) { $ return .= $ this -> panel ( ) ; $ return .= $ this -> treeView ( ) ; } else { if ( Input :: get ( 'table' ) && $ this -> ptable && $ this -> Database -> fieldExists ( 'pid' , $ this -> strTable ) ) { $ this -> procedure [ ] = 'pid=?' ; $ this -> values [ ] = CURRENT_ID ; } $ return .= $ this -> panel ( ) ; $ return .= ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 4 ) ? $ this -> parentView ( ) : $ this -> listView ( ) ; if ( strpos ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'panelLayout' ] , 'limit' ) !== false ) { $ return .= $ this -> paginationMenu ( ) ; } } return $ return ; }
4162	public function searchMedia ( $ lat , $ lng , $ distance = 1000 , $ minTimestamp = NULL , $ maxTimestamp = NULL ) { return $ this -> _makeCall ( 'media/search' , array ( 'lat' => $ lat , 'lng' => $ lng , 'distance' => $ distance , 'min_timestamp' => $ minTimestamp , 'max_timestamp' => $ maxTimestamp ) ) ; }
6864	protected function updateTotals ( InvoiceInterface $ invoice ) { $ changed = $ this -> invoiceCalculator -> calculate ( $ invoice ) ; if ( $ changed ) { foreach ( $ invoice -> getLines ( ) as $ line ) { $ this -> persistenceHelper -> persistAndRecompute ( $ line , false ) ; } } return $ changed ; }
3013	public function like ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/like' , $ options , false ) ; }
10586	protected static function registerEntity ( entity \ EntityInterface $ entity ) { if ( count ( self :: $ entities ) === 0 ) { register_shutdown_function ( "sndsgd\\fs\\Temp::cleanup" ) ; } self :: $ entities [ $ entity -> getPath ( ) ] = $ entity ; }
9879	private function writeBookViews ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ objWriter -> startElement ( 'bookViews' ) ; $ objWriter -> startElement ( 'workbookView' ) ; $ objWriter -> writeAttribute ( 'activeTab' , $ spreadsheet -> getActiveSheetIndex ( ) ) ; $ objWriter -> writeAttribute ( 'autoFilterDateGrouping' , '1' ) ; $ objWriter -> writeAttribute ( 'firstSheet' , '0' ) ; $ objWriter -> writeAttribute ( 'minimized' , '0' ) ; $ objWriter -> writeAttribute ( 'showHorizontalScroll' , '1' ) ; $ objWriter -> writeAttribute ( 'showSheetTabs' , '1' ) ; $ objWriter -> writeAttribute ( 'showVerticalScroll' , '1' ) ; $ objWriter -> writeAttribute ( 'tabRatio' , '600' ) ; $ objWriter -> writeAttribute ( 'visibility' , 'visible' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
5354	public function getAuthenticationData ( $ method ) { if ( ! $ this -> supportsAuthentication ( $ method ) ) { return null ; } $ authentication = $ this -> getSupportedAuthentication ( ) ; return $ authentication [ $ method ] ; }
1641	protected function setupSessionTracking ( Client $ client , $ endpoint , $ events ) { $ client -> setAutoCaptureSessions ( true ) ; if ( ! is_null ( $ endpoint ) ) { $ client -> setSessionEndpoint ( $ endpoint ) ; } $ sessionTracker = $ client -> getSessionTracker ( ) ; $ sessionStorage = function ( $ session = null ) { if ( is_null ( $ session ) ) { return session ( 'bugsnag-session' , [ ] ) ; } else { session ( [ 'bugsnag-session' => $ session ] ) ; } } ; $ sessionTracker -> setSessionFunction ( $ sessionStorage ) ; $ cache = $ this -> app -> cache ; $ genericStorage = function ( $ key , $ value = null ) use ( $ cache ) { if ( is_null ( $ value ) ) { return $ cache -> get ( $ key , null ) ; } else { $ cache -> put ( $ key , $ value , 60 ) ; } } ; $ sessionTracker -> setStorageFunction ( $ genericStorage ) ; }
3219	function getDelta ( $ cursor = null , $ pathPrefix = null ) { Checker :: argStringNonEmptyOrNull ( "cursor" , $ cursor ) ; Path :: checkArgOrNull ( "pathPrefix" , $ pathPrefix ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/delta" , array ( "cursor" => $ cursor , "path_prefix" => $ pathPrefix ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
5007	private function init ( $ name ) { if ( null === $ name ) { $ name = $ this -> default ; } if ( ! isset ( static :: $ orderMap [ $ name ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Unknown status name "%s" for "%s"' , $ name , static :: class ) ) ; } $ this -> name = $ name ; $ this -> order = static :: $ orderMap [ $ name ] ; }
759	public function setChildren ( $ children ) { $ this -> _children = [ ] ; foreach ( $ children as $ child ) { $ child -> parent = $ this ; $ this -> _children [ ] = $ child ; } $ this -> updateCollectionOffsets ( ) ; }
9051	protected function getMessage ( $ level , $ message , array $ context = array ( ) ) : MemoryStream { self :: checkLevel ( $ level ) ; $ ms = new MemoryStream ( ) ; $ ms -> write ( strftime ( "%Y-%m-%d %H:%M:%S" , time ( ) ) ) ; $ ms -> interpolate ( "\t[{level}]: " , array ( 'level' => sprintf ( "%6.6s" , $ level ) ) ) ; $ ms -> interpolate ( $ message , $ context ) ; $ ms -> write ( "\n" ) ; return $ ms ; }
8628	public static function fromXML ( $ xml ) { $ dom = new DOMDocument ( ) ; $ dom -> loadXML ( $ xml ) ; $ xpath = new DOMXPath ( $ dom ) ; $ response = $ xpath -> query ( "//*[local-name()='GetCompetitivePricingForSKUResponse']" ) ; if ( $ response -> length == 1 ) { return new MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse ( ( $ response -> item ( 0 ) ) ) ; } else { throw new Exception ( "Unable to construct MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse from provided XML. Make sure that GetCompetitivePricingForSKUResponse is a root element" ) ; } }
12588	protected function createTokenTable ( $ db , $ tableName ) { $ driver = $ db -> getDriverName ( ) ; $ file = dirname ( __DIR__ ) . '/migrations/' . $ this -> tokenTableName . '.' . $ db -> getDriverName ( ) ; $ pdo = $ this -> getDbConnection ( ) -> pdoInstance ; $ sql = file_get_contents ( $ file ) ; $ sql = rtrim ( $ sql ) ; $ sqls = preg_replace_callback ( "/\((.*)\)/" , create_function ( '$matches' , 'return str_replace(";"," $$$ ",$matches[0]);' ) , $ sql ) ; $ sqls = explode ( ";" , $ sqls ) ; foreach ( $ sqls as $ sql ) { if ( ! empty ( $ sql ) ) { $ sql = str_replace ( " $$$ " , ";" , $ sql ) . ";" ; $ pdo -> exec ( $ sql ) ; } } }
8364	public static function setCurrentLanguage ( $ language ) { self :: $ currentLanguage = $ language ; Session :: set ( '_stray_language' , self :: $ currentLanguage ) ; setlocale ( LC_ALL , $ language ) ; }
7974	public function getSender ( $ domain , $ sender ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ sender ) throw new BadMethodCallException ( 'Parameter $sender is missing.' ) ; $ sender = urlencode ( $ sender ) ; try { $ r = $ this -> get ( 'sms/' . $ domain . '/senders/' . $ sender ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
8535	public function setId ( $ id ) { if ( ! $ this -> isNumericArray ( $ id ) ) { $ id = array ( $ id ) ; } $ this -> fields [ 'Id' ] [ 'FieldValue' ] = $ id ; return $ this ; }
3630	protected function validateItems ( array $ items , $ type ) { foreach ( $ items as $ item ) { $ this -> validateItem ( $ item , $ type ) ; } }
8484	public static function getHostname ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Name FROM Win32_ComputerSystem" ) as $ cs ) { return $ cs -> Name ; } return "Unknown" ; }
5671	protected function describeStringDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } $ position = $ this -> stringDiffersAt ( $ first , $ second ) ; return sprintf ( 'at character %s with [%s] and [%s]' , $ position , $ this -> clipString ( $ first , 200 , $ position ) , $ this -> clipString ( $ second , 200 , $ position ) ) ; }
10446	protected function detectQueryType ( $ type ) { switch ( $ type ) { case 'INSERT INTO' : return ActionTypes :: CREATE ; case 'UPDATE' : return ActionTypes :: UPDATE ; case 'DELETE FROM' : return ActionTypes :: DELETE ; default : throw new \ UnexpectedValueException ( "Unknown statement of type {$type}" ) ; } }
474	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "update $table" ) ; $ this -> db -> createCommand ( ) -> update ( $ table , $ columns , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
4112	public function searchFullPath ( $ filename ) { $ paths = explode ( PATH_SEPARATOR , get_include_path ( ) ) ; foreach ( $ paths as $ path ) { $ fullPath = $ path . DIRECTORY_SEPARATOR . $ filename ; if ( file_exists ( $ fullPath ) ) { return $ fullPath ; } } return false ; }
9190	public function render ( array $ classes = [ ] , $ autoEscape = null ) { $ divOpen = '<div class="' . $ this -> divClass . '">' ; $ divClose = '</div>' ; $ hasMessages = false ; foreach ( $ this -> classes as $ namespace => $ namespaceClasses ) { $ namespaceClasses = ArrayUtils :: merge ( $ namespaceClasses , $ classes ) ; if ( $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> hasCurrentMessages ( $ namespace ) ) { $ hasMessages = true ; $ divOpen .= $ this -> getFlashMessengerHelper ( ) -> renderCurrent ( $ namespace , $ namespaceClasses , $ autoEscape ) ; $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> clearCurrentMessagesFromNamespace ( $ namespace ) ; } elseif ( $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> hasMessages ( $ namespace ) ) { $ hasMessages = true ; $ divOpen .= $ this -> getFlashMessengerHelper ( ) -> render ( $ namespace , $ namespaceClasses , $ autoEscape ) ; } } return $ hasMessages ? $ divOpen . $ divClose : '' ; }
4217	private function clearErrorsHelper ( & $ log , $ clear = true ) { $ errorsNotCleared = array ( ) ; foreach ( $ log as $ k => $ entry ) { if ( ! \ in_array ( $ entry [ 0 ] , array ( 'error' , 'warn' ) ) ) { continue ; } $ clear2 = $ clear ; if ( $ this -> channelName ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; $ clear2 = $ clear && $ channel === $ this -> channelName ; } if ( $ clear2 ) { unset ( $ log [ $ k ] ) ; } elseif ( isset ( $ entry [ 2 ] [ 'errorHash' ] ) ) { $ errorsNotCleared [ ] = $ entry [ 2 ] [ 'errorHash' ] ; } } $ log = \ array_values ( $ log ) ; return $ errorsNotCleared ; }
689	public function addRules ( $ rules , $ append = true ) { if ( ! $ this -> enablePrettyUrl ) { return ; } $ rules = $ this -> buildRules ( $ rules ) ; if ( $ append ) { $ this -> rules = array_merge ( $ this -> rules , $ rules ) ; } else { $ this -> rules = array_merge ( $ rules , $ this -> rules ) ; } }
1022	private static function buildExecutionContext ( Schema $ schema , DocumentNode $ documentNode , $ rootValue , $ contextValue , $ rawVariableValues , $ operationName = null , ? callable $ fieldResolver = null , ? PromiseAdapter $ promiseAdapter = null ) { $ errors = [ ] ; $ fragments = [ ] ; $ operation = null ; $ hasMultipleAssumedOperations = false ; foreach ( $ documentNode -> definitions as $ definition ) { switch ( $ definition -> kind ) { case NodeKind :: OPERATION_DEFINITION : if ( ! $ operationName && $ operation ) { $ hasMultipleAssumedOperations = true ; } if ( ! $ operationName || ( isset ( $ definition -> name ) && $ definition -> name -> value === $ operationName ) ) { $ operation = $ definition ; } break ; case NodeKind :: FRAGMENT_DEFINITION : $ fragments [ $ definition -> name -> value ] = $ definition ; break ; } } if ( $ operation === null ) { if ( $ operationName ) { $ errors [ ] = new Error ( sprintf ( 'Unknown operation named "%s".' , $ operationName ) ) ; } else { $ errors [ ] = new Error ( 'Must provide an operation.' ) ; } } elseif ( $ hasMultipleAssumedOperations ) { $ errors [ ] = new Error ( 'Must provide operation name if query contains multiple operations.' ) ; } $ variableValues = null ; if ( $ operation !== null ) { [ $ coercionErrors , $ coercedVariableValues ] = Values :: getVariableValues ( $ schema , $ operation -> variableDefinitions ? : [ ] , $ rawVariableValues ? : [ ] ) ; if ( empty ( $ coercionErrors ) ) { $ variableValues = $ coercedVariableValues ; } else { $ errors = array_merge ( $ errors , $ coercionErrors ) ; } } if ( ! empty ( $ errors ) ) { return $ errors ; } Utils :: invariant ( $ operation , 'Has operation if no errors.' ) ; Utils :: invariant ( $ variableValues !== null , 'Has variables if no errors.' ) ; return new ExecutionContext ( $ schema , $ fragments , $ rootValue , $ contextValue , $ operation , $ variableValues , $ errors , $ fieldResolver , $ promiseAdapter ) ; }
4258	public function addSubscriberInterface ( SubscriberInterface $ interface ) { $ subscribers = $ this -> getInterfaceSubscribers ( $ interface ) ; foreach ( $ subscribers as $ row ) { $ this -> subscribe ( $ row [ 0 ] , $ row [ 1 ] , $ row [ 2 ] ) ; } return $ subscribers ; }
7259	protected function getRealGrossBase ( Model \ SaleInterface $ sale ) : float { $ cache = $ this -> cache ; $ this -> cache = false ; $ base = $ this -> calculateSaleItems ( $ sale ) -> getBase ( ) ; $ this -> cache = $ cache ; return $ base ; }
10478	protected function resolveItemAction ( AbstractDiffItem $ item ) { if ( $ item instanceof CreateDiffItem ) { $ action = ActionTypes :: CREATE ; return $ action ; } elseif ( $ item instanceof DeleteDiffItem ) { $ action = ActionTypes :: DELETE ; return $ action ; } elseif ( $ item instanceof UpdateDiffItem ) { $ action = ActionTypes :: UPDATE ; return $ action ; } else { throw new \ InvalidArgumentException ( 'Unsupported diff item type. Got: ' . get_class ( $ item ) ) ; } }
5566	public function get ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } return $ this -> load ( $ url , new SimpleGetEncoding ( $ parameters ) ) ; }
7136	public function merge ( Margin $ margin ) : void { $ this -> purchaseCost += $ margin -> getPurchaseCost ( ) ; $ this -> sellingPrice += $ margin -> getSellingPrice ( ) ; $ this -> average = $ this -> average || $ margin -> isAverage ( ) ; }
9370	public function handle ( ServerRequestInterface $ request ) { $ callback = new CallbackHandler ( self :: $ container ) ; if ( static :: $ container -> has ( self :: MIDDLEWARE ) ) { $ middleware = static :: $ container -> get ( self :: MIDDLEWARE ) ; $ delegate = new Delegate ( $ callback ) ; $ result = $ middleware -> process ( $ request , $ delegate ) ; } return isset ( $ result ) ? $ result : $ callback ( $ request ) ; }
758	protected function renderImageByImagick ( $ code ) { $ backColor = $ this -> transparent ? new \ ImagickPixel ( 'transparent' ) : new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> backColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ foreColor = new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> foreColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ image = new \ Imagick ( ) ; $ image -> newImage ( $ this -> width , $ this -> height , $ backColor ) ; $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( 30 ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code ) ; $ length = strlen ( $ code ) ; $ w = ( int ) $ fontMetrics [ 'textWidth' ] - 8 + $ this -> offset * ( $ length - 1 ) ; $ h = ( int ) $ fontMetrics [ 'textHeight' ] - 8 ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ) ; $ draw -> setFillColor ( $ foreColor ) ; $ image -> annotateImage ( $ draw , $ x , $ y , mt_rand ( - 10 , 10 ) , $ code [ $ i ] ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code [ $ i ] ) ; $ x += ( int ) $ fontMetrics [ 'textWidth' ] + $ this -> offset ; } $ image -> setImageFormat ( 'png' ) ; return $ image -> getImageBlob ( ) ; }
3869	protected function getMetaModel ( $ identifier , $ ignoreError ) { $ factory = $ this -> getMetaModelsFactory ( ) ; if ( is_numeric ( $ identifier ) ) { $ identifier = $ factory -> translateIdToMetaModelName ( $ identifier ) ; } $ metaModels = $ factory -> getMetaModel ( $ identifier ) ; if ( ! $ ignoreError && $ metaModels == null ) { throw new \ RuntimeException ( 'Could not find the MetaModels with the name ' . $ identifier ) ; } return $ metaModels ; }
6913	public function addShipment ( ShipmentInterface $ shipment ) { if ( ! $ this -> shipments -> contains ( $ shipment ) ) { $ this -> shipments -> add ( $ shipment ) ; } return $ this ; }
4633	protected function getHeader ( $ key ) { return isset ( $ this -> headers [ $ key ] ) ? $ this -> headers [ $ key ] : NULL ; }
8530	private function _convertListFinancialEvents ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMaxResultsPerPage ( ) ) { $ parameters [ 'MaxResultsPerPage' ] = $ request -> getMaxResultsPerPage ( ) ; } if ( $ request -> isSetAmazonOrderId ( ) ) { $ parameters [ 'AmazonOrderId' ] = $ request -> getAmazonOrderId ( ) ; } if ( $ request -> isSetFinancialEventGroupId ( ) ) { $ parameters [ 'FinancialEventGroupId' ] = $ request -> getFinancialEventGroupId ( ) ; } if ( $ request -> isSetPostedAfter ( ) ) { $ parameters [ 'PostedAfter' ] = $ request -> getPostedAfter ( ) ; } if ( $ request -> isSetPostedBefore ( ) ) { $ parameters [ 'PostedBefore' ] = $ request -> getPostedBefore ( ) ; } return $ parameters ; }
9673	private function writeNumFmt ( XMLWriter $ objWriter , NumberFormat $ pNumberFormat , $ pId = 0 ) { $ formatCode = $ pNumberFormat -> getFormatCode ( ) ; if ( $ formatCode !== null ) { $ objWriter -> startElement ( 'numFmt' ) ; $ objWriter -> writeAttribute ( 'numFmtId' , ( $ pId + 164 ) ) ; $ objWriter -> writeAttribute ( 'formatCode' , $ formatCode ) ; $ objWriter -> endElement ( ) ; } }
3257	public function scopeWhereSKU ( $ query , $ sku ) { return $ query -> join ( config ( 'shop.item_table' ) , config ( 'shop.item_table' ) . '.order_id' , '=' , $ this -> table . '.id' ) -> where ( config ( 'shop.item_table' ) . '.sku' , $ sku ) ; }
5776	public function add ( string $ sql ) { $ args = func_get_args ( ) ; array_shift ( $ args ) ; $ this -> sql .= $ sql ; $ this -> args = array_merge ( $ this -> args , $ args ) ; return $ this ; }
7874	private function checkConfig ( ) : void { if ( empty ( $ this -> userkey ) ) { Log :: warning ( 'Config "message.zenziva.userkey" is not defined.' ) ; } if ( empty ( $ this -> passkey ) ) { Log :: warning ( 'Config "message.zenziva.passkey" is not defined.' ) ; } }
2156	protected function validator ( $ varInput ) { if ( $ varInput == '*****' ) { $ this -> blnSubmitInput = false ; return true ; } return parent :: validator ( $ varInput ) ; }
3581	protected function pluckMeta ( Builder $ query , ArgumentBag $ args , $ alias ) { list ( $ column , $ key ) = [ $ args -> get ( 'column' ) , $ args -> get ( 'key' ) ] ; $ query -> select ( "{$alias}.meta_value as {$column}" ) ; if ( ! is_null ( $ key ) ) { $ this -> metaSelectListsKey ( $ query , $ key ) ; } return $ query -> callParent ( 'pluck' , $ args -> all ( ) ) ; }
9417	public function fwhm ( ) { $ float_fwhm = 2 * sqrt ( 2 * log ( 2 ) ) * $ this -> float_sigma ; if ( $ this -> int_precision ) { return round ( $ float_fwhm , $ this -> int_precision ) ; } return $ float_fwhm ; }
6815	protected function buildFile ( array $ orders , string $ name ) { if ( false === $ path = tempnam ( sys_get_temp_dir ( ) , $ name ) ) { throw new RuntimeException ( "Failed to create temporary file." ) ; } if ( false === $ handle = fopen ( $ path , "w" ) ) { throw new RuntimeException ( "Failed to open '$path' for writing." ) ; } if ( ! empty ( $ headers = $ this -> buildHeaders ( ) ) ) { fputcsv ( $ handle , $ headers , ';' , '"' ) ; } $ supplierTotal = 0 ; $ forwarderTotal = 0 ; foreach ( $ orders as $ order ) { if ( ! empty ( $ row = $ this -> buildRow ( $ order ) ) ) { fputcsv ( $ handle , $ row , ';' , '"' ) ; $ supplierTotal += $ row [ 'payment_total' ] ; $ forwarderTotal += $ row [ 'forwarder_total' ] ; } } fputcsv ( $ handle , [ 'id' => '' , 'number' => '' , 'state' => '' , 'ordered_at' => '' , 'completed_at' => '' , 'supplier' => '' , 'payment_total' => $ supplierTotal , 'payment_date' => '' , 'payment_due_date' => '' , 'carrier' => '' , 'forwarder_total' => $ forwarderTotal , 'forwarder_date' => '' , 'forwarder_due_date' => '' , ] , ';' , '"' ) ; fclose ( $ handle ) ; return $ path ; }
6886	public function lookupPostcodeMetadata ( $ postcode ) { $ path = sprintf ( self :: PATH_LOOKUP_METADATA , $ postcode ) ; $ response = $ this -> httpGet ( $ path ) ; return Response \ PostcodeInfo :: buildFromResponse ( $ response ) ; }
9791	public function getCalculatedValue ( $ resetLog = true ) { if ( $ this -> dataType == DataType :: TYPE_FORMULA ) { try { $ result = Calculation :: getInstance ( $ this -> getWorksheet ( ) -> getParent ( ) ) -> calculateCellValue ( $ this , $ resetLog ) ; if ( is_array ( $ result ) ) { while ( is_array ( $ result ) ) { $ result = array_pop ( $ result ) ; } } } catch ( Exception $ ex ) { if ( ( $ ex -> getMessage ( ) === 'Unable to access External Workbook' ) && ( $ this -> calculatedValue !== null ) ) { return $ this -> calculatedValue ; } throw new \ PhpOffice \ PhpSpreadsheet \ Calculation \ Exception ( $ this -> getWorksheet ( ) -> getTitle ( ) . '!' . $ this -> getCoordinate ( ) . ' -> ' . $ ex -> getMessage ( ) ) ; } if ( $ result === '#Not Yet Implemented' ) { return $ this -> calculatedValue ; } return $ result ; } elseif ( $ this -> value instanceof RichText ) { return $ this -> value -> getPlainText ( ) ; } return $ this -> value ; }
11084	public static function deleteDirectory ( $ dirName , $ deleteSelf = true ) { $ dirName = rtrim ( $ dirName , '/' ) . '/' ; if ( file_exists ( $ dirName ) && $ files = scandir ( $ dirName , SCANDIR_SORT_NONE ) ) { foreach ( $ files as $ file ) { if ( $ file !== '.' && $ file !== '..' && $ file !== '.svn' ) { if ( is_dir ( $ dirName . $ file ) ) { self :: deleteDirectory ( $ dirName . $ file , true ) ; } elseif ( file_exists ( $ dirName . $ file ) ) { @ chmod ( $ dirName . $ file , 0777 ) ; unlink ( $ dirName . $ file ) ; } } } if ( $ deleteSelf && ! rmdir ( $ dirName ) ) { @ chmod ( $ dirName , 0777 ) ; return false ; } return true ; } return false ; }
10515	public function inc ( $ key , $ expire = 0 ) { $ this -> getLock ( $ key ) ; $ this -> set ( $ key , ( int ) $ this -> get ( $ key ) + 1 ) ; $ this -> releaseLock ( $ key ) ; return true ; }
11525	private function getDom ( $ url ) { $ ch = curl_init ( ) ; $ timeout = 5 ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , $ timeout ) ; $ dom = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ dom ; }
7362	protected function updateAmountsTotal ( SaleInterface $ sale ) { $ changed = false ; $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ sale -> clearResults ( ) ; $ result = $ this -> amountCalculator -> calculateSale ( $ sale ) ; if ( 0 != Money :: compare ( $ result -> getBase ( ) , $ sale -> getNetTotal ( ) , $ currency ) ) { $ sale -> setNetTotal ( $ result -> getBase ( ) ) ; $ changed = true ; } if ( 0 != Money :: compare ( $ result -> getTotal ( ) , $ sale -> getGrandTotal ( ) , $ currency ) ) { $ sale -> setGrandTotal ( $ result -> getTotal ( ) ) ; $ changed = true ; } return $ changed ; }
12395	abstract public function __construct ( ConnectionInterface $ connection ) ;
1070	private function collectConflictsBetweenFragments ( ValidationContext $ context , array & $ conflicts , $ areMutuallyExclusive , $ fragmentName1 , $ fragmentName2 ) { if ( $ fragmentName1 === $ fragmentName2 ) { return ; } if ( $ this -> comparedFragmentPairs -> has ( $ fragmentName1 , $ fragmentName2 , $ areMutuallyExclusive ) ) { return ; } $ this -> comparedFragmentPairs -> add ( $ fragmentName1 , $ fragmentName2 , $ areMutuallyExclusive ) ; $ fragment1 = $ context -> getFragment ( $ fragmentName1 ) ; $ fragment2 = $ context -> getFragment ( $ fragmentName2 ) ; if ( ! $ fragment1 || ! $ fragment2 ) { return ; } [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getReferencedFieldsAndFragmentNames ( $ context , $ fragment1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getReferencedFieldsAndFragmentNames ( $ context , $ fragment2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentName1 , $ fragmentNames2 [ $ j ] ) ; } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentName2 ) ; } }
12602	public static function delete ( $ path ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
5478	protected function setWidget ( $ tag ) { if ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'radio' ) { $ this -> addRadioButton ( $ tag ) ; } elseif ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'checkbox' ) { $ this -> addCheckbox ( $ tag ) ; } else { $ this -> widgets [ ] = $ tag ; } }
5401	public function isValidPath ( $ path ) { return ( strncmp ( $ this -> fixPath ( $ path ) , $ this -> getPath ( ) , strlen ( $ this -> getPath ( ) ) ) == 0 ) ; }
10977	public static function verify ( $ code ) { if ( ! $ code ) { return null ; } if ( $ user = self :: lookupVerificationCode ( $ code ) ) { $ user -> setVerificationCode ( ) ; } return $ user ; }
4191	protected function dumpMethodParams ( $ params ) { $ paramStr = '' ; foreach ( $ params as $ info ) { $ paramStr .= '<span class="parameter">' ; if ( ! empty ( $ info [ 'type' ] ) ) { $ paramStr .= '<span class="t_type">' . $ info [ 'type' ] . '</span> ' ; } $ paramStr .= '<span class="t_parameter-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . \ htmlspecialchars ( $ info [ 'name' ] ) . '</span>' ; if ( $ info [ 'defaultValue' ] !== $ this -> debug -> abstracter -> UNDEFINED ) { $ defaultValue = $ info [ 'defaultValue' ] ; $ paramStr .= ' <span class="t_operator">=</span> ' ; if ( $ info [ 'constantName' ] ) { $ title = '' ; $ type = $ this -> debug -> abstracter -> getType ( $ defaultValue ) ; if ( ! \ in_array ( $ type , array ( 'array' , 'resource' ) ) ) { $ title = $ this -> debug -> output -> text -> dump ( $ defaultValue ) ; $ title = \ htmlspecialchars ( 'value: ' . $ title ) ; } $ paramStr .= '<span class="t_parameter-default t_const"' . ' title="' . $ title . '"' . '>' . $ info [ 'constantName' ] . '</span>' ; } else { if ( \ is_string ( $ defaultValue ) ) { $ defaultValue = \ str_replace ( "\n" , ' ' , $ defaultValue ) ; } $ parsed = $ this -> debug -> utilities -> parseTag ( $ this -> debug -> output -> html -> dump ( $ defaultValue ) ) ; $ class = \ trim ( 't_parameter-default ' . $ parsed [ 'attribs' ] [ 'class' ] ) ; $ paramStr .= '<span class="' . $ class . '">' . $ parsed [ 'innerhtml' ] . '</span>' ; } } $ paramStr .= '</span>, ' ; } $ paramStr = \ trim ( $ paramStr , ', ' ) ; return $ paramStr ; }
8404	public static function registerApp ( string $ namespace , string $ path = null ) { $ namespace = rtrim ( $ namespace , '\\' ) ; if ( $ path == null ) { $ path = constant ( 'STRAY_PATH_APPS' ) . str_replace ( '_' , DIRECTORY_SEPARATOR , str_replace ( '\\' , DIRECTORY_SEPARATOR , $ namespace ) ) ; } self :: $ namespaces [ $ namespace ] = $ path ; self :: $ applications [ ] = $ namespace ; }
529	public function actionPackage ( array $ what ) { $ this -> validateWhat ( $ what , [ 'app' ] ) ; $ versions = $ this -> getCurrentVersions ( $ what ) ; $ this -> stdout ( "You are about to generate packages for the following things:\n\n" ) ; foreach ( $ what as $ ext ) { if ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( substr ( $ ext , 4 ) , Console :: FG_RED ) ; $ this -> stdout ( ' application version ' ) ; } elseif ( $ ext === 'framework' ) { $ this -> stdout ( ' - Yii Framework version ' ) ; } else { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( $ ext , Console :: FG_RED ) ; $ this -> stdout ( ' extension version ' ) ; } $ this -> stdout ( $ versions [ $ ext ] , Console :: BOLD ) ; $ this -> stdout ( "\n" ) ; } $ this -> stdout ( "\n" ) ; $ packagePath = "{$this->basePath}/packages" ; $ this -> stdout ( "Packages will be stored in $packagePath\n\n" ) ; if ( ! $ this -> confirm ( 'Continue?' , false ) ) { $ this -> stdout ( "Canceled.\n" ) ; return 1 ; } foreach ( $ what as $ ext ) { if ( $ ext === 'framework' ) { throw new Exception ( 'Can not package framework.' ) ; } elseif ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> packageApplication ( substr ( $ ext , 4 ) , $ versions [ $ ext ] , $ packagePath ) ; } else { throw new Exception ( 'Can not package extension.' ) ; } } $ this -> stdout ( "\ndone. verify the versions composer installed above and push it to github!\n\n" ) ; return 0 ; }
2987	public function addResource ( $ bundle , $ format , $ prefix = '/' , $ path = 'routing' ) { $ current = '' ; $ code = sprintf ( "%s:\n" , $ this -> getImportedResourceYamlKey ( $ bundle , $ prefix ) ) ; if ( file_exists ( $ this -> file ) ) { $ current = file_get_contents ( $ this -> file ) ; if ( false !== strpos ( $ current , '@' . $ bundle ) ) { throw new \ RuntimeException ( sprintf ( 'Bundle "%s" is already imported.' , $ bundle ) ) ; } } elseif ( ! is_dir ( $ dir = dirname ( $ this -> file ) ) ) { Generator :: mkdir ( $ dir ) ; } if ( 'annotation' == $ format ) { $ code .= sprintf ( " resource: \"@%s/Controller/\"\n type: annotation\n" , $ bundle ) ; } else { $ code .= sprintf ( " resource: \"@%s/Resources/config/%s.%s\"\n" , $ bundle , $ path , $ format ) ; } $ code .= sprintf ( " prefix: %s\n" , $ prefix ) ; $ code .= "\n" ; $ code .= $ current ; if ( false === Generator :: dump ( $ this -> file , $ code ) ) { return false ; } return true ; }
7845	public function send ( array $ destinations , string $ text ) : ? array { $ this -> checkConfig ( ) ; $ messages = [ ] ; foreach ( $ destinations as $ destination ) { $ messages [ ] = [ 'phone_number' => $ destination , 'message' => $ text , 'device_id' => $ this -> device , ] ; } $ body = Body :: json ( $ messages ) ; $ response = Request :: post ( $ this -> baseUrl . 'message/send' , [ ] , $ body ) ; if ( $ response -> code == 200 ) { return [ 'code' => $ response -> code , 'message' => 'OK' , 'data' => $ response -> body , ] ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } return [ 'code' => $ response -> code , 'message' => $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } }
935	public static function isKeyCaseSensitive ( $ caseSensitive , $ key ) { if ( \ is_array ( $ caseSensitive ) ) { return isset ( $ caseSensitive [ $ key ] ) ? $ caseSensitive [ $ key ] : true ; } return $ caseSensitive ; }
3730	protected function getMatchingIds ( $ objFilter ) { if ( $ objFilter ) { $ arrFilteredIds = $ objFilter -> getMatchingIds ( ) ; if ( $ arrFilteredIds !== null ) { return $ arrFilteredIds ; } } return $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'id' ) -> from ( $ this -> getTableName ( ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; }
5805	public function increment ( ) { $ this -> counter ++ ; if ( 1 === $ this -> counter ) { $ this -> expiresAt = $ this -> now ( ) + $ this -> expiresIn ; } }
4580	public function encrypt ( Encryptable $ model ) : EncryptionService { if ( $ model -> getEncrypted ( ) ) { return $ this ; } $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ property -> setAccessible ( true ) ; $ property -> setValue ( $ model , $ this -> cipherService -> encrypt ( $ property -> getValue ( $ model ) ) ) ; } $ model -> setEncrypted ( true ) ; return $ this ; }
4952	protected function checkRatingValue ( $ rating , $ throwException = true ) { if ( ! is_int ( $ rating ) || static :: RATING_EXCELLENT < $ rating || static :: RATING_NONE > $ rating ) { if ( $ throwException ) { throw new \ InvalidArgumentException ( sprintf ( '%s is not a valid rating value.' , $ rating ) ) ; } return false ; } return true ; }
3100	private function getItemData ( RunnerServiceContext $ context , $ itemRef ) { $ this -> getRunnerService ( ) -> assertQtiRunnerServiceContext ( $ context ) ; $ itemData = $ this -> getRunnerService ( ) -> getItemData ( $ context , $ itemRef ) ; $ itemDataVariable = $ this -> getRunnerService ( ) -> getItemVariableElementsData ( $ context , $ itemRef ) ; $ responses = $ itemData [ 'data' ] [ 'responses' ] ; foreach ( array_keys ( $ responses ) as $ responseId ) { if ( array_key_exists ( $ responseId , $ itemDataVariable ) ) { $ itemData [ 'data' ] [ 'responses' ] [ $ responseId ] = array_merge ( ... [ $ responses [ $ responseId ] , $ itemDataVariable [ $ responseId ] , ] ) ; } } return $ itemData ; }
4128	protected function loadMetadata ( $ className ) { if ( class_exists ( $ className ) ) { return parent :: loadMetadata ( $ className ) ; } throw MappingException :: classNotFound ( $ className ) ; }
2395	public function close ( ) { $ arrArchive [ 'archive_signature' ] = self :: CENTRAL_DIR_END ; $ arrArchive [ 'number_of_this_disk' ] = "\x00\x00" ; $ arrArchive [ 'number_of_disk_with_cd' ] = "\x00\x00" ; $ arrArchive [ 'total_cd_entries_disk' ] = pack ( 'v' , $ this -> intCount ) ; $ arrArchive [ 'total_cd_entries' ] = pack ( 'v' , $ this -> intCount ) ; $ arrArchive [ 'size_of_cd' ] = pack ( 'V' , \ strlen ( $ this -> strCentralDir ) ) ; $ arrArchive [ 'offset_start_cd' ] = pack ( 'V' , @ ftell ( $ this -> resFile ) ) ; $ arrArchive [ 'zipfile_comment_length' ] = "\x00\x00" ; $ arrArchive [ 'zipfile_comment' ] = '' ; fwrite ( $ this -> resFile , $ this -> strCentralDir ) ; fwrite ( $ this -> resFile , implode ( '' , $ arrArchive ) ) ; fclose ( $ this -> resFile ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } } Files :: getInstance ( ) -> rename ( self :: TEMPORARY_FOLDER . '/' . basename ( $ this -> strTemp ) , $ this -> strFile ) ; }
11621	public function view ( ) : \ TheCMSThread \ Core \ Main \ View { static $ view ; if ( $ view === null ) { $ view = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\View" ) ; } $ view -> __construct ( $ this -> auth ( ) ) ; return $ view ; }
8044	public static function setProcessTitle ( $ title , array $ replacements = array ( ) ) { if ( trim ( $ title ) == '' || PHP_OS == 'Darwin' ) { return ; } $ title = preg_replace_callback ( '/\%([a-z0-9]+)\%/i' , function ( $ match ) use ( $ replacements ) { if ( isset ( $ replacements [ $ match [ 1 ] ] ) ) { return $ replacements [ $ match [ 1 ] ] ; } return $ match [ 0 ] ; } , $ title ) ; $ title = preg_replace ( '/[^a-z0-9-_.: \\\\\\]\\[]/i' , '' , $ title ) ; if ( function_exists ( 'cli_set_process_title' ) ) { cli_set_process_title ( $ title ) ; } elseif ( function_exists ( 'setproctitle' ) ) { setproctitle ( $ title ) ; } }
1307	private static function replaceUrlParameter ( $ url , $ source ) { $ parameter = static :: urlParameter ( $ url ) ; return str_replace ( '{' . $ parameter . '}' , $ source [ $ parameter ] , $ url ) ; }
3446	private function getAccessorForLanguageField ( $ field ) { $ method = 'getValueFromLanguageField' ; return in_array ( $ field , $ this -> languageAccessors ) && method_exists ( $ this , $ method ) ? $ method : false ; }
9589	public function dropDownListDefault ( $ items , $ options = [ ] ) { Html :: addCssClass ( $ options , 'browser-default' ) ; return parent :: dropDownList ( $ items , $ options ) ; }
12311	private function detectMimeType ( $ file ) { $ fileParts = explode ( '.' , $ file ) ; $ extension = array_pop ( $ fileParts ) ; $ extension = strtolower ( $ extension ) ; if ( array_key_exists ( $ extension , $ this -> mimeTypes ) ) { return $ this -> mimeTypes [ $ extension ] ; } if ( function_exists ( 'finfo_open' ) ) { $ finfo = finfo_open ( FILEINFO_MIME_TYPE ) ; $ mimeType = finfo_file ( $ finfo , $ file ) ; finfo_close ( $ finfo ) ; return $ mimeType ; } return 'application/octet-stream' ; }
1630	public function resolve ( ) { $ request = $ this -> app -> make ( Request :: class ) ; if ( $ this -> app -> runningInConsole ( ) ) { $ command = $ request -> server ( 'argv' , [ ] ) ; if ( ! is_array ( $ command ) ) { $ command = explode ( ' ' , $ command ) ; } return new ConsoleRequest ( $ command ) ; } return new LaravelRequest ( $ request ) ; }
7113	public function urlAllowed ( $ user , $ url ) { if ( empty ( $ url ) ) { return false ; } if ( is_array ( $ url ) ) { $ url = Hash :: merge ( [ 'plugin' => null ] , $ url ) ; $ url = Router :: url ( $ url ) ; $ url = Router :: normalize ( $ url ) ; } $ route = Router :: parse ( $ url ) ; if ( empty ( $ route [ 'controller' ] ) || empty ( $ route [ 'action' ] ) ) { return false ; } return $ this -> isAuthorized ( $ user , $ route [ 'plugin' ] , $ route [ 'controller' ] , $ route [ 'action' ] ) ; }
4166	public function run ( $ command ) { $ process = new Process ( $ command , null , null , null , ini_get ( 'max_execution_time' ) ) ; $ process -> run ( function ( $ type , $ buffer ) { if ( Process :: ERR === $ type ) { $ this -> console -> warn ( trim ( $ buffer ) ) ; } else { $ this -> console -> info ( trim ( $ buffer ) ) ; } } ) ; if ( ! $ process -> isSuccessful ( ) ) { throw new ProcessFailedException ( $ process ) ; } return true ; }
713	public function bigInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BIGINT , $ length ) ; }
6021	public function setApiKey ( $ apiKey ) { $ this -> apiKey = $ apiKey ; list ( , $ datacentre ) = explode ( '-' , $ this -> apiKey ) ; $ this -> apiUrl = str_replace ( '<dc>' , $ datacentre , $ this -> apiUrl ) ; }
5026	protected function getCustomizationOptions ( ContainerInterface $ container , $ requestedName , array $ options = null ) { if ( ! static :: OPTIONS_NAME ) { throw new \ RuntimeException ( 'The class constants "OPTIONS_NAME" must be non empty.' ) ; } return $ container -> get ( static :: OPTIONS_NAME ) ; }
4738	public function onKernelException ( GetResponseForExceptionEvent $ event ) { if ( $ this -> isIgnored ( $ event -> getException ( ) ) ) { return ; } if ( $ this -> mailer ) { $ this -> mailer -> sendException ( $ event -> getRequest ( ) , $ event -> getException ( ) ) ; } if ( $ this -> statsd ) { $ this -> statsd -> increment ( "exception" ) ; } }
3047	protected function getToolStates ( ) { $ toolStates = $ this -> getRunnerService ( ) -> getToolsStates ( $ this -> getServiceContext ( ) ) ; array_walk ( $ toolStates , function ( & $ toolState ) { $ toolState = json_decode ( $ toolState ) ; } ) ; return $ toolStates ; }
8421	private function getTexture ( ) { if ( isset ( $ this -> model ) ) { $ texture = $ this -> attribute ; if ( isset ( $ this -> model -> $ texture ) ) { return $ this -> model -> $ texture ; } } if ( isset ( $ this -> texture ) ) { return $ this -> texture ; } return $ this -> default ; }
12768	public function get ( string $ key = '' ) { if ( empty ( $ key ) ) { return $ this -> store ; } else { return $ this -> store [ $ key ] ?? null ; } }
9934	public function setValue ( $ pValue ) { if ( is_array ( $ pValue ) ) { $ grouping = - 1 ; foreach ( $ pValue as $ key => $ value ) { if ( ! in_array ( $ key , self :: $ dateTimeGroups ) ) { unset ( $ pValue [ $ key ] ) ; } else { $ grouping = max ( $ grouping , array_search ( $ key , self :: $ dateTimeGroups ) ) ; } } if ( count ( $ pValue ) == 0 ) { throw new PhpSpreadsheetException ( 'Invalid rule value for column AutoFilter Rule.' ) ; } $ this -> setGrouping ( self :: $ dateTimeGroups [ $ grouping ] ) ; } $ this -> value = $ pValue ; return $ this ; }
11738	protected function normalize ( $ scheme = true , $ www = true ) { $ address = $ this -> address ; if ( $ scheme && null === $ this -> get ( self :: PARSE_SCHEME ) ) { $ address = sprintf ( 'http://%s' , $ this -> address ) ; } elseif ( ! $ scheme && $ this -> get ( self :: PARSE_SCHEME ) ) { $ address = str_replace ( $ this -> get ( self :: PARSE_SCHEME ) . '://' , '' , $ this -> address ) ; } if ( false === $ www && 0 === strpos ( $ this -> get ( self :: PARSE_HOST ) , 'www.' ) ) { $ address = substr ( $ address , 4 ) ; } return $ address ; }
10164	private function readRangeProtection ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ offset = 0 ; if ( ! $ this -> readDataOnly ) { $ offset += 12 ; $ isf = self :: getUInt2d ( $ recordData , 12 ) ; if ( $ isf != 2 ) { return ; } $ offset += 2 ; $ offset += 5 ; $ cref = self :: getUInt2d ( $ recordData , 19 ) ; $ offset += 2 ; $ offset += 6 ; $ cellRanges = [ ] ; for ( $ i = 0 ; $ i < $ cref ; ++ $ i ) { try { $ cellRange = $ this -> readBIFF8CellRangeAddressFixed ( substr ( $ recordData , 27 + 8 * $ i , 8 ) ) ; } catch ( PhpSpreadsheetException $ e ) { return ; } $ cellRanges [ ] = $ cellRange ; $ offset += 8 ; } $ rgbFeat = substr ( $ recordData , $ offset ) ; $ offset += 4 ; $ wPassword = self :: getInt4d ( $ recordData , $ offset ) ; $ offset += 4 ; if ( $ cellRanges ) { $ this -> phpSheet -> protectCells ( implode ( ' ' , $ cellRanges ) , strtoupper ( dechex ( $ wPassword ) ) , true ) ; } } }
6799	public function installCountries ( $ code = 'US' ) { $ countryNames = Intl :: getRegionBundle ( ) -> getCountryNames ( ) ; if ( ! isset ( $ countryNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default country code '$code'." ) ; } asort ( $ countryNames ) ; $ this -> generate ( Country :: class , $ countryNames , $ code ) ; }
4662	public function sendNow ( ) { $ config = $ this -> getManager ( ) -> getDI ( ) -> getConfig ( ) ; $ message = $ this -> getMessage ( ) ; $ username = $ config -> email -> username ; $ password = $ config -> email -> password ; $ host = $ config -> email -> host ; $ port = $ config -> email -> port ; $ transport = \ Swift_SmtpTransport :: newInstance ( $ host , $ port ) ; $ transport -> setUsername ( $ username ) ; $ transport -> setPassword ( $ password ) ; $ swift = \ Swift_Mailer :: newInstance ( $ transport ) ; $ failures = [ ] ; $ swift -> send ( $ message , $ failures ) ; }
11310	public static function setMappings ( array $ messages , $ manual = true ) { $ class = get_called_class ( ) ; if ( $ manual ) { static :: $ messages = $ messages ; self :: setStatus ( ) ; } else { self :: $ mappings [ $ class ] = array_replace ( $ class :: getMappings ( ) , $ messages ) ; } }
10461	public function initialize ( $ filePath , $ params ) { copy ( __DIR__ . '/../../../recipe/releaz.php' , $ filePath ) ; $ exampleFile = $ this -> getExamplePath ( ) ; $ projectFile = dirname ( $ filePath ) . '/' . $ this -> getExample ( ) ; copy ( $ exampleFile , $ projectFile ) ; $ this -> setParamsInExample ( $ projectFile , $ params ) ; }
4184	public function getFile ( $ class ) { if ( is_null ( $ this -> count ) ) { return $ this -> fileHas ( $ class ) -> getFile ( $ class ) ; } if ( isset ( $ this -> files [ $ class ] ) ) { return $ this -> files [ $ class ] ; } throw new FileException ( "File does not exists with given `{$class}` class." ) ; }
12064	public function setFlashBag ( $ sName , $ sValue ) { if ( ! isset ( $ _SESSION [ 'flashbag' ] ) ) { $ _SESSION [ 'flashbag' ] = array ( ) ; } $ _SESSION [ 'flashbag' ] [ $ sName ] = $ sValue ; return $ this ; }
6646	public function authenticate ( ) { $ request_token = $ this -> oauth -> getRequestToken ( $ this -> settings , $ this -> consumer , $ this -> token ) ; $ auth_url = $ this -> settings ( 'auth_api_url' ) . $ this -> settings ( 'authentication_uri' ) ; $ auth_url .= '?' . http_build_query ( [ 'oauth_token' => $ request_token -> key ] ) ; return $ this -> redirect -> to ( $ auth_url ) ; }
9759	function contain ( $ value = null ) : self { if ( $ this -> hasFlag ( 'file' ) ) return $ this -> expect ( @ file_get_contents ( $ this -> target ) , stringContains ( $ value ) ) ; return $ this -> expect ( $ this -> target , is_string ( $ this -> target ) ? stringContains ( $ value ) : contains ( $ value ) ) ; }
8866	private function runTask ( TaskInterface $ task , PayloadInterface $ payload ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Starting execution.' ) ; try { if ( ! $ task -> unless ( ) ) { $ this -> dispatch ( 'runner.task.unless' , $ task , $ payload ) ; $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping because unless() returned boolean false.' ) ; return ; } $ this -> dispatch ( 'runner.task.start' , $ task , $ payload ) ; $ task -> setUp ( ) ; $ exitCode = ( int ) $ task -> run ( $ payload ) ? : 0 ; $ task -> tearDown ( ) ; if ( $ task -> isFailOnError ( ) && $ exitCode !== 0 ) { throw new FailException ( sprintf ( 'Task: %s failed with exit code %s' , get_class ( $ task ) , $ exitCode ) ) ; } $ message = sprintf ( 'Task exited with status code %s' , $ exitCode ) ; if ( $ exitCode === 0 ) { $ this -> logTask ( $ task , LogLevel :: INFO , $ message ) ; } else { $ this -> logTask ( $ task , LogLevel :: WARNING , $ message ) ; } $ this -> dispatch ( 'runner.task.success' , $ task , $ payload , $ exitCode ) ; $ task -> markAsSuccessfullyExecuted ( ) ; } catch ( SkipException $ e ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping.' ) ; $ this -> dispatch ( 'runner.task.skip' , $ task , $ payload ) ; } catch ( RetryException $ e ) { $ this -> logTask ( $ task , LogLevel :: NOTICE , 'Retry thrown. Starting again.' ) ; $ this -> dispatch ( 'runner.task.retry' , $ task , $ payload ) ; if ( ! $ task -> getMaxRetries ( ) ) { throw new LogicException ( 'A retry exception was thrown, but no retries instance was set.' ) ; } $ task -> getMaxRetries ( ) -> increase ( ) ; $ this -> runTask ( $ task , $ payload ) ; return ; } catch ( FailException $ e ) { $ this -> logTask ( $ task , LogLevel :: WARNING , sprintf ( 'Failure thrown. Given message: %s' , $ e -> getMessage ( ) ) ) ; $ exitCode = $ e -> getCode ( ) ; if ( is_int ( $ exitCode ) ) { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload , $ exitCode ) ; } else { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload ) ; } throw $ e ; } $ this -> logTask ( $ task , LogLevel :: INFO , 'Execution successful.' ) ; }
7964	public function ipGetMonitoringNotification ( $ ip , $ notificationId ) { return json_decode ( self :: getClient ( ) -> ipGetMonitoringNotification ( $ this -> id , $ ip , $ notificationId ) ) ; }
11242	protected function _call ( $ fieldData , $ controller , $ method , $ passing , $ arguments ) { $ fieldData = array ( $ fieldData , $ arguments ) ; $ result = call_user_func_array ( array ( $ controller , $ method ) , $ fieldData ) ; return $ result == $ passing ? true : false ; }
7953	public function getSpam ( $ ipblock , $ spamstate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ spamstate ) throw new BadMethodCallException ( 'Parameter $spamstate is missing.' ) ; switch ( $ spamstate ) { case "blockedForSpam" : case "unblocked" : case "unblocking" : break ; default : throw new BadMethodCallException ( 'Parameter $spamstate is invalid.' ) ; } try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/?state=' . $ spamstate ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
7548	function childCount ( $ ignore_text_comments = false ) { if ( ! $ ignore_text_comments ) { return count ( $ this -> children ) ; } else { $ count = 0 ; foreach ( array_keys ( $ this -> children ) as $ k ) { if ( ! $ this -> children [ $ k ] -> isTextOrComment ( ) ) { ++ $ count ; } } return $ count ; } }
7226	public function info ( $ name = null ) { if ( $ name ) { return $ this -> info ? $ this -> info [ $ name ] : curl_getinfo ( $ this -> curl , "CURLINFO" . strtoupper ( $ name ) ) ; } else { return $ this -> info ? : curl_getinfo ( $ this -> curl ) ; } }
9022	public function getStopWords ( $ string , $ language = 'english' ) { $ words = $ this -> getWords ( $ string ) ; $ filter = new StopWordsFilter ( $ language ) ; $ stopWords = [ ] ; foreach ( $ words as $ word ) { if ( ! is_null ( $ filter -> filter ( $ word ) ) ) { $ stopWords [ ] = $ word ; } } return $ stopWords ; }
407	public function getBodyParams ( ) { if ( $ this -> _bodyParams === null ) { if ( isset ( $ _POST [ $ this -> methodParam ] ) ) { $ this -> _bodyParams = $ _POST ; unset ( $ this -> _bodyParams [ $ this -> methodParam ] ) ; return $ this -> _bodyParams ; } $ rawContentType = $ this -> getContentType ( ) ; if ( ( $ pos = strpos ( $ rawContentType , ';' ) ) !== false ) { $ contentType = substr ( $ rawContentType , 0 , $ pos ) ; } else { $ contentType = $ rawContentType ; } if ( isset ( $ this -> parsers [ $ contentType ] ) ) { $ parser = Yii :: createObject ( $ this -> parsers [ $ contentType ] ) ; if ( ! ( $ parser instanceof RequestParserInterface ) ) { throw new InvalidConfigException ( "The '$contentType' request parser is invalid. It must implement the yii\\web\\RequestParserInterface." ) ; } $ this -> _bodyParams = $ parser -> parse ( $ this -> getRawBody ( ) , $ rawContentType ) ; } elseif ( isset ( $ this -> parsers [ '*' ] ) ) { $ parser = Yii :: createObject ( $ this -> parsers [ '*' ] ) ; if ( ! ( $ parser instanceof RequestParserInterface ) ) { throw new InvalidConfigException ( 'The fallback request parser is invalid. It must implement the yii\\web\\RequestParserInterface.' ) ; } $ this -> _bodyParams = $ parser -> parse ( $ this -> getRawBody ( ) , $ rawContentType ) ; } elseif ( $ this -> getMethod ( ) === 'POST' ) { $ this -> _bodyParams = $ _POST ; } else { $ this -> _bodyParams = [ ] ; mb_parse_str ( $ this -> getRawBody ( ) , $ this -> _bodyParams ) ; } } return $ this -> _bodyParams ; }
3718	protected function getMetaModelFromModel ( ModelInterface $ model ) { if ( ! ( ( $ model -> getProviderName ( ) == 'tl_metamodel_dca_sortgroup' ) && $ model -> getProperty ( 'pid' ) ) ) { throw new DcGeneralInvalidArgumentException ( sprintf ( 'Model must originate from tl_metamodel_dca_sortgroup and be saved, this one originates from %s ' . 'and has pid %s' , $ model -> getProviderName ( ) , $ model -> getProperty ( 'pid' ) ) ) ; } $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'pid' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchColumn ( ) ; $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; return $ this -> factory -> getMetaModel ( $ tableName ) ; }
212	protected function initClientOptions ( ) { $ options = $ this -> clientOptions ; foreach ( $ options as $ key => $ value ) { if ( ! $ value instanceof JsExpression && in_array ( $ key , [ 'oncomplete' , 'onincomplete' , 'oncleared' , 'onKeyUp' , 'onKeyDown' , 'onBeforeMask' , 'onBeforePaste' , 'onUnMask' , 'isComplete' , 'determineActiveMasksetIndex' , ] , true ) ) { $ options [ $ key ] = new JsExpression ( $ value ) ; } } $ this -> clientOptions = $ options ; }
2655	public function createCondition ( $ version , array $ condition ) { $ checkIfExists = $ this -> getCondition ( $ version , $ condition [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/condition' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ condition [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ condition ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create a REQUEST condition.' ) ) ; } return $ result ; }
6676	public function render_meta_boxes ( $ post ) { App :: setCurrentID ( 'EFG' ) ; wp_nonce_field ( '_rating_movie_nonce' , 'rating_movie_nonce' ) ; $ meta_boxes = Module :: CustomRatingGrifus ( ) -> getOption ( 'path' , 'meta-boxes' ) ; $ data = [ 'votes' => $ this -> model -> get_movie_votes ( $ post -> ID ) ] ; $ this -> view -> renderizate ( $ meta_boxes , 'wp-insert-post' , $ data ) ; }
1952	public static function findBySourceParentAndEmail ( $ strSource , $ intParent , $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findOneBy ( array ( "$t.source=? AND $t.parent=? AND $t.email=?" ) , array ( $ strSource , $ intParent , $ strEmail ) , $ arrOptions ) ; }
1637	protected function setupQueue ( QueueManager $ queue ) { $ queue -> looping ( function ( ) { $ this -> app -> bugsnag -> flush ( ) ; $ this -> app -> bugsnag -> clearBreadcrumbs ( ) ; $ this -> app -> make ( Tracker :: class ) -> clear ( ) ; } ) ; if ( ! class_exists ( JobProcessing :: class ) ) { return ; } $ queue -> before ( function ( JobProcessing $ event ) { $ this -> app -> bugsnag -> setFallbackType ( 'Queue' ) ; $ job = [ 'name' => $ event -> job -> getName ( ) , 'queue' => $ event -> job -> getQueue ( ) , 'attempts' => $ event -> job -> attempts ( ) , 'connection' => $ event -> connectionName , ] ; if ( method_exists ( $ event -> job , 'resolveName' ) ) { $ job [ 'resolved' ] = $ event -> job -> resolveName ( ) ; } $ this -> app -> make ( Tracker :: class ) -> set ( $ job ) ; } ) ; }
1499	public function when ( bool $ test , $ encodings ) : self { if ( ! $ test || is_null ( $ encodings ) ) { return $ this ; } if ( $ encodings instanceof \ Closure ) { return $ encodings ( $ this ) ; } if ( is_string ( $ encodings ) ) { $ encodings = Encoding :: custom ( $ encodings ) ; } $ encodings = $ encodings instanceof Encoding ? [ $ encodings ] : $ encodings ; return $ this -> push ( ... $ encodings ) ; }
4459	private function fireQueue ( SplPriorityQueue $ queue , AbstractUserEvent $ event ) { $ eventHappening = $ event :: getHappening ( ) ; $ iterator = clone $ queue ; $ iterator -> top ( ) ; $ arguments = null ; $ status = null ; while ( $ iterator -> valid ( ) ) { $ handler = $ iterator -> current ( ) ; $ iterator -> next ( ) ; if ( is_object ( $ handler ) ) { if ( $ handler instanceof \ Closure ) { $ arguments = $ arguments ? : [ $ event ] ; $ status = call_user_func_array ( $ handler , $ arguments ) ; } else { if ( method_exists ( $ handler , $ eventHappening ) ) { $ status = $ handler -> { $ eventHappening } ( $ event ) ; } } } } return $ status ; }
1710	public function onReplaceInsertTags ( string $ tag , bool $ useCache , $ cacheValue , array $ flags ) { static $ supportedTags = [ 'faq' , 'faq_open' , 'faq_url' , 'faq_title' , ] ; $ elements = explode ( '::' , $ tag ) ; $ key = strtolower ( $ elements [ 0 ] ) ; if ( ! \ in_array ( $ key , $ supportedTags , true ) ) { return false ; } $ this -> framework -> initialize ( ) ; $ adapter = $ this -> framework -> getAdapter ( FaqModel :: class ) ; $ faq = $ adapter -> findByIdOrAlias ( $ elements [ 1 ] ) ; if ( null === $ faq || false === ( $ url = $ this -> generateUrl ( $ faq , \ in_array ( 'absolute' , $ flags , true ) ) ) ) { return '' ; } return $ this -> generateReplacement ( $ faq , $ key , $ url ) ; }
8095	public function add ( ) { if ( ! headers_sent ( ) ) { $ added = setcookie ( $ this -> name , $ this -> value , round ( time ( ) + 60 * 60 * 24 * $ this -> lifetime ) , $ this -> path , $ this -> host ) ; } else { echo "<script>" ; echo ' function setCookie(c_name,value,expiredays){ var exdate=new Date(); exdate.setDate(exdate.getDate()+expiredays); document.cookie=c_name+ "=" +escape(value)+((expiredays==null) ? "" : "; expires="+exdate.toUTCString()) + "; domain="+ escape("' . $ this -> host . '") + "; path=" + escape("' . $ this -> path . '"); } ' ; echo "setCookie('{$this->name}','{$this->value}',{$this->lifetime})" ; echo "</script>" ; $ added = true ; } return $ added ; }
8020	public function set ( string $ content ) { $ parsed = $ this -> parseContent ( $ content ) ; $ this -> id = $ parsed -> id ; $ this -> infoUri = $ parsed -> infoUri ; $ this -> partialCancelUri = $ parsed -> partialCancelUri ?? null ; $ this -> nextUri = $ parsed -> nextUri ?? null ; $ this -> columns = [ ] ; if ( isset ( $ parsed -> columns ) ) { $ this -> columnTransfer ( $ parsed -> columns ) ; } $ this -> data = $ parsed -> data ?? [ ] ; $ this -> stats = isset ( $ parsed -> stats ) ? $ this -> statsTransfer ( $ parsed -> stats ) : null ; $ this -> error = isset ( $ parsed -> error ) ? $ this -> errorTransfer ( $ parsed -> error ) : null ; }
12721	public function isShared ( $ abstract ) { if ( ! isset ( $ this -> bindings [ $ abstract ] ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be valid keys in binding container stack." , __METHOD__ ) ) ; } return ( $ this -> bindings [ $ abstract ] [ 'shared' ] ? true : false ) ; }
9414	public function variance ( ) { $ float_variance = pow ( $ this -> float_sigma , 2 ) ; if ( $ this -> int_precision ) { return round ( $ float_variance , $ this -> int_precision ) ; } return $ float_variance ; }
2307	protected function doCreateFileList ( $ strFolder = null , $ level = - 1 , $ strFilter = '' ) { if ( $ strFilter === true ) { @ trigger_error ( 'Passing "true" to Backend::doCreateFileList() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ strFilter = 'gif,jpg,jpeg,png' ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrPages = scan ( $ rootDir . '/' . $ strFolder ) ; if ( empty ( $ arrPages ) ) { return '' ; } if ( \ in_array ( '.htaccess' , $ arrPages ) ) { return '' ; } ++ $ level ; $ strFolders = '' ; $ strFiles = '' ; foreach ( $ arrPages as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ rootDir . '/' . $ strFolder . '/' . $ strFile ) ) { $ strFolders .= $ this -> doCreateFileList ( $ strFolder . '/' . $ strFile , $ level , $ strFilter ) ; } else { if ( $ strFilter != '' && ! preg_match ( '/\.(' . str_replace ( ',' , '|' , $ strFilter ) . ')$/i' , $ strFile ) ) { continue ; } $ strFiles .= sprintf ( '<option value="%s"%s>%s</option>' , $ strFolder . '/' . $ strFile , ( ( $ strFolder . '/' . $ strFile == Input :: get ( 'value' ) ) ? ' selected="selected"' : '' ) , StringUtil :: specialchars ( $ strFile ) ) ; } } if ( \ strlen ( $ strFiles ) ) { return '<optgroup label="' . StringUtil :: specialchars ( $ strFolder ) . '">' . $ strFiles . $ strFolders . '</optgroup>' ; } return $ strFiles . $ strFolders ; }
7484	public function endsWith ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; return $ string === $ this -> substring ( $ this -> length ( ) - mb_strlen ( $ string , $ this -> encoding ) ) -> __toString ( ) ; }
8522	public function setGlobalSellingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GlobalSellingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2961	public function readPort ( $ count = 0 ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { trigger_error ( "Device must be opened to read it" , E_USER_WARNING ) ; return false ; } if ( $ this -> _os === "linux" || $ this -> _os === "osx" ) { $ content = "" ; $ i = 0 ; if ( $ count !== 0 ) { do { if ( $ i > $ count ) { $ content .= fread ( $ this -> _dHandle , ( $ count - $ i ) ) ; } else { $ content .= fread ( $ this -> _dHandle , 128 ) ; } } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } else { do { $ content .= fread ( $ this -> _dHandle , 128 ) ; } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } return $ content ; } elseif ( $ this -> _os === "windows" ) { $ content = "" ; $ i = 0 ; if ( $ count !== 0 ) { do { if ( $ i > $ count ) { $ content .= fread ( $ this -> _dHandle , ( $ count - $ i ) ) ; } else { $ content .= fread ( $ this -> _dHandle , 128 ) ; } } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } else { do { $ content .= fread ( $ this -> _dHandle , 128 ) ; } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } return $ content ; } return false ; }
6857	protected static function equinoxSeptember ( $ year , $ vsop = true ) { $ month = 9 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
4413	public function onException ( GetResponseForExceptionEvent $ event ) { if ( ! $ this -> isAdminSiteAccess ) { return ; } $ routeName = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( $ routeName !== FallbackRouter :: ROUTE_NAME ) { return ; } $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof NotFoundHttpException ) { return ; } if ( method_exists ( $ exception , 'getOriginalResponse' ) ) { $ event -> setResponse ( $ exception -> getOriginalResponse ( ) ) ; } }
12603	public static function read ( $ path ) { $ path = Path :: clean ( $ path ) ; if ( ! File :: exists ( $ path ) ) { return '' ; } return file_get_contents ( $ path ) ; }
3560	protected function getValueType ( $ value ) { $ type = is_object ( $ value ) ? get_class ( $ value ) : gettype ( $ value ) ; return ( $ type == 'double' ) ? 'float' : $ type ; }
12172	public static function getDefaultForCallable ( $ callable , array $ params = array ( ) ) { if ( $ callable instanceof Closure ) { $ factory = new static ( $ callable , 'closure' ) ; $ factory -> addOptionalClassArgument ( '$container' , 'Autarky\Container\ContainerInterface' ) ; return $ factory -> getFactory ( $ params ) ; } return static :: getFromReflection ( $ callable , null ) -> getFactory ( $ params ) ; }
9112	public function setVisitTime ( $ visitTime ) { if ( $ visitTime instanceof \ DateTime ) { $ this -> visitTime = $ visitTime ; } else { $ this -> visitTime = new \ DateTime ( $ visitTime ) ; } return $ this ; }
6555	public function stop ( $ reason ) { $ this -> log ( $ reason , LogLevel :: INFO ) ; $ this -> stopped = true ; }
4544	public function kernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof ValidationException ) { return ; } $ data = [ 'type' => 'https://tools.ietf.org/html/rfc2616#section-10' , 'title' => 'An error occurred' ] ; if ( in_array ( $ this -> environment , [ 'dev' , 'test' ] , true ) ) { $ data [ 'detail' ] = $ exception -> getMessage ( ) ; $ data [ 'trace' ] = $ exception -> getTrace ( ) ; } $ request = $ event -> getRequest ( ) ; $ contentTypes = $ request -> getAcceptableContentTypes ( ) ; $ accept = array_shift ( $ contentTypes ) ; switch ( $ accept ) { case 'application/json' : case 'application/ld+json' : $ code = Response :: HTTP_INTERNAL_SERVER_ERROR ; if ( $ exception instanceof HttpException ) { $ code = $ exception -> getStatusCode ( ) ; } $ response = new JsonResponse ( $ data , $ code ) ; $ event -> setResponse ( $ response ) ; break ; } }
11473	public function destroy ( ResponseRequest $ request , Response $ response ) { try { $ id = $ response [ 'question_id' ] ; $ question = $ this -> question -> selectquestion ( $ id ) ; $ response -> delete ( ) ; return redirect ( '/discussion/' . $ question [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/response/' . $ response -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
5696	protected function getFormActionFromRequest ( HTTPRequest $ r ) { $ action = $ r -> requestVar ( 'action' ) ; $ formAction = $ this -> record -> findActionByName ( $ action ) ; if ( ! $ formAction instanceof BetterButtonNestedForm ) { throw new Exception ( "Action $action doesn't exist or is not a BetterButtonNestedForm" ) ; } return $ formAction ; }
1795	private function addFrontendRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/{alias}' . $ this -> urlSuffix , $ defaults , [ 'alias' => '.+' ] ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_frontend' , $ route ) ; }
2262	public function query ( $ strQuery ) { $ objStatement = new Statement ( $ this -> resConnection , $ this -> blnDisableAutocommit ) ; return $ objStatement -> query ( $ strQuery ) ; }
117	protected function getCommand ( $ cmd , $ url , $ path = null ) { $ cmd = sprintf ( '%s %s%s %s' , $ cmd , '--non-interactive ' , $ this -> getCredentialString ( ) , ProcessExecutor :: escape ( $ url ) ) ; if ( $ path ) { $ cmd .= ' ' . ProcessExecutor :: escape ( $ path ) ; } return $ cmd ; }
2271	public function getUuid ( ) { static $ ids ; if ( empty ( $ ids ) ) { $ statement = $ this -> resConnection -> executeQuery ( implode ( ' UNION ALL ' , array_fill ( 0 , 10 , "SELECT UNHEX(REPLACE(UUID(), '-', '')) AS uuid" ) ) ) ; $ ids = $ statement -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; } return array_pop ( $ ids ) ; }
4328	public static function parseAttribString ( $ str , $ dataDecode = true ) { $ attribs = array ( ) ; $ regexAttribs = '/\b([\w\-]+)\b(?: \s*=\s*(["\'])(.*?)\\2 | \s*=\s*(\S+) )?/xs' ; \ preg_match_all ( $ regexAttribs , $ str , $ matches ) ; $ keys = \ array_map ( 'strtolower' , $ matches [ 1 ] ) ; $ values = \ array_replace ( $ matches [ 3 ] , \ array_filter ( $ matches [ 4 ] , 'strlen' ) ) ; foreach ( $ keys as $ i => $ k ) { $ attribs [ $ k ] = $ values [ $ i ] ; if ( \ in_array ( $ k , self :: $ htmlBoolAttr ) ) { $ attribs [ $ k ] = true ; } } \ ksort ( $ attribs ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_string ( $ v ) ) { $ attribs [ $ k ] = \ htmlspecialchars_decode ( $ v ) ; } $ isDataAttrib = \ strpos ( $ k , 'data-' ) === 0 ; if ( $ isDataAttrib && $ dataDecode ) { $ val = $ attribs [ $ k ] ; $ attribs [ $ k ] = \ json_decode ( $ attribs [ $ k ] , true ) ; if ( $ attribs [ $ k ] === null && $ val !== 'null' ) { $ attribs [ $ k ] = \ json_decode ( '"' . $ val . '"' , true ) ; } } } return $ attribs ; }
2344	protected function createIfNotExists ( ) { if ( file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { return ; } if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strFile , 'wb' ) ) { throw new \ Exception ( sprintf ( 'Cannot create file "%s"' , $ this -> strFile ) ) ; } }
2251	public static function convertRelativeUrls ( $ strContent , $ strBase = '' , $ blnHrefOnly = false ) { if ( $ strBase == '' ) { $ strBase = Environment :: get ( 'base' ) ; } $ search = $ blnHrefOnly ? 'href' : 'href|src' ; $ arrUrls = preg_split ( '/((' . $ search . ')="([^"]+)")/i' , $ strContent , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; $ strContent = '' ; for ( $ i = 0 , $ c = \ count ( $ arrUrls ) ; $ i < $ c ; $ i += 4 ) { $ strContent .= $ arrUrls [ $ i ] ; if ( ! isset ( $ arrUrls [ $ i + 2 ] ) ) { continue ; } $ strAttribute = $ arrUrls [ $ i + 2 ] ; $ strUrl = $ arrUrls [ $ i + 3 ] ; if ( ! preg_match ( '@^(?:[a-z0-9]+:|#)@i' , $ strUrl ) ) { $ strUrl = $ strBase . ( ( $ strUrl != '/' ) ? $ strUrl : '' ) ; } $ strContent .= $ strAttribute . '="' . $ strUrl . '"' ; } return $ strContent ; }
12863	protected function getCachedIdentityService ( Cache $ cache , array $ options ) : CachedIdentityService { if ( ! isset ( $ options [ 'authUrl' ] ) ) { throw new \ InvalidArgumentException ( "'authUrl' is a required option" ) ; } $ stack = HandlerStack :: create ( ) ; if ( ! empty ( $ options [ 'debugLog' ] ) && ! empty ( $ options [ 'logger' ] ) && ! empty ( $ options [ 'messageFormatter' ] ) ) { $ stack -> push ( GuzzleMiddleware :: log ( $ options [ 'logger' ] , $ options [ 'messageFormatter' ] ) ) ; } $ clientOptions = [ 'base_uri' => Utils :: normalizeUrl ( $ options [ 'authUrl' ] ) , 'handler' => $ stack , ] ; if ( isset ( $ options [ 'requestOptions' ] ) ) { $ clientOptions = array_merge ( $ options [ 'requestOptions' ] , $ clientOptions ) ; } $ service = CachedIdentityService :: factory ( new Client ( $ clientOptions ) ) ; $ service -> setCache ( $ cache ) ; return $ service ; }
3045	protected function getAssessmentsFromDelivery ( \ core_kernel_classes_Resource $ compiledDelivery ) { $ unionAssignmentService = $ this -> getServiceLocator ( ) -> get ( UnionAssignmentService :: SERVICE_ID ) ; $ runtime = $ unionAssignmentService -> getRuntime ( $ compiledDelivery ) ; $ inputParameters = \ tao_models_classes_service_ServiceCallHelper :: getInputValues ( $ runtime , [ ] ) ; $ testDefinition = \ taoQtiTest_helpers_Utils :: getTestDefinition ( $ inputParameters [ 'QtiTestCompilation' ] ) ; $ assessmentItemRefs = $ testDefinition -> getComponentsByClassName ( 'assessmentItemRef' ) ; $ this -> report -> add ( new Report ( Report :: TYPE_INFO , "Starting to recompile items for delivery {$compiledDelivery->getLabel()} with identifier {$compiledDelivery->getUri()}:" ) ) ; $ count = 0 ; foreach ( $ assessmentItemRefs as $ assessmentItemRef ) { $ directoryIds = explode ( '|' , $ assessmentItemRef -> getHref ( ) ) ; $ item = $ this -> getResource ( $ directoryIds [ 0 ] ) ; $ properties = [ ] ; foreach ( $ item -> getRdfTriples ( ) as $ triple ) { $ properties [ $ triple -> predicate ] = $ triple -> object ; } if ( $ properties ) { $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 2 ] ) ; $ languages = $ item -> getUsedLanguages ( $ this -> getProperty ( \ taoItems_models_classes_ItemsService :: PROPERTY_ITEM_CONTENT ) ) ; foreach ( $ languages as $ lang ) { $ path = $ lang . DIRECTORY_SEPARATOR . QtiJsonItemCompiler :: METADATA_FILE_NAME ; if ( ! $ directory -> has ( $ path ) ) { $ this -> writeMetadata ( $ item , $ directory , $ path , $ properties ) ; $ count ++ ; } } } } $ this -> report -> add ( new Report ( Report :: TYPE_INFO , "Was updated {$count} items." ) ) ; }
1847	protected function parseArticles ( $ objArticles , $ blnAddArchive = false ) { $ limit = $ objArticles -> count ( ) ; if ( $ limit < 1 ) { return array ( ) ; } $ count = 0 ; $ arrArticles = array ( ) ; while ( $ objArticles -> next ( ) ) { $ objArticle = $ objArticles -> current ( ) ; $ arrArticles [ ] = $ this -> parseArticle ( $ objArticle , $ blnAddArchive , ( ( ++ $ count == 1 ) ? ' first' : '' ) . ( ( $ count == $ limit ) ? ' last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' odd' : ' even' ) , $ count ) ; } return $ arrArticles ; }
2223	protected function doGetTemplateFolders ( $ path , $ level = 0 ) { $ return = array ( ) ; $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( scan ( $ rootDir . '/' . $ path ) as $ file ) { if ( is_dir ( $ rootDir . '/' . $ path . '/' . $ file ) ) { $ return [ $ path . '/' . $ file ] = str_repeat ( ' &nbsp; &nbsp; ' , $ level ) . $ file ; $ return = array_merge ( $ return , $ this -> doGetTemplateFolders ( $ path . '/' . $ file , $ level + 1 ) ) ; } } return $ return ; }
11098	public static function secondsBetweenWorkingDays ( $ dateFrom , $ dateTo , $ workDayFrom , $ workDayTo , $ weekends = false , $ holidays = false , $ timeZone = 'Europe/Prague' ) { $ timeZoneObj = new \ DateTimeZone ( $ timeZone ) ; $ dateFromObj = new DateTime ( $ dateFrom , $ timeZoneObj ) ; $ dateToObj = new DateTime ( $ dateTo , $ timeZoneObj ) ; $ workDayFromObj = new DateTime ( $ workDayFrom , $ timeZoneObj ) ; $ workDayToObj = new DateTime ( $ workDayTo , $ timeZoneObj ) ; $ workDayLength = self :: secondsBetweenDates ( $ workDayFrom , $ workDayTo , true , $ timeZone ) ; $ period = new \ DatePeriod ( new DateTime ( $ dateFromObj -> format ( 'Y-m-d 00:00:00' ) , $ timeZoneObj ) , new \ DateInterval ( 'P1D' ) , new DateTime ( $ dateToObj -> format ( 'Y-m-d 23:59:59' ) , $ timeZoneObj ) ) ; $ workedTime = 0 ; foreach ( $ period as $ date ) { if ( ( ! $ weekends && ( int ) $ date -> format ( 'N' ) > 5 ) || ( ! $ holidays && self :: isCzechHoliday ( $ date ) ) ) { continue ; } if ( $ date -> format ( 'Y-m-d' ) === $ dateFromObj -> format ( 'Y-m-d' ) ) { $ endOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayToObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateFromObj < $ endOfDay && $ dateFromObj -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ diff = $ dateToObj -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } else { $ diff = $ endOfDay -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } elseif ( $ date -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ startOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayFromObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateToObj > $ startOfDay ) { $ diff = $ startOfDay -> diff ( $ dateToObj ) -> format ( '%H:%I:%S' ) ; $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } } else { $ workedTime += $ workDayLength ; } } return $ workedTime ; }
1208	public function moveChildToPosition ( ItemInterface $ item , ItemInterface $ child , $ position ) { $ name = $ child -> getName ( ) ; $ order = array_keys ( $ item -> getChildren ( ) ) ; $ oldPosition = array_search ( $ name , $ order ) ; unset ( $ order [ $ oldPosition ] ) ; $ order = array_values ( $ order ) ; array_splice ( $ order , $ position , 0 , $ name ) ; $ item -> reorderChildren ( $ order ) ; }
11117	protected function rollbackMigrations ( array $ migrations ) : void { $ this -> notify -> note ( '' ) ; foreach ( $ this -> getMigrationFiles ( M :: TYPE_DOWN ) as $ file ) { if ( in_array ( $ name = $ this -> getMigrationName ( $ file ) , $ migrations , true ) ) { $ this -> runDown ( $ file ) ; continue ; } $ this -> notify -> note ( "<fg=red>Migrate not found (in database table):</> {$name}" ) ; } }
2127	protected function fixPaths ( $ content , $ arrFile ) { $ strName = $ arrFile [ 'name' ] ; if ( strpos ( $ strName , $ this -> strWebDir . '/' ) === 0 ) { $ strName = substr ( $ strName , \ strlen ( $ this -> strWebDir ) + 1 ) ; } $ strDirname = \ dirname ( $ strName ) ; $ strGlue = ( $ strDirname != '.' ) ? $ strDirname . '/' : '' ; return preg_replace_callback ( '/url\(("[^"\n]+"|\'[^\'\n]+\'|[^"\'\s()]+)\)/' , function ( $ matches ) use ( $ strDirname , $ strGlue ) { $ strData = $ matches [ 1 ] ; if ( $ strData [ 0 ] == '"' || $ strData [ 0 ] == "'" ) { $ strData = substr ( $ strData , 1 , - 1 ) ; } if ( strncmp ( $ strData , 'data:' , 5 ) === 0 || strncmp ( $ strData , 'http://' , 7 ) === 0 || strncmp ( $ strData , 'https://' , 8 ) === 0 || strncmp ( $ strData , '/' , 1 ) === 0 || strncmp ( $ strData , 'assets/css3pie/' , 15 ) === 0 ) { return $ matches [ 0 ] ; } if ( strncmp ( $ strData , '../' , 3 ) !== 0 ) { $ strData = '../../' . $ strGlue . $ strData ; } else { $ dir = $ strDirname ; while ( strncmp ( $ strData , '../' , 3 ) === 0 ) { $ dir = \ dirname ( $ dir ) ; $ strData = substr ( $ strData , 3 ) ; } $ glue = ( $ dir != '.' ) ? $ dir . '/' : '' ; $ strData = '../../' . $ glue . $ strData ; } $ strQuote = '' ; if ( $ matches [ 1 ] [ 0 ] == "'" || $ matches [ 1 ] [ 0 ] == '"' ) { $ strQuote = $ matches [ 1 ] [ 0 ] ; } if ( preg_match ( '/[(),\s"\']/' , $ strData ) ) { if ( $ matches [ 1 ] [ 0 ] == "'" ) { $ strData = str_replace ( "'" , "\\'" , $ strData ) ; } else { $ strQuote = '"' ; $ strData = str_replace ( '"' , '\"' , $ strData ) ; } } return 'url(' . $ strQuote . $ strData . $ strQuote . ')' ; } , $ content ) ; }
12293	public function update ( array $ data , $ id ) { $ resource = $ this -> model -> find ( $ id ) ; if ( ! $ resource ) { return '' ; } $ resource -> update ( $ data ) ; return $ resource ; }
433	public function setModules ( $ modules ) { foreach ( $ modules as $ id => $ module ) { $ this -> _modules [ $ id ] = $ module ; } }
6040	public function download ( $ sessionId , array $ downloads ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'downloads' => $ downloads ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/download' , $ parameters , true ) ; return $ result ; }
1892	public function accept ( ) { if ( strncmp ( $ this -> current ( ) -> getFilename ( ) , '.' , 1 ) === 0 ) { return false ; } $ strPath = $ this -> current ( ) -> getPathname ( ) ; if ( is_file ( $ strPath ) ) { $ strPath = \ dirname ( $ strPath ) ; } $ objFolder = new Folder ( StringUtil :: stripRootDir ( $ strPath ) ) ; return ! $ objFolder -> isUnsynchronized ( ) ; }
4773	public function order ( Request $ request , WidgetInterface $ widget , string $ widgetId , int $ order ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'order' => $ order ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> json ( [ 'result' => 'success' , ] ) ; }
4887	public function createAttachedEntity ( $ entityClass , $ values = [ ] , $ key = null ) { if ( is_string ( $ values ) ) { $ key = $ values ; $ values = [ ] ; } $ entity = $ this -> repositories -> getRepository ( $ entityClass ) -> create ( $ values ) ; $ this -> addAttachedEntity ( $ entity , $ key ) ; return $ entity ; }
644	public function addDefaultValue ( $ name , $ table , $ column , $ value ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addDefaultValue ( $ name , $ table , $ column , $ value ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
8145	public function getParser ( ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 1.25 and will be removed in 2.0.' , __FUNCTION__ ) , E_USER_DEPRECATED ) ; if ( null === $ this -> parser ) { $ this -> parser = new Twig_Parser ( $ this ) ; } return $ this -> parser ; }
1453	protected function excluded ( string ... $ keys ) : Collection { return collect ( $ keys ) -> mapWithKeys ( function ( $ key ) { return [ $ key => new DisallowedParameter ( $ key ) ] ; } ) ; }
12164	private function createAuthorityTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?authority`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?authority` ( `authority_id` bigint(20) NOT NULL AUTO_INCREMENT, `authority_title` varchar(100) NOT NULL, `authority_parent_id` bigint(20) NOT NULL, `authority_name` varchar(45) NOT NULL COMMENT ' ', `authority_description` varchar(255) DEFAULT NULL, `lft` int(11) NOT NULL, `rgt` int(11) NOT NULL, PRIMARY KEY (`authority_id`), UNIQUE KEY `authority_name_UNIQUE` (`authority_name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=5 ;" ) ; $ this -> database -> query ( "INSERT INTO `?authority` (`authority_id`, `authority_title`, `authority_parent_id`, `authority_name`, `authority_description`, `lft`, `rgt`) VALUES (1, 'PUBLIC', 0, 'PUBLIC', 'All unregistered nodes, users and applications', 1, 8), (2, 'Registered Users', 1, 'REGISTEREDUSERS', 'All registered nodes with a known unique identifier', 2, 7), (3, 'Moderators', 2, 'MODERATORS', 'System moderators, Users allowed to manage user generated import', 3, 6), (4, 'Super Administrators', 3, 'MASTERADMINISTRATORS', 'Special users with awesome powers', 4, 5);" ) ; }
9397	protected function escape ( array $ options ) { $ results = [ ] ; foreach ( $ options as $ key => $ value ) { if ( ! in_array ( $ key , $ this -> safe ) ) { $ results [ $ key ] = escapeshellarg ( $ value ) ; } else { $ results [ $ key ] = $ value ; } } return $ results ; }
988	public function activate ( ) { if ( ! $ this -> chargeId ) { throw new Exception ( 'Can not activate plan without a charge ID.' ) ; } $ this -> response = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}/{$this->chargeId}/activate.json" ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ this -> response ; }
393	protected static function filterValidColumnNames ( $ db , array $ aliases ) { $ columnNames = [ ] ; $ tableName = static :: tableName ( ) ; $ quotedTableName = $ db -> quoteTableName ( $ tableName ) ; foreach ( static :: getTableSchema ( ) -> getColumnNames ( ) as $ columnName ) { $ columnNames [ ] = $ columnName ; $ columnNames [ ] = $ db -> quoteColumnName ( $ columnName ) ; $ columnNames [ ] = "$tableName.$columnName" ; $ columnNames [ ] = $ db -> quoteSql ( "$quotedTableName.[[$columnName]]" ) ; foreach ( $ aliases as $ tableAlias ) { $ columnNames [ ] = "$tableAlias.$columnName" ; $ quotedTableAlias = $ db -> quoteTableName ( $ tableAlias ) ; $ columnNames [ ] = $ db -> quoteSql ( "$quotedTableAlias.[[$columnName]]" ) ; } } return $ columnNames ; }
4846	public static function register ( array $ aliases ) { if ( ! $ aliases ) { return ; } if ( ! isset ( self :: $ autoloadFn ) ) { $ classAliases = & self :: $ aliases ; self :: $ autoloadFn = function ( $ className ) use ( & $ classAliases ) { if ( isset ( $ classAliases [ $ className ] ) ) { if ( strtolower ( $ classAliases [ $ className ] ) === strtolower ( $ className ) ) { throw new \ LogicException ( "Class alias is referencing the alias itself" ) ; } $ facadeClass = $ classAliases [ $ className ] ; class_alias ( $ facadeClass , $ className ) ; } } ; spl_autoload_register ( self :: $ autoloadFn ) ; } self :: $ aliases = array_merge ( self :: $ aliases , $ aliases ) ; }
6802	public function installTaxGroups ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ taxGroupRepository = $ this -> manager -> getRepository ( TaxGroup :: class ) ; $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_tax_groups.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Tax groups data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( $ datum [ 'default' ] ) { $ taxGroup = $ this -> manager -> getRepository ( TaxGroup :: class ) -> findOneBy ( [ 'default' => true ] ) ; if ( null !== $ taxGroup ) { call_user_func ( $ this -> log , $ name , 'skipped' ) ; continue ; } } if ( null === $ taxGroupRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ taxGroup = new TaxGroup ( ) ; $ taxGroup -> setName ( $ name ) -> setDefault ( $ datum [ 'default' ] ) ; if ( ! empty ( $ taxNames = $ datum [ 'taxes' ] ) ) { $ taxGroup -> setTaxes ( $ taxRepository -> findBy ( [ 'name' => $ taxNames ] ) ) ; } $ this -> manager -> persist ( $ taxGroup ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
1903	public function limit ( $ intRows , $ intOffset = 0 ) { if ( $ intRows <= 0 ) { $ intRows = 30 ; } if ( $ intOffset < 0 ) { $ intOffset = 0 ; } if ( strncasecmp ( $ this -> strQuery , 'SELECT' , 6 ) === 0 ) { $ this -> strQuery .= ' LIMIT ' . $ intOffset . ',' . $ intRows ; } else { $ this -> strQuery .= ' LIMIT ' . $ intRows ; } return $ this ; }
7920	private function openZipFile ( $ zipFile ) { $ zipArchive = new \ ZipArchive ; if ( $ zipArchive -> open ( $ zipFile ) !== true ) { throw new \ Exception ( 'Error opening ' . $ zipFile ) ; } return $ zipArchive ; }
8643	public function cancelReportRequests ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_CancelReportRequestsRequest ) { $ request = new MarketplaceWebService_Model_CancelReportRequestsRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertCancelReportRequests ( $ request ) ) ; $ response = MarketplaceWebService_Model_CancelReportRequestsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3532	public static function sendFortnitePostRequest ( $ endpoint , $ access_token , $ params = null ) { $ client = new Client ( ) ; try { $ response = $ client -> post ( $ endpoint , [ 'json' => $ params , 'headers' => [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
12417	static function run_copy_paste_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcpd = self :: getTool ( 'phpcpd' , $ opts , true ) ; try { $ out = pake_sh ( "$phpcpd " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcpd.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
6574	private function isSessionValid ( SessionDataHolder $ session , ServerRequestInterface $ request ) : bool { if ( ( $ lastReq = $ session -> getLastRequestTime ( ) ) && ( $ lastReq + $ this -> getExpire ( ) * 60 ) < time ( ) ) { return false ; } if ( $ this -> getValidateClientIp ( ) && ( $ clientIp = $ session -> getClientIp ( ) ) && isset ( $ request -> getServerParams ( ) [ 'REMOTE_ADDR' ] ) && $ clientIp != $ request -> getServerParams ( ) [ 'REMOTE_ADDR' ] ) { return false ; } return true ; }
9718	private function writePalette ( ) { $ aref = $ this -> palette ; $ record = 0x0092 ; $ length = 2 + 4 * count ( $ aref ) ; $ ccv = count ( $ aref ) ; $ data = '' ; foreach ( $ aref as $ color ) { foreach ( $ color as $ byte ) { $ data .= pack ( 'C' , $ byte ) ; } } $ header = pack ( 'vvv' , $ record , $ length , $ ccv ) ; $ this -> append ( $ header . $ data ) ; }
7610	public function signup ( ) { if ( $ this -> validate ( ) ) { $ user = new User ( ) ; $ user -> username = $ this -> username ; $ user -> email = $ this -> email ; $ user -> setPassword ( $ this -> password ) ; $ user -> generateAuthKey ( ) ; if ( $ user -> save ( ) ) { return $ user ; } } return null ; }
7365	protected function resolveOutstandingDate ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return null ; } if ( ! $ sale instanceof ShipmentSubjectInterface ) { return null ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { return null ; } if ( ! $ this -> saleHasOutstandingPayments ( $ sale ) ) { return null ; } $ from = null ; switch ( $ term -> getTrigger ( ) ) { case PaymentTermTriggers :: TRIGGER_SHIPPED : $ from = $ sale -> getShippedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_SHIPPED : if ( $ sale -> getShipmentState ( ) === ShipmentStates :: STATE_COMPLETED ) { $ from = $ sale -> getShippedAt ( true ) ; } break ; case PaymentTermTriggers :: TRIGGER_INVOICED : $ from = $ sale -> getInvoicedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_INVOICED : if ( $ sale -> getInvoiceState ( ) === InvoiceStates :: STATE_COMPLETED ) { $ from = $ sale -> getInvoicedAt ( true ) ; } break ; } if ( null === $ from ) { return null ; } $ date = clone $ from ; $ date -> setTime ( 23 , 59 , 59 ) ; $ date -> modify ( sprintf ( '+%s days' , $ term -> getDays ( ) ) ) ; if ( $ term -> getEndOfMonth ( ) ) { $ date -> modify ( 'last day of this month' ) ; } return $ date ; }
11298	public function getModelsFromCustomRelationship ( $ attributeName , $ objName , $ query = false , $ loadMap = false ) { $ repo = \ Cora \ RepositoryFactory :: make ( $ objName , false , false , false , $ this -> model_db ) ; if ( ! $ query ) $ query = $ this -> _getQueryObjectForRelation ( $ attributeName ) ; $ definingFunctionName = $ this -> model_attributes [ $ attributeName ] [ 'using' ] ; $ query = $ this -> $ definingFunctionName ( $ query ) ; return $ repo -> findAll ( $ query , false , $ loadMap ) ; }
3871	protected function getLanguage ( $ singleLanguage , $ metaModels ) { if ( ! empty ( $ singleLanguage ) ) { return array ( $ singleLanguage ) ; } elseif ( $ metaModels -> isTranslated ( ) && $ metaModels -> getAvailableLanguages ( ) ) { return $ metaModels -> getAvailableLanguages ( ) ; } return array ( $ GLOBALS [ 'TL_LANGUAGE' ] ) ; }
6859	protected static function solsticeDecember ( $ year , $ vsop = true ) { $ month = 12 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
2340	protected function getEditUrl ( ) { if ( $ this -> strEditUrl !== null ) { return sprintf ( $ this -> strEditUrl , $ this -> intPid ) ; } $ strUrl = Environment :: get ( 'request' ) ; if ( preg_match ( '/&(amp;)?state=/' , $ strUrl ) ) { $ strUrl = preg_replace ( array ( '/&(amp;)?id=[^&]+/' , '/(&(amp;)?)t(id=[^&]+)/' , '/(&(amp;)?)state=[^&]*/' ) , array ( '' , '$1$3' , '$1act=edit' ) , $ strUrl ) ; } if ( preg_match ( '/do=login(&|$)/' , $ strUrl ) ) { $ strUrl = preg_replace ( '/do=login(&|$)/' , 'do=user$1' , $ strUrl ) ; $ strUrl .= '&amp;act=edit&amp;id=' . $ this -> User -> id . '&amp;rt=' . REQUEST_TOKEN ; } $ strUrl = preg_replace ( '/act=(edit|override)All/' , 'act=edit&id=' . $ this -> intPid , $ strUrl ) ; return $ strUrl ; }
5145	public function _after ( \ Codeception \ TestCase $ test ) { if ( isset ( $ this -> config [ 'deleteEmailsAfterScenario' ] ) && $ this -> config [ 'deleteEmailsAfterScenario' ] ) { $ this -> deleteAllEmails ( ) ; } }
9404	protected static function prepare ( Collection & $ collection , $ component ) { $ instance = new $ component ; $ type = $ instance -> type ( ) ; if ( empty ( $ type ) === false ) { $ parameters = array ( $ instance -> get ( ) ) ; $ type === 'http' && $ parameters = $ instance -> get ( ) ; $ class = array ( $ collection , 'set' . ucfirst ( $ type ) ) ; call_user_func_array ( $ class , $ parameters ) ; } return $ instance ; }
2451	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoRequest ( $ event -> getRequest ( ) ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> attributes -> set ( '_locale' , $ this -> getLocale ( $ request ) ) ; }
8617	public function setInvalidSKU ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InvalidSKU' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6772	protected function didInvoiceCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } if ( null !== $ newAddress = $ sale -> getInvoiceAddress ( ) ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
3596	protected function createTables ( ) { $ tablesCreated = false ; $ tableSchema = Craft :: $ app -> db -> schema -> getTableSchema ( '{{%dolphiq_sitemap_entries}}' ) ; if ( $ tableSchema === null ) { $ tablesCreated = true ; $ this -> createTable ( '{{%dolphiq_sitemap_entries}}' , [ 'id' => $ this -> primaryKey ( ) , 'dateCreated' => $ this -> dateTime ( ) -> notNull ( ) , 'dateUpdated' => $ this -> dateTime ( ) -> notNull ( ) , 'uid' => $ this -> uid ( ) , 'linkId' => $ this -> integer ( ) -> notNull ( ) , 'type' => $ this -> string ( 30 ) -> notNull ( ) -> defaultValue ( '' ) , 'priority' => $ this -> double ( 2 ) -> notNull ( ) -> defaultValue ( 0.5 ) , 'changefreq' => $ this -> string ( 30 ) -> notNull ( ) -> defaultValue ( '' ) , ] ) ; } return $ tablesCreated ; }
8058	public function setWorkerPoolSize ( $ size ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Worker Pool Size for a created pool.' ) ; } $ size = ( int ) $ size ; if ( $ size <= 0 ) { throw new \ InvalidArgumentException ( '"' . $ size . '" is not an integer greater than 0.' ) ; } $ this -> workerPoolSize = $ size ; return $ this ; }
6761	public function find ( $ criteria ) { if ( ! $ criteria ) { error_log ( "collection error: no criteria specified" ) ; return null ; } else if ( is_callable ( $ criteria ) ) { foreach ( $ this -> models as $ model ) if ( $ criteria ( $ model ) ) return $ model ; } else if ( is_a ( $ criteria , "SnooPHP\Model\Model" ) ) { foreach ( $ this -> models as $ i => $ model ) if ( $ model == $ criteria ) return $ i ; } return null ; }
3784	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getProperty ( ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ dataProvider = $ environment -> getDataProvider ( ) ; $ properties = $ environment -> getDataDefinition ( ) -> getPropertiesDefinition ( ) ; $ values = ( array ) $ event -> getValue ( ) ; foreach ( $ values as $ row => $ current ) { $ values [ $ row ] = $ this -> updateValues ( $ current , $ properties , $ dataProvider ) ; } $ event -> setValue ( $ values ) ; }
1874	private function addComponents ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; foreach ( Versions :: VERSIONS as $ name => $ version ) { if ( 0 !== strncmp ( 'contao-components/' , $ name , 18 ) ) { continue ; } $ serviceId = 'assets._package_' . $ name ; $ basePath = 'assets/' . substr ( $ name , 18 ) ; $ version = $ this -> createVersionStrategy ( $ container , $ version , $ name ) ; $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ version , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ name , new Reference ( $ serviceId ) ] ) ; } }
5487	public function submitImage ( SelectorInterface $ selector , $ x , $ y , $ additional = false ) { $ additional = $ additional ? $ additional : array ( ) ; foreach ( $ this -> images as $ image ) { if ( $ selector -> isMatch ( $ image ) ) { $ encoding = $ this -> encode ( ) ; $ image -> write ( $ encoding , $ x , $ y ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; } } return false ; }
4146	protected function getUrl ( ) { $ domain = $ this -> urls [ 'domain' ] ; $ apiVersion = $ this -> urls [ 'api' ] ; $ jsonExt = '.json' ; if ( isset ( $ this -> withMedia ) && $ this -> withMedia === true ) { $ domain = $ this -> urls [ 'upload' ] ; } if ( $ this -> call === 'oauth/request_token' || $ this -> call === 'oauth/access_token' ) { $ apiVersion = '' ; $ jsonExt = '' ; } return $ domain . $ apiVersion . $ this -> call . $ jsonExt ; }
10897	public function setScheme ( $ scheme ) { foreach ( $ this -> uris as $ name => $ uri ) { $ this -> add ( $ name , $ uri -> withScheme ( $ scheme ) ) ; } }
1882	protected function getMD5Folders ( $ strPath ) { $ arrFiles = array ( ) ; foreach ( scan ( $ this -> strRootDir . '/' . $ strPath ) as $ strFile ) { if ( ! is_dir ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) ) { continue ; } $ arrFiles [ substr ( md5 ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) , 0 , 8 ) ] = 1 ; foreach ( $ this -> getMD5Folders ( $ strPath . '/' . $ strFile ) as $ k => $ v ) { $ arrFiles [ $ k ] = $ v ; } } return $ arrFiles ; }
11708	public function actionCreate ( ) { $ user = \ Yii :: createObject ( [ 'class' => User :: className ( ) , 'scenario' => 'create' , ] ) ; $ this -> performAjaxValidation ( $ user ) ; if ( $ user -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ user -> create ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been created' ) ) ; return $ this -> redirect ( [ 'index' ] ) ; } return $ this -> render ( 'create' , [ 'user' => $ user ] ) ; }
5273	public static function table ( $ table_name ) { global $ wpdb ; if ( empty ( self :: $ instances ) || empty ( self :: $ instances [ $ table_name ] ) ) { self :: $ instances [ $ table_name ] = new Query_Builder ( $ wpdb -> prefix . $ table_name ) ; } return self :: $ instances [ $ table_name ] ; }
102	public function findFile ( $ class ) { if ( isset ( $ this -> classMap [ $ class ] ) ) { return $ this -> classMap [ $ class ] ; } if ( $ this -> classMapAuthoritative || isset ( $ this -> missingClasses [ $ class ] ) ) { return false ; } if ( null !== $ this -> apcuPrefix ) { $ file = apcu_fetch ( $ this -> apcuPrefix . $ class , $ hit ) ; if ( $ hit ) { return $ file ; } } $ file = $ this -> findFileWithExtension ( $ class , '.php' ) ; if ( false === $ file && defined ( 'HHVM_VERSION' ) ) { $ file = $ this -> findFileWithExtension ( $ class , '.hh' ) ; } if ( null !== $ this -> apcuPrefix ) { apcu_add ( $ this -> apcuPrefix . $ class , $ file ) ; } if ( false === $ file ) { $ this -> missingClasses [ $ class ] = true ; } return $ file ; }
8434	private function write ( array $ mapping , string $ mappingName , string $ name , array $ up = [ ] , array $ down = [ ] , array $ import = [ ] ) { $ path = rtrim ( $ mapping [ 'config' ] [ 'migrations' ] [ 'path' ] , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; $ path .= $ name . DIRECTORY_SEPARATOR ; if ( file_exists ( $ path . $ name . '.php' ) === true ) { echo 'A migration with this name already exists. Do you want to overwrite it ? [y/n] : ' ; if ( fgetc ( STDIN ) != 'y' ) { return false ; } } if ( is_dir ( $ path ) === false ) { if ( mkdir ( $ path ) === false ) { throw new FileNotWritable ( 'can\'t mkdir "' . $ path . '"' ) ; } } $ path .= $ name . '.php' ; $ file = fopen ( $ path , 'w+' ) ; if ( $ file === false ) { throw new FileNotWritable ( 'can\'t open "' . $ path . '" with write permission' ) ; } $ content = "<?php\n\nnamespace " . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'migrations' ] [ 'namespace' ] , '\\' ) , '\\' ) . '\\' . $ name . ";\n\nuse " . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Migration;' . PHP_EOL ; if ( count ( $ import ) >= 1 ) { $ content .= 'use ' . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Mutation\\{' ; $ content .= implode ( ', ' , $ import ) . "};\n" ; } $ up = implode ( '' , array_map ( function ( string $ a ) { return ' ' . $ a . '->execute();' . PHP_EOL ; } , $ up ) ) ; $ down = implode ( '' , array_map ( function ( string $ a ) { return ' ' . $ a . '->execute();' . PHP_EOL ; } , $ down ) ) ; var_dump ( $ up ) ; $ content .= "\nclass " . $ name . " extends Migration\n{\n" ; $ content .= ' const NAME = \'' . $ name . "';\n\n" ; $ content .= " public function getMappingName() : string\n {\n return '" . $ mappingName . "';\n }\n\n" ; $ content .= " public function up()\n {\n" . $ up . " }\n\n" ; $ content .= " public function down()\n {\n" . $ down . " }\n" ; $ content .= "}" ; if ( fwrite ( $ file , $ content ) === false ) { throw new FileNotWritable ( 'can\'t write in "' . $ path . '"' ) ; } fclose ( $ file ) ; return true ; }
5976	public function media ( ) { if ( ! $ this -> media instanceof MediaController ) { $ this -> media = new MediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> media -> setLogger ( $ this -> logger ) ; } return $ this -> media ; }
9206	public function importTables ( array $ data ) { $ tableCount = count ( $ data ) ; $ this -> out ( "<info>Starting seed of {$tableCount} table(s).</info>" ) ; foreach ( $ data as $ table => $ records ) { $ this -> out ( "<info>{$table}</info>" ) ; $ defaults = [ ] ; if ( array_key_exists ( '_defaults' , $ records ) ) { $ defaults = $ records [ '_defaults' ] ; unset ( $ records [ '_defaults' ] ) ; $ this -> verbose ( "<success>{$table}: Default values set.</success>" ) ; } $ entityOptions = [ ] ; if ( array_key_exists ( '_options' , $ records ) ) { $ entityOptions = $ records [ '_options' ] ; unset ( $ records [ '_options' ] ) ; $ this -> verbose ( "<success>{$table}: Entity options set, but...</success>" ) ; $ this -> quiet ( "<warning>{$table}: Deprecation notice: Change [_options] to [_entityOptions].</warning>" ) ; } elseif ( array_key_exists ( '_entityOptions' , $ records ) ) { $ entityOptions = $ records [ '_entityOptions' ] ; unset ( $ records [ '_entityOptions' ] ) ; $ this -> verbose ( "<success>{$table}: Entity options set.</success>" ) ; } $ saveOptions = [ ] ; if ( array_key_exists ( '_saveOptions' , $ records ) ) { $ saveOptions = $ records [ '_saveOptions' ] ; unset ( $ records [ '_saveOptions' ] ) ; $ this -> verbose ( "<success>{$table}: Table save() options set.</success>" ) ; } $ Table = $ this -> loadModel ( $ table ) ; if ( array_key_exists ( '_truncate' , $ records ) && $ records [ '_truncate' ] ) { $ this -> truncateTable ( $ Table ) ; } unset ( $ records [ '_truncate' ] ) ; $ this -> importTable ( $ Table , $ this -> entityGenerator ( $ Table , $ records , $ defaults , $ entityOptions ) , $ saveOptions ) ; } $ this -> out ( "<info>Seeding complete.</info>" ) ; }
5408	protected function isMatch ( $ cookie , $ host , $ path , $ name ) { if ( $ cookie -> getName ( ) != $ name ) { return false ; } if ( $ host && $ cookie -> getHost ( ) && ! $ cookie -> isValidHost ( $ host ) ) { return false ; } if ( ! $ cookie -> isValidPath ( $ path ) ) { return false ; } return true ; }
930	public function transform ( Tokens $ tokens ) { foreach ( $ this -> items as $ transformer ) { foreach ( $ tokens as $ index => $ token ) { $ transformer -> process ( $ tokens , $ token , $ index ) ; } } }
3508	private static function doCharDiff ( $ from_text , $ to_text ) { $ result = array ( ) ; $ jobs = array ( array ( 0 , strlen ( $ from_text ) , 0 , strlen ( $ to_text ) ) ) ; while ( $ job = array_pop ( $ jobs ) ) { list ( $ from_segment_start , $ from_segment_end , $ to_segment_start , $ to_segment_end ) = $ job ; $ from_segment_len = $ from_segment_end - $ from_segment_start ; $ to_segment_len = $ to_segment_end - $ to_segment_start ; if ( ! $ from_segment_len || ! $ to_segment_len ) { if ( $ from_segment_len ) { $ result [ $ from_segment_start * 4 + 0 ] = new FineDiffDeleteOp ( $ from_segment_len ) ; } else if ( $ to_segment_len ) { $ result [ $ from_segment_start * 4 + 1 ] = new FineDiffInsertOp ( substr ( $ to_text , $ to_segment_start , $ to_segment_len ) ) ; } continue ; } if ( $ from_segment_len >= $ to_segment_len ) { $ copy_len = $ to_segment_len ; while ( $ copy_len ) { $ to_copy_start = $ to_segment_start ; $ to_copy_start_max = $ to_segment_end - $ copy_len ; while ( $ to_copy_start <= $ to_copy_start_max ) { $ from_copy_start = strpos ( substr ( $ from_text , $ from_segment_start , $ from_segment_len ) , substr ( $ to_text , $ to_copy_start , $ copy_len ) ) ; if ( $ from_copy_start !== false ) { $ from_copy_start += $ from_segment_start ; break 2 ; } $ to_copy_start ++ ; } $ copy_len -- ; } } else { $ copy_len = $ from_segment_len ; while ( $ copy_len ) { $ from_copy_start = $ from_segment_start ; $ from_copy_start_max = $ from_segment_end - $ copy_len ; while ( $ from_copy_start <= $ from_copy_start_max ) { $ to_copy_start = strpos ( substr ( $ to_text , $ to_segment_start , $ to_segment_len ) , substr ( $ from_text , $ from_copy_start , $ copy_len ) ) ; if ( $ to_copy_start !== false ) { $ to_copy_start += $ to_segment_start ; break 2 ; } $ from_copy_start ++ ; } $ copy_len -- ; } } if ( $ copy_len ) { $ jobs [ ] = array ( $ from_segment_start , $ from_copy_start , $ to_segment_start , $ to_copy_start ) ; $ result [ $ from_copy_start * 4 + 2 ] = new FineDiffCopyOp ( $ copy_len ) ; $ jobs [ ] = array ( $ from_copy_start + $ copy_len , $ from_segment_end , $ to_copy_start + $ copy_len , $ to_segment_end ) ; } else { $ result [ $ from_segment_start * 4 ] = new FineDiffReplaceOp ( $ from_segment_len , substr ( $ to_text , $ to_segment_start , $ to_segment_len ) ) ; } } ksort ( $ result , SORT_NUMERIC ) ; return array_values ( $ result ) ; }
9921	private function findManyToManyRelations ( array $ models ) { for ( $ i = 0 ; $ i < sizeof ( $ models ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < sizeof ( $ models ) ; $ j ++ ) { $ model1 = $ models [ $ i ] ; $ model2 = $ models [ $ j ] ; if ( strcasecmp ( $ model1 -> getName ( ) , $ model2 -> getName ( ) ) < 0 ) { $ tableName = strtolower ( $ model1 -> getName ( ) ) . '_' . strtolower ( $ model2 -> getName ( ) ) ; } else { $ tableName = strtolower ( $ model2 -> getName ( ) ) . '_' . strtolower ( $ model1 -> getName ( ) ) ; } if ( $ this -> databaseRepository -> hasTable ( $ tableName ) ) { $ this -> defineManyToManyRelation ( $ model1 , $ model2 ) ; } } } }
11312	public static function buildAuthString ( array $ data ) { $ str = array ( ) ; foreach ( $ data as $ k => $ v ) { $ str [ ] = self :: urlEncode ( $ k ) . '="' . self :: urlEncode ( $ v ) . '"' ; } return implode ( ', ' , $ str ) ; }
8175	protected function optimizePrintNode ( Twig_NodeInterface $ node , Twig_Environment $ env ) { if ( ! $ node instanceof Twig_Node_Print ) { return $ node ; } $ exprNode = $ node -> getNode ( 'expr' ) ; if ( $ exprNode instanceof Twig_Node_Expression_BlockReference || $ exprNode instanceof Twig_Node_Expression_Parent ) { $ exprNode -> setAttribute ( 'output' , true ) ; return $ exprNode ; } return $ node ; }
7778	protected function extractInput ( array $ data ) { $ input = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ input [ $ field ] = $ fieldData [ 0 ] ; } return $ input ; }
4340	private function uncollapseErrors ( & $ log ) { $ groupStack = array ( ) ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ groupStack [ ] = $ i ; } elseif ( $ method == 'groupEnd' ) { \ array_pop ( $ groupStack ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { foreach ( $ groupStack as $ i2 ) { $ log [ $ i2 ] [ 0 ] = 'group' ; } } } }
3074	public function getRubrics ( RunnerServiceContext $ context , AssessmentItemRef $ itemRef = null ) { $ session = $ context -> getTestSession ( ) ; $ routeItem = null ; if ( ! is_null ( $ itemRef ) ) { try { $ routeItem = $ session -> getRoute ( ) -> getRouteItemsByAssessmentItemRef ( $ itemRef ) ; if ( $ routeItem ) { $ routeItem = $ routeItem [ 0 ] ; } } catch ( OutOfBoundsException $ obe ) { \ common_Logger :: d ( "Could not retrieve the route for item '${itemRef}'." ) ; } } else { $ routeItem = $ session -> getRoute ( ) -> current ( ) ; } return implode ( '' , $ this -> getRubricBlock ( $ routeItem , $ session , $ context -> getCompilationDirectory ( ) ) ) ; }
5424	public function expectException ( $ expected = false , $ message = '%s' ) { $ this -> expected = $ this -> forceToExpectation ( $ expected ) ; $ this -> message = $ message ; }
12895	public function setPerson ( \ Chill \ PersonBundle \ Entity \ Person $ person = null ) { $ this -> person = $ person ; return $ this ; }
12323	protected function askQuestions ( InputInterface $ input , OutputInterface $ output ) { foreach ( $ this -> questions as $ question ) { if ( ! $ question -> ask ( $ input , $ output ) ) { return static :: RETURN_ERROR ; } } return static :: RETURN_SUCCESS ; }
2683	public function getWafSettings ( $ id ) { $ url = $ this -> _getWafEndpoint ( ) . $ id ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
10160	private function readMsoDrawing ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingData .= $ recordData ; }
2322	public static function getPixelValue ( $ size ) { @ trigger_error ( 'Using Image::getPixelValue() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ value = preg_replace ( '/[^0-9.-]+/' , '' , $ size ) ; $ unit = preg_replace ( '/[^acehimnprtvwx%]/' , '' , $ size ) ; switch ( $ unit ) { case '' : case 'px' : return ( int ) round ( $ value ) ; break ; case 'em' : return ( int ) round ( $ value * 16 ) ; break ; case 'ex' : return ( int ) round ( $ value * 16 / 2 ) ; break ; case 'pt' : return ( int ) round ( $ value * 16 / 12 ) ; break ; case 'pc' : return ( int ) round ( $ value * 16 ) ; break ; case 'in' : return ( int ) round ( $ value * 16 * 6 ) ; break ; case 'cm' : return ( int ) round ( $ value * 16 / ( 2.54 / 6 ) ) ; break ; case 'mm' : return ( int ) round ( $ value * 16 / ( 25.4 / 6 ) ) ; break ; case '%' : return ( int ) round ( $ value * 16 / 100 ) ; break ; } return 0 ; }
11564	protected function processWeakWord ( $ word ) { $ index = 0 ; $ text = ' ' . $ this -> text . ' ' ; while ( TRUE ) { $ index = mb_strpos ( $ text , ' ' . $ word . ' ' ) ; if ( $ index !== FALSE ) { $ text = mb_substr ( $ text , 0 , $ index + 1 ) . $ word . '&nbsp;' . mb_substr ( $ text , $ index + 1 + mb_strlen ( $ word ) + 1 ) ; $ index += 1 + mb_strlen ( $ word ) + 6 ; } else { break ; } } $ this -> text = mb_substr ( $ text , 1 , mb_strlen ( $ text ) - 2 ) ; }
1648	public function calculateFinalBearing ( Coordinate $ point1 , Coordinate $ point2 ) : float { $ initialBearing = $ this -> calculateBearing ( $ point2 , $ point1 ) ; return fmod ( $ initialBearing + 180 , 360 ) ; }
2376	public static function sanitizeFileName ( $ strName ) { $ strName = preg_replace ( '/[\pC]/u' , '' , $ strName ) ; if ( $ strName === null ) { throw new \ InvalidArgumentException ( 'The file name could not be sanitzied' ) ; } $ strName = str_replace ( array ( '\\' , '/' , ':' , '*' , '?' , '"' , '<' , '>' , '|' ) , '-' , $ strName ) ; return $ strName ; }
8470	public function alert ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'alert' , $ scope , $ message , $ context , $ config ) ; }
8151	public function hasExtension ( $ class ) { $ class = ltrim ( $ class , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } return true ; } return isset ( $ this -> extensionsByClass [ $ class ] ) ; }
5643	public function makeDry ( $ is_dry = true ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> makeDry ( $ is_dry ) ; } }
4921	public function region ( $ region , $ reset = false ) { $ this -> currentRegion = $ region ; if ( $ reset ) { $ this -> matrix [ $ this -> currentRegion ] = [ ] ; } return $ this ; }
10313	function getClicks ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ linkIdFilter = null , $ linkUrlFilter = null , $ linkTagFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ embedEmailClientInfos = false , $ excludeAnonymousClicks = false , $ standardFields = null , $ customFields = null , $ embedFieldBackups = false , $ pageIndex = 1 , $ pageSize = 100 , $ embedLinkTags = false ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null , $ embedFieldBackups ) ; $ params = $ this -> appendArrayFields ( $ params , "standard_field" , $ standardFields ) ; $ params = $ this -> appendArrayFields ( $ params , "custom_field" , $ customFields ) ; if ( isset ( $ embedEmailClientInfos ) ) $ params [ 'embed_email_client_infos' ] = ( $ embedEmailClientInfos == true ) ? "true" : "false" ; if ( isset ( $ embedLinkTags ) ) $ params [ 'embed_link_tags' ] = ( $ embedLinkTags == true ) ? "true" : "false" ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_id" , $ linkIdFilter ) ; if ( isset ( $ linkUrlFilter ) ) $ params [ 'link_url' ] = $ linkUrlFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_tag" , $ linkTagFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/clicks' , $ params ) ; }
8257	protected function startAuthentication ( ) { $ authorizationUrl = $ this -> provider -> getAuthorizationUrl ( ) ; $ this -> session -> migrate ( true ) ; $ this -> session -> set ( "oauth2state" , $ this -> provider -> getState ( ) ) ; $ this -> picoAuth -> redirectToPage ( $ authorizationUrl , null , false ) ; }
1373	public function all ( ) { if ( is_array ( $ this -> data ) ) { return $ this -> data ; } return $ this -> data = $ this -> route -> getCodec ( ) -> all ( $ this -> request ) ; }
4147	protected function getResponse ( ) { $ url = $ this -> getUrl ( ) ; $ params = array ( 'get' => $ this -> getParams , 'post' => $ this -> postParams , 'headers' => $ this -> buildRequestHeader ( ) , ) ; return $ this -> curl -> send ( $ url , $ params ) ; }
5491	protected function describeDifference ( $ expected , $ parameters ) { if ( count ( $ expected ) != count ( $ parameters ) ) { return sprintf ( 'Expected %s arguments of [%s], but got %s arguments of [%s]' , count ( $ expected ) , $ this -> renderArguments ( $ expected ) , count ( $ parameters ) , $ this -> renderArguments ( $ parameters ) ) ; } $ messages = array ( ) ; for ( $ i = 0 ; $ i < count ( $ expected ) ; $ i ++ ) { $ comparison = $ this -> forceToExpectation ( $ expected [ $ i ] ) ; if ( ! $ comparison -> test ( $ parameters [ $ i ] ) ) { $ messages [ ] = 'parameter ' . ( $ i + 1 ) . ' with [' . $ comparison -> overlayMessage ( $ parameters [ $ i ] , $ this -> getDumper ( ) ) . ']' ; } } return 'Parameter expectation differs at ' . implode ( ' and ' , $ messages ) ; }
2710	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ domains = $ this -> api -> getAllDomains ( $ activeVersion ) ; $ storeBaseUrl = $ this -> storeManager -> getStore ( ) -> getBaseUrl ( ) ; if ( ! $ domains ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Domain details.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'domains' => $ domains , 'store' => $ storeBaseUrl ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
6803	public function installTaxRules ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ countryRepository = $ this -> manager -> getRepository ( Country :: class ) ; $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; $ taxRuleRepository = $ this -> manager -> getRepository ( TaxRule :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_tax_rules.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Tax rules data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( null === $ taxRuleRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ taxRule = new TaxRule ( ) ; $ taxRule -> setName ( $ name ) -> setPriority ( $ datum [ 'priority' ] ) -> setCustomer ( $ datum [ 'customer' ] ) -> setBusiness ( $ datum [ 'business' ] ) -> setNotices ( $ datum [ 'notices' ] ) ; if ( ! empty ( $ countryCodes = $ datum [ 'countries' ] ) ) { $ taxRule -> setCountries ( $ countryRepository -> findBy ( [ 'code' => $ countryCodes ] ) ) ; } if ( ! empty ( $ taxNames = $ datum [ 'taxes' ] ) ) { $ taxRule -> setTaxes ( $ taxRepository -> findBy ( [ 'name' => $ taxNames ] ) ) ; } $ this -> manager -> persist ( $ taxRule ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
4667	public function setRenderView ( $ viewPath , $ params ) { $ this -> setViewEngines ( [ '.volt' => function ( $ view = null ) { $ volt = new Volt ( $ view ) ; $ volt -> setOptions ( [ 'compiledPath' => APP_PATH . '/cache/volt/' , 'compiledSeparator' => '_' , 'compileAlways' => ! $ this -> getDI ( ) -> get ( 'config' ) -> application -> production , ] ) ; return $ volt ; } ] ) ; $ view = $ this -> getView ( ) ; $ content = $ view -> render ( $ viewPath , $ params ) ; return $ content ; }
3990	private function getInputScreens ( ) { $ combinations = $ this -> getCombinations ( ) ; if ( null === $ combinations ) { return [ ] ; } $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; if ( $ this -> cache -> contains ( $ cacheKey = 'screens_' . implode ( ',' , $ screenIds ) ) ) { return $ this -> cache -> fetch ( $ cacheKey ) ; } $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ this -> cache -> save ( $ cacheKey , $ screens ) ; return $ screens ; }
9335	public function rad ( ) { if ( $ this -> original -> type == self :: TYPE_RAD ) { return $ this -> original -> value ; } return $ this -> float_rad ; }
3804	private function buildCondition ( $ condition , $ metaModel ) { if ( null === $ condition ) { return null ; } return $ this -> conditionFactory -> createCondition ( $ condition , $ metaModel ) ; }
3682	private function getFilterFactory ( ) : IFilterSettingFactory { if ( null === $ this -> filterFactory ) { return $ this -> filterFactory = System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ; } return $ this -> filterFactory ; }
66	public function isSymlinkedDirectory ( $ directory ) { if ( ! is_dir ( $ directory ) ) { return false ; } $ resolved = $ this -> resolveSymlinkedDirectorySymlink ( $ directory ) ; return is_link ( $ resolved ) ; }
9105	protected function parse_time ( ) { if ( ! empty ( $ this -> args [ 'time' ] ) ) { $ date_query = new \ WP_Date_Query ( $ this -> args [ 'time' ] , 'q.time' ) ; return new Where_Date ( $ date_query ) ; } else { return null ; } }
6216	public static function realmNameToSlug ( string $ name ) : string { $ name = \ mb_strtolower ( $ name , 'UTF-8' ) ; $ slug = \ str_replace ( static :: $ replaceTable [ 0 ] , static :: $ replaceTable [ 1 ] , $ name ) ; $ slug = \ preg_replace ( static :: $ regexTable [ 0 ] , static :: $ regexTable [ 1 ] , $ slug ) ; return \ trim ( ( string ) $ slug , '-' ) ; }
10016	public function addExternalSheet ( Worksheet $ pSheet , $ iSheetIndex = null ) { if ( $ this -> sheetNameExists ( $ pSheet -> getTitle ( ) ) ) { throw new Exception ( "Workbook already contains a worksheet named '{$pSheet->getTitle()}'. Rename the external sheet first." ) ; } $ countCellXfs = count ( $ this -> cellXfCollection ) ; foreach ( $ pSheet -> getParent ( ) -> getCellXfCollection ( ) as $ cellXf ) { $ this -> addCellXf ( clone $ cellXf ) ; } $ pSheet -> rebindParent ( $ this ) ; foreach ( $ pSheet -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ pSheet -> getCell ( $ coordinate ) ; $ cell -> setXfIndex ( $ cell -> getXfIndex ( ) + $ countCellXfs ) ; } return $ this -> addSheet ( $ pSheet , $ iSheetIndex ) ; }
1606	public function findRedirectByPath ( $ path ) { $ redirects = $ this -> findAllRedirects ( true ) ; foreach ( $ redirects as $ redirect ) { $ to = false ; if ( trim ( $ redirect [ 'uri' ] , '/' ) == $ path ) $ to = $ redirect [ 'to' ] ; elseif ( $ uri = $ this -> _isRedirectRegex ( $ redirect [ 'uri' ] ) ) if ( preg_match ( $ uri , $ path ) ) $ to = preg_replace ( $ uri , $ redirect [ 'to' ] , $ path ) ; if ( $ to ) { return [ 'to' => strpos ( $ to , '://' ) !== false ? $ to : UrlHelper :: siteUrl ( $ to ) , 'type' => $ redirect [ 'type' ] , ] ; } } return false ; }
6401	public function getResource ( $ resource ) : ? string { Preconditions :: checkState ( $ this -> isPsr0Compatible ( ) , "Class '%s' must be PSR-0 compatible!" , $ this -> getName ( ) ) ; $ slashedFileName = $ this -> getSlashedFileName ( ) ; $ filePath = $ resource [ 0 ] == '/' ? str_replace ( "/{$this->getSlashedName()}.php" , '' , $ slashedFileName ) . $ resource : dirname ( $ slashedFileName ) . '/' . $ resource ; return is_file ( $ filePath ) ? $ filePath : null ; }
3433	public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ groupBackup = isset ( $ this -> fields [ 'GROUP_ID' ] ) ? $ this -> fields [ 'GROUP_ID' ] : null ; $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; if ( $ groupBackup ) { $ this -> fields [ 'GROUP_ID' ] = $ groupBackup ; } $ this -> fieldsAreFetched = true ; $ this -> original = $ this -> fields ; return $ this -> fields ; }
148	public static function createValidator ( $ type , $ model , $ attributes , $ params = [ ] ) { $ params [ 'attributes' ] = $ attributes ; if ( $ type instanceof \ Closure || ( $ model -> hasMethod ( $ type ) && ! isset ( static :: $ builtInValidators [ $ type ] ) ) ) { $ params [ 'class' ] = __NAMESPACE__ . '\InlineValidator' ; $ params [ 'method' ] = $ type ; } else { if ( isset ( static :: $ builtInValidators [ $ type ] ) ) { $ type = static :: $ builtInValidators [ $ type ] ; } if ( is_array ( $ type ) ) { $ params = array_merge ( $ type , $ params ) ; } else { $ params [ 'class' ] = $ type ; } } return Yii :: createObject ( $ params ) ; }
9227	public function post ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: post ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
1251	private function startElement ( $ parser , $ name , array $ attributes ) { $ this -> metaStack -> push ( $ this -> getPhpMeta ( $ this -> normalizeElementName ( $ name ) , $ attributes ) ) ; }
2225	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( 'html' !== $ request -> getRequestFormat ( ) ) { return ; } if ( ! AcceptHeader :: fromString ( $ request -> headers -> get ( 'Accept' ) ) -> has ( 'text/html' ) ) { return ; } $ this -> handleException ( $ event ) ; }
11331	public function setModel ( $ value ) { $ this -> _model = $ value ; if ( is_object ( $ value ) && $ this -> _attributes ) { $ this -> _model -> attributes = $ this -> _attributes ; } return true ; }
410	public function setHostInfo ( $ value ) { $ this -> _hostName = null ; $ this -> _hostInfo = $ value === null ? null : rtrim ( $ value , '/' ) ; }
8636	public function setShipmentFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2350	public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new Folder ( $ strParent ) ; } $ return = $ this -> Files -> copy ( $ this -> strFile , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { Dbafs :: copyResource ( $ this -> strFile , $ strNewName ) ; } elseif ( $ syncTarget ) { Dbafs :: addResource ( $ strNewName ) ; } return $ return ; }
614	protected function getDependencies ( $ class ) { if ( isset ( $ this -> _reflections [ $ class ] ) ) { return [ $ this -> _reflections [ $ class ] , $ this -> _dependencies [ $ class ] ] ; } $ dependencies = [ ] ; try { $ reflection = new ReflectionClass ( $ class ) ; } catch ( \ ReflectionException $ e ) { throw new InvalidConfigException ( 'Failed to instantiate component or class "' . $ class . '".' , 0 , $ e ) ; } $ constructor = $ reflection -> getConstructor ( ) ; if ( $ constructor !== null ) { foreach ( $ constructor -> getParameters ( ) as $ param ) { if ( version_compare ( PHP_VERSION , '5.6.0' , '>=' ) && $ param -> isVariadic ( ) ) { break ; } elseif ( $ param -> isDefaultValueAvailable ( ) ) { $ dependencies [ ] = $ param -> getDefaultValue ( ) ; } else { $ c = $ param -> getClass ( ) ; $ dependencies [ ] = Instance :: of ( $ c === null ? null : $ c -> getName ( ) ) ; } } } $ this -> _reflections [ $ class ] = $ reflection ; $ this -> _dependencies [ $ class ] = $ dependencies ; return [ $ reflection , $ dependencies ] ; }
4731	public static function unicode_to_utf16 ( $ str ) { if ( \ extension_loaded ( 'mbstring' ) ) { return preg_replace_callback ( '/\\\\u([0-9a-fA-F]{4})/' , function ( $ match ) { return mb_convert_encoding ( pack ( 'H*' , $ match [ 1 ] ) , 'UTF-8' , 'UTF-16BE' ) ; } , $ str ) ; } return $ str ; }
1233	private function ensurePropertyType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } $ valid = explode ( '|' , $ this -> expectedType ) ; $ isValid = false ; foreach ( $ valid as $ check ) { if ( $ check !== 'any' && \ DTS \ eBaySDK \ checkPropertyType ( $ check ) ) { if ( $ check === $ actualType ) { return ; } $ isValid = false ; } else { $ isValid = true ; } } if ( ! $ isValid ) { throw new Exceptions \ InvalidPropertyTypeException ( $ this -> property , $ this -> expectedType , $ actualType ) ; } }
9159	protected function redirect ( $ controller = null , $ action = null ) { if ( null === $ controller ) { $ controller = Application :: getInstance ( ) -> getDefaultController ( ) ; } if ( null === $ action ) { $ action = Application :: getInstance ( ) -> getDefaultAction ( ) ; } $ destination = sprintf ( "Location: %s%s/%s" , $ this -> request -> getContextPrefix ( ) , $ controller , $ action ) ; header ( $ destination ) ; exit ( ) ; }
12898	public static function translate ( $ message , $ parameters = array ( ) , $ domain = "RedKiteCms" , $ locale = null ) { if ( null === self :: $ translator ) { return $ message ; } return self :: $ translator -> trans ( $ message , $ parameters , $ domain , $ locale ) ; }
6106	private function getGridClass ( ) { $ class = [ ] ; foreach ( $ this -> grid as $ grid ) { if ( ! isset ( $ grid [ 'type' ] ) || ! isset ( $ grid [ 'size' ] ) ) { throw new InvalidConfigException ( get_called_class ( ) . ' must have type and size.' ) ; } if ( ! isset ( $ grid [ 'positiontype' ] ) ) $ class [ ] = $ grid [ 'type' ] . $ grid [ 'size' ] ; else $ class [ ] = $ grid [ 'type' ] . $ grid [ 'positiontype' ] . '-' . $ grid [ 'size' ] ; } return implode ( ' ' , $ class ) ; }
12070	public function createProject ( $ composerJson ) { $ response = $ this -> getResponse ( 'post' , 'v2/projects' , array ( ) , array ( 'upload' => $ composerJson ) ) ; return $ this -> hydrator -> hydrate ( new Project ( ) , $ response ) ; }
10291	protected function aquireLock ( ) { $ lockfile = $ this -> lockDir . '/lock' ; $ fp = @ fopen ( $ lockfile , 'x' ) ; if ( $ fp === false ) { $ this -> logger -> log ( sprintf ( 'The lockfile %s does already exist.' , $ lockfile ) , Logger :: WARNING ) ; return false ; } fwrite ( $ fp , time ( ) ) ; fclose ( $ fp ) ; $ this -> logger -> log ( 'Aquired lock.' , Logger :: INFO ) ; return true ; }
4713	public function replace ( $ pattern , $ replacement ) { if ( is_callable ( $ replacement ) ) { $ this -> text = preg_replace_callback ( $ pattern , function ( $ matches ) use ( $ replacement ) { $ args = array_map ( function ( $ item ) { return new Text ( $ item ) ; } , $ matches ) ; return call_user_func_array ( $ replacement , $ args ) ; } , $ this -> text ) ; } else { $ this -> text = preg_replace ( $ pattern , $ replacement , $ this -> text ) ; } return $ this ; }
2738	private function setToken ( $ token ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_API_KEY , $ token ) ; $ this -> output -> writeln ( '<info>Token updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
9072	private function runQuery ( array $ query , int $ limit ) : Result { $ query [ 'Limit' ] = $ limit + 1 ; $ result = $ this -> dynamoDbClient -> query ( $ query ) ; $ result [ 'Items' ] = array_slice ( $ result [ 'Items' ] , 0 , $ limit ) ; return $ result ; }
9149	public function markAsUnread ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; if ( ! is_null ( $ object -> read_at ) ) { $ object -> forceFill ( [ 'read_at' => null ] ) -> save ( ) ; } \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
3711	protected function generateElement ( $ table , $ content , $ replace , $ elementId ) { $ sql = sprintf ( 'SELECT * FROM %s WHERE id=? AND type="metamodels_frontendclearall"' , $ table ) ; $ statement = $ this -> connection -> prepare ( $ sql ) ; $ statement -> bindValue ( 1 , $ elementId ) ; $ statement -> execute ( ) ; $ objDbResult = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ; if ( $ objDbResult === false ) { return str_replace ( $ replace , '' , $ content ) ; } if ( $ table == 'tl_module' ) { $ objElement = new ModuleFilterClearAll ( $ objDbResult ) ; } elseif ( $ table == 'tl_content' ) { $ objElement = new ContentElementFilterClearAll ( $ objDbResult ) ; } else { return str_replace ( $ replace , '' , $ content ) ; } return str_replace ( $ replace , $ objElement -> generateReal ( ) , $ content ) ; }
1332	protected function readWithFilters ( $ record , EncodingParametersInterface $ parameters ) { $ query = $ this -> newQuery ( ) -> whereKey ( $ record -> getKey ( ) ) ; $ this -> applyFilters ( $ query , collect ( $ parameters -> getFilteringParameters ( ) ) ) ; return $ query -> exists ( ) ? $ record : null ; }
7777	protected function extractFieldAliases ( array $ data ) { foreach ( $ data as $ field => $ fieldRules ) { $ extraction = explode ( '|' , $ field ) ; if ( isset ( $ extraction [ 1 ] ) ) { $ updatedField = $ extraction [ 0 ] ; $ alias = $ extraction [ 1 ] ; $ this -> fieldAliases [ $ updatedField ] = $ alias ; $ data [ $ updatedField ] = $ data [ $ field ] ; unset ( $ data [ $ field ] ) ; } } return $ data ; }
12726	public function getContent ( array $ contentData ) { foreach ( $ this -> mandatoryFields as $ mandatoryField ) { if ( ! array_key_exists ( $ mandatoryField , $ contentData ) ) { throw new ContentException ( "The field '$mandatoryField' is missing in the given content data" ) ; } } try { $ title = "" ; if ( isset ( $ contentData [ self :: FIELD_TITLE ] ) ) { $ title = $ contentData [ self :: FIELD_TITLE ] ; } $ summary = "" ; if ( isset ( $ contentData [ self :: FIELD_SUMMARY ] ) ) { $ summary = $ contentData [ self :: FIELD_SUMMARY ] ; } $ description = "" ; if ( isset ( $ contentData [ self :: FIELD_DESCRIPTION ] ) ) { $ description = $ contentData [ self :: FIELD_DESCRIPTION ] ; } $ content = new Content ( $ title , $ summary , $ description ) ; return $ content ; } catch ( \ Exception $ contentException ) { throw new ContentException ( sprintf ( "Failed to create a content model from the given data: %s" , $ contentException -> getMessage ( ) ) , $ contentException ) ; } }
10868	public function getById ( int $ id ) { return $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.' . self :: COLUMN_ID => $ id ] ) -> fetch ( ) ; }
4284	public function url_stat ( $ path , $ flags ) { self :: restorePrev ( ) ; if ( ! \ file_exists ( $ path ) ) { $ info = false ; } elseif ( $ flags & STREAM_URL_STAT_LINK ) { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ lstat ( $ path ) : \ lstat ( $ path ) ; } else { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ stat ( $ path ) : \ stat ( $ path ) ; } self :: register ( ) ; return $ info ; }
6049	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyResponse ( $ item ) ; } return $ this ; }
5713	public function updateItemEditForm ( $ form ) { if ( $ this -> owner -> record -> stat ( 'better_buttons_enabled' ) !== true ) { return false ; } Requirements :: css ( BETTER_BUTTONS_DIR . '/css/gridfield_betterbuttons.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons.js' ) ; $ actions = $ this -> owner -> record -> getBetterButtonsActions ( ) ; $ form -> setActions ( $ this -> filterFieldList ( $ form , $ actions ) ) ; if ( $ form -> Fields ( ) -> hasTabSet ( ) ) { $ form -> Fields ( ) -> findOrMakeTab ( 'Root' ) -> setTemplate ( TabSet :: class ) ; $ form -> addExtraClass ( 'cms-tabset' ) ; } $ utils = $ this -> owner -> record -> getBetterButtonsUtils ( ) ; $ form -> Utils = $ this -> filterFieldList ( $ form , $ utils ) ; $ form -> setTemplate ( [ 'type' => 'Includes' , 'BetterButtons_EditForm' , ] ) ; $ form -> addExtraClass ( 'better-buttons-form' ) ; }
4890	public function renderPage ( PageInterface $ page , $ vars = array ( ) ) { return $ this -> render ( $ this -> getPageManager ( ) -> getTemplate ( $ page ) , $ vars + array ( 'page' => $ page , 'id' => $ page -> getId ( ) , ) ) ; }
4945	public function revoke ( $ resource , $ permission = null , $ build = true ) { if ( self :: PERMISSION_NONE == $ permission || ! $ this -> isAssigned ( $ resource ) ) { return $ this ; } if ( self :: PERMISSION_CHANGE == $ permission ) { return $ this -> grant ( $ resource , self :: PERMISSION_VIEW , $ build ) ; } return $ this -> grant ( $ resource , self :: PERMISSION_NONE , $ build ) ; }
6094	public function isUtf8 ( ) { $ pattern = array ( ) ; $ pattern [ ] = "[\xC2-\xDF][\x80-\xBF]" ; $ pattern [ ] = "\xE0[\xA0-\xBF][\x80-\xBF]" ; $ pattern [ ] = "[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}" ; $ pattern [ ] = "\xED[\x80-\x9F][\x80-\xBF]" ; $ pattern [ ] = "\xF0[\x90-\xBF][\x80-\xBF]{2}" ; $ pattern [ ] = "[\xF1-\xF3][\x80-\xBF]{3}" ; $ pattern [ ] = "\xF4[\x80-\x8F][\x80-\xBF]{2}" ; return preg_match ( "%(?:" . implode ( "|" , $ pattern ) . ")+%xs" , $ this -> string ) ; }
4024	public function handle ( BuildDataDefinitionEvent $ event ) { if ( 'tl_metamodel_dca_sortgroup' !== $ event -> getContainer ( ) -> getName ( ) ) { return ; } foreach ( $ event -> getContainer ( ) -> getPalettesDefinition ( ) -> getPalettes ( ) as $ palette ) { foreach ( $ palette -> getProperties ( ) as $ property ) { if ( $ property -> getName ( ) != 'rendergrouptype' ) { continue ; } $ this -> addCondition ( $ property , new PropertyConditionChain ( array ( new InputScreenRenderModeIs ( 'flat' , $ this -> connection ) , new InputScreenRenderModeIs ( 'parented' , $ this -> connection ) , ) , PropertyConditionChain :: OR_CONJUNCTION ) ) ; } } }
1657	public function get ( $ name ) { foreach ( $ this -> arguments as $ argument ) { if ( $ argument [ 'name' ] == $ name ) { if ( isset ( $ this -> mapArgumentName [ $ name ] ) ) { return $ this -> { $ this -> mapArgumentName [ $ name ] } ( $ argument ) ; } else { return $ argument ; } } } }
597	public function one ( $ db = null ) { $ row = parent :: one ( $ db ) ; if ( $ row !== false ) { $ models = $ this -> populate ( [ $ row ] ) ; return reset ( $ models ) ? : null ; } return null ; }
10750	protected function sendVerb ( string $ verb , Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { $ send = array_merge ( [ ] , $ extra ) ; $ send [ 'success' ] = true ; $ send [ 'message' ] = "Objects $verb successfully" ; $ send [ 'objects' ] = array_map ( function ( $ id ) use ( $ type ) { return [ 'type' => $ type , 'id' => $ id ] ; } , $ ids ) ; return $ this -> sendJson ( $ response , $ send ) ; }
1538	public function willSeeOne ( $ request ) : bool { if ( $ this -> route -> isRelationship ( ) ) { return false ; } if ( $ this -> route -> isResource ( ) ) { return true ; } return $ request -> isMethod ( 'POST' ) ; }
12423	protected function getTranslations ( $ domain ) { if ( ! isset ( $ this -> translations [ $ domain ] ) ) { if ( ! isset ( $ this -> translationSources [ $ domain ] ) ) { $ msg = sprintf ( 'No translation directory for domain "%1$s" available' , $ domain ) ; throw new \ Aimeos \ MW \ Translation \ Exception ( $ msg ) ; } $ locale = $ this -> getLocale ( ) ; $ locations = array_reverse ( $ this -> getTranslationFileLocations ( $ this -> translationSources [ $ domain ] , $ locale ) ) ; foreach ( $ locations as $ location ) { $ translator = \ Zend \ I18n \ Translator \ MwTranslator :: factory ( $ this -> options ) ; $ translator -> addTranslationFile ( $ this -> adapter , $ location , $ domain , $ locale ) ; $ this -> translations [ $ domain ] [ $ location ] = $ translator ; } } return ( isset ( $ this -> translations [ $ domain ] ) ? $ this -> translations [ $ domain ] : [ ] ) ; }
6226	public function isValid ( ) { if ( $ this -> service_code == 2106 ) { if ( $ this -> getSpecifier ( 'pickup_point_id' ) === null ) return false ; } if ( $ this -> service_code == 3101 ) { $ expected_params = array ( 'amount' , 'account' , 'reference' , 'codbic' ) ; foreach ( $ expected_params as $ param ) { if ( $ this -> getSpecifier ( $ param ) === null ) return false ; } } if ( $ this -> service_code == 3102 ) { if ( $ this -> getSpecifier ( 'count' ) === null ) return false ; if ( ! is_numeric ( $ this -> getSpecifier ( 'count' ) ) ) return false ; } if ( $ this -> service_code == 3111 ) { if ( $ this -> getSpecifier ( 'insurancevalue' ) === null ) return false ; } if ( $ this -> service_code == 3120 ) { if ( $ this -> getSpecifier ( 'deliverytime' ) ) return false ; } if ( $ this -> service_code == 3143 ) { if ( $ this -> getSpecifier ( 'lqweight' ) === null or $ this -> getSpecifier ( 'lqcount' ) === null ) return false ; } if ( ! is_numeric ( $ this -> service_code ) ) { return false ; } return true ; }
12701	public function setEditorConfig ( $ config ) { if ( $ config instanceof Traversable ) { $ config = ArrayUtils :: iteratorToArray ( $ config ) ; } if ( ! is_array ( $ config ) ) { throw new InvalidArgumentException ( 'The options parameter must be an array or a Traversable' ) ; } $ this -> editorConfig = $ config ; return $ this ; }
12126	public function validate ( string $ sValue = null ) : bool { if ( $ this -> _sType == 'DateTime' ) { if ( preg_match ( '#^[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}#' , $ sValue ) ) { return true ; } } return false ; }
10025	function getContact ( $ contactId , $ checksum , $ standard_fields = array ( ) , $ custom_fields = array ( ) , $ ignoreChecksum = false ) { $ queryParameters = array ( 'id' => $ contactId , 'checksum' => $ checksum , 'standard_field' => $ standard_fields , 'ignore_checksum' => $ ignoreChecksum ? "true" : "false" ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/contact' , $ queryParameters ) ; }
6084	public function uploadNewVersion ( $ id , $ pathname , $ revisionComment , $ filename = null , $ progress = null , $ chunkSize = 10485760 ) { $ chunk = 0 ; $ chunksTotal = ceil ( filesize ( $ pathname ) / $ chunkSize ) ; $ fileId = sha1 ( uniqid ( 'uploadVersion' , true ) ) ; $ filename = $ filename ? : pathinfo ( $ filename , PATHINFO_BASENAME ) ; $ fp = fopen ( $ pathname , 'r' ) ; if ( false === $ fp ) { throw new UploadException ( 'Could not open file "' . $ pathname . '" for reading.' ) ; } if ( $ chunkSize > 10485760 ) { $ this -> logger -> warning ( 'Using a chunk size larger then 10MB is not recommended. Uploading is not guaranteed to work properly.' ) ; } while ( $ chunkData = fread ( $ fp , $ chunkSize ) ) { $ result = $ this -> uploadNewVersionChunked ( $ chunkData , $ id , $ revisionComment , $ filename , $ chunk , $ chunksTotal , $ fileId ) ; if ( is_callable ( $ progress ) ) { try { call_user_func ( $ progress , $ chunk + 1 , $ chunksTotal ) ; } catch ( \ Exception $ e ) { $ this -> logger -> warning ( 'Could not report progress due to callback error.' , [ 'message' => $ e -> getMessage ( ) ] ) ; } } $ this -> logger -> info ( 'Upload progress!' , [ 'part' => $ chunk + 1 , 'total' => $ chunksTotal ] ) ; if ( isset ( $ result [ 'mediaId' ] ) ) { return new MediaResponse ( $ result ) ; } if ( isset ( $ result [ 'success' ] ) && false == $ result [ 'success' ] ) { throw new UploadException ( $ result [ 'error' ] [ 'message' ] , $ result [ 'error' ] [ 'code' ] ) ; } $ fileId = $ result [ 'fileId' ] ; ++ $ chunk ; } if ( $ chunk == $ chunksTotal - 1 ) { throw new UploadException ( 'Uploaded all chunks, but something went wrong.' ) ; } if ( false === $ chunkData ) { throw new UploadException ( 'Could not read chunk ' . $ chunk . ' from file "' . $ pathname . '".' ) ; } throw new UploadException ( 'Unknown upload error!' ) ; }
5899	public function listFunctionalities ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/functionalities' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Functionality ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
8932	public function loadDependencies ( ) { $ config = ConfigService :: fetch ( dirname ( __DIR__ ) ) ; $ config = array_merge ( $ config , ConfigService :: fetch ( ) ) ; $ moduleService = new ModuleService ; if ( ! array_key_exists ( 'slim-api' , $ config ) ) { $ config [ 'slim-api' ] = [ 'modules' => [ 'SlimApi\Phinx' , 'SlimApi\Mvc' ] ] ; } else { require 'vendor/autoload.php' ; } foreach ( $ config [ 'slim-api' ] [ 'modules' ] as $ moduleNamespace ) { $ config = array_merge ( $ config , $ moduleService -> load ( $ moduleNamespace ) ) ; } return $ config ; }
1647	public function calculateBearing ( Coordinate $ point1 , Coordinate $ point2 ) : float { $ lat1 = deg2rad ( $ point1 -> getLat ( ) ) ; $ lat2 = deg2rad ( $ point2 -> getLat ( ) ) ; $ lng1 = deg2rad ( $ point1 -> getLng ( ) ) ; $ lng2 = deg2rad ( $ point2 -> getLng ( ) ) ; $ y = sin ( $ lng2 - $ lng1 ) * cos ( $ lat2 ) ; $ x = cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lng2 - $ lng1 ) ; $ bearing = rad2deg ( atan2 ( $ y , $ x ) ) ; if ( $ bearing < 0 ) { $ bearing = fmod ( $ bearing + 360 , 360 ) ; } return $ bearing ; }
7707	function _ApplyDiffToAll ( $ Diff ) { $ this -> PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; $ this -> pST_PosEnd += $ Diff ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; }
11184	protected function generateActions ( ) { $ parser = new Parser ( ) ; $ parser -> setPath ( $ this -> getApplicationPath ( ) ) ; $ parser -> setNameSpace ( $ this -> getApplicationNameSpace ( ) ) ; $ list = $ parser -> run ( ) ; return $ list ; }
5404	public function restartSession ( $ date = false ) { $ surviving_cookies = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { if ( ! $ this -> cookies [ $ i ] -> getValue ( ) ) { continue ; } if ( ! $ this -> cookies [ $ i ] -> getExpiry ( ) ) { continue ; } if ( $ date && $ this -> cookies [ $ i ] -> isExpired ( $ date ) ) { continue ; } $ surviving_cookies [ ] = $ this -> cookies [ $ i ] ; } $ this -> cookies = $ surviving_cookies ; }
326	public static function sentence ( array $ words , $ twoWordsConnector = null , $ lastWordConnector = null , $ connector = ', ' ) { if ( $ twoWordsConnector === null ) { $ twoWordsConnector = Yii :: t ( 'yii' , ' and ' ) ; } if ( $ lastWordConnector === null ) { $ lastWordConnector = $ twoWordsConnector ; } switch ( count ( $ words ) ) { case 0 : return '' ; case 1 : return reset ( $ words ) ; case 2 : return implode ( $ twoWordsConnector , $ words ) ; default : return implode ( $ connector , array_slice ( $ words , 0 , - 1 ) ) . $ lastWordConnector . end ( $ words ) ; } }
10042	public function validatePlugin ( $ plugin ) { if ( $ plugin instanceof Storage \ StorageInterface ) { return ; } throw new Storage \ Exception \ RuntimeException ( sprintf ( 'Plugin of type %s is invalid; must implement %s\Storage\StorageInterfaceInterface' , ( is_object ( $ plugin ) ? get_class ( $ plugin ) : gettype ( $ plugin ) ) , __NAMESPACE__ ) ) ; }
5333	public function setSignature ( $ parameters , $ privateKey , $ service , $ endpoint , $ timestamp , $ nonce ) { $ this -> __setCookie ( 'signature' , rawurlencode ( $ this -> sign ( $ privateKey , array_merge ( $ parameters , [ '__service' => $ service , '__hostname' => $ endpoint , '__timestamp' => $ timestamp , '__nonce' => $ nonce , ] ) ) ) ) ; }
11898	public function getEstimateTimeRemaining ( ) { $ estimatedDuration = $ this -> dataInterface -> estimateDuration ( ) ; if ( $ estimatedDuration ) { $ startedTime = strtotime ( $ this -> started ) ; $ estimatedEndTime = $ startedTime + $ estimatedDuration ; if ( time ( ) > $ estimatedEndTime ) { return false ; } return $ estimatedEndTime - time ( ) ; } return false ; }
3124	protected function fixRange ( $ range , $ lastTimestamp = null ) { $ fixedRange = [ ] ; $ last = null ; $ open = false ; foreach ( $ range as $ point ) { if ( $ this -> isStartPoint ( $ point ) ) { if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ point , TimePoint :: TYPE_END ) ; } $ open = true ; } else if ( $ this -> isEndPoint ( $ point ) ) { if ( ! $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last ? $ last : $ point , TimePoint :: TYPE_START ) ; } $ open = false ; } $ fixedRange [ ] = $ point ; $ last = $ point ; } if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last , TimePoint :: TYPE_END , $ lastTimestamp ) ; } return $ fixedRange ; }
8219	protected function getIp ( $ config ) { $ remoteAddr = $ _SERVER [ 'REMOTE_ADDR' ] ; if ( filter_var ( $ remoteAddr , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) ) { $ netmask = ( isset ( $ config [ "netmask_IPv4" ] ) ) ? $ config [ "netmask_IPv4" ] : self :: DEFAULT_NETMASK_IPV4 ; } else { $ netmask = ( isset ( $ config [ "netmask_IPv6" ] ) ) ? $ config [ "netmask_IPv6" ] : self :: DEFAULT_NETMASK_IPV6 ; } $ ipSubnet = $ this -> getSubnet ( $ remoteAddr , $ netmask ) ; return $ ipSubnet ; }
11536	public static function cast ( $ time ) { return $ time instanceof self ? $ time : new self ( $ time -> format ( self :: ISO8601 ) , $ time -> getTimezone ( ) ) ; }
6177	protected function executeDelete ( ) { foreach ( $ this -> tableData as $ key => $ row ) { if ( $ this -> where && ! $ this -> where -> execute ( $ row ) ) { continue ; } unset ( $ this -> tableData [ $ key ] ) ; } $ this -> tableData = array_values ( $ this -> tableData ) ; }
8186	public function displayBlock ( $ name , array $ context , array $ blocks = array ( ) , $ useBlocks = true ) { $ name = ( string ) $ name ; if ( $ useBlocks && isset ( $ blocks [ $ name ] ) ) { $ template = $ blocks [ $ name ] [ 0 ] ; $ block = $ blocks [ $ name ] [ 1 ] ; } elseif ( isset ( $ this -> blocks [ $ name ] ) ) { $ template = $ this -> blocks [ $ name ] [ 0 ] ; $ block = $ this -> blocks [ $ name ] [ 1 ] ; } else { $ template = null ; $ block = null ; } if ( null !== $ template && ! $ template instanceof self ) { throw new LogicException ( 'A block must be a method on a Twig_Template instance.' ) ; } if ( null !== $ template ) { try { $ template -> $ block ( $ context , $ blocks ) ; } catch ( Twig_Error $ e ) { if ( ! $ e -> getSourceContext ( ) ) { $ e -> setSourceContext ( $ template -> getSourceContext ( ) ) ; } if ( false === $ e -> getTemplateLine ( ) ) { $ e -> setTemplateLine ( - 1 ) ; $ e -> guess ( ) ; } throw $ e ; } catch ( Exception $ e ) { throw new Twig_Error_Runtime ( sprintf ( 'An exception has been thrown during the rendering of a template ("%s").' , $ e -> getMessage ( ) ) , - 1 , $ template -> getSourceContext ( ) , $ e ) ; } } elseif ( false !== $ parent = $ this -> getParent ( $ context ) ) { $ parent -> displayBlock ( $ name , $ context , array_merge ( $ this -> blocks , $ blocks ) , false ) ; } else { @ trigger_error ( sprintf ( 'Silent display of undefined block "%s" in template "%s" is deprecated since version 1.29 and will throw an exception in 2.0. Use the "block(\'%s\') is defined" expression to test for block existence.' , $ name , $ this -> getTemplateName ( ) , $ name ) , E_USER_DEPRECATED ) ; } }
11696	protected function normaliseSrcInput ( $ input ) : array { $ output = [ ] ; if ( $ input instanceof Finder ) { foreach ( $ input as $ fileInfo ) { $ output [ ] = $ fileInfo -> getRealpath ( ) ; } } else { if ( ! is_array ( $ input ) ) $ input = [ $ input ] ; if ( count ( $ input ) === 0 ) throw new \ UnexpectedValueException ; if ( ! is_string ( $ input [ 0 ] ) ) throw new \ UnexpectedValueException ; $ output = $ input ; } return $ output ; }
633	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> delete ( $ table , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
6183	public function add ( $ type , $ message , $ redirect = null ) { if ( ! isset ( $ type ) or ! isset ( $ message [ 0 ] ) ) { return false ; } if ( strlen ( trim ( $ type ) ) === 1 ) { $ type = str_replace ( [ 'h' , 'i' , 'w' , 'e' , 's' ] , [ 'help' , 'info' , 'warning' , 'error' , 'success' ] , $ type ) ; } $ router = new Router ( ) ; try { if ( ! in_array ( $ type , $ this -> msgTypes ) ) { throw new BaseException ( '"' . strip_tags ( $ type ) . '" is not a valid message type!' , 501 ) ; } } catch ( BaseException $ e ) { $ msg = null ; if ( ini_get ( 'display_errors' ) === "on" ) { $ msg .= '<pre>' ; $ msg .= 'Message: <b>' . $ e -> getMessage ( ) . '</b><br><br>' ; $ msg .= 'Accept: ' . $ _SERVER [ 'HTTP_ACCEPT' ] . '<br>' ; if ( isset ( $ _SERVER [ 'HTTP_REFERER' ] ) ) { $ msg .= 'Referer: ' . $ _SERVER [ 'HTTP_REFERER' ] . '<br><br>' ; } $ msg .= 'Request Method: ' . $ _SERVER [ 'REQUEST_METHOD' ] . '<br><br>' ; $ msg .= 'Current file Path: <b>' . $ this -> router -> currentPath ( ) . '</b><br>' ; $ msg .= 'File Exception: ' . $ e -> getFile ( ) . ':' . $ e -> getLine ( ) . '<br><br>' ; $ msg .= 'Trace: <br>' . $ e -> getTraceAsString ( ) . '<br>' ; $ msg .= '</pre>' ; return Response :: create ( $ msg ) -> display ( ) ; } return Response :: create ( $ e -> getMessage ( ) ) -> status ( 501 ) -> display ( ) ; } $ get = $ this -> driver -> get ( 'flash_messages' ) ; $ get [ $ type ] [ ] = $ message ; $ this -> driver -> set ( 'flash_messages' , $ get ) ; if ( ! is_null ( $ redirect ) ) { return $ router -> redirect ( $ redirect , 301 ) ; } return true ; }
9094	public function handle ( ) { try { if ( $ this -> validate ( ) ) { $ result = $ this -> update ( ) ; } } catch ( \ hypeJunction \ Exceptions \ ActionValidationException $ ex ) { register_error ( elgg_echo ( 'prototyper:validate:error' ) ) ; forward ( REFERER ) ; } catch ( \ IOException $ ex ) { register_error ( elgg_echo ( 'prototyper:io:error' , array ( $ ex -> getMessage ( ) ) ) ) ; forward ( REFERER ) ; } catch ( \ Exception $ ex ) { register_error ( elgg_echo ( 'prototyper:handle:error' , array ( $ ex -> getMessage ( ) ) ) ) ; forward ( REFERER ) ; } if ( $ result ) { system_message ( elgg_echo ( 'prototyper:action:success' ) ) ; forward ( $ this -> entity -> getURL ( ) ) ; } else { register_error ( elgg_echo ( 'prototyper:action:error' ) ) ; forward ( REFERER ) ; } }
8995	protected function addActions ( SymfonyController $ controller , Resource $ resource , $ chainName = '' ) { $ actions = array ( ) ; $ chainName = $ chainName . '_' . strtolower ( str_replace ( array ( '{' , '}' ) , '' , $ resource -> getDisplayName ( ) ) ) ; foreach ( $ resource -> getMethods ( ) as $ method ) { $ actionName = strtolower ( $ method -> getType ( ) ) . str_replace ( ' ' , '' , ucwords ( str_replace ( '_' , ' ' , $ chainName ) ) ) . 'Action' ; $ route = new SymfonyRoute ( $ resource -> getUri ( ) , strtolower ( $ method -> getType ( ) . $ chainName ) ) ; $ action = new SymfonyAction ( $ actionName , $ route , $ method -> getType ( ) , $ method -> getDescription ( ) ) ; preg_match_all ( '/\{[a-zA-Z]+\}/' , $ resource -> getUri ( ) , $ parameters ) ; foreach ( $ parameters [ 0 ] as $ parameter ) { $ action -> addParameter ( substr ( $ parameter , 1 , strlen ( $ parameter ) - 2 ) ) ; } if ( $ method -> getResponses ( ) ) { foreach ( $ method -> getResponses ( ) as $ code => $ response ) { $ headers = array ( ) ; foreach ( $ response -> getHeaders ( ) as $ key => $ value ) { if ( isset ( $ value [ 'required' ] ) && $ value [ 'required' ] ) { $ headers [ $ key ] = isset ( $ value [ 'example' ] ) ? $ value [ 'example' ] : '' ; } } $ _response = new SymfonyResponse ( $ code , $ headers ) ; foreach ( $ this -> config [ 'allowed_response_types' ] as $ allowedResponsetype ) { if ( null !== $ example = $ response -> getExampleByType ( $ allowedResponsetype ) ) { $ _response -> addContent ( new SymfonyResponseContent ( $ allowedResponsetype , str_replace ( array ( "\r\n" , "\n" , "\r" , "\t" , " " ) , '' , $ example ) ) ) ; } } $ action -> addResponse ( $ _response ) ; } } $ controller -> addAction ( $ action ) ; } foreach ( $ resource -> getResources ( ) as $ subresource ) { $ this -> addActions ( $ controller , $ subresource , $ chainName ) ; } }
6635	public function bootstrap ( $ app ) { Yii :: setAlias ( '@wavecms' , '@vendor/mrstroz/yii2-wavecms' ) ; if ( $ app -> id === 'app-backend' || $ app -> id === 'app-frontend' ) { Yii :: setAlias ( '@frontWeb' , str_replace ( '/admin' , '' , Yii :: getAlias ( '@web' ) ) ) ; Yii :: setAlias ( '@frontWebroot' , str_replace ( '/public/admin' , '/public' , Yii :: getAlias ( '@webroot' ) ) ) ; } if ( $ app -> id === 'app-backend' ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } } $ this -> initTranslations ( ) ; if ( $ app -> hasModule ( 'wavecms' ) && ( $ module = $ app -> getModule ( 'wavecms' ) ) instanceof Module ) { if ( $ app instanceof ConsoleApplication ) { $ module -> controllerNamespace = 'mrstroz\wavecms\commands' ; } else { $ module -> controllerNamespace = 'mrstroz\wavecms\controllers' ; if ( $ app -> id === 'app-backend' ) { Yii :: $ app -> errorHandler -> errorAction = $ module -> errorAction ; $ app -> set ( 'wavecms' , [ 'class' => 'mrstroz\wavecms\WavecmsComponent' , 'languages' => $ module -> languages ] ) ; $ app -> set ( 'cacheFrontend' , [ 'class' => 'yii\caching\FileCache' , 'cachePath' => Yii :: getAlias ( '@frontend' ) . '/runtime/cache' ] ) ; $ app -> set ( 'settings' , [ 'class' => 'yii2mod\settings\components\Settings' , ] ) ; Yii :: $ app -> assetManager -> appendTimestamp = true ; Yii :: $ app -> i18n -> translations [ 'yii2mod.settings' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'basePath' => '@yii2mod/settings/messages' ] ; $ this -> initContainer ( $ module ) ; $ this -> initLanguages ( ) ; $ this -> initParams ( ) ; $ this -> initRoutes ( $ app , $ module ) ; $ this -> initNavigation ( ) ; } } } }
8730	public function getCanSelectFolder ( ) { if ( ! $ this -> isActive ( ) ) { return false ; } if ( $ this -> template && in_array ( $ this -> template , self :: config ( ) -> disable_for_templates ) ) { return false ; } $ can = $ this -> canSelectFolder ; return ( is_bool ( $ can ) ) ? $ can : Permission :: check ( $ can ) ; }
8272	public function validateUsersSection ( & $ config ) { if ( ! isset ( $ config [ "users" ] ) ) { return ; } $ this -> assertArray ( $ config , "users" ) ; foreach ( $ config [ "users" ] as $ username => $ userData ) { $ this -> assertUsername ( $ username , $ config ) ; try { $ this -> validateUserData ( $ userData ) ; } catch ( ConfigurationException $ e ) { $ e -> addBeforeMessage ( "Invalid userdata for $username:" ) ; throw $ e ; } $ lowercaseName = strtolower ( $ username ) ; if ( $ username !== $ lowercaseName ) { if ( ! isset ( $ config [ "users" ] [ $ lowercaseName ] ) ) { $ config [ "users" ] [ $ lowercaseName ] = $ userData ; unset ( $ config [ "users" ] [ $ username ] ) ; } else { throw new ConfigurationException ( "User $username is defined multiple times." ) ; } } } }
6838	public function mapDatas ( $ kvs ) { foreach ( $ kvs as $ k => $ v ) { $ this -> mapData ( $ k , $ v ) ; } }
6914	public function removeShipment ( ShipmentInterface $ shipment ) { if ( $ this -> shipments -> contains ( $ shipment ) ) { $ this -> shipments -> removeElement ( $ shipment ) ; } return $ this ; }
5180	private function addArray ( string $ key , $ value ) : self { $ this -> props [ $ key ] [ ] = $ value ; return $ this ; }
1220	private function validateSeq ( $ from , array $ types , $ a , $ b ) { $ ta = Utils :: type ( $ a ) ; $ tb = Utils :: type ( $ b ) ; if ( $ ta !== $ tb ) { $ msg = "encountered a type mismatch in sequence: {$ta}, {$tb}" ; $ this -> typeError ( $ from , $ msg ) ; } $ typeMatch = ( $ types && $ types [ 0 ] == 'any' ) || in_array ( $ ta , $ types ) ; if ( ! $ typeMatch ) { $ msg = 'encountered a type error in sequence. The argument must be ' . 'an array of ' . implode ( '|' , $ types ) . ' types. ' . "Found {$ta}, {$tb}." ; $ this -> typeError ( $ from , $ msg ) ; } }
7023	private function formatZ ( & $ str ) { if ( strstr ( $ str , '%Z' ) ) $ str = str_replace ( '%Z' , $ this -> timezone -> offset * 3600 , $ str ) ; }
993	public static function isValidLiteralValue ( Type $ type , $ valueNode ) { $ emptySchema = new Schema ( [ ] ) ; $ emptyDoc = new DocumentNode ( [ 'definitions' => [ ] ] ) ; $ typeInfo = new TypeInfo ( $ emptySchema , $ type ) ; $ context = new ValidationContext ( $ emptySchema , $ emptyDoc , $ typeInfo ) ; $ validator = new ValuesOfCorrectType ( ) ; $ visitor = $ validator -> getVisitor ( $ context ) ; Visitor :: visit ( $ valueNode , Visitor :: visitWithTypeInfo ( $ typeInfo , $ visitor ) ) ; return $ context -> getErrors ( ) ; }
5907	public function retrieveSetting ( $ key , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/settings/' . $ key . '' , $ parameters , $ cachePolicy ) ; return $ result ; }
1102	protected function hasChange ( ) { return ! ( $ this -> bound1 ( ) == $ this -> node -> getRight ( ) || $ this -> bound1 ( ) == $ this -> node -> getLeft ( ) ) ; }
12558	public function actionFlush ( $ category = null ) { if ( is_null ( $ category ) ) { $ category = $ this -> prompt ( "Category (blank for all): " ) ; } if ( empty ( $ category ) ) { $ category = 'all' ; } else { $ category = [ 'category' , $ category ] ; } Cacher :: invalidateGroup ( $ category ) ; $ this -> out ( "Done!" ) ; }
2153	public function updateAccount ( ) { $ intUser = Input :: get ( 'id' ) ; if ( TL_MODE == 'FE' ) { $ this -> import ( FrontendUser :: class , 'User' ) ; $ intUser = $ this -> User -> id ; } if ( ! $ intUser ) { return ; } if ( TL_MODE == 'FE' || Input :: get ( 'act' ) == 'edit' ) { $ objUser = $ this -> Database -> prepare ( "SELECT email, disable FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intUser ) ; if ( $ objUser -> numRows ) { $ strEmail = Input :: post ( 'email' , true ) ; if ( ! empty ( $ _POST ) && $ strEmail != '' && $ strEmail != $ objUser -> email ) { $ objCount = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ strEmail ) ; if ( $ objCount -> count > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; } else { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET email=? WHERE email=?" ) -> execute ( $ strEmail , $ objUser -> email ) ; } $ objUser -> email = $ strEmail ; } $ objSubscriptions = $ this -> Database -> prepare ( "SELECT pid FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; if ( $ objSubscriptions -> numRows ) { $ strNewsletters = serialize ( $ objSubscriptions -> fetchEach ( 'pid' ) ) ; } else { $ strNewsletters = '' ; } $ this -> Database -> prepare ( "UPDATE tl_member SET newsletter=? WHERE id=?" ) -> execute ( $ strNewsletters , $ intUser ) ; if ( TL_MODE == 'FE' ) { $ this -> User -> newsletter = $ strNewsletters ; } elseif ( ! empty ( $ _POST ) && Input :: post ( 'disable' ) != $ objUser -> disable ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active=? WHERE email=?" ) -> execute ( ( Input :: post ( 'disable' ) ? '' : 1 ) , $ objUser -> email ) ; $ objUser -> disable = Input :: post ( 'disable' ) ; } } } elseif ( Input :: get ( 'act' ) == 'delete' ) { $ objUser = $ this -> Database -> prepare ( "SELECT email FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intUser ) ; if ( $ objUser -> numRows ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; } } }
12060	public function getTargetLabel ( ) { if ( ! isset ( $ this -> labels [ $ this -> target ] ) ) { return [ 'long' => 'unknown' , 'short' => 'unknown' ] ; } return $ this -> labels [ $ this -> target ] ; }
12978	protected function detectMetadataDriver ( $ dir , $ configPath ) { foreach ( ( array ) $ configPath as $ cPath ) { $ path = $ dir . DS . $ cPath . DS ; if ( ( $ files = glob ( $ path . '*.dcm.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ path . '*.orm.xml' ) ) && count ( $ files ) ) { return 'simplified_xml' ; } elseif ( ( $ files = glob ( $ path . '*.dcm.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ path . '*.orm.yml' ) ) && count ( $ files ) ) { return 'simplified_yml' ; } elseif ( ( $ files = glob ( $ path . '*.php' ) ) && count ( $ files ) ) { return 'php' ; } } if ( is_dir ( $ dir . DS . $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ) ) { return 'annotation' ; } return false ; }
11656	public function getShortName ( ) { preg_match ( '/Widget([A-Za-z]+)\\\Module/' , get_class ( $ this ) , $ matches ) ; if ( ! isset ( $ matches [ 1 ] ) ) { throw new Exception ( get_class ( $ this ) . " is not set up correctly!" ) ; } return $ matches [ 1 ] ; }
7386	public static final function moveFile ( $ file ) { try { if ( $ file -> is_temp ) { rename ( $ file -> temp_destination . '/' . $ file -> temp_name , $ file -> original_destination . '/' . $ file -> temp_name ) ; if ( ! file_exists ( $ file -> original_destination . '/' . $ file -> temp_name ) ) { throw new CannotSaveFileInHardDriveException ( ) ; } $ file -> is_temp = false ; $ file -> expire = null ; $ file -> save ( ) ; } } catch ( \ Exception $ exception ) { throw new FileException ( $ exception -> getMessage ( ) ) ; } }
4566	public function getForms ( $ id ) { $ forms = [ ] ; $ form = $ this -> getForm ( $ id ) ; $ form -> setMethod ( 'POST' ) -> setPrimary ( true ) ; $ forms [ ] = $ form ; switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ extract = function ( & $ container , $ key , & $ component ) use ( & $ extract , & $ forms , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as $ key => & $ subComponent ) { $ extract ( $ component -> components , $ key , $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as $ key => & $ subComponent ) { $ extract ( $ column -> components , $ key , $ subComponent ) ; } } break ; case property_exists ( $ component , 'properties' ) && is_object ( $ component -> properties ) && property_exists ( $ component -> properties , 'ds_form' ) : $ form = $ this -> getForm ( $ component -> properties -> ds_form ) ; $ data = [ ] ; if ( property_exists ( $ component , 'defaultValue' ) ) { try { $ data = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ data = [ ] ; } catch ( UnmatchedException $ exception ) { } } $ form -> setData ( $ data ) ; $ forms [ ] = $ form ; unset ( $ container [ $ key ] ) ; break ; } } ; foreach ( $ components as $ key => & $ component ) { $ extract ( $ components , $ key , $ component ) ; } $ form -> setSchema ( array_values ( $ components ) ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ forms ; }
8747	public function select ( ) { $ read = [ $ this -> stream ] ; $ write = null ; $ except = null ; $ this -> selected = @ stream_select ( $ read , $ write , $ except , 0 , $ this -> timeout ) ; return $ this ; }
2860	public function getLimitOptionsSelect ( ) { $ filterHelper = Mage :: helper ( 'sheep_debug/filter' ) ; $ select = $ this -> getLayout ( ) -> createBlock ( 'core/html_select' ) ; $ select -> setName ( 'limit' ) -> setId ( 'limit' ) -> setValue ( $ this -> getRequest ( ) -> getParam ( 'limit' , $ filterHelper -> getLimitDefaultValue ( ) ) ) -> setOptions ( $ this -> getOptionArray ( $ filterHelper -> getLimitValues ( ) ) ) ; return $ select -> getHtml ( ) ; }
6995	public static function parseApplePriceMatrix ( $ dom , $ currency , $ directory = null ) { if ( is_string ( $ dom ) ) { if ( file_exists ( $ dom ) && is_file ( $ dom ) ) { $ file = $ dom ; $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTMLFile ( $ file ) ; unset ( $ file ) ; } else { $ content = $ dom ; $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTML ( $ content ) ; unset ( $ content ) ; } } if ( ! $ dom instanceof \ DOMDocument ) { throw new \ InvalidArgumentException ( sprintf ( 'The first argument must be a DOMDocument instance or path to ApplePriceMatrix file, "%s" given.' , is_object ( $ dom ) ? get_class ( $ dom ) : gettype ( $ dom ) ) ) ; } $ currency = strtoupper ( $ currency ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ tierPrimary = static :: parseApplePriceMatrixTier ( $ xpath , 1 , $ currency ) ; $ tierAlternative = static :: parseApplePriceMatrixTier ( $ xpath , 2 , $ currency ) ; $ prices = $ tierPrimary + $ tierAlternative ; ksort ( $ prices ) ; if ( $ directory ) { if ( ! is_writable ( $ directory ) ) { throw new \ RuntimeException ( sprintf ( 'Could not write prices map to directory "%s". Directory is not writable.' , $ directory ) ) ; } $ file = $ directory . '/' . $ currency . '.php' ; file_put_contents ( $ file , '<?php return ' . var_export ( $ prices , 1 ) . ';' ) ; } return $ prices ; }
3614	public function setTargetTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
4953	public function call ( $ method , $ args = [ ] , $ expect = self :: EXPECT_SELF ) { if ( ! is_array ( $ args ) ) { $ expect = $ args ; $ args = [ ] ; } if ( ! $ this -> helper ) { return $ this -> expected ( $ expect ) ; } return call_user_func_array ( [ $ this -> helper , $ method ] , $ args ) ; }
1479	public function removeRelationship ( $ resourceType , $ id , $ relationshipKey , array $ queryParams = [ ] ) { $ name = RouteName :: removeRelationship ( $ resourceType , $ relationshipKey ) ; return $ this -> resource ( $ name , $ id , $ queryParams ) ; }
10027	function getContactByEmail ( $ email , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/email/' . utf8_encode ( $ email ) , $ queryParameters ) ; }
8157	public function prependPath ( $ path , $ namespace = self :: MAIN_NAMESPACE ) { $ this -> cache = $ this -> errorCache = array ( ) ; $ checkPath = $ this -> isAbsolutePath ( $ path ) ? $ path : $ this -> rootPath . $ path ; if ( ! is_dir ( $ checkPath ) ) { throw new Twig_Error_Loader ( sprintf ( 'The "%s" directory does not exist ("%s").' , $ path , $ checkPath ) ) ; } $ path = rtrim ( $ path , '/\\' ) ; if ( ! isset ( $ this -> paths [ $ namespace ] ) ) { $ this -> paths [ $ namespace ] [ ] = $ path ; } else { array_unshift ( $ this -> paths [ $ namespace ] , $ path ) ; } }
204	public static function moveCursorTo ( $ column , $ row = null ) { if ( $ row === null ) { echo "\033[" . ( int ) $ column . 'G' ; } else { echo "\033[" . ( int ) $ row . ';' . ( int ) $ column . 'H' ; } }
2528	protected function getActionFromWsdl ( $ wsdlFilePath , $ messageName ) { $ wsdlId = $ this -> getWsdlIdFor ( $ messageName ) ; return WsdlAnalyser :: exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , sprintf ( self :: XPATH_OPERATION_ACTION , $ messageName ) ) ; }
8966	public static function exists ( $ currencyCode ) { $ currencyCode = trim ( strtoupper ( $ currencyCode ) ) ; return array_key_exists ( $ currencyCode , self :: $ codes ) ; }
1550	protected function getRelation ( $ record , $ key ) { $ relation = $ record -> { $ key } ( ) ; if ( ! $ relation || ! $ this -> acceptRelation ( $ relation ) ) { throw new RuntimeException ( sprintf ( 'JSON API relation %s cannot be used for an Eloquent %s relation.' , class_basename ( $ this ) , class_basename ( $ relation ) ) ) ; } return $ relation ; }
4281	public function stream_tell ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ position = \ ftell ( $ this -> handle ) ; self :: register ( ) ; return $ position ; }
9960	public function setAutoFilterByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { return $ this -> setAutoFilter ( Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ) ; }
3690	public function handleCreateVariantAction ( ActionEvent $ event ) { if ( false === $ this -> scopeMatcher -> currentScopeIsBackend ( ) || 'createvariant' !== $ event -> getAction ( ) -> getName ( ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ view = $ environment -> getView ( ) ; $ dataProvider = $ environment -> getDataProvider ( ) ; $ inputProvider = $ environment -> getInputProvider ( ) ; $ modelId = $ inputProvider -> hasParameter ( 'id' ) ? ModelId :: fromSerialized ( $ inputProvider -> getParameter ( 'id' ) ) : null ; $ model = $ dataProvider -> createVariant ( $ dataProvider -> getEmptyConfig ( ) -> setId ( $ modelId -> getId ( ) ) ) ; if ( $ model == null ) { throw new \ RuntimeException ( sprintf ( 'Could not find model with id %s for creating a variant.' , $ modelId ) ) ; } $ metaModel = $ this -> factory -> getMetaModel ( $ model -> getProviderName ( ) ) ; if ( ! $ metaModel || ! $ metaModel -> hasVariants ( ) ) { return ; } $ preFunction = function ( $ environment , $ model ) { $ copyEvent = new PreCreateModelEvent ( $ environment , $ model ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ copyEvent :: NAME , $ copyEvent ) ; } ; $ postFunction = function ( $ environment , $ model ) { $ copyEvent = new PostCreateModelEvent ( $ environment , $ model ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ copyEvent :: NAME , $ copyEvent ) ; } ; if ( ! $ view instanceof BackendViewInterface ) { throw new \ InvalidArgumentException ( 'Invalid view registered in environment.' ) ; } $ editMask = new EditMask ( $ view , $ model , null , $ preFunction , $ postFunction , $ this -> breadcrumb ( $ environment ) ) ; $ event -> setResponse ( $ editMask -> execute ( ) ) ; }
1158	protected function ruleAfter ( $ attribute , array $ parameters ) { if ( ! ( $ date = strtotime ( $ parameters [ 0 ] ) ) ) { $ date = $ this -> getAttributeName ( $ parameters [ 0 ] ) ; } return [ $ attribute , [ $ date ] ] ; }
10968	public static function getPath ( ) { $ uri = isset ( $ _SERVER [ 'REQUEST_URI' ] ) ? $ _SERVER [ 'REQUEST_URI' ] : '' ; if ( strpos ( $ uri , '?' ) > 0 ) { $ uri = substr ( $ uri , 0 , strpos ( $ uri , '?' ) ) ; } $ uri = preg_replace ( "/^\\/(.*)$/" , "$1" , $ uri ) ; $ uri = preg_replace ( "/^(.*)\\/$/" , "$1" , $ uri ) ; return $ uri ; }
3982	private function extractUserRights ( TokenInterface $ token ) { $ beUser = $ token -> getUser ( ) ; if ( ! ( $ beUser instanceof BackendUser ) ) { return [ ] ; } $ allowedModules = $ beUser -> modules ; switch ( true ) { case \ is_string ( $ allowedModules ) : $ allowedModules = unserialize ( $ allowedModules , [ 'allowed_classes' => false ] ) ; break ; case null === $ allowedModules : $ allowedModules = [ ] ; break ; default : } return array_flip ( $ allowedModules ) ; }
8589	public function setReportScheduleList ( $ reportSchedule ) { if ( ! $ this -> _isNumericArray ( $ reportSchedule ) ) { $ reportSchedule = array ( $ reportSchedule ) ; } $ this -> fields [ 'ReportSchedule' ] [ 'FieldValue' ] = $ reportSchedule ; return $ this ; }
4300	public function groupEnd ( $ value = \ bdk \ Debug \ Abstracter :: UNDEFINED ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'value' => \ bdk \ Debug \ Abstracter :: UNDEFINED ) ) ; \ extract ( $ args ) ; $ groupStackWas = $ this -> rootInstance -> groupStackRef ; $ appendLog = false ; if ( $ groupStackWas && \ end ( $ groupStackWas ) [ 'collect' ] == $ this -> cfg [ 'collect' ] ) { \ array_pop ( $ this -> rootInstance -> groupStackRef ) ; $ appendLog = $ this -> cfg [ 'collect' ] ; } if ( $ appendLog && $ value !== \ bdk \ Debug \ Abstracter :: UNDEFINED ) { $ this -> appendLog ( 'groupEndValue' , array ( 'return' , $ value ) , $ meta ) ; } if ( $ this -> data [ 'groupPriorityStack' ] && ! $ groupStackWas ) { $ priorityClosing = \ array_pop ( $ this -> data [ 'groupPriorityStack' ] ) ; unset ( $ this -> data [ 'groupStacks' ] [ $ priorityClosing ] ) ; $ this -> setLogDest ( 'auto' ) ; $ meta [ 'closesSummary' ] = true ; $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; } elseif ( $ appendLog ) { $ this -> appendLog ( 'groupEnd' , array ( ) , $ meta ) ; } $ errorCaller = $ this -> errorHandler -> get ( 'errorCaller' ) ; if ( $ errorCaller && isset ( $ errorCaller [ 'groupDepth' ] ) && $ this -> getGroupDepth ( ) < $ errorCaller [ 'groupDepth' ] ) { $ this -> errorHandler -> setErrorCaller ( false ) ; } }
3129	private function loadItemData ( $ itemRef , $ path ) { $ cacheKey = $ itemRef . $ path ; if ( ! empty ( $ cacheKey ) && isset ( $ this -> dataCache [ $ itemRef . $ path ] ) ) { return $ this -> dataCache [ $ itemRef . $ path ] ; } $ directoryIds = explode ( '|' , $ itemRef ) ; if ( count ( $ directoryIds ) < 3 ) { if ( is_scalar ( $ itemRef ) ) { $ itemRefInfo = gettype ( $ itemRef ) . ': ' . strval ( $ itemRef ) ; } elseif ( is_object ( $ itemRef ) ) { $ itemRefInfo = gettype ( $ itemRef ) . ': ' . get_class ( $ itemRef ) ; } else { $ itemRefInfo = gettype ( $ itemRef ) ; } throw new \ common_exception_InconsistentData ( "The itemRef (value = '${itemRefInfo}') is not formatted correctly." ) ; } $ itemUri = $ directoryIds [ 0 ] ; $ userDataLang = \ common_session_SessionManager :: getSession ( ) -> getDataLanguage ( ) ; $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 2 ] ) ; if ( $ directory -> has ( $ userDataLang ) ) { $ lang = $ userDataLang ; } elseif ( $ directory -> has ( DEFAULT_LANG ) ) { \ common_Logger :: d ( $ userDataLang . ' is not part of compilation directory for item : ' . $ itemUri . ' use ' . DEFAULT_LANG ) ; $ lang = DEFAULT_LANG ; } else { throw new \ common_Exception ( 'item : ' . $ itemUri . 'is neither compiled in ' . $ userDataLang . ' nor in ' . DEFAULT_LANG ) ; } try { $ content = $ directory -> read ( $ lang . DIRECTORY_SEPARATOR . $ path ) ; $ assetService = $ this -> getServiceManager ( ) -> get ( ItemAssetsReplacement :: SERVICE_ID ) ; $ jsonContent = json_decode ( $ content , true ) ; $ jsonAssets = [ ] ; if ( isset ( $ jsonContent [ 'assets' ] ) ) { foreach ( $ jsonContent [ 'assets' ] as $ type => $ assets ) { foreach ( $ assets as $ key => $ asset ) { $ jsonAssets [ $ type ] [ $ key ] = $ assetService -> postProcessAssets ( $ asset ) ; } } $ jsonContent [ "assets" ] = $ jsonAssets ; } $ this -> dataCache [ $ cacheKey ] = $ jsonContent ; return $ this -> dataCache [ $ cacheKey ] ; } catch ( \ FileNotFoundException $ e ) { throw new \ tao_models_classes_FileNotFoundException ( $ path . ' for item reference ' . $ itemRef ) ; } catch ( \ League \ Flysystem \ FileNotFoundException $ e ) { throw new \ tao_models_classes_FileNotFoundException ( $ path . ' for item reference ' . $ itemRef ) ; } }
11671	public function executeRaw ( array $ arguments , & $ error = null ) { $ error = false ; $ commandID = array_shift ( $ arguments ) ; $ response = $ this -> connection -> executeCommand ( new RawCommand ( $ commandID , $ arguments ) ) ; if ( $ response instanceof ResponseInterface ) { if ( $ response instanceof ErrorResponseInterface ) { $ error = true ; } return ( string ) $ response ; } return $ response ; }
7931	public function appendToCollection ( array $ data ) { list ( $ data ) = $ this -> fireEvent ( 'append-to-collection' , [ $ data ] ) ; $ files = [ ] ; if ( isset ( $ data [ 'files' ] [ 'js' ] ) && is_array ( $ data [ 'files' ] [ 'js' ] ) ) $ files [ 'js' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'js' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; if ( isset ( $ data [ 'files' ] [ 'css' ] ) && is_array ( $ data [ 'files' ] [ 'css' ] ) ) $ files [ 'css' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'css' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; $ this -> collection [ ] = [ 'order' => isset ( $ data [ 'order' ] ) ? $ data [ 'order' ] : 0 , 'name' => isset ( $ data [ 'name' ] ) ? $ data [ 'name' ] : uniqid ( ) , 'files' => $ files , 'group' => isset ( $ data [ 'group' ] ) ? $ data [ 'group' ] : $ this -> defaultGroup , 'require' => isset ( $ data [ 'require' ] ) ? $ data [ 'require' ] : [ ] ] ; return $ this ; }
6976	protected function scheduleSaleContentChangeEvent ( Model \ AdjustmentInterface $ adjustment ) { if ( $ adjustment instanceof Model \ SaleAdjustmentInterface ) { if ( null === $ sale = $ this -> getSaleFromAdjustment ( $ adjustment ) ) { return ; } } elseif ( $ adjustment instanceof Model \ SaleItemAdjustmentInterface ) { if ( null === $ item = $ this -> getItemFromAdjustment ( $ adjustment ) ) { return ; } if ( null === $ sale = $ this -> getSaleFromItem ( $ item ) ) { return ; } } else { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ this -> persistenceHelper -> scheduleEvent ( $ this -> getSaleChangeEvent ( ) , $ sale ) ; }
11847	final public function save ( ) { $ this -> checkReadOnly ( ) ; $ this -> _save ( ) ; if ( count ( $ this -> _errors ) ) { throw new Zend_Db_Table_Row_Exception ( 'This row contain errors.' ) ; } foreach ( $ this -> _data as $ column => & $ value ) { if ( $ value instanceof DateTime ) { if ( ! ( $ value instanceof Benri_Util_DateTime ) ) { $ value = new Benri_Util_DateTime ( $ value -> format ( 'U' ) ) ; } $ value -> setFormat ( 'Y-m-d H:i:s' ) ; } } if ( $ this -> isNewRecord ( ) ) { if ( $ this -> offsetExists ( 'created_at' ) ) { $ this -> created_at = new Benri_Util_DateTime ( ) ; $ this -> created_at -> setFormat ( 'Y-m-d H:i:s' ) ; } } if ( $ this -> offsetExists ( 'updated_at' ) ) { $ this -> updated_at = new Benri_Util_DateTime ( ) ; $ this -> updated_at -> setFormat ( 'Y-m-d H:i:s' ) ; } parent :: save ( ) ; $ this -> _postSave ( ) ; return $ this ; }
12758	public static function getNew ( ) { $ class = new MediaLink ; $ medialink = get_class_vars ( get_class ( $ class ) ) ; foreach ( $ medialink as $ name => $ default ) : $ class :: set ( $ name , null ) ; $ class :: set ( "objectType" , "medialink" ) ; endforeach ; return $ class ; }
10938	private static function populateEntries ( $ heading , $ data , $ key ) { foreach ( LogLevels :: all ( ) as $ level ) { if ( self :: hasLogLevel ( $ heading [ $ key ] , $ level ) ) { self :: $ parsed [ ] = [ 'level' => $ level , 'header' => $ heading [ $ key ] , 'stack' => $ data [ $ key ] , ] ; } } }
2822	protected function _afterLoad ( ) { $ info = $ this -> getUnserializedInfo ( ) ; $ this -> logging = $ info [ 'logging' ] ; $ this -> action = $ info [ 'action' ] ; $ this -> design = $ info [ 'design' ] ; $ this -> blocks = $ info [ 'blocks' ] ; $ this -> models = $ info [ 'models' ] ; $ this -> collections = $ info [ 'collections' ] ; $ this -> queries = $ info [ 'queries' ] ; $ this -> timers = $ info [ 'timers' ] ; $ this -> emails = $ info [ 'emails' ] ; return parent :: _afterLoad ( ) ; }
9654	public function getForPath ( $ path ) { $ extension = $ this -> getExtension ( $ path ) ; if ( ! isset ( $ this -> loaders [ $ extension ] ) ) { $ this -> resolveLoader ( $ extension ) ; } return $ this -> loaders [ $ extension ] ; }
8615	public function setSalesRank ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SalesRank' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5416	protected function dispatchRequest ( $ socket , $ encoding ) { foreach ( $ this -> headers as $ header_line ) { $ socket -> write ( $ header_line . "\r\n" ) ; } if ( count ( $ this -> cookies ) > 0 ) { $ socket -> write ( 'Cookie: ' . implode ( ';' , $ this -> cookies ) . "\r\n" ) ; } $ encoding -> writeHeadersTo ( $ socket ) ; $ socket -> write ( "\r\n" ) ; $ encoding -> writeTo ( $ socket ) ; }
12676	public function approve ( $ sourceDir , array $ options , $ username ) { $ this -> init ( $ sourceDir , $ options , $ username ) ; $ sourceFilename = sprintf ( '%s/blocks/%s.json' , $ this -> contributorDir , $ options [ 'blockname' ] ) ; $ targetFilename = sprintf ( '%s/blocks/%s.json' , $ this -> productionDir , $ options [ 'blockname' ] ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVING , new BlockApprovingEvent ( $ this -> serializer , $ sourceFilename , $ targetFilename ) ) ; $ blockValues = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ sourceFilename ) ) ; $ blockValues [ "history" ] = array ( ) ; FilesystemTools :: writeFile ( $ targetFilename , json_encode ( $ blockValues ) ) ; $ slotDefinitionContribution = $ this -> getSlotDefinition ( $ this -> getContributorDir ( ) ) ; $ this -> saveSlotDefinition ( $ this -> productionDir , $ slotDefinitionContribution ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVED , new BlockApprovedEvent ( $ this -> serializer , $ sourceFilename , $ targetFilename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been approved on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; return $ blockValues ; }
3083	public function getAssessmentItemRefByIdentifier ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , $ identifier ) { $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-item-ref-${identifier}" ; return $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , "${filename}" ) ; }
4303	public function profile ( $ name = null ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } if ( ! $ this -> cfg [ 'enableProfiling' ] ) { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ this -> appendLog ( __FUNCTION__ , array ( 'Profile: Unable to start - enableProfiling opt not set. ' . $ callerInfo [ 'file' ] . ' on line ' . $ callerInfo [ 'line' ] . '.' ) ) ; return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) ) ; if ( $ meta [ 'name' ] === null ) { $ meta [ 'name' ] = 'Profile ' . $ this -> data [ 'profileAutoInc' ] ; $ this -> data [ 'profileAutoInc' ] ++ ; } $ name = $ meta [ 'name' ] ; $ message = '' ; if ( isset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ) { $ instance = $ this -> data [ 'profileInstances' ] [ $ name ] ; $ instance -> end ( ) ; $ instance -> start ( ) ; unset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ; $ this -> data [ 'profileInstances' ] [ $ name ] = $ instance ; $ message = 'Profile \'' . $ name . '\' restarted' ; } else { $ this -> data [ 'profileInstances' ] [ $ name ] = $ this -> methodProfile ; $ message = 'Profile \'' . $ name . '\' started' ; } $ this -> appendLog ( __FUNCTION__ , array ( $ message , ) , $ meta ) ; }
10614	public function createMigrateRepository ( array $ args ) { $ db = $ this -> app -> db ; $ repo = new Repository ( $ db ) ; $ resolver = $ this -> app -> resolver -> getResolver ( "migrations" ) ; $ mods = [ ] ; foreach ( $ resolver -> getSearchPath ( ) as $ name => $ path ) { $ module = new Module ( $ name , $ path , $ db ) ; if ( $ name === "wedeto.db" ) array_unshift ( $ mods , $ module ) ; else array_push ( $ mods , $ module ) ; } foreach ( $ mods as $ module ) $ repo -> addModule ( $ module ) ; return $ repo ; }
9061	private function getTableData ( $ table ) : self { if ( $ table instanceof Table ) { return $ table ; } elseif ( is_subclass_of ( $ table , Mapper :: class ) ) { $ mapper = $ this -> container -> getByType ( $ table ) ; return $ mapper -> getStructure ( ) ; } else { throw new InvalidArgumentException ; } }
4089	protected function buildUrl ( $ path = false , array $ options = array ( ) ) { $ isAbsolute = ( is_array ( $ path ) ? $ path [ 0 ] [ 0 ] : $ path [ 0 ] ) === '/' ; $ url = $ isAbsolute || null === $ this -> index ? '' : "/" . $ this -> index ; if ( $ path && is_array ( $ path ) && count ( $ path ) > 0 ) $ url .= "/" . implode ( "/" , array_filter ( $ path ) ) ; if ( substr ( $ url , - 1 ) == "/" ) $ url = substr ( $ url , 0 , - 1 ) ; if ( count ( $ options ) > 0 ) $ url .= "?" . http_build_query ( $ options , '' , '&' ) ; return $ url ; }
4837	public function confirm_resource ( $ params ) { $ endpoint = '/confirm' ; $ required_params = array ( 'resource_id' , 'resource_type' ) ; foreach ( $ required_params as $ key => $ value ) { if ( ! isset ( $ params [ $ value ] ) ) { throw new GoCardless_ArgumentsException ( "$value missing" ) ; } $ data [ $ value ] = $ params [ $ value ] ; } if ( isset ( $ params [ 'state' ] ) ) { $ data [ 'state' ] = $ params [ 'state' ] ; } if ( isset ( $ params [ 'resource_uri' ] ) ) { $ data [ 'resource_uri' ] = $ params [ 'resource_uri' ] ; } $ sig_validation_data = array ( 'data' => $ data , 'secret' => $ this -> account_details [ 'app_secret' ] , 'signature' => $ params [ 'signature' ] ) ; if ( $ this -> validate_signature ( $ sig_validation_data ) == false ) { throw new GoCardless_SignatureException ( ) ; } $ confirm_params = array ( 'resource_id' => $ params [ 'resource_id' ] , 'resource_type' => $ params [ 'resource_type' ] ) ; $ confirm_params [ 'http_authorization' ] = $ this -> account_details [ 'app_id' ] . ':' . $ this -> account_details [ 'app_secret' ] ; if ( ! isset ( $ params [ 'redirect_uri' ] ) && isset ( $ this -> redirect_uri ) ) { $ confirm_params [ 'redirect_uri' ] = $ this -> redirect_uri ; } $ response = $ this -> request ( 'post' , $ endpoint , $ confirm_params ) ; if ( $ response [ 'success' ] == true ) { $ endpoint = '/' . $ params [ 'resource_type' ] . 's/' . $ params [ 'resource_id' ] ; $ class_name = 'GoCardless_' . GoCardless_Utils :: camelize ( $ params [ 'resource_type' ] ) ; return new $ class_name ( $ this , $ this -> request ( 'get' , $ endpoint ) ) ; } else { throw new GoCardless_ClientException ( 'Failed to fetch the confirmed resource.' ) ; } }
2611	public function getActiveVersion ( $ service , $ activeVersion ) { $ currActiveVersion = $ this -> determineVersions ( $ service -> versions ) ; if ( $ currActiveVersion [ 'active_version' ] != $ activeVersion ) { throw new LocalizedException ( __ ( 'Active versions mismatch.' ) ) ; } return $ currActiveVersion ; }
10290	protected function storeLastRun ( ) { if ( ! @ file_put_contents ( $ this -> lockDir . '/lastRun' , time ( ) ) ) { $ this -> logger -> log ( 'Failure storing last run time: ' . ( isset ( $ php_errormsg ) ? $ php_errormsg : 'Unknown error - enable the track_errors ini directive.' ) , Logger :: ERROR ) ; return ; } $ this -> logger -> log ( 'Stored last run time.' , Logger :: INFO ) ; }
5800	public function delete ( int $ id , AuthenticationService $ authentication , AuthorizationService $ authorization ) : string { if ( null === $ administrator = $ this -> getObjectById ( $ id ) ) { throw new Exceptions \ QueryResultsNotFoundException ( ) ; } $ administrator -> setAuth ( $ authentication , $ authorization ) ; if ( ! $ administrator -> isDeletable ( ) ) { throw new Exceptions \ UnallowedActionException ( $ administrator -> getNotDeletableReason ( ) ) ; } $ this -> doDeleteTransaction ( $ id ) ; $ username = $ administrator -> getUsername ( ) ; unset ( $ administrator ) ; return $ username ; }
8370	public function perform ( array $ args = [ ] ) : int { $ this -> args = $ args ; unset ( $ this -> args [ 'messages' ] ) ; $ transport = new Swift_SmtpTransport ( $ args [ 'smtp' ] [ 'host' ] , $ args [ 'smtp' ] [ 'port' ] ) ; $ transport -> setUsername ( $ args [ 'smtp' ] [ 'username' ] ) ; $ transport -> setPassword ( $ args [ 'smtp' ] [ 'password' ] ) ; $ this -> messages = $ args [ 'messages' ] ; foreach ( $ messages as & $ message ) { if ( $ shutdown ) { break ; } $ mailer = new Swift_Mailer ( $ transport ) ; $ m = ( new Swift_Message ( $ message [ 'subject' ] ) ) -> setFrom ( [ $ message [ 'from' ] [ 'email' ] => $ message [ 'from' ] [ 'email' ] ] ) -> setTo ( [ $ message [ 'to' ] [ 'email' ] => $ message [ 'to' ] [ 'name' ] ] ) -> setBody ( $ message [ 'message' ] ) ; $ message [ 'sent' ] = ( $ mailer -> send ( $ m ) === 1 ) ; } return 0 ; }
4893	protected function array_compare ( $ array1 , $ array2 , $ maxDepth = 2 ) { $ result = array ( ) ; $ arraykeys = array_unique ( array_merge ( array_keys ( $ array1 ) , array_keys ( $ array2 ) ) ) ; foreach ( $ arraykeys as $ key ) { if ( ! empty ( $ key ) && is_string ( $ key ) && $ key [ 0 ] != "\0" && substr ( $ key , 0 , 8 ) != 'Doctrine' ) { if ( array_key_exists ( $ key , $ array1 ) && ! array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , '' ) ; } if ( ! array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( '' , $ array2 [ $ key ] ) ; } if ( array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ subResult = null ; if ( is_array ( $ array1 [ $ key ] ) && is_array ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ subResult = $ this -> array_compare ( $ array1 [ $ key ] , $ array2 [ $ key ] , $ maxDepth - 1 ) ; } } elseif ( is_object ( $ array1 [ $ key ] ) && is_object ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ hydrator = new EntityHydrator ( ) ; $ a1 = $ hydrator -> extract ( $ array1 [ $ key ] ) ; $ a2 = $ hydrator -> extract ( $ array2 [ $ key ] ) ; $ subResult = $ this -> array_compare ( $ a1 , $ a2 , $ maxDepth - 1 ) ; } } else { if ( $ array1 [ $ key ] != $ array2 [ $ key ] ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , $ array2 [ $ key ] ) ; } } if ( ! empty ( $ subResult ) ) { foreach ( $ subResult as $ subKey => $ subValue ) { if ( ! empty ( $ subKey ) && is_string ( $ subKey ) ) { $ result [ $ key . '.' . $ subKey ] = $ subValue ; } } } } } } return $ result ; }
1203	private function buildExtras ( ItemInterface $ item , array $ options ) { if ( ! empty ( $ options [ 'extras' ] ) ) { foreach ( $ options [ 'extras' ] as $ key => $ value ) { $ item -> setExtra ( $ key , $ value ) ; } } }
2837	public function getInfoAsArray ( ) { return array ( 'design_area' => $ this -> getArea ( ) , 'package_name' => $ this -> getPackageName ( ) , 'layout_theme' => $ this -> getThemeLayout ( ) , 'template_theme' => $ this -> getThemeTemplate ( ) , 'locale' => $ this -> getThemeLocale ( ) , 'skin' => $ this -> getThemeSkin ( ) ) ; }
3024	public function getBlogPosts ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/posts' ) ; if ( $ options && isset ( $ options [ 'type' ] ) ) { $ path .= '/' . $ options [ 'type' ] ; unset ( $ options [ 'type' ] ) ; } return $ this -> getRequest ( $ path , $ options , true ) ; }
11103	public function filter ( ScopeInterface $ scope ) { $ filtered = new self ; foreach ( $ this as $ eachResult ) { if ( $ eachResult -> getScope ( ) -> isEqualTo ( $ scope ) ) { $ filtered -> add ( $ eachResult ) ; } } return $ filtered ; }
7200	protected function detachSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> detachSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> detachSaleItemRecursively ( $ child ) ; } }
10565	protected function formatJson ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/json; charset=UTF-8' ) ; if ( $ response -> data !== null ) { $ options = $ this -> encodeOptions ; if ( $ this -> prettyPrint ) { $ options |= JSON_PRETTY_PRINT ; } $ response -> content = Json :: encode ( $ response -> data , $ options ) ; } }
12043	public function search ( $ query , & $ results = array ( ) ) { if ( ! empty ( $ query ) ) : $ words = explode ( ' ' , $ query ) ; foreach ( $ words as $ word ) { $ _results = $ this -> setListLookUpConditions ( "user_first_name" , $ word , 'OR' ) -> setListLookUpConditions ( "user_last_name" , $ word , 'OR' ) -> setListLookUpConditions ( "user_middle_name" , $ word , 'OR' ) -> setListLookUpConditions ( "user_name_id" , $ word , 'OR' ) ; } $ _results = $ this -> getObjectsList ( "user" ) ; $ rows = $ _results -> fetchAll ( ) ; $ members = array ( "filterid" => "users" , "title" => "People" , "results" => array ( ) ) ; foreach ( $ rows as $ member ) { $ photo = empty ( $ member [ 'user_photo' ] ) ? "" : "/system/object/{$member['user_photo']}/resize/170/170" ; $ members [ "results" ] [ ] = array ( "icon" => $ photo , "link" => "/member:{$member['user_name_id']}/profile/timeline" , "title" => $ this -> getFullName ( $ member [ 'user_first_name' ] , $ member [ 'user_middle_name' ] , $ member [ 'user_last_name' ] ) , "description" => "" , "type" => $ member [ 'object_type' ] , "user_name_id" => $ member [ 'user_name_id' ] ) ; } if ( ! empty ( $ members [ "results" ] ) ) $ results [ ] = $ members ; endif ; return true ; }
8718	public static function forceCreateInLocale ( $ locale , array $ attributes , $ translations = [ ] ) { $ model = new static ; return static :: unguarded ( function ( ) use ( $ locale , $ model , $ attributes , $ translations ) { return $ model -> createInLocale ( $ locale , $ attributes , $ translations ) ; } ) ; }
11243	public function setDirection ( Neuron_GameServer_Map_Vector3 $ start , Neuron_GameServer_Map_Vector3 $ end ) { $ this -> startRotation = $ start ; $ this -> endRotation = $ end ; }
9950	public function duplicateStyle ( Style $ pCellStyle , $ pRange ) { $ workbook = $ this -> parent ; if ( $ existingStyle = $ this -> parent -> getCellXfByHashCode ( $ pCellStyle -> getHashCode ( ) ) ) { $ xfIndex = $ existingStyle -> getIndex ( ) ; } else { $ workbook -> addCellXf ( $ pCellStyle ) ; $ xfIndex = $ pCellStyle -> getIndex ( ) ; } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> getCell ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row ) -> setXfIndex ( $ xfIndex ) ; } } return $ this ; }
12322	public function run ( InputInterface $ input , OutputInterface $ output ) { $ this -> doPreRun ( $ input , $ output ) ; $ code = parent :: run ( $ input , $ output ) ; $ this -> doPostRun ( $ input , $ output , $ code ) ; return $ code ; }
12431	protected function generateContentTypeFilter ( $ contentType ) { $ filter = null ; if ( ! is_null ( $ contentType ) && '' != $ contentType ) { $ filter = array ( 'contentType' => $ contentType ) ; } return $ filter ; }
2857	public function viewHandleAction ( ) { $ area = $ this -> getRequest ( ) -> getParam ( 'area' ) ; $ storeId = ( int ) $ this -> getRequest ( ) -> getParam ( 'store' ) ; $ handle = $ this -> getRequest ( ) -> getParam ( 'handle' ) ; $ updatesByFile = $ this -> getService ( ) -> getFileUpdatesWithHandle ( $ handle , $ storeId , $ area ) ; $ databaseUpdates = $ this -> getService ( ) -> getDatabaseUpdatesWithHandle ( $ handle , $ storeId , $ area ) ; $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' , '' , array ( 'template' => 'sheep_debug/view/panel/_layout_updates.phtml' , 'file_updates' => $ updatesByFile , 'db_updates' => $ databaseUpdates ) ) ; $ this -> getResponse ( ) -> setBody ( $ block -> toHtml ( ) ) ; }
10403	public function onConsume ( ItemPipelineEvent $ event ) { if ( $ event -> getItemSkip ( ) ) { $ this -> skip ( $ event ) ; } else { $ this -> consume ( $ event ) ; } }
10575	public static function apply ( $ text , $ foreground = '' , $ background = '' ) { try { $ style = new OutputFormatterStyle ( ) ; if ( $ foreground != '' ) { $ style -> setForeground ( $ foreground ) ; } if ( $ background != '' ) { $ style -> setBackground ( $ background ) ; } return $ style -> apply ( $ text ) ; } catch ( \ Exception $ e ) { return $ text ; } }
12196	public static function current ( ) { if ( defined ( 'PHPUNIT_RUNNING' ) ) { return 'http://localhost' ; } $ protocol = 'http://' ; if ( ! empty ( $ _SERVER [ 'HTTPS' ] ) || ( ! empty ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] === 'https' ) ) { $ protocol = 'https://' ; } return $ protocol . request ( ) -> server ( 'HTTP_HOST' ) . request ( ) -> server ( 'REQUEST_URI' ) ; }
10044	private function createSelectAssociationFormItem ( Model $ model , Column $ column , $ item ) { $ result = new SelectFormItem ( ) ; $ relations = $ this -> aujaConfigurator -> getRelationsForModel ( $ model ) ; $ relatedModel = null ; foreach ( $ relations as $ relation ) { $ rightModel = $ relation -> getRight ( ) ; if ( starts_with ( $ column -> getName ( ) , camel_case ( $ rightModel -> getName ( ) ) ) ) { $ relatedModel = $ rightModel ; } } if ( $ relatedModel != null ) { $ displayName = $ this -> aujaConfigurator -> getDisplayName ( $ relatedModel ) ; $ result -> setName ( $ displayName ) ; $ result -> setValue ( $ item -> id ) ; $ items = call_user_func ( array ( $ relatedModel -> getName ( ) , 'all' ) ) ; $ displayField = $ this -> aujaConfigurator -> getDisplayField ( $ relatedModel ) ; foreach ( $ items as $ item ) { $ label = isset ( $ item -> $ displayField ) ? $ item -> $ displayField : '' ; $ value = $ item -> id ; $ option = new SelectOption ( $ label , $ value ) ; $ result -> addOption ( $ option ) ; } } return $ result ; }
3748	protected function getIdsFromFilter ( $ filter , $ config ) { $ sorting = $ this -> extractSorting ( $ config ) ; return $ this -> getMetaModel ( ) -> getIdsFromFilter ( $ filter , $ sorting [ 0 ] , $ config -> getStart ( ) , $ config -> getAmount ( ) , strtoupper ( $ sorting [ 1 ] ) ) ; }
308	protected function createRule ( $ pattern , $ prefix , $ action ) { $ verbs = 'GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS' ; if ( preg_match ( "/^((?:($verbs),)*($verbs))(?:\\s+(.*))?$/" , $ pattern , $ matches ) ) { $ verbs = explode ( ',' , $ matches [ 1 ] ) ; $ pattern = isset ( $ matches [ 4 ] ) ? $ matches [ 4 ] : '' ; } else { $ verbs = [ ] ; } $ config = $ this -> ruleConfig ; $ config [ 'verb' ] = $ verbs ; $ config [ 'pattern' ] = rtrim ( $ prefix . '/' . strtr ( $ pattern , $ this -> tokens ) , '/' ) ; $ config [ 'route' ] = $ action ; if ( ! empty ( $ verbs ) && ! in_array ( 'GET' , $ verbs ) ) { $ config [ 'mode' ] = WebUrlRule :: PARSING_ONLY ; } $ config [ 'suffix' ] = $ this -> suffix ; return Yii :: createObject ( $ config ) ; }
11959	public function splice ( $ offset = 0 , $ length = 0 , $ replacement = [ ] ) { return new static ( array_splice ( $ this -> elements , $ offset , $ length , $ replacement ) ) ; }
8877	public static function formatDate ( $ timestamp , $ type = 'full_sort' , $ format = '' , $ timezone = null ) { switch ( $ type ) { case 'date_sort' : $ format = 'Y-m-d' ; break ; case 'date_long' : $ format = 'l, F j, Y' ; break ; case 'date_med' : $ format = 'j M Y' ; break ; case 'date_short' : $ format = 'n/d/Y' ; break ; case 'time_sort' : $ format = 'H:i T' ; break ; case 'time_long' : $ format = 'g:i:s A T' ; break ; case 'time_med' : $ format = 'g:i:s A' ; break ; case 'time_short' : $ format = 'g:i A' ; break ; case 'full_sort' : $ format = 'Y-m-d H:i T' ; break ; case 'full_long' : $ format = 'l, F j, Y g:i A T' ; break ; case 'full_med' : $ format = 'j M Y g:i A T' ; break ; case 'full_short' : $ format = 'n/d/Y g:i A T' ; break ; case 'custom' : default : break ; } try { $ date = new \ DateTime ( gmdate ( 'c' , ( int ) $ timestamp ) ) ; if ( isset ( $ timezone ) ) { if ( ! is_object ( $ timezone ) ) { $ timezone = new \ DateTimeZone ( $ timezone ) ; } $ date -> setTimezone ( $ timezone ) ; } else { $ date -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; } } catch ( \ Exception $ e ) { throw new \ Exception ( "Error formatting date: $e" ) ; } return $ date -> format ( $ format ) ; }
7455	protected function getTaxonomies ( string $ post_type ) : array { $ return = [ ] ; $ taxes = \ get_object_taxonomies ( $ post_type , 'objects' ) ; foreach ( $ taxes as $ tax_slug => $ tax_object ) { if ( \ is_taxonomy_hierarchical ( $ tax_slug ) ) { $ return [ ] = $ tax_slug ; } } return $ return ; }
11804	public function isRelation ( $ key ) { if ( ! method_exists ( $ this -> model , $ key ) ) { return false ; } $ relation = $ this -> model -> { $ key } ( ) ; return ( $ relation instanceof Relation ) ; }
5701	protected function createFieldList ( $ buttons ) { $ actions = FieldList :: create ( ) ; foreach ( $ buttons as $ buttonType => $ bool ) { if ( ! $ bool || ! $ buttonType ) { continue ; } if ( substr ( $ buttonType , 0 , 6 ) == "Group_" ) { $ group = $ this -> createButtonGroup ( substr ( $ buttonType , 6 ) ) ; if ( $ group -> children -> exists ( ) ) { $ actions -> push ( $ group ) ; } } elseif ( $ b = $ this -> instantiateButton ( $ buttonType ) ) { $ actions -> push ( $ b ) ; } } return $ actions ; }
7293	public function save_transit_posts ( $ new_status , $ old_status , $ post ) { $ this -> transit_posts [ $ post -> ID ] = array ( 'old_status' => $ old_status , 'new_status' => $ new_status ) ; }
3458	public function extend ( $ module ) : void { if ( is_object ( $ module ) || class_exists ( $ module ) ) { $ this -> modules [ ] = $ module ; } else { throw ApplicationException :: forInvalidModule ( $ module ) ; } }
6368	private function parseWithMode ( $ raw_taf , $ strict ) { $ clean_taf = trim ( $ raw_taf ) ; $ clean_taf = preg_replace ( "#\n+#" , ' ' , $ clean_taf ) ; $ clean_taf = preg_replace ( "#\r+#" , ' ' , $ clean_taf ) ; $ clean_taf = preg_replace ( '#[ ]{2,}#' , ' ' , $ clean_taf ) . ' ' ; $ clean_taf = strtoupper ( $ clean_taf ) ; if ( strpos ( $ clean_taf , 'CNL' ) === false ) { $ remaining_taf = trim ( $ clean_taf ) . ' END' ; } else { $ remaining_taf = $ clean_taf ; } $ decoded_taf = new DecodedTaf ( $ clean_taf ) ; $ with_cavok = false ; foreach ( $ this -> decoder_chain as $ chunk_decoder ) { try { $ decoded = $ chunk_decoder -> parse ( $ remaining_taf , $ with_cavok ) ; $ result = $ decoded [ 'result' ] ; if ( $ result != null ) { foreach ( $ result as $ key => $ value ) { if ( $ value !== null ) { $ setter_name = 'set' . ucfirst ( $ key ) ; $ decoded_taf -> $ setter_name ( $ value ) ; } } } $ remaining_taf = $ decoded [ 'remaining_taf' ] ; } catch ( ChunkDecoderException $ cde ) { $ decoded_taf -> addDecodingException ( $ cde ) ; if ( $ strict ) { break ; } $ remaining_taf = $ cde -> getRemainingTaf ( ) ; } if ( $ chunk_decoder instanceof VisibilityChunkDecoder ) { $ with_cavok = $ decoded_taf -> getCavok ( ) ; } } $ evolutionDecoder = new EvolutionChunkDecoder ( $ strict , $ with_cavok ) ; while ( $ remaining_taf != null && trim ( $ remaining_taf ) != 'END' ) { $ evolutionDecoder -> parse ( $ remaining_taf , $ decoded_taf ) ; $ remaining_taf = $ evolutionDecoder -> getRemaining ( ) ; } return $ decoded_taf ; }
8684	public static function fromRecursive ( $ iterable ) { $ arr = static :: from ( $ iterable ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof \ stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return $ arr ; }
5886	public function resolve ( $ tsdns ) { $ this -> getTransport ( ) -> sendLine ( $ tsdns ) ; $ repl = $ this -> getTransport ( ) -> readLine ( ) ; $ this -> getTransport ( ) -> disconnect ( ) ; if ( $ repl -> section ( ":" , 0 ) -> toInt ( ) == 404 ) { throw new Ts3Exception ( "unable to resolve TSDNS hostname (" . $ tsdns . ")" ) ; } Signal :: getInstance ( ) -> emit ( "tsdnsResolved" , $ tsdns , $ repl ) ; return $ repl ; }
2708	public function afterSave ( \ Magento \ Config \ Model \ Config $ subject ) { if ( $ this -> purge ) { $ this -> api -> cleanBySurrogateKey ( [ 'text' ] ) ; } }
4583	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! array_key_exists ( $ this -> attribute , $ payload ) ) { $ event -> markAsInvalid ( ) ; } $ uuid = $ payload [ $ this -> attribute ] ; $ tenant = $ this -> tenantService -> getRepository ( ) -> findBy ( [ 'uuid' => $ uuid ] ) ; if ( ! $ tenant ) { $ event -> markAsInvalid ( ) ; } }
11762	public static function get ( $ property , $ default = NULL ) { $ object = new \ ReflectionClass ( Collection :: class ) ; $ value = $ object -> getStaticPropertyValue ( $ property ) ; return ( empty ( $ value ) ) ? $ default : $ value ; }
5197	protected function version ( ) { $ version = explode ( '(' , $ this -> app -> version ( ) ) ; if ( isset ( $ version [ 1 ] ) ) { return substr ( $ version [ 1 ] , 0 , 3 ) ; } return null ; }
1564	public function setResource ( $ resource ) : ClientJob { $ schema = $ this -> getApi ( ) -> getContainer ( ) -> getSchema ( $ resource ) ; $ this -> fill ( [ 'resource_type' => $ schema -> getResourceType ( ) , 'resource_id' => $ schema -> getId ( $ resource ) , ] ) ; return $ this ; }
74	public function requestToken ( $ originUrl , $ consumerKey , $ consumerSecret ) { if ( ! empty ( $ this -> token ) || $ this -> getTokenFromConfig ( $ originUrl ) ) { return $ this -> token [ 'access_token' ] ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return '' ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; return $ this -> token [ 'access_token' ] ; }
11153	public function getBoolean ( $ probability = 0.5 ) { if ( ( \ is_int ( $ probability ) || \ is_float ( $ probability ) ) === false || $ probability < 0 || $ probability > 1 ) { throw new InvalidArgumentException ( 'Invalid probability' ) ; } if ( $ probability == 0 ) { $ result = false ; } else { $ random = $ this -> generator -> getFloat ( 0 , 1 ) ; $ result = ( $ probability >= $ random ) ; } return $ result ; }
4792	function select ( $ columns ) { $ this -> __destruct ( ) ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { $ this -> select [ ] = $ columns ; } } else { $ this -> select = array ( ) ; } return $ this ; }
3940	private function setEmptyValue ( PropertyInterface $ property , array $ propInfo ) { if ( ! array_key_exists ( 'empty_value' , $ propInfo ) || ! ( $ property instanceof EmptyValueAwarePropertyInterface ) ) { return ; } $ property -> setEmptyValue ( $ propInfo [ 'empty_value' ] ) ; }
11566	public function register ( string ... $ mods ) : void { $ this -> kms = array_unique ( array_merge ( $ this -> kms , $ mods ) ) ; }
5640	public function paintGroupEnd ( $ test_name ) { array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
10460	public static function create ( $ type ) { switch ( $ type ) { case ActionTypes :: CREATE : return new CreateDiffItem ( ) ; case ActionTypes :: UPDATE : return new UpdateDiffItem ( ) ; case ActionTypes :: DELETE : return new DeleteDiffItem ( ) ; default : throw new \ InvalidArgumentException ( "Invalid type {$type}" ) ; } }
5054	public function init ( ) { $ this -> setLabel ( 'general settings' ) ; $ this -> add ( array ( 'type' => 'Core\Form\Element\Select' , 'name' => 'language' , 'options' => array ( 'label' => 'choose your language' , 'value_options' => array ( 'en' => 'English' , 'fr' => 'French' , 'de' => 'German' , 'it' => 'Italian' , 'po' => 'Polish' , 'ru' => 'Russian' , 'tr' => 'Turkish' , 'es' => 'Spanish' , ) , 'description' => 'defines the languages of this frontend.' ) , ) ) ; $ timezones = array_merge ( \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: AFRICA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: AMERICA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: ASIA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: ATLANTIC ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: AUSTRALIA ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: EUROPE ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: INDIAN ) , \ DateTimeZone :: listIdentifiers ( \ DateTimeZone :: PACIFIC ) ) ; $ this -> add ( array ( 'type' => 'Core\Form\Element\Select' , 'name' => 'timezone' , 'options' => array ( 'label' => 'choose your timzone' , 'value_options' => $ timezones , 'description' => 'defines your local timezone.' ) , ) ) ; }
4010	public function getMaxPaginationLinks ( ) { if ( null === $ this -> maxPaginationLinks ) { $ this -> setMaxPaginationLinks ( \ Config :: get ( 'maxPaginationLinks' ) ) ; } return $ this -> maxPaginationLinks ; }
10793	public function delete ( $ idOrUser , $ forceLogout = true ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ em = $ main -> getEntityManager ( ) ; $ user = $ this -> getEntity ( $ idOrUser ) ; $ classifiedService = $ this -> getServiceLocator ( ) -> get ( 'document.service.classified' ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ , $ this , array ( 'user' => $ user ) ) ; $ user -> setState ( UserEntity :: USER_STATE_DELETED ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ documents = $ user -> getDocument ( ) ; foreach ( $ documents as $ document ) { try { $ classifiedService -> delete ( $ document ) ; } catch ( \ Exception $ e ) { } } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , array ( 'user' => $ user ) ) ; if ( $ forceLogout ) { $ this -> logout ( ) ; } return $ user ; }
9350	public function transpose ( ) { $ out = new self ( $ this -> size -> cols , $ this -> size -> rows ) ; foreach ( $ this -> arr as $ row ) { $ out -> addCol ( $ row ) ; } return $ out ; }
604	protected function substring ( $ length , $ caseSensitive = true , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + $ length > $ this -> length ) { return '' ; } $ cacheKey = $ offset . ',' . $ length ; if ( ! isset ( $ this -> _substrings [ $ cacheKey . ',1' ] ) ) { $ this -> _substrings [ $ cacheKey . ',1' ] = mb_substr ( $ this -> sql , $ offset , $ length , 'UTF-8' ) ; } if ( ! $ caseSensitive && ! isset ( $ this -> _substrings [ $ cacheKey . ',0' ] ) ) { $ this -> _substrings [ $ cacheKey . ',0' ] = mb_strtoupper ( $ this -> _substrings [ $ cacheKey . ',1' ] , 'UTF-8' ) ; } return $ this -> _substrings [ $ cacheKey . ',' . ( int ) $ caseSensitive ] ; }
417	public function getETags ( ) { if ( $ this -> headers -> has ( 'If-None-Match' ) ) { return preg_split ( '/[\s,]+/' , str_replace ( '-gzip' , '' , $ this -> headers -> get ( 'If-None-Match' ) ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } return [ ] ; }
4799	function exec ( $ query ) { $ conn = $ this -> getConn ( ) ; $ sql = $ conn -> quote ( $ query ) ; return $ conn -> exec ( $ sql ) ; }
12771	public function authorizeWithEmail ( $ hashedEmail , $ hashedPassword , $ remember = null , & $ user = null ) { $ result = new EmailStatus ( 0 ) ; if ( dbQuery ( $ this -> dbTable ) -> where ( $ this -> dbHashEmailField , $ hashedEmail ) -> first ( $ user ) ) { $ dbTable = $ this -> dbTable ; $ hashPasswordField = $ dbTable :: $ _attributes [ $ this -> dbHashPasswordField ] ; if ( $ user [ $ hashPasswordField ] === $ hashedPassword ) { $ result = new EmailStatus ( EmailStatus :: SUCCESS_EMAIL_AUTHORIZE ) ; $ this -> authorize ( $ user , $ remember ) ; } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_WRONGPWD ) ; } } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_NOTFOUND ) ; } if ( is_callable ( $ this -> authorizeHandler ) ) { if ( ! call_user_func_array ( $ this -> authorizeHandler , array ( & $ user , & $ result ) ) ) { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_AUTHORIZE_HANDLER ) ; } } return $ result ; }
7251	protected function validateIdentity ( SaleInterface $ sale , Constraint $ constraint ) { if ( null === $ sale -> getCustomer ( ) ) { if ( null === $ sale -> getCustomerGroup ( ) ) { $ this -> context -> buildViolation ( $ constraint -> customer_group_is_required_if_no_customer ) -> atPath ( 'customerGroup' ) -> addViolation ( ) ; } if ( 0 == strlen ( $ sale -> getEmail ( ) ) ) { $ this -> context -> buildViolation ( $ constraint -> email_is_required_if_no_customer ) -> atPath ( 'email' ) -> addViolation ( ) ; } IdentityValidator :: validateIdentity ( $ this -> context , $ sale ) ; } }
11837	public function getLogo ( $ size = null ) { if ( ! $ this -> logoPath || ! file_exists ( $ this -> logoPath ) ) { return ; } $ cacheLogo = $ this -> sizeImageCache ( $ this -> logoPath , $ size ) ; if ( $ cacheLogo ) { return $ this -> getCacheAssetUrl ( $ cacheLogo ) ; } return false ; }
468	public function buildSimpleCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
1689	public function updateStyleSheets ( ) { $ objStyleSheets = $ this -> Database -> execute ( "SELECT * FROM tl_style_sheet" ) ; $ arrStyleSheets = $ objStyleSheets -> fetchEach ( 'name' ) ; if ( file_exists ( $ this -> strRootDir . '/system/config/dcaconfig.php' ) ) { @ trigger_error ( 'Using the dcaconfig.php file has been deprecated and will no longer work in Contao 5.0. Create one or more DCA files in app/Resources/contao/dca instead.' , E_USER_DEPRECATED ) ; include $ this -> strRootDir . '/system/config/dcaconfig.php' ; } foreach ( scan ( $ this -> strRootDir . '/assets/css' , true ) as $ file ) { if ( is_dir ( $ this -> strRootDir . '/assets/css/' . $ file ) ) { continue ; } if ( \ is_array ( Config :: get ( 'rootFiles' ) ) && \ in_array ( $ file , Config :: get ( 'rootFiles' ) ) ) { continue ; } if ( preg_match ( '/^[a-f0-9]{12}\.css$/' , $ file ) ) { continue ; } $ objFile = new File ( 'assets/css/' . $ file ) ; if ( $ objFile -> extension == 'css' && ! \ in_array ( $ objFile -> filename , $ arrStyleSheets ) ) { $ objFile -> delete ( ) ; } } $ objStyleSheets -> reset ( ) ; while ( $ objStyleSheets -> next ( ) ) { $ this -> writeStyleSheet ( $ objStyleSheets -> row ( ) ) ; $ this -> log ( 'Generated style sheet "' . $ objStyleSheets -> name . '.css"' , __METHOD__ , TL_CRON ) ; } }
11589	public function matrix ( ) { if ( $ this -> _matrix ) { return $ this -> _matrix ; } $ this -> _matrix = new Matrix ( $ this -> tasks ( ) ) ; $ this -> _matrix -> process ( ) ; return $ this -> _matrix ; }
11960	public function reduce ( Closure $ fn , $ initial = null ) { return array_reduce ( $ this -> elements , $ fn , $ initial ) ; }
2975	public function bindTo ( $ newthis , $ newscope = 'static' ) { return new self ( $ this -> closure -> bindTo ( $ newthis , $ newscope ) , $ this -> serializer ) ; }
11635	public function getPageByDeviceId ( array $ deviceIdentifier , $ raw = false ) { $ params = [ 'type' => 1 , 'device_identifier' => $ deviceIdentifier , ] ; $ result = $ this -> parseJSON ( 'json' , [ self :: API_RELATION_SEARCH , $ params ] ) ; if ( $ raw === true ) { return $ result ; } $ page_ids = [ ] ; if ( ! empty ( $ result -> data [ 'relations' ] ) ) { foreach ( $ result -> data [ 'relations' ] as $ item ) { $ page_ids [ ] = $ item [ 'page_id' ] ; } } return $ page_ids ; }
270	public function getEnabled ( ) { if ( is_callable ( $ this -> _enabled ) ) { return call_user_func ( $ this -> _enabled , $ this ) ; } return $ this -> _enabled ; }
10197	public function writeStringTable ( array $ pStringTable ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'sst' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> writeAttribute ( 'uniqueCount' , count ( $ pStringTable ) ) ; foreach ( $ pStringTable as $ textElement ) { $ objWriter -> startElement ( 'si' ) ; if ( ! $ textElement instanceof RichText ) { $ textToWrite = StringHelper :: controlCharacterPHP2OOXML ( $ textElement ) ; $ objWriter -> startElement ( 't' ) ; if ( $ textToWrite !== trim ( $ textToWrite ) ) { $ objWriter -> writeAttribute ( 'xml:space' , 'preserve' ) ; } $ objWriter -> writeRawData ( $ textToWrite ) ; $ objWriter -> endElement ( ) ; } elseif ( $ textElement instanceof RichText ) { $ this -> writeRichText ( $ objWriter , $ textElement ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
2780	public function buildOptions ( ) : array { $ options = [ ] ; foreach ( $ this -> options as $ option => $ values ) { foreach ( ( array ) $ values as $ value ) { $ prefix = strlen ( $ option ) !== 1 ? '--' : '-' ; $ options [ ] = $ prefix . $ option ; if ( $ value !== true ) { $ options [ ] = $ value ; } } } return $ options ; }
9682	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; if ( isset ( $ xmlElement -> link_id ) ) $ this -> linkId = $ xmlElement -> link_id ; if ( isset ( $ xmlElement -> link_url ) ) $ this -> linkUrl = $ xmlElement -> link_url ; if ( isset ( $ xmlElement -> link_tags ) ) { $ this -> linkTags = array ( ) ; foreach ( $ xmlElement -> link_tags -> children ( ) as $ field ) { array_push ( $ this -> linkTags , $ field [ 0 ] ) ; } } }
2939	public static function linearUnitFactory ( $ name , $ toNativeUnitFactor ) { return new static ( $ name , function ( $ valueInNativeUnit ) use ( $ toNativeUnitFactor ) { return $ valueInNativeUnit / $ toNativeUnitFactor ; } , function ( $ valueInThisUnit ) use ( $ toNativeUnitFactor ) { return $ valueInThisUnit * $ toNativeUnitFactor ; } ) ; }
5797	public static function getRouteName ( bool $ isAdmin = true , string $ routePrefix = null , string $ routeType = null , string $ requestMethod = null ) : string { $ routeName = '' ; if ( $ isAdmin ) { $ routeName .= ROUTEPREFIX_ADMIN ; } if ( $ routePrefix !== null ) { $ routeName .= '.' . $ routePrefix ; } if ( $ requestMethod !== null ) { $ validActionMethods = [ 'put' , 'post' ] ; if ( ! in_array ( $ requestMethod , $ validActionMethods ) ) { throw new \ Exception ( "Invalid request method $requestMethod. Only post and put accepted in route names." ) ; } $ routeName .= '.' . $ requestMethod ; } if ( $ routeType !== null ) { if ( ! in_array ( $ routeType , self :: VALID_ROUTE_TYPES ) ) { throw new \ Exception ( "Invalid route type $routeType" ) ; } $ routeName .= '.' . $ routeType ; } return $ routeName ; }
5233	public function handleException ( \ Exception $ exception ) { if ( $ this -> loggingEnabled ) { $ this -> exceptionLogger -> log ( $ exception ) ; } if ( 'cgi' === $ this -> sapi ) { $ this -> header ( 'Status: 500 Internal Server Error' ) ; } else { $ this -> header ( 'HTTP/1.1 500 Internal Server Error' ) ; } $ this -> writeBody ( $ this -> createResponseBody ( $ exception ) ) ; }
6372	public function append ( IteratorAggregate $ other ) : FluentIterable { return self :: from ( Iterables :: concat ( $ this , $ other ) ) ; }
11729	private function _put ( $ attrName , $ value = NULL ) { $ this -> _checkModify ( ) ; if ( $ value === NULL ) $ this -> removeAttribute ( $ attrName ) ; elseif ( $ this -> hasAttribute ( $ attrName ) && method_exists ( $ attr = $ this -> getAttribute ( $ attrName ) , "setValue" ) ) { $ attr -> setValue ( $ value ) ; } else { $ this -> addAttribute ( new Attribute ( $ attrName , $ value ) ) ; } }
5610	public function paintCaseStart ( $ message ) { parent :: paintCaseStart ( $ message ) ; $ node = new TreemapNode ( 'TestCase' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
8497	public function getPackageTrackingDetails ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPackageTrackingDetails' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
877	private function skipClass ( Tokens $ tokens , $ classIndex , $ classOpenIndex , $ classCloseIndex ) { $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ classIndex ) ] ; if ( ! $ prevToken -> isGivenKind ( T_FINAL ) ) { return true ; } for ( $ index = $ classIndex ; $ index < $ classOpenIndex ; ++ $ index ) { if ( $ tokens [ $ index ] -> isGivenKind ( T_EXTENDS ) ) { return true ; } } $ useIndex = $ tokens -> getNextTokenOfKind ( $ classIndex , [ [ CT :: T_USE_TRAIT ] ] ) ; return $ useIndex && $ useIndex < $ classCloseIndex ; }
8992	public function getAttributeNames ( $ entity ) { if ( ! $ entity instanceof \ ElggEntity ) { return array ( ) ; } $ default = array ( 'guid' , 'type' , 'subtype' , 'owner_guid' , 'container_guid' , 'site_guid' , 'access_id' , 'time_created' , 'time_updated' , 'last_action' , 'enabled' , ) ; switch ( $ entity -> getType ( ) ) { case 'user' ; $ attributes = array ( 'name' , 'username' , 'email' , 'language' , 'banned' , 'admin' , 'password' , 'salt' ) ; break ; case 'group' : $ attributes = array ( 'name' , 'description' , ) ; break ; case 'object' : $ attributes = array ( 'title' , 'description' , ) ; break ; } return array_merge ( $ default , $ attributes ) ; }
2752	public function processBlockedItems ( $ strippedBlockedItems , $ blockingType = null ) { if ( empty ( $ blockingType ) ) { $ blockingType = $ this -> _scopeConfig -> getValue ( self :: XML_FASTLY_BLOCKING_TYPE ) ; } if ( $ blockingType == '1' ) { $ strippedBlockedItems = '!(' . $ strippedBlockedItems . ')' ; } return $ strippedBlockedItems ; }
3659	public static function getSubscribedServices ( ) { return [ Connection :: class => Connection :: class , Input :: class => Input :: class , InsertTags :: class => InsertTags :: class , Session :: class => Session :: class , IMetaModelsServiceContainer :: class => IMetaModelsServiceContainer :: class ] ; }
2626	protected function _construct ( ) { $ this -> addColumn ( 'backend_name' , [ 'label' => __ ( 'Name' ) ] ) ; $ this -> _addAfter = false ; $ this -> _template = 'Fastly_Cdn::system/config/form/field/acl.phtml' ; parent :: _construct ( ) ; }
8658	private function convertRequestReport ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'RequestReport' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMarketplaceIdList ( ) ) { $ marketplaceIdList = $ request -> getMarketplaceIdList ( ) ; foreach ( $ marketplaceIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'MarketplaceIdList.Id.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetReportType ( ) ) { $ parameters [ 'ReportType' ] = $ request -> getReportType ( ) ; } if ( $ request -> isSetStartDate ( ) ) { $ parameters [ 'StartDate' ] = $ this -> getFormattedTimestamp ( $ request -> getStartDate ( ) ) ; } if ( $ request -> isSetEndDate ( ) ) { $ parameters [ 'EndDate' ] = $ this -> getFormattedTimestamp ( $ request -> getEndDate ( ) ) ; } if ( $ request -> isSetReportOptions ( ) ) { $ parameters [ 'ReportOptions' ] = $ request -> getReportOptions ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
5764	public function routeIndexResetFilter ( Request $ request , Response $ response , $ args ) { return $ this -> indexViewObjects ( $ response , true ) ; }
10996	public function prepend ( string $ contents , int $ maxMemory = 8096 ) : bool { $ test = \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE | \ sndsgd \ Fs :: WRITABLE ; if ( $ this -> test ( $ test ) === false ) { $ this -> error = "failed to prepend file; {$this->error}" ; return false ; } $ len = strlen ( $ contents ) ; $ size = filesize ( $ this -> path ) ; $ endsize = $ len + $ size ; if ( $ endsize > $ maxMemory ) { return $ this -> prependFileInPlace ( $ contents , $ len , $ endsize ) ; } if ( ( $ tmp = $ this -> readFile ( 0 ) ) === false ) { return false ; } if ( $ this -> writeFile ( $ contents . $ tmp , 0 ) === false ) { return false ; } return true ; }
7569	public function getJobApiService ( ) { $ apiService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ JobApiService ( $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: jobBoardBaseUrl ( $ this -> _boardToken ) ) ) ; $ apiService -> setClient ( $ apiClient ) ; return $ apiService ; }
10443	protected function handleStart ( $ line ) { if ( preg_match ( '/^(INSERT INTO|UPDATE|DELETE FROM)\s+`?(.*?)`?\.`?(.*?)`?$/' , $ line , $ part ) ) { return [ 'type' => $ this -> detectQueryType ( $ part [ 1 ] ) , 'table' => $ part [ 3 ] , ] ; } throw new \ UnexpectedValueException ( "Expected a statement, got {$line}" ) ; }
5434	protected function isStaticMethod ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; if ( ! $ interface -> hasMethod ( $ name ) ) { return false ; } return $ interface -> getMethod ( $ name ) -> isStatic ( ) ; }
8491	public static function getCpuCores ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT NumberOfLogicalProcessors FROM Win32_Processor" ) ; $ cores = 0 ; foreach ( $ object as $ obj ) { $ cores = $ obj -> NumberOfLogicalProcessors ; } return $ cores ; }
7871	protected function drawPipesEnd ( ) { $ pipes = array_reverse ( $ this -> pipes ) ; foreach ( $ pipes as $ pipe ) { $ this -> drawBordered ( $ this -> geometry -> getSpacedPipe ( $ pipe , static :: NOCK , 'after()' ) ) ; $ this -> drawBorderBottom ( ) ; } }
11112	public function getMigrationFiles ( string $ type ) : array { $ array = [ ] ; foreach ( $ this -> filesystem -> listContents ( ) as $ file ) { if ( $ type === pathinfo ( $ file [ 'filename' ] , PATHINFO_EXTENSION ) ) { $ array [ ] = $ file ; } } return $ array ; }
2355	public function hasFrontendUser ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof FrontendUser ; }
1470	public function createResolver ( $ apiName , array $ config ) { $ factoryName = isset ( $ config [ 'resolver' ] ) ? $ config [ 'resolver' ] : ResolverFactory :: class ; $ factory = $ this -> container -> make ( $ factoryName ) ; if ( $ factory instanceof ResolverInterface ) { return $ factory ; } if ( ! is_callable ( $ factory ) ) { throw new RuntimeException ( "Factory {$factoryName} cannot be invoked." ) ; } $ resolver = $ factory ( $ apiName , $ config ) ; if ( ! $ resolver instanceof ResolverInterface ) { throw new RuntimeException ( "Factory {$factoryName} did not create a resolver instance." ) ; } return $ resolver ; }
10532	public function valid ( ) { if ( $ this -> items === null ) { return false ; } $ key = key ( $ this -> items ) ; return ( $ key !== null && $ key !== false ) ; }
4337	private function getDefaultOutputAs ( ) { $ ret = 'html' ; $ interface = $ this -> debug -> utilities -> getInterface ( ) ; if ( $ interface == 'ajax' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } elseif ( $ interface == 'http' ) { $ contentType = $ this -> debug -> utilities -> getResponseHeader ( ) ; if ( $ contentType && $ contentType !== 'text/html' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } } else { $ ret = 'text' ; } return $ ret ; }
3385	private function getRole ( $ identity = null ) { if ( is_object ( $ identity ) ) { return $ identity -> getRole ( ) ; } if ( is_array ( $ identity ) && isset ( $ identity [ 'role' ] ) ) { return $ identity [ 'role' ] ; } return 'guest' ; }
12873	protected function getElementValidatorChain ( \ Zend \ Form \ Element $ element ) { $ elementName = $ element -> getAttribute ( 'name' ) ; return $ this -> form -> getInputFilter ( ) -> get ( $ elementName ) -> getValidatorChain ( ) ; }
12299	public function getPivotFields ( $ obj , $ prop ) { $ reflection = new \ ReflectionClass ( $ obj ) ; $ property = $ reflection -> getProperty ( $ prop ) ; $ property -> setAccessible ( true ) ; $ value = $ property -> getValue ( $ obj ) ; $ property -> setAccessible ( false ) ; return array_diff ( $ value , [ 'deleted_at' , 'created_at' , 'updated_at' ] ) ; }
11197	public function add ( $ item , $ key = false , $ dataKey = false ) { $ keyPrefix = '' ; if ( is_array ( $ dataKey ) ) { $ keyPrefix = $ dataKey [ 1 ] ; $ dataKey = $ dataKey [ 0 ] ; } if ( is_object ( $ item ) ) { if ( $ key ) { if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else if ( $ dataKey && isset ( $ item -> $ dataKey ) ) { $ key = $ item -> $ dataKey ; if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> { $ keyPrefix . $ key } = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } else if ( is_array ( $ item ) ) { if ( $ key ) { if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else if ( $ dataKey && isset ( $ item [ $ dataKey ] ) ) { $ key = $ item [ $ dataKey ] ; if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> { $ keyPrefix . $ key } = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } else { if ( $ key ) { if ( ! $ this -> __isset ( $ key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } $ this -> contentModified = true ; return $ this ; }
6795	protected function convertValueIds ( $ valueResult , & $ counter = null ) { $ result = [ ] ; $ aliases = [ ] ; $ idColumn = $ this -> getIdColumn ( ) ; $ aliasColumn = $ this -> getAliasColumn ( ) ; while ( $ row = $ valueResult -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ valueId = $ row -> $ idColumn ; $ aliases [ $ valueId ] = $ row -> $ aliasColumn ; $ result [ ] = $ valueId ; } if ( ( $ counter !== null ) && ! empty ( $ result ) ) { $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'value_id' , 'COUNT(value_id) as mm_count' ) -> from ( 'tl_metamodel_tag_relation' ) -> where ( 'att_id=:att' ) -> andWhere ( 'value_id IN (:values)' ) -> groupBy ( 'item_id' ) -> setParameter ( 'att' , $ this -> get ( 'id' ) ) -> setParameter ( 'values' , $ result , Connection :: PARAM_STR_ARRAY ) -> execute ( ) -> fetch ( \ PDO :: FETCH_OBJ ) ; $ amount = $ statement -> mm_count ; $ valueId = $ statement -> value_id ; $ alias = $ aliases [ $ valueId ] ; $ counter [ $ valueId ] = $ amount ; $ counter [ $ alias ] = $ amount ; } return $ result ; }
8876	public function send ( ) { if ( ! preg_match ( '/^.+@.+$/' , $ this -> sender ) ) { return false ; } if ( ! preg_match ( '/^.+@.+$/' , $ this -> recipient ) ) { return false ; } if ( ! $ this -> subject || strlen ( $ this -> subject ) > 255 ) { return false ; } $ required_headers = [ ] ; if ( Mail :: $ config [ 'testing_mode' ] ) { if ( empty ( Mail :: $ config [ 'testing_email' ] ) ) { return true ; } $ required_headers [ 'X-Testing-Original-To' ] = $ this -> recipient ; foreach ( $ this -> headers as $ name => $ value ) { switch ( strtolower ( $ name ) ) { case 'cc' : $ this -> headers [ 'X-Testing-Original-Cc' ] = $ value ; $ required_headers [ $ name ] = '' ; break ; case 'bcc' : $ this -> headers [ 'X-Testing-Original-Bcc' ] = $ value ; $ required_headers [ $ name ] = '' ; break ; } } $ to = Mail :: $ config [ 'testing_email' ] ; $ subject = '*Test* ' . $ this -> subject ; } else { $ to = $ this -> recipient ; $ subject = $ this -> subject ; } $ required_headers [ 'From' ] = $ this -> sender ; $ required_headers [ 'Return-Path' ] = $ this -> sender ; $ required_headers [ 'Reply-To' ] = $ this -> sender ; $ required_headers [ 'X-Sender' ] = $ this -> sender ; $ headers = $ this -> buildHeaders ( $ required_headers ) ; $ message = $ this -> buildTextPart ( ) . $ this -> buildAttachmentPart ( ) . "--MIME_BOUNDRY--\n" ; return mail ( $ to , $ subject , $ message , $ headers , Mail :: $ config [ 'additional_parameters' ] ) ; }
2815	public function addCollection ( Varien_Data_Collection_Db $ collection ) { $ info = Mage :: getModel ( 'sheep_debug/collection' ) ; $ info -> init ( $ collection ) ; $ key = $ info -> getClass ( ) ; if ( ! array_key_exists ( $ key , $ this -> collections ) ) { $ this -> collections [ $ key ] = $ info ; } $ this -> collections [ $ key ] -> incrementCount ( ) ; }
12272	public function exec ( $ calcId ) { $ result = [ ] ; $ dwnlCompress = $ this -> daoBonDwnl -> getByCalcId ( $ calcId ) ; $ mapById = $ this -> hlpDwnlTree -> mapById ( $ dwnlCompress , EBonDwnl :: A_CUST_REF ) ; $ mapDepth = $ this -> hlpDwnlTree -> mapByTreeDepthDesc ( $ dwnlCompress , EBonDwnl :: A_CUST_REF , EBonDwnl :: A_DEPTH ) ; $ mapTeams = $ this -> hlpDwnlTree -> mapByTeams ( $ dwnlCompress , EBonDwnl :: A_CUST_REF , EBonDwnl :: A_PARENT_REF ) ; $ signupDebitCustomers = $ this -> hlpSignUpDebitCust -> exec ( ) ; foreach ( $ mapDepth as $ depth => $ levelCustomers ) { $ this -> logger -> debug ( "Process level #$depth of the downline tree." ) ; foreach ( $ levelCustomers as $ custId ) { $ entity = $ mapById [ $ custId ] ; $ ov = $ entity -> getPv ( ) ; $ isSignUpDebit = in_array ( $ custId , $ signupDebitCustomers ) ; if ( $ isSignUpDebit ) { $ ov += Cfg :: SIGNUP_DEBIT_PV ; } if ( isset ( $ mapTeams [ $ custId ] ) ) { $ team = $ mapTeams [ $ custId ] ; foreach ( $ team as $ memberId ) { $ member = $ result [ $ memberId ] ; $ memberOv = $ member -> getOv ( ) ; $ ov += $ memberOv ; } } $ entity -> setOv ( $ ov ) ; $ result [ $ custId ] = $ entity ; } } unset ( $ mapPv ) ; unset ( $ mapTeams ) ; unset ( $ mapDepth ) ; return $ result ; }
1383	protected function dataGet ( $ key , $ default = null ) { if ( ! isset ( $ this -> document -> data ) ) { return $ default ; } return data_get ( $ this -> document -> data , $ key , $ default ) ; }
4365	public function onErrorHighPri ( Event $ error ) { $ this -> throttleDataRead ( ) ; $ hash = $ error [ 'hash' ] ; $ error [ 'email' ] = ( $ error [ 'type' ] & $ this -> cfg [ 'emailMask' ] ) && $ error [ 'isFirstOccur' ] && $ this -> cfg [ 'emailTo' ] ; $ error [ 'stats' ] = array ( 'tsEmailed' => 0 , 'countSince' => 0 , 'emailedTo' => '' , ) ; if ( isset ( $ this -> throttleData [ 'errors' ] [ $ hash ] ) ) { $ stats = \ array_intersect_key ( $ this -> throttleData [ 'errors' ] [ $ hash ] , $ error [ 'stats' ] ) ; $ error [ 'stats' ] = \ array_merge ( $ error [ 'stats' ] , $ stats ) ; } return ; }
3880	private function getJumpToLabel ( ) { $ tableName = $ this -> metaModel -> getTableName ( ) ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> get ( 'id' ) ] [ 'details' ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> get ( 'id' ) ] [ 'details' ] ; } elseif ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ 'details' ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ 'details' ] ; } return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'details' ] ; }
8229	public static function readFile ( $ fileName , $ options = [ ] ) { $ reader = new File \ FileReader ( $ fileName , $ options ) ; $ success = true ; $ contents = null ; try { $ reader -> open ( ) ; $ contents = $ reader -> read ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ success = false ; } try { $ reader -> close ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ success = false ; } return ( $ success ) ? $ contents : false ; }
8264	protected function onOAuthError ( $ errorCode ) { $ errorCode = strlen ( $ errorCode > 100 ) ? substr ( $ errorCode , 0 , 100 ) : $ errorCode ; $ this -> logger -> notice ( "OAuth2 error response: code {code}, provider {provider}" , array ( "code" => $ errorCode , "provider" => get_class ( $ this -> provider ) , ) ) ; $ this -> session -> addFlash ( "error" , "The provider returned an error ($errorCode)" ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
2493	protected function getRange ( $ operator , $ start , $ end ) { $ startBrace = '[' ; $ startValue = '*' ; $ endValue = '*' ; $ endBrace = ']' ; $ start = '"' . $ this -> escapeQuote ( $ this -> toString ( $ start ) , true ) . '"' ; $ end = '"' . $ this -> escapeQuote ( $ this -> toString ( $ end ) , true ) . '"' ; switch ( $ operator ) { case Operator :: GT : $ startBrace = '{' ; $ endBrace = '}' ; case Operator :: GTE : $ startValue = $ start ; break ; case Operator :: LT : $ startBrace = '{' ; $ endBrace = '}' ; case Operator :: LTE : $ endValue = $ end ; break ; case Operator :: BETWEEN : $ startValue = $ start ; $ endValue = $ end ; break ; default : throw new \ RuntimeException ( "Unknown operator: $operator" ) ; } return "$startBrace$startValue TO $endValue$endBrace" ; }
10924	private function renderLine ( ) { $ output = [ ] ; $ output [ ] = $ this -> charCross ; if ( count ( $ this -> columns ) > 0 ) { for ( $ columnNumber = 0 ; $ columnNumber < count ( $ this -> columns ) ; $ columnNumber ++ ) { $ output [ ] = $ this -> renderCell ( $ columnNumber , $ this -> charHorizontal , $ this -> charHorizontal ) ; $ output [ ] = $ this -> charCross ; } } return implode ( '' , $ output ) ; }
7177	public static function pluck ( $ array , $ key ) { $ values = array ( ) ; foreach ( $ array as $ row ) { if ( isset ( $ row [ $ key ] ) ) { $ values [ ] = $ row [ $ key ] ; } } return $ values ; }
3743	protected function setLanguage ( $ language = '' ) { $ previousLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( ! empty ( $ language ) && ( $ GLOBALS [ 'TL_LANGUAGE' ] !== $ language ) ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ language ; } return $ previousLanguage ; }
3894	private function getFilteredAttributeNames ( $ metaModelId , $ allowedTypes = array ( ) ) { $ attributeNames = array ( ) ; if ( $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ) ) { foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( empty ( $ allowedTypes ) || in_array ( $ attribute -> get ( 'type' ) , $ allowedTypes ) ) { $ attributeNames [ $ attribute -> getColName ( ) ] = sprintf ( '%s [%s]' , $ attribute -> getName ( ) , $ attribute -> getColName ( ) ) ; } } } return $ attributeNames ; }
10668	public static function build ( $ input , array $ options = [ ] ) { if ( ! \ is_array ( $ options ) ) { $ options = [ 'return' => ( string ) $ options ] ; } $ defaults = [ 'return' => 'simplexml' , ] ; $ options = array_merge ( $ defaults , $ options ) ; if ( is_array ( $ input ) || is_object ( $ input ) ) { return self :: fromArray ( ( array ) $ input , $ options ) ; } if ( strpos ( $ input , '<' ) !== false ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> loadXML ( $ input ) ; return $ dom ; } if ( file_exists ( $ input ) || strpos ( $ input , 'http://' ) === 0 || strpos ( $ input , 'https://' ) === 0 ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA , true ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> load ( $ input ) ; return $ dom ; } if ( ! \ is_string ( $ input ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid input.' ) ) ; } throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'XML cannot be read.' ) ) ; }
12974	protected function autoLoadMappingInfo ( ) { $ mappings = array ( ) ; foreach ( \ Package :: loaded ( ) as $ package => $ path ) { $ mappings [ ] = $ package . '::package' ; } foreach ( \ Module :: loaded ( ) as $ module => $ path ) { $ mappings [ ] = $ module . '::module' ; } $ mappings [ ] = 'app' ; $ mappings = array_fill_keys ( $ mappings , array ( 'is_component' => true ) ) ; $ this -> setMappings ( $ mappings ) ; }
4502	public function after ( DOMNode $ node ) : void { $ this -> parentNode -> insertBefore ( $ node , $ this -> nextSibling ) ; }
1009	public static function defaultFieldResolver ( $ source , $ args , $ context , ResolveInfo $ info ) { $ fieldName = $ info -> fieldName ; $ property = null ; if ( is_array ( $ source ) || $ source instanceof ArrayAccess ) { if ( isset ( $ source [ $ fieldName ] ) ) { $ property = $ source [ $ fieldName ] ; } } elseif ( is_object ( $ source ) ) { if ( isset ( $ source -> { $ fieldName } ) ) { $ property = $ source -> { $ fieldName } ; } } return $ property instanceof Closure ? $ property ( $ source , $ args , $ context , $ info ) : $ property ; }
1100	protected function guardAgainstImpossibleMove ( ) { if ( ! $ this -> node -> exists ) throw new MoveNotPossibleException ( 'A new node cannot be moved.' ) ; if ( array_search ( $ this -> position , array ( 'child' , 'left' , 'right' , 'root' ) ) === FALSE ) throw new MoveNotPossibleException ( "Position should be one of ['child', 'left', 'right'] but is {$this->position}." ) ; if ( ! $ this -> promotingToRoot ( ) ) { if ( is_null ( $ this -> target ) ) { if ( $ this -> position === 'left' || $ this -> position === 'right' ) throw new MoveNotPossibleException ( "Could not resolve target node. This node cannot move any further to the {$this->position}." ) ; else throw new MoveNotPossibleException ( 'Could not resolve target node.' ) ; } if ( $ this -> node -> equals ( $ this -> target ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to itself.' ) ; if ( $ this -> target -> insideSubtree ( $ this -> node ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to a descendant of itself (inside moved tree).' ) ; if ( ! $ this -> node -> inSameScope ( $ this -> target ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to a different scope.' ) ; } }
3828	protected function addUrlParameter ( $ url , $ name , $ value ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ value = str_replace ( '%' , '%%' , urlencode ( $ value ) ) ; if ( empty ( $ value ) ) { return $ url ; } if ( $ name !== 'auto_item' ) { $ url .= '/' . $ name . '/' . $ value ; } else { $ url = '/' . $ value . $ url ; } return $ url ; }
93	public function filter ( $ relativePath , $ exclude ) { foreach ( $ this -> excludePatterns as $ patternData ) { list ( $ pattern , $ negate , $ stripLeadingSlash ) = $ patternData ; if ( $ stripLeadingSlash ) { $ path = substr ( $ relativePath , 1 ) ; } else { $ path = $ relativePath ; } if ( preg_match ( $ pattern , $ path ) ) { $ exclude = ! $ negate ; } } return $ exclude ; }
4920	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( ! $ spec instanceof Container ) { throw new \ InvalidArgumentException ( 'Tab container must be of the type \Core\Form\Container' ) ; } if ( ! $ spec -> getLabel ( ) ) { throw new \ InvalidArgumentException ( 'Container instances must have a label.' ) ; } } if ( is_array ( $ spec ) ) { if ( ! isset ( $ spec [ 'type' ] ) ) { $ spec [ 'type' ] = 'Core/Container' ; } if ( ! isset ( $ spec [ 'options' ] [ 'forms' ] ) && isset ( $ spec [ 'forms' ] ) ) { $ spec [ 'options' ] [ 'forms' ] = $ spec [ 'forms' ] ; unset ( $ spec [ 'forms' ] ) ; } } return parent :: setForm ( $ key , $ spec , $ enabled ) ; }
6056	public function updateFolder ( $ id , Folder $ folder ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'folder' => $ folder ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders/' . $ id . '' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
5878	protected static function updateIndex ( \ TYPO3 \ CMS \ Core \ Resource \ File $ file = null , $ width , $ height , array $ metadata = [ ] ) { if ( count ( $ metadata ) > 0 ) { $ metadataRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ Index \ MetaDataRepository :: class ) ; $ currentMetadata = $ metadataRepository -> findByFile ( $ file ) ; $ newMetadata = [ ] ; foreach ( $ currentMetadata as $ key => $ value ) { if ( ! empty ( $ metadata [ $ key ] ) ) { if ( $ key === 'creator_tool' && MathUtility :: canBeInterpretedAsFloat ( $ metadata [ $ key ] ) ) { continue ; } $ newMetadata [ $ key ] = $ metadata [ $ key ] ; } } unset ( $ newMetadata [ 'width' ] ) ; unset ( $ newMetadata [ 'height' ] ) ; $ newMetadata [ 'unit' ] = 'px' ; $ mapping = [ 'color_space' => 'ColorSpace' , 'content_creation_date' => 'DateTimeOriginal' , 'creator' => 'IPTCCreator|Company' , 'creator_tool' => 'Model|Make|Software' , 'description' => 'ImageDescription' , 'keywords' => 'IPTCKeywords' , 'latitude' => 'GPSLatitudeDecimal' , 'longitude' => 'GPSLongitudeDecimal' , 'location_city' => 'IPTCCity' , 'location_country' => 'IPTCCountry' , 'location_region' => 'IPTCRegion' , 'note' => 'IPTCLocation' , 'publisher' => 'IPTCCredit' , 'source' => 'IPTCSource' , 'title' => 'IPTCTitle' , ] ; foreach ( $ mapping as $ falKey => $ metadataKeyMapping ) { if ( ! empty ( $ newMetadata [ $ falKey ] ) ) { continue ; } $ metatadaKeys = explode ( '|' , $ metadataKeyMapping ) ; foreach ( $ metatadaKeys as $ metadataKey ) { $ value = null ; if ( isset ( $ metadata [ $ metadataKey ] ) ) { $ value = trim ( $ metadata [ $ metadataKey ] ) ; if ( ord ( $ value ) === 1 ) $ value = null ; switch ( $ metadataKey ) { case 'ColorSpace' : if ( $ value == 1 ) { $ value = 'RGB' ; } else { $ value = null ; } break ; case 'DateTimeOriginal' : $ value = strtotime ( $ value ) ; break ; } } if ( ! empty ( $ value ) ) { $ newMetadata [ $ falKey ] = $ value ; break ; } } } $ metadataRepository -> update ( $ file -> getUid ( ) , $ newMetadata ) ; } }
7093	private function checkHierarchyIntegrity ( InvoiceInterface $ invoice ) { if ( null !== $ shipment = $ invoice -> getShipment ( ) ) { if ( $ invoice -> getSale ( ) !== $ shipment -> getSale ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isCredit ( $ invoice ) && ! $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isInvoice ( $ invoice ) && $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } } }
7909	protected function renderSearchInput ( ) { $ lines = [ ] ; $ lines [ ] = Html :: beginTag ( 'div' , [ 'class' => 'ui icon search input' ] ) ; $ lines [ ] = Html :: tag ( 'i' , '' , [ 'class' => 'search icon' ] ) ; $ lines [ ] = Html :: input ( 'text' , $ this -> getId ( ) . '-search' , '' , $ this -> searchInputOptions ) ; $ lines [ ] = Html :: endTag ( 'div' ) ; $ lines [ ] = Html :: tag ( 'div' , '' , [ 'class' => 'divider' ] ) ; return implode ( "\n" , $ lines ) ; }
5386	public function isLabel ( $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> widgets [ $ i ] -> isLabel ( $ label ) ) { return true ; } } return false ; }
10253	public function getFullName ( $ gender = null ) { if ( empty ( $ gender ) ) { $ gender = $ this -> getGender ( ) ; } $ person_name = new Entities \ FullName ; $ person_name -> first = $ this -> getFirstName ( $ gender ) ; $ person_name -> middle = $ this -> getMiddleName ( $ gender ) ; $ person_name -> last = $ this -> getLastName ( ) ; $ person_name -> gender = $ gender ; return $ person_name ; }
2590	public function setArrivalDate ( \ DateTime $ arrivalDate ) { $ this -> arrivalDate = ( $ arrivalDate -> format ( 'dmy' ) !== '000000' ) ? $ arrivalDate -> format ( 'dmy' ) : null ; $ time = $ arrivalDate -> format ( 'Hi' ) ; if ( $ time !== '0000' ) { $ this -> arrivalTime = $ time ; } }
2657	public function createResponse ( $ version , array $ response ) { $ checkIfExists = $ this -> getResponse ( $ version , $ response [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/response_object' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ response [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ response ) ; return $ result ; }
2441	public static function urlDecode ( string $ data ) : self { $ decoded = base64_decode ( strtr ( $ data , '-_,' , '+/=' ) , true ) ; if ( \ function_exists ( 'gzdecode' ) && false !== ( $ uncompressed = @ gzdecode ( $ decoded ) ) ) { $ decoded = $ uncompressed ; } $ json = @ json_decode ( $ decoded , true ) ; if ( null === $ json ) { throw new \ InvalidArgumentException ( 'Invalid JSON data' ) ; } return new self ( $ json [ 'context' ] , $ json [ 'extras' ] , $ json [ 'value' ] , $ json [ 'current' ] ) ; }
12441	public function attach ( $ key , $ instance , $ type = self :: OBJECT ) { switch ( $ type ) { case self :: OBJECT : case self :: CACHE : if ( ! is_object ( $ instance ) ) { throw new \ LogicException ( 'Instance is not an object!' ) ; } break ; case self :: DATABASE : if ( ! ( $ instance instanceof \ PDO ) ) { throw new \ LogicException ( ) ; } break ; } if ( isset ( $ this -> instances [ $ key ] ) ) { return $ this ; } $ this -> instances [ $ key ] = $ instance ; return $ this ; }
11824	public function detect ( ) { $ str = file_get_contents ( $ this -> uri ) ; foreach ( $ this -> getBom ( 'all' ) as $ encoding => $ bom ) { if ( 0 === strncmp ( $ str , $ bom , strlen ( $ bom ) ) ) { return $ encoding ; } } }
11408	public function onBootstrap ( MvcEvent $ e ) { if ( ! $ e -> getRequest ( ) instanceof HttpRequest ) { return ; } $ app = $ e -> getApplication ( ) ; $ services = $ app -> getServiceManager ( ) ; $ eventManager = $ app -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; $ sharedEventManager -> attach ( UserService :: class , 'register' , function ( $ e ) use ( $ services ) { $ user = $ e -> getParam ( 'user' ) ; if ( $ user instanceof RoleableInterface && $ services -> has ( AuthorizationModuleOptions :: class ) ) { $ config = $ services -> get ( PermissionsModuleOptions :: class ) ; $ roleClass = $ config -> getRoleEntityClass ( ) ; $ mapper = $ services -> get ( 'MapperManager' ) -> get ( $ roleClass ) ; if ( $ defaultRole = $ mapper -> find ( $ config -> getAuthenticatedRole ( ) ) ) { $ user -> addRole ( $ defaultRole ) ; } } } , 100 ) ; }
6756	public static function createApp ( string $ appPath , string $ environment , bool $ debug ) : BaseKernel { $ envPath = $ appPath . '/.env' ; if ( file_exists ( $ envPath ) ) { $ dotenv = new Dotenv ( ) ; $ dotenv -> load ( $ envPath ) ; } $ oneBundleAppConfig = new \ OneBundleApp \ App \ OneBundleAppConfig ( $ appPath , $ environment ) ; \ Symfony \ Component \ Debug \ ErrorHandler :: register ( ) ; \ Symfony \ Component \ Debug \ ExceptionHandler :: register ( ) ; return new \ Mmoreram \ BaseBundle \ Kernel \ BaseKernel ( $ oneBundleAppConfig -> getBundles ( ) , $ oneBundleAppConfig -> getConfig ( ) , $ oneBundleAppConfig -> getRoutes ( ) , $ environment , $ debug , $ appPath . '/var' ) ; }
4894	public function end ( ) { if ( ! $ this -> captureLock ) { throw new \ RuntimeException ( 'Cannot end capture, there is no capture running.' ) ; } $ type = $ this -> captureType ; $ content = ob_get_clean ( ) ; $ options = $ this -> captureOptions ; $ this -> captureLock = false ; $ this -> captureType = null ; $ this -> captureOptions = null ; return $ this -> render ( $ type , $ content , $ options ) ; }
6221	public function setHttpClient ( $ httpClient ) { if ( is_null ( $ httpClient ) ) { $ httpClient = new Curl ; $ threeScaleVersion = new ThreeScaleVersion ( ) ; $ version = $ threeScaleVersion -> getVersion ( ) ; $ httpClient -> options [ 'CURLOPT_FOLLOWLOCATION' ] = false ; $ httpClient -> headers [ 'X-3scale-User-Agent' ] = 'plugin-php-v' . $ version ; } $ this -> httpClient = $ httpClient ; }
2547	public function analyzeResponse ( $ sendResult , $ messageName ) { if ( ! empty ( $ sendResult -> exception ) ) { return $ this -> makeResultForException ( $ sendResult ) ; } $ handler = $ this -> findHandlerForMessage ( $ messageName ) ; if ( $ handler instanceof MessageResponseHandler ) { return $ handler -> analyze ( $ sendResult ) ; } else { return new Result ( $ sendResult , Result :: STATUS_UNKNOWN ) ; } }
4720	public function register ( Text $ text ) { $ hash = $ this -> generateHash ( $ text ) ; $ this -> set ( $ hash , $ text ) ; return new Text ( $ hash ) ; }
10260	public function getIp ( ) { $ parts = [ ] ; for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ parts [ ] = $ this -> getInteger ( 0 , 255 ) ; } return join ( '.' , $ parts ) ; }
8759	public function postUpload ( Request $ request ) { $ input = $ request -> all ( ) ; $ response = $ this -> uploadRepository -> upload ( $ input ) ; return $ response ; }
8716	public static function createInLocale ( $ locale , array $ attributes = [ ] , $ translations = [ ] ) { $ model = ( new static ( $ attributes ) ) -> setLocale ( $ locale ) ; if ( $ model -> save ( ) && is_array ( $ translations ) ) { $ model -> saveTranslations ( $ translations ) ; } return $ model ; }
7070	static function round ( $ value , $ unit = 'piece' ) { if ( 0 < $ precision = static :: getPrecision ( $ unit ) ) { $ divider = pow ( 10 , $ precision ) ; return round ( floor ( $ value * $ divider ) / $ divider , $ precision ) ; } return floor ( $ value ) ; }
11555	private function getBonusTotals ( $ dsBegin , $ dsEnd ) { $ query = $ this -> qbGetBonusTotals -> build ( ) ; $ conn = $ query -> getConnection ( ) ; $ bind = [ QBGetTotals :: BND_PERIOD_BEGIN => $ dsBegin , QBGetTotals :: BND_PERIOD_END => $ dsEnd ] ; $ rs = $ conn -> fetchAll ( $ query , $ bind ) ; $ result = [ ] ; foreach ( $ rs as $ one ) { $ accId = $ one [ QBGetTotals :: A_ACC_ID ] ; $ custId = $ one [ QBGetTotals :: A_CUST_ID ] ; $ total = $ one [ QBGetTotals :: A_TOTAL ] ; if ( $ custId ) { $ item = new DTotal ( ) ; $ item -> accountId = $ accId ; $ item -> customerId = $ custId ; $ item -> total = $ total ; $ result [ $ custId ] = $ item ; } } return $ result ; }
10770	protected function resolveViewName ( ) { $ viewName = Yii :: $ app -> request -> get ( $ this -> viewParam , $ this -> defaultView ) ; if ( ! is_string ( $ viewName ) || ! preg_match ( '~^\w(?:(?!\/\.{0,2}\/)[\w\/\-\.])*$~' , $ viewName ) ) { if ( YII_DEBUG ) { throw new NotFoundHttpException ( "The requested view \"$viewName\" must start with a word character, must not contain /../ or /./, can contain only word characters, forward slashes, dots and dashes." ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return empty ( $ this -> viewPrefix ) ? $ viewName : $ this -> viewPrefix . '/' . $ viewName ; }
9137	public function call ( callable $ callable , array $ args = [ ] ) { $ args = $ this -> resolveArguments ( $ args ) ; $ reflection = $ this -> reflectCallable ( $ callable ) ; return call_user_func_array ( $ callable , $ this -> getParameters ( $ reflection , $ args ) ) ; }
882	private function normalizeType ( $ type ) { if ( '[]' === substr ( $ type , - 2 ) ) { return $ this -> normalize ( substr ( $ type , 0 , - 2 ) ) . '[]' ; } return $ this -> normalize ( $ type ) ; }
12690	protected function merge ( array $ configs ) { $ objects = array_filter ( $ configs , 'is_object' ) ; if ( ! empty ( $ objects ) ) { $ listConfigs = [ ] ; foreach ( $ configs as $ config ) { if ( ! is_object ( $ config ) ) { throw new RuntimeException ( 'Cannot merge object with other types' ) ; } $ listConfigs [ ] = ( array ) $ config ; } $ result = ( object ) $ this -> merge ( $ listConfigs ) ; } else { foreach ( $ configs as $ config ) { foreach ( $ config as $ key => $ value ) { $ existed = isset ( $ result [ $ key ] ) ; switch ( true ) { case ( $ existed && ( is_object ( $ result [ $ key ] ) || is_object ( $ value ) ) ) : case ( $ existed && ( is_array ( $ result [ $ key ] ) && is_array ( $ value ) ) ) : $ result [ $ key ] = $ this -> merge ( array ( $ result [ $ key ] , $ value ) ) ; break ; default : $ result [ $ key ] = $ value ; } } } } return $ result ; }
6130	protected function getCorpusName ( ) { if ( $ this -> currObj instanceof Channel && $ this -> currObj -> isSpacer ( ) ) { if ( $ this -> currObj -> spacerGetType ( ) != TeamSpeak3 :: SPACER_CUSTOM ) { return "" ; } $ string = $ this -> currObj [ "channel_name" ] -> section ( "]" , 1 , 99 ) ; if ( $ this -> currObj -> spacerGetAlign ( ) == TeamSpeak3 :: SPACER_ALIGN_REPEAT ) { $ string -> resize ( 30 , $ string ) ; } return htmlspecialchars ( $ string ) ; } if ( $ this -> currObj instanceof Client ) { $ before = array ( ) ; $ behind = array ( ) ; foreach ( $ this -> currObj -> memberOf ( ) as $ group ) { if ( $ group -> getProperty ( "namemode" ) == TeamSpeak3 :: GROUP_NAMEMODE_BEFORE ) { $ before [ ] = "[" . htmlspecialchars ( $ group [ "name" ] ) . "]" ; } elseif ( $ group -> getProperty ( "namemode" ) == TeamSpeak3 :: GROUP_NAMEMODE_BEHIND ) { $ behind [ ] = "[" . htmlspecialchars ( $ group [ "name" ] ) . "]" ; } } return implode ( "" , $ before ) . " " . htmlspecialchars ( $ this -> currObj ) . " " . implode ( "" , $ behind ) ; } return htmlspecialchars ( $ this -> currObj ) ; }
6878	private function getRevenueQuery ( ) { if ( null !== $ this -> revenueQuery ) { return $ this -> revenueQuery ; } $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ expr = $ qb -> expr ( ) ; return $ this -> revenueQuery = $ qb -> select ( [ 'o.date' , 'o.revenue' , 'o.details' ] ) -> andWhere ( $ expr -> eq ( 'o.type' , ':type' ) ) -> andWhere ( $ expr -> gte ( 'o.date' , ':from' ) ) -> andWhere ( $ expr -> lte ( 'o.date' , ':to' ) ) -> addOrderBy ( 'o.date' ) -> getQuery ( ) ; }
7664	function AttachAll ( ) { $ mime = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> attachment ) ; $ i ++ ) { $ bString = $ this -> attachment [ $ i ] [ 5 ] ; if ( $ bString ) $ string = $ this -> attachment [ $ i ] [ 0 ] ; else $ path = $ this -> attachment [ $ i ] [ 0 ] ; $ filename = $ this -> attachment [ $ i ] [ 1 ] ; $ name = $ this -> attachment [ $ i ] [ 2 ] ; $ encoding = $ this -> attachment [ $ i ] [ 3 ] ; $ type = $ this -> attachment [ $ i ] [ 4 ] ; $ disposition = $ this -> attachment [ $ i ] [ 6 ] ; $ cid = $ this -> attachment [ $ i ] [ 7 ] ; $ mime [ ] = sprintf ( "--%s%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Type: %s; name=\"%s\"%s" , $ type , $ name , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Transfer-Encoding: %s%s" , $ encoding , $ this -> LE ) ; if ( $ disposition == "inline" ) $ mime [ ] = sprintf ( "Content-ID: <%s>%s" , $ cid , $ this -> LE ) ; $ mime [ ] = sprintf ( "Content-Disposition: %s; filename=\"%s\"%s" , $ disposition , $ name , $ this -> LE . $ this -> LE ) ; if ( $ bString ) { $ mime [ ] = $ this -> EncodeString ( $ string , $ encoding ) ; if ( $ this -> IsError ( ) ) { return "" ; } $ mime [ ] = $ this -> LE . $ this -> LE ; } else { $ mime [ ] = $ this -> EncodeFile ( $ path , $ encoding ) ; if ( $ this -> IsError ( ) ) { return "" ; } $ mime [ ] = $ this -> LE . $ this -> LE ; } } $ mime [ ] = sprintf ( "--%s--%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; return join ( "" , $ mime ) ; }
7145	public function add_custom_profile_fields ( $ user ) { $ user_settings = apply_filters ( 'iac_get_user_settings' , array ( ) , $ user -> ID ) ; $ nonce = wp_create_nonce ( 'iac_user_settings' ) ; ?> <h3> <?php _e ( 'Informer?' , $ this -> get_textdomain ( ) ) ; ?> </h3> <table class="form-table"> <tr id="post_subscription"> <th> <label for="post_subscription_checkbox"> <?php _e ( 'Posts subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="post_subscription_checkbox" name="post_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_posts' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new posts via e-mail, without your own posts.' , $ this -> get_textdomain ( ) ) ; ?> </span> </td> </tr> <tr id="comment_subscription"> <th> <label for="comment_subscription_checkbox"> <?php _e ( 'Comments subscription' , $ this -> get_textdomain ( ) ) ; ?> </label> </th> <td> <input type="checkbox" id="comment_subscription_checkbox" name="comment_subscription" value="1" <?php checked ( '1' , $ user_settings [ 'inform_about_comments' ] ) ; ?> /> <span class="description"> <?php _e ( 'Inform about new comments via e-mail, without your own comments.' , $ this -> get_textdomain ( ) ) ; ?> </span> <input type="hidden" name="iac_nonce" value=" <?php echo $ nonce ; ?> " /> </td> </tr> </table> <?php }
1680	public function handleUserProfile ( Contao \ DataContainer $ dc ) { if ( Contao \ Input :: get ( 'do' ) != 'login' ) { return ; } if ( Contao \ BackendUser :: getInstance ( ) -> id != Contao \ Input :: get ( 'id' ) || Contao \ Input :: get ( 'act' ) != 'edit' ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not allowed to edit this page.' ) ; } $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'closed' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'hideVersionMenu' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] = array ( '__selector__' => $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ '__selector__' ] , 'default' => $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ 'login' ] ) ; $ arrFields = Contao \ StringUtil :: trimsplit ( '[,;]' , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ 'default' ] ) ; foreach ( $ arrFields as $ strField ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ strField ] [ 'exclude' ] = false ; } }
5162	public function attachGallery ( Gallery $ gallery ) : self { return $ this -> attach ( self :: ATTACHMENT_FIELD_GALLERY , $ this -> ensureOrder ( $ gallery , self :: ATTACHMENT_FIELD_GALLERY ) ) ; }
5697	public function baseTransform ( ) { parent :: baseTransform ( ) ; $ disabled = ( ! $ this -> gridFieldRequest -> getPreviousRecordID ( ) ) ; return $ this -> setDisabled ( $ disabled ) ; }
8939	public function closeChangeset ( $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/close' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'format' ] = 'text/xml' ; $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ header ) ; }
10360	public static function fatal ( ) { $ e = error_get_last ( ) ; if ( $ e !== null && ( error_reporting ( ) & $ e [ 'type' ] ) !== 0 ) { ErrorHandler :: exception ( new \ ErrorException ( $ e [ 'message' ] , $ e [ 'type' ] , 0 , $ e [ 'file' ] , $ e [ 'line' ] ) ) ; exit ( 1 ) ; } }
3319	public function isa ( $ type , $ option = null ) { if ( $ type === 'bool' ) { $ type = 'boolean' ; } $ this -> isa = $ type ; $ this -> isaOption = $ option ; return $ this ; }
9672	private function writeBorderPr ( XMLWriter $ objWriter , $ pName , Border $ pBorder ) { if ( $ pBorder -> getBorderStyle ( ) != Border :: BORDER_NONE ) { $ objWriter -> startElement ( $ pName ) ; $ objWriter -> writeAttribute ( 'style' , $ pBorder -> getBorderStyle ( ) ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pBorder -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; } }
9556	public function add ( ParameterClosure $ closure ) { $ this -> prefixes [ $ closure -> prefix ] [ $ closure -> parameterName ] = $ closure ; return $ this ; }
8676	public function flip ( ) { if ( ! $ this -> items ) { return $ this -> createFrom ( [ ] ) ; } try { return $ this -> createFrom ( Thrower :: call ( 'array_flip' , $ this -> items ) ) ; } catch ( ErrorException $ e ) { throw new LogicException ( 'Only string and integer values can be flipped' ) ; } }
3855	public function setMetaTags ( $ strTitleAttribute , $ strDescriptionAttribute ) { $ this -> strDescriptionAttribute = $ strDescriptionAttribute ; $ this -> strTitleAttribute = $ strTitleAttribute ; return $ this ; }
906	public function isBinaryOperator ( $ index ) { static $ nonArrayOperators = [ '=' => true , '*' => true , '/' => true , '%' => true , '<' => true , '>' => true , '|' => true , '^' => true , '.' => true , ] ; static $ potentialUnaryNonArrayOperators = [ '+' => true , '-' => true , '&' => true , ] ; static $ arrayOperators ; if ( null === $ arrayOperators ) { $ arrayOperators = [ T_AND_EQUAL => true , T_BOOLEAN_AND => true , T_BOOLEAN_OR => true , T_CONCAT_EQUAL => true , T_DIV_EQUAL => true , T_DOUBLE_ARROW => true , T_IS_EQUAL => true , T_IS_GREATER_OR_EQUAL => true , T_IS_IDENTICAL => true , T_IS_NOT_EQUAL => true , T_IS_NOT_IDENTICAL => true , T_IS_SMALLER_OR_EQUAL => true , T_LOGICAL_AND => true , T_LOGICAL_OR => true , T_LOGICAL_XOR => true , T_MINUS_EQUAL => true , T_MOD_EQUAL => true , T_MUL_EQUAL => true , T_OR_EQUAL => true , T_PLUS_EQUAL => true , T_POW => true , T_POW_EQUAL => true , T_SL => true , T_SL_EQUAL => true , T_SR => true , T_SR_EQUAL => true , T_XOR_EQUAL => true , CT :: T_TYPE_ALTERNATION => true , ] ; if ( \ defined ( 'T_SPACESHIP' ) ) { $ arrayOperators [ T_SPACESHIP ] = true ; } if ( \ defined ( 'T_COALESCE' ) ) { $ arrayOperators [ T_COALESCE ] = true ; } } $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( $ token -> isArray ( ) ) { return isset ( $ arrayOperators [ $ token -> getId ( ) ] ) ; } if ( isset ( $ nonArrayOperators [ $ token -> getContent ( ) ] ) ) { return true ; } if ( isset ( $ potentialUnaryNonArrayOperators [ $ token -> getContent ( ) ] ) ) { return ! $ this -> isUnaryPredecessorOperator ( $ index ) ; } return false ; }
9594	public function makeSessionHandler ( ) { $ handler = $ this -> dic -> resolve ( 'Autarky\Http\SessionHandlerFactory' ) -> makeHandler ( $ this -> config -> get ( 'session.handler' ) ) ; if ( $ this -> config -> get ( 'session.write_check' ) === true ) { $ handler = new WriteCheckSessionHandler ( $ handler ) ; } return $ handler ; }
8504	public function confirmTransportRequest ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ConfirmTransportRequest' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ConfirmTransportRequestResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5496	public function register ( $ method , $ args , $ action ) { $ args = $ this -> replaceWildcards ( $ args ) ; $ method = strtolower ( $ method ) ; if ( ! isset ( $ this -> always [ $ method ] ) ) { $ this -> always [ $ method ] = new SimpleSignatureMap ( ) ; } $ this -> always [ $ method ] -> add ( $ args , $ action ) ; }
11462	public static function notice ( $ message ) { $ message = preg_replace ( '/\s+/' , ' ' , $ message ) ; static :: writeLogLine ( 'Notices.log' , $ message ) ; trigger_error ( $ message , E_USER_NOTICE ) ; }
7567	protected function parse_adjacent ( ) { $ tmp = $ this -> result ; $ this -> result = array ( ) ; if ( ( $ c = $ this -> parse_conditions ( ) ) === false ) { return false ; } foreach ( $ tmp as $ t ) { if ( ( $ sibling = $ t -> getNextSibling ( ) ) !== false ) { if ( $ sibling -> match ( $ c , true , $ this -> custom_filter_map ) ) { $ this -> result [ ] = $ sibling ; } } } return true ; }
2007	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; if ( $ exception -> getPrevious ( ) instanceof ResourceNotFoundException && ! $ this -> hasRootPages ( ) ) { $ exception = new NoRootPageFoundException ( 'No root page found' , 0 , $ exception ) ; } $ class = $ this -> getTargetClass ( $ exception ) ; if ( null === $ class ) { return ; } if ( null !== ( $ httpException = $ this -> convertToHttpException ( $ exception , $ class ) ) ) { $ event -> setException ( $ httpException ) ; } }
11038	function node_path_walk ( $ elements , $ rank , $ ptype , & $ i , & $ line , $ cvalue , $ ncontent , $ content , $ code ) { if ( count ( $ elements ) == 1 ) { $ elt [ $ ptype . ':' . $ i . ':' . $ elements [ 0 ] . ':' . $ cvalue ] = $ this -> parse ( $ code ? _ETS_CODE : $ ptype , $ i , $ line , $ ncontent , $ content ) ; } else { $ element1 = array_shift ( $ elements ) ; $ masktype = ( $ ptype == _ETS_MIS || $ ptype == _ETS_MISVAL ) ? _ETS_MIS_TEMPLATE : _ETS_TEMPLATE ; $ elt [ $ masktype . ':' . $ i . '.' . $ rank . ':' . $ element1 ] = $ this -> node_path_walk ( $ elements , $ rank + 1 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } return $ elt ; }
737	protected function saveToFile ( $ data , $ file ) { file_put_contents ( $ file , "<?php\nreturn " . VarDumper :: export ( $ data ) . ";\n" , LOCK_EX ) ; $ this -> invalidateScriptCache ( $ file ) ; }
5623	protected function parseRequest ( $ raw ) { $ this -> raw = $ raw ; $ request = new SimpleGetEncoding ( ) ; foreach ( explode ( '&' , $ raw ) as $ pair ) { if ( preg_match ( '/(.*?)=(.*)/' , $ pair , $ matches ) ) { $ request -> add ( urldecode ( $ matches [ 1 ] ) , urldecode ( $ matches [ 2 ] ) ) ; } elseif ( $ pair ) { $ request -> add ( urldecode ( $ pair ) , '' ) ; } } return $ request ; }
236	protected function getCacheKey ( $ name ) { return [ __CLASS__ , $ this -> db -> dsn , $ this -> db -> username , $ this -> getRawTableName ( $ name ) , ] ; }
6910	public function addExtraCopy ( Recipient $ copy ) { if ( ! $ this -> extraCopies -> contains ( $ copy ) ) { $ this -> extraCopies -> add ( $ copy ) ; } return $ this ; }
5788	public function runExecute ( bool $ alterBooleanArgs = false ) { if ( ! isset ( $ this -> sql ) ) { $ this -> setSql ( ) ; } if ( isset ( $ this -> primaryKeyName ) ) { return parent :: executeWithReturnField ( $ this -> primaryKeyName , $ alterBooleanArgs ) ; } else { return parent :: execute ( $ alterBooleanArgs ) ; } }
516	public function actionMark ( $ version ) { $ originalVersion = $ version ; if ( ( $ namespaceVersion = $ this -> extractNamespaceMigrationVersion ( $ version ) ) !== false ) { $ version = $ namespaceVersion ; } elseif ( ( $ migrationName = $ this -> extractMigrationVersion ( $ version ) ) !== false ) { $ version = $ migrationName ; } elseif ( $ version !== static :: BASE_MIGRATION ) { throw new Exception ( "The version argument must be either a timestamp (e.g. 101129_185401)\nor the full name of a migration (e.g. m101129_185401_create_user_table)\nor the full name of a namespaced migration (e.g. app\\migrations\\M101129185401CreateUserTable)." ) ; } $ migrations = $ this -> getNewMigrations ( ) ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ this -> confirm ( "Set migration history at $originalVersion?" ) ) { for ( $ j = 0 ; $ j <= $ i ; ++ $ j ) { $ this -> addMigrationHistory ( $ migrations [ $ j ] ) ; } $ this -> stdout ( "The migration history is set at $originalVersion.\nNo actual migration was performed.\n" , Console :: FG_GREEN ) ; } return ExitCode :: OK ; } } $ migrations = array_keys ( $ this -> getMigrationHistory ( null ) ) ; $ migrations [ ] = static :: BASE_MIGRATION ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ i === 0 ) { $ this -> stdout ( "Already at '$originalVersion'. Nothing needs to be done.\n" , Console :: FG_YELLOW ) ; } else { if ( $ this -> confirm ( "Set migration history at $originalVersion?" ) ) { for ( $ j = 0 ; $ j < $ i ; ++ $ j ) { $ this -> removeMigrationHistory ( $ migrations [ $ j ] ) ; } $ this -> stdout ( "The migration history is set at $originalVersion.\nNo actual migration was performed.\n" , Console :: FG_GREEN ) ; } } return ExitCode :: OK ; } } throw new Exception ( "Unable to find the version '$originalVersion'." ) ; }
9466	private function getServerModules ( array $ requirements ) { if ( ! function_exists ( 'apache_get_modules' ) ) { return collect ( [ ] ) ; } $ modules = apache_get_modules ( ) ; $ requirements = array_combine ( $ requirements , $ requirements ) ; return collect ( $ requirements ) -> transform ( function ( $ requirement ) use ( $ modules ) { return in_array ( $ requirement , $ modules ) ; } ) ; }
2045	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ return = '<pre>' . htmlspecialchars ( $ this -> code ) . '</pre>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
8695	public static function format ( $ size , $ decimals = 2 , $ decPoint = '.' , $ thousandsSep = '' , $ unitSep = '' ) { $ output = $ unit = null ; foreach ( self :: getBinarySizes ( ) as $ unit => $ divider ) { $ output = $ size / $ divider ; if ( $ output < 1000 ) { break ; } } if ( null === $ output ) { throw new \ UnexpectedValueException ( "Unable to parse value: '{$size}'" ) ; } $ unit = $ unit === 'o' ? 'o' : ucfirst ( $ unit ) ; $ trimmed = rtrim ( rtrim ( number_format ( $ output , $ decimals , $ decPoint , $ thousandsSep ) , '0' ) , $ decPoint ) ; $ formatted = $ trimmed . $ unitSep . $ unit ; return str_replace ( ' ' , utf8_encode ( chr ( 160 ) ) , $ formatted ) ; }
8507	public function getPackageLabels ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPackageLabelsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPackageLabelsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPackageLabels' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPackageLabelsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1495	public static function createCustom ( ... $ mediaTypes ) : self { $ encodings = new self ( ) ; $ encodings -> stack = collect ( $ mediaTypes ) -> map ( function ( $ mediaType ) { return Encoding :: custom ( $ mediaType ) ; } ) -> all ( ) ; return $ encodings ; }
7439	protected function initializeProductMediaGalleryValue ( array $ attr ) { $ rowId = $ attr [ MemberNames :: ROW_ID ] ; $ valueId = $ attr [ MemberNames :: VALUE_ID ] ; $ storeId = $ attr [ MemberNames :: STORE_ID ] ; if ( $ entity = $ this -> loadProductMediaGalleryValueByValueIdAndStoreIdAndRowId ( $ valueId , $ storeId , $ rowId ) ) { return $ this -> mergeEntity ( $ entity , $ attr ) ; } return $ attr ; }
9050	private static function checkLevel ( $ level ) { if ( $ level != LogLevel :: ALERT && $ level != LogLevel :: CRITICAL && $ level != LogLevel :: DEBUG && $ level != LogLevel :: EMERGENCY && $ level != LogLevel :: ERROR && $ level != LogLevel :: INFO && $ level != LogLevel :: NOTICE && $ level != LogLevel :: WARNING ) { throw new \ Psr \ Log \ InvalidArgumentException ( "Invalid log level provided!" ) ; } }
4141	protected function getSignatureBaseString ( ) { $ method = strtoupper ( $ this -> method ) ; $ url = rawurlencode ( $ this -> getUrl ( ) ) ; return $ method . '&' . $ url . '&' . $ this -> getRequestString ( ) ; }
663	public function getMaster ( ) { if ( $ this -> _master === false ) { $ this -> _master = $ this -> shuffleMasters ? $ this -> openFromPool ( $ this -> masters , $ this -> masterConfig ) : $ this -> openFromPoolSequentially ( $ this -> masters , $ this -> masterConfig ) ; } return $ this -> _master ; }
10631	public static function avgload ( ) { $ avgload = new \ StdClass ( ) ; if ( false !== ( $ data = @ file ( '/proc/loadavg' ) ) ) { $ data = explode ( " " , implode ( "" , $ data ) ) ; $ data = array_chunk ( $ data , 4 ) ; $ avgload -> min1 = $ data [ 0 ] [ 0 ] ; $ avgload -> min5 = $ data [ 0 ] [ 1 ] ; $ avgload -> min15 = $ data [ 0 ] [ 2 ] ; $ fourth = explode ( '/' , $ data [ 0 ] [ 3 ] ) ; $ avgload -> running = $ fourth [ 0 ] ; $ avgload -> exists = $ fourth [ 1 ] ; $ avgload -> recentPID = $ data [ 1 ] [ 0 ] ; } return $ avgload ; }
8283	protected function resolveRealUrl ( $ fileName ) { $ fileNameClean = str_replace ( "\0" , '' , $ fileName ) ; $ realPath = realpath ( $ fileNameClean ) ; if ( $ realPath === false ) { return $ this -> requestUrl ; } $ contentPath = realpath ( $ this -> pico -> getConfig ( 'content_dir' ) ) ; $ contentExt = $ this -> pico -> getConfig ( 'content_ext' ) ; if ( strpos ( $ realPath , $ contentPath ) !== 0 ) { throw new \ RuntimeException ( "The plugin cannot be used with " . "symbolic links inside the content directory." ) ; } $ name = substr ( $ realPath , strlen ( $ contentPath ) + 1 , - strlen ( $ contentExt ) ) ; if ( DIRECTORY_SEPARATOR !== '/' ) { $ name = str_replace ( DIRECTORY_SEPARATOR , '/' , $ name ) ; } if ( strlen ( $ name ) >= 5 && 0 === substr_compare ( $ name , "index" , - 5 ) ) { $ name = rtrim ( substr ( $ name , 0 , - 5 ) , '/' ) ; } return $ name ; }
10992	public function splitName ( string $ defaultExtension = "" ) : array { $ filename = basename ( $ this -> path ) ; $ extpos = strrpos ( $ filename , "." ) ; if ( $ extpos === false || $ extpos === 0 ) { $ name = $ filename ; $ ext = $ defaultExtension ; } else { $ name = substr ( $ filename , 0 , $ extpos ) ; $ ext = substr ( $ filename , $ extpos + 1 ) ; } return [ $ name , $ ext ] ; }
6063	public function listFolders ( $ id , $ depth = 0 , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'depth' => $ depth ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/folders' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
7790	public function setOpeningBalanceClass ( $ openingBalanceClass ) { if ( ! is_callable ( $ openingBalanceClass ) && ! class_exists ( $ openingBalanceClass ) ) { throw new \ InvalidArgumentException ( '$openingBalanceClass must be a valid classname or a PHP callable' ) ; } $ this -> openingBalanceClass = $ openingBalanceClass ; return $ this ; }
3485	public static function resolve ( ) : SignatureGeneratorInterface { self :: addDefaultResolvers ( ) ; foreach ( self :: $ resolvers as $ resolver ) { if ( $ generator = $ resolver ( ) ) { return $ generator ; } } throw new \ LogicException ( 'Cannot resolve available JWT Signature Generator.' ) ; }
7311	public static function solsticeWinter ( $ year ) { $ jd = static :: solsticeDecember ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
2093	protected function validator ( $ varInput ) { $ this -> blnSubmitInput = false ; if ( ! \ strlen ( $ varInput ) && ( \ strlen ( $ this -> varValue ) || ! $ this -> mandatory ) ) { return '' ; } $ intLength = $ this -> minlength ? : Config :: get ( 'minPasswordLength' ) ; if ( Utf8 :: strlen ( $ varInput ) < $ intLength ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'passwordLength' ] , $ intLength ) ) ; } if ( $ varInput != $ this -> getPost ( $ this -> strName . '_confirm' ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'passwordMatch' ] ) ; } $ varInput = parent :: validator ( $ varInput ) ; if ( ! $ this -> hasErrors ( ) ) { $ this -> blnSubmitInput = true ; return password_hash ( $ varInput , PASSWORD_DEFAULT ) ; } return '' ; }
3519	public function getWebUITranslations ( ) { $ TITLE_SAVE_CHANGES = $ this -> get ( $ this -> package . '::messages.title-save-changes' ) ; $ TITLE_CANCEL_CHANGES = $ this -> get ( $ this -> package . '::messages.title-cancel-changes' ) ; $ TITLE_TRANSLATE = $ this -> get ( $ this -> package . '::messages.title-translate' ) ; $ TITLE_CONVERT_KEY = $ this -> get ( $ this -> package . '::messages.title-convert-key' ) ; $ TITLE_GENERATE_PLURALS = $ this -> get ( $ this -> package . '::messages.title-generate-plurals' ) ; $ TITLE_CLEAN_HTML_MARKDOWN = $ this -> get ( $ this -> package . '::messages.title-clean-html-markdown' ) ; $ TITLE_CAPITALIZE = $ this -> get ( $ this -> package . '::messages.title-capitalize' ) ; $ TITLE_LOWERCASE = $ this -> get ( $ this -> package . '::messages.title-lowercase' ) ; $ TITLE_CAPITALIZE_FIRST_WORD = $ this -> get ( $ this -> package . '::messages.title-capitalize-first-word' ) ; $ TITLE_SIMULATED_COPY = $ this -> get ( $ this -> package . '::messages.title-simulated-copy' ) ; $ TITLE_SIMULATED_PASTE = $ this -> get ( $ this -> package . '::messages.title-simulated-paste' ) ; $ TITLE_RESET_EDITOR = $ this -> get ( $ this -> package . '::messages.title-reset-editor' ) ; $ TITLE_LOAD_LAST = $ this -> get ( $ this -> package . '::messages.title-load-last' ) ; return <<<HTML<script>var TITLE_SAVE_CHANGES = "$TITLE_SAVE_CHANGES";var TITLE_CANCEL_CHANGES = "$TITLE_CANCEL_CHANGES";var TITLE_TRANSLATE = "$TITLE_TRANSLATE";var TITLE_CONVERT_KEY = "$TITLE_CONVERT_KEY";var TITLE_GENERATE_PLURALS = "$TITLE_GENERATE_PLURALS";var TITLE_CLEAN_HTML_MARKDOWN = "$TITLE_CLEAN_HTML_MARKDOWN";var TITLE_CAPITALIZE = "$TITLE_CAPITALIZE";var TITLE_LOWERCASE = "$TITLE_LOWERCASE";var TITLE_CAPITALIZE_FIRST_WORD = "$TITLE_CAPITALIZE_FIRST_WORD";var TITLE_SIMULATED_COPY = "$TITLE_SIMULATED_COPY";var TITLE_SIMULATED_PASTE = "$TITLE_SIMULATED_PASTE";var TITLE_RESET_EDITOR = "$TITLE_RESET_EDITOR";var TITLE_LOAD_LAST = "$TITLE_LOAD_LAST";</script>HTML ; }
808	private function sortAlphabetically ( array $ first , array $ second ) { $ firstNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ first [ 'namespace' ] ) ) ; $ secondNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ second [ 'namespace' ] ) ) ; return strcasecmp ( $ firstNamespace , $ secondNamespace ) ; }
4527	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Identitiable ) { return ; } $ this -> identityService -> generateIdentity ( $ entity ) ; }
949	public function sanitizeShopDomain ( $ domain ) { if ( empty ( $ domain ) ) { return ; } $ configEndDomain = Config :: get ( 'shopify-app.myshopify_domain' ) ; $ domain = strtolower ( preg_replace ( '/https?:\/\//i' , '' , trim ( $ domain ) ) ) ; if ( strpos ( $ domain , $ configEndDomain ) === false && strpos ( $ domain , '.' ) === false ) { $ domain .= ".{$configEndDomain}" ; } return parse_url ( "http://{$domain}" , PHP_URL_HOST ) ; }
2284	protected static function ip ( ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { return '' ; } return $ request -> getClientIp ( ) ; }
7181	protected function generateNumber ( PaymentInterface $ payment ) { if ( 0 == strlen ( $ payment -> getNumber ( ) ) ) { $ this -> numberGenerator -> generate ( $ payment ) ; return true ; } return false ; }
6750	public function getTransformer ( ) { if ( ! property_exists ( $ this , 'transformer' ) || ! $ this -> transformer ) { if ( ! $ this -> _defaultTransformer ) { $ this -> createQualifiedTransformerClass ( ) ; } return $ this -> _defaultTransformer ; } return $ this -> transformer ; }
2717	public function render ( AbstractElement $ element ) { $ element -> unsScope ( ) -> unsCanUseWebsiteValue ( ) -> unsCanUseDefaultValue ( ) ; return parent :: render ( $ element ) ; }
6202	public function methodFail ( $ errors = null ) { if ( $ errors === null ) { return $ this -> methodResult ( false ) ; } if ( ! is_array ( $ errors ) ) { $ errors = [ $ errors ] ; } return $ this -> methodResult ( false , [ 'errors' => $ errors ] ) ; }
11252	public function repositoryExists ( ) : bool { switch ( $ this -> pdo -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) ) { case 'pgsql' : $ sql = 'select count(*) from information_schema.tables where table_schema = current_schema() and table_name = ?' ; break ; case 'mysql' : $ sql = 'select count(*) from information_schema.tables where table_schema = database() and table_name = ?' ; break ; case 'sqlsrv' : $ sql = "select count(*) from sysobjects where type = 'U' and name = ?" ; break ; case 'sqlite' : $ sql = "select count(*) from sqlite_master where type = 'table' and name = ?" ; break ; default : throw InvalidArgumentException :: forDatabaseNotSupported ( ) ; } $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> bindParam ( 1 , $ this -> table ) ; $ stmt -> execute ( ) ; return $ stmt -> fetch ( PDO :: FETCH_COLUMN ) > 0 ; }
9031	public function execute ( Closure $ callback ) { foreach ( $ this -> getServices ( ) as $ service ) { try { return $ callback ( $ this -> container -> make ( $ service ) ) ; } catch ( Exception $ e ) { } } throw new RuntimeException ( 'Could not execute any service.' ) ; }
10568	public function create ( \ Psr \ Http \ Message \ ServerRequestInterface $ request , string $ sortParameter = self :: SORT , array $ defaultSort = [ ] ) : Pagination { $ offset = 0 ; $ max = PHP_INT_MAX ; $ params = $ request -> getQueryParams ( ) ; $ range = $ request -> getHeaderLine ( self :: RANGE ) ; if ( $ range !== null && preg_match ( self :: REGEX_RANGE , $ range , $ rm ) ) { $ offset = ( int ) $ rm [ 1 ] ; $ max = ( int ) $ rm [ 2 ] - $ offset + 1 ; } else { $ max = $ this -> parse ( self :: $ maxAlias , $ params , PHP_INT_MAX ) ; $ offVal = $ this -> parse ( self :: $ offsetAlias , $ params , 0 ) ; if ( $ offVal > 0 ) { $ offset = $ offVal ; } elseif ( isset ( $ params [ self :: START_INDEX ] ) ) { $ startIdx = isset ( $ params [ self :: START_INDEX ] ) ? ( int ) $ params [ self :: START_INDEX ] : 0 ; if ( $ startIdx > 0 ) { $ offset = $ startIdx - 1 ; } } elseif ( isset ( $ params [ self :: START_PAGE ] ) || isset ( $ params [ self :: PAGE ] ) ) { $ startPage = $ this -> parse ( self :: $ pageAlias , $ params , 0 ) ; if ( $ startPage > 0 ) { $ offset = ( $ max * ( $ startPage - 1 ) ) ; } } } return new Pagination ( $ max , $ offset , $ this -> getOrder ( $ request , $ sortParameter , $ defaultSort ) ) ; }
12813	private static function getNullables ( string $ table ) : array { if ( self :: $ nullablesCache !== null && array_key_exists ( $ table , self :: $ nullablesCache ) ) return self :: $ nullablesCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT column_name, data_type, is_nullable, column_default FROM information_schema.columns WHERE table_name = '$table' AND is_nullable = 'YES' " ; self :: $ nullablesCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ nullablesCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ nullablesCache [ $ table ] ; }
1443	protected function replaceApplicationNamespace ( & $ stub ) { $ namespace = rtrim ( $ this -> laravel -> getNamespace ( ) , '\\' ) ; $ stub = str_replace ( 'DummyApplicationNamespace' , $ namespace , $ stub ) ; return $ this ; }
7594	public function render ( $ sLabelMessage , $ aLabelAttributes = 'label-default' ) { if ( ! is_scalar ( $ sLabelMessage ) ) { throw new InvalidArgumentException ( 'Label message expects a scalar value, "' . gettype ( $ sLabelMessage ) . '" given' ) ; } if ( empty ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes are empty' ) ; } if ( is_string ( $ aLabelAttributes ) ) { $ aLabelAttributes = array ( 'class' => $ aLabelAttributes ) ; } elseif ( ! is_array ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes expects a string or an array, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } elseif ( empty ( $ aLabelAttributes [ 'class' ] ) ) { throw new \ InvalidArgumentException ( 'Label "class" attribute is empty' ) ; } elseif ( ! is_string ( $ aLabelAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Label "class" attribute expects string, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } if ( ! preg_match ( '/(\s|^)label(\s|$)/' , $ aLabelAttributes [ 'class' ] ) ) { $ aLabelAttributes [ 'class' ] .= ' label' ; } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sLabelMessage = $ oTranslator -> translate ( $ sLabelMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ labelFormat , isset ( $ aLabelAttributes [ 'tagName' ] ) ? $ aLabelAttributes [ 'tagName' ] : $ this -> tagName , $ this -> createAttributesString ( $ aLabelAttributes ) , $ sLabelMessage ) ; }
12831	private function onTokenFound ( $ token ) { if ( is_array ( $ token ) ) $ token = array_pop ( $ token ) ; $ token = trim ( $ token ) ; $ tokenParts = explode ( ' ' , $ token ) ; $ tag = array_shift ( $ tokenParts ) ; $ params = implode ( ' ' , $ tokenParts ) ; if ( $ this -> _blocks -> has ( $ tag ) ) { if ( $ this -> _blocks -> getDeepValue ( $ tag . '/runtime' ) ) { $ res = '<?php $this->_compiler->invokeBlock(\'' . $ tag . '\', ' . $ this -> compileExpression ( $ params ) . '); ?>' ; } else { $ res = $ this -> onBlockTagOpen ( $ tag , $ params ) ; } } elseif ( substr ( $ tag , 0 , strlen ( $ this -> _config [ 'blockClose' ] ) ) == $ this -> _config [ 'blockClose' ] ) { $ tag = substr ( $ tag , strlen ( $ this -> _config [ 'blockClose' ] ) ) ; $ res = $ this -> onBlockTagClose ( $ tag , $ params ) ; } else { $ res = $ this -> onVarEchoToken ( $ token , $ params ) ; } return $ res ; }
12720	public function callInstance ( $ instance , $ args = [ ] ) { $ args = ( is_array ( $ args ) ? $ args : array_slice ( func_get_args ( ) , 1 ) ) ; $ current = $ this -> make ( $ instance ) ; return call_user_func_array ( $ current , $ args ) ; }
1428	public static function createMany ( array $ input ) { $ errors = new ErrorCollection ( ) ; foreach ( $ input as $ item ) { $ errors -> add ( self :: create ( $ item ) ) ; } return $ errors ; }
5495	public function findFirstSlot ( $ parameters ) { $ count = count ( $ this -> map ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { if ( $ this -> map [ $ i ] [ 'params' ] -> test ( $ parameters ) ) { return $ this -> map [ $ i ] ; } } return ; }
8343	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ rawRequest = null ; self :: $ routes = array ( ) ; self :: $ isInit = true ; if ( defined ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_IS_HTTP' ) === true ) { self :: $ rawRequest = new RawRequest ( ) ; Session :: init ( ) ; Locale :: init ( self :: $ rawRequest ) ; } } }
7513	function next_no_whitespace ( ) { $ this -> token_start = null ; while ( ++ $ this -> pos < $ this -> size ) { if ( ! isset ( $ this -> whitespace [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
8450	public function contactRename ( $ contact , $ firstName , $ lastName ) { $ contact = $ this -> escapePeer ( $ contact ) ; $ firstName = $ this -> escapeStringArgument ( $ firstName ) ; $ lastName = $ this -> escapeStringArgument ( $ lastName ) ; return $ this -> exec ( 'rename_contact ' . $ contact . ' ' . $ firstName . ' ' . $ lastName ) ; }
5096	public function queryExists ( ) { foreach ( $ this -> selects as $ select ) { $ result = $ select -> queryExists ( ) ; if ( is_null ( $ result ) || $ result ) { return $ result ; } } return false ; }
5799	public function selectArrayWithRolesString ( string $ columns = "*" , array $ whereColumnsInfo = null ) : array { $ administrators = [ ] ; $ results = $ this -> selectArray ( $ columns , $ whereColumnsInfo ) ; foreach ( $ results as $ index => $ administrator ) { $ administrators [ $ index ] = $ administrator ; $ administrators [ $ index ] [ 'roles' ] = implode ( ", " , $ administrators [ $ index ] [ 'roles' ] ) ; } return $ administrators ; }
5094	public function executeIterator ( ) { $ result = $ this -> execute ( ) ; if ( ! $ result ) throw new MySqlException ( 'Could not execute multiset query!' ) ; while ( true ) { yield new StatementResult ( $ result ) ; if ( ! $ result -> nextRowset ( ) ) { $ this -> checkForError ( $ result ) ; break ; } } }
8480	public function run ( $ eventGroupId = null ) { $ eventGroups = EventGroup :: find ( ) -> asArray ( true ) -> all ( ) ; if ( count ( $ eventGroups ) === 0 ) { throw new Exception ( 'Event groups not found' ) ; } if ( $ eventGroupId === null ) { $ first = reset ( $ eventGroups ) ; $ eventGroupId = $ first [ 'id' ] ; } $ tabs = [ ] ; foreach ( $ eventGroups as $ eventGroup ) { $ tabs [ ] = [ 'label' => $ eventGroup [ 'name' ] , 'url' => [ 'index' , 'eventGroupId' => $ eventGroup [ 'id' ] ] , 'active' => $ eventGroupId == $ eventGroup [ 'id' ] , ] ; } $ model = new EventEventHandler ( [ 'scenario' => 'search' ] ) ; $ eventsList = Event :: find ( ) -> select ( [ 'name' , 'id' ] ) -> where ( [ 'event_group_id' => $ eventGroupId ] ) -> indexBy ( 'id' ) -> column ( ) ; return $ this -> controller -> render ( 'index' , [ 'dataProvider' => $ model -> search ( \ Yii :: $ app -> request -> get ( ) , array_keys ( $ eventsList ) ) , 'eventGroupId' => $ eventGroupId , 'eventsList' => $ eventsList , 'model' => $ model , 'tabs' => $ tabs , ] ) ; }
9694	public function canRead ( $ pFilename ) { try { $ this -> openFile ( $ pFilename ) ; } catch ( Exception $ e ) { return false ; } $ beginning = $ this -> readBeginning ( ) ; $ startWithTag = self :: startsWithTag ( $ beginning ) ; $ containsTags = self :: containsTags ( $ beginning ) ; $ endsWithTag = self :: endsWithTag ( $ this -> readEnding ( ) ) ; fclose ( $ this -> fileHandle ) ; return $ startWithTag && $ containsTags && $ endsWithTag ; }
12683	public function process ( ) { $ orderedTasks = $ this -> _tasks ; usort ( $ orderedTasks , function ( $ a , $ b ) { return $ a -> duration ( ) > $ b -> duration ( ) ? 1 : - 1 ; } ) ; $ this -> _ranking = $ orderedTasks ; $ matrix = [ ] ; foreach ( $ this -> _ranking as $ task1 ) { $ name1 = $ task1 -> name ( ) ; $ matrix [ $ name1 ] = [ ] ; foreach ( $ this -> _ranking as $ task2 ) { $ name2 = $ task2 -> name ( ) ; $ percent = intval ( round ( $ task1 -> duration ( ) / $ task2 -> duration ( ) * 100 ) ) ; $ matrix [ $ name1 ] [ $ name2 ] = $ percent ; } } $ this -> _matrix = $ matrix ; return $ this ; }
6269	private function nameFromAcademicDomain ( $ domain ) { $ path = $ this -> getPath ( $ domain ) ; if ( ! file_exists ( $ path ) ) { return null ; } return trim ( file_get_contents ( $ path ) ) ; }
9766	function instanceOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , isInstanceOf ( $ className ) ) ; }
151	public function createCommand ( $ db = null ) { if ( $ db === null ) { $ db = Yii :: $ app -> getDb ( ) ; } list ( $ sql , $ params ) = $ db -> getQueryBuilder ( ) -> build ( $ this ) ; $ command = $ db -> createCommand ( $ sql , $ params ) ; $ this -> setCommandCache ( $ command ) ; return $ command ; }
4624	public function pickNewNode ( ) { $ this -> getActiveNode ( ) -> setInactive ( true ) ; $ this -> attempts ++ ; $ this -> inactiveNodes [ $ this -> getActiveNodeIndex ( ) ] = $ this -> getActiveNode ( ) ; unset ( $ this -> nodes [ $ this -> getActiveNodeIndex ( ) ] ) ; $ this -> setActiveNodeIndex ( $ this -> pickNode ( ) ) ; return $ this ; }
1991	protected function getLoginStatus ( $ strCookie ) { @ trigger_error ( 'Using Frontend::getLoginStatus() has been deprecated and will no longer work in Contao 5.0. Use Symfony security instead.' , E_USER_DEPRECATED ) ; $ objTokenChecker = System :: getContainer ( ) -> get ( 'contao.security.token_checker' ) ; if ( $ strCookie == 'BE_USER_AUTH' && $ objTokenChecker -> hasBackendUser ( ) ) { if ( TL_MODE == 'FE' && ! $ objTokenChecker -> isPreviewMode ( ) ) { return false ; } return true ; } if ( $ strCookie == 'FE_USER_AUTH' && $ objTokenChecker -> hasFrontendUser ( ) ) { return true ; } return false ; }
1829	public function delete ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ intAffected = Database :: getInstance ( ) -> prepare ( "DELETE FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) -> affectedRows ; if ( $ intAffected ) { Registry :: getInstance ( ) -> unregister ( $ this ) ; $ this -> arrData [ static :: $ strPk ] = null ; } return $ intAffected ; }
4901	public static function loadConfig ( $ configuration = [ ] ) { $ configDir = static :: getConfigDir ( ) ; if ( empty ( $ configuration ) ) { $ configFile = $ configDir . '/config.php' ; if ( ! is_file ( $ configFile ) ) { throw new InvalidArgumentException ( sprintf ( 'Can not load config file "%s". Please be sure that this file exists and readable' , $ configFile ) ) ; } $ configuration = include $ configFile ; } $ isCli = php_sapi_name ( ) === 'cli' ; $ modules = $ configuration [ 'modules' ] ; $ modules = static :: generateModuleConfiguration ( $ modules ) ; $ yawikConfig = $ configDir . '/autoload/yawik.config.global.php' ; $ installMode = false ; if ( ! $ isCli && ! file_exists ( $ yawikConfig ) ) { $ modules = static :: generateModuleConfiguration ( [ 'Install' ] ) ; $ installMode = true ; } elseif ( in_array ( 'Install' , $ modules ) ) { $ modules = array_diff ( $ modules , [ 'Install' ] ) ; } static :: $ env = $ env = getenv ( 'APPLICATION_ENV' ) ? : 'production' ; $ defaults = [ 'module_listener_options' => [ 'module_paths' => [ './module' , './vendor' , './modules' ] , 'config_glob_paths' => [ sprintf ( $ configDir . '/autoload/{,*.}{global,%s,local}.php' , $ env ) ] , 'config_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_key' => 'module_map' , 'check_dependencies' => ( $ env != 'production' ) , 'cache_dir' => getcwd ( ) . "/var/cache" , ] , ] ; $ envConfig = [ ] ; $ envConfigFile = $ configDir . '/config.' . $ env . '.php' ; if ( file_exists ( $ envConfigFile ) ) { if ( is_readable ( $ envConfigFile ) ) { $ envConfig = include $ envConfigFile ; } else { \ trigger_error ( sprintf ( 'Environment config file "%s" is not readable.' , $ envConfigFile ) , E_USER_NOTICE ) ; } } $ configuration = ArrayUtils :: merge ( $ defaults , $ configuration ) ; $ configuration = ArrayUtils :: merge ( $ configuration , $ envConfig ) ; $ configuration [ 'modules' ] = $ modules ; if ( $ installMode ) { $ configuration [ 'module_listener_options' ] [ 'config_cache_enabled' ] = false ; $ configuration [ 'module_listener_options' ] [ 'module_map_cache_enabled' ] = false ; } if ( getenv ( 'DOCKER_ENV' ) == 'yes' ) { $ configuration = ArrayUtils :: merge ( $ configuration , static :: getDockerEnv ( $ configuration ) ) ; } return $ configuration ; }
3460	public function find ( string $ method , string $ path ) : Route { $ matcher = new UrlMatcher ( $ this -> routeCollection , new RequestContext ( '/' , $ method ) ) ; try { $ route = $ matcher -> match ( $ path ) ; } catch ( ResourceNotFoundException $ exception ) { throw RouterException :: noRouteMatchesRequestedUri ( $ path , $ method ) ; } catch ( SymfonyMethodNotAllowedException $ exception ) { throw RouterException :: methodNotAllowed ( $ path , $ exception -> getAllowedMethods ( ) ) ; } $ routeName = $ route [ '_route' ] ; unset ( $ route [ '_route' ] ) ; return $ this -> routes [ $ routeName ] -> withAttributes ( $ route ) ; }
1796	private function addIndexRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/' , $ defaults ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_index' , $ route ) ; }
4499	private function arrayMergeDeep ( array $ array1 , array $ array2 ) : array { $ result = [ ] ; foreach ( \ func_get_args ( ) as $ array ) { foreach ( $ array as $ key => $ value ) { if ( \ is_int ( $ key ) ) { $ result [ ] = $ value ; } elseif ( isset ( $ result [ $ key ] ) && \ is_array ( $ result [ $ key ] ) && \ is_array ( $ value ) ) { $ result [ $ key ] = $ this -> arrayMergeDeep ( $ result [ $ key ] , $ value ) ; } else { $ result [ $ key ] = $ value ; } } } return $ result ; }
12903	private function createCacheAdapter ( ) { $ extraData = & $ this -> extraData ; return new CallbackAdapter ( function ( Request $ request ) use ( & $ extraData ) { $ poolName = 'default' ; if ( isset ( $ this -> source [ 'cache' ] [ 'pool' ] ) ) { $ poolName = $ this -> source [ 'cache' ] [ 'pool' ] ; } $ adapter = new CacheAdapter ( $ this -> registry -> getCachePool ( $ poolName ) , new HttpApiAdapter ( ) , function ( Request $ request ) { $ data = $ request -> getData ( ) ; return $ this -> registry -> generateCacheItemKey ( sprintf ( '%s.%s.%s' , $ data [ 'service' ] , $ data [ 'group' ] , $ data [ 'action' ] ) , $ data [ 'arguments' ] ) ; } ) ; $ response = $ adapter -> receive ( $ request ) ; $ extraData = $ response -> getHeaders ( ) ; return $ response ; } ) ; }
10178	public function removeRow ( $ row ) { foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ r == $ row ) { $ this -> delete ( $ coord ) ; } } }
6458	public function writeJson ( IHttpResponseMessage $ response , array $ content ) : void { $ json = json_encode ( $ content ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new InvalidArgumentException ( 'Failed to JSON encode content: ' . json_last_error_msg ( ) ) ; } $ response -> getHeaders ( ) -> add ( 'Content-Type' , 'application/json' ) ; $ response -> setBody ( new StringBody ( $ json ) ) ; }
9373	public function display ( ) { $ handler = new PrettyPageHandler ; error_reporting ( E_ALL ) ; $ this -> __call ( 'pushHandler' , array ( $ handler ) ) ; return $ this -> whoops -> register ( ) ; }
3838	protected function build ( IMetaModelDataDefinition $ container ) { $ this -> inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( $ container -> hasDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ) { $ view = $ container -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; } else { return ; } $ panelLayout = $ this -> inputScreen [ 'meta' ] [ 'panelLayout' ] ; if ( empty ( $ panelLayout ) ) { return ; } $ arrRows = StringUtil :: trimsplit ( ';' , $ panelLayout ) ; $ panel = $ view -> getPanelLayout ( ) ; $ panelRows = $ panel -> getRows ( ) ; foreach ( $ arrRows as $ rowNo => $ rowElements ) { if ( $ panelRows -> getRowCount ( ) < ( $ rowNo + 1 ) ) { $ panelRow = $ panelRows -> addRow ( ) ; } else { $ panelRow = $ panelRows -> getRow ( $ rowNo ) ; } $ fields = StringUtil :: trimsplit ( ',' , $ rowElements ) ; $ fields = array_reverse ( $ fields ) ; $ this -> parsePanelRow ( $ fields , $ panelRow ) ; if ( $ panelRow -> getCount ( ) == 0 ) { $ panelRows -> deleteRow ( $ rowNo ) ; } } $ this -> ensureSubmitElement ( $ panelRows ) ; $ this -> inputScreen = null ; }
3417	protected function getValueFromLanguageField ( $ field ) { $ key = $ field . '_' . $ this -> getCurrentLanguage ( ) ; return isset ( $ this -> fields [ $ key ] ) ? $ this -> fields [ $ key ] : null ; }
4383	protected function buildArgString ( $ args ) { $ numArgs = \ count ( $ args ) ; if ( $ numArgs == 1 && \ is_string ( $ args [ 0 ] ) ) { $ args [ 0 ] = \ strip_tags ( $ args [ 0 ] ) ; } foreach ( $ args as $ k => $ v ) { if ( $ k > 0 || ! \ is_string ( $ v ) ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ this -> valDepth = 0 ; } $ glue = ', ' ; $ glueAfterFirst = true ; if ( $ numArgs && \ is_string ( $ args [ 0 ] ) ) { if ( \ preg_match ( '/[=:] ?$/' , $ args [ 0 ] ) ) { $ glueAfterFirst = false ; } elseif ( \ count ( $ args ) == 2 ) { $ glue = ' = ' ; } } if ( ! $ glueAfterFirst ) { return $ args [ 0 ] . \ implode ( $ glue , \ array_slice ( $ args , 1 ) ) ; } else { return \ implode ( $ glue , $ args ) ; } }
3635	public function httpMiddles ( Request $ request ) : array { $ dispatcher = \ bean ( 'serverDispatcher' ) ; $ middleType = ( int ) $ request -> query ( 'type' ) ; if ( $ middleType === 1 ) { return $ dispatcher -> getMiddlewares ( ) ; } return $ dispatcher -> requestMiddleware ( ) ; }
5359	protected function createUrlStatements ( Operation $ operation , $ queryParamVariable ) { $ urlVariable = new Expr \ Variable ( 'url' ) ; $ statements = [ new Expr \ Assign ( $ urlVariable , new Scalar \ String_ ( $ operation -> getPath ( ) ) ) ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof PathParameterSubSchema ) { $ statements [ ] = new Expr \ Assign ( $ urlVariable , new Expr \ FuncCall ( new Name ( 'str_replace' ) , [ new Arg ( new Scalar \ String_ ( '{' . $ parameter -> getName ( ) . '}' ) ) , new Arg ( new Expr \ FuncCall ( new Name ( 'urlencode' ) , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ parameter -> getName ( ) ) ) ) , ] ) ) , new Arg ( $ urlVariable ) ] ) ) ; } } } $ statements [ ] = new Expr \ Assign ( $ urlVariable , new Expr \ BinaryOp \ Concat ( $ urlVariable , new Expr \ BinaryOp \ Concat ( new Scalar \ String_ ( '?' ) , new Expr \ MethodCall ( $ queryParamVariable , 'buildQueryString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ) ) ; return [ $ statements , $ urlVariable ] ; }
11356	public function getInputFilter ( ) { if ( $ this -> filter ) { return $ this -> filter ; } $ specifications = [ ] ; if ( $ this -> object && $ this -> object instanceof InputFilterProviderInterface ) { $ specifications = $ this -> object -> getInputFilterSpecification ( ) ; } if ( $ this instanceof InputFilterProviderInterface ) { $ specifications = ArrayUtils :: merge ( $ specifications , $ this -> getInputFilterSpecification ( ) ) ; } $ this -> addRequiredAttributeToFields ( $ specifications ) ; if ( ! empty ( $ specifications ) && null === $ this -> baseFieldset ) { $ formFactory = $ this -> getFormFactory ( ) ; $ inputFactory = $ formFactory -> getInputFilterFactory ( ) ; if ( ! ( $ this -> filter instanceof InputFilterInterface ) ) { $ this -> filter = new InputFilter ( ) ; $ this -> filter -> setFactory ( $ inputFactory ) ; } foreach ( $ specifications as $ name => $ specification ) { $ input = $ inputFactory -> createInput ( $ specification ) ; $ this -> filter -> add ( $ input , $ name ) ; } } return parent :: getInputFilter ( ) ; }
7388	public function fetch ( string $ key , $ default = null ) { if ( isset ( $ _SERVER [ $ key ] ) ) { return $ _SERVER [ $ key ] ; } else { $ key = 'HTTP_' . $ key ; return $ _SERVER [ $ key ] ?? $ default ; } }
721	public function money ( $ precision = null , $ scale = null ) { $ length = [ ] ; if ( $ precision !== null ) { $ length [ ] = $ precision ; } if ( $ scale !== null ) { $ length [ ] = $ scale ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_MONEY , $ length ) ; }
3925	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( is_array ( $ event -> getValue ( ) ) ) { $ values = [ ] ; foreach ( $ event -> getValue ( ) as $ value ) { $ values [ ] = 'value_' . $ value ; } $ event -> setValue ( $ values ) ; } else { $ event -> setValue ( 'value_' . $ event -> getValue ( ) ) ; } }
7053	public static function get_instance ( ) { if ( ! self :: $ instance instanceof self ) { $ new = new self ; $ new -> init ( ) ; self :: $ instance = $ new ; } return self :: $ instance ; }
9202	public function createBearerToken ( ) { $ bearerCredentials = $ this -> createBearerCredentials ( ) ; $ headers = array ( 'Authorization' => 'Basic ' . $ bearerCredentials , 'Content-Type' => 'application/x-www-form-urlencoded;charset=UTF-8' ) ; $ body = 'grant_type=client_credentials' ; $ data = $ this -> guzzleClient -> post ( Config :: get ( 'oauth2_token' ) , array ( 'headers' => $ headers , 'body' => $ body ) ) -> json ( ) ; $ this -> credentials -> setBearerToken ( $ data [ 'access_token' ] ) ; return $ this ; }
4531	public function process ( ContainerBuilder $ container ) { $ definition = $ container -> findDefinition ( LoaderCollection :: class ) ; $ services = $ container -> findTaggedServiceIds ( 'ds_tenant.loader' ) ; $ items = [ ] ; foreach ( $ services as $ id => $ tags ) { foreach ( $ tags as $ tag ) { $ items [ ] = [ 'id' => $ id , 'priority' => array_key_exists ( 'priority' , $ tag ) ? $ tag [ 'priority' ] : 0 , 'alias' => array_key_exists ( 'alias' , $ tag ) ? $ tag [ 'alias' ] : null ] ; } } usort ( $ items , function ( $ a , $ b ) { return $ a [ 'priority' ] === $ b [ 'priority' ] ? 0 : $ a [ 'priority' ] < $ b [ 'priority' ] ? - 1 : 1 ; } ) ; foreach ( $ items as $ item ) { if ( null !== $ item [ 'alias' ] ) { $ definition -> addMethodCall ( 'set' , [ $ item [ 'alias' ] , new Reference ( $ item [ 'id' ] ) ] ) ; } else { $ definition -> addMethodCall ( 'add' , [ new Reference ( $ item [ 'id' ] ) ] ) ; } } }
312	public function run ( ) { try { $ this -> state = self :: STATE_BEFORE_REQUEST ; $ this -> trigger ( self :: EVENT_BEFORE_REQUEST ) ; $ this -> state = self :: STATE_HANDLING_REQUEST ; $ response = $ this -> handleRequest ( $ this -> getRequest ( ) ) ; $ this -> state = self :: STATE_AFTER_REQUEST ; $ this -> trigger ( self :: EVENT_AFTER_REQUEST ) ; $ this -> state = self :: STATE_SENDING_RESPONSE ; $ response -> send ( ) ; $ this -> state = self :: STATE_END ; return $ response -> exitStatus ; } catch ( ExitException $ e ) { $ this -> end ( $ e -> statusCode , isset ( $ response ) ? $ response : null ) ; return $ e -> statusCode ; } }
5033	public function extract ( $ value ) { if ( ! $ value instanceof FileInterface ) { return null ; } $ tmp = tempnam ( sys_get_temp_dir ( ) , 'yk-copy.' ) ; $ out = fopen ( $ tmp , 'w' ) ; $ in = $ value -> getResource ( ) ; register_shutdown_function ( function ( $ filename ) { @ unlink ( $ filename ) ; } , $ tmp ) ; while ( ! feof ( $ in ) ) { fputs ( $ out , fgets ( $ in , 1024 ) ) ; } fclose ( $ in ) ; fclose ( $ out ) ; $ return = [ "file" => $ tmp ] ; foreach ( [ 'user' , 'name' , 'type' ] as $ key ) { $ v = $ value -> { "get$key" } ( ) ; if ( $ v ) { $ return [ $ key ] = $ v ; } } return $ return ; }
7734	private function isHydraOperation ( \ ReflectionMethod $ method ) { $ annotation = $ this -> annotationReader -> getMethodAnnotation ( $ method , 'ML\HydraBundle\Mapping\Operation' ) ; return null !== $ annotation ; }
1857	public function fopen ( $ strFile , $ strMode ) { $ this -> validate ( $ strFile ) ; return fopen ( $ this -> strRootDir . '/' . $ strFile , $ strMode ) ; }
12820	public function execute ( callable $ callback , array $ vars ) : Response { $ arguments = $ this -> resolveDependencies ( $ callback , $ vars ) ; return call_user_func_array ( $ callback , $ arguments ) ; }
9212	protected function existsOrCreate ( $ file ) { if ( ! file_exists ( $ file ) ) { $ this -> out ( '<info>Creating empty seed file: ' . $ this -> shortPath ( $ file ) . '</info>' ) ; file_put_contents ( $ file , <<<'EOD'<?php/** * BasicSeed plugin data seed file. */namespace App\Config\BasicSeed;use Cake\ORM\TableRegistry;// Write your data import statements here.$data = [ 'TableName' => [ //'_truncate' => true, //'_entityOptions' => [ // 'validate' => false, //], //'_saveOptions' => [ // 'checkRules' => false, //], '_defaults' => [], [ 'id' => 1, 'name' => 'record 1', ], ],];$this->importTables($data);EOD ) ; } }
6885	public function lookupPostcodeAddresses ( $ postcode ) { $ path = self :: PATH_LOOKUP_POSTCODE ; $ response = $ this -> httpGet ( $ path , [ 'postcode' => $ postcode ] ) ; return Response \ AddressList :: buildFromResponse ( $ response ) ; }
11134	protected function calculateSELECT ( ) { $ this -> query .= 'SELECT ' ; if ( $ this -> distinct ) { $ this -> query .= ' DISTINCT ' ; } $ this -> queryStringFromArray ( 'selects' , '' , ', ' ) ; $ this -> queryStringFromArray ( 'tables' , ' FROM ' , ', ' ) ; $ this -> joinStringFromArray ( 'joins' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'groupBys' , ' GROUP BY ' , ', ' ) ; $ this -> conditionStringFromArray ( 'havings' , ' HAVING ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } if ( $ this -> offset ) { $ this -> query .= ' OFFSET ' . $ this -> offset ; } }
5124	private function castToArray ( $ input ) : array { $ result = array ( ) ; foreach ( $ input as $ key => $ value ) { $ result [ $ key ] = $ this -> castValue ( $ value ) ; } return $ result ; }
4060	public static function compare ( $ expected , $ actual , $ strict = true ) { try { self :: calculateDiff ( $ expected , $ actual , $ strict ) ; } catch ( \ Exception $ exception ) { $ instance = new DifferentValuesException ( $ expected , $ actual , $ strict , 'The values differ.' , 0 , $ exception ) ; throw $ instance ; } }
637	public function truncateTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> truncateTable ( $ table ) ; return $ this -> setSql ( $ sql ) ; }
10080	public static function getCurrencyCode ( ) { if ( ! empty ( self :: $ currencyCode ) ) { return self :: $ currencyCode ; } self :: $ currencyCode = '$' ; $ localeconv = localeconv ( ) ; if ( ! empty ( $ localeconv [ 'currency_symbol' ] ) ) { self :: $ currencyCode = $ localeconv [ 'currency_symbol' ] ; return self :: $ currencyCode ; } if ( ! empty ( $ localeconv [ 'int_curr_symbol' ] ) ) { self :: $ currencyCode = $ localeconv [ 'int_curr_symbol' ] ; return self :: $ currencyCode ; } return self :: $ currencyCode ; }
5508	public function returnsByReference ( $ method , & $ reference , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return reference' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleByReference ( $ reference ) ) ; }
7813	public static function toGregorianStr ( $ j_date , $ sep = '/' ) { $ arr = explode ( $ sep , $ j_date ) ; if ( count ( $ arr ) < 3 || intval ( $ arr [ 0 ] ) == 0 ) return "" ; else $ g_date = jDateTime :: toGregorian ( $ arr [ 2 ] , $ arr [ 1 ] , $ arr [ 0 ] ) ; return implode ( $ sep , $ g_date ) ; }
2821	protected function _beforeSave ( ) { parent :: _beforeSave ( ) ; if ( ! $ this -> getId ( ) ) { $ this -> setToken ( $ this -> generateToken ( ) ) ; $ this -> setHttpMethod ( $ this -> getController ( ) -> getHttpMethod ( ) ) ; $ this -> setResponseCode ( $ this -> getController ( ) -> getResponseCode ( ) ) ; $ this -> setIp ( $ this -> getController ( ) -> getRemoteIp ( ) ) ; } $ this -> setRequestPath ( $ this -> getController ( ) -> getRequestOriginalPath ( ) ) ; $ this -> setSessionId ( $ this -> getController ( ) -> getSessionId ( ) ) ; $ this -> setInfo ( $ this -> getSerializedInfo ( ) ) ; return $ this ; }
1820	public function extractVimeoId ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> vimeo != $ varValue ) { $ matches = array ( ) ; if ( preg_match ( '%vimeo\.com/(?:channels/(?:\w+/)?|groups/(?:[^/]+)/videos/|album/(?:\d+)/video/)?(\d+)(?:$|/|\?)%i' , $ varValue , $ matches ) ) { $ varValue = $ matches [ 1 ] ; } } return $ varValue ; }
11795	public function setAttachment ( $ file = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } if ( is_array ( $ file ) ) { foreach ( $ file as $ _f ) { if ( file_exists ( $ _f ) ) { $ this -> attachment [ ] = $ _f ; } } } else { if ( file_exists ( $ file ) ) { $ this -> attachment [ ] = $ file ; } } return $ this ; }
7981	public function getSessionFilesProperties ( $ sessId , $ fileId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionFilesProperties ( $ this -> pp , $ this -> sn , $ sessId , $ fileId ) ) ; }
5020	public function getFieldFlags ( $ field ) { if ( ! $ this -> hasField ( $ field ) ) { return [ ] ; } if ( ! isset ( $ this -> fields [ $ field ] [ '__flags__' ] ) ) { $ this -> fields [ $ field ] [ '__flags__' ] = $ this -> copyArrayValues ( $ this -> fields [ $ field ] , [ 'flags' => [ ] , 'order' => [ 'priority' ] , 'priority' ] ) ; } return $ this -> fields [ $ field ] [ '__flags__' ] ; }
3341	public function getFileList ( $ options = array ( ) ) { $ options = array_replace ( array ( 'from' => null , 'to' => null , 'limit' => null , 'request_limit' => null , 'stored' => $ this -> defaultFilters [ 'file' ] [ 'stored' ] , 'removed' => $ this -> defaultFilters [ 'file' ] [ 'removed' ] , 'reversed' => false , ) , $ options ) ; if ( ! empty ( $ options [ 'from' ] ) && ! empty ( $ options [ 'to' ] ) ) { throw new \ Exception ( 'Only one of "from" and "to" arguments is allowed' ) ; } $ options [ 'from' ] = self :: dateTimeString ( $ options [ 'from' ] ) ; $ options [ 'to' ] = self :: dateTimeString ( $ options [ 'to' ] ) ; foreach ( $ this -> defaultFilters [ 'file' ] as $ k => $ v ) { if ( ! is_null ( $ options [ $ k ] ) ) { $ options [ $ k ] = self :: booleanString ( $ options [ $ k ] ) ; } } return new FileIterator ( $ this , $ options ) ; }
11571	public function onBlockEditing ( BlockEditingEvent $ event ) { $ encodedBlock = $ event -> getFileContent ( ) ; $ htmlBlock = $ this -> pageProductionRenderer -> renderBlock ( $ encodedBlock ) ; $ this -> permalinkManager -> add ( $ event -> getFilePath ( ) , $ htmlBlock ) -> save ( ) ; }
10622	public static function forThe ( MapsObjectsByIdentity $ mapped , string ... $ allowedClasses ) : MapsObjectsByIdentity { foreach ( $ mapped -> objects ( ) as $ object ) { if ( Whitelist :: doesNotHave ( $ object , $ allowedClasses ) ) { $ mapped = $ mapped -> removeThe ( $ object ) ; } } return new Whitelist ( $ allowedClasses , $ mapped ) ; }
5184	private function lookUp ( array $ articleConstant ) : array { $ copyListAttributes = $ this -> listAttributes ; return array_map ( function ( $ singleConst ) use ( $ copyListAttributes ) { $ res = $ copyListAttributes [ $ singleConst ] ; return array_map ( function ( $ str ) use ( $ singleConst ) { return $ singleConst . $ str ; } , $ res ) ; } , $ articleConstant ) ; }
10571	protected function validateCache ( $ lastModified , $ etag ) { if ( isset ( $ _SERVER [ 'HTTP_IF_NONE_MATCH' ] ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getEtags ( ) , true ) ; } elseif ( isset ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) ) { return $ lastModified !== null && @ strtotime ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) >= $ lastModified ; } else { return $ etag === null && $ lastModified === null ; } }
11155	public function getValueByPowers ( array $ values , array $ powers ) { if ( empty ( $ values ) || empty ( $ powers ) || \ count ( $ values ) !== \ count ( $ powers ) ) { throw new InvalidArgumentException ( 'Empty parameter or count not equal' ) ; } $ values = \ array_values ( $ values ) ; $ powers = \ array_values ( $ powers ) ; $ rolledIndex = $ this -> getArrayKeyByPowers ( $ powers ) ; return $ values [ $ rolledIndex ] ; }
9605	public function vectorTripleProduct ( self $ b , self $ c ) { return $ this -> crossProduct ( $ b -> crossProduct ( $ c ) ) ; }
5445	protected function addSkipping ( ) { $ this -> mapHandler ( 'css' , 'ignore' ) ; $ this -> addEntryPattern ( '<style' , 'text' , 'css' ) ; $ this -> addExitPattern ( '</style>' , 'css' ) ; $ this -> mapHandler ( 'js' , 'ignore' ) ; $ this -> addEntryPattern ( '<script' , 'text' , 'js' ) ; $ this -> addExitPattern ( '</script>' , 'js' ) ; $ this -> mapHandler ( 'comment' , 'ignore' ) ; $ this -> addEntryPattern ( '<!--' , 'text' , 'comment' ) ; $ this -> addExitPattern ( ' , 'comment' ) ; }
6946	private function getRegularDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; return $ qb -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ ex -> eq ( 'o.shipmentState' , ':shipped' ) , $ ex -> isNull ( 'o.paymentTerm' ) ) ) -> addOrderBy ( 'o.createdAt' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'shipped' , ShipmentStates :: STATE_COMPLETED ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; }
12752	public function sendConfirmationMessage ( User $ user , Token $ token ) { return $ this -> sendMessage ( $ user -> email , $ this -> confirmationSubject , 'confirmation' , [ 'user' => $ user , 'token' => $ token ] ) ; }
6902	public function url ( $ page = 1 ) { $ page = max ( 1 , ( int ) $ page ) ; if ( $ page === 1 AND ! $ this -> first_page_in_url ) { $ page = NULL ; } switch ( $ this -> current_page_source ) { case 'query_string' : case 'mixed' : return URL :: site ( $ this -> request -> uri ( ) . $ this -> query ( [ $ this -> current_page_source_key => $ page ] ) ) ; case 'route' : return URL :: site ( $ this -> route -> url ( array_merge ( $ this -> route_params , array ( $ this -> current_page_source_key => $ page ) ) ) . $ this -> query ( ) ) ; } return '#' ; }
3980	private function getCommandInstance ( CommandCollectionInterface $ collection , $ operationName ) { if ( $ collection -> hasCommandNamed ( $ operationName ) ) { $ command = $ collection -> getCommandNamed ( $ operationName ) ; } else { switch ( $ operationName ) { case 'cut' : $ command = new CutCommand ( ) ; break ; case 'copy' : $ command = new CopyCommand ( ) ; break ; default : $ command = new Command ( ) ; } $ command -> setName ( $ operationName ) ; $ collection -> addCommand ( $ command ) ; } return $ command ; }
7103	public static function query ( array $ params = null , $ use_get = null ) { if ( $ use_get ) { if ( $ params === NULL ) { $ params = $ _GET ; } else { $ params = Arr :: merge ( $ _GET , $ params ) ; } } if ( empty ( $ params ) ) { return '' ; } $ query = http_build_query ( $ params , '' , '&' ) ; return ( $ query === '' ) ? '' : ( '?' . $ query ) ; }
11994	public function pipe ( $ data , $ index , $ isHeader = false ) { $ this -> lastIndex ++ ; $ this -> data [ $ this -> lastIndex ] = $ data ; }
10201	private function writeCellMerge ( XMLWriter $ objWriter , Cell $ cell ) { if ( ! $ cell -> isMergeRangeValueCell ( ) ) { return ; } $ mergeRange = Coordinate :: splitRange ( $ cell -> getMergeRange ( ) ) ; list ( $ startCell , $ endCell ) = $ mergeRange [ 0 ] ; $ start = Coordinate :: coordinateFromString ( $ startCell ) ; $ end = Coordinate :: coordinateFromString ( $ endCell ) ; $ columnSpan = Coordinate :: columnIndexFromString ( $ end [ 0 ] ) - Coordinate :: columnIndexFromString ( $ start [ 0 ] ) + 1 ; $ rowSpan = $ end [ 1 ] - $ start [ 1 ] + 1 ; $ objWriter -> writeAttribute ( 'table:number-columns-spanned' , $ columnSpan ) ; $ objWriter -> writeAttribute ( 'table:number-rows-spanned' , $ rowSpan ) ; }
1096	protected function scopedAttributes ( $ node ) { $ keys = $ this -> node -> getScopedColumns ( ) ; if ( count ( $ keys ) == 0 ) return array ( ) ; $ values = array_map ( function ( $ column ) use ( $ node ) { return $ node -> getAttribute ( $ column ) ; } , $ keys ) ; return array_combine ( $ keys , $ values ) ; }
5730	public function getButtonHTML ( ) { $ html = '<div class="btn-group" role="group">' ; $ params = array ( 'q' => ( array ) $ this -> gridFieldRequest -> getRequest ( ) -> getVar ( 'q' ) ) ; $ searchVars = ( bool ) $ params ? '?' . http_build_query ( $ params ) : '' ; $ previousRecordID = $ this -> gridFieldRequest -> getPreviousRecordID ( ) ; $ cssClass = $ previousRecordID ? "cms-panel-link" : "disabled" ; $ prevLink = $ previousRecordID ? Controller :: join_links ( $ this -> gridFieldRequest -> gridField -> Link ( ) , "item" , $ previousRecordID . $ searchVars ) : "javascript:void(0);" ; $ linkTitle = $ previousRecordID ? _t ( 'GridFieldBetterButtons.PREVIOUSRECORD' , 'Go to the previous record' ) : "" ; $ linkText = $ previousRecordID ? _t ( 'GridFieldBetterButtons.PREVIOUS' , 'Previous' ) : "" ; $ html .= sprintf ( "<a class='ss-ui-button btn btn-default gridfield-better-buttons-prevnext gridfield-better-buttons-prev %s' href='%s' title='%s'><img src='" . BETTER_BUTTONS_DIR . "/images/prev.png' alt='previous' /> %s</a>" , $ cssClass , $ prevLink , $ linkTitle , $ linkText ) ; $ nextRecordID = $ this -> gridFieldRequest -> getNextRecordID ( ) ; $ cssClass = $ nextRecordID ? "cms-panel-link" : "disabled" ; $ nextLink = $ nextRecordID ? Controller :: join_links ( $ this -> gridFieldRequest -> gridField -> Link ( ) , "item" , $ nextRecordID . $ searchVars ) : "javascript:void(0);" ; $ linkTitle = $ nextRecordID ? _t ( 'GridFieldBetterButtons.NEXTRECORD' , 'Go to the next record' ) : "" ; $ linkText = $ nextRecordID ? _t ( 'GridFieldBetterButtons.NEXT' , 'Next' ) : "" ; $ html .= sprintf ( "<a class='ss-ui-button btn btn-default gridfield-better-buttons-prevnext gridfield-better-buttons-next %s' href='%s' title='%s'>%s <img src='" . BETTER_BUTTONS_DIR . "/images/next.png' alt='next' /></a>" , $ cssClass , $ nextLink , $ linkTitle , $ linkText ) ; $ html .= '</div>' ; return $ html ; }
2748	private function extractMapping ( $ mapping , $ countryCode ) { $ final = null ; $ extractMapping = json_decode ( $ mapping , true ) ; if ( ! $ extractMapping ) { try { $ extractMapping = unserialize ( $ mapping ) ; } catch ( \ Exception $ e ) { $ extractMapping = [ ] ; } } if ( is_array ( $ extractMapping ) ) { $ countryId = 'country_id' ; $ key = 'store_id' ; foreach ( $ extractMapping as $ map ) { if ( is_array ( $ map ) && isset ( $ map [ $ countryId ] ) && strtolower ( str_replace ( ' ' , '' , $ map [ $ countryId ] ) ) == strtolower ( $ countryCode ) ) { if ( isset ( $ map [ $ key ] ) ) { return ( int ) $ map [ $ key ] ; } } elseif ( is_array ( $ map ) && isset ( $ map [ $ countryId ] ) && $ map [ $ countryId ] == '*' && isset ( $ map [ $ key ] ) && $ final === null ) { $ final = ( int ) $ map [ $ key ] ; } } } return $ final ; }
1985	public function getOptionsForUser ( BackendUser $ user ) : array { $ this -> loadOptions ( ) ; if ( $ user -> isAdmin ) { $ event = new ImageSizesEvent ( $ this -> options , $ user ) ; } else { $ options = array_map ( static function ( $ val ) { return is_numeric ( $ val ) ? ( int ) $ val : $ val ; } , StringUtil :: deserialize ( $ user -> imageSizes , true ) ) ; $ event = new ImageSizesEvent ( $ this -> filterOptions ( $ options ) , $ user ) ; } $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_USER , $ event ) ; return $ event -> getImageSizes ( ) ; }
9660	public static function identify ( $ pFilename ) { $ reader = self :: createReaderForFile ( $ pFilename ) ; $ className = get_class ( $ reader ) ; $ classType = explode ( '\\' , $ className ) ; unset ( $ reader ) ; return array_pop ( $ classType ) ; }
2606	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItemId = $ this -> getRequest ( ) -> getParam ( 'acl_item_id' ) ; $ deleteItem = $ this -> api -> deleteAclItem ( $ aclId , $ aclItemId ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11290	protected function _getModels ( $ attributeName , $ relatedObjName = false , $ query = false , $ loadMap = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = [ ] ; if ( $ relatedObjName ) { if ( isset ( $ def [ 'via' ] ) ) { $ result = $ this -> _getModelsFromTableColumn ( $ attributeName , $ relatedObjName , $ def [ 'via' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'using' ] ) ) { $ result = $ this -> getModelsFromCustomRelationship ( $ attributeName , $ relatedObjName , $ query , $ loadMap ) ; } else { $ result = $ this -> _getModelsFromRelationTable ( $ attributeName , $ relatedObjName , $ query , $ loadMap ) ; } } if ( $ result == null ) { $ this -> $ attributeName = new \ Cora \ Collection ( ) ; $ result = $ this -> model_data [ $ attributeName ] ; } return $ result ; }
3917	protected function sortByRandom ( ) { $ arrFiles = $ this -> foundFiles ; $ arrSource = $ this -> outputBuffer ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } $ keys = array_keys ( $ arrFiles ) ; $ files = array ( ) ; shuffle ( $ keys ) ; foreach ( $ keys as $ key ) { $ files [ $ key ] = $ arrFiles [ $ key ] ; } return $ this -> remapSorting ( $ files , $ arrSource ) ; }
12885	public function getReverseKeyTranslation ( $ localObject ) { $ key = is_object ( $ localObject ) ? $ localObject -> primaryKey : $ localObject ; if ( $ this -> settings [ 'universalKey' ] ) { return KeyTranslation :: find ( ) -> where ( [ 'registry_id' => $ key ] ) -> one ( ) ; } else { return KeyTranslation :: find ( ) -> where ( [ 'registry_id' => $ key , 'data_interface_id' => $ this -> module -> collectorItem -> interfaceObject -> primaryKey ] ) -> one ( ) ; } }
5765	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ administrators = $ this -> administratorsEntityMapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) , null , $ this -> authentication , $ this -> authorization ) ; } catch ( QueryFailureException $ e ) { $ administrators = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ administrators ) ; }
6481	private function createDefaultResponseContentNegotiationResult ( string $ type , ? string $ language , array $ acceptCharsetHeaders ) : ContentNegotiationResult { $ selectedMediaTypeFormatter = null ; foreach ( $ this -> mediaTypeFormatters as $ mediaTypeFormatter ) { if ( $ mediaTypeFormatter -> canWriteType ( $ type ) ) { $ selectedMediaTypeFormatter = $ mediaTypeFormatter ; break ; } } if ( $ selectedMediaTypeFormatter === null ) { return new ContentNegotiationResult ( null , null , null , $ language ) ; } $ encoding = $ this -> encodingMatcher -> getBestEncodingMatch ( $ selectedMediaTypeFormatter , $ acceptCharsetHeaders , null ) ; return new ContentNegotiationResult ( $ selectedMediaTypeFormatter , $ selectedMediaTypeFormatter -> getDefaultMediaType ( ) , $ encoding , $ language ) ; }
7364	protected function updateInvoiceTotal ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return false ; } $ changed = false ; $ invoice = $ this -> invoiceCalculator -> calculateInvoiceTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ invoice , $ sale -> getInvoiceTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setInvoiceTotal ( $ invoice ) ; $ changed = true ; } $ credit = $ this -> invoiceCalculator -> calculateCreditTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ credit , $ sale -> getCreditTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setCreditTotal ( $ credit ) ; $ changed = true ; } return $ changed ; }
8856	public function increase ( ) { $ this -> retries ++ ; if ( $ this -> retries > $ this -> maxRetries ) { throw new MaxRetriesExceededException ( sprintf ( 'Max allowed retries exceeded. Allowed: %s. Tried: %s.' , $ this -> maxRetries , $ this -> retries ) ) ; } return $ this ; }
252	public function removeAllFlashes ( ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; foreach ( array_keys ( $ counters ) as $ key ) { unset ( $ _SESSION [ $ key ] ) ; } unset ( $ _SESSION [ $ this -> flashParam ] ) ; }
4889	public function viewAction ( Request $ request , $ id ) { $ pageManager = $ this -> getPageManager ( ) ; $ page = $ pageManager -> findForView ( $ id ) ; if ( null !== ( $ validator = $ this -> getViewActionValidator ( ) ) ) { $ validator -> validate ( $ page ) ; } if ( $ page instanceof ControllerPageInterface ) { return $ this -> forward ( $ page -> getController ( ) , ( array ) $ page -> getControllerParameters ( ) + array ( 'parameters' => $ request -> query -> all ( ) , '_locale' => $ request -> attributes -> get ( '_locale' ) , '_internal_url' => $ request -> attributes -> get ( '_internal_url' ) , ) , $ request -> query -> all ( ) ) ; } return $ this -> renderPage ( $ page ) ; }
8248	public function checkPasswordPolicy ( Password $ password ) { $ result = true ; $ policy = $ this -> picoAuth -> getContainer ( ) -> get ( "PasswordPolicy" ) ; $ maxAllowedLen = $ this -> getPasswordEncoder ( ) -> getMaxAllowedLen ( ) ; if ( is_int ( $ maxAllowedLen ) && strlen ( $ password ) > $ maxAllowedLen ) { $ this -> session -> addFlash ( "error" , "Maximum length is {$maxAllowedLen}." ) ; $ result = false ; } if ( ! $ policy -> check ( $ password ) ) { $ errors = $ policy -> getErrors ( ) ; foreach ( $ errors as $ error ) { $ this -> session -> addFlash ( "error" , $ error ) ; } return false ; } return $ result ; }
6765	protected function handleUpdate ( SaleInterface $ sale ) { $ changed = false ; $ changed |= $ this -> updateNumber ( $ sale ) ; $ changed |= $ this -> updateKey ( $ sale ) ; $ changed |= $ this -> updateInformation ( $ sale , true ) ; if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'vatNumber' ) ) { $ changed |= $ this -> pricingUpdater -> updateVatNumberSubject ( $ sale ) ; } if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'customer' ) ) { $ changed |= $ this -> saleUpdater -> updatePaymentTerm ( $ sale ) ; } if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'shipmentMethod' , 'customerGroup' ] ) ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; } if ( $ this -> isDiscountUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateDiscounts ( $ sale , true ) ; } if ( $ this -> isTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateTaxation ( $ sale , true ) ; } elseif ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } return $ changed ; }
10416	protected function addStatusField ( Table $ table ) { if ( empty ( $ this -> shops ) ) { $ table -> addColumn ( 'status' , 'boolean' , [ 'default' => 0 ] ) -> setComment ( '0-new,1-done' ) ; $ table -> addIndex ( [ 'status' ] ) ; } else { foreach ( $ this -> shops as $ shop ) { $ fieldName = "status_{$shop}" ; $ table -> addColumn ( $ fieldName , 'boolean' , [ 'default' => 0 ] ) -> setComment ( '0-new,1-done' ) ; $ table -> addIndex ( [ $ fieldName ] ) ; } } }
10822	public static function block ( $ messages , $ style ) { if ( is_string ( $ messages ) ) { $ messages = [ $ messages ] ; } if ( count ( $ messages ) > 0 ) { self :: writeln ( str_repeat ( ' ' , self :: $ lineLength ) , $ style ) ; foreach ( $ messages as $ message ) { $ message = ' ' . $ message ; while ( strlen ( $ message ) < self :: $ lineLength ) { $ message .= ' ' ; } self :: writeln ( $ message , $ style ) ; } self :: writeln ( str_repeat ( ' ' , self :: $ lineLength ) , $ style ) ; } }
5942	public function readLine ( $ token = "\n" ) { $ this -> connect ( ) ; $ line = StringHelper :: factory ( "" ) ; while ( ! $ line -> endsWith ( $ token ) ) { $ this -> waitForReadyRead ( ) ; $ data = @ fgets ( $ this -> stream , 4096 ) ; Signal :: getInstance ( ) -> emit ( strtolower ( $ this -> getAdapterType ( ) ) . "DataRead" , $ data ) ; if ( $ data === false ) { if ( $ line -> count ( ) ) { $ line -> append ( $ token ) ; } else { throw new Ts3Exception ( "connection to server '" . $ this -> config [ "host" ] . ":" . $ this -> config [ "port" ] . "' lost" ) ; } } else { $ line -> append ( $ data ) ; } } return $ line -> trim ( ) ; }
5569	public function delete ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } return $ this -> load ( $ url , new SimpleDeleteEncoding ( $ parameters ) ) ; }
12869	public function bind ( $ sUser , $ sPassword ) : Ldap { return $ this -> _bConnected = ldap_bind ( $ this -> _rConnect , $ sUser , $ sPassword ) ; return $ this ; }
678	protected function detectSearchAttributeType ( Validator $ validator ) { if ( $ validator instanceof BooleanValidator ) { return self :: TYPE_BOOLEAN ; } if ( $ validator instanceof NumberValidator ) { return $ validator -> integerOnly ? self :: TYPE_INTEGER : self :: TYPE_FLOAT ; } if ( $ validator instanceof StringValidator ) { return self :: TYPE_STRING ; } if ( $ validator instanceof EachValidator ) { return self :: TYPE_ARRAY ; } if ( $ validator instanceof DateValidator ) { if ( $ validator -> type == DateValidator :: TYPE_DATETIME ) { return self :: TYPE_DATETIME ; } if ( $ validator -> type == DateValidator :: TYPE_TIME ) { return self :: TYPE_TIME ; } return self :: TYPE_DATE ; } }
11634	public function bindPage ( array $ deviceIdentifier , array $ pageIds ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'page_ids' => $ pageIds , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_BINDPAGE , $ params ] ) ; }
3705	public function handle ( CreateMetaModelEvent $ event ) { if ( null === $ metaModel = $ event -> getMetaModel ( ) ) { return ; } foreach ( $ this -> attributeFactory -> createAttributesForMetaModel ( $ metaModel ) as $ attribute ) { $ metaModel -> addAttribute ( $ attribute ) ; } }
12566	public function sendVideo ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VIDEO , $ message , $ to ) ; }
6380	public function readAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'quiz_attempts' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/quiz/attempt.php?attempt=' . $ id ; $ model -> name = 'Attempt ' . $ id ; return $ model ; }
6787	protected function fixDefault ( CustomerGroupInterface $ customerGroup ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ customerGroup , [ 'default' ] ) ) { return ; } if ( $ customerGroup -> isDefault ( ) ) { try { $ previousGroup = $ this -> customerGroupRepository -> findDefault ( ) ; } catch ( RuntimeException $ e ) { return ; } if ( $ previousGroup === $ customerGroup ) { return ; } $ previousGroup -> setDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ previousGroup , false ) ; } }
9551	public function setOrderBy ( $ order_by , $ order = null ) { $ this -> order_by = $ order_by ; $ this -> order = $ order ; return $ this ; }
8986	public function get_columns ( ) { return array ( 'id' => new IntegerBased ( 'BIGINT' , 'id' , array ( 'NOT NULL' , 'auto_increment' ) , array ( 20 ) ) , 'message' => new StringBased ( 'VARCHAR' , 'message' , array ( ) , array ( 255 ) ) , 'level' => new StringBased ( 'VARCHAR' , 'level' , array ( ) , array ( 20 ) ) , 'lgroup' => new StringBased ( 'VARCHAR' , 'lgroup' , array ( ) , array ( 20 ) ) , 'time' => new DateTime ( 'time' ) , 'user' => new ForeignUser ( 'user' ) , 'ip' => new StringBased ( 'VARCHAR' , 'ip' , array ( ) , array ( 45 ) ) , 'exception' => new StringBased ( 'VARCHAR' , 'exception' , array ( ) , array ( 255 ) ) , 'trace' => new StringBased ( 'LONGTEXT' , 'trace' ) , 'context' => new StringBased ( 'LONGTEXT' , 'context' ) , ) ; }
7408	public function merge ( $ ta ) : self { $ this -> _massageBlockInput ( $ in ) ; $ ret = clone $ this ; foreach ( $ ta as $ k => $ v ) { if ( is_int ( $ k ) ) { $ ret [ ] = $ v ; } else { $ ret [ $ k ] = $ v ; } } return $ ret ; }
12177	public function addArgument ( ArgumentInterface $ argument ) { $ this -> argumentPositions [ $ argument -> getPosition ( ) ] = $ argument ; $ this -> argumentNames [ $ argument -> getName ( ) ] = $ argument ; if ( $ argument -> isClass ( ) ) { $ this -> argumentClasses [ $ argument -> getClass ( ) ] = $ argument ; } return $ argument ; }
12113	public function getUnmappedForeignKeys ( ) { $ mappedForeign = ArrayHelper :: getColumn ( $ this -> _map , 'foreignKey' ) ; $ u = array_diff ( array_keys ( $ this -> foreignModel -> meta -> schema -> columns ) , $ mappedForeign ) ; unset ( $ u [ $ this -> foreignPrimaryKeyName ] ) ; return $ u ; }
8815	public function get ( $ key = null , $ filter = false ) { if ( is_null ( $ key ) ) { return $ _GET ; } $ value = ( isset ( $ _GET [ $ key ] ) ? $ _GET [ $ key ] : null ) ; return $ this -> filter ( $ value , $ filter ) ; }
1034	private function completeListValue ( ListOfType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ itemType = $ returnType -> getWrappedType ( ) ; Utils :: invariant ( is_array ( $ result ) || $ result instanceof Traversable , 'User Error: expected iterable, but did not find one for field ' . $ info -> parentType . '.' . $ info -> fieldName . '.' ) ; $ containsPromise = false ; $ i = 0 ; $ completedItems = [ ] ; foreach ( $ result as $ item ) { $ fieldPath = $ path ; $ fieldPath [ ] = $ i ++ ; $ completedItem = $ this -> completeValueCatchingError ( $ itemType , $ fieldNodes , $ info , $ fieldPath , $ item ) ; if ( ! $ containsPromise && $ this -> getPromise ( $ completedItem ) ) { $ containsPromise = true ; } $ completedItems [ ] = $ completedItem ; } return $ containsPromise ? $ this -> exeContext -> promises -> all ( $ completedItems ) : $ completedItems ; }
8689	private static function doFlatten ( $ iterable , $ depth , callable $ predicate , array $ result = [ ] ) { foreach ( $ iterable as $ item ) { if ( $ depth >= 1 && $ predicate ( $ item ) ) { $ result = static :: doFlatten ( $ item , $ depth - 1 , $ predicate , $ result ) ; } else { $ result [ ] = $ item ; } } return $ result ; }
1146	public function addConditionalRules ( $ attribute , $ rules = [ ] ) { foreach ( ( array ) $ attribute as $ key ) { $ current = isset ( $ this -> conditional [ $ key ] ) ? $ this -> conditional [ $ key ] : [ ] ; $ merge = head ( $ this -> validator -> explodeRules ( ( array ) $ rules ) ) ; $ this -> conditional [ $ key ] = array_merge ( $ current , $ merge ) ; } }
2506	public static function exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , $ xpath ) { WsdlAnalyser :: loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) ; return self :: $ wsdlDomXpath [ $ wsdlId ] -> evaluate ( $ xpath ) ; }
3899	public function setDataFor ( $ arrValues ) { $ strTable = $ this -> getMetaModel ( ) -> getTableName ( ) ; $ strColName = $ this -> getColName ( ) ; foreach ( $ arrValues as $ intId => $ varData ) { if ( is_array ( $ varData ) ) { $ varData = serialize ( $ varData ) ; } $ this -> connection -> update ( $ strTable , [ $ strColName => $ varData ] , [ 'id' => $ intId ] ) ; } }
9048	private function renderFields ( $ rendered , $ fields ) { foreach ( $ fields as $ field ) { if ( ! isset ( $ field [ 'name' ] ) ) { throw new ControlException ( "Field must have at least a name!" ) ; } $ fieldType = isset ( $ field [ 'type' ] ) ? $ field [ 'type' ] : 'text' ; $ id = isset ( $ field [ 'id' ] ) ? $ field [ 'id' ] : $ field [ 'name' ] ; $ class = isset ( $ field [ 'class' ] ) ? $ field [ 'class' ] : $ field [ 'name' ] ; $ rendered .= sprintf ( '<input type="%s" id="%s" class="%s" name="%s"/>' , $ fieldType , $ id , $ class , $ field [ 'name' ] ) ; } return $ rendered ; }
6694	public static function applyActive ( & $ Nav ) { if ( $ Nav ) { foreach ( $ Nav as & $ one ) { if ( isset ( $ one [ 'items' ] ) ) { self :: applyActive ( $ one [ 'items' ] ) ; } if ( ! isset ( $ one [ 'active' ] ) ) { if ( is_array ( $ one [ 'url' ] ) ) { $ url = $ one [ 'url' ] [ 0 ] ; $ route = Yii :: $ app -> requestedRoute ; $ params = Yii :: $ app -> request -> getQueryParams ( ) ; if ( $ url === '/' && $ route === Yii :: $ app -> controller -> module -> id . '/dashboard/index' ) { $ one [ 'active' ] = true ; } else { $ url = $ one [ 'url' ] ; $ urlExploded = explode ( '/' , $ url [ 0 ] ) ; $ one [ 'submenuTemplate' ] = '' ; foreach ( self :: $ active as $ activeAction ) { $ urlExploded [ count ( $ urlExploded ) - 1 ] = $ activeAction ; $ url [ 0 ] = implode ( '/' , $ urlExploded ) ; $ one [ 'items' ] [ ] = [ 'label' => $ one [ 'label' ] . ' - ' . $ activeAction , 'url' => $ url , 'options' => [ 'class' => 'hidden' ] ] ; if ( '/' . Yii :: $ app -> request -> getQueryParam ( 'parentRoute' ) === trim ( $ url [ 0 ] ) ) { $ one [ 'items' ] [ ] = [ 'label' => $ one [ 'label' ] . ' - Sub List' , 'url' => array_merge ( [ '/' . $ route ] , $ params ) , 'options' => [ 'class' => 'hidden' ] ] ; } } } } } } } }
1090	public function reOrderBy ( $ column , $ direction = 'asc' ) { $ this -> orders = null ; if ( ! is_null ( $ column ) ) return $ this -> orderBy ( $ column , $ direction ) ; return $ this ; }
2373	public static function toHtml5 ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*) \/>/i' => '<$1$2>' , '/ (cellpadding|cellspacing|border)="[^"]*"/' => '' , '/ rel="lightbox(\[([^\]]+)\])?"/' => ' data-lightbox="$2"' ) ; $ arrStrReplace = array ( '<u>' => '<span style="text-decoration:underline">' , '</u>' => '</span>' , ' target="_self"' => '' , ' onclick="window.open(this.href); return false"' => ' target="_blank"' , ' onclick="window.open(this.href);return false"' => ' target="_blank"' , ' onclick="window.open(this.href); return false;"' => ' target="_blank"' ) ; $ strString = preg_replace ( array_keys ( $ arrPregReplace ) , $ arrPregReplace , $ strString ) ; $ strString = str_ireplace ( array_keys ( $ arrStrReplace ) , $ arrStrReplace , $ strString ) ; return $ strString ; }
8300	public function handleEvent ( $ eventName , array $ params ) { parent :: handleEvent ( $ eventName , $ params ) ; if ( $ this -> isEnabled ( ) ) { $ this -> picoAuthPlugin -> handleEvent ( $ eventName , $ params ) ; } }
7288	public function setColumnForLinksLabels ( $ columnNameOrClosure ) { if ( ! is_string ( $ columnNameOrClosure ) && ! ( $ columnNameOrClosure instanceof DbExpr ) ) { throw new \ InvalidArgumentException ( '$columnNameOrClosure argument must be a string or a closure' ) ; } $ this -> columnForLinksLabels = $ columnNameOrClosure ; return $ this ; }
4549	public function get ( string $ alias ) { $ stat = $ this -> statCollection -> filter ( function ( $ element ) use ( $ alias ) { return $ element -> getAlias ( ) === $ alias ; } ) -> first ( ) ; if ( ! $ stat ) { throw new InvalidAliasException ( 'Stat alias "' . $ alias . '" does not exist.' ) ; } $ datum = $ stat -> get ( ) ; return $ datum ; }
3780	protected function getFilteredAttribute ( ) { if ( ! ( $ attributeId = $ this -> get ( 'attr_id' ) ) ) { return null ; } if ( $ attribute = $ this -> getMetaModel ( ) -> getAttributeById ( $ attributeId ) ) { return $ attribute ; } return null ; }
1324	public static function decode ( $ string , $ asArray ) { if ( version_compare ( PHP_VERSION , '5.4.0' , '>=' ) && ! ( defined ( 'JSON_C_VERSION' ) && PHP_INT_SIZE > 4 ) ) { return json_decode ( $ string , $ asArray , 512 , JSON_BIGINT_AS_STRING ) ; } return json_decode ( $ string , $ asArray ) ; }
8459	public function getVersion ( ) { if ( empty ( $ this -> drushVersion ) ) { $ isPrinted = $ this -> isPrinted ; $ this -> isPrinted = false ; $ result = $ this -> executeCommand ( $ this -> executable . ' version' ) ; $ output = $ result -> getMessage ( ) ; $ this -> drushVersion = 'unknown' ; if ( preg_match ( '#[0-9.]+#' , $ output , $ matches ) ) { $ this -> drushVersion = $ matches [ 0 ] ; } $ this -> isPrinted = $ isPrinted ; } return $ this -> drushVersion ; }
5307	protected function getPathFromPolygon ( SimpleXMLElement $ polygon ) { $ points = $ this -> getValuesFromList ( $ polygon [ 'points' ] ) ; $ path = 'M' . array_shift ( $ points ) . ' ' . array_shift ( $ points ) ; while ( count ( $ points ) ) { $ path .= 'L' . array_shift ( $ points ) . ' ' . array_shift ( $ points ) ; } return $ path . 'Z' ; }
9606	public function multiplyByScalar ( $ scalar ) { $ result = [ ] ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ result [ $ i ] = $ component * $ scalar ; } return new static ( $ result ) ; }
589	protected function registerBundle ( $ bundles , $ name , & $ registered ) { if ( ! isset ( $ registered [ $ name ] ) ) { $ registered [ $ name ] = false ; $ bundle = $ bundles [ $ name ] ; foreach ( $ bundle -> depends as $ depend ) { $ this -> registerBundle ( $ bundles , $ depend , $ registered ) ; } unset ( $ registered [ $ name ] ) ; $ registered [ $ name ] = $ bundle ; } elseif ( $ registered [ $ name ] === false ) { throw new Exception ( "A circular dependency is detected for target '{$name}': " . $ this -> composeCircularDependencyTrace ( $ name , $ registered ) . '.' ) ; } }
4288	public function onError ( Event $ event ) { if ( $ event [ 'inConsole' ] || ! $ event [ 'isFirstOccur' ] ) { return ; } $ this -> processLogEntry ( 'errorNotConsoled' , array ( $ event [ 'typeStr' ] . ': ' . $ event [ 'file' ] . ' (line ' . $ event [ 'line' ] . '): ' . $ event [ 'message' ] ) , array ( 'channel' => 'phpError' , 'class' => $ event [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ? 'danger' : 'warning' , ) ) ; }
8958	public function validateResponse ( $ url , $ response ) { if ( $ response -> code != 200 ) { $ error = htmlspecialchars ( $ response -> body ) ; throw new \ DomainException ( $ error , $ response -> code ) ; } }
2577	protected function hasPricingOption ( $ optionKey , $ priceOptions ) { $ found = false ; foreach ( $ priceOptions as $ pog ) { if ( $ pog -> pricingOptionKey -> pricingOptionKey === $ optionKey ) { $ found = true ; } } return $ found ; }
3388	public function redirectAfterConfirmationPath ( ) { if ( method_exists ( $ this , 'redirectConfirmationTo' ) ) { return $ this -> redirectConfirmationTo ( ) ; } return property_exists ( $ this , 'redirectConfirmationTo' ) ? $ this -> redirectConfirmationTo : route ( 'login' ) ; }
10442	protected function getNewPipe ( ) { $ cmd = 'mysqlbinlog ' . escapeshellarg ( $ this -> logDir . '/' . $ this -> baseName ) . '.[0-9]*' ; if ( $ this -> from !== null ) { if ( $ this -> startType == self :: START_TYPE_DATE ) { $ cmd .= ' --start-datetime=' . escapeshellarg ( $ this -> from -> format ( 'Y-m-d H:i:s' ) ) ; } elseif ( $ this -> startType == self :: START_TYPE_POSITION ) { $ cmd .= ' --start-position=' . escapeshellarg ( $ this -> from ) ; } } $ cmd .= " --base64-output=DECODE-ROWS -v 2>&1 | grep -E '###|#[0-9]|Errcode|ERROR'" ; $ this -> pipe = popen ( $ cmd , 'r' ) ; if ( empty ( $ this -> pipe ) ) { throw new \ RuntimeException ( 'Error while executing mysqlbinlog' ) ; } }
127	public function ensureBinariesPresence ( PackageInterface $ package ) { $ this -> binaryInstaller -> installBinaries ( $ package , $ this -> getInstallPath ( $ package ) , false ) ; }
7316	public function setTimezone ( $ timezone ) { if ( is_string ( $ timezone ) ) { $ timezone = TimeZone :: parse ( $ timezone ) ; } else { if ( $ timezone instanceof TimeZone == false ) { throw new \ InvalidArgumentException ( ) ; } } $ jd = $ this -> toJD ( ) ; $ tzOffset = $ timezone -> offset ( $ jd ) - $ this -> timezone -> offset ( $ jd ) ; $ this -> add ( Time :: hours ( $ tzOffset ) ) ; $ this -> timezone = $ timezone ; $ this -> timezone0 = $ timezone ; return $ this ; }
9314	public function storageClearAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ dbAdapter = $ this -> getDbAdapter ( ) ; $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; try { $ table = new JobTable ( $ dbAdapter ) ; $ table -> truncate ( ) ; } catch ( \ Exception $ exception ) { $ console -> writeLine ( 'Truncating database table failed!' , ConsoleColor :: LIGHT_RED ) ; return ; } $ console -> writeLine ( 'Storage was successfully cleared!' , ConsoleColor :: LIGHT_GREEN ) ; }
2220	public static function findPublishedDefaultByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.source='default'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
2064	public function checkFeedAlias ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == $ dc -> value || $ varValue == '' ) { return $ varValue ; } $ varValue = Contao \ StringUtil :: standardize ( $ varValue ) ; $ this -> import ( 'Contao\Automator' , 'Automator' ) ; $ arrFeeds = $ this -> Automator -> purgeXmlFiles ( true ) ; if ( \ in_array ( $ varValue , $ arrFeeds ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
9085	public function getAlias ( string $ abstract ) : string { if ( ! isset ( $ this -> aliases [ $ abstract ] ) ) { return $ abstract ; } if ( $ this -> aliases [ $ abstract ] === $ abstract ) { throw new ContainerException ( "[{$abstract}] is aliased to itself." ) ; } return $ this -> getAlias ( $ this -> aliases [ $ abstract ] ) ; }
5727	public function recordIsDeletedFromStage ( ) { if ( $ this -> owner -> hasMethod ( 'getIsDeletedFromStage' ) ) { return $ this -> owner -> IsDeletedFromStage ; } if ( ! $ this -> owner -> record -> checkVersioned ( ) ) { return false ; } if ( ! $ this -> owner -> record -> isInDB ( ) ) { return true ; } $ class = $ this -> owner -> record -> class ; $ stageVersion = Versioned :: get_versionnumber_by_stage ( $ class , 'Stage' , $ this -> owner -> record -> ID ) ; return ! ( $ stageVersion ) ; }
4875	public function getMetaData ( $ key = null , $ default = null ) { if ( null === $ key ) { return $ this -> metaData ; } return $ this -> hasMetaData ( $ key ) ? $ this -> metaData [ $ key ] : $ default ; }
6636	protected function initLanguages ( ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } if ( ! isset ( Yii :: $ app -> wavecms ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Component "wavecms" not defined in config.php' ) ) ; if ( ! count ( Yii :: $ app -> wavecms -> languages ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Property "languages" is not defined in config file for component "wavecms"' ) ) ; if ( ! Yii :: $ app -> session -> get ( 'editedLanguage' ) ) { Yii :: $ app -> session -> set ( 'editedLanguage' , Yii :: $ app -> wavecms -> languages [ 0 ] ) ; } Yii :: $ app -> wavecms -> editedLanguage = Yii :: $ app -> session -> get ( 'editedLanguage' ) ; }
6980	protected function findOneAddressBy ( $ expression ) { if ( 0 < $ this -> addresses -> count ( ) ) { $ criteria = Criteria :: create ( ) -> where ( $ expression ) -> setMaxResults ( 1 ) ; $ matches = $ this -> addresses -> matching ( $ criteria ) ; if ( $ matches -> count ( ) == 1 ) { return $ matches -> first ( ) ; } } return null ; }
12501	private static function updateRecursion ( $ document ) { $ result = array ( ) ; foreach ( self :: toDotted ( $ document , '' , 1 ) as $ path => $ value ) { $ result [ ] = $ path . $ value ; } return implode ( ' ' , $ result ) ; }
6286	public static function hash ( $ s ) { $ h = 5381 ; $ len = strlen ( $ s ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ h5 = ( $ h << 5 ) & 0xffffffff ; $ sum = ( $ h & 0x3fffffff ) + ( $ h5 & 0x3fffffff ) ; $ h = ( ( $ sum & 0x40000000 ? 1 : 0 ) + ( $ h & 0x80000000 ? 2 : 0 ) + ( $ h & 0x40000000 ? 1 : 0 ) + ( $ h5 & 0x80000000 ? 2 : 0 ) + ( $ h5 & 0x40000000 ? 1 : 0 ) ) << 30 | ( $ sum & 0x3fffffff ) ; $ h ^= ord ( $ s [ $ i ] ) ; $ h &= 0xffffffff ; } return $ h ; }
8971	protected function fromJson ( $ json ) { $ data = json_decode ( $ json , true ) ; return new Rate ( $ data [ 'sourceName' ] , ( float ) $ data [ 'value' ] , $ data [ 'currencyCode' ] , $ data [ 'rateType' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'date' ] ) , $ data [ 'baseCurrencyCode' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'createdAt' ] ) , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'modifiedAt' ] ) ) ; }
3034	public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ data = $ this -> getTreeResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; return $ this -> formatTreeData ( $ data ) ; }
11716	public static function entry ( $ argv ) : void { self :: initialize ( ) ; if ( isset ( $ argv [ 1 ] ) ) { $ command = $ argv [ 1 ] ; } else { return ; } if ( ! in_array ( $ command , array_keys ( self :: $ commands ) ) ) { return ; } $ arguments = [ ] ; $ options = [ ] ; for ( $ index = 2 ; $ index < count ( $ argv ) ; $ index ++ ) { list ( $ key , $ value ) = Service :: parse ( $ argv [ $ index ] ) ; if ( Service :: determineTypeOfWord ( $ argv [ $ index ] ) == Service :: OPTION_TYPE ) { if ( ! $ value ) { $ options [ $ key ] = true ; } else { $ options [ $ key ] = $ value ; } } else { $ arguments [ ] = $ key ; } } Service :: runCommand ( self :: $ commands [ $ command ] , $ arguments , $ options ) ; }
5875	public function containerAdd ( ServerRequestInterface $ request , ResponseInterface $ response ) : ResponseInterface { $ GLOBALS [ 'TCA' ] [ 'tx_imageautoresize' ] = include ( ExtensionManagementUtility :: extPath ( 'image_autoresize' ) . 'Configuration/TCA/Module/Options.php' ) ; $ GLOBALS [ 'TCA' ] [ 'tx_imageautoresize' ] [ 'ajax' ] = true ; $ dataProviders = & $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'formEngine' ] [ 'formDataGroup' ] [ 'tcaDatabaseRecord' ] ; $ dataProviders [ \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: class ] = [ 'before' => [ \ TYPO3 \ CMS \ Backend \ Form \ FormDataProvider \ DatabaseEditRow :: class , ] ] ; $ record = [ 'uid' => \ Causal \ ImageAutoresize \ Controller \ ConfigurationController :: virtualRecordId , 'pid' => 0 , ] ; \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: initialize ( $ record ) ; $ response = parent :: containerAdd ( $ request , $ response ) ; return $ response -> withHeader ( 'Content-Type' , 'application/json; charset=utf-8' ) ; }
9068	protected function convert_value_to_string ( $ value ) { if ( $ this -> is_resource ( $ value ) ) { $ type = get_resource_type ( $ value ) ; return "(Resource:$type)" ; } if ( is_object ( $ value ) ) { if ( $ value instanceof \ Exception || $ value instanceof \ Throwable ) { return '(' . get_class ( $ value ) . "#{$value->getCode()}:{$value->getMessage()})" ; } elseif ( $ value instanceof \ DateTime || ( interface_exists ( '\DateTimeInterface' ) && $ value instanceof \ DateTimeInterface ) ) { return $ value -> format ( \ DateTime :: ATOM ) ; } elseif ( method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } else { $ class = get_class ( $ value ) ; return "($class)" ; } } if ( is_array ( $ value ) ) { return '(Array)' ; } if ( is_scalar ( $ value ) ) { return $ value ; } if ( $ value === null ) { return '(Null)' ; } return '(Invalid)' ; }
5332	public static function haikunate ( array $ params = [ ] ) { $ defaults = [ "delimiter" => "-" , "tokenLength" => 4 , "tokenHex" => false , "tokenChars" => "0123456789" , ] ; $ params = array_merge ( $ defaults , $ params ) ; if ( $ params [ "tokenHex" ] == true ) { $ params [ "tokenChars" ] = "0123456789abcdef" ; } $ adjective = self :: $ ADJECTIVES [ mt_rand ( 0 , count ( self :: $ ADJECTIVES ) - 1 ) ] ; $ noun = self :: $ NOUNS [ mt_rand ( 0 , count ( self :: $ NOUNS ) - 1 ) ] ; $ token = "" ; for ( $ i = 0 ; $ i < $ params [ "tokenLength" ] ; $ i ++ ) { $ token .= $ params [ "tokenChars" ] [ mt_rand ( 0 , strlen ( $ params [ "tokenChars" ] ) - 1 ) ] ; } $ sections = [ $ adjective , $ noun , $ token ] ; return implode ( $ params [ "delimiter" ] , array_filter ( $ sections ) ) ; }
3233	static function useExternalPaths ( ) { if ( ! self :: $ useExternalFile and self :: $ paths !== null ) { throw new \ Exception ( "You called \"useExternalFile\" too late. The SDK already used the root " . "certificate file (probably to make an API call)." ) ; } self :: $ useExternalFile = true ; }
12890	public function createView ( ) : \ stdClass { $ oView = new \ stdClass ; $ oView -> form = $ this -> _sView ; $ oView -> form_start = $ this -> _oForm -> getFormInObject ( ) -> start ; $ oView -> form_end = $ this -> _oForm -> getFormInObject ( ) -> end ; $ oView -> form_row = array ( ) ; foreach ( $ this -> _oForm -> getFormInObject ( ) -> form as $ sKey => $ mValue ) { if ( $ mValue instanceof Container ) { $ oNewForm = $ mValue -> createView ( ) ; $ oView -> form_row [ $ sKey ] = $ oNewForm -> form_row ; } else { $ oView -> form_row [ $ sKey ] = $ mValue ; } } return $ oView ; }
10787	public function onlineHelpAction ( Request $ request ) { $ template = $ this -> searchService -> getOnlineHelp ( $ request -> getLocale ( ) , $ this -> getDefaultLocale ( ) ) ; return $ this -> render ( $ template ? : 'StingerSoftEntitySearchBundle:Help:no_help.html.twig' ) ; }
5804	public function check ( $ value ) { foreach ( $ this -> _definitions as $ definition ) if ( $ definition -> match ( $ value ) ) return true ; return false ; }
12788	public static function setStatus ( $ iCode ) { if ( $ iCode === 200 ) { header ( 'HTTP/1.1 200 Ok' ) ; } else if ( $ iCode === 201 ) { header ( 'HTTP/1.1 201 Created' ) ; } else if ( $ iCode === 204 ) { header ( "HTTP/1.0 204 No Content" ) ; } else if ( $ iCode === 403 ) { header ( 'HTTP/1.1 403 Forbidden' ) ; } else if ( $ iCode === 404 ) { header ( 'HTTP/1.1 404 Not Found' ) ; } }
1185	public function resolver ( $ field ) { return function ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) use ( $ field ) { return $ this -> resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) ; } ; }
4271	public function rename ( $ pathFrom , $ pathTo ) { self :: restorePrev ( ) ; $ success = \ rename ( $ pathFrom , $ pathTo ) ; self :: register ( ) ; return $ success ; }
10095	protected function processDefault ( $ url ) { if ( $ url === null ) { return $ url ; } $ url = ( string ) $ url ; switch ( $ url ) { case '404' : case 'mm' : case 'identicon' : case 'monsterid' : case 'wavatar' : case 'retro' : break ; default : $ valid = filter_var ( $ url , FILTER_VALIDATE_URL ) ; if ( ! $ valid ) { throw new InvalidArgumentException ( 'Invalid default avatar URL' ) ; } break ; } return $ url ; }
567	private function parseDateValueFormat ( $ value , $ format ) { if ( is_array ( $ value ) ) { return false ; } if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { if ( extension_loaded ( 'intl' ) ) { return $ this -> parseDateValueIntl ( $ value , $ format ) ; } $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } return $ this -> parseDateValuePHP ( $ value , $ format ) ; }
6156	public function redirect ( string $ url ) : object { return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
12787	public static function getPut ( ) { $ aPut = array ( ) ; $ rPutResource = fopen ( "php://input" , "r" ) ; while ( $ sData = fread ( $ rPutResource , 1024 ) ) { $ aSeparatePut = explode ( '&' , $ sData ) ; foreach ( $ aSeparatePut as $ sOne ) { $ aOnePut = explode ( '=' , $ sOne ) ; $ aPut [ $ aOnePut [ 0 ] ] = $ aOnePut [ 1 ] ; } } return $ aPut ; }
2078	public function purgePageCache ( ) { $ strCacheDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCacheDir . '/http_cache' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the page cache' , __METHOD__ , TL_CRON ) ; }
5013	public function attach ( EventManagerInterface $ events , $ priority = 1 ) : void { $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_BOOTSTRAP , [ $ this , 'logBootstrap' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_FINISH , [ $ this , 'logFinish' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_JOB , [ $ this , 'logJobStart' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_JOB , [ $ this , 'logJobEnd' ] , - 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_IDLE , [ $ this , 'injectLoggerInEvent' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_STATE , [ $ this , 'injectLoggerInEvent' ] , 1000 ) ; }
4451	public function recur ( string $ className , array $ data , ? int $ interval = null , ? int $ offset = null , ? string $ jid = null , ? int $ retries = null , ? int $ priority = null , ? int $ backlog = null , ? array $ tags = null ) { try { $ jid = $ jid ? : Uuid :: uuid4 ( ) -> toString ( ) ; } catch ( \ Exception $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } $ data = json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ; if ( empty ( $ data ) ) { throw new RuntimeException ( sprintf ( 'Unable to encode payload to make a recurring job "%s" for the "%s" queue.' , $ jid , $ this -> name ) ) ; } return $ this -> client -> recur ( $ this -> name , $ jid , $ className , $ data , 'interval' , is_null ( $ interval ) ? 60 : $ interval , is_null ( $ offset ) ? 0 : $ offset , 'priority' , is_null ( $ priority ) ? 0 : $ priority , 'tags' , json_encode ( $ tags ? : [ ] , JSON_UNESCAPED_SLASHES ) , 'retries' , is_null ( $ retries ) ? 5 : $ retries , 'backlog' , is_null ( $ backlog ) ? 0 : $ backlog ) ; }
10679	private function _sklStd ( $ slovo , $ ii , $ zivotne ) { if ( $ ii < 0 || $ ii > \ count ( $ this -> vzor ) ) { $ this -> astrTvar [ 0 ] = '!!!???' ; } $ count = \ count ( $ this -> v0 ) ; for ( $ jj = 0 ; $ jj < $ count ; $ jj ++ ) { if ( $ this -> _isShoda ( $ this -> v0 [ $ jj ] , $ slovo ) >= 0 ) { return null ; } } $ this -> astrTvar [ 0 ] = $ this -> vzor [ $ ii ] [ 0 ] ; for ( $ jj = 1 ; $ jj < 15 ; $ jj ++ ) { $ this -> astrTvar [ $ jj ] = $ this -> _sklon ( $ jj , $ ii , $ slovo , $ zivotne ) ; } $ count = \ count ( $ this -> v3 ) ; for ( $ jj = 0 ; $ jj < $ count ; $ jj ++ ) { if ( $ this -> _isShoda ( $ this -> v3 [ $ jj ] , $ slovo ) >= 0 ) { return ; } } }
3628	protected static function getCURLCerts ( ) { $ url = 'https://curl.haxx.se/ca/cacert.pem' ; $ certs = @ file_get_contents ( $ url ) ; if ( ! $ certs ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , 2 ) ; $ response = curl_exec ( $ ch ) ; $ info = curl_getinfo ( $ ch ) ; curl_close ( $ ch ) ; if ( $ info [ 'http_code' ] == 200 ) { $ certs = $ response ; } } return $ certs ; }
112	private function collectDependencies ( Pool $ pool , array $ collected , PackageInterface $ package ) { $ requires = array_merge ( $ package -> getRequires ( ) , $ package -> getDevRequires ( ) ) ; foreach ( $ requires as $ requireLink ) { $ requiredPackage = $ this -> lookupInstalledPackage ( $ pool , $ requireLink ) ; if ( $ requiredPackage && ! isset ( $ collected [ $ requiredPackage -> getName ( ) ] ) ) { $ collected [ $ requiredPackage -> getName ( ) ] = $ requiredPackage ; $ collected = $ this -> collectDependencies ( $ pool , $ collected , $ requiredPackage ) ; } } return $ collected ; }
8094	public function set ( $ keyPath , $ value ) { $ stops = explode ( '.' , $ keyPath ) ; $ currentLocation = $ previousLocation = $ this ; foreach ( $ stops as $ key ) { if ( $ currentLocation instanceof Collection ) { if ( ! ( $ currentLocation -> $ key instanceof Collection ) ) { $ currentLocation -> $ key = array ( ) ; } } else { $ currentLocation = array ( ) ; $ currentLocation -> $ key = array ( ) ; } $ previousLocation = $ currentLocation ; $ currentLocation = $ currentLocation -> $ key ; } $ previousLocation -> $ key = $ value ; }
3543	public function actionCreateExampleRole ( ) { $ auth = Yii :: $ app -> authManager ; $ displayDetailedAbout = $ auth -> createPermission ( 'permissionDisplayDetailedAbout' ) ; $ displayDetailedAbout -> description = 'Permission to display detailed about informations' ; $ auth -> add ( $ displayDetailedAbout ) ; $ useContactPage = $ auth -> createPermission ( 'permissionToUseContanctPage' ) ; $ useContactPage -> description = 'Permission to use the contanct page' ; $ auth -> add ( $ useContactPage ) ; $ yii2ExampleGroup = $ auth -> createRole ( 'yii2_example_group' ) ; $ auth -> add ( $ yii2ExampleGroup ) ; $ auth -> addChild ( $ yii2ExampleGroup , $ displayDetailedAbout ) ; $ auth -> addChild ( $ yii2ExampleGroup , $ useContactPage ) ; $ useHomePage = $ auth -> createPermission ( 'permissionToSeeHome' ) ; $ useHomePage -> description = 'Permission to use the home page' ; $ auth -> add ( $ useHomePage ) ; $ yii2HomeGroup = $ auth -> createRole ( 'yii2_see_home_group' ) ; $ auth -> add ( $ yii2HomeGroup ) ; $ auth -> addChild ( $ yii2HomeGroup , $ useHomePage ) ; echo "\n\n!!!! TODO !!!!\nTow roles with the name yii2_example_group and yii2_see_home_group were created in yii2.\nPlease create the groups with the same name in Active Directory.\nAssign the user you are using for the login to this groups in Active Directory.\n" ; }
11721	public function getCarouselItemsBlog ( $ entity ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; if ( $ entity instanceof Category ) { $ qb = $ em -> getRepository ( 'BlogBundle:Post' ) -> createQueryBuilder ( 'p' ) -> join ( 'p.categories' , 'c' ) -> join ( 'p.translations' , 't' ) -> where ( 'c.id = :category' ) -> andWhere ( 'p.highlighted = true' ) -> setParameter ( 'category' , $ entity -> getId ( ) ) -> setMaxResults ( 3 ) -> orderBy ( 'p.published' , 'DESC' ) ; } elseif ( $ entity instanceof Tag ) { $ qb = $ em -> getRepository ( 'BlogBundle:Post' ) -> createQueryBuilder ( 'p' ) -> join ( 'p.tags' , 'tag' ) -> join ( 'p.translations' , 't' ) -> where ( 't.id = :tag' ) -> andWhere ( 'p.highlighted = true' ) -> setParameter ( 'tag' , $ entity -> getId ( ) ) -> setMaxResults ( 3 ) -> orderBy ( 'p.published' , 'DESC' ) ; } $ entities = $ qb -> getQuery ( ) -> getResult ( ) ; return $ entities ; }
3303	public function getClient ( ) { if ( empty ( $ this -> client ) || ! ( $ this -> client instanceof HttpClient ) ) { $ this -> client = new HttpClient ( ) ; } return $ this -> client ; }
341	public static function validate ( $ model , $ attributes = null ) { $ result = [ ] ; if ( $ attributes instanceof Model ) { $ models = func_get_args ( ) ; $ attributes = null ; } else { $ models = [ $ model ] ; } foreach ( $ models as $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , $ attribute ) ] = $ errors ; } } return $ result ; }
12793	public function create ( $ params = array ( ) ) { $ serverConfig = array_merge ( $ this -> defaults , $ params ) ; try { $ response = $ this -> client -> request -> post ( $ this -> apiEndpoint . "/droplets" , [ 'json' => $ serverConfig ] ) ; if ( 202 != $ this -> client -> getStatus ( $ response ) ) { throw new Exception ( 'Unable to create server.' ) ; } } catch ( Exception $ e ) { echo 'Unable to create server because ' . $ e -> getMessage ( ) ; } return $ this -> client -> getBody ( $ response ) ; }
6700	public function setPreRelease ( $ pre ) { $ this -> pre = array_values ( ( array ) $ pre ) ; array_walk ( $ this -> pre , function ( & $ v ) { if ( preg_match ( '/^[0-9]+$/' , $ v ) ) { $ v = ( int ) $ v ; } } ) ; }
4158	function run ( ) { $ now = new DateTime ( 'now' ) ; $ sleep = min ( array_map ( function ( $ entry ) use ( $ now ) { list ( $ expression , $ job ) = $ entry ; return $ expression -> getNextRunDate ( $ now ) -> getTimestamp ( ) ; } , $ this -> entries ) ) ; time_sleep_until ( $ sleep ) ; $ scheduled = 0 ; foreach ( $ this -> entries as $ entry ) { list ( $ expression , $ job ) = $ entry ; if ( $ expression -> isDue ( $ now ) ) { $ this -> queue -> push ( $ job ) ; $ scheduled += 1 ; } } $ this -> queue -> flush ( ) ; return $ scheduled ; }
3528	public function getFriends ( ) { $ data = FortniteClient :: sendUnrealClientGetRequest ( FortniteClient :: EPIC_FRIENDS_ENDPOINT . $ this -> account_id , $ this -> access_token , true ) ; return $ data ; }
11667	private function addDefaultFunction ( ) { $ this -> addFunction ( 'app' , function ( ) { return app ( ) ; } ) ; $ this -> addFunction ( 'url' , function ( $ url , $ absolute = false , array $ params = array ( ) ) { if ( $ absolute ) { return Url :: createAbsolute ( $ url , $ params ) ; } else { return Url :: create ( $ url , $ params ) ; } } ) ; $ this -> addFunction ( 'assets' , function ( $ path ) { return Url :: createAbsolute ( $ path ) ; } ) ; }
5597	protected function createErrorQueue ( ) { $ context = SimpleTest :: getContext ( ) ; $ test = $ this -> getTestCase ( ) ; $ queue = $ context -> get ( 'SimpleErrorQueue' ) ; $ queue -> setTestCase ( $ test ) ; return $ queue ; }
8847	public function getArchivedBlogPosts ( $ year , $ month = null , $ day = null ) { $ query = $ this -> getBlogPosts ( ) -> dataQuery ( ) ; $ stage = $ query -> getQueryParam ( "Versioned.stage" ) ; if ( $ stage ) $ stage = '_' . Convert :: raw2sql ( $ stage ) ; $ query -> innerJoin ( "BlogPost" , "`SiteTree" . $ stage . "`.`ID` = `BlogPost" . $ stage . "`.`ID`" ) ; $ query -> where ( "YEAR(PublishDate) = '" . Convert :: raw2sql ( $ year ) . "'" ) ; if ( $ month ) { $ query -> where ( "MONTH(PublishDate) = '" . Convert :: raw2sql ( $ month ) . "'" ) ; if ( $ day ) { $ query -> where ( "DAY(PublishDate) = '" . Convert :: raw2sql ( $ day ) . "'" ) ; } } return $ this -> getBlogPosts ( ) -> setDataQuery ( $ query ) ; }
3407	public function setLockStore ( StoreInterface $ store ) : Factory { $ this -> lockFactory = new Factory ( $ store ) ; return $ this -> lockFactory ; }
6758	private function messageInMessage ( string $ message ) : string { $ decodedMessage = json_decode ( $ message , true ) ; if ( is_array ( $ decodedMessage ) && isset ( $ decodedMessage [ 'message' ] ) && is_string ( $ decodedMessage [ 'message' ] ) ) { return $ decodedMessage [ 'message' ] ; } return $ message ; }
4990	public function disableForm ( $ key = null ) { if ( null === $ key ) { $ this -> activeForms = array ( ) ; return $ this ; } if ( ! is_array ( $ key ) ) { $ key = array ( $ key ) ; } foreach ( $ key as $ k ) { if ( false !== strpos ( $ k , '.' ) ) { list ( $ childKey , $ childForm ) = explode ( '.' , $ k , 2 ) ; $ child = $ this -> getForm ( $ childKey ) ; $ child -> disableForm ( $ childForm ) ; } elseif ( isset ( $ this -> forms [ $ k ] [ '__instance__' ] ) ) { unset ( $ this -> forms [ $ k ] [ '__instance__' ] ) ; } } $ this -> activeForms = array_filter ( $ this -> activeForms , function ( $ item ) use ( $ key ) { return ! in_array ( $ item , $ key ) ; } ) ; return $ this ; }
2862	public function startRequest ( ) { foreach ( $ this -> files as $ logFile ) { $ logFilePath = $ this -> getLogFilePath ( $ logFile ) ; $ this -> ranges [ $ logFile ] = array ( 'start' => $ this -> getLastFilePosition ( $ logFilePath ) , 'end' => 0 ) ; } }
6615	public function hasEndpoint ( $ method , $ endpointName ) { $ methodName = $ this -> parseEndpointName ( $ method , $ endpointName ) ; return $ this -> reflection -> hasMethod ( $ methodName ) ; }
11015	public static function sec2time ( $ seconds ) { $ sec = intval ( $ seconds ) ; $ dtF = new \ DateTime ( "@0" ) ; $ dtT = new \ DateTime ( "@$sec" ) ; return $ dtF -> diff ( $ dtT ) -> format ( '%a days, %h hours, %i minutes and %s seconds' ) ; }
7474	public function updateAction ( Request $ request , $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ id ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
676	public function setPage ( $ value , $ validatePage = false ) { if ( $ value === null ) { $ this -> _page = null ; } else { $ value = ( int ) $ value ; if ( $ validatePage && $ this -> validatePage ) { $ pageCount = $ this -> getPageCount ( ) ; if ( $ value >= $ pageCount ) { $ value = $ pageCount - 1 ; } } if ( $ value < 0 ) { $ value = 0 ; } $ this -> _page = $ value ; } }
3256	public function map ( Router $ router ) { $ router -> group ( [ 'namespace' => 'Amsgames\LaravelShop\Http\Controllers' ] , function ( $ router ) { $ router -> group ( [ 'prefix' => 'shop' ] , function ( $ router ) { $ router -> get ( 'callback/payment/{status}/{id}/{shoptoken}' , [ 'as' => 'shop.callback' , 'uses' => 'Shop\CallbackController@process' ] ) ; $ router -> post ( 'callback/payment/{status}/{id}/{shoptoken}' , [ 'as' => 'shop.callback' , 'uses' => 'Shop\CallbackController@process' ] ) ; } ) ; } ) ; }
6205	public function onException ( \ Exception $ exception ) { if ( $ this -> shouldNotifyException ( $ exception ) ) { $ this -> airbrakeClient -> notifyOnException ( $ exception ) ; } return true ; }
7765	private function documentClassProperties ( \ ML \ HydraBundle \ Mapping \ ClassMetadata $ class ) { $ result = array ( ) ; $ propertyDomain = $ this -> getTypeReferenceIri ( $ class -> getName ( ) ) ; foreach ( $ class -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( '@' , $ property -> getExposeAs ( ) , 1 ) ) { continue ; } $ result [ ] = array ( 'property' => ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : array ( '@id' => 'vocab:' . $ property -> getIri ( ) , '@type' => ( $ property -> getRoute ( ) ) ? 'hydra:Link' : 'rdf:Property' , 'label' => $ property -> getTitle ( ) , 'description' => $ property -> getDescription ( ) , 'domain' => $ propertyDomain , 'range' => $ this -> getTypeReferenceIri ( $ property -> getType ( ) ) , 'supportedOperation' => $ this -> documentOperations ( $ property -> getOperations ( ) ) ) , 'hydra:title' => $ property -> getTitle ( ) , 'hydra:description' => $ property -> getDescription ( ) , 'required' => $ property -> getRequired ( ) , 'readonly' => $ property -> isReadOnly ( ) , 'writeonly' => $ property -> isWriteOnly ( ) ) ; } return $ result ; }
6016	public function createSite ( DeploymentSite $ deploymentSite ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'deploymentSite' => $ deploymentSite ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
4477	public function untrack ( ) : void { if ( $ this -> client -> call ( 'track' , 'untrack' , $ this -> jid ) ) { $ this -> tracked = false ; } }
11661	public static function readFromFile ( $ file ) { $ real_file = File :: asFile ( $ file ) ; if ( $ real_file -> exists ( ) ) return self :: readFromString ( $ file -> getContent ( ) ) ; else return array ( ) ; }
6884	static public function isValidType ( $ type , $ throw = true ) { if ( in_array ( $ type , static :: getTypes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( 'Invalid notification type.' ) ; } return false ; }
5729	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; foreach ( $ this -> children as $ child ) { if ( ! $ child instanceof BetterButton && ! $ child instanceof BetterButtonAction ) { throw new Exception ( "DropdownFormAction must be passed instances of BetterButton" ) ; } $ child -> bindGridField ( $ form , $ request ) ; $ child -> setIsGrouped ( true ) ; if ( $ child instanceof FormAction ) { $ child -> setUseButtonTag ( true ) ; } } return $ this ; }
2746	public function isImageOptimizationPixelRatioEnabled ( ) { if ( $ this -> isImageOptimizationEnabled ( ) !== true ) { return false ; } return $ this -> _scopeConfig -> isSetFlag ( self :: XML_FASTLY_IMAGE_OPTIMIZATIONS_PIXEL_RATIO ) ; }
11948	public function getSignature ( $ baseString , array $ params ) { unset ( $ params [ 'oauth_signature' ] ) ; if ( $ this -> signature_method === 'HMAC-SHA1' ) { $ result = $ this -> sign_HMAC_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'RSA-SHA1' ) { $ result = $ this -> sign_RSA_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'PLAINTEXT' ) { $ result = $ this -> sign_PLAINTEXT ( $ baseString ) ; } else { throw new ArtaxServiceException ( 'Unknown signature method: ' . $ this -> signature_method ) ; } return base64_encode ( $ result ) ; }
724	public function getUniqueId ( ) { return $ this -> module instanceof Application ? $ this -> id : $ this -> module -> getUniqueId ( ) . '/' . $ this -> id ; }
3864	private function setTitleAndDescription ( ) { $ page = $ this -> getPage ( ) ; if ( $ page && $ this -> objItems -> getCount ( ) ) { if ( ! empty ( $ this -> strTitleAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrTitle = $ objCurrentItem -> parseAttribute ( $ this -> strTitleAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrTitle [ 'text' ] ) ) { $ page -> pageTitle = strip_tags ( $ arrTitle [ 'text' ] ) ; break ; } } $ this -> objItems -> reset ( ) ; } if ( ! empty ( $ this -> strDescriptionAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrDescription = $ objCurrentItem -> parseAttribute ( $ this -> strDescriptionAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrDescription [ 'text' ] ) ) { $ page -> description = StringUtil :: substr ( $ arrDescription [ 'text' ] , 160 ) ; break ; } } $ this -> objItems -> reset ( ) ; } } }
11866	public function lock ( string $ sessionIdentifier ) : bool { if ( in_array ( $ sessionIdentifier , self :: $ lockedIdentifiers ) ) { return true ; } self :: $ lockedIdentifiers [ ] = $ sessionIdentifier ; return true ; }
6739	public function set_options ( ) { $ slug = Module :: CustomRatingGrifus ( ) -> getOption ( 'slug' ) ; $ options = $ this -> model -> get_options ( ) ; foreach ( $ options as $ option => $ value ) { Module :: CustomRatingGrifus ( ) -> setOption ( $ option , $ value ) ; } }
4507	public function created ( JWTCreatedEvent $ event ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; $ data = $ event -> getData ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ request -> getClientIp ( ) ) ; $ event -> setData ( $ data ) ; }
858	public function setCode ( $ code ) { if ( $ code === $ this -> generateCode ( ) ) { return ; } $ this -> setSize ( 0 ) ; $ tokens = \ defined ( 'TOKEN_PARSE' ) ? token_get_all ( $ code , TOKEN_PARSE ) : token_get_all ( $ code ) ; $ this -> setSize ( \ count ( $ tokens ) ) ; foreach ( $ tokens as $ index => $ token ) { $ this [ $ index ] = new Token ( $ token ) ; } $ transformers = Transformers :: create ( ) ; $ transformers -> transform ( $ this ) ; $ this -> foundTokenKinds = [ ] ; foreach ( $ this as $ token ) { $ this -> registerFoundToken ( $ token ) ; } $ this -> rewind ( ) ; $ this -> changeCodeHash ( self :: calculateCodeHash ( $ code ) ) ; $ this -> changed = true ; }
10169	public function write ( Spreadsheet $ spreadsheet = null ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-settings' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:config' , 'urn:oasis:names:tc:opendocument:xmlns:config:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:settings' ) ; $ objWriter -> startElement ( 'config:config-item-set' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'ooo:view-settings' ) ; $ objWriter -> startElement ( 'config:config-item-map-indexed' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'Views' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'config:config-item-set' ) ; $ objWriter -> writeAttribute ( 'config:name' , 'ooo:configuration-settings' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
6811	private function getDateFormatter ( ) { if ( $ this -> dateFormatter ) { return $ this -> dateFormatter ; } return $ this -> dateFormatter = IntlDateFormatter :: create ( $ this -> locale , IntlDateFormatter :: SHORT , IntlDateFormatter :: NONE , ini_get ( 'date.timezone' ) , IntlDateFormatter :: GREGORIAN ) ; }
3707	protected function renderWidget ( $ widget , $ filterOptions ) { $ filter = $ widget ; $ templateName = $ filter [ 'raw' ] [ 'eval' ] [ 'template' ] ; $ template = new \ FrontendTemplate ( $ templateName ? $ templateName : 'mm_filteritem_default' ) ; $ template -> setData ( $ filter ) ; $ template -> submit = $ filterOptions -> isAutoSubmit ( ) ; $ filter [ 'value' ] = $ template -> parse ( ) ; return $ filter ; }
9060	public function setPrimaryKey ( string ... $ key ) : self { $ this -> primaryKey = new PrimaryKey ( $ this , ... $ key ) ; return $ this ; }
9232	public function actionView ( $ id , $ format = false ) { $ model = $ this -> findModel ( $ id ) ; if ( $ format == 'json' ) { return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'view' , [ 'model' => $ model , ] ) ; } }
1554	protected function resourceRelationships ( $ record = null ) { $ validator = $ this -> validatorFactory ( ) -> relationships ( ) ; $ this -> relationshipRules ( $ validator , $ record ) ; return $ validator ; }
11631	private function getTransitions ( $ dsBegin , $ dsEnd ) { $ assetTypeId = $ this -> daoTypeAsset -> getIdByCode ( Cfg :: CODE_TYPE_ASSET_PV ) ; $ dateFrom = $ this -> hlpPeriod -> getTimestampFrom ( $ dsBegin ) ; $ dateTo = $ this -> hlpPeriod -> getTimestampNextFrom ( $ dsEnd ) ; $ query = $ this -> aQGetData -> build ( ) ; $ bind = [ $ this -> aQGetData :: BND_ASSET_TYPE_ID => $ assetTypeId , $ this -> aQGetData :: BND_DATE_FROM => $ dateFrom , $ this -> aQGetData :: BND_DATE_TO => $ dateTo ] ; $ conn = $ query -> getConnection ( ) ; $ rs = $ conn -> fetchAll ( $ query , $ bind ) ; $ result = [ ] ; foreach ( $ rs as $ one ) { $ item = new \ Praxigento \ BonusHybrid \ Service \ Calc \ PvWriteOff \ A \ Data \ Trans ( $ one ) ; $ result [ ] = $ item ; } return $ result ; }
12438	public function get ( $ id ) { if ( isset ( $ this -> children [ $ id ] ) ) { return $ this -> children [ $ id ] ; } throw new FormalException ( "Unknown form field '$id' on form '" . get_called_class ( ) . "'. Available fields are: " . implode ( ', ' , array_keys ( $ this -> children ) ) ) ; }
4975	private function findOrCreateChild ( $ tree , $ id ) { foreach ( $ tree -> getChildren ( ) as $ node ) { if ( $ id && $ node -> getId ( ) == $ id ) { return $ node ; } } $ nodeClass = get_class ( $ tree ) ; $ node = new $ nodeClass ( ) ; $ tree -> addChild ( $ node ) ; return $ node ; }
4684	public function setValueNormalization ( bool $ enabled = false ) { if ( $ enabled === true ) { $ this -> initColumnConversions ( ) ; } else { $ this -> toIntColumns = [ ] ; $ this -> toFloatColumns = [ ] ; $ this -> toStringColumns = [ ] ; $ this -> toBoolColumns = [ ] ; $ this -> toDateTimeColumns = [ ] ; $ this -> toDriverColumns = [ ] ; } }
10476	public function push ( string $ event , $ event_args = null ) : EventChannelInterface { try { $ this -> channel -> push ( $ event , $ event_args ) ; } catch ( EventSourceIsNotPushableException $ e ) { throw new EventStreamException ( 'Event is not pushable.' ) ; } return $ this ; }
9251	public function addCompilerPass ( CompilerPassInterface $ pass , $ type = PassConfig :: TYPE_BEFORE_OPTIMIZATION ) { $ this -> compilerPasses [ ] = array ( $ pass , $ type ) ; }
12778	public function getRefreshInstructions ( ) { $ i = [ ] ; $ i [ 'type' ] = 'widget' ; $ i [ 'systemId' ] = $ this -> collectorItem -> systemId ; $ i [ 'recreateParams' ] = $ this -> recreateParams ; if ( $ this -> section ) { $ i [ 'section' ] = $ this -> section -> systemId ; } return $ i ; }
961	public function handle ( $ type ) { $ jobClass = '\\App\\Jobs\\' . str_replace ( '-' , '' , ucwords ( $ type , '-' ) ) . 'Job' ; $ jobClass :: dispatch ( Request :: header ( 'x-shopify-shop-domain' ) , json_decode ( Request :: getContent ( ) ) ) ; return Response :: make ( '' , 201 ) ; }
5030	public function findPageBy ( $ repository , $ conditions ) { $ ret = $ this -> em -> getRepository ( $ repository ) -> findOneBy ( $ conditions ) ; if ( ! $ ret ) { throw new NotFoundHttpException ; } return $ ret ; }
4771	public function status ( Request $ request , WidgetInterface $ widget , string $ widgetId , bool $ status = true ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'status' => $ status ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
1750	public static function log ( $ strText , $ strFunction , $ strCategory ) { @ trigger_error ( 'Using System::log() has been deprecated and will no longer work in Contao 5.0. Use the logger service instead.' , E_USER_DEPRECATED ) ; $ level = 'ERROR' === $ strCategory ? LogLevel :: ERROR : LogLevel :: INFO ; $ logger = static :: getContainer ( ) -> get ( 'monolog.logger.contao' ) ; $ logger -> log ( $ level , $ strText , array ( 'contao' => new ContaoContext ( $ strFunction , $ strCategory ) ) ) ; }
2186	public function fetch ( $ strTable , $ varKey , $ strAlias = null ) { $ strClass = Model :: getClassFromTable ( $ strTable ) ; $ strPk = $ strClass :: getPk ( ) ; if ( $ strAlias === null || $ strAlias == $ strPk ) { if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ varKey ] ) ) { return $ this -> arrRegistry [ $ strTable ] [ $ varKey ] ; } return null ; } return $ this -> fetchByAlias ( $ strTable , $ strAlias , $ varKey ) ; }
5774	public function isDeletable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } $ id = $ this -> getId ( ) ; if ( $ this -> isLoggedIn ( ) ) { $ this -> notDeletableReason = "Administrator cannot delete own account: id $id" ; return false ; } if ( ! $ this -> getAuthorization ( ) -> hasTopRole ( ) && $ this -> hasTopRole ( ) ) { $ this -> notDeletableReason = "Not authorized to delete administrator: id $id" ; return false ; } if ( ( EventsTableMapper :: getInstance ( ) ) -> existForAdministrator ( $ id ) ) { $ this -> notDeletableReason = "Events exist for administrator: id $id" ; return false ; } return true ; }
8114	public function addReviewNote ( Member $ reviewer , $ message ) { $ reviewLog = ContentReviewLog :: create ( ) ; $ reviewLog -> Note = $ message ; $ reviewLog -> ReviewerID = $ reviewer -> ID ; $ this -> owner -> ReviewLogs ( ) -> add ( $ reviewLog ) ; }
803	private function hasVoidReturnAnnotation ( Tokens $ tokens , $ index ) { foreach ( $ this -> findReturnAnnotations ( $ tokens , $ index ) as $ return ) { if ( [ 'void' ] === $ return -> getTypes ( ) ) { return true ; } } return false ; }
9387	public function restful ( $ route , $ class , $ middlewares = array ( ) ) { $ middlewares = ( is_string ( $ middlewares ) ) ? array ( $ middlewares ) : $ middlewares ; $ this -> add ( 'GET' , '/' . $ route , $ class . '@index' , $ middlewares ) ; $ this -> add ( 'POST' , '/' . $ route , $ class . '@store' , $ middlewares ) ; $ this -> add ( 'DELETE' , '/' . $ route . '/:id' , $ class . '@delete' , $ middlewares ) ; $ this -> add ( 'GET' , '/' . $ route . '/:id' , $ class . '@show' , $ middlewares ) ; $ this -> add ( 'PATCH' , '/' . $ route . '/:id' , $ class . '@update' , $ middlewares ) ; $ this -> add ( 'PUT' , '/' . $ route . '/:id' , $ class . '@update' , $ middlewares ) ; return $ this ; }
9188	public function connect ( ) { if ( ! is_resource ( $ this -> handle ) ) { throw new SocketException ( "Socket is not available" ) ; } if ( ! @ socket_connect ( $ this -> handle , $ this -> endpoint -> getAddress ( ) , $ this -> endpoint -> getPort ( ) ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ this -> conntected = true ; }
9761	function containOnlyInstancesOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , containsOnlyInstancesOf ( $ className ) ) ; }
5499	public function respond ( $ step , $ method , $ args ) { $ method = strtolower ( $ method ) ; if ( isset ( $ this -> at [ $ method ] [ $ step ] ) ) { if ( $ this -> at [ $ method ] [ $ step ] -> isMatch ( $ args ) ) { $ action = $ this -> at [ $ method ] [ $ step ] -> findFirstAction ( $ args ) ; if ( isset ( $ action ) ) { return $ action -> act ( ) ; } } } if ( isset ( $ this -> always [ $ method ] ) ) { $ action = $ this -> always [ $ method ] -> findFirstAction ( $ args ) ; if ( isset ( $ action ) ) { return $ action -> act ( ) ; } } return ; }
4423	protected function doInteract ( ) { $ siteAccess = $ this -> askForData ( 'site-access-name' , 'Enter the name of the Netgen Admin UI siteaccess' , 'ngadminui' , function ( $ siteaccess ) { if ( ! preg_match ( '/^[a-z][a-z0-9_]*$/' , $ siteaccess ) ) { throw new InvalidArgumentException ( 'Siteaccess name is not valid. It must start with a letter, followed by any combination of letters, numbers and underscore.' ) ; } $ existingSiteAccesses = $ this -> getContainer ( ) -> getParameter ( 'ezpublish.siteaccess.list' ) ; if ( in_array ( $ siteaccess , $ existingSiteAccesses , true ) ) { throw new InvalidArgumentException ( sprintf ( 'Siteaccess "%s" already exists.' , $ siteaccess ) ) ; } return $ siteaccess ; } ) ; $ this -> output -> writeln ( '' ) ; $ languageCode = $ this -> askForData ( 'language-code' , 'Enter the language code in which the Netgen Admin UI will be translated' , 'eng-GB' , function ( $ languageCode ) { $ languageService = $ this -> getContainer ( ) -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; try { $ languageService -> loadLanguage ( $ languageCode ) ; } catch ( NotFoundException $ e ) { throw new InvalidArgumentException ( sprintf ( 'Language code "%s" does not exist.' , $ languageCode ) ) ; } return $ languageCode ; } ) ; $ this -> output -> writeln ( '' ) ; $ availableGroups = array_keys ( $ this -> getContainer ( ) -> getParameter ( 'ezpublish.siteaccess.groups' ) ) ; $ availableGroups [ ] = 'default' ; $ siteAccessGroup = $ this -> askForChoiceData ( 'site-access-group' , 'Enter the siteaccess group name on which the Netgen Admin UI configuration will be based. This is usually the name of your frontend siteaccess group' , $ availableGroups , current ( $ availableGroups ) ) ; $ this -> writeSection ( 'Summary before installation' ) ; $ this -> output -> writeln ( array ( 'You are going to generate legacy <info>' . $ siteAccess . '</info> siteaccess with <info>' . $ languageCode . '</info> language code based on <info>' . $ siteAccessGroup . '</info> siteaccess group.' , '' , ) ) ; if ( ! $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ this -> getConfirmationQuestion ( 'Do you confirm installation (answering <comment>no</comment> will restart the process)' , true ) ) ) { $ this -> output -> writeln ( '' ) ; return false ; } return true ; }
3190	public function getLastRegisteredTimestamp ( ) { $ points = $ this -> timeLine -> getPoints ( ) ; $ length = count ( $ points ) ; $ last = false ; if ( $ length ) { $ last = end ( $ points ) -> getTimestamp ( ) ; } return $ last ; }
3259	public function placeTransaction ( $ gateway , $ transactionId , $ detail = null , $ token = null ) { return call_user_func ( Config :: get ( 'shop.transaction' ) . '::create' , [ 'order_id' => $ this -> attributes [ 'id' ] , 'gateway' => $ gateway , 'transaction_id' => $ transactionId , 'detail' => $ detail , 'token' => $ token , ] ) ; }
8398	public static function getSchema ( string $ mapping ) : Schema { $ data = Mapping :: get ( $ mapping ) ; $ class = rtrim ( ucfirst ( $ data [ 'config' ] [ 'provider' ] ) , '\\' ) . '\\Schema' ; return new $ class ( $ mapping ) ; }
12026	private function generateExecuteDocBlock ( $ methodDescription ) { $ responseClass = $ this -> operationDefinition -> getResponseClass ( ) ; $ docBlock = new DocBlockGenerator ( $ methodDescription , null ) ; if ( $ responseClass ) { $ tags [ ] = new GenericTag ( 'return' , '\\' . $ responseClass ) ; } else { $ tags [ ] = new GenericTag ( 'return' , 'mixed' ) ; } $ docBlock -> setTags ( $ tags ) ; return $ docBlock ; }
8928	public function add ( $ name , GeneratorInterface $ class ) { if ( array_key_exists ( $ name , $ this -> generators ) ) { throw new \ InvalidArgumentException ( 'Generator already exists.' ) ; } $ this -> generators [ $ name ] = $ class ; }
3613	public function setTargetTemperature ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
10083	protected function registerRouter ( ) { $ this -> app -> singleton ( 'auja.router' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new AujaRouter ( $ app [ 'auja' ] , $ app [ 'router' ] , $ config [ 'route' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Routing\AujaRouter' , 'auja.router' ) ; }
8232	protected function readConfiguration ( ) { if ( is_array ( $ this -> config ) ) { return ; } $ fileName = $ this -> dir . static :: CONFIG_FILE ; if ( ! file_exists ( $ fileName ) ) { $ this -> config = $ this -> validateConfiguration ( ) ; return ; } $ modifyTime = filemtime ( $ fileName ) ; if ( false === $ modifyTime ) { throw new \ RuntimeException ( "Unable to get mtime of the configuration file." ) ; } $ cacheKey = md5 ( $ fileName ) ; if ( $ this -> cache -> has ( $ cacheKey ) ) { $ this -> config = $ this -> cache -> get ( $ cacheKey ) ; if ( $ this -> config [ "_mtime" ] === $ modifyTime ) { return ; } } if ( ( $ yaml = self :: readFile ( $ fileName ) ) !== false ) { $ config = \ Symfony \ Component \ Yaml \ Yaml :: parse ( $ yaml ) ; $ this -> config = $ this -> validateConfiguration ( $ config ) ; } else { throw new \ RuntimeException ( "Unable to read configuration file." ) ; } $ storedConfig = $ this -> config ; $ storedConfig [ "_mtime" ] = $ modifyTime ; $ this -> cache -> set ( $ cacheKey , $ storedConfig ) ; }
3930	private function buildProperty ( PropertiesDefinitionInterface $ definition , IAttribute $ attribute , array $ propInfo ) { if ( ! $ attribute ) { return ; } $ property = $ this -> getOrCreateProperty ( $ definition , $ attribute -> getColName ( ) ) ; $ this -> setLabel ( $ property , $ propInfo , $ attribute ) ; $ this -> setDescription ( $ property , $ propInfo ) ; $ this -> setDefaultValue ( $ property , $ propInfo ) ; $ this -> setExcluded ( $ property , $ propInfo ) ; $ this -> setSearchable ( $ property , $ propInfo ) ; $ this -> setFilterable ( $ property , $ propInfo ) ; $ this -> setWidgetType ( $ property , $ propInfo ) ; $ this -> setOptions ( $ property , $ propInfo ) ; $ this -> setExplanation ( $ property , $ propInfo ) ; $ this -> setEval ( $ property , $ propInfo , ( $ attribute instanceof ITranslated ) ) ; $ this -> setEmptyValue ( $ property , $ propInfo ) ; }
2130	protected function markModified ( ) { if ( $ this -> blnIsModified === true ) { return ; } $ this -> blnIsModified = true ; $ this -> strTop = '' ; $ this -> strBottom = '' ; $ this -> Files = Files :: getInstance ( ) ; if ( static :: $ blnHasLcf ) { $ strMode = 'top' ; $ resFile = fopen ( $ this -> strRootDir . '/system/config/localconfig.php' , 'rb' ) ; while ( ! feof ( $ resFile ) ) { $ strLine = fgets ( $ resFile ) ; $ strTrim = trim ( $ strLine ) ; if ( $ strTrim == '?>' ) { continue ; } if ( $ strTrim == '### INSTALL SCRIPT START ###' ) { $ strMode = 'data' ; continue ; } if ( $ strTrim == '### INSTALL SCRIPT STOP ###' ) { $ strMode = 'bottom' ; continue ; } if ( $ strMode == 'top' ) { $ this -> strTop .= $ strLine ; } elseif ( $ strMode == 'bottom' ) { $ this -> strBottom .= $ strLine ; } elseif ( $ strTrim != '' ) { $ arrChunks = array_map ( 'trim' , explode ( '=' , $ strLine , 2 ) ) ; $ this -> arrData [ $ arrChunks [ 0 ] ] = $ arrChunks [ 1 ] ; } } fclose ( $ resFile ) ; } }
8787	public function script ( $ url , $ attributes = [ ] , $ secure = null ) { $ attributes [ 'src' ] = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> toHtmlString ( '<script' . $ this -> attributes ( $ attributes ) . '></script>' . PHP_EOL ) ; }
11158	protected function getVideoId ( $ url ) { $ logger = $ this -> getLogger ( ) ; $ parsed = parse_url ( $ url ) ; $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'parsed' => $ parsed ) ) ; switch ( $ parsed [ 'host' ] ) { case 'youtu.be' : return ltrim ( $ parsed [ 'path' ] , '/' ) ; case 'www.youtube.com' : case 'youtube.com' : if ( ! empty ( $ parsed [ 'query' ] ) ) { parse_str ( $ parsed [ 'query' ] , $ query ) ; $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'query' => $ query ) ) ; if ( ! empty ( $ query [ 'v' ] ) ) { return $ query [ 'v' ] ; } } elseif ( isset ( $ parsed [ 'path' ] ) && substr ( $ parsed [ 'path' ] , 0 , 7 ) == '/embed/' ) { $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'path' => $ parsed [ 'path' ] ) ) ; $ vId = substr ( $ parsed [ 'path' ] , 7 ) ; if ( ! empty ( $ vId ) ) { return $ vId ; } } } return null ; }
2628	protected function getOptions ( $ label = false ) { $ options = [ ] ; foreach ( $ this -> _storeManager -> getStores ( ) as $ store ) { $ options [ ] = [ 'value' => $ store -> getId ( ) , 'label' => $ store -> getName ( ) ] ; } if ( $ label ) { array_unshift ( $ options , [ 'value' => '' , 'label' => $ label ] ) ; } return $ options ; }
8622	public function setGetLowestOfferListingsForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetLowestOfferListingsForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6922	public function set ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false , array $ taxes ) { $ key = $ this -> buildKey ( $ taxGroup , $ country , $ business ) ; $ this -> taxes [ $ key ] = $ taxes ; }
6041	public function search ( $ sessionId , Search $ search , $ hits ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'search' => $ search , 'hits' => $ hits ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/search' , $ parameters , true ) ; return $ result ; }
8544	public function setRefundEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RefundEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2117	public function getExcludedFields ( ) { $ processed = array ( ) ; $ files = Contao \ System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; Contao \ System :: loadLanguageFile ( $ strTable ) ; $ this -> loadDataContainer ( $ strTable ) ; } $ arrReturn = array ( ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] as $ k => $ v ) { if ( \ is_array ( $ v [ 'fields' ] ) ) { foreach ( $ v [ 'fields' ] as $ kk => $ vv ) { if ( $ k == 'tl_user' && $ kk == 'admin' && ! $ this -> User -> isAdmin ) { continue ; } if ( $ vv [ 'exclude' ] || $ vv [ 'orig_exclude' ] ) { $ arrReturn [ $ k ] [ Contao \ StringUtil :: specialchars ( $ k . '::' . $ kk ) ] = isset ( $ vv [ 'label' ] [ 0 ] ) ? $ vv [ 'label' ] [ 0 ] . ' <span style="color:#999;padding-left:3px">[' . $ kk . ']</span>' : $ kk ; } } } } ksort ( $ arrReturn ) ; return $ arrReturn ; }
12277	public function update ( $ groupId , $ name ) { $ params = [ 'group' => [ 'id' => $ groupId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
7269	public function belongsTo ( $ refClass , $ forColumn = null ) { $ refTable = $ refClass :: tableName ( ) ; $ forTable = static :: tableName ( ) ; $ refColumn = $ refClass :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( $ refClass :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select R.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and F.$forColumn = :id " , [ "id" => $ this -> $ forColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ refModel = new $ refClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ refModel -> $ col = $ refModel -> decodeValue ( $ val , $ col ) ; return $ refModel ; }
11880	protected function getRunner ( ) { if ( null === $ this -> runner ) { $ this -> runner = new ConsoleApplication ( $ this -> name , $ this -> version , $ this -> description , $ this -> alias ) ; } return $ this -> runner ; }
4020	protected function validateWidget ( & $ arrField , $ strRow , $ strKey , & $ varInput ) { $ varValue = $ varInput [ $ strRow ] [ $ strKey ] ; $ objWidget = $ this -> initializeWidget ( $ arrField , $ strRow , $ strKey , $ varValue ) ; if ( ! is_object ( $ objWidget ) ) { return false ; } if ( ( $ arrField [ 'inputType' ] == 'checkbox' ) && isset ( $ varInput [ $ strRow ] [ $ strKey ] ) ) { $ _POST [ $ objWidget -> name ] = $ varValue ; } $ objWidget -> validate ( ) ; $ varValue = $ objWidget -> value ; $ rgxp = $ arrField [ 'eval' ] [ 'rgxp' ] ; if ( ( $ rgxp == 'date' || $ rgxp == 'time' || $ rgxp == 'datim' ) && $ varValue != '' ) { $ objDate = new Date ( $ varValue , $ GLOBALS [ 'TL_CONFIG' ] [ $ rgxp . 'Format' ] ) ; $ varValue = $ objDate -> tstamp ; } $ varValue = $ this -> handleSaveCallback ( $ arrField , $ objWidget , $ varValue ) ; $ varInput [ $ strRow ] [ $ strKey ] = $ varValue ; if ( $ objWidget -> hasErrors ( ) ) { return false ; } return true ; }
2385	public function addLegend ( string $ name , $ parent , string $ position = self :: POSITION_AFTER , $ hide = false ) : self { $ this -> validatePosition ( $ position ) ; $ this -> legends [ ] = [ 'name' => $ name , 'parents' => ( array ) $ parent , 'position' => $ position , 'hide' => ( bool ) $ hide , ] ; return $ this ; }
9823	public function writeWorkbookRelationships ( Spreadsheet $ spreadsheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ this -> writeRelationship ( $ objWriter , 1 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles' , 'styles.xml' ) ; $ this -> writeRelationship ( $ objWriter , 2 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme' , 'theme/theme1.xml' ) ; $ this -> writeRelationship ( $ objWriter , 3 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings' , 'sharedStrings.xml' ) ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ this -> writeRelationship ( $ objWriter , ( $ i + 1 + 3 ) , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet' , 'worksheets/sheet' . ( $ i + 1 ) . '.xml' ) ; } if ( $ spreadsheet -> hasMacros ( ) ) { $ this -> writeRelationShip ( $ objWriter , ( $ i + 1 + 3 ) , 'http://schemas.microsoft.com/office/2006/relationships/vbaProject' , 'vbaProject.bin' ) ; ++ $ i ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
8731	public function whitelist ( string $ address ) : WhitelistResponse { try { $ response = $ this -> callHydroApi ( 'post' , 'whitelist' , [ 'timeout' => 60 , 'json' => [ 'address' => $ address ] ] ) ; $ data = \ GuzzleHttp \ json_decode ( $ response -> getBody ( ) -> getContents ( ) , true ) ; } catch ( RuntimeException $ e ) { throw AddressWhitelistingFailed :: forAddress ( $ address , $ e -> getMessage ( ) ) ; } catch ( InvalidArgumentException $ e ) { throw AddressWhitelistingFailed :: forAddress ( $ address , $ e -> getMessage ( ) ) ; } catch ( GuzzleException $ e ) { throw AddressWhitelistingFailed :: forAddress ( $ address , $ e -> getMessage ( ) ) ; } catch ( ApiRequestFailed $ e ) { throw AddressWhitelistingFailed :: forAddress ( $ address , $ e -> getMessage ( ) ) ; } return new WhitelistResponse ( $ data [ 'hydro_address_id' ] , $ data [ 'transaction_hash' ] ) ; }
7956	public function getBillingAccountServices ( ) { $ serviceList = json_decode ( self :: getClient ( ) -> getBillingAccountServices ( $ this -> billingAccount ) ) ; $ services = array ( ) ; foreach ( $ serviceList as $ service ) { $ services [ ] = new TelephonyAccountService ( $ service , $ this ) ; } return $ services ; }
10124	private function writeGridset ( ) { $ record = 0x0082 ; $ length = 0x0002 ; $ fGridSet = ! $ this -> phpSheet -> getPrintGridlines ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fGridSet ) ; $ this -> append ( $ header . $ data ) ; }
1684	public function checkAdminStatus ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == '' && $ this -> User -> id == $ dc -> id ) { $ varValue = 1 ; } return $ varValue ; }
170	public static function filterPath ( $ path , $ options ) { if ( isset ( $ options [ 'filter' ] ) ) { $ result = call_user_func ( $ options [ 'filter' ] , $ path ) ; if ( is_bool ( $ result ) ) { return $ result ; } } if ( empty ( $ options [ 'except' ] ) && empty ( $ options [ 'only' ] ) ) { return true ; } $ path = str_replace ( '\\' , '/' , $ path ) ; if ( ! empty ( $ options [ 'except' ] ) ) { if ( ( $ except = self :: lastExcludeMatchingFromList ( $ options [ 'basePath' ] , $ path , $ options [ 'except' ] ) ) !== null ) { return $ except [ 'flags' ] & self :: PATTERN_NEGATIVE ; } } if ( ! empty ( $ options [ 'only' ] ) && ! is_dir ( $ path ) ) { if ( ( $ except = self :: lastExcludeMatchingFromList ( $ options [ 'basePath' ] , $ path , $ options [ 'only' ] ) ) !== null ) { return true ; } return false ; } return true ; }
12798	public function getLines ( $ lazy = true , $ raw = false ) { if ( is_null ( $ this -> _lines ) ) { $ file = $ this -> filePointer ; if ( ! $ file ) { return false ; } rewind ( $ file ) ; $ this -> _lines = [ ] ; $ currentLineNumber = 0 ; while ( ( $ buffer = fgetcsv ( $ this -> filePointer , 0 , $ this -> delimeter ) ) !== false ) { $ currentLineNumber ++ ; if ( $ currentLineNumber <= $ this -> skipLines ) { continue ; } $ line = Yii :: createObject ( [ 'class' => SourceFileLine :: className ( ) , 'sourceFile' => $ this , 'lineNumber' => $ currentLineNumber - 1 , 'content' => $ buffer ] ) ; if ( $ this -> testIgnore ( $ line ) ) { continue ; } $ lineId = $ line -> id ; if ( ! isset ( $ lineId ) ) { continue ; } $ this -> _lines [ $ lineId ] = $ line ; if ( $ lazy ) { $ line -> clean ( ) ; } } } return $ this -> _lines ; }
8672	private function iterateFromIndex ( $ fromIndex ) { Assert :: integer ( $ fromIndex ) ; $ count = count ( $ this -> items ) ; if ( $ count === 0 ) { return ; } $ last = $ count - 2 ; $ index = $ fromIndex < 0 ? max ( $ last + $ fromIndex , - 1 ) : min ( $ fromIndex - 1 , $ last ) ; $ keys = array_keys ( $ this -> items ) ; while ( ++ $ index < $ count ) { $ key = $ keys [ $ index ] ; yield $ key => $ this -> items [ $ key ] ; } }
7164	private function buildSaleDiscountsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) ) { return ; } foreach ( $ sale -> getAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ adjustment ) { $ this -> view -> addDiscount ( $ this -> buildDiscountLine ( $ adjustment ) ) ; } }
8468	public static function getActiveHandlersList ( ) { $ cacheKey = 'DevGroup/EventsSystem:activeHandlersList' ; $ handlers = Yii :: $ app -> cache -> get ( $ cacheKey ) ; if ( $ handlers === false ) { $ eventEventHandlers = EventEventHandler :: find ( ) -> where ( [ 'is_active' => 1 ] ) -> orderBy ( [ 'sort_order' => SORT_ASC ] ) -> asArray ( true ) -> all ( ) ; $ events = Event :: find ( ) -> where ( [ 'id' => array_column ( $ eventEventHandlers , 'event_id' , 'event_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ eventGroups = EventGroup :: find ( ) -> where ( [ 'id' => array_column ( $ events , 'event_group_id' , 'event_group_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ eventHandlers = EventHandler :: find ( ) -> where ( [ 'id' => array_column ( $ eventEventHandlers , 'event_handler_id' , 'event_handler_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ handlers = [ ] ; foreach ( $ eventEventHandlers as $ eventEventHandler ) { if ( isset ( $ eventHandlers [ $ eventEventHandler [ 'event_handler_id' ] ] , $ events [ $ eventEventHandler [ 'event_id' ] ] , $ eventGroups [ $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'event_group_id' ] ] ) === false ) { continue ; } try { $ data = Json :: decode ( $ eventEventHandler [ 'packed_json_params' ] ) ; } catch ( \ Exception $ e ) { $ data = [ ] ; } $ handlers [ ] = [ 'class' => $ eventGroups [ $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'event_group_id' ] ] [ 'owner_class_name' ] , 'name' => $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'execution_point' ] , 'callable' => [ $ eventHandlers [ $ eventEventHandler [ 'event_handler_id' ] ] [ 'class_name' ] , $ eventEventHandler [ 'method' ] , ] , 'data' => $ data , ] ; } Yii :: $ app -> cache -> set ( $ cacheKey , $ handlers , 86400 , new TagDependency ( [ 'tags' => [ NamingHelper :: getCommonTag ( EventGroup :: className ( ) ) , NamingHelper :: getCommonTag ( Event :: className ( ) ) , NamingHelper :: getCommonTag ( EventHandler :: className ( ) ) , NamingHelper :: getCommonTag ( EventEventHandler :: className ( ) ) , ] , ] ) ) ; } return $ handlers ; }
11599	public function run ( ) : void { if ( ! $ this -> isAppRootSet ( ) ) { throw new Exception ( "The application root wasn't defined." ) ; } if ( ! $ this -> isConfigFileSet ( ) ) { throw new Exception ( "The main config file wasn't defined." ) ; } $ configPath = $ this -> getAppRoot ( ) . $ this -> getConfigFile ( ) ; if ( ! is_readable ( $ configPath ) ) { throw new Exception ( "It's unable to load " . $ configPath . 'as main config file.' ) ; } $ config = require_once $ configPath ; if ( ! is_array ( $ config ) ) { throw new Exception ( 'The main config must be an array.' ) ; } $ this -> configSet = $ config ; }
8875	public function getMimeType ( $ attachment ) { $ attachment = explode ( '.' , basename ( $ attachment ) ) ; if ( ! isset ( $ this -> mimeTypes [ strtolower ( $ attachment [ count ( $ attachment ) - 1 ] ) ] ) ) { pines_error ( 'MIME Type not found.' ) ; return null ; } return $ this -> mimeTypes [ strtolower ( $ attachment [ count ( $ attachment ) - 1 ] ) ] ; }
226	protected function asCurrencyStringFallback ( $ value , $ currency = null ) { if ( $ currency === null ) { if ( $ this -> currencyCode === null ) { throw new InvalidConfigException ( 'The default currency code for the formatter is not defined.' ) ; } $ currency = $ this -> currencyCode ; } return $ currency . ' ' . $ this -> asDecimalStringFallback ( $ value , 2 ) ; }
5435	public function getSignature ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; $ method = $ interface -> getMethod ( $ name ) ; $ abstract = ( $ method -> isAbstract ( ) && ! $ interface -> isInterface ( ) && ! $ this -> isAbstractMethodInParents ( $ name ) ) ? 'abstract ' : '' ; if ( $ method -> isPublic ( ) ) { $ visibility = 'public' ; } elseif ( $ method -> isProtected ( ) ) { $ visibility = 'protected' ; } else { $ visibility = 'private' ; } $ static = $ method -> isStatic ( ) ? 'static ' : '' ; $ reference = $ method -> returnsReference ( ) ? '&' : '' ; $ params = $ this -> getParameterSignatures ( $ method ) ; $ returnType = $ this -> getReturnType ( $ method ) ; return "{$abstract}$visibility {$static}function $reference$name($params){$returnType}" ; }
4663	public function smtp ( array $ params ) { if ( ! array_key_exists ( 'username' , $ params ) ) { throw new Exception ( 'We need a username' ) ; } if ( ! array_key_exists ( 'password' , $ params ) ) { throw new Exception ( 'We need a password' ) ; } $ this -> smtp = $ params ; $ this -> auth = true ; return $ this ; }
10633	protected function getVars ( $ content , $ details = [ ] ) { $ defaults = [ 'title' => Translate :: t ( 'file.title' , [ ] , 'filefield' ) , 'file' => false , ] ; $ vars = array_merge ( $ defaults , $ content ) ; $ this -> getModel ( ) -> setVars ( $ vars ) ; }
9162	private function adjustNumbytes ( $ numBytes ) : int { if ( isset ( $ this -> headers [ 'Content-Length' ] ) ) { $ numBytes = intval ( $ this -> headers [ 'Content-Length' ] ) ; } return $ numBytes ; }
12518	public static function files ( $ path , $ filter = '.' , $ recurse = false , $ full = false , $ exclude = array ( '.svn' , 'CVS' , '.DS_Store' , '__MACOSX' , 'Thumbs.db' ) , $ excludefilter = array ( '^\..*' , '.*~' ) , $ naturalSort = true ) { $ path = Path :: clean ( $ path ) ; if ( ! is_dir ( $ path ) ) { throw new Exception ( Helper :: getTranslation ( 'NOT_A_FOLDER' ) ) ; } if ( count ( $ excludefilter ) ) { $ excludefilter_string = '/(' . implode ( '|' , $ excludefilter ) . ')/' ; } else { $ excludefilter_string = '' ; } $ arr = Folder :: _items ( $ path , $ filter , $ recurse , $ full , $ exclude , $ excludefilter_string , true ) ; if ( $ naturalSort ) { natsort ( $ arr ) ; } else { asort ( $ arr ) ; } return array_values ( $ arr ) ; }
8441	public function updateAction ( string $ production_slug , int $ id , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { list ( $ post , $ production ) = $ this -> lookupEntity ( Post :: class , $ id , $ production_slug ) ; if ( ! $ auth -> isGranted ( 'edit' , $ post ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; if ( null !== $ post -> getParent ( ) ) { $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.updated' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/update.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
7359	public static function getDefaultPriceMapLoader ( ) { if ( null === self :: $ defaultPriceMapLoader ) { $ currencyDir = realpath ( __DIR__ . '/../../../data/prices' ) ; self :: $ defaultPriceMapLoader = new PhpFileLoader ( array ( $ currencyDir ) ) ; } return self :: $ defaultPriceMapLoader ; }
6736	public function instantiate ( $ provider ) { if ( ! $ this -> supported ( $ provider ) ) { throw new ProviderNotSupportedException ( $ provider ) ; } $ class = $ this -> providerClass ( $ provider ) ; switch ( $ provider ) { case 'facebook' : return new $ class ( $ this -> config , $ this -> redirector , $ this -> http , $ this -> store , $ this -> profile , $ this -> access_token ) ; break ; case 'twitter' : return new $ class ( $ this -> config , $ this -> http , $ this -> redirector , $ this -> store , $ this -> profile , $ this -> signature , $ this -> consumer , $ this -> token , $ this -> oauth ) ; break ; } }
5769	public function setSql ( ) { $ this -> args [ ] = $ this -> updateOnColumnValue ; $ lastArgNum = count ( $ this -> args ) ; $ this -> sql = "UPDATE $this->dbTable SET $this->setColumnsValues WHERE $this->updateOnColumnName = $" . $ lastArgNum ; }
5734	public function getLeagueMatches ( int $ leagueID , array $ filter = [ 'dateFrom' => '' , 'dateTo' => '' , 'stage' => '' , 'status' => '' , 'matchday' => '' , 'group' => '' ] ) { $ leagueMatches = $ this -> run ( "v2/competitions/{$leagueID}/matches" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagueMatches -> matches ) ; }
12963	public function checkDbExists ( $ name ) { $ data = $ this -> query ( "SELECT COUNT(*) AS total FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '" . $ this -> escape ( $ name ) . "'" , true ) ; if ( isset ( $ data [ '0' ] [ 'total' ] ) && $ data [ '0' ] [ 'total' ] == '1' ) { return true ; } return false ; }
5592	protected function fetchWhileRedirected ( $ url , $ encoding ) { $ redirects = 0 ; do { $ response = $ this -> fetch ( $ url , $ encoding ) ; if ( $ response -> isError ( ) ) { return $ response ; } $ headers = $ response -> getHeaders ( ) ; if ( $ this -> cookies_enabled ) { $ headers -> writeCookiesToJar ( $ this -> cookie_jar , $ url ) ; } if ( ! $ headers -> isRedirect ( ) ) { break ; } $ location = new SimpleUrl ( $ headers -> getLocation ( ) ) ; $ url = $ location -> makeAbsolute ( $ url ) ; $ encoding = new SimpleGetEncoding ( ) ; } while ( ! $ this -> isTooManyRedirects ( ++ $ redirects ) ) ; return $ response ; }
7239	protected function getAddressFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerAddressInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerAddressInterface :: class ) ; } return $ resource ; }
8668	public function setSelf ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Self' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7527	private function nest ( $ x , $ node , $ end = false ) { array_push ( $ x -> stmtStack , $ node ) ; $ n = $ this -> statement ( $ x ) ; array_pop ( $ x -> stmtStack ) ; if ( $ end ) $ this -> t -> mustMatch ( $ end ) ; return $ n ; }
7178	public function isValidType ( $ type ) { return in_array ( $ type , array ( self :: ANY , self :: FIXED_LINE , self :: MOBILE , self :: PAGER , self :: PERSONAL_NUMBER , self :: PREMIUM_RATE , self :: SHARED_COST , self :: TOLL_FREE , self :: UAN , self :: VOIP , self :: VOICEMAIL , ) , true ) ; }
3741	protected function getLabelParameters ( EnvironmentInterface $ environment , ModelInterface $ model ) { if ( $ model -> getProperty ( 'type' ) == 'simplelookup' ) { return $ this -> getLabelParametersWithAttributeAndUrlParam ( $ environment , $ model ) ; } return $ this -> getLabelParametersNormal ( $ environment , $ model ) ; }
3725	private function buildPickerService ( ContainerBuilder $ container ) { $ pickerService = $ container -> getDefinition ( 'metamodels.controller.picker' ) ; $ configs = $ pickerService -> getArgument ( 2 ) ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'w50' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'w50x' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'clr' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'clx' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'long' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'wizard' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'm12' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'search' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'sort' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'filter' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'limit' ] ; $ pickerService -> setArgument ( 2 , $ configs ) ; }
5530	protected function chainMockExpectations ( ) { $ code = " function expect(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expect(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectAt(\$timing, \$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectAt(\$timing, \$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectCallCount(\$method, \$count) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectMaximumCallCount(\$method, \$count, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectMaximumCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectMinimumCallCount(\$method, \$count, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectMinimumCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectNever(\$method) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectNever(\$method);\n" ; $ code .= " }\n" ; $ code .= " function expectOnce(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectOnce(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectAtLeastOnce(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectAtLeastOnce(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; return $ code ; }
7175	public static function set_path ( & $ array , $ path , $ value , $ delimiter = null ) : void { if ( ! $ delimiter ) { $ delimiter = static :: $ delimiter ; } $ keys = $ path ; if ( ! is_array ( $ path ) ) { $ keys = explode ( $ delimiter , $ path ) ; } while ( count ( $ keys ) > 1 ) { $ key = array_shift ( $ keys ) ; if ( is_string ( $ key ) && ctype_digit ( $ key ) ) { $ key = ( int ) $ key ; } if ( ! isset ( $ array [ $ key ] ) ) { $ array [ $ key ] = array ( ) ; } $ array = & $ array [ $ key ] ; } $ array [ array_shift ( $ keys ) ] = $ value ; }
3634	public function events ( Request $ request ) : array { $ em = \ bean ( 'eventManager' ) ; if ( $ event = \ trim ( $ request -> query ( 'name' ) ) ) { if ( ! $ queue = $ em -> getListenerQueue ( $ event ) ) { return [ 'msg' => 'event name is invalid: ' . $ event ] ; } $ classes = [ ] ; foreach ( $ queue -> getIterator ( ) as $ listener ) { $ classes [ ] = \ get_class ( $ listener ) ; } return $ classes ; } return $ em -> getListenedEvents ( ) ; }
10468	public static function getConversionFactor ( Uom $ from , Uom $ to ) { if ( $ from -> isSameValueAs ( $ to ) ) { return new Fraction ( 1 ) ; } if ( ! isset ( static :: $ conversions ) ) { static :: $ conversions = json_decode ( utf8_encode ( file_get_contents ( __DIR__ . '/conversions.json' ) ) , true ) ; } if ( isset ( static :: $ conversions [ $ from -> getName ( ) ] [ $ to -> getName ( ) ] ) ) { $ numeratorDenominatorPair = static :: $ conversions [ $ from -> getName ( ) ] [ $ to -> getName ( ) ] ; } elseif ( isset ( static :: $ conversions [ $ to -> getName ( ) ] [ $ from -> getName ( ) ] ) ) { $ numeratorDenominatorPair = array_reverse ( static :: $ conversions [ $ to -> getName ( ) ] [ $ from -> getName ( ) ] ) ; } else { throw new ConversionNotSetException ( $ from -> getName ( ) , $ to -> getName ( ) ) ; } if ( count ( $ numeratorDenominatorPair ) == 2 ) { return new Fraction ( $ numeratorDenominatorPair [ 0 ] , $ numeratorDenominatorPair [ 1 ] ) ; } else { throw new BadConversionException ( ) ; } }
7275	protected function encodeValue ( $ column ) { $ val = in_array ( $ column , static :: $ jsons ) ? to_json ( $ this -> $ column ) : $ this -> $ column ; if ( isset ( static :: $ casts [ $ column ] ) && ( static :: $ casts [ $ column ] === "object" || static :: $ casts [ $ column ] === "array" ) ) $ val = to_json ( $ this -> $ column ) ; if ( is_bool ( $ val ) ) $ val = ( int ) $ val ; return $ val ; }
3587	protected function getMetaWhereConstraint ( $ method , ArgumentBag $ args ) { $ column = $ args -> get ( 'column' ) ; $ args -> set ( 'column' , 'meta_value' ) ; if ( $ method === 'whereBetween' ) { return $ this -> getMetaBetweenConstraint ( $ column , $ args -> get ( 'values' ) ) ; } return function ( $ query ) use ( $ column , $ method , $ args ) { $ query -> where ( 'meta_key' , $ column ) ; if ( $ args -> get ( 'value' ) || $ args -> get ( 'values' ) ) { call_user_func_array ( [ $ query , $ method ] , $ args -> all ( ) ) ; } } ; }
7061	private function setClasses ( array $ classes ) { if ( ! empty ( $ classes ) ) { $ this -> vars [ 'attr' ] [ 'class' ] = ' ' . trim ( implode ( ' ' , $ classes ) ) ; } else { unset ( $ this -> vars [ 'attr' ] [ 'class' ] ) ; } }
7489	public function insert ( $ offset , $ string ) { $ offset = ( int ) $ offset ; $ string = static :: convertString ( $ string , $ this -> encoding ) ; if ( $ offset < 0 || $ offset >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } $ this -> string = mb_substr ( $ this -> string , 0 , $ offset , $ this -> encoding ) . $ string . mb_substr ( $ this -> string , $ offset , $ this -> length ( ) , $ this -> encoding ) ; return $ this ; }
12728	public function expectsOutcome ( IOutcomeRule $ rule , IOutcomeRule $ rule2 = null , IOutcomeRule $ rule3 = null , IOutcomeRule $ rule4 = null , IOutcomeRule $ rule5 = null , IOutcomeRule $ rule6 = null , IOutcomeRule $ rule7 = null , IOutcomeRule $ rule8 = null , IOutcomeRule $ rule9 = null , IOutcomeRule $ rule10 = null ) { foreach ( func_get_args ( ) as $ arg ) { if ( $ arg instanceof IInputRule ) { $ this -> outcomeRules [ ] = $ arg ; } } return $ this ; }
354	private static function tokenizePattern ( $ pattern ) { $ charset = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; $ depth = 1 ; if ( ( $ start = $ pos = mb_strpos ( $ pattern , '{' , 0 , $ charset ) ) === false ) { return [ $ pattern ] ; } $ tokens = [ mb_substr ( $ pattern , 0 , $ pos , $ charset ) ] ; while ( true ) { $ open = mb_strpos ( $ pattern , '{' , $ pos + 1 , $ charset ) ; $ close = mb_strpos ( $ pattern , '}' , $ pos + 1 , $ charset ) ; if ( $ open === false && $ close === false ) { break ; } if ( $ open === false ) { $ open = mb_strlen ( $ pattern , $ charset ) ; } if ( $ close > $ open ) { $ depth ++ ; $ pos = $ open ; } else { $ depth -- ; $ pos = $ close ; } if ( $ depth === 0 ) { $ tokens [ ] = explode ( ',' , mb_substr ( $ pattern , $ start + 1 , $ pos - $ start - 1 , $ charset ) , 3 ) ; $ start = $ pos + 1 ; $ tokens [ ] = mb_substr ( $ pattern , $ start , $ open - $ start , $ charset ) ; $ start = $ open ; } if ( $ depth !== 0 && ( $ open === false || $ close === false ) ) { break ; } } if ( $ depth !== 0 ) { return false ; } return $ tokens ; }
8332	public function listSequences ( $ database = null ) { $ query = "SELECT name FROM sysobjects WHERE xtype = 'U'" ; $ tableNames = $ this -> _conn -> fetchAll ( $ query ) ; return array_map ( [ $ this -> _conn -> formatter , 'fixSequenceName' ] , $ tableNames ) ; }
11997	static public function generateDoctrine2 ( \ Doctrine \ ORM \ EntityManager $ entityManager , $ entityName , $ field , $ length = 16 ) { do { $ generate = self :: generate ( $ length ) ; } while ( self :: doctrine2Query ( $ entityManager , $ entityName , $ field , $ generate ) ) ; return $ generate ; }
2712	public function _getElementHtml ( AbstractElement $ element ) { $ this -> setNamePrefix ( $ element -> getName ( ) ) -> setHtmlId ( $ element -> getHtmlId ( ) ) ; return $ this -> _toHtml ( ) ; }
5089	public function queryMapRow ( $ key = 0 , $ removeColumnFromRow = false ) { $ fetchMode = $ this -> resolveFetchMode ( is_string ( $ key ) ) ; $ result = $ this -> execute ( ) ; $ map = [ ] ; try { while ( $ row = $ result -> fetch ( $ fetchMode ) ) { if ( ! isset ( $ row [ $ key ] ) ) throw new MySqlException ( "Key '$key' column not found in the query result: " . implode ( array_keys ( $ row ) ) ) ; if ( $ removeColumnFromRow ) { $ map [ $ row [ $ key ] ] = $ row ; unset ( $ map [ $ row [ $ key ] ] [ $ key ] ) ; } else { $ map [ $ row [ $ key ] ] = $ row ; } } } finally { $ result -> closeCursor ( ) ; } return $ map ; }
9917	public function getRelationsForModel ( Model $ model ) { if ( empty ( $ this -> models ) ) { throw new \ LogicException ( 'AujaConfigurator not configured yet! Call configure first.' ) ; } return ! is_null ( $ model ) && isset ( $ this -> relations [ $ model -> getName ( ) ] ) ? $ this -> relations [ $ model -> getName ( ) ] : [ ] ; }
7586	public function setDestinationPath ( $ destination = null ) { if ( empty ( $ destination ) ) { $ destination = sys_get_temp_dir ( ) . '/SugarAPI' ; } $ this -> destinationPath = $ destination ; return $ this ; }
5143	public static function create ( array $ data ) : \ One \ Model \ Photo { $ url = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'url' , '' ) ) ; $ ratio = self :: validateString ( ( string ) self :: checkData ( $ data , 'ratio' , '' ) ) ; $ description = self :: validateString ( ( string ) self :: checkData ( $ data , 'description' , '' ) ) ; $ information = self :: validateString ( ( string ) self :: checkData ( $ data , 'information' , '' ) ) ; return self :: createPhoto ( $ url , $ ratio , $ description , $ information ) ; }
3143	public function timeout ( RunnerServiceContext $ context , $ scope , $ ref , $ late = false ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Select next item before timeout" ) ; $ context -> selectAdaptiveNextItem ( ) ; } try { $ session -> closeTimer ( $ ref , $ scope ) ; if ( $ late ) { if ( $ scope == 'assessmentTest' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW ; } else if ( $ scope == 'testPart' ) { $ code = AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW ; } else if ( $ scope == 'assessmentSection' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW ; } else { $ code = AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW ; } throw new AssessmentTestSessionException ( "Maximum duration of ${scope} '${ref}' not respected." , $ code ) ; } else { $ session -> checkTimeLimits ( false , true , false ) ; } } catch ( AssessmentTestSessionException $ e ) { $ this -> onTimeout ( $ context , $ e ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'timeout' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
9891	protected function createHint ( ) { if ( $ this -> getElement ( ) -> getHint ( ) ) { $ this -> hint = $ this -> builder -> make ( 'hint' , $ this -> getElement ( ) -> getHintAttributes ( ) , $ this -> getElement ( ) -> getHint ( ) ) ; } }
12342	protected function printInfo ( $ msg , bool $ withTime = true , ? string $ fontColor = self :: FONT_COLOR_MAP [ 'lightGreen' ] , ? string $ bgColor = null ) : void { $ this -> print ( $ this -> getColoredMsg ( $ msg , $ fontColor , $ bgColor ) , $ withTime ) ; }
8146	public function parse ( Twig_TokenStream $ stream ) { if ( null === $ this -> parser ) { $ this -> parser = new Twig_Parser ( $ this ) ; } return $ this -> parser -> parse ( $ stream ) ; }
4649	protected function getServices ( $ config ) { $ services = array ( ) ; $ travisServices = isset ( $ config [ 'services' ] ) && is_array ( $ config [ 'services' ] ) ? $ config [ 'services' ] : array ( ) ; foreach ( $ travisServices as $ service ) { if ( isset ( $ this -> servicesMapping [ $ service ] ) ) { $ services [ ] = new Service ( $ service , $ this -> servicesMapping [ $ service ] [ 'repository' ] , $ this -> servicesMapping [ $ service ] [ 'tag' ] , $ this -> servicesMapping [ $ service ] [ 'config' ] ) ; } } return $ services ; }
5947	public function getAdapterType ( ) { if ( $ this -> adapter instanceof AbstractAdapter ) { $ string = StringHelper :: factory ( get_class ( $ this -> adapter ) ) ; return $ string -> substr ( $ string -> findLast ( "\\" ) ) -> replace ( array ( "\\" , " " ) , "" ) -> toString ( ) ; } return "Unknown" ; }
1311	public function checkSignature ( Request $ request , Consumer $ consumer , Token $ token , $ signature ) { $ built = $ this -> buildSignature ( $ request , $ consumer , $ token ) ; if ( strlen ( $ built ) == 0 || strlen ( $ signature ) == 0 ) { return false ; } if ( strlen ( $ built ) != strlen ( $ signature ) ) { return false ; } $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ signature ) ; $ i ++ ) { $ result |= ord ( $ built { $ i } ) ^ ord ( $ signature { $ i } ) ; } return $ result == 0 ; }
890	public function getTypes ( ) { if ( null === $ this -> types ) { $ this -> types = [ ] ; $ content = $ this -> getTypesContent ( ) ; while ( '' !== $ content && false !== $ content ) { Preg :: match ( '{^' . self :: REGEX_TYPES . '$}x' , $ content , $ matches ) ; $ this -> types [ ] = $ matches [ 'type' ] ; $ content = substr ( $ content , \ strlen ( $ matches [ 'type' ] ) + 1 ) ; } } return $ this -> types ; }
1358	public static function create ( $ mediaType , int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , new EncoderOptions ( $ options , $ urlPrefix , $ depth ) ) ; }
2662	public function getBackends ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
11265	public function model ( $ pathname ) { $ fullPath = $ this -> config [ 'pathToModels' ] . $ this -> getPath ( $ pathname ) . $ this -> config [ 'modelsPrefix' ] . $ this -> getName ( $ pathname ) . $ this -> config [ 'modelsPostfix' ] . '.php' ; include_once ( $ fullPath ) ; }
4145	protected function validateCredentials ( $ credentials ) { $ credentials = array_filter ( $ credentials ) ; $ keys = array_keys ( $ credentials ) ; $ diff = array_diff ( $ this -> requiredCredentials , $ keys ) ; if ( ! empty ( $ diff ) ) { throw new MissingCredentialsException ( 'Missing Credentials: ' . implode ( $ diff , ', ' ) ) ; } unset ( $ credentials , $ keys , $ diff ) ; }
2468	public function getOptions ( ) : array { $ options = [ ] ; foreach ( self :: DEFAULT_OPTIONS as $ option => $ label ) { $ options [ $ option ] = $ this -> translator -> trans ( 'MSC.validCharacters.' . $ label , [ ] , 'contao_default' ) ; } $ event = new SlugValidCharactersEvent ( $ options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: SLUG_VALID_CHARACTERS , $ event ) ; return $ event -> getOptions ( ) ; }
10419	public static function parse ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new Exception ( 'The give file ' . $ path . ' doesn\'t exist.' ) ; } return Yaml :: parse ( file_get_contents ( $ path ) ) ; }
10314	function getClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ linkIdFilter = null , $ linkUrlFilter = null , $ linkTagFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_id" , $ linkIdFilter ) ; if ( isset ( $ linkUrlFilter ) ) $ params [ 'link_url' ] = $ linkUrlFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_tag" , $ linkTagFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/clicks/count' , $ params ) ; }
5970	public function accounts ( ) { if ( ! $ this -> accounts instanceof AccountsController ) { $ this -> accounts = new AccountsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> accounts -> setLogger ( $ this -> logger ) ; } return $ this -> accounts ; }
8729	protected function updateFolderName ( HTTPRequest $ request ) { if ( ! $ this -> getCanSelectFolder ( ) ) { return ; } $ folderID = $ request -> requestVar ( "{$this->Name}/folder" ) ; $ path = $ this -> folderPathFromID ( $ folderID ) ; if ( $ path !== false ) { $ this -> setFolderName ( $ path ) ; $ this -> selectField -> setValue ( $ folderID ) ; } }
11228	protected function getUrl ( $ section , array $ uriParams = [ ] ) { $ endpoint = rtrim ( $ this -> getEndpoint ( ) , '/' ) ; $ section = ltrim ( $ section , '/' ) ; $ params = http_build_query ( $ uriParams ) ; if ( $ params ) { return sprintf ( "%s/%s?%s" , $ endpoint , $ section , $ params ) ; } else { return sprintf ( "%s/%s" , $ endpoint , $ section ) ; } }
2572	protected function loadSessionHandler ( $ params ) { if ( isset ( $ params [ 'sessionHandler' ] ) && $ params [ 'sessionHandler' ] instanceof Session \ Handler \ HandlerInterface ) { $ this -> sessionHandler = $ params [ 'sessionHandler' ] ; } }
9363	public function add ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return new self ( $ this -> float_r + $ z -> re , $ this -> float_i + $ z -> im ) ; }
8120	public function canSubmitReview ( $ record ) { if ( ! $ record -> canEdit ( ) || ! $ record -> hasMethod ( 'canBeReviewedBy' ) || ! $ record -> canBeReviewedBy ( Security :: getCurrentUser ( ) ) ) { return false ; } return true ; }
11494	public static function log ( $ message , $ type = DataLogger :: INFO ) { if ( null === self :: $ logger ) { return ; } if ( ! method_exists ( self :: $ logger , $ type ) ) { $ exceptionMessage = sprintf ( 'Logger does not support the %s method.' , $ type ) ; throw new \ InvalidArgumentException ( $ exceptionMessage ) ; } self :: $ logger -> $ type ( $ message ) ; }
5931	public function setDefinition ( $ definition ) { if ( is_array ( $ definition ) ) { $ this -> definition = $ definition ; return $ this ; } $ this -> definition = json_decode ( $ definition , true ) ; if ( null === $ this -> definition ) { $ this -> definition = $ definition ; } return $ this ; }
12595	protected function getMinifier ( SplFileInfo $ file , string $ source ) : Minifier { $ minifier = '\Gears\Asset\Minifiers\\' ; $ minifier .= ucfirst ( $ this -> destination -> getExtension ( ) ) ; if ( ! class_exists ( $ minifier ) ) { throw new RuntimeException ( 'Minification is not supported for type: ' . $ this -> destination -> getExtension ( ) ) ; } return new $ minifier ( $ file , $ source ) ; }
829	private function isStringPartToken ( Token $ token ) { return $ token -> isGivenKind ( T_ENCAPSED_AND_WHITESPACE ) || $ token -> isGivenKind ( T_START_HEREDOC ) || '"' === $ token -> getContent ( ) || 'b"' === strtolower ( $ token -> getContent ( ) ) ; }
2213	public function first ( ) { $ this -> intIndex = 0 ; $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ $ this -> intIndex ] ; return $ this ; }
3749	protected function getItemsFromFilter ( $ filter , $ config ) { $ sorting = $ this -> extractSorting ( $ config ) ; return $ this -> getMetaModel ( ) -> findByFilter ( $ filter , $ sorting [ 0 ] , $ config -> getStart ( ) , $ config -> getAmount ( ) , strtoupper ( $ sorting [ 1 ] ) , $ config -> getFields ( ) ? : array ( ) ) ; }
10439	protected function nextBufferLine ( ) { $ query = $ this -> parseQuery ( ) ; if ( ! empty ( $ query ) ) { $ this -> buffer [ $ this -> key ] [ self :: PARAM_QUERY ] = $ query ; } else { $ this -> buffer [ $ this -> key ] = false ; } }
3550	protected function registerParser ( ) { $ this -> app -> singleton ( EmojiParser :: class , function ( Container $ app ) { return new EmojiParser ( $ app -> make ( RepositoryInterface :: class ) ) ; } ) ; }
5985	public function setTokens ( AccessToken $ accessToken , AccessToken $ refreshToken = null ) { if ( $ accessToken instanceof AccessToken && false === $ accessToken -> isExpired ( ) ) { if ( $ this -> cache instanceof Cache ) { $ this -> cache -> save ( 'oauth2accesstoken' , serialize ( $ accessToken ) , $ accessToken -> getExpires ( ) -> getTimestamp ( ) - ( new \ DateTime ( ) ) -> getTimestamp ( ) ) ; } $ this -> oauth2Middleware -> setAccessToken ( $ accessToken ) ; } if ( $ refreshToken instanceof AccessToken && false === $ accessToken -> isExpired ( ) ) { if ( $ this -> cache instanceof Cache ) { $ this -> cache -> save ( 'oauth2refreshtoken' , serialize ( $ refreshToken ) , $ refreshToken -> getExpires ( ) instanceof \ DateTime ? $ refreshToken -> getExpires ( ) -> getTimestamp ( ) - ( new \ DateTime ( ) ) -> getTimestamp ( ) : 3600 * 24 * 13 ) ; } $ this -> oauth2Middleware -> setRefreshToken ( $ refreshToken ) ; } }
12908	public function update ( FilterRequest $ request , $ id ) { $ this -> fieldManager = $ this -> getFieldManager ( ) ; $ this -> validate ( $ request -> request , $ this -> fieldManager -> update ( ) ) ; $ id = $ this -> getRealId ( $ id ) ; $ resource = $ this -> repository -> update ( $ request -> all ( ) , $ id ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
6467	private function createStreamFromString ( string $ string ) : Stream { $ stream = new Stream ( fopen ( 'php://temp' , 'r+b' ) ) ; $ stream -> write ( $ string ) ; $ stream -> rewind ( ) ; return $ stream ; }
7278	public function input ( $ name = null , $ default = null ) { return ! $ name ? $ this -> inputs : ( $ this -> inputs [ $ name ] ?? $ default ) ; }
5551	public function getMimeType ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getMimeType ( ) ; } return $ this -> frameset -> getMimeType ( ) ; }
2924	public function formatSetterLine ( $ key , $ value = null , $ comment = null , $ export = false ) { $ forceQuotes = ( strlen ( $ comment ) > 0 && strlen ( trim ( $ value ) ) == 0 ) ; $ value = $ this -> formatValue ( $ value , $ forceQuotes ) ; $ key = $ this -> formatKey ( $ key ) ; $ comment = $ this -> formatComment ( $ comment ) ; $ export = $ export ? 'export ' : '' ; $ line = "{$export}{$key}={$value}{$comment}" ; return $ line ; }
12510	public function buildPreview ( $ by ) { if ( ! in_array ( $ by , $ this -> previewBys , true ) ) { throw new InvalidArgumentException ( 'This preview by not exist.' ) ; } if ( empty ( $ this -> msgType ) ) { throw new RuntimeException ( 'Message type not exist.' ) ; } elseif ( $ this -> msgType === Broadcast :: MSG_TYPE_VIDEO ) { if ( is_array ( $ this -> message ) ) { $ this -> message = array_shift ( $ this -> message ) ; } $ this -> msgType = 'mpvideo' ; } if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message content to send.' ) ; } if ( empty ( $ this -> to ) ) { throw new RuntimeException ( 'No to.' ) ; } $ content = ( new Transformer ( $ this -> msgType , $ this -> message ) ) -> transform ( ) ; $ message = array_merge ( $ this -> buildTo ( $ this -> to , $ by ) , $ content ) ; return $ message ; }
9005	protected function get_levels ( ) { return array ( LogLevel :: EMERGENCY => 'Emergency' , LogLevel :: ALERT => 'Alert' , LogLevel :: CRITICAL => 'Critical' , LogLevel :: ERROR => 'Error' , LogLevel :: WARNING => 'Warning' , LogLevel :: NOTICE => 'Notice' , LogLevel :: INFO => 'Info' , LogLevel :: DEBUG => 'Debug' ) ; }
3076	public function processInput ( QtiRunnerServiceContext $ context , array $ input ) { $ responses = [ ] ; foreach ( $ input as $ data ) { if ( ! is_array ( $ data ) || ! isset ( $ data [ 'channel' ] ) || ! isset ( $ data [ 'message' ] ) ) { throw new \ common_exception_InconsistentData ( 'Wrong message chunk received by the bidirectional communication service: either channel or message content is missing!' ) ; } if ( $ this -> hasChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ) { $ channel = $ this -> getChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ; $ responses [ ] = $ this -> processChannel ( $ channel , $ context , $ data [ 'message' ] ) ; } else { $ responses [ ] = $ this -> fallback ( $ data [ 'channel' ] , $ context , $ data [ 'message' ] ) ; } } return $ responses ; }
10792	public function get ( $ idOrUser ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; if ( 'current' == $ idOrUser ) { return $ userRepository -> get ( $ idOrUser , $ this -> getServiceLocator ( ) ) ; } $ user = $ this -> getEntity ( $ idOrUser ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } return $ userRepository -> get ( $ user , $ this -> getServiceLocator ( ) ) ; }
7902	protected function getFullFileName ( Provider $ provider ) { $ folder = $ this -> folder ? rtrim ( $ this -> folder , '/' ) . '/' : '' ; if ( $ this -> filename ) { $ filename = $ this -> filename ; } else { $ filename = md5 ( uniqid ( microtime ( true ) , true ) ) ; } return $ folder . $ filename . '.' . $ provider -> getExtension ( ) ; }
7917	protected function renderInput ( ) { return $ this -> hasModel ( ) ? Html :: activeRadio ( $ this -> model , $ this -> attribute , $ this -> options ) : Html :: radio ( $ this -> name , $ this -> checked , $ this -> options ) ; }
9963	public function removeRow ( $ pRow , $ pNumRows = 1 ) { if ( $ pRow >= 1 ) { $ highestRow = $ this -> getHighestDataRow ( ) ; $ objReferenceHelper = ReferenceHelper :: getInstance ( ) ; $ objReferenceHelper -> insertNewBefore ( 'A' . ( $ pRow + $ pNumRows ) , 0 , - $ pNumRows , $ this ) ; for ( $ r = 0 ; $ r < $ pNumRows ; ++ $ r ) { $ this -> getCellCollection ( ) -> removeRow ( $ highestRow ) ; -- $ highestRow ; } } else { throw new Exception ( 'Rows to be deleted should at least start from row 1.' ) ; } return $ this ; }
2212	public function fetchField ( $ intOffset = 0 ) { $ arrFields = array_values ( $ this -> resultSet [ $ this -> intIndex ] ) ; return $ arrFields [ $ intOffset ] ; }
6742	public function apply ( Request $ request , ParamConverter $ configuration ) { $ param = $ this -> getRequestAttributeName ( $ request , $ configuration ) ; if ( ! $ request -> attributes -> has ( $ param ) ) { return false ; } $ value = $ request -> attributes -> get ( $ param ) ; if ( ! $ value && $ configuration -> isOptional ( ) ) { return false ; } $ convertedValue = $ this -> convertValue ( $ value , $ configuration ) ; if ( null === $ convertedValue && false === $ configuration -> isOptional ( ) ) { throw new NotFoundHttpException ( "Unable to find '{$configuration->getClass()}' with identifier '{$value}' not found" ) ; } $ request -> attributes -> set ( $ configuration -> getName ( ) , $ convertedValue ) ; return true ; }
10138	private function writePageLayoutView ( ) { $ record = 0x088B ; $ length = 0x0010 ; $ rt = 0x088B ; $ grbitFrt = 0x0000 ; $ reserved = 0x0000000000000000 ; $ wScalvePLV = $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) ; if ( $ this -> phpSheet -> getSheetView ( ) -> getView ( ) == SheetView :: SHEETVIEW_PAGE_LAYOUT ) { $ fPageLayoutView = 1 ; } else { $ fPageLayoutView = 0 ; } $ fRulerVisible = 0 ; $ fWhitespaceHidden = 0 ; $ grbit = $ fPageLayoutView ; $ grbit |= $ fRulerVisible << 1 ; $ grbit |= $ fWhitespaceHidden << 3 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvVVvv' , $ rt , $ grbitFrt , 0x00000000 , 0x00000000 , $ wScalvePLV , $ grbit ) ; $ this -> append ( $ header . $ data ) ; }
2926	public function load ( $ filePath = null , $ restoreIfNotFound = false , $ restorePath = null ) { $ this -> resetContent ( ) ; if ( ! is_null ( $ filePath ) ) { $ this -> filePath = $ filePath ; } else { if ( method_exists ( $ this -> app , 'environmentPath' ) && method_exists ( $ this -> app , 'environmentFile' ) ) { $ this -> filePath = $ this -> app -> environmentPath ( ) . '/' . $ this -> app -> environmentFile ( ) ; } else { $ this -> filePath = __DIR__ . '/../../../../../../.env' ; } } $ this -> reader -> load ( $ this -> filePath ) ; if ( file_exists ( $ this -> filePath ) ) { $ this -> writer -> setBuffer ( $ this -> getContent ( ) ) ; return $ this ; } elseif ( $ restoreIfNotFound ) { return $ this -> restore ( $ restorePath ) ; } else { return $ this ; } }
10628	public static function cpuPercentages ( $ cpuCoreInfo1 , $ cpuCoreInfo2 ) { $ cpus = array ( ) ; foreach ( $ cpuCoreInfo1 as $ idx => $ core ) { $ dif = array ( ) ; $ cpu = array ( ) ; $ dif [ 'user' ] = $ cpuCoreInfo2 [ $ idx ] [ 'user' ] - $ cpuCoreInfo1 [ $ idx ] [ 'user' ] ; $ dif [ 'nice' ] = $ cpuCoreInfo2 [ $ idx ] [ 'nice' ] - $ cpuCoreInfo1 [ $ idx ] [ 'nice' ] ; $ dif [ 'sys' ] = $ cpuCoreInfo2 [ $ idx ] [ 'sys' ] - $ cpuCoreInfo1 [ $ idx ] [ 'sys' ] ; $ dif [ 'idle' ] = $ cpuCoreInfo2 [ $ idx ] [ 'idle' ] - $ cpuCoreInfo1 [ $ idx ] [ 'idle' ] ; $ dif [ 'iowait' ] = $ cpuCoreInfo2 [ $ idx ] [ 'iowait' ] - $ cpuCoreInfo1 [ $ idx ] [ 'iowait' ] ; $ dif [ 'irq' ] = $ cpuCoreInfo2 [ $ idx ] [ 'irq' ] - $ cpuCoreInfo1 [ $ idx ] [ 'irq' ] ; $ dif [ 'softirq' ] = $ cpuCoreInfo2 [ $ idx ] [ 'softirq' ] - $ cpuCoreInfo1 [ $ idx ] [ 'softirq' ] ; $ total = array_sum ( $ dif ) ; foreach ( $ dif as $ x => $ y ) { $ cpu [ $ x ] = round ( $ y / $ total * 100 , 2 ) ; } $ cpus [ 'cpu' . $ idx ] = $ cpu ; } return $ cpus ; }
1787	public function getActiveLayoutSections ( Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> pid ) { $ arrSections = array ( ) ; $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> pid ) ; if ( $ objPage -> layout ) { $ objLayout = Contao \ LayoutModel :: findByPk ( $ objPage -> layout ) ; if ( $ objLayout === null ) { return array ( ) ; } $ arrModules = Contao \ StringUtil :: deserialize ( $ objLayout -> modules ) ; if ( empty ( $ arrModules ) || ! \ is_array ( $ arrModules ) ) { return array ( ) ; } foreach ( $ arrModules as $ arrModule ) { if ( $ arrModule [ 'mod' ] == 0 && $ arrModule [ 'enable' ] ) { $ arrSections [ ] = $ arrModule [ 'col' ] ; } } } } else { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; $ objLayout = $ this -> Database -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = Contao \ StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ arrSections [ ] = $ v [ 'id' ] ; } } } } } return Contao \ Backend :: convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) ; }
7349	protected function hasNotification ( SaleInterface $ sale , $ type , $ number ) { foreach ( $ sale -> getNotifications ( ) as $ n ) { if ( $ n -> getType ( ) !== $ type ) { continue ; } if ( $ n -> hasData ( 'shipment' ) && $ n -> getData ( 'shipment' ) === $ number ) { return true ; } } return false ; }
11458	public function batchPageSummary ( $ timestamp , $ pageIndex ) { $ params = [ 'date' => $ timestamp , 'page_index' => $ pageIndex , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_PAGE_LIST , $ params ] ) ; }
4062	private static function isEmptyArrayEquivalent ( $ expected , $ actual ) { return ( gettype ( $ expected ) == 'string' ) && ( ( gettype ( $ actual ) == 'array' ) || ( gettype ( $ actual ) == 'NULL' ) ) && empty ( $ actual ) && empty ( $ expected ) ; }
10312	function getRecipientsCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeDeletedRecipients = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeDeletedRecipients ) ) $ params [ 'exclude_deleted_recipients' ] = ( $ excludeDeletedRecipients == true ) ? "true" : "false" ; return $ this -> get ( 'reports/recipients/count' , $ params ) ; }
1212	public static function isTruthy ( $ value ) { if ( ! $ value ) { return $ value === 0 || $ value === '0' ; } elseif ( $ value instanceof \ stdClass ) { return ( bool ) get_object_vars ( $ value ) ; } elseif ( $ value instanceof JmesPathableArrayInterface ) { return Utils :: isTruthy ( iterator_to_array ( $ value ) ) ; } elseif ( $ value instanceof JmesPathableObjectInterface ) { return ( bool ) $ value -> toArray ( ) ; } else { return true ; } }
10767	public static function normalizeAccountNumber ( $ account ) { $ account = str_replace ( ' ' , '' , $ account ) ; if ( false === strpos ( $ account , '-' ) ) { $ account = '000000-' . $ account ; } $ parts = explode ( '-' , $ account ) ; $ parts [ 0 ] = str_pad ( $ parts [ 0 ] , 6 , '0' , STR_PAD_LEFT ) ; $ parts2 = explode ( '/' , $ parts [ 1 ] ) ; $ parts2 [ 0 ] = str_pad ( $ parts2 [ 0 ] , 10 , '0' , STR_PAD_LEFT ) ; $ parts2 [ 1 ] = str_pad ( $ parts2 [ 1 ] , 4 , '0' , STR_PAD_LEFT ) ; $ parts [ 1 ] = implode ( '/' , $ parts2 ) ; return implode ( '-' , $ parts ) ; }
2613	private function prepareGAReqData ( ) { if ( ! empty ( $ this -> GAReqData ) ) { return $ this -> GAReqData ; } $ mandatoryReqData = [ ] ; $ mandatoryReqData [ 'v' ] = 1 ; $ mandatoryReqData [ 'tid' ] = $ this -> getGATrackingId ( ) ; $ cid = $ this -> config -> getCID ( ) ; $ mandatoryReqData [ 'cid' ] = $ cid ; $ mandatoryReqData [ 'uid' ] = $ cid ; $ mandatoryReqData [ 'ua' ] = $ this -> metaData -> getVersion ( ) ; $ mandatoryReqData [ 'geoid' ] = $ this -> getCountry ( ) ; $ mandatoryReqData [ 'ds' ] = 'Fastly' ; $ customVars = $ this -> prepareCustomVariables ( ) ; $ this -> GAReqData = array_merge ( $ mandatoryReqData , $ customVars ) ; return $ this -> GAReqData ; }
8850	public function rss ( ) { $ rss = new RSSFeed ( $ this -> getBlogPosts ( ) , $ this -> Link ( ) , $ this -> MetaTitle , $ this -> MetaDescription ) ; $ this -> extend ( 'updateRss' , $ rss ) ; return $ rss -> outputToBrowser ( ) ; }
11271	public function render ( $ template , array $ vars = array ( ) ) { ob_start ( ) ; try { $ this -> display ( $ template , $ vars ) ; } catch ( Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } return ob_get_clean ( ) ; }
1722	private function addGlobal ( array $ chunks , $ value ) : void { if ( false === $ this -> addToGlobals ) { return ; } $ data = & $ GLOBALS [ 'TL_LANG' ] ; foreach ( $ chunks as $ key ) { if ( null === $ data || ! \ is_array ( $ data ) ) { $ data = [ ] ; } $ data = & $ data [ $ key ] ; } $ data = $ value ; }
11516	public function updateMetadata ( SiteConfig $ config , SiteTree $ owner , & $ metadata ) { $ HTML5Favicon = $ config -> HTML5Favicon ( ) ; $ IOSPinicon = $ config -> IOSPinicon ( ) ; $ AndroidPinicon = $ config -> AndroidPinicon ( ) ; $ WindowsPinicon = $ config -> WindowsPinicon ( ) ; if ( $ IOSPinicon -> exists ( ) ) { $ this -> GenerateIOSPinicon ( $ config , $ owner , $ metadata , $ IOSPinicon ) ; } if ( $ HTML5Favicon -> exists ( ) ) { $ this -> GenerateHTML5Favicon ( $ owner , $ metadata , $ HTML5Favicon ) ; } if ( $ AndroidPinicon -> exists ( ) ) { $ this -> GenerateAndroidPinicon ( $ config , $ owner , $ metadata ) ; } if ( $ WindowsPinicon -> exists ( ) ) { $ this -> GenerateWindowsPinicon ( $ config , $ owner , $ metadata , $ WindowsPinicon ) ; } }
4734	public function write_data ( ) { $ option_key = "_wp_session_{$this->session_id}" ; if ( $ this -> dirty ) { if ( false === get_option ( $ option_key ) ) { add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; add_option ( "_wp_session_expires_{$this->session_id}" , $ this -> expires , '' , 'no' ) ; } else { delete_option ( "_wp_session_{$this->session_id}" ) ; add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; } } }
5821	protected function writeToContainer ( $ type , $ path , $ payload ) { try { $ this -> container -> { 'uploadFrom' . $ type } ( $ path , $ payload ) ; } catch ( UploadFailedException $ e ) { return false ; } return $ this -> getMetadata ( $ path ) ; }
379	public function renderCallStackItem ( $ file , $ line , $ class , $ method , $ args , $ index ) { $ lines = [ ] ; $ begin = $ end = 0 ; if ( $ file !== null && $ line !== null ) { $ line -- ; $ lines = @ file ( $ file ) ; if ( $ line < 0 || $ lines === false || ( $ lineCount = count ( $ lines ) ) < $ line ) { return '' ; } $ half = ( int ) ( ( $ index === 1 ? $ this -> maxSourceLines : $ this -> maxTraceSourceLines ) / 2 ) ; $ begin = $ line - $ half > 0 ? $ line - $ half : 0 ; $ end = $ line + $ half < $ lineCount ? $ line + $ half : $ lineCount - 1 ; } return $ this -> renderFile ( $ this -> callStackItemView , [ 'file' => $ file , 'line' => $ line , 'class' => $ class , 'method' => $ method , 'index' => $ index , 'lines' => $ lines , 'begin' => $ begin , 'end' => $ end , 'args' => $ args , ] ) ; }
1410	public function resourceTypeNotRecognised ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'resource_type_not_recognised' , 'code' ) , $ this -> trans ( 'resource_type_not_recognised' , 'title' ) , $ this -> trans ( 'resource_type_not_recognised' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'type' ) ) ; }
12044	public function view ( UserPolicy $ user , Question $ question ) { if ( $ user -> canDo ( 'forum.question.view' ) && $ user -> isAdmin ( ) ) { return true ; } return $ question -> user_id == user_id ( ) && $ question -> user_type == user_type ( ) ; }
10008	public function disconnectWorksheets ( ) { $ worksheet = null ; foreach ( $ this -> workSheetCollection as $ k => & $ worksheet ) { $ worksheet -> disconnectCells ( ) ; $ this -> workSheetCollection [ $ k ] = null ; } unset ( $ worksheet ) ; $ this -> workSheetCollection = [ ] ; }
5725	protected function saveAndRedirect ( $ data , $ form , $ redirectLink ) { $ new_record = $ this -> owner -> record -> ID == 0 ; $ controller = Controller :: curr ( ) ; $ list = $ this -> owner -> gridField -> getList ( ) ; if ( $ list instanceof ManyManyList ) { $ extraData = ( isset ( $ data [ 'ManyMany' ] ) ) ? $ data [ 'ManyMany' ] : null ; } else { $ extraData = null ; } if ( ! $ this -> owner -> record -> canEdit ( ) ) { return $ controller -> httpError ( 403 ) ; } try { $ form -> saveInto ( $ this -> owner -> record ) ; $ this -> owner -> record -> write ( ) ; $ list -> add ( $ this -> owner -> record , $ extraData ) ; } catch ( ValidationException $ e ) { $ form -> sessionMessage ( $ e -> getResult ( ) -> message ( ) , 'bad' ) ; $ responseNegotiator = new PjaxResponseNegotiator ( array ( 'CurrentForm' => function ( ) use ( $ form ) { return $ form -> forTemplate ( ) ; } , 'default' => function ( ) use ( $ controller ) { return $ controller -> redirectBack ( ) ; } ) ) ; if ( $ controller -> getRequest ( ) -> isAjax ( ) ) { $ controller -> getRequest ( ) -> addHeader ( 'X-Pjax' , 'CurrentForm' ) ; } return $ responseNegotiator -> respond ( $ controller -> getRequest ( ) ) ; } return Controller :: curr ( ) -> redirect ( $ redirectLink ) ; }
7191	private function copyNotification ( Model \ SaleNotificationInterface $ source , Model \ SaleNotificationInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'type' , 'data' , 'sentAt' , 'details' ] ) ; }
887	private function needFixing ( Tokens $ tokens , $ index ) { if ( $ this -> isStrictOrNullableReturnTypeFunction ( $ tokens , $ index ) ) { return false ; } $ content = '' ; while ( ! $ tokens [ $ index ] -> equals ( ';' ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ content .= $ tokens [ $ index ] -> getContent ( ) ; } $ content = ltrim ( $ content , '(' ) ; $ content = rtrim ( $ content , ');' ) ; return 'null' === strtolower ( $ content ) ; }
7718	function meth_Conv_Prepare ( & $ Loc , $ StrConv ) { $ x = strtolower ( $ StrConv ) ; $ x = '+' . str_replace ( ' ' , '' , $ x ) . '+' ; if ( strpos ( $ x , '+esc+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvEsc = true ; } if ( strpos ( $ x , '+wsp+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvWS = true ; } if ( strpos ( $ x , '+js+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvJS = true ; } if ( strpos ( $ x , '+url+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUrl = true ; } if ( strpos ( $ x , '+utf8+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUtf8 = true ; } if ( strpos ( $ x , '+no+' ) !== false ) $ Loc -> ConvStr = false ; if ( strpos ( $ x , '+yes+' ) !== false ) $ Loc -> ConvStr = true ; if ( strpos ( $ x , '+nobr+' ) !== false ) { $ Loc -> ConvStr = true ; $ Loc -> ConvBr = false ; } }
5704	public function Field ( $ properties = array ( ) ) { if ( $ this -> isGrouped ( ) ) { $ this -> transformToInput ( ) ; } else { $ this -> transformToButton ( ) ; } return parent :: Field ( $ properties ) ; }
3242	public function getDisplayNameAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> displayName ; return isset ( $ this -> itemName ) ? $ this -> attributes [ $ this -> itemName ] : ( array_key_exists ( 'name' , $ this -> attributes ) ? $ this -> attributes [ 'name' ] : '' ) ; }
994	private function getDescription ( $ node ) { if ( $ node -> description ) { return $ node -> description -> value ; } if ( isset ( $ this -> options [ 'commentDescriptions' ] ) ) { $ rawValue = $ this -> getLeadingCommentBlock ( $ node ) ; if ( $ rawValue !== null ) { return BlockString :: value ( "\n" . $ rawValue ) ; } } return null ; }
4518	public function preFlush ( PreFlushEventArgs $ args ) { $ entities = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getScheduledEntityInsertions ( ) ; foreach ( $ entities as $ entity ) { if ( ! $ entity instanceof Parameter ) { continue ; } $ entity -> setValue ( serialize ( $ entity -> getValue ( ) ) ) ; } }
6255	public function searchPickupPoints ( $ postcode = null , $ street_address = null , $ country = null , $ service_provider = null , $ limit = 5 ) { if ( ( $ postcode == null && $ street_address == null ) || ( trim ( $ postcode ) == '' && trim ( $ street_address ) == '' ) ) { return '[]' ; } $ post_params = array ( 'postcode' => ( string ) $ postcode , 'address' => ( string ) $ street_address , 'country' => ( string ) $ country , 'service_provider' => ( string ) $ service_provider , 'limit' => ( int ) $ limit ) ; return $ this -> doPost ( '/pickup-points/search' , $ post_params ) ; }
11569	public static function search ( $ query , & $ results = array ( ) ) { $ attachments = static :: getInstance ( ) ; if ( ! empty ( $ query ) ) : $ words = explode ( ' ' , $ query ) ; foreach ( $ words as $ word ) { $ _results = $ attachments -> setListLookUpConditions ( "attachment_name" , $ word , 'OR' ) -> setListLookUpConditions ( "attachment_title" , $ word , 'OR' ) -> setListLookUpConditions ( "attachment_description" , $ word , 'OR' ) -> setListLookUpConditions ( "attachment_tags" , $ word , 'OR' ) ; } $ _results = $ attachments -> setListLookUpConditions ( "attachment_owner" , array ( $ attachments -> user -> get ( "user_name_id" ) ) , "AND" , true ) -> setListOrderBy ( "o.object_created_on" , "DESC" ) -> getObjectsList ( "attachment" ) ; $ rows = $ _results -> fetchAll ( ) ; $ browsable = array ( "image/jpg" , "image/jpeg" , "image/png" , "image/gif" ) ; $ documents = array ( "filterid" => "attachments" , "title" => "Documents" , "results" => array ( ) ) ; foreach ( $ rows as $ attachment ) { $ document = array ( "title" => $ attachment [ 'attachment_title' ] , "description" => "" , "type" => $ attachment [ 'object_type' ] , "object_uri" => $ attachment [ 'object_uri' ] ) ; if ( in_array ( $ attachment [ 'attachment_type' ] , $ browsable ) ) : $ document [ 'icon' ] = "/system/object/{$attachment['object_uri']}/resize/170/170" ; $ document [ 'link' ] = "/system/media/photo/view/{$attachment['object_uri']}" ; else : $ document [ 'media_uri' ] = $ attachment [ 'object_uri' ] ; $ document [ 'link' ] = "/system/object/{$attachment['object_uri']}" ; endif ; $ documents [ "results" ] [ ] = $ document ; } if ( ! empty ( $ documents [ "results" ] ) ) $ results [ ] = $ documents ; endif ; return true ; }
8011	private static function setParityBit ( $ byte ) { $ parity = 1 ; for ( $ i = 1 ; $ i < 8 ; $ i ++ ) { $ parity = ( $ parity + ( ( $ byte >> $ i ) & 1 ) ) % 2 ; } $ byte = $ byte | ( $ parity & 1 ) ; return $ byte ; }
5927	public function retrieveCategory ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/categories/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
4836	public function create_bill ( $ params ) { if ( ! isset ( $ params [ 'pre_authorization_id' ] ) ) { throw new GoCardless_ArgumentsException ( 'pre_authorization_id missing' ) ; } $ pre_auth = new GoCardless_PreAuthorization ( $ this , array ( 'id' => $ params [ 'pre_authorization_id' ] ) ) ; return $ pre_auth -> create_bill ( array ( 'amount' => $ params [ 'amount' ] ) ) ; }
6403	public function isValid ( ) { if ( $ this -> getFromDay ( ) == null || $ this -> getFromHour ( ) == null || $ this -> getToDay ( ) == null || $ this -> getToHour ( ) == null ) { return false ; } if ( $ this -> getFromDay ( ) < 1 || $ this -> getFromDay ( ) > 31 ) { return false ; } if ( $ this -> getToDay ( ) < 1 || $ this -> getToDay ( ) > 31 ) { return false ; } if ( $ this -> getFromHour ( ) > 24 || $ this -> getToHour ( ) > 24 ) { return false ; } if ( $ this -> getFromDay ( ) == $ this -> getToDay ( ) && $ this -> getFromHour ( ) >= $ this -> getToHour ( ) ) { return false ; } return true ; }
192	public function send ( ) { if ( $ this -> isSent ) { return ; } $ this -> trigger ( self :: EVENT_BEFORE_SEND ) ; $ this -> prepare ( ) ; $ this -> trigger ( self :: EVENT_AFTER_PREPARE ) ; $ this -> sendHeaders ( ) ; $ this -> sendContent ( ) ; $ this -> trigger ( self :: EVENT_AFTER_SEND ) ; $ this -> isSent = true ; }
2157	public function generate ( ) { if ( $ this -> youtube == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://youtu.be/' . $ this -> youtube . '" target="_blank" rel="noreferrer noopener">youtu.be/' . $ this -> youtube . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
3015	public function deletePost ( $ blogName , $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; $ path = $ this -> blogPath ( $ blogName , '/post/delete' ) ; return $ this -> postRequest ( $ path , $ options , false ) ; }
8738	protected function filterValues ( array $ values ) { $ attributes = $ this -> model -> translatableAttributes ( ) ; $ translatable = [ ] ; foreach ( $ attributes as $ key ) { if ( array_key_exists ( $ key , $ values ) ) { $ translatable [ $ key ] = $ values [ $ key ] ; unset ( $ values [ $ key ] ) ; } } return [ $ values , $ translatable ] ; }
9065	protected function checkMVC ( ) { $ viewResolver = $ this -> sm -> get ( 'ViewResolver' ) ; $ return = true ; if ( $ viewResolver instanceof ViewResolver \ AggregateResolver ) { if ( $ viewResolver -> count ( ) == 2 ) { $ defResolvers = array ( 'Zend\View\Resolver\TemplateMapResolver' , 'Zend\View\Resolver\TemplatePathStack' ) ; foreach ( $ viewResolver -> getIterator ( ) -> toArray ( ) as $ i => $ ro ) { if ( $ defResolvers [ $ i ] != get_class ( $ ro ) ) { $ return = false ; break ; } } } else { $ return = false ; } } else { $ return = false ; } $ viewTemplatePathStack = $ this -> sm -> get ( 'ViewTemplatePathStack' ) ; if ( ! $ viewTemplatePathStack instanceof ViewResolver \ TemplatePathStack ) { throw new \ Exception ( 'yimaTheme work with PathStack' ) ; } return $ return ; }
10764	public function generateText ( ) { $ result = 'SPD' . self :: DELIMITER . $ this -> version . self :: DELIMITER . $ this -> implodeContent ( ) ; if ( $ this -> appendCRC32 ) { $ result .= self :: DELIMITER . 'CRC32:' . sprintf ( '%x' , crc32 ( $ result ) ) ; } return $ result ; }
7083	public function method ( $ method = NULL ) { if ( $ method === NULL ) { return $ this -> _method ; } $ this -> _method = strtoupper ( $ method ) ; return $ this ; }
10522	protected function quoteIndex ( array $ cols ) { $ q = [ ] ; foreach ( $ cols as $ col ) { $ q [ ] = $ this -> quoteLeading ( $ col ) ; } return $ q ; }
8389	public function addLeftOuterJoin ( $ table , $ on ) { $ this -> leftOuterJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
8496	public function getFulfillmentPreview ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetFulfillmentPreviewRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetFulfillmentPreviewRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetFulfillmentPreview' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetFulfillmentPreviewResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
146	protected function moveWatch ( $ fromLiteral , $ toLiteral , $ node ) { if ( ! isset ( $ this -> watchChains [ $ toLiteral ] ) ) { $ this -> watchChains [ $ toLiteral ] = new RuleWatchChain ; } $ node -> moveWatch ( $ fromLiteral , $ toLiteral ) ; $ this -> watchChains [ $ fromLiteral ] -> remove ( ) ; $ this -> watchChains [ $ toLiteral ] -> unshift ( $ node ) ; }
10626	public static function docroot ( ) { if ( ! empty ( $ _SERVER [ 'DOCUMENT_ROOT' ] ) ) { $ docroot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; } else { $ docroot = str_replace ( '\\' , '/' , dirname ( __FILE__ ) ) ; } return $ docroot ; }
2133	public static function persist ( $ strKey , $ varValue ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> add ( $ strKey , $ varValue ) ; }
8025	public function addFree ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; $ this -> processDetails [ $ pid ] = $ processDetails ; $ this -> sockets [ $ pid ] = $ processDetails -> getSocket ( ) ; $ this -> registerFreeProcess ( $ processDetails ) ; return $ this ; }
5507	public function returnsByValue ( $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return value' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleByValue ( $ value ) ) ; }
5753	public function getRoleIdsForRoles ( array $ roles ) : array { if ( count ( $ roles ) == 0 ) { throw new \ InvalidArgumentException ( "Roles array must be populated." ) ; } $ roleIds = [ ] ; foreach ( $ roles as $ role ) { if ( null === $ roleIds [ ] = $ this -> getRoleIdForRole ( $ role ) ) { throw new \ InvalidArgumentException ( "Role $role does not exist" ) ; } } return $ roleIds ; }
3573	protected function setInstance ( Attribute $ attribute ) { if ( $ this -> has ( $ attribute -> getMetaKey ( ) ) ) { $ this -> update ( $ attribute ) ; } else { $ this -> items [ $ attribute -> getMetaKey ( ) ] = $ attribute ; } return $ this ; }
9356	public function withUri ( UriInterface $ uri , $ preserve = false ) { $ static = clone $ this ; $ static -> uri = $ uri ; if ( ! $ preserve && $ host = $ uri -> getHost ( ) ) { $ port = $ host . ':' . $ uri -> getPort ( ) ; $ host = $ uri -> getPort ( ) ? $ port : $ host ; $ static -> headers [ 'Host' ] = ( array ) $ host ; } return $ static ; }
2482	protected function generateQueryString ( array $ parameters ) { $ removedArrayCharacters = preg_replace ( '/%5B[0-9]+%5D=/' , '=' , http_build_query ( $ parameters ) ) ; $ removedDuplicatedEscapingForUrlPath = str_replace ( '%5C%5C%2F' , '%5C%2F' , $ removedArrayCharacters ) ; return $ removedDuplicatedEscapingForUrlPath ; }
9773	function readable ( ) : self { if ( ! $ this -> hasFlag ( 'directory' ) && ! $ this -> hasFlag ( 'file' ) ) throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , isReadable ( ) ) ; }
8428	public function getFileIcon ( $ fileType , $ iconLib = 'cmti' ) { switch ( $ iconLib ) { case 'cmti' : { return $ this -> getCmtiFileIcon ( $ fileType ) ; } case 'fa' : { return $ this -> getFaFileIcon ( $ fileType ) ; } } }
532	protected function resortChangelog ( $ changelog ) { foreach ( $ changelog as $ i => $ line ) { $ changelog [ $ i ] = rtrim ( $ line ) ; } $ changelog = array_filter ( $ changelog ) ; $ i = 0 ; ArrayHelper :: multisort ( $ changelog , function ( $ line ) use ( & $ i ) { if ( preg_match ( '/^- (Chg|Enh|Bug|New)( #\d+(, #\d+)*)?: .+/' , $ line , $ m ) ) { $ o = [ 'Bug' => 'C' , 'Enh' => 'D' , 'Chg' => 'E' , 'New' => 'F' ] ; return $ o [ $ m [ 1 ] ] . ' ' . ( ! empty ( $ m [ 2 ] ) ? $ m [ 2 ] : 'AAAA' . $ i ++ ) ; } return 'B' . $ i ++ ; } , SORT_ASC , SORT_NATURAL ) ; array_unshift ( $ changelog , '' ) ; $ changelog [ ] = '' ; $ changelog [ ] = '' ; return $ changelog ; }
9689	static function getDataType ( $ value ) { switch ( $ value ) { case "string" : return self :: $ STRING ; case "double" : return self :: $ DOUBLE ; case "float" : return self :: $ FLOAT ; case "integer" : return self :: $ INTEGER ; case "boolean" : return self :: $ BOOLEAN ; case "timestamp" : return self :: $ TIMESTAMP ; case "json" : return self :: $ JSON ; default : return null ; } }
2824	public function getExpirationDate ( $ currentDate ) { $ numberOfDays = Mage :: helper ( 'sheep_debug' ) -> getPersistLifetime ( ) ; return date ( self :: DATE_FORMAT , strtotime ( "-{$numberOfDays} days {$currentDate}" ) ) ; }
7419	protected function setRedirect ( string $ url = '' , int $ statusCode = 303 ) { $ this -> response -> redirect ( $ url , $ statusCode ) ; }
7184	private function getFindAvailableByCountryAndWeightQuery ( ) { if ( null === $ this -> findAvailableByCountryAndWeightQuery ) { $ qb = $ this -> getCollectionQueryBuilder ( ) ; $ this -> findAvailableByCountryAndWeightQuery = $ qb -> join ( 'o.prices' , 'p' ) -> join ( 'p.zone' , 'z' ) -> andWhere ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'z.countries' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'p.weight' , ':weight' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.enabled' , ':enabled' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.available' , ':available' ) ) -> addOrderBy ( 'o.position' , 'ASC' ) -> getQuery ( ) ; } return $ this -> findAvailableByCountryAndWeightQuery ; }
6373	public function filterBy ( string $ className ) : FluentIterable { return self :: from ( Iterables :: filterBy ( $ this , $ className ) ) ; }
11506	public function offsetSet ( $ slot , $ connection ) { if ( ! static :: isValid ( $ slot ) ) { throw new \ OutOfBoundsException ( "Invalid slot $slot for `$connection`" ) ; } $ this -> slots [ ( int ) $ slot ] = ( string ) $ connection ; }
8288	protected function loadModules ( ) { foreach ( $ this -> config [ "authModules" ] as $ name ) { try { $ instance = $ this -> container -> get ( $ name ) ; } catch ( \ League \ Container \ Exception \ NotFoundException $ e ) { if ( ! class_exists ( $ name ) ) { throw new \ RuntimeException ( "PicoAuth module not found: " . $ name ) ; } $ instance = new $ name ; } if ( ! is_subclass_of ( $ instance , Module \ AbstractAuthModule :: class , false ) ) { throw new \ RuntimeException ( "PicoAuth module class must inherit from AbstractAuthModule." ) ; } $ name = $ instance -> getName ( ) ; $ this -> modules [ $ name ] = $ instance ; } }
8047	public function send ( $ data ) { $ serialized = serialize ( $ data ) ; $ hdr = pack ( 'N' , strlen ( $ serialized ) ) ; $ buffer = $ hdr . $ serialized ; unset ( $ serialized ) ; unset ( $ hdr ) ; $ total = strlen ( $ buffer ) ; while ( $ total > 0 ) { $ sent = socket_write ( $ this -> socket , $ buffer ) ; if ( $ sent === FALSE ) { throw new SimpleSocketException ( 'Sending failed with: ' . socket_strerror ( socket_last_error ( $ this -> socket ) ) ) ; } $ total -= $ sent ; $ buffer = substr ( $ buffer , $ sent ) ; } }
10796	public function classifiedAnswer ( array $ data ) { $ id = isset ( $ data [ 'id' ] ) ? $ data [ 'id' ] : null ; if ( empty ( $ id ) ) { throw new \ Exception ( "Errore si sistema." ) ; } $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ documentRepository = $ main -> getDocumentEntityRepository ( ) ; $ classified = $ documentRepository -> getEntity ( $ id ) ; $ classifiedModel = $ this -> getServiceLocator ( ) -> get ( 'document.model.classifiedAdminListing' ) ; $ classifiedModel -> init ( $ classified , $ this -> getServiceLocator ( ) ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.classifiedanswer' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ data = array_merge ( $ form -> getData ( ) , array ( 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) , 'to' => $ classifiedModel -> email , 'fullname' => $ classifiedModel -> fullname , 'title' => $ classifiedModel -> title , 'address' => $ classifiedModel -> address ) ) ; $ event = new ClassifiedAnswerEvent ( __FUNCTION__ , null , $ data ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; }
181	public function getConverter ( ) { if ( $ this -> _converter === null ) { $ this -> _converter = Yii :: createObject ( AssetConverter :: className ( ) ) ; } elseif ( is_array ( $ this -> _converter ) || is_string ( $ this -> _converter ) ) { if ( is_array ( $ this -> _converter ) && ! isset ( $ this -> _converter [ 'class' ] ) ) { $ this -> _converter [ 'class' ] = AssetConverter :: className ( ) ; } $ this -> _converter = Yii :: createObject ( $ this -> _converter ) ; } return $ this -> _converter ; }
3502	private function initializeCurlResource ( ) : void { if ( ! $ this -> resource ) { $ this -> resource = curl_init ( ) ; curl_setopt ( $ this -> resource , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_POST , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_HTTP_VERSION , 3 ) ; } }
10519	public static function getBrowserUserAgentGenerated ( ) { static $ ua ; if ( isset ( $ ua ) ) { return $ ua ; } $ year = abs ( @ date ( 'Y' ) ) ; if ( $ year <= 2017 ) { return $ ua = self :: DEFAULT_USER_AGENT ; } $ user_agent = 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:[version].0) Gecko/20100101 Firefox/[version].0' ; $ month = abs ( @ date ( 'm' ) ) ; $ version = 51 ; $ currentYear = ( $ year - 2017 ) ; $ currentVersion = is_int ( $ month / 2 ) ? $ month / 2 : abs ( $ month / 2 + 0.5 ) ; $ version += $ currentYear + $ currentVersion ; return $ ua = str_replace ( '[version]' , $ version , $ user_agent ) ; }
4811	public function create ( ) { $ language = new ExpressionLanguage ( ) ; foreach ( $ this -> providers as $ provider ) { $ language -> registerProvider ( $ provider ) ; } return $ language ; }
7885	public function getData ( $ date , $ level = null ) { if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ data = LogViewer :: data ( $ date , $ level ) ; $ paginator = new Paginator ( $ data , $ this -> perPage ) ; $ path = ( new \ ReflectionClass ( $ paginator ) ) -> getProperty ( 'path' ) ; $ path -> setAccessible ( true ) ; $ path -> setValue ( $ paginator , URL :: route ( 'logviewer.index' ) . '/' . $ date . '/' . $ level ) ; if ( count ( $ data ) > $ paginator -> perPage ( ) ) { $ log = array_slice ( $ data , $ paginator -> firstItem ( ) - 1 , $ paginator -> perPage ( ) ) ; } else { $ log = $ data ; } return View :: make ( 'logviewer::data' , compact ( 'paginator' , 'log' ) ) ; }
8946	public function changePreference ( $ key , $ preference ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences/' . $ key ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ preference ) ; return $ response -> body ; }
414	public function setSecurePort ( $ value ) { if ( $ value != $ this -> _securePort ) { $ this -> _securePort = ( int ) $ value ; $ this -> _hostInfo = null ; } }
3153	public function storeTraceVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getTraceVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
632	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> update ( $ table , $ columns , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
9010	public function char ( int $ size = 36 , string $ charset = null ) : self { $ this -> type = 'char(' . $ size . ')' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
8287	protected function createContainer ( ) { $ configDir = $ this -> pico -> getConfigDir ( ) ; $ userContainer = $ configDir . "PicoAuth/container.php" ; if ( is_file ( $ userContainer ) && is_readable ( $ userContainer ) ) { $ this -> container = include $ userContainer ; if ( $ this -> container === false || ! ( $ this -> container instanceof \ League \ Container \ Container ) ) { throw new \ RuntimeException ( "The container.php does not return container instance." ) ; } } else { $ this -> container = include $ this -> pluginDir . '/src/container.php' ; } $ this -> container -> share ( 'configDir' , new \ League \ Container \ Argument \ RawArgument ( $ configDir ) ) ; $ this -> container -> share ( 'PicoAuth' , $ this ) ; if ( ! $ this -> config [ "rateLimit" ] ) { $ this -> container -> share ( 'RateLimit' , \ PicoAuth \ Security \ RateLimiting \ NullRateLimit :: class ) ; } }
11062	public static function isEncodingSupported ( $ encoding ) { $ encoding = strtolower ( $ encoding ) ; if ( isset ( static :: supportedEncodings ( ) [ $ encoding ] ) ) { return true ; } return false ; }
12834	private function generatePureCreatorMethod ( ServiceDefinition $ service ) : string { $ taggedAs = implode ( ', ' , $ service -> getTags ( ) ) ; $ classNormalized = $ this -> normalizeFqcn ( $ service -> getClass ( ) ) ; if ( $ service -> isSingleton ( ) ) { return <<<PHP /** * Get service {$service->getId()} (Singleton) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { if (isset(\$this->singletons['{$service->getId()}'])) { return \$this->singletons['{$service->getId()}']; } /** @noinspection OneTimeUseVariablesInspection */ \$service = \$this->singletons['{$service->getId()}'] = new $classNormalized({$this->buildInjectionParameters($this->container, $service->getInjection()->getCreatorInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; } return <<<PHP /** * Get a fresh instance of service "{$service->getId()}" (Prototype) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { \$this->prototypes['{$service->getId()}'] = (\$this->prototypes['{$service->getId()}'] ?? 0) + 1; /** @noinspection OneTimeUseVariablesInspection */ \$service = new $classNormalized({$this->buildInjectionParameters($this->container, $service->getInjection()->getCreatorInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; }
1455	protected function validateHasOne ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasOne ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasOneExpected ( $ key ) ) ; return false ; } $ identifier = $ relationship -> getData ( ) ; if ( ! $ identifier ) { return true ; } if ( ! $ this -> validateIdentifier ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateExists ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateAcceptable ( $ identifier , $ record , $ key , $ resource ) ) { return false ; } return true ; }
1273	public function isAmbiguous ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> AmbiguousAddressIndicator ) ; }
11137	protected function calculateDELETE ( ) { $ this -> query .= 'DELETE FROM ' ; $ this -> queryStringFromArray ( 'tables' , '' , ', ' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } }
12260	private function _cacheCustomFields ( $ class ) { $ customFieldsGroups = $ this -> em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> findBy ( array ( 'entity' => ( is_string ( $ class ) ) ? $ class : get_class ( $ class ) ) ) ; if ( ! $ customFieldsGroups ) { throw CustomFieldsHelperException :: customFieldsGroupNotFound ( ( is_string ( $ class ) ) ? $ class : get_class ( $ class ) ) ; } foreach ( $ customFieldsGroup as $ cfGroup ) { $ this -> _cacheCustomFields ( $ cfGroup ) ; } }
3617	public function setFanModeMinutesPerHour ( $ mode , $ serial_number = NULL ) { $ modes = explode ( ',' , $ mode ) ; $ mode = $ modes [ 0 ] ; $ duty_cycle = $ modes [ 1 ] ; return $ this -> _setFanMode ( $ mode , $ duty_cycle , NULL , $ serial_number ) ; }
2263	public function listTables ( $ strDatabase = null , $ blnNoCache = false ) { if ( $ blnNoCache || ! isset ( $ this -> arrCache [ $ strDatabase ] ) ) { $ strOldDatabase = $ this -> resConnection -> getDatabase ( ) ; if ( $ strDatabase !== null && $ strDatabase != $ strOldDatabase ) { $ this -> setDatabase ( $ strDatabase ) ; } $ this -> arrCache [ $ strDatabase ] = $ this -> resConnection -> getSchemaManager ( ) -> listTableNames ( ) ; if ( $ strDatabase !== null && $ strDatabase != $ strOldDatabase ) { $ this -> setDatabase ( $ strOldDatabase ) ; } } return $ this -> arrCache [ $ strDatabase ] ; }
5751	public function deleteByPrimaryKey ( $ primaryKeyValue , ? string $ returnField = null ) : ? string { if ( null === $ role = $ this -> getObjectById ( ( int ) $ primaryKeyValue ) ) { throw new Exceptions \ QueryResultsNotFoundException ( "Role not found: id $primaryKeyValue" ) ; } if ( ! $ role -> isDeletable ( ( int ) $ primaryKeyValue ) ) { throw new Exceptions \ UnallowedActionException ( "Role in use: id $primaryKeyValue" ) ; } return parent :: deleteByPrimaryKey ( $ primaryKeyValue , $ returnField ) ; }
7163	private function buildSaleItemsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasItems ( ) ) { return ; } foreach ( $ sale -> getItems ( ) as $ item ) { $ this -> view -> addItem ( $ this -> buildSaleItemLineView ( $ item ) ) ; } }
2911	public function xml2array ( $ xml , array & $ arr , $ parentKey = '' ) { if ( ! $ xml ) { return ; } if ( count ( $ xml -> children ( ) ) == 0 ) { $ arr [ $ parentKey ] = ( string ) $ xml ; } else { foreach ( $ xml -> children ( ) as $ key => $ item ) { $ key = $ parentKey ? $ parentKey . DS . $ key : $ key ; $ this -> xml2array ( $ item , $ arr , $ key ) ; } } return $ arr ; }
10287	protected function parseCrontab ( $ crontab ) { $ lines = preg_split ( '(\r\n|\r|\n)' , $ crontab ) ; $ this -> crontab = array ( ) ; foreach ( $ lines as $ line ) { $ line = trim ( $ line ) ; if ( ! empty ( $ line ) && ( $ line [ 0 ] !== '#' ) && ( $ line [ 0 ] !== ';' ) ) { $ this -> crontab [ ] = new Cronjob ( $ line ) ; } } }
267	protected function loadMessagesFromDb ( $ category , $ language ) { $ mainQuery = ( new Query ( ) ) -> select ( [ 'message' => 't1.message' , 'translation' => 't2.translation' ] ) -> from ( [ 't1' => $ this -> sourceMessageTable , 't2' => $ this -> messageTable ] ) -> where ( [ 't1.id' => new Expression ( '[[t2.id]]' ) , 't1.category' => $ category , 't2.language' => $ language , ] ) ; $ fallbackLanguage = substr ( $ language , 0 , 2 ) ; $ fallbackSourceLanguage = substr ( $ this -> sourceLanguage , 0 , 2 ) ; if ( $ fallbackLanguage !== $ language ) { $ mainQuery -> union ( $ this -> createFallbackQuery ( $ category , $ language , $ fallbackLanguage ) , true ) ; } elseif ( $ language === $ fallbackSourceLanguage ) { $ mainQuery -> union ( $ this -> createFallbackQuery ( $ category , $ language , $ fallbackSourceLanguage ) , true ) ; } $ messages = $ mainQuery -> createCommand ( $ this -> db ) -> queryAll ( ) ; return ArrayHelper :: map ( $ messages , 'message' , 'translation' ) ; }
11513	public function actionReset ( $ id , $ code ) { if ( ! $ this -> module -> enablePasswordRecovery ) { throw new NotFoundHttpException ; } $ token = $ this -> finder -> findToken ( [ 'user_id' => $ id , 'code' => $ code , 'type' => Token :: TYPE_RECOVERY ] ) -> one ( ) ; if ( $ token === null || $ token -> isExpired || $ token -> user === null ) { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'Recovery link is invalid or expired. Please try requesting a new one.' ) ) ; return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Invalid or expired link' ) , 'module' => $ this -> module , ] ) ; } $ model = \ Yii :: createObject ( [ 'class' => RecoveryForm :: className ( ) , 'scenario' => 'reset' , ] ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> getRequest ( ) -> post ( ) ) && $ model -> resetPassword ( $ token ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Password has been changed' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'reset' , [ 'model' => $ model , ] ) ; }
7423	protected function registerWidget ( $ name = null , $ id = null ) { if ( $ name === null ) { $ name = $ this -> getDefaultJsWidgetName ( ) ; } $ this -> _registerBundle ( ) ; if ( ! $ this -> isAjaxCrud && $ this -> getUpdateUrl ( ) ) { if ( $ id === null ) { $ id = $ this -> options [ 'id' ] ; } $ options = empty ( $ this -> clientOptions ) ? '' : Json :: htmlEncode ( [ 'updateUrl' => Url :: to ( $ this -> getUpdateUrl ( ) ) ] ) ; $ js = "jQuery('#$id').$name($options);" ; $ this -> getView ( ) -> registerJs ( $ js ) ; } }
2510	public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( self :: Q_G_ERR ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ errorCatNode = $ domXpath -> query ( self :: Q_G_CAT ) -> item ( 0 ) ; $ analyzeResponse -> setStatus ( $ this -> makeStatusForPotentiallyNonExistent ( $ errorCatNode ) ) ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( self :: Q_G_MSG ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'general' ) ; } $ errorCodeNodeList = $ domXpath -> query ( self :: Q_D_ERR ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ errorCatNode = $ domXpath -> query ( self :: Q_D_CAT ) -> item ( 0 ) ; $ analyzeResponse -> setStatus ( $ this -> makeStatusForPotentiallyNonExistent ( $ errorCatNode ) ) ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( self :: Q_D_MSG ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) , 'deficient_fop' ) ; } return $ analyzeResponse ; }
6594	public function getMethodDocumentation ( \ ReflectionMethod $ method ) { $ comment = $ this -> getMethodComment ( $ method ) ; $ summary = $ this -> getSummary ( $ comment ) ; $ parameters = $ this -> getParameters ( $ comment ) ; $ returnType = $ this -> getReturnType ( $ comment ) ; $ documentation = [ ] ; if ( $ summary ) { $ documentation [ 'summary' ] = $ summary ; $ description = $ this -> getDescription ( $ comment ) ; if ( $ description ) { $ documentation [ 'description' ] = $ description ; } } $ documentation [ 'parameters' ] = $ parameters ; $ documentation [ 'returnType' ] = $ returnType ; return $ documentation ; }
1444	protected function getStubFor ( $ implementationType ) { return sprintf ( '%s/%s/%s.stub' , $ this -> stubsDirectory , $ implementationType , Str :: dasherize ( $ this -> type ) ) ; }
5008	public function trigger ( $ event , $ target = null ) { if ( empty ( $ this -> _template ) || ! is_string ( $ this -> _template ) ) { throw new \ InvalidArgumentException ( 'ContentCollector must have a template-name' ) ; } $ responseCollection = $ this -> getController ( ) -> getEventManager ( ) -> trigger ( $ event , $ target ) ; $ viewModel = new ViewModel ( ) ; $ viewModel -> setTemplate ( $ this -> _template ) ; foreach ( $ responseCollection as $ i => $ response ) { if ( is_string ( $ response ) ) { $ template = $ response ; $ response = new ViewModel ( array ( 'target' => $ target ) ) ; $ response -> setTemplate ( $ template ) ; } $ viewModel -> addChild ( $ response , $ this -> _captureTo . $ i ) ; } return $ viewModel ; }
10500	public function lte ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value !== null && $ this -> value <= $ value ) { return true ; } return false ; }
4380	protected function visualWhiteSpace ( $ str ) { $ str = \ preg_replace_callback ( '/(\r\n|\r|\n)/' , array ( $ this , 'visualWhiteSpaceCallback' ) , $ str ) ; $ str = \ preg_replace ( '#(<br />)?\n$#' , '' , $ str ) ; $ str = \ str_replace ( "\t" , '<span class="ws_t">' . "\t" . '</span>' , $ str ) ; return $ str ; }
3224	function getThumbnail ( $ path , $ format , $ size ) { Path :: checkArgNonRoot ( "path" , $ path ) ; Checker :: argString ( "format" , $ format ) ; Checker :: argString ( "size" , $ size ) ; if ( ! in_array ( $ format , array ( "jpeg" , "png" ) ) ) { throw new \ InvalidArgumentException ( "Invalid 'format': " . Util :: q ( $ format ) ) ; } if ( ! in_array ( $ size , array ( "xs" , "s" , "m" , "l" , "xl" ) ) ) { throw new \ InvalidArgumentException ( "Invalid 'size': " . Util :: q ( $ size ) ) ; } $ url = $ this -> buildUrlForGetOrPut ( $ this -> contentHost , $ this -> appendFilePath ( "1/thumbnails" , $ path ) , array ( "size" => $ size , "format" => $ format ) ) ; $ curl = $ this -> mkCurl ( $ url ) ; $ metadataCatcher = new DropboxMetadataHeaderCatcher ( $ curl -> handle ) ; $ curl -> set ( CURLOPT_RETURNTRANSFER , true ) ; $ response = $ curl -> exec ( ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ metadata = $ metadataCatcher -> getMetadata ( ) ; return array ( $ metadata , $ response -> body ) ; }
1773	public function validate ( ) { $ varValue = $ this -> validator ( $ this -> getPost ( $ this -> strName ) ) ; if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } $ this -> varValue = $ varValue ; }
9132	protected function validate ( $ config , $ name , $ path ) { if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The definition of "%s" in "%s" must be a YAML array.' , $ name , $ path ) ) ; } if ( $ extraKeys = array_diff ( array_keys ( $ config ) , self :: $ availableKeys ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The routing file "%s" contains unsupported keys for "%s": "%s". Expected one of: "%s".' , $ path , $ name , implode ( '", "' , $ extraKeys ) , implode ( '", "' , self :: $ availableKeys ) ) ) ; } if ( isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The business rule file "%s" must not specify both the "resource" key and the "expression" key for "%s". Choose between an import and a rule definition.' , $ path , $ name ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'type' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "type" key for the rule definition "%s" in "%s" is unsupported. It is only available for imports in combination with the "resource" key.' , $ name , $ path ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && ! isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'You must define an "expression" for the rule "%s" in file "%s".' , $ name , $ path ) ) ; } if ( isset ( $ config [ 'tags' ] ) && ! is_array ( $ config [ 'tags' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } elseif ( isset ( $ config [ 'tags' ] ) ) { foreach ( $ config [ 'tags' ] as $ tag ) { if ( ! isset ( $ tag [ 'name' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } } } }
5663	private function dequote ( $ quoted ) { if ( preg_match ( '/^(\'([^\']*)\'|"([^"]*)")$/' , $ quoted , $ matches ) ) { return isset ( $ matches [ 3 ] ) ? $ matches [ 3 ] : $ matches [ 2 ] ; } return $ quoted ; }
9019	public function getKeywords ( $ string , $ amount = 10 ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ keywords = $ analysis -> getKeyValuesByFrequency ( ) ; return array_slice ( $ keywords , 0 , $ amount ) ; }
3441	protected function normalizePropertyFormat ( ) { if ( empty ( $ this -> fields [ 'PROPERTIES' ] ) ) { return ; } foreach ( $ this -> fields [ 'PROPERTIES' ] as $ code => $ prop ) { $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE' ] = $ prop [ 'VALUE' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_VALUE' ] = $ prop [ '~VALUE' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ 'DESCRIPTION' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ '~DESCRIPTION' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE_ID' ] = $ prop [ 'PROPERTY_VALUE_ID' ] ; } }
10950	private function xorTokens ( $ token1 , $ token2 ) { $ n1 = StringHelper :: byteLength ( $ token1 ) ; $ n2 = StringHelper :: byteLength ( $ token2 ) ; if ( $ n1 > $ n2 ) { $ token2 = str_pad ( $ token2 , $ n1 , $ token2 ) ; } elseif ( $ n1 < $ n2 ) { $ token1 = str_pad ( $ token1 , $ n2 , $ n1 === 0 ? ' ' : $ token1 ) ; } return $ token1 ^ $ token2 ; }
10739	public function supports ( $ query ) { foreach ( $ this -> engines as $ eachEngine ) { if ( $ eachEngine -> supports ( $ query ) ) { return true ; } } return false ; }
1589	protected function invoke ( string $ hook , ... $ arguments ) { if ( ! method_exists ( $ this , $ hook ) ) { return null ; } $ result = $ this -> { $ hook } ( ... $ arguments ) ; return $ this -> isInvokedResult ( $ result ) ? $ result : null ; }
9377	protected function extract ( $ filepath , array $ data ) { extract ( $ data ) ; ob_start ( ) ; include $ filepath ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; return $ contents ; }
2557	protected function loadMopDetails ( MopInfo $ options ) { $ this -> mopDetails = new MopDetails ( ) ; if ( $ this -> checkAnyNotEmpty ( $ options -> fopCode , $ options -> fopStatus ) ) { $ this -> mopDetails -> fopPNRDetails = new FopPNRDetails ( $ options -> fopCode , $ options -> fopStatus ) ; } if ( ! empty ( $ options -> freeFlowText ) ) { $ this -> mopDetails -> oldFopFreeflow = new OldFopFreeflow ( $ options -> freeFlowText , $ options -> freeFlowEncoding ) ; } if ( ! empty ( $ options -> supplementaryData ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_DATA_INFORMATION , $ options -> supplementaryData ) ; } if ( ! empty ( $ options -> supplementarySwitches ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_SWITCH_INFORMATION , $ options -> supplementarySwitches ) ; } }
9948	public function getColumnDimension ( $ pColumn , $ create = true ) { $ pColumn = strtoupper ( $ pColumn ) ; if ( ! isset ( $ this -> columnDimensions [ $ pColumn ] ) ) { if ( ! $ create ) { return null ; } $ this -> columnDimensions [ $ pColumn ] = new ColumnDimension ( $ pColumn ) ; if ( Coordinate :: columnIndexFromString ( $ this -> cachedHighestColumn ) < Coordinate :: columnIndexFromString ( $ pColumn ) ) { $ this -> cachedHighestColumn = $ pColumn ; } } return $ this -> columnDimensions [ $ pColumn ] ; }
8465	public static function getUriMethods ( ) { $ root = str_replace ( $ _SERVER [ 'DOCUMENT_ROOT' ] , '' , getcwd ( ) ) ; $ subfolder = trim ( $ root , '/' ) ; return trim ( str_replace ( $ subfolder , '' , self :: getUri ( ) ) , '/' ) ; }
5688	public function getFormByImage ( $ selector ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> hasImage ( $ selector ) ) { return $ this -> forms [ $ i ] ; } } return ; }
11124	public static function create ( $ notify ) { switch ( true ) { case $ notify === NotifyInterface :: STDOUT : return new NotifyStdout ( ) ; case $ notify === NotifyInterface :: LOGGER : return new NotifyLogger ( PrettyLogger :: create ( ) ) ; case $ notify === NotifyInterface :: BLACKHOLE : return new NotifyBlackhole ( ) ; case $ notify instanceof Output : return new NotifyConsole ( $ notify ) ; case $ notify instanceof LoggerInterface : return new NotifyLogger ( $ notify ) ; default : throw InvalidArgumentException :: forNotSupportedNotifier ( ) ; } }
3561	protected function getMutatedType ( $ value , $ dir = 'setter' ) { foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ this -> getValueType ( $ value ) == $ mutated || $ value instanceof $ mutated ) { return $ mutated ; } } }
2455	public function copyAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not copyable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; if ( isset ( $ arrClipboard [ $ this -> strTable ] ) && \ is_array ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] ) ) { foreach ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] as $ id ) { $ this -> intId = $ id ; $ id = $ this -> copy ( true ) ; Input :: setGet ( 'pid' , $ id ) ; Input :: setGet ( 'mode' , 1 ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
9688	public function det ( ) { if ( $ this -> m == $ this -> n ) { $ d = $ this -> pivsign ; for ( $ j = 0 ; $ j < $ this -> n ; ++ $ j ) { $ d *= $ this -> LU [ $ j ] [ $ j ] ; } return $ d ; } throw new CalculationException ( Matrix :: MATRIX_DIMENSION_EXCEPTION ) ; }
8540	public function setmember ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'member' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12922	public function getForeignDataItems ( ) { if ( ! isset ( $ this -> _foreignDataItems ) ) { $ this -> _foreignDataItems = [ ] ; $ this -> trigger ( self :: EVENT_LOAD_FOREIGN_DATA_ITEMS ) ; } return $ this -> _foreignDataItems ; }
8778	public function redirect ( $ data = null , int $ statusCode = 301 , $ secure = false ) { if ( substr ( $ data , 0 , 4 ) === 'http' || substr ( $ data , 0 , 5 ) === 'https' ) { header ( 'Location: ' . $ data , true , $ statusCode ) ; } else { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . $ data : $ this -> url ; header ( 'Location: ' . $ this -> getUrl ( $ data , $ secure ) , true , $ statusCode ) ; } die ( ) ; }
7383	public static function toValues ( $ input , array $ include = [ ] ) { if ( ! is_array ( $ input ) && ! is_object ( $ input ) ) { throw new InvalidArgumentException ( 'input must be an associative array or traversable object' ) ; } $ sqlStrs = [ ] ; if ( count ( $ include ) ) { foreach ( $ include as $ i ) { if ( array_key_exists ( $ i , $ input ) ) { $ sqlStrs [ ] = '`' . $ i . '` = VALUES(`' . $ i . '`)' ; } } } else { foreach ( $ input as $ k => & $ v ) { $ sqlStrs [ ] = '`' . $ k . '` = VALUES(`' . $ k . '`)' ; } } return implode ( ",\n" , $ sqlStrs ) ; }
4844	public static function singularize ( $ string ) { if ( substr ( $ string , - 1 ) == 's' ) { return substr ( $ string , 0 , - 1 ) ; } elseif ( substr ( $ string , - 1 ) == 'i' ) { return substr ( $ string , 0 , - 1 ) . 'us' ; } else { return $ string ; } }
6293	private function scanThemes ( ) { $ themeDirectories = glob ( $ this -> basePath . '/*' , GLOB_ONLYDIR ) ; $ themes = [ ] ; foreach ( $ themeDirectories as $ themePath ) { $ json = $ themePath . '/theme.json' ; if ( file_exists ( $ json ) ) { $ contents = file_get_contents ( $ json ) ; if ( ! $ contents === false ) { $ th = $ this -> parseThemeInfo ( json_decode ( $ contents , true ) ) ; $ themes [ $ th -> getDirectory ( ) ] = $ th ; } } } $ this -> themes = $ themes ; if ( count ( $ themes ) && ! $ this -> activeTheme ) { $ this -> set ( array_keys ( $ themes ) [ 0 ] ) ; } }
6820	protected function writeInvoiceTaxesLine ( ) { $ sale = $ this -> invoice -> getSale ( ) ; $ date = $ sale -> getCreatedAt ( ) ; $ credit = $ this -> invoice -> getType ( ) === InvoiceTypes :: TYPE_CREDIT ; foreach ( $ this -> invoice -> getTaxesDetails ( ) as $ detail ) { $ amount = $ this -> round ( $ detail [ 'amount' ] ) ; if ( 0 === $ this -> compare ( $ amount , 0 ) ) { continue ; } $ account = $ this -> getTaxAccountNumber ( $ detail [ 'rate' ] , $ this -> invoice -> getNumber ( ) ) ; if ( $ credit ) { $ this -> writer -> credit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance -= $ amount ; } else { $ this -> writer -> debit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance += $ amount ; } } }
6759	public function process ( ContainerBuilder $ container ) { if ( ! $ container -> has ( $ this -> registry ) ) { return ; } $ definition = $ container -> findDefinition ( $ this -> registry ) ; $ taggedServices = $ container -> findTaggedServiceIds ( $ this -> tag ) ; foreach ( $ taggedServices as $ id => $ tags ) { $ arguments = [ new Reference ( $ id ) ] ; if ( $ this -> withPriority ) { $ arguments [ ] = $ this -> resolvePriority ( $ tags ) ; } $ definition -> addMethodCall ( $ this -> method , $ arguments ) ; } }
7442	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } return array ( 'group' => $ group , ) ; }
10660	public function withHeaders ( array $ headers ) { $ object = clone $ this ; $ object -> configs [ 'headers' ] = [ ] ; $ object -> inProcessingLoop = true ; $ object -> replaceHeaders ( $ headers ) ; $ object -> inProcessingLoop = true ; return $ object -> buildConfigClient ( ) ; }
8744	protected function runLoop ( ) { while ( $ this -> isListening ) { $ this -> stream -> select ( ) ; if ( true === $ this -> charSequenceEnabled && null !== $ this -> escapePressedAt ) { if ( $ this -> escapeKeyHasExpired ( ) ) { $ this -> disableKeySequence ( ) ; $ this -> setCurrentKey ( $ this -> matcher -> getKey ( $ this -> matcher -> getEscapeKey ( ) ) ) ; $ this -> dispatchKeyPressEvents ( $ this -> getCurrentKey ( ) ) ; } } if ( $ this -> stream -> isAvailable ( ) ) { $ char = $ this -> stream -> getChar ( ) ; if ( $ this -> matcher -> getEscapeKey ( ) === $ char ) { $ this -> enableKeySequence ( ) ; $ this -> setCurrentKey ( $ char ) ; } else { $ this -> escapePressedAt = null ; if ( $ this -> charSequenceEnabled ) { $ this -> concatCurrentKey ( $ char ) ; $ mapped = $ this -> matcher -> getKey ( $ this -> getCurrentKey ( ) ) ; if ( $ mapped ) { $ this -> setCurrentKey ( $ mapped ) ; $ this -> disableKeySequence ( ) ; } else { continue ; } } else { if ( $ this -> matcher -> isBasicLatin ( $ char ) ) { continue ; } else { $ this -> setCurrentKey ( $ this -> matcher -> getKey ( $ char ) ? : $ char ) ; } } $ this -> dispatchKeyPressEvents ( $ this -> getCurrentKey ( ) ) ; } } } return $ this ; }
2859	public function getHttpMethodsSelect ( ) { $ options = $ this -> getHttpMethodOptions ( ) ; array_unshift ( $ options , array ( 'value' => '' , 'label' => 'Any' ) ) ; $ select = $ this -> getLayout ( ) -> createBlock ( 'core/html_select' ) ; $ select -> setName ( 'method' ) -> setId ( 'method' ) -> setValue ( $ this -> getRequest ( ) -> getParam ( 'method' ) ) -> setOptions ( $ options ) ; return $ select -> getHtml ( ) ; }
11212	protected function getFromLookup ( $ key ) { if ( $ key === $ this -> cache_key || $ this -> hasInLookup ( $ key ) ) { return $ this -> getFromRegistry ( $ this -> cache_reg , $ key ) ; } return null ; }
10845	protected function refreshProductBuyPrices ( ProductInterface $ product ) { $ buyPrice = $ product -> getBuyPrice ( ) ; $ grossAmount = $ buyPrice -> getGrossAmount ( ) ; $ taxRate = $ product -> getBuyPriceTax ( ) -> getValue ( ) ; $ netAmount = TaxHelper :: calculateNetPrice ( $ grossAmount , $ taxRate ) ; $ buyPrice -> setTaxRate ( $ taxRate ) ; $ buyPrice -> setTaxAmount ( $ grossAmount - $ netAmount ) ; $ buyPrice -> setNetAmount ( $ netAmount ) ; }
1802	public function initPicker ( PickerInterface $ picker ) { if ( ! empty ( $ _GET [ 'act' ] ) ) { return null ; } $ provider = $ picker -> getCurrentProvider ( ) ; if ( ! $ provider instanceof DcaPickerProviderInterface || $ provider -> getDcaTable ( ) != $ this -> strTable ) { return null ; } $ attributes = $ provider -> getDcaAttributes ( $ picker -> getConfig ( ) ) ; $ this -> objPicker = $ picker ; $ this -> strPickerFieldType = $ attributes [ 'fieldType' ] ; $ this -> objPickerCallback = function ( $ value ) use ( $ picker , $ provider ) { return $ provider -> convertDcaValue ( $ picker -> getConfig ( ) , $ value ) ; } ; if ( isset ( $ attributes [ 'value' ] ) ) { $ this -> arrPickerValue = ( array ) $ attributes [ 'value' ] ; } return $ attributes ; }
7936	public function getSeeOffers ( $ countryDestination , $ countryCurrencyPrice , $ quantity ) { return json_decode ( self :: getClient ( ) -> getSeeOffers ( $ this -> domain , $ countryDestination , $ countryCurrencyPrice , $ quantity ) ) ; }
9246	private function replaceOnce ( $ search , $ replace , $ subject ) { $ pos = strpos ( $ subject , $ search ) ; if ( $ pos !== false ) { $ subject = substr_replace ( $ subject , $ replace , $ pos , strlen ( $ search ) ) ; } return $ subject ; }
3465	public function post ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: post ( $ route ) ) ; }
6420	public function stop ( ) : Stopwatch { $ tick = $ this -> ticker -> read ( ) ; Preconditions :: checkState ( $ this -> isRunning , 'This stopwatch is already stopped.' ) ; $ this -> isRunning = false ; $ this -> elapsedMicros += ( $ tick - $ this -> startTick ) ; return $ this ; }
10661	public function withoutCookie ( $ cookieName = null ) { $ object = clone $ this ; if ( ! $ this -> configs [ 'cookies' ] instanceof CookieJarInterface ) { return $ object ; } if ( ! $ cookieName ) { unset ( $ object -> configs [ 'cookies' ] ) ; } else { if ( ! is_array ( $ cookieName ) ) { $ cookieName = [ $ cookieName ] ; } $ cookies = $ this -> configs [ 'cookies' ] -> toArray ( ) ; foreach ( $ cookieName as $ cookie ) { if ( ! is_string ( $ cookie ) || ! $ cookie ) { continue ; } unset ( $ cookies [ $ cookie ] ) ; } $ this -> configs [ 'cookies' ] = new CookieJar ( $ cookies ) ; } return $ object -> buildConfigClient ( ) ; }
3292	public function twitter ( ) { if ( is_null ( $ this -> title ) ) { $ this -> title = config ( 'laravel-share.services.twitter.text' ) ; } $ base = config ( 'laravel-share.services.twitter.uri' ) ; $ url = $ base . '?text=' . urlencode ( $ this -> title ) . '&url=' . $ this -> url ; $ this -> buildLink ( 'twitter' , $ url ) ; return $ this ; }
11838	public function set ( $ key , $ value ) { if ( $ this -> cacheEnabled ) { $ this -> cacheEngine -> set ( $ key , $ value ) ; } }
137	public function install ( RepositoryInterface $ repo , InstallOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; $ installer -> install ( $ repo , $ package ) ; $ this -> markForNotification ( $ package ) ; }
6947	private function getOutstandingExpiredDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; $ qb -> join ( 'o.paymentTerm' , 't' ) -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ qb -> expr ( ) -> lte ( 'o.outstandingDate' , ':today' ) , $ this -> getDueClauses ( ) ) ) -> addOrderBy ( 'o.outstandingDate' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'today' , ( new \ DateTime ( ) ) -> setTime ( 23 , 59 , 59 ) , Type :: DATETIME ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; $ this -> setDueParameters ( $ qb ) ; return $ qb ; }
6472	public function getBestEncodingMatch ( IMediaTypeFormatter $ formatter , array $ acceptCharsetHeaders , ? MediaTypeHeaderValue $ mediaTypeHeader ) : ? string { $ rankedAcceptCharsetHeaders = $ this -> rankAcceptCharsetHeaders ( $ acceptCharsetHeaders ) ; foreach ( $ rankedAcceptCharsetHeaders as $ acceptCharsetHeader ) { foreach ( $ formatter -> getSupportedEncodings ( ) as $ supportedEncoding ) { $ charset = $ acceptCharsetHeader -> getCharset ( ) ; if ( $ charset === '*' || strcasecmp ( $ charset , $ supportedEncoding ) === 0 ) { return $ supportedEncoding ; } } } if ( $ mediaTypeHeader === null || $ mediaTypeHeader -> getCharset ( ) === null ) { return null ; } foreach ( $ formatter -> getSupportedEncodings ( ) as $ supportedEncoding ) { $ charset = $ mediaTypeHeader -> getCharset ( ) ; if ( $ charset === '*' || strcasecmp ( $ charset , $ supportedEncoding ) === 0 ) { return $ supportedEncoding ; } } return null ; }
2002	public static function getVersion ( string $ packageName ) : string { $ version = Versions :: getVersion ( $ packageName ) ; return static :: parseVersion ( $ version ) ; }
11381	public function render ( FormInterface $ form ) { if ( method_exists ( $ form , 'prepare' ) ) { $ form -> prepare ( ) ; } if ( ! $ form -> getAttribute ( 'role' ) ) { $ form -> setAttribute ( 'role' , 'form' ) ; } $ formContent = '' ; foreach ( $ form as $ element ) { if ( $ element instanceof FieldsetInterface ) { $ formContent .= $ this -> getView ( ) -> formCollection ( $ element ) ; } else { $ element -> setOption ( '_form' , $ form ) ; $ formContent .= $ this -> getView ( ) -> formRow ( $ element ) ; } } return $ this -> openTag ( $ form ) . $ formContent . $ this -> closeTag ( ) ; }
1217	public static function slice ( $ value , $ start = null , $ stop = null , $ step = 1 ) { if ( ! Utils :: isArray ( $ value ) && ! is_string ( $ value ) ) { throw new \ InvalidArgumentException ( 'Expects string or array' ) ; } return self :: sliceIndices ( $ value , $ start , $ stop , $ step ) ; }
1644	public function simplify ( Polyline $ polyline ) : Polyline { $ counterPoints = $ polyline -> getNumberOfPoints ( ) ; if ( $ counterPoints < 3 ) { return clone $ polyline ; } $ result = new Polyline ( ) ; $ bearingCalc = new BearingEllipsoidal ( ) ; $ points = $ polyline -> getPoints ( ) ; $ index = 0 ; $ result -> addPoint ( $ points [ $ index ] ) ; do { $ index ++ ; if ( $ index === ( $ counterPoints - 1 ) ) { $ result -> addPoint ( $ points [ $ index ] ) ; break ; } $ bearing1 = $ bearingCalc -> calculateBearing ( $ points [ $ index - 1 ] , $ points [ $ index ] ) ; $ bearing2 = $ bearingCalc -> calculateBearing ( $ points [ $ index ] , $ points [ $ index + 1 ] ) ; $ bearingDifference = min ( fmod ( $ bearing1 - $ bearing2 + 360 , 360 ) , fmod ( $ bearing2 - $ bearing1 + 360 , 360 ) ) ; if ( $ bearingDifference > $ this -> bearingAngle ) { $ result -> addPoint ( $ points [ $ index ] ) ; } } while ( $ index < $ counterPoints ) ; return $ result ; }
6494	private function rankAcceptMediaTypeHeaders ( array $ mediaTypeHeaders ) : array { usort ( $ mediaTypeHeaders , [ $ this , 'compareAcceptMediaTypeHeaders' ] ) ; $ rankedMediaTypeHeaders = array_filter ( $ mediaTypeHeaders , [ $ this , 'filterZeroScores' ] ) ; return array_values ( $ rankedMediaTypeHeaders ) ; }
842	public function offsetSet ( $ index , $ newval ) { $ this -> blockEndCache = [ ] ; if ( ! $ this [ $ index ] || ! $ this [ $ index ] -> equals ( $ newval ) ) { $ this -> changed = true ; if ( isset ( $ this [ $ index ] ) ) { $ this -> unregisterFoundToken ( $ this [ $ index ] ) ; } $ this -> registerFoundToken ( $ newval ) ; } parent :: offsetSet ( $ index , $ newval ) ; }
12652	public function getPageTexts ( $ language ) { if ( ! isset ( $ this -> contents [ $ language ] ) ) { $ this -> contents [ $ language ] = $ this -> readFileContents ( $ language ) ; } return $ this -> contents [ $ language ] ; }
8263	protected function onStateMismatch ( ) { $ this -> logger -> warning ( "OAuth2 response state mismatch: provider: {provider} from {addr}" , array ( "provider" => get_class ( $ this -> provider ) , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] ) ) ; $ this -> session -> remove ( "oauth2state" ) ; $ this -> session -> addFlash ( "error" , "Invalid OAuth response." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
6539	public function transform ( $ iterator ) { if ( null === $ iterator ) { return array ( ) ; } if ( is_array ( $ iterator ) ) { return $ iterator ; } if ( ! $ iterator instanceof Iterator ) { throw new TransformationFailedException ( 'Expected a Yucca\Component\Iterator\Iterator object.' ) ; } return $ iterator -> getArray ( ) ; }
3422	public function count ( ) { if ( $ this -> queryShouldBeStopped ) { return 0 ; } $ queryType = 'UserQuery::count' ; $ filter = $ this -> normalizeFilter ( ) ; $ callback = function ( ) use ( $ filter ) { return ( int ) $ this -> bxObject -> getList ( $ order = 'ID' , $ by = 'ASC' , $ filter , [ 'NAV_PARAMS' => [ 'nTopCount' => 0 , ] , ] ) -> NavRecordCount ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'filter' ) , $ callback ) ; }
483	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ time = $ this -> beginCommand ( 'create' . ( $ unique ? ' unique' : '' ) . " index $name on $table (" . implode ( ',' , ( array ) $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
5867	public static function getOrientation ( $ fileName ) { $ orientation = 1 ; $ metadata = static :: getMetadata ( $ fileName ) ; if ( isset ( $ metadata [ 'Orientation' ] ) ) { $ orientation = $ metadata [ 'Orientation' ] ; } return $ orientation ; }
5651	public function explainFlag ( $ flags , $ explanation ) { $ flags = is_array ( $ flags ) ? $ flags : array ( $ flags ) ; $ this -> flag_sets [ ] = $ flags ; $ this -> explanations [ ] = $ explanation ; }
3530	public static function sendUnrealClientPostRequest ( $ endpoint , $ params = null , $ authorization = self :: EPIC_LAUNCHER_AUTHORIZATION , $ oauth = false ) { $ client = new Client ( [ 'http_errors' => false ] ) ; try { $ response = $ client -> post ( $ endpoint , [ 'form_params' => $ params , 'headers' => [ 'User-Agent' => self :: UNREAL_CLIENT_USER_AGENT , 'Authorization' => ( ! $ oauth ) ? 'basic ' . $ authorization : 'bearer ' . $ authorization , 'X-Epic-Device-ID' => self :: generateDeviceId ( ) ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
4241	public function onError ( Event $ error ) { if ( $ this -> debug -> getCfg ( 'collect' ) ) { $ this -> error = $ error ; $ errInfo = $ error [ 'typeStr' ] . ': ' . $ error [ 'file' ] . ' (line ' . $ error [ 'line' ] . ')' ; $ errMsg = $ error [ 'message' ] ; if ( $ error [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ) { $ this -> debug -> error ( $ errInfo . ': ' , $ errMsg ) ; } else { $ this -> debug -> warn ( $ errInfo . ': ' , $ errMsg ) ; } $ error [ 'continueToNormal' ] = false ; $ error [ 'inConsole' ] = true ; $ error [ 'email' ] = false ; $ this -> error = null ; } elseif ( $ this -> debug -> getCfg ( 'output' ) ) { $ error [ 'email' ] = false ; $ error [ 'inConsole' ] = false ; } else { $ error [ 'inConsole' ] = false ; } }
10986	public static function getMaxUploadSize ( $ max_size = 0 ) { $ post_max_size = Tools :: unformatBytes ( ini_get ( 'post_max_size' ) ) ; $ upload_max_filesize = Tools :: unformatBytes ( ini_get ( 'upload_max_filesize' ) ) ; if ( $ max_size > 0 ) { $ result = min ( $ post_max_size , $ upload_max_filesize , $ max_size ) ; } else { $ result = min ( $ post_max_size , $ upload_max_filesize ) ; } return $ result ; }
7835	protected function getWorkflowsNamespace ( ) { $ relative = ltrim ( config ( 'workflow.path' ) , app_path ( ) ) ; $ chunks = array_map ( 'ucfirst' , explode ( '/' , $ relative ) ) ; return implode ( '\\' , $ chunks ) ; }
11844	private function addAPerson ( array $ person , ObjectManager $ manager ) { $ p = new Person ( ) ; foreach ( $ person as $ key => $ value ) { switch ( $ key ) { case 'CountryOfBirth' : case 'Nationality' : $ value = $ this -> getCountry ( $ value ) ; break ; case 'Birthdate' : $ value = new \ DateTime ( $ value ) ; break ; case 'center' : case 'maritalStatus' : $ value = $ this -> getReference ( $ value ) ; break ; } if ( method_exists ( $ p , 'set' . $ key ) ) { call_user_func ( array ( $ p , 'set' . $ key ) , $ value ) ; } elseif ( method_exists ( $ p , 'add' . $ key ) ) { if ( ! is_array ( $ value ) ) { $ value = array ( $ value ) ; } foreach ( $ value as $ v ) { if ( $ v !== NULL ) { call_user_func ( array ( $ p , 'add' . $ key ) , $ v ) ; } } } } $ manager -> persist ( $ p ) ; echo "add person'" . $ p -> __toString ( ) . "'\n" ; }
8285	protected function sessionTimeoutCheck ( $ configKey , $ sessKey , $ clear , $ alwaysUpdate = false ) { if ( $ this -> config [ $ configKey ] !== false ) { $ t = time ( ) ; if ( $ this -> session -> has ( $ sessKey ) ) { if ( $ this -> session -> get ( $ sessKey ) < $ t - $ this -> config [ $ configKey ] ) { if ( $ clear ) { $ this -> session -> invalidate ( ) ; } else { $ this -> session -> migrate ( true ) ; } $ this -> session -> set ( $ sessKey , $ t ) ; } elseif ( $ alwaysUpdate ) { $ this -> session -> set ( $ sessKey , $ t ) ; } } else { $ this -> session -> set ( $ sessKey , $ t ) ; } } }
9207	public function importTable ( Table $ Table , $ records , array $ options = [ ] ) { $ defaultOptions = [ 'checkRules' => true , 'checkExisting' => true , ] ; $ options = $ options + $ defaultOptions ; foreach ( $ records as $ record ) { $ action = ( $ record -> isNew ( ) ? 'Create' : 'Update' ) ; $ result = $ Table -> save ( $ record , $ options ) ; $ key = $ this -> findKey ( $ Table , $ record ) ; if ( $ result ) { $ this -> verbose ( "<success>{$Table->alias()} ({$key}): {$action} successful.</success>" ) ; } else { $ this -> quiet ( "<warning>{$Table->alias()} ({$key}): {$action} failed.</warning>" ) ; $ this -> printValidationErrors ( $ Table -> alias ( ) , $ this -> findKey ( $ Table , $ record ) , $ record -> errors ( ) ) ; } } }
1095	public function children ( $ node ) { $ query = $ this -> node -> newQuery ( ) ; $ query -> where ( $ this -> node -> getQualifiedParentColumnName ( ) , '=' , $ node -> getKey ( ) ) ; foreach ( $ this -> scopedAttributes ( $ node ) as $ fld => $ value ) $ query -> where ( $ this -> qualify ( $ fld ) , '=' , $ value ) ; $ query -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) ; return $ query -> get ( ) ; }
12015	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a MULTI/EXEC transaction over aggregate connections.' ) ; } if ( ! $ client -> getCommandFactory ( ) -> supportsCommands ( array ( 'MULTI' , 'EXEC' , 'DISCARD' ) ) ) { throw new NotSupportedException ( 'MULTI, EXEC and DISCARD are not supported by the current command factory.' ) ; } }
10396	public function loadClassMetadata ( LoadClassMetadataEventArgs $ eventArgs ) { if ( empty ( $ this -> replacements ) ) { return ; } $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ tableName = $ metadata -> getTableName ( ) ; if ( $ tableName ) { $ metadata -> setPrimaryTable ( [ 'name' => $ this -> doReplacement ( $ tableName ) , ] ) ; } foreach ( $ metadata -> getFieldNames ( ) as $ fieldName ) { $ mapping = $ metadata -> getFieldMapping ( $ fieldName ) ; foreach ( $ mapping as $ key => $ value ) { if ( is_string ( $ value ) ) { $ mapping [ $ key ] = $ this -> doReplacement ( $ value ) ; } } $ metadata -> setAttributeOverride ( $ fieldName , $ mapping ) ; } $ associationMappings = $ metadata -> getAssociationMappings ( ) ; foreach ( $ metadata -> getAssociationNames ( ) as $ fieldName ) { if ( isset ( $ associationMappings [ $ fieldName ] ) ) { $ associationMapping = $ associationMappings [ $ fieldName ] ; if ( isset ( $ associationMapping [ 'joinColumns' ] ) ) { foreach ( $ associationMapping [ 'joinColumns' ] as $ key => $ joinColumn ) { $ associationMapping [ 'joinColumns' ] [ $ key ] [ 'name' ] = $ this -> doReplacement ( $ joinColumn [ 'name' ] ) ; $ associationMapping [ 'joinColumns' ] [ $ key ] [ 'referencedColumnName' ] = $ this -> doReplacement ( $ joinColumn [ 'referencedColumnName' ] ) ; } $ metadata -> setAssociationOverride ( $ fieldName , $ associationMapping ) ; } } } if ( count ( $ metadata -> discriminatorMap ) ) { $ this -> processDiscriminatorMap ( $ metadata ) ; } }
1369	protected function bindInboundRequest ( ) { $ this -> app -> singleton ( JsonApiRequest :: class ) ; $ this -> app -> alias ( JsonApiRequest :: class , 'json-api.request' ) ; $ this -> app -> singleton ( Route :: class , function ( Application $ app ) { return new Route ( $ app -> make ( ResolverInterface :: class ) , $ app -> make ( 'router' ) -> current ( ) ) ; } ) ; $ this -> app -> bind ( StoreInterface :: class , function ( ) { return json_api ( ) -> getStore ( ) ; } ) ; $ this -> app -> bind ( ResolverInterface :: class , function ( ) { return json_api ( ) -> getResolver ( ) ; } ) ; $ this -> app -> bind ( ErrorRepositoryInterface :: class , function ( ) { return json_api ( ) -> getErrors ( ) ; } ) ; $ this -> app -> bind ( ContainerInterface :: class , function ( ) { return json_api ( ) -> getContainer ( ) ; } ) ; $ this -> app -> singleton ( HeaderParametersInterface :: class , function ( Application $ app ) { $ parser = $ app -> make ( HttpFactoryInterface :: class ) -> createHeaderParametersParser ( ) ; $ serverRequest = $ app -> make ( ServerRequestInterface :: class ) ; return $ parser -> parse ( $ serverRequest , http_contains_body ( $ serverRequest ) ) ; } ) ; $ this -> app -> singleton ( EncodingParametersInterface :: class , function ( Application $ app ) { $ parser = $ app -> make ( HttpFactoryInterface :: class ) -> createQueryParametersParser ( ) ; return $ parser -> parseQueryParameters ( request ( ) -> query ( ) ) ; } ) ; }
4473	public function heartbeat ( array $ data = [ ] ) : float { try { $ this -> expires = $ this -> client -> heartbeat ( $ this -> jid , $ this -> worker , json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ) ; } catch ( QlessException $ e ) { throw new LostLockException ( $ e -> getMessage ( ) , 'Heartbeat' , $ this -> jid , $ e -> getCode ( ) , $ e ) ; } return $ this -> expires ; }
11531	public static function slotDir ( $ sourceDir , array $ options ) { $ paths = array ( sprintf ( '%s/pages/pages/%s/%s_%s/%s' , $ sourceDir , $ options [ 'page' ] , $ options [ 'language' ] , $ options [ 'country' ] , $ options [ 'slot' ] ) , sprintf ( '%s/slots/%s/%s_%s' , $ sourceDir , $ options [ 'slot' ] , $ options [ 'language' ] , $ options [ 'country' ] ) , sprintf ( '%s/slots/%s' , $ sourceDir , $ options [ 'slot' ] ) , ) ; return self :: cascade ( $ paths ) ; }
5951	public function addFolderResponse ( $ item ) { if ( ! ( $ item instanceof FolderResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new FolderResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FolderResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } elseif ( ! is_numeric ( $ item ) ) { trigger_error ( 'Array parameter item is not of expected type "FolderResponse"!' , E_USER_WARNING ) ; } } $ this -> results [ ] = $ item ; return $ this ; }
2562	protected function loadGeoCode ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAllNotEmpty ( $ params -> latitude , $ params -> longitude ) ) { $ this -> porFndQryParams -> geoCode = new GeoCode ( $ params -> longitude , $ params -> latitude ) ; } }
4686	public function addSelect ( string $ expression , ... $ args ) : self { if ( ! is_string ( $ expression ) ) { throw new InvalidArgumentException ( 'Select expression has to be a string.' ) ; } $ this -> dirty ( ) ; $ this -> select [ ] = $ expression ; $ this -> pushArgs ( 'select' , $ args ) ; return $ this ; }
1225	private function buildQueryParameters ( array $ paramValues ) { if ( empty ( $ paramValues ) ) { return '' ; } $ query = [ ] ; foreach ( $ paramValues as $ param => $ value ) { if ( is_array ( $ value ) ) { $ value = join ( ',' , $ value ) ; } elseif ( is_bool ( $ value ) ) { $ value = $ value ? 'true' : 'false' ; } elseif ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } $ query [ ] = $ param . '=' . urlencode ( $ value ) ; } return '?' . join ( '&' , $ query ) ; }
64	public function size ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new \ RuntimeException ( "$path does not exist." ) ; } if ( is_dir ( $ path ) ) { return $ this -> directorySize ( $ path ) ; } return filesize ( $ path ) ; }
11440	public function getInfos ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> infos ) ; } else { return $ this -> infos ; } }
9598	protected function flashInput ( Request $ request = null ) { if ( $ request === null ) { $ request = $ this -> container -> resolve ( 'Symfony\Component\HttpFoundation\RequestStack' ) -> getCurrentRequest ( ) ; } $ this -> flash ( '_old_input' , $ request -> request -> all ( ) ) ; }
7126	static public function copy ( AddressInterface $ source , AddressInterface $ target ) { $ target -> setCompany ( $ source -> getCompany ( ) ) -> setGender ( $ source -> getGender ( ) ) -> setFirstName ( $ source -> getFirstName ( ) ) -> setLastName ( $ source -> getLastName ( ) ) -> setStreet ( $ source -> getStreet ( ) ) -> setComplement ( $ source -> getComplement ( ) ) -> setSupplement ( $ source -> getSupplement ( ) ) -> setExtra ( $ source -> getExtra ( ) ) -> setCity ( $ source -> getCity ( ) ) -> setPostalCode ( $ source -> getPostalCode ( ) ) -> setCountry ( $ source -> getCountry ( ) ) -> setState ( $ source -> getState ( ) ) -> setDigicode1 ( $ source -> getDigicode1 ( ) ) -> setDigicode2 ( $ source -> getDigicode2 ( ) ) -> setIntercom ( $ source -> getIntercom ( ) ) -> setLatitude ( $ source -> getLatitude ( ) ) -> setLongitude ( $ source -> getLongitude ( ) ) ; if ( is_object ( $ phone = $ source -> getPhone ( ) ) ) { $ target -> setPhone ( clone $ phone ) ; } else { $ target -> setPhone ( $ phone ) ; } if ( is_object ( $ mobile = $ source -> getMobile ( ) ) ) { $ target -> setMobile ( clone $ mobile ) ; } else { $ target -> setMobile ( $ mobile ) ; } }
12262	public function getCustomField ( $ class , $ slug = null ) { if ( ! $ slug ) { throw CustomFieldsHelperException :: slugIsMissing ( ) ; } $ resolveClass = ( is_string ( $ class ) ) ? $ class : get_class ( $ class ) ; if ( ! $ this -> cache [ $ resolveClass ] [ $ slug ] ) { $ this -> _cacheCustomFields ( $ resolveClass ) ; } return $ this -> cache [ $ resolveClass ] [ $ slug ] ; }
8974	public function setOutputFormat ( $ format ) { $ output = array ( 'xml' , 'html' , 'text' , 'text-main' ) ; if ( ! in_array ( $ format , $ output ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Available output format: %s' , implode ( ', ' , $ output ) ) ) ; } $ this -> outputFormat = $ format ; return $ this ; }
5856	public function initializeRulesets ( array $ configuration ) { $ general = $ configuration ; $ general [ 'usergroup' ] = '' ; unset ( $ general [ 'rulesets' ] ) ; $ general = $ this -> expandValuesInRuleset ( $ general ) ; if ( $ general [ 'conversion_mapping' ] === '' ) { $ general [ 'conversion_mapping' ] = [ ] ; } if ( isset ( $ configuration [ 'rulesets' ] ) ) { $ rulesets = $ this -> compileRuleSets ( $ configuration [ 'rulesets' ] ) ; } else { $ rulesets = [ ] ; } foreach ( $ rulesets as $ k => & $ ruleset ) { foreach ( $ general as $ key => $ value ) { if ( ! isset ( $ ruleset [ $ key ] ) ) { $ ruleset [ $ key ] = $ value ; } elseif ( $ ruleset [ $ key ] === '' ) { $ ruleset [ $ key ] = $ value ; } } if ( count ( $ ruleset [ 'usergroup' ] ) == 0 ) { $ ruleset [ 'directories' ] = array_diff ( $ ruleset [ 'directories' ] , $ general [ 'directories' ] ) ; if ( count ( $ ruleset [ 'directories' ] ) == 0 ) { unset ( $ rulesets [ $ k ] ) ; } } } $ rulesets [ ] = $ general ; $ this -> rulesets = $ rulesets ; }
9076	public function addTag ( $ name , array $ attributes = array ( ) ) { foreach ( $ this -> rules as $ rule ) { $ rule -> addTag ( $ name , $ attributes ) ; } }
7736	private function documentProperties ( ClassMetadata $ metadata , ReflectionClass $ class ) { $ properties = array ( ) ; $ elements = array_merge ( $ class -> getProperties ( ) , $ class -> getMethods ( ) ) ; foreach ( $ elements as $ element ) { $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Expose' ) ; if ( null === $ annotation ) { continue ; } $ property = new PropertyDefinition ( $ class -> name , $ element -> name ) ; $ property -> setExposeAs ( $ annotation -> as ) ; $ property -> setIri ( $ annotation -> getIri ( ) ) ; if ( null !== $ annotation -> required ) { $ property -> setRequired ( $ annotation -> required ) ; } if ( null !== $ annotation -> readonly ) { $ property -> setReadOnly ( $ annotation -> readonly ) ; } if ( null !== $ annotation -> writeonly ) { $ property -> setWriteOnly ( $ annotation -> writeonly ) ; } $ tmp = $ this -> getDocBlockText ( $ element ) ; $ property -> setTitle ( $ tmp [ 'title' ] ) ; $ property -> setDescription ( $ tmp [ 'description' ] ) ; $ tmp = $ this -> getType ( $ element ) ; $ property -> setType ( $ tmp [ 'type' ] ) ; $ this -> documentRouteAndOperations ( $ property , $ element ) ; if ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Collection' ) ) ) { $ property -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; if ( false === $ property -> supportsOperation ( $ annotation -> route ) ) { $ property -> addOperation ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ property -> setType ( 'ML\HydraBundle\Entity\Collection' ) ; $ property -> setReadOnly ( true ) ; } $ properties [ ] = $ property ; } $ metadata -> setProperties ( $ properties ) ; }
8446	private function convertQuestion ( Question $ question ) { $ buttons = Collection :: make ( $ question -> getButtons ( ) ) -> map ( function ( $ button ) { return [ 'label' => $ button [ 'text' ] , 'metadata' => $ button [ 'value' ] ] ; } ) ; return [ 'text' => $ question -> getText ( ) , 'quick_reply' => [ 'type' => 'options' , 'options' => $ buttons -> toArray ( ) , ] , ] ; }
9833	public function setWorkbookPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> workbookPassword = $ pValue ; return $ this ; }
11701	public function get ( $ component ) { $ parts = explode ( '.' , $ component ) ; if ( count ( $ parts ) == 1 ) { return $ this -> getService ( $ parts [ 0 ] ) ; } elseif ( count ( $ parts ) == 2 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) ; } elseif ( count ( $ parts ) == 3 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) -> getAction ( $ parts [ 2 ] ) ; } throw new \ LogicException ( 'Malformed component path. Please use a dot-notated path (e.g. service.group.action)' ) ; }
2487	protected function search ( array $ parameters ) { $ queryString = $ this -> generateQueryString ( $ parameters ) ; $ response = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getEntryEndpoint ( ) ) , '/select' , new Message ( [ 'Content-Type' => 'application/x-www-form-urlencoded' , ] , $ queryString ) ) ; $ result = json_decode ( $ response -> body ) ; if ( ! isset ( $ result -> response ) ) { throw new RuntimeException ( '->response not set: ' . var_export ( array ( $ result , $ parameters ) , true ) ) ; } return $ result ; }
4664	public function setDynamicContent ( array $ params , string $ content ) { $ processed_content = preg_replace_callback ( '~\{(.*?)\}~si' , function ( $ match ) use ( $ params ) { return str_replace ( $ match [ 0 ] , isset ( $ params [ $ match [ 1 ] ] ) ? $ params [ $ match [ 1 ] ] : $ match [ 0 ] , $ match [ 0 ] ) ; } , $ content ) ; return $ processed_content ; }
5165	public function render ( DataBuilder $ data_builder , $ parameters , array $ data = [ ] ) { $ parameters = $ this -> castParameters ( $ parameters ) ; $ tm = new TemplateManager ( ) ; $ result = new Result ( ) ; try { $ bag = new Bag ( $ parameters ) ; $ bag -> set ( 'body' , $ tm -> renderRaw ( 'text/html' , strval ( $ bag -> get ( 'body' ) ) , $ data ) ) ; $ attachments = [ ] ; foreach ( ( array ) Yaml :: parse ( strval ( $ bag -> get ( 'attachments' ) ) ) as $ key => $ attachment ) { $ attachment = ( object ) $ attachment ; $ attachments [ $ key ] [ 'as' ] = strval ( $ tm -> renderRaw ( 'text/plain' , $ attachment -> as , $ data ) ) ; $ attachments [ $ key ] [ 'source' ] = strval ( $ tm -> renderRaw ( 'text/plain' , $ attachment -> source , $ data ) ) ; } $ bag -> set ( 'attachments' , $ attachments ) ; $ bag -> set ( 'recipients' , explode ( ',' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'recipients' ) ) , $ data ) ) ) ; $ bag -> set ( 'subject' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'subject' ) ) , $ data ) ) ; $ bag -> set ( 'sender' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'sender' ) ) , $ data ) ) ; $ result -> setResources ( new Collection ( [ $ bag -> toArray ( ) ] ) ) ; } catch ( \ Twig_Error $ e ) { $ e = new Exceptions \ EmailSenderRenderException ( $ e -> getRawMessage ( ) . ' on line ' . $ e -> getTemplateLine ( ) ) ; $ result -> addErrors ( new Collection ( [ $ e ] ) ) ; } return $ result ; }
5702	public function isCustomActionAllowed ( $ action ) { $ actions = $ this -> owner -> config ( ) -> better_buttons_actions ; if ( $ actions ) { return in_array ( $ action , $ actions ) ; } return false ; }
7013	private function format_m ( & $ str ) { if ( strstr ( $ str , '%m' ) ) $ str = str_replace ( '%m' , sprintf ( '%02d' , $ this -> month ) , $ str ) ; }
4534	public function setCandidateGroup ( ? string $ candidateGroup ) { $ this -> candidateGroup = $ candidateGroup ; $ this -> _candidateGroup = null !== $ candidateGroup ; return $ this ; }
11974	private function firstParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( is_numeric ( $ params [ 0 ] ) && $ params [ 0 ] > 0 && $ params [ 0 ] <= $ this -> maxDieRolls ) ; }
6681	public function afterAction ( $ action , $ result ) { $ result = parent :: afterAction ( $ action , $ result ) ; $ this -> setSecurityHeaders ( ) ; if ( extension_loaded ( 'newrelic' ) ) { newrelic_name_transaction ( $ action -> controller -> id . '/' . $ action -> id ) ; } return $ result ; }
9667	private function writeGradientFill ( XMLWriter $ objWriter , Fill $ pFill ) { $ objWriter -> startElement ( 'fill' ) ; $ objWriter -> startElement ( 'gradientFill' ) ; $ objWriter -> writeAttribute ( 'type' , $ pFill -> getFillType ( ) ) ; $ objWriter -> writeAttribute ( 'degree' , $ pFill -> getRotation ( ) ) ; $ objWriter -> startElement ( 'stop' ) ; $ objWriter -> writeAttribute ( 'position' , '0' ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getStartColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'stop' ) ; $ objWriter -> writeAttribute ( 'position' , '1' ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getEndColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
4339	private function setOutputAs ( $ outputAs ) { if ( \ is_object ( $ this -> cfg [ 'outputAs' ] ) ) { $ this -> debug -> removePlugin ( $ this -> cfg [ 'outputAs' ] ) ; $ this -> cfg [ 'outputAs' ] = null ; } $ prop = null ; $ obj = null ; if ( \ is_string ( $ outputAs ) ) { $ prop = $ outputAs ; $ classname = __NAMESPACE__ . '\\Output\\' . \ ucfirst ( $ outputAs ) ; if ( \ property_exists ( $ this , $ prop ) ) { $ obj = $ this -> { $ prop } ; } elseif ( \ class_exists ( $ classname ) ) { $ obj = new $ classname ( $ this -> debug ) ; } } elseif ( $ outputAs instanceof OutputInterface ) { $ classname = \ get_class ( $ outputAs ) ; $ prefix = __NAMESPACE__ . '\\Output\\' ; if ( \ strpos ( $ classname , $ prefix ) == 0 ) { $ prop = \ substr ( $ classname , \ strlen ( $ prefix ) ) ; $ prop = \ lcfirst ( $ prop ) ; } $ obj = $ outputAs ; } if ( $ obj ) { $ this -> debug -> addPlugin ( $ obj ) ; $ this -> cfg [ 'outputAs' ] = $ obj ; if ( $ prop ) { $ this -> { $ prop } = $ obj ; } } }
9499	public function processRequest ( RequestInterface $ request ) { $ response = $ request -> send ( ) ; $ attempt = 0 ; while ( $ response -> getStatusCode ( ) == 429 && $ attempt < 5 ) { $ wait = $ response -> getHeader ( 'Retry-After' ) ; if ( $ wait > 0 ) { sleep ( $ wait ) ; } $ attempt ++ ; $ response = $ request -> send ( ) ; } if ( $ response -> getStatusCode ( ) >= 500 ) { throw new ZendeskException ( 'Zendesk Server Error Detected.' ) ; } if ( $ response -> getStatusCode ( ) >= 400 ) { if ( $ response -> getContentType ( ) == 'application/json' ) { $ result = $ response -> json ( ) ; $ description = array_key_exists ( $ result , 'description' ) ? $ result [ 'description' ] : 'Invalid Request' ; $ value = array_key_exists ( $ result , 'value' ) ? $ result [ 'value' ] : array ( ) ; $ exception = new ZendeskException ( $ description ) ; $ exception -> setError ( $ value ) ; throw $ exception ; } else { throw new ZendeskException ( 'Invalid API Request' ) ; } } return $ response ; }
2266	public function indexExists ( $ strName , $ strTable , $ blnNoCache = false ) { if ( $ strName == '' || $ strTable == '' ) { return false ; } foreach ( $ this -> listFields ( $ strTable , $ blnNoCache ) as $ arrField ) { if ( $ arrField [ 'name' ] == $ strName && $ arrField [ 'type' ] == 'index' ) { return true ; } } return false ; }
9869	private function writePageMargins ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'pageMargins' ) ; $ objWriter -> writeAttribute ( 'left' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getLeft ( ) ) ) ; $ objWriter -> writeAttribute ( 'right' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getRight ( ) ) ) ; $ objWriter -> writeAttribute ( 'top' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getTop ( ) ) ) ; $ objWriter -> writeAttribute ( 'bottom' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getBottom ( ) ) ) ; $ objWriter -> writeAttribute ( 'header' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getHeader ( ) ) ) ; $ objWriter -> writeAttribute ( 'footer' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getFooter ( ) ) ) ; $ objWriter -> endElement ( ) ; }
12440	public function get ( $ key ) { if ( ! isset ( $ this -> instances [ $ key ] ) ) { throw new \ LogicException ( 'No instance for given key! (key: ' . $ key . ')' ) ; } return $ this -> instances [ $ key ] ; }
4687	public function where ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ expression ; $ this -> args [ 'where' ] = $ args ; return $ this ; }
5789	protected function setRules ( bool $ skipUniqueForUnchanged = false , array $ record = null ) { $ this -> mapFieldsRules ( $ this -> databaseTableValidation -> getValidationRules ( ) ) ; $ uniqueColumns = $ this -> mapper -> getUniqueColumns ( ) ; if ( count ( $ uniqueColumns ) > 0 ) { $ this -> addUniqueRule ( ) ; foreach ( $ uniqueColumns as $ databaseColumnMapper ) { $ field = $ databaseColumnMapper -> getName ( ) ; if ( ! ( $ skipUniqueForUnchanged && $ this -> inputData [ $ field ] == $ record [ $ field ] ) ) { $ this -> rule ( 'unique' , $ field , $ databaseColumnMapper , $ this ) ; } } } }
7276	protected static function tableColumns ( ) { global $ dbConfig ; $ query = Db :: instance ( static :: getDbName ( ) ) -> prepare ( " select column_name, column_key from information_schema.columns where table_schema = :schema and table_name = :table " ) ; $ query -> bindValue ( ":schema" , $ dbConfig [ static :: getDbName ( ) ] [ "schema" ] ) ; $ query -> bindValue ( ":table" , static :: tableName ( ) ) ; if ( $ query -> execute ( ) ) return $ query -> fetchAll ( PDO :: FETCH_ASSOC ) ; else return false ; }
10640	protected function createUniquePath ( UploadedFile $ file ) { $ dir = 'mmmb/' . mb_substr ( mb_strtolower ( ( string ) $ file -> getClientOriginalName ( ) ) , 0 , 2 ) ; $ filename = str_replace ( array ( ' ' , $ file -> getClientOriginalExtension ( ) ) , '-' , $ file -> getClientOriginalName ( ) ) ; $ name = mb_strtolower ( $ filename . uniqid ( ) . '.' . $ file -> getClientOriginalExtension ( ) ) ; return array ( 'dir' => $ dir , 'filename' => $ name , 'path' => $ dir . '/' . $ name , ) ; }
6091	public function removeMoodboard ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/moodboards/' . $ id . '' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
263	public function close ( ) { if ( $ this -> getIsActive ( ) ) { $ this -> fields = $ this -> composeFields ( ) ; YII_DEBUG ? session_write_close ( ) : @ session_write_close ( ) ; } }
11466	public static function writeLogLine ( $ log_file , $ input , $ timestamp = null ) { if ( is_null ( self :: $ _error_folder ) ) { return false ; } $ log_file = basename ( $ log_file ) ; $ fp = @ fopen ( self :: $ _error_folder . $ log_file , 'ab' ) ; if ( ! $ fp ) { return false ; } if ( empty ( $ timestamp ) ) { $ timestamp = time ( ) ; } $ line = [ ] ; $ line [ ] = date ( \ DateTime :: ISO8601 , $ timestamp ) ; if ( $ input instanceof \ Throwable ) { $ message = $ input -> getMessage ( ) ; if ( ! ( $ input instanceof BaseException ) ) { $ message = preg_replace ( '/\s+/' , ' ' , $ message ) ; } $ line [ ] = BaseException :: getShortName ( get_class ( $ input ) ) ; $ line [ ] = $ message ; $ line [ ] = $ input -> getFile ( ) ; $ line [ ] = $ input -> getLine ( ) ; $ line_out = vsprintf ( '[%s] %s: %s in %s on line %d' , $ line ) ; } elseif ( is_string ( $ input ) ) { $ line [ ] = $ input ; $ line_out = vsprintf ( '[%s] %s' , $ line ) ; } else { return false ; } if ( flock ( $ fp , LOCK_EX ) ) { fwrite ( $ fp , $ line_out . PHP_EOL ) ; flock ( $ fp , LOCK_UN ) ; fclose ( $ fp ) ; return true ; } else { return false ; } }
5987	public function setCreatedRange ( $ createdRange ) { if ( $ createdRange instanceof DateTimeRange ) { $ this -> createdRange = $ createdRange ; } elseif ( is_array ( $ createdRange ) ) { $ this -> createdRange = new DateTimeRange ( $ createdRange ) ; } else { $ this -> createdRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
7189	private function copyAdjustment ( Model \ AdjustmentInterface $ source , Model \ AdjustmentInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'designation' , 'type' , 'mode' , 'amount' , 'immutable' , ] ) ; }
7666	function EncodeQP ( $ str ) { $ encoded = $ this -> FixEOL ( $ str ) ; if ( substr ( $ encoded , - ( strlen ( $ this -> LE ) ) ) != $ this -> LE ) $ encoded .= $ this -> LE ; $ encoded = preg_replace ( '/([\000-\010\013\014\016-\037\075\177-\377])/e' , "'='.sprintf('%02X', ord('\\1'))" , $ encoded ) ; $ encoded = preg_replace ( "/([\011\040])" . $ this -> LE . "/e" , "'='.sprintf('%02X', ord('\\1')).'" . $ this -> LE . "'" , $ encoded ) ; $ encoded = $ this -> WrapText ( $ encoded , 74 , true ) ; return $ encoded ; }
10333	function fromXML ( $ xmlElement ) { parent :: fromXML ( $ xmlElement ) ; if ( isset ( $ xmlElement -> permissionType ) ) $ this -> permission = Permission :: getPermission ( $ xmlElement -> permissionType ) ; if ( isset ( $ xmlElement -> field_backups ) ) $ this -> fieldBackups = XMLDeserializer :: deserialize ( $ xmlElement -> field_backups ) ; }
11715	protected function getCachedToken ( array $ options ) { $ authOptions = array_intersect_key ( $ options , $ this -> api -> postTokens ( ) [ 'params' ] ) ; $ optionsToHash = array_merge ( $ authOptions , array_intersect_key ( $ options , [ 'authUrl' => true , ] ) ) ; if ( isset ( $ optionsToHash [ 'user' ] ) ) { unset ( $ optionsToHash [ 'user' ] [ 'password' ] ) ; } $ key = 'openstack-token-' . md5 ( json_encode ( $ optionsToHash ) ) ; if ( $ this -> cache -> has ( $ key ) ) { return $ this -> cache -> get ( $ key ) ; } $ token = $ this -> generateToken ( $ authOptions ) ; $ cachedToken = $ token -> export ( ) ; $ expiresAt = new DateTime ( $ cachedToken [ 'expires_at' ] ) ; $ this -> cache -> put ( $ key , $ cachedToken , $ expiresAt -> sub ( new DateInterval ( 'PT1M' ) ) ) ; return $ cachedToken ; }
1286	private function createIdChunks ( array $ resourceIds ) : array { $ chunks = [ ] ; $ chunkId = - 1 ; $ resourceIds = \ array_values ( $ resourceIds ) ; foreach ( $ resourceIds as $ index => $ resourceId ) { if ( 0 === $ index % 30 ) { ++ $ chunkId ; $ chunks [ $ chunkId ] = [ ] ; } $ chunks [ $ chunkId ] [ ] = $ resourceId ; } return $ chunks ; }
4562	public function getProperties ( Translatable $ model ) : array { $ class = get_class ( $ model ) ; if ( substr ( $ class , 0 , 15 ) === 'Proxies\\__CG__\\' ) { $ class = substr ( $ class , 15 ) ; } $ properties = [ ] ; $ reflection = new ReflectionClass ( $ class ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Translate :: class ) ; if ( ! $ annotation ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
8527	private function _convertListFinancialEventGroups ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroups' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMaxResultsPerPage ( ) ) { $ parameters [ 'MaxResultsPerPage' ] = $ request -> getMaxResultsPerPage ( ) ; } if ( $ request -> isSetFinancialEventGroupStartedAfter ( ) ) { $ parameters [ 'FinancialEventGroupStartedAfter' ] = $ request -> getFinancialEventGroupStartedAfter ( ) ; } if ( $ request -> isSetFinancialEventGroupStartedBefore ( ) ) { $ parameters [ 'FinancialEventGroupStartedBefore' ] = $ request -> getFinancialEventGroupStartedBefore ( ) ; } return $ parameters ; }
10102	public function writeUrlInternal ( $ row1 , $ col1 , $ row2 , $ col2 , $ url ) { $ record = 0x01B8 ; $ length = 0x00000 ; $ url = preg_replace ( '/^internal:/' , '' , $ url ) ; $ unknown1 = pack ( 'H*' , 'D0C9EA79F9BACE118C8200AA004BA90B02000000' ) ; $ options = pack ( 'V' , 0x08 ) ; $ url .= "\0" ; $ url_len = StringHelper :: countCharacters ( $ url ) ; $ url_len = pack ( 'V' , $ url_len ) ; $ url = StringHelper :: convertEncoding ( $ url , 'UTF-16LE' , 'UTF-8' ) ; $ length = 0x24 + strlen ( $ url ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ row1 , $ row2 , $ col1 , $ col2 ) ; $ this -> append ( $ header . $ data . $ unknown1 . $ options . $ url_len . $ url ) ; return 0 ; }
12108	public function changePageFromRequest ( $ id , $ request ) { $ this -> getPage ( $ id ) ; $ page = $ this -> createPageObject ( null , null , $ request ) ; $ this -> pages [ $ id ] = $ page ; $ this -> persist ( ) ; return $ page ; }
3724	private function buildCacheService ( ContainerBuilder $ container , array $ config ) { if ( ! $ config [ 'enable_cache' ] ) { $ cache = $ container -> getDefinition ( 'metamodels.cache' ) ; $ cache -> setClass ( ArrayCache :: class ) ; $ cache -> setArguments ( [ ] ) ; $ container -> setParameter ( 'metamodels.cache_dir' , null ) ; return ; } $ container -> setParameter ( 'metamodels.cache_dir' , $ config [ 'cache_dir' ] ) ; }
12100	public function priceBrutto ( $ netto , $ tax ) { $ tax = round ( ( double ) $ tax / 100.0 , 2 ) ; if ( $ tax < 0.00 ) { throw new Exception ( sprintf ( 'Tax must be greater than or equal to 0, given %s.' , $ tax ) ) ; } if ( $ tax === 0.00 ) { return $ netto ; } $ result = $ netto * ( $ tax + 1 ) ; return round ( $ result , 2 , PHP_ROUND_HALF_UP ) ; }
10802	public function savePageHistoricAction ( ) { $ responseData = $ this -> params ( ) -> fromRoute ( 'datas' , $ this -> params ( ) -> fromQuery ( 'datas' , '' ) ) ; $ idPage = isset ( $ responseData [ 'idPage' ] ) ? $ responseData [ 'idPage' ] : ( ! empty ( $ responseData [ 0 ] [ 'idPage' ] ) ? ( $ responseData [ 0 ] [ 'idPage' ] ) : 0 ) ; $ isNew = isset ( $ responseData [ 'isNew' ] ) ? $ responseData [ 'isNew' ] : ( ! empty ( $ responseData [ 0 ] [ 'isNew' ] ) ? ( $ responseData [ 0 ] [ 'isNew' ] ) : 0 ) ; $ response = array ( 'idPage' => $ idPage , 'isNew' => $ isNew ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_save_start' , $ this , $ response ) ; $ melisCoreAuth = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreAuth' ) ; $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ pageAction = $ this -> params ( ) -> fromRoute ( 'pageActionUsed' , $ this -> params ( ) -> fromQuery ( 'pageActionUsed' , '' ) ) ; $ histDatas = array ( ) ; $ container = new Container ( 'meliscms' ) ; $ datas = array ( ) ; if ( isset ( $ container [ 'action-page-tmp' ] [ 'success' ] ) && $ container [ 'action-page-tmp' ] [ 'success' ] == 0 ) return ; if ( ! empty ( $ container [ 'action-page-tmp' ] ) ) { if ( ! empty ( $ container [ 'action-page-tmp' ] [ 'datas' ] ) ) $ datas = $ container [ 'action-page-tmp' ] [ 'datas' ] ; } $ description = '' ; switch ( $ pageAction ) { case 'Save' : if ( $ isNew ) { $ description = 'tr_melispagehistoric_description_text_new' ; } else { $ description = 'tr_melispagehistoric_description_text_save' ; } break ; case 'Publish' : $ description = 'tr_melispagehistoric_description_text_publish' ; break ; case 'Unpublish' : $ description = 'tr_melispagehistoric_description_text_unpublished' ; break ; } if ( $ idPage ) { $ userId = ( int ) null ; $ userAuthDatas = $ melisCoreAuth -> getStorage ( ) -> read ( ) ; if ( $ userAuthDatas ) $ userId = $ userAuthDatas -> usr_id ; $ histDatas = array ( 'hist_page_id' => $ idPage , 'hist_action' => $ pageAction , 'hist_date' => date ( 'Y-m-d H:i:s' ) , 'hist_user_id' => $ userId , 'hist_description' => $ description ) ; $ melisPageHistoricTable -> save ( $ histDatas ) ; } $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_save_end' , $ this , $ histDatas ) ; }
2686	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ req = $ this -> api -> checkImageOptimizationStatus ( ) ; if ( ! $ req ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check image optimization status.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11055	public function getBundle ( $ name , $ publish = true ) { if ( $ this -> bundles === false ) { return $ this -> loadDummyBundle ( $ name ) ; } elseif ( ! isset ( $ this -> bundles [ $ name ] ) ) { return $ this -> bundles [ $ name ] = $ this -> loadBundle ( $ name , [ ] , $ publish ) ; } elseif ( $ this -> bundles [ $ name ] instanceof AssetBundle ) { return $ this -> bundles [ $ name ] ; } elseif ( is_array ( $ this -> bundles [ $ name ] ) ) { return $ this -> bundles [ $ name ] = $ this -> loadBundle ( $ name , $ this -> bundles [ $ name ] , $ publish ) ; } elseif ( $ this -> bundles [ $ name ] === false ) { return $ this -> loadDummyBundle ( $ name ) ; } else { throw new InvalidConfigException ( "Invalid asset bundle configuration: $name" ) ; } }
9016	public function markAllNotificationsAsRead ( ) { $ object = Auth :: user ( ) ; $ object -> unreadNotifications -> markAsRead ( ) ; \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
9165	public function fields ( $ entity = array ( ) , $ action = 'all' , array $ params = array ( ) ) { $ fieldCollection = array ( ) ; $ entity = $ this -> entityFactory -> build ( $ entity ) ; if ( $ entity instanceof \ ElggEntity ) { $ params [ 'entity' ] = $ entity ; $ fields = ( array ) elgg_trigger_plugin_hook ( 'prototype' , $ action , $ params , array ( ) ) ; $ attribute_names = $ this -> entityFactory -> getAttributeNames ( $ entity ) ; if ( ! $ entity -> guid ) { $ fields [ 'type' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'subtype' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'owner_guid' ] = array ( 'type' => 'hidden' ) ; $ fields [ 'container_guid' ] = array ( 'type' => 'hidden' ) ; } else { $ fields [ 'guid' ] = array ( 'type' => 'hidden' ) ; } foreach ( $ fields as $ shortname => $ field ) { $ field [ 'entity_type' ] = $ entity -> getType ( ) ; $ field [ 'entity_subtype' ] = $ entity -> getSubtype ( ) ; if ( empty ( $ field [ 'shortname' ] ) ) { $ field [ 'shortname' ] = $ shortname ; } if ( in_array ( $ shortname , $ attribute_names ) ) { $ field [ 'data_type' ] = 'attribute' ; $ field [ 'class_name' ] = Elements \ AttributeField :: CLASSNAME ; } $ fieldObj = $ this -> fieldFactory -> build ( $ field ) ; if ( $ fieldObj instanceof Elements \ Field ) { $ fieldCollection [ ] = $ fieldObj ; } } } return new Elements \ FieldCollection ( $ fieldCollection ) ; }
8664	private function convertManageReportSchedule ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ManageReportSchedule' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportType ( ) ) { $ parameters [ 'ReportType' ] = $ request -> getReportType ( ) ; } if ( $ request -> isSetSchedule ( ) ) { $ parameters [ 'Schedule' ] = $ request -> getSchedule ( ) ; } if ( $ request -> isSetScheduleDate ( ) ) { $ parameters [ 'ScheduleDate' ] = $ this -> getFormattedTimestamp ( $ request -> getScheduleDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
8153	public function removeExtension ( $ name ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.12 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( $ this -> extensionInitialized ) { throw new LogicException ( sprintf ( 'Unable to remove extension "%s" as extensions have already been initialized.' , $ name ) ) ; } $ class = ltrim ( $ name , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } unset ( $ this -> extensions [ $ class ] ) ; } unset ( $ this -> extensions [ $ class ] ) ; $ this -> updateOptionsHash ( ) ; }
6498	public function useScreenResolution ( $ width_height ) { list ( $ width , $ height ) = explode ( 'x' , $ width_height ) ; $ this -> getSessionDriver ( ) -> resizeWindow ( ( int ) $ width , ( int ) $ height ) ; }
7720	static function f_Misc_UpdateArray ( & $ array , $ numerical , $ v , $ d ) { if ( ! is_array ( $ v ) ) { if ( is_null ( $ v ) ) { $ array = array ( ) ; return ; } else { $ v = array ( $ v => $ d ) ; } } foreach ( $ v as $ p => $ a ) { if ( $ numerical === true ) { if ( is_string ( $ p ) ) { $ i = array_search ( $ p , $ array , true ) ; if ( $ i === false ) { if ( ! is_null ( $ a ) ) $ array [ ] = $ p ; } else { if ( is_null ( $ a ) ) array_splice ( $ array , $ i , 1 ) ; } } else { $ i = array_search ( $ a , $ array , true ) ; if ( $ i == false ) $ array [ ] = $ a ; } } else { if ( is_null ( $ a ) ) { unset ( $ array [ $ p ] ) ; } elseif ( $ numerical === 'frm' ) { self :: f_Misc_FormatSave ( $ a , $ p ) ; } else { $ array [ $ p ] = $ a ; } } } }
7075	private function addItemDetails ( array & $ details , Model \ SaleItemInterface $ item ) { $ total = 0 ; if ( ! ( $ item -> isCompound ( ) && ! $ item -> hasPrivateChildren ( ) ) ) { $ itemResult = $ item -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ item -> getTotalQuantity ( ) . 'x ' . $ item -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NUMBER' . $ this -> line ] = $ item -> getReference ( ) ; if ( ! empty ( $ description = $ item -> getDescription ( ) ) ) { $ details [ 'L_PAYMENTREQUEST_0_DESC' . $ this -> line ] = $ description ; } $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = $ this -> format ( $ itemResult -> getTotal ( ) ) ; $ total = $ itemResult -> getTotal ( ) ; $ this -> line ++ ; } foreach ( $ item -> getChildren ( ) as $ child ) { $ total += $ this -> addItemDetails ( $ details , $ child ) ; } return $ total ; }
3944	public static function searchFiles ( $ folder , $ extension ) { $ scanResult = array ( ) ; $ result = array ( ) ; if ( is_dir ( TL_ROOT . '/' . $ folder ) ) { $ scanResult = scan ( TL_ROOT . '/' . $ folder ) ; } foreach ( $ scanResult as $ value ) { if ( ! is_file ( TL_ROOT . '/' . $ folder . '/' . $ value ) ) { $ result += self :: searchFiles ( $ folder . '/' . $ value , $ extension ) ; } else { if ( preg_match ( '/' . $ extension . '$/i' , $ value ) ) { $ result [ $ folder ] [ $ folder . '/' . $ value ] = $ value ; } } } return $ result ; }
10342	protected function isValidDate ( $ year , $ month , $ day ) { if ( $ month <= 0 || $ month > 12 || $ day <= 0 || $ day > 31 ) { return false ; } if ( ( $ month == 4 || $ month == 6 || $ month == 9 || $ month == 11 ) && ( $ day == 31 ) ) { return false ; } if ( $ month == 2 ) { if ( $ day > 29 ) { return false ; } $ leap = date ( 'L' , strtotime ( $ year . '-01-01' ) ) ; if ( $ leap === '0' && $ day > 28 ) { return false ; } } return true ; }
3970	protected function attributeIdToName ( IMetaModel $ metaModel , $ attributeId ) { if ( null === $ attribute = $ metaModel -> getAttributeById ( $ attributeId ) ) { throw new \ RuntimeException ( sprintf ( 'Could not retrieve attribute %s from MetaModel %s.' , $ attributeId , $ metaModel -> getTableName ( ) ) ) ; } return $ attribute -> getColName ( ) ; }
10883	public function reportException ( \ Exception $ ex ) { $ report = new ErrorStreamReport ( ) ; $ report -> error_group = $ ex -> getMessage ( ) . ':' . $ ex -> getLine ( ) ; $ report -> line_number = $ ex -> getLine ( ) ; $ report -> file_name = $ ex -> getFile ( ) ; $ report -> message = $ ex -> getMessage ( ) ; $ report -> stack_trace = $ ex -> getTraceAsString ( ) ; $ report -> severity = 3 ; return $ this -> report ( $ report ) ; }
8382	public function fetch ( ) { if ( $ this -> statement == null || $ this -> getErrorState ( ) != '00000' ) { return false ; } return $ this -> statement -> fetch ( \ PDO :: FETCH_ASSOC ) ; }
8526	public function listFinancialEventGroups ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroups' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6510	protected function initHandler ( HandlerInterface $ handler ) { if ( $ this -> formatter != null ) { $ handler -> setFormatter ( $ this -> formatter ) ; } foreach ( $ this -> processors as $ processor ) { $ handler -> pushProcessor ( $ processor ) ; } return $ handler ; }
7216	protected function getTaxGroupFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof TaxGroupInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . TaxGroupInterface :: class ) ; } return $ resource ; }
5851	protected function addToolbarButtons ( ) { $ buttonBar = $ this -> moduleTemplate -> getDocHeaderComponent ( ) -> getButtonBar ( ) ; $ saveSplitButton = $ buttonBar -> makeSplitButton ( ) ; $ saveButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveDoc' ) ) ) -> setName ( '_savedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveButton , true ) ; $ saveAndCloseButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveCloseDoc' ) ) ) -> setName ( '_saveandclosedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setClasses ( 't3js-editform-submitButton' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save-close' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveAndCloseButton ) ; $ buttonBar -> addButton ( $ saveSplitButton , \ TYPO3 \ CMS \ Backend \ Template \ Components \ ButtonBar :: BUTTON_POSITION_LEFT , 2 ) ; $ closeButton = $ buttonBar -> makeLinkButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.closeDoc' ) ) ) -> setHref ( '#' ) -> setClasses ( 't3js-editform-close' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-view-go-back' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ buttonBar -> addButton ( $ closeButton ) ; }
3564	public function castToString ( ) { if ( $ this -> attributes [ 'meta_type' ] == 'array' ) { return $ this -> attributes [ 'meta_value' ] ; } $ value = $ this -> getValue ( ) ; if ( $ this -> isStringable ( $ value ) || is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } return '' ; }
4700	protected function handleInput ( InputInterface $ input ) { if ( $ file = $ input -> getArgument ( 'file' ) ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The input file "%s" not found' , $ file ) ) ; } return file_get_contents ( $ file ) ; } else { $ contents = '' ; if ( $ stdin = fopen ( 'php://stdin' , 'r' ) ) { if ( stream_set_blocking ( $ stdin , false ) ) { $ contents = stream_get_contents ( $ stdin ) ; } fclose ( $ stdin ) ; } if ( $ contents ) { return $ contents ; } } throw new \ InvalidArgumentException ( 'No input file' ) ; }
1413	public function resourceDoesNotExist ( string $ path ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_NOT_FOUND , $ this -> trans ( 'resource_not_found' , 'code' ) , $ this -> trans ( 'resource_not_found' , 'title' ) , $ this -> trans ( 'resource_not_found' , 'detail' ) , $ this -> pointer ( $ path ) ) ; }
11654	protected function _initMultiDbResources ( ) { $ registry = $ this -> getPluginResource ( 'multidb' ) ; if ( ! $ registry ) { return ; } $ options = $ registry -> getOptions ( ) ; foreach ( $ options as & $ connection ) { if ( 'db://' === substr ( $ connection [ 'dbname' ] , 0 , 5 ) ) { $ connection = array_replace ( $ connection , $ this -> _parseDsn ( $ connection [ 'dbname' ] ) ) ; } } Zend_Registry :: set ( 'multidb' , $ registry -> setOptions ( $ options ) ) ; }
1191	private function addCustomDefinition ( array $ definitionConfig , HTMLPurifier_Config $ configObject = null ) { if ( ! $ configObject ) { $ configObject = HTMLPurifier_Config :: createDefault ( ) ; $ configObject -> loadArray ( $ this -> getConfig ( ) ) ; } $ configObject -> set ( 'HTML.DefinitionID' , $ definitionConfig [ 'id' ] ) ; $ configObject -> set ( 'HTML.DefinitionRev' , $ definitionConfig [ 'rev' ] ) ; if ( ! isset ( $ definitionConfig [ 'debug' ] ) || $ definitionConfig [ 'debug' ] ) { $ configObject -> set ( 'Cache.DefinitionImpl' , null ) ; } if ( $ def = $ configObject -> maybeGetRawHTMLDefinition ( ) ) { if ( ! empty ( $ definitionConfig [ 'attributes' ] ) ) { $ this -> addCustomAttributes ( $ definitionConfig [ 'attributes' ] , $ def ) ; } if ( ! empty ( $ definitionConfig [ 'elements' ] ) ) { $ this -> addCustomElements ( $ definitionConfig [ 'elements' ] , $ def ) ; } } return $ configObject ; }
11129	protected function stringize ( array & $ arguments ) { array_walk ( $ arguments , function ( & $ value ) { if ( is_object ( $ value ) ) { $ value = get_class ( $ value ) ; } elseif ( is_scalar ( $ value ) ) { $ value = ( string ) $ value ; } else { $ value = json_encode ( $ value , 0 ) ; } } ) ; return $ this ; }
5754	protected function setIndexFilter ( Request $ request , Response $ response , $ args , array $ listViewColumns , AdminListView $ view ) { $ this -> setRequestInput ( $ request , [ $ view -> getSessionFilterFieldKey ( ) ] ) ; if ( ! isset ( $ this -> requestInput [ $ view -> getSessionFilterFieldKey ( ) ] ) ) { throw new \ Exception ( "session filter input must be set" ) ; } $ this -> storeFilterFieldValueInSession ( $ view ) ; if ( null !== $ filterColumnsInfo = $ this -> getFilterColumns ( $ view -> getSessionFilterFieldKey ( ) , $ listViewColumns ) ) { $ this -> storeFilterColumnsInfoInSession ( $ filterColumnsInfo , $ view ) ; } }
2663	public function configureBackend ( $ params , $ version , $ old_name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend/' . str_replace ( ' ' , '%20' , $ old_name ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ params ) ; return $ result ; }
898	private function isOfLowerPrecedence ( Token $ token ) { static $ tokens ; if ( null === $ tokens ) { $ tokens = [ T_AND_EQUAL , T_BOOLEAN_AND , T_BOOLEAN_OR , T_CASE , T_CONCAT_EQUAL , T_DIV_EQUAL , T_DOUBLE_ARROW , T_GOTO , T_LOGICAL_AND , T_LOGICAL_OR , T_LOGICAL_XOR , T_MINUS_EQUAL , T_MUL_EQUAL , T_OR_EQUAL , T_PLUS_EQUAL , T_RETURN , T_SL_EQUAL , T_SR_EQUAL , T_THROW , T_XOR_EQUAL , T_ECHO , T_PRINT , T_OPEN_TAG , T_OPEN_TAG_WITH_ECHO , ] ; if ( \ defined ( 'T_POW_EQUAL' ) ) { $ tokens [ ] = T_POW_EQUAL ; } if ( \ defined ( 'T_COALESCE' ) ) { $ tokens [ ] = T_COALESCE ; } } static $ otherTokens = [ '&' , '|' , '^' , '?' , ':' , '=' , ',' , ';' , ] ; return $ token -> isGivenKind ( $ tokens ) || $ token -> equalsAny ( $ otherTokens ) ; }
10984	public static function getHostId ( ) { if ( self :: isWindows ( ) ) { $ uuid = explode ( "\r\n" , trim ( shell_exec ( 'wmic csproduct get UUID' ) ) ) ; return ( \ count ( $ uuid ) === 2 ? $ uuid [ 1 ] : false ) ; } $ uuid = trim ( shell_exec ( 'hostid' ) ) ; return $ uuid === null ? false : $ uuid ; }
4129	public function createQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new ODMQuery ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; $ query -> setDocumentManager ( $ this ) ; return $ query ; }
8420	public function renderWidget ( $ config = [ ] ) { $ widgetHtml = $ this -> render ( $ this -> template , [ 'name' => $ this -> getModelName ( ) , 'attribute' => $ this -> attribute , 'label' => $ this -> label , 'texture' => $ this -> getTexture ( ) , 'disabled' => $ this -> disabled ] ) ; if ( $ this -> wrap ) { return Html :: tag ( $ this -> wrapper , $ widgetHtml , $ this -> options ) ; } return $ widgetHtml ; }
11130	protected function matchTemplate ( & $ template , array & $ arguments ) { $ count = substr_count ( $ template , '%s' ) ; $ size = sizeof ( $ arguments ) ; if ( $ count > $ size ) { $ arguments = $ arguments + array_fill ( $ size , $ count - $ size , '' ) ; } else { $ template .= str_repeat ( ' %s' , $ size - $ count ) ; } return $ this ; }
11520	protected function GenerateWindowsPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ WindowsPinicon ) { $ metadata .= $ owner -> MarkupComment ( 'Windows Pinned Icon' ) ; $ appName = $ config -> fetchPiniconTitle ( ) ; if ( ! $ appName ) { $ appName = $ config -> Title ; } $ metadata .= $ owner -> MarkupMeta ( 'application-name' , $ appName ) ; if ( $ config -> fetchWindowsPiniconBackgroundColor ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'msapplication-TileColor' , $ config -> fetchWindowsPiniconBackgroundColor ( ) ) ; } $ metadata .= $ owner -> MarkupMeta ( 'msapplication-square70x70logo' , $ WindowsPinicon -> Fill ( 70 , 70 ) -> getAbsoluteURL ( ) ) ; $ metadata .= $ owner -> MarkupMeta ( 'msapplication-square150x150logo' , $ WindowsPinicon -> Fill ( 150 , 150 ) -> getAbsoluteURL ( ) ) ; }
2287	public static function findActiveByEmailAndUsername ( $ strEmail , $ strUsername = null , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "$t.email=? AND $t.login='1' AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ) ; if ( $ strUsername !== null ) { $ arrColumns [ ] = "$t.username=?" ; } return static :: findOneBy ( $ arrColumns , array ( $ strEmail , $ strUsername ) , $ arrOptions ) ; }
5406	protected function findFirstMatch ( $ cookie ) { for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { $ is_match = $ this -> isMatch ( $ cookie , $ this -> cookies [ $ i ] -> getHost ( ) , $ this -> cookies [ $ i ] -> getPath ( ) , $ this -> cookies [ $ i ] -> getName ( ) ) ; if ( $ is_match ) { return $ i ; } } return count ( $ this -> cookies ) ; }
10731	public function getMinute ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'minute' ] ; } }
294	public function setAttribute ( $ name , $ value ) { if ( $ this -> hasAttribute ( $ name ) ) { if ( ! empty ( $ this -> _relationsDependencies [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _attributes ) || $ this -> _attributes [ $ name ] !== $ value ) ) { $ this -> resetDependentRelations ( $ name ) ; } $ this -> _attributes [ $ name ] = $ value ; } else { throw new InvalidArgumentException ( get_class ( $ this ) . ' has no attribute named "' . $ name . '".' ) ; } }
12	public function setOptimizeAutoloader ( $ optimizeAutoloader = false ) { $ this -> optimizeAutoloader = ( bool ) $ optimizeAutoloader ; if ( ! $ this -> optimizeAutoloader ) { $ this -> setClassMapAuthoritative ( false ) ; } return $ this ; }
11956	function addQueue ( $ channel , $ queue , $ weight = 1 ) { $ orig = $ channel ; $ channel = $ this -> _normalizeQueueName ( $ channel ) ; if ( ! $ queue instanceof iQueueDriver ) throw new \ Exception ( sprintf ( 'Queue must be instance of iQueueDriver; given: (%s).' , \ Poirot \ Std \ flatten ( $ queue ) ) ) ; if ( isset ( $ this -> channels_queue [ $ channel ] ) ) throw new \ RuntimeException ( sprintf ( 'Channel (%s) is currently filled with (%s) and is not empty.' , $ orig , get_class ( $ this -> channels_queue [ $ channel ] ) ) ) ; $ this -> channels_queue [ $ channel ] = $ queue ; $ this -> channels_weight [ $ channel ] = $ weight ; return $ this ; }
5005	protected function attachListeners ( $ services , $ eventManager , $ listeners ) { $ lazyListeners = [ ] ; foreach ( $ listeners as $ name => $ options ) { $ options = $ this -> normalizeListenerOptions ( $ name , $ options ) ; if ( $ options [ 'lazy' ] && null !== $ options [ 'attach' ] ) { foreach ( $ options [ 'attach' ] as $ spec ) { $ lazyListeners [ ] = [ 'service' => $ options [ 'service' ] , 'event' => $ spec [ 'event' ] , 'method' => $ spec [ 'method' ] , 'priority' => $ spec [ 'priority' ] , ] ; } continue ; } if ( $ services -> has ( $ options [ 'service' ] ) ) { $ listener = $ services -> get ( $ options [ 'service' ] ) ; } elseif ( class_exists ( $ options [ 'service' ] , true ) ) { $ listener = new $ options [ 'service' ] ( ) ; } else { throw new \ UnexpectedValueException ( sprintf ( 'Class or service %s does not exists. Cannot create listener instance.' , $ options [ 'service' ] ) ) ; } if ( $ listener instanceof ListenerAggregateInterface ) { $ listener -> attach ( $ eventManager , $ options [ 'priority' ] ) ; continue ; } foreach ( $ options [ 'attach' ] as $ spec ) { $ callback = $ spec [ 'method' ] ? [ $ listener , $ spec [ 'method' ] ] : $ listener ; $ eventManager -> attach ( $ spec [ 'event' ] , $ callback , $ spec [ 'priority' ] ) ; } } if ( ! empty ( $ lazyListeners ) ) { $ aggregate = $ services -> get ( 'Core/Listener/DeferredListenerAggregate' ) ; $ aggregate -> setListeners ( $ lazyListeners ) -> attach ( $ eventManager ) ; } }
2602	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionaryName = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , $ dictionaryName ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || $ dictionary == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } else { return $ result -> setData ( [ 'status' => true ] ) ; } } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
3884	private function createSetting ( $ dbResult , $ filterSettings ) { $ factory = $ this -> getTypeFactory ( $ dbResult [ 'type' ] ) ; if ( $ factory ) { $ setting = $ factory -> createInstance ( $ dbResult , $ filterSettings ) ; if ( ! $ setting ) { return null ; } if ( $ factory -> isNestedType ( ) ) { $ this -> collectRulesFor ( $ setting , $ filterSettings ) ; } return $ setting ; } return null ; }
1937	private function convertValueToPath ( string $ value ) : string { $ filesAdapter = $ this -> framework -> getAdapter ( FilesModel :: class ) ; if ( Validator :: isUuid ( $ value ) && ( $ filesModel = $ filesAdapter -> findByUuid ( $ value ) ) instanceof FilesModel ) { return $ filesModel -> path ; } return $ value ; }
12083	public function getAllMedia ( $ objectType = 'media' , $ objectURI = NULL , $ objectId = NULL ) { $ objects = $ this -> getMediaObjectsList ( $ objectType , $ objectURI , $ objectId ) -> fetchAll ( ) ; $ items = array ( ) ; foreach ( $ objects as $ i => $ object ) { $ object = $ this -> getOwner ( $ object , $ object [ 'media_owner' ] ) ; if ( $ object [ 'object_type' ] === "attachment" ) : $ object [ 'media_object' ] = $ object [ 'object_uri' ] ; if ( empty ( $ object [ 'media_title' ] ) ) : $ object [ 'media_title' ] = $ object [ 'attachment_name' ] ; endif ; endif ; $ object [ 'media_comment_target' ] = $ object [ 'object_uri' ] ; $ object [ 'media_published' ] = $ object [ 'object_created_on' ] ; $ items [ ] = $ object ; } $ mediacollections = new Collection ( ) ; $ mediacollections :: set ( "items" , $ items ) ; $ mediacollections :: set ( "totalItems" , count ( $ items ) ) ; $ collection = $ mediacollections :: getArray ( ) ; return $ collection ; }
11046	function parse_containers ( $ containers ) { if ( ! is_array ( $ containers ) ) { $ containers = explode ( ',' , $ containers ) ; } foreach ( $ containers as $ container ) { $ masktree = $ this -> read_container ( $ container , _ETS_ROOT ) ; if ( $ masktree === FALSE ) { $ this -> error ( 11 , 52 , $ this -> container ) ; } else { $ this -> masktree = $ this -> masktree_merge ( $ this -> masktree , $ masktree , $ container ) ; } } }
3839	private function ensureSubmitElement ( $ panelRows ) { $ hasSubmit = false ; foreach ( $ panelRows as $ panelRow ) { foreach ( $ panelRow as $ element ) { if ( $ element instanceof SubmitElementInformationInterface ) { $ hasSubmit = true ; break ; } if ( $ hasSubmit ) { break ; } } } if ( ! $ hasSubmit && $ panelRows -> getRowCount ( ) ) { $ row = $ panelRows -> getRow ( $ panelRows -> getRowCount ( ) - 1 ) ; $ row -> addElement ( new DefaultSubmitElementInformation ( ) , 0 ) ; } }
6708	protected function getReaderFactory ( ) { if ( ! $ this -> readerFactory ) { $ this -> readerFactory = new ReaderFactory ( [ new Json ( ) , new Xml ( ) , ] ) ; } return $ this -> readerFactory ; }
10989	protected function _setData ( $ key , $ value ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerSet ( $ store , $ key , $ value ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ store ) ; } }
9645	public function makePdo ( array $ config , $ connection = null ) { if ( ! isset ( $ config [ 'driver' ] ) && ! isset ( $ config [ 'dsn' ] ) ) { throw new InvalidArgumentException ( 'DSN or driver must be set' ) ; } $ options = isset ( $ config [ 'pdo_options' ] ) ? $ config [ 'pdo_options' ] : [ ] ; unset ( $ config [ 'pdo_options' ] ) ; $ options = array_replace ( $ this -> defaultPdoOptions , $ options ) ; $ initCommands = isset ( $ config [ 'pdo_init_commands' ] ) ? $ config [ 'pdo_init_commands' ] : [ ] ; unset ( $ config [ 'pdo_init_commands' ] ) ; if ( isset ( $ config [ 'driver' ] ) && $ config [ 'driver' ] == 'sqlite' ) { $ this -> validate ( $ config , 'path' , $ connection ) ; $ dsn = $ this -> makeSqliteDsn ( $ config [ 'path' ] ) ; return $ this -> makePdoInner ( $ dsn , null , null , $ options , $ initCommands ) ; } elseif ( isset ( $ config [ 'dsn' ] ) && strpos ( $ config [ 'dsn' ] , 'sqlite:' ) === 0 ) { return $ this -> makePdoInner ( $ config [ 'dsn' ] , null , null , $ options , $ initCommands ) ; } $ this -> validate ( $ config , 'username' , $ connection , false ) ; $ username = $ config [ 'username' ] ; unset ( $ config [ 'username' ] ) ; $ this -> validate ( $ config , 'password' , $ connection , true ) ; $ password = $ config [ 'password' ] ; unset ( $ config [ 'password' ] ) ; if ( isset ( $ config [ 'dsn' ] ) ) { $ dsn = $ config [ 'dsn' ] ; } else { $ driver = $ config [ 'driver' ] ; unset ( $ config [ 'driver' ] ) ; $ this -> validate ( $ config , 'host' , $ connection ) ; $ this -> validate ( $ config , 'dbname' , $ connection ) ; $ dsn = $ this -> makeDsn ( $ driver , $ config ) ; } return $ this -> makePdoInner ( $ dsn , $ username , $ password , $ options , $ initCommands ) ; }
860	public function clearRange ( $ indexStart , $ indexEnd ) { for ( $ i = $ indexStart ; $ i <= $ indexEnd ; ++ $ i ) { $ this -> clearAt ( $ i ) ; } }
2419	protected function addTemplatesToArchive ( ZipWriter $ objArchive , $ strFolder ) { $ strFolder = preg_replace ( '@^templates/@' , '' , $ strFolder ) ; if ( $ strFolder == '' ) { $ strFolder = 'templates' ; } else { $ strFolder = 'templates/' . $ strFolder ; } if ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new \ RuntimeException ( 'Insecure path ' . $ strFolder ) ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { return ; } foreach ( scan ( $ this -> strRootDir . '/' . $ strFolder ) as $ strFile ) { if ( preg_match ( '/\.(html5|sql)$/' , $ strFile ) && strncmp ( $ strFile , 'be_' , 3 ) !== 0 && strncmp ( $ strFile , 'nl_' , 3 ) !== 0 ) { $ objArchive -> addFile ( $ strFolder . '/' . $ strFile ) ; } } }
4546	public function setIncludeAssignedTasks ( ? bool $ includeAssignedTasks ) { $ this -> includeAssignedTasks = $ includeAssignedTasks ; $ this -> _includeAssignedTasks = null !== $ includeAssignedTasks ; return $ this ; }
4118	public static function getType ( $ name ) { if ( ! isset ( self :: $ _typeObjects [ $ name ] ) ) { if ( ! isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: unknownType ( $ name ) ; } self :: $ _typeObjects [ $ name ] = new self :: $ _typesMap [ $ name ] ( ) ; } return self :: $ _typeObjects [ $ name ] ; }
207	public static function confirm ( $ message , $ default = false ) { while ( true ) { static :: stdout ( $ message . ' (yes|no) [' . ( $ default ? 'yes' : 'no' ) . ']:' ) ; $ input = trim ( static :: stdin ( ) ) ; if ( empty ( $ input ) ) { return $ default ; } if ( ! strcasecmp ( $ input , 'y' ) || ! strcasecmp ( $ input , 'yes' ) ) { return true ; } if ( ! strcasecmp ( $ input , 'n' ) || ! strcasecmp ( $ input , 'no' ) ) { return false ; } } }
10607	public function checkLoggedInAction ( ) { $ data = array ( 'logged' => 0 , 'data' => null ) ; if ( ! $ this -> zfcUserAuthentication ( ) -> hasIdentity ( ) ) { return new JsonModel ( $ data ) ; } $ identity = $ this -> zfcUserAuthentication ( ) -> getIdentity ( ) ; $ data [ 'logged' ] = 1 ; $ userModel = $ this -> getServiceLocator ( ) -> get ( 'user.model.user' ) ; $ data [ 'data' ] = $ userModel -> init ( $ identity , $ this -> getServiceLocator ( ) ) ; return new JsonModel ( $ data ) ; }
9674	public function allConditionalStyles ( Spreadsheet $ spreadsheet ) { $ aStyles = [ ] ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { foreach ( $ spreadsheet -> getSheet ( $ i ) -> getConditionalStylesCollection ( ) as $ conditionalStyles ) { foreach ( $ conditionalStyles as $ conditionalStyle ) { $ aStyles [ ] = $ conditionalStyle ; } } } return $ aStyles ; }
8388	public function addInnerJoin ( $ table , $ on ) { $ this -> innerJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
2560	private function checkAndCreateMopDetailedData ( $ fopType ) { if ( is_null ( $ this -> paymentModule -> mopDetailedData ) ) { $ this -> paymentModule -> mopDetailedData = new MopDetailedData ( $ fopType ) ; } }
6145	public function checkFragment ( $ fragment = null ) { if ( $ fragment === null ) { $ fragment = $ this -> fragment ; } if ( strlen ( $ fragment ) == 0 ) { return true ; } $ pattern = "/^" . $ this -> regex [ "uric" ] . "*$/" ; $ status = @ preg_match ( $ pattern , $ fragment ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI fragment validation failed" ) ; } return ( $ status == 1 ) ; }
392	protected static function filterCondition ( array $ condition , array $ aliases = [ ] ) { $ result = [ ] ; $ db = static :: getDb ( ) ; $ columnNames = static :: filterValidColumnNames ( $ db , $ aliases ) ; foreach ( $ condition as $ key => $ value ) { if ( is_string ( $ key ) && ! in_array ( $ db -> quoteSql ( $ key ) , $ columnNames , true ) ) { throw new InvalidArgumentException ( 'Key "' . $ key . '" is not a column name and can not be used as a filter' ) ; } $ result [ $ key ] = is_array ( $ value ) ? array_values ( $ value ) : $ value ; } return $ result ; }
9588	protected function isAttributeSet ( SimpleXmlElement $ node , $ name ) { $ attributes = $ node -> attributes ( ) ; return isset ( $ attributes [ $ name ] ) ; }
8879	private function isValidHomeDirectory ( string $ path ) : bool { $ valid = false ; if ( '~/' === substr ( $ path , 0 , 2 ) ) { $ valid = $ this -> isValidFullPath ( $ this -> expandHomeDirectory ( $ path ) ) ; } return $ valid ; }
1259	private function write ( $ str ) { $ this -> source .= $ this -> indentation ; if ( func_num_args ( ) == 1 ) { $ this -> source .= $ str . "\n" ; return $ this ; } $ this -> source .= vsprintf ( $ str , array_slice ( func_get_args ( ) , 1 ) ) . "\n" ; return $ this ; }
9026	public function hasEmail ( $ string ) { $ result = false ; $ tokenizer = new General ( ) ; $ words = $ tokenizer -> tokenize ( $ string ) ; foreach ( $ words as $ word ) { if ( filter_var ( $ word , FILTER_VALIDATE_EMAIL ) ) { $ result = true ; } } return $ result ; }
4198	public function onEnd ( Event $ event ) { $ obj = $ event -> getSubject ( ) ; if ( $ obj instanceof \ DOMNodeList ) { $ event [ 'properties' ] [ 'length' ] = \ array_merge ( static :: $ basePropInfo , array ( 'type' => 'integer' , 'value' => $ obj -> length , ) ) ; } elseif ( $ obj instanceof \ Exception ) { if ( isset ( $ event [ 'properties' ] [ 'xdebug_message' ] ) ) { $ event [ 'properties' ] [ 'xdebug_message' ] [ 'isExcluded' ] = true ; } } elseif ( $ obj instanceof \ mysqli && ! $ event [ 'collectPropertyValues' ] ) { $ propsAlwaysAvail = array ( 'client_info' , 'client_version' , 'connect_errno' , 'connect_error' , 'errno' , 'error' , 'stat' ) ; $ reflectionObject = $ event [ 'reflector' ] ; foreach ( $ propsAlwaysAvail as $ name ) { $ reflectionProperty = $ reflectionObject -> getProperty ( $ name ) ; $ event [ 'properties' ] [ $ name ] [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } }
5830	public function prepareRequest ( Request $ request ) { $ this -> ch = curl_init ( ) ; curl_setopt ( $ this -> ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ this -> ch , CURLOPT_HEADER , true ) ; curl_setopt ( $ this -> ch , CURLOPT_URL , $ request -> getUrl ( ) ) ; $ options = $ request -> getOptions ( ) ; if ( ! empty ( $ options ) ) { curl_setopt_array ( $ this -> ch , $ options ) ; } $ method = $ request -> getMethod ( ) ; if ( $ method === 'post' ) { curl_setopt ( $ this -> ch , CURLOPT_POST , 1 ) ; } elseif ( $ method !== 'get' ) { curl_setopt ( $ this -> ch , CURLOPT_CUSTOMREQUEST , strtoupper ( $ method ) ) ; } curl_setopt ( $ this -> ch , CURLOPT_HTTPHEADER , $ request -> formatHeaders ( ) ) ; if ( $ this -> methods [ $ method ] === true ) { curl_setopt ( $ this -> ch , CURLOPT_POSTFIELDS , $ request -> encodeData ( ) ) ; } }
12655	public function addTextContainer ( $ name , $ content , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { throw new \ Exception ( "Text container name already used." ) ; } $ this -> contents [ $ language ] [ $ name ] = array ( 'id' => $ name , 'name' => $ name , 'content' => $ content , 'outdated' => false ) ; $ this -> writeTextsToFile ( $ language ) ; if ( $ language === $ this -> baseLang ) { $ this -> setExtraLanguagesOutdated ( $ name , $ content ) ; } return $ this -> contents [ $ language ] [ $ name ] ; }
972	public function forget ( ) { $ keys = [ self :: DOMAIN , self :: USER , self :: TOKEN ] ; foreach ( $ keys as $ key ) { Session :: forget ( $ key ) ; } }
851	public function getTokenNotOfKindSibling ( $ index , $ direction , array $ tokens = [ ] ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( $ this -> isEmptyAt ( $ index ) ) { continue ; } if ( $ this [ $ index ] -> equalsAny ( $ tokens ) ) { continue ; } return $ index ; } }
10334	public function setName ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = 'Calibri' ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'name' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> name = $ pValue ; } return $ this ; }
3165	public function switchClientStoreId ( RunnerServiceContext $ context , $ receivedStoreId ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ sessionId = $ session -> getSessionId ( ) ; $ stateService = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) ; $ lastStoreId = $ stateService -> getStoreId ( $ sessionId ) ; if ( $ lastStoreId == false || $ lastStoreId != $ receivedStoreId ) { $ stateService -> setStoreId ( $ sessionId , $ receivedStoreId ) ; } return $ lastStoreId ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'switchClientStoreId' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
11128	protected function getClassName ( $ fileName ) { $ namePiece = @ explode ( $ this -> config [ 'modelsPrefix' ] , $ fileName ) ; $ name = isset ( $ namePiece [ 1 ] ) ? $ namePiece [ 1 ] : $ fileName ; $ namePiece = @ explode ( $ this -> config [ 'modelsPostfix' ] , $ name ) ; $ name = isset ( $ namePiece [ 1 ] ) ? $ namePiece [ 0 ] : $ name ; $ namePiece = explode ( '.php' , $ name ) ; $ name = isset ( $ namePiece [ 1 ] ) ? $ namePiece [ 0 ] : $ name ; return $ name ; }
8543	public function setShipmentEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5157	public function executeFor ( Route $ route ) : bool { if ( null === $ this -> pathConstraint ) { return true ; } return strpos ( $ route -> getPath ( ) , $ this -> pathConstraint ) === 0 ; }
4928	public function setListener ( $ event , $ service , $ method = null , $ priority = 0 ) { if ( is_int ( $ method ) ) { $ priority = $ method ; $ method = null ; } $ name = uniqid ( ) ; $ this -> listenerSpecs [ $ name ] = [ 'event' => $ event , 'service' => $ service , 'method' => $ method , 'priority' => $ priority , 'instance' => null , ] ; return $ this ; }
10652	protected function _unsetMany ( $ keys ) { $ keys = $ this -> _normalizeIterable ( $ keys ) ; $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerUnsetMany ( $ store , $ keys ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } }
2242	public static function getContentElement ( $ intId , $ strColumn = 'main' ) { if ( \ is_object ( $ intId ) ) { $ objRow = $ intId ; } else { if ( ! \ strlen ( $ intId ) || $ intId < 1 ) { return '' ; } $ objRow = ContentModel :: findByPk ( $ intId ) ; if ( $ objRow === null ) { return '' ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } $ strClass = ContentElement :: findClass ( $ objRow -> type ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Content element class "' . $ strClass . '" (content element "' . $ objRow -> type . '") does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = 'ce_' ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } if ( $ objElement -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
11434	public function registerResources ( Translator $ translator , array $ dirs ) { $ finder = new Finder ( ) ; $ files = $ finder -> files ( ) -> depth ( 0 ) -> ignoreUnreadableDirs ( ) -> in ( $ dirs ) ; foreach ( $ files as $ file ) { $ file = ( string ) $ file ; preg_match_all ( '/[^.]+/' , basename ( $ file ) , $ match ) ; $ translator -> addResource ( 'xliff' , $ file , $ match [ 0 ] [ 1 ] , "RedKiteCms" ) ; } }
12335	public function editProfileAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'edit-profile' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getEditProfileForm ( ) ; $ identity = $ this -> cmsAuthentication ( ) -> getIdentity ( ) ; $ form -> bind ( $ identity ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ result = $ this -> getUserService ( ) -> editProfile ( $ identity ) ; if ( $ result instanceof ResponseInterface ) { return $ result ; } elseif ( $ result ) { $ fm = $ this -> flashMessenger ( ) ; $ fm -> setNamespace ( $ form -> getName ( ) . '-' . $ fm :: NAMESPACE_SUCCESS ) -> addMessage ( $ this -> translate ( 'Data has been successfully saved' ) ) ; } } return new ViewModel ( compact ( 'form' ) ) ; }
7120	protected function getFindBySubjectAndSupplierQuery ( ) { if ( null !== $ this -> findBySubjectAndSupplierQuery ) { return $ this -> findBySubjectAndSupplierQuery ; } $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; return $ this -> findBySubjectAndSupplierQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ this -> getAlias ( ) . '.supplier' , ':supplier' ) ) -> getQuery ( ) ; }
11740	public function exportAction ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ chillSecurityHelper = $ this -> get ( 'chill.main.security.authorization.helper' ) ; $ user = $ this -> get ( 'security.context' ) -> getToken ( ) -> getUser ( ) ; $ reachableCenters = $ chillSecurityHelper -> getReachableCenters ( $ user , new Role ( 'CHILL_PERSON_SEE' ) ) ; $ personRepository = $ em -> getRepository ( 'ChillPersonBundle:Person' ) ; $ qb = $ personRepository -> createQueryBuilder ( 'p' ) ; $ qb -> where ( $ qb -> expr ( ) -> in ( 'p.center' , ':centers' ) ) -> setParameter ( 'centers' , $ reachableCenters ) ; $ persons = $ qb -> getQuery ( ) -> getResult ( ) ; $ response = $ this -> render ( 'ChillPersonBundle:Person:export.csv.twig' , array ( 'persons' => $ persons , 'cf_group' => $ this -> getCFGroup ( ) ) ) ; $ response -> headers -> set ( 'Content-Type' , 'text/csv; charset=utf-8' ) ; $ response -> headers -> set ( 'Content-Disposition' , 'attachment; filename="export_person.csv"' ) ; return $ response ; }
39	protected function generatePackageTree ( PackageInterface $ package , RepositoryInterface $ installedRepo , RepositoryInterface $ distantRepos ) { $ requires = $ package -> getRequires ( ) ; ksort ( $ requires ) ; $ children = array ( ) ; foreach ( $ requires as $ requireName => $ require ) { $ packagesInTree = array ( $ package -> getName ( ) , $ requireName ) ; $ treeChildDesc = array ( 'name' => $ requireName , 'version' => $ require -> getPrettyConstraint ( ) , ) ; $ deepChildren = $ this -> addTree ( $ requireName , $ require , $ installedRepo , $ distantRepos , $ packagesInTree ) ; if ( $ deepChildren ) { $ treeChildDesc [ 'requires' ] = $ deepChildren ; } $ children [ ] = $ treeChildDesc ; } $ tree = array ( 'name' => $ package -> getPrettyName ( ) , 'version' => $ package -> getPrettyVersion ( ) , 'description' => $ package -> getDescription ( ) , ) ; if ( $ children ) { $ tree [ 'requires' ] = $ children ; } return $ tree ; }
10459	public function finish ( $ outputStat = true ) { if ( $ outputStat === true ) { $ this -> output -> writeln ( '' ) ; $ this -> output -> writeln ( sprintf ( '<info>Job finished in %.2f s</info>' , microtime ( true ) - $ this -> start ) ) ; $ this -> output -> writeln ( sprintf ( '<info>Memory usage: %.2f MB</info>' , memory_get_peak_usage ( ) >> 20 ) ) ; } else { $ end = microtime ( true ) ; return [ 'start' => $ this -> start , 'finish' => $ end , 'duration' => $ end - $ this -> start , 'memory_peak' => memory_get_peak_usage ( ) >> 20 , ] ; } }
11007	public function requireSriFor ( bool $ script , bool $ style ) : void { if ( $ script && $ style ) { $ this -> tags [ 'require-sri-for' ] = [ 'script' , 'style' ] ; } else if ( $ script ) { $ this -> tags [ 'require-sri-for' ] = [ 'script' ] ; } else if ( $ style ) { $ this -> tags [ 'require-sri-for' ] = [ 'style' ] ; } }
3698	private function getOrCreateDefinition ( ) { if ( $ this -> container -> hasDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ) { $ view = $ this -> container -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; if ( ! $ view instanceof Contao2BackendViewDefinitionInterface ) { throw new DcGeneralInvalidArgumentException ( 'Configured BackendViewDefinition does not implement Contao2BackendViewDefinitionInterface.' ) ; } return $ view ; } $ this -> container -> setDefinition ( Contao2BackendViewDefinitionInterface :: NAME , $ view = new Contao2BackendViewDefinition ( ) ) ; return $ view ; }
34	protected function jobToText ( $ job ) { $ packageName = $ job [ 'packageName' ] ; $ constraint = $ job [ 'constraint' ] ; switch ( $ job [ 'cmd' ] ) { case 'install' : $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; if ( ! $ packages ) { return 'No package found to satisfy install request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) ; } return 'Installation request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . ' -> satisfiable by ' . $ this -> getPackageList ( $ packages ) . '.' ; case 'update' : return 'Update request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '.' ; case 'remove' : return 'Removal request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '' ; } if ( isset ( $ constraint ) ) { $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; } else { $ packages = array ( ) ; } return 'Job(cmd=' . $ job [ 'cmd' ] . ', target=' . $ packageName . ', packages=[' . $ this -> getPackageList ( $ packages ) . '])' ; }
6249	protected function prepareForPresentation ( ) { if ( $ this -> prepared ) { return ; } $ this -> permissionGroups = new Collection ; $ this -> ungroupedPermissions = [ ] ; $ this -> groupedPermissionIndex = [ ] ; $ this -> loadPermissionsFromModules ( ) -> loadCustomPermissions ( ) -> loadCustomPermissionGroups ( ) -> addUngroupedPermissionGroup ( ) -> filterEmptyGroups ( ) ; }
2089	public static function findPublishedBySourceAndParent ( $ strSource , $ intParent , $ blnDesc = false , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.source=? AND $t.parent=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = ( $ blnDesc ? "$t.date DESC" : "$t.date" ) ; } return static :: findBy ( $ arrColumns , array ( $ strSource , ( int ) $ intParent ) , $ arrOptions ) ; }
6006	public function toUnicode ( ) { $ h = ord ( $ this -> char { 0 } ) ; if ( $ h <= 0x7F ) { return $ h ; } else { if ( $ h < 0xC2 ) { return false ; } else { if ( $ h <= 0xDF ) { return ( $ h & 0x1F ) << 6 | ( ord ( $ this -> char { 1 } ) & 0x3F ) ; } else { if ( $ h <= 0xEF ) { return ( $ h & 0x0F ) << 12 | ( ord ( $ this -> char { 1 } ) & 0x3F ) << 6 | ( ord ( $ this -> char { 2 } ) & 0x3F ) ; } else { if ( $ h <= 0xF4 ) { return ( $ h & 0x0F ) << 18 | ( ord ( $ this -> char { 1 } ) & 0x3F ) << 12 | ( ord ( $ this -> char { 2 } ) & 0x3F ) << 6 | ( ord ( $ this -> char { 3 } ) & 0x3F ) ; } else { return false ; } } } } } }
8592	public function setFilterOptions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FilterOptions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1342	public function getParameters ( ) : EncodingParametersInterface { if ( $ this -> parameters ) { return $ this -> parameters ; } return $ this -> parameters = $ this -> container -> make ( EncodingParametersInterface :: class ) ; }
3354	public function copy ( $ target = null ) { Helper :: deprecate ( '2.0.0' , '3.0.0' , 'Use createLocalCopy() or createRemoteCopy() instead' ) ; return $ this -> api -> copyFile ( $ this -> getUrl ( ) , $ target ) ; }
12730	public function renderStraight ( Zend_Navigation_Container $ container = null ) { if ( $ container === null ) { $ container = $ this -> getContainer ( ) ; } if ( ! $ active = $ this -> findActive ( $ container ) ) { return '' ; } $ active = $ active [ 'page' ] ; if ( $ this -> getLinkLast ( ) ) { $ html = '<li>' . $ this -> htmlify ( $ active ) . '</li>' ; } else { $ html = $ active -> getLabel ( ) ; if ( $ this -> getUseTranslator ( ) && $ t = $ this -> getTranslator ( ) ) { $ html = $ t -> translate ( $ html ) ; } $ html = '<li class="active">' . $ this -> view -> escape ( $ html ) . '</li>' ; } while ( ( $ parent = $ active -> getParent ( ) ) != null ) { if ( $ parent instanceof Zend_Navigation_Page ) { $ html = '<li>' . $ this -> htmlify ( $ parent ) . ' <span class="divider">' . $ this -> getSeparator ( ) . '</span></li>' . PHP_EOL . $ html ; } if ( $ parent === $ container ) { break ; } $ active = $ parent ; } return strlen ( $ html ) ? $ this -> getIndent ( ) . '<ul class="breadcrumb">' . $ html . '</ul>' : '' ; }
1269	public function getSubscription ( $ name = null , $ beginDateTime = null , $ endDateTime = null , $ fileName = null , $ bookmark = null ) { if ( null !== $ beginDateTime ) { $ beginDateTime = $ this -> formatDateTime ( $ beginDateTime ) ; } if ( null !== $ endDateTime ) { $ endDateTime = $ this -> formatDateTime ( $ endDateTime ) ; } if ( null !== $ beginDateTime && null === $ endDateTime ) { $ endDateTime = $ this -> formatDateTime ( time ( ) ) ; } $ this -> name = $ name ; $ this -> beginDateTime = $ beginDateTime ; $ this -> endDateTime = $ endDateTime ; $ this -> fileName = $ fileName ; $ this -> bookmark = $ bookmark ; $ access = $ this -> createAccess ( ) ; $ request = $ this -> createRequest ( ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ access , $ request , $ this -> compileEndpointUrl ( self :: ENDPOINT ) ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { if ( isset ( $ response -> Bookmark ) ) { $ this -> setBookmark ( ( string ) $ response -> Bookmark ) ; } else { $ this -> setBookmark ( null ) ; } return $ this -> formatResponse ( $ response ) ; } }
12733	public function register ( array $ signals , $ callableArray = null ) { foreach ( $ signals as $ signal ) { if ( ! in_array ( $ signal , $ this -> _signals , true ) ) { $ signalName = static :: getSignalName ( $ signal ) ; throw new InvalidArgumentException ( "Signal [{$signalName}] is not supported. Use setSignals() to add support." , $ signal ) ; } } $ reg = new Listener ( $ signals ) ; $ reg -> setNotification ( $ callableArray ) ; $ this -> _byId [ $ reg -> id ] = $ reg ; foreach ( $ signals as $ signal ) { $ this -> _bySignal [ $ signal ] [ $ reg -> id ] = $ reg ; } return $ reg ; }
12218	public function shutdownHandler ( ) { $ error = error_get_last ( ) ; if ( $ error && $ error [ 'type' ] & $ this -> fatalErrors ) { $ this -> errorHandler ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } }
4360	public static function dump ( $ str , $ useHtml = false , $ sanitizeNonBinary = false ) { self :: $ useHtml = $ useHtml ; self :: $ sanitizeNonBinary = $ sanitizeNonBinary ; self :: setStr ( $ str ) ; $ controlCharAs = 'other' ; $ curBlockType = 'utf8' ; $ newBlockType = null ; $ curBlockStart = 0 ; $ strNew = '' ; while ( self :: $ curI < self :: $ stats [ 'strLen' ] ) { $ curI = self :: $ curI ; $ isUtf8 = self :: isOffsetUtf8 ( $ isSpecial , true ) ; if ( $ isUtf8 && $ isSpecial && $ controlCharAs !== 'utf8special' && \ ord ( $ str [ $ curI ] ) < 0x80 ) { if ( $ controlCharAs == 'other' ) { $ isUtf8 = false ; } elseif ( $ controlCharAs == 'utf8' ) { $ isSpecial = false ; } } if ( $ isUtf8 ) { if ( $ isSpecial ) { if ( $ curBlockType !== 'utf8special' ) { $ newBlockType = 'utf8special' ; } } else { if ( $ curBlockType !== 'utf8' ) { $ newBlockType = 'utf8' ; } } } else { if ( $ curBlockType !== 'other' ) { $ newBlockType = 'other' ; } } if ( $ newBlockType ) { $ len = $ curI - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; $ curBlockStart = $ curI ; $ curBlockType = $ newBlockType ; $ newBlockType = null ; } } $ len = self :: $ stats [ 'strLen' ] - $ curBlockStart ; self :: incStat ( $ curBlockType , $ len ) ; if ( self :: $ stats [ 'strLen' ] ) { $ percentOther = ( self :: $ stats [ 'bytesOther' ] ) / self :: $ stats [ 'strLen' ] * 100 ; if ( $ percentOther > 33 ) { $ strNew = self :: dumpBlock ( $ str , 'other' , array ( 'prefix' => false ) ) ; } else { $ subStr = \ substr ( self :: $ str , $ curBlockStart , $ len ) ; $ strNew .= self :: dumpBlock ( $ subStr , $ curBlockType ) ; } } return $ strNew ; }
9711	private function writeBoundSheet ( $ sheet , $ offset ) { $ sheetname = $ sheet -> getTitle ( ) ; $ record = 0x0085 ; switch ( $ sheet -> getSheetState ( ) ) { case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: SHEETSTATE_VISIBLE : $ ss = 0x00 ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: SHEETSTATE_HIDDEN : $ ss = 0x01 ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: SHEETSTATE_VERYHIDDEN : $ ss = 0x02 ; break ; default : $ ss = 0x00 ; break ; } $ st = 0x00 ; $ grbit = 0x0000 ; $ data = pack ( 'VCC' , $ offset , $ ss , $ st ) ; $ data .= StringHelper :: UTF8toBIFF8UnicodeShort ( $ sheetname ) ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ data ) ; }
135	public function ensureBinariesPresence ( PackageInterface $ package ) { try { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; } catch ( \ InvalidArgumentException $ e ) { return ; } if ( $ installer instanceof BinaryPresenceInterface ) { $ installer -> ensureBinariesPresence ( $ package ) ; } }
1763	public function onKernelTerminate ( PostResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || ! $ this -> canRunController ( $ event -> getRequest ( ) ) ) { return ; } $ controller = $ this -> framework -> createInstance ( FrontendCron :: class ) ; $ controller -> run ( ) ; }
12457	protected function onSuccessLoad ( ) { if ( $ this -> Web2All -> DebugLevel > Web2All_Manager_Main :: DEBUGLEVEL_MEDIUM ) { $ this -> Web2All -> debugLog ( 'Web2All_Table_Object::loadFromTable(): loaded: ' . $ this -> asDebugString ( ) ) ; } }
11275	protected function buildResponse ( ) { $ res = array ( ) ; $ res [ 'type' ] = $ this -> getParameters ( ) -> getType ( ) ; $ res [ 'tid' ] = $ this -> getParameters ( ) -> getTid ( ) ; $ res [ 'action' ] = $ this -> getParameters ( ) -> getAction ( ) ; $ res [ 'method' ] = $ this -> getParameters ( ) -> getMethod ( ) ; $ res [ 'result' ] = $ this -> getResult ( ) ; return $ res ; }
289	protected function isLanguageSupported ( $ requested , $ supported ) { $ supported = str_replace ( '_' , '-' , strtolower ( $ supported ) ) ; $ requested = str_replace ( '_' , '-' , strtolower ( $ requested ) ) ; return strpos ( $ requested . '-' , $ supported . '-' ) === 0 ; }
1673	public function isUnprotected ( ) { $ path = $ this -> strFolder ; do { if ( file_exists ( $ this -> strRootDir . '/' . $ path . '/.public' ) ) { return true ; } $ path = \ dirname ( $ path ) ; } while ( $ path != '.' ) ; return false ; }
1192	private function addCustomAttributes ( array $ attributes , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ attributes as $ attribute ) { $ required = ! empty ( $ attribute [ 3 ] ) ? true : false ; $ onElement = $ attribute [ 0 ] ; $ attrName = $ required ? $ attribute [ 1 ] . '*' : $ attribute [ 1 ] ; $ validValues = $ attribute [ 2 ] ; $ definition -> addAttribute ( $ onElement , $ attrName , $ validValues ) ; } return $ definition ; }
4492	public function broadcast ( Message $ message , string $ topicArn ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $topicArn" , [ 'Message' => $ message , ] ) ; return ; } $ this -> messages -> send ( $ message , $ topicArn ) ; }
865	private function skipNonArrayElements ( $ index , Tokens $ tokens ) { if ( $ tokens [ $ index ] -> equals ( '}' ) ) { return $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ; } if ( $ tokens [ $ index ] -> equals ( ')' ) ) { $ startIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ startIndex = $ tokens -> getPrevMeaningfulToken ( $ startIndex ) ; if ( ! $ tokens [ $ startIndex ] -> isGivenKind ( [ T_ARRAY , CT :: T_ARRAY_SQUARE_BRACE_OPEN ] ) ) { return $ startIndex ; } } return $ index ; }
5677	protected function stringDiffersAt ( $ first , $ second ) { if ( ! $ first || ! $ second ) { return 0 ; } if ( strlen ( $ first ) < strlen ( $ second ) ) { list ( $ first , $ second ) = array ( $ second , $ first ) ; } $ position = 0 ; $ step = strlen ( $ first ) ; while ( $ step > 1 ) { $ step = ( integer ) ( ( $ step + 1 ) / 2 ) ; if ( strncmp ( $ first , $ second , $ position + $ step ) == 0 ) { $ position += $ step ; } } return $ position ; }
9562	protected function matchesTypehint ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return true ; } if ( is_array ( $ handler ) ) { $ reflection = ( new ReflectionMethod ( $ handler [ 0 ] , $ handler [ 1 ] ) ) ; } else { $ reflection = ( new ReflectionFunction ( $ handler ) ) ; } $ params = $ reflection -> getParameters ( ) ; if ( empty ( $ params ) ) { return true ; } $ handlerHint = $ params [ 0 ] -> getClass ( ) ; if ( ! $ handlerHint ) { return true ; } return $ handlerHint -> isInstance ( $ exception ) ; }
2981	private function findLastImportedPath ( $ yamlContents ) { $ data = Yaml :: parse ( $ yamlContents ) ; if ( ! isset ( $ data [ 'imports' ] ) ) { return false ; } $ lastImport = end ( $ data [ 'imports' ] ) ; if ( ! isset ( $ lastImport [ 'resource' ] ) ) { return false ; } return $ lastImport [ 'resource' ] ; }
3825	protected function compile ( ) { $ objItemRenderer = new ItemList ( ) ; $ this -> Template -> searchable = ! $ this -> metamodel_donotindex ; $ sorting = $ this -> metamodel_sortby ; $ direction = $ this -> metamodel_sortby_direction ; if ( $ this -> metamodel_sort_override ) { if ( \ Input :: get ( 'orderBy' ) ) { $ sorting = \ Input :: get ( 'orderBy' ) ; } if ( \ Input :: get ( 'orderDir' ) ) { $ direction = \ Input :: get ( 'orderDir' ) ; } } $ objItemRenderer -> setServiceContainerFallback ( function ( ) { return $ this -> getServiceContainer ( ) ; } ) -> setFactory ( System :: getContainer ( ) -> get ( 'metamodels.factory' ) ) -> setFilterFactory ( System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ) -> setRenderSettingFactory ( System :: getContainer ( ) -> get ( 'metamodels.render_setting_factory' ) ) -> setEventDispatcher ( System :: getContainer ( ) -> get ( 'event_dispatcher' ) ) -> setMetaModel ( $ this -> metamodel , $ this -> metamodel_rendersettings ) -> setLimit ( $ this -> metamodel_use_limit , $ this -> metamodel_offset , $ this -> metamodel_limit ) -> setPageBreak ( $ this -> perPage ) -> setSorting ( $ sorting , $ direction ) -> setFilterSettings ( $ this -> metamodel_filtering ) -> setFilterParameters ( StringUtil :: deserialize ( $ this -> metamodel_filterparams , true ) , $ this -> getFilterParameters ( $ objItemRenderer ) ) -> setMetaTags ( $ this -> metamodel_meta_title , $ this -> metamodel_meta_description ) ; $ this -> Template -> items = \ StringUtil :: encodeEmail ( $ objItemRenderer -> render ( $ this -> metamodel_noparsing , $ this ) ) ; $ this -> Template -> numberOfItems = $ objItemRenderer -> getItems ( ) -> getCount ( ) ; $ this -> Template -> pagination = $ objItemRenderer -> getPagination ( ) ; }
2161	public function run33Update ( ) { $ objLayout = $ this -> Database -> query ( "SELECT id, framework FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ strFramework = '' ; $ tmp = StringUtil :: deserialize ( $ objLayout -> framework ) ; if ( ! empty ( $ tmp ) && \ is_array ( $ tmp ) ) { if ( ( $ key = array_search ( 'layout.css' , $ tmp ) ) !== false ) { array_insert ( $ tmp , $ key + 1 , 'responsive.css' ) ; } $ strFramework = serialize ( array_values ( array_unique ( $ tmp ) ) ) ; } $ this -> Database -> prepare ( "UPDATE tl_layout SET framework=? WHERE id=?" ) -> execute ( $ strFramework , $ objLayout -> id ) ; } $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `viewport` varchar(64) NOT NULL default ''" ) ; }
12853	public function import ( Package $ package , $ id = null ) { $ id = is_null ( $ id ) ? $ package -> id : $ id ; $ this -> symbols = array_merge ( $ package -> symbols , $ this -> symbols ) ; $ this -> macros = array_merge ( $ package -> macros , $ this -> macros ) ; $ this -> packages [ $ id ] = $ package ; }
5099	public function into ( $ table , array $ fields = null ) { $ this -> setPart ( CmdInsert :: PART_INTO , $ table ) ; if ( ! is_null ( $ fields ) ) { $ this -> placeholder = false ; $ this -> fields = $ fields ; } return $ this ; }
11063	public function getRealEncoding ( $ encoding ) { if ( static :: isEncodingSupported ( $ encoding ) === false ) { throw new \ Exception ( 'Encoding is not supported: "' . $ encoding . '"' ) ; } return static :: supportedEncodings ( ) [ strtolower ( $ encoding ) ] ; }
2071	private function getDateAndTime ( CalendarEventsModel $ objEvent , PageModel $ objPage , $ intStartTime , $ intEndTime , $ span ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) ; if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> dateFormat , $ intEndTime ) ; } $ strTime = '' ; if ( $ objEvent -> addTime ) { if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> datimFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> datimFormat , $ intEndTime ) ; } elseif ( $ intStartTime == $ intEndTime ) { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) ; } else { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> timeFormat , $ intEndTime ) ; } } return array ( $ strDate , $ strTime ) ; }
1043	public static function printError ( Error $ error ) { $ printedLocations = [ ] ; if ( $ error -> nodes ) { foreach ( $ error -> nodes as $ node ) { if ( ! $ node -> loc ) { continue ; } if ( $ node -> loc -> source === null ) { continue ; } $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ node -> loc -> source , $ node -> loc -> source -> getLocation ( $ node -> loc -> start ) ) ; } } elseif ( $ error -> getSource ( ) && $ error -> getLocations ( ) ) { $ source = $ error -> getSource ( ) ; foreach ( $ error -> getLocations ( ) as $ location ) { $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ source , $ location ) ; } } return ! $ printedLocations ? $ error -> getMessage ( ) : implode ( "\n\n" , array_merge ( [ $ error -> getMessage ( ) ] , $ printedLocations ) ) . "\n" ; }
6962	public static function B ( $ year ) { $ jd = static :: B1900 ( ) -> jd + ( $ year - 1900 ) * static :: DaysBesselianYear ; $ epoch = new static ( $ jd ) ; $ epoch -> type = YearType :: Besselian ( ) ; return $ epoch ; }
531	protected function splitChangelog ( $ file , $ version ) { $ lines = explode ( "\n" , file_get_contents ( $ file ) ) ; $ start = [ ] ; $ changelog = [ ] ; $ end = [ ] ; $ state = 'start' ; foreach ( $ lines as $ l => $ line ) { if ( isset ( $ lines [ $ l - 2 ] ) && strpos ( $ lines [ $ l - 2 ] , $ version ) !== false && isset ( $ lines [ $ l - 1 ] ) && strncmp ( $ lines [ $ l - 1 ] , '---' , 3 ) === 0 ) { $ state = 'changelog' ; } if ( $ state === 'changelog' && isset ( $ lines [ $ l + 1 ] ) && strncmp ( $ lines [ $ l + 1 ] , '---' , 3 ) === 0 ) { $ state = 'end' ; } if ( ! empty ( $ { $ state } ) && trim ( $ line ) !== '' && strncmp ( $ line , '- ' , 2 ) !== 0 ) { end ( $ { $ state } ) ; $ { $ state } [ key ( $ { $ state } ) ] .= "\n" . $ line ; } else { $ { $ state } [ ] = $ line ; } } return [ $ start , $ changelog , $ end ] ; }
4215	private static function keys ( $ val ) { if ( Abstracter :: isAbstraction ( $ val ) ) { if ( $ val [ 'type' ] == 'object' ) { if ( $ val [ 'traverseValues' ] ) { $ val = $ val [ 'traverseValues' ] ; } elseif ( $ val [ 'stringified' ] ) { $ val = null ; } elseif ( isset ( $ val [ 'methods' ] [ '__toString' ] [ 'returnValue' ] ) ) { $ val = null ; } else { $ val = \ array_filter ( $ val [ 'properties' ] , function ( $ prop ) { return $ prop [ 'visibility' ] === 'public' ; } ) ; \ ksort ( $ val , SORT_NATURAL | SORT_FLAG_CASE ) ; } } else { $ val = null ; } } return \ is_array ( $ val ) ? \ array_keys ( $ val ) : array ( self :: SCALAR ) ; }
12823	protected function createContributorDir ( $ sourceDir , array $ options , $ username ) { if ( null === $ username ) { return ; } $ this -> init ( $ sourceDir , $ options , $ username ) ; if ( is_dir ( $ this -> contributorDir ) ) { return ; } $ this -> filesystem -> copy ( $ this -> productionDir . '/slot.json' , $ this -> contributorDir . '/slot.json' , true ) ; $ this -> filesystem -> mirror ( $ this -> productionDir . '/blocks' , $ this -> contributorDir . '/blocks' ) ; }
5266	public static function merge ( Model $ model1 , Model $ model2 , array $ attributes ) { foreach ( $ attributes as $ attribute ) { $ model1 -> $ attribute = $ model2 -> $ attribute ; } return $ model1 ; }
7800	protected function splitStatements ( $ text ) { $ chunks = preg_split ( '/^:20:/m' , $ text , - 1 ) ; $ chunks = array_filter ( array_map ( 'trim' , array_slice ( $ chunks , 1 ) ) ) ; return array_map ( function ( $ statement ) { return ':20:' . $ statement ; } , $ chunks ) ; }
4409	protected function render ( $ template , $ parameters ) { $ twig = new Twig_Environment ( new Twig_Loader_Filesystem ( $ this -> skeletonDirs ) , array ( 'debug' => true , 'cache' => false , 'strict_variables' => true , 'autoescape' => false , ) ) ; return $ twig -> render ( $ template , $ parameters ) ; }
3792	private function getModelById ( $ modelId ) { if ( $ modelId === null ) { return null ; } $ provider = $ this -> environment -> getDataProvider ( ) ; $ config = $ provider -> getEmptyConfig ( ) -> setId ( $ modelId ) ; return $ provider -> fetch ( $ config ) ; }
1188	public function validatorClosure ( ) { return function ( $ attribute , $ value , $ parameters , BaseValidator $ validator ) { $ remoteValidator = new Validator ( $ validator ) ; $ remoteValidator -> validate ( $ value , $ parameters ) ; return $ attribute ; } ; }
11091	public static function gpsDistance ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) { $ lat1 = deg2rad ( $ lat1 ) ; $ lon1 = deg2rad ( $ lon1 ) ; $ lat2 = deg2rad ( $ lat2 ) ; $ lon2 = deg2rad ( $ lon2 ) ; $ lonDelta = $ lon2 - $ lon1 ; $ a = ( ( cos ( $ lat2 ) * sin ( $ lonDelta ) ) ** 2 ) + ( ( cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lonDelta ) ) ** 2 ) ; $ b = sin ( $ lat1 ) * sin ( $ lat2 ) + cos ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lonDelta ) ; return atan2 ( sqrt ( $ a ) , $ b ) * 6371.0088 ; }
7303	public function onParentChange ( ResourceEventInterface $ event ) { $ customer = $ this -> getCustomerFromEvent ( $ event ) ; if ( $ this -> updateFromParent ( $ customer ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ customer , true ) ; } }
5367	public function paintException ( $ message ) { parent :: paintException ( $ message ) ; $ this -> results [ ] = new SimpleResultOfException ( parent :: getTestList ( ) , $ message ) ; }
8781	public function save ( $ content = null , $ time = 30 ) { $ fileName = md5 ( $ this -> prefix . http ( ) -> server ( 'REQUEST_URI' ) ) . $ this -> extension ; $ this -> file = cache_path ( 'html' . DIRECTORY_SEPARATOR . $ fileName ) ; $ this -> start ( $ time ) ; return $ this -> finish ( $ content ) ; }
1381	protected function validateToMany ( array $ value , ? string $ field = null ) : bool { $ path = $ field ? "/data/relationships/{$field}/data" : "/data" ; $ valid = true ; foreach ( $ value as $ index => $ item ) { if ( ! $ this -> validateIdentifier ( $ item , $ path , $ index ) ) { $ valid = false ; continue ; } if ( $ this -> isNotFound ( $ item -> type , $ item -> id ) ) { $ this -> resourceDoesNotExist ( "{$path}/{$index}" ) ; $ valid = false ; } } return $ valid ; }
62	public function unlink ( $ path ) { $ unlinked = @ $ this -> unlinkImplementation ( $ path ) ; if ( ! $ unlinked ) { if ( Platform :: isWindows ( ) ) { usleep ( 350000 ) ; $ unlinked = @ $ this -> unlinkImplementation ( $ path ) ; } if ( ! $ unlinked ) { $ error = error_get_last ( ) ; $ message = 'Could not delete ' . $ path . ': ' . @ $ error [ 'message' ] ; if ( Platform :: isWindows ( ) ) { $ message .= "\nThis can be due to an antivirus or the Windows Search Indexer locking the file while they are analyzed" ; } throw new \ RuntimeException ( $ message ) ; } } return true ; }
10821	public static function title ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'title' , $ length , $ separator ) ; }
9801	public static function setLibXmlLoaderOptions ( $ options ) { if ( $ options === null && defined ( 'LIBXML_DTDLOAD' ) ) { $ options = LIBXML_DTDLOAD | LIBXML_DTDATTR ; } self :: $ libXmlLoaderOptions = $ options ; }
9770	function matchFormat ( string $ format ) : self { return $ this -> expect ( $ this -> target , matches ( $ format ) ) ; }
8926	public static function fetch ( $ dir = false ) { if ( false === $ dir ) { $ dir = getcwd ( ) ; } $ config = [ ] ; $ files = glob ( $ dir . '/config/*.config.php' , GLOB_BRACE ) ; foreach ( $ files as $ file ) { $ config = array_merge ( $ config , ( require $ file ) ) ; } return $ config ; }
398	public function delete ( ) { if ( ! $ this -> isTransactional ( self :: OP_DELETE ) ) { return $ this -> deleteInternal ( ) ; } $ transaction = static :: getDb ( ) -> beginTransaction ( ) ; try { $ result = $ this -> deleteInternal ( ) ; if ( $ result === false ) { $ transaction -> rollBack ( ) ; } else { $ transaction -> commit ( ) ; } return $ result ; } catch ( \ Exception $ e ) { $ transaction -> rollBack ( ) ; throw $ e ; } catch ( \ Throwable $ e ) { $ transaction -> rollBack ( ) ; throw $ e ; } }
10120	private function writeMarginTop ( ) { $ record = 0x0028 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getTop ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
3163	public function startTimer ( RunnerServiceContext $ context , $ timestamp = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INTERACTING ) { $ session -> startItemTimer ( $ timestamp ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'startTimer' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
10825	public static function choice ( $ question , array $ choices , $ defaultValue = null ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( ( string ) $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( count ( $ choices ) > 0 ) { foreach ( $ choices as $ index => $ choice ) { self :: write ( ' [' ) ; self :: write ( ( string ) ( $ index + 1 ) , 'comment' ) ; self :: writeln ( '] ' . $ choice ) ; } } if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( ! isset ( $ choices [ intval ( $ value ) - 1 ] ) ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] Value "' . $ value . '" is invalid' , 'error' ) ; $ value = '' ; } elseif ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
7957	public function getProperties ( ) { $ this -> properties = json_decode ( self :: getClient ( ) -> getProperties ( $ this -> id ) ) ; return $ this -> properties ; }
4779	public function removeWidget ( string $ widgetId ) { if ( isset ( $ this -> widgets [ $ widgetId ] ) ) { unset ( $ this -> widgets [ $ widgetId ] ) ; } return $ this ; }
4895	public function render ( $ type = null , $ content = true , array $ options = array ( ) ) { if ( is_array ( $ type ) ) { $ options = $ type ; $ type = self :: TYPE_INFO ; $ content = true ; } elseif ( is_array ( $ content ) ) { $ options = $ content ; $ content = true ; } if ( true === $ content ) { return $ this -> start ( $ type , $ options ) ; } $ id = isset ( $ options [ 'id' ] ) ? ' id="' . $ options [ 'id' ] . '"' : '' ; $ class = isset ( $ options [ 'class' ] ) ? ' ' . $ options [ 'class' ] : '' ; if ( ( isset ( $ options [ 'dismissable' ] ) && $ options [ 'dismissable' ] ) || ! isset ( $ options [ 'dismissable' ] ) ) { $ class .= ' alert-dismissable' ; $ content = '<button type="button" class="close" data-dismiss="alert">&times;</button>' . '<span class="notification-content">' . $ content . '</span>' ; } $ target = array_key_exists ( 'target' , $ options ) ? ' target="' . $ options [ 'target' ] . '"' : '' ; $ markup = '<div ' . $ id . ' class="alert alert-' . $ type . $ class . '" ' . $ target . '>' . $ content . '</div>' . PHP_EOL ; return $ markup ; }
5979	public function propertysets ( ) { if ( ! $ this -> propertysets instanceof PropertysetsController ) { $ this -> propertysets = new PropertysetsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> propertysets -> setLogger ( $ this -> logger ) ; } return $ this -> propertysets ; }
4077	protected function getPaletteCombinationRows ( ) { $ combinations = $ this -> getCombinationsFromDatabase ( ) ; $ success = array ( ) ; if ( ! $ combinations ) { return array_keys ( $ this -> information ) ; } foreach ( $ combinations as $ combination ) { $ modelId = $ combination -> pid ; $ modelName = $ this -> tableNameFromId ( $ modelId ) ; if ( ! empty ( $ this -> information [ $ modelName ] [ self :: COMBINATION ] ) ) { continue ; } $ this -> information [ $ modelName ] [ self :: MODELID ] = $ modelId ; $ this -> information [ $ modelName ] [ self :: COMBINATION ] = array ( 'dca_id' => $ combination -> dca_id , 'view_id' => $ combination -> view_id ) ; $ this -> setTableMapping ( $ modelId , $ modelName ) ; $ success [ ] = $ modelId ; } return $ success ; }
2498	private function getLanguageFilter ( array $ languageCodes ) { $ languageFilters = array ( ) ; foreach ( $ languageCodes as $ languageCode ) { $ condition = new CustomField ( self :: FIELD_LANGUAGE , Operator :: EQ , $ languageCode ) ; $ excluded = $ this -> getExcludedLanguageCodes ( $ languageCodes , $ languageCode ) ; if ( ! empty ( $ excluded ) ) { $ condition = new LogicalAnd ( array ( $ condition , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ excluded ) ) , ) ) ; } $ languageFilters [ ] = $ condition ; } if ( count ( $ languageFilters ) > 1 ) { $ languageFilters = array ( new LogicalOr ( $ languageFilters ) ) ; } if ( $ this -> hasMainLanguagesEndpoint ) { $ languageFilters [ ] = new LogicalNot ( new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ) ; } if ( count ( $ languageFilters ) > 1 ) { return new LogicalAnd ( $ languageFilters ) ; } return reset ( $ languageFilters ) ; }
629	public function queryScalar ( ) { $ result = $ this -> queryInternal ( 'fetchColumn' , 0 ) ; if ( is_resource ( $ result ) && get_resource_type ( $ result ) === 'stream' ) { return stream_get_contents ( $ result ) ; } return $ result ; }
1816	public function pagePicker ( Contao \ DataContainer $ dc ) { @ trigger_error ( 'Using tl_content::pagePicker() has been deprecated and will no longer work in Contao 5.0. Set the "dcaPicker" eval attribute instead.' , E_USER_DEPRECATED ) ; return Contao \ Backend :: getDcaPickerWizard ( true , $ dc -> table , $ dc -> field , $ dc -> inputName ) ; }
8649	private function calculateStringToSignV2 ( array $ parameters , $ queuepath = null ) { $ parsedUrl = parse_url ( $ this -> config [ 'ServiceURL' ] ) ; $ endpoint = $ parsedUrl [ 'host' ] ; if ( isset ( $ parsedUrl [ 'port' ] ) && ! is_null ( $ parsedUrl [ 'port' ] ) ) { $ endpoint .= ':' . $ parsedUrl [ 'port' ] ; } $ data = 'POST' ; $ data .= "\n" ; $ data .= $ endpoint ; $ data .= "\n" ; if ( $ queuepath ) { $ uri = $ queuepath ; } else { $ uri = "/" ; } $ uriencoded = implode ( "/" , array_map ( array ( $ this , "urlencode" ) , explode ( "/" , $ uri ) ) ) ; $ data .= $ uriencoded ; $ data .= "\n" ; uksort ( $ parameters , 'strcmp' ) ; $ data .= $ this -> getParametersAsString ( $ parameters ) ; return $ data ; }
8921	protected function parseRelationship ( $ node ) { $ rel = array ( ) ; $ x = preg_replace ( '/\(.*?\)/' , '' , $ node -> text ( 'marc:subfield[@code="w"]' ) ) ; if ( ! empty ( $ x ) ) { $ rel [ 'id' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="t"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'title' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="g"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'parts' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="x"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'issn' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="z"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'isbn' ] = $ x ; } return $ rel ; }
12317	public function load ( $ name ) { foreach ( $ this -> sourceDirs as $ dir ) { if ( 0 === strpos ( $ name , DIRECTORY_SEPARATOR ) ) { $ yamlFile = $ name ; } else { $ yamlFile = $ dir . '/' . $ name ; } if ( false === strstr ( $ yamlFile , self :: EXT_YML ) ) { $ yamlFile .= self :: EXT_YML ; } if ( is_file ( $ yamlFile ) ) { return new ArrayCollection ( Yaml :: parse ( $ yamlFile ) ) ; } } throw new \ Exception ( sprintf ( 'No Yaml file found for {%s}' , $ name ) ) ; }
2990	public function uploadFromPath ( $ path ) { $ file = new FormUpload ( $ path ) ; $ this -> request -> setParam ( 'content' , $ file ) ; return $ this ; }
249	public function regenerateID ( $ deleteOldSession = false ) { if ( $ this -> getIsActive ( ) ) { if ( YII_DEBUG && ! headers_sent ( ) ) { session_regenerate_id ( $ deleteOldSession ) ; } else { @ session_regenerate_id ( $ deleteOldSession ) ; } } }
8028	public function registerFreeProcess ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; if ( $ this -> hasProcess ( $ pid ) === FALSE ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not register free process. Process (%d) not in list.' , $ processDetails -> getPid ( ) ) , 1400761296 ) ; } $ this -> freeProcessIds [ $ pid ] = $ pid ; return $ this ; }
2437	public function setData ( $ arrData ) { if ( ! \ is_array ( $ arrData ) ) { throw new \ Exception ( 'Array required to set session data' ) ; } foreach ( $ this -> mappedKeys as $ strKey ) { if ( isset ( $ arrData [ $ strKey ] ) ) { $ this -> session -> set ( $ strKey , $ arrData [ $ strKey ] ) ; unset ( $ arrData [ $ strKey ] ) ; } } $ this -> sessionBag -> replace ( $ arrData ) ; }
12543	public function getLink ( ) : string { if ( $ this -> link === null ) { return str_replace ( "?" . $ _SERVER [ "QUERY_STRING" ] , "" , $ _SERVER [ "REQUEST_URI" ] ) ; } else { return $ this -> link ; } }
7001	public function method ( $ method = null ) { if ( $ method ) $ this -> method = trim ( $ method ) ; return $ this -> method ; }
9518	public function getUsage ( $ withEncapsulation = true , $ withAliases = true ) { $ usage = '' ; if ( $ withEncapsulation ) { $ usage = ( $ this -> required ? '' : '[' ) ; } $ aliases = ( $ withAliases ? $ this -> getAliasUsage ( ) : '' ) ; $ usage .= $ this -> prefix . $ this -> parameterName . $ aliases . ' ' ; $ usage .= $ this -> getPropertiesAsString ( ) ; return $ usage . ( $ withEncapsulation ? ( $ this -> required ? '' : ']' ) : '' ) ; }
6650	public function unlinkFiles ( $ fileName ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ fileName ) { if ( @ file_exists ( $ folder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ fileName ) ; } } }
5304	public function getPath ( $ scale = 1 , $ roundPrecision = null , $ flip = 'none' , $ onlyFilled = true , $ xOffset = 0 , $ yOffset = 0 ) { $ path = $ this -> getPathPart ( $ this -> xmlDocument , $ onlyFilled ) ; if ( $ scale !== 1 || $ roundPrecision !== null || $ flip !== 'none' || $ xOffset !== 0 || $ yOffset !== 0 ) { $ path = $ this -> transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset / $ scale , $ yOffset / $ scale ) ; } return trim ( $ path ) ; }
7122	protected function detectAndApplyLanguage ( ) { if ( $ this -> config ( 'autodetect' , true ) ) { $ detector = $ this -> getLanguageDetector ( ) ; $ language = $ detector -> getLanguageFromCookie ( ) ; if ( ! $ language || strlen ( $ language ) > 5 || ! in_array ( $ language , $ this -> getSupportedLanguages ( ) , true ) ) { $ language = $ detector -> getDriver ( ) -> detect ( ) ; if ( ! $ language || strlen ( $ language ) > 5 ) { $ language = $ this -> request -> getDefaultLocale ( ) ; } } $ this -> applyNewLanguage ( $ language , true ) ; } }
12520	protected function getWhereFromParameter ( ParameterInterface $ parameter ) { if ( $ parameter instanceof IdAwareParameterInterface && $ parameter -> getId ( ) ) { return [ 'id' => $ parameter -> getId ( ) ] ; } else { return [ 'namespace' => $ parameter -> getNamespace ( ) , 'name' => $ parameter -> getName ( ) ] ; } }
469	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } return $ model ; }
9468	public function map ( ) { $ this -> namespace ( 'System' ) -> prefix ( 'system' ) -> name ( 'system.' ) -> group ( function ( ) { $ this -> registerSystemInformationRoutes ( ) ; $ this -> registerLogViewerRoutes ( ) ; $ this -> registerRouteViewerRoutes ( ) ; } ) ; }
4394	public function capture ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsCapture ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> capture ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ; $ order -> setPaymentStatus ( $ status ) ; } }
6079	public function combineSlides ( array $ structure ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'structure' => $ structure ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/slides/combine' , $ parameters ) ; return $ result ; }
9248	public function from ( Contract $ contract , string $ string , callable $ callback = null ) : string { return $ this -> callback ( $ contract -> recipe ( $ string , 'upperCaseFirst' , function ( $ string ) use ( $ contract ) { if ( $ contract instanceof ClassName ) { return lcfirst ( $ string ) ; } return strtolower ( $ string ) ; } ) , $ callback ) ; }
4088	protected function transformDSLSortToString ( $ dslSort ) { $ string = "" ; if ( is_array ( $ dslSort ) ) { foreach ( $ dslSort as $ sort ) { if ( is_array ( $ sort ) ) { $ field = key ( $ sort ) ; $ info = current ( $ sort ) ; } else $ field = $ sort ; $ string .= "&sort=" . $ field ; if ( isset ( $ info ) ) { if ( is_string ( $ info ) && $ info == "desc" ) $ string .= ":reverse" ; elseif ( is_array ( $ info ) && array_key_exists ( "reverse" , $ info ) && $ info [ 'reverse' ] ) $ string .= ":reverse" ; } } } return $ string ; }
3464	public function get ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: get ( $ route ) ) ; }
12456	public function installAssets ( $ targetFolder = "web" , $ force = false ) { $ sourceDir = $ this -> pluginDir . '/Resources/public' ; $ targetDir = $ this -> rootDir . '/' . $ targetFolder . '/plugins/' . strtolower ( $ this -> name ) ; if ( is_dir ( $ targetDir ) && ! $ force ) { return ; } $ this -> filesystem -> symlink ( $ sourceDir , $ targetDir , true ) ; }
4955	public function listenToRenderer ( ) { if ( $ this -> ListenersUnaware ) { $ this -> ListenersUnaware = false ; $ view = $ this -> serviceManager -> get ( 'View' ) ; $ viewEvents = $ view -> getEventManager ( ) ; $ viewEvents -> attach ( ViewEvent :: EVENT_RESPONSE , array ( $ this , 'anounceAttachedFiles' ) , 1000 ) ; } }
5063	public function outputJson ( int $ depth = 512 , int $ options = 0 ) { $ json = json_decode ( $ this -> output ( ) , false , $ depth , $ options ) ; if ( is_null ( $ json ) ) { $ errorMessage = json_last_error_msg ( ) ; throw new JsonDecodeException ( $ errorMessage ) ; } return $ json ; }
4471	public function requeue ( ? string $ queue = null , array $ opts = [ ] ) : string { $ opts = array_merge ( [ 'delay' => 0 , 'data' => $ this -> data , 'priority' => $ this -> priority , 'retries' => $ this -> retries , 'tags' => $ this -> tags , 'depends' => $ this -> dependencies , ] , $ opts ) ; $ queueName = $ queue ? : $ this -> queue ; $ data = json_encode ( $ opts [ 'data' ] , JSON_UNESCAPED_SLASHES ) ? : '{}' ; return $ this -> client -> requeue ( $ this -> worker , $ queueName , $ this -> jid , $ this -> klass , $ data , $ opts [ 'delay' ] , 'priority' , $ opts [ 'priority' ] , 'tags' , json_encode ( $ opts [ 'tags' ] , JSON_UNESCAPED_SLASHES ) , 'retries' , $ opts [ 'retries' ] , 'depends' , json_encode ( $ opts [ 'depends' ] , JSON_UNESCAPED_SLASHES ) ) ; }
10982	public static function getMemInfo ( ) { $ result = [ ] ; if ( $ n = preg_match_all ( '/^([\S]+):\s+(\d+)\skB$/im' , file_get_contents ( '/proc/meminfo' ) , $ matches ) ) { for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ result [ $ matches [ 1 ] [ $ i ] ] = $ matches [ 2 ] [ $ i ] ; } } return $ result ; }
12169	private function createPropertyValuesTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?property_values`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?property_values` ( `value_id` mediumint(11) NOT NULL AUTO_INCREMENT, `value_data` text NOT NULL, `value_updated_on` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `property_id` int(11) NOT NULL, `object_id` int(11) NOT NULL, PRIMARY KEY (`value_id`), UNIQUE KEY `object_property_uid` (`object_id`,`property_id`), KEY `property_id_idxfk` (`property_id`), KEY `object_id_idxfk` (`object_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;" ) ; $ this -> database -> query ( "DROP PROCEDURE IF EXISTS `property_value_validate`;" ) ; $ this -> database -> query ( "CREATE PROCEDURE `?property_value_validate`(IN _property_id INT, IN _value_data LONGTEXT) BEGIN DECLARE _validationFails CONDITION FOR SQLSTATE '99001'; DECLARE _dataTypeRegExp VARCHAR(255); DECLARE _signalText TEXT; SELECT r.datatype_validation FROM `?properties` AS d INNER JOIN `?property_datatypes` AS r WHERE `property_id`= _property_id AND d.property_datatype=r.datatype_name INTO _dataTypeRegExp; IF (_dataTypeRegExp IS NOT NULL) THEN IF (_value_data NOT REGEXP(_dataTypeRegExp)) THEN SET _signalText = CONCAT('The inserted/updated value fails the property data type validation'); SIGNAL _validationFails SET MESSAGE_TEXT=_signalText; END IF; END IF; END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?property_value_validate_insert`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?property_value_validate_insert` BEFORE INSERT ON `?property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?property_value_validate_update`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?property_value_validate_update` BEFORE UPDATE ON `?property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; }
4604	protected function parse ( $ path ) : array { $ fixtures = array_key_exists ( 'FIXTURES' , $ _ENV ) ? $ _ENV [ 'FIXTURES' ] : 'dev' ; $ files = glob ( str_replace ( '{fixtures}' , $ fixtures , $ path ) ) ; if ( ! $ files ) { throw new LogicException ( 'Fixtures path "' . $ path . '" yields no files.' ) ; } $ objects = [ ] ; foreach ( $ files as $ file ) { foreach ( Objects :: parseFile ( $ file ) as $ object ) { $ objects [ ] = $ object ; } } return $ objects ; }
5934	public function setLastLogin ( $ lastLogin ) { if ( $ lastLogin instanceof DateTime ) { $ this -> lastLogin = $ lastLogin ; } else { try { $ this -> lastLogin = new DateTime ( $ lastLogin ) ; } catch ( \ Exception $ e ) { $ this -> lastLogin = null ; } } return $ this ; }
2485	public function bulkIndexDocuments ( array $ documents ) { $ documentMap = array ( ) ; $ mainTranslationsEndpoint = $ this -> endpointResolver -> getMainLanguagesEndpoint ( ) ; $ mainTranslationsDocuments = array ( ) ; foreach ( $ documents as $ translationDocuments ) { foreach ( $ translationDocuments as $ document ) { $ documentMap [ $ document -> languageCode ] [ ] = $ document ; if ( $ mainTranslationsEndpoint !== null && $ document -> isMainTranslation ) { $ mainTranslationsDocuments [ ] = $ this -> getMainTranslationDocument ( $ document ) ; } } } foreach ( $ documentMap as $ languageCode => $ translationDocuments ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getIndexingTarget ( $ languageCode ) ) , $ translationDocuments ) ; } if ( ! empty ( $ mainTranslationsDocuments ) ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ mainTranslationsEndpoint ) , $ mainTranslationsDocuments ) ; } }
10458	public function validate ( string $ answer ) : string { if ( trim ( ( string ) $ answer ) === '' ) { throw new \ RuntimeException ( sprintf ( '%s Given value: "%s"' , $ this -> getErrorMessage ( ) , $ answer ) ) ; } return $ answer ; }
10797	public function getCryptedPassword ( $ password ) { $ bcrypt = new Bcrypt ; $ bcrypt -> setCost ( $ this -> getOptions ( ) -> getPasswordCost ( ) ) ; return $ bcrypt -> create ( $ password ) ; }
4307	public function timeEnd ( $ label = null , $ returnOrTemplate = false , $ precision = 4 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'label' => null , 'returnOrTemplate' => false , 'precision' => 4 , ) ) ; \ extract ( $ args ) ; if ( \ is_bool ( $ label ) || \ strpos ( $ label , '%time' ) !== false ) { if ( \ is_numeric ( $ returnOrTemplate ) ) { $ precision = $ returnOrTemplate ; } $ returnOrTemplate = $ label ; $ label = null ; } $ ret = $ this -> timeGet ( $ label , true , null ) ; if ( isset ( $ label ) ) { if ( isset ( $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] ) ) { $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] = array ( $ ret , null , ) ; } } else { $ label = 'time' ; \ array_pop ( $ this -> data [ 'timers' ] [ 'stack' ] ) ; } if ( \ is_int ( $ precision ) ) { $ ret = \ number_format ( $ ret , $ precision , '.' , '' ) ; } $ this -> doTime ( $ ret , $ returnOrTemplate , $ label , $ meta ) ; return $ ret ; }
10045	private function createFromType ( Model $ model , Column $ column , $ item ) { $ result = null ; switch ( $ column -> getType ( ) ) { case Type :: TEXT : case Type :: TARRAY : case Type :: SIMPLE_ARRAY : case Type :: JSON_ARRAY : case Type :: OBJECT : case Type :: BLOB : $ result = new TextAreaFormItem ( ) ; break ; case Type :: INTEGER : case Type :: SMALLINT : case Type :: BIGINT : $ result = new IntegerFormItem ( ) ; break ; case Type :: DECIMAL : case Type :: FLOAT : $ result = new NumberFormItem ( ) ; break ; case Type :: BOOLEAN : $ result = new CheckboxFormItem ( ) ; break ; case Type :: DATE : $ result = new DateFormItem ( ) ; break ; case Type :: DATETIME : case Type :: DATETIMETZ : $ result = new DateTimeFormItem ( ) ; break ; case Type :: TIME : $ result = new TimeFormItem ( ) ; break ; case Type :: STRING : case Type :: GUID : default : $ result = new TextFormItem ( ) ; break ; } $ columnName = $ column -> getName ( ) ; $ result -> setName ( $ columnName ) ; $ result -> setLabel ( Lang :: trans ( $ this -> aujaConfigurator -> getColumnDisplayName ( $ model , $ columnName ) ) ) ; if ( $ item != null && isset ( $ item -> $ columnName ) ) { $ result -> setValue ( $ item -> $ columnName ) ; } return $ result ; }
5595	protected function createRoute ( $ url ) { if ( $ this -> proxy ) { return new SimpleProxyRoute ( $ url , $ this -> proxy , $ this -> proxy_username , $ this -> proxy_password ) ; } return new SimpleRoute ( $ url ) ; }
688	protected function removeAllItems ( $ type ) { if ( ! $ this -> supportsCascadeUpdate ( ) ) { $ names = ( new Query ( ) ) -> select ( [ 'name' ] ) -> from ( $ this -> itemTable ) -> where ( [ 'type' => $ type ] ) -> column ( $ this -> db ) ; if ( empty ( $ names ) ) { return ; } $ key = $ type == Item :: TYPE_PERMISSION ? 'child' : 'parent' ; $ this -> db -> createCommand ( ) -> delete ( $ this -> itemChildTable , [ $ key => $ names ] ) -> execute ( ) ; $ this -> db -> createCommand ( ) -> delete ( $ this -> assignmentTable , [ 'item_name' => $ names ] ) -> execute ( ) ; } $ this -> db -> createCommand ( ) -> delete ( $ this -> itemTable , [ 'type' => $ type ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; }
12138	public function destroy ( QuestionRequest $ request , Question $ question ) { try { $ question -> delete ( ) ; return $ this -> response -> message ( trans ( 'messages.success.deleted' , [ 'Module' => trans ( 'forum::question.name' ) ] ) ) -> code ( 202 ) -> status ( 'success' ) -> url ( guard_url ( 'forum/question' ) ) -> redirect ( ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/question/' . $ question -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
8336	public function setValueMutator ( callable $ callback ) : self { $ this -> valueMutator = $ callback ; $ this -> value = ( $ this -> valueMutator ) ( $ this -> value ) ; return $ this ; }
477	public function renameTable ( $ table , $ newName ) { $ time = $ this -> beginCommand ( "rename table $table to $newName" ) ; $ this -> db -> createCommand ( ) -> renameTable ( $ table , $ newName ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
9675	public function allFills ( Spreadsheet $ spreadsheet ) { $ aFills = [ ] ; $ fill0 = new Fill ( ) ; $ fill0 -> setFillType ( Fill :: FILL_NONE ) ; $ aFills [ ] = $ fill0 ; $ fill1 = new Fill ( ) ; $ fill1 -> setFillType ( Fill :: FILL_PATTERN_GRAY125 ) ; $ aFills [ ] = $ fill1 ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFills [ $ style -> getFill ( ) -> getHashCode ( ) ] ) ) { $ aFills [ $ style -> getFill ( ) -> getHashCode ( ) ] = $ style -> getFill ( ) ; } } return $ aFills ; }
4767	public static function convertXmlToPhpObj ( $ node ) { $ ret = array ( ) ; if ( is_object ( $ node ) && $ node -> hasChildNodes ( ) ) { foreach ( $ node -> childNodes as $ child ) { $ name = self :: decode ( $ child -> nodeName ) ; if ( $ child -> nodeType == XML_TEXT_NODE ) { $ ret = self :: decode ( $ child -> nodeValue ) ; } else { if ( 'array' === $ name ) { return self :: parseArray ( $ child ) ; } else { $ ret [ $ name ] = self :: convertXmlToPhpObj ( $ child ) ; } } } } return ! empty ( $ ret ) ? $ ret : null ; }
4630	protected function prepareRequestHeaders ( ) { $ curl_headers = [ ] ; foreach ( $ this -> headers as $ key => $ value ) { $ curl_headers [ ] = sprintf ( '%s: %s' , $ key , $ value ) ; } $ object = $ this -> command -> getObject ( ) ; if ( $ object ) { if ( $ object -> getVclock ( ) ) { $ curl_headers [ ] = sprintf ( '%s: %s' , static :: VCLOCK_KEY , $ object -> getVclock ( ) ) ; } if ( $ object -> getContentType ( ) ) { $ charset = '' ; if ( $ object -> getCharset ( ) ) { $ charset = sprintf ( '; charset=%s' , $ object -> getCharset ( ) ) ; } $ curl_headers [ ] = sprintf ( '%s: %s' , static :: CONTENT_TYPE_KEY , $ object -> getContentType ( ) , $ charset ) ; } $ translator = new Api \ Http \ Translator \ SecondaryIndex ( ) ; $ indexHeaders = $ translator -> createHeadersFromIndexes ( $ object -> getIndexes ( ) ) ; foreach ( $ indexHeaders as $ value ) { $ curl_headers [ ] = sprintf ( '%s: %s' , $ value [ 0 ] , $ value [ 1 ] ) ; } foreach ( $ object -> getMetaData ( ) as $ key => $ value ) { $ curl_headers [ ] = sprintf ( '%s%s: %s' , static :: METADATA_PREFIX , $ key , $ value ) ; } } $ this -> options [ CURLOPT_HTTPHEADER ] = $ curl_headers ; $ this -> headers = [ ] ; return $ this ; }
9567	public function config ( $ configurator ) { if ( $ this -> booted ) { $ this -> invokeConfigurator ( $ configurator ) ; } else { $ this -> configurators -> push ( $ configurator ) ; } }
4435	public static function fromErrorMessage ( string $ error ) : QlessException { $ area = null ; $ message = $ error ; if ( preg_match ( self :: ERROR_MESSAGE_RE , $ error , $ matches ) > 0 ) { $ area = $ matches [ 'area' ] ; $ message = $ matches [ 'message' ] ; } switch ( true ) { case ( $ area === 'Requeue' && stripos ( $ message , 'does not exist' ) !== false ) : case ( stripos ( $ message , 'Job does not exist' ) !== false ) : return new InvalidJobException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job given out to another worker' ) !== false ) : return new JobLostException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job not currently running' ) !== false ) : default : return new QlessException ( $ message , $ area ) ; } }
11932	protected function generateOption ( $ key , $ value ) { $ option = new FieldOption ( ) ; $ option -> setKey ( $ key ) ; $ option -> setValue ( $ value ) ; return $ option ; }
1925	public function convertToPaletteImage ( ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return $ this ; } $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; $ transparentColor = null ; if ( $ this -> countColors ( 256 ) <= 256 ) { $ paletteImage = imagecreate ( $ width , $ height ) ; $ colors = array ( ) ; $ isTransparent = false ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ color = imagecolorat ( $ this -> gdResource , $ x , $ y ) ; if ( ( ( $ color >> 24 ) & 0x7F ) === 127 ) { $ isTransparent = true ; } else { $ colors [ $ color & 0xFFFFFF ] = true ; } } } $ colors = array_keys ( $ colors ) ; foreach ( $ colors as $ index => $ color ) { imagecolorset ( $ paletteImage , $ index , ( $ color >> 16 ) & 0xFF , ( $ color >> 8 ) & 0xFF , $ color & 0xFF ) ; } if ( $ isTransparent ) { $ transparentColor = imagecolorallocate ( $ paletteImage , 0 , 0 , 0 ) ; imagecolortransparent ( $ paletteImage , $ transparentColor ) ; } imagecopy ( $ paletteImage , $ this -> gdResource , 0 , 0 , 0 , 0 , $ width , $ height ) ; } else { $ paletteImage = imagecreatetruecolor ( $ width , $ height ) ; imagealphablending ( $ paletteImage , false ) ; imagesavealpha ( $ paletteImage , true ) ; imagecopy ( $ paletteImage , $ this -> gdResource , 0 , 0 , 0 , 0 , $ width , $ height ) ; imagetruecolortopalette ( $ paletteImage , false , 255 ) ; $ transparentColor = imagecolorallocate ( $ paletteImage , 0 , 0 , 0 ) ; imagecolortransparent ( $ paletteImage , $ transparentColor ) ; } if ( $ transparentColor !== null ) { for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { if ( ( ( imagecolorat ( $ this -> gdResource , $ x , $ y ) >> 24 ) & 0x7F ) === 127 ) { imagefilledrectangle ( $ paletteImage , $ x , $ y , $ x , $ y , $ transparentColor ) ; } } } } imagedestroy ( $ this -> gdResource ) ; $ this -> gdResource = $ paletteImage ; return $ this ; }
4690	public function addGroupBy ( $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group [ ] = $ expression ; $ this -> pushArgs ( 'group' , $ args ) ; return $ this ; }
3551	public function parse ( InlineParserContext $ inlineContext ) { $ cursor = $ inlineContext -> getCursor ( ) ; $ previous = $ cursor -> peek ( - 1 ) ; if ( $ previous !== null && $ previous !== ' ' ) { return false ; } $ saved = $ cursor -> saveState ( ) ; $ cursor -> advance ( ) ; $ handle = $ cursor -> match ( '/^[a-z0-9\+\-_]+:/' ) ; if ( ! $ handle ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ next = $ cursor -> peek ( 0 ) ; if ( $ next !== null && $ next !== ' ' ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ key = substr ( $ handle , 0 , - 1 ) ; if ( $ this -> map === null ) { $ this -> map = $ this -> repo -> get ( ) ; } if ( ! array_key_exists ( $ key , $ this -> map ) ) { $ cursor -> restoreState ( $ saved ) ; return false ; } $ inline = new Image ( $ this -> map [ $ key ] , $ key ) ; $ inline -> data [ 'attributes' ] = [ 'class' => 'emoji' , 'data-emoji' => $ key ] ; $ inlineContext -> getContainer ( ) -> appendChild ( $ inline ) ; return true ; }
6387	public function readDiscussion ( $ id ) { $ model = $ this -> readObject ( $ id , 'forum_discussions' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/forum/discuss.php?d=' . $ id ; return $ model ; }
8424	public function generate ( Request $ request ) { if ( count ( $ request -> getArgs ( ) ) != 1 ) { echo 'Wrong arguments.' . PHP_EOL . 'Usage : db/generate mapping_name' . PHP_EOL ; } else { $ mapping = $ request -> getArgs ( ) [ 0 ] ; $ schema = Schema :: getSchema ( $ mapping ) ; $ schema -> generateModels ( ) ; } }
5061	public function calculateWidth ( $ text , $ size = self :: TEXT_SIZE ) { $ size = $ this -> convertToPt ( $ size ) ; $ box = imagettfbbox ( $ size , 0 , $ this -> fontPath , $ text ) ; return round ( abs ( $ box [ 2 ] - $ box [ 0 ] ) + self :: SHIELD_PADDING_EXTERNAL + self :: SHIELD_PADDING_INTERNAL , 1 ) ; }
10212	function toCsvString ( ) { $ standard_fields = "{" ; if ( isset ( $ this -> standard_fields ) ) { foreach ( $ this -> standard_fields as $ index => $ value ) { $ standard_fields .= $ index . "=" . $ value . "," ; } $ standard_fields = rtrim ( $ standard_fields , ',' ) ; } $ standard_fields .= "}" ; $ customfields = "{" ; if ( isset ( $ this -> custom_fields ) ) { foreach ( $ this -> custom_fields as $ index => $ value ) { $ customfields .= $ index . "=" . $ value . "," ; } $ customfields = rtrim ( $ customfields , ',' ) ; } $ customfields .= "}" ; $ permission = "" ; if ( isset ( $ this -> permission ) ) { $ permission = $ this -> permission -> getCode ( ) ; } return $ this -> id . ";" . $ this -> email . ";" . $ permission . ";" . $ this -> external_id . ";" . ( ( $ this -> anonymous == true ) ? "true" : "false" ) . ";" . $ this -> created . ";" . $ this -> updated . ";\"" . $ standard_fields . "\"" . ";\"" . $ customfields . "\"" ; }
5151	protected function textAfterString ( $ haystack , $ needle ) { $ result = "" ; $ needleLength = strlen ( $ needle ) ; if ( $ needleLength > 0 && preg_match ( "#$needle([^\r\n]+)#i" , $ haystack , $ match ) ) { $ result = trim ( substr ( $ match [ 0 ] , - ( strlen ( $ match [ 0 ] ) - $ needleLength ) ) ) ; } return $ result ; }
7624	protected function performRequest ( $ path = '/' , $ query = array ( ) , $ httpVerb = 'GET' , $ headers = array ( ) , $ forTableStorage = false , $ rawData = null , $ resourceType = self :: RESOURCE_UNKNOWN , $ requiredPermission = self :: PERMISSION_READ ) { if ( strpos ( $ path , '/' ) !== 0 ) { $ path = '/' . $ path ; } if ( ! isset ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = '' ; } if ( ! isset ( $ headers [ 'content-length' ] ) && ( $ rawData !== null || $ httpVerb == "PUT" ) ) { $ headers [ 'Content-Length' ] = strlen ( ( string ) $ rawData ) ; } $ headers [ 'Expect' ] = '' ; $ headers [ 'x-ms-version' ] = $ this -> apiVersion ; $ path = str_replace ( ' ' , '%20' , $ path ) ; $ requestUrl = $ this -> getBaseUrl ( ) . $ path ; if ( count ( $ query ) > 0 ) { $ queryString = '' ; foreach ( $ query as $ key => $ value ) { $ queryString .= ( $ queryString ? '&' : '?' ) . rawurlencode ( $ key ) . '=' . rawurlencode ( $ value ) ; } $ requestUrl .= $ queryString ; } $ requestUrl = $ this -> credentials -> signRequestUrl ( $ requestUrl , $ resourceType , $ requiredPermission ) ; $ headers = $ this -> credentials -> signRequestHeaders ( $ httpVerb , $ path , $ query , $ headers , $ forTableStorage , $ resourceType , $ requiredPermission , $ rawData ) ; return $ this -> httpClient -> request ( $ httpVerb , $ requestUrl , $ rawData , $ headers ) ; }
3962	private function createOrGetDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasMetaModelDefinition ( ) ) { return $ container -> getMetaModelDefinition ( ) ; } $ container -> setMetaModelDefinition ( $ definition = new MetaModelDefinition ( ) ) ; return $ definition ; }
5366	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ this -> results [ ] = new SimpleResultOfFail ( parent :: getTestList ( ) , $ message ) ; }
2643	private function _purge ( $ uri , $ type , $ method = \ Zend_Http_Client :: POST , $ payload = null ) { if ( $ method == 'PURGE' ) { $ expiration = time ( ) + self :: PURGE_TOKEN_LIFETIME ; $ zendUri = \ Zend_Uri :: factory ( $ uri ) ; $ path = $ zendUri -> getPath ( ) ; $ stringToSign = $ path . $ expiration ; $ signature = hash_hmac ( 'sha1' , $ stringToSign , $ this -> config -> getServiceId ( ) ) ; $ token = $ expiration . '_' . urlencode ( $ signature ) ; $ headers = [ self :: FASTLY_HEADER_TOKEN . ': ' . $ token ] ; } else { $ headers = [ self :: FASTLY_HEADER_AUTH . ': ' . $ this -> config -> getApiKey ( ) ] ; } if ( $ this -> config -> canUseSoftPurge ( ) ) { array_push ( $ headers , self :: FASTLY_HEADER_SOFT_PURGE . ': 1' ) ; } $ result [ 'status' ] = true ; try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> setConfig ( [ 'timeout' => self :: PURGE_TIMEOUT ] ) ; if ( $ method == 'PURGE' ) { $ client -> addOption ( CURLOPT_CUSTOMREQUEST , 'PURGE' ) ; } $ client -> write ( $ method , $ uri , '1.1' , $ headers , $ payload ) ; $ responseBody = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; $ responseMessage = \ Zend_Http_Response :: extractMessage ( $ responseBody ) ; $ client -> close ( ) ; if ( $ responseCode == '429' ) { throw new LocalizedException ( __ ( $ responseMessage ) ) ; } elseif ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( $ responseCode . ': ' . $ responseMessage ) ) ; } } catch ( \ Exception $ e ) { $ this -> logger -> critical ( $ e -> getMessage ( ) , $ uri ) ; $ result [ 'status' ] = false ; $ result [ 'msg' ] = $ e -> getMessage ( ) ; } if ( empty ( $ type ) ) { return $ result ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishPurgeChanges ( ) ) { $ this -> sendWebHook ( '*initiated ' . $ type . '*' ) ; if ( $ this -> config -> canPublishPurgeDebugBacktrace ( ) == false ) { return $ result ; } $ this -> stackTrace ( $ type ) ; } return $ result ; }
11484	protected function getFunctionArguments ( ReflectionFunctionAbstract $ func , array $ params = array ( ) ) { $ args = [ ] ; foreach ( $ func -> getParameters ( ) as $ param ) { $ class = $ param -> getClass ( ) ; if ( $ class ) { $ args [ ] = $ this -> resolveClassArg ( $ class , $ param , $ params ) ; } else { $ args [ ] = $ this -> resolveNonClassArg ( $ param , $ params , $ func ) ; } } return $ args ; }
1926	public function countColors ( $ max = null ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return imagecolorstotal ( $ this -> gdResource ) ; } $ colors = array ( ) ; $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ colors [ imagecolorat ( $ this -> gdResource , $ x , $ y ) ] = true ; if ( $ max !== null && \ count ( $ colors ) > $ max ) { break 2 ; } } } return \ count ( $ colors ) ; }
7862	protected function setPipesOfWorkflow ( $ workflow ) { $ pipes = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ this -> pipes = array_map ( function ( $ pipe ) { $ chunks = explode ( '\\' , $ pipe ) ; return end ( $ chunks ) ; } , $ pipes ) ; $ this -> geometry -> setPipes ( $ this -> pipes ) ; }
7806	protected function getNearestDateTimeFromDayAndMonth ( \ DateTime $ target , $ day , $ month ) { $ initialGuess = new \ DateTime ( ) ; $ initialGuess -> setDate ( $ target -> format ( 'Y' ) , $ month , $ day ) ; $ initialGuess -> setTime ( 0 , 0 , 0 ) ; $ initialGuessDiff = $ target -> diff ( $ initialGuess ) ; $ yearEarlier = clone $ initialGuess ; $ yearEarlier -> modify ( '-1 year' ) ; $ yearEarlierDiff = $ target -> diff ( $ yearEarlier ) ; if ( $ yearEarlierDiff -> days < $ initialGuessDiff -> days ) { return $ yearEarlier ; } $ yearLater = clone $ initialGuess ; $ yearLater -> modify ( '+1 year' ) ; $ yearLaterDiff = $ target -> diff ( $ yearLater ) ; if ( $ yearLaterDiff -> days < $ initialGuessDiff -> days ) { return $ yearLater ; } return $ initialGuess ; }
4180	protected function notifyUser ( ) { $ this -> console -> line ( '' ) ; $ this -> console -> line ( "{$this->isDone($this->getProviders()->isRegistered())} " . "{$this->getProviders()->count()} service provider registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getFacades()->isRegistered())} " . "{$this->getFacades()->count()} facade registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getMigration()->isRegistered())} " . "{$this->getMigration()->count()} migration file ran." ) ; $ this -> console -> line ( "{$this->isDone($this->getResources()->isRegistered())} " . '- ' . $ this -> console -> tokenizePackageInfo ( ) [ 'name' ] . ' file publish.' ) ; return true ; }
8632	public function setReportRequestInfoList ( $ reportRequestInfo ) { if ( ! $ this -> _isNumericArray ( $ reportRequestInfo ) ) { $ reportRequestInfo = array ( $ reportRequestInfo ) ; } $ this -> fields [ 'ReportRequestInfo' ] [ 'FieldValue' ] = $ reportRequestInfo ; return $ this ; }
8046	public function hasData ( $ sec = 0 , $ usec = 0 ) { $ sec = ( int ) $ sec ; $ usec = ( int ) $ usec ; if ( $ sec < 0 ) { $ sec = 0 ; } if ( $ usec < 0 ) { $ usec = 0 ; } $ read = array ( $ this -> socket ) ; $ write = array ( ) ; $ except = array ( ) ; $ sockets = socket_select ( $ read , $ write , $ except , $ sec , $ usec ) ; if ( $ sockets === FALSE ) { return FALSE ; } return $ sockets > 0 ; }
8669	protected function computeFileSystemDifferences ( ) { $ entityPathByFilesystems = [ ] ; foreach ( $ this -> resourceManager -> getResourceConfigurations ( ) as $ resourceConfiguration ) { $ className = $ resourceConfiguration -> getEntity ( ) ; $ entityManager = $ this -> doctrine -> getManagerForClass ( $ className ) ; if ( ! $ entityManager instanceof EntityManagerInterface ) { throw new \ UnexpectedValueException ( "No manager found for class {$className}" ) ; } $ repository = $ entityManager -> getRepository ( $ className ) ; if ( ! $ repository instanceof ResourceRepositoryInterface ) { throw new \ UnexpectedValueException ( "Repository for class {$className} must implement ResourceRepositoryInterface" ) ; } $ paths = $ repository -> getPaths ( ) ; $ adapterReference = $ this -> adaptersByResourceType [ $ resourceConfiguration -> getCode ( ) ] ; if ( array_key_exists ( $ adapterReference , $ entityPathByFilesystems ) ) { $ entityPathByFilesystems [ $ adapterReference ] = array_merge ( $ entityPathByFilesystems [ $ adapterReference ] , $ paths ) ; } else { $ entityPathByFilesystems [ $ adapterReference ] = $ paths ; } } foreach ( $ this -> adapters as $ adapterReference => $ adapter ) { $ existingPaths = [ ] ; foreach ( $ adapter -> listContents ( ) as $ metadata ) { $ entityPath = $ metadata [ 'path' ] ; if ( '.gitkeep' === $ entityPath ) { continue ; } $ existingPaths [ $ entityPath ] = $ entityPath ; } $ entityPaths = $ entityPathByFilesystems [ $ adapterReference ] ; $ this -> extraFiles [ $ adapterReference ] = array_diff_key ( $ existingPaths , $ entityPaths ) ; $ this -> missingFiles [ $ adapterReference ] = array_diff_key ( $ entityPaths , $ existingPaths ) ; } }
11152	public function setParameters ( array $ request ) { foreach ( $ this -> getRequiredParameters ( ) as $ param ) { if ( isset ( $ request [ $ param ] ) ) { $ dynamicMethod = "set" . ucfirst ( $ param ) ; if ( method_exists ( $ this , $ dynamicMethod ) ) { $ this -> $ dynamicMethod ( $ request [ $ param ] ) ; } else { throw new ExtDirectException ( "Method for required parameter '{$param}' not implemented" ) ; } } else { throw new ExtDirectException ( "Required parameter '{$param}' is missing" ) ; } } }
9758	function closeTo ( $ value , float $ delta ) : self { return $ this -> expect ( $ this -> target , equalTo ( $ value , $ delta ) ) ; }
5636	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; print $ this -> getFailCount ( ) . ") $message\n" ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print "\tin " . implode ( "\n\tin " , array_reverse ( $ breadcrumb ) ) ; print "\n" ; }
11893	private function createEditForm ( CustomField $ entity , $ type ) { $ form = $ this -> createForm ( 'custom_field_choice' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfield_update' , array ( 'id' => $ entity -> getId ( ) ) ) , 'method' => 'PUT' , 'type' => $ type , 'group_widget' => 'hidden' ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Update' ) ) ; return $ form ; }
4904	protected function createValueOptions ( NodeInterface $ node , $ allowSelectNodes = false , $ isRoot = true ) { $ key = $ isRoot ? $ node -> getValue ( ) : $ node -> getValueWithParents ( ) ; $ name = $ node -> getName ( ) ; if ( $ node -> hasChildren ( ) ) { $ leafOptions = [ ] ; if ( $ allowSelectNodes && ! $ isRoot ) { $ leafOptions [ $ key ] = $ name ; $ key = "$key-group" ; } foreach ( $ node -> getChildren ( ) as $ child ) { $ leafOptions += $ this -> createValueOptions ( $ child , $ allowSelectNodes , false ) ; } $ value = [ 'label' => $ name , 'options' => $ leafOptions ] ; } else { $ value = $ name ; } return [ $ key => $ value ] ; }
4717	public function emit ( $ event , $ parameters ) { if ( ! isset ( $ this -> callbacks [ $ event ] ) ) { return ; } if ( ! $ this -> callbacks [ $ event ] [ 0 ] ) { usort ( $ this -> callbacks [ $ event ] [ 1 ] , function ( $ A , $ B ) { if ( $ A [ 0 ] == $ B [ 0 ] ) { return 0 ; } return ( $ A [ 0 ] > $ B [ 0 ] ) ? 1 : - 1 ; } ) ; $ this -> callbacks [ $ event ] [ 0 ] = true ; } foreach ( $ this -> callbacks [ $ event ] [ 1 ] as $ item ) { call_user_func_array ( $ item [ 1 ] , $ this -> buildParameters ( $ parameters ) ) ; } }
10583	public static function dumpResponse ( ResponseInterface $ response ) { $ statusLine = sprintf ( "HTTP/%s %d %s" , $ response -> getProtocolVersion ( ) , $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) ; header ( $ statusLine , true , $ response -> getStatusCode ( ) ) ; foreach ( $ response -> getHeaders ( ) as $ name => $ values ) { foreach ( $ values as $ value ) { header ( sprintf ( '%s: %s' , $ name , $ value ) , false ) ; } } $ body = $ response -> getBody ( ) ; while ( ! $ body -> eof ( ) ) { echo $ body -> read ( 1024 ) ; } }
2014	public static function addClasses ( $ classes ) { @ trigger_error ( 'Using ClassLoader::addClasses() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; foreach ( $ classes as $ class => $ file ) { self :: addClass ( $ class , $ file ) ; } }
6931	private function feedShipmentInvoice ( Invoice \ InvoiceInterface $ invoice ) { $ changed = false ; $ shipment = $ invoice -> getShipment ( ) ; $ calculator = $ this -> invoiceBuilder -> getInvoiceCalculator ( ) ; foreach ( $ shipment -> getItems ( ) as $ shipmentItem ) { $ saleItem = $ shipmentItem -> getSaleItem ( ) ; $ max = $ shipment -> isReturn ( ) ? $ calculator -> calculateCreditableQuantity ( $ saleItem ) : $ calculator -> calculateInvoiceableQuantity ( $ saleItem ) ; if ( 0 < $ quantity = min ( $ max , $ shipmentItem -> getQuantity ( ) ) ) { $ line = $ this -> invoiceBuilder -> findOrCreateGoodLine ( $ invoice , $ saleItem , $ max ) ; if ( $ line -> getQuantity ( ) !== $ quantity ) { $ line -> setQuantity ( $ quantity ) ; $ changed = true ; } } } if ( $ invoice -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_GOOD ) ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getAdjustments ( Common \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ saleAdjustment ) { foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_DISCOUNT ) as $ line ) { if ( $ saleAdjustment === $ line -> getSaleAdjustment ( ) ) { continue 2 ; } } $ this -> invoiceBuilder -> buildDiscountLine ( $ saleAdjustment , $ invoice ) ; $ changed = true ; } if ( null !== $ sale -> getShipmentMethod ( ) && ! $ this -> isShipmentAmountInvoiced ( $ invoice ) ) { $ this -> invoiceBuilder -> buildShipmentLine ( $ invoice ) ; } } return $ changed ; }
5668	public function describeDifference ( $ first , $ second , $ identical = false ) { if ( $ identical ) { if ( ! $ this -> isTypeMatch ( $ first , $ second ) ) { return sprintf ( 'with type mismatch as [%s] does not match [%s]' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) ) ; } } $ type = $ this -> getType ( $ first ) ; if ( $ type === 'Unknown' ) { return 'with unknown type' ; } $ method = 'describe' . $ type . 'Difference' ; return $ this -> $ method ( $ first , $ second , $ identical ) ; }
12458	private function createCommentForm ( CommentFront $ model , $ entity ) { $ form = $ this -> createForm ( 'BlogBundle\Form\CommentFrontType' , $ model , array ( 'action' => $ this -> generateUrl ( 'blog_blog_comment' , array ( 'post' => $ entity -> getId ( ) ) ) , 'method' => 'POST' , 'attr' => array ( 'id' => 'comment-form' , 'class' => 'comment-form' ) ) ) ; return $ form ; }
5967	public function tempPasswordList ( $ resolve = false ) { $ passwords = $ this -> request ( "servertemppasswordlist" ) -> toAssocArray ( "pw_clear" ) ; if ( $ resolve ) { foreach ( $ passwords as $ password => $ array ) { try { $ channel = $ this -> channelGetById ( $ array [ "tcid" ] ) ; $ passwords [ $ password ] [ "tcname" ] = $ channel -> toString ( ) ; $ passwords [ $ password ] [ "tcpath" ] = $ channel -> getPathway ( ) ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0xA00 ) { throw $ e ; } } } } return $ passwords ; }
12447	static function run_build_dependencies ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; $ current = $ opts [ 'extension' ] [ 'name' ] ; foreach ( $ opts [ 'dependencies' ] [ 'extensions' ] as $ ext => $ source ) { if ( $ ext != $ current ) { foreach ( $ source as $ type => $ def ) { break ; } $ tempconf = array ( 'extension' => array ( 'name' => $ ext ) , 'version' => array ( 'major' => 0 , 'minor' => 0 , 'release' => 0 ) , $ type => $ def ) ; $ tempconffile = self :: getOptionsDir ( ) . "/options-tmp_$ext.yaml" ; pakeYaml :: emitfile ( $ tempconf , $ tempconffile ) ; $ task = pakeTask :: get ( 'init' ) ; $ task -> execute ( array ( "tmp_$ext" ) , array_merge ( $ cliopts , array ( 'skip-init' => false , 'skip-init-fetch' => false , 'skip-init-clean' => true ) ) ) ; if ( is_file ( self :: getBuildDir ( $ opts ) . "/$ext/pake/options-$ext.yaml" ) ) { pake_copy ( self :: getBuildDir ( $ opts ) . "/$ext/pake/options-$ext.yaml" , self :: getOptionsDir ( ) . "/options-$ext.yaml" ) ; } else { throw new pakeException ( "Missing pake/options.yaml extension in dependent extension $ext" ) ; } $ task -> execute ( array ( "tmp_$ext" ) , array_merge ( $ cliopts , array ( 'skip-init' => false , 'skip-init-fetch' => true , 'skip-init-clean' => false ) ) ) ; pake_remove ( $ tempconffile , '' ) ; $ task = pakeTask :: get ( 'build' ) ; foreach ( $ task -> get_prerequisites ( ) as $ pretask ) { $ pretask = pakeTask :: get ( $ pretask ) ; $ pretask -> execute ( array ( $ ext ) , array_merge ( $ opts , array ( 'skip-init' => true ) ) ) ; } $ task -> execute ( array ( $ ext ) , array_merge ( $ opts , array ( 'skip-init' => true ) ) ) ; } } }
6308	public function setA ( StringType $ name , Attribute $ attribute ) { if ( $ this -> hasA ( $ name ) ) { $ this -> attributes = $ this -> attributes -> kDiff ( new AttributeMap ( [ $ name ( ) => $ attribute ] ) ) ; } $ this -> attributes = $ this -> attributes -> append ( [ $ name ( ) => $ attribute ] ) ; return $ this ; }
488	public static function getInstances ( $ model , $ attribute ) { $ name = Html :: getInputName ( $ model , $ attribute ) ; return static :: getInstancesByName ( $ name ) ; }
734	public function init ( ) { parent :: init ( ) ; $ this -> itemFile = Yii :: getAlias ( $ this -> itemFile ) ; $ this -> assignmentFile = Yii :: getAlias ( $ this -> assignmentFile ) ; $ this -> ruleFile = Yii :: getAlias ( $ this -> ruleFile ) ; $ this -> load ( ) ; }
10627	public static function cpuCoreInfo ( ) { $ cores = array ( ) ; if ( false !== ( $ data = @ file ( '/proc/stat' ) ) ) { foreach ( $ data as $ line ) { if ( preg_match ( '/^cpu[0-9]/' , $ line ) ) { $ info = explode ( ' ' , $ line ) ; $ cores [ ] = array ( 'user' => $ info [ 1 ] , 'nice' => $ info [ 2 ] , 'sys' => $ info [ 3 ] , 'idle' => $ info [ 4 ] , 'iowait' => $ info [ 5 ] , 'irq' => $ info [ 6 ] , 'softirq' => $ info [ 7 ] ) ; } } } return $ cores ; }
3241	protected function createSeeder ( $ data ) { $ seederFile = base_path ( '/database/seeds' ) . '/LaravelShopSeeder.php' ; $ output = $ this -> laravel -> view -> make ( 'laravel-shop::generators.seeder' ) -> with ( $ data ) -> render ( ) ; if ( ! file_exists ( $ seederFile ) && $ fs = fopen ( $ seederFile , 'x' ) ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; return true ; } return false ; }
7107	static public function round ( $ amount , $ currency ) { $ precision = static :: getPrecision ( $ currency ) ; $ roundingIncrement = static :: getRoundingIncrement ( $ currency ) ; $ amount = round ( $ amount , $ precision , \ PHP_ROUND_HALF_EVEN ) ; if ( 0 < $ roundingIncrement && 0 < $ precision ) { $ roundingFactor = $ roundingIncrement / pow ( 10 , $ precision ) ; $ amount = round ( $ amount / $ roundingFactor ) * $ roundingFactor ; } return $ amount ; }
7550	function wrapInner ( $ node , $ start = 0 , $ end = - 1 , $ wrap_index = - 1 , $ node_index = null ) { if ( $ end < 0 ) { $ end += count ( $ this -> children ) ; } if ( $ node_index === null ) { $ node_index = $ end + 1 ; } if ( ! is_object ( $ node ) ) { $ node = $ this -> addChild ( $ node , $ node_index ) ; } elseif ( $ node -> parent !== $ this ) { $ node -> changeParent ( $ this -> parent , $ node_index ) ; } $ this -> moveChildren ( $ node , $ wrap_index , $ start , $ end ) ; return $ node ; }
8861	public function canView ( $ member = null ) { if ( ! parent :: canView ( $ member ) ) return false ; if ( $ this -> PublishDate ) { $ publishDate = $ this -> dbObject ( "PublishDate" ) ; if ( $ publishDate -> InFuture ( ) && ! Permission :: checkMember ( $ member , "VIEW_DRAFT_CONTENT" ) ) { return false ; } } return true ; }
5164	public function send ( EmailSender $ email , array $ data = [ ] ) { $ result = ( new DataBuilderManager ( ) ) -> validateRaw ( $ email -> data_builder , $ data ) ; dispatch ( new SendEmail ( $ email , $ data , $ this -> getAgent ( ) ) ) ; return $ result ; }
2149	public function createNewUser ( $ intUser , $ arrData ) { $ arrNewsletters = StringUtil :: deserialize ( $ arrData [ 'newsletter' ] , true ) ; if ( ! \ is_array ( $ arrNewsletters ) ) { return ; } $ time = time ( ) ; foreach ( $ arrNewsletters as $ intNewsletter ) { $ intNewsletter = ( int ) $ intNewsletter ; if ( $ intNewsletter < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intNewsletter , $ arrData [ 'email' ] ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, addedOn=$time" ) -> execute ( $ intNewsletter , $ arrData [ 'email' ] ) ; } } }
12416	static function run_coding_style_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcs = self :: getTool ( 'phpcs' , $ opts , true ) ; $ rulesDir = self :: getVendorDir ( ) . '/squizlabs/php_codesniffer/Codesniffer/Standards/' . $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ; if ( ! is_dir ( $ rulesDir ) ) { if ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] == 'ezcs' ) { $ sourceDir = self :: getVendorDir ( ) . '/ezsystems/ezcs/php/ezcs' ; if ( is_dir ( $ sourceDir ) ) { pake_symlink ( $ sourceDir , $ rulesDir ) ; } } } try { $ out = pake_sh ( "$phpcs --standard=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ) . " " . "--report=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'format' ] ) . " " . "--extensions=php " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcs.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
4205	private function getParams ( \ ReflectionMethod $ reflectionMethod , $ phpDoc = array ( ) ) { $ paramArray = array ( ) ; $ params = $ reflectionMethod -> getParameters ( ) ; if ( empty ( $ phpDoc ) ) { $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; } foreach ( $ params as $ i => $ reflectionParameter ) { $ nameNoPrefix = $ reflectionParameter -> getName ( ) ; $ name = '$' . $ nameNoPrefix ; if ( \ method_exists ( $ reflectionParameter , 'isVariadic' ) && $ reflectionParameter -> isVariadic ( ) ) { $ name = '...' . $ name ; } if ( $ reflectionParameter -> isPassedByReference ( ) ) { $ name = '&' . $ name ; } $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( $ reflectionParameter -> isDefaultValueAvailable ( ) ) { $ defaultValue = $ reflectionParameter -> getDefaultValue ( ) ; if ( \ version_compare ( PHP_VERSION , '5.4.6' , '>=' ) && $ reflectionParameter -> isDefaultValueConstant ( ) ) { $ constantName = $ reflectionParameter -> getDefaultValueConstantName ( ) ; } } $ paramInfo = array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , 'desc' => null , 'isOptional' => $ reflectionParameter -> isOptional ( ) , 'name' => $ name , 'type' => $ this -> getParamTypeHint ( $ reflectionParameter ) , ) ; if ( isset ( $ phpDoc [ 'param' ] [ $ i ] ) ) { $ paramInfo [ 'desc' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'desc' ] ; if ( ! isset ( $ paramInfo [ 'type' ] ) ) { $ paramInfo [ 'type' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'type' ] ; } } $ paramArray [ $ nameNoPrefix ] = $ paramInfo ; } return $ paramArray ; }
9261	public function map ( $ route , $ name , $ handler , array $ methods = array ( 'GET' ) ) { foreach ( $ methods as $ method ) { if ( null === $ name ) { $ this -> addRoute ( $ method , $ route , $ handler ) ; } else { $ this -> addNamedRoute ( $ name , $ method , $ route , $ handler ) ; } } }
7817	public function secret ( string $ secret = '' ) : self { if ( empty ( $ secret ) ) { $ secret = str_random ( 15 ) ; } $ this -> secret = $ secret ; return $ this ; }
4973	private function prepareHydrateData ( array $ data ) { $ items = $ data [ 'items' ] ; $ tree = [ '__root__' => array_shift ( $ items ) ] ; foreach ( $ items as $ item ) { $ parent = substr ( $ item [ 'current' ] , 0 , strrpos ( $ item [ 'current' ] , '-' ) ) ; $ tree [ $ parent ] [ ] = $ item ; } $ this -> hydrateData = $ tree ; }
2388	private function implode ( array $ config ) : string { $ palette = '' ; foreach ( $ config as $ legend => $ group ) { if ( \ count ( $ group [ 'fields' ] ) < 1 ) { continue ; } if ( '' !== $ palette ) { $ palette .= ';' ; } if ( ! \ is_int ( $ legend ) ) { $ palette .= sprintf ( '{%s%s},' , $ legend , ( $ group [ 'hide' ] ? ':hide' : '' ) ) ; } $ palette .= implode ( ',' , $ group [ 'fields' ] ) ; } return $ palette ; }
11223	private static function checkRegexRoutes ( ) { $ pos = 0 ; self :: getRegexRoutes ( ) ; $ method = $ _SERVER [ 'REQUEST_METHOD' ] ; $ searches = array_keys ( self :: $ patterns ) ; $ replaces = array_values ( self :: $ patterns ) ; foreach ( self :: $ routes as $ route ) { $ segments = explode ( '/' , str_replace ( $ searches , '' , $ route ) ) ; $ route = str_replace ( $ searches , $ replaces , $ route ) ; $ route = Url :: addBackSlash ( $ route ) ; if ( preg_match ( '#^' . $ route . '$#' , self :: $ uri , $ matched ) ) { $ methodRoute = self :: $ methods [ $ pos ] ; if ( $ methodRoute == $ method || $ methodRoute == 'ANY' ) { $ matched = explode ( '/' , trim ( $ matched [ 0 ] , '/' ) ) ; $ matched = array_diff ( $ matched , $ segments ) ; if ( ! is_object ( self :: $ callbacks [ $ pos ] ) ) { self :: $ response = self :: invokeObject ( self :: $ callbacks [ $ pos ] , $ matched ) ; } else { self :: $ response = call_user_func_array ( self :: $ callbacks [ $ pos ] , $ matched ) ; } if ( ! self :: $ halts ) { return self :: $ response ; } self :: $ halts -- ; } } $ pos ++ ; } return self :: $ response ; }
2871	public function getModules ( ) { $ items = array ( ) ; $ items [ ] = array ( 'module' => 'Magento' , 'codePool' => 'core' , 'active' => true , 'version' => $ this -> getMagentoVersion ( ) ) ; $ modulesConfig = Mage :: getConfig ( ) -> getModuleConfig ( ) ; foreach ( $ modulesConfig as $ node ) { foreach ( $ node as $ module => $ data ) { $ items [ ] = array ( 'module' => $ module , 'codePool' => ( string ) $ data -> codePool , 'active' => $ data -> active == 'true' , 'version' => ( string ) $ data -> version ) ; } } return $ items ; }
8994	private function update ( ) { if ( null !== $ this -> namespace ) { $ _SESSION [ $ this -> namespace ] = $ this -> sessionData ; } else { $ _SESSION = $ this -> sessionData ; } }
3151	protected function continueInteraction ( RunnerServiceContext $ context ) { $ continue = false ; $ session = $ context -> getTestSession ( ) ; if ( $ session -> isRunning ( ) === true && $ session -> isTimeout ( ) === false ) { $ event = new QtiContinueInteractionEvent ( $ context , $ this ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; $ continue = true ; } else { $ this -> finish ( $ context ) ; } return $ continue ; }
2555	protected static function loadCorpNegoFare ( $ corporateNegoFare ) { $ opt = [ ] ; if ( $ corporateNegoFare !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_CORPORATE_NEGOTIATED_FARES ) ; $ po -> optionDetail = new OptionDetail ( $ corporateNegoFare ) ; $ opt [ ] = $ po ; } return $ opt ; }
5825	public function encodeData ( ) { switch ( $ this -> encoding ) { case Request :: ENCODING_JSON : return json_encode ( $ this -> data ) ; break ; case Request :: ENCODING_RAW : return ( string ) $ this -> data ; break ; case Request :: ENCODING_QUERY : return http_build_query ( $ this -> data ) ; break ; default : throw new \ UnexpectedValueException ( "Encoding [$encoding] not a known Request::ENCODING_* constant" ) ; } }
2274	public function getEditableMemberProperties ( ) { $ return = array ( ) ; Contao \ System :: loadLanguageFile ( 'tl_member' ) ; $ this -> loadDataContainer ( 'tl_member' ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] as $ k => $ v ) { if ( $ v [ 'eval' ] [ 'feEditable' ] ) { $ return [ $ k ] = $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ; } } return $ return ; }
2603	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ dictionaryName = Config :: CONFIG_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ currActiveVersion , $ dictionaryName ) ; if ( ! $ dictionary ) { return $ result -> setData ( [ 'status' => false ] ) ; } $ dictionaryItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; foreach ( $ dictionaryItems as $ item ) { if ( $ item -> item_key == Config :: CONFIG_DICTIONARY_KEY && $ item -> item_value == 1 ) { return $ result -> setData ( [ 'status' => true ] ) ; } } return $ result -> setData ( [ 'status' => false ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
9152	public function view ( $ vars = array ( ) ) { $ output = '' ; $ vars [ 'entity' ] = $ this -> entity ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getOutputView ( ) === false ) { continue ; } if ( $ field -> getType ( ) == 'hidden' || $ field -> getValueType ( ) == 'hidden' ) { continue ; } if ( $ field -> isHiddenOnProfile ( ) ) { continue ; } $ field_view = $ field -> viewOutput ( $ vars ) ; if ( $ field_view ) { $ output .= elgg_format_element ( 'div' , array ( 'class' => 'prototyper-output' , ) , $ field_view ) ; } } return $ output ; }
11930	public function getActiveCustomFields ( ) { if ( $ this -> activeCustomFields === null ) { $ this -> activeCustomFields = array ( ) ; foreach ( $ this -> customFields as $ cf ) { if ( $ cf -> isActive ( ) ) { array_push ( $ this -> activeCustomFields , $ cf ) ; } } } return $ this -> activeCustomFields ; }
3001	public function setHTML ( $ message ) { $ f3 = \ Base :: instance ( ) ; $ tmpl = new \ Template ( ) ; if ( $ f3 -> exists ( 'mailer.jumplinks' , $ jumplink ) && $ jumplink ) $ tmpl -> extend ( 'a' , function ( $ node ) use ( $ f3 , $ tmpl ) { if ( isset ( $ node [ '@attrib' ] ) ) { $ attr = $ node [ '@attrib' ] ; unset ( $ node [ '@attrib' ] ) ; } else $ attr = array ( ) ; if ( isset ( $ attr [ 'href' ] ) ) { if ( ! $ f3 -> exists ( 'mailer.jump_route' , $ ping_route ) ) $ ping_route = '/mailer-jump' ; $ attr [ 'href' ] = $ f3 -> get ( 'SCHEME' ) . '://' . $ f3 -> get ( 'HOST' ) . $ f3 -> get ( 'BASE' ) . $ ping_route . '?target=' . urlencode ( $ attr [ 'href' ] ) ; } $ params = '' ; foreach ( $ attr as $ key => $ value ) $ params .= ' ' . $ key . '="' . $ value . '"' ; return '<a' . $ params . '>' . $ tmpl -> build ( $ node ) . '</a>' ; } ) ; $ message = $ tmpl -> build ( $ tmpl -> parse ( $ message ) ) ; $ this -> setContent ( $ message , 'text/html' ) ; }
9433	protected static function checkOrder ( $ float_min , $ float_max ) { if ( ! is_numeric ( $ float_min ) && ! is_numeric ( $ float_max ) ) { throw new \ InvalidArgumentException ( 'Min and max values must be valid numbers.' ) ; } if ( $ float_min >= $ float_max ) { throw new \ InvalidArgumentException ( 'Max value must be greater than min value!' ) ; } }
8869	public function attach ( Runner $ runner ) { if ( $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t attach already attached runner.' ) ; } $ this -> runners -> attach ( $ runner ) ; return $ this ; }
9648	protected function getConstantValues ( string $ classIdentifier , string $ regex ) : array { $ reflectionClass = new \ ReflectionClass ( $ classIdentifier ) ; $ constants = $ reflectionClass -> getConstants ( ) ; $ validValues = array_filter ( $ constants , function ( $ constantName ) use ( $ regex ) { return preg_match ( $ regex , $ constantName ) ; } , ARRAY_FILTER_USE_KEY ) ; return $ validValues ; }
3983	private function buildBackendMenuSection ( $ groupName , Request $ request ) { $ strRefererId = $ request -> attributes -> get ( '_contao_referer_id' ) ; $ label = $ this -> translator -> trans ( 'MOD.' . $ groupName , [ ] , 'contao_modules' ) ; if ( \ is_array ( $ label ) ) { $ label = $ label [ 0 ] ; } return [ 'class' => ' node-expanded' , 'title' => StringUtil :: specialchars ( $ this -> translator -> trans ( 'MSC.collapseNode' , [ ] , 'contao_modules' ) ) , 'label' => $ label , 'href' => $ this -> urlGenerator -> generate ( 'contao_backend' , [ 'do' => $ request -> get ( 'do' ) , 'mtg' => $ groupName , 'ref' => $ strRefererId ] ) , 'ajaxUrl' => $ this -> urlGenerator -> generate ( 'contao_backend' ) , 'icon' => 'modPlus.gif' , 'modules' => [ ] , ] ; }
5447	protected function addAttributeTokens ( ) { $ this -> mapHandler ( 'dq_attribute' , 'acceptAttributeToken' ) ; $ this -> addEntryPattern ( '=\s*"' , 'tag' , 'dq_attribute' ) ; $ this -> addPattern ( '\\\\"' , 'dq_attribute' ) ; $ this -> addExitPattern ( '"' , 'dq_attribute' ) ; $ this -> mapHandler ( 'sq_attribute' , 'acceptAttributeToken' ) ; $ this -> addEntryPattern ( "=\s*'" , 'tag' , 'sq_attribute' ) ; $ this -> addPattern ( "\\\\'" , 'sq_attribute' ) ; $ this -> addExitPattern ( "'" , 'sq_attribute' ) ; $ this -> mapHandler ( 'uq_attribute' , 'acceptAttributeToken' ) ; $ this -> addSpecialPattern ( '=\s*[^>\s]*' , 'tag' , 'uq_attribute' ) ; }
12265	public function findInSourceDirs ( Finder $ finder ) { foreach ( $ this -> sourceDirs as $ dir ) { $ finder -> in ( $ dir ) ; } return $ finder ; }
3941	public function maxChildren ( $ conditionType ) { if ( ! isset ( $ GLOBALS [ 'METAMODELS' ] [ 'inputscreen_conditions' ] [ $ conditionType ] [ 'maxChildren' ] ) ) { return null ; } @ trigger_error ( 'Configuring input screen conditions via global array is deprecated. ' . 'Please implement/configure a valid condition factory.' , E_USER_DEPRECATED ) ; return $ GLOBALS [ 'METAMODELS' ] [ 'inputscreen_conditions' ] [ $ conditionType ] [ 'maxChildren' ] ; }
5941	public function connect ( ) { if ( $ this -> stream !== null ) { return ; } $ host = strval ( $ this -> config [ "host" ] ) ; $ port = strval ( $ this -> config [ "port" ] ) ; $ address = "tcp://" . $ host . ":" . $ port ; $ timeout = intval ( $ this -> config [ "timeout" ] ) ; $ this -> stream = @ stream_socket_client ( $ address , $ errno , $ errstr , $ timeout ) ; if ( $ this -> stream === false ) { throw new Ts3Exception ( StringHelper :: factory ( $ errstr ) -> toUtf8 ( ) -> toString ( ) , $ errno ) ; } @ stream_set_timeout ( $ this -> stream , $ timeout ) ; @ stream_set_blocking ( $ this -> stream , $ this -> config [ "blocking" ] ? 1 : 0 ) ; }
4788	function insert ( $ data ) { $ rows = func_get_args ( ) ; $ return = $ this -> insert_multi ( $ rows ) ; if ( ! $ return ) { return false ; } if ( ! is_array ( $ data ) ) { return $ return ; } if ( $ this -> notORM -> driver == "pgsql" ) { if ( ! isset ( $ data [ $ this -> primary ] ) ) { $ pgss = $ this -> query ( "SELECT pg_get_serial_sequence('" . $ this -> table . "', '" . $ this -> primary . "') pgss" , $ this -> parameters ) -> fetch ( ) ; if ( isset ( $ pgss [ 'pgss' ] ) ) { $ rs = $ this -> query ( "select last_value id from " . $ pgss [ 'pgss' ] , $ this -> parameters ) -> fetch ( ) ; $ data [ $ this -> primary ] = $ rs [ 'id' ] ; $ this -> sequence = $ rs [ 'id' ] ; } } } else { if ( ! isset ( $ data [ $ this -> primary ] ) && ( $ id = $ this -> notORM -> connection -> lastInsertId ( $ this -> notORM -> structure -> getSequence ( $ this -> table ) ) ) ) { $ data [ $ this -> primary ] = $ id ; } } return new $ this -> notORM -> rowClass ( $ data , $ this ) ; }
1480	private function flip ( array $ resources ) { $ all = [ ] ; foreach ( $ resources as $ resourceType => $ types ) { foreach ( ( array ) $ types as $ type ) { $ all [ $ type ] = $ resourceType ; } } return $ all ; }
1449	protected function relationshipRules ( $ record , string $ field ) : array { return collect ( $ this -> rules ( $ record ) ) -> filter ( function ( $ v , $ key ) use ( $ field ) { return Str :: startsWith ( $ key , $ field ) ; } ) -> all ( ) ; }
12526	static public function cleanup ( $ opts = array ( ) ) { if ( strtoupper ( substr ( PHP_OS , 0 , 3 ) ) == 'WIN' ) { exec ( 'tasklist /FO CSV' , $ runningProcesses , $ return_var ) ; $ runningProcesses = array_map ( function ( $ line ) { $ cols = explode ( ',' , $ line ) ; return trim ( $ cols [ 1 ] , '"' ) ; } , $ runningProcesses ) ; unset ( $ runningProcesses [ 0 ] ) ; sort ( $ runningProcesses ) ; unset ( $ runningProcesses [ 0 ] ) ; } else { exec ( 'ps -e -o pid' , $ runningProcesses , $ return_var ) ; } if ( $ return_var != 0 ) { pake_echo_error ( "Could not get list of processes to remove stale lock files" ) ; return ; } $ lockDir = self :: lockDir ( $ opts ) ; foreach ( glob ( $ lockDir . "/*_W.lock" ) as $ writeLock ) { $ pid = file_get_contents ( $ writeLock ) ; if ( ! in_array ( $ pid , $ runningProcesses ) ) { pake_unlink ( $ writeLock ) ; } } foreach ( glob ( $ lockDir . "/*_R/*.lock" ) as $ readLock ) { $ pid = file_get_contents ( $ readLock ) ; if ( ! in_array ( $ pid , $ runningProcesses ) ) { pake_unlink ( $ readLock ) ; } } }
7702	function OpenDoc_GetDraw ( $ Tag , $ Txt , $ Pos , $ Forward , $ LevelStop ) { return $ this -> XML_BlockAlias_Prefix ( 'draw:' , $ Txt , $ Pos , $ Forward , $ LevelStop ) ; }
6238	public function write ( string $ content , bool $ append = false , int $ mode = LOCK_EX ) : self { $ this -> checkFileWritePermissions ( ) ; if ( ! $ this -> storage -> writeFile ( $ content , $ append , $ mode ) ) { throw new AccessDeniedException ( 'unable to write file-content' , 403 ) ; } return $ this ; }
7705	function _GetAttValPos ( $ Att ) { if ( $ this -> pST_Src === false ) $ this -> pST_Src = substr ( $ this -> Txt , $ this -> PosBeg , $ this -> pST_PosEnd - $ this -> PosBeg + 1 ) ; $ a = ' ' . $ Att . '="' ; $ p0 = strpos ( $ this -> pST_Src , $ a ) ; if ( $ p0 !== false ) { $ p1 = $ p0 + strlen ( $ a ) ; $ p2 = strpos ( $ this -> pST_Src , '"' , $ p1 ) ; if ( $ p2 !== false ) return array ( $ p1 , $ p2 - $ p1 , $ p0 , $ p2 - $ p0 + 1 ) ; } return false ; }
12389	protected function updateCredentialHash ( PasswordableInterface $ identityObject , $ password ) { $ cryptoService = $ this -> getMapper ( ) -> getPasswordService ( ) ; if ( ! $ cryptoService instanceof Bcrypt ) { return $ this ; } $ hash = explode ( '$' , $ identityObject -> getPassword ( ) ) ; if ( $ hash [ 2 ] === $ cryptoService -> getCost ( ) ) { return $ this ; } $ identityObject -> setPassword ( $ cryptoService -> create ( $ password ) ) ; return $ this ; }
6167	protected function writePerformance ( $ time ) { $ ms = round ( $ time * 1000 ) ; foreach ( self :: $ performanceThresholds as $ colour => $ threshold ) { if ( $ ms > $ threshold ) { break ; } } $ this -> writeWithColor ( $ colour , " ($ms ms)" ) ; }
3364	public function flush ( $ args , $ assoc_args ) { self :: apache_modules ( ) ; if ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) && ! in_array ( 'mod_rewrite' , ( array ) WP_CLI :: get_config ( 'apache_modules' ) , true ) ) { WP_CLI :: warning ( 'Regenerating a .htaccess file requires special configuration. See usage docs.' ) ; } if ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) && is_multisite ( ) ) { WP_CLI :: warning ( "WordPress can't generate .htaccess file for a multisite install." ) ; } self :: check_skip_plugins_themes ( ) ; flush_rewrite_rules ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) ) ; if ( ! get_option ( 'rewrite_rules' ) ) { WP_CLI :: warning ( "Rewrite rules are empty, possibly because of a missing permalink_structure option. Use 'wp rewrite list' to verify, or 'wp rewrite structure' to update permalink_structure." ) ; } else { WP_CLI :: success ( 'Rewrite rules flushed.' ) ; } }
11665	private function filterElement ( ElementInterface $ element ) { $ value = $ element -> getValue ( ) ; foreach ( $ this -> filters as $ scope => $ filter ) { $ elementIds = array_map ( 'trim' , explode ( ',' , $ scope ) ) ; if ( $ scope === '*' || in_array ( $ element -> getID ( ) , $ elementIds ) ) { $ value = $ filter -> filter ( $ value ) ; } } $ element -> setValue ( $ value ) ; }
9004	protected function months_dropdown ( $ post_type ) { global $ wpdb , $ wp_locale ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ months = $ wpdb -> get_results ( " SELECT DISTINCT YEAR( time ) AS year, MONTH( time ) AS month FROM $tn ORDER BY time DESC " ) ; $ month_count = count ( $ months ) ; if ( ! $ month_count || ( 1 == $ month_count && 0 == $ months [ 0 ] -> month ) ) { return ; } $ m = isset ( $ _GET [ 'm' ] ) ? ( int ) $ _GET [ 'm' ] : 0 ; ?> <label for="filter-by-date" class="screen-reader-text"> <?php _e ( 'Filter by date' ) ; ?> </label> <select name="m" id="filter-by-date"> <option <?php selected ( $ m , 0 ) ; ?> value="0"> <?php _e ( 'All dates' ) ; ?> </option> <?php foreach ( $ months as $ arc_row ) { if ( 0 == $ arc_row -> year ) { continue ; } $ month = zeroise ( $ arc_row -> month , 2 ) ; $ year = $ arc_row -> year ; printf ( "<option %s value='%s'>%s</option>\n" , selected ( $ m , $ year . $ month , false ) , esc_attr ( $ arc_row -> year . $ month ) , sprintf ( __ ( '%1$s %2$d' ) , $ wp_locale -> get_month ( $ month ) , $ year ) ) ; } ?> </select> <?php }
10727	public function getYear ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'year' ] ; } }
4379	protected function dumpArray ( $ array ) { if ( empty ( $ array ) ) { $ html = '<span class="t_keyword">array</span>' . '<span class="t_punct">()</span>' ; } else { $ displayKeys = $ this -> debug -> getCfg ( 'output.displayListKeys' ) || ! $ this -> debug -> utilities -> isList ( $ array ) ; $ html = '<span class="t_keyword">array</span>' . '<span class="t_punct">(</span>' . "\n" ; if ( $ displayKeys ) { $ html .= '<span class="array-inner">' . "\n" ; foreach ( $ array as $ key => $ val ) { $ html .= "\t" . '<span class="key-value">' . '<span class="t_key' . ( \ is_int ( $ key ) ? ' t_int' : '' ) . '">' . $ this -> dump ( $ key , true , false ) . '</span> ' . '<span class="t_operator">=&gt;</span> ' . $ this -> dump ( $ val ) . '</span>' . "\n" ; } $ html .= '</span>' ; } else { $ html .= '<ul class="array-inner list-unstyled">' . "\n" ; foreach ( $ array as $ val ) { $ html .= $ this -> dump ( $ val , true , 'li' ) ; } $ html .= '</ul>' ; } $ html .= '<span class="t_punct">)</span>' ; } return $ html ; }
5155	public function setConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } unset ( $ this -> configuration ) ; $ this -> configuration = $ configuration ; if ( $ configure ) { $ this -> configure ( ) ; } }
5258	public static function map ( $ query = [ ] , callable $ callback = null , $ limit = - 1 ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ query [ 'from' ] = Arr :: get ( $ query , 'from' , 0 ) ; $ query [ 'size' ] = Arr :: get ( $ query , 'size' , 50 ) ; $ i = 0 ; $ models = static :: search ( $ query ) ; $ total = $ models -> getTotal ( ) ; while ( $ models ) { foreach ( $ models as $ model ) { if ( $ callback ) { $ callback ( $ model ) ; } $ i ++ ; } $ query [ 'from' ] += $ query [ 'size' ] ; if ( $ i >= $ total || ( $ limit > 0 && $ i >= $ limit ) ) { break ; } $ models = static :: search ( $ query ) ; } return $ total ; }
2069	public function cutPage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_PAGE_HIERARCHY , $ row ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
5226	private function isTypeMismatch ( $ type , $ value ) { if ( ! ( $ type instanceof \ ReflectionClass ) ) { return false ; } if ( ! is_object ( $ value ) ) { return true ; } return ! $ type -> isInstance ( $ value ) ; }
1093	protected function getFreshInstance ( ) { if ( $ this -> areSoftDeletesEnabled ( ) ) return static :: withTrashed ( ) -> find ( $ this -> getKey ( ) ) ; return static :: find ( $ this -> getKey ( ) ) ; }
2433	public function get ( $ strKey ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { return $ this -> session -> get ( $ strKey ) ; } return $ this -> sessionBag -> get ( $ strKey ) ; }
3191	public function timeout ( $ timeLimit , $ tags , $ target ) { $ duration = $ this -> compute ( $ tags , $ target ) ; return $ duration >= $ timeLimit ; }
3208	public static function encode ( $ string ) { if ( strlen ( $ string ) == 0 ) { return '' ; } $ binaryString = '' ; foreach ( str_split ( $ string ) as $ s ) { $ binaryString .= sprintf ( '%08b' , ord ( $ s ) ) ; } $ binaryArray = self :: chunk ( $ binaryString , 5 ) ; while ( count ( $ binaryArray ) % 8 !== 0 ) { $ binaryArray [ ] = null ; } $ base32String = '' ; foreach ( $ binaryArray as $ bin ) { $ char = 32 ; if ( ! is_null ( $ bin ) ) { $ bin = str_pad ( $ bin , 5 , 0 , STR_PAD_RIGHT ) ; $ char = bindec ( $ bin ) ; } $ base32String .= self :: $ alphabet [ $ char ] ; } return $ base32String ; }
11190	public function getData ( ) { $ reference = new FluidXml ( false ) ; $ reference -> add ( $ this -> getTransactionReference ( ) ) ; return [ 'password' => $ this -> getPassword ( ) , 'userId' => $ this -> getUserId ( ) , 'merchantId' => $ this -> getMerchantId ( ) , 'transactionReference' => $ reference ] ; }
5004	protected function createEventManager ( $ services , $ config ) { if ( $ services -> has ( $ config [ 'service' ] ) ) { $ events = $ services -> get ( $ config [ 'service' ] ) ; } else { if ( ! class_exists ( $ config [ 'service' ] , true ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Class or service %s does not exists. Cannot create event manager instance.' , $ config [ 'service' ] ) ) ; } $ events = new $ config [ 'service' ] ( ) ; } if ( false === $ config [ 'configure' ] ) { return $ events ; } $ events -> setIdentifiers ( $ config [ 'identifiers' ] ) ; $ event = $ services -> has ( $ config [ 'event' ] ) ? $ services -> get ( $ config [ 'event' ] ) : new $ config [ 'event' ] ( ) ; $ events -> setEventPrototype ( $ event ) ; if ( 'EventManager' != $ config [ 'service' ] && method_exists ( $ events , 'setSharedManager' ) && $ services -> has ( 'SharedEventManager' ) ) { $ sharedEvents = $ services -> get ( 'SharedEventManager' ) ; $ events -> setSharedManager ( $ sharedEvents ) ; } return $ events ; }
2227	public function editHeader ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> User -> canEditFieldsOf ( 'tl_faq_category' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
2931	public function setKeys ( $ data ) { foreach ( $ data as $ setter ) { if ( array_key_exists ( 'key' , $ setter ) ) { $ key = $ this -> formatter -> formatKey ( $ setter [ 'key' ] ) ; $ value = array_key_exists ( 'value' , $ setter ) ? $ setter [ 'value' ] : null ; $ comment = array_key_exists ( 'comment' , $ setter ) ? $ setter [ 'comment' ] : null ; $ export = array_key_exists ( 'export' , $ setter ) ? $ setter [ 'export' ] : false ; if ( ! is_file ( $ this -> filePath ) || ! $ this -> keyExists ( $ key ) ) { $ this -> writer -> appendSetter ( $ key , $ value , $ comment , $ export ) ; } else { $ oldInfo = $ this -> getKeys ( [ $ key ] ) ; $ comment = is_null ( $ comment ) ? $ oldInfo [ $ key ] [ 'comment' ] : $ comment ; $ this -> writer -> updateSetter ( $ key , $ value , $ comment , $ export ) ; } } } return $ this ; }
2907	public function getPartDecodedContent ( Zend_Mime_Part $ mimePart ) { if ( method_exists ( $ mimePart , 'getRawContent' ) ) { return $ mimePart -> getRawContent ( ) ; } $ content = '' ; if ( method_exists ( $ mimePart , 'getContent' ) ) { $ encoding = $ mimePart -> encoding ; $ mimePart -> encoding = 'none' ; $ content = $ mimePart -> getContent ( ) ; $ mimePart -> encoding = $ encoding ; } return $ content ; }
12443	public function add ( InvokerInterface $ invoker , $ taskArgs = [ ] ) { $ taskArgs = ( is_array ( $ taskArgs ) ? $ taskArgs : array_slice ( func_get_args ( ) , 1 ) ) ; array_unshift ( $ this -> tasks , compact ( 'invoker' , 'taskArgs' ) ) ; return $ this ; }
461	public function buildColumns ( $ columns ) { if ( ! is_array ( $ columns ) ) { if ( strpos ( $ columns , '(' ) !== false ) { return $ columns ; } $ rawColumns = $ columns ; $ columns = preg_split ( '/\s*,\s*/' , $ columns , - 1 , PREG_SPLIT_NO_EMPTY ) ; if ( $ columns === false ) { throw new InvalidArgumentException ( "$rawColumns is not valid columns." ) ; } } foreach ( $ columns as $ i => $ column ) { if ( $ column instanceof ExpressionInterface ) { $ columns [ $ i ] = $ this -> buildExpression ( $ column ) ; } elseif ( strpos ( $ column , '(' ) === false ) { $ columns [ $ i ] = $ this -> db -> quoteColumnName ( $ column ) ; } } return implode ( ', ' , $ columns ) ; }
7116	public function watch ( Repository \ PaymentRepositoryInterface $ paymentRepository ) { if ( null === $ term = $ this -> termRepository -> findLongest ( ) ) { return false ; } $ today = new \ DateTime ( ) ; $ today -> setTime ( 0 , 0 , 0 ) ; $ fromDate = clone $ today ; $ fromDate -> modify ( '-1 year' ) ; $ states = [ Model \ PaymentStates :: STATE_AUTHORIZED , Model \ PaymentStates :: STATE_CAPTURED ] ; $ method = $ this -> methodRepository -> findOneBy ( [ 'factoryName' => Constants :: FACTORY_NAME , ] ) ; if ( ! $ method || ! $ method -> isOutstanding ( ) ) { return false ; } $ result = false ; $ payments = $ paymentRepository -> findByMethodAndStates ( $ method , $ states , $ fromDate ) ; foreach ( $ payments as $ payment ) { $ sale = $ payment -> getSale ( ) ; if ( null === $ date = $ sale -> getOutstandingDate ( ) ) { continue ; } $ diff = $ date -> diff ( $ today ) ; if ( 0 < $ diff -> days && ! $ diff -> invert ) { $ payment -> setState ( Model \ PaymentStates :: STATE_EXPIRED ) ; $ this -> persist ( $ payment ) ; $ result = true ; } } return $ result ; }
5108	private function appendDesc ( & $ column ) : void { if ( is_array ( $ column ) ) { foreach ( $ column as & $ col ) { $ col = "$col DESC" ; } } else { $ column = [ "$column DESC" ] ; } }
10237	public static function getInstance ( Spreadsheet $ spreadsheet = null ) { if ( $ spreadsheet !== null ) { $ instance = $ spreadsheet -> getCalculationEngine ( ) ; if ( isset ( $ instance ) ) { return $ instance ; } } if ( ! isset ( self :: $ instance ) || ( self :: $ instance === null ) ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
2698	public function upgrade ( ModuleDataSetupInterface $ setup , ModuleContextInterface $ context ) { $ version = $ context -> getVersion ( ) ; if ( ! $ version ) { return ; } $ oldConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/geoip_country_mapping' , ] ; $ newConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/fastly_advanced_configuration/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/fastly_advanced_configuration/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_country_mapping' ] ; $ setup -> startSetup ( ) ; if ( version_compare ( $ version , '1.0.8' , '<=' ) ) { $ this -> upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) ; } if ( version_compare ( $ version , '1.0.9' , '<=' ) ) { $ this -> upgrade109 ( $ setup ) ; } $ magVer = $ this -> productMetadata -> getVersion ( ) ; if ( version_compare ( $ version , '1.0.10' , '<=' ) && version_compare ( $ magVer , '2.2' , '>=' ) ) { $ this -> upgrade1010 ( $ newConfigPaths ) ; $ setup -> endSetup ( ) ; } elseif ( version_compare ( $ magVer , '2.2' , '<' ) ) { $ setup -> endSetup ( ) ; } }
7752	protected function completeMetadata ( ClassMetadata $ class ) { $ className = $ class -> getName ( ) ; if ( null === $ class -> getIri ( ) ) { $ class -> setIri ( $ this -> namingStrategy -> classIriFragment ( $ className ) ) ; } if ( null === $ class -> getExposeAs ( ) ) { $ class -> setExposeAs ( $ this -> namingStrategy -> classShortName ( $ className ) ) ; } if ( null === $ class -> getTitle ( ) ) { $ class -> setTitle ( $ this -> namingStrategy -> classShortName ( $ className ) ) ; } foreach ( $ class -> getProperties ( ) as $ property ) { $ propertyName = $ property -> getName ( ) ; if ( null === $ property -> getIri ( ) ) { $ property -> setIri ( $ this -> namingStrategy -> propertyIriFragment ( $ className , $ propertyName ) ) ; } if ( null === $ property -> getExposeAs ( ) ) { $ property -> setExposeAs ( $ this -> namingStrategy -> propertyShortName ( $ className , $ propertyName ) ) ; } if ( null === $ property -> getTitle ( ) ) { $ property -> setTitle ( $ this -> namingStrategy -> propertyShortName ( $ className , $ propertyName ) ) ; } } }
10947	public function getAcceptableContentTypes ( ) { if ( $ this -> _contentTypes === null ) { if ( isset ( $ _SERVER [ 'HTTP_ACCEPT' ] ) ) { $ this -> _contentTypes = $ this -> parseAcceptHeader ( $ _SERVER [ 'HTTP_ACCEPT' ] ) ; } else { $ this -> _contentTypes = [ ] ; } } return $ this -> _contentTypes ; }
7345	public function modifySubmitedValueBeforeValidation ( $ value , array $ data ) { if ( $ this -> hasSubmittedValueModifier ( ) ) { return call_user_func ( $ this -> getSubmittedValueModifier ( ) , $ value , $ data ) ; } else { return $ value ; } }
11946	protected function getCurrentUser ( ) { try { return JWTAuth :: parseToken ( ) -> authenticate ( ) ; } catch ( \ Tymon \ JWTAuth \ Exceptions \ JWTException $ ex ) { return null ; } }
6190	public function renderJSON ( $ data , $ status = 200 ) { exit ( Response :: Create ( json_encode ( $ data ) ) -> status ( $ status ) -> headers ( [ 'Content-Type' => 'application/json' ] ) -> display ( ) ) ; }
8236	protected function checkServerConfiguration ( ) { $ pico = $ this -> picoAuth -> getPico ( ) ; $ configDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfigDir ( ) ) ; $ configFile = $ configDir . "/config.yml" ; $ contentDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfig ( 'content_dir' ) ) ; $ indexFile = $ contentDir . "/index" . $ pico -> getConfig ( 'content_ext' ) ; $ urls = array ( 'dir_listing' => $ configDir , 'config_file' => $ configFile , 'content_file' => $ indexFile ) ; $ this -> httpsTest ( ) ; $ this -> webRootDirsTest ( ) ; $ this -> picoAuth -> addOutput ( "installer_urltest" , $ urls ) ; }
970	public function setDomain ( string $ shopDomain ) { $ this -> fixLifetime ( ) ; Session :: put ( self :: DOMAIN , $ shopDomain ) ; }
9933	public function setRuleType ( $ pRuleType ) { if ( ! in_array ( $ pRuleType , self :: $ ruleTypes ) ) { throw new PhpSpreadsheetException ( 'Invalid rule type for column AutoFilter Rule.' ) ; } $ this -> ruleType = $ pRuleType ; return $ this ; }
9943	public function setCellValueExplicit ( $ pCoordinate , $ pValue , $ pDataType ) { $ this -> getCell ( $ pCoordinate ) -> setValueExplicit ( $ pValue , $ pDataType ) ; return $ this ; }
2850	public function setTemplateHints ( $ status ) { $ this -> deleteTemplateHintsDbConfigs ( ) ; $ config = $ this -> getConfig ( ) ; $ config -> saveConfig ( 'dev/debug/template_hints' , ( int ) $ status ) ; $ config -> saveConfig ( 'dev/debug/template_hints_blocks' , ( int ) $ status ) ; }
3846	protected static function changeSubPalettesToConditions ( ) { $ objDB = self :: DB ( ) ; if ( ! $ objDB -> tableExists ( 'tl_metamodel_dcasetting_condition' ) ) { $ objDB -> execute ( 'CREATE TABLE `tl_metamodel_dcasetting_condition` ( `id` int(10) unsigned NOT NULL auto_increment, `pid` int(10) unsigned NOT NULL default \'0\', `settingId` int(10) unsigned NOT NULL default \'0\', `sorting` int(10) unsigned NOT NULL default \'0\', `tstamp` int(10) unsigned NOT NULL default \'0\', `enabled` char(1) NOT NULL default \'\', `type` varchar(255) NOT NULL default \'\', `attr_id` int(10) unsigned NOT NULL default \'0\', `comment` varchar(255) NOT NULL default \'\', `value` blob NULL, PRIMARY KEY (`id`) )ENGINE=MyISAM DEFAULT CHARSET=utf8;' ) ; } if ( $ objDB -> tableExists ( 'tl_metamodel_dcasetting' , null , true ) && $ objDB -> fieldExists ( 'subpalette' , 'tl_metamodel_dcasetting' , true ) ) { $ subpalettes = $ objDB -> execute ( 'SELECT * FROM tl_metamodel_dcasetting WHERE subpalette!=0' ) ; if ( $ subpalettes -> numRows ) { $ attributes = $ objDB -> execute ( ' SELECT attr_id, colName FROM tl_metamodel_dcasetting AS setting LEFT JOIN tl_metamodel_attribute AS attribute ON (setting.attr_id=attribute.id) WHERE dcatype=\'attribute\' ' ) ; $ attr = array ( ) ; while ( $ attributes -> next ( ) ) { $ attr [ $ attributes -> attr_id ] = $ attributes -> colName ; } $ checkboxes = $ objDB -> execute ( ' SELECT * FROM tl_metamodel_dcasetting WHERE subpalette=0 AND dcatype=\'attribute\' ' ) ; $ check = array ( ) ; while ( $ checkboxes -> next ( ) ) { $ check [ $ checkboxes -> id ] = $ checkboxes -> attr_id ; } while ( $ subpalettes -> next ( ) ) { $ data = array ( 'pid' => 0 , 'settingId' => $ subpalettes -> id , 'sorting' => '128' , 'tstamp' => time ( ) , 'enabled' => '1' , 'type' => 'conditionpropertyvalueis' , 'attr_id' => $ check [ $ subpalettes -> subpalette ] , 'comment' => sprintf ( 'Only show when checkbox "%s" is checked' , $ attr [ $ check [ $ subpalettes -> subpalette ] ] ) , 'value' => '1' , ) ; $ objDB -> prepare ( 'INSERT INTO tl_metamodel_dcasetting_condition %s' ) -> set ( $ data ) -> execute ( ) ; $ objDB -> prepare ( 'UPDATE tl_metamodel_dcasetting SET subpalette=0 WHERE id=?' ) -> execute ( $ subpalettes -> id ) ; $ objDB -> prepare ( 'UPDATE tl_metamodel_dcasetting SET submitOnChange=1 WHERE id=?' ) -> execute ( $ subpalettes -> subpalette ) ; } } TableManipulation :: dropColumn ( 'tl_metamodel_dcasetting' , 'subpalette' , true ) ; } }
5574	public function clickSubmit ( $ label = 'Submit' , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectByLabel ( $ label ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectByLabel ( $ label ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
5722	public function save ( $ data , $ form ) { $ origStage = Versioned :: get_stage ( ) ; Versioned :: set_stage ( 'Stage' ) ; $ action = $ this -> owner -> doSave ( $ data , $ form ) ; Versioned :: set_stage ( $ origStage ) ; return $ action ; }
3058	public function containsAdaptive ( ) { $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ this -> getCompilationDirectory ( ) [ 'private' ] ) ; return ! empty ( $ adaptiveSectionMap ) ; }
5809	public function updateSearchForm ( $ form ) { Requirements :: javascript ( FUSION_PATH . '/javascript/fusion.js' ) ; $ form -> Fields ( ) -> insertBefore ( ListboxField :: create ( 'q[Tagging]' , 'Tags' , FusionTag :: get ( ) -> map ( 'Title' , 'Title' ) -> toArray ( ) , ( ( $ filtering = $ this -> owner -> getRequest ( ) -> getVar ( 'q' ) ) && isset ( $ filtering [ 'Tagging' ] ) ) ? $ filtering [ 'Tagging' ] : array ( ) , null , true ) , 'q[Term]' ) ; $ this -> owner -> extend ( 'updateCMSMainTaggingExtensionSearchForm' , $ form ) ; }
5482	public function setField ( SelectorInterface $ selector , $ value , $ position = false ) { $ success = false ; $ _position = 0 ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { $ _position ++ ; if ( $ position === false or $ _position === ( int ) $ position ) { if ( $ this -> widgets [ $ i ] -> setValue ( $ value ) ) { $ success = true ; } } } } return $ success ; }
8182	public function getDuration ( ) { if ( $ this -> isRoot ( ) && $ this -> profiles ) { $ duration = 0 ; foreach ( $ this -> profiles as $ profile ) { $ duration += $ profile -> getDuration ( ) ; } return $ duration ; } return isset ( $ this -> ends [ 'wt' ] ) && isset ( $ this -> starts [ 'wt' ] ) ? $ this -> ends [ 'wt' ] - $ this -> starts [ 'wt' ] : 0 ; }
9992	public function generateStyles ( $ generateSurroundingHTML = true ) { if ( $ this -> spreadsheet === null ) { throw new WriterException ( 'Internal Spreadsheet object not set to an instance of an object.' ) ; } $ css = $ this -> buildCSS ( $ generateSurroundingHTML ) ; $ html = '' ; if ( $ generateSurroundingHTML ) { $ html .= ' <style type="text/css">' . PHP_EOL ; $ html .= ' html { ' . $ this -> assembleCSS ( $ css [ 'html' ] ) . ' }' . PHP_EOL ; } foreach ( $ css as $ styleName => $ styleDefinition ) { if ( $ styleName != 'html' ) { $ html .= ' ' . $ styleName . ' { ' . $ this -> assembleCSS ( $ styleDefinition ) . ' }' . PHP_EOL ; } } if ( $ generateSurroundingHTML ) { $ html .= ' </style>' . PHP_EOL ; } return $ html ; }
7963	public function ipSetMonitoringNotifications ( $ ip , $ frequency = 'once' , $ email = '' , $ sms = array ( ) ) { return json_decode ( self :: getClient ( ) -> ipSetMonitoringNotifications ( $ this -> id , $ ip , $ frequency , $ email , $ sms ) ) ; }
5232	public function equals ( $ compare ) { if ( $ compare instanceof self ) { return ( get_class ( $ compare ) === get_class ( $ this ) && $ compare -> name ( ) === $ this -> name ) ; } return false ; }
2512	public function setStatus ( $ newStatus ) { if ( $ this -> isWorseStatus ( $ newStatus , $ this -> status ) ) { $ this -> status = $ newStatus ; } }
10175	public function getHighestColumn ( $ row = null ) { if ( $ row == null ) { $ colRow = $ this -> getHighestRowAndColumn ( ) ; return $ colRow [ 'column' ] ; } $ columnList = [ 1 ] ; foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ r != $ row ) { continue ; } $ columnList [ ] = Coordinate :: columnIndexFromString ( $ c ) ; } return Coordinate :: stringFromColumnIndex ( max ( $ columnList ) + 1 ) ; }
5198	public function save ( ) { try { $ connection = new Connection ( $ this -> buildConnectionOptions ( ) ) ; $ connection -> open ( ) ; $ msg = new AMQPMessage ( $ this -> message , array ( 'content_type' => $ this -> content_type , 'delivery_mode' => 2 ) ) ; $ connection -> channel -> basic_publish ( $ msg , $ this -> exchange , $ this -> queue_name ) ; $ connection -> close ( ) ; } catch ( Exception $ e ) { $ connection -> close ( ) ; throw new Exception ( $ e ) ; } }
928	public function delete ( $ path ) { if ( isset ( $ this -> files [ $ path ] ) ) { unset ( $ this -> files [ $ path ] ) ; } $ this -> unlink ( $ path ) ; }
1454	protected function validateRelationship ( RelationshipInterface $ relationship , $ key = null ) { if ( ! $ relationship -> has ( RelationshipInterface :: DATA ) ) { $ this -> addError ( $ this -> errorFactory -> memberRequired ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ relationship -> isHasOne ( ) && ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> memberRelationshipExpected ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ this -> validateEmpty ( $ relationship , $ key ) ) { return false ; } return true ; }
8419	public static function get ( string $ alias ) { if ( isset ( self :: $ databases [ $ alias ] ) === false ) { throw new DatabaseNotFound ( 'database "' . $ alias . '" doesn\'t seem to be registered' ) ; } return self :: $ databases [ $ alias ] ; }
2913	public function formatMemorySize ( $ size , $ precision = 2 ) { $ sizes = array ( " Bytes" , " KB" , " MB" , " GB" , " TB" , " PB" , " EB" , " ZB" , " YB" ) ; if ( $ size == 0 ) { return $ this -> __ ( 'n/a' ) ; } else { $ value = round ( $ size / pow ( 1000 , ( $ i = floor ( log ( $ size , 1000 ) ) ) ) , $ precision ) ; $ unitIndex = ( int ) $ i ; return $ this -> __ ( '%s%s' , $ this -> formatNumber ( $ value , $ precision ) , $ sizes [ $ unitIndex ] ) ; } }
7148	public function getTotal ( $ discounted = true ) { $ base = $ this -> base ; if ( $ discounted && $ this -> hasDiscounts ( ) ) { foreach ( $ this -> discounts as $ discount ) { $ base -= $ this -> calculateAdjustment ( $ discount , $ base ) ; } } $ total = $ base ; if ( ! empty ( $ this -> taxes ) && $ this -> mode === VatDisplayModes :: MODE_ATI ) { foreach ( $ this -> taxes as $ tax ) { $ total += $ this -> calculateAdjustment ( $ tax , $ base ) ; } } return $ total ; }
771	public function actionConfig ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; $ dir = dirname ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } $ array = VarDumper :: export ( $ this -> getOptionValues ( $ this -> action -> id ) ) ; $ content = <<<EOD<?php/** * Configuration file for 'yii {$this->id}/{$this->defaultAction}' command. * * This file is automatically generated by 'yii {$this->id}/{$this->action->id}' command. * It contains parameters for source code messages extraction. * You may modify this file to suit your needs. * * You can use 'yii {$this->id}/{$this->action->id}-template' command to create * template configuration file with detailed description for each parameter. */return $array;EOD ; if ( FileHelper :: createDirectory ( $ dir ) === false || file_put_contents ( $ filePath , $ content , LOCK_EX ) === false ) { $ this -> stdout ( "Configuration file was NOT created: '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file created: '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; }
5409	public function selectAsPairs ( $ url ) { $ pairs = array ( ) ; foreach ( $ this -> cookies as $ cookie ) { if ( $ this -> isMatch ( $ cookie , $ url -> getHost ( ) , $ url -> getPath ( ) , $ cookie -> getName ( ) ) ) { $ pairs [ ] = $ cookie -> getName ( ) . '=' . $ cookie -> getValue ( ) ; } } return $ pairs ; }
12221	private function logException ( Exception $ exception ) { if ( in_array ( $ exception -> getStatusCode ( ) , $ this -> doNotLog ) ) { return ; } $ message = sprintf ( 'Uncaught exception of type %s thrown in file %s at line %s%s.' , get_class ( $ exception ) , $ exception -> getFile ( ) , $ exception -> getLine ( ) , $ exception -> getMessage ( ) ? sprintf ( ' with message "%s"' , $ exception -> getMessage ( ) ) : '' ) ; $ this -> container [ 'log' ] -> error ( $ message , array ( 'exception' => $ exception , 'Exception message' => $ message , 'Exception line' => $ exception -> getLine ( ) , 'Exception trace' => $ exception -> getTraceAsString ( ) , ) ) ; }
11472	public function update ( ResponseRequest $ request , Response $ response ) { try { $ attributes = $ request -> all ( ) ; $ id = $ attributes [ 'question_id' ] ; $ question = $ this -> question -> selectquestion ( $ id ) ; $ response -> update ( $ attributes ) ; return redirect ( '/discussion/' . $ question [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/response/' . $ response -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
108	private function addExtension ( $ name , $ prettyVersion ) { $ extraDescription = null ; try { $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } catch ( \ UnexpectedValueException $ e ) { $ extraDescription = ' (actual version: ' . $ prettyVersion . ')' ; if ( preg_match ( '{^(\d+\.\d+\.\d+(?:\.\d+)?)}' , $ prettyVersion , $ match ) ) { $ prettyVersion = $ match [ 1 ] ; } else { $ prettyVersion = '0' ; } $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } $ packageName = $ this -> buildPackageName ( $ name ) ; $ ext = new CompletePackage ( $ packageName , $ version , $ prettyVersion ) ; $ ext -> setDescription ( 'The ' . $ name . ' PHP extension' . $ extraDescription ) ; $ this -> addPackage ( $ ext ) ; }
12833	private function generateConfigCreatorMethod ( ConfigService $ config ) { $ configClass = Util :: normalizeFqcn ( $ config -> getClass ( ) ) ; $ configData = var_export ( $ config -> getData ( ) , true ) ; return <<<PHP public function getAppConfig() : {$configClass} { if (isset(\$this->singletons['{$config->getId()}}'])) { return \$this->singletons['{$config->getId()}']; } \$data = {$configData}; return \$this->singletons['{$config->getId()}'] = new {$configClass}(\$data); }PHP ; }
2086	public static function getPath ( $ template , $ format , $ custom = 'templates' ) { $ file = $ template . '.' . $ format ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ custom . '/' . $ file ) ) { return $ rootDir . '/' . $ custom . '/' . $ file ; } if ( $ custom != 'templates' ) { if ( file_exists ( $ rootDir . '/templates/' . $ file ) ) { return $ rootDir . '/templates/' . $ file ; } } return static :: getDefaultPath ( $ template , $ format ) ; }
11541	public function editProfile ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getEditProfileForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __FUNCTION__ , $ this , compact ( 'user' ) ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __FUNCTION__ . '.post' , $ this , compact ( 'user' ) ) ; return $ user ; }
7908	protected function renderDropdown ( ) { $ lines = [ ] ; $ lines [ ] = $ this -> encodeText ? Html :: encode ( $ this -> text ) : $ this -> text ; if ( $ this -> icon && is_string ( $ this -> icon ) ) { $ lines [ ] = $ this -> icon ; } $ lines [ ] = $ this -> renderItems ( $ this -> items , $ this -> options , $ this -> displaySearchInput ) ; return Html :: tag ( 'div' , implode ( "\n" , $ lines ) , $ this -> options ) ; }
9355	public function det ( ) { if ( ! $ this -> isSquare ( ) ) { throw new \ RuntimeException ( 'Cannot compute determinant of non square matrix!' ) ; } if ( $ this -> size -> rows == 2 ) { return $ this -> get ( 0 , 0 ) * $ this -> get ( 1 , 1 ) - $ this -> get ( 0 , 1 ) * $ this -> get ( 1 , 0 ) ; } else { $ int_out = 0 ; $ arr_row = $ this -> arr [ 0 ] ; foreach ( $ arr_row as $ n => $ v ) { $ int_out += pow ( - 1 , $ n + 2 ) * $ v * $ this -> subMatrix ( 0 , $ n ) -> det ( ) ; } return $ int_out ; } }
5684	public function getUrlById ( $ id ) { foreach ( $ this -> links as $ link ) { if ( $ link -> getAttribute ( 'id' ) === ( string ) $ id ) { return $ this -> getUrlFromLink ( $ link ) ; } } return false ; }
9953	public function mergeCells ( $ pRange ) { $ pRange = strtoupper ( $ pRange ) ; if ( strpos ( $ pRange , ':' ) !== false ) { $ this -> mergeCells [ $ pRange ] = $ pRange ; $ aReferences = Coordinate :: extractAllCellReferencesInRange ( $ pRange ) ; $ upperLeft = $ aReferences [ 0 ] ; if ( ! $ this -> cellExists ( $ upperLeft ) ) { $ this -> getCell ( $ upperLeft ) -> setValueExplicit ( null , DataType :: TYPE_NULL ) ; } $ count = count ( $ aReferences ) ; for ( $ i = 1 ; $ i < $ count ; ++ $ i ) { if ( $ this -> cellExists ( $ aReferences [ $ i ] ) ) { $ this -> getCell ( $ aReferences [ $ i ] ) -> setValueExplicit ( null , DataType :: TYPE_NULL ) ; } } } else { throw new Exception ( 'Merge must be set on a range of cells.' ) ; } return $ this ; }
8346	public static function route ( $ method , $ path , $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'route' , 'method' => $ method , 'path' => $ path , 'action' => $ action , 'namespace' => self :: $ namespace , 'subdomain' => self :: $ subdomain , 'uri' => self :: $ uri ) ; } }
446	public function detachBehaviors ( ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ name => $ behavior ) { $ this -> detachBehavior ( $ name ) ; } }
11567	public function set ( string $ sNameOfDi , callable $ cFunction , bool $ bShared = false ) : Di { if ( $ bShared === true ) { self :: $ _aSharedDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } else { $ this -> _aDependencyInjectorContener [ md5 ( $ sNameOfDi ) ] = $ cFunction ; } return $ this ; }
11964	private function checkSource ( $ connection ) { if ( gettype ( $ connection ) == "string" ) { $ config = include ( __DIR__ . '/../../../../../clusterpoint.php' ) ; $ connection = $ config [ $ connection ] ; } return $ connection ; }
10974	public function saveLocation ( $ runValidation = true , $ attributeNames = null ) { $ location = $ this -> location ; if ( $ location === null ) { $ location = new Location ( ) ; } $ location -> country_id = $ this -> country_id ; $ location -> region_id = $ this -> region_id ; $ location -> city_id = $ this -> city_id ; $ location -> state_id = $ this -> state_id ; $ location -> address = $ this -> address ; $ location -> postal_code = $ this -> postal_code ; $ location -> latitude = $ this -> latitude ; $ location -> longitude = $ this -> longitude ; if ( is_array ( $ attributeNames ) ) { $ attributesNames = array_intersect ( [ 'country_id' , 'region_id' , 'city_id' , 'state_id' , 'address' , 'postal_code' , 'latitude' , 'longitude' ] , $ attributesNames ) ; } if ( empty ( $ attributeNames ) ) { $ attributeNames = null ; } if ( $ location -> save ( $ runValidation , $ attributeNames ) === false ) { $ this -> addErrors ( $ location -> getErrors ( ) ) ; return false ; } $ this -> location_id = $ location -> id ; return true ; }
5644	public function getStatus ( ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { if ( ! $ this -> reporters [ $ i ] -> getStatus ( ) ) { return false ; } } return true ; }
7773	protected function validateAgainstRule ( $ field , $ value , $ rule , array $ args ) { $ ruleToCall = $ this -> getRuleToCall ( $ rule ) ; $ passed = call_user_func_array ( $ ruleToCall , [ $ value , $ this -> input , $ args ] ) ; if ( ! $ passed ) { $ this -> handleError ( $ field , $ value , $ rule , $ args ) ; return $ this -> canSkipRule ( $ ruleToCall , $ value ) ; } return true ; }
2338	public function initialize ( ) { if ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'enableVersioning' ] ) { return ; } $ objVersion = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_version WHERE fromTable=? AND pid=?" ) -> limit ( 1 ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> count > 0 ) { return ; } $ this -> create ( ) ; }
9111	protected function getConfig ( ) { $ config = $ this -> getServiceLocator ( ) -> get ( 'config' ) ; if ( isset ( $ config [ 'yima-theme' ] ) && is_array ( $ config [ 'yima-theme' ] ) ) { $ config = $ config [ 'yima-theme' ] ; } else { $ config = array ( ) ; } return $ config ; }
10293	protected static function validateTimeZone ( $ timeZone ) { if ( is_object ( $ timeZone ) && $ timeZone instanceof DateTimeZone ) { return $ timeZone ; } elseif ( is_string ( $ timeZone ) ) { return new DateTimeZone ( $ timeZone ) ; } throw new \ Exception ( 'Invalid timezone' ) ; }
2238	private function handlePrependLocale ( array $ extensionConfigs , ContainerBuilder $ container ) : array { if ( ! $ container -> hasParameter ( 'prepend_locale' ) ) { return $ extensionConfigs ; } foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'prepend_locale' ] ) ) { return $ extensionConfigs ; } } @ trigger_error ( 'Defining the "prepend_locale" parameter in the parameters.yml file has been deprecated and will no longer work in Contao 5.0. Define the "contao.prepend_locale" parameter in the config.yml file instead.' , E_USER_DEPRECATED ) ; $ extensionConfigs [ ] = [ 'prepend_locale' => '%prepend_locale%' , ] ; return $ extensionConfigs ; }
1289	public function setType ( string $ type = null ) { $ validTypes = [ 'all' , 'Asset' , 'Entry' , 'Deletion' , 'DeletedAsset' , 'DeletedEntry' ] ; if ( ! \ in_array ( $ type , $ validTypes , true ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Unexpected type "%s".' , $ type ) ) ; } $ this -> type = $ type ; return $ this ; }
8981	private static function matchesDateCriteria ( $ key , RateInterface $ rate , array $ criteria ) { $ date = self :: extractDateCriteria ( $ key , $ criteria ) ; if ( $ date === null ) { return true ; } if ( $ key === 'dateFrom' ) { $ rateDate = new \ DateTime ( $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) ) ; $ rateDate -> setTime ( 23 , 59 , 59 ) ; return $ date <= $ rateDate ; } if ( $ key === 'dateTo' ) { $ rateDate = new \ DateTime ( $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) ) ; $ rateDate -> setTime ( 0 , 0 , 0 ) ; return $ date >= $ rateDate ; } return $ date -> format ( 'Y-m-d' ) === $ rate -> getDate ( ) -> format ( 'Y-m-d' ) ; }
3421	protected function loadModels ( ) { $ queryType = 'UserQuery::getList' ; $ sort = $ this -> sort ; $ filter = $ this -> normalizeFilter ( ) ; $ params = [ 'SELECT' => $ this -> propsMustBeSelected ( ) ? [ 'UF_*' ] : ( $ this -> normalizeUfSelect ( ) ? : false ) , 'NAV_PARAMS' => $ this -> navigation , 'FIELDS' => $ this -> normalizeSelect ( ) , ] ; $ selectGroups = $ this -> groupsMustBeSelected ( ) ; $ keyBy = $ this -> keyBy ; $ callback = function ( ) use ( $ sort , $ filter , $ params , $ selectGroups ) { $ users = [ ] ; $ rsUsers = $ this -> bxObject -> getList ( $ sort , $ sortOrder = false , $ filter , $ params ) ; while ( $ arUser = $ this -> performFetchUsingSelectedMethod ( $ rsUsers ) ) { if ( $ selectGroups ) { $ arUser [ 'GROUP_ID' ] = $ this -> bxObject -> getUserGroup ( $ arUser [ 'ID' ] ) ; } $ this -> addItemToResultsUsingKeyBy ( $ users , new $ this -> modelName ( $ arUser [ 'ID' ] , $ arUser ) ) ; } return new Collection ( $ users ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'sort' , 'filter' , 'params' , 'selectGroups' , 'keyBy' ) , $ callback ) ; }
7231	public function loadResult ( array $ result ) { $ changed = false ; foreach ( [ 'revenue' , 'shipping' , 'margin' , 'orders' , 'items' , 'average' , 'details' ] as $ property ) { if ( $ this -> { $ property } != $ result [ $ property ] ) { $ this -> { $ property } = $ result [ $ property ] ; $ changed = true ; } } return $ changed ; }
4265	private function sortSubscribers ( $ eventName ) { \ krsort ( $ this -> subscribers [ $ eventName ] ) ; $ this -> sorted [ $ eventName ] = array ( ) ; foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ subscriber ) { if ( $ this -> isClosureFactory ( $ subscriber ) ) { $ subscriber [ 0 ] = $ subscriber [ 0 ] ( ) ; $ this -> subscribers [ $ eventName ] [ $ priority ] [ $ k ] = $ subscriber ; } $ this -> sorted [ $ eventName ] [ ] = $ subscriber ; } } }
3121	public function filter ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ subset = new static ( ) ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ subset -> add ( $ point ) ; } } return $ subset ; }
11235	protected function checkReferenceLoop ( $ loop , $ name ) { if ( $ loop > 20 ) { throw new RuntimeException ( Message :: get ( Message :: MSG_REF_LOOP , $ name ) , Message :: MSG_REF_LOOP ) ; } }
8762	public function upload ( $ input ) { $ validator = \ Validator :: make ( $ input , config ( 'dropzoner.validator' ) , config ( 'dropzoner.validator-messages' ) ) ; if ( $ validator -> fails ( ) ) { return response ( ) -> json ( [ 'error' => true , 'message' => $ validator -> messages ( ) -> first ( ) , 'code' => 400 ] , 400 ) ; } $ photo = $ input [ 'file' ] ; $ original_name = $ photo -> getClientOriginalName ( ) ; $ extension = $ photo -> getClientOriginalExtension ( ) ; $ original_name_without_extension = substr ( $ original_name , 0 , strlen ( $ original_name ) - strlen ( $ extension ) - 1 ) ; $ filename = $ this -> sanitize ( $ original_name_without_extension ) ; $ allowed_filename = $ this -> createUniqueFilename ( $ filename ) ; $ filename_with_extension = $ allowed_filename . '.' . $ extension ; $ manager = new ImageManager ( ) ; $ image = $ manager -> make ( $ photo ) -> save ( config ( 'dropzoner.upload-path' ) . $ filename_with_extension ) ; if ( ! $ image ) { return response ( ) -> json ( [ 'error' => true , 'message' => 'Server error while uploading' , 'code' => 500 ] , 500 ) ; } event ( new ImageWasUploaded ( $ original_name , $ filename_with_extension ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 , 'filename' => $ filename_with_extension ] , 200 ) ; }
2057	public function checkRootType ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue != 'root' && $ dc -> activeRecord -> pid == 0 ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'topLevelRoot' ] ) ; } return $ varValue ; }
2016	public function generateMarkup ( ) { $ return = ' <div> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple required> </div>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; }
4073	public function getUser ( ) { static $ authenticated ; if ( ! isset ( $ authenticated ) ) { $ authenticated = true ; $ this -> authenticateUser ( ) ; } return $ this -> user ; }
7628	public function getContainerAcl ( $ containerName = '' , $ signedIdentifiers = false ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'GET' , array ( ) , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } if ( $ signedIdentifiers == false ) { $ accessType = $ response -> getHeader ( Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ) ; if ( strtolower ( $ accessType ) == 'true' ) { $ accessType = self :: ACL_PUBLIC_CONTAINER ; } return $ accessType ; } $ result = $ this -> parseResponse ( $ response ) ; if ( ! $ result ) { return array ( ) ; } $ entries = null ; if ( $ result -> SignedIdentifier ) { if ( count ( $ result -> SignedIdentifier ) > 1 ) { $ entries = $ result -> SignedIdentifier ; } else { $ entries = array ( $ result -> SignedIdentifier ) ; } } $ returnValue = array ( ) ; foreach ( $ entries as $ entry ) { $ returnValue [ ] = new SignedIdentifier ( $ entry -> Id , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Start ? $ entry -> AccessPolicy -> Start : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Expiry ? $ entry -> AccessPolicy -> Expiry : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Permission ? $ entry -> AccessPolicy -> Permission : '' : '' ) ; } return $ returnValue ; }
5854	protected function persistFlexForm ( array & $ valueArray ) { foreach ( $ valueArray as $ key => $ value ) { if ( $ key === 'el' ) { foreach ( $ value as $ idx => $ v ) { if ( $ v && substr ( $ idx , 0 , 3 ) === 'ID-' ) { $ valueArray [ $ key ] [ substr ( $ idx , 3 ) ] = $ v ; unset ( $ valueArray [ $ key ] [ $ idx ] ) ; } } } elseif ( isset ( $ valueArray [ $ key ] ) ) { $ this -> persistFlexForm ( $ valueArray [ $ key ] ) ; } } }
8640	public function setShipmentItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11149	protected function process ( array $ requestParams ) { $ request = new ExtDirectRequest ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; $ response = new ExtDirectResponse ( ) ; $ requestParameters = new Parameters ( ) ; try { $ request -> setApplicationPath ( $ this -> getApplicationPath ( ) ) ; $ requestParameters -> setParameters ( $ requestParams ) ; $ request -> injectParameters ( $ requestParameters ) ; $ response -> injectParameters ( $ requestParameters ) ; $ request -> injectResponse ( $ response ) ; $ request -> setParamMethod ( $ this -> getParamMethod ( ) ) ; $ request -> setMethodCalls ( $ this -> getMethodsToCall ( ) ) ; $ request -> run ( ) ; } catch ( ExtDirectApplicationException $ e ) { $ result = $ e -> getResponse ( ) ; if ( ! empty ( $ result ) ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) , "actions" => $ result ) ) ; } else { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } } catch ( \ Exception $ e ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } return $ response ; }
10798	public function dateToSqlFormat ( $ dateString ) { $ dateFormatter = new \ IntlDateFormatter ( \ Locale :: getDefault ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , \ date_default_timezone_get ( ) , \ IntlDateFormatter :: GREGORIAN , "dd MMM yyyy" ) ; $ time = $ dateFormatter -> parse ( $ dateString ) ; $ date = new \ DateTime ( ) ; $ date -> setTimestamp ( $ time ) ; return $ date -> format ( 'Y-m-d' ) ; }
1476	public function createQueryValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ data , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) { return $ this -> invalidQueryParameter ( $ key , $ detail , $ failed ) ; } ) ; }
10508	private function registerChecker ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogChecker :: class , Utilities \ LogChecker :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.checker' , Contracts \ Utilities \ LogChecker :: class ) ; }
11568	public function count ( ) { if ( is_null ( $ this -> recordSet ) ) { $ this -> fetchData ( ) ; } if ( is_null ( $ this -> recordcount ) ) { $ this -> recordcount = $ this -> recordSet -> RecordCount ( ) ; } return $ this -> recordcount ; }
11975	private function secondParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( ! isset ( $ params [ 1 ] ) || ( is_numeric ( $ params [ 1 ] ) && $ params [ 1 ] >= 1 && $ params [ 1 ] <= $ this -> maxDieSides ) ) ; }
9013	public function mediumtext ( string $ charset = null ) : self { $ this -> type = 'mediumtext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
5323	public function registerHandler ( $ signal , $ handler ) { if ( ! is_callable ( $ handler ) ) { throw new \ InvalidArgumentException ( 'The handler is not callable' ) ; } if ( ! isset ( $ this -> handlers [ $ signal ] ) ) { $ this -> handlers [ $ signal ] = [ ] ; if ( ! pcntl_signal ( $ signal , [ $ this , 'handleSignal' ] ) ) { throw new \ RuntimeException ( sprintf ( 'Could not register signal %d with pcntl_signal' , $ signal ) ) ; } ; } ; $ this -> handlers [ $ signal ] [ ] = $ handler ; return $ this ; }
12056	public function getLabels ( ) { $ labels = [ ] ; $ labels [ 'delete_object' ] = [ 'short' => 'Delete ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'delete the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been deleted' , 'options' => [ 'class' => 'btn-danger' ] , 'response' => 'home' , ] ; $ labels [ 'archive_object' ] = [ 'short' => 'Archive ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'archive the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been archived' , 'response' => 'refresh' , ] ; $ labels [ 'unarchive_object' ] = [ 'short' => 'Unarchive ' . $ this -> object -> objectType -> title -> getSingular ( true ) , 'long' => 'unarchive the ' . $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em>' , 'past' => $ this -> object -> objectType -> title -> getSingular ( false ) . ' <em>' . $ this -> object -> descriptor . '</em> has been unarchived' , 'response' => 'refresh' , ] ; if ( isset ( $ this -> relationshipWith ) ) { $ labels [ 'delete_relationship' ] = [ 'short' => 'Delete Relationship' , 'long' => 'delete the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em>' , 'past' => 'the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em> has been deleted' , 'options' => [ 'class' => 'btn-warning' ] , ] ; $ labels [ 'end_relationship' ] = [ 'short' => 'End Relationship' , 'long' => 'end the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em>' , 'past' => 'the relationship between <em>' . $ this -> object -> descriptor . '</em> and <em>' . $ this -> relationshipWith -> descriptor . '</em> has been ended' , ] ; } return $ labels ; }
6850	public static function years ( $ start = false , $ end = false ) { $ start = ( $ start === false ) ? ( date ( 'Y' ) - 5 ) : ( int ) $ start ; $ end = ( $ end === false ) ? ( date ( 'Y' ) + 5 ) : ( int ) $ end ; $ years = array ( ) ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { $ years [ $ i ] = ( string ) $ i ; } return $ years ; }
5885	protected function renderDropdown ( ) { $ config = $ this -> dropdown ; $ config [ 'clientOptions' ] = false ; $ config [ 'view' ] = $ this -> getView ( ) ; return Dropdown :: widget ( $ config ) ; }
3177	public static function checkTimedSectionExit ( RunnerServiceContext $ context , $ nextPosition ) { $ timerConfig = $ context -> getTestConfig ( ) -> getConfigValue ( 'timer' ) ; if ( empty ( $ timerConfig [ 'keepUpToTimeout' ] ) ) { $ session = $ context -> getTestSession ( ) ; $ route = $ session -> getRoute ( ) ; $ section = $ session -> getCurrentAssessmentSection ( ) ; $ limits = $ section -> getTimeLimits ( ) ; if ( ! ( $ context instanceof QtiRunnerServiceContext ) || ! $ context -> isAdaptive ( ) ) { $ isJumpOutOfSection = false ; if ( ( $ nextPosition >= 0 ) && ( $ nextPosition < $ route -> count ( ) ) ) { $ nextSection = $ route -> getRouteItemAt ( $ nextPosition ) ; $ isJumpOutOfSection = ( $ section -> getIdentifier ( ) !== $ nextSection -> getAssessmentSection ( ) -> getIdentifier ( ) ) ; } if ( $ isJumpOutOfSection && $ limits != null && $ limits -> hasMaxTime ( ) ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; foreach ( $ assessmentItemRefs as $ assessmentItemRef ) { $ itemSessions = $ session -> getAssessmentItemSessions ( $ assessmentItemRef -> getIdentifier ( ) ) ; if ( $ itemSessions !== false ) { foreach ( $ itemSessions as $ itemSession ) { $ itemSession -> endItemSession ( ) ; } } } } } } }
5633	public function collect ( & $ test , $ path ) { $ path = $ this -> removeTrailingSlash ( $ path ) ; if ( $ handle = opendir ( $ path ) ) { while ( ( $ entry = readdir ( $ handle ) ) !== false ) { if ( $ this -> isHidden ( $ entry ) ) { continue ; } $ this -> handle ( $ test , $ path . DIRECTORY_SEPARATOR . $ entry ) ; } closedir ( $ handle ) ; } }
10205	public function setIndent ( $ pValue ) { if ( $ pValue > 0 ) { if ( $ this -> getHorizontal ( ) != self :: HORIZONTAL_GENERAL && $ this -> getHorizontal ( ) != self :: HORIZONTAL_LEFT && $ this -> getHorizontal ( ) != self :: HORIZONTAL_RIGHT ) { $ pValue = 0 ; } } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'indent' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> indent = $ pValue ; } return $ this ; }
4211	public static function getConstants ( $ phpVer = null ) { $ phpVer = $ phpVer ? : PHP_VERSION ; $ phpVer = \ preg_match ( '/^\d+\.\d+$/' , $ phpVer ) ? $ phpVer . '.0' : $ phpVer ; $ constants = array ( 'E_ERROR' => 1 , 'E_WARNING' => 2 , 'E_PARSE' => 4 , 'E_NOTICE' => 8 , 'E_CORE_ERROR' => 16 , 'E_CORE_WARNING' => 32 , 'E_COMPILE_ERROR' => 64 , 'E_COMPILE_WARNING' => 128 , 'E_USER_ERROR' => 256 , 'E_USER_WARNING' => 512 , 'E_USER_NOTICE' => 1024 , 'E_STRICT' => \ version_compare ( $ phpVer , '5.0.0' , '>=' ) ? 2048 : null , 'E_RECOVERABLE_ERROR' => \ version_compare ( $ phpVer , '5.2.0' , '>=' ) ? 4096 : null , 'E_DEPRECATED' => \ version_compare ( $ phpVer , '5.3.0' , '>=' ) ? 8192 : null , 'E_USER_DEPRECATED' => \ version_compare ( $ phpVer , '5.3.0' , '>=' ) ? 16384 : null , 'E_ALL' => null , ) ; $ constants = \ array_filter ( $ constants ) ; $ constants [ 'E_ALL' ] = \ array_sum ( $ constants ) ; if ( isset ( $ constants [ 'E_STRICT' ] ) && \ version_compare ( $ phpVer , '5.4.0' , '<' ) ) { $ constants [ 'E_ALL' ] -= $ constants [ 'E_STRICT' ] ; } return $ constants ; }
9424	public function write ( $ string ) { if ( ! $ this -> isWritable ( ) ) { $ message = 'Stream is not writable' ; throw new \ RuntimeException ( $ message ) ; } $ this -> size = null ; return fwrite ( $ this -> stream , $ string ) ; }
11644	protected function getConnection ( ) { $ connection = $ this -> getClient ( ) -> getConnection ( ) ; if ( $ connection instanceof ReplicationInterface ) { $ connection -> switchToMaster ( ) ; } return $ connection ; }
5572	public function authenticate ( $ username , $ password ) { if ( ! $ this -> page -> getRealm ( ) ) { return false ; } $ url = $ this -> page -> getUrl ( ) ; if ( ! $ url ) { return false ; } $ this -> user_agent -> setIdentity ( $ url -> getHost ( ) , $ this -> page -> getRealm ( ) , $ username , $ password ) ; return $ this -> retry ( ) ; }
1129	public function getLeftSibling ( ) { return $ this -> siblings ( ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getLeft ( ) ) -> orderBy ( $ this -> getOrderColumnName ( ) , 'desc' ) -> get ( ) -> last ( ) ; }
5836	public function handleRequest ( Request $ request ) : Promise { $ path = removeDotPathSegments ( $ request -> getUri ( ) -> getPath ( ) ) ; return new Coroutine ( ( $ fileInfo = $ this -> fetchCachedStat ( $ path , $ request ) ) ? $ this -> respondFromFileInfo ( $ fileInfo , $ request ) : $ this -> respondWithLookup ( $ this -> root . $ path , $ path , $ request ) ) ; }
4991	public function getEntity ( $ key = '*' ) { return isset ( $ this -> entities [ $ key ] ) ? $ this -> entities [ $ key ] : null ; }
7467	public function addColor ( $ color , $ code = null ) { $ newColors = $ this -> parseColor ( $ color , $ code ) ; $ this -> colors = array_merge ( $ this -> colors , $ newColors ) ; return $ this ; }
9151	public function getSelectOptions ( ) { $ filter = new UnderscoreToCamelCase ( ) ; $ funcName = "get" . ucfirst ( $ filter -> filter ( $ this -> getUserColumn ( ) ) ) ; $ resultSet = $ this -> fetchAll ( array ( 'user_id' , $ this -> getUserColumn ( ) ) , function ( Select $ select ) { $ select -> where -> notEqualTo ( 'user_id' , $ this -> getCurrentUser ( ) -> getId ( ) ) ; } ) ; $ options = array ( ) ; foreach ( $ resultSet as $ user ) { $ options [ $ user -> getId ( ) ] = $ user -> $ funcName ( ) ; } return $ options ; }
6423	public function isConfigured ( ) { if ( empty ( $ this -> options [ 'application_name' ] ) || empty ( $ this -> options [ 'client_id' ] ) || empty ( $ this -> options [ 'client_secret' ] ) ) { return false ; } return true ; }
5161	public function attach ( string $ field , Model $ item ) : self { $ this -> attachment [ $ field ] [ ] = $ item ; return $ this ; }
5166	protected function filterUriInstance ( $ uri ) : string { if ( $ uri instanceof UriInterface ) { return ( string ) $ uri ; } if ( is_string ( $ uri ) ) { return ( string ) \ One \ createUriFromString ( $ uri ) ; } return '' ; }
6992	static protected function getCacheKeyForOptimizedUiTemplatesBasedOnUserId ( $ group ) : string { if ( static :: getAuthModule ( ) -> getAccessPolicyClassName ( ) === CmfAccessPolicy :: class ) { $ userId = 'any' ; } else { $ user = static :: getUser ( ) ; $ userId = $ user ? $ user -> getAuthIdentifier ( ) : 'not_authenticated' ; } return static :: url_prefix ( ) . '_templates_' . static :: getShortLocale ( ) . '_' . $ group . '_user_' . $ userId ; }
9762	function empty ( ) : self { if ( is_object ( $ this -> target ) && ! ( $ this -> target instanceof \ Countable ) ) { $ constraint = countOf ( 0 ) ; $ target = get_object_vars ( $ this -> target ) ; } else if ( is_string ( $ this -> target ) ) { $ constraint = equalTo ( 0 ) ; $ target = $ this -> hasFlag ( 'file' ) ? @ filesize ( $ this -> target ) : mb_strlen ( $ this -> target ) ; } else { $ constraint = isEmpty ( ) ; $ target = $ this -> target ; } return $ this -> expect ( $ target , $ constraint ) ; }
7555	function match ( $ conditions , $ match = true , $ custom_filters = array ( ) ) { $ t = isset ( $ conditions [ 'tags' ] ) ; $ a = isset ( $ conditions [ 'attributes' ] ) ; $ f = isset ( $ conditions [ 'filters' ] ) ; if ( ! ( $ t || $ a || $ f ) ) { if ( is_array ( $ conditions ) && $ conditions ) { foreach ( $ conditions as $ c ) { if ( $ this -> match ( $ c , $ match ) ) { return true ; } } } return false ; } else { if ( ( $ t && ( ! $ this -> match_tags ( $ conditions [ 'tags' ] ) ) ) === $ match ) { return false ; } if ( ( $ a && ( ! $ this -> match_attributes ( $ conditions [ 'attributes' ] ) ) ) === $ match ) { return false ; } if ( ( $ f && ( ! $ this -> match_filters ( $ conditions [ 'filters' ] , $ custom_filters ) ) ) === $ match ) { return false ; } return true ; } }
8587	public function setLowestOfferListing ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LowestOfferListing' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4575	public function getCount ( Parameters $ parameters = null ) { $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ result = $ this -> execute ( 'GET' , static :: RESOURCE_COUNT , $ options ) ; return $ result -> count ; }
8922	public function apply ( $ targetDocument , $ patchDocument ) { if ( $ targetDocument === null || ! is_object ( $ targetDocument ) || is_array ( $ targetDocument ) ) { $ targetDocument = new \ stdClass ( ) ; } if ( $ patchDocument === null || ! is_object ( $ patchDocument ) || is_array ( $ patchDocument ) ) { return $ patchDocument ; } foreach ( $ patchDocument as $ key => $ value ) { if ( $ value === null ) { unset ( $ targetDocument -> $ key ) ; } else { if ( ! isset ( $ targetDocument -> $ key ) ) { $ targetDocument -> $ key = null ; } $ targetDocument -> $ key = $ this -> apply ( $ targetDocument -> $ key , $ value ) ; } } return $ targetDocument ; }
10184	function createContactFilter ( $ newFilterObject , $ createTargetGroup , $ version = 1.0 ) { if ( $ version == 1.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> put ( "contactfilters/contactfilter" , $ newFilterObject -> toXMLString ( ) , $ queryParameters ) ; } else if ( $ version == 2.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> post ( "contactfilters/v2" , $ newFilterObject , $ queryParameters , "application/json" ) ; } }
11664	public function isValid ( array $ values ) { $ this -> errorMessages = [ ] ; foreach ( $ this -> elements -> getElements ( ) as $ element ) { $ elementId = $ element -> getID ( ) ; if ( empty ( $ elementId ) ) { continue ; } $ value = null ; if ( array_key_exists ( $ elementId , $ values ) ) { $ value = $ values [ $ elementId ] ; } $ element -> setValue ( $ value ) ; $ this -> filterElement ( $ element ) ; $ this -> validateElement ( $ element ) ; } return count ( $ this -> errorMessages ) === 0 ; }
5667	public function getType ( $ value ) { if ( ! isset ( $ value ) ) { return 'Null' ; } elseif ( is_bool ( $ value ) ) { return 'Boolean' ; } elseif ( is_string ( $ value ) ) { return 'String' ; } elseif ( is_integer ( $ value ) ) { return 'Integer' ; } elseif ( is_float ( $ value ) ) { return 'Float' ; } elseif ( is_array ( $ value ) ) { return 'Array' ; } elseif ( is_resource ( $ value ) ) { return 'Resource' ; } elseif ( is_object ( $ value ) ) { return 'Object' ; } return 'Unknown' ; }
7748	private function isAccessible ( \ ReflectionClass $ class , $ methodName , $ parameters ) { if ( $ class -> hasMethod ( $ methodName ) ) { $ method = $ class -> getMethod ( $ methodName ) ; if ( $ method -> isPublic ( ) && $ method -> getNumberOfRequiredParameters ( ) === $ parameters ) { return true ; } } return false ; }
11731	protected function generateSlot ( $ path , $ blocks = array ( ) , $ username = null ) { if ( is_dir ( $ path ) && ! $ this -> override ) { return ; } $ folders = array ( ) ; $ activeDir = $ path . '/active' ; $ contributorsDir = $ path . '/contributors' ; $ folders [ ] = $ activeDir . '/blocks' ; $ folders [ ] = $ activeDir . '/archive' ; $ folders [ ] = $ contributorsDir ; $ targetDir = $ activeDir ; $ blocksDir = $ activeDir . '/blocks' ; if ( null !== $ username ) { $ targetDir = $ contributorsDir . '/' . $ username ; $ blocksDir = $ targetDir . '/blocks' ; $ folders [ ] = $ targetDir ; $ folders [ ] = $ targetDir . '/archive' ; $ folders [ ] = $ blocksDir ; } $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> generateBlocks ( $ blocks , $ blocksDir , $ targetDir ) ; }
8040	public function buildEventDates ( array $ data ) { $ dates = [ ] ; $ eventLength = $ this -> calculateEventLength ( $ data ) ; $ allDay = array_key_exists ( 'all_day' , $ data ) ; foreach ( $ data [ 'repeat_dates' ] as $ date ) { if ( strlen ( $ date ) > 0 ) { $ date = strtotime ( $ date . ' ' . $ data [ 'start' ] [ 'time' ] ) ; if ( false === $ date ) { throw new InvalidDateStringException ( 'Invalid date string!' ) ; } $ eventStart = $ this -> carbon -> copy ( ) -> setTimestamp ( $ date ) ; $ eventEnds = $ allDay ? null : $ eventStart -> copy ( ) -> addSeconds ( $ eventLength ) ; $ dates [ ] = [ 'start' => $ eventStart -> toDateTimeString ( ) , 'end' => ( null !== $ eventEnds ) ? $ eventEnds -> toDateTimeString ( ) : null , ] ; } } return $ dates ; }
6195	protected function findControllerFiles ( ) { $ result = [ ] ; foreach ( $ this -> controllerDirs as $ dir ) { $ directoryIterator = new \ RecursiveDirectoryIterator ( $ dir ) ; $ iterator = new \ RecursiveIteratorIterator ( $ directoryIterator ) ; $ files = new \ RegexIterator ( $ iterator , '/\.php$/i' , \ RecursiveRegexIterator :: GET_MATCH ) ; foreach ( $ files as $ k => $ v ) { $ result [ $ k ] = filemtime ( $ k ) ; } } return $ result ; }
1896	private function purgeOldFiles ( string $ webDir ) : void { if ( file_exists ( $ webDir . '/app_dev.php' ) ) { $ this -> fs -> remove ( $ webDir . '/app_dev.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/app_dev.php</comment> file.' ) ; } if ( file_exists ( $ webDir . '/install.php' ) ) { $ this -> fs -> remove ( $ webDir . '/install.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/install.php</comment> file.' ) ; } }
6415	public static function get ( IteratorAggregate $ iterable , int $ position ) { return Iterators :: get ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ position ) ; }
7346	static public function calculateReceivedQuantity ( SupplierOrderItemInterface $ item ) { $ quantity = 0 ; foreach ( $ item -> getOrder ( ) -> getDeliveries ( ) as $ delivery ) { foreach ( $ delivery -> getItems ( ) as $ deliveryItem ) { if ( $ item === $ deliveryItem -> getOrderItem ( ) ) { $ quantity += $ deliveryItem -> getQuantity ( ) ; continue 2 ; } } } return $ quantity ; }
4638	private function buildBody ( $ body , string $ charset ) : Mime \ Message { if ( $ body instanceof Mime \ Message ) { return $ body ; } if ( is_string ( $ body ) ) { $ mimePart = new Mime \ Part ( $ body ) ; $ mimePart -> type = $ body !== strip_tags ( $ body ) ? Mime \ Mime :: TYPE_HTML : Mime \ Mime :: TYPE_TEXT ; $ body = $ mimePart ; } $ body -> charset = $ charset ; $ message = new Mime \ Message ( ) ; $ message -> setParts ( [ $ body ] ) ; return $ message ; }
9640	protected function rebuildURL ( $ url ) { $ defaults = $ this -> config [ 'defaultparts' ] ; if ( ! preg_match ( '#^[a-zA-Z]+://#' , $ url ) ) { $ url = $ defaults [ 'scheme' ] . "://" . $ url ; } $ parts = parse_url ( $ url ) ; if ( ! $ parts ) { return "" ; } foreach ( $ parts as $ part => $ value ) { if ( $ this -> config [ 'removeparts' ] [ $ part ] === true ) { unset ( $ parts [ $ part ] ) ; } } foreach ( $ defaults as $ part => $ default ) { if ( ! isset ( $ parts [ $ part ] ) ) { $ parts [ $ part ] = $ default ; } } return rtrim ( http_build_url ( $ defaults , $ parts ) , "/" ) ; }
11358	public function removeBlock ( $ blockFile ) { foreach ( $ this -> permalinks as $ permalink => $ associatedBlocks ) { $ tmp = array_flip ( $ associatedBlocks ) ; unset ( $ tmp [ $ blockFile ] ) ; if ( empty ( $ tmp ) ) { unset ( $ this -> permalinks [ $ permalink ] ) ; continue ; } $ this -> permalinks [ $ permalink ] = array_flip ( $ tmp ) ; } return $ this ; }
12088	public function view ( UserPolicy $ user , Response $ response ) { if ( $ user -> canDo ( 'forum.response.view' ) && $ user -> isAdmin ( ) ) { return true ; } return $ response -> user_id == user_id ( ) && $ response -> user_type == user_type ( ) ; }
1908	private function getArgumentName ( Request $ request , ArgumentMetadata $ argument ) : ? string { if ( $ request -> attributes -> has ( $ argument -> getName ( ) ) ) { return $ argument -> getName ( ) ; } $ className = lcfirst ( $ this -> stripNamespace ( $ argument -> getType ( ) ) ) ; if ( $ request -> attributes -> has ( $ className ) ) { return $ className ; } return null ; }
11302	public function loadAll ( ) { $ this -> data -> id = $ this -> id ; foreach ( $ this -> model_attributes as $ key => $ value ) { $ temp = $ this -> $ key ; } }
3314	protected function request ( $ url , $ images , array $ options = [ ] , $ requestType = false ) { $ http = ( new Http ) -> setHeaders ( [ 'Authorization' => $ this -> authorization -> getAuthorization ( ) ] ) ; $ image = is_array ( $ images ) ? $ images [ 0 ] : $ images ; $ urlName = $ requestType ? 'url_list' : 'url' ; if ( FileConverter :: isUrl ( $ image ) ) { $ isurl = true ; } else { $ isurl = false ; $ multiparts [ 'image' ] [ ] = $ image ; } $ options = $ this -> appendAppIdAndBucketIfEmpty ( $ options ) ; try { if ( $ isurl ) { $ response = $ http -> json ( $ url , array_merge ( $ options , [ $ urlName => $ image ] ) ) ; } else { $ response = $ http -> upload ( $ url , $ multiparts , $ options ) ; } } catch ( \ GuzzleHttp \ Exception \ ClientException $ e ) { if ( $ e -> hasResponse ( ) ) { $ response = $ e -> getResponse ( ) ; } } return $ http -> parseJson ( $ response ) ; }
11078	public static function formatPhoneNumber ( $ phoneNumber , $ formatType = Tools :: PHONE_NUMBER_FORMAT_NUMBER ) { $ formatType = ( int ) $ formatType ; if ( $ formatType !== self :: PHONE_NUMBER_FORMAT_INTERNATIONAL && $ formatType !== self :: PHONE_NUMBER_FORMAT_INTERNATIONAL_NICE && $ formatType !== self :: PHONE_NUMBER_FORMAT_NUMBER && $ formatType !== self :: PHONE_NUMBER_FORMAT_NICE && $ formatType !== self :: PHONE_NUMBER_FORMAT_SMSTOOLS ) { return false ; } if ( ! Validate :: isPhoneNumber ( $ phoneNumber ) ) { return false ; } $ phoneNumber = self :: removeSpace ( $ phoneNumber ) ; $ phoneLen = \ strlen ( $ phoneNumber ) ; if ( $ phoneLen > 9 && 0 !== strpos ( $ phoneNumber , '+' ) ) { $ phoneNumber = '+' . $ phoneNumber ; $ phoneLen ++ ; } if ( $ phoneLen !== 9 && ! ( $ phoneLen >= 11 && $ phoneLen <= 13 && 0 === strpos ( $ phoneNumber , '+' ) ) ) { return false ; } $ international = ( $ phoneLen !== 9 ) ; switch ( $ formatType ) { case self :: PHONE_NUMBER_FORMAT_INTERNATIONAL_NICE : $ formattedPhone = preg_replace ( '/^(\+\d{1,3})(\d{3})(\d{3})(\d{3})$/' , '$1 $2 $3 $4' , $ international ? $ phoneNumber : '+420' . $ phoneNumber ) ; break ; case self :: PHONE_NUMBER_FORMAT_INTERNATIONAL : $ formattedPhone = $ international ? $ phoneNumber : '+420' . $ phoneNumber ; break ; case self :: PHONE_NUMBER_FORMAT_NICE : $ formattedPhone = preg_replace ( '/^(\+\d{1,3})(\d{3})(\d{3})(\d{3})$/' , '$2 $3 $4' , $ international ? $ phoneNumber : '+420' . $ phoneNumber ) ; break ; case self :: PHONE_NUMBER_FORMAT_NUMBER : $ formattedPhone = $ international ? substr ( $ phoneNumber , - 9 ) : $ phoneNumber ; break ; case self :: PHONE_NUMBER_FORMAT_SMSTOOLS : $ formattedPhone = $ international ? trim ( $ phoneNumber , '+' ) : '420' . $ phoneNumber ; break ; default : $ formattedPhone = false ; } return $ formattedPhone ; }
4253	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method == 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method == 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { if ( isset ( $ meta [ 'file' ] ) ) { $ args [ ] = $ meta [ 'file' ] . ': line ' . $ meta [ 'line' ] ; } } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ k => $ arg ) { $ args [ $ k ] = \ json_encode ( $ this -> dump ( $ arg ) ) ; } $ str = 'console.' . $ method . '(' . \ implode ( ',' , $ args ) . ');' . "\n" ; $ str = \ str_replace ( \ json_encode ( $ this -> debug -> abstracter -> UNDEFINED ) , 'undefined' , $ str ) ; return $ str ; }
1481	public function getDefaultCodec ( ) : Codec { return $ this -> factory -> createCodec ( $ this -> getContainer ( ) , $ this -> encodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ? : Encoding :: jsonApi ( ) , $ this -> decodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ) ; }
4481	public function setInterval ( int $ interval ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'interval' , $ interval ) ) { $ this -> interval = $ interval ; } }
9310	protected function doPostAction ( $ uri , array $ data = [ ] ) { $ this -> setActionUri ( $ uri ) ; try { $ response = $ this -> client -> post ( $ this -> uri , [ 'json' => $ data ] ) ; } catch ( ClientException $ e ) { $ response = $ e -> getResponse ( ) ; } catch ( ServerException $ e ) { $ response = $ e -> getResponse ( ) ; } return $ this -> responseToJson ( $ response ) ; }
2677	public function deleteAclItem ( $ aclId , $ aclItemId ) { $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry/' . $ aclItemId ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; }
9972	public function setCodeName ( $ pValue , $ validate = true ) { if ( $ this -> getCodeName ( ) == $ pValue ) { return $ this ; } if ( $ validate ) { $ pValue = str_replace ( ' ' , '_' , $ pValue ) ; self :: checkSheetCodeName ( $ pValue ) ; if ( $ this -> getParent ( ) ) { if ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue ) ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 29 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 29 ) ; } $ i = 1 ; while ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue . '_' . $ i ) ) { ++ $ i ; if ( $ i == 10 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 28 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 28 ) ; } } elseif ( $ i == 100 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 27 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 27 ) ; } } } $ pValue = $ pValue . '_' . $ i ; } } } $ this -> codeName = $ pValue ; return $ this ; }
1294	public static function create ( JsonDecoderClientInterface $ client , ClientOptions $ options ) : ResourcePoolInterface { if ( $ options -> usesLowMemoryResourcePool ( ) ) { return new Standard ( $ client -> getApi ( ) , $ client -> getSpaceId ( ) , $ client -> getEnvironmentId ( ) ) ; } return new Extended ( $ client , $ options -> getCacheItemPool ( ) , $ options -> hasCacheAutoWarmup ( ) , $ options -> hasCacheContent ( ) ) ; }
8126	protected function getSchemaResponse ( $ schemaID , $ form = null , ValidationResult $ errors = null , $ extraData = [ ] ) { $ parts = $ this -> owner -> getRequest ( ) -> getHeader ( LeftAndMain :: SCHEMA_HEADER ) ; $ data = $ this -> owner -> getFormSchema ( ) -> getMultipartSchema ( $ parts , $ schemaID , $ form , $ errors ) ; if ( $ extraData ) { $ data = array_merge ( $ data , $ extraData ) ; } $ response = HTTPResponse :: create ( Convert :: raw2json ( $ data ) ) ; $ response -> addHeader ( 'Content-Type' , 'application/json' ) ; return $ response ; }
421	public function init ( ) { parent :: init ( ) ; if ( strncmp ( $ this -> db -> driverName , 'oci' , 3 ) !== 0 && strncmp ( $ this -> db -> driverName , 'odbc' , 4 ) !== 0 ) { throw new InvalidConfigException ( 'In order to use OracleMutex connection must be configured to use Oracle database.' ) ; } }
4578	public function start ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_START ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_START_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_START_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' , 'Content-Type' => 'application/json' ] ] ; if ( $ parameters ) { $ parameters = ( array ) $ parameters -> toObject ( true ) ; foreach ( $ parameters as $ name => $ value ) { switch ( $ name ) { case 'variables' : foreach ( $ value as $ variable ) { $ options [ 'json' ] [ $ name ] [ $ variable -> name ] = [ 'value' => Variable :: TYPE_JSON === $ variable -> type ? json_encode ( $ variable -> value ) : $ variable -> value , 'type' => $ variable -> type ] ; } break ; case 'key' : break ; default : $ options [ 'json' ] [ $ name ] = $ value ; } } } $ object = $ this -> execute ( 'POST' , $ resource , $ options ) ; $ model = ProcessInstanceService :: toModel ( $ object ) ; return $ model ; }
3757	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; $ values = Helper :: decodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( unserialize ( $ values , [ 'allowed_classes' => false ] ) ) ; }
2684	private function _fetch ( $ uri , $ method = \ Zend_Http_Client :: GET , $ body = '' , $ test = false , $ testApiKey = null , $ logError = true ) { $ apiKey = ( $ test == true ) ? $ testApiKey : $ this -> config -> getApiKey ( ) ; if ( is_array ( $ body ) == true ) { $ body = http_build_query ( $ body ) ; } $ headers = [ self :: FASTLY_HEADER_AUTH . ': ' . $ apiKey , 'Accept: application/json' ] ; $ options = [ ] ; switch ( $ method ) { case \ Zend_Http_Client :: DELETE : $ options [ CURLOPT_CUSTOMREQUEST ] = \ Zend_Http_Client :: DELETE ; break ; case \ Zend_Http_Client :: PUT : $ headers [ ] = 'Content-Type: application/x-www-form-urlencoded' ; $ options [ CURLOPT_CUSTOMREQUEST ] = \ Zend_Http_Client :: PUT ; if ( $ body != '' ) { $ options [ CURLOPT_POSTFIELDS ] = $ body ; } break ; case \ Zend_Http_Client :: PATCH : $ options [ CURLOPT_CUSTOMREQUEST ] = \ Zend_Http_Client :: PATCH ; $ headers [ ] = 'Content-Type: text/json' ; if ( $ body != '' ) { $ options [ CURLOPT_POSTFIELDS ] = $ body ; } break ; } $ client = $ this -> curlFactory -> create ( ) ; $ client -> setOptions ( $ options ) ; $ client -> write ( $ method , $ uri , '1.1' , $ headers , $ body ) ; $ response = $ client -> read ( ) ; $ client -> close ( ) ; $ responseBody = \ Zend_Http_Response :: extractBody ( $ response ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; $ responseMessage = \ Zend_Http_Response :: extractMessage ( $ response ) ; if ( $ responseCode == '429' ) { throw new LocalizedException ( __ ( $ responseMessage ) ) ; } elseif ( $ responseCode != '200' ) { if ( $ logError == true ) { $ this -> logger -> critical ( 'Return status ' . $ responseCode , $ uri ) ; } return false ; } return json_decode ( $ responseBody ) ; }
6222	public function getElevation ( $ latitude , $ longitude ) { if ( $ latitude === 0.0 && $ longitude === 0.0 ) { return false ; } if ( ! $ this -> locationIsInBounds ( $ latitude , $ longitude ) ) { throw new InvalidArgumentException ( sprintf ( 'Location (%f, %f) is out of bounds ([-%f, %f], [-%f, %f]).' , $ latitude , $ longitude , static :: MAX_LATITUDE , static :: MAX_LATITUDE , static :: MAX_LONGITUDE , static :: MAX_LONGITUDE ) ) ; } $ filename = $ this -> getFilenameFor ( $ latitude , $ longitude ) ; if ( $ this -> CurrentFilename !== $ filename ) { $ this -> openResource ( $ filename ) ; } return $ this -> getElevationFromResource ( $ latitude , $ longitude ) ; }
11253	public function transaction ( callable $ callback ) : void { $ this -> pdo -> beginTransaction ( ) ; $ callback ( $ this ) ; $ this -> pdo -> commit ( ) ; }
5498	public function expectArguments ( $ method , $ args , $ message ) { $ args = $ this -> replaceWildcards ( $ args ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args [ strtolower ( $ method ) ] = new ParametersExpectation ( $ args , $ message ) ; }
4870	private function entityToString ( EntityInterface $ entity ) { if ( method_exists ( $ entity , '__toString' ) ) { return $ entity -> __toString ( ) ; } $ str = get_class ( $ entity ) ; if ( $ entity instanceof \ Core \ Entity \ IdentifiableEntityInterface ) { $ str .= '( ' . $ entity -> getId ( ) . ' )' ; } return $ str ; }
10664	public function withRequest ( RequestInterface $ request ) { $ object = clone $ this ; $ object -> request = $ request ; $ object -> method = $ request -> getMethod ( ) ; return $ object ; }
5158	public static function create ( array $ data ) : \ One \ Model \ Gallery { $ body = self :: validateString ( ( string ) self :: checkData ( $ data , 'body' , '' ) ) ; $ order = self :: validateInteger ( ( int ) self :: checkData ( $ data , 'order' , null ) ) ; $ photo = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'photo' , '' ) ) ; $ source = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'source' , '' ) ) ; $ lead = self :: validateString ( ( string ) self :: checkData ( $ data , 'lead' , '' ) ) ; return self :: createGallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
5750	public function setRoles ( ) { $ this -> roles = [ ] ; if ( null !== $ records = $ this -> select ( ) ) { foreach ( $ records as $ record ) { $ this -> roles [ ( int ) $ record [ 'id' ] ] = $ record [ 'role' ] ; } } }
9749	public function _calcSize ( & $ raList ) { list ( $ iSBDcnt , $ iBBcnt , $ iPPScnt ) = [ 0 , 0 , 0 ] ; $ iSmallLen = 0 ; $ iSBcnt = 0 ; $ iCount = count ( $ raList ) ; for ( $ i = 0 ; $ i < $ iCount ; ++ $ i ) { if ( $ raList [ $ i ] -> Type == OLE :: OLE_PPS_TYPE_FILE ) { $ raList [ $ i ] -> Size = $ raList [ $ i ] -> getDataLen ( ) ; if ( $ raList [ $ i ] -> Size < OLE :: OLE_DATA_SIZE_SMALL ) { $ iSBcnt += floor ( $ raList [ $ i ] -> Size / $ this -> smallBlockSize ) + ( ( $ raList [ $ i ] -> Size % $ this -> smallBlockSize ) ? 1 : 0 ) ; } else { $ iBBcnt += ( floor ( $ raList [ $ i ] -> Size / $ this -> bigBlockSize ) + ( ( $ raList [ $ i ] -> Size % $ this -> bigBlockSize ) ? 1 : 0 ) ) ; } } } $ iSmallLen = $ iSBcnt * $ this -> smallBlockSize ; $ iSlCnt = floor ( $ this -> bigBlockSize / OLE :: OLE_LONG_INT_SIZE ) ; $ iSBDcnt = floor ( $ iSBcnt / $ iSlCnt ) + ( ( $ iSBcnt % $ iSlCnt ) ? 1 : 0 ) ; $ iBBcnt += ( floor ( $ iSmallLen / $ this -> bigBlockSize ) + ( ( $ iSmallLen % $ this -> bigBlockSize ) ? 1 : 0 ) ) ; $ iCnt = count ( $ raList ) ; $ iBdCnt = $ this -> bigBlockSize / OLE :: OLE_PPS_SIZE ; $ iPPScnt = ( floor ( $ iCnt / $ iBdCnt ) + ( ( $ iCnt % $ iBdCnt ) ? 1 : 0 ) ) ; return [ $ iSBDcnt , $ iBBcnt , $ iPPScnt ] ; }
9835	public static function imagecreatefrombmp ( $ p_sFile ) { $ file = fopen ( $ p_sFile , 'rb' ) ; $ read = fread ( $ file , 10 ) ; while ( ! feof ( $ file ) && ( $ read != '' ) ) { $ read .= fread ( $ file , 1024 ) ; } $ temp = unpack ( 'H*' , $ read ) ; $ hex = $ temp [ 1 ] ; $ header = substr ( $ hex , 0 , 108 ) ; if ( substr ( $ header , 0 , 4 ) == '424d' ) { $ header_parts = str_split ( $ header , 2 ) ; $ width = hexdec ( $ header_parts [ 19 ] . $ header_parts [ 18 ] ) ; $ height = hexdec ( $ header_parts [ 23 ] . $ header_parts [ 22 ] ) ; unset ( $ header_parts ) ; } $ x = 0 ; $ y = 1 ; $ image = imagecreatetruecolor ( $ width , $ height ) ; $ body = substr ( $ hex , 108 ) ; $ body_size = ( strlen ( $ body ) / 2 ) ; $ header_size = ( $ width * $ height ) ; $ usePadding = ( $ body_size > ( $ header_size * 3 ) + 4 ) ; for ( $ i = 0 ; $ i < $ body_size ; $ i += 3 ) { if ( $ x >= $ width ) { if ( $ usePadding ) { $ i += $ width % 4 ; } $ x = 0 ; ++ $ y ; if ( $ y > $ height ) { break ; } } $ i_pos = $ i * 2 ; $ r = hexdec ( $ body [ $ i_pos + 4 ] . $ body [ $ i_pos + 5 ] ) ; $ g = hexdec ( $ body [ $ i_pos + 2 ] . $ body [ $ i_pos + 3 ] ) ; $ b = hexdec ( $ body [ $ i_pos ] . $ body [ $ i_pos + 1 ] ) ; $ color = imagecolorallocate ( $ image , $ r , $ g , $ b ) ; imagesetpixel ( $ image , $ x , $ height - $ y , $ color ) ; ++ $ x ; } unset ( $ body ) ; return $ image ; }
6954	private function getGridForCountry ( CountryInterface $ country ) { if ( isset ( $ this -> grids [ $ country -> getId ( ) ] ) ) { return $ this -> grids [ $ country -> getId ( ) ] ; } $ grid = [ ] ; $ prices = $ this -> priceRepository -> findByCountry ( $ country ) ; foreach ( $ prices as $ price ) { $ method = $ price -> getMethod ( ) ; if ( ! isset ( $ grid [ $ method -> getId ( ) ] ) ) { $ gateway = $ this -> gatewayRegistry -> getGateway ( $ method -> getGatewayName ( ) ) ; $ grid [ $ method -> getId ( ) ] = [ 'method' => $ method , 'max_weight' => $ gateway -> getMaxWeight ( ) , 'prices' => [ ] , ] ; } $ grid [ $ method -> getId ( ) ] [ 'prices' ] [ ] = [ 'weight' => $ price -> getWeight ( ) , 'price' => $ price -> getNetPrice ( ) , ] ; } foreach ( $ grid as & $ method ) { usort ( $ method [ 'prices' ] , function ( $ a , $ b ) { if ( 0 === bccomp ( $ a [ 'weight' ] , $ b [ 'weight' ] , 3 ) ) { return 0 ; } return $ a [ 'weight' ] > $ b [ 'weight' ] ? 1 : - 1 ; } ) ; $ max = end ( $ method [ 'prices' ] ) [ 'weight' ] ; if ( 0 == $ method [ 'max_weight' ] || $ method [ 'max_weight' ] > $ max ) { $ method [ 'max_weight' ] = $ max ; } unset ( $ method ) ; } return $ this -> grids [ $ country -> getId ( ) ] = $ grid ; }
10225	public function itemsFor ( $ model , $ items = null , $ targetUrl = null , $ nextPageUrl = null , $ offset = - 1 , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ items == null ) { $ items = call_user_func ( array ( $ modelName , 'simplePaginate' ) , 10 ) ; } $ factory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\ResourceItemsFactory' ) ; return $ factory -> create ( $ modelName , $ items , $ targetUrl , $ nextPageUrl , $ offset , $ config ) ; }
6234	protected function applyAccessMode ( int $ mode ) : void { if ( $ this -> mode === self :: MODE_CLOSED ) { $ this -> mode = $ mode ; return ; } elseif ( $ mode === $ this -> mode ) { return ; } throw new AccessDeniedException ( 'unable to switch access-mode for existing binary file handle' , 500 ) ; }
12430	public function sort ( $ key , $ order = Sortable :: ASC ) { $ this -> criteria -> sort ( $ key , $ order ) ; return $ this ; }
3104	public function save ( ) { $ storage = $ this -> getStorage ( ) ; if ( $ storage ) { $ success = $ storage -> set ( $ this -> userId , $ this -> getStorageKey ( ) , json_encode ( $ this -> state ) ) ; } else { $ success = false ; } return $ success ; }
1865	public function addSenderPlaceholder ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> pid ) { $ objChannel = $ this -> Database -> prepare ( "SELECT sender FROM tl_newsletter_channel WHERE id=?" ) -> execute ( $ dc -> activeRecord -> pid ) ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'placeholder' ] = $ objChannel -> sender ; } return $ varValue ; }
443	public function off ( $ name , $ handler = null ) { $ this -> ensureBehaviors ( ) ; if ( empty ( $ this -> _events [ $ name ] ) && empty ( $ this -> _eventWildcards [ $ name ] ) ) { return false ; } if ( $ handler === null ) { unset ( $ this -> _events [ $ name ] , $ this -> _eventWildcards [ $ name ] ) ; return true ; } $ removed = false ; if ( isset ( $ this -> _events [ $ name ] ) ) { foreach ( $ this -> _events [ $ name ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( $ this -> _events [ $ name ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { $ this -> _events [ $ name ] = array_values ( $ this -> _events [ $ name ] ) ; return $ removed ; } } if ( isset ( $ this -> _eventWildcards [ $ name ] ) ) { foreach ( $ this -> _eventWildcards [ $ name ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( $ this -> _eventWildcards [ $ name ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { $ this -> _eventWildcards [ $ name ] = array_values ( $ this -> _eventWildcards [ $ name ] ) ; if ( empty ( $ this -> _eventWildcards [ $ name ] ) ) { unset ( $ this -> _eventWildcards [ $ name ] ) ; } } } return $ removed ; }
4637	private function createMailEvent ( Email $ email , string $ name , ResultInterface $ result = null ) : MailEvent { $ event = new MailEvent ( $ email , $ name ) ; if ( $ result !== null ) { $ event -> setResult ( $ result ) ; } return $ event ; }
3942	private static function buildLanguageArray ( IMetaModel $ metaModel , TranslatorInterface $ translator ) { $ languages = array ( ) ; foreach ( ( array ) $ metaModel -> getAvailableLanguages ( ) as $ langCode ) { $ languages [ $ langCode ] = $ translator -> translate ( 'LNG.' . $ langCode , 'languages' ) ; } asort ( $ languages ) ; return $ languages ; }
11793	public function setCc ( $ mail = '' , $ name = null ) { $ this -> cc = Helper :: deduplicate ( array_merge ( $ this -> cc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
5698	public function baseTransform ( ) { parent :: baseTransform ( ) ; $ disabled = ( ! $ this -> gridFieldRequest -> getNextRecordID ( ) ) ; return $ this -> setDisabled ( $ disabled ) ; }
7236	private function phoneNumberCountry ( PhoneNumber $ phoneNumber = null ) { if ( $ phoneNumber ) { return $ this -> phoneNumberUtil -> getRegionCodeForNumber ( $ phoneNumber ) ; } return null ; }
8376	public function orderBy ( $ orderBy ) { if ( is_array ( $ orderBy ) === true ) { $ this -> orderBy = '' ; foreach ( $ orderBy as $ key => $ elem ) { $ this -> orderBy .= $ key . ' ' . $ elem . ', ' ; } $ this -> orderBy = substr ( $ this -> orderBy , 0 , - 2 ) ; } else { $ this -> orderBy = $ orderBy ; } return $ this ; }
6784	public function buildQueryString ( $ options ) { $ options = $ this -> resolve ( $ options ) ; foreach ( $ this -> formParameters as $ key => $ isFormParameter ) { if ( $ isFormParameter && isset ( $ options [ $ key ] ) ) { unset ( $ options [ $ key ] ) ; } } foreach ( $ this -> headerParameters as $ key => $ isHeaderParameter ) { if ( $ isHeaderParameter && isset ( $ options [ $ key ] ) ) { unset ( $ options [ $ key ] ) ; } } return http_build_query ( $ options ) ; }
2442	protected function getUser ( ) : BackendUser { if ( null === $ this -> tokenStorage ) { throw new \ RuntimeException ( 'No token storage provided' ) ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'No token provided' ) ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser ) { throw new \ RuntimeException ( 'The token does not contain a back end user object' ) ; } return $ user ; }
4470	public function complete ( ? string $ nextq = null , int $ delay = 0 , array $ depends = [ ] ) : string { if ( $ this -> completed || $ this -> failed ) { throw new JobAlreadyFinishedException ( ) ; } $ params = [ $ this -> jid , $ this -> worker , $ this -> queue , json_encode ( $ this -> data , JSON_UNESCAPED_SLASHES ) ? : '{}' ] ; if ( $ nextq ) { $ next = [ 'next' , $ nextq , 'delay' , $ delay , 'depends' , json_encode ( $ depends , JSON_UNESCAPED_SLASHES ) ] ; $ params = array_merge ( $ params , $ next ) ; } $ this -> completed = true ; return call_user_func_array ( [ $ this -> client , 'complete' ] , $ params ) ; }
4315	protected function getGroupDepth ( ) { $ depth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] as $ stack ) { $ depth += \ count ( $ stack ) ; } $ depth += \ count ( $ this -> data [ 'groupPriorityStack' ] ) ; return $ depth ; }
2784	private function indent ( $ output , $ asArray = false ) { $ lines = explode ( "\n" , $ output ) ; $ out = [ ] ; foreach ( $ lines as $ line ) { $ out [ ] = ' > ' . $ line ; } if ( $ asArray ) { return $ out ; } $ return = implode ( "\n" , $ out ) ; return $ return ; }
795	public function load ( $ data , $ formName = null ) { $ scope = $ formName === null ? $ this -> formName ( ) : $ formName ; if ( $ scope === '' && ! empty ( $ data ) ) { $ this -> setAttributes ( $ data ) ; return true ; } elseif ( isset ( $ data [ $ scope ] ) ) { $ this -> setAttributes ( $ data [ $ scope ] ) ; return true ; } return false ; }
6342	final public static function valueOf ( $ name ) : self { $ className = static :: class ; Preconditions :: checkArgument ( array_key_exists ( $ className , self :: $ cache ) && array_key_exists ( $ name , self :: $ cache [ $ className ] ) , "The enum '%s' type has no constant with name '%s'" , $ className , $ name ) ; return self :: $ cache [ $ className ] [ $ name ] ; }
8777	public function assets ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . ASSETS_FOLDER . '/' . $ data : $ this -> url . '/' . ASSETS_FOLDER . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
10856	public function has ( string $ typeName ) : bool { if ( isset ( $ this -> shared [ $ typeName ] ) || isset ( $ this -> definitions [ $ typeName ] ) ) { return true ; } if ( ! isset ( $ this -> typeCache [ $ typeName ] ) ) { if ( \ class_exists ( $ typeName ) || \ interface_exists ( $ typeName , false ) ) { $ this -> typeCache [ $ typeName ] = new \ ReflectionClass ( $ typeName ) ; } else { $ this -> typeCache [ $ typeName ] = false ; } } return $ this -> typeCache [ $ typeName ] !== false && $ this -> typeCache [ $ typeName ] -> isInstantiable ( ) ; }
5823	private function resolveOptions ( array $ options = array ( ) ) { $ this -> options [ 'alertPublisher' ] = $ this -> alertPublisher ; return array_merge ( $ this -> options , $ options ) ; }
6804	public function installCustomerGroups ( ) { $ groups = ( array ) $ this -> customerGroupRepository -> findBy ( [ ] , [ ] , 1 ) -> getIterator ( ) ; if ( ! empty ( $ groups ) ) { call_user_func ( $ this -> log , 'All' , 'skipped' ) ; return ; } $ groups = [ 'Particuliers' => [ 'default' => true , 'business' => false , 'registration' => true , ] , 'Entreprise' => [ 'default' => false , 'business' => true , 'registration' => true , ] , ] ; foreach ( $ groups as $ name => $ config ) { $ result = 'already exists' ; if ( null === $ this -> customerGroupRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ customerGroup = $ this -> customerGroupRepository -> createNew ( ) ; $ customerGroup -> setName ( $ name ) -> setDefault ( $ config [ 'default' ] ) -> setBusiness ( $ config [ 'business' ] ) -> setRegistration ( $ config [ 'registration' ] ) -> translate ( ) -> setTitle ( $ name ) ; $ this -> manager -> persist ( $ customerGroup ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } $ this -> manager -> flush ( ) ; }
6726	public function get_movie_votes ( $ post_id ) { $ votes = get_post_meta ( $ post_id , 'imdbTotalVotes' , true ) ; if ( ! empty ( $ votes ) ) { return json_decode ( $ votes , true ) ; } return false ; }
11775	protected function getIsEnabled ( ) : \ Illuminate \ Database \ Eloquent \ Model { $ result = Model \ Setting :: find ( 1 ) ; $ result -> value = ( bool ) $ result -> value ; return $ result ; }
1442	protected function replaceRecord ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'DummyRecord' , Str :: classify ( str_singular ( $ resource ) ) , $ stub ) ; return $ this ; }
3115	public function storeItemHrefIndex ( $ testSessionId , $ table ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setItemHrefIndex ( $ table ) ; $ extendedState -> save ( ) ; }
5570	public function retry ( ) { $ frames = $ this -> page -> getFrameFocus ( ) ; if ( count ( $ frames ) > 0 ) { $ this -> loadFrame ( $ frames , $ this -> page -> getUrl ( ) , $ this -> page -> getRequestData ( ) ) ; return $ this -> page -> getRaw ( ) ; } if ( $ url = $ this -> history -> getUrl ( ) ) { $ this -> page = $ this -> fetch ( $ url , $ this -> history -> getParameters ( ) ) ; return $ this -> page -> getRaw ( ) ; } return false ; }
10181	public function add ( $ pCoord , Cell $ cell ) { if ( $ pCoord !== $ this -> currentCoordinate ) { $ this -> storeCurrentCell ( ) ; } $ this -> index [ $ pCoord ] = true ; $ this -> currentCoordinate = $ pCoord ; $ this -> currentCell = $ cell ; $ this -> currentCellIsDirty = true ; return $ cell ; }
3340	public function getFilesChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'file_list' , 'GET' , $ options ) ; $ files_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ resultArr [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; }
9552	public function allowMimeTypes ( $ mimeTypes ) { if ( ! is_array ( $ mimeTypes ) ) { $ mimeTypes = [ $ mimeTypes ] ; } $ this -> constraints [ ] = new MimeTypeConstraint ( $ mimeTypes ) ; return $ this ; }
3203	protected function validate_css_property_value ( $ value , $ compare_type , $ compare_value ) { switch ( $ compare_type ) { case '!=' : return $ value !== $ compare_value ; case '>' : return $ value > $ compare_value ; default : return false ; } }
8311	public function applyDefaults ( $ config , array $ defaults , $ depth = 1 ) { if ( ! is_int ( $ depth ) || $ depth < 0 ) { throw new \ InvalidArgumentException ( "Depth must be non-negative integer." ) ; } if ( ! is_array ( $ config ) ) { return $ defaults ; } if ( $ depth === 0 ) { $ config += $ defaults ; return $ config ; } foreach ( $ defaults as $ key => $ defaultValue ) { if ( ! isset ( $ config [ $ key ] ) ) { $ config [ $ key ] = $ defaultValue ; continue ; } if ( is_array ( $ defaultValue ) ) { if ( is_array ( $ config [ $ key ] ) ) { $ config [ $ key ] = $ this -> applyDefaults ( $ config [ $ key ] , $ defaultValue , $ depth - 1 ) ; } else { throw new ConfigurationException ( "Configuration key " . $ key . " expects an array, a scalar value found." ) ; } } else { if ( is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( "Configuration key " . $ key . " expects scalar, an array found." ) ; } } } return $ config ; }
10079	public static function strCaseReverse ( $ pValue ) { $ characters = self :: mbStrSplit ( $ pValue ) ; foreach ( $ characters as & $ character ) { if ( self :: mbIsUpper ( $ character ) ) { $ character = mb_strtolower ( $ character , 'UTF-8' ) ; } else { $ character = mb_strtoupper ( $ character , 'UTF-8' ) ; } } return implode ( '' , $ characters ) ; }
89	public function write ( array $ hash , $ options = 448 ) { $ dir = dirname ( $ this -> path ) ; if ( ! is_dir ( $ dir ) ) { if ( file_exists ( $ dir ) ) { throw new \ UnexpectedValueException ( $ dir . ' exists and is not a directory.' ) ; } if ( ! @ mkdir ( $ dir , 0777 , true ) ) { throw new \ UnexpectedValueException ( $ dir . ' does not exist and could not be created.' ) ; } } $ retries = 3 ; while ( $ retries -- ) { try { file_put_contents ( $ this -> path , static :: encode ( $ hash , $ options ) . ( $ options & self :: JSON_PRETTY_PRINT ? "\n" : '' ) ) ; break ; } catch ( \ Exception $ e ) { if ( $ retries ) { usleep ( 500000 ) ; continue ; } throw $ e ; } } }
1670	public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new self ( $ strParent ) ; } $ return = $ this -> Files -> rename ( $ this -> strFolder , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { $ this -> objModel = Dbafs :: moveResource ( $ this -> strFolder , $ strNewName ) ; } elseif ( $ syncSource ) { $ this -> objModel = Dbafs :: deleteResource ( $ this -> strFolder ) ; } elseif ( $ syncTarget ) { $ this -> objModel = Dbafs :: addResource ( $ strNewName ) ; } if ( $ return != false ) { $ this -> strFolder = $ strNewName ; } return $ return ; }
4448	public function put ( string $ className , array $ data , ? string $ jid = null , ? int $ delay = null , ? int $ retries = null , ? int $ priority = null , ? array $ tags = null , ? array $ depends = null ) { try { $ jid = $ jid ? : str_replace ( '-' , '' , Uuid :: uuid4 ( ) -> toString ( ) ) ; } catch ( \ Exception $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } $ data = new JobData ( $ data ) ; $ this -> getEventsManager ( ) -> fire ( new QueueEvent \ BeforeEnqueue ( $ this , $ jid , $ data , $ className ) ) ; if ( ! $ putData = json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ) { throw new RuntimeException ( sprintf ( 'Unable to encode payload to put the described job "%s" to the "%s" queue.' , $ jid , $ this -> name ) ) ; } $ jid = $ this -> client -> put ( '' , $ this -> name , $ jid , $ className , $ putData , is_null ( $ delay ) ? 0 : $ delay , 'priority' , is_null ( $ priority ) ? 0 : $ priority , 'tags' , json_encode ( $ tags ? : [ ] , JSON_UNESCAPED_SLASHES ) , 'retries' , is_null ( $ retries ) ? 5 : $ retries , 'depends' , json_encode ( $ depends ? : [ ] , JSON_UNESCAPED_SLASHES ) ) ; $ this -> getEventsManager ( ) -> fire ( new QueueEvent \ AfterEnqueue ( $ this , $ jid , $ data -> toArray ( ) , $ className ) ) ; return $ jid ; }
11670	public function getClientBy ( $ selector , $ value , $ callable = null ) { $ selector = strtolower ( $ selector ) ; if ( ! in_array ( $ selector , array ( 'id' , 'key' , 'slot' , 'role' , 'alias' , 'command' ) ) ) { throw new \ InvalidArgumentException ( "Invalid selector type: `$selector`" ) ; } if ( ! method_exists ( $ this -> connection , $ method = "getConnectionBy$selector" ) ) { $ class = get_class ( $ this -> connection ) ; throw new \ InvalidArgumentException ( "Selecting connection by $selector is not supported by $class" ) ; } if ( ! $ connection = $ this -> connection -> $ method ( $ value ) ) { throw new \ InvalidArgumentException ( "Cannot find a connection by $selector matching `$value`" ) ; } $ client = new static ( $ connection , $ this -> getOptions ( ) ) ; if ( $ callable ) { return call_user_func ( $ callable , $ client ) ; } else { return $ client ; } }
6527	public static function resolveCurie ( $ curie ) : string { $ key = ( string ) $ curie ; if ( isset ( self :: $ curies [ $ key ] ) ) { return self :: $ classes [ self :: $ curies [ $ key ] ] ; } throw new NoMessageForCurie ( SchemaCurie :: fromString ( $ key ) ) ; }
7938	public function getBackupFTPaccessBlock ( $ domain , $ ipBlock ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; try { $ r = $ this -> get ( 'dedicated/server/' . $ domain . '/features/backupFTP/access/' . urlencode ( $ ipBlock ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
9678	public function allNumberFormats ( Spreadsheet $ spreadsheet ) { $ aNumFmts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false && ! isset ( $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] ) ) { $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] = $ style -> getNumberFormat ( ) ; } } return $ aNumFmts ; }
3590	public function allowsMeta ( $ key ) { $ allowed = $ this -> getAllowedMeta ( ) ; return empty ( $ allowed ) || in_array ( $ key , $ allowed ) ; }
901	public function getMethodAttributes ( $ index ) { $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_FUNCTION ) ) { throw new \ LogicException ( sprintf ( 'No T_FUNCTION at given index %d, got %s.' , $ index , $ token -> getName ( ) ) ) ; } $ attributes = [ 'visibility' => null , 'static' => false , 'abstract' => false , 'final' => false , ] ; for ( $ i = $ index ; $ i >= 0 ; -- $ i ) { $ tokenIndex = $ tokens -> getPrevMeaningfulToken ( $ i ) ; $ i = $ tokenIndex ; $ token = $ tokens [ $ tokenIndex ] ; if ( $ token -> isGivenKind ( T_STATIC ) ) { $ attributes [ 'static' ] = true ; continue ; } if ( $ token -> isGivenKind ( T_FINAL ) ) { $ attributes [ 'final' ] = true ; continue ; } if ( $ token -> isGivenKind ( T_ABSTRACT ) ) { $ attributes [ 'abstract' ] = true ; continue ; } if ( $ token -> isGivenKind ( T_PRIVATE ) ) { $ attributes [ 'visibility' ] = T_PRIVATE ; continue ; } if ( $ token -> isGivenKind ( T_PROTECTED ) ) { $ attributes [ 'visibility' ] = T_PROTECTED ; continue ; } if ( $ token -> isGivenKind ( T_PUBLIC ) ) { $ attributes [ 'visibility' ] = T_PUBLIC ; continue ; } break ; } return $ attributes ; }
10732	public function getSecond ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'second' ] ; } }
886	private function clear ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ ++ $ index ] -> equals ( ';' ) ) { if ( $ this -> shouldClearToken ( $ tokens , $ index ) ) { $ tokens -> clearAt ( $ index ) ; } } }
1747	public function getCalendars ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> calendars ) ) { return array ( ) ; } $ arrCalendars = array ( ) ; $ objCalendars = $ this -> Database -> execute ( "SELECT id, title FROM tl_calendar ORDER BY title" ) ; while ( $ objCalendars -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objCalendars -> id , 'calendars' ) ) { $ arrCalendars [ $ objCalendars -> id ] = $ objCalendars -> title ; } } return $ arrCalendars ; }
10485	protected function getTableMapping ( $ table ) { if ( array_key_exists ( $ table , $ this -> mappings ) ) { return $ this -> mappings [ $ table ] ; } $ mapping = $ this -> retrieveMapping ( $ table ) ; if ( empty ( $ mapping ) ) { throw new \ UnderflowException ( "Table with name {$table} not found." ) ; } $ this -> mappings [ $ table ] = $ mapping ; return $ mapping ; }
6697	public function isMethodHidden ( $ methodName ) { if ( ! method_exists ( $ this , $ methodName ) ) { throw new Exception ( 500 , "The method '$methodName' does not exist in " . get_called_class ( ) ) ; } return isset ( $ this -> hiddenMethods [ $ methodName ] ) ; }
10210	public function createAction ( ) { $ request = $ this -> getRequest ( ) ; $ prg = $ this -> prg ( $ request -> getRequestUri ( ) , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } elseif ( $ prg === false ) { return $ this -> viewModel ; } if ( $ this -> contactForm -> setData ( $ prg ) -> isValid ( ) ) { $ contact = $ this -> contactForm -> getData ( ) ; $ this -> commandService -> persist ( $ contact ) ; $ this -> viewModel -> setVariable ( 'contact' , $ contact ) ; } return $ this -> viewModel ; }
5905	public function retrieveRole ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/roles/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Role ( $ result ) ; return $ result ; }
424	protected function adjustLabelFor ( $ options ) { if ( ! isset ( $ options [ 'id' ] ) ) { return ; } $ this -> _inputId = $ options [ 'id' ] ; if ( ! isset ( $ this -> labelOptions [ 'for' ] ) ) { $ this -> labelOptions [ 'for' ] = $ options [ 'id' ] ; } }
321	public function normalizePathInfo ( $ pathInfo , $ suffix , & $ normalized = false ) { if ( empty ( $ pathInfo ) ) { return $ pathInfo ; } $ sourcePathInfo = $ pathInfo ; if ( $ this -> collapseSlashes ) { $ pathInfo = $ this -> collapseSlashes ( $ pathInfo ) ; } if ( $ this -> normalizeTrailingSlash === true ) { $ pathInfo = $ this -> normalizeTrailingSlash ( $ pathInfo , $ suffix ) ; } $ normalized = $ sourcePathInfo !== $ pathInfo ; return $ pathInfo ; }
11655	private function _parseDsn ( $ dsn ) { $ dsn = parse_url ( $ dsn ) ; $ cfg = [ ] ; if ( isset ( $ dsn [ 'port' ] ) ) { $ cfg [ 'port' ] = $ dsn [ 'port' ] ; } return $ cfg + [ 'dbname' => isset ( $ dsn [ 'path' ] ) ? trim ( $ dsn [ 'path' ] , '/' ) : null , 'host' => isset ( $ dsn [ 'host' ] ) ? $ dsn [ 'host' ] : null , 'password' => isset ( $ dsn [ 'pass' ] ) ? $ dsn [ 'pass' ] : null , 'username' => isset ( $ dsn [ 'user' ] ) ? $ dsn [ 'user' ] : null , ] ; }
8740	public function i18nQuery ( ) { $ query = $ this -> getModel ( ) -> newQueryWithoutScopes ( ) -> getQuery ( ) ; $ query -> from ( $ this -> model -> getI18nTable ( ) ) ; return $ query ; }
8614	public function setFeedSubmissionInfoList ( $ feedSubmissionInfo ) { if ( ! $ this -> _isNumericArray ( $ feedSubmissionInfo ) ) { $ feedSubmissionInfo = array ( $ feedSubmissionInfo ) ; } $ this -> fields [ 'FeedSubmissionInfo' ] [ 'FieldValue' ] = $ feedSubmissionInfo ; return $ this ; }
12801	public function createItem ( $ name , array $ options = array ( ) ) { if ( ! empty ( $ options [ 'admin' ] ) ) { $ admin = $ options [ 'admin' ] ; if ( ! $ options [ 'admin' ] instanceof AdminInterface ) { $ admin = $ this -> container -> get ( 'sonata.admin.pool' ) -> getAdminByAdminCode ( $ admin ) ; } $ action = isset ( $ options [ 'admin_action' ] ) ? $ options [ 'admin_action' ] : 'list' ; $ options [ 'uri' ] = $ admin -> generateUrl ( $ action ) ; $ options [ 'translationDomain' ] = $ admin -> getTranslationDomain ( ) ; } if ( ! empty ( $ options [ 'route' ] ) ) { $ params = isset ( $ options [ 'routeParameters' ] ) ? $ options [ 'routeParameters' ] : array ( ) ; $ absolute = isset ( $ options [ 'routeAbsolute' ] ) ? $ options [ 'routeAbsolute' ] : false ; $ options [ 'uri' ] = $ this -> generator -> generate ( $ options [ 'route' ] , $ params , $ absolute ) ; } $ item = new MenuItem ( $ name , $ this ) ; $ options = array_merge ( array ( 'uri' => null , 'label' => null , 'attributes' => array ( ) , 'linkAttributes' => array ( ) , 'childrenAttributes' => array ( ) , 'labelAttributes' => array ( ) , 'extras' => array ( ) , 'display' => true , 'displayChildren' => true , 'translationDomain' => 'messages' , 'displayLink' => true , 'displayLabel' => true , ) , $ options ) ; $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setExtras ( $ options [ 'extras' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) -> setTranslationDomain ( $ options [ 'translationDomain' ] ) -> setDisplayLink ( $ options [ 'displayLink' ] ) -> setDisplayLabel ( $ options [ 'displayLabel' ] ) ; return $ item ; return parent :: createItem ( $ name , $ options ) ; }
11889	public function paginate ( ) { $ model = $ this -> model ; if ( property_exists ( $ model , 'order' ) ) { $ paginator = $ model :: orderBy ( $ model :: $ order , $ model :: $ sort ) -> paginate ( $ model :: $ paginate , $ model :: $ index ) ; } else { $ paginator = $ model :: paginate ( $ model :: $ paginate , $ model :: $ index ) ; } if ( ! $ this -> isPageInRange ( $ paginator ) && ! $ this -> isFirstPage ( $ paginator ) ) { throw new NotFoundHttpException ( ) ; } if ( $ paginator -> getTotal ( ) ) { $ this -> paginateLinks = $ paginator -> links ( ) ; } return $ paginator ; }
1306	public function destroy ( $ id , Request $ request ) { $ post = Models :: post ( ) -> with ( 'discussion' ) -> findOrFail ( $ id ) ; if ( $ request -> user ( ) -> id !== ( int ) $ post -> user_id ) { return redirect ( '/' . config ( 'chatter.routes.home' ) ) -> with ( [ 'chatter_alert_type' => 'danger' , 'chatter_alert' => trans ( 'chatter::alert.danger.reason.destroy_post' ) , ] ) ; } if ( $ post -> discussion -> posts ( ) -> oldest ( ) -> first ( ) -> id === $ post -> id ) { if ( config ( 'chatter.soft_deletes' ) ) { $ post -> discussion -> posts ( ) -> delete ( ) ; $ post -> discussion ( ) -> delete ( ) ; } else { $ post -> discussion -> posts ( ) -> forceDelete ( ) ; $ post -> discussion ( ) -> forceDelete ( ) ; } return redirect ( '/' . config ( 'chatter.routes.home' ) ) -> with ( [ 'chatter_alert_type' => 'success' , 'chatter_alert' => trans ( 'chatter::alert.success.reason.destroy_post' ) , ] ) ; } $ post -> delete ( ) ; $ url = '/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.discussion' ) . '/' . $ post -> discussion -> category -> slug . '/' . $ post -> discussion -> slug ; return redirect ( $ url ) -> with ( [ 'chatter_alert_type' => 'success' , 'chatter_alert' => trans ( 'chatter::alert.success.reason.destroy_from_discussion' ) , ] ) ; }
9357	public function withoutHeader ( $ name ) { $ instance = clone $ this ; if ( $ this -> hasHeader ( $ name ) ) { $ static = clone $ this ; unset ( $ static -> headers [ $ name ] ) ; $ instance = $ static ; } return $ instance ; }
9683	public function getCountryName ( $ code ) { $ name = Intl :: getRegionBundle ( ) -> getCountryName ( strtoupper ( $ code ) , $ this -> getRequest ( ) -> getLanguageCode ( ) ? : 'en' ) ; if ( $ name ) { return $ name ; } return $ code ; }
6318	public function query ( $ sql ) { $ rows = array ( ) ; foreach ( $ this -> getConnection ( ) -> query ( $ sql ) as $ row ) { $ rows [ ] = $ row ; } return $ rows ; }
12461	private function createMakeDefaultForm ( CustomFieldsGroup $ group = null ) { return $ this -> createFormBuilder ( $ group , array ( 'method' => 'POST' , 'action' => $ this -> generateUrl ( 'customfieldsgroup_makedefault' ) ) ) -> add ( 'id' , 'hidden' ) -> add ( 'submit' , 'submit' , array ( 'label' => 'Make default' ) ) -> getForm ( ) ; }
7018	private function format_h ( & $ str ) { if ( strstr ( $ str , '%h' ) ) { $ h = $ this -> hour > 12 ? $ this -> hour - 12 : $ this -> hour ; $ str = str_replace ( '%h' , sprintf ( '%02d' , $ h ) , $ str ) ; } }
4016	protected function getWidgetClass ( $ field ) { $ className = $ GLOBALS [ ( TL_MODE == 'BE' ? 'BE_FFL' : 'TL_FFL' ) ] [ $ field [ 'inputType' ] ] ; if ( ( $ className !== '' ) && class_exists ( $ className ) ) { return $ className ; } return null ; }
3918	private function checkDownloads ( ) { if ( $ this -> getShowImages ( ) ) { return ; } if ( ( $ file = Input :: get ( 'file' ) ) && ( $ key = Input :: get ( 'fileKey' ) ) ) { if ( ! ( array_key_exists ( $ file , $ _SESSION [ 'metaModels_downloads' ] ) && $ _SESSION [ 'metaModels_downloads' ] [ $ file ] === $ key ) ) { $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_403' ] ( ) ; $ objHandler -> generate ( $ file ) ; } Controller :: sendFileToBrowser ( $ file ) ; } }
3928	private function getOptionsViaDcGeneral ( $ metaModel , $ environment , $ attribute ) { $ factory = DcGeneralFactory :: deriveEmptyFromEnvironment ( $ environment ) -> setContainerName ( $ metaModel -> getTableName ( ) ) ; $ dcGeneral = $ factory -> createDcGeneral ( ) ; $ subEnv = $ dcGeneral -> getEnvironment ( ) ; $ optEv = new GetPropertyOptionsEvent ( $ subEnv , $ subEnv -> getDataProvider ( ) -> getEmptyModel ( ) ) ; $ optEv -> setPropertyName ( $ attribute -> getColName ( ) ) ; $ subEnv -> getEventDispatcher ( ) -> dispatch ( GetPropertyOptionsEvent :: NAME , $ optEv ) ; $ options = $ optEv -> getOptions ( ) ; return $ options ; }
7607	public function renderToggle ( array $ aDropdownOptions ) { if ( empty ( $ aDropdownOptions [ 'label' ] ) ) { $ aDropdownOptions [ 'label' ] = '' ; } elseif ( ! is_scalar ( $ aDropdownOptions [ 'label' ] ) ) { throw new InvalidArgumentException ( '"label" option expects a scalar value, "' . gettype ( $ aDropdownOptions [ 'label' ] ) . '" given' ) ; } elseif ( ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ aDropdownOptions [ 'label' ] = $ oTranslator -> translate ( $ aDropdownOptions [ 'label' ] , $ this -> getTranslatorTextDomain ( ) ) ; } if ( empty ( $ aDropdownOptions [ 'toggle_attributes' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] = array ( 'class' => 'sr-only dropdown-toggle' ) ; } else { if ( ! is_array ( $ aDropdownOptions [ 'toggle_attributes' ] ) ) { throw new InvalidArgumentException ( '"toggle_attributes" option expects an array, "' . gettype ( $ aDropdownOptions [ 'toggle_attributes' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'toggle_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'class' ] = 'sr-only dropdown-toggle' ; } else { if ( ! preg_match ( '/(\s|^)sr-only(\s|$)/' , $ aDropdownOptions [ 'toggle_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'class' ] .= ' sr-only' ; } if ( ! preg_match ( '/(\s|^)dropdown-toggle(\s|$)/' , $ aDropdownOptions [ 'toggle_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'class' ] .= ' dropdown-toggle' ; } } } if ( empty ( $ aDropdownOptions [ 'toggle_attributes' ] [ 'data-toggle' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'data-toggle' ] = 'dropdown' ; } if ( empty ( $ aDropdownOptions [ 'toggle_attributes' ] [ 'role' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'role' ] = 'button' ; } if ( empty ( $ aDropdownOptions [ 'toggle_attributes' ] [ 'href' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'href' ] = '#' ; } if ( ! empty ( $ aDropdownOptions [ 'name' ] ) ) { $ aDropdownOptions [ 'toggle_attributes' ] [ 'id' ] = $ aDropdownOptions [ 'name' ] ; } $ aValidTagAttributes = $ this -> validTagAttributes ; $ this -> validTagAttributes = array ( 'href' => true ) ; $ sAttributeString = $ this -> createAttributesString ( $ aDropdownOptions [ 'toggle_attributes' ] ) ; $ this -> validTagAttributes = $ aValidTagAttributes ; return sprintf ( static :: $ dropdownToggleFormat , $ sAttributeString , $ this -> getEscapeHtmlHelper ( ) -> __invoke ( $ aDropdownOptions [ 'label' ] ) ) ; }
7989	public function getTemplateProperties ( $ domain , $ templateId ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ templateId = ( string ) $ templateId ; if ( ! $ templateId ) throw new BadMethodCallException ( "Parameter $templateId is missing" ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/templates/' . $ templateId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( ) ; }
11637	public function getTableRegistry ( ) { if ( is_null ( $ this -> _tableRegistry ) ) { $ objectTypeClass = Yii :: $ app -> classes [ 'ObjectTypeRegistry' ] ; $ this -> _tableRegistry = [ ] ; if ( $ objectTypeClass :: tableExists ( ) ) { $ om = $ objectTypeClass :: find ( ) -> all ( ) ; $ this -> _tableRegistry = ArrayHelper :: index ( $ om , 'name' ) ; } } return $ this -> _tableRegistry ; }
1895	private function addHtaccess ( string $ webDir ) : void { $ htaccess = __DIR__ . '/../Resources/skeleton/web/.htaccess' ; if ( ! file_exists ( $ webDir . '/.htaccess' ) ) { $ this -> fs -> copy ( $ htaccess , $ webDir . '/.htaccess' , true ) ; $ this -> io -> writeln ( 'Added the <comment>web/.htaccess</comment> file.' ) ; return ; } $ existingContent = file_get_contents ( $ webDir . '/.htaccess' ) ; if ( preg_match ( '/^\s*RewriteRule\s/im' , $ existingContent ) ) { return ; } $ this -> fs -> dumpFile ( $ webDir . '/.htaccess' , $ existingContent . "\n\n" . file_get_contents ( $ htaccess ) ) ; $ this -> io -> writeln ( 'Updated the <comment>web/.htaccess</comment> file.' ) ; }
7865	protected function drawBordered ( $ content ) { $ left = $ this -> geometry -> getLeftBordersWith ( static :: BORDER_X ) ; $ right = $ this -> geometry -> getRightBordersWith ( static :: BORDER_X ) ; $ this -> drawRow ( $ left . $ content . $ right ) ; }
11600	public function getConfig ( string $ sName = '' ) { if ( empty ( $ sName ) ) { return $ this -> configSet ; } elseif ( isset ( $ this -> configSet [ $ sName ] ) ) { return $ this -> configSet [ $ sName ] ; } else { return null ; } }
12955	public function getObject ( $ checkAccess = true ) { $ registryClass = Yii :: $ app -> classes [ 'Registry' ] ; $ return = $ registryClass :: getObject ( $ this -> registry_id , $ checkAccess ) ; if ( get_class ( $ return ) === 'cascade\models\Registry' ) { \ d ( $ this -> registry_id ) ; exit ; } return $ return ; }
11470	public function store ( ResponseRequest $ request ) { try { $ request = $ request -> all ( ) ; $ slug = $ request [ 'slug' ] ; $ attributes [ 'comment' ] = $ request [ 'comment' ] ; $ attributes [ 'question_id' ] = $ request [ 'question_id' ] ; $ attributes [ 'user_id' ] = user_id ( ) ; $ attributes [ 'user_type' ] = user_type ( ) ; $ response = $ this -> repository -> create ( $ attributes ) ; return $ this -> response -> message ( trans ( 'messages.success.created' , [ 'Module' => trans ( 'forum::response.name' ) ] ) ) -> code ( 204 ) -> status ( 'success' ) -> url ( trans_url ( '/discussion/' . $ slug ) ) -> redirect ( ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( trans_url ( '/question/' . $ slug ) ) -> redirect ( ) ; } }
7716	static function FindElement ( & $ TxtOrObj , $ Tag , $ PosBeg , $ Forward = true ) { $ XmlLoc = clsTbsXmlLoc :: FindStartTag ( $ TxtOrObj , $ Tag , $ PosBeg , $ Forward ) ; if ( $ XmlLoc === false ) return false ; $ XmlLoc -> FindEndTag ( ) ; return $ XmlLoc ; }
4489	public function registerDevice ( string $ deviceId , string $ platform , ? string $ userData = null ) : string { if ( ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } try { $ args = [ 'PlatformApplicationArn' => $ this -> arns [ $ platform ] , 'Token' => $ deviceId , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ; if ( $ userData ) { $ args [ 'CustomUserData' ] = $ userData ; } $ res = $ this -> sns -> createPlatformEndpoint ( $ args ) ; } catch ( SnsException $ e ) { preg_match ( '/Endpoint (.+?) already/' , $ e -> getMessage ( ) , $ matches ) ; if ( isset ( $ matches [ 1 ] ) ) { $ this -> sns -> setEndpointAttributes ( [ 'EndpointArn' => $ matches [ 1 ] , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ) ; return $ matches [ 1 ] ; } else { throw $ e ; } } return $ res [ 'EndpointArn' ] ; }
12288	public function loop ( array $ collection , string $ block , string $ emptyBlock = null ) : string { if ( empty ( $ collection ) ) { return isset ( $ emptyBlock ) ? trim ( $ this -> make ( $ emptyBlock ) ) . PHP_EOL : PHP_EOL ; } else { $ items = '' ; foreach ( $ collection as $ key => $ item ) { $ items .= rtrim ( $ this -> make ( $ block , [ 'key' => $ key , 'item' => $ item ] ) ) ; } return ltrim ( $ items ) . PHP_EOL ; } }
8766	protected function loadConfigFiles ( ) { try { if ( file_exists ( $ this -> cachePath ( 'config.php' ) ) ) { $ this -> config = require $ this -> cachePath ( 'config.php' ) ; } else { $ dotenv = new \ Dotenv \ Dotenv ( $ this -> root ) ; $ dotenv -> load ( ) ; foreach ( glob ( $ this -> root . '/config/*.php' ) as $ file ) { $ keyName = strtolower ( str_replace ( [ $ this -> root . '/config/' , '.php' ] , '' , $ file ) ) ; $ this -> config [ $ keyName ] = require $ file ; } } } catch ( Exception $ e ) { die ( printf ( "Configuration information could not be retrieved properly.\nError Message: %s" , $ e -> getMessage ( ) ) ) ; } }
4218	private function clearLog ( $ flags ) { $ return = null ; $ clearErrors = $ flags & Debug :: CLEAR_LOG_ERRORS ; if ( $ flags & Debug :: CLEAR_LOG ) { $ return = 'log (' . ( $ clearErrors ? 'incl errors' : 'sans errors' ) . ')' ; $ curDepth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] [ 'main' ] as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entriesKeep = $ this -> debug -> internal -> getCurrentGroups ( $ this -> data [ 'log' ] , $ curDepth ) ; $ this -> clearLogHelper ( $ this -> data [ 'log' ] , $ clearErrors , $ entriesKeep ) ; } elseif ( $ clearErrors ) { $ return = 'errors' ; } return $ return ; }
10436	public function channel ( string $ channel_id ) : LoggerChannelInterface { $ logger = $ this -> log_manager -> get ( $ channel_id ) ; if ( ! $ logger ) { return new NullLoggerChannel ( ) ; } return new CalgamoLoggerChannelAdapter ( $ logger ) ; }
9255	public function getRootDir ( ) { if ( ! $ this -> rootDir ) { $ refl = new \ ReflectionObject ( $ this ) ; $ filename = $ refl -> getFileName ( ) ; if ( false !== ( $ pos = strrpos ( $ filename , '/vendor/' ) ) ) { $ filename = substr ( $ filename , 0 , $ pos ) ; } else { $ filename = dirname ( $ filename ) . '/..' ; } $ this -> rootDir = str_replace ( '\\' , '/' , $ filename ) ; } return $ this -> rootDir ; }
2162	public function run35Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_member` CHANGE `username` `username` varchar(64) COLLATE utf8_bin NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_member` SET username=NULL WHERE username=''" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_member` DROP INDEX `username`, ADD UNIQUE KEY `username` (`username`)" ) ; }
3062	public function canMoveBackward ( ) { $ moveBack = false ; $ session = $ this -> getTestSession ( ) ; if ( $ this -> isAdaptive ( ) ) { $ positionInCatSession = array_search ( $ this -> getCurrentCatItemId ( ) , $ this -> getShadowTest ( ) ) ; if ( $ positionInCatSession === 0 ) { if ( $ session -> getRoute ( ) -> getPosition ( ) !== 0 ) { $ moveBack = $ session -> getPreviousRouteItem ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> getRoute ( ) -> current ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> canMoveBackward ( ) ; if ( $ moveBack ) { $ moveBack = $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> canMoveBackward ( $ session ) ; } } return $ moveBack ; }
6679	public static function convertDate ( $ dateString , $ fromFormat , $ toFormat ) { $ date = DateTime :: createFromFormat ( $ fromFormat , $ dateString ) ; if ( ! $ date && $ fromFormat == DateFormat :: FORMAT_ORACLE_WITH_MICROSECONDS ) { $ date = DateTime :: createFromFormat ( DateFormat :: FORMAT_ORACLE_DATE_ONLY , $ dateString ) ; } if ( $ date ) { return $ date -> format ( $ toFormat ) ; } return $ dateString ; }
3793	private function hasVariants ( ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> providerName ) ; if ( $ metaModel === null ) { throw new \ RuntimeException ( sprintf ( 'Could not find a MetaModels with the name %s' , $ this -> providerName ) ) ; } return $ metaModel -> hasVariants ( ) ; }
10371	public static function add_scripts ( ) { self :: look_if_process_files ( 'script' ) ; foreach ( self :: $ data [ 'script' ] as $ data ) { $ params = [ 'plugin_url' => defined ( 'WP_PLUGIN_URL' ) ? WP_PLUGIN_URL . '/' : '' , 'nonce' => wp_create_nonce ( $ data [ 'name' ] ) , ] ; $ data [ 'params' ] = array_merge ( $ data [ 'params' ] , $ params ) ; wp_register_script ( $ data [ 'name' ] , $ data [ 'url' ] , $ data [ 'deps' ] , $ data [ 'version' ] , $ data [ 'footer' ] ) ; wp_enqueue_script ( $ data [ 'name' ] ) ; wp_localize_script ( $ data [ 'name' ] , $ data [ 'name' ] , $ data [ 'params' ] ) ; } }
7415	public function errorMessage ( ) : string { static $ errors = array ( UPLOAD_ERR_INI_SIZE => 'The file "%s" exceeds your upload_max_filesize ini directive (limit is %d KiB).' , UPLOAD_ERR_FORM_SIZE => 'The file "%s" exceeds the upload limit defined in your form.' , UPLOAD_ERR_PARTIAL => 'The file "%s" was only partially uploaded.' , UPLOAD_ERR_NO_FILE => 'No file was uploaded.' , UPLOAD_ERR_CANT_WRITE => 'The file "%s" could not be written on disk.' , UPLOAD_ERR_NO_TMP_DIR => 'File could not be uploaded: missing temporary directory.' , UPLOAD_ERR_EXTENSION => 'File upload was stopped by a PHP extension.' , ) ; $ errorCode = $ this -> error ; $ maxFileSize = $ errorCode === UPLOAD_ERR_INI_SIZE ? $ this -> getMaxFileSize ( ) / 1024 : 0 ; $ message = isset ( $ errors [ $ errorCode ] ) ? $ errors [ $ errorCode ] : 'The file "%s" was not uploaded due to an unknown error.' ; return sprintf ( $ message , $ this -> name , $ maxFileSize ) ; }
2831	public function selectSqlAction ( ) { if ( $ query = $ this -> _initQuery ( ) ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ results = $ helper -> runSql ( $ query -> getQuery ( ) , $ query -> getQueryParams ( ) ) ; $ this -> renderTable ( $ results ) ; } }
10589	public function buildPayoutFromId ( $ sPayoutId ) { $ oPayout = new Freeagent \ DataWrapper \ PayoutVO ( ) ; $ oPayout -> setId ( $ sPayoutId ) ; try { $ oDets = $ this -> getTxnChargeDetails ( $ sPayoutId ) ; $ oPayout -> setDateArrival ( strtotime ( $ oDets -> PaymentDate ) ) -> setCurrency ( $ oDets -> GrossAmount -> currencyID ) ; $ oPayout -> addCharge ( $ this -> buildChargeFromTransaction ( $ sPayoutId ) ) ; } catch ( \ Exception $ oE ) { } return $ oPayout ; }
6361	public function toDateInterval ( float $ duration ) : DateInterval { Preconditions :: checkState ( $ this -> dateIntervalFormat !== null , '[%s] does not support toDateInterval()' , $ this ) ; return new DateInterval ( sprintf ( $ this -> dateIntervalFormat , $ duration ) ) ; }
3672	private function getPageCandidates ( string $ alias ) { $ aliases = [ $ alias ] ; while ( '/' !== $ alias && false !== strpos ( $ alias , '/' ) ) { $ alias = \ dirname ( $ alias ) ; $ aliases [ ] = $ alias ; } $ pages = $ this -> pageModelAdapter -> findByAliases ( $ aliases ) ; if ( null === $ pages ) { return null ; } $ arrPages = [ ] ; while ( $ pages -> next ( ) ) { $ objModel = $ pages -> current ( ) ; $ objPage = $ objModel -> loadDetails ( ) ; $ domain = $ objPage -> domain ? : '*' ; $ arrPages [ $ domain ] [ $ objPage -> rootLanguage ] [ ] = $ objPage ; if ( $ objPage -> rootIsFallback ) { $ arrPages [ $ domain ] [ '*' ] [ ] = $ objPage ; } } return $ arrPages ; }
7772	protected function replaceMessageFormat ( $ message , array $ item ) { $ keys = array_keys ( $ item ) ; if ( ! empty ( $ item [ 'args' ] ) ) { $ args = $ item [ 'args' ] ; $ argReplace = array_map ( function ( $ i ) { return "{\${$i}}" ; } , array_keys ( $ args ) ) ; $ args [ ] = count ( $ item [ 'args' ] ) ; $ argReplace [ ] = '{$#}' ; $ args [ ] = implode ( ', ' , $ item [ 'args' ] ) ; $ argReplace [ ] = '{$*}' ; $ message = str_replace ( $ argReplace , $ args , $ message ) ; } $ message = str_replace ( [ '{field}' , '{value}' ] , [ $ item [ 'field' ] , $ item [ 'value' ] ] , $ message ) ; return $ message ; }
12383	public static function perMonth ( $ months = 1 , $ date_format = "Y-m" ) { $ hits_per_month = [ ] ; for ( $ i = 1 ; $ i <= $ months ; $ i ++ ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subMonths ( $ i ) -> firstOfMonth ( ) , Carbon :: now ( ) -> subMonths ( $ i ) -> lastOfMonth ( ) ) ; $ hits_per_month [ Carbon :: now ( ) -> subMonths ( $ i ) -> format ( $ date_format ) ] = $ hits_count ; } return $ hits_per_month ; }
9383	public function getClassName ( $ identifier , $ args = [ ] ) { if ( isset ( $ this -> classes [ $ identifier ] ) ) { return $ args ? vsprintf ( $ this -> classes [ $ identifier ] , $ args ) : $ this -> classes [ $ identifier ] ; } }
11191	public function routeProcess ( $ uri = false , $ httpMethod = false ) { if ( ! $ httpMethod ) $ httpMethod = $ _SERVER [ 'REQUEST_METHOD' ] ; $ this -> httpMethod = $ httpMethod ; if ( ! $ uri ) $ uri = $ _SERVER [ 'REQUEST_URI' ] ; $ this -> setPath ( $ uri ) ; $ customPathSearch = $ this -> customFind ( ) ; if ( $ customPathSearch || ( ! $ customPathSearch && $ this -> config [ 'automatic_routing' ] ) ) { $ this -> routeFind ( ) ; } else if ( $ customPathSearch == - 1 ) { $ this -> error ( '403' ) ; } }
8409	public static function clear ( ) { $ keys = array_keys ( $ _COOKIE ) ; foreach ( $ keys as $ key ) { setcookie ( $ key , '' , time ( ) - 1 ) ; } }
11301	public function getFieldName ( $ attributeName ) { if ( isset ( $ this -> model_attributes [ $ attributeName ] [ 'field' ] ) ) { return $ this -> model_attributes [ $ attributeName ] [ 'field' ] ; } return $ attributeName ; }
6188	public function render ( $ data , $ type = null ) { if ( empty ( $ type ) or $ type === 'html' ) { return Response :: Create ( $ this -> renderInclude ( $ data ) ) ; } elseif ( $ type === 'jsonp' ) { return $ this -> renderJSONP ( $ data ) ; } else { return $ this -> renderJSON ( $ data ) ; } }
6751	private function createQualifiedTransformerClass ( ) { $ reflection = new ReflectionClass ( __CLASS__ ) ; $ name = $ reflection -> getName ( ) ; $ qualifiedTransformerClass = $ name . "Transformer" ; $ this -> setTransformer ( $ qualifiedTransformerClass ) ; }
11363	public static function mailListTagger ( array $ list ) { $ str = '' ; foreach ( $ list as $ name => $ mail ) { if ( is_string ( $ mail ) ) { $ str .= self :: mailTagger ( $ mail , $ name ) . Mailer :: $ ADDERSSES_SEPARATOR ; } elseif ( is_array ( $ mail ) ) { foreach ( $ mail as $ subname => $ submail ) { $ str .= self :: mailTagger ( $ submail , $ subname ) . Mailer :: $ ADDERSSES_SEPARATOR ; } } } return $ str ; }
9517	public function recreate ( $ file ) { if ( is_file ( $ file ) ) { return ; } $ virtual = $ tables = $ indexes = array ( ) ; if ( $ result = $ this -> query ( 'SELECT type, name, sql FROM sqlite_master' ) ) { while ( list ( $ type , $ name , $ sql ) = $ this -> fetch ( $ result ) ) { if ( ! empty ( $ sql ) ) { switch ( $ type ) { case 'table' : $ tables [ $ name ] = $ sql ; break ; case 'index' : $ indexes [ ] = $ sql ; break ; } } } $ this -> close ( $ result ) ; } foreach ( $ tables as $ name => $ sql ) { if ( strpos ( $ sql , 'VIRTUAL TABLE' ) ) { $ virtual [ ] = $ name ; } } foreach ( $ virtual as $ table ) { foreach ( $ tables as $ name => $ sql ) { if ( strpos ( $ name , "{$table}_" ) === 0 ) { unset ( $ tables [ $ name ] ) ; } } } $ db = new self ( $ file ) ; $ this -> exec ( 'ATTACH DATABASE ' . $ this -> dbEscape ( $ file ) . ' AS recreate' ) ; foreach ( $ tables as $ table => $ sql ) { $ db -> connection ( ) -> exec ( $ sql ) ; if ( $ fields = $ this -> row ( 'SELECT * FROM ' . $ table . ' LIMIT 1' , '' , 'assoc' ) ) { $ fields = implode ( ', ' , array_keys ( $ fields ) ) ; $ this -> exec ( "INSERT INTO recreate.{$table} ({$fields}) SELECT * FROM {$table}" ) ; } } foreach ( $ indexes as $ sql ) { $ db -> connection ( ) -> exec ( $ sql ) ; } $ db -> connection ( ) -> close ( ) ; }
10978	protected function setVerificationCode ( $ code = null ) { $ this -> { Config :: get ( 'verifier.store_column' ) } = $ code ; if ( $ code ) { $ this -> { Config :: get ( 'verifier.flag_column' ) } = false ; } else { $ this -> { Config :: get ( 'verifier.flag_column' ) } = true ; } $ this -> save ( ) ; }
71	protected function filterPackageMap ( array $ packageMap , PackageInterface $ mainPackage ) { $ packages = array ( ) ; $ include = array ( ) ; foreach ( $ packageMap as $ item ) { $ package = $ item [ 0 ] ; $ name = $ package -> getName ( ) ; $ packages [ $ name ] = $ package ; } $ add = function ( PackageInterface $ package ) use ( & $ add , $ packages , & $ include ) { foreach ( $ package -> getRequires ( ) as $ link ) { $ target = $ link -> getTarget ( ) ; if ( ! isset ( $ include [ $ target ] ) ) { $ include [ $ target ] = true ; if ( isset ( $ packages [ $ target ] ) ) { $ add ( $ packages [ $ target ] ) ; } } } } ; $ add ( $ mainPackage ) ; return array_filter ( $ packageMap , function ( $ item ) use ( $ include ) { $ package = $ item [ 0 ] ; foreach ( $ package -> getNames ( ) as $ name ) { if ( isset ( $ include [ $ name ] ) ) { return true ; } } return false ; } ) ; }
5781	private function getSectionForAdministrator ( array $ section , string $ sectionName ) : array { if ( isset ( $ section [ 'authorization' ] ) && ! $ this -> container -> authorization -> isAuthorized ( $ section [ 'authorization' ] ) ) { return [ ] ; } $ updatedSection = [ ] ; foreach ( $ section as $ key => $ value ) { if ( $ key != 'subSections' ) { $ updatedSection [ $ key ] = $ value ; } } $ updatedSubSections = [ ] ; if ( isset ( $ section [ 'subSections' ] ) ) { foreach ( $ section [ 'subSections' ] as $ subSectionName => $ subSection ) { $ updatedSubSection = $ this -> getSectionForAdministrator ( $ subSection , $ subSectionName ) ; if ( count ( $ updatedSubSection ) > 0 ) { $ updatedSubSections [ $ subSectionName ] = $ updatedSubSection ; } } } if ( count ( $ updatedSubSections ) > 0 ) { $ updatedSection [ 'subSections' ] = $ updatedSubSections ; } return $ updatedSection ; }
12396	public function where ( $ field , $ operator = null , $ value = null , $ logical = '&&' ) { if ( $ field instanceof Closure ) { $ this -> scope -> where .= $ this -> scope -> where == '' ? ' (' : $ logical . ' (' ; call_user_func ( $ field , $ this ) ; $ this -> scope -> where .= ') ' ; } else { $ logical = ( strlen ( $ this -> scope -> where ) <= 1 || substr ( $ this -> scope -> where , - 1 ) == '(' ) ? '' : $ logical ; $ this -> scope -> where .= Parser :: where ( $ field , $ operator , $ value , $ logical ) ; } return $ this ; }
1791	private function prepareDomain ( RequestContext $ context , array & $ parameters , int & $ referenceType ) : void { if ( isset ( $ parameters [ '_ssl' ] ) ) { $ context -> setScheme ( true === $ parameters [ '_ssl' ] ? 'https' : 'http' ) ; } if ( isset ( $ parameters [ '_domain' ] ) && '' !== $ parameters [ '_domain' ] ) { $ this -> addHostToContext ( $ context , $ parameters , $ referenceType ) ; } unset ( $ parameters [ '_domain' ] , $ parameters [ '_ssl' ] ) ; }
7854	protected function deleteIfForced ( array $ files ) { if ( ! $ this -> option ( 'force' ) ) return ; foreach ( $ files as $ file ) { if ( $ this -> files -> exists ( $ path = $ this -> getPath ( $ file ) ) ) { $ this -> files -> delete ( $ path ) ; } } }
2953	protected function extractData ( $ text , $ template ) { preg_match ( '/' . $ template . '/s' , $ text , $ matches ) ; $ keys = array_filter ( array_keys ( $ matches ) , 'is_string' ) ; $ matches = array_intersect_key ( $ matches , array_flip ( $ keys ) ) ; if ( ! empty ( $ matches ) ) { return $ this -> cleanExtractedData ( $ matches ) ; } return false ; }
11580	public function getStatus ( ) { $ message = 'Tracking ' ; $ numRepos = 0 ; if ( isset ( $ this [ 'repositories' ] ) && ( 1 === ( $ numRepos = count ( $ this [ 'repositories' ] ) ) ) ) { $ message .= '1 repository.' ; } else { $ message .= $ numRepos . ' repositories.' ; } return $ message ; }
7798	public function parse ( $ text ) { $ statements = array ( ) ; foreach ( $ this -> splitStatements ( $ text ) as $ chunk ) { if ( $ statement = $ this -> statement ( $ chunk ) ) { $ statements [ ] = $ statement ; } } return $ statements ; }
7895	public function extend ( $ provider , Closure $ callback ) { if ( $ this -> isProviderAliasExists ( $ provider ) ) { throw new InvalidArgumentException ( "Alias provider is already reserved [{$provider}]" ) ; } $ this -> customProviders [ $ provider ] = $ callback ; return $ this ; }
2401	public function route ( $ strName , $ arrParams = array ( ) ) { $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( $ strName , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; return ampersand ( $ strUrl ) ; }
1392	public function isJsonApi ( $ request , Exception $ e ) { if ( Helpers :: wantsJsonApi ( $ request ) ) { return true ; } $ route = app ( JsonApiService :: class ) -> currentRoute ( ) ; return $ route -> hasCodec ( ) && $ route -> getCodec ( ) -> willEncode ( ) ; }
11125	public function index ( Request $ request ) { $ this -> settingRepository -> pushCriteria ( new RequestCriteria ( $ request ) ) ; $ settings = $ this -> settingRepository -> all ( ) ; $ dateFormats = DateFormatter :: dropdownArray ( ) ; return view ( 'l5starter::admin.settings.index' ) -> with ( [ 'dateFormats' => $ dateFormats , 'settings' => $ settings , ] ) ; }
10853	public function setLimit ( $ num , $ offset = 0 ) { $ this -> limit = ( int ) $ num ; $ this -> offset = ( int ) $ offset ; }
12173	protected static function addReflectionArguments ( Definition $ factory , ReflectionFunctionAbstract $ reflectionFunction = null ) { if ( ! $ reflectionFunction ) { $ callable = $ factory -> getCallable ( ) ; if ( is_array ( $ callable ) ) { $ reflectionFunction = new ReflectionMethod ( $ callable [ 0 ] , $ callable [ 1 ] ) ; } else { $ reflectionFunction = new ReflectionFunction ( $ callable ) ; } } foreach ( $ reflectionFunction -> getParameters ( ) as $ arg ) { try { $ name = $ arg -> getName ( ) ; $ required = ! $ arg -> isOptional ( ) ; if ( $ argClass = $ arg -> getClass ( ) ) { $ factory -> addClassArgument ( $ name , $ argClass -> getName ( ) , $ required ) ; } else { $ default = ( $ required ? null : $ arg -> getDefaultValue ( ) ) ; $ factory -> addScalarArgument ( $ name , null , $ required , $ default ) ; } } catch ( ReflectionException $ re ) { throw UnresolvableArgumentException :: fromReflectionParam ( $ arg , $ reflectionFunction , $ re ) ; } } }
9834	public static function pixelsToCellDimension ( $ pValue , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ pDefaultFont ) { $ name = $ pDefaultFont -> getName ( ) ; $ size = $ pDefaultFont -> getSize ( ) ; if ( isset ( Font :: $ defaultColumnWidths [ $ name ] [ $ size ] ) ) { $ colWidth = $ pValue * Font :: $ defaultColumnWidths [ $ name ] [ $ size ] [ 'width' ] / Font :: $ defaultColumnWidths [ $ name ] [ $ size ] [ 'px' ] ; } else { $ colWidth = $ pValue * 11 * Font :: $ defaultColumnWidths [ 'Calibri' ] [ 11 ] [ 'width' ] / Font :: $ defaultColumnWidths [ 'Calibri' ] [ 11 ] [ 'px' ] / $ size ; } return $ colWidth ; }
5480	protected function addCheckbox ( $ tag ) { if ( ! isset ( $ this -> checkboxes [ $ tag -> getName ( ) ] ) ) { $ this -> widgets [ ] = $ tag ; $ this -> checkboxes [ $ tag -> getName ( ) ] = count ( $ this -> widgets ) - 1 ; } else { $ index = $ this -> checkboxes [ $ tag -> getName ( ) ] ; if ( ! is_a ( $ this -> widgets [ $ index ] , 'SimpleCheckboxGroup' ) ) { $ previous = $ this -> widgets [ $ index ] ; $ this -> widgets [ $ index ] = new SimpleCheckboxGroup ( ) ; $ this -> widgets [ $ index ] -> addWidget ( $ previous ) ; } $ this -> widgets [ $ index ] -> addWidget ( $ tag ) ; } }
8604	public function getSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_GetSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_GetSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_GetSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5681	protected function linkIsAbsolute ( $ url ) { $ parsed = new SimpleUrl ( $ url ) ; return ( boolean ) ( $ parsed -> getScheme ( ) && $ parsed -> getHost ( ) ) ; }
9318	public function rotate ( $ angle , $ background = 'FFFFFF' ) { $ angle = intval ( $ angle ) ; if ( ! is_int ( $ angle ) || ( $ angle < 0 ) || ( $ angle > 360 ) ) { throw new ezcBaseValueException ( 'height' , $ height , 'angle < 0 or angle > 360' ) ; } $ angle = 360 - $ angle ; $ background = "#{$background}" ; $ this -> addFilterOption ( $ this -> getActiveReference ( ) , '-background' , $ background ) ; $ this -> addFilterOption ( $ this -> getActiveReference ( ) , '-rotate' , $ angle ) ; }
8938	public function updateChangeset ( $ id , $ tags = array ( ) ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <changeset>' . $ tagList . '</changeset> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> changeset ; }
8648	private function addRequiredParameters ( array $ parameters ) { $ parameters [ 'AWSAccessKeyId' ] = $ this -> awsAccessKeyId ; $ parameters [ 'Timestamp' ] = $ this -> getFormattedTimestamp ( new DateTime ( 'now' , new DateTimeZone ( 'UTC' ) ) ) ; $ parameters [ 'Version' ] = self :: SERVICE_VERSION ; $ parameters [ 'SignatureVersion' ] = $ this -> config [ 'SignatureVersion' ] ; if ( $ parameters [ 'SignatureVersion' ] > 1 ) { $ parameters [ 'SignatureMethod' ] = $ this -> config [ 'SignatureMethod' ] ; } $ parameters [ 'Signature' ] = $ this -> signParameters ( $ parameters , $ this -> awsSecretAccessKey ) ; return $ parameters ; }
11743	public function remove ( $ pageName ) { if ( $ pageName == $ this -> configurationHandler -> homepage ( ) ) { throw new RuntimeException ( "exception_homepage_cannot_be_removed" ) ; } $ pageDir = $ this -> pagesDir . '/' . $ pageName ; Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_REMOVING , new PageCollectionRemovingEvent ( $ this -> username , $ pageDir ) ) ; $ filesystem = new Filesystem ( ) ; if ( file_exists ( $ pageDir . '/page.json' ) ) { $ filesystem -> mirror ( $ pageDir , $ this -> pagesRemovedDir . '/' . $ pageName . "-" . date ( "Y-m-d-H.i.s" ) ) ; } $ filesystem -> remove ( $ pageDir ) ; Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_REMOVED , new PageCollectionRemovedEvent ( $ this -> username , $ pageDir ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully removed from website' , $ pageName ) ) ; }
5298	public function addGlyph ( $ char , $ path , $ name = null , $ width = null ) { $ glyph = $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> addChild ( 'glyph' ) ; $ glyph -> addAttribute ( 'unicode' , $ char ) ; if ( $ name !== null ) { $ glyph -> addAttribute ( 'glyph-name' , $ name ) ; } if ( $ width !== null ) { $ glyph -> addAttribute ( 'horiz-adv-x' , $ width ) ; } $ glyph -> addAttribute ( 'd' , $ path ) ; }
2146	protected function generateEmailObject ( Result $ objNewsletter , $ arrAttachments ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ objNewsletter -> sender ; $ objEmail -> subject = $ objNewsletter -> subject ; if ( $ objNewsletter -> senderName != '' ) { $ objEmail -> fromName = $ objNewsletter -> senderName ; } $ objEmail -> embedImages = ! $ objNewsletter -> externalImages ; $ objEmail -> logFile = TL_NEWSLETTER . '_' . $ objNewsletter -> id ; if ( ! empty ( $ arrAttachments ) && \ is_array ( $ arrAttachments ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ arrAttachments as $ strAttachment ) { $ objEmail -> attachFile ( $ rootDir . '/' . $ strAttachment ) ; } } return $ objEmail ; }
11319	function query ( $ sql , $ params = array ( ) ) { $ db = Neuron_DB_Database :: getInstance ( ) ; $ sql = $ this -> printf ( $ sql , $ params ) ; if ( $ this -> debug ) { echo $ sql . "<br><br>" ; } try { $ data = $ db -> query ( $ sql ) ; if ( $ this -> debug ) { echo '<pre>' ; var_dump ( $ data ) ; echo "</pre><br><br>" ; } $ this -> error = false ; return $ data ; } catch ( Exception $ e ) { $ this -> error = true ; echo 'error' ; } }
6738	public function run_ajax ( ) { $ methods = [ 'add_movie_rating' ] ; foreach ( $ methods as $ method ) { add_action ( 'wp_ajax_' . $ method , [ $ this -> rating , $ method ] ) ; add_action ( 'wp_ajax_nopriv_' . $ method , [ $ this -> rating , $ method ] ) ; } }
8438	public function setPostLink ( TimelineLinkEvent $ event ) : void { $ action = $ event -> getAction ( ) ; if ( ! in_array ( $ action -> getVerb ( ) , [ 'post' , 'reply' ] ) ) { return ; } $ production = $ action -> getComponent ( 'indirectComplement' ) -> getData ( ) ; $ post = $ action -> getComponent ( 'directComplement' ) -> getData ( ) ; $ event -> setLink ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) , '_fragment' => 'post-' . $ post -> getId ( ) , ] ) ) ; }
2052	public static function create ( $ file , $ size = null ) { if ( \ is_string ( $ file ) ) { $ file = new File ( rawurldecode ( $ file ) ) ; } $ imageSize = null ; $ picture = new static ( $ file ) ; if ( \ is_array ( $ size ) && ! empty ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ size = ( int ) $ size [ 2 ] ; } $ imageSize = null ; if ( ! \ is_array ( $ size ) ) { $ imageSize = ImageSizeModel :: findByPk ( $ size ) ; if ( $ imageSize === null ) { $ size = array ( ) ; } } if ( \ is_array ( $ size ) ) { $ size += array ( 0 , 0 , 'crop' ) ; $ imageSize = new \ stdClass ( ) ; $ imageSize -> width = $ size [ 0 ] ; $ imageSize -> height = $ size [ 1 ] ; $ imageSize -> resizeMode = $ size [ 2 ] ; $ imageSize -> zoom = 0 ; } $ picture -> setImageSize ( $ imageSize ) ; if ( $ imageSize !== null && ! empty ( $ imageSize -> id ) ) { $ picture -> setImageSizeItems ( ImageSizeItemModel :: findVisibleByPid ( $ imageSize -> id , array ( 'order' => 'sorting ASC' ) ) ) ; } $ fileRecord = FilesModel :: findByPath ( $ file -> path ) ; if ( $ fileRecord !== null && $ fileRecord -> importantPartWidth && $ fileRecord -> importantPartHeight ) { $ picture -> setImportantPart ( array ( 'x' => ( int ) $ fileRecord -> importantPartX , 'y' => ( int ) $ fileRecord -> importantPartY , 'width' => ( int ) $ fileRecord -> importantPartWidth , 'height' => ( int ) $ fileRecord -> importantPartHeight , ) ) ; } return $ picture ; }
3250	public function scopeWhereCurrent ( $ query ) { if ( Auth :: guest ( ) ) return $ query ; return $ query -> whereUser ( Auth :: user ( ) -> shopId ) ; }
8174	protected function checkLoopUsageCondition ( Twig_TokenStream $ stream , Twig_NodeInterface $ node ) { if ( $ node instanceof Twig_Node_Expression_GetAttr && $ node -> getNode ( 'node' ) instanceof Twig_Node_Expression_Name && 'loop' == $ node -> getNode ( 'node' ) -> getAttribute ( 'name' ) ) { throw new Twig_Error_Syntax ( 'The "loop" variable cannot be used in a looping condition.' , $ node -> getTemplateLine ( ) , $ stream -> getSourceContext ( ) ) ; } foreach ( $ node as $ n ) { if ( ! $ n ) { continue ; } $ this -> checkLoopUsageCondition ( $ stream , $ n ) ; } }
4417	public function showLocationLayouts ( $ locationId ) { $ repository = $ this -> getRepository ( ) ; $ location = $ repository -> getLocationService ( ) -> loadLocation ( $ locationId ) ; $ content = $ repository -> getContentService ( ) -> loadContent ( $ location -> contentInfo -> id ) ; $ request = $ this -> createRequest ( $ content , $ location ) ; return $ this -> render ( '@NetgenAdminUI/layouts/location_layouts.html.twig' , array ( 'rules' => $ this -> layoutResolver -> resolveRules ( $ request , array ( 'ez_content_type' ) ) , 'related_layouts' => $ this -> relatedLayoutsLoader -> loadRelatedLayouts ( $ location ) , 'location' => $ location , ) ) ; }
2403	public function trans ( $ strId , array $ arrParams = array ( ) , $ strDomain = 'contao_default' ) { return System :: getContainer ( ) -> get ( 'translator' ) -> trans ( $ strId , $ arrParams , $ strDomain ) ; }
11544	public function confirmPasswordReset ( $ token ) { $ user = $ this -> getMapper ( ) -> findOneBy ( [ 'registrationToken' => $ token ] ) ; if ( ! $ user instanceof UserInterface ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setRegistrationToken ( $ this -> getRegistrationToken ( ) ) ; $ user -> setEmailConfirmed ( true ) ; $ password = $ this -> getPasswordGenerator ( ) -> generate ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ viewModel = new ViewModel ( compact ( 'user' , 'password' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-change-password-success' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Your password has been changed!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
7121	private function createFindBySubjectQueryBuilder ( ) { $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createQueryBuilder ( ) ; return $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.subjectIdentity.provider' , ':provider' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.subjectIdentity.identifier' , ':identifier' ) ) ; }
10350	protected function validate ( ) { $ this -> validateArgSet ( $ this -> args ) ; if ( $ this -> success ) { $ this -> validateArgSet ( $ this -> successArgs ) ; } if ( ! $ this -> success ) { $ this -> validateArgSet ( $ this -> failureArgs ) ; } }
318	public function registerCssFile ( $ url , $ options = [ ] , $ key = null ) { $ url = Yii :: getAlias ( $ url ) ; $ key = $ key ? : $ url ; $ depends = ArrayHelper :: remove ( $ options , 'depends' , [ ] ) ; if ( empty ( $ depends ) ) { $ this -> cssFiles [ $ key ] = Html :: cssFile ( $ url , $ options ) ; } else { $ this -> getAssetManager ( ) -> bundles [ $ key ] = Yii :: createObject ( [ 'class' => AssetBundle :: className ( ) , 'baseUrl' => '' , 'css' => [ strncmp ( $ url , '//' , 2 ) === 0 ? $ url : ltrim ( $ url , '/' ) ] , 'cssOptions' => $ options , 'depends' => ( array ) $ depends , ] ) ; $ this -> registerAssetBundle ( $ key ) ; } }
4318	private function setLogDest ( $ where = 'auto' ) { if ( $ where == 'auto' ) { $ where = $ this -> data [ 'groupPriorityStack' ] ? 'summary' : 'log' ; } if ( $ where == 'log' ) { $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'log' ] ; $ this -> rootInstance -> groupStackRef = & $ this -> rootInstance -> data [ 'groupStacks' ] [ 'main' ] ; } elseif ( $ where == 'alerts' ) { $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'alerts' ] ; } else { $ priority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; if ( ! isset ( $ this -> data [ 'logSummary' ] [ $ priority ] ) ) { $ this -> data [ 'logSummary' ] [ $ priority ] = array ( ) ; $ this -> data [ 'groupStacks' ] [ $ priority ] = array ( ) ; } $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'logSummary' ] [ $ priority ] ; $ this -> rootInstance -> groupStackRef = & $ this -> rootInstance -> data [ 'groupStacks' ] [ $ priority ] ; } }
775	public function resetSequence ( $ tableName , $ value = null ) { $ table = $ this -> db -> getTableSchema ( $ tableName ) ; if ( $ table !== null && $ table -> sequenceName !== null ) { $ tableName = $ this -> db -> quoteTableName ( $ tableName ) ; if ( $ value === null ) { $ key = reset ( $ table -> primaryKey ) ; $ value = $ this -> db -> createCommand ( "SELECT MAX(`$key`) FROM $tableName" ) -> queryScalar ( ) + 1 ; } else { $ value = ( int ) $ value ; } return "ALTER TABLE $tableName AUTO_INCREMENT=$value" ; } elseif ( $ table === null ) { throw new InvalidArgumentException ( "Table not found: $tableName" ) ; } throw new InvalidArgumentException ( "There is no sequence associated with table '$tableName'." ) ; }
9109	public function getResolverObject ( $ state = null , array $ options = array ( ) ) { if ( $ state == null && isset ( $ this -> resolverObject [ 'last_resolver' ] ) ) { return $ this -> resolverObject [ 'last_resolver' ] ; } if ( $ state != 'resolver_adapter_service' && $ state != 'mvclayout_resolver_adapter' ) throw new \ Exception ( 'Invalid state name provided.' ) ; $ config = $ this -> getConfig ( ) ; if ( isset ( $ config [ 'theme_locator' ] ) ) $ config = $ config [ 'theme_locator' ] ; else $ config = array ( ) ; if ( ! isset ( $ config [ $ state ] ) ) throw new \ Exception ( "Theme Resolver Service not present in config[$state]." ) ; $ config = $ config [ $ state ] ; if ( is_string ( $ config ) ) { $ config = array ( "{$config}" => 1 ) ; } if ( isset ( $ this -> resolverObject [ $ state ] ) ) { $ resolver = $ this -> resolverObject [ $ state ] ; $ this -> resolverObject [ 'last_resolver' ] = $ resolver ; return $ resolver ; } else $ resolver = new Resolvers \ Aggregate ( ) ; foreach ( $ config as $ service => $ priority ) { if ( $ this -> getServiceLocator ( ) -> has ( $ service ) ) { $ service = $ this -> getServiceLocator ( ) -> get ( $ service ) ; } else { if ( ! class_exists ( $ service ) ) throw new \ Exception ( "Resolver '$service' not found for yimaTheme as Service either Class." ) ; $ service = new $ service ( ) ; } if ( $ service instanceof Resolvers \ LocatorResolverAwareInterface ) { $ service -> setThemeLocator ( $ this ) ; } if ( $ service instanceof Resolvers \ ConfigResolverAwareInterface ) { $ service -> setConfig ( $ this -> getConfig ( ) ) ; } if ( isset ( $ options [ 'event_mvc' ] ) ) if ( $ service instanceof Resolvers \ MvcResolverAwareInterface ) $ service -> setMvcEvent ( $ options [ 'event_mvc' ] ) ; $ resolver -> attach ( $ service , $ priority ) ; } $ this -> resolverObject [ $ state ] = $ resolver ; $ this -> resolverObject [ 'last_resolver' ] = $ resolver ; return $ resolver ; }
203	protected function createQuery ( $ targetClass , $ condition ) { $ query = $ targetClass :: find ( ) -> andWhere ( $ condition ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ query ) ; } elseif ( $ this -> filter !== null ) { $ query -> andWhere ( $ this -> filter ) ; } return $ query ; }
12165	private function createAuthorityPermissionsTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?authority_permissions`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?authority_permissions` ( `authority_permission_key` bigint(20) NOT NULL AUTO_INCREMENT, `authority_id` bigint(20) NOT NULL, `permission_area_uri` varchar(255) NOT NULL, `permission` varchar(45) NOT NULL DEFAULT '1', `permission_type` varchar(45) NOT NULL, `permission_title` varchar(45) NOT NULL, PRIMARY KEY (`authority_permission_key`), UNIQUE KEY `UNIQUE` (`permission_area_uri`,`permission_type`,`authority_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;" ) ; $ this -> database -> query ( "INSERT INTO `?authority_permissions` (`authority_permission_key`, `authority_id`, `permission_area_uri`, `permission`, `permission_type`, `permission_title`) VALUES (1, 4, '^/admin(/[a-z0-9-]*)*', 'allow', 'special', 'Console'), (2, 1, '^/admin/setup/install(/[a-z0-9-]*)*', 'allow', 'execute', 'Installer'), (3, 4, '^/page(/[a-z0-9-]*)*', 'allow', 'execute', 'Content'), (4, 2, '^/member(/[a-z0-9-]*)*', 'allow', 'execute', 'Member Pages'), (5, 1, '^/member/sign([a-z0-9-]*)*', 'allow', 'execute', 'Authentication'), (6, 2, '^/message(/[a-z0-9-]*)*', 'allow', 'execute', 'Messages'), (7, 1, '^/search(/[a-z0-9-]*)*', 'allow', 'execute', 'Search'), (8, 4, '^/listing(/[a-z0-9-]*)*', 'allow', 'special', 'Directory'), (9, 2, '^/notification(/[a-z0-9-]*)*', 'allow', 'execute', 'Messages'), (10, 1, '^/post(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (11, 1, '^/event(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (12, 1, '^/stream(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (13, 1, '^/group(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (14, 1, '^/file(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (16, 2, '^/post(/[a-z0-9-]*)*', 'allow', 'execute', 'Content'), (15, 1, '^/page(/[a-z0-9-]*)*', 'allow', 'view', 'Content');" ) ; }
8078	protected function buildUri ( $ endpoint , $ options = [ ] ) { if ( $ this -> token !== '' ) { $ options [ 'auth' ] = $ this -> token ; } return $ this -> base . '/' . ltrim ( $ endpoint , '/' ) . '.json?' . http_build_query ( $ options , '' , '&' ) ; }
11706	public function storageValidate ( $ validators , $ storage ) { $ errors = [ ] ; foreach ( $ validators as $ kValidate => $ validate ) { if ( ! isset ( $ storage [ $ kValidate ] ) ) { $ errors [ ] = [ 'field' => $ kValidate , 'message' => 'Value ' . $ kValidate . ' not found.' ] ; continue ; } $ error = $ this -> validate ( $ validate , $ storage [ $ kValidate ] ) ; if ( $ error ) $ errors [ ] = [ 'field' => $ kValidate , 'message' => $ error ] ; } return $ errors ; }
7144	public static function remove_author_meta_values ( ) { global $ blog_id ; if ( isset ( $ blog_id ) && ! empty ( $ blog_id ) ) { $ blogusers = get_users ( array ( 'blog_id' => $ blog_id ) ) ; foreach ( $ blogusers as $ user_object ) { delete_user_meta ( $ user_object -> ID , 'post_subscription' ) ; delete_user_meta ( $ user_object -> ID , 'comment_subscription' ) ; } } }
5080	public function postIndex ( ) { $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ this -> userCan ( static :: ACTION_CREATE ) ; $ aData = $ oInput -> post ( ) ; if ( empty ( $ aData ) ) { $ sData = stream_get_contents ( fopen ( 'php://input' , 'r' ) ) ; $ aData = json_decode ( $ sData , JSON_OBJECT_AS_ARRAY ) ? : [ ] ; } $ aData = $ this -> validateUserInput ( $ aData ) ; $ iItemId = $ this -> oModel -> create ( $ aData ) ; if ( empty ( $ iItemId ) ) { throw new ApiException ( 'Failed to create resource. ' . $ this -> oModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } $ oItem = $ this -> oModel -> getById ( $ iItemId , static :: CONFIG_LOOKUP_DATA ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
3232	static function findError ( $ path ) { Checker :: argStringNonEmpty ( "path" , $ path ) ; $ matchResult = preg_match ( '%^(?: [\x09\x0A\x0D\x20-\x7E] # ASCII | [\xC2-\xDF][\x80-\xBF] # non-overlong 2-byte | \xE0[\xA0-\xBF][\x80-\xBD] # excluding overlongs, FFFE, and FFFF | [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2} # straight 3-byte | \xED[\x80-\x9F][\x80-\xBF] # excluding surrogates )*$%xs' , $ path ) ; if ( $ matchResult !== 1 ) { return "must be valid UTF-8; BMP only, no surrogates, no U+FFFE or U+FFFF" ; } if ( $ path [ 0 ] !== "/" ) return "must start with \"/\"" ; $ l = strlen ( $ path ) ; if ( $ l === 1 ) return null ; if ( $ path [ $ l - 1 ] === "/" ) return "must not end with \"/\"" ; return null ; }
4096	public function build ( ) { $ built = array ( ) ; if ( $ this -> fieldname ) { $ built [ $ this -> fieldname ] = array ( ) ; foreach ( array ( "from" , "to" , "includeLower" , "includeUpper" , "boost" ) as $ opt ) { if ( $ this -> $ opt !== null ) $ built [ $ this -> fieldname ] [ $ opt ] = $ this -> $ opt ; } if ( count ( $ built [ $ this -> fieldname ] ) == 0 ) throw new \ ElasticSearch \ Exception ( "Empty RangeQuery cant be created" ) ; } return $ built ; }
3849	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'tableName' ) ) { return ; } $ tableName = strtolower ( $ event -> getValue ( ) ) ; if ( ! strlen ( $ tableName ) ) { throw new \ RuntimeException ( 'Table name not given' ) ; } if ( substr ( $ tableName , 0 , 3 ) !== 'mm_' ) { $ tableName = 'mm_' . $ tableName ; } $ dataProvider = $ event -> getEnvironment ( ) -> getDataProvider ( 'tl_metamodel' ) ; try { if ( ! $ event -> getModel ( ) -> getId ( ) ) { $ this -> tableManipulator -> checkTableDoesNotExist ( $ tableName ) ; } else { $ oldVersion = $ dataProvider -> fetch ( $ dataProvider -> getEmptyConfig ( ) -> setId ( $ event -> getModel ( ) -> getId ( ) ) ) ; if ( $ oldVersion -> getProperty ( 'tableName' ) !== $ event -> getModel ( ) -> getProperty ( 'tableName' ) ) { $ this -> tableManipulator -> checkTableDoesNotExist ( $ tableName ) ; } } } catch ( \ Exception $ exception ) { throw new \ RuntimeException ( $ exception -> getMessage ( ) , $ exception -> getCode ( ) , $ exception ) ; } $ event -> setValue ( $ tableName ) ; }
7035	protected function createMigrationTable ( ) { $ migrations = new Table ( "migrations" , true ) ; $ migrations -> string ( "host" ) -> notNullable ( ) -> primaryComposite ( ) ; $ migrations -> timestamp ( "created_at" ) -> notNullable ( ) -> primaryComposite ( true ) ; $ migrations -> blob ( "tables" ) ; try { return $ migrations -> create ( $ this -> dbName ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
6351	public static function size ( Iterator $ iterator ) { $ result = 0 ; Iterators :: each ( $ iterator , function ( ) use ( & $ result ) { $ result ++ ; } ) ; return $ result ; }
7479	public function getContent ( ) { $ this -> absolute ( ) ; if ( ! is_file ( $ this -> data ) ) { Exception :: i ( ) -> setMessage ( self :: ERROR_PATH_IS_NOT_FILE ) -> addVariable ( $ this -> data ) -> trigger ( ) ; } return file_get_contents ( $ this -> data ) ; }
5969	protected static function sortFileList ( array $ a , array $ b ) { if ( ! array_key_exists ( "src" , $ a ) || ! array_key_exists ( "src" , $ b ) || ! array_key_exists ( "type" , $ a ) || ! array_key_exists ( "type" , $ b ) ) { return 0 ; throw new Ts3Exception ( "invalid parameter" , 0x602 ) ; } if ( $ a [ "type" ] != $ b [ "type" ] ) { return ( $ a [ "type" ] < $ b [ "type" ] ) ? - 1 : 1 ; } return strcmp ( strtolower ( $ a [ "src" ] ) , strtolower ( $ b [ "src" ] ) ) ; }
10289	protected function executeTasks ( array $ tasks ) { foreach ( $ tasks as $ scheduled => $ taskList ) { foreach ( $ taskList as $ cronjob ) { if ( ( $ task = $ this -> taskFactory -> factory ( $ cronjob -> task , $ scheduled , $ this -> logger ) ) !== false ) { $ this -> logger -> setTask ( $ task -> getId ( ) ) ; $ this -> logger -> log ( 'Start task execution.' ) ; $ status = $ task -> execute ( ) ; switch ( $ status ) { case Executor :: SUCCESS : $ this -> logger -> log ( 'Finished task execution.' ) ; break ; case Executor :: ERROR : $ this -> logger -> log ( 'Error occured during task execution.' , Logger :: WARNING ) ; break ; case Executor :: RESCHEDULE : $ this -> logger -> log ( 'Task will be rescheduled for ' . $ task -> reScheduleTime . ' seconds.' ) ; $ this -> rescheduled [ $ scheduled + $ task -> reScheduleTime ] = $ cronjob ; break ; default : $ this -> logger -> log ( 'Invalid status returned by task.' , Logger :: ERROR ) ; break ; } $ this -> logger -> setTask ( ) ; } } } }
11993	public function orderBy ( $ key , $ direction = 'asc' ) { return $ this -> sort ( function ( $ a , $ b ) use ( $ key , $ direction ) { $ valueA = is_object ( $ a ) ? $ a -> { $ key } : $ a [ $ key ] ; $ valueB = is_object ( $ b ) ? $ b -> { $ key } : $ b [ $ key ] ; if ( $ valueA == $ valueB ) return 0 ; $ result = ( $ valueA < $ valueB ) ? - 1 : 1 ; return $ direction === 'desc' ? - ( $ result ) : $ result ; } ) ; }
1928	protected function validator ( $ varInput ) { foreach ( $ varInput as $ k => $ v ) { if ( $ k != 'unit' ) { $ varInput [ $ k ] = parent :: validator ( $ v ) ; } } return $ varInput ; }
5853	protected function loadVirtualTca ( ) { $ GLOBALS [ 'TCA' ] [ static :: virtualTable ] = include ( ExtensionManagementUtility :: extPath ( $ this -> extKey ) . 'Configuration/TCA/Module/Options.php' ) ; ExtensionManagementUtility :: addLLrefForTCAdescr ( static :: virtualTable , 'EXT:' . $ this -> extKey . '/Resource/Private/Language/locallang_csh_' . static :: virtualTable . '.xlf' ) ; }
12398	public function select ( $ select = null ) { $ this -> scope -> select = Parser :: select ( $ select ) ; return $ this ; }
5183	public function article ( string $ singleJsonArticle ) : Article { if ( json_decode ( $ singleJsonArticle , true ) ) { $ dataArticle = json_decode ( $ singleJsonArticle , true ) [ 'data' ] ; $ article = new Article ( $ this -> filterString ( $ this -> getValue ( 'title' , $ dataArticle ) ) , $ this -> filterString ( $ this -> getValue ( 'body' , $ dataArticle ) ) , $ this -> filterString ( $ this -> getValue ( 'source' , $ dataArticle ) ) , $ this -> getValue ( 'unique_id' , $ dataArticle ) , $ this -> filterInteger ( $ this -> getValue ( 'type_id' , $ dataArticle [ 'type' ] ) ) , $ this -> filterInteger ( $ this -> getValue ( 'category_id' , $ dataArticle [ 'category' ] ) ) , $ this -> getValue ( 'reporter' , $ dataArticle ) , $ this -> filterString ( $ this -> getValue ( 'lead' , $ dataArticle ) ) , $ this -> getValue ( 'tag_name' , $ dataArticle [ 'tags' ] ) , $ this -> filterString ( $ this -> getValue ( 'published_at' , $ dataArticle ) ) , ( string ) $ this -> filterInteger ( $ this -> getValue ( 'id' , $ dataArticle ) ) ) ; $ attachmentConstants = [ Article :: ATTACHMENT_FIELD_PHOTO , Article :: ATTACHMENT_FIELD_PAGE , Article :: ATTACHMENT_FIELD_GALLERY , Article :: ATTACHMENT_FIELD_VIDEO , ] ; $ attachmentTypes = [ self :: JSON_PHOTO_FIELD , self :: JSON_PAGE_FIELD , self :: JSON_GALLERY_FIELD , self :: JSON_VIDEO_FIELD , ] ; $ attachmentAttributes = $ this -> lookUp ( $ attachmentConstants ) ; return $ this -> generalAttachment ( $ article , $ attachmentConstants , $ attachmentTypes , $ attachmentAttributes , $ dataArticle ) ; } throw new \ Exception ( 'Empty or invalid JSON Response' , 1 ) ; }
3753	public function save ( ModelInterface $ objItem , $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } if ( $ objItem instanceof Model ) { $ backupLanguage = $ this -> setLanguage ( $ this -> getCurrentLanguage ( ) ) ; $ objItem -> getItem ( ) -> save ( $ timestamp ) ; $ this -> setLanguage ( $ backupLanguage ) ; return $ objItem ; } throw new \ RuntimeException ( 'ERROR: incompatible object passed to GeneralDataMetaModel::save()' ) ; }
4236	public function emailLog ( ) { $ errorStr = $ this -> buildErrorList ( ) ; $ subject = 'Debug Log' ; $ subjectMore = '' ; if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ subjectMore .= ' ' . $ _SERVER [ 'HTTP_HOST' ] ; } if ( $ errorStr ) { $ subjectMore .= ' ' . ( $ subjectMore ? '(Error)' : 'Error' ) ; } $ subject = \ rtrim ( $ subject . ':' . $ subjectMore , ':' ) ; $ body = ( ! isset ( $ _SERVER [ 'REQUEST_URI' ] ) && ! empty ( $ _SERVER [ 'argv' ] ) ? 'Command: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) : 'Request: ' . $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] ) . "\n\n" ; if ( $ errorStr ) { $ body .= 'Error(s):' . "\n" . $ errorStr . "\n" ; } $ data = \ array_intersect_key ( $ this -> debug -> getData ( ) , \ array_flip ( array ( 'alerts' , 'log' , 'logSummary' , 'requestId' , 'runtime' , ) ) ) ; $ data [ 'rootChannel' ] = $ this -> debug -> getCfg ( 'channel' ) ; $ body .= $ this -> debug -> utilities -> serializeLog ( $ data ) ; $ this -> email ( $ this -> debug -> getCfg ( 'emailTo' ) , $ subject , $ body ) ; return ; }
9139	public static function parse ( $ uri , $ serverVars = array ( ) , $ defaultController = 'Index' , $ defaultAction = 'index' ) { $ req = new self ( $ defaultController , $ defaultAction ) ; $ req -> origin = $ uri ; self :: parseRemoteHost ( $ req , $ serverVars ) ; self :: parseGetPostSessionCookie ( $ req ) ; $ savedRequestParams = array ( ) ; if ( strpos ( $ uri , '?' ) ) { parse_str ( substr ( $ uri , strpos ( $ uri , '?' ) + 1 ) , $ savedRequestParams ) ; $ uri = substr ( $ uri , 0 , strpos ( $ uri , '?' ) ) ; } self :: parseContextPrefix ( $ req , $ serverVars ) ; $ parts = self :: parseUri ( $ req , $ uri , $ defaultController , $ defaultAction ) ; $ numParts = count ( $ parts ) ; for ( $ i = 0 ; $ i < $ numParts ; $ i = $ i + 2 ) { $ paramName = trim ( $ parts [ $ i ] ) ; $ paramValue = isset ( $ parts [ $ i + 1 ] ) ? trim ( $ parts [ $ i + 1 ] ) : '' ; if ( $ paramName && $ paramValue ) { $ req -> params [ $ paramName ] = $ paramValue ; } } $ req -> params = array_merge ( $ req -> params , $ savedRequestParams ) ; self :: parseParameters ( $ req , $ serverVars ) ; return $ req ; }
9234	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; if ( Yii :: $ app -> request -> post ( ) ) { $ post = Yii :: $ app -> request -> post ( ) ; $ category = [ ] ; if ( isset ( $ post [ 'Post' ] [ 'category' ] ) ) { $ category = $ post [ 'Post' ] [ 'category' ] ; } if ( is_array ( $ post [ 'Post' ] [ 'tags' ] ) ) { $ post [ 'Post' ] [ 'tags' ] = implode ( "," , $ post [ 'Post' ] [ 'tags' ] ) ; } $ model -> load ( $ post ) ; $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> save ( ) ) { $ cs = BlogCatPos :: deleteAll ( "post_id = :id" , [ "id" => $ model -> id ] ) ; foreach ( $ category as $ d ) { $ c = new BlogCatPos ( ) ; $ c -> post_id = $ model -> id ; $ c -> category_id = $ d ; $ c -> isdel = 0 ; $ c -> save ( ) ; } $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } } return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; }
12605	public static function getName ( $ file ) { $ file = str_replace ( '\\' , '/' , $ file ) ; $ slash = strrpos ( $ file , '/' ) ; if ( $ slash !== false ) { return substr ( $ file , $ slash + 1 ) ; } return $ file ; }
9641	public function validate ( $ validator ) { $ this -> value = trim ( $ this -> value ) ; $ regex = $ this -> config [ 'validregex' ] ; if ( $ this -> value && $ regex && ! preg_match ( $ regex , $ this -> value ) ) { $ validator -> validationError ( $ this -> name , _t ( 'ExternalURLField.VALIDATION' , "Please enter a valid URL" ) , "validation" ) ; return false ; } return true ; }
241	public function init ( ) { parent :: init ( ) ; if ( $ this -> model === null ) { throw new InvalidConfigException ( 'Please specify the "model" property.' ) ; } if ( $ this -> formatter === null ) { $ this -> formatter = Yii :: $ app -> getFormatter ( ) ; } elseif ( is_array ( $ this -> formatter ) ) { $ this -> formatter = Yii :: createObject ( $ this -> formatter ) ; } if ( ! $ this -> formatter instanceof Formatter ) { throw new InvalidConfigException ( 'The "formatter" property must be either a Format object or a configuration array.' ) ; } $ this -> normalizeAttributes ( ) ; if ( ! isset ( $ this -> options [ 'id' ] ) ) { $ this -> options [ 'id' ] = $ this -> getId ( ) ; } }
10824	public static function confirm ( $ question , $ allowShort , $ defaultValue = false ) { $ value = $ defaultValue ? 'yes' : 'no' ; $ value = self :: ask ( $ question . ' (yes/no)' , $ value ) ; return $ value == 'yes' || ( $ value == 'y' && $ allowShort ) ; }
8586	public function setCompetitivePrice ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'CompetitivePrice' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5743	protected function parseContentType ( $ contentType ) { if ( false === stripos ( $ contentType , ';' ) ) { throw new ParserException ( 'ContentType does not contain a \';\'' ) ; } list ( $ mime , $ boundary ) = explode ( ';' , $ contentType , 2 ) ; list ( $ key , $ boundaryValue ) = explode ( '=' , trim ( $ boundary ) , 2 ) ; if ( 'boundary' != $ key ) { throw new ParserException ( 'Boundary does not start with \'boundary=\'' ) ; } return [ strtolower ( trim ( $ mime ) ) , $ boundaryValue ] ; }
2834	public function startRendering ( Mage_Core_Block_Abstract $ block ) { if ( $ this -> isRendering ) { $ this -> renderedCount ++ ; Mage :: log ( "Recursive block rendering {$this->getName()}" , Zend_Log :: DEBUG ) ; return ; } $ this -> init ( $ block ) ; $ this -> isRendering = true ; $ this -> renderedCount ++ ; $ this -> renderedAt = microtime ( true ) ; if ( self :: $ startRenderingTime === null ) { self :: $ startRenderingTime = $ this -> renderedAt ; } }
6053	public function retrieveParents ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders/' . $ id . '/parents' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderParent ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
8755	public function buildTracker ( $ numItems = Tracker :: UNKNOWN , array $ extraSubscribers = [ ] ) { $ tracker = new Tracker ( $ numItems ) ; foreach ( array_merge ( $ this -> defaultSubscribers , $ extraSubscribers ) as $ listener ) { $ tracker -> getDispatcher ( ) -> addSubscriber ( $ listener ) ; } return $ tracker ; }
10756	public function map ( $ method , $ route , $ target , $ name = null , $ hostGroup = null , $ prepend = false ) { if ( ! $ hostGroup ) { $ hostGroup = null ; } if ( $ prepend ) { array_unshift ( $ this -> routes , array ( $ method , $ route , $ target , $ name , $ hostGroup ) ) ; } else { $ this -> routes [ ] = array ( $ method , $ route , $ target , $ name , $ hostGroup ) ; } if ( $ name ) { if ( array_key_exists ( $ name , $ this -> namedRoutes ) ) { throw new HaltoRouterException ( "Can not redeclare route $name" ) ; } $ this -> namedRoutes [ $ name ] = array ( $ route , $ hostGroup ) ; } return $ this ; }
5748	public static function removeLastCharsFromString ( string $ input , int $ numChars = 1 ) : string { if ( $ numChars > strlen ( $ input ) ) { throw new \ InvalidArgumentException ( "Cannot remove $numChars from $input" ) ; } return substr ( $ input , 0 , strlen ( $ input ) - $ numChars ) ; }
8070	private function getDomainControllerStrategy ( array $ domain_controller ) { $ protocol = $ this -> ssl ? $ this :: PROTOCOL_SSL : $ this :: PROTOCOL ; if ( count ( $ domain_controller ) === 1 ) { return new SingleDomainController ( $ protocol , $ domain_controller ) ; } if ( $ this -> backup === true ) { return new RebindDomainController ( $ protocol , $ domain_controller ) ; } else { return new LoadBalancingDomainController ( $ protocol , $ domain_controller ) ; } }
2929	public function keyExists ( $ key ) { $ allKeys = $ this -> getKeys ( ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return true ; } return false ; }
10319	function getBlocksCount ( $ fromDate = null , $ toDate = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ reasons = null , $ oldStatus = null , $ newStatus = null , $ excludeAnonymousBlocks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , null , null ) ; if ( isset ( $ excludeAnonymousBlocks ) ) $ params [ 'exclude_anonymous_blocks' ] = ( $ excludeAnonymousBlocks == true ) ? "true" : "false" ; $ params = $ this -> appendArrayFields ( $ params , "reasons" , $ reasons ) ; if ( isset ( $ oldStatus ) ) $ params [ 'old_status' ] = $ oldStatus ; if ( isset ( $ newStatus ) ) $ params [ 'new_status' ] = $ newStatus ; return $ this -> get ( 'reports/blocks/count' , $ params ) ; }
10299	private function writeDataLabels ( XMLWriter $ objWriter , Layout $ chartLayout = null ) { $ objWriter -> startElement ( 'c:dLbls' ) ; $ objWriter -> startElement ( 'c:showLegendKey' ) ; $ showLegendKey = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowLegendKey ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showLegendKey ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showVal' ) ; $ showVal = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowVal ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showVal ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showCatName' ) ; $ showCatName = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowCatName ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showCatName ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showSerName' ) ; $ showSerName = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowSerName ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showSerName ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showPercent' ) ; $ showPercent = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowPercent ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showPercent ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showBubbleSize' ) ; $ showBubbleSize = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowBubbleSize ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showBubbleSize ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showLeaderLines' ) ; $ showLeaderLines = ( empty ( $ chartLayout ) ) ? 1 : $ chartLayout -> getShowLeaderLines ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showLeaderLines ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
9186	protected function mergeParams ( & $ data , $ params ) { foreach ( $ params as $ paramName => $ paramValue ) { if ( is_array ( $ paramValue ) ) { foreach ( $ paramValue as $ key => $ value ) { foreach ( $ value as $ name => $ x ) { $ data [ $ paramName ] [ $ key ] [ $ name ] = $ x ; } } } else { $ data [ $ paramName ] = $ paramValue ; } } }
9435	public function theta ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set theta value, because algebraic form is in use.' ) ; } $ this -> theta = new \ stdClass ( ) ; $ this -> theta -> min = $ float_min ; $ this -> theta -> max = $ float_max ; return $ this ; }
6855	private function transform ( SaleInterface $ sale ) { $ order = $ this -> newOrder ( ) ; $ this -> saleTransformer -> initialize ( $ sale , $ order ) ; if ( null === $ event = $ this -> saleTransformer -> transform ( ) ) { return $ order ; } return null ; }
7725	public function url ( $ text , $ title , $ url ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'title' => $ title , 'url' => $ url ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
8790	public function linkAsset ( $ url , $ title = null , $ attributes = [ ] , $ secure = null ) { $ url = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> link ( $ url , $ title ? : $ url , $ attributes , $ secure ) ; }
6899	public function regenerate ( $ delete_old = false ) { if ( $ this -> is_active ( ) ) { @ session_regenerate_id ( $ delete_old ) ; } else { $ this -> open ( ) ; } return session_id ( ) ; }
268	protected function getContextMessage ( ) { $ context = ArrayHelper :: filter ( $ GLOBALS , $ this -> logVars ) ; foreach ( $ this -> maskVars as $ var ) { if ( ArrayHelper :: getValue ( $ context , $ var ) !== null ) { ArrayHelper :: setValue ( $ context , $ var , '***' ) ; } } $ result = [ ] ; foreach ( $ context as $ key => $ value ) { $ result [ ] = "\${$key} = " . VarDumper :: dumpAsString ( $ value ) ; } return implode ( "\n\n" , $ result ) ; }
1983	public static function hasMessages ( $ strScope = TL_MODE ) { return static :: hasError ( $ strScope ) || static :: hasConfirmation ( $ strScope ) || static :: hasNew ( $ strScope ) || static :: hasInfo ( $ strScope ) || static :: hasRaw ( $ strScope ) ; }
5417	protected function createResponse ( $ socket ) { $ response = new SimpleHttpResponse ( $ socket , $ this -> route -> getUrl ( ) , $ this -> encoding ) ; $ socket -> close ( ) ; return $ response ; }
2410	public function getDbInstallerArray ( ) { $ return = array ( ) ; foreach ( $ this -> arrFields as $ k => $ v ) { if ( \ is_array ( $ v ) ) { if ( ! isset ( $ v [ 'name' ] ) ) { $ v [ 'name' ] = $ k ; } $ return [ 'SCHEMA_FIELDS' ] [ $ k ] = $ v ; } else { $ return [ 'TABLE_FIELDS' ] [ $ k ] = '`' . $ k . '` ' . $ v ; } } $ quote = function ( $ item ) { return '`' . $ item . '`' ; } ; foreach ( $ this -> arrKeys as $ k => $ v ) { if ( strpos ( $ k , ',' ) !== false ) { $ f = array_map ( $ quote , StringUtil :: trimsplit ( ',' , $ k ) ) ; $ k = str_replace ( ',' , '_' , $ k ) ; } else { $ f = array ( $ quote ( $ k ) ) ; } if ( $ v == 'primary' ) { $ k = 'PRIMARY' ; $ v = 'PRIMARY KEY (' . implode ( ', ' , $ f ) . ')' ; } elseif ( $ v == 'index' ) { $ v = 'KEY `' . $ k . '` (' . implode ( ', ' , $ f ) . ')' ; } else { $ v = strtoupper ( $ v ) . ' KEY `' . $ k . '` (' . implode ( ', ' , $ f ) . ')' ; } $ return [ 'TABLE_CREATE_DEFINITIONS' ] [ $ k ] = $ v ; } $ return [ 'TABLE_OPTIONS' ] = '' ; foreach ( $ this -> arrMeta as $ k => $ v ) { if ( $ k == 'engine' ) { $ return [ 'TABLE_OPTIONS' ] .= ' ENGINE=' . $ v ; } elseif ( $ k == 'charset' ) { $ return [ 'TABLE_OPTIONS' ] .= ' DEFAULT CHARSET=' . $ v ; } elseif ( $ k == 'collate' ) { $ return [ 'TABLE_OPTIONS' ] .= ' COLLATE ' . $ v ; } } return $ return ; }
7286	public function getInvoices ( $ filter = null ) { if ( null === $ filter ) { return $ this -> invoices ; } return $ this -> invoices -> filter ( function ( InvoiceInterface $ invoice ) use ( $ filter ) { return $ filter xor InvoiceTypes :: isCredit ( $ invoice ) ; } ) ; }
9099	public function serve ( ServiceCallback $ callback ) { $ this -> bind ( ) ; $ this -> listen ( ) ; $ runOn = true ; while ( $ runOn ) { $ clientHandle = @ socket_accept ( $ this -> handle ) ; if ( ! is_resource ( $ clientHandle ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ address = null ; $ port = 0 ; if ( ! @ socket_getpeername ( $ clientHandle , $ address , $ port ) ) { $ code = socket_last_error ( $ clientHandle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ client = new ClientSocket ( new Endpoint ( $ address , $ port ) , $ clientHandle ) ; $ runOn = boolval ( $ callback -> callback ( $ client ) ) ; } }
4053	private function fetchConditions ( $ inputScreenId ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return $ builder -> select ( 'cond.*' , 'setting.attr_id AS setting_attr_id' ) -> from ( 'tl_metamodel_dcasetting_condition' , 'cond' ) -> leftJoin ( 'cond' , 'tl_metamodel_dcasetting' , 'setting' , 'cond.settingId=setting.id' ) -> leftJoin ( 'setting' , 'tl_metamodel_dca' , 'dca' , 'setting.pid=dca.id' ) -> where ( 'cond.enabled=1' ) -> andWhere ( 'setting.published=1' ) -> andWhere ( 'dca.id=:screenId' ) -> setParameter ( 'screenId' , $ inputScreenId ) -> orderBy ( 'pid' ) -> addOrderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
9579	public function setChannel ( $ channel , LoggerInterface $ logger ) { if ( isset ( $ this -> channels [ $ channel ] ) ) { throw new InvalidArgumentException ( "Channel $channel is already defined" ) ; } $ this -> channels [ $ channel ] = $ logger ; }
3473	public function set ( string $ key , $ value ) : void { $ key = explode ( '.' , $ key ) ; $ last = array_pop ( $ key ) ; $ result = & $ this -> config ; foreach ( $ key as $ part ) { if ( ! isset ( $ result [ $ part ] ) || ! is_array ( $ result [ $ part ] ) ) { $ result [ $ part ] = [ ] ; } $ result = & $ result [ $ part ] ; } $ result [ $ last ] = $ value ; }
11702	public function add ( $ sName , $ mType , $ sLabel = null , $ mValue = null , $ mOptions = null ) { if ( $ mType instanceof Container ) { $ this -> _aElement [ $ sName ] = $ mType ; } else if ( $ mType === 'text' || $ mType === 'submit' || $ mType === 'password' || $ mType === 'file' || $ mType === 'tel' || $ mType === 'url' || $ mType === 'email' || $ mType === 'search' || $ mType === 'date' || $ mType === 'time' || $ mType === 'datetime' || $ mType === 'month' || $ mType === 'week' || $ mType === 'number' || $ mType === 'range' || $ mType === 'color' || $ mType === 'hidden' ) { $ this -> _aElement [ $ sName ] = new Input ( $ sName , $ mType , $ sLabel , $ mValue ) ; } elseif ( $ mType === 'textarea' ) { $ this -> _aElement [ $ sName ] = new Textarea ( $ sName , $ sLabel , $ mValue ) ; } else if ( $ mType === 'select' ) { $ this -> _aElement [ $ sName ] = new Select ( $ sName , $ mOptions , $ sLabel , $ mValue ) ; } else if ( $ mType === 'label' ) { $ this -> _aElement [ $ sName ] = new Label ( $ sName ) ; } else if ( $ mType === 'list_checkbox' ) { $ i = 0 ; $ this -> _aElement [ $ sName . '_' . $ i ++ ] = new Label ( $ sLabel ) ; foreach ( $ mValue as $ mKey => $ sValue ) { $ this -> _aElement [ $ sName . '_' . $ i ++ ] = new Checkbox ( $ sName , $ sValue , $ mKey , $ mOptions ) ; } } else if ( $ mType === 'checkbox' ) { $ this -> _aElement [ $ sName ] = new Checkbox ( $ sName , $ sLabel , $ mValue , $ mOptions ) ; } else if ( $ mType === 'radio' ) { $ this -> _aElement [ $ sName . rand ( 100000 , 999999 ) ] = new Radio ( $ sName , $ sLabel , $ mValue , $ mOptions ) ; } return $ this ; }
8217	public static function getRefererQueryParam ( $ url , $ key ) { if ( ! $ url ) { return null ; } $ query = [ ] ; parse_str ( parse_url ( $ url , PHP_URL_QUERY ) , $ query ) ; if ( isset ( $ query [ $ key ] ) ) { return $ query [ $ key ] ; } return null ; }
4789	function update ( array $ data ) { if ( $ this -> notORM -> freeze ) { return false ; } if ( ! $ data ) { return 0 ; } $ values = array ( ) ; $ parameters = array ( ) ; $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ data as $ key => $ val ) { $ values [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; if ( $ val instanceof NotORM_Literal && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } if ( $ this -> parameters ) { $ parameters = array_merge ( $ parameters , $ this -> parameters ) ; } $ return = $ this -> query ( "UPDATE" . $ this -> topString ( $ this -> limit ) . " $this->table SET " . implode ( ", " , $ values ) . $ this -> whereString ( ) , $ parameters ) ; if ( ! $ return ) { return false ; } return $ return -> rowCount ( ) ; }
3497	public function addDefaultVisitors ( ) : Http20Builder { if ( $ this -> addedDefaultVisitors ) { return $ this ; } $ this -> addedDefaultVisitors = true ; $ this -> addVisitor ( new AddExpirationHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddPriorityHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddApnIdHeaderVisitor ( ) ) ; $ this -> addVisitor ( new AddCollapseIdHeaderVisitor ( ) ) ; return $ this ; }
11590	public static function title ( $ title , $ pad = '=' ) { $ rest = ( int ) ( 78 - mb_strlen ( $ title ) ) / 2 ; $ result = "\n\n" ; $ result .= str_repeat ( $ pad , $ rest ) ; $ result .= ' ' . $ title . ' ' ; $ result .= str_repeat ( $ pad , $ rest ) ; $ result .= "\n\n" ; return $ result ; }
2883	public function getRequestInfo ( ) { if ( $ this -> requestInfo === null ) { $ this -> requestInfo = Mage :: getModel ( 'sheep_debug/requestInfo' ) ; } return $ this -> requestInfo ; }
7504	public function getTf ( string $ key , array $ args = null , array $ replacements = null , string ... $ namespaces ) { if ( empty ( $ namespaces ) ) { $ namespaces = $ this -> meta -> getNamespaces ( ) ; } $ translatedText = $ this -> textService -> tf ( $ namespaces , $ key , $ args , ... $ this -> meta -> getN2nLocales ( ) ) ; $ replacedText = HtmlBuilderMeta :: replace ( $ translatedText , $ replacements , $ this -> view ) ; return new Raw ( $ replacedText ) ; }
6620	public function getChildController ( $ controllerName ) { $ methodName = $ this -> parseControllerName ( $ controllerName ) ; if ( ! $ this -> reflection -> hasMethod ( $ methodName ) ) { throw new \ RuntimeException ( "{$this->reflection->getName()}::{$methodName} does not exist" ) ; } $ controller = $ this -> reflection -> getMethod ( $ methodName ) -> invokeArgs ( $ this -> controller , [ ] ) ; if ( ! is_object ( $ controller ) || ! $ controller instanceof Controller ) { throw new \ RuntimeException ( "{$this->reflection->getName()}::{$methodName} did not return a Controller" ) ; } return $ controller ; }
4108	public function getSkinFileContent ( $ file ) { $ package = Mage :: getSingleton ( 'core/design_package' ) ; $ areaBackup = $ package -> getArea ( ) ; $ path = $ package -> setArea ( 'frontend' ) -> getFilename ( $ file , array ( '_type' => 'skin' ) ) ; $ content = file_get_contents ( $ path ) ; $ package -> setArea ( $ areaBackup ) ; return $ content ; }
10410	public function createUrlsTempFile ( ) { $ hash = md5 ( microtime ( true ) ) ; $ links = array_merge ( $ this -> getUrls ( ) , $ this -> getUrlsByDocumentParameter ( ) ) ; $ urlsFile = "/tmp/urls_{$hash}.txt" ; $ urls = [ ] ; foreach ( $ links as $ url ) { $ separator = ( $ url [ 0 ] !== '/' ) ? '/' : '' ; $ urls [ ] = $ this -> baseUrl . $ separator . $ url ; } file_put_contents ( $ urlsFile , implode ( PHP_EOL , $ urls ) ) ; return $ urlsFile ; }
10641	public function andWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
2841	public function renderArray ( $ data , $ noDataLabel = 'No Data' , $ header = null ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ block -> setTemplate ( 'sheep_debug/view/panel/_array.phtml' ) ; $ block -> setData ( 'array' , $ data ) ; $ block -> setData ( 'no_data_label' , $ noDataLabel ) ; $ block -> setData ( 'header' , $ header ) ; return $ block -> toHtml ( ) ; }
12739	public function removeClass ( $ name ) { $ classParts = explode ( ' ' , $ this -> tags [ 'class' ] ) ; $ className = '' ; foreach ( $ classParts as $ part ) { if ( $ name != $ part ) { $ className .= ' ' . $ part ; } } $ this -> tags [ 'class' ] = trim ( $ className ) ; }
1994	public static function indexPageIfApplicable ( Response $ objResponse ) { global $ objPage ; if ( $ objPage === null ) { return ; } if ( Config :: get ( 'enableSearch' ) && $ objResponse -> getStatusCode ( ) == 200 && ! BE_USER_LOGGED_IN && ! $ objPage -> noSearch ) { if ( Config :: get ( 'indexProtected' ) || ( ! FE_USER_LOGGED_IN && ! $ objPage -> protected ) ) { $ blnIndex = true ; foreach ( array_keys ( $ _GET ) as $ key ) { if ( \ in_array ( $ key , $ GLOBALS [ 'TL_NOINDEX_KEYS' ] ) || strncmp ( $ key , 'page_' , 5 ) === 0 ) { $ blnIndex = false ; break ; } } if ( $ blnIndex ) { $ arrData = array ( 'url' => Environment :: get ( 'base' ) . Environment :: get ( 'relativeRequest' ) , 'content' => $ objResponse -> getContent ( ) , 'title' => $ objPage -> pageTitle ? : $ objPage -> title , 'protected' => ( $ objPage -> protected ? '1' : '' ) , 'groups' => $ objPage -> groups , 'pid' => $ objPage -> id , 'language' => $ objPage -> language ) ; Search :: indexPage ( $ arrData ) ; } } } }
5795	public function insert ( array $ columnValues , bool $ addBooleanColumnFalse = false ) { if ( $ addBooleanColumnFalse ) { $ columnValues = $ this -> addBooleanColumnFalse ( $ columnValues ) ; } $ ib = new InsertBuilder ( $ this -> tableName ) ; if ( $ this -> getPrimaryKeyColumnName ( ) !== null ) { $ ib -> setPrimaryKeyName ( $ this -> getPrimaryKeyColumnName ( ) ) ; } $ this -> addColumnsToBuilder ( $ ib , $ columnValues ) ; return $ ib -> runExecute ( ) ; }
8436	public static function fetchArray ( array $ conditions , array $ orderBy = null , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( $ entity -> getAllFieldsRealNames ( ) ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( is_array ( $ orderBy ) && count ( $ orderBy ) > 0 ) { $ orders = array ( ) ; foreach ( $ orderBy as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ orders [ $ realName ] = strtoupper ( ucfirst ( $ value ) ) ; } $ selectQuery -> orderBy ( $ orders ) ; } $ selectQuery -> limit ( 1 ) ; if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( is_array ( $ data ) === false ) { return false ; } return $ data ; }
6080	public function updateProperties ( $ id , array $ properties ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'properties' => $ properties ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/media/' . $ id . '/properties' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
8693	public static function createSymlink ( $ symlinkTarget , $ symlinkName ) { if ( false === @ symlink ( $ symlinkTarget , $ symlinkName ) ) { throw new \ UnexpectedValueException ( "An error occurred while creating symlink '{$symlinkName}'" ) ; } if ( false === $ target = readlink ( $ symlinkName ) ) { throw new \ UnexpectedValueException ( "Symlink {$symlinkName} points to target {$target}" ) ; } }
8548	public function setServiceProviderCreditEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ServiceProviderCreditEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1586	public function pointer ( string $ key , string $ prefix = '' ) : string { $ prefix = rtrim ( $ prefix , '/' ) ; if ( 'type' === $ key ) { return $ prefix . '/type' ; } if ( 'id' === $ key ) { return $ prefix . '/id' ; } $ parts = collect ( explode ( '.' , $ key ) ) ; $ field = $ parts -> first ( ) ; if ( $ this -> isAttribute ( $ field ) ) { return $ prefix . '/attributes/' . $ parts -> implode ( '/' ) ; } if ( $ this -> isRelationship ( $ field ) ) { $ name = 1 < $ parts -> count ( ) ? $ field . '/' . $ parts -> put ( 0 , 'data' ) -> implode ( '/' ) : $ field ; return $ prefix . "/relationships/{$name}" ; } return $ prefix ? $ prefix : '/' ; }
9975	private static function fillBuiltInFormatCodes ( ) { if ( self :: $ builtInFormats === null ) { self :: $ builtInFormats = [ ] ; self :: $ builtInFormats [ 0 ] = self :: FORMAT_GENERAL ; self :: $ builtInFormats [ 1 ] = '0' ; self :: $ builtInFormats [ 2 ] = '0.00' ; self :: $ builtInFormats [ 3 ] = '#,##0' ; self :: $ builtInFormats [ 4 ] = '#,##0.00' ; self :: $ builtInFormats [ 9 ] = '0%' ; self :: $ builtInFormats [ 10 ] = '0.00%' ; self :: $ builtInFormats [ 11 ] = '0.00E+00' ; self :: $ builtInFormats [ 12 ] = '# ?/?' ; self :: $ builtInFormats [ 13 ] = '# ??/??' ; self :: $ builtInFormats [ 14 ] = 'm/d/yyyy' ; self :: $ builtInFormats [ 15 ] = 'd-mmm-yy' ; self :: $ builtInFormats [ 16 ] = 'd-mmm' ; self :: $ builtInFormats [ 17 ] = 'mmm-yy' ; self :: $ builtInFormats [ 18 ] = 'h:mm AM/PM' ; self :: $ builtInFormats [ 19 ] = 'h:mm:ss AM/PM' ; self :: $ builtInFormats [ 20 ] = 'h:mm' ; self :: $ builtInFormats [ 21 ] = 'h:mm:ss' ; self :: $ builtInFormats [ 22 ] = 'm/d/yyyy h:mm' ; self :: $ builtInFormats [ 37 ] = '#,##0_);(#,##0)' ; self :: $ builtInFormats [ 38 ] = '#,##0_);[Red](#,##0)' ; self :: $ builtInFormats [ 39 ] = '#,##0.00_);(#,##0.00)' ; self :: $ builtInFormats [ 40 ] = '#,##0.00_);[Red](#,##0.00)' ; self :: $ builtInFormats [ 44 ] = '_("$"* #,##0.00_);_("$"* \(#,##0.00\);_("$"* "-"??_);_(@_)' ; self :: $ builtInFormats [ 45 ] = 'mm:ss' ; self :: $ builtInFormats [ 46 ] = '[h]:mm:ss' ; self :: $ builtInFormats [ 47 ] = 'mm:ss.0' ; self :: $ builtInFormats [ 48 ] = '##0.0E+0' ; self :: $ builtInFormats [ 49 ] = '@' ; self :: $ builtInFormats [ 27 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 30 ] = 'm/d/yy' ; self :: $ builtInFormats [ 36 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 50 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 57 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 59 ] = 't0' ; self :: $ builtInFormats [ 60 ] = 't0.00' ; self :: $ builtInFormats [ 61 ] = 't#,##0' ; self :: $ builtInFormats [ 62 ] = 't#,##0.00' ; self :: $ builtInFormats [ 67 ] = 't0%' ; self :: $ builtInFormats [ 68 ] = 't0.00%' ; self :: $ builtInFormats [ 69 ] = 't# ?/?' ; self :: $ builtInFormats [ 70 ] = 't# ??/??' ; self :: $ flippedBuiltInFormats = array_flip ( self :: $ builtInFormats ) ; } }
7731	public function supportsNormalization ( $ data , $ format = null ) { return is_object ( $ data ) && ( $ data instanceof \ DateTime ) && ( self :: FORMAT === $ format ) ; }
4916	public function setValue ( $ value ) { if ( ! $ value ) { if ( ! $ this -> getName ( ) ) { throw new \ InvalidArgumentException ( 'Value must not be empty.' ) ; } $ value = self :: filterValue ( $ this -> getName ( ) ) ; } $ this -> value = ( string ) $ value ; return $ this ; }
1542	protected function query ( $ query ) { return new CursorBuilder ( $ query , $ this -> column , $ this -> identifier , $ this -> descending ) ; }
10123	private function writePrintGridlines ( ) { $ record = 0x002b ; $ length = 0x0002 ; $ fPrintGrid = $ this -> phpSheet -> getPrintGridlines ( ) ? 1 : 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fPrintGrid ) ; $ this -> append ( $ header . $ data ) ; }
2126	protected function handleCss ( $ content , $ arrFile ) { $ content = $ this -> fixPaths ( $ content , $ arrFile ) ; if ( $ arrFile [ 'media' ] != '' && $ arrFile [ 'media' ] != 'all' && strpos ( $ content , '@media' ) === false ) { $ content = '@media ' . $ arrFile [ 'media' ] . "{\n" . $ content . "\n}" ; } return $ content ; }
10206	public function setReadOrder ( $ pValue ) { if ( $ pValue < 0 || $ pValue > 2 ) { $ pValue = 0 ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'readOrder' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> readOrder = $ pValue ; } return $ this ; }
6672	public function restart_all_ratings ( ) { $ nonce = isset ( $ _POST [ 'nonce' ] ) ? $ _POST [ 'nonce' ] : '' ; if ( ! wp_verify_nonce ( $ nonce , 'eliasis' ) && ! wp_verify_nonce ( $ nonce , 'customRatingGrifusAdmin' ) ) { die ( 'Busted!' ) ; } $ response [ 'ratings_restarted' ] = 0 ; $ posts = $ this -> model -> get_posts ( ) ; foreach ( $ posts as $ post ) { if ( isset ( $ post -> ID ) && ! $ this -> model -> get_movie_votes ( $ post -> ID ) ) { $ this -> set_rating_and_votes ( $ post -> ID , $ this -> get_default_votes ( $ post -> ID ) ) ; $ response [ 'ratings_restarted' ] ++ ; } } echo json_encode ( $ response ) ; die ( ) ; }
12366	public function getNextVideoToConvert ( ) { $ query = $ this -> createQueryBuilder ( 'v' ) ; $ this -> onlyUploaded ( $ query ) ; return $ query -> getQuery ( ) -> getOneOrNullResult ( ) ; }
6050	public function addPropertyResponse ( $ item ) { if ( ! ( $ item instanceof PropertyResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertyResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertyResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertyResponse"!' , E_USER_WARNING ) ; } } $ this -> properties [ ] = $ item ; return $ this ; }
6489	private function addHeaderValue ( HttpHeaders $ headers , string $ name , $ value , bool $ append ) : void { $ decodedValue = trim ( ( string ) ( isset ( self :: $ headersToUrlDecode [ $ name ] ) ? urldecode ( $ value ) : $ value ) ) ; if ( isset ( self :: $ specialCaseHeaders [ $ name ] ) ) { $ headers -> add ( $ name , $ decodedValue , $ append ) ; } elseif ( strpos ( $ name , 'HTTP_' ) === 0 ) { $ normalizedName = substr ( $ name , 5 ) ; $ headers -> add ( $ normalizedName , $ decodedValue , $ append ) ; } }
8282	public function onPageRendering ( & $ templateName , array & $ twigVariables ) { $ twigVariables [ 'auth' ] [ 'plugin' ] = $ this ; $ twigVariables [ 'auth' ] [ 'vars' ] = $ this -> output ; if ( ! $ this -> errorOccurred ) { $ twigVariables [ 'auth' ] [ 'user' ] = $ this -> user ; $ old = $ this -> session -> getFlash ( 'old' ) ; if ( count ( $ old ) && isset ( $ old [ 0 ] ) ) { $ twigVariables [ 'auth' ] [ 'old' ] = $ old [ 0 ] ; } } }
11643	public function getFormatter ( ) { if ( $ this -> _formatter === null ) { $ this -> _formatter = Yii :: $ app -> format ; } return $ this -> _formatter ; }
10005	public function setRibbonXMLData ( $ target , $ xmlData ) { if ( $ target !== null && $ xmlData !== null ) { $ this -> ribbonXMLData = [ 'target' => $ target , 'data' => $ xmlData ] ; } else { $ this -> ribbonXMLData = null ; } }
1219	private function debugRequest ( $ url , array $ headers , $ body ) { $ str = $ url . PHP_EOL ; $ str .= array_reduce ( array_keys ( $ headers ) , function ( $ str , $ key ) use ( $ headers ) { $ str .= $ key . ': ' . $ headers [ $ key ] . PHP_EOL ; return $ str ; } , '' ) ; $ str .= $ body ; $ this -> debug ( $ str ) ; }
7114	static public function isBetterMode ( $ modeA , $ modeB ) { if ( $ modeA === static :: MODE_DISABLED ) { return $ modeB !== static :: MODE_DISABLED ; } elseif ( $ modeA === static :: MODE_JUST_IN_TIME ) { return in_array ( $ modeB , [ static :: MODE_MANUAL , static :: MODE_AUTO ] , true ) ; } return false ; }
10148	private function readMsoDrawingGroup ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingGroupData .= $ recordData ; }
8327	public function recognizeRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra = [ ] ) { $ captchaId = $ this -> sendRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra ) ; $ startTime = time ( ) ; while ( true ) { $ this -> getLogger ( ) -> info ( "Waiting {$this->rTimeout} sec." ) ; sleep ( $ this -> recaptchaRTimeout ) ; if ( time ( ) - $ startTime >= $ this -> mTimeout ) { throw new RuntimeException ( "Captcha waiting timeout." ) ; } $ result = $ this -> getCaptchaResult ( $ captchaId ) ; if ( $ result === false ) { continue ; } $ this -> getLogger ( ) -> info ( "Elapsed " . ( time ( ) - $ startTime ) . " second(s)." ) ; return $ result ; } throw new RuntimeException ( 'Unknown recognition logic error.' ) ; }
4802	protected function locateDirectory ( string $ name ) : ? string { $ parts = [ $ name ] ; foreach ( Database :: COLLECTION_SEPARATOR_CHARACTERS as $ char ) { if ( ! strstr ( $ name , $ char ) ) { continue ; } $ parts = explode ( $ char , $ name ) ; break ; } return $ this -> recurseLocateDirectory ( $ parts ) ; }
6682	private function setSecurityHeaders ( ) { $ headers = Yii :: $ app -> response -> headers ; $ headers -> add ( 'X-Frame-Options' , 'DENY' ) ; $ headers -> add ( 'X-XSS-Protection' , '1' ) ; }
3359	public function preview ( $ width , $ height ) { if ( ! $ width || ! $ height ) { throw new \ Exception ( 'Please, provide both width and height for preview' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'preview' ] = array ( 'width' => $ width , 'height' => $ height , ) ; return $ result ; }
12425	public function getAuthorizerToken ( $ appId , $ refreshToken ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ appId , 'authorizer_refresh_token' => $ refreshToken , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_TOKEN , $ params ] ) ; }
11456	public function batchDeviceSummary ( $ timestamp , $ pageIndex ) { $ params = [ 'date' => $ timestamp , 'page_index' => $ pageIndex , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_LIST , $ params ] ) ; }
11283	protected function _populateAttributes ( $ record ) { foreach ( $ this -> model_attributes as $ key => $ def ) { if ( isset ( $ record [ $ this -> getFieldName ( $ key ) ] ) ) { $ fieldName = $ this -> getFieldName ( $ key ) ; if ( \ Cora \ Gateway :: is_serialized ( $ record [ $ fieldName ] ) ) { $ value = unserialize ( $ record [ $ fieldName ] ) ; } else if ( isset ( $ def [ 'type' ] ) && ( $ def [ 'type' ] == 'date' || $ def [ 'type' ] == 'datetime' ) ) { $ value = new \ DateTime ( $ record [ $ fieldName ] ) ; } else { $ value = $ record [ $ fieldName ] ; } $ this -> beforeSet ( $ key , $ value ) ; $ this -> model_data [ $ key ] = $ value ; $ this -> afterSet ( $ key , $ value ) ; } else if ( isset ( $ def [ 'models' ] ) || ( isset ( $ def [ 'model' ] ) && isset ( $ def [ 'usesRefTable' ] ) ) ) { if ( ! isset ( $ this -> model_data [ $ key ] ) ) $ this -> model_data [ $ key ] = 1 ; } } }
9743	public function setCountry ( $ country ) { if ( ! ( $ country instanceof Country ) ) { $ country = new Country ( $ country ) ; } if ( $ country -> isEmpty ( ) ) { $ this -> invalidArguments ( '10001' ) ; } return $ this -> setParameter ( 'country' , $ country ) ; }
6231	public function used ( ) { return $ this -> core -> api ( ) -> response ( $ this -> makeContainer ( $ this -> core -> auth ( ) -> getAllPermissions ( ) ) ) ; }
1659	public static function create ( $ reply = null ) { $ suggestion = new self ( ) ; if ( $ reply ) { $ suggestion -> reply ( $ reply ) ; } return $ suggestion ; }
4443	public function multiget ( array $ jids ) : array { if ( empty ( $ jids ) ) { return [ ] ; } $ results = call_user_func_array ( [ $ this -> client , 'multiget' ] , $ jids ) ; $ jobs = json_decode ( $ results , true ) ? : [ ] ; $ ret = [ ] ; foreach ( $ jobs as $ data ) { $ job = new BaseJob ( $ this -> client , $ data ) ; $ job -> setEventsManager ( $ this -> client -> getEventsManager ( ) ) ; $ ret [ $ job -> jid ] = $ job ; } return $ ret ; }
5360	protected function createBodyStatements ( Operation $ operation , $ queryParamVariable , Context $ context ) { $ bodyParameter = null ; $ bodyVariable = new Expr \ Variable ( 'body' ) ; $ parameterKey = 0 ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ bodyParameter = $ parameter ; $ parameterKey = $ key ; } } } if ( null === $ bodyParameter ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( $ queryParamVariable , 'buildFormDataString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] , $ bodyVariable ] ; } if ( $ bodyParameter -> getSchema ( ) instanceof Reference || $ context -> getRegistry ( ) -> hasClass ( $ operation -> getReference ( ) . '/parameters/' . $ parameterKey ) ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( new Expr \ PropertyFetch ( new Expr \ Variable ( 'this' ) , 'serializer' ) , 'serialize' , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) , new Arg ( new Scalar \ String_ ( 'json' ) ) ] ) ) ] , $ bodyVariable ] ; } return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) ] , $ bodyVariable ] ; }
1832	public function onRegister ( Registry $ registry ) { foreach ( static :: getUniqueFields ( ) as $ strColumn ) { $ varAliasValue = $ this -> { $ strColumn } ; if ( ! $ registry -> isRegisteredAlias ( $ this , $ strColumn , $ varAliasValue ) ) { $ registry -> registerAlias ( $ this , $ strColumn , $ varAliasValue ) ; } } }
5102	public function asSelect ( ICmdSelect $ select ) { $ this -> setPart ( CmdInsert :: PART_VALUES , false ) ; return $ this -> setPart ( CmdInsert :: PART_AS , $ select -> assemble ( ) , $ select -> bind ( ) ) ; }
12289	private function make ( string $ block , array $ vars = null ) : string { $ commonVars = static :: COMMON_NAME . static :: VARS_PROPERTY_SUFFIX ; $ blockVars = $ block . static :: VARS_PROPERTY_SUFFIX ; $ allVars = [ ] ; if ( isset ( $ this -> $ commonVars ) && is_array ( $ this -> $ commonVars ) ) { $ allVars = $ this -> $ commonVars ; } if ( isset ( $ this -> $ blockVars ) && is_array ( $ this -> $ blockVars ) ) { $ allVars += $ this -> $ blockVars ; } if ( isset ( $ vars ) ) { $ allVars += $ vars ; } $ file = $ this -> path . $ this -> { $ block . static :: BLOCK_PROPERTY_SUFFIX } . '.' . static :: FILE_EXTENSION ; $ localScope = function ( $ vars , $ file ) { ob_start ( ) ; extract ( $ vars ) ; try { require $ file ; } catch ( \ Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } $ _ = isset ( $ _ ) ? str_pad ( '' , $ _ ) : '' ; return str_replace ( PHP_EOL , PHP_EOL . $ _ , PHP_EOL . ob_get_clean ( ) ) ; } ; return $ localScope ( $ allVars , $ file ) ; }
12900	public function offsetGet ( $ offset ) { if ( $ offset === 'headers' ) { $ headers = [ 'HTTP/' . $ this -> getResponse ( ) -> getProtocolVersion ( ) . ' ' . $ this -> getResponse ( ) -> getStatusCode ( ) . ' ' . $ this -> getResponse ( ) -> getReasonPhrase ( ) ] ; foreach ( $ this -> getResponse ( ) -> getHeaders ( ) as $ header => $ values ) { foreach ( $ values as $ value ) { $ headers [ ] = $ header . ': ' . $ value ; } } return $ headers ; } }
10702	public static function getPasswordComplexity ( $ password , $ minLength ) { $ group = [ 'upper' => '/[A-Z]/' , 'lower' => '/[a-z]/' , 'number' => '/[0-9]/' , 'special' => '/[^A-Za-z0-9]/' , ] ; $ score = 0 ; $ length = \ strlen ( $ password ) ; if ( $ length < $ minLength ) { return 0 ; } foreach ( $ group as $ pattern ) { if ( preg_match ( $ pattern , $ password ) ) { $ score ++ ; } } if ( $ score < 3 ) { $ score -- ; } if ( $ length > $ minLength ) { $ score += ( int ) floor ( ( $ length - $ minLength ) / 2 ) ; } return $ score ; }
12934	public function move ( $ baseDir , array $ options , $ username ) { $ this -> resolveMoveOptions ( $ options ) ; if ( array_key_exists ( "targetSlot" , $ options ) ) { $ options [ "slot" ] = $ options [ "targetSlot" ] ; $ block = $ this -> moveBlockToAnotherSlot ( $ baseDir , $ options , $ username ) ; return $ block ; } $ options [ "slot" ] = $ options [ "sourceSlot" ] ; $ block = $ this -> moveBlockToSameSlot ( $ baseDir , $ options , $ username ) ; return $ block ; }
11999	static protected function phalconQuery ( $ modelName , $ field , $ generate ) { $ return = \ Phalcon \ Mvc \ Model :: query ( ) -> setModelName ( $ modelName ) -> where ( "$field = :value:" ) -> bind ( array ( 'value' => $ generate ) ) -> execute ( ) ; return ( boolean ) $ return -> count ( ) ; }
11004	public function getPath ( $ url ) { $ url = new URL ( $ url ) ; $ to_replace = $ this -> url -> path ; $ path = $ url -> path ; if ( strpos ( $ path , $ to_replace ) === 0 ) $ path = substr ( $ path , strlen ( $ to_replace ) ) ; $ path = '/' . urldecode ( $ path ) ; return $ path ; }
9465	public function getSummary ( ) { $ string = "---\n" ; foreach ( $ this -> getWords ( ) as $ k => $ v ) { $ string .= '[' . $ k . ']: Docs:' . $ v [ 'docs' ] . ' | Hits:' . $ v [ 'hits' ] . "\n" ; } return $ string ; }
7387	public static final function generateThumbnailsFrom ( $ files , array $ size ) { foreach ( $ files as $ file ) { self :: generateThumbnail ( $ file -> getRecord ( ) , $ size ) ; } }
12041	public function getFullName ( $ first = NULL , $ middle = NULL , $ last = NULL ) { $ user_first_name = $ this -> getPropertyValue ( "user_first_name" ) ; $ user_middle_name = $ this -> getPropertyValue ( "user_middle_name" ) ; $ user_last_name = $ this -> getPropertyValue ( "user_last_name" ) ; $ user_full_name = implode ( ' ' , array ( empty ( $ user_first_name ) ? $ first : $ user_first_name , empty ( $ user_middle_name ) ? $ middle : $ user_middle_name , empty ( $ user_last_name ) ? $ last : $ user_last_name ) ) ; if ( ! empty ( $ user_full_name ) ) { return $ user_full_name ; } }
6204	public function onError ( $ type , $ message , $ file = null , $ line = null , $ context = null ) { if ( ini_get ( 'error_reporting' ) == 0 ) { return true ; } if ( isset ( $ this -> fatalErrors [ $ type ] ) ) { throw new Exception ( $ message ) ; } if ( $ this -> shouldNotifyError ( $ type , $ message , $ file , $ line , $ context ) ) { $ backtrace = debug_backtrace ( ) ; array_shift ( $ backtrace ) ; $ this -> airbrakeClient -> notifyOnError ( $ message , $ backtrace ) ; return true ; } return true ; }
3267	protected function openFile ( int $ mode ) : SplFileObject { $ path = $ this -> getPath ( ) ; if ( ! is_file ( $ path ) && ! @ touch ( $ path ) ) { throw new Exception ( 'Could not create file: ' . $ path ) ; } if ( ! is_readable ( $ path ) || ! is_writable ( $ path ) ) { throw new Exception ( 'File does not have permission for read and write: ' . $ path ) ; } if ( $ this -> getConfig ( ) -> useGzip ( ) ) { $ path = 'compress.zlib://' . $ path ; } $ res = $ this -> fileAccessMode [ $ mode ] ; $ file = new SplFileObject ( $ path , $ res [ 'mode' ] ) ; if ( $ mode === self :: FILE_READ ) { $ file -> setFlags ( SplFileObject :: DROP_NEW_LINE | SplFileObject :: SKIP_EMPTY | SplFileObject :: READ_AHEAD ) ; } if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( $ res [ 'operation' ] ) ) { $ file = null ; throw new Exception ( 'Could not lock file: ' . $ path ) ; } return $ file ; }
6407	public static function filter ( IteratorAggregate $ unfiltered , callable $ predicate ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ unfiltered , $ predicate ) { return Iterators :: filter ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ predicate ) ; } ) ; }
5953	public function channelList ( array $ filter = array ( ) ) { if ( $ this -> channelList === null ) { $ channels = $ this -> request ( "channellist -topic -flags -voice -limits -icon" ) -> toAssocArray ( "cid" ) ; $ this -> channelList = array ( ) ; foreach ( $ channels as $ cid => $ channel ) { $ this -> channelList [ $ cid ] = new Channel ( $ this , $ channel ) ; } $ this -> resetNodeList ( ) ; } return $ this -> filterList ( $ this -> channelList , $ filter ) ; }
5632	protected function removeTrailingSlash ( $ path ) { if ( substr ( $ path , - 1 ) == DIRECTORY_SEPARATOR ) { return substr ( $ path , 0 , - 1 ) ; } elseif ( substr ( $ path , - 1 ) == '/' ) { return substr ( $ path , 0 , - 1 ) ; } else { return $ path ; } }
6927	protected function notify ( $ type , $ resource ) { $ notify = $ this -> builder -> create ( $ type , $ resource ) ; if ( ! $ this -> builder -> build ( $ notify ) ) { return ; } $ this -> queue -> add ( $ notify ) ; }
2231	protected function hasUser ( ) : bool { $ user = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ user ) { return false ; } return ! ( $ user instanceof AnonymousToken ) ; }
16	public static function getContentHash ( $ composerFileContents ) { $ content = json_decode ( $ composerFileContents , true ) ; $ relevantKeys = array ( 'name' , 'version' , 'require' , 'require-dev' , 'conflict' , 'replace' , 'provide' , 'minimum-stability' , 'prefer-stable' , 'repositories' , 'extra' , ) ; $ relevantContent = array ( ) ; foreach ( array_intersect ( $ relevantKeys , array_keys ( $ content ) ) as $ key ) { $ relevantContent [ $ key ] = $ content [ $ key ] ; } if ( isset ( $ content [ 'config' ] [ 'platform' ] ) ) { $ relevantContent [ 'config' ] [ 'platform' ] = $ content [ 'config' ] [ 'platform' ] ; } ksort ( $ relevantContent ) ; return md5 ( json_encode ( $ relevantContent ) ) ; }
6950	private function getByCountryAndBusinessQuery ( ) { if ( null === $ this -> byCountryAndBusinessQuery ) { $ qb = $ this -> getBaseQueryBuilder ( ) ; $ this -> byCountryAndBusinessQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'r.business' , ':business' ) ) -> getQuery ( ) -> setParameter ( 'business' , true ) -> setMaxResults ( 1 ) ; } return $ this -> byCountryAndBusinessQuery ; }
9045	protected function getConfig ( ) { if ( $ this -> config === null ) { if ( file_exists ( $ this -> filename ) ) { $ this -> filename = realpath ( $ this -> filename ) ; $ this -> config = new Config ( include $ this -> filename , true ) ; } else { $ this -> filename = getcwd ( ) . $ this -> filename ; $ this -> config = new Config ( [ ] , true ) ; } } return $ this -> config ; }
4405	public function generate ( InputInterface $ input , OutputInterface $ output ) { $ fileSystem = $ this -> container -> get ( 'filesystem' ) ; $ configResolver = $ this -> container -> get ( 'ezpublish.config.resolver' ) ; $ kernelRootDir = $ this -> container -> getParameter ( 'kernel.root_dir' ) ; $ siteAccessGroup = $ input -> getOption ( 'site-access-group' ) ; $ varDir = $ configResolver -> getParameter ( 'var_dir' , null , $ siteAccessGroup ) ; $ repository = $ configResolver -> getParameter ( 'repository' , null , $ siteAccessGroup ) ; $ configFile = $ kernelRootDir . '/config/ngadminui.yml' ; if ( $ fileSystem -> exists ( $ configFile ) ) { if ( ! $ this -> questionHelper -> ask ( $ input , $ output , new ConfirmationQuestion ( '<info><comment>ngadminui.yml</comment> configuration file already exists. Do you want to overwrite it?</info> [<comment>no</comment>] ' , false ) ) ) { return ; } } $ siteAccessName = $ input -> getOption ( 'site-access-name' ) ; $ languageService = $ this -> container -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; $ languages = $ languageService -> loadLanguages ( ) ; $ settings = array ( 'parameters' => array ( 'netgen_admin_ui.' . $ siteAccessName . '.is_admin_ui_siteaccess' => true , 'eztags.' . $ siteAccessName . '.routing.enable_tag_router' => false , 'ezsettings.' . $ siteAccessName . '.treemenu.http_cache' => false , ) , 'ezpublish' => array ( 'siteaccess' => array ( 'list' => array ( $ siteAccessName , ) , 'groups' => array ( 'ngadminui' => array ( $ siteAccessName , ) , ) , 'match' => array ( 'Map\URI' => array ( $ siteAccessName => $ siteAccessName , ) , ) , ) , 'system' => array ( $ siteAccessName => array ( 'user' => array ( 'layout' => '@NetgenAdminUI/pagelayout_login.html.twig' , 'login_template' => '@NetgenAdminUI/user/login.html.twig' , ) , 'languages' => array_map ( function ( Language $ language ) { return $ language -> languageCode ; } , $ languages ) , 'var_dir' => $ varDir , 'repository' => $ repository , ) , ) , ) , 'ez_publish_legacy' => array ( 'system' => array ( $ siteAccessName => array ( 'templating' => array ( 'view_layout' => '@NetgenAdminUI/pagelayout_legacy.html.twig' , 'module_layout' => '@NetgenAdminUI/pagelayout_module.html.twig' , ) , ) , ) , ) , ) ; file_put_contents ( $ configFile , Yaml :: dump ( $ settings , 7 ) ) ; $ output -> writeln ( array ( '' , 'Generated <comment>ngadminui.yml</comment> configuration file!' , '' , ) ) ; }
9074	protected function getRouteInformation ( Route $ route ) { return $ this -> filterRoute ( [ 'name' => $ route -> getName ( ) , 'isAuthorized' => $ this -> isAuthorized ( $ route ) , ] ) ; }
2443	public static function encrypt ( $ varValue , $ strKey = null ) { if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: encrypt ( $ v ) ; } return $ varValue ; } elseif ( $ varValue == '' ) { return '' ; } if ( static :: $ resTd === null ) { static :: initialize ( ) ; } if ( ! $ strKey ) { $ strKey = System :: getContainer ( ) -> getParameter ( 'contao.encryption_key' ) ; } $ iv = mcrypt_create_iv ( mcrypt_enc_get_iv_size ( static :: $ resTd ) ) ; mcrypt_generic_init ( static :: $ resTd , md5 ( $ strKey ) , $ iv ) ; $ strEncrypted = mcrypt_generic ( static :: $ resTd , $ varValue ) ; $ strEncrypted = base64_encode ( $ iv . $ strEncrypted ) ; mcrypt_generic_deinit ( static :: $ resTd ) ; return $ strEncrypted ; }
9100	private function bind ( ) { if ( ! @ socket_bind ( $ this -> handle , $ this -> endpoint -> getAddress ( ) , $ this -> endpoint -> getPort ( ) ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
3968	protected function createAttributeInstance ( ModelInterface $ model = null ) { if ( null === $ model ) { return null ; } return $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ this -> getMetaModelByModelPid ( $ model ) ) ; }
2575	protected function loadRequestCreatorParams ( $ params ) { if ( isset ( $ params [ 'requestCreatorParams' ] ) ) { if ( $ params [ 'requestCreatorParams' ] instanceof RequestCreatorParams ) { $ this -> requestCreatorParams = $ params [ 'requestCreatorParams' ] ; } elseif ( is_array ( $ params [ 'requestCreatorParams' ] ) ) { $ this -> requestCreatorParams = new RequestCreatorParams ( $ params [ 'requestCreatorParams' ] ) ; } } }
4545	public function setSortBy ( ? string $ sortBy ) { $ this -> sortBy = $ sortBy ; $ this -> _sortBy = null !== $ sortBy ; return $ this ; }
4049	public function fetchInputScreens ( $ idList ) : array { $ idList = array_filter ( $ idList ) ; $ builder = $ this -> connection -> createQueryBuilder ( ) ; $ screens = $ builder -> select ( 'd.*' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel' , 'm' , 'm.id=d.pid' ) -> where ( $ builder -> expr ( ) -> in ( 'd.id' , ':idList' ) ) -> setParameter ( 'idList' , $ idList , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'm.sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; $ keys = array_flip ( $ idList ) ; foreach ( $ screens as $ screen ) { $ metaModelName = $ keys [ $ screen [ 'id' ] ] ; $ result [ $ metaModelName ] = $ this -> prepareInputScreen ( $ metaModelName , $ screen ) ; } return $ result ; }
5913	public function addUserToGroup ( $ id , array $ groupIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'groupIds' => $ groupIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/groups' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
9078	private static function parseContextPrefix ( Request & $ request , $ serverVars = array ( ) ) { if ( isset ( $ serverVars [ 'CONTEXT_PREFIX' ] ) && $ serverVars [ 'CONTEXT_PREFIX' ] != '' ) { $ request -> setContextPrefix ( $ serverVars [ 'CONTEXT_PREFIX' ] . '/' ) ; } elseif ( isset ( $ serverVars [ 'REDIRECT_BASE' ] ) ) { $ request -> setContextPrefix ( $ serverVars [ 'REDIRECT_BASE' ] ) ; } elseif ( isset ( $ serverVars [ 'SCRIPT_FILENAME' ] ) && isset ( $ serverVars [ 'SCRIPT_NAME' ] ) ) { if ( isset ( $ serverVars [ 'HTTP_HOST' ] ) ) { $ scriptName = preg_replace ( '/^.+[\\\\\\/]/' , '' , $ serverVars [ 'SCRIPT_FILENAME' ] ) ; $ request -> contextPrefix = str_replace ( $ scriptName , '' , $ serverVars [ 'SCRIPT_NAME' ] ) ; } } }
165	public static function serialize ( array $ links ) { foreach ( $ links as $ rel => $ link ) { if ( is_array ( $ link ) ) { foreach ( $ link as $ i => $ l ) { $ link [ $ i ] = $ l instanceof self ? array_filter ( ( array ) $ l ) : [ 'href' => $ l ] ; } $ links [ $ rel ] = $ link ; } elseif ( ! $ link instanceof self ) { $ links [ $ rel ] = [ 'href' => $ link ] ; } } return $ links ; }
3059	public function selectAdaptiveNextItem ( ) { $ lastItemId = $ this -> getCurrentCatItemId ( ) ; $ lastOutput = $ this -> getLastCatItemOutput ( ) ; $ catSession = $ this -> getCatSession ( ) ; $ preSelection = $ catSession -> getTestMap ( ) ; try { if ( ! $ this -> syncingMode ) { $ selection = $ catSession -> getTestMap ( array_values ( $ lastOutput ) ) ; if ( ! $ this -> saveAdaptiveResults ( $ catSession ) ) { \ common_Logger :: w ( 'Unable to save CatService results.' ) ; } $ isShadowItem = false ; } else { $ selection = $ catSession -> getTestMap ( ) ; $ isShadowItem = true ; } } catch ( CatEngineException $ e ) { \ common_Logger :: e ( 'Error during CatEngine processing. ' . $ e -> getMessage ( ) ) ; $ selection = $ catSession -> getTestMap ( ) ; $ isShadowItem = true ; } $ event = new SelectAdaptiveNextItemEvent ( $ this -> getTestSession ( ) , $ lastItemId , $ preSelection , $ selection , $ isShadowItem ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ this -> persistCatSession ( $ catSession ) ; if ( is_array ( $ selection ) && count ( $ selection ) > 0 ) { \ common_Logger :: d ( "New CAT item selection is '" . implode ( ', ' , $ selection ) . "'." ) ; return $ selection [ 0 ] ; } else { \ common_Logger :: d ( 'No new CAT item selection.' ) ; return null ; } }
12123	public function onEntryUpdate ( ContentfulEntryEvent $ e ) { $ entry = $ e -> getEntry ( ) ; $ key = $ this -> getCacheKeyItem ( $ entry -> getId ( ) , 'uri' ) ; $ urisForItemOption = Option :: fromValue ( $ this -> cache -> fetch ( $ key ) , false ) ; if ( $ urisForItemOption -> isEmpty ( ) ) { Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ entry ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] Entry "%s" is not used.' , $ entry -> getId ( ) ) ) ; } ) ; return ; } $ urisForItem = $ urisForItemOption -> get ( ) ; foreach ( $ urisForItem as $ uri => $ bool ) { $ key = $ this -> getCacheKeyRequest ( sha1 ( $ uri ) , 'lastmodified' ) ; $ lastModified = $ this -> cache -> fetch ( $ key ) ; if ( $ lastModified >= $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) { Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ lastModified , $ uri ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] "%s" was last modified at "%s". Entry is older.' , $ uri , $ lastModified ) ) ; } ) ; continue ; } $ this -> cache -> save ( $ key , $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) ; Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ entry , $ uri ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] Setting last modified time for "%s" to "%s".' , $ uri , $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) ) ; } ) ; } }
12355	public function setVariables ( array $ data ) : void { foreach ( $ data as $ key => $ value ) { $ this -> $ key = $ value ; } }
4969	public function fromEvent ( $ param = null , $ default = null ) { if ( null === $ param ) { return $ this -> event -> getParams ( ) ; } return $ this -> event -> getParam ( $ param , $ default ) ; }
12924	public function getHandledLocalDataItems ( ) { $ handled = [ ] ; foreach ( $ this -> localDataItems as $ local ) { if ( $ local -> handled ) { $ handled [ ] = $ local ; } } return $ handled ; }
10544	public function setSites ( array $ sites ) { $ this -> sites = array ( ) ; foreach ( $ sites as $ site ) $ this -> addSite ( $ site ) ; return $ this ; }
7889	public function make ( $ date , $ level = 'all' ) { $ raw = $ this -> filesystem -> read ( $ date ) ; $ levels = $ this -> levels ; return new Log ( $ raw , $ levels , $ level ) ; }
11911	public static function trimStringRight ( $ str , $ remove ) { if ( ! is_string ( $ str ) ) throw new InvalidArgumentException ( '$str has to be a string' ) ; if ( ! is_string ( $ remove ) ) throw new InvalidArgumentException ( '$remove has to be a string' ) ; $ len = strlen ( $ remove ) ; $ offset = strlen ( $ str ) - $ len ; while ( 0 < $ offset && strpos ( $ str , $ remove , $ offset ) === $ offset ) { $ str = substr ( $ str , 0 , $ offset ) ; $ offset = strlen ( $ str ) - $ len ; } return $ str ; }
2843	public function getBlockTreeHtml ( ) { $ content = '' ; $ rootNodes = $ this -> getBlocksAsTree ( ) ; foreach ( $ rootNodes as $ rootNode ) { $ content .= $ this -> renderTreeNode ( $ rootNode ) ; } return $ content ; }
12546	public function once ( $ event , callable $ callback , $ priority = 100 ) { $ this -> event -> once ( $ event , $ callback , $ priority ) ; }
1039	private static function printPath ( ? array $ path = null ) { $ pathStr = '' ; $ currentPath = $ path ; while ( $ currentPath ) { $ pathStr = ( is_string ( $ currentPath [ 'key' ] ) ? '.' . $ currentPath [ 'key' ] : '[' . $ currentPath [ 'key' ] . ']' ) . $ pathStr ; $ currentPath = $ currentPath [ 'prev' ] ; } return $ pathStr ? 'value' . $ pathStr : '' ; }
4429	protected function getChoiceQuestion ( $ questionName , $ defaultValue = null , array $ choices = array ( ) ) { $ questionName = $ defaultValue ? '<info>' . $ questionName . '</info> [<comment>' . $ defaultValue . '</comment>]: ' : '<info>' . $ questionName . '</info>: ' ; return new ChoiceQuestion ( $ questionName , $ choices , $ defaultValue ) ; }
8963	private static function extractDateCriteria ( $ key , array $ criteria ) { $ date = ( ! empty ( $ criteria [ $ key ] ) ) ? $ criteria [ $ key ] : null ; if ( is_string ( $ date ) ) { $ date = \ DateTime :: createFromFormat ( 'Y-m-d' , $ date ) ; } if ( false === $ date ) { throw new InvalidArgumentException ( sprintf ( 'Invalid date/time format provided "%s", expected "%s", or instance of \DateTime class.' , $ criteria [ $ key ] , 'Y-m-d' ) ) ; } return $ date ; }
8425	public function getAllActiveQuery ( Production $ production ) : Query { $ qb = $ this -> createQueryBuilder ( 'p' ) ; return $ qb -> join ( 'p.groups' , 'g' ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'g' , ':group' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.active' , ':active' ) ) -> andWhere ( $ qb -> expr ( ) -> isNull ( 'p.parent' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isNull ( 'p.expiry' ) , $ qb -> expr ( ) -> gt ( 'p.expiry' , ':now' ) ) ) -> setParameter ( 'group' , $ production ) -> setParameter ( 'active' , true ) -> setParameter ( 'now' , new \ DateTime ( ) ) -> orderBy ( 'p.pinned' , 'DESC' ) -> addOrderBy ( 'p.created' , 'DESC' ) -> getQuery ( ) ; }
12639	protected function rethrowExceptions ( callable $ callable ) { try { return $ callable ( ) ; } catch ( ImplementationNotFoundException $ ex ) { throw new ImplementationNotFoundException ( $ ex -> getMessage ( ) ) ; } catch ( TypeMismatchException $ ex ) { throw new TypeMismatchException ( $ ex -> getMessage ( ) ) ; } catch ( UnresolveableArgumentException $ ex ) { throw new UnresolveableArgumentException ( $ ex -> getMessage ( ) ) ; } catch ( ValueNotFoundException $ ex ) { throw new ValueNotFoundException ( $ ex -> getMessage ( ) ) ; } catch ( InvalidCallableFormatException $ ex ) { throw new InvalidCallableFormatException ( $ ex -> getMessage ( ) ) ; } catch ( MissingDefinitionIdentifierException $ ex ) { throw new MissingDefinitionIdentifierException ( $ ex -> getMessage ( ) ) ; } catch ( MissingDefinitionValueException $ ex ) { throw new MissingDefinitionValueException ( $ ex -> getMessage ( ) ) ; } catch ( ClassNotFoundException $ ex ) { throw new ClassNotFoundException ( $ ex -> getMessage ( ) ) ; } }
963	public function postProcess ( ) { if ( ! $ this -> shop -> trashed ( ) ) { return ; } $ this -> shop -> restore ( ) ; $ this -> shop -> charges ( ) -> restore ( ) ; $ this -> shop -> save ( ) ; }
12424	public function getAuthorizationInfo ( $ authCode = null ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorization_code' => $ authCode ? : $ this -> request -> get ( 'auth_code' ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTH_INFO , $ params ] ) ; }
3254	private function getItem ( $ sku ) { $ className = Config :: get ( 'shop.item' ) ; $ item = new $ className ( ) ; return $ item -> where ( 'sku' , $ sku ) -> where ( 'cart_id' , $ this -> attributes [ 'id' ] ) -> first ( ) ; }
1283	public function addUnknownField ( string $ name ) : Field { $ this -> fields [ $ name ] = new Field ( $ name , $ name , 'Unknown' ) ; return $ this -> fields [ $ name ] ; }
4466	private function normalizeCommandArgs ( string $ command , array $ args ) : array { $ arguments = array_merge ( [ $ command , microtime ( true ) ] , $ args ) ; array_unshift ( $ arguments , 0 ) ; array_unshift ( $ arguments , $ this -> sha ) ; return $ arguments ; }
4516	public function setSortOrder ( ? string $ sortOrder ) { $ this -> sortOrder = $ sortOrder ; $ this -> _sortOrder = null !== $ sortOrder ; return $ this ; }
9351	public function add ( $ matrix ) { if ( ! ( $ matrix instanceof Matrix ) ) { throw new \ InvalidArgumentException ( 'Given argument must be an instance of \Malenki\Math\Matrix' ) ; } if ( ! $ this -> sameSize ( $ matrix ) ) { throw new \ RuntimeException ( 'Cannot adding given matrix: it has wrong size.' ) ; } $ out = new self ( $ this -> size -> rows , $ this -> size -> cols ) ; foreach ( $ this -> arr as $ k => $ v ) { $ arrOther = $ matrix -> getRow ( $ k ) ; $ arrNew = array ( ) ; foreach ( $ v as $ kk => $ vv ) { if ( $ arrOther [ $ kk ] instanceof Complex ) { $ arrNew [ ] = $ arrOther [ $ kk ] -> add ( $ vv ) ; } elseif ( $ vv instanceof Complex ) { $ arrNew [ ] = $ vv -> add ( $ arrOther [ $ kk ] ) ; } else { $ arrNew [ ] = $ arrOther [ $ kk ] + $ vv ; } } $ out -> addRow ( $ arrNew ) ; } return $ out ; }
10397	protected function processDiscriminatorMap ( ClassMetadataInfo $ metadata ) { $ newMap = [ ] ; foreach ( $ metadata -> discriminatorMap as $ mapId => $ mappedEntityName ) { $ newKey = $ this -> doReplacement ( $ mapId ) ; $ newMap [ $ newKey ] = $ mappedEntityName ; } $ metadata -> discriminatorMap = $ newMap ; }
9629	protected function getRouteIdentifier ( Route $ route ) : string { return empty ( $ route -> getName ( ) ) ? $ route -> getTarget ( ) : $ route -> getName ( ) ; }
5400	protected function truncateHost ( $ host ) { $ tlds = SimpleUrl :: getAllTopLevelDomains ( ) ; if ( preg_match ( '/[a-z\-]+\.(' . $ tlds . ')$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } elseif ( preg_match ( '/[a-z\-]+\.[a-z\-]+\.[a-z\-]+$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } return false ; }
5413	protected function createSocket ( $ scheme , $ host , $ port , $ timeout ) { if ( in_array ( $ scheme , array ( 'file' ) ) ) { return new SimpleFileSocket ( $ this -> url ) ; } elseif ( in_array ( $ scheme , array ( 'https' ) ) ) { return new SimpleSecureSocket ( $ host , $ port , $ timeout ) ; } else { return new SimpleSocket ( $ host , $ port , $ timeout ) ; } }
12377	public function superadmin ( User $ account , Container $ application , Database $ database ) { $ config = $ this -> config ; $ username = $ application -> input -> getString ( "user_first_name" , "" , "post" , FALSE , array ( ) ) ; $ usernameid = $ application -> input -> getString ( "user_name_id" , "" , "post" , FALSE , array ( ) ) ; $ userpass = $ application -> input -> getString ( "user_password" , "" , "post" , FALSE , array ( ) ) ; $ userpass2 = $ application -> input -> getString ( "user_password_2" , "" , "post" , FALSE , array ( ) ) ; $ useremail = $ application -> input -> getString ( "user_email" , "" , "post" , FALSE , array ( ) ) ; if ( empty ( $ userpass ) || empty ( $ username ) || empty ( $ usernameid ) || empty ( $ useremail ) ) { throw new Exception ( t ( 'Please provide at least a Name, Username, E-mail and Password' ) ) ; return false ; } if ( $ userpass <> $ userpass2 ) { throw new Exception ( t ( 'The user passwords do not match' ) ) ; return false ; } if ( ! $ account -> store ( $ application -> input -> data ( "post" ) , true ) ) { throw new Exception ( t ( 'Could not store the admin user account' ) ) ; return false ; } $ adminAuthority = $ this -> config -> get ( "setup.site.superadmin-authority" , NULL ) ; if ( ! empty ( $ adminAuthority ) ) { $ query = "INSERT INTO ?objects_authority( authority_id, object_id ) SELECT {$database->quote((int)$adminAuthority)}, object_id FROM ?objects WHERE object_uri={$database->quote($usernameid)}" ; $ database -> exec ( $ query ) ; } $ config -> set ( "setup.session.store" , "database" ) ; $ config -> set ( "setup.database.installed" , TRUE ) ; if ( ! $ config -> saveParams ( ) ) { throw new Exception ( "could not save config" ) ; return false ; } return true ; }
4691	public function having ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> having = $ expression ; $ this -> args [ 'having' ] = $ args ; return $ this ; }
8717	public static function forceCreate ( array $ attributes , $ translations = [ ] ) { $ model = new static ; return static :: unguarded ( function ( ) use ( $ model , $ attributes , $ translations ) { return $ model -> create ( $ attributes , $ translations ) ; } ) ; }
4376	protected function buildTableFooter ( $ keys ) { $ haveTotal = false ; $ cells = array ( ) ; foreach ( $ keys as $ key ) { $ colHasTotal = isset ( $ this -> tableInfo [ 'totals' ] [ $ key ] ) ; $ cells [ ] = $ colHasTotal ? $ this -> dump ( \ round ( $ this -> tableInfo [ 'totals' ] [ $ key ] , 6 ) , true , 'td' ) : '<td></td>' ; $ haveTotal = $ haveTotal || $ colHasTotal ; } if ( ! $ haveTotal ) { return '' ; } return '<tfoot>' . "\n" . '<tr><td>&nbsp;</td>' . ( $ this -> tableInfo [ 'haveObjRow' ] ? '<td>&nbsp;</td>' : '' ) . \ implode ( '' , $ cells ) . '</tr>' . "\n" . '</tfoot>' . "\n" ; }
11226	final public static function getShortName ( $ className = '' ) { $ base = strrchr ( static :: getRealClassName ( $ className ) , '\\' ) ; return $ base ? substr ( $ base , 1 ) : $ className ; }
1118	public static function allLeaves ( ) { $ instance = new static ; $ grammar = $ instance -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ instance -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ instance -> getQualifiedLeftColumnName ( ) ) ; return $ instance -> newQuery ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
472	public function insert ( $ table , $ columns ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> insert ( $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
12777	public function render ( ) { $ sort = 0 ; $ query = $ this -> request -> getQuery ( ) ; if ( isset ( $ query [ 'sort' ] ) && isset ( $ this -> columns [ $ query [ 'sort' ] ] ) ) { $ sort = $ query [ 'sort' ] ; } return $ this -> formatter -> render ( $ this -> columns , $ this -> getRecords ( ) , $ this -> dataManager -> getTotalCount ( ) , $ this -> limit , $ this -> page , $ sort ) ; }
6923	private function buildKey ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false ) { return sprintf ( '%s-%s-%s' , $ taxGroup -> getId ( ) , $ country -> getId ( ) , ( int ) $ business ) ; }
11168	public function getApiAsArray ( ) { if ( $ this -> useCache ( ) ) { if ( $ this -> getExtCache ( ) -> isApiCached ( ) ) { return $ this -> getExtCache ( ) -> getApi ( ) ; } } $ api = $ this -> generateApi ( ) ; if ( $ this -> useCache ( ) ) { $ this -> getExtCache ( ) -> cacheApi ( $ api ) ; } return $ api ; }
1861	public function chmod ( $ strFile , $ varMode ) { $ this -> validate ( $ strFile ) ; return chmod ( $ this -> strRootDir . '/' . $ strFile , $ varMode ) ; }
9744	public function setState ( $ state ) { if ( ! $ state ) { return $ this ; } if ( ! ( $ state instanceof State ) ) { $ state = new State ( $ state ) ; } if ( $ state -> isEmpty ( ) ) { $ this -> invalidArguments ( '10002' ) ; } return $ this -> setParameter ( 'state' , $ state ) ; }
4378	protected function buildTableRow ( $ row , $ keys , $ rowKey ) { $ str = '' ; $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; $ parsed = $ this -> debug -> utilities -> parseTag ( $ this -> dump ( $ rowKey ) ) ; $ str .= '<tr>' ; $ str .= $ this -> debug -> utilities -> buildTag ( 'th' , array ( 'class' => 't_key text-right ' . $ parsed [ 'attribs' ] [ 'class' ] , 'scope' => 'row' , ) , $ parsed [ 'innerhtml' ] ) ; if ( $ objInfo [ 'row' ] ) { $ str .= $ this -> markupClassname ( $ objInfo [ 'row' ] [ 'className' ] , 'td' , array ( 'title' => $ objInfo [ 'row' ] [ 'phpDoc' ] [ 'summary' ] ? : null , ) ) ; $ this -> tableInfo [ 'haveObjRow' ] = true ; } else { $ str .= '<td class="t_classname"></td>' ; } foreach ( $ values as $ v ) { $ str .= $ this -> dump ( $ v , true , 'td' ) ; } $ str .= '</tr>' . "\n" ; $ str = \ str_replace ( ' title=""' , '' , $ str ) ; foreach ( \ array_keys ( $ this -> tableInfo [ 'totals' ] ) as $ k ) { $ this -> tableInfo [ 'totals' ] [ $ k ] += $ values [ $ k ] ; } foreach ( $ objInfo [ 'cols' ] as $ k2 => $ classname ) { if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] === false ) { continue ; } if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] === null ) { $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] = $ classname ; } if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] !== $ classname ) { $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] = false ; } } return $ str ; }
3775	public function maxChildren ( $ conditionType ) { $ factory = $ this -> factories -> has ( $ conditionType ) ? $ this -> getFactory ( $ conditionType ) : null ; if ( ! $ factory instanceof NestablePropertyConditionFactoryInterface ) { if ( null !== $ value = $ this -> fallbackFactory -> maxChildren ( $ conditionType ) ) { return $ value ; } return 0 ; } return $ factory -> maxChildren ( ) ; }
6051	public function listFolders ( $ root = 0 , $ depth = 0 , $ includeProperties = true , $ includeObjectCounts = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'root' => $ root , 'depth' => $ depth , 'includeProperties' => $ includeProperties , 'includeObjectCounts' => $ includeObjectCounts ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
7330	private function configureSubjectRelativeMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , SubjectRelativeInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> relativeClassCache ) ) { return ; } $ this -> getSubjectIdentityMapper ( $ eventArgs -> getEntityManager ( ) ) -> processClassMetadata ( $ metadata , 'subjectIdentity' , 'subject_' ) ; $ this -> relativeClassCache [ ] = $ class ; }
7482	public function changeEncoding ( $ encoding ) { $ encoding = ( string ) $ encoding ; $ this -> string = iconv ( $ this -> encoding , $ encoding , $ this -> string ) ; $ this -> encoding = $ encoding ; return $ this ; }
1173	public function setDelegatedValidator ( DelegatedValidator $ validator ) { $ this -> validator = $ validator ; $ this -> rules -> setDelegatedValidator ( $ validator ) ; $ this -> messages -> setDelegatedValidator ( $ validator ) ; }
5245	private function replace ( string $ pattern , string $ replacement , string $ targetFile ) { $ this -> filesystem -> put ( $ targetFile , preg_replace ( $ pattern , $ replacement , $ this -> filesystem -> get ( $ targetFile ) ) ) ; }
9519	public function getPropertiesAsString ( ) { $ result = '' ; $ rFunction = new ReflectionFunction ( $ this -> parameterClosure ) ; if ( $ rFunction -> isVariadic ( ) ) { $ result .= '<' . $ rFunction -> getParameters ( ) [ 0 ] -> getName ( ) . ', ...>' ; } else { for ( $ i = 0 ; $ i < count ( $ rFunction -> getParameters ( ) ) ; $ i ++ ) { $ result .= ( $ result == '' ? '' : ' ' ) . '<' . $ rFunction -> getParameters ( ) [ $ i ] -> getName ( ) . '>' ; } } return $ result ; }
9565	public function addBeforeHook ( $ hook ) { if ( ! isset ( $ this -> options [ 'before' ] ) ) { $ this -> options [ 'before' ] = [ ] ; } $ this -> options [ 'before' ] [ ] = $ hook ; }
3673	private function getPageIdFromUrlHook ( ? array $ fragments ) : ? array { if ( ! ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] ) ) ) { return $ fragments ; } foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageIdFromUrl' ] as $ callback ) { $ fragments = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ fragments ) ; } return $ fragments ; }
8342	public static function addData ( string $ title , array $ data ) { if ( self :: $ isInit === true ) { self :: $ prettyPageHandler -> AddDataTable ( $ title , $ data ) ; } }
773	public function actionExtract ( $ configFile = null ) { $ this -> initConfig ( $ configFile ) ; $ files = FileHelper :: findFiles ( realpath ( $ this -> config [ 'sourcePath' ] ) , $ this -> config ) ; $ messages = [ ] ; foreach ( $ files as $ file ) { $ messages = array_merge_recursive ( $ messages , $ this -> extractMessages ( $ file , $ this -> config [ 'translator' ] , $ this -> config [ 'ignoreCategories' ] ) ) ; } $ catalog = isset ( $ this -> config [ 'catalog' ] ) ? $ this -> config [ 'catalog' ] : 'messages' ; if ( in_array ( $ this -> config [ 'format' ] , [ 'php' , 'po' ] ) ) { foreach ( $ this -> config [ 'languages' ] as $ language ) { $ dir = $ this -> config [ 'messagePath' ] . DIRECTORY_SEPARATOR . $ language ; if ( ! is_dir ( $ dir ) && ! @ mkdir ( $ dir ) ) { throw new Exception ( "Directory '{$dir}' can not be created." ) ; } if ( $ this -> config [ 'format' ] === 'po' ) { $ this -> saveMessagesToPO ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ catalog , $ this -> config [ 'markUnused' ] ) ; } else { $ this -> saveMessagesToPHP ( $ messages , $ dir , $ this -> config [ 'overwrite' ] , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'sort' ] , $ this -> config [ 'markUnused' ] ) ; } } } elseif ( $ this -> config [ 'format' ] === 'db' ) { $ db = Instance :: ensure ( $ this -> config [ 'db' ] , Connection :: className ( ) ) ; $ sourceMessageTable = isset ( $ this -> config [ 'sourceMessageTable' ] ) ? $ this -> config [ 'sourceMessageTable' ] : '{{%source_message}}' ; $ messageTable = isset ( $ this -> config [ 'messageTable' ] ) ? $ this -> config [ 'messageTable' ] : '{{%message}}' ; $ this -> saveMessagesToDb ( $ messages , $ db , $ sourceMessageTable , $ messageTable , $ this -> config [ 'removeUnused' ] , $ this -> config [ 'languages' ] , $ this -> config [ 'markUnused' ] ) ; } elseif ( $ this -> config [ 'format' ] === 'pot' ) { $ this -> saveMessagesToPOT ( $ messages , $ this -> config [ 'messagePath' ] , $ catalog ) ; } }
2380	public static function trimsplit ( $ strPattern , $ strString ) { if ( \ strlen ( $ strPattern ) == 1 ) { $ arrFragments = array_map ( 'trim' , explode ( $ strPattern , $ strString ) ) ; } else { $ arrFragments = array_map ( 'trim' , preg_split ( '/' . $ strPattern . '/ui' , $ strString ) ) ; } if ( \ count ( $ arrFragments ) < 2 && ! \ strlen ( $ arrFragments [ 0 ] ) ) { $ arrFragments = array ( ) ; } return $ arrFragments ; }
9101	private function listen ( ) { if ( ! @ socket_listen ( $ this -> handle , 5 ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
4375	protected function buildGroupMethod ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ str = '' ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ label = \ array_shift ( $ args ) ; $ levelClass = isset ( $ meta [ 'level' ] ) ? 'level-' . $ meta [ 'level' ] : null ; if ( ! empty ( $ meta [ 'isMethodName' ] ) ) { $ label = $ this -> markupClassname ( $ label ) ; } foreach ( $ args as $ k => $ v ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ argStr = \ implode ( ', ' , $ args ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'div' , array ( 'class' => array ( 'group-header' , $ method == 'groupCollapsed' ? 'collapsed' : 'expanded' , $ levelClass , ) , 'data-channel' => $ meta [ 'channel' ] , ) , '<span class="group-label">' . $ label . ( ! empty ( $ argStr ) ? '(</span>' . $ argStr . '<span class="group-label">)' : '' ) . '</span>' ) . "\n" ; $ str .= '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => array ( 'm_group' , $ levelClass , ) , ) ) . '>' ; } elseif ( $ method == 'groupEnd' ) { $ str = '</div>' ; } return $ str ; }
4381	protected function visualWhiteSpaceCallback ( $ matches ) { $ strBr = $ this -> debug -> getCfg ( 'addBR' ) ? '<br />' : '' ; $ search = array ( "\r" , "\n" ) ; $ replace = array ( '<span class="ws_r"></span>' , '<span class="ws_n"></span>' . $ strBr . "\n" ) ; return \ str_replace ( $ search , $ replace , $ matches [ 1 ] ) ; }
8170	public function recoverPassword ( ) { $ user = User :: findOne ( [ 'email' => $ this -> email ] ) ; if ( $ user != NULL ) { $ user -> password_reset_token = Yii :: $ app -> getSecurity ( ) -> generateRandomString ( ) . '_' . time ( ) ; $ user -> save ( FALSE ) ; } Mailer :: sendRecoveryMessage ( $ user ) ; Yii :: $ app -> session -> setFlash ( 'info' , 'You will receive an email with instructions on how to reset your password in a few minutes.' ) ; }
8953	public function createNode ( $ changeset , $ latitude , $ longitude , $ tags ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'node/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <node changeset="' . $ changeset . '" lat="' . $ latitude . '" lon="' . $ longitude . '">' . $ tagList . '</node> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
8057	public function setParentProcessTitleFormat ( $ string ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Children\'s Process Title Format for a created pool.' ) ; } $ this -> parentProcessTitleFormat = ProcessDetails :: sanitizeProcessTitleFormat ( $ string ) ; return $ this ; }
52	public function setOutputProgress ( $ outputProgress ) { foreach ( $ this -> downloaders as $ downloader ) { $ downloader -> setOutputProgress ( $ outputProgress ) ; } return $ this ; }
8416	public function commit ( ) : bool { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( $ this -> transactionLevel > 0 ) { -- $ this -> transactionLevel ; if ( $ this -> transactionLevel == 0 ) { return $ this -> providerDatabase -> commit ( $ this -> GetMasterLink ( ) ) ; } return $ this -> providerDatabase -> releaseSavePoint ( $ this -> GetMasterLink ( ) , 'LEVEL' . $ this -> transactionLevel ) ; } return false ; }
4790	function insert_update ( array $ unique , array $ insert , array $ update = array ( ) ) { if ( ! $ update ) { $ update = $ insert ; } $ insert = $ unique + $ insert ; $ values = "(" . implode ( ", " , array_keys ( $ insert ) ) . ") VALUES " . $ this -> quote ( $ insert ) ; if ( $ this -> notORM -> driver == "mysql" ) { $ set = array ( ) ; if ( ! $ update ) { $ update = $ unique ; } $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ update as $ key => $ val ) { $ set [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; } return $ this -> insert ( "$values ON DUPLICATE KEY UPDATE " . implode ( ", " , $ set ) ) ; } else { $ connection = $ this -> notORM -> connection ; $ errorMode = $ connection -> getAttribute ( PDO :: ATTR_ERRMODE ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , PDO :: ERRMODE_EXCEPTION ) ; try { $ return = $ this -> insert ( $ values ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; return $ return ; } catch ( PDOException $ e ) { $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; if ( $ e -> getCode ( ) == "23000" || $ e -> getCode ( ) == "23505" ) { if ( ! $ update ) { return 0 ; } $ clone = clone $ this ; $ return = $ clone -> where ( $ unique ) -> update ( $ update ) ; return ( $ return ? $ return + 1 : $ return ) ; } if ( $ errorMode == PDO :: ERRMODE_EXCEPTION ) { throw $ e ; } elseif ( $ errorMode == PDO :: ERRMODE_WARNING ) { trigger_error ( "PDOStatement::execute(): " . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } } return 0 ; }
9820	public function getColumn ( $ pColumn ) { $ this -> testColumnInRange ( $ pColumn ) ; if ( ! isset ( $ this -> columns [ $ pColumn ] ) ) { $ this -> columns [ $ pColumn ] = new AutoFilter \ Column ( $ pColumn , $ this ) ; } return $ this -> columns [ $ pColumn ] ; }
2502	protected function mapData ( array $ data ) { $ values = array ( ) ; reset ( $ data ) ; while ( $ key = current ( $ data ) ) { $ values [ $ key ] = next ( $ data ) ; next ( $ data ) ; } return $ values ; }
905	public function isUnaryPredecessorOperator ( $ index ) { static $ potentialSuccessorOperator = [ T_INC , T_DEC ] ; static $ potentialBinaryOperator = [ '+' , '-' , '&' , [ CT :: T_RETURN_REF ] ] ; static $ otherOperators ; if ( null === $ otherOperators ) { $ otherOperators = [ '!' , '~' , '@' , [ T_ELLIPSIS ] ] ; } static $ disallowedPrevTokens ; if ( null === $ disallowedPrevTokens ) { $ disallowedPrevTokens = [ ']' , '}' , ')' , '"' , '`' , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ T_CLASS_C ] , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_DEC ] , [ T_DIR ] , [ T_DNUMBER ] , [ T_FILE ] , [ T_FUNC_C ] , [ T_INC ] , [ T_LINE ] , [ T_LNUMBER ] , [ T_METHOD_C ] , [ T_NS_C ] , [ T_STRING ] , [ T_TRAIT_C ] , [ T_VARIABLE ] , ] ; } $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( $ potentialSuccessorOperator ) ) { return ! $ this -> isUnarySuccessorOperator ( $ index ) ; } if ( $ token -> equalsAny ( $ otherOperators ) ) { return true ; } if ( ! $ token -> equalsAny ( $ potentialBinaryOperator ) ) { return false ; } $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( ! $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return true ; } if ( ! $ token -> equals ( '&' ) || ! $ prevToken -> isGivenKind ( T_STRING ) ) { return false ; } static $ searchTokens = [ ';' , '{' , '}' , [ T_FUNCTION ] , [ T_OPEN_TAG ] , [ T_OPEN_TAG_WITH_ECHO ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevTokenOfKind ( $ index , $ searchTokens ) ] ; return $ prevToken -> isGivenKind ( T_FUNCTION ) ; }
1940	public function checkUniqueRecipient ( $ varValue , Contao \ DataContainer $ dc ) { $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE email=? AND pid=(SELECT pid FROM tl_newsletter_recipients WHERE id=?) AND id!=?" ) -> execute ( $ varValue , $ dc -> id , $ dc -> id ) ; if ( $ objRecipient -> count > 0 ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unique' ] , $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ $ dc -> field ] [ 0 ] ) ) ; } return $ varValue ; }
7405	public function assign ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; $ this -> _container = [ ] ; foreach ( $ in as $ k => $ v ) { $ this -> offsetSet ( $ k , $ v ) ; } }
6110	public function fileList ( $ cpw = "" , $ path = "/" , $ recursive = false ) { return $ this -> getParent ( ) -> channelFileList ( $ this -> getId ( ) , $ cpw , $ path , $ recursive ) ; }
8564	public function getEligibleShippingServices ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetEligibleShippingServicesRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetEligibleShippingServicesResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4777	public function getOutput ( ItemInterface $ item , $ userId ) { if ( $ item -> getCacheTime ( ) ) { $ cache = $ this -> cache -> getItem ( $ item -> getId ( ) . $ userId ) ; $ cache -> expiresAfter ( $ item -> getCacheTime ( ) ) ; if ( false === $ cache -> isHit ( ) ) { $ cache -> set ( $ item -> getTemplate ( ) ? $ this -> engine -> render ( $ item -> getTemplate ( ) , [ 'widget' => $ item ] ) : $ item -> getContent ( ) ) ; $ this -> cache -> save ( $ cache ) ; } return $ cache -> get ( ) ; } return $ item -> getTemplate ( ) ? $ this -> engine -> render ( $ item -> getTemplate ( ) , [ 'widget' => $ item ] ) : $ item -> getContent ( ) ; }
6749	public function transformCollection ( $ collection ) { if ( is_object ( $ collection ) ) $ collection = $ collection -> toArray ( ) [ "data" ] ; return array_map ( [ $ this , "transform" ] , $ collection ) ; }
634	public function createTable ( $ table , $ columns , $ options = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createTable ( $ table , $ columns , $ options ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
4179	public function hasManagerFile ( ) { if ( app ( 'filesystem' ) -> exists ( $ this -> directory . 'manager.yml' ) ) { return true ; } $ this -> console -> warn ( "No manager.yml file found in {$this->name} package." ) ; return false ; }
5121	private function sendRequest ( RequestInterface $ request , int $ attempt = 0 ) : \ Psr \ Http \ Message \ StreamInterface { if ( $ attempt >= $ this -> options -> get ( 'max_attempt' ) ) { throw new \ Exception ( 'MAX attempt reached for ' . $ request -> getUri ( ) . ' with payload ' . ( string ) $ request ) ; } try { $ response = $ this -> httpClient -> send ( $ request , [ 'allow_redirects' => false , 'synchronous' => true , 'curl' => [ CURLOPT_FORBID_REUSE => true , CURLOPT_MAXCONNECTS => 30 , CURLOPT_SSL_VERIFYPEER => false , CURLOPT_SSL_VERIFYSTATUS => false , ] , ] ) ; if ( $ response -> getStatusCode ( ) === 200 ) { return $ response -> getBody ( ) ; } return $ this -> sendRequest ( $ request , $ attempt ++ ) ; } catch ( ClientException $ err ) { if ( $ err -> getResponse ( ) -> getStatusCode ( ) === 401 && $ request -> getRequestTarget ( ) !== self :: AUTHENTICATION ) { $ this -> renewAuthToken ( ) ; return $ this -> sendRequest ( $ request , $ attempt ++ ) ; } throw $ err ; } catch ( \ Throwable $ err ) { throw $ err ; } }
1607	public function save ( $ uri , $ to , $ type , $ siteId = null , $ id = null ) { if ( $ siteId === 'null' ) $ siteId = null ; if ( $ id ) { $ record = RedirectRecord :: findOne ( compact ( 'id' ) ) ; if ( ! $ record ) return 'Unable to find redirect with ID: ' . $ id ; } else { $ existing = RedirectRecord :: findOne ( compact ( 'uri' , 'siteId' ) ) ; if ( $ existing ) return 'A redirect with that URI already exists!' ; $ record = new RedirectRecord ( ) ; } $ record -> uri = $ uri ; $ record -> to = $ to ; $ record -> type = $ type ; if ( $ siteId !== false ) $ record -> siteId = $ siteId ; if ( ! $ record -> save ( ) ) return $ record -> getErrors ( ) ; return $ record -> id ; }
2799	public static function generate ( $ mutantFile = null , $ bootstrap = '' , $ replacingFile = null ) { $ loadHumbug = '' ; if ( 'phar:' === substr ( __FILE__ , 0 , 5 ) ) { $ loadHumbug = '\Phar::loadPhar(\'' . str_replace ( 'phar://' , '' , \ Phar :: running ( ) ) . '\', \'humbug.phar\');' ; $ humbugBootstrap = 'phar://humbug.phar' . '/bootstrap.php' ; } else { $ humbugBootstrap = realpath ( __DIR__ . '/../../../bootstrap.php' ) ; } $ file = sys_get_temp_dir ( ) . '/humbug.phpunit.bootstrap.php' ; if ( ! is_null ( $ mutantFile ) ) { $ mutantFile = addslashes ( $ mutantFile ) ; $ replacingFile = addslashes ( $ replacingFile ) ; $ prepend = <<<PREPEND<?php{$loadHumbug}require_once '{$humbugBootstrap}';use Humbug\StreamWrapper\IncludeInterceptor;IncludeInterceptor::intercept('{$replacingFile}', '{$mutantFile}');IncludeInterceptor::enable();PREPEND ; if ( ! empty ( $ bootstrap ) ) { $ buffer = $ prepend . "\nrequire_once '{$bootstrap}';" ; } else { $ buffer = $ prepend ; } file_put_contents ( $ file , $ buffer ) ; } else { if ( ! empty ( $ bootstrap ) ) { $ buffer = "<?php\n{$loadHumbug}\nrequire_once '{$humbugBootstrap}';\nrequire_once '{$bootstrap}';" ; } else { $ buffer = "<?php\n{$loadHumbug}\nrequire_once '{$humbugBootstrap}';" ; } file_put_contents ( $ file , $ buffer ) ; } }
7037	protected static function computeDependencies ( array $ tables ) { $ result = [ ] ; while ( ! empty ( $ tables ) ) { $ num = count ( $ tables ) ; foreach ( $ tables as $ i => $ table ) if ( ! $ table -> dependent ( ) ) { $ result [ ] = $ table ; unset ( $ tables [ $ i ] ) ; foreach ( $ tables as $ t ) $ t -> removeDependency ( $ table -> name ( ) ) ; } if ( count ( $ tables ) === $ num ) return false ; } return $ result ; }
11206	public function map ( $ callback , $ data = false ) { $ collection = $ this -> getIterator ( ) ; $ mutatedCollection = new Collection ( ) ; foreach ( $ collection as $ prop => $ result ) { $ funcArgs = is_array ( $ data ) ? $ data : [ $ data ] ; array_unshift ( $ funcArgs , $ prop ) ; array_unshift ( $ funcArgs , $ result ) ; $ aValue = call_user_func_array ( $ callback , $ funcArgs ) ; $ mutatedCollection -> add ( $ aValue ) ; } return $ mutatedCollection ; }
9281	public function getPending ( array $ options = array ( ) ) { $ where = new Where ( ) ; $ where -> equalTo ( "{$this->tableName}.status" , JobEntity :: STATUS_PENDING ) ; return $ this -> fetchByWhere ( $ where , $ options ) ; }
10012	public function getSheet ( $ pIndex ) { if ( ! isset ( $ this -> workSheetCollection [ $ pIndex ] ) ) { $ numSheets = $ this -> getSheetCount ( ) ; throw new Exception ( "Your requested sheet index: {$pIndex} is out of bounds. The actual number of sheets is {$numSheets}." ) ; } return $ this -> workSheetCollection [ $ pIndex ] ; }
6538	public function init ( ) { Html :: addCssClass ( $ this -> options , [ 'panel' , 'sx-panel' , $ this -> color ] ) ; $ options = ArrayHelper :: merge ( $ this -> options , [ 'id' => $ this -> id , ] ) ; echo Html :: beginTag ( 'div' , $ options ) ; echo Html :: beginTag ( 'div' , $ this -> headingOptions ) ; echo <<<HTML <div class="pull-left"> <h2> {$this->name} </h2> </div> <div class="panel-actions panel-hidden-actions"> {$this->actions} </div>HTML ; echo Html :: endTag ( 'div' ) ; echo Html :: beginTag ( 'div' , $ this -> bodyOptions ) ; echo $ this -> content ; }
5100	public function values ( $ values ) { if ( isset ( $ values [ 0 ] ) ) return $ this -> appendByPosition ( $ values ) ; $ this -> fixDefaultValues ( $ values ) ; if ( ! $ this -> fields ) { $ this -> placeholder = false ; $ this -> fields = array_keys ( $ values ) ; return $ this -> appendByPosition ( array_values ( $ values ) ) ; } return $ this -> appendByField ( $ values ) ; }
8320	public function getCaptchaResultBulk ( array $ captchaIds ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , '/res.php?' . http_build_query ( [ 'key' => $ this -> apiKey , 'action' => 'get' , 'ids' => join ( ',' , $ captchaIds ) ] ) ) ; $ captchaTexts = $ response -> getBody ( ) -> __toString ( ) ; $ this -> getLogger ( ) -> info ( "Got bulk response: `{$captchaTexts}`." ) ; $ captchaTexts = explode ( "|" , $ captchaTexts ) ; $ result = [ ] ; foreach ( $ captchaTexts as $ index => $ captchaText ) { $ captchaText = html_entity_decode ( trim ( $ captchaText ) ) ; $ result [ $ captchaIds [ $ index ] ] = ( $ captchaText == self :: STATUS_CAPTCHA_NOT_READY ) ? false : $ captchaText ; } return $ result ; }
11001	public function setLocale ( $ locale ) { $ locale = WF :: cast_array ( $ locale ) ; foreach ( $ locale as $ l ) $ this -> locales [ ] = new Locale ( $ l ) ; $ this -> locales = array_unique ( $ this -> locales ) ; return $ this ; }
492	public function findFor ( $ name , $ model ) { if ( method_exists ( $ model , 'get' . $ name ) ) { $ method = new \ ReflectionMethod ( $ model , 'get' . $ name ) ; $ realName = lcfirst ( substr ( $ method -> getName ( ) , 3 ) ) ; if ( $ realName !== $ name ) { throw new InvalidArgumentException ( 'Relation names are case sensitive. ' . get_class ( $ model ) . " has a relation named \"$realName\" instead of \"$name\"." ) ; } } return $ this -> multiple ? $ this -> all ( ) : $ this -> one ( ) ; }
2326	public static function createFromDbResult ( Result $ objResult , $ strTable ) { $ arrModels = array ( ) ; $ strClass = Model :: getClassFromTable ( $ strTable ) ; while ( $ objResult -> next ( ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( $ strTable , $ objResult -> { $ strClass :: getPk ( ) } ) ; if ( $ objModel !== null ) { $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; $ arrModels [ ] = $ objModel ; } else { $ arrModels [ ] = new $ strClass ( $ objResult ) ; } } return new static ( $ arrModels , $ strTable ) ; }
12435	public function add ( $ id , IFormField $ field ) { $ field -> setId ( $ id ) ; return $ this -> addFormField ( $ field ) ; }
1619	public function buildAll ( $ query ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "n=n+1 pks[n]=redis.call('HGETALL',$key .. pk)" , 'pks' ) ; }
7268	public function hasMany ( $ forClass , $ forColumn = null , $ condition = "" , array $ conditionParams = [ ] ) { $ refTable = static :: tableName ( ) ; $ forTable = $ forClass :: tableName ( ) ; $ refColumn = static :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( static :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select F.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and R.$refColumn = :id $condition " , array_merge ( [ "id" => $ this -> $ refColumn ] , $ conditionParams ) , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return new Collection ( [ ] ) ; $ collection = [ ] ; foreach ( $ rows as $ row ) { $ forModel = new $ forClass ; foreach ( $ row as $ column => $ val ) $ forModel -> $ column = $ forModel -> decodeValue ( $ val , $ column ) ; $ collection [ ] = $ forModel ; } return new Collection ( $ collection ) ; }
2816	public function getCollectionsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getCollections ( ) as $ collection ) { $ data [ ] = array ( 'type' => $ collection -> getType ( ) , 'class' => $ collection -> getClass ( ) , 'sql' => $ collection -> getQuery ( ) , 'count' => $ collection -> getCount ( ) ) ; } return $ data ; }
9993	private function createCSSStyle ( Style $ pStyle ) { $ css = array_merge ( $ this -> createCSSStyleAlignment ( $ pStyle -> getAlignment ( ) ) , $ this -> createCSSStyleBorders ( $ pStyle -> getBorders ( ) ) , $ this -> createCSSStyleFont ( $ pStyle -> getFont ( ) ) , $ this -> createCSSStyleFill ( $ pStyle -> getFill ( ) ) ) ; return $ css ; }
1794	private function getAutoItems ( array $ parameters ) : array { if ( isset ( $ parameters [ 'auto_item' ] ) ) { return [ $ parameters [ 'auto_item' ] ] ; } if ( isset ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) && \ is_array ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) { return $ GLOBALS [ 'TL_AUTO_ITEM' ] ; } return [ ] ; }
4321	public static function arrayPathGet ( $ array , $ path ) { if ( ! \ is_array ( $ path ) ) { $ path = \ array_filter ( \ preg_split ( '#[\./]#' , $ path ) , 'strlen' ) ; } $ path = \ array_reverse ( $ path ) ; while ( $ path ) { $ key = \ array_pop ( $ path ) ; $ arrayAccess = \ is_array ( $ array ) || $ array instanceof \ ArrayAccess ; if ( ! $ arrayAccess ) { return null ; } elseif ( isset ( $ array [ $ key ] ) ) { $ array = $ array [ $ key ] ; } elseif ( $ key == '__count__' ) { return \ count ( $ array ) ; } elseif ( $ key == '__end__' ) { \ end ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } elseif ( $ key == '__reset__' ) { \ reset ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } else { return null ; } } return $ array ; }
12117	public static function displayConsoleException ( \ Throwable $ Throwable ) { ob_start ( ) ; echo PHP_EOL . ' ' ; echo ( ( $ Throwable instanceof PHPAssertionFailed ) ? 'Assertion Failed' : 'Uncaught ' . self :: getShortName ( get_class ( $ Throwable ) ) ) ; echo ' <' . basename ( $ Throwable -> getFile ( ) ) . ':' . $ Throwable -> getLine ( ) . '>' ; echo PHP_EOL . PHP_EOL . ' ' ; if ( $ Throwable instanceof PHPAssertionFailed ) { $ message = $ Throwable -> getExpression ( ) ; if ( $ message == '' ) { $ message = 'false' ; } } else { $ message = $ Throwable -> getMessage ( ) ; } echo wordwrap ( $ message , self :: CONSOLE_WIDTH - 2 , PHP_EOL . ' ' ) ; echo PHP_EOL . PHP_EOL . ' Stack Trace:' . PHP_EOL . PHP_EOL ; if ( $ Throwable instanceof BaseException || $ Throwable instanceof PHPErrorException ) { $ trace = $ Throwable -> getStackTrace ( ) ; } else { $ trace = array_reverse ( $ Throwable -> getTrace ( ) ) ; } $ trace_empty = [ 'class' => '' , 'type' => '' , 'function' => '' , 'file' => '{unknown}' , 'line' => 0 ] ; foreach ( $ trace as $ key => $ trace_item ) { $ trace_item = array_merge ( $ trace_empty , $ trace_item ) ; $ trace_item [ 'file' ] = basename ( $ trace_item [ 'file' ] ) ; if ( $ trace_item [ 'function' ] != '{closure}' ) { $ trace_item [ 'function' ] .= '()' ; } $ key ++ ; echo str_pad ( " $key. " , 6 , ' ' ) ; echo self :: getShortName ( $ trace_item [ 'class' ] ) . $ trace_item [ 'type' ] . $ trace_item [ 'function' ] ; echo " <{$trace_item['file']}:{$trace_item['line']}>" . PHP_EOL ; } return ob_get_clean ( ) ; }
4132	public function clear ( $ objectName = null ) { if ( $ objectName === null ) { $ this -> unitOfWork = new UnitOfWork ( $ this ) ; } else { throw new CouchDBException ( "DocumentManager#clear(\$objectName) not yet implemented." ) ; } }
5256	public function setParent ( ElasticsearchModel $ parent ) { $ this -> _parent = $ parent ; $ this -> setParentId ( $ parent -> getId ( ) ) ; }
27	public function write ( ) { $ data = array ( ) ; $ dumper = new ArrayDumper ( ) ; foreach ( $ this -> getCanonicalPackages ( ) as $ package ) { $ data [ ] = $ dumper -> dump ( $ package ) ; } usort ( $ data , function ( $ a , $ b ) { return strcmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; $ this -> file -> write ( $ data ) ; }
7033	protected function lastMigration ( ) { try { $ migration = Db :: query ( "select * from migrations order by created_at desc limit 1" , [ ] , $ this -> dbName ) ; return $ migration [ 0 ] ; } catch ( PDOException $ e ) { if ( $ e -> getCode ( ) === "42S02" ) return null ; } return false ; }
2751	public function validateCustomSnippet ( $ name , $ type , $ priority ) { $ snippetName = str_replace ( ' ' , '' , $ name ) ; $ types = [ 'init' , 'recv' , 'hit' , 'miss' , 'pass' , 'fetch' , 'error' , 'deliver' , 'log' , 'hash' , 'none' ] ; $ inArray = in_array ( $ type , $ types ) ; $ isNumeric = is_numeric ( $ priority ) ; $ isAlphanumeric = preg_match ( '/^[\w]+$/' , $ snippetName ) ; $ error = null ; if ( ! $ inArray ) { $ error = 'Type value is not recognised.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } if ( ! $ isNumeric ) { $ error = 'Please make sure that the priority value is a number.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } if ( ! $ isAlphanumeric ) { $ error = 'Please make sure that the name value contains only alphanumeric characters.' ; return [ 'snippet_name' => null , 'error' => $ error ] ; } return [ 'snippet_name' => $ snippetName , 'error' => $ error ] ; }
1920	private function getSqlDefinitions ( ) : array { $ this -> framework -> initialize ( ) ; $ installer = $ this -> framework -> createInstance ( Installer :: class ) ; $ sqlTarget = $ installer -> getFromDca ( ) ; $ sqlLegacy = $ installer -> getFromFile ( ) ; if ( ! empty ( $ sqlLegacy ) ) { foreach ( $ sqlLegacy as $ table => $ categories ) { foreach ( $ categories as $ category => $ fields ) { if ( \ is_array ( $ fields ) ) { foreach ( $ fields as $ name => $ sql ) { $ sqlTarget [ $ table ] [ $ category ] [ $ name ] = $ sql ; } } else { $ sqlTarget [ $ table ] [ $ category ] = $ fields ; } } } } if ( $ filter = $ this -> doctrine -> getConnection ( ) -> getConfiguration ( ) -> getFilterSchemaAssetsExpression ( ) ) { foreach ( array_keys ( $ sqlTarget ) as $ key ) { if ( ! preg_match ( $ filter , $ key ) ) { unset ( $ sqlTarget [ $ key ] ) ; } } } return $ sqlTarget ; }
2965	public function buildRequest ( $ method , $ path , array $ params = [ ] ) { $ body = ArrayUtils :: get ( $ params , 'body' , null ) ; $ query = ArrayUtils :: get ( $ params , 'query' , null ) ; $ options = [ ] ; if ( in_array ( $ method , [ 'POST' , 'PUT' , 'PATCH' ] ) && $ body ) { $ options [ 'body' ] = $ body ; } if ( $ query ) { $ options [ 'query' ] = $ query ; } return $ this -> createRequest ( $ method , $ path , $ options ) ; }
8965	public function rewriteCountQuery ( $ query ) { if ( \ preg_match ( '/^\s*SELECT\s+\bDISTINCT\b/is' , $ query ) || \ preg_match ( '/\s+GROUP\s+BY\s+/is' , $ query ) ) { return '' ; } $ openParenthesis = '(?:\()' ; $ closeParenthesis = '(?:\))' ; $ subQueryInSelect = $ openParenthesis . '.*\bFROM\b.*' . $ closeParenthesis ; $ pattern = '/(?:.*' . $ subQueryInSelect . '.*)\bFROM\b\s+/Uims' ; if ( \ preg_match ( $ pattern , $ query ) ) { return '' ; } $ subQueryWithLimitOrder = $ openParenthesis . '.*\b(LIMIT|ORDER)\b.*' . $ closeParenthesis ; $ pattern = '/.*\bFROM\b.*(?:.*' . $ subQueryWithLimitOrder . '.*).*/Uims' ; if ( \ preg_match ( $ pattern , $ query ) ) { return '' ; } $ queryCount = \ preg_replace ( '/(?:.*)\bFROM\b\s+/Uims' , 'SELECT COUNT(*) FROM ' , $ query , 1 ) ; list ( $ queryCount ) = \ preg_split ( '/\s+ORDER\s+BY\s+/is' , $ queryCount ) ; list ( $ queryCount ) = \ preg_split ( '/\bLIMIT\b/is' , $ queryCount ) ; return \ trim ( $ queryCount ) ; }
9080	private static function parseElement ( Request & $ req , $ serverVars , $ elementName , $ paramName ) { if ( isset ( $ serverVars [ $ elementName ] ) ) { $ req -> setParam ( $ paramName , $ serverVars [ $ elementName ] ) ; } }
9573	protected function registerProviders ( ) { $ dependants = [ ] ; foreach ( $ this -> providers as $ provider ) { if ( is_string ( $ provider ) ) { $ provider = new $ provider ( ) ; } $ this -> registerProvider ( $ provider ) ; if ( $ provider instanceof DependantProviderInterface ) { $ dependants [ ] = $ provider ; } } foreach ( $ dependants as $ dependant ) { $ this -> checkProviderDependencies ( $ dependant ) ; } }
3139	public function storeItemResponse ( RunnerServiceContext $ context , $ itemRef , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ this -> getCurrentAssessmentSession ( $ context ) ; try { \ common_Logger :: t ( 'Responses sent from the client-side. The Response Processing will take place.' ) ; if ( $ context -> isAdaptive ( ) ) { $ session -> beginItemSession ( ) ; $ session -> beginAttempt ( ) ; $ session -> endAttempt ( $ responses ) ; $ assessmentItem = $ session -> getAssessmentItem ( ) ; $ assessmentItemIdentifier = $ assessmentItem -> getIdentifier ( ) ; $ score = $ session -> getVariable ( 'SCORE' ) ; $ output = $ context -> getLastCatItemOutput ( ) ; if ( $ score !== null ) { $ output [ $ assessmentItemIdentifier ] = new ItemResult ( $ assessmentItemIdentifier , new ResultVariable ( $ score -> getIdentifier ( ) , BaseType :: getNameByConstant ( $ score -> getBaseType ( ) ) , $ score -> getValue ( ) -> getValue ( ) , null , $ score -> getCardinality ( ) ) , microtime ( true ) ) ; } else { \ common_Logger :: i ( "No 'SCORE' outcome variable for item '${assessmentItemIdentifier}' involved in an adaptive section." ) ; } $ context -> persistLastCatItemOutput ( $ output ) ; $ resultTransmitter = new \ taoQtiCommon_helpers_ResultTransmitter ( $ context -> getSessionManager ( ) -> getResultServer ( ) ) ; $ outcomeVariables = [ ] ; $ hrefParts = explode ( '|' , $ assessmentItem -> getHref ( ) ) ; $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ itemIdentifier = $ assessmentItem -> getIdentifier ( ) ; $ attempt = $ context -> getCatAttempts ( $ itemIdentifier ) ; $ transmissionId = "${sessionId}.${itemIdentifier}.${attempt}" ; $ attempt ++ ; foreach ( $ session -> getAllVariables ( ) as $ var ) { if ( $ var -> getIdentifier ( ) === 'numAttempts' ) { $ var -> setValue ( new \ qtism \ common \ datatypes \ QtiInteger ( $ attempt ) ) ; } $ variables [ ] = $ var ; } $ resultTransmitter -> transmitItemVariable ( $ variables , $ transmissionId , $ hrefParts [ 0 ] , $ hrefParts [ 2 ] ) ; $ context -> persistCatAttempts ( $ itemIdentifier , $ attempt ) ; $ context -> getTestSession ( ) -> endAttempt ( new State ( ) , true ) ; } else { $ session -> endAttempt ( $ responses , true ) ; } return true ; } catch ( AssessmentTestSessionException $ e ) { \ common_Logger :: w ( $ e -> getMessage ( ) ) ; return false ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
12912	public function join ( BaseManager $ manager , $ type = null , $ column = null , $ column_right = null ) { $ this -> joins [ $ manager -> table ] = array ( 'manager' => $ manager , 'type' => $ type , 'column' => $ column , 'column_right' => $ column_right ) ; return $ this ; }
12688	protected function load ( $ namespace , $ require = false ) { if ( isset ( $ this -> cache [ $ namespace ] ) ) { return $ this -> cache [ $ namespace ] ; } $ file = $ this -> getConfigFile ( $ namespace ) ; $ configuration = null ; try { $ configFile = new YamlConfiguration ( $ file ) ; $ configuration = $ configFile -> get ( ) ; if ( is_array ( $ configuration ) && ! empty ( $ configuration [ 'inherits' ] ) ) { $ allConfiguration = [ ] ; foreach ( $ configuration [ 'inherits' ] as $ parentNamespace ) { $ allConfiguration [ ] = $ this -> load ( $ parentNamespace ) ; } $ allConfiguration [ ] = $ configuration ; $ configuration = $ this -> merge ( $ allConfiguration ) ; unset ( $ allConfiguration , $ configuration [ 'inherits' ] ) ; } unset ( $ configFile ) ; } catch ( FileNotFoundException $ e ) { if ( $ require ) { throw new FileNotFoundException ( 'Could not find settings file for ' . $ namespace ) ; } } return $ this -> cache [ $ namespace ] = $ configuration ; }
8826	protected function migrationToClassName ( $ migrationName ) { $ class = str_replace ( '_' , ' ' , $ migrationName ) ; $ class = ucwords ( $ class ) ; $ class = str_replace ( ' ' , '' , $ class ) ; if ( ! $ this -> isValidClassName ( $ class ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Migration class "%s" is invalid' , $ class ) ) ; } return $ class ; }
6579	public function setParts ( array $ parts ) { $ parts = array_intersect_key ( $ parts , $ this -> params ) ; if ( isset ( $ parts [ 'port' ] ) ) $ parts [ 'port' ] = ( int ) $ parts [ 'port' ] ; if ( isset ( $ parts [ 'query' ] ) ) { $ query = $ this -> _parse_str ( $ parts [ 'query' ] ) ; $ this -> _rksort ( $ query ) ; $ parts [ 'query' ] = $ query ; } array_walk ( $ parts , function ( & $ part , $ key ) { if ( is_string ( $ part ) ) { $ part = strlen ( $ part ) ? $ part : null ; } else { $ part = $ part ? : null ; } } ) ; $ self = clone $ this ; $ self -> params = array_replace ( $ this -> params , $ parts ) ; return $ self ; }
9651	public function duplicate ( $ doWrite = true ) { $ clonedNode = parent :: duplicate ( $ doWrite ) ; if ( $ this -> Options ( ) ) { foreach ( $ this -> Options ( ) as $ field ) { $ newField = $ field -> duplicate ( ) ; $ newField -> ParentID = $ clonedNode -> ID ; $ newField -> write ( ) ; } } return $ clonedNode ; }
11308	public function entityFromBody ( $ body , $ entity ) { $ json = $ this -> decodeJson ( $ body ) ; return $ entity -> populate ( $ json ) ; }
5355	protected function getClassFromOperation ( $ name , Operation $ operation = null , $ reference , $ registry ) { if ( $ operation === null ) { return ; } if ( $ operation -> getParameters ( ) ) { foreach ( $ operation -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ this -> chainGuesser -> guessClass ( $ parameter -> getSchema ( ) , $ name . 'Body' , $ reference . '/parameters/' . $ key , $ registry ) ; } } } if ( $ operation -> getResponses ( ) ) { foreach ( $ operation -> getResponses ( ) as $ status => $ response ) { if ( $ response instanceof Response ) { $ this -> chainGuesser -> guessClass ( $ response -> getSchema ( ) , $ name . 'Response' . $ status , $ reference . '/responses/' . $ status , $ registry ) ; } } } }
11945	protected function handleEventMessage ( array $ message ) { Log :: debug ( 'OpenPlatform Event Message detail:' , $ message ) ; $ message = new Collection ( $ message ) ; $ infoType = $ message -> get ( 'InfoType' ) ; if ( $ handler = $ this -> getHandler ( $ infoType ) ) { $ handler -> handle ( $ message ) ; } else { Log :: notice ( "No existing handler for '{$infoType}'." ) ; } if ( $ messageHandler = $ this -> getMessageHandler ( ) ) { call_user_func_array ( $ messageHandler , [ $ message ] ) ; } }
1842	public function process ( ContainerBuilder $ container ) : void { if ( ! $ container -> has ( 'contao.fragment.registry' ) ) { return ; } $ this -> registerFragments ( $ container , ContentElementReference :: TAG_NAME ) ; $ this -> registerFragments ( $ container , FrontendModuleReference :: TAG_NAME ) ; }
11425	public function remark ( $ openId , $ remark ) { $ params = [ 'openid' => $ openId , 'remark' => $ remark , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_REMARK , $ params ] ) ; }
10747	protected function sendItems ( Response $ response , iterable $ items , ? Pagination $ pagination = null , ? int $ total = null ) : Response { $ items = is_array ( $ items ) ? $ items : ( $ items instanceof \ Traversable ? iterator_to_array ( $ items , false ) : [ ] ) ; $ total = $ total ?? count ( $ items ) ; $ start = $ pagination === null ? 0 : $ pagination -> getOffset ( ) ; $ max = $ pagination === null ? 0 : $ pagination -> getMax ( ) ; $ end = max ( min ( ( PHP_INT_MAX - $ max < $ start ? PHP_INT_MAX : $ start + $ max ) , $ total ) - 1 , 0 ) ; return $ this -> sendJson ( $ response -> withHeader ( 'Content-Range' , "items $start-$end/$total" ) , $ items ) ; }
3830	protected function prepareFrontendFilterOptions ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , $ blnAutoSubmit ) { $ arrOptions = array ( ) ; if ( ! isset ( $ arrWidget [ 'options' ] ) ) { return $ arrOptions ; } $ filterUrl = new FilterUrl ( $ arrJumpTo ) ; foreach ( $ arrFilterUrl as $ name => $ value ) { if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ filterUrl -> setSlug ( $ name , ( string ) $ value ) ; } $ parameterName = $ arrWidget [ 'eval' ] [ 'urlparam' ] ; if ( $ arrWidget [ 'eval' ] [ 'includeBlankOption' ] ) { $ blnActive = $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , '' ) ; $ arrOptions [ ] = array ( 'key' => '' , 'value' => ( $ arrWidget [ 'eval' ] [ 'blankOptionLabel' ] ? $ arrWidget [ 'eval' ] [ 'blankOptionLabel' ] : $ GLOBALS [ 'TL_LANG' ] [ 'metamodels_frontendfilter' ] [ 'do_not_filter' ] ) , 'href' => $ this -> filterUrlBuilder -> generate ( $ filterUrl -> clone ( ) -> setSlug ( $ parameterName , '' ) ) , 'active' => $ blnActive , 'class' => 'doNotFilter' . ( $ blnActive ? ' active' : '' ) , ) ; } foreach ( $ arrWidget [ 'options' ] as $ strKeyOption => $ strOption ) { $ strValue = $ this -> getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ; $ blnActive = $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ; $ arrOptions [ ] = array ( 'key' => $ strKeyOption , 'value' => $ strOption , 'href' => $ this -> filterUrlBuilder -> generate ( $ filterUrl -> clone ( ) -> setSlug ( $ parameterName , $ strValue ) ) , 'active' => $ blnActive , 'class' => StringUtil :: standardize ( $ strKeyOption ) . ( $ blnActive ? ' active' : '' ) ) ; } return $ arrOptions ; }
5782	public function routeGetDelete ( Request $ request , Response $ response , $ args ) { if ( ! $ this -> authorization -> isAuthorized ( ROLES_DELETE_RESOURCE ) ) { throw new \ Exception ( 'No permission.' ) ; } $ primaryKey = $ args [ ROUTEARG_PRIMARY_KEY ] ; $ tableName = $ this -> tableMapper -> getFormalTableName ( false ) ; $ primaryKeyColumnName = $ this -> tableMapper -> getPrimaryKeyColumnName ( ) ; try { $ this -> tableMapper -> deleteByPrimaryKey ( $ primaryKey ) ; $ this -> events -> insertInfo ( EVENT_ROLE_DELETE , [ $ primaryKeyColumnName => $ primaryKey ] ) ; SlimPostgres :: setAdminNotice ( "Deleted $tableName $primaryKey" ) ; } catch ( Exceptions \ UnallowedActionException $ e ) { $ this -> events -> insertWarning ( EVENT_UNALLOWED_ACTION , [ 'error' => $ e -> getMessage ( ) ] ) ; SlimPostgres :: setAdminNotice ( $ e -> getMessage ( ) , 'failure' ) ; } catch ( Exceptions \ QueryResultsNotFoundException $ e ) { define ( 'EVENT_QUERY_NO_RESULTS' , 'Query Results Not Found' ) ; $ this -> events -> insertWarning ( EVENT_QUERY_NO_RESULTS , $ e -> getMessage ( ) ) ; SlimPostgres :: setAdminNotice ( $ e -> getMessage ( ) , 'failure' ) ; } catch ( Exceptions \ QueryFailureException $ e ) { $ this -> events -> insertError ( EVENT_QUERY_FAIL , [ 'error' => $ e -> getMessage ( ) ] ) ; SlimPostgres :: setAdminNotice ( 'Delete Failed' , 'failure' ) ; } return $ response -> withRedirect ( $ this -> router -> pathFor ( SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ) ) ; }
7539	function isParent ( $ tag , $ recursive = false ) { return ( $ this -> hasParent ( $ tag , $ recursive ) === ( $ tag !== null ) ) ; }
9154	private function parseParameters ( \ ReflectionMethod $ action ) { $ params = $ action -> getParameters ( ) ; if ( count ( $ params ) < 1 ) { return false ; } $ param = $ params [ 0 ] ; assert ( $ param instanceof \ ReflectionParameter ) ; if ( ! ( $ class = $ param -> getClass ( ) ) || $ class -> getName ( ) != 'Nkey\Caribu\Mvc\Controller\Request' ) { return false ; } return true ; }
12620	public function createModel ( $ id , $ attributes ) { return Yii :: createObject ( [ 'class' => $ this -> foreignModelClass , 'tableName' => $ this -> fileSource -> id , 'interface' => $ this -> module , 'id' => $ id , 'attributes' => $ attributes ] ) ; }
1853	public function onReplaceInsertTags ( string $ tag ) { $ chunks = explode ( '::' , $ tag ) ; if ( 'trans' !== $ chunks [ 0 ] ) { return false ; } $ parameters = isset ( $ chunks [ 3 ] ) ? explode ( ':' , $ chunks [ 3 ] ) : [ ] ; return $ this -> translator -> trans ( $ chunks [ 1 ] , $ parameters , $ chunks [ 2 ] ?? null ) ; }
12646	public function setTrue ( $ obData = null ) { $ this -> bStatus = true ; $ this -> obData = $ obData ; return $ this ; }
12385	public function permalinksByLanguage ( $ language = null ) { $ result = array ( ) ; if ( null === $ language ) { $ language = $ this -> currentLanguage ; } foreach ( $ this -> pages as $ page ) { foreach ( $ page [ "seo" ] as $ pageAttribute ) { if ( $ pageAttribute [ "language" ] != $ language ) { continue ; } $ result [ ] = $ pageAttribute [ "permalink" ] ; } } return $ result ; }
1915	protected function getQuestion ( ) { $ this -> generateCaptcha ( ) ; $ question = $ GLOBALS [ 'TL_LANG' ] [ 'SEC' ] [ 'question' . random_int ( 1 , 3 ) ] ; $ question = sprintf ( $ question , $ this -> arrCaptcha [ 'int1' ] , $ this -> arrCaptcha [ 'int2' ] ) ; $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ question ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( '&#%s;' , Utf8 :: ord ( $ strCharacter ) ) ; } return $ strEncoded ; }
11781	public function fromEntityToDb ( $ document ) { $ unitOfWork = $ this -> documentManager -> getUnitOfWork ( ) ; $ persistenceBuilder = new PersistenceBuilder ( $ this -> documentManager , $ unitOfWork ) ; $ mapping = array ( 'targetDocument' => $ this -> documentClass , ) ; return $ persistenceBuilder -> prepareEmbeddedDocumentValue ( $ mapping , $ document , true ) ; }
6746	public function getCatalogue ( $ locale = null ) { if ( $ this -> translator instanceof TranslatorBagInterface ) { return $ this -> translator -> getCatalogue ( $ locale ) ; } return null ; }
2282	protected static function ssl ( ) { $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { return false ; } return $ request -> isSecure ( ) ; }
6102	public function listPropertyTypes ( $ systemName = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/propertysets/propertytypes' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new PropertyType ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; if ( null !== $ systemName ) { foreach ( $ result as $ entry ) { if ( $ entry -> getSystemName ( ) === $ systemName ) { return $ entry ; } } return null ; } return $ result ; }
8032	public function validateDatesArray ( $ attribute , $ value , array $ parameters , Validator $ validator ) { foreach ( $ value as $ date ) { if ( false === strtotime ( $ date ) || empty ( $ date ) ) { return false ; } } return true ; }
8984	public function isEqual ( TableNode $ expected , TableNode $ actual , $ message = NULL ) { $ this -> doAssert ( 'Failed asserting that two tables were equivalent: ' , [ 'ignoreColumnSequence' => TRUE ] , $ expected , $ actual , $ message ) ; }
6537	public function registerAssetFiles ( $ view ) { if ( \ Yii :: $ app -> request -> isPjax ) { return parent :: registerAssetFiles ( $ view ) ; } parent :: registerAssetFiles ( $ view ) ; }
8678	public function chunk ( $ size , $ preserveKeys = false ) { $ create = function ( $ items ) { return $ this -> createFrom ( $ items ) ; } ; return $ this -> createFrom ( array_map ( $ create , array_chunk ( $ this -> items , $ size , $ preserveKeys ) ) ) ; }
9028	protected function randomizeSamples ( $ referencePrefix , array $ samples , $ limit = 1 ) { $ sample = array_rand ( $ samples , $ limit ) ; if ( 1 === $ limit ) { $ referenceName = sprintf ( '%s_%s' , $ referencePrefix , $ samples [ $ sample ] ) ; return $ this -> getReference ( $ referenceName ) ; } else { $ collection = new ArrayCollection ( ) ; foreach ( $ sample as $ index ) { $ referenceName = sprintf ( '%s_%s' , $ referencePrefix , $ samples [ $ index ] ) ; $ collection -> add ( $ this -> getReference ( $ referenceName ) ) ; } return $ collection ; } }
5293	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ directory = $ input -> getArgument ( 'directory' ) ; $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading files from "' . $ directory . '" ...' ) ; $ generator -> generateFromDir ( $ directory , array ( 'id' => $ input -> getOption ( 'name' ) ? : 'SVGFont' , ) , $ input -> getOption ( 'rename-files' ) ) ; $ output -> writeln ( 'writing font to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getFont ( ) -> getXML ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created ' . $ outputFile . ' successfully</success>' ) ; }
12772	public function register ( $ email , $ hashedPassword = null , & $ user = null , $ valid = false ) { $ result = new EmailStatus ( 0 ) ; if ( ! dbQuery ( $ this -> dbTable ) -> cond ( $ this -> dbEmailField , $ email ) -> first ( $ user ) ) { if ( ! isset ( $ user ) ) { $ user = new $ this -> dbTable ( false ) ; } $ user [ $ this -> dbEmailField ] = $ email ; $ user [ $ this -> dbHashEmailField ] = $ this -> hash ( $ email ) ; if ( isset ( $ hashedPassword ) ) { $ user [ $ this -> dbHashPasswordField ] = $ hashedPassword ; } else { $ user [ $ this -> dbHashPasswordField ] = $ this -> generatePassword ( ) ; } if ( ! $ valid ) { $ user [ $ this -> dbConfirmField ] = $ this -> hash ( $ email . time ( ) ) ; } else { $ user [ $ this -> dbConfirmField ] = 1 ; } $ activeField = $ this -> dbActiveField ; $ createdField = $ this -> dbCreatedField ; $ user -> $ activeField = 1 ; $ user -> $ createdField = date ( 'Y-m-d H:i:s' ) ; $ user -> save ( ) ; $ this -> authorize ( $ user ) ; $ result = new EmailStatus ( EmailStatus :: SUCCESS_EMAIL_REGISTERED ) ; } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_REGISTER_FOUND ) ; } if ( is_callable ( $ this -> registerHandler ) ) { if ( ! call_user_func_array ( $ this -> registerHandler , array ( & $ user , & $ result ) ) ) { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_REGISTER_HANDLER ) ; } } return $ result ; }
2023	public static function findFirstPublishedByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.type!='root' AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findOneBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
1467	public static function doesResponseHaveBody ( $ request , $ response ) { if ( 'HEAD' === strtoupper ( $ request -> getMethod ( ) ) ) { return false ; } $ status = $ response -> getStatusCode ( ) ; if ( ( 100 <= $ status && 200 > $ status ) || 204 === $ status || 304 === $ status ) { return false ; } if ( self :: hasHeader ( $ response , 'Transfer-Encoding' ) ) { return true ; } ; if ( ! $ contentLength = self :: getHeader ( $ response , 'Content-Length' ) ) { return false ; } return 0 < $ contentLength [ 0 ] ; }
5128	public function readQDateTime ( ) { $ day = $ this -> readUInt ( ) ; $ msec = $ this -> readUInt ( ) ; $ this -> readBool ( ) ; if ( $ day === 0 && $ msec === 0xFFFFFFFF ) { return null ; } $ time = ( $ day - 2440588 ) * 86400 + $ msec / 1000 ; $ dt = \ DateTime :: createFromFormat ( 'U.u' , sprintf ( '%.6F' , $ time ) ) ; $ dt -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; return $ dt ; }
6176	public static function arrayUniqueMultidimensional ( array $ input ) { $ serialized = array_map ( 'serialize' , $ input ) ; $ unique = array_unique ( $ serialized ) ; $ output = array_intersect_key ( $ input , $ unique ) ; return array_values ( $ output ) ; }
4645	public function setDimension ( $ name , array $ values ) { if ( empty ( $ values ) ) { $ values = array ( null ) ; } $ this -> dimensions [ $ name ] = $ values ; }
481	public function addPrimaryKey ( $ name , $ table , $ columns ) { $ time = $ this -> beginCommand ( "add primary key $name on $table (" . ( is_array ( $ columns ) ? implode ( ',' , $ columns ) : $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> addPrimaryKey ( $ name , $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
8455	protected function argsForNextCommand ( $ args ) { if ( ! is_array ( $ args ) ) { $ args = func_get_args ( ) ; } $ this -> argumentsForNextCommand .= ' ' . implode ( ' ' , $ args ) ; return $ this ; }
5204	public function isActiveURL ( $ url , $ output = "active" ) { if ( $ this -> url -> current ( ) == $ this -> url -> to ( $ url ) ) { return $ output ; } return null ; }
10065	public function setPieces ( $ pieces ) { if ( $ pieces && ! $ pieces instanceof PieceBag ) { $ pieces = new PieceBag ( is_array ( $ pieces ) ? $ pieces : [ ] ) ; } return $ this -> setParameter ( 'pieces' , $ pieces ) ; }
11507	public function serve ( ) { Log :: debug ( 'Request received:' , [ 'Method' => $ this -> request -> getMethod ( ) , 'URI' => $ this -> request -> getRequestUri ( ) , 'Query' => $ this -> request -> getQueryString ( ) , 'Protocal' => $ this -> request -> server -> get ( 'SERVER_PROTOCOL' ) , 'Content' => $ this -> request -> getContent ( ) , ] ) ; $ this -> validate ( $ this -> token ) ; if ( $ str = $ this -> request -> get ( 'echostr' ) ) { Log :: debug ( "Output 'echostr' is '$str'." ) ; return new Response ( $ str ) ; } $ result = $ this -> handleRequest ( ) ; $ response = $ this -> buildResponse ( $ result [ 'to' ] , $ result [ 'from' ] , $ result [ 'response' ] ) ; Log :: debug ( 'Server response created:' , compact ( 'response' ) ) ; return new Response ( $ response ) ; }
8167	public function addIndentation ( ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is deprecated since version 1.27 and will be removed in 2.0. Use write(\'\') instead.' , E_USER_DEPRECATED ) ; $ this -> source .= str_repeat ( ' ' , $ this -> indentation * 4 ) ; return $ this ; }
4266	public static function register ( $ pathsExclude = array ( ) ) { $ result = \ stream_wrapper_unregister ( static :: PROTOCOL ) ; if ( $ result === false ) { throw new \ UnexpectedValueException ( 'Failed to unregister' ) ; } if ( $ pathsExclude ) { self :: $ pathsExclude = $ pathsExclude ; } \ stream_wrapper_register ( static :: PROTOCOL , \ get_called_class ( ) ) ; \ ini_set ( 'opcache.enable' , 0 ) ; }
2775	public function streamOutput ( bool $ streamOutput = true ) : void { if ( $ streamOutput && ! isset ( $ this -> gitOutputListener ) ) { $ this -> gitOutputListener = new GitOutputStreamListener ( ) ; $ this -> addOutputListener ( $ this -> gitOutputListener ) ; } if ( ! $ streamOutput && isset ( $ this -> gitOutputListener ) ) { $ this -> removeOutputListener ( $ this -> gitOutputListener ) ; unset ( $ this -> gitOutputListener ) ; } }
3972	public function decodeAttributeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ attribute = $ metaModel -> getAttributeById ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ) ; } }
5113	public function writeQTime ( $ timestamp ) { if ( $ timestamp instanceof \ DateTime ) { $ msec = $ timestamp -> format ( 'H' ) * 3600000 + $ timestamp -> format ( 'i' ) * 60000 + $ timestamp -> format ( 's' ) * 1000 + ( int ) ( $ timestamp -> format ( '0.u' ) * 1000 ) ; } else { $ msec = round ( ( $ timestamp - strtotime ( 'midnight' , ( int ) $ timestamp ) ) * 1000 ) ; } $ this -> writeUInt ( $ msec ) ; }
814	private function getNewLineIndex ( $ index , Tokens $ tokens ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; for ( $ index , $ count = \ count ( $ tokens ) ; $ index < $ count ; ++ $ index ) { if ( false !== strstr ( $ tokens [ $ index ] -> getContent ( ) , $ lineEnding ) ) { return $ index ; } } return $ index ; }
5306	protected function transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset , $ yOffset ) { if ( $ flip === 'horizontal' || $ flip === 'vertical' ) { $ viewBox = $ this -> getViewBox ( ) ; } return preg_replace_callback ( '([m,l,h,v,c,s,q,t,a,z](?:[\\s,]*-?(?=\\.?\\d)\\d*(?:\\.\\d+)?)*)i' , function ( $ maches ) use ( $ scale , $ roundPrecision , $ flip , $ xOffset , $ yOffset , $ viewBox ) { $ command = substr ( $ maches [ 0 ] , 0 , 1 ) ; $ absoluteCommand = strtoupper ( $ command ) === $ command ; $ xyCommand = in_array ( strtolower ( $ command ) , array ( 'm' , 'l' , 'c' , 's' , 'q' , 't' ) ) ; $ xCommand = strtolower ( $ command ) === 'h' ; $ yCommand = strtolower ( $ command ) === 'v' ; if ( strtolower ( $ command ) === 'z' ) { return $ command ; } if ( strtolower ( $ command ) === 'a' ) { throw new \ Exception ( 'Path command "A" is currently not supportet!' ) ; } $ values = $ this -> getValuesFromList ( substr ( $ maches [ 0 ] , 1 ) ) ; foreach ( $ values as $ key => $ value ) { if ( $ flip === 'horizontal' && ( ( ! ( $ key % 2 ) && $ xyCommand ) || $ xCommand ) ) { $ values [ $ key ] *= - 1 ; if ( $ absoluteCommand ) { $ values [ $ key ] += $ viewBox [ 'width' ] ; } } if ( $ flip === 'vertical' && ( ( $ key % 2 && $ xyCommand ) || $ yCommand ) ) { $ values [ $ key ] *= - 1 ; if ( $ absoluteCommand ) { $ values [ $ key ] += $ viewBox [ 'height' ] ; } } if ( $ absoluteCommand && ( ( ! ( $ key % 2 ) && $ xyCommand ) || $ xCommand ) ) { $ values [ $ key ] += $ xOffset ; } if ( $ absoluteCommand && ( ( $ key % 2 && $ xyCommand ) || $ yCommand ) ) { $ values [ $ key ] += $ yOffset ; } $ values [ $ key ] *= $ scale ; if ( $ roundPrecision !== null ) { $ values [ $ key ] = round ( $ values [ $ key ] , $ roundPrecision ) ; } } return $ command . implode ( ' ' , $ values ) ; } , $ path ) ; }
4344	protected function pushStack ( $ funcName ) { $ this -> funcStack [ ] = array ( 'function' => $ funcName , 'tsStart' => $ this -> timeLastTick , 'subTime' => 0 , ) ; if ( ! isset ( $ this -> data [ $ funcName ] ) ) { $ this -> data [ $ funcName ] = array ( 'calls' => 0 , 'totalTime' => 0 , 'ownTime' => 0 , ) ; } $ this -> data [ $ funcName ] [ 'calls' ] ++ ; }
7696	function MsPowerpoint_Clean ( & $ Txt ) { $ this -> MsPowerpoint_CleanRpr ( $ Txt , 'a:rPr' ) ; $ Txt = str_replace ( '<a:rPr/>' , '' , $ Txt ) ; $ this -> MsPowerpoint_CleanRpr ( $ Txt , 'a:endParaRPr' ) ; $ Txt = str_replace ( '<a:endParaRPr/>' , '' , $ Txt ) ; $ Txt = str_replace ( '</a:t><a:t>' , '' , $ Txt ) ; $ Txt = str_replace ( '</a:t></a:r><a:r><a:t>' , '' , $ Txt ) ; $ Txt = str_replace ( '<a:t></a:t>' , '' , $ Txt ) ; $ Txt = str_replace ( '<a:r></a:r>' , '' , $ Txt ) ; }
6552	public function lock ( ) { if ( $ this -> pid === $ this -> getSerial ( ) ) { return ; } $ this -> pid = $ this -> getSerial ( ) ; $ this -> fh = fopen ( $ filename = $ this -> getPidFilename ( ) , 'a+' ) ; if ( ! flock ( $ this -> fh , LOCK_EX | LOCK_NB ) ) { throw new ImportAlreadyRunningException ( sprintf ( 'PID file %s is already in use' , $ filename ) ) ; } if ( fwrite ( $ this -> fh , $ this -> pid . PHP_EOL ) === false ) { throw new \ Exception ( sprintf ( 'Can\'t write PID %s to PID file %s' , $ this -> pid , $ filename ) ) ; } }
12104	public function handleRequest ( ) : void { global $ argv ; if ( ! is_array ( $ argv ) || empty ( $ argv ) ) { throw new Exception ( 'Invalid value of the cli args array was given.' ) ; } ( new CliCtrlResolver ( $ argv ) ) -> run ( ) ; }
11900	public function getIsMostRecent ( ) { return ! empty ( $ this -> dataInterface ) && $ this -> dataInterface -> lastDataInterfaceLog && $ this -> dataInterface -> lastDataInterfaceLog -> primaryKey === $ this -> primaryKey ; }
5296	public function setOptions ( $ options = array ( ) ) { $ this -> options = array_merge ( $ this -> options , $ options ) ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ 'id' ] = $ this -> options [ 'id' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ 'horiz-adv-x' ] = $ this -> options [ 'horiz-adv-x' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'units-per-em' ] = $ this -> options [ 'units-per-em' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'ascent' ] = $ this -> options [ 'ascent' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'descent' ] = $ this -> options [ 'descent' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'x-height' ] = $ this -> options [ 'x-height' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'cap-height' ] = $ this -> options [ 'cap-height' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'missing-glyph' } [ 0 ] [ 'horiz-adv-x' ] = $ this -> options [ 'horiz-adv-x' ] ; }
5775	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ roles = $ this -> mapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) ) ; } catch ( QueryFailureException $ e ) { $ roles = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ roles ) ; }
5511	public function expectCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_counts [ strtolower ( $ method ) ] = new CallCountExpectation ( $ method , $ count , $ message ) ; }
8723	public function translateOrNew ( $ locale ) { if ( is_null ( $ instance = $ this -> translate ( $ locale ) ) ) { return $ this -> newModelInstance ( ) ; } return $ instance ; }
6037	public function init ( ) { parent :: init ( ) ; if ( $ this -> data ) { $ order = 0 ; if ( is_array ( $ this -> model -> { $ this -> attribute } ) ) { foreach ( $ this -> model -> { $ this -> attribute } as $ value ) { $ order ++ ; if ( is_object ( $ value ) ) { $ this -> options [ 'options' ] [ $ value -> Id ] = [ 'data-order' => $ order ] ; } else { $ this -> options [ 'options' ] [ $ value ] = [ 'data-order' => $ order ] ; } } } } }
8914	public function decode ( $ value , $ b = 62 ) { $ limit = strlen ( $ value ) ; $ result = strpos ( $ this -> base , $ value [ 0 ] ) ; for ( $ i = 1 ; $ i < $ limit ; $ i ++ ) { $ result = $ b * $ result + strpos ( $ this -> base , $ value [ $ i ] ) ; } return $ result ; }
8891	public function singleton ( $ key , $ value ) { if ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } }
100	public function set ( $ prefix , $ paths ) { if ( ! $ prefix ) { $ this -> fallbackDirsPsr0 = ( array ) $ paths ; } else { $ this -> prefixesPsr0 [ $ prefix [ 0 ] ] [ $ prefix ] = ( array ) $ paths ; } }
8683	public static function from ( $ iterable ) { if ( is_array ( $ iterable ) ) { return $ iterable ; } if ( $ iterable instanceof ImmutableBag ) { return $ iterable -> toArray ( ) ; } if ( $ iterable instanceof Traversable ) { return iterator_to_array ( $ iterable ) ; } if ( $ iterable === null ) { return [ ] ; } if ( $ iterable instanceof \ stdClass ) { return ( array ) $ iterable ; } Assert :: nullOrIsIterable ( $ iterable ) ; }
3798	private function checkModelWithVariants ( $ containedModel ) { $ isVarbase = ( bool ) $ containedModel -> getProperty ( 'varbase' ) ; $ vargroup = $ containedModel -> getProperty ( 'vargroup' ) ; $ isCurrentVarbase = ( bool ) $ this -> currentModel -> getProperty ( 'varbase' ) ; $ currentVargroup = $ this -> currentModel -> getProperty ( 'vargroup' ) ; if ( $ isVarbase && ! $ this -> circularReference && $ isCurrentVarbase ) { $ this -> disablePA = false ; } elseif ( ! $ isVarbase && ! $ isCurrentVarbase && $ vargroup == $ currentVargroup ) { $ this -> disablePA = false ; } $ this -> disablePI = ! $ isCurrentVarbase || $ isVarbase ; }
3557	protected function setType ( $ value ) { $ this -> attributes [ 'meta_type' ] = $ this -> hasMutator ( $ value , 'setter' ) ? $ this -> getMutatedType ( $ value , 'setter' ) : $ this -> getValueType ( $ value ) ; }
3654	public function purge ( ) { foreach ( $ GLOBALS [ 'TL_PURGE' ] [ 'folders' ] [ 'metamodels_assets' ] [ 'affected' ] as $ folderName ) { $ folder = new \ Folder ( $ folderName ) ; $ folder -> purge ( ) ; } $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ dispatcher -> dispatch ( ContaoEvents :: SYSTEM_LOG , new LogEvent ( 'Purged the MetaModels assets' , __METHOD__ , TL_CRON ) ) ; }
6824	protected function getTaxAccountNumber ( float $ rate , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_TAX ) { continue ; } if ( 0 !== bccomp ( $ account -> getTax ( ) -> getRate ( ) , $ rate , 5 ) ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No tax account number configured for tax rate '%s' (%s)" , $ rate , $ origin ) ) ; }
5932	public function setEndDate ( $ endDate ) { if ( $ endDate instanceof DateTime ) { $ this -> endDate = $ endDate ; } else { try { $ this -> endDate = new DateTime ( $ endDate ) ; } catch ( \ Exception $ e ) { $ this -> endDate = null ; } } return $ this ; }
10193	public static function getQueryPreview ( QueryBuilder $ query = null ) { if ( empty ( $ query ) ) { return "" ; } $ sql = str_replace ( '?' , "'%s'" , $ query -> toSql ( ) ) ; $ bindings = $ query -> getBindings ( ) ; return vsprintf ( $ sql , $ bindings ) ; }
2241	public static function getArticle ( $ varId , $ blnMultiMode = false , $ blnIsInsertTag = false , $ strColumn = 'main' ) { global $ objPage ; if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( ! $ varId ) { return '' ; } $ objRow = ArticleModel :: findByIdOrAliasAndPid ( $ varId , ( ! $ blnIsInsertTag ? $ objPage -> id : null ) ) ; if ( $ objRow === null ) { return false ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } if ( isset ( $ _GET [ 'pdf' ] ) && Input :: get ( 'pdf' ) == $ objRow -> id ) { if ( $ objRow -> printable == 1 ) { @ trigger_error ( 'Setting tl_article.printable to "1" has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } elseif ( $ objRow -> printable != '' ) { $ options = StringUtil :: deserialize ( $ objRow -> printable ) ; if ( \ is_array ( $ options ) && \ in_array ( 'pdf' , $ options ) ) { $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } } } $ objRow -> headline = $ objRow -> title ; $ objRow -> multiMode = $ blnMultiMode ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow ) ; } } $ objArticle = new ModuleArticle ( $ objRow , $ strColumn ) ; $ strBuffer = $ objArticle -> generate ( $ blnIsInsertTag ) ; if ( $ objArticle -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
86	public function archive ( PackageInterface $ package , $ format , $ targetDir , $ fileName = null , $ ignoreFilters = false ) { if ( empty ( $ format ) ) { throw new \ InvalidArgumentException ( 'Format must be specified' ) ; } $ usableArchiver = null ; foreach ( $ this -> archivers as $ archiver ) { if ( $ archiver -> supports ( $ format , $ package -> getSourceType ( ) ) ) { $ usableArchiver = $ archiver ; break ; } } if ( null === $ usableArchiver ) { throw new \ RuntimeException ( sprintf ( 'No archiver found to support %s format' , $ format ) ) ; } $ filesystem = new Filesystem ( ) ; if ( null === $ fileName ) { $ packageName = $ this -> getPackageFilename ( $ package ) ; } else { $ packageName = $ fileName ; } $ filesystem -> ensureDirectoryExists ( $ targetDir ) ; $ target = realpath ( $ targetDir ) . '/' . $ packageName . '.' . $ format ; $ filesystem -> ensureDirectoryExists ( dirname ( $ target ) ) ; if ( ! $ this -> overwriteFiles && file_exists ( $ target ) ) { return $ target ; } if ( $ package instanceof RootPackageInterface ) { $ sourcePath = realpath ( '.' ) ; } else { $ sourcePath = sys_get_temp_dir ( ) . '/composer_archive' . uniqid ( ) ; $ filesystem -> ensureDirectoryExists ( $ sourcePath ) ; try { $ this -> downloadManager -> download ( $ package , $ sourcePath ) ; } catch ( \ Exception $ e ) { $ filesystem -> removeDirectory ( $ sourcePath ) ; throw $ e ; } if ( file_exists ( $ composerJsonPath = $ sourcePath . '/composer.json' ) ) { $ jsonFile = new JsonFile ( $ composerJsonPath ) ; $ jsonData = $ jsonFile -> read ( ) ; if ( ! empty ( $ jsonData [ 'archive' ] [ 'exclude' ] ) ) { $ package -> setArchiveExcludes ( $ jsonData [ 'archive' ] [ 'exclude' ] ) ; } } } $ tempTarget = sys_get_temp_dir ( ) . '/composer_archive' . uniqid ( ) . '.' . $ format ; $ filesystem -> ensureDirectoryExists ( dirname ( $ tempTarget ) ) ; $ archivePath = $ usableArchiver -> archive ( $ sourcePath , $ tempTarget , $ format , $ package -> getArchiveExcludes ( ) , $ ignoreFilters ) ; $ filesystem -> rename ( $ archivePath , $ target ) ; if ( ! $ package instanceof RootPackageInterface ) { $ filesystem -> removeDirectory ( $ sourcePath ) ; } $ filesystem -> remove ( $ tempTarget ) ; return $ target ; }
9455	public function getQueries ( ) { $ array = [ ] ; foreach ( $ this -> getKeywords ( ) as $ keyword ) { $ value = $ keyword -> getData ( ) ; if ( $ this -> getCountableAttributes ( ) ) { $ value [ 'countableAttributes' ] = $ this -> getCountableAttributes ( ) ; } $ array [ ] = $ value ; } return $ array ; }
8176	public function actionRecoverPassword ( ) { $ model = new AccountRecoverPasswordForm ( ) ; if ( $ model -> load ( Yii :: $ app -> request -> post ( ) ) ) { if ( $ model -> validate ( ) ) { $ model -> recoverPassword ( ) ; } } return $ this -> render ( 'recoverPassword' , [ 'model' => $ model ] ) ; }
6769	public function onStateChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } $ this -> handleStateChange ( $ sale ) ; }
1713	protected function executePostActionsHook ( DataContainer $ dc ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> strAction , $ dc ) ; } } }
302	public function getAttributeLabel ( $ attribute ) { $ labels = $ this -> attributeLabels ( ) ; if ( isset ( $ labels [ $ attribute ] ) ) { return $ labels [ $ attribute ] ; } elseif ( strpos ( $ attribute , '.' ) ) { $ attributeParts = explode ( '.' , $ attribute ) ; $ neededAttribute = array_pop ( $ attributeParts ) ; $ relatedModel = $ this ; foreach ( $ attributeParts as $ relationName ) { if ( $ relatedModel -> isRelationPopulated ( $ relationName ) && $ relatedModel -> $ relationName instanceof self ) { $ relatedModel = $ relatedModel -> $ relationName ; } else { try { $ relation = $ relatedModel -> getRelation ( $ relationName ) ; } catch ( InvalidParamException $ e ) { return $ this -> generateAttributeLabel ( $ attribute ) ; } $ modelClass = $ relation -> modelClass ; $ relatedModel = $ modelClass :: instance ( ) ; } } $ labels = $ relatedModel -> attributeLabels ( ) ; if ( isset ( $ labels [ $ neededAttribute ] ) ) { return $ labels [ $ neededAttribute ] ; } } return $ this -> generateAttributeLabel ( $ attribute ) ; }
12357	public function updateEntryName ( ContentfulEntry $ entry ) { $ displayField = $ this -> getDisplayField ( ) ; $ values = array_values ( ( array ) $ entry -> { $ displayField } ) ; $ entry -> setName ( isset ( $ values [ 0 ] ) ? $ values [ 0 ] : 'Untitled' ) ; }
3404	public function lock ( Output $ output ) { if ( ! $ this -> lock ) { return ; } $ this -> lock = $ this -> getApplication ( ) -> getLockFactory ( ) -> createLock ( $ this -> getName ( ) ) ; if ( ! $ this -> lock -> acquire ( ) ) { $ output -> error ( "Another instance of this command (" . $ this -> getName ( ) . ") is currently running" ) ; exit ( Application :: STATUS_LOCKED ) ; } }
9600	public function length ( ) { $ sumOfSquares = 0 ; foreach ( $ this -> components ( ) as $ component ) { $ sumOfSquares += pow ( $ component , 2 ) ; } return sqrt ( $ sumOfSquares ) ; }
3781	private function determineFilterValue ( $ filterValues , $ valueName ) { if ( ! isset ( $ filterValues [ $ valueName ] ) && $ this -> get ( 'defaultid' ) ) { return $ this -> get ( 'defaultid' ) ; } return $ filterValues [ $ valueName ] ; }
11681	public function read ( $ id ) { $ path = $ this -> getPath ( $ id ) ; if ( ! file_exists ( $ path ) ) { return '' ; } if ( filemtime ( $ path ) < time ( ) - $ this -> lifeTime ) { return '' ; } return file_get_contents ( $ path ) ; }
3814	private function injectServiceContainerIntoDataDrivers ( $ providerDefinitions , $ environment ) { foreach ( $ providerDefinitions as $ provider ) { $ providerInstance = $ environment -> getDataProvider ( $ provider -> getName ( ) ) ; if ( $ providerInstance instanceof Driver ) { $ initialization = $ provider -> getInitializationData ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ initialization [ 'source' ] ) ; $ providerInstance -> setBaseConfig ( array_merge ( $ initialization , [ 'metaModel' => $ metaModel ] ) ) ; $ providerInstance -> setDispatcher ( $ this -> dispatcher ) ; $ providerInstance -> setConnection ( $ this -> connection ) ; } } }
10561	public function createController ( $ route , $ params ) { $ control = NULL ; $ route = ltrim ( $ route , '/' ) ; $ route = rtrim ( $ route , '/' ) ; $ vars = explode ( '/' , $ route ) ; if ( 1 === count ( $ vars ) && '' == $ vars [ 0 ] ) { $ control = $ this -> _buildControllerName ( $ this -> defaultController . 'Controller' ) ; $ aName = $ this -> _buildActionName ( $ control , $ this -> defaultAction ) ; } else if ( 1 === count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ this -> defaultAction ) ; } else if ( 2 === count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ vars [ 0 ] ) ; } else if ( 2 < count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ vars [ 0 ] ) ; array_shift ( $ vars ) ; } else { $ control = $ this -> _buildControllerName ( $ this -> defaultController . 'Controller' ) ; $ aName = $ this -> defaultAction . 'Action' ; } $ action = new Action ( $ aName , $ params ) ; $ controller = new $ control ( $ this -> config ) ; $ controller -> setAction ( $ action ) ; $ controller -> setDispatcher ( $ this -> dispatcher ) ; $ controller -> addDefaultListeners ( ) ; return $ controller ; }
3227	function buildUrlForGetOrPut ( $ host , $ path , $ params = null ) { return RequestUtil :: buildUrlForGetOrPut ( $ this -> userLocale , $ host , $ path , $ params ) ; }
3795	private function checkEmpty ( $ action ) { if ( $ this -> hasVariants ( ) && $ this -> currentModel !== null ) { $ this -> disablePA = false ; } elseif ( $ action == 'create' ) { $ this -> disablePA = false ; $ this -> disablePI = false ; } }
323	public static function titleize ( $ words , $ ucAll = false ) { $ words = static :: humanize ( static :: underscore ( $ words ) , $ ucAll ) ; return $ ucAll ? StringHelper :: mb_ucwords ( $ words , self :: encoding ( ) ) : StringHelper :: mb_ucfirst ( $ words , self :: encoding ( ) ) ; }
889	private function shouldClearToken ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; return ! $ token -> isComment ( ) && ! ( $ token -> isWhitespace ( ) && $ tokens [ $ index + 1 ] -> isComment ( ) ) ; }
11122	public function getEndLocation ( ) { $ lastLocation = $ this -> getLocation ( ) ; $ lastDate = NOW ; foreach ( $ this -> movements as $ v ) { if ( $ v -> getEndTime ( ) > $ lastDate ) { $ lastDate = $ v -> getEndTime ( ) ; $ lastLocation = $ v -> getEndLocation ( ) ; } } return $ lastLocation ; }
2295	public static function getTinyTemplates ( ) { $ strDir = Config :: get ( 'uploadPath' ) . '/tiny_templates' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strDir ) ) { return '' ; } $ arrFiles = array ( ) ; $ arrTemplates = scan ( $ rootDir . '/' . $ strDir ) ; foreach ( $ arrTemplates as $ strFile ) { if ( strncmp ( '.' , $ strFile , 1 ) !== 0 && is_file ( $ rootDir . '/' . $ strDir . '/' . $ strFile ) ) { $ arrFiles [ ] = '{ title: "' . $ strFile . '", url: "' . $ strDir . '/' . $ strFile . '" }' ; } } return implode ( ",\n" , $ arrFiles ) . "\n" ; }
12063	public function can_save_post_meta ( $ post_id , $ action , $ nonce ) { $ is_autosave = wp_is_post_autosave ( $ post_id ) ; $ is_revision = wp_is_post_revision ( $ post_id ) ; $ is_valid_nonce = ( isset ( $ _POST [ $ nonce ] ) && wp_verify_nonce ( $ _POST [ $ nonce ] , $ action ) ) ; return ! ( $ is_autosave || $ is_revision ) && $ is_valid_nonce ; }
12714	protected function resolveMethodParameters ( $ params = [ ] ) { if ( ! is_array ( $ params ) ) { throw new \ InvalidArgumentException ( sprintf ( "Parameter 1 of %s must be an array." , __METHOD__ ) ) ; } foreach ( $ params as $ key => $ value ) { if ( $ value instanceof \ ReflectionParameter ) { $ class = $ value -> getClass ( ) ; if ( $ class instanceof \ ReflectionClass ) { if ( $ class -> isInterface ( ) ) { $ params [ $ key ] = $ this -> getConcreteFromInterface ( $ class -> getName ( ) ) ; } else { $ params [ $ key ] = $ this -> circularDependencyResolver ( $ class -> getName ( ) ) ; } } else { $ params [ $ key ] = ( $ value -> isDefaultValueAvailable ( ) ? $ value -> getDefaultValue ( ) : null ) ; } } else { if ( is_string ( $ value ) && class_exists ( $ value ) ) { $ params [ $ key ] = $ this -> circularDependencyResolver ( $ value ) ; } elseif ( $ value instanceof \ Closure ) { $ params [ $ key ] = $ value ( $ this ) ; } else { $ params [ $ key ] = $ value ; } } } return $ params ; }
98	public function add ( $ prefix , $ paths , $ prepend = false ) { if ( ! $ prefix ) { if ( $ prepend ) { $ this -> fallbackDirsPsr0 = array_merge ( ( array ) $ paths , $ this -> fallbackDirsPsr0 ) ; } else { $ this -> fallbackDirsPsr0 = array_merge ( $ this -> fallbackDirsPsr0 , ( array ) $ paths ) ; } return ; } $ first = $ prefix [ 0 ] ; if ( ! isset ( $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] ) ) { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = ( array ) $ paths ; return ; } if ( $ prepend ) { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = array_merge ( ( array ) $ paths , $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] ) ; } else { $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] = array_merge ( $ this -> prefixesPsr0 [ $ first ] [ $ prefix ] , ( array ) $ paths ) ; } }
5452	public function startElement ( $ name , $ attributes ) { $ factory = new SimpleTagBuilder ( ) ; $ tag = $ factory -> createTag ( $ name , $ attributes ) ; if ( ! $ tag ) { return true ; } if ( $ tag -> getTagName ( ) === 'label' ) { $ this -> acceptLabelStart ( $ tag ) ; $ this -> openTag ( $ tag ) ; return true ; } if ( $ tag -> getTagName ( ) === 'form' ) { $ this -> acceptFormStart ( $ tag ) ; return true ; } if ( $ tag -> getTagName ( ) === 'frameset' ) { $ this -> acceptFramesetStart ( $ tag ) ; return true ; } if ( $ tag -> getTagName ( ) === 'frame' ) { $ this -> acceptFrame ( $ tag ) ; return true ; } if ( $ tag -> isPrivateContent ( ) && ! isset ( $ this -> private_content_tag ) ) { $ this -> private_content_tag = $ tag ; } if ( $ tag -> expectEndTag ( ) ) { $ this -> openTag ( $ tag ) ; return true ; } $ this -> acceptTag ( $ tag ) ; return true ; }
5015	public function logFinish ( FinishEvent $ event ) : void { $ this -> getLogger ( ) -> info ( sprintf ( $ this -> tmpl [ 'queue' ] , 'Stop' , $ event -> getQueue ( ) -> getName ( ) ) ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
8712	public function whereTranslated ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( func_num_args ( ) == 2 ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } elseif ( $ this -> invalidOperatorAndValue ( $ operator , $ value ) ) { throw new InvalidArgumentException ( 'Illegal operator and value combination.' ) ; } if ( ! in_array ( strtolower ( $ operator ) , $ this -> operators , true ) ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } $ fallbackColumn = $ this -> qualifyTranslationColumn ( $ column , true ) ; $ column = $ this -> qualifyTranslationColumn ( $ column ) ; if ( ! $ this -> model -> shouldFallback ( ) || $ column instanceof Closure ) { return $ this -> where ( $ column , $ operator , $ value , $ boolean ) ; } $ condition = $ this -> compileIfNull ( $ column , $ fallbackColumn ) ; return $ this -> whereRaw ( "$condition $operator ?" , [ $ value ] , $ boolean ) ; }
6295	private function parseThemeInfo ( array $ info ) { $ themeInfo = new ThemeInfo ( ) ; $ required = [ 'name' , 'author' , 'directory' ] ; foreach ( $ required as $ key ) { if ( ! array_key_exists ( $ key , $ info ) ) { throw new ThemeInfoAttributeException ( $ key ) ; } } $ themeInfo -> setName ( $ info [ 'name' ] ) ; $ themeInfo -> setAuthor ( $ info [ 'author' ] ) ; $ themeInfo -> setDirectory ( strtolower ( $ info [ 'directory' ] ) ) ; if ( isset ( $ info [ 'description' ] ) ) { $ themeInfo -> setDescription ( $ info [ 'description' ] ) ; } if ( isset ( $ info [ 'version' ] ) ) { $ themeInfo -> setVersion ( $ info [ 'version' ] ) ; } if ( isset ( $ info [ 'parent' ] ) ) { $ themeInfo -> setParent ( $ info [ 'parent' ] ) ; } $ themeInfo -> setPath ( $ this -> findPath ( $ info [ 'directory' ] ) ) ; return $ themeInfo ; }
6520	private function populateDefault ( Field $ field ) { if ( $ this -> has ( $ field -> getName ( ) ) ) { return true ; } $ default = $ field -> getDefault ( $ this ) ; if ( null === $ default ) { return false ; } if ( $ field -> isASingleValue ( ) ) { $ this -> data [ $ field -> getName ( ) ] = $ default ; unset ( $ this -> clearedFields [ $ field -> getName ( ) ] ) ; return true ; } if ( empty ( $ default ) ) { return false ; } if ( $ field -> isASet ( ) ) { $ this -> addToSet ( $ field -> getName ( ) , $ default ) ; return true ; } $ this -> data [ $ field -> getName ( ) ] = $ default ; unset ( $ this -> clearedFields [ $ field -> getName ( ) ] ) ; return true ; }
6580	public static function fromPolar ( $ length , $ ap , $ av ) { return new static ( $ length * cos ( $ ap ) * cos ( $ av ) , $ length * sin ( $ ap ) * cos ( $ av ) , $ length * sin ( $ av ) ) ; }
779	public function get ( $ name ) { return isset ( $ this -> _cookies [ $ name ] ) ? $ this -> _cookies [ $ name ] : null ; }
2980	public function addResource ( Bundle $ bundle ) { if ( ! file_exists ( $ this -> file ) ) { throw new \ RuntimeException ( sprintf ( 'The target config file %s does not exist' , $ this -> file ) ) ; } $ code = $ this -> getImportCode ( $ bundle ) ; $ currentContents = file_get_contents ( $ this -> file ) ; if ( false !== strpos ( $ currentContents , $ code ) ) { throw new \ RuntimeException ( sprintf ( 'The %s configuration file from %s is already imported' , $ bundle -> getServicesConfigurationFilename ( ) , $ bundle -> getName ( ) ) ) ; } $ lastImportedPath = $ this -> findLastImportedPath ( $ currentContents ) ; if ( ! $ lastImportedPath ) { throw new \ RuntimeException ( sprintf ( 'Could not find the imports key in %s' , $ this -> file ) ) ; } $ importsPosition = strpos ( $ currentContents , 'imports:' ) ; $ lastImportPosition = strpos ( $ currentContents , $ lastImportedPath , $ importsPosition ) ; $ targetLinebreakPosition = strpos ( $ currentContents , "\n" , $ lastImportPosition ) ; $ newContents = substr ( $ currentContents , 0 , $ targetLinebreakPosition ) . "\n" . $ code . substr ( $ currentContents , $ targetLinebreakPosition ) ; if ( false === Generator :: dump ( $ this -> file , $ newContents ) ) { throw new \ RuntimeException ( sprintf ( 'Could not write file %s ' , $ this -> file ) ) ; } }
5042	public function setListener ( $ listener ) { $ listener -> getSharedManager ( ) -> attach ( '*' , NotificationEvent :: EVENT_NOTIFICATION_HTML , array ( $ this , 'createOutput' ) , 1 ) ; $ this -> notificationListener = $ listener ; }
9583	public function addCachedRoute ( Route $ route ) { $ this -> routes -> attach ( $ route ) ; if ( $ name = $ route -> getName ( ) ) { $ this -> addNamedRoute ( $ name , $ route ) ; } }
3323	protected function consumeOptionToken ( Option $ spec , $ arg , $ next , & $ success = false ) { if ( $ spec -> isFlag ( ) ) { if ( $ spec -> isIncremental ( ) ) { $ spec -> increaseValue ( ) ; } else { $ spec -> setValue ( true ) ; } return 0 ; } else if ( $ spec -> isRequired ( ) ) { if ( $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> setValue ( $ next -> arg ) ; return 1 ; } else { throw new RequireValueException ( "Option '{$arg->getOptionName()}' requires a value." ) ; } } else if ( $ spec -> isMultiple ( ) ) { if ( $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ this -> pushOptionValue ( $ spec , $ arg , $ next ) ; return 1 ; } } else if ( $ spec -> isOptional ( ) && $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> setValue ( $ next -> arg ) ; return 1 ; } return 0 ; }
1856	protected function getPageLayout ( $ objPage ) { $ objLayout = LayoutModel :: findByPk ( $ objPage -> layout ) ; if ( null === $ objLayout ) { $ this -> log ( 'Could not find layout ID "' . $ objPage -> layout . '"' , __METHOD__ , TL_ERROR ) ; throw new NoLayoutSpecifiedException ( 'No layout specified' ) ; } $ objPage -> hasJQuery = $ objLayout -> addJQuery ; $ objPage -> hasMooTools = $ objLayout -> addMooTools ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objPage , $ objLayout , $ this ) ; } } return $ objLayout ; }
1957	public function generate ( ) { if ( $ this -> vimeo == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://vimeo.com/' . $ this -> vimeo . '" target="_blank" rel="noreferrer noopener">vimeo.com/' . $ this -> vimeo . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
11686	public function getLocation ( $ location , $ owner = null ) { $ bucket = $ this -> getBucket ( 'locations:' . $ location ) ; if ( is_null ( $ owner ) ) { return $ bucket -> toArray ( ) ; } else { $ result = [ ] ; foreach ( $ bucket as $ key => $ widget ) { if ( $ widget -> owner === $ owner ) { $ result [ $ key ] = $ widget ; } } return $ result ; } }
1921	private function getIndexLength ( Table $ table , string $ column ) : ? int { $ col = $ table -> getColumn ( $ column ) ; if ( null === ( $ length = $ col -> getLength ( ) ) ) { return null ; } if ( $ length <= 191 ) { return null ; } if ( $ col -> hasPlatformOption ( 'collation' ) ) { $ collation = $ col -> getPlatformOption ( 'collation' ) ; } else { $ collation = $ table -> getOption ( 'collate' ) ; } $ defaultLength = $ this -> getDefaultIndexLength ( $ table ) ; $ bytes = 0 === strncmp ( $ collation , 'utf8mb4' , 7 ) ? 4 : 3 ; $ indexLength = ( int ) floor ( $ defaultLength / $ bytes ) ; if ( $ length <= $ indexLength ) { return null ; } return $ indexLength ; }
8788	public function style ( $ url , $ attributes = [ ] , $ secure = null ) { $ defaults = [ 'media' => 'all' , 'type' => 'text/css' , 'rel' => 'stylesheet' ] ; $ attributes = array_merge ( $ attributes , $ defaults ) ; $ attributes [ 'href' ] = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> toHtmlString ( '<link' . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL ) ; }
4520	public function set ( string $ key , $ value ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ parameter -> setKey ( $ key ) -> setValue ( $ value ) ; $ this -> manager -> persist ( $ parameter ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> detach ( $ parameter ) ; }
3297	public function doAutoRunEnhancements ( LeadEvent $ event ) { $ lead = $ event -> getLead ( ) ; if ( $ lead && ( null !== $ lead -> getDateIdentified ( ) || ! $ lead -> isAnonymous ( ) ) ) { $ leadKey = strtolower ( implode ( '|' , [ $ lead -> getFirstname ( ) , ( $ lead -> getLastActive ( ) ? $ lead -> getLastActive ( ) -> format ( 'c' ) : '' ) , $ lead -> getEmail ( ) , $ lead -> getPhone ( ) , $ lead -> getMobile ( ) , ] ) ) ; if ( strlen ( $ leadKey ) > 3 ) { if ( isset ( $ this -> leadsEnhanced [ $ leadKey ] ) ) { return ; } else { $ this -> leadsEnhanced [ $ leadKey ] = true ; } } $ integrations = $ this -> enhancerHelper -> getEnhancerIntegrations ( ) ; foreach ( $ integrations as $ integration ) { $ settings = $ integration -> getIntegrationSettings ( ) ; if ( $ settings -> getIsPublished ( ) ) { $ features = $ settings -> getFeatureSettings ( ) ; if ( isset ( $ features [ 'autorun_enabled' ] ) && $ features [ 'autorun_enabled' ] ) { try { $ integration -> doEnhancement ( $ lead ) ; } catch ( \ Exception $ exception ) { $ e = new ApiErrorException ( 'There was an issue using enhancer: ' . $ integration -> getName ( ) , 0 , $ exception ) ; if ( ! empty ( $ lead ) ) { $ e -> setContact ( $ lead ) ; } throw $ e ; } } } } $ this -> logger -> info ( 'doAutoRunEnhancements complete' ) ; } }
405	public function addCorsHeaders ( $ response , $ headers ) { if ( empty ( $ headers ) === false ) { $ responseHeaders = $ response -> getHeaders ( ) ; foreach ( $ headers as $ field => $ value ) { $ responseHeaders -> set ( $ field , $ value ) ; } } }
6120	public function serverStart ( $ sid ) { if ( $ sid == $ this -> serverSelectedId ( ) ) { $ this -> serverDeselect ( ) ; } $ this -> execute ( "serverstart" , array ( "sid" => $ sid ) ) ; $ this -> serverListReset ( ) ; Signal :: getInstance ( ) -> emit ( "notifyServerstarted" , $ this , $ sid ) ; }
1665	public function getListForSelect ( $ display = 'name' ) { foreach ( $ this -> getList ( $ display ) as $ key => $ value ) { $ countries [ $ key ] = $ value [ $ display ] ; } return $ countries ; }
8978	protected function getRateKey ( $ currencyCode , $ date , $ rateType , $ sourceName ) { return str_replace ( [ '%currency_code%' , '%date%' , '%rate_type%' , '%source_name%' ] , [ $ currencyCode , $ date -> format ( 'Y-m-d' ) , $ rateType , $ sourceName ] , '%currency_code%_%date%_%rate_type%_%source_name%' ) ; }
6675	public function add_meta_boxes ( $ post_type , $ post ) { App :: setCurrentID ( 'EFG' ) ; $ is_active = $ this -> get_rating_state ( $ post -> ID ) ; if ( App :: main ( ) -> is_publish_post ( $ post ) && $ is_active ) { $ this -> add_styles ( ) ; $ this -> add_scripts ( ) ; add_meta_box ( 'info_movie-rating-movie' , __ ( 'Extensions For Grifus - Custom rating' , 'extensions-for-grifus-rating' ) , [ $ this , 'render_meta_boxes' ] , $ post_type , 'normal' , 'high' ) ; } }
5353	public function getSupportedAuthentication ( ) { if ( empty ( $ this -> data -> authentication ) || empty ( $ this -> data -> authentication ) ) { return array ( ) ; } return ( array ) $ this -> data -> authentication ; }
3109	public function getCatValue ( $ assessmentSectionId , $ key ) { return ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) ? $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] : null ; }
12609	public function getParent ( $ type ) { if ( isset ( $ this -> _parents [ $ type ] ) ) { return $ this -> _parents [ $ type ] ; } return false ; }
55	public function download ( PackageInterface $ package , $ targetDir , $ preferSource = null ) { $ preferSource = null !== $ preferSource ? $ preferSource : $ this -> preferSource ; $ sourceType = $ package -> getSourceType ( ) ; $ distType = $ package -> getDistType ( ) ; $ sources = array ( ) ; if ( $ sourceType ) { $ sources [ ] = 'source' ; } if ( $ distType ) { $ sources [ ] = 'dist' ; } if ( empty ( $ sources ) ) { throw new \ InvalidArgumentException ( 'Package ' . $ package . ' must have a source or dist specified' ) ; } if ( ! $ preferSource && ( $ this -> preferDist || 'dist' === $ this -> resolvePackageInstallPreference ( $ package ) ) ) { $ sources = array_reverse ( $ sources ) ; } $ this -> filesystem -> ensureDirectoryExists ( $ targetDir ) ; foreach ( $ sources as $ i => $ source ) { if ( isset ( $ e ) ) { $ this -> io -> writeError ( ' <warning>Now trying to download from ' . $ source . '</warning>' ) ; } $ package -> setInstallationSource ( $ source ) ; try { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> download ( $ package , $ targetDir ) ; } break ; } catch ( \ RuntimeException $ e ) { if ( $ i === count ( $ sources ) - 1 ) { throw $ e ; } $ this -> io -> writeError ( ' <warning>Failed to download ' . $ package -> getPrettyName ( ) . ' from ' . $ source . ': ' . $ e -> getMessage ( ) . '</warning>' ) ; } } }
4860	public function push ( JobInterface $ job , array $ options = [ ] ) { $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; $ result = $ this -> mongoCollection -> insertOne ( $ envelope ) ; $ job -> setId ( ( string ) $ result -> getInsertedId ( ) ) ; }
11475	public function setObjectType ( $ type ) { if ( ! is_object ( $ type ) ) { if ( Yii :: $ app -> collectors [ 'types' ] -> has ( $ type ) ) { $ type = Yii :: $ app -> collectors [ 'types' ] -> getOne ( $ type ) -> object ; } else { $ type = null ; } } $ this -> _objectType = $ type ; }
1388	protected function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotSupportClientIds ( $ type , $ path ) ) ; }
11326	public static function removeSuffix ( $ string , $ suffix ) { if ( static :: hasSuffix ( $ string , $ suffix ) ) { return substr ( $ string , 0 , - strlen ( $ suffix ) ) ; } return $ string ; }
2042	public static function validateSymlink ( string $ target , string $ link , string $ rootDir ) : void { if ( '' === $ target ) { throw new \ InvalidArgumentException ( 'The symlink target must not be empty.' ) ; } if ( '' === $ link ) { throw new \ InvalidArgumentException ( 'The symlink path must not be empty.' ) ; } if ( false !== strpos ( $ link , '../' ) ) { throw new \ InvalidArgumentException ( 'The symlink path must not be relative.' ) ; } $ fs = new Filesystem ( ) ; if ( $ fs -> exists ( $ rootDir . '/' . $ link ) && ! is_link ( $ rootDir . '/' . $ link ) ) { throw new \ LogicException ( sprintf ( 'The path "%s" exists and is not a symlink.' , $ link ) ) ; } }
4418	protected function createRequest ( Content $ content , Location $ location ) { $ request = Request :: create ( '' ) ; $ request -> attributes -> set ( 'content' , $ content ) ; $ request -> attributes -> set ( 'location' , $ location ) ; if ( interface_exists ( 'eZ\Publish\Core\MVC\Symfony\View\ContentValueView' ) ) { $ contentView = new ContentView ( ) ; $ contentView -> setLocation ( $ location ) ; $ contentView -> setContent ( $ content ) ; $ request -> attributes -> set ( 'view' , $ contentView ) ; } return $ request ; }
565	public function getScriptFile ( ) { if ( $ this -> _scriptFile === null ) { if ( isset ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ) { $ this -> setScriptFile ( $ _SERVER [ 'SCRIPT_FILENAME' ] ) ; } else { throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } } return $ this -> _scriptFile ; }
8719	public function fresh ( $ with = [ ] ) { if ( ! $ this -> exists ) { return ; } $ query = static :: newQueryWithoutScopes ( ) -> with ( is_string ( $ with ) ? func_get_args ( ) : $ with ) -> where ( $ this -> getKeyName ( ) , $ this -> getKey ( ) ) ; ( new TranslatableScope ( ) ) -> apply ( $ query , $ this ) ; return $ query -> first ( ) ; }
3311	protected function getTokenFormApi ( ) { $ http = $ this -> getHttp ( ) ; $ token = $ http -> parseJson ( $ http -> post ( self :: API_TOKEN_URI , [ 'grant_type' => 'client_credentials' , 'client_id' => $ this -> getAppKey ( ) , 'client_secret' => $ this -> getSecretKey ( ) ] ) ) ; if ( empty ( $ token [ $ this -> tokenSucessKey ] ) ) { throw new RuntimeException ( 'Request AccessToken fail. response: ' . json_encode ( $ token , JSON_UNESCAPED_UNICODE ) ) ; } return $ token ; }
2281	protected static function httpHost ( ) { if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_HOST' ] ; } else { $ host = $ _SERVER [ 'SERVER_NAME' ] ; if ( $ _SERVER [ 'SERVER_PORT' ] != 80 ) { $ host .= ':' . $ _SERVER [ 'SERVER_PORT' ] ; } } return preg_replace ( '/[^A-Za-z0-9[\].:-]/' , '' , $ host ) ; }
5666	private function attachLabels ( $ widgets_by_id , $ labels ) { foreach ( $ labels as $ label ) { $ for = $ label -> getFor ( ) ; if ( $ for and isset ( $ widgets_by_id [ $ for ] ) ) { $ text = $ label -> getText ( ) ; foreach ( $ widgets_by_id [ $ for ] as $ widget ) { $ widget -> setLabel ( $ text ) ; } } } }
9347	public function isDiagonal ( ) { $ int_size = min ( ( array ) $ this -> size ) ; if ( $ int_size > 0 ) { for ( $ i = 0 ; $ i < $ int_size ; $ i ++ ) { $ arr_row = $ this -> getRow ( $ i ) ; if ( $ arr_row [ $ i ] != 0 ) { unset ( $ arr_row [ $ i ] ) ; foreach ( $ arr_row as $ v ) { if ( $ v != 0 ) { return false ; } } } else { return false ; } } return true ; } return false ; }
6559	public function get_number_type ( $ phone_number = '' , $ region = NULL ) { $ inputParams = array ( 'phone_number' => $ phone_number , 'region' => $ region ) ; $ this -> debug -> info ( __FUNCTION__ , 'Input Params: ' , $ inputParams ) ; if ( empty ( $ phone_number ) ) { $ this -> debug -> warning ( __FUNCTION__ , 'Phone Number input is Empty!' ) ; return NULL ; } $ phone_number = trim ( $ phone_number ) ; try { $ phoneNumberUtil = PhoneNumberUtil :: getInstance ( ) ; $ use_region = NULL !== $ region ? strtoupper ( $ region ) : self :: DEFAULT_REGION ; $ phoneNumberObject = $ phoneNumberUtil -> parse ( trim ( $ phone_number ) , $ use_region ) ; $ result = $ phoneNumberUtil -> getNumberType ( $ phoneNumberObject ) ; $ this -> debug -> debug ( __FUNCTION__ , 'Use REGION: ' . $ use_region ) ; $ this -> debug -> info ( __FUNCTION__ , 'Final Result: ' . $ result ) ; return $ result ; } catch ( \ Exception $ e ) { $ message = 'Error File: ' . $ e -> getFile ( ) . ' - Line: ' . $ e -> getLine ( ) . ' - Code: ' . $ e -> getCode ( ) . ' - Message: ' . $ e -> getMessage ( ) ; $ this -> debug -> error ( __FUNCTION__ , $ message ) ; return NULL ; } }
6531	protected function applyAnalyzer ( array $ mapping , Field $ field , \ stdClass $ rootObject , $ path = null ) { if ( null === $ this -> defaultAnalyzer ) { return $ mapping ; } if ( ! isset ( $ mapping [ 'type' ] ) || 'text' !== $ mapping [ 'type' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'index' ] ) && false === $ mapping [ 'index' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'analyzer' ] ) ) { return $ mapping ; } $ mapping [ 'analyzer' ] = $ this -> defaultAnalyzer ; return $ mapping ; }
1138	public function destroyDescendants ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ lft ) -> where ( $ rgtCol , '<' , $ rgt ) -> delete ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ rgt ) -> decrement ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>' , $ rgt ) -> decrement ( $ rgtCol , $ diff ) ; } ) ; }
12112	public function getForeignDataModel ( $ key ) { $ config = $ this -> settings [ 'foreignPullParams' ] ; if ( ! isset ( $ config [ 'where' ] ) ) { $ config [ 'where' ] = [ ] ; } if ( ! empty ( $ config [ 'where' ] ) ) { $ config [ 'where' ] = [ 'and' , $ config [ 'where' ] , [ $ this -> foreignModel -> primaryKey ( ) => $ key ] ] ; } else { $ config [ 'where' ] [ $ this -> foreignModel -> primaryKey ( ) ] = $ key ; } return $ this -> foreignModel -> findOne ( $ config ) ; }
11913	public function current ( ) { $ current = current ( $ this -> storage ) ; if ( $ this -> useMapEntries ) { return new MapEntry ( $ current [ 0 ] , $ current [ 1 ] ) ; } return $ current [ 1 ] ; }
7322	public function sidereal ( $ mode = 'a' , Angle $ lon = null ) { $ ut = $ this -> copy ( ) -> toUT1 ( ) ; $ uta = $ ut -> jd ; $ utb = $ ut -> dayFrac ; $ ut = null ; $ tt = $ this -> copy ( ) -> toTT ( ) ; $ tta = $ tt -> jd ; $ ttb = $ tt -> dayFrac ; $ tt = null ; $ st ; if ( $ mode == 'a' ) { $ strad = IAU :: Gst06a ( $ uta , $ utb , $ tta , $ ttb ) ; } else { $ strad = IAU :: Gmst06 ( $ uta , $ utb , $ tta , $ ttb ) ; } if ( $ lon ) { $ st = Angle :: rad ( $ strad ) -> add ( $ lon ) -> norm ( ) -> toTime ( ) ; } else { $ st = Angle :: rad ( $ strad ) -> toTime ( ) ; } return $ st ; }
7837	public function register ( ) { $ className = studly_case ( strtolower ( config ( 'message.vendor' , 'smsgatewayme' ) ) ) ; $ classPath = '\Yugo\SMSGateway\Vendors\\' . $ className ; if ( ! class_exists ( $ classPath ) ) { abort ( 500 , sprintf ( 'SMS vendor %s is not available.' , $ className ) ) ; } app ( ) -> bind ( SMS :: class , $ classPath ) ; }
7952	public function setReverseProperties ( $ ipblock , $ ip , $ reverse ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Parameter $ip is missing.' ) ; $ payload = array ( 'ipReverse' => $ ip , 'reverse' => $ reverse ) ; try { $ r = $ this -> post ( 'ip/' . urlencode ( $ ipblock ) . '/reverse' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
3699	private function parseListing ( ) { $ listing = $ this -> definition -> getListingConfig ( ) ; if ( null === $ listing -> getRootLabel ( ) ) { $ listing -> setRootLabel ( $ this -> metaModel -> get ( 'name' ) ) ; } if ( null === $ listing -> getRootIcon ( ) ) { $ listing -> setRootIcon ( $ this -> iconBuilder -> getBackendIcon ( $ this -> inputScreen [ 'meta' ] [ 'backendicon' ] ) ) ; } $ this -> parseListSorting ( $ listing ) ; $ this -> parseListLabel ( $ listing ) ; $ listing -> setShowColumns ( ( bool ) $ this -> inputScreen [ 'meta' ] [ 'showColumns' ] ) ; }
9400	public function export ( ) { foreach ( $ this -> messages as $ message ) { list ( $ msg , $ level , $ catagory , $ timestamp , $ traces ) = $ message ; $ errStr = '' ; $ options = [ 'level' => yii \ log \ Logger :: getLevelName ( $ level ) , 'extra' => [ ] , ] ; $ templateData = null ; if ( is_array ( $ msg ) ) { $ errStr = isset ( $ msg [ 'msg' ] ) ? $ msg [ 'msg' ] : '' ; if ( isset ( $ msg [ 'data' ] ) ) $ options [ 'extra' ] = $ msg [ 'data' ] ; } else { $ errStr = $ msg ; } $ traces = array_map ( function ( $ v ) { return "{$v['file']}" . PHP_EOL . "{$v['class']}::{$v['function']} [{$v['line']}]" ; } , $ traces ) ; if ( ! empty ( $ traces ) ) $ options [ 'extra' ] [ 'traces' ] = $ traces ; $ this -> client -> captureMessage ( $ errStr , array ( ) , $ options , false ) ; } }
346	private static function mergeCssClasses ( array $ existingClasses , array $ additionalClasses ) { foreach ( $ additionalClasses as $ key => $ class ) { if ( is_int ( $ key ) && ! in_array ( $ class , $ existingClasses ) ) { $ existingClasses [ ] = $ class ; } elseif ( ! isset ( $ existingClasses [ $ key ] ) ) { $ existingClasses [ $ key ] = $ class ; } } return array_unique ( $ existingClasses ) ; }
3612	public function setTargetTemperatureMode ( $ mode , $ temperature = NULL , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; if ( $ temperature !== NULL ) { if ( $ mode == TARGET_TEMP_MODE_RANGE ) { if ( ! is_array ( $ temperature ) || count ( $ temperature ) != 2 || ! is_numeric ( $ temperature [ 0 ] ) || ! is_numeric ( $ temperature [ 1 ] ) ) { echo "Error: when using TARGET_TEMP_MODE_RANGE, you need to set the target temperatures (second argument of setTargetTemperatureMode) using an array of two numeric values.\n" ; return FALSE ; } $ temp_low = $ this -> temperatureInCelsius ( $ temperature [ 0 ] , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temperature [ 1 ] , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } elseif ( $ mode != TARGET_TEMP_MODE_OFF ) { if ( ! is_numeric ( $ temperature ) ) { echo "Error: when using TARGET_TEMP_MODE_HEAT or TARGET_TEMP_MODE_COLD, you need to set the target temperature (second argument of setTargetTemperatureMode) using an numeric value.\n" ; return FALSE ; } $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } } $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_type' => $ mode ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
6186	public function renderInclude ( $ name , $ path = null ) { $ twigConfig = Config :: load ( 'twig' ) ; $ pathFile = pathFile ( $ name ) ; $ folder = $ pathFile [ 0 ] ; $ name = $ pathFile [ 1 ] ; $ path = $ twigConfig -> get ( 'setTemplateDir' ) . DIRECTORY_SEPARATOR . $ folder . $ name . $ twigConfig -> get ( 'fileExtension' , '.twig' ) ; try { if ( ! is_file ( $ path ) ) { throw new ViewException ( 'Can not open template ' . $ name . ' in: ' . $ path ) ; } $ renderInclude = $ this -> twig -> render ( $ name , $ this -> assign ) ; } catch ( ViewException $ e ) { echo $ e -> getMessage ( ) . '<br /> File: ' . $ e -> getFile ( ) . '<br /> Code line: ' . $ e -> getLine ( ) . '<br /> Trace: ' . $ e -> getTraceAsString ( ) ; exit ( ) ; } return $ renderInclude ; }
6550	public function current ( ) { if ( $ this -> iterator -> valid ( ) === false ) { return null ; } $ iterator = $ this -> iterator -> current ( ) -> getCellIterator ( ) ; $ iterator -> setIterateOnlyExistingCells ( false ) ; $ result = [ ] ; foreach ( $ iterator as $ cell ) { $ result [ ] = $ cell -> getValue ( ) ; } return $ result ; }
11920	public function onPageRemoved ( PageCollectionRemovedEvent $ event ) { $ pageName = basename ( $ event -> getFilePath ( ) ) ; $ page = $ this -> pagesParser -> contributor ( $ event -> getUsername ( ) ) -> parse ( ) -> page ( $ pageName ) ; if ( null === $ page ) { return ; } foreach ( $ page [ "seo" ] as $ seo ) { $ permalink = $ seo [ "permalink" ] ; $ this -> permalinkManager -> remove ( $ permalink ) ; } $ this -> permalinkManager -> save ( ) ; }
9656	public function merge ( array $ routes ) { foreach ( $ routes as $ name => $ route ) { $ this -> override ( $ name , $ route ) ; } }
3799	private function checkModelWithoutVariants ( $ containedModel ) { $ parentDefinition = $ this -> environment -> getDataDefinition ( ) -> getBasicDefinition ( ) -> getParentDataProvider ( ) ; $ this -> disablePA = ( $ this -> currentModel -> getId ( ) == $ containedModel -> getId ( ) ) || ( $ parentDefinition && $ this -> currentModel -> getProperty ( 'pid' ) == $ containedModel -> getProperty ( 'pid' ) ) ; $ this -> disablePI = ( $ this -> circularReference ) || ( $ this -> currentModel -> getId ( ) == $ containedModel -> getId ( ) ) || ( $ parentDefinition && $ this -> currentModel -> getProperty ( 'pid' ) == $ containedModel -> getId ( ) ) ; }
11778	public function startAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , ) ; return parent :: start ( $ options ) ; }
4490	public function createTopic ( string $ name ) : string { $ res = $ this -> sns -> createTopic ( [ 'Name' => $ name , ] ) ; return $ res [ 'TopicArn' ] ; }
1933	protected function getLocaleString ( ) { $ container = System :: getContainer ( ) ; return 'var Contao={' . 'theme:"' . Backend :: getTheme ( ) . '",' . 'lang:{' . 'close:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'close' ] . '",' . 'collapse:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] . '",' . 'expand:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] . '",' . 'loading:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'loadingData' ] . '",' . 'apply:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'apply' ] . '"' . '},' . 'script_url:"' . $ container -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) . '",' . 'path:"' . Environment :: get ( 'path' ) . '",' . 'request_token:"' . REQUEST_TOKEN . '",' . 'referer_id:"' . $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) . '"' . '};' ; }
4446	public function tagged ( string $ tag , int $ offset = 0 , int $ limit = 25 ) : array { $ response = json_decode ( $ this -> client -> call ( 'tag' , 'get' , $ tag , $ offset , $ limit ) , true ) ; if ( empty ( $ response [ 'jobs' ] ) ) { $ response [ 'jobs' ] = [ ] ; } return $ response [ 'jobs' ] ; }
8247	public function userDataEncodePassword ( & $ userData , Password $ newPassword ) { $ encoderName = $ this -> config [ "encoder" ] ; $ encoder = $ this -> picoAuth -> getContainer ( ) -> get ( $ encoderName ) ; $ userData [ 'pwhash' ] = $ encoder -> encode ( $ newPassword -> get ( ) ) ; $ userData [ 'encoder' ] = $ encoderName ; if ( isset ( $ userData [ 'pwreset' ] ) ) { unset ( $ userData [ 'pwreset' ] ) ; } }
12320	public static function getBundleLocationName ( string $ sName ) : string { $ oConfig = self :: get ( $ sName , null , true ) ; if ( isset ( $ oConfig -> redirect ) ) { return $ oConfig -> redirect ; } else { return PORTAL ; } }
4859	public function getNeighbours ( $ namespace , $ callback , $ id ) { $ list = $ this -> getList ( $ namespace , $ callback ) ; $ list -> setCurrent ( $ id ) ; return [ $ list -> getPrevious ( ) , $ list -> getNext ( ) ] ; }
6800	public function installCurrencies ( $ code = 'USD' ) { $ currencyNames = Intl :: getCurrencyBundle ( ) -> getCurrencyNames ( ) ; if ( ! isset ( $ currencyNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default currency code '$code'." ) ; } asort ( $ currencyNames ) ; $ this -> generate ( Currency :: class , $ currencyNames , $ code ) ; }
1216	public static function stableSort ( array $ data , callable $ sortFn ) { array_walk ( $ data , function ( & $ v , $ k ) { $ v = [ $ v , $ k ] ; } ) ; uasort ( $ data , function ( $ a , $ b ) use ( $ sortFn ) { return $ sortFn ( $ a [ 0 ] , $ b [ 0 ] ) ? : ( $ a [ 1 ] < $ b [ 1 ] ? - 1 : 1 ) ; } ) ; return array_map ( function ( $ v ) { return $ v [ 0 ] ; } , array_values ( $ data ) ) ; }
5068	public function setOpt ( int $ option , string $ value ) : bool { return curl_share_setopt ( $ this -> sh , $ option , $ value ) ; }
3686	protected function getAndOrFilter ( IFilter $ filter , $ operation ) { if ( ! $ operation [ 'children' ] ) { return ; } if ( $ operation [ 'operation' ] == 'AND' ) { $ filterRule = new ConditionAnd ( ) ; } else { $ filterRule = new ConditionOr ( ) ; } $ filter -> addFilterRule ( $ filterRule ) ; $ children = $ this -> optimizedFilter ( $ filterRule , $ operation [ 'children' ] , $ operation [ 'operation' ] ) ; foreach ( $ children as $ child ) { $ subFilter = $ this -> getMetaModel ( ) -> getEmptyFilter ( ) ; $ filterRule -> addChild ( $ subFilter ) ; $ this -> calculateSubfilter ( $ child , $ subFilter ) ; } }
4641	private function buildCallback ( BuildInfo $ output ) { $ message = "" ; if ( $ output -> getError ( ) ) { $ this -> logger -> error ( sprintf ( "Error when creating job: %s\n" , $ output -> getError ( ) ) , array ( 'static' => false , 'static-id' => null ) ) ; return ; } if ( $ output -> getStream ( ) ) { $ message = $ output -> getStream ( ) ; } if ( $ output -> getStatus ( ) ) { $ message = $ output -> getStatus ( ) ; if ( $ output -> getProgress ( ) ) { $ message .= " " . $ output -> getProgress ( ) ; } } if ( ! $ output -> getId ( ) && ! preg_match ( '#\n#' , $ message ) ) { $ message .= "\n" ; } $ this -> logger -> debug ( $ message , array ( 'static' => $ output -> getId ( ) !== null , 'static-id' => $ output -> getId ( ) , ) ) ; }
4794	function group ( $ columns , $ having = "" ) { $ this -> __destruct ( ) ; $ this -> group = $ columns ; $ this -> having = $ having ; return $ this ; }
4440	public static function sigName ( int $ signal ) : string { $ signals = [ 'SIGHUP' , 'SIGINT' , 'SIGQUIT' , 'SIGILL' , 'SIGTRAP' , 'SIGABRT' , 'SIGIOT' , 'SIGBUS' , 'SIGFPE' , 'SIGKILL' , 'SIGUSR1' , 'SIGSEGV' , 'SIGUSR2' , 'SIGPIPE' , 'SIGALRM' , 'SIGTERM' , 'SIGSTKFLT' , 'SIGCLD' , 'SIGCHLD' , 'SIGCONT' , 'SIGSTOP' , 'SIGTSTP' , 'SIGTTIN' , 'SIGTTOU' , 'SIGURG' , 'SIGXCPU' , 'SIGXFSZ' , 'SIGVTALRM' , 'SIGPROF' , 'SIGWINCH' , 'SIGPOLL' , 'SIGIO' , 'SIGPWR' , 'SIGSYS' , 'SIGBABY' , ] ; foreach ( $ signals as $ name ) { if ( defined ( $ name ) && constant ( $ name ) === $ signal ) { return $ name ; } } return 'UNKNOWN' ; }
5939	public function setExtraData ( array $ extraData ) { $ this -> extraData = [ ] ; foreach ( $ extraData as $ item ) { $ this -> addExtraData ( $ item ) ; } return $ this ; }
7471	public function createAction ( Request $ request ) { $ user = new User ( ) ; $ form = $ this -> createForm ( UserType :: class , $ user ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ user -> setPassword ( $ encoder -> encodePassword ( $ user -> getPassword ( ) , $ user -> getSalt ( ) ) ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The user has been created.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ user -> getId ( ) ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) ) ; }
2172	private function purgeSymfonyCache ( ) : void { $ filesystem = new Filesystem ( ) ; $ cacheDir = $ this -> getContainerParameter ( 'kernel.cache_dir' ) ; $ ref = new \ ReflectionObject ( $ this -> container ) ; $ containerDir = basename ( \ dirname ( $ ref -> getFileName ( ) ) ) ; $ finder = Finder :: create ( ) -> depth ( 0 ) -> exclude ( $ containerDir ) -> in ( $ cacheDir ) ; foreach ( $ finder as $ file ) { $ filesystem -> remove ( $ file -> getPathname ( ) ) ; } if ( \ function_exists ( 'opcache_reset' ) ) { opcache_reset ( ) ; } if ( \ function_exists ( 'apc_clear_cache' ) && ! ini_get ( 'apc.stat' ) ) { apc_clear_cache ( ) ; } }
5744	public static function getDatabaseColumnValidationValue ( ColumnMapper $ databaseColumnMapper , string $ validationType ) { foreach ( self :: getDatabaseColumnValidation ( $ databaseColumnMapper ) as $ validation ) { if ( ! is_array ( $ validation ) && $ validation == $ validationType ) { return true ; } elseif ( is_array ( $ validation ) && $ validation [ 0 ] == $ validationType ) { return $ validation [ 1 ] ; } } return false ; }
839	public static function fromCode ( $ code ) { $ codeHash = self :: calculateCodeHash ( $ code ) ; if ( self :: hasCache ( $ codeHash ) ) { $ tokens = self :: getCache ( $ codeHash ) ; $ tokens -> generateCode ( ) ; if ( $ codeHash === $ tokens -> codeHash ) { $ tokens -> clearEmptyTokens ( ) ; $ tokens -> clearChanged ( ) ; return $ tokens ; } } $ tokens = new self ( ) ; $ tokens -> setCode ( $ code ) ; $ tokens -> clearChanged ( ) ; return $ tokens ; }
5599	public function tally ( ) { while ( list ( $ severity , $ message , $ file , $ line ) = $ this -> extract ( ) ) { $ severity = $ this -> getSeverityAsString ( $ severity ) ; $ this -> test -> error ( $ severity , $ message , $ file , $ line ) ; } while ( list ( $ expected , $ message ) = $ this -> extractExpectation ( ) ) { $ this -> test -> assert ( $ expected , false , '%s -> Expected error not caught' ) ; } }
10570	protected function parseSort ( string $ sort , array & $ sorts ) { if ( strlen ( trim ( $ sort ) ) === 0 ) { return ; } if ( substr ( $ sort , 0 , 1 ) == "[" ) { $ json = json_decode ( $ sort ) ; if ( is_array ( $ json ) ) { foreach ( $ json as $ s ) { if ( is_object ( $ s ) ) { $ sorts [ $ s -> property ] = strcasecmp ( self :: DESC , $ s -> direction ) !== 0 ; } } return ; } } if ( substr ( $ sort , - 4 ) == ",asc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 4 ) ] = true ; } elseif ( substr ( $ sort , - 5 ) == ",desc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 5 ) ] = false ; } elseif ( substr ( $ sort , - 10 ) == ":ascending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 10 ) ] = true ; } elseif ( substr ( $ sort , - 11 ) == ":descending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 11 ) ] = false ; } else { foreach ( explode ( ',' , $ sort ) as $ s ) { if ( substr ( $ s , 0 , 1 ) === '-' ) { $ sorts [ substr ( $ s , 1 ) ] = false ; } elseif ( substr ( $ s , 0 , 1 ) === '+' ) { $ sorts [ substr ( $ s , 1 ) ] = true ; } else { $ sorts [ $ s ] = true ; } } } }
8882	private function isValidGlobalCommand ( string $ command ) : bool { $ valid = false ; if ( strlen ( $ command ) ) { foreach ( $ this -> paths as $ pathDir ) { $ tmpPath = $ pathDir . DIRECTORY_SEPARATOR . $ command ; if ( $ this -> isValidFullPath ( $ tmpPath ) ) { $ valid = true ; break ; } } } return $ valid ; }
12202	public function create ( int $ status = 200 , array $ headers = [ ] , $ body = null ) : ResponseInterface { return new Response ( $ status , $ headers , $ body ) ; }
10450	public function delete ( $ key ) { try { $ this -> get ( $ key ) ; } catch ( KeyNotFoundException $ e ) { return false ; } return $ this -> getClient ( ) -> delete ( $ key ) ; }
11053	public static function sprintts ( $ datatree , $ containers , $ entry = 'main' ) { return $ this -> sprintt ( $ datatree , $ containers , $ entry , _ETS_STRING_READ , '' , '' ) ; }
9349	public function multiplyAllow ( $ matrix ) { if ( is_numeric ( $ matrix ) ) { return true ; } if ( $ matrix instanceof Complex ) { return true ; } if ( $ matrix instanceof Matrix ) { return $ this -> size -> cols == $ matrix -> rows ; } return false ; }
8139	public function load ( $ name ) { if ( $ name instanceof Twig_TemplateWrapper ) { return $ name ; } if ( $ name instanceof Twig_Template ) { return new Twig_TemplateWrapper ( $ this , $ name ) ; } return new Twig_TemplateWrapper ( $ this , $ this -> loadTemplate ( $ name ) ) ; }
2726	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , 'magentomodule_basic_auth' ) ; if ( ! $ dictionary || ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) ) { return $ result -> setData ( [ 'status' => 'none' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ authItems = false ; if ( isset ( $ dictionary -> id ) ) { $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; } if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'There are no dictionary items.' ] ) ; } if ( ! $ authItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch dictionary items.' ] ) ; } foreach ( $ authItems as $ key => $ item ) { $ userData = explode ( ':' , base64_decode ( $ item -> item_key ) ) ; $ username = $ userData [ 0 ] ; $ item -> item_key_id = $ item -> item_key ; $ item -> item_key = $ username ; $ authItems [ $ key ] = $ item ; } return $ result -> setData ( [ 'status' => true , 'auths' => $ authItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1558	protected function doesRequireOrdering ( $ query ) { if ( ! $ this -> primaryKey ) { return false ; } $ query = ( $ query instanceof Relation ) ? $ query -> getBaseQuery ( ) : $ query -> getQuery ( ) ; return ! collect ( $ query -> orders ? : [ ] ) -> contains ( function ( array $ order ) { $ col = $ order [ 'column' ] ?? '' ; return $ this -> primaryKey === $ col ; } ) ; }
9071	protected function prepareException ( Exception $ e ) { $ e = parent :: prepareException ( $ e ) ; if ( $ e instanceof PermissionDoesNotExist || $ e instanceof AuthorizationException ) { $ e = new AuthenticationException ( $ e -> getMessage ( ) ) ; } return $ e ; }
4597	public function setDeserializeValues ( ? bool $ deserializeValues ) { $ this -> deserializeValues = $ deserializeValues ; $ this -> _deserializeValues = null !== $ deserializeValues ; return $ this ; }
8576	public function setItemChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9393	public function withStatus ( $ code , $ reason = '' ) { $ static = clone $ this ; $ static -> code = $ code ; $ static -> reason = $ reason ? : $ static -> codes [ $ code ] ; return $ static ; }
9210	protected function printValidationErrors ( $ table , $ id , $ errors ) { foreach ( $ errors as $ field => $ messages ) { foreach ( ( array ) $ messages as $ message ) { $ this -> quiet ( "<warning>{$table} ({$id}): {$field}: {$message}</warning>" ) ; } } }
337	protected function extractColumnType ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> dbType = $ dbType ; if ( strpos ( $ dbType , 'FLOAT' ) !== false || strpos ( $ dbType , 'DOUBLE' ) !== false ) { $ column -> type = 'double' ; } elseif ( strpos ( $ dbType , 'NUMBER' ) !== false ) { if ( $ scale === null || $ scale > 0 ) { $ column -> type = 'decimal' ; } else { $ column -> type = 'integer' ; } } elseif ( strpos ( $ dbType , 'INTEGER' ) !== false ) { $ column -> type = 'integer' ; } elseif ( strpos ( $ dbType , 'BLOB' ) !== false ) { $ column -> type = 'binary' ; } elseif ( strpos ( $ dbType , 'CLOB' ) !== false ) { $ column -> type = 'text' ; } elseif ( strpos ( $ dbType , 'TIMESTAMP' ) !== false ) { $ column -> type = 'timestamp' ; } else { $ column -> type = 'string' ; } }
4819	public function getIterator ( IteratorFilter $ itf = null ) { if ( is_null ( $ itf ) ) { return new AnyIterator ( $ this -> collection ) ; } return new AnyIterator ( $ itf -> match ( $ this -> collection ) ) ; }
4311	public function output ( $ options = array ( ) ) { $ cfgRestore = $ this -> config -> setCfg ( $ options ) ; if ( ! $ this -> cfg [ 'output' ] ) { $ this -> config -> setCfg ( $ cfgRestore ) ; return null ; } $ outputAs = $ this -> output -> getCfg ( 'outputAs' ) ; if ( \ is_string ( $ outputAs ) ) { $ this -> output -> setCfg ( 'outputAs' , $ outputAs ) ; } $ channels = $ this -> getChannels ( true ) ; $ channels [ ] = $ this ; $ headers = array ( ) ; foreach ( $ channels as $ channel ) { $ event = $ channel -> eventManager -> publish ( 'debug.output' , $ channel , array ( 'headers' => array ( ) , 'return' => '' , 'isTarget' => $ channel === $ this , ) ) ; $ headers = \ array_merge ( $ headers , $ event [ 'headers' ] ) ; } if ( ! $ this -> getCfg ( 'outputHeaders' ) || ! $ headers ) { $ this -> data [ 'headers' ] = \ array_merge ( $ this -> data [ 'headers' ] , $ event [ 'headers' ] ) ; } elseif ( \ headers_sent ( $ file , $ line ) ) { \ trigger_error ( 'PHPDebugConsole: headers already sent: ' . $ file . ', line ' . $ line , E_USER_NOTICE ) ; } else { foreach ( $ headers as $ nameVal ) { \ header ( $ nameVal [ 0 ] . ': ' . $ nameVal [ 1 ] ) ; } } if ( ! $ this -> parentInstance ) { $ this -> data [ 'outputSent' ] = true ; } $ this -> config -> setCfg ( $ cfgRestore ) ; return $ event [ 'return' ] ; }
10326	function addRule ( $ rule ) { if ( ! $ this -> rules ) $ this -> rules = array ( ) ; array_push ( $ this -> rules , $ rule ) ; }
5464	public function isWithin ( $ url ) { if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) ) ) { return true ; } if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) . $ url -> getPage ( ) . '/' ) ) { return true ; } return false ; }
11213	protected function removeFromLookup ( $ registry ) { foreach ( $ this -> lookup_pool as $ idx => $ reg ) { if ( $ registry === $ reg ) { if ( $ reg instanceof DelegatorAwareInterface ) { $ reg -> setDelegator ( ) ; } unset ( $ this -> lookup_pool [ $ idx ] ) ; } } return $ this ; }
6337	public function parse ( SaxHandlerInterface $ saxHandler , $ xmlDocument ) { $ xmlDocument = ( $ xmlDocument instanceof StreamInterface ) ? $ xmlDocument : $ this -> getDocumentStream ( $ xmlDocument ) ; return $ saxHandler -> parse ( $ xmlDocument ) ; }
3675	private function collectAttributeFactories ( $ container ) { $ attributeFactory = $ container -> getDefinition ( 'metamodels.attribute_factory' ) ; foreach ( array_keys ( $ container -> findTaggedServiceIds ( self :: TAG_ATTRIBUTE_FACTORY ) ) as $ factory ) { $ attributeFactory -> addMethodCall ( 'addTypeFactory' , [ new Reference ( $ factory ) ] ) ; } }
11595	private function getPageId ( ) { if ( preg_match ( '/\/page\/(\w+)$/' , $ this -> name , $ matches ) ) { $ id = $ matches [ 1 ] ; } else { $ id = $ this -> environment -> getRequestHelper ( ) -> getIdentifierParam ( 'id' , null , true ) ; } return $ id ; }
7433	public function export ( Defender $ defender ) { $ content = json_encode ( $ defender -> dangerFiles ) ; $ name = 'defender/defender-' . $ this -> date . '.json' ; if ( $ this -> storage -> exists ( $ name ) ) { $ this -> storage -> delete ( $ name ) ; } $ this -> storage -> put ( $ name , $ content ) ; }
2640	public function cleanUrl ( $ url ) { $ result = $ this -> _purge ( $ url , 'PURGE' , 'PURGE' ) ; if ( $ result [ 'status' ] ) { $ this -> logger -> execute ( $ url ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishKeyUrlChanges ( ) ) { $ this -> sendWebHook ( '*clean by URL for* ' . $ url ) ; } return $ result ; }
6332	public function createResponse ( $ status , $ errorCode , $ errorDescription ) { $ document = new \ DOMDocument ( '1.0' , 'utf-8' ) ; $ document -> formatOutput = false ; $ response = $ document -> appendChild ( $ document -> createElement ( 'SVSPurchaseStatusNotificationResponse' ) ) ; $ result = $ response -> appendChild ( $ document -> createElement ( 'TransactionResult' ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Description' , $ errorDescription ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Code' , $ errorCode ) ) ; $ response -> appendChild ( $ document -> createElement ( 'Status' , $ status ) ) ; $ authentication = $ response -> appendChild ( $ document -> createElement ( 'Authentication' ) ) ; $ checksum = $ authentication -> appendChild ( $ document -> createElement ( 'Checksum' , $ this -> getMerchantPassword ( ) ) ) ; $ checksum -> nodeValue = $ this -> calculateXmlChecksum ( $ document -> saveXML ( ) ) ; return $ document -> saveXML ( ) ; }
2084	public function rotateLogs ( ) { @ trigger_error ( 'Using Automator::rotateLogs() has been deprecated and will no longer work in Contao 5.0. Use the logger service instead, which rotates its log files automatically.' , E_USER_DEPRECATED ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrFiles = preg_grep ( '/\.log$/' , scan ( $ rootDir . '/system/logs' ) ) ; foreach ( $ arrFiles as $ strFile ) { $ objFile = new File ( 'system/logs/' . $ strFile . '.9' ) ; if ( $ objFile -> exists ( ) ) { $ objFile -> delete ( ) ; } for ( $ i = 8 ; $ i > 0 ; $ i -- ) { $ strGzName = 'system/logs/' . $ strFile . '.' . $ i ; if ( file_exists ( $ rootDir . '/' . $ strGzName ) ) { $ objFile = new File ( $ strGzName ) ; $ objFile -> renameTo ( 'system/logs/' . $ strFile . '.' . ( $ i + 1 ) ) ; } } $ objFile = new File ( 'system/logs/' . $ strFile ) ; $ objFile -> renameTo ( 'system/logs/' . $ strFile . '.1' ) ; } }
10520	public function constraint ( $ string ) { if ( ! isset ( $ this -> tbl_constraint [ 'other' ] ) ) { $ this -> tbl_constraint [ 'other' ] = [ ] ; } $ this -> tbl_constraint [ 'other' ] [ ] = $ string ; return $ this ; }
5263	public function fields ( $ fields = false ) { if ( $ fields === false ) { $ this -> query [ 'body' ] [ '_source' ] = false ; } elseif ( ( array ) $ fields == [ '*' ] ) { unset ( $ this -> query [ 'body' ] [ '_source' ] ) ; } else { $ this -> query [ 'body' ] [ '_source' ] = $ fields ; } return $ this ; }
1249	public function createService ( $ namespace , array $ config = [ ] ) { $ configuration = $ this -> config ; if ( isset ( $ this -> config [ $ namespace ] ) ) { $ configuration = arrayMergeDeep ( $ configuration , $ this -> config [ $ namespace ] ) ; } $ configuration = arrayMergeDeep ( $ configuration , $ config ) ; $ service = "DTS\\eBaySDK\\{$namespace}\\Services\\{$namespace}Service" ; return new $ service ( $ configuration ) ; }
2896	public function captureEmail ( ) { $ email = Mage :: getModel ( 'sheep_debug/email' ) ; $ email -> setFromEmail ( $ this -> getFromEmail ( ) ) ; $ email -> setFromName ( $ this -> getFromName ( ) ) ; $ email -> setToEmail ( $ this -> getToEmail ( ) ) ; $ email -> setToName ( $ this -> getToName ( ) ) ; $ email -> setSubject ( $ this -> getSubject ( ) ) ; $ email -> setIsPlain ( $ this -> getType ( ) != 'html' ) ; $ email -> setBody ( $ this -> getBody ( ) ) ; $ email -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; $ email -> setIsAccepted ( true ) ; $ requestInfo = Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) ; $ requestInfo -> addEmail ( $ email ) ; }
11861	public function getCompanionId ( ) { if ( $ this -> isForeign && isset ( $ this -> foreignPrimaryKey ) ) { return $ this -> foreignPrimaryKey ; } elseif ( ! $ this -> isForeign && isset ( $ this -> localPrimaryKey ) ) { return $ this -> localPrimaryKey ; } if ( isset ( $ this -> companionObject ) ) { return $ this -> companionObject -> primaryKey ; } return ; }
2034	public function onRegister ( Registry $ registry ) { parent :: onRegister ( $ registry ) ; if ( $ this -> fallback && $ this -> type == 'root' && ! $ registry -> isRegisteredAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ) { $ registry -> registerAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ; } }
8276	public function triggerEvent ( $ eventName , array $ params = array ( ) ) { foreach ( $ this -> modules as $ module ) { $ module -> handleEvent ( $ eventName , $ params ) ; } }
5577	public function clickImage ( $ label , $ x = 1 , $ y = 1 , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormByImage ( new SelectByLabel ( $ label ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitImage ( new SelectByLabel ( $ label ) , $ x , $ y , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
6790	protected function merge ( array $ cachedUnits , array $ fetchedUnits ) { $ cachedIds = [ ] ; foreach ( $ cachedUnits as $ unit ) { if ( null !== $ id = $ unit -> getId ( ) ) { $ cachedIds [ ] = $ unit -> getId ( ) ; } } foreach ( $ fetchedUnits as $ unit ) { if ( in_array ( $ unit -> getId ( ) , $ cachedIds ) ) { continue ; } if ( $ this -> unitCache -> isRemoved ( $ unit ) ) { continue ; } if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ unit ) ) { continue ; } $ cachedUnits [ ] = $ unit ; } return $ cachedUnits ; }
4554	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; foreach ( $ this -> removed as $ property ) { if ( array_key_exists ( $ property , $ payload ) ) { $ event -> markAsInvalid ( ) ; break ; } } }
1279	private function extractSpaceId ( array $ data ) : string { if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Space' === $ data [ 'sys' ] [ 'type' ] ) { return $ data [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Environment' === $ data [ 'sys' ] [ 'type' ] ) { return $ this -> spaceId ; } if ( isset ( $ data [ 'sys' ] [ 'space' ] ) ) { return $ data [ 'sys' ] [ 'space' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'space' ] ) ) { return $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'space' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] ) && ! $ data [ 'items' ] ) { return $ this -> spaceId ; } return '[blank]' ; }
5509	public function expect ( $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments' ) ; $ this -> expectations -> expectArguments ( $ method , $ args , $ message ) ; $ args = $ this -> replaceWildcards ( $ args ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args [ strtolower ( $ method ) ] = new ParametersExpectation ( $ args , $ message ) ; }
1692	protected function shortenHexColor ( $ color ) { if ( $ color [ 0 ] == $ color [ 1 ] && $ color [ 2 ] == $ color [ 3 ] && $ color [ 4 ] == $ color [ 5 ] ) { return $ color [ 0 ] . $ color [ 2 ] . $ color [ 4 ] ; } return $ color ; }
546	protected function getCreateTableSql ( $ table ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> quoteTableName ( $ table -> fullName ) ) -> queryOne ( ) ; if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } return $ sql ; }
5998	public function setMax ( $ max ) { if ( $ max instanceof DateTime ) { $ this -> max = $ max ; } else { try { $ this -> max = new DateTime ( $ max ) ; } catch ( \ Exception $ e ) { $ this -> max = null ; } } return $ this ; }
7553	protected function match_tags ( $ tags ) { $ res = false ; foreach ( $ tags as $ tag => $ match ) { if ( ! is_array ( $ match ) ) { $ match = array ( 'match' => $ match , 'operator' => 'or' , 'compare' => 'total' , 'case_sensitive' => false ) ; } else { if ( is_int ( $ tag ) ) { $ tag = $ match [ 'tag' ] ; } if ( ! isset ( $ match [ 'match' ] ) ) { $ match [ 'match' ] = true ; } if ( ! isset ( $ match [ 'operator' ] ) ) { $ match [ 'operator' ] = 'or' ; } if ( ! isset ( $ match [ 'compare' ] ) ) { $ match [ 'compare' ] = 'total' ; } if ( ! isset ( $ match [ 'case_sensitive' ] ) ) { $ match [ 'case_sensitive' ] = false ; } } if ( ( $ match [ 'operator' ] === 'and' ) && ( ! $ res ) ) { return false ; } elseif ( ! ( $ res && ( $ match [ 'operator' ] === 'or' ) ) ) { if ( $ match [ 'compare' ] === 'total' ) { $ a = $ this -> tag ; } elseif ( $ match [ 'compare' ] === 'namespace' ) { $ a = $ this -> getNamespace ( ) ; } elseif ( $ match [ 'compare' ] === 'name' ) { $ a = $ this -> getTag ( ) ; } if ( $ match [ 'case_sensitive' ] ) { $ res = ( ( $ a === $ tag ) === $ match [ 'match' ] ) ; } else { $ res = ( ( strcasecmp ( $ a , $ tag ) === 0 ) === $ match [ 'match' ] ) ; } } } return $ res ; }
3243	public function getShopUrlAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> shopUrl ; if ( ! property_exists ( $ this , 'itemRouteName' ) && ! property_exists ( $ this , 'itemRouteParams' ) ) return '#' ; $ params = [ ] ; foreach ( array_keys ( $ this -> attributes ) as $ attribute ) { if ( in_array ( $ attribute , $ this -> itemRouteParams ) ) $ params [ $ attribute ] = $ this -> attributes [ $ attribute ] ; } return empty ( $ this -> itemRouteName ) ? '#' : \ route ( $ this -> itemRouteName , $ params ) ; }
7714	function switchToRelative ( ) { $ this -> FindEndTag ( ) ; $ this -> rel_Txt = & $ this -> Txt ; $ this -> rel_PosBeg = $ this -> PosBeg ; $ this -> rel_Len = $ this -> GetLen ( ) ; $ src = $ this -> GetSrc ( ) ; $ this -> Txt = & $ src ; $ this -> _ApplyDiffToAll ( - $ this -> PosBeg ) ; }
7526	public static function parseFile ( $ path , $ context = null ) { $ html_str = file_get_contents ( $ path , false , $ context ) ; return static :: parseStr ( $ html_str ) ; }
2111	private function askForPassword ( string $ label , InputInterface $ input , OutputInterface $ output ) : string { $ question = new Question ( $ label ) ; $ question -> setHidden ( true ) ; $ question -> setMaxAttempts ( 3 ) ; $ helper = $ this -> getHelper ( 'question' ) ; return $ helper -> ask ( $ input , $ output , $ question ) ; }
4857	public function getParams ( $ namespace , $ defaults , $ params = null ) { $ session = new Container ( $ namespace ) ; $ sessionParams = $ session -> params ? : array ( ) ; $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; if ( $ params -> get ( 'clear' ) ) { $ sessionParams = array ( ) ; unset ( $ params [ 'clear' ] ) ; } $ changed = false ; foreach ( $ defaults as $ key => $ default ) { if ( is_numeric ( $ key ) ) { $ key = $ default ; $ default = null ; } $ value = $ params -> get ( $ key ) ; if ( null === $ value ) { if ( isset ( $ sessionParams [ $ key ] ) ) { $ params -> set ( $ key , $ sessionParams [ $ key ] ) ; } elseif ( null !== $ default ) { $ params -> set ( $ key , $ default ) ; $ sessionParams [ $ key ] = $ default ; $ changed = true ; } } else { if ( ! isset ( $ sessionParams [ $ key ] ) || $ sessionParams [ $ key ] != $ value ) { $ changed = true ; $ sessionParams [ $ key ] = $ value ; } } } if ( $ changed ) { unset ( $ session -> list ) ; $ session -> params = $ sessionParams ; } return $ params ; }
11942	private function validateArgument ( Request $ request , ConfigContainer $ config , $ position ) { $ value = null ; switch ( $ config -> getValue ( 'storage' ) ) { case 'url' : $ value = $ this -> validateUrl ( $ request , $ config , $ position ) ; break ; case 'post' : $ value = $ this -> validateGetPost ( $ request -> getData ( ) , $ config , $ position ) ; break ; case 'get' : $ value = $ this -> validateGetPost ( $ request -> getQuery ( ) , $ config , $ position ) ; break ; default : throw new InvalidConfigValueException ( 'storage' , $ config -> getValue ( 'storage' ) ) ; } $ validatorName = $ config -> getValue ( 'validator' ) ; if ( $ validatorName !== '' ) { $ validatorObject = new $ validatorName ( ) ; $ error = $ validatorObject -> validate ( $ value ) ; if ( $ error ) { throw new InvalidArgumentException ( $ position , $ config -> getValue ( 'name' ) , $ error ) ; } } $ mapperName = $ config -> getValue ( 'mapper' ) ; if ( $ mapperName !== '' ) { $ mapper = new $ mapperName ( $ this -> container ) ; $ value = $ mapper -> cast ( $ value ) ; } $ request -> setArgument ( $ config -> getValue ( 'name' ) , $ value ) ; }
3138	public function emptyResponse ( RunnerServiceContext $ context , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ similar = 0 ; foreach ( $ responses as $ responseVariable ) { $ value = $ responseVariable -> getValue ( ) ; $ default = $ responseVariable -> getDefaultValue ( ) ; if ( TestRunnerUtils :: isQtiValueNull ( $ value ) === true ) { if ( TestRunnerUtils :: isQtiValueNull ( $ default ) === true ) { $ similar ++ ; } } elseif ( $ value -> equals ( $ default ) === true ) { $ similar ++ ; } } $ respCount = count ( $ responses ) ; return $ respCount > 0 && $ similar == $ respCount ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
1867	private function validateSessionLifetime ( User $ user ) : void { if ( ! $ this -> session -> isStarted ( ) ) { return ; } $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ timeout = ( int ) $ config -> get ( 'sessionTimeout' ) ; if ( $ timeout > 0 && ( time ( ) - $ this -> session -> getMetadataBag ( ) -> getLastUsed ( ) ) < $ timeout ) { return ; } if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has been logged out automatically due to inactivity' , $ user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ user -> username ) ] ) ; } throw new UsernameNotFoundException ( sprintf ( 'User "%s" has been logged out automatically due to inactivity.' , $ user -> username ) ) ; }
12722	protected function turnIntoResolvableClosure ( $ abstract , $ concrete ) { return function ( Container $ container , $ parameters = [ ] ) use ( $ abstract , $ concrete ) { return ( $ abstract == $ concrete ? $ container -> resolve ( $ abstract ) : $ container -> resolve ( $ concrete , $ parameters ) ) ; } ; }
7853	protected function resolveRequest ( ) { if ( class_exists ( $ request = $ this -> inflector -> getRequest ( ) ) ) { return $ this -> container -> make ( $ request ) ; } return $ this -> container -> make ( 'Illuminate\Http\Request' ) ; }
9885	private function writeDefinedNameForNamedRange ( XMLWriter $ objWriter , NamedRange $ pNamedRange ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , $ pNamedRange -> getName ( ) ) ; if ( $ pNamedRange -> getLocalOnly ( ) ) { $ objWriter -> writeAttribute ( 'localSheetId' , $ pNamedRange -> getScope ( ) -> getParent ( ) -> getIndex ( $ pNamedRange -> getScope ( ) ) ) ; } $ range = Coordinate :: splitRange ( $ pNamedRange -> getRange ( ) ) ; $ iMax = count ( $ range ) ; for ( $ i = 0 ; $ i < $ iMax ; ++ $ i ) { $ range [ $ i ] [ 0 ] = '\'' . str_replace ( "'" , "''" , $ pNamedRange -> getWorksheet ( ) -> getTitle ( ) ) . '\'!' . Coordinate :: absoluteReference ( $ range [ $ i ] [ 0 ] ) ; if ( isset ( $ range [ $ i ] [ 1 ] ) ) { $ range [ $ i ] [ 1 ] = Coordinate :: absoluteReference ( $ range [ $ i ] [ 1 ] ) ; } } $ range = Coordinate :: buildRange ( $ range ) ; $ objWriter -> writeRawData ( $ range ) ; $ objWriter -> endElement ( ) ; }
9411	protected function exceptions ( \ Exception $ exception , $ uri ) { $ interface = 'Phroute\Phroute\Exception\HttpRouteNotFoundException' ; $ message = ( string ) $ exception -> getMessage ( ) ; is_a ( $ exception , $ interface ) && $ message = 'Route "' . $ uri . '" not found' ; throw new \ UnexpectedValueException ( ( string ) $ message ) ; }
7060	public function removeClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( false !== $ index = array_search ( $ class , $ classes ) ) { unset ( $ classes [ $ index ] ) ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
10355	public function incrementAttempts ( ) { $ this -> cache -> add ( $ this -> key , 0 , $ this -> getExpiry ( ) ) ; $ this -> cache -> increment ( $ this -> key ) ; }
5983	protected function withOAuth2MiddleWare ( HandlerStack $ stack ) { if ( ! ( $ this -> oauth2Middleware instanceof OAuthMiddleware ) ) { $ oauthClient = new Client ( [ 'base_uri' => $ this -> basepath , 'verify' => $ this -> verifyCertificates , 'headers' => [ 'User-Agent' => 'qbank3api-phpwrapper/2 (qbankapi: 1; swagger: 1.1)' , ] , ] ) ; $ config = [ PasswordCredentials :: CONFIG_USERNAME => $ this -> credentials -> getUsername ( ) , PasswordCredentials :: CONFIG_PASSWORD => $ this -> credentials -> getPassword ( ) , PasswordCredentials :: CONFIG_CLIENT_ID => $ this -> credentials -> getClientId ( ) , PasswordCredentials :: CONFIG_TOKEN_URL => 'oauth2/token' , ] ; $ this -> oauth2Middleware = new OAuthMiddleware ( $ oauthClient , new PasswordCredentials ( $ oauthClient , $ config ) , new RefreshToken ( $ oauthClient , $ config ) ) ; $ tokens = $ this -> getTokens ( ) ; if ( ! empty ( $ tokens [ 'accessTokens' ] ) ) { $ this -> oauth2Middleware -> setAccessToken ( $ tokens [ 'accessTokens' ] ) ; } if ( ! empty ( $ tokens [ 'refreshTokens' ] ) ) { $ this -> oauth2Middleware -> setRefreshToken ( $ tokens [ 'refreshTokens' ] ) ; } } $ stack -> push ( $ this -> oauth2Middleware -> onBefore ( ) ) ; $ stack -> push ( $ this -> oauth2Middleware -> onFailure ( 3 ) ) ; return $ stack ; }
7933	public function loadFromArray ( array $ data ) { list ( $ data ) = $ this -> fireEvent ( 'load-from-array' , [ $ data ] ) ; $ files = [ ] ; if ( isset ( $ data [ 'files' ] [ 'js' ] ) && is_array ( $ data [ 'files' ] [ 'js' ] ) ) $ files [ 'js' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'js' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; if ( isset ( $ data [ 'files' ] [ 'css' ] ) && is_array ( $ data [ 'files' ] [ 'css' ] ) ) $ files [ 'css' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'css' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; $ item = [ 'order' => isset ( $ data [ 'order' ] ) ? $ data [ 'order' ] : 0 , 'name' => isset ( $ data [ 'name' ] ) ? $ data [ 'name' ] : uniqid ( ) , 'files' => $ files , 'group' => isset ( $ data [ 'group' ] ) ? $ data [ 'group' ] : $ this -> defaultGroup , 'require' => isset ( $ data [ 'require' ] ) ? $ data [ 'require' ] : [ ] ] ; if ( isset ( $ item [ 'files' ] [ 'js' ] ) && is_array ( $ item [ 'files' ] [ 'js' ] ) ) $ item [ 'files' ] [ 'js' ] = $ this -> applyNamespaces ( $ item [ 'files' ] [ 'js' ] ) ; if ( isset ( $ item [ 'files' ] [ 'css' ] ) && is_array ( $ item [ 'files' ] [ 'css' ] ) ) $ item [ 'files' ] [ 'css' ] = $ this -> applyNamespaces ( $ item [ 'files' ] [ 'css' ] ) ; $ this -> loaded [ ] = $ item ; if ( isset ( $ item [ 'require' ] ) && is_array ( $ item [ 'require' ] ) ) { foreach ( $ item [ 'require' ] as $ name ) { $ this -> loadFromCollection ( $ name ) ; } } return $ this ; }
9889	public static function json ( $ response ) { $ body = self :: toString ( $ response ) ; $ data = json_decode ( $ body , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new RuntimeException ( 'Unable to parse response body into JSON: ' . json_last_error ( ) ) ; } return $ data === null ? [ ] : $ data ; }
12976	public function parseMappingInfo ( ) { $ mappings = array ( ) ; foreach ( $ this -> getMappings ( ) as $ mappingName => $ mappingConfig ) { if ( is_array ( $ mappingConfig ) === false or \ Arr :: get ( $ mappingConfig , 'mapping' , true ) === false ) { continue ; } $ mappingConfig = array_replace ( array ( 'dir' => false , 'type' => false , 'prefix' => false , ) , $ mappingConfig ) ; if ( isset ( $ mappingConfig [ 'is_component' ] ) === false ) { $ mappingConfig [ 'is_component' ] = false ; if ( is_dir ( $ mappingConfig [ 'dir' ] ) === false ) { $ mappingConfig [ 'is_component' ] = ( \ Package :: loaded ( $ mappingName ) or \ Module :: loaded ( $ mappingName ) ) ; } } if ( $ mappingConfig [ 'is_component' ] ) { $ mappingConfig = $ this -> getComponentDefaults ( $ mappingName , $ mappingConfig ) ; } if ( empty ( $ mappingConfig ) ) { continue ; } $ mappings [ $ mappingName ] = $ mappingConfig ; } $ this -> config [ 'mappings' ] = $ mappings ; }
619	public static function validateData ( array $ data , $ rules = [ ] ) { $ model = new static ( $ data ) ; if ( ! empty ( $ rules ) ) { $ validators = $ model -> getValidators ( ) ; foreach ( $ rules as $ rule ) { if ( $ rule instanceof Validator ) { $ validators -> append ( $ rule ) ; } elseif ( is_array ( $ rule ) && isset ( $ rule [ 0 ] , $ rule [ 1 ] ) ) { $ validator = Validator :: createValidator ( $ rule [ 1 ] , $ model , ( array ) $ rule [ 0 ] , array_slice ( $ rule , 2 ) ) ; $ validators -> append ( $ validator ) ; } else { throw new InvalidConfigException ( 'Invalid validation rule: a rule must specify both attribute names and validator type.' ) ; } } } $ model -> validate ( ) ; return $ model ; }
1466	public static function doesRequestHaveBody ( $ request ) { if ( self :: hasHeader ( $ request , 'Transfer-Encoding' ) ) { return true ; } ; if ( 1 > self :: getHeader ( $ request , 'Content-Length' ) ) { return false ; } return true ; }
5813	public function getCMSFields ( ) { $ fields = parent :: getCMSFields ( ) ; $ types = array ( ) ; foreach ( $ this -> service -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } if ( count ( $ types ) ) { $ fields -> replaceField ( 'TagTypes' , $ list = ListboxField :: create ( 'Types' , 'Tag Types' , $ types ) -> setMultiple ( true ) ) ; $ items = is_string ( $ this -> TagTypes ) ? array_keys ( unserialize ( $ this -> TagTypes ) ) : array ( ) ; $ list -> setValue ( $ items ) ; $ list -> setDisabledItems ( $ items ) ; } else { $ fields -> removeByName ( 'TagTypes' ) ; } $ this -> extend ( 'updateFusionTagCMSFields' , $ fields ) ; return $ fields ; }
9040	public function getMax ( string $ column ) : int { return $ this -> connection -> query ( 'SELECT IFNULL(MAX(%column), 0) position FROM %table' , $ column , $ this -> getTableName ( ) ) -> fetch ( ) -> position ; }
12816	private static function getColumns ( string $ table ) : array { if ( self :: $ columnsCache !== null && array_key_exists ( $ table , self :: $ columnsCache ) ) return self :: $ columnsCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT * FROM information_schema.columns WHERE table_name = '$table' " ; self :: $ columnsCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ columnsCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ columnsCache [ $ table ] ; }
5215	private function getAnnotatedBinding ( \ ReflectionClass $ class ) { $ annotations = annotationsOf ( $ class ) ; if ( $ class -> isInterface ( ) && $ annotations -> contain ( 'ImplementedBy' ) ) { return $ this -> bind ( $ class -> getName ( ) ) -> to ( $ this -> findImplementation ( $ annotations , $ class -> getName ( ) ) ) ; } elseif ( $ annotations -> contain ( 'ProvidedBy' ) ) { return $ this -> bind ( $ class -> getName ( ) ) -> toProviderClass ( $ annotations -> firstNamed ( 'ProvidedBy' ) -> getProviderClass ( ) ) ; } return $ this -> getImplicitBinding ( $ class ) ; }
10844	protected function calculateAttributePrice ( VariantInterface $ variant , $ amount ) { $ modifierType = $ variant -> getModifierType ( ) ; $ modifierValue = $ variant -> getModifierValue ( ) ; switch ( $ modifierType ) { case '+' : $ amount = $ amount + $ modifierValue ; break ; case '-' : $ amount = $ amount - $ modifierValue ; break ; case '%' : $ amount = $ amount * ( $ modifierValue / 100 ) ; break ; } return round ( $ amount , 2 ) ; }
2469	public function mapContentBlock ( Content $ content ) { $ contentInfo = $ content -> versionInfo -> contentInfo ; $ locations = $ this -> locationHandler -> loadLocationsByContent ( $ contentInfo -> id ) ; $ blockFields = $ this -> getBlockFields ( $ content ) ; $ contentFields = $ this -> getContentFields ( $ content ) ; $ documents = [ ] ; $ locationFieldsMap = [ ] ; foreach ( $ locations as $ location ) { $ locationFieldsMap [ $ location -> id ] = $ this -> getLocationFields ( $ location ) ; } foreach ( array_keys ( $ content -> versionInfo -> names ) as $ languageCode ) { $ blockTranslationFields = $ this -> getBlockTranslationFields ( $ content , $ languageCode ) ; $ translationLocationDocuments = array ( ) ; foreach ( $ locations as $ location ) { $ translationLocationDocuments [ ] = new Document ( array ( 'id' => $ this -> generateLocationDocumentId ( $ location -> id , $ languageCode ) , 'fields' => array_merge ( $ blockFields , $ locationFieldsMap [ $ location -> id ] , $ blockTranslationFields ) , ) ) ; } $ isMainTranslation = ( $ contentInfo -> mainLanguageCode === $ languageCode ) ; $ alwaysAvailable = ( $ isMainTranslation && $ contentInfo -> alwaysAvailable ) ; $ contentTranslationFields = $ this -> getContentTranslationFields ( $ content , $ languageCode ) ; $ documents [ ] = new Document ( array ( 'id' => $ this -> generateContentDocumentId ( $ contentInfo -> id , $ languageCode ) , 'languageCode' => $ languageCode , 'alwaysAvailable' => $ alwaysAvailable , 'isMainTranslation' => $ isMainTranslation , 'fields' => array_merge ( $ blockFields , $ contentFields , $ blockTranslationFields , $ contentTranslationFields ) , 'documents' => $ translationLocationDocuments , ) ) ; } return $ documents ; }
4631	protected function prepareRequestMethod ( ) { switch ( $ this -> command -> getMethod ( ) ) { case "POST" : $ this -> options [ CURLOPT_POST ] = 1 ; break ; case "PUT" : $ this -> options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; case "DELETE" : $ this -> options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case "HEAD" : $ this -> options [ CURLOPT_NOBODY ] = 1 ; break ; default : $ this -> options [ CURLOPT_HTTPGET ] = 1 ; } return $ this ; }
7292	public function get_users_by_meta ( $ meta_key , $ meta_value = '' , $ meta_compare = '' , $ include_empty = FALSE ) { if ( $ include_empty ) { if ( in_array ( $ meta_compare , array ( '<>' , '!=' ) ) ) { $ meta_compare = '=' ; } else { $ meta_compare = '!=' ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'ID' ) ) ; $ exclude_users = $ query -> get_results ( ) ; $ query = new WP_User_Query ( array ( 'fields' => 'all_with_meta' , 'exclude' => $ exclude_users ) ) ; return $ query -> get_results ( ) ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'all_with_meta' ) ) ; return $ query -> get_results ( ) ; }
